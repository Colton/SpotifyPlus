// SpotifyPlus variables
var employeeFeaturesEnabled = true;

(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
module.exports = {
  "settings": "Einstellungen",
  "upgrade": "Upgrade",
  "viewAccount": "Konto anzeigen",
  "language": "Sprache",
  "selectLanguage": "Sprache wählen",
  "selectProxy": "Proxytyp",
  "Host": "Host",
  "Port": "Port",
  "username": "Benutzername",
  "password": "Kennwort",
  "updateProxy": "Proxy aktualisieren",
  "social": "Social",
  "employeeFeatures": "Funktionen für Mitarbeiter",
  "appLinks": "Links zu Apps",
  "design": "Design",
  "designOptionAuto": "Auto",
  "designOptionGLUE1": "GLUE 1",
  "designOptionGLUE2": "GLUE 2",
  "newPlaylistsPublic": "Neue Playlists automatisch veröffentlichen",
  "privateSession": "Private Session",
  "privateSessionInfo": "Die private Session ist aktiv, bis du dich abmeldest.",
  "spotify": "Spotify",
  "facebook": "Facebook",
  "lastfm": "Last.fm",
  "seeWhatFriendsAreListening": "Finde heraus, was deine Freunde hören.",
  "shareOnFacebook": "Meine Aktivität auf Facebook teilen",
  "publishActivity": "Meine Aktivität auf Spotify veröffentlichen",
  "publishPlaylists": "Neue Playlists automatisch veröffentlichen",
  "publishTopArtists": "Meine aktuellen Top-Künstler anzeigen",
  "publishActivityTopListener": "Mich als Top-Hörer für Künstler veröffentlichen",
  "musicQuality": "Soundqualität",
  "hqStreaming": "Streaming mit hoher Qualität (nur Premium)",
  "devices": "Geräte",
  "connectToADevice": "Mit einem Gerät verbinden – Spotify auf Deinen Geräten hören und bedienen",
  "openDevicesMenu": "Menü der Geräte öffnen",
  "scrobbleToLastfm": "Zu Last.fm scrobbeln",
  "connectedAs": "Verbunden als",
  "logOut": "Abmelden",
  "about": "Information",
  "legal": "Rechtliches",
  "help": "Hilfe",
  "connect": "Verbinden",
  "connectFacebook": "Mit Facebook verbinden",
  "connectLastfm": "Mit Last.FM verbinden",
  "disconnectFacebook": "Von Facebook trennen",
  "disconnectLastfm": "Verbindung trennen",
  "startupAndWindowBehavior": "Hochfahr- und Fensterverhalten",
  "closeShouldMinimize": "Mit dem Schließen-Button minimierst Du das Spotify-Fenster in die Benachrichtigungsleiste.",
  "autostart": "Spotify automatisch beim Anmelden öffnen",
  "hideAdvancedSettings": "Erweiterte Einstellungen ausblenden",
  "showAdvancedSettings": "Erweiterte Einstellungen anzeigen",
  "autostartNormal": "Ja",
  "autostartMinimized": "Minimiert",
  "autostartOff": "Nein",
  "localFiles": "Lokale Dateien",
  "localFilesSources": "Songs zeigen von",
  "localFilesAddSource": "Quelle hinzufügen",
  "localFilesSource_downloads": "Downloads",
  "localFilesSource_itunes": "iTunes",
  "localFilesSource_my_music": "Meine Musik",
  "localFilesSource_windows_music_library": "Musikbibliothek",
  "localFilesSource_windows_media_player": "Windows Media Player",
  "accessibility": "Bedienungshilfen",
  "accessibilityColors": "Farben für Bedienungshilfe einschalten",
  "recoverPlaylists": "Playlists Widerholen",
  "playback": "Wiedergabe",
  "sameVolume": "Gleiche Lautstärke für alle Songs festlegen",
  "musicAnnouncements": "Musikankündigungen",
  "display": "Anzeigeoptionen",
  "showMusicAnnouncements": "Ankündigungen zu Neuerscheinungen anzeigen",
  "showUnavailableTracks": "Nicht verfügbare Songs in Playlists anzeigen",
  "friendFeed": "Freundes-Feed anzeigen",
  "showTrackNotifications": "Desktopbenachrichtigungen bei Songänderungen anzeigen",
  "cache": "Cache",
  "manuallySetCacheSize": "Cache-Größe manuell festlegen",
  "fileSystemLocationLabel": "Standort:",
  "changeLocation": "Standort ändern",
  "Proxy": "Proxy",
  "aboutSpotify": "Über Spotify",
  "auto-detect": "Automatische Erkennung",
  "no-proxy": "Kein Proxy",
  "http": "HTTP",
  "socks4": "Socks4",
  "socks5": "Socks5",
  "crossfadeTracks": "Songs überblenden",
  "tracks": "Songs",
  "sec": "Sek",
  "connectedToLastFmAs": "Mit Last.fm verbunden als {0}",
  "missingUsername": "Fehlender Benutzername",
  "missingPassword": "Fehlendes Kennwort",
  "invalidUsernameOrPassword": "Ungültiger Benutzername und/oder Kennwort",
  "compatibility": "Kompatibilität",
  "enableHardwareAcceleration": "Hardwarebeschleunigung aktivieren",
  "backToLogin": "Zurück zur Anmeldung",
  "webhelper": "Öffnen von Spotify über Web-Links erlauben"
};
},{}],2:[function(require,module,exports){
module.exports = {
  "settings": "Ρυθμίσεις",
  "upgrade": "Αναβάθμιση",
  "viewAccount": "Προβολή λογαριασμού",
  "language": "Γλώσσα",
  "selectLanguage": "Επιλογή γλώσσας",
  "selectProxy": "Τύπος διακομιστή",
  "Host": "Κεντρικός υπολογιστής",
  "Port": "Θύρα",
  "username": "Όνομα χρήστη",
  "password": "Κωδικός πρόσβασης",
  "updateProxy": "Ενημέρωση διακομιστή μεσολάβησης",
  "social": "Κοινωνικά δίκτυα",
  "employeeFeatures": "Χαρακτηριστικά εργαζομένου",
  "appLinks": "Σύνδεσμοι σε apps",
  "design": "Design",
  "designOptionAuto": "Αυτόματο",
  "designOptionGLUE1": "GLUE 1",
  "designOptionGLUE2": "GLUE 2",
  "newPlaylistsPublic": "Αυτόματη δημοσιοποίηση νέων λιστών",
  "privateSession": "Ιδιωτική περίοδος σύνδεσης",
  "privateSessionInfo": "η ιδιωτική περίοδος σύνδεσης διαρκεί μέχρι να αποσυνδεθείς",
  "spotify": "Spotify",
  "facebook": "Facebook",
  "lastfm": "Last.fm",
  "seeWhatFriendsAreListening": "Δες τι ακούνε οι φίλοι σου",
  "shareOnFacebook": "Κοινοποίηση δραστηριότητάς μου στο Facebook",
  "publishActivity": "Δημοσίευση δραστηριότητάς μου στο Spotify",
  "publishPlaylists": "Αυτόματη δημοσιοποίηση νέων λιστών",
  "publishTopArtists": "Εμφάνιση των Κορυφαίων καλλιτεχνών μου τώρα",
  "publishActivityTopListener": "Παρουσίασέ με ως Κορυφαίο ακροατή για καλλιτέχνες",
  "musicQuality": "Ποιότητα Μουσικής",
  "hqStreaming": "Streaming υψηλής ποιότητας (μόνο στο Premium)",
  "devices": "Συσκευές",
  "connectToADevice": "Σύνδεση σε συσκευή - Άκου και έλεγχε το Spotify στις συσκευές σου",
  "openDevicesMenu": "Άνοιξε το μενού Συσκευές",
  "scrobbleToLastfm": "Scrobble στο Last.fm",
  "connectedAs": "Έχεις συνδεθεί ως",
  "logOut": "Αποσύνδεση",
  "about": "Σχετικά με",
  "legal": "Νομικές πληροφορίες",
  "help": "Βοήθεια",
  "connect": "Σύνδεση",
  "connectFacebook": "Σύνδεση στο Facebook",
  "connectLastfm": "Σύνδεση με Last.FM",
  "disconnectFacebook": "Αποσύνδεση από το Facebook",
  "disconnectLastfm": "Αποσύνδεση",
  "startupAndWindowBehavior": "Εκκίνηση και συμπεριφορά παραθύρων",
  "closeShouldMinimize": "Το κουμπί Κλείσιμο θα πρέπει να ελαχιστοποιεί το παράθυρο του Spotify στον δίσκο",
  "autostart": "Να ανοίγει αυτόματα το Spotify μόλις συνδέεσαι στον υπολογιστή",
  "hideAdvancedSettings": "Απόκρυψη ρυθμίσεων για προχωρημένους",
  "showAdvancedSettings": "Εμφάνιση ρυθμίσεων για προχωρημένους",
  "autostartNormal": "Ναι",
  "autostartMinimized": "Ελαχιστοποιημένο",
  "autostartOff": "Όχι",
  "localFiles": "Τοπικά αρχεία",
  "localFilesSources": "Εμφάνιση τραγουδιών από:",
  "localFilesAddSource": "Προσθήκη πηγής",
  "localFilesSource_downloads": "Λήψεις",
  "localFilesSource_itunes": "iTunes",
  "localFilesSource_my_music": "Η μουσική μου",
  "localFilesSource_windows_music_library": "Μουσική Βιβλιοθήκη",
  "localFilesSource_windows_media_player": "Windows Media Player",
  "accessibility": "Προσβασιμότητα",
  "accessibilityColors": "Ενεργοποίηση χρωμάτων προσβασιμότητας",
  "recoverPlaylists": "Ανάκτηση λιστών",
  "playback": "Αναπαραγωγή",
  "sameVolume": "Ορισμός του ίδιου επιπέδου έντασης ήχου για όλα τα τραγούδια",
  "musicAnnouncements": "Ανακοινώσεις για μουσική",
  "display": "Επιλογές προβολής",
  "showMusicAnnouncements": "Εμφάνιση ανακοινώσεων για νέες κυκλοφορίες",
  "showUnavailableTracks": "Εμφάνιση μη διαθέσιμων τραγουδιών σε λίστες",
  "friendFeed": "Εμφάνιση ροής φίλων",
  "showTrackNotifications": "Εμφάνιση ειδοποιήσεων στην επιφάνεια εργασίας κατά την αλλαγή τραγουδιού",
  "cache": "Προσωρινή μνήμη cache",
  "manuallySetCacheSize": "Ορισμός μεγέθους μνήμης cache με μη αυτόματο τρόπο",
  "fileSystemLocationLabel": "Θέση:",
  "changeLocation": "Αλλαγή θέσης",
  "Proxy": "Διακομιστής μεσολάβησης",
  "aboutSpotify": "Σχετικά με το Spotify",
  "auto-detect": "Αυτόματη ανίχνευση",
  "no-proxy": "Χωρίς διακομιστή μεσολάβησης",
  "http": "HTTP",
  "socks4": "Socks4",
  "socks5": "Socks5",
  "crossfadeTracks": "Crossfade τραγουδιών",
  "tracks": "τραγούδια",
  "sec": "δευτ.",
  "connectedToLastFmAs": "Σύνδεση στο Last.fm ως {0}",
  "missingUsername": "Λείπει το όνομα χρήστη",
  "missingPassword": "Λείπει ο κωδικός πρόσβασης",
  "invalidUsernameOrPassword": "Μη έγκυρο όνομα χρήστη ή κωδικός πρόσβασης",
  "compatibility": "Συμβατότητα",
  "enableHardwareAcceleration": "Ενεργοποίηση επιτάχυνσης υλικού",
  "backToLogin": "Επιστροφή στη Σύνδεση",
  "webhelper": "Να επιτρέπεται άνοιγμα του Spotify από το Web"
};
},{}],3:[function(require,module,exports){
module.exports = {
  "settings": "Settings",
  "upgrade": "Upgrade",
  "viewAccount": "View account",
  "language": "Language",
  "selectLanguage": "Choose language",
  "selectProxy": "Proxy type",
  "Host": "Host",
  "Port": "Port",
  "username": "Username",
  "password": "Password",
  "updateProxy": "Update Proxy",
  "social": "Social",
  "employeeFeatures": "Employee Features",
  "appLinks": "Links to apps",
  "design": "Design",
  "designOptionAuto": "Auto",
  "designOptionGLUE1": "GLUE 1",
  "designOptionGLUE2": "GLUE 2",
  "newPlaylistsPublic": "Automatically make new playlists public",
  "privateSession": "Private session",
  "privateSessionInfo": "private session lasts until you log out",
  "spotify": "Spotify",
  "facebook": "Facebook",
  "lastfm": "Last.fm",
  "seeWhatFriendsAreListening": "See what your friends are listening to",
  "shareOnFacebook": "Share my activity on Facebook",
  "publishActivity": "Publish my activity on Spotify",
  "publishPlaylists": "Automatically make new playlists public",
  "publishTopArtists": "Show my current Top Artists",
  "publishActivityTopListener": "Publish me as a Top Listener for artists",
  "musicQuality": "Music Quality",
  "hqStreaming": "High quality streaming (Premium only)",
  "devices": "Devices",
  "connectToADevice": "Connect to a device - Listen to and control Spotify on your devices",
  "openDevicesMenu": "Open Devices Menu",
  "scrobbleToLastfm": "Scrobble to Last.fm",
  "connectedAs": "Connected as",
  "logOut": "Log out",
  "about": "About",
  "legal": "Legal",
  "help": "Help",
  "connect": "Connect",
  "connectFacebook": "Connect to Facebook",
  "connectLastfm": "Connect to Last.FM",
  "disconnectFacebook": "Disconnect from Facebook",
  "disconnectLastfm": "Disconnect",
  "startupAndWindowBehavior": "Startup and Window Behaviour",
  "closeShouldMinimize": "Close button should minimize the Spotify window to the tray",
  "autostart": "Open Spotify automatically after you log into the computer",
  "hideAdvancedSettings": "Hide advanced settings",
  "showAdvancedSettings": "Show advanced settings",
  "autostartNormal": "Yes",
  "autostartMinimized": "Minimized",
  "autostartOff": "No",
  "localFiles": "Local Files",
  "localFilesSources": "Show songs from",
  "localFilesAddSource": "Add a source",
  "localFilesSource_downloads": "Downloads",
  "localFilesSource_itunes": "iTunes",
  "localFilesSource_my_music": "My Music",
  "localFilesSource_windows_music_library": "Music Library",
  "localFilesSource_windows_media_player": "Windows Media Player",
  "accessibility": "Accessibility",
  "accessibilityColors": "Turn on accessibility colors",
  "recoverPlaylists": "Recover Playlists",
  "playback": "Playback",
  "sameVolume": "Set the same volume level for all songs",
  "musicAnnouncements": "Music Announcements",
  "display": "Display Options",
  "showMusicAnnouncements": "Show announcements about new releases",
  "showUnavailableTracks": "Show unavailable songs in playlists",
  "friendFeed": "Show friend feed",
  "showTrackNotifications": "Show desktop notifications when the song changes",
  "cache": "Cache",
  "manuallySetCacheSize": "Manualy set cache size",
  "fileSystemLocationLabel": "Location:",
  "changeLocation": "Change Location",
  "Proxy": "Proxy",
  "aboutSpotify": "About Spotify",
  "auto-detect": "Auto Detect",
  "no-proxy": "No Proxy",
  "http": "HTTP",
  "socks4": "Socks4",
  "socks5": "Socks5",
  "crossfadeTracks": "Crossfade songs",
  "tracks": "songs",
  "sec": "sec",
  "connectedToLastFmAs": "Connected to Last.fm as {0}",
  "missingUsername": "Missing username",
  "missingPassword": "Missing password",
  "invalidUsernameOrPassword": "Invalid username or password",
  "compatibility": "Compatibility",
  "enableHardwareAcceleration": "Enable hardware acceleration",
  "backToLogin": "Back to Login",
  "webhelper": "Allow Spotify to be opened from the web"
};
},{}],4:[function(require,module,exports){
module.exports = {
  "settings": "Preferencias",
  "upgrade": "Suscríbete",
  "viewAccount": "Ver cuenta",
  "language": "Idioma",
  "selectLanguage": "Elegir idioma",
  "selectProxy": "Tipo de proxy",
  "Host": "Host",
  "Port": "Puerto",
  "username": "Usuario",
  "password": "Contraseña",
  "updateProxy": "Actualizar proxy",
  "social": "Social",
  "employeeFeatures": "Funcionalidades para empleados",
  "appLinks": "Enlaces a aplicaciones",
  "design": "Design",
  "designOptionAuto": "Auto",
  "designOptionGLUE1": "GLUE 1",
  "designOptionGLUE2": "GLUE 2",
  "newPlaylistsPublic": "Hacer públicas las nuevas playlists automáticamente",
  "privateSession": "Sesión privada",
  "privateSessionInfo": "la sesión privada dura hasta que cierres sesión",
  "spotify": "Spotify",
  "facebook": "Facebook",
  "lastfm": "Last.fm",
  "seeWhatFriendsAreListening": "Escucha lo que tus amigos están escuchando.",
  "shareOnFacebook": "Compartir mi actividad en Facebook",
  "publishActivity": "Publicar mi actividad en Spotify",
  "publishPlaylists": "Hacer públicas las nuevas playlists automáticamente",
  "publishTopArtists": "Mostrar mis Artistas favoritos actuales",
  "publishActivityTopListener": "Publicarme como oyente principal de artistas",
  "musicQuality": "Calidad de la música",
  "hqStreaming": "Streaming en alta calidad (solo Premium)",
  "devices": "Dispositivos",
  "connectToADevice": "Conectar a un dispositivo - Escucha y controla Spotify en tus dispositivos ",
  "openDevicesMenu": "Abrir el menú Dispositivos",
  "scrobbleToLastfm": "Hacer scrobbling a Last.fm",
  "connectedAs": "Conectado como",
  "logOut": "Cerrar sesión",
  "about": "Acerca de",
  "legal": "Información legal",
  "help": "Ayuda",
  "connect": "Conectar",
  "connectFacebook": "Conectar a Facebook",
  "connectLastfm": "Conectar a Last.FM",
  "disconnectFacebook": "Desconéctate de Facebook",
  "disconnectLastfm": "Desconectar",
  "startupAndWindowBehavior": "Comportamiento de inicio y de ventanas",
  "closeShouldMinimize": "El botón Cerrar debería minimizar la ventana de Spotify a la bandeja",
  "autostart": "Abrir Spotify automáticamente al iniciar la computadora",
  "hideAdvancedSettings": "Ocultar configuración avanzada",
  "showAdvancedSettings": "Mostrar configuración avanzada",
  "autostartNormal": "Sí",
  "autostartMinimized": "Minimizado",
  "autostartOff": "No",
  "localFiles": "Archivos Locales",
  "localFilesSources": "Mostrar canciones de",
  "localFilesAddSource": "Agregar una fuente",
  "localFilesSource_downloads": "Descargas",
  "localFilesSource_itunes": "iTunes",
  "localFilesSource_my_music": "Mi música",
  "localFilesSource_windows_music_library": "Biblioteca de música",
  "localFilesSource_windows_media_player": "Windows Media Player",
  "accessibility": "Accesibilidad",
  "accessibilityColors": "Activar los colores de accesibilidad",
  "recoverPlaylists": "Recuperar playlists",
  "playback": "Reproducción",
  "sameVolume": "Igualar el volumen de todas las canciones",
  "musicAnnouncements": "Anuncios de música",
  "display": "Opciones de visualización",
  "showMusicAnnouncements": "Mostrar mensajes sobre nuevos lanzamientos",
  "showUnavailableTracks": "Mostrar canciones no disponibles en playlists",
  "friendFeed": "Mostrar actividad de amigos",
  "showTrackNotifications": "Mostrar notificaciones de escritorio al cambiar de canción",
  "cache": "Caché",
  "manuallySetCacheSize": "Determinar manualmente el tamaño de la caché",
  "fileSystemLocationLabel": "Ubicación:",
  "changeLocation": "Cambiar ubicación",
  "Proxy": "Proxy",
  "aboutSpotify": "Acerca de Spotify",
  "auto-detect": "Detección automática",
  "no-proxy": "Sin proxy",
  "http": "HTTP",
  "socks4": "Socks4",
  "socks5": "Socks5",
  "crossfadeTracks": "Hacer una transición gradual entre las canciones",
  "tracks": "canciones",
  "sec": "seg",
  "connectedToLastFmAs": "Conectado a Last.fm como {0}",
  "missingUsername": "Falta el nombre de usuario",
  "missingPassword": "Falta la contraseña",
  "invalidUsernameOrPassword": "Nombre de usuario o contraseña no válidos",
  "compatibility": "Compatibilidad",
  "enableHardwareAcceleration": "Activar aceleración de hardware",
  "backToLogin": "Regresar a inicio de sesión",
  "webhelper": "Permitir que Spotify se abra desde la Web"
};
},{}],5:[function(require,module,exports){
module.exports = {
  "settings": "Preferencias",
  "upgrade": "Suscríbete",
  "viewAccount": "Ver cuenta",
  "language": "Idioma",
  "selectLanguage": "Elegir idioma",
  "selectProxy": "Tipo de proxy",
  "Host": "Host",
  "Port": "Puerto",
  "username": "Usuario",
  "password": "Contraseña",
  "updateProxy": "Actualizar proxy",
  "social": "Social",
  "employeeFeatures": "Funciones para empleados",
  "appLinks": "Enlaces a apps",
  "design": "Design",
  "designOptionAuto": "Automát.",
  "designOptionGLUE1": "GLUE 1",
  "designOptionGLUE2": "GLUE 2",
  "newPlaylistsPublic": "Hacer automáticamente públicas las playlists nuevas",
  "privateSession": "Sesión privada",
  "privateSessionInfo": "la sesión privada dura hasta que cierres sesión",
  "spotify": "Spotify",
  "facebook": "Facebook",
  "lastfm": "Last.fm",
  "seeWhatFriendsAreListening": "Escucha lo que tus amigos están escuchando.",
  "shareOnFacebook": "Compartir mi actividad en Facebook",
  "publishActivity": "Publicar mi actividad en Spotify",
  "publishPlaylists": "Hacer automáticamente públicas las playlists nuevas",
  "publishTopArtists": "Mostrar mis artistas más escuchados actuales",
  "publishActivityTopListener": "Publicar cuando sea oyente principal de un artista",
  "musicQuality": "Calidad de la música",
  "hqStreaming": "Streaming en alta calidad (solo Premium)",
  "devices": "Dispositivos",
  "connectToADevice": "Conectar a un dispositivo - Escucha y controla Spotify en tus dispositivos",
  "openDevicesMenu": "Abre el menú Dispositivos",
  "scrobbleToLastfm": "Hacer scrobbling a Last.fm",
  "connectedAs": "Conectado como",
  "logOut": "Cerrar sesión",
  "about": "Acerca de",
  "legal": "Información legal",
  "help": "Ayuda",
  "connect": "Conectar",
  "connectFacebook": "Conectar a Facebook",
  "connectLastfm": "Conectar a Last.FM",
  "disconnectFacebook": "Desconectar de Facebook",
  "disconnectLastfm": "Desconectar",
  "startupAndWindowBehavior": "Arranque y ventana",
  "closeShouldMinimize": "El botón de cerrar debería minimizar la ventana de Spotify a la bandeja",
  "autostart": "Abrir Spotify automáticamente al iniciar el ordenador",
  "hideAdvancedSettings": "Ocultar configuración avanzada",
  "showAdvancedSettings": "Mostrar configuración avanzada",
  "autostartNormal": "Sí",
  "autostartMinimized": "Minimizado",
  "autostartOff": "No",
  "localFiles": "Archivos Locales",
  "localFilesSources": "Mostrar canciones de",
  "localFilesAddSource": "Añadir una fuente",
  "localFilesSource_downloads": "Descargas",
  "localFilesSource_itunes": "iTunes",
  "localFilesSource_my_music": "Mi música",
  "localFilesSource_windows_music_library": "Biblioteca de música",
  "localFilesSource_windows_media_player": "Windows Media Player",
  "accessibility": "Accesibilidad",
  "accessibilityColors": "Activar colores de accesibilidad",
  "recoverPlaylists": "Recuperar playlists",
  "playback": "Reproducción",
  "sameVolume": "Igualar el volumen de todas las canciones",
  "musicAnnouncements": "Mensajes musicales",
  "display": "Opciones de visualización",
  "showMusicAnnouncements": "Mostrar mensajes sobre nuevos lanzamientos",
  "showUnavailableTracks": "Mostrar las canciones no disponibles en las playlists",
  "friendFeed": "Mostrar actividad de los amigos",
  "showTrackNotifications": "Mostrar notificaciones en el ordenador al cambiar de canción",
  "cache": "Caché",
  "manuallySetCacheSize": "Establecer manualmente el tamaño de la caché",
  "fileSystemLocationLabel": "Ubicación:",
  "changeLocation": "Cambiar ubicación",
  "Proxy": "Proxy",
  "aboutSpotify": "Acerca de Spotify",
  "auto-detect": "Detección automática",
  "no-proxy": "Sin proxy",
  "http": "HTTP",
  "socks4": "Socks4",
  "socks5": "Socks5",
  "crossfadeTracks": "Activar crossfade",
  "tracks": "canciones",
  "sec": "seg",
  "connectedToLastFmAs": "Conectado a Last.fm como {0}",
  "missingUsername": "Falta el nombre de usuario",
  "missingPassword": "Falta la contraseña",
  "invalidUsernameOrPassword": "Nombre de usuario o contraseña no válidos",
  "compatibility": "Compatibilidad",
  "enableHardwareAcceleration": "Activar aceleración de hardware",
  "backToLogin": "Volver a inicio de sesión",
  "webhelper": "Permitir que se abra Spotify desde la web"
};
},{}],6:[function(require,module,exports){
module.exports = {
  "settings": "Asetukset",
  "upgrade": "Päivitä",
  "viewAccount": "Näytä tili",
  "language": "Kieli",
  "selectLanguage": "Valitse kieli",
  "selectProxy": "Välityspalvelimen tyyppi",
  "Host": "Pääkone",
  "Port": "Portti",
  "username": "Käyttäjätunnus",
  "password": "Salasana",
  "updateProxy": "Päivitä välityspalvelin",
  "social": "Sosiaalinen media",
  "employeeFeatures": "Työntekijäesittelyt",
  "appLinks": "Linkit sovelluksiin",
  "design": "Design",
  "designOptionAuto": "Automaattinen",
  "designOptionGLUE1": "GLUE 1",
  "designOptionGLUE2": "GLUE 2",
  "newPlaylistsPublic": "Tee uusista soittolistoista automaattisesti julkisia",
  "privateSession": "Yksityinen istunto",
  "privateSessionInfo": "yksityinen istunto jatkuu, kunnes kirjaudut ulos",
  "spotify": "Spotify",
  "facebook": "Facebook",
  "lastfm": "Last.fm",
  "seeWhatFriendsAreListening": "Katso, mitä ystäväsi kuuntelevat",
  "shareOnFacebook": "Jaa toimintani Facebookissa",
  "publishActivity": "Julkaise toimintani Spotifyssa",
  "publishPlaylists": "Tee uusista soittolistoista automaattisesti julkisia",
  "publishTopArtists": "Näytä nykyiset kuunnelluimmat artistini",
  "publishActivityTopListener": "Käyttäjätunnukseni saa näyttää artistin sivulla ykköskuuntelijana",
  "musicQuality": "Musiikin äänenlaatu",
  "hqStreaming": "Laadukas suoratoisto (vain Premium)",
  "devices": "Laitteet",
  "connectToADevice": "Muodosta yhteys laitteeseen – kuuntele ja ohjaa Spotifyta laitteissasi",
  "openDevicesMenu": "Avaa Laitteet-valikko",
  "scrobbleToLastfm": "Lähetä Last.fm-palveluun",
  "connectedAs": "Linkitetty nimellä",
  "logOut": "Kirjaudu ulos",
  "about": "Tietoja",
  "legal": "Lakiasiat",
  "help": "Ohje",
  "connect": "Yhdistä",
  "connectFacebook": "Linkitä Facebookiin",
  "connectLastfm": "Liitä Last.FM:ään",
  "disconnectFacebook": "Katkaise yhteys Facebookiin",
  "disconnectLastfm": "Katkaise yhteys",
  "startupAndWindowBehavior": "Käynnistäminen ja ikkunan toiminta",
  "closeShouldMinimize": "Sulje-painikkeen pitäisi pienentää Spotify-ikkuna ilmaisinalueelle",
  "autostart": "Käynnistä Spotify automaattisesti, kun kirjaudun tietokoneeseen",
  "hideAdvancedSettings": "Piilota lisäasetukset",
  "showAdvancedSettings": "Näytä lisäasetukset",
  "autostartNormal": "Kyllä",
  "autostartMinimized": "Pienennetty",
  "autostartOff": "Ei",
  "localFiles": "Paikalliset tiedostot",
  "localFilesSources": "Näytä kappaleet kohteesta",
  "localFilesAddSource": "Lisää lähde",
  "localFilesSource_downloads": "Lataukset",
  "localFilesSource_itunes": "iTunes",
  "localFilesSource_my_music": "Oma musiikki",
  "localFilesSource_windows_music_library": "Musiikkikirjasto",
  "localFilesSource_windows_media_player": "Windows Media Player",
  "accessibility": "Helppokäyttöisyys",
  "accessibilityColors": "Ota helppokäyttövärit käyttöön",
  "recoverPlaylists": "Palauta soittolistat",
  "playback": "Toisto",
  "sameVolume": "Soita kaikki kappaleet samalla äänenvoimakkuudella",
  "musicAnnouncements": "Musiikki-ilmoitukset",
  "display": "Näyttövalinnat",
  "showMusicAnnouncements": "Näytä uusia julkaisuja koskevat ilmoitukset",
  "showUnavailableTracks": "Näytä soittolistoissa myös kappaleet, jotka eivät ole käytettävissä",
  "friendFeed": "Näytä kaverisyöte",
  "showTrackNotifications": "Näytä työpöydällä ilmoitus, kun kappale vaihtuu",
  "cache": "Välimuisti",
  "manuallySetCacheSize": "Aseta välimuistin koko manuaalisesti",
  "fileSystemLocationLabel": "Sijainti:",
  "changeLocation": "Vaihda sijainti",
  "Proxy": "Välityspalvelin",
  "aboutSpotify": "Tietoja Spotifysta",
  "auto-detect": "Automaattinen tunnistus",
  "no-proxy": "Ei välityspalvelinta",
  "http": "HTTP",
  "socks4": "Socks4",
  "socks5": "Socks5",
  "crossfadeTracks": "Ristihäivytä kappaleet",
  "tracks": "kappaletta",
  "sec": "s",
  "connectedToLastFmAs": "Yhdistetty Last.fm:ään nimellä {0}",
  "missingUsername": "Käyttäjätunnus puuttuu",
  "missingPassword": "Salasana puuttuu",
  "invalidUsernameOrPassword": "Virheellinen käyttäjätunnus tai salasana",
  "compatibility": "Yhteensopivuus",
  "enableHardwareAcceleration": "Ota laitteistokiihdytys käyttöön",
  "backToLogin": "Takaisin sisäänkirjautumiseen",
  "webhelper": "Salli Spotifyn avaaminen selaimesta"
};
},{}],7:[function(require,module,exports){
module.exports = {
  "settings": "Préférences",
  "upgrade": "Abonnez-vous",
  "viewAccount": "Afficher le compte",
  "language": "Langue",
  "selectLanguage": "Choisir une langue",
  "selectProxy": "Type de mandataire",
  "Host": "Hôte",
  "Port": "Port",
  "username": "Utilisateur",
  "password": "Mot de passe",
  "updateProxy": "Mettre à jour le mandataire",
  "social": "Partage",
  "employeeFeatures": "Fonctionnalités réservées aux employés",
  "appLinks": "Liens vers des applications",
  "design": "Design",
  "designOptionAuto": "Automatique",
  "designOptionGLUE1": "GLUE 1",
  "designOptionGLUE2": "GLUE 2",
  "newPlaylistsPublic": "Rendre les nouvelles listes de lecture publiques automatiquement",
  "privateSession": "Session privée",
  "privateSessionInfo": "La session privée se termine lorsque vous vous déconnectez",
  "spotify": "Spotify",
  "facebook": "Facebook",
  "lastfm": "Last.fm",
  "seeWhatFriendsAreListening": "Voyez ce que vos amis écoutent",
  "shareOnFacebook": "Partager mon activité sur Facebook",
  "publishActivity": "Publier mon activité sur Spotify",
  "publishPlaylists": "Rendre les nouvelles listes de lecture publiques automatiquement",
  "publishTopArtists": "Afficher mes meilleurs artistes actuels",
  "publishActivityTopListener": "Publier mon nom comme grand auditeur des artistes",
  "musicQuality": "Qualité sonore",
  "hqStreaming": "Diffusion en continu en haute qualité (Premium uniquement)",
  "devices": "Appareils",
  "connectToADevice": "Se connecter à un appareil : écoutez et contrôlez Spotify sur vos appareils",
  "openDevicesMenu": "Ouvrir le menu Appareils",
  "scrobbleToLastfm": "Envoyer vers Last.fm",
  "connectedAs": "Connecté en tant que",
  "logOut": "Déconnexion",
  "about": "À propos",
  "legal": "Renseignements juridiques",
  "help": "Aide",
  "connect": "Connect",
  "connectFacebook": "Connexion à Facebook",
  "connectLastfm": "Se connecter à Last.FM",
  "disconnectFacebook": "Déconnexion de Facebook",
  "disconnectLastfm": "Déconnexion",
  "startupAndWindowBehavior": "Démarrage et comportement de la fenêtre",
  "closeShouldMinimize": "Le bouton Fermer devrait réduire la fenêtre Spotify dans la barre.",
  "autostart": "Ouvrir Spotify automatiquement au démarrage de l'ordinateur",
  "hideAdvancedSettings": "Masquer les paramètres avancés",
  "showAdvancedSettings": "Afficher les paramètres avancés",
  "autostartNormal": "Oui",
  "autostartMinimized": "Minimisé",
  "autostartOff": "Non",
  "localFiles": "Fichiers locaux",
  "localFilesSources": "Afficher les chansons de",
  "localFilesAddSource": "Ajouter une source",
  "localFilesSource_downloads": "Téléchargements",
  "localFilesSource_itunes": "iTunes",
  "localFilesSource_my_music": "Ma musique",
  "localFilesSource_windows_music_library": "Bibliothèque musicale",
  "localFilesSource_windows_media_player": "Windows Media Player",
  "accessibility": "Accessibilité",
  "accessibilityColors": "Activer les couleurs d'accessibilité",
  "recoverPlaylists": "Récupérer les listes de lecture",
  "playback": "Lecture",
  "sameVolume": "Définir le même volume pour toutes les chansons",
  "musicAnnouncements": "Annonces Musique",
  "display": "Options d'affichage",
  "showMusicAnnouncements": "Afficher les annonces et les nouveautés",
  "showUnavailableTracks": "Afficher les chansons non disponibles dans les listes de lecture",
  "friendFeed": "Afficher le fil d'actualité d'un ami",
  "showTrackNotifications": "Afficher les notifications lorsque la chanson change",
  "cache": "Antémémoire",
  "manuallySetCacheSize": "Définir manuellement la taille de l'antémémoire",
  "fileSystemLocationLabel": "Emplacement :",
  "changeLocation": "Changer d'emplacement",
  "Proxy": "Mandataire",
  "aboutSpotify": "À propos de Spotify",
  "auto-detect": "Détection automatique",
  "no-proxy": "Aucun mandataire",
  "http": "HTTP",
  "socks4": "Socks4",
  "socks5": "Socks5",
  "crossfadeTracks": "Chansons enchaînées",
  "tracks": "chansons",
  "sec": "sec",
  "connectedToLastFmAs": "Connecté à Last.fm en tant que {0}",
  "missingUsername": "Nom d'utilisateur manquant",
  "missingPassword": "Mot de passe manquant",
  "invalidUsernameOrPassword": "Nom d'utilisateur ou mot de passe incorrect",
  "compatibility": "Compatibilité",
  "enableHardwareAcceleration": "Activer l'accélération matérielle",
  "backToLogin": "Retour à la page de connexion",
  "webhelper": "Autoriser l'ouverture de Spotify depuis le Web"
};
},{}],8:[function(require,module,exports){
module.exports = {
  "settings": "Préférences",
  "upgrade": "Abonnez-vous",
  "viewAccount": "Voir le compte",
  "language": "Langue",
  "selectLanguage": "Choisir une langue",
  "selectProxy": "Type de proxy",
  "Host": "Hôte",
  "Port": "Port",
  "username": "Utilisateur",
  "password": "Mot de passe",
  "updateProxy": "Mettre à jour le proxy",
  "social": "Partage",
  "employeeFeatures": "Fonctionnalités pour les employés",
  "appLinks": "Liens vers les applis",
  "design": "Design",
  "designOptionAuto": "Automatique",
  "designOptionGLUE1": "GLUE 1",
  "designOptionGLUE2": "GLUE 2",
  "newPlaylistsPublic": "Publier automatiquement les nouvelles playlists",
  "privateSession": "Session d’écoute privée",
  "privateSessionInfo": "Les sessions d'écoute privées se terminent lorsque vous vous déconnectez.",
  "spotify": "Spotify",
  "facebook": "Facebook",
  "lastfm": "Last.fm",
  "seeWhatFriendsAreListening": "Voyez ce que vos amis écoutent",
  "shareOnFacebook": "Partager mon activité sur Facebook",
  "publishActivity": "Publier mon activité sur Spotify",
  "publishPlaylists": "Publier automatiquement les nouvelles playlists",
  "publishTopArtists": "Afficher mes Top artistes du moment",
  "publishActivityTopListener": "Me publier comme Top fan pour des artistes",
  "musicQuality": "Qualité sonore",
  "hqStreaming": "Streaming haute qualité (Premium uniquement)",
  "devices": "Appareils",
  "connectToADevice": "Se connecter à un appareil - Écoutez et contrôlez Spotify sur vos appareils",
  "openDevicesMenu": "Menu Ouvrir les appareils",
  "scrobbleToLastfm": "Scrobbler sur Last.fm",
  "connectedAs": "Connecté en tant que",
  "logOut": "Déconnexion",
  "about": "A propos",
  "legal": "Légal",
  "help": "Aide",
  "connect": "Connecter",
  "connectFacebook": "Connexion à Facebook",
  "connectLastfm": "Connexion à Last.FM",
  "disconnectFacebook": "Déconnexion de Facebook",
  "disconnectLastfm": "Déconnecter",
  "startupAndWindowBehavior": "Démarrage et comportement de la fenêtre",
  "closeShouldMinimize": "Le bouton de fermeture doit minimiser la fenêtre Spotify dans la barre de tâches.",
  "autostart": "Ouvrir Spotify automatiquement au démarrage",
  "hideAdvancedSettings": "Masquer les paramètres avancés",
  "showAdvancedSettings": "Afficher les paramètres avancés",
  "autostartNormal": "Oui",
  "autostartMinimized": "Minimisé",
  "autostartOff": "Non",
  "localFiles": "Fichiers locaux",
  "localFilesSources": "Afficher les chansons de",
  "localFilesAddSource": "Ajouter une source",
  "localFilesSource_downloads": "Téléchargements",
  "localFilesSource_itunes": "iTunes",
  "localFilesSource_my_music": "Ma Musique",
  "localFilesSource_windows_music_library": "Bibliothèque musicale",
  "localFilesSource_windows_media_player": "Windows Media Player",
  "accessibility": "Accessibilité",
  "accessibilityColors": "Activer les couleurs de l'accessibilité",
  "recoverPlaylists": "Récupérer les playlists",
  "playback": "Lecture",
  "sameVolume": "Définir le même volume pour toutes les chansons",
  "musicAnnouncements": "Publicités musicales",
  "display": "Options d'affichage",
  "showMusicAnnouncements": "Afficher les publicités sur les nouveautés",
  "showUnavailableTracks": "Afficher les chansons non disponibles dans les playlists",
  "friendFeed": "Afficher le flux d'amis",
  "showTrackNotifications": "Afficher des notifications sur votre ordinateur au changement de chanson",
  "cache": "Mémoire cache",
  "manuallySetCacheSize": "Définir manuellement la taille du cache",
  "fileSystemLocationLabel": "Emplacement :",
  "changeLocation": "Édition l'emplacement",
  "Proxy": "Proxy",
  "aboutSpotify": "À propos de Spotify",
  "auto-detect": "Détection automatique",
  "no-proxy": "Aucun proxy",
  "http": "HTTP",
  "socks4": "Socks4",
  "socks5": "Socks5",
  "crossfadeTracks": "Activer le fondu enchaîné des chansons",
  "tracks": "titres",
  "sec": "s",
  "connectedToLastFmAs": "Connecté à Last.fm en tant que {0}",
  "missingUsername": "Nom d'utilisateur manquant",
  "missingPassword": "Mot de passe manquant",
  "invalidUsernameOrPassword": "Nom d'utilisateur ou mot de passe non valide",
  "compatibility": "Compatibilité",
  "enableHardwareAcceleration": "Activer l'accélération matérielle",
  "backToLogin": "Retour à la connexion",
  "webhelper": "Autoriser l'ouverture de Spotify à partir du Web"
};
},{}],9:[function(require,module,exports){
module.exports = {
  "settings": "Beállítások",
  "upgrade": "Csomagváltás",
  "viewAccount": "Fiók megtekintése",
  "language": "Nyelv",
  "selectLanguage": "Nyelvválasztás",
  "selectProxy": "Proxy típusa",
  "Host": "Host (gép)",
  "Port": "Portszám",
  "username": "Felhasználónév",
  "password": "Jelszó",
  "updateProxy": "Proxy adatainak módosítása",
  "social": "Közösség",
  "employeeFeatures": "Munkatársak által elérhető funkciók",
  "appLinks": "Alkalmazások hivatkozásai",
  "design": "Design",
  "designOptionAuto": "Automatikus",
  "designOptionGLUE1": "GLUE 1",
  "designOptionGLUE2": "GLUE 2",
  "newPlaylistsPublic": "Automatikusan legyenek nyilvánosak az új lejátszási listák",
  "privateSession": "Privát zenehallgatás",
  "privateSessionInfo": "a privát zenehallgatás a kijelentkezésig tart",
  "spotify": "Spotify",
  "facebook": "Facebook",
  "lastfm": "Last.fm",
  "seeWhatFriendsAreListening": "Nézd meg, mit hallgatnak az ismerőseid",
  "shareOnFacebook": "Tevékenységeim megosztása Facebookon",
  "publishActivity": "Tevékenységeim megosztása a Spotifyon",
  "publishPlaylists": "Automatikusan legyenek nyilvánosak az új lejátszási listák",
  "publishTopArtists": "Jelenleg legkedveltebb előadóim megjelenítése",
  "publishActivityTopListener": "Legyen nyilvános, hogy kit hallgatok a legtöbbször",
  "musicQuality": "Hangminőség",
  "hqStreaming": "Kiváló minőségű online lejátszás (csak Premium-előfizetőknek)",
  "devices": "Készülékek",
  "connectToADevice": "Csatlakozás másik készülékhez – más készülékeken is lejátszhatod a spotifyos tartalmakat, a Spotify alkalmazást pedig távirányítóként használhatod hozzájuk.",
  "openDevicesMenu": "Készülékek menü megnyitása",
  "scrobbleToLastfm": "Visszajelzés (scrobble) a Last.fm-nek",
  "connectedAs": "Csatlakozva mint",
  "logOut": "Kijelentkezés",
  "about": "Névjegy",
  "legal": "Jogi tudnivalók",
  "help": "Súgó",
  "connect": "Csatlakozás",
  "connectFacebook": "Összekapcsolás a Facebookkal",
  "connectLastfm": "Csatlakozás a Last.FM-hez",
  "disconnectFacebook": "Facebook-fiók leválasztása",
  "disconnectLastfm": "Kapcsolat bontása",
  "startupAndWindowBehavior": "Indítás és ablakok",
  "closeShouldMinimize": "A Bezárás gomb a képernyő jobb alsó sarkába helyezi Spotify ikonját",
  "autostart": "A Spotify automatikus megnyitása, amikor bejelentkezem a számítógépre",
  "hideAdvancedSettings": "Részletes beállítások elrejtése",
  "showAdvancedSettings": "Részletes beállítások megjelenítése",
  "autostartNormal": "Igen",
  "autostartMinimized": "Kis méret",
  "autostartOff": "Nem",
  "localFiles": "Helyi fájlok",
  "localFilesSources": "Számok:",
  "localFilesAddSource": "Forrás felvétele",
  "localFilesSource_downloads": "Letöltések",
  "localFilesSource_itunes": "iTunes",
  "localFilesSource_my_music": "Zenéim",
  "localFilesSource_windows_music_library": "Zenekönyvtár",
  "localFilesSource_windows_media_player": "Windows Media Player",
  "accessibility": "Kisegítő lehetőségek",
  "accessibilityColors": "Kontrasztos színek bekapcsolása",
  "recoverPlaylists": "Lejátszási listák helyreállítása",
  "playback": "Lejátszás",
  "sameVolume": "Azonos (normalizált) hangerő minden számhoz",
  "musicAnnouncements": "Zenei hírek",
  "display": "Megjelenítési beállítások",
  "showMusicAnnouncements": "Új kiadványokkal kapcsolatos hírek megjelenítése",
  "showUnavailableTracks": "Le nem játszható számok megjelenítése a lejátszási listákban",
  "friendFeed": "Ismerősök üzenőfalának megjelenítése",
  "showTrackNotifications": "Számok közötti váltáskor asztali értesítés megjelenítése",
  "cache": "Gyorsítótár",
  "manuallySetCacheSize": "Kézzel beállított gyorsítótárméret",
  "fileSystemLocationLabel": "Hely:",
  "changeLocation": "Hely módosítása",
  "Proxy": "Proxy",
  "aboutSpotify": "A Spotify névjegye",
  "auto-detect": "Automatikus észlelés",
  "no-proxy": "Nincs proxy",
  "http": "HTTP",
  "socks4": "Socks4",
  "socks5": "Socks5",
  "crossfadeTracks": "Áttűnés a számok közt",
  "tracks": "dalok",
  "sec": "mp",
  "connectedToLastFmAs": "Csatlakozva a Last.fm-hez {0} néven",
  "missingUsername": "Nincs megadva a felhasználónév",
  "missingPassword": "Nincs megadva a jelszó",
  "invalidUsernameOrPassword": "Helytelen felhasználónév vagy jelszó",
  "compatibility": "Kompatibilitás",
  "enableHardwareAcceleration": "Hardveres gyorsítás engedélyezése",
  "backToLogin": "Vissza a bejelentkezéshez",
  "webhelper": "A Spotify megnyitásának engedélyezése a böngészőből"
};
},{}],10:[function(require,module,exports){
module.exports = {
  "settings": "Pengaturan",
  "upgrade": "Upgrade",
  "viewAccount": "Lihat akun kamu",
  "language": "Bahasa",
  "selectLanguage": "Pilih bahasa",
  "selectProxy": "Jenis proksi",
  "Host": "Host",
  "Port": "Port",
  "username": "Nama Pengguna",
  "password": "Kata Sandi",
  "updateProxy": "Perbarui Proksi",
  "social": "Social",
  "employeeFeatures": "Fitur Karyawan",
  "appLinks": "Tautan ke aplikasi",
  "design": "Design",
  "designOptionAuto": "Otomatis",
  "designOptionGLUE1": "GLUE 1",
  "designOptionGLUE2": "GLUE 2",
  "newPlaylistsPublic": "Secara otomatis membuat playlist baru publik",
  "privateSession": "Sesi pribadi",
  "privateSessionInfo": "sesi pribadi berlangsung hingga kamu keluar",
  "spotify": "Spotify",
  "facebook": "Facebook",
  "lastfm": "Last.fm",
  "seeWhatFriendsAreListening": "Lihat apa yang didengarkan temanmu",
  "shareOnFacebook": "Bagikan aktivitasku di Facebook",
  "publishActivity": "Publikasikan aktivitasku di Spotify",
  "publishPlaylists": "Secara otomatis membuat playlist baru publik",
  "publishTopArtists": "Tampilkan Artis Teratasku saat ini",
  "publishActivityTopListener": "Publikasikan aku sebagai Pendengar Teratas untuk artis",
  "musicQuality": "Kualitas Musik",
  "hqStreaming": "Streaming kualitas tinggi (hanya Premium)",
  "devices": "Perangkat",
  "connectToADevice": "Hubungkan ke perangkat - Dengarkan dan kontrol Spotify di perangkatmu",
  "openDevicesMenu": "Buka Menu Perangkat",
  "scrobbleToLastfm": "Scrobble ke Last.fm",
  "connectedAs": "Terhubung sebagai",
  "logOut": "Keluar",
  "about": "Tentang",
  "legal": "Legal",
  "help": "Bantuan",
  "connect": "Connect",
  "connectFacebook": "Aktifkan Facebook",
  "connectLastfm": "Hubungkan ke Last.FM",
  "disconnectFacebook": "Putuskan dari Facebook",
  "disconnectLastfm": "Putuskan",
  "startupAndWindowBehavior": "Perilaku Saat Dihidupkan dan Jendela",
  "closeShouldMinimize": "Tombol Tutup harus meminimalkan jendela Spotify ke baki",
  "autostart": "Buka Spotify secara otomatis setelah kamu masuk ke komputer",
  "hideAdvancedSettings": "Sembunyikan pengaturan lanjutan",
  "showAdvancedSettings": "Tampilkan pengaturan lanjutan",
  "autostartNormal": "Ya",
  "autostartMinimized": "Diminimalkan",
  "autostartOff": "Tidak",
  "localFiles": "File Lokal",
  "localFilesSources": "Tampilkan lagu dari",
  "localFilesAddSource": "Tambahkan sumber",
  "localFilesSource_downloads": "Downloads",
  "localFilesSource_itunes": "iTunes",
  "localFilesSource_my_music": "Musikku",
  "localFilesSource_windows_music_library": "Koleksi Musik",
  "localFilesSource_windows_media_player": "Windows Media Player",
  "accessibility": "Aksesibilitas",
  "accessibilityColors": "Aktifkan warna aksesibilitas",
  "recoverPlaylists": "Pulihkan Playlist",
  "playback": "Playback",
  "sameVolume": "Atur tingkat volume yang sama untuk semua lagu.",
  "musicAnnouncements": "Pemberitahuan Musik",
  "display": "Opsi Tampilan",
  "showMusicAnnouncements": "Tampilkan pengumuman tentang rilis terbaru",
  "showUnavailableTracks": "Tampilkan lagu yang tidak tersedia dalam playlist",
  "friendFeed": "Tampilkan feed teman",
  "showTrackNotifications": "Tampilkan pemberitahuan desktop jika lagu berubah",
  "cache": "Cache",
  "manuallySetCacheSize": "Tetapkan ukuran cache secara manual",
  "fileSystemLocationLabel": "Lokasi:",
  "changeLocation": "Ubah Lokasi",
  "Proxy": "Proxy",
  "aboutSpotify": "Tentang Spotify",
  "auto-detect": "Deteksi Otomatis",
  "no-proxy": "Tanpa Proksi",
  "http": "HTTP",
  "socks4": "Socks4",
  "socks5": "Socks5",
  "crossfadeTracks": "Baurkan lagu",
  "tracks": "lagu",
  "sec": "dtk",
  "connectedToLastFmAs": "Terhubung ke Last.fm sebagai {0}",
  "missingUsername": "Nama pengguna tidak ada",
  "missingPassword": "Kata sandi tidak ada",
  "invalidUsernameOrPassword": "Nama pengguna atau kata sandi tidak valid",
  "compatibility": "Kompatibilitas",
  "enableHardwareAcceleration": "Aktifkan akselerasi perangkat keras",
  "backToLogin": "Kembali ke Masuk",
  "webhelper": "Izinkan Spotify dibuka dari web"
};
},{}],11:[function(require,module,exports){
'use strict';

// This file will likely become a generated file in the future. Please
// avoid adding extra APIs or exports here.

var i18n = require('../../../libs/spotify-i18n')({
  'de': require('./de.lang'),
  'el': require('./el.lang'),
  'en': require('./en.lang'),
  'es': require('./es.lang'),
  'es-419': require('./es-419.lang'),
  'fi': require('./fi.lang'),
  'fr': require('./fr.lang'),
  'fr-CA': require('./fr-CA.lang'),
  'hu': require('./hu.lang'),
  'id': require('./id.lang'),
  'it': require('./it.lang'),
  'ja': require('./ja.lang'),
  'nl': require('./nl.lang'),
  'pl': require('./pl.lang'),
  'pt-BR': require('./pt-BR.lang'),
  'sv': require('./sv.lang'),
  'tr': require('./tr.lang'),
  'zh-Hant': require('./zh-Hant.lang'),
  'zsm': require('./zsm.lang')
});

module.exports = i18n;

},{"../../../libs/spotify-i18n":211,"./de.lang":1,"./el.lang":2,"./en.lang":3,"./es-419.lang":4,"./es.lang":5,"./fi.lang":6,"./fr-CA.lang":7,"./fr.lang":8,"./hu.lang":9,"./id.lang":10,"./it.lang":12,"./ja.lang":13,"./nl.lang":14,"./pl.lang":15,"./pt-BR.lang":16,"./sv.lang":17,"./tr.lang":18,"./zh-Hant.lang":19,"./zsm.lang":20}],12:[function(require,module,exports){
module.exports = {
  "settings": "Impostazioni",
  "upgrade": "Upgrade",
  "viewAccount": "Visualizza account",
  "language": "Lingua",
  "selectLanguage": "Scegli lingua",
  "selectProxy": "Tipo di proxy",
  "Host": "Host",
  "Port": "Porta",
  "username": "Username",
  "password": "Password",
  "updateProxy": "Aggiorna proxy",
  "social": "Social",
  "employeeFeatures": "Funzionalità per i dipendenti",
  "appLinks": "Link alle app",
  "design": "Design",
  "designOptionAuto": "Auto",
  "designOptionGLUE1": "GLUE 1",
  "designOptionGLUE2": "GLUE 2",
  "newPlaylistsPublic": "Rendi automaticamente pubbliche le nuove playlist",
  "privateSession": "Sessione privata",
  "privateSessionInfo": "la sessione privata rimarrà attiva fin quando non avrai effettuato il log out",
  "spotify": "Spotify",
  "facebook": "Facebook",
  "lastfm": "Last.fm",
  "seeWhatFriendsAreListening": "Scopri cosa stanno ascoltando i tuoi amici",
  "shareOnFacebook": "Condividi la mia attività su Facebook",
  "publishActivity": "Pubblica la mia attività su Spotify",
  "publishPlaylists": "Rendi automaticamente pubbliche le nuove playlist",
  "publishTopArtists": "Mostra i miei top artist",
  "publishActivityTopListener": "Pubblicami come top listener per gli artisti",
  "musicQuality": "Qualità della musica",
  "hqStreaming": "Streaming ad alta qualità (solo Premium)",
  "devices": "Dispositivi",
  "connectToADevice": "Connetti a un dispositivo - Ascolta e controlla Spotify sui tuoi dispositivi",
  "openDevicesMenu": "Apri il menu Dispositivi",
  "scrobbleToLastfm": "Scrobbling su Last.fm",
  "connectedAs": "Connesso come",
  "logOut": "Disconnetti",
  "about": "Informazioni",
  "legal": "Note legali",
  "help": "Aiuto",
  "connect": "Connettiti",
  "connectFacebook": "Connettiti a Facebook",
  "connectLastfm": "Collegati a Last.FM",
  "disconnectFacebook": "Disconnettiti da Facebook",
  "disconnectLastfm": "Disconnetti",
  "startupAndWindowBehavior": "Impostazioni di avvio e per le finestre",
  "closeShouldMinimize": "Il pulsante Chiudi dovrebbe ridurre la finestra di Spotify a icona nella barra delle applicazioni",
  "autostart": "Apri Spotify automaticamente dopo l'accesso al computer",
  "hideAdvancedSettings": "Nascondi impostazioni avanzate",
  "showAdvancedSettings": "Mostra impostazioni avanzate",
  "autostartNormal": "Sì",
  "autostartMinimized": "Ridotto a icona",
  "autostartOff": "No",
  "localFiles": "File locali",
  "localFilesSources": "Mostra i brani di",
  "localFilesAddSource": "Aggiungi una fonte",
  "localFilesSource_downloads": "Download",
  "localFilesSource_itunes": "iTunes",
  "localFilesSource_my_music": "La mia musica",
  "localFilesSource_windows_music_library": "Libreria musicale",
  "localFilesSource_windows_media_player": "Windows Media Player",
  "accessibility": "Accessibilità",
  "accessibilityColors": "Attiva i colori per l'accesso facilitato",
  "recoverPlaylists": "Recupera playlist",
  "playback": "Riproduzione",
  "sameVolume": "Regola lo stesso livello di volume per tutti i brani",
  "musicAnnouncements": "Annunci musicali",
  "display": "Opzioni di visualizzazione",
  "showMusicAnnouncements": "Mostra gli annunci sulle nuove uscite",
  "showUnavailableTracks": "Mostra i brani non disponibili nelle playlist",
  "friendFeed": "Mostra feed amici",
  "showTrackNotifications": "Mostra le notifiche sul desktop quando cambia il brano",
  "cache": "Cache",
  "manuallySetCacheSize": "Imposta manualmente la dimensione della cache",
  "fileSystemLocationLabel": "Posizione:",
  "changeLocation": "Modifica posizione",
  "Proxy": "Proxy",
  "aboutSpotify": "Informazioni su Spotify",
  "auto-detect": "Rilevamento automatico",
  "no-proxy": "Senza proxy",
  "http": "HTTP",
  "socks4": "Socks4",
  "socks5": "Socks5",
  "crossfadeTracks": "Dissolvenza tra i brani",
  "tracks": "brani",
  "sec": "sec",
  "connectedToLastFmAs": "Connesso a Last.fm come {0}",
  "missingUsername": "Nome utente mancante",
  "missingPassword": "Password mancante",
  "invalidUsernameOrPassword": "Nome utente o password non validi",
  "compatibility": "Compatibilità",
  "enableHardwareAcceleration": "Abilita accelerazione hardware",
  "backToLogin": "Torna al login",
  "webhelper": "Consenti di aprire Spotify dal Web"
};
},{}],13:[function(require,module,exports){
module.exports = {
  "settings": "設定",
  "upgrade": "アップグレードする",
  "viewAccount": "アカウントを表示",
  "language": "言語",
  "selectLanguage": "言語を選択",
  "selectProxy": "プロキシの種類",
  "Host": "ホスト",
  "Port": "ポート",
  "username": "ユーザー名",
  "password": "パスワード",
  "updateProxy": "プロキシの更新",
  "social": "ソーシャル",
  "employeeFeatures": "従業員用の機能",
  "appLinks": "アプリへのリンク",
  "design": "Design",
  "designOptionAuto": "自動",
  "designOptionGLUE1": "GLUE 1",
  "designOptionGLUE2": "GLUE 2",
  "newPlaylistsPublic": "新規プレイリストを自動的に公開",
  "privateSession": "プライベートセッション",
  "privateSessionInfo": "プライベートセッションはログアウトするまで保持されます",
  "spotify": "Spotify",
  "facebook": "Facebook",
  "lastfm": "Last.fm",
  "seeWhatFriendsAreListening": "友達が聴いている曲をチェック",
  "shareOnFacebook": "Facebookで自分のアクティビティを共有",
  "publishActivity": "Spotifyで自分のアクティビティを公開",
  "publishPlaylists": "新規プレイリストを自動的に公開",
  "publishTopArtists": "自分の現在のトップアーティストを表示",
  "publishActivityTopListener": "自分をアーティストのトップリスナーとして公開",
  "musicQuality": "音質",
  "hqStreaming": "高品質ストリーミング(プレミアムのみ)",
  "devices": "デバイス",
  "connectToADevice": "デバイスに接続 - ご利用のデバイスでSpotifyの再生や管理ができます",
  "openDevicesMenu": "デバイスメニューを開く",
  "scrobbleToLastfm": " Last.fmにScrobble ",
  "connectedAs": "次のアカウントで接続済み",
  "logOut": "ログアウト",
  "about": "詳細",
  "legal": "利用条件",
  "help": "ヘルプ",
  "connect": "接続",
  "connectFacebook": "Facebookに接続",
  "connectLastfm": "Last.FMに接続",
  "disconnectFacebook": "Facebookから切断",
  "disconnectLastfm": "切断",
  "startupAndWindowBehavior": "スタートアップとウィンドウの動作",
  "closeShouldMinimize": "[閉じる]ボタンをクリックすると、Spotifyのウィンドウを最小化してトレイに入れることができます",
  "autostart": "コンピューター起動後にSpotifyを自動的に開く",
  "hideAdvancedSettings": "詳細設定を非表示にする",
  "showAdvancedSettings": "詳細設定を表示する",
  "autostartNormal": "はい",
  "autostartMinimized": "最小化",
  "autostartOff": "いいえ",
  "localFiles": "ローカルファイル",
  "localFilesSources": "次の場所にある曲を表示",
  "localFilesAddSource": "ソースを追加",
  "localFilesSource_downloads": "ダウンロード",
  "localFilesSource_itunes": "iTunes",
  "localFilesSource_my_music": "マイミュージック",
  "localFilesSource_windows_music_library": "Music Library",
  "localFilesSource_windows_media_player": "Windows Media Player",
  "accessibility": "アクセシビリティ",
  "accessibilityColors": "アクセシビリティカラーをオンにする",
  "recoverPlaylists": "プレイリストの回復",
  "playback": "再生",
  "sameVolume": "すべての曲で同じ音量に設定",
  "musicAnnouncements": "音楽広告",
  "display": "表示オプション",
  "showMusicAnnouncements": "ニューリリースに関するお知らせを表示",
  "showUnavailableTracks": "プレイリスト内の再生できない曲を表示",
  "friendFeed": "友達フィードを表示",
  "showTrackNotifications": "曲が変わるときにデスクトップ通知を表示",
  "cache": "キャッシュ",
  "manuallySetCacheSize": "キャッシュのサイズを手動で設定",
  "fileSystemLocationLabel": "ファイルの場所：",
  "changeLocation": "コンサート会場の場所変更",
  "Proxy": "プロキシ",
  "aboutSpotify": "Spotifyについて",
  "auto-detect": "自動検出",
  "no-proxy": "プロキシなし",
  "http": "HTTP",
  "socks4": "Socks4",
  "socks5": "Socks5",
  "crossfadeTracks": "曲をクロスフェード",
  "tracks": "ソング",
  "sec": "秒",
  "connectedToLastFmAs": "{0}としてLast.fmに接続しました",
  "missingUsername": "ユーザー名を入力して下さい",
  "missingPassword": "パスワードがありません",
  "invalidUsernameOrPassword": "ユーザー名またはパスワードが無効です",
  "compatibility": "互換性",
  "enableHardwareAcceleration": "ハードウェア高速化を有効化",
  "backToLogin": "ログインに戻る",
  "webhelper": "SpotifyのWeb起動を許可"
};
},{}],14:[function(require,module,exports){
module.exports = {
  "settings": "Instellingen",
  "upgrade": "Upgrade",
  "viewAccount": "Account bekijken",
  "language": "Taal",
  "selectLanguage": "Taal selecteren",
  "selectProxy": "Proxytype",
  "Host": "Host",
  "Port": "Poort",
  "username": "Gebruikersnaam",
  "password": "Wachtwoord",
  "updateProxy": "Proxy bijwerken",
  "social": "Sociaal",
  "employeeFeatures": "Functies voor werknemers",
  "appLinks": "Links naar apps",
  "design": "Design",
  "designOptionAuto": "Automatisch",
  "designOptionGLUE1": "GLUE 1",
  "designOptionGLUE2": "GLUE 2",
  "newPlaylistsPublic": "Nieuwe afspeellijsten automatisch openbaar maken",
  "privateSession": "Privésessie",
  "privateSessionInfo": "privé-sessies duren tot je bent uitgelogd",
  "spotify": "Spotify",
  "facebook": "Facebook",
  "lastfm": "Last.fm",
  "seeWhatFriendsAreListening": "Ontdek waar je vrienden naar luisteren",
  "shareOnFacebook": "Mijn activiteit delen op Facebook",
  "publishActivity": "Mijn activiteit delen op Spotify",
  "publishPlaylists": "Nieuwe afspeellijsten automatisch openbaar maken",
  "publishTopArtists": "Toon mijn huidige topartiesten",
  "publishActivityTopListener": "Publiceer mij als topluisteraar voor artiesten",
  "musicQuality": "Geluidskwaliteit",
  "hqStreaming": "Streaming in hoge kwaliteit (alleen Premium)",
  "devices": "Apparaten",
  "connectToADevice": "Verbinding maken met een apparaat - Gebruik en beheer Spotify op al je apparaten",
  "openDevicesMenu": "Het menu Apparaten openen",
  "scrobbleToLastfm": "Scrobblen naar Last.fm",
  "connectedAs": "Verbonden als",
  "logOut": "Uitloggen",
  "about": "Informatie",
  "legal": "Juridisch",
  "help": "Help",
  "connect": "Verbinden",
  "connectFacebook": "Verbinden met Facebook",
  "connectLastfm": "Verbinding maken met Last.FM",
  "disconnectFacebook": "Verbinding met Facebook verbreken",
  "disconnectLastfm": "Verbinding verbreken",
  "startupAndWindowBehavior": "Opstart- en venstergedrag",
  "closeShouldMinimize": "Met de knop Sluiten kun je het Spotify-venster minimaliseren naar het systeemvak",
  "autostart": "Spotify automatisch openen bij het inloggen op deze computer",
  "hideAdvancedSettings": "Geavanceerde instellingen verbergen",
  "showAdvancedSettings": "Geavanceerde instellingen weergeven",
  "autostartNormal": "Ja",
  "autostartMinimized": "Geminimaliseerd",
  "autostartOff": "Nee",
  "localFiles": "Lokale bestanden",
  "localFilesSources": "Geef nummers weer uit",
  "localFilesAddSource": "Een bron toevoegen",
  "localFilesSource_downloads": "Downloads",
  "localFilesSource_itunes": "iTunes",
  "localFilesSource_my_music": "Mijn muziek",
  "localFilesSource_windows_music_library": "Muziekbibliotheek",
  "localFilesSource_windows_media_player": "Windows Media Player",
  "accessibility": "Toegankelijkheid",
  "accessibilityColors": "Toegankelijkheidskleuren aanzetten",
  "recoverPlaylists": "Afspeellijsten herstellen",
  "playback": "Afspelen",
  "sameVolume": "Hetzelfde volume instellen voor alle nummers",
  "musicAnnouncements": "Muziekaankondigingen",
  "display": "Weergaveopties",
  "showMusicAnnouncements": "Aankondigingen weergeven over nieuwe releases",
  "showUnavailableTracks": "Niet-beschikbare nummers weergeven in afspeellijsten",
  "friendFeed": "Vriendenfeed weergeven",
  "showTrackNotifications": "Desktopnotificaties weergeven wanneer er van nummer wordt gewisseld",
  "cache": "Cache",
  "manuallySetCacheSize": "Cachegrootte handmatig instellen",
  "fileSystemLocationLabel": "Locatie:",
  "changeLocation": "Locatie wijzigen",
  "Proxy": "Proxy",
  "aboutSpotify": "Over Spotify",
  "auto-detect": "Automatisch detecteren",
  "no-proxy": "Geen proxy",
  "http": "HTTP",
  "socks4": "Socks4",
  "socks5": "Socks5",
  "crossfadeTracks": "Nummers in elkaar over laten lopen",
  "tracks": "nummers",
  "sec": "sec",
  "connectedToLastFmAs": "Verbinding gemaakt met Last.FM als {0}",
  "missingUsername": "Gebruikersnaam ontbreekt",
  "missingPassword": "Wachtwoord ontbreekt",
  "invalidUsernameOrPassword": "Ongeldige gebruikersnaam of wachtwoord",
  "compatibility": "Compatibiliteit",
  "enableHardwareAcceleration": "Hardwareversnelling inschakelen",
  "backToLogin": "Terug naar inloggen",
  "webhelper": "Toestaan ​​dat Spotify wordt geopend vanaf het web"
};
},{}],15:[function(require,module,exports){
module.exports = {
  "settings": "Ustawienia",
  "upgrade": "Przejdź na wyższą wersję",
  "viewAccount": "Zobacz konto",
  "language": "Język",
  "selectLanguage": "Wybierz język",
  "selectProxy": "Typ serwera proxy",
  "Host": "Host",
  "Port": "Port",
  "username": "Nazwa użytkownika",
  "password": "Hasło",
  "updateProxy": "Uaktualnij serwer proxy",
  "social": "Społecznościowe",
  "employeeFeatures": "Funkcje dla pracowników",
  "appLinks": "Łącza do aplikacji",
  "design": "Design",
  "designOptionAuto": "Automatycznie",
  "designOptionGLUE1": "GLUE 1",
  "designOptionGLUE2": "GLUE 2",
  "newPlaylistsPublic": "Automatycznie upubliczniaj nowe playlisty",
  "privateSession": "Sesja prywatna",
  "privateSessionInfo": "sesja prywatna trwa do czasu wylogowania",
  "spotify": "Spotify",
  "facebook": "Facebook",
  "lastfm": "Last.fm",
  "seeWhatFriendsAreListening": "Zobacz, czego słuchają Twoi znajomi",
  "shareOnFacebook": "Udostępnij aktywność na Facebooku",
  "publishActivity": "Publikuj aktywność w Spotify",
  "publishPlaylists": "Automatycznie upubliczniaj nowe playlisty",
  "publishTopArtists": "Pokaż mojego najlepszego wykonawcę",
  "publishActivityTopListener": "Oznaczaj mnie jako najlepszego słuchacza danych wykonawców",
  "musicQuality": "Jakość muzyki",
  "hqStreaming": "Streaming w wysokiej jakości (tylko wersja Premium)",
  "devices": "Urządzenia",
  "connectToADevice": "Podłącz do urządzenia, aby za jego pomocą sterować odtwarzaniem muzyki w Spotify",
  "openDevicesMenu": "Otwórz menu Urządzenia",
  "scrobbleToLastfm": "Scrobbluj do Last.fm",
  "connectedAs": "Połączono jako",
  "logOut": "Wyloguj",
  "about": "Informacje",
  "legal": "Informacje prawne",
  "help": "Pomoc",
  "connect": "Połącz",
  "connectFacebook": "Połącz z Facebookiem",
  "connectLastfm": "Połącz się z Last.FM",
  "disconnectFacebook": "Rozłącz się z Facebookiem",
  "disconnectLastfm": "Rozłącz",
  "startupAndWindowBehavior": "Uruchamianie i styl okna",
  "closeShouldMinimize": "Przycisk zamykania zminimalizuje okno Spotify do paska",
  "autostart": "Uruchamiaj Spotify automatycznie po zalogowaniu się na komputerze",
  "hideAdvancedSettings": "Ukryj ustawienia zaawansowane",
  "showAdvancedSettings": "Pokaż ustawienia zaawansowane",
  "autostartNormal": "Tak",
  "autostartMinimized": "Zminimalizowano",
  "autostartOff": "Nie",
  "localFiles": "Lokalne pliki",
  "localFilesSources": "Pokaż utwory użytkownika",
  "localFilesAddSource": "Dodaj źródło",
  "localFilesSource_downloads": "Pobrane pliki",
  "localFilesSource_itunes": "iTunes",
  "localFilesSource_my_music": "Moja muzyka",
  "localFilesSource_windows_music_library": "Biblioteka muzyki",
  "localFilesSource_windows_media_player": "Windows Media Player",
  "accessibility": "Dostępność",
  "accessibilityColors": "Włącz opcję oznaczania dostępności kolorami",
  "recoverPlaylists": "Odzyskaj playlisty",
  "playback": "Odtwarzanie",
  "sameVolume": "Ustaw ten sam poziom głośności dla wszystkich utworów",
  "musicAnnouncements": "Powiadomienia o muzyce",
  "display": "Opcje wyświetlacza",
  "showMusicAnnouncements": "Pokaż powiadomienia o nowych wydaniach",
  "showUnavailableTracks": "Pokaż utwory niedostępne w playliście",
  "friendFeed": "Pokaż kanał znajomego",
  "showTrackNotifications": "Pokaż powiadomienie na pulpicie, gdy zmieni się utwór",
  "cache": "Pamięć podręczna",
  "manuallySetCacheSize": "Ręcznie ustaw wielkość pamięci podręcznej",
  "fileSystemLocationLabel": "Lokalizacja:",
  "changeLocation": "Zmień lokalizację",
  "Proxy": "Serwer proxy",
  "aboutSpotify": "O Spotify",
  "auto-detect": "Automatyczne wykrywanie",
  "no-proxy": "Brak serwera proxy",
  "http": "HTTP",
  "socks4": "Socks4",
  "socks5": "Socks5",
  "crossfadeTracks": "Płynne przejście między utworami",
  "tracks": "utwory",
  "sec": "s",
  "connectedToLastFmAs": "Połącz się z Last.FM jako {0}",
  "missingUsername": "Brak nazwy użytkownika",
  "missingPassword": "Brak hasła",
  "invalidUsernameOrPassword": "Nieprawidłowa nazwa użytkownika lub hasło",
  "compatibility": "Zgodność",
  "enableHardwareAcceleration": "Włącz przyspieszenie sprzętowe",
  "backToLogin": "Powrót do logowania",
  "webhelper": "Zezwalaj na uruchamianie Spotify z Internetu"
};
},{}],16:[function(require,module,exports){
module.exports = {
  "settings": "Preferências",
  "upgrade": "Fazer upgrade",
  "viewAccount": "Ver a conta",
  "language": "Idioma",
  "selectLanguage": "Escolher idioma",
  "selectProxy": "Tipo de proxy",
  "Host": "Host",
  "Port": "Porta",
  "username": "Nome de usuário",
  "password": "Senha",
  "updateProxy": "Atualizar proxy",
  "social": "Redes sociais",
  "employeeFeatures": "Funcionalidades para funcionários",
  "appLinks": "Links para aplicativos",
  "design": "Design",
  "designOptionAuto": "Automático",
  "designOptionGLUE1": "GLUE 1",
  "designOptionGLUE2": "GLUE 2",
  "newPlaylistsPublic": "Mostrar as playlists novas para todos",
  "privateSession": "Sessão privada",
  "privateSessionInfo": "a sessão privada dura até você sair",
  "spotify": "Spotify",
  "facebook": "Facebook",
  "lastfm": "Last.fm",
  "seeWhatFriendsAreListening": "Veja o que seus amigos estão ouvindo",
  "shareOnFacebook": "Compartilhar minha atividade no Facebook",
  "publishActivity": "Publicar minha atividade no Spotify",
  "publishPlaylists": "Mostrar as playlists novas para todos",
  "publishTopArtists": "Mostrar meus artistas mais tocados atualmente",
  "publishActivityTopListener": "Publicar que sou um dos Melhores ouvintes dos artistas",
  "musicQuality": "Qualidade da música",
  "hqStreaming": "Transmissão de alta qualidade (só no Premium)",
  "devices": "Dispositivos",
  "connectToADevice": "Conectar a um dispositivo - Escute e controle o Spotify em todos os seus aparelhos",
  "openDevicesMenu": "Abrir o menu Dispositivos",
  "scrobbleToLastfm": "Scrobble na Last.fm",
  "connectedAs": "Conectado como",
  "logOut": "Sair",
  "about": "Sobre",
  "legal": "Legal",
  "help": "Ajuda",
  "connect": "Conectar",
  "connectFacebook": "Conectar ao Facebook",
  "connectLastfm": "Conectar a Last.FM",
  "disconnectFacebook": "Desconectar do Facebook",
  "disconnectLastfm": "Desconectar",
  "startupAndWindowBehavior": "Inicialização e comportamento da janela",
  "closeShouldMinimize": "O botão Fechar minimiza a janela do Spotify na bandeja",
  "autostart": "Abrir o Spotify quando entrar no computador",
  "hideAdvancedSettings": "Ocultar configurações avançadas",
  "showAdvancedSettings": "Mostrar configurações avançadas",
  "autostartNormal": "Sim",
  "autostartMinimized": "Minimizado",
  "autostartOff": "Não",
  "localFiles": "Arquivos locais",
  "localFilesSources": "Mostrar músicas de",
  "localFilesAddSource": "Adicionar uma origem",
  "localFilesSource_downloads": "Downloads",
  "localFilesSource_itunes": "iTunes",
  "localFilesSource_my_music": "Minhas músicas",
  "localFilesSource_windows_music_library": "Biblioteca de músicas",
  "localFilesSource_windows_media_player": "Windows Media Player",
  "accessibility": "Acessibilidade",
  "accessibilityColors": "Ligar cores de acessibilidade",
  "recoverPlaylists": "Recuperar playlists",
  "playback": "Reprodução",
  "sameVolume": "Definir o mesmo nível de volume para todas as músicas",
  "musicAnnouncements": "Anúncios de músicas",
  "display": "Opções de exibição",
  "showMusicAnnouncements": "Mostrar notícias sobre novos lançamentos",
  "showUnavailableTracks": "Mostrar músicas indisponíveis em playlists",
  "friendFeed": "Mostrar feed de amigos",
  "showTrackNotifications": "Mostrar notificações na área de trabalho ao mudar de música",
  "cache": "Cache",
  "manuallySetCacheSize": "Definir o tamanho do cache manualmente",
  "fileSystemLocationLabel": "Local:",
  "changeLocation": "Alterar local",
  "Proxy": "Proxy",
  "aboutSpotify": "Sobre o Spotify",
  "auto-detect": "Detectar automaticamente",
  "no-proxy": "Sem proxy",
  "http": "HTTP",
  "socks4": "Socks4",
  "socks5": "Socks5",
  "crossfadeTracks": "Fazer uma transição gradual entre as músicas",
  "tracks": "músicas",
  "sec": "s",
  "connectedToLastFmAs": "Conectado a Last.fm como {0}",
  "missingUsername": "Falta o nome de usuário",
  "missingPassword": "Falta a senha",
  "invalidUsernameOrPassword": "Nome de usuário ou senha inválidos",
  "compatibility": "Compatibilidade",
  "enableHardwareAcceleration": "Ativar aceleração de hardware",
  "backToLogin": "Voltar para Login",
  "webhelper": "Permitir que o Spotify seja aberto na Web"
};
},{}],17:[function(require,module,exports){
module.exports = {
  "settings": "Inställningar",
  "upgrade": "Uppgradera",
  "viewAccount": "Visa konto",
  "language": "Språk",
  "selectLanguage": "Välj språk",
  "selectProxy": "Proxytyp",
  "Host": "Värd",
  "Port": "Port",
  "username": "Användarnamn",
  "password": "Lösenord",
  "updateProxy": "Uppdatera proxy",
  "social": "Sociala nätverk",
  "employeeFeatures": "Funktioner för anställda",
  "appLinks": "Länkar till appar",
  "design": "Design",
  "designOptionAuto": "Auto",
  "designOptionGLUE1": "GLUE 1",
  "designOptionGLUE2": "GLUE 2",
  "newPlaylistsPublic": "Gör nya spellistor offentliga automatiskt",
  "privateSession": "Dold aktivitet",
  "privateSessionInfo": "din aktivitet är dold tills du loggar ut",
  "spotify": "Spotify",
  "facebook": "Facebook",
  "lastfm": "Last.fm",
  "seeWhatFriendsAreListening": "Se vad dina vänner lyssnar på",
  "shareOnFacebook": "Dela min aktivitet på Facebook",
  "publishActivity": "Publicera min aktivitet på Spotify",
  "publishPlaylists": "Gör nya spellistor offentliga automatiskt",
  "publishTopArtists": "Visa mina aktuella toppartister",
  "publishActivityTopListener": "Visa om jag är en av dem som lyssnat mest på en artist",
  "musicQuality": "Musikkvalitet",
  "hqStreaming": "Streama med hög kvalitet (endast Premium)",
  "devices": "Enheter",
  "connectToADevice": "Anslut till en enhet – lyssna på och styr Spotify på dina enheter.",
  "openDevicesMenu": "Öppna menyn Enheter",
  "scrobbleToLastfm": "Skrobbla till Last.fm",
  "connectedAs": "Ansluten som",
  "logOut": "Logga ut",
  "about": "Om",
  "legal": "Juridisk information",
  "help": "Hjälp",
  "connect": "Anslut",
  "connectFacebook": "Anslut till Facebook",
  "connectLastfm": "Anslut till Last.FM",
  "disconnectFacebook": "Koppla ifrån Facebook",
  "disconnectLastfm": "Koppla från",
  "startupAndWindowBehavior": "Start- och fönsterfunktioner",
  "closeShouldMinimize": "Knappen Stäng ska minimera Spotify-fönstret till systemfältet",
  "autostart": "Öppna Spotify automatiskt när du har loggat in på datorn",
  "hideAdvancedSettings": "Dölj avancerade inställningar",
  "showAdvancedSettings": "Visa avancerade inställningar",
  "autostartNormal": "Ja",
  "autostartMinimized": "Minimerat",
  "autostartOff": "Nej",
  "localFiles": "Lokala filer",
  "localFilesSources": "Visar låtar från",
  "localFilesAddSource": "Lägg till en källa",
  "localFilesSource_downloads": "Hämtningar",
  "localFilesSource_itunes": "iTunes",
  "localFilesSource_my_music": "Min musik",
  "localFilesSource_windows_music_library": "Musikbibliotek",
  "localFilesSource_windows_media_player": "Windows Media Player",
  "accessibility": "Hjälpmedel",
  "accessibilityColors": "Aktivera hjälpfärger",
  "recoverPlaylists": "Återställ spellistor",
  "playback": "Uppspelning",
  "sameVolume": "Använd samma volym för alla låtar",
  "musicAnnouncements": "Musikmeddelanden",
  "display": "Visningsalternativ",
  "showMusicAnnouncements": "Visa meddelanden om nya releaser",
  "showUnavailableTracks": "Visa låtar som inte är tillgängliga i spellistorna",
  "friendFeed": "Visa vänflöde",
  "showTrackNotifications": "Visa skrivbordsmeddelanden när låten ändras",
  "cache": "Cacheminne",
  "manuallySetCacheSize": "Ange cacheminnets storlek manuellt",
  "fileSystemLocationLabel": "Plats:",
  "changeLocation": "Byt plats",
  "Proxy": "Proxy",
  "aboutSpotify": "Om Spotify",
  "auto-detect": "Identifiera automatiskt",
  "no-proxy": "Ingen proxy",
  "http": "HTTP",
  "socks4": "Socks4",
  "socks5": "Socks5",
  "crossfadeTracks": "Tonade låtövergångar",
  "tracks": "spår",
  "sec": "sek",
  "connectedToLastFmAs": "Ansluten till Last.fm som {0}",
  "missingUsername": "Användarnamnet saknas",
  "missingPassword": "Lösenordet saknas",
  "invalidUsernameOrPassword": "Ogiltigt användarnamn eller lösenord",
  "compatibility": "Kompatibilitet",
  "enableHardwareAcceleration": "Aktivera maskinvaruacceleration",
  "backToLogin": "Tillbaka till inloggning",
  "webhelper": "Tillåt att Spotify öppnas från webben"
};
},{}],18:[function(require,module,exports){
module.exports = {
  "settings": "Ayarlar",
  "upgrade": "Yükselt",
  "viewAccount": "Hesabı görüntüle",
  "language": "Dil",
  "selectLanguage": "Dili seç",
  "selectProxy": "Proxy türü",
  "Host": "Sunucu",
  "Port": "Port",
  "username": "Kullanıcı adı",
  "password": "Parola",
  "updateProxy": "Proxy'yi Güncelle",
  "social": "Sosyal",
  "employeeFeatures": "Çalışan Özellikleri",
  "appLinks": "Uygulamalar için bağlantılar",
  "design": "Design",
  "designOptionAuto": "Otomatik",
  "designOptionGLUE1": "GLUE 1",
  "designOptionGLUE2": "GLUE 2",
  "newPlaylistsPublic": "Yeni çalma listelerini otomatik olarak herkese açık yap",
  "privateSession": "Gizli oturum",
  "privateSessionInfo": "oturum kapatılana kadar özel oturum devam eder",
  "spotify": "Spotify",
  "facebook": "Facebook",
  "lastfm": "Last.fm",
  "seeWhatFriendsAreListening": "Arkadaşlarının ne dinlediğini gör",
  "shareOnFacebook": "Hareketlerimi Facebook'ta paylaş",
  "publishActivity": "Hareketlerimi Spotify'da yayınla",
  "publishPlaylists": "Yeni çalma listelerini otomatik olarak herkese açık yap",
  "publishTopArtists": "Şu anki En Çok Dinlenen Sanatçılarımı göster",
  "publishActivityTopListener": "Beni sanatçılar için En Çok Dinleyen olarak yayınla",
  "musicQuality": "Müzik Kalitesi",
  "hqStreaming": "Yüksek kaliteli aktarma (yalnızca Premium)",
  "devices": "Cihazlar",
  "connectToADevice": "Bir cihaza bağla: Spotify'ı cihazlarında dinle ve kontrol et",
  "openDevicesMenu": "Cihazlar Menüsü'nü Aç",
  "scrobbleToLastfm": "Last.fm'de scrobble",
  "connectedAs": "Bağlandı:",
  "logOut": "Oturumu kapat",
  "about": "Hakkında",
  "legal": "Yasal",
  "help": "Yardım",
  "connect": "Bağlan",
  "connectFacebook": "Facebook'a Bağlan",
  "connectLastfm": "Last.FM'e bağla",
  "disconnectFacebook": "Facebook bağlantısını kes",
  "disconnectLastfm": "Bağlantıyı kes",
  "startupAndWindowBehavior": "Açılma ve Pencere Davranışı",
  "closeShouldMinimize": "Kapat düğmesi Spotify penceresini görev çubuğunda simge durumuna küçültür",
  "autostart": "Bilgisayarda oturum açıldığında Spotify'ı otomatik olarak başlat",
  "hideAdvancedSettings": "Gelişmiş ayarları gizle",
  "showAdvancedSettings": "Gelişmiş ayarları göster",
  "autostartNormal": "Evet",
  "autostartMinimized": "Küçültüldü",
  "autostartOff": "Hayır",
  "localFiles": "Yerel Dosyalar",
  "localFilesSources": "Şuradaki şarkılarını göster:",
  "localFilesAddSource": "Kaynak ekle",
  "localFilesSource_downloads": "İndirilenler",
  "localFilesSource_itunes": "iTunes",
  "localFilesSource_my_music": "Müziklerim",
  "localFilesSource_windows_music_library": "Müzik Kitaplığı",
  "localFilesSource_windows_media_player": "Windows Ortam Yürütücü",
  "accessibility": "Erişilebilirlik",
  "accessibilityColors": "Erişilebilirlik renklerini aç",
  "recoverPlaylists": "Çalma Listelerini Kurtar",
  "playback": "Çalma",
  "sameVolume": "Tüm şarkılar için aynı ses seviyesini kullan",
  "musicAnnouncements": "Müzik Duyuruları",
  "display": "Görüntüleme Seçenekleri",
  "showMusicAnnouncements": "Yeni çıkanlar hakkındaki duyuruları göster",
  "showUnavailableTracks": "Çalma listelerindeki çalınamayan şarkıları göster",
  "friendFeed": "Arkadaş akışını göster",
  "showTrackNotifications": "Şarkı değiştiğinde masaüstü bildirimleri göster",
  "cache": "Önbellek",
  "manuallySetCacheSize": "Önbellek boyutunu elle ayarla",
  "fileSystemLocationLabel": "Konum:",
  "changeLocation": "Konumu Değiştir",
  "Proxy": "Proxy",
  "aboutSpotify": "Spotify Hakkında",
  "auto-detect": "Otomatik Algıla",
  "no-proxy": "Proxy Yok",
  "http": "HTTP",
  "socks4": "Socks4",
  "socks5": "Socks5",
  "crossfadeTracks": "Şarkılarda çapraz geçiş",
  "tracks": "şarkı",
  "sec": "sn.",
  "connectedToLastFmAs": "Last.fm'e bağlanıldı: {0}",
  "missingUsername": "Kullanıcı adı eksik",
  "missingPassword": "Parola eksik",
  "invalidUsernameOrPassword": "Kullanıcı adı veya parola geçersiz",
  "compatibility": "Uyumluluk",
  "enableHardwareAcceleration": "Donanım hızlandırıcısını etkinleştir",
  "backToLogin": "Oturum Açma Ekranına Geri Dön",
  "webhelper": "Spotify'ın web'den açılmasına izin ver"
};
},{}],19:[function(require,module,exports){
module.exports = {
  "settings": "設定",
  "upgrade": "升級",
  "viewAccount": "查看帳戶",
  "language": "語言 ",
  "selectLanguage": "選擇語言",
  "selectProxy": "Proxy 類型",
  "Host": "主機",
  "Port": "連接埠",
  "username": "用戶名",
  "password": "密碼",
  "updateProxy": "更新 Proxy",
  "social": "社交",
  "employeeFeatures": "員工功能",
  "appLinks": "應用程式連結",
  "design": "Design",
  "designOptionAuto": "自動",
  "designOptionGLUE1": "GLUE 1",
  "designOptionGLUE2": "GLUE 2",
  "newPlaylistsPublic": "自動公開新的播放清單",
  "privateSession": "私人時段",
  "privateSessionInfo": "登出前私人時段不會中斷",
  "spotify": "Spotify",
  "facebook": "Facebook",
  "lastfm": "Last.fm",
  "seeWhatFriendsAreListening": "看看朋友正在收聽什麼",
  "shareOnFacebook": "在 Facebook 上分享個人動態",
  "publishActivity": "發佈個人動態至 Spotify",
  "publishPlaylists": "自動公開新的播放清單",
  "publishTopArtists": "顯示我目前的當紅藝人",
  "publishActivityTopListener": "發佈我是藝人的頭號粉絲",
  "musicQuality": "音質",
  "hqStreaming": "高音質串流 (僅限 Premium)",
  "devices": "裝置",
  "connectToADevice": "連接至裝置 - 在你的裝置上收聽及控制 Spotify",
  "openDevicesMenu": "開啟裝置選單",
  "scrobbleToLastfm": "推薦至 Last.fm",
  "connectedAs": "連接為",
  "logOut": "登出",
  "about": "關於",
  "legal": "法律條文",
  "help": "說明中心",
  "connect": "連線",
  "connectFacebook": "連接至 Facebook",
  "connectLastfm": "連接至 Last.FM",
  "disconnectFacebook": "中斷 Facebook 連線",
  "disconnectLastfm": "中斷連線",
  "startupAndWindowBehavior": "啟動及視窗行為",
  "closeShouldMinimize": "關閉按鈕可將 Spotify 視窗最小化至系統列。",
  "autostart": "登入電腦後自動開啟 Spotify",
  "hideAdvancedSettings": "隱藏進階設定",
  "showAdvancedSettings": "顯示進階設定",
  "autostartNormal": "是",
  "autostartMinimized": "最小化",
  "autostartOff": "否",
  "localFiles": "本機檔案",
  "localFilesSources": "顯示來自以下的歌曲：",
  "localFilesAddSource": "新增來源",
  "localFilesSource_downloads": "下載",
  "localFilesSource_itunes": "iTunes",
  "localFilesSource_my_music": "我的音樂",
  "localFilesSource_windows_music_library": "音樂庫",
  "localFilesSource_windows_media_player": "Windows Media Player",
  "accessibility": "無障礙",
  "accessibilityColors": "開啟輔助色彩",
  "recoverPlaylists": "恢復播放清單",
  "playback": "播放",
  "sameVolume": "設定所有歌曲音量相同",
  "musicAnnouncements": "音樂公告",
  "display": "顯示選項",
  "showMusicAnnouncements": "顯示最新發行公告",
  "showUnavailableTracks": "在播放清單中顯示無法播放的歌曲",
  "friendFeed": "顯示好友動態",
  "showTrackNotifications": "歌曲變更時顯示桌面通知",
  "cache": "快取",
  "manuallySetCacheSize": "手動設定快取大小",
  "fileSystemLocationLabel": "位置：",
  "changeLocation": "變更位置",
  "Proxy": "Proxy",
  "aboutSpotify": "關於 Spotify",
  "auto-detect": "自動偵測",
  "no-proxy": "無 Proxy",
  "http": "HTTP",
  "socks4": "Socks4",
  "socks5": "Socks5",
  "crossfadeTracks": "淡入/淡出歌曲",
  "tracks": " 首歌曲",
  "sec": "秒",
  "connectedToLastFmAs": "連接到 Last.fm 為 {0}",
  "missingUsername": "缺少使用者名稱",
  "missingPassword": "缺少密碼",
  "invalidUsernameOrPassword": "無效的使用者名稱或密碼",
  "compatibility": "相容性",
  "enableHardwareAcceleration": "開啟硬體加速 (Enable hardware acceleration)",
  "backToLogin": "返回登入",
  "webhelper": "允許 Spotify 從網路中開啟"
};
},{}],20:[function(require,module,exports){
module.exports = {
  "settings": "Tetapan",
  "upgrade": "Naik taraf",
  "viewAccount": "Lihat akaun",
  "language": "Bahasa",
  "selectLanguage": "Pilih bahasa",
  "selectProxy": "Jenis Proxy",
  "Host": "Hos",
  "Port": "Port",
  "username": "Nama pengguna",
  "password": "Kata laluan",
  "updateProxy": "Kemaskini Proksi",
  "social": "Sosial",
  "employeeFeatures": "Ciri untuk Pekerja",
  "appLinks": "Pautan kepada aplikasi",
  "design": "Design",
  "designOptionAuto": "Auto",
  "designOptionGLUE1": "GLUE 1",
  "designOptionGLUE2": "GLUE 2",
  "newPlaylistsPublic": "Secara automatik jadikan playlist baru sebagai umum",
  "privateSession": "Sesi peribadi",
  "privateSessionInfo": "sesi peribadi berlangsung sehingga anda log keluar",
  "spotify": "Spotify",
  "facebook": "Facebook",
  "lastfm": "Last.fm",
  "seeWhatFriendsAreListening": "Lihat apa yang rakan anda dengar",
  "shareOnFacebook": "Kongsi aktiviti saya di Facebook",
  "publishActivity": "Terbitkan aktiviti saya di Spotify",
  "publishPlaylists": "Secara automatik jadikan playlist baru sebagai umum",
  "publishTopArtists": "Paparkan Artis Paling Popular semasa saya",
  "publishActivityTopListener": "Terbitkan saya sebagai Pendengar Paling Popular untuk artis",
  "musicQuality": "Kualiti Muzik",
  "hqStreaming": "Penstriman berkualiti tinggi (Premium sahaja)",
  "devices": "Peranti",
  "connectToADevice": "Sambung ke peranti - Dengar dan kawal Spotify pada peranti anda",
  "openDevicesMenu": "Buka Menu Peranti",
  "scrobbleToLastfm": "Scrobble ke Last.fm",
  "connectedAs": "Disambungkan sebagai",
  "logOut": "Log keluar",
  "about": "Perihal",
  "legal": "Undang-undang",
  "help": "Bantuan",
  "connect": "Sambung",
  "connectFacebook": "Sambung ke Facebook",
  "connectLastfm": "Sambung ke Last.FM",
  "disconnectFacebook": "Putuskan sambungan dari Facebook",
  "disconnectLastfm": "Putuskan sambungan",
  "startupAndWindowBehavior": "Permulaan dan Perilaku Tetingkap",
  "closeShouldMinimize": "Butang tutup sepatutnya meminimumkan tetingkap Spotify menjadi ceper",
  "autostart": "Buka Spotify secara automatik selepas anda log masuk ke dalam komputer",
  "hideAdvancedSettings": "Sembunyikan tetapan lanjut",
  "showAdvancedSettings": "Tunjukkan tetapan lanjut",
  "autostartNormal": "Ya",
  "autostartMinimized": "Dikurangkan",
  "autostartOff": "Tidak",
  "localFiles": "Fail Tempatan",
  "localFilesSources": "Tunjukkan lagu daripada",
  "localFilesAddSource": "Tambah sumber",
  "localFilesSource_downloads": "Muatan Turun",
  "localFilesSource_itunes": "iTunes",
  "localFilesSource_my_music": "Muzik Saya",
  "localFilesSource_windows_music_library": "Perpustakaan Muzik",
  "localFilesSource_windows_media_player": "Windows Media Player",
  "accessibility": "Kebolehcapaian",
  "accessibilityColors": "Hidupkan warna kebolehcapaian",
  "recoverPlaylists": "Pulihkan Senarai main",
  "playback": "Main Semula",
  "sameVolume": "Tetapkan tahap kelantangan yang sama untuk semua lagu",
  "musicAnnouncements": "Pengumuman Muzik",
  "display": "Pilihan Paparan",
  "showMusicAnnouncements": "Tunjukkan pengumuman tentang keluaran baharu",
  "showUnavailableTracks": "Tunjukkan lagu yang tidak tersedia dalam senarai main",
  "friendFeed": "Tunjukkan suapan rakan",
  "showTrackNotifications": "Tunjukkan pemberitahuan desktop apabila lagu berubah",
  "cache": "Cache",
  "manuallySetCacheSize": "Tetapkan saiz cache secara manual",
  "fileSystemLocationLabel": "Lokasi:",
  "changeLocation": "Tukar Lokasi",
  "Proxy": "Proksi",
  "aboutSpotify": "Tentang Spotify",
  "auto-detect": "Auto Kesan",
  "no-proxy": "Tiada Proksi",
  "http": "HTTP",
  "socks4": "Socks4",
  "socks5": "Socks5",
  "crossfadeTracks": "Lenyap silang lagu",
  "tracks": "lagu",
  "sec": "saat",
  "connectedToLastFmAs": "Sambung ke Last.fm sebagai {0}",
  "missingUsername": "Hilang nama pengguna",
  "missingPassword": "Hilang kata laluan",
  "invalidUsernameOrPassword": "Nama pengguna atau kata laluan tidak sah.",
  "compatibility": "Keserasian",
  "enableHardwareAcceleration": "Dayakan pemecutan perkakasan",
  "backToLogin": "Kembali ke Log masuk",
  "webhelper": "Benarkan Spotify dibuka dari web"
};
},{}],21:[function(require,module,exports){
(function (global){
'use strict';

/**
 * Module dependencies
 */

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var EventEmitter = require('events').EventEmitter;

/**
 * Binds a named event on element
 * to an object
 *
 * @api private
 * @param {Element} el
 * @param {String} event
 * @param {Object} ctx
 */

function bind(el, event, ctx) {
  var fn = (ctx['on' + event] || ctx[event]).bind(ctx);
  ctx._events = ctx._events || {};
  ctx._events[event] = fn;
  el.addEventListener(event, fn, false);
}

/**
 * Unbinds a named event on a given
 * element from an object
 *
 * @api private
 * @param {Element} el
 * @param {String} event
 * @param {Object} ctx
 */

function unbind(el, event, ctx) {
  var fn = (ctx._events || {})[event];
  el.removeEventListener(event, fn);
  if (ctx._events) {
    delete ctx._events[event];
  }
}

/**
 * Constrains a value to not exceed a
 * minimum and maximum value
 */

function constrain(value, min, max) {
  if (value > max) {
    return max;
  } else if (value < min) {
    return min;
  }

  return value;
}

/**
 * Returns a `translate3d' value for
 * a `transform' CSS property
 *
 * @api private
 * @param {Object} coords
 */

function translate3d(coords) {
  return 'translate3d(' + (coords.x || 0) + 'px, ' + (coords.y || 0) + 'px, ' + (coords.z || 0.0001) + 'px' + ')';
}

/**
 * Returns the x and y coords from an event
 *
 * @param {Event} e
 * @returns coords {x: {Number} ,y: {Number} }
 */

function getCoords(e) {
  var coords = {
    x: null,
    y: null
  };
  if (isTouch(e)) {
    coords.x = e.changedTouches[0].clientX;
    coords.y = e.changedTouches[0].clientY;
  } else {
    coords.x = e.pageX;
    coords.y = e.pageY;
  }

  return coords;
}

/**
 * Returns the 'move' and 'end'  attributes from an event
 *
 * @param {Event} e
 * @returns attr {move: {Event.type} ,end: {Event.type} }
 */

function getListenerAttributes(e) {
  var attr = {
    move: null,
    end: null
  };
  if (isTouch(e)) {
    attr.move = 'touchmove';
    attr.end = 'touchend';
  } else {
    attr.move = 'mousemove';
    attr.end = 'mouseup';
  }

  return attr;
}

/**
 * Function to decide if an event is touch or mouse
 *
 * @param {Event} e
 */

function isTouch(e) {
  if (e.type === 'touchstart' || e.type === 'touchmove' || e.type === 'touchend' || e.type === 'touchcancel') {
    return true;
  }

  return false;
}

/**
 * `Range' constructor
 *
 * @api private
 * @param {Object} opts
 */

function Range(options) {
  if (!(this instanceof Range)) {
    return new Range(options);
  }

  var opts = options || {};

  this.x = opts.x || 0;
  this.y = opts.y || 0;

  return this;
}

/**
 * Sets (x, y) range
 *
 * @api public
 * @param {Number} x
 * @param {Number} y
 */

Range.prototype.set = function (x, y) {
  this.x = x;
  this.y = y;
  return this;
};

/**
 * Increments current range
 *
 * @api public
 * @param {Number} x
 * @param {Number} y
 */

Range.prototype.increment = function (x, y) {
  this.x += x;
  this.y += y;
  return this;
};

/**
 * Decrements current range
 *
 * @api public
 * @param {Number} x
 * @param {Number} y
 */

Range.prototype.increment = function (x, y) {
  this.x -= x;
  this.y -= y;
  return this;
};

/**
 * `Translation' constructor
 *
 * @api private
 * @param {Element} el
 */

function Translation(el) {
  if (!(this instanceof Translation)) {
    return new Translation(el);
  }

  Range.call(this);

  // @see: http://bit.ly/1v3hcoA
  this.matrix = new global.WebKitCSSMatrix('none');
  this.el = el;

  return this;
}

// inherit `Range'
Translation.prototype = Object.create(Range.prototype, {
  constructor: {
    value: Translation
  }
});

/**
 * Computes translation (translate3d) for
 * instance element
 *
 * @api public
 */

Translation.prototype.compute = function () {
  var style = getComputedStyle(this.el);
  var transform = style.transform || style.webkitTransform;

  if (transform !== 'none') {
    this.matrix.setMatrixValue(transform);
    this.set(this.matrix.m41, this.matrix.m42);
  }

  return this;
};

/**
 * `Drag' constructor
 *
 * @api public
 * @param {Element} el
 * @param {Object} opts - optional
 */

module.exports = Drag;
function Drag(el, opts) {
  if (!(this instanceof Drag)) {
    return new Drag(el, opts);
  }

  EventEmitter.call(this);

  // init
  this.translation = new Translation(el);
  this.disabled = false;
  this.smooth = opts.smooth || false;
  this.origin = new Range({
    x: 0,
    y: 0
  });
  this.coords = new Range({
    x: 0,
    y: 0
  });
  this.range = new Range(opts.range);
  this.start = new Range({
    x: 0,
    y: 0
  });
  this.axis = opts.axis || null;
  this.el = el;

  // initialize event listeners
  bind(el, 'mousedown', this);
  bind(el, 'touchstart', this);

  return this;
}

// inherit `EventEmitter'
Drag.prototype = Object.create(EventEmitter.prototype, {
  constructor: {
    value: Drag
  }
});

/**
 * Handles `onmousedown' events
 *
 * @api private
 * @param {Event} e
 */

Drag.prototype.onmousedown = function (e) {
  this.handleDragStart(e);
};

/**
 * Handles `ontouchstart' events
 *
 * @api private
 * @param {Event} e
 */

Drag.prototype.ontouchstart = function (e) {
  this.handleDragStart(e);
};

/**
 * Handles `onmousemove' events
 *
 * @api private
 * @param {Event} e
 */

Drag.prototype.onmousemove = function (e) {
  this.handleDrag(e);
};

/**
 * Handles `ontouchmove' events
 *
 * @api private
 * @param {Event} e
 */

Drag.prototype.ontouchmove = function (e) {
  this.handleDrag(e);
};

/**
 * Handles `onmouseup' events
 *
 * @api private
 * @param {Event} e
 */

Drag.prototype.onmouseup = function (e) {
  this.handleDragEnd(e);
};

/**
 * Handles `ontouchend' events
 *
 * @api private
 * @param {Event} e
 */

Drag.prototype.ontouchend = function (e) {
  this.handleDragEnd(e);
};

/**
 * Handles a 'dragstart' event for touch and mouse
 * @param {Event} e
 */

Drag.prototype.handleDragStart = function (e) {
  e.stopPropagation();

  if (this.disabled === true) {
    return false;
  }

  this.el.classList.add('dragging');

  // update origin range
  this.origin.set(this.el.offsetLeft, this.el.offsetTop);

  // Set current coords
  var currentCoords = getCoords(e);
  this.start.set(currentCoords.x, currentCoords.y);

  if (this.smooth === true) {
    this.translation.compute();
  }

  // Set listener attributes
  var attr = getListenerAttributes(e);
  bind(document, attr.move, this);
  bind(document, attr.end, this);

  this.emit('dragstart', e);

  return true;
};

/**
 * Handles a 'drag' event for touch and mouse
 * @param {Event} e
 */

Drag.prototype.handleDrag = function (e) {
  e.preventDefault();
  e.stopPropagation();

  if (this.disabled === true) {
    return false;
  }

  // Set coords
  var currentCoords = getCoords(e);
  var x = this.origin.x + (currentCoords.x - this.start.x);
  var y = this.origin.y + (currentCoords.y - this.start.y);
  var constraint = null;

  if (this.smooth === true) {
    x = x - (this.origin.x - this.translation.x);
    y = y - (this.origin.y - this.translation.y);
  }

  constraint = this.constraints(x, y);
  this.coords.set(constraint.x, constraint.y);
  this.update();
  this.emit('drag', e);

  return true;
};

/**
 * Handles a 'dragend' event for touch and mouse
 * @param {Event} e
 */

Drag.prototype.handleDragEnd = function (e) {
  if (this.disabled === true) {
    return false;
  }

  this.el.classList.remove('dragging');

  // Unbind listeners
  var attr = getListenerAttributes(e);
  unbind(document, attr.move, this);
  unbind(document, attr.end, this);

  this.emit('dragend', e);

  return true;
};

/**
 * Returns current coordinate constraints based
 * on input coordinates
 *
 * @api public
 * @param {Number} x
 * @param {Number} y
 */

Drag.prototype.constraints = function (_x, _y) {
  var x = _typeof(this.range.x) === 'object' ? constrain(_x, this.range.x[0], this.range.x[1]) : _x;

  var y = _typeof(this.range.y) === 'object' ? constrain(_y, this.range.y[0], this.range.y[1]) : _y;

  // reset coord based on axis contraint
  if (this.axis === 'x') {
    y = 0;
  } else if (this.axis === 'y') {
    x = 0;
  }

  return {
    x: x,
    y: y
  };
};

/**
 * Updates position based on state
 *
 * @api public
 */

Drag.prototype.update = function () {
  if (this.disabled === true) {
    return false;
  } else if (this.smooth === true) {
    this.el.style.transform = translate3d(this.coords);
  } else {
    this.el.style.left = this.coords.x + 'px';
    this.el.style.top = this.coords.y + 'px';
  }
  return this;
};

/**
 * Sets position and updates state
 *
 * @api public
 * @param {Number} x
 * @param {Number} y
 */

Drag.prototype.position = function (x, y) {
  if (this.disabled === true) {
    return false;
  }

  this.coords.set(x, y);
  return this.update();
};

/**
 * Enables dragging
 *
 * @api public
 */

Drag.prototype.enable = function () {
  this.el.classList.remove('disabled');
  this.disabled = false;
  return this;
};

/**
 * Disables dragging
 *
 * @api public
 */

Drag.prototype.disable = function () {
  this.el.classList.add('disabled');
  this.disabled = true;
  return this;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"events":271}],22:[function(require,module,exports){
'use strict';

/**
 * Module dependencies
 */

var loc = require('../i18n');
var bind = Function.prototype.bind.bind(Function.prototype.call);
var slice = bind(Array.prototype.slice);

/**
 * Returns i18n text for current
 * localization setting
 *
 * @api public
 * @param {String} text
 */

function i18n(text) {
  var value = loc.get(text);
  if (arguments.length > 1) {
    value = slice(arguments, 1).reduce(function (str, arg, i) {
      var regex = new RegExp('\\{' + i + '\\}', 'g');
      return str.replace(regex, arg);
    }, value);
  }

  return value || text;
}

/**
 * Checks if key exists in i18n
 * data stucture
 *
 * @api public
 * @param {String} key
 */

i18n.exists = function (key) {
  return !loc.get(key) || loc.get(key) !== key;
};

/**
 * Exports
 */

module.exports = i18n;

},{"../i18n":11}],23:[function(require,module,exports){
(function (global){
'use strict';

/**
 * Module dependencies
 */

var glue = require('../../../libs/spotify-glue-cat');
glue.gridOverlay.listen();

var Batch = require('spotify-batch');
var helpers = require('../../../libs/spotify-handlebars/helpers');
var hbs = require('../../../libs/spotify-handlebars');
var $ = require('../../../libs/spotify-elements');
var LOGIN_APP_URI = 'spotify:app:zlogin';

var events = require('./needed-events');

var isLoggedIn = !!global.__spotify.username;

// Initialize locale.
require('../../../libs/spotify-handlebars/helpers/numeral').setLocale(window.__spotify.locale);

require('../../../libs/spotify-live-models/client-storage').register();

var live = require('../../../libs/spotify-live');
var user = require('../../../libs/spotify-live-models/user');
var client = require('../../../libs/spotify-live-models/client');

if (isLoggedIn) {
  user.register();
  client.register();
}

/**
 * Container RPC
 */
var rpc = require('./rpc');

/**
 * Application models
 */
var models = require('../models');

/**
 * Views
 */
var views = {
  header: require('../views/header.hbs'),
  footer: require('../views/footer.hbs'),
  index: require('../views/index.hbs'),
  prelogin: require('../views/prelogin.hbs'),
  preloginFooter: require('../views/prelogin-footer.hbs')
};

/**
 * Resources
 */

var resources = [require('../resources/account'), require('../resources/user')];

/**
 * Setting contexts in the order in
 * which they will be rendered
 */

var contexts = [
// basic
require('../settings/language'), require('../settings/music-quality'), require('../settings/devices'), require('../settings/social'), require('../settings/local-files'), require('../settings/accessibility'), require('../settings/display'),

// advanced
require('../settings/playback'), require('../settings/window-handling'), require('../settings/cache'), require('../settings/proxy'), require('../settings/compatibility'), require('../settings/employee-features')];

var preloginContexts = [require('../settings/proxy')];

function updateHeader() {
  $('#header').html(views.header(models.serialize()));
  var node = $('#upgradeAccount');
  var account = models.get('account');

  if (!account.get('premium')) {
    node.removeClass('hidden');
    node.off('click').on('click', function () {
      window.open(account.get('upgradeUrl'));
    });
  } else {
    node.addClass('hidden');
  }

  $('#viewAccount').off('click').on('click', function () {
    window.open(account.get('viewUrl'));
  });

  events.update();
}

// register spotify handlebars helpers
hbs.register(helpers);

// i18n intialization
var i18n = require('../i18n');
var strings = i18n.appStrings();
helpers.loc.register(strings);

// custom helpers
hbs.register({
  sliderRangeSetting: require('./view-helpers/sliderRangeSetting'),
  sliderSetting: require('./view-helpers/sliderSetting'),
  selectSetting: require('./view-helpers/selectSetting')
});

/**
 * Fetch resources
 */
var tasks = new Batch().concurrency(1);

if (isLoggedIn) {
  tasks.push(function (next) {
    var batch = new Batch().concurrency(1);

    // enqueue resources
    resources.forEach(function (res) {
      if (typeof res.fetch === 'function') {
        batch.push(function (done) {
          res.fetch(done);
        });
      }
    });

    batch.run(next);
  });
}

/**
 * Render index view
 */
if (isLoggedIn) {
  tasks.push(function (next) {
    var data = models.serialize();
    updateHeader();
    $('#settings').html(views.index(data));
    $('#footer').html(views.footer(data));

    models.get('user').on('update', updateHeader);

    next();
  });
} else {
  tasks.push(function (next) {
    var inlineWindowControls = window.__spotify.os && window.__spotify.os.inline_window_controls;

    var data = {
      title: strings.settings,
      message: strings.restartClient,
      inlineWindowControls: inlineWindowControls
    };
    $('html').addClass('prelogin');
    $('#settings').html(views.prelogin(data));
    $('#footer').html(views.preloginFooter());

    next();
  });
}

/**
 * Initialize setting contexts
 */

if (isLoggedIn) {
  tasks.push(function (next) {
    var batch = new Batch().concurrency(1);

    // enqueue each context synchronization
    contexts.forEach(function (ctx) {
      if (typeof ctx.sync === 'function') {
        batch.push(function (done) {
          ctx.sync(done);
        });
      }
    });

    // enqueue each context initialization
    contexts.forEach(function (ctx) {
      if (typeof ctx.init === 'function') {
        batch.push(function (done) {
          ctx.init(done);
        });
      }
    });

    batch.run(function (err) {
      if (err) {
        throw err;
      }
      next();
    });
  });
} else {
  tasks.push(function (next) {
    var batch = new Batch().concurrency(1);

    preloginContexts.forEach(function (ctx) {
      if (typeof ctx.sync === 'function') {
        batch.push(function (done) {
          ctx.sync(done);
        });
      }
    });

    preloginContexts.forEach(function (ctx) {
      if (typeof ctx.init === 'function') {
        batch.push(function (done) {
          ctx.init(done);
        });
      }
    });

    batch.run(function (err) {
      if (err) {
        throw err;
      }
      next();
    });
  });
}

/**
 * Handle global model events
 */

if (isLoggedIn) {
  tasks.push(function (next) {
    var account;
    account = models.get('account');
    account.on('update', updateHeader);

    var settings = models.get('settings');
    settings.on('update', function (data) {
      if (data.advancedSettings === true) {
        $('#hideAdvancedSettings').removeClass('hidden');
        $('#showAdvancedSettings').addClass('hidden');
        $('#advanced-settings').removeClass('hidden');
      } else if (data.advancedSettings === false) {
        $('#hideAdvancedSettings').addClass('hidden');
        $('#showAdvancedSettings').removeClass('hidden');
        $('#advanced-settings').addClass('hidden');
      }
    });

    next();
  });
}

/**
 * Update UI elements that are affected by the incognito mode.
 */

tasks.push(function (next) {
  var settingsElement = document.querySelector('#settings');
  var incognitoStateInputs = document.querySelectorAll('.incognito-state input');

  live('spotify:client').get('session', function (err, session) {
    toggleIncognitoElements(session.get('incognito'));

    session.on('update', function (data) {
      var isIncognitoMode = data.incognito || session.get('incognito');
      toggleIncognitoElements(isIncognitoMode);
    });
  });

  next();

  function toggleIncognitoElements(isDisabled) {
    $(settingsElement).toggleClass('is-incognito', isDisabled);

    $(incognitoStateInputs).forEach(function (input) {
      input.disabled = isDisabled;
    });
  }
});

/**
 * Initialize DOM event handlers
 */

tasks.push(function (next) {
  var settings = models.get('settings');

  // prevent form submission when user hits
  // enter on any input field
  var doc = $(document);
  doc.delegate('submit', 'form', function (e) {
    e.preventDefault();
    e.stopPropagation();
    return false;
  });

  // Advanced settings
  doc.delegate('click', '#hideAdvancedSettings', function () {
    settings.update({
      advancedSettings: false
    });
  });

  doc.delegate('click', '#showAdvancedSettings', function () {
    settings.update({
      advancedSettings: true
    });
  });

  doc.delegate('click', '#logout', function () {
    rpc.logout();
  });

  // Pre-login
  doc.delegate('click', '#login', function (event) {
    event.preventDefault();
    global.location.href = LOGIN_APP_URI;
  });

  next();
});

/**
 * Initialize event bus
 */

events.attach();

/**
 * Run boot tasks
 */

tasks.run(function (err) {
  if (err) {
    console.error(err.stack ? err.stack : err);
  }

  // notify zlink
  rpc.notifyLoaded();

  // hide loading view
  document.querySelector('#loading').style.display = 'none';

  // update bus
  events.update();
});

require('../../../libs/spotify-expose-dev-mode-debug-globals/bridge').init();
require('../../../libs/spotify-expose-dev-mode-debug-globals/live').init();
require('../../../libs/spotify-expose-dev-mode-debug-globals/cosmos').init();

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../../libs/spotify-elements":149,"../../../libs/spotify-expose-dev-mode-debug-globals/bridge":163,"../../../libs/spotify-expose-dev-mode-debug-globals/cosmos":164,"../../../libs/spotify-expose-dev-mode-debug-globals/live":166,"../../../libs/spotify-glue-cat":186,"../../../libs/spotify-handlebars":208,"../../../libs/spotify-handlebars/helpers":199,"../../../libs/spotify-handlebars/helpers/numeral":203,"../../../libs/spotify-live":217,"../../../libs/spotify-live-models/client":213,"../../../libs/spotify-live-models/client-storage":212,"../../../libs/spotify-live-models/user":214,"../i18n":11,"../models":31,"../resources/account":34,"../resources/user":39,"../settings/accessibility":40,"../settings/cache":43,"../settings/compatibility":46,"../settings/devices":49,"../settings/display":54,"../settings/employee-features":69,"../settings/language":76,"../settings/local-files":79,"../settings/music-quality":83,"../settings/playback":87,"../settings/proxy":91,"../settings/social":98,"../settings/window-handling":116,"../views/footer.hbs":125,"../views/header.hbs":126,"../views/index.hbs":127,"../views/prelogin-footer.hbs":128,"../views/prelogin.hbs":129,"./needed-events":24,"./rpc":26,"./view-helpers/selectSetting":27,"./view-helpers/sliderRangeSetting":28,"./view-helpers/sliderSetting":29,"spotify-batch":351}],24:[function(require,module,exports){
'use strict';

var anchor = require('../../../libs/spotify-events/anchor');
var scrollbar = require('../../../libs/spotify-events/scrollbar');
var slider = require('../../../libs/spotify-events/slider');
var select = require('../../../libs/spotify-events/select');

module.exports = {
  update: function update() {
    anchor.update();
    scrollbar.update();
    slider.update();
    select.update();
  },
  attach: function attach() {
    anchor.attach();
    scrollbar.attach();
    slider.attach();
    select.attach();
  },
  detach: function detach() {
    anchor.detach();
    scrollbar.detach();
    slider.detach();
    select.detach();
  }
};

},{"../../../libs/spotify-events/anchor":152,"../../../libs/spotify-events/scrollbar":158,"../../../libs/spotify-events/select":161,"../../../libs/spotify-events/slider":162}],25:[function(require,module,exports){
'use strict';

/**
 * Module dependencies
 */

var bridge = require('../../../libs/spotify-bridge-request');

/**
 * Get client web token
 * bridge end point
 */

var CLIENT_WEB_TOKEN_REQ = 'client_get_web_token';

/**
 * Bridge request timeout in milliseconds
 */

var BRIDGE_REQUEST_TIMEOUT = 1000;

/**
 * Creates a timeout and calls
 * `fn' if not cleared
 *
 * @api private
 * @param {Function} fn
 */

function timeout(fn) {
  // timeout after `300ms'
  return setTimeout(fn.bind(null, new Error('bridge() request timeout')), BRIDGE_REQUEST_TIMEOUT);
}

/**
 * Retrieves oAuth token for URL
 * from bridge for active uer
 *
 * @api public
 * @param {String} url
 * @param {Function} fn
 */

exports.get = function (url, fn) {
  var to = timeout(fn);
  // make request
  bridge.request(CLIENT_WEB_TOKEN_REQ, [url], function (err, res) {
    clearTimeout(to);

    if (err) {
      fn(err);
      return;
    }

    fn(null, res ? res.token : null);
  });

  return this;
};

},{"../../../libs/spotify-bridge-request":144}],26:[function(require,module,exports){
'use strict';

// define `postMessage' on exports so
// the function can be overloaded for
// testing/dependency injection

exports.postMessage = typeof window !== 'undefined' && window.parent ? window.parent.postMessage.bind(window.parent) : function () {};

/**
 * Sends a message with type and data and
 * an optional target
 *
 * @api public
 * @param {String} type
 * @param {Mixed} data - optional
 * @param {String} target - optional (Default: '*')
 */

exports.send = function (type, data, target) {
  var enc = {
    type: type
  };

  // encode if data present
  if (data) {
    enc.data = data;
    enc = JSON.stringify(enc);
  }

  // send
  exports.postMessage(enc, target || '*');
  return this;
};

/**
 * Sends a logout message
 *
 * @api public
 */

exports.logout = function () {
  return this.send('logout');
};

/**
 * Notifies application has loaded
 *
 * @api public
 */

exports.notifyLoaded = function () {
  return this.send('notify_loaded');
};

},{}],27:[function(require,module,exports){
'use strict';

/**
 * Module dependencies
 */

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var tpl = require('../../templates/selectSetting.hbs');
var Handlebars = require('../../../../libs/spotify-handlebars');
var live = require('../../../../libs/spotify-live');

/**
 * Export a handlebars helper to render a settings row with a select
 *
 * @api public
 * @param {String} uri - Uri to the controlled live model
 * @param {String} id
 */

module.exports = function (uri, id, selectableOptions, description) {
  var options = (typeof selectableOptions === 'undefined' ? 'undefined' : _typeof(selectableOptions)) !== 'object' ? live(uri).get(selectableOptions).serialize() : selectableOptions;

  return new Handlebars.runtime.SafeString(tpl({
    description: description.fn(this),
    uri: uri,
    property: id,
    selected: live(uri).get(id),
    options: options
  }));
};

},{"../../../../libs/spotify-handlebars":208,"../../../../libs/spotify-live":217,"../../templates/selectSetting.hbs":122}],28:[function(require,module,exports){
'use strict';

/**
 * Module dependencies
 */

var Handlebars = require('../../../../libs/spotify-handlebars');
var live = require('../../../../libs/spotify-live');
var tpl = require('../../templates/sliderRangeSetting.hbs');

/**
 * Slider range helper
 *
 * @param {String} uri
 * @param {String} property
 * @param {Boolean} allowedProperty
 */

module.exports = function (uri, property, _allowedProperty) {
  var len = arguments.length;
  var allowed = true;
  var allowedProperty = _allowedProperty;

  if (len === 4 && typeof allowedProperty === 'string') {
    allowed = live(uri).get(allowedProperty);
  } else {
    allowedProperty = undefined;
  }

  return new Handlebars.runtime.SafeString(tpl({
    allowedProperty: allowedProperty,
    property: property,
    enabled: live(uri).get(property),
    allowed: allowed,
    uri: uri
  }));
};

},{"../../../../libs/spotify-handlebars":208,"../../../../libs/spotify-live":217,"../../templates/sliderRangeSetting.hbs":123}],29:[function(require,module,exports){
'use strict';

/**
 * Module dependencies
 */

var Handlebars = require('../../../../libs/spotify-handlebars');
var live = require('../../../../libs/spotify-live');
var tpl = require('../../templates/sliderSetting.hbs');

/**
 * Export a handlebars helper to render a settings row with a slider
 *
 * @param {String} uri - Uri to the controlled live model
 * @param {String} property - Name of property to control on live model
 * @param {String} className - ClassNames we want to add
 *     to the container
 * @param {Boolean} allowedProperty - Name of property defining if
 *     setting is available.
 *     If not specified, the setting will be available.
 *     If false, the slider will become disabled.
 */

module.exports = function (uri, property, className, _allowedProperty) {
  var nArguments = arguments.length;
  var options = arguments[nArguments - 1];
  var allowed = true;
  var containerClassName;
  var allowedProperty = _allowedProperty;

  if (typeof className === 'string') {
    containerClassName = className;
  }

  if (nArguments === 5 && typeof allowedProperty === 'string') {
    allowed = live(uri).get(allowedProperty);
  } else {
    allowedProperty = undefined;
  }

  var value = live(uri).get(property);

  // Only render this helper's contents if the property is well defined.
  if (value === undefined) {
    return new Handlebars.runtime.SafeString('');
  }

  return new Handlebars.runtime.SafeString(tpl({
    description: options.fn && options.fn(this),
    uri: uri,
    property: property,
    containerClassName: containerClassName,
    allowedProperty: allowedProperty,
    enabled: value,
    allowed: allowed
  }));
};

},{"../../../../libs/spotify-handlebars":208,"../../../../libs/spotify-live":217,"../../templates/sliderSetting.hbs":124}],30:[function(require,module,exports){

'use strict';

/**
 * Module dependencies
 */

var live = require('../../../libs/spotify-live');

/**
 * Live user account model
 *
 * @api public
 */

module.exports = live({
  upgradeUrl: null,
  typeName: null,
  premium: false,
  viewUrl: null,
  type: null
});

},{"../../../libs/spotify-live":217}],31:[function(require,module,exports){
'use strict';

/**
 * Module dependencies
 */

var live = require('../../../libs/spotify-live');

/**
 * Live application settings model wrapper
 *
 * @api public
 */

module.exports = live({
  settings: require('./settings'),
  account: require('./account'),
  user: require('./user')
});

},{"../../../libs/spotify-live":217,"./account":30,"./settings":32,"./user":33}],32:[function(require,module,exports){
'use strict';

/**
 * Module dependencies
 */

var live = require('../../../libs/spotify-live');

/**
 * Live setting model
 *
 * @api public
 */

module.exports = live({
  advancedSettings: false
});

},{"../../../libs/spotify-live":217}],33:[function(require,module,exports){
'use strict';

/**
 * Module dependencies
 */

var live = require('../../../libs/spotify-live');

/**
 * Live user model
 *
 * @api public
 */

module.exports = live({
  imageUrl: null,
  name: null,
  uri: null
});

},{"../../../libs/spotify-live":217}],34:[function(require,module,exports){
'use strict';

/**
 * Module dependencies
 */

var live = require('../../../libs/spotify-live');
var Preferences = require('../../../libs/spotify-preferences');
var Batch = require('spotify-batch');
var model = require('../models/account');
var oauth = require('../lib/oauth');

/**
 * Account upgrade URL
 */

var ACCOUNT_UPGRADE_URL = 'https://www.spotify.com/redirect/upgrade-product?' + 'utm_source=spotify&utm_medium=product-KM&utm_campaign=settings-upgrade';

/**
 * Account overview URL
 */

var ACCOUNT_OVERVIEW_URL = 'https://www.spotify.com/redirect/account-page';

/**
 * Live request timeout in ms
 */

var REQUEST_TIMEOUT = 100;

/**
 * `ps' preferences
 */
var prefs;

/**
 * Fetches account resource
 *
 * @api public
 * @param {Function} fn
 */

exports.fetch = function (fn) {
  var to = null;
  var tasks = new Batch().concurrency(1);

  if (!prefs) {
    prefs = new Preferences('ps');
  }

  // initializes request timeout
  function timeout(f) {
    clearTimeout(to);
    to = setTimeout(function () {
      (f || fn)(new Error('live() request timeout'));
    }, REQUEST_TIMEOUT);
  }

  // fetch preferences
  tasks.push(function (next) {
    timeout(next);
    prefs.all(function (err, res) {
      clearTimeout(to);
      if (err) {
        next(err);
        return;
      }
      var ps = res.ps;

      model.update({
        type: ps.type,
        typeName: ps.name,
        premium: ps.type === 'premium'
      });

      next();
    });
  });

  // fetch account url
  tasks.push(function (next) {
    oauth.get(ACCOUNT_OVERVIEW_URL, function (err, token) {
      if (err && console) {
        console.log(err);
      }

      var url = ACCOUNT_OVERVIEW_URL;
      if (token) {
        url += '?' + token;
      }

      model.update({ viewUrl: url });

      next();
    });
  });

  // fetch upgrade url
  tasks.push(function (next) {
    oauth.get(ACCOUNT_UPGRADE_URL, function (err, token) {
      if (err && console) {
        console.log(err);
      }

      model.update({
        upgradeUrl: ACCOUNT_UPGRADE_URL + '&' + token
      });

      next();
    });
  });

  // fetch session
  tasks.push(function (next) {
    timeout(next);
    live('spotify:client').get('session', function (err, session) {
      clearTimeout(to);

      if (err) {
        next(err);
        return;
      }

      next();

      // wait for session updates to update
      // account information incase of premium
      // upgrades in real time
      session.on('update', function (data) {
        if (data.productName) {
          model.update({
            typeName: data.productName
          });
        }

        if (data.product) {
          model.update({
            premium: data.product === 'premium',
            type: data.product
          });
        }
      });
    });
  });

  // run batch
  tasks.run(fn);
};

},{"../../../libs/spotify-live":217,"../../../libs/spotify-preferences":243,"../lib/oauth":25,"../models/account":30,"spotify-batch":351}],35:[function(require,module,exports){
'use strict';

var cosmos = require('spotify-cosmos-api');

var FACEBOOK_COSMOS_ENDPOINT = 'sp://facebook/v1';
var FACEBOOK_CONNECTION_ENDPOINT = FACEBOOK_COSMOS_ENDPOINT + '/connection';
var FACEBOOK_SCROBBLING_ENDPOINT = FACEBOOK_COSMOS_ENDPOINT + '/scrobbling';
var FACEBOOK_PERMISSIONS_ENDPOINT = FACEBOOK_COSMOS_ENDPOINT + '/permissions';

function parseReply(callback, error, reply) {
  if (error) {
    callback(error);
  } else {
    callback(null, reply.getJSONBody());
  }
}

function sendGetRequest(url, callback) {
  cosmos.resolver.get({ url: url }, parseReply.bind(null, callback));
}

function sendPostRequest(url, body, callback) {
  cosmos.resolver.post({ url: url, body: body }, parseReply.bind(null, callback));
}

function sendSubRequest(url, callback) {
  cosmos.resolver.subscribe({ url: url }, parseReply.bind(null, callback));
}

function getConnectionStatus(callback) {
  sendGetRequest(FACEBOOK_CONNECTION_ENDPOINT, callback);
}

function setConnectionStatus(enable, callback) {
  sendPostRequest(FACEBOOK_CONNECTION_ENDPOINT, { enable: enable }, callback);
}

function subscribeToConnectionStatus(callback) {
  sendSubRequest(FACEBOOK_CONNECTION_ENDPOINT, callback);
}

function getScrobbling(callback) {
  sendGetRequest(FACEBOOK_SCROBBLING_ENDPOINT, callback);
}

function setScrobbling(enable, callback) {
  sendPostRequest(FACEBOOK_SCROBBLING_ENDPOINT, { enable: enable }, callback);
}

function getPermissions(callback) {
  sendGetRequest(FACEBOOK_PERMISSIONS_ENDPOINT, callback);
}

function requestPermissions(permissions, callback) {
  sendPostRequest(FACEBOOK_PERMISSIONS_ENDPOINT, {
    permissions: permissions
  }, callback);
}

module.exports = {
  getConnectionStatus: getConnectionStatus,
  subscribeToConnectionStatus: subscribeToConnectionStatus,
  connect: setConnectionStatus.bind(null, true),
  disconnect: setConnectionStatus.bind(null, false),
  getScrobbling: getScrobbling,
  setScrobbling: setScrobbling,
  getPermissions: getPermissions,
  requestPermissions: requestPermissions
};

},{"spotify-cosmos-api":357}],36:[function(require,module,exports){
'use strict';

/**
 * Module dependencies
 */

var cosmos = require('spotify-cosmos-api');

/**
 * Last.fm cosmos resolver endpoint
 */

var LASTFM_COSMOS_ENDPOINT = 'sp://lastfm-oauth/v1';

/**
 * Retrieve status of currently authenticated
 * user for Lastfm
 *
 * @api public
 * @param {Function} fn
 */

exports.status = function (callback) {
  var fn = callback || function () {};
  var req = {
    url: LASTFM_COSMOS_ENDPOINT + '/status'
  };

  cosmos.resolver.get(req, function (err, res) {
    if (err) {
      fn(err);
      return;
    }

    fn(null, res.getJSONBody());
  });

  return this;
};

exports.subscribe = function (callback) {
  var fn = callback || function () {};
  var req = {
    url: LASTFM_COSMOS_ENDPOINT + '/status'
  };

  cosmos.resolver.subscribe(req, function (err, res) {
    if (err) {
      fn(err);
      return;
    }

    fn(null, res.getJSONBody());
  });

  return this;
};

/**
 * Authenticate user with lastfm
 *
 * @api public
 * @param {Object} opts
 * @param {Function} fn
 */

exports.auth = function (callback) {
  var fn = callback || function () {};
  var req = {
    url: LASTFM_COSMOS_ENDPOINT + '/token'
  };

  cosmos.resolver.get(req, function (err, res) {
    if (err) {
      fn(err);
      return;
    }

    if (fn) {
      fn(null, res.getJSONBody());
    }
  });
};

/**
 * Logout and disable scrobbling
 *
 * @api public
 * @param {Function} fn
 */

exports.logout = function (callback) {
  var fn = callback || function () {};
  var req = {
    url: LASTFM_COSMOS_ENDPOINT + '/logout'
  };

  cosmos.resolver.get(req, function (err, res) {
    if (err) {
      fn(err);
      return;
    }

    if (fn) {
      fn(null, res.getJSONBody());
    }
  });
};

},{"spotify-cosmos-api":357}],37:[function(require,module,exports){
'use strict';

/**
 * Module dependencies
 */

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var cosmos = require('spotify-cosmos-api');

/**
 * Last.fm cosmos resolver endpoint
 */

var LASTFM_COSMOS_ENDPOINT = 'sp://lastfm/v1';

/**
 * Retrieve status of currently authenticated
 * user for Lastfm
 *
 * @api public
 * @param {Function} fn
 */

exports.status = function (fn) {
  var req = {
    url: LASTFM_COSMOS_ENDPOINT + '/status'
  };

  cosmos.resolver.get(req, function (err, res) {
    if (err) {
      fn(err);
      return;
    }

    fn(null, res.getJSONBody());
  });

  return this;
};

/**
 * Authenticate user with lastfm
 *
 * @api public
 * @param {Object} opts
 * @param {Function} fn
 */

exports.auth = function (opts, fn) {
  var req = null;

  if ((typeof opts === 'undefined' ? 'undefined' : _typeof(opts)) !== 'object') {
    throw new TypeError('lastfm#auth(): expecting object');
  } else if (typeof opts.username !== 'string') {
    throw new TypeError('lastfm#auth(): expecting .username to be a string');
  } else if (typeof opts.password !== 'string') {
    throw new TypeError('lastfm#auth(): expecting .password to be a string');
  }

  req = new cosmos.Request('PUT', LASTFM_COSMOS_ENDPOINT + '/credentials', null, opts);

  cosmos.resolver.resolve(req, function (err, res) {
    if (err) {
      fn(err);
      return;
    }

    fn(null, res.getJSONBody());
  });

  return this;
};

/**
 * Enable/disable scrobbling
 *
 * @api public
 * @param {Boolean} state
 * @param {Function} fn
 */

exports.scrobbling = function (state, fn) {
  var req = new cosmos.Request('POST', LASTFM_COSMOS_ENDPOINT + '/scrobbling', null, { enabled: state });

  cosmos.resolve.post(req, function (err, res) {
    if (err) {
      fn(err);
      return;
    }

    fn(null, res.getJSONBody());
  });
};

/**
 * Logout and disable scrobbling
 *
 * @api public
 * @param {Function} fn
 */

exports.logout = function (fn) {
  return exports.auth({
    username: '',
    password: '',
    enable_scrobbling: false
  }, fn);
};

},{"spotify-cosmos-api":357}],38:[function(require,module,exports){
'use strict';

/**
 * Module dependencies
 */

var cosmos = require('spotify-cosmos-api');

/**
 * Local files cosmos endpoint
 */

var LOCAL_FILES_COSMOS_ENDPOINT = 'sp://local-files/v1';

/**
 * Browse directory cosmos endpoint
 */

var BROWSE_DIRECTORY_COSMOS_ENDPOINT = 'sp://desktop/v1/browse_for_folder';

/**
 * Retrieves all sources for local files
 *
 * @api publc
 * @param {Function} fn
 */

exports.sources = function (fn) {
  cosmos.resolver.get(LOCAL_FILES_COSMOS_ENDPOINT + '/sources', function (err, res) {
    if (err) {
      fn(err);
      return;
    }
    fn(null, res.getJSONBody());
  });
};

/**
 * Browse user directory for source
 *
 * @api public
 * @param {Function} fn
 */

exports.browse = function (fn) {
  cosmos.resolver.post(BROWSE_DIRECTORY_COSMOS_ENDPOINT, function (err, res) {
    if (err) {
      fn(err);
      return;
    }
    var data = res.getJSONBody();
    if (data === null) {
      fn(new Error('Error browsing directory'));
    } else {
      fn(null, data);
    }
  });
};

/**
 * Updates a source
 *
 * @api public
 * @param {Object} source
 * @param {Function} fn
 */

exports.update = function (source, fn) {
  var req = new cosmos.Request('PUT', LOCAL_FILES_COSMOS_ENDPOINT + '/sources', {}, source.get('id'));

  cosmos.resolver.resolve(req, function (err, res) {
    if (err) {
      fn(err);
      return;
    }
    var data = res.getJSONBody();
    source.update({ enabled: true });
    if (data) {
      fn(null, data);
    } else {
      fn(new Error('Error parsing file source data'));
    }
  });
};

/**
 * Deletes a source
 *
 * @api public
 * @param {Object} source
 * @param {Function} fn
 */

exports.delete = function (source, fn) {
  var req = new cosmos.Request('DELETE', LOCAL_FILES_COSMOS_ENDPOINT + '/sources', {}, source.get('id'));

  cosmos.resolver.resolve(req, function (err, res) {
    if (err) {
      fn(err);
      return;
    }
    var data = res.getJSONBody();
    source.update({ enabled: false });
    if (data) {
      fn(null, data);
    } else {
      fn(new Error('Error parsing file source data'));
    }
  });
};

},{"spotify-cosmos-api":357}],39:[function(require,module,exports){
'use strict';

/**
 * Module dependencies
 */

var live = require('../../../libs/spotify-live');
var model = require('../models/user');

/**
 * Live request timeout in ms
 */

var REQUEST_TIMEOUT = 100;

/**
 * Fetches user resource
 *
 * @api public
 * @param {Function} callback
 */

exports.fetch = function (callback) {
  var lastTimeout = null;

  // initializes request timeout
  function timeout(optIgnoreError) {
    if (lastTimeout) {
      clearTimeout(lastTimeout);
    }

    lastTimeout = setTimeout(function () {
      var error = new Error('live() request timeout');
      var argument = null;
      if (optIgnoreError) {
        console.error(error);
      } else {
        argument = error;
      }

      callback(argument);
    }, REQUEST_TIMEOUT);
  }

  function updateModel(data) {
    if (data.image) {
      model.update({
        imageUrl: data.image
      });
    }

    if (data.name) {
      model.update({
        name: data.name
      });
    }
  }

  function getUserData(user) {
    live(user.uri).query('image, name', function (err, res) {
      // destroy timeout
      clearTimeout(lastTimeout);

      if (err) {
        callback(err);
        return;
      }

      updateModel(res);
      callback(null);
    });
  }

  timeout();

  live('spotify:client').query('currentUser(username, uri)', function (err, res) {
    clearTimeout(lastTimeout);

    if (err) {
      callback(err);
      return;
    }

    var user = res.currentUser;

    // update user model
    model.update({
      name: user.username,
      uri: user.uri
    });

    /**
     * Try to fetch the profileImage uri and the real name.
     * This often won't complete when offline, in that case the non-fatal
     * timeout will resolve it.
     * If it just takes long to get the data, the model will still
     * be updated later and we watch for the change elsewhere.
     */
    timeout(true);

    getUserData(user);

    /**
     * Watch for profile image uri changes. This will
     * only happen when loading the uri was slower than
     * a timeout, for example because of being offline.
     */
    live(user.uri).on('update', updateModel);
  });

  return this;
};

},{"../../../libs/spotify-live":217,"../models/user":33}],40:[function(require,module,exports){
'use strict';

/**
 * Module dependencies
 */

var dom = require('domify');

/**
 * Accessibility setting template
 */

var template = require('./template.hbs');

/**
 * Accessibility setting model
 */

exports.model = require('./model');

/**
 * Initializes accessibility setting
 *
 * @api public
 * @param {Function} done
 */

exports.init = function (done) {
  var settings = document.querySelector('#basic-settings');
  var model = exports.model;
  var view = dom(template(model.serialize()));
  settings.appendChild(view);
  done();
};

/**
 * Syncs setting from bridge
 *
 * @api public
 * @param {Function} done
 */

exports.sync = function (done) {
  done();
};

},{"./model":41,"./template.hbs":42,"domify":270}],41:[function(require,module,exports){

'use strict';

/**
 * Module dependencies
 */

var live = require('../../../../libs/spotify-live');

/**
 * Accessibility live model
 */

module.exports = live({
  enabled: false,
  colors: false,
  uri: 'settings:accessibility'
});

},{"../../../../libs/spotify-live":217}],42:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {

  var buffer = "", stack1, helper, options;
  buffer += "\n<section id=\"accessibility\">\n  <div class=\"section-divider\">\n    <h2>"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "accessibility", options) : helperMissing.call(depth0, "loc", "accessibility", options)))
    + "</h2>\n  </div>\n\n  ";
  stack1 = (helper = helpers.sliderSetting || (depth0 && depth0.sliderSetting),options={hash:{},inverse:self.noop,fn:self.program(2, program2, data),data:data},helper ? helper.call(depth0, "settings:accessibility", "colors", options) : helperMissing.call(depth0, "sliderSetting", "settings:accessibility", "colors", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n</section>\n";
  return buffer;
  }
function program2(depth0,data) {

  var buffer = "", stack1, helper, options;
  buffer += "\n    ";
  stack1 = (helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "accessibilityColors", options) : helperMissing.call(depth0, "loc", "accessibilityColors", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  ";
  return buffer;
  }

  stack1 = helpers['if'].call(depth0, (depth0 && depth0.enabled), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n";
  return buffer;
  });

},{"hbsfy/runtime":303}],43:[function(require,module,exports){
'use strict';

var Preferences = require('../../../../libs/spotify-preferences');
var cosmos = require('spotify-cosmos-api');
var dom = require('domify');
var $ = require('../../../../libs/spotify-elements');

var prefs;

var template = require('./template.hbs');
var browseFileSystem = require('../../resources/local-files').browse;

exports.model = require('./model');

var USER_MESSAGE_ENDPOINT = 'sp://messages/v1/container/user-message';

exports.init = function (done) {
  if (!prefs) {
    prefs = new Preferences('*');
  }

  var model = exports.model;
  var settings = document.querySelector('#advanced-settings');
  var view = dom(template(model.serialize()));

  // render
  settings.appendChild(view);

  $('#change-cache-location').on('click', function () {
    browseFileSystem(function (error, dir) {
      if (error || !dir.path) {
        // user clicks "Cancel"
        return;
      }

      model.publish({ location: dir.path });
    });
  });

  model.on('publish', function (data) {
    var hasData = 'location' in data;
    if (!hasData) {
      return;
    }

    var prevLocation = model.get('location');
    var location = data.location;

    model.update({ location: location });
    prefs.set('storage.location', location, function (err) {
      if (err) {
        console.error(err.stack || err);

        // Revert
        model.update({ location: prevLocation });
      }
    });

    if (prevLocation !== location) {
      cosmos.resolver.post({
        url: USER_MESSAGE_ENDPOINT,
        body: {
          id: 'cache-changed'
        }
      });
    }
  });

  model.on('update', function (data) {
    var hasData = 'location' in data;
    if (!hasData) {
      return;
    }
    var element = $('#cache-location');
    if (element) {
      element.text(data.location);
    }
  });

  done();
};

/**
 * Called when native layer pushs sync
 * to application layer
 *
 * @api public
 * @param {Function} done
 */

exports.sync = function (done) {
  if (!prefs) {
    prefs = new Preferences('*');
  }

  prefs.all(function (err, res) {
    if (err) {
      done(err);
      return;
    }

    exports.model.update({
      location: res['storage.location']
    });

    done();
  });
};

},{"../../../../libs/spotify-elements":149,"../../../../libs/spotify-preferences":243,"../../resources/local-files":38,"./model":44,"./template.hbs":45,"domify":270,"spotify-cosmos-api":357}],44:[function(require,module,exports){

'use strict';

/**
 * Module dependencies
 */

var live = require('../../../../libs/spotify-live');

/**
 * Music quality live model
 *
 * @api public
 */

module.exports = live({
  location: null,
  uri: 'settings:cache'
});

},{"../../../../libs/spotify-live":217}],45:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, options, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, functionType="function";


  buffer += "<section id=\"cache\">\n  <div class=\"section-divider\">\n    <h2>"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "cache", options) : helperMissing.call(depth0, "loc", "cache", options)))
    + "</h2>\n  </div>\n\n  <div class=\"setting-row\">\n    <div class=\"col description\">\n      "
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "fileSystemLocationLabel", options) : helperMissing.call(depth0, "loc", "fileSystemLocationLabel", options)))
    + " <span id=\"cache-location\">";
  if (helper = helpers.location) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.location); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</span>\n    </div>\n\n    <div class=\"col action\">\n      <button class=\"button button-with-stroke\" type=\"button\" id=\"change-cache-location\">\n        <span>"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "changeLocation", options) : helperMissing.call(depth0, "loc", "changeLocation", options)))
    + "</span>\n      </button>\n    </div>\n  </div>\n\n</section>\n";
  return buffer;
  });

},{"hbsfy/runtime":303}],46:[function(require,module,exports){
'use strict';

/**
 * Module dependencies
 */

var Preferences = require('../../../../libs/spotify-preferences');
var dom = require('domify');
var $ = require('../../../../libs/spotify-elements');
var cosmos = require('spotify-cosmos-api');
var template = require('./template.hbs');
var USER_MESSAGE_ENDPOINT = 'sp://messages/v1/container/user-message';
var prefs;

exports.model = require('./model');

/**
 * Initializes setting
 *
 * @api public
 * @param {Function} done
 */

exports.init = function (done) {
  if (!prefs) {
    prefs = new Preferences('*');
  }

  var settings = $('#advanced-settings');
  var model = exports.model;
  var view = dom(template(model.serialize()));

  // render
  settings.appendChild(view);

  model.on('publish', function (data) {
    if ('on' in data) {
      var previousValue = model.get('on');
      model.update({ on: data.on });
      prefs.set('ui.hardware_acceleration', data.on, function (err) {
        if (err) {
          // revert change
          model.update({ on: previousValue });
          console.error(err.stack || err);
        } else {
          cosmos.resolver.post({
            url: USER_MESSAGE_ENDPOINT,
            body: {
              id: 'hardware-acceleration-changed'
            }
          });
        }
      });
    }
  });

  done();
};

/**
 * Updates settings from bridge
 *
 * @api public
 * @param {Function} done
 */

exports.sync = function (done) {
  var model = exports.model;
  if (!prefs) {
    prefs = new Preferences('*');
  }

  prefs.all(function (err, res) {
    if (err) {
      done(err);
      return;
    }
    model.update({
      // Windows only feature
      enabled: navigator && /^win/i.test(navigator.platform),
      on: res['ui.hardware_acceleration']
    });
    done();
  });
};

},{"../../../../libs/spotify-elements":149,"../../../../libs/spotify-preferences":243,"./model":47,"./template.hbs":48,"domify":270,"spotify-cosmos-api":357}],47:[function(require,module,exports){

'use strict';

/**
 * Module dependencies
 */

var live = require('../../../../libs/spotify-live');

/**
 * Music announcements live model
 *
 * @api public
 */

module.exports = live({
  enabled: false,
  on: true,
  uri: 'settings:hardware-acceleration'
});

},{"../../../../libs/spotify-live":217}],48:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {

  var buffer = "", stack1, helper, options;
  buffer += "\n<section id=\"compatibility\">\n  <div class=\"section-divider\">\n    <h2>"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "compatibility", options) : helperMissing.call(depth0, "loc", "compatibility", options)))
    + "</h2>\n  </div>\n\n  ";
  stack1 = (helper = helpers.sliderSetting || (depth0 && depth0.sliderSetting),options={hash:{},inverse:self.noop,fn:self.program(2, program2, data),data:data},helper ? helper.call(depth0, "settings:hardware-acceleration", "on", options) : helperMissing.call(depth0, "sliderSetting", "settings:hardware-acceleration", "on", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n</section>\n";
  return buffer;
  }
function program2(depth0,data) {

  var buffer = "", stack1, helper, options;
  buffer += "\n    ";
  stack1 = (helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "enableHardwareAcceleration", options) : helperMissing.call(depth0, "loc", "enableHardwareAcceleration", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  ";
  return buffer;
  }

  stack1 = helpers['if'].call(depth0, (depth0 && depth0.enabled), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n";
  return buffer;
  });

},{"hbsfy/runtime":303}],49:[function(require,module,exports){
'use strict';

/**
 * Module dependencies
 */

var cosmos = require('spotify-cosmos-api');
var live = require('../../../../libs/spotify-live');
var dom = require('domify');

exports.model = live({
  enabled: true
});

/**
 * Devices setting template
 */
var template = require('./template.hbs');

/*
 * Initializes devices settings
 *
 * @api public
 * @param {Function} done
 */
exports.init = function (done) {
  var model = exports.model;
  var settings = document.querySelector('#basic-settings');
  var view = dom(template(model.serialize()));

  // render
  settings.appendChild(view);

  settings.querySelector('#devices-button').onclick = function () {
    sendOpenMessage();
  };

  done();
};

function sendOpenMessage() {
  var endpoint = 'sp://messages/v1/container/connect/popup';
  cosmos.resolver.post({
    url: endpoint,
    body: {
      open: true,
      source: 'settings'
    }
  });
}

},{"../../../../libs/spotify-live":217,"./template.hbs":50,"domify":270,"spotify-cosmos-api":357}],50:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {

  var buffer = "", helper, options;
  buffer += "\n<div id=\"devices\">\n  <div class=\"section-divider\">\n    <h2>"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "devices", options) : helperMissing.call(depth0, "loc", "devices", options)))
    + "</h2>\n  </div>\n\n  <div class=\"setting-row\">\n    <div id=\"devices-description\" class=\"col description\">\n      "
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "connectToADevice", options) : helperMissing.call(depth0, "loc", "connectToADevice", options)))
    + "\n    </div>\n    <div class=\"col action action-button\">\n     <button type=\"button\" class=\"enable button button-with-stroke button-devices\" id=\"devices-button\">\n        "
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "openDevicesMenu", options) : helperMissing.call(depth0, "loc", "openDevicesMenu", options)))
    + "\n      </button>\n    </div>\n  </div>\n</div>\n";
  return buffer;
  }

  stack1 = helpers['if'].call(depth0, (depth0 && depth0.enabled), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n";
  return buffer;
  });

},{"hbsfy/runtime":303}],51:[function(require,module,exports){
'use strict';

var Preferences = require('../../../../../libs/spotify-preferences');
var dom = require('domify');
var $ = require('../../../../../libs/spotify-elements');
var template = require('./template.hbs');
var prefs;
exports.model = require('./model');

/**
 * Initializes setting
 *
 * @api public
 * @param {Function} done
 */

exports.init = function (done) {
  if (!prefs) {
    prefs = new Preferences('*');
  }
  var settings = $('#display');
  var model = exports.model;
  var view = dom(template(model.serialize()));

  // render
  settings.appendChild(view);

  model.on('publish', function (data) {
    if ('show' in data) {
      var show = data.show;

      // set `show_unplayable_tracks' setting if `show' is set
      model.update({ show: show });
      prefs.set('ui.show_friend_feed', show, function (err) {
        if (err) {
          console.error(err.stack || err);

          // Revert
          model.update({ show: !show });
        }
      });
    }
  });

  done();
};

/**
 * Updates settings from bridge
 *
 * @api public
 * @param {Function} done
 */

exports.sync = function (done) {
  var model = exports.model;

  if (!prefs) {
    prefs = new Preferences('*');
  }

  prefs.all(function (err, res) {
    if (err) {
      done(err);
      return;
    }

    model.update({
      show: res['ui.show_friend_feed']
    });

    done();
  });
};

},{"../../../../../libs/spotify-elements":149,"../../../../../libs/spotify-preferences":243,"./model":52,"./template.hbs":53,"domify":270}],52:[function(require,module,exports){

'use strict';

/**
 * Module dependencies
 */

var live = require('../../../../../libs/spotify-live');

/**
 * Friend feed live model
 *
 * @api public
 */

module.exports = live({
  enabled: true,
  show: true,
  uri: 'settings:friend-feed'
});

},{"../../../../../libs/spotify-live":217}],53:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, options, helperMissing=helpers.helperMissing, self=this;

function program1(depth0,data) {

  var buffer = "", stack1, helper, options;
  buffer += "\n    ";
  stack1 = (helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "friendFeed", options) : helperMissing.call(depth0, "loc", "friendFeed", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  ";
  return buffer;
  }

  buffer += "<div id=\"friend-feed\">\n  ";
  stack1 = (helper = helpers.sliderSetting || (depth0 && depth0.sliderSetting),options={hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data},helper ? helper.call(depth0, "settings:friend-feed", "show", options) : helperMissing.call(depth0, "sliderSetting", "settings:friend-feed", "show", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n</div>\n";
  return buffer;
  });

},{"hbsfy/runtime":303}],54:[function(require,module,exports){
'use strict';

var Batch = require('spotify-batch');
var dom = require('domify');

var sections = [require('./unavailable-tracks'), require('./music-announcements'), require('./friend-feed'), require('./notifications')];

var template = require('./template.hbs');

exports.model = require('./model');

/**
 * Init
 *
 * @api public
 * @param {Function} done
 */

exports.init = function (done) {
  var settings = document.querySelector('#basic-settings');
  var model = exports.model;
  var batch = new Batch().concurrency(1);
  var view = dom(template(model.serialize()));

  // render
  settings.appendChild(view);

  sections.forEach(function (section) {
    if (typeof section.init === 'function') {
      batch.push(function (next) {
        section.init(next);
      });
    }
  });

  batch.run(done);
};

/**
 * Called when native layer pushs sync
 * to application layer
 *
 * @api public
 * @param {Function} done
 */

exports.sync = function (done) {
  var batch = new Batch().concurrency(1);
  sections.forEach(function (section) {
    if (typeof section.sync === 'function') {
      batch.push(function (next) {
        section.sync(next);
      });
    }
  });

  batch.run(done);
};

},{"./friend-feed":51,"./model":55,"./music-announcements":56,"./notifications":59,"./template.hbs":62,"./unavailable-tracks":63,"domify":270,"spotify-batch":351}],55:[function(require,module,exports){

'use strict';

/**
 * Module dependencies
 */

var live = require('../../../../libs/spotify-live');

/**
 * Display settings model
 *
 * @api public
 */

module.exports = live({
  enabled: true,
  uri: 'settings:display',

  musicAnnouncements: require('./music-announcements/model'),
  unavailableTracks: require('./unavailable-tracks/model')

});

},{"../../../../libs/spotify-live":217,"./music-announcements/model":57,"./unavailable-tracks/model":64}],56:[function(require,module,exports){
'use strict';

/**
 * Module dependencies
 */

var account = require('../../../models/account');
var Preferences = require('../../../../../libs/spotify-preferences');
var dom = require('domify');
var live = require('../../../../../libs/spotify-live');
var $ = require('../../../../../libs/spotify-elements');
var template = require('./template.hbs');
var prefs;

exports.model = require('./model');

/**
 * Toggle the visibility of the section block according to the model
 */
function toggleDisplay(enabled) {
  var section = $('#music-announcements');
  if (enabled) {
    section.removeClass('hidden');
  } else {
    section.addClass('hidden');
  }
}

/**
 * Initializes setting
 *
 * @api public
 * @param {Function} done
 */

exports.init = function (done) {
  if (!prefs) {
    prefs = new Preferences('*');
  }

  var settings = $('#display');
  var model = exports.model;
  var view = dom(template(model.serialize()));

  // render
  settings.appendChild(view);
  toggleDisplay(model.serialize().enabled);

  live('spotify:client').get('session', function (err, session) {
    if (err) {
      console.error(err);
    }
    model.update({ enabled: session.get('product') === 'premium' });

    session.on('update', function (data) {
      if ('product' in data) {
        model.update({ enabled: data.product === 'premium' });
      }
    });
  });

  model.on('publish', function (data) {
    var enabled = model.get('enabled');
    var show = data.show;

    // if the feature is not enabled then always
    // show the announcement
    if (!enabled) {
      show = true;
    }

    // set `hide_hpto' setting if `show' is set
    if (typeof show !== 'undefined') {
      model.update({ show: show });
      prefs.set('ui.hide_hpto', !show, function (err) {
        if (err) {
          console.error(err.stack || err);
        }
      });
    }
  });

  model.on('update', function (data) {
    if ('enabled' in data) {
      toggleDisplay(data.enabled);
    }
  });

  done();
};

/**
 * Updates settings from bridge
 *
 * @api public
 * @param {Function} done
 */

exports.sync = function (done) {
  var model = exports.model;

  if (!prefs) {
    prefs = new Preferences('*');
  }

  model.update({
    enabled: account.get('premium')
  });

  prefs.all(function (err, res) {
    if (err) {
      done(err);
      return;
    }

    model.update({
      show: !res['ui.hide_hpto']
    });

    done();
  });
};

},{"../../../../../libs/spotify-elements":149,"../../../../../libs/spotify-live":217,"../../../../../libs/spotify-preferences":243,"../../../models/account":30,"./model":57,"./template.hbs":58,"domify":270}],57:[function(require,module,exports){

'use strict';

/**
 * Module dependencies
 */

var live = require('../../../../../libs/spotify-live');

/**
 * Music announcements live model
 *
 * @api public
 */

module.exports = live({
  enabled: false,
  show: true,
  uri: 'settings:music-announcements'
});

},{"../../../../../libs/spotify-live":217}],58:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, options, helperMissing=helpers.helperMissing, self=this;

function program1(depth0,data) {

  var buffer = "", stack1, helper, options;
  buffer += "\n    ";
  stack1 = (helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "showMusicAnnouncements", options) : helperMissing.call(depth0, "loc", "showMusicAnnouncements", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  ";
  return buffer;
  }

  buffer += "<div id=\"music-announcements\">\n  ";
  stack1 = (helper = helpers.sliderSetting || (depth0 && depth0.sliderSetting),options={hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data},helper ? helper.call(depth0, "settings:music-announcements", "show", options) : helperMissing.call(depth0, "sliderSetting", "settings:music-announcements", "show", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n</div>\n";
  return buffer;
  });

},{"hbsfy/runtime":303}],59:[function(require,module,exports){
'use strict';

var Preferences = require('../../../../../libs/spotify-preferences');
var dom = require('domify');
var $ = require('../../../../../libs/spotify-elements');
var template = require('./template.hbs');
var prefs;

exports.model = require('./model');

/**
 * Initializes setting
 *
 * @api public
 * @param {Function} done
 */

exports.init = function (done) {
  if (!prefs) {
    prefs = new Preferences('*');
  }
  var settings = $('#display');
  var model = exports.model;
  var enabled = model.get('enabled');
  var view = dom(template(model.serialize()));

  // If this feature doesn't exist on the target platform, then
  // we don't want to show it.
  if (!enabled) {
    done();
    return;
  }

  // render
  settings.appendChild(view);

  model.on('publish', function (data) {
    if ('show' in data) {
      var show = data.show;

      model.update({ show: show });
      prefs.set('ui.track_notifications_enabled', show, function (err) {
        if (err) {
          console.error(err.stack || err);

          // Revert
          model.update({ show: !show });
        }
      });
    }
  });

  done();
};

/**
 * Updates settings from bridge
 *
 * @api public
 * @param {Function} done
 */

exports.sync = function (done) {
  var model = exports.model;
  if (!prefs) {
    prefs = new Preferences('*');
  }

  prefs.all(function (err, res) {
    if (err) {
      done(err);
      return;
    }

    model.update({
      show: res['ui.track_notifications_enabled']
    });

    done();
  });
};

},{"../../../../../libs/spotify-elements":149,"../../../../../libs/spotify-preferences":243,"./model":60,"./template.hbs":61,"domify":270}],60:[function(require,module,exports){

'use strict';

/**
 * Module dependencies
 */

var live = require('../../../../../libs/spotify-live');

/**
 * Track notifications live model
 *
 * @api public
 */

var containerFeatures = live('spotify:client').get('containerFeatures');
var notificationsEnabled = containerFeatures && containerFeatures.get('showTrackNotifications');

module.exports = live({
  enabled: !!notificationsEnabled,
  show: true,
  uri: 'settings:show-track-notifications'
});

},{"../../../../../libs/spotify-live":217}],61:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, options, helperMissing=helpers.helperMissing, self=this;

function program1(depth0,data) {

  var buffer = "", stack1, helper, options;
  buffer += "\n    ";
  stack1 = (helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "showTrackNotifications", options) : helperMissing.call(depth0, "loc", "showTrackNotifications", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  ";
  return buffer;
  }

  buffer += "<div id=\"show-track-notifications\">\n  ";
  stack1 = (helper = helpers.sliderSetting || (depth0 && depth0.sliderSetting),options={hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data},helper ? helper.call(depth0, "settings:show-track-notifications", "show", options) : helperMissing.call(depth0, "sliderSetting", "settings:show-track-notifications", "show", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n</div>\n";
  return buffer;
  });

},{"hbsfy/runtime":303}],62:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {

  var buffer = "", helper, options;
  buffer += "\n<section id=\"display\">\n  <div class=\"section-divider\">\n    <h2>"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "display", options) : helperMissing.call(depth0, "loc", "display", options)))
    + "</h2>\n  </div>\n</section>\n";
  return buffer;
  }

  stack1 = helpers['if'].call(depth0, (depth0 && depth0.enabled), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n";
  return buffer;
  });

},{"hbsfy/runtime":303}],63:[function(require,module,exports){
'use strict';

var Preferences = require('../../../../../libs/spotify-preferences');
var dom = require('domify');
var $ = require('../../../../../libs/spotify-elements');

var template = require('./template.hbs');
var prefs;

exports.model = require('./model');

/**
 * Initializes setting
 *
 * @api public
 * @param {Function} done
 */

exports.init = function (done) {
  if (!prefs) {
    prefs = new Preferences('*');
  }

  var settings = $('#display');
  var model = exports.model;
  var view = dom(template(model.serialize()));

  // render
  settings.appendChild(view);

  model.on('publish', function (data) {
    if ('show' in data) {
      var show = data.show;

      // set `show_unplayable_tracks' setting if `show' is set
      model.update({ show: show });

      prefs.set('ui.show_unplayable_tracks', show, function (err) {
        if (err) {
          console.error(err.stack || err);

          // Revert
          model.update({ show: !show });
        }
      });
    }
  });

  done();
};

/**
 * Updates settings from bridge
 *
 * @api public
 * @param {Function} done
 */

exports.sync = function (done) {
  var model = exports.model;
  if (!prefs) {
    prefs = new Preferences('*');
  }

  prefs.all(function (err, res) {
    if (err) {
      done(err);
      return;
    }

    model.update({
      show: res['ui.show_unplayable_tracks']
    });

    done();
  });
};

},{"../../../../../libs/spotify-elements":149,"../../../../../libs/spotify-preferences":243,"./model":64,"./template.hbs":65,"domify":270}],64:[function(require,module,exports){

'use strict';

/**
 * Module dependencies
 */

var live = require('../../../../../libs/spotify-live');

/**
 * Unavailable tracks live model
 *
 * @api public
 */

module.exports = live({
  enabled: true,
  show: false,
  uri: 'settings:show-unavailable-tracks'
});

},{"../../../../../libs/spotify-live":217}],65:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, options, helperMissing=helpers.helperMissing, self=this;

function program1(depth0,data) {

  var buffer = "", stack1, helper, options;
  buffer += "\n    ";
  stack1 = (helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "showUnavailableTracks", options) : helperMissing.call(depth0, "loc", "showUnavailableTracks", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  ";
  return buffer;
  }

  buffer += "<div id=\"show-unavailable-tracks\">\n  ";
  stack1 = (helper = helpers.sliderSetting || (depth0 && depth0.sliderSetting),options={hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data},helper ? helper.call(depth0, "settings:show-unavailable-tracks", "show", options) : helperMissing.call(depth0, "sliderSetting", "settings:show-unavailable-tracks", "show", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n</div>\n";
  return buffer;
  });

},{"hbsfy/runtime":303}],66:[function(require,module,exports){
'use strict';

var dom = require('domify');

var template = require('./template.hbs');
var model = require('./model');

/**
 * Initializes features settings
 *
 * @api public
 * @param {Function} done
 */
exports.init = function (done) {
  var enabled = model.get('enabled');

  if (enabled) {
    var settings = document.querySelector('#employee-features');
    var view = dom(template(model.serialize()));
    settings.appendChild(view);
  }

  done();
};

exports.model = model;

},{"./model":67,"./template.hbs":68,"domify":270}],67:[function(require,module,exports){
'use strict';

var live = require('../../../../../libs/spotify-live');
var cdnDeploy = require('../../../../../cdn-deploy.json');

module.exports = live({
  enabled: true,
  apps: cdnDeploy.apps || {}
});

},{"../../../../../cdn-deploy.json":130,"../../../../../libs/spotify-live":217}],68:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, functionType="function", escapeExpression=this.escapeExpression, helperMissing=helpers.helperMissing, self=this;

function program1(depth0,data) {

  var buffer = "", stack1, helper, options;
  buffer += "\n<section id=\"apps\">\n  <div class=\"section-divider section-divider-small\">\n    <h3>"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "appLinks", options) : helperMissing.call(depth0, "loc", "appLinks", options)))
    + "</h3>\n  </div>\n\n  ";
  stack1 = helpers.each.call(depth0, (depth0 && depth0.apps), {hash:{},inverse:self.noop,fn:self.program(2, program2, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n</section>\n";
  return buffer;
  }
function program2(depth0,data) {

  var buffer = "", stack1;
  buffer += "\n    <a href=\"spotify:app:"
    + escapeExpression(((stack1 = (data == null || data === false ? data : data.key)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\" class=\"button button-gray\">\n      "
    + escapeExpression(((stack1 = (data == null || data === false ? data : data.key)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\n    </a>\n  ";
  return buffer;
  }

  stack1 = helpers['if'].call(depth0, (depth0 && depth0.enabled), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n";
  return buffer;
  });

},{"hbsfy/runtime":303}],69:[function(require,module,exports){
'use strict';

var Batch = require('spotify-batch');
var dom = require('domify');

var template = require('./template.hbs');
var model = require('./model');

var sections = [require('./apps'), require('./search-proxy')];

/**
 * Initializes employee features settings
 *
 * @api public
 * @param {Function} done
 */
exports.init = function (done) {
  var settings = document.querySelector('#advanced-settings');
  var enabled = model.get('enabled');
  var batch = new Batch().concurrency(1);

  if (enabled) {
    // render
    var view = dom(template(model.serialize()));
    settings.appendChild(view);

    sections.forEach(function (section) {
      if (typeof section.init === 'function') {
        batch.push(function (next) {
          section.init(next);
        });
      }
    });
  }

  batch.run(done);
};

/**
 * Called when native layer pushs sync
 * to application layer
 *
 * @api public
 * @param {Function} done
 */
exports.sync = function (done) {
  var batch = new Batch().concurrency(1);
  sections.forEach(function (section) {
    if (typeof section.sync === 'function') {
      batch.push(function (next) {
        section.sync(next);
      });
    }
  });

  batch.run(done);
};

exports.model = model;

},{"./apps":66,"./model":70,"./search-proxy":71,"./template.hbs":74,"domify":270,"spotify-batch":351}],70:[function(require,module,exports){
(function (global){
'use strict';

var live = require('../../../../libs/spotify-live');

var isEmployee = employeeFeaturesEnabled;

/**
 * Social live model
 *
 * @api public
 */
module.exports = live({
  enabled: isEmployee,
  uri: 'settings:employee-features'
});

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../../../libs/spotify-live":217}],71:[function(require,module,exports){
'use strict';

var dom = require('domify');
var cosmos = require('spotify-cosmos-api');
var live = require('../../../../../libs/spotify-live');
var proxyConfiguration = require('../../../../../libs/bfs-km-searchview').proxyConfiguration(live);
var template = require('./template.hbs');
var model = require('./model');

var USER_MESSAGE_ENDPOINT = 'sp://messages/v1/container/user-message';

exports.model = model;

/**
 * Initializes searchview proxy settings
 *
 * @api public
 * @param {Function} done
 */
exports.init = function (done) {
  var settings = document.querySelector('#employee-features');
  var modelData = model.serialize();
  var view = dom(template(modelData));

  var inputs = Array.prototype.slice.call(view.querySelectorAll('input'));
  var submitButton = view.querySelector('button');

  if (model.get('enabled')) {
    settings.appendChild(view);
  }

  Promise.all([proxyConfiguration.getDefaultConfiguration(), proxyConfiguration.getUserData()]).then(function (data) {
    return Object.assign({}, data[0], data[1]);
  }).then(function (proxy) {
    // Define inputs' placeholder based on default configuration or user data.
    ['host', 'port', 'catalogue', 'username', 'country'].forEach(function (key) {
      view.querySelector('input[name="' + key + '"]').placeholder = proxy[key];
    });
  });

  model.on('update', function (data) {
    updateInputsState(inputs, data.proxyEnabled);
    updateInputsValue(inputs, data);
  });

  model.on('publish', function (data) {
    model.update(data);
    updateInputsState(inputs, data.proxyEnabled);
    updatePreferences(data, showRestartBlueBarMessage);
  });

  submitButton.addEventListener('click', function (e) {
    e.preventDefault();

    var values = getInputsValue(inputs);
    model.update(values);
    updatePreferences(values, showRestartBlueBarMessage);
  });

  done();
};

/**
 * Called when native layer pushs sync
 * to application layer
 *
 * @api public
 * @param {Function} done
 */
exports.sync = function (done) {
  proxyConfiguration.getAllPreferences().then(function (preferences) {
    if (preferences.enabled !== undefined) {
      preferences.proxyEnabled = preferences.enabled;
      delete preferences.enabled;
    }

    model.update(preferences);
    done();
  }).catch(function (err) {
    console.error(err);
    done();
  });
};

function getInputsValue(inputs) {
  return inputs.reduce(function (values, input) {
    var value = input.type === 'checkbox' ? input.checked : input.value;

    values[input.name] = value;
    return values;
  }, {});
}

function updatePreferences(preferences, callback) {
  // The key `proxyEnabled` is named `enabled` in the client preferences.
  if (preferences.proxyEnabled !== undefined) {
    preferences.enabled = preferences.proxyEnabled;
    delete preferences.proxyEnabled;
  }

  proxyConfiguration.updatePreferences(preferences).then(callback);
}

function updateInputsState(inputs, enabled) {
  inputs.forEach(function (input) {
    input.disabled = !enabled;
  });
}

function updateInputsValue(inputs, values) {
  inputs.forEach(function (input) {
    if (values[input.name] === undefined) {
      return;
    }

    if (input.type === 'checkbox') {
      input.checked = values[input.name];
    } else {
      input.value = values[input.name];
    }
  });
}

function showRestartBlueBarMessage() {
  cosmos.resolver.post({
    url: USER_MESSAGE_ENDPOINT,
    body: {
      id: 'feature-changed'
    }
  });
}

},{"../../../../../libs/bfs-km-searchview":132,"../../../../../libs/spotify-live":217,"./model":72,"./template.hbs":73,"domify":270,"spotify-cosmos-api":357}],72:[function(require,module,exports){
'use strict';

var live = require('../../../../../libs/spotify-live');

module.exports = live({
  enabled: true,
  uri: 'settings:employee-features:search-proxy',
  proxyEnabled: false,
  host: '',
  port: '',
  catalogue: '',
  username: '',
  country: '',
  employee: false
});

},{"../../../../../libs/spotify-live":217}],73:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, self=this, helperMissing=helpers.helperMissing;

function program1(depth0,data) {

  var buffer = "", stack1, helper, options;
  buffer += "\n<section id=\"search-proxy\">\n  <div class=\"section-divider section-divider-small\">\n    <h3>Search proxy</h3>\n  </div>\n\n  ";
  stack1 = (helper = helpers.sliderSetting || (depth0 && depth0.sliderSetting),options={hash:{},inverse:self.noop,fn:self.program(2, program2, data),data:data},helper ? helper.call(depth0, "settings:employee-features:search-proxy", "proxyEnabled", options) : helperMissing.call(depth0, "sliderSetting", "settings:employee-features:search-proxy", "proxyEnabled", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n  <div class=\"form-group\">\n    <label for=\"search-proxy-host\">Host: </label>\n    <input\n      id=\"search-proxy-host\"\n      class=\"form-control\"\n      type=\"text\"\n      name=\"host\">\n  </div>\n\n  <div class=\"form-group\">\n    <label for=\"search-proxy-port\">Port: </label>\n    <input\n      id=\"search-proxy-port\"\n      class=\"form-control\"\n      type=\"text\"\n      name=\"port\">\n  </div>\n\n  <div class=\"form-group\">\n    <label for=\"search-proxy-catalogue\">Catalogue: </label>\n    <input\n      id=\"search-proxy-catalogue\"\n      class=\"form-control\"\n      type=\"text\"\n      name=\"catalogue\">\n  </div>\n\n  <div class=\"form-group\">\n    <label for=\"search-proxy-username\">Username: </label>\n    <input\n      id=\"search-proxy-username\"\n      class=\"form-control\"\n      type=\"text\"\n      name=\"username\">\n  </div>\n\n  <div class=\"form-group\">\n    <label for=\"search-proxy-country\">Country: </label>\n    <input\n      id=\"search-proxy-country\"\n      class=\"form-control\"\n      type=\"text\"\n      name=\"country\">\n  </div>\n\n  <div class=\"form-group\">\n    <div class=\"checkbox\">\n      <label for=\"search-proxy-employee\">Employee flag </label>\n      <input\n        id=\"search-proxy-employee\"\n        type=\"checkbox\"\n        name=\"employee\">\n    </div>\n  </div>\n\n  <div class=\"form-group\">\n    <button type=\"button\" class=\"button button-with-stroke\">\n      <span>";
  stack1 = (helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "updateProxy", options) : helperMissing.call(depth0, "loc", "updateProxy", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "</span>\n    </button>\n  </div>\n\n</section>\n";
  return buffer;
  }
function program2(depth0,data) {


  return "\n    Override searchview settings\n  ";
  }

  stack1 = helpers['if'].call(depth0, (depth0 && depth0.enabled), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n";
  return buffer;
  });

},{"hbsfy/runtime":303}],74:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {

  var buffer = "", helper, options;
  buffer += "\n<section id=\"employee-features\">\n  <div class=\"section-divider\">\n    <h2>"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "employeeFeatures", options) : helperMissing.call(depth0, "loc", "employeeFeatures", options)))
    + "</h2>\n  </div>\n</section>\n";
  return buffer;
  }

  stack1 = helpers['if'].call(depth0, (depth0 && depth0.enabled), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n";
  return buffer;
  });

},{"hbsfy/runtime":303}],75:[function(require,module,exports){
module.exports={
  "en": "English (English)",
  "zh-Hant": "中文 (Chinese)",
  "hu": "Magyar (Hungarian)",
  "de": "Deutsch (German)",
  "es": "Español (Spanish)",
  "es-419": "Español (International Spanish)",
  "fi": "Suomeksi (Finnish)",
  "fr": "Français (French)",
  "fr-CA": "Français Canadien (Canadian French)",
  "el": "Eλληνικά (Greek)",
  "id": "Bahasa Indonesia (Indonesian)",
  "it": "Italiano (Italian)",
  "ja": "日本語 (Japanese)",
  "zsm": "Melayu (Malay)",
  "nl": "Nederlands (Dutch)",
  "pl": "Polski (Polish)",
  "pt-BR": "Português do Brasil (Brazilian Portuguese)",
  "sv": "Svenska (Swedish)",
  "tr": "Türkçe (Turkish)"
}
},{}],76:[function(require,module,exports){
'use strict';

/**
 * Module dependencies
 */

var Preferences = require('../../../../libs/spotify-preferences');
var cosmos = require('spotify-cosmos-api');
var dom = require('domify');

// global preferences
var prefs;

/**
 * Cosmos user message container endpoint
 */

var USER_MESSAGE_ENDPOINT = 'sp://messages/v1/container/user-message';

/**
 * Language setting template
 */

var template = require('./template.hbs');

// Original language that is initially fetch from core
var originalLanguage;

/**
 * Language setting model
 *
 * @api public
 */

exports.model = require('./model');

/**
 * Initializes language settings
 *
 * @api public
 * @param {Function} done
 */
exports.init = function (done) {
  if (!prefs) {
    prefs = new Preferences('*');
  }

  var model = exports.model;
  var settings = document.querySelector('#basic-settings');
  var view = dom(template(model.serialize()));

  // render
  settings.appendChild(view);

  // initialize model updates and notify
  // cosmos if the language changed is
  // not the original value at boot
  model.on('update', function (data) {
    // emit update only if language selected has change
    if (data.selected && originalLanguage && data.selected !== originalLanguage) {
      cosmos.resolver.post({
        url: USER_MESSAGE_ENDPOINT,
        body: {
          id: 'language-changed'
        }
      });
    }
  });

  // initialize model publishing to notify
  // bridge of a new language
  model.on('publish', function (data) {
    prefs.set('language', data.selected, function (err) {
      if (err) {
        done(err);
        return;
      }
      model.update({ selected: data.selected });
    });
  });

  done();
};

/**
 * Called when native layer pushs sync
 * to application layer
 *
 * @api public
 * @param {Function} done
 */

exports.sync = function (done) {
  if (!prefs) {
    prefs = new Preferences('*');
  }

  prefs.get('language', function (err, language) {
    if (err) {
      done(err);
      return;
    }
    if (!originalLanguage) {
      originalLanguage = language;
    }
    exports.model.update({ selected: language });
    done();
  });
};

},{"../../../../libs/spotify-preferences":243,"./model":77,"./template.hbs":78,"domify":270,"spotify-cosmos-api":357}],77:[function(require,module,exports){

'use strict';

/**
 * Module dependencies
 */

var live = require('../../../../libs/spotify-live');

/**
 * Language setting model
 *
 * @api public
 */

var languages = require('./data.json');
// jshint camelcase: false
var blacklistedLanguages = window.__spotify ? window.__spotify.blacklisted_languages : null;
// jshint camelcase: true
if (blacklistedLanguages) {
  for (var i = 0; i < blacklistedLanguages.length; ++i) {
    delete languages[blacklistedLanguages[i]];
  }
}

module.exports = live({
  languages: languages,
  selected: null,
  enabled: true,
  uri: 'settings:language'
});

},{"../../../../libs/spotify-live":217,"./data.json":75}],78:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {

  var buffer = "", stack1, helper, options;
  buffer += "\n<section id=\"language\">\n  <div class=\"section-divider\">\n    <h4>"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "language", options) : helperMissing.call(depth0, "loc", "language", options)))
    + "</h4>\n  </div>\n  ";
  stack1 = (helper = helpers.selectSetting || (depth0 && depth0.selectSetting),options={hash:{},inverse:self.noop,fn:self.program(2, program2, data),data:data},helper ? helper.call(depth0, "settings:language", "selected", "languages", options) : helperMissing.call(depth0, "selectSetting", "settings:language", "selected", "languages", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n</section>\n";
  return buffer;
  }
function program2(depth0,data) {

  var buffer = "", stack1, helper, options;
  buffer += "\n    ";
  stack1 = (helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "selectLanguage", options) : helperMissing.call(depth0, "loc", "selectLanguage", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  ";
  return buffer;
  }

  stack1 = helpers['if'].call(depth0, (depth0 && depth0.enabled), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n";
  return buffer;
  });

},{"hbsfy/runtime":303}],79:[function(require,module,exports){
'use strict';

/**
 * Module dependencies
 */

var localFiles = require('../../resources/local-files');
var events = require('../../lib/needed-events');
var live = require('../../../../libs/spotify-live');
var dom = require('domify');
var i18n = require('../../lib/i18n');
var $ = require('../../../../libs/spotify-elements');

var timeouts = {};

/**
 * Time in milliseconds when to remove
 * a source from the UI
 */

var SOURCE_REMOVE_TIMEOUT = 5000;

/**
 * View template
 */

var tpl = require('./template.hbs');

/**
 * Normalize a given source
 *
 * @api private
 * @param {Object} source
 */

function normalize(source) {
  // resolve source name
  var key = 'localFilesSource_' + source.id;
  var name = i18n.exists(key) && i18n(key) || source.name || source.path;

  // normalize object
  return {
    enabled: source.enabled,
    path: source.path,
    name: name,
    uri: 'settings:local-files:' + source.id,
    id: source.id
  };
}

/**
 * Updates model with normalized sources
 * that are found
 *
 * @api private
 * @param {Array} sources
 */

function update(sources) {
  exports.model.update({
    sources: sources.filter(function (source) {
      return source.found;
    }).map(function (source) {
      return normalize(source);
    })
  });
}

/**
 * Insert a new local file source
 * from browsed directory in UI
 *
 * @api private
 * @param {Function} fn
 */

function insertSourceFromDirectory(fn) {
  var model = exports.model;
  var sources = model.get('sources');
  localFiles.browse(function (err, dir) {
    var source = null;

    if (err) {
      fn(err);
      return;
    } else if (!dir.path) {
      // user clicks "Cancel"
      fn(new Error('Unable to determine directory path'));
      return;
    }

    source = {
      index: sources.length,
      values: [live(normalize({
        enabled: true,
        path: dir.path,
        id: dir.path
      }))],
      type: 'insert'
    };

    // publish
    sources.publish([source]);

    // done
    fn(null);
  });
}

function onSourceUpdate(source, data) {
  var id = source.get('id');
  var uri = source.uri;
  var to = timeouts[uri];

  // Never remove default sources.
  switch (id) {
    case 'downloads':
    case 'itunes':
    case 'my_music':
    case 'windows_music_library':
    case 'windows_media_player':
      return;

    default:
    // do nothing
  }

  if (to) {
    clearTimeout(to);
    delete timeouts[uri];
  }

  if (data.enabled === false) {
    timeouts[uri] = setTimeout(function () {
      if (source.get('enabled') === false) {
        var el = $('[data-row-uri=' + uri + ']');
        if (el) {
          el.remove();
        }
      }
      delete timeouts[uri];
    }, SOURCE_REMOVE_TIMEOUT);
  }
}

function onSourcePublish(source, data) {
  var action = data.enabled ? 'update' : 'delete';
  localFiles[action](source, function (err) {
    if (err) {
      console.error(err.stack || err);
    }
  });
}

/**
 * Setting live model
 *
 * @api public
 */

exports.model = require('./model');

/**
 * Initialize local files settings
 *
 * @api public
 * @param {Function} done
 */

exports.init = function (done) {
  var settings = document.querySelector('#basic-settings');
  var model = exports.model;
  var enabled = model.get('enabled');
  var sources = model.get('sources');
  var view = dom(tpl(model.serialize()));

  events.attach();

  if (enabled) {
    // handle click for "Add Source"
    $(view.querySelector('.add-source')).on('click', function () {
      insertSourceFromDirectory(function (err) {
        if (err) {
          console.error(err.stack || err);
        }
      });
    });

    sources.on('update', function () {
      var node = view.querySelector('.sources');
      node.innerHTML = require('./sources.hbs')(model.serialize());
      events.update();
    });

    // handle publish events for sources model
    sources.on('publish', function (data) {
      data.filter(function (op) {
        return op.type === 'insert';
      }).forEach(function (op) {
        op.values.forEach(function (source) {
          localFiles.update(source, function (err, filesData) {
            // when data comes back, update using server data.
            if (err) {
              console.error(err.stack || err);
            } else {
              update(filesData);
            }
          });
        });
      });
    });

    live.subscribe(/^settings:local-files:/, 'publish', onSourcePublish);
    live.subscribe(/^settings:local-files:/, 'update', onSourceUpdate);
  }

  settings.appendChild(view);
  done();
};

/**
 * Sync settings from bridge
 *
 * @api public
 * @param {Function} done
 */

exports.sync = function (done) {
  localFiles.sources(function (err, res) {
    if (err) {
      done(err);
      return;
    }

    update(res);
    done();
  });
};

},{"../../../../libs/spotify-elements":149,"../../../../libs/spotify-live":217,"../../lib/i18n":22,"../../lib/needed-events":24,"../../resources/local-files":38,"./model":80,"./sources.hbs":81,"./template.hbs":82,"domify":270}],80:[function(require,module,exports){

'use strict';

/**
 * Module dependencies
 */

var live = require('../../../../libs/spotify-live');

/**
 * Local files setting live model
 *
 * @api public
 */

module.exports = live({
  enabled: true,
  sources: [],
  uri: 'settings:local-files'
});

},{"../../../../libs/spotify-live":217}],81:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, functionType="function", self=this, helperMissing=helpers.helperMissing;

function program1(depth0,data) {

  var buffer = "", stack1, helper, options;
  buffer += "\n  ";
  stack1 = (helper = helpers.sliderSetting || (depth0 && depth0.sliderSetting),options={hash:{},inverse:self.noop,fn:self.program(2, program2, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.uri), "enabled", options) : helperMissing.call(depth0, "sliderSetting", (depth0 && depth0.uri), "enabled", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n";
  return buffer;
  }
function program2(depth0,data) {

  var stack1, helper;
  if (helper = helpers.name) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.name); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  if(stack1 || stack1 === 0) { return stack1; }
  else { return ''; }
  }

  stack1 = helpers.each.call(depth0, (depth0 && depth0.sources), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n";
  return buffer;
  });

},{"hbsfy/runtime":303}],82:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
var partial$0 = require('./sources.hbs');
HandlebarsCompiler.registerPartial('./sources.hbs', partial$0);
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); partials = this.merge(partials, Handlebars.partials); data = data || {};
  var buffer = "", stack1, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {

  var buffer = "", stack1, helper, options;
  buffer += "\n<section id=\"local-files\">\n  <div class=\"section-divider\">\n    <h2>"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "localFiles", options) : helperMissing.call(depth0, "loc", "localFiles", options)))
    + "</h2>\n  </div>\n\n  <div class=\"section-divider section-divider-small\">\n    <h3>"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "localFilesSources", options) : helperMissing.call(depth0, "loc", "localFilesSources", options)))
    + "</h3>\n  </div>\n\n  <div class=\"sources\">\n    ";
  stack1 = self.invokePartial(partials['./sources.hbs'], './sources.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  </div>\n\n  <button type=\"button\" class=\"button button-with-stroke add-source\">\n    <span>"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "localFilesAddSource", options) : helperMissing.call(depth0, "loc", "localFilesAddSource", options)))
    + "</span>\n  </button>\n</section>\n";
  return buffer;
  }

  stack1 = helpers['if'].call(depth0, (depth0 && depth0.enabled), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n";
  return buffer;
  });

},{"./sources.hbs":81,"hbsfy/runtime":303}],83:[function(require,module,exports){
'use strict';

/**
 * Module dependencies
 */

var Preferences = require('../../../../libs/spotify-preferences');
var cosmos = require('spotify-cosmos-api');
var live = require('../../../../libs/spotify-live');
var dom = require('domify');

var prefs;

// See spotify/bitrate/cpp/include/spotify/bitrate/bitrate_types.h
// in client-core.
var BIT_RATE_EXTREME = 4;
var BIT_RATE_HIGH = 3;
var BIT_RATE_AUTOMATIC = 0;

/**
 * Music quality setting template
 */

var template = require('./template.hbs');

/**
 * Music quality model
 *
 * @api publc
 */

exports.model = require('./model');

/**
 * Initializes music quality settings
 *
 * @api public
 * @param {Function} done
 */

exports.init = function (done) {
  if (!prefs) {
    prefs = new Preferences('*');
  }

  var model = exports.model;
  var settings = document.querySelector('#basic-settings');
  var view = dom(template(model.serialize()));

  // render
  settings.appendChild(view);

  model.on('publish', function (data) {
    function updatePlayBitrate(playBitrate, callback) {
      prefs.set('audio.play_bitrate_enumeration', playBitrate, function (err) {
        if (err) {
          console.error(err.stack || err);
          return;
        }

        model.update({ hqStreaming: data.hqStreaming });

        callback();
      });
    }

    function updateSyncBitrate(syncBitrate) {
      prefs.set('audio.sync_bitrate_enumeration', syncBitrate, function (err) {
        if (err) {
          console.error(err.stack || err);
          return;
        }
      });
    }

    // Only play bitrate should have an automatic setting.
    // Not because it doesn't work to set it to automatic,
    // but because product wants it this way.
    var playBitrate = data.hqStreaming ? BIT_RATE_EXTREME : BIT_RATE_AUTOMATIC;
    var syncBitrate = data.hqStreaming ? BIT_RATE_EXTREME : BIT_RATE_HIGH;

    live('spotify:client').query('session(product)', function (err, res) {
      if (err && console) {
        console.error(err.stack || err);
      }

      if (err || res.session.product !== 'premium') {
        cosmos.resolver.post({
          url: 'sp://messages/v1/container/user-message',
          body: {
            id: 'cant-set-high-quality-streaming'
          }
        });

        return;
      }

      updatePlayBitrate(playBitrate, function () {
        updateSyncBitrate(syncBitrate);
      });
    });
  });

  done();
};

/**
 * Called when native layer pushs sync
 * to application layer
 *
 * @api public
 * @param {Function} done
 */

exports.sync = function (done) {
  if (!prefs) {
    prefs = new Preferences('*');
  }

  prefs.all(function (err, res) {
    if (err) {
      done(err);
      return;
    }

    var isPremium = res['ps.type'] === 'premium';
    var isExtreme = res['audio.play_bitrate_enumeration'] === BIT_RATE_EXTREME;
    exports.model.update({
      hqStreaming: isPremium && isExtreme
    });

    done();
  });
};

},{"../../../../libs/spotify-live":217,"../../../../libs/spotify-preferences":243,"./model":84,"./template.hbs":85,"domify":270,"spotify-cosmos-api":357}],84:[function(require,module,exports){

'use strict';

/**
 * Module dependencies
 */

var live = require('../../../../libs/spotify-live');

/**
 * Music quality live model
 *
 * @api public
 */

module.exports = live({
  hqStreaming: false,
  enabled: true,
  uri: 'settings:quality'
});

},{"../../../../libs/spotify-live":217}],85:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {

  var buffer = "", stack1, helper, options;
  buffer += "\n<section id=\"music-quality\">\n  <div class=\"section-divider\">\n    <h2>"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "musicQuality", options) : helperMissing.call(depth0, "loc", "musicQuality", options)))
    + "</h2>\n  </div>\n\n  ";
  stack1 = (helper = helpers.sliderSetting || (depth0 && depth0.sliderSetting),options={hash:{},inverse:self.noop,fn:self.program(2, program2, data),data:data},helper ? helper.call(depth0, "settings:quality", "hqStreaming", options) : helperMissing.call(depth0, "sliderSetting", "settings:quality", "hqStreaming", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n</section>\n";
  return buffer;
  }
function program2(depth0,data) {

  var buffer = "", stack1, helper, options;
  buffer += "\n    ";
  stack1 = (helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "hqStreaming", options) : helperMissing.call(depth0, "loc", "hqStreaming", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  ";
  return buffer;
  }

  stack1 = helpers['if'].call(depth0, (depth0 && depth0.enabled), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n";
  return buffer;
  });

},{"hbsfy/runtime":303}],86:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", helper, options, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;


  buffer += "<div class=\"col crossfade\">\n  "
    + escapeExpression((helper = helpers.sliderRangeSetting || (depth0 && depth0.sliderRangeSetting),options={hash:{},data:data},helper ? helper.call(depth0, "settings:playback", "crossfadeDuration", options) : helperMissing.call(depth0, "sliderRangeSetting", "settings:playback", "crossfadeDuration", options)))
    + "\n</div>\n";
  return buffer;
  });

},{"hbsfy/runtime":303}],87:[function(require,module,exports){
'use strict';

/**
 * Module dependencies
 */

var Preferences = require('../../../../libs/spotify-preferences');
var Drag = require('../../lib/drag');
var dom = require('domify');
var $ = require('../../../../libs/spotify-elements');
var template = require('./template.hbs');
var prefs;

/**
 * Crossfade duration maximum value
 * in milliseconds
 */

var CROSSFADE_DURATION_MAX = 12000;

/**
 * Inserts `node' after `sibling'
 *
 * @api private
 * @param {Element} node
 * @param {Element} sibling
 */

function insertAfter(node, sibling) {
  sibling.parentNode.insertBefore(node, sibling.nextSibling);
}

/**
 * Playback setting model
 */

exports.model = require('./model');

/**
 * Initialize setting
 *
 * @api public
 * @param {Function} done
 */

exports.init = function (done) {
  if (!prefs) {
    prefs = new Preferences('*');
  }

  var settings = document.querySelector('#advanced-settings');
  var crossfade = dom(require('./crossfade.hbs')());
  var slider = crossfade.querySelector('.slider-range');
  var sliderTrack = slider.querySelector('.progress-bar-wrapper');
  var sliderHandle = slider.querySelector('.progress-bar-wrapper .handle');
  var model = exports.model;
  var view = dom(template(model.serialize()));

  // render
  settings.appendChild(view);

  // render cross fade
  insertAfter(crossfade, view.querySelector('.crossfade .description'));

  // initialize slider handle
  var computedWidth = getComputedStyle(sliderTrack).width;
  var width = parseFloat(computedWidth, 10);
  var start = 0;
  var end = width;
  var handle = new Drag(sliderHandle, {
    smooth: true,
    range: {
      x: [start, end]
    },
    axis: 'x'
  });

  function updateCrossfadeSliderPosition(data, updateHandle) {
    var time = slider.querySelector('.time');
    var x = 0;
    var w = 0;
    var p = 0;

    if ('crossfadeDuration' in data) {
      w = parseFloat(getComputedStyle(sliderTrack, null).width);
      p = data.crossfadeDuration / CROSSFADE_DURATION_MAX * 100;
      x = p * w / 100;

      time.innerHTML = Math.round(data.crossfadeDuration / 1000); // to seconds
      slider.querySelector('.inner').style.width = x + 'px';

      if (updateHandle !== false) {
        handle.position(x, 0);
      }
    }
  }

  function publish(data) {
    if ('crossfadeEnabled' in data) {
      var cfEnabled = data.crossfadeEnabled;
      prefs.set('audio.crossfade_v2', cfEnabled, function (err) {
        if (err) {
          console.error(err.stack || err);
        }
        model.update({ crossfadeEnabled: cfEnabled });
      });
    }

    if ('crossfadeDuration' in data) {
      var duration = data.crossfadeDuration;
      prefs.set('audio.crossfade.time_v2', duration, function (err) {
        if (err) {
          console.error(err.stack || err);
        }
        model.update({ crossfadeDuration: duration });
      });
    }

    if ('sameVolume' in data) {
      var svEnabled = data.sameVolume;
      prefs.set('audio.normalize_v2', svEnabled, function (err) {
        if (err) {
          console.error(err.stack || err);
        }
        model.update({ sameVolume: svEnabled });
      });
    }
  }

  function toggleSliderState(enabled) {
    if (enabled === true) {
      $(crossfade).removeClass('disabled');
      $(slider).removeClass('disabled');
      $(sliderTrack).addClass('handle');
      handle.enable();
    } else if (enabled === false) {
      $(crossfade).addClass('disabled');
      $(slider).addClass('disabled');
      $(sliderTrack).removeClass('handle');
      handle.disable();
    }
  }

  function handleMouseDown(e) {
    if (!model.get('crossfadeEnabled') || e.target === sliderTrack.querySelector('.handle')) {
      // Ignore the click in the handle
      return;
    }
    $(sliderTrack).addClass('active');
    var style = getComputedStyle(sliderTrack);
    var x;
    if (isTouch(e)) {
      x = e.changedTouches[0].pageX;
      var leftPosition = sliderTrack.getBoundingClientRect().left;
      x = x - leftPosition;
    } else {
      x = e.offsetX;
    }
    var w = parseFloat(style.width);
    var p = x / w;
    var duration = Math.round(p * CROSSFADE_DURATION_MAX);

    updateCrossfadeSliderPosition({ crossfadeDuration: duration });
    publish({ crossfadeDuration: duration });
    handle.handleDragStart(e);
  }
  // Add active class on sliderHandle
  $(sliderHandle).on('mousedown', function () {
    $(sliderTrack).addClass('active');
  });
  $(sliderHandle).on('touchstart', function () {
    $(sliderTrack).addClass('active');
  });

  // Remove active class on sliderHandle
  $(sliderHandle).on('mouseup', function () {
    $(sliderTrack).removeClass('active');
  });
  $(sliderHandle).on('touchend', function () {
    $(sliderTrack).removeClass('active');
  });

  // Remove active class on sliderTrack
  $(sliderTrack).on('mouseup', function () {
    $(sliderTrack).removeClass('active');
  });
  $(sliderTrack).on('touchend', function () {
    $(sliderTrack).removeClass('active');
  });

  $(sliderTrack).on('mousedown', handleMouseDown);
  $(sliderTrack).on('touchstart', handleMouseDown);

  handle.on('drag', function () {
    var x = handle.coords.x;
    var w = parseFloat(getComputedStyle(sliderTrack, null).width);
    var p = x / w;
    var duration = Math.round(p * CROSSFADE_DURATION_MAX);

    // update time
    model.update({ crossfadeDuration: duration });
    updateCrossfadeSliderPosition({ crossfadeDuration: duration }, false);
  });

  handle.on('dragend', function () {
    var duration = model.get('crossfadeDuration');
    $(sliderTrack).removeClass('active');
    publish({ crossfadeDuration: duration });
  });

  model.on('update', function (data) {
    toggleSliderState(data.crossfadeEnabled);
  });

  model.on('publish', function (data) {
    publish(data);
  });

  // handle current crossfade position
  updateCrossfadeSliderPosition(model.serialize());

  // handle enabled slider state
  toggleSliderState(model.get('crossfadeEnabled'));

  done();
};

/**
 * Function to decide if an event is touch or mouse
 *
 * @param {Event} e
 */

function isTouch(e) {
  if (e.type === 'touchstart' || e.type === 'touchmove' || e.type === 'touchend' || e.type === 'touchcancel') {
    return true;
  }

  return false;
}

/**
 * Sync bridge and model
 *
 * @api public
 * @param {Function} done
 */

exports.sync = function (done) {
  if (!prefs) {
    prefs = new Preferences('*');
  }

  prefs.all(function (err, res) {
    if (err) {
      done(err);
      return;
    }

    exports.model.update({
      crossfadeDuration: res['audio.crossfade.time_v2'],
      crossfadeEnabled: res['audio.crossfade_v2'],
      gapless: res['audio.gapless_v2'],
      sameVolume: res['audio.normalize_v2']
    });
    done();
  });
};

},{"../../../../libs/spotify-elements":149,"../../../../libs/spotify-preferences":243,"../../lib/drag":21,"./crossfade.hbs":86,"./model":88,"./template.hbs":89,"domify":270}],88:[function(require,module,exports){

'use strict';

/**
 * Module dependencies
 */

var live = require('../../../../libs/spotify-live');

/**
 * Recover playlist setting live model
 *
 * @api public
 */

module.exports = live({
  crossfadeEnabled: false,
  crossfadeDuration: 12000,
  sameVolume: false,
  gapless: false,
  enabled: true,
  uri: 'settings:playback'
});

},{"../../../../libs/spotify-live":217}],89:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {

  var buffer = "", stack1, helper, options;
  buffer += "\n<section id=\"playback\">\n  <div class=\"section-divider\">\n    <h2>"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "playback", options) : helperMissing.call(depth0, "loc", "playback", options)))
    + "</h2>\n  </div>\n\n  <div class=\"crossfade\">\n    ";
  stack1 = (helper = helpers.sliderSetting || (depth0 && depth0.sliderSetting),options={hash:{},inverse:self.noop,fn:self.program(2, program2, data),data:data},helper ? helper.call(depth0, "settings:playback", "crossfadeEnabled", options) : helperMissing.call(depth0, "sliderSetting", "settings:playback", "crossfadeEnabled", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  </div>\n\n  <div class=\"crossfade\">\n    ";
  stack1 = (helper = helpers.sliderSetting || (depth0 && depth0.sliderSetting),options={hash:{},inverse:self.noop,fn:self.program(4, program4, data),data:data},helper ? helper.call(depth0, "settings:playback", "sameVolume", options) : helperMissing.call(depth0, "sliderSetting", "settings:playback", "sameVolume", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  </div>\n\n</section>\n";
  return buffer;
  }
function program2(depth0,data) {

  var buffer = "", stack1, helper, options;
  buffer += "\n      ";
  stack1 = (helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "crossfadeTracks", options) : helperMissing.call(depth0, "loc", "crossfadeTracks", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    ";
  return buffer;
  }

function program4(depth0,data) {

  var buffer = "", stack1, helper, options;
  buffer += "\n      ";
  stack1 = (helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "sameVolume", options) : helperMissing.call(depth0, "loc", "sameVolume", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    ";
  return buffer;
  }

  stack1 = helpers['if'].call(depth0, (depth0 && depth0.enabled), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n";
  return buffer;
  });

},{"hbsfy/runtime":303}],90:[function(require,module,exports){
module.exports={
  "types": [
    "auto-detect",
    "no-proxy",
    "http",
    "socks4",
    "socks5"
  ]
}
},{}],91:[function(require,module,exports){
(function (global){
'use strict';

/**
 * Module dependencies
 */

var bridge = require('../../../../libs/spotify-bridge-request');
var cosmos = require('spotify-cosmos-api');
var dom = require('domify');
var $ = require('../../../../libs/spotify-elements');

/**
 * Proxy modes
 */
// var PROXY_MODE_AUTO = 0;
// var PROXY_MODE_NONE = 1;
var PROXY_MODE_HTTP = 2;
var PROXY_MODE_SOCKS4 = 3;
var PROXY_MODE_SOCKS5 = 4;

var USER_MESSAGE_ENDPOINT = 'sp://messages/v1/container/user-message';
var LOGIN_APP_URI = 'spotify:app:zlogin';

/**
 * Proxy input state map used
 * to determine which proxy inputs
 * are active for a given proxy mode
 */

var validFields = {};

validFields[PROXY_MODE_HTTP] = {
  username: true,
  password: true,
  host: true,
  port: true
};

validFields[PROXY_MODE_SOCKS4] = {
  username: true,
  host: true,
  port: true
};

validFields[PROXY_MODE_SOCKS5] = {
  username: true,
  password: true,
  host: true,
  port: true
};

/**
 * Proxy data
 */

var proxies = require('./data.json');

/**
 * Proxy setting template
 */

var template = require('./template.hbs');

/**
 * Validates the value of an input field.
 * Invalid is a non-empty string for the port number,
 * as well as for the field to be disabled.
 *
 * @api private
 * @param {Element} input
 * @return {Boolean} true if it's valid
 */

function validate(input) {
  var value = input.value;
  var name = input.getAttribute('name');

  if (name === 'port' && value !== '') {
    value = Number(value);
    if (Number.isNaN(value)) {
      return false;
    }
  }
  return true;
}

/**
 * Handle `blur' and `change' events
 * for proxy inputs
 *
 * @api private
 * @param {Event} e
 */

function onProxyBlurOrChange(e) {
  e.preventDefault();
  var valid = validate(e.target);
  $(e.target).toggleClass('error', !valid);
}

/**
 * Creates a map of input name
 * to input value from a given
 * DOM element who contains
 * `<input />' elements
 *
 * @api private
 * @param {Element} view
 */

function getInputValues(view) {
  var inputs = view.querySelectorAll('input');
  var values = {};

  for (var i = 0; i < inputs.length; i++) {
    var input = inputs[i];
    var key = input.getAttribute('name');
    var value = input.value;
    values[key] = value;
  }

  return values;
}

/**
 * format a proxy address to be submitted to
 * the backend
 *
 * @api private
 * @param {int} mode mode type
 * @param {string} host hostname
 * @param {string} port port number
 */

function formatAddress(mode, host, port) {
  var address = host + ':' + port;

  switch (mode) {
    case PROXY_MODE_HTTP:
      address += '@http';
      break;
    case PROXY_MODE_SOCKS4:
      address += '@socks4';
      break;
    case PROXY_MODE_SOCKS5:
      address += '@socks5';
      break;
    default:
    // do nothing
  }
  return address;
}

/**
 * Validate all input fields
 *
 * Inputs that aren't in validFields are always valid, since
 * they aren't relevant for the chosen proxy config.
 */
function validateInputs(fields) {
  var view = document.querySelector('#proxy');
  var inputs = view.querySelectorAll('input');
  var allValid = true;

  for (var i = 0; i < inputs.length; i++) {
    var name = inputs[i].name;

    var valid = true;
    if (fields[name]) {
      valid = validate(inputs[i]);
      if (!valid) {
        allValid = false;
      }
    }
    $(inputs[i]).toggleClass('error', !valid);
  }

  return allValid;
}

/**
 * Handle proxy input submission
 *
 * @api private
 * @param {Event} e
 */

function onProxySubmit(e) {
  var model = exports.model;
  var view = document.querySelector('#proxy');

  e.preventDefault();
  e.stopPropagation();

  var values = getInputValues(view);
  model.update(values);

  var data = model.serialize();

  var fieldsDef = validFields[data.mode];
  if (fieldsDef && !validateInputs(fieldsDef)) {
    return false;
  }

  // update bridge preferences through login-set-global-prefs since that
  // works regardless of being logged in.
  var prefs = {
    'network.proxy.mode': data.mode
  };

  if (fieldsDef) {
    if (fieldsDef.username) {
      prefs['network.proxy.user'] = data.username;
    }

    if (fieldsDef.password) {
      prefs['network.proxy.pass'] = data.password;
    }

    if (fieldsDef.host && fieldsDef.port) {
      prefs['network.proxy.addr'] = formatAddress(data.mode, data.host, data.port);
    }
  }

  bridge.request('login-set-global-prefs', [prefs], function (err) {
    if (err) {
      console.error(err.stack || err);
      return;
    }

    var isLoggedIn = !!global.__spotify.username;
    if (isLoggedIn) {
      // Notify the user to restart.
      cosmos.resolver.post({
        url: USER_MESSAGE_ENDPOINT,
        body: {
          id: 'proxysettings-changed'
        }
      });
    } else {
      // Take the user right back to login.
      global.location.href = LOGIN_APP_URI;
    }
  });

  return true;
}

/**
 * Update input values from map
 * where each key in map is the
 * input name and each value is
 * the input value
 *
 * @api private
 * @param {Element} view
 * @param {Object} map
 */

function updateInputValues(view, values) {
  var inputs = view.querySelectorAll('input');
  var select = view.querySelector('select');

  for (var i = 0; i < inputs.length; i++) {
    var input = inputs[i];
    var name = input.getAttribute('name');
    var value = values[name];
    input.value = value || '';
  }

  if (values.type) {
    select.value = values.type;
  }
}

/**
 * Toggles input state based on
 * proxy mode
 *
 * @api public
 * @param {Element} view
 * @param {Number} mode
 */

function updateInputDisabledState(view, mode) {
  var inputs = view.querySelectorAll('input');
  var fields = validFields[mode];

  // Assume all inputs have no errors
  $(inputs).removeClass('error');

  // Without any valid fields for this state, just disable all
  if (!fields) {
    $(inputs).attribute('disabled', true);
    return false;
  }

  for (var i = 0; i < inputs.length; i++) {
    var input = inputs[i];
    var name = input.name;
    if (fields[name]) {
      input.removeAttribute('disabled');
    } else {
      input.setAttribute('disabled', true);
    }
  }

  return true;
}

/**
 * Proxy setting model
 *
 * @api publc
 */

exports.model = require('./model');

/**
 * Initializes proxy  settings
 *
 * @api public
 * @param {Function} done
 */

exports.init = function (done) {
  var isLoggedIn = !!global.__spotify.username;

  var settings;
  if (isLoggedIn) {
    settings = document.querySelector('#advanced-settings');
  } else {
    settings = document.querySelector('#basic-settings');
  }

  var model = exports.model;
  var modelData = model.serialize();
  var view = dom(template(modelData));

  updateInputDisabledState(view, modelData.mode);
  updateInputValues(view, modelData);

  // render
  settings.appendChild(view);

  // handle view changes when model
  // state is published
  model.on('publish', function (data) {
    var mode;

    // retrieve mode constant from
    // proxy types index
    if (data.type) {
      mode = proxies.types.indexOf(data.type);
    }

    // update input state
    updateInputDisabledState(view, mode);

    // update proxy model mode and type
    model.update({
      type: proxies.types[mode],
      mode: mode
    });

    // focus the host input
    var hostInput = view.querySelector('#proxy-host-input');
    hostInput.focus();
    hostInput.select();
  });

  // bind input events
  $(view).search('input').on('blur', onProxyBlurOrChange).on('change', onProxyBlurOrChange);

  // handle submission
  $(view).search('#updateProxy').on('click', onProxySubmit);

  done();
};

/**
 * Called when native layer pushs sync
 * to application layer
 *
 * @api public
 * @param {Function} done
 */

exports.sync = function (done) {
  var prefs = ['network.proxy.mode', 'network.proxy.addr', 'network.proxy.user', 'network.proxy.pass'];

  bridge.request('login-get-global-prefs', prefs, function (error, data) {
    if (error) {
      done(error);
      return;
    }

    var mode = data['network.proxy.mode'];
    var address = data['network.proxy.addr'];
    var user = data['network.proxy.user'];
    var pass = data['network.proxy.pass'];

    var parts = address.split(':');
    var host = parts[0] || null;
    var port = parts[1] || null;
    var type = proxies.types[mode];

    // remove the proxy type from the port
    if (port && port.indexOf('@') > -1) {
      port = port.split('@')[0];
    }

    var updateData = {
      mode: mode,
      host: host,
      port: port,
      username: user,
      password: pass,
      type: type
    };

    exports.model.update(updateData);

    done();
  });
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../../../libs/spotify-bridge-request":144,"../../../../libs/spotify-elements":149,"./data.json":90,"./model":92,"./template.hbs":93,"domify":270,"spotify-cosmos-api":357}],92:[function(require,module,exports){
'use strict';

/**
 * Module dependencies
 */

var proxies = require('./data.json');
var i18n = require('../../lib/i18n');
var live = require('../../../../libs/spotify-live');

/**
 * Cerate i18n support for types
 */

var supported = proxies.types.reduce(function (map, type) {
  map[type] = i18n(type);
  return map;
}, {});

/**
 * Proxy live model
 *
 * @api public
 */

module.exports = live({
  supportedProxies: supported,
  username: '',
  password: '',
  enabled: true,
  mode: 0,
  type: proxies.types[0],
  host: '',
  port: '',
  uri: 'settings:proxy'
});

},{"../../../../libs/spotify-live":217,"../../lib/i18n":22,"./data.json":90}],93:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {

  var buffer = "", stack1, helper, options;
  buffer += "\n<section id=\"proxy\">\n  <div class=\"section-divider\">\n    <h2>"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Proxy", options) : helperMissing.call(depth0, "loc", "Proxy", options)))
    + "</h2>\n  </div>\n\n  ";
  stack1 = (helper = helpers.selectSetting || (depth0 && depth0.selectSetting),options={hash:{},inverse:self.noop,fn:self.program(2, program2, data),data:data},helper ? helper.call(depth0, "settings:proxy", "type", "supportedProxies", options) : helperMissing.call(depth0, "selectSetting", "settings:proxy", "type", "supportedProxies", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n  <div class=\"form-group\">\n    <input\n      id=\"proxy-host-input\"\n      placeholder='";
  stack1 = (helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Host", options) : helperMissing.call(depth0, "loc", "Host", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "'\n      data-uri=\"proxy\"\n      disabled=true\n      class=\"form-control\"\n      type=\"text\"\n      name=\"host\" />\n\n    <input\n      placeholder='";
  stack1 = (helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Port", options) : helperMissing.call(depth0, "loc", "Port", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "'\n      data-uri=\"proxy\"\n      disabled=true\n      class=\"form-control\"\n      type=\"text\"\n      name=\"port\" />\n  </div>\n\n  <div class=\"form-group\">\n    <input\n      placeholder='";
  stack1 = (helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "username", options) : helperMissing.call(depth0, "loc", "username", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "'\n      data-uri=\"proxy\"\n      disabled=true\n      class=\"form-control\"\n      type=\"text\"\n      name=\"username\" />\n\n    <input\n      placeholder='";
  stack1 = (helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "password", options) : helperMissing.call(depth0, "loc", "password", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "'\n      disabled=true\n      data-uri=\"proxy\"\n      class=\"form-control\"\n      type=\"password\"\n      name=\"password\" />\n  </div>\n\n  <div class=\"form-group\">\n    <button id=\"updateProxy\" type=\"button\" class=\"button button-with-stroke\">\n    <span>";
  stack1 = (helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "updateProxy", options) : helperMissing.call(depth0, "loc", "updateProxy", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "</span>\n    </button>\n  </div>\n</section>\n";
  return buffer;
  }
function program2(depth0,data) {

  var buffer = "", stack1, helper, options;
  buffer += "\n    ";
  stack1 = (helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "selectProxy", options) : helperMissing.call(depth0, "loc", "selectProxy", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  ";
  return buffer;
  }

  stack1 = helpers['if'].call(depth0, (depth0 && depth0.enabled), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n";
  return buffer;
  });

},{"hbsfy/runtime":303}],94:[function(require,module,exports){
'use strict';

/**
 * Module dependencies
 */

var dom = require('domify');
var $ = require('../../../../../libs/spotify-elements');
var facebook = require('../../../resources/facebook');
var user = require('../../../models/user');
var _ = require('../../../lib/i18n');

/**
 * Facebook social setting template
 */

var template = require('./template.hbs');
var userInfoTemplate = require('./user.hbs');

/**
 * Social setting model
 *
 * @api public
 */

exports.model = require('./model');

function toggleDisplay(element, enabled) {
  if (enabled) {
    element.removeClass('hidden');
  } else {
    element.addClass('hidden');
  }
}

function updateView() {
  var data = exports.model.serialize();
  var descriptionLabel = $('#facebook-description');
  var section = $('#facebook-section');
  var connectButton = $('#facebook-connect-button');
  var connectButtonLabel = $('#facebook-button-label');
  var scrobbling = $('#facebook-scrobbling');

  toggleDisplay(section, data.show_connect_option || data.connection);
  toggleDisplay(connectButton, data.show_connect_option);
  toggleDisplay(scrobbling, data.connection);

  if (data.connection) {
    descriptionLabel.html(userInfoTemplate(user.serialize()));
    connectButtonLabel.html(_('disconnectFacebook'));
  } else {
    descriptionLabel.html(_('seeWhatFriendsAreListening'));
    connectButtonLabel.html(_('connectFacebook'));
  }
}

var PERMISSION_KEY_SCROBBLING = 'publish_actions';
var PERMISSION_VALUE_GRANTED = 'granted';

function hasScrobblingPermission(permissions) {
  return permissions.filter(function (p) {
    return p.permission === PERMISSION_KEY_SCROBBLING && p.status === PERMISSION_VALUE_GRANTED;
  }).length > 0;
}

function checkScrobblingPermission(onPresent, onMissing) {
  facebook.getPermissions(function (err, resp) {
    if (hasScrobblingPermission(resp.permissions)) {
      onPresent();
    } else {
      onMissing();
    }
  });
}

function requestScrobblingPermission(onGranted, onDenied) {
  facebook.requestPermissions(PERMISSION_KEY_SCROBBLING, checkScrobblingPermission.bind(null, onGranted, onDenied));
}

function setScrobbling(enabled, callback) {
  var enableScrobbling = facebook.setScrobbling.bind(facebook, true, callback);
  var disableScrobbling = facebook.setScrobbling.bind(facebook, false, callback);
  var onMissing = requestScrobblingPermission.bind(null, enableScrobbling, disableScrobbling);

  if (!enabled) {
    disableScrobbling();
  } else {
    checkScrobblingPermission(enableScrobbling, onMissing);
  }
}

/**
 * Initializes social settings
 *
 * @api public
 * @param {Function} done
 */

exports.init = function (done) {
  var settings = document.querySelector('#social');
  var model = exports.model;
  var view = dom(template(model.serialize()));

  // render
  settings.appendChild(view);
  var updateModel = function updateModel(err, data) {
    if (!err) {
      model.update(data);
    }
  };

  $('#facebook-connect-button').on('click', function () {
    if (model.get('connection')) {
      facebook.disconnect(updateModel);
    } else {
      facebook.connect(updateModel);
    }
  });

  facebook.getConnectionStatus(function (err, status) {
    if (!err) {
      model.update(status);
    }
  });

  model.on('update', function () {
    updateView();
  });

  model.on('publish', function (data) {
    if ('scrobbling' in data) {
      setScrobbling(data.scrobbling, function (err, resp) {
        if (!err) {
          model.update(resp);
        }
      });
    }
  });

  user.on('update', function () {
    updateView();
  });

  facebook.subscribeToConnectionStatus(function (err, res) {
    if (!err) {
      model.update(res);
    }
  });

  updateView();
  done();
};

/**
 * Called when native layer pushs sync
 * to application layer
 *
 * @api public
 * @param {Function} done
 */

exports.sync = function (done) {
  facebook.getScrobbling(function (err, resp) {
    if (err) {
      done(err);
      return;
    }
    exports.model.update(resp);
    done();
  });
};

},{"../../../../../libs/spotify-elements":149,"../../../lib/i18n":22,"../../../models/user":33,"../../../resources/facebook":35,"./model":95,"./template.hbs":96,"./user.hbs":97,"domify":270}],95:[function(require,module,exports){

'use strict';

/**
 * Module dependencies
 */

var live = require('../../../../../libs/spotify-live');

/**
 * Social live model
 *
 * @api public
 */

module.exports = live({
  enabled: true,
  scrobbling: false,
  connection: false,
  show_connect_option: true,
  uri: 'settings:social:facebook'
});

},{"../../../../../libs/spotify-live":217}],96:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {

  var buffer = "", stack1, helper, options;
  buffer += "\n<section id=\"facebook-section\">\n  <div class=\"section-divider section-divider-small\">\n    <h3>"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "facebook", options) : helperMissing.call(depth0, "loc", "facebook", options)))
    + "</h3>\n  </div>\n\n  <div class=\"setting-row incognito-state\">\n    <div id=\"facebook-description\" class=\"col description\"></div>\n    <div class=\"col action action-button\">\n     <button type=\"button\" class=\"enable button button-facebook\" id=\"facebook-connect-button\">\n        <span id=\"facebook-button-label\"></span>\n      </button>\n    </div>\n  </div>\n  <div id=\"facebook-scrobbling\">\n    ";
  stack1 = (helper = helpers.sliderSetting || (depth0 && depth0.sliderSetting),options={hash:{},inverse:self.noop,fn:self.program(2, program2, data),data:data},helper ? helper.call(depth0, "settings:social:facebook", "scrobbling", "incognito-state", options) : helperMissing.call(depth0, "sliderSetting", "settings:social:facebook", "scrobbling", "incognito-state", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  </div>\n</section>\n";
  return buffer;
  }
function program2(depth0,data) {

  var buffer = "", stack1, helper, options;
  buffer += "\n      ";
  stack1 = (helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "shareOnFacebook", options) : helperMissing.call(depth0, "loc", "shareOnFacebook", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    ";
  return buffer;
  }

  stack1 = helpers['if'].call(depth0, (depth0 && depth0.enabled), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n";
  return buffer;
  });

},{"hbsfy/runtime":303}],97:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
var partial$0 = require('../../../../../libs/spotify-glue-cat/templates/v1/media-image-no-link.hbs');
HandlebarsCompiler.registerPartial('../../../../../libs/spotify-glue-cat/templates/v1/media-image-no-link.hbs', partial$0);
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); partials = this.merge(partials, Handlebars.partials); data = data || {};
  var buffer = "", stack1, helper, self=this, functionType="function", escapeExpression=this.escapeExpression;


  buffer += "<div class=\"avatar\">\n    ";
  stack1 = self.invokePartial(partials['../../../../../libs/spotify-glue-cat/templates/v1/media-image-no-link.hbs'], '../../../../../libs/spotify-glue-cat/templates/v1/media-image-no-link.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n</div>\n<span>";
  if (helper = helpers.name) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.name); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</span>\n";
  return buffer;
  });

},{"../../../../../libs/spotify-glue-cat/templates/v1/media-image-no-link.hbs":190,"hbsfy/runtime":303}],98:[function(require,module,exports){
(function (global){
'use strict';

/**
 * Module dependencies
 */

var Batch = require('spotify-batch');
var dom = require('domify');

/**
 * Social setting sections
 */

var sections = [require('./spotify'), require('./facebook'), global.__spotify.container_features.lastfmOAuth ? require('./lastfm-oauth') : require('./lastfm')];

/**
 * Social setting template
 */

var template = require('./template.hbs');

/**
 * Social setting model
 *
 * @api public
 */

exports.model = require('./model');

/**
 * Initializes social settings
 *
 * @api public
 * @param {Function} done
 */

exports.init = function (done) {
  var settings = document.querySelector('#basic-settings');
  var model = exports.model;
  var enabled = model.get('enabled');
  var batch = new Batch().concurrency(1);
  var view = dom(template(model.serialize()));

  if (enabled) {
    // render
    settings.appendChild(view);

    sections.forEach(function (section) {
      if (typeof section.init === 'function') {
        batch.push(function (next) {
          section.init(next);
        });
      }
    });
  }

  batch.run(done);
};

/**
 * Called when native layer pushs sync
 * to application layer
 *
 * @api public
 * @param {Function} done
 */

exports.sync = function (done) {
  var batch = new Batch().concurrency(1);
  sections.forEach(function (section) {
    if (typeof section.sync === 'function') {
      batch.push(function (next) {
        section.sync(next);
      });
    }
  });

  batch.run(done);
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./facebook":94,"./lastfm":102,"./lastfm-oauth":99,"./model":105,"./spotify":106,"./template.hbs":109,"domify":270,"spotify-batch":351}],99:[function(require,module,exports){
'use strict';

/**
 * Module dependencies
 */

var lastfm = require('../../../resources/lastfm-oauth');
var i18n = require('../../../lib/i18n');
var dom = require('domify');
var $ = require('../../../../../libs/spotify-elements');

/**
 * Last.fm social setting template
 */

var template = require('./template.hbs');

/**
 * Last.fm setting model
 *
 * @api public
 */

exports.model = require('./model');

/**
 * Initializes Last.FM settings
 *
 * @api public
 * @param {Function} done
 */

exports.init = function (done) {
  var settings = document.querySelector('#social');
  var model = exports.model;
  var enabled = model.get('enabled');
  var view = dom(template(model.serialize()));

  var status = view.querySelector('.status');

  var stateConnected = view.querySelectorAll('.state.connected');
  var stateDisconnected = view.querySelectorAll('.state.disconnected');

  var disconnect = view.querySelector('.disconnect');
  var showAuth = view.querySelector('.show-auth .button');

  // render
  settings.appendChild(view);

  /**
   * Updates state
   *
   * @api private
   */

  function update() {
    var scrobbling = model.get('scrobbling');
    var username = model.get('username');

    if (scrobbling === true) {
      $(stateDisconnected).addClass('hidden');
      $(stateConnected).removeClass('hidden');
      status.innerText = i18n('connectedToLastFmAs', username);
    } else {
      $(stateDisconnected).removeClass('hidden');
      $(stateConnected).addClass('hidden');
    }
  }

  if (enabled) {
    update();
    model.on('update', function () {
      update();
    });

    $(disconnect).on('click', function () {
      lastfm.logout(function () {
        model.update({
          username: null,
          scrobbling: false
        });
      });
    });

    $(showAuth).on('click', function () {
      lastfm.auth();
    });
  }

  lastfm.subscribe(function (e, res) {
    if (e) {
      return;
    }
    model.update({
      scrobbling: res.scrobbling,
      username: res.username
    });
  });

  done();
};

/**
 * Called when native layer pushs sync
 * to application layer
 *
 * @api public
 * @param {Function} done
 */

exports.sync = function (done) {
  lastfm.status(function (err, res) {
    if (err) {
      done(err);
      return;
    }

    exports.model.update({
      scrobbling: res.scrobbling,
      username: res.username
    });

    done();
  });
};

},{"../../../../../libs/spotify-elements":149,"../../../lib/i18n":22,"../../../resources/lastfm-oauth":36,"./model":100,"./template.hbs":101,"domify":270}],100:[function(require,module,exports){

'use strict';

/**
 * Module dependencies
 */

var live = require('../../../../../libs/spotify-live');

/**
 * Last.FM setting model
 *
 * @api public
 */

module.exports = live({
  username: null,
  enabled: true,
  scrobbling: false,
  uri: 'setting:social:lastfm:oauth'
});

},{"../../../../../libs/spotify-live":217}],101:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {

  var buffer = "", helper, options;
  buffer += "\n<section class=\"lastfm-oauth\">\n  <div class=\"section-divider section-divider-small\">\n    <h3>"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "lastfm", options) : helperMissing.call(depth0, "loc", "lastfm", options)))
    + "</h3>\n  </div>\n\n  <div class=\"setting-row state disconnected\">\n    <div class=\"col description\">\n      "
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "scrobbleToLastfm", options) : helperMissing.call(depth0, "loc", "scrobbleToLastfm", options)))
    + "\n    </div>\n\n    <div class=\"col action show-auth state disconnected\">\n      <button class=\"connect button button-with-stroke\" type=\"button\">\n        <span>"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "connectLastfm", options) : helperMissing.call(depth0, "loc", "connectLastfm", options)))
    + "</span>\n      </button>\n    </div>\n  </div>\n\n  <section class=\"state connected setting-row\">\n    <div class=\"col action user description\">\n      <span class=\"status\">&nbsp;</span>\n    </div>\n\n    <div class=\"col action\">\n      <button class=\"disconnect button button-with-stroke\" type=\"button\">\n        <span>"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "disconnectLastfm", options) : helperMissing.call(depth0, "loc", "disconnectLastfm", options)))
    + "</span>\n      </button>\n    </div>\n  </section>\n\n  <section class=\"state disconnected setting-row\">\n    <div class=\"col user-input hidden right\">\n      <button class=\"connect-last-fm button button-with-stroke\" type=\"button\">\n        <span>"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "connect", options) : helperMissing.call(depth0, "loc", "connect", options)))
    + "</span>\n      </button>\n    </div>\n  </section>\n</section>\n";
  return buffer;
  }

  stack1 = helpers['if'].call(depth0, (depth0 && depth0.enabled), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n";
  return buffer;
  });

},{"hbsfy/runtime":303}],102:[function(require,module,exports){
'use strict';

/**
 * Module dependencies
 */

var lastfm = require('../../../resources/lastfm');
var i18n = require('../../../lib/i18n');
var dom = require('domify');
var $ = require('../../../../../libs/spotify-elements');

var bind = Function.prototype.bind.bind(Function.prototype.call);
var every = bind(Array.prototype.every);

/**
 * Error codes
 */

var EBAD_CREDENTIALS = 5001;
var ESET_CREDENTIALS = 32;

/**
 * Key codes
 */

var ENTER_KEY = 13;

/**
 * Last.fm social setting template
 */

var template = require('./template.hbs');

/**
 * Last.fm setting model
 *
 * @api public
 */

exports.model = require('./model');

/**
 * Initializes Last.FM settings
 *
 * @api public
 * @param {Function} done
 */

exports.init = function (done) {
  var settings = document.querySelector('#social');
  var model = exports.model;
  var enabled = model.get('enabled');
  var view = dom(template(model.serialize()));

  var inputs = view.querySelectorAll('input');
  var status = view.querySelector('.status');
  var message = view.querySelector('.message');

  var stateConnected = view.querySelectorAll('.state.connected');
  var stateDisconnected = view.querySelectorAll('.state.disconnected');

  var connect = view.querySelector('.connect-last-fm');
  var disconnect = view.querySelector('.disconnect');

  var showAuth = view.querySelector('.show-auth .button');

  // render
  settings.appendChild(view);

  /**
   * Shows authentication inputs
   *
   * @api private
   */

  function showAuthenticationInputs() {
    $(view.querySelector('.show-auth')).addClass('hidden');
    $(view.querySelectorAll('.user-input')).removeClass('hidden');

    view.querySelector('#lastfm-username-input').focus();
  }

  /**
   * Hides authentication inputs
   *
   * @api private
   */

  function hideAuthenticationInputs() {
    $(view.querySelector('.show-auth')).removeClass('hidden');
    $(view.querySelectorAll('.user-input')).addClass('hidden');
  }

  /**
   * Handles `onkeydown' and `onkeyup' events
   * for all inputs
   *
   * @api private
   * @param {Event} e
   */

  function onkey(e) {
    if (ENTER_KEY === e.which) {
      e.stopPropagation();
      e.preventDefault();
      login();
      return false;
    }

    return true;
  }

  /**
   * Updates state
   *
   * @api private
   */

  function update() {
    var scrobbling = model.get('scrobbling');
    var username = model.get('username');

    if (scrobbling === true) {
      $(stateDisconnected).addClass('hidden');
      $(stateConnected).removeClass('hidden');
      $(message).addClass('hide');
      $(inputs).forEach(function (input) {
        input.value = '';
      });
      status.innerText = i18n('connectedToLastFmAs', username);
    } else {
      $(stateDisconnected).removeClass('hidden');
      $(stateConnected).addClass('hidden');
      $(message).removeClass('hide');
    }
  }

  /**
   * Validate inputs
   *
   * @api private
   * @param {Array|HTMLCollection} inputs
   * @param {Boolean} showError - optional
   */

  function validate(inputsList, showError) {
    return every(inputsList, function (input) {
      var name = input.getAttribute('name');
      var value = Boolean(input.value);

      $(input).removeClass('error');
      if (value === false) {
        $(input).addClass('error');

        if (showError !== false) {
          switch (name) {
            case 'username':
              error('missingUsername');
              break;

            case 'password':
              error('missingPassword');
              break;

            default:
            // do nothing
          }
        }

        return false;
      }

      return true;
    });
  }

  /**
   * Displays a give message for a view and
   * returns message container node with a
   * reset `className'
   *
   * @api private
   * @param {Element} view
   * @param {String} message
   */

  function info(msg) {
    var span = message.querySelector('span');
    message.className = 'message';

    if (!msg) {
      span.innerText = '';
    } else if (typeof msg === 'string') {
      span.innerText = i18n(msg);
    } else if (msg.appendChild) {
      span.innerText = '';
      span.appendChild(msg);
    }

    return message;
  }

  /**
   * Displays a given error message in view
   *
   * @api private
   * @param {Element} view
   * @param {String} message
   */

  function error(msg) {
    var node = info(msg);
    $(node).addClass('error');
  }

  /**
   * Logout user and disable scrobbling
   *
   * @api private
   * @param {Element} view
   */

  function logout() {
    lastfm.logout(function (err, res) {
      if (err) {
        console.error(err.stack || err);
        return;
      }

      if (res.credentials_set === false) {
        model.update({
          username: null,
          password: null,
          scrobbling: false
        });

        hideAuthenticationInputs();
      } else {
        console.debug(res);
      }
    });
  }

  /**
   * Login user and enable scrobbling
   *
   * @api private
   * @param {Element} view
   */

  function login() {
    var username = view.querySelector('input[name=username]');
    var password = view.querySelector('input[name=password]');
    var opts = null;

    info(false);

    if (validate(inputs) === false) {
      return false;
    }

    opts = {
      username: username.value,
      password: password.value
    };

    lastfm.auth(opts, function (err, res) {
      if (err) {
        console.error(err.stack || err);
        return;
      }

      if (res.credentials_set && res.scrobbling) {
        opts.scrobbling = res.scrobbling;
        model.update(opts);
        hideAuthenticationInputs();
      } else {
        // @TODO - handle more error cases
        switch (res.error_code) {
          case EBAD_CREDENTIALS:
            error('invalidUsernameOrPassword');
            $(inputs).addClass('error');
            break;

          case ESET_CREDENTIALS:
            // @NOP
            // credentials are just set and this
            // callback will be called again where
            // we can determine of the user is scrobbling
            // and their credentials have been set natively
            break;

          default:
            console.warn('Failed to authenticate Last.fm', res);
        }
      }
    });

    return true;
  }

  if (enabled) {
    update();
    model.on('update', function () {
      update();
    });

    $(inputs).on('keyup', onkey);
    $(inputs).on('keydown', onkey);

    $(inputs).on('blur', function (e) {
      validate([e.target], false);
    });

    $(inputs).on('change', function (e) {
      validate([e.target], false);
    });

    $(connect).on('click', function () {
      login();
    });

    $(disconnect).on('click', function () {
      logout();
    });

    $(showAuth).on('click', function () {
      showAuthenticationInputs();
    });
  }

  done();
};

/**
 * Called when native layer pushs sync
 * to application layer
 *
 * @api public
 * @param {Function} done
 */

exports.sync = function (done) {
  lastfm.status(function (err, res) {
    if (err) {
      done(err);
      return;
    }

    exports.model.update({
      scrobbling: res.scrobbling,
      username: res.username,
      password: res.password
    });

    done();
  });
};

},{"../../../../../libs/spotify-elements":149,"../../../lib/i18n":22,"../../../resources/lastfm":37,"./model":103,"./template.hbs":104,"domify":270}],103:[function(require,module,exports){

'use strict';

/**
 * Module dependencies
 */

var live = require('../../../../../libs/spotify-live');

/**
 * Last.FM setting model
 *
 * @api public
 */

module.exports = live({
  username: null,
  password: null,
  enabled: true,
  scrobbling: false,
  uri: 'setting:social:lastfm'
});

},{"../../../../../libs/spotify-live":217}],104:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {

  var buffer = "", stack1, helper, options;
  buffer += "\n<section class=\"lastfm incognito-state\">\n  <div class=\"section-divider section-divider-small\">\n    <h3>"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "lastfm", options) : helperMissing.call(depth0, "loc", "lastfm", options)))
    + "</h3>\n  </div>\n\n  <div class=\"setting-row state disconnected\">\n    <div class=\"col description\">\n      "
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "scrobbleToLastfm", options) : helperMissing.call(depth0, "loc", "scrobbleToLastfm", options)))
    + "\n    </div>\n\n    <div class=\"col action action-button show-auth state disconnected\">\n      <button class=\"connect button button-with-stroke\" type=\"button\">\n        <span>"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "connectLastfm", options) : helperMissing.call(depth0, "loc", "connectLastfm", options)))
    + "</span>\n      </button>\n    </div>\n  </div>\n\n  <section class=\"state connected setting-row\">\n    <div class=\"col action user description\">\n      <span class=\"status\">&nbsp;</span>\n    </div>\n\n    <div class=\"col action action-button\">\n      <button class=\"disconnect button button-with-stroke\" type=\"button\">\n        <span>"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "disconnectLastfm", options) : helperMissing.call(depth0, "loc", "disconnectLastfm", options)))
    + "</span>\n      </button>\n    </div>\n  </section>\n\n  <section class=\"state disconnected setting-row\">\n    <div class=\"col user-input hidden right\">\n      <button class=\"connect-last-fm button button-with-stroke\" type=\"button\">\n        <span>"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "connect", options) : helperMissing.call(depth0, "loc", "connect", options)))
    + "</span>\n      </button>\n    </div>\n\n    <div class=\"col user-input hidden left\">\n      <div class=\"form-group\">\n        <input id=\"lastfm-username-input\" class=\"form-control\" placeholder='";
  stack1 = (helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "username", options) : helperMissing.call(depth0, "loc", "username", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "' type=\"text\" name=\"username\" />\n        <input class=\"form-control\" placeholder='";
  stack1 = (helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "password", options) : helperMissing.call(depth0, "loc", "password", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "' type=\"password\" name=\"password\" />\n      </div>\n    </div>\n  </section>\n\n  <section class=\"message hide setting-row\">\n    <span>&nbsp;</span>\n  </section>\n</section>\n";
  return buffer;
  }

  stack1 = helpers['if'].call(depth0, (depth0 && depth0.enabled), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n";
  return buffer;
  });

},{"hbsfy/runtime":303}],105:[function(require,module,exports){

'use strict';

/**
 * Module dependencies
 */

var live = require('../../../../libs/spotify-live');

/**
 * Social live model
 *
 * @api public
 */

module.exports = live({
  enabled: true,
  uri: 'settings:social',

  facebook: require('./facebook/model'),
  lastfm: require('./lastfm/model'),
  spotfy: require('./spotify/model')

});

},{"../../../../libs/spotify-live":217,"./facebook/model":95,"./lastfm/model":103,"./spotify/model":107}],106:[function(require,module,exports){
'use strict';

/**
 * Module dependencies
 */

var Preferences = require('../../../../../libs/spotify-preferences');
var abba = require('../../../../../libs/spotify-abba-mini');

// Monkey patch because there is a bug in dedupe and spotify-live-models
// also depends on spotify-preferences.
if (!Preferences.prototype.setAtomicFlags) {
  Preferences.prototype.setAtomicFlags = function (key, flagBoolPairs, fn) {
    this.get(key, function (err, _value) {
      if (err) {
        fn(err);
        return;
      }

      var value = _value;

      flagBoolPairs.forEach(function (pair) {
        var flag = pair[0];
        var bool = pair[1];
        if (bool === undefined || bool === null) {
          return;
        }
        if (bool) {
          value |= flag;
        } else {
          value &= ~flag;
        }
      });

      this.set(key, value, fn);
    }.bind(this));
  };
}

var live = require('../../../../../libs/spotify-live');
var dom = require('domify');

// all preferences
var prefs;

/**
 * Social setting template
 */

var template = require('./template.hbs');

/**
 * Social setting model
 *
 * @api public
 */

exports.model = require('./model');

/**
 * Flags for bitwise ops to determine publish-activity product state.
 *
 * These are named in a non-idiomatic JS manner. Instead they purposefully
 * match the flags within client-core to improve code searchability.
 */
var kPublishActivityPlayedTracks = 0x1;

/**
 * Flags for bitwise ops to determine public-toplist product state.
 *
 * These are named in a non-idiomatic JS manner. Instead they purposefully
 * match the flags within client-core to improve code searchability.
 */
var kPublicToplistArtists = 0x1;
// var kPublicToplistAlbums = 0x2;
// var kPublicToplistTracks = 0x4;

/**
 * Flags for bitwise ops to determine public-toplistener product state.
 *
 * These are named in a non-idiomatic JS manner. Instead they purposefully
 * match the flags within client-core to improve code searchability.
 */
var kPublicTopListenerArtists = 0x1;

/**
 * Initializes social settings
 *
 * @api public
 * @param {Function} done
 */

exports.init = function (done) {
  if (!prefs) {
    prefs = new Preferences('*');
  }

  var model = exports.model;
  var enabled = model.get('enabled');
  var settings = document.querySelector('#social');
  var view = dom(template(model.serialize()));

  // render
  settings.appendChild(view);

  // bind click events if enabled
  if (enabled) {
    // listen for update to toggle state
    model.on('update', function () {
      // @TODO - handle updates ?
    });
  }

  // update mode when session changes
  live('spotify:client').get('session', function (err, session) {
    session.on('update', function (data) {
      if (typeof data.incognito !== 'undefined') {
        model.update({ private: data.incognito });
      }
    });
  });

  model.on('publish', function (data) {
    // @TODO - figure out what these arbitrary numbers mean
    // @cc (werle)
    var publicPlaylists = data.publicPlaylists ? 1 : 0;

    if (typeof data.private !== 'undefined') {
      prefs.set('ui.incognito_mode', data.private, function (err) {
        if (err) {
          console.error(err);
          return;
        }
        model.update({ private: data.private });
      });
    }

    if ('publish' in data) {
      prefs.setAtomicFlags('ps.publish-activity', [[kPublishActivityPlayedTracks, data.publish]], function (err) {
        if (err) {
          console.error(err);
          return;
        }
        model.update({ publish: data.publish });
      });
    }

    if ('publicTopListenerArtists' in data) {
      prefs.setAtomicFlags('ps.public-toplistener', [[kPublicTopListenerArtists, data.publicTopListenerArtists]], function (err) {
        if (err) {
          console.error(err);
          return;
        }
        model.update({
          publicTopListenerArtists: data.publicTopListenerArtists
        });
      });
    }

    if (typeof data.publicPlaylists !== 'undefined') {
      prefs.set('ps.publish-playlist', publicPlaylists, function (err) {
        if (err) {
          console.error(err);
          return;
        }
        model.update({ publicPlaylists: data.publicPlaylists });
      });
    }

    if ('publicToplist' in data) {
      prefs.setAtomicFlags('ps.public-toplist', [[kPublicToplistArtists, data.publicToplist]], function (err) {
        if (err) {
          console.error(err);
          return;
        }

        model.update({ publicToplist: data.publicToplist });
      });
    }
  });

  done();
};

/**
 * Called when native layer pushs sync
 * to application layer
 *
 * @api public
 * @param {Function} done
 */

exports.sync = function (done) {
  if (!prefs) {
    prefs = new Preferences('*');
  }

  prefs.all(function (err, res) {
    if (err) {
      done(err);
      return;
    }

    var papt = res['ps.publish-activity'] & kPublishActivityPlayedTracks;
    var ptla = res['ps.public-toplistener'] & kPublicTopListenerArtists;
    var ptl = res['ps.public-toplist'] & kPublicToplistArtists;

    // https://abtesting.spotify.net/#/features/604
    abba('creator-show-toplistener-setting', function (error, cell) {
      exports.model.update({
        private: res['ui.incognito_mode'],
        publish: Boolean(papt),
        publicTopListenerArtists: Boolean(ptla),
        publicPlaylists: res['ps.publish-playlist'] > 0,
        publicToplist: Boolean(ptl)
      });

      if (cell !== 'Show' || res['ps.public-toplistener'] === undefined) {
        exports.model.delete('publicTopListenerArtists');
      }

      done();
    });
  });
};

},{"../../../../../libs/spotify-abba-mini":142,"../../../../../libs/spotify-live":217,"../../../../../libs/spotify-preferences":243,"./model":107,"./template.hbs":108,"domify":270}],107:[function(require,module,exports){

'use strict';

/**
 * Module dependencies
 */

var live = require('../../../../../libs/spotify-live');

/**
 * Spotify social setting live model
 *
 * @api public
 */

module.exports = live({
  publicPlaylists: true,
  publish: false,
  private: false,
  enabled: true,
  publicToplist: true,
  publicTopListenerArtists: true,
  uri: 'settings:social:spotify'
});

},{"../../../../../libs/spotify-live":217}],108:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {

  var buffer = "", stack1, helper, options;
  buffer += "\n<section class=\"spotify\">\n  <div class=\"section-divider section-divider-small\">\n    <h3>"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "spotify", options) : helperMissing.call(depth0, "loc", "spotify", options)))
    + "</h3>\n  </div>\n\n  ";
  stack1 = (helper = helpers.sliderSetting || (depth0 && depth0.sliderSetting),options={hash:{},inverse:self.noop,fn:self.program(2, program2, data),data:data},helper ? helper.call(depth0, "settings:social:spotify", "publicPlaylists", options) : helperMissing.call(depth0, "sliderSetting", "settings:social:spotify", "publicPlaylists", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n  ";
  stack1 = (helper = helpers.sliderSetting || (depth0 && depth0.sliderSetting),options={hash:{},inverse:self.noop,fn:self.program(4, program4, data),data:data},helper ? helper.call(depth0, "settings:social:spotify", "private", options) : helperMissing.call(depth0, "sliderSetting", "settings:social:spotify", "private", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n  ";
  stack1 = (helper = helpers.sliderSetting || (depth0 && depth0.sliderSetting),options={hash:{},inverse:self.noop,fn:self.program(6, program6, data),data:data},helper ? helper.call(depth0, "settings:social:spotify", "publish", "incognito-state", options) : helperMissing.call(depth0, "sliderSetting", "settings:social:spotify", "publish", "incognito-state", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n  ";
  stack1 = (helper = helpers.sliderSetting || (depth0 && depth0.sliderSetting),options={hash:{},inverse:self.noop,fn:self.program(8, program8, data),data:data},helper ? helper.call(depth0, "settings:social:spotify", "publicTopListenerArtists", "incognito-state", options) : helperMissing.call(depth0, "sliderSetting", "settings:social:spotify", "publicTopListenerArtists", "incognito-state", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n  ";
  stack1 = (helper = helpers.sliderSetting || (depth0 && depth0.sliderSetting),options={hash:{},inverse:self.noop,fn:self.program(10, program10, data),data:data},helper ? helper.call(depth0, "settings:social:spotify", "publicToplist", "incognito-state", options) : helperMissing.call(depth0, "sliderSetting", "settings:social:spotify", "publicToplist", "incognito-state", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n</section>\n";
  return buffer;
  }
function program2(depth0,data) {

  var buffer = "", stack1, helper, options;
  buffer += "\n    ";
  stack1 = (helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "newPlaylistsPublic", options) : helperMissing.call(depth0, "loc", "newPlaylistsPublic", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  ";
  return buffer;
  }

function program4(depth0,data) {

  var buffer = "", stack1, helper, options;
  buffer += "\n    ";
  stack1 = (helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "privateSession", options) : helperMissing.call(depth0, "loc", "privateSession", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  ";
  return buffer;
  }

function program6(depth0,data) {

  var buffer = "", stack1, helper, options;
  buffer += "\n    ";
  stack1 = (helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "publishActivity", options) : helperMissing.call(depth0, "loc", "publishActivity", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  ";
  return buffer;
  }

function program8(depth0,data) {

  var buffer = "", stack1, helper, options;
  buffer += "\n    ";
  stack1 = (helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "publishActivityTopListener", options) : helperMissing.call(depth0, "loc", "publishActivityTopListener", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  ";
  return buffer;
  }

function program10(depth0,data) {

  var buffer = "", stack1, helper, options;
  buffer += "\n    ";
  stack1 = (helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "publishTopArtists", options) : helperMissing.call(depth0, "loc", "publishTopArtists", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  ";
  return buffer;
  }

  stack1 = helpers['if'].call(depth0, (depth0 && depth0.enabled), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n";
  return buffer;
  });

},{"hbsfy/runtime":303}],109:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {

  var buffer = "", helper, options;
  buffer += "\n<section id=\"social\">\n  <div class=\"section-divider\">\n    <h2>"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "social", options) : helperMissing.call(depth0, "loc", "social", options)))
    + "</h2>\n  </div>\n</section>\n";
  return buffer;
  }

  stack1 = helpers['if'].call(depth0, (depth0 && depth0.enabled), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n";
  return buffer;
  });

},{"hbsfy/runtime":303}],110:[function(require,module,exports){
'use strict';

/**
 * Module dependencies
 */

var Preferences = require('../../../../../libs/spotify-preferences');
var dom = require('domify');
var tpl = require('./template.hbs');
var prefs;

exports.model = require('./model');

/**
 * Initializes open spotify settings
 *
 * @api public
 * @param {Function} done
 */

exports.init = function (done) {
  if (!prefs) {
    prefs = new Preferences('app');
  }

  var settings = document.querySelector('#window-handling');
  var model = exports.model;
  var enabled = model.get('enabled');
  var view = dom(tpl(model.serialize()));

  // render
  settings.appendChild(view);

  if (enabled) {
    model.on('publish', function (data) {
      if (typeof data.mode !== 'undefined') {
        prefs.set('autostart-mode', data.mode, function (err) {
          if (err) {
            console.error(err.stack || err);
          } else {
            model.update({ mode: data.mode });
          }
        });
      }
    });
  }

  done();
};

/**
 * Sync settings from bridge
 *
 * @api public
 * @param {Function} done
 */

exports.sync = function (done) {
  if (!prefs) {
    prefs = new Preferences('app');
  }

  prefs.all(function (err, res) {
    if (err) {
      done(err);
      return;
    }

    exports.model.update({ mode: res.app['autostart-mode'] });
    done();
  });
};

},{"../../../../../libs/spotify-preferences":243,"./model":111,"./template.hbs":112,"domify":270}],111:[function(require,module,exports){

'use strict';

/**
 * Module dependencies
 */

var live = require('../../../../../libs/spotify-live');
var i18n = require('../../../lib/i18n');

/**
 * Recover playlist setting live model
 *
 * @api public
 */

var containerFeatures = live('spotify:client').get('containerFeatures');
var autostartEnabled = containerFeatures && containerFeatures.get('autostart');

module.exports = live({
  enabled: !!autostartEnabled,
  mode: null,
  uri: 'settings:auto-open',
  autostart: {
    enabled: true,
    options: {
      minimized: i18n('autostartMinimized'),
      normal: i18n('autostartNormal'),
      off: i18n('autostartOff')
    }
  }
});

},{"../../../../../libs/spotify-live":217,"../../../lib/i18n":22}],112:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helperMissing=helpers.helperMissing, self=this;

function program1(depth0,data) {

  var buffer = "", stack1;
  buffer += "\n<div id=\"auto-open\">\n  ";
  stack1 = helpers['if'].call(depth0, ((stack1 = (depth0 && depth0.autostart)),stack1 == null || stack1 === false ? stack1 : stack1.enabled), {hash:{},inverse:self.noop,fn:self.program(2, program2, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n</div>\n";
  return buffer;
  }
function program2(depth0,data) {

  var buffer = "", stack1, helper, options;
  buffer += "\n    ";
  stack1 = (helper = helpers.selectSetting || (depth0 && depth0.selectSetting),options={hash:{},inverse:self.noop,fn:self.program(3, program3, data),data:data},helper ? helper.call(depth0, "settings:auto-open", "mode", ((stack1 = (depth0 && depth0.autostart)),stack1 == null || stack1 === false ? stack1 : stack1.options), options) : helperMissing.call(depth0, "selectSetting", "settings:auto-open", "mode", ((stack1 = (depth0 && depth0.autostart)),stack1 == null || stack1 === false ? stack1 : stack1.options), options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  ";
  return buffer;
  }
function program3(depth0,data) {

  var buffer = "", stack1, helper, options;
  buffer += "\n      ";
  stack1 = (helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "autostart", options) : helperMissing.call(depth0, "loc", "autostart", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    ";
  return buffer;
  }

  stack1 = helpers['if'].call(depth0, (depth0 && depth0.enabled), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n";
  return buffer;
  });

},{"hbsfy/runtime":303}],113:[function(require,module,exports){
'use strict';

var Preferences = require('../../../../../libs/spotify-preferences');
var dom = require('domify');
var $ = require('../../../../../libs/spotify-elements');
var template = require('./template.hbs');
var prefs;

exports.model = require('./model');

/**
 * Initializes setting
 *
 * @api public
 * @param {Function} done
 */

exports.init = function (done) {
  if (!prefs) {
    prefs = new Preferences('*');
  }

  var settings = $('#window-handling');
  var model = exports.model;
  var enabled = model.get('enabled');
  var view = dom(template(model.serialize()));

  // If this feature doesn't exist on the target platform, then
  // we don't want to show it.
  if (!enabled) {
    done();
    return;
  }

  // render
  settings.appendChild(view);

  model.on('publish', function (data) {
    if ('value' in data) {
      var value = data.value;

      model.update({ value: value });
      prefs.set('ui.minimize_to_tray', value, function (err) {
        if (err) {
          console.error(err.stack || err);

          // Revert
          model.update({ value: !value });
        }
      });
    }
  });

  done();
};

/**
 * Updates settings from bridge
 *
 * @api public
 * @param {Function} done
 */

exports.sync = function (done) {
  var model = exports.model;

  if (!prefs) {
    prefs = new Preferences('*');
  }

  prefs.all(function (err, res) {
    if (err) {
      done(err);
      return;
    }

    model.update({
      value: res['ui.minimize_to_tray']
    });

    done();
  });
};

},{"../../../../../libs/spotify-elements":149,"../../../../../libs/spotify-preferences":243,"./model":114,"./template.hbs":115,"domify":270}],114:[function(require,module,exports){

'use strict';

/**
 * Module dependencies
 */

var live = require('../../../../../libs/spotify-live');

/**
 * live-ification of the model
 *
 * @api public
 */

var containerFeatures = live('spotify:client').get('containerFeatures');
var enabled = containerFeatures && containerFeatures.get('closeCanMinimizeOrExit');

module.exports = live({
  enabled: !!enabled,
  value: false,
  uri: 'settings:close-should-minimize'
});

},{"../../../../../libs/spotify-live":217}],115:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, options, helperMissing=helpers.helperMissing, self=this;

function program1(depth0,data) {

  var buffer = "", stack1, helper, options;
  buffer += "\n    ";
  stack1 = (helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "closeShouldMinimize", options) : helperMissing.call(depth0, "loc", "closeShouldMinimize", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  ";
  return buffer;
  }

  buffer += "<div id=\"close-should-minimize\">\n  ";
  stack1 = (helper = helpers.sliderSetting || (depth0 && depth0.sliderSetting),options={hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data},helper ? helper.call(depth0, "settings:close-should-minimize", "value", options) : helperMissing.call(depth0, "sliderSetting", "settings:close-should-minimize", "value", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n</div>\n";
  return buffer;
  });

},{"hbsfy/runtime":303}],116:[function(require,module,exports){
'use strict';

var Batch = require('spotify-batch');
var dom = require('domify');

var sections = [require('./auto-open'), require('./close-should-minimize'), require('./web-helper')];

var template = require('./template.hbs');

exports.model = require('./model');

/**
 * Init
 *
 * @api public
 * @param {Function} done
 */

exports.init = function (done) {
  var settings = document.querySelector('#advanced-settings');
  var model = exports.model;
  var batch = new Batch().concurrency(1);
  var view = dom(template(model.serialize()));

  // render
  settings.appendChild(view);

  sections.forEach(function (section) {
    if (typeof section.init === 'function') {
      batch.push(function (next) {
        section.init(next);
      });
    }
  });

  batch.run(done);
};

/**
 * Called when native layer pushs sync
 * to application layer
 *
 * @api public
 * @param {Function} done
 */

exports.sync = function (done) {
  var batch = new Batch().concurrency(1);
  sections.forEach(function (section) {
    if (typeof section.sync === 'function') {
      batch.push(function (next) {
        section.sync(next);
      });
    }
  });

  batch.run(done);
};

},{"./auto-open":110,"./close-should-minimize":113,"./model":117,"./template.hbs":118,"./web-helper":119,"domify":270,"spotify-batch":351}],117:[function(require,module,exports){

'use strict';

/**
 * Module dependencies
 */

var live = require('../../../../libs/spotify-live');

/**
 * Windows handling settings model
 *
 * @api public
 */

module.exports = live({
  enabled: true,
  uri: 'settings:window-handling',

  autoOpen: require('./auto-open/model')
});

},{"../../../../libs/spotify-live":217,"./auto-open/model":111}],118:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {

  var buffer = "", helper, options;
  buffer += "\n<section id=\"window-handling\">\n  <div class=\"section-divider\">\n    <h2>"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "startupAndWindowBehavior", options) : helperMissing.call(depth0, "loc", "startupAndWindowBehavior", options)))
    + "</h2>\n  </div>\n</section>\n";
  return buffer;
  }

  stack1 = helpers['if'].call(depth0, (depth0 && depth0.enabled), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n";
  return buffer;
  });

},{"hbsfy/runtime":303}],119:[function(require,module,exports){
'use strict';

var Preferences = require('../../../../../libs/spotify-preferences');
var dom = require('domify');
var tpl = require('./template.hbs');
var prefs;

exports.model = require('./model');

var WEBHELPER_ENABLED_PREF = 'webhelper.enabled';

/**
 * Initializes web helper settings
 *
 * @api public
 * @param {Function} done
 */

exports.init = function (done) {
  if (!prefs) {
    prefs = new Preferences('webhelper');
  }

  var settings = document.querySelector('#window-handling');
  var model = exports.model;
  var view = dom(tpl(model.serialize()));

  settings.appendChild(view);

  model.on('publish', function (data) {
    var value = data.webhelper;
    var oldValue = model.get('webhelper');
    model.update({ webhelper: value });
    prefs.set(WEBHELPER_ENABLED_PREF, value, function (err) {
      if (err) {
        model.update({ webhelper: oldValue });
      }
    });
  });

  done();
};

/**
 * Sync settings from bridge
 *
 * @api public
 * @param {Function} done
 */

exports.sync = function (done) {
  var model = exports.model;

  if (!prefs) {
    prefs = new Preferences('*');
  }

  prefs.all(function (err, res) {
    if (err) {
      done(err);
      return;
    }

    model.update({ webhelper: res[WEBHELPER_ENABLED_PREF] });
    done();
  });
};

},{"../../../../../libs/spotify-preferences":243,"./model":120,"./template.hbs":121,"domify":270}],120:[function(require,module,exports){
'use strict';

var live = require('../../../../../libs/spotify-live');

/**
 * Web Helper setting live model
 *
 * @api public
 */
module.exports = live({
  enabled: true,
  webhelper: true,
  uri: 'settings:web-helper'
});

},{"../../../../../libs/spotify-live":217}],121:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var stack1, helperMissing=helpers.helperMissing, self=this;

function program1(depth0,data) {

  var buffer = "", stack1, helper, options;
  buffer += "\n<div id=\"webhelper\">\n  ";
  stack1 = (helper = helpers.sliderSetting || (depth0 && depth0.sliderSetting),options={hash:{},inverse:self.noop,fn:self.program(2, program2, data),data:data},helper ? helper.call(depth0, "settings:web-helper", "webhelper", options) : helperMissing.call(depth0, "sliderSetting", "settings:web-helper", "webhelper", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n</div>\n";
  return buffer;
  }
function program2(depth0,data) {

  var buffer = "", stack1, helper, options;
  buffer += "\n    ";
  stack1 = (helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "webhelper", options) : helperMissing.call(depth0, "loc", "webhelper", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  ";
  return buffer;
  }

  stack1 = helpers['if'].call(depth0, (depth0 && depth0.enabled), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { return stack1; }
  else { return ''; }
  });

},{"hbsfy/runtime":303}],122:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
var partial$0 = require('../../../libs/spotify-glue-cat/templates/v1/select.hbs');
HandlebarsCompiler.registerPartial('../../../libs/spotify-glue-cat/templates/v1/select.hbs', partial$0);
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); partials = this.merge(partials, Handlebars.partials); data = data || {};
  var buffer = "", stack1, helper, functionType="function", escapeExpression=this.escapeExpression, self=this;


  buffer += "<div class=\"setting-row\">\n  <div class=\"col description\">";
  if (helper = helpers.description) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.description); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</div>\n  <div class=\"col action\">\n    ";
  stack1 = self.invokePartial(partials['../../../libs/spotify-glue-cat/templates/v1/select.hbs'], '../../../libs/spotify-glue-cat/templates/v1/select.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  </div>\n</div>\n";
  return buffer;
  });

},{"../../../libs/spotify-glue-cat/templates/v1/select.hbs":192,"hbsfy/runtime":303}],123:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, options, functionType="function", escapeExpression=this.escapeExpression, self=this, helperMissing=helpers.helperMissing;

function program1(depth0,data) {


  return " enabled";
  }

function program3(depth0,data) {


  return " disabled";
  }

function program5(depth0,data) {

  var buffer = "", stack1, helper;
  buffer += "data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"";
  return buffer;
  }

function program7(depth0,data) {

  var buffer = "", stack1, helper;
  buffer += "data-slider-range-property=\"";
  if (helper = helpers.property) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.property); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"";
  return buffer;
  }

function program9(depth0,data) {

  var buffer = "", stack1, helper;
  buffer += "data-slider-range-allowed-property=\"";
  if (helper = helpers.allowedProperty) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.allowedProperty); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"";
  return buffer;
  }

  buffer += "<!-- @TODO - abstract into GLUE -->\n<div\n  tabindex=\"0\"\n  role=\"slider\"\n  class=\"slider-range";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.enabled), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  stack1 = (helper = helpers.compare || (depth0 && depth0.compare),options={hash:{},inverse:self.noop,fn:self.program(3, program3, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.allowed), false, options) : helperMissing.call(depth0, "compare", (depth0 && depth0.allowed), false, options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\"\n  ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.uri), {hash:{},inverse:self.noop,fn:self.program(5, program5, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.property), {hash:{},inverse:self.noop,fn:self.program(7, program7, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.allowedProperty), {hash:{},inverse:self.noop,fn:self.program(9, program9, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += ">\n  <div class=\"container\">\n    <div class=\"progress-bar-wrapper\">\n      <div class=\"progress-bar\"><div class=\"inner\"><div class=\"handle\"></div></div></div>\n    </div>\n    <div class=\"duration\">\n      <span class=\"time\">0</span>\n      <span class=\"unit\">";
  stack1 = (helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "sec", options) : helperMissing.call(depth0, "loc", "sec", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "</span>\n    </div>\n  </div>\n</div>\n";
  return buffer;
  });

},{"hbsfy/runtime":303}],124:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
var partial$0 = require('../../../libs/spotify-glue-cat/templates/v1/slider.hbs');
HandlebarsCompiler.registerPartial('../../../libs/spotify-glue-cat/templates/v1/slider.hbs', partial$0);
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); partials = this.merge(partials, Handlebars.partials); data = data || {};
  var buffer = "", stack1, helper, functionType="function", escapeExpression=this.escapeExpression, self=this;


  buffer += "<div class=\"setting-row ";
  if (helper = helpers.containerClassName) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.containerClassName); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-row-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\">\n  <div class=\"col description\">";
  if (helper = helpers.description) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.description); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "</div>\n  <div class=\"col action\">\n    ";
  stack1 = self.invokePartial(partials['../../../libs/spotify-glue-cat/templates/v1/slider.hbs'], '../../../libs/spotify-glue-cat/templates/v1/slider.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  </div>\n</div>\n";
  return buffer;
  });

},{"../../../libs/spotify-glue-cat/templates/v1/slider.hbs":193,"hbsfy/runtime":303}],125:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", helper, options, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;


  buffer += "<p class=\"text-center\">\n  <button id=\"logout\" class=\"button button-with-stroke\">"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "logOut", options) : helperMissing.call(depth0, "loc", "logOut", options)))
    + "</button>\n</p>\n<p class=\"text-center\">\n  <a href=\"spotify:app:about\">"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "aboutSpotify", options) : helperMissing.call(depth0, "loc", "aboutSpotify", options)))
    + "</a>\n</p>\n";
  return buffer;
  });

},{"hbsfy/runtime":303}],126:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
var partial$0 = require('../../../libs/spotify-glue-cat/templates/v1/media-image-no-link.hbs');
HandlebarsCompiler.registerPartial('../../../libs/spotify-glue-cat/templates/v1/media-image-no-link.hbs', partial$0);
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); partials = this.merge(partials, Handlebars.partials); data = data || {};
  var buffer = "", stack1, helper, options, self=this, functionType="function", escapeExpression=this.escapeExpression, helperMissing=helpers.helperMissing;

function program1(depth0,data) {

  var stack1;
  stack1 = self.invokePartial(partials['../../../libs/spotify-glue-cat/templates/v1/media-image-no-link.hbs'], '../../../libs/spotify-glue-cat/templates/v1/media-image-no-link.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { return stack1; }
  else { return ''; }
  }

  buffer += "<div class=\"avatar\">\n    ";
  stack1 = helpers['with'].call(depth0, (depth0 && depth0.user), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n</div>\n\n<h1 class=\"text-center\" id=\"username\">"
    + escapeExpression(((stack1 = ((stack1 = (depth0 && depth0.user)),stack1 == null || stack1 === false ? stack1 : stack1.name)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "</h1>\n<p class=\"text-center text-meta\" id=\"accountTypeName\">"
    + escapeExpression(((stack1 = ((stack1 = (depth0 && depth0.account)),stack1 == null || stack1 === false ? stack1 : stack1.typeName)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "</p>\n<p class=\"text-center button-container\">\n  <button id=\"upgradeAccount\" class=\"button button-green\">"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "upgrade", options) : helperMissing.call(depth0, "loc", "upgrade", options)))
    + "</button>\n  <button id=\"viewAccount\" class=\"button button-with-stroke\">"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "viewAccount", options) : helperMissing.call(depth0, "loc", "viewAccount", options)))
    + "</button>\n</p>\n";
  return buffer;
  });

},{"../../../libs/spotify-glue-cat/templates/v1/media-image-no-link.hbs":190,"hbsfy/runtime":303}],127:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, options, self=this, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;

function program1(depth0,data) {


  return " class=\"hidden\" ";
  }

  buffer += "<div id=\"basic-settings\"></div>\n<div id=\"advanced-settings\" ";
  stack1 = helpers.unless.call(depth0, (depth0 && depth0.advancedSettings), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += ">\n</div>\n\n<p class=\"text-center\">\n  <button id=\"showAdvancedSettings\" type=\"button\" class=\"button button-with-stroke\">\n    <span>"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "showAdvancedSettings", options) : helperMissing.call(depth0, "loc", "showAdvancedSettings", options)))
    + "</span>\n  </button>\n  <button id=\"hideAdvancedSettings\" type=\"button\" class=\"button button-with-stroke hidden\">\n    <span>"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "hideAdvancedSettings", options) : helperMissing.call(depth0, "loc", "hideAdvancedSettings", options)))
    + "</span>\n  </button>\n</p>\n";
  return buffer;
  });

},{"hbsfy/runtime":303}],128:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", helper, options, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;


  buffer += "<p class=\"text-center\">\n  <button id=\"login\" class=\"button button-with-stroke\">"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "backToLogin", options) : helperMissing.call(depth0, "loc", "backToLogin", options)))
    + "</button>\n</p>\n";
  return buffer;
  });

},{"hbsfy/runtime":303}],129:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, functionType="function", escapeExpression=this.escapeExpression;


  buffer += "<h2 id=\"prelogin-title\">";
  if (helper = helpers.title) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.title); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</h2>\n<div id=\"basic-settings\"></div>\n";
  return buffer;
  });

},{"hbsfy/runtime":303}],130:[function(require,module,exports){
module.exports={
  "apps": {
    "app-manager": {},
    "diag": {},
    "glue-reference": {},
    "latest-releases": {},
    "lyrics": {},
    "message-visualization": {},
    "video-debug": {},
    "trufflepig": {
      "url": "http://d1hza3lyffsoht.cloudfront.net/329ccb292048f4a08cea7b1a3191652d9a12c71f",
      "revision": "cfd8b1c"
    },
    "radio-view": {
      "url": "https://artifactory.spotify.net/artifactory/client-infrastructure/client-zelda-js/external-apps/radio-view/0.1.8/radio-view.0.1.8.master.24b5317.spa"
    },
    "flusterradio": {
      "url": "https://artifactory.spotify.net/artifactory/client-infrastructure/client-zelda-js/external-apps/flusterradio/0.2.5/flusterradio.0.2.5.master.9decd99.spa"
    },
    "prosecco-player": {
      "url": "https://artifactory.spotify.net/artifactory/client-infrastructure/client-zelda-js/external-apps/prosecco-player/0.2.0/prosecco-player.0.2.0.master.f8a3854.spa",
      "revision": "f8a3854"
    }
  }
}

},{}],131:[function(require,module,exports){
(function (global){
'use strict';

var requests = require('./requests/requests.js');
var Session = require('../../bfs-km-session').Session;
var types = require('bfs-km-types');
var proxyConfiguration = require('./proxyConfiguration');

var CATALOGUE = 'catalogue';
var COUNTRY = 'country';
var GET = 'GET';
var LOCALE = 'locale';
var PLATFORM = 'platform';
var USERNAME = 'username';

/**
 * Constructs a new context.
 */
var Context = function Context(session, live) {
  types.check.type(session, Session);

  this.id = 0;
  this.session = session;
  this.proxyConfig = proxyConfiguration.getConfiguration(live);
};

/**
 * Static method that creates a new context with the default dependencies.
 */
Context.create = function (session, live) {
  types.check.type(session, Session);

  return new Context(session, live);
};

/**
 * Static method that creates a mock context which responds with the given
 * serialized json response for all requests.
 */
Context.createMockThatRespondsWith = function (response) {
  var Mock;

  types.check.string(response);

  Mock = types.mock(Context);

  Mock.prototype.resolve = function (uri, caller, success, failure) {
    var json;

    types.check.string(uri);
    types.check.type(caller, global.Object);
    types.check.function(success);
    types.check.function(failure);

    try {
      json = global.JSON.parse(response);
    } catch (error) {
      failure.call(caller, error);

      return;
    }

    success.call(caller, json);
  };

  return new Mock(Session.createMock());
};

/**
 * Clones the context instance.
 */
Context.prototype.clone = function () {
  var that;

  that = new this.constructor(this.session);

  return that;
};

/**
 * Helper method that creates a new hub request.
 */
Context.prototype.newHubRequest = function () {
  return requests.Hub.create();
};

/**
 * Helper method that creates a new search request.
 */
Context.prototype.newSearchRequest = function () {
  return requests.Search.create();
};

/**
 * Resolve the given uri based on the proxy configuration.
 */
Context.prototype.resolve = function (uri, caller, success, failure) {
  this.proxyConfig.then(function (proxy) {
    if (proxy.enabled) {
      this._localhostRequest(uri, proxy, success, failure, caller);
      return;
    }

    this._cosmosRequest(uri, caller, success, failure);
  }.bind(this));
};

/**
 * Resolves the given uri using the cosmos resolver and calls the succes
 * callback or the failure callback depending on whether the request was
 * successful or not.
 */
Context.prototype._cosmosRequest = function (uri, caller, success, failure) {
  var cosmos;
  var id;
  var callback;

  cosmos = require('spotify-cosmos-api');

  types.check.string(uri);
  types.check.type(caller, global.Object);
  types.check.function(success);
  types.check.function(failure);

  id = ++this.id;

  callback = function callback(error, response) {
    var json;

    if (id === this.id) {
      if (types.is.type(error, global.Error)) {
        failure.call(caller, error);
      } else {
        json = response.getJSONBody();

        if (types.is.object(json)) {
          success.call(caller, json);
        } else {
          failure.call(caller, new global.Error('Received malformed json!'));
        }
      }
    }
  };

  callback = callback.bind(this);

  cosmos.resolver.resolve(new cosmos.Request(GET, uri), callback);
};

/**
 * Make a request to the proxy running locally.
 */
Context.prototype._localhostRequest = function (uri, proxy, success, failure, caller) {
  types.check.string(uri);
  types.check.type(caller, global.Object);
  types.check.function(success);
  types.check.function(failure);

  var id = ++this.id;
  var httpUri = uri.replace(/^hm:\/\//, proxy.host + ':' + proxy.port + '/');
  var xhr = new XMLHttpRequest();

  xhr.onreadystatechange = function () {
    if (id !== this.id || xhr.readyState !== 4) {
      return;
    }

    var json = null;
    if (xhr.status === 200) {
      try {
        json = JSON.parse(xhr.response);
      } catch (error) {
        failure.call(caller, error);
      }
    }

    if (types.is.object(json)) {
      success.call(caller, json);
    } else {
      failure.call(caller, new global.Error('Received malformed json!'));
    }
  }.bind(this);

  xhr.open('GET', httpUri, true);
  xhr.setRequestHeader('x-spotify-catalogue', proxy.catalogue);
  xhr.setRequestHeader('x-spotify-country', proxy.country);
  xhr.setRequestHeader('x-spotify-employee', String(proxy.employee));
  xhr.setRequestHeader('x-spotify-username', proxy.username);
  xhr.send();
};

/**
 * Sends a request to the given uri. If the request fails, the given failure
 * callback is called with the Error as its argument. If the request succeeds,
 * the given success callback is called with the json response as its argument.
 * No context parameters are appended to the uri.
 */
Context.prototype.send = function (uri, caller, success, failure) {
  types.check.string(uri);
  types.check.type(caller, global.Object);
  types.check.function(success);
  types.check.function(failure);

  this.resolve(uri, caller, success, failure);
};

/**
 * Sends a request to the uri of the given request. If the request fails, the
 * given failure callback is called with the Error as its argument. If the
 * request succeeds, the given success callback is called with the json response
 * as its argument. All context parameters are appended to the uri.
 */
Context.prototype.sendRequest = function (request, caller, success, failure) {
  var cloned;
  var uri;

  types.check.type(request, requests.Request);
  types.check.type(caller, global.Object);
  types.check.function(success);
  types.check.function(failure);

  cloned = request.clone();

  cloned.setParameter(CATALOGUE, this.session.getCatalogue());
  cloned.setParameter(COUNTRY, this.session.getCountry());
  cloned.setParameter(LOCALE, this.session.getLocale());
  cloned.setParameter(PLATFORM, this.session.getPlatform());
  cloned.setParameter(USERNAME, this.session.getUsername());

  uri = cloned.toUri();

  this.resolve(uri, caller, success, failure);
};

module.exports = Context;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../bfs-km-session":140,"./proxyConfiguration":133,"./requests/requests.js":138,"bfs-km-types":257,"spotify-cosmos-api":357}],132:[function(require,module,exports){
'use strict';

exports.Context = require('./Context.js');
exports.requests = require('./requests/requests.js');
exports.proxyConfiguration = require('./proxyConfiguration');

},{"./Context.js":131,"./proxyConfiguration":133,"./requests/requests.js":138}],133:[function(require,module,exports){
'use strict';

var proxyConfigurationState = require('./proxyConfigurationState');

var STORAGE_NAMESPACE = 'search-proxy';
var STORAGE_FIELDS = ['enabled', 'host', 'port', 'catalogue', 'username', 'country', 'employee'];
var STORAGE_FIELDS_WITH_NAMESPACE = STORAGE_FIELDS.map(formatStorageKey);

var DEFAULT_CONFIGURATION = {
  enabled: false,
  host: 'http://localhost',
  port: '8081',
  catalogue: 'free',
  username: null,
  country: null,
  employee: false
};

exports = module.exports = function (live) {
  return {
    getConfiguration: getConfiguration.bind(null, live),
    getDefaultConfiguration: getDefaultConfiguration,
    getUserData: getUserData.bind(null, live),
    getAllPreferences: getAllPreferences.bind(null, live),
    updatePreferences: updatePreferences.bind(null, live)
  };
};

/**
 * Get the proxy configuration based on user data & preferences.
 */
exports.getConfiguration = getConfiguration;

function getConfiguration(live) {
  return Promise.all([getDefaultConfiguration(), getUserData(live), getAllPreferences(live)]).then(function (data) {
    var defaultConfiguration = data[0];
    var userData = data[1];
    var preferences = data[2];

    return proxyConfigurationState(defaultConfiguration, userData, preferences);
  });
}

/**
 * Get the default configuration used by searchview.
 */
exports.getDefaultConfiguration = getDefaultConfiguration;

function getDefaultConfiguration() {
  return Promise.resolve(DEFAULT_CONFIGURATION);
}

/**
 * Get user data from live model.
 */
exports.getUserData = getUserData;

function getUserData(live) {
  return new Promise(function (resolve, reject) {
    live('spotify:client').query('currentUser(username), session(country)', function (err, data) {
      if (err) {
        reject(err);
        return;
      }

      resolve({
        username: data.currentUser.username,
        country: data.session.country,
        catalogue: window.__spotify.product_state.catalogue
      });
    });
  });
}

/**
 * Get all user's proxy preferences defined in the settings page.
 */
exports.getAllPreferences = getAllPreferences;

function getAllPreferences(live) {
  return new Promise(function (resolve, reject) {
    live('spotify:client-storage').get(STORAGE_FIELDS_WITH_NAMESPACE, function (err, storageData) {
      if (err) {
        reject(err);
        return;
      }

      // Map `storageData` with `STORAGE_FIELDS`.
      // It uses `STORAGE_FIELDS` values as keys and `storageData` as values.
      var result = STORAGE_FIELDS.reduce(function (acc, key, index) {
        var value = storageData[index];

        if (value === 'true') {
          value = true;
        } else if (value === 'false') {
          value = false;
        }

        acc[key] = value;
        return acc;
      }, {});

      resolve(result);
    });
  });
}

/**
 * Update the given keys.
 */
exports.updatePreferences = updatePreferences;

function updatePreferences(live, data) {
  // Preprend the storage namespace to the keys.
  var storageData = Object.keys(data).reduce(function (acc, key) {
    acc[formatStorageKey(key)] = data[key];
    return acc;
  }, {});

  live('spotify:client-storage').publish(storageData);

  return Promise.resolve();
}

/**
 * Format a key using the storage namespace.
 */
function formatStorageKey(key) {
  return STORAGE_NAMESPACE + ':' + key;
}

},{"./proxyConfigurationState":134}],134:[function(require,module,exports){
'use strict';

exports = module.exports = proxyConfigurationState;

/**
 * Merge DEFAULT_STATE, userData and preferences into one object.
 * @public
 */
function proxyConfigurationState(defaultState, userData, preferences) {
  var filterUserData = excludeEmptyProperties(userData);
  var filterPreferences = excludeEmptyProperties(preferences);

  var state = Object.assign({}, defaultState, filterUserData, filterPreferences);

  return state;
}

/**
 * Exclude properties that are considered as "empty".
 * @private
 */
function excludeEmptyProperties(data) {
  if (!data) {
    return {};
  }

  var res = Object.keys(data).reduce(function (acc, key) {
    var value = data[key];

    // Exclude if the property is not defined or an emtpy string.
    if (value === undefined || value === null || value === '') {
      return acc;
    }

    acc[key] = value;

    return acc;
  }, {});

  return res;
}

},{}],135:[function(require,module,exports){
(function (global){
'use strict';

var Request = require('./Request.js');
var types = require('bfs-km-types');

var BASE_URI = 'hm://hubview/km/';
var EMPTY = '';
var HUB = 'hub';
var SUB_HUB = 'sub-hub';
var SUB_SUB_HUB = 'sub-sub-hub';
var SYMBOL_FORWARD_SLASH = '/';
var VERSION = 'version';

/**
 * Constructs a new hub request.
 */
var Hub = function Hub() {
  Request.call(this);

  this.storage[HUB] = EMPTY;
  this.storage[SUB_HUB] = EMPTY;
  this.storage[SUB_SUB_HUB] = EMPTY;
  this.storage[VERSION] = EMPTY;
};

types.extend(Hub, Request);

/**
 * Static method that creates a new request.
 */
Hub.create = function () {
  return new Hub();
};

/**
 * Static method that creates a mock request.
 */
Hub.createMock = function () {
  var Mock;

  Mock = types.mock(Hub);

  return new Mock();
};

/**
 * Clones the request instance.
 */
Hub.prototype.clone = function () {
  var that;

  that = new this.constructor();

  that.storage = types.clone(this.storage);

  return that;
};

/**
 * Gets the base uri for the request.
 */
Hub.prototype.getBaseUri = function () {
  var uri;

  uri = EMPTY;

  uri += BASE_URI;
  uri += global.encodeURIComponent(this.storage[VERSION]);
  uri += SYMBOL_FORWARD_SLASH;
  uri += global.encodeURIComponent(this.storage[HUB]);

  if (this.storage[SUB_HUB] === '') {
    return uri;
  }

  uri += SYMBOL_FORWARD_SLASH;
  uri += global.encodeURIComponent(this.storage[SUB_HUB]);

  if (this.storage[SUB_SUB_HUB] === '') {
    return uri;
  }

  uri += SYMBOL_FORWARD_SLASH;
  uri += global.encodeURIComponent(this.storage[SUB_SUB_HUB]);

  return uri;
};

/**
 * Gets the hub.
 */
Hub.prototype.getHub = function () {
  return this.storage[HUB];
};

/**
 * Gets the sub hub.
 */
Hub.prototype.getSubHub = function () {
  return this.storage[SUB_HUB];
};

/**
 * Gets the sub sub hub.
 */
Hub.prototype.getSubSubHub = function () {
  return this.storage[SUB_SUB_HUB];
};

/**
 * Gets the version.
 */
Hub.prototype.getVersion = function () {
  return this.storage[VERSION];
};

/**
 * Sets the hub.
 */
Hub.prototype.setHub = function (hub) {
  types.check.string(hub);

  this.storage[HUB] = hub;

  return this;
};

/**
 * Sets the sub hub.
 */
Hub.prototype.setSubHub = function (subHub) {
  types.check.string(subHub);

  this.storage[SUB_HUB] = subHub;

  return this;
};

/**
 * Sets the sub sub hub.
 */
Hub.prototype.setSubSubHub = function (subSubHub) {
  types.check.string(subSubHub);

  this.storage[SUB_SUB_HUB] = subSubHub;

  return this;
};

/**
 * Sets the version.
 */
Hub.prototype.setVersion = function (version) {
  types.check.string(version);

  this.storage[VERSION] = version;

  return this;
};

module.exports = Hub;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./Request.js":136,"bfs-km-types":257}],136:[function(require,module,exports){
(function (global){
'use strict';

var types = require('bfs-km-types');

var EMPTY = '';
var PARAMETERS = 'parameters';
var SYMBOL_AMPERSAND = '&';
var SYMBOL_EQUALITY_SIGN = '=';
var SYMBOL_QUESTION_MARK = '?';

/**
 * Constructs a new request.
 */
var Request = function Request() {
  this.storage = {};

  this.storage[PARAMETERS] = {};
};

types.define(Request);

/**
 * Clones the request instance.
 */
Request.prototype.clone = function () {
  throw new global.Error('Abstract method!');
};

/**
 * Gets the base uri for the request.
 */
Request.prototype.getBaseUri = function () {
  throw new global.Error('Abstract method!');
};

/**
 * Gets the parameter with the given key. Returns null if the parameter with the
 * given key is unset.
 */
Request.prototype.getParameter = function (key) {
  types.check.string(key);

  return types.fallback.string(this.storage[PARAMETERS][key], null);
};

/**
 * Sets the parameter with the given key to the given value. Note that the value
 * must be a string.
 */
Request.prototype.setParameter = function (key, value) {
  types.check.string(key);
  types.check.string(value);

  this.storage[PARAMETERS][key] = value;

  return this;
};

/**
 * Sets all parameters defined by the given object. Note that all values must be
 * strings.
 */
Request.prototype.setParameters = function (object) {
  types.check.object(object);

  Object.keys(object).forEach(function (key) {
    this.setParameter(key, object[key]);
  }.bind(this));

  return this;
};

/**
 * Converts the request to a uri.
 */
Request.prototype.toUri = function () {
  var query;
  var uri;

  uri = this.getBaseUri();

  query = EMPTY;

  Object.keys(this.storage[PARAMETERS]).forEach(function (key) {
    query += query.length === 0 ? SYMBOL_QUESTION_MARK : SYMBOL_AMPERSAND;
    query += global.encodeURIComponent(key);
    query += SYMBOL_EQUALITY_SIGN;
    query += global.encodeURIComponent(this.storage[PARAMETERS][key]);
  }.bind(this));

  uri += query;

  return uri;
};

module.exports = Request;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"bfs-km-types":257}],137:[function(require,module,exports){
(function (global){
'use strict';

var Request = require('./Request.js');
var types = require('bfs-km-types');

var BASE_URI = 'hm://searchview/km/';
var EMPTY = '';
var ENDPOINT = 'endpoint';
var QUERY = 'query';
var SYMBOL_FORWARD_SLASH = '/';
var VERSION = 'version';

/**
 * Constructs a new search request.
 */
var Search = function Search() {
  Request.call(this);

  this.storage[ENDPOINT] = EMPTY;
  this.storage[QUERY] = EMPTY;
  this.storage[VERSION] = EMPTY;
};

types.extend(Search, Request);

/**
 * Static method that creates a new request.
 */
Search.create = function () {
  return new Search();
};

/**
 * Static method that creates a mock request.
 */
Search.createMock = function () {
  var Mock;

  Mock = types.mock(Search);

  return new Mock();
};

/**
 * Clones the request instance.
 */
Search.prototype.clone = function () {
  var that;

  that = new this.constructor();

  that.storage = types.clone(this.storage);

  return that;
};

/**
 * Gets the base uri for the request.
 */
Search.prototype.getBaseUri = function () {
  var uri;

  uri = EMPTY;

  uri += BASE_URI;
  uri += global.encodeURIComponent(this.storage[VERSION]);
  uri += SYMBOL_FORWARD_SLASH;
  uri += global.encodeURIComponent(this.storage[ENDPOINT]);
  uri += SYMBOL_FORWARD_SLASH;
  uri += global.encodeURIComponent(this.storage[QUERY]);

  return uri;
};

/**
 * Gets the endpoint.
 */
Search.prototype.getEndpoint = function () {
  return this.storage[ENDPOINT];
};

/**
 * Gets the query.
 */
Search.prototype.getQuery = function () {
  return this.storage[QUERY];
};

/**
 * Gets the version.
 */
Search.prototype.getVersion = function () {
  return this.storage[VERSION];
};

/**
 * Sets the endpoint.
 */
Search.prototype.setEndpoint = function (endpoint) {
  types.check.string(endpoint);

  this.storage[ENDPOINT] = endpoint;

  return this;
};

/**
 * Sets the query.
 */
Search.prototype.setQuery = function (query) {
  types.check.string(query);

  this.storage[QUERY] = query;

  return this;
};

/**
 * Sets the version.
 */
Search.prototype.setVersion = function (version) {
  types.check.string(version);

  this.storage[VERSION] = version;

  return this;
};

module.exports = Search;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./Request.js":136,"bfs-km-types":257}],138:[function(require,module,exports){
'use strict';

exports.Hub = require('./Hub.js');
exports.Request = require('./Request.js');
exports.Search = require('./Search.js');

},{"./Hub.js":135,"./Request.js":136,"./Search.js":137}],139:[function(require,module,exports){
'use strict';

var types = require('bfs-km-types');

var platform = require('./platform.js');

/**
 * Constructs a new session.
 */
var Session = function Session() {
  this.storage = {
    catalogue: '',
    country: '',
    incognito: false,
    locale: '',
    online: true,
    platform: platform,
    username: ''
  };

  this.listen();
};

/**
 * A static method that creates a mock session.
 */
Session.createMock = function () {
  var Mock;

  Mock = types.mock(Session);

  Mock.prototype.listen = function () {};

  return new Mock();
};

/**
 * Gets the catalogue.
 */
Session.prototype.getCatalogue = function () {
  return this.storage.catalogue;
};

/**
 * Gets the country.
 */
Session.prototype.getCountry = function () {
  return this.storage.country;
};

/**
 * Gets the incognito flag.
 */
Session.prototype.getIncognito = function () {
  return this.storage.incognito;
};

/**
 * Gets the locale.
 */
Session.prototype.getLocale = function () {
  return this.storage.locale;
};

/**
 * Gets the online flag.
 */
Session.prototype.getOnline = function () {
  return this.storage.online;
};

/**
 * Gets the platform.
 */
Session.prototype.getPlatform = function () {
  return this.storage.platform;
};

/**
 * Gets the username.
 */
Session.prototype.getUsername = function () {
  return this.storage.username;
};

/**
 * A method that makes the session listen for state changes from the client.
 */
Session.prototype.listen = function () {
  var live;
  var client;
  var query;

  live = require('../../spotify-live');
  client = live('spotify:client');

  if (platform === 'web') {
    query = 'currentUser(username), session(catalogue, country, incognito, language, online)';
  } else {
    query = 'currentUser(username), session(country, incognito, language, online)';
  }

  client.query(query, function (error, json) {
    if (types.conforms(json, { currentUser: {} })) {
      this.parseCurrentUser(json.currentUser);
    }

    client.get('currentUser').on('update', function (data) {
      this.parseCurrentUser(data);
    }.bind(this));

    if (types.conforms(json, { session: {} })) {
      this.parseSession(json.session);
    }

    client.get('session').on('update', function (data) {
      this.parseSession(data);
    }.bind(this));
  }.bind(this));
};

/**
 * Parses the currentUser data.
 */
Session.prototype.parseCurrentUser = function (json) {
  if (types.conforms(json, { username: '' })) {
    this.storage.username = json.username;
  }
};

/**
 * Parses the session data.
 */
Session.prototype.parseSession = function (json) {
  if (types.conforms(json, { catalogue: '' })) {
    this.storage.catalogue = json.catalogue;
  }

  if (types.conforms(json, { country: '' })) {
    this.storage.country = json.country;
  }

  if (types.conforms(json, { incognito: false })) {
    this.storage.incognito = json.incognito;
  }

  if (types.conforms(json, { language: '' })) {
    this.storage.locale = json.language;
  }

  if (types.conforms(json, { online: false })) {
    this.storage.online = json.online;
  }
};

module.exports = Session;

},{"../../spotify-live":217,"./platform.js":141,"bfs-km-types":257}],140:[function(require,module,exports){
'use strict';

exports.Session = require('./Session.js');

},{"./Session.js":139}],141:[function(require,module,exports){
(function (global){
'use strict';

var types = require('bfs-km-types');

var platform = function platform() {
  if (types.is.function(global._getSpotifyModule)) {
    if (types.is.object(global.__spotify)) {
      return 'zelda';
    }
    return 'desktop';
  }
  return 'web';
};

module.exports = platform();

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"bfs-km-types":257}],142:[function(require,module,exports){
(function (global){
'use strict';

var cosmos = require('spotify-cosmos-api');

var abba = function abba(flag, callback) {
  cosmos.resolver.post({
    url: 'sp://abba/v1/flags',
    body: {
      flags: [flag]
    }
  }, function (err, response) {
    if (global.__spotify.abba_overrides && flag in global.__spotify.abba_overrides) {
      callback(null, global.__spotify.abba_overrides[flag]);
      return;
    }

    if (err) {
      callback(err, null);
      return;
    }
    var body = response.getJSONBody();
    var flags = body && body.flags || [];
    var featureFlagCell = flags[0] && flags[0].featureName === flag && flags[0].cell;
    callback(null, featureFlagCell || null);
  });
};
module.exports = abba;
// Also expose as an easily stubbable property.
abba.get = abba;

abba.subscribe = function (flag, callback) {
  var oldValue;

  var update = function update(newValue) {
    // ABBA might pub even though the value we're after haven't actually
    // changed, so must make sure that the flag we're tracking actually
    // changed value.
    if (newValue !== oldValue) {
      oldValue = newValue;
      callback(null, newValue);
    }
  };

  var cosmosSubscription = cosmos.resolver.subscribe({
    url: 'sp://abba/v1/flags',
    body: {
      flags: [flag]
    }
  }, function (subscribeError) {
    if (subscribeError) {
      callback(subscribeError);
      return;
    }

    abba.get(flag, function (err, newValue) {
      if (err) {
        callback(err);
        return;
      }
      update(newValue);
    });
  });

  var subscription = {
    cancel: function cancel() {
      if (cosmosSubscription) cosmosSubscription.cancel();
      var index = abba._subscriptions[flag].indexOf(subscription);
      if (index !== -1) {
        abba._subscriptions[flag].splice(index, 1);
      }
      subscription = cosmosSubscription = null;
    },
    _update: update
  };

  if (!(flag in abba._subscriptions)) abba._subscriptions[flag] = [];
  abba._subscriptions[flag].push(subscription);

  return subscription;
};

abba._subscriptions = {};

abba.override = function (flag, value) {
  if (!('abba_overrides' in global.__spotify)) global.__spotify.abba_overrides = {};
  global.__spotify.abba_overrides[flag] = value;

  (abba._subscriptions[flag] || []).forEach(function (subscription) {
    subscription._update(value);
  });
  console.warn('[abba.override]', 'Keep in mind that this is not persistent and only updates existing `abba.subscribe`s and subsequent `abba.get`s');
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"spotify-cosmos-api":357}],143:[function(require,module,exports){
'use strict';

// Base function that doesn't have any dependencies on it's own. Expects to get
// state (a plain, empty object) injected in addition to a bridge request
// function.
function cosmosRequest(state, bridge, opts, callback) {

  if (typeof opts.uri !== 'string') throw new Error('Expected uri to be string.');

  if (COSMOS_VERBS.indexOf(opts.method) === -1) throw new Error('Method must match valid verb in uppercase (GET, POST etc)');

  if (opts.body && typeof opts.body !== 'string') throw new Error('If body is provided it should be a string.');

  if (opts.headers && Object.prototype.toString.call(opts.headers) !== '[object Object]') throw new Error('Expected headers be a plain object.');

  var cosmosOptions = {
    action: opts.method,
    uri: opts.uri
  };
  if (opts.body) cosmosOptions.body = opts.body;
  if (opts.headers) cosmosOptions.headers = opts.headers;

  /* Cosmos requires each request to have a unique ID. Ideally, this would be
  uuids, but unfortunately, it is integers. This means that in apps that for
  some reason need to use spotify-cosmos-api, there would between the two
  counters if cosmosRequest started from 0. To make it safe for the two
  implemenations to co-exist if needed, we begin counting at
  significantly higher number: */
  state.requestIDCounter = state.requestIDCounter || TEN_PER_SECOND_FOR_A_YEAR;
  state.requestIDCounter++;

  var requestArguments = [state.requestIDCounter, cosmosOptions];

  var isCanceled = false;
  var stateRequestIDCounter = state.requestIDCounter;

  function cancelFunction() {
    isCanceled = true;
    bridge('cosmos_request_cancel', [stateRequestIDCounter]);
  }

  // run is a recursive function that does a bridge request and then keeps
  // pulling values after every response in the case of a subscription. In
  // case we are not subscribing, or the cancelFunction has been called,
  // run sends cosmos_request_cancel and terminates.
  function run(isFirst, requestIDCounter) {
    var messageName = isFirst ? 'cosmos_request_create' : 'cosmos_request_pull';
    bridge(messageName, requestArguments, function (error, responseString) {
      // The request to cancel may not have gotten to the bridge
      // before the original request got resolved,
      // so make sure not to continue if we detect it's been canceled.
      if (isCanceled) {
        return;
      }
      try {
        if (callback) {
          if (error) {
            callback(error);
          } else {
            callback(null, responseString);
          }
        }
      } finally {
        if (opts.method !== 'SUB') {
          // If the request was a non-SUB, tell core to clean up the request.
          // NOTE: Not sure if this is strictly necessary,
          // have not been to investigate in C++-land, so for now
          // we are just mimicing the behavior of spotify-cosmos-api.
          bridge('cosmos_request_cancel', [requestIDCounter]);
        } else if (!isCanceled) {
          // maybe canceled in above callback
          run(false, requestIDCounter);
        }
      }
    });
  }

  run(true, stateRequestIDCounter);

  return cancelFunction;
}

var TEN_PER_SECOND_FOR_A_YEAR = 10 * 60 * 60 * 24 * 365;

var COSMOS_VERBS = ['GET', 'HEAD', 'POST', 'PUT', 'SUB', 'PATCH', 'DELETE'];

module.exports = cosmosRequest;

},{}],144:[function(require,module,exports){
(function (global){
'use strict';

var debug = require('debug')('spotify-bridge-request');
var defer = require('spotify-deferred');

var cosmosBaseFunction = require('./cosmos');

// NOTE: Implicit global state.
var scheduledCoreFlush = false;
var cosmosState = null;

exports.cosmos = cosmos;
exports.cosmosJSON = cosmosJSON;
exports.request = request;
exports._request = _request;

function cosmos() {
  if (!cosmosState) cosmosState = {};

  var baseArguments = [cosmosState, request];
  var cancelFunction = cosmosBaseFunction.apply(null, baseArguments.concat(Array.prototype.slice.call(arguments)));
  return cancelFunction;
}

function _createCallbackWrapper(callback) {
  return function callbackWrapper(err, response) {
    if (!err) {
      var parsedResponse;
      try {
        parsedResponse = JSON.parse(response.body);
      } catch (e) {
        e.message = 'Failed to parse cosmos response: ' + e.message;
        callback(e);
        return;
      }
      callback(null, parsedResponse);
    } else {
      callback(err, response);
    }
  };
}

function cosmosJSON(opts, callback) {
  if (opts.body) {
    opts.body = JSON.stringify(opts.body);
  }
  var callbackWrapper = callback ? _createCallbackWrapper(callback) : null;
  var cancelFunction = cosmos(opts, callbackWrapper);
  return cancelFunction;
}

function request(name, opt_args, opt_callback) {
  var args = opt_args || [];
  var callback = getCallback(name, args, opt_callback);

  debug('req:' + name, args);

  exports._request(name, args, callback);

  if (name !== 'core_flush' && !scheduledCoreFlush) {
    scheduledCoreFlush = true;
    defer(flushCore);
  }

  return exports;
}

function _request(name, args, callback) {
  global._getSpotifyModule('bridge').executeRequest(JSON.stringify({
    name: name,
    args: args
  }), {
    onSuccess: getSuccessHandler(callback),
    onFailure: getFailureHandler(callback, name, args)
  });
}

function getCallback(name, args, opt_userCallback) {
  var userCallback = opt_userCallback || function () {};

  return function (error, data) {
    if (error) {
      if (error.name === 'timeout') {
        // Set the delay between 300ms and 400ms
        var delay = 300 + Math.floor(Math.random() * 100);

        debug('timeout', error.message);

        // Retry the request
        setTimeout(function () {
          request(name, args, userCallback);
        }, delay);
        return;
      }
    }

    debug('res:' + name, args, data);

    userCallback(error, data);
  };
}

function getSuccessHandler(requestCallback) {
  return function (data) {
    var parsed;

    debug('success', data);

    try {
      parsed = JSON.parse(data);
    } catch (error) {
      requestCallback(error);
    }

    if (parsed) {
      requestCallback(null, parsed);
    }
  };
}

function getFailureHandler(requestCallback, name, args) {
  return function (data) {
    var parsed;

    debug('failure', data);

    try {
      parsed = JSON.parse(data);
    } catch (error) {
      requestCallback(error);
    }

    if (parsed) {
      requestCallback(createError(name, args, parsed));
    }
  };
}

function createError(name, args, response) {
  var argsString = JSON.stringify(args);
  var debug = ' (bridge message: \'' + name + '\', args: ' + argsString + ')';
  var msg = response.message + debug;
  var error = new Error(msg);
  error.name = response.error;

  return error;
}

function flushCore() {
  scheduledCoreFlush = false;
  request('core_flush');
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./cosmos":143,"debug":268,"spotify-deferred":362}],145:[function(require,module,exports){
/*
attributes
*/"use strict";

var $ = require("./base");

var trim = require("mout/string/trim"),
    forEach = require("mout/array/forEach"),
    filter = require("mout/array/filter"),
    indexOf = require("mout/array/indexOf");

// attributes

$.implement({

    setAttribute: function setAttribute(name, value) {
        return this.forEach(function (node) {
            node.setAttribute(name, value);
        });
    },

    getAttribute: function getAttribute(name) {
        var attr = this[0].getAttributeNode(name);
        return attr && attr.specified ? attr.value : null;
    },

    hasAttribute: function hasAttribute(name) {
        var node = this[0];
        if (node.hasAttribute) return node.hasAttribute(name);
        var attr = node.getAttributeNode(name);
        return !!(attr && attr.specified);
    },

    removeAttribute: function removeAttribute(name) {
        return this.forEach(function (node) {
            var attr = node.getAttributeNode(name);
            if (attr) node.removeAttributeNode(attr);
        });
    }

});

var accessors = {};

forEach(["type", "value", "name", "href", "title", "id"], function (name) {

    accessors[name] = function (value) {
        return value !== undefined ? this.forEach(function (node) {
            node[name] = value;
        }) : this[0][name];
    };
});

// booleans

forEach(["checked", "disabled", "selected"], function (name) {

    accessors[name] = function (value) {
        return value !== undefined ? this.forEach(function (node) {
            node[name] = !!value;
        }) : !!this[0][name];
    };
});

// className

var classes = function classes(className) {
    var classNames = trim(className).replace(/\s+/g, " ").split(" "),
        uniques = {};

    return filter(classNames, function (className) {
        if (className !== "" && !uniques[className]) return uniques[className] = className;
    }).sort();
};

accessors.className = function (className) {
    return className !== undefined ? this.forEach(function (node) {
        node.className = classes(className).join(" ");
    }) : classes(this[0].className).join(" ");
};

// attribute

$.implement({

    attribute: function attribute(name, value) {
        var accessor = accessors[name];
        if (accessor) return accessor.call(this, value);
        if (value != null) return this.setAttribute(name, value);
        if (value === null) return this.removeAttribute(name);
        if (value === undefined) return this.getAttribute(name);
    }

});

$.implement(accessors);

// shortcuts

$.implement({

    check: function check() {
        return this.checked(true);
    },

    uncheck: function uncheck() {
        return this.checked(false);
    },

    disable: function disable() {
        return this.disabled(true);
    },

    enable: function enable() {
        return this.disabled(false);
    },

    select: function select() {
        return this.selected(true);
    },

    deselect: function deselect() {
        return this.selected(false);
    }

});

// classNames, has / add / remove Class

$.implement({

    classNames: function classNames() {
        return classes(this[0].className);
    },

    hasClass: function hasClass(className) {
        return indexOf(this.classNames(), className) > -1;
    },

    addClass: function addClass(className) {
        return this.forEach(function (node) {
            var nodeClassName = node.className;
            var classNames = classes(nodeClassName + " " + className).join(" ");
            if (nodeClassName !== classNames) node.className = classNames;
        });
    },

    removeClass: function removeClass(className) {
        return this.forEach(function (node) {
            var classNames = classes(node.className);
            forEach(classes(className), function (className) {
                var index = indexOf(classNames, className);
                if (index > -1) classNames.splice(index, 1);
            });
            node.className = classNames.join(" ");
        });
    },

    toggleClass: function toggleClass(className, force) {
        var add = force !== undefined ? force : !this.hasClass(className);
        if (add) this.addClass(className);else this.removeClass(className);
        return !!add;
    }

});

// toString

$.prototype.toString = function () {
    var tag = this.tag(),
        id = this.id(),
        classes = this.classNames();

    var str = tag;
    if (id) str += '#' + id;
    if (classes.length) str += '.' + classes.join(".");
    return str;
};

var textProperty = document.createElement('div').textContent == null ? 'innerText' : 'textContent';

// tag, html, text, data

$.implement({

    tag: function tag() {
        return this[0].tagName.toLowerCase();
    },

    html: function html(_html) {
        return _html !== undefined ? this.forEach(function (node) {
            node.innerHTML = _html;
        }) : this[0].innerHTML;
    },

    text: function text(_text) {
        return _text !== undefined ? this.forEach(function (node) {
            node[textProperty] = _text;
        }) : this[0][textProperty];
    },

    data: function data(key, value) {
        switch (value) {
            case undefined:
                return this.getAttribute("data-" + key);
            case null:
                return this.removeAttribute("data-" + key);
            default:
                return this.setAttribute("data-" + key, value);
        }
    }

});

module.exports = $;

},{"./base":146,"mout/array/filter":308,"mout/array/forEach":309,"mout/array/indexOf":310,"mout/string/trim":340}],146:[function(require,module,exports){
/*
elements
*/"use strict";

var prime = require("prime");

var _forEach = require("mout/array/forEach"),
    _map = require("mout/array/map"),
    _filter = require("mout/array/filter"),
    _every = require("mout/array/every"),
    _some = require("mout/array/some");

// uniqueID

var index = 0,
    __dc = document.__counter,
    counter = document.__counter = (__dc ? parseInt(__dc, 36) + 1 : 0).toString(36),
    key = "uid:" + counter;

var uniqueID = function uniqueID(n) {
    if (n === window) return "window";
    if (n === document) return "document";
    if (n === document.documentElement) return "html";
    return n[key] || (n[key] = (index++).toString(36));
};

var instances = new WeakMap();

// elements prime

var $ = prime({ constructor: function $(n, context) {

        if (n == null) return this && this.constructor === $ ? new Elements() : null;

        var self, uid, instance;

        if (n.constructor !== Elements) {

            self = new Elements();

            if (typeof n === "string") {
                if (!self.search) return null;
                self[self.length++] = context || document;
                return self.search(n);
            }

            if (n.nodeType || n === window) {

                self[self.length++] = n;
            } else if (n.length) {

                // this could be an array, or any object with a length attribute,
                // including another instance of elements from another interface.

                var uniques = {};

                for (var i = 0, l = n.length; i < l; i++) {
                    // perform elements flattening
                    var nodes = $(n[i], context);
                    if (nodes && nodes.length) for (var j = 0, k = nodes.length; j < k; j++) {
                        var node = nodes[j];
                        uid = uniqueID(node);
                        if (!uniques[uid]) {
                            self[self.length++] = node;
                            uniques[uid] = true;
                        }
                    }
                }
            }
        } else {
            self = n;
        }

        if (!self.length) return null;

        // when length is 1 always use the same elements instance

        if (self.length === 1) {
            if (instance = instances.get(self[0])) {
                return instance;
            } else {
                instances.set(self[0], self);
            }
        }

        return self;
    } });

var Elements = prime({

    inherits: $,

    constructor: function Elements() {
        this.length = 0;
    },

    unlink: function unlink() {
        return this.map(function (node) {
            instances.delete(node);
            return node;
        });
    },

    // methods

    forEach: function forEach(method, context) {
        _forEach(this, method, context);
        return this;
    },

    map: function map(method, context) {
        return _map(this, method, context);
    },

    filter: function filter(method, context) {
        return _filter(this, method, context);
    },

    every: function every(method, context) {
        return _every(this, method, context);
    },

    some: function some(method, context) {
        return _some(this, method, context);
    }

});

module.exports = $;

},{"mout/array/every":307,"mout/array/filter":308,"mout/array/forEach":309,"mout/array/map":312,"mout/array/some":315,"prime":345}],147:[function(require,module,exports){
/*
delegation
*/"use strict";

var Map = require("prime/map");

var $ = require("./events");
require('./traversal');

$.implement({

    delegate: function delegate(event, selector, handle) {

        return this.forEach(function (node) {

            var self = $(node);

            var delegation = self._delegation || (self._delegation = {}),
                events = delegation[event] || (delegation[event] = {}),
                map = events[selector] || (events[selector] = new Map());

            if (map.get(handle)) return;

            var action = function action(e) {
                var target = $(e.target || e.srcElement),
                    match = target.matches(selector) ? target : target.parent(selector);

                var res;

                if (match) res = handle.call(self, e, match);

                return res;
            };

            map.set(handle, action);

            self.on(event, action);
        });
    },

    undelegate: function undelegate(event, selector, handle) {

        return this.forEach(function (node) {

            var self = $(node),
                delegation,
                events,
                map;

            if (!(delegation = self._delegation) || !(events = delegation[event]) || !(map = events[selector])) return;

            var action = map.get(handle);

            if (action) {
                self.off(event, action);
                map.remove(action);

                // if there are no more handles in a given selector, delete it
                if (!map.count()) delete events[selector];
                // var evc = evd = 0, x
                var e1 = true,
                    e2 = true,
                    x;
                for (x in events) {
                    e1 = false;
                    break;
                }
                // if no more selectors in a given event type, delete it
                if (e1) delete delegation[event];
                for (x in delegation) {
                    e2 = false;
                    break;
                }
                // if there are no more delegation events in the element, delete the _delegation object
                if (e2) delete self._delegation;
            }
        });
    }

});

module.exports = $;

},{"./events":148,"./traversal":151,"prime/map":346}],148:[function(require,module,exports){
/*
events
*/"use strict";

var Emitter = require("prime/emitter");

var $ = require("./base");

$.implement({

    on: function on(event, handle, useCapture) {

        return this.forEach(function (node) {
            var self = $(node);

            var internalEvent = event + (useCapture ? ":capture" : "");

            Emitter.prototype.on.call(self, internalEvent, handle);

            var domListeners = self._domListeners || (self._domListeners = {});
            if (!domListeners[internalEvent]) {
                var listener = function listener(e) {
                    Emitter.prototype.emit.call(self, internalEvent, e || window.event, Emitter.EMIT_SYNC);
                };
                node.addEventListener(event, listener, useCapture || false);
                domListeners[internalEvent] = listener;
            }
        });
    },

    off: function off(event, handle, useCapture) {

        return this.forEach(function (node) {

            var self = $(node);

            var internalEvent = event + (useCapture ? ":capture" : "");

            var domListeners = self._domListeners,
                domEvent,
                listeners = self._listeners,
                events;

            if (domListeners && (domEvent = domListeners[internalEvent]) && listeners && (events = listeners[internalEvent])) {

                Emitter.prototype.off.call(self, internalEvent, handle);

                if (!self._listeners || !self._listeners[event]) {
                    node.removeEventListener(event, domEvent, false);
                    delete domListeners[event];

                    for (var l in domListeners) {
                        return;
                    }delete self._domListeners;
                }
            }
        });
    },

    emit: function emit() {
        var args = arguments;
        return this.forEach(function (node) {
            Emitter.prototype.emit.apply($(node), args);
        });
    }

});

module.exports = $;

},{"./base":146,"prime/emitter":344}],149:[function(require,module,exports){
/*
elements
*/"use strict";

var $ = require("./base");
require("./attributes");
require("./events");
require("./insertion");
require("./traversal");
require("./delegation");

module.exports = $;

},{"./attributes":145,"./base":146,"./delegation":147,"./events":148,"./insertion":150,"./traversal":151}],150:[function(require,module,exports){
/*
insertion
*/"use strict";

var $ = require("./base");

// base insertion

$.implement({

    appendChild: function appendChild(child) {
        this[0].appendChild($(child)[0]);
        return this;
    },

    insertBefore: function insertBefore(child, ref) {
        this[0].insertBefore($(child)[0], $(ref)[0]);
        return this;
    },

    removeChild: function removeChild(child) {
        this[0].removeChild($(child)[0]);
        return this;
    },

    replaceChild: function replaceChild(child, ref) {
        this[0].replaceChild($(child)[0], $(ref)[0]);
        return this;
    }

});

// before, after, bottom, top

$.implement({

    before: function before(element) {
        element = $(element)[0];
        var parent = element.parentNode;
        if (parent) this.forEach(function (node) {
            parent.insertBefore(node, element);
        });
        return this;
    },

    after: function after(element) {
        element = $(element)[0];
        var parent = element.parentNode;
        if (parent) this.forEach(function (node) {
            parent.insertBefore(node, element.nextSibling);
        });
        return this;
    },

    bottom: function bottom(element) {
        element = $(element)[0];
        return this.forEach(function (node) {
            element.appendChild(node);
        });
    },

    top: function top(element) {
        element = $(element)[0];
        return this.forEach(function (node) {
            element.insertBefore(node, element.firstChild);
        });
    }

});

// insert, replace

$.implement({

    insert: $.prototype.bottom,

    remove: function remove() {
        return this.forEach(function (node) {
            var parent = node.parentNode;
            if (parent) parent.removeChild(node);
        });
    },

    replace: function replace(element) {
        element = $(element)[0];
        element.parentNode.replaceChild(this[0], element);
        return this;
    }

});

module.exports = $;

},{"./base":146}],151:[function(require,module,exports){
/*
traversal
*/"use strict";

var map = require("mout/array/map");

var slick = require("slick");

var $ = require("./base");

var gen = function gen(combinator, expression) {
    return map(slick.parse(expression || "*"), function (part) {
        return combinator + " " + part;
    }).join(", ");
};

var push_ = Array.prototype.push;

$.implement({

    search: function search(expression) {
        if (this.length === 1) return $(slick.search(expression, this[0], new $()));

        var buffer = [];
        for (var i = 0, node; node = this[i]; i++) {
            push_.apply(buffer, slick.search(expression, node));
        }buffer = $(buffer);
        return buffer && buffer.sort();
    },

    find: function find(expression) {
        if (this.length === 1) return $(slick.find(expression, this[0]));

        for (var i = 0, node; node = this[i]; i++) {
            var found = slick.find(expression, node);
            if (found) return $(found);
        }

        return null;
    },

    sort: function sort() {
        return slick.sort(this);
    },

    matches: function matches(expression) {
        return slick.matches(this[0], expression);
    },

    contains: function contains(node) {
        return slick.contains(this[0], node);
    },

    nextSiblings: function nextSiblings(expression) {
        return this.search(gen('~', expression));
    },

    nextSibling: function nextSibling(expression) {
        return this.find(gen('+', expression));
    },

    previousSiblings: function previousSiblings(expression) {
        return this.search(gen('!~', expression));
    },

    previousSibling: function previousSibling(expression) {
        return this.find(gen('!+', expression));
    },

    children: function children(expression) {
        return this.search(gen('>', expression));
    },

    firstChild: function firstChild(expression) {
        return this.find(gen('^', expression));
    },

    lastChild: function lastChild(expression) {
        return this.find(gen('!^', expression));
    },

    parent: function parent(expression) {
        var buffer = [];
        loop: for (var i = 0, node; node = this[i]; i++) {
            while ((node = node.parentNode) && node !== document) {
                if (!expression || slick.matches(node, expression)) {
                    buffer.push(node);
                    break loop;
                    break;
                }
            }
        }return $(buffer);
    },

    parents: function parents(expression) {
        var buffer = [];
        for (var i = 0, node; node = this[i]; i++) {
            while ((node = node.parentNode) && node !== document) {
                if (!expression || slick.matches(node, expression)) buffer.push(node);
            }
        }return $(buffer);
    }

});

module.exports = $;

},{"./base":146,"mout/array/map":312,"slick":349}],152:[function(require,module,exports){
'use strict';

var $ = require('../spotify-elements');
var Navigator = require('../spotify-navigation/navigator');
var AppState = require('../spotify-navigation/app-state');

var SELECTOR = 'a';

var nav = new Navigator();

var handleAnchorClick = function handleAnchorClick(event, node) {
  var anchor = node[0];
  var href = anchor.getAttribute('href');
  if (!href || href[0] === '#') {
    return;
  }

  event.preventDefault();

  var referrer = anchor.getAttribute('data-referrer-id') || document.body.getAttribute('data-referrer-id');

  var state = new AppState(href);

  if (referrer) {
    state.setReferrer(referrer);
  }

  nav.requestOpenState(state);
};

var isAttached = false;

exports.attach = function attach() {
  if (isAttached) {
    return;
  }
  isAttached = true;
  $(document).delegate('click', SELECTOR, handleAnchorClick);
};

exports.detach = function detach() {
  if (!isAttached) {
    return;
  }
  isAttached = false;
  $(document).undelegate('click', SELECTOR, handleAnchorClick);
};

exports.update = function () {};

},{"../spotify-elements":149,"../spotify-navigation/app-state":224,"../spotify-navigation/navigator":225}],153:[function(require,module,exports){
/*
Event Center
*/'use strict';

var Emitter = require('prime/emitter');

module.exports = new Emitter();

},{"prime/emitter":344}],154:[function(require,module,exports){
'use strict';

/**
 * Module for handling clicks on the scroll bar track to scroll pages.
 *
 * @private
 */

var BezierEasing = require('bezier-easing');

var config = require('./config');

module.exports = {

  // Called from outside
  setHandler: function setHandler(eventName, scroller, handler) {
    if (eventName === 'clickEnd') {
      scroller._clickEndHandler = handler;
    }
  },

  scrollTo: function scrollTo(scroller, newPosition, useEasing, callback) {
    var startPosition = scroller.view.scrollTop;
    var positionDiff = newPosition - startPosition;

    var startTimestamp = Date.now();
    var totalTime = config.scrollToTransitionMs;

    if (!useEasing) {
      totalTime = config.scrollToLinearTransitionMs;
    }

    // Ease in/out quadratic
    var easing = new BezierEasing(0.455, 0.03, 0.515, 0.955);

    var tick = function tick() {
      var elapsedTime = Date.now() - startTimestamp;
      var totalPercentage = elapsedTime / totalTime;

      var currentPercentage = useEasing ? easing.get(totalPercentage) : totalPercentage;

      scroller.view.scrollTop = startPosition + positionDiff * currentPercentage;

      if (totalPercentage < 1) {
        // Must use setTimeout to not make it flicker. Setting scrollTop in
        // requestAnimationFrame will make it scroll and in the next frame allow
        // the scroll handlers to move elements, making it look very flickery.
        setTimeout(tick, config.frameMs);
      } else {
        scroller.view.scrollTop = startPosition + positionDiff;
        scroller.isClickScrollAnimating = false;
        if (callback) {
          callback();
        }
      }
    };

    scroller.isClickScrollAnimating = true;
    setTimeout(tick, config.frameMs);
  },

  holdClick: function holdClick(scroller) {
    var targetThumbEdge = scroller.clickTargetThumbTop;
    var newPosition = this.getNextScrollValue(scroller);
    var newThumbTop = newPosition / scroller.viewScrollHeight * scroller.viewHeight;
    var newThumbBottom = newThumbTop + scroller.thumbHeight;
    var direction = scroller.clickTargetDirection;

    var isValid = false;
    if (direction === 'up' && newThumbBottom > targetThumbEdge) {
      isValid = true;
    } else if (direction === 'down' && newThumbTop < targetThumbEdge) {
      isValid = true;
    }

    if (isValid) {
      var useEasing = false;

      this.scrollTo(scroller, newPosition, useEasing, function () {
        if (scroller.isClickScrolling) {
          this.holdClick(scroller);
        }
      }.bind(this));
    }
  },

  getNextScrollValue: function getNextScrollValue(scroller) {
    var change = scroller.viewHeight * config.clickScrollDistanceFactor;

    if (scroller.clickTargetDirection === 'up') {
      return scroller.view.scrollTop - change;
    }

    return scroller.view.scrollTop + change;
  },

  setMovementData: function setMovementData(scroller, clientY) {
    var trackTop = scroller.scrollBarTrack.getBoundingClientRect().top;
    var targetThumbEdge = clientY - trackTop;
    var direction = targetThumbEdge < scroller.thumbTop ? 'up' : 'down';

    scroller.clickTargetDirection = direction;
    scroller.clickTargetThumbTop = targetThumbEdge;
  },

  onClickHold: function onClickHold(scroller) {
    scroller.isClickScrolling = true;

    this.holdClick(scroller);
  },

  onMouseMove: function onMouseMove(scroller, event) {
    if (scroller.isMouseOver && event.target === scroller.scrollBarTrack) {
      this.setMovementData(scroller, event.clientY);

      if (scroller.isClickScrolling && !scroller.isClickScrollAnimating) {
        this.holdClick(scroller);
      }
    }
  },

  onMouseUp: function onMouseUp(scroller) {
    scroller.isClickScrolling = false;

    clearTimeout(scroller.clickHoldTimer);

    this.removeHandlers(scroller);

    if (scroller._clickEndHandler) {
      scroller._clickEndHandler();
    }
  },

  onTrackMouseDown: function onTrackMouseDown(scroller, event) {
    var isVisible = scroller.isVisible;
    var isPrimaryButton = event.button === 0;
    var isTargetTrack = event.target === scroller.scrollBarTrack;

    if (isVisible && isPrimaryButton && isTargetTrack) {
      var navigator = window.navigator;
      var isMac = navigator && navigator.userAgent.indexOf('Mac') > -1;
      var isWindows = navigator && navigator.userAgent.indexOf('Windows') > -1;

      if (isMac && event.altKey || isWindows && event.shiftKey) {
        var trackTop = scroller.scrollBarTrack.getBoundingClientRect().top;
        var targetThumbCenter = event.clientY - trackTop;
        var targetThumbTop = Math.max(0, Math.min(scroller.viewHeight - scroller.thumbHeight, targetThumbCenter - scroller.thumbHeight / 2));

        scroller.view.scrollTop = targetThumbTop / (scroller.viewHeight - scroller.thumbHeight) * (scroller.viewScrollHeight - scroller.viewHeight);
      } else {
        this.setMovementData(scroller, event.clientY);

        var targetPosition = this.getNextScrollValue(scroller);
        var useEasing = true;

        this.scrollTo(scroller, targetPosition, useEasing);

        this.addHandlers(scroller);

        scroller.clickHoldTimer = setTimeout(this.onClickHold.bind(this, scroller), config.scrollToTransitionMs + config.clickHoldDelayMs);
      }
    }
  },

  addHandlers: function addHandlers(scroller) {
    scroller._click_onMouseUp = this.onMouseUp.bind(this, scroller);
    scroller._click_onMouseMove = this.onMouseMove.bind(this, scroller);

    document.addEventListener('mouseup', scroller._click_onMouseUp, false);
    document.addEventListener('mousemove', scroller._click_onMouseMove, false);
  },

  removeHandlers: function removeHandlers(scroller) {
    document.removeEventListener('mouseup', scroller._click_onMouseUp, false);
    document.removeEventListener('mousemove', scroller._click_onMouseMove, false);
  },

  attach: function attach(scroller) {
    var onTrackMouseDown = this.onTrackMouseDown.bind(this, scroller);

    scroller.scrollBarTrack.addEventListener('mousedown', onTrackMouseDown, false);

    return function () {
      scroller.scrollBarTrack.removeEventListener('mousedown', onTrackMouseDown, false);
    };
  }

};

},{"./config":155,"bezier-easing":246}],155:[function(require,module,exports){
"use strict";

/**
 * Config with all timer values etc. Easy to have them all in one place, and it
 * also helps for testing, since the config can be used from there too.
 *
 * @private
 */

module.exports = {
  hideAfterMs: 750,
  showAfterMs: 500,

  // Sync with CSS transition duration
  hideTransitionMs: 500,

  expandDelayMs: 150,

  frameMs: 16,
  scrollToTransitionMs: 200,
  scrollToLinearTransitionMs: 120,
  clickHoldDelayMs: 500,
  clickScrollDistanceFactor: 0.95
};

},{}],156:[function(require,module,exports){
'use strict';

/**
 * Module for handling dragging the scroll bar thumb to scroll.
 *
 * @private
 */

module.exports = {

  // Called from outside
  setHandler: function setHandler(eventName, scroller, handler) {
    if (eventName === 'dragStart') {
      scroller._dragStartHandler = handler;
    } else if (eventName === 'dragEnd') {
      scroller._dragEndHandler = handler;
    }
  },

  onThumbMouseDown: function onThumbMouseDown(scroller, event) {
    if (event.button === 0 && scroller.isVisible) {
      scroller.isDragging = true;
      scroller.startDragMouseY = event.clientY;
      scroller.startDragThumbTop = scroller.thumbTop;

      this.addDragHandlers(scroller);

      if (scroller._dragStartHandler) {
        scroller._dragStartHandler();
      }
    }
  },

  onMouseUp: function onMouseUp(scroller, event) {
    if (scroller.isDragging) {
      scroller.isDragging = false;

      this.removeDragHandlers(scroller);

      if (scroller._dragEndHandler) {
        scroller._dragEndHandler();
      }
    }
  },

  onMouseMove: function onMouseMove(scroller, event) {
    var y = event.clientY;
    var startY = scroller.startDragMouseY;

    scroller.thumbTop = Math.max(0, Math.min(scroller.viewHeight - scroller.thumbHeight, scroller.startDragThumbTop + y - startY));

    scroller.view.scrollTop = scroller.thumbTop / (scroller.viewHeight - scroller.thumbHeight) * (scroller.viewScrollHeight - scroller.viewHeight);
  },

  addDragHandlers: function addDragHandlers(scroller) {
    scroller._drag_onMouseMove = this.onMouseMove.bind(this, scroller);
    scroller._drag_onMouseUp = this.onMouseUp.bind(this, scroller);

    document.addEventListener('mousemove', scroller._drag_onMouseMove, false);
    document.addEventListener('mouseup', scroller._drag_onMouseUp, false);
  },

  removeDragHandlers: function removeDragHandlers(scroller) {
    document.removeEventListener('mousemove', scroller._drag_onMouseMove, false);
    document.removeEventListener('mouseup', scroller._drag_onMouseUp, false);
  },

  attach: function attach(scroller) {
    var onThumbMouseDown = this.onThumbMouseDown.bind(this, scroller);

    scroller.scrollBarThumb.addEventListener('mousedown', onThumbMouseDown, false);

    return function () {
      scroller.scrollBarThumb.removeEventListener('mousedown', onThumbMouseDown, false);
    };
  }

};

},{}],157:[function(require,module,exports){
'use strict';

/**
 * Module for handling expanding the scroll bar width on hover.
 *
 * @private
 */

var config = require('./config');

module.exports = {

  expand: function expand(scroller) {
    clearTimeout(scroller.resetExpandedTimer);
    scroller.scrollBarTrack.classList.add('expanded');
  },

  collapse: function collapse(scroller) {
    scroller.scrollBarTrack.classList.remove('expanded');
  },

  // Called from outside
  onHide: function onHide(scroller) {
    if (!scroller.alwaysVisible) {
      clearTimeout(scroller.expandTimer);
      clearTimeout(scroller.resetExpandedTimer);

      scroller.resetExpandedTimer = setTimeout(this.collapse.bind(this, scroller), config.hideTransitionMs);
    }
  },

  onTrackMouseEnter: function onTrackMouseEnter(scroller, event) {
    if (event.target === scroller.scrollBarTrack) {
      if (scroller.isVisible) {
        clearTimeout(scroller.expandTimer);
        clearTimeout(scroller.resetExpandedTimer);
        scroller.expandTimer = setTimeout(function () {
          this.expand(scroller);
        }.bind(this), config.expandDelayMs);
      } else {
        this.expand(scroller);
      }
    }
  },

  onTrackMouseLeave: function onTrackMouseLeave(scroller, event) {
    if (event.target === scroller.scrollBarTrack) {
      if (scroller.isVisible) {
        clearTimeout(scroller.expandTimer);
      } else {
        this.collapse(scroller);
      }
    }
  },

  attach: function attach(scroller) {
    if (scroller.alwaysVisible) {
      this.expand(scroller);

      return function () {};
    } else {
      this.collapse(scroller);

      var onTrackMouseEnter = this.onTrackMouseEnter.bind(this, scroller);
      var onTrackMouseLeave = this.onTrackMouseLeave.bind(this, scroller);

      scroller.scrollBarTrack.addEventListener('mouseenter', onTrackMouseEnter, false);
      scroller.scrollBarTrack.addEventListener('mouseleave', onTrackMouseLeave, false);

      return function () {
        scroller.scrollBarTrack.removeEventListener('mouseenter', onTrackMouseEnter, false);
        scroller.scrollBarTrack.removeEventListener('mouseleave', onTrackMouseLeave, false);
      };
    }
  }

};

},{"./config":155}],158:[function(require,module,exports){
'use strict';

var glue = require('../../spotify-glue-cat');
var cosmos = require('spotify-cosmos-api');

var center = require('../center');
var drag = require('./drag');
var visibility = require('./visibility');
var position = require('./position');
var expansion = require('./expansion');
var click = require('./click');

var scrollers = [];
var scrollerStyle = null;

function Scroller(scrollView) {
  this.view = scrollView;
  this.setInitialState();
  this.addScrollBar();
  this.refresh();

  this.view.setAttribute('data-scroll-area-initialized', '');

  this._onResize = function () {
    this.refresh();
  }.bind(this);
  this._onScroll = function () {
    this.refreshScrollBar();
  }.bind(this);
  this._onThumbDragStart = function (event) {
    event.preventDefault();
    event.stopPropagation();
  };

  // Listen for the scroll event to update view size etc on scroll
  var scrollObject = this.isBody ? window : this.view;
  scrollObject.addEventListener('scroll', this._onScroll, false);

  // Listen for the window resize event, even for scroll areas that are not the
  // body scroll. Since we can't listen for resize events when elements resize,
  // we do a best effort of at least updating when the window resizes (which
  // might affect the size of the scroll area).
  window.addEventListener('resize', this._onResize, false);

  // Prevent dragndrop handling from spotify-events (it will be triggered
  // otherwise since we have to set the draggable attribute to not trigger
  // focus events).
  this.scrollBarThumb.addEventListener('dragstart', this._onThumbDragStart, true);

  this._detachVisibility = visibility.attach(this);
  this._detachPosition = position.attach(this);
  this._detachDrag = drag.attach(this);
  this._detachClick = click.attach(this);
  this._detachExpansion = expansion.attach(this);

  visibility.setHandler('show', this, function () {
    this.refresh();
  }.bind(this));

  visibility.setHandler('hide', this, function () {
    expansion.onHide(this);
  }.bind(this));

  // Events are sent when dragging to allow some use cases where you need to do
  // something while dragging. For example, when dragging the scroll bar in the
  // app sidebar and hovering over the main view, it will not trigger mousemove
  // events since the main view is an iframe. To counter that, zlink is
  // listening to these events and sets pointer-events on the content area.
  drag.setHandler('dragStart', this, function () {
    center.emit('scroll-thumb-drag-start', { id: this.viewId });
  }.bind(this));
  drag.setHandler('dragEnd', this, function () {
    visibility.onDragEnd(this);
    center.emit('scroll-thumb-drag-end', { id: this.viewId });
  }.bind(this));

  click.setHandler('clickEnd', this, function () {
    visibility.onClickEnd(this);
  }.bind(this));
}

Scroller.prototype.setInitialState = function () {
  var scrollerStyleToUse = scrollerStyle || window.__spotify.scroller_style;
  this.alwaysVisible = scrollerStyleToUse === 'always';

  this.scrollBarTrack = null;
  this.scrollBarThumb = null;

  this.isBody = this.view === document.body;
  this.viewId = this.view.getAttribute('data-scroll-area');
  this.viewHeight = 0;
  this.viewScrollHeight = 0;

  this.isVisible = false;
  this.isDragging = false;
  this.isMouseOver = false;
  this.isClickScrolling = false;
  this.isClickScrollAnimating = false;

  this.thumbTop = 0;
  this.thumbHeight = 0;

  this.clickTargetDirection = 'down';
  this.clickTargetThumbTop = 0;

  this.startDragMouseY = 0;
  this.startDragThumbTop = 0;

  this.hideTimer = 0;
  this.mouseOverShowTimer = 0;
};

Scroller.prototype.addScrollBar = function () {
  var track = document.createElement('div');
  var thumb = document.createElement('div');

  track.className = 'scrollbar-track';
  thumb.className = 'scrollbar-thumb';

  if (this.alwaysVisible) {
    track.className += ' always-visible';
  }

  // If the thumb is not set to draggable it will trigger focus events on
  // elements being dragged over. For example, dragging the thumb up to the
  // search input puts focus in the search input, which opens the suggest box.
  // Since we will find this element from the dragndrop module, we also need to
  // prevent any drag handling (find the drag listener further down).
  thumb.setAttribute('draggable', 'true');

  track.appendChild(thumb);
  this.view.appendChild(track);

  this.scrollBarTrack = track;
  this.scrollBarThumb = thumb;
};

Scroller.prototype.setViewSize = function () {
  // Hide the scroll bar while calculating sizes, so the scroll bar doesn't
  // interfere. This can happen if scrolled to the bottom of the scroll view and
  // the scroll height changes to be smaller. If the scroll bar is not hidden
  // while calculating the values here, the scrollHeight will not change, since
  // the scroll bar is taking up space.
  this.scrollBarTrack.style.display = 'none';

  if (this.isBody) {
    this.viewHeight = window.innerHeight || Infinity;
  } else {
    this.viewHeight = this.view.clientHeight || Infinity;
  }

  this.viewScrollHeight = this.view.scrollHeight;

  this.scrollBarTrack.style.display = 'block';
};

Scroller.prototype.setThumbSize = function () {
  var percentage = this.viewHeight / this.viewScrollHeight;
  this.thumbHeight = Math.max(40, this.viewHeight * percentage);
  this.scrollBarThumb.style.height = this.thumbHeight + 'px';
};

Scroller.prototype.setTrackPosition = function () {
  this.scrollBarTrack.style.transform = 'translate3d(0, ' + (this.view.scrollTop + 'px') + ', 0)';
};

Scroller.prototype.refresh = function () {
  this.refreshView();
  this.refreshScrollBar();
};

Scroller.prototype.refreshView = function () {
  this.setViewSize();
};

Scroller.prototype.refreshScrollBar = function () {
  this.setThumbSize();

  if (!this.isBody) {
    this.setTrackPosition();
  }
};

Scroller.prototype.update = function () {
  var oldViewHeight = this.viewHeight;
  var oldScrollHeight = this.viewScrollHeight;

  this.refresh();

  visibility.update(this);

  var newViewHeight = this.viewHeight;
  var newScrollHeight = this.viewScrollHeight;

  if (newViewHeight !== oldViewHeight || newScrollHeight !== oldScrollHeight) {
    visibility.highlight(this);
  }
};

Scroller.prototype.setScrollBarMode = function (mode) {
  this.alwaysVisible = mode === 'always';

  if (this.alwaysVisible) {
    this.scrollBarTrack.classList.add('always-visible');
  } else {
    this.scrollBarTrack.classList.remove('always-visible');
  }

  this._detachVisibility();
  this._detachPosition();
  this._detachDrag();
  this._detachClick();
  this._detachExpansion();

  this._detachVisibility = visibility.attach(this);
  this._detachPosition = position.attach(this);
  this._detachDrag = drag.attach(this);
  this._detachClick = click.attach(this);
  this._detachExpansion = expansion.attach(this);
};

Scroller.prototype.isInDOM = function () {
  var currentNode = this.view.parentNode;
  while (currentNode && currentNode !== document.documentElement) {
    currentNode = currentNode.parentNode;
  }

  // If we still have a current node after the loop, we found the document
  // element, which means it's in DOM.
  return !!currentNode;
};

Scroller.prototype.destroy = function () {
  var scrollObject = this.isBody ? window : this.view;

  scrollObject.removeEventListener('scroll', this._onScroll, false);

  window.removeEventListener('resize', this._onResize, false);

  this.scrollBarThumb.removeEventListener('dragstart', this._onThumbDragStart, true);

  this.view.removeAttribute('data-scroll-area-initialized', '');
  this.view.removeChild(this.scrollBarTrack);

  this._detachVisibility();
  this._detachPosition();
  this._detachDrag();
  this._detachClick();
  this._detachExpansion();
};

var isAttached = false;
var controlMessageSubscription;

exports.update = function (node) {
  if (!isAttached) {
    return;
  }

  // Clean up scrollers that are not in DOM anymore.
  scrollers = scrollers.filter(function (scroller) {
    if (!scroller.isInDOM()) {
      scroller.destroy();
      return false;
    }
    return true;
  });

  // Update all active scrollers
  for (var i = 0, l = scrollers.length; i < l; i++) {
    scrollers[i].update();
  }

  var selector = '[data-scroll-area]';
  var scrollViews = (node || document).querySelectorAll(selector);

  for (var i = 0, l = scrollViews.length; i < l; i++) {
    if (!scrollViews[i].hasAttribute('data-scroll-area-initialized')) {
      var scrollView = scrollViews[i];
      var isBody = scrollView === document.body;

      if (isBody && glue.getVersion() !== 2) {
        continue;
      }

      scrollers.push(new Scroller(scrollView));
    }
  }
};

exports.attach = function () {
  if (isAttached) return;
  isAttached = true;

  var setScrollBarMode = function setScrollBarMode(mode) {
    scrollerStyle = mode;

    for (var i = 0, l = scrollers.length; i < l; i++) {
      scrollers[i].setScrollBarMode(mode);
    }
  };

  controlMessageSubscription = cosmos.resolver.subscribe({
    url: 'sp://messages/v1/container/control'
  }, function (error, response) {
    if (!error) {
      var data = response.getJSONBody();
      if (data) {
        var styleWasChanged = true;
        switch (data.type) {
          case 'set_scroller_style_always_visible':
            setScrollBarMode('always');
            break;
          case 'set_scroller_style_overlay':
            setScrollBarMode('overlay');
            break;
          default:
            styleWasChanged = false;
        }

        // Fix a rendering bug in Chromium. When scroller style changes in the
        // system (changing system preference, connecting/disconnecting a mouse
        // etc), Chromium will render a white area where the scroll bar is
        // supposed to be. By adding and removing a class name we're triggering
        // a re-render and it will look good.
        //
        // https://jira.spotify.net/browse/KM-8285
        // http://crbug.com/538579
        if (styleWasChanged) {
          var performFix = function performFix() {
            var nodes = scrollers.map(function (scroller) {
              return scroller.view;
            });

            // Always include body to fix the main scroll, even if it doesn't
            // have a custom scroll bar.
            if (nodes.indexOf(document.body) === -1) {
              nodes.push(document.body);
            }

            for (var i = 0, l = nodes.length; i < l; i++) {
              nodes[i].classList.add('jmeBDLRW3CRWW3kZZaZ');
              nodes[i].classList.remove('jmeBDLRW3CRWW3kZZaZ');
            }
          };

          // Perform the fix twice (once with a delay), since it sometimes might
          // be slow and won't apply the fix on the first try.
          performFix();
          setTimeout(performFix, 1000);
        }
      }
    } else {
      controlMessageSubscription.cancel();
    }
  });
};

exports.detach = function () {
  if (!isAttached) return;
  isAttached = false;

  for (var i = 0, l = scrollers.length; i < l; i++) {
    scrollers[i].destroy();
  }
  scrollers.length = 0;

  scrollerStyle = null;

  if (controlMessageSubscription) {
    controlMessageSubscription.cancel();
    controlMessageSubscription = null;
  }
};

},{"../../spotify-glue-cat":186,"../center":153,"./click":154,"./drag":156,"./expansion":157,"./position":159,"./visibility":160,"spotify-cosmos-api":357}],159:[function(require,module,exports){
'use strict';

/**
 * Module for handling updating the scroll bar thumb position when scroll
 * position changes.
 *
 * @private
 */

module.exports = {

  setThumbPosition: function setThumbPosition(scroller) {
    if (scroller.viewScrollHeight === scroller.viewHeight) {
      scroller.thumbTop = 0;
    } else {
      scroller.thumbTop = scroller.view.scrollTop / (scroller.viewScrollHeight - scroller.viewHeight) * (scroller.viewHeight - scroller.thumbHeight);
    }

    scroller.scrollBarThumb.style.transform = 'translate3d(0, ' + (scroller.thumbTop + 'px') + ', 0)';
  },

  onScroll: function onScroll(scroller) {
    this.setThumbPosition(scroller);
  },

  attach: function attach(scroller) {
    var onScroll = this.onScroll.bind(this, scroller);

    var scrollObject = scroller.isBody ? window : scroller.view;
    scrollObject.addEventListener('scroll', onScroll, false);

    this.setThumbPosition(scroller);

    return function () {
      scrollObject.removeEventListener('scroll', onScroll, false);
    };
  }

};

},{}],160:[function(require,module,exports){
'use strict';

/**
 * Module for handling the visibility of the scroll bar, based on mouse position
 * and scroll events.
 *
 * @private
 */

var config = require('./config');

module.exports = {

  // Called from outside
  setHandler: function setHandler(eventName, scroller, handler) {
    if (eventName === 'show') {
      scroller._showHandler = handler;
    } else if (eventName === 'hide') {
      scroller._hideHandler = handler;
    }
  },

  refresh: function refresh(scroller) {
    if (scroller.viewScrollHeight > scroller.viewHeight) {
      this.showScrollBar(scroller);
    } else {
      this.hideScrollBar(scroller);
    }
  },

  showScrollBar: function showScrollBar(scroller) {
    if (scroller.isVisible) {
      return;
    }

    if (scroller.viewScrollHeight > scroller.viewHeight) {
      scroller.scrollBarTrack.classList.add('visible');
      scroller.isVisible = true;

      if (scroller._showHandler) {
        scroller._showHandler();
      }
    }
  },

  hideScrollBar: function hideScrollBar(scroller) {
    if (!scroller.isVisible || scroller.isDragging) {
      return;
    }

    scroller.scrollBarTrack.classList.remove('visible');
    scroller.isVisible = false;

    if (scroller._hideHandler) {
      scroller._hideHandler();
    }
  },

  startHideTimer: function startHideTimer(scroller) {
    this.stopHideTimer(scroller);
    scroller.hideTimer = setTimeout(this.hideScrollBar.bind(this, scroller), config.hideAfterMs);
  },

  stopHideTimer: function stopHideTimer(scroller) {
    clearTimeout(scroller.hideTimer);
  },

  // Called from outside
  onDragEnd: function onDragEnd(scroller) {
    if (!scroller.alwaysVisible && !scroller.isMouseOver) {
      this.startHideTimer(scroller);
    }
  },

  // Called from outside
  onClickEnd: function onClickEnd(scroller) {
    if (!scroller.alwaysVisible && !scroller.isMouseOver) {
      this.startHideTimer(scroller);
    }
  },

  onScroll: function onScroll(scroller) {
    if (!scroller.isVisible) {
      this.showScrollBar(scroller);
    }

    if (!scroller.isDragging && !scroller.isClickScrolling && !scroller.isMouseOver) {
      this.startHideTimer(scroller);
    }
  },

  onTrackMouseEnter: function onTrackMouseEnter(scroller, event) {
    if (event.target === scroller.scrollBarTrack) {
      scroller.isMouseOver = true;

      this.stopHideTimer(scroller);

      if (!scroller.isVisible) {
        scroller.mouseOverShowTimer = setTimeout(this.showScrollBar.bind(this, scroller), config.showAfterMs);
      }
    }
  },

  onTrackMouseLeave: function onTrackMouseLeave(scroller, event) {
    if (event.target === scroller.scrollBarTrack) {
      scroller.isMouseOver = false;

      if (!scroller.isDragging && !scroller.isClickScrolling) {
        clearTimeout(scroller.mouseOverShowTimer);

        if (scroller.isVisible) {
          this.startHideTimer(scroller);
        }
      }
    }
  },

  attach: function attach(scroller) {
    if (scroller.alwaysVisible) {
      this.refresh(scroller);

      return function () {};
    } else {
      this.hideScrollBar(scroller);

      var onScroll = this.onScroll.bind(this, scroller);
      var onTrackMouseEnter = this.onTrackMouseEnter.bind(this, scroller);
      var onTrackMouseLeave = this.onTrackMouseLeave.bind(this, scroller);

      var scrollObject = scroller.isBody ? window : scroller.view;
      scrollObject.addEventListener('scroll', onScroll, false);

      scroller.scrollBarTrack.addEventListener('mouseenter', onTrackMouseEnter, false);
      scroller.scrollBarTrack.addEventListener('mouseleave', onTrackMouseLeave, false);

      return function () {
        scrollObject.removeEventListener('scroll', onScroll, false);

        scroller.scrollBarTrack.removeEventListener('mouseenter', onTrackMouseEnter, false);
        scroller.scrollBarTrack.removeEventListener('mouseleave', onTrackMouseLeave, false);
      };
    }
  },

  update: function update(scroller) {
    if (scroller.alwaysVisible) {
      this.refresh(scroller);
    }
  },

  highlight: function highlight(scroller) {
    if (!scroller.alwaysVisible && !scroller.isVisible) {
      this.showScrollBar(scroller);
      this.startHideTimer(scroller);
    }
  }

};

},{"./config":155}],161:[function(require,module,exports){
/**
 * @module spotify-events/select
 */
'use strict';

var $ = require('../spotify-elements');
var center = require('./center');

var live = require('../spotify-live');

var ATTR_SELECT = 'select';
var ATTR_PROPERTY = 'select-property';
var SELECTOR_SELECT = '[data-' + ATTR_SELECT + ']';

// Stored nodes, used to not add listeners multiple times
var storedNodes = [];

/**
 * Handle a change on a select node.
 *
 * @param {MouseEvent} event Event object.
 * @param {Elements} elem An elements DOM node for the select.
 */
function handleChange(event, elem) {
  var property = elem.data(ATTR_PROPERTY);
  var node = elem[0];
  // If a property is set, update the model. That will later trigger
  // an update of the view and a change event on center will be sent.
  if (property) {
    publish(node, property);
    // If no property is set, just emit a change event on center.
  } else {
      emitUpdate(node, selectedValue(node));
    }
}

/**
 * Return the value attribute of the selected option
 *
 * @param {Elements} elem An elements DOM node for the select
 */
function selectedValue(node) {
  var selected = node.options[node.selectedIndex];
  return selected.value;
}

/**
 * Handle when a select-option event happens on center.
 *
 * @param {Object} event An object with data.
 */
function onSelectSet(event) {
  if (!event.id) return;

  var elem = $('[data-' + ATTR_SELECT + '=' + event.id + ']');
  if (!elem) return;

  var node = elem[0];
  var value = event.selected;

  // updating the node will trigger a DOM event,
  // delegated to handleChange in this module.
  var property = elem.data(ATTR_PROPERTY);

  if (property) {
    publish(node, property, value);
  } else {
    setState(node, value);
  }
}

/**
 * Publish new data to the live model. If no data-uri is found from
 * the passed node, nothing happens.
 *
 * @param {HtmlElement} node A DOM node for the select
 * @param {string} property A property name on the live model
 * @param {string=} opt_value Optional value to set the property to.
 *     If not provided, the selected option's value is fetched from the DOM.
 */
function publish(node, property, opt_value) {
  var uri = getUriFromNode(node);
  if (!uri) return;

  var model = live(uri);

  // If the model doesn't have a current value, we can't safely
  // set a new value without maybe being wrong.
  var value = model.get(property);
  if (value === undefined) return;

  var newValue = opt_value === undefined ? selectedValue(node) : opt_value;

  var data = {};
  data[property] = newValue;

  // Publishing the new value to the model will trigger the update
  // handler added here in this module to send an center event,
  // and update the DOM if needed.
  model.publish(data);
}

/**
 * Update the state of one select node.
 *
 * @param {HTMLElement} node A DOM node for the select.
 */
function updateNode(node) {
  if (storedNodes.indexOf(node) > -1) return;
  storedNodes.push(node);

  var elem = $(node);
  var property = elem.data(ATTR_PROPERTY);
  if (!property) return;

  var uri = getUriFromNode(node);
  if (!uri) return;

  var model = live(uri);

  model.get(property, function (error, value) {
    if (error) throw error;

    setState(node, value);

    model.on('update', function (properties) {
      if (property in properties) {
        setState(node, properties[property]);
      }
    });
  });
}

/**
 * Update a select node based on a value.
 *
 * @param {HTMLElement} node A DOM node for a select.
 * @param {string} value The value attribute of the option to select
 */
function setState(node, value) {
  updateNodeWithValue(node, value);
  emitUpdate(node, value);
}

/**
 * Update a select based on an option's value attribute
 *
 * @param {HTMLElement} node A DOM node for a select.
 * @param {string} value The value attribute of the option to select
 */
function updateNodeWithValue(node, value) {
  var selectElement = $(node);
  var optionElement = selectElement.find('option[value="' + value + '"]');
  if (optionElement && !optionElement.attribute('selected')) {
    optionElement.select();
  }
}

/**
 * Emit a change event on center. It will have the following format:
 * {
 *   element: HTMLElement,
 *   id: 'id from data-select attribute' || null,
 *   selected: the new selected value
 * }
 *
 * @param {HTMLElement} node A DOM node for a select.
 * @param {string} value Attribute of the selected option
 */
function emitUpdate(node, selected) {
  var id = $(node).data(ATTR_SELECT) || null;
  center.emit('select-change', {
    element: node,
    id: id,
    selected: selected
  });
}

/**
 * Get a URI from a node.
 *
 * @param {HTMLElement} node A DOM node.
 *
 * @return {string?} A URI string or null if not found.
 */
function getUriFromNode(node) {
  var stateNode = node.closest('[data-uri]');
  if (!stateNode) return null;
  return stateNode.getAttribute('data-uri');
}

var isAttached = false;

exports.update = function (opt_node) {
  if (!isAttached) return;

  var nodes = $(opt_node || document).search(SELECTOR_SELECT);
  if (!nodes) return;

  nodes.forEach(updateNode);
};

exports.attach = function () {
  if (isAttached) return;
  isAttached = true;

  var doc = $(document);
  doc.delegate('change', SELECTOR_SELECT, handleChange);

  center.on('select-set', onSelectSet);
};

exports.detach = function () {
  if (!isAttached) return;
  isAttached = false;

  var doc = $(document);
  doc.undelegate('change', SELECTOR_SELECT, handleChange);

  center.off('select-set', onSelectSet);
};

},{"../spotify-elements":149,"../spotify-live":217,"./center":153}],162:[function(require,module,exports){
/**
 * @module spotify-events/slider
 */
'use strict';

var $ = require('../spotify-elements');
var center = require('./center');

var live = require('../spotify-live');

var ATTR_SLIDER = 'slider';
var ATTR_PROPERTY = 'slider-property';
var SELECTOR_SLIDER = '[data-' + ATTR_SLIDER + ']';
var CLASSNAME_ENABLED = 'enabled';
var CLASSNAME_DISABLED = 'disabled';
var ATTR_ALLOWED = 'slider-allowed-property';

var SPACE_KEY_CODE = 32;

// Stored nodes, used to not add listeners multiple times
var storedNodes = [];

/**
 * Handle a click on a slider node.
 *
 * @param {MouseEvent} event Event object.
 * @param {Elements} elem An elements DOM node for the slider.
 */
function handleClick(event, elem) {
  var property = elem.data(ATTR_PROPERTY);

  if (elem.data(ATTR_ALLOWED) && !live(elem.data('uri')).get(elem.data(ATTR_ALLOWED))) {
    return;
  }

  // If a property is set, update the model. That will later trigger
  // an update of the view and a change event on center will be sent.
  if (property) {
    toggleAndPublish(elem[0], property);

    // If no property is set, just flip the visual style and emit
    // a change event on center.
  } else {
      setState(elem[0], !elem.hasClass(CLASSNAME_ENABLED));
    }
}

/**
 * Handle a keyboard event on a slider node.
 *
 * @param {KeyboardEvent} event Event object.
 * @param {Elements} elem An elements DOM node for the slider.
 */
function handleKeyUp(event, elem) {
  if (event.keyCode !== SPACE_KEY_CODE) {
    return;
  }

  handleClick(event, elem);
};

/**
 * Handle when a slider-set event happens on center.
 *
 * @param {Object} event An object with data.
 */
function onSliderSet(event) {
  if (!event.id) return;

  var elem = $('[data-' + ATTR_SLIDER + '=' + event.id + ']');
  if (!elem) return;

  var node = elem[0];
  var enabled = !!event.enabled;

  var property = elem.data(ATTR_PROPERTY);

  if (property) {
    toggleAndPublish(node, property, enabled);
  } else {
    setState(node, enabled);
  }
}

/**
 * Update the live model with new data. If no data-uri is found from
 * the passed node, nothing happens.
 *
 * @param {HTMLElement} node A DOM node for the slider.
 * @param {string} property A property name on the model.
 * @param {boolean=} opt_enabled Optional boolean flag. If true, this
 *     sets it to true, if false this sets it to false. If not provided,
 *     this sets it to the opposite of the current value in the model.
 */
function toggleAndPublish(node, property, opt_enabled) {
  var uri = getUriFromNode(node);
  if (!uri) return;

  var model = live(uri);

  // If the model doesn't have a current value, we can't safely
  // set a new value without maybe being wrong.
  var value = model.get(property);
  if (value === undefined) return;

  var newValue = opt_enabled === undefined ? !value : opt_enabled;

  var data = {};
  data[property] = newValue;

  // Publishing the new value to the model will trigger the update
  // handler added here in this module to update the visual state
  // of the button.
  model.publish(data);
}

/**
 * Update the state of one slider node.
 *
 * @param {HTMLElement} node A DOM node for the slider.
 */
function updateNode(node) {

  // Don't handle the same URI and node twice.
  if (storedNodes.indexOf(node) > -1) return;
  storedNodes.push(node);

  var elem = $(node);
  var property = elem.data(ATTR_PROPERTY);
  var allowedProperty = elem.data(ATTR_ALLOWED);

  if (!property) return;

  var uri = getUriFromNode(node);
  if (!uri) return;

  var model = live(uri);

  model.get(property, function (error, value) {
    if (error) throw error;

    setState(node, !!value);

    model.on('update', function (properties) {
      if (property in properties) {
        setState(node, !!properties[property]);
      }

      if (allowedProperty && allowedProperty in properties) {
        disableNode(node, !properties[allowedProperty]);
      }
    });
  });
}

/**
 * Update a slider node based on a value.
 *
 * @param {HTMLElement} node A DOM node for a slider.
 * @param {boolean} enabled True if should be enabled, false otherwise.
 */
function setState(node, enabled) {
  updateNodeWithValue(node, enabled);
  emitUpdate(node, enabled);
}

/**
 * Update a slider node based on a value.
 *
 * @param {HTMLElement} node A DOM node for a slider.
 * @param {boolean} enabled True if should be enabled, false otherwise.
 */
function updateNodeWithValue(node, enabled) {
  var elem = $(node);
  if (enabled) {
    elem.addClass(CLASSNAME_ENABLED);
  } else {
    elem.removeClass(CLASSNAME_ENABLED);
  }
}

/**
 * Update a slider node based on whether is disabled
 *
 * @param {HTMLElement} node A DOM node for a slider.
 * @param {boolean} disabled True if should be disabled, false otherwise.
 */
function disableNode(node, disabled) {
  var elem = $(node);
  if (disabled) {
    elem.addClass(CLASSNAME_DISABLED);
  } else {
    elem.removeClass(CLASSNAME_DISABLED);
  }
}

/**
 * Emit a change event on center. It will have the following format:
 * {
 *   element: HTMLElement,
 *   id: 'id from data-slider attribute' || null,
 *   enabled: true // the new value
 * }
 *
 * @param {HTMLElement} node A DOM node for a slider.
 * @param {boolean} enabled True if enabled, false otherwise.
 */
function emitUpdate(node, enabled) {
  var id = $(node).data(ATTR_SLIDER) || null;
  center.emit('slider-change', {
    element: node,
    id: id,
    enabled: enabled
  });
}

/**
 * Get a URI from a node.
 *
 * @param {HTMLElement} node A DOM node.
 *
 * @return {string?} A URI string or null if not found.
 */
function getUriFromNode(node) {
  var stateNode = node.closest('[data-uri]');
  if (!stateNode) return null;
  return stateNode.getAttribute('data-uri');
}

var isAttached = false;

/**
 * Update the module based on the current DOM state.
 *
 * @param {HTMLElement=} opt_node Optional DOM node to make changes inside.
 */
exports.update = function (opt_node) {
  if (!isAttached) return;

  var nodes = $(opt_node || document).search(SELECTOR_SLIDER);
  if (!nodes) return;

  nodes.forEach(updateNode);
};

/**
 * Attach event listeners etc.
 */
exports.attach = function () {
  if (isAttached) return;
  isAttached = true;

  var doc = $(document);
  doc.delegate('click', SELECTOR_SLIDER, handleClick);
  doc.delegate('keyup', SELECTOR_SLIDER, handleKeyUp);

  center.on('slider-set', onSliderSet);
};

/**
 * Detach event listeners etc.
 */
exports.detach = function () {
  if (!isAttached) return;
  isAttached = false;

  var doc = $(document);
  doc.undelegate('click', SELECTOR_SLIDER, handleClick);
  doc.undelegate('keyup', SELECTOR_SLIDER, handleKeyUp);

  center.off('slider-set', onSliderSet);
};

},{"../spotify-elements":149,"../spotify-live":217,"./center":153}],163:[function(require,module,exports){
(function (global){
'use strict';

exports.init = function () {
  require('./expose-debug-global').expose(global, 'bridge', require('../spotify-bridge-request'));
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-bridge-request":144,"./expose-debug-global":165}],164:[function(require,module,exports){
(function (global){
'use strict';

exports.init = function () {
  require('./expose-debug-global').expose(global, 'cosmos', require('spotify-cosmos-api'));
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./expose-debug-global":165,"spotify-cosmos-api":357}],165:[function(require,module,exports){
'use strict';

exports.expose = function (global, name, object) {
  if (global.__spotify && global.__spotify.developer_mode) {
    Object.defineProperty(global, name, {
      get: function get() {
        try {
          throw new Error();
        } catch (error) {
          if (!/injectedscript/i.test(error.stack)) {
            throw new Error('window.' + name + ' should only be accessed from the console');
          }
        }
        return object;
      },
      enumerable: true,
      configurable: true
    });
  }
};

},{}],166:[function(require,module,exports){
(function (global){
'use strict';

exports.init = function () {
  require('./expose-debug-global').expose(global, 'live', require('../spotify-live'));
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-live":217,"./expose-debug-global":165}],167:[function(require,module,exports){
module.exports = {
  "Album": "Album",
  "AndMore": "und {0} weitere",
  "Artist": "Künstler",
  "By": "von",
  "Create Similar Playlist": "Ähnliche Playlist erstellen",
  "Filter": "Filter",
  "Follow": "Folgen",
  "Follower": "Follower",
  "FollowersLabel": "Followers",
  "Following": "Folge ich",
  "FollowingLabel": "Folge ich",
  "ListenersLabel": "Monatliche Hörer",
  "FollowsYou": "Folgt dir",
  "HoldToPreview": "Zum Reinhören gedrückt halten",
  "ListenCount": "{0} Mal abgespielt",
  "ListenReactionMulti": "{0} Hörer in Deinem Netzwerk",
  "ListenReactionSingle": "{0} hört sich das an",
  "LocalFile": "Lokale Datei",
  "More": "Mehr",
  "Pause": "Pause",
  "Play": "Play",
  "Playlist": "Playlist",
  "PressEnterToPlay": "Drück die Eingabetaste zum Abspielen",
  "Popularity": "Beliebtheit",
  "Remove": "Entfernen",
  "RemoveYourMusic": "Aus \"Deine Musik\" entfernen",
  "Save": "Speichern",
  "SaveYourMusic": "In \"Deine Musik\" speichern",
  "Saved": "Gespeichert",
  "ShufflePlay": "Shuffle",
  "Song": "Song",
  "StartRadio": "Radio starten",
  "Time": "Dauer",
  "Toplist": "Top-Songs",
  "Track": "Song",
  "Unfollow": "Nicht mehr folgen",
  "User": "Benutzer",
  "ViewAll": "Mehr Darstellung",
  "HoursShort": "{0} Std.",
  "MinutesShort": "{0} Min.",
  "SecondsShort": "{0} Sek.",
  "ErrorTitle": "Bei der Anzeige dieser Ansicht ist ein Fehler aufgetreten!",
  "ErrorMessage": "Diese Ansicht ist entweder nicht vorhanden oder es ist ein Fehler aufgetreten.",
  "OfflineTitle": "Diese Ansicht ist offline nicht verfügbar.",
  "OfflineMessage": "Geh zum Laden online."
};
},{}],168:[function(require,module,exports){
module.exports = {
  "Album": "Άλμπουμ",
  "AndMore": "και άλλοι {0}",
  "Artist": "Καλλιτέχνης",
  "By": "από",
  "Create Similar Playlist": "Δημιουργία παρόμοιας playlist",
  "Filter": "Φίλτρο",
  "Follow": "Ακολούθησε",
  "Follower": "Οπαδός",
  "FollowersLabel": "Οπαδοί",
  "Following": "Aκολουθείται",
  "FollowingLabel": "Aκολουθείται",
  "ListenersLabel": "Μηνιαίοι ακροατές",
  "FollowsYou": "Σε ακολουθεί",
  "HoldToPreview": "Πάτησε και κράτησε πατημένο για προεπισκόπηση",
  "ListenCount": "{0} αναπαραγωγές",
  "ListenReactionMulti": "{0} ακροατές στο δίκτυό σου",
  "ListenReactionSingle": "Ο χρήστης {0} ακούει αυτό",
  "LocalFile": "Τοπικό αρχείο",
  "More": "Περισσότερα",
  "Pause": "Παύση",
  "Play": "Αναπαραγωγή",
  "Playlist": "Λίστα",
  "PressEnterToPlay": "Πάτησε Enter για αναπαραγωγή",
  "Popularity": "Δημοφιλία",
  "Remove": "Αφαίρεση",
  "RemoveYourMusic": "Αφαίρεση από τη Mουσική σου",
  "Save": "Αποθήκευση",
  "SaveYourMusic": "Αποθήκευση στη Mουσική σου",
  "Saved": "Αποθηκεύτηκε",
  "ShufflePlay": "Τυχαία αναπαραγωγή",
  "Song": "Τραγούδι",
  "StartRadio": "Έναρξη ραδιοφώνου",
  "Time": "Διάρκεια",
  "Toplist": "Κορυφαία τραγούδια",
  "Track": "Τραγούδι",
  "Unfollow": "Άρση ακολούθησης",
  "User": "Χρήστης",
  "ViewAll": "Δες τα όλα",
  "HoursShort": "{0} ώρα",
  "MinutesShort": "{0} λεπ.",
  "SecondsShort": "{0} δευτ.",
  "ErrorTitle": "Προέκυψε σφάλμα κατά την προβολή αυτής της οθόνης!",
  "ErrorMessage": "Η συγκεκριμένη προβολή δεν υπάρχει ή προέκυψε κάποιο σφάλμα.",
  "OfflineTitle": "Αυτή η προβολή δεν είναι διαθέσιμη εκτός σύνδεσης!",
  "OfflineMessage": "Συνδέσου στο διαδίκτυο για να πραγματοποιηθεί φόρτωση."
};
},{}],169:[function(require,module,exports){
module.exports = {
  "Album": "Album",
  "AndMore": "and {0} more",
  "Artist": "Artist",
  "By": "by",
  "Create Similar Playlist": "Create Similar Playlist",
  "Filter": "Filter",
  "Follow": "Follow",
  "Follower": "Follower",
  "FollowersLabel": "Followers",
  "Following": "Following",
  "FollowingLabel": "Following",
  "ListenersLabel": "Monthly Listeners",
  "FollowsYou": "Follows You",
  "HoldToPreview": "Click and Hold to Preview",
  "ListenCount": "{0} plays",
  "ListenReactionMulti": "{0} listeners in your network",
  "ListenReactionSingle": "{0} listens to this",
  "LocalFile": "Local File",
  "More": "More",
  "Pause": "Pause",
  "Play": "Play",
  "Playlist": "Playlist",
  "PressEnterToPlay": "Press Enter to play",
  "Popularity": "Popularity",
  "Remove": "Remove",
  "RemoveYourMusic": "Remove from Your Music",
  "Save": "Save",
  "SaveYourMusic": "Save to Your Music",
  "Saved": "Saved",
  "ShufflePlay": "Shuffle Play",
  "Song": "Song",
  "StartRadio": "Start Radio",
  "Time": "Time",
  "Toplist": "Top songs",
  "Track": "Song",
  "Unfollow": "Unfollow",
  "User": "User",
  "ViewAll": "View All",
  "HoursShort": "{0} hr",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} sec",
  "ErrorTitle": "There was a problem displaying this view!",
  "ErrorMessage": "This view either does not exist or an error occurred.",
  "OfflineTitle": "This view is not available offline!",
  "OfflineMessage": "Please go online to load."
}
;
},{}],170:[function(require,module,exports){
module.exports = {
  "Album": "Álbum",
  "AndMore": "y {0} más",
  "Artist": "Artista",
  "By": "por",
  "Create Similar Playlist": "Crear playlist similar",
  "Filter": "Filtrar",
  "Follow": "Seguir",
  "Follower": "Seguidor",
  "FollowersLabel": "Seguidores",
  "Following": "Siguiendo",
  "FollowingLabel": "Siguiendo",
  "ListenersLabel": "Oyentes mensuales",
  "FollowsYou": "Te sigue",
  "HoldToPreview": "Haz clic y mantén pulsado para oír la muestra preliminar",
  "ListenCount": "{0} reproducciones",
  "ListenReactionMulti": "{0} oyentes en tu red",
  "ListenReactionSingle": "{0} escucha esto",
  "LocalFile": "Archivo local",
  "More": "Más",
  "Pause": "Pausa",
  "Play": "Reproducir",
  "Playlist": "Lista",
  "PressEnterToPlay": "Presiona Enter para reproducir",
  "Popularity": "Popularidad",
  "Remove": "Eliminar",
  "RemoveYourMusic": "Eliminar de Tu Música",
  "Save": "Guardar",
  "SaveYourMusic": "Guardar en Tu Música",
  "Saved": "Guardado",
  "ShufflePlay": "Aleatoria",
  "Song": "Canción",
  "StartRadio": "Comenzar Radio",
  "Time": "Tiempo",
  "Toplist": "Canciones más reproducidas",
  "Track": "Canción",
  "Unfollow": "Dejar de seguir",
  "User": "Usuario",
  "ViewAll": "Ver todos",
  "HoursShort": "{0} hr",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} seg",
  "ErrorTitle": "Hubo un problema al mostrar esta vista.",
  "ErrorMessage": "Puede ser que esta vista no exista, o bien, que haya ocurrido un error.",
  "OfflineTitle": "Esta vista no está disponible sin conexión. ",
  "OfflineMessage": "Conéctate a la red para cargar."
};
},{}],171:[function(require,module,exports){
module.exports = {
  "Album": "Álbum",
  "AndMore": "y {0} más",
  "Artist": "Artista",
  "By": "por",
  "Create Similar Playlist": "Crear playlist similar",
  "Filter": "Filtrar",
  "Follow": "Seguir",
  "Follower": "Seguidor",
  "FollowersLabel": "Seguidores",
  "Following": "Siguiendo",
  "FollowingLabel": "Siguiendo",
  "ListenersLabel": "Oyentes mensuales",
  "FollowsYou": "Te sigue",
  "HoldToPreview": "Pulsa y mantén pulsado para oír la muestra preliminar",
  "ListenCount": "{0} reproducciones",
  "ListenReactionMulti": "{0} oyentes en tu red",
  "ListenReactionSingle": "{0} escucha esto",
  "LocalFile": "Archivo local",
  "More": "Más",
  "Pause": "Pausar",
  "Play": "Reproducir",
  "Playlist": "Lista",
  "PressEnterToPlay": "Pulsa Intro para reproducir",
  "Popularity": "Popularidad",
  "Remove": "Retirar",
  "RemoveYourMusic": "Eliminar de Tu música",
  "Save": "Guardar",
  "SaveYourMusic": "Guardar en Tu música",
  "Saved": "Guardada",
  "ShufflePlay": "Aleatoria",
  "Song": "Canción",
  "StartRadio": "Comenzar radio",
  "Time": "Tiempo",
  "Toplist": "Canciones más escuchadas",
  "Track": "Canción",
  "Unfollow": "Dejar de seguir",
  "User": "Usuario",
  "ViewAll": "Ver todos",
  "HoursShort": "{0} hr",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} seg",
  "ErrorTitle": "Se ha producido un problema al mostrar esta vista.",
  "ErrorMessage": "Esta vista no existe o se ha producido un error.",
  "OfflineTitle": "Esta vista no está disponible sin conexión. ",
  "OfflineMessage": "Por favor, conéctate para cargar."
};
},{}],172:[function(require,module,exports){
module.exports = {
  "Album": "Albumi",
  "AndMore": "ja {0} muuta",
  "Artist": "Artisti",
  "By": "tekijältä",
  "Create Similar Playlist": "Luo samankaltainen soittolista",
  "Filter": "Suodatin",
  "Follow": "Seuraa",
  "Follower": "Seuraaja",
  "FollowersLabel": "Seuraajat",
  "Following": "Seurataan",
  "FollowingLabel": "Seurataan",
  "ListenersLabel": "Kuuntelijat kuukauden aikana",
  "FollowsYou": "Seuraa sinua",
  "HoldToPreview": "Kuuntele pätkä pitämällä tätä painettuna",
  "ListenCount": "{0} toistoa",
  "ListenReactionMulti": "{0} kuuntelijaa verkostossasi",
  "ListenReactionSingle": "{0} kuuntelee tätä",
  "LocalFile": "Paikallinen tiedosto",
  "More": "Lisää",
  "Pause": "Tauko",
  "Play": "Toista",
  "Playlist": "Soittolista",
  "PressEnterToPlay": "Toista painamalla Enter-näppäintä",
  "Popularity": "Suosio",
  "Remove": "Poista",
  "RemoveYourMusic": "Poista Omasta musiikista",
  "Save": "Tallenna",
  "SaveYourMusic": "Tallenna Omaan musiikkiin",
  "Saved": "Tallennettu",
  "ShufflePlay": "Satunnaistoisto",
  "Song": "Kappale",
  "StartRadio": "Käynnistä radio",
  "Time": "Kesto",
  "Toplist": "Suosituimmat kappaleet",
  "Track": "Kappale",
  "Unfollow": "Lopeta seuraaminen",
  "User": "Käyttäjä",
  "ViewAll": "Näytä kaikki",
  "HoursShort": "{0} h",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} s",
  "ErrorTitle": "Tämän näkymän näyttämisessä on ongelmia.",
  "ErrorMessage": "Tätä näkymää ei ole, tai tapahtui virhe.",
  "OfflineTitle": "Tätä näkymää ei voi käyttää offline-tilassa!",
  "OfflineMessage": "Siirry online-tilaan, jotta voit ladata."
};
},{}],173:[function(require,module,exports){
module.exports = {
  "Album": "Album",
  "AndMore": "et {0} autres",
  "Artist": "Artiste",
  "By": "par",
  "Create Similar Playlist": "Créer une liste de lecture semblable",
  "Filter": "Filtrer",
  "Follow": "Suivre",
  "Follower": "Abonné",
  "FollowersLabel": "Abonné",
  "Following": "Suivis",
  "FollowingLabel": "Suivis",
  "ListenersLabel": "Auditeurs mensuels",
  "FollowsYou": "Vous suit",
  "HoldToPreview": "Cliquez longuement pour avoir un aperçu",
  "ListenCount": "{0} écoutes",
  "ListenReactionMulti": "{0} auditeurs dans votre réseau",
  "ListenReactionSingle": "{0} écoute ceci",
  "LocalFile": "Fichier local",
  "More": "Plus",
  "Pause": "Pause",
  "Play": "Lecture",
  "Playlist": "Playlist",
  "PressEnterToPlay": "Appuyez sur Entrée pour faire la lecture",
  "Popularity": "Popularité",
  "Remove": "Supprimer",
  "RemoveYourMusic": "Supprimer de Votre musique",
  "Save": "Sauvegarder",
  "SaveYourMusic": "Enregistrer dans Votre musique",
  "Saved": "Sauvegardé",
  "ShufflePlay": "Lecture aléatoire",
  "Song": "Titre",
  "StartRadio": "Lancer la radio",
  "Time": "Durée",
  "Toplist": "Meilleures chansons",
  "Track": "Titre",
  "Unfollow": "Ne plus suivre",
  "User": "Utilisateur",
  "ViewAll": "Voir tout",
  "HoursShort": "{0} h",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} s",
  "ErrorTitle": "Un problème est survenu lors du chargement de cet affichage!",
  "ErrorMessage": "L'affichage n'existe pas ou une erreur s'est produite.",
  "OfflineTitle": "Cette vue n'est pas disponible hors ligne!",
  "OfflineMessage": "Veuillez accéder à Internet pour charger le contenu."
};
},{}],174:[function(require,module,exports){
module.exports = {
  "Album": "Album",
  "AndMore": "et {0} autres",
  "Artist": "Artiste",
  "By": "par",
  "Create Similar Playlist": "Créer une playlist similaire",
  "Filter": "Filtre",
  "Follow": "S'abonner",
  "Follower": "Abonné",
  "FollowersLabel": "Abonnés",
  "Following": "Abonné",
  "FollowingLabel": "Abonné",
  "ListenersLabel": "Nombres de personnes qui écoutent par mois",
  "FollowsYou": "Est abonné à vous",
  "HoldToPreview": "Cliquez longuement pour avoir un aperçu",
  "ListenCount": "{0} écoutes",
  "ListenReactionMulti": "{0} auditeurs dans votre réseau",
  "ListenReactionSingle": "{0} écoute ceci.",
  "LocalFile": "Fichier local",
  "More": "Plus",
  "Pause": "Pause",
  "Play": "Lire",
  "Playlist": "Playlist",
  "PressEnterToPlay": "Appuyez sur Entrée pour écouter",
  "Popularity": "Popularité",
  "Remove": "Supprimer",
  "RemoveYourMusic": "Supprimer de Ma musique",
  "Save": "Sauvegarder",
  "SaveYourMusic": "Sauvegarder dans Ma musique",
  "Saved": "Sauvegardé",
  "ShufflePlay": "Aléatoire",
  "Song": "Titre",
  "StartRadio": "Ecouter la radio",
  "Time": "Durée",
  "Toplist": "Top titres",
  "Track": "Titre",
  "Unfollow": "Se désabonner",
  "User": "Utilisateur",
  "ViewAll": "Présentation tout",
  "HoursShort": "{0} h",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} s",
  "ErrorTitle": "Problème d'affichage !",
  "ErrorMessage": "Cet affichage n'existe pas ou une erreur s'est produite.",
  "OfflineTitle": "Cet affichage n'est pas disponible hors connexion.",
  "OfflineMessage": "Connectez-vous pour procéder au chargement."
};
},{}],175:[function(require,module,exports){
module.exports = {
  "Album": "Album",
  "AndMore": "és még {0} felhasználó",
  "Artist": "Előadó",
  "By": "tőle:",
  "Create Similar Playlist": "Hasonló műsorlista létrehozása",
  "Filter": "Szűrő",
  "Follow": "Követés",
  "Follower": "Követő",
  "FollowersLabel": "Követők",
  "Following": "Követések",
  "FollowingLabel": "Követések",
  "ListenersLabel": "Hallgatók havonta",
  "FollowsYou": "Téged követ",
  "HoldToPreview": "Tartsd nyomva a belehallgatáshoz",
  "ListenCount": "{0} lejátszás",
  "ListenReactionMulti": "{0} ismerősöd hallgatta meg",
  "ListenReactionSingle": "{0} már meghallgatta",
  "LocalFile": "Helyi fájl",
  "More": "Több",
  "Pause": "Szünet",
  "Play": "Lejátszás",
  "Playlist": "Lejátszási lista",
  "PressEnterToPlay": "Lejátszás az Enterrel",
  "Popularity": "Népszerűség",
  "Remove": "Eltávolítás",
  "RemoveYourMusic": "Törlés a Zenéid közül",
  "Save": "Mentés",
  "SaveYourMusic": "Mentés a Zenéid közé",
  "Saved": "Mentett",
  "ShufflePlay": "Lejátszás keverve",
  "Song": "Dal",
  "StartRadio": "Rádió bekapcsolása",
  "Time": "Idő",
  "Toplist": "Toplista",
  "Track": "Dal",
  "Unfollow": "Nem követem",
  "User": "Felhasználó",
  "ViewAll": "Mindent mutat",
  "HoursShort": "{0} óra",
  "MinutesShort": "{0} perc",
  "SecondsShort": "{0} mp",
  "ErrorTitle": "Egy hiba miatt nem jeleníthető meg ez az oldal",
  "ErrorMessage": "A kért nézet nem létezik, vagy valamilyen műszaki hiba történt.",
  "OfflineTitle": "Ez a nézet internetkapcsolat nélkül nem érhető el.",
  "OfflineMessage": "Csatlakozz az internethez, majd indítsd el."
};
},{}],176:[function(require,module,exports){
module.exports = {
  "Album": "Album",
  "AndMore": "dan {0} lagi",
  "Artist": "Artis",
  "By": "menurut",
  "Create Similar Playlist": "Buat Playlist Serupa",
  "Filter": "Filter",
  "Follow": "Ikuti",
  "Follower": "Pengikut",
  "FollowersLabel": "Pengikut",
  "Following": "Mengikuti",
  "FollowingLabel": "Mengikuti",
  "ListenersLabel": "Pendengar Bulanan",
  "FollowsYou": "Mengikutimu",
  "HoldToPreview": "Klik dan Tahan untuk Pratinjau",
  "ListenCount": "{0} permainan",
  "ListenReactionMulti": "{0} pendengar di jaringanmu",
  "ListenReactionSingle": "{0} mendengarkan ini",
  "LocalFile": "File Lokal",
  "More": "Lainnya",
  "Pause": "Jeda",
  "Play": "Play",
  "Playlist": "Playlist",
  "PressEnterToPlay": "Tekan Enter untuk memainkan",
  "Popularity": "Popularitas",
  "Remove": "Hapus",
  "RemoveYourMusic": "Hapus dari Musik Kamu",
  "Save": "Simpan",
  "SaveYourMusic": "Simpan ke Musik Kamu",
  "Saved": "Tersimpan",
  "ShufflePlay": "Pemutaran Acak",
  "Song": "Lagu",
  "StartRadio": "Mulai Radio",
  "Time": "Waktu",
  "Toplist": "Lagu teratas",
  "Track": "Lagu",
  "Unfollow": "Berhenti mengikuti",
  "User": "Pengguna",
  "ViewAll": "Lihat Semua",
  "HoursShort": "{0} jam",
  "MinutesShort": "{0} mnt",
  "SecondsShort": "{0} dtk",
  "ErrorTitle": "Ada masalah saat menampilkan tampilan ini!",
  "ErrorMessage": "Tampilan ini tidak ada atau terjadi kesalahan.",
  "OfflineTitle": "Tampilan ini tidak tersedia offline.",
  "OfflineMessage": "Alihkan ke online untuk memuat."
};
},{}],177:[function(require,module,exports){
module.exports = {
  "Album": "Album",
  "AndMore": "e altri {0}",
  "Artist": "Artista",
  "By": "per",
  "Create Similar Playlist": "Crea playlist simile",
  "Filter": "Filtra",
  "Follow": "Segui",
  "Follower": "Follower",
  "FollowersLabel": "Follower",
  "Following": "Following",
  "FollowingLabel": "Following",
  "ListenersLabel": "Ascoltatori questo mese",
  "FollowsYou": "Ti segue",
  "HoldToPreview": "Tieni premuto per un'anteprima",
  "ListenCount": "{0} riproduzioni",
  "ListenReactionMulti": "{0} ascoltatori nella tua rete",
  "ListenReactionSingle": "{0} ascolta questo",
  "LocalFile": "File locale",
  "More": "Più",
  "Pause": "Pausa",
  "Play": "Play",
  "Playlist": "Playlist",
  "PressEnterToPlay": "Premi Invio per riprodurre",
  "Popularity": "Popolarità",
  "Remove": "Rimuovi",
  "RemoveYourMusic": "Elimina da La tua musica",
  "Save": "Salva",
  "SaveYourMusic": "Salva in La tua musica",
  "Saved": "Salvato",
  "ShufflePlay": "Riproduzione shuffle",
  "Song": "Brano",
  "StartRadio": "Crea una radio",
  "Time": "Durata",
  "Toplist": "Brani top",
  "Track": "Brano",
  "Unfollow": "Non seguire più",
  "User": "Utente",
  "ViewAll": "Visualizza tutto",
  "HoursShort": "{0} ore",
  "MinutesShort": "{0} min.",
  "SecondsShort": "{0} sec",
  "ErrorTitle": "Si è verificato un errore in questa vista.",
  "ErrorMessage": "La vista non esiste o si è verificato un errore.",
  "OfflineTitle": "Questa vista non è disponibile offline.",
  "OfflineMessage": "Passa online per caricare."
};
},{}],178:[function(require,module,exports){
module.exports = {
  "Album": "アルバム",
  "AndMore": "その他{0}人",
  "Artist": "アーティスト",
  "By": "/",
  "Create Similar Playlist": "同様のプレイリストを作成",
  "Filter": "フィルタ",
  "Follow": "フォロー",
  "Follower": "フォロワー",
  "FollowersLabel": "フォロワー",
  "Following": "フォロー中",
  "FollowingLabel": "フォロー中",
  "ListenersLabel": "今月のリスナー",
  "FollowsYou": "あなたをフォローしています",
  "HoldToPreview": "プレビューするには、クリックを押しします",
  "ListenCount": "{0}回再生",
  "ListenReactionMulti": "ネットワーク内で{0}人が聴いています",
  "ListenReactionSingle": "{0}さんはこれを聴いています",
  "LocalFile": "ローカルファイル",
  "More": "詳細",
  "Pause": "一時停止",
  "Play": "再生",
  "Playlist": "プレイリスト",
  "PressEnterToPlay": "再生するにはEnterキーを押します",
  "Popularity": "人気",
  "Remove": "削除",
  "RemoveYourMusic": "My Musicから削除",
  "Save": "保存",
  "SaveYourMusic": "My Musicに保存",
  "Saved": "保存済み",
  "ShufflePlay": "シャッフルプレイ",
  "Song": "ソング",
  "StartRadio": "Radioを開始",
  "Time": "時間",
  "Toplist": "トップ曲",
  "Track": "ソング",
  "Unfollow": "フォローをやめる",
  "User": "ユーザー",
  "ViewAll": "すべて表示",
  "HoursShort": "{0} 時間",
  "MinutesShort": "{0} 分",
  "SecondsShort": "{0} 秒",
  "ErrorTitle": "このビューを表示しようとしているときに問題が発生しました。",
  "ErrorMessage": "このビューが存在しないか、エラーが発生しました。",
  "OfflineTitle": "このビューはオフラインでは使用できません。",
  "OfflineMessage": "ロードするには、インターネットに接続してください。"
};
},{}],179:[function(require,module,exports){
module.exports = {
  "Album": "Album",
  "AndMore": "en {0} meer",
  "Artist": "Artiest",
  "By": "van",
  "Create Similar Playlist": "Vergelijkbare afspeellijst maken",
  "Filter": "Filter",
  "Follow": "Volgen",
  "Follower": "Volger",
  "FollowersLabel": "Volgers",
  "Following": "Volgend",
  "FollowingLabel": "Volgend",
  "ListenersLabel": "Luisteraars per maand",
  "FollowsYou": "Volgt jou",
  "HoldToPreview": "Klikken en vasthouden om een stukje te horen",
  "ListenCount": "{0} keer afgespeeld",
  "ListenReactionMulti": "{0} luisteraars in jouw netwerk",
  "ListenReactionSingle": "{0} luistert hiernaar",
  "LocalFile": "Lokaal bestand",
  "More": "Meer",
  "Pause": "Pauze",
  "Play": "Afspelen",
  "Playlist": "Afspeellijst",
  "PressEnterToPlay": "Druk op Enter om af te spelen",
  "Popularity": "Populariteit",
  "Remove": "Verwijderen",
  "RemoveYourMusic": "Verwijderen uit Jouw Muziek",
  "Save": "Opslaan",
  "SaveYourMusic": "Opslaan in Jouw Muziek",
  "Saved": "Opgeslagen",
  "ShufflePlay": "Shuffle",
  "Song": "Nummer",
  "StartRadio": "Radio starten",
  "Time": "Tijd",
  "Toplist": "Topnummers",
  "Track": "Nummer",
  "Unfollow": "Niet meer volgen",
  "User": "Gebruiker",
  "ViewAll": "Alles bekijken",
  "HoursShort": "{0} uur",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} sec",
  "ErrorTitle": "Er is een fout opgetreden bij het laden van deze weergave.",
  "ErrorMessage": "Deze weergave bestaat niet of er is een fout opgetreden.",
  "OfflineTitle": "Deze weergave is offline niet beschikbaar!",
  "OfflineMessage": "Ga online om te laden."
};
},{}],180:[function(require,module,exports){
module.exports = {
  "Album": "Album",
  "AndMore": "i {0} więcej",
  "Artist": "Wykonawca",
  "By": "według",
  "Create Similar Playlist": "Utwórz podobną playlistę",
  "Filter": "Filtruj",
  "Follow": "Obserwuj",
  "Follower": "Obserwujący",
  "FollowersLabel": "Obserwatorzy",
  "Following": "Obserwowana",
  "FollowingLabel": "Obserwowana",
  "ListenersLabel": "Słuchacze w tym miesiącu",
  "FollowsYou": "Obserwuje Cię",
  "HoldToPreview": "Aby odsłuchać, kliknij i przytrzymaj.",
  "ListenCount": "Liczba odtworzeń: {0}",
  "ListenReactionMulti": "Liczba słuchaczy w Twojej sieci: {0}",
  "ListenReactionSingle": "Użytkownik {0} słucha tego",
  "LocalFile": "Plik lokalny",
  "More": "Więcej",
  "Pause": "Pauza",
  "Play": "Odtwórz",
  "Playlist": "Playlista",
  "PressEnterToPlay": "Naciśnij Enter, aby odtworzyć",
  "Popularity": "Popularność",
  "Remove": "Usuń",
  "RemoveYourMusic": "Usuń z kolekcji Twoja muzyka",
  "Save": "Zapisz",
  "SaveYourMusic": "Zapisz w kolekcji Twoja muzyka",
  "Saved": "Zapisany",
  "ShufflePlay": "Odtwarzanie losowe",
  "Song": "Utwór",
  "StartRadio": "Włącz radio",
  "Time": "Czas",
  "Toplist": "Najpopularniejsze utwory",
  "Track": "Utwór",
  "Unfollow": "Przestań obserwować",
  "User": "Użytkownik",
  "ViewAll": "Wyświetl wszystko",
  "HoursShort": "{0} godz.",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} s",
  "ErrorTitle": "Podczas wyświetlania tego widoku wystąpił błąd!",
  "ErrorMessage": "Ten widok nie istnieje lub wystąpił błąd.",
  "OfflineTitle": "Ten widok jest niedostępny w trybie offline. ",
  "OfflineMessage": "Przejdź do trybu online, aby załadować."
};
},{}],181:[function(require,module,exports){
module.exports = {
  "Album": "Álbum",
  "AndMore": "e mais {0}",
  "Artist": "Artista",
  "By": "de",
  "Create Similar Playlist": "Criar playlist similar",
  "Filter": "Filtrar",
  "Follow": "Seguir",
  "Follower": "Seguidor",
  "FollowersLabel": "Seguidores",
  "Following": "Seguindo",
  "FollowingLabel": "Seguindo",
  "ListenersLabel": "Ouvintes mensais",
  "FollowsYou": "Segue você",
  "HoldToPreview": "Clique e segure para a prévia",
  "ListenCount": "{0} reproduções",
  "ListenReactionMulti": "{0} ouvintes na sua rede",
  "ListenReactionSingle": "{0} ouvem isso",
  "LocalFile": "Arquivo local",
  "More": "Mais",
  "Pause": "Pause",
  "Play": "Play",
  "Playlist": "Playlist",
  "PressEnterToPlay": "Pressione Enter para tocar",
  "Popularity": "Popularidade",
  "Remove": "Remover",
  "RemoveYourMusic": "Remover de Suas músicas",
  "Save": "Salvar",
  "SaveYourMusic": "Salvar em Suas músicas",
  "Saved": "Salvo",
  "ShufflePlay": "Ordem aleatória",
  "Song": "Música",
  "StartRadio": "Abrir rádio",
  "Time": "Tempo",
  "Toplist": "Músicas mais tocadas",
  "Track": "Música",
  "Unfollow": "Deixar de seguir",
  "User": "Usuário",
  "ViewAll": "Ver tudo",
  "HoursShort": "{0} h",
  "MinutesShort": "{0} m",
  "SecondsShort": "{0} s",
  "ErrorTitle": "Tivemos um problema ao mostrar esta exibição!",
  "ErrorMessage": "A exibição não existe ou ocorreu um erro.",
  "OfflineTitle": "Essa visualização não está disponível offline!",
  "OfflineMessage": "Fique online para carregar."
};
},{}],182:[function(require,module,exports){
module.exports = {
  "Album": "Album",
  "AndMore": "och {0} till",
  "Artist": "Artist",
  "By": "av",
  "Create Similar Playlist": "Skapa en liknande spellista",
  "Filter": "Filtrera",
  "Follow": "Följ",
  "Follower": "Följare",
  "FollowersLabel": "Följare",
  "Following": "Följer",
  "FollowingLabel": "Följer",
  "ListenersLabel": "Lyssnare per månad",
  "FollowsYou": "Följer dig",
  "HoldToPreview": "Klicka och håll kvar för att förhandslyssna",
  "ListenCount": "{0} uppspelningar",
  "ListenReactionMulti": "{0} lyssnare i ditt nätverk",
  "ListenReactionSingle": "{0} lyssnar på detta",
  "LocalFile": "Lokal fil",
  "More": "Mer",
  "Pause": "Pausa",
  "Play": "Spela upp",
  "Playlist": "Spellista",
  "PressEnterToPlay": "Tryck på Retur om du vill lyssna",
  "Popularity": "Popularitet",
  "Remove": "Ta bort",
  "RemoveYourMusic": "Ta bort från Din Musik",
  "Save": "Spara",
  "SaveYourMusic": "Spara i Din Musik",
  "Saved": "Sparade",
  "ShufflePlay": "Slumpmässig uppspelning",
  "Song": "Låt",
  "StartRadio": "Starta radio",
  "Time": "Tid",
  "Toplist": "Topplåtar",
  "Track": "Låt",
  "Unfollow": "Sluta följa",
  "User": "Användare",
  "ViewAll": "Visa alla",
  "HoursShort": "{0} tim",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} sek",
  "ErrorTitle": "Det uppstod ett fel när den här vyn skulle visas!",
  "ErrorMessage": "Den här vyn finns inte eller så uppstod ett fel.",
  "OfflineTitle": "Den här vyn är inte tillgänglig offline.",
  "OfflineMessage": "Anslut till internet om du vill läsa in appen."
};
},{}],183:[function(require,module,exports){
module.exports = {
  "Album": "Albüm",
  "AndMore": "ve {0} daha",
  "Artist": "Sanatçı",
  "By": "-",
  "Create Similar Playlist": "Benzer Çalma Listesi Oluştur",
  "Filter": "Filtrele",
  "Follow": "Takip Et",
  "Follower": "Takipçi",
  "FollowersLabel": "Takipçiler",
  "Following": "Takip Ediliyor",
  "FollowingLabel": "Takip Ediliyor",
  "ListenersLabel": "Aylık Dinleyici",
  "FollowsYou": "Seni Takip Ediyor",
  "HoldToPreview": "Basılı Tut ve Önizle",
  "ListenCount": "{0} dinleme",
  "ListenReactionMulti": "Ağında {0} dinleyici",
  "ListenReactionSingle": "{0} bunu dinliyor",
  "LocalFile": "Yerel Dosya",
  "More": "Daha fazla",
  "Pause": "Duraklat",
  "Play": "Çal",
  "Playlist": "Çalma listesi",
  "PressEnterToPlay": "Çalmak için Enter'a bas",
  "Popularity": "Popülerlik",
  "Remove": "Çıkar",
  "RemoveYourMusic": "Müziklerin'den çıkar",
  "Save": "Kaydet",
  "SaveYourMusic": "Müziklerin'e kaydet",
  "Saved": "Kaydedildi",
  "ShufflePlay": "Karışık Çal",
  "Song": "Şarkı",
  "StartRadio": "Radyoyu Başlat",
  "Time": "Saat",
  "Toplist": "En çok dinlenen şarkılar",
  "Track": "Şarkı",
  "Unfollow": "Takip Etmeyi Bırak",
  "User": "Kullanıcı",
  "ViewAll": "Tümünü Görüntüle",
  "HoursShort": "{0} sa",
  "MinutesShort": "{0} dk",
  "SecondsShort": "{0} sn",
  "ErrorTitle": "Bu öğe görüntülenirken bir sorun oluştu!",
  "ErrorMessage": "Bu görünüm yok veya bir hata oluştu.",
  "OfflineTitle": "Bu görünüm çevrimdışıyken kullanılamaz!",
  "OfflineMessage": "Yüklemek için lütfen çevrimiçi ol."
};
},{}],184:[function(require,module,exports){
module.exports = {
  "Album": "專輯",
  "AndMore": "還有 {0} 首",
  "Artist": "藝人",
  "By": "－",
  "Create Similar Playlist": "建立相似的播放清單",
  "Filter": "篩選",
  "Follow": "關注",
  "Follower": "粉絲",
  "FollowersLabel": "關注者",
  "Following": "正在關注",
  "FollowingLabel": "正在關注",
  "ListenersLabel": "每月聽眾",
  "FollowsYou": "關注你",
  "HoldToPreview": "按住即可預覽",
  "ListenCount": "播放了 {0} 次",
  "ListenReactionMulti": "在你的社群網路中有 {0} 名聽眾",
  "ListenReactionSingle": "{0} 收聽了這首歌曲",
  "LocalFile": "本機檔案",
  "More": "更多",
  "Pause": "暫停",
  "Play": "播放",
  "Playlist": "播放列表",
  "PressEnterToPlay": "請按 Enter 播放",
  "Popularity": "流行",
  "Remove": "移除",
  "RemoveYourMusic": "從你的音樂中移除",
  "Save": "儲存",
  "SaveYourMusic": "儲存至你的音樂",
  "Saved": "已儲存",
  "ShufflePlay": "隨機播放",
  "Song": "歌曲",
  "StartRadio": "啟用電臺",
  "Time": "時間",
  "Toplist": "當紅歌曲",
  "Track": "歌曲",
  "Unfollow": "取消關注",
  "User": "使用者",
  "ViewAll": "檢視全部",
  "HoursShort": "{0} 小時",
  "MinutesShort": "{0} 分鐘",
  "SecondsShort": "{0} 秒鐘",
  "ErrorTitle": "顯示這個畫面時出現問題。",
  "ErrorMessage": "這個畫面可能不存在或發生錯誤。",
  "OfflineTitle": "離線時無法使用這個檢視！",
  "OfflineMessage": "請上網以載入。"
};
},{}],185:[function(require,module,exports){
module.exports = {
  "Album": "Album",
  "AndMore": "dan {0} lagi",
  "Artist": "Artis",
  "By": "oleh",
  "Create Similar Playlist": "Cipta Senarai Main Serupa",
  "Filter": "Penapis",
  "Follow": "Ikut",
  "Follower": "Pengikut",
  "FollowersLabel": "Pengikut",
  "Following": "Mengikuti",
  "FollowingLabel": "Mengikuti",
  "ListenersLabel": "Pendengar Bulanan",
  "FollowsYou": "Megikuti Anda",
  "HoldToPreview": "Klik dan Tahan untuk Pratonton",
  "ListenCount": "{0} main",
  "ListenReactionMulti": "{0} pendengar dalam rangkaian anda",
  "ListenReactionSingle": "{0} mendengar ini",
  "LocalFile": "Fail Setempat",
  "More": "Lebih banyak",
  "Pause": "Jeda",
  "Play": "Main",
  "Playlist": "Senarai main",
  "PressEnterToPlay": "Tekan Enter untuk main",
  "Popularity": "Populariti",
  "Remove": "Keluarkan",
  "RemoveYourMusic": "Keluarkan daripada Muzik Anda",
  "Save": "Simpan",
  "SaveYourMusic": "Simpan ke Muzik Anda",
  "Saved": "Disimpan",
  "ShufflePlay": "Main Rombak",
  "Song": "Lagu",
  "StartRadio": "Mulakan Radio",
  "Time": "Masa",
  "Toplist": "Lagu popular",
  "Track": "Lagu",
  "Unfollow": "Nyahikut",
  "User": "Pengguna",
  "ViewAll": "Lihat Semua",
  "HoursShort": "{0} jam",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} saat",
  "ErrorTitle": "Terdapat masalah memaparkan paparan ini!",
  "ErrorMessage": "Paparan ini sama ada tidak wujud atau ralat berlaku.",
  "OfflineTitle": "Paparan ini tidak tersedia di luar talian!",
  "OfflineMessage": "Sila ke online untuk memuatkan."
};
},{}],186:[function(require,module,exports){
'use strict';

exports.getVersion = require('./src/version').getVersion;
exports.gridOverlay = require('./src/gridOverlay');

},{"./src/gridOverlay":187,"./src/version":188}],187:[function(require,module,exports){
(function (global){
'use strict';

var cosmos = require('spotify-cosmos-api');

var DEFAULT_GRID_COLOR = 'rgba(251, 74, 131, 0.22)';
var DEFAULT_GRID_COLOR_HIGHLIGHT = 'rgba(251, 74, 131, 0.8)';
var GRID_BASELINE = 8;

var overlayElement = null;
var baselineHighlightElement = null;
var gridColor = '';
var highlightGridColor = '';
var gridModes = ['off', 'column', 'baseline'];
var currentModeIndex = 0;

/**
 * Listen for control messages to toggle the grid when a menu item is clicked
 * or a keyboard shortcut is pressed. This only happens if the user is a global
 * app developer.
 */
function listen() {
  var spotify = global.__spotify;
  var productState = spotify && spotify.product_state;
  var appDeveloperFlag = productState && productState['app-developer'];

  if (appDeveloperFlag === '3' || appDeveloperFlag === '7') {
    cosmos.resolver.subscribe({
      url: 'sp://messages/v1/container/control'
    }, function (error, response) {
      if (error) return;
      var data = response.getJSONBody();
      if (data && data.type === 'toggle_grid') {
        toggle();
      }
    });
  }
}

/**
 * Toggle the grid overlay.
 */
function toggle() {
  var newIndex = currentModeIndex + 1;
  if (newIndex > gridModes.length - 1) {
    newIndex = 0;
  }

  var mode = gridModes[newIndex];

  if (mode === 'off') {
    disable();
  } else {
    enable(mode);
  }
}

/**
 * Enable the grid overlay.
 *
 * @param {string} mode The grid mode to enable, 'column' or 'baseline'.
 */
function enable(mode) {
  if (!mode) {
    return;
  }

  if (gridModes[currentModeIndex] === mode) {
    return;
  }

  currentModeIndex = gridModes.indexOf(mode);

  if (overlayElement && overlayElement.parentNode) {
    overlayElement.parentNode.removeChild(overlayElement);
  }

  if (mode === 'baseline') {
    document.addEventListener('mousemove', onMouseMove, false);
  }

  overlayElement = createOverlayElement();

  document.body.appendChild(overlayElement);
}

/**
 * Disable the grid overlay.
 */
function disable() {
  if (gridModes[currentModeIndex] === 'off') {
    return;
  }

  if (overlayElement && overlayElement.parentNode) {
    overlayElement.parentNode.removeChild(overlayElement);
  }

  currentModeIndex = gridModes.indexOf('off');
  overlayElement = null;
  baselineHighlightElement = null;

  document.removeEventListener('mousemove', onMouseMove, false);
}

/**
 * Set the color used for each grid column or baseline line.
 *
 * @param {string} color Any valid CSS color.
 * @param {string=} highlightColor Any valid CSS color. Can be omitted for
 *     column grid.
 */
function setColor(color, highlightColor) {
  gridColor = color;
  highlightGridColor = highlightColor;
}

/**
 * Reset all state in this module.
 */
function reset() {
  overlayElement = null;
  baselineHighlightElement = null;
  gridColor = '';
  highlightGridColor = '';
  currentModeIndex = 0;
}

/**
 * Mouse move handler that highlights the hovered baseline line.
 *
 * @param {Event} event A mousemove event object.
 *
 * @private
 */
function onMouseMove(event) {
  if (!baselineHighlightElement) {
    baselineHighlightElement = document.createElement('div');
    baselineHighlightElement.className = 'grid-overlay-baseline-highlight';
    baselineHighlightElement.style.backgroundColor = highlightGridColor || DEFAULT_GRID_COLOR_HIGHLIGHT;
    overlayElement.appendChild(baselineHighlightElement);
  }

  // Calculate the Y position for the baseline line closest to the pointer
  var pointerPos = event.clientY + window.scrollY;
  var yLineAbove = Math.floor(pointerPos / GRID_BASELINE) * GRID_BASELINE;
  var y = yLineAbove + (pointerPos % GRID_BASELINE > 4 ? GRID_BASELINE : 0);

  baselineHighlightElement.style.top = y - 1 + 'px';
}

/**
 * Create the DOM nodes needed for the overlay, with the correct class names
 * and styles.
 *
 * @return {HTMLElement} The container element for the overlay.
 *
 * @private
 */
function createOverlayElement() {
  var color = gridColor || DEFAULT_GRID_COLOR;

  var container = document.createElement('div');
  container.className = 'grid-overlay container';

  if (gridModes[currentModeIndex] === 'column') {
    var row = document.createElement('div');
    row.className = 'grid-overlay-row row';
    container.appendChild(row);

    var sizeLabel = createSizeLabel();
    container.appendChild(sizeLabel);

    var columnClassNames = 'col-xs-1 col-sm-1 col-md-1 col-lg-1';

    for (var i = 0; i < 12; i++) {
      var column = document.createElement('div');
      column.className = 'grid-overlay-col-' + (i + 1) + ' ' + columnClassNames;

      column.style.backgroundColor = color;

      row.appendChild(column);
    }
  } else if (gridModes[currentModeIndex] === 'baseline') {
    container.classList.add('grid-overlay-baseline');

    var baselinePercentage = (GRID_BASELINE - 1) / GRID_BASELINE * 100 + '%';

    var backgroundImage = ['linear-gradient(', 'to bottom, ', 'transparent, ', 'transparent ' + baselinePercentage + ', ', color + ' ' + baselinePercentage, ')'].join('');

    container.style.backgroundImage = backgroundImage;

    // Because JSDOM is using the package 'cssstyle', which is stupid and
    // doesn't support gradients as values...
    container.style._backgroundImage = backgroundImage;
  }

  return container;
}

/**
 * Create the DOM nodes needed for the grid size label.
 *
 * @return {HTMLElement} A DOM node.
 *
 * @private
 */
function createSizeLabel() {
  var sizes = [{ name: 'Extra Small', id: 'xs' }, { name: 'Small', id: 'sm' }, { name: 'Medium', id: 'md' }, { name: 'Large', id: 'lg' }];

  var labelContainer = document.createElement('div');
  labelContainer.className = 'grid-overlay-label';

  sizes.forEach(function (size) {
    var label = document.createElement('span');
    label.className = 'visible-' + size.id;
    label.textContent = size.name;
    labelContainer.appendChild(label);
  });

  return labelContainer;
}

exports.listen = listen;
exports.toggle = toggle;
exports.enable = enable;
exports.disable = disable;
exports.setColor = setColor;
exports.reset = reset;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"spotify-cosmos-api":357}],188:[function(require,module,exports){
'use strict';

// This should be removed later when nothing is calling this method

exports.getVersion = function () {
  return 1;
};

},{}],189:[function(require,module,exports){
'use strict';

module.exports = {
  'de': require('../i18n/de.lang'),
  'el': require('../i18n/el.lang'),
  'en': require('../i18n/en.lang'),
  'es': require('../i18n/es.lang'),
  'es-419': require('../i18n/es-419.lang'),
  'fi': require('../i18n/fi.lang'),
  'fr': require('../i18n/fr.lang'),
  'fr-CA': require('../i18n/fr-CA.lang'),
  'hu': require('../i18n/hu.lang'),
  'id': require('../i18n/id.lang'),
  'it': require('../i18n/it.lang'),
  'ja': require('../i18n/ja.lang'),
  'nl': require('../i18n/nl.lang'),
  'pl': require('../i18n/pl.lang'),
  'pt-BR': require('../i18n/pt-BR.lang'),
  'sv': require('../i18n/sv.lang'),
  'tr': require('../i18n/tr.lang'),
  'zh-Hant': require('../i18n/zh-Hant.lang'),
  'zsm': require('../i18n/zsm.lang')
};

},{"../i18n/de.lang":167,"../i18n/el.lang":168,"../i18n/en.lang":169,"../i18n/es-419.lang":170,"../i18n/es.lang":171,"../i18n/fi.lang":172,"../i18n/fr-CA.lang":173,"../i18n/fr.lang":174,"../i18n/hu.lang":175,"../i18n/id.lang":176,"../i18n/it.lang":177,"../i18n/ja.lang":178,"../i18n/nl.lang":179,"../i18n/pl.lang":180,"../i18n/pt-BR.lang":181,"../i18n/sv.lang":182,"../i18n/tr.lang":183,"../i18n/zh-Hant.lang":184,"../i18n/zsm.lang":185}],190:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
var partial$0 = require('./media/image.hbs');
HandlebarsCompiler.registerPartial('./media/image.hbs', partial$0);
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); partials = this.merge(partials, Handlebars.partials); data = data || {};
  var buffer = "", stack1, helper, options, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, functionType="function", self=this, blockHelperMissing=helpers.blockHelperMissing;

function program1(depth0,data) {


  return "data-context";
  }

  buffer += "<div class=\"media-object media-object-image media-object-simple media-object-"
    + escapeExpression((helper = helpers.type || (depth0 && depth0.type),options={hash:{},data:data},helper ? helper.call(depth0, (depth0 && depth0.uri), options) : helperMissing.call(depth0, "type", (depth0 && depth0.uri), options)))
    + " ";
  if (helper = helpers.modifiers) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.modifiers); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"\n  ";
  options={hash:{},inverse:self.program(1, program1, data),fn:self.noop,data:data}
  if (helper = helpers.noContext) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.noContext); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.noContext) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.program(1, program1, data),fn:self.noop,data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-contextmenu draggable=\"true\">\n  <div class=\"mo-wrapper\">\n    <div class=\"mo-image-wrapper\">\n      <span>\n      ";
  stack1 = self.invokePartial(partials['./media/image.hbs'], './media/image.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      </span>\n    </div>\n  </div>\n</div>\n";
  return buffer;
  });

},{"./media/image.hbs":191,"hbsfy/runtime":303}],191:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, options, functionType="function", escapeExpression=this.escapeExpression, self=this, helperMissing=helpers.helperMissing;

function program1(depth0,data) {

  var buffer = "", stack1;
  buffer += "\n  <div class=\"mo-image-background-color\">\n    ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.imageUrl), {hash:{},inverse:self.noop,fn:self.program(2, program2, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  </div>\n";
  return buffer;
  }
function program2(depth0,data) {

  var buffer = "", stack1, helper;
  buffer += "\n      <div class=\"mo-image-background\" style=\"background-image: url('";
  if (helper = helpers.imageUrl) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.imageUrl); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "')\"></div>\n    ";
  return buffer;
  }

function program4(depth0,data) {

  var buffer = "", stack1;
  buffer += "\n  <div class=\"mo-wide-image\" ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.imageUrl), {hash:{},inverse:self.noop,fn:self.program(5, program5, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += ">\n";
  return buffer;
  }
function program5(depth0,data) {

  var buffer = "", stack1, helper;
  buffer += "style=\"background-image: url('";
  if (helper = helpers.imageUrl) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.imageUrl); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "')\"";
  return buffer;
  }

function program7(depth0,data) {

  var buffer = "", stack1;
  buffer += "\n  <div class=\"mo-image\" ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.imageUrl), {hash:{},inverse:self.noop,fn:self.program(5, program5, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += ">\n";
  return buffer;
  }

  buffer += "<svg class=\"mo-placeholder\" viewBox=\"0 0 10 10\" preserveAspectRatio=\"xMidYMid meet\">\n  <text class=\"playlist-placeholder\" x=\"5\" y=\"9.8\">&#xf135;</text>\n  <text class=\"playlist-folder-placeholder\" x=\"5\" y=\"9.8\">&#xf137;</text>\n  <text class=\"album-placeholder\" x=\"5\" y=\"9.8\">&#xf101;</text>\n  <text class=\"artist-placeholder\" x=\"5\" y=\"9.8\">&#xf103;</text>\n  <text class=\"user-placeholder\" x=\"5\" y=\"9.8\">&#xf15d;</text>\n  <text class=\"genre-placeholder\" x=\"5\" y=\"9.8\">&#xf109;</text>\n  <text class=\"collection-placeholder\" x=\"5\" y=\"9.8\">&#xf157;</text>\n  <text class=\"local-files-placeholder\" x=\"5\" y=\"9.8\">&#xf1fb;</text>\n</svg>\n\n";
  stack1 = (helper = helpers.type || (depth0 && depth0.type),options={hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.uri), "user", "artist", options) : helperMissing.call(depth0, "type", (depth0 && depth0.uri), "user", "artist", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.wideImage), {hash:{},inverse:self.program(7, program7, data),fn:self.program(4, program4, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n</div>\n<span class=\"mo-verified\">\n  <span class=\"spoticon-check-16\"></span>\n</span>\n";
  return buffer;
  });

},{"hbsfy/runtime":303}],192:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, functionType="function", escapeExpression=this.escapeExpression, self=this, helperMissing=helpers.helperMissing;

function program1(depth0,data) {

  var buffer = "", stack1, helper;
  buffer += "data-select=\"";
  if (helper = helpers.id) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.id); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"";
  return buffer;
  }

function program3(depth0,data) {


  return "data-select";
  }

function program5(depth0,data) {

  var buffer = "", stack1, helper;
  buffer += "data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"";
  return buffer;
  }

function program7(depth0,data) {

  var buffer = "", stack1, helper;
  buffer += "data-select-property=\"";
  if (helper = helpers.property) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.property); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"";
  return buffer;
  }

function program9(depth0,data) {

  var buffer = "", stack1, helper;
  buffer += "aria-labelledby=\"";
  if (helper = helpers.labelId) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.labelId); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"";
  return buffer;
  }

function program11(depth0,data,depth1) {

  var buffer = "", stack1, helper, options;
  buffer += "\n     <option\n       ";
  stack1 = (helper = helpers.compare || (depth1 && depth1.compare),options={hash:{},inverse:self.noop,fn:self.program(12, program12, data),data:data},helper ? helper.call(depth0, (data == null || data === false ? data : data.key), (depth1 && depth1.selected), options) : helperMissing.call(depth0, "compare", (data == null || data === false ? data : data.key), (depth1 && depth1.selected), options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n       value=\""
    + escapeExpression(((stack1 = (data == null || data === false ? data : data.key)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\">\n     "
    + escapeExpression((typeof depth0 === functionType ? depth0.apply(depth0) : depth0))
    + "\n     </option>\n  ";
  return buffer;
  }
function program12(depth0,data) {


  return "\n         selected=\"selected\"\n       ";
  }

  buffer += "<select\n  ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.id), {hash:{},inverse:self.program(3, program3, data),fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.uri), {hash:{},inverse:self.noop,fn:self.program(5, program5, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.property), {hash:{},inverse:self.noop,fn:self.program(7, program7, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.labelId), {hash:{},inverse:self.noop,fn:self.program(9, program9, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n>\n  ";
  stack1 = helpers.each.call(depth0, (depth0 && depth0.options), {hash:{},inverse:self.noop,fn:self.programWithDepth(11, program11, data, depth0),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n</select>";
  return buffer;
  });

},{"hbsfy/runtime":303}],193:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, options, functionType="function", escapeExpression=this.escapeExpression, self=this, helperMissing=helpers.helperMissing;

function program1(depth0,data) {


  return "true";
  }

function program3(depth0,data) {


  return "false";
  }

function program5(depth0,data) {


  return " enabled";
  }

function program7(depth0,data) {


  return " disabled";
  }

function program9(depth0,data) {


  return "aria-disabled=\"true\"";
  }

function program11(depth0,data) {

  var buffer = "", stack1, helper;
  buffer += "data-slider=\"";
  if (helper = helpers.id) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.id); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"";
  return buffer;
  }

function program13(depth0,data) {


  return "data-slider";
  }

function program15(depth0,data) {

  var buffer = "", stack1, helper;
  buffer += "aria-labelledby=\"";
  if (helper = helpers.labelId) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.labelId); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"";
  return buffer;
  }

function program17(depth0,data) {

  var buffer = "", stack1, helper;
  buffer += "data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"";
  return buffer;
  }

function program19(depth0,data) {

  var buffer = "", stack1, helper;
  buffer += "data-slider-property=\"";
  if (helper = helpers.property) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.property); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"";
  return buffer;
  }

function program21(depth0,data) {

  var buffer = "", stack1, helper;
  buffer += "data-slider-allowed-property=\"";
  if (helper = helpers.allowedProperty) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.allowedProperty); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"";
  return buffer;
  }

  buffer += "<div\n  tabindex=\"0\"\n  role=\"checkbox\"\n  aria-checked=\"";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.enabled), {hash:{},inverse:self.program(3, program3, data),fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\"\n  class=\"slider";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.enabled), {hash:{},inverse:self.noop,fn:self.program(5, program5, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  stack1 = (helper = helpers.compare || (depth0 && depth0.compare),options={hash:{},inverse:self.noop,fn:self.program(7, program7, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.allowed), false, options) : helperMissing.call(depth0, "compare", (depth0 && depth0.allowed), false, options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\"\n  ";
  stack1 = (helper = helpers.compare || (depth0 && depth0.compare),options={hash:{},inverse:self.noop,fn:self.program(9, program9, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.allowed), false, options) : helperMissing.call(depth0, "compare", (depth0 && depth0.allowed), false, options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.id), {hash:{},inverse:self.program(13, program13, data),fn:self.program(11, program11, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.labelId), {hash:{},inverse:self.noop,fn:self.program(15, program15, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.uri), {hash:{},inverse:self.noop,fn:self.program(17, program17, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.property), {hash:{},inverse:self.noop,fn:self.program(19, program19, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.allowedProperty), {hash:{},inverse:self.noop,fn:self.program(21, program21, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += ">\n  <div></div>\n</div>\n";
  return buffer;
  });

},{"hbsfy/runtime":303}],194:[function(require,module,exports){
'use strict';

// Usage
// Data {{#compare 'myvalue' value}}has{{else}}doesn't have{{/compare}} myvalue.
// Data {{#compare '5' tracks.length true}}has{{else}}doesn't have{{/compare}} 5 tracks.
// Data {{#compare tracks.length 5 operator='>'}}has more than{{else}}has less than or equal to{{/compare}} 5 tracks.

var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var operators = {
  '==': function _(a, b) {
    /* eslint eqeqeq: 0 */return a == b;
  },
  '===': function _(a, b) {
    return a === b;
  },
  '!=': function _(a, b) {
    /* eslint eqeqeq: 0 */return a != b;
  },
  '<': function _(a, b) {
    return a < b;
  },
  '>': function _(a, b) {
    return a > b;
  },
  '<=': function _(a, b) {
    return a <= b;
  },
  '>=': function _(a, b) {
    return a >= b;
  },
  'typeof': function _typeof(a, b) {
    return (typeof a === 'undefined' ? 'undefined' : _typeof2(a)) == b;
  }
};

function compare(a, b, s) {
  var options = arguments[arguments.length - 1];
  var soft = s !== options ? s : false;
  var operator = soft ? '==' : options.hash.operator || '===';

  var match = operators[operator](a, b);

  return match ? options.fn(this) : options.inverse(this);
}

compare.displayName = 'compare';

module.exports = compare;

},{}],195:[function(require,module,exports){
'use strict';

var duration = function duration(ms) {
  if (isNaN(ms)) return ms;

  var s = Math.round(ms / 1000);
  var oneMinute = 60;
  var oneHour = 60 * oneMinute;

  var hours = Math.floor(s / oneHour);
  var minutes = Math.floor(s % oneHour / oneMinute);
  var seconds = Math.round(s % oneHour % oneMinute);

  // Include hours if needed
  if (hours) {
    hours += ':';

    // If hours are specified, minutes should always be with two digits
    if (minutes < 10) minutes = '0' + minutes;
  } else {
    hours = '';
  }

  // Since minutes should always be displayed, seconds should always be with two digits
  if (seconds < 10) seconds = '0' + seconds;

  return hours + minutes + ':' + seconds;
};

duration.displayName = 'duration';

module.exports = duration;

},{}],196:[function(require,module,exports){
'use strict';

var nameListTooltip = require('./name-list-tooltip');

var facepile = function facepile(list, totalCount, mT, opts) {
  var options = opts;
  var minThresh = mT;

  if (!list) {
    return '';
  }

  if (arguments.length < 4) {
    options = minThresh;
    minThresh = 3;
  }

  minThresh = minThresh || 3;

  var len = list.length;
  var thresh = Math.min(minThresh, len);
  var ret = '';

  // Display faces.
  for (var i = 0; i < thresh; i++) {
    var obj = list[i];
    obj.modifiers = 'media-object-link media-object-simple';
    ret += options.fn(obj);
  }

  // Display badge count for hidden listeners.
  if (totalCount > thresh) {
    ret += options.inverse({
      badgeCount: totalCount - thresh,
      badgeTooltip: nameListTooltip(list.slice(thresh), totalCount - thresh)
    });
  }
  return ret;
};

facepile.displayName = 'facepile';

module.exports = facepile;

},{"./name-list-tooltip":202}],197:[function(require,module,exports){
(function (global){
'use strict';

var getHTTPLink = require('../util/link');

var isDesktop = !!global._getSpotifyModule;

var href = function href(uri) {
  if (isDesktop) return uri;
  return getHTTPLink(uri, 'https://play.spotify.com');
};

href.displayName = 'href';

module.exports = href;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../util/link":209}],198:[function(require,module,exports){
'use strict';

var loc = require('./loc');

var humanizeDuration = function humanizeDuration(ms) {
  if (isNaN(ms)) return ms;

  var s = Math.round(ms / 1000);
  var oneMinute = 60;
  var oneHour = 60 * oneMinute;

  var hours = Math.floor(s / oneHour);
  var minutes = Math.floor(s % oneHour / oneMinute);
  var seconds = Math.round(s % oneHour % oneMinute);

  var formattedDuration = '';

  if (hours) {
    formattedDuration += loc('HoursShort', hours, {});
  }

  if (minutes) {
    formattedDuration += ' ';
    formattedDuration += loc('MinutesShort', minutes, {});
  }

  if (!hours && !minutes || hours === 0 && minutes < 10) {
    formattedDuration += ' ';
    formattedDuration += loc('SecondsShort', seconds, {});
  }

  return formattedDuration.trim();
};

humanizeDuration.displayName = 'humanizeDuration';

module.exports = humanizeDuration;

},{"./loc":201}],199:[function(require,module,exports){
'use strict';

exports.compare = require('./compare');
exports.duration = require('./duration');
exports.facepile = require('./facepile');
exports.href = require('./href');
exports.humanizeDuration = require('./humanize-duration');
exports.list = require('./list');
exports.loc = require('./loc');
exports.nameListTooltip = require('./name-list-tooltip');
exports.numeral = require('./numeral');
exports.share = require('./share');
exports.slice = require('./slice');
exports.type = require('./type');
exports.userReaction = require('./user-reaction');

},{"./compare":194,"./duration":195,"./facepile":196,"./href":197,"./humanize-duration":198,"./list":200,"./loc":201,"./name-list-tooltip":202,"./numeral":203,"./share":204,"./slice":205,"./type":206,"./user-reaction":207}],200:[function(require,module,exports){
'use strict';

var map = require('mout/array/map');

var Handlebars = require('handlebars/dist/cjs/handlebars.runtime').default;

var lists = {};

var list = function list(array) {
  if (!array) {
    return '';
  }

  var args = Array.prototype.slice.call(arguments);
  var options = args.pop();
  var listID = args[1];

  if (array === 'reset') {
    delete lists[listID];
    return '';
  }

  if (listID && lists[listID] === undefined) {
    lists[listID] = -1;
  }

  return map(array, function (item, i) {
    var data = Handlebars.createFrame(options.data || {});
    data.index = listID ? ++lists[listID] : i;
    data.number = data.index + 1;
    data.localIndex = i;
    data.localNumber = i + 1;
    return options.fn(item, { data: data });
  }).join(options.hash && options.hash.join || '');
};

list.displayName = 'list';

module.exports = list;

},{"handlebars/dist/cjs/handlebars.runtime":296,"mout/array/map":312}],201:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var mixIn = require('mout/object/mixIn');
var slice_ = Array.prototype.slice;

var storage = {};

var loc = function loc(key) {
  var value = storage[key];

  if (!value) return '';

  var args = slice_.call(arguments, 1);
  var options = {};

  if (_typeof(args[args.length - 1]) === 'object') {
    options = args.pop();
  }

  var hash = options.hash;

  return value.replace(/\{([\w-]+)\}/g, function (full, match) {
    var n = +match;
    var interpolated;

    if (isNaN(n)) {
      interpolated = hash[match];
    } else {
      interpolated = args[n];
    }

    return interpolated !== null ? interpolated : '';
  });
};

loc.displayName = 'loc';

loc.register = function (object) {
  mixIn(storage, object);
  return this;
};

module.exports = loc;

},{"mout/object/mixIn":334}],202:[function(require,module,exports){
'use strict';

var loc = require('./loc');

var nameListTooltip = function nameListTooltip(users, totalCount) {
  if (totalCount === 0) {
    return undefined;
  }

  var len = users.length;
  var textTokens = users.map(function (user) {
    return user.name;
  });

  if (totalCount - len > 0) {
    var andMoreText = loc('AndMore', totalCount - len);
    textTokens.push(andMoreText);
  }

  return textTokens.join('<br>\n').replace(/'/g, '&#39;');
};

nameListTooltip.displayName = 'nameListTooltip';

module.exports = nameListTooltip;

},{"./loc":201}],203:[function(require,module,exports){
'use strict';

var isNumber = require('mout/lang/isNumber');

/**
 * If the first argument is a number, pipe it through spotify-numeral with an
 * optional format propety in the options hash, otherwise return it untouched.
 *
 * Example usage – results when using fr locale:
 *
 * {{numeral 1000}} -> '1 000'
 * {{numeral 1000 format='0,0.000'}} -> '1 000,000'
 * {{numeral 1000 format='$0,0.00'}} -> '€1 000,00'
 *
 * @param {Number|String} number - The number to format (or string to leave
 *     untouched).
 * @param {Object} [options] - The handlebars options object.
 * @param {Object} [options.hash] - The handlebars options hash object.
 * @param {String} [options.hash.format] - The optional format to pass to
 *     numeraljs.
 * @return {String} The formatted (or untouched) string.
 */
var numeralHelper = function numeralHelper(number, options) {
  var format = options && options.hash && options.hash.format;
  var numeral = numeralHelper._numeral;
  return isNumber(number) ? numeral(number).format(format) : number;
};

numeralHelper.displayName = 'numeral';

module.exports = numeralHelper;

// This is tricky, but is a way to allow for the locale to be injected
// from the consuming app instead of from within spotify-numeral, removing
// the dependency on spotify-quickstart.
module.exports.setLocale = function (locale) {
  numeralHelper._numeral = require('../../spotify-numeral')(locale);
};

},{"../../spotify-numeral":227,"mout/lang/isNumber":323}],204:[function(require,module,exports){
'use strict';

var getHTTPLink = require('../util/link');

var share = function share(uri) {
  return getHTTPLink(uri, 'https://open.spotify.com');
};

share.displayName = 'share';

module.exports = share;

},{"../util/link":209}],205:[function(require,module,exports){
'use strict';

var kindOf = require('mout/lang/kindOf');
var map = require('mout/array/map');
var forEach = require('mout/array/forEach');

var Handlebars = require('handlebars/dist/cjs/handlebars.runtime').default;
var slice_ = Array.prototype.slice;

var slice = function slice(arr) {
  var array = arr;

  if (!array) {
    return '';
  }

  var sep;
  var begin;
  var end;
  var options;

  forEach(slice_.call(arguments, 1), function (arg) {
    switch (kindOf(arg)) {
      case 'String':
        sep = arg;
        break;

      case 'Number':
        if (begin === null) {
          begin = arg;
        } else if (end === null) {
          end = arg;
        }
        break;

      case 'Object':
        options = arg;
        break;

      default:
      // Do nothing.
    }
  });

  if (begin !== null) {
    array = array.slice(begin, end !== null ? end : array.length);
  }

  return map(array, function (item) {
    var data = Handlebars.createFrame(options.data || {});

    return options.fn(item, { data: data });
  }).join(sep || '');
};

slice.displayName = 'slice';

module.exports = slice;

},{"handlebars/dist/cjs/handlebars.runtime":296,"mout/array/forEach":309,"mout/array/map":312,"mout/lang/kindOf":326}],206:[function(require,module,exports){
'use strict';

var getType = require('../util/type');

// This needs at least the uri param to get the type:
// {{type uri}}
//
// If you pass more parameters you can use it like a matcher:
// {{#type uri "track" "album"}}YAY{{/type}}
// This will print 'YAY' for tracks or albums.

var type = function type(uri) {
  if (arguments.length <= 2) {
    // Simple get type.
    return getType(uri);
  }

  // Match type.
  var context = arguments[arguments.length - 1];
  var success = false;
  var uriType = getType(uri);

  for (var i = 1; i < arguments.length - 1; i++) {
    if (uriType === arguments[i]) {
      success = true;
      break;
    }
  }

  return success ? context.fn(this) : context.inverse(this);
};

type.displayName = 'type';

module.exports = type;

},{"../util/type":210}],207:[function(require,module,exports){
'use strict';

var loc = require('./loc');

var userReaction = function userReaction(users, totalCount, reactionType) {
  if (!totalCount) return '';
  var key = reactionType + 'Reaction' + (totalCount > 1 ? 'Multi' : 'Single');

  if (totalCount > 1) {
    return loc(key, totalCount);
  }

  if (!users.length) {
    return '';
  }

  var firstListener = users[0].name;
  return loc(key, firstListener);
};

userReaction.displayName = 'userReaction';

module.exports = userReaction;

},{"./loc":201}],208:[function(require,module,exports){
'use strict';

var kindOf = require('mout/lang/kindOf');

var Handlebars = require('handlebars/dist/cjs/handlebars.runtime').default;

// Expose the runtime to make partials easier to register.
exports.runtime = Handlebars;

exports.register = function (helpers) {
  var list = {};

  if (kindOf(helpers) === 'Function') {
    list[helpers.displayName] = helpers;
  } else {
    list = helpers;
  }

  for (var key in list) {
    if (list.hasOwnProperty(key)) {
      Handlebars.registerHelper(key, list[key]);
    }
  }

  return this;
};

},{"handlebars/dist/cjs/handlebars.runtime":296,"mout/lang/kindOf":326}],209:[function(require,module,exports){
'use strict';

module.exports = function (uri, base) {
  var matches = (uri || '').match(/^spotify:(.+)$/);

  if (!matches) {
    return uri || '';
  }

  var parts = matches.pop().replace(/:$/, '').split(/:/);
  var type = parts.shift();

  if (type === 'search') {
    parts = [parts.join(':')];
  }

  parts.unshift(base, type);

  return parts.join('/');
};

},{}],210:[function(require,module,exports){
'use strict';

module.exports = function (uri) {
  if (!uri || !uri.split) {
    return null;
  }
  var parts = uri.split(':');
  var result = null;
  switch (parts[1]) {
    case 'album':
      // spotify:album:<id>:<disc>
      if (parts.length === 4) {
        return 'disc';
      } else if (parts.length === 3) {
        return 'album';
      }
      break;

    case 'artist':
      if (parts.length === 3) {
        return 'artist';
      }
      break;

    case 'track':
      if (parts.length === 3) {
        return 'track';
      }
      break;

    case 'genre':
      if (parts.length === 3) {
        return 'genre';
      }
      break;

    case 'station':
      if (parts.length > 3) {
        return 'station';
      }
      break;

    case 'local':
      if (parts.length === 6) {
        return 'track';
      } else if (parts.length === 4) {
        return 'album';
      } else if (parts.length === 3) {
        return 'artist';
      }
      break;

    case 'user':
      // spotify:user:<username>:collection
      if (parts.length > 3 && parts[3] === 'collection') {
        return 'collection';
      }

      // spotify:user:<username>:folder:<id>
      if (parts.length === 5 && parts[3] === 'folder') {
        return 'playlist-folder';
      }

      // spotify:user:<username>:<playlist:<id>|starred|toplist>
      if (parts.length > 3 && parts.length <= 5 && parts[2] !== 'facebook') {
        return 'playlist';
      } else if (parts.length === 3) {
        return 'user';
      }
      break;

    case 'internal':
      // spotify:internal:local-files
      return parts[2];

    case 'app':
      // spotify:app:collection:albums, spotify:app:radio
      return parts.slice(1).join('-');

    default:
    // Do nothing.
  }

  return result;
};

},{}],211:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var Translations = require('../spotify-translations');
var glueLocales = require('../spotify-glue-cat/strings');

module.exports = function (localeToStrings) {
  if (!localeToStrings || (typeof localeToStrings === 'undefined' ? 'undefined' : _typeof(localeToStrings)) !== 'object') {
    throw new Error('' + 'Locale strings must be a plain object. ' + 'See spotify-i18n/README.md');
  }

  function getClientLocale() {
    return typeof window !== 'undefined' && window.__spotify && window.__spotify.locale || 'en';
  }

  var locales = localeToStrings;
  var i18n = new Translations();
  i18n.injectData(locales[getClientLocale()] || {});

  return {
    locale: getClientLocale,
    get: i18n.get.bind(i18n),

    glueStrings: function glueStrings() {
      return glueLocales[getClientLocale()];
    },

    appStrings: function appStrings() {
      return locales[getClientLocale()];
    }
  };
};

},{"../spotify-glue-cat/strings":189,"../spotify-translations":245}],212:[function(require,module,exports){
(function (global){
/**
 * @module spotify-live-models/client-storage
 */
'use strict';

var forOwn = require('mout/object/forOwn');
var combine = require('mout/array/combine');
var remove = require('mout/array/remove');
var contains = require('mout/array/contains');

var URI = 'spotify:client-storage';
var live = require('../spotify-live');
var cosmos = require('./util/cosmos');
var endpoints = {
  broadcast: 'sp://messages/v1/client-storage'
};

var waiting = [];

function onInit(model) {
  // Set a flag for showing that the model has been implemented and
  // registered. This is so that we can check this in player without
  // making a breaking change. Would be great with a future live API
  // to see if someone has implemented a specific model.
  model.update({ implemented: true });
}

function onWait(model, properties) {
  // Ask the top frame to broadcast the properties.
  // Values will be null when they weren't stored.
  waiting = combine(waiting, properties);
  global.top.postMessage({
    type: 'client_storage',
    name: 'broadcast_client_storage',
    data: properties
  }, '*');
}

function onPublish(model, properties) {
  // Tell the top frame to persist and broadcast
  global.top.postMessage({
    type: 'client_storage',
    name: 'set_client_storage',
    data: properties
  }, '*');

  // Optimistic update
  model.update(properties);
}

function onBroadcast(error, event) {
  var update = {};
  var model = live(URI);
  forOwn(event.body, function (value, key) {

    // Update model if this instance of storage knows that the model waits for it
    var isWaiting = contains(waiting, key);

    // Or if the model has a potentially outdated value in the live cache
    var hasKey = model.get(key) !== undefined;

    if (isWaiting || hasKey) update[key] = value;
    if (isWaiting) remove(waiting, key);
  });
  model.update(update);
}

var broadcastSubscription;
var regExp = exports.matches = new RegExp('^' + URI + '$');
var registered;

exports.register = function () {
  if (registered) return;
  registered = true;

  live.subscribe(regExp, 'init', onInit);
  live.subscribe(regExp, 'wait', onWait);
  live.subscribe(regExp, 'publish', onPublish);
  broadcastSubscription = cosmos.subscribe({ url: endpoints.broadcast }, onBroadcast);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  live.unsubscribe(regExp, 'init', onInit);
  live.unsubscribe(regExp, 'wait', onWait);
  live.unsubscribe(regExp, 'publish', onPublish);

  if (broadcastSubscription) {
    broadcastSubscription.cancel();
    broadcastSubscription = null;
  }
  waiting.length = 0;
};

exports._endpoints = endpoints;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-live":217,"./util/cosmos":216,"mout/array/combine":304,"mout/array/contains":305,"mout/array/remove":313,"mout/object/forOwn":331}],213:[function(require,module,exports){
(function (global){
/**
 * @module spotify-live-models/client
 */
'use strict';

var live = require('../spotify-live');
var bridge = require('./util/bridge').request;
var liburi = require('spotify-liburi');

var BACKOFF = 100;

function updateCurrentUser(model) {
  bridge('user_metadata', ['spotify:user:@'], function (error, payload) {
    if (error) {
      if (global.__spotify && global.__spotify.username) {
        var username = global.__spotify.username;
        model.update({
          currentUser: {
            uri: liburi.profileURI(username).toURI(),
            username: username
          }
        });
      }

      if (global.console) console.error(error);
      return;
    }

    model.update({
      currentUser: {
        uri: liburi.profileURI(payload.username).toURI(),
        name: payload.name,
        username: payload.username
      }
    });
  });
}

function getFeatures(callback) {
  bridge('client_features', [], function (error, payload) {
    if (error) return callback(error);
    callback(null, payload.features);
  });
}

function updateSessionData(model) {
  bridge('session_query', [], function (error, payload) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }

    // Not all the clients expose employee property so it needs to be set if it does not exist
    if (payload.employee === undefined) {
      if (global.__spotify && global.__spotify.product_state && global.__spotify.product_state.employee) {
        // For Zelda
        payload.employee = global.__spotify.product_state.employee === '1' ? true : false;
      } else {
        // Clients older than 0.9.16 do not expose employee flag.
        payload.employee = false;
      }
    }

    model.update({ session: payload });

    // Initiate session subscription since data has been requested once.
    bridgeWaitSession(model);
  });
}

function bridgeWaitSession(model) {
  bridge('session_event_wait', [], function (error, event) {
    if (!registered) return;
    if (error) {
      setTimeout(function () {
        bridgeWaitSession(model);
      }, BACKOFF);
      if (global.console) console.error(error);
      return;
    }

    if (event.type === 'change') {
      model.get('session').update(event.data);
    }

    bridgeWaitSession(model);
  });
}

function showContextMenu(model, data) {
  if (global === window && window.top && window.top.postMessage) {
    window.top.postMessage({
      type: 'client_show_context_ui',
      data: data
    }, '*');
  }
}

function onWait(model, properties) {
  if (properties.indexOf('currentUser') > -1) {
    updateCurrentUser(model);
  }

  if (properties.indexOf('session') > -1) {
    updateSessionData(model);
  }
}

var hasFeatures;

function onFeaturesWait(featuresModel, properties) {
  // If features have been loaded before, every requested feature that
  // generates a 'wait' event after that is not an enabled feature in
  // the client, so we return false for all other properties.
  if (hasFeatures) {
    var features = {};
    properties.forEach(function (prop) {
      features[prop] = false;
    });
    featuresModel.update(features);
  } else {
    hasFeatures = true;
    getFeatures(function (error, features) {
      if (error) {
        if (global.console) console.error(error);
        return;
      }
      featuresModel.update(features);

      // Get a list of features that the model is waiting for still,
      // even after the received features were added.
      var neededFeatures = [];
      properties.forEach(function (prop) {
        if (!(prop in features)) neededFeatures.push(prop);
      });

      // Trigger a new wait handler for the properties it's still waiting for
      onFeaturesWait(featuresModel, neededFeatures);
    });
  }
}

function onInit(model) {
  // Get container_features and put it into it's own place on the client model.
  var __spotify = global.__spotify || {};
  var containerFeatures = live(__spotify.container_features || {});
  containerFeatures.on('wait', function (properties) {
    var update = {};
    for (var i = 0, property; property = properties[i]; i++) {
      update[property] = false;
    }
    containerFeatures.update(update);
  });

  // Listen for wait events on the features model to fetch data
  // through bridge and set other features to false
  var features = live({});
  features.on('wait', function (properties) {
    onFeaturesWait(features, properties);
  });

  model.update({
    features: features,
    containerFeatures: containerFeatures
  });

  // Grab the username from __spotify where available
  if (global.__spotify && global.__spotify.username) {
    var username = global.__spotify.username;
    model.update({
      currentUser: {
        uri: liburi.profileURI(username).toURI(),
        username: username
      }
    });
  }

  // Async fetch from bridge to complete currentUser to a user model
  // while we don't have all the info available elsewhere.
  updateCurrentUser(model);
}

var regExp = exports.matches = /^spotify:client$/;
var registered;
exports.register = function () {
  if (registered) return;
  registered = true;

  live.subscribe(regExp, 'wait', onWait);
  live.subscribe(regExp, 'init', onInit);
  live.subscribe(regExp, 'show-context-menu', showContextMenu);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  live.unsubscribe(regExp, 'wait', onWait);
  live.unsubscribe(regExp, 'init', onInit);
  live.unsubscribe(regExp, 'show-context-menu', showContextMenu);
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-live":217,"./util/bridge":215,"spotify-liburi":367}],214:[function(require,module,exports){
(function (global){
/**
 * @module spotify-live-models/user
 */
'use strict';

var live = require('../spotify-live');
var liburi = require('spotify-liburi');
var contains = require('mout/array/contains');
var intersection = require('mout/array/intersection');
var bridge = require('./util/bridge').request;

function updateMetadata(model) {
  bridge('user_metadata', [model.uri], function (error, payload) {
    if (error && global.console) console.error(error);

    if (!payload) payload = {};

    payload.username = payload.username || liburi.from(model.uri).username;
    payload.name = payload.name || payload.username;
    payload.image = payload.image || '';
    payload.images = payload.images || [];

    if (payload.subscribed == null) {
      payload.subscribed = false;
    }

    if (payload.currentUser == null) {
      live('spotify:client').query('currentUser(uri)', function (error, data) {
        if (error) {
          if (global.console) console.error(error);
          return;
        }
        model.update({ currentUser: model.uri === data.currentUser.uri });
      });
    }

    model.update(payload);
  });
}

function updateArtist(model) {
  bridge('user_associated_artist', [model.uri], function (error, payload) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }
    var artist = payload.artist ? { uri: payload.artist } : null;
    model.update({ artist: artist });
  });
}

function onWait(model, properties) {
  var hasArtist = contains(properties, 'artist');
  var metaFields = ['currentUser', 'name', 'username', 'image', 'images', 'subscribed'];
  var hasMetadata = !!intersection(properties, metaFields).length;

  if (hasMetadata) updateMetadata(model);
  if (hasArtist) updateArtist(model);
}

var regExp = exports.matches = /^spotify:user:[^:]+$/;
var registered;
exports.register = function () {
  if (registered) return;
  registered = true;

  live.subscribe(regExp, 'wait', onWait);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  live.unsubscribe(regExp, 'wait', onWait);
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-live":217,"./util/bridge":215,"mout/array/contains":305,"mout/array/intersection":311,"spotify-liburi":367}],215:[function(require,module,exports){
/**
 * @module spotify-live-models/util/bridge
 * @private
 */

'use strict';

var bridge = require('../../spotify-bridge-request');

module.exports = {
  request: bridge.request
};

},{"../../spotify-bridge-request":144}],216:[function(require,module,exports){
(function (global){
/**
 * @module spotify-live-models/util/cosmos
 * @private
 */

'use strict';

var cosmos = require('spotify-cosmos-api');

function DELETE(options, opt_callback) {
  options.method = exports.cosmos.Action.DELETE;
  return request(options, opt_callback);
}

function GET(options, opt_callback) {
  options.method = exports.cosmos.Action.GET;
  return request(options, opt_callback);
}

function SUB(options, opt_callback) {
  options.method = exports.cosmos.Action.SUB;
  return request(options, opt_callback);
}

function POST(options, opt_callback) {
  options.method = exports.cosmos.Action.POST;
  return request(options, opt_callback);
}

function PUT(options, opt_callback) {
  options.method = exports.cosmos.Action.PUT;
  return request(options, opt_callback);
}

function HEAD(options, opt_callback) {
  options.method = exports.cosmos.Action.HEAD;
  return request(options, opt_callback);
}

function request(options, opt_callback) {
  var method = options.method;
  delete options.method;

  var subscription, canceled;

  sanitizeURL(options.url, function (error, url) {
    if (error) return opt_callback && opt_callback(error);

    // if you cancel before the userName is replaced.
    if (canceled) return;

    var request = new exports.cosmos.Request(method || exports.cosmos.Action.GET, url, options.headers, options.body);
    subscription = exports.cosmos.resolver.resolve(request, function (error, response) {
      if (!opt_callback) return;
      if (error) return opt_callback(error);
      try {
        opt_callback(null, {
          body: JSON.parse(response.getBody() || '{}'),
          headers: response.getHeaders(),
          status: response.getStatusCode()
        });
      } catch (parseError) {
        parseError.response = response;
        opt_callback(parseError);
      }
    });
  });

  return {
    cancel: function cancel() {
      if (subscription && subscription.cancel) {
        // we already subscribed, cancel it.
        subscription.cancel();
        subscription = null;
      } else if (!canceled) {
        // not subscribed yet, don't even subscribe.
        canceled = true;
      }
      return null;
    }
  };
}

function sanitizeURL(url, callback) {
  if (url.indexOf('@') > -1) {
    callback(null, url.replace('@', encodeURIComponent(global.__spotify.username)));
  } else {
    callback(null, url);
  }
}

exports.request = request;
exports.get = GET;
exports.post = POST;
exports.subscribe = SUB;
exports.delete = DELETE;
exports.put = PUT;
exports.head = HEAD;
exports.cosmos = cosmos;

exports.sanitizeURL = sanitizeURL;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"spotify-cosmos-api":357}],217:[function(require,module,exports){
(function (global){
/**
 * @module live
 */'use strict';

// prime

var prime = require('prime');
var defer = require('prime/defer');
var Emitter = require('prime/emitter');

// mout
var isPlainObject = require('mout/lang/isPlainObject');
var isArray = require('mout/lang/isArray');
var isRegExp = require('mout/lang/isRegExp');
var isNumber = function isNumber(n) {
  return typeof n === 'number';
};
var isString = function isString(s) {
  return typeof s === 'string';
};

var escapeRegExp = require('mout/string/escapeRegExp');

var _difference = require('mout/array/difference');
var filter = require('mout/array/filter');
var combine = require('mout/array/combine');
var map = require('mout/array/map');

var deepMixIn = require('mout/object/deepMixIn');
var pick = require('mout/object/pick');
var keys = require('mout/object/keys');

// finally
var flow = require('finally');

// util
var OrderedSet = require('./util/ordered-set');
var Range = require('../spotify-range2');
var parse = require('./util/parser');
var throttle = require('./util/throttle');

// methods

var isLiveList = function isLiveList(item) {
  return item instanceof LiveList;
};

var isLiveObject = function isLiveObject(item) {
  return item instanceof LiveObject;
};

// Simple, stupid and fast.
// Shallow, not checking hasOwnProperty.
var simpleClone = function simpleClone(object) {
  var clone = {};
  for (var key in object) {
    clone[key] = object[key];
  }
  return clone;
};

var difference = function difference(a, b) {
  return a.length === 0 ? [] : _difference.apply(this, arguments);
};

var values = function values(object, keys) {
  var values = [];
  var key;
  for (var i = 0, len = keys.length; i < len; i++) {
    key = keys[i];
    if (key in object) values.push(object[key]);else values.length++;
  }
  return values;
};

// subtract ranges2 from ranges1
var rdifference = function rdifference(ranges1, ranges2) {
  if (!ranges1.length) return [];

  var resultingRanges = [];

  for (var i = 0, len = ranges1.length; i < len; i++) {
    var range = ranges1[i];
    resultingRanges = resultingRanges.concat(range.subtract(ranges2));
  }

  // Make sure we don't have overlapping ranges
  resultingRanges = new Range(0, 0).merge(resultingRanges);

  // Remove any empty ranges
  resultingRanges = filter(resultingRanges, function (range) {
    return !!range.length;
  });

  return resultingRanges;
};

// merge ranges1 into ranges2
var rcombine = function rcombine(ranges1, ranges2) {
  for (var i = 0, len = ranges1.length; i < len; i++) {
    var range = ranges1[i];
    ranges2 = range.merge(ranges2);
  }
  return ranges2;
};

// util
var IDX = 0;

var slice_ = Array.prototype.slice;

var transform = function transform(item, method) {

  if (isPlainObject(item)) {
    // plain objects need to be liveified
    if ('operations' in item) return new LiveList().update(item.operations);
    return live(item.uri)._update(item, method);
  }

  if (isArray(item)) {
    // arrays need to be liveified
    return new LiveList()._update([{
      type: 'insert',
      index: 0,
      length: item.length,
      values: item
    }], method);
  }
  return item;
};

// Creates a callback with a timeout.
function createTimedCallback(callback, timeout) {
  var called;
  var timeoutId = setTimeout(function () {
    called = true;
    callback(new Error('Timeout Expired: ' + timeout + ' milliseconds'));
  }, timeout);
  return function () {
    if (!called) {
      clearTimeout(timeoutId);
      callback.apply(this, arguments);
    }
  };
};

var LiveList = prime( /** @lends LiveList.prototype */{

  mixin: Emitter,

  /**
   * A representation of an array which may be observed for changes
   * @constructs
   * @mixes Emitter
   * @param {Number} [length] - A number representing the length of the liveList.
   */
  constructor: function LiveList(length) {
    this._data = new OrderedSet(length);
    this._mergeThrottled = throttle(this._merge, this);
    this._waiting = [];

    var self = this;
    var lastWait = '';

    if (live.debug) setInterval(function () {
      var thisWait = self._waiting.toString();
      if (lastWait === thisWait) return;
      lastWait = thisWait;

      if (self._waiting.length) {
        console.warn(self, 'waiting for', self._waiting);
      } else {
        console.warn(self, 'all done');
      }
    }, 2000);
  },

  get index() {
    return this._data.index;
  },

  get length() {
    return this._data.length;
  },

  get keys() {
    return this._data.keys;
  },

  get values() {
    return this._data.values;
  },

  indexOf: function indexOf(key) {
    return this._data.indexOf(key);
  },

  indexOfMany: function indexOfMany(keys) {
    return this._data.indexOfMany(keys);
  },

  valueOf: function valueOf(key) {
    return this._data.valueOf(key);
  },

  hasKey: function hasKey(key) {
    return this._data.hasKey(key);
  },

  forEach: function forEach(fn, ctx) {
    this._data.forEach(fn, ctx);
    return this;
  },

  map: function map(fn, ctx) {
    return this._data.map(fn, ctx);
  },

  _merge: function _merge() {
    var data = this._data; // actual data
    var publish = this._publish; // new items on top of a copy of data || null
    var before = this._before; // an old copy of data || null

    if (publish) {
      delete this._publish;
      if (this._listeners && this._listeners.publish) {
        var publishDiff = data.diff(publish);
        if (publishDiff.length) this.emit('publish', publishDiff, EMIT_SYNC);
      }
    } else if (before) {
      delete this._before;
      if (this._listeners && this._listeners.update) {
        var updateDiff = before.diff(data);
        if (updateDiff.length) this.emit('update', updateDiff, EMIT_SYNC);
      }
    }
    return this;
  },

  _update: function _update(operations, method) {

    var branch;
    if (method === PUBLISH) {
      // it was receiving, cannot publish.
      if (this._before) return this;
      branch = this._publish || (this._publish = this._data.clone());
    } else if (method === UPDATE) {
      // it was publishing, delete it.
      if (this._publish) delete this._publish;
      if (!this._before) this._before = this._data.clone();
      branch = this._data;
    }

    var op;
    for (var opIndex = 0, opLen = operations.length; opIndex < opLen; opIndex++) {
      op = operations[opIndex];
      switch (op.type) {
        case 'length':
          branch.length = op.length;break;
        case 'sort':
          branch.sort(op.compareFunction);break;
        case 'move':
          branch.move(op.from, op.to, op.length);break;
        case 'remove':
          branch.remove(op.index, op.length);break;
        case 'insert':
          var values = [];
          var keys = op.keys || [];
          for (var i = 0, len = op.values.length; i < len; i++) {
            if (!op.keys || !op.keys[i]) keys[i] = (IDX++).toString(36);
            values[i] = transform(op.values[i], method);
          }
          branch.insert(op.index, keys, values);
          break;
      }
    }

    if (method === UPDATE) this._waiting = rdifference(this._waiting, this.index);

    this._mergeThrottled();
    return this;
  },

  publish: function publish(operations) {
    return this._update(operations, PUBLISH);
  },

  update: function update(operations) {
    return this._update(operations, UPDATE);
  },

  /**
   * Serialize the data in this list into a plain object.
   *
   * @param {number=} limit Optional limit parameter. Controls how many levels
   *     deep to serialize.
   *
   * @return {Array} The data array.
   */
  serialize: function serialize(limit) {
    if (limit === 0) return [];

    var array = [];
    var nextLimit = limit === undefined ? undefined : limit - 1;

    for (var i = 0; i < this.length; i++) {
      var value = this.values[i];
      var serializedValue = value;
      if (value && value.serialize) {
        serializedValue = value.serialize(nextLimit);
      }
      array.push(serializedValue);
    }

    return array;
  },

  _getDataFromMask: function _getDataFromMask(mask) {
    var items = [];

    if (mask.length > 0) {
      // The provided mask to a list is the mask for each list item, so we need
      // to loop through all the items and get the data from each item based on
      // the mask.
      for (var i = 0, l = this.length; i < l; i++) {
        var item = this.get(i);
        var parsedItem;
        var isObjectOrList = item && item._getDataFromMask;
        if (isObjectOrList) {
          parsedItem = item._getDataFromMask(mask);
        }
        items.push(parsedItem);
      }
    }

    return items;
  },

  _query: function _query(selector, callback, mode) {
    var self = this;

    var query = function query() {
      queryList(self, selector, function (error, data, wasSync) {
        if (error) return callback(error);

        if (!wasSync) {
          self._query(selector, callback, mode);
        } else {
          callback(null, data);
        }
      });
    };

    if (mode === ASYNC) defer(query);else query();
  },

  /**
   * Query properties in this list.
   * This can be called in two different ways: with a callback or without. When
   * calling it with a callback, it will wait for any missing data and always
   * return the data you queried for. When calling it without a callback, it
   * will return an array structure with only the data that was found in the
   * object at the moment. It will not kick off any events for waiting for
   * properties.
   *
   * @param {String} selector - The query selector. Only selectors without
   *     filters are supported when not providing a callback.
   * @param {Array} params - The query replace parameters.
   * @param {LiveList~queryCallback} callback - The callback that handles the response.
   * @param {Object} [mode] live.SYNC: Force sync, 2: live.ASAP: Don't force async
   * @param {Number} timeout - optional timeout in milliseconds
   *
   * @return {LiveList|Array} If no callback is passed it returns an array with
   *                             the data matching the query, that was found at
   *                             the moment in the list.
   *                             If a callback is passed it returns the instance.
   */
  query: function query(selector, params, callback, mode, timeout) {
    /**
     * @callback LiveList~queryCallback
     * @param {Error|Null} error - An error that you can throw, or null.
     * @param {Array} [data] - The response as an array.
     */
    if (typeof params === 'function') {
      // shift for empty params
      timeout = mode;
      mode = callback;
      callback = params;
      params = [];
    }

    if (!callback) {
      return this._getDataFromMask(parse(selector, params).mask);
    }

    if (!mode) {
      mode = ASYNC;
    } else if (isNumber(mode)) {
      // shift once again
      timeout = mode;
      mode = ASYNC;
    }

    if (timeout) {
      callback = createTimedCallback(callback, timeout);
    }

    this._query(parse(selector, params), callback, mode);
    return this;
  },

  _wait: function _wait(ranges) {
    if (!this._required) {
      // if _required is set, it was deferred already
      this._required = [];
      defer(function () {
        var missingFromIndex = this.missing(this._required);
        var missingFromWaiting = rdifference(missingFromIndex, this._waiting);
        this._waiting = rcombine(this._waiting, missingFromWaiting);
        delete this._required;
        if (missingFromWaiting.length) this.emit('wait', missingFromWaiting, EMIT_SYNC);
      }, this);
    }
    this._required = rcombine(this._required, ranges);
  },

  missing: function missing(ranges) {
    return rdifference(ranges, this.index);
  },

  // the raw, unbeautified get
  // this can callback sync or async
  _get: function _get(ranges, callback) {
    if (this.missing(ranges).length) {
      // has missing stuff (no matter what)
      this._wait(ranges);

      var check = function check() {
        var needed = this.missing(ranges);
        if (!needed.length) {
          this.off('update', check);
          callback.call(this);
        }
      };

      this.on('update', check);
    } else {
      // the callback is called with 'true' when syncronous.
      callback.call(this, null, true);
    }
  },

  /**
   * Checks if the range has been set with values in the list.
   *
   * @param {number} fromIndex The index to start from.
   * @param {number=} toIndex Optional index to stop at (non-inclusive). If no
   *     toIndex is specified, it will default to the index after fromIndex, to
   *     check for the single item at fromIndex.
   *
   * @return {Boolean} True if the range has been set.
   */
  has: function has(fromIndex, toIndex) {
    var hasToIndex = toIndex !== undefined;
    if (!hasToIndex) toIndex = fromIndex + 1;

    var range = new Range(fromIndex, toIndex);

    return range.contained(this.index);
  },

  /**
   * Gets items from the list between the specified indices.
   * @param {Number} what - The index to start from.
   * @param {Number} [toIndex=fromIndex + 1] - The index to stop at (non-inclusive).
   * @param {LiveList~getCallback} [callback] - Optional callback function. If no toIndex
   *     is specified, the callback can be placed as the second argument.
   * @param {Object} [mode] live.SYNC: Force sync, 2: live.ASAP: Don't force async
   * @param {Number} timeout - optional timeout in milliseconds
   * @return {LiveList|Array} If no callback is specified, returns the requested items in an array.
   *                          If a callback is specified, the method returns the instance.
   */
  get: function get(fromIndex, toIndex) {
    /**
     * @callback LiveList~getCallback
     * @param {Error|Null} error - An error that you can throw, or null.
     * @param {Array|*} [data] - The response as an array.
     *                           If toIndex is not specified a single item on the list is passed.
     */

    // fast, get one
    if (arguments.length === 1) {
      if (isNumber(fromIndex)) return this.values[fromIndex];
      if (isString(fromIndex)) return this.valueOf(fromIndex);
    }

    var self = this;

    var args = slice_.call(arguments);
    var callback, mode, requested;

    for (var i = 0, len = args.length; i < len; i++) {
      var arg = args[i];
      if (typeof arg === 'function') {
        var split = args.splice(i, 3);
        len = args.length;
        callback = split[0];
        if (split[1]) {
          if (split[1] === SYNC || split[1] === ASYNC || split[1] === ASAP) {
            mode = split[1];
          } else {
            // assume this arg is a timeout
            mode = ASYNC;
            callback = createTimedCallback(callback, split[1]);
            break;
          }
          // is there a timeout ?
          if (split[2] && mode !== SYNC) {
            callback = createTimedCallback(callback, split[2]);
          }
        } else {
          mode = ASYNC;
        }
        break;
      }
    }

    var asArray = false;
    var asSingleValue = false;

    if (fromIndex instanceof Range) {
      // one range
      requested = args;
      asArray = !callback && requested.length > 1;
    } else if (isArray(fromIndex)) {
      // array of ranges
      asArray = true;
      requested = fromIndex;
    } else {
      // numbers ?
      var hasToIndex = !isNaN(toIndex);
      if (!hasToIndex) toIndex = fromIndex + 1;
      asSingleValue = !hasToIndex;
      requested = [new Range(fromIndex, toIndex)];
    }

    var result = function result() {
      return map(requested, function (range) {
        return self.values.slice(range.start, range.end);
      });
    };

    var done = function done() {
      if (asArray) callback.call(self, null, result());else if (asSingleValue) callback.call(self, null, self.values[fromIndex]);else callback.apply(self, [null].concat(result()));
    };

    if (!callback) {
      if (asArray) return result();
      return result()[0];
    } else if (mode === SYNC) {
      done();
    } else {
      if (mode === ASYNC && !this.missing(requested).length) {
        // it has all the data but needs to be ASYNC
        defer(function () {
          this._get(requested, done);
        }, this);
      } else {
        this._get(requested, done);
      }
    }
    return this;
  }

});

var LiveObject = prime( /** @lends LiveObject.prototype */{

  mixin: Emitter,

  /**
   * A representation of an object which may be observed for changes
   * @constructs
   * @mixes Emitter
   */
  constructor: function LiveObject(_uri) {
    this.uri = _uri;
    this._data = { uri: _uri };
    this._mergeThrottled = throttle(this._merge, this);
    this.index = [];
    this._waiting = [];
    this.emit('init', EMIT_SYNC);

    var self = this;
    var lastWait = '';

    if (live.debug) setInterval(function () {
      var thisWait = self._waiting.toString();
      if (lastWait === thisWait) return;
      lastWait = thisWait;

      if (self._waiting.length) {
        console.warn(self, self._waiting);
      } else {
        console.warn(self, 'all done');
      }
    }, 2000);
  },

  emit: function emit() {
    var uri = this.uri;
    if (uri) {
      var keys = emitters.keys;
      var values = emitters.values;
      var key;
      var args;

      for (var i = 0, len = keys.length; i < len; i++) {
        key = keys[i];
        if (uri.match(key)) {
          if (!args) {
            args = new Array(arguments.length);
            for (var j = 0; j < arguments.length; ++j) {
              args[j] = arguments[j];
            }
            args.splice(1, 0, this);
          }
          var emitter = values[i];
          emitter.emit.apply(emitter, args);
        }
      }
    }

    Emitter.prototype.emit.apply(this, arguments);
  },

  _merge: function _merge() {
    var data = this._data; // the data
    var before = this._before; // an old copy of data
    var publish = this._publish; // published data
    var value;
    var key;

    // published changes
    if (publish) {
      delete this._publish;

      // emit change events if the object has a uri that can be subscribed too,
      // or the object in itself has listeners
      if (this.uri || this._listeners && this._listeners.publish) {
        var publishEvent = {};

        for (key in publish) {
          value = publish[key];
          if (data[key] !== value) publishEvent[key] = value;
        }

        if (Object.keys(publishEvent).length) {
          this.emit('publish', publishEvent, EMIT_SYNC);
        }
      }
    }

    // if there are changes
    if (before) {
      delete this._before;

      var updateEvent = {};

      // emit change events if the object has a uri that can be subscribed too,
      // or the object in itself has listeners
      if (this.uri || this._listeners && this._listeners.update) {
        // check changed and added keys
        for (key in data) {
          value = data[key];
          // there was no key, or value is different
          if (!(key in before) || before[key] !== value) updateEvent[key] = value;
        }

        // check deleted keys
        for (key in before) {
          value = before[key];
          // there is no key so it was deleted
          if (!(key in data)) updateEvent[key] = undefined;
        }

        if (Object.keys(updateEvent).length) {
          this.emit('update', updateEvent, EMIT_SYNC);
        }
      }
    }

    return this;
  },

  _update: function _update(object, method) {
    var branch;

    if (method === PUBLISH) {
      branch = this._publish || (this._publish = simpleClone(this._data));
    } else if (method === UPDATE) {
      if (!this._before) this._before = simpleClone(this._data);
      branch = this._data;
    }

    var value;
    for (var key in object) {
      value = object[key];
      var previous = !(key in branch) ? undefined : branch[key];

      if (isLiveList(previous)) {
        // updating lists with an array will keep the reference but replace every item.
        if (isArray(value)) {

          previous._update([{
            type: 'remove',
            index: 0,
            length: previous.length
          }, {
            type: 'insert',
            index: 0,
            values: value
          }], method);
          continue;
        } else if (isPlainObject(value) && 'operations' in value) {
          previous._update(value.operations, method);
          continue;
        }
      }

      if (method === UPDATE && value === undefined) delete branch[key];else branch[key] = transform(value, method);
    }

    if (method === UPDATE) {
      this.index = keys(branch);
      this._waiting = difference(this._waiting, this.index);
    }

    this._mergeThrottled();
    return this;
  },

  delete: function _delete(key) {
    var object = {};
    object[key] = undefined;
    return this.update(object);
  },

  update: function update(object) {
    return this._update(object, UPDATE);
  },

  publish: function publish(object) {
    return this._update(object, PUBLISH);
  },

  /**
   * Serialize the data in this object into a plain object.
   *
   * @param {number=} limit Optional limit parameter. Controls how many levels
   *     deep to serialize.
   *
   * @return {Object} The data object.
   */
  serialize: function serialize(limit) {
    if (limit === 0) return {};

    var object = {};
    var data = this._data;
    var nextLimit = limit === undefined ? undefined : limit - 1;

    for (var key in data) {
      var value = data[key];
      if (value === undefined) continue;
      var serializedValue = value;
      if (value && value.serialize) {
        serializedValue = value.serialize(nextLimit);
      }
      object[key] = serializedValue;
    }

    return object;
  },

  _getDataFromMask: function _getDataFromMask(mask) {
    var data = {};

    for (var i = 0, l = mask.length; i < l; i++) {
      var thisMask = mask[i];
      var nextMask = thisMask.mask;
      var key = thisMask.key;

      var realValue = this.get(key);
      var value = realValue;

      // Set the value to an empty object or array, and then it will be filled
      // in with the found data in the next step.
      if (isLiveObject(realValue)) value = {};
      if (isLiveList(realValue)) value = [];

      if (nextMask) {
        if (isLiveObject(realValue)) {
          var innerData = realValue._getDataFromMask(nextMask);
          deepMixIn(value, innerData);
        } else if (isLiveList(realValue)) {
          value = realValue._getDataFromMask(nextMask);
        }
      }

      data[key] = value;
    }

    return data;
  },

  _query: function _query(selector, callback, mode) {
    var self = this;

    var query = function query() {
      queryObject(self, selector, function (error, data, wasSync) {
        if (error) return callback.call(this, error);

        if (!wasSync) {
          self._query(selector, callback, mode);
        } else {
          callback.call(this, null, data);
        }
      });
    };

    if (mode === ASYNC) defer(query);else query();
  },

  /**
   * Query properties in this object.
   * This can be called in two different ways: with a callback or without. When
   * calling it with a callback, it will wait for any missing properties and
   * always return the data you queried for. When calling it without a callback,
   * it will return an object structure with only the data that was found in the
   * object at the moment. It will not kick off any events for waiting for
   * properties.
   *
   * @param {String} selector - The query selector. Only selectors without
   *     filters are supported when not providing a callback.
   * @param {Array} params - The query replace parameters. Optional.
   * @param {LiveObject~queryCallback} callback - The callback function.
   * @param {Object} [mode] live.SYNC: Force sync, 2: live.ASAP: Don't force async
   * @param {Number} timeout - optional timeout in milliseconds
   *
   * @return {LiveObject|Object} If no callback is passed it returns an object
   *                             with the data matching the query, that was found
   *                             at the moment in the object.
   *                             If a callback is passed it returns the instance.
   */
  query: function query(selector, params, callback, mode, timeout) {
    /**
     * @callback LiveObject~queryCallback
     * @param {Error|Null} error - An error that you can throw, or null.
     * @param {LiveObject} [data] - The response as a plain object.
     */
    if (typeof params === 'function') {
      // shift for empty params
      timeout = mode;
      mode = callback;
      callback = params;
      params = [];
    }

    if (!callback) {
      return this._getDataFromMask(parse(selector, params).mask);
    }

    if (!mode) {
      mode = ASYNC;
    } else if (isNumber(mode)) {
      // shift once again
      timeout = mode;
      mode = ASYNC;
    }

    if (timeout) {
      callback = createTimedCallback(callback, timeout);
    }

    this._query(parse(selector, params), callback, mode);
    return this;
  },

  _wait: function _wait(keys) {
    if (!this._required) {
      // if _required is set, it was deferred already
      this._required = [];
      defer(function () {
        var missingFromIndex = this.missing(this._required);
        var missingFromWaiting = difference(missingFromIndex, this._waiting);
        this._waiting = combine(this._waiting, missingFromWaiting);
        delete this._required;
        if (missingFromWaiting.length) this.emit('wait', missingFromWaiting, EMIT_SYNC);
      }, this);
    }
    this._required = combine(this._required, keys);
  },

  missing: function missing(keys) {
    return difference(keys, this.index);
  },

  /**
   * Checks if the key has been set in the object.
   *
   * @param {string} key The name of the key.
   *
   * @return {Boolean} True if the key has been set.
   */
  has: function has(key) {
    return this.index.indexOf(key) > -1;
  },

  // the raw, unbeautified get
  // this can callback sync or async
  _get: function _get(keys, callback) {
    if (this.missing(keys).length) {
      this._wait(keys);

      var check = function check() {
        var needed = this.missing(keys);
        if (!needed.length) {
          this.off('update', check);
          callback.call(this);
        }
      };
      this.on('update', check);
    } else {
      // the callback is called with 'true' when syncronous.
      callback.call(this, null, true);
    }
  },

  /**
   * Gets values from the object.
   * @param {...String|Array} keys - An array of strings as arguments.
   * @param {LiveObject~getCallback} [callback] - Optional callback function.
   * @param {Object} [mode] live.SYNC: Force sync, 2: live.ASAP: Don't force async
   * @param {Number} timeout - optional timeout in milliseconds
   * @return {LiveObject|Array|*} If no callback is passed and keys is either an array or multiple arguments
   *                             returns the values in an array.
   *                             If no callback is passed and keys is a single parameter it
   *                             returns the requested value (any type).
   *                             If a callback is passed it returns the instance.
   */
  get: function get(key) {
    /**
     * @callback LiveObject~getCallback
     * @param {Error|Null} error - An error that you can throw, or null.
     * @param {Array|...*} [data] - If keys are requested as arguments (any #)
     *                              it will return many results as arguments.
     *                              If keys are requested as an array (any #), it will return data as an array
     * @param {Number} [mode] 1: FORCE SYNC, 2: DON'T FORCE ASYNC
     */

    // fast, get one
    var data = this._data;
    if (arguments.length === 1 && isString(key)) return data[key];

    var self = this;

    var args = slice_.call(arguments);
    var callback, mode, keys;

    for (var i = 0, len = args.length; i < len; i++) {
      var arg = args[i];
      if (typeof arg === 'function') {
        var split = args.splice(i, 3);
        len = args.length;
        callback = split[0];
        if (split[1]) {
          if (split[1] === SYNC || split[1] === ASYNC || split[1] === ASAP) {
            mode = split[1];
          } else {
            // assume this arg is a timeout
            mode = ASYNC;
            callback = createTimedCallback(callback, split[1]);
            break;
          }
          // is there a timeout ?
          if (split[2] && mode !== SYNC) {
            callback = createTimedCallback(callback, split[2]);
          }
        } else {
          mode = ASYNC;
        }
        break;
      }
    }

    var asArray = false;

    if (isArray(key)) {
      keys = key;
      asArray = true;
    } else {
      keys = args;
    }

    var done = function done() {
      var vals = values(data, keys);
      if (asArray) {
        callback.call(self, null, vals);
      } else {
        vals.unshift(null); // unshift no error
        callback.apply(self, vals);
      }
    };

    if (!callback) {
      return values(data, keys);
    } else if (mode === SYNC) {
      done();
    } else {
      if (mode === ASYNC && !this.missing(keys).length) {
        // it has all the data but needs to be ASYNC
        defer(function () {
          self._get(keys, done);
        });
      } else {
        this._get(keys, done);
      }
    }

    return this;
  }

});

var queryAny = function queryAny(object, selector, callback) {
  if (isPlainObject(object) || isLiveObject(object)) return queryObject(object, selector, callback);else if (isArray(object) || isLiveList(object)) return queryList(object, selector, callback);else return callback(null, object, true);
};

var queryObject = function queryObject(object, selector, callback) {
  var data = {};
  var isSync = true;

  if (!selector) callback(null, data, isSync);

  var keys = map(selector.mask, 'key');

  var done = function done(values) {
    flow().parallel(values, function (objectValue, i) {
      var control = this;
      queryAny(objectValue, selector.mask[i], function (error, dataValue, wasSync) {
        if (error) return control.break(error);
        if (!wasSync) isSync = false;
        if (data[keys[i]]) deepMixIn(data[keys[i]], dataValue);else data[keys[i]] = dataValue;
        control.done();
      });
    }).finally(function (error) {
      callback(error, data, isSync);
    });
  };

  if (isLiveObject(object)) {
    object._get(keys, function (error, wasSync) {
      if (error) return callback(error);
      if (!wasSync) isSync = false;
      var values = map(keys, function (key) {
        return object._data[key];
      });
      done(values);
    });
  } else {
    var values = pick(object, keys);
    done(values);
  }
};

var satisfies = function satisfies(value, op, right) {
  if (!op) return !!value;
  if (isRegExp(right)) return right.test(value);

  if (op === '=') return value === right;
  if (op === '!=') return value !== right;

  if (isNumber(right)) {
    if (op === '>') return value > right;
    if (op === '>=') return value >= right;
    if (op === '<') return value < right;
    if (op === '<=') return value <= right;
  }

  if (isString(right)) {
    var escapedRight = escapeRegExp(right);
    // starts with
    if (op === '^=') return new RegExp('^' + escapedRight).test(value);
    // ends with
    if (op === '$=') return new RegExp(escapedRight + '$').test(value);
    // contains separated by space e.g. 'list of things to look for' ~= 'list'
    if (op === '~=') return new RegExp('(^|\\s)' + escapedRight + '(\\s|$)').test(value);
    // contains separated by - e.g. 'list-of-things-to-look-for' ~= 'things'
    if (op === '|=') return new RegExp('^' + escapedRight + '(-|$)').test(value);
    // contains e.g. 'listofthingstolookfor' ~= 'look'
    if (op === ' *=') return value.toString().indexOf(right) !== -1;
  }

  return false;
};

var filterArray = function filterArray(array, left, op, right, callback) {
  var isSync = true;

  var filtered = [];

  flow().parallel(array, function (item, i) {
    var ctrl = this;

    if (isLiveObject(item)) {
      item._get([left], function (error, wasSync) {
        if (error) return ctrl.break(error);
        if (!wasSync) isSync = false;
        var value = item._data[left];
        if (satisfies(value, op, right)) filtered[i] = item;
        ctrl.done();
      });
    } else if (isPlainObject(item)) {
      if (satisfies(item[left], op, right)) filtered[i] = item;
      ctrl.done();
    } else {
      // filter objects only
      ctrl.done();
    }
  }).finally(function (error) {
    if (error) return callback(error);
    var clean = [];
    for (var i = 0; i < filtered.length; i++) {
      if (i in filtered) clean.push(filtered[i]);
    }callback(null, clean, isSync);
  });
};

// default filter that filters the whole list.
var defaultFilters = [[{
  left: 0,
  op: ':'
}]];

var queryList = function queryList(list, selector, callback) {
  var isSync = true;
  // if there are no filters we need to query the full length
  if (!selector.filters) selector.filters = defaultFilters;

  // single filter.
  // must be sequential.
  flow().sequential(selector.filters, function (conditions) {
    var sequential = this;

    var ref = [];

    // list of conditions in a single filter.
    // can be parallel.
    flow().parallel(conditions, function (condition) {
      var parallel = this;

      var left = condition.left;
      var right = condition.right;
      var op = condition.op;

      if ('left' in condition && !('right' in condition) && isNumber(left)) {
        if (!op) right = left + 1;else if (op === ':') right = list.length;
        op = ':';
      }

      if ('right' in condition && !('left' in condition) && isNumber(right) && op === ':') {
        left = 0;
      }

      // filter by range.
      if (isNumber(left) && isNumber(right) && op === ':') {
        // if the list is an array it means it has already been filtered.
        if (isArray(list)) {
          var filtered = slice_.call(list, left, right);
          ref = ref.concat(filtered);
          parallel.done();
        } else {
          list._get([new Range(left, right)], function (error, wasSync) {
            if (error) return parallel.break(error);

            for (var i = left; i < right; i++) {
              ref.push(list.values[i]);
            }if (!wasSync) isSync = false;
            parallel.done();
          });
        }
      } else {

        var done = function done(array) {
          filterArray(array, left, op, right, function (error, filtered, wasSync) {
            if (error) return parallel.break(error);

            if (!wasSync) isSync = false;
            ref = ref.concat(filtered);
            parallel.done();
          });
        };

        if (isArray(list)) {
          done(list);
        } else {
          // the list is not an array, never been filtered.
          // assume full length.
          // call a function that filters an array once you arraify it.
          list._get([new Range(0, list.length)], function (error, wasSync) {
            if (error) return parallel.break(error);

            var array = [];
            for (var i = 0; i < list.length; i++) {
              array.push(list.values[i]);
            }if (!wasSync) isSync = false;
            done(array);
          });
        }
      }

      // parallel finished
    }).finally(function (error) {
      if (error) return sequential.break(error);
      list = ref;
      sequential.continue();
    });

    // sequential finished
  }).finally(function (error) {
    if (error) return callback(error);

    var data = [];

    // final parallel
    flow().parallel(list, function (item, i) {
      var control = this;
      queryAny(item, selector, function (err, res, wasSync) {
        if (!wasSync) isSync = false;
        if (data[i]) deepMixIn(data[i], res);else data[i] = res;
        control.done(err);
      });
    }).finally(function (err) {
      callback(err, data, isSync);
    });
  });
};

var cache = {};

/**
 * Create a new instance of a object, based on an unique identifier.
 * @function
 * @static
 * @param {String|LiveObject} item - An object with an uri property, or an uri as a string.
 * @return {LiveObject|LiveList} An instance of LiveObject or LiveList.
 */
var live = function live(item) {
  if (isArray(item)) {
    return new LiveList().update([{
      type: 'insert',
      index: 0,
      length: item.length,
      values: item
    }]);
  } else if (isNumber(item)) {
    return new LiveList(item);
  } else if (isString(item)) {
    return cache[item] || (cache[item] = new LiveObject(item));
  } else if (isPlainObject(item)) {
    return live(item.uri).update(item);
  } else if (isLiveList(item) || isLiveObject(item)) {
    return item;
  }

  return new LiveObject();
};

// Allow localStorage.debug to also control live.debug.
if (global.localStorage && global.localStorage.debug && (global.localStorage.debug.indexOf('spotify-live') > -1 || global.localStorage.debug.indexOf('*') > -1)) {
  live.debug = true;
}

var emitters = {
  keys: [],
  values: []
};

/**
 * Subscribe to the specific event of objects matching the pattern.
 * @function
 * @static
 * @param {RegExp} match - Regular expression for matching uris.
 * @param {String} name - The name of the event to listen for.
 * @param {Function} handle - The event handle.
 * @return {Function} The live function.
 */
live.subscribe = function (match, name, handle) {
  if (match.matches) match = match.matches;

  var string = match.toString();

  var keys = emitters.keys;
  var values = emitters.values;

  var emitter;
  for (var i = 0, len = keys.length; i < len; i++) {
    var key = keys[i];
    if (key.toString() === string) {
      emitter = values[i];
      if (emitter) break;
    }
  }

  if (!emitter) {
    keys.push(match);
    values.push(emitter = new Emitter());
  }

  emitter.on(name, handle);

  return this;
};

/**
 * Unsubscribe to the specific event of objects matching the pattern.
 * @function
 * @static
 * @param {RegExp} match - Regular expression for matching uris.
 * @param {String} name - The name of the event to unsubscribe from.
 * @param {Function} handle - The event handle.
 * @return {Function} The live function.
 */
live.unsubscribe = function (match, name, handle) {
  if (match.matches) match = match.matches;

  var string = match.toString();

  var keys = emitters.keys;
  var values = emitters.values;

  var emitter;
  for (var i = 0, len = keys.length; i < len; i++) {
    var key = keys[i];
    if (key.toString() === string) {
      emitter = values[i];
      if (emitter) break;
    }
  }

  if (emitter) emitter.off(name, handle);

  return this;
};

/**
 * Delete a model from the live cache.
 *
 * @param {string} uri A uri.
 *
 * @return {Function} The live function.
 */
live.delete = function (uri) {
  delete cache[uri];
  return this;
};

/**
 * Purge the entire cache.
 *
 * @return {Function} The live function.
 */
live.purge = function () {
  cache = {};
  return this;
};

/**
 * Check if live has an object for the URI in the cache.
 *
 * @param {string} uri A uri.
 *
 * @return {Boolean} True if the object is in the cache.
 */
live.has = function (uri) {
  return !!cache[uri];
};

var EMIT_SYNC = live.EMIT_SYNC = Emitter.EMIT_SYNC;

var ASYNC = live.ASYNC = 'ASYNC';
var SYNC = live.SYNC = 'SYNC';
var ASAP = live.ASAP = 'ASAP';

var PUBLISH = 3;
var UPDATE = 4;

/**
 * @static
 * @see LiveObject
 */
live.Object = LiveObject;

/**
 * @static
 * @see LiveList
 */
live.List = LiveList;

module.exports = live;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-range2":244,"./util/ordered-set":219,"./util/parser":220,"./util/throttle":221,"finally":273,"mout/array/combine":304,"mout/array/difference":306,"mout/array/filter":308,"mout/array/map":312,"mout/lang/isArray":321,"mout/lang/isPlainObject":324,"mout/lang/isRegExp":325,"mout/object/deepMixIn":329,"mout/object/keys":333,"mout/object/pick":335,"mout/string/escapeRegExp":337,"prime":345,"prime/defer":343,"prime/emitter":344}],218:[function(require,module,exports){
/**
 * @module spotify-live/diff
 */
'use strict';

// Original code from: https://github.com/codeparty/arraydiff
// License: MIT
// This has been forked to allow for optimizations and patching operations.

// Based on some rough benchmarking, this algorithm is about O(n^2) worst case,
// and it can compute diffs on random arrays of length 1024 in about 34ms,
// though just a few changes on an array of length 1024 takes about 0.5ms

var splice_ = Array.prototype.splice;
var slice_ = Array.prototype.slice;

var annotate = function annotate(before, after) {
  // Find all items in both the before and after array, and represent them
  // as moves. Many of these "moves" may end up being discarded in the last
  // pass if they are from an index to the same index, but we don't know this
  // up front, since we haven't yet offset the indices.
  //
  // Also keep a map of all the indicies accounted for in the before and after
  // arrays. These maps are used next to create insert and remove diffs.
  var beforeLength = before.length;
  var afterLength = after.length;
  var moves = [];
  var beforeMarked = {};
  var afterMarked = {};
  for (var beforeIndex = 0; beforeIndex < beforeLength; beforeIndex++) {
    var beforeItem = before[beforeIndex];
    for (var afterIndex = 0; afterIndex < afterLength; afterIndex++) {
      if (afterMarked[afterIndex]) continue;
      if (beforeItem !== after[afterIndex]) continue;
      var from = beforeIndex;
      var to = afterIndex;
      var length = 0;
      do {
        beforeMarked[beforeIndex++] = afterMarked[afterIndex++] = true;
        length++;
      } while (beforeIndex < beforeLength && afterIndex < afterLength && before[beforeIndex] === after[afterIndex] && !afterMarked[afterIndex]);
      var moveDiff = {
        type: 'move',
        from: from,
        to: to,
        length: length
      };
      moves.push(moveDiff);
      beforeIndex--;
      break;
    }
  }

  // Create a remove for all of the items in the before array that were
  // not marked as being matched in the after array as well
  var removes = [];
  for (beforeIndex = 0; beforeIndex < beforeLength;) {
    if (beforeMarked[beforeIndex]) {
      beforeIndex++;
      continue;
    }
    var index = beforeIndex;
    var length = 0;
    while (beforeIndex < beforeLength && !beforeMarked[beforeIndex++]) {
      length++;
    }
    var removeDiff = {
      type: 'remove',
      index: index,
      length: length,
      values: slice_.call(before, index, index + length)
    };
    removes.push(removeDiff);
  }

  // Create an insert for all of the items in the after array that were
  // not marked as being matched in the before array as well
  var inserts = [];
  for (afterIndex = 0; afterIndex < afterLength;) {
    if (afterMarked[afterIndex]) {
      afterIndex++;
      continue;
    }
    var index = afterIndex;
    var length = 0;
    while (afterIndex < afterLength && !afterMarked[afterIndex++]) {
      length++;
    }
    var values = slice_.call(after, index, index + length);
    inserts.push({ type: 'insert', index: index, length: length, values: values });
  }

  return [removes, moves, inserts];
};

var offset = function offset(removes, moves, inserts) {

  var insertsLength = inserts.length;
  var removesLength = removes.length;
  var movesLength = moves.length;
  var i, j;

  // Offset subsequent removes and moves by removes
  var count = 0;
  for (i = 0; i < removesLength; i++) {
    var remove = removes[i];
    remove.index -= count;
    count += remove.length;
    for (j = 0; j < movesLength; j++) {
      var move = moves[j];
      if (move.from >= remove.index) move.from -= remove.length;
    }
  }

  // Offset moves by inserts
  for (i = insertsLength; i--;) {
    var insert = inserts[i];
    var length = insert.length;
    for (j = movesLength; j--;) {
      var move = moves[j];
      if (move.to >= insert.index) move.to -= length;
    }
  }

  // Offset the to of moves by later moves
  for (i = movesLength; i-- > 1;) {
    var move = moves[i];
    if (move.to === move.from) continue;
    for (j = i; j--;) {
      var earlier = moves[j];
      if (earlier.to >= move.to) earlier.to -= move.length;
      if (earlier.to >= move.from) earlier.to += move.length;
    }
  }

  // Only output moves that end up having an effect after offsetting
  var outputMoves = [];

  // Offset the from of moves by earlier moves
  for (i = 0; i < movesLength; i++) {
    var move = moves[i];
    if (move.to === move.from) continue;
    outputMoves.push(move);
    for (j = i + 1; j < movesLength; j++) {
      var later = moves[j];
      if (later.from >= move.from) later.from -= move.length;
      if (later.from >= move.to) later.from += move.length;
    }
  }

  // try to reduce the number of move events
  reduceMoves(outputMoves);

  return removes.concat(outputMoves, inserts);
};

var reduceMoves = function reduceMoves(moves) {
  for (var i = 0; i < moves.length; i++) {

    // if we detect a move operation of a lots of items to a near position, we
    // can swap it by a move operation of less items to a farther position
    // (which is going to be much more performant).
    //
    // Example:
    // [1, 2, 3, 4, 5, 6, 7] => [2, 3, 4, 5, 6, 7, 1]
    // We could move [2, 3, 4, 5, 6, 7] one position ahead, but it's better to
    // move [1] six positions behind.
    if (moves[i].length > Math.abs(moves[i].to - moves[i].from)) {
      var from = moves[i].from;
      var to = moves[i].to;
      var length = moves[i].length;

      moves[i].length = Math.abs(moves[i].to - moves[i].from);
      moves[i].from = to;
      moves[i].to = to + length;
    }
  }
};

var insert = function insert(array, index, values) {
  for (var i = 0; i < values.length; i++) {
    if (i in values) {
      var idx = index + i;
      if (array.length < idx) array.length = idx;
      array.splice(idx, 0, values[i]);
    }
  }
  return values;
};

var remove = function remove(array, index, length) {
  return splice_.call(array, index, length);
};

var move = function move(array, from, to, length) {
  var moved = remove(array, from, length);
  insert(array, to, moved);
  return moved;
};

var patch = function patch(array, operations) {
  for (var i = 0; i < operations.length; i++) {
    var operation = operations[i];
    switch (operation.type) {
      case 'move':
        move(array, operation.from, operation.to, operation.length);break;
      case 'remove':
        remove(array, operation.index, operation.length);break;
      case 'insert':
        insert(array, operation.index, operation.values);break;
    }
  }
  return array;
};

var diff = function diff(before, after) {
  var operations = annotate(before, after);
  return offset.apply(this, operations);
};

diff.annotate = annotate;
diff.offset = offset;

diff.remove = remove;
diff.insert = insert;
diff.move = move;
diff.patch = patch;

module.exports = diff;

},{}],219:[function(require,module,exports){
/**
 * @module spotify-live/util/ordered-set
 * @private
 */
'use strict';

// prime

var prime = require('prime');

// mout
var forEach = require('mout/array/forEach');

var Range = require('../../spotify-range2');
var _diff = require('./diff');

var OrderedSet = prime({

  constructor: function constructor(length) {
    if (!length) length = 0;
    this.index = [];
    this.keys = new Array(length);
    this.values = new Array(length);
    this.objectStorage = {};
  },

  get length() {
    return this.keys.length;
  },

  set length(value) {
    this.keys.length = value;
    this.values.length = value;
  },

  forEach: function forEach(fn, ctx) {
    var index = this.index;
    main: for (var k = 0; k < index.length; k++) {
      var range = index[k];
      for (var i = range.start; i < range.end; i++) {
        if (fn.call(ctx, this.values[i], i, this.keys[i], this) === false) break main;
      }
    }
    return this;
  },

  map: function map(fn, ctx) {
    var values = new Array(this.length);
    this.forEach(function (value, index, key) {
      values[index] = fn.call(ctx, value, index, key, this);
    }, this);
    return values;
  },

  copy: function copy(set) {
    this.index = set.index.slice();
    this.keys = set.keys.slice();
    this.values = set.values.slice();
    var length = this.keys.length;
    this.objectStorage = {};
    for (var i = 0; i < length; i++) {
      this.objectStorage[this.keys[i]] = this.values[i];
    }
    return this;
  },

  clone: function clone() {
    return new OrderedSet().copy(this);
  },

  indexOf: function indexOf(key) {
    var index = -1;
    this.forEach(function (v, i, k) {
      if (key === k) {
        index = i;
        return false;
      }
    });
    return index;
  },

  indexOfMany: function indexOfMany(keys) {
    var indexedKeys = {};
    var found = 0;
    var output = [];

    // create a hash with the keys that are going to be searched, so we can
    // access them really fast later
    for (var i = 0; i < keys.length; i++) {
      indexedKeys[keys[i]] = -1;
    }

    this.forEach(function (v, i, k) {
      // If the element one that is being searched, add its position
      // to the output array
      if (k in indexedKeys) {
        indexedKeys[k] = i;
        found++;

        // when we have found all the search keys, we do not need to iterate
        // any more
        if (found >= keys.length) {
          return false;
        }
      }
    });

    for (i = 0; i < keys.length; i++) {
      output[i] = indexedKeys[keys[i]];
    }

    return output;
  },

  valueOf: function valueOf(key) {
    return this.objectStorage[key] || null;
  },

  hasKey: function hasKey(key) {
    return this.objectStorage.hasOwnProperty(key);
  },

  sort: function sort(fn) {
    var keys = this.keys;
    var values = this.values;
    var operations = _diff(values.slice(), values.sort(fn));

    forEach(operations, function (op) {
      // unless something is broken, a sort only produces moves.
      _diff.move(keys, op.from, op.to, op.length);
    });

    return this;
  },

  move: function move(from, to, length) {
    if (from > this.length) return [];
    if (from + length > this.length) length = from - this.length;
    if (to > this.length) to = this.length;
    if (from === to) return [];

    _diff.move(this.keys, from, to, length);
    _diff.move(this.values, from, to, length);

    return this;
  },

  insert: function insert(index, keys, values) {
    if (keys.length !== values.length) throw new Error('length mismatch');

    var range = new Range(index, index + keys.length);
    this.index = range.insert(this.index);

    _diff.insert(this.keys, index, keys);
    _diff.insert(this.values, index, values);

    for (var i = 0, length = keys.length; i < length; i++) {
      this.objectStorage[keys[i]] = values[i];
    }

    return this;
  },

  remove: function remove(index, length) {
    if (index >= this.length) return [];
    if (index + length > this.length) length = this.length;
    var range = new Range(index, index + length);
    this.index = range.extract(this.index);

    for (var i = 0; i < length; i++) {
      delete this.objectStorage[this.keys[i + index]];
    }
    _diff.remove(this.keys, index, length);
    _diff.remove(this.values, index, length);

    return this;
  },

  diff: function diff(target) {
    var operations = _diff.annotate(this.keys, target.keys);

    forEach(operations[0], function (op) {
      // remove
      op.keys = op.values;
      op.values = this.values.slice(op.index, op.index + op.length);
    }, this);

    forEach(operations[1], function (op) {
      // move
      op.keys = op.values;
      op.values = this.values.slice(op.from, op.from + op.length);
    }, this);

    forEach(operations[2], function (op) {
      // insert
      op.keys = op.values;
      op.values = target.values.slice(op.index, op.index + op.length);
    });

    return _diff.offset.apply(_diff, operations);
  },

  patch: function patch(operations) {
    forEach(operations, function (op) {
      switch (op.type) {
        case 'move':
          this.move(op.from, op.to, op.length);break;
        case 'remove':
          this.remove(op.index, op.length);break;
        case 'insert':
          this.insert(op.index, op.keys, op.values);break;
      }
    }, this);
    return this;
  }

});

module.exports = OrderedSet;

},{"../../spotify-range2":244,"./diff":218,"mout/array/forEach":309,"prime":345}],220:[function(require,module,exports){
/**
 * @module spotify-live/util/parser
 */
'use strict';

var normalize = function normalize(value) {
  if (value !== '' && !isNaN(value)) return +value;else if (value === 'true') return true;else if (value === 'false') return false;else if (value === 'null') return null;else if (value === 'undefined') return undefined;
  return value;
};

function escapeForRegExp(str) {
  return str.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
};

var COMMA = ',';
var BMASK = '(';
var EMASK = ')';
var BFILTER = '[';
var EFILTER = ']';
var EQUALS = '=';
var WHITESPACE = '\\s';

var operators = ['=', '!=', '>=', '<=', '>', '<', '^=', '$=', '~=', '|=', '*='];

var keyBlacklist = COMMA + BMASK + EMASK + escapeForRegExp(BFILTER) + escapeForRegExp(EFILTER) + EQUALS + WHITESPACE;
var keyBlacklistCharacterClass = '[^' + keyBlacklist + ']';

var KEY_CHARACTER_REG_EXP = new RegExp(keyBlacklistCharacterClass);
var EXACT_KEY_REG_EXP = new RegExp('^' + keyBlacklistCharacterClass + '+$');

var OPERATORS_REG_EXP = new RegExp(operators.map(escapeForRegExp).join('|'));
var REPLACE_REG_EXP = /\$([\d]+)/;
var RANGE_FILTER_REG_EXP = /^(\d*):(\d*)$/;

var parse = function parse(string, params) {
  if (!params) params = [];

  var selector = { mask: [] };
  var history = [selector];

  var key = '';
  var filter;

  var filterStr = '';
  var left = '';
  var right = '';
  var op = '';

  for (var i = 0; i < string.length + 1; i++) {
    var c = string.charAt(i);

    if (filter) {
      // parse the filter
      filterStr = filterStr.trim();
      if (c === COMMA || c === EFILTER) {
        var matches;
        if (matches = filterStr.match(RANGE_FILTER_REG_EXP)) {
          left = matches[1];
          op = ':';
          right = matches[2];
        } else if (matches = filterStr.match(OPERATORS_REG_EXP)) {
          left = filterStr.substring(0, matches.index);
          op = matches[0];
          right = filterStr.substring(matches.index + op.length);
        } else if (matches = filterStr.match(EXACT_KEY_REG_EXP)) {
          left = matches[0];
        } else {
          throw new SyntaxError('syntax error: `' + filterStr + '` contains characters not valid in a filter');
        }

        filterStr = '';

        var condition = {};

        if (left) {
          var leftMatch = left.match(REPLACE_REG_EXP);
          left = leftMatch ? params[+leftMatch[1]] : normalize(left);
          condition.left = left;
        }

        if (op) condition.op = op;

        if (right) {
          var rightMatch = right.match(REPLACE_REG_EXP);
          right = rightMatch ? params[+rightMatch[1]] : normalize(right);
          condition.right = right;
        }

        if ('left' in condition || 'right' in condition) filter.push(condition);

        right = '';
        left = '';
        op = '';

        if (c === EFILTER) {
          if (filter.length) {
            var filters = selector.filters || (selector.filters = []);
            filters.push(filter);
          }

          filter = null;
        }
        continue;
      }

      filterStr += c;
    } else {
      // parse the key

      if (c && KEY_CHARACTER_REG_EXP.test(c)) {
        // key
        key += c;
      } else if (key && (!c || c === COMMA || c === BMASK || c === BFILTER || c === EMASK)) {
        // end key
        // end word is "a!" or "b(a!)" or "a!,c" or "a!(" or "a!["
        var keyMatch = key.match(REPLACE_REG_EXP);
        // begin a new selector
        history[0].mask.push(selector = { key: keyMatch ? params[+keyMatch[1]] : normalize(key) });
        key = '';
      } else if (c && key) {
        throw new SyntaxError('syntax error: `' + c + '` is not a valid character in a key');
      }

      if (c === BMASK) {
        selector.mask = [];
        history.unshift(selector);
      } else if (c === EMASK) {
        history.shift();
      }

      if (c === BFILTER) {
        filter = [];
      }
    }
  }

  if (history.length !== 1) throw new SyntaxError('syntax error');

  return history[0];
};

/** exports */
module.exports = parse;

},{}],221:[function(require,module,exports){
/**
 * @module spotify-live/util/throttle
 * @private
 */
'use strict';

var defer = require('prime/defer');
var isInteger = function isInteger(n) {
  return typeof n === 'number' && n % 1 === 0;
};

var slice = Array.prototype.slice;

var _throttle = function _throttle(fn, method, context) {
  var queued, args, cancel;

  return function () {
    args = arguments;
    if (!queued) {
      queued = true;
      cancel = method(function (time) {
        queued = false;
        fn.apply(context, slice.call(args).concat(time));
      });
    }
    return cancel;
  };
};

var throttle = function throttle(callback, argument, context) {
  if (isInteger(argument)) return throttle.timeout(callback, argument, context);else return throttle.immediate(callback, argument);
};

throttle.timeout = function (callback, ms, context) {
  return _throttle(callback, function (run) {
    return defer.timeout(run, ms, context);
  }, context);
};

throttle.frame = function (callback, context) {
  return _throttle(callback, function (run) {
    return defer.frame(run, context);
  }, context);
};

throttle.immediate = function (callback, context) {
  return _throttle(callback, function (run) {
    return defer.immediate(run, context);
  }, context);
};

module.exports = throttle;

},{"prime/defer":343}],222:[function(require,module,exports){
'use strict';

var languages = require('./languages.json');

function lookup(language, to) {
  var lang = languages[language];
  if (lang[to]) {
    return lang[to];
  } else {
    return language;
  }
}

module.exports = lookup;
module.exports.all = function () {
  return Object.keys(languages);
};

},{"./languages.json":223}],223:[function(require,module,exports){
module.exports={
  "de": {
    "smartling": "de-DE"
  },
  "el": {
    "smartling": "el-GR"
  },
  "en": {
    "smartling": "en-GB"
  },
  "es": {
    "numeral": "es-ES",
    "smartling": "es-ES"
  },
  "es-419": {
    "moment": "es",
    "numeral": "es-ES",
    "smartling": "es-LA"
  },
  "fi": {
    "smartling": "fi-FI"
  },
  "fr": {
    "smartling": "fr-FR"
  },
  "fr-CA": {
    "smartling": "fr-CA",
    "moment": "fr-ca"
  },
  "hu": {
    "smartling": "hu-HU"
  },
  "id": {
    "smartling": "id-ID"
  },
  "it": {
    "smartling": "it-IT"
  },
  "ja": {
    "smartling": "ja-JP"
  },
  "nl": {
    "numeral": "nl-nl",
    "smartling": "nl-NL"
  },
  "pl": {
    "smartling": "pl-PL"
  },
  "pt-BR": {
    "moment": "pt-br",
    "numeral": "pt-br",
    "smartling": "pt-BR"
  },
  "sv": {
    "smartling": "sv-SE"
  },
  "tr": {
    "smartling": "tr-TR"
  },
  "zh-Hant": {
    "moment": "zh-tw",
    "smartling": "zh-TW"
  },
  "zsm": {
    "moment": "ms-my",
    "smartling": "ms-MY"
  }
}
},{}],224:[function(require,module,exports){
'use strict';

/**
 * Object representing state of an app.
 *
 * @param {String} uri Spotify URI of app.
 * @constructor
 */

function AppState(uri) {
  /**
   * Spotify URI.
   *
   * @type {String}
   */
  this._uri = undefined;

  /**
   * String identifying what requested a state.
   *
   * @type {String}
   */
  this._referrer = undefined;

  if (uri !== undefined) {
    this.setURI(uri);
  }
}

/**
 * Create new instance of AppState based on JSON string.
 *
 * @param {String} json Serialized representation of AppState object.
 * @return {AppState} Instance of AppState.
 */
AppState.unserialize = function (json) {
  var s = JSON.parse(json);
  var a = new AppState();
  a.setURI(s.uri);
  a.setReferrer(s.referrer);
  return a;
};

/**
 * Test if another object is considered equal to this.
 *
 * @param {AppState} state AppState instance to compare.
 */
AppState.prototype.equals = function (state) {
  return typeof this._uri === 'string' && state instanceof AppState && this._uri === state._uri && this._referrer === state._referrer;
};

/**
 * Get App identifier.
 *
 * @return {String} Id of app contained in URI.
 */
AppState.prototype.getAppId = function () {
  var uri = this.getURI();
  var parts = uri.split(':');
  if (parts.length < 3) {
    return undefined;
  }
  if (parts[1] !== 'app') {
    return undefined;
  }
  if (parts[2] === '') {
    return undefined;
  }
  return parts[2];
};

/**
 * Get Referrer value.
 *
 * @return {String} Referrer value as string.
 */
AppState.prototype.getReferrer = function () {
  return this._referrer;
};

/**
 * Get URI value.
 *
 * @return {String} URI as string.
 */
AppState.prototype.getURI = function () {
  if (this._uri === undefined) {
    throw new Error('URI not set');
  }
  return this._uri;
};

/**
 * Create serialized representation of this instance.
 *
 * @return {String} Serialized representation of AppState object.
 */
AppState.prototype.serialize = function () {
  return JSON.stringify({
    uri: this.getURI(),
    referrer: this.getReferrer()
  });
};

/**
 * Set Referrer value.
 *
 * @param {String} referrer Referrer string.
 */
AppState.prototype.setReferrer = function (referrer) {
  this._referrer = referrer;
};

/**
 * Set URI value.
 *
 * @param {String} uri Spotify URI for app.
 */
AppState.prototype.setURI = function (uri) {
  if (typeof uri !== 'string') {
    throw new TypeError('URI must be string');
  }
  this._uri = uri;
};

module.exports = AppState;

},{}],225:[function(require,module,exports){
(function (global){
'use strict';

var inherit = require('spotify-inheritance/inherit');
var EventEmitter = require('spotify-eventemitter');
var AppState = require('./app-state');
var _global = global.top || global;

/**
 * Class containing methods for navigating.
 *
 * @constructor
 */
function Navigator() {
  EventEmitter.call(this);

  /**
   * Locally bound handler function for message event on global.
   *
   * @type {Function}
   */
  this._messageHandler = this._messageHandler.bind(this);
}

inherit(Navigator, EventEmitter);

/**
 * Maps constants to string values of known events.
 */
Navigator.EVENTS = {
  OPEN_STATE: 'navigation_open_state'
};

/**
 * Identify posted message and trigger relevant callbacks
 * based on the message contents.
 *
 * @param {Object} message Message object caused by postMessage.
 */
Navigator.prototype._messageHandler = function (message) {
  if (!message.data.type) {
    return;
  }
  var name = message.data.type;
  if (name === Navigator.EVENTS.OPEN_STATE) {
    var appState = AppState.unserialize(message.data.state);
    this.emitSync(name, { state: appState });
  }
};

/**
 * Start listening to messages.
 */
Navigator.prototype.attachListener = function () {
  _global.addEventListener('message', this._messageHandler);
};

/**
 * Stop listening to messages.
 */
Navigator.prototype.detachListener = function () {
  _global.removeEventListener('message', this._messageHandler);
};

/**
 * Send an open request message.
 *
 * @param {AppState} state AppState instance to base open action on.
 */
Navigator.prototype.requestOpenState = function (state) {
  _global.postMessage({
    type: Navigator.EVENTS.OPEN_STATE,
    state: state.serialize()
  }, '*');
};

module.exports = Navigator;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./app-state":224,"spotify-eventemitter":363,"spotify-inheritance/inherit":366}],226:[function(require,module,exports){
'use strict';

module.exports = function (numeral) {
  return {
    delimiters: {
      thousands: ',',
      decimal: '.'
    },
    abbreviations: {
      thousand: 'k',
      million: 'm',
      billion: 'b',
      trillion: 't'
    },
    ordinal: function ordinal(number) {
      var b = number % 10;
      return ~ ~(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
    },
    currency: {
      symbol: '$'
    }
  };
};

},{}],227:[function(require,module,exports){
'use strict';

var numeral = require('./numeraljs/numeral');
var locales = require('../spotify-locales');

module.exports = function (currentLanguage) {

  // We need to explicitly require all languages listed in spotify-locales
  // so that Quickstart can access them at runtime
  // (dynamic paths can't be cached).
  var languages = {
    'de': require('./numeraljs/languages/de'),
    // Custom en.js file
    'en': require('./en')(numeral),
    // es-419 falls back to es-es in Numeral.js
    'es-ES': require('./numeraljs/languages/es-ES'),
    'fi': require('./numeraljs/languages/fi'),
    'fr': require('./numeraljs/languages/fr'),
    'fr-CA': require('./numeraljs/languages/fr-CA'),
    'hu': require('./numeraljs/languages/hu'),
    'id': require('./numeraljs/languages/id'),
    'it': require('./numeraljs/languages/it'),
    'ja': require('./numeraljs/languages/ja'),
    'nl-nl': require('./numeraljs/languages/nl-nl'),
    'pl': require('./numeraljs/languages/pl'),
    'pt-br': require('./numeraljs/languages/pt-br'),
    'sv': require('./numeraljs/languages/sv'),
    'tr': require('./numeraljs/languages/tr')
  };

  var numeralLocale = locales(currentLanguage, 'numeral');
  if (!languages[numeralLocale]) {
    numeralLocale = 'en';
  }
  numeral.language(numeralLocale, languages[numeralLocale]);
  numeral.language(numeralLocale);

  return numeral;
};

},{"../spotify-locales":222,"./en":226,"./numeraljs/languages/de":228,"./numeraljs/languages/es-ES":229,"./numeraljs/languages/fi":230,"./numeraljs/languages/fr":232,"./numeraljs/languages/fr-CA":231,"./numeraljs/languages/hu":233,"./numeraljs/languages/id":234,"./numeraljs/languages/it":235,"./numeraljs/languages/ja":236,"./numeraljs/languages/nl-nl":237,"./numeraljs/languages/pl":238,"./numeraljs/languages/pt-br":239,"./numeraljs/languages/sv":240,"./numeraljs/languages/tr":241,"./numeraljs/numeral":242}],228:[function(require,module,exports){
'use strict';

/*!
 * numeral.js language configuration
 * language : German (de) – generally useful in Germany, Austria, Luxembourg, Belgium
 * author : Marco Krage : https://github.com/sinky
 */
(function () {
    var language = {
        delimiters: {
            thousands: '.',
            decimal: ','
        },
        abbreviations: {
            thousand: 'k',
            million: 'm',
            billion: 'b',
            trillion: 't'
        },
        ordinal: function ordinal(number) {
            return '.';
        },
        currency: {
            symbol: '€'
        }
    };

    // Node
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = language;
    }
})();

},{}],229:[function(require,module,exports){
'use strict';

/*!
 * numeral.js language configuration
 * language : spanish Spain
 * author : Hernan Garcia : https://github.com/hgarcia
 */
(function () {
    var language = {
        delimiters: {
            thousands: '.',
            decimal: ','
        },
        abbreviations: {
            thousand: 'k',
            million: 'mm',
            billion: 'b',
            trillion: 't'
        },
        ordinal: function ordinal(number) {
            var b = number % 10;
            return b === 1 || b === 3 ? 'er' : b === 2 ? 'do' : b === 7 || b === 0 ? 'mo' : b === 8 ? 'vo' : b === 9 ? 'no' : 'to';
        },
        currency: {
            symbol: '€'
        }
    };

    // Node
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = language;
    }
})();

},{}],230:[function(require,module,exports){
'use strict';

/*!
 * numeral.js language configuration
 * language : Finnish
 * author : Sami Saada : https://github.com/samitheberber
 */
(function () {
    var language = {
        delimiters: {
            thousands: ' ',
            decimal: ','
        },
        abbreviations: {
            thousand: 'k',
            million: 'M',
            billion: 'G',
            trillion: 'T'
        },
        ordinal: function ordinal(number) {
            return '.';
        },
        currency: {
            symbol: '€'
        }
    };

    // Node
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = language;
    }
})();

},{}],231:[function(require,module,exports){
'use strict';

/*!
 * numeral.js language configuration
 * language : french (Canada) (fr-CA)
 * author : Léo Renaud-Allaire : https://github.com/renaudleo
 */
(function () {
    var language = {
        delimiters: {
            thousands: ' ',
            decimal: ','
        },
        abbreviations: {
            thousand: 'k',
            million: 'M',
            billion: 'G',
            trillion: 'T'
        },
        ordinal: function ordinal(number) {
            return number === 1 ? 'er' : 'e';
        },
        currency: {
            symbol: '$'
        }
    };

    // Node
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = language;
    }
})();

},{}],232:[function(require,module,exports){
'use strict';

/*!
 * numeral.js language configuration
 * language : french (fr)
 * author : Adam Draper : https://github.com/adamwdraper
 */
(function () {
    var language = {
        delimiters: {
            thousands: ' ',
            decimal: ','
        },
        abbreviations: {
            thousand: 'k',
            million: 'm',
            billion: 'b',
            trillion: 't'
        },
        ordinal: function ordinal(number) {
            return number === 1 ? 'er' : 'e';
        },
        currency: {
            symbol: '€'
        }
    };

    // Node
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = language;
    }
})();

},{}],233:[function(require,module,exports){
'use strict';

/*!
 * numeral.js language configuration
 * language : Hungarian (hu)
 * author : Peter Bakondy : https://github.com/pbakondy
 */
(function () {
    var language = {
        delimiters: {
            thousands: ' ',
            decimal: ','
        },
        abbreviations: {
            thousand: 'E', // ezer
            million: 'M', // millió
            billion: 'Mrd', // milliárd
            trillion: 'T' // trillió
        },
        ordinal: function ordinal(number) {
            return '.';
        },
        currency: {
            symbol: ' Ft'
        }
    };

    // Node
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = language;
    }
})();

},{}],234:[function(require,module,exports){
'use strict';

/*!
 * numeral.js language configuration
 * language : Indonesian (id)
 */
(function () {
    var language = {
        delimiters: {
            thousands: ',',
            decimal: '.'
        },
        abbreviations: {
            thousand: 'ribu',
            million: 'juta',
            billion: 'miliar',
            trillion: 'triliun'
        },
        ordinal: function ordinal(number) {
            // According to Spotify's internal Indonesian specialist,
            // there is no ordinal symbol in Indonesian (like st, nd, th, º, ª),
            // they just use the word (equivalent to writing: first, second,
            // third, instead of 1st, 2nd, 3rd). And as we don't have such
            // capability to translate all numbers to words, this function
            // returns an empty string and wherever there's a ordinal, it will
            // just show up as the cardinal number.
            return '';
        },
        currency: {
            symbol: 'Rp'
        }
    };

    // Node
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = language;
    }
})();

},{}],235:[function(require,module,exports){
'use strict';

/*!
 * numeral.js language configuration
 * language : italian Italy (it)
 * author : Giacomo Trombi : http://cinquepunti.it
 */
(function () {
    var language = {
        delimiters: {
            thousands: '.',
            decimal: ','
        },
        abbreviations: {
            thousand: 'mila',
            million: 'mil',
            billion: 'b',
            trillion: 't'
        },
        ordinal: function ordinal(number) {
            return 'º';
        },
        currency: {
            symbol: '€'
        }
    };

    // Node
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = language;
    }
})();

},{}],236:[function(require,module,exports){
'use strict';

/*!
 * numeral.js language configuration
 * language : japanese
 * author : teppeis : https://github.com/teppeis
 */
(function () {
    var language = {
        delimiters: {
            thousands: ',',
            decimal: '.'
        },
        abbreviations: {
            thousand: '千',
            million: '百万',
            billion: '十億',
            trillion: '兆'
        },
        ordinal: function ordinal(number) {
            return '.';
        },
        currency: {
            symbol: '¥'
        }
    };

    // Node
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = language;
    }
})();

},{}],237:[function(require,module,exports){
'use strict';

/*!
 * numeral.js language configuration
 * language : netherlands-dutch (nl-nl)
 * author : Dave Clayton : https://github.com/davedx
 */
(function () {
    var language = {
        delimiters: {
            thousands: '.',
            decimal: ','
        },
        abbreviations: {
            thousand: 'k',
            million: 'mln',
            billion: 'mrd',
            trillion: 'bln'
        },
        ordinal: function ordinal(number) {
            var remainder = number % 100;
            return number !== 0 && remainder <= 1 || remainder === 8 || remainder >= 20 ? 'ste' : 'de';
        },
        currency: {
            symbol: '€ '
        }
    };

    // Node
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = language;
    }
})();

},{}],238:[function(require,module,exports){
'use strict';

/*!
 * numeral.js language configuration
 * language : polish (pl)
 * author : Dominik Bulaj : https://github.com/dominikbulaj
 */
(function () {
    var language = {
        delimiters: {
            thousands: ' ',
            decimal: ','
        },
        abbreviations: {
            thousand: 'tys.',
            million: 'mln',
            billion: 'mld',
            trillion: 'bln'
        },
        ordinal: function ordinal(number) {
            return '.';
        },
        currency: {
            symbol: 'PLN'
        }
    };

    // Node
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = language;
    }
})();

},{}],239:[function(require,module,exports){
'use strict';

/*!
 * numeral.js language configuration
 * language : portuguese brazil (pt-br)
 * author : Ramiro Varandas Jr : https://github.com/ramirovjr
 */
(function () {
    var language = {
        delimiters: {
            thousands: '.',
            decimal: ','
        },
        abbreviations: {
            thousand: 'mil',
            million: 'milhões',
            billion: 'b',
            trillion: 't'
        },
        ordinal: function ordinal(number) {
            return 'º';
        },
        currency: {
            symbol: 'R$'
        }
    };

    // Node
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = language;
    }
})();

},{}],240:[function(require,module,exports){
'use strict';

/*!
 * numeral.js language configuration
 * language : swedish
 * author :
 */
(function () {
    var language = {
        delimiters: {
            thousands: ' ',
            decimal: ','
        },
        abbreviations: {
            thousand: 't',
            million: 'mn',
            billion: 'md',
            trillion: 'bn'
        },
        ordinal: function ordinal(number) {
            return '.';
        },
        currency: {
            symbol: 'SEK'
        }
    };

    // Node
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = language;
    }
})();

},{}],241:[function(require,module,exports){
'use strict';

/*!
 * numeral.js language configuration
 * language : turkish (tr)
 * author : Ecmel Ercan : https://github.com/ecmel, Erhan Gundogan : https://github.com/erhangundogan, Burak Yiğit Kaya: https://github.com/BYK
 */
(function () {
    var suffixes = {
        1: '\'inci',
        5: '\'inci',
        8: '\'inci',
        70: '\'inci',
        80: '\'inci',

        2: '\'nci',
        7: '\'nci',
        20: '\'nci',
        50: '\'nci',

        3: '\'üncü',
        4: '\'üncü',
        100: '\'üncü',

        6: '\'ncı',

        9: '\'uncu',
        10: '\'uncu',
        30: '\'uncu',

        60: '\'ıncı',
        90: '\'ıncı'
    },
        language = {
        delimiters: {
            thousands: '.',
            decimal: ','
        },
        abbreviations: {
            thousand: 'bin',
            million: 'milyon',
            billion: 'milyar',
            trillion: 'trilyon'
        },
        ordinal: function ordinal(number) {
            if (number === 0) {
                // special case for zero
                return '\'ıncı';
            }

            var a = number % 10,
                b = number % 100 - a,
                c = number >= 100 ? 100 : null;

            return suffixes[a] || suffixes[b] || suffixes[c];
        },
        currency: {
            symbol: '₺'
        }
    };

    // Node
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = language;
    }
})();

},{}],242:[function(require,module,exports){
'use strict';

/*!
 * numeral.js
 * version : 1.5.3
 * author : Adam Draper
 * license : MIT
 * http://adamwdraper.github.com/Numeral-js/
 */

(function () {

    /************************************
        Constants
    ************************************/

    var _numeral,
        VERSION = '1.5.3',

    // internal storage for language config files
    languages = {},
        currentLanguage = 'en',
        zeroFormat = null,
        defaultFormat = '0,0',

    // check for nodeJS
    hasModule = typeof module !== 'undefined' && module.exports;

    /************************************
        Constructors
    ************************************/

    // Numeral prototype object
    function Numeral(number) {
        this._value = number;
    }

    /**
     * Implementation of toFixed() that treats floats more like decimals
     *
     * Fixes binary rounding issues (eg. (0.615).toFixed(2) === '0.61') that present
     * problems for accounting- and finance-related software.
     */
    function toFixed(value, precision, roundingFunction, optionals) {
        var power = Math.pow(10, precision),
            optionalsRegExp,
            output;

        //roundingFunction = (roundingFunction !== undefined ? roundingFunction : Math.round);
        // Multiply up by precision, round accurately, then divide and use native toFixed():
        output = (roundingFunction(value * power) / power).toFixed(precision);

        if (optionals) {
            optionalsRegExp = new RegExp('0{1,' + optionals + '}$');
            output = output.replace(optionalsRegExp, '');
        }

        return output;
    }

    /************************************
        Formatting
    ************************************/

    // determine what type of formatting we need to do
    function formatNumeral(n, format, roundingFunction) {
        var output;

        // figure out what kind of format we are dealing with
        if (format.indexOf('$') > -1) {
            // currency!!!!!
            output = formatCurrency(n, format, roundingFunction);
        } else if (format.indexOf('%') > -1) {
            // percentage
            output = formatPercentage(n, format, roundingFunction);
        } else if (format.indexOf(':') > -1) {
            // time
            output = formatTime(n, format);
        } else {
            // plain ol' numbers or bytes
            output = formatNumber(n._value, format, roundingFunction);
        }

        // return string
        return output;
    }

    // revert to number
    function unformatNumeral(n, string) {
        var stringOriginal = string,
            thousandRegExp,
            millionRegExp,
            billionRegExp,
            trillionRegExp,
            suffixes = ['KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'],
            bytesMultiplier = false,
            power;

        if (string.indexOf(':') > -1) {
            n._value = unformatTime(string);
        } else {
            if (string === zeroFormat) {
                n._value = 0;
            } else {
                if (languages[currentLanguage].delimiters.decimal !== '.') {
                    string = string.replace(/\./g, '').replace(languages[currentLanguage].delimiters.decimal, '.');
                }

                // see if abbreviations are there so that we can multiply to the correct number
                thousandRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.thousand + '(?:\\)|(\\' + languages[currentLanguage].currency.symbol + ')?(?:\\))?)?$');
                millionRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.million + '(?:\\)|(\\' + languages[currentLanguage].currency.symbol + ')?(?:\\))?)?$');
                billionRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.billion + '(?:\\)|(\\' + languages[currentLanguage].currency.symbol + ')?(?:\\))?)?$');
                trillionRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.trillion + '(?:\\)|(\\' + languages[currentLanguage].currency.symbol + ')?(?:\\))?)?$');

                // see if bytes are there so that we can multiply to the correct number
                for (power = 0; power <= suffixes.length; power++) {
                    bytesMultiplier = string.indexOf(suffixes[power]) > -1 ? Math.pow(1024, power + 1) : false;

                    if (bytesMultiplier) {
                        break;
                    }
                }

                // do some math to create our number
                n._value = (bytesMultiplier ? bytesMultiplier : 1) * (stringOriginal.match(thousandRegExp) ? Math.pow(10, 3) : 1) * (stringOriginal.match(millionRegExp) ? Math.pow(10, 6) : 1) * (stringOriginal.match(billionRegExp) ? Math.pow(10, 9) : 1) * (stringOriginal.match(trillionRegExp) ? Math.pow(10, 12) : 1) * (string.indexOf('%') > -1 ? 0.01 : 1) * ((string.split('-').length + Math.min(string.split('(').length - 1, string.split(')').length - 1)) % 2 ? 1 : -1) * Number(string.replace(/[^0-9\.]+/g, ''));

                // round if we are talking about bytes
                n._value = bytesMultiplier ? Math.ceil(n._value) : n._value;
            }
        }
        return n._value;
    }

    function formatCurrency(n, format, roundingFunction) {
        var symbolIndex = format.indexOf('$'),
            openParenIndex = format.indexOf('('),
            minusSignIndex = format.indexOf('-'),
            space = '',
            spliceIndex,
            output;

        // check for space before or after currency
        if (format.indexOf(' $') > -1) {
            space = ' ';
            format = format.replace(' $', '');
        } else if (format.indexOf('$ ') > -1) {
            space = ' ';
            format = format.replace('$ ', '');
        } else {
            format = format.replace('$', '');
        }

        // format the number
        output = formatNumber(n._value, format, roundingFunction);

        // position the symbol
        if (symbolIndex <= 1) {
            if (output.indexOf('(') > -1 || output.indexOf('-') > -1) {
                output = output.split('');
                spliceIndex = 1;
                if (symbolIndex < openParenIndex || symbolIndex < minusSignIndex) {
                    // the symbol appears before the "(" or "-"
                    spliceIndex = 0;
                }
                output.splice(spliceIndex, 0, languages[currentLanguage].currency.symbol + space);
                output = output.join('');
            } else {
                output = languages[currentLanguage].currency.symbol + space + output;
            }
        } else {
            if (output.indexOf(')') > -1) {
                output = output.split('');
                output.splice(-1, 0, space + languages[currentLanguage].currency.symbol);
                output = output.join('');
            } else {
                output = output + space + languages[currentLanguage].currency.symbol;
            }
        }

        return output;
    }

    function formatPercentage(n, format, roundingFunction) {
        var space = '',
            output,
            value = n._value * 100;

        // check for space before %
        if (format.indexOf(' %') > -1) {
            space = ' ';
            format = format.replace(' %', '');
        } else {
            format = format.replace('%', '');
        }

        output = formatNumber(value, format, roundingFunction);

        if (output.indexOf(')') > -1) {
            output = output.split('');
            output.splice(-1, 0, space + '%');
            output = output.join('');
        } else {
            output = output + space + '%';
        }

        return output;
    }

    function formatTime(n) {
        var hours = Math.floor(n._value / 60 / 60),
            minutes = Math.floor((n._value - hours * 60 * 60) / 60),
            seconds = Math.round(n._value - hours * 60 * 60 - minutes * 60);
        return hours + ':' + (minutes < 10 ? '0' + minutes : minutes) + ':' + (seconds < 10 ? '0' + seconds : seconds);
    }

    function unformatTime(string) {
        var timeArray = string.split(':'),
            seconds = 0;
        // turn hours and minutes into seconds and add them all up
        if (timeArray.length === 3) {
            // hours
            seconds = seconds + Number(timeArray[0]) * 60 * 60;
            // minutes
            seconds = seconds + Number(timeArray[1]) * 60;
            // seconds
            seconds = seconds + Number(timeArray[2]);
        } else if (timeArray.length === 2) {
            // minutes
            seconds = seconds + Number(timeArray[0]) * 60;
            // seconds
            seconds = seconds + Number(timeArray[1]);
        }
        return Number(seconds);
    }

    function formatNumber(value, format, roundingFunction) {
        var negP = false,
            signed = false,
            optDec = false,
            abbr = '',
            abbrK = false,
            // force abbreviation to thousands
        abbrM = false,
            // force abbreviation to millions
        abbrB = false,
            // force abbreviation to billions
        abbrT = false,
            // force abbreviation to trillions
        abbrForce = false,
            // force abbreviation
        bytes = '',
            ord = '',
            abs = Math.abs(value),
            suffixes = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'],
            min,
            max,
            power,
            w,
            precision,
            thousands,
            d = '',
            neg = false;

        // check if number is zero and a custom zero format has been set
        if (value === 0 && zeroFormat !== null) {
            return zeroFormat;
        } else {
            // see if we should use parentheses for negative number or if we should prefix with a sign
            // if both are present we default to parentheses
            if (format.indexOf('(') > -1) {
                negP = true;
                format = format.slice(1, -1);
            } else if (format.indexOf('+') > -1) {
                signed = true;
                format = format.replace(/\+/g, '');
            }

            // see if abbreviation is wanted
            if (format.indexOf('a') > -1) {
                // check if abbreviation is specified
                abbrK = format.indexOf('aK') >= 0;
                abbrM = format.indexOf('aM') >= 0;
                abbrB = format.indexOf('aB') >= 0;
                abbrT = format.indexOf('aT') >= 0;
                abbrForce = abbrK || abbrM || abbrB || abbrT;

                // check for space before abbreviation
                if (format.indexOf(' a') > -1) {
                    abbr = ' ';
                    format = format.replace(' a', '');
                } else {
                    format = format.replace('a', '');
                }

                if (abs >= Math.pow(10, 12) && !abbrForce || abbrT) {
                    // trillion
                    abbr = abbr + languages[currentLanguage].abbreviations.trillion;
                    value = value / Math.pow(10, 12);
                } else if (abs < Math.pow(10, 12) && abs >= Math.pow(10, 9) && !abbrForce || abbrB) {
                    // billion
                    abbr = abbr + languages[currentLanguage].abbreviations.billion;
                    value = value / Math.pow(10, 9);
                } else if (abs < Math.pow(10, 9) && abs >= Math.pow(10, 6) && !abbrForce || abbrM) {
                    // million
                    abbr = abbr + languages[currentLanguage].abbreviations.million;
                    value = value / Math.pow(10, 6);
                } else if (abs < Math.pow(10, 6) && abs >= Math.pow(10, 3) && !abbrForce || abbrK) {
                    // thousand
                    abbr = abbr + languages[currentLanguage].abbreviations.thousand;
                    value = value / Math.pow(10, 3);
                }
            }

            // see if we are formatting bytes
            if (format.indexOf('b') > -1) {
                // check for space before
                if (format.indexOf(' b') > -1) {
                    bytes = ' ';
                    format = format.replace(' b', '');
                } else {
                    format = format.replace('b', '');
                }

                for (power = 0; power <= suffixes.length; power++) {
                    min = Math.pow(1024, power);
                    max = Math.pow(1024, power + 1);

                    if (value >= min && value < max) {
                        bytes = bytes + suffixes[power];
                        if (min > 0) {
                            value = value / min;
                        }
                        break;
                    }
                }
            }

            // see if ordinal is wanted
            if (format.indexOf('o') > -1) {
                // check for space before
                if (format.indexOf(' o') > -1) {
                    ord = ' ';
                    format = format.replace(' o', '');
                } else {
                    format = format.replace('o', '');
                }

                ord = ord + languages[currentLanguage].ordinal(value);
            }

            if (format.indexOf('[.]') > -1) {
                optDec = true;
                format = format.replace('[.]', '.');
            }

            w = value.toString().split('.')[0];
            precision = format.split('.')[1];
            thousands = format.indexOf(',');

            if (precision) {
                if (precision.indexOf('[') > -1) {
                    precision = precision.replace(']', '');
                    precision = precision.split('[');
                    d = toFixed(value, precision[0].length + precision[1].length, roundingFunction, precision[1].length);
                } else {
                    d = toFixed(value, precision.length, roundingFunction);
                }

                w = d.split('.')[0];

                if (d.split('.')[1].length) {
                    d = languages[currentLanguage].delimiters.decimal + d.split('.')[1];
                } else {
                    d = '';
                }

                if (optDec && Number(d.slice(1)) === 0) {
                    d = '';
                }
            } else {
                w = toFixed(value, null, roundingFunction);
            }

            // format number
            if (w.indexOf('-') > -1) {
                w = w.slice(1);
                neg = true;
            }

            if (thousands > -1) {
                w = w.toString().replace(/(\d)(?=(\d{3})+(?!\d))/g, '$1' + languages[currentLanguage].delimiters.thousands);
            }

            if (format.indexOf('.') === 0) {
                w = '';
            }

            return (negP && neg ? '(' : '') + (!negP && neg ? '-' : '') + (!neg && signed ? '+' : '') + w + d + (ord ? ord : '') + (abbr ? abbr : '') + (bytes ? bytes : '') + (negP && neg ? ')' : '');
        }
    }

    /************************************
        Top Level Functions
    ************************************/

    _numeral = function numeral(input) {
        if (_numeral.isNumeral(input)) {
            input = input.value();
        } else if (input === 0 || typeof input === 'undefined') {
            input = 0;
        } else if (!Number(input)) {
            input = _numeral.fn.unformat(input);
        }

        return new Numeral(Number(input));
    };

    // version number
    _numeral.version = VERSION;

    // compare numeral object
    _numeral.isNumeral = function (obj) {
        return obj instanceof Numeral;
    };

    // This function will load languages and then set the global language.  If
    // no arguments are passed in, it will simply return the current global
    // language key.
    _numeral.language = function (key, values) {
        if (!key) {
            return currentLanguage;
        }

        if (key && !values) {
            if (!languages[key]) {
                throw new Error('Unknown language : ' + key);
            }
            currentLanguage = key;
        }

        if (values || !languages[key]) {
            loadLanguage(key, values);
        }

        return _numeral;
    };

    // This function provides access to the loaded language data.  If
    // no arguments are passed in, it will simply return the current
    // global language object.
    _numeral.languageData = function (key) {
        if (!key) {
            return languages[currentLanguage];
        }

        if (!languages[key]) {
            throw new Error('Unknown language : ' + key);
        }

        return languages[key];
    };

    _numeral.language('en', {
        delimiters: {
            thousands: ',',
            decimal: '.'
        },
        abbreviations: {
            thousand: 'k',
            million: 'm',
            billion: 'b',
            trillion: 't'
        },
        ordinal: function ordinal(number) {
            var b = number % 10;
            return ~ ~(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
        },
        currency: {
            symbol: '$'
        }
    });

    _numeral.zeroFormat = function (format) {
        zeroFormat = typeof format === 'string' ? format : null;
    };

    _numeral.defaultFormat = function (format) {
        defaultFormat = typeof format === 'string' ? format : '0.0';
    };

    /************************************
        Helpers
    ************************************/

    function loadLanguage(key, values) {
        languages[key] = values;
    }

    /************************************
        Floating-point helpers
    ************************************/

    // The floating-point helper functions and implementation
    // borrows heavily from sinful.js: http://guipn.github.io/sinful.js/

    /**
     * Array.prototype.reduce for browsers that don't support it
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce#Compatibility
     */
    if ('function' !== typeof Array.prototype.reduce) {
        Array.prototype.reduce = function (callback, opt_initialValue) {
            'use strict';

            if (null === this || 'undefined' === typeof this) {
                // At the moment all modern browsers, that support strict mode, have
                // native implementation of Array.prototype.reduce. For instance, IE8
                // does not support strict mode, so this check is actually useless.
                throw new TypeError('Array.prototype.reduce called on null or undefined');
            }

            if ('function' !== typeof callback) {
                throw new TypeError(callback + ' is not a function');
            }

            var index,
                value,
                length = this.length >>> 0,
                isValueSet = false;

            if (1 < arguments.length) {
                value = opt_initialValue;
                isValueSet = true;
            }

            for (index = 0; length > index; ++index) {
                if (this.hasOwnProperty(index)) {
                    if (isValueSet) {
                        value = callback(value, this[index], index, this);
                    } else {
                        value = this[index];
                        isValueSet = true;
                    }
                }
            }

            if (!isValueSet) {
                throw new TypeError('Reduce of empty array with no initial value');
            }

            return value;
        };
    }

    /**
     * Computes the multiplier necessary to make x >= 1,
     * effectively eliminating miscalculations caused by
     * finite precision.
     */
    function multiplier(x) {
        var parts = x.toString().split('.');
        if (parts.length < 2) {
            return 1;
        }
        return Math.pow(10, parts[1].length);
    }

    /**
     * Given a variable number of arguments, returns the maximum
     * multiplier that must be used to normalize an operation involving
     * all of them.
     */
    function correctionFactor() {
        var args = Array.prototype.slice.call(arguments);
        return args.reduce(function (prev, next) {
            var mp = multiplier(prev),
                mn = multiplier(next);
            return mp > mn ? mp : mn;
        }, -Infinity);
    }

    /************************************
        Numeral Prototype
    ************************************/

    _numeral.fn = Numeral.prototype = {

        clone: function clone() {
            return _numeral(this);
        },

        format: function format(inputString, roundingFunction) {
            return formatNumeral(this, inputString ? inputString : defaultFormat, roundingFunction !== undefined ? roundingFunction : Math.round);
        },

        unformat: function unformat(inputString) {
            if (Object.prototype.toString.call(inputString) === '[object Number]') {
                return inputString;
            }
            return unformatNumeral(this, inputString ? inputString : defaultFormat);
        },

        value: function value() {
            return this._value;
        },

        valueOf: function valueOf() {
            return this._value;
        },

        set: function set(value) {
            this._value = Number(value);
            return this;
        },

        add: function add(value) {
            var corrFactor = correctionFactor.call(null, this._value, value);
            function cback(accum, curr, currI, O) {
                return accum + corrFactor * curr;
            }
            this._value = [this._value, value].reduce(cback, 0) / corrFactor;
            return this;
        },

        subtract: function subtract(value) {
            var corrFactor = correctionFactor.call(null, this._value, value);
            function cback(accum, curr, currI, O) {
                return accum - corrFactor * curr;
            }
            this._value = [value].reduce(cback, this._value * corrFactor) / corrFactor;
            return this;
        },

        multiply: function multiply(value) {
            function cback(accum, curr, currI, O) {
                var corrFactor = correctionFactor(accum, curr);
                return accum * corrFactor * (curr * corrFactor) / (corrFactor * corrFactor);
            }
            this._value = [this._value, value].reduce(cback, 1);
            return this;
        },

        divide: function divide(value) {
            function cback(accum, curr, currI, O) {
                var corrFactor = correctionFactor(accum, curr);
                return accum * corrFactor / (curr * corrFactor);
            }
            this._value = [this._value, value].reduce(cback);
            return this;
        },

        difference: function difference(value) {
            return Math.abs(_numeral(this._value).subtract(value).value());
        }

    };

    /************************************
        Exposing Numeral
    ************************************/

    module.exports = _numeral;
}).call(undefined);

},{}],243:[function(require,module,exports){

'use strict';

/**
 * Module dependencies
 */

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var extend = require('extend'),
    bridge = require('../spotify-bridge-request'),
    batch = require('spotify-batch');

/**
 * Bridge methods
 */

var PREF_ALL = 'preferences_all';
var PREF_GET = 'preferences_get';
var PREF_SET = 'preferences_set';
var PREF_SUB = 'preferences_event_wait';

/**
 * Converts a string with dot notation into
 * a nested object where the last key is
 * set to value
 *
 *  eg: f('foo.bar', 123) = {foo: {bar: 123}}
 *
 * @api private
 * @param {String} string
 * @param {Mixed} value
 * @param {String} delimiter - optional
 */

function TransformStringIntoObjectAndSetValue(string, value, delimiter) {
  var object = {};
  string.split(delimiter || '.').reduce(function (o, c, i, a) {
    if (i < a.length - 1) {
      o[c] = {};
    } else {
      o[c] = value;
    }

    return o[c];
  }, object);

  return object;
}

/**
 * Converts an object with nest objects into a flat object
 *
 *  eg: f({foo: {bar: 123}}) = {'foo.bar': 123}
 *
 * @api private
 * @param {String} string
 * @param {String} delimiter - optional
 */

function TransformObjectIntoFlatObject(object, delimiter) {
  var flattened = {};
  delimiter = delimiter || '.';
  function traverse(o, key) {
    var tmp = null;
    for (var p in o) {
      if ('object' == _typeof(o[p])) {
        key = key ? [key, p].join(delimiter) : p;
        traverse(o[p], key);
      } else {
        tmp = key ? [key, p].join(delimiter) : p;
        flattened[tmp] = o[p];
      }
    }
  }

  traverse(object);
  return flattened;
}

/**
 * Normalizes data from bridge responses
 *
 * @api private
 * @param {String} key
 * @param {Object} data
 * @param {Boolean} preserve - optional (Default: false)
 */

function NormalizeData(key, data, preserve) {
  var out = {};
  var regex = '*' == key ? null : RegExp('^' + key);
  var targets = null;

  if ('object' != (typeof data === 'undefined' ? 'undefined' : _typeof(data))) {
    return data;
  }

  targets = Object.keys(data).map(function (key) {
    if (null == regex || regex.test(key)) {
      return [key, data[key]];
    }
  }).filter(Boolean).reduce(function (t, c) {
    t[c[0]] = c[1];
    return t;
  }, {});

  Object.keys(targets).forEach(function (key) {
    // extend output object with transformed properties
    extend(true, out, TransformStringIntoObjectAndSetValue(key, targets[key]));
  });

  if ('*' == key || true === preserve) {
    return out;
  } else {
    return key.split('.').reduce(function (o, k) {
      return o[k];
    }, out);
  }
}

/**
 * Subscribes to a key.
 *
 * @api private
 * @param {Function} rpc The RPC to use.
 * @param {String} key The key (including path).
 * @param {*} lastValue The last value of the key (used for comparing).
 * @param {Function} fn Subscribe handler.
 * @param {Object=} sub Subscription object, optional.
 */

function SubscribeToKey(rpc, key, lastValue, fn, sub) {
  sub = sub || {
    isCancelled: false,
    cancel: function cancel() {
      this.isCancelled = true;
    }
  };

  rpc(PREF_SUB, [], function (err, res) {
    if (sub.isCancelled) return;

    var didValueChange = false;

    if (res) {
      var value = NormalizeData(key, res);
      if (value !== lastValue) {
        lastValue = value;
        didValueChange = true;
      }
    }

    // Resubscribe since one subscription is only for one response
    SubscribeToKey(rpc, key, lastValue, fn, sub);

    if (didValueChange) {
      fn(null, lastValue);
    }
  });

  return sub;
}

/**
 * `Preferences' constructor
 *
 * @api public
 * @param {String} path - optional (Default: '*')
 * @param {Function} rpc - optional
 */

module.exports = Preferences;
function Preferences(path, rpc) {
  if (!(this instanceof Preferences)) {
    return new Preferences(path, rpc);
  }

  this.path = path || '*';
  this.rpc = rpc || bridge.request.bind(bridge);
}

/**
 * Retrieves all preferences at path.
 * If path is '*' then all preferences
 * are retrieved.
 *
 * @api public
 * @param {Function} fn
 */

Preferences.prototype.all = function (fn) {
  var self = this;
  var path = this.path;

  this.rpc(PREF_ALL, [], function (err, res) {
    if (err) {
      return fn(err);
    } else if ('*' == path) {
      fn(null, res);
    } else {
      fn(null, NormalizeData(path, res, true));
    }
  });

  return this;
};

/**
 * Sets a preference at key at path
 * with value
 *
 * @api public
 * @param {String} key
 * @param {Mixed} value
 * @param {Function} fn
 */

Preferences.prototype.set = function (key, value, fn) {
  var self = this;
  var path = this.path;
  var tmp = null;
  var map = null;
  var jobs = null;

  // handle batch jobs to extend bridge preferences
  if ('object' == (typeof key === 'undefined' ? 'undefined' : _typeof(key))) {
    fn = value;

    map = TransformObjectIntoFlatObject(key);
    jobs = batch().concurrency(1);
    Object.keys(map).forEach(function (k) {
      jobs.push(function (next) {
        self.set(k, map[k], next);
      });
    });

    jobs.run(fn);
  } else {
    key = '*' == path ? key : [path, key].join('.');
    this.rpc(PREF_SET, [key, value], fn);
  }
  return this;
};

/**
 * Sets a preference bitflag at path, based on the inputs.
 *
 * @api public
 * @param {String} key
 * @param {Array} flagBoolPairs
 * @param {Function} fn
 */

Preferences.prototype.setAtomicFlags = function (key, flagBoolPairs, fn) {
  var self = this;

  self.get(key, function (err, value) {
    if (err) return fn(err);

    flagBoolPairs.forEach(function (pair) {
      var flag = pair[0];
      var bool = pair[1];
      if (bool === undefined || bool === null) return;
      if (bool) value |= flag;else value &= ~flag;
    });

    self.set(key, value, fn);
  });
};

/**
 * Gets a preference at key at path
 *
 * @api public
 * @param {String} key
 * @param {Function} fn
 */

Preferences.prototype.get = function (key, fn) {
  var self = this;
  key = '*' == this.path ? key : [this.path, key].join('.');

  // try to get property first
  this.rpc(PREF_GET, [key], function (err, res) {
    var value = res ? NormalizeData(key, res) : null;
    if (null == value) {
      self.rpc(PREF_ALL, [], function (err, res) {
        if (err) {
          return fn(err);
        } else {
          fn(null, NormalizeData(key, res));
        }
      });
    } else {
      fn(null, NormalizeData(key, res));
    }
  });
  return this;
};

/**
 * Subscribes to a preference at key at path
 *
 * @api public
 * @param {String} key
 * @param {Function} fn
 */

Preferences.prototype.subscribe = function (key, fn) {
  var self = this;
  var sub = null;
  var cancelled = false;

  // Get initial value and then subscribe for changes
  this.get(key, function (err, res) {
    if (cancelled) return;
    var keyWithPath = '*' == self.path ? key : [self.path, key].join('.');
    sub = SubscribeToKey(self.rpc, keyWithPath, res, fn);

    // Respond to the GET (initial value for SUB)
    fn(err, res);
  });

  return {
    cancel: function cancel() {
      cancelled = true;
      if (sub) {
        sub.cancel();
      }
    }
  };
};

},{"../spotify-bridge-request":144,"extend":272,"spotify-batch":351}],244:[function(require,module,exports){
/**
 * @module spotify-range2
 */
'use strict';

var prime = require('prime');

var map = require('mout/array/map');

var push_ = Array.prototype.push;
var slice_ = Array.prototype.slice;

var Range = prime( /** @lends Range.prototype */{

  /**
   * The representation of a range
   * @constructs
   * @param {Number} start The start of the range.
   * @param {Number} end The end of the range.
   */
  constructor: function Range(start, end) {
    this.update(start, end);
  },

  /** Update a range. */
  update: function update(start, end) {
    if (start !== null) this.start = start;
    if (end !== null) this.end = end;
    if (this.start === null || this.end === null) throw new Error('invalid range');
    if (this.start > this.end) throw new Error('invalid range');
    this.length = this.end - this.start;
    return this;
  },

  /** Copy a range. */
  copy: function copy() {
    return new Range(this.start, this.end);
  },

  /** Range is above range. */
  above: function above(range) {
    if (!range) return false;
    return this.start >= range.end;
  },

  /** Range is below range. */
  below: function below(range) {
    if (!range) return false;
    return this.end <= range.start;
  },

  adjacent: function adjacent(range) {
    if (!range) return false;
    return this.end === range.start || this.start === range.end;
  },

  /** Range intersects range. */
  intersects: function intersects(range) {
    if (!range) return false;
    return !this.above(range) && !this.below(range);
  },

  /** Range contains range. */
  contains: function contains(range) {
    if (!range) return false;
    return this.start <= range.start && this.end >= range.end;
  },

  /** Range is contained by ranges. */
  contained: function contained(range) {
    var ranges;
    if (range instanceof Range) ranges = arguments;else ranges = range;
    if (!ranges) return false;

    for (var i = 0; ranges[i] !== undefined; i++) {
      var r = ranges[i];
      if (r.start <= this.start && r.end >= this.end) {
        return true;
      }
    }
    return false;
  },

  /** Range fits two ranges. */
  fits: function fits(prev, next) {
    if (!prev && !next) return true;
    if (!prev) return this.end <= next.start;
    if (!next) return this.start >= prev.end;
    return this.start >= prev.end && this.end <= next.start;
  },

  // get the section of this range contained between two ranges
  // [0, 20] » [0, 8], [16, 20] » [8, 16]

  /** portion of a range between two ranges. */
  between: function between(prev, next) {
    if (!prev && !next) return this.copy();
    if (!prev) return this.start >= next.start ? null : new Range(this.start, Math.min(this.end, next.start));
    if (!next) return this.end <= prev.end ? null : new Range(Math.max(prev.end, this.start), this.end);

    return this.end > prev.end && this.start < next.start ? new Range(Math.max(prev.end, this.start), Math.min(next.start, this.end)) : null;
  },

  // [0, 8] » [0, 2], [4, 5] = [0, 2], [4, 5]
  // [3, 6] » [5, 7] = [5, 6]
  // [6, 9] » [5, 7] = [6, 7]

  /** intersection of a range with many ranges */
  intersection: function intersection(range) {
    var intersected = [];
    var ranges;
    if (range instanceof Range) ranges = arguments;else ranges = range;
    for (var k = 0; k < ranges.length; k++) {
      var r = ranges[k];
      if (this.below(r)) break;

      if (r.intersects(this)) intersected.push(new Range(Math.max(this.start, r.start), Math.min(this.end, r.end)));
    }
    return intersected;
  },

  // subtract ranges from this range
  // [0, 8] » [0, 2], [4, 5] = [2, 4], [5, 8]

  /** subtract many ranges from the range. */
  subtract: function subtract(range) {
    var subtracted = [];
    var ranges;
    if (range instanceof Range) ranges = arguments;else ranges = range;
    for (var k = -1; k < ranges.length; k++) {
      var prev = ranges[k];
      var next = ranges[k + 1];
      var between = this.between(prev, next);
      if (between) subtracted.push(between);
    }
    return subtracted;
  },

  // extract this range from ranges
  // [0, 8] » [0, 2], [5, 8] = []
  // [8, 20] » [0, 2], [5, 8] = [0, 2], [5, 8]
  // [0, 10] » [5, 10], [15, 20] = [5, 10]
  // [10, 20] » [5, 80], [90, 100] = [5, 70] [80, 90]
  // [10, 20] » [0, 10], [20, 30] = [0, 20]

  /** extract the range from many ranges. */
  extract: function extract(range) {
    var ranges = range instanceof Range ? slice_.call(arguments) : range.slice();

    for (var k = 0; k < ranges.length; k++) {
      var prev = ranges[k - 1];
      var next = ranges[k];

      var newRange = null;

      if (this.below(next)) {
        newRange = new Range(next.start - this.length, next.end - this.length);
      } else if (this.intersects(next)) {
        var subtracted = next.subtract(this);
        if (subtracted.length === 2) {
          // is contained
          newRange = new Range(subtracted[0].start, subtracted[1].end - this.length);
        } else if (subtracted.length === 1) {
          if (next.end > this.end) {
            // second segment kept
            newRange = new Range(subtracted[0].start - this.length, subtracted[0].end - this.length);
          } else if (this.start > next.start) {
            // first segment kept
            newRange = new Range(subtracted[0].start, subtracted[0].end);
          }
        } else {
          // gets eaten
          ranges.splice(k--, 1); // decrease k
        }
      } else {
          ranges.splice(k, 1, next.copy());
        }

      if (newRange) {
        if (prev && prev.end === newRange.start) {
          // touches previous
          ranges.splice(k-- - 1, 2, new Range(prev.start, newRange.end)); // decrease k due to splicing
        } else {
            ranges.splice(k, 1, newRange);
          }
      }
    }

    return ranges;
  },

  // [2,3] » [0,1], [2,3] = [0,1], [2,4]
  // [1,2] » [0,6] = [0,7]
  // [0,1] » [0,1], [5,6] = [0,2], [6,7]
  // [4,6] » [0,1], [5,6] = [0,1], [4,6], [7,8]

  // TODO: this can be slightly better. merging can be done in one loop.

  /** insert the range in many ranges. */
  insert: function insert(range) {
    var ranges = range instanceof Range ? slice_.call(arguments) : range.slice();

    for (var k = 0; k < ranges.length; k++) {
      var next = ranges[k];

      if (this.start >= next.end) {
        ranges.splice(k, 1, next.copy());
      } else if (this.start > next.start && this.start < next.end) {
        ranges.splice(k, 1, new Range(next.start, this.start), new Range(this.start, next.end));
      } else {
        ranges.splice(k, 1, new Range(next.start + this.length, next.end + this.length));
      }
    }

    return this.merge(ranges);
  },

  // merge this range in ranges
  // [0, 8] » [0, 2], [5, 8] = [0, 8]
  // [8, 20] » [0, 2], [5, 8] = [0, 2], [5, 20]
  // [0, 10] » [5, 10], [15, 20] = [0, 10], [15, 20]

  /** merge many ranges to the range. */
  merge: function merge(range) {
    var ranges;
    if (range instanceof Range) ranges = arguments;else ranges = range;

    ranges = map(ranges, function (r) {
      return r.copy();
    });

    if (!ranges.length) return [this.copy()];

    var k;
    var l;

    for (k = -1, l = ranges.length; k < l; k++) {
      var prev = ranges[k];
      var next = ranges[k + 1];
      var between = this.between(prev, next);

      if (between) {
        if (!prev && next) {
          if (between.end === next.start) {
            next.update(between.start, next.end);
          } else {
            k++; // increase k since we had a push
            ranges.unshift(between);
          }
        } else if (prev && next) {
          if (prev.end === between.start && between.end === next.start) {
            prev.update(prev.start, next.end);
            ranges.splice(k-- + 1, 1); // remove the next, decrease k since we had a splice
          } else if (prev.end === between.start) {
              prev.update(prev.start, between.end);
            } else if (between.end === next.start) {
              next.update(between.start, next.end);
            } else {
              ranges.splice(k + 1, 0, between);
            }
        } else if (prev && !next) {
          if (prev.end === between.start) {
            prev.update(prev.start, between.end);
          } else {
            k++; // increase k since we had a push
            ranges.push(between);
          }
        }
      }
    }

    return ranges;
  },

  /** Remove range from many ranges
      - The range(s) you pass is what you remove from */
  remove: function remove(range) {
    var ranges;
    if (range instanceof Range) ranges = arguments;else ranges = range;
    var result = [];
    for (var i = 0; i < ranges.length; i++) {
      var remaining = ranges[i].subtract(this);
      if (remaining.length) push_.apply(result, remaining);
    }
    return result;
  },

  /** Range to an array of indices */
  toIndices: function toIndices() {
    var indices = [];
    for (var i = this.start; i < this.end; i++) {
      indices.push(i);
    }return indices;
  },

  /** Range to a string */
  toString: function toString() {
    return [this.start, this.end] + '';
  }

});

/**
 * Range from a string
 * @memberof Range
 * @static
 * @param {String} string - The string.
 * @return {Range} The range.
 */
Range.fromString = function (string) {
  var parts = string.split(',');
  return new Range(+parts[0], +parts[1]);
};

/**
 * Ranges from an array of indices
 * @memberof Range
 * @static
 * @param {Array} indices - An array of indices.
 * @return {Array} An array of Ranges.
 */
Range.fromIndices = function (indices) {
  indices.sort(function (a, b) {
    return a > b ? 1 : -1;
  });

  var ranges = [];
  var rstart;
  var rend;

  for (var i = 0; i < indices.length; i++) {
    rstart = indices[i];
    rend = rstart;
    while (indices[i + 1] - indices[i] === 1) {
      rend = indices[i + 1]; // increment the index if the numbers sequential
      i++;
    }
    ranges.push(new Range(rstart, rend + 1));
  }

  return ranges;
};

/**
 * A function that returns a range.
 * @function
 * @see Range
 * @param {Number} start The start of the range.
 * @param {Number} end The end of the range.
 */
module.exports = Range;

},{"mout/array/map":312,"prime":345}],245:[function(require,module,exports){
'use strict';

function Translations() {
  this._data = {};

  // ensure that the context of the get method is always this object
  this.get = this.get.bind(this);
}

/**
 * Default implementation if the
 * locale is not loaded
 */
Translations.prototype.injectData = function (data) {
  this._data = data;
};

/**
 * Get a translation
 */
Translations.prototype.get = function (key, var_args) {
  var format = this._data.hasOwnProperty(key) ? this._data[key] : key;
  var args = arguments;

  return format.replace(/\{(\d+?)\}/g, function (str, num) {
    var value = args[+num + 1];

    // Do not change by a ||. A value of an empty string would make it fail.
    return typeof value !== 'undefined' ? value : str;
  });
};

/**
 * Gets the raw translations data
 * @return {Object} Locale object
 */
Translations.prototype.getData = function () {
  return this._data;
};

/**
 * Creates a translations instance with the specified data
 *
 * @param {Object} data Translations object
 * @return {Translations}
 */
Translations.createWithData = function (data) {
  var translations = new Translations();
  translations.injectData(data);
  return translations;
};

module.exports = Translations;

},{}],246:[function(require,module,exports){
/**
 * BezierEasing - use bezier curve for transition easing function
 * by Gaëtan Renaudeau 2014 - 2015 – MIT License
 *
 * Credits: is based on Firefox's nsSMILKeySpline.cpp
 * Usage:
 * var spline = BezierEasing([ 0.25, 0.1, 0.25, 1.0 ])
 * spline.get(x) => returns the easing value | x must be in [0, 1] range
 *
 */

// These values are established by empiricism with tests (tradeoff: performance VS precision)
var NEWTON_ITERATIONS = 4;
var NEWTON_MIN_SLOPE = 0.001;
var SUBDIVISION_PRECISION = 0.0000001;
var SUBDIVISION_MAX_ITERATIONS = 10;

var kSplineTableSize = 11;
var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);

var float32ArraySupported = typeof Float32Array === "function";

function A (aA1, aA2) { return 1.0 - 3.0 * aA2 + 3.0 * aA1; }
function B (aA1, aA2) { return 3.0 * aA2 - 6.0 * aA1; }
function C (aA1)      { return 3.0 * aA1; }

// Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.
function calcBezier (aT, aA1, aA2) {
  return ((A(aA1, aA2)*aT + B(aA1, aA2))*aT + C(aA1))*aT;
}

// Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.
function getSlope (aT, aA1, aA2) {
  return 3.0 * A(aA1, aA2)*aT*aT + 2.0 * B(aA1, aA2) * aT + C(aA1);
}

function binarySubdivide (aX, aA, aB, mX1, mX2) {
  var currentX, currentT, i = 0;
  do {
    currentT = aA + (aB - aA) / 2.0;
    currentX = calcBezier(currentT, mX1, mX2) - aX;
    if (currentX > 0.0) {
      aB = currentT;
    } else {
      aA = currentT;
    }
  } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);
  return currentT;
}

function newtonRaphsonIterate (aX, aGuessT, mX1, mX2) {
  for (var i = 0; i < NEWTON_ITERATIONS; ++i) {
    var currentSlope = getSlope(aGuessT, mX1, mX2);
    if (currentSlope === 0.0) return aGuessT;
    var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
    aGuessT -= currentX / currentSlope;
  }
  return aGuessT;
}

/**
 * points is an array of [ mX1, mY1, mX2, mY2 ]
 */
function BezierEasing (points, b, c, d) {
  if (arguments.length === 4) {
    return new BezierEasing([ points, b, c, d ]);
  }
  if (!(this instanceof BezierEasing)) return new BezierEasing(points);

  if (!points || points.length !== 4) {
    throw new Error("BezierEasing: points must contains 4 values");
  }
  for (var i=0; i<4; ++i) {
    if (typeof points[i] !== "number" || isNaN(points[i]) || !isFinite(points[i])) {
      throw new Error("BezierEasing: points should be integers.");
    }
  }
  if (points[0] < 0 || points[0] > 1 || points[2] < 0 || points[2] > 1) {
    throw new Error("BezierEasing x values must be in [0, 1] range.");
  }

  this._str = "BezierEasing("+points+")";
  this._css = "cubic-bezier("+points+")";
  this._p = points;
  this._mSampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);
  this._precomputed = false;

  this.get = this.get.bind(this);
}

BezierEasing.prototype = {

  get: function (x) {
    var mX1 = this._p[0],
      mY1 = this._p[1],
      mX2 = this._p[2],
      mY2 = this._p[3];
    if (!this._precomputed) this._precompute();
    if (mX1 === mY1 && mX2 === mY2) return x; // linear
    // Because JavaScript number are imprecise, we should guarantee the extremes are right.
    if (x === 0) return 0;
    if (x === 1) return 1;
    return calcBezier(this._getTForX(x), mY1, mY2);
  },

  getPoints: function() {
    return this._p;
  },

  toString: function () {
    return this._str;
  },

  toCSS: function () {
    return this._css;
  },

  // Private part

  _precompute: function () {
    var mX1 = this._p[0],
      mY1 = this._p[1],
      mX2 = this._p[2],
      mY2 = this._p[3];
    this._precomputed = true;
    if (mX1 !== mY1 || mX2 !== mY2)
      this._calcSampleValues();
  },

  _calcSampleValues: function () {
    var mX1 = this._p[0],
      mX2 = this._p[2];
    for (var i = 0; i < kSplineTableSize; ++i) {
      this._mSampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
    }
  },

  /**
   * getTForX chose the fastest heuristic to determine the percentage value precisely from a given X projection.
   */
  _getTForX: function (aX) {
    var mX1 = this._p[0],
      mX2 = this._p[2],
      mSampleValues = this._mSampleValues;

    var intervalStart = 0.0;
    var currentSample = 1;
    var lastSample = kSplineTableSize - 1;

    for (; currentSample !== lastSample && mSampleValues[currentSample] <= aX; ++currentSample) {
      intervalStart += kSampleStepSize;
    }
    --currentSample;

    // Interpolate to provide an initial guess for t
    var dist = (aX - mSampleValues[currentSample]) / (mSampleValues[currentSample+1] - mSampleValues[currentSample]);
    var guessForT = intervalStart + dist * kSampleStepSize;

    var initialSlope = getSlope(guessForT, mX1, mX2);
    if (initialSlope >= NEWTON_MIN_SLOPE) {
      return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
    } else if (initialSlope === 0.0) {
      return guessForT;
    } else {
      return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
    }
  }
};

// CSS mapping
BezierEasing.css = {
  "ease":        BezierEasing.ease      = BezierEasing(0.25, 0.1, 0.25, 1.0),
  "linear":      BezierEasing.linear    = BezierEasing(0.00, 0.0, 1.00, 1.0),
  "ease-in":     BezierEasing.easeIn    = BezierEasing(0.42, 0.0, 1.00, 1.0),
  "ease-out":    BezierEasing.easeOut   = BezierEasing(0.00, 0.0, 0.58, 1.0),
  "ease-in-out": BezierEasing.easeInOut = BezierEasing(0.42, 0.0, 0.58, 1.0)
};

module.exports = BezierEasing;

},{}],247:[function(require,module,exports){
(function (global){
var check = require('./check.js');
var compare = require('./compare.js');

/**
 * Throws an Error if there are differences between the two given instances. The
 * error message will contain the difference summary. Compares arrays, booleans,
 * numbers, objects and strings as well as null and undefined by value and other
 * types by reference.
 */
var assert = function (one, two) {
  var summary;

  summary = compare(one, two, '');

  if (summary !== null) {
    throw new global.Error(summary);
  }
};

/**
 * Throws an Error if the given method does not throw when called with the given
 * args for the given instance.
 */
assert.throws = function (instance, method, args) {
  var unexpected;

  check.function(method);
  check.array(args);

  unexpected = new Error('Expected an error to be thrown!');

  try {
    method.apply(instance, args);

    throw unexpected;
  } catch (error) {
    if (error === unexpected) {
      throw unexpected;
    }
  }
};

module.exports = assert;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./check.js":248,"./compare.js":250}],248:[function(require,module,exports){
(function (global){
var is = require('./is.js');

/**
 * Throws a TypeError if the given instance is not an array.
 */
exports.array = function (instance) {
  if (!is.array(instance)) {
    throw new global.TypeError('Expected array!');
  }
};

/**
 * Throws a TypeError if the given instance is not a boolean.
 */
exports.boolean = function (instance) {
  if (!is.boolean(instance)) {
    throw new global.TypeError('Expected boolean!');
  }
};

/**
 * Throws a TypeError if the given instance is not a function.
 */
exports.function = function (instance) {
  if (!is.function(instance)) {
    throw new global.TypeError('Expected function!');
  }
};

/**
 * Throws a TypeError if the given instance is not null.
 */
exports.null = function (instance) {
  if (!is.null(instance)) {
    throw new global.TypeError('Expected null!');
  }
};

/**
 * Throws a TypeError if the given instance is not a number.
 */
exports.number = function (instance) {
  if (!is.number(instance)) {
    throw new global.TypeError('Expected number!');
  }
};

/**
 * Throws a TypeError if the given instance is not an object.
 */
exports.object = function (instance) {
  if (!is.object(instance)) {
    throw new global.TypeError('Expected object!');
  }
};

/**
 * Throws a TypeError if the given instance is not a string.
 */
exports.string = function (instance) {
  if (!is.string(instance)) {
    throw new global.TypeError('Expected string!');
  }
};

/**
 * Throws a TypeError if the given instance does not descend from the given
 * constructor.
 */
exports.type = function (instance, constructor) {
  if (!is.type(instance, constructor)) {
    throw new global.TypeError('Expected type!');
  }
};

/**
 * Throws a TypeError if the given instance is not undefined.
 */
exports.undefined = function (instance) {
  if (!is.undefined(instance)) {
    throw new global.TypeError('Expected undefined!');
  }
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./is.js":258}],249:[function(require,module,exports){
(function (global){
var is = require('./is.js');
var name = require('./name.js');

/**
 * Attemps to clone the given instance. Only arrays, booleans, numbers, objects
 * and strings as well as null and undefined are accepted. If any other type is
 * encountered, a TypeError is thrown.
 */
var clone = function (instance) {
  var array;
  var i;
  var k;
  var l;
  var object;

  if (is.array(instance)) {
    array = [];

    for (i = 0, l = instance.length; i < l; i++) {
      array[i] = clone(instance[i]);
    }

    return array;
  }

  if (is.boolean(instance)) {
    return instance;
  }

  if (is.null(instance)) {
    return instance;
  }

  if (is.number(instance)) {
    return instance;
  }

  if (is.object(instance)) {
    object = {};

    for (k in instance) {
      object[k] = clone(instance[k]);
    }

    return object;
  }

  if (is.string(instance)) {
    return instance;
  }

  if (is.undefined(instance)) {
    return instance;
  }

  throw new global.TypeError('Unexpected type "' + name(instance) + '"!');
};

module.exports = clone;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./is.js":258,"./name.js":260}],250:[function(require,module,exports){
var is = require('./is.js');
var name = require('./name.js');

/**
 * Creates a difference summary between the two given instances. Compares
 * arrays, booleans, numbers, objects and strings as well as null and undefined
 * by value and other types by reference. Returns null if the two given
 * instances are identical.
 */
var compare = function (one, two, prefix) {
  var i;
  var k;
  var l;
  var m;
  var result;
  var summary;

  result = '\n';

  if (!is.string(prefix)) {
    prefix = '';
  }

  if (is.array(one)) {
    if (!is.array(two)) {
      return 'expected type "' + name(one) + '" but found type "' + name(two) + '"\n';
    }

    for (i = 0, l = one.length, m = two.length; i < l && i < m; i++) {
      summary = compare(one[i], two[i], prefix + '    ');

      if (summary !== null) {
        result += prefix + '"' + i + '": ' + summary;
      }
    }

    for (; i < l; i++) {
      result += prefix + '"' + i + '": the item is missing\n';
    }

    for (; i < m; i++) {
      result += prefix + '"' + i + '": the item was not expected\n';
    }

    return result !== '\n' ? result : null;
  }

  if (is.boolean(one)) {
    if (!is.boolean(two)) {
      return 'expected type "' + name(one) + '" but found type "' + name(two) + '"\n';
    }

    if (one.valueOf() !== two.valueOf()) {
      return 'expected ' + one.valueOf() + ' but found ' + two.valueOf() + '\n';
    }

    return null;
  }

  if (is.null(one)) {
    if (!is.null(two)) {
      return 'expected type "' + name(one) + '" but found type "' + name(two) + '"\n';
    }

    return null;
  }

  if (is.number(one)) {
    if (!is.number(two)) {
      return 'expected type "' + name(one) + '" but found type "' + name(two) + '"\n';
    }

    if (one.valueOf() !== two.valueOf()) {
      return 'expected ' + one.valueOf() + ' but found ' + two.valueOf() + '\n';
    }

    return null;
  }

  if (is.object(one)) {
    if (!is.object(two)) {
      return 'expected type "' + name(one) + '" but found type "' + name(two) + '"\n';
    }

    for (k in one) {
      if (!(k in two)) {
        result += prefix + '"' + k + '": the item is missing\n';
      } else {
        summary = compare(one[k], two[k], prefix + '    ');

        if (summary !== null) {
          result += prefix + '"' + k + '": ' + summary;
        }
      }
    }

    for (k in two) {
      if (!(k in one)) {
        result += prefix + '"' + k + '": the item was not expected\n';
      }
    }

    return result !== '\n' ? result : null;
  }

  if (is.string(one)) {
    if (!is.string(two)) {
      return 'expected type "' + name(one) + '" but found type "' + name(two) + '"\n';
    }

    if (one.valueOf() !== two.valueOf()) {
      return 'expected "' + one.valueOf() + '" but found "' + two.valueOf() + '"\n';
    }

    return null;
  }

  if (is.undefined(one)) {
    if (!is.undefined(two)) {
      return 'expected type "' + name(one) + '" but found type "' + name(two) + '"\n';
    }

    return null;
  }

  if (two == null || two.constructor !== one.constructor) {
    return 'expected an instance of type "' + name(one) + '"\n';
  } else {
    if (one !== two) {
      return 'expected a different instance of type "' + name(one) + '"\n';
    }
  }

  return null;
};

module.exports = compare;

},{"./is.js":258,"./name.js":260}],251:[function(require,module,exports){
var is = require('./is.js');

/**
 * Checks whether the given actual json conforms to the given schema. This
 * asserts that all required fields are present and have the correct types. It
 * also asserts that all optional fields either are present and have the correct
 * types or are missing in the given actual json.
 */
var conforms = function (actual, schema, verbose, path) {
  var i;
  var l;
  var result;
  var k;
  var parts;

  if (!is.boolean(verbose)) {
    verbose = false;
  }

  if (!is.string(path)) {
    path = 'root';
  }

  if (is.array(schema)) {
    if (is.array(actual)) {
      if (schema.length === 0) {
        return true;
      }

      if (schema.length !== 1) {
        if (verbose) {
          console.warn(path + ': expected an array with exactly one element in the schema but found ' + schema.length + ' elements');
        }

        return false;
      }

      result = true;

      for (i = 0, l = actual.length; i < l; i++) {
        if (!conforms(actual[i], schema[0], verbose, path + '[' + i + ']')) {
          result = false;
        }
      }

      return result;
    } else {
      if (verbose) {
        console.warn(path + ': expected an array but found', actual);
      }

      return false;
    }
  }

  if (is.boolean(schema)) {
    if (is.boolean(actual)) {
      return true;
    } else {
      if (verbose) {
        console.warn(path + ': expected a boolean but found', actual);
      }

      return false;
    }
  }

  if (is.number(schema)) {
    if (is.number(actual)) {
      return true;
    } else {
      if (verbose) {
        console.warn(path + ': expected a number but found', actual);
      }

      return false;
    }
  }

  if (is.object(schema)) {
    if (is.object(actual)) {
      result = true;

      for (k in schema) {
        parts = /^([^?]+)\?$/.exec(k);

        if (parts === null) {
          if (!conforms(actual[k], schema[k], verbose, path + '.' + k)) {
            result = false;
          }
        } else {
          if (actual[parts[1]] != null) {
            if (!conforms(actual[parts[1]], schema[k], verbose, path + '.' + k)) {
              result = false;
            }
          }
        }
      }

      return result;
    } else {
      if (verbose) {
        console.warn(path + ': expected an object but found', actual);
      }

      return false;
    }
  }

  if (is.string(schema)) {
    if (is.string(actual)) {
      return true;
    } else {
      if (verbose) {
        console.warn(path + ': expected a string but found', actual);
      }

      return false;
    }
  }

  if (verbose) {
    console.warn(path + ': expected a supported type in the schema but found', schema);
  }

  return false;
};

module.exports = conforms;

},{"./is.js":258}],252:[function(require,module,exports){
(function (global){
var check = require('./check.js');

/**
 * Makes base a pure class.
 */
var define = function (base) {
  check.function(base);

  base.prototype = global.Object.create(null);
  base.prototype.constructor = base;
};

module.exports = define;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./check.js":248}],253:[function(require,module,exports){
var is = require('./is.js');
var name = require('./name.js');

/**
 * Determines if the two given instances are identical. Compares arrays,
 * booleans, numbers, objects and strings as well as null and undefined by value
 * and other types by reference.
 */
var equals = function (one, two) {
  var i;
  var k;
  var l;

  if (is.array(one)) {
    if (!is.array(two)) {
      return false;
    }

    if (one.length !== two.length) {
      return false;
    }

    for (i = 0, l = one.length; i < l; i++) {
      if (!equals(one[i], two[i])) {
        return false;
      }
    }

    return true;
  }

  if (is.boolean(one)) {
    if (!is.boolean(two)) {
      return false;
    }

    if (one.valueOf() !== two.valueOf()) {
      return false;
    }

    return true;
  }

  if (is.null(one)) {
    if (!is.null(two)) {
      return false;
    }

    return true;
  }

  if (is.number(one)) {
    if (!is.number(two)) {
      return false;
    }

    if (one.valueOf() !== two.valueOf()) {
      return false;
    }

    return true;
  }

  if (is.object(one)) {
    if (!is.object(two)) {
      return false;
    }

    for (k in one) {
      if (!(k in two)) {
        return false;
      }

      if (!equals(one[k], two[k])) {
        return false;
      }
    }

    for (k in two) {
      if (!(k in one)) {
        return false;
      }
    }

    return true;
  }

  if (is.string(one)) {
    if (!is.string(two)) {
      return false;
    }

    if (one.valueOf() !== two.valueOf()) {
      return false;
    }

    return true;
  }

  if (is.undefined(one)) {
    if (!is.undefined(two)) {
      return false;
    }

    return true;
  }

  return one === two;
};

module.exports = equals;

},{"./is.js":258,"./name.js":260}],254:[function(require,module,exports){
(function (global){
var check = require('./check.js');

/**
 * Makes derived extend base.
 */
var extend = function (derived, base) {
  check.function(derived);
  check.function(base);

  derived.prototype = global.Object.create(base.prototype);
  derived.prototype.constructor = derived;
};

module.exports = extend;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./check.js":248}],255:[function(require,module,exports){
var is = require('./is.js');

/**
 * Returns the given fallback if the given instance is not an array.
 */
exports.array = function (instance, fallback) {
  return is.array(instance) ? instance : fallback;
};

/**
 * Returns the given fallback if the given instance is not a boolean.
 */
exports.boolean = function (instance, fallback) {
  return is.boolean(instance) ? instance : fallback;
};

/**
 * Returns the given fallback if the given instance is not a function.
 */
exports.function = function (instance, fallback) {
  return is.function(instance) ? instance : fallback;
};

/**
 * Returns the given fallback if the given instance is not null.
 */
exports.null = function (instance, fallback) {
  return is.null(instance) ? instance : fallback;
};

/**
 * Returns the given fallback if the given instance is not a number.
 */
exports.number = function (instance, fallback) {
  return is.number(instance) ? instance : fallback;
};

/**
 * Returns the given fallback if the given instance is not an object.
 */
exports.object = function (instance, fallback) {
  return is.object(instance) ? instance : fallback;
};

/**
 * Returns the given fallback if the given instance is not a string.
 */
exports.string = function (instance, fallback) {
  return is.string(instance) ? instance : fallback;
};

/**
 * Returns the given fallback if the given instance does not descend from the
 * given constructor.
 */
exports.type = function (instance, constructor, fallback) {
  return is.type(instance, constructor) ? instance : fallback;
};

/**
 * Returns the given fallback if the given instance is not undefined.
 */
exports.undefined = function (instance, fallback) {
  return is.undefined(instance) ? instance : fallback;
};

},{"./is.js":258}],256:[function(require,module,exports){
/**
 * Creates a function wrapper that always returns the given value.
 */
var fixture = function (value) {
  return function () {
    return value;
  };
};

module.exports = fixture;

},{}],257:[function(require,module,exports){
exports.assert = require('./assert.js');
exports.check = require('./check.js');
exports.clone = require('./clone.js');
exports.compare = require('./compare.js');
exports.conforms = require('./conforms.js');
exports.define = require('./define.js');
exports.equals = require('./equals.js');
exports.extend = require('./extend.js');
exports.fallback = require('./fallback.js');
exports.fixture = require('./fixture.js');
exports.is = require('./is.js');
exports.mock = require('./mock.js');
exports.name = require('./name.js');
exports.spy = require('./spy.js');
exports.stub = require('./stub.js');

},{"./assert.js":247,"./check.js":248,"./clone.js":249,"./compare.js":250,"./conforms.js":251,"./define.js":252,"./equals.js":253,"./extend.js":254,"./fallback.js":255,"./fixture.js":256,"./is.js":258,"./mock.js":259,"./name.js":260,"./spy.js":261,"./stub.js":262}],258:[function(require,module,exports){
(function (global){
/**
 * Determines if the given instance is an array.
 */
exports.array = function (instance) {
  return instance != null && instance.constructor === global.Array;
};

/**
 * Determines if the given instance is a boolean.
 */
exports.boolean = function (instance) {
  return instance != null && instance.constructor === global.Boolean;
};

/**
 * Determines if the given instance is a function.
 */
exports.function = function (instance) {
  return instance != null && instance.constructor === global.Function;
};

/**
 * Determines if the given instance is null.
 */
exports.null = function (instance) {
  return instance === null;
};

/**
 * Determines if the given instance is a number.
 */
exports.number = function (instance) {
  return instance != null && instance.constructor === global.Number;
};

/**
 * Determines if the given instance is an object.
 */
exports.object = function (instance) {
  return instance != null && instance.constructor === global.Object;
};

/**
 * Determines if the given instance is a string.
 */
exports.string = function (instance) {
  return instance != null && instance.constructor === global.String;
};

/**
 * Determines if the given instance descends from the given constructor.
 */
exports.type = function (instance, constructor) {
  return instance != null && constructor != null && instance instanceof constructor;
};

/**
 * Determines if the given instance is undefined.
 */
exports.undefined = function (instance) {
  return instance === global.undefined;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],259:[function(require,module,exports){
(function (global){
var check = require('./check.js');
var extend = require('./extend.js');
var is = require('./is.js');

/**
 * Creates a mock for the given base class with the given implementation that
 * can be used for unit testing. The methods defined on implementation will be
 * used instead of the methods defined on the base class.
 */
var mock = function (base, implementation) {
  var derived;
  var keys;
  var i;
  var key;

  check.function(base);

  derived = function () {
    base.apply(this, arguments);
  };

  extend(derived, base);

  derived.create = function () {
    var that;

    that = global.Object.create(derived.prototype);

    derived.apply(that, arguments);

    return that;
  };

  if (implementation != null) {
    check.object(implementation);

    keys = global.Object.getOwnPropertyNames(implementation);

    for (i = 0; i < keys.length; i++) {
      key = keys[i];

      if (key !== 'constructor' && is.function(implementation[key])) {
        if (is.function(base.prototype[key])) {
          derived.prototype[key] = implementation[key];
        } else {
          throw new global.Error('Method "' + key + '" doesn\'t override any method defined on the base class!');
        }
      }
    }
  }

  return derived;
};

module.exports = mock;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./check.js":248,"./extend.js":254,"./is.js":258}],260:[function(require,module,exports){
var is = require('./is.js');

/**
 * Attempts to read the type name for the given instance.
 */
var name = function (instance) {
  if (is.null(instance)) {
    return 'Null';
  }

  if (is.undefined(instance)) {
    return 'Undefined';
  }

  if (is.function(instance.constructor) && is.string(instance.constructor.name)) {
    return instance.constructor.name;
  }

  return '';
};

module.exports = name;

},{"./is.js":258}],261:[function(require,module,exports){
(function (global){
var check = require('./check.js');

/**
 * Creates a spy function that records all function calls into the given calls
 * array.
 */
var spy = function (calls) {
  check.array(calls);

  return function () {
    calls.push({ 'caller' : this, 'arguments' : global.Array.prototype.slice.call(arguments) });
  };
};

module.exports = spy;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./check.js":248}],262:[function(require,module,exports){
(function (global){
var check = require('./check.js');
var extend = require('./extend.js');
var is = require('./is.js');

/**
 * Creates a stub for the given base class with the given implementation that
 * can be used for unit testing.
 */
var stub = function (base, implementation) {
  var derived;
  var prototype;
  var keys;
  var i;
  var key;

  check.function(base);
  check.object(implementation);

  derived = function () {
    var key;

    for (key in implementation) {
      this[key] = implementation[key];
    }
  };

  extend(derived, base);

  derived.create = function () {
    var that;

    that = global.Object.create(derived.prototype);

    derived.apply(that, arguments);

    return that;
  };

  prototype = base.prototype;

  while (prototype != null && prototype !== global.Object.prototype) {
    keys = global.Object.getOwnPropertyNames(prototype);

    for (i = 0; i < keys.length; i++) {
      key = keys[i];

      if (key !== 'constructor' && is.function(prototype[key])) {
        if (is.function(implementation[key])) {
          derived.prototype[key] = implementation[key];
        } else {
          derived.prototype[key] = (function (key) {
            return function () {
              throw new global.Error('Method stub "' + key + '" called!');
            };
          })(key);
        }
      }
    }

    prototype = global.Object.getPrototypeOf(prototype);
  }

  return derived;
};

module.exports = stub;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./check.js":248,"./extend.js":254,"./is.js":258}],263:[function(require,module,exports){
'use strict';

exports.message = require('./src/message');
exports.request = require('./src/request');
exports.response = require('./src/response');
exports.playerstate = require('./src/player_state');

},{"./src/message":264,"./src/player_state":265,"./src/request":266,"./src/response":267}],264:[function(require,module,exports){
/**
 * A set of Message headers.
 *
 * @name exports.Headers
 * @typedef {Object.<string, string>}
 */
exports.Headers;

/**
 * A body of a Request-Response.
 *
 * @name exports.Body
 * @typedef {*}
 */
exports.Body;

/**
 * A serialized Message object.
 *
 * @name Spotify.Cosmos.SerializedMessage
 * @typedef {{
 *   uri: Spotify.Cosmos.URI,
 *   headers: Spotify.Cosmos.Headers,
 *   body: Spotify.Cosmos.Body
 * }}
 */
exports.SerializedMessage;

/**
 * Encapsulates a message.
 *
 * A message is an entity that has a URI, headers and a body.
 *
 * @constructs Spotify.Cosmos.Message
 * @param {Spotify.Cosmos.URI} uri The URI of the message
 * @param {Spotify.Cosmos.Headers=} opt_headers The optional headers of the
 *     message.
 * @param {Spotify.Cosmos.Body=} opt_body The optional body of the message.
 */
function Message(uri, opt_headers, opt_body) {
  if (uri == null)
    throw new TypeError('Invalid `uri` argument for Message.');

  /**
   * The URI of the Message.
   *
   * @type {Spotify.Cosmos.URI}
   * @protected
   */
  this._uri = uri;

  /**
   * The headers of the Message.
   *
   * @type {Spotify.Cosmos.Headers}
   * @protected
   */
  this._headers = {};

  /**
   * The body of the Message.
   *
   * @type {Spotify.Cosmos.Body}
   * @protected
   */
  this._body = this._encodeBody(opt_body || '');

  if (opt_headers) this._setHeaders(opt_headers);
}
exports.Message = Message;

/**
 * Creates a new Message from a SerializedMessage object.
 *
 * @param {Spotify.Cosmos.SerializedMessage} object The serialized request.
 * @return {Spotify.Cosmos.Message|null} The new Message object or null.
 */
Message.fromObject = function(object) {
  return (object && object.uri) ?
    new Message(
        object.uri,
        object.headers,
        object.body
    ) : null;
};

/**
 * Encodes a message body to a string.
 *
 * @param {*} body The value for the body.
 * @return {string} The body encoded as a string.
 */
Message.prototype._encodeBody = function(body) {
  if (typeof body != 'string') {
    body = JSON.stringify(body);
  }
  return body;
};

/**
 * Returns the URI of the message.
 *
 * @return {Spotify.Cosmos.URI} The URI of the message.
 */
Message.prototype.getURI = function() {
  return this._uri;
};

/**
 * Returns the mimetype of the message.
 *
 * @return {Spotify.Cosmos.MimeType} The mimetype of the message.
 */
Message.prototype.getMimeType = function() {
  return this._headers['accept'];
};

/**
 * Returns the value of a message's headers.
 *
 * @param {string} name The name of the header.
 * @return {string|null} The header value or null if the header wasn't set.
 */
Message.prototype.getHeader = function(name) {
  return this._headers[name.toLowerCase()] || null;
};

/**
 * Returns the headers of the message.
 *
 * @return {Spotify.Cosmos.Headers} The headers of the message.
 */
Message.prototype.getHeaders = function() {
  var _headers = this._headers;
  var headers = {};
  for (var name in _headers) {
    if (!_headers.hasOwnProperty(name)) continue;
    headers[name] = _headers[name];
  }
  return headers;
};

/**
 * Sets a bunch of headers to the message's headers.
 *
 * @param {Spotify.Cosmos.Headers} headers The headers to set to the message.
 * @protected
 */
Message.prototype._setHeaders = function(headers) {
  var _headers = this._headers;
  for (var name in headers) {
    if (!headers.hasOwnProperty(name)) continue;
    _headers[name.toLowerCase()] = headers[name];
  }
  return this;
};

/**
 * Returns the body of the message.
 *
 * @return {Spotify.Cosmos.Body} The body of the message.
 */
Message.prototype.getBody = function() {
  return this._body;
};

/**
 * Returns the body as a JSON object.
 *
 * @return {Object|null} The body of the message parsed as a JSON value. Can
 *     be null if the body is not a proper JSON string.
 */
Message.prototype.getJSONBody = function() {
  try {
    return JSON.parse(this._body);
  } catch(e) {
    return null;
  }
};

/**
 * Creates a new Message instance with data copied from the current instance.
 *
 * @param {Spotify.Cosmos.Headers=} opt_headers The optional headers of the
 *     message.
 * @param {Spotify.Cosmos.Body=} opt_body The optional body of the message.
 */
Message.prototype.copy = function(opt_headers, opt_body) {
  return new Message(
      this._uri,
      this._copyHeaders(opt_headers),
      typeof opt_body != 'undefined' ? opt_body : this._body
  );
};

/**
 * Copies the headers of the message.
 *
 * @param {Spotify.Cosmos.Headers=} opt_headers The optional headers of the
 *     message.
 * @return {Spotify.Cosmos.Headers} The headers of the message.
 */
Message.prototype._copyHeaders = function(opt_headers) {
  var headers;
  if (opt_headers) {
    var _headers = this._headers;
    var name;
    headers = {};
    for (name in _headers) {
      if (!_headers.hasOwnProperty(name)) continue;
      headers[name] = _headers[name];
    }
    for (name in opt_headers) {
      if (!opt_headers.hasOwnProperty(name)) continue;
      headers[name.toLowerCase()] = opt_headers[name];
    }
  } else {
    headers = this._headers;
  }
  return headers;
};

/**
 * Serializes the message into a plain object.
 *
 * @return {Spotify.Cosmos.SerializedMessage} The serialized object.
 */
Message.prototype.serialize = function() {
  return this.toJSON();
};

/**
 * Returns a JSON-object representation of the message.
 *
 * @return {Object} The JSON representation of the message.
 */
Message.prototype.toJSON = function() {
  return {
    uri: this._uri,
    headers: this._headers,
    body: this._body
  };
};

},{}],265:[function(require,module,exports){
var inherit = require('spotify-inheritance').inherit;

/**
 * PlayerState is used for two distinct purposes: Pushing new state to the
 * player (this is done when you request to play a completely new context with
 * 'play' method) and retrieving player state updates.
 *
 * Changing properties on PlayerState objects will not change the state of
 * the player unless you pass it to the 'play' method.
 *
 * @param {Object} stateData the data for the playerState.
 */
function PlayerState(stateData) {
  Serializable.call(this, [
    'action',
    'context',
    'tracks',
    'index',
    'playing',
    'loading',
    'track',
    'position',
    'duration',
    'volume',
    'options',
    'play_origin',
    'next_page_url',
    'prev_page_url'
  ]);

  stateData = stateData || {};
  /**
   * What kind of the action player should perform.
   * It's set directly before sending the request.
   * @type {String}
   */
  this.action = stateData.action;

  /**
   * Spotify uri describing the context that
   * will be played e.g playlist, album or artist.
   * Example: spotify:artist:4XaUmUGjidSklcDHxv3XWf,
   * spotify:user:daftpunkofficial:playlist:5nrg0D90OlFyveVfrQD0zE,
   * spotify:album:2nXJkqkS1tIKIyhBcFMmwz
   *
   * @type {String}
   */
  this.context = stateData.context;

  /**
   * The list of tracks uris to play in the given context.
   * Example: [
   *    spotify:track:0bXpmJyHHYPk6QBFj25bYF,
   *    spotify:track:6DXFVsLcEvOTSrkG9G1Cb1,
   *    spotify:track:6rxEjkoar48SssZePbtb2x
   * ]
   *
   * @type {Array.<String>}
   */
  this.tracks = stateData.tracks;

  /**
   * Which element on the this.tracks list should
   * be played.
   *
   * @type {Number}
   */
  this.index = stateData.index;

  /**
   * Is the player currently playing
   */
  this.playing = stateData.playing;
  this.loading = stateData.loading;

  /**
   * Current track URI
   * @type {String}
   */
  this.track = stateData.track;


  this.position = stateData.position;

  this.volume = stateData.volume;

  /**
   * Current track duration in miliseconds?
   * @type {Number}
   */
  this.duration = stateData.duration;

  /**
   * See PlayOptions description
   * @type {cosmos-bindings-js/scripts/player_state~PlayOptions}
   */
  this.options = new PlayOptions(stateData.options);

  /**
   * See PlayOrigin description
   * @type {cosmos-bindings-js/scripts/player_state~PlayOrigin}
   */
  this.play_origin = new PlayOrigin(stateData.play_origin);

  /**
   * Before the list of tracks that are to be played ends, a request will be sent
   * to this URL, which is supposed to return a list of tracks. That list of
   * tracks will then be appended to the list of tracks in the context.
   *
   * The response payload of the next_page_url should look like this:
   *
   * {
   *   "tracks": [
   *     { "track": "spotify:track:$TRACK-ID1", "context": "spotify:album:$ALBUM-ID1" },
   *     { "track": "spotify:track:$TRACK-ID2", "context": "spotify:album:$ALBUM-ID1" },
   *     { "track": "spotify:track:$TRACK-ID3", "context": "spotify:album:$ALBUM-ID1" },
   *   ],
   *   "next_page_url": "...", // Optional
   *   "prev_page_url": "..." // Optional
   * }
   *
   * May be null, which is the same as a URL that would return an empty list
   * of tracks (but with null, no network request is made).
   */
  this.next_page_url = stateData.next_page_url;

  /**
   * Like `next_page_url`, but for going backwards in the context.
   */
  this.prev_page_url = stateData.prev_page_url;
}
inherit(PlayerState, Serializable);

/**
 * Ovverides prototype method.
 * Converts play options and origin to
 * serializable to make sure only correct data
 * is returned.
 * @return {Object} Data associated with player state.
 */
PlayerState.prototype.serialize = function() {
  if (this.options && !(this.options instanceof PlayOptions)) {
    this.options = new PlayOptions(this.options);
  }

  if (this.play_origin && !(this.play_origin instanceof PlayOrigin)) {
    this.play_origin = new PlayOrigin(this.play_origin);
  }

  return this.constructor.prototype.serialize.call(this);
};

/**
 * Possible player actions.
 */
PlayerState.ACTIONS = {
  UNKNOWN: 'unknown',
  PLAY: 'play',
  UPDATE: 'update',
  STOP: 'stop',
  RESUME: 'resume',
  PAUSE: 'pause',
  SKIP_PREV: 'skip_prev',
  SKIP_NEXT: 'skip_next'
};

function PlayOrigin(data) {
  Serializable.call(this, [
    'source',
    'source_context',
    'reason',
    'referrer',
    'referrer_version',
    'referrer_vendor'
  ]);

  data = data || {};

  /**
   * What kind of playlist did we play from?
   *
   * The default value of this property is "unknown". Must have a value.
   *
   * Valid values include 'album', 'artist', 'extlink', 'playlist', 'playqueue',
   * 'radio', 'search', 'unknown'.
   *
   * For an up to date list of valid values, see `PLAY_SOURCES` in
   * https://git.spotify.net/cgit.cgi/log-parser.git/tree/spotify/log_parser/messages_specs.py
   */
  this.source = data.source || 'unknown';

  /**
   * The uri of the view that initiated the playback.
   */
  this.source_context = data.source_context || 'unknown';

  /**
   * Why was the song started?
   *
   * The default value of this property is "unknown". Must have a value.
   *
   * A list of valid values that might be used by features:
   *
   * unknown    = Client doesn't know
   * clickrow   = A row in the song list was clicked/opened
   * playbtn    = The play button was pressed
   * urlopen    = A Url was opened
   *
   * For a complete and up to date list of valid values, see `PLAY_REASONS` in
   * https://git.spotify.net/cgit.cgi/log-parser.git/tree/spotify/log_parser/messages_specs.py
   */
  this.reason = data.reason || 'unknown';

  /**
   * Either a remote site or a spotify app which initiated the request.
   *
   * NOTE: This normally should be a readonly property and not be set
   * explicitly in the PlayerState as the Player will overwrite it when sending the request.
   */
  this.referrer = data.referrer || 'unknown';

  /**
   * The version of the referrer, where applicable. It usually makes sense to
   * set this value to the version of the JS app version, for instance "0.7.5".
   *
   * NOTE: This normally should be a readonly property and not be set
   * explicitly in the PlayerState as the Player will overwrite it when sending the request.
   */
  this.referrer_version = data.referrer_version || 'unknown';

  /**
   * The vendor of the referrer, where applicable.
   * For example com.soundrop, com.spotify.
   *
   * NOTE: This normally should be a readonly property and not be set
   * explicitly in the PlayerState as the Player will overwrite it when sending the request.
   */
  this.referrer_vendor = data.referrer_vendor || 'unknown';
}
inherit(PlayOrigin, Serializable);

/**
 * What kind of options user has
 * with the player. By default
 * all 'can_*' properties are set to true.
 * You might want to restrict some of them
 * in the special cases like ads (no skipping)
 * or radio no skipping prev.
 * @constructor
 * @param {Object} options The options data.
 */
function PlayOptions(options) {
  Serializable.call(this, [
    'repeat',
    'shuffle',
    'can_repeat',
    'can_shuffle',
    'can_skip_prev',
    'can_skip_next',
    'can_seek',
    'use_dmca_rules'
  ]);
  options = options || {};

  /**
   * True if repeat (repeat all, not single track repeat) is (or is to be) enabled.
   *
   * Default value is false
   */
  this.repeat = options.repeat !== undefined ? options.repeat : false;

  /**
   * True if shuffle is (or is to be) enabled.
   *
   * Default value is false
   */
  this.shuffle = options.shuffle !== undefined ? options.shuffle : false;

  /**
   * True if this context can be repeated. This would be false for instance in the
   * case of radio.
   *
   * Default value is true.
   */
  this.can_repeat = options.can_repeat !== undefined ? options.can_repeat : true;

  /**
   * True if this context can be shuffled. This would be false for instance in the
   * case of radio.
   *
   * Default value is true.
   */
  this.can_shuffle = options.can_shuffle !== undefined ? options.can_shuffle : true;

  /**
   * True if the user is (or should be) allowed to skip to the previous track.
   *
   * Default value is true.
   */
  this.can_skip_prev = options.can_skip_prev !== undefined ? options.can_skip_prev : true;

  /**
   * True if the user is (or should be) allowed to skip to the next track.
   *
   * Default value is true.
   */
  this.can_skip_next = options.can_skip_next !== undefined ? options.can_skip_next : true;

  /**
   * True if the user is (or should be) allowed to seek to a certain time in the
   * currently playing track.
   *
   * Default value is true.
   */
  this.can_seek = options.can_seek !== undefined ? options.can_seek : true;

  /**
   * True if the track player should automatically apply DMCA rules when playing.
   * DMCA rules should be enabled for users that have free radio in the US, and
   * controls how many tracks the user are allowed to skip etc.
   *
   * Default value is false.
   */
  this.use_dmca_rules = options.use_dmca_rules !== undefined ? options.use_dmca_rules : false;
}
inherit(PlayOptions, Serializable);

/**
 * The object accepting only defined properties.
 * To make sure only valid properties are passed
 * always use 'serialize()' when object value needed.
 * @constructor
 * @param {Array.<string>} allowedProps The list of the properties
 * that are supported for the object.
 */
function Serializable(allowedProps) {
  this._props = allowedProps || [];
}

/**
 * The JSON representation of the object.
 * @return {Object} Data associated with current player state.
 */
Serializable.prototype.serialize = function() {
  var data = {};
  var prop;

  for (var i = 0, l = this._props.length; i < l; i++) {
    prop = this._props[i];
    if (this[prop] !== undefined) {
      if (this[prop] instanceof Serializable) {
        data[prop] = this[prop].serialize();
      } else {
        data[prop] = this[prop];
      }
    }
  }

  return data;
};

exports.PlayerState = PlayerState;

},{"spotify-inheritance":365}],266:[function(require,module,exports){
var inherit = require('spotify-inheritance').inherit;

var Message = require('./message').Message;

/**
 * Request actions.
 *
 * @name exports.Action
 * @enum {string}
 */
exports.Action = {
  DELETE: 'DELETE',
  GET: 'GET',
  HEAD: 'HEAD',
  POST: 'POST',
  PUT: 'PUT',
  SUB: 'SUB',
  PATCH: 'PATCH'
};

/**
 * A serialized Request object.
 *
 * @name Spotify.Cosmos.SerializedRequest
 * @typedef {{
 *   uri: Spotify.Cosmos.URI,
 *   headers: Spotify.Cosmos.Headers,
 *   body: Spotify.Cosmos.Body
 * }}
 */
exports.SerializedRequest;

/**
 * Encapsulates a request to the handlers.
 *
 * Instances of this class are "immutable" and should not be changed.
 *
 * @constructs Spotify.Cosmos.Request
 * @extends Spotify.Cosmos.Message
 * @param {Spotify.Cosmos.Action} action The action of the request.
 * @param {Spotify.Cosmos.URI} uri The URI of the request
 * @param {Spotify.Cosmos.Headers=} opt_headers The optional headers of the
 *     request.
 * @param {Spotify.Cosmos.Body=} opt_body The optional body of the request.
 */
function Request(action, uri, opt_headers, opt_body) {
  if (!(this instanceof Request))
    return new Request(action, uri, opt_headers, opt_body);
  if (!action)
    throw new TypeError('Invalid `action` argument for Request.');
  Message.call(this, uri, opt_headers, opt_body);

  /**
   * The action of the request.
   *
   * @type {Spotify.Cosmos.Action}
   * @protected
   */
  this._action = action;
}
inherit(Request, Message);
exports.Request = Request;

/**
 * Creates a new Request from a SerializedRequest object.
 *
 * @param {Spotify.Cosmos.SerializedRequest} object The serialized request.
 * @return {Spotify.Cosmos.Request|null} The new Request object or null.
 */
Request.fromObject = function(object) {
  return (object && object.action && object.uri) ?
    new Request(
        object.action,
        object.uri,
        object.headers,
        object.body
    ) : null;
};

/**
 * Returns the action of the request.
 *
 * @return {Spotify.Cosmos.Action} The action of the request.
 */
Request.prototype.getAction = function() {
  return this._action;
};

/**
 * @inheritDoc
 */
Request.prototype.copy = function(opt_headers, opt_body) {
  return new Request(
      this._action,
      this._uri,
      this._copyHeaders(opt_headers),
      typeof opt_body != 'undefined' ? opt_body : this._body
  );
};

/**
 * @inheritDoc
 */
Request.prototype.toJSON = function() {
  return {
    action: this._action,
    uri: this._uri,
    headers: this._headers,
    body: this._body
  };
};



},{"./message":264,"spotify-inheritance":365}],267:[function(require,module,exports){
var inherit = require('spotify-inheritance').inherit;

var Message = require('./message').Message;

/**
 * Statuscode.
 * The statuses with negative numbers are reserved for
 * errors that originate within the cosmos library.
 *
 * @name exports.StatusCode
 * @enum {number}
 */
exports.StatusCode = {
  OK: 200,
  CREATED: 201,
  ACCEPTED: 202,
  BAD_REQUEST: 400,
  UNAUTHORIZED: 401,
  FORBIDDEN: 403,
  NOT_FOUND: 404,
  METHOD_NOT_ALLOWED: 405,
  TIMED_OUT: 408,
  CONFLICT: 409,
  GONE: 410,
  INTERNAL_SERVER_ERROR: 500,
  NOT_IMPLEMENTED: 501,
  BAD_GATEWAY: 502,
  SERVICE_UNAVAILABLE: 503,

  /** Something went wrong, but the exact reason is not known. */
  ERROR_UNKNOWN: -100,

  /** A resource allocation required to complete the request failed. */
  ERROR_ALLOCATION_FAILED: -101,

  /** The body could not be decoded because it does
   not conform to the encoding header field. */
  ERROR_INVALID_ENCODING: -102,

  /** The router detected an infinite loop while processing the request. */
  ERROR_INFINITE_LOOP: -103,

  /** No endpoint resolver that could handle the request was found. */
  ERROR_RESOLVER_NOT_FOUND: -104
};

/**
 * A serialized Response object.
 *
 * @name Spotify.Cosmos.SerializedResponse
 * @typedef {{
 *   uri: Spotify.Cosmos.URI,
 *   status: Spotify.Cosmos.StatusCode,
 *   headers: Spotify.Cosmos.Headers,
 *   body: Spotify.Cosmos.Body
 * }}
 */
exports.SerializedResponse;

/**
 * Encapsulates a response from the handlers.
 *
 * @constructs Spotify.Cosmos.Response
 * @extends Spotify.Cosmos.Message
 * @param {Spotify.Cosmos.URI} uri The URI of the response
 * @param {Spotify.Cosmos.StatusCode} status The status of the response.
 * @param {Spotify.Cosmos.Headers=} opt_headers The optional headers of the
 *     response.
 * @param {Spotify.Cosmos.Body=} opt_body The optional body of the response.
 */
function Response(uri, status, opt_headers, opt_body) {
  if (!(this instanceof Response))
    return new Response(uri, status, opt_headers, opt_body, opt_requestURI);
  if (typeof status == 'undefined' || status == null)
    throw new TypeError('Invalid `status` argument for Response.');

  Message.call(this, uri, opt_headers, opt_body);

  /**
   * The Status of the Response.
   *
   * @type {Spotify.Cosmos.StatusCode}
   * @protected
   */
  this._status = status;
}
inherit(Response, Message);
exports.Response = Response;

/**
 * Creates a new Response from a SerializedResponse object.
 *
 * @param {Spotify.Cosmos.SerializedResponse} object The serialized response.
 * @return {Spotify.Cosmos.Response|null} The new Response object or null.
 */
Response.fromObject = function(object) {
  return (object && object.uri && object.status) ?
    new Response(
        object.uri,
        object.status,
        object.headers,
        object.body
    ) : null;
};

/**
 * @inheritDoc
 */
Response.prototype.getMimeType = function() {
  return this._headers['content-type'];
};

/**
 * Returns the status code of the Response.
 *
 * @return {Spotify.Cosmos.StatusCode} The status code of the response.
 */
Response.prototype.getStatusCode = function() {
  return this._status;
};

/**
 * @inheritDoc
 */
Response.prototype.copy = function(opt_headers, opt_body) {
  return new Response(
      this._uri,
      this._status,
      this._copyHeaders(opt_headers),
      typeof opt_body != 'undefined' ? opt_body : this._body
  );
};

/**
 * @inheritDoc
 */
Response.prototype.toJSON = function() {
  return {
    uri: this._uri,
    status: this._status,
    headers: this._headers,
    body: this._body
  };
};


},{"./message":264,"spotify-inheritance":365}],268:[function(require,module,exports){

/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = require('./debug');
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // is webkit? http://stackoverflow.com/a/16459606/376773
  return ('WebkitAppearance' in document.documentElement.style) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (window.console && (console.firebug || (console.exception && console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  return JSON.stringify(v);
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs() {
  var args = arguments;
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return args;

  var c = 'color: ' + this.color;
  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
  return args;
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}
  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage(){
  try {
    return window.localStorage;
  } catch (e) {}
}

},{"./debug":269}],269:[function(require,module,exports){

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = debug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = require('ms');

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lowercased letter, i.e. "n".
 */

exports.formatters = {};

/**
 * Previously assigned color.
 */

var prevColor = 0;

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 *
 * @return {Number}
 * @api private
 */

function selectColor() {
  return exports.colors[prevColor++ % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function debug(namespace) {

  // define the `disabled` version
  function disabled() {
  }
  disabled.enabled = false;

  // define the `enabled` version
  function enabled() {

    var self = enabled;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // add the `color` if not set
    if (null == self.useColors) self.useColors = exports.useColors();
    if (null == self.color && self.useColors) self.color = selectColor();

    var args = Array.prototype.slice.call(arguments);

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %o
      args = ['%o'].concat(args);
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    if ('function' === typeof exports.formatArgs) {
      args = exports.formatArgs.apply(self, args);
    }
    var logFn = enabled.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }
  enabled.enabled = true;

  var fn = exports.enabled(namespace) ? enabled : disabled;

  fn.namespace = namespace;

  return fn;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  var split = (namespaces || '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

},{"ms":342}],270:[function(require,module,exports){

/**
 * Expose `parse`.
 */

module.exports = parse;

/**
 * Tests for browser support.
 */

var div = document.createElement('div');
// Setup
div.innerHTML = '  <link/><table></table><a href="/a">a</a><input type="checkbox"/>';
// Make sure that link elements get serialized correctly by innerHTML
// This requires a wrapper element in IE
var innerHTMLBug = !div.getElementsByTagName('link').length;
div = undefined;

/**
 * Wrap map from jquery.
 */

var map = {
  legend: [1, '<fieldset>', '</fieldset>'],
  tr: [2, '<table><tbody>', '</tbody></table>'],
  col: [2, '<table><tbody></tbody><colgroup>', '</colgroup></table>'],
  // for script/link/style tags to work in IE6-8, you have to wrap
  // in a div with a non-whitespace character in front, ha!
  _default: innerHTMLBug ? [1, 'X<div>', '</div>'] : [0, '', '']
};

map.td =
map.th = [3, '<table><tbody><tr>', '</tr></tbody></table>'];

map.option =
map.optgroup = [1, '<select multiple="multiple">', '</select>'];

map.thead =
map.tbody =
map.colgroup =
map.caption =
map.tfoot = [1, '<table>', '</table>'];

map.polyline =
map.ellipse =
map.polygon =
map.circle =
map.text =
map.line =
map.path =
map.rect =
map.g = [1, '<svg xmlns="http://www.w3.org/2000/svg" version="1.1">','</svg>'];

/**
 * Parse `html` and return a DOM Node instance, which could be a TextNode,
 * HTML DOM Node of some kind (<div> for example), or a DocumentFragment
 * instance, depending on the contents of the `html` string.
 *
 * @param {String} html - HTML string to "domify"
 * @param {Document} doc - The `document` instance to create the Node for
 * @return {DOMNode} the TextNode, DOM Node, or DocumentFragment instance
 * @api private
 */

function parse(html, doc) {
  if ('string' != typeof html) throw new TypeError('String expected');

  // default to the global `document` object
  if (!doc) doc = document;

  // tag name
  var m = /<([\w:]+)/.exec(html);
  if (!m) return doc.createTextNode(html);

  html = html.replace(/^\s+|\s+$/g, ''); // Remove leading/trailing whitespace

  var tag = m[1];

  // body support
  if (tag == 'body') {
    var el = doc.createElement('html');
    el.innerHTML = html;
    return el.removeChild(el.lastChild);
  }

  // wrap map
  var wrap = map[tag] || map._default;
  var depth = wrap[0];
  var prefix = wrap[1];
  var suffix = wrap[2];
  var el = doc.createElement('div');
  el.innerHTML = prefix + html + suffix;
  while (depth--) el = el.lastChild;

  // one element
  if (el.firstChild == el.lastChild) {
    return el.removeChild(el.firstChild);
  }

  // several elements
  var fragment = doc.createDocumentFragment();
  while (el.firstChild) {
    fragment.appendChild(el.removeChild(el.firstChild));
  }

  return fragment;
}

},{}],271:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      }
      throw TypeError('Uncaught, unspecified "error" event.');
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],272:[function(require,module,exports){
var hasOwn = Object.prototype.hasOwnProperty;
var toStr = Object.prototype.toString;
var undefined;

var isArray = function isArray(arr) {
	if (typeof Array.isArray === 'function') {
		return Array.isArray(arr);
	}

	return toStr.call(arr) === '[object Array]';
};

var isPlainObject = function isPlainObject(obj) {
	'use strict';
	if (!obj || toStr.call(obj) !== '[object Object]') {
		return false;
	}

	var has_own_constructor = hasOwn.call(obj, 'constructor');
	var has_is_property_of_method = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');
	// Not own constructor property must be Object
	if (obj.constructor && !has_own_constructor && !has_is_property_of_method) {
		return false;
	}

	// Own properties are enumerated firstly, so to speed up,
	// if last one is own, then all properties are own.
	var key;
	for (key in obj) {}

	return key === undefined || hasOwn.call(obj, key);
};

module.exports = function extend() {
	'use strict';
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[0],
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if (typeof target === 'boolean') {
		deep = target;
		target = arguments[1] || {};
		// skip the boolean and the target
		i = 2;
	} else if ((typeof target !== 'object' && typeof target !== 'function') || target == null) {
		target = {};
	}

	for (; i < length; ++i) {
		options = arguments[i];
		// Only deal with non-null/undefined values
		if (options != null) {
			// Extend the base object
			for (name in options) {
				src = target[name];
				copy = options[name];

				// Prevent never-ending loop
				if (target === copy) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {
					if (copyIsArray) {
						copyIsArray = false;
						clone = src && isArray(src) ? src : [];
					} else {
						clone = src && isPlainObject(src) ? src : {};
					}

					// Never move original objects, clone them
					target[name] = extend(deep, clone, copy);

				// Don't bring in undefined values
				} else if (copy !== undefined) {
					target[name] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};


},{}],273:[function(require,module,exports){
/*
Finally
*/'use strict';

var prime = require('prime');

var kindOf = require('mout/lang/kindOf');
var map = require('mout/array/map');
var slice = require('mout/array/slice');
var forEach = require('mout/array/forEach');
var reduce = require('mout/array/reduce');

var each = require('mout/collection/forEach');
var cmap = require('mout/collection/map');

var push_ = Array.prototype.push;

/* create the flow */
var Flow = prime({

  /* options */
  constructor: function Flow() {
    this._seq = [];
  },

  /* add steps to the flow */
  then: function() {
    this._push(this._callbacks(arguments));
    return this;
  },

  _parallel: function(parallel, args) {
    var self = this;
    return function() {
      var control = new Controller(self, self._index++);
      self._controls.push(control);
      parallel.apply(control, args ? args.concat(slice(arguments)) : arguments);
    };
  },

  _push: function(parallels, args) {
    if (!parallels.length) return;
    this._seq.push(map(parallels, function(parallel) {
      return this._parallel(parallel, args);
    }, this));
  },

  _callbacks: function(callbacks) {
    return reduce(callbacks, function(a, b) {
      if (kindOf(b) === 'Array') push_.apply(a, b);
      else a.push(b);
      return a;
    }, []);
  },

  /* will make a sequential entry for each entry in the object */
  sequential: function(object) {
    var callbacks = this._callbacks(slice(arguments, 1));
    each(object, function(value, key) {
      this._push(callbacks, [value, key]);
    }, this);
    return this;
  },

  /* will make a single sequential entry with one parallel for each entry in the object */
  parallel: function(object, parallel) {
    var parallels = cmap(object, function(value, key) {
      return this._parallel(parallel, [value, key]);
    }, this);
    if (parallels.length) this._seq.push(parallels);
    return this;
  },

  /* assign last step and execute the flow */
  finally: function() {
    this.then.apply(this, arguments);
    this._continue.call(this);
    return this;
  },

  /* execute the flow with arguments to the first step */
  run: function() {
    this._continue.apply(this, arguments);
    return this;
  },

  // private

  _break: function() {
    this._seq.splice(0, this._seq.length - 1);
    this._continue.apply(this, arguments);
  },

  _spread: function(error, args) {
    var seq = this._next();
    if (!seq || !(seq = seq[0])) return;
    if (!args || !args.length) args = [undefined];
    this._length = args.length;
    forEach(args, function(arg) {
      seq(error, arg);
    });
  },

  _continue: function() {
    var seq = this._next();
    if (!seq) return;
    this._length = seq.length;
    var args = arguments;
    forEach(seq, function(parallel) {
      parallel.apply(null, args);
    });
  },

  _next: function() {
    var seq = this._seq.shift();
    if (!seq) return;

    if (this._controls) forEach(this._controls, function(control) { // kill old controls
      control._kill();
    });

    // reset variables

    this._arguments = [];
    this._errors = [];
    this._controls = [];
    this._index = 0;

    return seq;
  },

  _done: function(index, error, data) {
    this._arguments[index] = data;
    if (error) this._errors.push(error);
    if (!--this._length) {
      var errors = null;
      if (this._errors.length === 1) errors = this._errors[0];
      else if (this._errors.length) errors = new Error(map(this._errors, function(e) {
        return e.message;
      }).join('\n'));
      this._continue.apply(this, [errors].concat(this._arguments));
    }
    else this._controls[index]._kill();
  }

});

/* control the flow */
var Controller = function Controller(flow, index) {

  var dead;

  this._kill = function() {
    dead = true;
  };

  /* break the flow */
  this.break = function() {
    if (!dead) flow._break.apply(flow, arguments);
  };

  /* step in the next sequential */
  this.continue = function() {
    if (!dead) flow._continue.apply(flow, arguments);
  };

  /* spread results to the next sequential */
  this.spread = function(error, args) {
    if (!dead) flow._spread(error, args);
  };

  /* set the the current parallel in the sequential as complete */
  var done = this.done = function(error, data) {
    if (!dead) flow._done.call(flow, index, error, data);
  };

};

/* public interface */
module.exports = function() {
  var flow = new Flow();
  flow.then.apply(flow, arguments);
  return flow;
};

},{"mout/array/forEach":274,"mout/array/map":275,"mout/array/reduce":276,"mout/array/slice":277,"mout/collection/forEach":278,"mout/collection/map":280,"mout/lang/kindOf":288,"prime":295}],274:[function(require,module,exports){


    /**
     * Array forEach
     */
    function forEach(arr, callback, thisObj) {
        if (arr == null) {
            return;
        }
        var i = -1,
            len = arr.length;
        while (++i < len) {
            // we iterate over sparse items since there is no way to make it
            // work properly on IE 7-8. see #64
            if ( callback.call(thisObj, arr[i], i, arr) === false ) {
                break;
            }
        }
    }

    module.exports = forEach;



},{}],275:[function(require,module,exports){
var makeIterator = require('../function/makeIterator_');

    /**
     * Array map
     */
    function map(arr, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        var results = [];
        if (arr == null){
            return results;
        }

        var i = -1, len = arr.length;
        while (++i < len) {
            results[i] = callback(arr[i], i, arr);
        }

        return results;
    }

     module.exports = map;


},{"../function/makeIterator_":282}],276:[function(require,module,exports){


    /**
     * Array reduce
     */
    function reduce(arr, fn, initVal) {
        // check for args.length since initVal might be "undefined" see #gh-57
        var hasInit = arguments.length > 2,
            result = initVal;

        if (arr == null || !arr.length) {
            if (!hasInit) {
                throw new Error('reduce of empty array with no initial value');
            } else {
                return initVal;
            }
        }

        var i = -1, len = arr.length;
        while (++i < len) {
            if (!hasInit) {
                result = arr[i];
                hasInit = true;
            } else {
                result = fn(result, arr[i], i, arr);
            }
        }

        return result;
    }

    module.exports = reduce;


},{}],277:[function(require,module,exports){


    /**
     * Create slice of source array or array-like object
     */
    function slice(arr, start, end){
        var len = arr.length;

        if (start == null) {
            start = 0;
        } else if (start < 0) {
            start = Math.max(len + start, 0);
        } else {
            start = Math.min(start, len);
        }

        if (end == null) {
            end = len;
        } else if (end < 0) {
            end = Math.max(len + end, 0);
        } else {
            end = Math.min(end, len);
        }

        var result = [];
        while (start < end) {
            result.push(arr[start++]);
        }

        return result;
    }

    module.exports = slice;



},{}],278:[function(require,module,exports){
var make = require('./make_');
var arrForEach = require('../array/forEach');
var objForEach = require('../object/forOwn');

    /**
     */
    module.exports = make(arrForEach, objForEach);



},{"../array/forEach":274,"../object/forOwn":291,"./make_":279}],279:[function(require,module,exports){
var slice = require('../array/slice');

    /**
     * internal method used to create other collection modules.
     */
    function makeCollectionMethod(arrMethod, objMethod, defaultReturn) {
        return function(){
            var args = slice(arguments);
            if (args[0] == null) {
                return defaultReturn;
            }
            // array-like is treated as array
            return (typeof args[0].length === 'number')? arrMethod.apply(null, args) : objMethod.apply(null, args);
        };
    }

    module.exports = makeCollectionMethod;



},{"../array/slice":277}],280:[function(require,module,exports){
var isObject = require('../lang/isObject');
var values = require('../object/values');
var arrMap = require('../array/map');
var makeIterator = require('../function/makeIterator_');

    /**
     * Map collection values, returns Array.
     */
    function map(list, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        // list.length to check array-like object, if not array-like
        // we simply map all the object values
        if( isObject(list) && list.length == null ){
            list = values(list);
        }
        return arrMap(list, function (val, key, list) {
            return callback(val, key, list);
        });
    }

    module.exports = map;



},{"../array/map":275,"../function/makeIterator_":282,"../lang/isObject":287,"../object/values":294}],281:[function(require,module,exports){


    /**
     * Returns the first argument provided to it.
     */
    function identity(val){
        return val;
    }

    module.exports = identity;



},{}],282:[function(require,module,exports){
var identity = require('./identity');
var prop = require('./prop');
var deepMatches = require('../object/deepMatches');

    /**
     * Converts argument into a valid iterator.
     * Used internally on most array/object/collection methods that receives a
     * callback/iterator providing a shortcut syntax.
     */
    function makeIterator(src, thisObj){
        if (src == null) {
            return identity;
        }
        switch(typeof src) {
            case 'function':
                // function is the first to improve perf (most common case)
                // also avoid using `Function#call` if not needed, which boosts
                // perf a lot in some cases
                return (typeof thisObj !== 'undefined')? function(val, i, arr){
                    return src.call(thisObj, val, i, arr);
                } : src;
            case 'object':
                return function(val){
                    return deepMatches(val, src);
                };
            case 'string':
            case 'number':
                return prop(src);
        }
    }

    module.exports = makeIterator;



},{"../object/deepMatches":289,"./identity":281,"./prop":283}],283:[function(require,module,exports){


    /**
     * Returns a function that gets a property of the passed object
     */
    function prop(name){
        return function(obj){
            return obj[name];
        };
    }

    module.exports = prop;



},{}],284:[function(require,module,exports){
var mixIn = require('../object/mixIn');

    /**
     * Create Object using prototypal inheritance and setting custom properties.
     * - Mix between Douglas Crockford Prototypal Inheritance <http://javascript.crockford.com/prototypal.html> and the EcmaScript 5 `Object.create()` method.
     * @param {object} parent    Parent Object.
     * @param {object} [props] Object properties.
     * @return {object} Created object.
     */
    function createObject(parent, props){
        function F(){}
        F.prototype = parent;
        return mixIn(new F(), props);

    }
    module.exports = createObject;



},{"../object/mixIn":293}],285:[function(require,module,exports){
var isKind = require('./isKind');
    /**
     */
    var isArray = Array.isArray || function (val) {
        return isKind(val, 'Array');
    };
    module.exports = isArray;


},{"./isKind":286}],286:[function(require,module,exports){
var kindOf = require('./kindOf');
    /**
     * Check if value is from a specific "kind".
     */
    function isKind(val, kind){
        return kindOf(val) === kind;
    }
    module.exports = isKind;


},{"./kindOf":288}],287:[function(require,module,exports){
var isKind = require('./isKind');
    /**
     */
    function isObject(val) {
        return isKind(val, 'Object');
    }
    module.exports = isObject;


},{"./isKind":286}],288:[function(require,module,exports){


    var _rKind = /^\[object (.*)\]$/,
        _toString = Object.prototype.toString,
        UNDEF;

    /**
     * Gets the "kind" of value. (e.g. "String", "Number", etc)
     */
    function kindOf(val) {
        if (val === null) {
            return 'Null';
        } else if (val === UNDEF) {
            return 'Undefined';
        } else {
            return _rKind.exec( _toString.call(val) )[1];
        }
    }
    module.exports = kindOf;


},{}],289:[function(require,module,exports){
var forOwn = require('./forOwn');
var isArray = require('../lang/isArray');

    function containsMatch(array, pattern) {
        var i = -1, length = array.length;
        while (++i < length) {
            if (deepMatches(array[i], pattern)) {
                return true;
            }
        }

        return false;
    }

    function matchArray(target, pattern) {
        var i = -1, patternLength = pattern.length;
        while (++i < patternLength) {
            if (!containsMatch(target, pattern[i])) {
                return false;
            }
        }

        return true;
    }

    function matchObject(target, pattern) {
        var result = true;
        forOwn(pattern, function(val, key) {
            if (!deepMatches(target[key], val)) {
                // Return false to break out of forOwn early
                return (result = false);
            }
        });

        return result;
    }

    /**
     * Recursively check if the objects match.
     */
    function deepMatches(target, pattern){
        if (target && typeof target === 'object') {
            if (isArray(target) && isArray(pattern)) {
                return matchArray(target, pattern);
            } else {
                return matchObject(target, pattern);
            }
        } else {
            return target === pattern;
        }
    }

    module.exports = deepMatches;



},{"../lang/isArray":285,"./forOwn":291}],290:[function(require,module,exports){
var hasOwn = require('./hasOwn');

    var _hasDontEnumBug,
        _dontEnums;

    function checkDontEnum(){
        _dontEnums = [
                'toString',
                'toLocaleString',
                'valueOf',
                'hasOwnProperty',
                'isPrototypeOf',
                'propertyIsEnumerable',
                'constructor'
            ];

        _hasDontEnumBug = true;

        for (var key in {'toString': null}) {
            _hasDontEnumBug = false;
        }
    }

    /**
     * Similar to Array/forEach but works over object properties and fixes Don't
     * Enum bug on IE.
     * based on: http://whattheheadsaid.com/2010/10/a-safer-object-keys-compatibility-implementation
     */
    function forIn(obj, fn, thisObj){
        var key, i = 0;
        // no need to check if argument is a real object that way we can use
        // it for arrays, functions, date, etc.

        //post-pone check till needed
        if (_hasDontEnumBug == null) checkDontEnum();

        for (key in obj) {
            if (exec(fn, obj, key, thisObj) === false) {
                break;
            }
        }


        if (_hasDontEnumBug) {
            var ctor = obj.constructor,
                isProto = !!ctor && obj === ctor.prototype;

            while (key = _dontEnums[i++]) {
                // For constructor, if it is a prototype object the constructor
                // is always non-enumerable unless defined otherwise (and
                // enumerated above).  For non-prototype objects, it will have
                // to be defined on this object, since it cannot be defined on
                // any prototype objects.
                //
                // For other [[DontEnum]] properties, check if the value is
                // different than Object prototype value.
                if (
                    (key !== 'constructor' ||
                        (!isProto && hasOwn(obj, key))) &&
                    obj[key] !== Object.prototype[key]
                ) {
                    if (exec(fn, obj, key, thisObj) === false) {
                        break;
                    }
                }
            }
        }
    }

    function exec(fn, obj, key, thisObj){
        return fn.call(thisObj, obj[key], key, obj);
    }

    module.exports = forIn;



},{"./hasOwn":292}],291:[function(require,module,exports){
var hasOwn = require('./hasOwn');
var forIn = require('./forIn');

    /**
     * Similar to Array/forEach but works over object properties and fixes Don't
     * Enum bug on IE.
     * based on: http://whattheheadsaid.com/2010/10/a-safer-object-keys-compatibility-implementation
     */
    function forOwn(obj, fn, thisObj){
        forIn(obj, function(val, key){
            if (hasOwn(obj, key)) {
                return fn.call(thisObj, obj[key], key, obj);
            }
        });
    }

    module.exports = forOwn;



},{"./forIn":290,"./hasOwn":292}],292:[function(require,module,exports){


    /**
     * Safer Object.hasOwnProperty
     */
     function hasOwn(obj, prop){
         return Object.prototype.hasOwnProperty.call(obj, prop);
     }

     module.exports = hasOwn;



},{}],293:[function(require,module,exports){
var forOwn = require('./forOwn');

    /**
    * Combine properties from all the objects into first one.
    * - This method affects target object in place, if you want to create a new Object pass an empty object as first param.
    * @param {object} target    Target Object
    * @param {...object} objects    Objects to be combined (0...n objects).
    * @return {object} Target Object.
    */
    function mixIn(target, objects){
        var i = 0,
            n = arguments.length,
            obj;
        while(++i < n){
            obj = arguments[i];
            if (obj != null) {
                forOwn(obj, copyProp, target);
            }
        }
        return target;
    }

    function copyProp(val, key){
        this[key] = val;
    }

    module.exports = mixIn;


},{"./forOwn":291}],294:[function(require,module,exports){
var forOwn = require('./forOwn');

    /**
     * Get object values
     */
    function values(obj) {
        var vals = [];
        forOwn(obj, function(val, key){
            vals.push(val);
        });
        return vals;
    }

    module.exports = values;



},{"./forOwn":291}],295:[function(require,module,exports){
/*
prime
 - prototypal inheritance
*/"use strict"

var hasOwn = require("mout/object/hasOwn"),
    mixIn  = require("mout/object/mixIn"),
    create = require("mout/lang/createObject"),
    kindOf = require("mout/lang/kindOf")

var hasDescriptors = true

try {
    Object.defineProperty({}, "~", {})
    Object.getOwnPropertyDescriptor({}, "~")
} catch (e){
    hasDescriptors = false
}

// we only need to be able to implement "toString" and "valueOf" in IE < 9
var hasEnumBug = !({valueOf: 0}).propertyIsEnumerable("valueOf"),
    buggy      = ["toString", "valueOf"]

var verbs = /^constructor|inherits|mixin$/

var implement = function(proto){
    var prototype = this.prototype

    for (var key in proto){
        if (key.match(verbs)) continue
        if (hasDescriptors){
            var descriptor = Object.getOwnPropertyDescriptor(proto, key)
            if (descriptor){
                Object.defineProperty(prototype, key, descriptor)
                continue
            }
        }
        prototype[key] = proto[key]
    }

    if (hasEnumBug) for (var i = 0; (key = buggy[i]); i++){
        var value = proto[key]
        if (value !== Object.prototype[key]) prototype[key] = value
    }

    return this
}

var prime = function(proto){

    if (kindOf(proto) === "Function") proto = {constructor: proto}

    var superprime = proto.inherits

    // if our nice proto object has no own constructor property
    // then we proceed using a ghosting constructor that all it does is
    // call the parent's constructor if it has a superprime, else an empty constructor
    // proto.constructor becomes the effective constructor
    var constructor = (hasOwn(proto, "constructor")) ? proto.constructor : (superprime) ? function(){
        return superprime.apply(this, arguments)
    } : function(){}

    if (superprime){

        mixIn(constructor, superprime)

        var superproto = superprime.prototype
        // inherit from superprime
        var cproto = constructor.prototype = create(superproto)

        // setting constructor.parent to superprime.prototype
        // because it's the shortest possible absolute reference
        constructor.parent = superproto
        cproto.constructor = constructor
    }

    if (!constructor.implement) constructor.implement = implement

    var mixins = proto.mixin
    if (mixins){
        if (kindOf(mixins) !== "Array") mixins = [mixins]
        for (var i = 0; i < mixins.length; i++) constructor.implement(create(mixins[i].prototype))
    }

    // implement proto and return constructor
    return constructor.implement(proto)

}

module.exports = prime

},{"mout/lang/createObject":284,"mout/lang/kindOf":288,"mout/object/hasOwn":292,"mout/object/mixIn":293}],296:[function(require,module,exports){
"use strict";
/*globals Handlebars: true */
var base = require("./handlebars/base");

// Each of these augment the Handlebars object. No need to setup here.
// (This is done to easily share code between commonjs and browse envs)
var SafeString = require("./handlebars/safe-string")["default"];
var Exception = require("./handlebars/exception")["default"];
var Utils = require("./handlebars/utils");
var runtime = require("./handlebars/runtime");

// For compatibility and usage outside of module systems, make the Handlebars object a namespace
var create = function() {
  var hb = new base.HandlebarsEnvironment();

  Utils.extend(hb, base);
  hb.SafeString = SafeString;
  hb.Exception = Exception;
  hb.Utils = Utils;

  hb.VM = runtime;
  hb.template = function(spec) {
    return runtime.template(spec, hb);
  };

  return hb;
};

var Handlebars = create();
Handlebars.create = create;

exports["default"] = Handlebars;
},{"./handlebars/base":297,"./handlebars/exception":298,"./handlebars/runtime":299,"./handlebars/safe-string":300,"./handlebars/utils":301}],297:[function(require,module,exports){
"use strict";
var Utils = require("./utils");
var Exception = require("./exception")["default"];

var VERSION = "1.3.0";
exports.VERSION = VERSION;var COMPILER_REVISION = 4;
exports.COMPILER_REVISION = COMPILER_REVISION;
var REVISION_CHANGES = {
  1: '<= 1.0.rc.2', // 1.0.rc.2 is actually rev2 but doesn't report it
  2: '== 1.0.0-rc.3',
  3: '== 1.0.0-rc.4',
  4: '>= 1.0.0'
};
exports.REVISION_CHANGES = REVISION_CHANGES;
var isArray = Utils.isArray,
    isFunction = Utils.isFunction,
    toString = Utils.toString,
    objectType = '[object Object]';

function HandlebarsEnvironment(helpers, partials) {
  this.helpers = helpers || {};
  this.partials = partials || {};

  registerDefaultHelpers(this);
}

exports.HandlebarsEnvironment = HandlebarsEnvironment;HandlebarsEnvironment.prototype = {
  constructor: HandlebarsEnvironment,

  logger: logger,
  log: log,

  registerHelper: function(name, fn, inverse) {
    if (toString.call(name) === objectType) {
      if (inverse || fn) { throw new Exception('Arg not supported with multiple helpers'); }
      Utils.extend(this.helpers, name);
    } else {
      if (inverse) { fn.not = inverse; }
      this.helpers[name] = fn;
    }
  },

  registerPartial: function(name, str) {
    if (toString.call(name) === objectType) {
      Utils.extend(this.partials,  name);
    } else {
      this.partials[name] = str;
    }
  }
};

function registerDefaultHelpers(instance) {
  instance.registerHelper('helperMissing', function(arg) {
    if(arguments.length === 2) {
      return undefined;
    } else {
      throw new Exception("Missing helper: '" + arg + "'");
    }
  });

  instance.registerHelper('blockHelperMissing', function(context, options) {
    var inverse = options.inverse || function() {}, fn = options.fn;

    if (isFunction(context)) { context = context.call(this); }

    if(context === true) {
      return fn(this);
    } else if(context === false || context == null) {
      return inverse(this);
    } else if (isArray(context)) {
      if(context.length > 0) {
        return instance.helpers.each(context, options);
      } else {
        return inverse(this);
      }
    } else {
      return fn(context);
    }
  });

  instance.registerHelper('each', function(context, options) {
    var fn = options.fn, inverse = options.inverse;
    var i = 0, ret = "", data;

    if (isFunction(context)) { context = context.call(this); }

    if (options.data) {
      data = createFrame(options.data);
    }

    if(context && typeof context === 'object') {
      if (isArray(context)) {
        for(var j = context.length; i<j; i++) {
          if (data) {
            data.index = i;
            data.first = (i === 0);
            data.last  = (i === (context.length-1));
          }
          ret = ret + fn(context[i], { data: data });
        }
      } else {
        for(var key in context) {
          if(context.hasOwnProperty(key)) {
            if(data) {
              data.key = key;
              data.index = i;
              data.first = (i === 0);
            }
            ret = ret + fn(context[key], {data: data});
            i++;
          }
        }
      }
    }

    if(i === 0){
      ret = inverse(this);
    }

    return ret;
  });

  instance.registerHelper('if', function(conditional, options) {
    if (isFunction(conditional)) { conditional = conditional.call(this); }

    // Default behavior is to render the positive path if the value is truthy and not empty.
    // The `includeZero` option may be set to treat the condtional as purely not empty based on the
    // behavior of isEmpty. Effectively this determines if 0 is handled by the positive path or negative.
    if ((!options.hash.includeZero && !conditional) || Utils.isEmpty(conditional)) {
      return options.inverse(this);
    } else {
      return options.fn(this);
    }
  });

  instance.registerHelper('unless', function(conditional, options) {
    return instance.helpers['if'].call(this, conditional, {fn: options.inverse, inverse: options.fn, hash: options.hash});
  });

  instance.registerHelper('with', function(context, options) {
    if (isFunction(context)) { context = context.call(this); }

    if (!Utils.isEmpty(context)) return options.fn(context);
  });

  instance.registerHelper('log', function(context, options) {
    var level = options.data && options.data.level != null ? parseInt(options.data.level, 10) : 1;
    instance.log(level, context);
  });
}

var logger = {
  methodMap: { 0: 'debug', 1: 'info', 2: 'warn', 3: 'error' },

  // State enum
  DEBUG: 0,
  INFO: 1,
  WARN: 2,
  ERROR: 3,
  level: 3,

  // can be overridden in the host environment
  log: function(level, obj) {
    if (logger.level <= level) {
      var method = logger.methodMap[level];
      if (typeof console !== 'undefined' && console[method]) {
        console[method].call(console, obj);
      }
    }
  }
};
exports.logger = logger;
function log(level, obj) { logger.log(level, obj); }

exports.log = log;var createFrame = function(object) {
  var obj = {};
  Utils.extend(obj, object);
  return obj;
};
exports.createFrame = createFrame;
},{"./exception":298,"./utils":301}],298:[function(require,module,exports){
"use strict";

var errorProps = ['description', 'fileName', 'lineNumber', 'message', 'name', 'number', 'stack'];

function Exception(message, node) {
  var line;
  if (node && node.firstLine) {
    line = node.firstLine;

    message += ' - ' + line + ':' + node.firstColumn;
  }

  var tmp = Error.prototype.constructor.call(this, message);

  // Unfortunately errors are not enumerable in Chrome (at least), so `for prop in tmp` doesn't work.
  for (var idx = 0; idx < errorProps.length; idx++) {
    this[errorProps[idx]] = tmp[errorProps[idx]];
  }

  if (line) {
    this.lineNumber = line;
    this.column = node.firstColumn;
  }
}

Exception.prototype = new Error();

exports["default"] = Exception;
},{}],299:[function(require,module,exports){
"use strict";
var Utils = require("./utils");
var Exception = require("./exception")["default"];
var COMPILER_REVISION = require("./base").COMPILER_REVISION;
var REVISION_CHANGES = require("./base").REVISION_CHANGES;

function checkRevision(compilerInfo) {
  var compilerRevision = compilerInfo && compilerInfo[0] || 1,
      currentRevision = COMPILER_REVISION;

  if (compilerRevision !== currentRevision) {
    if (compilerRevision < currentRevision) {
      var runtimeVersions = REVISION_CHANGES[currentRevision],
          compilerVersions = REVISION_CHANGES[compilerRevision];
      throw new Exception("Template was precompiled with an older version of Handlebars than the current runtime. "+
            "Please update your precompiler to a newer version ("+runtimeVersions+") or downgrade your runtime to an older version ("+compilerVersions+").");
    } else {
      // Use the embedded version info since the runtime doesn't know about this revision yet
      throw new Exception("Template was precompiled with a newer version of Handlebars than the current runtime. "+
            "Please update your runtime to a newer version ("+compilerInfo[1]+").");
    }
  }
}

exports.checkRevision = checkRevision;// TODO: Remove this line and break up compilePartial

function template(templateSpec, env) {
  if (!env) {
    throw new Exception("No environment passed to template");
  }

  // Note: Using env.VM references rather than local var references throughout this section to allow
  // for external users to override these as psuedo-supported APIs.
  var invokePartialWrapper = function(partial, name, context, helpers, partials, data) {
    var result = env.VM.invokePartial.apply(this, arguments);
    if (result != null) { return result; }

    if (env.compile) {
      var options = { helpers: helpers, partials: partials, data: data };
      partials[name] = env.compile(partial, { data: data !== undefined }, env);
      return partials[name](context, options);
    } else {
      throw new Exception("The partial " + name + " could not be compiled when running in runtime-only mode");
    }
  };

  // Just add water
  var container = {
    escapeExpression: Utils.escapeExpression,
    invokePartial: invokePartialWrapper,
    programs: [],
    program: function(i, fn, data) {
      var programWrapper = this.programs[i];
      if(data) {
        programWrapper = program(i, fn, data);
      } else if (!programWrapper) {
        programWrapper = this.programs[i] = program(i, fn);
      }
      return programWrapper;
    },
    merge: function(param, common) {
      var ret = param || common;

      if (param && common && (param !== common)) {
        ret = {};
        Utils.extend(ret, common);
        Utils.extend(ret, param);
      }
      return ret;
    },
    programWithDepth: env.VM.programWithDepth,
    noop: env.VM.noop,
    compilerInfo: null
  };

  return function(context, options) {
    options = options || {};
    var namespace = options.partial ? options : env,
        helpers,
        partials;

    if (!options.partial) {
      helpers = options.helpers;
      partials = options.partials;
    }
    var result = templateSpec.call(
          container,
          namespace, context,
          helpers,
          partials,
          options.data);

    if (!options.partial) {
      env.VM.checkRevision(container.compilerInfo);
    }

    return result;
  };
}

exports.template = template;function programWithDepth(i, fn, data /*, $depth */) {
  var args = Array.prototype.slice.call(arguments, 3);

  var prog = function(context, options) {
    options = options || {};

    return fn.apply(this, [context, options.data || data].concat(args));
  };
  prog.program = i;
  prog.depth = args.length;
  return prog;
}

exports.programWithDepth = programWithDepth;function program(i, fn, data) {
  var prog = function(context, options) {
    options = options || {};

    return fn(context, options.data || data);
  };
  prog.program = i;
  prog.depth = 0;
  return prog;
}

exports.program = program;function invokePartial(partial, name, context, helpers, partials, data) {
  var options = { partial: true, helpers: helpers, partials: partials, data: data };

  if(partial === undefined) {
    throw new Exception("The partial " + name + " could not be found");
  } else if(partial instanceof Function) {
    return partial(context, options);
  }
}

exports.invokePartial = invokePartial;function noop() { return ""; }

exports.noop = noop;
},{"./base":297,"./exception":298,"./utils":301}],300:[function(require,module,exports){
"use strict";
// Build out our basic SafeString type
function SafeString(string) {
  this.string = string;
}

SafeString.prototype.toString = function() {
  return "" + this.string;
};

exports["default"] = SafeString;
},{}],301:[function(require,module,exports){
"use strict";
/*jshint -W004 */
var SafeString = require("./safe-string")["default"];

var escape = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#x27;",
  "`": "&#x60;"
};

var badChars = /[&<>"'`]/g;
var possible = /[&<>"'`]/;

function escapeChar(chr) {
  return escape[chr] || "&amp;";
}

function extend(obj, value) {
  for(var key in value) {
    if(Object.prototype.hasOwnProperty.call(value, key)) {
      obj[key] = value[key];
    }
  }
}

exports.extend = extend;var toString = Object.prototype.toString;
exports.toString = toString;
// Sourced from lodash
// https://github.com/bestiejs/lodash/blob/master/LICENSE.txt
var isFunction = function(value) {
  return typeof value === 'function';
};
// fallback for older versions of Chrome and Safari
if (isFunction(/x/)) {
  isFunction = function(value) {
    return typeof value === 'function' && toString.call(value) === '[object Function]';
  };
}
var isFunction;
exports.isFunction = isFunction;
var isArray = Array.isArray || function(value) {
  return (value && typeof value === 'object') ? toString.call(value) === '[object Array]' : false;
};
exports.isArray = isArray;

function escapeExpression(string) {
  // don't escape SafeStrings, since they're already safe
  if (string instanceof SafeString) {
    return string.toString();
  } else if (!string && string !== 0) {
    return "";
  }

  // Force a string conversion as this will be done by the append regardless and
  // the regex test will do this transparently behind the scenes, causing issues if
  // an object's to string has escaped characters in it.
  string = "" + string;

  if(!possible.test(string)) { return string; }
  return string.replace(badChars, escapeChar);
}

exports.escapeExpression = escapeExpression;function isEmpty(value) {
  if (!value && value !== 0) {
    return true;
  } else if (isArray(value) && value.length === 0) {
    return true;
  } else {
    return false;
  }
}

exports.isEmpty = isEmpty;
},{"./safe-string":300}],302:[function(require,module,exports){
// Create a simple path alias to allow browserify to resolve
// the runtime on a supported path.
module.exports = require('./dist/cjs/handlebars.runtime');

},{"./dist/cjs/handlebars.runtime":296}],303:[function(require,module,exports){
module.exports = require("handlebars/runtime")["default"];

},{"handlebars/runtime":302}],304:[function(require,module,exports){
var indexOf = require('./indexOf');

    /**
     * Combines an array with all the items of another.
     * Does not allow duplicates and is case and type sensitive.
     */
    function combine(arr1, arr2) {
        if (arr2 == null) {
            return arr1;
        }

        var i = -1, len = arr2.length;
        while (++i < len) {
            if (indexOf(arr1, arr2[i]) === -1) {
                arr1.push(arr2[i]);
            }
        }

        return arr1;
    }
    module.exports = combine;


},{"./indexOf":310}],305:[function(require,module,exports){
var indexOf = require('./indexOf');

    /**
     * If array contains values.
     */
    function contains(arr, val) {
        return indexOf(arr, val) !== -1;
    }
    module.exports = contains;


},{"./indexOf":310}],306:[function(require,module,exports){
var unique = require('./unique');
var filter = require('./filter');
var some = require('./some');
var contains = require('./contains');
var slice = require('./slice');


    /**
     * Return a new Array with elements that aren't present in the other Arrays.
     */
    function difference(arr) {
        var arrs = slice(arguments, 1),
            result = filter(unique(arr), function(needle){
                return !some(arrs, function(haystack){
                    return contains(haystack, needle);
                });
            });
        return result;
    }

    module.exports = difference;



},{"./contains":305,"./filter":308,"./slice":314,"./some":315,"./unique":316}],307:[function(require,module,exports){
var makeIterator = require('../function/makeIterator_');

    /**
     * Array every
     */
    function every(arr, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        var result = true;
        if (arr == null) {
            return result;
        }

        var i = -1, len = arr.length;
        while (++i < len) {
            // we iterate over sparse items since there is no way to make it
            // work properly on IE 7-8. see #64
            if (!callback(arr[i], i, arr) ) {
                result = false;
                break;
            }
        }

        return result;
    }

    module.exports = every;


},{"../function/makeIterator_":318}],308:[function(require,module,exports){
var makeIterator = require('../function/makeIterator_');

    /**
     * Array filter
     */
    function filter(arr, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        var results = [];
        if (arr == null) {
            return results;
        }

        var i = -1, len = arr.length, value;
        while (++i < len) {
            value = arr[i];
            if (callback(value, i, arr)) {
                results.push(value);
            }
        }

        return results;
    }

    module.exports = filter;



},{"../function/makeIterator_":318}],309:[function(require,module,exports){
arguments[4][274][0].apply(exports,arguments)
},{"dup":274}],310:[function(require,module,exports){


    /**
     * Array.indexOf
     */
    function indexOf(arr, item, fromIndex) {
        fromIndex = fromIndex || 0;
        if (arr == null) {
            return -1;
        }

        var len = arr.length,
            i = fromIndex < 0 ? len + fromIndex : fromIndex;
        while (i < len) {
            // we iterate over sparse items since there is no way to make it
            // work properly on IE 7-8. see #64
            if (arr[i] === item) {
                return i;
            }

            i++;
        }

        return -1;
    }

    module.exports = indexOf;


},{}],311:[function(require,module,exports){
var unique = require('./unique');
var filter = require('./filter');
var every = require('./every');
var contains = require('./contains');
var slice = require('./slice');


    /**
     * Return a new Array with elements common to all Arrays.
     * - based on underscore.js implementation
     */
    function intersection(arr) {
        var arrs = slice(arguments, 1),
            result = filter(unique(arr), function(needle){
                return every(arrs, function(haystack){
                    return contains(haystack, needle);
                });
            });
        return result;
    }

    module.exports = intersection;



},{"./contains":305,"./every":307,"./filter":308,"./slice":314,"./unique":316}],312:[function(require,module,exports){
arguments[4][275][0].apply(exports,arguments)
},{"../function/makeIterator_":318,"dup":275}],313:[function(require,module,exports){
var indexOf = require('./indexOf');

    /**
     * Remove a single item from the array.
     * (it won't remove duplicates, just a single item)
     */
    function remove(arr, item){
        var idx = indexOf(arr, item);
        if (idx !== -1) arr.splice(idx, 1);
    }

    module.exports = remove;


},{"./indexOf":310}],314:[function(require,module,exports){
arguments[4][277][0].apply(exports,arguments)
},{"dup":277}],315:[function(require,module,exports){
var makeIterator = require('../function/makeIterator_');

    /**
     * Array some
     */
    function some(arr, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        var result = false;
        if (arr == null) {
            return result;
        }

        var i = -1, len = arr.length;
        while (++i < len) {
            // we iterate over sparse items since there is no way to make it
            // work properly on IE 7-8. see #64
            if ( callback(arr[i], i, arr) ) {
                result = true;
                break;
            }
        }

        return result;
    }

    module.exports = some;


},{"../function/makeIterator_":318}],316:[function(require,module,exports){
var filter = require('./filter');

    /**
     * @return {array} Array of unique items
     */
    function unique(arr, compare){
        compare = compare || isEqual;
        return filter(arr, function(item, i, arr){
            var n = arr.length;
            while (++i < n) {
                if ( compare(item, arr[i]) ) {
                    return false;
                }
            }
            return true;
        });
    }

    function isEqual(a, b){
        return a === b;
    }

    module.exports = unique;



},{"./filter":308}],317:[function(require,module,exports){
arguments[4][281][0].apply(exports,arguments)
},{"dup":281}],318:[function(require,module,exports){
arguments[4][282][0].apply(exports,arguments)
},{"../object/deepMatches":328,"./identity":317,"./prop":319,"dup":282}],319:[function(require,module,exports){
arguments[4][283][0].apply(exports,arguments)
},{"dup":283}],320:[function(require,module,exports){
arguments[4][284][0].apply(exports,arguments)
},{"../object/mixIn":334,"dup":284}],321:[function(require,module,exports){
arguments[4][285][0].apply(exports,arguments)
},{"./isKind":322,"dup":285}],322:[function(require,module,exports){
arguments[4][286][0].apply(exports,arguments)
},{"./kindOf":326,"dup":286}],323:[function(require,module,exports){
var isKind = require('./isKind');
    /**
     */
    function isNumber(val) {
        return isKind(val, 'Number');
    }
    module.exports = isNumber;


},{"./isKind":322}],324:[function(require,module,exports){


    /**
     * Checks if the value is created by the `Object` constructor.
     */
    function isPlainObject(value) {
        return (!!value && typeof value === 'object' &&
            value.constructor === Object);
    }

    module.exports = isPlainObject;



},{}],325:[function(require,module,exports){
var isKind = require('./isKind');
    /**
     */
    function isRegExp(val) {
        return isKind(val, 'RegExp');
    }
    module.exports = isRegExp;


},{"./isKind":322}],326:[function(require,module,exports){
arguments[4][288][0].apply(exports,arguments)
},{"dup":288}],327:[function(require,module,exports){


    /**
     * Typecast a value to a String, using an empty string value for null or
     * undefined.
     */
    function toString(val){
        return val == null ? '' : val.toString();
    }

    module.exports = toString;



},{}],328:[function(require,module,exports){
arguments[4][289][0].apply(exports,arguments)
},{"../lang/isArray":321,"./forOwn":331,"dup":289}],329:[function(require,module,exports){
var forOwn = require('./forOwn');
var isPlainObject = require('../lang/isPlainObject');

    /**
     * Mixes objects into the target object, recursively mixing existing child
     * objects.
     */
    function deepMixIn(target, objects) {
        var i = 0,
            n = arguments.length,
            obj;

        while(++i < n){
            obj = arguments[i];
            if (obj) {
                forOwn(obj, copyProp, target);
            }
        }

        return target;
    }

    function copyProp(val, key) {
        var existing = this[key];
        if (isPlainObject(val) && isPlainObject(existing)) {
            deepMixIn(existing, val);
        } else {
            this[key] = val;
        }
    }

    module.exports = deepMixIn;



},{"../lang/isPlainObject":324,"./forOwn":331}],330:[function(require,module,exports){
arguments[4][290][0].apply(exports,arguments)
},{"./hasOwn":332,"dup":290}],331:[function(require,module,exports){
arguments[4][291][0].apply(exports,arguments)
},{"./forIn":330,"./hasOwn":332,"dup":291}],332:[function(require,module,exports){
arguments[4][292][0].apply(exports,arguments)
},{"dup":292}],333:[function(require,module,exports){
var forOwn = require('./forOwn');

    /**
     * Get object keys
     */
     var keys = Object.keys || function (obj) {
            var keys = [];
            forOwn(obj, function(val, key){
                keys.push(key);
            });
            return keys;
        };

    module.exports = keys;



},{"./forOwn":331}],334:[function(require,module,exports){
arguments[4][293][0].apply(exports,arguments)
},{"./forOwn":331,"dup":293}],335:[function(require,module,exports){
var slice = require('../array/slice');

    /**
     * Return a copy of the object, filtered to only have values for the whitelisted keys.
     */
    function pick(obj, var_keys){
        var keys = typeof arguments[1] !== 'string'? arguments[1] : slice(arguments, 1),
            out = {},
            i = 0, key;
        while (key = keys[i++]) {
            out[key] = obj[key];
        }
        return out;
    }

    module.exports = pick;



},{"../array/slice":314}],336:[function(require,module,exports){

    /**
     * Contains all Unicode white-spaces. Taken from
     * http://en.wikipedia.org/wiki/Whitespace_character.
     */
    module.exports = [
        ' ', '\n', '\r', '\t', '\f', '\v', '\u00A0', '\u1680', '\u180E',
        '\u2000', '\u2001', '\u2002', '\u2003', '\u2004', '\u2005', '\u2006',
        '\u2007', '\u2008', '\u2009', '\u200A', '\u2028', '\u2029', '\u202F',
        '\u205F', '\u3000'
    ];


},{}],337:[function(require,module,exports){
var toString = require('../lang/toString');

    /**
     * Escape RegExp string chars.
     */
    function escapeRegExp(str) {
        return toString(str).replace(/\W/g,'\\$&');
    }

    module.exports = escapeRegExp;



},{"../lang/toString":327}],338:[function(require,module,exports){
var toString = require('../lang/toString');
var WHITE_SPACES = require('./WHITE_SPACES');
    /**
     * Remove chars from beginning of string.
     */
    function ltrim(str, chars) {
        str = toString(str);
        chars = chars || WHITE_SPACES;

        var start = 0,
            len = str.length,
            charLen = chars.length,
            found = true,
            i, c;

        while (found && start < len) {
            found = false;
            i = -1;
            c = str.charAt(start);

            while (++i < charLen) {
                if (c === chars[i]) {
                    found = true;
                    start++;
                    break;
                }
            }
        }

        return (start >= len) ? '' : str.substr(start, len);
    }

    module.exports = ltrim;


},{"../lang/toString":327,"./WHITE_SPACES":336}],339:[function(require,module,exports){
var toString = require('../lang/toString');
var WHITE_SPACES = require('./WHITE_SPACES');
    /**
     * Remove chars from end of string.
     */
    function rtrim(str, chars) {
        str = toString(str);
        chars = chars || WHITE_SPACES;

        var end = str.length - 1,
            charLen = chars.length,
            found = true,
            i, c;

        while (found && end >= 0) {
            found = false;
            i = -1;
            c = str.charAt(end);

            while (++i < charLen) {
                if (c === chars[i]) {
                    found = true;
                    end--;
                    break;
                }
            }
        }

        return (end >= 0) ? str.substring(0, end + 1) : '';
    }

    module.exports = rtrim;


},{"../lang/toString":327,"./WHITE_SPACES":336}],340:[function(require,module,exports){
var toString = require('../lang/toString');
var WHITE_SPACES = require('./WHITE_SPACES');
var ltrim = require('./ltrim');
var rtrim = require('./rtrim');
    /**
     * Remove white-spaces from beginning and end of string.
     */
    function trim(str, chars) {
        str = toString(str);
        chars = chars || WHITE_SPACES;
        return ltrim(rtrim(str, chars), chars);
    }

    module.exports = trim;


},{"../lang/toString":327,"./WHITE_SPACES":336,"./ltrim":338,"./rtrim":339}],341:[function(require,module,exports){


    /**
     * Get current time in miliseconds
     */
    function now(){
        // yes, we defer the work to another function to allow mocking it
        // during the tests
        return now.get();
    }

    now.get = (typeof Date.now === 'function')? Date.now : function(){
        return +(new Date());
    };

    module.exports = now;



},{}],342:[function(require,module,exports){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} options
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options){
  options = options || {};
  if ('string' == typeof val) return parse(val);
  return options.long
    ? long(val)
    : short(val);
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = '' + str;
  if (str.length > 10000) return;
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
  if (!match) return;
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function short(ms) {
  if (ms >= d) return Math.round(ms / d) + 'd';
  if (ms >= h) return Math.round(ms / h) + 'h';
  if (ms >= m) return Math.round(ms / m) + 'm';
  if (ms >= s) return Math.round(ms / s) + 's';
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function long(ms) {
  return plural(ms, d, 'day')
    || plural(ms, h, 'hour')
    || plural(ms, m, 'minute')
    || plural(ms, s, 'second')
    || ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) return;
  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
  return Math.ceil(ms / n) + ' ' + name + 's';
}

},{}],343:[function(require,module,exports){
(function (process,global){
/*
defer
*/"use strict"

var kindOf  = require("mout/lang/kindOf"),
    now     = require("mout/time/now"),
    forEach = require("mout/array/forEach"),
    indexOf = require("mout/array/indexOf")

var callbacks = {
    timeout: {},
    frame: [],
    immediate: []
}

var push = function(collection, callback, context, defer){

    var iterator = function(){
        iterate(collection)
    }

    if (!collection.length) defer(iterator)

    var entry = {
        callback: callback,
        context: context
    }

    collection.push(entry)

    return function(){
        var io = indexOf(collection, entry)
        if (io > -1) collection.splice(io, 1)
    }
}

var iterate = function(collection){
    var time = now()

    forEach(collection.splice(0), function(entry) {
        entry.callback.call(entry.context, time)
    })
}

var defer = function(callback, argument, context){
    return (kindOf(argument) === "Number") ? defer.timeout(callback, argument, context) : defer.immediate(callback, argument)
}

if (global.process && process.nextTick){

    defer.immediate = function(callback, context){
        return push(callbacks.immediate, callback, context, process.nextTick)
    }

} else if (global.setImmediate){

    defer.immediate = function(callback, context){
        return push(callbacks.immediate, callback, context, setImmediate)
    }

} else if (global.postMessage && global.addEventListener){

    addEventListener("message", function(event){
        if (event.source === global && event.data === "@deferred"){
            event.stopPropagation()
            iterate(callbacks.immediate)
        }
    }, true)

    defer.immediate = function(callback, context){
        return push(callbacks.immediate, callback, context, function(){
            postMessage("@deferred", "*")
        })
    }

} else {

    defer.immediate = function(callback, context){
        return push(callbacks.immediate, callback, context, function(iterator){
            setTimeout(iterator, 0)
        })
    }

}

var requestAnimationFrame = global.requestAnimationFrame ||
    global.webkitRequestAnimationFrame ||
    global.mozRequestAnimationFrame ||
    global.oRequestAnimationFrame ||
    global.msRequestAnimationFrame ||
    function(callback) {
        setTimeout(callback, 1e3 / 60)
    }

defer.frame = function(callback, context){
    return push(callbacks.frame, callback, context, requestAnimationFrame)
}

var clear

defer.timeout = function(callback, ms, context){
    var ct = callbacks.timeout

    if (!clear) clear = defer.immediate(function(){
        clear = null
        callbacks.timeout = {}
    })

    return push(ct[ms] || (ct[ms] = []), callback, context, function(iterator){
        setTimeout(iterator, ms)
    })
}

module.exports = defer

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"_process":347,"mout/array/forEach":309,"mout/array/indexOf":310,"mout/lang/kindOf":326,"mout/time/now":341}],344:[function(require,module,exports){
/*
Emitter
*/"use strict"

var indexOf = require("mout/array/indexOf"),
    forEach = require("mout/array/forEach")

var prime = require("./index"),
    defer = require("./defer")

var slice = Array.prototype.slice;

var Emitter = prime({

    constructor: function(stoppable){
        this._stoppable = stoppable
    },

    on: function(event, fn){
        var listeners = this._listeners || (this._listeners = {}),
            events = listeners[event] || (listeners[event] = [])

        if (indexOf(events, fn) === -1) events.push(fn)

        return this
    },

    off: function(event, fn){
        var listeners = this._listeners, events
        if (listeners && (events = listeners[event])){

            var io = indexOf(events, fn)
            if (io > -1) events.splice(io, 1)
            if (!events.length) delete listeners[event];
            for (var l in listeners) return this
            delete this._listeners
        }
        return this
    },

    emit: function(event){
        var self = this,
            args = slice.call(arguments, 1)

        var emit = function(){
            var listeners = self._listeners, events
            if (listeners && (events = listeners[event])){
                forEach(events.slice(0), function(event){
                    var result = event.apply(self, args)
                    if (self._stoppable) return result
                })
            }
        }

        if (args[args.length - 1] === Emitter.EMIT_SYNC){
            args.pop()
            emit()
        } else {
            defer(emit)
        }

        return this
    }

})

Emitter.EMIT_SYNC = {}

module.exports = Emitter

},{"./defer":343,"./index":345,"mout/array/forEach":309,"mout/array/indexOf":310}],345:[function(require,module,exports){
arguments[4][295][0].apply(exports,arguments)
},{"dup":295,"mout/lang/createObject":320,"mout/lang/kindOf":326,"mout/object/hasOwn":332,"mout/object/mixIn":334}],346:[function(require,module,exports){
/*
Map
*/"use strict"

var indexOf = require("mout/array/indexOf")

var prime = require("./index")

var Map = prime({

    constructor: function Map(){
        this.length = 0
        this._values = []
        this._keys = []
    },

    set: function(key, value){
        var index = indexOf(this._keys, key)

        if (index === -1){
            this._keys.push(key)
            this._values.push(value)
            this.length++
        } else {
            this._values[index] = value
        }

        return this
    },

    get: function(key){
        var index = indexOf(this._keys, key)
        return (index === -1) ? null : this._values[index]
    },

    count: function(){
        return this.length
    },

    forEach: function(method, context){
        for (var i = 0, l = this.length; i < l; i++){
            if (method.call(context, this._values[i], this._keys[i], this) === false) break
        }
        return this
    },

    map: function(method, context){
        var results = new Map
        this.forEach(function(value, key){
            results.set(key, method.call(context, value, key, this))
        }, this)
        return results
    },

    filter: function(method, context){
        var results = new Map
        this.forEach(function(value, key){
            if (method.call(context, value, key, this)) results.set(key, value)
        }, this)
        return results
    },

    every: function(method, context){
        var every = true
        this.forEach(function(value, key){
            if (!method.call(context, value, key, this)) return (every = false)
        }, this)
        return every
    },

    some: function(method, context){
        var some = false
        this.forEach(function(value, key){
            if (method.call(context, value, key, this)) return !(some = true)
        }, this)
        return some
    },

    indexOf: function(value){
        var index = indexOf(this._values, value)
        return (index > -1) ? this._keys[index] : null
    },

    remove: function(value){
        var index = indexOf(this._values, value)

        if (index !== -1){
            this._values.splice(index, 1)
            this.length--
            return this._keys.splice(index, 1)[0]
        }

        return null
    },

    unset: function(key){
        var index = indexOf(this._keys, key)

        if (index !== -1){
            this._keys.splice(index, 1)
            this.length--
            return this._values.splice(index, 1)[0]
        }

        return null
    },

    keys: function(){
        return this._keys.slice()
    },

    values: function(){
        return this._values.slice()
    }

})

var map = function(){
    return new Map
}

map.prototype = Map.prototype

module.exports = map

},{"./index":345,"mout/array/indexOf":310}],347:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],348:[function(require,module,exports){
/*
Slick Finder
*/"use strict"

// Notable changes from Slick.Finder 1.0.x

// faster bottom -> up expression matching
// prefers mental sanity over *obsessive compulsive* milliseconds savings
// uses prototypes instead of objects
// tries to use matchesSelector smartly, whenever available
// can populate objects as well as arrays
// lots of stuff is broken or not implemented

var parse = require("./parser")

// utilities

var index = 0,
    counter = document.__counter = (parseInt(document.__counter || -1, 36) + 1).toString(36),
    key = "uid:" + counter

var uniqueID = function(n, xml){
    if (n === window) return "window"
    if (n === document) return "document"
    if (n === document.documentElement) return "html"

    if (xml) {
        var uid = n.getAttribute(key)
        if (!uid) {
            uid = (index++).toString(36)
            n.setAttribute(key, uid)
        }
        return uid
    } else {
        return n[key] || (n[key] = (index++).toString(36))
    }
}

var uniqueIDXML = function(n) {
    return uniqueID(n, true)
}

var isArray = Array.isArray || function(object){
    return Object.prototype.toString.call(object) === "[object Array]"
}

// tests

var uniqueIndex = 0;

var HAS = {

    GET_ELEMENT_BY_ID: function(test, id){
        id = "slick_" + (uniqueIndex++);
        // checks if the document has getElementById, and it works
        test.innerHTML = '<a id="' + id + '"></a>'
        return !!this.getElementById(id)
    },

    QUERY_SELECTOR: function(test){
        // this supposedly fixes a webkit bug with matchesSelector / querySelector & nth-child
        test.innerHTML = '_<style>:nth-child(2){}</style>'

        // checks if the document has querySelectorAll, and it works
        test.innerHTML = '<a class="MiX"></a>'

        return test.querySelectorAll('.MiX').length === 1
    },

    EXPANDOS: function(test, id){
        id = "slick_" + (uniqueIndex++);
        // checks if the document has elements that support expandos
        test._custom_property_ = id
        return test._custom_property_ === id
    },

    // TODO: use this ?

    // CHECKED_QUERY_SELECTOR: function(test){
    //
    //     // checks if the document supports the checked query selector
    //     test.innerHTML = '<select><option selected="selected">a</option></select>'
    //     return test.querySelectorAll(':checked').length === 1
    // },

    // TODO: use this ?

    // EMPTY_ATTRIBUTE_QUERY_SELECTOR: function(test){
    //
    //     // checks if the document supports the empty attribute query selector
    //     test.innerHTML = '<a class=""></a>'
    //     return test.querySelectorAll('[class*=""]').length === 1
    // },

    MATCHES_SELECTOR: function(test){

        test.className = "MiX"

        // checks if the document has matchesSelector, and we can use it.

        var matches = test.matchesSelector || test.mozMatchesSelector || test.webkitMatchesSelector

        // if matchesSelector trows errors on incorrect syntax we can use it
        if (matches) try {
            matches.call(test, ':slick')
        } catch(e){
            // just as a safety precaution, also test if it works on mixedcase (like querySelectorAll)
            return matches.call(test, ".MiX") ? matches : false
        }

        return false
    },

    GET_ELEMENTS_BY_CLASS_NAME: function(test){
        test.innerHTML = '<a class="f"></a><a class="b"></a>'
        if (test.getElementsByClassName('b').length !== 1) return false

        test.firstChild.className = 'b'
        if (test.getElementsByClassName('b').length !== 2) return false

        // Opera 9.6 getElementsByClassName doesnt detects the class if its not the first one
        test.innerHTML = '<a class="a"></a><a class="f b a"></a>'
        if (test.getElementsByClassName('a').length !== 2) return false

        // tests passed
        return true
    },

    // no need to know

    // GET_ELEMENT_BY_ID_NOT_NAME: function(test, id){
    //     test.innerHTML = '<a name="'+ id +'"></a><b id="'+ id +'"></b>'
    //     return this.getElementById(id) !== test.firstChild
    // },

    // this is always checked for and fixed

    // STAR_GET_ELEMENTS_BY_TAG_NAME: function(test){
    //
    //     // IE returns comment nodes for getElementsByTagName('*') for some documents
    //     test.appendChild(this.createComment(''))
    //     if (test.getElementsByTagName('*').length > 0) return false
    //
    //     // IE returns closed nodes (EG:"</foo>") for getElementsByTagName('*') for some documents
    //     test.innerHTML = 'foo</foo>'
    //     if (test.getElementsByTagName('*').length) return false
    //
    //     // tests passed
    //     return true
    // },

    // this is always checked for and fixed

    // STAR_QUERY_SELECTOR: function(test){
    //
    //     // returns closed nodes (EG:"</foo>") for querySelector('*') for some documents
    //     test.innerHTML = 'foo</foo>'
    //     return !!(test.querySelectorAll('*').length)
    // },

    GET_ATTRIBUTE: function(test){
        // tests for working getAttribute implementation
        var shout = "fus ro dah"
        test.innerHTML = '<a class="' + shout + '"></a>'
        return test.firstChild.getAttribute('class') === shout
    }

}

// Finder

var Finder = function Finder(document){

    this.document        = document
    var root = this.root = document.documentElement
    this.tested          = {}

    // uniqueID

    this.uniqueID = this.has("EXPANDOS") ? uniqueID : uniqueIDXML

    // getAttribute

    this.getAttribute = (this.has("GET_ATTRIBUTE")) ? function(node, name){

        return node.getAttribute(name)

    } : function(node, name){

        node = node.getAttributeNode(name)
        return (node && node.specified) ? node.value : null

    }

    // hasAttribute

    this.hasAttribute = (root.hasAttribute) ? function(node, attribute){

        return node.hasAttribute(attribute)

    } : function(node, attribute) {

        node = node.getAttributeNode(attribute)
        return !!(node && node.specified)

    }

    // contains

    this.contains = (document.contains && root.contains) ? function(context, node){

        return context.contains(node)

    } : (root.compareDocumentPosition) ? function(context, node){

        return context === node || !!(context.compareDocumentPosition(node) & 16)

    } : function(context, node){

        do {
            if (node === context) return true
        } while ((node = node.parentNode))

        return false
    }

    // sort
    // credits to Sizzle (http://sizzlejs.com/)

    this.sorter = (root.compareDocumentPosition) ? function(a, b){

        if (!a.compareDocumentPosition || !b.compareDocumentPosition) return 0
        return a.compareDocumentPosition(b) & 4 ? -1 : a === b ? 0 : 1

    } : ('sourceIndex' in root) ? function(a, b){

        if (!a.sourceIndex || !b.sourceIndex) return 0
        return a.sourceIndex - b.sourceIndex

    } : (document.createRange) ? function(a, b){

        if (!a.ownerDocument || !b.ownerDocument) return 0
        var aRange = a.ownerDocument.createRange(),
            bRange = b.ownerDocument.createRange()

        aRange.setStart(a, 0)
        aRange.setEnd(a, 0)
        bRange.setStart(b, 0)
        bRange.setEnd(b, 0)
        return aRange.compareBoundaryPoints(Range.START_TO_END, bRange)

    } : null

    this.failed = {}

    var nativeMatches = this.has("MATCHES_SELECTOR")

    if (nativeMatches) this.matchesSelector = function(node, expression){

        if (this.failed[expression]) return null

        try {
            return nativeMatches.call(node, expression)
        } catch(e){
            if (slick.debug) console.warn("matchesSelector failed on " + expression)
            this.failed[expression] = true
            return null
        }

    }

    if (this.has("QUERY_SELECTOR")){

        this.querySelectorAll = function(node, expression){

            if (this.failed[expression]) return true

            var result, _id, _expression, _combinator, _node


            // non-document rooted QSA
            // credits to Andrew Dupont

            if (node !== this.document){

                _combinator = expression[0].combinator

                _id         = node.getAttribute("id")
                _expression = expression

                if (!_id){
                    _node = node
                    _id = "__slick__"
                    _node.setAttribute("id", _id)
                }

                expression = "#" + _id + " " + _expression


                // these combinators need a parentNode due to how querySelectorAll works, which is:
                // finding all the elements that match the given selector
                // then filtering by the ones that have the specified element as an ancestor
                if (_combinator.indexOf("~") > -1 || _combinator.indexOf("+") > -1){

                    node = node.parentNode
                    if (!node) result = true
                    // if node has no parentNode, we return "true" as if it failed, without polluting the failed cache

                }

            }

            if (!result) try {
                result = node.querySelectorAll(expression.toString())
            } catch(e){
                if (slick.debug) console.warn("querySelectorAll failed on " + (_expression || expression))
                result = this.failed[_expression || expression] = true
            }

            if (_node) _node.removeAttribute("id")

            return result

        }

    }

}

Finder.prototype.has = function(FEATURE){

    var tested        = this.tested,
        testedFEATURE = tested[FEATURE]

    if (testedFEATURE != null) return testedFEATURE

    var root     = this.root,
        document = this.document,
        testNode = document.createElement("div")

    testNode.setAttribute("style", "display: none;")

    root.appendChild(testNode)

    var TEST = HAS[FEATURE], result = false

    if (TEST) try {
        result = TEST.call(document, testNode)
    } catch(e){}

    if (slick.debug && !result) console.warn("document has no " + FEATURE)

    root.removeChild(testNode)

    return tested[FEATURE] = result

}

var combinators = {

    " ": function(node, part, push){

        var item, items

        var noId = !part.id, noTag = !part.tag, noClass = !part.classes

        if (part.id && node.getElementById && this.has("GET_ELEMENT_BY_ID")){
            item = node.getElementById(part.id)

            // return only if id is found, else keep checking
            // might be a tad slower on non-existing ids, but less insane

            if (item && item.getAttribute('id') === part.id){
                items = [item]
                noId = true
                // if tag is star, no need to check it in match()
                if (part.tag === "*") noTag = true
            }
        }

        if (!items){

            if (part.classes && node.getElementsByClassName && this.has("GET_ELEMENTS_BY_CLASS_NAME")){
                items = node.getElementsByClassName(part.classList)
                noClass = true
                // if tag is star, no need to check it in match()
                if (part.tag === "*") noTag = true
            } else {
                items = node.getElementsByTagName(part.tag)
                // if tag is star, need to check it in match because it could select junk, boho
                if (part.tag !== "*") noTag = true
            }

            if (!items || !items.length) return false

        }

        for (var i = 0; item = items[i++];)
            if ((noTag && noId && noClass && !part.attributes && !part.pseudos) || this.match(item, part, noTag, noId, noClass))
                push(item)

        return true

    },

    ">": function(node, part, push){ // direct children
        if ((node = node.firstChild)) do {
            if (node.nodeType == 1 && this.match(node, part)) push(node)
        } while ((node = node.nextSibling))
    },

    "+": function(node, part, push){ // next sibling
        while ((node = node.nextSibling)) if (node.nodeType == 1){
            if (this.match(node, part)) push(node)
            break
        }
    },

    "^": function(node, part, push){ // first child
        node = node.firstChild
        if (node){
            if (node.nodeType === 1){
                if (this.match(node, part)) push(node)
            } else {
                combinators['+'].call(this, node, part, push)
            }
        }
    },

    "~": function(node, part, push){ // next siblings
        while ((node = node.nextSibling)){
            if (node.nodeType === 1 && this.match(node, part)) push(node)
        }
    },

    "++": function(node, part, push){ // next sibling and previous sibling
        combinators['+'].call(this, node, part, push)
        combinators['!+'].call(this, node, part, push)
    },

    "~~": function(node, part, push){ // next siblings and previous siblings
        combinators['~'].call(this, node, part, push)
        combinators['!~'].call(this, node, part, push)
    },

    "!": function(node, part, push){ // all parent nodes up to document
        while ((node = node.parentNode)) if (node !== this.document && this.match(node, part)) push(node)
    },

    "!>": function(node, part, push){ // direct parent (one level)
        node = node.parentNode
        if (node !== this.document && this.match(node, part)) push(node)
    },

    "!+": function(node, part, push){ // previous sibling
        while ((node = node.previousSibling)) if (node.nodeType == 1){
            if (this.match(node, part)) push(node)
            break
        }
    },

    "!^": function(node, part, push){ // last child
        node = node.lastChild
        if (node){
            if (node.nodeType == 1){
                if (this.match(node, part)) push(node)
            } else {
                combinators['!+'].call(this, node, part, push)
            }
        }
    },

    "!~": function(node, part, push){ // previous siblings
        while ((node = node.previousSibling)){
            if (node.nodeType === 1 && this.match(node, part)) push(node)
        }
    }

}

Finder.prototype.search = function(context, expression, found){

    if (!context) context = this.document
    else if (!context.nodeType && context.document) context = context.document

    var expressions = parse(expression)

    // no expressions were parsed. todo: is this really necessary?
    if (!expressions || !expressions.length) throw new Error("invalid expression")

    if (!found) found = []

    var uniques, push = isArray(found) ? function(node){
        found[found.length] = node
    } : function(node){
        found[found.length++] = node
    }

    // if there is more than one expression we need to check for duplicates when we push to found
    // this simply saves the old push and wraps it around an uid dupe check.
    if (expressions.length > 1){
        uniques = {}
        var plush = push
        push = function(node){
            var uid = uniqueID(node)
            if (!uniques[uid]){
                uniques[uid] = true
                plush(node)
            }
        }
    }

    // walker

    var node, nodes, part

    main: for (var i = 0; expression = expressions[i++];){

        // querySelector

        // TODO: more functional tests

        // if there is querySelectorAll (and the expression does not fail) use it.
        if (!slick.noQSA && this.querySelectorAll){

            nodes = this.querySelectorAll(context, expression)
            if (nodes !== true){
                if (nodes && nodes.length) for (var j = 0; node = nodes[j++];) if (node.nodeName > '@'){
                    push(node)
                }
                continue main
            }
        }

        // if there is only one part in the expression we don't need to check each part for duplicates.
        // todo: this might be too naive. while solid, there can be expression sequences that do not
        // produce duplicates. "body div" for instance, can never give you each div more than once.
        // "body div a" on the other hand might.
        if (expression.length === 1){

            part = expression[0]
            combinators[part.combinator].call(this, context, part, push)

        } else {

            var cs = [context], c, f, u, p = function(node){
                var uid = uniqueID(node)
                if (!u[uid]){
                    u[uid] = true
                    f[f.length] = node
                }
            }

            // loop the expression parts
            for (var j = 0; part = expression[j++];){
                f = []; u = {}
                // loop the contexts
                for (var k = 0; c = cs[k++];) combinators[part.combinator].call(this, c, part, p)
                // nothing was found, the expression failed, continue to the next expression.
                if (!f.length) continue main
                cs = f // set the contexts for future parts (if any)
            }

            if (i === 0) found = f // first expression. directly set found.
            else for (var l = 0; l < f.length; l++) push(f[l]) // any other expression needs to push to found.
        }

    }

    if (uniques && found && found.length > 1) this.sort(found)

    return found

}

Finder.prototype.sort = function(nodes){
    return this.sorter ? Array.prototype.sort.call(nodes, this.sorter) : nodes
}

// TODO: most of these pseudo selectors include <html> and qsa doesnt. fixme.

var pseudos = {


    // TODO: returns different results than qsa empty.

    'empty': function(){
        return !(this && this.nodeType === 1) && !(this.innerText || this.textContent || '').length
    },

    'not': function(expression){
        return !slick.matches(this, expression)
    },

    'contains': function(text){
        return (this.innerText || this.textContent || '').indexOf(text) > -1
    },

    'first-child': function(){
        var node = this
        while ((node = node.previousSibling)) if (node.nodeType == 1) return false
        return true
    },

    'last-child': function(){
        var node = this
        while ((node = node.nextSibling)) if (node.nodeType == 1) return false
        return true
    },

    'only-child': function(){
        var prev = this
        while ((prev = prev.previousSibling)) if (prev.nodeType == 1) return false

        var next = this
        while ((next = next.nextSibling)) if (next.nodeType == 1) return false

        return true
    },

    'first-of-type': function(){
        var node = this, nodeName = node.nodeName
        while ((node = node.previousSibling)) if (node.nodeName == nodeName) return false
        return true
    },

    'last-of-type': function(){
        var node = this, nodeName = node.nodeName
        while ((node = node.nextSibling)) if (node.nodeName == nodeName) return false
        return true
    },

    'only-of-type': function(){
        var prev = this, nodeName = this.nodeName
        while ((prev = prev.previousSibling)) if (prev.nodeName == nodeName) return false
        var next = this
        while ((next = next.nextSibling)) if (next.nodeName == nodeName) return false
        return true
    },

    'enabled': function(){
        return !this.disabled
    },

    'disabled': function(){
        return this.disabled
    },

    'checked': function(){
        return this.checked || this.selected
    },

    'selected': function(){
        return this.selected
    },

    'focus': function(){
        var doc = this.ownerDocument
        return doc.activeElement === this && (this.href || this.type || slick.hasAttribute(this, 'tabindex'))
    },

    'root': function(){
        return (this === this.ownerDocument.documentElement)
    }

}

Finder.prototype.match = function(node, bit, noTag, noId, noClass){

    // TODO: more functional tests ?

    if (!slick.noQSA && this.matchesSelector){
        var matches = this.matchesSelector(node, bit)
        if (matches !== null) return matches
    }

    // normal matching

    if (!noTag && bit.tag){

        var nodeName = node.nodeName.toLowerCase()
        if (bit.tag === "*"){
            if (nodeName < "@") return false
        } else if (nodeName != bit.tag){
            return false
        }

    }

    if (!noId && bit.id && node.getAttribute('id') !== bit.id) return false

    var i, part

    if (!noClass && bit.classes){

        var className = this.getAttribute(node, "class")
        if (!className) return false

        for (part in bit.classes) if (!RegExp('(^|\\s)' + bit.classes[part] + '(\\s|$)').test(className)) return false
    }

    var name, value

    if (bit.attributes) for (i = 0; part = bit.attributes[i++];){

        var operator  = part.operator,
            escaped   = part.escapedValue

        name  = part.name
        value = part.value

        if (!operator){

            if (!this.hasAttribute(node, name)) return false

        } else {

            var actual = this.getAttribute(node, name)
            if (actual == null) return false

            switch (operator){
                case '^=' : if (!RegExp(      '^' + escaped            ).test(actual)) return false; break
                case '$=' : if (!RegExp(            escaped + '$'      ).test(actual)) return false; break
                case '~=' : if (!RegExp('(^|\\s)' + escaped + '(\\s|$)').test(actual)) return false; break
                case '|=' : if (!RegExp(      '^' + escaped + '(-|$)'  ).test(actual)) return false; break

                case '='  : if (actual !== value) return false; break
                case '*=' : if (actual.indexOf(value) === -1) return false; break
                default   : return false
            }

        }
    }

    if (bit.pseudos) for (i = 0; part = bit.pseudos[i++];){

        name  = part.name
        value = part.value

        if (pseudos[name]) return pseudos[name].call(node, value)

        if (value != null){
            if (this.getAttribute(node, name) !== value) return false
        } else {
            if (!this.hasAttribute(node, name)) return false
        }

    }

    return true

}

Finder.prototype.matches = function(node, expression){

    var expressions = parse(expression)

    if (expressions.length === 1 && expressions[0].length === 1){ // simplest match
        return this.match(node, expressions[0][0])
    }

    // TODO: more functional tests ?

    if (!slick.noQSA && this.matchesSelector){
        var matches = this.matchesSelector(node, expressions)
        if (matches !== null) return matches
    }

    var nodes = this.search(this.document, expression, {length: 0})

    for (var i = 0, res; res = nodes[i++];) if (node === res) return true
    return false

}

var finders = {}

var finder = function(context){
    var doc = context || document
    if (doc.ownerDocument) doc = doc.ownerDocument
    else if (doc.document) doc = doc.document

    if (doc.nodeType !== 9) throw new TypeError("invalid document")

    var uid = uniqueID(doc)
    return finders[uid] || (finders[uid] = new Finder(doc))
}

// ... API ...

var slick = function(expression, context){
    return slick.search(expression, context)
}

slick.search = function(expression, context, found){
    return finder(context).search(context, expression, found)
}

slick.find = function(expression, context){
    return finder(context).search(context, expression)[0] || null
}

slick.getAttribute = function(node, name){
    return finder(node).getAttribute(node, name)
}

slick.hasAttribute = function(node, name){
    return finder(node).hasAttribute(node, name)
}

slick.contains = function(context, node){
    return finder(context).contains(context, node)
}

slick.matches = function(node, expression){
    return finder(node).matches(node, expression)
}

slick.sort = function(nodes){
    if (nodes && nodes.length > 1) finder(nodes[0]).sort(nodes)
    return nodes
}

slick.parse = parse;

// slick.debug = true
// slick.noQSA  = true

module.exports = slick

},{"./parser":350}],349:[function(require,module,exports){
(function (global){
/*
slick
*/"use strict"

module.exports = "document" in global ? require("./finder") : { parse: require("./parser") }

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./finder":348,"./parser":350}],350:[function(require,module,exports){
/*
Slick Parser
 - originally created by the almighty Thomas Aylott <@subtlegradient> (http://subtlegradient.com)
*/"use strict"

// Notable changes from Slick.Parser 1.0.x

// The parser now uses 2 classes: Expressions and Expression
// `new Expressions` produces an array-like object containing a list of Expression objects
// - Expressions::toString() produces a cleaned up expressions string
// `new Expression` produces an array-like object
// - Expression::toString() produces a cleaned up expression string
// The only exposed method is parse, which produces a (cached) `new Expressions` instance
// parsed.raw is no longer present, use .toString()
// parsed.expression is now useless, just use the indices
// parsed.reverse() has been removed for now, due to its apparent uselessness
// Other changes in the Expressions object:
// - classNames are now unique, and save both escaped and unescaped values
// - attributes now save both escaped and unescaped values
// - pseudos now save both escaped and unescaped values

var escapeRe   = /([-.*+?^${}()|[\]\/\\])/g,
    unescapeRe = /\\/g

var escape = function(string){
    // XRegExp v2.0.0-beta-3
    // « https://github.com/slevithan/XRegExp/blob/master/src/xregexp.js
    return (string + "").replace(escapeRe, '\\$1')
}

var unescape = function(string){
    return (string + "").replace(unescapeRe, '')
}

var slickRe = RegExp(
/*
#!/usr/bin/env ruby
puts "\t\t" + DATA.read.gsub(/\(\?x\)|\s+#.*$|\s+|\\$|\\n/,'')
__END__
    "(?x)^(?:\
      \\s* ( , ) \\s*               # Separator          \n\
    | \\s* ( <combinator>+ ) \\s*   # Combinator         \n\
    |      ( \\s+ )                 # CombinatorChildren \n\
    |      ( <unicode>+ | \\* )     # Tag                \n\
    | \\#  ( <unicode>+       )     # ID                 \n\
    | \\.  ( <unicode>+       )     # ClassName          \n\
    |                               # Attribute          \n\
    \\[  \
        \\s* (<unicode1>+)  (?:  \
            \\s* ([*^$!~|]?=)  (?:  \
                \\s* (?:\
                    ([\"']?)(.*?)\\9 \
                )\
            )  \
        )?  \\s*  \
    \\](?!\\]) \n\
    |   :+ ( <unicode>+ )(?:\
    \\( (?:\
        (?:([\"'])([^\\12]*)\\12)|((?:\\([^)]+\\)|[^()]*)+)\
    ) \\)\
    )?\
    )"
*/
"^(?:\\s*(,)\\s*|\\s*(<combinator>+)\\s*|(\\s+)|(<unicode>+|\\*)|\\#(<unicode>+)|\\.(<unicode>+)|\\[\\s*(<unicode1>+)(?:\\s*([*^$!~|]?=)(?:\\s*(?:([\"']?)(.*?)\\9)))?\\s*\\](?!\\])|(:+)(<unicode>+)(?:\\((?:(?:([\"'])([^\\13]*)\\13)|((?:\\([^)]+\\)|[^()]*)+))\\))?)"
    .replace(/<combinator>/, '[' + escape(">+~`!@$%^&={}\\;</") + ']')
    .replace(/<unicode>/g, '(?:[\\w\\u00a1-\\uFFFF-]|\\\\[^\\s0-9a-f])')
    .replace(/<unicode1>/g, '(?:[:\\w\\u00a1-\\uFFFF-]|\\\\[^\\s0-9a-f])')
)

// Part

var Part = function Part(combinator){
    this.combinator = combinator || " "
    this.tag = "*"
}

Part.prototype.toString = function(){

    if (!this.raw){

        var xpr = "", k, part

        xpr += this.tag || "*"
        if (this.id) xpr += "#" + this.id
        if (this.classes) xpr += "." + this.classList.join(".")
        if (this.attributes) for (k = 0; part = this.attributes[k++];){
            xpr += "[" + part.name + (part.operator ? part.operator + '"' + part.value + '"' : '') + "]"
        }
        if (this.pseudos) for (k = 0; part = this.pseudos[k++];){
            xpr += ":" + part.name
            if (part.value) xpr += "(" + part.value + ")"
        }

        this.raw = xpr

    }

    return this.raw
}

// Expression

var Expression = function Expression(){
    this.length = 0
}

Expression.prototype.toString = function(){

    if (!this.raw){

        var xpr = ""

        for (var j = 0, bit; bit = this[j++];){
            if (j !== 1) xpr += " "
            if (bit.combinator !== " ") xpr += bit.combinator + " "
            xpr += bit
        }

        this.raw = xpr

    }

    return this.raw
}

var replacer = function(
    rawMatch,

    separator,
    combinator,
    combinatorChildren,

    tagName,
    id,
    className,

    attributeKey,
    attributeOperator,
    attributeQuote,
    attributeValue,

    pseudoMarker,
    pseudoClass,
    pseudoQuote,
    pseudoClassQuotedValue,
    pseudoClassValue
){

    var expression, current

    if (separator || !this.length){
        expression = this[this.length++] = new Expression
        if (separator) return ''
    }

    if (!expression) expression = this[this.length - 1]

    if (combinator || combinatorChildren || !expression.length){
        current = expression[expression.length++] = new Part(combinator)
    }

    if (!current) current = expression[expression.length - 1]

    if (tagName){

        current.tag = unescape(tagName)

    } else if (id){

        current.id = unescape(id)

    } else if (className){

        var unescaped = unescape(className)

        var classes = current.classes || (current.classes = {})
        if (!classes[unescaped]){
            classes[unescaped] = escape(className)
            var classList = current.classList || (current.classList = [])
            classList.push(unescaped)
            classList.sort()
        }

    } else if (pseudoClass){

        pseudoClassValue = pseudoClassValue || pseudoClassQuotedValue

        ;(current.pseudos || (current.pseudos = [])).push({
            type         : pseudoMarker.length == 1 ? 'class' : 'element',
            name         : unescape(pseudoClass),
            escapedName  : escape(pseudoClass),
            value        : pseudoClassValue ? unescape(pseudoClassValue) : null,
            escapedValue : pseudoClassValue ? escape(pseudoClassValue) : null
        })

    } else if (attributeKey){

        attributeValue = attributeValue ? escape(attributeValue) : null

        ;(current.attributes || (current.attributes = [])).push({
            operator     : attributeOperator,
            name         : unescape(attributeKey),
            escapedName  : escape(attributeKey),
            value        : attributeValue ? unescape(attributeValue) : null,
            escapedValue : attributeValue ? escape(attributeValue) : null
        })

    }

    return ''

}

// Expressions

var Expressions = function Expressions(expression){
    this.length = 0

    var self = this

    var original = expression, replaced

    while (expression){
        replaced = expression.replace(slickRe, function(){
            return replacer.apply(self, arguments)
        })
        if (replaced === expression) throw new Error(original + ' is an invalid expression')
        expression = replaced
    }
}

Expressions.prototype.toString = function(){
    if (!this.raw){
        var expressions = []
        for (var i = 0, expression; expression = this[i++];) expressions.push(expression)
        this.raw = expressions.join(", ")
    }

    return this.raw
}

var cache = {}

var parse = function(expression){
    if (expression == null) return null
    expression = ('' + expression).replace(/^\s+|\s+$/g, '')
    return cache[expression] || (cache[expression] = new Expressions(expression))
}

module.exports = parse

},{}],351:[function(require,module,exports){

/**
 * `Batch' constructor
 *
 * @api public
 * @param {Number} max - optional (Default: Infinity)
 */

module.exports = Batch;
function Batch (max) {
  if (!(this instanceof Batch)) {
    return new Batch(max);
  }

  var self = this;

  this.m = 0; // max
  this.c = 0; // concurrency
  this.jobs = [];

  this.concurrency(Infinity);
  this.max(max);

  Object.defineProperty(this, 'length', {
    get: function () {
      return self.jobs.length;
    }
  });
}

/**
 * Set batch concurrency
 *
 * @api public
 * @param {Number} n
 */

Batch.prototype.concurrency = function (n) {
  if (n > 0) {
    this.c = n;
  }
  return this;
};

/**
 * Set max job limit
 *
 * @api publc
 * @param {Number} n
 */

Batch.prototype.max = function (n) {
  this.m = 'number' == typeof n && n > 0 ? n : Infinity;
  return this;
};

/**
 * Push job onto queue
 *
 * @api publc
 * @param {Function} fn
 */

Batch.prototype.push = function (fn) {
  if ('function' != typeof fn) {
    throw new TypeError("expecting a function");
  } else if (this.length < this.m) {
    this.jobs.push(fn);
  }
  return this;
};

/**
 * Shift job off of queue
 *
 * @api public
 */

Batch.prototype.shift = function () {
  return this.jobs.shift();
};

/**
 * Dequeues all queued jobs
 *
 * @api public
 * @param {Function} done - optional
 */

Batch.prototype.run = function (done) {
  done = 'function' == typeof done ? done : Function();
  var self = this;
  var c = this.c;
  var i = 0;

  // empty queue
  if (0 == this.length) {
    return done(null);
  }

  function dequeue  () {
    var job = null;
    if (0 == self.length) {
      return false;
    }

    job = self.shift();

    if ('function' != typeof job) {
      return;
    }

    try { job(next); }
    catch (err) {
      done(err)
      return false;
    }

    function next (err) {
      if (err) {
        done(err);
      } else if (self.length) {
        dequeue();
      } else {
        done();
      }
    }
  }

  while (i++ < c) {
    if (false === dequeue()) {
      break;
    }
  }

  return this;
};

},{}],352:[function(require,module,exports){
/*jslint node: true */

'use strict';

var ClientRequest = require('./request').ClientRequest;

/**
 * An autoincremented id that is used to distinguish Resolver instances.
 *
 * @type {number}
 * @private
 */
var resolverUID = 0;

/**
 * A resolver takes a request for a resources and sends it through the
 * transport.
 *
 * @constructs Resolver
 */
function Resolver() {
  if (!(this instanceof Resolver))
    return new Resolver();

  /**
   * The resolver's id.
   *
   * @type {number}
   * @protected
   */
  this._id = resolverUID++;

  /**
   * An incrementing ID used for tracking requests.
   *
   * @type {number}
   * @protected
   */
  this._requestID = 0;

  /**
   * Storage for the sent request handlers waiting for a response.
   *
   * @type {Object.<string, function>}
   * @protected
   */
  this._handlers = {};
}
exports.Resolver = Resolver;

/**
 * Adds a handler to the internal storage.
 *
 * @param {number} requestID The identifier for the request.
 * @param {ClientRequest} handler The handler for the request.
 * @protected
 */
Resolver.prototype._addHandler = function(requestID, handler) {
  this._handlers[requestID] = handler;
  return this;
};

/**
 * Removes a handler from the internal storage.
 *
 * @param {number} requestID The identifier for the request.
 * @protected
 */
Resolver.prototype._removeHandler = function(requestID) {
  this._handlers[requestID] = null;
  return this;
};

/**
 * Sends a request through the transport.
 *
 * Subclasses of this class need to implement this method.
 *
 * @param {number} requestID The id of the request.
 * @param {Object} data The payload data for the request.
 * @protected
 */
Resolver.prototype._sendRequest = function(requestID, data) {
  throw new Error('Resolver _sendRequest not implemented.');
};

/**
 * Handles a response from the transport.
 *
 * @param {Object} response The response from the transport.
 * @protected
 */
Resolver.prototype._handleResponse = function(response) {
  throw new Error('Resolver _handleResponse not implemented.');
};

/**
 * Dispatches a request handler with some data.
 *
 * @param {number} requestID The request handler to dispatch.
 * @param {Object} data The response data to send back.
 * @protected
 */
Resolver.prototype._dispatchResponse = function(requestID, requestType, data) {
  var handler = this._handlers[requestID];
  if (!handler) return;
  handler._handleResponse(requestType, data);
};

/**
 * Resolves a request (represented by the data) through the transport.
 *
 * @param {Object} data The data representing the request.
 * @param {function} onsuccess The success handler for the request.
 * @param {function} onerror The error handler for the request.
 */
Resolver.prototype._resolve = function(data, onsuccess, onerror) {
  if (!data || !onsuccess || !onerror ||
      typeof onsuccess != 'function' || typeof onerror != 'function')
    throw new TypeError('Invalid argument length for `resolve`.');

  var requestID = ++this._requestID;
  var request = new ClientRequest(this, requestID, data, onsuccess, onerror);

  this._addHandler(requestID, request);

  request.onClose = this._removeHandler.bind(this);
  request.open();

  return request;
};

/**
 * Resolves a single request (represented by the data) through the transport.
 *
 * @param {Object} data The data representing the request.
 * @param {function} onsuccess The success handler for the request.
 * @param {function} onerror The error handler for the request.
 */
Resolver.prototype.resolve = function(data, onsuccess, onerror) {
  throw new Error('Resolver resolve not implemented.');
};

/**
 * Resolves a subscription request (represented by the data) through the transport.
 *
 * @param {Object} data The data representing the request.
 * @param {function} onsuccess The success handler for the request.
 * @param {function} onerror The error handler for the request.
 */
Resolver.prototype.subscribe = function(data, onsuccess, onerror) {
  throw new Error('Resolver subscribe not implemented.');
};

},{"./request":356}],353:[function(require,module,exports){
(function (global){
/*jslint node: true */

'use strict';

var defer = require('spotify-deferred');
var Resolver = require('./bootstrap').Resolver;

/**
 * A mock resolver for a nodejs environment.
 *
 * This resolver uses regular callbacks as a transport.
 *
 * @constructs Cosmos.MockResolver
 * @extends Cosmos.Resolver
 */
function MockResolver() {
  if (!(this instanceof MockResolver))
    return new MockResolver();
  Resolver.call(this);

  // rebind the _handleResponse method so that we can reuse it for both
  // addEventListener and removeEventListener
  this._handleResponse = this._handleResponse.bind(this);

  /**
   * The identifier for request messages.
   *
   * @type {string}
   * @protected
   */
  this._requestMessageType = 'cosmos-request';

  /**
   * The identifier for response messages.
   *
   * @type {string}
   * @protected
   */
  this._responseMessageType = 'cosmos-response';

  /**
   * Prefix for the requests ids to prevent clashes
   * with bridge requests in webplayer
   *
   * @type {string}
   * @private
   */
  this._requestIdPrefix = 'cosmos_';

  this._handlersMap = {};

  // attach the handler
  this.attach();
}
MockResolver.prototype = new Resolver();
MockResolver.prototype.constructor = MockResolver;
exports.MockResolver = MockResolver;

/**
 * @inheritDoc
 */
MockResolver.prototype._sendRequest = function(requestName, requestID, data) {
  var self = this;

  var message = {
    type: this._requestMessageType,
    resolver: this._id,
    id: this._requestIdPrefix + requestID,
    name: requestName,
    payload: data.serialize ? data.serialize() : data
  };

  if (!this._handlersMap[data._action]) {
    return;
  }

  if (!this._handlersMap[data._action][data._uri]) {
    return;
  }

  this._handlersMap[data._action][data._uri](data, function (status, resp) {
    message.payload = {
      body: typeof resp !== 'undefined' ? resp : status,
      uri: data._uri,
      status: typeof resp !== 'undefined' ? status : 200
    };
    message.type = self._responseMessageType;

    var response = {
      data: message
    };
    self._handleResponse(response);
  });
};

/**
 * @inheritDoc
 */
MockResolver.prototype._handleResponse = function(response) {
  var data = response.data;
  if (typeof data == 'string') {
    try {
      data = JSON.parse(response.data);
    } catch (e) {
      return;
    }
  }
  if (data.type != this._responseMessageType ||
      data.resolver != this._id ||
      !data.payload) return;
  var id = data.id || '';
  var requestID = parseInt(id.replace(this._requestIdPrefix, ''), 10);
  var requestName = data.name || '';
  if (!requestID || !requestName) return;
  this._dispatchResponse(requestID, requestName, data.payload);
};

/**
 * Attaches the resolver so that it could process calls from the window object.
 */
MockResolver.prototype.attach = function() {
  var win = global.window;
  if (win) {
    win._cosmosRequest = this.resolve.bind(this);
  }
};

/**
 * Detaches the resolver so that it doesn't process calls from the window object.
 */
MockResolver.prototype.detach = function() {
  var win = global.window;
  if (win) {
    delete win._cosmosRequest;
  }
};

/**
 * Specific method for the mock resolver to add request handlers
 *
 * @param {string}   method       Type of method (GET, POST, PUT, SUB)
 * @param {string}   uri          Request to handle
 * @param {Function} fn           Function that handles the request
 */
MockResolver.prototype.addHandler = function(method, uri, fn) {
  if (!this._handlersMap[method]) {
    this._handlersMap[method] = {};
  }

  this._handlersMap[method][uri] = fn;
};

/**
 * Specific method for the mock resolver to remove a specific request handler
 *
 * @param {string}   method       Type of method (GET, POST, PUT, SUB)
 * @param {string}   uri          Request to handle
 */
MockResolver.prototype.removeHandler = function(method, uri) {
  if (!this._handlersMap[method]) {
    return;
  }

  if (this._handlersMap[method][uri]) {
    delete this._handlersMap[method][uri];
  }
};

/**
 * Specific method for the mock resolver to remove all handlers
 */
MockResolver.prototype.clearHandlers = function() {
  this._handlersMap = {};
};

/**
 * Resolves a single request (represented by the data) through the transport.
 * Single requests need to be closed immediately after the response is
 * received.
 *
 * @param {Object} data The data representing the request.
 * @param {function} onsuccess The success handler for the request.
 * @param {function} onerror The error handler for the request.
 */
MockResolver.prototype.resolve = function(data, onsuccess, onerror) {
  function onResult(callback, response) {
    defer(callback.bind(this, response));
    request.close();
  }

  var request = this._resolve(data, onResult.bind(this, onsuccess), onResult.bind(this, onerror));
  return request;
};

/**
 * Resolves a  subscription request (represented by the data) through the transport.
 * Subscriptions stay open until they're explicitly closed.
 * Every time the request returns some data pull for next
 * batch is sent.
 *
 * @param {Object} data The data representing the request.
 * @param {function} onsuccess The success handler for the request.
 * @param {function} onerror The error handler for the request.
 */
MockResolver.prototype.subscribe = function(data, onsuccess, onerror) {
  return this._resolve(data, onsuccess, onerror);
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./bootstrap":352,"spotify-deferred":359}],354:[function(require,module,exports){
(function (global){
/*jslint node: true */

'use strict';

var SpotifyApi = global.SpotifyApi;
var useApiRequest = !!(SpotifyApi && SpotifyApi.api &&
    typeof SpotifyApi.api.request === 'function');

var Resolver = require('./bootstrap').Resolver;
var defer = require('spotify-deferred');

/**
 * A resolver for a native environment.
 *
 * This resolver uses the Stitch bridge as a transport
 *
 * @constructs Cosmos.NativeResolver
 * @extends Cosmos.Resolver
 * @param {Object} spBridge Spotify CPP/JS bridge
 */
function NativeResolver(spBridge) {
  if (!(this instanceof NativeResolver))
    return new NativeResolver();
  if (!spBridge) {
    throw new TypeError('Missing `spBridge` parameter');
  }
  Resolver.call(this);

  this._bridge = spBridge;

  this._deferredFlush = false;
}
NativeResolver.prototype = new Resolver();
NativeResolver.prototype.constructor = NativeResolver;
exports.NativeResolver = NativeResolver;

/**
 * Prepare bridge flush.
 * TODO: Move to the separate module
 */
NativeResolver.prototype._prepareCoreFlush = function() {
  if (!this._deferredFlush) {
    this._deferredFlush = true;
    this._defer(this, this._flushRequests);
  }
};

/**
 * Flush bridge requests.
 * TODO: Move to the separate module
 */
NativeResolver.prototype._flushRequests = function() {
  this._deferredFlush = false;
  var flushMsg = JSON.stringify({ name: 'core_flush', args: []});
  this._sendBridgeRequest(flushMsg, {
    onSuccess: function() {},
    onFailure: function() {}
  });
};

/**
 * Defer the function call.
 * TODO: Move to the separate module
 */
NativeResolver.prototype._defer = function(context, callback) {
  defer(callback.bind(context));
};

/**
 * If SpotifyApi is loaded, use api requests to send messages to bridge
 * TODO: Use proxy that will handle Cosmos/Stitch calls for the resolver.
 */
NativeResolver.prototype._sendRequest = function(requestName, requestId, data) {
  var self = this;
  data = (data.serialize ? data.serialize() : data);

  var args = [requestId, data];
  var caller = { self: this, id: requestId, type: requestName };

  if (useApiRequest) {
    this._sendApiRequest(requestName, args, caller, this._handleResponse, this._handleError);
  } else {
    this._sendCosmosRequest(requestName, args, caller, this._handleResponse, this._handleError);
  }
};


/**
 * Talk to bridge directly from Cosmos
 * TODO: Move to the separate module
 */
NativeResolver.prototype._sendCosmosRequest = function(requestName, args, caller, onSuccess, onError) {
  var message = JSON.stringify({
    name: requestName,
    args: args
  });

  this._sendBridgeRequest(message, {
    onSuccess: function(data) {
      onSuccess.call(caller, JSON.parse(data));
    },
    onFailure: function(data) {
      data = JSON.parse(data);
      onError.call(caller, data);
    }
  });

  this._prepareCoreFlush();
};

/**
 * Send message to the bridge
 * @param {string} message The message to send to the bridge.
 * @param {Object.<string, function>} callbackMap The `onSuccess`
 * and `onFailure` functions to be executed after request is completed.
 * TODO: Use proxy that will handle Cosmos/Stitch calls for the resolver.
 */
NativeResolver.prototype._sendBridgeRequest = function(message, callbackMap) {
  this._bridge.executeRequest(message, callbackMap || {});
};

/**
 * Use old API to send messages to the bridge.
 * TODO: Move to the separate module
 */
NativeResolver.prototype._sendApiRequest = function(requestName, args, caller, onSuccess, onError) {
  SpotifyApi.api.request(
      requestName,
      args,
      caller,
      onSuccess,
      onError
  );
};

/**
 * Handles successful responses from the bridge
 * @param {Object} data The response data.
 */
NativeResolver.prototype._handleResponse = function(data) {
  this.self._dispatchResponse(this.id, this.type, data.responses && data.responses[0] || data);
};

/**
 * Handles failed responses from the bridge
 * @param {Object} error The error data.
 */
NativeResolver.prototype._handleError = function(error) {
  this.self._dispatchResponse(this.id, this.type, error);
};

/**
 * Resolves a single request (represented by the data) through the transport.
 * Single requests need to be closed immediately after the response is
 * received.
 *
 * @param {Object} data The data representing the request.
 * @param {function} onsuccess The success handler for the request.
 * @param {function} onerror The error handler for the request.
 */
NativeResolver.prototype.resolve = function(data, onsuccess, onerror) {
  function onResult(callback, response) {
    this._defer(this, callback.bind(this, response));
    request.close();
  }

  var request = this._resolve(data, onResult.bind(this, onsuccess), onResult.bind(this, onerror));
  return request;
};

/**
 * Resolves a  subscription request (represented by the data) through the transport.
 * Subscriptions stay open until they're explicitly closed.
 * Every time the request returns some data pull for next
 * batch is sent.
 *
 * @param {Object} data The data representing the request.
 * @param {function} onsuccess The success handler for the request.
 * @param {function} onerror The error handler for the request.
 */
NativeResolver.prototype.subscribe = function(data, onsuccess, onerror) {
  function onResult(callback, response) {
    callback.call(this, response);
    request.pull();
  }

  var request = this._resolve(data, onResult.bind(this, onsuccess), onResult.bind(this, onerror));
  return request;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./bootstrap":352,"spotify-deferred":359}],355:[function(require,module,exports){
(function (global){
/*jslint node: true */

'use strict';

var defer = require('spotify-deferred');
var Resolver = require('./bootstrap').Resolver;

/**
 * A resolver for a web-based environment.
 *
 * This resolver uses postMessage as a transport.
 *
 * @constructs Cosmos.WebResolver
 * @extends Cosmos.Resolver
 * @type {string=} opt_target The optional target for the postMessage calls.
 */
function WebResolver(opt_target) {
  if (!(this instanceof WebResolver))
    return new WebResolver(opt_target);
  Resolver.call(this);

  /**
   * The target for postMessage calls.
   *
   * @type {string}
   * @protected
   */
  this._target = opt_target || '*';

  // rebind the _handleResponse method so that we can reuse it for both
  // addEventListener and removeEventListener
  this._handleResponse = this._handleResponse.bind(this);

  /**
   * The identifier for request messages.
   *
   * @type {string}
   * @protected
   */
  this._requestMessageType = 'cosmos-request';

  /**
   * The identifier for response messages.
   *
   * @type {string}
   * @protected
   */
  this._responseMessageType = 'cosmos-response';

  /**
   * Prefix for the requests ids to prevent clashes
   * with bridge requests in webplayer
   *
   * @type {string}
   * @private
   */
  this._requestIdPrefix = 'cosmos_';

  // attach the handler
  this.attach();
}
WebResolver.prototype = new Resolver();
WebResolver.prototype.constructor = WebResolver;
exports.WebResolver = WebResolver;

/**
 * @inheritDoc
 */
WebResolver.prototype._sendRequest = function(requestName, requestID, data) {
  var top = global.window.top;

  var message = {
    type: this._requestMessageType,
    resolver: this._id,
    id: this._requestIdPrefix + requestID,
    name: requestName,
    payload: data.serialize ? data.serialize() : data
  };
  top.postMessage(JSON.stringify(message), this._target);
};

/**
 * @inheritDoc
 */
WebResolver.prototype._handleResponse = function(response) {
  var data = response.data;
  if (typeof data == 'string') {
    try {
      data = JSON.parse(response.data);
    } catch (e) {
      return;
    }
  }
  if (data.type != this._responseMessageType ||
      data.resolver != this._id ||
      !data.payload) return;
  var id = data.id || '';
  var requestID = parseInt(id.replace(this._requestIdPrefix, ''), 10);
  var requestName = data.name || '';
  if (!requestID || !requestName) return;
  this._dispatchResponse(requestID, requestName, data.payload);
};

/**
 * Attaches the resolver so that it could process postMessage calls.
 */
WebResolver.prototype.attach = function() {
  var win = global.window;
  if (win.addEvent && !win.addEventListener) {
    win.addEvent('onmessage', this._handleResponse);
  } else {
    win.addEventListener('message', this._handleResponse, false);
  }
};

/**
 * Detaches the resolver so that it doesn't process postMessage calls.
 */
WebResolver.prototype.detach = function() {
  var win = global.window;
  if (win.removeEvent && !win.removeEventListener) {
    win.removeEvent('onmessage', this._handleResponse);
  } else {
    win.removeEventListener('message', this._handleResponse, false);
  }
};

/**
 * Resolves a single request (represented by the data) through the transport.
 * Single requests need to be closed immediately after the response is
 * received.
 *
 * @param {Object} data The data representing the request.
 * @param {function} onsuccess The success handler for the request.
 * @param {function} onerror The error handler for the request.
 */
WebResolver.prototype.resolve = function(data, onsuccess, onerror) {
  function onResult(callback, response) {
    defer(callback.bind(this, response));
    request.close();
  }

  var request = this._resolve(data, onResult.bind(this, onsuccess), onResult.bind(this, onerror));
  return request;
};

/**
 * Resolves a  subscription request (represented by the data) through the transport.
 * Subscriptions stay open until they're explicitly closed.
 * Every time the request returns some data pull for next
 * batch is sent.
 *
 * @param {Object} data The data representing the request.
 * @param {function} onsuccess The success handler for the request.
 * @param {function} onerror The error handler for the request.
 */
WebResolver.prototype.subscribe = function(data, onsuccess, onerror) {
  return this._resolve(data, onsuccess, onerror);
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./bootstrap":352,"spotify-deferred":359}],356:[function(require,module,exports){
/*jslint node: true */

'use strict';

var defer = require('spotify-deferred');

/**
 * The representation of the connection to the client.
 * With introduction of Cosmos subscription the model of making
 * client requests changed.
 * Each Cosmos requests now needs to be explicitly cancelled to
 * close the connection.
 * Simple requests that only send or retrieve data (e.g POST and GET)
 * need to send 'cosmos_request_cancel' message immediately after the response
 * is received.
 * Subscription requests need to send a 'cosmos_request_pull' message every time
 * they receive data. The consumer of the subscription needs to cancel the subscription
 * when no more data should be sent from the provider.
 */
function ClientRequest(resolver, requestId, data, onsuccess, onerror) {

  /**
   * Request identifier.
   * @type {number}
   */
  this._requestId = requestId;

  /**
   * Either web or native request resolver.
   * @type {Cosmos.Resolver}
   */
  this._resolver = resolver;

  /**
   * Data that should be passed with every request.
   * @type {*}
   */
  this._requestData = data;

  /**
   * Triggered on success
   * @type {function}
   */
  this._successCallback = onsuccess;

  /**
   * Triggered on error
   * @type {function}
   */
  this._errorCallback = onerror;

  /**
   * Current state of the request.
   * @type {ClientRequest.status}
   */
  this._status = ClientRequest.status.INITIALIZED;
}
exports.ClientRequest = ClientRequest;

/**
 * Possible state of the ClientRequest instance.
 */
ClientRequest.status = {
  INITIALIZED: 'INITIALIZED',
  CLOSED: 'CLOSED',
  OPEN: 'OPEN'
};

/**
 * Possible desktop bridge messages.
 */
ClientRequest.messages = {
  OPEN: 'cosmos_request_create',
  PULL: 'cosmos_request_pull',
  CLOSE: 'cosmos_request_cancel'
};

/**
 * Opens the connection with the client.
 */
ClientRequest.prototype.open = function() {
  if (this._status === ClientRequest.status.INITIALIZED) {
    this._status = ClientRequest.status.OPEN;
    this._sendRequest(ClientRequest.messages.OPEN, this._requestData);
  }
};

/**
 * Send pull request for the open connection.
 * For subscriptions pull should resolve to a
 * piece of data.
 */
ClientRequest.prototype.pull = function() {
  if (this._status === ClientRequest.status.OPEN) {
    this._sendRequest(ClientRequest.messages.PULL, this._requestData);
  }
  return this._status;
};

/**
 * Closes the connection with the client.
 */
ClientRequest.prototype.close = function() {
  if (this._status === ClientRequest.status.OPEN) {
    this._status = ClientRequest.status.CLOSE;
    this._sendRequest(ClientRequest.messages.CLOSE);
  }
};

ClientRequest.prototype.onClose = function() {};

/**
 * Sends the request to the platform specific resolver
 * @param {string} requestName The message type. One of the {ClientRequest.messages}.
 * @param {object?} data The data to send with the request.
 */
ClientRequest.prototype._sendRequest = function(requestName, data) {
  this._resolver._sendRequest(requestName, this._requestId, data || {});
};

/**
 * Handles the response for the given request
 * @param {String} requestName The message type. One of the {ClientRequest.messages}.
 * @param {Object} data The response data.
 */
ClientRequest.prototype._handleResponse = function(requestName, data) {
  var self = this;
  var status = data && data.status;
  var callback;

  if (requestName === ClientRequest.messages.CLOSE) {
    this._successCallback = null;
    this._errorCallback = null;
    this._requestData = null;
    this.onClose(this._requestId);
    return;
  }

  callback = this._successCallback;
  callback = typeof callback === 'function' ? callback : function() {};
  defer(callback.bind(this, data));
};

},{"spotify-deferred":359}],357:[function(require,module,exports){
(function (global){
'use strict';

var window = global.window || {};
var process = global.process;

var common = require('cosmos-common-js');
var Resolver = require('./scripts/resolver').Resolver;

var SPResolver = null;
var spResolver = null;

var hasNativeBridge = window._getSpotifyModule &&
    typeof window._getSpotifyModule === 'function' &&
    window._getSpotifyModule('bridge');

var nodeRegex = /(node)|(grunt)|(iojs)(\.exe)*$/;
var isNodeJs = process && process.title && nodeRegex.test(process.argv[0]);

if (!isNodeJs) {
  if (hasNativeBridge) {
    SPResolver = require('./env/bootstrap.native.js').NativeResolver;
    spResolver = new SPResolver(hasNativeBridge);
  } else {
    SPResolver = require('./env/bootstrap.web.js').WebResolver;
    spResolver = new SPResolver();
  }
} else {
  SPResolver = require('./env/bootstrap.mock.js').MockResolver;
  spResolver = new SPResolver();

  exports.mockResolver = {
    addHandler: spResolver.addHandler.bind(spResolver),
    removeHandler: spResolver.removeHandler.bind(spResolver),
    clearHandlers: spResolver.clearHandlers.bind(spResolver)
  };
}

exports.Resolver = Resolver;
exports.Action = common.request.Action;
exports.Request = common.request.Request;
exports.Response = common.response.Response;
exports.resolver = spResolver ? new Resolver(spResolver) : null;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./env/bootstrap.mock.js":353,"./env/bootstrap.native.js":354,"./env/bootstrap.web.js":355,"./scripts/resolver":360,"cosmos-common-js":263}],358:[function(require,module,exports){
/**
 * @file
 * Unified window messaging facility.
 *
 * This module exports two functions to the Spotify
 * namespace which allows other subsystems to handle
 * particular types of messages sent through the native
 * window.postMessage method.
 *
 * @see Spotify.addMessageHandler
 * @see Spotify.removeMessageHandler
 */
'use strict';

var POST_ROUTER_ID = 'post-router-msg-' + new Date().getTime();

var hasStructuredClone = false;

var setImmediate = setImmediate ? setImmediate : setTimeout;

var CURRENT_WINDOW_ORIGIN = undefined;

if (typeof window !== 'undefined') {
  CURRENT_WINDOW_ORIGIN = (window.location.origin ||
      window.location.protocol + '//' + window.location.hostname);

  // Hacky solution to make it work for the webplayer.
  if (!window.__forceNoStructuredClone) {
    // Check if the platform has support for structured cloning.
    //
    // In platforms where this is supported, sending a postMessage with an
    // object that contains a function will throw an error, as it is not
    // cloneable.
    try {
      window.postMessage({
        toString: function() {
          return "clone-test";
        }
      }, CURRENT_WINDOW_ORIGIN);
      hasStructuredClone = false;
    } catch(e) {
      hasStructuredClone = true;
    }
  }
}

/**
 * Storage for message handlers.
 *
 * @type {Object.<string, Spotify.Shell.MessageHandler>}
 * @private
 */
var handlers = {};


/**
 * Variable to check if the window is already listening to postMessage events
 *
 * @type {bool}
 * @private
 */
var isListening = false;


function handleImmediateMessage(data) {
  var handler = handlers[data.type];
  if (!handler) return;
  handler.fn.call(this, data);
}


/**
 * Main event handler for the window message event.
 *
 * @param {Event} event The message event object.
 * @private
 */
function handlePostMessage(event) {
  var data = event.data;
  if (!hasStructuredClone) {
    if (typeof data == 'string') {
      try {
        data = JSON.parse(data);
      } catch (e) {
        return;
      }
    } else {
      // We only expect strings.
      return;
    }
  }
  if (event.origin == CURRENT_WINDOW_ORIGIN) {
    data = data[POST_ROUTER_ID];
    if (!data) {
      // Not our data, return immediately.
      return;
    }
  }
  var handler = handlers[data.type];
  if (!handler || handler.origin != '*' && event.origin !== handler.origin) {
    return;
  }
  handler.fn.call(this, data, event);
}

/**
 * Attaches the handlePostMessage function to PostMessage events
 *
 * @private
 */
var startListening = function() {
  if (window.attachEvent && !window.addEventListener) {
    // IE8 and Below
    window.attachEvent('onmessage', handlePostMessage);
  } else if (window.attachEvent && window.addEventListener) {
    // IE9
    window.addEventListener('message', handlePostMessage, false);
  } else if (window.addEventListener) {
    // Everyone else
    window.addEventListener('message', handlePostMessage, false);
  }
};


/**
 * Adds a message handler for a particular message type.
 *
 * The message handler function will be invoked when the window receives
 * a message marked as a particular type, receiving an argument. The
 * argument will be the data payload of the event decoded from JSON.
 *
 * @param {string} type The type of the message to handle.
 * @param {function} fn The handler function.
 * @param {string} origin needed
 * @throws {Error} Thrown if the message type being handled already has
 *     a handler function.
 */
var addMessageHandler = function(type, fn, origin) {
  if (typeof window !== 'undefined' && !isListening) {
    startListening();
    isListening = true;
  }

  if (!origin) {
    origin = CURRENT_WINDOW_ORIGIN;
  }

  if (handlers[type]) {
    throw new Error('Rehandling of message "' + type + '" not allowed.');
  }
  handlers[type] = {
    fn: fn,
    origin: origin
  };
  return;
};


/**
 * Removes a message handler for a particular message type.
 *
 * @param {string} type The type of the message to remove.
 * @param {Spotify.Shell.MessageHandler} fn The handler function.
 * @return {boolean} True if the handler function was succesfully removed.
 */
var removeMessageHandler = function(type, fn) {
  if (handlers[type] && (!fn || handlers[type].fn === fn)) {
    handlers[type] = null;
    return true;
  }
  return false;
};


/**
 * Sends a message to the event handler
 *
 * @param {string} type The type of the message to remove.
 * @param {Object} data JSON object to pass to the handler
 */
var sendMessage = function(type, data, destWindow, origin) {
  data = data || {};
  data.type = type;

  if (typeof window === 'undefined') {
    return setImmediate(handleImmediateMessage.bind(null, data));
  }

  destWindow = destWindow || window;

  if (!origin) {
    origin = CURRENT_WINDOW_ORIGIN;
  }

  destWindow.postMessage(JSON.stringify(data), origin);
};

var sendLocalMessage = function(type, data) {
  data = data || {};
  data.type = type;

  if (typeof window === 'undefined') {
    return setImmediate(handleImmediateMessage.bind(null, data));
  }

  // Wrap the data in a custom object to quickly identify the message.
  var wrapper = {};
  wrapper[POST_ROUTER_ID] = data;

  window.postMessage(hasStructuredClone ?
                     wrapper :
                     JSON.stringify(wrapper), CURRENT_WINDOW_ORIGIN);
};


/**
 * Export public interface
 */
module.exports = {
  addMessageHandler: addMessageHandler,
  removeMessageHandler: removeMessageHandler,
  sendMessage: sendMessage,
  sendLocalMessage: sendLocalMessage,
  WINDOW_ORIGIN: CURRENT_WINDOW_ORIGIN
};

},{}],359:[function(require,module,exports){
/**
 * @file
 * Introduces a function called "defer" that allows functions to be
 * executed in the next available tick.
 *
 * Unlike "setTimeout", "defer" executes the function at the nearest
 * possible time without clamping.
 *
 * @see Spotify.defer
 */
'use strict';

var PostRouter = require('spotify-postrouter');


/**
 * Storage for deferred functions to be executed.
 *
 * @type {Array.<function()>}
 * @private
 */
var deferred = [];


/**
 * A bound version of the postMessage routine used to trigger deferred
 * execution.
 *
 * @type {function()}
 * @private
 */
var send = function () {
  PostRouter.sendLocalMessage('execute_deferreds');
};


/**
 * Executes the deferred functions when the window
 * receives an 'execute_deferreds' message.
 *
 * @private
 */
function executeDeferreds() {
  var fns = deferred.splice(0);
  if (!fns.length) return;
  for (var i = 0, l = fns.length; i < l; i++) {
    try {
      fns[i]();
    } finally {
      // Do nothing.
      null;
    }
  }
}

PostRouter.addMessageHandler('execute_deferreds', executeDeferreds);


/**
 * Executes the function applied at the nearest possible time without
 * clamping.
 *
 * @param {function()} fn The function to execute.
 */
var defer = function(fn) {
  var trigger = !deferred.length;
  deferred.push(fn);
  if (trigger) send();
};


/**
 * Export public interface
 */
module.exports = defer;

},{"spotify-postrouter":358}],360:[function(require,module,exports){
var common = require('cosmos-common-js');

var Request = common.request.Request;
var Action = common.request.Action;
var Response = common.response.Response;

/**
 * Checks whether a status is successful.
 *
 * We define a successful status to be something within the 200 to 299 range.
 *
 * @param {number} status The status to check.
 */
function _isSuccessStatus(status) {
  // This constitutes a successfull status.
  return (status >= 200 && status <= 299);
};


function Resolver(spResolver) {
  if (!spResolver || typeof spResolver.resolve !== 'function') {
    throw TypeError('Incorrect resolver argument');
  }

  this._resolver = spResolver;
}

/**
 * The basic, generic method of sending the requests.
 *
 * For params description:
 * @borrows Resolver#_resolve as Resolver#resolve
 */
Resolver.prototype.resolve = function(request, callback) {
  return this._resolve(request, callback);
};

/**
 * Convenience method for doing GET requests.
 * resolver.get('sp://player') is an equivalent of
 * resolver.resolve(new Request('GET', 'sp://player')).
 *
 * @param {string|Object.<string, object>} options If is a string
 * will be parsed as url. If more data is needed, object notation
 * should be used.
 *  param options.url {string} The url of the request.
 *  param options.body {object=} The request body.
 *  param options.headers {object=} The request headers.
 * @param {function(error=, object?)} callback The function
 * executed after the request has been completed.
 *
 * @return {RequestHandler} The cancellable request handler.
 */
Resolver.prototype.get = function(options, callback) {
  return this._resolveFromParams(Action.GET, options, callback);
};

/**
 * Convenience method for doing POST requests.
 * resolver.post('sp://player') is an equivalent of
 * resolver.resolve(new Request('POST', 'sp://player'))
 *
 * @see Resolver#get for params description and returned value.
 */
Resolver.prototype.post = function(options, callback) {
  return this._resolveFromParams(Action.POST, options, callback);
};

/**
 * Convenience method for doing SUB requests.
 * resolver.subscribe('sp://player') is an equivalent of
 * resolver.resolve(new Request('SUB', 'sp://player'))
 *
 * @see Resolver#get for params description and returned value.
 */
Resolver.prototype.subscribe = function(options, callback) {
  return this._resolveFromParams(Action.SUB, options, callback);
};

/**
 * Convenience method for doing PUT requests.
 * resolver.put('sp://ads/v1/settings/session') is an equivalent of
 * resolver.resolve(new Request('PUT', 'sp://ads/v1/settings/session'))
 *
 * @see Resolver#get for params description and returned value.
 */
Resolver.prototype.put = function(options, callback) {
  return this._resolveFromParams(Action.PUT, options, callback);
};

/**
 * Convenience method for doing PATCH requests.
 * resolver.patch('sp://ads/v1/settings/session') is an equivalent of
 * resolver.resolve(new Request('PATCH', 'sp://ads/v1/settings/session'))
 *
 * @see Resolver#get for params description and returned value.
 */
Resolver.prototype.patch = function(options, callback) {
  return this._resolveFromParams(Action.PATCH, options, callback);
};

/**
 * Convenience method for doing DELETE requests.
 * resolver.delete('sp://player') is an equivalent of
 * resolver.resolve(new Request('DELETE', 'sp://player'))
 *
 * @see Resolver#get for params description and returned value.
 */
Resolver.prototype.delete = function(options, callback) {
  return this._resolveFromParams(Action.DELETE, options, callback);
};

/**
 * @private
 * Sends the request to the platform specific request resolver.
 * If the request action is 'SUB' it will send subscribe request
 * In any other case it will send simple resolve request.
 *
 * @param {Cosmos.Request} request A request object.
 * @param {function(error=, object?)} callback The function
 * executed after the request has been completed.
 *
 * @return {RequestHandler} The cancellable request handler.
 */
Resolver.prototype._resolve = function(request, callback) {
  if (!callback || typeof callback !== 'function') {
    callback = function() {};
  }

  var requestHandler;

  function onSuccess(serverResponse) {
    if (!requestHandler._request) {
      return;
    }

    var response = Response.fromObject(serverResponse);
    if (!response) {
      var error = new Error(
        'Failed to parse response: ' + JSON.stringify(serverResponse));
      return callback(error);
    }

    if (_isSuccessStatus(response.getStatusCode())) {
      return callback(null, response);
    } else {
      // Extract just the initial part of the request uri. It's good to have something
      // but it is also good to avoid having everything, since that can hurt dashboards
      // that group error messages.
      var requestEndpoint = request.toJSON().uri.match(/[^\:]*(\:\/\/)?[^\/]*/)[0];
      var errorMessage = (
        response.getHeader("error") ||
        "Request to " + requestEndpoint + " failed with status code " + response.getStatusCode());
      var error = new Error(errorMessage);
      error.response = response;
      return callback(error, response);
    }
  }

  function onError(serverResponse) {
    return callback(serverResponse instanceof Error ?
      serverResponse :
      new Error('Request failed: ' + JSON.stringify(serverResponse)));
  }

  var resolveFn = request.getAction() === Action.SUB ?
      this._resolver.subscribe : this._resolver.resolve;

  var clientRequest = resolveFn.call(this._resolver, request, onSuccess, onError);

  requestHandler = new RequestHandler(clientRequest);
  return requestHandler;
};

/**
 * @private
 * Creates Request object from supplied params.
 * @param {string} method Request method. One of the Request.Action.
 * @param {string|Object.<string, object>} options If is a string
 * will be parsed as url. If more data is needed, object notation
 * should be used.
 *  param options.url {string} The url of the request.
 *  param options.body {object=} The request body.
 *  param options.headers {object=} The request headers.
 * @param {function(error=, object?)} callback The function
 * executed after the request has been completed.
 *
 * @return {RequestHandler} The cancellable request handler.
 */
Resolver.prototype._resolveFromParams = function(method, options, callback) {
  options = options || {};

  var url = typeof options === 'string' ? options : options.url;
  var headers = options.headers;
  var body = options.body;

  var request = new Request(method, url, headers, body);

  return this._resolve(request, callback);
};

/**
 * The object that wraps the clientRequest
 * in a very simple interface.
 * Separates the implementation of the ClientRequest
 * from the request handler returned by Cosmos API.
 *
 * @param {Cosmos.ClientRequest} request The object
 * representing the newly opened request to the client.
 * Usually a request will be a subscription that
 * needs a close handler.
 */
function RequestHandler(request) {
  if (!request || typeof request.close !== 'function')
    throw new TypeError('Invalid `request` argument.');

  this._request = request;
}

/**
 * Closes the request and removes the object.
 */
RequestHandler.prototype.cancel = function() {
  if (this._request) {
    this._request.close();
    this._request = null;
  }
};

exports.Resolver = Resolver;

},{"cosmos-common-js":263}],361:[function(require,module,exports){
'use strict';

/**
 * The Base62 Converter
 *
 * @class Base62
 * @constructor
 *
 */

var digits = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
var invHexDigits = {};
var invDigits = {};

for (var i = 0; i < digits.length; ++i) { invDigits[digits[i]] = i; }
for (var i = 0; i < 16; ++i) { invHexDigits['0123456789abcdef'[i]] = i; }
for (var i = 0; i < 16; ++i) { invHexDigits['0123456789ABCDEF'[i]] = i; }

/**
 * lhs *= rhs
 * @private
 */
function mul(lhs, rhs, base) {
  var rest = 0;
  for (var i = 0; i < lhs.length; ++i) {
    var tmp = lhs[i] * rhs + rest;
    lhs[i] = tmp % base;
    rest = ~~(tmp / base);
  }
  while (rest) {
    lhs.push(rest % base);
    rest = ~~(rest / base);
  }
}

/**
 * acc += lhs * rhs
 * @private
 */
function madd(acc, lhs, rhs, base) {
  var rest = 0;
  for (var i = 0; i < lhs.length; ++i) {
    var tmp = ~~acc[i] + lhs[i] * rhs + rest;
    acc[i] = tmp % base;
    rest = ~~(tmp / base);
  }
  while (rest) {
    var tmp = ~~acc[i] + rest;
    acc[i] = tmp % base;
    rest = ~~(tmp / base);
    ++i;
  }
}

/**
 * Change base
 * @private
 */
function convert(data, fromBase, toBase) {
  var r = [0];
  var b = [1];
  for (var i = 0; i < data.length; ++i) {
    madd(r, b, data[i], toBase);
    mul(b, fromBase, toBase);
  }
  return r;
}

/**
 * Decode to
 * @private
 */
function mapr(data, mapping) {
  for (var i = 0, r = []; i < data.length; ++i) { r.push(mapping[data[i]]); }
  return r.reverse();
}

/**
 * Pad with 0s
 * @private
 */
function pad(data, length) {
  while (data.length < length) { data.push(0); }
  return data;
}

module.exports = {

  /**
   * Converts from array of bytes to base62 encoded string.
   *
   * @public
   * @name Spotify.Utils.Base62#fromBytes
   * @function
   * @param {Array.<number>} data Array of byte numbers.
   * @param {?number} length Do zeropadding until at least this length.
   * @return {string} Base62 encoded string.
  **/
  fromBytes: function(data, length) {
    var r = convert(data.slice(0).reverse(), 256, 62);
    return mapr(pad(r, length), digits).join('');
  },

  /**
   * Converts from base62 encoded string to array of bytes
   *
   * @public
   * @name Spotify.Utils.Base62#toBytes
   * @function
   * @param {string} str Base62 encoded string.
   * @param {?number} length Do zeropadding until at least this length.
   * @return {Array.<number>} Array of byte numbers.
  **/
  toBytes: function(str, length) {
    var r = convert(mapr(str, invDigits), 62, 256);
    return pad(r, length).reverse();
  },

  /**
   * Converts from base62 encoded string to hex encoded string
   *
   * @public
   * @name Spotify.Utils.Base62#toHex
   * @function
   * @param {string} str Base62 encoded string.
   * @param {?number} length Do zeropadding until at least this length.
   * @return {string} Hex encoded string.
  **/
  toHex: function(str, length) {
    var r = convert(mapr(str, invDigits), 62, 16);
    return mapr(pad(r, length), digits).join('');
  },

  /**
   * Converts from hex encoded strign to base62 encoded string
   *
   * @public
   * @name Spotify.Utils.Base62#fromHex
   * @function
   * @param {string} str Hex encoded string.
   * @param {?number} length Do zeropadding until at least this length.
   * @return {string} Base62 encoded string.
  **/
  fromHex: function(str, length) {
    var r = convert(mapr(str, invHexDigits), 16, 62);
    return mapr(pad(r, length), digits).join('');
  }

};

},{}],362:[function(require,module,exports){
(function() {
  /**
   * @file
   * Introduces a function called "defer" that allows functions to be
   * executed in the next available tick.
   *
   * Unlike "setTimeout", "defer" executes the function at the nearest
   * possible time without clamping.
   *
   * @see Spotify.defer
   */
  'use strict';

  var hasWindow = typeof window != 'undefined';
  var hasDefineProperty = typeof Object.defineProperty == 'function';

  if (hasWindow && window.__modDefFn) {
    // If deferred has been attached to the global scope
    module.exports = window.__modDefFn;
    return;
  }

  /**
   * Storage for deferred functions to be executed.
   *
   * @type {Array.<function()>}
   * @private
   */
  var deferred = [];


  /**
   * A bound version of the postMessage routine used to trigger deferred
   * execution.
   *
   * @type {function()}
   * @private
   */
  var send;
  var origin;

  if (hasWindow && window.postMessage) {
    origin = (window.location.origin ||
          window.location.protocol + '//' + window.location.hostname);
    send = window.postMessage.bind(window, '@execute_deferreds', origin);
    if (!window.__hasDeferredHandler) {
      if (hasDefineProperty) {
        Object.defineProperty(window, '__hasDeferredHandler', {value: 1});
      } else {
        window.__hasDeferredHandler = 1;
      }
      var handler = function(e) {
        if (e.origin != origin && e.data != '@execute_deferreds') {
          return;
        }
        executeDeferreds();
      };
      if (window.addEventListener) {
        window.addEventListener('message', handler);
      } else {
        window.attachEvent('onmessage', handler);
      }
    }
  } else if (typeof setImmediate != 'undefined') {
    send = setImmediate.bind(null, executeDeferreds);
  } else {
    send = setTimeout.bind(null, executeDeferreds, 10);
  }


  /**
   * Executes the deferred functions when the window
   * receives an 'execute_deferreds' message.
   *
   * @private
   */
  function executeDeferreds() {
    var fns = deferred.splice(0);
    if (!fns.length) return;
    for (var i = 0, l = fns.length; i < l; i++) {
      try {
        fns[i]();
      } finally {
        // Do nothing.
        null;
      }
    }
  }


  /**
   * Executes the function applied at the nearest possible time without
   * clamping.
   *
   * @param {function()} fn The function to execute.
   */
  var defer = function(fn) {
    var trigger = !deferred.length;
    deferred.push(fn);
    if (trigger) send();
  };

  if (hasWindow && !window.__modDefFn) {
    if (hasDefineProperty) {
      Object.defineProperty(window, '__modDefFn', {value: defer});
    } else {
      window.__modDefFn = defer;
    }
  }

  /**
   * Export public interface
   */
  module.exports = defer;

})();

},{}],363:[function(require,module,exports){
/**
 * @module spotify-eventemitter
 */
'use strict';

/**
 * @private
 */
var _defer = require('spotify-deferred');

/**
 * The event handlers.
 *
 * @typedef {Array.<function>}
 * @private
 */
var EventHandlers;

/**
 * Represents an Event.
 *
 * **NOTE**: The Event class is an internal class: you cannot instantiate it
 * directly. Instead, you should use the provided
 * {@link module:spotify-eventemitter.createEvent} function.
 *
 * @constructor
 * @param {string} type The type name of the event object.
 * @param {Object} props An object that will be added as properties of the
 *     event object.
 * @see {@link module:spotify-eventemitter.createEvent}
 */
function Event(type, props) {
  /**
   * The type of the event.
   *
   * @type {string}
   */
  this.type = type;

  /**
   * A flag for whether preventDefault was called.
   *
   * @type {boolean}
   * @private
   */
  this._prevented = false;

  /**
   * A flag for whether stopPropagation was called
   *
   * @type {boolean}
   * @private
   */
  this._stopped = false;

  /**
   * A flag for whether stopImmediatePropagation was called.
   *
   * @type {boolean}
   * @private
   */
  this._immediateStopped = false;

  if (props) {
    for (var key in props) {
      if (key == 'type') {
        continue;
      }
      this[key] = props[key];
    }
  }
}

/**
 * Prevents the default operation for the event.
 */
Event.prototype.preventDefault = function() {
  this._prevented = true;
};

/**
 * Returns whether preventDefault was called on the event.
 *
 * @return {boolean} True if preventDefault was called, false otherwise.
 */
Event.prototype.isDefaultPrevented = function() {
  return this._prevented;
};

/**
 * Stops the propagation of the event.
 */
Event.prototype.stopPropagation = function() {
  this._stopped = true;
};

/**
 * Returns whether stopPropagation was called on the event.
 *
 * @return {boolean} True if stopPropagation was called, false otherwise.
 */
Event.prototype.isPropagationStopped = function() {
  return this._stopped;
};

/**
 * Stops the immediate propagation of the event.
 *
 * Handlers added after any event handler calling this method will not receive
 * the event.
 */
Event.prototype.stopImmediatePropagation = function() {
  this._immediateStopped = true;
};

/**
 * Returns whether stopImmediatePropagation was called on the event.
 *
 * @return {boolean} True if stopImmediatePropagation was called, false
 *     otherwise.
 */
Event.prototype.isImmediatePropagationStopped = function() {
  return this._immediateStopped;
};

/**
 * An EventEmitter is an object that can be listened to for events.
 *
 * Instances of this class are not usually used directly; instead, a class that
 * needs EventEmitter functionality would inherit from the EventEmitter class
 * so that it's instances can use events.
 *
 * @constructor
 * @alias module:spotify-eventemitter
 *
 * @example <caption>Direct usage</caption>
 * var EventEmitter = require('spotify-eventemitter');
 * var emitter = new EventEmitter();
 * emitter.addListener('someEvent', function() {
 *     console.log('someEvent fired!');
 * });
 * emitter.emit('someEvent');
 * @example <caption>Inheritance</caption>
 * var EventEmitter = require('spotify-eventemitter');
 * var inherit = require('spotify-inherit/inherit');
 *
 * function MyClass() {
 *   EventEmitter.call(this);
 * }
 * inherit(MyClass, EventEmitter);
 *
 * var instance = new MyClass();
 * instance.addListener('someEvent', function() {
 *     console.log('someEvent fired!');
 * });
 * instance.emit('someEvent');
 */
function EventEmitter() {
  /**
   * A map of event names to event handlers.
   *
   * @type {Object.<string, module:spotify-eventemitter~EventHandlers>}
   * @private
   */
  this._listenerMap;
}

/**
 * Creates a new Event object.
 *
 * @param {string} type The type name of the event.
 * @param {Object=} opt_params An object containing properties for the new event
 *     object.
 * @return {module:spotify-eventemitter~Event} The new event object.
 */
EventEmitter.createEvent = function(type, opt_params) {
  return new Event(type, opt_params);
};

/**
 * Adds an event listener to the emitter.
 *
 * This method is idempotent: calling it multiple times using the same type
 * and listener arguments will only set the listener once. This behaviour is
 * done to prevent accidental additions of the same event listener.
 *
 * @param {string} type The type of event to listen to.
 * @param {function} listener A function to be called when the emitter fires
 *     the event specified in the type.
 * @return {module:spotify-eventemitter} The event emitter.
 */
EventEmitter.prototype.addListener = function(type, listener) {
  var _listenerMap = this._listenerMap || (this._listenerMap = {});
  var listeners = _listenerMap[type] || (_listenerMap[type] = []);
  if (listeners.indexOf(listener) != -1) {
    // Handler already added, return quickly.
    return this;
  }
  listeners.push(listener);
  return this;
};

/**
 * Adds multiple event listeners to the emitter.
 *
 * @param {Object.<string, function>} eventListeners An object, the keys of
 *     which correspond to the name of events to listen to, and the value of
 *     each of these keys should be a function that would be added as the
 *     listener for that event.
 * @return {module:spotify-eventemitter} The event emitter.
 */
EventEmitter.prototype.addListeners = function(eventListeners) {
  for (var type in eventListeners) {
    this.addListener(type, eventListeners[type]);
  }
  return this;
};

/**
 * Adds a "once" event listener to the emitter, which will be removed right
 * after it has been fired.
 *
 * In order to achieve the "once" behaviour, the listener argument passed to
 * this method is wrapped in a function, which is then returned by the method.
 *
 * Because of this wrapping, this method is not idempotent: calling it multiple
 * times with the same type and listener arguments will result to multiple
 * event listeners attached.
 *
 * @param {string} type The type of event to listen to.
 * @param {function} listener A function to be called when the emitter fires
 *     the event specified in the type and then automatically removed.
 * @return {function} The function used to wrap the listener function argument.
 *     This function can be used as an argument to removeEvent.
 */
EventEmitter.prototype.addOnceListener = function(type, listener) {
  var wrapper = function() {
    this.removeListener(type, wrapper);
    return listener.apply(this, arguments);
  };
  this.addListener(type, wrapper);
  return wrapper;
};

/**
 * Removes an event listener from the emitter.
 *
 * @param {string} type The type of event to remove.
 * @param {function} listener The listener function to remove. This must be a
 *     function that was added previously using addEvent.
 * @return {module:spotify-eventemitter} The event emitter.
 */
EventEmitter.prototype.removeListener = function(type, listener) {
  var _listenerMap = this._listenerMap;
  var listeners = _listenerMap && _listenerMap[type];
  if (!listeners) {
    return this;
  }
  var index = listeners.indexOf(listener);
  if (index == -1) {
    return this;
  }
  listeners.splice(index, 1);
  if (!listeners.length) {
    _listenerMap[type] = null;
  }
  return this;
};

/**
 * Removes all event listeners from the emitter for a particular type.
 *
 * @param {string} type The event type to remove.
 * @return {module:spotify-eventemitter} The event emitter.
 */
EventEmitter.prototype.removeAllListeners = function(type) {
  var _listenerMap = this._listenerMap;
  if (!_listenerMap) {
    return this;
  }
  _listenerMap[type] = null;
  return this;
};

/**
 * Removes multiple event listeners from the emitter.
 *
 * @param {Object.<string, function>} eventListeners An object, the keys of
 *     which correspond to the name of events to listen to, and the value of
 *     each of these keys should be a function that would be added as the
 *     listener for that event.
 * @return {module:spotify-eventemitter} The event emitter.
 */
EventEmitter.prototype.removeListeners = function(eventListeners) {
  for (var type in eventListeners) {
    this.removeListener(type, eventListeners[type]);
  }
  return this;
};

/**
 * Creates and emits an event on the emitter.
 *
 * This method invokes all the added event listeners of the `type` provided in
 * the order they were added, passing in a new Event object created using the
 * provided `type` and `opt_params` arguments.
 *
 * This method emits events asynchronously: the listeners are not called until
 * the next run loop.
 *
 * @param {string} type The type name of the event to emit.
 * @param {Object=} opt_params An object containing parameters for the Event
 *     object.
 * @return {module:spotify-eventemitter~Event} The Event object that was
 *     created.
 */
EventEmitter.prototype.emit = function(type, opt_params) {
  var event = new Event(type, opt_params);
  _defer(function() {
    this.emitEventSync(event);
  }.bind(this));
  return event;
};

/**
 * Emits an event on the emitter.
 *
 * This method invokes all the added event listeners of the `type` of the
 * `event` provided in the order they were added, passing in the `event` as an
 * argument.
 *
 * This method emits events asynchronously: the listeners are not called until
 * the next run loop.
 *
 * @param {module:spotify-eventemitter~Event} event The Event object.
 * @return {module:spotify-eventemitter~Event} The Event object that was passed.
 */
EventEmitter.prototype.emitEvent = function(event) {
  _defer(function() {
    this.emitEventSync(event);
  }.bind(this));
  return event;
};

/**
 * Creates and synchronously emits an event on the emitter.
 *
 * This method invokes all the added event listeners of the `type` provided in
 * the order they were added, passing in a new Event object created using the
 * provided `type` and `opt_params` arguments.
 *
 * @param {string} type The type name of event to emit.
 * @param {Object=} opt_params An object containing parameters for the event
 *     object.
 * @return {module:spotify-eventemitter~Event} The Event object that was
 *     created.
 */
EventEmitter.prototype.emitSync = function(type, opt_params) {
  var event = new Event(type, opt_params);
  this.emitEventSync(event);
  return event;
};

/**
 * Synchronously emits an event on the emitter.
 *
 * This method invokes all the added event listeners of the `type` of the
 * `event` provided in the order they were added, passing in the `event` as an
 * argument.
 *
 * @param {module:spotify-eventemitter~Event} event The Event object.
 * @return {module:spotify-eventemitter~Event} The Event object that was passed.
 */
EventEmitter.prototype.emitEventSync = function(event) {
  var type = event.type;
  var _listenerMap = this._listenerMap;
  var listeners = _listenerMap && _listenerMap[type];
  if (!listeners || !listeners.length) {
    return event;
  }
  listeners = listeners.slice(0);
  for (var i = 0, l = listeners.length; i < l; i++) {
    listeners[i].call(this, event);
    if (event.isImmediatePropagationStopped()) {
      break;
    }
  }
  return event;
};

// DEPRECATED METHODS:

/**
 * Adds an event listener to the emitter.
 *
 * **NOTE**: This method has been deprecated in favor of
 * {@link module:spotify-eventemitter#addListener}.
 *
 * This method is idempotent: calling it multiple times using the same type
 * and listener arguments will only set the listener once. This behaviour is
 * done to prevent accidental additions of the same event listener.
 *
 * @deprecated since v2.0.0.
 * @param {string} type The type of event to listen to.
 * @param {function} listener A function to be called when the emitter fires
 *     the event specified in the type.
 * @return {module:spotify-eventemitter} The event emitter.
 * @see {@link module:spotify-eventemitter#addListener}
 */
EventEmitter.prototype.addEvent = function(type, listener) {
  return this.addListener(type, listener);
};

/**
 * Adds multiple event listeners to the emitter.
 *
 * **NOTE**: This method has been deprecated in favor of
 * {@link module:spotify-eventemitter#addListeners}.
 *
 * @deprecated since v2.0.0.
 * @param {Object.<string, function>} eventListeners An object, the keys of
 *     which correspond to the name of events to listen to, and the value of
 *     each of these keys should be a function that would be added as the
 *     listener for that event.
 * @return {module:spotify-eventemitter} The event emitter.
 * @see {@link module:spotify-eventemitter#addListeners}
 */
EventEmitter.prototype.addEvents = function(eventListeners) {
  return this.addListeners(eventListeners);
};

/**
 * Adds a "once" event listener to the emitter, which will be removed right
 * after it has been fired.
 *
 * **NOTE**: This method has been deprecated in favor of
 * {@link module:spotify-eventemitter#addOnceListener}.
 *
 * In order to achieve the "once" behaviour, the listener argument passed to
 * this method is wrapped in a function, which is then returned by the method.
 *
 * Because of this wrapping, this method is not idempotent: calling it multiple
 * times with the same type and listener arguments will result to multiple
 * event listeners attached.
 *
 * @deprecated since v2.0.0.
 * @param {string} type The type of event to listen to.
 * @param {function} listener A function to be called when the emitter fires
 *     the event specified in the type and then automatically removed.
 * @return {function} The function used to wrap the listener function argument.
 *     This function can be used as an argument to removeEvent.
 * @see {@link module:spotify-eventemitter#addOnceListener}
 */
EventEmitter.prototype.addOnceEvent = function(type, listener) {
  return this.addOnceListener(type, listener);
};

/**
 * Removes an event listener from the emitter.
 *
 * **NOTE**: This method has been deprecated in favor of
 * {@link module:spotify-eventemitter#removeListener}.
 *
 * @deprecated since v2.0.0.
 * @param {string} type The type of event to remove.
 * @param {function} listener The listener function to remove. This must be a
 *     function that was added previously using addEvent.
 * @return {module:spotify-eventemitter} The event emitter.
 * @see {@link module:spotify-eventemitter#removeListener}
 */
EventEmitter.prototype.removeEvent = function(type, listener) {
  return this.removeListener(type, listener);
};

/**
 * Removes multiple event listeners from the emitter.
 *
 * **NOTE**: This method has been deprecated in favor of
 * {@link module:spotify-eventemitter#removeListeners}.
 *
 * @deprecated since v2.0.0.
 * @param {Object.<string, function>} events An object, the keys of which
 *     correspond to the name of events to remove, and the value of each of
 *     these keys should be a function that would be removed as a listener.
 * @return {module:spotify-eventemitter} The event emitter.
 * @see {@link module:spotify-eventemitter#removeListeners}
 */
EventEmitter.prototype.removeEvents = function(eventListeners) {
  return this.removeListeners(eventListeners);
};

/**
 * Fires an event on the emitter, optionally passing arguments to the listeners.
 *
 * **NOTE**: This method has been deprecated in favor of
 * {@link module:spotify-eventemitter#emit}.
 *
 * This method fire events asynchronously: the listeners are not called until
 * the next run loop. A third boolean parameter can be passed to change this
 * behaviour.
 *
 * @deprecated since v2.0.0.
 * @param {string} type The type of event to fire.
 * @param {Array.<*>=} opt_args A set of objects that would be passed to the
 *     event listeners as arguments.
 * @param {boolean=} opt_priority Passing true will fire the event synchronously.
 * @return {module:spotify-eventemitter} The event emitter.
 * @see {@link module:spotify-eventemitter#emit}
 */
EventEmitter.prototype.fireEvent = function(type, opt_args, opt_priority) {
  if (opt_priority) {
    this.fireEventSync(type, opt_args);
  } else {
    var self = this;
    _defer(function() { self.fireEventSync(type, opt_args); });
  }
  return this;
};

/**
 * Fires an event on the emitter synchronously, optionally passing arguments to
 * the listeners.
 *
 * **NOTE**: This method has been deprecated in favor of
 * {@link module:spotify-eventemitter#emitSync}.
 *
 * @deprecated since v2.0.0.
 * @param {string} type The type of event to fire.
 * @param {Array.<*>=} opt_args A set of objects that would be passed to the
 *     event listeners as arguments.
 * @return {module:spotify-eventemitter} The event emitter.
 * @see {@link module:spotify-eventemitter#emitSync}
 */
EventEmitter.prototype.fireEventSync = function(type, opt_args) {
  var self = this;
  var events = this._listenerMap && this._listenerMap[type];
  if (!events || !events.length) return this;
  events = events.slice(0);
  var i, l;
  if (!opt_args) {
    for (i = 0, l = events.length; i < l; i++) {
      events[i].call(self);
    }
  } else {
    if (!Array.isArray(opt_args)) {
      opt_args = [opt_args];
    }
    for (i = 0, l = events.length; i < l; i++) {
      events[i].apply(self, opt_args);
    }
  }
  return this;
};

/**
 * Adds an event listener to the emitter.
 *
 * **NOTE**: This method has been deprecated in favor of
 * {@link module:spotify-eventemitter#addListener}.
 *
 * This method is idempotent: calling it multiple times using the same type
 * and listener arguments will only set the listener once. This behaviour is
 * done to prevent accidental additions of the same event listener.
 *
 * @deprecated since v2.0.0.
 * @param {string} type The type of event to listen to.
 * @param {function} listener A function to be called when the emitter fires
 *     the event specified in the type.
 * @return {module:spotify-eventemitter} The event emitter.
 * @see {@link module:spotify-eventemitter#addListener}
 */
EventEmitter.prototype.on = function(type, listener) {
  return this.addEvent(type, listener);
};

/**
 * Adds a "once" event listener to the emitter, which will be removed right
 * after it has been fired.
 *
 * **NOTE**: This method has been deprecated in favor of
 * {@link module:spotify-eventemitter#addOnceListener}.
 *
 * In order to achieve the "once" behaviour, the listener argument passed to
 * this method is wrapped in a function, which is then returned by the method.
 *
 * Because of this wrapping, this method is not idempotent: calling it multiple
 * times with the same type and listener arguments will result to multiple
 * event listeners attached.
 *
 * @deprecated since v2.0.0.
 * @param {string} type The type of event to listen to.
 * @param {function} listener A function to be called when the emitter fires
 *     the event specified in the type and then automatically removed.
 * @return {function} The function used to wrap the listener function argument.
 *     This function can be used as an argument to removeEvent.
 * @see {@link module:spotify-eventemitter#addOnceListener}
 */
EventEmitter.prototype.once = function(type, listener) {
  return this.addOnceEvent(type, listener);
};

/**
 * Removes an event listener or all event listeners from the emitter.
 *
 * **NOTE**: This method has been deprecated in favor of
 * {@link module:spotify-eventemitter#removeListener}.
 *
 * @deprecated since v2.0.0.
 * @param {string} type The type of event to remove.
 * @param {function=} opt_listener The listener function to remove. This must be
 *     a function that was added previously using addEvent. If this parameter is
 *     not given, all event listeners of the corresponding `type` argument will
 *     be removed.
 * @return {module:spotify-eventemitter} The event emitter.
 * @see {@link module:spotify-eventemitter#removeListener}
 * @see {@link module:spotify-eventemitter#removeListeners}
 */
EventEmitter.prototype.off = function(type, opt_listener) {
  if (typeof opt_listener === 'function') {
    return this.removeEvent(type, opt_listener);
  }
  // if no listener set, remove all the listeners from the event
  this._listenerMap[type] = null;
  return this;
};

/**
 * Exporting
 */
module.exports = EventEmitter;

},{"spotify-deferred":362}],364:[function(require,module,exports){
'use strict';

/**
 * Function to add properties to an object
 * @param {Object} obj The input object
 * @param {Object} args The objects which are going to be injected
 * @return {Object} The extended object
 */
var extend = function(obj, args) {
  var source;

  for (var i = 1; i < arguments.length; i++) {
    source = arguments[i];
    if (source) {
      for (var prop in source) {
        if (source.hasOwnProperty(prop)) {
          obj[prop] = source[prop];
        }
      }
    }
  }
  return obj;
};


/**
 * Export public interface
 */
module.exports = extend;

},{}],365:[function(require,module,exports){
'use strict';

module.exports = {
  inherit: require('./inherit'),
  extend: require('./extend')
};

},{"./extend":364,"./inherit":366}],366:[function(require,module,exports){
'use strict';

/**
 * Makes a class inherit from a superclass' prototype indirectly.
 *
 * @param {Spotify.ClassLike} Sub The class that will inherit.
 * @param {Spotify.ClassLike} Super The class to inherit from.
 */
var inherit = function(Sub, Super) {
  var superProto = Super.prototype;
  function Superclass() {}
  Superclass.prototype = Sub._super = superProto;
  Superclass.prototype.constructor = Super;
  Sub.prototype = new Superclass();
};


/**
 * Export public interface
 */
module.exports = inherit;

},{}],367:[function(require,module,exports){
'use strict';

/**
 * @private
 */
var Base62 = require('spotify-crypto/src/base62');

/**
 * The URI prefix for URIs.
 *
 * @const
 * @private
 */
var URI_PREFIX = 'spotify:';

/**
 * The URL prefix for Play.
 *
 * @const
 * @private
 */
var PLAY_HTTP_PREFIX = 'http://play.spotify.com/';

/**
 * The HTTPS URL prefix for Play.
 *
 * @const
 * @private
 */
var PLAY_HTTPS_PREFIX = 'https://play.spotify.com/';

/**
 * The URL prefix for Open.
 *
 * @const
 * @private
 */
var OPEN_HTTP_PREFIX = 'http://open.spotify.com/';

/**
 * The HTTPS URL prefix for Open.
 *
 * @const
 * @private
 */
var OPEN_HTTPS_PREFIX = 'https://open.spotify.com/';

var ERROR_INVALID = new TypeError('Invalid Spotify URI!');
var ERROR_NOT_IMPLEMENTED = new TypeError('Not implemented!');


/**
 * The format for the URI to parse.
 *
 * @enum {number}
 * @private
 */
var Format = {
  URI: 0,
  URL: 1
};

/**
 * Represents the result of a URI splitting operation.
 *
 * @typedef {{
 *    format: Format,
 *    components: Array.<string>
 * }}
 * @see _splitIntoComponents
 * @private
 */
var SplittedURI;

/**
 * Split an string URI or HTTP/HTTPS URL into components, skipping the prefix.
 *
 * @param {string} str A string URI to split.
 * @return {SplittedURI} The parsed URI.
 * @private
 */
var _splitIntoComponents = function(str) {
  var components;
  var format;
  var anchor;

  var hashSplit = str.split('#');

  if (hashSplit.length > 1) {
    // first token
    str = hashSplit.shift();
    // last token
    anchor = hashSplit.pop();
  }

  if (str.indexOf(URI_PREFIX) === 0) {
    components = str.slice(URI_PREFIX.length).split(':');
    format = Format.URI;
  } else {
    // For HTTP URLs, ignore any query string argument
    str = str.split('?')[0];

    if (str.indexOf(PLAY_HTTP_PREFIX) === 0) {
      components = str.slice(PLAY_HTTP_PREFIX.length).split('/');
    } else if (str.indexOf(PLAY_HTTPS_PREFIX) === 0) {
      components = str.slice(PLAY_HTTPS_PREFIX.length).split('/');
    } else if (str.indexOf(OPEN_HTTP_PREFIX) === 0) {
      components = str.slice(OPEN_HTTP_PREFIX.length).split('/');
    } else if (str.indexOf(OPEN_HTTPS_PREFIX) === 0) {
      components = str.slice(OPEN_HTTPS_PREFIX.length).split('/');
    } else {
      throw ERROR_INVALID;
    }
    format = Format.URL;
  }

  if (anchor) {
    components.push(anchor);
  }

  return {
    format: format,
    components: components
  };
};

/**
 * Encodes a component according to a format.
 *
 * @param {string} component A component string.
 * @param {Format} format A format.
 * @return {string} An encoded component string.
 * @private
 */
var _encodeComponent = function(component, format) {
  component = encodeURIComponent(component);
  if (format === Format.URI) {
    component = component.replace(/%20/g, '+');
  }

  // encode characters that are not encoded by default by encodeURIComponent
  // but that the Spotify URI spec encodes: !'*()
  component = component.replace(/[!'()]/g, escape);
  component = component.replace(/\*/g, '%2A');

  return component;
};

/**
 * Decodes a component according to a format.
 *
 * @param {string} component An encoded component string.
 * @param {Format} format A format.
 * @return {string} An decoded component string.
 * @private
 */
var _decodeComponent = function(component, format) {
  var part = format == Format.URI ? component.replace(/\+/g, '%20') : component;
  return decodeURIComponent(part);
};

/**
 * Returns the components of a URI as an array.
 *
 * @param {URI} uri A uri.
 * @param {Format} format The output format.
 * @return {Array.<string>} An array of uri components.
 * @private
 */
var _getComponents = function(uri, format) {
  var base62;
  if (uri.id) {
    base62 = uri._base62Id;
  }

  var components;
  var i;
  var len;
  switch (uri.type) {
    case URI.Type.ALBUM:
      components = [URI.Type.ALBUM, base62];
      if (uri.disc) {
        components.push(uri.disc);
      }
      return components;
    case URI.Type.AD:
      return [URI.Type.AD, uri._base62Id];
    case URI.Type.ARTIST:
      return [URI.Type.ARTIST, base62];
    case URI.Type.ARTIST_TOPLIST:
      return [URI.Type.ARTIST, base62, URI.Type.TOP, uri.toplist];
    case URI.Type.SEARCH:
      return [URI.Type.SEARCH, _encodeComponent(uri.query, format)];
    case URI.Type.TRACK:
      if (uri.anchor) {
        base62 += '#' + uri.anchor;
      }
      return [URI.Type.TRACK, base62];
    case URI.Type.TRACKSET:
      var trackIds = [];
      for (i = 0, len = uri.tracks.length; i < len; i++) {
        trackIds.push(uri.tracks[i]._base62Id);
      }
      trackIds = [trackIds.join(',')];
      // Index can be 0 sometimes (required for trackset)
      if (uri.index !== null) {
        trackIds.push('#', uri.index);
      }
      return [URI.Type.TRACKSET, _encodeComponent(uri.name)].concat(trackIds);
    case URI.Type.FACEBOOK:
      return [URI.Type.USER, URI.Type.FACEBOOK, uri.uid];
    case URI.Type.AUDIO_FILE:
      return [URI.Type.AUDIO_FILE, uri.extension, uri._base62Id];
    case URI.Type.FOLDER:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.FOLDER, uri._base62Id];
    case URI.Type.FOLLOWERS:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.FOLLOWERS];
    case URI.Type.FOLLOWING:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.FOLLOWING];
    case URI.Type.PLAYLIST:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.PLAYLIST, base62];
    case URI.Type.STARRED:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.STARRED];
    case URI.Type.TEMP_PLAYLIST:
      return [URI.Type.TEMP_PLAYLIST, uri.origin, uri.data];
    case URI.Type.CONTEXT_GROUP:
      return [URI.Type.CONTEXT_GROUP, uri.origin, uri.name];
    case URI.Type.USER_TOPLIST:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.TOP, uri.toplist];
    // Legacy Toplist
    case URI.Type.USER_TOP_TRACKS:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.TOPLIST];
    case URI.Type.TOPLIST:
      return [URI.Type.TOP, uri.toplist].concat(uri.global ? [URI.Type.GLOBAL] : ['country', uri.country]);
    case URI.Type.INBOX:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.INBOX];
    case URI.Type.ROOTLIST:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.ROOTLIST];
    case URI.Type.PUBLISHED_ROOTLIST:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.PUBLISHED_ROOTLIST];
    case URI.Type.COLLECTION_TRACK_LIST:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.COLLECTION_TRACK_LIST, base62];
    case URI.Type.PROFILE:
      if (uri.args && uri.args.length > 0)
        return [URI.Type.USER, _encodeComponent(uri.username, format)].concat(uri.args);
      return [URI.Type.USER, _encodeComponent(uri.username, format)];
    case URI.Type.LOCAL_ARTIST:
      return [URI.Type.LOCAL, _encodeComponent(uri.artist, format)];
    case URI.Type.LOCAL_ALBUM:
      return [URI.Type.LOCAL, _encodeComponent(uri.artist, format), _encodeComponent(uri.album, format)];
    case URI.Type.LOCAL:
      return [URI.Type.LOCAL,
        _encodeComponent(uri.artist, format),
        _encodeComponent(uri.album, format),
        _encodeComponent(uri.track, format),
        uri.duration];
    case URI.Type.LIBRARY:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.LIBRARY].concat(uri.category ? [uri.category] : []);
    case URI.Type.IMAGE:
      return [URI.Type.IMAGE, uri._base62Id];
    case URI.Type.MOSAIC:
      components = uri.ids.slice(0);
      components.unshift(URI.Type.MOSAIC);
      return components;
    case URI.Type.RADIO:
      return [URI.Type.RADIO, uri.args];
    case URI.Type.SPECIAL:
      components = [URI.Type.SPECIAL];
      var args = uri.args || [];
      for (i = 0, len = args.length; i < len; ++i)
        components.push(_encodeComponent(args[i], format));
      return components;
    case URI.Type.STATION:
      components = [URI.Type.STATION];
      var args = uri.args || [];
      for (i = 0, len = args.length; i < len; i++) {
        components.push(_encodeComponent(args[i], format));
      }
      return components;
    case URI.Type.APPLICATION:
      components = [URI.Type.APP, uri._base62Id];
      var args = uri.args || [];
      for (i = 0, len = args.length; i < len; ++i)
        components.push(_encodeComponent(args[i], format));
      return components;
    case URI.Type.COLLECTION_ALBUM:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.COLLECTION, URI.Type.ALBUM, base62];
    case URI.Type.COLLECTION_MISSING_ALBUM:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.COLLECTION, URI.Type.ALBUM, base62, 'missing'];
    case URI.Type.COLLECTION_ARTIST:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.COLLECTION, URI.Type.ARTIST, base62];
    case URI.Type.COLLECTION:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.COLLECTION].concat(uri.category ? [uri.category] : []);
    case URI.Type.EPISODE:
      return [URI.Type.EPISODE, base62];
    default:
      throw ERROR_INVALID;
  }
};

/**
 * Parses the components of a URI into a real URI object.
 *
 * @param {Array.<string>} components The components of the URI as a string
 *     array.
 * @param {Format} format The format of the source string.
 * @return {URI} The URI object.
 * @private
 */
var _parseFromComponents = function(components, format) {
  var _current = 0;

  var _getNextComponent = function() {
    return components[_current++];
  };

  var _getIdComponent = function() {
    var component = _getNextComponent();

    if (component.length > 22) {
      throw new Error('Invalid ID');
    }
    return component;
  };

  var _getRemainingComponents = function() {
    return components.slice(_current);
  };

  var _getRemainingString = function() {
    var separator = (format == Format.URI) ? ':' : '/';
    return components.slice(_current).join(separator);
  };

  var part = _getNextComponent();
  var id;
  var i;
  var len;

  switch (part) {
    case URI.Type.ALBUM:
      return URI.albumURI(_getIdComponent(), parseInt(_getNextComponent(), 10));
    case URI.Type.AD:
      return URI.adURI(_getNextComponent());
    case URI.Type.ARTIST:
      id = _getIdComponent();
      if (_getNextComponent() == URI.Type.TOP) {
        return URI.artistToplistURI(id, _getNextComponent());
      } else {
        return URI.artistURI(id);
      }
    case URI.Type.AUDIO_FILE:
      return URI.audioFileURI(_getNextComponent(), _getNextComponent());
    case URI.Type.TEMP_PLAYLIST:
      return URI.temporaryPlaylistURI(_getNextComponent(), _getRemainingString());
    case URI.Type.SEARCH:
      return URI.searchURI(_decodeComponent(_getRemainingString(), format));
    case URI.Type.TRACK:
      return URI.trackURI(_getIdComponent(), _getNextComponent());
    case URI.Type.TRACKSET:
      var name = _decodeComponent(_getNextComponent());
      var tracksArray = _getNextComponent();
      var hashSign = _getNextComponent();
      var index = parseInt(_getNextComponent(), 10);
      // Sanity check: %23 is URL code for "#"
      if (hashSign !== '%23' || isNaN(index)) {
        index = null;
      }
      var tracksetTracks = [];
      if (tracksArray) {
        tracksArray = _decodeComponent(tracksArray).split(',');
        for (i = 0, len = tracksArray.length; i < len; i++) {
          var trackId = tracksArray[i];
          tracksetTracks.push(URI.trackURI(trackId));
        }
      }
      return URI.tracksetURI(tracksetTracks, name, index);
    case URI.Type.CONTEXT_GROUP:
      return URI.contextGroupURI(_getNextComponent(), _getNextComponent());
    case URI.Type.TOP:
      var type = _getNextComponent();
      if (_getNextComponent() == URI.Type.GLOBAL) {
        return URI.toplistURI(type, null, true);
      } else {
        return URI.toplistURI(type, _getNextComponent(), false);
      }
    case URI.Type.USER:
      var username = _decodeComponent(_getNextComponent(), format);
      var text = _getNextComponent();
      if (username == URI.Type.FACEBOOK && text != null) {
        return URI.facebookURI(parseInt(text, 10));
      } else if (text != null) {
        switch (text) {
          case URI.Type.PLAYLIST:
            return URI.playlistURI(username, _getIdComponent());
          case URI.Type.FOLDER:
            return URI.folderURI(username, _getIdComponent());
          case URI.Type.COLLECTION_TRACK_LIST:
            return URI.collectionTrackList(username, _getIdComponent());
          case URI.Type.COLLECTION:
            var collectionItemType = _getNextComponent();
            switch (collectionItemType) {
              case URI.Type.ALBUM:
                id = _getIdComponent();
                if (_getNextComponent() === 'missing') {
                  return URI.collectionMissingAlbumURI(username, id);
                } else {
                  return URI.collectionAlbumURI(username, id);
                }
              case URI.Type.ARTIST:
                return URI.collectionArtistURI(username, _getIdComponent());
              default:
                return URI.collectionURI(username, collectionItemType);
            }
          case URI.Type.STARRED:
            return URI.starredURI(username);
          case URI.Type.FOLLOWERS:
            return URI.followersURI(username);
          case URI.Type.FOLLOWING:
            return URI.followingURI(username);
          case URI.Type.TOP:
            return URI.userToplistURI(username, _getNextComponent());
          case URI.Type.INBOX:
            return URI.inboxURI(username);
          case URI.Type.ROOTLIST:
            return URI.rootlistURI(username);
          case URI.Type.PUBLISHED_ROOTLIST:
            return URI.publishedRootlistURI(username);
          case URI.Type.TOPLIST:
            // legacy toplist
            return URI.userTopTracksURI(username);
          case URI.Type.LIBRARY:
            return URI.libraryURI(username, _getNextComponent());
        }
      }
      var rem = _getRemainingComponents();
      if (text != null && rem.length > 0) {
        return URI.profileURI(username, [text].concat(rem));
      } else if (text != null) {
        return URI.profileURI(username, [text]);
      } else {
        return URI.profileURI(username);
      }
    case URI.Type.LOCAL:
      var artistNameComponent = _getNextComponent();
      var artistName = artistNameComponent && _decodeComponent(artistNameComponent, format);
      var albumNameComponent = _getNextComponent();
      var albumName = albumNameComponent && _decodeComponent(albumNameComponent, format);
      var trackNameComponent = _getNextComponent();
      var trackName = trackNameComponent && _decodeComponent(trackNameComponent, format);
      var durationComponent = _getNextComponent();
      var duration = parseInt(durationComponent, 10);
      if (trackNameComponent !== undefined) {
        return URI.localURI(artistName, albumName, trackName, duration);
      } else if (albumNameComponent !== undefined) {
        return URI.localAlbumURI(artistName, albumName);
      } else {
        return URI.localArtistURI(artistName);
      }
    case URI.Type.IMAGE:
      return URI.imageURI(_getIdComponent());
    case URI.Type.MOSAIC:
      return URI.mosaicURI(components.slice(_current));
    case URI.Type.RADIO:
      return URI.radioURI(_getRemainingString());
    case URI.Type.SPECIAL:
      var args = _getRemainingComponents();
      for (i = 0, len = args.length; i < len; ++i)
        args[i] = _decodeComponent(args[i], format);
      return URI.specialURI(args);
    case URI.Type.STATION:
      return URI.stationURI(_getRemainingComponents());
    case URI.Type.EPISODE:
      return URI.episodeURI(_getIdComponent());
    default:
      if (part === URI.Type.APP) {
        id = _getNextComponent();
      } else {
        id = part;
      }
      var args = _getRemainingComponents();
      for (i = 0, len = args.length; i < len; ++i)
        args[i] = _decodeComponent(args[i], format);
      return URI.applicationURI(id, args);
  }

  throw ERROR_INVALID;
};

/**
 * A class holding information about a uri.
 *
 * @constructor
 * @param {URI.Type} type The uri type.
 * @param {Object} props The uri properties.
 */
function URI(type, props) {
  /**
   * The uri type.
   *
   * @type {string}
   */
  this.type = type;

  // Merge properties into URI object.
  for (var prop in props) {
    if (typeof props[prop] == 'function') {
      continue;
    }
    this[prop] = props[prop];
  }
}

// Lazy convert the id to hexadecimal only when requested
Object.defineProperty(URI.prototype, 'id', {
  get: function() {
    if (!this._hexId) {
      this._hexId = this._base62Id ? URI.idToHex(this._base62Id) : undefined;
    }
    return this._hexId;
  },
  set: function(id) {
    this._base62Id = id ? URI.hexToId(id) : undefined;
    this._hexId = undefined;
  },
  enumerable: true,
  configurable: true
});

/**
 * Creates an application URI object from the current URI object.
 *
 * If the current URI object is already an application type, a copy is made.
 *
 * @return {URI} The current URI as an application URI.
 */
URI.prototype.toAppType = function() {
  if (this.type == URI.Type.APPLICATION) {
    return URI.applicationURI(this.id, this.args);
  } else {
    var components = _getComponents(this, Format.URL);
    var id = components.shift();
    var len = components.length;
    if (len) {
      while (len--) {
        components[len] = _decodeComponent(components[len], Format.URL);
      }
    }
    if (this.type == URI.Type.RADIO) {
      components = components.shift().split(':');
    }
    var result = URI.applicationURI(id, components);
    return result;
  }
};

/**
 * Creates a URI object from an application URI object.
 *
 * If the current URI object is not an application type, a copy is made.
 *
 * @return {URI} The current URI as a real typed URI.
 */
URI.prototype.toRealType = function() {
  if (this.type == URI.Type.APPLICATION) {
    return _parseFromComponents([this.id].concat(this.args), Format.URI);
  } else {
    return new URI(null, this);
  }
};

/**
 * Returns the URI representation of this URI.
 *
 * @return {String} The URI representation of this uri.
 */
URI.prototype.toURI = function() {
  return URI_PREFIX + _getComponents(this, Format.URI).join(':');
};

/**
 * Returns the String representation of this URI.
 *
 * @return {String} The URI representation of this uri.
 * @see {URI#toURI}
 */
URI.prototype.toString = function() {
  return this.toURI();
};

/**
 * Get the URL path of this uri.
 *
 * @param {boolean} opt_leadingSlash True if a leading slash should be prepended.
 * @return {String} The path of this uri.
 */
URI.prototype.toURLPath = function(opt_leadingSlash) {
  var components = _getComponents(this, Format.URL);
  if (components[0] === URI.Type.APP) {
    components.shift();
  }

  // Some URIs are allowed to have empty components. It should be investigated
  // whether we need to strip empty components at all from any URIs. For now,
  // we check specifically for tracksets and local tracks and strip empty
  // components for all other URIs.
  //
  // For tracksets, it's permissible to have a path that looks like
  // 'trackset//trackURI' because the identifier parameter for a trackset can
  // be blank. For local tracks, some metadata can be missing, like missing
  // album name would be 'spotify:local:artist::track:duration'.
  var isTrackset = components[0] === URI.Type.TRACKSET;
  var isLocalTrack = components[0] === URI.Type.LOCAL;
  var shouldStripEmptyComponents = !isTrackset && !isLocalTrack;

  if (shouldStripEmptyComponents) {
    var _temp = [];
    for (var i = 0, l = components.length; i < l; i++) {
      var component = components[i];
      if (!!component) {
        _temp.push(component);
      }
    }
    components = _temp;
  }
  var path = components.join('/');
  return opt_leadingSlash ? '/' + path : path;
};

/**
 * Returns the Play URL string for the uri.
 *
 * @return {string} The Play URL string for the uri.
 */
URI.prototype.toPlayURL = function() {
    return PLAY_HTTPS_PREFIX + this.toURLPath();
};

/**
 * Returns the URL string for the uri.
 *
 * @return {string} The URL string for the uri.
 * @see {URL#toPlayURL}
 */
URI.prototype.toURL = function() {
  return this.toPlayURL();
};

/**
 * Returns the Open URL string for the uri.
 *
 * @return {string} The Open URL string for the uri.
 */
URI.prototype.toOpenURL = function() {
  return OPEN_HTTPS_PREFIX + this.toURLPath();
};

/**
 * Returns the Play HTTPS URL string for the uri.
 *
 * @return {string} The Play HTTPS URL string for the uri.
 */
URI.prototype.toSecurePlayURL = function() {
    return this.toPlayURL();
};

/**
 * Returns the HTTPS URL string for the uri.
 *
 * @return {string} The HTTPS URL string for the uri.
 * @see {URL#toSecurePlayURL}
 */
URI.prototype.toSecureURL = function() {
  return this.toPlayURL();
};

/**
 * Returns the Open HTTPS URL string for the uri.
 *
 * @return {string} The Open HTTPS URL string for the uri.
 */
URI.prototype.toSecureOpenURL = function() {
  return this.toOpenURL();
};

/**
 * Returns the id of the uri as a bytestring.
 *
 * @return {Array} The id of the uri as a bytestring.
 */
URI.prototype.idToByteString = function() {
  var data = Base62.toBytes(this._base62Id);
  data = data.map(function(i) {
    return String.fromCharCode(i);
  }).join('');
  while (data.length < 16) {
    data = String.fromCharCode(0) + data;
  }
  return data;
};

/**
 * The various URI Types.
 *
 * Note that some of the types in this enum are not real URI types, but are
 * actually URI particles. They are marked so.
 *
 * @enum {string}
 */
URI.Type = {
  EMPTY: 'empty',
  ALBUM: 'album',
  AD: 'ad',
  /** URI particle; not an actual URI. */
  APP: 'app',
  APPLICATION: 'application',
  ARTIST: 'artist',
  ARTIST_TOPLIST: 'artist-toplist',
  AUDIO_FILE: 'audiofile',
  COLLECTION: 'collection',
  COLLECTION_ALBUM: 'collection-album',
  COLLECTION_MISSING_ALBUM: 'collection-missing-album',
  COLLECTION_ARTIST: 'collection-artist',
  CONTEXT_GROUP: 'context-group',
  EPISODE: 'episode',
  /** URI particle; not an actual URI. */
  FACEBOOK: 'facebook',
  FOLDER: 'folder',
  FOLLOWERS: 'followers',
  FOLLOWING: 'following',
  /** URI particle; not an actual URI. */
  GLOBAL: 'global',
  IMAGE: 'image',
  INBOX: 'inbox',
  LOCAL_ARTIST: 'local-artist',
  LOCAL_ALBUM: 'local-album',
  LOCAL: 'local',
  LIBRARY: 'library',
  MOSAIC: 'mosaic',
  PLAYLIST: 'playlist',
  PROFILE: 'profile',
  PUBLISHED_ROOTLIST: 'published-rootlist',
  RADIO: 'radio',
  ROOTLIST: 'rootlist',
  COLLECTION_TRACK_LIST: 'collectiontracklist',
  SEARCH: 'search',
  SPECIAL: 'special',
  STARRED: 'starred',
  STATION: 'station',
  TEMP_PLAYLIST: 'temp-playlist',
  /** URI particle; not an actual URI. */
  TOP: 'top',
  TOPLIST: 'toplist',
  TRACK: 'track',
  TRACKSET: 'trackset',
  /** URI particle; not an actual URI. */
  USER: 'user',
  USER_TOPLIST: 'user-toplist',
  USER_TOP_TRACKS: 'user-top-tracks',
  /** Deprecated contant. Please use USER_TOP_TRACKS. */
  USET_TOP_TRACKS: 'user-top-tracks'
};

/**
 * Creates a new URI object from a parsed string argument.
 *
 * @param {string} str The string that will be parsed into a URI object.
 * @throws TypeError If the string argument is not a valid URI, a TypeError will
 *     be thrown.
 * @return {URI} The parsed URI object.
 */
URI.fromString = function(str) {
  var splitted = _splitIntoComponents(str);
  return _parseFromComponents(splitted.components, splitted.format);
};

/**
 * Parses a given object into a URI instance.
 *
 * Unlike URI.fromString, this function could receive any kind of value. If
 * the value is already a URI instance, it is simply returned.
 * Otherwise the value will be stringified before parsing.
 *
 * This function also does not throw an error like URI.fromString, but
 * instead simply returns null if it can't parse the value.
 *
 * @param {*} value The value to parse.
 * @return {URI?} The corresponding URI instance, or null if the
 *     passed value is not a valid value.
 */
URI.from = function(value) {
  try {
    if (value instanceof URI) {
      return value;
    }
    if (typeof value == 'object' && value.type) {
      return new URI(null, value);
    }
    return URI.fromString(value.toString());
  } catch(e) {
    return null;
  }
};

/**
 * Creates a new URI from a bytestring.
 *
 * @param {URI.Type} type The type of the URI.
 * @param {ByteString} idByteString The ID of the URI as a bytestring.
 * @param {Object} opt_args Optional arguments to the URI constructor.
 * @return {URI} The URI object created.
 */
URI.fromByteString = function(type, idByteString, opt_args) {
  var bytes = [];
  for (var i = 0; i < idByteString.length; i++) {
    bytes.push(idByteString.charCodeAt(i));
  }
  var id = Base62.fromBytes(bytes, 22);
  var args = opt_args || {};
  args.id = id;
  return new URI(type, args);
};

/**
 * Clones a given SpotifyURI instance.
 *
 * @param {URI} uri The uri to clone.
 * @return {URI?} An instance of URI.
 */
URI.clone = function(uri) {
  if (!(uri instanceof URI)) {
    return null;
  }
  return new URI(null, uri);
};

/**
 * @deprecated
 */
URI.getCanonical = function(username) {
  return this.getCanonical(username);
};

/**
 * Returns the canonical representation of a username.
 *
 * @param {string} username The username to encode.
 * @return {string} The encoded canonical representation of the username.
 */
URI.getCanonicalUsername = function(username) {
  return _encodeComponent(username, Format.URI);
};

/**
 * Returns the non-canonical representation of a username.
 *
 * @param {string} username The username to encode.
 * @return {string} The unencoded canonical representation of the username.
 */
URI.getDisplayUsername = function(username) {
  return _decodeComponent(username, Format.URI);
};

/**
 * Returns the hex representation of a Base62 encoded id.
 *
 * @param {string} id The base62 encoded id.
 * @return {string} The hex representation of the base62 id.
 */
URI.idToHex = function(id) {
  if (id.length == 22) {
    return Base62.toHex(id, 32);
  }
  return id;
};

/**
 * Returns the base62 representation of a hex encoded id.
 *
 * @param {string} hex The hex encoded id.
 * @return {string} The base62 representation of the id.
 */
URI.hexToId = function(hex) {
  if (hex.length == 32) {
    return Base62.fromHex(hex, 22);
  }
  return hex;
};

/**
 * Creates a new empty URI.
 *
 * @return {URI} The empty URI.
 */
URI.emptyURI = function() {
  return new URI(URI.Type.EMPTY, {});
};

/**
 * Creates a new 'album' type URI.
 *
 * @param {string} id The id of the album.
 * @param {number} disc The disc number of the album.
 * @return {URI} The album URI.
 */
URI.albumURI = function(id, disc) {
  return new URI(URI.Type.ALBUM, {id: id, disc: disc});
};

/**
 * Creates a new 'ad' type URI.
 *
 * @param {string} id The id of the ad.
 * @return {URI} The ad URI.
 */
URI.adURI = function(id) {
  return new URI(URI.Type.AD, {id: id});
};

/**
 * Creates a new 'audiofile' type URI.
 *
 * @param {string} extension The extension of the audiofile.
 * @param {string} id The id of the extension.
 * @return {URI} The audiofile URI.
 */
URI.audioFileURI = function(extension, id) {
  return new URI(URI.Type.AUDIO_FILE, {id: id, extension: extension});
};

/**
 * Creates a new 'artist' type URI.
 *
 * @param {string} id The id of the artist.
 * @return {URI} The artist URI.
 */
URI.artistURI = function(id) {
  return new URI(URI.Type.ARTIST, {id: id});
};

/**
 * Creates a new 'artist-toplist' type URI.
 *
 * @param {string} id The id of the artist.
 * @param {string} toplist The toplist type.
 * @return {URI} The artist-toplist URI.
 */
URI.artistToplistURI = function(id, toplist) {
  return new URI(URI.Type.ARTIST_TOPLIST, {id: id, toplist: toplist});
};

/**
 * Creates a new 'search' type URI.
 *
 * @param {string} query The unencoded search query.
 * @return {URI} The search URI
 */
URI.searchURI = function(query) {
  return new URI(URI.Type.SEARCH, {query: query});
};

/**
 * Creates a new 'track' type URI.
 *
 * @param {string} id The id of the track.
 * @param {string} anchor The point in the track formatted as mm:ss
 * @return {URI} The track URI.
 */
URI.trackURI = function(id, anchor) {
  return new URI(URI.Type.TRACK, {id: id, anchor: anchor});
};

/**
 * Creates a new 'trackset' type URI.
 *
 * @param {Array.<URI>} tracks An array of 'track' type URIs.
 * @param {string} name The name of the trackset.
 * @param {number} index The index in the trackset.
 * @return {URI} The trackset URI.
 */
URI.tracksetURI = function(tracks, name, index) {
  return new URI(URI.Type.TRACKSET, {
    tracks: tracks,
    name: name || '',
    index: isNaN(index) ? null : index
  });
};

/**
 * Creates a new 'facebook' type URI.
 *
 * @param {string} uid The user id.
 * @return {URI} The facebook URI.
 */
URI.facebookURI = function(uid) {
  return new URI(URI.Type.FACEBOOK, {uid: uid});
};

/**
 * Creates a new 'followers' type URI.
 *
 * @param {string} username The non-canonical username.
 * @return {URI} The followers URI.
 */
URI.followersURI = function(username) {
  return new URI(URI.Type.FOLLOWERS, {username: username});
};

/**
 * Creates a new 'following' type URI.
 *
 * @param {string} username The non-canonical username.
 * @return {URI} The following URI.
 */
URI.followingURI = function(username) {
  return new URI(URI.Type.FOLLOWING, {username: username});
};

/**
 * Creates a new 'playlist' type URI.
 *
 * @param {string} username The non-canonical username of the playlist owner.
 * @param {string} id The id of the playlist.
 * @return {URI} The playlist URI.
 */
URI.playlistURI = function(username, id) {
  return new URI(URI.Type.PLAYLIST, {username: username, id: id});
};

/**
 * Creates a new 'folder' type URI.
 *
 * @param {string} username The non-canonical username of the folder owner.
 * @param {string} id The id of the folder.
 * @return {URI} The folder URI.
 */
URI.folderURI = function(username, id) {
  return new URI(URI.Type.FOLDER, {username: username, id: id});
};

/**
 * Creates a new 'collectiontracklist' type URI.
 *
 * @param {string} username The non-canonical username of the collection owner.
 * @param {string} id The id of the tracklist.
 * @return {URI} The collectiontracklist URI.
 */
URI.collectionTrackList = function(username, id) {
  return new URI(URI.Type.COLLECTION_TRACK_LIST, {username: username, id: id});
};

/**
 * Creates a new 'starred' type URI.
 *
 * @param {string} username The non-canonical username of the starred list owner.
 * @return {URI} The starred URI.
 */
URI.starredURI = function(username) {
  return new URI(URI.Type.STARRED, {username: username});
};

/**
 * Creates a new 'user-toplist' type URI.
 *
 * @param {string} username The non-canonical username of the toplist owner.
 * @param {string} toplist The toplist type.
 * @return {URI} The user-toplist URI.
 */
URI.userToplistURI = function(username, toplist) {
  return new URI(URI.Type.USER_TOPLIST, {username: username, toplist: toplist});
};

/**
 * Creates a new 'user-top-tracks' type URI.
 *
 * @deprecated
 * @param {string} username The non-canonical username of the toplist owner.
 * @return {URI} The user-top-tracks URI.
 */
URI.userTopTracksURI = function(username) {
  return new URI(URI.Type.USER_TOP_TRACKS, {username: username});
};

/**
 * Creates a new 'toplist' type URI.
 *
 * @param {string} toplist The toplist type.
 * @param {string} country The country code for the toplist.
 * @param {boolean} global True if this is a global rather than a country list.
 * @return {URI} The toplist URI.
 */
URI.toplistURI = function(toplist, country, global) {
  return new URI(URI.Type.TOPLIST, {toplist: toplist, country: country, global: !!global});
};

/**
 * Creates a new 'inbox' type URI.
 *
 * @param {string} username The non-canonical username of the inbox owner.
 * @return {URI} The inbox URI.
 */
URI.inboxURI = function(username) {
  return new URI(URI.Type.INBOX, {username: username});
};

/**
 * Creates a new 'rootlist' type URI.
 *
 * @param {string} username The non-canonical username of the rootlist owner.
 * @return {URI} The rootlist URI.
 */
URI.rootlistURI = function(username) {
  return new URI(URI.Type.ROOTLIST, {username: username});
};

/**
 * Creates a new 'published-rootlist' type URI.
 *
 * @param {string} username The non-canonical username of the published-rootlist owner.
 * @return {URI} The published-rootlist URI.
 */
URI.publishedRootlistURI = function(username) {
  return new URI(URI.Type.PUBLISHED_ROOTLIST, {username: username});
};

/**
 * Creates a new 'local-artist' type URI.
 *
 * @param {string} artist The artist name.
 * @return {URI} The local-artist URI.
 */
URI.localArtistURI = function(artist) {
  return new URI(URI.Type.LOCAL_ARTIST, {artist: artist});
};

/**
 * Creates a new 'local-album' type URI.
 *
 * @param {string} artist The artist name.
 * @param {string} album The album name.
 * @return {URI} The local-album URI.
 */
URI.localAlbumURI = function(artist, album) {
  return new URI(URI.Type.LOCAL_ALBUM, {artist: artist, album: album});
};

/**
 * Creates a new 'local' type URI.
 *
 * @param {string} artist The artist name.
 * @param {string} album The album name.
 * @param {string} track The track name.
 * @param {number} duration The track duration in ms.
 * @return {URI} The local URI.
 */
URI.localURI = function(artist, album, track, duration) {
  return new URI(URI.Type.LOCAL, {
    artist: artist,
    album: album,
    track: track,
    duration: duration
  });
};

/**
 * Creates a new 'library' type URI.
 *
 * @param {string} username The non-canonical username of the rootlist owner.
 * @param {string} category The category of the library.
 * @return {URI} The library URI.
 */
URI.libraryURI = function(username, category) {
  return new URI(URI.Type.LIBRARY, {username: username, category: category});
};

/**
 * Creates a new 'collection' type URI.
 *
 * @param {string} username The non-canonical username of the rootlist owner.
 * @param {string} category The category of the collection.
 * @return {URI} The collection URI.
 */
URI.collectionURI = function(username, category) {
  return new URI(URI.Type.COLLECTION, {username: username, category: category});
};

/**
 * Creates a new 'temp-playlist' type URI.
 *
 * @param {string} origin The origin of the temporary playlist.
 * @param {string} data Additional data for the playlist.
 * @return {URI} The temp-playlist URI.
 */
URI.temporaryPlaylistURI = function(origin, data) {
  return new URI(URI.Type.TEMP_PLAYLIST, {origin: origin, data: data});
};

/**
 * Creates a new 'context-group' type URI.
 *
 * @deprecated
 * @param {string} origin The origin of the temporary playlist.
 * @param {string} name The name of the context group.
 * @return {URI} The context-group URI.
 */
URI.contextGroupURI = function(origin, name) {
  return new URI(URI.Type.CONTEXT_GROUP, {origin: origin, name: name});
};

/**
 * Creates a new 'profile' type URI.
 *
 * @param {string} username The non-canonical username of the rootlist owner.
 * @param {Array.<string>} args A list of arguments.
 * @return {URI} The profile URI.
 */
URI.profileURI = function(username, args) {
  return new URI(URI.Type.PROFILE, {username: username, args: args});
};

/**
 * Creates a new 'image' type URI.
 *
 * @param {string} id The id of the image.
 * @return {URI} The image URI.
 */
URI.imageURI = function(id) {
  return new URI(URI.Type.IMAGE, {id: id});
};

/**
 * Creates a new 'mosaic' type URI.
 *
 * @param {Array.<string>} ids The ids of the mosaic immages.
 * @return {URI} The mosaic URI.
 */
URI.mosaicURI = function(ids) {
  return new URI(URI.Type.MOSAIC, {ids: ids});
};

/**
 * Creates a new 'radio' type URI.
 *
 * @param {string} args The radio seed arguments.
 * @return {URI} The radio URI.
 */
URI.radioURI = function(args) {
  args = typeof args === 'undefined' ? '' : args;
  return new URI(URI.Type.RADIO, {args: args});
};

/**
 * Creates a new 'special' type URI.
 *
 * @param {Array.<string>} args An array containing the other arguments.
 * @return {URI} The special URI.
 */
URI.specialURI = function(args) {
  args = typeof args === 'undefined' ? [] : args;
  return new URI(URI.Type.SPECIAL, {args: args});
};

/**
 * Creates a new 'station' type URI.
 *
 * @param {Array.<string>} args An array of arguments for the station.
 * @return {URI} The station URI.
 */
URI.stationURI = function(args) {
  args = typeof args === 'undefined' ? [] : args;
  return new URI(URI.Type.STATION, {args: args});
};

/**
 * Creates a new 'application' type URI.
 *
 * @param {string} id The id of the application.
 * @param {Array.<string>} args An array containing the arguments to the app.
 * @return {URI} The application URI.
 */
URI.applicationURI = function(id, args) {
  args = typeof args === 'undefined' ? [] : args;
  return new URI(URI.Type.APPLICATION, {id: id, args: args});
};

/**
 * Creates a new 'collection-album' type URI.
 *
 * @param {string} username The non-canonical username of the rootlist owner.
 * @param {string} id The id of the album.
 * @return {URI} The collection-album URI.
 */
URI.collectionAlbumURI = function(username, id) {
  return new URI(URI.Type.COLLECTION_ALBUM, {username: username, id: id});
};

/**
 * Creates a new 'collection-album-missing' type URI.
 *
 * @param {string} username The non-canonical username of the rootlist owner.
 * @param {string} id The id of the album.
 * @return {URI} The collection-album-missing URI.
 */
URI.collectionMissingAlbumURI = function(username, id) {
  return new URI(URI.Type.COLLECTION_MISSING_ALBUM, {username: username, id: id});
};

/**
 * Creates a new 'collection-artist' type URI.
 *
 * @param {string} username The non-canonical username of the rootlist owner.
 * @param {string} id The id of the artist.
 * @return {URI} The collection-artist URI.
 */
URI.collectionArtistURI = function(username, id) {
  return new URI(URI.Type.COLLECTION_ARTIST, {username: username, id: id});
};

/**
 * Creates a new 'episode' type URI.
 *
 * @param {string} id The id of the episode.
 * @return {URI} The episode URI.
 */
URI.episodeURI = function(id) {
  return new URI(URI.Type.EPISODE, {id: id});
};

/**
 * Export public interface
 */
module.exports = URI;

},{"spotify-crypto/src/base62":361}]},{},[23]);
