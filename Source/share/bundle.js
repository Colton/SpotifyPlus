(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
module.exports = {
  "appName": "Teilen",
  "appDescription": "Teilen",
  "actionBackToSharing": "Zurück zum Teilen",
  "actionCancel": "Abbrechen",
  "actionClose": "Schließen",
  "actionConnect": "Verbinden",
  "actionDisconnect": "Verbindung trennen",
  "actionSend": "Senden",
  "actionInviteFriends": "Freunde einladen",
  "actionShare": "Teilen",
  "trackOrAlbumByArtist": "{0} von {1}",
  "playlistByPerson": "{0} von {1}",
  "connectToNetwork": "Verbinde dein {0} Konto",
  "couldNotFindUser": "Sorry, kein Ergebnis für diese Suche.",
  "errorTitle": "Fehler",
  "errorLocalFile": "Leider können lokale Dateien nicht geteilt werden.",
  "errorOpError": "Leider kann dies nicht geteilt werden.",
  "errorUnsupportedType": "Leider kannst du das nicht teilen.",
  "fieldEmail": "E-Mail",
  "fieldMessageAlbum": "Schreib etwas über dieses Album (optional)",
  "fieldMessageArtist": "Schreib etwas über diesen Künstler (optional)",
  "fieldMessagePlaylist": "Schreib etwas über diese Playlist (optional)",
  "fieldMessageTrack": "Schreib etwas über diesen Titel (optional)",
  "fieldPassword": "Kennwort",
  "fieldTo": "Name eines Freundes",
  "fieldUsername": "Benutzername",
  "optionsConnectError": "Verbindung fehlgeschlagen.",
  "optionsConnectFailed": "Benutzername oder Kennwort falsch. Bitte überprüfen und erneut versuchen.",
  "optionsDisclaimer": "Dein Kennwort wird nicht gespeichert.",
  "optionsStateConnectedAs": "Mit {0} verbinden als",
  "optionsStateNotConnected": "Nicht verbunden.",
  "optionsStateTumblrPostingTo": "Auf Tumblr posten auf",
  "optionsStateUnknown": "Vorübergehend nicht verfügbar.",
  "optionsTitle": "Einstellungen zum Teilen",
  "optionsLink": "Einstellungen",
  "optionsVisitSettings": "Nimm Änderungen in den <a href=\"spotify:app:settings\">Einstellungen</a> vor.",
  "playlistByPrefix": "von",
  "postTab": "An Follower posten",
  "searchForMusic": "Suche nach einem Song, Album oder Künstler",
  "sendTab": "Senden an...",
  "sendMusicTitle": "Musik senden",
  "shareTitle": "Teilen",
  "shareTo": "Auch posten auf",
  "shareToPlain": "Posten auf",
  "embedTab": "Einbetten",
  "embedTitle": "Teilen",
  "embedPreview": "Vorschau:",
  "embedCode": "Einbettungscode:",
  "embedSize": "Layout:",
  "embedSizeBasicLabel": "Basic",
  "embedSizeBasicDimensions": "200x25",
  "embedSizeDetailLabel": "Detail",
  "embedSizeDetailDimensions": "300x56",
  "embedAdvanced": "Weitere Optionen"
};
},{}],2:[function(require,module,exports){
module.exports = {
  "appName": "Κοινοποίηση",
  "appDescription": "Κοινοποίηση",
  "actionBackToSharing": "Επιστροφή στην Κοινοποίηση",
  "actionCancel": "Ακύρωση",
  "actionClose": "Κλείσιμο",
  "actionConnect": "Σύνδεση",
  "actionDisconnect": "Αποσύνδεση",
  "actionSend": "Αποστολή",
  "actionInviteFriends": "Κάλεσε φίλους",
  "actionShare": "Κοινοποίηση",
  "trackOrAlbumByArtist": "{0} από {1}",
  "playlistByPerson": "{0} από {1}",
  "connectToNetwork": "Σύνδεσε το λογαριασμό σου στο {0}",
  "couldNotFindUser": "Δυστυχώς, δεν βρέθηκαν αποτελέσματα.",
  "errorTitle": "Σφάλμα",
  "errorLocalFile": "Δυστυχώς, τα τοπικά αρχεία δεν μπορούν να κοινοποιηθούν.",
  "errorOpError": "Δυστυχώς, δεν ήταν δυνατή η κοινοποίηση αυτού του υλικού.",
  "errorUnsupportedType": "Δυστυχώς, αυτό δεν μπορείς να το κοινοποιήσεις.",
  "fieldEmail": "E-mail",
  "fieldMessageAlbum": "Πες κάτι για αυτό το άλμπουμ (Προαιρετικό)",
  "fieldMessageArtist": "Πες κάτι για αυτόν τον καλλιτέχνη (Προαιρετικό)",
  "fieldMessagePlaylist": "Πες κάτι για αυτή τη λίστα (Προαιρετικό)",
  "fieldMessageTrack": "Πες κάτι για αυτό το τραγούδι (Προαιρετικό)",
  "fieldPassword": "Κωδικός πρόσβασης",
  "fieldTo": "Πρόσθεσε ένα φίλο",
  "fieldUsername": "Όνομα χρήστη",
  "optionsConnectError": "Η σύνδεση απέτυχε.",
  "optionsConnectFailed": "Λάθος όνομα χρήστη ή κωδικός πρόσβασης. Έλεγξε και δοκίμασε ξανά.",
  "optionsDisclaimer": "Δεν θα αποθηκεύσουμε ποτέ τον κωδικό πρόσβασής σου.",
  "optionsStateConnectedAs": "Έχεις συνδεθεί στο {0} ως",
  "optionsStateNotConnected": "Δεν έχεις συνδεθεί.",
  "optionsStateTumblrPostingTo": "Δημοσίευση στο Tumblr στη διεύθυνση",
  "optionsStateUnknown": "Προσωρινά δεν είναι διαθέσιμο.",
  "optionsTitle": "Ρυθμίσεις κοινοποίησης",
  "optionsLink": "Ρυθμίσεις",
  "optionsVisitSettings": "Πήγαινε στις <a href=\"spotify:app:settings\">Ρυθμίσεις</a> για θέματα διαχείρισης.",
  "playlistByPrefix": "από",
  "postTab": "Δημοσίευση σε οπαδούς",
  "searchForMusic": "Αναζήτηση τραγουδιού, άλμπουμ ή καλλιτέχνη",
  "sendTab": "Αποστολή σε...",
  "sendMusicTitle": "Αποστολή μουσικής",
  "shareTitle": "Κοινοποίηση",
  "shareTo": "Δημοσίευση επίσης σε",
  "shareToPlain": "Ανάρτηση σε",
  "embedTab": "Ενσωμάτωση",
  "embedTitle": "Κοινοποίηση",
  "embedPreview": "Προεπισκόπηση:",
  "embedCode": "Κώδικας ενσωμάτωσης:",
  "embedSize": "Διάταξη:",
  "embedSizeBasicLabel": "Βασική",
  "embedSizeBasicDimensions": "200x25",
  "embedSizeDetailLabel": "Λεπτομέρειες",
  "embedSizeDetailDimensions": "300x56",
  "embedAdvanced": "Περισσότερες επιλογές"
};
},{}],3:[function(require,module,exports){
module.exports = {
  "appName": "Share",
  "appDescription": "Share",
  "actionBackToSharing": "Back to Sharing",
  "actionCancel": "Cancel",
  "actionClose": "Close",
  "actionConnect": "Connect",
  "actionDisconnect": "Disconnect",
  "actionSend": "Send",
  "actionInviteFriends": "Invite friends",
  "actionShare": "Share",
  "trackOrAlbumByArtist": "{0} by {1}",
  "playlistByPerson": "{0} by {1}",
  "connectToNetwork": "Connect your {0} account",
  "couldNotFindUser": "Sorry, no results could be found.",
  "errorTitle": "Error",
  "errorLocalFile": "Sorry, local files cannot be shared.",
  "errorOpError": "Sorry, unable to share this resource.",
  "errorUnsupportedType": "Sorry, you cannot share that.",
  "fieldEmail": "E-mail",
  "fieldMessageAlbum": "Say something about this album (Optional)",
  "fieldMessageArtist": "Say something about this artist (Optional)",
  "fieldMessagePlaylist": "Say something about this playlist (Optional)",
  "fieldMessageTrack": "Say something about this song (Optional)",
  "fieldPassword": "Password",
  "fieldTo": "Enter a friend's name",
  "fieldUsername": "Username",
  "optionsConnectError": "Failed to connect.",
  "optionsConnectFailed": "Incorrect username or password. Please double check and try again.",
  "optionsDisclaimer": "We will never store your password.",
  "optionsStateConnectedAs": "Connected to {0} as",
  "optionsStateNotConnected": "Not connected.",
  "optionsStateTumblrPostingTo": "Posting to Tumblr at",
  "optionsStateUnknown": "Temporarily Unavailable.",
  "optionsTitle": "Share Settings",
  "optionsLink": "Settings",
  "optionsVisitSettings": "Visit <a href=\"spotify:app:settings\">Settings</a> to manage.",
  "playlistByPrefix": "by",
  "postTab": "Post to followers",
  "searchForMusic": "Search for a song, album or artist",
  "sendTab": "Send to...",
  "sendMusicTitle": "Send Music",
  "shareTitle": "Share",
  "shareTo": "Also post to",
  "shareToPlain": "Post to",
  "embedTab": "Embed",
  "embedTitle": "Share",
  "embedPreview": "Preview:",
  "embedCode": "Embed code:",
  "embedSize": "Layout:",
  "embedSizeBasicLabel": "Basic",
  "embedSizeBasicDimensions": "200x25",
  "embedSizeDetailLabel": "Detail",
  "embedSizeDetailDimensions": "300x56",
  "embedAdvanced": "More options"
};
},{}],4:[function(require,module,exports){
module.exports = {
  "appName": "Compartir",
  "appDescription": "Compartir",
  "actionBackToSharing": "Regresar a compartir",
  "actionCancel": "Cancelar",
  "actionClose": "Cerrar",
  "actionConnect": "Conectar",
  "actionDisconnect": "Desconectar",
  "actionSend": "Enviar",
  "actionInviteFriends": "Invita a tus amigos",
  "actionShare": "Compartir",
  "trackOrAlbumByArtist": "{0} de {1}",
  "playlistByPerson": "{0} de {1}",
  "connectToNetwork": "Conectar tu cuenta {0}",
  "couldNotFindUser": "Lo sentimos, no se encontró ningún resultado.",
  "errorTitle": "Error",
  "errorLocalFile": "Lo sentimos, los archivos locales no pueden ser compartidos",
  "errorOpError": "Lo sentimos, no es posible compartir este medio.",
  "errorUnsupportedType": "Lo sentimos, no puedes compartir eso.",
  "fieldEmail": "E-mail",
  "fieldMessageAlbum": "Platícanos algo de este álbum (Opcional)",
  "fieldMessageArtist": "Platícanos algo de este artista (Opcional)",
  "fieldMessagePlaylist": "Platícanos algo sobre esta playlist (Opcional)",
  "fieldMessageTrack": "Platícanos algo de esta canción (Opcional)",
  "fieldPassword": "Contraseña",
  "fieldTo": "Escribe el nombre de un amigo",
  "fieldUsername": "Usuario",
  "optionsConnectError": "Falló el intento de conexión.",
  "optionsConnectFailed": "Nombre de usuario o contraseña incorrectos. Por favor revisa y vuelve a intentarlo.",
  "optionsDisclaimer": "Nunca guardaremos tu contraseña.",
  "optionsStateConnectedAs": "Conectado con {0} como",
  "optionsStateNotConnected": "No conectado.",
  "optionsStateTumblrPostingTo": "Publicando en Tumblr en",
  "optionsStateUnknown": "Temporalmente no disponible.",
  "optionsTitle": "Compartir configuración.",
  "optionsLink": "Preferencias",
  "optionsVisitSettings": "Ve a <a href=\"spotify:app:settings\">Configuración</a> para administrar.",
  "playlistByPrefix": "por",
  "postTab": "Publicar para seguidores",
  "searchForMusic": "Busca una canción, álbum o artista",
  "sendTab": "Enviar a...",
  "sendMusicTitle": "Envía música",
  "shareTitle": "Compartir",
  "shareTo": "También publicar en",
  "shareToPlain": "Publicar en",
  "embedTab": "Insertar",
  "embedTitle": "Compartir",
  "embedPreview": "Vista previa:",
  "embedCode": "Insertar código:",
  "embedSize": "Diseño:",
  "embedSizeBasicLabel": "Básico",
  "embedSizeBasicDimensions": "200x25",
  "embedSizeDetailLabel": "Detalle",
  "embedSizeDetailDimensions": "300x56",
  "embedAdvanced": "Más opciones"
};
},{}],5:[function(require,module,exports){
module.exports = {
  "appName": "Compartir",
  "appDescription": "Compartir",
  "actionBackToSharing": "Regresar a Compartir",
  "actionCancel": "Cancelar",
  "actionClose": "Cerrar",
  "actionConnect": "Conectar",
  "actionDisconnect": "Desconectar",
  "actionSend": "Enviar",
  "actionInviteFriends": "Invitar a amigos",
  "actionShare": "Compartir",
  "trackOrAlbumByArtist": "{0} de {1}",
  "playlistByPerson": "{0} de {1}",
  "connectToNetwork": "Conectar tu cuenta de {0}",
  "couldNotFindUser": "Lo sentimos, no se han encontrado resultados.",
  "errorTitle": "Error",
  "errorLocalFile": "Lo sentimos, pero no es posible compartir archivos locales.",
  "errorOpError": "Lo sentimos, pero no hemos podido compartir este recurso.",
  "errorUnsupportedType": "Lo sentimos, pero no es posible compartir eso.",
  "fieldEmail": "Correo electrónico",
  "fieldMessageAlbum": "Di algo acerca de este álbum (opcional)",
  "fieldMessageArtist": "Di algo acerca de este/a artista (opcional)",
  "fieldMessagePlaylist": "Di algo acerca de esta playlist (opcional)",
  "fieldMessageTrack": "Di algo acerca de esta canción (opcional)",
  "fieldPassword": "Contraseña",
  "fieldTo": "Introduce el nombre de un amigo",
  "fieldUsername": "Usuario",
  "optionsConnectError": "No se ha logrado conectar.",
  "optionsConnectFailed": "Nombre de usuario o contraseña incorrectos. Por favor, compruébalos e inténtalo de nuevo.",
  "optionsDisclaimer": "Nunca almacenaremos tu contraseña.",
  "optionsStateConnectedAs": "Conectado a {0} como",
  "optionsStateNotConnected": "No conectado.",
  "optionsStateTumblrPostingTo": "Publicando en Tumblr en",
  "optionsStateUnknown": "Temporalmente no disponible.",
  "optionsTitle": "Configuración de compartir",
  "optionsLink": "Preferencias",
  "optionsVisitSettings": "Entra en <a href=\"spotify:app:settings\">Configuración</a> para hacer ajustes.",
  "playlistByPrefix": "por",
  "postTab": "Publicar para los seguidores",
  "searchForMusic": "Busca una canción, álbum o artista",
  "sendTab": "Enviar a...",
  "sendMusicTitle": "Enviar música",
  "shareTitle": "Compartir",
  "shareTo": "Publicar también en",
  "shareToPlain": "Publicar en",
  "embedTab": "Incrustar",
  "embedTitle": "Compartir",
  "embedPreview": "Muestra preliminar:",
  "embedCode": "Código de incrustación:",
  "embedSize": "Maquetación:",
  "embedSizeBasicLabel": "Básico",
  "embedSizeBasicDimensions": "200x25",
  "embedSizeDetailLabel": "Detallado",
  "embedSizeDetailDimensions": "300x56",
  "embedAdvanced": "Más opciones"
};
},{}],6:[function(require,module,exports){
module.exports = {
  "appName": "Jaa",
  "appDescription": "Jaa",
  "actionBackToSharing": "Takaisin jakoon",
  "actionCancel": "Peruuta",
  "actionClose": "Sulje",
  "actionConnect": "Yhdistä",
  "actionDisconnect": "Katkaise yhteys",
  "actionSend": "Lähetä",
  "actionInviteFriends": "Kutsu kavereita",
  "actionShare": "Jaa",
  "trackOrAlbumByArtist": "{0} - {1}",
  "playlistByPerson": "{0} - {1}",
  "connectToNetwork": "Linkitä {0}-tilisi",
  "couldNotFindUser": "Tuloksia ei valitettavasti löytynyt.",
  "errorTitle": "Virhe",
  "errorLocalFile": "Paikallisia tiedostoja ei valitettavasti voi jakaa.",
  "errorOpError": "Valitettavasti tätä resurssia ei voi jakaa.",
  "errorUnsupportedType": "Sitä ei valitettavasti voi jakaa.",
  "fieldEmail": "Sähköposti",
  "fieldMessageAlbum": "Sano jotain tästä albumista (valinnainen)",
  "fieldMessageArtist": "Sano jotain tästä artistista (valinnainen)",
  "fieldMessagePlaylist": "Sano jotain tästä soittolistasta (valinnainen)",
  "fieldMessageTrack": "Sano jotain tästä kappaleesta (valinnainen)",
  "fieldPassword": "Salasana",
  "fieldTo": "Anna ystävän nimi",
  "fieldUsername": "Käyttäjätunnus",
  "optionsConnectError": "Yhteydenmuodostus epäonnistui.",
  "optionsConnectFailed": "Virheellinen käyttäjätunnus tai salasana. Tarkista ne ja yritä uudelleen.",
  "optionsDisclaimer": "Emme koskaan tallenna salasanaasi.",
  "optionsStateConnectedAs": "Yhdistetty kohteeseen {0} käyttäjänä",
  "optionsStateNotConnected": "Ei yhdistetty.",
  "optionsStateTumblrPostingTo": "Julkaistaan Tumblriin osoitteeseen",
  "optionsStateUnknown": "Tilapäisesti ei käytettävissä.",
  "optionsTitle": "Jaa-toiminnon asetukset",
  "optionsLink": "Asetukset",
  "optionsVisitSettings": "Voit hallita asetuksia <a href=\"spotify:app:settings\">Asetukset</a>-sivulla.",
  "playlistByPrefix": "tekijältä",
  "postTab": "Julkaise seuraajille",
  "searchForMusic": "Hae kappaletta, albumia tai artistia",
  "sendTab": "Lähetä kaverille…",
  "sendMusicTitle": "Lähetä musiikkia",
  "shareTitle": "Jaa",
  "shareTo": "Julkaise myös kohteessa",
  "shareToPlain": "Julkaise palveluun",
  "embedTab": "Upota",
  "embedTitle": "Jaa",
  "embedPreview": "Esikatselu:",
  "embedCode": "Upotettava koodi:",
  "embedSize": "Asettelu:",
  "embedSizeBasicLabel": "Perusnäkymä",
  "embedSizeBasicDimensions": "200 x 25",
  "embedSizeDetailLabel": "Yksityiskohtainen näkymä",
  "embedSizeDetailDimensions": "300 x 56",
  "embedAdvanced": "Lisää vaihtoehtoja"
};
},{}],7:[function(require,module,exports){
module.exports = {
  "appName": "Partager",
  "appDescription": "Partager",
  "actionBackToSharing": "Retour",
  "actionCancel": "Annuler",
  "actionClose": "Fermer",
  "actionConnect": "Connect",
  "actionDisconnect": "Déconnexion",
  "actionSend": "Envoyer",
  "actionInviteFriends": "Inviter des amis",
  "actionShare": "Partager",
  "trackOrAlbumByArtist": "{0} de {1}",
  "playlistByPerson": "{0} de {1}",
  "connectToNetwork": "Liez votre compte {0}",
  "couldNotFindUser": "Désolé! Aucun résultat n'a été trouvé.",
  "errorTitle": "Erreur",
  "errorLocalFile": "Vous ne pouvez pas partager de fichiers locaux.",
  "errorOpError": "Désolé! Impossible de partager cette ressource.",
  "errorUnsupportedType": "Désolé! Vous ne pouvez pas partager ça.",
  "fieldEmail": "Adresse courriel",
  "fieldMessageAlbum": "Donnez votre avis sur cet album (facultatif)",
  "fieldMessageArtist": "Donnez votre avis sur cet artiste (facultatif)",
  "fieldMessagePlaylist": "Donnez votre avis sur cette liste de lecture (facultatif)",
  "fieldMessageTrack": "Donnez votre avis sur cette chanson (facultatif)",
  "fieldPassword": "Mot de passe",
  "fieldTo": "Entrez le nom d'un ami",
  "fieldUsername": "Utilisateur",
  "optionsConnectError": "Échec de la connexion.",
  "optionsConnectFailed": "Nom d'utilisateur ou mot de passe incorrect. Veuillez vérifier et réessayer.",
  "optionsDisclaimer": "Nous n'enregistrons jamais votre mot de passe.",
  "optionsStateConnectedAs": "Connecté à {0} en tant que",
  "optionsStateNotConnected": "Non connecté.",
  "optionsStateTumblrPostingTo": "Publication sur Tumblr sur ",
  "optionsStateUnknown": "Temporairement indisponible.",
  "optionsTitle": "Paramètres de partage",
  "optionsLink": "Préférences",
  "optionsVisitSettings": "Afficher les <a href=\"spotify:app:settings\">paramètres</a> pour assurer la gestion.",
  "playlistByPrefix": "par",
  "postTab": "Publier pour les abonnés",
  "searchForMusic": "Rechercher une chanson, un album ou un artiste",
  "sendTab": "Envoyer vers...",
  "sendMusicTitle": "Envoyer de la musique",
  "shareTitle": "Partager",
  "shareTo": "Publier également sur",
  "shareToPlain": "Publier sur",
  "embedTab": "Intégré",
  "embedTitle": "Partager",
  "embedPreview": "Aperçu :",
  "embedCode": "Code intégré :",
  "embedSize": "Disposition :",
  "embedSizeBasicLabel": "De base",
  "embedSizeBasicDimensions": "200 x 25",
  "embedSizeDetailLabel": "Détail",
  "embedSizeDetailDimensions": "300 x 56",
  "embedAdvanced": "Plus d'options"
};
},{}],8:[function(require,module,exports){
module.exports = {
  "appName": "Partager",
  "appDescription": "Partager",
  "actionBackToSharing": "Retour",
  "actionCancel": "Annuler",
  "actionClose": "Fermer",
  "actionConnect": "Connecter",
  "actionDisconnect": "Déconnecter",
  "actionSend": "Envoyer",
  "actionInviteFriends": "Inviter des amis",
  "actionShare": "Partager",
  "trackOrAlbumByArtist": "{0} de {1}",
  "playlistByPerson": "{0} de {1}",
  "connectToNetwork": "Reliez votre compte {0}",
  "couldNotFindUser": "Aucun résultat",
  "errorTitle": "Erreur",
  "errorLocalFile": "Vous ne pouvez pas partager de fichiers locaux.",
  "errorOpError": "Impossible d'utiliser cette ressource.",
  "errorUnsupportedType": "Vous ne pouvez pas partager ça.",
  "fieldEmail": "Adresse e-mail",
  "fieldMessageAlbum": "Donnez votre avis sur cet album (facultatif)",
  "fieldMessageArtist": "Donnez votre avis sur cet artiste (facultatif)",
  "fieldMessagePlaylist": "Donnez votre avis sur cette playlist (facultatif)",
  "fieldMessageTrack": "Donnez votre avis sur ce titre (facultatif)",
  "fieldPassword": "Mot de passe",
  "fieldTo": "Nom d'un ami",
  "fieldUsername": "Utilisateur",
  "optionsConnectError": "Impossible de relier les comptes.",
  "optionsConnectFailed": "Nom d'utilisateur ou mot de passe incorrect. Merci de vérifier et de réessayer.",
  "optionsDisclaimer": "Nous n'enregistrons jamais votre mot de passe.",
  "optionsStateConnectedAs": "Connecté à {0} en tant que",
  "optionsStateNotConnected": "Non relié.",
  "optionsStateTumblrPostingTo": "Publication sur Tumblr sur ",
  "optionsStateUnknown": "Temporairement indisponible.",
  "optionsTitle": "Paramètres de partage",
  "optionsLink": "Préférences",
  "optionsVisitSettings": "Rendez-vous sur <a href=\"spotify:app:settings\">Paramètres</a> pour gérer.",
  "playlistByPrefix": "par",
  "postTab": "Poster pour les abonnés",
  "searchForMusic": "Rechercher un titre, album ou artiste",
  "sendTab": "Envoyer à...",
  "sendMusicTitle": "Envoyer de la musique",
  "shareTitle": "Partager",
  "shareTo": "Publier aussi sur",
  "shareToPlain": "Poster sur",
  "embedTab": "Embed",
  "embedTitle": "Partager",
  "embedPreview": "Aperçu :",
  "embedCode": "Code embed :",
  "embedSize": "Disposition :",
  "embedSizeBasicLabel": "De base",
  "embedSizeBasicDimensions": "200 x 25",
  "embedSizeDetailLabel": "Détail",
  "embedSizeDetailDimensions": "300 x 56",
  "embedAdvanced": "Plus d'options"
};
},{}],9:[function(require,module,exports){
module.exports = {
  "appName": "Megosztás",
  "appDescription": "Megosztás",
  "actionBackToSharing": "Vissza a megosztáshoz",
  "actionCancel": "Mégse",
  "actionClose": "Bezárás",
  "actionConnect": "Csatlakozás",
  "actionDisconnect": "Kapcsolat bontása",
  "actionSend": "Küldés",
  "actionInviteFriends": "Ismerősök meghívása",
  "actionShare": "Megosztás",
  "trackOrAlbumByArtist": "{1}: {0}",
  "playlistByPerson": "{1}: {0}",
  "connectToNetwork": "Csatlakoztasd {0}-fiókod",
  "couldNotFindUser": "Sajnos nem található eredmény.",
  "errorTitle": "Hiba",
  "errorLocalFile": "Helyi fájlokat sajnos nem lehet megosztani.",
  "errorOpError": "Sajnos ezt az erőforrást nem lehet megosztani.",
  "errorUnsupportedType": "Sajnos ezt nem oszthatod meg.",
  "fieldEmail": "Emailcím",
  "fieldMessageAlbum": "Mondj valamit erről az albumról (nem kötelező)",
  "fieldMessageArtist": "Mondj valamit erről az előadóról (nem kötelező)",
  "fieldMessagePlaylist": "Mondj valamit erről a lejátszási listáról (nem kötelező)",
  "fieldMessageTrack": "Mondj valamit erről a dalról (nem kötelező)",
  "fieldPassword": "Jelszó",
  "fieldTo": "Add meg egy barátod nevét",
  "fieldUsername": "Felhasználónév",
  "optionsConnectError": "Nem sikerült csatlakozni.",
  "optionsConnectFailed": "Helytelen felhasználónév vagy jelszó. Ellenőrizd újra, és próbáld meg ismét.",
  "optionsDisclaimer": "A jelszavad sosem fogjuk tárolni.",
  "optionsStateConnectedAs": "Kapcsolódva ehhez: {0} mint",
  "optionsStateNotConnected": "Nem kapcsolódik.",
  "optionsStateTumblrPostingTo": "Közzététel a Tumblren itt:",
  "optionsStateUnknown": "Ideiglenesen nem érhető el.",
  "optionsTitle": "Megosztási beállítások",
  "optionsLink": "Beállítások",
  "optionsVisitSettings": "Kezelés a <a href=\"spotify:app:settings\">Beállítások</a> pontban.",
  "playlistByPrefix": "tőle:",
  "postTab": "Megosztás a követőkkel",
  "searchForMusic": "Keress dalt, albumot vagy előadót",
  "sendTab": "Küldés neki...",
  "sendMusicTitle": "Zene küldése",
  "shareTitle": "Megosztás",
  "shareTo": "Posztolás:",
  "shareToPlain": "Posztolás ide:",
  "embedTab": "Beágyazás",
  "embedTitle": "Megosztás",
  "embedPreview": "Ízelítő:",
  "embedCode": "Kód beágyazása:",
  "embedSize": "Elrendezés:",
  "embedSizeBasicLabel": "Alap",
  "embedSizeBasicDimensions": "200x25",
  "embedSizeDetailLabel": "Részletes",
  "embedSizeDetailDimensions": "300x56",
  "embedAdvanced": "További lehetőségek"
};
},{}],10:[function(require,module,exports){
module.exports = {
  "appName": "Bagikan",
  "appDescription": "Bagikan",
  "actionBackToSharing": "Kembali ke Berbagi",
  "actionCancel": "Batalkan",
  "actionClose": "Tutup",
  "actionConnect": "Connect",
  "actionDisconnect": "Putuskan",
  "actionSend": "Kirim",
  "actionInviteFriends": "Undang teman",
  "actionShare": "Bagikan",
  "trackOrAlbumByArtist": "{0} dari {1}",
  "playlistByPerson": "{0} dari {1}",
  "connectToNetwork": "Aktifkan akun {0} kamu",
  "couldNotFindUser": "Maaf, tidak ada hasil yang ditemukan.",
  "errorTitle": "Kesalahan",
  "errorLocalFile": "Maaf, file lokal tidak dapat dibagikan.",
  "errorOpError": "Maaf, tidak dapat membagikan sumber daya ini.",
  "errorUnsupportedType": "Maaf, kamu tidak dapat membagikannya.",
  "fieldEmail": "Email",
  "fieldMessageAlbum": "Berikan pendapatmu tentang album ini (Opsional)",
  "fieldMessageArtist": "Berikan pendapatmu tentang artis ini (Opsional)",
  "fieldMessagePlaylist": "Berikan pendapatmu tentang playlist ini (Opsional)",
  "fieldMessageTrack": "Berikan pendapatmu tentang lagu ini (Opsional)",
  "fieldPassword": "Kata Sandi",
  "fieldTo": "Masukkan nama teman",
  "fieldUsername": "Nama Pengguna",
  "optionsConnectError": "Gagal menghubung,",
  "optionsConnectFailed": "Nama pengguna atau kata sandi salah. Silakan periksa dan coba kembali.",
  "optionsDisclaimer": "Kami tidak akan pernah menyimpan kata sandimu.",
  "optionsStateConnectedAs": "Terhubung ke {0} sebagai",
  "optionsStateNotConnected": "Tidak terhubung.",
  "optionsStateTumblrPostingTo": "Posting ke Tumblr di",
  "optionsStateUnknown": "Tidak Tersedia Untuk Sementara.",
  "optionsTitle": "Pengaturan Berbagi",
  "optionsLink": "Pengaturan",
  "optionsVisitSettings": "Buka <a href=\"spotify:app:settings\">Pengaturan</a> untuk mengelola.",
  "playlistByPrefix": "menurut",
  "postTab": "Posting ke pengikut",
  "searchForMusic": "Cari lagu, album atau artis",
  "sendTab": "Kirimkan ke...",
  "sendMusicTitle": "Kirim Musik",
  "shareTitle": "Bagikan",
  "shareTo": "Juga mengirim ke",
  "shareToPlain": "Posting ke",
  "embedTab": "Sematkan",
  "embedTitle": "Bagikan",
  "embedPreview": "Pratinjau:",
  "embedCode": "Sematkan kode:",
  "embedSize": "Tata letak:",
  "embedSizeBasicLabel": "Dasar",
  "embedSizeBasicDimensions": "200 x 25",
  "embedSizeDetailLabel": "Detail",
  "embedSizeDetailDimensions": "300 x 56",
  "embedAdvanced": "Opsi lainnya"
};
},{}],11:[function(require,module,exports){
'use strict';

// This file will likely become a generated file in the future. Please
// avoid adding extra APIs or exports here.

var i18n = require('../../../libs/spotify-i18n')({
  'de': require('./de.lang'),
  'el': require('./el.lang'),
  'en': require('./en.lang'),
  'es': require('./es.lang'),
  'es-419': require('./es-419.lang'),
  'fi': require('./fi.lang'),
  'fr': require('./fr.lang'),
  'fr-CA': require('./fr-CA.lang'),
  'hu': require('./hu.lang'),
  'id': require('./id.lang'),
  'it': require('./it.lang'),
  'ja': require('./ja.lang'),
  'nl': require('./nl.lang'),
  'pl': require('./pl.lang'),
  'pt-BR': require('./pt-BR.lang'),
  'sv': require('./sv.lang'),
  'tr': require('./tr.lang'),
  'zh-Hant': require('./zh-Hant.lang'),
  'zsm': require('./zsm.lang')
});

module.exports = i18n;

},{"../../../libs/spotify-i18n":106,"./de.lang":1,"./el.lang":2,"./en.lang":3,"./es-419.lang":4,"./es.lang":5,"./fi.lang":6,"./fr-CA.lang":7,"./fr.lang":8,"./hu.lang":9,"./id.lang":10,"./it.lang":12,"./ja.lang":13,"./nl.lang":14,"./pl.lang":15,"./pt-BR.lang":16,"./sv.lang":17,"./tr.lang":18,"./zh-Hant.lang":19,"./zsm.lang":20}],12:[function(require,module,exports){
module.exports = {
  "appName": "Condividi",
  "appDescription": "Condividi",
  "actionBackToSharing": "Torna alla condivisione",
  "actionCancel": "Annulla",
  "actionClose": "Chiudi",
  "actionConnect": "Connettiti",
  "actionDisconnect": "Disconnetti",
  "actionSend": "Invia",
  "actionInviteFriends": "Invita gli amici",
  "actionShare": "Condividi",
  "trackOrAlbumByArtist": "{0} di {1}",
  "playlistByPerson": "{0} di {1}",
  "connectToNetwork": "Collega il tuo account {0}",
  "couldNotFindUser": "Spiacente, non sono stati trovati risultati.",
  "errorTitle": "Errore",
  "errorLocalFile": "Spiacenti, ma i file locali non possono essere condivisi.",
  "errorOpError": "Spiacenti. Impossibile condividere questa risorsa.",
  "errorUnsupportedType": "Spiacenti, ma non puoi condividere questo elemento.",
  "fieldEmail": "E-mail",
  "fieldMessageAlbum": "Cosa pensi di questo album? (opzionale)",
  "fieldMessageArtist": "Di' cosa pensi di questo artista (opzionale)",
  "fieldMessagePlaylist": "Di' cosa pensi di questa playlist (opzionale)",
  "fieldMessageTrack": "Di' cosa pensi di questo brano (opzionale)",
  "fieldPassword": "Password",
  "fieldTo": "Nome di un amico",
  "fieldUsername": "Username",
  "optionsConnectError": "Impossibile connettersi.",
  "optionsConnectFailed": "Username o password errati. Ricontrolla e riprova.",
  "optionsDisclaimer": "Non salveremo mai la tua password.",
  "optionsStateConnectedAs": "Connesso a {0} come",
  "optionsStateNotConnected": "Non connesso.",
  "optionsStateTumblrPostingTo": "Posta su Tumblr in",
  "optionsStateUnknown": "Temporaneamente non disponibile.",
  "optionsTitle": "Impostazioni Condivisione",
  "optionsLink": "Impostazioni",
  "optionsVisitSettings": "Visita <a href=\"spotify:app:settings\">Impostazioni</a> per gestire.",
  "playlistByPrefix": "per",
  "postTab": "Posta ai follower",
  "searchForMusic": "Cerca un brano, un album o un artista",
  "sendTab": "Invia a...",
  "sendMusicTitle": "Invia musica",
  "shareTitle": "Condividi",
  "shareTo": "Posta anche su",
  "shareToPlain": "Pubblica su",
  "embedTab": "Incorpora",
  "embedTitle": "Condividi",
  "embedPreview": "Anteprima:",
  "embedCode": "Codice di incorporamento:",
  "embedSize": "Layout:",
  "embedSizeBasicLabel": "Di base",
  "embedSizeBasicDimensions": "200x25",
  "embedSizeDetailLabel": "Dettagli",
  "embedSizeDetailDimensions": "300x56",
  "embedAdvanced": "Altre opzioni"
};
},{}],13:[function(require,module,exports){
module.exports = {
  "appName": "共有",
  "appDescription": "共有",
  "actionBackToSharing": "共有に戻る",
  "actionCancel": "キャンセル",
  "actionClose": "閉じる",
  "actionConnect": "接続",
  "actionDisconnect": "切断",
  "actionSend": "送信",
  "actionInviteFriends": "友人を招待",
  "actionShare": "共有",
  "trackOrAlbumByArtist": "{1}の{0}",
  "playlistByPerson": "{1}の{0}",
  "connectToNetwork": "自分の{0}アカウントに接続",
  "couldNotFindUser": "残念ですが、結果が見つかりませんでした。",
  "errorTitle": "エラー",
  "errorLocalFile": "残念ながら、ローカルファイルは共有できません。",
  "errorOpError": "残念ながら、このリソースは共有できません。",
  "errorUnsupportedType": "残念ながら、これは共有できません。",
  "fieldEmail": "Eメール",
  "fieldMessageAlbum": "このアルバムについてのコメント(任意)",
  "fieldMessageArtist": "このアーティストについてのコメント(任意)",
  "fieldMessagePlaylist": "このプレイリストについてのコメント(任意)",
  "fieldMessageTrack": "この曲についてのコメント(任意)",
  "fieldPassword": "パスワード",
  "fieldTo": "名前を入力",
  "fieldUsername": "ユーザー名",
  "optionsConnectError": "接続に失敗しました。",
  "optionsConnectFailed": "ユーザー名またはパスワードが間違っています。再度確認してもう一度お試しください。",
  "optionsDisclaimer": "Spotifyはパスワードを保存しません。",
  "optionsStateConnectedAs": "次のアカウントで{0}に接続しました:",
  "optionsStateNotConnected": "接続されていません。",
  "optionsStateTumblrPostingTo": "次のTumblrに投稿する",
  "optionsStateUnknown": "一時的に利用不可です。",
  "optionsTitle": "設定を共有",
  "optionsLink": "設定",
  "optionsVisitSettings": "管理するには[<a href=\"spotify:app:settings\">設定</a>]にアクセス",
  "playlistByPrefix": "/",
  "postTab": "フォロワーに投稿する",
  "searchForMusic": "曲、アルバムまたはアーティストを検索",
  "sendTab": "メッセージで送信...",
  "sendMusicTitle": "曲を送る",
  "shareTitle": "共有",
  "shareTo": " シェアする･･･",
  "shareToPlain": "投稿先",
  "embedTab": "埋め込む",
  "embedTitle": "共有",
  "embedPreview": "プレビュー: ",
  "embedCode": "埋め込みコード",
  "embedSize": "レイアウト: ",
  "embedSizeBasicLabel": "基本",
  "embedSizeBasicDimensions": "200x25",
  "embedSizeDetailLabel": "詳細",
  "embedSizeDetailDimensions": "300x56",
  "embedAdvanced": "その他のオプション"
};
},{}],14:[function(require,module,exports){
module.exports = {
  "appName": "Delen",
  "appDescription": "Delen",
  "actionBackToSharing": "Terug naar Delen",
  "actionCancel": "Annuleren",
  "actionClose": "Sluiten",
  "actionConnect": "Verbinden",
  "actionDisconnect": "Verbinding verbreken",
  "actionSend": "Verzenden",
  "actionInviteFriends": "Vrienden uitnodigen",
  "actionShare": "Delen",
  "trackOrAlbumByArtist": "{0} van {1}",
  "playlistByPerson": "{0} van {1}",
  "connectToNetwork": "Koppel je {0} account",
  "couldNotFindUser": "Er zijn helaas geen resultaten gevonden.",
  "errorTitle": "Fout",
  "errorLocalFile": "Lokale bestanden kunnen helaas niet worden gedeeld.",
  "errorOpError": "Deze bron kan helaas niet worden gedeeld.",
  "errorUnsupportedType": "Dat kun je helaas niet delen.",
  "fieldEmail": "E-mail",
  "fieldMessageAlbum": "Zeg iets over dit album (optioneel)",
  "fieldMessageArtist": "Zeg iets over deze artiest (optioneel)",
  "fieldMessagePlaylist": "Zeg iets over deze afspeellijst (optioneel)",
  "fieldMessageTrack": "Zeg iets over dit nummer (optioneel)",
  "fieldPassword": "Wachtwoord",
  "fieldTo": "naam van een vriend ",
  "fieldUsername": "Gebruikersnaam",
  "optionsConnectError": "Koppeling mislukt.",
  "optionsConnectFailed": "Onjuiste gebruikersnaam of wachtwoord. Controleer het nog eens en probeer het opnieuw.",
  "optionsDisclaimer": "We zullen je wachtwoord nooit opslaan.",
  "optionsStateConnectedAs": "Gekoppeld met {0} als",
  "optionsStateNotConnected": "Niet gekoppeld.",
  "optionsStateTumblrPostingTo": "Posten op Tumblr-pagina",
  "optionsStateUnknown": "Tijdelijk niet beschikbaar.",
  "optionsTitle": "Instellingen voor delen",
  "optionsLink": "Instellingen",
  "optionsVisitSettings": "Ga naar <a href=\"spotify:app:settings\">Instellingen</a> om te beheren.",
  "playlistByPrefix": "van",
  "postTab": "Posten naar volgers",
  "searchForMusic": "Zoek een nummer, album of artiest",
  "sendTab": "Versturen naar...",
  "sendMusicTitle": "Muziek versturen",
  "shareTitle": "Delen",
  "shareTo": "Ook posten op",
  "shareToPlain": "Plaatsen op",
  "embedTab": "Insluiten",
  "embedTitle": "Delen",
  "embedPreview": "Voorbeeld:",
  "embedCode": "Insluitcode:",
  "embedSize": "Opmaak:",
  "embedSizeBasicLabel": "Standaard",
  "embedSizeBasicDimensions": "200x25",
  "embedSizeDetailLabel": "Gedetailleerd",
  "embedSizeDetailDimensions": "300x56",
  "embedAdvanced": "Meer opties"
};
},{}],15:[function(require,module,exports){
module.exports = {
  "appName": "Udostępnij",
  "appDescription": "Udostępnij",
  "actionBackToSharing": "Powrót do udostępniania",
  "actionCancel": "Anuluj",
  "actionClose": "Zakończ",
  "actionConnect": "Połącz",
  "actionDisconnect": "Rozłącz",
  "actionSend": "Wyślij",
  "actionInviteFriends": "Zaproś znajomych",
  "actionShare": "Udostępnij",
  "trackOrAlbumByArtist": "{0} - {1}",
  "playlistByPerson": "{0} - {1}",
  "connectToNetwork": "Powiąż ze swoim kontem {0}",
  "couldNotFindUser": "Niestety nie można było znaleźć żadnych wyników.",
  "errorTitle": "Błąd",
  "errorLocalFile": "Uwaga: pliki zapisane lokalnie nie mogą być udostępniane.",
  "errorOpError": "Niestety nie można udostępnić tych zasobów.",
  "errorUnsupportedType": "Przepraszamy, nie możesz tego udostępnić.",
  "fieldEmail": "E-mail",
  "fieldMessageAlbum": "Powiedz coś o tym albumie (opcja)",
  "fieldMessageArtist": "Powiedz coś o tym wykonawcy (opcja)",
  "fieldMessagePlaylist": "Powiedz coś o tej playliście (opcja)",
  "fieldMessageTrack": "Powiedz coś o tym utworze (opcja)",
  "fieldPassword": "Hasło",
  "fieldTo": "Wpisz nazwisko znajomego",
  "fieldUsername": "Nazwa użytkownika",
  "optionsConnectError": "Połączenie nie powiodło się.",
  "optionsConnectFailed": "Nieprawidłowa nazwa użytkownika lub hasło. Sprawdź poprawność wpisanych danych i spróbuj ponownie.",
  "optionsDisclaimer": "Nigdy nie przechowujemy haseł.",
  "optionsStateConnectedAs": "Połączono z kontem {0} jako",
  "optionsStateNotConnected": "Brak połączenia.",
  "optionsStateTumblrPostingTo": "Wysyłanie do Tumblr -",
  "optionsStateUnknown": "Chwilowo niedostępne.",
  "optionsTitle": "Ustawienia udostępniania",
  "optionsLink": "Ustawienia",
  "optionsVisitSettings": "Wejdź w <a href=\"spotify:app:settings\">Ustawienia</a>, aby zarządzać.",
  "playlistByPrefix": "według",
  "postTab": "Opublikuj dla obserwujących",
  "searchForMusic": "Szukaj utworu, albumu lub wykonawcy",
  "sendTab": "Wyślij do...",
  "sendMusicTitle": "Wyślij muzykę",
  "shareTitle": "Udostępnij",
  "shareTo": "Publikuj również w serwisie",
  "shareToPlain": "Publikuj na",
  "embedTab": "Osadź",
  "embedTitle": "Udostępnij",
  "embedPreview": "Podgląd:",
  "embedCode": "Osadź kod:",
  "embedSize": "Układ:",
  "embedSizeBasicLabel": "Podstawowy",
  "embedSizeBasicDimensions": "200 x 25",
  "embedSizeDetailLabel": "Szczegóły",
  "embedSizeDetailDimensions": "300 x 56",
  "embedAdvanced": "Więcej opcji"
};
},{}],16:[function(require,module,exports){
module.exports = {
  "appName": "Compartilhar",
  "appDescription": "Compartilhar",
  "actionBackToSharing": "Voltar ao compartilhamento",
  "actionCancel": "Cancelar",
  "actionClose": "Fechar",
  "actionConnect": "Conectar",
  "actionDisconnect": "Desconectar",
  "actionSend": "Mandar",
  "actionInviteFriends": "Convidar amigos",
  "actionShare": "Compartilhar",
  "trackOrAlbumByArtist": "{0} de {1}",
  "playlistByPerson": "{0} de {1}",
  "connectToNetwork": "Conectar sua conta do {0}",
  "couldNotFindUser": "Desculpe, não foi possível encontrar resultados.",
  "errorTitle": "Erro",
  "errorLocalFile": "Desculpe, não é possível compartilhar arquivos locais.",
  "errorOpError": "Desculpe, não é possível compartilhar este recurso.",
  "errorUnsupportedType": "Desculpe, você não pode compartilhar isso.",
  "fieldEmail": "E-mail",
  "fieldMessageAlbum": "Diga algo sobre este álbum (opcional)",
  "fieldMessageArtist": "Diga algo sobre este artista (opcional)",
  "fieldMessagePlaylist": "Diga algo sobre esta playlist (opcional)",
  "fieldMessageTrack": "Diga algo sobre esta música (opcional)",
  "fieldPassword": "Senha",
  "fieldTo": "Nome do amigo",
  "fieldUsername": "Nome de usuário",
  "optionsConnectError": "Falha na conexão.",
  "optionsConnectFailed": "Nome de usuário ou senha incorretos. Confirme e tente de novo.",
  "optionsDisclaimer": "Nós nunca armazenamos sua senha.",
  "optionsStateConnectedAs": "Conectado a {0} como",
  "optionsStateNotConnected": "Não conectado.",
  "optionsStateTumblrPostingTo": "Postando no Tumblr em",
  "optionsStateUnknown": "Temporariamente indisponível.",
  "optionsTitle": "Compartilhar configurações",
  "optionsLink": "Preferências",
  "optionsVisitSettings": "Acesse <a href=\"spotify:app:settings\">Configurar</a> para gerenciar.",
  "playlistByPrefix": "de",
  "postTab": "Postar para os seguidores",
  "searchForMusic": "Busque uma música, um álbum ou artista",
  "sendTab": "Mandar para...",
  "sendMusicTitle": "Mandar músicas",
  "shareTitle": "Compartilhar",
  "shareTo": "Também postar no",
  "shareToPlain": "Postar no",
  "embedTab": "Incorporar",
  "embedTitle": "Compartilhar",
  "embedPreview": "Prévia:",
  "embedCode": "Código para incorporar:",
  "embedSize": "Layout:",
  "embedSizeBasicLabel": "Básico",
  "embedSizeBasicDimensions": "200x25",
  "embedSizeDetailLabel": "Detalhado",
  "embedSizeDetailDimensions": "300x56",
  "embedAdvanced": "Mais opções"
};
},{}],17:[function(require,module,exports){
module.exports = {
  "appName": "Dela",
  "appDescription": "Dela",
  "actionBackToSharing": "Tillbaka till Delning",
  "actionCancel": "Avbryt",
  "actionClose": "Stäng",
  "actionConnect": "Anslut",
  "actionDisconnect": "Koppla från",
  "actionSend": "Skicka",
  "actionInviteFriends": "Bjud in vänner",
  "actionShare": "Dela",
  "trackOrAlbumByArtist": "{0} av {1}",
  "playlistByPerson": "{0} av {1}",
  "connectToNetwork": "Anslut ditt {0}-konto",
  "couldNotFindUser": "Det gick inte att hitta några resultat.",
  "errorTitle": "Fel",
  "errorLocalFile": "Tyvärr går det inte att dela lokala filer.",
  "errorOpError": "Tyvärr går det inte att dela den här resursen.",
  "errorUnsupportedType": "Tyvärr kan du inte dela det.",
  "fieldEmail": "E-post",
  "fieldMessageAlbum": "Säg något om det här albumet (valfritt)",
  "fieldMessageArtist": "Säg något om den här artisten (valfritt)",
  "fieldMessagePlaylist": "Säg något om den här spellistan (valfritt)",
  "fieldMessageTrack": "Säg något om den här låten (valfritt)",
  "fieldPassword": "Lösenord",
  "fieldTo": "Skriv en väns namn",
  "fieldUsername": "Användarnamn",
  "optionsConnectError": "Det gick inte att ansluta.",
  "optionsConnectFailed": "Fel användarnamn eller lösenord. Dubbelkolla och försök igen.",
  "optionsDisclaimer": "Vi lagrar aldrig ditt lösenord.",
  "optionsStateConnectedAs": "Ansluten till {0} som",
  "optionsStateNotConnected": "Inte ansluten.",
  "optionsStateTumblrPostingTo": "Dela på Tumblr på",
  "optionsStateUnknown": "Tillfälligt otillgänglig.",
  "optionsTitle": "Delningsinställningar",
  "optionsLink": "Inställningar",
  "optionsVisitSettings": "Öppna <a href=\"spotify:app:settings\">Inställningar</a> för att hantera.",
  "playlistByPrefix": "av",
  "postTab": "Dela med följare",
  "searchForMusic": "Sök efter ett spår, ett album eller en artist",
  "sendTab": "Skicka till …",
  "sendMusicTitle": "Skicka musik",
  "shareTitle": "Dela",
  "shareTo": "Dela också på",
  "shareToPlain": "Dela på",
  "embedTab": "Bädda in",
  "embedTitle": "Dela",
  "embedPreview": "Förhandsgranska:",
  "embedCode": "Inbäddningskod:",
  "embedSize": "Layout:",
  "embedSizeBasicLabel": "Enkel",
  "embedSizeBasicDimensions": "200 × 25",
  "embedSizeDetailLabel": "Detaljerad",
  "embedSizeDetailDimensions": "300 × 56",
  "embedAdvanced": "Fler alternativ"
};
},{}],18:[function(require,module,exports){
module.exports = {
  "appName": "Paylaş",
  "appDescription": "Paylaş",
  "actionBackToSharing": "Paylaşıma geri git",
  "actionCancel": "İptal",
  "actionClose": "Kapat",
  "actionConnect": "Bağlan",
  "actionDisconnect": "Bağlantıyı kes",
  "actionSend": "Gönder",
  "actionInviteFriends": "Arkadaşları davet et",
  "actionShare": "Paylaş",
  "trackOrAlbumByArtist": "{0} - {1}",
  "playlistByPerson": "{0} - {1}",
  "connectToNetwork": "{0} hesabına bağlan",
  "couldNotFindUser": "Üzgünüz, sonuç bulunamadı.",
  "errorTitle": "Hata",
  "errorLocalFile": "Üzgünüz, yerel dosyalar paylaşılamıyor.",
  "errorOpError": "Üzgünüz, bu kaynak paylaşılamıyor.",
  "errorUnsupportedType": "Üzgünüz, bunu paylaşamazsın.",
  "fieldEmail": "E-posta",
  "fieldMessageAlbum": "Bu albüm hakkında bir şey yaz (İsteğe bağlı)",
  "fieldMessageArtist": "Bu sanatçı hakkında bir şey yaz (İsteğe bağlı)",
  "fieldMessagePlaylist": "Bu çalma list. hakkında bir şey yaz (İsteğe bağlı)",
  "fieldMessageTrack": "Bu şarkı hakkında bir şey yaz (İsteğe bağlı)",
  "fieldPassword": "Parola",
  "fieldTo": "Bir arkadaşın adını gir",
  "fieldUsername": "Kullanıcı adı",
  "optionsConnectError": "Bağlanılamadı.",
  "optionsConnectFailed": "Kullanıcı adı veya parola yanlış. Lütfen tekrar kontrol et ve yeniden dene.",
  "optionsDisclaimer": "Parolanı asla kaydetmeyiz.",
  "optionsStateConnectedAs": "{0} hesabına bağlanıldı:",
  "optionsStateNotConnected": "Bağlı değil.",
  "optionsStateTumblrPostingTo": "Tumblr'da yayınlanıyor:",
  "optionsStateUnknown": "Geçici Olarak Kullanılamıyor.",
  "optionsTitle": "Ayarları Paylaş",
  "optionsLink": "Ayarlar",
  "optionsVisitSettings": "Yönetmek için <a href=\"spotify:app:settings\">Ayarlar</a>'a git.",
  "playlistByPrefix": "-",
  "postTab": "Takipçilerinle paylaş",
  "searchForMusic": "Şarkı, albüm veya sanatçı ara",
  "sendTab": "Gönder...",
  "sendMusicTitle": "Müzik Gönder",
  "shareTitle": "Paylaş",
  "shareTo": "Ayrıca şurada yayınla:",
  "shareToPlain": "Yayınlanacağı yer",
  "embedTab": "Yerleştir",
  "embedTitle": "Paylaş",
  "embedPreview": "Önizle:",
  "embedCode": "Kodu yerleştir:",
  "embedSize": "Düzen:",
  "embedSizeBasicLabel": "Temel",
  "embedSizeBasicDimensions": "200x25",
  "embedSizeDetailLabel": "Ayrıntı",
  "embedSizeDetailDimensions": "300x56",
  "embedAdvanced": "Diğer seçenekler"
};
},{}],19:[function(require,module,exports){
module.exports = {
  "appName": "分享",
  "appDescription": "分享",
  "actionBackToSharing": "返回分享",
  "actionCancel": "取消",
  "actionClose": "關閉",
  "actionConnect": "連線",
  "actionDisconnect": "中斷連線",
  "actionSend": "傳送",
  "actionInviteFriends": "邀請好友",
  "actionShare": "分享",
  "trackOrAlbumByArtist": "{1} 的 {0}",
  "playlistByPerson": "{1} 的 {0}",
  "connectToNetwork": "連接你的 {0} 帳戶",
  "couldNotFindUser": "抱歉，找不到結果。",
  "errorTitle": "錯誤",
  "errorLocalFile": "很抱歉，無法分享本機檔案。",
  "errorOpError": "對不起，無法分享此項資源。",
  "errorUnsupportedType": "很抱歉，你不可以分享該檔案。",
  "fieldEmail": "電子郵件",
  "fieldMessageAlbum": "表達有關此專輯的意見 (可選擇填寫)",
  "fieldMessageArtist": "表達有關此歌手的意見 (可選擇填寫)",
  "fieldMessagePlaylist": "表達有關此播放清單的意見 (可選擇填寫)",
  "fieldMessageTrack": "表達有關此歌曲的意見 (可選擇填寫)",
  "fieldPassword": "密碼",
  "fieldTo": "輸入好友的名稱",
  "fieldUsername": "用戶名",
  "optionsConnectError": "連線失敗。",
  "optionsConnectFailed": "使用者名稱或密碼錯誤。請再檢查並重試。",
  "optionsDisclaimer": "我們絕對不會保存你的密碼。",
  "optionsStateConnectedAs": "連接到 {0} 為",
  "optionsStateNotConnected": "未連接。",
  "optionsStateTumblrPostingTo": "正在發佈至 Tumblr 的",
  "optionsStateUnknown": "暫時無法使用。",
  "optionsTitle": "分享設定",
  "optionsLink": "設定",
  "optionsVisitSettings": "前往<a href=\"spotify:app:settings\">設定</a>即可進行管理。",
  "playlistByPrefix": "－",
  "postTab": "和粉絲分享",
  "searchForMusic": "搜尋歌曲、專輯或藝人",
  "sendTab": "發送到...",
  "sendMusicTitle": "發送音樂",
  "shareTitle": "分享",
  "shareTo": "同樣發佈到",
  "shareToPlain": "發佈至",
  "embedTab": "嵌入",
  "embedTitle": "分享",
  "embedPreview": "預覽：",
  "embedCode": "嵌入代碼：",
  "embedSize": "版面：",
  "embedSizeBasicLabel": "基本",
  "embedSizeBasicDimensions": "200x25",
  "embedSizeDetailLabel": "詳細",
  "embedSizeDetailDimensions": "300x56",
  "embedAdvanced": "更多選項"
};
},{}],20:[function(require,module,exports){
module.exports = {
  "appName": "Kongsi",
  "appDescription": "Kongsi",
  "actionBackToSharing": "Kembali ke Berkongsi",
  "actionCancel": "Batal",
  "actionClose": "Tutup",
  "actionConnect": "Sambung",
  "actionDisconnect": "Putuskan sambungan",
  "actionSend": "Hantar",
  "actionInviteFriends": "Jemput rakan",
  "actionShare": "Kongsi",
  "trackOrAlbumByArtist": "{0} oleh {1}",
  "playlistByPerson": "{0} oleh {1}",
  "connectToNetwork": "Sambung ke akaun {0} anda",
  "couldNotFindUser": "Maaf, tiada hasil boleh ditemui.",
  "errorTitle": "Ralat",
  "errorLocalFile": "Maaf, fail setempat tidak boleh dikongsi.",
  "errorOpError": "Maaf, tidak dapat berkongsi sumber ini.",
  "errorUnsupportedType": "Maaf, anda tidak boleh berkongsi itu.",
  "fieldEmail": "E-mel",
  "fieldMessageAlbum": "Nyatakan sesuatu mengenai album ini (Pilihan)",
  "fieldMessageArtist": "Nyatakan sesuatu mengenai artis ini (Pilihan)",
  "fieldMessagePlaylist": "Nyatakan sesuatu mengenai senarai main ini (Pilihan)",
  "fieldMessageTrack": "Nyatakan sesuatu mengenai lagu ini (Pilihan)",
  "fieldPassword": "Kata laluan",
  "fieldTo": "Masukkan nama rakan",
  "fieldUsername": "Nama pengguna",
  "optionsConnectError": "Gagal untuk menyambung",
  "optionsConnectFailed": "Nama pengguna atau kata laluan salah. Sila periksa semula dan cuba lagi.",
  "optionsDisclaimer": "Kami tidak akan sekali-kali menyimpan kata laluan anda.",
  "optionsStateConnectedAs": "Disambung ke {0} sebagai",
  "optionsStateNotConnected": "Tidak disambung.",
  "optionsStateTumblrPostingTo": "Mengepos ke Tumblr pada",
  "optionsStateUnknown": "Buat Sementara Tidak Tersedia.",
  "optionsTitle": "Tetapan Kongsi",
  "optionsLink": "Tetapan",
  "optionsVisitSettings": "Lawati <a href=\"spotify:app:settings\">Tetapan</a> untuk menguruskan.",
  "playlistByPrefix": "oleh",
  "postTab": "Pos kepada pengikut",
  "searchForMusic": "Cari lagu, album atau artis",
  "sendTab": "Hantar ke...",
  "sendMusicTitle": "Hantar Muzik",
  "shareTitle": "Kongsi",
  "shareTo": "Juga pos ke",
  "shareToPlain": "Pos ke",
  "embedTab": "Benamkan",
  "embedTitle": "Kongsi",
  "embedPreview": "Pratonton:",
  "embedCode": "Benamkan kod:",
  "embedSize": "Susun atur:",
  "embedSizeBasicLabel": "Asas",
  "embedSizeBasicDimensions": "200x25",
  "embedSizeDetailLabel": "Terperinci",
  "embedSizeDetailDimensions": "300x56",
  "embedAdvanced": "Lebih pilihan"
};
},{}],21:[function(require,module,exports){
module.exports={
  "name": "share",
  "version": "3.6.0",
  "license": "UNLICENSED",
  "main": "scripts/main.js",
  "publishConfig": {
    "registry": "http://npm-registry.spotify.net"
  },
  "private": true
}

},{}],22:[function(require,module,exports){
'use strict';

var elements = require('../../../libs/spotify-elements');
var URI = require('spotify-liburi');
var mainStrings = require('../i18n');
var inherit = require('spotify-inheritance/inherit');

var models = require('../../../libs/api-cjs/scripts/models');
var Logger = require('../../../libs/spotify-client-logger');
var debug = require('debug');
var Facebook = require('./networks/facebook').Facebook;
var Tumblr = require('./networks/tumblr').Tumblr;
var Twitter = require('./networks/twitter').Twitter;
var ErrorView = require('./views/error').ErrorView;
var OptionsView = require('./views/options').OptionsView;
var SendView = require('./views/send').SendView;
var ShareView = require('./views/share').ShareView;
var EmbedView = require('./views/embed').EmbedView;
var mediaObject = require('./utils/media-object');
var toggleHide = require('./utils/toggle-hide');
var pkg = require('../package.json');

var _ = mainStrings.get.bind(mainStrings); // Shortcut for translation.
var logSourceBase = 'spotify:app:' + pkg.name;

function ShareApp() {

  // Logger for ShareApp meant to user actions and generic errors.
  this.logger = new Logger();
  this.logger.setConstant({ source: logSourceBase });

  // Debug for ShareApp
  this.debug = debug(pkg.name);

  // Set up the ability to piecemeal update the template.
  this.resourceTemplate = mediaObject(document.getElementById('resource'));

  /**
   * Networks that the share widget supports sharing to.
   */
  this.networks = {
    'facebook': new Facebook(logSourceBase),
    'twitter': new Twitter(logSourceBase),
    'tumblr': new Tumblr(logSourceBase)
  };

  /**
   * Views supported by the share widget.
   */
  this.views = {
    'error': new ErrorView(this),
    'options': new OptionsView(this),
    'send': new SendView(this),
    'share': new ShareView(this),
    'embed': new EmbedView(this)
  };

  this.currentView = 'share'; // Set in HTML as default class name

  this.urlTitle = null; // used as a title or link's context in share post on socialnetworks

  // Bind listeners to the right context
  this._handleKeyPress = this._handleKeyPress.bind(this);
  this._onTabClick = this._onTabClick.bind(this);
  this._onShowOptionsView = this.showView.bind(this, this.views.options);
  this._onShowShareView = this.showView.bind(this, this.views.share);
  this._onCloseClick = this.clearStateAndExit.bind(this);
}
inherit(ShareApp, models.Observable);

ShareApp.prototype.setup = function () {
  var dataStrings = document.querySelectorAll('[data-string]');
  for (var i = 0; i < dataStrings.length; ++i) {
    var el = dataStrings[i];
    this._translateDataString(el, el.getAttribute('data-string'), el.getAttribute('data-attribute'));
  }

  document.addEventListener('keypress', this._handleKeyPress);
  document.getElementById('tabs').addEventListener('click', this._onTabClick);
  this.views.share.addEventListener('show_options_view', this._onShowOptionsView);
  this.views.options.addEventListener('show_share_view', this._onShowShareView);
  this.views.send.addEventListener('show_share_view', this._onShowShareView);
  this.views.error.addEventListener('close_click', this._onCloseClick);

  this.updateNetworksConnectedStates();

  this.containers = document.querySelectorAll('[data-container]');
};

ShareApp.prototype.reInit = function (sharedUri) {
  var self = this;

  // HACK ALERT: INVITE-MODE A/B test
  // Remove inviteMode from the app as soon as the invite-encouragment
  // a/b test (https://abtesting.spotify.net/#/tests/75) has ended.

  self.inviteMode = false;
  var specialString = '-invitemode-75jumpp3dp88lxaf';
  if (sharedUri.indexOf(specialString) > -1) {
    // Since the share dialog app does not have any interface
    // for passing any kinds of arguments, and adding that
    // would involve changing tons of layers of legacy code,
    // we just weld a special string suffix on top of the username
    // when calling models.client.showShareUI in Stitch
    // (because thats the only part of the uri that desktop won't validate)
    // and then remove it when received in the share app. We are specifically
    // using @ because to make sure it's an invalid username.
    sharedUri = sharedUri.replace(specialString, '');
    self.inviteMode = true;
  }

  // Re-show global nav.
  this.toggleGlobalNavDisplay(true);

  if (!!self.inviteMode) {
    var body = document.getElementsByTagName('body')[0];
    elements(body).addClass('invite-mode');
  }

  this.debug('reInit', { uri: sharedUri });

  var uri = URI.from(sharedUri);

  if (!uri || uri.type !== URI.Type.TRACK && uri.type !== URI.Type.ARTIST && uri.type !== URI.Type.ALBUM && uri.type !== URI.Type.PLAYLIST) {
    // TODO(sri) use translated lines for this. Also change "Close" button in HTML!
    this.showError(_('errorUnsupportedType'), 'unknown resource', sharedUri);
    return;
  }

  // If this resource can be embedded, show the Embed tab.
  this.resource = models.fromURI(sharedUri);

  if (!this.resource) {
    this.showError(_('errorLocalFile'), 'local file', sharedUri);
    return;
  }

  var defaultView = self.inviteMode ? 'send' : 'share';
  // Clear state if the local resource has changed
  if (localStorage.resource !== this.resource.uri) {
    this._clearState();

    // Remember current resource for drafts.
    localStorage.resource = this.resource.uri;
  } else if (localStorage.view) {
    // Pick up the state from earlier time.
    defaultView = localStorage.view;
    this.logger.userHit('reopen', { resource: sharedUri, view: defaultView });
  }

  var embedTab = document.querySelector('[data-container="embed"]');
  if (this.resource instanceof models.Artist || this.resource instanceof models.User) {
    embedTab.style.display = '';
  } else {
    embedTab.style.display = 'none';
  }

  this.logger.userHit('open', { resource: this.resource.uri });

  // Avoid a race condition where a previous resource might still be loading.
  if (this.resourceLoadPromise) {
    this.resourceLoadPromise.setFail('cancel');
  }

  // Reset the metadata before loading new metadata.
  this.resourceTemplate(null);

  // Let's load the image and name first to set the cover and title
  this.resourceLoadPromise = this.resource.load('name', 'image').done(this, this.onCoverAndTitleLoaded).fail(this, this.showOpError);

  // Show the share view by default per design.
  // This call also prompts the message box to retrieve draft.
  this._setCurrentTabView(defaultView);
};

/**
 * Utility method to replace all the "data-string" attributes with translated strings.
 *
 * @param {Object} element The DOM element for which contains the attribute to be translated.
 * @param {string} key The string key to look up the translations.
 * @param {string=} opt_attr The data attribute which contains the value that is being translated.
 *     If the attribute value isn't passed, the value is written down into the elements textContent.
 */
ShareApp.prototype._translateDataString = function (element, key, opt_attr) {
  var string = _(key);

  // Log when the key is the same as the translated strings (since that means key isn't found).
  if (!string || key === string) {
    this.logger.error('translation_error', {
      key: key, attribute: opt_attr, string: string, language: models.session.language });
  }

  if (string) {
    if (opt_attr) {
      element.setAttribute(opt_attr, string);
    } else {
      element.textContent = string;
    }
  }
};

ShareApp.prototype._resourceTypeText = function () {
  if (this.resource instanceof models.Playlist) {
    return 'fieldMessagePlaylist';
  } else if (this.resource instanceof models.Album) {
    return 'fieldMessageAlbum';
  } else if (this.resource instanceof models.Artist) {
    return 'fieldMessageArtist';
  } else if (this.resource instanceof models.Track) {
    return 'fieldMessageTrack';
  } else {
    return '';
  }
};

ShareApp.prototype._onTabClick = function (evt) {
  evt.preventDefault();
  var container = evt.target.getAttribute('data-container');

  // protects against clicking in the space in the middle
  if (!container) return false;
  this._setCurrentTabView(container);
};

ShareApp.prototype._setCurrentTabView = function (tab) {
  this.toggleSelectedTab(tab);
  this.showViewByName(tab);
};

ShareApp.prototype.toggleSelectedTab = function (activeContainer) {
  for (var i = 0; i < this.containers.length; ++i) {
    if (this.containers[i].getAttribute('data-container') === activeContainer) {
      elements(this.containers[i]).addClass('selected');
      elements(this.containers[i].parentNode).addClass('active');
    } else {
      if (elements(this.containers[i]).hasClass('selected')) {
        elements(this.containers[i]).removeClass('selected');
        elements(this.containers[i].parentNode).removeClass('active');
      }
    }
  }
};

ShareApp.prototype._getActionBar = function () {
  return document.querySelector('#primary-controls');
};

ShareApp.prototype.getActionButtonByAlias = function (alias) {
  var container = document.querySelector('#primary-controls');
  var selector = alias === 'ok' ? '.js-ok-button' : '.js-cancel-button';
  return container.querySelector(selector);
};

ShareApp.prototype.toggleActionBarDisplay = function (opt_state) {
  var elBar = this._getActionBar();
  toggleHide(elBar, opt_state);
  return elBar;
};

ShareApp.prototype.toggleActionButtonDisabled = function (alias, opt_state) {
  var btn = this.getActionButtonByAlias(alias);

  if (typeof opt_state !== 'undefined') {
    btn.disabled = opt_state;
  } else {
    btn.disabled = !btn.disabled;
  }
  return btn;
};

ShareApp.prototype.toggleActionButtonDisplay = function (alias, opt_state) {
  var btn = this.getActionButtonByAlias(alias);
  toggleHide(btn, opt_state);
  return btn;
};

ShareApp.prototype.setActionButtonText = function (alias, text) {
  var btn = this.getActionButtonByAlias(alias);
  btn.textContent = text;
  return btn;
};

ShareApp.prototype.setActionButtonTabIndex = function (alias, index) {
  var btn = this.getActionButtonByAlias(alias);
  btn.tabIndex = index;
  return btn;
};

ShareApp.prototype.toggleGlobalNavDisplay = function (opt_state) {
  var elTabs = document.querySelector('#tabs');
  toggleHide(elTabs, opt_state);
  return elTabs;
};

ShareApp.prototype.onCoverAndTitleLoaded = function (resource) {
  var self = this;

  var name = resource.name.decodeForText();
  this.urlTitle = name;

  this.resourceTemplate({
    uri: resource.uri,
    name: name,
    imageUrl: resource.image
  });

  // Each resource has a slightly different attribute displayed.
  // Eg: Playlist share would list the owner. Tracks & Album show artists names.
  if (resource instanceof models.Artist) {

    this.urlTitle = name;
    localStorage.message = '#NowPlaying ' + this.urlTitle;
  } else if (resource instanceof models.Playlist) {

    resource.load('owner').done(this, function (resource) {
      resource.owner.load('name').done(this, function (sharedPlaylistOwner) {
        self.resourceTemplate('owner', {
          name: sharedPlaylistOwner.name,
          uri: sharedPlaylistOwner.uri
        });
        self.urlTitle = _('playlistByPerson', name, sharedPlaylistOwner.name);
        localStorage.message = '#NowPlaying ' + self.urlTitle;
      });
    });
  } else if (resource instanceof models.Track || resource instanceof models.Album) {

    resource.load('artists').done(this, function (trackOrAlbum) {
      var artistNamesPromises = [];
      for (var i = 0; i < trackOrAlbum.artists.length; i++) {
        artistNamesPromises.push(trackOrAlbum.artists[i].load('name'));
      }

      models.Promise.join(artistNamesPromises).always(this, function (artistsWithLoadedNames) {
        var artists = artistsWithLoadedNames.map(function (artist) {
          return {
            name: artist.name.decodeForText() || '',
            uri: artist.uri || ''
          };
        });

        this.resourceTemplate('artists', artists);
        var artistNames = artists.map(function (artist) {
          return artist.name.decodeForText();
        }).join(', ');

        self.urlTitle = _('trackOrAlbumByArtist', name, artistNames);
        localStorage.message = '#NowPlaying ' + self.urlTitle;
      });
    });
  }
};

ShareApp.prototype.showView = function (view) {

  if (!view.prepared) view.prepare();

  if (this.currentView && this.currentView !== view.id) {
    // Notify the current view that it's about to be hidden.
    this.views[this.currentView].onWillHide();
    elements(document.body).removeClass(this.currentView);
    elements(document.body).addClass(view.id);
    this.currentView = view.id;
    this.toggleSelectedTab(this.currentView); // fix selected tab UI for share/send
  }

  this.setTitle(view);

  // Log the impression of each view.
  this.logger.userImpression(view.id + '_view');
  view.onshow();
  view.resize();
};

ShareApp.prototype.setTitle = function (view) {
  return;
  if (!view.title) return;
  var title = document.querySelector('.title');
  title.textContent = view.title;
};

ShareApp.prototype.showError = function (errorMessage, logReason, opt_logContext) {
  this.views.error.setError(errorMessage);
  this.showView(this.views.error);
  this.logger.error('error_view', { reason: logReason }, opt_logContext);
};

ShareApp.prototype.showOpError = function (resource, error) {
  if (error === 'cancel') return; // Known failure. So, don't show an error view.

  this.showError(_('errorOpError'), 'load failed', this.resource.uri);
};

ShareApp.prototype.showViewByName = function (viewName) {
  var view = this.views[viewName];
  if (!view) throw new Error('View does not exist: ' + viewName);
  this.showView(view);
};

ShareApp.prototype._handleKeyPress = function (evt) {
  // Close the share popup when hitting Escape.
  if (evt.keyCode === 27) {
    this.debug('escape', { view: this.currentView });
    this.exitApp();
  }
};

ShareApp.prototype.exitApp = function () {
  this.debug('will exit');
  this.cleanUpAtExit();
  window.parent.postMessage(JSON.stringify({ type: 'POPUP_WINDOW_CLOSE' }), '*');
};

ShareApp.prototype.cleanUpAtExit = function () {
  // Reset the current view.
  this.views[this.currentView].onWillHide();
  this.views[this.currentView].reset();
};

ShareApp.prototype._clearState = function () {
  delete localStorage.message;
  delete localStorage.resource;
  delete localStorage.view;
};

ShareApp.prototype.clearStateAndExit = function () {
  this._clearState();
  this.exitApp();
};

ShareApp.prototype.updateNetworksConnectedStates = function () {
  var allNetworks = []; // used to keep state of all networks
  for (var network in this.networks) {
    allNetworks.push(this.networks[network].getState());
  }

  // It's interesting to note which networks are connected at the point of starting.
  models.Promise.join(allNetworks).always(this, function (networksData) {
    var networks = [],
        userInfo = [];

    for (var network in this.networks) {
      if (this.networks[network].enabled) {
        networks.push(network);
        userInfo.push(this.networks[network].getName());
      }
    }

    this.debug('connected', {
      networks: networks.join(' '),
      userInfo: userInfo.join(' ')
    });
  });
};

ShareApp.prototype.updateLoggerSource = function (uri) {
  var source = logSourceBase + ':' + uri;
  this.logger.setConstant({ source: source });
  Object.keys(this.networks).forEach(function (key) {
    if (this.networks[key].enabled) {
      this.networks[key].updateLoggerSource.call(this.networks[key], source);
    }
  }.bind(this));
};

exports.ShareApp = ShareApp;

},{"../../../libs/api-cjs/scripts/models":43,"../../../libs/spotify-client-logger":51,"../../../libs/spotify-elements":56,"../i18n":11,"../package.json":21,"./networks/facebook":26,"./networks/tumblr":27,"./networks/twitter":28,"./utils/media-object":31,"./utils/toggle-hide":33,"./views/embed":35,"./views/error":36,"./views/options":37,"./views/send":38,"./views/share":39,"debug":147,"spotify-inheritance/inherit":241,"spotify-liburi":242}],23:[function(require,module,exports){
'use strict';

var models = require('../../../libs/api-cjs/scripts/models');
var facebook = require('../../../libs/api-cjs/scripts/facebook');
var relations = require('../../../libs/api-cjs/scripts/relations');
var inherit = require('spotify-inheritance/inherit');

var FACEBOOK_PREFIX = 'facebook:';
var eventSource = new models.Observable();
var _initialized = false;

var _loading = 0;

function addEventListener() {
  eventSource.addEventListener.apply(eventSource, arguments);
}

function removeEventListener() {
  eventSource.removeEventListener.apply(eventSource, arguments);
}

var collections = [];

/**
 * An index of users that have been added.
 * @type {Object.<string, boolean>}
 */
var userIndex = {};

/**
 * A list of users that are ready to display in the autocomplete.
 */
var readyUsers = [];

/**
 * Adds a user to shown in the autocomplete list.
 * @param {module:api/models~User|module:api/facebook~FacebookUser} user The
 *     user to add to the index.
 */
function addUser(user) {
  if (typeof user == 'string') {
    if (user.match(/^spotify:/)) {
      user = models.fromURI(user);
    } else {
      // Unknown identifier.
      return;
    }
  }

  // Handle Facebook users.
  if (user instanceof facebook.FacebookUser && user.user) {
    // If the Facebook user is connected to Spotify, just handle it as a
    // Spotify user, ignoring the Facebook information.
    user = user.user;
  }

  // If Artist, just bail, we no longer can get the related artist/user
  // from the bridge with the latest core.
  if (user instanceof models.Artist) {
    return;
  }

  // Get a string key for the user.
  var key = getUserKey(user);

  // Unknown user type.
  if (!key) return;

  // Check if the user has been added before. If not, add it to the index and
  // load metadata.
  if (userIndex[key]) return;
  userIndex[key] = true;

  // Load the user metadata. For Facebook users this should already be pre-
  // populated (so no additional request will be made).
  var promise = user.load('image', 'name');
  promise.always(markUserAsReady);

  // Increment a loading counter. This counter will be decremented by the
  // function markUserAsReady.
  _loading++;

  // If this was the first load in this batch, dispatch an event.
  if (_loading == 1) eventSource.dispatchEvent('loading');
}

function getUserFromKey(key) {
  var prefixLength = FACEBOOK_PREFIX.length;
  if (key.substr(0, prefixLength) == FACEBOOK_PREFIX) {
    return facebook.FacebookUser.fromId(key.substr(prefixLength));
  } else {
    return models.fromURI(key);
  }
}

function getUserKey(user) {
  if (user instanceof models.Artist || user instanceof models.Profile || user instanceof models.User) {
    return user.uri;
  } else if (user instanceof facebook.FacebookUser) {
    return FACEBOOK_PREFIX + user.id;
  }
}

function removeUser(user) {
  // TODO
}

var timeoutUserAdded, usersStartIndex;
function markUserAsReady(user) {
  _loading--;

  // Attempt to repair failed users by parsing the user URI.
  if (!user.name) {
    var pieces = user.uri && user.uri.split(':');
    if (!pieces || pieces.length < 3 || pieces[1] != 'user') {
      return;
    }
    user.resolve('name', decodeURIComponent(pieces[2]));
  }

  // Create a window for more users to come in before emitting the event.
  if (!timeoutUserAdded) {
    // Store the current last index of readyUsers. This will be used below.
    var usersStartIndex = readyUsers.length;

    timeoutUserAdded = setTimeout(function () {
      // Emit event with the users that were added since the timer was set.
      eventSource.dispatchEvent({
        type: 'users',
        users: readyUsers.slice(usersStartIndex)
      });

      timeoutUserAdded = null;

      // Dispatch an event when all users have finished loading.
      if (!_loading) {
        eventSource.dispatchEvent('done');
      }
    }, 50);
  }

  readyUsers.push(user);
}

/**
 * Adds the users in the specified collection to the autocomplete widget.
 * @param {module:api/models~Collection} collection The collection of users
 *     to add.
 */
function addCollection(collection) {
  collections.push(collection);

  collection.snapshot(0, 10000).done(function (snapshot) {
    snapshot.toArray().forEach(addUser);
  });

  // Add modification event handlers to the collection.
  //
  // Not all collections support this, so the data might still change on
  // reload of the app. To solve this, we could time out our cache after an
  // hour or so, and reload all data.
  collection.addEventListener('add', function (event) {
    event.uris.forEach(addUser);
  });

  collection.addEventListener('remove', function (event) {
    event.uris.forEach(removeUser);
  });
}

/**
 * Kicks off the autocomplete functionality by building and decorating the
 * index.
 */
function init() {
  if (_initialized) return;
  _initialized = true;

  var rels = relations.Relations.forCurrentUser();
  addCollection(rels.subscribers);
  addCollection(facebook.session.friends);
}

/**
 * Refreshes the users from all collections. This won't remove any users, though.
 */
function refresh() {
  collections.forEach(function (collection) {
    collection.snapshot().done(function (snapshot) {
      snapshot.toArray().forEach(addUser);
    });
  });
}

function Filter() {
  models.Observable.call(this);

  this.clear();

  // Add newly decorated users that match the current search query.
  addEventListener('users', this._addNewUsers.bind(this));
}
inherit(Filter, models.Observable);

Filter.prototype._addNewUsers = function (event) {
  if (!this._query) return;

  var usersAdded = 0;

  for (var i = 0; i < event.users.length; i++) {
    var user = event.users[i];
    if (this._userMatches(user)) {
      this._result.push(user);
      usersAdded++;
    }
  }

  if (usersAdded) {
    this.dispatchEvent({
      type: 'change',
      result: this.getResult(),
      async: true // The result changed asynchronously.
    });
  }
};

/**
 * Checks whether the specified user matches the current query.
 *
 * @private
 * @param {Object} user A user to check.
 * @return {boolean} Whether the user matches.
 */
Filter.prototype._userMatches = function (user) {
  return user.name.toLowerCase().indexOf(this._query) >= 0;
};

Filter.prototype.clear = function () {
  this._exclude = null;
  this._query = '';
  this._result = [];
};

Filter.prototype.setExcludeList = function (exclude) {
  this._exclude = exclude;
};

Filter.prototype.getResult = function () {
  var exclude = this._exclude;
  if (exclude) {
    return this._result.filter(function (user) {
      return exclude.indexOf(user) == -1;
    });
  } else {
    return this._result;
  }
};

Filter.prototype.search = function (query) {
  query = query.toLowerCase();
  if (query == this._query) {
    return this._result;
  }

  var candidates;
  if (this._query && query.indexOf(this._query) >= 0) {
    // If the new query contains the previous query, just filter the previous
    // result set in place.
    candidates = this._result;
  } else {
    candidates = readyUsers.slice();
  }

  this._query = query;

  for (var i = candidates.length - 1; i >= 0; i--) {
    if (!this._userMatches(candidates[i])) {
      candidates.splice(i, 1);
    }
  }

  this._result = candidates;

  var filteredResult = this.getResult();

  this.dispatchEvent({
    type: 'change',
    result: filteredResult,
    async: false // The change happened synchronously (function call).
  });

  return filteredResult;
};

exports.Filter = Filter;
exports.addEventListener = addEventListener;
exports.getUserFromKey = getUserFromKey;
exports.getUserKey = getUserKey;
exports.init = init;
exports.refresh = refresh;
exports.removeEventListener = removeEventListener;

},{"../../../libs/api-cjs/scripts/facebook":40,"../../../libs/api-cjs/scripts/models":43,"../../../libs/api-cjs/scripts/relations":45,"spotify-inheritance/inherit":241}],24:[function(require,module,exports){
'use strict';

// Uncomment this to enable verbose global logging
// localStorage.logging_debug = true;

// Initiate legacy API core for $api-cjs/scripts/models and friends.
var ApiCore = require('../../../libs/spotify-api-core');

// Register the application model to get updates to active state.
var live = require('../../../libs/spotify-live');
require('../../../libs/spotify-live-models/application').register();

var ShareApp = require('./app').ShareApp;

require('../../../libs/spotify-handlebars/helpers/numeral').setLocale(window.__spotify.locale);

// We only need to create one shareApp instance and re-init for change of resource.
var shareApp = new ShareApp();
shareApp.setup();

var appModel = live('spotify:application');
var focusArgumentsTimeout = null;

function argumentsChanged(properties) {
  clearTimeout(focusArgumentsTimeout);

  if ('arguments' in properties) {
    var args = properties.arguments;
    var extractedUri = extractUri(args);
    shareApp.updateLoggerSource(extractedUri);
    shareApp.logger.info('args_change', args);
    shareApp.reInit(extractUri(args));
  }

  if (properties.active) {
    shareApp.logger.info('share view is now active');
    shareApp.reInit(extractUri(appModel.get('arguments')));
  }
}

function extractUri(args) {
  if (!args) return '';
  if (args.indexOf('spotify:') == 0) {
    return args;
  } else {
    return decodeURIComponent(args);
  }
}

live('spotify:application').query('arguments', function (error, data) {
  if (error) {
    shareApp.logger.error('arguments_load_error', { error: error.message });
    return;
  }

  var extractedUri = extractUri(data.arguments);

  shareApp.updateLoggerSource(extractedUri);
  shareApp.logger.info('loaded');
  shareApp.logger.info('device', 'desktop');
  shareApp.logger.info('initial arguments', data.arguments);
  shareApp.reInit(extractedUri);
  appModel.on('update', argumentsChanged);
});

window.addEventListener('message', function (event) {
  var message;
  try {
    message = JSON.parse(event.data);
  } catch (e) {
    return;
  }

  if (message.type) {
    // Log messages received for debugging utility.
    shareApp.logger.info('msg_received:' + message.type, message);
  }

  if (message.type === 'WINDOW_FOCUS') {
    clearTimeout(focusArgumentsTimeout);
    // If the app has been previously initialized, then set a failsafe
    // in the event that the arguments do not change.
    var args = appModel.get('arguments');
    if (args) {
      focusArgumentsTimeout = setTimeout(function () {
        shareApp.reInit(extractUri(args));
      }, 100);
    }
  }

  if (message.type === 'WINDOW_CLOSED') {
    // Reset the resource template (mediaObject).
    shareApp.resourceTemplate(null);
    shareApp.cleanUpAtExit();
  }
});

require('../../../libs/spotify-expose-dev-mode-debug-globals/bridge').init();
require('../../../libs/spotify-expose-dev-mode-debug-globals/live').init();
require('../../../libs/spotify-expose-dev-mode-debug-globals/cosmos').init();

},{"../../../libs/spotify-api-core":48,"../../../libs/spotify-expose-dev-mode-debug-globals/bridge":59,"../../../libs/spotify-expose-dev-mode-debug-globals/cosmos":60,"../../../libs/spotify-expose-dev-mode-debug-globals/live":62,"../../../libs/spotify-handlebars/helpers/numeral":98,"../../../libs/spotify-live":109,"../../../libs/spotify-live-models/application":107,"./app":22}],25:[function(require,module,exports){
'use strict';

var models = require('../../../libs/api-cjs/scripts/models');
var hermes = require('../../../libs/api-cjs/scripts/hermes');
var Logger = require('../../../libs/spotify-client-logger');
var inherit = require('spotify-inheritance/inherit');
var pkg = require('../package.json');

/**
 * Constructor for an abstract Network. All social networks inherit this.
 * @constructor
 * @extends {module:api/models~Observable}
 * @param {String} logSourceBase - the base logger source field
 */
function Network(logSourceBase) {
  // Use a tri-state approach for determining if a network state is unknwon, connected or failed to connect.
  // null - unknown, false - cannot connect, true - connected.
  this.enabled = null;

  // keep a flag to keep state of networks unselected by user in share screen
  // these networks wouldn't automatically be selected for that share session
  this.selected = !!localStorage['select-network-' + this.name];

  // A logger instance per network to log network related actions
  // Network's name defined in each network.
  this.logger = new Logger();
  this.logger.setConstant({ source: logSourceBase });
};
inherit(Network, models.Observable);

/**
 * Simple utility method used by social networks to send out hermes requests.
 *
 * @param {string} uri The hermes URI to make the request to.
 * @param {string} method The method to use for the hermes request.
 * @param {string} replyType The protobuf type of hermes-reply's payload's first item.
 *     If null, the reply payload is unprocessed and expected to be empty.
 * @param {string} requestType The protobuf type of hermes request's payload's first item.
 *     If null, the request payload is set empty.
 * @param {Object} data The data for the request payload.
 * @return {module:api/models~Promise} A promise for the hermes Request.
 *     The promise resolves to the reply of the request or an error.
 */
Network.prototype.hermesRequest = function (uri, method, replyType, requestType, data) {
  var req = hermes.Hermes.get(uri, replyType ? [this.schema.type(replyType)] : [], requestType ? [this.schema.type(requestType)] : []);
  req.method = method;

  // Log information about the Hermes request.
  var key = this.logger.createTimer('hermes');
  return req.send(data).always(this, function () {
    this.logger.logTimer(key, { req: uri, method: method });
  });
};

Network.prototype.dispatchConnectChangeEvent = function () {
  this.dispatchEvent({ type: 'connection_updated', network: this.name });
};

Network.prototype.updateLoggerSource = function (source) {
  this.logger.setConstant({ source: source });
};

exports.Network = Network;

},{"../../../libs/api-cjs/scripts/hermes":41,"../../../libs/api-cjs/scripts/models":43,"../../../libs/spotify-client-logger":51,"../package.json":21,"spotify-inheritance/inherit":241}],26:[function(require,module,exports){
'use strict';

/**
 * @fileoverview Module for handling Facebook user authentication, connection
 *     and posts.
 */
var debug = require('debug')('share:facebook');
var transport = require('spotify-cosmos-api').resolver;
var mainStrings = require('../../i18n');
var LegitPromise = window.Promise;
var posmos = require('../utils/posmos');
var inherit = require('spotify-inheritance/inherit');

var facebook = require('../../../../libs/api-cjs/scripts/facebook');
var models = require('../../../../libs/api-cjs/scripts/models');
var Network = require('../network').Network;

/**
 * The max number of Facebook friends to get when loading a list of all
 * friends.
 * @const
 */
var MAX_FACEBOOK_FRIENDS = 1000;

// Shortcut for translation.
var _ = mainStrings.get.bind(mainStrings);

var endpoints = {
  connection: 'sp://facebook/v1/connection',
  permissions: 'sp://facebook/v1/permissions'
};

/**
 * Class supporting interaction with the Facebook network.
 * @class
 */
function Facebook() {
  this.displayName = 'Facebook';
  this.name = 'facebook';

  Network.call(this);

  // The current user's Facebook user info.
  this.facebookUser = null;

  // Promise which will be resolved when the Facebook friends have been
  // loaded.
  this.friendsPromise = new models.Promise();

  this.connectionSubscription = null;
  this._subscribeToConnectionStatus();
}
inherit(Facebook, Network);

/**
 * Get connected state for Facebook.
 * @return {module:api/models~Promise} A promise that resolves when the
 *     connected state is known.
 */
Facebook.prototype.getState = function () {

  var self = this;
  var p = new models.Promise();

  LegitPromise.all([posmos('get', { url: endpoints.connection }), posmos('get', { url: endpoints.permissions })]).then(function (results) {
    var connectionBody = results[0].getJSONBody();
    var permissionsBody = results[1].getJSONBody();
    debug('fbstate', connectionBody, permissionsBody);

    if (!connectionBody.connection) {
      return fail([new Error('No Facebook Connection')]);
    }

    // The permissions to publish to a user's wall on Facebook is the same
    // as scrobbling, which is requested on the Zelda Settings page.
    // Yes, this is confusing, but the current flow of data in this app only
    // supports a network being `enabled` or not, not `enabled` but without
    // permissions to do anything.
    var publish = permissionsBody.permissions.filter(function (perm) {
      return perm.permission === 'publish_actions' && perm.status === 'granted';
    })[0];

    if (!publish) {
      return fail([new Error('No publish_actions Permissions granted')]);
    }

    // Hope against hope that somehow the stitch api is in sync with cosmos.
    // We are forced to still use this because the cosmos resolver does not
    // expose Facebook friends nor the user's Facebook id. This should
    // probably be done in the share view backend, whenever someone gets
    // around to rewriting this entire widget.
    facebook.session.load('facebookUser').done(self, self._onFacebookUserLoaded).done(function (session) {
      debug('session', session);
      p.setDone(session);
    }).fail(function (_, error) {
      debug('session', _, error);
      return fail([error]);
    });
  }).catch(function (errors) {
    return fail(errors);
  });

  function fail(errors) {
    debug('fail', errors);
    self.enabled = false;
    errors.forEach(function (error) {
      self.logger.error('fb_session_error', { error: error && error.message });
    });
    self.dispatchConnectChangeEvent();
    self.friendsPromise.setFail(errors);
    p.setFail(errors);
    return p;
  }

  return p;
};

/**
 * Tells Spotify to connect the user to Facebook.
 * @return {module:api/models~Promise} The promise returned by request to
 *     show Facebook connect UI.
 */
Facebook.prototype.connect = function () {
  // TODO(sri): If not connected, call facebook.session.showConnectUI() once
  // implemented.
  return this.getState();
};

/**
 * Tells Spotify to disconnect the user from Facebook.
 * @return {module:api/models~Promise} The promise returned by request to
 *     disconnect from Facebook.
 */
Facebook.prototype.disconnect = function () {
  this.enabled = false;
  this.dispatchConnectChangeEvent();
};

/**
 * Subscribe via cosmos to the facebook resolver for connection changes.
 */
Facebook.prototype._subscribeToConnectionStatus = function () {
  var sub = this.connectionSubscription;
  if (sub && sub.cancel) {
    debug('cancel()');
    sub.cancel();
    this.connectionSubscription = null;
  }

  var uri = endpoints.connection;
  debug('SUB', uri);
  this.connectionSubscription = transport.subscribe(uri, function (err, res) {
    debug('RES', uri, err, res);
    if (err) return this._subscribeToConnectionStatus();
    this.getState();
  }.bind(this));
};

/**
 * Once facebookUser is loaded, vet the user and dispatch connection_change
 * event.
 */
Facebook.prototype._onFacebookUserLoaded = function (session) {
  if (!session.facebookUser) return;

  // Load the Facebook name for the user. This is displayed in the options
  // page.
  session.facebookUser.load('name').done(this, function (facebookUser) {
    if (!facebookUser.name) {
      this._handleEmptyFacebookName();
    } else {
      // Looks like we've loaded the current session's Facebook user
      // successfully.
      this.enabled = true;
      this.facebookUser = facebookUser;

      // Load friends for the user for autocomplete in send view.
      // TODO(sri): perhaps it only makes sense to do this on choosing send
      // view.
      this.loadFriends();
    }
  }).fail(this, function (_, error) {
    // Failures to load Facebook name imply that the Facebook session isn't
    // active.
    this._handleEmptyFacebookName();
    // TODO(drew): this should be unnecessary, as it's improbable that we were
    // able to load session.facebookUser but unable to get the fb name,
    // which implies a bridge/core/backend bug
    this.friendsPromise.setFail();
    this.logger.error('fb_name_load_error', { uid: session.facebookUser.id });
  }).always(this, this.dispatchConnectChangeEvent);
};

Facebook.prototype._handleEmptyFacebookName = function () {
  this.enabled = null;
};

/**
 * Get the name of the connected user.
 * @return {string} The full name of the user, as on Facebook.
 */
Facebook.prototype.getName = function () {
  return this.facebookUser ? this.facebookUser.name : '';
};

/**
 * Method to get state in "Connected as" form.
 * @return {string} A description of the Facebook state.
 */
Facebook.prototype.getStateText = function () {
  return _('optionsStateConnectedAs', this.displayName);
};

/**
 * Method to post a message with attachment to the user's timeline on
 * Facebook.
 *
 * @param {string} message The string message to accompany the post.
 * @param {string} urlTitle The title for the link to post; unused by
 *     Facebook.
 * @param {string} url The Spotify link that's being posted.
 * @return {module:api/models~Promise} A promise for the post request.
 */
Facebook.prototype.post = function (message, urlTitle, url) {
  return facebook.session.post(message, url.toSpotifyURI());
};

/**
 * Send a message to a list of Facebook users (as single messages, not a
 * group conversation).
 * @param {Array.<module:api/facebook~FacebookUser>} to The recipients.
 * @param {string} message The message text.
 * @param {string} url The Spotify link that's being sent.
 * @return {module:api/models~Promise} A promise that'd resolve once message
 *     is sent.
 */
Facebook.prototype.message = function (to, message, url) {
  var promises = [];
  for (var i = 0; i < to.length; ++i) {
    var promise = facebook.session.message([to[i]], message, models.fromURI(url.toSpotifyURI()));
    promises.push(promise);
  }
  return models.Promise.join(promises);
};

/**
 * Load the list of the current user's Facebook friends.
 */
Facebook.prototype.loadFriends = function () {
  var self = this;

  facebook.session.load('friends').done(function (session) {
    session.friends.snapshot(0, MAX_FACEBOOK_FRIENDS).done(function (snapshot) {
      var friends = snapshot.toArray();

      var loadPromises = friends.map(function (friend) {
        var promise = friend.load('user', 'image', 'name');

        promise.fail(function (_, error) {
          self.logger.error('fb_friend_metadata_load_error', { error: error && error.message });
        });

        return promise;
      });

      // When all the data here resolves (either way), resolve the friends
      // promise.
      models.Promise.join(loadPromises).done(function (friends) {
        // Resolve the friends promise to indicate that Facebook friends'
        // data has loaded successfully.
        self.friendsPromise.setDone(friends || []);
      }).fail(function (_, error) {
        self.logger.error('fb_friends_metadata_load_error', { error: error && error.message });
        self.friendsPromise.setFail(error);
      });
    }).fail(function (_, error) {
      self.logger.error('fb_friends_snapshot_error', { error: error && error.message });
      self.friendsPromise.setFail(error);
    });
  }).fail(function (_, error) {
    self.logger.error('fb_friends_load_error', { error: error && error.message });
    self.friendsPromise.setFail(error);
  });
};

exports.Facebook = Facebook;

},{"../../../../libs/api-cjs/scripts/facebook":40,"../../../../libs/api-cjs/scripts/models":43,"../../i18n":11,"../network":25,"../utils/posmos":32,"debug":147,"spotify-cosmos-api":233,"spotify-inheritance/inherit":241}],27:[function(require,module,exports){
'use strict';

var mainStrings = require('../../i18n');
var inherit = require('spotify-inheritance/inherit');

/**
 * @fileoverview Module for handling connecting and posting to Tumblr from share widget.
 * @module share
 */

var hermes = require('../../../../libs/api-cjs/scripts/hermes');
var Network = require('../network').Network;

var _ = mainStrings.get.bind(mainStrings); // shortcut for translation

/**
 * Constructor for Tumblr instance.
 * It's recommended only to construct one instance and use that across views to
 * preserve state of the network across various views.
 */
function Tumblr() {
  this.name = 'tumblr';
  this.displayName = 'Tumblr';

  this.schema = hermes.Schema.fromURL('proto/tumblr.proto');
  this.hermesBaseUri = 'hm://tumblr/';
  Network.call(this);
};
inherit(Tumblr, Network);

/**
 * Connect handler to Tumblr network. Passes info to backend which negotiates for auth-tokens
 * using xAuth Authentication.
 *
 * @param {string} email The email for the Tumblr user.
 * @param {string} password The password for the Tumblr user.
 * @return {module:api/models~Promise} A promise for the hermes request to connect to Tumblr.
 */
Tumblr.prototype.connect = function (email, password) {
  var data = { email: email, password: password };
  var hermesUri = this.hermesBaseUri + 'enable';
  var req = this.hermesRequest(hermesUri, 'POST', 'TumblrUserInfo', 'TumblrCredentials', data);
  return req.done(this, this._onConnect).fail(this, this._onConnectFail);
};

/**
 * Method to update authentication state, on network connected.
 *
 * @private
 * @param {Object} hermesReply The Object from the hermes reply for the connect request.
 */
Tumblr.prototype._onConnect = function (hermesReply) {
  this._updateAuth(hermesReply[0]);
};

/**
 * Utility method to update authenticated state.
 *
 * @private
 * @param {Object} userinfo The userinfo object that keeps the auth_token.
 */
Tumblr.prototype._updateAuth = function (userinfo) {
  if (!userinfo) userinfo = {};

  this.authToken = userinfo.auth_token;
  this.blogName = userinfo.blog_name;
  this.enabled = Boolean(this.blogName);
  this.dispatchConnectChangeEvent();
  // Not saving user-id at this point since it's never used.
};

/**
 * Utility method to update authenticated state.
 *
 * @private
 * @param {Object} request The hermes request object.
 * @param {Object} error The error object explaining why connection failed.
 */
Tumblr.prototype._onConnectFail = function (request, error) {
  this.logger.error('tumblr_connect_error', { error: error.message });
  this._updateAuth({}); // reset Auth
};

/**
 * Disconnect handler for Tumblr credentials. Also sends a message to backend to forget credentials.
 * @return {module:api/models~Promise} A promise for the hermes request to remove Tumblr auth token.
 */
Tumblr.prototype.disconnect = function () {
  var hermesUri = this.hermesBaseUri + 'disable';
  // Reset the status right now since we don't have to wait for reply
  this._updateAuth({}); // reset Auth
  return this.hermesRequest(hermesUri, 'POST', null, null, {});
};

/**
 * Method to fetch Tumblr blog name.
 * @return {string} A string that represents the string to show the Tumblr connected state.
 */
Tumblr.prototype.getName = function () {
  return this.blogName + '.tumblr.com';
};

/**
 * Method to get state in "Connected as" form.
 *
 * @return {string} The connected state and blog being posted to.
 */
Tumblr.prototype.getStateText = function () {
  return _('optionsStateTumblrPostingTo');
};

/**
 * Method to get the connected state of Tumblr for the user from the backend.
 *
 * @return {module:api/models~Promise} A promise for the hermes request to get connected state.
 */
Tumblr.prototype.getState = function () {
  var hermesUri = this.hermesBaseUri + 'userinfo';
  var req = this.hermesRequest(hermesUri, 'GET', 'TumblrUserInfo', null, {});
  return req.done(this, this._onConnect);
};

/**
 * Method to post a message along with a Spotify resource on the user's Tumblr blog.
 *
 * @param {string} message The string message to accompany the Tumblr post.
 * @param {urlTitle} urlTitle The title for the link to post. This title shows up on the post.
 * @param {url} url The shared link to be converted to Play button on Tumblr.
 * @return {module:api/models~Promise} A promise for the hermes request to post.
 */
Tumblr.prototype.post = function (message, urlTitle, url) {
  var data = {
    message: message,
    spotify_link: url,
    auth_token: undefined, // this.authToken,
    blog_name: this.blogName,
    link_title: urlTitle
  };

  var hermesUri = this.hermesBaseUri + 'post';
  return this.hermesRequest(hermesUri, 'POST', null, 'TumblrPost', data);
};
exports.Tumblr = Tumblr;

},{"../../../../libs/api-cjs/scripts/hermes":41,"../../i18n":11,"../network":25,"spotify-inheritance/inherit":241}],28:[function(require,module,exports){
'use strict';

var strings = require('../../i18n');
var transport = require('spotify-cosmos-api').resolver;
var posmos = require('../utils/posmos');
var querystring = require('querystring');
var debug = require('debug')('share:twitter');
var spuri = require('spotify-liburi');
var inherit = require('spotify-inheritance/inherit');

// Forced to use these broken promises.
var Promise = require('../../../../libs/api-cjs/scripts/models').Promise;
var LegitPromise = window.Promise;
var Network = require('../network').Network;

var endpoints = {
  info: 'hm://share-view/v1/info',
  authorize: 'hm://share-view/v2/network/twitter/authorize?callback=http://localhost/twitter-oauth-cb',
  connect: 'hm://share-view/v2/network/twitter',
  disconnect: 'hm://share-view/v1/network/twitter',
  oauth: 'sp://oauth/v1/flow',
  broadcast: 'hm://share-view/v1/broadcast'
};

// Purposeful: legacy-style export
exports.Twitter = Twitter;

function Twitter() {
  this.name = 'twitter';
  this.displayName = 'Twitter';

  Network.call(this);

  this.logger = null; // "injected" externally.
  this.screenName = null;
  this.enabled = false;
}

inherit(Twitter, Network);

/**
 * @return {module:api/models~Promise} A promise for the hermes request to connect to Twitter.
 */
Twitter.prototype.connect = function () {
  var self = this;
  var logger = self.logger;

  var p = new Promise();

  LegitPromise.resolve('GO').then(posmos.bind(null, 'get', { url: endpoints.authorize })).then(function (res) {
    return res.getBody();
  }).then(openOauthDialog).then(extractCredentials).then(saveCredentials).then(function (res) {
    return res.getJSONBody();
  }).then(function (body) {
    self.getState();
    p.setDone(res);
  }).catch(function (err) {
    logger && logger.error('twitter_connect_error', { error: err.message });
    self.dispatchConnectChangeEvent();
    p.setFail(err);
  });

  return p;

  function openOauthDialog(authorizeUrl) {
    return posmos('post', {
      url: endpoints.oauth,
      body: {
        url: authorizeUrl,
        close_url: 'http://localhost/twitter-oauth-cb',
        window: {
          // defaults: width:380, height:760
          height: 540
        }
      }
    });
  }

  function extractCredentials(res) {
    var body = res.getJSONBody();
    if (body.complete !== true) {
      throw new Error(res.getBody());
    }

    var qs = body.url.slice(body.url.indexOf('?') + 1);
    var creds = querystring.parse(qs);

    // The backend wants "token" instead of "oauth_token" etc.
    Object.keys(creds).forEach(function (key) {
      creds[key.replace('oauth_', '')] = creds[key];
      delete creds[key];
    });

    debug('creds', creds);
    return creds;
  }

  function saveCredentials(creds) {
    return posmos('post', {
      url: endpoints.connect,
      body: creds
    });
  }
};

/**
 * Sends a message to backend to forget credentials.
 *
 * @return {module:api/models~Promise} A promise for the hermes request to remove Twitter auth token.
 */
Twitter.prototype.disconnect = function () {
  var self = this;
  var logger = self.logger;

  debug('DELETE', endpoints.disconnect);
  transport.delete(endpoints.disconnect, function (err, res) {
    debug('RES', endpoints.disconnect, err, res);

    if (err) {
      logger && logger.error('twitter_connect_error', { error: err.message });
      return;
    }

    self.getState();
  });
};

/**
 * Method to get the connected state of Twitter for the user from the backend.
 *
 * @return {module:api/models~Promise} A promise for the hermes request to get connected state.
 */
Twitter.prototype.getState = function () {
  var self = this;
  var p = new Promise();

  // The uri is required, and apparently is not meant to be url encoded...
  // TODO: use this endpoint in the root of the app to actually decorate the
  // to-be-shared resource.
  var uri = endpoints.info + '?uri=spotify:track:abcdef&decorate=false&busterCannon=' + Math.random();

  debug('GET', uri);
  transport.get(uri, function (err, res) {
    debug('RES', uri, err, res);
    if (err) {
      return failout(err);
    }

    var body = res.getJSONBody();
    if (!body.networks) {
      return failout();
    }

    var network = body.networks.filter(function (n) {
      return n.networkType === 'TWITTER';
    })[0];

    if (!network || network.state !== 'CONNECTED') {
      return failout();
    }

    self.screenName = network.name;
    self.enabled = true;
    self.dispatchConnectChangeEvent();
    p.setDone(self.name); // This value isn't ever used...
    return;
  });

  return p;

  function failout(err) {
    var notFoundError = new Error('Twitter not found in connected networks.');
    self.enabled = false;
    self.dispatchConnectChangeEvent();
    p.setFail(err || notFoundError);
  }
};

/**
 * Method to Tweet a message along with a Spotify resource.
 *
 * @param {string} message The string message to accompany the Twitter post.
 * @param {urlTitle} urlTitle The title for the link to post. Unused by Twitter.
 * @param {url} url The open.spotify link that's being shared on Twitter.
 * @return {module:api/models~Promise} A promise for the hermes request to tweet.
 */
Twitter.prototype.post = function (message, urlTitle, url) {

  // Just in case this comes in as open.spotify or something.
  var uri = spuri.from(url);
  var p = new Promise();

  var opts = {
    url: endpoints.broadcast,
    body: {
      uri: uri.toURI(),
      title: urlTitle || '',
      message: message || '',
      networks: ['TWITTER']
    }
  };

  debug('POST', opts.url, opts);
  transport.post(opts, function (err, res) {
    debug('RES', opts.url, err, res);

    if (err) {
      p.setFail(err);
      return;
    }

    var body = res.getJSONBody();
    if (!body.status || !body.status.TWITTER || !body.status.TWITTER.success) {
      p.setFail(body);
      return;
    }

    p.setDone(body);
    return;
  });

  return p;
};

/**
 * Method to fetch Twitter screen name (prepended with an @). Unconnected accounts would simply return '@'.
 *
 * @return {string} A string that represents the Twitter screen name, if connected, prepended with an '@'.
 */
Twitter.prototype.getName = function () {
  return '@' + this.screenName;
};

/**
 * Method to get state in "Connected as" form.
 * @return {string} A string that represents the string to show the Twitter connected state.
 */
Twitter.prototype.getStateText = function () {
  return strings.get('optionsStateConnectedAs', this.displayName);
};

},{"../../../../libs/api-cjs/scripts/models":43,"../../i18n":11,"../network":25,"../utils/posmos":32,"debug":147,"querystring":224,"spotify-cosmos-api":233,"spotify-inheritance/inherit":241,"spotify-liburi":242}],29:[function(require,module,exports){
'use strict';

var models = require('../../../libs/api-cjs/scripts/models');
var hermes = require('../../../libs/api-cjs/scripts/hermes');
var messaging = require('../../../libs/api-cjs/scripts/messaging');

var BASE_URI = 'spotify:app:messages';

var _schema = hermes.Schema.fromURL('proto/messaging.proto');

function _createURI(threadId, opt_messageId) {
  var pieces = [BASE_URI, 'thread', encodeURIComponent(threadId)];
  if (opt_messageId) {
    pieces.push('message', encodeURIComponent(opt_messageId));
  }
  return pieces.join(':');
}

function _makeNewMessage(recipients, text, opt_attachment) {
  var data = {
    recipients: recipients,
    text: text
  };

  if (opt_attachment) {
    data.attachment = opt_attachment.uri;
  }

  return data;
}

function _parseMessage(threadId, data) {
  return {
    id: data.id,
    uri: _createURI(threadId, data.id),
    user: data.sender,
    timestamp: data.timestamp,
    attachment: data.attachment,
    text: data.text
  };
}

function _parseThread(data) {
  var preview = _parseMessage(data.id, data.preview);

  return {
    uri: _createURI(data.id),
    state: data.readUntil == preview.id ? 'seen' : 'unread',
    timestamp: preview.timestamp
  };
}

function _sendSingle(recipients, text, attachment) {
  var request = hermes.Hermes.request('PUT', 'hm://messaging/threads', [_schema.type('Conversation')], [_schema.type('NewMessage')]);

  var data = _makeNewMessage(recipients, text, attachment);
  var promise = request.send(data);

  var resultPromise = new models.Promise();

  promise.done(function (frames) {
    var convo = _parseThread(frames[0]);
    resultPromise.setDone(messaging.Conversation.fromURI(convo.uri, convo));
  }).fail(function (_, error) {
    resultPromise.setFail(error);
  });

  return resultPromise;
}

// Creates one thread for each recipient (we currently don't support group
// messaging). This function needs to be equivalent to $api/messaging#send.
function send(recipients, text, opt_attachment) {
  recipients = recipients.map(function (recipient) {
    return recipient.uri;
  });

  var sendPromises = [];
  for (var i = 0; i < recipients.length; i++) {
    sendPromises.push(_sendSingle([recipients[i]], text, opt_attachment));
  }

  var promise = new models.Promise();

  models.Promise.join(sendPromises).done(function (convos) {
    promise.setDone(convos[0]);
  }).fail(function (_, error) {
    promise.setFail(error);
  });

  return promise;
}

exports.send = send;

},{"../../../libs/api-cjs/scripts/hermes":41,"../../../libs/api-cjs/scripts/messaging":42,"../../../libs/api-cjs/scripts/models":43}],30:[function(require,module,exports){
'use strict';

function logPromise(promise, logger, identifier, data) {
  var key = logger.createTimer(identifier);

  promise.done(function () {
    logger.info(identifier, data);
  });

  promise.fail(function (_, error) {
    var errorData = {
      error: error && error.message || ''
    };

    // Copy the data object so that we don't need to modify it.
    if (data) {
      for (var key in data) {
        if (data.hasOwnProperty(key)) {
          errorData[key] = data[key];
        }
      }
    }

    logger.error(identifier, errorData);
  });

  promise.always(function () {
    logger.logTimer(key);
  });
}

exports.logPromise = logPromise;

},{}],31:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var models = require('../../../../libs/api-cjs/scripts/models');

require('../../../../libs/spotify-handlebars').register(require('../../../../libs/spotify-handlebars/helpers'));
var mediaObject = require('../../../../libs/spotify-glue-cat/templates/v1/media-object.hbs');

/**
 * Given a DOM node, return a function (render) that when called will
 * automatically rerender the media object template with the new data as
 * well as all data from previous calls. The motivation being that the former
 * stitch api did not easily batch data from multiple sources, so we
 * optimistically give the data to the template whenever some is ready.
 *
 * Examples:
 * var render = mediaObject(document.querySelector('div'));
 *
 * render('name', 'this is the name')
 *   => Render
 * render({ name: 'this is the name' })
 *   => Add properties of the given object to the internal data and render.
 * render(null)
 *   => Clear the existing data, and render.
 *
 */
module.exports = function (container) {

  var data = {};

  return function (name, value) {

    if (name === null && typeof value === 'undefined') {
      Object.keys(data).forEach(function (key) {
        delete data[key];
      });
    } else if ((typeof name === 'undefined' ? 'undefined' : _typeof(name)) === 'object') {
      var input = name;
      Object.keys(input).forEach(function (key) {
        data[key] = input[key];
      });
    } else {
      data[name] = value;
    }

    // uri is now a required property.
    data.uri = data.uri || '';

    data.modifiers = data.modifiers || 'media-object-horizontal col-xs-12 col-sm-12 col-md-12 col-lg-12';

    if (data.imageUrl) {
      data.modifiers = data.modifiers.replace(/placeholder-visible/g, '');
    } else {
      data.modifiers += ' placeholder-visible';
    }

    container.innerHTML = mediaObject(data);
  };
};

},{"../../../../libs/api-cjs/scripts/models":43,"../../../../libs/spotify-glue-cat/templates/v1/media-object.hbs":85,"../../../../libs/spotify-handlebars":103,"../../../../libs/spotify-handlebars/helpers":94}],32:[function(require,module,exports){
'use strict';

var debug = require('debug')('share:posmos');
var transport = require('spotify-cosmos-api').resolver;
var LegitPromise = window.Promise;

// Expose cosmos as A+ promises for the sake of chaining.
module.exports = function cosmos(method, opts) {
  return new LegitPromise(function (resolve, reject) {
    debug(method.toUpperCase(), opts.url, opts);
    transport[method](opts, function (err, res) {
      debug('RES', opts.url, err, res);
      if (err) return reject(err);
      return resolve(res);
    });
  });
};

},{"debug":147,"spotify-cosmos-api":233}],33:[function(require,module,exports){
'use strict';

var elements = require('../../../../libs/spotify-elements');

/**
 * Toggle the display of an element.
 */
module.exports = function (element, opt_force) {
  var state = typeof opt_force !== 'undefined' ? opt_force : elements(element).hasClass('hide');
  if (state === true) {
    elements(element).removeClass('hide');
  } else {
    elements(element).addClass('hide');
  }
};

},{"../../../../libs/spotify-elements":56}],34:[function(require,module,exports){
'use strict';

var models = require('../../../libs/api-cjs/scripts/models');
var inherit = require('spotify-inheritance/inherit');

function View() {
  this.node = document.getElementById(this.id);
  this.prepared = false;
}
inherit(View, models.Observable);

View.prototype.resize = function () {
  var rects = document.querySelector('.js-bounding-rect').getBoundingClientRect();
  window.parent.postMessage(JSON.stringify({
    type: 'POPUP_SET_PREFERRED_SIZE',
    data: {
      width: rects.width,
      height: rects.height
    }
  }), '*');
};

View.prototype.onshow = function () {};

View.prototype.onWillHide = function () {};

View.prototype.prepare = function () {
  this.prepared = true;
};

View.prototype.reset = function () {};

exports.View = View;

},{"../../../libs/api-cjs/scripts/models":43,"spotify-inheritance/inherit":241}],35:[function(require,module,exports){
'use strict';

var mainStrings = require('../../i18n');
var inherit = require('spotify-inheritance/inherit');

var models = require('../../../../libs/api-cjs/scripts/models');
var logging = require('../utils/logging');
var View = require('../view').View;

var _ = mainStrings.get.bind(mainStrings); // shortcut for translation

var FOLLOW_BUTTON_URL_BASE = 'https://developer.spotify.com/technologies/widgets/spotify-follow-button/';

function EmbedView(app) {
  var _this = this;
  this.id = 'embed';
  this.title = _('embedTitle');
  View.call(this);
  this.app = app;
  this.embedCode = this.node.querySelector('input.embed-code');
  this.embedAdvanced = this.node.querySelector('#embed-advanced');
  this.embedImageWrapperBasic = this.node.querySelector('.embed-iframewrapper-basic');
  this.embedImageWrapperDetail = this.node.querySelector('.embed-iframewrapper-detail');

  // Bind listeners to the right context
  this._onCodeClick = this._onCodeClick.bind(this);
  this._onCancelRightClickBlocker = this._onCancelRightClickBlocker.bind(this);
  this._onAdvancedClick = this._onAdvancedClick.bind(this);
  this._onSizeButtonClick = this._onSizeButtonClick.bind(this);
  this._onCancelClick = this._onCancelClick.bind(this);

  this.embedCode.addEventListener('click', this._onCodeClick);
  this.embedCode.addEventListener('mouseover', this._onCodeClick);
  this.embedCode.addEventListener('contextmenu', this._onCancelRightClickBlocker);
  this.embedAdvanced.addEventListener('click', this._onAdvancedClick);

  // Handle clicks on the size buttons.
  this.sizeButtons = this.node.querySelectorAll('[data-size]');
  for (var i = 0; i < this.sizeButtons.length; i++) {
    this.sizeButtons[i].addEventListener('click', this._onSizeButtonClick);
  }

  // select basic view
  localStorage.shareFollowButtonSize = 'basic';
  this.node.querySelector('[data-size=\'basic\']').setAttribute('checked', 'checked');

  // check if we should hide the 'more options' button or not.
  this.embedAdvanced.setAttribute('style', 'display: none;');
  models.session.load('device').done(function (session) {
    if (session.device == 'web') {
      // enable on web. On desktop it can't open properly the target page on a standalone
      // browser window
      _this.embedAdvanced.setAttribute('style', '');
    }
  });
};
inherit(EmbedView, View);

EmbedView.prototype.onshow = function () {
  this._generatePreviews();
  this._updatePreview();

  // Ready the cancel button.
  var btnCancel = this.app.getActionButtonByAlias('cancel');
  this.app.setActionButtonText('cancel', _('actionCancel'));
  this.app.setActionButtonTabIndex('cancel', 3);
  btnCancel.addEventListener('click', this._onCancelClick);

  // Show global action bar.
  this.app.toggleActionBarDisplay(true);
  // Hide the "ok" button.
  this.app.toggleActionButtonDisplay('ok', false);
};

EmbedView.prototype.onWillHide = function () {
  this.app.getActionButtonByAlias('cancel').removeEventListener('click', this._onCancelClick);
};

/**
 * Returns the embed code for a follow button.
 *
 * @param {string} uri The uri for which to generate the button.
 * @param {string} size The size. Either "basic" or "detail".
 * @param {number} width The width of the iframe.
 * @param {number} height The height of the iframe.
 */
EmbedView.prototype._getCode = function (uri, size, width, height) {
  var iframeUrl = 'https://embed.spotify.com/follow/1/?uri=' + encodeURIComponent(uri) + '&size=' + size + '&theme=dark';
  return '<iframe width=\"' + width + '\" height=\"' + height + '\" src=\"' + iframeUrl + '\" scrolling=\"no\" frameborder=\"0\" style=\"border:none; overflow:hidden;\" allowtransparency=\"true\"></iframe>';
};

/**
 * Generates the iframe previews.
 */
EmbedView.prototype._generatePreviews = function () {
  // basic
  this.embedImageWrapperBasic.innerHTML = this._getCode(this.app.resource.uri, 'basic', 200, 25);

  // detail
  this.embedImageWrapperDetail.innerHTML = this._getCode(this.app.resource.uri, 'detail', 300, 56);
};

/**
 * Updates the iframe preview
 */
EmbedView.prototype._updatePreview = function () {
  var size = localStorage.shareFollowButtonSize;
  var activeSize = size === 'basic' ? this.embedImageWrapperBasic : this.embedImageWrapperDetail,
      nonActiveSize = size === 'detail' ? this.embedImageWrapperBasic : this.embedImageWrapperDetail;

  activeSize.style.display = 'block';
  nonActiveSize.style.display = 'none';

  this.embedCode.value = activeSize.innerHTML;

  this.embedAdvanced.setAttribute('href', FOLLOW_BUTTON_URL_BASE + '?uri=' + encodeURIComponent(this.app.resource.uri));
  this.resize();
};

EmbedView.prototype._onCodeClick = function (evt) {
  this.embedCode.select();
};

EmbedView.prototype._onCancelRightClickBlocker = function (evt) {
  evt.stopPropagation();
  return true;
};

EmbedView.prototype._onAdvancedClick = function (evt) {
  var url = FOLLOW_BUTTON_URL_BASE + '?uri=' + encodeURIComponent(this.app.resource.uri);
  models.application.openURI(url);
};

EmbedView.prototype._onSizeButtonClick = function (evt) {
  var item = evt.target;
  var size = item.getAttribute('data-size');
  localStorage.shareFollowButtonSize = size;
  this.app.logger.userHit('size_button', { size: size });
  this._updatePreview();
};

EmbedView.prototype._onCancelClick = function (evt) {
  //On click on cancel button, quit the app and assume user aborted the share.
  this.app.logger.userHit('cancel', { view: 'embed' });
  this.app.clearStateAndExit();
};

exports.EmbedView = EmbedView;

},{"../../../../libs/api-cjs/scripts/models":43,"../../i18n":11,"../utils/logging":30,"../view":34,"spotify-inheritance/inherit":241}],36:[function(require,module,exports){
'use strict';

var mainStrings = require('../../i18n');
var inherit = require('spotify-inheritance/inherit');

var View = require('../view').View;

var _ = mainStrings.get.bind(mainStrings); // shortcut for translation

function ErrorView(app) {
  this.id = 'error';
  this.app = app;
  View.call(this);
  this._onCloseButton = this._onCloseButton.bind(this);
};
inherit(ErrorView, View);

ErrorView.prototype.setError = function (error) {
  this.node.querySelector('p').textContent = error;
};

ErrorView.prototype._onCloseButton = function () {
  this.dispatchEvent({ type: 'close_click' });
};

ErrorView.prototype.onshow = function () {

  this.app.toggleActionBarDisplay(true);

  this.app.toggleActionButtonDisplay('ok', false);

  this.app.toggleGlobalNavDisplay(false);

  this.closeButton = this.app.getActionButtonByAlias('cancel');
  this.app.setActionButtonText('cancel', _('actionClose'));

  this.closeButton.addEventListener('click', this._onCloseButton);
};

ErrorView.prototype.onWillHide = function () {
  this.closeButton.removeEventListener('click', this._onCloseButton);
};

exports.ErrorView = ErrorView;

},{"../../i18n":11,"../view":34,"spotify-inheritance/inherit":241}],37:[function(require,module,exports){
'use strict';

var elements = require('../../../../libs/spotify-elements');
var mainStrings = require('../../i18n');
var inherit = require('spotify-inheritance/inherit');
var View = require('../view').View;

var _ = mainStrings.get.bind(mainStrings); // shortcut for translation

// View to authenticate to networks.
function OptionsView(app) {
  this.id = 'options';
  this.title = _('optionsTitle');
  View.call(this);
  this.app = app;

  this.backToSharingButton = this.node.querySelector('.js-options-back');

  // Add all the necessary buttons to disconnect from connected networks.
  var networkNodes = this.node.querySelectorAll('[data-network]');

  // Keep track of username, password boxes and connect buttons for each network.
  // We'll alter the state of each based on the connection state (as per design requirements)
  this.connectionButtons = {};
  this.usernameBox = {};
  this.passwordBox = {};
  for (var i = 0; i < networkNodes.length; ++i) {
    var networkName = networkNodes[i].getAttribute('data-network');

    // Set up the connect buttons for each network and handle clicks on them.
    var connectNode = networkNodes[i].querySelector('.connect-head');
    if (connectNode && networkName !== 'facebook') {
      var button = document.createElement('button');
      button.className = 'button button-green button-small';
      button.innerHTML = _('actionConnect');

      connectNode.appendChild(button);
      button.addEventListener('click', this._onConnectionButtonClick.bind(this, networkName));
      this.connectionButtons[networkName] = button;
    }

    if (connectNode && networkName === 'facebook') {
      var info = document.createElement('div');
      info.className = 'settings-info';
      info.innerHTML = _('optionsVisitSettings');
      connectNode.appendChild(info);
      info.querySelector('a').addEventListener('click', function () {
        this.app.exitApp();
      }.bind(this));
    }

    // Also, a user could potentially press 'enter' in either username/password textboxes and expect to connect.
    var username = networkNodes[i].querySelector('input[name=username]');
    if (username) {
      username.addEventListener('keydown', this._onKeyDown.bind(this, networkName));
      this.usernameBox[networkName] = username;
    }

    var password = networkNodes[i].querySelector('input[name=password]');
    if (password) {
      password.addEventListener('keydown', this._onKeyDown.bind(this, networkName));
      this.passwordBox[networkName] = password;
    }
  }

  // Handle the back-to-sharing button click
  this.backToSharingButton.addEventListener('click', this._onBackToShareButtonClick.bind(this));

  // Listen to all network status updates
  for (var network in this.app.networks) {
    this.app.networks[network].addEventListener('connection_updated', function (evt) {
      this.updateNetworkState(evt.network);
    }.bind(this));
  }
}
inherit(OptionsView, View);

/**
 * Get "disconnect" option if connected. Else, "connect".
 * @param {string} network The network to get the connect button for.
 */
OptionsView.prototype._getConnectionButton = function (network) {
  var connectButton = this.connectionButtons[network];
  if (!connectButton) {
    this.app.logger.error('network_connect_button_error', { name: network });
    return null;
  }
  return connectButton;
};

/**
 * Sets the connect button state for the given network.
 * @param {string} network The network for which the state is set.
 * @param {string} promptState The state that reflects what to prompt the user to do.
 */
OptionsView.prototype.setConnectionButtonState = function (network, promptState) {
  var connectButton = this._getConnectionButton(network);
  if (!connectButton) return;
  if (promptState === 'connect') {
    // Set the button to show "Connect" and accentuate positive in green.
    connectButton.disabled = false;
    connectButton.innerHTML = _('actionConnect');
    elements(connectButton).removeClass('button-with-stroke');
    elements(connectButton).addClass('button-green');
  } else if (promptState === 'disconnect') {
    connectButton.disabled = false;
    // Set the connect button to show "Disconnect" option and don't accentuate it.
    connectButton.innerHTML = _('actionDisconnect');
    elements(connectButton).removeClass('button-green');
    elements(connectButton).addClass('button-with-stroke');
  } else if (promptState === 'unknown') {
    connectButton.disabled = true;
  }
  connectButton.setAttribute('data-type', promptState);
};

OptionsView.prototype._disableUsernameBox = function (network) {
  if (this.usernameBox.hasOwnProperty(network)) {
    var u = this.usernameBox[network];
    u.setAttribute('disabled', true);
    this._readyPlaceholder(u, '**********');
  }
};

OptionsView.prototype._disablePasswordBox = function (network) {
  if (this.passwordBox.hasOwnProperty(network)) {
    var p = this.passwordBox[network];
    p.setAttribute('disabled', true);
    this._readyPlaceholder(p, '**********');
  }
};

OptionsView.prototype._enableUsernameBox = function (network) {
  if (this.usernameBox.hasOwnProperty(network) && this.usernameBox[network].hasAttribute('disabled')) {
    var u = this.usernameBox[network];
    this._readyPlaceholder(u);
    u.removeAttribute('disabled');
  }
};

OptionsView.prototype._enablePasswordBox = function (network) {
  if (this.passwordBox.hasOwnProperty(network) && this.passwordBox[network].hasAttribute('disabled')) {
    var p = this.passwordBox[network];
    this._readyPlaceholder(p);
    p.removeAttribute('disabled');
  }
};

/**
 * Grabs placeholder strings from the node's attributes, and either
 * sets the placeholder via {app._translateDataString} or calls into the
 * placeholder polyfill.
 * @param  {Element} node Use this node to attach placeholder text. Assumes
 *   the node has 'data-string' and 'data-attribute' attributes.
 * @param  {string=} opt_text If defined, will override the placeholder value.
 */
OptionsView.prototype._readyPlaceholder = function (node, opt_text) {
  var placeholderKey = node.getAttribute('data-string'),
      placeholderAttr = node.getAttribute('data-attribute');

  this.app._translateDataString(node, placeholderKey, placeholderAttr);
  if (opt_text) {
    node.setAttribute(placeholderAttr, opt_text);
  }
};

OptionsView.prototype._onKeyDown = function (network, evt) {
  // If "enter" is pressed, the credentials should attempt to authenticate.
  if (evt.keyCode == 13) this._onConnectRequest(network);
};

OptionsView.prototype.onshow = function () {
  // Empty all fields.
  Array.prototype.forEach.call(this.node.querySelectorAll('input'), function (input) {
    input.value = '';
  });

  for (var network in this.app.networks) {
    // By default, set the connection state initially to unknown.
    this.setConnectionButtonState(network, 'unknown');
    this.updateNetworkState(network);
  }

  this.app.toggleActionBarDisplay(false);
  this.app.toggleGlobalNavDisplay(false);
};

OptionsView.prototype.onWillHide = function () {
  this.app.toggleGlobalNavDisplay(true);
};

OptionsView.prototype._onConnectionButtonClick = function (network, evt) {
  var connectButton = this._getConnectionButton(network);
  if (!connectButton) return;

  var type = connectButton.getAttribute('data-type');

  if (type === 'disconnect') {
    this._onDisconnectClick(network);
  } else if (type === 'connect') {
    this._onConnectRequest(network);
  } else {
    this.app.logger.error('unknown_network_state_button_error', { network: network, type: type });
  }
  connectButton.disabled = false;
};

OptionsView.prototype._onDisconnectClick = function (network) {
  this.app.networks[network].disconnect();
  this.app.logger.userHit('network_disconnect', {}, network);
};

/**
 * Method to call to update the state of a network's connected state.
 * @param {string} network The network for which the state should be updated.
 */
OptionsView.prototype.updateNetworkState = function (network) {
  // Update the state texts (connected/not connected) for the social networks.
  var networkNode = this.node.querySelector('[data-network=' + network + ']');
  var stateNode = networkNode.querySelector('.state');
  var accountNode = networkNode.querySelector('.account');

  elements(networkNode).removeClass('error');
  var promptState = 'unknown'; // The state to prompt to the user
  if (this.app.networks[network].enabled) {
    elements(networkNode).addClass('connected');
    elements(networkNode).removeClass('unknown');
    stateNode.textContent = this.app.networks[network].getStateText() + ' ';
    accountNode.textContent = this.app.networks[network].getName();
    this._disableUsernameBox(network);
    this._disablePasswordBox(network);
    this.setConnectionButtonState(network, 'disconnect');
  } else {
    elements(networkNode).removeClass('connected');
    if (this.app.networks[network].enabled === false) {
      elements(networkNode).removeClass('unknown');
      stateNode.textContent = _('connectToNetwork', this.app.networks[network].displayName);
      this._enableUsernameBox(network);
      this._enablePasswordBox(network);
      this.setConnectionButtonState(network, 'connect');
    } else {
      elements(networkNode).addClass('unknown');
      stateNode.textContent = _('optionsStateUnknown');
      this._disableUsernameBox(network);
      this._disablePasswordBox(network);
      this.setConnectionButtonState(network, 'unknown');
    }
  }
};

OptionsView.prototype._onConnectRequest = function (network) {
  var networkNode = this.node.querySelector('[data-network=' + network + ']');
  var stateNode = networkNode.querySelector('.state');
  var username = this.usernameBox[network];
  var password = this.passwordBox[network];

  if (username && !username.value || password && !password.value) {
    return;
  }

  var connectButton = this._getConnectionButton(network);
  if (connectButton) connectButton.disabled = true;

  this._disableUsernameBox(network);
  this._disablePasswordBox(network);

  // Facebook does not have a user/pass box, prepare empty string for
  // generic `connect` call below
  var usernameValue = username ? username.value : '';
  var passwordValue = password ? password.value : '';

  elements(networkNode).addClass('connecting');
  elements(networkNode).removeClass('error');

  this.app.logger.userHit('network_connect', { username: usernameValue }, network);
  this.app.networks[network].connect(usernameValue, passwordValue).done(this, function (hermesReply) {
    // Check any network that the user successfully connects to.
    if (username) username.value = ''; // Reset the username.
    if (password) password.value = '';
    // disable AGAIN to enable placeholder fallbacks to update properly
    this._disableUsernameBox(network);
    this._disablePasswordBox(network);
    this.app.logger.info('network_connected', {}, network);
  }).fail(this, function (req, error) {
    // If auth failed, reenable the username and password boxes
    // Since no connection_update is sent, we need to reenable the buttons we just disabled
    this._enableUsernameBox(network);
    this._enablePasswordBox(network);
    if (connectButton) {
      connectButton.disabled = false;
    }
    elements(networkNode).addClass('error');

    // Link has a bug where code is an object.
    var errorCode = error.code && error.code.code || error.code;
    stateNode.textContent = _(errorCode == 401 ? 'optionsConnectFailed' : 'optionsConnectError');

    this.app.logger.error('network_connect_fail', { errorCode: error.code }, network);
  }).always(this, function (hermesReply) {
    elements(networkNode).removeClass('connecting');
    this.resize();
  });
};

OptionsView.prototype._onBackToShareButtonClick = function (evt) {
  this.app.logger.userHit('back_to_share_view');
  this.dispatchEvent({ type: 'show_share_view' });
};

// Reset method for options view. When window closes due to external clicks.
OptionsView.prototype.reset = function () {
  // Given that the user was in options view, reset them back to share view.
  this.dispatchEvent({ type: 'show_share_view' });
};

exports.OptionsView = OptionsView;

},{"../../../../libs/spotify-elements":56,"../../i18n":11,"../view":34,"spotify-inheritance/inherit":241}],38:[function(require,module,exports){
'use strict';

var userItemTemplate = require('../../../../libs/spotify-glue-cat/templates/v1/list-group-item-media.hbs');
var elements = require('../../../../libs/spotify-elements');
var mainStrings = require('../../i18n');
var inherit = require('spotify-inheritance/inherit');

var facebook = require('../../../../libs/api-cjs/scripts/facebook');
var models = require('../../../../libs/api-cjs/scripts/models');
var autocomplete = require('../autocomplete');
var logging = require('../utils/logging');
var messaging = require('../newmessaging');
var View = require('../view').View;

// Shortcut for translation.
var _ = mainStrings.get.bind(mainStrings);

var AUTOCOMPLETE_RESULTS = 4;
var DEFAULT_USER_ICON = 'images/user-icon.png';
var USER_ATTRIBUTE = 'data-user';

// view to send music to friends privately.
function SendView(app) {
  this.id = 'send';
  this.title = _('shareTitle');
  View.call(this);
  this.app = app;

  // Bind listeners to the right context
  this._onSendClick = this._onSendClick.bind(this);
  this._onCancelClick = this._onCancelClick.bind(this);
  this._onInputBlur = this._onInputBlur.bind(this);
  this._onInputFocus = this._onInputFocus.bind(this);
  this._search = this._search.bind(this);
  this._onInputKeyDown = this._onInputKeyDown.bind(this);
  this._onSelectedUserClick = this._onSelectedUserClick.bind(this);
  this._onUserSelect = this._onUserSelect.bind(this);

  this.messageBox = this.node.querySelector('.message');
  this.messageBox.addEventListener('keyup', function (event) {
    localStorage.message = event.target.value;
  });

  this.userList = this.node.querySelector('#user-list');
  this.userList.addEventListener('click', this._onSelectedUserClick);

  this.userInput = this.userList.querySelector('input');
  this.userInput.addEventListener('blur', this._onInputBlur);
  this.userInput.addEventListener('focus', this._onInputFocus);
  this.userInput.addEventListener('keyup', this._search);
  this.userInput.addEventListener('keydown', this._onInputKeyDown);

  // Keep track of all currently showing results of the autocomplete search.
  this.results = this.node.querySelector('#user-results');
  this.resultsItems = [];
  this.selectedResultIndex = 0;

  this.results.addEventListener('mousedown', this._onUserSelect);

  autocomplete.addEventListener('loading', function () {
    elements(this.results).addClass('loading');
  }.bind(this));

  autocomplete.addEventListener('done', function () {
    elements(this.results).removeClass('loading');
  }.bind(this));

  this.filter = new autocomplete.Filter();
  this.filter.addEventListener('change', function (event) {
    this._renderUserResults(event.result);
  }.bind(this));
}
inherit(SendView, View);

SendView.prototype._onInputBlur = function () {
  this.resetUserInput();
  elements(this.userList).removeClass('focus');
};

SendView.prototype._onInputFocus = function () {
  elements(this.userList).addClass('focus');
};

SendView.prototype._onInputKeyDown = function (event) {

  this.userInput.setAttribute('size', this.userInput.value.length + 6);

  // Handle case when keystroke is used to perform an action
  // on the previous selections of the recipients.
  if (!this.userInput.value && !this.resultsItems.length) {
    switch (event.keyCode) {
      case 8:
        // Backspace
        var lastUser = this.userList.querySelector('.selected-user:last-of-type');
        this.unselectUser(lastUser);
      default:
        return; // bail regardless
    }
  }

  // Handle special key presses when autocompleting names
  var oldIndex = this.selectedResultIndex;
  switch (event.keyCode) {
    case 9: // Tab
    case 13: // Return
    case 188:
      // Comma

      if (event.preventDefault) event.preventDefault();
      event.returnValue = false;

      if (!this.resultsItems.length) return;

      // Add the currently selected user to the list.
      var userKey = this.resultsItems[this.selectedResultIndex].getAttribute(USER_ATTRIBUTE);
      this.selectUser(userKey);

      break;
    case 27:
      // Escape
      this.resetUserInput();
      return;
    case 38:
      // Up
      this.selectedResultIndex--;
      if (this.selectedResultIndex < 0) this.selectedResultIndex = this.resultsItems.length - 1;
      break;
    case 40:
      // Down
      this.selectedResultIndex++;
      if (this.selectedResultIndex >= this.resultsItems.length) this.selectedResultIndex = 0;
      break;
    default:
      return;
  }

  // Change the selected list item.
  if (oldIndex !== this.selectedResultIndex) {
    if (this.resultsItems[oldIndex]) {
      elements(this.resultsItems[oldIndex]).removeClass('active');
    }
    if (this.resultsItems[this.selectedResultIndex]) {
      elements(this.resultsItems[this.selectedResultIndex]).addClass('active');
    }
  }
};

SendView.prototype._onSelectedUserClick = function (event) {
  var target = event.target;
  if (elements(target).hasClass('delete')) {
    this.unselectUser(target.parentNode);
  } else {
    // Focus the user input when clicking inside user list.
    this.userInput.focus();
  }
};

SendView.prototype._onCancelClick = function () {
  this.app.logger.userHit('cancel', { view: 'send' });
  this.app.clearStateAndExit();
};

SendView.prototype._onSendClick = function () {
  elements(document.body).addClass('sending');
  this.app.toggleActionButtonDisabled('ok', true);

  var message = this.messageBox.value;

  // Get the Spotify and Facebook users out of the users in the user list.
  var spotifyUsers = [];
  var facebookUsers = [];

  var promises = [];

  var users = this.getSelectedUsers();
  for (var i = 0; i < users.length; i++) {
    var user = users[i];
    if (user instanceof facebook.FacebookUser) {
      facebookUsers.push(user);
    } else {
      spotifyUsers.push(user);
    }
  }

  // Create a list of usernames for logging purposes.
  var usernamesForLogging = spotifyUsers.map(function (user) {
    return user.username || user.uri.substr('spotify:user:'.length);
  });

  // Log that the user hit the "Send" button (other information is logged per
  // backend request).
  this.app.logger.userHit('send', {
    facebookUsers: facebookUsers.map(function (user) {
      return user.id;
    }),
    facebookUsersCount: facebookUsers.length,
    spotifyUsers: usernamesForLogging,
    spotifyUsersCount: spotifyUsers.length,
    message: message,
    resource: this.app.resource.uri
  });

  // Send a message to the user inside of Spotify.
  if (spotifyUsers.length) {
    var spotifySendPromise = messaging.send(spotifyUsers, message, this.app.resource);
    promises.push(spotifySendPromise);

    logging.logPromise(spotifySendPromise, this.app.logger, 'messaging');
  }

  // Send a message to a user's Facebook inbox.
  if (facebookUsers.length) {
    var facebookSendPromise = facebook.session.message(facebookUsers, message, this.app.resource);
    promises.push(facebookSendPromise);

    logging.logPromise(facebookSendPromise, this.app.logger, 'facebook_message');
  }

  models.Promise.join(promises).done(this, function () {
    elements(document.body).removeClass('sending');
    setTimeout(this.app.clearStateAndExit.bind(this.app), 240);
  });
};

SendView.prototype._onUserSelect = function (event) {
  var item = event.target;
  while (!item.getAttribute(USER_ATTRIBUTE)) {
    item = item.parentNode;
    if (!item || item == this.node) return;
  }

  this.selectUser(item.getAttribute(USER_ATTRIBUTE));
};

SendView.prototype._renderUserResults = function (users) {
  this.results.innerHTML = '';

  var node;

  var throbber = document.createElement('span');
  throbber.className = 'list-group-item throbber-item';
  throbber.innerHTML = '<div class="throbber"><div></div></div>';
  this.results.appendChild(throbber);

  // If the list was empty, just add one item telling the user there were no results.
  if (!users.length) {
    node = document.createElement('span');
    node.className = 'no-results list-group-item';
    node.textContent = _('couldNotFindUser');

    this.results.insertBefore(node, throbber);
    this.results.style.display = 'block';

    this.resultsItems = [];
    return;
  }

  // Limit the number of results to render.
  users = users.slice(0, AUTOCOMPLETE_RESULTS);

  var user, modifiers, data;
  // Staging element for converting template HTML to DOM.
  var staging = document.createElement('div');
  for (var i = 0; i < users.length; i++) {
    user = users[i];

    data = {
      // FB users do not have uris, but the media object needs a
      // spotify:user:* to properly style itself as a user.
      uri: user.uri || 'spotify:user:FBUSERONLY',
      imageUrl: user.image || '', // Just in case
      name: user.name.decodeForText()
    };

    // Build the node representing the user.
    modifiers = [];
    if (i == this.selectedResultIndex) data.modifiers = 'active';
    if (!user.image) data.mediaModifiers = 'placeholder-visible';

    staging.innerHTML = userItemTemplate(data);

    node = staging.childNodes[0];
    node.setAttribute(USER_ATTRIBUTE, autocomplete.getUserKey(user));
    this.results.insertBefore(node, throbber);
  }

  this.resultsItems = this.results.querySelectorAll('[' + USER_ATTRIBUTE + ']');
  this.results.style.display = 'block';
};

SendView.prototype._search = function () {
  if (!this.userInput.value) {
    this.resetUserInput();
    return;
  }

  this.filter.setExcludeList(this.getSelectedUsers());
  this.filter.search(this.userInput.value);
};

SendView.prototype.getSelectedUsers = function () {
  var users = [];

  var userSpans = this.userList.querySelectorAll('.selected-user');
  for (var i = 0; i < userSpans.length; i++) {
    var userKey = userSpans[i].getAttribute(USER_ATTRIBUTE);
    users.push(autocomplete.getUserFromKey(userKey));
  }

  return users;
};

SendView.prototype.resetUserInput = function () {
  this.filter.clear();
  this.userInput.value = '';
  this.results.style.display = 'none';

  // Reset the items in the autocomplete results.
  this.resultsItems = [];

  // Reset the other parameters while selecting a user.
  this.selectedResultIndex = 0;
};

SendView.prototype.selectUser = function (userKey) {
  var user = autocomplete.getUserFromKey(userKey);

  var node = document.createElement('span');
  node.className = 'selected-user';
  node.textContent = user.name;
  node.setAttribute(USER_ATTRIBUTE, userKey);

  var deleteNode = document.createElement('span');
  deleteNode.className = 'delete';
  node.appendChild(deleteNode);

  this.userList.insertBefore(node, this.userInput);
  this.app.toggleActionButtonDisabled('ok', false);

  this.userInput.style.width = 'auto';
  this.userInput.setAttribute('placeholder', '');
  this.userInput.setAttribute('size', '1');

  this.resetUserInput();

  // Reset the focus back into the input box
  // in case the user wants to add more users
  this.setFocusUserInput();
  this.resize();
};

SendView.prototype.unselectAllUsers = function () {
  var users = this.userList.querySelectorAll('.selected-user');
  for (var i = 0; i < users.length; i++) {
    this.unselectUser(users[i]);
  }
};

SendView.prototype.unselectUser = function (node) {
  if (!node || !node.getAttribute(USER_ATTRIBUTE)) return;
  if (!this.userList.removeChild(node)) return;

  if (!this.userList.querySelectorAll('.selected-user').length) {
    var placeholderText = _('fieldTo');
    this.userInput.setAttribute('placeholder', placeholderText);
    this.userInput.removeAttribute('size');
    this.userInput.style.width = '100%';

    this.app.toggleActionButtonDisabled('ok', true);
  }

  this.resize();
};

SendView.prototype.onshow = function () {

  autocomplete.init();

  localStorage.view = 'send';
  this.messageBox.value = localStorage.message || '';
  this.setFocusUserInput();

  this.app.toggleGlobalNavDisplay(true);

  var btnOk = this.app.getActionButtonByAlias('ok');
  this.app.setActionButtonText('ok', this.app.inviteMode ? _('actionInviteFriends') : _('actionSend'));
  this.app.setActionButtonTabIndex('ok', 3);
  this.app.toggleActionButtonDisplay('ok', true);

  var btnCancel = this.app.getActionButtonByAlias('cancel');
  this.app.setActionButtonText('cancel', _('actionCancel'));
  this.app.setActionButtonTabIndex('cancel', 4);

  // Immediately disable unless recipients are selected.
  this.app.toggleActionButtonDisabled('ok', this.getSelectedUsers().length === 0);

  btnOk.addEventListener('click', this._onSendClick);
  btnCancel.addEventListener('click', this._onCancelClick);
};

SendView.prototype.onWillHide = function () {
  // Kill all button listeners.

  var btnOk = this.app.getActionButtonByAlias('ok');
  var btnCancel = this.app.getActionButtonByAlias('cancel');
  btnOk.removeEventListener('click', this._onSendClick);
  btnCancel.removeEventListener('click', this._onCancelClick);
};

/**
 * Reset method for send view. When window closes due to external clicks.
 */
SendView.prototype.reset = function () {
  // To be safe, reset the user input though the 'blur' event triggered
  // would've triggered this effect (see constructor).
  this.resetUserInput();

  // Simply reset any auto-completed names.
  this.unselectAllUsers();

  this.messageBox.value = '';

  this.dispatchEvent({ type: 'show_share_view' });
};

SendView.prototype.setFocusUserInput = function () {
  var input = this.userInput;
  input.focus();
  setTimeout(function () {
    input.focus();
  }, 100);
};

exports.SendView = SendView;

},{"../../../../libs/api-cjs/scripts/facebook":40,"../../../../libs/api-cjs/scripts/models":43,"../../../../libs/spotify-elements":56,"../../../../libs/spotify-glue-cat/templates/v1/list-group-item-media.hbs":84,"../../i18n":11,"../autocomplete":23,"../newmessaging":29,"../utils/logging":30,"../view":34,"spotify-inheritance/inherit":241}],39:[function(require,module,exports){
(function (global){
'use strict';

var mainStrings = require('../../i18n');
var inherit = require('spotify-inheritance/inherit');
var Logger = require('../../../../libs/spotify-client-logger');
var pkg = require('../../package.json');
var logger = new Logger();
logger.setConstant({ source: pkg.name });

var IS_REMOVE_ACTIVITY_AB_TEST = global.__spotify && global.__spotify.product_state && global.__spotify.product_state['ab-remove-activity'] === '1';

var models = require('../../../../libs/api-cjs/scripts/models');
var hermes = require('../../../../libs/api-cjs/scripts/hermes');
var logging = require('../utils/logging');
var View = require('../view').View;

var _ = mainStrings.get.bind(mainStrings); // shortcut for translation

// view that allows posting to Spotify and external networks.
function ShareView(app) {
  var self = this;

  this.id = 'share';
  this.title = _('shareTitle');
  View.call(this);
  this.app = app;

  // Bind listeners to the right context
  this._dispatchShowOptions = this._dispatchShowOptions.bind(this);
  this._onNetworkButtonsClick = this._onNetworkButtonsClick.bind(this);
  this._onCancelClick = this._onCancelClick.bind(this);
  this._onShareClick = this._onShareClick.bind(this);

  this.messageText = getViewNode().querySelector('textarea');

  var optionsButton = getViewNode().querySelector('#share-options');
  optionsButton.addEventListener('click', this._dispatchShowOptions);

  this.networkButtons = getViewNode().querySelectorAll('[data-network]');
  for (var i = 0; i < this.networkButtons.length; i++) {
    this.networkButtons[i].addEventListener('click', this._onNetworkButtonsClick);
  }

  this.messageBox = getViewNode().querySelector('.message');
  this.messageBox.addEventListener('keyup', function (evt) {
    localStorage.message = evt.target.value;
  });

  // Listen for connection updates on each network,
  // and do interface updates when they change
  var networkNames = Object.keys(this.app.networks);
  networkNames.forEach(function (networkName) {

    var networkModel = app.networks[networkName];
    networkModel.addEventListener('connection_updated', function onConnectionUpdated() {
      var networkNode = getViewNode().querySelector('[data-network=' + networkName + ']');

      if (networkModel.enabled && networkModel.selected) {
        networkNode.classList.add('selected');
      } else {
        networkNode.classList.remove('selected');
      }

      updateShareButtonState();
    });
  });

  this.bouncerSchema = hermes.Schema.fromURL('proto/bouncer.proto');

  updateShareButtonState();

  getViewNode().querySelector('#networks-label span').innerText = IS_REMOVE_ACTIVITY_AB_TEST ? _('shareToPlain') : _('shareTo');
};
inherit(ShareView, View);

ShareView.prototype.onshow = function () {
  this.alreadyShared = false;

  localStorage.view = 'share';
  var msgBox = this.messageBox;
  var textarea = this.messageText;
  setTimeout(function () {
    textarea.focus();
    msgBox.value = localStorage.message || '';
  }, 100);

  this.app.toggleActionBarDisplay(true);

  var btnOk = this.app.getActionButtonByAlias('ok');
  this.app.setActionButtonText('ok', _('actionShare'));
  this.app.setActionButtonTabIndex('ok', 2);
  this.app.toggleActionButtonDisplay('ok', true);
  this.app.toggleActionButtonDisabled('ok', false);

  var btnCancel = this.app.getActionButtonByAlias('cancel');
  this.app.setActionButtonText('cancel', _('actionCancel'));
  this.app.setActionButtonTabIndex('cancel', 3);
  this.app.toggleActionButtonDisplay('cancel', true);
  this.app.toggleActionButtonDisabled('cancel', false);

  btnCancel.addEventListener('click', this._onCancelClick);
  btnOk.addEventListener('click', this._onShareClick);

  updateShareButtonState();
};

ShareView.prototype.onWillHide = function () {
  var btnOk = this.app.getActionButtonByAlias('ok');
  var btnCancel = this.app.getActionButtonByAlias('cancel');
  btnOk.removeEventListener('click', this._onShareClick);
  btnCancel.removeEventListener('click', this._onCancelClick);
};

ShareView.prototype._onNetworkButtonsClick = function (evt) {
  var item = evt.target.parentNode;
  var network = item.getAttribute('data-network');

  if (!this.app.networks[network] || !item.classList.contains('selected') && !this.app.networks[network].enabled) {
    logUserHit('network_button', { network: network });
    this._dispatchShowOptions();
    return;
  }

  // Make a note of user unselecting a network so it's not
  // automatically reselected on refresh.
  if (item.classList.contains('selected')) {
    item.classList.remove('selected');
    this.app.networks[network].selected = false;
  } else {
    item.classList.add('selected');
    this.app.networks[network].selected = true;
  }

  // Remember the user's preference.
  localStorage['select-network-' + network] = this.app.networks[network].selected ? 'selected' : '';

  logUserHit('network_button', {
    network: network,
    willShare: this.app.networks[network].selected ? 'true' : 'false',
    authenticated: this.app.networks[network].getName()
  });

  updateShareButtonState();
};

ShareView.prototype._dispatchShowOptions = function () {
  logger.userHit('options_button');
  this.dispatchEvent({ type: 'show_options_view' });
};

ShareView.prototype._onCancelClick = function (evt) {
  logger.userHit('cancel', { view: 'share' });
  clearMessageBox();
  this.app.clearStateAndExit();
};

ShareView.prototype._onShareClick = function () {
  if (this.alreadyShared) return;
  this.share().always(this, function () {
    clearMessageBox();
    setTimeout(this.app.clearStateAndExit.bind(this.app), 240);
  });
};

ShareView.prototype.share = function () {
  if (this.alreadyShared) return;
  this.alreadyShared = true;

  // Disable the button.
  this.app.toggleActionButtonDisabled('ok', true);

  document.body.classList.add('sending');

  // Post the message.
  var selectedNetworks = getSelectedNetworkNames();
  var sharedUrl = this.app.resource.uri.toSpotifyURL();
  var networksPostPromises = [];
  var message = this.messageBox.value;

  // toSpotifyURL returns a play.spotify url in Link.
  // Tumblr won't post UPB unless open.spotify.link is passed.
  // Probably safer to do the same with Twitter too.
  sharedUrl = sharedUrl.replace('https://play.spotify.com', 'http://open.spotify.com');

  // XXX: The added "#" prevents the demonic censorship code from replacing
  // the URI with a URL.
  sharedUrl += '#';

  // Log the share action.
  var connectedNetworks = [];
  for (var network in this.app.networks) {
    if (this.app.networks[network].enabled) {
      connectedNetworks.push(network);
    }
  }

  // Log that a share was initiated.
  logUserHit('share', {
    networks: selectedNetworks.join(' '),
    resource: this.app.resource.uri,
    message: message,
    connectedNetworks: connectedNetworks.join(' ')
  });

  // Measure the total time to share.
  var logTimerKey = logger.createTimer('share');

  // Always share to Spotify Social through presence/feed and bouncer.
  // By posting to one's own feed, a user's followers see this activity.
  var promise;

  // Bouncer.
  var socialStory = {
    type: 'SHARED_URI',
    uri: this.app.resource.uri,
    metadata: { summary: message }
  };

  var req = hermes.Hermes.request('POST', 'hm://bouncer/story', [this.bouncerSchema.type('SocialStory')], [this.bouncerSchema.type('SocialStory')]);

  promise = req.send(socialStory);
  networksPostPromises.push(promise);

  logPromise(promise, 'bouncer');

  // *** NOTE ***
  // KM-8783: Presence sharing removed, since posting shared uris is no
  // longer supported by the backend, nor presented in the client.

  // Other networks.
  var self = this;
  selectedNetworks.forEach(function (network) {
    promise = self.app.networks[network].post(message, self.app.urlTitle, sharedUrl);
    networksPostPromises.push(promise);

    promise.done(function () {
      self.dispatchEvent({ type: 'shared_to_network', network: network });
    });

    logPromise(promise, network);
  });

  // When shares finish, log the time it took and clear the "sending" state.
  return models.Promise.join(networksPostPromises).always(this, function () {
    logger.logTimer(logTimerKey);

    document.body.classList.remove('sending');

    clearMessageBox();

    this.app.toggleActionButtonDisabled('ok', false);
  });
};

function clearMessageBox() {
  getViewNode().querySelector('.message').value = '';
}

function getSelectedNetworkNames() {
  var selectedNetworkButtonElements = getViewNode().querySelectorAll('[data-network].selected');
  return Array.from(selectedNetworkButtonElements).map(function (element) {
    return element.dataset.network;
  });
}

function updateShareButtonState() {
  if (IS_REMOVE_ACTIVITY_AB_TEST) {
    var shareButtonElement = document.querySelector('#primary-controls .js-ok-button');
    shareButtonElement.disabled = getSelectedNetworkNames().length === 0;
  }
}

function getViewNode() {
  return document.getElementById('share');
}

function logPromise(promise, name) {
  logging.logPromise(promise, logger, name);
}

function logUserHit(name, data) {
  logger.userHit(name, data);
}

exports.ShareView = ShareView;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../../../libs/api-cjs/scripts/hermes":41,"../../../../libs/api-cjs/scripts/models":43,"../../../../libs/spotify-client-logger":51,"../../i18n":11,"../../package.json":21,"../utils/logging":30,"../view":34,"spotify-inheritance/inherit":241}],40:[function(require,module,exports){
'use strict';

var hermes = require('./hermes');
var models = require('./models');

/**
 * Functions for getting Facebook information for the user.
 *
 * @exports api/facebook
 * @since 1.18.0
 *
 * @example
 * // Post a track to the current user's timeline.
 * require(['./facebook', './models'], function(facebook, models) {
 *   facebook.session.post('Dance!', 'spotify:track:0FutrWIUM5Mg3434asiwkp');
 * });
 */

/**
 * @typedef {module:api/models~Album|module:api/models~Artist|module:api/models~Playlist|module:api/models~Track}
 */
var Attachment;

// Don't use an explicit path so that this works with Zelda. Note: This path
// has to exist in the app's directory for this to work, because SPM apps don't
// have frameworks in runtime (they are embedded).
var _schema = hermes.Schema.fromURL('proto/facebook.proto'),
    SERVICE = 'hm://facebook';

// Adds callbacks to a promise, optionally passing the returned data through
// a "parser" which will transform the data to the expected format.
function _addCallbacks(promise, parser, callback, opt_errback) {
  promise.done(function (frames) {
    var data = frames && frames[0] ? frames[0] : null;
    callback(parser ? parser(data) : data);
  }).fail(function (_, error) {
    if (opt_errback) {
      opt_errback(error);
    }
  });
}

function _fbUserFactory(id, opt_metadata) {
  return FacebookUser.fromId(id, opt_metadata);
}

function _getCredentials(username, callback, opt_errback) {
  var req = hermes.Hermes.get(SERVICE + '/user/' + encodeURIComponent(username), [_schema.type('UserState')], [_schema.type('UserState')]);

  _addCallbacks(req.send({}), null, callback, opt_errback);
}

// Gets information about the logged in user's Facebook profile.
function _getSession(callback, opt_errback) {
  models.session.user.load('username').done(function (user) {
    var req = hermes.Hermes.get(SERVICE + '/user/' + encodeURIComponent(user.username) + '/me', [_schema.type('User')], [_schema.type('UserRequest')]);

    var payload = {
      fields: {
        display_name: true,
        picture_large: true
      }
    };

    _addCallbacks(req.send(payload), _parseSession, callback, opt_errback);
  });
}

// Gets information about the specified Facebook profile.
function _getUserData(uid, callback, opt_errback) {
  var req = hermes.Hermes.get(SERVICE + '/uid/' + encodeURIComponent(uid) + '/me', [_schema.type('User')], [_schema.type('UserRequest')]);

  var payload = {
    fields: {
      display_name: true,
      picture_large: true
    }
  };

  _addCallbacks(req.send(payload), _parseUserData, callback, opt_errback);
}

// Turns a Facebook service response into a collection data structure.
function _parseFriendsList(data) {
  var ids = [],
      metadata = [];

  data.friends.forEach(function (friend) {
    ids.push(friend.facebook_uid);
    metadata.push(_parseUserData(friend));
  });

  return {
    length: data.friends.length,
    array: ids,
    metadata: metadata
  };
}

function _parseSession(data) {
  return {
    facebookUser: data.facebook_uid,
    name: data.display_name,
    image: data.picture_large
  };
}

function _parseUserData(data) {
  var result = {
    user: data.spotify_username ? 'spotify:user:' + data.spotify_username : null
  };

  if (data.display_name) result.name = data.display_name;
  if (data.picture_large) result.image = data.picture_large;

  return result;
}

// Sends a private message to the specified Facebook ids.
function _sendMessage(uids, message, url, callback, opt_errback) {
  models.session.user.load('username').done(function (user) {
    _getCredentials(user.username, function (payload) {
      var req = hermes.Hermes.request('POST', SERVICE + '/inbox', [_schema.type('InboxReply')], [_schema.type('InboxRequest')]);

      payload.facebook_uids = uids;

      // XXX: The added "#" prevents the demonic censorship code from
      // replacing the URI with a URL.
      payload.message_link = url + '#';

      if (message) {
        payload.message_text = message;
      }

      // We could parse message/thread id here, but we don't need it.
      _addCallbacks(req.send(payload), null, callback, opt_errback);
    }, opt_errback);
  });
}

// Posts a message on the current user's Facebook timeline.
function _share(message, resourceUri, callback, opt_errback) {
  models.session.user.load('username').done(function (user) {
    _getCredentials(user.username, function (payload) {
      var req = hermes.Hermes.request('POST', SERVICE + '/user/' + encodeURIComponent(user.username) + '/share', [_schema.type('ShareReply')], [_schema.type('ShareRequest')]);

      payload.uri = resourceUri;

      if (message) {
        payload.message_text = message;
      }

      // We could parse post id here, but we don't need it.
      _addCallbacks(req.send(payload), null, callback, opt_errback);
    }, opt_errback);
  });
}

// Handles requesting a list of Facebook friends of the user specified by the
// list descriptor, using the Collection API.
function _snapshotFriends(descriptor, offset, length, raw) {
  var promise = new models.Promise();
  var done = function done(data) {
    promise.setDone(data);
  };
  var fail = function fail(error) {
    promise.setFail(error);
  };

  models.User.fromURI(descriptor.uri).load('username').done(function (user) {
    var req = hermes.Hermes.get(SERVICE + '/user/' + encodeURIComponent(user.username) + '/friends', [_schema.type('FriendsReply')], [_schema.type('FriendsRequest')]);

    // Set up options for the request.
    var options = {
      offset: offset
    };

    // The Facebook service doesn't take -1 for "all", instead the limit
    // should only be set if an actual length was specified.
    if (length > -1) {
      options.limit = length;
    }

    // Assemble the full payload of the friends request.
    var payload = {
      options: options,
      fields: {
        app_user: true,
        display_name: true,
        picture_large: true
      }
    };

    // Raw means no metadata is needed, so don't request any fields.
    if (raw) {
      delete payload.fields;
    }

    _addCallbacks(req.send(payload), _parseFriendsList, done, fail);
  }).fail(function (_, error) {
    fail(error);
  });

  return promise;
}

/**
 * The Facebook session of the current user.
 *
 * @class
 * @extends {module:api/models~Loadable}
 * @classdesc A Facebook session which allows interaction with the Facebook
 *     graph.
 * @since 1.18.0
 *
 * @property {module:api/models~User} user The user that the Facebook session
 *     is for.
 * @property {module:api/models~Collection} friends A collection of Facebook
 *     users that are friends of the current user on Facebook.
 * @property {module:api/facebook~FacebookUser} facebookUser The Facebook
 *     user that this session represents.
 */
function FacebookSession() {
  models.Loadable.call(this);

  this.resolve('user', models.session.user);
  this.resolve('friends', new models.Collection(FacebookUser, null, _snapshotFriends, this.user.uri, _fbUserFactory));
}
SP.inherit(FacebookSession, models.Loadable);

models.Loadable.define(FacebookSession, ['user', 'friends']);
models.Loadable.define(FacebookSession, ['facebookUser'], '_loadSession');

/**
 * Sends a query to get the Facebook information for the current user.
 *
 * @param {number} propsMask A bitmask of properties that are needed.
 *
 * @private
 */
FacebookSession.prototype._loadSession = function (propsMask) {
  var self = this;
  var load = function load(data) {
    self.resolveMany(propsMask, data);
  };
  var fail = function fail(error) {
    self.resolveFail(propsMask, error);
  };

  _getSession(load, fail);
};

/**
 * Builds a FacebookUser instance from the id returned by the bridge.
 *
 * @param {string} value A Facebook user id.
 *
 * @private
 */
FacebookSession.prototype._make_facebookUser = function (value) {
  return value ? FacebookUser.fromId(value) : null;
};

/**
 * Adds a post to the current user's Facebook timeline.
 *
 * @param {string} text The text of the post.
 * @param {string} uri  The URI of the attement
 * @return {module:api/models~Promise} A promise.
 */
FacebookSession.prototype.post = function (text, uri) {
  var promise = new models.Promise(this);

  _share(text, uri, function () {
    promise.setDone();
  }, function (error) {
    promise.setFail(error);
  });

  return promise;
};

/**
 * Sends a Facebook message to one or more Facebook users.
 *
 * @param {Array.<module:api/facebook~FacebookUser>} facebookUsers The
 *     Facebook users to send the message to.
 * @param {string} text The message text.
 * @param {Attachment} attachment A resource to attach to the message.
 * @return {module:api/models~Promise} A promise.
 */
FacebookSession.prototype.message = function (facebookUsers, text, attachment) {
  var promise = new models.Promise(this);

  var ids = facebookUsers.map(function (user) {
    return user.id;
  });
  _sendMessage(ids, text, attachment.uri.toSpotifyURL(), function () {
    promise.setDone();
  }, function (error) {
    promise.setFail(error);
  });

  return promise;
};

/**
 * A Facebook user.
 *
 * Don't use this constructor directly. Instead, use fromId.
 *
 * @class
 * @extends {module:api/models~Loadable}
 * @classdesc A container for Facebook user data.
 * @since 1.18.0
 *
 * @property {string} id The Facebook user id.
 * @property {module:api/models~User} user The Spotify user that is connected
 *     to this Facebook account.
 * @property {string} image An URL to the Facebook user's profile image.
 * @property {string} name The display name of the Facebook user.
 *
 * @param {string} id The Facebook user id.
 */
function FacebookUser(id) {
  models.Loadable.call(this);

  this.resolve('id', id);
}
SP.inherit(FacebookUser, models.Loadable);

models.Loadable.define(FacebookUser, ['id']);
models.Loadable.define(FacebookUser, ['user', 'image', 'name'], '_requestMetadata');

/**
 * Sends a metadata request to the backend.
 *
 * @param {number} propsMask A bitmask of properties that were needed.
 *
 * @private
 */
FacebookUser.prototype._requestMetadata = function (propsMask) {
  var self = this;
  var load = function load(data) {
    self.resolveMany(propsMask, data);
  };
  var fail = function fail(error) {
    self.resolveFail(propsMask, error);
  };

  _getUserData(this.id, load, fail);
};

/**
 * Creates a User instance from the URI returned by the bridge.
 *
 * @param {string} value A Spotify user URI.
 *
 * @private
 */
FacebookUser.prototype._make_user = function (value) {
  return value ? models.User.fromURI(value) : null;
};

/**
 * Create a FacebookUser instance from a Facebook user id.
 *
 * @function
 *
 * @param {string} id A Facebook user id.
 * @return {module:api/facebook~FacebookUser} A FacebookUser instance.
 */
FacebookUser.fromId = models.Cache.lookup;
FacebookUser._cache = new models.Cache(FacebookUser);

/**
 * The Facebook session of the current user.
 *
 * @type {module:api/facebook~FacebookSession}
 */
exports.session = new FacebookSession();

exports.FacebookSession = FacebookSession;
exports.FacebookUser = FacebookUser;

},{"./hermes":41,"./models":43}],41:[function(require,module,exports){
'use strict';

var models = require('./models');

/**
 * Functionality for performing Hermes requests.
 *
 * @exports api/hermes
 * @since 1.0.0
 *
 * @private
 *
 * @example
 * require(['./hermes'], function(hermes) {
 *   // Load a .proto file.
 *   var schema = hermes.Schema.fromURL('proto/suggestion.proto');
 *
 *   // Create a Hermes request object (this will not send the request).
 *   var request = hermes.Hermes.get(
 *       'hm://socialgraph/suggestions/people/',
 *       [schema.type('UserSuggestionReply')],
 *       [schema.type('SuggestionRequest')]);
 *
 *   // Send the request with a parameter (maps to SuggestionRequest in .proto
 *   // file).
 *   request.send({reasons: ['FACEBOOK']}).done(function(frames) {
 *     console.log('You should follow these Facebook friends of yours:');
 *     // Output results (data maps to UserSuggestionReply in .proto file).
 *     frames[0].suggestions.forEach(function(suggestion) {
 *       console.log(suggestion.username);
 *     });
 *   });
 * });
 */

var Loadable = models.Loadable;
var Promise = models.Promise;

/**
 * A map of ReadyState values (same as the WebSocket API).
 * @enum {number}
 *
 * @private
 */
var ReadyState = {
  CONNECTING: 0,
  OPEN: 1,
  CLOSING: 2,
  CLOSED: 3
};

/**
 * Helper function to be used in map() to convert a schema type into a schema
 * type string that can be passed over the bridge. Broken out into a separate
 * function so that we can avoid creating anonymous functions each time when
 * sending a request.
 *
 * @private
 */
function _type(type) {
  return type.schema.id + '#' + type.name;
}

/**
 * @class
 * @classdesc Hermes needs description.
 * @since 1.0.0
 *
 * @private
 */
function Hermes() {}

/**
 * Constructs a Hermes GET request with a given URI and description of the
 * result and argument types. The types come from a Schema that was created
 * earlier.
 *
 * @since 1.0.0
 *
 * @param {string} uri The Hermes hm:// URI for the GET request.
 * @param {Array} resultTypes An array of types for the result of the Hermes
 *     request. Can be empty if you do not care about the result.
 * @param {Array} argumentTypes An array of types for each of the arguments
 *     of the request.
 * @param {number} timeout The timeout of the request, in milliseconds.
 * @return {module:api/hermes~Request} A Hermes request.
 *
 * @see module:api/hermes~Schema#fromURL
 * @see module:api/hermes~Schema#type
 */
Hermes.get = function (uri, resultTypes, argumentTypes, timeout) {
  return new Request('GET', uri, resultTypes, argumentTypes, timeout);
};

/**
 * Constructs a Hermes request with a given method, URI and description of
 * the result and argument types. The types come from a Schema that was
 * created earlier.
 *
 * @param {string} method Hermes-method to use; GET, PUT, PATCH etc.
 * @param {string} uri The Hermes hm:// URI for the request.
 * @param {Array} resultTypes An array of types for the result of the Hermes
 *     request. Can be empty if you do not care about the result.
 * @param {Array} argumentTypes An array of types for each of the arguments
 *     of the request.
 * @param {number} timeout The timeout of the request, in milliseconds.
 * @return {module:api/hermes~Request} A Hermes request.
 *
 * @since 1.7.3
 *
 * @see Schema#fromURL
 * @see Schema#type
 */
Hermes.request = function (method, uri, resultTypes, argumentTypes, timeout) {
  return new Request(method, uri, resultTypes, argumentTypes, timeout);
};

/**
 * Subscribes to a PubSub topic. Returns a promise which will be resolved
 * once the subscription has been created. The promise resolves to a
 * Subscription object which will trigger "message" events.
 *
 * @param {string} uri The Hermes hm:// URI for the PubSub topic.
 * @param {Array} resultTypes An array of types for the messages that come in
 *     through the subscription.
 * @param {Array} argumentTypes An array of types for each of the arguments
 *     of the request.
 * @return {module:api/models~Promise} A promise for the request. When the
 *     promise has been fulfilled, the subscription is running. The object of
 *     the promise will be a Subscription which will have "message" events
 *     triggered on it.
 *
 * @example
 * hermes.Hermes.subscribe('hm://collection/collection', [schema.type('CollectionItems')], [], [])
 *     .done(function(sub) {
 *       console.log('Subscribed.');
 *       sub.addEventListener('message', function(event) {
 *         console.log('Message:', event.frames[0]);
 *       });
 *     })
 *     .fail(function(_, error) {
 *       console.error('Subscribe failed!', error);
 *     });
 */
Hermes.subscribe = function (uri, resultTypes, argumentTypes, args) {
  var promise = new models.Promise();
  var done = function done(data) {
    promise.setDone(new Subscription(data.subscription_id));
  };
  var fail = function fail(_, error) {
    promise.setFail(error);
  };

  var rload = Promise.join(resultTypes.map(function (type) {
    return type.schema.load('id');
  }));
  var aload = Promise.join(argumentTypes.map(function (type) {
    return type.schema.load('id');
  }));
  Promise.join(rload, aload).done(function () {
    var rtypes = resultTypes.map(_type);
    var atypes = argumentTypes.map(_type);
    SP.request('hermes_subscribe', [uri, rtypes, atypes, args], null, done, fail);
  }).fail(fail);

  return promise;
};

/**
 * @class
 * @extends {module:api/models~Loadable}
 * @classdesc A Hermes request that can be sent multiple times with different
 *     arguments. To create a new request, use of the methods of the Hermes
 *     helper class.
 * @since 1.0.0
 *
 * @see module:api/hermes~Hermes#get
 *
 * @private
 */
function Request(method, uri, resultTypes, argumentTypes, timeout) {
  Loadable.call(this);

  this.resolve('uri', uri);
  this.resolve('method', method);
  this.resolve('timeout', timeout || 0);
  this._rtypes = resultTypes;
  this._atypes = argumentTypes;

  // Start loading the schemas of the result and argument types. This might be
  // a combination of different schemas, or it might be the same one for all
  // types. Everything is joined together into a single promise.
  var rload = Promise.join(this._rtypes.map(function (type) {
    return type.schema.load('id');
  }));
  var aload = Promise.join(this._atypes.map(function (type) {
    return type.schema.load('id');
  }));
  this._load = Promise.join(rload, aload);
}
SP.inherit(Request, Loadable);

Loadable.define(Request, ['uri', 'method', 'timeout']);

/**
 * Sends the Hermes request with a unique set of arguments. The number of
 * arguments should match the number of argument types used when creating the
 * request.
 *
 * @since 1.0.0
 *
 * @param {...*} var_args Any number of arguments.
 * @return {module:api/models~Promise} A promise for the request. When the
 *     promise has been fulfilled, the request has completed. The object of
 *     the promise is an array containing all of the replies. Even if there
 *     is only one reply, it will be contained in an array of one element.
 */
Request.prototype.send = function (var_args) {
  var promise = new Promise();
  var request = this;
  var reqArg = [].slice.call(arguments);
  this._load.done(function () {
    var done = function done(data) {
      promise.setDone(data.result);
    };
    var rtypes = request._rtypes.map(_type);
    var atypes = request._atypes.map(_type);
    var requestArgs = [request.uri, request.method, rtypes, atypes, reqArg, request.timeout];
    SP.request('hermes_send_request', requestArgs, promise, done, promise.setFail);
  }).fail(function (o, error) {
    promise.setFail(error);
  });
  return promise;
};

/**
 * To create an instance of this class, use the fromURL method.
 *
 * @class
 * @extends {module:api/models~Loadable}
 * @classdesc A Hermes schema contains a collection of messages and
 *     enumerations. Messages that are contained within the same schema can
 *     refer each other, but not to messages in other schemas.
 * @since 1.0.0
 *
 * @see module:api/hermes~Schema#fromURL
 *
 * @private
 */
function Schema(urls) {
  Loadable.call(this);
  this._urls = urls;
}
SP.inherit(Schema, Loadable);

Loadable.define(Schema, ['id'], '_register');

/**
 * Call this method to load a new schema from a collection of .proto files.
 * The .proto files must be contained within the application's bundle.
 *
 * @param {Array.<string>|string} urls An array of URL strings. Each URL must
 *     point to an existing and valid .proto file. The parameter can also be
 *     a single URL string.
 * @return {module:api/hermes~Schema} A schema for the specified .proto file.
 *
 * @since 1.0.0
 */
Schema.fromURL = function (urls) {
  if (typeof urls === 'string') urls = [urls];
  return new this(urls);
};

/**
 * TODO: Documentation needed.
 *
 * @param {string} name Name.
 *
 * @return {{schema: module:api/hermes~Schema, name: string}}
 *     TODO: Documentation needed.
 */
Schema.prototype.type = function (name) {
  return { schema: this, name: name };
};

/**
 * TODO: Documentation needed.
 *
 * @param {number} propsMask Property mask.
 *
 * @private
 */
Schema.prototype._register = function (propsMask) {
  var load = function load(data) {
    this.resolveMany(propsMask, data);
  };
  var fail = function fail(oops) {
    this.resolveFail(propsMask, oops);
  };
  SP.request('hermes_register_schema', this._urls, this, load, fail);
};

/**
 * @class
 * @extends {module:api/models~BridgeLoadable}
 * @classdesc A running subscription of PubSub messages. To get messages, you
 *     need to listen for the "message" event.
 *
 * @private
 */
function Subscription(id) {
  models.BridgeLoadable.call(this);

  this.readyState = ReadyState.OPEN;
  this._id = id;
}
SP.inherit(Subscription, models.BridgeLoadable);

/**
 * @private
 */
Subscription.prototype._observed = function () {
  if (this.readyState != ReadyState.OPEN) return;

  this.bridgeListen('hermes_event_wait', [this._id]);

  // Listen to close events from the bridge.
  this.addEventListener('close', function onClose() {
    this.removeEventListener('close', onClose);

    // Stop expecting events from the bridge.
    this.bridgeUnlisten();
    this.readyState = ReadyState.CLOSED;
  });
};

/**
 * Stops subscribing to the PubSub topic.
 */
Subscription.prototype.close = function () {
  if (this.readyState != ReadyState.OPEN) return;
  this.readyState = ReadyState.CLOSING;

  SP.request('hermes_unsubscribe', [this._id]);
};

exports.Hermes = Hermes;
exports.ReadyState = ReadyState;
exports.Schema = Schema;
exports.Subscription = Subscription;

},{"./models":43}],42:[function(require,module,exports){
'use strict';

var hermes = require('./hermes');
var models = require('./models');

/**
 * Functions for sending messages and listing received messages.
 *
 * @exports api/messaging
 * @since 1.3.0
 * @ignore
 *
 * @example
 * require(['./messaging', './models'], function(messaging, models) {
 *   var recipient = models.User.fromUsername('andreas.blixt');
 *   var attachment = models.Track.fromURI('spotify:track:0FutrWIUM5Mg3434asiwkp');
 *   messaging.send(recipient, 'Hello! :)', attachment);
 * });
 */

var _schema = hermes.Schema.fromURL('proto/messaging.proto');

/**
 * @typedef {module:api/models~Album|module:api/models~Artist|module:api/models~Playlist|module:api/models~Track}
 */
var Attachment;

/**
 * The status of a conversation.
 *
 * @enum {string}
 */
var State = {
  UNREAD: 'unread',
  SEEN: 'seen',
  REPLIED: 'replied'
};

/**
 * The base URI for messages.
 * @const
 * @private
 */
var BASE_URI = 'spotify:app:messages';

/**
 * The base URL for message requests.
 * @const
 * @private
 */
var SERVICE = 'hm://messaging';

/**
 * Hooks up a Hermes request promise to call the specified callbacks. As a
 * convenience, the first frame of the Hermes response is parsed using the
 * specified parser function, and then passed along to the callback.
 *
 * @param {module:api/models~Promise} promise The promise to hook up.
 * @param {Function} parser A parser function which will transform a Hermes
 *     frame to a JavaScript object.
 * @param {Function} callback A callback to be called once the request has
 *     succeeded. A parsed object will be passed in as an argument.
 * @param {Function=} opt_errback A callback to call if the request fails.
 */
function _addCallbacks(promise, parser, callback, opt_errback) {
  promise.done(function (frames) {
    if (callback) {
      var data = frames && frames[0] ? frames[0] : null;
      callback(parser(data));
    }
  }).fail(function (_, error) {
    if (opt_errback) {
      opt_errback(error);
    }
  });
}

/**
 * Creates a URI for a conversation/message given the ids.
 *
 * @param {string} conversationId The id of the conversation.
 * @param {string=} opt_messageId The id of the message.
 * @return {string} The generated URI.
 *
 * @private
 */
function _createURI(threadId, opt_messageId) {
  var pieces = [BASE_URI, 'thread', encodeURIComponent(threadId)];
  if (opt_messageId) {
    pieces.push('message', encodeURIComponent(opt_messageId));
  }
  return pieces.join(':');
}

/**
 * Gets messages in a thread.
 *
 * @param {string} threadId The id of the thread to get the messages for.
 * @param {number} count The number of messages to get.
 * @param {?string} afterId Only load messages that were sent before this
 *     message id. Use this for pagination, or pass in null for the first
 *     "page".
 *
 * @private
 */
function _getMessages(threadId, count, afterId, callback, errback) {
  var request = _hermes('GET', '/threads/' + threadId + '/messages', 'DirectMessageList', 'ListRequest');
  _addCallbacks(request.send(_makeListRequest(count, afterId)), _parseMessageList.bind(null, threadId), callback, errback);
}

var _threadIdRegex = new RegExp('^' + BASE_URI + ':thread:([^:]+)');

function _getThreadId(threadURI) {
  return decodeURIComponent(threadURI.replace(_threadIdRegex, '$1'));
}

/**
 * Creates a Hermes request.
 *
 * @return {module:api/hermes~Request} A Hermes request object.
 *
 * @private
 */
function _hermes(method, path, opt_replyType, opt_argumentType) {
  return hermes.Hermes.request(method, SERVICE + path, opt_replyType ? [_schema.type(opt_replyType)] : [], opt_argumentType ? [_schema.type(opt_argumentType)] : []);
}

/**
 * Creates an object for making a list request.
 *
 * @param {number} limit The maximum number of items to get.
 * @param {string=} opt_afterId Only load items that were sent before this
 *     id. Use this for pagination, or pass in null for the first "page".
 * @param {Date=} opt_lastTimestamp The timestamp of the item referenced
 *     above. This is used to resolve ambiguous cases.
 * @return {Object} An object for making a list request.
 *
 * @private
 */
function _makeListRequest(limit, opt_afterId, opt_lastTimestamp) {
  var data = { limit: limit };
  if (opt_afterId) data.lastId = opt_afterId;
  if (opt_lastTimestamp) data.lastTimestamp = opt_lastTimestamp.getTime();
  return data;
}

// Creates a data structure to send to the backend when sending a message.
function _makeNewMessage(recipients, text, opt_attachment) {
  var data = {
    recipients: recipients,
    text: text
  };

  if (opt_attachment) {
    data.attachment = opt_attachment.uri;
  }

  return data;
}

// Functions for parsing data from the backend.
function _parseMessage(threadId, data) {
  return {
    id: data.id,
    uri: _createURI(threadId, data.id),
    user: data.sender,
    timestamp: data.timestamp,
    attachment: data.attachment,
    text: data.text
  };
}

function _parseMessageList(threadId, data) {
  return data.messages ? data.messages.map(_parseMessage.bind(null, threadId)) : [];
}

function _parseThread(data) {
  var preview = _parseMessage(data.id, data.preview);

  return {
    uri: _createURI(data.id),
    state: data.readUntil == preview.id ? 'seen' : 'unread',
    timestamp: preview.timestamp
  };
}

// Creates a single thread in the messaging backend.
function _sendSingle(recipients, text, attachment) {
  var request = _hermes('PUT', '/threads', 'Conversation', 'NewMessage');

  var promise = new models.Promise();

  _addCallbacks(request.send(_makeNewMessage(recipients, text, attachment)), _parseThread, function (convo) {
    promise.setDone(Conversation.fromURI(convo.uri, convo));
  }, function (error) {
    promise.setFail(error);
  });

  return promise;
}

function _snapshotMessages(descriptor, offset, length, raw) {
  var threadId = _getThreadId(descriptor.uri);

  var promise = new models.Promise();

  _getMessages(threadId, length, offset || null, function (messages) {
    promise.setDone({
      length: messages.length,
      array: messages.map(function (message) {
        return message.uri;
      }),
      metadata: messages
    });
  }, function (error) {
    promise.setFail(error);
  });

  return promise;
}

/**
 * Creates an object that represents a single conversation.
 *
 * @class
 * @extends {module:api/models~Loadable}
 * @classdesc A single conversation with one or more users.
 * @since 1.3.0
 * @ignore
 *
 * @property {module:api/models~Collection} messages A collection of messages
 *     in this conversation.
 * @property {module:api/messaging~State} state The state of this
 *     conversation.
 * @property {Date} timestamp The timestamp of the most recent message in
 *     this conversation.
 * @property {string} uri The URI of this conversation.
 * @property {Array.<module:api/models~User>} users A list of users that this
 *     conversation is with.
 *
 * @param {string} uri The URI of the conversation.
 */
function Conversation(uri) {
  models.Loadable.call(this);

  this.resolve('uri', uri);
  this.resolve('messages', new models.Collection(Message, uri, _snapshotMessages, uri));
}
SP.inherit(Conversation, models.Loadable);

models.Loadable.define(Conversation, ['messages', 'state', 'timestamp', 'uri', 'users']);

/**
 * Creates a date value out of a UNIX timestamp.
 *
 * @param {number} value A UNIX timestamp, in milliseconds.
 * @return {Date} A date object.
 *
 * @private
 */
Conversation.prototype._make_timestamp = function (value) {
  return new Date(value);
};

/**
 * Creates a list of users out of a list of user URIs.
 *
 * @param {Array.<string>} value A list of user URIs.
 * @return {Array.<module:api/models~User>} A list of user objects.
 *
 * @private
 */
Conversation.prototype._make_users = function (value) {
  return models.User.fromURIs(value);
};

/**
 * Returns a conversation object from a URI.
 *
 * @function
 *
 * @param {string} uri The URI of the conversation.
 * @return {module:api/messaging~Conversation} A conversation object.
 *
 * @private
 */
Conversation.fromURI = models.Cache.lookup;
Conversation._cache = new models.Cache(Conversation);

/**
 * Adds a message to a conversation.
 *
 * @since 1.3.0
 *
 * @param {string} text The message text.
 * @param {Attachment=} opt_attachment An optional attachment (such as a
 *     track).
 * @return {module:api/models~Promise} A promise.
 */
Conversation.prototype.send = function (text, opt_attachment) {
  var threadId = _getThreadId(this.uri);
  var request = _hermes('PUT', '/threads/' + threadId + '/messages', 'DirectMessage', 'NewMessage');

  var data = _makeNewMessage(null, text, opt_attachment);

  var promise = new models.Promise();
  _addCallbacks(request.send(data), _parseMessage.bind(null, threadId), function (message) {
    promise.setDone(message);
  }, function (error) {
    promise.setFail(error);
  });
  return promise;
};

/**
 * Creates an object that represents a single message.
 *
 * @class
 * @extends {module:api/models~Loadable}
 * @classdesc A single message from a user. May have an attachment (such as a
 *     track).
 * @since 1.3.0
 * @ignore
 *
 * @property {module:api/messaging~Attachment} attachment An attachment (such
 *     as a track).
 * @property {module:api/messaging~State} state The state of this message.
 * @property {string} text The message text.
 * @property {Date} timestamp The timestamp of this message.
 * @property {string} uri The URI of this message.
 * @property {module:api/models~User} user The user who sent this message.
 *
 * @param {string} uri The URI of this message.
 */
function Message(uri) {
  models.BridgeLoadable.call(this);

  this.resolve('uri', uri);
}
SP.inherit(Message, models.Loadable);

models.Loadable.define(Message, ['attachment', 'state', 'text', 'timestamp', 'uri', 'user']);

/**
 * Creates an object out of an attachment URI.
 *
 * @param {string} value URI of the attachment.
 * @return {module:api/models~Loadable} An attachment object, such as a
 *     track, or null if there is no attachment.
 *
 * @private
 */
Message.prototype._make_attachment = function (value) {
  return models.fromURI(value);
};

/**
 * Creates a date value out of a UNIX timestamp.
 *
 * @param {number} value A UNIX timestamp, in milliseconds.
 * @return {Date} A date object.
 *
 * @private
 */
Message.prototype._make_timestamp = function (value) {
  return new Date(value);
};

/**
 * Creates a user object out of a URI.
 *
 * @param {string} value A user URI.
 * @return {module:api/models~User} A user object.
 *
 * @private
 */
Message.prototype._make_user = function (value) {
  return models.User.fromURI(value);
};

/**
 * Gets a message instance from a URI.
 *
 * @function
 *
 * @param {string} uri The URI of the message.
 * @return {module:api/messaging~Message} The message object.
 *
 * @private
 */
Message.fromURI = models.Cache.lookup;
Message._cache = new models.Cache(Message);

/**
 * Sends a message to one or more users.
 *
 * @since 1.3.0
 *
 * @param {Array.<module:api/models~User>} to One or more users to send the
 *     message to.
 * @param {string} text The message text.
 * @param {module:api/messaging~Attachment=} opt_attachment An optional
 *     attachment (such as a track).
 * @return {module:api/models~Promise} A promise that resolves when message
 *     is sent.
 */
function send(recipients, text, opt_attachment) {
  recipients = SP.uris(recipients);

  var sendPromises = [];
  for (var i = 0; i < recipients.length; i++) {
    sendPromises.push(_sendSingle([recipients[i]], text, opt_attachment));
  }

  var promise = new models.Promise();

  models.Promise.join(sendPromises).done(function (convos) {
    promise.setDone(convos[0]);
  }).fail(function (_, error) {
    promise.setFail(error);
  });

  return promise;
}

exports.Conversation = Conversation;
exports.Message = Message;
exports.State = State;
exports.send = send;

},{"./hermes":41,"./models":43}],43:[function(require,module,exports){
'use strict'; /**
 * Functionality for working with objects in the Spotify universe.
 *
 * @module api/models
 */ /**
 * Request callback that resolves the object of the promise with the request
 * result.
 *
 * @this {module:api/models~Promise}
 *
 * @private
 */var _resolveResult=function _resolveResult(result){this.object.resolveMany(0,result);this.setDone();}; /**
 * Set a promise to done.
 *
 * @this {module:api/models~Promise}
 *
 * @private
 */var _setDone=function _setDone(){this.setDone();}; /**
 * Performs a bridge request and returns a promise for that request.
 *
 * @param {Object} object The object to return in the promise callbacks.
 * @param {string} request The request to make.
 * @param {Array} args Arguments to send with the request.
 * @param {boolean=} opt_resolveResult Whether to also resolve the result on
 *     the object. Useful when the request returns updated data.
 * @return {module:api/models~Promise} A promise that will resolve when the
 *     request is complete.
 */var promisedRequest=function promisedRequest(object,request,args,opt_resolveResult){var promise=new Promise(object);SP.request(request,args,promise,opt_resolveResult?_resolveResult:_setDone,promise.setFail);return promise;}; /**
 * Helper function to create an Artist object from an object containing both the
 * URI and the metadata of the artist. Used to create the "artists" property of
 * both Album and Track.
 *
 * @private
 */var _artists=function _artists(metadataWithUri){return Artist.fromURI(metadataWithUri.uri,metadataWithUri);}; /**
 * Helper function to create an Album object from an object containing both the
 * URI and the metadata of the album. Used to create the "albums" property of
 * AlbumGroups.
 *
 * @private
 */var _albums=function _albums(metadataWithUri){return Album.fromURI(metadataWithUri.uri,metadataWithUri);}; /**
 * Helper function to create a Disc object from an object containing both the
 * URI and the metadata of the disc. Used to create the "discs" property of
 * Albums.
 *
 * @private
 */var _discs=function _discs(metadataWithUri){return Disc.fromURI(metadataWithUri.uri,metadataWithUri);}; /**
 * All "metadata items" (Album, Artist, Playlist, Track and User) are cached on
 * JavaScript side, because it is quite expensive to cross the bridge each time
 * one is needed. The cached items may not contain no metadata, some metadata
 * or all metadata. The items are never evicted from the cache, but a longer
 * term plan is to implement that though, so the user of the API cannot depend
 * on the fact that Item.fromURI always returns the same item for a given URI.
 *
 * @class
 * @since 1.0.0
 * @ignore
 *
 * @param {Function} itemClass The type of the items that the cache is for.
 */function Cache(itemClass){ /**
   * A map of URIs to object instances.
   * @type {Object.<string, Object>}
   * @private
   */this._items={}; /**
   * The type of the items that the cache is for.
   * @type {Function}
   * @private
   */this._class=itemClass;} /**
 * Looks up an item in the cache for this class.
 *
 * @since 1.0.0
 *
 * @param {string} uri The URI of the item to look up.
 * @param {Object=} opt_metadata Metadata to fill the object with if it isn't
 *     in the cache.
 * @return {module:api/models~Loadable} An item from the cache (or a newly
 *     created instance now in the cache).
 */Cache.lookup=function(uri,opt_metadata){return this._cache.lookup(uri,opt_metadata);}; /**
 * Looks up a list of items in the cache for this class.
 *
 * @since 1.3.0
 *
 * @param {Array.<string>} uris The URIs of the items to look up.
 * @return {Array.<module:api/models~Loadable>} A list of items from the cache
 *     (or newly created instances, now also stored in the cache).
 */Cache.lookupMany=function(uris){var result=[];for(var i=0,len=uris.length;i<len;i++){result.push(this._cache.lookup(uris[i]));}return result;}; /**
 * Put an item in the cache.
 *
 * @since 1.0.0
 *
 * @param {string} uri The URI of the item to cache.
 * @param {module:api/models~Loadable} item The item to cache.
 */Cache.prototype.cache=function(uri,item){this._items[uri]=item;}; /**
 * Looks up an item in the cache, creating it and filling it with the provided
 * metadata if it doesn't exist in the cache.
 *
 * @since 1.0.0
 *
 * @param {string} uri The URI of the item to look up.
 * @param {Object=} opt_metadata Metadata to fill the object with if it isn't
 *     in the cache.
 * @return {module:api/models~Loadable} An item from the cache (or a newly
 *     created instance now in the cache).
 */Cache.prototype.lookup=function(uri,opt_metadata){if(!uri)return null;var item=this._items[uri];if(!(item instanceof this._class)){item=new this._class(uri);item.resolveMany(0,opt_metadata);this._items[uri]=item;}return item;}; /**
 * Removes an item from the cache.
 *
 * @since 1.0.0
 *
 * @param {string} uri The URI of the item to remove.
 */Cache.prototype.remove=function(uri){delete this._items[uri];}; /**
 * Updates a property on one or more items in the cache.
 *
 * @since 1.0.0
 *
 * @param {Array.<string>} uris The URIs of one or more items to update.
 * @param {Object} data An object with properties and values to update the
 *     items with.
 */Cache.prototype.update=function(uris,data){for(var i=0,len=uris.length;i<len;i++){var item=this._items[uris[i]];if(item)item.resolveMany(0,data);}}; /**
 * @class
 * @classdesc The base class for all objects that can be observed with
 *     addEventListener.
 * @since 1.0.0
 *
 * @example
 * function MyClass() {
 *   Observable.call(this);
 *
 *   this.something = 127;
 * }
 * SP.inherit(MyClass, Observable);
 */function Observable(){} /**
 * This method is called when the first event listener is added to this
 * Observable. Subclasses may override this method in order to lazily initialize
 * resources related to event listening.
 *
 * @since 1.0.0
 * @ignore
 *
 * @protected
 */Observable.prototype._observed=function(){}; /**
 * Same as the addEventListener in standard JavaScript. Call this method to add
 * an observer to the receiver object, for a given named event.
 *
 * @since 1.0.0
 *
 * @param {string} eventType The name of the event to get notifications for.
 * @param {Function} observer The callback function. To unregister the
 *     callback, the exact same function must be passed to the
 *     removeEventListener method.
 *
 * @see module:api/models~Observable#removeEventListener
 *
 * @example
 * models.player.addEventListener('change', updateNowPlayingWidget);
 */Observable.prototype.addEventListener=function(eventType,observer){if(!observer)return;if(!this._ob){this._ob={};this._obcount=0;}var callbacks=this._ob[eventType];if(callbacks)callbacks.push(observer);else this._ob[eventType]=[observer];this._obcount++;if(this._obcount==1)this._observed();}; /**
 * Same as the removeEventListener in standard JavaScript. Call this method to
 * remove an observer that was previously added.
 *
 * @since 1.0.0
 *
 * @param {string} eventType The name of the event you're getting notifications
 *     for.
 * @param {Function} observer The callback must be the exact same function
 *     instance as was used in the registration, and not just an identical
 *     anonymous function.
 *
 * @see module:api/models~Observable#addEventListener
 *
 * @example
 * models.player.removeEventListener('change', updateNowPlayingWidget);
 */Observable.prototype.removeEventListener=function(eventType,observer){var observers=this._ob||{};var callbacks=observers[eventType]||[];var index=callbacks.indexOf(observer);if(index!=-1){this._obcount--;callbacks.splice(index,1);if(!callbacks.length)delete observers[eventType];if(!this._obcount)delete this._ob;}}; /**
 * Triggers an event for all observer callbacks. Any callback that explicitly
 * returns false or calls preventDefault() will cause the return value of this
 * function to be false.
 *
 * @since 1.0.0
 *
 * @param {{type: string}|string} evt The event object to dispatch (must have a
 *     type property), or simply the event type as a string.
 * @return {boolean} False if the event was prevented; otherwise, true.
 */Observable.prototype.dispatchEvent=function(evt){if(typeof evt=='string'){evt={type:evt};}if(!evt||!evt.type){throw new Error('Dispatched event must have a type.');}if(!evt.target){evt.target=this;}var observers=this._ob||{};var callbacks=(observers[evt.type]||[]).slice(0);if(!callbacks.length)return true;var ret=true;evt.preventDefault=function(){ret=false;};for(var i=0;i<callbacks.length;i++){try{if(callbacks[i].call(this,evt)===false)ret=false;}catch(error){console.error(error);if(SP._throwError)throw error;}}return ret;}; /**
 * @class
 * @classdesc A promise is an object that represents a pending query that will
 *     be resolved at some point in the future. A query may either be done or
 *     it may fail. Depending on the outcome, the appropriate callbacks will be
 *     called. A number of promises may be joined using {@link Promise#join} to
 *     make it easy to run a function once several independent queries have all
 *     been resolved.
 * @since 1.0.0
 *
 * @property {*} object An object that will be passed to the callbacks when the
 *     promise resolves.
 *
 * @param {Object=} opt_object An object that will be passed to the always/
 *     done/fail/each callbacks.
 */function Promise(opt_object){this.object=opt_object;this._done=[];this._fail=[];} /**
 * When the promise is resolved (success or failure doesn't matter), callbacks
 * registered by this method will be invoked. If the promise has already
 * resolved, the callback function will be called immediately, without waiting
 * for the next runloop iteration. The argument to the callback function is the
 * object used to resolve the promise.
 *
 * @since 1.0.0
 *
 * @param {Object|function(Object)} callbackOrThis If this argument is an
 *     object, it will be used as the "this" context object when calling the
 *     callback. If this argument is the callback function instead, the "this"
 *     context object will be the promise when the callback is called.
 * @param {function(Object)=} opt_callback The callback function to invoke,
 *     unless specified as the first argument.
 * @return {module:api/models~Promise} Returns the same instance, so that the
 *     callback method calls can be easily called in sequence.
 *
 * @example
 * models.Artist.fromURI('spotify:artist:74terC9ol9zMo8rfzhSOiG').load('name')
 *     .done(function(artist) { console.log(artist.name); })
 *     .fail(function(artist, error) { console.log(error.message); })
 *     .always(function(artist, maybeError) { console.log('Done or failed.'); });
 */Promise.prototype.always=function(callbackOrThis,opt_callback){var cbFunc,cbThis;if(opt_callback){cbFunc=opt_callback;cbThis=callbackOrThis;}else {cbFunc=callbackOrThis;cbThis=this;}if(typeof cbFunc!='function')throw new Error('A callback function is required');if(this._done){ // If the _done property exists, this promise has not resolved yet.
this._done.push(SP.callback(SP.bind(cbFunc,cbThis)));this._fail.push(SP.callback(SP.bind(cbFunc,cbThis)));}else {cbFunc.apply(cbThis,this._args);}return this;}; /**
 * When the promise is resolved successfully, callbacks registered by this
 * method will be invoked. If the promise has already resolved, the callback
 * function will be called immediately, without waiting for the next runloop
 * iteration. The argument to the callback function is the object used to
 * resolve the promise.
 *
 * @since 1.0.0
 *
 * @param {Object|function(Object)} callbackOrThis If this argument is an
 *     object, it will be used as the "this" context object when calling the
 *     callback. If this argument is the callback function instead, the "this"
 *     context object will be the promise when the callback is called.
 * @param {function(Object)=} opt_callback The callback function to invoke,
 *     unless specified as the first argument.
 * @return {module:api/models~Promise} Returns the same instance, so that the
 *     callback method calls can be easily called in sequence.
 *
 * @example
 * models.Artist.fromURI('spotify:artist:74terC9ol9zMo8rfzhSOiG').load('name')
 *     .done(function(artist) { console.log(artist.name); })
 *     .fail(function(artist, error) { console.log(error.message); });
 */Promise.prototype.done=function(callbackOrThis,opt_callback){var cbFunc,cbThis;if(opt_callback){cbFunc=opt_callback;cbThis=callbackOrThis;}else {cbFunc=callbackOrThis;cbThis=this;}if(typeof cbFunc!='function')throw new Error('A callback function is required');if(this._isDone)cbFunc.apply(cbThis,this._args);else if(this._done) // If the _done property exists, this promise has not resolved yet.
this._done.push(SP.callback(SP.bind(cbFunc,cbThis)));return this;}; /**
 * When the promise fails, callbacks registered by this method will be invoked.
 * If the promise has already failed, the callback function will be called
 * immediately, without waiting for the next runloop iteration. The argument to
 * the callback function is an error object describing the failure.
 *
 * @since 1.0.0
 *
 * @param {Object|function(Object)} callbackOrThis If this argument is an
 *     object, it will be used as the "this" context object when calling the
 *     callback. If this argument is the callback function instead, the "this"
 *     context object will be the promise when the callback is called.
 * @param {function(Object)=} opt_callback The callback function to invoke,
 *     unless specified as the first argument.
 * @return {module:api/models~Promise} Returns the same instance, so that the
 *     callback method calls can be easily called in sequence.
 *
 * @example
 * models.Track.fromURI('spotify:track:6a41rCqZhb2W6rpMolDR08').load('name')
 *     .done(function(track) { console.log(track.name); })
 *     .fail(function(track, error) { console.log(error.message); });
 */Promise.prototype.fail=function(callbackOrThis,opt_callback){var cbFunc,cbThis;if(opt_callback){cbFunc=opt_callback;cbThis=callbackOrThis;}else {cbFunc=callbackOrThis;cbThis=this;}if(typeof cbFunc!='function')throw new Error('A callback function is required');if(this._isFail)cbFunc.apply(cbThis,this._args);else if(this._fail) // If the _fail property exists, this promise has not resolved yet.
this._fail.push(SP.callback(SP.bind(cbFunc,cbThis)));return this;}; /**
 * For joined promises, the callback given to this method will be called once
 * for each of the promises in the join. Promises that fail will not invoke the
 * callback. When adding this callback to the promise, all joined promises that
 * already have completed will invoke the callback, in the order they resolved.
 * The argument to the callback is the same argument as given to the individual
 * promises.
 *
 * @since 1.0.0
 *
 * @param {Object|function(Object)} callbackOrThis If this argument is an
 *     object, it will be used as the "this" context object when calling the
 *     callback. If this argument is the callback function instead, the "this"
 *     context object will be the promise when the callback is called.
 * @param {function(Object)=} opt_callback The callback function to invoke,
 *     unless specified as the first argument.
 * @return {module:api/models~Promise} Returns the same instance, so that the
 *     callback method calls can be easily called in sequence.
 *
 * @example
 * var tracks = getSomeToplist();
 * var promises = [];
 * tracks.forEach(function(track) { promises.push(track.load('name')); });
 * models.Promise.join(promises)
 *     .each(function(track) { console.log('Loaded one track: ' + track.name); })
 *     .done(function(tracks) { console.log('Loaded all tracks.'); })
 *     .fail(function(tracks) { console.log('Failed to load at least one track.'); });
 */Promise.prototype.each=function(callbackOrThis,opt_callback){ // If this is not a joined promise, calling this method will be a no-op.
if(this._objs){var cbFunc,cbThis;if(opt_callback){cbFunc=opt_callback;cbThis=callbackOrThis;}else {cbFunc=callbackOrThis;cbThis=this;}if(typeof cbFunc!='function')throw new Error('A callback function is required');if(this._each){this._each.push(SP.callback(SP.bind(cbFunc,cbThis)));} // Call the newly added each callback for any objects that may already have
// resolved.
for(var i=0,l=this._objs.length;i<l;i++){cbFunc.call(cbThis,this._objs[i]);}}return this;}; /**
 * Resolves the promise, with the object that was specified when creating the
 * instance, set manually afterwards or passed to this method. All callbacks
 * for done will be called in the order they were registered.
 *
 * @since 1.0.0
 *
 * @param {*=} opt_object An optional object that should be passed on to all
 *     done handlers.
 */Promise.prototype.setDone=function(opt_object){if(!this._done)return;var done=this._done;var fail=this._fail;delete this._done;delete this._fail;if(arguments.length==1){this.object=opt_object;}this._isDone=true; // Must be set before invoking the callbacks.
this._args=[this.object];for(var i=0,l=done.length;i<l;i++){done[i].apply(undefined,this._args);} // first arg ignored as target is bound
for(var j=0,k=fail.length;j<k;j++){fail[j].clear();}delete this._each;delete this._join;delete this._numResolved;delete this._oneFailed;}; /**
 * Fails the promise, with the given error reason. All callbacks for fail will
 * be called in the order they were registered.
 *
 * @since 1.0.0
 *
 * @param {Object} error An error object describing what went wrong.
 */Promise.prototype.setFail=function(error){if(!this._done)return;var fail=this._fail;var done=this._done;delete this._done;delete this._fail;this._isFail=true; // Must be set before invoking the callbacks.
this._args=[this.object,error];for(var i=0,l=fail.length;i<l;i++){fail[i].apply(undefined,this._args);} // first arg ignored as target is bound
for(var j=0,k=done.length;j<k;j++){done[j].clear();}delete this._each;delete this._join;delete this._numResolved;delete this._oneFailed;}; /**
 * Joins several promises into a single promise that can be waited on. The done
 * and fail callbacks will be called when all of the promises have resolved or
 * any of the promises has failed respectively. The argument to the callback
 * function is an array with the resolved object of all promises. In addition
 * to these composite callbacks, the returned promise object has a method
 * called each, which can be used to get a callback when each of the promises
 * complete. The each callbacks will never be called again once the promise has
 * resolved or failed.
 *
 * @since 1.0.0
 *
 * @param {Array.<module:api/models~Promise>|...module:api/models~Promise} promises
 *     Either an array of promises to join or the promises as separate
 *     parameters.
 * @return {module:api/models~Promise} A new Promise that will be done/fail
 *     when all of the joined promises are done/failed.
 *
 * @example
 * var p1 = album.load('name');
 * var p2 = track.load('name', 'duration');
 * var wait = models.Promise.join(p1, p2); // or join([p1, p2]);
 * wait.done(albumAndTrackDone).fail(eitherFailed).each(eitherDone);
 */Promise.join=function(promises){var promise=new Promise();promises=SP.varargs(arguments,0,true);promise._join=promises;promise._each=[];promise._objs=[];promise._numResolved=0;if(promises.length===0)promise.setDone([]);for(var i=0,l=promises.length;i<l;i++){promises[i].done(promise,promise._oneDone).fail(promise,promise._oneFail);}return promise;}; /**
 * This method is called whenever a sub-promise resolves. Once all sub-promises
 * have resolved, this promise will also resolve. If one or more of the sub-
 * promises failed, this promise will also fail.
 *
 * @see module:api/models~Promise#join
 *
 * @private
 */Promise.prototype._oneEither=function(object){this._numResolved++;if(this._numResolved<this._join.length)return; // If the function doesn't return above, all promises have resolved. Collect
// all the objects into an array and make that the object of this promise.
this.object=[];for(var i=0,l=this._join.length;i<l;i++){this.object.push(this._join[i].object);} // We no longer need the each callbacks so we need to clean them up.
for(var j=0,k=this._each.length;j<k;j++){this._each[j].clear();} // If one or more of the promises failed, we want this promise to fail too.
if(this._oneFailed)this.setFail();else this.setDone();}; /**
 * Called when one of the joined promises resolves as done. Will go through the
 * list of each callbacks and call them with the same arguments as given to
 * this method. If this method is called after a done or fail callback has been
 * called nothing will happen, because our contract states that we must never
 * call one of the each callbacks after either the done or fail callbacks have
 * been called.
 *
 * @see module:api/models~Promise#join
 *
 * @private
 */Promise.prototype._oneDone=function(object){if(!this._done)return; // Keep track of resolved objects for any each callbacks added after this
// promise has resolved.
this._objs.push(object); // Call the each callbacks.
var nextEach=[];for(var i=0,l=this._each.length;i<l;i++){var cb=this._each[i];nextEach.push(cb.copy());cb.call(undefined,object); // first arg ignored as target is bound
}this._each=nextEach;this._oneEither(object);}; /**
 * Called when one of the joined promises resolves as failed. If this method is
 * called after a done or fail callback has been called nothing will happen,
 * because our contract states that we must never call one of the each
 * callbacks after either the done or fail callbacks have been called.
 *
 * @see module:api/models~Promise#join
 *
 * @private
 */Promise.prototype._oneFail=function(object,error){if(!this._done)return; // Mark the promise as failed. It won't fail straight away though since we
// may have more unresolved promises still in progress. Once all promises
// have resolved, we will resolve this promise as failed.
this._oneFailed=true;this._oneEither(object);}; /**
 * @class
 * @extends {module:api/models~Observable}
 * @classdesc This is the base class for all high level objects that are
 *     exposed in the API. The most important function is the load function,
 *     which must be called by the users of the object to indicate exactly what
 *     properties they are interested in. The caller cannot expect any other
 *     properties to be available on the object, even though some extra
 *     properties might show up there as an optimized fetch operation. The
 *     extra properties can and will change in the future and must not be read.
 * @since 1.0.0
 */function Loadable(){Observable.call(this); // this._done = 0 and this._wait = 0 are implicit since undefined acts the
// same as 0 for bitwise operations. This means that the subclass does not
// need to call this constructor at all.
}SP.inherit(Loadable,Observable); /**
 * Register a group of properties that can all be fetched using the same method
 * call. The method will be invoked once when any of the properties in the
 * group is loaded, and the method must return all of the properties in the
 * group: otherwise they will never be loaded, even if additional load calls
 * are made for those properties. They object will already have recorded that
 * there are no values for those properties.
 *
 * @since 1.0.0
 *
 * @param {Function} clazz The constructor to register properties for.
 * @param {Array.<string>} names The names of the properties.
 * @param {string=} opt_func The name of a function which should be used to
 *     request any of the properties in the group. The function should be on
 *     the prototype of "clazz".
 */Loadable.define=function(clazz,names,opt_func){var proto=clazz.prototype;if(!proto._prop)proto._prop={};if(!proto._next)proto._next=0;var group={mask:0,func:opt_func};for(var i=0,l=names.length;i<l;i++){var mask=1<<proto._next++;group.mask|=mask;proto._prop[names[i]]={mask:mask,group:group};}}; /**
 * Lets the subclasses transform the raw property values into high level objects
 * such as Album or Track. The bridge will in general send URIs for links to
 * other items, which can be passed to Track/Album/etc.fromURI to create the
 * actual objects. The transform method should never start a load of the objects
 * it creates, because that could end up in loading the entire world, and the
 * idea is that it is supposed to be cheap to create objects, and the expensive
 * operations should happen when actually loading the objects.
 *
 * @private
 *
 * @param {string} name Name of the property to make.
 * @param {*} value The value to use for making the property.
 * @return {*} The (possibly transformed) value to assign to the property.
 */Loadable.prototype._make=function(name,value){name='_make_'+name;var func=this[name];return func?func(value):value;}; /**
 * Resolves a single property on an object.
 *
 * @since 1.0.0
 *
 * @param {string} name The name of the property.
 * @param {*} value The new value.
 * @param {boolean=} opt_silent Whether to skip dispatching change events for
 *     any properties that change.
 */Loadable.prototype.resolve=function(name,value,opt_silent){var prop=this._prop[name];if(!prop)return;this._done|=this._prop[name].mask;this._wait&=~this._done;var newValue=this._make(name,value);if(this.hasOwnProperty(name)&&!opt_silent){ // The item already had this value, so if the value changed, dispatch a
// change event for anyone who may have read it and wants to know it
// changed.
var oldValue=this[name];if(oldValue!==newValue){this[name]=newValue;this.dispatchEvent({type:'change:'+name,property:name,oldValue:oldValue});}}else {this[name]=newValue;}if(!this._wait)delete this._wait;}; /**
 * Resolves many properties on an object.
 *
 * @since 1.0.0
 *
 * @param {number} propsMask A bitmask of properties to mark as done and unmark
 *     as waiting.
 * @param {Object} data A map of properties to update and their new values.
 * @param {boolean=} opt_silent Whether to skip dispatching change events for
 *     any properties that change.
 */Loadable.prototype.resolveMany=function(propsMask,data,opt_silent){for(var name in data){this.resolve(name,data[name],opt_silent);}this._done|=propsMask;this._wait&=~propsMask;this.resolveDone();}; /**
 * Signal that all calls to resolve are done, at least for the moment.
 *
 * @since 1.0.0
 *
 * @protected
 */Loadable.prototype.resolveDone=function(){if(!this._reqs)return;var done=[];for(var i=0;i<this._reqs.length;i++){if(!(this._reqs[i]._need&~this._done))done.push(this._reqs.splice(i--,1)[0]);}if(!this._reqs.length)delete this._reqs;if(!this._wait)delete this._wait;for(var j=0,l=done.length;j<l;j++){done[j].setDone();}}; /**
 * Signal that resolving failed.
 *
 * @since 1.0.0
 *
 * @protected
 */Loadable.prototype.resolveFail=function(propsMask,error){this._wait&=~propsMask;if(!this._reqs)return;var fail=[];for(var i=0;i<this._reqs.length;i++){if(this._reqs[i]._need&propsMask)fail.push(this._reqs.splice(i--,1)[0]);}if(!this._reqs.length)delete this._reqs;if(!this._wait)delete this._wait;for(var j=0,l=fail.length;j<l;j++){fail[j].setFail(error);}}; /**
 * Before any properties of an object can be read they must be loaded by calling
 * this function with a list of properties that the caller is interested in. The
 * only way to ensure that any properties are available on an object is to call
 * this method. After specifying what properties to load the caller must wait
 * for the returned promise to resolve before the properties can actually be
 * read from the object. If the promise fails, the properties must not be read.
 * Note that it is possible, and recommended, to call load multiple times with
 * different property lists. The properties should be grouped by how they are
 * used together. By specifiying a minimum set of properties for each call to
 * load, the callback will happen as soon as possible, sometimes without even
 * having to wait for additional metadata to be fetched remotely.
 *
 * @since 1.0.0
 *
 * @param {Array.<string>|...string} properties An array of property names. The
 *     property names that are available for loading can be found in the
 *     documentation for each specific sub-class. Note that instead of passing
 *     in an array, multiple arguments can be passed instead.
 * @return {module:api/models~Promise} A promise to wait for before the
 *     properties can be read.
 *
 * @example
 * models.Track.fromURI('…').load('name', 'duration').done(function(track) {
 *   console.log('The track ' + track.name + ' is ' + track.duration + ' ms long.');
 * });
 */Loadable.prototype.load=function(properties){var args=SP.varargs(arguments);var req=new Promise(this);req._need=this._neededForLoad(args);if(req._need){if(this._reqs)this._reqs.push(req);else this._reqs=[req];this._requestProperties(req._need);}else {req.setDone();}return req;}; /**
 * Checks what properties already exist and returns the intersection of those
 * and the properties to load. The returned value is the bitmask of all
 * properties that are needed, but not yet loaded, including the ones that are
 * waiting to get a reply. If the properties array is empty, a bitmask
 * representing all properties in the object is returned. This can be a very
 * request if properties must be loaded from different sources, so it must only
 * be used when debugging code as a convenience.
 *
 * @since 1.0.0
 *
 * @param {Array} properties An array of properties to get the bitmask for.
 *
 * @private
 */Loadable.prototype._neededForLoad=function(properties){var neededMask=0;for(var i=0,l=properties.length;i<l;i++){var name=properties[i];var prop=this._prop[name];if(!prop)throw new Error(name+' is not a property.');neededMask|=prop.mask;}return neededMask&~this._done;}; /**
 * @private
 */Loadable.prototype._requestProperties=function(propsMask){var groups=[];for(var name in this._prop){var prop=this._prop[name];var mask=prop.group.mask;if(!(mask&propsMask))continue; // skip: no overlap
if(mask&this._wait)continue; // skip: already sent
groups.push(prop.group);this._wait|=mask;propsMask&=~mask;if(!propsMask)break;}for(var i=0,l=groups.length;i<l;i++){var func=this[groups[i].func];if(func)func.call(this,groups[i].mask);}}; /**
 * @class
 * @extends {module:api/models~Loadable}
 * @classdesc Loadable that interacts with the bridge and handles some common
 *     functionality.
 * @since 1.0.0
 * @ignore
 */function BridgeLoadable(){Loadable.call(this);}SP.inherit(BridgeLoadable,Loadable); /**
 * Start listening for bridge events.
 *
 * @ignore
 *
 * @param {string} requestName Request name to make to the bridge.
 * @param {Array} requestArgs Args for the bridge request.
 */BridgeLoadable.prototype.bridgeListen=function(requestName,requestArgs){if(!this._listening){this._requestName=requestName;this._requestArgs=requestArgs;this._listening=true;this._eventWait();}}; /**
 * Stop listening for bridge events.
 *
 * @ignore
 */BridgeLoadable.prototype.bridgeUnlisten=function(){delete this._requestName;delete this._requestArgs; // There's no way to actually cancel the pending request. So we wait for the
// next timeout, and then no further SP.request will be made.
delete this._listening;}; /**
 * Renew the request to wait for a bridge event if we're supposed to be
 * listening.
 *
 * @private
 */BridgeLoadable.prototype._eventWait=function(){if(this._listening)SP.request(this._requestName,this._requestArgs,this,this._eventDone,this._eventFail);}; /**
 * Handler for bridge events, internal implementation.
 *
 * @private
 */BridgeLoadable.prototype._eventDone=function(event){this._eventWait();this.eventDone(event);}; /**
 * Handle an event.
 *
 * Default behavior: resolve the 'data' field from events into property updates
 * on this object. By default, a bridge event is redispatched as a JavaScript
 * event on this, unless a 'receiver' field is specified on the event. If
 * given, the 'receiver' field causes 'this[event.receiver]' to be the event
 * target instead of 'this'.
 *
 * Subclasses should override this method if they need custom functionality to
 * run on every bridge event. This should be a rare case.
 *
 * @param {Object} event Raw event object from the bridge.
 */BridgeLoadable.prototype.eventDone=function(event){if(event.receiver&&this.hasOwnProperty(event.receiver)){ // Event told us to use a member object as the event receiver.
var receiver=this[event.receiver];receiver.resolveMany(0,event.data);receiver.dispatchEvent(event);}else {this.resolveMany(0,event.data);this.dispatchEvent(event);}}; /**
 * Failure handler, internal implementation.
 *
 * @private
 */BridgeLoadable.prototype._eventFail=function(error){if(error.error=='timeout')this._eventWait();this.eventFail(error);}; /**
 * Handle a failure.
 *
 * Subclasses should replace this method if they need custom
 * functionality to run on an error.
 *
 * @param {Object} error Raw error object from the bridge.
 */BridgeLoadable.prototype.eventFail=function(error){}; /**
 * A bridge listener that does not handle events itself, but that can proxy
 * them to another bridge listener.
 *
 * @class
 * @extends {module:api/models~BridgeLoadable}
 * @since 1.2.0
 * @ignore
 */function ProxyListener(){BridgeLoadable.call(this); /**
   * Functions that can modify an event before it is proxied.
   * @type {Array.<Function>}
   * @private
   */this._filters=[]; /**
   * Other BridgeLoadables that will receive the events from this one.
   * @type {Array.<module:api/models~BridgeLoadable>}
   * @private
   */this._receivers=[];}SP.inherit(ProxyListener,BridgeLoadable); /**
 * Adds a filter which will be applied before proxying an event.
 *
 * A filter can prevent an event from being proxied by explicitly returning
 * false. It is also free to modify the event before it is passed on, or
 * otherwise making use of its data.
 *
 * @param {function(Object):boolean} filter A filter to apply to events.
 */ProxyListener.prototype.filter=function(filter){this._filters.push(filter);}; /**
 * Proxies events to the specified bridge listener. More than one receiver is
 * allowed.
 *
 * @param {module:api/models~BridgeLoadable} receiver Bridge listener to
 *     receive events from this one.
 */ProxyListener.prototype.proxyTo=function(receiver){this._receivers.push(receiver);}; /**
 * Applies filters and proxies the event instead of handling it on this
 *     instance.
 *
 * @override
 *
 * @param {Object} evt Raw event object from the bridge.
 */ProxyListener.prototype.eventDone=function(evt){ // Apply all filters before passing the event on to the receivers. However,
// if any of the filter functions return false, the event will not be passed
// on.
var i,len,proxy=true;for(i=0,len=this._filters.length;i<len;i++){if(this._filters[i](evt)===false)proxy=false;}if(!proxy)return;for(i=0,len=this._receivers.length;i<len;i++){this._receivers[i].eventDone(evt);}}; /**
 * @class
 * @extends {module:api/models~BridgeLoadable}
 * @classdesc The base class of all the "metadata objects": Album, Artist,
 *     Playlist, Track and User. It encapsulates all of the metadata request
 *     functionality, which is more or less the same for all types.
 */function MdL(uri){BridgeLoadable.call(this);}SP.inherit(MdL,BridgeLoadable); /**
 * Subclasses must call this method to set up some particulars of that subclass.
 * Failure to load this method will lead to runtime error when loading any
 * properties of the instances.
 */MdL.init=function(clazz,prefix){clazz._type=prefix;}; /**
 * Returns an image URI for a given minimum size in pixels. Note that this
 * method does takes into account the resolution of the device screen, which
 * means that if the application is running on a High-DPI display, such as an
 * iPhone 4 or iPad 3, the number of pixels in the image will be twice as many
 * as the number of requested CSS pixels. An application running on 3G might
 * want to choose to first transfer a half resolution image to get something on
 * the screen quickly and then request the full resolution image only when all
 * low resolution images have been loaded. Note that all of this is taken care
 * of automatically when using the included view classes, so most applications
 * should not need to worry too much about this. Before this method can be
 * called, the image property must have been loaded.
 *
 * @param {number} size The size, in pixels, of the shortest side of the the
 *     image. Note that not all images are square, so the image might be larger
 *     in one direction that the requested size, but it will not be smaller,
 *     unless the size exceeds the maximum image size allowed, which is
 *     platform specific and might change over time. Also note that the image
 *     can be larger than the requested minimum size.
 * @return {string} The URI of the image best suited for the provided size.
 *
 * @since 1.0.0
 *
 * @example
 * album.load('image').done(function() {
 *   div.style.backgroundImage = 'url(' + album.imageForSize(300) + ')';
 * });
 */MdL.prototype.imageForSize=function(size){var images=this.images;size*=window.devicePixelRatio||1;for(var i=0,l=images?images.length:0;i<l;i++){if(images[i][0]>=size||i==l-1)return images[i][1].replace('{size}',size);}return this.image;}; /**
 * Called by load to fetch the metadata of the item.
 *
 * @see MdL#_profile
 *
 * @private
 */MdL.prototype._metadata=function(propsMask){var load=function load(data){this.resolveMany(propsMask,data);};var fail=function fail(oops){this.resolveFail(propsMask,oops);};SP.request(this.constructor._type+'_metadata',[this.uri],this,load,fail);}; /**
 * Called by load to fetch the profile information of the item. The profile
 * information is a type of metadata for the item, but things that are quite
 * expensive to look up and of little interest to most users of the API. The
 * main use of the profile is the Artist object, which has some rarely used
 * properties, such as the biography and portait images. The most likely user
 * of the properties is the artist application. No need to punish every other
 * user of the Artist object.
 *
 * @see MdL#_metadata
 *
 * @private
 */MdL.prototype._profile=function(propsMask){var load=function load(data){this.resolveMany(propsMask,data);};var fail=function fail(oops){this.resolveFail(propsMask,oops);};SP.request(this.constructor._type+'_profile',[this.uri],this,load,fail);}; /**
 * Get a string representation of the object.
 *
 * @return {string} A string representation of the object.
 */MdL.prototype.toString=function(){return this.uri;}; /**
 * Never construct an album object using the default constructor - use
 * fromURI() instead.
 *
 * @class
 * @extends {module:api/models~MdL}
 * @classdesc The album represents any type of album (album, single or
 *     compilation) in the Spotify catalog.
 * @since 1.0.0
 *
 * @property {Array.<module:api/models~Artist>} artists The artists of the
 *     album.
 * @property {string} availability Describes how and when the album is
 *     available for playback for the currently logged in user. The value will
 *     be one of: "available", "banned", "regional", "premium" or
 *     "unavailable". "available" means that the album can be played, "banned"
 *     that the artist has chosen to not make the album available, "regional"
 *     that the album is playable in other regions but not in the region of the
 *     currently logged in user, "premium" means that this is premium only
 *     content and a premium account is needed in order to play the album (the
 *     playable property needs to be checked to actually see if the user can
 *     play it or not), and "unavailable" which means the album is unavailable
 *     for other reasons.
 * @property {Array.<string>} copyrights An array of strings with copyright
 *     holders for the album. The strings will be on the format "(C) 2012
 *     Company", where "(C)" can be a "(P)" and the year and company name is
 *     album specific. For copyright symbols, see:<br>
 *     <a href="http://en.wikipedia.org/wiki/Copyright_symbol">Wikipedia - Copyright symbol</a><br>
 *     <a href="http://en.wikipedia.org/wiki/Sound_recording_copyright_symbol">Wikipedia - Sound recording copyright symbol</a>
 * @property {Array} discs An array of discs which are collections of tracks.
 * @property {string} label The label that owns the rights to the album. By
 *     using this name in the search query "label:<name>" you can get all the
 *     albums for a given label.
 * @property {string} image The image URI for the album.
 *     The format of the image URI is platform dependent, but will always be
 *     something that can be used as the source of an img element or a
 *     background-image in CSS. The size of the image is not defined and might
 *     differ between platforms, so it is recommended that applications use the
 *     imageForSize method to get an appropriately sized image. In general,
 *     it's best to use the Image view from the views framework to display
 *     images - it will load the image in the background (while displaying a
 *     placeholder) and make sure to pick the correct size "intelligently",
 *     based on the current screen resolution and available bandwidth.
 * @property {string} name The name of the album. This is a human readable
 *     string that can be presented to the user. Make sure to call the proper
 *     string decoding method before using the string in the DOM.
 * @property {boolean} playable Indicates if the album is playable by the
 *     currently logged in user. An album can be unplayable for various
 *     reasons, such as regional restrictions or play count restrictions in the
 *     free service.
 * @property {number} popularity The popularity rating of the album. This is a
 *     value between 0 and 100, inclusive, with 0 meaning a very unpopular
 *     album and 100 a highly popular album.
 * @property {module:api/models~Collection} tracks The tracks of this album.
 * @property {string} type The type of album: "album", "single", "compilation"
 *     or undefined if the type is not known.
 * @property {string} uri The URI of the album.
 *
 * @param {string} uri The URI of the album.
 *
 * @see module:api/models~MdL#imageForSize
 * @see String#decodeForText
 * @see String#decodeForHtml
 * @see String#decodeForLink
 * @see module:api/models~Album#fromURI
 */function Album(uri){MdL.call(this);this.resolve('uri',uri);}SP.inherit(Album,MdL);Loadable.define(Album,['uri']);Loadable.define(Album,['availability','artists','date','discs','image','images', // Loaded when 'image' is loaded.
'label','name','playable','popularity','type'],'_metadata');Loadable.define(Album,['copyrights'],'_profile');Loadable.define(Album,['tracks'],'_collections');MdL.init(Album,'album'); /**
 * @private
 */Album.prototype._make_artists=function(value){return value&&value.map(_artists);}; /**
 * @private
 */Album.prototype._make_discs=function(value){return value&&value.map(_discs);}; /**
 * @private
 */Album.prototype._collections=function(){this.resolve('tracks',new BridgeCollection(Track,this.uri,'album_tracks'));this.resolveDone();}; /**
 * Returns the album for a given Spotify URI. The URI is the only property that
 * is loaded on the album immediately.
 *
 * @since 1.0.0
 *
 * @param {string} uri The Spotify URI of the album.
 * @return {module:api/models~Album} The album.
 *
 * @example
 * models.Album.fromURI('spotify:album:0hvxqdv8Bg6BXIbTQFr2Sd').load('name').done(function(album) {
 *   console.log(album.uri + ': ' + album.name.decodeForText());
 *   document.getElementById('album').innerHTML = album.name.decodeForHtml();
 * });
 */Album.fromURI=Cache.lookup; /**
 * Gets a list of albums from a list of URIs.
 *
 * @since 1.3.0
 *
 * @param {Array.<string>} uris List of URIs.
 * @return {Array.<module:api/models~Album>} A list of albums.
 */Album.fromURIs=Cache.lookupMany; /**
 * @private
 */Album._cache=new Cache(Album); /**
 * @class
 * @extends {module:api/models~MdL}
 * @classdesc Contains a list of tracks that belong to a single disc of an
 *     album.
 * @since 1.0.0
 */function Disc(uri){MdL.call(this);this.resolve('uri',uri);this.resolve('tracks',new BridgeCollection(Track,uri,'album_disc_tracks'));}SP.inherit(Disc,MdL);Loadable.define(Disc,['uri','tracks']);Loadable.define(Disc,['album','number'],'_metadata');MdL.init(Disc,'disc'); /**
 * @private
 */Disc.prototype._make_album=function(value){return value&&Album.fromURI(value);}; /**
 * Returns the disc for a given Spotify URI. The URI is the only property that
 * is loaded on the disc immediately.
 *
 * @since 1.0.0
 *
 * @param {string} uri The Spotify URI of the disc.
 * @return {module:api/models~Disc} The disc.
 *
 * @example
 * models.Disc.fromURI('spotify:album:1P1LYaTMV1LnDiHA3LOows:1').load('number').done(function(disc) {
 *   console.log(disc.uri + ': ' + disc.number);
 *   document.getElementById('discNumber').innerHTML = disc.number;
 * });
 */Disc.fromURI=Cache.lookup; /**
 * Gets a list of discs from a list of URIs.
 *
 * @since 1.3.0
 *
 * @param {Array.<string>} uris List of URIs.
 * @return {Array.<module:api/models~Disc>} A list of discs.
 */Disc.fromURIs=Cache.lookupMany; /**
 * @private
 */Disc._cache=new Cache(Disc); /**
 * @class
 * @extends {module:api/models~Loadable}
 * @classdesc Contains functionality related to the underlying client that is
 *     running this application.
 * @since 1.5.0
 * @ignore
 *
 * @property {Object.<string, boolean>} features The set of feature flags for
 *     this client. Each key in this object is the name of a feature, and the
 *     value is a boolean indicating whether the feature is enabled.
 */function Client(){BridgeLoadable.call(this);}SP.inherit(Client,BridgeLoadable); /**
 * @private
 */Client.prototype._observed=function(){this.bridgeListen('client_event_wait',[]);};Loadable.define(Client,['features'],'_features');Loadable.define(Client,['hide_hpto'],'_hide_hpto'); /**
 * @private
 */Client.prototype._features=function(propsMask){var load=function load(data){this.resolveMany(propsMask,data);};var fail=function fail(oops){this.resolveFail(propsMask,oops);};SP.request('client_features',[],this,load,fail);}; /**
 * @private
 */Client.prototype._hide_hpto=function(propsMask){var load=function load(data){this.resolveMany(propsMask,data);};var fail=function fail(oops){this.resolveFail(propsMask,oops);};SP.request('client_get_hide_hpto',[],this,load,fail);}; /**
 * Show the platform-specific sharing UI.
 *
 * @param {module:api/models~BridgeLoadable|string} item Item object to share.
 *     URI as a string is supported for now, but marked as deprecated.
 * @param {string=} opt_message Message to render initially in the sharing UI.
 * @param {{x: number, y: number}=} opt_point Point at which the sharing UI
 *     should be rendered. This point is in x,y coordinates relative to the
 *     application viewport.
 * @return {module:api/models~Promise} A Promise which will resolve
 *     successfully if the sharing UI is opened, and which will fail if the
 *     sharing UI could not be opened.
 *
 * @example
 * var item = models.Track.fromURI('spotify:track:2P2S1wxZYQYHRYDip79JiY');
 * var element = document.getElementById('myButton');
 * var rect = element.getBoundingClientRect();
 * models.client.showShareUI(item, 'Check out this track!',
 *     {x: rect.left, y: rect.top}).done(sharingOpenedSuccessfully);
 */Client.prototype.showShareUI=function(item,opt_message,opt_point){var uri=item.uri||item;var message=opt_message||'';var args=[uri,message];if(opt_point&&'x' in opt_point&&'y' in opt_point){args.push(opt_point.x);args.push(opt_point.y);}return promisedRequest(this,'client_show_share_ui',args);}; /**
 * Show the platform-specific context UI.
 *
 * @param {Array.<module:api/models~BridgeLoadable>|module:api/models~BridgeLoadable} item
 *     Items to show context UI for. The items in the array should be of the
 *     same type.
 * @param {{x: number, y: number}=} opt_point Point at which the context UI
 *     should be rendered. This point is in x,y coordinates relative to the
 *     application viewport.
 * @param {module:api/models~BridgeLoadable=} opt_origin
 *     Origin where the items come from.
 * @param {number=} opt_index Index of item within collection.
 * @return {module:api/models~Promise} A Promise which will resolve
 *     successfully if the context UI is opened, and which will fail if the
 *     context UI could not be opened.
 *
 * @example
 * var items = [
 *   models.Track.fromURI('spotify:track:2e2Z8FeqqvUClWqc23nuX1'),
 *   models.Track.fromURI('spotify:track:3k68IqyXiefjfjKy3BVOX0'),
 *   models.Track.fromURI('spotify:track:3jRHAsjvnSTmB5crrpqyTj')
 * ];
 * var element = document.getElementById('track');
 * var rect = element.getBoundingClientRect();
 * models.client.showContextUI(items, { x: rect.left, y: rect.top })
 *     .done(contextUIOpenedSuccessfully)
 *     .fail(contextUINotOpened);
 */Client.prototype.showContextUI=function(items,opt_point,opt_origin,opt_index){var uris=Array.isArray(items)?SP.uris(items):[items.uri];var args=[uris];if(opt_point&&'x' in opt_point&&'y' in opt_point){args.push(opt_point.x);args.push(opt_point.y);}if(opt_origin&&opt_origin.uri){args.push(opt_origin.uri);}if(typeof opt_index!=='undefined'&&opt_index%1===0){args.push(opt_index);}return promisedRequest(this,'client_show_context_ui',args);}; /**
 * Broadcast a string message to all apps listening to the "broadcast" event.
 *
 * @param {string} message Event name.
 * @return {module:api/models~Promise} A Promise which will resolve
 *     successfully if the event was sent.
 *
 * @example
 * models.client.addEventListener('broadcast', function(event) {
 *   console.log('Event: ', event.message); // == 'my-event'
 * });
 * models.client.broadcast('my-event');
 */Client.prototype.broadcast=function(message){return promisedRequest(this,'client_broadcast',[message]);}; /**
 * @class
 * @extends {module:api/models~BridgeLoadable}
 * @classdesc The application object manages the interaction between your
 *     application and the Spotify client it runs within. The arguments that
 *     were used to start the application can be accessed and observed, so that
 *     the application is notified whenever they change. Like all other objects
 *     in the Spotify API, the caller must make sure the object is loaded
 *     before accessing any of its properties.
 * @since 1.0.0
 *
 * @property {Array} arguments The arguments that were used to start the
 *     application, or the most recent arguments if they have changed since
 *     starting. Observe the "arguments" event to get notified when this
 *     happens.
 * @property {Array} dropped The most recent spotify items that were
 *     dragged and dropped into the app. Observe the "dropped" event to
 *     get notified when this happens.
 * @property {string} identifier The application identifier.
 * @property {string} name The localized application name.
 * @property {string} uri The URI of the application, without any arguments.
 *
 * @example
 * models.application.load('arguments').done(doSomethingWithTheArguments);
 * models.application.addEventListener('arguments', doSomethingWithTheArguments);
 */function Application(){BridgeLoadable.call(this);}SP.inherit(Application,BridgeLoadable); /**
 * @name module:api/models~Application#arguments
 * @desc Fired when the application's arguments have changed.
 * @event
 *
 * @param {Object} event The event object.
 */ /**
 * @name module:api/models~Application#activate
 * @desc Fired when the application is activated.
 * @event
 *
 * @param {Object} event The event object.
 */ /**
 * @name module:api/models~Application#deactivate
 * @desc Fired when the application is deactivated.
 * @event
 *
 * @param {Object} event The event object.
 */ /**
 * @name module:api/models~Application#dropped
 * @desc Fired when spotify items are dragged and dropped into the application.
 * @event
 *
 * @param {Object} event The event object.
 */Loadable.define(Application,['arguments','dropped','identifier','name','uri'],'_query'); /**
 * @private
 */Application.prototype._observed=function(){this.bridgeListen('application_event_wait',[]);}; /**
 * @private
 */Application.prototype._make_dropped=function(value){return value&&value.map(function(i){return fromURI(i);});}; /**
 * @private
 */Application.prototype._query=function(propsMask){var load=function load(data){this.resolveMany(propsMask,data);};var fail=function fail(oops){this.resolveFail(propsMask,oops);};SP.request('application_query',[],this,load,fail);}; /**
 * Makes a request to the current system to activate the application. Whether
 * or not this request is granted is not guaranteed, and implementations are
 * free to ignore this request.
 *
 * @since 1.0.0
 *
 * @example
 * finishedInitialization(…, function() {
 *   models.application.activate();
 * });
 */Application.prototype.activate=function(){return promisedRequest(this,'application_activate',[this.uri]);}; /**
 * Makes a request to the current system to deactivate the application. Whether
 * or not this request is granted is not guaranteed, and implementations are
 * free to ignore this request.
 *
 * @since 1.0.0
 *
 * @example
 * finishedDestruction(…, function() {
 *   models.application.deactivate();
 * });
 */Application.prototype.deactivate=function(){return promisedRequest(this,'application_deactivate',[this.uri]);}; /**
 * If specified in the application's manifest that a loading screen should be
 * put up in place of the application itself, when starting the application,
 * call this method to indicate that the application has finished loading
 * whatever it needs to display the initial state. Also call this method if the
 * manifest specifies that it can restore itself exactly to the state it had
 * when last deactivated. This will hide the screenshot of the application that
 * was made when the application deactivated, and is now used to hide the load.
 *
 * Note that there is no guarantee that the client will keep the loading screen
 * forever, if the application never calls this method. The client can choose
 * to hide the loading screen after an arbitrary timeout even if the
 * application has not completely finished loading, so care should be taken to
 * ensure that the state restoration is as fast as possible.
 *
 * @since 1.0.0
 *
 * @example
 * loadSavedStateFromLocalStorageAndRestoreDOM(…, function() {
 *   models.application.hideLoadingScreen();
 * });
 */Application.prototype.hideLoadingScreen=function(){SP.request('application_notify_loaded',[]);}; /**
 * Reads a single file from the application's bundle. The path is relative to
 * the root of the bundle. If there is a localized version of the file (in a
 * .loc sub-directory, e.g., en.loc, fr.loc), it will be returned instead of
 * the non-localized version.
 *
 * @since 1.0.0
 *
 * @param {string} path The file path, relative to the root of the
 *     application's bundle.
 * @return {module:api/models~Promise} A promise that will be fulfilled when
 *     the data has been read. The object of the promise is the data of the
 *     file.
 *
 * @example
 * models.application.readFile('messages.txt').done(gotMessages).fail(didNotGetMessages);
 * function gotMessages(messages) { … }
 * function didNotGetMessages() { … }
 */Application.prototype.readFile=function(path){var promise=new Promise();var request=new XMLHttpRequest();request.open('GET',path,true);request.onreadystatechange=function(e){if(request.readyState!==4)return;if(request.status!==200&&request.status!==0){promise.setFail();}else {promise.setDone(request.responseText);}};request.send(null);return promise;}; /**
 * Instructs the Spotify client to perform its default action on the given
 * URI. Depending on the URI resource kind (track, search, playlist etc.)
 * the client may or may not navigate to it. Depending on which platform
 * you're running on, this might behave differently (to conform with the
 * default behavior for the platform).
 *
 * @since 1.0.0
 *
 * @param {string} uri The Spotify URI to navigate to. The URI should be a
 *     well-formed and properly encoded spotify URI.
 * @param {string=} opt_context The history context of the operation. If the
 *     context of the last URI that was navigated to is the same as this
 *     context, the old entry will be removed from the history stack and
 *     replaced by the new URI. Most applications will not have a need to set
 *     the history context and should leave out this parameter.
 * @return {module:api/models~Promise} A promise that will be fulfilled if the
 *     client can navigate the given URI. If the URI is not valid or supported
 *     by the client, it will fail to resolve. It can also fail if the current
 *     application does not have permission to navigate to URIs.
 *
 * @see module:api/models~Application#openApp
 *
 * @example
 * models.application.openURI('spotify:artist:4F84IBURUo98rz4r61KF70');
 */Application.prototype.openURI=function(uri,opt_context){return promisedRequest(this,'application_open_uri',[uri,opt_context||null]);}; /**
 * Launches another Spotify application with, optional, arguments. The
 * application will launch in a view decided by the client and may end up
 * replacing the currently running application. How an application is launched
 * is specified in the manifest of that application.
 *
 * @since 1.0.0
 *
 * @param {string} app The bundle identifier of the application.
 * @param {...string} var_args Zero or more unencoded strings that will be sent
 *     as arguments to the application.
 * @return {module:api/models~Promise} A promise that will be fulfilled if the
 *     client can launch the specified application. If the application is not
 *     known by the client or if the current application does not have
 *     permission to launch applications, it will fail to resolve. Note that
 *     the current application might not be alive to receive the callback, if
 *     the application that is launched replaces the current application.
 *
 * @see module:api/models~Application#openURI
 *
 * @example
 * var uri = myArtist.uri;
 * models.application.openApp('radio', uri);
 */Application.prototype.openApp=function(app,var_args){var arg=SP.varargs(arguments,1);var uriSegments=['spotify','app',app];for(var i=0,l=arg.length;i<l;i++){uriSegments.push(encodeURIComponent(arg[i]));}return this.openURI(uriSegments.join(':'));}; /**
 * Sets the display title of the application. How this title is used, if used
 * at all, is dependent on the client.
 *
 * @since 1.0.0
 *
 * @param {string} title The display title for the application.
 * @param {string=} opt_subtitle An optional subtitle.
 * @return {module:api/models~Promise} A promise that will be fulfilled if the
 *     display title was successfully changed.
 *
 * @example
 * models.application.setTitle('My Application');
 */Application.prototype.setTitle=function(title,opt_subtitle){return promisedRequest(this,'application_set_title',[title,opt_subtitle||'']);}; /**
 * Resolves a resource path into a form suitable for including in an HTML tag.
 *
 * @since 1.27.0
 *
 * @param {string} path The path to resolve.
 * @return {string} The resolved path.
 *
 * @example
 * var path =  models.application.resolvePath("./images/profile.png");
 * var image = document.createElement('img');
 * image.setAttribute('src', path);
 * document.body.appendChild(image);
 */Application.prototype.resolvePath=function(path){return SP.resolvePath(path);}; /**
 * Logs an app specific event to the Spotify data warehouse. All parameters are
 * application dependent (i.e. you don't have to log your app's bundle version
 * nor name), letting you add new log messages on the fly without having to
 * update any logging framework(s).
 *
 * @since 1.0.0
 *
 * @param {string} context Any context you want to associate with the event
 *     (like "spotify:album:521in6R9kcIFL3cOrqFcH1").
 * @param {string} event The name of the event you're logging.
 * @param {string} eventVersion The version of the event you're logging.
 * @param {string} testVersion The A/B test version (if any) currently in use.
 * @param {Object} data Any data you want to assoicate with the event. Must be
 *     a JSON-serializable object.
 * @return {module:api/models~Promise} The promise for the logging event.
 *
 * @example
 * require(['./models#application'], function(app) {
 *   app.clientEvent('Top 10 list', 'click', '1', '', {itemNumber: 3});
 * });
 */Application.prototype.clientEvent=function(context,event,eventVersion,testVersion,data){return promisedRequest(this,'application_client_event',[].slice.call(arguments));}; /**
 * Never construct an artist object using the default constructor - use
 * fromURI() instead.
 *
 * @class
 * @extends {module:api/models~MdL}
 * @classdesc The artist object represents an artist in the Spotify catalog.
 * @since 1.0.0
 *
 * @property {module:api/models~Collection} albums The artist's own albums.
 * @property {string} biography The biography associated with the artist.
 * @property {module:api/models~Collection} genres The genres associated with
 *     the artist.
 * @property {string} image The image URI for the artist.
 *     The format of the image URI is platform dependent, but will always be
 *     something that can be used as the source of an img element or a
 *     background-image in CSS. The size of the image is not defined and might
 *     differ between platforms, so it is recommended that applications use the
 *     imageForSize method to get an appropriately sized image. In general,
 *     it's best to use the Image view from the views framework to display
 *     images - it will load the image in the background (while displaying a
 *     placeholder) and make sure to pick the correct size "intelligently",
 *     based on the current screen resolution and available bandwidth.
 * @property {string} name The name of the artist. This is a human readable
 *     string that can be presented to the user. Make sure to call the proper
 *     string decoding method before using the string in the DOM.
 * @property {number} popularity The popularity rating of the artist. This is a
 *     value between 0 and 100, inclusive, with 0 meaning a very low popularity
 *     and 100 a very high popularity.
 * @property {module:api/models~Collection} portraits Portraits (images) of the
 *     artist.
 * @property {string} uri The URI of the album.
 * @property {Object} years The years during which the artist was/is active.
 *     This value of the property has two fields: "from" and "to".
 * @property {module:api/models~User} user The user associated to the artist,
 *     if any exists. Otherwise null.
 *
 * @param {string} uri The URI of the artist.
 *
 * @see module:api/models~MdL#imageForSize
 * @see String#decodeForText
 * @see String#decodeForHtml
 * @see String#decodeForLink
 * @see module:api/models~Artist#fromURI
 */function Artist(uri){MdL.call(this);this.resolve('uri',uri);}SP.inherit(Artist,MdL);Loadable.define(Artist,['uri']);Loadable.define(Artist,['image','images', // Loaded when 'image' is loaded.
'name','popularity'],'_metadata');Loadable.define(Artist,['biography','genres','portraits','years'],'_profile');Loadable.define(Artist,['user'],'_associatedUser');MdL.init(Artist,'artist'); /**
 * @private
 */Artist.prototype._associatedUser=function(propsMask){var load=function load(data){this.resolveMany(propsMask,data);};var fail=function fail(oops){this.resolveFail(propsMask,oops);};SP.request('artist_associated_user',[this.uri],this,load,fail);}; /**
 * @private
 */Artist.prototype._make_user=function(value){return value&&User.fromURI(value);}; /**
 * Returns the artist for a given Spotify URI. The URI is the only property
 * that is loaded on the artist immediately.
 *
 * @since 1.0.0
 *
 * @param {string} uri The Spotify URI of the artist.
 * @return {module:api/models~Artist} The artist matching the given URI.
 *
 * @example
 * models.Artist.fromURI('spotify:artist:5bWRCM3vFGqamlNxSzNj1O').load('name').done(function(artist) {
 *   console.log(artist.uri + ': ' + artist.name.decodeForText());
 *   document.getElementById('artist').innerHTML = artist.name.decodeForHtml();
 * });
 */Artist.fromURI=Cache.lookup; /**
 * Gets a list of artists from a list of URIs.
 *
 * @since 1.3.0
 *
 * @param {Array.<string>} uris List of URIs.
 * @return {Array.<module:api/models~Artist>} A list of artists.
 */Artist.fromURIs=Cache.lookupMany; /**
 * @private
 */Artist._cache=new Cache(Artist); /**
 * An enum of the different allowed list descriptor types.
 *
 * @enum {string}
 */ListDescriptor.Types={LIST:'list',LISTS:'lists',SORT:'sort',FILTER:'filter',RANGE:'range',SHUFFLE:'shuffle'}; /**
 * Never construct a list descriptor using the default constructor - use create
 * or one of the "get*" methods instead.
 *
 * @class
 * @classdesc Describes the list contained in a collection, including the item
 *     list(s) it's built of and any modifiers (i.e. sorting/ranging/filtering).
 * @since TODO
 *
 * @property {module:api/models~ListDescriptor.Types} type The type of the
 *     descriptor.
 *
 * @param {module:api/models~ListDescriptor.Types} type The type of this list
 *     descriptor. Can be one of: lists, list, sort, filter, range, shuffle.
 * @param {Object=} opt_params Depending on the type this will hold different
 *     parameters. Available options are:
 *     - uri: a Spotify URI identifying the underlying source list.
 *     - lists: an array of list descriptors, used for context groups.
 *     - list: the list descriptor that a modifier is applied to.
 *     - version: for versioning of modifier arguments.
 *     - args: an array of string that hold the arguments to the modifiers.
 *
 * @example
 * var descriptor = new ListDescriptor(ListDescriptor.Types.LIST, {uri: uri});
 * descriptor = new ListDescriptor(ListDescriptor.Types.SORT, {
 *   list: descriptor,
 *   version: 1,
 *   args: ['name', 'asc']
 * });
 */function ListDescriptor(type,opt_params){this.type=type;for(var n in opt_params){this[n]=opt_params[n];}} /**
 * Compares two list descriptors to see if they are equal.
 *
 * @param {module:api/models~ListDescriptor} a The first list descriptor.
 * @param {module:api/models~ListDescriptor} b The second list descriptor.
 *
 * @return {boolean} Returns true if the list descriptors are equal, false
 *     otherwise.
 */ListDescriptor.compare=function(a,b){if(a.type!==b.type){return false;}switch(a.type){case ListDescriptor.Types.LIST:return a.uri===b.uri;case ListDescriptor.Types.LISTS:if(a.lists.length!==b.lists.length){return false;}for(var i=0;i<a.lists.length;i++){if(!ListDescriptor.compare(a.lists[i],b.lists[i])){return false;}}return true;case ListDescriptor.Types.FILTER:case ListDescriptor.Types.RANGE:case ListDescriptor.Types.SHUFFLE:case ListDescriptor.Types.SORT:if(a.version!==b.version){return false;}if(a.args.toString()!==b.args.toString()){return false;}return ListDescriptor.compare(a.list,b.list);default:return false;}}; /**
 * Create a basic list descriptor with a single Spotify URI and without
 * modifiers.
 *
 * @param {string} uri The uri that points to the list resource.
 * @return {module:api/models~ListDescriptor} The created list descriptor.
 */ListDescriptor.create=function(uri){return new ListDescriptor(ListDescriptor.Types.LIST,{uri:uri});}; /**
 * Create a concatenated list descriptor consisting of multiple lists.
 *
 * @param {Array.<module:api/models~ListDescriptor>} lists An array of list
 *     descriptors.
 * @return {module:api/models~ListDescriptor} The created list descriptor.
 */ListDescriptor.createConcatenated=function(lists){return new ListDescriptor(ListDescriptor.Types.LISTS,{lists:lists});}; /**
 * Get a filtered list descriptor for this descriptor.
 *
 * @param {string} operation How to compare when filtering.
 * @param {string} field The field to filter on.
 * @param {string} value The value to compare against when filtering.
 * @return {module:api/models~ListDescriptor} The new list descriptor.
 */ListDescriptor.prototype.filter=function(operation,field,value){return new ListDescriptor(ListDescriptor.Types.FILTER,{list:this,args:[operation,field,value],version:1});}; /**
 * Get a range list descriptor for this descriptor.
 *
 * @param {number} offset The offset to start the range from.
 * @param {number} length The length of the range.
 * @return {module:api/models~ListDescriptor} The new list descriptor.
 */ListDescriptor.prototype.range=function(offset,length){return new ListDescriptor(ListDescriptor.Types.RANGE,{list:this,args:[offset,length],version:1});}; /**
 * Get a shuffled list descriptor for this descriptor.
 *
 * @param {number=} opt_seed An optional seed used to give a deterministic
 *     shuffle.
 * @return {module:api/models~ListDescriptor} The new list descriptor.
 */ListDescriptor.prototype.shuffle=function(opt_seed){return new ListDescriptor(ListDescriptor.Types.SHUFFLE,{list:this,args:[opt_seed||Math.floor(Math.random()*200000000)],version:1});}; /**
 * Get a sorted list descriptor for this descriptor.
 *
 * @param {string} field The field to sort on.
 * @param {string=} opt_direction An optional sorting order, "asc" or "desc". Defaults to ascending.
 * @param {...Object} var_args repeated fields and directions for secondary, tertiary etc. sort order.
 * @return {module:api/models~ListDescriptor} The new list descriptor.
 */ListDescriptor.prototype.sort=function(field,opt_direction,var_args){if(arguments.length>2&&arguments.length%2!=0){throw new Error('Invalid number of parameters');}var args=arguments.length==1?[field,'asc']:Array.prototype.slice.call(arguments);return new ListDescriptor(ListDescriptor.Types.SORT,{list:this,args:args,version:1});}; /**
 * Returns the descriptor that represents the base for the list that this
 * descriptor is for.
 *
 * @return {module:api/models~ListDescriptor} A descriptor of type "list" or
 *     "lists".
 */ListDescriptor.prototype.getBase=function(){switch(this.type){case ListDescriptor.Types.LIST:case ListDescriptor.Types.LISTS:return this;case ListDescriptor.Types.FILTER:case ListDescriptor.Types.RANGE:case ListDescriptor.Types.SHUFFLE:case ListDescriptor.Types.SORT:return this.list?this.list.getBase():null;}return null;}; /**
 * @class
 * @extends {module:api/models~BridgeLoadable}
 * @classdesc A collection represents a list of items. Each item in a given
 *     collection is guaranteed to be of the same kind. The type of the item(s)
 *     depends on what the collection represents - it could be tracks in a
 *     playlist, albums in a toplist etc.
 * @since 1.0.0
 *
 * @property {module:api/models~ListDescriptor} descriptor The list descriptor
 *     that describes the list of items that this collection represents.
 * @property {Function} type The type of the items in the collection.
 * @property {string} uri The URI identifying the collection.
 *
 * @param {module:api/models~Loadable} itemClass A constructor for the items in
 *     the resulting snapshots. All items must be of this type.
 * @param {string} uri The URI that identifies the collection.
 * @param {Function} snapshot A function responsible for getting the items for
 *     snapshots. It should return a promise which resolves to an object with
 *     the properties "array", "length", and (optionally) "metadata".
 * @param {module:api/models~ListDescriptor=} opt_descriptor An optional
 *     descriptor with more info to describe the collection. If one is not
 *     specified, a new one will be created using the specified URI.
 * @param {Function=} opt_itemFactory A factory function responsible for
 *     creating the items in the collection out of the data returned by the
 *     snapshot request. The factory function will be called with two
 *     arguments: the basic data and the corresponding metadata. The metadata
 *     argument might not always be provided.
 *     <p>
 *     If a factory is not provided, the item type's static fromURI method will
 *     be used.
 */function Collection(itemClass,uri,snapshot,opt_descriptor,opt_itemFactory){BridgeLoadable.call(this);this.resolve('descriptor',opt_descriptor instanceof ListDescriptor?opt_descriptor:ListDescriptor.create(opt_descriptor||uri));this.resolve('type',itemClass);this.resolve('uri',uri);this._snapshot=snapshot;this._factory=opt_itemFactory||SP.bind(itemClass.fromURI,itemClass);}SP.inherit(Collection,BridgeLoadable);Loadable.define(Collection,['descriptor','type','uri']); /**
 * Clone this collection, and optionally change the descriptor. This should
 * rarely need to be called without a new descriptor to use, since collections
 * are stateless.
 *
 * @param {module:api/models~ListDescriptor=} opt_newDescriptor The new descriptor
 *     to use.
 */Collection.prototype.clone=function(opt_newDescriptor){return new Collection(this.type,this.uri,this._snapshot,opt_newDescriptor||this.descriptor,this._factory);}; /**
 * Makes a snapshot of the collection, optionally for a limited range. Making a
 * snapshot is the only way to examine the items in the collection, by freezing
 * it at a specific moment in time. The snapshot, once resolved, will never
 * change and can be kept around for as long as required. The start offset and
 * maximum length can, and should, be used to limit the size of the snapshot.
 * When making a snapshot of a playlist, only ask for the tracks that are
 * actually being displayed on screen at the moment, instead of asking for all
 * tracks in the playlist, which could be thousands of tracks. Even if the items
 * are not meant to be displayed it is a good idea to divide the colleciton into
 * chunks of reasonable size, to keep memory usage down and avoid blocking the
 * client. Ask for sequential snapshots of 500 items or so and ask for the next
 * snapshot while working on the first one.
 *
 * @since 1.0.0
 *
 * @param {number=} opt_start The offset of the first item to fetch in the
 *     snapshot. This is a hint to the API, and items before the offset could
 *     end up being fetched. It is however not allowed to read any items that
 *     were not specifically specified.
 * @param {number=} opt_length The maximum length of the range to snapshot.
 *     This is also a hint, and more items could end up being fetched. Note
 *     that the caller must not ask for items outside of the specified range.
 * @param {boolean=} opt_raw An optional parameter specifying if the snapshot
 *     should avoid pre-fetching metadata for the items in the snapshot. For
 *     most use cases this parameter should be left out or set to false. Only
 *     pass true if the only intended use for the snapshot is to get the URIs
 *     of the items.
 * @return {module:api/models~Promise} A promise.
 *
 * @example
 * playlist.tracks.snapshot(0, 50).done(function(snapshot) {
 *   var len = Math.min(snapshot.length, 50);
 *   for (var i = 0; i < len; i++) {
 *     doSomethingWithTrack(snapshot.get(i));
 *   }
 * });
 */Collection.prototype.snapshot=function(opt_start,opt_length,opt_raw){var snapshot=new Snapshot(this,opt_start,opt_length,opt_raw);return snapshot.load('length','range');}; /**
 * Adds one or more items to a collection. The item is added to the end of the
 * collection. Note that it is better to call this method with multiple items
 * than to call it multiple times with a single item, since the tracks are added
 * asynchronously and could end up in the wrong order otherwise. This can happen
 * when the second item to add is already cached by the client, while the first
 * item must be fetched remotely. In this situation the second item would be
 * added before the first. This can either be resolved by always waiting for the
 * item to be added before moving on to the next item, but this is less efficient
 * than simply passing in all items to be added right away.
 *
 * @since 1.0.0
 *
 * @param {Array.<Object>|...Object} items The items to add to the collection.
 *     Can either be a single item, many items or an array of items.
 * @return {module:api/models~Promise} A promise.
 *
 * @example
 * playlist1.tracks.add(models.Track.fromURI('spotify:track:2P2S1wxZYQYHRYDip79JiY'));
 * playlist2.tracks.add(track1, track2, …, trackN).done(addedManyTracks);
 */Collection.prototype.add=function(items){throw new Error('This method has not been implemented.');}; /**
 * Inserts one or more items into a collection. Note that it is better to call
 * this method with multiple items than to call it multiple times with a single
 * item, since the tracks are added asynchronously and could end up in the wrong
 * order otherwise. This can happen when the second item to insert is already
 * cached by the client, while the first item must be fetched remotely. In this
 * situation the second item would be inserted before the first. This can either
 * be resolved by always waiting for the item to be inserted before moving on to
 * the next item, but this is less efficient than simply passing in all items to
 * be inserted right away.
 *
 * @since 1.0.0
 *
 * @param {module:api/models~Reference} ref A reference to where the items
 *     should be inserted into the collection.
 * @param {Array.<Object>|...Object} items The items to insert into the
 *     collection. Can either be a single item, many items or an array of
 *     items.
 * @return {module:api/models~Promise} A promise.
 *
 * @example
 * playlist.tracks.snapshot(function(snapshot) {
 *   var index = …;
 *   playlist.tracks.insert(snapshot.ref(index), track1, track2, track3);
 * });
 */Collection.prototype.insert=function(ref,items){throw new Error('This method has not been implemented.');}; /**
 * Removes an item from the collection.
 *
 * @since 1.0.0
 *
 * @param {module:api/models~Reference} ref A reference to which item should be
 *     removed from the collection.
 * @return {module:api/models~Promise} A promise.
 */Collection.prototype.remove=function(ref){throw new Error('This method has not been implemented.');}; /**
 * Trims items from the end of the collection so that the last item in the
 * collection is the item referred to by the given reference. If the reference
 * is not in the collection, no items will be removed.
 *
 * @since 1.0.0
 *
 * @param {module:api/models~Reference} ref The last item in the collection to
 *     keep.
 * @return {module:api/models~Promise} A promise.
 */Collection.prototype.trim=function(ref){throw new Error('This method has not been implemented.');}; /**
 * Removes all items in the collection.
 *
 * @since 1.0.0
 *
 * @return {module:api/models~Promise} A promise.
 */Collection.prototype.clear=function(){throw new Error('This method has not been implemented.');}; /**
 * Returns a sorted version of the collection. The current collection
 * will not be affected.
 *
 * @since 1.0.0
 *
 * @param {string} field The field by which to sort by.
 *     As of now only collections of tracks are sortable and the fields that
 *     are allowed to sort on for those are:
 *     - album.name: the name of the album the track belongs to.
 *     - artists.name: the artist performing the track.
 *     - addTime: the timestamp when the track was added to a playlist.
 *     - creator: the person who added the track to a playlist.
 *     - disc: the disc number.
 *     - duration: the duration of the track.
 *     - name: the title of the track.
 *     - number: the number of the track on an album disc.
 *     - popularity: how popular the track is.
 *     - seen: if a track has been marked as seen or not.
 * @param {string=} opt_direction The sorting order, ascending or descending.
 *     Is given as "asc" or "desc". If the sording order is not
 *     specified, ascending order is used.
 * @param {...Object} var_args repeated fields and directions for secondary, tertiary etc. sort order.
 * @return {module:api/models~Collection} A sorted collection.
 *
 * @example
 * // Sort the playlist by duration of the tracks, longest first.
 * // The sorted collection can further be filtered if needed.
 * var sorted = playlist.tracks.sort('duration', 'asc');
 */Collection.prototype.sort=function(field,opt_direction,var_args){return this.clone(this.descriptor.sort.apply(this.descriptor,arguments));}; /**
 * Returns a filtered version of the collection. The current collection
 * will not be affected.
 *
 * @since 1.0.0
 *
 * @param {string} operation The operation to use when filtering.
 *     Available operations are "=", "<", "<=", ">=", ">", "!=",
 *     "startswith" and "contains".
 * @param {string} field The field to do the filtering on.
 *     As of now only collections of tracks are filterable and the fields that
 *     are allowed to filter on for those are:
 *     - album.name: the name of the album the track belongs to.
 *     - artists.name: the artist performing the track.
 *     - duration: the duration of the track.
 *     - name: the title of the track.
 *     - playable: whether the track is playable for the current user.
 *     - seen: if a track has been marked as seen or not.
 *     - text: free text filtering based on title, artist name and album name.
 * @param {string} value  The actual value to use when filtering.
 * @return {module:api/models~Collection} The filtered collection.
 *
 * @example
 * // Filter the playlist to only show playable tracks.
 * var filtered = playlist.tracks.filter('=' 'playable', 'true');
 * // Filter the playlist to only show tracks with an artist that starts with 'slayer'.
 * var filtered = playlist.tracks.filter('startswith', 'artist.name', 'slayer');
 * // Filter on the free text field. Note that 'contains' is the only allowed operation here.
 * var filtered = playlist.tracks.filter('contains', 'text', 'miles walkin');
 */Collection.prototype.filter=function(operation,field,value){return this.clone(this.descriptor.filter(operation,field,value));}; /**
 * Returns a ranged version of the collection. The current collection will not
 * be affected.
 *
 * @param {number} offset The offset where to start ranging.
 * @param {number} length The length of the range.
 * @return {module:api/models~Collection} The ranged collection.
 *
 * @example
 * // Create a range of the first twelve tracks of a playlist.
 * var ranged = playlist.tracks.range(0, 12);
 */Collection.prototype.range=function(offset,length){return this.clone(this.descriptor.range(offset,length));}; /**
 * Returns a shuffled version of the collection. The current collection will
 * not be affected.
 *
 * @param {number=} opt_seed An optional seed to create a stable shuffle.
 * @return {module:api/models~Collection} The shuffled collection.
 *
 * @example
 * // Shuffle the playlist.
 * var shuffled = playlist.tracks.shuffle();
 */Collection.prototype.shuffle=function(opt_seed){return this.clone(this.descriptor.shuffle(opt_seed));}; /**
 * Determines if a list of items is part of the collection or not.
 *
 * Note that not all collections implement this feature, as it can be an
 * extremely heavy, in some cases impossible, operation to perform.
 *
 * @function
 * @name Collection#contains
 * @since 1.22.0
 * @param {Array.<Object>|...Object} items The items to verify containment for.
 *     Can either be a single item, many items or an array of items.
 * @return {Promise} A promise that will result in the containment. If a single
 *     item was provided the result is just a Boolean. If multiple items were
 *     provided the result is an array where each index is a Boolean.
 *
 * @example
 * var track1 = models.Track.fromURI('spotify:track:2P2S1wxZYQYHRYDip79JiY');
 * library.tracks.contains(track1).done(function(contains) {
 *   console.log(contains ? 'Yes!' : 'No.');
 * });
 *
 * var track2 = models.Track.fromURI('spotify:track:1hKdDCpiI9mqz1jVHRKG0E');
 * library.tracks.contains([track1, track2]).done(function(contains) {
 *   console.log('Track 1:', contains[0], 'Track 2:', contains[1]);
 * });
 */Collection.prototype.contains=function(items){throw new Error('This method has not been implemented.');}; /**
 * @class
 * @extends {module:api/models~Collection}
 * @classdesc A special collection which will perform all its operations
 *     (snapshot, add, etc.) over the bridge.
 *
 * @property {module:api/models~ListDescriptor} descriptor The list descriptor
 *     that describes the list of items that this collection represents.
 * @property {Function} type The type of the items in the collection.
 * @property {string} uri The URI identifying the collection.
 *
 * @param {module:api/models~BridgeLoadable} itemClass A constructor for the
 *     items in the resulting snapshots. All items must be of this type.
 * @param {string} uri The URI that identifies the collection.
 * @param {string} requestPrefix The prefix to put before bridge requests such
 *     as "_snapshot", "_insert", and "_remove".
 * @param {module:api/models~ListDescriptor=} opt_descriptor An optional
 *     descriptor with more info to describe the collection. If one is not
 *     specified, a new one will be created using the specified URI.
 * @param {Function=} opt_itemFactory A factory function responsible for
 *     creating the items in the collection out of the data returned by the
 *     bridge. The factory function will be called with two arguments: the
 *     basic data and the corresponding metadata. The metadata argument might
 *     not always be provided.
 *     <p>
 *     If a factory is not provided, the item type's static fromURI method will
 *     be used.
 *
 * @private
 */function BridgeCollection(itemClass,uri,requestPrefix,opt_descriptor,opt_itemFactory){Collection.call(this,itemClass,uri,this._requestSnapshot,opt_descriptor,opt_itemFactory);this._prefix=requestPrefix;}SP.inherit(BridgeCollection,Collection); /**
 * Performs the bridge request for fetching a snapshot. Triggered by loading
 * the "length" or "range" properties on a snapshot instance.
 *
 * @param {module:api/models~ListDescriptor} descriptor A descriptor describing
 *     the list which is being snapshotted.
 * @param {number} offset Offset into the snapshot.
 * @param {number} length The length of the snapshot.
 * @param {boolean} raw Whether the data should be raw (no metadata).
 * @return {module:api/models~Promise} A promise.
 *
 * @private
 */BridgeCollection.prototype._requestSnapshot=function(descriptor,offset,length,raw){var promise=new Promise(); // XXX(fxb): This is a hack for making 'toplist_region_*' snapshots work,
//           that have the invalid 'spotify:top:<type>:country:USER' URI.
//           Remove this hack, when Toplist.forCurrentRegion is removed.
if(this._prefix.indexOf('toplist_region_')==0&&descriptor.uri.match(/:country:USER$/)!=null){var onCountryLoaded=function onCountryLoaded(session){descriptor.uri=descriptor.uri.replace(/:country:USER$/,':country:'+session.country);SP.request(this._prefix+'_snapshot',[descriptor,offset,length,raw],promise,promise.setDone,promise.setFail);};new Session().load('country').done(SP.bind(onCountryLoaded,this)).fail(promise.setFail);return promise;}SP.request(this._prefix+'_snapshot',[descriptor,offset,length,raw],promise,promise.setDone,promise.setFail);return promise;};BridgeCollection.prototype.add=function(items){var args=SP.uris(arguments);args.unshift(this.descriptor);return promisedRequest(this,this._prefix+'_append',args);};BridgeCollection.prototype.clear=function(){return promisedRequest(this,this._prefix+'_clear',[this.descriptor]);};BridgeCollection.prototype.clone=function(opt_newDescriptor){return new BridgeCollection(this.type,this.uri,this._prefix,opt_newDescriptor||this.descriptor,this._factory);};BridgeCollection.prototype.insert=function(ref,items){var args=[this.descriptor,ref.index,ref.uri];var uris=SP.uris(arguments,1);return promisedRequest(this,this._prefix+'_insert',args.concat(uris));};BridgeCollection.prototype.remove=function(ref){return promisedRequest(this,this._prefix+'_remove',[this.descriptor,ref.index,ref.uri]);};BridgeCollection.prototype.trim=function(ref){return promisedRequest(this,this._prefix+'_trim',[this.descriptor,ref.index,ref.uri]);};BridgeCollection.prototype.contains=function(items){var args=SP.uris(arguments);args.unshift(this.descriptor);var promise=new Promise();var done=function done(val){if(args.length==2&&!(items instanceof Array))promise.object=val.in_collection[0];else promise.object=val.in_collection;promise.setDone();};SP.request(this._prefix+'_contains',args,promise,done,promise.setFail);return promise;}; /**
 * Never construct a context object using the default constructor - use
 * fromURI() instead.
 *
 * @class
 * @extends {module:api/models~Loadable}
 * @classdesc An opaque context. The player will hold one of these contexts
 *     when a track is playing, rather than holding a reference to the high
 *     level context objects, such as Album or Playlist. This context can be
 *     compared to other contexts to check for equality and it can also be
 *     passed to the play methods of the player object.
 * @since 1.0.0
 *
 * @property {string} uri The URI of the context.
 *
 * @see module:api/models~Context#fromURI
 * @see module:api/models~Player#playContext
 */function Context(uri){Loadable.call(this);this.resolve('uri',uri);}SP.inherit(Context,Loadable);Loadable.define(Context,['uri']); /**
 * Get a string representation of the object.
 *
 * @return {string} A string representation of the object.
 */Context.prototype.toString=function(){return this.uri;}; /**
 * Returns an opaque context for a given Spotify URI. The URI is the only
 * property that is available on the context. It is loaded immediately.
 *
 * @since 1.0.0
 *
 * @param {string} uri The Spotify URI of the context.
 * @return {module:api/models~Context} The opaque context for the URI.
 *
 * @example
 * models.Artist.fromURI('spotify:artist:5bWRCM3vFGqamlNxSzNj1O').load('name').done(function(artist) {
 *   console.log(artist.uri + ': ' + artist.name.decodeForText());
 *   document.getElementById('artist').innerHTML = artist.name.decodeForHtml();
 * });
 */Context.fromURI=function(uri){return new Context(uri);}; /**
 * Never construct a context object using the default constructor - use
 * create() instead.
 *
 * @class
 * @extends {module:api/models~Loadable}
 * @classdesc A context group. The player takes a context group when calling
 *     the playContextGroup method.
 * @since 1.0.0
 *
 * @see module:api/models~Context#create
 * @see module:api/models~Player#playContextGroup
 */function Group(){Loadable.call(this);this.resolve('descriptor',ListDescriptor.createConcatenated([]));}SP.inherit(Group,Loadable);Loadable.define(Group,['descriptor']); /**
 * Add a context to a context group so they can be played together as one large context.
 *
 * @example
 *    var group = models.Group.create(id);
 *    group.add(models.Album.fromURI('spotify:album:5etQDl13KIndMaI2d9PZTy'));
 *    group.add(models.Playlist.fromURI("spotify:user:bobcat.dev:playlist:5aKLARNN2gWLog15rrlhel"));
 */Group.prototype.add=function(context){var descriptor=context.descriptor||ListDescriptor.create(context.uri);this.descriptor.lists.push(descriptor);}; /**
 * Creates a named context group.
 *
 * @since 1.0.0
 *
 * @return {module:api/models~Promise} A promise that will resolve into a Group
 *     once it has been created.
 */Group.create=function(){var group=new Group();var promise=new Promise();promise.setDone(group);return promise;}; /**
 * Never construct a playlist object using the default constructor - use
 * fromURI() instead.
 *
 * @class
 * @extends {module:api/models~MdL}
 * @classdesc The playlist object represents a playlist owned by a certain
 *     Spotify user.
 * @since 1.0.0
 *
 * @property {Object} allows A dictionary of the allowed operations on the
 *     playlist.
 * @property {boolean} collaborative Indicates if this is a collaborative
 *     playlist.
 * @property {string} name The name of the playlist. This is a human readable
 *     string that can be presented to the user. Make sure to call the proper
 *     string decoding method before using the string in the DOM.
 * @property {string} image The image URI for the playlist. The format of the
 *     image URI is platform dependent, but will always be something that can
 *     be used as the source of an img element or a background-image in CSS.
 *     The size of the image is not defined and might differ between platforms,
 *     so it is recommended that applications use the imageForSize method to
 *     get an appropriately sized image. In general, it's best to use the Image
 *     view from the views framework to display images - it will load the image
 *     in the background (while displaying a placeholder) and make sure to pick
 *     the correct size "intelligently", based on the current screen resolution
 *     and available bandwidth.
 * @property {module:api/models~User} owner The owner of a playlist. Depending
 *     on the privacy settings of the Spotify client, this may or may not be
 *     empty.
 * @property {boolean} published Indicates if the playlist belongs to the
 *     currently logged in user's list of public playlists.
 * @property {boolean} subscribed Indicates if the the currently logged in user
 *     is subscribed to this playlist.
 * @property {module:api/models~Collection} subscribers A collection of users
 *     that are currently subscribed to this playlist.
 * @property {module:api/models~Collection} tracks The tracks in this playlist.
 * @property {string} uri The URI of the playlist.
 *
 * @param {string} uri The URI of the playlist.
 *
 * @see module:api/models~MdL#imageForSize
 * @see String#decodeForText
 * @see String#decodeForHtml
 * @see String#decodeForLink
 * @see module:api/models~Playlist#fromURI
 */function Playlist(uri){MdL.call(this);this.resolve('uri',uri);}SP.inherit(Playlist,MdL); /**
 * @name module:api/models~Playlist#insert
 * @desc Fired when a track is inserted into the playlist.
 * @event
 *
 * @param {Object} event The event object. It has an array of the track URIs
 *     that have been inserted called "uris" and a property called "index"
 *     telling the position where the tracks were inserted.
 */ /**
 * @name module:api/models~Playlist#remove
 * @desc Fired when a track is removed into the playlist.
 * @event
 *
 * @param {Object} event The event object. It has two arrays, one containing
 *     the URIs of the tracks that have been removed called "uris", and another
 *     one containing the positions those tracks had in the playlist called
 *     "indices".
 */ /**
 * @name module:api/models~Playlist#change
 * @desc Fired when a property of the playlist changed.
 * @event
 *
 * @param {Object} event The event object.
 */ /**
 * @name module:api/models~Playlist#change:{property}
 * @desc {property} is one of the playlist's properties listed above. Fired
 *     when that specific property changes.
 * @event
 *
 * @param {Object} event The event object.
 */Loadable.define(Playlist,['uri']);Loadable.define(Playlist,['allows','collaborative','subscribed','name','owner','published'],'_metadata');Loadable.define(Playlist,['image','images' // Loaded when 'image' is loaded.
],'_profile');Loadable.define(Playlist,['subscribers','tracks'],'_collections');Loadable.define(Playlist,['popularity'],'_popularity');MdL.init(Playlist,'playlist'); /**
 * @private
 */Playlist.prototype._make_owner=function(value){return value&&User.fromURI(value.uri,value);}; /**
 * @private
 */Playlist.prototype._collections=function(){this.resolve('subscribers',new BridgeCollection(User,this.uri,'playlist_subscribers'));this.resolve('tracks',new BridgeCollection(Track,this.uri,'playlist_tracks'));this.resolveDone();}; /**
 * @private
 */Playlist.prototype._popularity=function(propsMask){var load=function load(data){this.resolveMany(propsMask,data);};var fail=function fail(oops){this.resolveFail(propsMask,oops);};SP.request('playlist_popularity',[this.uri],this,load,fail);}; /**
 * A bridge listener for library events. This is only a proxy so to actually
 * handle the events, another bridge listener needs to receive the events using
 * the proxyTo method.
 *
 * @type {module:api/models~ProxyListener}
 *
 * @private
 */Playlist._libraryListener=null; /**
 * Returns the playlist for a given Spotify URI. The URI is the only property
 * that is loaded on the playlist immediately.
 *
 * @since 1.0.0
 *
 * @param {string} uri the Spotify URI of the playlist.
 * @return {module:api/models~Playlist} A playlist.
 *
 * @example
 * models.Playlist.fromURI(playlistURI).load('name').done(function(playlist) {
 *   console.log(playlist.uri + ': ' + playlist.name.decodeForText());
 *   document.getElementById('playlist').innerHTML = playlist.name.decodeForHtml();
 * });
 */Playlist.fromURI=Cache.lookup; /**
 * Gets a list of playlists from a list of URIs.
 *
 * @since 1.3.0
 *
 * @param {Array.<string>} uris List of URIs.
 * @return {Array.<module:api/models~Playlist>} A list of playlists.
 */Playlist.fromURIs=Cache.lookupMany; /**
 * @private
 */Playlist._cache=new Cache(Playlist); /**
 * Creates a named playlist and adds it to the user's library.
 *
 * @since 1.0.0
 *
 * @param {string} name The name of the playlist. This is how the playlist will
 *     be presented to the user.
 * @return {module:api/models~Promise} A promise that will resolve into a
 *     Playlist once it has been created.
 */Playlist.create=function(name){var promise=new Promise();var done=function done(result){var playlist=new Playlist(result.uri);Playlist._cache.cache(result.uri,playlist);playlist.resolve('name',name);promise.setDone(playlist);};SP.request('playlist_create',[name],promise,done,promise.setFail);return promise;}; /**
 * Sets up (if needed) and returns a proxy listener for library events.
 *
 * @return {module:api/models~ProxyListener} A proxy listener for library
 *     events.
 */Playlist.getOrCreateLibraryListener=function(){var listener=Playlist._libraryListener;if(!listener){listener=new ProxyListener();listener.bridgeListen('library_event_wait',[exports.session.user.uri]); // Apply a filter to library events which will update cached Playlist
// instances.
listener.filter(function(evt){if(evt.type!='insert'&&evt.type!='remove')return;var newState=evt.type=='insert';switch(evt.receiver){case 'playlists':Playlist._cache.update(evt.uris,{subscribed:newState});break;case 'published':Playlist._cache.update(evt.uris,{published:newState});break;}});Playlist._libraryListener=listener;}return listener;}; /**
 * @override
 */Playlist.prototype.resolveMany=function(propsMask,data,opt_silent){Playlist._superClass.resolveMany.call(this,propsMask,data,opt_silent);};Playlist.prototype.load=function(){var args=SP.varargs(arguments);if(Array.prototype.indexOf.call(args,'subscribed')>=0){ // Start listening for library events if we ever load the subscribed
// property.
Playlist.getOrCreateLibraryListener();}return Playlist._superClass.load.apply(this,args);}; /**
 * Called when the first event listener is added to the playlist object. Make a
 * request for the next event for this playlist. If a request has already been
 * made for this playlist, another request will be made but it will fail
 * because only one event request at a time is allowed. This is ok since it
 * happens fairly rarely and will not cause any incorrect behavior.
 *
 * @private
 */Playlist.prototype._observed=function(){this.bridgeListen('playlist_event_wait',[this.uri]);}; /**
 * Override to stop listening on bridge events if there are no JS listeners
 * attached to this playlist.
 *
 * @override
 */Playlist.prototype.eventFail=function(error){if(!this._obcount)this.bridgeUnlisten();Playlist._superClass.eventFail.call(this,error);}; /**
 * Set the name of the playlist.
 *
 * @param {string} name The new name.
 * @return {module:api/models~Promise} A promise.
 */Playlist.prototype.setName=function(name){return promisedRequest(this,'playlist_set_name',[this.uri,name],true);}; /**
 * Don't use this constructor directly.
 *
 * @class
 * @extends {module:api/models~MdL}
 * @classdesc A profile consisting of artist and/or a user. It can be both an
 *     artist and a user if the artist has connected their page to a user
 *     profile.
 *
 * @since 1.20.0
 *
 * @property {string} uri A URI for the profile. This will be a user URI
 *     when the profile consists of a user; otherwise, an artist URI.
 * @property {module:api/models~Artist} artist An artist object. This field
 *     would be null if the profile is not an artist.
 * @property {module:api/models~User} user A user object. This field would be
 *     null if the artist has not merged their page with a user account.
 * @property {string} name The name of the user or artist. If a user profile
 *     name is available and is not equivalent to the username, it will be used;
 *     otherwise the artist name will be used (if the profile is of an artist).
 * @property {string} image An image for the relation. If a user profile
 *     image is available, it will be used; otherwise the artist image will
 *     be used (if the profile is of an artist).
 *
 * @param {string} uri A URI for the profile. This should be a user URI when a
 *     user profile is available; otherwise, an artist URI.
 *
 */function Profile(uri){MdL.call(this);this.resolve('uri',uri);}SP.inherit(Profile,MdL); /**
 * Gets a Profile object based on the provided artist or user URI.
 *
 * @since 1.20.0
 *
 * @param {string} artistOrUserURI An artist or user URI to find the
 *     appropriate Profile object for.
 * @return {module:api/models~Profile} A Profile object.
 */Profile.fromURI=Cache.lookup; /**
 * Gets a list of Profile objects based on the provided artist or user URIs.
 *
 * @since 1.21.0
 *
 * @param {Array.<string>} artistOrUserURIs A list of artist and/or user URIs
 *     to get the appropriate Profile objects for.
 * @return {Array.<module:api/models~Profile>} A list of Profile objects.
 */Profile.fromURIs=Cache.lookupMany;Profile._cache=new Cache(Profile);Loadable.define(Profile,['uri']);Loadable.define(Profile,['artist','user'],'_loadArtistOrUser');Loadable.define(Profile,['name','image','images'],'_metadata');Profile.prototype._make_artist=function(uri){return Artist.fromURI(uri);};Profile.prototype._make_user=function(uri){return User.fromURI(uri);};Profile.prototype._loadArtistOrUser=function(propsMask){var object=exports.fromURI(this.uri),promise;if(object instanceof Artist){promise=object.load('user').done(this,function(){var uri=object.user?object.user.uri:null;this.resolveMany(propsMask,{artist:object.uri,user:uri});});}else if(object instanceof User){promise=object.load('artist').done(this,function(){var uri=object.artist?object.artist.uri:null;this.resolveMany(propsMask,{artist:uri,user:object.uri});});}else {throw new Error('Invalid URI for Profile');}promise.fail(this,function(){this.resolveFail(propsMask,{message:'Failed to resolve artist/user objects'});});}; // This overrides the _metadata method of MdL.
Profile.prototype._metadata=function(propsMask){this.load('artist','user').done(this,function(){if(this.user){this.user.load('name','username','image','images').done(this,function(){var data={name:this.user.name,image:this.user.image,images:this.user.images}; // A name has been manually defined; not empty or simply the undecorated username
// An image has been uploaded for the user profile
var nameDefined=data.name&&data.name.toLowerCase()!==this.user.username,imageUploaded=data.image; // Load profile data unless it is an artist and a user name and/or image haven't been set
if(!this.artist||nameDefined&&imageUploaded)return this.resolveMany(propsMask,data); // Pull artist name and/or image to fill in missing data for the user profile
this.artist.load('name','image','images').done(this,function(artist){ // Fall back to artist name if the user lacks a valid name
if(!nameDefined)data.name=artist.name; // Fall back to artist image if the user lacks a valid image
if(!imageUploaded){data.image=artist.image;data.images=artist.images;}}).always(this,function(){this.resolveMany(propsMask,data);});}).fail(this,function(_,error){this.resolveFail(propsMask,error);});}else {this.artist.load('name','image','images').done(this,function(artist){this.resolveMany(propsMask,{name:artist.name,image:artist.image,images:artist.images});}).fail(this,function(_,error){this.resolveFail(propsMask,error);});}});}; /**
 * Waits for any playlist change event.
 *
 * @since 1.20.0
 *
 * @private
 */Playlist._playlistEventWait=function(){SP.request('playlist_event_wait_any',[],this,this._playlistEventDone,this._playlistEventFail);}; /**
 * @private
 */Playlist._playlistEventDone=function(event){var playlist=Playlist.fromURI(event.data.uri);playlist.resolveMany(0,event.data);playlist.dispatchEvent(event);this._playlistEventWait();}; /**
 * @private
 */Playlist._playlistEventFail=function(error){if(error.error=='timeout')this._playlistEventWait();}; /**
 * @class
 * @classdesc A reference to an item in a snapshot. To remove items from a
 *     collection, first find the item in the snapshot to get a reference to
 *     it, and then call the remove method on the collection, passing it the
 *     reference. If the collection has changed since creating the reference,
 *     the call will fail, and the caller must make a new snapshot and
 *     reference, and try the operation again. Do not directly create instances
 *     of this class. Instead use the find operation on the snapshot.
 * @since 1.0.0
 *
 * @see module:api/models~Collection#remove
 * @see module:api/models~Snapshot#find
 * @see module:api/models~Snapshot#ref
 *
 * @example
 * myTracks.snapshot().done(function(snapshot) {
 *   myTracks.remove(snapshot.find(track));
 * });
 */function Reference(index,uri){this.index=index;this.uri=uri;} /**
 * @class
 * @extends {module:api/models~BridgeLoadable}
 * @classdesc The session object exposes information about the current session.
 * @since 1.0.0
 *
 * @property {string} catalogue The currently logged in user's account catalogue.
 *     e.g. "free"/"daypass"/"premium"/"shuffle".
 * @property {boolean} connecting Set to true if the client is not online and
 *     is in the process of trying to connect to the Spotify servers.
 * @property {string} connection The current network connection type. One of
 *     "none", "gprs", "edge", "3g", "wlan", "ethernet" and "unknown". More
 *     types will be added in the future as more connectivity options become
 *     available. On some platforms this property may not be available, and
 *     will always be set to "unknown".
 * @property {string} country The country that the currently logged in user is
 *     registered in, as a two-letter ISO 3166-1 country code.
 * @property {boolean} developer Set to true if the currently logged in user's
 *     Spotify account has the "app-developer" attribute.
 * @property {string} device The device that the application is running on. One
 *     of "unknown", "mobile", "tablet" and "desktop". More device types could
 *     be added in the future.
 * @property {boolean} incognito Set if the currently logged in user has
 *     instructed the client to not broadcast any activity publically.
 * @property {string} language The language that the Spotify client is
 *     currently using, as a two-letter ISO 639-1 language code.
 * @property {boolean} online Indicates if the client has a connection to the
 *     Spotify servers or not. This can be false either be because the
 *     connection was lost, or because the client was manually put in offline
 *     mode.
 * @property {string} partner Set if the currently logged in user's account is
 *     currently being paid for through partner. If set, it holds the partner's
 *     identifier.
 * @property {string} product The currently logged in user's account product,
 *     e.g., "premium"/"daypass"/"free".
 * @property {number} resolution The resolution of the main screen of the
 *     device that the application is running on. The resolution is defined in
 *     CSS pixel units, meaning that a resolution of 2 would equal two device
 *     pixels per one CSS pixel. This is corresponds to running the application
 *     on a device with a High-DPI display, such as an iPhone 4 or iPad 3. On
 *     regular resolution displays, this value will be 1.
 * @property {string} streaming Set to disabled, if the user cannot stream
 *     music, enabled if the user can stream, or dmca-radio if streaming is
 *     restricted to DMCA radio.
 * @property {number} testGroup The AB test group that the user belongs to. Can
 *     be used to provide different functionality to different set of users to
 *     test new features and compare the behaviors and outcomes of each group.
 * @property {module:api/models~User} user A User instance representing the
 *     currently logged in user.
 */function Session(){BridgeLoadable.call(this);this.resolve('user',User.fromURI('spotify:user:@'));}SP.inherit(Session,BridgeLoadable); /**
 * @name module:api/models~Session#change
 * @desc Fired when a property of the session changed.
 * @event
 *
 * @param {Object} event The event object.
 */ /**
 * @name module:api/models~Session#change:{property}
 * @desc Where {property} is one of the session's properties listed above.
 *     Fired when that specific property changes.
 * @event
 *
 * @param {Object} event The event object.
 */Loadable.define(Session,['user']);Loadable.define(Session,['catalogue','connecting','connection','country','developer','device','incognito','language','online','partner','product','resolution','streaming','testGroup','capabilities'],'_query'); /**
 * @private
 */Session.prototype._observed=function(){this.bridgeListen('session_event_wait',[]);}; /**
 * @private
 */Session.prototype._query=function(propsMask){var load=function load(data){this.resolveMany(propsMask,data);};var fail=function fail(oops){this.resolveFail(propsMask,oops);};SP.request('session_query',[],this,load,fail);}; /**
 * Returns the test group for the currently logged in user for the given
 * test name.
 *
 * @since X.Y.
 *
 * @param {string} name The name of the test.
 * @return {module:api/models~Promise} The promise for the test group. If
 *     successful, the done callback will return the number of the test group.
 *
 * @example
 * require(['./models#session'], function(session) {
 *     session.testGroupForTest("NTX_NO_SIDEBAR")
 *         .done(function(group) {
 *             console.log("Test group: ", group);
 *         });
 });
 */Session.prototype.testGroupForTest=function(name){var promise=new Promise();SP.request('session_test_group',[name],promise,function(result){this.setDone(result.testGroup);},Promise.setFail);return promise;}; /**
 * @class
 * @extends {module:api/models~Loadable}
 * @classdesc A snapshot is a collection frozen in time. Collections can change
 *     their contents at any time, so to examine the items in the collection,
 *     take a snapshot of the the entire collection, or just the part of it
 *     that is interesting. Partial snapshots are preferred when possible,
 *     since they will fetch less data, saving memory and bandwidth. When the
 *     collection changes, the snapshot will remain the same, but it is a good
 *     time to take a new snapshot of the collection (if your app needs to use
 *     up-to-date data).
 *
 *     To make a snapshot, call the snapshot method on the collection. You
 *     should not directly instantiate a snapshot object.
 * @since 1.0.0
 *
 * @property {number} length The total length of the collection at the time the
 *     snapshot was taken. This number can be greater than the range (offset +
 *     length) that the snapshot was created using.
 * @property {{offset: number, length: number}} range The valid range for the
 *     snapshot, used at creation time. The value of the property has two
 *     fields: "offset" and "length".
 *
 * @param {module:api/models~Collection} collection The collection responsible
 *     for this snapshot.
 * @param {number=} opt_start The offset in the collection at which to start
 *     filling the snapshot with items.
 * @param {number=} opt_length The number of items to put in the snapshot.
 * @param {boolean=} opt_raw Whether the request should only fetch the most
 *     basic information rather than also fetch metadata for the items.
 *
 * @see module:api/models~Collection#snapshot
 *
 * @example
 * myAlbum.tracks.snapshot().done(function(snapshot) { … });
 * myArtist.albums.snapshot.done(artistLoaded).fail(artistNotLoaded);
 * myPlaylist.tracks.snapshot(0, 100).done(function(snapshot) { … });
 */function Snapshot(collection,opt_start,opt_length,opt_raw){Loadable.call(this);this._collection=collection;this._off=opt_start===undefined?0:opt_start;this._len=opt_length===undefined?-1:opt_length;this._raw=!!opt_raw;}SP.inherit(Snapshot,Loadable);Loadable.define(Snapshot,['length','range'],'_request'); /**
 * Requests the items for the snapshot using the collection's "_snapshot"
 * method.
 *
 * @private
 */Snapshot.prototype._request=function(){var col=this._collection;col._snapshot(col.descriptor,this._off,this._len,this._raw).done(this,function(result){this._uris=result.array;this._meta=result.metadata||[];this.resolve('length',result.length);this.resolve('range',{offset:this._off,length:this._uris.length});this.resolveDone();}).fail(this,function(error){var propsMask=this._neededForLoad(['length','range']);this.resolveFail(propsMask,error);});}; /**
 * Returns a singe item from the snapshot. If the index is outside the range of
 * the snapshot, null is returned. Since the snapshot is static, the returned
 * item will never be different when calling this method with the same index.
 *
 * @since 1.0.0
 *
 * @param {module:api/models~Reference|number} index The index of the item to
 *     get. Can be a reference returned by the find method.
 * @return {module:api/models~Loadable} The item in the collection.
 *
 * @example
 * myTracks.snapshot(0, 20).done(function(snapshot) {
 *   var track1 = snapshot.get(18); // Returns a Track
 *   var track2 = snapshot.get(23); // Returns null
 * });
 */Snapshot.prototype.get=function(index){if(index instanceof Reference)index=index.index;index-=this._off;if(index<0||index>this._uris.length)return null;return this._collection._factory(this._uris[index],this._meta[index]);}; /**
 * Searches for a given item in the snapshot part of the collection, and returns
 * a reference to the item if found or null if it was not found in the snapshot.
 * If null is returned it just means that item was not found in the snapshot. It
 * could still be somewhere in the collection. The reference is bound to the
 * snapshot's view of the collection, and can be used to remove items from the
 * collection or add new items in a particular location.
 *
 * @since 1.0.0
 *
 * @param {!module:api/models~Loadable} item A collection item, such as Track
 *     or Artist.
 * @param {module:api/models~Reference|number} first The first item to consider
 *     when searching. This parameter is optional. If left out, the search will
 *     start from first item in the snapshot.
 * @return {module:api/models~Reference} A reference object.
 *
 * @example
 * myTracks.snapshot().done(function(snapshot) {
 *   myTracks.remove(snapshot.find(track));
 * });
 */Snapshot.prototype.find=function(item,first){if(first instanceof Reference)first=first.index;var index=this._uris.indexOf(item.uri,first||0);return index==-1?null:new Reference(index+this._off,this._uris[index]);}; /**
 * This is a utility function to get instances of all the items in this
 * snapshot and then calling load on all the individual items and finally
 * joining all the resulting promises.
 *
 * @since 1.0.0
 *
 * @param {Array.<string>|...string} properties An array of property names. The
 *     property names that are available for loading can be found in the
 *     documentation for each specific sub-class. Note that instead of passing
 *     in an array, multiple arguments can be passed instead.
 * @return {module:api/models~Promise} A promise to wait for before the
 *     properties can be read.
 *
 * @example
 * var playlist = Playlist.fromURI(…);
 * playlist.load('tracks').done(function() {
 *   playlist.tracks.snapshot().done(function(snapshot) {
 *     snapshot.loadAll('name').each(function(track) {
 *       console.log(track.name);
 *     });
 *   });
 * });
 *
 * @see module:api/models~Loadable#load
 */Snapshot.prototype.loadAll=function(){var promises=[],items=this.toArray();for(var i=0,len=items.length;i<len;i++){var item=items[i];promises.push(item.load.apply(item,arguments));}return Promise.join(promises);}; /**
 * Makes a reference to an indexed item in the snapshot. The reference can be
 * used to insert to or remove items from the collection that the snapshot came
 * from. Note that the index must be part of the snapshot subset or one past the
 * the length of the collection, so that tracks can be inserted at the very end.
 *
 * @since 1.0.0
 *
 * @param {number} index The item index in the snapshot.
 * @return {module:api/models~Reference} A reference object.
 *
 * @example
 * myTracks.snapshot().done(function(snapshot) {
 *   myTracks.remove(snapshot.ref(0));
 * });
 */Snapshot.prototype.ref=function(index){var item=this.get(index);return new Reference(index,item?item.uri:null);}; /**
 * Creates an array with all of the items in the snapshot. Does not include the
 * empty slots in the snapshot, if any. Be sure that you actually have a need to
 * call this method before using it, since it will create instances of every item
 * in the snapshot, which are usually created lazily.
 *
 * @since 1.0.0
 *
 * @return {Array.<Object>} An array.
 *
 * @example
 * myTracks.snapshot().done(function(snapshot) {
 *   var tracks = snapshot.toArray();
 *   tracks.forEach(doSomethingWithTrack);
 * });
 */Snapshot.prototype.toArray=function(){var array=[],col=this._collection;for(var i=0,l=this._uris.length;i<l;i++){array[i]=col._factory(this._uris[i],this._meta[i]);}return array;}; /**
 * Creates an array with all URIs of the items in the snapshot. Does not include
 * the empty slots in the snapshot, if any. In general, applications should not
 * need to work with URIs directly, but for applications that have their own
 * database of Spotify URIs mapped to their own data it might be useful. If the
 * application does not actually need the metadata of the items in the snapshot
 * it is better to call this method than toArray, to avoid creating a large
 * number of objects that are not needed.
 *
 * @since 1.2.0
 *
 * @return {Array.<string>} An array of URIs.
 */Snapshot.prototype.toURIs=function(){return this._uris.slice();}; /**
 * Never construct a track object using the default constructor - use fromURI()
 * instead.
 *
 * @class
 * @extends {module:api/models~MdL}
 * @classdesc The track represents a track on an album in the Spotify catalog.
 * @since 1.0.0
 *
 * @property {module:api/models~Album} album The album of the track.
 * @property {Array.<module:api/models~Artist>} artists The artists of the
 *     track.
 * @property {string} availability Describes how and when the track is
 *     available for playback for the currently logged in user. The value will
 *     be one of: "available", "banned", "regional", "premium" or
 *     "unavailable". "available" means that the track can be played, "banned"
 *     that the artist has chosen to not make the track available, "regional"
 *     that the track is playable in other regions but not in the region of the
 *     currently logged in user, "premium" means that this is premium only
 *     content and a premium account is needed in order to play the track (the
 *     playable property needs to be checked to actually see if the user can
 *     play it or not), and "unavailable" which means the track is unavailable
 *     for other reasons.
 * @property {number} disc For multi-disc albums, indicates which disc the
 *     track is on. The first disc is disc 1.
 * @property {number} duration The duration of the track, in milliseconds.
 * @property {boolean} explicit True if the track should be displayed with a
 *     label indicating that it contains explicit lyrics. May not be set in all
 *     regions.
 * @property {string} image The image URI for the track. The format of the
 *     image URI is platform dependent, but will always be something that can
 *     be used as the source of an img element or a background-image in CSS.
 *     The size of the image is not defined and might differ between platforms,
 *     so it is recommended that applications use the imageForSize method to
 *     get an appropriately sized image. In general, it's best to use the Image
 *     view from the views framework to display images - it will load the image
 *     in the background (while displaying a placeholder) and make sure to pick
 *     the correct size "intelligently", based on the current screen resolution
 *     and available bandwidth.
 * @property {string} name The name of the playlist. This is a human readable
 *     string that can be presented to the user. Make sure to call the proper
 *     string decoding method before using the string in the DOM.
 * @property {number} number The number of the track on the album/disc it
 *     belongs to. The first track is track 1, the second track is track 2 and
 *     so on. The track number count is reset for each new disc on the album,
 *     and hence the first track on disc two on a two disc album is also known
 *     as track number 1 (and so on, for every new disc on the album).
 * @property {boolean} playable Indicates if the track is playable by the
 *     currently logged in user. If the resource used to construct the track
 *     isn't readily available for playback, Spotify will automatically try to
 *     find another (equivalent) playable copy of the track. This implies that
 *     if this property is set to false, neither this copy or any other copy of
 *     this track (in the Spotify catalog) is playable for the currently logged
 *     in user. A track can be unplayable for various reasons, such as regional
 *     restrictions or play count restrictions in the free service.
 * @property {number} popularity The popularity rating of the track. This is a
 *     value between 0 and 100, inclusive, with 0 meaning a very impopular
 *     track and 100 a highly popular track.
 * @property {string} uri The URI of the playlist.
 *
 * @param {string} uri The URI of the track.
 *
 * @see module:api/models~MdL#imageForSize
 * @see String#decodeForText
 * @see String#decodeForHtml
 * @see String#decodeForLink
 * @see module:api/models~Track#fromURI
 */function Track(uri){MdL.call(this);this.resolve('uri',uri);}SP.inherit(Track,MdL);Loadable.define(Track,['uri']);Loadable.define(Track,['ad_metadata','advertisement','album','artists','availability','disc','duration','explicit','image','images', // Loaded when 'image' is loaded.
'local','name','number','placeholder','playable','popularity'],'_metadata');MdL.init(Track,'track'); /**
 * @private
 */Track.prototype._make_album=function(value){return value&&Album.fromURI(value.uri,value);}; /**
 * @private
 */Track.prototype._make_artists=function(value){return value&&value.map(_artists);}; /**
 * Returns the track for a given Spotify URI. The URI is the only property that
 * is loaded on the track immediately.
 *
 * @since 1.0.0
 *
 * @param {string} uri The Spotify URI of the track.
 * @return {module:api/models~Track} A track.
 *
 * @example
 * models.Track.fromURI('spotify:track:2M5nPOo9UmoQVOWrN8lfN1').load('name').done(function(track) {
 *   console.log(track.uri + ': ' + track.name.decodeForText());
 *   document.getElementById('track').innerHTML = track.name.decodeForHtml();
 * });
 */Track.fromURI=Cache.lookup; /**
 * Gets a list of tracks from a list of URIs.
 *
 * @since 1.3.0
 *
 * @param {Array.<string>} uris List of URIs.
 * @return {Array.<module:api/models~Track>} A list of tracks.
 */Track.fromURIs=Cache.lookupMany; /**
 * @private
 */Track._cache=new Cache(Track); /**
 * Stars the current track for the currently logged-in user.
 *
 * @since 1.0.0
 *
 * @return {module:api/models~Promise} A promise.
 *
 * @deprecated Use {@link module:api/models~Library#star} instead.
 *
 * @example
 * models.Track.fromURI('spotify:track:2M5nPOo9UmoQVOWrN8lfN1').star();
 */Track.prototype.star=function(){return promisedRequest(this,'library_star',[exports.session.user.uri,this.uri]);}; /**
 * Unstars the current track for the currently logged-in user.
 *
 * @since 1.0.0
 *
 * @return {module:api/models~Promise} A promise.
 *
 * @deprecated Use {@link module:api/library~Library#unstar} instead.
 *
 * @example
 * models.Track.fromURI('spotify:track:2M5nPOo9UmoQVOWrN8lfN1').unstar();
 */Track.prototype.unstar=function(){return promisedRequest(this,'library_unstar',[exports.session.user.uri,this.uri]);}; /**
 * Waits for any track change event.
 *
 * @since 1.16.1
 *
 * @private
 */Track._trackEventWait=function(){SP.request('track_event_wait_any',[],this,this._trackEventDone,this._trackEventFail);}; /**
 * @private
 */Track._trackEventDone=function(event){var track=Track.fromURI(event.data.uri);track.resolveMany(0,event.data);track.dispatchEvent(event);this._trackEventWait();}; /**
 * @private
 */Track._trackEventFail=function(error){if(error.error=='timeout')this._trackEventWait();}; /**
 * @class
 * @extends {module:api/models~MdL}
 * @classdesc The user objects represents a unique Spotify user.
 * @since 1.0.0
 *
 * @property {boolean} currentUser A boolean field that indicates whether or
 *     not the user represented by the object is the current session's user.
 * @property {string} identifier An identifier for the user that is unique to
 *     the application. This can be used to identify the currently logged in
 *     user and will not change, but it will be different for each application,
 *     so it cannot be used to track the user between different applications.
 *     This property is only set on the currently logged in user.
 * @property {string} image The image URI for the user's portrait image. This
 *     property may or may not be available, depending on the application's
 *     permissions. The format of the image URI is platform dependent, but will
 *     always be something that can be used as the source of an img element or
 *     a background-image in CSS. The size of the image is not defined and
 *     might differ between platforms, so it is recommended that applications
 *     use the imageForSize method to get an appropriately sized image. In
 *     general, it's best to use the Image view from the views framework to
 *     display images - it will load the image in the background (while
 *     displaying a placeholder) and make sure to pick the correct size
 *     "intelligently", based on the current screen resolution and available
 *     bandwidth.
 * @property {string} name The name of the user. This is a human readable
 *     string that can be presented to the user. Make sure to call the proper
 *     string decoding method before using the string in the DOM.
 * @property {string} uri The URI of the user.
 * @property {string} username The canonical username of the user. This name
 *     should not be presented to the user. Call decodeForText to get a pure
 *     string without escape characters.
 * @property {module:api/models~Artist} artist The artist that the user is
 *     associated to, if any exists. Otherwise null.
 *
 * @param {string} uri The URI of the user.
 *
 * @see module:api/models~MdL#imageForSize
 * @see String#decodeForText
 * @see String#decodeForHtml
 * @see String#decodeForLink
 */function User(uri){MdL.call(this);this.resolve('uri',uri);}SP.inherit(User,MdL);Loadable.define(User,['uri']);Loadable.define(User,['currentUser','identifier','image','images', // Loaded when 'image' is loaded.
'name','subscribed','username'],'_metadata');Loadable.define(User,['artist'],'_associatedArtist');MdL.init(User,'user'); /**
 * @private
 */User.prototype._associatedArtist=function(propsMask){var load=function load(data){this.resolveMany(propsMask,data);};var fail=function fail(oops){this.resolveFail(propsMask,oops);};SP.request('user_associated_artist',[this.uri],this,load,fail);}; /**
 * @private
 */User.prototype._make_artist=function(value){return value&&Artist.fromURI(value);}; /**
 * A bridge listener for relations events. This is only a proxy so to actually
 * handle the events, another bridge listener needs to receive the events using
 * the proxyTo method.
 *
 * @type {module:api/models~ProxyListener}
 *
 * @private
 */User._relationsListener=null; /**
 * Returns the user for a given Spotify URI. The URI is the only property that
 * is loaded on the user immediately.
 *
 * @since 1.0.0
 *
 * @param {string} uri The Spotify URI of the user.
 * @return {module:api/models~User} A user.
 *
 * @example
 * var user = models.User.fromURI('spotify:user:…');
 * user.load('username', 'name').done(function(user) {
 *   console.log(user.username + ': ' + user.name.decodeForText());
 *   document.getElementById('user').innerHTML = user.name.decodeForHtml();
 * });
 */User.fromURI=Cache.lookup; /**
 * Gets a list of users from a list of URIs.
 *
 * @since 1.3.0
 *
 * @param {Array.<string>} uris List of URIs.
 * @return {Array.<module:api/models~User>} A list of users.
 */User.fromURIs=Cache.lookupMany; /**
 * @private
 */User._cache=new Cache(User); /**
 * Returns the user for a given Spotify username. The URI is the only property
 * that is loaded on the user immediately.
 *
 * @since 1.1.0
 *
 * @param {string} username The canonical username of the user.
 * @return {module:api/models~User} A user.
 *
 * @example
 * var user = models.User.fromUsername('**freer!de**');
 * user.load('username', 'name').done(function(user) {
 *   console.log(user.username + ': ' + user.name.decodeForText());
 *   document.getElementById('user').innerHTML = user.name.decodeForHtml();
 * });
 */User.fromUsername=function(username){ // fromURI only accepts characters escaped with lower case hexadecimal.
var escaped=encodeURIComponent(username),i=-1;while((i=escaped.indexOf('%',i+1))>-1){escaped=escaped.substring(0,i+1)+escaped.substring(i+1,i+3).toLowerCase()+escaped.substring(i+3);}return User.fromURI('spotify:user:'+escaped);}; /**
 * Sets up (if needed) and returns a proxy listener for relation events.
 *
 * @return {module:api/models~ProxyListener} A proxy listener for relation
 *     events.
 */User.getOrCreateRelationsListener=function(){var listener=User._relationsListener;if(!listener){listener=new ProxyListener();listener.bridgeListen('relations_event_wait',[exports.session.user.uri]); // Apply a filter to relations events which will update cached User
// instances.
listener.filter(function(evt){if(evt.receiver!='subscriptions'||evt.type!='add'&&evt.type!='remove')return;User._cache.update(evt.uris,{subscribed:evt.type=='add'});});User._relationsListener=listener;}return listener;}; /**
 * @override
 */User.prototype.load=function(){var args=SP.varargs(arguments);if(Array.prototype.indexOf.call(args,'subscribed')>=0){ // Start listening for relation events if we ever load the subscribed
// property.
User.getOrCreateRelationsListener();}return User._superClass.load.apply(this,args);}; /**
 * Generic function for getting an instance that best represents the passed in
 * URI.
 *
 * Only use this function if you don't know what the URI type is, or if the URI
 * can be one of several different types.
 *
 * This function will only return instances of Album, Artist, Disc, Playlist,
 * Track, User or Collection.
 *
 * @since 1.3.0
 *
 * @param {string} uri The URI to get an instance for.
 * @param {Object=} opt_data Optional data to resolve the instance with. Note
 *     that this should only be used if the data was provided together with the
 *     URI.
 * @return {module:api/models~Loadable} An instance representing the provided
 *     URI, or null if the URI could not be understood.
 */var fromURI=function fromURI(uri,opt_data){var parts=uri.split(':');var result=null;switch(parts[1]){case 'album': // spotify:album:<id>:<disc>
if(parts.length==4)result=Disc.fromURI(uri,opt_data);else if(parts.length==3)result=Album.fromURI(uri,opt_data);break;case 'artist':if(parts.length==3)result=Artist.fromURI(uri,opt_data);break;case 'track':if(parts.length==3)result=Track.fromURI(uri,opt_data);break;case 'local':if(parts.length===6)result=Track.fromURI(uri,opt_data);else if(parts.length===4)result=Album.fromURI(uri,opt_data);else if(parts.length===3)result=Artist.fromURI(uri,opt_data);break;case 'user': // spotify:user:<username>:collection
if(parts.length>3&&parts[3]=='collection')return new BridgeCollection(Track,uri,'library_tracks'); // spotify:user:<username>:<playlist:<id>|toplist>
if(parts.length>3&&parts.length<=5&&parts[2]!='facebook')result=Playlist.fromURI(uri,opt_data);else if(parts.length==3)result=User.fromURI(uri,opt_data);break;}return result;}; /*
 * Start waiting for any incoming global playlist and track change events. This
 * is different from the regular playlist events in that the API does not know
 * what playlist it will get updates for and cannot control it in any way. The
 * use case for these events is to update the properties of the playlists (such
 * as allows.offlineSync) and tracks (such as .playable) even when no one is
 * currently observing them.
 */Playlist._playlistEventWait();Track._trackEventWait(); /*
 * Export all of the classes and instances that are available to users of this
 * module. We could set the classes at the top of the file, but the instance
 * must be created here at the bottom because they need the prototypes of the
 * classes to be set up before creating an object.
 */exports.Observable=Observable;exports.Loadable=Loadable;exports.BridgeLoadable=BridgeLoadable;exports.MdL=MdL;exports.Album=Album;exports.Application=Application;exports.Artist=Artist;exports.Cache=Cache;exports.Client=Client;exports.Collection=Collection;exports.BridgeCollection=BridgeCollection;exports.Context=Context;exports.Disc=Disc;exports.Group=Group;exports.ListDescriptor=ListDescriptor;exports.Playlist=Playlist;exports.Profile=Profile;exports.Promise=Promise;exports.Session=Session;exports.Track=Track;exports.User=User;exports.application=new Application();exports.client=new Client();exports.fromURI=fromURI;exports.promisedRequest=promisedRequest;exports.session=new Session();

},{}],44:[function(require,module,exports){
'use strict';

var hermes = require('../hermes');
var models = require('../models');

/**
 * Temporary implementation of artist relations, pending bridge support.
 *
 * @since 1.20.0
 *
 * @exports api/artistrelations
 *
 * @private
 */

/**
 * Enum of ways to change subscription status.
 *
 * @enum {number}
 */
var Relationship = {
  NOT_SUBSCRIBED: 0,
  SUBSCRIBED: 1
};

var ARTIST_GRAPH_ROOT = 'hm://socialgraph/';
var ARTIST_GRAPH_SUBSCRIPTIONS = ARTIST_GRAPH_ROOT + 'subscriptions/artist';
var ARTIST_GRAPH_SUBSCRIBERS = ARTIST_GRAPH_ROOT + 'subscribers/artist';
var COMBINED_GRAPH_SUBSCRIPTIONS = ARTIST_GRAPH_ROOT + 'subscriptions/combined';

// The Hermes schema for socialgraph requests.
var _schema = hermes.Schema.fromURL('proto/socialgraph.proto');

/**
 * Returns the artist subscriptions for a user.
 *
 * @since 1.20.0
 *
 * @param {string=} opt_userUri A user URI. If blank, the current user is used.
 * @param {module:api/models~Promise} A promise resolving to a list of artist
 *    objects.
 */
function artistSubscriptions(opt_userUri) {
  var promise = new models.Promise();

  var canonicalUsername = opt_userUri ? _trimUri('user', opt_userUri) : '';
  if (canonicalUsername == '@') canonicalUsername = '';

  var requestPromise = _request('GET', ARTIST_GRAPH_SUBSCRIPTIONS + '/' + canonicalUsername, 'ArtistListReply', 'UserListRequest', { include_length: true });
  requestPromise.done(function (data) {
    var response = [],
        result = data[0].artists || [];
    for (var i = 0, len = result.length; i < len; i++) {
      response.push(models.Artist.fromURI('spotify:artist:' + result[i].artistid));
    }
    promise.setDone(response);
  }).fail(function (_, error) {
    promise.setFail(error);
  });

  return promise;
}

/**
 * Takes a list of artist and user uris and returns three separate lists, one
 * of users and one of artists. For artists, it returns the user instead if
 * the artist has been merged. It also returns a list of merged artist and
 * user URI's to allow for cache invalidation.
 *
 * @since 1.20.0
 *
 * @param {Array.<string>} uris List of URIs.
 * @return {module:api/models~Promise} A promise that will resolve into an
 *     object containing the properties "userUris", "artistUris" and
 *     "mergedUris".
 */
function categorizeUsersAndArtists(uris) {
  var artistUris = [],
      userUris = [],
      artistUriSet = {},
      userUriSet = {},
      mergedUriSet = {};

  // Split up artists and users into different lists of URIs.
  for (var i = 0, len = uris.length; i < len; i++) {
    var uri = uris[i];

    if (uri.indexOf('spotify:artist:') === 0) {
      // Artists are not added to the set here because we don't yet know if
      // they're merged or not.
      artistUris.push(uri);
    } else {
      userUriSet[uri] = true;
      userUris.push(uri);
    }
  }

  var promises;

  // Resolve the "user" connection for all user URIs.
  promises = models.Artist.fromURIs(artistUris).map(function (artist) {
    return artist.load('user');
  });

  var artistsPromise = models.Promise.join(promises);
  artistsPromise.each(function (artist) {
    if (artist.user) {
      userUriSet[artist.user.uri] = true;
      mergedUriSet[artist.uri] = true;
    } else {
      artistUriSet[artist.uri] = true;
    }
  });

  // Resolve the "artist" connection for all user URIs.
  promises = models.User.fromURIs(userUris).map(function (user) {
    return user.load('artist');
  });

  var usersPromise = models.Promise.join(promises);
  usersPromise.each(function (user) {
    if (user.artist) {
      mergedUriSet[user.artist.uri] = true;
    }
  });

  var promise = new models.Promise();

  // Combine everything into an object with lists of user, artist and merged
  // URIs.
  models.Promise.join(artistsPromise, usersPromise).always(function () {
    promise.setDone({
      artistUris: Object.keys(artistUriSet),
      userUris: Object.keys(userUriSet),
      mergedUris: Object.keys(mergedUriSet)
    });
  });

  return promise;
}

/**
 * Subscribes or unsubscribes the current user from a set of artists.
 *
 * @since 1.20.0
 *
 * @param {Array.<string>} artistUris A list of artist URIs.
 * @param {Relationship} relationship What the relationship should be changed
 *     to.
 * @return {module:api/models~Promise} A promise for the request.
 */
function changeRelation(artistUris, relationship) {
  if (artistUris.length === 0) {
    var promise = new models.Promise();
    promise.setDone();
    return promise;
  }

  var method = relationship === Relationship.SUBSCRIBED ? 'POST' : 'DELETE';
  var promise = _request(method, ARTIST_GRAPH_SUBSCRIPTIONS, 'StringListReply', 'StringListRequest', { args: artistUris.map(_trimArtistUri) });
  promise.done(this, function () {
    models.Artist._cache.update(artistUris, { subscribed: relationship === Relationship.SUBSCRIBED });
  });
  return promise;
}

/**
 * Returns the total number of subscriptions for a user.
 *
 * @since 1.20.0
 *
 * @param {string} userUri A user URI.
 * @return {module:api/models~Promise} A promise resolving to a subscriber
 *     count.
 */
function combinedSubscriptionCount(userUri) {
  var canonicalUsername = _trimUri('user', userUri);
  var username;

  var usernamePromise;
  if (canonicalUsername === '@') {
    // The URI is for the current user, but censored, so we need to request
    // the actual username.
    usernamePromise = models.session.user.load('username').done(function (user) {
      username = user.username;
    }).fail(function (_, error) {
      usernamePromise.setFail(error);
    });
  } else {
    username = decodeURIComponent(canonicalUsername);

    // Instantly resolve the promise since we know the username already.
    usernamePromise = new models.Promise();
    usernamePromise.setDone();
  }

  var promise = new models.Promise();
  usernamePromise.done(function () {
    _batchRequest('combinedSubscriptionCount', username, promise);
  });
  return promise;
}

/**
 * Called when the user subscribe is done so that we update the merged artist
 * caches as well.
 *
 * @since 1.20.0
 *
 * @param {Array.<string>} artistUris An array of artist URIs to update.
 * @param {Relationship} relationship What the relationship should be changed
 *     to.
 */
function updateCache(artistUris, relationship) {
  models.Artist._cache.update(artistUris, { subscribed: relationship === Relationship.SUBSCRIBED });
}

/**
 * Looks up if the current user is subscribed to the artist or not.
 * <p>
 * Performs batching to look up all artist URIs in a runloop in one go.
 *
 * @since 1.20.0
 *
 * @param {string} artistUri An artist URI.
 * @return {module:api/models~Promise} A promise resolving to a boolean
 *    of the subscription status.
 */
function isSubscribed(artistUri) {
  return _batchRequest('isSubscribed', _trimArtistUri(artistUri));
}

/**
 * Returns the subscriber count for an artist.
 *
 * @since 1.20.0
 *
 * @param {string} artistUri An artist URI.
 * @return {module:api/models~Promise} A promise resolving to the number of
 *     subscribers the artist has.
 */
function subscriberCount(artistUri) {
  return _batchRequest('subscriberCount', _trimArtistUri(artistUri));
}

/**
 * A map of batchable requests.
 *
 * @private
 */
var _batchable = {
  combinedSubscriptionCount: function combinedSubscriptionCount(values, promises) {
    return _request('GET', COMBINED_GRAPH_SUBSCRIPTIONS + '/count', 'CountReply', 'StringListRequest', { args: values }).done(function (frames) {
      var counts = frames[0].counts;
      for (var i = 0, len = counts.length; i < len; i++) {
        promises[i].setDone(counts[i]);
      }
    });
  },

  isSubscribed: function isSubscribed(values, promises) {
    return _request('GET', ARTIST_GRAPH_SUBSCRIPTIONS + '/exists', 'StringListReply', 'StringListRequest', { args: values }).done(function (frames) {
      var subscribed = frames[0].reply;
      for (var i = 0, len = subscribed.length; i < len; i++) {
        promises[i].setDone(subscribed[i] == 'True');
      }
    });
  },

  subscriberCount: function subscriberCount(values, promises) {
    return _request('GET', ARTIST_GRAPH_SUBSCRIBERS + '/count', 'CountReply', 'StringListRequest', { args: values }).done(function (frames) {
      var counts = frames[0].counts;
      for (var i = 0, len = counts.length; i < len; i++) {
        promises[i].setDone(counts[i]);
      }
    });
  }
};

/**
 * A set of requests batched in this runloop.
 *
 * @private
 */
var _batch = {};

/**
 * Whether the batch call has been deferred yet in this runloop.
 *
 * @private
 */
var _batchDeferred = false;

/**
 * Adds a request to be batched.
 *
 * @since 1.20.0
 *
 * @private
 */
function _batchRequest(request, value, opt_promise) {
  if (!opt_promise) {
    opt_promise = new models.Promise();
  }

  if (_batch[request]) {
    _batch[request].values.push(value);
    _batch[request].promises.push(opt_promise);
  } else {
    _batch[request] = { values: [value], promises: [opt_promise] };
  }

  if (!_batchDeferred) {
    SP.defer(null, _runBatchedRequests);
    _batchDeferred = true;
  }

  return opt_promise;
}

/**
 * Performs a Hermes query.
 *
 * @since 1.20.0
 *
 * @private
 */
function _request(method, url, opt_replyType, opt_requestType, var_args) {
  var request = hermes.Hermes.request(method, url, opt_replyType ? [_schema.type(opt_replyType)] : [], opt_requestType ? [_schema.type(opt_requestType)] : []);
  return request.send.apply(request, SP.varargs(arguments, 4));
}

/**
 * Runs the set of batched requests.
 *
 * @since 1.20.0
 *
 * @private
 */
function _runBatchedRequests() {
  if (_batchDeferred) {
    _batchDeferred = false;
  }

  for (var request in _batch) {
    var promise = _batchable[request](_batch[request].values, _batch[request].promises);
    promise.fail(_batch[request], function (_, error) {
      for (var i = 0, len = this.promises.length; i < len; i++) {
        this.promises[i].setFail(error);
      }
    });
  }

  _batch = {};
}

function _trimArtistUri(artistUri) {
  return _trimUri('artist', artistUri);
}

function _trimUri(prefix, uri) {
  var prefix = 'spotify:' + prefix,
      idx = uri.indexOf(prefix);
  return idx >= 0 ? uri.substr(idx + prefix.length + 1) : uri;
}

exports.Relationship = Relationship;
exports.artistSubscriptions = artistSubscriptions;
exports.categorizeUsersAndArtists = categorizeUsersAndArtists;
exports.changeRelation = changeRelation;
exports.combinedSubscriptionCount = combinedSubscriptionCount;
exports.updateCache = updateCache;
exports.isSubscribed = isSubscribed;
exports.subscriberCount = subscriberCount;

},{"../hermes":41,"../models":43}],45:[function(require,module,exports){
'use strict';

var models = require('./models');
var relationsartist = require('./private/relationsartist');

/**
 * Functionality for handling the relationships between users and artists.
 *
 * @exports api/relations
 * @since 1.0.0
 *
 * @example
 * require(['./relations#Relations'], function(Relations) {
 *   var rels = Relations.forCurrentUser();
 *   rels.subscribers.snapshot(0, 10).done(function(snapshot) {
 *     console.log('You have a total of', snapshot.length, 'follower(s).');
 *     console.log('Here are the first 10:', snapshot.toArray());
 *   });
 * });
 */

/**
 * Request combined subscriptions from the backend.
 *
 * @since 1.20.0
 *
 * @this {module:api/models~Collection}
 *
 * @param {module:api/models~ListDescriptor} descriptor A descriptor
 *     describing the list which is being snapshotted.
 * @param {number} offset Offset into the snapshot.
 * @param {number} length The length of the snapshot.
 * @param {boolean} raw Whether the data should be raw (no metadata).
 * @return {module:api/models~Promise} A promise.
 *
 * @private
 */
function _combinedSubscriptionsSnapshot(descriptor, offset, length, raw) {
  var promises = [];

  var base = descriptor.getBase();
  if (base.type != models.ListDescriptor.Types.LIST) {
    throw new Error('Unexpected descriptor: ' + base.type);
  }

  var uri = base.uri;

  if (length != 0) {
    var allSubscriptionsPromise = models.Promise.join([relationsartist.artistSubscriptions(uri), Relations.forUser(models.User.fromURI(uri)).subscriptions.snapshot()]);

    var itemsPromise = new models.Promise();

    allSubscriptionsPromise.done(function (results) {
      var artistUris = results[0].map(function (artist) {
        return artist.uri;
      });
      var userUris = results[1].toURIs();

      var uris = artistUris.concat(userUris);
      relationsartist.categorizeUsersAndArtists(uris).done(function (result) {
        itemsPromise.setDone(result);
      }).fail(function (_, error) {
        itemsPromise.setFail(error);
      });
    });

    allSubscriptionsPromise.fail(function (_, error) {
      itemsPromise.setFail(error);
    });

    promises.push(itemsPromise);
  }

  var countPromise = relationsartist.combinedSubscriptionCount(uri);
  promises.push(countPromise);

  var resultPromise = new models.Promise();
  models.Promise.join(promises).done(function () {
    var result = { array: [] };

    if (length != 0) {
      result.metadata = [];

      var i,
          items = itemsPromise.object;

      for (i = 0; i < items.artistUris.length; i++) {
        var artistUri = items.artistUris[i];

        if (items.mergedUris.indexOf(artistUri) >= 0) continue;

        result.array.push(artistUri);
        result.metadata.push({
          artist: artistUri,
          user: null
        });
      }

      for (i = 0; i < items.userUris.length; i++) {
        // This user has to be in the cache due to how the relationsartist
        // module works.
        var user = models.User.fromURI(items.userUris[i]);
        if (user.artist) {
          result.array.unshift(user.uri);
          result.metadata.unshift({ artist: user.artist.uri, user: user.uri });
        } else {
          result.array.push(user.uri);
          result.metadata.push({ artist: null, user: user.uri });
        }
      }

      if (offset || length > -1) {
        // A snapshot length of -1 means "as many as possible".
        var end = offset + (length > -1 ? length : result.array.length);
        result.array = result.array.slice(offset, end);
        result.metadata = result.metadata.slice(offset, end);
      }
    }

    result.length = countPromise.object;

    resultPromise.setDone(result);
  }).fail(function (_, error) {
    resultPromise.setFail(error);
  });

  return resultPromise;
}

/**
 * Never construct a relations object using the default constructor; instead,
 * use forCurrentUser() or forUser(user).
 *
 * @class
 * @extends {module:api/models~BridgeLoadable}
 * @classdesc Represent a user's relations.
 * @since 1.0.0
 *
 * @property {module:api/models~User} owner The user whom the relations
 *     belong to.
 * @property {module:api/models~Collection} subscribers A collection of users
 *     subscribing to the user.
 * @property {module:api/models~Collection} subscriptions A collection of
 *     users the user is subscribing to.
 * @property {module:api/models~Collection} combinedSubscriptions A
 *     collection of the combination of artists and users the user is
 *     subscribing to.
 *
 * @param {string} uri A URI that represents this set of relations. This
 *     URI will match the user URI.
 */
function Relations(uri) {
  models.BridgeLoadable.call(this);

  var owner = models.User.fromURI(uri);

  this.resolve('owner', owner);
  this.resolve('subscribers', new models.BridgeCollection(models.User, null, 'relations_subscribers_users', owner.uri));
  this.resolve('subscriptions', new models.BridgeCollection(models.User, null, 'relations_subscriptions_users', owner.uri));
  this.resolve('combinedSubscriptions', new models.Collection(models.Profile, null, _combinedSubscriptionsSnapshot, owner.uri));
}
SP.inherit(Relations, models.BridgeLoadable);

/**
 * Gets a relations object based on a URI.
 *
 * @param {string} uri A user URI to get the relations object for.
 * @return {module:api/relations~Relations} A relations object.
 */
Relations.fromURI = models.Cache.lookup;
Relations._cache = new models.Cache(Relations);

models.Loadable.define(Relations, ['owner', 'subscribers', 'subscriptions', 'combinedSubscriptions']);

/**
 * Never construct a relations object using the default constructor; instead,
 * use forCurrentUser() or forUser(user) on the Relations class.
 *
 * @class
 * @extends {module:api/relations~Relations}
 * @classdesc Represent the current user's relations.
 * @since 1.0.0
 *
 * @property {module:api/models~User} owner The user whom the relations
 *     belong to.
 * @property {module:api/models~Collection} subscribers A collection of users
 *     subscribing to the user.
 * @property {module:api/models~Collection} subscriptions A collection of
 *     users the user is subscribing to. Supports listening for events "add"
 *     and "remove".
 *
 * @param {string} uri A URI that represents this set of relations. This
 *     URI will match the user URI.
 *
 * @see module:api/relations~Relations
 *
 * @example
 * var rels = Relations.forCurrentUser();
 * rels.subscribe(models.User.fromURI(…));
 */
function CurrentUserRelations(uri) {
  Relations.call(this, uri);

  models.User.getOrCreateRelationsListener().proxyTo(this);
}
SP.inherit(CurrentUserRelations, Relations);

/**
 * A reference to the CurrentUserRelations instance that represents the
 * relations for the current user.
 *
 * @type {module:api/relations~CurrentUserRelations}
 *
 * @private
 */
Relations._currentUser = null;

/**
 * Gets the relations for the current user.
 *
 * @since 1.0.0
 *
 * @return {module:api/relations~CurrentUserRelations} An object that
 *     represents the relations of the currently logged in user.
 */
Relations.forCurrentUser = function () {
  if (!Relations._currentUser) {
    Relations._currentUser = new CurrentUserRelations(models.session.user.uri);
  }
  return Relations._currentUser;
};

/**
 * Gets the relations for a user.
 *
 * @since 1.0.0
 *
 * @param {module:api/models~User} user The user whose relations object to
 *     return.
 * @return {module:api/relations~Relations} An object that represents the
 *     relations of the provided user.
 */
Relations.forUser = function (user) {
  return Relations.fromURI(user.uri);
};

// Monkey patch a subscribed property onto the models.Artist class.
models.Loadable.define(models.Artist, ['subscribed'], '_relations__temp_patch');

models.Artist.prototype._relations__temp_patch = function (propsMask) {
  relationsartist.isSubscribed(this.uri).done(this, function (subscribed) {
    this.resolveMany(propsMask, { subscribed: subscribed });
  }).fail(this, function () {
    this.resolveFail(propsMask, { error: 'Cannot load subscribed property' });
  });
};

// Keep track of user subscriptions and update merged artists.
function _userRelationChangeHandler(evt) {
  for (var i = 0; i < evt.uris.length; i++) {
    models.User.fromURI(evt.uris[i]).load('artist').done(function (user) {
      if (!user.artist) return;
      user.artist.resolve('subscribed', evt.type == 'add');
    });
  }

  // Simulate a bridge event by using BridgeLoadable#eventDone.
  Relations.forCurrentUser().eventDone({
    type: evt.type,
    receiver: 'combinedSubscriptions',
    uris: evt.uris
  });
}

var subs = Relations.forCurrentUser().subscriptions;
subs.addEventListener('add', _userRelationChangeHandler);
subs.addEventListener('remove', _userRelationChangeHandler);

exports.Relations = Relations;

},{"./models":43,"./private/relationsartist":44}],46:[function(require,module,exports){
'use strict';

var SpotifyApi = require('./core');

(function () {
  SpotifyApi.prototype._throwError = true;

  var bridge = window._getSpotifyModule('bridge');

  var core;
  /* In CEF3 the core module will be unavailable, thus producing an error. */
  try {
    core = window._getSpotifyModule('core');
  } catch (err) {}

  /**
   * Override the request creation routine with one that reads files using the
   * native C++ readFile() function, if available.
   */
  if (core) SpotifyApi.prototype._createRequest = function (module, callback) {
    // Run asynchronously to mirror the behaviour of other platforms
    this.defer(this, function () {
      var code = core.readFile(module);
      if (undefined === code) {
        throw new Error('Could not load module "' + module + '"; Not found.');
      } else {
        callback(code);
      }
    });
  };

  /**
   * Makes a request to a native function.
   */
  SpotifyApi.prototype.request = function (name, args, caller, success, failed) {
    var contextId = this._getContextIdForRequest();
    var message = JSON.stringify({ name: name, args: args, context: contextId });
    bridge.executeRequest(message, {
      onSuccess: function onSuccess(data) {
        if (success) {
          success.call(caller, JSON.parse(data));
        }
      },
      onFailure: function onFailure(data) {
        data = JSON.parse(data);
        if (failed) {
          failed.call(caller, data);
        }
      }
    });
    this._prepareFlush(name);
  };

  SpotifyApi.api = new SpotifyApi();
  SpotifyApi.api.container = 'desktop';
})();

},{"./core":47}],47:[function(require,module,exports){
'use strict';

/**
 * Core functionality of the Spotify API.
 *
 * @module api/core
 * @ignore
 */

/**
 * @namespace
 * @ignore
 */
var spotify = {};

/*
 * The Spotify API entry point. Only one instance of this class can exist.
 * Applications never directly use this class (expect for that it actually
 * implements the "require" functionality). Frameworks use this class to make
 * requests over the Stitch bridge. Each platform must make a subclass of this
 * class to implement the request communication.
 */

/**
 * This class should never be instantiated by the user; an instance will be
 * available to all imported module under the variable <code>SP</code>.
 *
 * @class
 * @classdesc This class deals with core Spotify API functionality.
 *     <p>
 *     An instance of this class is available in all imported modules under the
 *     variable <code>SP</code>.
 * @since 1.0.0
 * @ignore
 */
function SpotifyApi() {
  this._modules = {};
  this._requested = {};
  this._moduleQueue = [];
  this._delayedFns = [];
  this._parallelReqs = 4;
  this._contextStack = [];
  this._deferredFlush = false;
  this._useLoadingTimeout = false;
  this._patchRequestOpen();
}

module.exports = SpotifyApi;

/**
 * Never construct an AnalyticsContext using the constructor - use the
 * SP.analyticsContext() convenience function instead.
 *
 * @class
 * @classdesc An analytics context can be used to group activity inside of an
 *     application so it can be tracked as a single logical entity.  All API
 *     requests executed when a given context is active will be tagged with the
 *     context id so they can be assigned to the context on the other side of
 *     the bridge. AnalyticsContexts can handle asyncronous callbacks and may
 *     be nested arbitrarily deep.
 * @since 1.6.0
 * @ignore
 *
 * @param {string} name A human readable name for the context.
 *
 * @see module:api/core~SpotifyApi#analyticsContext
 */
SpotifyApi.AnalyticsContext = function (name) {
  this.name = name;
  this.id = SpotifyApi.AnalyticsContext._nextId++;
  this.references = 0;
  this._begin();
};
SpotifyApi.AnalyticsContext._nextId = 1;

/**
 * Add a reference to the context: indicates that there is an outstanding
 * promise that was created in the context.
 */
SpotifyApi.AnalyticsContext.prototype.addReference = function () {
  this.references++;
};

/**
 * Remove a reference to the context: indicates that a promise that was created
 * in the context has been fullfilled.
 */
SpotifyApi.AnalyticsContext.prototype.removeReference = function () {
  this.references--;
  if (this.references === 0) {
    this._end();
  }
};

/**
 * Called when a context is first created: sends a message over the bridge with
 * the context details.
 *
 * @private
 */
SpotifyApi.AnalyticsContext.prototype._begin = function () {
  SpotifyApi.api.request('core_context_begin', [this.id, this.name], this);
};

/**
 * Called when there are no more references to the context: sends a message
 * over the bridge with the context details.
 *
 * @private
 */
SpotifyApi.AnalyticsContext.prototype._end = function () {
  SpotifyApi.api.request('core_context_end', [this.id], this);
};

/**
 * Execute a function in an analytics context.
 *
 * @param {string} name A human readable name to identify the context.
 * @param {Function} func A function to invoke in the context.
 *
 * @example
 * SP.analyticsContext('load-playlist-view', function() {
 *   // do lots of complex loading and nested calls here
 * });
 */
SpotifyApi.prototype.analyticsContext = function (name, func) {
  var context = new SpotifyApi.AnalyticsContext(name);
  context.addReference();
  this._contextStack.push(context);
  try {
    func();
  } finally {
    this._contextStack.pop();
    context.removeReference();
  }
};

/**
 * Never construct a Callback using the constructor - use the SP.callback()
 * convenience function instead.
 *
 * @class
 * @classdesc A callback class that captures a context stack on instantiation
 *     and restores it on invocation.
 * @since 1.7.0
 * @ignore
 *
 * @param {Function} func The function to wrap.
 * @param {Array=} opt_contextStack A context stack to capture. If a stack is
 *     not provided, this defaults to the current context stack.
 *
 * @see module:api/core~SpotifyApi#callback
 * @see module:api/core~SpotifyApi#analyticsContext
 */
SpotifyApi.Callback = function (func, opt_contextStack) {
  this._func = func;
  this._setContextStack(opt_contextStack || SpotifyApi.api._contextStack);
};

/**
 * TODO: Documentation needed.
 *
 * @param {*} context The context to apply to the callback function.
 * @param {Array} args The arguments to apply to the callback function.
 */
SpotifyApi.Callback.prototype.apply = function (context, args) {
  try {
    var oldContextStack = SpotifyApi.api._contextStack;
    SpotifyApi.api._contextStack = this._contextStack;
    this._func.apply(context, args);
  } catch (error) {
    setTimeout(function () {
      throw error;
    }, 0);
  } finally {
    SpotifyApi.api._contextStack = oldContextStack;
    this.clear();
  }
};

/**
 * TODO: Documentation needed.
 *
 * @param {*} context The context to apply to the callback function.
 * @param {...*} var_args The arguments to apply to the callback function.
 */
SpotifyApi.Callback.prototype.call = function (context, var_args) {
  this.apply(context, Array.prototype.slice.call(arguments, 1));
};

/**
 * Creates a copy of the callback instance, incrementing the context stack
 * reference count.
 */
SpotifyApi.Callback.prototype.copy = function () {
  return new this.constructor(this._func, this._contextStack);
};

/**
 * Clear the callback, releasing the context stack: calling it after this will
 * cause an exception to be thrown.
 *
 * Note: If your callback will never be invoked, be sure to call clear to
 * ensure proper cleanup of the instance.
 */
SpotifyApi.Callback.prototype.clear = function () {
  this._releaseContextStack();
  delete this._func;
  delete this._contextStack;
};

/**
 * Set the context stack that should be restored when the callback is invoked.
 *
 * @private
 *
 * @see module:api/core~SpotifyApi.Callback#invoke
 */
SpotifyApi.Callback.prototype._setContextStack = function (contextStack) {
  for (var i = 0, l = contextStack.length; i < l; ++i) {
    contextStack[i].addReference();
  }
  this._contextStack = contextStack.slice(0);
};

/**
 * Remove our reference to each item in the stored context stack.
 *
 * @private
 */
SpotifyApi.Callback.prototype._releaseContextStack = function () {
  var contextStack = this._contextStack;
  for (var i = 0, l = contextStack.length; i < l; ++i) {
    contextStack[l - i - 1].removeReference();
  }
};

/**
 * Return a callback object that when invoked will restore the analytics
 * context stack that was active at the time the callback was created.
 *
 * @param {Function} func The function to wrap.
 * @return {module:api/core~SpotifyApi.Callback} A callback object.
 */
SpotifyApi.prototype.callback = function (func) {
  return new SpotifyApi.Callback(func);
};

/**
 * Return the analytics context id to send over the bridge for the next
 * request.
 *
 * @return {number} The context id.
 *
 * @private
 */
SpotifyApi.prototype._getContextIdForRequest = function () {
  var contexts = this._contextStack;
  return contexts.length ? contexts[contexts.length - 1].id : 0;
};

/**
 * Process the message that are posted to the window to handle the zero-delay
 * timeout system. When calling the delay function a message will be posted to
 * the window and processed in this event handler. It just goes through all
 * registered delayed invocations and calls them in order. Note that the array
 * must be copied first, because the callback could end up putting more stuff
 * on it, which must not run until the _next_ runloop iteration.
 */
window.addEventListener('message', function (event) {
  if (event.source == window && event.data == 'api-delay') {
    event.stopPropagation();
    var functions = SpotifyApi.api._delayedFns.splice(0);
    for (var i = 0, l = functions.length; i < l; i++) {
      functions[i].call();
    }
  }
});

/**
 * All subclasses' implementations of the request method must call this method.
 * It does not matter if it is called in the beginning or end of the request
 * method since the action is deferred until the beginning of the next runloop
 * iteration.
 *
 * @param {string} name The name of the request.
 *
 * @private
 */
SpotifyApi.prototype._prepareFlush = function (name) {
  if (!this._deferredFlush && name != 'core_flush') {
    this._deferredFlush = true;
    this.defer(this, this._flushRequests);
  }
};

/**
 * Sends the "bridge_flush" request across the bridge, indicating that now is
 * a good time to execute any batch jobs that have been building up because of
 * incoming requests. The implementation is free to execute requests right away
 * or wait until this flush request is sent.
 *
 * @private
 */
SpotifyApi.prototype._flushRequests = function () {
  this._deferredFlush = false;
  this.request('core_flush', []);
};

/**
 * Call this function to perform a function as soon as possible, but in the next
 * run loop iteration at the earliest. It is faster than calling setTimeout with
 * a zero timeout argument, since most browsers will artificially increase the
 * timeout to 15 milliseconds (plus/minus a few milliseconds).
 *
 * @param {Object} self The this instance to use in the callback.
 * @param {Function} func The function to call in the next runloop iteration.
 */
SpotifyApi.prototype.defer = function (self, func) {
  if (this._delayedFns.push(this.bind(this.callback(func), self)) == 1) window.postMessage('api-delay', '*');
};

/**
 * Used by require to evaluate the JavaScript module source code. Note that the
 * code in the module will be interpreted in strict JavaScript mode, to ensure
 * that it does not make some common coding mistakes, and it also enables some
 * additional optimizations by the compiler.
 *
 * @param {Object} meta The module's meta object.
 * @param {Array} graph An array containing the object's dependency graph.
 * @param {string} module The module path.
 * @param {string} code The source code of the module.
 * @return {Object} The exported namespace of the module.
 *
 * @private
 */
SpotifyApi.prototype._evalModule = function (meta, graph, module, code) {
  return !/\.lang$/.test(module) ? this._evalJSModule(meta, graph, module, code) : this._evalLangModule(module, code);
};

SpotifyApi.prototype._evalJSModule = function (meta, graph, module, code) {
  var self = this;
  var exports = { __name: module };
  var require = function require(modules, fn) {
    exports.__waiting = true; // require was called inside the module
    var callback = function callback() {
      exports.__waiting = false;
      return fn.apply(this, arguments);
    };
    callback.__native = true;
    return self._require(module, meta, graph, modules, callback);
  };
  try {
    code = '\'use strict\';' + code + '\n//@ sourceURL=' + module;
    new Function('require', 'exports', 'SP', '_code', 'eval(_code)').call({}, require, exports, this, code);
    return exports;
  } catch (error) {
    error.message += ' in ' + module;
    throw error;
  }
};

/**
 * A module containing localized strings.
 * <p>
 * To use string modules, make sure that you have a "SupportedLanguages" key in
 * your manifest, the value of which should be an array of strings
 * corresponding to the languages you support:
 *
 * <pre>
 * {
 *   …
 *   "SupportedLanguages": ["de", "en", "es"],
 *   …
 * }
 * </pre>
 *
 * Second, create locale-directories for each of the languages you support in
 * the root of your application. Inside each of these directories should be
 * another directory called "strings," which will contain the language string
 * files:
 *
 * <pre>
 * $ tree ~/Spotify/my-app
 * ~/Spotify/my-app/
 * ├── de.loc
 * │   └── strings
 * ├── en.loc
 * │   └── strings
 * ├── es.loc
 * │   └── strings
 * ├── index.html
 * ├── manifest.json
 * └── scripts
 *     └── main.js
 *
 * 7 directories, 3 files
 * </pre>
 *
 * You're then ready to add your strings via .lang files. A Lang file is a JSON
 * document containing key-value pairs of identifiers and their corresponding
 * locale strings. Here's an example .lang file:
 *
 * <pre>
 * $ < ~/Spotify/my-app/en.loc/strings/main.lang
 * {
 *   "greeting": "Hello and Welcome!",
 *   "personal-greeting": "Hello {0}, and Welcome!"
 * }
 * </pre>
 *
 * The lang file above is for the en locale, and we'll need corresponding ones
 * for other supported locales as well. Your final directory structure should
 * look similar to this:
 *
 * <pre>
 * $ tree ~/Spotify/my-app
 * ~/Spotify/my-app/
 * ├── de.loc
 * │   └── strings
 * │       └── main.lang
 * ├── en.loc
 * │   └── strings
 * │       └── main.lang
 * ├── es.loc
 * │   └── strings
 * │       └── main.lang
 * ├── index.html
 * ├── manifest.json
 * └── scripts
 *     └── main.js
 *
 * 7 directories, 6 files
 * </pre>
 *
 * Now that you have your files set up, you can then add locale support to your
 * apps. As mentioned above, lang files are imported using the same require()
 * function that we use for importing modules. To import a locale, you simply
 * import strings/<name of the file>.lang:
 *
 * <pre>
 * require('strings/main.lang', function(mainStrings) {
 *   …
 * });
 * </pre>
 *
 * It is important to notice that we did not specify the locale folder to use
 * when requiring the file. This is because the client will automatically
 * resolve the path to the proper string file for the locale. If the above
 * snippet is run in a client using en, then it will import
 * en.loc/strings/main.lang, and the same for other supported languages.
 * <p>
 * NB! As of the moment, only two-character language codes work. However, this
 * is a limitation of the hosting client, not the locale implementation.
 * Support for extended language codes will automatically appear once the
 * hosting clients support them.
 * <p>
 * When your locale strings have been imported, require() will then invoke your
 * callback with an object of the following interface:
 *
 * <pre>
 * interface StringsGetter : Object {
 *   string get(string key [, interface {} interpolatedValue1 … interpolatedValueN]);
 * }
 * </pre>
 *
 * You can then use this object to get the strings from your file, as well as
 * do simple string interpolation (see the example section).
 *
 * @class
 *
 * @property {Object.<string, string>} A map of string ids to translated
 *     strings.
 *
 * @example
 * require('strings/main.lang', function(mainStrings) {
 *   // Returns 'Hello and Welcome!'
 *   mainStrings.get('greeting');
 *
 *   // Returns 'Hello Mark, and Welcome!'
 *   mainStrings.get('personal-greeting', 'Mark');
 *
 *   // Non-existent key, returns 'non-existent'
 *   mainStrings.get('non-existent');
 *
 *   // Non-existent key, returns 'non-existent but still interpolated'
 *   mainStrings.get('non-existent but still {0}', 'interpolated');
 * });
 */
SpotifyApi.LangModule = function (name, strings) {
  this.__name = name;
  this.strings = strings;
};

/**
 * Gets a string from the language module. This function supports substitution
 * of parameters ("{0}" will be replaced with the first additional argument to
 * this method).
 *
 * @param {string} key The key to use when looking up the string. If the string
 *     does not exist, the key will be used as the string instead.
 * @param {...*} var_args Substitution values to use for the string.
 * @return {string} The localized, formatted string.
 */
SpotifyApi.LangModule.prototype.get = function (key, var_args) {
  var format = this.strings.hasOwnProperty(key) ? this.strings[key] : key;

  // Scan the format string for placeholders ("{0}", etc.) and substitute them
  // with the provided arguments.
  var out = '',
      lastIndex = 0,
      startIndex,
      endIndex;
  while ((startIndex = format.indexOf('{', lastIndex)) > -1) {
    endIndex = format.indexOf('}', startIndex + 1);
    // Stop parsing if we can't find a closing curly brace.
    if (endIndex == -1) {
      break;
    }

    // Get the substitution value from the arguments.
    var value = arguments[parseInt(format.substring(startIndex + 1, endIndex)) + 1];
    if (value !== undefined) {
      out += format.substring(lastIndex, startIndex) + value;
    } else {
      // Just leave the placeholder untouched if there is no value.
      out += format.substring(lastIndex, endIndex + 1);
    }

    lastIndex = endIndex + 1;
  }

  return lastIndex ? out + format.substring(lastIndex) : format;
};

/**
 * Evaluates a language module, which is basically just a JSON file. The module
 * that is returned will also have a "get" function which lets people load a
 * localized string with formatting.
 *
 * @param {string} module Name of the module.
 * @param {string} code The JSON data of the module.
 * @return {Object} The exported members of the module.
 *
 * @private
 */
SpotifyApi.prototype._evalLangModule = function (module, code) {
  try {
    return new SpotifyApi.LangModule(module, JSON.parse(code));
  } catch (error) {
    throw new Error('Cannot import language file "' + module + '": ' + error.message);
  }
};

/**
 * Fires a require callback after all of dependencies have finished loading.
 *
 * @param {Object} meta The metadata node to start at.
 *
 * @private
 */
SpotifyApi.prototype._fireCallbacks = function (meta) {
  while (meta) {
    meta.waiting--;
    if (meta.waiting) break;
    meta.unpacked.forEach(function (unpacked) {
      var pos = unpacked.position;
      var exported = meta.args[pos];
      var property = unpacked.property;
      if (!(property in exported)) throw new Error('No "' + property + '" exported in module "' + exported.__name + '"');
      meta.args[pos] = exported[property];
    });
    meta.callback.apply({}, meta.args);
    meta.waiting = 1 / 0; // Infinity
    meta = meta.parent;
  }
};

/**
 * Asynchronously loads a file at a given path. Basically just a
 * handy wrapper around XMLHttpRequest. Will throw an error if
 * the path is not found, or if the request times out.
 *
 * @param  {String}   path     The path to the file.
 * @param  {Function} callback A callback function that handles
 *                             one argument - the body of the file.
 *
 * @private
 *
 */
SpotifyApi.prototype._createRequest = function (path, callback) {
  var request, timeoutMS, xmlHttpTimeout, timedOut;

  request = new XMLHttpRequest();
  request.open('GET', path, true);

  request.onreadystatechange = function () {
    var isDone, iOSHack, isOK;
    isDone = request.readyState === 4;

    if (isDone) {
      clearTimeout(xmlHttpTimeout);

      if (timedOut) {
        throw new Error('Could not load file "' + path + '"; Timed out.');
      }

      // FIXME: Originally the 0 status code for success was for our
      // implementation of Stitch on iOS 4. This is probably not needed
      // anymore, but please test on both iOS 5 and iOS 6 before removing.
      iOSHack = request.status === 0 && !!request.responseText;
      isOK = request.status === 200 || iOSHack;

      if (!isOK) {
        throw new Error('Could not load file "' + path + '"; Not found.');
      }

      callback(request.responseText);
    }
  };

  if (this._useLoadingTimeout) {
    timeoutMS = 1500;
    xmlHttpTimeout = setTimeout(function () {
      timedOut = true;
      request.abort();
    }, timeoutMS);
  }

  request.send(null);
};

/**
 * Loads the executable code of a module via XHR or from the cache.
 *
 * @private
 */
SpotifyApi.prototype._loadModule = function (meta, graph, module, position, property) {
  var self = this;

  var cached = this._modules[module];
  if (cached && !cached.__waiting) {
    meta.args[position] = this._modules[module];
    if (property) meta.unpacked.push({ property: property, position: position });
    this._fireCallbacks(meta);
  } else if (this._requested[module] || !this._parallelReqs) {
    this.defer(this, function () {
      this._loadModule(meta, graph, module, position, property);
    });
  } else {
    this._requested[module] = true;
    this._parallelReqs--;
    this._createRequest(module, function (responseText) {
      self._parallelReqs++;
      var exported = self._modules[module] = self._evalModule(meta, graph, module, responseText);
      meta.args[position] = exported;
      if (property) meta.unpacked.push({ property: property, position: position });
      self._fireCallbacks(meta);
    });
  }
};

/**
 * Resolves any path-related "magic" for a module's require path.
 *
 * @private
 */
SpotifyApi.prototype._resolveModule = function (module) {
  if (!/\.lang$/.test(module)) {
    var _module = module.match(/^(\$(?:[^\/]+)\/)(?!scripts)(.*)/);
    if (_module) module = _module[1] + 'scripts/' + _module[2];
    module += '.js';
  }
  return module;
};

/**
 * Import a module of the Spotify API by specifying the module path as:
 * $framework/module, e.g., $api/models. Store the returned object in a
 * variable of your own choice. The object represents the namespace of the
 * module. You can also use this method to import your own modules, included in
 * the bundle, by passing a relative module path.
 *
 * @param {string} name The module name.
 * @param {Object} parent The meta object of the modules' parent.
 * @param {Array.<string>} graph The dependency graph of the modules.
 * @param {string|Array.<string>} modules The paths of the modules to require.
 * @param {Function} fn The callback function to call when the modules have
 *     been loaded.
 * @return {Object} The module namespace.
 *
 * @private
 */
SpotifyApi.prototype._require = function (name, parent, graph, modules, fn) {
  if (typeof modules == 'string') modules = [modules];
  if (!modules || !modules.length) throw new Error('Missing modules argument to require().');
  if (!fn || typeof fn != 'function') throw new Error('Missing callback function argument to require().');

  var len = modules.length;

  var meta = {
    name: name,
    parent: parent,
    waiting: len,
    callback: fn,
    args: new Array(len),
    unpacked: []
  };

  parent.waiting++;

  for (var i = 0, l = len; i < l; i++) {
    var module = modules[i];
    if (!module) throw new Error('Empty module name in require.');

    // Property unpacking.
    var property = module.split('#');
    module = this._resolveModule(property[0]);
    property = property[1];

    // Dependency checking.
    var modGraph = graph.slice(0);
    var index = graph.indexOf(module);
    modGraph.push(module);
    if (index != -1) {
      modGraph = modGraph.slice(index).join(' -> ');
      throw new Error('Circular Dependency on Module "' + module + '": ' + modGraph);
    }

    this._loadModule(meta, modGraph, module, i, property);
  }
};

/**
 * This function will take an array of parameters (usually from the 'arguments'
 * keyword), and expect it to contain a single array of values, or a variable-
 * length list of values, starting at the specified offset (default 0). This is
 * used to implement methods such as Loadable.load and Promise.join.
 *
 * @since 1.1.0
 *
 * @param {Arguments|Array} values An arguments object or an array to get the
 *     list of values from.
 * @param {number=} opt_offset An offset to start expecting variable arguments
 *     at. For example, if a function always takes one argument plus a list of
 *     values (which can either be a single array or many arguments), you would
 *     pass in an offset of 1. Default is 0.
 * @param {boolean=} opt_copy Force this function to return a copy of the list
 *     so that the return value is safe to retain and/or change.
 * @return {Arguments|Array} Either the arguments object or an array. Unless a
 *     copy of the value list is explicitly requested, the existing list will
 *     be returned when possible (for performance reasons), so do not attempt
 *     to modify the returned value in any way unless asking for it to be
 *     copied.
 *
 * @example
 * function printList(title) {
 *   // Get the items with an offset of 1 (ignoring title).
 *   var items = SP.varargs(arguments, 1);
 *
 *   var html = '&lt;h1&gt;' + title + '&lt;/h1&gt;&lt;ul&gt;';
 *   for (var i = 0; i < items.length; i++) {
 *     html += '&lt;li&gt;' + items[i] + '&lt;/li&gt;';
 *   }
 *   document.write(html + '&lt;/ul&gt;');
 * }
 *
 * // This will work...
 * printList('Numbers', ['one', 'two', 'three']);
 *
 * // ...and so will this.
 * printList('Numbers', 'four', 'five', 'six');
 */
SpotifyApi.prototype.varargs = function (values, opt_offset, opt_copy) {
  if (!opt_offset) opt_offset = 0;

  if (Array.isArray(values[opt_offset])) {
    if (values.length > opt_offset + 1) throw new Error('Ambiguous use of varargs');
    values = values[opt_offset];
    opt_offset = 0;
  }

  return opt_offset || opt_copy ? Array.prototype.slice.call(values, opt_offset) : values;
};

/**
 * Gets a list of URIs from the provided arguments object or array.
 *
 * @since 1.1.0
 *
 * @param {Arguments|Array} values An arguments object or an array to get the
 *     list of URIs from. It is expected to hold objects with a "uri" property.
 * @param {number=} opt_offset An offset to start expecting variable arguments
 *     at. For example, if a function always takes one argument plus a list of
 *     values (which can either be a single array or many arguments), you would
 *     pass in an offset of 1. Default is 0.
 * @return {Array.<string>} A list containing the URIs of the provided objects.
 *
 * @see module:api/core~SpotifyApi#varargs
 */
SpotifyApi.prototype.uris = function (values, opt_offset) {
  var objs = this.varargs(values, opt_offset),
      uris = [];
  for (var i = 0, len = objs.length; i < len; i++) {
    uris.push(objs[i].uri);
  }
  return uris;
};

/**
 * Binds a function to a specific this object. This is a simpler version of the
 * bind method of the Function class, which is not available on all platforms.
 *
 * @since 1.4.0
 *
 * @param {Function} func A function to bind.
 * @param {Object} that The this object to use when invoking the returned
 *     function.
 * @param {...*} var_args Additional arguments to pass into the function before
 *     any arguments passed to the new, bound version of the function.
 * @return {Function} A new function that will invoke the given function.
 */
SpotifyApi.prototype.bind = function (func, that, var_args) {
  if (arguments.length > 2) {
    var slice = Array.prototype.slice;
    var bind = Function.prototype.bind;
    if (bind && func.bind === bind) return bind.apply(func, slice.call(arguments, 1));
    var args = slice.call(arguments, 2);
    return function () {
      return func.apply(that, arguments.length ? args.concat(slice.call(arguments)) : args);
    };
  } else {
    return function () {
      return func.apply(that, arguments);
    };
  }
};

/**
 * Inherit the prototype methods from one constructor into another.
 *
 * @param {Function} childConstructor Child class.
 * @param {Function} parentConstructor Parent class.
 *
 * @example
 * function ParentClass(a, b) { }
 * ParentClass.prototype.foo = function(a) { }
 *
 * function ChildClass(a, b, c) {
 *   ParentClass.call(this, a, b);
 * }
 * SP.inherit(ChildClass, ParentClass);
 *
 * var child = new ChildClass('a', 'b', 'see');
 * child.foo(); // works
 *
 * // In addition, a superclass' implementation of a method can be invoked as
 * // as follows:
 *
 * ChildClass.prototype.foo = function(a) {
 *   ChildClass._superClass.foo.call(this, a);
 *   // other code
 * };
 */
SpotifyApi.prototype.inherit = function (childConstructor, parentConstructor) {
  var TempConstructor = function TempConstructor() {};

  TempConstructor.prototype = childConstructor._superClass = parentConstructor.prototype;
  childConstructor.prototype = new TempConstructor();
  childConstructor.prototype.constructor = childConstructor;
  return childConstructor;
};

/**
 * Patches XMLHttpRequest.prototype.open to add a custom Spotify header.
 * Only applies to same-domain requests.
 * <p>
 * This allows us to mark requests sent from applications, to avoid
 * injecting our tags into files that aren't the source of the webpage.
 *
 * @private
 */
SpotifyApi.prototype._patchRequestOpen = function () {
  var open = XMLHttpRequest.prototype.open;

  /*
   * When a <base> element is present in the head, the browser will
   * interpret local urls as they were joined to the base href.
   * A link element allows us to avoid checking for the base element
   * specifically, as the href property of a link is always the result
   * of the browser interpretation of that link.
   * A link also allows us to use the handy protocol and hostname properties
   * without having to use a regexp to match them.
   */
  var link = document.createElement('a');
  var location = window.location;

  XMLHttpRequest.prototype.open = function (method, url) {
    var result = open.apply(this, arguments);
    link.href = url;

    /**
     * In internet explorer 9, an <a> element might have the protocol property set to ":" and an empty hostname property
     * which means those properties are the same as the document base url, therefore we treat them as local
     */
    if (link.protocol == ':' && !link.hostname || link.protocol == location.protocol && link.hostname == location.hostname) {
      this.setRequestHeader('X-Spotify-Requested-With', 'XMLHttpRequest');
    }
    return result;
  };
};

/**
 * Resolve a path to something that can be included with an HTML tag
 */
SpotifyApi.prototype.resolvePath = function (path) {
  return path;
};

/**
 * Import a module of the Spotify API by specifying the module path as:
 * $framework/module, e.g., $api/models. Store the returned object in a variable
 * of your own choice. The object represents the namespace of the module. You
 * can also use this method to import your own modules, included in the bundle,
 * by passing a relative module path. Note that the code in the module will be
 * interpreted in strict JavaScript mode, to ensure that it does not make some
 * common coding mistakes, and it also enables some additional optimizations by
 * the compiler.
 *
 * @global
 * @since 1.0.0
 *
 * @param {Array.<string>} modules The module paths.
 * @param {Function} callback The function that will be called once all
 *     required modules have been loaded, including the modules that the
 *     required modules themselves depend on.
 *
 * @example
 * require(['scripts/newsfeed', '$api/models'], function(newsfeed, models) {
 *   var player = models.player;
 *   player.playTrack(models.Track.fromURI('spotify:track:2GIyi2hpXSAlMgjEfmd0oF'));
 * });
 */
function _require(modules, callback) {
  return SpotifyApi.api._require('__main__', {
    callback: function callback() {},
    waiting: 1 / 0 // Infinity
  }, [], modules, callback);
}
spotify.require = _require;

/**
 * @class String
 * @classdesc The built-in String class.
 * @global
 */
String;

/**
 * Before using any string returned from the Spotify API, call this method to
 * decode it to a usable string. Note that this method must only be used for
 * cases where the string will never end up being interpreted as HTML (such as
 * when using it in an innerHTML attribute). In that case, the decodeForHtml
 * method should be used instead.
 *
 * @name String#decodeForText
 * @return {string} A string without any escaped characters.
 * @since 1.0.0
 *
 * @see String#decodeForHtml
 * @see String#decodeForLink
 *
 * @example
 * document.getElementById('name').innerText = album.name.decodeForText();
 */
String.prototype.decodeForText = function () {
  return this.toString();
};

/**
 * Before using any string returned from the Spotify API in the DOM in a way
 * such that the string might be interpreted as HTML, such as setting the
 * innerHTML attribute of a node. Note that the recommendation is that the
 * application does not use innerHTML, because it is easy to accidentally
 * introduce dangerous behavior.
 *
 * @name String#decodeForHtml
 * @return {string} An escaped string that does not contain any HTML code.
 * @since 1.0.0
 *
 * @see String#decodeForText
 * @see String#decodeForLink
 *
 * @example
 * document.getElementById('name').innerHTML = track.name.decodeForHtml();
 */
String.prototype.decodeForHtml = function () {
  var e = { '&': '&amp;', '<': '&lt;', '>': '&gt;' };
  var r = function r(c) {
    return e[c];
  };
  return function () {
    return this.replace(/[&<>]/g, r);
  };
}();

/**
 * Before using a URL string returned from the Spotify API in HTML code that
 * constructs links, use this method to decode it into a string that is escaped
 * for links. Note that it is not recommended to build HTML directly using
 * strings. It is better to construct nodes and set the link URL attributes
 * instead. This way there is less chance of introducing dangerous behavior.
 *
 * @name String#decodeForLink
 * @return {string} A URL escaped string.
 * @since 1.0.0
 *
 * @see String#decodeForText
 * @see String#decodeForHtml
 *
 * @example
 * div.innerHTML = '&lt;a href="' + artist.uri.decodeForLink() + '"&gt;Artist&lt;/a&gt;';
 */
String.prototype.decodeForLink = function () {
  return encodeURI(this);
};

/**
 * URI and URL Bases used for toSpotifyURL, toSpotifyURI and toSpotifyLink
 * methods.
 */
SpotifyApi.Bases = {
  uri: 'spotify',
  url: 'http://open.spotify.com'
};

/**
 * Regular expressions used for toSpotifyURL, toSpotifyURI and toSpotifyLink
 * methods.
 */
SpotifyApi.Exps = {
  spotify: /^spotify:(.+)$/,
  http: /^https?:\/\/(play|open)\.spotify\.com\/(.+)$/
};

/**
 * Converts a string Spotify URI to a Spotify URL.
 *
 * @name String#toSpotifyURL
 * @return {String} a string containing a Spotiy URI.
 * @since 1.0.0
 *
 * @see String#toSpotifyURI
 * @see String#toSpotifyLink
 */
String.prototype.toSpotifyURL = function () {
  var matches = this.match(SpotifyApi.Exps.spotify);
  if (!matches) return this;
  var parts = matches.pop().replace(/:$/, '').split(/:/);
  var type = parts.shift();
  if (type == 'search') parts = [parts.join(':')];
  parts.unshift(SpotifyApi.Bases.url, type);
  return parts.join('/');
};

/**
 * Converts a string Spotify URL to a Spotify URI.
 *
 * @name String#toSpotifyURI
 * @return {String} a string containing a Spotiy URL.
 * @since 1.0.0
 *
 * @see String#toSpotifyURL
 * @see String#toSpotifyLink
 */
String.prototype.toSpotifyURI = function () {
  var matches = this.match(SpotifyApi.Exps.http);
  if (!matches) return this;
  var parts = matches.pop().replace(/\/$/, '').split(/\//);
  parts.unshift(SpotifyApi.Bases.uri);
  return parts.join(':');
};

/**
 * Converts a string Spotify URL or Spotify URI to the
 * platform's default type.
 *
 * @name String#toSpotifyLink
 * @return {String} a string containing a Spotiy URL or URL.
 * @since 1.0.0
 *
 * @see String#toSpotifyURL
 * @see String#toSpotifyURI
 */
String.prototype.toSpotifyLink = function () {
  return this.toSpotifyURI();
};

},{}],48:[function(require,module,exports){
'use strict';

var SpotifyApi = require('./client/core');

// This decorates SpotifyApi with monkey patch methods.
require('./client/core.desktop');

// Some apps / libs expect SP.bind, SP.inherits SP.request to be accessible.
// Examples include api/scripts/models.
window.SP = SpotifyApi.api;

exports.SpotifyApi = SpotifyApi;
exports.SP = SpotifyApi.api;
// exports.LangModule = SpotifyApi.LangModule;

},{"./client/core":47,"./client/core.desktop":46}],49:[function(require,module,exports){
'use strict';

// Base function that doesn't have any dependencies on it's own. Expects to get
// state (a plain, empty object) injected in addition to a bridge request
// function.
function cosmosRequest(state, bridge, opts, callback) {

  if (typeof opts.uri !== 'string') throw new Error('Expected uri to be string.');

  if (COSMOS_VERBS.indexOf(opts.method) === -1) throw new Error('Method must match valid verb in uppercase (GET, POST etc)');

  if (opts.body && typeof opts.body !== 'string') throw new Error('If body is provided it should be a string.');

  if (opts.headers && Object.prototype.toString.call(opts.headers) !== '[object Object]') throw new Error('Expected headers be a plain object.');

  var cosmosOptions = {
    action: opts.method,
    uri: opts.uri
  };
  if (opts.body) cosmosOptions.body = opts.body;
  if (opts.headers) cosmosOptions.headers = opts.headers;

  /* Cosmos requires each request to have a unique ID. Ideally, this would be
  uuids, but unfortunately, it is integers. This means that in apps that for
  some reason need to use spotify-cosmos-api, there would between the two
  counters if cosmosRequest started from 0. To make it safe for the two
  implemenations to co-exist if needed, we begin counting at
  significantly higher number: */
  state.requestIDCounter = state.requestIDCounter || TEN_PER_SECOND_FOR_A_YEAR;
  state.requestIDCounter++;

  var requestArguments = [state.requestIDCounter, cosmosOptions];

  var isCanceled = false;
  var stateRequestIDCounter = state.requestIDCounter;

  function cancelFunction() {
    isCanceled = true;
    bridge('cosmos_request_cancel', [stateRequestIDCounter]);
  }

  // run is a recursive function that does a bridge request and then keeps
  // pulling values after every response in the case of a subscription. In
  // case we are not subscribing, or the cancelFunction has been called,
  // run sends cosmos_request_cancel and terminates.
  function run(isFirst, requestIDCounter) {
    var messageName = isFirst ? 'cosmos_request_create' : 'cosmos_request_pull';
    bridge(messageName, requestArguments, function (error, responseString) {
      // The request to cancel may not have gotten to the bridge
      // before the original request got resolved,
      // so make sure not to continue if we detect it's been canceled.
      if (isCanceled) {
        return;
      }
      try {
        if (callback) {
          if (error) {
            callback(error);
          } else {
            callback(null, responseString);
          }
        }
      } finally {
        if (opts.method !== 'SUB') {
          // If the request was a non-SUB, tell core to clean up the request.
          // NOTE: Not sure if this is strictly necessary,
          // have not been to investigate in C++-land, so for now
          // we are just mimicing the behavior of spotify-cosmos-api.
          bridge('cosmos_request_cancel', [requestIDCounter]);
        } else if (!isCanceled) {
          // maybe canceled in above callback
          run(false, requestIDCounter);
        }
      }
    });
  }

  run(true, stateRequestIDCounter);

  return cancelFunction;
}

var TEN_PER_SECOND_FOR_A_YEAR = 10 * 60 * 60 * 24 * 365;

var COSMOS_VERBS = ['GET', 'HEAD', 'POST', 'PUT', 'SUB', 'PATCH', 'DELETE'];

module.exports = cosmosRequest;

},{}],50:[function(require,module,exports){
(function (global){
'use strict';

var debug = require('debug')('spotify-bridge-request');
var defer = require('spotify-deferred');

var cosmosBaseFunction = require('./cosmos');

// NOTE: Implicit global state.
var scheduledCoreFlush = false;
var cosmosState = null;

exports.cosmos = cosmos;
exports.cosmosJSON = cosmosJSON;
exports.request = request;
exports._request = _request;

function cosmos() {
  if (!cosmosState) cosmosState = {};

  var baseArguments = [cosmosState, request];
  var cancelFunction = cosmosBaseFunction.apply(null, baseArguments.concat(Array.prototype.slice.call(arguments)));
  return cancelFunction;
}

function _createCallbackWrapper(callback) {
  return function callbackWrapper(err, response) {
    if (!err) {
      var parsedResponse;
      try {
        parsedResponse = JSON.parse(response.body);
      } catch (e) {
        e.message = 'Failed to parse cosmos response: ' + e.message;
        callback(e);
        return;
      }
      callback(null, parsedResponse);
    } else {
      callback(err, response);
    }
  };
}

function cosmosJSON(opts, callback) {
  if (opts.body) {
    opts.body = JSON.stringify(opts.body);
  }
  var callbackWrapper = callback ? _createCallbackWrapper(callback) : null;
  var cancelFunction = cosmos(opts, callbackWrapper);
  return cancelFunction;
}

function request(name, opt_args, opt_callback) {
  var args = opt_args || [];
  var callback = getCallback(name, args, opt_callback);

  debug('req:' + name, args);

  exports._request(name, args, callback);

  if (name !== 'core_flush' && !scheduledCoreFlush) {
    scheduledCoreFlush = true;
    defer(flushCore);
  }

  return exports;
}

function _request(name, args, callback) {
  global._getSpotifyModule('bridge').executeRequest(JSON.stringify({
    name: name,
    args: args
  }), {
    onSuccess: getSuccessHandler(callback),
    onFailure: getFailureHandler(callback, name, args)
  });
}

function getCallback(name, args, opt_userCallback) {
  var userCallback = opt_userCallback || function () {};

  return function (error, data) {
    if (error) {
      if (error.name === 'timeout') {
        // Set the delay between 300ms and 400ms
        var delay = 300 + Math.floor(Math.random() * 100);

        debug('timeout', error.message);

        // Retry the request
        setTimeout(function () {
          request(name, args, userCallback);
        }, delay);
        return;
      }
    }

    debug('res:' + name, args, data);

    userCallback(error, data);
  };
}

function getSuccessHandler(requestCallback) {
  return function (data) {
    var parsed;

    debug('success', data);

    try {
      parsed = JSON.parse(data);
    } catch (error) {
      requestCallback(error);
    }

    if (parsed) {
      requestCallback(null, parsed);
    }
  };
}

function getFailureHandler(requestCallback, name, args) {
  return function (data) {
    var parsed;

    debug('failure', data);

    try {
      parsed = JSON.parse(data);
    } catch (error) {
      requestCallback(error);
    }

    if (parsed) {
      requestCallback(createError(name, args, parsed));
    }
  };
}

function createError(name, args, response) {
  var argsString = JSON.stringify(args);
  var debug = ' (bridge message: \'' + name + '\', args: ' + argsString + ')';
  var msg = response.message + debug;
  var error = new Error(msg);
  error.name = response.error;

  return error;
}

function flushCore() {
  scheduledCoreFlush = false;
  request('core_flush');
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./cosmos":49,"debug":147,"spotify-deferred":238}],51:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var ClientEvent3 = require('../spotify-logger/messages/ClientEvent3');

var EVENTS = {
  // User (primary)
  USER_IMPRESSION: 'user:impression',
  USER_HIT: 'user:hit',
  // User (secondary - only use if neccesary)
  USER_SELECT: 'user:select',
  USER_HOVER: 'user:hover',
  USER_HOLD_TIMER: 'user:hold',

  // Info
  INFO_TIMER_DEFAULT: 'info:timer',
  INFO_STATE_LOAD_TIMER: 'info:state_load_timer',
  INFO_DEFAULT: 'info:default',
  INFO_WARN: 'info:warn',

  // Error
  ERROR_DEFAULT: 'error:default',
  ERROR_USER_ACTION_FAIL: 'error:user_action_fail',
  ERROR_RENDER_FAIL: 'error:render_fail'
};

var mixin = function mixin(base, addition) {
  var prop;
  for (prop in addition) {
    if (!base[prop]) {
      base[prop] = addition[prop];
    }
  }
};

/**
 * @class Logger Constructor
 * @param {Function} optBridgeRequest used mostly for testing
 */
function Logger() {
  this.timers = {};
}

/**
 * Filters out the data that should be specific fields in the schema
 * @param {object} obj - the mutated data obj
 * @param {object} extraData - the additional data in the log
 */
Logger.prototype._filterSchemaData = function (obj, extraData) {
  ClientEvent3.schema.fields.forEach(function (field) {
    if (extraData[field.name]) {
      obj[field.name] = extraData[field.name];
      delete extraData[field.name];
    }
  });
};

/**
 * Adds the remaining jsonData to the object
 * and overrides existing values
 * @param {object} obj - object that will be mutated
 * @param {object} jsonData
 */
Logger.prototype._addJsonData = function (obj, jsonData) {
  if (obj.json_data) {
    // Override the existing keys
    Object.keys(jsonData).forEach(function (key) {
      obj.json_data[key] = jsonData[key];
    });
  } else {
    obj.json_data = jsonData;
  }
};

/**
 * Builds ordered data array for backend consumption
 * @param {string} event Must be one of CLIENT_EVENT_NAMES or null.
 * @param {string|array} logData
 * @private
 * @return {array}
 */
Logger.prototype._buildBackendData = function (event, logData) {
  var data = {
    source_vendor: 'com.spotify',
    event: event
  };
  var extra;

  if (!logData.length) {
    throw new Error('Need some data to log!');
  }

  if (this.constant) {
    mixin(data, this.constant);
  }

  if (logData.length === 1) {
    if (typeof logData[0] === 'string') {
      data.event_version = logData[0];
      return data;
    } else if (_typeof(logData[0]) === 'object') {
      extra = logData[0];
    } else {
      throw new Error(event + ' must log either an object literal or a string');
    }
  } else {
    // support for the old logging style
    // might not even be needed -- should investigate
    data.event_version = logData[0];
    data.context = logData[2];
    extra = logData[1] || {};
  }

  this._filterSchemaData(data, extra);
  this._addJsonData(data, extra);

  return data;
};

/**
 * Internal log function: sends log to backend.
 * @param {array} backendData
 * @private
 */
Logger.prototype._log = function (backendData) {
  ClientEvent3.log(backendData);
};

// Public Methods

/**
 * All Log Methods
 *
 * @function
 * @param {...strings} optional number of arguments
 * @param {string|object} logData - can have the following key/values
 *        event_version, context, target_uri, name, section
 *        plus any number of optional key/values
 * Example: logger.userHit({
 *           event_version: 'play_button',
 *           context: 'recommended_stations',
 *           target_uri: 'spotify:genre:rock',
 *           name: 'Rock Genre Station'
 *           section: 'Carousel',
 *           customField: 'hello'
 *        });
 * @public
 */

Logger.prototype.userImpression = function () {
  var args = Array.prototype.slice.call(arguments, 0);
  this._log(this._buildBackendData(EVENTS.USER_IMPRESSION, args));
};
Logger.prototype.userHit = function () {
  var args = Array.prototype.slice.call(arguments, 0);
  this._log(this._buildBackendData(EVENTS.USER_HIT, args));
};
Logger.prototype.userSelect = function () {
  var args = Array.prototype.slice.call(arguments, 0);
  this._log(this._buildBackendData(EVENTS.USER_SELECT, args));
};
Logger.prototype.userHover = function () {
  var args = Array.prototype.slice.call(arguments, 0);
  this._log(this._buildBackendData(EVENTS.USER_HOVER, args));
};
Logger.prototype.userHold = function () {
  var args = Array.prototype.slice.call(arguments, 0);
  this._log(this._buildBackendData(EVENTS.USER_HOLD_TIMER, args));
};
Logger.prototype.info = function () {
  var args = Array.prototype.slice.call(arguments, 0);
  this._log(this._buildBackendData(EVENTS.INFO_DEFAULT, args));
};
Logger.prototype.infoWarn = function () {
  var args = Array.prototype.slice.call(arguments, 0);
  this._log(this._buildBackendData(EVENTS.INFO_WARN, args));
};
Logger.prototype.infoStageLoadTimer = function () {
  var args = Array.prototype.slice.call(arguments, 0);
  this._log(this._buildBackendData(EVENTS.INFO_STATE_LOAD_TIMER, args));
};
Logger.prototype.infoTimer = function () {
  var args = Array.prototype.slice.call(arguments, 0);
  this._log(this._buildBackendData(EVENTS.INFO_TIMER_DEFAULT, args));
};
Logger.prototype.error = function () {
  var args = Array.prototype.slice.call(arguments, 0);
  this._log(this._buildBackendData(EVENTS.ERROR_DEFAULT, args));
};
Logger.prototype.errorUserActionFail = function () {
  var args = Array.prototype.slice.call(arguments, 0);
  this._log(this._buildBackendData(EVENTS.ERROR_USER_ACTION_FAIL, args));
};
Logger.prototype.errorRenderFail = function () {
  var args = Array.prototype.slice.call(arguments, 0);
  this._log(this._buildBackendData(EVENTS.ERROR_RENDER_FAIL, args));
};
Logger.prototype.createTimer = function (eventVersion, optKey) {
  var key = eventVersion + (optKey || '');

  this.timers[key] = {
    startTime: Date.now(),
    eventVersion: eventVersion
  };

  return key;
};
Logger.prototype.logTimer = function (key, optData) {
  var timer = this.timers[key];
  var data = optData ? optData : {};

  if (!timer) {
    throw new Error('LogTimer: No record of a timer with key: ' + key);
  }
  data.event_version = timer.eventVersion;
  data.duration = Date.now() - timer.startTime;

  this._log(this._buildBackendData(EVENTS.INFO_TIMER_DEFAULT, [data]));
};

/**
 * @function
 * @param (object) - constant
 * add some data to go into every log event e.g. { featureName: featureValue };
 */

Logger.prototype.setConstant = function (constant) {
  if ((typeof constant === 'undefined' ? 'undefined' : _typeof(constant)) !== 'object') return;
  this.constant = constant;
};
module.exports = Logger;

},{"../spotify-logger/messages/ClientEvent3":118}],52:[function(require,module,exports){
/*
attributes
*/"use strict";

var $ = require("./base");

var trim = require("mout/string/trim"),
    forEach = require("mout/array/forEach"),
    filter = require("mout/array/filter"),
    indexOf = require("mout/array/indexOf");

// attributes

$.implement({

    setAttribute: function setAttribute(name, value) {
        return this.forEach(function (node) {
            node.setAttribute(name, value);
        });
    },

    getAttribute: function getAttribute(name) {
        var attr = this[0].getAttributeNode(name);
        return attr && attr.specified ? attr.value : null;
    },

    hasAttribute: function hasAttribute(name) {
        var node = this[0];
        if (node.hasAttribute) return node.hasAttribute(name);
        var attr = node.getAttributeNode(name);
        return !!(attr && attr.specified);
    },

    removeAttribute: function removeAttribute(name) {
        return this.forEach(function (node) {
            var attr = node.getAttributeNode(name);
            if (attr) node.removeAttributeNode(attr);
        });
    }

});

var accessors = {};

forEach(["type", "value", "name", "href", "title", "id"], function (name) {

    accessors[name] = function (value) {
        return value !== undefined ? this.forEach(function (node) {
            node[name] = value;
        }) : this[0][name];
    };
});

// booleans

forEach(["checked", "disabled", "selected"], function (name) {

    accessors[name] = function (value) {
        return value !== undefined ? this.forEach(function (node) {
            node[name] = !!value;
        }) : !!this[0][name];
    };
});

// className

var classes = function classes(className) {
    var classNames = trim(className).replace(/\s+/g, " ").split(" "),
        uniques = {};

    return filter(classNames, function (className) {
        if (className !== "" && !uniques[className]) return uniques[className] = className;
    }).sort();
};

accessors.className = function (className) {
    return className !== undefined ? this.forEach(function (node) {
        node.className = classes(className).join(" ");
    }) : classes(this[0].className).join(" ");
};

// attribute

$.implement({

    attribute: function attribute(name, value) {
        var accessor = accessors[name];
        if (accessor) return accessor.call(this, value);
        if (value != null) return this.setAttribute(name, value);
        if (value === null) return this.removeAttribute(name);
        if (value === undefined) return this.getAttribute(name);
    }

});

$.implement(accessors);

// shortcuts

$.implement({

    check: function check() {
        return this.checked(true);
    },

    uncheck: function uncheck() {
        return this.checked(false);
    },

    disable: function disable() {
        return this.disabled(true);
    },

    enable: function enable() {
        return this.disabled(false);
    },

    select: function select() {
        return this.selected(true);
    },

    deselect: function deselect() {
        return this.selected(false);
    }

});

// classNames, has / add / remove Class

$.implement({

    classNames: function classNames() {
        return classes(this[0].className);
    },

    hasClass: function hasClass(className) {
        return indexOf(this.classNames(), className) > -1;
    },

    addClass: function addClass(className) {
        return this.forEach(function (node) {
            var nodeClassName = node.className;
            var classNames = classes(nodeClassName + " " + className).join(" ");
            if (nodeClassName !== classNames) node.className = classNames;
        });
    },

    removeClass: function removeClass(className) {
        return this.forEach(function (node) {
            var classNames = classes(node.className);
            forEach(classes(className), function (className) {
                var index = indexOf(classNames, className);
                if (index > -1) classNames.splice(index, 1);
            });
            node.className = classNames.join(" ");
        });
    },

    toggleClass: function toggleClass(className, force) {
        var add = force !== undefined ? force : !this.hasClass(className);
        if (add) this.addClass(className);else this.removeClass(className);
        return !!add;
    }

});

// toString

$.prototype.toString = function () {
    var tag = this.tag(),
        id = this.id(),
        classes = this.classNames();

    var str = tag;
    if (id) str += '#' + id;
    if (classes.length) str += '.' + classes.join(".");
    return str;
};

var textProperty = document.createElement('div').textContent == null ? 'innerText' : 'textContent';

// tag, html, text, data

$.implement({

    tag: function tag() {
        return this[0].tagName.toLowerCase();
    },

    html: function html(_html) {
        return _html !== undefined ? this.forEach(function (node) {
            node.innerHTML = _html;
        }) : this[0].innerHTML;
    },

    text: function text(_text) {
        return _text !== undefined ? this.forEach(function (node) {
            node[textProperty] = _text;
        }) : this[0][textProperty];
    },

    data: function data(key, value) {
        switch (value) {
            case undefined:
                return this.getAttribute("data-" + key);
            case null:
                return this.removeAttribute("data-" + key);
            default:
                return this.setAttribute("data-" + key, value);
        }
    }

});

module.exports = $;

},{"./base":53,"mout/array/filter":184,"mout/array/forEach":185,"mout/array/indexOf":186,"mout/string/trim":214}],53:[function(require,module,exports){
/*
elements
*/"use strict";

var prime = require("prime");

var _forEach = require("mout/array/forEach"),
    _map = require("mout/array/map"),
    _filter = require("mout/array/filter"),
    _every = require("mout/array/every"),
    _some = require("mout/array/some");

// uniqueID

var index = 0,
    __dc = document.__counter,
    counter = document.__counter = (__dc ? parseInt(__dc, 36) + 1 : 0).toString(36),
    key = "uid:" + counter;

var uniqueID = function uniqueID(n) {
    if (n === window) return "window";
    if (n === document) return "document";
    if (n === document.documentElement) return "html";
    return n[key] || (n[key] = (index++).toString(36));
};

var instances = new WeakMap();

// elements prime

var $ = prime({ constructor: function $(n, context) {

        if (n == null) return this && this.constructor === $ ? new Elements() : null;

        var self, uid, instance;

        if (n.constructor !== Elements) {

            self = new Elements();

            if (typeof n === "string") {
                if (!self.search) return null;
                self[self.length++] = context || document;
                return self.search(n);
            }

            if (n.nodeType || n === window) {

                self[self.length++] = n;
            } else if (n.length) {

                // this could be an array, or any object with a length attribute,
                // including another instance of elements from another interface.

                var uniques = {};

                for (var i = 0, l = n.length; i < l; i++) {
                    // perform elements flattening
                    var nodes = $(n[i], context);
                    if (nodes && nodes.length) for (var j = 0, k = nodes.length; j < k; j++) {
                        var node = nodes[j];
                        uid = uniqueID(node);
                        if (!uniques[uid]) {
                            self[self.length++] = node;
                            uniques[uid] = true;
                        }
                    }
                }
            }
        } else {
            self = n;
        }

        if (!self.length) return null;

        // when length is 1 always use the same elements instance

        if (self.length === 1) {
            if (instance = instances.get(self[0])) {
                return instance;
            } else {
                instances.set(self[0], self);
            }
        }

        return self;
    } });

var Elements = prime({

    inherits: $,

    constructor: function Elements() {
        this.length = 0;
    },

    unlink: function unlink() {
        return this.map(function (node) {
            instances.delete(node);
            return node;
        });
    },

    // methods

    forEach: function forEach(method, context) {
        _forEach(this, method, context);
        return this;
    },

    map: function map(method, context) {
        return _map(this, method, context);
    },

    filter: function filter(method, context) {
        return _filter(this, method, context);
    },

    every: function every(method, context) {
        return _every(this, method, context);
    },

    some: function some(method, context) {
        return _some(this, method, context);
    }

});

module.exports = $;

},{"mout/array/every":183,"mout/array/filter":184,"mout/array/forEach":185,"mout/array/map":187,"mout/array/some":189,"prime":219}],54:[function(require,module,exports){
/*
delegation
*/"use strict";

var Map = require("prime/map");

var $ = require("./events");
require('./traversal');

$.implement({

    delegate: function delegate(event, selector, handle) {

        return this.forEach(function (node) {

            var self = $(node);

            var delegation = self._delegation || (self._delegation = {}),
                events = delegation[event] || (delegation[event] = {}),
                map = events[selector] || (events[selector] = new Map());

            if (map.get(handle)) return;

            var action = function action(e) {
                var target = $(e.target || e.srcElement),
                    match = target.matches(selector) ? target : target.parent(selector);

                var res;

                if (match) res = handle.call(self, e, match);

                return res;
            };

            map.set(handle, action);

            self.on(event, action);
        });
    },

    undelegate: function undelegate(event, selector, handle) {

        return this.forEach(function (node) {

            var self = $(node),
                delegation,
                events,
                map;

            if (!(delegation = self._delegation) || !(events = delegation[event]) || !(map = events[selector])) return;

            var action = map.get(handle);

            if (action) {
                self.off(event, action);
                map.remove(action);

                // if there are no more handles in a given selector, delete it
                if (!map.count()) delete events[selector];
                // var evc = evd = 0, x
                var e1 = true,
                    e2 = true,
                    x;
                for (x in events) {
                    e1 = false;
                    break;
                }
                // if no more selectors in a given event type, delete it
                if (e1) delete delegation[event];
                for (x in delegation) {
                    e2 = false;
                    break;
                }
                // if there are no more delegation events in the element, delete the _delegation object
                if (e2) delete self._delegation;
            }
        });
    }

});

module.exports = $;

},{"./events":55,"./traversal":58,"prime/map":220}],55:[function(require,module,exports){
/*
events
*/"use strict";

var Emitter = require("prime/emitter");

var $ = require("./base");

$.implement({

    on: function on(event, handle, useCapture) {

        return this.forEach(function (node) {
            var self = $(node);

            var internalEvent = event + (useCapture ? ":capture" : "");

            Emitter.prototype.on.call(self, internalEvent, handle);

            var domListeners = self._domListeners || (self._domListeners = {});
            if (!domListeners[internalEvent]) {
                var listener = function listener(e) {
                    Emitter.prototype.emit.call(self, internalEvent, e || window.event, Emitter.EMIT_SYNC);
                };
                node.addEventListener(event, listener, useCapture || false);
                domListeners[internalEvent] = listener;
            }
        });
    },

    off: function off(event, handle, useCapture) {

        return this.forEach(function (node) {

            var self = $(node);

            var internalEvent = event + (useCapture ? ":capture" : "");

            var domListeners = self._domListeners,
                domEvent,
                listeners = self._listeners,
                events;

            if (domListeners && (domEvent = domListeners[internalEvent]) && listeners && (events = listeners[internalEvent])) {

                Emitter.prototype.off.call(self, internalEvent, handle);

                if (!self._listeners || !self._listeners[event]) {
                    node.removeEventListener(event, domEvent, false);
                    delete domListeners[event];

                    for (var l in domListeners) {
                        return;
                    }delete self._domListeners;
                }
            }
        });
    },

    emit: function emit() {
        var args = arguments;
        return this.forEach(function (node) {
            Emitter.prototype.emit.apply($(node), args);
        });
    }

});

module.exports = $;

},{"./base":53,"prime/emitter":218}],56:[function(require,module,exports){
/*
elements
*/"use strict";

var $ = require("./base");
require("./attributes");
require("./events");
require("./insertion");
require("./traversal");
require("./delegation");

module.exports = $;

},{"./attributes":52,"./base":53,"./delegation":54,"./events":55,"./insertion":57,"./traversal":58}],57:[function(require,module,exports){
/*
insertion
*/"use strict";

var $ = require("./base");

// base insertion

$.implement({

    appendChild: function appendChild(child) {
        this[0].appendChild($(child)[0]);
        return this;
    },

    insertBefore: function insertBefore(child, ref) {
        this[0].insertBefore($(child)[0], $(ref)[0]);
        return this;
    },

    removeChild: function removeChild(child) {
        this[0].removeChild($(child)[0]);
        return this;
    },

    replaceChild: function replaceChild(child, ref) {
        this[0].replaceChild($(child)[0], $(ref)[0]);
        return this;
    }

});

// before, after, bottom, top

$.implement({

    before: function before(element) {
        element = $(element)[0];
        var parent = element.parentNode;
        if (parent) this.forEach(function (node) {
            parent.insertBefore(node, element);
        });
        return this;
    },

    after: function after(element) {
        element = $(element)[0];
        var parent = element.parentNode;
        if (parent) this.forEach(function (node) {
            parent.insertBefore(node, element.nextSibling);
        });
        return this;
    },

    bottom: function bottom(element) {
        element = $(element)[0];
        return this.forEach(function (node) {
            element.appendChild(node);
        });
    },

    top: function top(element) {
        element = $(element)[0];
        return this.forEach(function (node) {
            element.insertBefore(node, element.firstChild);
        });
    }

});

// insert, replace

$.implement({

    insert: $.prototype.bottom,

    remove: function remove() {
        return this.forEach(function (node) {
            var parent = node.parentNode;
            if (parent) parent.removeChild(node);
        });
    },

    replace: function replace(element) {
        element = $(element)[0];
        element.parentNode.replaceChild(this[0], element);
        return this;
    }

});

module.exports = $;

},{"./base":53}],58:[function(require,module,exports){
/*
traversal
*/"use strict";

var map = require("mout/array/map");

var slick = require("slick");

var $ = require("./base");

var gen = function gen(combinator, expression) {
    return map(slick.parse(expression || "*"), function (part) {
        return combinator + " " + part;
    }).join(", ");
};

var push_ = Array.prototype.push;

$.implement({

    search: function search(expression) {
        if (this.length === 1) return $(slick.search(expression, this[0], new $()));

        var buffer = [];
        for (var i = 0, node; node = this[i]; i++) {
            push_.apply(buffer, slick.search(expression, node));
        }buffer = $(buffer);
        return buffer && buffer.sort();
    },

    find: function find(expression) {
        if (this.length === 1) return $(slick.find(expression, this[0]));

        for (var i = 0, node; node = this[i]; i++) {
            var found = slick.find(expression, node);
            if (found) return $(found);
        }

        return null;
    },

    sort: function sort() {
        return slick.sort(this);
    },

    matches: function matches(expression) {
        return slick.matches(this[0], expression);
    },

    contains: function contains(node) {
        return slick.contains(this[0], node);
    },

    nextSiblings: function nextSiblings(expression) {
        return this.search(gen('~', expression));
    },

    nextSibling: function nextSibling(expression) {
        return this.find(gen('+', expression));
    },

    previousSiblings: function previousSiblings(expression) {
        return this.search(gen('!~', expression));
    },

    previousSibling: function previousSibling(expression) {
        return this.find(gen('!+', expression));
    },

    children: function children(expression) {
        return this.search(gen('>', expression));
    },

    firstChild: function firstChild(expression) {
        return this.find(gen('^', expression));
    },

    lastChild: function lastChild(expression) {
        return this.find(gen('!^', expression));
    },

    parent: function parent(expression) {
        var buffer = [];
        loop: for (var i = 0, node; node = this[i]; i++) {
            while ((node = node.parentNode) && node !== document) {
                if (!expression || slick.matches(node, expression)) {
                    buffer.push(node);
                    break loop;
                    break;
                }
            }
        }return $(buffer);
    },

    parents: function parents(expression) {
        var buffer = [];
        for (var i = 0, node; node = this[i]; i++) {
            while ((node = node.parentNode) && node !== document) {
                if (!expression || slick.matches(node, expression)) buffer.push(node);
            }
        }return $(buffer);
    }

});

module.exports = $;

},{"./base":53,"mout/array/map":187,"slick":226}],59:[function(require,module,exports){
(function (global){
'use strict';

exports.init = function () {
  require('./expose-debug-global').expose(global, 'bridge', require('../spotify-bridge-request'));
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-bridge-request":50,"./expose-debug-global":61}],60:[function(require,module,exports){
(function (global){
'use strict';

exports.init = function () {
  require('./expose-debug-global').expose(global, 'cosmos', require('spotify-cosmos-api'));
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./expose-debug-global":61,"spotify-cosmos-api":233}],61:[function(require,module,exports){
'use strict';

exports.expose = function (global, name, object) {
  if (global.__spotify && global.__spotify.developer_mode) {
    Object.defineProperty(global, name, {
      get: function get() {
        try {
          throw new Error();
        } catch (error) {
          if (!/injectedscript/i.test(error.stack)) {
            throw new Error('window.' + name + ' should only be accessed from the console');
          }
        }
        return object;
      },
      enumerable: true,
      configurable: true
    });
  }
};

},{}],62:[function(require,module,exports){
(function (global){
'use strict';

exports.init = function () {
  require('./expose-debug-global').expose(global, 'live', require('../spotify-live'));
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-live":109,"./expose-debug-global":61}],63:[function(require,module,exports){
module.exports = {
  "Album": "Album",
  "AndMore": "und {0} weitere",
  "Artist": "Künstler",
  "By": "von",
  "Create Similar Playlist": "Ähnliche Playlist erstellen",
  "Filter": "Filter",
  "Follow": "Folgen",
  "Follower": "Follower",
  "FollowersLabel": "Followers",
  "Following": "Folge ich",
  "FollowingLabel": "Folge ich",
  "ListenersLabel": "Monatliche Hörer",
  "FollowsYou": "Folgt dir",
  "HoldToPreview": "Zum Reinhören gedrückt halten",
  "ListenCount": "{0} Mal abgespielt",
  "ListenReactionMulti": "{0} Hörer in Deinem Netzwerk",
  "ListenReactionSingle": "{0} hört sich das an",
  "LocalFile": "Lokale Datei",
  "More": "Mehr",
  "Pause": "Pause",
  "Play": "Play",
  "Playlist": "Playlist",
  "PressEnterToPlay": "Drück die Eingabetaste zum Abspielen",
  "Popularity": "Beliebtheit",
  "Remove": "Entfernen",
  "RemoveYourMusic": "Aus \"Deine Musik\" entfernen",
  "Save": "Speichern",
  "SaveYourMusic": "In \"Deine Musik\" speichern",
  "Saved": "Gespeichert",
  "ShufflePlay": "Shuffle",
  "Song": "Song",
  "StartRadio": "Radio starten",
  "Time": "Dauer",
  "Toplist": "Top-Songs",
  "Track": "Song",
  "Unfollow": "Nicht mehr folgen",
  "User": "Benutzer",
  "ViewAll": "Mehr Darstellung",
  "HoursShort": "{0} Std.",
  "MinutesShort": "{0} Min.",
  "SecondsShort": "{0} Sek.",
  "ErrorTitle": "Bei der Anzeige dieser Ansicht ist ein Fehler aufgetreten!",
  "ErrorMessage": "Diese Ansicht ist entweder nicht vorhanden oder es ist ein Fehler aufgetreten.",
  "OfflineTitle": "Diese Ansicht ist offline nicht verfügbar.",
  "OfflineMessage": "Geh zum Laden online."
};
},{}],64:[function(require,module,exports){
module.exports = {
  "Album": "Άλμπουμ",
  "AndMore": "και άλλοι {0}",
  "Artist": "Καλλιτέχνης",
  "By": "από",
  "Create Similar Playlist": "Δημιουργία παρόμοιας playlist",
  "Filter": "Φίλτρο",
  "Follow": "Ακολούθησε",
  "Follower": "Οπαδός",
  "FollowersLabel": "Οπαδοί",
  "Following": "Aκολουθείται",
  "FollowingLabel": "Aκολουθείται",
  "ListenersLabel": "Μηνιαίοι ακροατές",
  "FollowsYou": "Σε ακολουθεί",
  "HoldToPreview": "Πάτησε και κράτησε πατημένο για προεπισκόπηση",
  "ListenCount": "{0} αναπαραγωγές",
  "ListenReactionMulti": "{0} ακροατές στο δίκτυό σου",
  "ListenReactionSingle": "Ο χρήστης {0} ακούει αυτό",
  "LocalFile": "Τοπικό αρχείο",
  "More": "Περισσότερα",
  "Pause": "Παύση",
  "Play": "Αναπαραγωγή",
  "Playlist": "Λίστα",
  "PressEnterToPlay": "Πάτησε Enter για αναπαραγωγή",
  "Popularity": "Δημοφιλία",
  "Remove": "Αφαίρεση",
  "RemoveYourMusic": "Αφαίρεση από τη Mουσική σου",
  "Save": "Αποθήκευση",
  "SaveYourMusic": "Αποθήκευση στη Mουσική σου",
  "Saved": "Αποθηκεύτηκε",
  "ShufflePlay": "Τυχαία αναπαραγωγή",
  "Song": "Τραγούδι",
  "StartRadio": "Έναρξη ραδιοφώνου",
  "Time": "Διάρκεια",
  "Toplist": "Κορυφαία τραγούδια",
  "Track": "Τραγούδι",
  "Unfollow": "Άρση ακολούθησης",
  "User": "Χρήστης",
  "ViewAll": "Δες τα όλα",
  "HoursShort": "{0} ώρα",
  "MinutesShort": "{0} λεπ.",
  "SecondsShort": "{0} δευτ.",
  "ErrorTitle": "Προέκυψε σφάλμα κατά την προβολή αυτής της οθόνης!",
  "ErrorMessage": "Η συγκεκριμένη προβολή δεν υπάρχει ή προέκυψε κάποιο σφάλμα.",
  "OfflineTitle": "Αυτή η προβολή δεν είναι διαθέσιμη εκτός σύνδεσης!",
  "OfflineMessage": "Συνδέσου στο διαδίκτυο για να πραγματοποιηθεί φόρτωση."
};
},{}],65:[function(require,module,exports){
module.exports = {
  "Album": "Album",
  "AndMore": "and {0} more",
  "Artist": "Artist",
  "By": "by",
  "Create Similar Playlist": "Create Similar Playlist",
  "Filter": "Filter",
  "Follow": "Follow",
  "Follower": "Follower",
  "FollowersLabel": "Followers",
  "Following": "Following",
  "FollowingLabel": "Following",
  "ListenersLabel": "Monthly Listeners",
  "FollowsYou": "Follows You",
  "HoldToPreview": "Click and Hold to Preview",
  "ListenCount": "{0} plays",
  "ListenReactionMulti": "{0} listeners in your network",
  "ListenReactionSingle": "{0} listens to this",
  "LocalFile": "Local File",
  "More": "More",
  "Pause": "Pause",
  "Play": "Play",
  "Playlist": "Playlist",
  "PressEnterToPlay": "Press Enter to play",
  "Popularity": "Popularity",
  "Remove": "Remove",
  "RemoveYourMusic": "Remove from Your Music",
  "Save": "Save",
  "SaveYourMusic": "Save to Your Music",
  "Saved": "Saved",
  "ShufflePlay": "Shuffle Play",
  "Song": "Song",
  "StartRadio": "Start Radio",
  "Time": "Time",
  "Toplist": "Top songs",
  "Track": "Song",
  "Unfollow": "Unfollow",
  "User": "User",
  "ViewAll": "View All",
  "HoursShort": "{0} hr",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} sec",
  "ErrorTitle": "There was a problem displaying this view!",
  "ErrorMessage": "This view either does not exist or an error occurred.",
  "OfflineTitle": "This view is not available offline!",
  "OfflineMessage": "Please go online to load."
}
;
},{}],66:[function(require,module,exports){
module.exports = {
  "Album": "Álbum",
  "AndMore": "y {0} más",
  "Artist": "Artista",
  "By": "por",
  "Create Similar Playlist": "Crear playlist similar",
  "Filter": "Filtrar",
  "Follow": "Seguir",
  "Follower": "Seguidor",
  "FollowersLabel": "Seguidores",
  "Following": "Siguiendo",
  "FollowingLabel": "Siguiendo",
  "ListenersLabel": "Oyentes mensuales",
  "FollowsYou": "Te sigue",
  "HoldToPreview": "Haz clic y mantén pulsado para oír la muestra preliminar",
  "ListenCount": "{0} reproducciones",
  "ListenReactionMulti": "{0} oyentes en tu red",
  "ListenReactionSingle": "{0} escucha esto",
  "LocalFile": "Archivo local",
  "More": "Más",
  "Pause": "Pausa",
  "Play": "Reproducir",
  "Playlist": "Lista",
  "PressEnterToPlay": "Presiona Enter para reproducir",
  "Popularity": "Popularidad",
  "Remove": "Eliminar",
  "RemoveYourMusic": "Eliminar de Tu Música",
  "Save": "Guardar",
  "SaveYourMusic": "Guardar en Tu Música",
  "Saved": "Guardado",
  "ShufflePlay": "Aleatoria",
  "Song": "Canción",
  "StartRadio": "Comenzar Radio",
  "Time": "Tiempo",
  "Toplist": "Canciones más reproducidas",
  "Track": "Canción",
  "Unfollow": "Dejar de seguir",
  "User": "Usuario",
  "ViewAll": "Ver todos",
  "HoursShort": "{0} hr",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} seg",
  "ErrorTitle": "Hubo un problema al mostrar esta vista.",
  "ErrorMessage": "Puede ser que esta vista no exista, o bien, que haya ocurrido un error.",
  "OfflineTitle": "Esta vista no está disponible sin conexión. ",
  "OfflineMessage": "Conéctate a la red para cargar."
};
},{}],67:[function(require,module,exports){
module.exports = {
  "Album": "Álbum",
  "AndMore": "y {0} más",
  "Artist": "Artista",
  "By": "por",
  "Create Similar Playlist": "Crear playlist similar",
  "Filter": "Filtrar",
  "Follow": "Seguir",
  "Follower": "Seguidor",
  "FollowersLabel": "Seguidores",
  "Following": "Siguiendo",
  "FollowingLabel": "Siguiendo",
  "ListenersLabel": "Oyentes mensuales",
  "FollowsYou": "Te sigue",
  "HoldToPreview": "Pulsa y mantén pulsado para oír la muestra preliminar",
  "ListenCount": "{0} reproducciones",
  "ListenReactionMulti": "{0} oyentes en tu red",
  "ListenReactionSingle": "{0} escucha esto",
  "LocalFile": "Archivo local",
  "More": "Más",
  "Pause": "Pausar",
  "Play": "Reproducir",
  "Playlist": "Lista",
  "PressEnterToPlay": "Pulsa Intro para reproducir",
  "Popularity": "Popularidad",
  "Remove": "Retirar",
  "RemoveYourMusic": "Eliminar de Tu música",
  "Save": "Guardar",
  "SaveYourMusic": "Guardar en Tu música",
  "Saved": "Guardada",
  "ShufflePlay": "Aleatoria",
  "Song": "Canción",
  "StartRadio": "Comenzar radio",
  "Time": "Tiempo",
  "Toplist": "Canciones más escuchadas",
  "Track": "Canción",
  "Unfollow": "Dejar de seguir",
  "User": "Usuario",
  "ViewAll": "Ver todos",
  "HoursShort": "{0} hr",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} seg",
  "ErrorTitle": "Se ha producido un problema al mostrar esta vista.",
  "ErrorMessage": "Esta vista no existe o se ha producido un error.",
  "OfflineTitle": "Esta vista no está disponible sin conexión. ",
  "OfflineMessage": "Por favor, conéctate para cargar."
};
},{}],68:[function(require,module,exports){
module.exports = {
  "Album": "Albumi",
  "AndMore": "ja {0} muuta",
  "Artist": "Artisti",
  "By": "tekijältä",
  "Create Similar Playlist": "Luo samankaltainen soittolista",
  "Filter": "Suodatin",
  "Follow": "Seuraa",
  "Follower": "Seuraaja",
  "FollowersLabel": "Seuraajat",
  "Following": "Seurataan",
  "FollowingLabel": "Seurataan",
  "ListenersLabel": "Kuuntelijat kuukauden aikana",
  "FollowsYou": "Seuraa sinua",
  "HoldToPreview": "Kuuntele pätkä pitämällä tätä painettuna",
  "ListenCount": "{0} toistoa",
  "ListenReactionMulti": "{0} kuuntelijaa verkostossasi",
  "ListenReactionSingle": "{0} kuuntelee tätä",
  "LocalFile": "Paikallinen tiedosto",
  "More": "Lisää",
  "Pause": "Tauko",
  "Play": "Toista",
  "Playlist": "Soittolista",
  "PressEnterToPlay": "Toista painamalla Enter-näppäintä",
  "Popularity": "Suosio",
  "Remove": "Poista",
  "RemoveYourMusic": "Poista Omasta musiikista",
  "Save": "Tallenna",
  "SaveYourMusic": "Tallenna Omaan musiikkiin",
  "Saved": "Tallennettu",
  "ShufflePlay": "Satunnaistoisto",
  "Song": "Kappale",
  "StartRadio": "Käynnistä radio",
  "Time": "Kesto",
  "Toplist": "Suosituimmat kappaleet",
  "Track": "Kappale",
  "Unfollow": "Lopeta seuraaminen",
  "User": "Käyttäjä",
  "ViewAll": "Näytä kaikki",
  "HoursShort": "{0} h",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} s",
  "ErrorTitle": "Tämän näkymän näyttämisessä on ongelmia.",
  "ErrorMessage": "Tätä näkymää ei ole, tai tapahtui virhe.",
  "OfflineTitle": "Tätä näkymää ei voi käyttää offline-tilassa!",
  "OfflineMessage": "Siirry online-tilaan, jotta voit ladata."
};
},{}],69:[function(require,module,exports){
module.exports = {
  "Album": "Album",
  "AndMore": "et {0} autres",
  "Artist": "Artiste",
  "By": "par",
  "Create Similar Playlist": "Créer une liste de lecture semblable",
  "Filter": "Filtrer",
  "Follow": "Suivre",
  "Follower": "Abonné",
  "FollowersLabel": "Abonné",
  "Following": "Suivis",
  "FollowingLabel": "Suivis",
  "ListenersLabel": "Auditeurs mensuels",
  "FollowsYou": "Vous suit",
  "HoldToPreview": "Cliquez longuement pour avoir un aperçu",
  "ListenCount": "{0} écoutes",
  "ListenReactionMulti": "{0} auditeurs dans votre réseau",
  "ListenReactionSingle": "{0} écoute ceci",
  "LocalFile": "Fichier local",
  "More": "Plus",
  "Pause": "Pause",
  "Play": "Lecture",
  "Playlist": "Playlist",
  "PressEnterToPlay": "Appuyez sur Entrée pour faire la lecture",
  "Popularity": "Popularité",
  "Remove": "Supprimer",
  "RemoveYourMusic": "Supprimer de Votre musique",
  "Save": "Sauvegarder",
  "SaveYourMusic": "Enregistrer dans Votre musique",
  "Saved": "Sauvegardé",
  "ShufflePlay": "Lecture aléatoire",
  "Song": "Titre",
  "StartRadio": "Lancer la radio",
  "Time": "Durée",
  "Toplist": "Meilleures chansons",
  "Track": "Titre",
  "Unfollow": "Ne plus suivre",
  "User": "Utilisateur",
  "ViewAll": "Voir tout",
  "HoursShort": "{0} h",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} s",
  "ErrorTitle": "Un problème est survenu lors du chargement de cet affichage!",
  "ErrorMessage": "L'affichage n'existe pas ou une erreur s'est produite.",
  "OfflineTitle": "Cette vue n'est pas disponible hors ligne!",
  "OfflineMessage": "Veuillez accéder à Internet pour charger le contenu."
};
},{}],70:[function(require,module,exports){
module.exports = {
  "Album": "Album",
  "AndMore": "et {0} autres",
  "Artist": "Artiste",
  "By": "par",
  "Create Similar Playlist": "Créer une playlist similaire",
  "Filter": "Filtre",
  "Follow": "S'abonner",
  "Follower": "Abonné",
  "FollowersLabel": "Abonnés",
  "Following": "Abonné",
  "FollowingLabel": "Abonné",
  "ListenersLabel": "Nombres de personnes qui écoutent par mois",
  "FollowsYou": "Est abonné à vous",
  "HoldToPreview": "Cliquez longuement pour avoir un aperçu",
  "ListenCount": "{0} écoutes",
  "ListenReactionMulti": "{0} auditeurs dans votre réseau",
  "ListenReactionSingle": "{0} écoute ceci.",
  "LocalFile": "Fichier local",
  "More": "Plus",
  "Pause": "Pause",
  "Play": "Lire",
  "Playlist": "Playlist",
  "PressEnterToPlay": "Appuyez sur Entrée pour écouter",
  "Popularity": "Popularité",
  "Remove": "Supprimer",
  "RemoveYourMusic": "Supprimer de Ma musique",
  "Save": "Sauvegarder",
  "SaveYourMusic": "Sauvegarder dans Ma musique",
  "Saved": "Sauvegardé",
  "ShufflePlay": "Aléatoire",
  "Song": "Titre",
  "StartRadio": "Ecouter la radio",
  "Time": "Durée",
  "Toplist": "Top titres",
  "Track": "Titre",
  "Unfollow": "Se désabonner",
  "User": "Utilisateur",
  "ViewAll": "Présentation tout",
  "HoursShort": "{0} h",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} s",
  "ErrorTitle": "Problème d'affichage !",
  "ErrorMessage": "Cet affichage n'existe pas ou une erreur s'est produite.",
  "OfflineTitle": "Cet affichage n'est pas disponible hors connexion.",
  "OfflineMessage": "Connectez-vous pour procéder au chargement."
};
},{}],71:[function(require,module,exports){
module.exports = {
  "Album": "Album",
  "AndMore": "és még {0} felhasználó",
  "Artist": "Előadó",
  "By": "tőle:",
  "Create Similar Playlist": "Hasonló műsorlista létrehozása",
  "Filter": "Szűrő",
  "Follow": "Követés",
  "Follower": "Követő",
  "FollowersLabel": "Követők",
  "Following": "Követések",
  "FollowingLabel": "Követések",
  "ListenersLabel": "Hallgatók havonta",
  "FollowsYou": "Téged követ",
  "HoldToPreview": "Tartsd nyomva a belehallgatáshoz",
  "ListenCount": "{0} lejátszás",
  "ListenReactionMulti": "{0} ismerősöd hallgatta meg",
  "ListenReactionSingle": "{0} már meghallgatta",
  "LocalFile": "Helyi fájl",
  "More": "Több",
  "Pause": "Szünet",
  "Play": "Lejátszás",
  "Playlist": "Lejátszási lista",
  "PressEnterToPlay": "Lejátszás az Enterrel",
  "Popularity": "Népszerűség",
  "Remove": "Eltávolítás",
  "RemoveYourMusic": "Törlés a Zenéid közül",
  "Save": "Mentés",
  "SaveYourMusic": "Mentés a Zenéid közé",
  "Saved": "Mentett",
  "ShufflePlay": "Lejátszás keverve",
  "Song": "Dal",
  "StartRadio": "Rádió bekapcsolása",
  "Time": "Idő",
  "Toplist": "Toplista",
  "Track": "Dal",
  "Unfollow": "Nem követem",
  "User": "Felhasználó",
  "ViewAll": "Mindent mutat",
  "HoursShort": "{0} óra",
  "MinutesShort": "{0} perc",
  "SecondsShort": "{0} mp",
  "ErrorTitle": "Egy hiba miatt nem jeleníthető meg ez az oldal",
  "ErrorMessage": "A kért nézet nem létezik, vagy valamilyen műszaki hiba történt.",
  "OfflineTitle": "Ez a nézet internetkapcsolat nélkül nem érhető el.",
  "OfflineMessage": "Csatlakozz az internethez, majd indítsd el."
};
},{}],72:[function(require,module,exports){
module.exports = {
  "Album": "Album",
  "AndMore": "dan {0} lagi",
  "Artist": "Artis",
  "By": "menurut",
  "Create Similar Playlist": "Buat Playlist Serupa",
  "Filter": "Filter",
  "Follow": "Ikuti",
  "Follower": "Pengikut",
  "FollowersLabel": "Pengikut",
  "Following": "Mengikuti",
  "FollowingLabel": "Mengikuti",
  "ListenersLabel": "Pendengar Bulanan",
  "FollowsYou": "Mengikutimu",
  "HoldToPreview": "Klik dan Tahan untuk Pratinjau",
  "ListenCount": "{0} permainan",
  "ListenReactionMulti": "{0} pendengar di jaringanmu",
  "ListenReactionSingle": "{0} mendengarkan ini",
  "LocalFile": "File Lokal",
  "More": "Lainnya",
  "Pause": "Jeda",
  "Play": "Play",
  "Playlist": "Playlist",
  "PressEnterToPlay": "Tekan Enter untuk memainkan",
  "Popularity": "Popularitas",
  "Remove": "Hapus",
  "RemoveYourMusic": "Hapus dari Musik Kamu",
  "Save": "Simpan",
  "SaveYourMusic": "Simpan ke Musik Kamu",
  "Saved": "Tersimpan",
  "ShufflePlay": "Pemutaran Acak",
  "Song": "Lagu",
  "StartRadio": "Mulai Radio",
  "Time": "Waktu",
  "Toplist": "Lagu teratas",
  "Track": "Lagu",
  "Unfollow": "Berhenti mengikuti",
  "User": "Pengguna",
  "ViewAll": "Lihat Semua",
  "HoursShort": "{0} jam",
  "MinutesShort": "{0} mnt",
  "SecondsShort": "{0} dtk",
  "ErrorTitle": "Ada masalah saat menampilkan tampilan ini!",
  "ErrorMessage": "Tampilan ini tidak ada atau terjadi kesalahan.",
  "OfflineTitle": "Tampilan ini tidak tersedia offline.",
  "OfflineMessage": "Alihkan ke online untuk memuat."
};
},{}],73:[function(require,module,exports){
module.exports = {
  "Album": "Album",
  "AndMore": "e altri {0}",
  "Artist": "Artista",
  "By": "per",
  "Create Similar Playlist": "Crea playlist simile",
  "Filter": "Filtra",
  "Follow": "Segui",
  "Follower": "Follower",
  "FollowersLabel": "Follower",
  "Following": "Following",
  "FollowingLabel": "Following",
  "ListenersLabel": "Ascoltatori questo mese",
  "FollowsYou": "Ti segue",
  "HoldToPreview": "Tieni premuto per un'anteprima",
  "ListenCount": "{0} riproduzioni",
  "ListenReactionMulti": "{0} ascoltatori nella tua rete",
  "ListenReactionSingle": "{0} ascolta questo",
  "LocalFile": "File locale",
  "More": "Più",
  "Pause": "Pausa",
  "Play": "Play",
  "Playlist": "Playlist",
  "PressEnterToPlay": "Premi Invio per riprodurre",
  "Popularity": "Popolarità",
  "Remove": "Rimuovi",
  "RemoveYourMusic": "Elimina da La tua musica",
  "Save": "Salva",
  "SaveYourMusic": "Salva in La tua musica",
  "Saved": "Salvato",
  "ShufflePlay": "Riproduzione shuffle",
  "Song": "Brano",
  "StartRadio": "Crea una radio",
  "Time": "Durata",
  "Toplist": "Brani top",
  "Track": "Brano",
  "Unfollow": "Non seguire più",
  "User": "Utente",
  "ViewAll": "Visualizza tutto",
  "HoursShort": "{0} ore",
  "MinutesShort": "{0} min.",
  "SecondsShort": "{0} sec",
  "ErrorTitle": "Si è verificato un errore in questa vista.",
  "ErrorMessage": "La vista non esiste o si è verificato un errore.",
  "OfflineTitle": "Questa vista non è disponibile offline.",
  "OfflineMessage": "Passa online per caricare."
};
},{}],74:[function(require,module,exports){
module.exports = {
  "Album": "アルバム",
  "AndMore": "その他{0}人",
  "Artist": "アーティスト",
  "By": "/",
  "Create Similar Playlist": "同様のプレイリストを作成",
  "Filter": "フィルタ",
  "Follow": "フォロー",
  "Follower": "フォロワー",
  "FollowersLabel": "フォロワー",
  "Following": "フォロー中",
  "FollowingLabel": "フォロー中",
  "ListenersLabel": "今月のリスナー",
  "FollowsYou": "あなたをフォローしています",
  "HoldToPreview": "プレビューするには、クリックを押しします",
  "ListenCount": "{0}回再生",
  "ListenReactionMulti": "ネットワーク内で{0}人が聴いています",
  "ListenReactionSingle": "{0}さんはこれを聴いています",
  "LocalFile": "ローカルファイル",
  "More": "詳細",
  "Pause": "一時停止",
  "Play": "再生",
  "Playlist": "プレイリスト",
  "PressEnterToPlay": "再生するにはEnterキーを押します",
  "Popularity": "人気",
  "Remove": "削除",
  "RemoveYourMusic": "My Musicから削除",
  "Save": "保存",
  "SaveYourMusic": "My Musicに保存",
  "Saved": "保存済み",
  "ShufflePlay": "シャッフルプレイ",
  "Song": "ソング",
  "StartRadio": "Radioを開始",
  "Time": "時間",
  "Toplist": "トップ曲",
  "Track": "ソング",
  "Unfollow": "フォローをやめる",
  "User": "ユーザー",
  "ViewAll": "すべて表示",
  "HoursShort": "{0} 時間",
  "MinutesShort": "{0} 分",
  "SecondsShort": "{0} 秒",
  "ErrorTitle": "このビューを表示しようとしているときに問題が発生しました。",
  "ErrorMessage": "このビューが存在しないか、エラーが発生しました。",
  "OfflineTitle": "このビューはオフラインでは使用できません。",
  "OfflineMessage": "ロードするには、インターネットに接続してください。"
};
},{}],75:[function(require,module,exports){
module.exports = {
  "Album": "Album",
  "AndMore": "en {0} meer",
  "Artist": "Artiest",
  "By": "van",
  "Create Similar Playlist": "Vergelijkbare afspeellijst maken",
  "Filter": "Filter",
  "Follow": "Volgen",
  "Follower": "Volger",
  "FollowersLabel": "Volgers",
  "Following": "Volgend",
  "FollowingLabel": "Volgend",
  "ListenersLabel": "Luisteraars per maand",
  "FollowsYou": "Volgt jou",
  "HoldToPreview": "Klikken en vasthouden om een stukje te horen",
  "ListenCount": "{0} keer afgespeeld",
  "ListenReactionMulti": "{0} luisteraars in jouw netwerk",
  "ListenReactionSingle": "{0} luistert hiernaar",
  "LocalFile": "Lokaal bestand",
  "More": "Meer",
  "Pause": "Pauze",
  "Play": "Afspelen",
  "Playlist": "Afspeellijst",
  "PressEnterToPlay": "Druk op Enter om af te spelen",
  "Popularity": "Populariteit",
  "Remove": "Verwijderen",
  "RemoveYourMusic": "Verwijderen uit Jouw Muziek",
  "Save": "Opslaan",
  "SaveYourMusic": "Opslaan in Jouw Muziek",
  "Saved": "Opgeslagen",
  "ShufflePlay": "Shuffle",
  "Song": "Nummer",
  "StartRadio": "Radio starten",
  "Time": "Tijd",
  "Toplist": "Topnummers",
  "Track": "Nummer",
  "Unfollow": "Niet meer volgen",
  "User": "Gebruiker",
  "ViewAll": "Alles bekijken",
  "HoursShort": "{0} uur",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} sec",
  "ErrorTitle": "Er is een fout opgetreden bij het laden van deze weergave.",
  "ErrorMessage": "Deze weergave bestaat niet of er is een fout opgetreden.",
  "OfflineTitle": "Deze weergave is offline niet beschikbaar!",
  "OfflineMessage": "Ga online om te laden."
};
},{}],76:[function(require,module,exports){
module.exports = {
  "Album": "Album",
  "AndMore": "i {0} więcej",
  "Artist": "Wykonawca",
  "By": "według",
  "Create Similar Playlist": "Utwórz podobną playlistę",
  "Filter": "Filtruj",
  "Follow": "Obserwuj",
  "Follower": "Obserwujący",
  "FollowersLabel": "Obserwatorzy",
  "Following": "Obserwowana",
  "FollowingLabel": "Obserwowana",
  "ListenersLabel": "Słuchacze w tym miesiącu",
  "FollowsYou": "Obserwuje Cię",
  "HoldToPreview": "Aby odsłuchać, kliknij i przytrzymaj.",
  "ListenCount": "Liczba odtworzeń: {0}",
  "ListenReactionMulti": "Liczba słuchaczy w Twojej sieci: {0}",
  "ListenReactionSingle": "Użytkownik {0} słucha tego",
  "LocalFile": "Plik lokalny",
  "More": "Więcej",
  "Pause": "Pauza",
  "Play": "Odtwórz",
  "Playlist": "Playlista",
  "PressEnterToPlay": "Naciśnij Enter, aby odtworzyć",
  "Popularity": "Popularność",
  "Remove": "Usuń",
  "RemoveYourMusic": "Usuń z kolekcji Twoja muzyka",
  "Save": "Zapisz",
  "SaveYourMusic": "Zapisz w kolekcji Twoja muzyka",
  "Saved": "Zapisany",
  "ShufflePlay": "Odtwarzanie losowe",
  "Song": "Utwór",
  "StartRadio": "Włącz radio",
  "Time": "Czas",
  "Toplist": "Najpopularniejsze utwory",
  "Track": "Utwór",
  "Unfollow": "Przestań obserwować",
  "User": "Użytkownik",
  "ViewAll": "Wyświetl wszystko",
  "HoursShort": "{0} godz.",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} s",
  "ErrorTitle": "Podczas wyświetlania tego widoku wystąpił błąd!",
  "ErrorMessage": "Ten widok nie istnieje lub wystąpił błąd.",
  "OfflineTitle": "Ten widok jest niedostępny w trybie offline. ",
  "OfflineMessage": "Przejdź do trybu online, aby załadować."
};
},{}],77:[function(require,module,exports){
module.exports = {
  "Album": "Álbum",
  "AndMore": "e mais {0}",
  "Artist": "Artista",
  "By": "de",
  "Create Similar Playlist": "Criar playlist similar",
  "Filter": "Filtrar",
  "Follow": "Seguir",
  "Follower": "Seguidor",
  "FollowersLabel": "Seguidores",
  "Following": "Seguindo",
  "FollowingLabel": "Seguindo",
  "ListenersLabel": "Ouvintes mensais",
  "FollowsYou": "Segue você",
  "HoldToPreview": "Clique e segure para a prévia",
  "ListenCount": "{0} reproduções",
  "ListenReactionMulti": "{0} ouvintes na sua rede",
  "ListenReactionSingle": "{0} ouvem isso",
  "LocalFile": "Arquivo local",
  "More": "Mais",
  "Pause": "Pause",
  "Play": "Play",
  "Playlist": "Playlist",
  "PressEnterToPlay": "Pressione Enter para tocar",
  "Popularity": "Popularidade",
  "Remove": "Remover",
  "RemoveYourMusic": "Remover de Suas músicas",
  "Save": "Salvar",
  "SaveYourMusic": "Salvar em Suas músicas",
  "Saved": "Salvo",
  "ShufflePlay": "Ordem aleatória",
  "Song": "Música",
  "StartRadio": "Abrir rádio",
  "Time": "Tempo",
  "Toplist": "Músicas mais tocadas",
  "Track": "Música",
  "Unfollow": "Deixar de seguir",
  "User": "Usuário",
  "ViewAll": "Ver tudo",
  "HoursShort": "{0} h",
  "MinutesShort": "{0} m",
  "SecondsShort": "{0} s",
  "ErrorTitle": "Tivemos um problema ao mostrar esta exibição!",
  "ErrorMessage": "A exibição não existe ou ocorreu um erro.",
  "OfflineTitle": "Essa visualização não está disponível offline!",
  "OfflineMessage": "Fique online para carregar."
};
},{}],78:[function(require,module,exports){
module.exports = {
  "Album": "Album",
  "AndMore": "och {0} till",
  "Artist": "Artist",
  "By": "av",
  "Create Similar Playlist": "Skapa en liknande spellista",
  "Filter": "Filtrera",
  "Follow": "Följ",
  "Follower": "Följare",
  "FollowersLabel": "Följare",
  "Following": "Följer",
  "FollowingLabel": "Följer",
  "ListenersLabel": "Lyssnare per månad",
  "FollowsYou": "Följer dig",
  "HoldToPreview": "Klicka och håll kvar för att förhandslyssna",
  "ListenCount": "{0} uppspelningar",
  "ListenReactionMulti": "{0} lyssnare i ditt nätverk",
  "ListenReactionSingle": "{0} lyssnar på detta",
  "LocalFile": "Lokal fil",
  "More": "Mer",
  "Pause": "Pausa",
  "Play": "Spela upp",
  "Playlist": "Spellista",
  "PressEnterToPlay": "Tryck på Retur om du vill lyssna",
  "Popularity": "Popularitet",
  "Remove": "Ta bort",
  "RemoveYourMusic": "Ta bort från Din Musik",
  "Save": "Spara",
  "SaveYourMusic": "Spara i Din Musik",
  "Saved": "Sparade",
  "ShufflePlay": "Slumpmässig uppspelning",
  "Song": "Låt",
  "StartRadio": "Starta radio",
  "Time": "Tid",
  "Toplist": "Topplåtar",
  "Track": "Låt",
  "Unfollow": "Sluta följa",
  "User": "Användare",
  "ViewAll": "Visa alla",
  "HoursShort": "{0} tim",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} sek",
  "ErrorTitle": "Det uppstod ett fel när den här vyn skulle visas!",
  "ErrorMessage": "Den här vyn finns inte eller så uppstod ett fel.",
  "OfflineTitle": "Den här vyn är inte tillgänglig offline.",
  "OfflineMessage": "Anslut till internet om du vill läsa in appen."
};
},{}],79:[function(require,module,exports){
module.exports = {
  "Album": "Albüm",
  "AndMore": "ve {0} daha",
  "Artist": "Sanatçı",
  "By": "-",
  "Create Similar Playlist": "Benzer Çalma Listesi Oluştur",
  "Filter": "Filtrele",
  "Follow": "Takip Et",
  "Follower": "Takipçi",
  "FollowersLabel": "Takipçiler",
  "Following": "Takip Ediliyor",
  "FollowingLabel": "Takip Ediliyor",
  "ListenersLabel": "Aylık Dinleyici",
  "FollowsYou": "Seni Takip Ediyor",
  "HoldToPreview": "Basılı Tut ve Önizle",
  "ListenCount": "{0} dinleme",
  "ListenReactionMulti": "Ağında {0} dinleyici",
  "ListenReactionSingle": "{0} bunu dinliyor",
  "LocalFile": "Yerel Dosya",
  "More": "Daha fazla",
  "Pause": "Duraklat",
  "Play": "Çal",
  "Playlist": "Çalma listesi",
  "PressEnterToPlay": "Çalmak için Enter'a bas",
  "Popularity": "Popülerlik",
  "Remove": "Çıkar",
  "RemoveYourMusic": "Müziklerin'den çıkar",
  "Save": "Kaydet",
  "SaveYourMusic": "Müziklerin'e kaydet",
  "Saved": "Kaydedildi",
  "ShufflePlay": "Karışık Çal",
  "Song": "Şarkı",
  "StartRadio": "Radyoyu Başlat",
  "Time": "Saat",
  "Toplist": "En çok dinlenen şarkılar",
  "Track": "Şarkı",
  "Unfollow": "Takip Etmeyi Bırak",
  "User": "Kullanıcı",
  "ViewAll": "Tümünü Görüntüle",
  "HoursShort": "{0} sa",
  "MinutesShort": "{0} dk",
  "SecondsShort": "{0} sn",
  "ErrorTitle": "Bu öğe görüntülenirken bir sorun oluştu!",
  "ErrorMessage": "Bu görünüm yok veya bir hata oluştu.",
  "OfflineTitle": "Bu görünüm çevrimdışıyken kullanılamaz!",
  "OfflineMessage": "Yüklemek için lütfen çevrimiçi ol."
};
},{}],80:[function(require,module,exports){
module.exports = {
  "Album": "專輯",
  "AndMore": "還有 {0} 首",
  "Artist": "藝人",
  "By": "－",
  "Create Similar Playlist": "建立相似的播放清單",
  "Filter": "篩選",
  "Follow": "關注",
  "Follower": "粉絲",
  "FollowersLabel": "關注者",
  "Following": "正在關注",
  "FollowingLabel": "正在關注",
  "ListenersLabel": "每月聽眾",
  "FollowsYou": "關注你",
  "HoldToPreview": "按住即可預覽",
  "ListenCount": "播放了 {0} 次",
  "ListenReactionMulti": "在你的社群網路中有 {0} 名聽眾",
  "ListenReactionSingle": "{0} 收聽了這首歌曲",
  "LocalFile": "本機檔案",
  "More": "更多",
  "Pause": "暫停",
  "Play": "播放",
  "Playlist": "播放列表",
  "PressEnterToPlay": "請按 Enter 播放",
  "Popularity": "流行",
  "Remove": "移除",
  "RemoveYourMusic": "從你的音樂中移除",
  "Save": "儲存",
  "SaveYourMusic": "儲存至你的音樂",
  "Saved": "已儲存",
  "ShufflePlay": "隨機播放",
  "Song": "歌曲",
  "StartRadio": "啟用電臺",
  "Time": "時間",
  "Toplist": "當紅歌曲",
  "Track": "歌曲",
  "Unfollow": "取消關注",
  "User": "使用者",
  "ViewAll": "檢視全部",
  "HoursShort": "{0} 小時",
  "MinutesShort": "{0} 分鐘",
  "SecondsShort": "{0} 秒鐘",
  "ErrorTitle": "顯示這個畫面時出現問題。",
  "ErrorMessage": "這個畫面可能不存在或發生錯誤。",
  "OfflineTitle": "離線時無法使用這個檢視！",
  "OfflineMessage": "請上網以載入。"
};
},{}],81:[function(require,module,exports){
module.exports = {
  "Album": "Album",
  "AndMore": "dan {0} lagi",
  "Artist": "Artis",
  "By": "oleh",
  "Create Similar Playlist": "Cipta Senarai Main Serupa",
  "Filter": "Penapis",
  "Follow": "Ikut",
  "Follower": "Pengikut",
  "FollowersLabel": "Pengikut",
  "Following": "Mengikuti",
  "FollowingLabel": "Mengikuti",
  "ListenersLabel": "Pendengar Bulanan",
  "FollowsYou": "Megikuti Anda",
  "HoldToPreview": "Klik dan Tahan untuk Pratonton",
  "ListenCount": "{0} main",
  "ListenReactionMulti": "{0} pendengar dalam rangkaian anda",
  "ListenReactionSingle": "{0} mendengar ini",
  "LocalFile": "Fail Setempat",
  "More": "Lebih banyak",
  "Pause": "Jeda",
  "Play": "Main",
  "Playlist": "Senarai main",
  "PressEnterToPlay": "Tekan Enter untuk main",
  "Popularity": "Populariti",
  "Remove": "Keluarkan",
  "RemoveYourMusic": "Keluarkan daripada Muzik Anda",
  "Save": "Simpan",
  "SaveYourMusic": "Simpan ke Muzik Anda",
  "Saved": "Disimpan",
  "ShufflePlay": "Main Rombak",
  "Song": "Lagu",
  "StartRadio": "Mulakan Radio",
  "Time": "Masa",
  "Toplist": "Lagu popular",
  "Track": "Lagu",
  "Unfollow": "Nyahikut",
  "User": "Pengguna",
  "ViewAll": "Lihat Semua",
  "HoursShort": "{0} jam",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} saat",
  "ErrorTitle": "Terdapat masalah memaparkan paparan ini!",
  "ErrorMessage": "Paparan ini sama ada tidak wujud atau ralat berlaku.",
  "OfflineTitle": "Paparan ini tidak tersedia di luar talian!",
  "OfflineMessage": "Sila ke online untuk memuatkan."
};
},{}],82:[function(require,module,exports){
'use strict';

module.exports = {
  'de': require('../i18n/de.lang'),
  'el': require('../i18n/el.lang'),
  'en': require('../i18n/en.lang'),
  'es': require('../i18n/es.lang'),
  'es-419': require('../i18n/es-419.lang'),
  'fi': require('../i18n/fi.lang'),
  'fr': require('../i18n/fr.lang'),
  'fr-CA': require('../i18n/fr-CA.lang'),
  'hu': require('../i18n/hu.lang'),
  'id': require('../i18n/id.lang'),
  'it': require('../i18n/it.lang'),
  'ja': require('../i18n/ja.lang'),
  'nl': require('../i18n/nl.lang'),
  'pl': require('../i18n/pl.lang'),
  'pt-BR': require('../i18n/pt-BR.lang'),
  'sv': require('../i18n/sv.lang'),
  'tr': require('../i18n/tr.lang'),
  'zh-Hant': require('../i18n/zh-Hant.lang'),
  'zsm': require('../i18n/zsm.lang')
};

},{"../i18n/de.lang":63,"../i18n/el.lang":64,"../i18n/en.lang":65,"../i18n/es-419.lang":66,"../i18n/es.lang":67,"../i18n/fi.lang":68,"../i18n/fr-CA.lang":69,"../i18n/fr.lang":70,"../i18n/hu.lang":71,"../i18n/id.lang":72,"../i18n/it.lang":73,"../i18n/ja.lang":74,"../i18n/nl.lang":75,"../i18n/pl.lang":76,"../i18n/pt-BR.lang":77,"../i18n/sv.lang":78,"../i18n/tr.lang":79,"../i18n/zh-Hant.lang":80,"../i18n/zsm.lang":81}],83:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
var partial$0 = require('./media/image.hbs');
HandlebarsCompiler.registerPartial('./media/image.hbs', partial$0);
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); partials = this.merge(partials, Handlebars.partials); data = data || {};
  var buffer = "", stack1, helper, options, functionType="function", escapeExpression=this.escapeExpression, helperMissing=helpers.helperMissing, self=this, blockHelperMissing=helpers.blockHelperMissing;

function program1(depth0,data) {
  
  var buffer = "", stack1, helper, options;
  buffer += "\n  <div class=\"facepile\" data-tooltip title=\"";
  if (helper = helpers.name) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.name); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-tooltip-instant>\n    <div class=\"media-object media-object-image media-object-link media-object-simple media-object-"
    + escapeExpression((helper = helpers.type || (depth0 && depth0.type),options={hash:{},data:data},helper ? helper.call(depth0, (depth0 && depth0.uri), options) : helperMissing.call(depth0, "type", (depth0 && depth0.uri), options)))
    + " ";
  options={hash:{},inverse:self.program(2, program2, data),fn:self.noop,data:data}
  if (helper = helpers.imageUrl) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.imageUrl); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.imageUrl) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.program(2, program2, data),fn:self.noop,data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\"\n      data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"\n      data-log-context=\"media-object\"\n      data-contextmenu>\n      <div class=\"mo-wrapper\">\n        <div class=\"mo-image-wrapper\">\n          <a href=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-log-click=\"media-image\">\n            ";
  stack1 = self.invokePartial(partials['./media/image.hbs'], './media/image.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n          </a>\n        </div>\n      </div>\n    </div>\n  </div>\n";
  return buffer;
  }
function program2(depth0,data) {
  
  
  return "show-placeholder";
  }

function program4(depth0,data,depth1) {
  
  var buffer = "", stack1, helper;
  buffer += "\n  <button\n    type=\"button\"\n    class=\"button facepile-badge\"\n    title=\"";
  if (helper = helpers.badgeTooltip) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.badgeTooltip); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"\n    data-tooltip\n    data-tooltip-instant\n    data-modal=\"spotify:modal:socialproof:"
    + escapeExpression(((stack1 = (depth1 && depth1.uri)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\"\n  >\n    +";
  if (helper = helpers.badgeCount) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.badgeCount); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\n  </button>\n";
  return buffer;
  }

  stack1 = (helper = helpers.facepile || (depth0 && depth0.facepile),options={hash:{},inverse:self.programWithDepth(4, program4, data, depth0),fn:self.program(1, program1, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.listeners), (depth0 && depth0.totalListeners), options) : helperMissing.call(depth0, "facepile", (depth0 && depth0.listeners), (depth0 && depth0.totalListeners), options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n";
  return buffer;
  });

},{"./media/image.hbs":87,"hbsfy/runtime":179}],84:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
var partial$0 = require('./media/image.hbs');
HandlebarsCompiler.registerPartial('./media/image.hbs', partial$0);
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); partials = this.merge(partials, Handlebars.partials); data = data || {};
  var buffer = "", stack1, helper, options, self=this, functionType="function", escapeExpression=this.escapeExpression, blockHelperMissing=helpers.blockHelperMissing, helperMissing=helpers.helperMissing;

function program1(depth0,data) {
  
  
  return "multiline";
  }

function program3(depth0,data) {
  
  var stack1;
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.totalListeners), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { return stack1; }
  else { return ''; }
  }

function program5(depth0,data) {
  
  
  return "auxiliary";
  }

function program7(depth0,data) {
  
  
  return "unread";
  }

function program9(depth0,data) {
  
  var stack1, helper;
  if (helper = helpers.url) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.url); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  return escapeExpression(stack1);
  }

function program11(depth0,data) {
  
  var stack1, helper;
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  return escapeExpression(stack1);
  }

function program13(depth0,data) {
  
  
  return "show-placeholder";
  }

function program15(depth0,data) {
  
  var buffer = "", stack1, helper, options;
  buffer += "\n        <span class=\"text-secondary\">\n          ";
  options={hash:{},inverse:self.noop,fn:self.program(16, program16, data),data:data}
  if (helper = helpers.icon) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.icon); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.icon) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.noop,fn:self.program(16, program16, data),data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n          ";
  if (helper = helpers.text) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.text); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\n        </span>\n      ";
  return buffer;
  }
function program16(depth0,data) {
  
  var buffer = "";
  buffer += "<span class=\"spoticon-"
    + escapeExpression((typeof depth0 === functionType ? depth0.apply(depth0) : depth0))
    + "-16\"></span>";
  return buffer;
  }

function program18(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n        ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.totalListeners), {hash:{},inverse:self.noop,fn:self.program(19, program19, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      ";
  return buffer;
  }
function program19(depth0,data) {
  
  var buffer = "", stack1, helper, options;
  buffer += "\n        <span class=\"text-secondary socialproof\" data-log-data='{\"socialProofTotalListeners\":\"";
  if (helper = helpers.totalListeners) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.totalListeners); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"}'>\n          <span class=\"text-muted one-line\" ";
  stack1 = (helper = helpers.compare || (depth0 && depth0.compare),options={hash:{},inverse:self.program(22, program22, data),fn:self.program(20, program20, data),data:data},helper ? helper.call(depth0, 1, (depth0 && depth0.totalListeners), options) : helperMissing.call(depth0, "compare", 1, (depth0 && depth0.totalListeners), options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += ">\n            "
    + escapeExpression((helper = helpers.userReaction || (depth0 && depth0.userReaction),options={hash:{},data:data},helper ? helper.call(depth0, (depth0 && depth0.listeners), (depth0 && depth0.totalListeners), "Listen", options) : helperMissing.call(depth0, "userReaction", (depth0 && depth0.listeners), (depth0 && depth0.totalListeners), "Listen", options)))
    + "\n          </span>\n        </span>\n        ";
  return buffer;
  }
function program20(depth0,data) {
  
  var buffer = "";
  return buffer;
  }

function program22(depth0,data) {
  
  var buffer = "", helper, options;
  buffer += "data-tooltip=\""
    + escapeExpression((helper = helpers.nameListTooltip || (depth0 && depth0.nameListTooltip),options={hash:{},data:data},helper ? helper.call(depth0, (depth0 && depth0.listeners), (depth0 && depth0.totalListeners), options) : helperMissing.call(depth0, "nameListTooltip", (depth0 && depth0.listeners), (depth0 && depth0.totalListeners), options)))
    + "\"";
  return buffer;
  }

function program24(depth0,data) {
  
  var buffer = "", stack1, helper, options;
  buffer += "\n        <div class=\"auxiliary-box\">\n          <span class=\"text-meta text-muted one-line\">";
  if (helper = helpers.text) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.text); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</span>\n          ";
  options={hash:{},inverse:self.noop,fn:self.program(25, program25, data),data:data}
  if (helper = helpers.icon) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.icon); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.icon) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.noop,fn:self.program(25, program25, data),data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n        </div>\n      ";
  return buffer;
  }
function program25(depth0,data) {
  
  var buffer = "";
  buffer += "<div class=\"auxiliary-icon spoticon-"
    + escapeExpression((typeof depth0 === functionType ? depth0.apply(depth0) : depth0))
    + "-16\"></div>";
  return buffer;
  }

  buffer += "<div\n  class=\"\n    list-group-item\n    list-group-item-media\n    ";
  options={hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data}
  if (helper = helpers.subtitle) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.subtitle); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.subtitle) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    ";
  options={hash:{},inverse:self.noop,fn:self.program(3, program3, data),data:data}
  if (helper = helpers.socialproof) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.socialproof); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.socialproof) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.noop,fn:self.program(3, program3, data),data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    ";
  options={hash:{},inverse:self.noop,fn:self.program(5, program5, data),data:data}
  if (helper = helpers.auxiliary) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.auxiliary); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.auxiliary) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.noop,fn:self.program(5, program5, data),data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    ";
  options={hash:{},inverse:self.noop,fn:self.program(7, program7, data),data:data}
  if (helper = helpers.unread) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.unread); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.unread) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.noop,fn:self.program(7, program7, data),data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    ";
  if (helper = helpers.modifiers) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.modifiers); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\n  \">\n  <a href=\"";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.url), {hash:{},inverse:self.program(11, program11, data),fn:self.program(9, program9, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\"\n    data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"\n    data-log-data='{\"target_uri\": \"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\", \"name\": \"";
  if (helper = helpers.name) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.name); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"}'\n    data-contextmenu\n    data-drag-text>\n    <div class=\"media-object media-object-simple media-object-link media-object-"
    + escapeExpression((helper = helpers.type || (depth0 && depth0.type),options={hash:{},data:data},helper ? helper.call(depth0, (depth0 && depth0.uri), options) : helperMissing.call(depth0, "type", (depth0 && depth0.uri), options)))
    + " ";
  options={hash:{},inverse:self.program(13, program13, data),fn:self.noop,data:data}
  if (helper = helpers.imageUrl) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.imageUrl); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.imageUrl) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.program(13, program13, data),fn:self.noop,data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\">\n      <div class=\"mo-image-wrapper\">\n        ";
  stack1 = self.invokePartial(partials['./media/image.hbs'], './media/image.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      </div>\n    </div>\n    <div class=\"item-data \">\n      <span>";
  if (helper = helpers.name) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.name); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</span>\n      ";
  options={hash:{},inverse:self.noop,fn:self.program(15, program15, data),data:data}
  if (helper = helpers.subtitle) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.subtitle); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.subtitle) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.noop,fn:self.program(15, program15, data),data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n      ";
  options={hash:{},inverse:self.noop,fn:self.program(18, program18, data),data:data}
  if (helper = helpers.socialproof) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.socialproof); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.socialproof) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.noop,fn:self.program(18, program18, data),data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n      ";
  options={hash:{},inverse:self.noop,fn:self.program(24, program24, data),data:data}
  if (helper = helpers.auxiliary) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.auxiliary); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.auxiliary) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.noop,fn:self.program(24, program24, data),data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    </div>\n  </a>\n  <button class=\"button button-play list-group-item-media-play\" data-log-click=\"play-button\" data-button=\"play-context\"></button>\n</div>\n";
  return buffer;
  });

},{"./media/image.hbs":87,"hbsfy/runtime":179}],85:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
var partial$0 = require('./media/image.hbs');
HandlebarsCompiler.registerPartial('./media/image.hbs', partial$0);
var partial$1 = require('./media/controllers.hbs');
HandlebarsCompiler.registerPartial('./media/controllers.hbs', partial$1);
var partial$2 = require('./media/info.hbs');
HandlebarsCompiler.registerPartial('./media/info.hbs', partial$2);
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); partials = this.merge(partials, Handlebars.partials); data = data || {};
  var buffer = "", stack1, helper, options, functionType="function", escapeExpression=this.escapeExpression, helperMissing=helpers.helperMissing, self=this, blockHelperMissing=helpers.blockHelperMissing;

function program1(depth0,data) {
  
  
  return "data-context";
  }

function program3(depth0,data) {
  
  
  return "\"mo-wide-image-wrapper\"";
  }

function program5(depth0,data) {
  
  
  return "\"mo-image-wrapper\"";
  }

function program7(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n        <div data-drag-text=\"";
  if (helper = helpers.title) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.title); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-log-click=\"media-image\" draggable=\"true\">\n      ";
  return buffer;
  }

function program9(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n        <a data-drag-text=\"";
  if (helper = helpers.title) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.title); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" href=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-log-click=\"media-image\">\n      ";
  return buffer;
  }

function program11(depth0,data) {
  
  
  return "\n        </div>\n      ";
  }

function program13(depth0,data) {
  
  
  return "\n        </a>\n      ";
  }

  buffer += "<div class=\"media-object media-object-"
    + escapeExpression((helper = helpers.type || (depth0 && depth0.type),options={hash:{},data:data},helper ? helper.call(depth0, (depth0 && depth0.uri), options) : helperMissing.call(depth0, "type", (depth0 && depth0.uri), options)))
    + " ";
  if (helper = helpers.modifiers) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.modifiers); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"\n  ";
  options={hash:{},inverse:self.program(1, program1, data),fn:self.noop,data:data}
  if (helper = helpers.noContext) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.noContext); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.noContext) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.program(1, program1, data),fn:self.noop,data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"\n  data-log-context=\"media-object\" data-log-data='{ \"name\": \"";
  if (helper = helpers.name) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.name); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\", \"target_uri\": \"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" }' data-contextmenu>\n  <div class=\"mo-wrapper\">\n    <div class=";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.wideImage), {hash:{},inverse:self.program(5, program5, data),fn:self.program(3, program3, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += ">\n      ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.noLink), {hash:{},inverse:self.program(9, program9, data),fn:self.program(7, program7, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n      ";
  stack1 = self.invokePartial(partials['./media/image.hbs'], './media/image.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      <div class=\"mo-overlay\"></div>\n\n      ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.noLink), {hash:{},inverse:self.program(13, program13, data),fn:self.program(11, program11, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n      ";
  stack1 = self.invokePartial(partials['./media/controllers.hbs'], './media/controllers.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    </div>\n    ";
  stack1 = self.invokePartial(partials['./media/info.hbs'], './media/info.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  </div>\n</div>\n";
  return buffer;
  });

},{"./media/controllers.hbs":86,"./media/image.hbs":87,"./media/info.hbs":88,"hbsfy/runtime":179}],86:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, options, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, self=this, functionType="function", blockHelperMissing=helpers.blockHelperMissing;

function program1(depth0,data) {
  
  var buffer = "", stack1, helper, options;
  buffer += "\n  ";
  stack1 = (helper = helpers.type || (depth0 && depth0.type),options={hash:{},inverse:self.noop,fn:self.program(2, program2, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.uri), "track", "album", options) : helperMissing.call(depth0, "type", (depth0 && depth0.uri), "track", "album", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  ";
  stack1 = (helper = helpers.type || (depth0 && depth0.type),options={hash:{},inverse:self.noop,fn:self.program(4, program4, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.uri), "playlist", "station", "artist", options) : helperMissing.call(depth0, "type", (depth0 && depth0.uri), "playlist", "station", "artist", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n";
  return buffer;
  }
function program2(depth0,data) {
  
  var buffer = "", helper, options;
  buffer += "\n    <button type=\"button\" data-button=\"add\" class=\"button button-icon-only button-add mo-add\" data-tooltip=\""
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Save", options) : helperMissing.call(depth0, "loc", "Save", options)))
    + "\" data-tooltip-add=\""
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Save", options) : helperMissing.call(depth0, "loc", "Save", options)))
    + "\" data-tooltip-remove=\""
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Remove", options) : helperMissing.call(depth0, "loc", "Remove", options)))
    + "\" data-log-click=\"add-button\"></button>\n  ";
  return buffer;
  }

function program4(depth0,data) {
  
  var buffer = "", stack1, helper, options;
  buffer += "\n    ";
  options={hash:{},inverse:self.program(5, program5, data),fn:self.noop,data:data}
  if (helper = helpers.currentUserPlaylist) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.currentUserPlaylist); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.currentUserPlaylist) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.program(5, program5, data),fn:self.noop,data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  ";
  return buffer;
  }
function program5(depth0,data) {
  
  var buffer = "", helper, options;
  buffer += "\n    <button type=\"button\" data-button=\"add\" class=\"button button-icon-only button-add mo-add\" data-tooltip=\""
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Follow", options) : helperMissing.call(depth0, "loc", "Follow", options)))
    + "\" data-tooltip-add=\""
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Follow", options) : helperMissing.call(depth0, "loc", "Follow", options)))
    + "\" data-tooltip-remove=\""
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Unfollow", options) : helperMissing.call(depth0, "loc", "Unfollow", options)))
    + "\" data-log-click=\"follow-button\"></button>\n    ";
  return buffer;
  }

function program7(depth0,data) {
  
  var buffer = "", stack1, helper, options;
  buffer += "\n    data-button=\"play\"\n    ";
  options={hash:{},inverse:self.noop,fn:self.program(8, program8, data),data:data}
  if (helper = helpers.range) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.range); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.range) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.noop,fn:self.program(8, program8, data),data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  ";
  return buffer;
  }
function program8(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "data-range=\"";
  if (helper = helpers.start) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.start); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + ",";
  if (helper = helpers.end) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.end); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"";
  return buffer;
  }

function program10(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n    ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.contextPage), {hash:{},inverse:self.program(14, program14, data),fn:self.program(11, program11, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  ";
  return buffer;
  }
function program11(depth0,data) {
  
  var buffer = "", stack1, helper, options;
  buffer += "\n      data-button=\"play\"\n      ";
  options={hash:{},inverse:self.noop,fn:self.program(12, program12, data),data:data}
  if (helper = helpers.contextPage) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.contextPage); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.contextPage) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.noop,fn:self.program(12, program12, data),data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    ";
  return buffer;
  }
function program12(depth0,data) {
  
  var buffer = "";
  buffer += "data-context-page=\""
    + escapeExpression((typeof depth0 === functionType ? depth0.apply(depth0) : depth0))
    + "\"";
  return buffer;
  }

function program14(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n      ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.trackUri), {hash:{},inverse:self.program(18, program18, data),fn:self.program(15, program15, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    ";
  return buffer;
  }
function program15(depth0,data) {
  
  var buffer = "", stack1, helper, options;
  buffer += "\n        ";
  options={hash:{},inverse:self.noop,fn:self.program(16, program16, data),data:data}
  if (helper = helpers.trackUri) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.trackUri); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.trackUri) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.noop,fn:self.program(16, program16, data),data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n        data-button=\"play\"\n      ";
  return buffer;
  }
function program16(depth0,data) {
  
  var buffer = "";
  buffer += "data-track-uri=\""
    + escapeExpression((typeof depth0 === functionType ? depth0.apply(depth0) : depth0))
    + "\"";
  return buffer;
  }

function program18(depth0,data) {
  
  
  return "\n        data-button=\"play-context\"\n      ";
  }

function program20(depth0,data) {
  
  var buffer = "", helper, options;
  buffer += "data-tooltip=\""
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "HoldToPreview", options) : helperMissing.call(depth0, "loc", "HoldToPreview", options)))
    + "\"";
  return buffer;
  }

function program22(depth0,data) {
  
  var buffer = "", helper, options;
  buffer += "\n  <button type=\"button\" data-button=\"contextmenu\" class=\"button button-icon-only button-more mo-more\" data-tooltip=\""
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "More", options) : helperMissing.call(depth0, "loc", "More", options)))
    + "\" data-log-click=\"context-menu-button\"></button>\n";
  return buffer;
  }

function program24(depth0,data) {
  
  
  return "\n<button type=\"button\" class=\"button button-icon-only mo-delete\" data-log-click=\"delete-button\"></button>\n";
  }

  stack1 = (helper = helpers.type || (depth0 && depth0.type),options={hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.uri), "playlist", "track", "album", "station", "artist", options) : helperMissing.call(depth0, "type", (depth0 && depth0.uri), "playlist", "track", "album", "station", "artist", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n<button type=\"button\" class=\"button button-play mo-play\" data-log-click=\"play-button\"\n  ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.range), {hash:{},inverse:self.program(10, program10, data),fn:self.program(7, program7, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n  ";
  options={hash:{},inverse:self.noop,fn:self.program(20, program20, data),data:data}
  if (helper = helpers.preview) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.preview); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.preview) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.noop,fn:self.program(20, program20, data),data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += ">\n</button>\n\n";
  stack1 = (helper = helpers.type || (depth0 && depth0.type),options={hash:{},inverse:self.noop,fn:self.program(22, program22, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.uri), "playlist", "track", "album", "artist", options) : helperMissing.call(depth0, "type", (depth0 && depth0.uri), "playlist", "track", "album", "artist", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n";
  options={hash:{},inverse:self.noop,fn:self.program(24, program24, data),data:data}
  if (helper = helpers.canDelete) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.canDelete); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.canDelete) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.noop,fn:self.program(24, program24, data),data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n";
  return buffer;
  });

},{"hbsfy/runtime":179}],87:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, options, functionType="function", escapeExpression=this.escapeExpression, self=this, helperMissing=helpers.helperMissing;

function program1(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n  <div class=\"mo-image-background-color\">\n    ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.imageUrl), {hash:{},inverse:self.noop,fn:self.program(2, program2, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  </div>\n";
  return buffer;
  }
function program2(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n      <div class=\"mo-image-background\" style=\"background-image: url('";
  if (helper = helpers.imageUrl) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.imageUrl); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "')\"></div>\n    ";
  return buffer;
  }

function program4(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n  <div class=\"mo-wide-image\" ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.imageUrl), {hash:{},inverse:self.noop,fn:self.program(5, program5, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += ">\n";
  return buffer;
  }
function program5(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "style=\"background-image: url('";
  if (helper = helpers.imageUrl) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.imageUrl); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "')\"";
  return buffer;
  }

function program7(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n  <div class=\"mo-image\" ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.imageUrl), {hash:{},inverse:self.noop,fn:self.program(5, program5, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += ">\n";
  return buffer;
  }

  buffer += "<svg class=\"mo-placeholder\" viewBox=\"0 0 10 10\" preserveAspectRatio=\"xMidYMid meet\">\n  <text class=\"playlist-placeholder\" x=\"5\" y=\"9.8\">&#xf135;</text>\n  <text class=\"playlist-folder-placeholder\" x=\"5\" y=\"9.8\">&#xf137;</text>\n  <text class=\"album-placeholder\" x=\"5\" y=\"9.8\">&#xf101;</text>\n  <text class=\"artist-placeholder\" x=\"5\" y=\"9.8\">&#xf103;</text>\n  <text class=\"user-placeholder\" x=\"5\" y=\"9.8\">&#xf15d;</text>\n  <text class=\"genre-placeholder\" x=\"5\" y=\"9.8\">&#xf109;</text>\n  <text class=\"collection-placeholder\" x=\"5\" y=\"9.8\">&#xf157;</text>\n  <text class=\"local-files-placeholder\" x=\"5\" y=\"9.8\">&#xf1fb;</text>\n</svg>\n\n";
  stack1 = (helper = helpers.type || (depth0 && depth0.type),options={hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.uri), "user", "artist", options) : helperMissing.call(depth0, "type", (depth0 && depth0.uri), "user", "artist", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.wideImage), {hash:{},inverse:self.program(7, program7, data),fn:self.program(4, program4, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n</div>\n<span class=\"mo-verified\">\n  <span class=\"spoticon-check-16\"></span>\n</span>\n";
  return buffer;
  });

},{"hbsfy/runtime":179}],88:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
var partial$0 = require('./../facepile-common.hbs');
HandlebarsCompiler.registerPartial('./../facepile-common.hbs', partial$0);
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); partials = this.merge(partials, Handlebars.partials); data = data || {};
  var buffer = "", stack1, helper, options, functionType="function", escapeExpression=this.escapeExpression, self=this, blockHelperMissing=helpers.blockHelperMissing;

function program1(depth0,data) {
  
  
  return "meta";
  }

function program3(depth0,data) {
  
  
  return "description";
  }

function program5(depth0,data) {
  
  
  return "socialproof";
  }

function program7(depth0,data) {
  
  
  return "subtitle";
  }

function program9(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n      <div class=\"mo-title\" title=\"";
  if (helper = helpers.name) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.name); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-log-click=\"media-title\" draggable=\"true\">\n    ";
  return buffer;
  }

function program11(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n      <a class=\"mo-title\" title=\"";
  if (helper = helpers.name) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.name); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" href=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-log-click=\"media-title\">\n    ";
  return buffer;
  }

function program13(depth0,data) {
  
  
  return "\n      </div>\n    ";
  }

function program15(depth0,data) {
  
  
  return "\n      </a>\n    ";
  }

function program17(depth0,data) {
  
  var buffer = "", stack1, helper, options;
  buffer += "\n      <div class=\"mo-subtitle text-muted one-line\">\n        ";
  options={hash:{},inverse:self.noop,fn:self.program(18, program18, data),data:data}
  if (helper = helpers.artists) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.artists); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.artists) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.noop,fn:self.program(18, program18, data),data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n        ";
  options={hash:{},inverse:self.noop,fn:self.program(20, program20, data),data:data}
  if (helper = helpers.owner) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.owner); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.owner) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.noop,fn:self.program(20, program20, data),data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      </div>\n    ";
  return buffer;
  }
function program18(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n          <a title=\"";
  if (helper = helpers.name) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.name); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" href=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-log-click=\"artist-name\">";
  if (helper = helpers.name) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.name); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</a>\n        ";
  return buffer;
  }

function program20(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n          <a title=\"";
  if (helper = helpers.name) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.name); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" href=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-log-click=\"owner-name\">";
  if (helper = helpers.name) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.name); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</a>\n        ";
  return buffer;
  }

function program22(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n      <div class=\"mo-description\">";
  if (helper = helpers.description) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.description); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</div>\n    ";
  return buffer;
  }

function program24(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n      ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.totalListeners), {hash:{},inverse:self.noop,fn:self.program(25, program25, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    ";
  return buffer;
  }
function program25(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n        ";
  stack1 = self.invokePartial(partials['./../facepile-common.hbs'], './../facepile-common.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      ";
  return buffer;
  }

function program27(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n      <div class=\"mo-meta\">";
  if (helper = helpers.meta) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.meta); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</div>\n    ";
  return buffer;
  }

  buffer += "<div class=\"mo-info ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.meta), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.description), {hash:{},inverse:self.noop,fn:self.program(3, program3, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.socialproof), {hash:{},inverse:self.noop,fn:self.program(5, program5, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  options={hash:{},inverse:self.program(7, program7, data),fn:self.noop,data:data}
  if (helper = helpers.hideSubtitle) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.hideSubtitle); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.hideSubtitle) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.program(7, program7, data),fn:self.noop,data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\" data-log-context=\"media-info\">\n  <div class=\"mo-info-wrapper\">\n    ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.noLink), {hash:{},inverse:self.program(11, program11, data),fn:self.program(9, program9, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n        <span class=\"mo-title-border\">\n          ";
  if (helper = helpers.name) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.name); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\n          <span class=\"ellipsis\">&nbsp;</span>\n        </span>\n    ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.noLink), {hash:{},inverse:self.program(15, program15, data),fn:self.program(13, program13, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n    ";
  options={hash:{},inverse:self.program(17, program17, data),fn:self.noop,data:data}
  if (helper = helpers.hideSubtitle) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.hideSubtitle); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.hideSubtitle) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.program(17, program17, data),fn:self.noop,data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n    ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.description), {hash:{},inverse:self.noop,fn:self.program(22, program22, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n    ";
  options={hash:{},inverse:self.noop,fn:self.program(24, program24, data),data:data}
  if (helper = helpers.socialproof) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.socialproof); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.socialproof) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.noop,fn:self.program(24, program24, data),data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n    ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.meta), {hash:{},inverse:self.noop,fn:self.program(27, program27, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    <div class=\"media-link-hider\"></div>\n    ";
  if (helper = helpers.customContent) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.customContent); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  </div>\n</div>\n";
  return buffer;
  });

},{"./../facepile-common.hbs":83,"hbsfy/runtime":179}],89:[function(require,module,exports){
'use strict';

// Usage
// Data {{#compare 'myvalue' value}}has{{else}}doesn't have{{/compare}} myvalue.
// Data {{#compare '5' tracks.length true}}has{{else}}doesn't have{{/compare}} 5 tracks.
// Data {{#compare tracks.length 5 operator='>'}}has more than{{else}}has less than or equal to{{/compare}} 5 tracks.

var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var operators = {
  '==': function _(a, b) {
    /* eslint eqeqeq: 0 */return a == b;
  },
  '===': function _(a, b) {
    return a === b;
  },
  '!=': function _(a, b) {
    /* eslint eqeqeq: 0 */return a != b;
  },
  '<': function _(a, b) {
    return a < b;
  },
  '>': function _(a, b) {
    return a > b;
  },
  '<=': function _(a, b) {
    return a <= b;
  },
  '>=': function _(a, b) {
    return a >= b;
  },
  'typeof': function _typeof(a, b) {
    return (typeof a === 'undefined' ? 'undefined' : _typeof2(a)) == b;
  }
};

function compare(a, b, s) {
  var options = arguments[arguments.length - 1];
  var soft = s !== options ? s : false;
  var operator = soft ? '==' : options.hash.operator || '===';

  var match = operators[operator](a, b);

  return match ? options.fn(this) : options.inverse(this);
}

compare.displayName = 'compare';

module.exports = compare;

},{}],90:[function(require,module,exports){
'use strict';

var duration = function duration(ms) {
  if (isNaN(ms)) return ms;

  var s = Math.round(ms / 1000);
  var oneMinute = 60;
  var oneHour = 60 * oneMinute;

  var hours = Math.floor(s / oneHour);
  var minutes = Math.floor(s % oneHour / oneMinute);
  var seconds = Math.round(s % oneHour % oneMinute);

  // Include hours if needed
  if (hours) {
    hours += ':';

    // If hours are specified, minutes should always be with two digits
    if (minutes < 10) minutes = '0' + minutes;
  } else {
    hours = '';
  }

  // Since minutes should always be displayed, seconds should always be with two digits
  if (seconds < 10) seconds = '0' + seconds;

  return hours + minutes + ':' + seconds;
};

duration.displayName = 'duration';

module.exports = duration;

},{}],91:[function(require,module,exports){
'use strict';

var nameListTooltip = require('./name-list-tooltip');

var facepile = function facepile(list, totalCount, mT, opts) {
  var options = opts;
  var minThresh = mT;

  if (!list) {
    return '';
  }

  if (arguments.length < 4) {
    options = minThresh;
    minThresh = 3;
  }

  minThresh = minThresh || 3;

  var len = list.length;
  var thresh = Math.min(minThresh, len);
  var ret = '';

  // Display faces.
  for (var i = 0; i < thresh; i++) {
    var obj = list[i];
    obj.modifiers = 'media-object-link media-object-simple';
    ret += options.fn(obj);
  }

  // Display badge count for hidden listeners.
  if (totalCount > thresh) {
    ret += options.inverse({
      badgeCount: totalCount - thresh,
      badgeTooltip: nameListTooltip(list.slice(thresh), totalCount - thresh)
    });
  }
  return ret;
};

facepile.displayName = 'facepile';

module.exports = facepile;

},{"./name-list-tooltip":97}],92:[function(require,module,exports){
(function (global){
'use strict';

var getHTTPLink = require('../util/link');

var isDesktop = !!global._getSpotifyModule;

var href = function href(uri) {
  if (isDesktop) return uri;
  return getHTTPLink(uri, 'https://play.spotify.com');
};

href.displayName = 'href';

module.exports = href;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../util/link":104}],93:[function(require,module,exports){
'use strict';

var loc = require('./loc');

var humanizeDuration = function humanizeDuration(ms) {
  if (isNaN(ms)) return ms;

  var s = Math.round(ms / 1000);
  var oneMinute = 60;
  var oneHour = 60 * oneMinute;

  var hours = Math.floor(s / oneHour);
  var minutes = Math.floor(s % oneHour / oneMinute);
  var seconds = Math.round(s % oneHour % oneMinute);

  var formattedDuration = '';

  if (hours) {
    formattedDuration += loc('HoursShort', hours, {});
  }

  if (minutes) {
    formattedDuration += ' ';
    formattedDuration += loc('MinutesShort', minutes, {});
  }

  if (!hours && !minutes || hours === 0 && minutes < 10) {
    formattedDuration += ' ';
    formattedDuration += loc('SecondsShort', seconds, {});
  }

  return formattedDuration.trim();
};

humanizeDuration.displayName = 'humanizeDuration';

module.exports = humanizeDuration;

},{"./loc":96}],94:[function(require,module,exports){
'use strict';

exports.compare = require('./compare');
exports.duration = require('./duration');
exports.facepile = require('./facepile');
exports.href = require('./href');
exports.humanizeDuration = require('./humanize-duration');
exports.list = require('./list');
exports.loc = require('./loc');
exports.nameListTooltip = require('./name-list-tooltip');
exports.numeral = require('./numeral');
exports.share = require('./share');
exports.slice = require('./slice');
exports.type = require('./type');
exports.userReaction = require('./user-reaction');

},{"./compare":89,"./duration":90,"./facepile":91,"./href":92,"./humanize-duration":93,"./list":95,"./loc":96,"./name-list-tooltip":97,"./numeral":98,"./share":99,"./slice":100,"./type":101,"./user-reaction":102}],95:[function(require,module,exports){
'use strict';

var map = require('mout/array/map');

var Handlebars = require('handlebars/dist/cjs/handlebars.runtime').default;

var lists = {};

var list = function list(array) {
  if (!array) {
    return '';
  }

  var args = Array.prototype.slice.call(arguments);
  var options = args.pop();
  var listID = args[1];

  if (array === 'reset') {
    delete lists[listID];
    return '';
  }

  if (listID && lists[listID] === undefined) {
    lists[listID] = -1;
  }

  return map(array, function (item, i) {
    var data = Handlebars.createFrame(options.data || {});
    data.index = listID ? ++lists[listID] : i;
    data.number = data.index + 1;
    data.localIndex = i;
    data.localNumber = i + 1;
    return options.fn(item, { data: data });
  }).join(options.hash && options.hash.join || '');
};

list.displayName = 'list';

module.exports = list;

},{"handlebars/dist/cjs/handlebars.runtime":172,"mout/array/map":187}],96:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var mixIn = require('mout/object/mixIn');
var slice_ = Array.prototype.slice;

var storage = {};

var loc = function loc(key) {
  var value = storage[key];

  if (!value) return '';

  var args = slice_.call(arguments, 1);
  var options = {};

  if (_typeof(args[args.length - 1]) === 'object') {
    options = args.pop();
  }

  var hash = options.hash;

  return value.replace(/\{([\w-]+)\}/g, function (full, match) {
    var n = +match;
    var interpolated;

    if (isNaN(n)) {
      interpolated = hash[match];
    } else {
      interpolated = args[n];
    }

    return interpolated !== null ? interpolated : '';
  });
};

loc.displayName = 'loc';

loc.register = function (object) {
  mixIn(storage, object);
  return this;
};

module.exports = loc;

},{"mout/object/mixIn":208}],97:[function(require,module,exports){
'use strict';

var loc = require('./loc');

var nameListTooltip = function nameListTooltip(users, totalCount) {
  if (totalCount === 0) {
    return undefined;
  }

  var len = users.length;
  var textTokens = users.map(function (user) {
    return user.name;
  });

  if (totalCount - len > 0) {
    var andMoreText = loc('AndMore', totalCount - len);
    textTokens.push(andMoreText);
  }

  return textTokens.join('<br>\n').replace(/'/g, '&#39;');
};

nameListTooltip.displayName = 'nameListTooltip';

module.exports = nameListTooltip;

},{"./loc":96}],98:[function(require,module,exports){
'use strict';

var isNumber = require('mout/lang/isNumber');

/**
 * If the first argument is a number, pipe it through spotify-numeral with an
 * optional format propety in the options hash, otherwise return it untouched.
 *
 * Example usage – results when using fr locale:
 *
 * {{numeral 1000}} -> '1 000'
 * {{numeral 1000 format='0,0.000'}} -> '1 000,000'
 * {{numeral 1000 format='$0,0.00'}} -> '€1 000,00'
 *
 * @param {Number|String} number - The number to format (or string to leave
 *     untouched).
 * @param {Object} [options] - The handlebars options object.
 * @param {Object} [options.hash] - The handlebars options hash object.
 * @param {String} [options.hash.format] - The optional format to pass to
 *     numeraljs.
 * @return {String} The formatted (or untouched) string.
 */
var numeralHelper = function numeralHelper(number, options) {
  var format = options && options.hash && options.hash.format;
  var numeral = numeralHelper._numeral;
  return isNumber(number) ? numeral(number).format(format) : number;
};

numeralHelper.displayName = 'numeral';

module.exports = numeralHelper;

// This is tricky, but is a way to allow for the locale to be injected
// from the consuming app instead of from within spotify-numeral, removing
// the dependency on spotify-quickstart.
module.exports.setLocale = function (locale) {
  numeralHelper._numeral = require('../../spotify-numeral')(locale);
};

},{"../../spotify-numeral":124,"mout/lang/isNumber":197}],99:[function(require,module,exports){
'use strict';

var getHTTPLink = require('../util/link');

var share = function share(uri) {
  return getHTTPLink(uri, 'https://open.spotify.com');
};

share.displayName = 'share';

module.exports = share;

},{"../util/link":104}],100:[function(require,module,exports){
'use strict';

var kindOf = require('mout/lang/kindOf');
var map = require('mout/array/map');
var forEach = require('mout/array/forEach');

var Handlebars = require('handlebars/dist/cjs/handlebars.runtime').default;
var slice_ = Array.prototype.slice;

var slice = function slice(arr) {
  var array = arr;

  if (!array) {
    return '';
  }

  var sep;
  var begin;
  var end;
  var options;

  forEach(slice_.call(arguments, 1), function (arg) {
    switch (kindOf(arg)) {
      case 'String':
        sep = arg;
        break;

      case 'Number':
        if (begin === null) {
          begin = arg;
        } else if (end === null) {
          end = arg;
        }
        break;

      case 'Object':
        options = arg;
        break;

      default:
      // Do nothing.
    }
  });

  if (begin !== null) {
    array = array.slice(begin, end !== null ? end : array.length);
  }

  return map(array, function (item) {
    var data = Handlebars.createFrame(options.data || {});

    return options.fn(item, { data: data });
  }).join(sep || '');
};

slice.displayName = 'slice';

module.exports = slice;

},{"handlebars/dist/cjs/handlebars.runtime":172,"mout/array/forEach":185,"mout/array/map":187,"mout/lang/kindOf":200}],101:[function(require,module,exports){
'use strict';

var getType = require('../util/type');

// This needs at least the uri param to get the type:
// {{type uri}}
//
// If you pass more parameters you can use it like a matcher:
// {{#type uri "track" "album"}}YAY{{/type}}
// This will print 'YAY' for tracks or albums.

var type = function type(uri) {
  if (arguments.length <= 2) {
    // Simple get type.
    return getType(uri);
  }

  // Match type.
  var context = arguments[arguments.length - 1];
  var success = false;
  var uriType = getType(uri);

  for (var i = 1; i < arguments.length - 1; i++) {
    if (uriType === arguments[i]) {
      success = true;
      break;
    }
  }

  return success ? context.fn(this) : context.inverse(this);
};

type.displayName = 'type';

module.exports = type;

},{"../util/type":105}],102:[function(require,module,exports){
'use strict';

var loc = require('./loc');

var userReaction = function userReaction(users, totalCount, reactionType) {
  if (!totalCount) return '';
  var key = reactionType + 'Reaction' + (totalCount > 1 ? 'Multi' : 'Single');

  if (totalCount > 1) {
    return loc(key, totalCount);
  }

  if (!users.length) {
    return '';
  }

  var firstListener = users[0].name;
  return loc(key, firstListener);
};

userReaction.displayName = 'userReaction';

module.exports = userReaction;

},{"./loc":96}],103:[function(require,module,exports){
'use strict';

var kindOf = require('mout/lang/kindOf');

var Handlebars = require('handlebars/dist/cjs/handlebars.runtime').default;

// Expose the runtime to make partials easier to register.
exports.runtime = Handlebars;

exports.register = function (helpers) {
  var list = {};

  if (kindOf(helpers) === 'Function') {
    list[helpers.displayName] = helpers;
  } else {
    list = helpers;
  }

  for (var key in list) {
    if (list.hasOwnProperty(key)) {
      Handlebars.registerHelper(key, list[key]);
    }
  }

  return this;
};

},{"handlebars/dist/cjs/handlebars.runtime":172,"mout/lang/kindOf":200}],104:[function(require,module,exports){
'use strict';

module.exports = function (uri, base) {
  var matches = (uri || '').match(/^spotify:(.+)$/);

  if (!matches) {
    return uri || '';
  }

  var parts = matches.pop().replace(/:$/, '').split(/:/);
  var type = parts.shift();

  if (type === 'search') {
    parts = [parts.join(':')];
  }

  parts.unshift(base, type);

  return parts.join('/');
};

},{}],105:[function(require,module,exports){
'use strict';

module.exports = function (uri) {
  if (!uri || !uri.split) {
    return null;
  }
  var parts = uri.split(':');
  var result = null;
  switch (parts[1]) {
    case 'album':
      // spotify:album:<id>:<disc>
      if (parts.length === 4) {
        return 'disc';
      } else if (parts.length === 3) {
        return 'album';
      }
      break;

    case 'artist':
      if (parts.length === 3) {
        return 'artist';
      }
      break;

    case 'track':
      if (parts.length === 3) {
        return 'track';
      }
      break;

    case 'genre':
      if (parts.length === 3) {
        return 'genre';
      }
      break;

    case 'station':
      if (parts.length > 3) {
        return 'station';
      }
      break;

    case 'local':
      if (parts.length === 6) {
        return 'track';
      } else if (parts.length === 4) {
        return 'album';
      } else if (parts.length === 3) {
        return 'artist';
      }
      break;

    case 'user':
      // spotify:user:<username>:collection
      if (parts.length > 3 && parts[3] === 'collection') {
        return 'collection';
      }

      // spotify:user:<username>:folder:<id>
      if (parts.length === 5 && parts[3] === 'folder') {
        return 'playlist-folder';
      }

      // spotify:user:<username>:<playlist:<id>|starred|toplist>
      if (parts.length > 3 && parts.length <= 5 && parts[2] !== 'facebook') {
        return 'playlist';
      } else if (parts.length === 3) {
        return 'user';
      }
      break;

    case 'internal':
      // spotify:internal:local-files
      return parts[2];

    case 'app':
      // spotify:app:collection:albums, spotify:app:radio
      return parts.slice(1).join('-');

    default:
    // Do nothing.
  }

  return result;
};

},{}],106:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var Translations = require('../spotify-translations');
var glueLocales = require('../spotify-glue-cat/strings');

module.exports = function (localeToStrings) {
  if (!localeToStrings || (typeof localeToStrings === 'undefined' ? 'undefined' : _typeof(localeToStrings)) !== 'object') {
    throw new Error('' + 'Locale strings must be a plain object. ' + 'See spotify-i18n/README.md');
  }

  function getClientLocale() {
    return typeof window !== 'undefined' && window.__spotify && window.__spotify.locale || 'en';
  }

  var locales = localeToStrings;
  var i18n = new Translations();
  i18n.injectData(locales[getClientLocale()] || {});

  return {
    locale: getClientLocale,
    get: i18n.get.bind(i18n),

    glueStrings: function glueStrings() {
      return glueLocales[getClientLocale()];
    },

    appStrings: function appStrings() {
      return locales[getClientLocale()];
    }
  };
};

},{"../spotify-glue-cat/strings":82,"../spotify-translations":141}],107:[function(require,module,exports){
(function (global){
/**
 * @module spotify-live-models/application
 */
'use strict';

var contains = require('mout/array/contains');
var live = require('../spotify-live');
var bridge = require('./util/bridge').request;
var AppState = require('../spotify-navigation/app-state');

var BACKOFF = 100;

function bridgeWait() {
  bridge('application_event_wait', [], function (error, event) {
    if (!registered) return;
    if (error) {
      setTimeout(function () {
        bridgeWait(model);
      }, BACKOFF);
      if (global.console) console.error(error);
      return;
    }

    var model = live('spotify:application');

    if (event.data && event.data.arguments) {
      model.update({
        arguments: event.data.arguments.join(':')
      });
    }

    // These don't won't happen on Zelda, there we handle it through postMessage. See onMessage.
    switch (event.type) {
      case 'activate':
        model.update({ 'active': true });
        break;

      case 'deactivate':
        model.update({ 'active': false });
        break;
    }

    bridgeWait(model);
  });
}

function onMessage(message) {
  var model = live('spotify:application');

  if (message.data && message.data.name) {
    if (message.data.name === 'set_active') {
      model.update({
        active: message.data.active
      });
    } else if (message.data.name === 'set_arguments') {
      // Arguments come as an array of un-encoded values, but we need to
      // concatenate them to a single colon-separated string for the
      // current design of the API. This is incorrect, as arguments should
      // be encoded if they are joined in a string. We should fix this, but
      // not without a breaking change.
      // https://jira.spotify.net/browse/KM-2353
      model.update({
        arguments: message.data.arguments.join(':')
      });
    } else if (message.data.name === 'set_state') {
      model.update({
        state: AppState.unserialize(message.data.state)
      });
    }
  }
}

function onRegister(model) {
  model.update({
    version: global.__spotify && global.__spotify.app_version || '0.0.0'
  });

  bridge('application_query', [], function (error, payload) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }

    var data = {};
    if (payload.uri) data.appURI = payload.uri;
    if (payload.arguments) data.arguments = payload.arguments.join(':');
    if ('active' in payload) data.active = payload.active;

    model.update(data);
  });
}

function applicationOpenUri(model, event) {
  bridge('application_open_uri', [event.uri]);
}

function applicationReplaceUri(model, event) {

  // This is intended to work like history.replace in the browser.

  // Desktop can also replace further back, so the current appURI needs
  // to be passed.
  // Link can't replace further back anyway, so anything thruthy as the
  // second argument will just replace the current.

  model.get('appURI', function (error, appUri) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }
    bridge('application_open_uri', [event.uri, appUri]);
  });
}

var regExp = exports.matches = /^spotify:application$/;
var registered;
exports.register = function () {
  if (registered) return;
  registered = true;

  live.subscribe(regExp, 'push-history-state', applicationOpenUri);
  live.subscribe(regExp, 'replace-history-state', applicationReplaceUri);
  global.addEventListener('message', onMessage);
  bridgeWait();
  onRegister(live('spotify:application'));
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  live.unsubscribe(regExp, 'push-history-state', applicationOpenUri);
  live.unsubscribe(regExp, 'replace-history-state', applicationReplaceUri);
  global.removeEventListener('message', onMessage);
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-live":109,"../spotify-navigation/app-state":122,"./util/bridge":108,"mout/array/contains":181}],108:[function(require,module,exports){
/**
 * @module spotify-live-models/util/bridge
 * @private
 */

'use strict';

var bridge = require('../../spotify-bridge-request');

module.exports = {
  request: bridge.request
};

},{"../../spotify-bridge-request":50}],109:[function(require,module,exports){
(function (global){
/**
 * @module live
 */'use strict';

// prime

var prime = require('prime');
var defer = require('prime/defer');
var Emitter = require('prime/emitter');

// mout
var isPlainObject = require('mout/lang/isPlainObject');
var isArray = require('mout/lang/isArray');
var isRegExp = require('mout/lang/isRegExp');
var isNumber = function isNumber(n) {
  return typeof n === 'number';
};
var isString = function isString(s) {
  return typeof s === 'string';
};

var escapeRegExp = require('mout/string/escapeRegExp');

var _difference = require('mout/array/difference');
var filter = require('mout/array/filter');
var combine = require('mout/array/combine');
var map = require('mout/array/map');

var deepMixIn = require('mout/object/deepMixIn');
var pick = require('mout/object/pick');
var keys = require('mout/object/keys');

// finally
var flow = require('finally');

// util
var OrderedSet = require('./util/ordered-set');
var Range = require('../spotify-range2');
var parse = require('./util/parser');
var throttle = require('./util/throttle');

// methods

var isLiveList = function isLiveList(item) {
  return item instanceof LiveList;
};

var isLiveObject = function isLiveObject(item) {
  return item instanceof LiveObject;
};

// Simple, stupid and fast.
// Shallow, not checking hasOwnProperty.
var simpleClone = function simpleClone(object) {
  var clone = {};
  for (var key in object) {
    clone[key] = object[key];
  }
  return clone;
};

var difference = function difference(a, b) {
  return a.length === 0 ? [] : _difference.apply(this, arguments);
};

var values = function values(object, keys) {
  var values = [];
  var key;
  for (var i = 0, len = keys.length; i < len; i++) {
    key = keys[i];
    if (key in object) values.push(object[key]);else values.length++;
  }
  return values;
};

// subtract ranges2 from ranges1
var rdifference = function rdifference(ranges1, ranges2) {
  if (!ranges1.length) return [];

  var resultingRanges = [];

  for (var i = 0, len = ranges1.length; i < len; i++) {
    var range = ranges1[i];
    resultingRanges = resultingRanges.concat(range.subtract(ranges2));
  }

  // Make sure we don't have overlapping ranges
  resultingRanges = new Range(0, 0).merge(resultingRanges);

  // Remove any empty ranges
  resultingRanges = filter(resultingRanges, function (range) {
    return !!range.length;
  });

  return resultingRanges;
};

// merge ranges1 into ranges2
var rcombine = function rcombine(ranges1, ranges2) {
  for (var i = 0, len = ranges1.length; i < len; i++) {
    var range = ranges1[i];
    ranges2 = range.merge(ranges2);
  }
  return ranges2;
};

// util
var IDX = 0;

var slice_ = Array.prototype.slice;

var transform = function transform(item, method) {

  if (isPlainObject(item)) {
    // plain objects need to be liveified
    if ('operations' in item) return new LiveList().update(item.operations);
    return live(item.uri)._update(item, method);
  }

  if (isArray(item)) {
    // arrays need to be liveified
    return new LiveList()._update([{
      type: 'insert',
      index: 0,
      length: item.length,
      values: item
    }], method);
  }
  return item;
};

// Creates a callback with a timeout.
function createTimedCallback(callback, timeout) {
  var called;
  var timeoutId = setTimeout(function () {
    called = true;
    callback(new Error('Timeout Expired: ' + timeout + ' milliseconds'));
  }, timeout);
  return function () {
    if (!called) {
      clearTimeout(timeoutId);
      callback.apply(this, arguments);
    }
  };
};

var LiveList = prime( /** @lends LiveList.prototype */{

  mixin: Emitter,

  /**
   * A representation of an array which may be observed for changes
   * @constructs
   * @mixes Emitter
   * @param {Number} [length] - A number representing the length of the liveList.
   */
  constructor: function LiveList(length) {
    this._data = new OrderedSet(length);
    this._mergeThrottled = throttle(this._merge, this);
    this._waiting = [];

    var self = this;
    var lastWait = '';

    if (live.debug) setInterval(function () {
      var thisWait = self._waiting.toString();
      if (lastWait === thisWait) return;
      lastWait = thisWait;

      if (self._waiting.length) {
        console.warn(self, 'waiting for', self._waiting);
      } else {
        console.warn(self, 'all done');
      }
    }, 2000);
  },

  get index() {
    return this._data.index;
  },

  get length() {
    return this._data.length;
  },

  get keys() {
    return this._data.keys;
  },

  get values() {
    return this._data.values;
  },

  indexOf: function indexOf(key) {
    return this._data.indexOf(key);
  },

  indexOfMany: function indexOfMany(keys) {
    return this._data.indexOfMany(keys);
  },

  valueOf: function valueOf(key) {
    return this._data.valueOf(key);
  },

  hasKey: function hasKey(key) {
    return this._data.hasKey(key);
  },

  forEach: function forEach(fn, ctx) {
    this._data.forEach(fn, ctx);
    return this;
  },

  map: function map(fn, ctx) {
    return this._data.map(fn, ctx);
  },

  _merge: function _merge() {
    var data = this._data; // actual data
    var publish = this._publish; // new items on top of a copy of data || null
    var before = this._before; // an old copy of data || null

    if (publish) {
      delete this._publish;
      if (this._listeners && this._listeners.publish) {
        var publishDiff = data.diff(publish);
        if (publishDiff.length) this.emit('publish', publishDiff, EMIT_SYNC);
      }
    } else if (before) {
      delete this._before;
      if (this._listeners && this._listeners.update) {
        var updateDiff = before.diff(data);
        if (updateDiff.length) this.emit('update', updateDiff, EMIT_SYNC);
      }
    }
    return this;
  },

  _update: function _update(operations, method) {

    var branch;
    if (method === PUBLISH) {
      // it was receiving, cannot publish.
      if (this._before) return this;
      branch = this._publish || (this._publish = this._data.clone());
    } else if (method === UPDATE) {
      // it was publishing, delete it.
      if (this._publish) delete this._publish;
      if (!this._before) this._before = this._data.clone();
      branch = this._data;
    }

    var op;
    for (var opIndex = 0, opLen = operations.length; opIndex < opLen; opIndex++) {
      op = operations[opIndex];
      switch (op.type) {
        case 'length':
          branch.length = op.length;break;
        case 'sort':
          branch.sort(op.compareFunction);break;
        case 'move':
          branch.move(op.from, op.to, op.length);break;
        case 'remove':
          branch.remove(op.index, op.length);break;
        case 'insert':
          var values = [];
          var keys = op.keys || [];
          for (var i = 0, len = op.values.length; i < len; i++) {
            if (!op.keys || !op.keys[i]) keys[i] = (IDX++).toString(36);
            values[i] = transform(op.values[i], method);
          }
          branch.insert(op.index, keys, values);
          break;
      }
    }

    if (method === UPDATE) this._waiting = rdifference(this._waiting, this.index);

    this._mergeThrottled();
    return this;
  },

  publish: function publish(operations) {
    return this._update(operations, PUBLISH);
  },

  update: function update(operations) {
    return this._update(operations, UPDATE);
  },

  /**
   * Serialize the data in this list into a plain object.
   *
   * @param {number=} limit Optional limit parameter. Controls how many levels
   *     deep to serialize.
   *
   * @return {Array} The data array.
   */
  serialize: function serialize(limit) {
    if (limit === 0) return [];

    var array = [];
    var nextLimit = limit === undefined ? undefined : limit - 1;

    for (var i = 0; i < this.length; i++) {
      var value = this.values[i];
      var serializedValue = value;
      if (value && value.serialize) {
        serializedValue = value.serialize(nextLimit);
      }
      array.push(serializedValue);
    }

    return array;
  },

  _getDataFromMask: function _getDataFromMask(mask) {
    var items = [];

    if (mask.length > 0) {
      // The provided mask to a list is the mask for each list item, so we need
      // to loop through all the items and get the data from each item based on
      // the mask.
      for (var i = 0, l = this.length; i < l; i++) {
        var item = this.get(i);
        var parsedItem;
        var isObjectOrList = item && item._getDataFromMask;
        if (isObjectOrList) {
          parsedItem = item._getDataFromMask(mask);
        }
        items.push(parsedItem);
      }
    }

    return items;
  },

  _query: function _query(selector, callback, mode) {
    var self = this;

    var query = function query() {
      queryList(self, selector, function (error, data, wasSync) {
        if (error) return callback(error);

        if (!wasSync) {
          self._query(selector, callback, mode);
        } else {
          callback(null, data);
        }
      });
    };

    if (mode === ASYNC) defer(query);else query();
  },

  /**
   * Query properties in this list.
   * This can be called in two different ways: with a callback or without. When
   * calling it with a callback, it will wait for any missing data and always
   * return the data you queried for. When calling it without a callback, it
   * will return an array structure with only the data that was found in the
   * object at the moment. It will not kick off any events for waiting for
   * properties.
   *
   * @param {String} selector - The query selector. Only selectors without
   *     filters are supported when not providing a callback.
   * @param {Array} params - The query replace parameters.
   * @param {LiveList~queryCallback} callback - The callback that handles the response.
   * @param {Object} [mode] live.SYNC: Force sync, 2: live.ASAP: Don't force async
   * @param {Number} timeout - optional timeout in milliseconds
   *
   * @return {LiveList|Array} If no callback is passed it returns an array with
   *                             the data matching the query, that was found at
   *                             the moment in the list.
   *                             If a callback is passed it returns the instance.
   */
  query: function query(selector, params, callback, mode, timeout) {
    /**
     * @callback LiveList~queryCallback
     * @param {Error|Null} error - An error that you can throw, or null.
     * @param {Array} [data] - The response as an array.
     */
    if (typeof params === 'function') {
      // shift for empty params
      timeout = mode;
      mode = callback;
      callback = params;
      params = [];
    }

    if (!callback) {
      return this._getDataFromMask(parse(selector, params).mask);
    }

    if (!mode) {
      mode = ASYNC;
    } else if (isNumber(mode)) {
      // shift once again
      timeout = mode;
      mode = ASYNC;
    }

    if (timeout) {
      callback = createTimedCallback(callback, timeout);
    }

    this._query(parse(selector, params), callback, mode);
    return this;
  },

  _wait: function _wait(ranges) {
    if (!this._required) {
      // if _required is set, it was deferred already
      this._required = [];
      defer(function () {
        var missingFromIndex = this.missing(this._required);
        var missingFromWaiting = rdifference(missingFromIndex, this._waiting);
        this._waiting = rcombine(this._waiting, missingFromWaiting);
        delete this._required;
        if (missingFromWaiting.length) this.emit('wait', missingFromWaiting, EMIT_SYNC);
      }, this);
    }
    this._required = rcombine(this._required, ranges);
  },

  missing: function missing(ranges) {
    return rdifference(ranges, this.index);
  },

  // the raw, unbeautified get
  // this can callback sync or async
  _get: function _get(ranges, callback) {
    if (this.missing(ranges).length) {
      // has missing stuff (no matter what)
      this._wait(ranges);

      var check = function check() {
        var needed = this.missing(ranges);
        if (!needed.length) {
          this.off('update', check);
          callback.call(this);
        }
      };

      this.on('update', check);
    } else {
      // the callback is called with 'true' when syncronous.
      callback.call(this, null, true);
    }
  },

  /**
   * Checks if the range has been set with values in the list.
   *
   * @param {number} fromIndex The index to start from.
   * @param {number=} toIndex Optional index to stop at (non-inclusive). If no
   *     toIndex is specified, it will default to the index after fromIndex, to
   *     check for the single item at fromIndex.
   *
   * @return {Boolean} True if the range has been set.
   */
  has: function has(fromIndex, toIndex) {
    var hasToIndex = toIndex !== undefined;
    if (!hasToIndex) toIndex = fromIndex + 1;

    var range = new Range(fromIndex, toIndex);

    return range.contained(this.index);
  },

  /**
   * Gets items from the list between the specified indices.
   * @param {Number} what - The index to start from.
   * @param {Number} [toIndex=fromIndex + 1] - The index to stop at (non-inclusive).
   * @param {LiveList~getCallback} [callback] - Optional callback function. If no toIndex
   *     is specified, the callback can be placed as the second argument.
   * @param {Object} [mode] live.SYNC: Force sync, 2: live.ASAP: Don't force async
   * @param {Number} timeout - optional timeout in milliseconds
   * @return {LiveList|Array} If no callback is specified, returns the requested items in an array.
   *                          If a callback is specified, the method returns the instance.
   */
  get: function get(fromIndex, toIndex) {
    /**
     * @callback LiveList~getCallback
     * @param {Error|Null} error - An error that you can throw, or null.
     * @param {Array|*} [data] - The response as an array.
     *                           If toIndex is not specified a single item on the list is passed.
     */

    // fast, get one
    if (arguments.length === 1) {
      if (isNumber(fromIndex)) return this.values[fromIndex];
      if (isString(fromIndex)) return this.valueOf(fromIndex);
    }

    var self = this;

    var args = slice_.call(arguments);
    var callback, mode, requested;

    for (var i = 0, len = args.length; i < len; i++) {
      var arg = args[i];
      if (typeof arg === 'function') {
        var split = args.splice(i, 3);
        len = args.length;
        callback = split[0];
        if (split[1]) {
          if (split[1] === SYNC || split[1] === ASYNC || split[1] === ASAP) {
            mode = split[1];
          } else {
            // assume this arg is a timeout
            mode = ASYNC;
            callback = createTimedCallback(callback, split[1]);
            break;
          }
          // is there a timeout ?
          if (split[2] && mode !== SYNC) {
            callback = createTimedCallback(callback, split[2]);
          }
        } else {
          mode = ASYNC;
        }
        break;
      }
    }

    var asArray = false;
    var asSingleValue = false;

    if (fromIndex instanceof Range) {
      // one range
      requested = args;
      asArray = !callback && requested.length > 1;
    } else if (isArray(fromIndex)) {
      // array of ranges
      asArray = true;
      requested = fromIndex;
    } else {
      // numbers ?
      var hasToIndex = !isNaN(toIndex);
      if (!hasToIndex) toIndex = fromIndex + 1;
      asSingleValue = !hasToIndex;
      requested = [new Range(fromIndex, toIndex)];
    }

    var result = function result() {
      return map(requested, function (range) {
        return self.values.slice(range.start, range.end);
      });
    };

    var done = function done() {
      if (asArray) callback.call(self, null, result());else if (asSingleValue) callback.call(self, null, self.values[fromIndex]);else callback.apply(self, [null].concat(result()));
    };

    if (!callback) {
      if (asArray) return result();
      return result()[0];
    } else if (mode === SYNC) {
      done();
    } else {
      if (mode === ASYNC && !this.missing(requested).length) {
        // it has all the data but needs to be ASYNC
        defer(function () {
          this._get(requested, done);
        }, this);
      } else {
        this._get(requested, done);
      }
    }
    return this;
  }

});

var LiveObject = prime( /** @lends LiveObject.prototype */{

  mixin: Emitter,

  /**
   * A representation of an object which may be observed for changes
   * @constructs
   * @mixes Emitter
   */
  constructor: function LiveObject(_uri) {
    this.uri = _uri;
    this._data = { uri: _uri };
    this._mergeThrottled = throttle(this._merge, this);
    this.index = [];
    this._waiting = [];
    this.emit('init', EMIT_SYNC);

    var self = this;
    var lastWait = '';

    if (live.debug) setInterval(function () {
      var thisWait = self._waiting.toString();
      if (lastWait === thisWait) return;
      lastWait = thisWait;

      if (self._waiting.length) {
        console.warn(self, self._waiting);
      } else {
        console.warn(self, 'all done');
      }
    }, 2000);
  },

  emit: function emit() {
    var uri = this.uri;
    if (uri) {
      var keys = emitters.keys;
      var values = emitters.values;
      var key;
      var args;

      for (var i = 0, len = keys.length; i < len; i++) {
        key = keys[i];
        if (uri.match(key)) {
          if (!args) {
            args = new Array(arguments.length);
            for (var j = 0; j < arguments.length; ++j) {
              args[j] = arguments[j];
            }
            args.splice(1, 0, this);
          }
          var emitter = values[i];
          emitter.emit.apply(emitter, args);
        }
      }
    }

    Emitter.prototype.emit.apply(this, arguments);
  },

  _merge: function _merge() {
    var data = this._data; // the data
    var before = this._before; // an old copy of data
    var publish = this._publish; // published data
    var value;
    var key;

    // published changes
    if (publish) {
      delete this._publish;

      // emit change events if the object has a uri that can be subscribed too,
      // or the object in itself has listeners
      if (this.uri || this._listeners && this._listeners.publish) {
        var publishEvent = {};

        for (key in publish) {
          value = publish[key];
          if (data[key] !== value) publishEvent[key] = value;
        }

        if (Object.keys(publishEvent).length) {
          this.emit('publish', publishEvent, EMIT_SYNC);
        }
      }
    }

    // if there are changes
    if (before) {
      delete this._before;

      var updateEvent = {};

      // emit change events if the object has a uri that can be subscribed too,
      // or the object in itself has listeners
      if (this.uri || this._listeners && this._listeners.update) {
        // check changed and added keys
        for (key in data) {
          value = data[key];
          // there was no key, or value is different
          if (!(key in before) || before[key] !== value) updateEvent[key] = value;
        }

        // check deleted keys
        for (key in before) {
          value = before[key];
          // there is no key so it was deleted
          if (!(key in data)) updateEvent[key] = undefined;
        }

        if (Object.keys(updateEvent).length) {
          this.emit('update', updateEvent, EMIT_SYNC);
        }
      }
    }

    return this;
  },

  _update: function _update(object, method) {
    var branch;

    if (method === PUBLISH) {
      branch = this._publish || (this._publish = simpleClone(this._data));
    } else if (method === UPDATE) {
      if (!this._before) this._before = simpleClone(this._data);
      branch = this._data;
    }

    var value;
    for (var key in object) {
      value = object[key];
      var previous = !(key in branch) ? undefined : branch[key];

      if (isLiveList(previous)) {
        // updating lists with an array will keep the reference but replace every item.
        if (isArray(value)) {

          previous._update([{
            type: 'remove',
            index: 0,
            length: previous.length
          }, {
            type: 'insert',
            index: 0,
            values: value
          }], method);
          continue;
        } else if (isPlainObject(value) && 'operations' in value) {
          previous._update(value.operations, method);
          continue;
        }
      }

      if (method === UPDATE && value === undefined) delete branch[key];else branch[key] = transform(value, method);
    }

    if (method === UPDATE) {
      this.index = keys(branch);
      this._waiting = difference(this._waiting, this.index);
    }

    this._mergeThrottled();
    return this;
  },

  delete: function _delete(key) {
    var object = {};
    object[key] = undefined;
    return this.update(object);
  },

  update: function update(object) {
    return this._update(object, UPDATE);
  },

  publish: function publish(object) {
    return this._update(object, PUBLISH);
  },

  /**
   * Serialize the data in this object into a plain object.
   *
   * @param {number=} limit Optional limit parameter. Controls how many levels
   *     deep to serialize.
   *
   * @return {Object} The data object.
   */
  serialize: function serialize(limit) {
    if (limit === 0) return {};

    var object = {};
    var data = this._data;
    var nextLimit = limit === undefined ? undefined : limit - 1;

    for (var key in data) {
      var value = data[key];
      if (value === undefined) continue;
      var serializedValue = value;
      if (value && value.serialize) {
        serializedValue = value.serialize(nextLimit);
      }
      object[key] = serializedValue;
    }

    return object;
  },

  _getDataFromMask: function _getDataFromMask(mask) {
    var data = {};

    for (var i = 0, l = mask.length; i < l; i++) {
      var thisMask = mask[i];
      var nextMask = thisMask.mask;
      var key = thisMask.key;

      var realValue = this.get(key);
      var value = realValue;

      // Set the value to an empty object or array, and then it will be filled
      // in with the found data in the next step.
      if (isLiveObject(realValue)) value = {};
      if (isLiveList(realValue)) value = [];

      if (nextMask) {
        if (isLiveObject(realValue)) {
          var innerData = realValue._getDataFromMask(nextMask);
          deepMixIn(value, innerData);
        } else if (isLiveList(realValue)) {
          value = realValue._getDataFromMask(nextMask);
        }
      }

      data[key] = value;
    }

    return data;
  },

  _query: function _query(selector, callback, mode) {
    var self = this;

    var query = function query() {
      queryObject(self, selector, function (error, data, wasSync) {
        if (error) return callback.call(this, error);

        if (!wasSync) {
          self._query(selector, callback, mode);
        } else {
          callback.call(this, null, data);
        }
      });
    };

    if (mode === ASYNC) defer(query);else query();
  },

  /**
   * Query properties in this object.
   * This can be called in two different ways: with a callback or without. When
   * calling it with a callback, it will wait for any missing properties and
   * always return the data you queried for. When calling it without a callback,
   * it will return an object structure with only the data that was found in the
   * object at the moment. It will not kick off any events for waiting for
   * properties.
   *
   * @param {String} selector - The query selector. Only selectors without
   *     filters are supported when not providing a callback.
   * @param {Array} params - The query replace parameters. Optional.
   * @param {LiveObject~queryCallback} callback - The callback function.
   * @param {Object} [mode] live.SYNC: Force sync, 2: live.ASAP: Don't force async
   * @param {Number} timeout - optional timeout in milliseconds
   *
   * @return {LiveObject|Object} If no callback is passed it returns an object
   *                             with the data matching the query, that was found
   *                             at the moment in the object.
   *                             If a callback is passed it returns the instance.
   */
  query: function query(selector, params, callback, mode, timeout) {
    /**
     * @callback LiveObject~queryCallback
     * @param {Error|Null} error - An error that you can throw, or null.
     * @param {LiveObject} [data] - The response as a plain object.
     */
    if (typeof params === 'function') {
      // shift for empty params
      timeout = mode;
      mode = callback;
      callback = params;
      params = [];
    }

    if (!callback) {
      return this._getDataFromMask(parse(selector, params).mask);
    }

    if (!mode) {
      mode = ASYNC;
    } else if (isNumber(mode)) {
      // shift once again
      timeout = mode;
      mode = ASYNC;
    }

    if (timeout) {
      callback = createTimedCallback(callback, timeout);
    }

    this._query(parse(selector, params), callback, mode);
    return this;
  },

  _wait: function _wait(keys) {
    if (!this._required) {
      // if _required is set, it was deferred already
      this._required = [];
      defer(function () {
        var missingFromIndex = this.missing(this._required);
        var missingFromWaiting = difference(missingFromIndex, this._waiting);
        this._waiting = combine(this._waiting, missingFromWaiting);
        delete this._required;
        if (missingFromWaiting.length) this.emit('wait', missingFromWaiting, EMIT_SYNC);
      }, this);
    }
    this._required = combine(this._required, keys);
  },

  missing: function missing(keys) {
    return difference(keys, this.index);
  },

  /**
   * Checks if the key has been set in the object.
   *
   * @param {string} key The name of the key.
   *
   * @return {Boolean} True if the key has been set.
   */
  has: function has(key) {
    return this.index.indexOf(key) > -1;
  },

  // the raw, unbeautified get
  // this can callback sync or async
  _get: function _get(keys, callback) {
    if (this.missing(keys).length) {
      this._wait(keys);

      var check = function check() {
        var needed = this.missing(keys);
        if (!needed.length) {
          this.off('update', check);
          callback.call(this);
        }
      };
      this.on('update', check);
    } else {
      // the callback is called with 'true' when syncronous.
      callback.call(this, null, true);
    }
  },

  /**
   * Gets values from the object.
   * @param {...String|Array} keys - An array of strings as arguments.
   * @param {LiveObject~getCallback} [callback] - Optional callback function.
   * @param {Object} [mode] live.SYNC: Force sync, 2: live.ASAP: Don't force async
   * @param {Number} timeout - optional timeout in milliseconds
   * @return {LiveObject|Array|*} If no callback is passed and keys is either an array or multiple arguments
   *                             returns the values in an array.
   *                             If no callback is passed and keys is a single parameter it
   *                             returns the requested value (any type).
   *                             If a callback is passed it returns the instance.
   */
  get: function get(key) {
    /**
     * @callback LiveObject~getCallback
     * @param {Error|Null} error - An error that you can throw, or null.
     * @param {Array|...*} [data] - If keys are requested as arguments (any #)
     *                              it will return many results as arguments.
     *                              If keys are requested as an array (any #), it will return data as an array
     * @param {Number} [mode] 1: FORCE SYNC, 2: DON'T FORCE ASYNC
     */

    // fast, get one
    var data = this._data;
    if (arguments.length === 1 && isString(key)) return data[key];

    var self = this;

    var args = slice_.call(arguments);
    var callback, mode, keys;

    for (var i = 0, len = args.length; i < len; i++) {
      var arg = args[i];
      if (typeof arg === 'function') {
        var split = args.splice(i, 3);
        len = args.length;
        callback = split[0];
        if (split[1]) {
          if (split[1] === SYNC || split[1] === ASYNC || split[1] === ASAP) {
            mode = split[1];
          } else {
            // assume this arg is a timeout
            mode = ASYNC;
            callback = createTimedCallback(callback, split[1]);
            break;
          }
          // is there a timeout ?
          if (split[2] && mode !== SYNC) {
            callback = createTimedCallback(callback, split[2]);
          }
        } else {
          mode = ASYNC;
        }
        break;
      }
    }

    var asArray = false;

    if (isArray(key)) {
      keys = key;
      asArray = true;
    } else {
      keys = args;
    }

    var done = function done() {
      var vals = values(data, keys);
      if (asArray) {
        callback.call(self, null, vals);
      } else {
        vals.unshift(null); // unshift no error
        callback.apply(self, vals);
      }
    };

    if (!callback) {
      return values(data, keys);
    } else if (mode === SYNC) {
      done();
    } else {
      if (mode === ASYNC && !this.missing(keys).length) {
        // it has all the data but needs to be ASYNC
        defer(function () {
          self._get(keys, done);
        });
      } else {
        this._get(keys, done);
      }
    }

    return this;
  }

});

var queryAny = function queryAny(object, selector, callback) {
  if (isPlainObject(object) || isLiveObject(object)) return queryObject(object, selector, callback);else if (isArray(object) || isLiveList(object)) return queryList(object, selector, callback);else return callback(null, object, true);
};

var queryObject = function queryObject(object, selector, callback) {
  var data = {};
  var isSync = true;

  if (!selector) callback(null, data, isSync);

  var keys = map(selector.mask, 'key');

  var done = function done(values) {
    flow().parallel(values, function (objectValue, i) {
      var control = this;
      queryAny(objectValue, selector.mask[i], function (error, dataValue, wasSync) {
        if (error) return control.break(error);
        if (!wasSync) isSync = false;
        if (data[keys[i]]) deepMixIn(data[keys[i]], dataValue);else data[keys[i]] = dataValue;
        control.done();
      });
    }).finally(function (error) {
      callback(error, data, isSync);
    });
  };

  if (isLiveObject(object)) {
    object._get(keys, function (error, wasSync) {
      if (error) return callback(error);
      if (!wasSync) isSync = false;
      var values = map(keys, function (key) {
        return object._data[key];
      });
      done(values);
    });
  } else {
    var values = pick(object, keys);
    done(values);
  }
};

var satisfies = function satisfies(value, op, right) {
  if (!op) return !!value;
  if (isRegExp(right)) return right.test(value);

  if (op === '=') return value === right;
  if (op === '!=') return value !== right;

  if (isNumber(right)) {
    if (op === '>') return value > right;
    if (op === '>=') return value >= right;
    if (op === '<') return value < right;
    if (op === '<=') return value <= right;
  }

  if (isString(right)) {
    var escapedRight = escapeRegExp(right);
    // starts with
    if (op === '^=') return new RegExp('^' + escapedRight).test(value);
    // ends with
    if (op === '$=') return new RegExp(escapedRight + '$').test(value);
    // contains separated by space e.g. 'list of things to look for' ~= 'list'
    if (op === '~=') return new RegExp('(^|\\s)' + escapedRight + '(\\s|$)').test(value);
    // contains separated by - e.g. 'list-of-things-to-look-for' ~= 'things'
    if (op === '|=') return new RegExp('^' + escapedRight + '(-|$)').test(value);
    // contains e.g. 'listofthingstolookfor' ~= 'look'
    if (op === ' *=') return value.toString().indexOf(right) !== -1;
  }

  return false;
};

var filterArray = function filterArray(array, left, op, right, callback) {
  var isSync = true;

  var filtered = [];

  flow().parallel(array, function (item, i) {
    var ctrl = this;

    if (isLiveObject(item)) {
      item._get([left], function (error, wasSync) {
        if (error) return ctrl.break(error);
        if (!wasSync) isSync = false;
        var value = item._data[left];
        if (satisfies(value, op, right)) filtered[i] = item;
        ctrl.done();
      });
    } else if (isPlainObject(item)) {
      if (satisfies(item[left], op, right)) filtered[i] = item;
      ctrl.done();
    } else {
      // filter objects only
      ctrl.done();
    }
  }).finally(function (error) {
    if (error) return callback(error);
    var clean = [];
    for (var i = 0; i < filtered.length; i++) {
      if (i in filtered) clean.push(filtered[i]);
    }callback(null, clean, isSync);
  });
};

// default filter that filters the whole list.
var defaultFilters = [[{
  left: 0,
  op: ':'
}]];

var queryList = function queryList(list, selector, callback) {
  var isSync = true;
  // if there are no filters we need to query the full length
  if (!selector.filters) selector.filters = defaultFilters;

  // single filter.
  // must be sequential.
  flow().sequential(selector.filters, function (conditions) {
    var sequential = this;

    var ref = [];

    // list of conditions in a single filter.
    // can be parallel.
    flow().parallel(conditions, function (condition) {
      var parallel = this;

      var left = condition.left;
      var right = condition.right;
      var op = condition.op;

      if ('left' in condition && !('right' in condition) && isNumber(left)) {
        if (!op) right = left + 1;else if (op === ':') right = list.length;
        op = ':';
      }

      if ('right' in condition && !('left' in condition) && isNumber(right) && op === ':') {
        left = 0;
      }

      // filter by range.
      if (isNumber(left) && isNumber(right) && op === ':') {
        // if the list is an array it means it has already been filtered.
        if (isArray(list)) {
          var filtered = slice_.call(list, left, right);
          ref = ref.concat(filtered);
          parallel.done();
        } else {
          list._get([new Range(left, right)], function (error, wasSync) {
            if (error) return parallel.break(error);

            for (var i = left; i < right; i++) {
              ref.push(list.values[i]);
            }if (!wasSync) isSync = false;
            parallel.done();
          });
        }
      } else {

        var done = function done(array) {
          filterArray(array, left, op, right, function (error, filtered, wasSync) {
            if (error) return parallel.break(error);

            if (!wasSync) isSync = false;
            ref = ref.concat(filtered);
            parallel.done();
          });
        };

        if (isArray(list)) {
          done(list);
        } else {
          // the list is not an array, never been filtered.
          // assume full length.
          // call a function that filters an array once you arraify it.
          list._get([new Range(0, list.length)], function (error, wasSync) {
            if (error) return parallel.break(error);

            var array = [];
            for (var i = 0; i < list.length; i++) {
              array.push(list.values[i]);
            }if (!wasSync) isSync = false;
            done(array);
          });
        }
      }

      // parallel finished
    }).finally(function (error) {
      if (error) return sequential.break(error);
      list = ref;
      sequential.continue();
    });

    // sequential finished
  }).finally(function (error) {
    if (error) return callback(error);

    var data = [];

    // final parallel
    flow().parallel(list, function (item, i) {
      var control = this;
      queryAny(item, selector, function (err, res, wasSync) {
        if (!wasSync) isSync = false;
        if (data[i]) deepMixIn(data[i], res);else data[i] = res;
        control.done(err);
      });
    }).finally(function (err) {
      callback(err, data, isSync);
    });
  });
};

var cache = {};

/**
 * Create a new instance of a object, based on an unique identifier.
 * @function
 * @static
 * @param {String|LiveObject} item - An object with an uri property, or an uri as a string.
 * @return {LiveObject|LiveList} An instance of LiveObject or LiveList.
 */
var live = function live(item) {
  if (isArray(item)) {
    return new LiveList().update([{
      type: 'insert',
      index: 0,
      length: item.length,
      values: item
    }]);
  } else if (isNumber(item)) {
    return new LiveList(item);
  } else if (isString(item)) {
    return cache[item] || (cache[item] = new LiveObject(item));
  } else if (isPlainObject(item)) {
    return live(item.uri).update(item);
  } else if (isLiveList(item) || isLiveObject(item)) {
    return item;
  }

  return new LiveObject();
};

// Allow localStorage.debug to also control live.debug.
if (global.localStorage && global.localStorage.debug && (global.localStorage.debug.indexOf('spotify-live') > -1 || global.localStorage.debug.indexOf('*') > -1)) {
  live.debug = true;
}

var emitters = {
  keys: [],
  values: []
};

/**
 * Subscribe to the specific event of objects matching the pattern.
 * @function
 * @static
 * @param {RegExp} match - Regular expression for matching uris.
 * @param {String} name - The name of the event to listen for.
 * @param {Function} handle - The event handle.
 * @return {Function} The live function.
 */
live.subscribe = function (match, name, handle) {
  if (match.matches) match = match.matches;

  var string = match.toString();

  var keys = emitters.keys;
  var values = emitters.values;

  var emitter;
  for (var i = 0, len = keys.length; i < len; i++) {
    var key = keys[i];
    if (key.toString() === string) {
      emitter = values[i];
      if (emitter) break;
    }
  }

  if (!emitter) {
    keys.push(match);
    values.push(emitter = new Emitter());
  }

  emitter.on(name, handle);

  return this;
};

/**
 * Unsubscribe to the specific event of objects matching the pattern.
 * @function
 * @static
 * @param {RegExp} match - Regular expression for matching uris.
 * @param {String} name - The name of the event to unsubscribe from.
 * @param {Function} handle - The event handle.
 * @return {Function} The live function.
 */
live.unsubscribe = function (match, name, handle) {
  if (match.matches) match = match.matches;

  var string = match.toString();

  var keys = emitters.keys;
  var values = emitters.values;

  var emitter;
  for (var i = 0, len = keys.length; i < len; i++) {
    var key = keys[i];
    if (key.toString() === string) {
      emitter = values[i];
      if (emitter) break;
    }
  }

  if (emitter) emitter.off(name, handle);

  return this;
};

/**
 * Delete a model from the live cache.
 *
 * @param {string} uri A uri.
 *
 * @return {Function} The live function.
 */
live.delete = function (uri) {
  delete cache[uri];
  return this;
};

/**
 * Purge the entire cache.
 *
 * @return {Function} The live function.
 */
live.purge = function () {
  cache = {};
  return this;
};

/**
 * Check if live has an object for the URI in the cache.
 *
 * @param {string} uri A uri.
 *
 * @return {Boolean} True if the object is in the cache.
 */
live.has = function (uri) {
  return !!cache[uri];
};

var EMIT_SYNC = live.EMIT_SYNC = Emitter.EMIT_SYNC;

var ASYNC = live.ASYNC = 'ASYNC';
var SYNC = live.SYNC = 'SYNC';
var ASAP = live.ASAP = 'ASAP';

var PUBLISH = 3;
var UPDATE = 4;

/**
 * @static
 * @see LiveObject
 */
live.Object = LiveObject;

/**
 * @static
 * @see LiveList
 */
live.List = LiveList;

module.exports = live;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-range2":140,"./util/ordered-set":111,"./util/parser":112,"./util/throttle":113,"finally":149,"mout/array/combine":180,"mout/array/difference":182,"mout/array/filter":184,"mout/array/map":187,"mout/lang/isArray":195,"mout/lang/isPlainObject":198,"mout/lang/isRegExp":199,"mout/object/deepMixIn":203,"mout/object/keys":207,"mout/object/pick":209,"mout/string/escapeRegExp":211,"prime":219,"prime/defer":217,"prime/emitter":218}],110:[function(require,module,exports){
/**
 * @module spotify-live/diff
 */
'use strict';

// Original code from: https://github.com/codeparty/arraydiff
// License: MIT
// This has been forked to allow for optimizations and patching operations.

// Based on some rough benchmarking, this algorithm is about O(n^2) worst case,
// and it can compute diffs on random arrays of length 1024 in about 34ms,
// though just a few changes on an array of length 1024 takes about 0.5ms

var splice_ = Array.prototype.splice;
var slice_ = Array.prototype.slice;

var annotate = function annotate(before, after) {
  // Find all items in both the before and after array, and represent them
  // as moves. Many of these "moves" may end up being discarded in the last
  // pass if they are from an index to the same index, but we don't know this
  // up front, since we haven't yet offset the indices.
  //
  // Also keep a map of all the indicies accounted for in the before and after
  // arrays. These maps are used next to create insert and remove diffs.
  var beforeLength = before.length;
  var afterLength = after.length;
  var moves = [];
  var beforeMarked = {};
  var afterMarked = {};
  for (var beforeIndex = 0; beforeIndex < beforeLength; beforeIndex++) {
    var beforeItem = before[beforeIndex];
    for (var afterIndex = 0; afterIndex < afterLength; afterIndex++) {
      if (afterMarked[afterIndex]) continue;
      if (beforeItem !== after[afterIndex]) continue;
      var from = beforeIndex;
      var to = afterIndex;
      var length = 0;
      do {
        beforeMarked[beforeIndex++] = afterMarked[afterIndex++] = true;
        length++;
      } while (beforeIndex < beforeLength && afterIndex < afterLength && before[beforeIndex] === after[afterIndex] && !afterMarked[afterIndex]);
      var moveDiff = {
        type: 'move',
        from: from,
        to: to,
        length: length
      };
      moves.push(moveDiff);
      beforeIndex--;
      break;
    }
  }

  // Create a remove for all of the items in the before array that were
  // not marked as being matched in the after array as well
  var removes = [];
  for (beforeIndex = 0; beforeIndex < beforeLength;) {
    if (beforeMarked[beforeIndex]) {
      beforeIndex++;
      continue;
    }
    var index = beforeIndex;
    var length = 0;
    while (beforeIndex < beforeLength && !beforeMarked[beforeIndex++]) {
      length++;
    }
    var removeDiff = {
      type: 'remove',
      index: index,
      length: length,
      values: slice_.call(before, index, index + length)
    };
    removes.push(removeDiff);
  }

  // Create an insert for all of the items in the after array that were
  // not marked as being matched in the before array as well
  var inserts = [];
  for (afterIndex = 0; afterIndex < afterLength;) {
    if (afterMarked[afterIndex]) {
      afterIndex++;
      continue;
    }
    var index = afterIndex;
    var length = 0;
    while (afterIndex < afterLength && !afterMarked[afterIndex++]) {
      length++;
    }
    var values = slice_.call(after, index, index + length);
    inserts.push({ type: 'insert', index: index, length: length, values: values });
  }

  return [removes, moves, inserts];
};

var offset = function offset(removes, moves, inserts) {

  var insertsLength = inserts.length;
  var removesLength = removes.length;
  var movesLength = moves.length;
  var i, j;

  // Offset subsequent removes and moves by removes
  var count = 0;
  for (i = 0; i < removesLength; i++) {
    var remove = removes[i];
    remove.index -= count;
    count += remove.length;
    for (j = 0; j < movesLength; j++) {
      var move = moves[j];
      if (move.from >= remove.index) move.from -= remove.length;
    }
  }

  // Offset moves by inserts
  for (i = insertsLength; i--;) {
    var insert = inserts[i];
    var length = insert.length;
    for (j = movesLength; j--;) {
      var move = moves[j];
      if (move.to >= insert.index) move.to -= length;
    }
  }

  // Offset the to of moves by later moves
  for (i = movesLength; i-- > 1;) {
    var move = moves[i];
    if (move.to === move.from) continue;
    for (j = i; j--;) {
      var earlier = moves[j];
      if (earlier.to >= move.to) earlier.to -= move.length;
      if (earlier.to >= move.from) earlier.to += move.length;
    }
  }

  // Only output moves that end up having an effect after offsetting
  var outputMoves = [];

  // Offset the from of moves by earlier moves
  for (i = 0; i < movesLength; i++) {
    var move = moves[i];
    if (move.to === move.from) continue;
    outputMoves.push(move);
    for (j = i + 1; j < movesLength; j++) {
      var later = moves[j];
      if (later.from >= move.from) later.from -= move.length;
      if (later.from >= move.to) later.from += move.length;
    }
  }

  // try to reduce the number of move events
  reduceMoves(outputMoves);

  return removes.concat(outputMoves, inserts);
};

var reduceMoves = function reduceMoves(moves) {
  for (var i = 0; i < moves.length; i++) {

    // if we detect a move operation of a lots of items to a near position, we
    // can swap it by a move operation of less items to a farther position
    // (which is going to be much more performant).
    //
    // Example:
    // [1, 2, 3, 4, 5, 6, 7] => [2, 3, 4, 5, 6, 7, 1]
    // We could move [2, 3, 4, 5, 6, 7] one position ahead, but it's better to
    // move [1] six positions behind.
    if (moves[i].length > Math.abs(moves[i].to - moves[i].from)) {
      var from = moves[i].from;
      var to = moves[i].to;
      var length = moves[i].length;

      moves[i].length = Math.abs(moves[i].to - moves[i].from);
      moves[i].from = to;
      moves[i].to = to + length;
    }
  }
};

var insert = function insert(array, index, values) {
  for (var i = 0; i < values.length; i++) {
    if (i in values) {
      var idx = index + i;
      if (array.length < idx) array.length = idx;
      array.splice(idx, 0, values[i]);
    }
  }
  return values;
};

var remove = function remove(array, index, length) {
  return splice_.call(array, index, length);
};

var move = function move(array, from, to, length) {
  var moved = remove(array, from, length);
  insert(array, to, moved);
  return moved;
};

var patch = function patch(array, operations) {
  for (var i = 0; i < operations.length; i++) {
    var operation = operations[i];
    switch (operation.type) {
      case 'move':
        move(array, operation.from, operation.to, operation.length);break;
      case 'remove':
        remove(array, operation.index, operation.length);break;
      case 'insert':
        insert(array, operation.index, operation.values);break;
    }
  }
  return array;
};

var diff = function diff(before, after) {
  var operations = annotate(before, after);
  return offset.apply(this, operations);
};

diff.annotate = annotate;
diff.offset = offset;

diff.remove = remove;
diff.insert = insert;
diff.move = move;
diff.patch = patch;

module.exports = diff;

},{}],111:[function(require,module,exports){
/**
 * @module spotify-live/util/ordered-set
 * @private
 */
'use strict';

// prime

var prime = require('prime');

// mout
var forEach = require('mout/array/forEach');

var Range = require('../../spotify-range2');
var _diff = require('./diff');

var OrderedSet = prime({

  constructor: function constructor(length) {
    if (!length) length = 0;
    this.index = [];
    this.keys = new Array(length);
    this.values = new Array(length);
    this.objectStorage = {};
  },

  get length() {
    return this.keys.length;
  },

  set length(value) {
    this.keys.length = value;
    this.values.length = value;
  },

  forEach: function forEach(fn, ctx) {
    var index = this.index;
    main: for (var k = 0; k < index.length; k++) {
      var range = index[k];
      for (var i = range.start; i < range.end; i++) {
        if (fn.call(ctx, this.values[i], i, this.keys[i], this) === false) break main;
      }
    }
    return this;
  },

  map: function map(fn, ctx) {
    var values = new Array(this.length);
    this.forEach(function (value, index, key) {
      values[index] = fn.call(ctx, value, index, key, this);
    }, this);
    return values;
  },

  copy: function copy(set) {
    this.index = set.index.slice();
    this.keys = set.keys.slice();
    this.values = set.values.slice();
    var length = this.keys.length;
    this.objectStorage = {};
    for (var i = 0; i < length; i++) {
      this.objectStorage[this.keys[i]] = this.values[i];
    }
    return this;
  },

  clone: function clone() {
    return new OrderedSet().copy(this);
  },

  indexOf: function indexOf(key) {
    var index = -1;
    this.forEach(function (v, i, k) {
      if (key === k) {
        index = i;
        return false;
      }
    });
    return index;
  },

  indexOfMany: function indexOfMany(keys) {
    var indexedKeys = {};
    var found = 0;
    var output = [];

    // create a hash with the keys that are going to be searched, so we can
    // access them really fast later
    for (var i = 0; i < keys.length; i++) {
      indexedKeys[keys[i]] = -1;
    }

    this.forEach(function (v, i, k) {
      // If the element one that is being searched, add its position
      // to the output array
      if (k in indexedKeys) {
        indexedKeys[k] = i;
        found++;

        // when we have found all the search keys, we do not need to iterate
        // any more
        if (found >= keys.length) {
          return false;
        }
      }
    });

    for (i = 0; i < keys.length; i++) {
      output[i] = indexedKeys[keys[i]];
    }

    return output;
  },

  valueOf: function valueOf(key) {
    return this.objectStorage[key] || null;
  },

  hasKey: function hasKey(key) {
    return this.objectStorage.hasOwnProperty(key);
  },

  sort: function sort(fn) {
    var keys = this.keys;
    var values = this.values;
    var operations = _diff(values.slice(), values.sort(fn));

    forEach(operations, function (op) {
      // unless something is broken, a sort only produces moves.
      _diff.move(keys, op.from, op.to, op.length);
    });

    return this;
  },

  move: function move(from, to, length) {
    if (from > this.length) return [];
    if (from + length > this.length) length = from - this.length;
    if (to > this.length) to = this.length;
    if (from === to) return [];

    _diff.move(this.keys, from, to, length);
    _diff.move(this.values, from, to, length);

    return this;
  },

  insert: function insert(index, keys, values) {
    if (keys.length !== values.length) throw new Error('length mismatch');

    var range = new Range(index, index + keys.length);
    this.index = range.insert(this.index);

    _diff.insert(this.keys, index, keys);
    _diff.insert(this.values, index, values);

    for (var i = 0, length = keys.length; i < length; i++) {
      this.objectStorage[keys[i]] = values[i];
    }

    return this;
  },

  remove: function remove(index, length) {
    if (index >= this.length) return [];
    if (index + length > this.length) length = this.length;
    var range = new Range(index, index + length);
    this.index = range.extract(this.index);

    for (var i = 0; i < length; i++) {
      delete this.objectStorage[this.keys[i + index]];
    }
    _diff.remove(this.keys, index, length);
    _diff.remove(this.values, index, length);

    return this;
  },

  diff: function diff(target) {
    var operations = _diff.annotate(this.keys, target.keys);

    forEach(operations[0], function (op) {
      // remove
      op.keys = op.values;
      op.values = this.values.slice(op.index, op.index + op.length);
    }, this);

    forEach(operations[1], function (op) {
      // move
      op.keys = op.values;
      op.values = this.values.slice(op.from, op.from + op.length);
    }, this);

    forEach(operations[2], function (op) {
      // insert
      op.keys = op.values;
      op.values = target.values.slice(op.index, op.index + op.length);
    });

    return _diff.offset.apply(_diff, operations);
  },

  patch: function patch(operations) {
    forEach(operations, function (op) {
      switch (op.type) {
        case 'move':
          this.move(op.from, op.to, op.length);break;
        case 'remove':
          this.remove(op.index, op.length);break;
        case 'insert':
          this.insert(op.index, op.keys, op.values);break;
      }
    }, this);
    return this;
  }

});

module.exports = OrderedSet;

},{"../../spotify-range2":140,"./diff":110,"mout/array/forEach":185,"prime":219}],112:[function(require,module,exports){
/**
 * @module spotify-live/util/parser
 */
'use strict';

var normalize = function normalize(value) {
  if (value !== '' && !isNaN(value)) return +value;else if (value === 'true') return true;else if (value === 'false') return false;else if (value === 'null') return null;else if (value === 'undefined') return undefined;
  return value;
};

function escapeForRegExp(str) {
  return str.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
};

var COMMA = ',';
var BMASK = '(';
var EMASK = ')';
var BFILTER = '[';
var EFILTER = ']';
var EQUALS = '=';
var WHITESPACE = '\\s';

var operators = ['=', '!=', '>=', '<=', '>', '<', '^=', '$=', '~=', '|=', '*='];

var keyBlacklist = COMMA + BMASK + EMASK + escapeForRegExp(BFILTER) + escapeForRegExp(EFILTER) + EQUALS + WHITESPACE;
var keyBlacklistCharacterClass = '[^' + keyBlacklist + ']';

var KEY_CHARACTER_REG_EXP = new RegExp(keyBlacklistCharacterClass);
var EXACT_KEY_REG_EXP = new RegExp('^' + keyBlacklistCharacterClass + '+$');

var OPERATORS_REG_EXP = new RegExp(operators.map(escapeForRegExp).join('|'));
var REPLACE_REG_EXP = /\$([\d]+)/;
var RANGE_FILTER_REG_EXP = /^(\d*):(\d*)$/;

var parse = function parse(string, params) {
  if (!params) params = [];

  var selector = { mask: [] };
  var history = [selector];

  var key = '';
  var filter;

  var filterStr = '';
  var left = '';
  var right = '';
  var op = '';

  for (var i = 0; i < string.length + 1; i++) {
    var c = string.charAt(i);

    if (filter) {
      // parse the filter
      filterStr = filterStr.trim();
      if (c === COMMA || c === EFILTER) {
        var matches;
        if (matches = filterStr.match(RANGE_FILTER_REG_EXP)) {
          left = matches[1];
          op = ':';
          right = matches[2];
        } else if (matches = filterStr.match(OPERATORS_REG_EXP)) {
          left = filterStr.substring(0, matches.index);
          op = matches[0];
          right = filterStr.substring(matches.index + op.length);
        } else if (matches = filterStr.match(EXACT_KEY_REG_EXP)) {
          left = matches[0];
        } else {
          throw new SyntaxError('syntax error: `' + filterStr + '` contains characters not valid in a filter');
        }

        filterStr = '';

        var condition = {};

        if (left) {
          var leftMatch = left.match(REPLACE_REG_EXP);
          left = leftMatch ? params[+leftMatch[1]] : normalize(left);
          condition.left = left;
        }

        if (op) condition.op = op;

        if (right) {
          var rightMatch = right.match(REPLACE_REG_EXP);
          right = rightMatch ? params[+rightMatch[1]] : normalize(right);
          condition.right = right;
        }

        if ('left' in condition || 'right' in condition) filter.push(condition);

        right = '';
        left = '';
        op = '';

        if (c === EFILTER) {
          if (filter.length) {
            var filters = selector.filters || (selector.filters = []);
            filters.push(filter);
          }

          filter = null;
        }
        continue;
      }

      filterStr += c;
    } else {
      // parse the key

      if (c && KEY_CHARACTER_REG_EXP.test(c)) {
        // key
        key += c;
      } else if (key && (!c || c === COMMA || c === BMASK || c === BFILTER || c === EMASK)) {
        // end key
        // end word is "a!" or "b(a!)" or "a!,c" or "a!(" or "a!["
        var keyMatch = key.match(REPLACE_REG_EXP);
        // begin a new selector
        history[0].mask.push(selector = { key: keyMatch ? params[+keyMatch[1]] : normalize(key) });
        key = '';
      } else if (c && key) {
        throw new SyntaxError('syntax error: `' + c + '` is not a valid character in a key');
      }

      if (c === BMASK) {
        selector.mask = [];
        history.unshift(selector);
      } else if (c === EMASK) {
        history.shift();
      }

      if (c === BFILTER) {
        filter = [];
      }
    }
  }

  if (history.length !== 1) throw new SyntaxError('syntax error');

  return history[0];
};

/** exports */
module.exports = parse;

},{}],113:[function(require,module,exports){
/**
 * @module spotify-live/util/throttle
 * @private
 */
'use strict';

var defer = require('prime/defer');
var isInteger = function isInteger(n) {
  return typeof n === 'number' && n % 1 === 0;
};

var slice = Array.prototype.slice;

var _throttle = function _throttle(fn, method, context) {
  var queued, args, cancel;

  return function () {
    args = arguments;
    if (!queued) {
      queued = true;
      cancel = method(function (time) {
        queued = false;
        fn.apply(context, slice.call(args).concat(time));
      });
    }
    return cancel;
  };
};

var throttle = function throttle(callback, argument, context) {
  if (isInteger(argument)) return throttle.timeout(callback, argument, context);else return throttle.immediate(callback, argument);
};

throttle.timeout = function (callback, ms, context) {
  return _throttle(callback, function (run) {
    return defer.timeout(run, ms, context);
  }, context);
};

throttle.frame = function (callback, context) {
  return _throttle(callback, function (run) {
    return defer.frame(run, context);
  }, context);
};

throttle.immediate = function (callback, context) {
  return _throttle(callback, function (run) {
    return defer.immediate(run, context);
  }, context);
};

module.exports = throttle;

},{"prime/defer":217}],114:[function(require,module,exports){
'use strict';

var languages = require('./languages.json');

function lookup(language, to) {
  var lang = languages[language];
  if (lang[to]) {
    return lang[to];
  } else {
    return language;
  }
}

module.exports = lookup;
module.exports.all = function () {
  return Object.keys(languages);
};

},{"./languages.json":115}],115:[function(require,module,exports){
module.exports={
  "de": {
    "smartling": "de-DE"
  },
  "el": {
    "smartling": "el-GR"
  },
  "en": {
    "smartling": "en-GB"
  },
  "es": {
    "numeral": "es-ES",
    "smartling": "es-ES"
  },
  "es-419": {
    "moment": "es",
    "numeral": "es-ES",
    "smartling": "es-LA"
  },
  "fi": {
    "smartling": "fi-FI"
  },
  "fr": {
    "smartling": "fr-FR"
  },
  "fr-CA": {
    "smartling": "fr-CA",
    "moment": "fr-ca"
  },
  "hu": {
    "smartling": "hu-HU"
  },
  "id": {
    "smartling": "id-ID"
  },
  "it": {
    "smartling": "it-IT"
  },
  "ja": {
    "smartling": "ja-JP"
  },
  "nl": {
    "numeral": "nl-nl",
    "smartling": "nl-NL"
  },
  "pl": {
    "smartling": "pl-PL"
  },
  "pt-BR": {
    "moment": "pt-br",
    "numeral": "pt-br",
    "smartling": "pt-BR"
  },
  "sv": {
    "smartling": "sv-SE"
  },
  "tr": {
    "smartling": "tr-TR"
  },
  "zh-Hant": {
    "moment": "zh-tw",
    "smartling": "zh-TW"
  },
  "zsm": {
    "moment": "ms-my",
    "smartling": "ms-MY"
  }
}
},{}],116:[function(require,module,exports){
'use strict';

var schemer = require('./schemer');
var cosmos = require('spotify-cosmos-api');
var debug = require('debug');

var id = 0;

module.exports = function log(schema, data) {
  /*eslint-disable camelcase */
  var body = schemer(schema, Object.assign({}, {
    message_name: schema.name,
    message_version: schema.schema_version
  }, data));

  // Logging cosmos endpoint requires all values to be strings.
  body.fields = body.fields.map(function (f) {
    if (typeof f === 'string') return f;
    if (f == null) return '';
    return JSON.stringify(f);
  });

  var qualifiedName = schema.name + schema.schema_version;
  /*eslint-enable camelcase */

  var messageDebug = debug('spotify-logger:' + qualifiedName);
  var requestId = ++id;

  messageDebug('REQ %s#%s %s', qualifiedName, requestId, JSON.stringify(body));

  cosmos.resolver.post({
    url: 'sp://logging/v1/log',
    body: body
  }, function (error, response) {
    if (error) return console.error(error, body);
    messageDebug('RES %s#%s %d', qualifiedName, requestId, response.getStatusCode());
  });
};

},{"./schemer":117,"debug":147,"spotify-cosmos-api":233}],117:[function(require,module,exports){
'use strict';

var validation = require('../vendor/avro-trunk/lang/js/lib/validator');
var debug = require('debug')(require('../package.json').name + ':');

module.exports = function (schema, data) {

  debug(schema.name);

  var name = data.message_name;
  var version = data.message_version;
  var copy = Object.assign({}, data);

  if (version !== schema.schema_version) throw new Error('' + 'Invalid message version: received Message with message_version ' + version + ' but the Schema requires version ' + schema.schema_version);

  // Create positional array of field values as required by cosmos and
  // log-parser, and also create an avro Field for each value to allow
  // validation.
  var fields = schema.fields.map(function (f) {
    var type = f.type;
    var value = copy[f.name];

    // If field is a union, attempt to infer the type by grabbing the first
    // non-null type from the schema.
    if (Array.isArray(f.type)) {
      copy[f.name] = {};
      var firstNoneNullType = type.filter(function (t) {
        return t !== 'null';
      })[0];
      copy[f.name][firstNoneNullType] = value;
      debug('union `%s` (%s) : `%s`', f.name, firstNoneNullType, value);
    } else {
      copy[f.name] = value;
      debug('field `%s` : `%s`', f.name, value);
    }
    return value === undefined ? f.default : value;
  })
  // remove name, version
  .slice(2);

  validation.Validator.validate(schema, copy);

  return {
    message: name,
    version: version,
    fields: fields
  };
};

module.exports.Validator = validation.Validator;
module.exports.ProtocolValidator = validation.ProtocolValidator;

},{"../package.json":119,"../vendor/avro-trunk/lang/js/lib/validator":121,"debug":147}],118:[function(require,module,exports){
'use strict';

var schema = require('../schemas/ClientEvent3.json');
var log = require('../lib/log');

module.exports = {
  schema: schema,
  log: log.bind(null, schema)
};

},{"../lib/log":116,"../schemas/ClientEvent3.json":120}],119:[function(require,module,exports){
module.exports={
  "name": "spotify-logger",
  "version": "1.0.0",
  "description": "Generate / consume log-parser schemas in JS",
  "bin": {
    "spotify-logger-schemas-generator": "bin/schemas-generator",
    "spotify-logger-messages-generator": "bin/messages-generator"
  },
  "main": "lib/log.js",
  "dependencies": {},
  "devDependencies": {},
  "scripts": {
    "dev": "echo App scripts have been removed. Please see docs/app-development.md for more information. && exit 1",
    "prod": "echo App scripts have been removed. Please see docs/app-development.md for more information. && exit 1",
    "spa": "echo App scripts have been removed. Please see docs/app-development.md for more information. && exit 1",
    "enable": "echo App scripts have been removed. Please see docs/app-development.md for more information. && exit 1"
  },
  "author": "Drew Petersen <drewp@spotify.com>",
  "license": "UNLICENSED",
  "private": true
}
},{}],120:[function(require,module,exports){
module.exports={
  "type": "record",
  "name": "ClientEvent",
  "namespace": "com.spotify.Message",
  "doc": "A generic client event primarily used by Stitch Apps",
  "fields": [
    {
      "name": "message_name",
      "type": "string"
    },
    {
      "name": "message_version",
      "type": "int"
    },
    {
      "name": "source",
      "type": [
        "null",
        "string"
      ],
      "doc": "Source which generated the event, will mostly be set to the App-ID",
      "default": null
    },
    {
      "name": "context",
      "type": [
        "null",
        "string"
      ],
      "doc": "Optional context within the app",
      "default": null
    },
    {
      "name": "event",
      "type": [
        "null",
        "string"
      ],
      "doc": "Event name",
      "default": null
    },
    {
      "name": "event_version",
      "type": [
        "null",
        "string"
      ],
      "doc": "Optional event version, can be used as a version or sub-type",
      "default": null
    },
    {
      "name": "test_version",
      "type": [
        "null",
        "string"
      ],
      "doc": "Optional test case if A/B testing",
      "default": null
    },
    {
      "name": "source_version",
      "type": [
        "null",
        "string"
      ],
      "doc": "The version of the app",
      "default": null
    },
    {
      "name": "source_vendor",
      "type": [
        "null",
        "string"
      ],
      "doc": "The app vendor",
      "default": null
    },
    {
      "name": "json_data",
      "type": [
        "null",
        "string"
      ],
      "doc": "Additional JSON data specific to the event being sent",
      "default": null
    }
  ],
  "schema_version": 3
}
},{}],121:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

// Licensed to the Apache Software Foundation (ASF) under one or more
// contributor license agreements.  See the NOTICE file distributed with
// this work for additional information regarding copyright ownership.
// The ASF licenses this file to You under the Apache License, Version 2.0
// (the "License"); you may not use this file except in compliance with
// the License.  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

if (typeof require !== 'undefined') {
  var _ = require("underscore");
}

var AvroSpec = {
  PrimitiveTypes: ['null', 'boolean', 'int', 'long', 'float', 'double', 'bytes', 'string'],
  ComplexTypes: ['record', 'enum', 'array', 'map', 'union', 'fixed']
};
AvroSpec.Types = AvroSpec.PrimitiveTypes.concat(AvroSpec.ComplexTypes);

var InvalidSchemaError = function InvalidSchemaError(msg) {
  return new Error('InvalidSchemaError: ' + msg);
};
var InvalidProtocolError = function InvalidProtocolError(msg) {
  return new Error('InvalidProtocolError: ' + msg);
};
var ValidationError = function ValidationError(msg) {
  return new Error('ValidationError: ' + msg);
};
var ProtocolValidationError = function ProtocolValidationError(msg) {
  return new Error('ProtocolValidationError: ' + msg);
};

function Record(name, namespace, fields) {
  function validateArgs(name, namespace, fields) {
    if (!_.isString(name)) {
      throw new InvalidSchemaError('Record name must be string');
    }

    if (!_.isNull(namespace) && !_.isUndefined(namespace) && !_.isString(namespace)) {
      throw new InvalidSchemaError('Record namespace must be string or null');
    }

    if (!_.isArray(fields)) {
      throw new InvalidSchemaError('Record name must be string');
    }
  }

  validateArgs(name, namespace, fields);

  this.name = name;
  this.namespace = namespace;
  this.fields = fields;
}

function makeFullyQualifiedTypeName(schema, namespace) {
  var typeName = null;
  if (_.isString(schema)) {
    typeName = schema;
  } else if (_.isObject(schema)) {
    if (_.isString(schema.namespace)) {
      namespace = schema.namespace;
    }
    if (_.isString(schema.name)) {
      typeName = schema.name;
    } else if (_.isString(schema.type)) {
      typeName = schema.type;
    }
    /** BEGIN CHANGE BY drewp **/
    else if (_.has(schema, 'valueSchema') && _.isString(schema.valueSchema.type)) {
        typeName = makeFullyQualifiedTypeName(schema.valueSchema, namespace);
      }
    /** END CHANGE BY drewp **/
  } else {
      throw new InvalidSchemaError('unable to determine fully qualified type name from schema ' + JSON.stringify(schema) + ' in namespace ' + namespace);
    }

  if (!_.isString(typeName)) {
    throw new InvalidSchemaError('unable to determine type name from schema ' + JSON.stringify(schema) + ' in namespace ' + namespace);
  }

  if (typeName.indexOf('.') !== -1) {
    return typeName;
  } else if (_.contains(AvroSpec.PrimitiveTypes, typeName)) {
    return typeName;
  } else if (_.isString(namespace)) {
    return namespace + '.' + typeName;
  } else {
    return typeName;
  }
}

function Union(typeSchemas, namespace) {
  this.branchNames = function () {
    return _.map(typeSchemas, function (typeSchema) {
      return makeFullyQualifiedTypeName(typeSchema, namespace);
    });
  };

  function validateArgs(typeSchemas) {
    if (!_.isArray(typeSchemas) || _.isEmpty(typeSchemas)) {
      throw new InvalidSchemaError('Union must have at least 1 branch');
    }
  }

  validateArgs(typeSchemas);

  this.typeSchemas = typeSchemas;
  this.namespace = namespace;
}

function Enum(symbols) {

  function validateArgs(symbols) {
    if (!_.isArray(symbols)) {
      throw new InvalidSchemaError('Enum must have array of symbols, got ' + JSON.stringify(symbols));
    }
    if (!_.all(symbols, function (symbol) {
      return _.isString(symbol);
    })) {
      throw new InvalidSchemaError('Enum symbols must be strings, got ' + JSON.stringify(symbols));
    }
  }

  validateArgs(symbols);

  this.symbols = symbols;
}

function AvroArray(itemSchema) {

  function validateArgs(itemSchema) {
    if (_.isNull(itemSchema) || _.isUndefined(itemSchema)) {
      throw new InvalidSchemaError('Array "items" schema should not be null or undefined');
    }
  }

  validateArgs(itemSchema);

  this.itemSchema = itemSchema;
}

function Map(valueSchema) {
  function validateArgs(valueSchema) {
    if (_.isNull(valueSchema) || _.isUndefined(valueSchema)) {
      throw new InvalidSchemaError('Map "values" schema should not be null or undefined');
    }
  }

  validateArgs(valueSchema);

  this.valueSchema = valueSchema;
}

function Field(name, schema) {
  function validateArgs(name, schema) {
    if (!_.isString(name)) {
      throw new InvalidSchemaError('Field name must be string');
    }
  }

  this.name = name;
  this.schema = schema;
}

function Primitive(type) {
  function validateArgs(type) {
    if (!_.isString(type)) {
      throw new InvalidSchemaError('Primitive type name must be a string');
    }

    if (!_.contains(AvroSpec.PrimitiveTypes, type)) {
      throw new InvalidSchemaError('Primitive type must be one of: ' + JSON.stringify(AvroSpec.PrimitiveTypes) + '; got ' + type);
    }
  }

  validateArgs(type);

  this.type = type;
}

function Validator(schema, namespace, namedTypes) {
  this.validate = function (obj) {
    return _validate(this.schema, obj);
  };

  var _validate = function _validate(schema, obj) {
    if (schema instanceof Record) {
      return _validateRecord(schema, obj);
    } else if (schema instanceof Union) {
      return _validateUnion(schema, obj);
    } else if (schema instanceof Enum) {
      return _validateEnum(schema, obj);
    } else if (schema instanceof AvroArray) {
      return _validateArray(schema, obj);
    } else if (schema instanceof Map) {
      return _validateMap(schema, obj);
    } else if (schema instanceof Primitive) {
      return _validatePrimitive(schema, obj);
    } else {
      throw new InvalidSchemaError('validation not yet implemented: ' + JSON.stringify(schema));
    }
  };

  var _validateRecord = function _validateRecord(schema, obj) {
    if (!_.isObject(obj) || _.isArray(obj)) {
      throw new ValidationError('Expected record Javascript type to be non-array object, got ' + JSON.stringify(obj));
    }

    var schemaFieldNames = _.pluck(schema.fields, 'name').sort();
    var objFieldNames = _.keys(obj).sort();
    if (!_.isEqual(schemaFieldNames, objFieldNames)) {
      throw new ValidationError('Expected record fields ' + JSON.stringify(schemaFieldNames) + '; got ' + JSON.stringify(objFieldNames));
    }

    return _.all(schema.fields, function (field) {
      return _validate(field.schema, obj[field.name]);
    });
  };

  var _validateUnion = function _validateUnion(schema, obj) {
    if (_.isObject(obj)) {
      if (_.isArray(obj)) {
        throw new ValidationError('Expected union Javascript type to be non-array object (or null), got ' + JSON.stringify(obj));
      } else if (_.size(obj) !== 1) {
        throw new ValidationError('Expected union Javascript object to be object with exactly 1 key (or null), got ' + JSON.stringify(obj));
      } else {
        var unionBranch = _.keys(obj)[0];
        if (unionBranch === "") {
          throw new ValidationError('Expected union Javascript object to contain non-empty string branch, got ' + JSON.stringify(obj));
        }
        if (_.contains(schema.branchNames(), unionBranch)) {
          return true;
        } else {
          throw new ValidationError('Expected union branch to be one of ' + JSON.stringify(schema.branchNames()) + '; got ' + JSON.stringify(unionBranch));
        }
      }
    } else if (_.isNull(obj)) {
      if (_.contains(schema.branchNames(), 'null')) {
        return true;
      } else {
        throw new ValidationError('Expected union branch to be one of ' + JSON.stringify(schema.branchNames()) + '; got ' + JSON.stringify(obj));
      }
    } else {
      throw new ValidationError('Expected union Javascript object to be non-array object of size 1 or null, got ' + JSON.stringify(obj));
    }
  };

  var _validateEnum = function _validateEnum(schema, obj) {
    if (_.isString(obj)) {
      if (_.contains(schema.symbols, obj)) {
        return true;
      } else {
        throw new ValidationError('Expected enum value to be one of ' + JSON.stringify(schema.symbols) + '; got ' + JSON.stringify(obj));
      }
    } else {
      throw new ValidationError('Expected enum Javascript object to be string, got ' + JSON.stringify(obj));
    }
  };

  var _validateArray = function _validateArray(schema, obj) {
    if (_.isArray(obj)) {
      return _.all(obj, function (member) {
        return _validate(schema.itemSchema, member);
      });
    } else {
      throw new ValidationError('Expected array Javascript object to be array, got ' + JSON.stringify(obj));
    }
  };

  var _validateMap = function _validateMap(schema, obj) {
    if (_.isObject(obj) && !_.isArray(obj)) {
      return _.all(obj, function (value) {
        return _validate(schema.valueSchema, value);
      });
    } else if (_.isArray(obj)) {
      throw new ValidationError('Expected map Javascript object to be non-array object, got array ' + JSON.stringify(obj));
    } else {
      throw new ValidationError('Expected map Javascript object to be non-array object, got ' + JSON.stringify(obj));
    }
  };

  var _validatePrimitive = function _validatePrimitive(schema, obj) {
    switch (schema.type) {
      case 'null':
        if (_.isNull(obj) || _.isUndefined(obj)) {
          return true;
        } else {
          throw new ValidationError('Expected Javascript null or undefined for Avro null, got ' + JSON.stringify(obj));
        }
        break;
      case 'boolean':
        if (_.isBoolean(obj)) {
          return true;
        } else {
          throw new ValidationError('Expected Javascript boolean for Avro boolean, got ' + JSON.stringify(obj));
        }
        break;
      case 'int':
        if (_.isNumber(obj) && Math.floor(obj) === obj && Math.abs(obj) <= Math.pow(2, 31)) {
          return true;
        } else {
          throw new ValidationError('Expected Javascript int32 number for Avro int, got ' + JSON.stringify(obj));
        }
        break;
      case 'long':
        if (_.isNumber(obj) && Math.floor(obj) === obj && Math.abs(obj) <= Math.pow(2, 63)) {
          return true;
        } else {
          throw new ValidationError('Expected Javascript int64 number for Avro long, got ' + JSON.stringify(obj));
        }
        break;
      case 'float':
        if (_.isNumber(obj)) {
          // TODO: handle NaN?
          return true;
        } else {
          throw new ValidationError('Expected Javascript float number for Avro float, got ' + JSON.stringify(obj));
        }
        break;
      case 'double':
        if (_.isNumber(obj)) {
          // TODO: handle NaN?
          return true;
        } else {
          throw new ValidationError('Expected Javascript double number for Avro double, got ' + JSON.stringify(obj));
        }
        break;
      case 'bytes':
        throw new InvalidSchemaError('not yet implemented: ' + schema.type);
      case 'string':
        if (_.isString(obj)) {
          // TODO: handle NaN?
          return true;
        } else {
          throw new ValidationError('Expected Javascript string for Avro string, got ' + JSON.stringify(obj));
        }
        break;
      default:
        throw new InvalidSchemaError('unrecognized primitive type: ' + schema.type);
    }
  };

  // TODO: namespace handling is rudimentary. multiple namespaces within a certain nested schema definition
  // are probably buggy.
  var _namedTypes = namedTypes || {};
  var _saveNamedType = function _saveNamedType(fullyQualifiedTypeName, schema) {
    if (_.has(_namedTypes, fullyQualifiedTypeName)) {
      if (!_.isEqual(_namedTypes[fullyQualifiedTypeName], schema)) {
        throw new InvalidSchemaError('conflicting definitions for type ' + fullyQualifiedTypeName + ': ' + JSON.stringify(_namedTypes[fullyQualifiedTypeName]) + ' and ' + JSON.stringify(schema));
      }
    } else {
      _namedTypes[fullyQualifiedTypeName] = schema;
    }
  };

  var _lookupTypeByFullyQualifiedName = function _lookupTypeByFullyQualifiedName(fullyQualifiedTypeName) {
    if (_.has(_namedTypes, fullyQualifiedTypeName)) {
      return _namedTypes[fullyQualifiedTypeName];
    } else {
      return null;
    }
  };

  var _parseNamedType = function _parseNamedType(schema, namespace) {
    if (_.contains(AvroSpec.PrimitiveTypes, schema)) {
      return new Primitive(schema);
    } else if (!_.isNull(_lookupTypeByFullyQualifiedName(makeFullyQualifiedTypeName(schema, namespace)))) {
      return _lookupTypeByFullyQualifiedName(makeFullyQualifiedTypeName(schema, namespace));
    } else {
      throw new InvalidSchemaError('unknown type name: ' + JSON.stringify(schema) + '; known type names are ' + JSON.stringify(_.keys(_namedTypes)));
    }
  };

  var _parseSchema = function _parseSchema(schema, parentSchema, namespace) {
    if (_.isNull(schema) || _.isUndefined(schema)) {
      throw new InvalidSchemaError('schema is null, in parentSchema: ' + JSON.stringify(parentSchema));
    } else if (_.isString(schema)) {
      return _parseNamedType(schema, namespace);
    } else if (_.isObject(schema) && !_.isArray(schema)) {
      if (schema.type === 'record') {
        var newRecord = new Record(schema.name, schema.namespace, _.map(schema.fields, function (field) {
          return new Field(field.name, _parseSchema(field.type, schema, schema.namespace || namespace));
        }));
        _saveNamedType(makeFullyQualifiedTypeName(schema, namespace), newRecord);
        return newRecord;
      } else if (schema.type === 'enum') {
        if (_.has(schema, 'symbols')) {
          var newEnum = new Enum(schema.symbols);
          _saveNamedType(makeFullyQualifiedTypeName(schema, namespace), newEnum);
          return newEnum;
        } else {
          throw new InvalidSchemaError('enum must specify symbols, got ' + JSON.stringify(schema));
        }
      } else if (schema.type === 'array') {
        if (_.has(schema, 'items')) {
          return new AvroArray(_parseSchema(schema.items, schema, namespace));
        } else {
          throw new InvalidSchemaError('array must specify "items" schema, got ' + JSON.stringify(schema));
        }
      } else if (schema.type === 'map') {
        if (_.has(schema, 'values')) {
          return new Map(_parseSchema(schema.values, schema, namespace));
        } else {
          throw new InvalidSchemaError('map must specify "values" schema, got ' + JSON.stringify(schema));
        }
      } else if (_.has(schema, 'type') && _.contains(AvroSpec.PrimitiveTypes, schema.type)) {
        return _parseNamedType(schema.type, namespace);
      } else {
        throw new InvalidSchemaError('not yet implemented: ' + schema.type);
      }
    } else if (_.isArray(schema)) {
      if (_.isEmpty(schema)) {
        throw new InvalidSchemaError('unions must have at least 1 branch');
      }
      var branchTypes = _.map(schema, function (branchType) {
        return _parseSchema(branchType, schema, namespace);
      });
      return new Union(branchTypes, namespace);
    } else {
      throw new InvalidSchemaError('unexpected Javascript type for schema: ' + (typeof schema === 'undefined' ? 'undefined' : _typeof(schema)));
    }
  };

  this.rawSchema = schema;
  this.schema = _parseSchema(schema, null, namespace);
}

Validator.validate = function (schema, obj) {
  return new Validator(schema).validate(obj);
};

function ProtocolValidator(protocol) {
  this.validate = function (typeName, obj) {
    var fullyQualifiedTypeName = makeFullyQualifiedTypeName(typeName, protocol.namespace);
    if (!_.has(_typeSchemaValidators, fullyQualifiedTypeName)) {
      throw new ProtocolValidationError('Protocol does not contain definition for type ' + JSON.stringify(fullyQualifiedTypeName) + ' (fully qualified from input "' + typeName + '"); known types are ' + JSON.stringify(_.keys(_typeSchemaValidators)));
    }
    return _typeSchemaValidators[fullyQualifiedTypeName].validate(obj);
  };

  var _typeSchemaValidators = {};
  var _initSchemaValidators = function _initSchemaValidators(protocol) {
    var namedTypes = {};
    if (!_.has(protocol, 'protocol') || !_.isString(protocol.protocol)) {
      throw new InvalidProtocolError('Protocol must contain a "protocol" attribute with a string value');
    }
    if (_.isArray(protocol.types)) {
      _.each(protocol.types, function (typeSchema) {
        var schemaValidator = new Validator(typeSchema, protocol.namespace, namedTypes);
        var fullyQualifiedTypeName = makeFullyQualifiedTypeName(typeSchema, protocol.namespace);
        _typeSchemaValidators[fullyQualifiedTypeName] = schemaValidator;
      });
    }
  };

  _initSchemaValidators(protocol);
}

ProtocolValidator.validate = function (protocol, typeName, obj) {
  return new ProtocolValidator(protocol).validate(typeName, obj);
};

if (typeof exports !== 'undefined') {
  exports['Validator'] = Validator;
  exports['ProtocolValidator'] = ProtocolValidator;
}

},{"underscore":243}],122:[function(require,module,exports){
'use strict';

/**
 * Object representing state of an app.
 *
 * @param {String} uri Spotify URI of app.
 * @constructor
 */

function AppState(uri) {
  /**
   * Spotify URI.
   *
   * @type {String}
   */
  this._uri = undefined;

  /**
   * String identifying what requested a state.
   *
   * @type {String}
   */
  this._referrer = undefined;

  if (uri !== undefined) {
    this.setURI(uri);
  }
}

/**
 * Create new instance of AppState based on JSON string.
 *
 * @param {String} json Serialized representation of AppState object.
 * @return {AppState} Instance of AppState.
 */
AppState.unserialize = function (json) {
  var s = JSON.parse(json);
  var a = new AppState();
  a.setURI(s.uri);
  a.setReferrer(s.referrer);
  return a;
};

/**
 * Test if another object is considered equal to this.
 *
 * @param {AppState} state AppState instance to compare.
 */
AppState.prototype.equals = function (state) {
  return typeof this._uri === 'string' && state instanceof AppState && this._uri === state._uri && this._referrer === state._referrer;
};

/**
 * Get App identifier.
 *
 * @return {String} Id of app contained in URI.
 */
AppState.prototype.getAppId = function () {
  var uri = this.getURI();
  var parts = uri.split(':');
  if (parts.length < 3) {
    return undefined;
  }
  if (parts[1] !== 'app') {
    return undefined;
  }
  if (parts[2] === '') {
    return undefined;
  }
  return parts[2];
};

/**
 * Get Referrer value.
 *
 * @return {String} Referrer value as string.
 */
AppState.prototype.getReferrer = function () {
  return this._referrer;
};

/**
 * Get URI value.
 *
 * @return {String} URI as string.
 */
AppState.prototype.getURI = function () {
  if (this._uri === undefined) {
    throw new Error('URI not set');
  }
  return this._uri;
};

/**
 * Create serialized representation of this instance.
 *
 * @return {String} Serialized representation of AppState object.
 */
AppState.prototype.serialize = function () {
  return JSON.stringify({
    uri: this.getURI(),
    referrer: this.getReferrer()
  });
};

/**
 * Set Referrer value.
 *
 * @param {String} referrer Referrer string.
 */
AppState.prototype.setReferrer = function (referrer) {
  this._referrer = referrer;
};

/**
 * Set URI value.
 *
 * @param {String} uri Spotify URI for app.
 */
AppState.prototype.setURI = function (uri) {
  if (typeof uri !== 'string') {
    throw new TypeError('URI must be string');
  }
  this._uri = uri;
};

module.exports = AppState;

},{}],123:[function(require,module,exports){
'use strict';

module.exports = function (numeral) {
  return {
    delimiters: {
      thousands: ',',
      decimal: '.'
    },
    abbreviations: {
      thousand: 'k',
      million: 'm',
      billion: 'b',
      trillion: 't'
    },
    ordinal: function ordinal(number) {
      var b = number % 10;
      return ~ ~(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
    },
    currency: {
      symbol: '$'
    }
  };
};

},{}],124:[function(require,module,exports){
'use strict';

var numeral = require('./numeraljs/numeral');
var locales = require('../spotify-locales');

module.exports = function (currentLanguage) {

  // We need to explicitly require all languages listed in spotify-locales
  // so that Quickstart can access them at runtime
  // (dynamic paths can't be cached).
  var languages = {
    'de': require('./numeraljs/languages/de'),
    // Custom en.js file
    'en': require('./en')(numeral),
    // es-419 falls back to es-es in Numeral.js
    'es-ES': require('./numeraljs/languages/es-ES'),
    'fi': require('./numeraljs/languages/fi'),
    'fr': require('./numeraljs/languages/fr'),
    'fr-CA': require('./numeraljs/languages/fr-CA'),
    'hu': require('./numeraljs/languages/hu'),
    'id': require('./numeraljs/languages/id'),
    'it': require('./numeraljs/languages/it'),
    'ja': require('./numeraljs/languages/ja'),
    'nl-nl': require('./numeraljs/languages/nl-nl'),
    'pl': require('./numeraljs/languages/pl'),
    'pt-br': require('./numeraljs/languages/pt-br'),
    'sv': require('./numeraljs/languages/sv'),
    'tr': require('./numeraljs/languages/tr')
  };

  var numeralLocale = locales(currentLanguage, 'numeral');
  if (!languages[numeralLocale]) {
    numeralLocale = 'en';
  }
  numeral.language(numeralLocale, languages[numeralLocale]);
  numeral.language(numeralLocale);

  return numeral;
};

},{"../spotify-locales":114,"./en":123,"./numeraljs/languages/de":125,"./numeraljs/languages/es-ES":126,"./numeraljs/languages/fi":127,"./numeraljs/languages/fr":129,"./numeraljs/languages/fr-CA":128,"./numeraljs/languages/hu":130,"./numeraljs/languages/id":131,"./numeraljs/languages/it":132,"./numeraljs/languages/ja":133,"./numeraljs/languages/nl-nl":134,"./numeraljs/languages/pl":135,"./numeraljs/languages/pt-br":136,"./numeraljs/languages/sv":137,"./numeraljs/languages/tr":138,"./numeraljs/numeral":139}],125:[function(require,module,exports){
'use strict';

/*!
 * numeral.js language configuration
 * language : German (de) – generally useful in Germany, Austria, Luxembourg, Belgium
 * author : Marco Krage : https://github.com/sinky
 */
(function () {
    var language = {
        delimiters: {
            thousands: '.',
            decimal: ','
        },
        abbreviations: {
            thousand: 'k',
            million: 'm',
            billion: 'b',
            trillion: 't'
        },
        ordinal: function ordinal(number) {
            return '.';
        },
        currency: {
            symbol: '€'
        }
    };

    // Node
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = language;
    }
})();

},{}],126:[function(require,module,exports){
'use strict';

/*!
 * numeral.js language configuration
 * language : spanish Spain
 * author : Hernan Garcia : https://github.com/hgarcia
 */
(function () {
    var language = {
        delimiters: {
            thousands: '.',
            decimal: ','
        },
        abbreviations: {
            thousand: 'k',
            million: 'mm',
            billion: 'b',
            trillion: 't'
        },
        ordinal: function ordinal(number) {
            var b = number % 10;
            return b === 1 || b === 3 ? 'er' : b === 2 ? 'do' : b === 7 || b === 0 ? 'mo' : b === 8 ? 'vo' : b === 9 ? 'no' : 'to';
        },
        currency: {
            symbol: '€'
        }
    };

    // Node
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = language;
    }
})();

},{}],127:[function(require,module,exports){
'use strict';

/*!
 * numeral.js language configuration
 * language : Finnish
 * author : Sami Saada : https://github.com/samitheberber
 */
(function () {
    var language = {
        delimiters: {
            thousands: ' ',
            decimal: ','
        },
        abbreviations: {
            thousand: 'k',
            million: 'M',
            billion: 'G',
            trillion: 'T'
        },
        ordinal: function ordinal(number) {
            return '.';
        },
        currency: {
            symbol: '€'
        }
    };

    // Node
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = language;
    }
})();

},{}],128:[function(require,module,exports){
'use strict';

/*!
 * numeral.js language configuration
 * language : french (Canada) (fr-CA)
 * author : Léo Renaud-Allaire : https://github.com/renaudleo
 */
(function () {
    var language = {
        delimiters: {
            thousands: ' ',
            decimal: ','
        },
        abbreviations: {
            thousand: 'k',
            million: 'M',
            billion: 'G',
            trillion: 'T'
        },
        ordinal: function ordinal(number) {
            return number === 1 ? 'er' : 'e';
        },
        currency: {
            symbol: '$'
        }
    };

    // Node
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = language;
    }
})();

},{}],129:[function(require,module,exports){
'use strict';

/*!
 * numeral.js language configuration
 * language : french (fr)
 * author : Adam Draper : https://github.com/adamwdraper
 */
(function () {
    var language = {
        delimiters: {
            thousands: ' ',
            decimal: ','
        },
        abbreviations: {
            thousand: 'k',
            million: 'm',
            billion: 'b',
            trillion: 't'
        },
        ordinal: function ordinal(number) {
            return number === 1 ? 'er' : 'e';
        },
        currency: {
            symbol: '€'
        }
    };

    // Node
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = language;
    }
})();

},{}],130:[function(require,module,exports){
'use strict';

/*!
 * numeral.js language configuration
 * language : Hungarian (hu)
 * author : Peter Bakondy : https://github.com/pbakondy
 */
(function () {
    var language = {
        delimiters: {
            thousands: ' ',
            decimal: ','
        },
        abbreviations: {
            thousand: 'E', // ezer
            million: 'M', // millió
            billion: 'Mrd', // milliárd
            trillion: 'T' // trillió
        },
        ordinal: function ordinal(number) {
            return '.';
        },
        currency: {
            symbol: ' Ft'
        }
    };

    // Node
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = language;
    }
})();

},{}],131:[function(require,module,exports){
'use strict';

/*!
 * numeral.js language configuration
 * language : Indonesian (id)
 */
(function () {
    var language = {
        delimiters: {
            thousands: ',',
            decimal: '.'
        },
        abbreviations: {
            thousand: 'ribu',
            million: 'juta',
            billion: 'miliar',
            trillion: 'triliun'
        },
        ordinal: function ordinal(number) {
            // According to Spotify's internal Indonesian specialist,
            // there is no ordinal symbol in Indonesian (like st, nd, th, º, ª),
            // they just use the word (equivalent to writing: first, second,
            // third, instead of 1st, 2nd, 3rd). And as we don't have such
            // capability to translate all numbers to words, this function
            // returns an empty string and wherever there's a ordinal, it will
            // just show up as the cardinal number.
            return '';
        },
        currency: {
            symbol: 'Rp'
        }
    };

    // Node
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = language;
    }
})();

},{}],132:[function(require,module,exports){
'use strict';

/*!
 * numeral.js language configuration
 * language : italian Italy (it)
 * author : Giacomo Trombi : http://cinquepunti.it
 */
(function () {
    var language = {
        delimiters: {
            thousands: '.',
            decimal: ','
        },
        abbreviations: {
            thousand: 'mila',
            million: 'mil',
            billion: 'b',
            trillion: 't'
        },
        ordinal: function ordinal(number) {
            return 'º';
        },
        currency: {
            symbol: '€'
        }
    };

    // Node
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = language;
    }
})();

},{}],133:[function(require,module,exports){
'use strict';

/*!
 * numeral.js language configuration
 * language : japanese
 * author : teppeis : https://github.com/teppeis
 */
(function () {
    var language = {
        delimiters: {
            thousands: ',',
            decimal: '.'
        },
        abbreviations: {
            thousand: '千',
            million: '百万',
            billion: '十億',
            trillion: '兆'
        },
        ordinal: function ordinal(number) {
            return '.';
        },
        currency: {
            symbol: '¥'
        }
    };

    // Node
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = language;
    }
})();

},{}],134:[function(require,module,exports){
'use strict';

/*!
 * numeral.js language configuration
 * language : netherlands-dutch (nl-nl)
 * author : Dave Clayton : https://github.com/davedx
 */
(function () {
    var language = {
        delimiters: {
            thousands: '.',
            decimal: ','
        },
        abbreviations: {
            thousand: 'k',
            million: 'mln',
            billion: 'mrd',
            trillion: 'bln'
        },
        ordinal: function ordinal(number) {
            var remainder = number % 100;
            return number !== 0 && remainder <= 1 || remainder === 8 || remainder >= 20 ? 'ste' : 'de';
        },
        currency: {
            symbol: '€ '
        }
    };

    // Node
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = language;
    }
})();

},{}],135:[function(require,module,exports){
'use strict';

/*!
 * numeral.js language configuration
 * language : polish (pl)
 * author : Dominik Bulaj : https://github.com/dominikbulaj
 */
(function () {
    var language = {
        delimiters: {
            thousands: ' ',
            decimal: ','
        },
        abbreviations: {
            thousand: 'tys.',
            million: 'mln',
            billion: 'mld',
            trillion: 'bln'
        },
        ordinal: function ordinal(number) {
            return '.';
        },
        currency: {
            symbol: 'PLN'
        }
    };

    // Node
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = language;
    }
})();

},{}],136:[function(require,module,exports){
'use strict';

/*!
 * numeral.js language configuration
 * language : portuguese brazil (pt-br)
 * author : Ramiro Varandas Jr : https://github.com/ramirovjr
 */
(function () {
    var language = {
        delimiters: {
            thousands: '.',
            decimal: ','
        },
        abbreviations: {
            thousand: 'mil',
            million: 'milhões',
            billion: 'b',
            trillion: 't'
        },
        ordinal: function ordinal(number) {
            return 'º';
        },
        currency: {
            symbol: 'R$'
        }
    };

    // Node
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = language;
    }
})();

},{}],137:[function(require,module,exports){
'use strict';

/*!
 * numeral.js language configuration
 * language : swedish
 * author :
 */
(function () {
    var language = {
        delimiters: {
            thousands: ' ',
            decimal: ','
        },
        abbreviations: {
            thousand: 't',
            million: 'mn',
            billion: 'md',
            trillion: 'bn'
        },
        ordinal: function ordinal(number) {
            return '.';
        },
        currency: {
            symbol: 'SEK'
        }
    };

    // Node
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = language;
    }
})();

},{}],138:[function(require,module,exports){
'use strict';

/*!
 * numeral.js language configuration
 * language : turkish (tr)
 * author : Ecmel Ercan : https://github.com/ecmel, Erhan Gundogan : https://github.com/erhangundogan, Burak Yiğit Kaya: https://github.com/BYK
 */
(function () {
    var suffixes = {
        1: '\'inci',
        5: '\'inci',
        8: '\'inci',
        70: '\'inci',
        80: '\'inci',

        2: '\'nci',
        7: '\'nci',
        20: '\'nci',
        50: '\'nci',

        3: '\'üncü',
        4: '\'üncü',
        100: '\'üncü',

        6: '\'ncı',

        9: '\'uncu',
        10: '\'uncu',
        30: '\'uncu',

        60: '\'ıncı',
        90: '\'ıncı'
    },
        language = {
        delimiters: {
            thousands: '.',
            decimal: ','
        },
        abbreviations: {
            thousand: 'bin',
            million: 'milyon',
            billion: 'milyar',
            trillion: 'trilyon'
        },
        ordinal: function ordinal(number) {
            if (number === 0) {
                // special case for zero
                return '\'ıncı';
            }

            var a = number % 10,
                b = number % 100 - a,
                c = number >= 100 ? 100 : null;

            return suffixes[a] || suffixes[b] || suffixes[c];
        },
        currency: {
            symbol: '₺'
        }
    };

    // Node
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = language;
    }
})();

},{}],139:[function(require,module,exports){
'use strict';

/*!
 * numeral.js
 * version : 1.5.3
 * author : Adam Draper
 * license : MIT
 * http://adamwdraper.github.com/Numeral-js/
 */

(function () {

    /************************************
        Constants
    ************************************/

    var _numeral,
        VERSION = '1.5.3',

    // internal storage for language config files
    languages = {},
        currentLanguage = 'en',
        zeroFormat = null,
        defaultFormat = '0,0',

    // check for nodeJS
    hasModule = typeof module !== 'undefined' && module.exports;

    /************************************
        Constructors
    ************************************/

    // Numeral prototype object
    function Numeral(number) {
        this._value = number;
    }

    /**
     * Implementation of toFixed() that treats floats more like decimals
     *
     * Fixes binary rounding issues (eg. (0.615).toFixed(2) === '0.61') that present
     * problems for accounting- and finance-related software.
     */
    function toFixed(value, precision, roundingFunction, optionals) {
        var power = Math.pow(10, precision),
            optionalsRegExp,
            output;

        //roundingFunction = (roundingFunction !== undefined ? roundingFunction : Math.round);
        // Multiply up by precision, round accurately, then divide and use native toFixed():
        output = (roundingFunction(value * power) / power).toFixed(precision);

        if (optionals) {
            optionalsRegExp = new RegExp('0{1,' + optionals + '}$');
            output = output.replace(optionalsRegExp, '');
        }

        return output;
    }

    /************************************
        Formatting
    ************************************/

    // determine what type of formatting we need to do
    function formatNumeral(n, format, roundingFunction) {
        var output;

        // figure out what kind of format we are dealing with
        if (format.indexOf('$') > -1) {
            // currency!!!!!
            output = formatCurrency(n, format, roundingFunction);
        } else if (format.indexOf('%') > -1) {
            // percentage
            output = formatPercentage(n, format, roundingFunction);
        } else if (format.indexOf(':') > -1) {
            // time
            output = formatTime(n, format);
        } else {
            // plain ol' numbers or bytes
            output = formatNumber(n._value, format, roundingFunction);
        }

        // return string
        return output;
    }

    // revert to number
    function unformatNumeral(n, string) {
        var stringOriginal = string,
            thousandRegExp,
            millionRegExp,
            billionRegExp,
            trillionRegExp,
            suffixes = ['KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'],
            bytesMultiplier = false,
            power;

        if (string.indexOf(':') > -1) {
            n._value = unformatTime(string);
        } else {
            if (string === zeroFormat) {
                n._value = 0;
            } else {
                if (languages[currentLanguage].delimiters.decimal !== '.') {
                    string = string.replace(/\./g, '').replace(languages[currentLanguage].delimiters.decimal, '.');
                }

                // see if abbreviations are there so that we can multiply to the correct number
                thousandRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.thousand + '(?:\\)|(\\' + languages[currentLanguage].currency.symbol + ')?(?:\\))?)?$');
                millionRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.million + '(?:\\)|(\\' + languages[currentLanguage].currency.symbol + ')?(?:\\))?)?$');
                billionRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.billion + '(?:\\)|(\\' + languages[currentLanguage].currency.symbol + ')?(?:\\))?)?$');
                trillionRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.trillion + '(?:\\)|(\\' + languages[currentLanguage].currency.symbol + ')?(?:\\))?)?$');

                // see if bytes are there so that we can multiply to the correct number
                for (power = 0; power <= suffixes.length; power++) {
                    bytesMultiplier = string.indexOf(suffixes[power]) > -1 ? Math.pow(1024, power + 1) : false;

                    if (bytesMultiplier) {
                        break;
                    }
                }

                // do some math to create our number
                n._value = (bytesMultiplier ? bytesMultiplier : 1) * (stringOriginal.match(thousandRegExp) ? Math.pow(10, 3) : 1) * (stringOriginal.match(millionRegExp) ? Math.pow(10, 6) : 1) * (stringOriginal.match(billionRegExp) ? Math.pow(10, 9) : 1) * (stringOriginal.match(trillionRegExp) ? Math.pow(10, 12) : 1) * (string.indexOf('%') > -1 ? 0.01 : 1) * ((string.split('-').length + Math.min(string.split('(').length - 1, string.split(')').length - 1)) % 2 ? 1 : -1) * Number(string.replace(/[^0-9\.]+/g, ''));

                // round if we are talking about bytes
                n._value = bytesMultiplier ? Math.ceil(n._value) : n._value;
            }
        }
        return n._value;
    }

    function formatCurrency(n, format, roundingFunction) {
        var symbolIndex = format.indexOf('$'),
            openParenIndex = format.indexOf('('),
            minusSignIndex = format.indexOf('-'),
            space = '',
            spliceIndex,
            output;

        // check for space before or after currency
        if (format.indexOf(' $') > -1) {
            space = ' ';
            format = format.replace(' $', '');
        } else if (format.indexOf('$ ') > -1) {
            space = ' ';
            format = format.replace('$ ', '');
        } else {
            format = format.replace('$', '');
        }

        // format the number
        output = formatNumber(n._value, format, roundingFunction);

        // position the symbol
        if (symbolIndex <= 1) {
            if (output.indexOf('(') > -1 || output.indexOf('-') > -1) {
                output = output.split('');
                spliceIndex = 1;
                if (symbolIndex < openParenIndex || symbolIndex < minusSignIndex) {
                    // the symbol appears before the "(" or "-"
                    spliceIndex = 0;
                }
                output.splice(spliceIndex, 0, languages[currentLanguage].currency.symbol + space);
                output = output.join('');
            } else {
                output = languages[currentLanguage].currency.symbol + space + output;
            }
        } else {
            if (output.indexOf(')') > -1) {
                output = output.split('');
                output.splice(-1, 0, space + languages[currentLanguage].currency.symbol);
                output = output.join('');
            } else {
                output = output + space + languages[currentLanguage].currency.symbol;
            }
        }

        return output;
    }

    function formatPercentage(n, format, roundingFunction) {
        var space = '',
            output,
            value = n._value * 100;

        // check for space before %
        if (format.indexOf(' %') > -1) {
            space = ' ';
            format = format.replace(' %', '');
        } else {
            format = format.replace('%', '');
        }

        output = formatNumber(value, format, roundingFunction);

        if (output.indexOf(')') > -1) {
            output = output.split('');
            output.splice(-1, 0, space + '%');
            output = output.join('');
        } else {
            output = output + space + '%';
        }

        return output;
    }

    function formatTime(n) {
        var hours = Math.floor(n._value / 60 / 60),
            minutes = Math.floor((n._value - hours * 60 * 60) / 60),
            seconds = Math.round(n._value - hours * 60 * 60 - minutes * 60);
        return hours + ':' + (minutes < 10 ? '0' + minutes : minutes) + ':' + (seconds < 10 ? '0' + seconds : seconds);
    }

    function unformatTime(string) {
        var timeArray = string.split(':'),
            seconds = 0;
        // turn hours and minutes into seconds and add them all up
        if (timeArray.length === 3) {
            // hours
            seconds = seconds + Number(timeArray[0]) * 60 * 60;
            // minutes
            seconds = seconds + Number(timeArray[1]) * 60;
            // seconds
            seconds = seconds + Number(timeArray[2]);
        } else if (timeArray.length === 2) {
            // minutes
            seconds = seconds + Number(timeArray[0]) * 60;
            // seconds
            seconds = seconds + Number(timeArray[1]);
        }
        return Number(seconds);
    }

    function formatNumber(value, format, roundingFunction) {
        var negP = false,
            signed = false,
            optDec = false,
            abbr = '',
            abbrK = false,
            // force abbreviation to thousands
        abbrM = false,
            // force abbreviation to millions
        abbrB = false,
            // force abbreviation to billions
        abbrT = false,
            // force abbreviation to trillions
        abbrForce = false,
            // force abbreviation
        bytes = '',
            ord = '',
            abs = Math.abs(value),
            suffixes = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'],
            min,
            max,
            power,
            w,
            precision,
            thousands,
            d = '',
            neg = false;

        // check if number is zero and a custom zero format has been set
        if (value === 0 && zeroFormat !== null) {
            return zeroFormat;
        } else {
            // see if we should use parentheses for negative number or if we should prefix with a sign
            // if both are present we default to parentheses
            if (format.indexOf('(') > -1) {
                negP = true;
                format = format.slice(1, -1);
            } else if (format.indexOf('+') > -1) {
                signed = true;
                format = format.replace(/\+/g, '');
            }

            // see if abbreviation is wanted
            if (format.indexOf('a') > -1) {
                // check if abbreviation is specified
                abbrK = format.indexOf('aK') >= 0;
                abbrM = format.indexOf('aM') >= 0;
                abbrB = format.indexOf('aB') >= 0;
                abbrT = format.indexOf('aT') >= 0;
                abbrForce = abbrK || abbrM || abbrB || abbrT;

                // check for space before abbreviation
                if (format.indexOf(' a') > -1) {
                    abbr = ' ';
                    format = format.replace(' a', '');
                } else {
                    format = format.replace('a', '');
                }

                if (abs >= Math.pow(10, 12) && !abbrForce || abbrT) {
                    // trillion
                    abbr = abbr + languages[currentLanguage].abbreviations.trillion;
                    value = value / Math.pow(10, 12);
                } else if (abs < Math.pow(10, 12) && abs >= Math.pow(10, 9) && !abbrForce || abbrB) {
                    // billion
                    abbr = abbr + languages[currentLanguage].abbreviations.billion;
                    value = value / Math.pow(10, 9);
                } else if (abs < Math.pow(10, 9) && abs >= Math.pow(10, 6) && !abbrForce || abbrM) {
                    // million
                    abbr = abbr + languages[currentLanguage].abbreviations.million;
                    value = value / Math.pow(10, 6);
                } else if (abs < Math.pow(10, 6) && abs >= Math.pow(10, 3) && !abbrForce || abbrK) {
                    // thousand
                    abbr = abbr + languages[currentLanguage].abbreviations.thousand;
                    value = value / Math.pow(10, 3);
                }
            }

            // see if we are formatting bytes
            if (format.indexOf('b') > -1) {
                // check for space before
                if (format.indexOf(' b') > -1) {
                    bytes = ' ';
                    format = format.replace(' b', '');
                } else {
                    format = format.replace('b', '');
                }

                for (power = 0; power <= suffixes.length; power++) {
                    min = Math.pow(1024, power);
                    max = Math.pow(1024, power + 1);

                    if (value >= min && value < max) {
                        bytes = bytes + suffixes[power];
                        if (min > 0) {
                            value = value / min;
                        }
                        break;
                    }
                }
            }

            // see if ordinal is wanted
            if (format.indexOf('o') > -1) {
                // check for space before
                if (format.indexOf(' o') > -1) {
                    ord = ' ';
                    format = format.replace(' o', '');
                } else {
                    format = format.replace('o', '');
                }

                ord = ord + languages[currentLanguage].ordinal(value);
            }

            if (format.indexOf('[.]') > -1) {
                optDec = true;
                format = format.replace('[.]', '.');
            }

            w = value.toString().split('.')[0];
            precision = format.split('.')[1];
            thousands = format.indexOf(',');

            if (precision) {
                if (precision.indexOf('[') > -1) {
                    precision = precision.replace(']', '');
                    precision = precision.split('[');
                    d = toFixed(value, precision[0].length + precision[1].length, roundingFunction, precision[1].length);
                } else {
                    d = toFixed(value, precision.length, roundingFunction);
                }

                w = d.split('.')[0];

                if (d.split('.')[1].length) {
                    d = languages[currentLanguage].delimiters.decimal + d.split('.')[1];
                } else {
                    d = '';
                }

                if (optDec && Number(d.slice(1)) === 0) {
                    d = '';
                }
            } else {
                w = toFixed(value, null, roundingFunction);
            }

            // format number
            if (w.indexOf('-') > -1) {
                w = w.slice(1);
                neg = true;
            }

            if (thousands > -1) {
                w = w.toString().replace(/(\d)(?=(\d{3})+(?!\d))/g, '$1' + languages[currentLanguage].delimiters.thousands);
            }

            if (format.indexOf('.') === 0) {
                w = '';
            }

            return (negP && neg ? '(' : '') + (!negP && neg ? '-' : '') + (!neg && signed ? '+' : '') + w + d + (ord ? ord : '') + (abbr ? abbr : '') + (bytes ? bytes : '') + (negP && neg ? ')' : '');
        }
    }

    /************************************
        Top Level Functions
    ************************************/

    _numeral = function numeral(input) {
        if (_numeral.isNumeral(input)) {
            input = input.value();
        } else if (input === 0 || typeof input === 'undefined') {
            input = 0;
        } else if (!Number(input)) {
            input = _numeral.fn.unformat(input);
        }

        return new Numeral(Number(input));
    };

    // version number
    _numeral.version = VERSION;

    // compare numeral object
    _numeral.isNumeral = function (obj) {
        return obj instanceof Numeral;
    };

    // This function will load languages and then set the global language.  If
    // no arguments are passed in, it will simply return the current global
    // language key.
    _numeral.language = function (key, values) {
        if (!key) {
            return currentLanguage;
        }

        if (key && !values) {
            if (!languages[key]) {
                throw new Error('Unknown language : ' + key);
            }
            currentLanguage = key;
        }

        if (values || !languages[key]) {
            loadLanguage(key, values);
        }

        return _numeral;
    };

    // This function provides access to the loaded language data.  If
    // no arguments are passed in, it will simply return the current
    // global language object.
    _numeral.languageData = function (key) {
        if (!key) {
            return languages[currentLanguage];
        }

        if (!languages[key]) {
            throw new Error('Unknown language : ' + key);
        }

        return languages[key];
    };

    _numeral.language('en', {
        delimiters: {
            thousands: ',',
            decimal: '.'
        },
        abbreviations: {
            thousand: 'k',
            million: 'm',
            billion: 'b',
            trillion: 't'
        },
        ordinal: function ordinal(number) {
            var b = number % 10;
            return ~ ~(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
        },
        currency: {
            symbol: '$'
        }
    });

    _numeral.zeroFormat = function (format) {
        zeroFormat = typeof format === 'string' ? format : null;
    };

    _numeral.defaultFormat = function (format) {
        defaultFormat = typeof format === 'string' ? format : '0.0';
    };

    /************************************
        Helpers
    ************************************/

    function loadLanguage(key, values) {
        languages[key] = values;
    }

    /************************************
        Floating-point helpers
    ************************************/

    // The floating-point helper functions and implementation
    // borrows heavily from sinful.js: http://guipn.github.io/sinful.js/

    /**
     * Array.prototype.reduce for browsers that don't support it
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce#Compatibility
     */
    if ('function' !== typeof Array.prototype.reduce) {
        Array.prototype.reduce = function (callback, opt_initialValue) {
            'use strict';

            if (null === this || 'undefined' === typeof this) {
                // At the moment all modern browsers, that support strict mode, have
                // native implementation of Array.prototype.reduce. For instance, IE8
                // does not support strict mode, so this check is actually useless.
                throw new TypeError('Array.prototype.reduce called on null or undefined');
            }

            if ('function' !== typeof callback) {
                throw new TypeError(callback + ' is not a function');
            }

            var index,
                value,
                length = this.length >>> 0,
                isValueSet = false;

            if (1 < arguments.length) {
                value = opt_initialValue;
                isValueSet = true;
            }

            for (index = 0; length > index; ++index) {
                if (this.hasOwnProperty(index)) {
                    if (isValueSet) {
                        value = callback(value, this[index], index, this);
                    } else {
                        value = this[index];
                        isValueSet = true;
                    }
                }
            }

            if (!isValueSet) {
                throw new TypeError('Reduce of empty array with no initial value');
            }

            return value;
        };
    }

    /**
     * Computes the multiplier necessary to make x >= 1,
     * effectively eliminating miscalculations caused by
     * finite precision.
     */
    function multiplier(x) {
        var parts = x.toString().split('.');
        if (parts.length < 2) {
            return 1;
        }
        return Math.pow(10, parts[1].length);
    }

    /**
     * Given a variable number of arguments, returns the maximum
     * multiplier that must be used to normalize an operation involving
     * all of them.
     */
    function correctionFactor() {
        var args = Array.prototype.slice.call(arguments);
        return args.reduce(function (prev, next) {
            var mp = multiplier(prev),
                mn = multiplier(next);
            return mp > mn ? mp : mn;
        }, -Infinity);
    }

    /************************************
        Numeral Prototype
    ************************************/

    _numeral.fn = Numeral.prototype = {

        clone: function clone() {
            return _numeral(this);
        },

        format: function format(inputString, roundingFunction) {
            return formatNumeral(this, inputString ? inputString : defaultFormat, roundingFunction !== undefined ? roundingFunction : Math.round);
        },

        unformat: function unformat(inputString) {
            if (Object.prototype.toString.call(inputString) === '[object Number]') {
                return inputString;
            }
            return unformatNumeral(this, inputString ? inputString : defaultFormat);
        },

        value: function value() {
            return this._value;
        },

        valueOf: function valueOf() {
            return this._value;
        },

        set: function set(value) {
            this._value = Number(value);
            return this;
        },

        add: function add(value) {
            var corrFactor = correctionFactor.call(null, this._value, value);
            function cback(accum, curr, currI, O) {
                return accum + corrFactor * curr;
            }
            this._value = [this._value, value].reduce(cback, 0) / corrFactor;
            return this;
        },

        subtract: function subtract(value) {
            var corrFactor = correctionFactor.call(null, this._value, value);
            function cback(accum, curr, currI, O) {
                return accum - corrFactor * curr;
            }
            this._value = [value].reduce(cback, this._value * corrFactor) / corrFactor;
            return this;
        },

        multiply: function multiply(value) {
            function cback(accum, curr, currI, O) {
                var corrFactor = correctionFactor(accum, curr);
                return accum * corrFactor * (curr * corrFactor) / (corrFactor * corrFactor);
            }
            this._value = [this._value, value].reduce(cback, 1);
            return this;
        },

        divide: function divide(value) {
            function cback(accum, curr, currI, O) {
                var corrFactor = correctionFactor(accum, curr);
                return accum * corrFactor / (curr * corrFactor);
            }
            this._value = [this._value, value].reduce(cback);
            return this;
        },

        difference: function difference(value) {
            return Math.abs(_numeral(this._value).subtract(value).value());
        }

    };

    /************************************
        Exposing Numeral
    ************************************/

    module.exports = _numeral;
}).call(undefined);

},{}],140:[function(require,module,exports){
/**
 * @module spotify-range2
 */
'use strict';

var prime = require('prime');

var map = require('mout/array/map');

var push_ = Array.prototype.push;
var slice_ = Array.prototype.slice;

var Range = prime( /** @lends Range.prototype */{

  /**
   * The representation of a range
   * @constructs
   * @param {Number} start The start of the range.
   * @param {Number} end The end of the range.
   */
  constructor: function Range(start, end) {
    this.update(start, end);
  },

  /** Update a range. */
  update: function update(start, end) {
    if (start !== null) this.start = start;
    if (end !== null) this.end = end;
    if (this.start === null || this.end === null) throw new Error('invalid range');
    if (this.start > this.end) throw new Error('invalid range');
    this.length = this.end - this.start;
    return this;
  },

  /** Copy a range. */
  copy: function copy() {
    return new Range(this.start, this.end);
  },

  /** Range is above range. */
  above: function above(range) {
    if (!range) return false;
    return this.start >= range.end;
  },

  /** Range is below range. */
  below: function below(range) {
    if (!range) return false;
    return this.end <= range.start;
  },

  adjacent: function adjacent(range) {
    if (!range) return false;
    return this.end === range.start || this.start === range.end;
  },

  /** Range intersects range. */
  intersects: function intersects(range) {
    if (!range) return false;
    return !this.above(range) && !this.below(range);
  },

  /** Range contains range. */
  contains: function contains(range) {
    if (!range) return false;
    return this.start <= range.start && this.end >= range.end;
  },

  /** Range is contained by ranges. */
  contained: function contained(range) {
    var ranges;
    if (range instanceof Range) ranges = arguments;else ranges = range;
    if (!ranges) return false;

    for (var i = 0; ranges[i] !== undefined; i++) {
      var r = ranges[i];
      if (r.start <= this.start && r.end >= this.end) {
        return true;
      }
    }
    return false;
  },

  /** Range fits two ranges. */
  fits: function fits(prev, next) {
    if (!prev && !next) return true;
    if (!prev) return this.end <= next.start;
    if (!next) return this.start >= prev.end;
    return this.start >= prev.end && this.end <= next.start;
  },

  // get the section of this range contained between two ranges
  // [0, 20] » [0, 8], [16, 20] » [8, 16]

  /** portion of a range between two ranges. */
  between: function between(prev, next) {
    if (!prev && !next) return this.copy();
    if (!prev) return this.start >= next.start ? null : new Range(this.start, Math.min(this.end, next.start));
    if (!next) return this.end <= prev.end ? null : new Range(Math.max(prev.end, this.start), this.end);

    return this.end > prev.end && this.start < next.start ? new Range(Math.max(prev.end, this.start), Math.min(next.start, this.end)) : null;
  },

  // [0, 8] » [0, 2], [4, 5] = [0, 2], [4, 5]
  // [3, 6] » [5, 7] = [5, 6]
  // [6, 9] » [5, 7] = [6, 7]

  /** intersection of a range with many ranges */
  intersection: function intersection(range) {
    var intersected = [];
    var ranges;
    if (range instanceof Range) ranges = arguments;else ranges = range;
    for (var k = 0; k < ranges.length; k++) {
      var r = ranges[k];
      if (this.below(r)) break;

      if (r.intersects(this)) intersected.push(new Range(Math.max(this.start, r.start), Math.min(this.end, r.end)));
    }
    return intersected;
  },

  // subtract ranges from this range
  // [0, 8] » [0, 2], [4, 5] = [2, 4], [5, 8]

  /** subtract many ranges from the range. */
  subtract: function subtract(range) {
    var subtracted = [];
    var ranges;
    if (range instanceof Range) ranges = arguments;else ranges = range;
    for (var k = -1; k < ranges.length; k++) {
      var prev = ranges[k];
      var next = ranges[k + 1];
      var between = this.between(prev, next);
      if (between) subtracted.push(between);
    }
    return subtracted;
  },

  // extract this range from ranges
  // [0, 8] » [0, 2], [5, 8] = []
  // [8, 20] » [0, 2], [5, 8] = [0, 2], [5, 8]
  // [0, 10] » [5, 10], [15, 20] = [5, 10]
  // [10, 20] » [5, 80], [90, 100] = [5, 70] [80, 90]
  // [10, 20] » [0, 10], [20, 30] = [0, 20]

  /** extract the range from many ranges. */
  extract: function extract(range) {
    var ranges = range instanceof Range ? slice_.call(arguments) : range.slice();

    for (var k = 0; k < ranges.length; k++) {
      var prev = ranges[k - 1];
      var next = ranges[k];

      var newRange = null;

      if (this.below(next)) {
        newRange = new Range(next.start - this.length, next.end - this.length);
      } else if (this.intersects(next)) {
        var subtracted = next.subtract(this);
        if (subtracted.length === 2) {
          // is contained
          newRange = new Range(subtracted[0].start, subtracted[1].end - this.length);
        } else if (subtracted.length === 1) {
          if (next.end > this.end) {
            // second segment kept
            newRange = new Range(subtracted[0].start - this.length, subtracted[0].end - this.length);
          } else if (this.start > next.start) {
            // first segment kept
            newRange = new Range(subtracted[0].start, subtracted[0].end);
          }
        } else {
          // gets eaten
          ranges.splice(k--, 1); // decrease k
        }
      } else {
          ranges.splice(k, 1, next.copy());
        }

      if (newRange) {
        if (prev && prev.end === newRange.start) {
          // touches previous
          ranges.splice(k-- - 1, 2, new Range(prev.start, newRange.end)); // decrease k due to splicing
        } else {
            ranges.splice(k, 1, newRange);
          }
      }
    }

    return ranges;
  },

  // [2,3] » [0,1], [2,3] = [0,1], [2,4]
  // [1,2] » [0,6] = [0,7]
  // [0,1] » [0,1], [5,6] = [0,2], [6,7]
  // [4,6] » [0,1], [5,6] = [0,1], [4,6], [7,8]

  // TODO: this can be slightly better. merging can be done in one loop.

  /** insert the range in many ranges. */
  insert: function insert(range) {
    var ranges = range instanceof Range ? slice_.call(arguments) : range.slice();

    for (var k = 0; k < ranges.length; k++) {
      var next = ranges[k];

      if (this.start >= next.end) {
        ranges.splice(k, 1, next.copy());
      } else if (this.start > next.start && this.start < next.end) {
        ranges.splice(k, 1, new Range(next.start, this.start), new Range(this.start, next.end));
      } else {
        ranges.splice(k, 1, new Range(next.start + this.length, next.end + this.length));
      }
    }

    return this.merge(ranges);
  },

  // merge this range in ranges
  // [0, 8] » [0, 2], [5, 8] = [0, 8]
  // [8, 20] » [0, 2], [5, 8] = [0, 2], [5, 20]
  // [0, 10] » [5, 10], [15, 20] = [0, 10], [15, 20]

  /** merge many ranges to the range. */
  merge: function merge(range) {
    var ranges;
    if (range instanceof Range) ranges = arguments;else ranges = range;

    ranges = map(ranges, function (r) {
      return r.copy();
    });

    if (!ranges.length) return [this.copy()];

    var k;
    var l;

    for (k = -1, l = ranges.length; k < l; k++) {
      var prev = ranges[k];
      var next = ranges[k + 1];
      var between = this.between(prev, next);

      if (between) {
        if (!prev && next) {
          if (between.end === next.start) {
            next.update(between.start, next.end);
          } else {
            k++; // increase k since we had a push
            ranges.unshift(between);
          }
        } else if (prev && next) {
          if (prev.end === between.start && between.end === next.start) {
            prev.update(prev.start, next.end);
            ranges.splice(k-- + 1, 1); // remove the next, decrease k since we had a splice
          } else if (prev.end === between.start) {
              prev.update(prev.start, between.end);
            } else if (between.end === next.start) {
              next.update(between.start, next.end);
            } else {
              ranges.splice(k + 1, 0, between);
            }
        } else if (prev && !next) {
          if (prev.end === between.start) {
            prev.update(prev.start, between.end);
          } else {
            k++; // increase k since we had a push
            ranges.push(between);
          }
        }
      }
    }

    return ranges;
  },

  /** Remove range from many ranges
      - The range(s) you pass is what you remove from */
  remove: function remove(range) {
    var ranges;
    if (range instanceof Range) ranges = arguments;else ranges = range;
    var result = [];
    for (var i = 0; i < ranges.length; i++) {
      var remaining = ranges[i].subtract(this);
      if (remaining.length) push_.apply(result, remaining);
    }
    return result;
  },

  /** Range to an array of indices */
  toIndices: function toIndices() {
    var indices = [];
    for (var i = this.start; i < this.end; i++) {
      indices.push(i);
    }return indices;
  },

  /** Range to a string */
  toString: function toString() {
    return [this.start, this.end] + '';
  }

});

/**
 * Range from a string
 * @memberof Range
 * @static
 * @param {String} string - The string.
 * @return {Range} The range.
 */
Range.fromString = function (string) {
  var parts = string.split(',');
  return new Range(+parts[0], +parts[1]);
};

/**
 * Ranges from an array of indices
 * @memberof Range
 * @static
 * @param {Array} indices - An array of indices.
 * @return {Array} An array of Ranges.
 */
Range.fromIndices = function (indices) {
  indices.sort(function (a, b) {
    return a > b ? 1 : -1;
  });

  var ranges = [];
  var rstart;
  var rend;

  for (var i = 0; i < indices.length; i++) {
    rstart = indices[i];
    rend = rstart;
    while (indices[i + 1] - indices[i] === 1) {
      rend = indices[i + 1]; // increment the index if the numbers sequential
      i++;
    }
    ranges.push(new Range(rstart, rend + 1));
  }

  return ranges;
};

/**
 * A function that returns a range.
 * @function
 * @see Range
 * @param {Number} start The start of the range.
 * @param {Number} end The end of the range.
 */
module.exports = Range;

},{"mout/array/map":187,"prime":219}],141:[function(require,module,exports){
'use strict';

function Translations() {
  this._data = {};

  // ensure that the context of the get method is always this object
  this.get = this.get.bind(this);
}

/**
 * Default implementation if the
 * locale is not loaded
 */
Translations.prototype.injectData = function (data) {
  this._data = data;
};

/**
 * Get a translation
 */
Translations.prototype.get = function (key, var_args) {
  var format = this._data.hasOwnProperty(key) ? this._data[key] : key;
  var args = arguments;

  return format.replace(/\{(\d+?)\}/g, function (str, num) {
    var value = args[+num + 1];

    // Do not change by a ||. A value of an empty string would make it fail.
    return typeof value !== 'undefined' ? value : str;
  });
};

/**
 * Gets the raw translations data
 * @return {Object} Locale object
 */
Translations.prototype.getData = function () {
  return this._data;
};

/**
 * Creates a translations instance with the specified data
 *
 * @param {Object} data Translations object
 * @return {Translations}
 */
Translations.createWithData = function (data) {
  var translations = new Translations();
  translations.injectData(data);
  return translations;
};

module.exports = Translations;

},{}],142:[function(require,module,exports){
'use strict';

exports.message = require('./src/message');
exports.request = require('./src/request');
exports.response = require('./src/response');
exports.playerstate = require('./src/player_state');

},{"./src/message":143,"./src/player_state":144,"./src/request":145,"./src/response":146}],143:[function(require,module,exports){
/**
 * A set of Message headers.
 *
 * @name exports.Headers
 * @typedef {Object.<string, string>}
 */
exports.Headers;

/**
 * A body of a Request-Response.
 *
 * @name exports.Body
 * @typedef {*}
 */
exports.Body;

/**
 * A serialized Message object.
 *
 * @name Spotify.Cosmos.SerializedMessage
 * @typedef {{
 *   uri: Spotify.Cosmos.URI,
 *   headers: Spotify.Cosmos.Headers,
 *   body: Spotify.Cosmos.Body
 * }}
 */
exports.SerializedMessage;

/**
 * Encapsulates a message.
 *
 * A message is an entity that has a URI, headers and a body.
 *
 * @constructs Spotify.Cosmos.Message
 * @param {Spotify.Cosmos.URI} uri The URI of the message
 * @param {Spotify.Cosmos.Headers=} opt_headers The optional headers of the
 *     message.
 * @param {Spotify.Cosmos.Body=} opt_body The optional body of the message.
 */
function Message(uri, opt_headers, opt_body) {
  if (uri == null)
    throw new TypeError('Invalid `uri` argument for Message.');

  /**
   * The URI of the Message.
   *
   * @type {Spotify.Cosmos.URI}
   * @protected
   */
  this._uri = uri;

  /**
   * The headers of the Message.
   *
   * @type {Spotify.Cosmos.Headers}
   * @protected
   */
  this._headers = {};

  /**
   * The body of the Message.
   *
   * @type {Spotify.Cosmos.Body}
   * @protected
   */
  this._body = this._encodeBody(opt_body || '');

  if (opt_headers) this._setHeaders(opt_headers);
}
exports.Message = Message;

/**
 * Creates a new Message from a SerializedMessage object.
 *
 * @param {Spotify.Cosmos.SerializedMessage} object The serialized request.
 * @return {Spotify.Cosmos.Message|null} The new Message object or null.
 */
Message.fromObject = function(object) {
  return (object && object.uri) ?
    new Message(
        object.uri,
        object.headers,
        object.body
    ) : null;
};

/**
 * Encodes a message body to a string.
 *
 * @param {*} body The value for the body.
 * @return {string} The body encoded as a string.
 */
Message.prototype._encodeBody = function(body) {
  if (typeof body != 'string') {
    body = JSON.stringify(body);
  }
  return body;
};

/**
 * Returns the URI of the message.
 *
 * @return {Spotify.Cosmos.URI} The URI of the message.
 */
Message.prototype.getURI = function() {
  return this._uri;
};

/**
 * Returns the mimetype of the message.
 *
 * @return {Spotify.Cosmos.MimeType} The mimetype of the message.
 */
Message.prototype.getMimeType = function() {
  return this._headers['accept'];
};

/**
 * Returns the value of a message's headers.
 *
 * @param {string} name The name of the header.
 * @return {string|null} The header value or null if the header wasn't set.
 */
Message.prototype.getHeader = function(name) {
  return this._headers[name.toLowerCase()] || null;
};

/**
 * Returns the headers of the message.
 *
 * @return {Spotify.Cosmos.Headers} The headers of the message.
 */
Message.prototype.getHeaders = function() {
  var _headers = this._headers;
  var headers = {};
  for (var name in _headers) {
    if (!_headers.hasOwnProperty(name)) continue;
    headers[name] = _headers[name];
  }
  return headers;
};

/**
 * Sets a bunch of headers to the message's headers.
 *
 * @param {Spotify.Cosmos.Headers} headers The headers to set to the message.
 * @protected
 */
Message.prototype._setHeaders = function(headers) {
  var _headers = this._headers;
  for (var name in headers) {
    if (!headers.hasOwnProperty(name)) continue;
    _headers[name.toLowerCase()] = headers[name];
  }
  return this;
};

/**
 * Returns the body of the message.
 *
 * @return {Spotify.Cosmos.Body} The body of the message.
 */
Message.prototype.getBody = function() {
  return this._body;
};

/**
 * Returns the body as a JSON object.
 *
 * @return {Object|null} The body of the message parsed as a JSON value. Can
 *     be null if the body is not a proper JSON string.
 */
Message.prototype.getJSONBody = function() {
  try {
    return JSON.parse(this._body);
  } catch(e) {
    return null;
  }
};

/**
 * Creates a new Message instance with data copied from the current instance.
 *
 * @param {Spotify.Cosmos.Headers=} opt_headers The optional headers of the
 *     message.
 * @param {Spotify.Cosmos.Body=} opt_body The optional body of the message.
 */
Message.prototype.copy = function(opt_headers, opt_body) {
  return new Message(
      this._uri,
      this._copyHeaders(opt_headers),
      typeof opt_body != 'undefined' ? opt_body : this._body
  );
};

/**
 * Copies the headers of the message.
 *
 * @param {Spotify.Cosmos.Headers=} opt_headers The optional headers of the
 *     message.
 * @return {Spotify.Cosmos.Headers} The headers of the message.
 */
Message.prototype._copyHeaders = function(opt_headers) {
  var headers;
  if (opt_headers) {
    var _headers = this._headers;
    var name;
    headers = {};
    for (name in _headers) {
      if (!_headers.hasOwnProperty(name)) continue;
      headers[name] = _headers[name];
    }
    for (name in opt_headers) {
      if (!opt_headers.hasOwnProperty(name)) continue;
      headers[name.toLowerCase()] = opt_headers[name];
    }
  } else {
    headers = this._headers;
  }
  return headers;
};

/**
 * Serializes the message into a plain object.
 *
 * @return {Spotify.Cosmos.SerializedMessage} The serialized object.
 */
Message.prototype.serialize = function() {
  return this.toJSON();
};

/**
 * Returns a JSON-object representation of the message.
 *
 * @return {Object} The JSON representation of the message.
 */
Message.prototype.toJSON = function() {
  return {
    uri: this._uri,
    headers: this._headers,
    body: this._body
  };
};

},{}],144:[function(require,module,exports){
var inherit = require('spotify-inheritance').inherit;

/**
 * PlayerState is used for two distinct purposes: Pushing new state to the
 * player (this is done when you request to play a completely new context with
 * 'play' method) and retrieving player state updates.
 *
 * Changing properties on PlayerState objects will not change the state of
 * the player unless you pass it to the 'play' method.
 *
 * @param {Object} stateData the data for the playerState.
 */
function PlayerState(stateData) {
  Serializable.call(this, [
    'action',
    'context',
    'tracks',
    'index',
    'playing',
    'loading',
    'track',
    'position',
    'duration',
    'volume',
    'options',
    'play_origin',
    'next_page_url',
    'prev_page_url'
  ]);

  stateData = stateData || {};
  /**
   * What kind of the action player should perform.
   * It's set directly before sending the request.
   * @type {String}
   */
  this.action = stateData.action;

  /**
   * Spotify uri describing the context that
   * will be played e.g playlist, album or artist.
   * Example: spotify:artist:4XaUmUGjidSklcDHxv3XWf,
   * spotify:user:daftpunkofficial:playlist:5nrg0D90OlFyveVfrQD0zE,
   * spotify:album:2nXJkqkS1tIKIyhBcFMmwz
   *
   * @type {String}
   */
  this.context = stateData.context;

  /**
   * The list of tracks uris to play in the given context.
   * Example: [
   *    spotify:track:0bXpmJyHHYPk6QBFj25bYF,
   *    spotify:track:6DXFVsLcEvOTSrkG9G1Cb1,
   *    spotify:track:6rxEjkoar48SssZePbtb2x
   * ]
   *
   * @type {Array.<String>}
   */
  this.tracks = stateData.tracks;

  /**
   * Which element on the this.tracks list should
   * be played.
   *
   * @type {Number}
   */
  this.index = stateData.index;

  /**
   * Is the player currently playing
   */
  this.playing = stateData.playing;
  this.loading = stateData.loading;

  /**
   * Current track URI
   * @type {String}
   */
  this.track = stateData.track;


  this.position = stateData.position;

  this.volume = stateData.volume;

  /**
   * Current track duration in miliseconds?
   * @type {Number}
   */
  this.duration = stateData.duration;

  /**
   * See PlayOptions description
   * @type {cosmos-bindings-js/scripts/player_state~PlayOptions}
   */
  this.options = new PlayOptions(stateData.options);

  /**
   * See PlayOrigin description
   * @type {cosmos-bindings-js/scripts/player_state~PlayOrigin}
   */
  this.play_origin = new PlayOrigin(stateData.play_origin);

  /**
   * Before the list of tracks that are to be played ends, a request will be sent
   * to this URL, which is supposed to return a list of tracks. That list of
   * tracks will then be appended to the list of tracks in the context.
   *
   * The response payload of the next_page_url should look like this:
   *
   * {
   *   "tracks": [
   *     { "track": "spotify:track:$TRACK-ID1", "context": "spotify:album:$ALBUM-ID1" },
   *     { "track": "spotify:track:$TRACK-ID2", "context": "spotify:album:$ALBUM-ID1" },
   *     { "track": "spotify:track:$TRACK-ID3", "context": "spotify:album:$ALBUM-ID1" },
   *   ],
   *   "next_page_url": "...", // Optional
   *   "prev_page_url": "..." // Optional
   * }
   *
   * May be null, which is the same as a URL that would return an empty list
   * of tracks (but with null, no network request is made).
   */
  this.next_page_url = stateData.next_page_url;

  /**
   * Like `next_page_url`, but for going backwards in the context.
   */
  this.prev_page_url = stateData.prev_page_url;
}
inherit(PlayerState, Serializable);

/**
 * Ovverides prototype method.
 * Converts play options and origin to
 * serializable to make sure only correct data
 * is returned.
 * @return {Object} Data associated with player state.
 */
PlayerState.prototype.serialize = function() {
  if (this.options && !(this.options instanceof PlayOptions)) {
    this.options = new PlayOptions(this.options);
  }

  if (this.play_origin && !(this.play_origin instanceof PlayOrigin)) {
    this.play_origin = new PlayOrigin(this.play_origin);
  }

  return this.constructor.prototype.serialize.call(this);
};

/**
 * Possible player actions.
 */
PlayerState.ACTIONS = {
  UNKNOWN: 'unknown',
  PLAY: 'play',
  UPDATE: 'update',
  STOP: 'stop',
  RESUME: 'resume',
  PAUSE: 'pause',
  SKIP_PREV: 'skip_prev',
  SKIP_NEXT: 'skip_next'
};

function PlayOrigin(data) {
  Serializable.call(this, [
    'source',
    'source_context',
    'reason',
    'referrer',
    'referrer_version',
    'referrer_vendor'
  ]);

  data = data || {};

  /**
   * What kind of playlist did we play from?
   *
   * The default value of this property is "unknown". Must have a value.
   *
   * Valid values include 'album', 'artist', 'extlink', 'playlist', 'playqueue',
   * 'radio', 'search', 'unknown'.
   *
   * For an up to date list of valid values, see `PLAY_SOURCES` in
   * https://git.spotify.net/cgit.cgi/log-parser.git/tree/spotify/log_parser/messages_specs.py
   */
  this.source = data.source || 'unknown';

  /**
   * The uri of the view that initiated the playback.
   */
  this.source_context = data.source_context || 'unknown';

  /**
   * Why was the song started?
   *
   * The default value of this property is "unknown". Must have a value.
   *
   * A list of valid values that might be used by features:
   *
   * unknown    = Client doesn't know
   * clickrow   = A row in the song list was clicked/opened
   * playbtn    = The play button was pressed
   * urlopen    = A Url was opened
   *
   * For a complete and up to date list of valid values, see `PLAY_REASONS` in
   * https://git.spotify.net/cgit.cgi/log-parser.git/tree/spotify/log_parser/messages_specs.py
   */
  this.reason = data.reason || 'unknown';

  /**
   * Either a remote site or a spotify app which initiated the request.
   *
   * NOTE: This normally should be a readonly property and not be set
   * explicitly in the PlayerState as the Player will overwrite it when sending the request.
   */
  this.referrer = data.referrer || 'unknown';

  /**
   * The version of the referrer, where applicable. It usually makes sense to
   * set this value to the version of the JS app version, for instance "0.7.5".
   *
   * NOTE: This normally should be a readonly property and not be set
   * explicitly in the PlayerState as the Player will overwrite it when sending the request.
   */
  this.referrer_version = data.referrer_version || 'unknown';

  /**
   * The vendor of the referrer, where applicable.
   * For example com.soundrop, com.spotify.
   *
   * NOTE: This normally should be a readonly property and not be set
   * explicitly in the PlayerState as the Player will overwrite it when sending the request.
   */
  this.referrer_vendor = data.referrer_vendor || 'unknown';
}
inherit(PlayOrigin, Serializable);

/**
 * What kind of options user has
 * with the player. By default
 * all 'can_*' properties are set to true.
 * You might want to restrict some of them
 * in the special cases like ads (no skipping)
 * or radio no skipping prev.
 * @constructor
 * @param {Object} options The options data.
 */
function PlayOptions(options) {
  Serializable.call(this, [
    'repeat',
    'shuffle',
    'can_repeat',
    'can_shuffle',
    'can_skip_prev',
    'can_skip_next',
    'can_seek',
    'use_dmca_rules'
  ]);
  options = options || {};

  /**
   * True if repeat (repeat all, not single track repeat) is (or is to be) enabled.
   *
   * Default value is false
   */
  this.repeat = options.repeat !== undefined ? options.repeat : false;

  /**
   * True if shuffle is (or is to be) enabled.
   *
   * Default value is false
   */
  this.shuffle = options.shuffle !== undefined ? options.shuffle : false;

  /**
   * True if this context can be repeated. This would be false for instance in the
   * case of radio.
   *
   * Default value is true.
   */
  this.can_repeat = options.can_repeat !== undefined ? options.can_repeat : true;

  /**
   * True if this context can be shuffled. This would be false for instance in the
   * case of radio.
   *
   * Default value is true.
   */
  this.can_shuffle = options.can_shuffle !== undefined ? options.can_shuffle : true;

  /**
   * True if the user is (or should be) allowed to skip to the previous track.
   *
   * Default value is true.
   */
  this.can_skip_prev = options.can_skip_prev !== undefined ? options.can_skip_prev : true;

  /**
   * True if the user is (or should be) allowed to skip to the next track.
   *
   * Default value is true.
   */
  this.can_skip_next = options.can_skip_next !== undefined ? options.can_skip_next : true;

  /**
   * True if the user is (or should be) allowed to seek to a certain time in the
   * currently playing track.
   *
   * Default value is true.
   */
  this.can_seek = options.can_seek !== undefined ? options.can_seek : true;

  /**
   * True if the track player should automatically apply DMCA rules when playing.
   * DMCA rules should be enabled for users that have free radio in the US, and
   * controls how many tracks the user are allowed to skip etc.
   *
   * Default value is false.
   */
  this.use_dmca_rules = options.use_dmca_rules !== undefined ? options.use_dmca_rules : false;
}
inherit(PlayOptions, Serializable);

/**
 * The object accepting only defined properties.
 * To make sure only valid properties are passed
 * always use 'serialize()' when object value needed.
 * @constructor
 * @param {Array.<string>} allowedProps The list of the properties
 * that are supported for the object.
 */
function Serializable(allowedProps) {
  this._props = allowedProps || [];
}

/**
 * The JSON representation of the object.
 * @return {Object} Data associated with current player state.
 */
Serializable.prototype.serialize = function() {
  var data = {};
  var prop;

  for (var i = 0, l = this._props.length; i < l; i++) {
    prop = this._props[i];
    if (this[prop] !== undefined) {
      if (this[prop] instanceof Serializable) {
        data[prop] = this[prop].serialize();
      } else {
        data[prop] = this[prop];
      }
    }
  }

  return data;
};

exports.PlayerState = PlayerState;

},{"spotify-inheritance":240}],145:[function(require,module,exports){
var inherit = require('spotify-inheritance').inherit;

var Message = require('./message').Message;

/**
 * Request actions.
 *
 * @name exports.Action
 * @enum {string}
 */
exports.Action = {
  DELETE: 'DELETE',
  GET: 'GET',
  HEAD: 'HEAD',
  POST: 'POST',
  PUT: 'PUT',
  SUB: 'SUB',
  PATCH: 'PATCH'
};

/**
 * A serialized Request object.
 *
 * @name Spotify.Cosmos.SerializedRequest
 * @typedef {{
 *   uri: Spotify.Cosmos.URI,
 *   headers: Spotify.Cosmos.Headers,
 *   body: Spotify.Cosmos.Body
 * }}
 */
exports.SerializedRequest;

/**
 * Encapsulates a request to the handlers.
 *
 * Instances of this class are "immutable" and should not be changed.
 *
 * @constructs Spotify.Cosmos.Request
 * @extends Spotify.Cosmos.Message
 * @param {Spotify.Cosmos.Action} action The action of the request.
 * @param {Spotify.Cosmos.URI} uri The URI of the request
 * @param {Spotify.Cosmos.Headers=} opt_headers The optional headers of the
 *     request.
 * @param {Spotify.Cosmos.Body=} opt_body The optional body of the request.
 */
function Request(action, uri, opt_headers, opt_body) {
  if (!(this instanceof Request))
    return new Request(action, uri, opt_headers, opt_body);
  if (!action)
    throw new TypeError('Invalid `action` argument for Request.');
  Message.call(this, uri, opt_headers, opt_body);

  /**
   * The action of the request.
   *
   * @type {Spotify.Cosmos.Action}
   * @protected
   */
  this._action = action;
}
inherit(Request, Message);
exports.Request = Request;

/**
 * Creates a new Request from a SerializedRequest object.
 *
 * @param {Spotify.Cosmos.SerializedRequest} object The serialized request.
 * @return {Spotify.Cosmos.Request|null} The new Request object or null.
 */
Request.fromObject = function(object) {
  return (object && object.action && object.uri) ?
    new Request(
        object.action,
        object.uri,
        object.headers,
        object.body
    ) : null;
};

/**
 * Returns the action of the request.
 *
 * @return {Spotify.Cosmos.Action} The action of the request.
 */
Request.prototype.getAction = function() {
  return this._action;
};

/**
 * @inheritDoc
 */
Request.prototype.copy = function(opt_headers, opt_body) {
  return new Request(
      this._action,
      this._uri,
      this._copyHeaders(opt_headers),
      typeof opt_body != 'undefined' ? opt_body : this._body
  );
};

/**
 * @inheritDoc
 */
Request.prototype.toJSON = function() {
  return {
    action: this._action,
    uri: this._uri,
    headers: this._headers,
    body: this._body
  };
};



},{"./message":143,"spotify-inheritance":240}],146:[function(require,module,exports){
var inherit = require('spotify-inheritance').inherit;

var Message = require('./message').Message;

/**
 * Statuscode.
 * The statuses with negative numbers are reserved for
 * errors that originate within the cosmos library.
 *
 * @name exports.StatusCode
 * @enum {number}
 */
exports.StatusCode = {
  OK: 200,
  CREATED: 201,
  ACCEPTED: 202,
  BAD_REQUEST: 400,
  UNAUTHORIZED: 401,
  FORBIDDEN: 403,
  NOT_FOUND: 404,
  METHOD_NOT_ALLOWED: 405,
  TIMED_OUT: 408,
  CONFLICT: 409,
  GONE: 410,
  INTERNAL_SERVER_ERROR: 500,
  NOT_IMPLEMENTED: 501,
  BAD_GATEWAY: 502,
  SERVICE_UNAVAILABLE: 503,

  /** Something went wrong, but the exact reason is not known. */
  ERROR_UNKNOWN: -100,

  /** A resource allocation required to complete the request failed. */
  ERROR_ALLOCATION_FAILED: -101,

  /** The body could not be decoded because it does
   not conform to the encoding header field. */
  ERROR_INVALID_ENCODING: -102,

  /** The router detected an infinite loop while processing the request. */
  ERROR_INFINITE_LOOP: -103,

  /** No endpoint resolver that could handle the request was found. */
  ERROR_RESOLVER_NOT_FOUND: -104
};

/**
 * A serialized Response object.
 *
 * @name Spotify.Cosmos.SerializedResponse
 * @typedef {{
 *   uri: Spotify.Cosmos.URI,
 *   status: Spotify.Cosmos.StatusCode,
 *   headers: Spotify.Cosmos.Headers,
 *   body: Spotify.Cosmos.Body
 * }}
 */
exports.SerializedResponse;

/**
 * Encapsulates a response from the handlers.
 *
 * @constructs Spotify.Cosmos.Response
 * @extends Spotify.Cosmos.Message
 * @param {Spotify.Cosmos.URI} uri The URI of the response
 * @param {Spotify.Cosmos.StatusCode} status The status of the response.
 * @param {Spotify.Cosmos.Headers=} opt_headers The optional headers of the
 *     response.
 * @param {Spotify.Cosmos.Body=} opt_body The optional body of the response.
 */
function Response(uri, status, opt_headers, opt_body) {
  if (!(this instanceof Response))
    return new Response(uri, status, opt_headers, opt_body, opt_requestURI);
  if (typeof status == 'undefined' || status == null)
    throw new TypeError('Invalid `status` argument for Response.');

  Message.call(this, uri, opt_headers, opt_body);

  /**
   * The Status of the Response.
   *
   * @type {Spotify.Cosmos.StatusCode}
   * @protected
   */
  this._status = status;
}
inherit(Response, Message);
exports.Response = Response;

/**
 * Creates a new Response from a SerializedResponse object.
 *
 * @param {Spotify.Cosmos.SerializedResponse} object The serialized response.
 * @return {Spotify.Cosmos.Response|null} The new Response object or null.
 */
Response.fromObject = function(object) {
  return (object && object.uri && object.status) ?
    new Response(
        object.uri,
        object.status,
        object.headers,
        object.body
    ) : null;
};

/**
 * @inheritDoc
 */
Response.prototype.getMimeType = function() {
  return this._headers['content-type'];
};

/**
 * Returns the status code of the Response.
 *
 * @return {Spotify.Cosmos.StatusCode} The status code of the response.
 */
Response.prototype.getStatusCode = function() {
  return this._status;
};

/**
 * @inheritDoc
 */
Response.prototype.copy = function(opt_headers, opt_body) {
  return new Response(
      this._uri,
      this._status,
      this._copyHeaders(opt_headers),
      typeof opt_body != 'undefined' ? opt_body : this._body
  );
};

/**
 * @inheritDoc
 */
Response.prototype.toJSON = function() {
  return {
    uri: this._uri,
    status: this._status,
    headers: this._headers,
    body: this._body
  };
};


},{"./message":143,"spotify-inheritance":240}],147:[function(require,module,exports){

/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = require('./debug');
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // is webkit? http://stackoverflow.com/a/16459606/376773
  return ('WebkitAppearance' in document.documentElement.style) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (window.console && (console.firebug || (console.exception && console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  return JSON.stringify(v);
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs() {
  var args = arguments;
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return args;

  var c = 'color: ' + this.color;
  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
  return args;
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}
  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage(){
  try {
    return window.localStorage;
  } catch (e) {}
}

},{"./debug":148}],148:[function(require,module,exports){

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = debug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = require('ms');

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lowercased letter, i.e. "n".
 */

exports.formatters = {};

/**
 * Previously assigned color.
 */

var prevColor = 0;

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 *
 * @return {Number}
 * @api private
 */

function selectColor() {
  return exports.colors[prevColor++ % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function debug(namespace) {

  // define the `disabled` version
  function disabled() {
  }
  disabled.enabled = false;

  // define the `enabled` version
  function enabled() {

    var self = enabled;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // add the `color` if not set
    if (null == self.useColors) self.useColors = exports.useColors();
    if (null == self.color && self.useColors) self.color = selectColor();

    var args = Array.prototype.slice.call(arguments);

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %o
      args = ['%o'].concat(args);
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    if ('function' === typeof exports.formatArgs) {
      args = exports.formatArgs.apply(self, args);
    }
    var logFn = enabled.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }
  enabled.enabled = true;

  var fn = exports.enabled(namespace) ? enabled : disabled;

  fn.namespace = namespace;

  return fn;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  var split = (namespaces || '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

},{"ms":216}],149:[function(require,module,exports){
/*
Finally
*/'use strict';

var prime = require('prime');

var kindOf = require('mout/lang/kindOf');
var map = require('mout/array/map');
var slice = require('mout/array/slice');
var forEach = require('mout/array/forEach');
var reduce = require('mout/array/reduce');

var each = require('mout/collection/forEach');
var cmap = require('mout/collection/map');

var push_ = Array.prototype.push;

/* create the flow */
var Flow = prime({

  /* options */
  constructor: function Flow() {
    this._seq = [];
  },

  /* add steps to the flow */
  then: function() {
    this._push(this._callbacks(arguments));
    return this;
  },

  _parallel: function(parallel, args) {
    var self = this;
    return function() {
      var control = new Controller(self, self._index++);
      self._controls.push(control);
      parallel.apply(control, args ? args.concat(slice(arguments)) : arguments);
    };
  },

  _push: function(parallels, args) {
    if (!parallels.length) return;
    this._seq.push(map(parallels, function(parallel) {
      return this._parallel(parallel, args);
    }, this));
  },

  _callbacks: function(callbacks) {
    return reduce(callbacks, function(a, b) {
      if (kindOf(b) === 'Array') push_.apply(a, b);
      else a.push(b);
      return a;
    }, []);
  },

  /* will make a sequential entry for each entry in the object */
  sequential: function(object) {
    var callbacks = this._callbacks(slice(arguments, 1));
    each(object, function(value, key) {
      this._push(callbacks, [value, key]);
    }, this);
    return this;
  },

  /* will make a single sequential entry with one parallel for each entry in the object */
  parallel: function(object, parallel) {
    var parallels = cmap(object, function(value, key) {
      return this._parallel(parallel, [value, key]);
    }, this);
    if (parallels.length) this._seq.push(parallels);
    return this;
  },

  /* assign last step and execute the flow */
  finally: function() {
    this.then.apply(this, arguments);
    this._continue.call(this);
    return this;
  },

  /* execute the flow with arguments to the first step */
  run: function() {
    this._continue.apply(this, arguments);
    return this;
  },

  // private

  _break: function() {
    this._seq.splice(0, this._seq.length - 1);
    this._continue.apply(this, arguments);
  },

  _spread: function(error, args) {
    var seq = this._next();
    if (!seq || !(seq = seq[0])) return;
    if (!args || !args.length) args = [undefined];
    this._length = args.length;
    forEach(args, function(arg) {
      seq(error, arg);
    });
  },

  _continue: function() {
    var seq = this._next();
    if (!seq) return;
    this._length = seq.length;
    var args = arguments;
    forEach(seq, function(parallel) {
      parallel.apply(null, args);
    });
  },

  _next: function() {
    var seq = this._seq.shift();
    if (!seq) return;

    if (this._controls) forEach(this._controls, function(control) { // kill old controls
      control._kill();
    });

    // reset variables

    this._arguments = [];
    this._errors = [];
    this._controls = [];
    this._index = 0;

    return seq;
  },

  _done: function(index, error, data) {
    this._arguments[index] = data;
    if (error) this._errors.push(error);
    if (!--this._length) {
      var errors = null;
      if (this._errors.length === 1) errors = this._errors[0];
      else if (this._errors.length) errors = new Error(map(this._errors, function(e) {
        return e.message;
      }).join('\n'));
      this._continue.apply(this, [errors].concat(this._arguments));
    }
    else this._controls[index]._kill();
  }

});

/* control the flow */
var Controller = function Controller(flow, index) {

  var dead;

  this._kill = function() {
    dead = true;
  };

  /* break the flow */
  this.break = function() {
    if (!dead) flow._break.apply(flow, arguments);
  };

  /* step in the next sequential */
  this.continue = function() {
    if (!dead) flow._continue.apply(flow, arguments);
  };

  /* spread results to the next sequential */
  this.spread = function(error, args) {
    if (!dead) flow._spread(error, args);
  };

  /* set the the current parallel in the sequential as complete */
  var done = this.done = function(error, data) {
    if (!dead) flow._done.call(flow, index, error, data);
  };

};

/* public interface */
module.exports = function() {
  var flow = new Flow();
  flow.then.apply(flow, arguments);
  return flow;
};

},{"mout/array/forEach":150,"mout/array/map":151,"mout/array/reduce":152,"mout/array/slice":153,"mout/collection/forEach":154,"mout/collection/map":156,"mout/lang/kindOf":164,"prime":171}],150:[function(require,module,exports){


    /**
     * Array forEach
     */
    function forEach(arr, callback, thisObj) {
        if (arr == null) {
            return;
        }
        var i = -1,
            len = arr.length;
        while (++i < len) {
            // we iterate over sparse items since there is no way to make it
            // work properly on IE 7-8. see #64
            if ( callback.call(thisObj, arr[i], i, arr) === false ) {
                break;
            }
        }
    }

    module.exports = forEach;



},{}],151:[function(require,module,exports){
var makeIterator = require('../function/makeIterator_');

    /**
     * Array map
     */
    function map(arr, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        var results = [];
        if (arr == null){
            return results;
        }

        var i = -1, len = arr.length;
        while (++i < len) {
            results[i] = callback(arr[i], i, arr);
        }

        return results;
    }

     module.exports = map;


},{"../function/makeIterator_":158}],152:[function(require,module,exports){


    /**
     * Array reduce
     */
    function reduce(arr, fn, initVal) {
        // check for args.length since initVal might be "undefined" see #gh-57
        var hasInit = arguments.length > 2,
            result = initVal;

        if (arr == null || !arr.length) {
            if (!hasInit) {
                throw new Error('reduce of empty array with no initial value');
            } else {
                return initVal;
            }
        }

        var i = -1, len = arr.length;
        while (++i < len) {
            if (!hasInit) {
                result = arr[i];
                hasInit = true;
            } else {
                result = fn(result, arr[i], i, arr);
            }
        }

        return result;
    }

    module.exports = reduce;


},{}],153:[function(require,module,exports){


    /**
     * Create slice of source array or array-like object
     */
    function slice(arr, start, end){
        var len = arr.length;

        if (start == null) {
            start = 0;
        } else if (start < 0) {
            start = Math.max(len + start, 0);
        } else {
            start = Math.min(start, len);
        }

        if (end == null) {
            end = len;
        } else if (end < 0) {
            end = Math.max(len + end, 0);
        } else {
            end = Math.min(end, len);
        }

        var result = [];
        while (start < end) {
            result.push(arr[start++]);
        }

        return result;
    }

    module.exports = slice;



},{}],154:[function(require,module,exports){
var make = require('./make_');
var arrForEach = require('../array/forEach');
var objForEach = require('../object/forOwn');

    /**
     */
    module.exports = make(arrForEach, objForEach);



},{"../array/forEach":150,"../object/forOwn":167,"./make_":155}],155:[function(require,module,exports){
var slice = require('../array/slice');

    /**
     * internal method used to create other collection modules.
     */
    function makeCollectionMethod(arrMethod, objMethod, defaultReturn) {
        return function(){
            var args = slice(arguments);
            if (args[0] == null) {
                return defaultReturn;
            }
            // array-like is treated as array
            return (typeof args[0].length === 'number')? arrMethod.apply(null, args) : objMethod.apply(null, args);
        };
    }

    module.exports = makeCollectionMethod;



},{"../array/slice":153}],156:[function(require,module,exports){
var isObject = require('../lang/isObject');
var values = require('../object/values');
var arrMap = require('../array/map');
var makeIterator = require('../function/makeIterator_');

    /**
     * Map collection values, returns Array.
     */
    function map(list, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        // list.length to check array-like object, if not array-like
        // we simply map all the object values
        if( isObject(list) && list.length == null ){
            list = values(list);
        }
        return arrMap(list, function (val, key, list) {
            return callback(val, key, list);
        });
    }

    module.exports = map;



},{"../array/map":151,"../function/makeIterator_":158,"../lang/isObject":163,"../object/values":170}],157:[function(require,module,exports){


    /**
     * Returns the first argument provided to it.
     */
    function identity(val){
        return val;
    }

    module.exports = identity;



},{}],158:[function(require,module,exports){
var identity = require('./identity');
var prop = require('./prop');
var deepMatches = require('../object/deepMatches');

    /**
     * Converts argument into a valid iterator.
     * Used internally on most array/object/collection methods that receives a
     * callback/iterator providing a shortcut syntax.
     */
    function makeIterator(src, thisObj){
        if (src == null) {
            return identity;
        }
        switch(typeof src) {
            case 'function':
                // function is the first to improve perf (most common case)
                // also avoid using `Function#call` if not needed, which boosts
                // perf a lot in some cases
                return (typeof thisObj !== 'undefined')? function(val, i, arr){
                    return src.call(thisObj, val, i, arr);
                } : src;
            case 'object':
                return function(val){
                    return deepMatches(val, src);
                };
            case 'string':
            case 'number':
                return prop(src);
        }
    }

    module.exports = makeIterator;



},{"../object/deepMatches":165,"./identity":157,"./prop":159}],159:[function(require,module,exports){


    /**
     * Returns a function that gets a property of the passed object
     */
    function prop(name){
        return function(obj){
            return obj[name];
        };
    }

    module.exports = prop;



},{}],160:[function(require,module,exports){
var mixIn = require('../object/mixIn');

    /**
     * Create Object using prototypal inheritance and setting custom properties.
     * - Mix between Douglas Crockford Prototypal Inheritance <http://javascript.crockford.com/prototypal.html> and the EcmaScript 5 `Object.create()` method.
     * @param {object} parent    Parent Object.
     * @param {object} [props] Object properties.
     * @return {object} Created object.
     */
    function createObject(parent, props){
        function F(){}
        F.prototype = parent;
        return mixIn(new F(), props);

    }
    module.exports = createObject;



},{"../object/mixIn":169}],161:[function(require,module,exports){
var isKind = require('./isKind');
    /**
     */
    var isArray = Array.isArray || function (val) {
        return isKind(val, 'Array');
    };
    module.exports = isArray;


},{"./isKind":162}],162:[function(require,module,exports){
var kindOf = require('./kindOf');
    /**
     * Check if value is from a specific "kind".
     */
    function isKind(val, kind){
        return kindOf(val) === kind;
    }
    module.exports = isKind;


},{"./kindOf":164}],163:[function(require,module,exports){
var isKind = require('./isKind');
    /**
     */
    function isObject(val) {
        return isKind(val, 'Object');
    }
    module.exports = isObject;


},{"./isKind":162}],164:[function(require,module,exports){


    var _rKind = /^\[object (.*)\]$/,
        _toString = Object.prototype.toString,
        UNDEF;

    /**
     * Gets the "kind" of value. (e.g. "String", "Number", etc)
     */
    function kindOf(val) {
        if (val === null) {
            return 'Null';
        } else if (val === UNDEF) {
            return 'Undefined';
        } else {
            return _rKind.exec( _toString.call(val) )[1];
        }
    }
    module.exports = kindOf;


},{}],165:[function(require,module,exports){
var forOwn = require('./forOwn');
var isArray = require('../lang/isArray');

    function containsMatch(array, pattern) {
        var i = -1, length = array.length;
        while (++i < length) {
            if (deepMatches(array[i], pattern)) {
                return true;
            }
        }

        return false;
    }

    function matchArray(target, pattern) {
        var i = -1, patternLength = pattern.length;
        while (++i < patternLength) {
            if (!containsMatch(target, pattern[i])) {
                return false;
            }
        }

        return true;
    }

    function matchObject(target, pattern) {
        var result = true;
        forOwn(pattern, function(val, key) {
            if (!deepMatches(target[key], val)) {
                // Return false to break out of forOwn early
                return (result = false);
            }
        });

        return result;
    }

    /**
     * Recursively check if the objects match.
     */
    function deepMatches(target, pattern){
        if (target && typeof target === 'object') {
            if (isArray(target) && isArray(pattern)) {
                return matchArray(target, pattern);
            } else {
                return matchObject(target, pattern);
            }
        } else {
            return target === pattern;
        }
    }

    module.exports = deepMatches;



},{"../lang/isArray":161,"./forOwn":167}],166:[function(require,module,exports){
var hasOwn = require('./hasOwn');

    var _hasDontEnumBug,
        _dontEnums;

    function checkDontEnum(){
        _dontEnums = [
                'toString',
                'toLocaleString',
                'valueOf',
                'hasOwnProperty',
                'isPrototypeOf',
                'propertyIsEnumerable',
                'constructor'
            ];

        _hasDontEnumBug = true;

        for (var key in {'toString': null}) {
            _hasDontEnumBug = false;
        }
    }

    /**
     * Similar to Array/forEach but works over object properties and fixes Don't
     * Enum bug on IE.
     * based on: http://whattheheadsaid.com/2010/10/a-safer-object-keys-compatibility-implementation
     */
    function forIn(obj, fn, thisObj){
        var key, i = 0;
        // no need to check if argument is a real object that way we can use
        // it for arrays, functions, date, etc.

        //post-pone check till needed
        if (_hasDontEnumBug == null) checkDontEnum();

        for (key in obj) {
            if (exec(fn, obj, key, thisObj) === false) {
                break;
            }
        }


        if (_hasDontEnumBug) {
            var ctor = obj.constructor,
                isProto = !!ctor && obj === ctor.prototype;

            while (key = _dontEnums[i++]) {
                // For constructor, if it is a prototype object the constructor
                // is always non-enumerable unless defined otherwise (and
                // enumerated above).  For non-prototype objects, it will have
                // to be defined on this object, since it cannot be defined on
                // any prototype objects.
                //
                // For other [[DontEnum]] properties, check if the value is
                // different than Object prototype value.
                if (
                    (key !== 'constructor' ||
                        (!isProto && hasOwn(obj, key))) &&
                    obj[key] !== Object.prototype[key]
                ) {
                    if (exec(fn, obj, key, thisObj) === false) {
                        break;
                    }
                }
            }
        }
    }

    function exec(fn, obj, key, thisObj){
        return fn.call(thisObj, obj[key], key, obj);
    }

    module.exports = forIn;



},{"./hasOwn":168}],167:[function(require,module,exports){
var hasOwn = require('./hasOwn');
var forIn = require('./forIn');

    /**
     * Similar to Array/forEach but works over object properties and fixes Don't
     * Enum bug on IE.
     * based on: http://whattheheadsaid.com/2010/10/a-safer-object-keys-compatibility-implementation
     */
    function forOwn(obj, fn, thisObj){
        forIn(obj, function(val, key){
            if (hasOwn(obj, key)) {
                return fn.call(thisObj, obj[key], key, obj);
            }
        });
    }

    module.exports = forOwn;



},{"./forIn":166,"./hasOwn":168}],168:[function(require,module,exports){


    /**
     * Safer Object.hasOwnProperty
     */
     function hasOwn(obj, prop){
         return Object.prototype.hasOwnProperty.call(obj, prop);
     }

     module.exports = hasOwn;



},{}],169:[function(require,module,exports){
var forOwn = require('./forOwn');

    /**
    * Combine properties from all the objects into first one.
    * - This method affects target object in place, if you want to create a new Object pass an empty object as first param.
    * @param {object} target    Target Object
    * @param {...object} objects    Objects to be combined (0...n objects).
    * @return {object} Target Object.
    */
    function mixIn(target, objects){
        var i = 0,
            n = arguments.length,
            obj;
        while(++i < n){
            obj = arguments[i];
            if (obj != null) {
                forOwn(obj, copyProp, target);
            }
        }
        return target;
    }

    function copyProp(val, key){
        this[key] = val;
    }

    module.exports = mixIn;


},{"./forOwn":167}],170:[function(require,module,exports){
var forOwn = require('./forOwn');

    /**
     * Get object values
     */
    function values(obj) {
        var vals = [];
        forOwn(obj, function(val, key){
            vals.push(val);
        });
        return vals;
    }

    module.exports = values;



},{"./forOwn":167}],171:[function(require,module,exports){
/*
prime
 - prototypal inheritance
*/"use strict"

var hasOwn = require("mout/object/hasOwn"),
    mixIn  = require("mout/object/mixIn"),
    create = require("mout/lang/createObject"),
    kindOf = require("mout/lang/kindOf")

var hasDescriptors = true

try {
    Object.defineProperty({}, "~", {})
    Object.getOwnPropertyDescriptor({}, "~")
} catch (e){
    hasDescriptors = false
}

// we only need to be able to implement "toString" and "valueOf" in IE < 9
var hasEnumBug = !({valueOf: 0}).propertyIsEnumerable("valueOf"),
    buggy      = ["toString", "valueOf"]

var verbs = /^constructor|inherits|mixin$/

var implement = function(proto){
    var prototype = this.prototype

    for (var key in proto){
        if (key.match(verbs)) continue
        if (hasDescriptors){
            var descriptor = Object.getOwnPropertyDescriptor(proto, key)
            if (descriptor){
                Object.defineProperty(prototype, key, descriptor)
                continue
            }
        }
        prototype[key] = proto[key]
    }

    if (hasEnumBug) for (var i = 0; (key = buggy[i]); i++){
        var value = proto[key]
        if (value !== Object.prototype[key]) prototype[key] = value
    }

    return this
}

var prime = function(proto){

    if (kindOf(proto) === "Function") proto = {constructor: proto}

    var superprime = proto.inherits

    // if our nice proto object has no own constructor property
    // then we proceed using a ghosting constructor that all it does is
    // call the parent's constructor if it has a superprime, else an empty constructor
    // proto.constructor becomes the effective constructor
    var constructor = (hasOwn(proto, "constructor")) ? proto.constructor : (superprime) ? function(){
        return superprime.apply(this, arguments)
    } : function(){}

    if (superprime){

        mixIn(constructor, superprime)

        var superproto = superprime.prototype
        // inherit from superprime
        var cproto = constructor.prototype = create(superproto)

        // setting constructor.parent to superprime.prototype
        // because it's the shortest possible absolute reference
        constructor.parent = superproto
        cproto.constructor = constructor
    }

    if (!constructor.implement) constructor.implement = implement

    var mixins = proto.mixin
    if (mixins){
        if (kindOf(mixins) !== "Array") mixins = [mixins]
        for (var i = 0; i < mixins.length; i++) constructor.implement(create(mixins[i].prototype))
    }

    // implement proto and return constructor
    return constructor.implement(proto)

}

module.exports = prime

},{"mout/lang/createObject":160,"mout/lang/kindOf":164,"mout/object/hasOwn":168,"mout/object/mixIn":169}],172:[function(require,module,exports){
"use strict";
/*globals Handlebars: true */
var base = require("./handlebars/base");

// Each of these augment the Handlebars object. No need to setup here.
// (This is done to easily share code between commonjs and browse envs)
var SafeString = require("./handlebars/safe-string")["default"];
var Exception = require("./handlebars/exception")["default"];
var Utils = require("./handlebars/utils");
var runtime = require("./handlebars/runtime");

// For compatibility and usage outside of module systems, make the Handlebars object a namespace
var create = function() {
  var hb = new base.HandlebarsEnvironment();

  Utils.extend(hb, base);
  hb.SafeString = SafeString;
  hb.Exception = Exception;
  hb.Utils = Utils;

  hb.VM = runtime;
  hb.template = function(spec) {
    return runtime.template(spec, hb);
  };

  return hb;
};

var Handlebars = create();
Handlebars.create = create;

exports["default"] = Handlebars;
},{"./handlebars/base":173,"./handlebars/exception":174,"./handlebars/runtime":175,"./handlebars/safe-string":176,"./handlebars/utils":177}],173:[function(require,module,exports){
"use strict";
var Utils = require("./utils");
var Exception = require("./exception")["default"];

var VERSION = "1.3.0";
exports.VERSION = VERSION;var COMPILER_REVISION = 4;
exports.COMPILER_REVISION = COMPILER_REVISION;
var REVISION_CHANGES = {
  1: '<= 1.0.rc.2', // 1.0.rc.2 is actually rev2 but doesn't report it
  2: '== 1.0.0-rc.3',
  3: '== 1.0.0-rc.4',
  4: '>= 1.0.0'
};
exports.REVISION_CHANGES = REVISION_CHANGES;
var isArray = Utils.isArray,
    isFunction = Utils.isFunction,
    toString = Utils.toString,
    objectType = '[object Object]';

function HandlebarsEnvironment(helpers, partials) {
  this.helpers = helpers || {};
  this.partials = partials || {};

  registerDefaultHelpers(this);
}

exports.HandlebarsEnvironment = HandlebarsEnvironment;HandlebarsEnvironment.prototype = {
  constructor: HandlebarsEnvironment,

  logger: logger,
  log: log,

  registerHelper: function(name, fn, inverse) {
    if (toString.call(name) === objectType) {
      if (inverse || fn) { throw new Exception('Arg not supported with multiple helpers'); }
      Utils.extend(this.helpers, name);
    } else {
      if (inverse) { fn.not = inverse; }
      this.helpers[name] = fn;
    }
  },

  registerPartial: function(name, str) {
    if (toString.call(name) === objectType) {
      Utils.extend(this.partials,  name);
    } else {
      this.partials[name] = str;
    }
  }
};

function registerDefaultHelpers(instance) {
  instance.registerHelper('helperMissing', function(arg) {
    if(arguments.length === 2) {
      return undefined;
    } else {
      throw new Exception("Missing helper: '" + arg + "'");
    }
  });

  instance.registerHelper('blockHelperMissing', function(context, options) {
    var inverse = options.inverse || function() {}, fn = options.fn;

    if (isFunction(context)) { context = context.call(this); }

    if(context === true) {
      return fn(this);
    } else if(context === false || context == null) {
      return inverse(this);
    } else if (isArray(context)) {
      if(context.length > 0) {
        return instance.helpers.each(context, options);
      } else {
        return inverse(this);
      }
    } else {
      return fn(context);
    }
  });

  instance.registerHelper('each', function(context, options) {
    var fn = options.fn, inverse = options.inverse;
    var i = 0, ret = "", data;

    if (isFunction(context)) { context = context.call(this); }

    if (options.data) {
      data = createFrame(options.data);
    }

    if(context && typeof context === 'object') {
      if (isArray(context)) {
        for(var j = context.length; i<j; i++) {
          if (data) {
            data.index = i;
            data.first = (i === 0);
            data.last  = (i === (context.length-1));
          }
          ret = ret + fn(context[i], { data: data });
        }
      } else {
        for(var key in context) {
          if(context.hasOwnProperty(key)) {
            if(data) { 
              data.key = key; 
              data.index = i;
              data.first = (i === 0);
            }
            ret = ret + fn(context[key], {data: data});
            i++;
          }
        }
      }
    }

    if(i === 0){
      ret = inverse(this);
    }

    return ret;
  });

  instance.registerHelper('if', function(conditional, options) {
    if (isFunction(conditional)) { conditional = conditional.call(this); }

    // Default behavior is to render the positive path if the value is truthy and not empty.
    // The `includeZero` option may be set to treat the condtional as purely not empty based on the
    // behavior of isEmpty. Effectively this determines if 0 is handled by the positive path or negative.
    if ((!options.hash.includeZero && !conditional) || Utils.isEmpty(conditional)) {
      return options.inverse(this);
    } else {
      return options.fn(this);
    }
  });

  instance.registerHelper('unless', function(conditional, options) {
    return instance.helpers['if'].call(this, conditional, {fn: options.inverse, inverse: options.fn, hash: options.hash});
  });

  instance.registerHelper('with', function(context, options) {
    if (isFunction(context)) { context = context.call(this); }

    if (!Utils.isEmpty(context)) return options.fn(context);
  });

  instance.registerHelper('log', function(context, options) {
    var level = options.data && options.data.level != null ? parseInt(options.data.level, 10) : 1;
    instance.log(level, context);
  });
}

var logger = {
  methodMap: { 0: 'debug', 1: 'info', 2: 'warn', 3: 'error' },

  // State enum
  DEBUG: 0,
  INFO: 1,
  WARN: 2,
  ERROR: 3,
  level: 3,

  // can be overridden in the host environment
  log: function(level, obj) {
    if (logger.level <= level) {
      var method = logger.methodMap[level];
      if (typeof console !== 'undefined' && console[method]) {
        console[method].call(console, obj);
      }
    }
  }
};
exports.logger = logger;
function log(level, obj) { logger.log(level, obj); }

exports.log = log;var createFrame = function(object) {
  var obj = {};
  Utils.extend(obj, object);
  return obj;
};
exports.createFrame = createFrame;
},{"./exception":174,"./utils":177}],174:[function(require,module,exports){
"use strict";

var errorProps = ['description', 'fileName', 'lineNumber', 'message', 'name', 'number', 'stack'];

function Exception(message, node) {
  var line;
  if (node && node.firstLine) {
    line = node.firstLine;

    message += ' - ' + line + ':' + node.firstColumn;
  }

  var tmp = Error.prototype.constructor.call(this, message);

  // Unfortunately errors are not enumerable in Chrome (at least), so `for prop in tmp` doesn't work.
  for (var idx = 0; idx < errorProps.length; idx++) {
    this[errorProps[idx]] = tmp[errorProps[idx]];
  }

  if (line) {
    this.lineNumber = line;
    this.column = node.firstColumn;
  }
}

Exception.prototype = new Error();

exports["default"] = Exception;
},{}],175:[function(require,module,exports){
"use strict";
var Utils = require("./utils");
var Exception = require("./exception")["default"];
var COMPILER_REVISION = require("./base").COMPILER_REVISION;
var REVISION_CHANGES = require("./base").REVISION_CHANGES;

function checkRevision(compilerInfo) {
  var compilerRevision = compilerInfo && compilerInfo[0] || 1,
      currentRevision = COMPILER_REVISION;

  if (compilerRevision !== currentRevision) {
    if (compilerRevision < currentRevision) {
      var runtimeVersions = REVISION_CHANGES[currentRevision],
          compilerVersions = REVISION_CHANGES[compilerRevision];
      throw new Exception("Template was precompiled with an older version of Handlebars than the current runtime. "+
            "Please update your precompiler to a newer version ("+runtimeVersions+") or downgrade your runtime to an older version ("+compilerVersions+").");
    } else {
      // Use the embedded version info since the runtime doesn't know about this revision yet
      throw new Exception("Template was precompiled with a newer version of Handlebars than the current runtime. "+
            "Please update your runtime to a newer version ("+compilerInfo[1]+").");
    }
  }
}

exports.checkRevision = checkRevision;// TODO: Remove this line and break up compilePartial

function template(templateSpec, env) {
  if (!env) {
    throw new Exception("No environment passed to template");
  }

  // Note: Using env.VM references rather than local var references throughout this section to allow
  // for external users to override these as psuedo-supported APIs.
  var invokePartialWrapper = function(partial, name, context, helpers, partials, data) {
    var result = env.VM.invokePartial.apply(this, arguments);
    if (result != null) { return result; }

    if (env.compile) {
      var options = { helpers: helpers, partials: partials, data: data };
      partials[name] = env.compile(partial, { data: data !== undefined }, env);
      return partials[name](context, options);
    } else {
      throw new Exception("The partial " + name + " could not be compiled when running in runtime-only mode");
    }
  };

  // Just add water
  var container = {
    escapeExpression: Utils.escapeExpression,
    invokePartial: invokePartialWrapper,
    programs: [],
    program: function(i, fn, data) {
      var programWrapper = this.programs[i];
      if(data) {
        programWrapper = program(i, fn, data);
      } else if (!programWrapper) {
        programWrapper = this.programs[i] = program(i, fn);
      }
      return programWrapper;
    },
    merge: function(param, common) {
      var ret = param || common;

      if (param && common && (param !== common)) {
        ret = {};
        Utils.extend(ret, common);
        Utils.extend(ret, param);
      }
      return ret;
    },
    programWithDepth: env.VM.programWithDepth,
    noop: env.VM.noop,
    compilerInfo: null
  };

  return function(context, options) {
    options = options || {};
    var namespace = options.partial ? options : env,
        helpers,
        partials;

    if (!options.partial) {
      helpers = options.helpers;
      partials = options.partials;
    }
    var result = templateSpec.call(
          container,
          namespace, context,
          helpers,
          partials,
          options.data);

    if (!options.partial) {
      env.VM.checkRevision(container.compilerInfo);
    }

    return result;
  };
}

exports.template = template;function programWithDepth(i, fn, data /*, $depth */) {
  var args = Array.prototype.slice.call(arguments, 3);

  var prog = function(context, options) {
    options = options || {};

    return fn.apply(this, [context, options.data || data].concat(args));
  };
  prog.program = i;
  prog.depth = args.length;
  return prog;
}

exports.programWithDepth = programWithDepth;function program(i, fn, data) {
  var prog = function(context, options) {
    options = options || {};

    return fn(context, options.data || data);
  };
  prog.program = i;
  prog.depth = 0;
  return prog;
}

exports.program = program;function invokePartial(partial, name, context, helpers, partials, data) {
  var options = { partial: true, helpers: helpers, partials: partials, data: data };

  if(partial === undefined) {
    throw new Exception("The partial " + name + " could not be found");
  } else if(partial instanceof Function) {
    return partial(context, options);
  }
}

exports.invokePartial = invokePartial;function noop() { return ""; }

exports.noop = noop;
},{"./base":173,"./exception":174,"./utils":177}],176:[function(require,module,exports){
"use strict";
// Build out our basic SafeString type
function SafeString(string) {
  this.string = string;
}

SafeString.prototype.toString = function() {
  return "" + this.string;
};

exports["default"] = SafeString;
},{}],177:[function(require,module,exports){
"use strict";
/*jshint -W004 */
var SafeString = require("./safe-string")["default"];

var escape = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#x27;",
  "`": "&#x60;"
};

var badChars = /[&<>"'`]/g;
var possible = /[&<>"'`]/;

function escapeChar(chr) {
  return escape[chr] || "&amp;";
}

function extend(obj, value) {
  for(var key in value) {
    if(Object.prototype.hasOwnProperty.call(value, key)) {
      obj[key] = value[key];
    }
  }
}

exports.extend = extend;var toString = Object.prototype.toString;
exports.toString = toString;
// Sourced from lodash
// https://github.com/bestiejs/lodash/blob/master/LICENSE.txt
var isFunction = function(value) {
  return typeof value === 'function';
};
// fallback for older versions of Chrome and Safari
if (isFunction(/x/)) {
  isFunction = function(value) {
    return typeof value === 'function' && toString.call(value) === '[object Function]';
  };
}
var isFunction;
exports.isFunction = isFunction;
var isArray = Array.isArray || function(value) {
  return (value && typeof value === 'object') ? toString.call(value) === '[object Array]' : false;
};
exports.isArray = isArray;

function escapeExpression(string) {
  // don't escape SafeStrings, since they're already safe
  if (string instanceof SafeString) {
    return string.toString();
  } else if (!string && string !== 0) {
    return "";
  }

  // Force a string conversion as this will be done by the append regardless and
  // the regex test will do this transparently behind the scenes, causing issues if
  // an object's to string has escaped characters in it.
  string = "" + string;

  if(!possible.test(string)) { return string; }
  return string.replace(badChars, escapeChar);
}

exports.escapeExpression = escapeExpression;function isEmpty(value) {
  if (!value && value !== 0) {
    return true;
  } else if (isArray(value) && value.length === 0) {
    return true;
  } else {
    return false;
  }
}

exports.isEmpty = isEmpty;
},{"./safe-string":176}],178:[function(require,module,exports){
// Create a simple path alias to allow browserify to resolve
// the runtime on a supported path.
module.exports = require('./dist/cjs/handlebars.runtime');

},{"./dist/cjs/handlebars.runtime":172}],179:[function(require,module,exports){
module.exports = require("handlebars/runtime")["default"];

},{"handlebars/runtime":178}],180:[function(require,module,exports){
var indexOf = require('./indexOf');

    /**
     * Combines an array with all the items of another.
     * Does not allow duplicates and is case and type sensitive.
     */
    function combine(arr1, arr2) {
        if (arr2 == null) {
            return arr1;
        }

        var i = -1, len = arr2.length;
        while (++i < len) {
            if (indexOf(arr1, arr2[i]) === -1) {
                arr1.push(arr2[i]);
            }
        }

        return arr1;
    }
    module.exports = combine;


},{"./indexOf":186}],181:[function(require,module,exports){
var indexOf = require('./indexOf');

    /**
     * If array contains values.
     */
    function contains(arr, val) {
        return indexOf(arr, val) !== -1;
    }
    module.exports = contains;


},{"./indexOf":186}],182:[function(require,module,exports){
var unique = require('./unique');
var filter = require('./filter');
var some = require('./some');
var contains = require('./contains');
var slice = require('./slice');


    /**
     * Return a new Array with elements that aren't present in the other Arrays.
     */
    function difference(arr) {
        var arrs = slice(arguments, 1),
            result = filter(unique(arr), function(needle){
                return !some(arrs, function(haystack){
                    return contains(haystack, needle);
                });
            });
        return result;
    }

    module.exports = difference;



},{"./contains":181,"./filter":184,"./slice":188,"./some":189,"./unique":190}],183:[function(require,module,exports){
var makeIterator = require('../function/makeIterator_');

    /**
     * Array every
     */
    function every(arr, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        var result = true;
        if (arr == null) {
            return result;
        }

        var i = -1, len = arr.length;
        while (++i < len) {
            // we iterate over sparse items since there is no way to make it
            // work properly on IE 7-8. see #64
            if (!callback(arr[i], i, arr) ) {
                result = false;
                break;
            }
        }

        return result;
    }

    module.exports = every;


},{"../function/makeIterator_":192}],184:[function(require,module,exports){
var makeIterator = require('../function/makeIterator_');

    /**
     * Array filter
     */
    function filter(arr, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        var results = [];
        if (arr == null) {
            return results;
        }

        var i = -1, len = arr.length, value;
        while (++i < len) {
            value = arr[i];
            if (callback(value, i, arr)) {
                results.push(value);
            }
        }

        return results;
    }

    module.exports = filter;



},{"../function/makeIterator_":192}],185:[function(require,module,exports){
arguments[4][150][0].apply(exports,arguments)
},{"dup":150}],186:[function(require,module,exports){


    /**
     * Array.indexOf
     */
    function indexOf(arr, item, fromIndex) {
        fromIndex = fromIndex || 0;
        if (arr == null) {
            return -1;
        }

        var len = arr.length,
            i = fromIndex < 0 ? len + fromIndex : fromIndex;
        while (i < len) {
            // we iterate over sparse items since there is no way to make it
            // work properly on IE 7-8. see #64
            if (arr[i] === item) {
                return i;
            }

            i++;
        }

        return -1;
    }

    module.exports = indexOf;


},{}],187:[function(require,module,exports){
arguments[4][151][0].apply(exports,arguments)
},{"../function/makeIterator_":192,"dup":151}],188:[function(require,module,exports){
arguments[4][153][0].apply(exports,arguments)
},{"dup":153}],189:[function(require,module,exports){
var makeIterator = require('../function/makeIterator_');

    /**
     * Array some
     */
    function some(arr, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        var result = false;
        if (arr == null) {
            return result;
        }

        var i = -1, len = arr.length;
        while (++i < len) {
            // we iterate over sparse items since there is no way to make it
            // work properly on IE 7-8. see #64
            if ( callback(arr[i], i, arr) ) {
                result = true;
                break;
            }
        }

        return result;
    }

    module.exports = some;


},{"../function/makeIterator_":192}],190:[function(require,module,exports){
var filter = require('./filter');

    /**
     * @return {array} Array of unique items
     */
    function unique(arr, compare){
        compare = compare || isEqual;
        return filter(arr, function(item, i, arr){
            var n = arr.length;
            while (++i < n) {
                if ( compare(item, arr[i]) ) {
                    return false;
                }
            }
            return true;
        });
    }

    function isEqual(a, b){
        return a === b;
    }

    module.exports = unique;



},{"./filter":184}],191:[function(require,module,exports){
arguments[4][157][0].apply(exports,arguments)
},{"dup":157}],192:[function(require,module,exports){
arguments[4][158][0].apply(exports,arguments)
},{"../object/deepMatches":202,"./identity":191,"./prop":193,"dup":158}],193:[function(require,module,exports){
arguments[4][159][0].apply(exports,arguments)
},{"dup":159}],194:[function(require,module,exports){
arguments[4][160][0].apply(exports,arguments)
},{"../object/mixIn":208,"dup":160}],195:[function(require,module,exports){
arguments[4][161][0].apply(exports,arguments)
},{"./isKind":196,"dup":161}],196:[function(require,module,exports){
arguments[4][162][0].apply(exports,arguments)
},{"./kindOf":200,"dup":162}],197:[function(require,module,exports){
var isKind = require('./isKind');
    /**
     */
    function isNumber(val) {
        return isKind(val, 'Number');
    }
    module.exports = isNumber;


},{"./isKind":196}],198:[function(require,module,exports){


    /**
     * Checks if the value is created by the `Object` constructor.
     */
    function isPlainObject(value) {
        return (!!value && typeof value === 'object' &&
            value.constructor === Object);
    }

    module.exports = isPlainObject;



},{}],199:[function(require,module,exports){
var isKind = require('./isKind');
    /**
     */
    function isRegExp(val) {
        return isKind(val, 'RegExp');
    }
    module.exports = isRegExp;


},{"./isKind":196}],200:[function(require,module,exports){
arguments[4][164][0].apply(exports,arguments)
},{"dup":164}],201:[function(require,module,exports){


    /**
     * Typecast a value to a String, using an empty string value for null or
     * undefined.
     */
    function toString(val){
        return val == null ? '' : val.toString();
    }

    module.exports = toString;



},{}],202:[function(require,module,exports){
arguments[4][165][0].apply(exports,arguments)
},{"../lang/isArray":195,"./forOwn":205,"dup":165}],203:[function(require,module,exports){
var forOwn = require('./forOwn');
var isPlainObject = require('../lang/isPlainObject');

    /**
     * Mixes objects into the target object, recursively mixing existing child
     * objects.
     */
    function deepMixIn(target, objects) {
        var i = 0,
            n = arguments.length,
            obj;

        while(++i < n){
            obj = arguments[i];
            if (obj) {
                forOwn(obj, copyProp, target);
            }
        }

        return target;
    }

    function copyProp(val, key) {
        var existing = this[key];
        if (isPlainObject(val) && isPlainObject(existing)) {
            deepMixIn(existing, val);
        } else {
            this[key] = val;
        }
    }

    module.exports = deepMixIn;



},{"../lang/isPlainObject":198,"./forOwn":205}],204:[function(require,module,exports){
arguments[4][166][0].apply(exports,arguments)
},{"./hasOwn":206,"dup":166}],205:[function(require,module,exports){
arguments[4][167][0].apply(exports,arguments)
},{"./forIn":204,"./hasOwn":206,"dup":167}],206:[function(require,module,exports){
arguments[4][168][0].apply(exports,arguments)
},{"dup":168}],207:[function(require,module,exports){
var forOwn = require('./forOwn');

    /**
     * Get object keys
     */
     var keys = Object.keys || function (obj) {
            var keys = [];
            forOwn(obj, function(val, key){
                keys.push(key);
            });
            return keys;
        };

    module.exports = keys;



},{"./forOwn":205}],208:[function(require,module,exports){
arguments[4][169][0].apply(exports,arguments)
},{"./forOwn":205,"dup":169}],209:[function(require,module,exports){
var slice = require('../array/slice');

    /**
     * Return a copy of the object, filtered to only have values for the whitelisted keys.
     */
    function pick(obj, var_keys){
        var keys = typeof arguments[1] !== 'string'? arguments[1] : slice(arguments, 1),
            out = {},
            i = 0, key;
        while (key = keys[i++]) {
            out[key] = obj[key];
        }
        return out;
    }

    module.exports = pick;



},{"../array/slice":188}],210:[function(require,module,exports){

    /**
     * Contains all Unicode white-spaces. Taken from
     * http://en.wikipedia.org/wiki/Whitespace_character.
     */
    module.exports = [
        ' ', '\n', '\r', '\t', '\f', '\v', '\u00A0', '\u1680', '\u180E',
        '\u2000', '\u2001', '\u2002', '\u2003', '\u2004', '\u2005', '\u2006',
        '\u2007', '\u2008', '\u2009', '\u200A', '\u2028', '\u2029', '\u202F',
        '\u205F', '\u3000'
    ];


},{}],211:[function(require,module,exports){
var toString = require('../lang/toString');

    /**
     * Escape RegExp string chars.
     */
    function escapeRegExp(str) {
        return toString(str).replace(/\W/g,'\\$&');
    }

    module.exports = escapeRegExp;



},{"../lang/toString":201}],212:[function(require,module,exports){
var toString = require('../lang/toString');
var WHITE_SPACES = require('./WHITE_SPACES');
    /**
     * Remove chars from beginning of string.
     */
    function ltrim(str, chars) {
        str = toString(str);
        chars = chars || WHITE_SPACES;

        var start = 0,
            len = str.length,
            charLen = chars.length,
            found = true,
            i, c;

        while (found && start < len) {
            found = false;
            i = -1;
            c = str.charAt(start);

            while (++i < charLen) {
                if (c === chars[i]) {
                    found = true;
                    start++;
                    break;
                }
            }
        }

        return (start >= len) ? '' : str.substr(start, len);
    }

    module.exports = ltrim;


},{"../lang/toString":201,"./WHITE_SPACES":210}],213:[function(require,module,exports){
var toString = require('../lang/toString');
var WHITE_SPACES = require('./WHITE_SPACES');
    /**
     * Remove chars from end of string.
     */
    function rtrim(str, chars) {
        str = toString(str);
        chars = chars || WHITE_SPACES;

        var end = str.length - 1,
            charLen = chars.length,
            found = true,
            i, c;

        while (found && end >= 0) {
            found = false;
            i = -1;
            c = str.charAt(end);

            while (++i < charLen) {
                if (c === chars[i]) {
                    found = true;
                    end--;
                    break;
                }
            }
        }

        return (end >= 0) ? str.substring(0, end + 1) : '';
    }

    module.exports = rtrim;


},{"../lang/toString":201,"./WHITE_SPACES":210}],214:[function(require,module,exports){
var toString = require('../lang/toString');
var WHITE_SPACES = require('./WHITE_SPACES');
var ltrim = require('./ltrim');
var rtrim = require('./rtrim');
    /**
     * Remove white-spaces from beginning and end of string.
     */
    function trim(str, chars) {
        str = toString(str);
        chars = chars || WHITE_SPACES;
        return ltrim(rtrim(str, chars), chars);
    }

    module.exports = trim;


},{"../lang/toString":201,"./WHITE_SPACES":210,"./ltrim":212,"./rtrim":213}],215:[function(require,module,exports){


    /**
     * Get current time in miliseconds
     */
    function now(){
        // yes, we defer the work to another function to allow mocking it
        // during the tests
        return now.get();
    }

    now.get = (typeof Date.now === 'function')? Date.now : function(){
        return +(new Date());
    };

    module.exports = now;



},{}],216:[function(require,module,exports){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} options
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options){
  options = options || {};
  if ('string' == typeof val) return parse(val);
  return options.long
    ? long(val)
    : short(val);
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = '' + str;
  if (str.length > 10000) return;
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
  if (!match) return;
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function short(ms) {
  if (ms >= d) return Math.round(ms / d) + 'd';
  if (ms >= h) return Math.round(ms / h) + 'h';
  if (ms >= m) return Math.round(ms / m) + 'm';
  if (ms >= s) return Math.round(ms / s) + 's';
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function long(ms) {
  return plural(ms, d, 'day')
    || plural(ms, h, 'hour')
    || plural(ms, m, 'minute')
    || plural(ms, s, 'second')
    || ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) return;
  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
  return Math.ceil(ms / n) + ' ' + name + 's';
}

},{}],217:[function(require,module,exports){
(function (process,global){
/*
defer
*/"use strict"

var kindOf  = require("mout/lang/kindOf"),
    now     = require("mout/time/now"),
    forEach = require("mout/array/forEach"),
    indexOf = require("mout/array/indexOf")

var callbacks = {
    timeout: {},
    frame: [],
    immediate: []
}

var push = function(collection, callback, context, defer){

    var iterator = function(){
        iterate(collection)
    }

    if (!collection.length) defer(iterator)

    var entry = {
        callback: callback,
        context: context
    }

    collection.push(entry)

    return function(){
        var io = indexOf(collection, entry)
        if (io > -1) collection.splice(io, 1)
    }
}

var iterate = function(collection){
    var time = now()

    forEach(collection.splice(0), function(entry) {
        entry.callback.call(entry.context, time)
    })
}

var defer = function(callback, argument, context){
    return (kindOf(argument) === "Number") ? defer.timeout(callback, argument, context) : defer.immediate(callback, argument)
}

if (global.process && process.nextTick){

    defer.immediate = function(callback, context){
        return push(callbacks.immediate, callback, context, process.nextTick)
    }

} else if (global.setImmediate){

    defer.immediate = function(callback, context){
        return push(callbacks.immediate, callback, context, setImmediate)
    }

} else if (global.postMessage && global.addEventListener){

    addEventListener("message", function(event){
        if (event.source === global && event.data === "@deferred"){
            event.stopPropagation()
            iterate(callbacks.immediate)
        }
    }, true)

    defer.immediate = function(callback, context){
        return push(callbacks.immediate, callback, context, function(){
            postMessage("@deferred", "*")
        })
    }

} else {

    defer.immediate = function(callback, context){
        return push(callbacks.immediate, callback, context, function(iterator){
            setTimeout(iterator, 0)
        })
    }

}

var requestAnimationFrame = global.requestAnimationFrame ||
    global.webkitRequestAnimationFrame ||
    global.mozRequestAnimationFrame ||
    global.oRequestAnimationFrame ||
    global.msRequestAnimationFrame ||
    function(callback) {
        setTimeout(callback, 1e3 / 60)
    }

defer.frame = function(callback, context){
    return push(callbacks.frame, callback, context, requestAnimationFrame)
}

var clear

defer.timeout = function(callback, ms, context){
    var ct = callbacks.timeout

    if (!clear) clear = defer.immediate(function(){
        clear = null
        callbacks.timeout = {}
    })

    return push(ct[ms] || (ct[ms] = []), callback, context, function(iterator){
        setTimeout(iterator, ms)
    })
}

module.exports = defer

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"_process":221,"mout/array/forEach":185,"mout/array/indexOf":186,"mout/lang/kindOf":200,"mout/time/now":215}],218:[function(require,module,exports){
/*
Emitter
*/"use strict"

var indexOf = require("mout/array/indexOf"),
    forEach = require("mout/array/forEach")

var prime = require("./index"),
    defer = require("./defer")

var slice = Array.prototype.slice;

var Emitter = prime({

    constructor: function(stoppable){
        this._stoppable = stoppable
    },

    on: function(event, fn){
        var listeners = this._listeners || (this._listeners = {}),
            events = listeners[event] || (listeners[event] = [])

        if (indexOf(events, fn) === -1) events.push(fn)

        return this
    },

    off: function(event, fn){
        var listeners = this._listeners, events
        if (listeners && (events = listeners[event])){

            var io = indexOf(events, fn)
            if (io > -1) events.splice(io, 1)
            if (!events.length) delete listeners[event];
            for (var l in listeners) return this
            delete this._listeners
        }
        return this
    },

    emit: function(event){
        var self = this,
            args = slice.call(arguments, 1)

        var emit = function(){
            var listeners = self._listeners, events
            if (listeners && (events = listeners[event])){
                forEach(events.slice(0), function(event){
                    var result = event.apply(self, args)
                    if (self._stoppable) return result
                })
            }
        }

        if (args[args.length - 1] === Emitter.EMIT_SYNC){
            args.pop()
            emit()
        } else {
            defer(emit)
        }

        return this
    }

})

Emitter.EMIT_SYNC = {}

module.exports = Emitter

},{"./defer":217,"./index":219,"mout/array/forEach":185,"mout/array/indexOf":186}],219:[function(require,module,exports){
arguments[4][171][0].apply(exports,arguments)
},{"dup":171,"mout/lang/createObject":194,"mout/lang/kindOf":200,"mout/object/hasOwn":206,"mout/object/mixIn":208}],220:[function(require,module,exports){
/*
Map
*/"use strict"

var indexOf = require("mout/array/indexOf")

var prime = require("./index")

var Map = prime({

    constructor: function Map(){
        this.length = 0
        this._values = []
        this._keys = []
    },

    set: function(key, value){
        var index = indexOf(this._keys, key)

        if (index === -1){
            this._keys.push(key)
            this._values.push(value)
            this.length++
        } else {
            this._values[index] = value
        }

        return this
    },

    get: function(key){
        var index = indexOf(this._keys, key)
        return (index === -1) ? null : this._values[index]
    },

    count: function(){
        return this.length
    },

    forEach: function(method, context){
        for (var i = 0, l = this.length; i < l; i++){
            if (method.call(context, this._values[i], this._keys[i], this) === false) break
        }
        return this
    },

    map: function(method, context){
        var results = new Map
        this.forEach(function(value, key){
            results.set(key, method.call(context, value, key, this))
        }, this)
        return results
    },

    filter: function(method, context){
        var results = new Map
        this.forEach(function(value, key){
            if (method.call(context, value, key, this)) results.set(key, value)
        }, this)
        return results
    },

    every: function(method, context){
        var every = true
        this.forEach(function(value, key){
            if (!method.call(context, value, key, this)) return (every = false)
        }, this)
        return every
    },

    some: function(method, context){
        var some = false
        this.forEach(function(value, key){
            if (method.call(context, value, key, this)) return !(some = true)
        }, this)
        return some
    },

    indexOf: function(value){
        var index = indexOf(this._values, value)
        return (index > -1) ? this._keys[index] : null
    },

    remove: function(value){
        var index = indexOf(this._values, value)

        if (index !== -1){
            this._values.splice(index, 1)
            this.length--
            return this._keys.splice(index, 1)[0]
        }

        return null
    },

    unset: function(key){
        var index = indexOf(this._keys, key)

        if (index !== -1){
            this._keys.splice(index, 1)
            this.length--
            return this._values.splice(index, 1)[0]
        }

        return null
    },

    keys: function(){
        return this._keys.slice()
    },

    values: function(){
        return this._values.slice()
    }

})

var map = function(){
    return new Map
}

map.prototype = Map.prototype

module.exports = map

},{"./index":219,"mout/array/indexOf":186}],221:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],222:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

},{}],223:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};

},{}],224:[function(require,module,exports){
'use strict';

exports.decode = exports.parse = require('./decode');
exports.encode = exports.stringify = require('./encode');

},{"./decode":222,"./encode":223}],225:[function(require,module,exports){
/*
Slick Finder
*/"use strict"

// Notable changes from Slick.Finder 1.0.x

// faster bottom -> up expression matching
// prefers mental sanity over *obsessive compulsive* milliseconds savings
// uses prototypes instead of objects
// tries to use matchesSelector smartly, whenever available
// can populate objects as well as arrays
// lots of stuff is broken or not implemented

var parse = require("./parser")

// utilities

var index = 0,
    counter = document.__counter = (parseInt(document.__counter || -1, 36) + 1).toString(36),
    key = "uid:" + counter

var uniqueID = function(n, xml){
    if (n === window) return "window"
    if (n === document) return "document"
    if (n === document.documentElement) return "html"

    if (xml) {
        var uid = n.getAttribute(key)
        if (!uid) {
            uid = (index++).toString(36)
            n.setAttribute(key, uid)
        }
        return uid
    } else {
        return n[key] || (n[key] = (index++).toString(36))
    }
}

var uniqueIDXML = function(n) {
    return uniqueID(n, true)
}

var isArray = Array.isArray || function(object){
    return Object.prototype.toString.call(object) === "[object Array]"
}

// tests

var uniqueIndex = 0;

var HAS = {

    GET_ELEMENT_BY_ID: function(test, id){
        id = "slick_" + (uniqueIndex++);
        // checks if the document has getElementById, and it works
        test.innerHTML = '<a id="' + id + '"></a>'
        return !!this.getElementById(id)
    },

    QUERY_SELECTOR: function(test){
        // this supposedly fixes a webkit bug with matchesSelector / querySelector & nth-child
        test.innerHTML = '_<style>:nth-child(2){}</style>'

        // checks if the document has querySelectorAll, and it works
        test.innerHTML = '<a class="MiX"></a>'

        return test.querySelectorAll('.MiX').length === 1
    },

    EXPANDOS: function(test, id){
        id = "slick_" + (uniqueIndex++);
        // checks if the document has elements that support expandos
        test._custom_property_ = id
        return test._custom_property_ === id
    },

    // TODO: use this ?

    // CHECKED_QUERY_SELECTOR: function(test){
    //
    //     // checks if the document supports the checked query selector
    //     test.innerHTML = '<select><option selected="selected">a</option></select>'
    //     return test.querySelectorAll(':checked').length === 1
    // },

    // TODO: use this ?

    // EMPTY_ATTRIBUTE_QUERY_SELECTOR: function(test){
    //
    //     // checks if the document supports the empty attribute query selector
    //     test.innerHTML = '<a class=""></a>'
    //     return test.querySelectorAll('[class*=""]').length === 1
    // },

    MATCHES_SELECTOR: function(test){

        test.className = "MiX"

        // checks if the document has matchesSelector, and we can use it.

        var matches = test.matchesSelector || test.mozMatchesSelector || test.webkitMatchesSelector

        // if matchesSelector trows errors on incorrect syntax we can use it
        if (matches) try {
            matches.call(test, ':slick')
        } catch(e){
            // just as a safety precaution, also test if it works on mixedcase (like querySelectorAll)
            return matches.call(test, ".MiX") ? matches : false
        }

        return false
    },

    GET_ELEMENTS_BY_CLASS_NAME: function(test){
        test.innerHTML = '<a class="f"></a><a class="b"></a>'
        if (test.getElementsByClassName('b').length !== 1) return false

        test.firstChild.className = 'b'
        if (test.getElementsByClassName('b').length !== 2) return false

        // Opera 9.6 getElementsByClassName doesnt detects the class if its not the first one
        test.innerHTML = '<a class="a"></a><a class="f b a"></a>'
        if (test.getElementsByClassName('a').length !== 2) return false

        // tests passed
        return true
    },

    // no need to know

    // GET_ELEMENT_BY_ID_NOT_NAME: function(test, id){
    //     test.innerHTML = '<a name="'+ id +'"></a><b id="'+ id +'"></b>'
    //     return this.getElementById(id) !== test.firstChild
    // },

    // this is always checked for and fixed

    // STAR_GET_ELEMENTS_BY_TAG_NAME: function(test){
    //
    //     // IE returns comment nodes for getElementsByTagName('*') for some documents
    //     test.appendChild(this.createComment(''))
    //     if (test.getElementsByTagName('*').length > 0) return false
    //
    //     // IE returns closed nodes (EG:"</foo>") for getElementsByTagName('*') for some documents
    //     test.innerHTML = 'foo</foo>'
    //     if (test.getElementsByTagName('*').length) return false
    //
    //     // tests passed
    //     return true
    // },

    // this is always checked for and fixed

    // STAR_QUERY_SELECTOR: function(test){
    //
    //     // returns closed nodes (EG:"</foo>") for querySelector('*') for some documents
    //     test.innerHTML = 'foo</foo>'
    //     return !!(test.querySelectorAll('*').length)
    // },

    GET_ATTRIBUTE: function(test){
        // tests for working getAttribute implementation
        var shout = "fus ro dah"
        test.innerHTML = '<a class="' + shout + '"></a>'
        return test.firstChild.getAttribute('class') === shout
    }

}

// Finder

var Finder = function Finder(document){

    this.document        = document
    var root = this.root = document.documentElement
    this.tested          = {}

    // uniqueID

    this.uniqueID = this.has("EXPANDOS") ? uniqueID : uniqueIDXML

    // getAttribute

    this.getAttribute = (this.has("GET_ATTRIBUTE")) ? function(node, name){

        return node.getAttribute(name)

    } : function(node, name){

        node = node.getAttributeNode(name)
        return (node && node.specified) ? node.value : null

    }

    // hasAttribute

    this.hasAttribute = (root.hasAttribute) ? function(node, attribute){

        return node.hasAttribute(attribute)

    } : function(node, attribute) {

        node = node.getAttributeNode(attribute)
        return !!(node && node.specified)

    }

    // contains

    this.contains = (document.contains && root.contains) ? function(context, node){

        return context.contains(node)

    } : (root.compareDocumentPosition) ? function(context, node){

        return context === node || !!(context.compareDocumentPosition(node) & 16)

    } : function(context, node){

        do {
            if (node === context) return true
        } while ((node = node.parentNode))

        return false
    }

    // sort
    // credits to Sizzle (http://sizzlejs.com/)

    this.sorter = (root.compareDocumentPosition) ? function(a, b){

        if (!a.compareDocumentPosition || !b.compareDocumentPosition) return 0
        return a.compareDocumentPosition(b) & 4 ? -1 : a === b ? 0 : 1

    } : ('sourceIndex' in root) ? function(a, b){

        if (!a.sourceIndex || !b.sourceIndex) return 0
        return a.sourceIndex - b.sourceIndex

    } : (document.createRange) ? function(a, b){

        if (!a.ownerDocument || !b.ownerDocument) return 0
        var aRange = a.ownerDocument.createRange(),
            bRange = b.ownerDocument.createRange()

        aRange.setStart(a, 0)
        aRange.setEnd(a, 0)
        bRange.setStart(b, 0)
        bRange.setEnd(b, 0)
        return aRange.compareBoundaryPoints(Range.START_TO_END, bRange)

    } : null

    this.failed = {}

    var nativeMatches = this.has("MATCHES_SELECTOR")

    if (nativeMatches) this.matchesSelector = function(node, expression){

        if (this.failed[expression]) return null

        try {
            return nativeMatches.call(node, expression)
        } catch(e){
            if (slick.debug) console.warn("matchesSelector failed on " + expression)
            this.failed[expression] = true
            return null
        }

    }

    if (this.has("QUERY_SELECTOR")){

        this.querySelectorAll = function(node, expression){

            if (this.failed[expression]) return true

            var result, _id, _expression, _combinator, _node


            // non-document rooted QSA
            // credits to Andrew Dupont

            if (node !== this.document){

                _combinator = expression[0].combinator

                _id         = node.getAttribute("id")
                _expression = expression

                if (!_id){
                    _node = node
                    _id = "__slick__"
                    _node.setAttribute("id", _id)
                }

                expression = "#" + _id + " " + _expression


                // these combinators need a parentNode due to how querySelectorAll works, which is:
                // finding all the elements that match the given selector
                // then filtering by the ones that have the specified element as an ancestor
                if (_combinator.indexOf("~") > -1 || _combinator.indexOf("+") > -1){

                    node = node.parentNode
                    if (!node) result = true
                    // if node has no parentNode, we return "true" as if it failed, without polluting the failed cache

                }

            }

            if (!result) try {
                result = node.querySelectorAll(expression.toString())
            } catch(e){
                if (slick.debug) console.warn("querySelectorAll failed on " + (_expression || expression))
                result = this.failed[_expression || expression] = true
            }

            if (_node) _node.removeAttribute("id")

            return result

        }

    }

}

Finder.prototype.has = function(FEATURE){

    var tested        = this.tested,
        testedFEATURE = tested[FEATURE]

    if (testedFEATURE != null) return testedFEATURE

    var root     = this.root,
        document = this.document,
        testNode = document.createElement("div")

    testNode.setAttribute("style", "display: none;")

    root.appendChild(testNode)

    var TEST = HAS[FEATURE], result = false

    if (TEST) try {
        result = TEST.call(document, testNode)
    } catch(e){}

    if (slick.debug && !result) console.warn("document has no " + FEATURE)

    root.removeChild(testNode)

    return tested[FEATURE] = result

}

var combinators = {

    " ": function(node, part, push){

        var item, items

        var noId = !part.id, noTag = !part.tag, noClass = !part.classes

        if (part.id && node.getElementById && this.has("GET_ELEMENT_BY_ID")){
            item = node.getElementById(part.id)

            // return only if id is found, else keep checking
            // might be a tad slower on non-existing ids, but less insane

            if (item && item.getAttribute('id') === part.id){
                items = [item]
                noId = true
                // if tag is star, no need to check it in match()
                if (part.tag === "*") noTag = true
            }
        }

        if (!items){

            if (part.classes && node.getElementsByClassName && this.has("GET_ELEMENTS_BY_CLASS_NAME")){
                items = node.getElementsByClassName(part.classList)
                noClass = true
                // if tag is star, no need to check it in match()
                if (part.tag === "*") noTag = true
            } else {
                items = node.getElementsByTagName(part.tag)
                // if tag is star, need to check it in match because it could select junk, boho
                if (part.tag !== "*") noTag = true
            }

            if (!items || !items.length) return false

        }

        for (var i = 0; item = items[i++];)
            if ((noTag && noId && noClass && !part.attributes && !part.pseudos) || this.match(item, part, noTag, noId, noClass))
                push(item)

        return true

    },

    ">": function(node, part, push){ // direct children
        if ((node = node.firstChild)) do {
            if (node.nodeType == 1 && this.match(node, part)) push(node)
        } while ((node = node.nextSibling))
    },

    "+": function(node, part, push){ // next sibling
        while ((node = node.nextSibling)) if (node.nodeType == 1){
            if (this.match(node, part)) push(node)
            break
        }
    },

    "^": function(node, part, push){ // first child
        node = node.firstChild
        if (node){
            if (node.nodeType === 1){
                if (this.match(node, part)) push(node)
            } else {
                combinators['+'].call(this, node, part, push)
            }
        }
    },

    "~": function(node, part, push){ // next siblings
        while ((node = node.nextSibling)){
            if (node.nodeType === 1 && this.match(node, part)) push(node)
        }
    },

    "++": function(node, part, push){ // next sibling and previous sibling
        combinators['+'].call(this, node, part, push)
        combinators['!+'].call(this, node, part, push)
    },

    "~~": function(node, part, push){ // next siblings and previous siblings
        combinators['~'].call(this, node, part, push)
        combinators['!~'].call(this, node, part, push)
    },

    "!": function(node, part, push){ // all parent nodes up to document
        while ((node = node.parentNode)) if (node !== this.document && this.match(node, part)) push(node)
    },

    "!>": function(node, part, push){ // direct parent (one level)
        node = node.parentNode
        if (node !== this.document && this.match(node, part)) push(node)
    },

    "!+": function(node, part, push){ // previous sibling
        while ((node = node.previousSibling)) if (node.nodeType == 1){
            if (this.match(node, part)) push(node)
            break
        }
    },

    "!^": function(node, part, push){ // last child
        node = node.lastChild
        if (node){
            if (node.nodeType == 1){
                if (this.match(node, part)) push(node)
            } else {
                combinators['!+'].call(this, node, part, push)
            }
        }
    },

    "!~": function(node, part, push){ // previous siblings
        while ((node = node.previousSibling)){
            if (node.nodeType === 1 && this.match(node, part)) push(node)
        }
    }

}

Finder.prototype.search = function(context, expression, found){

    if (!context) context = this.document
    else if (!context.nodeType && context.document) context = context.document

    var expressions = parse(expression)

    // no expressions were parsed. todo: is this really necessary?
    if (!expressions || !expressions.length) throw new Error("invalid expression")

    if (!found) found = []

    var uniques, push = isArray(found) ? function(node){
        found[found.length] = node
    } : function(node){
        found[found.length++] = node
    }

    // if there is more than one expression we need to check for duplicates when we push to found
    // this simply saves the old push and wraps it around an uid dupe check.
    if (expressions.length > 1){
        uniques = {}
        var plush = push
        push = function(node){
            var uid = uniqueID(node)
            if (!uniques[uid]){
                uniques[uid] = true
                plush(node)
            }
        }
    }

    // walker

    var node, nodes, part

    main: for (var i = 0; expression = expressions[i++];){

        // querySelector

        // TODO: more functional tests

        // if there is querySelectorAll (and the expression does not fail) use it.
        if (!slick.noQSA && this.querySelectorAll){

            nodes = this.querySelectorAll(context, expression)
            if (nodes !== true){
                if (nodes && nodes.length) for (var j = 0; node = nodes[j++];) if (node.nodeName > '@'){
                    push(node)
                }
                continue main
            }
        }

        // if there is only one part in the expression we don't need to check each part for duplicates.
        // todo: this might be too naive. while solid, there can be expression sequences that do not
        // produce duplicates. "body div" for instance, can never give you each div more than once.
        // "body div a" on the other hand might.
        if (expression.length === 1){

            part = expression[0]
            combinators[part.combinator].call(this, context, part, push)

        } else {

            var cs = [context], c, f, u, p = function(node){
                var uid = uniqueID(node)
                if (!u[uid]){
                    u[uid] = true
                    f[f.length] = node
                }
            }

            // loop the expression parts
            for (var j = 0; part = expression[j++];){
                f = []; u = {}
                // loop the contexts
                for (var k = 0; c = cs[k++];) combinators[part.combinator].call(this, c, part, p)
                // nothing was found, the expression failed, continue to the next expression.
                if (!f.length) continue main
                cs = f // set the contexts for future parts (if any)
            }

            if (i === 0) found = f // first expression. directly set found.
            else for (var l = 0; l < f.length; l++) push(f[l]) // any other expression needs to push to found.
        }

    }

    if (uniques && found && found.length > 1) this.sort(found)

    return found

}

Finder.prototype.sort = function(nodes){
    return this.sorter ? Array.prototype.sort.call(nodes, this.sorter) : nodes
}

// TODO: most of these pseudo selectors include <html> and qsa doesnt. fixme.

var pseudos = {


    // TODO: returns different results than qsa empty.

    'empty': function(){
        return !(this && this.nodeType === 1) && !(this.innerText || this.textContent || '').length
    },

    'not': function(expression){
        return !slick.matches(this, expression)
    },

    'contains': function(text){
        return (this.innerText || this.textContent || '').indexOf(text) > -1
    },

    'first-child': function(){
        var node = this
        while ((node = node.previousSibling)) if (node.nodeType == 1) return false
        return true
    },

    'last-child': function(){
        var node = this
        while ((node = node.nextSibling)) if (node.nodeType == 1) return false
        return true
    },

    'only-child': function(){
        var prev = this
        while ((prev = prev.previousSibling)) if (prev.nodeType == 1) return false

        var next = this
        while ((next = next.nextSibling)) if (next.nodeType == 1) return false

        return true
    },

    'first-of-type': function(){
        var node = this, nodeName = node.nodeName
        while ((node = node.previousSibling)) if (node.nodeName == nodeName) return false
        return true
    },

    'last-of-type': function(){
        var node = this, nodeName = node.nodeName
        while ((node = node.nextSibling)) if (node.nodeName == nodeName) return false
        return true
    },

    'only-of-type': function(){
        var prev = this, nodeName = this.nodeName
        while ((prev = prev.previousSibling)) if (prev.nodeName == nodeName) return false
        var next = this
        while ((next = next.nextSibling)) if (next.nodeName == nodeName) return false
        return true
    },

    'enabled': function(){
        return !this.disabled
    },

    'disabled': function(){
        return this.disabled
    },

    'checked': function(){
        return this.checked || this.selected
    },

    'selected': function(){
        return this.selected
    },

    'focus': function(){
        var doc = this.ownerDocument
        return doc.activeElement === this && (this.href || this.type || slick.hasAttribute(this, 'tabindex'))
    },

    'root': function(){
        return (this === this.ownerDocument.documentElement)
    }

}

Finder.prototype.match = function(node, bit, noTag, noId, noClass){

    // TODO: more functional tests ?

    if (!slick.noQSA && this.matchesSelector){
        var matches = this.matchesSelector(node, bit)
        if (matches !== null) return matches
    }

    // normal matching

    if (!noTag && bit.tag){

        var nodeName = node.nodeName.toLowerCase()
        if (bit.tag === "*"){
            if (nodeName < "@") return false
        } else if (nodeName != bit.tag){
            return false
        }

    }

    if (!noId && bit.id && node.getAttribute('id') !== bit.id) return false

    var i, part

    if (!noClass && bit.classes){

        var className = this.getAttribute(node, "class")
        if (!className) return false

        for (part in bit.classes) if (!RegExp('(^|\\s)' + bit.classes[part] + '(\\s|$)').test(className)) return false
    }

    var name, value

    if (bit.attributes) for (i = 0; part = bit.attributes[i++];){

        var operator  = part.operator,
            escaped   = part.escapedValue

        name  = part.name
        value = part.value

        if (!operator){

            if (!this.hasAttribute(node, name)) return false

        } else {

            var actual = this.getAttribute(node, name)
            if (actual == null) return false

            switch (operator){
                case '^=' : if (!RegExp(      '^' + escaped            ).test(actual)) return false; break
                case '$=' : if (!RegExp(            escaped + '$'      ).test(actual)) return false; break
                case '~=' : if (!RegExp('(^|\\s)' + escaped + '(\\s|$)').test(actual)) return false; break
                case '|=' : if (!RegExp(      '^' + escaped + '(-|$)'  ).test(actual)) return false; break

                case '='  : if (actual !== value) return false; break
                case '*=' : if (actual.indexOf(value) === -1) return false; break
                default   : return false
            }

        }
    }

    if (bit.pseudos) for (i = 0; part = bit.pseudos[i++];){

        name  = part.name
        value = part.value

        if (pseudos[name]) return pseudos[name].call(node, value)

        if (value != null){
            if (this.getAttribute(node, name) !== value) return false
        } else {
            if (!this.hasAttribute(node, name)) return false
        }

    }

    return true

}

Finder.prototype.matches = function(node, expression){

    var expressions = parse(expression)

    if (expressions.length === 1 && expressions[0].length === 1){ // simplest match
        return this.match(node, expressions[0][0])
    }

    // TODO: more functional tests ?

    if (!slick.noQSA && this.matchesSelector){
        var matches = this.matchesSelector(node, expressions)
        if (matches !== null) return matches
    }

    var nodes = this.search(this.document, expression, {length: 0})

    for (var i = 0, res; res = nodes[i++];) if (node === res) return true
    return false

}

var finders = {}

var finder = function(context){
    var doc = context || document
    if (doc.ownerDocument) doc = doc.ownerDocument
    else if (doc.document) doc = doc.document

    if (doc.nodeType !== 9) throw new TypeError("invalid document")

    var uid = uniqueID(doc)
    return finders[uid] || (finders[uid] = new Finder(doc))
}

// ... API ...

var slick = function(expression, context){
    return slick.search(expression, context)
}

slick.search = function(expression, context, found){
    return finder(context).search(context, expression, found)
}

slick.find = function(expression, context){
    return finder(context).search(context, expression)[0] || null
}

slick.getAttribute = function(node, name){
    return finder(node).getAttribute(node, name)
}

slick.hasAttribute = function(node, name){
    return finder(node).hasAttribute(node, name)
}

slick.contains = function(context, node){
    return finder(context).contains(context, node)
}

slick.matches = function(node, expression){
    return finder(node).matches(node, expression)
}

slick.sort = function(nodes){
    if (nodes && nodes.length > 1) finder(nodes[0]).sort(nodes)
    return nodes
}

slick.parse = parse;

// slick.debug = true
// slick.noQSA  = true

module.exports = slick

},{"./parser":227}],226:[function(require,module,exports){
(function (global){
/*
slick
*/"use strict"

module.exports = "document" in global ? require("./finder") : { parse: require("./parser") }

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./finder":225,"./parser":227}],227:[function(require,module,exports){
/*
Slick Parser
 - originally created by the almighty Thomas Aylott <@subtlegradient> (http://subtlegradient.com)
*/"use strict"

// Notable changes from Slick.Parser 1.0.x

// The parser now uses 2 classes: Expressions and Expression
// `new Expressions` produces an array-like object containing a list of Expression objects
// - Expressions::toString() produces a cleaned up expressions string
// `new Expression` produces an array-like object
// - Expression::toString() produces a cleaned up expression string
// The only exposed method is parse, which produces a (cached) `new Expressions` instance
// parsed.raw is no longer present, use .toString()
// parsed.expression is now useless, just use the indices
// parsed.reverse() has been removed for now, due to its apparent uselessness
// Other changes in the Expressions object:
// - classNames are now unique, and save both escaped and unescaped values
// - attributes now save both escaped and unescaped values
// - pseudos now save both escaped and unescaped values

var escapeRe   = /([-.*+?^${}()|[\]\/\\])/g,
    unescapeRe = /\\/g

var escape = function(string){
    // XRegExp v2.0.0-beta-3
    // « https://github.com/slevithan/XRegExp/blob/master/src/xregexp.js
    return (string + "").replace(escapeRe, '\\$1')
}

var unescape = function(string){
    return (string + "").replace(unescapeRe, '')
}

var slickRe = RegExp(
/*
#!/usr/bin/env ruby
puts "\t\t" + DATA.read.gsub(/\(\?x\)|\s+#.*$|\s+|\\$|\\n/,'')
__END__
    "(?x)^(?:\
      \\s* ( , ) \\s*               # Separator          \n\
    | \\s* ( <combinator>+ ) \\s*   # Combinator         \n\
    |      ( \\s+ )                 # CombinatorChildren \n\
    |      ( <unicode>+ | \\* )     # Tag                \n\
    | \\#  ( <unicode>+       )     # ID                 \n\
    | \\.  ( <unicode>+       )     # ClassName          \n\
    |                               # Attribute          \n\
    \\[  \
        \\s* (<unicode1>+)  (?:  \
            \\s* ([*^$!~|]?=)  (?:  \
                \\s* (?:\
                    ([\"']?)(.*?)\\9 \
                )\
            )  \
        )?  \\s*  \
    \\](?!\\]) \n\
    |   :+ ( <unicode>+ )(?:\
    \\( (?:\
        (?:([\"'])([^\\12]*)\\12)|((?:\\([^)]+\\)|[^()]*)+)\
    ) \\)\
    )?\
    )"
*/
"^(?:\\s*(,)\\s*|\\s*(<combinator>+)\\s*|(\\s+)|(<unicode>+|\\*)|\\#(<unicode>+)|\\.(<unicode>+)|\\[\\s*(<unicode1>+)(?:\\s*([*^$!~|]?=)(?:\\s*(?:([\"']?)(.*?)\\9)))?\\s*\\](?!\\])|(:+)(<unicode>+)(?:\\((?:(?:([\"'])([^\\13]*)\\13)|((?:\\([^)]+\\)|[^()]*)+))\\))?)"
    .replace(/<combinator>/, '[' + escape(">+~`!@$%^&={}\\;</") + ']')
    .replace(/<unicode>/g, '(?:[\\w\\u00a1-\\uFFFF-]|\\\\[^\\s0-9a-f])')
    .replace(/<unicode1>/g, '(?:[:\\w\\u00a1-\\uFFFF-]|\\\\[^\\s0-9a-f])')
)

// Part

var Part = function Part(combinator){
    this.combinator = combinator || " "
    this.tag = "*"
}

Part.prototype.toString = function(){

    if (!this.raw){

        var xpr = "", k, part

        xpr += this.tag || "*"
        if (this.id) xpr += "#" + this.id
        if (this.classes) xpr += "." + this.classList.join(".")
        if (this.attributes) for (k = 0; part = this.attributes[k++];){
            xpr += "[" + part.name + (part.operator ? part.operator + '"' + part.value + '"' : '') + "]"
        }
        if (this.pseudos) for (k = 0; part = this.pseudos[k++];){
            xpr += ":" + part.name
            if (part.value) xpr += "(" + part.value + ")"
        }

        this.raw = xpr

    }

    return this.raw
}

// Expression

var Expression = function Expression(){
    this.length = 0
}

Expression.prototype.toString = function(){

    if (!this.raw){

        var xpr = ""

        for (var j = 0, bit; bit = this[j++];){
            if (j !== 1) xpr += " "
            if (bit.combinator !== " ") xpr += bit.combinator + " "
            xpr += bit
        }

        this.raw = xpr

    }

    return this.raw
}

var replacer = function(
    rawMatch,

    separator,
    combinator,
    combinatorChildren,

    tagName,
    id,
    className,

    attributeKey,
    attributeOperator,
    attributeQuote,
    attributeValue,

    pseudoMarker,
    pseudoClass,
    pseudoQuote,
    pseudoClassQuotedValue,
    pseudoClassValue
){

    var expression, current

    if (separator || !this.length){
        expression = this[this.length++] = new Expression
        if (separator) return ''
    }

    if (!expression) expression = this[this.length - 1]

    if (combinator || combinatorChildren || !expression.length){
        current = expression[expression.length++] = new Part(combinator)
    }

    if (!current) current = expression[expression.length - 1]

    if (tagName){

        current.tag = unescape(tagName)

    } else if (id){

        current.id = unescape(id)

    } else if (className){

        var unescaped = unescape(className)

        var classes = current.classes || (current.classes = {})
        if (!classes[unescaped]){
            classes[unescaped] = escape(className)
            var classList = current.classList || (current.classList = [])
            classList.push(unescaped)
            classList.sort()
        }

    } else if (pseudoClass){

        pseudoClassValue = pseudoClassValue || pseudoClassQuotedValue

        ;(current.pseudos || (current.pseudos = [])).push({
            type         : pseudoMarker.length == 1 ? 'class' : 'element',
            name         : unescape(pseudoClass),
            escapedName  : escape(pseudoClass),
            value        : pseudoClassValue ? unescape(pseudoClassValue) : null,
            escapedValue : pseudoClassValue ? escape(pseudoClassValue) : null
        })

    } else if (attributeKey){

        attributeValue = attributeValue ? escape(attributeValue) : null

        ;(current.attributes || (current.attributes = [])).push({
            operator     : attributeOperator,
            name         : unescape(attributeKey),
            escapedName  : escape(attributeKey),
            value        : attributeValue ? unescape(attributeValue) : null,
            escapedValue : attributeValue ? escape(attributeValue) : null
        })

    }

    return ''

}

// Expressions

var Expressions = function Expressions(expression){
    this.length = 0

    var self = this

    var original = expression, replaced

    while (expression){
        replaced = expression.replace(slickRe, function(){
            return replacer.apply(self, arguments)
        })
        if (replaced === expression) throw new Error(original + ' is an invalid expression')
        expression = replaced
    }
}

Expressions.prototype.toString = function(){
    if (!this.raw){
        var expressions = []
        for (var i = 0, expression; expression = this[i++];) expressions.push(expression)
        this.raw = expressions.join(", ")
    }

    return this.raw
}

var cache = {}

var parse = function(expression){
    if (expression == null) return null
    expression = ('' + expression).replace(/^\s+|\s+$/g, '')
    return cache[expression] || (cache[expression] = new Expressions(expression))
}

module.exports = parse

},{}],228:[function(require,module,exports){
/*jslint node: true */

'use strict';

var ClientRequest = require('./request').ClientRequest;

/**
 * An autoincremented id that is used to distinguish Resolver instances.
 *
 * @type {number}
 * @private
 */
var resolverUID = 0;

/**
 * A resolver takes a request for a resources and sends it through the
 * transport.
 *
 * @constructs Resolver
 */
function Resolver() {
  if (!(this instanceof Resolver))
    return new Resolver();

  /**
   * The resolver's id.
   *
   * @type {number}
   * @protected
   */
  this._id = resolverUID++;

  /**
   * An incrementing ID used for tracking requests.
   *
   * @type {number}
   * @protected
   */
  this._requestID = 0;

  /**
   * Storage for the sent request handlers waiting for a response.
   *
   * @type {Object.<string, function>}
   * @protected
   */
  this._handlers = {};
}
exports.Resolver = Resolver;

/**
 * Adds a handler to the internal storage.
 *
 * @param {number} requestID The identifier for the request.
 * @param {ClientRequest} handler The handler for the request.
 * @protected
 */
Resolver.prototype._addHandler = function(requestID, handler) {
  this._handlers[requestID] = handler;
  return this;
};

/**
 * Removes a handler from the internal storage.
 *
 * @param {number} requestID The identifier for the request.
 * @protected
 */
Resolver.prototype._removeHandler = function(requestID) {
  this._handlers[requestID] = null;
  return this;
};

/**
 * Sends a request through the transport.
 *
 * Subclasses of this class need to implement this method.
 *
 * @param {number} requestID The id of the request.
 * @param {Object} data The payload data for the request.
 * @protected
 */
Resolver.prototype._sendRequest = function(requestID, data) {
  throw new Error('Resolver _sendRequest not implemented.');
};

/**
 * Handles a response from the transport.
 *
 * @param {Object} response The response from the transport.
 * @protected
 */
Resolver.prototype._handleResponse = function(response) {
  throw new Error('Resolver _handleResponse not implemented.');
};

/**
 * Dispatches a request handler with some data.
 *
 * @param {number} requestID The request handler to dispatch.
 * @param {Object} data The response data to send back.
 * @protected
 */
Resolver.prototype._dispatchResponse = function(requestID, requestType, data) {
  var handler = this._handlers[requestID];
  if (!handler) return;
  handler._handleResponse(requestType, data);
};

/**
 * Resolves a request (represented by the data) through the transport.
 *
 * @param {Object} data The data representing the request.
 * @param {function} onsuccess The success handler for the request.
 * @param {function} onerror The error handler for the request.
 */
Resolver.prototype._resolve = function(data, onsuccess, onerror) {
  if (!data || !onsuccess || !onerror ||
      typeof onsuccess != 'function' || typeof onerror != 'function')
    throw new TypeError('Invalid argument length for `resolve`.');

  var requestID = ++this._requestID;
  var request = new ClientRequest(this, requestID, data, onsuccess, onerror);

  this._addHandler(requestID, request);

  request.onClose = this._removeHandler.bind(this);
  request.open();

  return request;
};

/**
 * Resolves a single request (represented by the data) through the transport.
 *
 * @param {Object} data The data representing the request.
 * @param {function} onsuccess The success handler for the request.
 * @param {function} onerror The error handler for the request.
 */
Resolver.prototype.resolve = function(data, onsuccess, onerror) {
  throw new Error('Resolver resolve not implemented.');
};

/**
 * Resolves a subscription request (represented by the data) through the transport.
 *
 * @param {Object} data The data representing the request.
 * @param {function} onsuccess The success handler for the request.
 * @param {function} onerror The error handler for the request.
 */
Resolver.prototype.subscribe = function(data, onsuccess, onerror) {
  throw new Error('Resolver subscribe not implemented.');
};

},{"./request":232}],229:[function(require,module,exports){
(function (global){
/*jslint node: true */

'use strict';

var defer = require('spotify-deferred');
var Resolver = require('./bootstrap').Resolver;

/**
 * A mock resolver for a nodejs environment.
 *
 * This resolver uses regular callbacks as a transport.
 *
 * @constructs Cosmos.MockResolver
 * @extends Cosmos.Resolver
 */
function MockResolver() {
  if (!(this instanceof MockResolver))
    return new MockResolver();
  Resolver.call(this);

  // rebind the _handleResponse method so that we can reuse it for both
  // addEventListener and removeEventListener
  this._handleResponse = this._handleResponse.bind(this);

  /**
   * The identifier for request messages.
   *
   * @type {string}
   * @protected
   */
  this._requestMessageType = 'cosmos-request';

  /**
   * The identifier for response messages.
   *
   * @type {string}
   * @protected
   */
  this._responseMessageType = 'cosmos-response';

  /**
   * Prefix for the requests ids to prevent clashes
   * with bridge requests in webplayer
   *
   * @type {string}
   * @private
   */
  this._requestIdPrefix = 'cosmos_';

  this._handlersMap = {};

  // attach the handler
  this.attach();
}
MockResolver.prototype = new Resolver();
MockResolver.prototype.constructor = MockResolver;
exports.MockResolver = MockResolver;

/**
 * @inheritDoc
 */
MockResolver.prototype._sendRequest = function(requestName, requestID, data) {
  var self = this;

  var message = {
    type: this._requestMessageType,
    resolver: this._id,
    id: this._requestIdPrefix + requestID,
    name: requestName,
    payload: data.serialize ? data.serialize() : data
  };

  if (!this._handlersMap[data._action]) {
    return;
  }

  if (!this._handlersMap[data._action][data._uri]) {
    return;
  }

  this._handlersMap[data._action][data._uri](data, function (status, resp) {
    message.payload = {
      body: typeof resp !== 'undefined' ? resp : status,
      uri: data._uri,
      status: typeof resp !== 'undefined' ? status : 200
    };
    message.type = self._responseMessageType;

    var response = {
      data: message
    };
    self._handleResponse(response);
  });
};

/**
 * @inheritDoc
 */
MockResolver.prototype._handleResponse = function(response) {
  var data = response.data;
  if (typeof data == 'string') {
    try {
      data = JSON.parse(response.data);
    } catch (e) {
      return;
    }
  }
  if (data.type != this._responseMessageType ||
      data.resolver != this._id ||
      !data.payload) return;
  var id = data.id || '';
  var requestID = parseInt(id.replace(this._requestIdPrefix, ''), 10);
  var requestName = data.name || '';
  if (!requestID || !requestName) return;
  this._dispatchResponse(requestID, requestName, data.payload);
};

/**
 * Attaches the resolver so that it could process calls from the window object.
 */
MockResolver.prototype.attach = function() {
  var win = global.window;
  if (win) {
    win._cosmosRequest = this.resolve.bind(this);
  }
};

/**
 * Detaches the resolver so that it doesn't process calls from the window object.
 */
MockResolver.prototype.detach = function() {
  var win = global.window;
  if (win) {
    delete win._cosmosRequest;
  }
};

/**
 * Specific method for the mock resolver to add request handlers
 *
 * @param {string}   method       Type of method (GET, POST, PUT, SUB)
 * @param {string}   uri          Request to handle
 * @param {Function} fn           Function that handles the request
 */
MockResolver.prototype.addHandler = function(method, uri, fn) {
  if (!this._handlersMap[method]) {
    this._handlersMap[method] = {};
  }

  this._handlersMap[method][uri] = fn;
};

/**
 * Specific method for the mock resolver to remove a specific request handler
 *
 * @param {string}   method       Type of method (GET, POST, PUT, SUB)
 * @param {string}   uri          Request to handle
 */
MockResolver.prototype.removeHandler = function(method, uri) {
  if (!this._handlersMap[method]) {
    return;
  }

  if (this._handlersMap[method][uri]) {
    delete this._handlersMap[method][uri];
  }
};

/**
 * Specific method for the mock resolver to remove all handlers
 */
MockResolver.prototype.clearHandlers = function() {
  this._handlersMap = {};
};

/**
 * Resolves a single request (represented by the data) through the transport.
 * Single requests need to be closed immediately after the response is
 * received.
 *
 * @param {Object} data The data representing the request.
 * @param {function} onsuccess The success handler for the request.
 * @param {function} onerror The error handler for the request.
 */
MockResolver.prototype.resolve = function(data, onsuccess, onerror) {
  function onResult(callback, response) {
    defer(callback.bind(this, response));
    request.close();
  }

  var request = this._resolve(data, onResult.bind(this, onsuccess), onResult.bind(this, onerror));
  return request;
};

/**
 * Resolves a  subscription request (represented by the data) through the transport.
 * Subscriptions stay open until they're explicitly closed.
 * Every time the request returns some data pull for next
 * batch is sent.
 *
 * @param {Object} data The data representing the request.
 * @param {function} onsuccess The success handler for the request.
 * @param {function} onerror The error handler for the request.
 */
MockResolver.prototype.subscribe = function(data, onsuccess, onerror) {
  return this._resolve(data, onsuccess, onerror);
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./bootstrap":228,"spotify-deferred":235}],230:[function(require,module,exports){
(function (global){
/*jslint node: true */

'use strict';

var SpotifyApi = global.SpotifyApi;
var useApiRequest = !!(SpotifyApi && SpotifyApi.api &&
    typeof SpotifyApi.api.request === 'function');

var Resolver = require('./bootstrap').Resolver;
var defer = require('spotify-deferred');

/**
 * A resolver for a native environment.
 *
 * This resolver uses the Stitch bridge as a transport
 *
 * @constructs Cosmos.NativeResolver
 * @extends Cosmos.Resolver
 * @param {Object} spBridge Spotify CPP/JS bridge
 */
function NativeResolver(spBridge) {
  if (!(this instanceof NativeResolver))
    return new NativeResolver();
  if (!spBridge) {
    throw new TypeError('Missing `spBridge` parameter');
  }
  Resolver.call(this);

  this._bridge = spBridge;

  this._deferredFlush = false;
}
NativeResolver.prototype = new Resolver();
NativeResolver.prototype.constructor = NativeResolver;
exports.NativeResolver = NativeResolver;

/**
 * Prepare bridge flush.
 * TODO: Move to the separate module
 */
NativeResolver.prototype._prepareCoreFlush = function() {
  if (!this._deferredFlush) {
    this._deferredFlush = true;
    this._defer(this, this._flushRequests);
  }
};

/**
 * Flush bridge requests.
 * TODO: Move to the separate module
 */
NativeResolver.prototype._flushRequests = function() {
  this._deferredFlush = false;
  var flushMsg = JSON.stringify({ name: 'core_flush', args: []});
  this._sendBridgeRequest(flushMsg, {
    onSuccess: function() {},
    onFailure: function() {}
  });
};

/**
 * Defer the function call.
 * TODO: Move to the separate module
 */
NativeResolver.prototype._defer = function(context, callback) {
  defer(callback.bind(context));
};

/**
 * If SpotifyApi is loaded, use api requests to send messages to bridge
 * TODO: Use proxy that will handle Cosmos/Stitch calls for the resolver.
 */
NativeResolver.prototype._sendRequest = function(requestName, requestId, data) {
  var self = this;
  data = (data.serialize ? data.serialize() : data);

  var args = [requestId, data];
  var caller = { self: this, id: requestId, type: requestName };

  if (useApiRequest) {
    this._sendApiRequest(requestName, args, caller, this._handleResponse, this._handleError);
  } else {
    this._sendCosmosRequest(requestName, args, caller, this._handleResponse, this._handleError);
  }
};


/**
 * Talk to bridge directly from Cosmos
 * TODO: Move to the separate module
 */
NativeResolver.prototype._sendCosmosRequest = function(requestName, args, caller, onSuccess, onError) {
  var message = JSON.stringify({
    name: requestName,
    args: args
  });

  this._sendBridgeRequest(message, {
    onSuccess: function(data) {
      onSuccess.call(caller, JSON.parse(data));
    },
    onFailure: function(data) {
      data = JSON.parse(data);
      onError.call(caller, data);
    }
  });

  this._prepareCoreFlush();
};

/**
 * Send message to the bridge
 * @param {string} message The message to send to the bridge.
 * @param {Object.<string, function>} callbackMap The `onSuccess`
 * and `onFailure` functions to be executed after request is completed.
 * TODO: Use proxy that will handle Cosmos/Stitch calls for the resolver.
 */
NativeResolver.prototype._sendBridgeRequest = function(message, callbackMap) {
  this._bridge.executeRequest(message, callbackMap || {});
};

/**
 * Use old API to send messages to the bridge.
 * TODO: Move to the separate module
 */
NativeResolver.prototype._sendApiRequest = function(requestName, args, caller, onSuccess, onError) {
  SpotifyApi.api.request(
      requestName,
      args,
      caller,
      onSuccess,
      onError
  );
};

/**
 * Handles successful responses from the bridge
 * @param {Object} data The response data.
 */
NativeResolver.prototype._handleResponse = function(data) {
  this.self._dispatchResponse(this.id, this.type, data.responses && data.responses[0] || data);
};

/**
 * Handles failed responses from the bridge
 * @param {Object} error The error data.
 */
NativeResolver.prototype._handleError = function(error) {
  this.self._dispatchResponse(this.id, this.type, error);
};

/**
 * Resolves a single request (represented by the data) through the transport.
 * Single requests need to be closed immediately after the response is
 * received.
 *
 * @param {Object} data The data representing the request.
 * @param {function} onsuccess The success handler for the request.
 * @param {function} onerror The error handler for the request.
 */
NativeResolver.prototype.resolve = function(data, onsuccess, onerror) {
  function onResult(callback, response) {
    this._defer(this, callback.bind(this, response));
    request.close();
  }

  var request = this._resolve(data, onResult.bind(this, onsuccess), onResult.bind(this, onerror));
  return request;
};

/**
 * Resolves a  subscription request (represented by the data) through the transport.
 * Subscriptions stay open until they're explicitly closed.
 * Every time the request returns some data pull for next
 * batch is sent.
 *
 * @param {Object} data The data representing the request.
 * @param {function} onsuccess The success handler for the request.
 * @param {function} onerror The error handler for the request.
 */
NativeResolver.prototype.subscribe = function(data, onsuccess, onerror) {
  function onResult(callback, response) {
    callback.call(this, response);
    request.pull();
  }

  var request = this._resolve(data, onResult.bind(this, onsuccess), onResult.bind(this, onerror));
  return request;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./bootstrap":228,"spotify-deferred":235}],231:[function(require,module,exports){
(function (global){
/*jslint node: true */

'use strict';

var defer = require('spotify-deferred');
var Resolver = require('./bootstrap').Resolver;

/**
 * A resolver for a web-based environment.
 *
 * This resolver uses postMessage as a transport.
 *
 * @constructs Cosmos.WebResolver
 * @extends Cosmos.Resolver
 * @type {string=} opt_target The optional target for the postMessage calls.
 */
function WebResolver(opt_target) {
  if (!(this instanceof WebResolver))
    return new WebResolver(opt_target);
  Resolver.call(this);

  /**
   * The target for postMessage calls.
   *
   * @type {string}
   * @protected
   */
  this._target = opt_target || '*';

  // rebind the _handleResponse method so that we can reuse it for both
  // addEventListener and removeEventListener
  this._handleResponse = this._handleResponse.bind(this);

  /**
   * The identifier for request messages.
   *
   * @type {string}
   * @protected
   */
  this._requestMessageType = 'cosmos-request';

  /**
   * The identifier for response messages.
   *
   * @type {string}
   * @protected
   */
  this._responseMessageType = 'cosmos-response';

  /**
   * Prefix for the requests ids to prevent clashes
   * with bridge requests in webplayer
   *
   * @type {string}
   * @private
   */
  this._requestIdPrefix = 'cosmos_';

  // attach the handler
  this.attach();
}
WebResolver.prototype = new Resolver();
WebResolver.prototype.constructor = WebResolver;
exports.WebResolver = WebResolver;

/**
 * @inheritDoc
 */
WebResolver.prototype._sendRequest = function(requestName, requestID, data) {
  var top = global.window.top;

  var message = {
    type: this._requestMessageType,
    resolver: this._id,
    id: this._requestIdPrefix + requestID,
    name: requestName,
    payload: data.serialize ? data.serialize() : data
  };
  top.postMessage(JSON.stringify(message), this._target);
};

/**
 * @inheritDoc
 */
WebResolver.prototype._handleResponse = function(response) {
  var data = response.data;
  if (typeof data == 'string') {
    try {
      data = JSON.parse(response.data);
    } catch (e) {
      return;
    }
  }
  if (data.type != this._responseMessageType ||
      data.resolver != this._id ||
      !data.payload) return;
  var id = data.id || '';
  var requestID = parseInt(id.replace(this._requestIdPrefix, ''), 10);
  var requestName = data.name || '';
  if (!requestID || !requestName) return;
  this._dispatchResponse(requestID, requestName, data.payload);
};

/**
 * Attaches the resolver so that it could process postMessage calls.
 */
WebResolver.prototype.attach = function() {
  var win = global.window;
  if (win.addEvent && !win.addEventListener) {
    win.addEvent('onmessage', this._handleResponse);
  } else {
    win.addEventListener('message', this._handleResponse, false);
  }
};

/**
 * Detaches the resolver so that it doesn't process postMessage calls.
 */
WebResolver.prototype.detach = function() {
  var win = global.window;
  if (win.removeEvent && !win.removeEventListener) {
    win.removeEvent('onmessage', this._handleResponse);
  } else {
    win.removeEventListener('message', this._handleResponse, false);
  }
};

/**
 * Resolves a single request (represented by the data) through the transport.
 * Single requests need to be closed immediately after the response is
 * received.
 *
 * @param {Object} data The data representing the request.
 * @param {function} onsuccess The success handler for the request.
 * @param {function} onerror The error handler for the request.
 */
WebResolver.prototype.resolve = function(data, onsuccess, onerror) {
  function onResult(callback, response) {
    defer(callback.bind(this, response));
    request.close();
  }

  var request = this._resolve(data, onResult.bind(this, onsuccess), onResult.bind(this, onerror));
  return request;
};

/**
 * Resolves a  subscription request (represented by the data) through the transport.
 * Subscriptions stay open until they're explicitly closed.
 * Every time the request returns some data pull for next
 * batch is sent.
 *
 * @param {Object} data The data representing the request.
 * @param {function} onsuccess The success handler for the request.
 * @param {function} onerror The error handler for the request.
 */
WebResolver.prototype.subscribe = function(data, onsuccess, onerror) {
  return this._resolve(data, onsuccess, onerror);
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./bootstrap":228,"spotify-deferred":235}],232:[function(require,module,exports){
/*jslint node: true */

'use strict';

var defer = require('spotify-deferred');

/**
 * The representation of the connection to the client.
 * With introduction of Cosmos subscription the model of making
 * client requests changed.
 * Each Cosmos requests now needs to be explicitly cancelled to
 * close the connection.
 * Simple requests that only send or retrieve data (e.g POST and GET)
 * need to send 'cosmos_request_cancel' message immediately after the response
 * is received.
 * Subscription requests need to send a 'cosmos_request_pull' message every time
 * they receive data. The consumer of the subscription needs to cancel the subscription
 * when no more data should be sent from the provider.
 */
function ClientRequest(resolver, requestId, data, onsuccess, onerror) {

  /**
   * Request identifier.
   * @type {number}
   */
  this._requestId = requestId;

  /**
   * Either web or native request resolver.
   * @type {Cosmos.Resolver}
   */
  this._resolver = resolver;

  /**
   * Data that should be passed with every request.
   * @type {*}
   */
  this._requestData = data;

  /**
   * Triggered on success
   * @type {function}
   */
  this._successCallback = onsuccess;

  /**
   * Triggered on error
   * @type {function}
   */
  this._errorCallback = onerror;

  /**
   * Current state of the request.
   * @type {ClientRequest.status}
   */
  this._status = ClientRequest.status.INITIALIZED;
}
exports.ClientRequest = ClientRequest;

/**
 * Possible state of the ClientRequest instance.
 */
ClientRequest.status = {
  INITIALIZED: 'INITIALIZED',
  CLOSED: 'CLOSED',
  OPEN: 'OPEN'
};

/**
 * Possible desktop bridge messages.
 */
ClientRequest.messages = {
  OPEN: 'cosmos_request_create',
  PULL: 'cosmos_request_pull',
  CLOSE: 'cosmos_request_cancel'
};

/**
 * Opens the connection with the client.
 */
ClientRequest.prototype.open = function() {
  if (this._status === ClientRequest.status.INITIALIZED) {
    this._status = ClientRequest.status.OPEN;
    this._sendRequest(ClientRequest.messages.OPEN, this._requestData);
  }
};

/**
 * Send pull request for the open connection.
 * For subscriptions pull should resolve to a
 * piece of data.
 */
ClientRequest.prototype.pull = function() {
  if (this._status === ClientRequest.status.OPEN) {
    this._sendRequest(ClientRequest.messages.PULL, this._requestData);
  }
  return this._status;
};

/**
 * Closes the connection with the client.
 */
ClientRequest.prototype.close = function() {
  if (this._status === ClientRequest.status.OPEN) {
    this._status = ClientRequest.status.CLOSE;
    this._sendRequest(ClientRequest.messages.CLOSE);
  }
};

ClientRequest.prototype.onClose = function() {};

/**
 * Sends the request to the platform specific resolver
 * @param {string} requestName The message type. One of the {ClientRequest.messages}.
 * @param {object?} data The data to send with the request.
 */
ClientRequest.prototype._sendRequest = function(requestName, data) {
  this._resolver._sendRequest(requestName, this._requestId, data || {});
};

/**
 * Handles the response for the given request
 * @param {String} requestName The message type. One of the {ClientRequest.messages}.
 * @param {Object} data The response data.
 */
ClientRequest.prototype._handleResponse = function(requestName, data) {
  var self = this;
  var status = data && data.status;
  var callback;

  if (requestName === ClientRequest.messages.CLOSE) {
    this._successCallback = null;
    this._errorCallback = null;
    this._requestData = null;
    this.onClose(this._requestId);
    return;
  }

  callback = this._successCallback;
  callback = typeof callback === 'function' ? callback : function() {};
  defer(callback.bind(this, data));
};

},{"spotify-deferred":235}],233:[function(require,module,exports){
(function (global){
'use strict';

var window = global.window || {};
var process = global.process;

var common = require('cosmos-common-js');
var Resolver = require('./scripts/resolver').Resolver;

var SPResolver = null;
var spResolver = null;

var hasNativeBridge = window._getSpotifyModule &&
    typeof window._getSpotifyModule === 'function' &&
    window._getSpotifyModule('bridge');

var nodeRegex = /(node)|(grunt)|(iojs)(\.exe)*$/;
var isNodeJs = process && process.title && nodeRegex.test(process.argv[0]);

if (!isNodeJs) {
  if (hasNativeBridge) {
    SPResolver = require('./env/bootstrap.native.js').NativeResolver;
    spResolver = new SPResolver(hasNativeBridge);
  } else {
    SPResolver = require('./env/bootstrap.web.js').WebResolver;
    spResolver = new SPResolver();
  }
} else {
  SPResolver = require('./env/bootstrap.mock.js').MockResolver;
  spResolver = new SPResolver();

  exports.mockResolver = {
    addHandler: spResolver.addHandler.bind(spResolver),
    removeHandler: spResolver.removeHandler.bind(spResolver),
    clearHandlers: spResolver.clearHandlers.bind(spResolver)
  };
}

exports.Resolver = Resolver;
exports.Action = common.request.Action;
exports.Request = common.request.Request;
exports.Response = common.response.Response;
exports.resolver = spResolver ? new Resolver(spResolver) : null;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./env/bootstrap.mock.js":229,"./env/bootstrap.native.js":230,"./env/bootstrap.web.js":231,"./scripts/resolver":236,"cosmos-common-js":142}],234:[function(require,module,exports){
/**
 * @file
 * Unified window messaging facility.
 *
 * This module exports two functions to the Spotify
 * namespace which allows other subsystems to handle
 * particular types of messages sent through the native
 * window.postMessage method.
 *
 * @see Spotify.addMessageHandler
 * @see Spotify.removeMessageHandler
 */
'use strict';

var POST_ROUTER_ID = 'post-router-msg-' + new Date().getTime();

var hasStructuredClone = false;

var setImmediate = setImmediate ? setImmediate : setTimeout;

var CURRENT_WINDOW_ORIGIN = undefined;

if (typeof window !== 'undefined') {
  CURRENT_WINDOW_ORIGIN = (window.location.origin ||
      window.location.protocol + '//' + window.location.hostname);

  // Hacky solution to make it work for the webplayer.
  if (!window.__forceNoStructuredClone) {
    // Check if the platform has support for structured cloning.
    //
    // In platforms where this is supported, sending a postMessage with an
    // object that contains a function will throw an error, as it is not
    // cloneable.
    try {
      window.postMessage({
        toString: function() {
          return "clone-test";
        }
      }, CURRENT_WINDOW_ORIGIN);
      hasStructuredClone = false;
    } catch(e) {
      hasStructuredClone = true;
    }
  }
}

/**
 * Storage for message handlers.
 *
 * @type {Object.<string, Spotify.Shell.MessageHandler>}
 * @private
 */
var handlers = {};


/**
 * Variable to check if the window is already listening to postMessage events
 *
 * @type {bool}
 * @private
 */
var isListening = false;


function handleImmediateMessage(data) {
  var handler = handlers[data.type];
  if (!handler) return;
  handler.fn.call(this, data);
}


/**
 * Main event handler for the window message event.
 *
 * @param {Event} event The message event object.
 * @private
 */
function handlePostMessage(event) {
  var data = event.data;
  if (!hasStructuredClone) {
    if (typeof data == 'string') {
      try {
        data = JSON.parse(data);
      } catch (e) {
        return;
      }
    } else {
      // We only expect strings.
      return;
    }
  }
  if (event.origin == CURRENT_WINDOW_ORIGIN) {
    data = data[POST_ROUTER_ID];
    if (!data) {
      // Not our data, return immediately.
      return;
    }
  }
  var handler = handlers[data.type];
  if (!handler || handler.origin != '*' && event.origin !== handler.origin) {
    return;
  }
  handler.fn.call(this, data, event);
}

/**
 * Attaches the handlePostMessage function to PostMessage events
 *
 * @private
 */
var startListening = function() {
  if (window.attachEvent && !window.addEventListener) {
    // IE8 and Below
    window.attachEvent('onmessage', handlePostMessage);
  } else if (window.attachEvent && window.addEventListener) {
    // IE9
    window.addEventListener('message', handlePostMessage, false);
  } else if (window.addEventListener) {
    // Everyone else
    window.addEventListener('message', handlePostMessage, false);
  }
};


/**
 * Adds a message handler for a particular message type.
 *
 * The message handler function will be invoked when the window receives
 * a message marked as a particular type, receiving an argument. The
 * argument will be the data payload of the event decoded from JSON.
 *
 * @param {string} type The type of the message to handle.
 * @param {function} fn The handler function.
 * @param {string} origin needed
 * @throws {Error} Thrown if the message type being handled already has
 *     a handler function.
 */
var addMessageHandler = function(type, fn, origin) {
  if (typeof window !== 'undefined' && !isListening) {
    startListening();
    isListening = true;
  }

  if (!origin) {
    origin = CURRENT_WINDOW_ORIGIN;
  }

  if (handlers[type]) {
    throw new Error('Rehandling of message "' + type + '" not allowed.');
  }
  handlers[type] = {
    fn: fn,
    origin: origin
  };
  return;
};


/**
 * Removes a message handler for a particular message type.
 *
 * @param {string} type The type of the message to remove.
 * @param {Spotify.Shell.MessageHandler} fn The handler function.
 * @return {boolean} True if the handler function was succesfully removed.
 */
var removeMessageHandler = function(type, fn) {
  if (handlers[type] && (!fn || handlers[type].fn === fn)) {
    handlers[type] = null;
    return true;
  }
  return false;
};


/**
 * Sends a message to the event handler
 *
 * @param {string} type The type of the message to remove.
 * @param {Object} data JSON object to pass to the handler
 */
var sendMessage = function(type, data, destWindow, origin) {
  data = data || {};
  data.type = type;

  if (typeof window === 'undefined') {
    return setImmediate(handleImmediateMessage.bind(null, data));
  }

  destWindow = destWindow || window;

  if (!origin) {
    origin = CURRENT_WINDOW_ORIGIN;
  }

  destWindow.postMessage(JSON.stringify(data), origin);
};

var sendLocalMessage = function(type, data) {
  data = data || {};
  data.type = type;

  if (typeof window === 'undefined') {
    return setImmediate(handleImmediateMessage.bind(null, data));
  }

  // Wrap the data in a custom object to quickly identify the message.
  var wrapper = {};
  wrapper[POST_ROUTER_ID] = data;

  window.postMessage(hasStructuredClone ?
                     wrapper :
                     JSON.stringify(wrapper), CURRENT_WINDOW_ORIGIN);
};


/**
 * Export public interface
 */
module.exports = {
  addMessageHandler: addMessageHandler,
  removeMessageHandler: removeMessageHandler,
  sendMessage: sendMessage,
  sendLocalMessage: sendLocalMessage,
  WINDOW_ORIGIN: CURRENT_WINDOW_ORIGIN
};

},{}],235:[function(require,module,exports){
/**
 * @file
 * Introduces a function called "defer" that allows functions to be
 * executed in the next available tick.
 *
 * Unlike "setTimeout", "defer" executes the function at the nearest
 * possible time without clamping.
 *
 * @see Spotify.defer
 */
'use strict';

var PostRouter = require('spotify-postrouter');


/**
 * Storage for deferred functions to be executed.
 *
 * @type {Array.<function()>}
 * @private
 */
var deferred = [];


/**
 * A bound version of the postMessage routine used to trigger deferred
 * execution.
 *
 * @type {function()}
 * @private
 */
var send = function () {
  PostRouter.sendLocalMessage('execute_deferreds');
};


/**
 * Executes the deferred functions when the window
 * receives an 'execute_deferreds' message.
 *
 * @private
 */
function executeDeferreds() {
  var fns = deferred.splice(0);
  if (!fns.length) return;
  for (var i = 0, l = fns.length; i < l; i++) {
    try {
      fns[i]();
    } finally {
      // Do nothing.
      null;
    }
  }
}

PostRouter.addMessageHandler('execute_deferreds', executeDeferreds);


/**
 * Executes the function applied at the nearest possible time without
 * clamping.
 *
 * @param {function()} fn The function to execute.
 */
var defer = function(fn) {
  var trigger = !deferred.length;
  deferred.push(fn);
  if (trigger) send();
};


/**
 * Export public interface
 */
module.exports = defer;

},{"spotify-postrouter":234}],236:[function(require,module,exports){
var common = require('cosmos-common-js');

var Request = common.request.Request;
var Action = common.request.Action;
var Response = common.response.Response;

/**
 * Checks whether a status is successful.
 *
 * We define a successful status to be something within the 200 to 299 range.
 *
 * @param {number} status The status to check.
 */
function _isSuccessStatus(status) {
  // This constitutes a successfull status.
  return (status >= 200 && status <= 299);
};


function Resolver(spResolver) {
  if (!spResolver || typeof spResolver.resolve !== 'function') {
    throw TypeError('Incorrect resolver argument');
  }

  this._resolver = spResolver;
}

/**
 * The basic, generic method of sending the requests.
 *
 * For params description:
 * @borrows Resolver#_resolve as Resolver#resolve
 */
Resolver.prototype.resolve = function(request, callback) {
  return this._resolve(request, callback);
};

/**
 * Convenience method for doing GET requests.
 * resolver.get('sp://player') is an equivalent of
 * resolver.resolve(new Request('GET', 'sp://player')).
 *
 * @param {string|Object.<string, object>} options If is a string
 * will be parsed as url. If more data is needed, object notation
 * should be used.
 *  param options.url {string} The url of the request.
 *  param options.body {object=} The request body.
 *  param options.headers {object=} The request headers.
 * @param {function(error=, object?)} callback The function
 * executed after the request has been completed.
 *
 * @return {RequestHandler} The cancellable request handler.
 */
Resolver.prototype.get = function(options, callback) {
  return this._resolveFromParams(Action.GET, options, callback);
};

/**
 * Convenience method for doing POST requests.
 * resolver.post('sp://player') is an equivalent of
 * resolver.resolve(new Request('POST', 'sp://player'))
 *
 * @see Resolver#get for params description and returned value.
 */
Resolver.prototype.post = function(options, callback) {
  return this._resolveFromParams(Action.POST, options, callback);
};

/**
 * Convenience method for doing SUB requests.
 * resolver.subscribe('sp://player') is an equivalent of
 * resolver.resolve(new Request('SUB', 'sp://player'))
 *
 * @see Resolver#get for params description and returned value.
 */
Resolver.prototype.subscribe = function(options, callback) {
  return this._resolveFromParams(Action.SUB, options, callback);
};

/**
 * Convenience method for doing PUT requests.
 * resolver.put('sp://ads/v1/settings/session') is an equivalent of
 * resolver.resolve(new Request('PUT', 'sp://ads/v1/settings/session'))
 *
 * @see Resolver#get for params description and returned value.
 */
Resolver.prototype.put = function(options, callback) {
  return this._resolveFromParams(Action.PUT, options, callback);
};

/**
 * Convenience method for doing PATCH requests.
 * resolver.patch('sp://ads/v1/settings/session') is an equivalent of
 * resolver.resolve(new Request('PATCH', 'sp://ads/v1/settings/session'))
 *
 * @see Resolver#get for params description and returned value.
 */
Resolver.prototype.patch = function(options, callback) {
  return this._resolveFromParams(Action.PATCH, options, callback);
};

/**
 * Convenience method for doing DELETE requests.
 * resolver.delete('sp://player') is an equivalent of
 * resolver.resolve(new Request('DELETE', 'sp://player'))
 *
 * @see Resolver#get for params description and returned value.
 */
Resolver.prototype.delete = function(options, callback) {
  return this._resolveFromParams(Action.DELETE, options, callback);
};

/**
 * @private
 * Sends the request to the platform specific request resolver.
 * If the request action is 'SUB' it will send subscribe request
 * In any other case it will send simple resolve request.
 *
 * @param {Cosmos.Request} request A request object.
 * @param {function(error=, object?)} callback The function
 * executed after the request has been completed.
 *
 * @return {RequestHandler} The cancellable request handler.
 */
Resolver.prototype._resolve = function(request, callback) {
  if (!callback || typeof callback !== 'function') {
    callback = function() {};
  }

  var requestHandler;

  function onSuccess(serverResponse) {
    if (!requestHandler._request) {
      return;
    }

    var response = Response.fromObject(serverResponse);
    if (!response) {
      var error = new Error(
        'Failed to parse response: ' + JSON.stringify(serverResponse));
      return callback(error);
    }

    if (_isSuccessStatus(response.getStatusCode())) {
      return callback(null, response);
    } else {
      // Extract just the initial part of the request uri. It's good to have something
      // but it is also good to avoid having everything, since that can hurt dashboards
      // that group error messages.
      var requestEndpoint = request.toJSON().uri.match(/[^\:]*(\:\/\/)?[^\/]*/)[0];
      var errorMessage = (
        response.getHeader("error") ||
        "Request to " + requestEndpoint + " failed with status code " + response.getStatusCode());
      var error = new Error(errorMessage);
      error.response = response;
      return callback(error, response);
    }
  }

  function onError(serverResponse) {
    return callback(serverResponse instanceof Error ?
      serverResponse :
      new Error('Request failed: ' + JSON.stringify(serverResponse)));
  }

  var resolveFn = request.getAction() === Action.SUB ?
      this._resolver.subscribe : this._resolver.resolve;

  var clientRequest = resolveFn.call(this._resolver, request, onSuccess, onError);

  requestHandler = new RequestHandler(clientRequest);
  return requestHandler;
};

/**
 * @private
 * Creates Request object from supplied params.
 * @param {string} method Request method. One of the Request.Action.
 * @param {string|Object.<string, object>} options If is a string
 * will be parsed as url. If more data is needed, object notation
 * should be used.
 *  param options.url {string} The url of the request.
 *  param options.body {object=} The request body.
 *  param options.headers {object=} The request headers.
 * @param {function(error=, object?)} callback The function
 * executed after the request has been completed.
 *
 * @return {RequestHandler} The cancellable request handler.
 */
Resolver.prototype._resolveFromParams = function(method, options, callback) {
  options = options || {};

  var url = typeof options === 'string' ? options : options.url;
  var headers = options.headers;
  var body = options.body;

  var request = new Request(method, url, headers, body);

  return this._resolve(request, callback);
};

/**
 * The object that wraps the clientRequest
 * in a very simple interface.
 * Separates the implementation of the ClientRequest
 * from the request handler returned by Cosmos API.
 *
 * @param {Cosmos.ClientRequest} request The object
 * representing the newly opened request to the client.
 * Usually a request will be a subscription that
 * needs a close handler.
 */
function RequestHandler(request) {
  if (!request || typeof request.close !== 'function')
    throw new TypeError('Invalid `request` argument.');

  this._request = request;
}

/**
 * Closes the request and removes the object.
 */
RequestHandler.prototype.cancel = function() {
  if (this._request) {
    this._request.close();
    this._request = null;
  }
};

exports.Resolver = Resolver;

},{"cosmos-common-js":142}],237:[function(require,module,exports){
'use strict';

/**
 * The Base62 Converter
 *
 * @class Base62
 * @constructor
 *
 */

var digits = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
var invHexDigits = {};
var invDigits = {};

for (var i = 0; i < digits.length; ++i) { invDigits[digits[i]] = i; }
for (var i = 0; i < 16; ++i) { invHexDigits['0123456789abcdef'[i]] = i; }
for (var i = 0; i < 16; ++i) { invHexDigits['0123456789ABCDEF'[i]] = i; }

/**
 * lhs *= rhs
 * @private
 */
function mul(lhs, rhs, base) {
  var rest = 0;
  for (var i = 0; i < lhs.length; ++i) {
    var tmp = lhs[i] * rhs + rest;
    lhs[i] = tmp % base;
    rest = ~~(tmp / base);
  }
  while (rest) {
    lhs.push(rest % base);
    rest = ~~(rest / base);
  }
}

/**
 * acc += lhs * rhs
 * @private
 */
function madd(acc, lhs, rhs, base) {
  var rest = 0;
  for (var i = 0; i < lhs.length; ++i) {
    var tmp = ~~acc[i] + lhs[i] * rhs + rest;
    acc[i] = tmp % base;
    rest = ~~(tmp / base);
  }
  while (rest) {
    var tmp = ~~acc[i] + rest;
    acc[i] = tmp % base;
    rest = ~~(tmp / base);
    ++i;
  }
}

/**
 * Change base
 * @private
 */
function convert(data, fromBase, toBase) {
  var r = [0];
  var b = [1];
  for (var i = 0; i < data.length; ++i) {
    madd(r, b, data[i], toBase);
    mul(b, fromBase, toBase);
  }
  return r;
}

/**
 * Decode to
 * @private
 */
function mapr(data, mapping) {
  for (var i = 0, r = []; i < data.length; ++i) { r.push(mapping[data[i]]); }
  return r.reverse();
}

/**
 * Pad with 0s
 * @private
 */
function pad(data, length) {
  while (data.length < length) { data.push(0); }
  return data;
}

module.exports = {

  /**
   * Converts from array of bytes to base62 encoded string.
   *
   * @public
   * @name Spotify.Utils.Base62#fromBytes
   * @function
   * @param {Array.<number>} data Array of byte numbers.
   * @param {?number} length Do zeropadding until at least this length.
   * @return {string} Base62 encoded string.
  **/
  fromBytes: function(data, length) {
    var r = convert(data.slice(0).reverse(), 256, 62);
    return mapr(pad(r, length), digits).join('');
  },

  /**
   * Converts from base62 encoded string to array of bytes
   *
   * @public
   * @name Spotify.Utils.Base62#toBytes
   * @function
   * @param {string} str Base62 encoded string.
   * @param {?number} length Do zeropadding until at least this length.
   * @return {Array.<number>} Array of byte numbers.
  **/
  toBytes: function(str, length) {
    var r = convert(mapr(str, invDigits), 62, 256);
    return pad(r, length).reverse();
  },

  /**
   * Converts from base62 encoded string to hex encoded string
   *
   * @public
   * @name Spotify.Utils.Base62#toHex
   * @function
   * @param {string} str Base62 encoded string.
   * @param {?number} length Do zeropadding until at least this length.
   * @return {string} Hex encoded string.
  **/
  toHex: function(str, length) {
    var r = convert(mapr(str, invDigits), 62, 16);
    return mapr(pad(r, length), digits).join('');
  },

  /**
   * Converts from hex encoded strign to base62 encoded string
   *
   * @public
   * @name Spotify.Utils.Base62#fromHex
   * @function
   * @param {string} str Hex encoded string.
   * @param {?number} length Do zeropadding until at least this length.
   * @return {string} Base62 encoded string.
  **/
  fromHex: function(str, length) {
    var r = convert(mapr(str, invHexDigits), 16, 62);
    return mapr(pad(r, length), digits).join('');
  }

};

},{}],238:[function(require,module,exports){
(function() {
  /**
   * @file
   * Introduces a function called "defer" that allows functions to be
   * executed in the next available tick.
   *
   * Unlike "setTimeout", "defer" executes the function at the nearest
   * possible time without clamping.
   *
   * @see Spotify.defer
   */
  'use strict';

  var hasWindow = typeof window != 'undefined';
  var hasDefineProperty = typeof Object.defineProperty == 'function';

  if (hasWindow && window.__modDefFn) {
    // If deferred has been attached to the global scope
    module.exports = window.__modDefFn;
    return;
  }

  /**
   * Storage for deferred functions to be executed.
   *
   * @type {Array.<function()>}
   * @private
   */
  var deferred = [];


  /**
   * A bound version of the postMessage routine used to trigger deferred
   * execution.
   *
   * @type {function()}
   * @private
   */
  var send;
  var origin;

  if (hasWindow && window.postMessage) {
    origin = (window.location.origin ||
          window.location.protocol + '//' + window.location.hostname);
    send = window.postMessage.bind(window, '@execute_deferreds', origin);
    if (!window.__hasDeferredHandler) {
      if (hasDefineProperty) {
        Object.defineProperty(window, '__hasDeferredHandler', {value: 1});
      } else {
        window.__hasDeferredHandler = 1;
      }
      var handler = function(e) {
        if (e.origin != origin && e.data != '@execute_deferreds') {
          return;
        }
        executeDeferreds();
      };
      if (window.addEventListener) {
        window.addEventListener('message', handler);
      } else {
        window.attachEvent('onmessage', handler);
      }
    }
  } else if (typeof setImmediate != 'undefined') {
    send = setImmediate.bind(null, executeDeferreds);
  } else {
    send = setTimeout.bind(null, executeDeferreds, 10);
  }


  /**
   * Executes the deferred functions when the window
   * receives an 'execute_deferreds' message.
   *
   * @private
   */
  function executeDeferreds() {
    var fns = deferred.splice(0);
    if (!fns.length) return;
    for (var i = 0, l = fns.length; i < l; i++) {
      try {
        fns[i]();
      } finally {
        // Do nothing.
        null;
      }
    }
  }


  /**
   * Executes the function applied at the nearest possible time without
   * clamping.
   *
   * @param {function()} fn The function to execute.
   */
  var defer = function(fn) {
    var trigger = !deferred.length;
    deferred.push(fn);
    if (trigger) send();
  };

  if (hasWindow && !window.__modDefFn) {
    if (hasDefineProperty) {
      Object.defineProperty(window, '__modDefFn', {value: defer});
    } else {
      window.__modDefFn = defer;
    }
  }

  /**
   * Export public interface
   */
  module.exports = defer;

})();

},{}],239:[function(require,module,exports){
'use strict';

/**
 * Function to add properties to an object
 * @param {Object} obj The input object
 * @param {Object} args The objects which are going to be injected
 * @return {Object} The extended object
 */
var extend = function(obj, args) {
  var source;

  for (var i = 1; i < arguments.length; i++) {
    source = arguments[i];
    if (source) {
      for (var prop in source) {
        if (source.hasOwnProperty(prop)) {
          obj[prop] = source[prop];
        }
      }
    }
  }
  return obj;
};


/**
 * Export public interface
 */
module.exports = extend;

},{}],240:[function(require,module,exports){
'use strict';

module.exports = {
  inherit: require('./inherit'),
  extend: require('./extend')
};

},{"./extend":239,"./inherit":241}],241:[function(require,module,exports){
'use strict';

/**
 * Makes a class inherit from a superclass' prototype indirectly.
 *
 * @param {Spotify.ClassLike} Sub The class that will inherit.
 * @param {Spotify.ClassLike} Super The class to inherit from.
 */
var inherit = function(Sub, Super) {
  var superProto = Super.prototype;
  function Superclass() {}
  Superclass.prototype = Sub._super = superProto;
  Superclass.prototype.constructor = Super;
  Sub.prototype = new Superclass();
};


/**
 * Export public interface
 */
module.exports = inherit;

},{}],242:[function(require,module,exports){
'use strict';

/**
 * @private
 */
var Base62 = require('spotify-crypto/src/base62');

/**
 * The URI prefix for URIs.
 *
 * @const
 * @private
 */
var URI_PREFIX = 'spotify:';

/**
 * The URL prefix for Play.
 *
 * @const
 * @private
 */
var PLAY_HTTP_PREFIX = 'http://play.spotify.com/';

/**
 * The HTTPS URL prefix for Play.
 *
 * @const
 * @private
 */
var PLAY_HTTPS_PREFIX = 'https://play.spotify.com/';

/**
 * The URL prefix for Open.
 *
 * @const
 * @private
 */
var OPEN_HTTP_PREFIX = 'http://open.spotify.com/';

/**
 * The HTTPS URL prefix for Open.
 *
 * @const
 * @private
 */
var OPEN_HTTPS_PREFIX = 'https://open.spotify.com/';

var ERROR_INVALID = new TypeError('Invalid Spotify URI!');
var ERROR_NOT_IMPLEMENTED = new TypeError('Not implemented!');


/**
 * The format for the URI to parse.
 *
 * @enum {number}
 * @private
 */
var Format = {
  URI: 0,
  URL: 1
};

/**
 * Represents the result of a URI splitting operation.
 *
 * @typedef {{
 *    format: Format,
 *    components: Array.<string>
 * }}
 * @see _splitIntoComponents
 * @private
 */
var SplittedURI;

/**
 * Split an string URI or HTTP/HTTPS URL into components, skipping the prefix.
 *
 * @param {string} str A string URI to split.
 * @return {SplittedURI} The parsed URI.
 * @private
 */
var _splitIntoComponents = function(str) {
  var components;
  var format;
  var anchor;

  var hashSplit = str.split('#');

  if (hashSplit.length > 1) {
    // first token
    str = hashSplit.shift();
    // last token
    anchor = hashSplit.pop();
  }

  if (str.indexOf(URI_PREFIX) === 0) {
    components = str.slice(URI_PREFIX.length).split(':');
    format = Format.URI;
  } else {
    // For HTTP URLs, ignore any query string argument
    str = str.split('?')[0];

    if (str.indexOf(PLAY_HTTP_PREFIX) === 0) {
      components = str.slice(PLAY_HTTP_PREFIX.length).split('/');
    } else if (str.indexOf(PLAY_HTTPS_PREFIX) === 0) {
      components = str.slice(PLAY_HTTPS_PREFIX.length).split('/');
    } else if (str.indexOf(OPEN_HTTP_PREFIX) === 0) {
      components = str.slice(OPEN_HTTP_PREFIX.length).split('/');
    } else if (str.indexOf(OPEN_HTTPS_PREFIX) === 0) {
      components = str.slice(OPEN_HTTPS_PREFIX.length).split('/');
    } else {
      throw ERROR_INVALID;
    }
    format = Format.URL;
  }

  if (anchor) {
    components.push(anchor);
  }

  return {
    format: format,
    components: components
  };
};

/**
 * Encodes a component according to a format.
 *
 * @param {string} component A component string.
 * @param {Format} format A format.
 * @return {string} An encoded component string.
 * @private
 */
var _encodeComponent = function(component, format) {
  component = encodeURIComponent(component);
  if (format === Format.URI) {
    component = component.replace(/%20/g, '+');
  }

  // encode characters that are not encoded by default by encodeURIComponent
  // but that the Spotify URI spec encodes: !'*()
  component = component.replace(/[!'()]/g, escape);
  component = component.replace(/\*/g, '%2A');

  return component;
};

/**
 * Decodes a component according to a format.
 *
 * @param {string} component An encoded component string.
 * @param {Format} format A format.
 * @return {string} An decoded component string.
 * @private
 */
var _decodeComponent = function(component, format) {
  var part = format == Format.URI ? component.replace(/\+/g, '%20') : component;
  return decodeURIComponent(part);
};

/**
 * Returns the components of a URI as an array.
 *
 * @param {URI} uri A uri.
 * @param {Format} format The output format.
 * @return {Array.<string>} An array of uri components.
 * @private
 */
var _getComponents = function(uri, format) {
  var base62;
  if (uri.id) {
    base62 = uri._base62Id;
  }

  var components;
  var i;
  var len;
  switch (uri.type) {
    case URI.Type.ALBUM:
      components = [URI.Type.ALBUM, base62];
      if (uri.disc) {
        components.push(uri.disc);
      }
      return components;
    case URI.Type.AD:
      return [URI.Type.AD, uri._base62Id];
    case URI.Type.ARTIST:
      return [URI.Type.ARTIST, base62];
    case URI.Type.ARTIST_TOPLIST:
      return [URI.Type.ARTIST, base62, URI.Type.TOP, uri.toplist];
    case URI.Type.SEARCH:
      return [URI.Type.SEARCH, _encodeComponent(uri.query, format)];
    case URI.Type.TRACK:
      if (uri.anchor) {
        base62 += '#' + uri.anchor;
      }
      return [URI.Type.TRACK, base62];
    case URI.Type.TRACKSET:
      var trackIds = [];
      for (i = 0, len = uri.tracks.length; i < len; i++) {
        trackIds.push(uri.tracks[i]._base62Id);
      }
      trackIds = [trackIds.join(',')];
      // Index can be 0 sometimes (required for trackset)
      if (uri.index !== null) {
        trackIds.push('#', uri.index);
      }
      return [URI.Type.TRACKSET, _encodeComponent(uri.name)].concat(trackIds);
    case URI.Type.FACEBOOK:
      return [URI.Type.USER, URI.Type.FACEBOOK, uri.uid];
    case URI.Type.AUDIO_FILE:
      return [URI.Type.AUDIO_FILE, uri.extension, uri._base62Id];
    case URI.Type.FOLDER:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.FOLDER, uri._base62Id];
    case URI.Type.FOLLOWERS:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.FOLLOWERS];
    case URI.Type.FOLLOWING:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.FOLLOWING];
    case URI.Type.PLAYLIST:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.PLAYLIST, base62];
    case URI.Type.STARRED:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.STARRED];
    case URI.Type.TEMP_PLAYLIST:
      return [URI.Type.TEMP_PLAYLIST, uri.origin, uri.data];
    case URI.Type.CONTEXT_GROUP:
      return [URI.Type.CONTEXT_GROUP, uri.origin, uri.name];
    case URI.Type.USER_TOPLIST:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.TOP, uri.toplist];
    // Legacy Toplist
    case URI.Type.USER_TOP_TRACKS:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.TOPLIST];
    case URI.Type.TOPLIST:
      return [URI.Type.TOP, uri.toplist].concat(uri.global ? [URI.Type.GLOBAL] : ['country', uri.country]);
    case URI.Type.INBOX:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.INBOX];
    case URI.Type.ROOTLIST:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.ROOTLIST];
    case URI.Type.PUBLISHED_ROOTLIST:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.PUBLISHED_ROOTLIST];
    case URI.Type.COLLECTION_TRACK_LIST:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.COLLECTION_TRACK_LIST, base62];
    case URI.Type.PROFILE:
      if (uri.args && uri.args.length > 0)
        return [URI.Type.USER, _encodeComponent(uri.username, format)].concat(uri.args);
      return [URI.Type.USER, _encodeComponent(uri.username, format)];
    case URI.Type.LOCAL_ARTIST:
      return [URI.Type.LOCAL, _encodeComponent(uri.artist, format)];
    case URI.Type.LOCAL_ALBUM:
      return [URI.Type.LOCAL, _encodeComponent(uri.artist, format), _encodeComponent(uri.album, format)];
    case URI.Type.LOCAL:
      return [URI.Type.LOCAL,
        _encodeComponent(uri.artist, format),
        _encodeComponent(uri.album, format),
        _encodeComponent(uri.track, format),
        uri.duration];
    case URI.Type.LIBRARY:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.LIBRARY].concat(uri.category ? [uri.category] : []);
    case URI.Type.IMAGE:
      return [URI.Type.IMAGE, uri._base62Id];
    case URI.Type.MOSAIC:
      components = uri.ids.slice(0);
      components.unshift(URI.Type.MOSAIC);
      return components;
    case URI.Type.RADIO:
      return [URI.Type.RADIO, uri.args];
    case URI.Type.SPECIAL:
      components = [URI.Type.SPECIAL];
      var args = uri.args || [];
      for (i = 0, len = args.length; i < len; ++i)
        components.push(_encodeComponent(args[i], format));
      return components;
    case URI.Type.STATION:
      components = [URI.Type.STATION];
      var args = uri.args || [];
      for (i = 0, len = args.length; i < len; i++) {
        components.push(_encodeComponent(args[i], format));
      }
      return components;
    case URI.Type.APPLICATION:
      components = [URI.Type.APP, uri._base62Id];
      var args = uri.args || [];
      for (i = 0, len = args.length; i < len; ++i)
        components.push(_encodeComponent(args[i], format));
      return components;
    case URI.Type.COLLECTION_ALBUM:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.COLLECTION, URI.Type.ALBUM, base62];
    case URI.Type.COLLECTION_MISSING_ALBUM:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.COLLECTION, URI.Type.ALBUM, base62, 'missing'];
    case URI.Type.COLLECTION_ARTIST:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.COLLECTION, URI.Type.ARTIST, base62];
    case URI.Type.COLLECTION:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.COLLECTION].concat(uri.category ? [uri.category] : []);
    case URI.Type.EPISODE:
      return [URI.Type.EPISODE, base62];
    default:
      throw ERROR_INVALID;
  }
};

/**
 * Parses the components of a URI into a real URI object.
 *
 * @param {Array.<string>} components The components of the URI as a string
 *     array.
 * @param {Format} format The format of the source string.
 * @return {URI} The URI object.
 * @private
 */
var _parseFromComponents = function(components, format) {
  var _current = 0;

  var _getNextComponent = function() {
    return components[_current++];
  };

  var _getIdComponent = function() {
    var component = _getNextComponent();

    if (component.length > 22) {
      throw new Error('Invalid ID');
    }
    return component;
  };

  var _getRemainingComponents = function() {
    return components.slice(_current);
  };

  var _getRemainingString = function() {
    var separator = (format == Format.URI) ? ':' : '/';
    return components.slice(_current).join(separator);
  };

  var part = _getNextComponent();
  var id;
  var i;
  var len;

  switch (part) {
    case URI.Type.ALBUM:
      return URI.albumURI(_getIdComponent(), parseInt(_getNextComponent(), 10));
    case URI.Type.AD:
      return URI.adURI(_getNextComponent());
    case URI.Type.ARTIST:
      id = _getIdComponent();
      if (_getNextComponent() == URI.Type.TOP) {
        return URI.artistToplistURI(id, _getNextComponent());
      } else {
        return URI.artistURI(id);
      }
    case URI.Type.AUDIO_FILE:
      return URI.audioFileURI(_getNextComponent(), _getNextComponent());
    case URI.Type.TEMP_PLAYLIST:
      return URI.temporaryPlaylistURI(_getNextComponent(), _getRemainingString());
    case URI.Type.SEARCH:
      return URI.searchURI(_decodeComponent(_getRemainingString(), format));
    case URI.Type.TRACK:
      return URI.trackURI(_getIdComponent(), _getNextComponent());
    case URI.Type.TRACKSET:
      var name = _decodeComponent(_getNextComponent());
      var tracksArray = _getNextComponent();
      var hashSign = _getNextComponent();
      var index = parseInt(_getNextComponent(), 10);
      // Sanity check: %23 is URL code for "#"
      if (hashSign !== '%23' || isNaN(index)) {
        index = null;
      }
      var tracksetTracks = [];
      if (tracksArray) {
        tracksArray = _decodeComponent(tracksArray).split(',');
        for (i = 0, len = tracksArray.length; i < len; i++) {
          var trackId = tracksArray[i];
          tracksetTracks.push(URI.trackURI(trackId));
        }
      }
      return URI.tracksetURI(tracksetTracks, name, index);
    case URI.Type.CONTEXT_GROUP:
      return URI.contextGroupURI(_getNextComponent(), _getNextComponent());
    case URI.Type.TOP:
      var type = _getNextComponent();
      if (_getNextComponent() == URI.Type.GLOBAL) {
        return URI.toplistURI(type, null, true);
      } else {
        return URI.toplistURI(type, _getNextComponent(), false);
      }
    case URI.Type.USER:
      var username = _decodeComponent(_getNextComponent(), format);
      var text = _getNextComponent();
      if (username == URI.Type.FACEBOOK && text != null) {
        return URI.facebookURI(parseInt(text, 10));
      } else if (text != null) {
        switch (text) {
          case URI.Type.PLAYLIST:
            return URI.playlistURI(username, _getIdComponent());
          case URI.Type.FOLDER:
            return URI.folderURI(username, _getIdComponent());
          case URI.Type.COLLECTION_TRACK_LIST:
            return URI.collectionTrackList(username, _getIdComponent());
          case URI.Type.COLLECTION:
            var collectionItemType = _getNextComponent();
            switch (collectionItemType) {
              case URI.Type.ALBUM:
                id = _getIdComponent();
                if (_getNextComponent() === 'missing') {
                  return URI.collectionMissingAlbumURI(username, id);
                } else {
                  return URI.collectionAlbumURI(username, id);
                }
              case URI.Type.ARTIST:
                return URI.collectionArtistURI(username, _getIdComponent());
              default:
                return URI.collectionURI(username, collectionItemType);
            }
          case URI.Type.STARRED:
            return URI.starredURI(username);
          case URI.Type.FOLLOWERS:
            return URI.followersURI(username);
          case URI.Type.FOLLOWING:
            return URI.followingURI(username);
          case URI.Type.TOP:
            return URI.userToplistURI(username, _getNextComponent());
          case URI.Type.INBOX:
            return URI.inboxURI(username);
          case URI.Type.ROOTLIST:
            return URI.rootlistURI(username);
          case URI.Type.PUBLISHED_ROOTLIST:
            return URI.publishedRootlistURI(username);
          case URI.Type.TOPLIST:
            // legacy toplist
            return URI.userTopTracksURI(username);
          case URI.Type.LIBRARY:
            return URI.libraryURI(username, _getNextComponent());
        }
      }
      var rem = _getRemainingComponents();
      if (text != null && rem.length > 0) {
        return URI.profileURI(username, [text].concat(rem));
      } else if (text != null) {
        return URI.profileURI(username, [text]);
      } else {
        return URI.profileURI(username);
      }
    case URI.Type.LOCAL:
      var artistNameComponent = _getNextComponent();
      var artistName = artistNameComponent && _decodeComponent(artistNameComponent, format);
      var albumNameComponent = _getNextComponent();
      var albumName = albumNameComponent && _decodeComponent(albumNameComponent, format);
      var trackNameComponent = _getNextComponent();
      var trackName = trackNameComponent && _decodeComponent(trackNameComponent, format);
      var durationComponent = _getNextComponent();
      var duration = parseInt(durationComponent, 10);
      if (trackNameComponent !== undefined) {
        return URI.localURI(artistName, albumName, trackName, duration);
      } else if (albumNameComponent !== undefined) {
        return URI.localAlbumURI(artistName, albumName);
      } else {
        return URI.localArtistURI(artistName);
      }
    case URI.Type.IMAGE:
      return URI.imageURI(_getIdComponent());
    case URI.Type.MOSAIC:
      return URI.mosaicURI(components.slice(_current));
    case URI.Type.RADIO:
      return URI.radioURI(_getRemainingString());
    case URI.Type.SPECIAL:
      var args = _getRemainingComponents();
      for (i = 0, len = args.length; i < len; ++i)
        args[i] = _decodeComponent(args[i], format);
      return URI.specialURI(args);
    case URI.Type.STATION:
      return URI.stationURI(_getRemainingComponents());
    case URI.Type.EPISODE:
      return URI.episodeURI(_getIdComponent());
    default:
      if (part === URI.Type.APP) {
        id = _getNextComponent();
      } else {
        id = part;
      }
      var args = _getRemainingComponents();
      for (i = 0, len = args.length; i < len; ++i)
        args[i] = _decodeComponent(args[i], format);
      return URI.applicationURI(id, args);
  }

  throw ERROR_INVALID;
};

/**
 * A class holding information about a uri.
 *
 * @constructor
 * @param {URI.Type} type The uri type.
 * @param {Object} props The uri properties.
 */
function URI(type, props) {
  /**
   * The uri type.
   *
   * @type {string}
   */
  this.type = type;

  // Merge properties into URI object.
  for (var prop in props) {
    if (typeof props[prop] == 'function') {
      continue;
    }
    this[prop] = props[prop];
  }
}

// Lazy convert the id to hexadecimal only when requested
Object.defineProperty(URI.prototype, 'id', {
  get: function() {
    if (!this._hexId) {
      this._hexId = this._base62Id ? URI.idToHex(this._base62Id) : undefined;
    }
    return this._hexId;
  },
  set: function(id) {
    this._base62Id = id ? URI.hexToId(id) : undefined;
    this._hexId = undefined;
  },
  enumerable: true,
  configurable: true
});

/**
 * Creates an application URI object from the current URI object.
 *
 * If the current URI object is already an application type, a copy is made.
 *
 * @return {URI} The current URI as an application URI.
 */
URI.prototype.toAppType = function() {
  if (this.type == URI.Type.APPLICATION) {
    return URI.applicationURI(this.id, this.args);
  } else {
    var components = _getComponents(this, Format.URL);
    var id = components.shift();
    var len = components.length;
    if (len) {
      while (len--) {
        components[len] = _decodeComponent(components[len], Format.URL);
      }
    }
    if (this.type == URI.Type.RADIO) {
      components = components.shift().split(':');
    }
    var result = URI.applicationURI(id, components);
    return result;
  }
};

/**
 * Creates a URI object from an application URI object.
 *
 * If the current URI object is not an application type, a copy is made.
 *
 * @return {URI} The current URI as a real typed URI.
 */
URI.prototype.toRealType = function() {
  if (this.type == URI.Type.APPLICATION) {
    return _parseFromComponents([this.id].concat(this.args), Format.URI);
  } else {
    return new URI(null, this);
  }
};

/**
 * Returns the URI representation of this URI.
 *
 * @return {String} The URI representation of this uri.
 */
URI.prototype.toURI = function() {
  return URI_PREFIX + _getComponents(this, Format.URI).join(':');
};

/**
 * Returns the String representation of this URI.
 *
 * @return {String} The URI representation of this uri.
 * @see {URI#toURI}
 */
URI.prototype.toString = function() {
  return this.toURI();
};

/**
 * Get the URL path of this uri.
 *
 * @param {boolean} opt_leadingSlash True if a leading slash should be prepended.
 * @return {String} The path of this uri.
 */
URI.prototype.toURLPath = function(opt_leadingSlash) {
  var components = _getComponents(this, Format.URL);
  if (components[0] === URI.Type.APP) {
    components.shift();
  }

  // Some URIs are allowed to have empty components. It should be investigated
  // whether we need to strip empty components at all from any URIs. For now,
  // we check specifically for tracksets and local tracks and strip empty
  // components for all other URIs.
  //
  // For tracksets, it's permissible to have a path that looks like
  // 'trackset//trackURI' because the identifier parameter for a trackset can
  // be blank. For local tracks, some metadata can be missing, like missing
  // album name would be 'spotify:local:artist::track:duration'.
  var isTrackset = components[0] === URI.Type.TRACKSET;
  var isLocalTrack = components[0] === URI.Type.LOCAL;
  var shouldStripEmptyComponents = !isTrackset && !isLocalTrack;

  if (shouldStripEmptyComponents) {
    var _temp = [];
    for (var i = 0, l = components.length; i < l; i++) {
      var component = components[i];
      if (!!component) {
        _temp.push(component);
      }
    }
    components = _temp;
  }
  var path = components.join('/');
  return opt_leadingSlash ? '/' + path : path;
};

/**
 * Returns the Play URL string for the uri.
 *
 * @return {string} The Play URL string for the uri.
 */
URI.prototype.toPlayURL = function() {
    return PLAY_HTTPS_PREFIX + this.toURLPath();
};

/**
 * Returns the URL string for the uri.
 *
 * @return {string} The URL string for the uri.
 * @see {URL#toPlayURL}
 */
URI.prototype.toURL = function() {
  return this.toPlayURL();
};

/**
 * Returns the Open URL string for the uri.
 *
 * @return {string} The Open URL string for the uri.
 */
URI.prototype.toOpenURL = function() {
  return OPEN_HTTPS_PREFIX + this.toURLPath();
};

/**
 * Returns the Play HTTPS URL string for the uri.
 *
 * @return {string} The Play HTTPS URL string for the uri.
 */
URI.prototype.toSecurePlayURL = function() {
    return this.toPlayURL();
};

/**
 * Returns the HTTPS URL string for the uri.
 *
 * @return {string} The HTTPS URL string for the uri.
 * @see {URL#toSecurePlayURL}
 */
URI.prototype.toSecureURL = function() {
  return this.toPlayURL();
};

/**
 * Returns the Open HTTPS URL string for the uri.
 *
 * @return {string} The Open HTTPS URL string for the uri.
 */
URI.prototype.toSecureOpenURL = function() {
  return this.toOpenURL();
};

/**
 * Returns the id of the uri as a bytestring.
 *
 * @return {Array} The id of the uri as a bytestring.
 */
URI.prototype.idToByteString = function() {
  var data = Base62.toBytes(this._base62Id);
  data = data.map(function(i) {
    return String.fromCharCode(i);
  }).join('');
  while (data.length < 16) {
    data = String.fromCharCode(0) + data;
  }
  return data;
};

/**
 * The various URI Types.
 *
 * Note that some of the types in this enum are not real URI types, but are
 * actually URI particles. They are marked so.
 *
 * @enum {string}
 */
URI.Type = {
  EMPTY: 'empty',
  ALBUM: 'album',
  AD: 'ad',
  /** URI particle; not an actual URI. */
  APP: 'app',
  APPLICATION: 'application',
  ARTIST: 'artist',
  ARTIST_TOPLIST: 'artist-toplist',
  AUDIO_FILE: 'audiofile',
  COLLECTION: 'collection',
  COLLECTION_ALBUM: 'collection-album',
  COLLECTION_MISSING_ALBUM: 'collection-missing-album',
  COLLECTION_ARTIST: 'collection-artist',
  CONTEXT_GROUP: 'context-group',
  EPISODE: 'episode',
  /** URI particle; not an actual URI. */
  FACEBOOK: 'facebook',
  FOLDER: 'folder',
  FOLLOWERS: 'followers',
  FOLLOWING: 'following',
  /** URI particle; not an actual URI. */
  GLOBAL: 'global',
  IMAGE: 'image',
  INBOX: 'inbox',
  LOCAL_ARTIST: 'local-artist',
  LOCAL_ALBUM: 'local-album',
  LOCAL: 'local',
  LIBRARY: 'library',
  MOSAIC: 'mosaic',
  PLAYLIST: 'playlist',
  PROFILE: 'profile',
  PUBLISHED_ROOTLIST: 'published-rootlist',
  RADIO: 'radio',
  ROOTLIST: 'rootlist',
  COLLECTION_TRACK_LIST: 'collectiontracklist',
  SEARCH: 'search',
  SPECIAL: 'special',
  STARRED: 'starred',
  STATION: 'station',
  TEMP_PLAYLIST: 'temp-playlist',
  /** URI particle; not an actual URI. */
  TOP: 'top',
  TOPLIST: 'toplist',
  TRACK: 'track',
  TRACKSET: 'trackset',
  /** URI particle; not an actual URI. */
  USER: 'user',
  USER_TOPLIST: 'user-toplist',
  USER_TOP_TRACKS: 'user-top-tracks',
  /** Deprecated contant. Please use USER_TOP_TRACKS. */
  USET_TOP_TRACKS: 'user-top-tracks'
};

/**
 * Creates a new URI object from a parsed string argument.
 *
 * @param {string} str The string that will be parsed into a URI object.
 * @throws TypeError If the string argument is not a valid URI, a TypeError will
 *     be thrown.
 * @return {URI} The parsed URI object.
 */
URI.fromString = function(str) {
  var splitted = _splitIntoComponents(str);
  return _parseFromComponents(splitted.components, splitted.format);
};

/**
 * Parses a given object into a URI instance.
 *
 * Unlike URI.fromString, this function could receive any kind of value. If
 * the value is already a URI instance, it is simply returned.
 * Otherwise the value will be stringified before parsing.
 *
 * This function also does not throw an error like URI.fromString, but
 * instead simply returns null if it can't parse the value.
 *
 * @param {*} value The value to parse.
 * @return {URI?} The corresponding URI instance, or null if the
 *     passed value is not a valid value.
 */
URI.from = function(value) {
  try {
    if (value instanceof URI) {
      return value;
    }
    if (typeof value == 'object' && value.type) {
      return new URI(null, value);
    }
    return URI.fromString(value.toString());
  } catch(e) {
    return null;
  }
};

/**
 * Creates a new URI from a bytestring.
 *
 * @param {URI.Type} type The type of the URI.
 * @param {ByteString} idByteString The ID of the URI as a bytestring.
 * @param {Object} opt_args Optional arguments to the URI constructor.
 * @return {URI} The URI object created.
 */
URI.fromByteString = function(type, idByteString, opt_args) {
  var bytes = [];
  for (var i = 0; i < idByteString.length; i++) {
    bytes.push(idByteString.charCodeAt(i));
  }
  var id = Base62.fromBytes(bytes, 22);
  var args = opt_args || {};
  args.id = id;
  return new URI(type, args);
};

/**
 * Clones a given SpotifyURI instance.
 *
 * @param {URI} uri The uri to clone.
 * @return {URI?} An instance of URI.
 */
URI.clone = function(uri) {
  if (!(uri instanceof URI)) {
    return null;
  }
  return new URI(null, uri);
};

/**
 * @deprecated
 */
URI.getCanonical = function(username) {
  return this.getCanonical(username);
};

/**
 * Returns the canonical representation of a username.
 *
 * @param {string} username The username to encode.
 * @return {string} The encoded canonical representation of the username.
 */
URI.getCanonicalUsername = function(username) {
  return _encodeComponent(username, Format.URI);
};

/**
 * Returns the non-canonical representation of a username.
 *
 * @param {string} username The username to encode.
 * @return {string} The unencoded canonical representation of the username.
 */
URI.getDisplayUsername = function(username) {
  return _decodeComponent(username, Format.URI);
};

/**
 * Returns the hex representation of a Base62 encoded id.
 *
 * @param {string} id The base62 encoded id.
 * @return {string} The hex representation of the base62 id.
 */
URI.idToHex = function(id) {
  if (id.length == 22) {
    return Base62.toHex(id, 32);
  }
  return id;
};

/**
 * Returns the base62 representation of a hex encoded id.
 *
 * @param {string} hex The hex encoded id.
 * @return {string} The base62 representation of the id.
 */
URI.hexToId = function(hex) {
  if (hex.length == 32) {
    return Base62.fromHex(hex, 22);
  }
  return hex;
};

/**
 * Creates a new empty URI.
 *
 * @return {URI} The empty URI.
 */
URI.emptyURI = function() {
  return new URI(URI.Type.EMPTY, {});
};

/**
 * Creates a new 'album' type URI.
 *
 * @param {string} id The id of the album.
 * @param {number} disc The disc number of the album.
 * @return {URI} The album URI.
 */
URI.albumURI = function(id, disc) {
  return new URI(URI.Type.ALBUM, {id: id, disc: disc});
};

/**
 * Creates a new 'ad' type URI.
 *
 * @param {string} id The id of the ad.
 * @return {URI} The ad URI.
 */
URI.adURI = function(id) {
  return new URI(URI.Type.AD, {id: id});
};

/**
 * Creates a new 'audiofile' type URI.
 *
 * @param {string} extension The extension of the audiofile.
 * @param {string} id The id of the extension.
 * @return {URI} The audiofile URI.
 */
URI.audioFileURI = function(extension, id) {
  return new URI(URI.Type.AUDIO_FILE, {id: id, extension: extension});
};

/**
 * Creates a new 'artist' type URI.
 *
 * @param {string} id The id of the artist.
 * @return {URI} The artist URI.
 */
URI.artistURI = function(id) {
  return new URI(URI.Type.ARTIST, {id: id});
};

/**
 * Creates a new 'artist-toplist' type URI.
 *
 * @param {string} id The id of the artist.
 * @param {string} toplist The toplist type.
 * @return {URI} The artist-toplist URI.
 */
URI.artistToplistURI = function(id, toplist) {
  return new URI(URI.Type.ARTIST_TOPLIST, {id: id, toplist: toplist});
};

/**
 * Creates a new 'search' type URI.
 *
 * @param {string} query The unencoded search query.
 * @return {URI} The search URI
 */
URI.searchURI = function(query) {
  return new URI(URI.Type.SEARCH, {query: query});
};

/**
 * Creates a new 'track' type URI.
 *
 * @param {string} id The id of the track.
 * @param {string} anchor The point in the track formatted as mm:ss
 * @return {URI} The track URI.
 */
URI.trackURI = function(id, anchor) {
  return new URI(URI.Type.TRACK, {id: id, anchor: anchor});
};

/**
 * Creates a new 'trackset' type URI.
 *
 * @param {Array.<URI>} tracks An array of 'track' type URIs.
 * @param {string} name The name of the trackset.
 * @param {number} index The index in the trackset.
 * @return {URI} The trackset URI.
 */
URI.tracksetURI = function(tracks, name, index) {
  return new URI(URI.Type.TRACKSET, {
    tracks: tracks,
    name: name || '',
    index: isNaN(index) ? null : index
  });
};

/**
 * Creates a new 'facebook' type URI.
 *
 * @param {string} uid The user id.
 * @return {URI} The facebook URI.
 */
URI.facebookURI = function(uid) {
  return new URI(URI.Type.FACEBOOK, {uid: uid});
};

/**
 * Creates a new 'followers' type URI.
 *
 * @param {string} username The non-canonical username.
 * @return {URI} The followers URI.
 */
URI.followersURI = function(username) {
  return new URI(URI.Type.FOLLOWERS, {username: username});
};

/**
 * Creates a new 'following' type URI.
 *
 * @param {string} username The non-canonical username.
 * @return {URI} The following URI.
 */
URI.followingURI = function(username) {
  return new URI(URI.Type.FOLLOWING, {username: username});
};

/**
 * Creates a new 'playlist' type URI.
 *
 * @param {string} username The non-canonical username of the playlist owner.
 * @param {string} id The id of the playlist.
 * @return {URI} The playlist URI.
 */
URI.playlistURI = function(username, id) {
  return new URI(URI.Type.PLAYLIST, {username: username, id: id});
};

/**
 * Creates a new 'folder' type URI.
 *
 * @param {string} username The non-canonical username of the folder owner.
 * @param {string} id The id of the folder.
 * @return {URI} The folder URI.
 */
URI.folderURI = function(username, id) {
  return new URI(URI.Type.FOLDER, {username: username, id: id});
};

/**
 * Creates a new 'collectiontracklist' type URI.
 *
 * @param {string} username The non-canonical username of the collection owner.
 * @param {string} id The id of the tracklist.
 * @return {URI} The collectiontracklist URI.
 */
URI.collectionTrackList = function(username, id) {
  return new URI(URI.Type.COLLECTION_TRACK_LIST, {username: username, id: id});
};

/**
 * Creates a new 'starred' type URI.
 *
 * @param {string} username The non-canonical username of the starred list owner.
 * @return {URI} The starred URI.
 */
URI.starredURI = function(username) {
  return new URI(URI.Type.STARRED, {username: username});
};

/**
 * Creates a new 'user-toplist' type URI.
 *
 * @param {string} username The non-canonical username of the toplist owner.
 * @param {string} toplist The toplist type.
 * @return {URI} The user-toplist URI.
 */
URI.userToplistURI = function(username, toplist) {
  return new URI(URI.Type.USER_TOPLIST, {username: username, toplist: toplist});
};

/**
 * Creates a new 'user-top-tracks' type URI.
 *
 * @deprecated
 * @param {string} username The non-canonical username of the toplist owner.
 * @return {URI} The user-top-tracks URI.
 */
URI.userTopTracksURI = function(username) {
  return new URI(URI.Type.USER_TOP_TRACKS, {username: username});
};

/**
 * Creates a new 'toplist' type URI.
 *
 * @param {string} toplist The toplist type.
 * @param {string} country The country code for the toplist.
 * @param {boolean} global True if this is a global rather than a country list.
 * @return {URI} The toplist URI.
 */
URI.toplistURI = function(toplist, country, global) {
  return new URI(URI.Type.TOPLIST, {toplist: toplist, country: country, global: !!global});
};

/**
 * Creates a new 'inbox' type URI.
 *
 * @param {string} username The non-canonical username of the inbox owner.
 * @return {URI} The inbox URI.
 */
URI.inboxURI = function(username) {
  return new URI(URI.Type.INBOX, {username: username});
};

/**
 * Creates a new 'rootlist' type URI.
 *
 * @param {string} username The non-canonical username of the rootlist owner.
 * @return {URI} The rootlist URI.
 */
URI.rootlistURI = function(username) {
  return new URI(URI.Type.ROOTLIST, {username: username});
};

/**
 * Creates a new 'published-rootlist' type URI.
 *
 * @param {string} username The non-canonical username of the published-rootlist owner.
 * @return {URI} The published-rootlist URI.
 */
URI.publishedRootlistURI = function(username) {
  return new URI(URI.Type.PUBLISHED_ROOTLIST, {username: username});
};

/**
 * Creates a new 'local-artist' type URI.
 *
 * @param {string} artist The artist name.
 * @return {URI} The local-artist URI.
 */
URI.localArtistURI = function(artist) {
  return new URI(URI.Type.LOCAL_ARTIST, {artist: artist});
};

/**
 * Creates a new 'local-album' type URI.
 *
 * @param {string} artist The artist name.
 * @param {string} album The album name.
 * @return {URI} The local-album URI.
 */
URI.localAlbumURI = function(artist, album) {
  return new URI(URI.Type.LOCAL_ALBUM, {artist: artist, album: album});
};

/**
 * Creates a new 'local' type URI.
 *
 * @param {string} artist The artist name.
 * @param {string} album The album name.
 * @param {string} track The track name.
 * @param {number} duration The track duration in ms.
 * @return {URI} The local URI.
 */
URI.localURI = function(artist, album, track, duration) {
  return new URI(URI.Type.LOCAL, {
    artist: artist,
    album: album,
    track: track,
    duration: duration
  });
};

/**
 * Creates a new 'library' type URI.
 *
 * @param {string} username The non-canonical username of the rootlist owner.
 * @param {string} category The category of the library.
 * @return {URI} The library URI.
 */
URI.libraryURI = function(username, category) {
  return new URI(URI.Type.LIBRARY, {username: username, category: category});
};

/**
 * Creates a new 'collection' type URI.
 *
 * @param {string} username The non-canonical username of the rootlist owner.
 * @param {string} category The category of the collection.
 * @return {URI} The collection URI.
 */
URI.collectionURI = function(username, category) {
  return new URI(URI.Type.COLLECTION, {username: username, category: category});
};

/**
 * Creates a new 'temp-playlist' type URI.
 *
 * @param {string} origin The origin of the temporary playlist.
 * @param {string} data Additional data for the playlist.
 * @return {URI} The temp-playlist URI.
 */
URI.temporaryPlaylistURI = function(origin, data) {
  return new URI(URI.Type.TEMP_PLAYLIST, {origin: origin, data: data});
};

/**
 * Creates a new 'context-group' type URI.
 *
 * @deprecated
 * @param {string} origin The origin of the temporary playlist.
 * @param {string} name The name of the context group.
 * @return {URI} The context-group URI.
 */
URI.contextGroupURI = function(origin, name) {
  return new URI(URI.Type.CONTEXT_GROUP, {origin: origin, name: name});
};

/**
 * Creates a new 'profile' type URI.
 *
 * @param {string} username The non-canonical username of the rootlist owner.
 * @param {Array.<string>} args A list of arguments.
 * @return {URI} The profile URI.
 */
URI.profileURI = function(username, args) {
  return new URI(URI.Type.PROFILE, {username: username, args: args});
};

/**
 * Creates a new 'image' type URI.
 *
 * @param {string} id The id of the image.
 * @return {URI} The image URI.
 */
URI.imageURI = function(id) {
  return new URI(URI.Type.IMAGE, {id: id});
};

/**
 * Creates a new 'mosaic' type URI.
 *
 * @param {Array.<string>} ids The ids of the mosaic immages.
 * @return {URI} The mosaic URI.
 */
URI.mosaicURI = function(ids) {
  return new URI(URI.Type.MOSAIC, {ids: ids});
};

/**
 * Creates a new 'radio' type URI.
 *
 * @param {string} args The radio seed arguments.
 * @return {URI} The radio URI.
 */
URI.radioURI = function(args) {
  args = typeof args === 'undefined' ? '' : args;
  return new URI(URI.Type.RADIO, {args: args});
};

/**
 * Creates a new 'special' type URI.
 *
 * @param {Array.<string>} args An array containing the other arguments.
 * @return {URI} The special URI.
 */
URI.specialURI = function(args) {
  args = typeof args === 'undefined' ? [] : args;
  return new URI(URI.Type.SPECIAL, {args: args});
};

/**
 * Creates a new 'station' type URI.
 *
 * @param {Array.<string>} args An array of arguments for the station.
 * @return {URI} The station URI.
 */
URI.stationURI = function(args) {
  args = typeof args === 'undefined' ? [] : args;
  return new URI(URI.Type.STATION, {args: args});
};

/**
 * Creates a new 'application' type URI.
 *
 * @param {string} id The id of the application.
 * @param {Array.<string>} args An array containing the arguments to the app.
 * @return {URI} The application URI.
 */
URI.applicationURI = function(id, args) {
  args = typeof args === 'undefined' ? [] : args;
  return new URI(URI.Type.APPLICATION, {id: id, args: args});
};

/**
 * Creates a new 'collection-album' type URI.
 *
 * @param {string} username The non-canonical username of the rootlist owner.
 * @param {string} id The id of the album.
 * @return {URI} The collection-album URI.
 */
URI.collectionAlbumURI = function(username, id) {
  return new URI(URI.Type.COLLECTION_ALBUM, {username: username, id: id});
};

/**
 * Creates a new 'collection-album-missing' type URI.
 *
 * @param {string} username The non-canonical username of the rootlist owner.
 * @param {string} id The id of the album.
 * @return {URI} The collection-album-missing URI.
 */
URI.collectionMissingAlbumURI = function(username, id) {
  return new URI(URI.Type.COLLECTION_MISSING_ALBUM, {username: username, id: id});
};

/**
 * Creates a new 'collection-artist' type URI.
 *
 * @param {string} username The non-canonical username of the rootlist owner.
 * @param {string} id The id of the artist.
 * @return {URI} The collection-artist URI.
 */
URI.collectionArtistURI = function(username, id) {
  return new URI(URI.Type.COLLECTION_ARTIST, {username: username, id: id});
};

/**
 * Creates a new 'episode' type URI.
 *
 * @param {string} id The id of the episode.
 * @return {URI} The episode URI.
 */
URI.episodeURI = function(id) {
  return new URI(URI.Type.EPISODE, {id: id});
};

/**
 * Export public interface
 */
module.exports = URI;

},{"spotify-crypto/src/base62":237}],243:[function(require,module,exports){
//     Underscore.js 1.8.3
//     http://underscorejs.org
//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `exports` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var
    push             = ArrayProto.push,
    slice            = ArrayProto.slice,
    toString         = ObjProto.toString,
    hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind,
    nativeCreate       = Object.create;

  // Naked function reference for surrogate-prototype-swapping.
  var Ctor = function(){};

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.8.3';

  // Internal function that returns an efficient (for current engines) version
  // of the passed-in callback, to be repeatedly applied in other Underscore
  // functions.
  var optimizeCb = function(func, context, argCount) {
    if (context === void 0) return func;
    switch (argCount == null ? 3 : argCount) {
      case 1: return function(value) {
        return func.call(context, value);
      };
      case 2: return function(value, other) {
        return func.call(context, value, other);
      };
      case 3: return function(value, index, collection) {
        return func.call(context, value, index, collection);
      };
      case 4: return function(accumulator, value, index, collection) {
        return func.call(context, accumulator, value, index, collection);
      };
    }
    return function() {
      return func.apply(context, arguments);
    };
  };

  // A mostly-internal function to generate callbacks that can be applied
  // to each element in a collection, returning the desired result — either
  // identity, an arbitrary callback, a property matcher, or a property accessor.
  var cb = function(value, context, argCount) {
    if (value == null) return _.identity;
    if (_.isFunction(value)) return optimizeCb(value, context, argCount);
    if (_.isObject(value)) return _.matcher(value);
    return _.property(value);
  };
  _.iteratee = function(value, context) {
    return cb(value, context, Infinity);
  };

  // An internal function for creating assigner functions.
  var createAssigner = function(keysFunc, undefinedOnly) {
    return function(obj) {
      var length = arguments.length;
      if (length < 2 || obj == null) return obj;
      for (var index = 1; index < length; index++) {
        var source = arguments[index],
            keys = keysFunc(source),
            l = keys.length;
        for (var i = 0; i < l; i++) {
          var key = keys[i];
          if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];
        }
      }
      return obj;
    };
  };

  // An internal function for creating a new object that inherits from another.
  var baseCreate = function(prototype) {
    if (!_.isObject(prototype)) return {};
    if (nativeCreate) return nativeCreate(prototype);
    Ctor.prototype = prototype;
    var result = new Ctor;
    Ctor.prototype = null;
    return result;
  };

  var property = function(key) {
    return function(obj) {
      return obj == null ? void 0 : obj[key];
    };
  };

  // Helper for collection methods to determine whether a collection
  // should be iterated as an array or as an object
  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
  var getLength = property('length');
  var isArrayLike = function(collection) {
    var length = getLength(collection);
    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
  };

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles raw objects in addition to array-likes. Treats all
  // sparse array-likes as if they were dense.
  _.each = _.forEach = function(obj, iteratee, context) {
    iteratee = optimizeCb(iteratee, context);
    var i, length;
    if (isArrayLike(obj)) {
      for (i = 0, length = obj.length; i < length; i++) {
        iteratee(obj[i], i, obj);
      }
    } else {
      var keys = _.keys(obj);
      for (i = 0, length = keys.length; i < length; i++) {
        iteratee(obj[keys[i]], keys[i], obj);
      }
    }
    return obj;
  };

  // Return the results of applying the iteratee to each element.
  _.map = _.collect = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length,
        results = Array(length);
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      results[index] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
  };

  // Create a reducing function iterating left or right.
  function createReduce(dir) {
    // Optimized iterator function as using arguments.length
    // in the main function will deoptimize the, see #1991.
    function iterator(obj, iteratee, memo, keys, index, length) {
      for (; index >= 0 && index < length; index += dir) {
        var currentKey = keys ? keys[index] : index;
        memo = iteratee(memo, obj[currentKey], currentKey, obj);
      }
      return memo;
    }

    return function(obj, iteratee, memo, context) {
      iteratee = optimizeCb(iteratee, context, 4);
      var keys = !isArrayLike(obj) && _.keys(obj),
          length = (keys || obj).length,
          index = dir > 0 ? 0 : length - 1;
      // Determine the initial value if none is provided.
      if (arguments.length < 3) {
        memo = obj[keys ? keys[index] : index];
        index += dir;
      }
      return iterator(obj, iteratee, memo, keys, index, length);
    };
  }

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`.
  _.reduce = _.foldl = _.inject = createReduce(1);

  // The right-associative version of reduce, also known as `foldr`.
  _.reduceRight = _.foldr = createReduce(-1);

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, predicate, context) {
    var key;
    if (isArrayLike(obj)) {
      key = _.findIndex(obj, predicate, context);
    } else {
      key = _.findKey(obj, predicate, context);
    }
    if (key !== void 0 && key !== -1) return obj[key];
  };

  // Return all the elements that pass a truth test.
  // Aliased as `select`.
  _.filter = _.select = function(obj, predicate, context) {
    var results = [];
    predicate = cb(predicate, context);
    _.each(obj, function(value, index, list) {
      if (predicate(value, index, list)) results.push(value);
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, predicate, context) {
    return _.filter(obj, _.negate(cb(predicate)), context);
  };

  // Determine whether all of the elements match a truth test.
  // Aliased as `all`.
  _.every = _.all = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (!predicate(obj[currentKey], currentKey, obj)) return false;
    }
    return true;
  };

  // Determine if at least one element in the object matches a truth test.
  // Aliased as `any`.
  _.some = _.any = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (predicate(obj[currentKey], currentKey, obj)) return true;
    }
    return false;
  };

  // Determine if the array or object contains a given item (using `===`).
  // Aliased as `includes` and `include`.
  _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {
    if (!isArrayLike(obj)) obj = _.values(obj);
    if (typeof fromIndex != 'number' || guard) fromIndex = 0;
    return _.indexOf(obj, item, fromIndex) >= 0;
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function(value) {
      var func = isFunc ? method : value[method];
      return func == null ? func : func.apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, _.property(key));
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs) {
    return _.filter(obj, _.matcher(attrs));
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.find(obj, _.matcher(attrs));
  };

  // Return the maximum element (or element-based computation).
  _.max = function(obj, iteratee, context) {
    var result = -Infinity, lastComputed = -Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value > result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iteratee, context) {
    var result = Infinity, lastComputed = Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value < result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed < lastComputed || computed === Infinity && result === Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Shuffle a collection, using the modern version of the
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
  _.shuffle = function(obj) {
    var set = isArrayLike(obj) ? obj : _.values(obj);
    var length = set.length;
    var shuffled = Array(length);
    for (var index = 0, rand; index < length; index++) {
      rand = _.random(0, index);
      if (rand !== index) shuffled[index] = shuffled[rand];
      shuffled[rand] = set[index];
    }
    return shuffled;
  };

  // Sample **n** random values from a collection.
  // If **n** is not specified, returns a single random element.
  // The internal `guard` argument allows it to work with `map`.
  _.sample = function(obj, n, guard) {
    if (n == null || guard) {
      if (!isArrayLike(obj)) obj = _.values(obj);
      return obj[_.random(obj.length - 1)];
    }
    return _.shuffle(obj).slice(0, Math.max(0, n));
  };

  // Sort the object's values by a criterion produced by an iteratee.
  _.sortBy = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value: value,
        index: index,
        criteria: iteratee(value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index - right.index;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(behavior) {
    return function(obj, iteratee, context) {
      var result = {};
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index) {
        var key = iteratee(value, index, obj);
        behavior(result, value, key);
      });
      return result;
    };
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key].push(value); else result[key] = [value];
  });

  // Indexes the object's values by a criterion, similar to `groupBy`, but for
  // when you know that your index values will be unique.
  _.indexBy = group(function(result, value, key) {
    result[key] = value;
  });

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key]++; else result[key] = 1;
  });

  // Safely create a real, live array from anything iterable.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (isArrayLike(obj)) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return isArrayLike(obj) ? obj.length : _.keys(obj).length;
  };

  // Split a collection into two arrays: one whose elements all satisfy the given
  // predicate, and one whose elements all do not satisfy the predicate.
  _.partition = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var pass = [], fail = [];
    _.each(obj, function(value, key, obj) {
      (predicate(value, key, obj) ? pass : fail).push(value);
    });
    return [pass, fail];
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[0];
    return _.initial(array, array.length - n);
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array.
  _.last = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[array.length - 1];
    return _.rest(array, Math.max(0, array.length - n));
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, n == null || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, _.identity);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, strict, startIndex) {
    var output = [], idx = 0;
    for (var i = startIndex || 0, length = getLength(input); i < length; i++) {
      var value = input[i];
      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
        //flatten current level of array or arguments object
        if (!shallow) value = flatten(value, shallow, strict);
        var j = 0, len = value.length;
        output.length += len;
        while (j < len) {
          output[idx++] = value[j++];
        }
      } else if (!strict) {
        output[idx++] = value;
      }
    }
    return output;
  };

  // Flatten out an array, either recursively (by default), or just one level.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, false);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iteratee, context) {
    if (!_.isBoolean(isSorted)) {
      context = iteratee;
      iteratee = isSorted;
      isSorted = false;
    }
    if (iteratee != null) iteratee = cb(iteratee, context);
    var result = [];
    var seen = [];
    for (var i = 0, length = getLength(array); i < length; i++) {
      var value = array[i],
          computed = iteratee ? iteratee(value, i, array) : value;
      if (isSorted) {
        if (!i || seen !== computed) result.push(value);
        seen = computed;
      } else if (iteratee) {
        if (!_.contains(seen, computed)) {
          seen.push(computed);
          result.push(value);
        }
      } else if (!_.contains(result, value)) {
        result.push(value);
      }
    }
    return result;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(flatten(arguments, true, true));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    var result = [];
    var argsLength = arguments.length;
    for (var i = 0, length = getLength(array); i < length; i++) {
      var item = array[i];
      if (_.contains(result, item)) continue;
      for (var j = 1; j < argsLength; j++) {
        if (!_.contains(arguments[j], item)) break;
      }
      if (j === argsLength) result.push(item);
    }
    return result;
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = flatten(arguments, true, true, 1);
    return _.filter(array, function(value){
      return !_.contains(rest, value);
    });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    return _.unzip(arguments);
  };

  // Complement of _.zip. Unzip accepts an array of arrays and groups
  // each array's elements on shared indices
  _.unzip = function(array) {
    var length = array && _.max(array, getLength).length || 0;
    var result = Array(length);

    for (var index = 0; index < length; index++) {
      result[index] = _.pluck(array, index);
    }
    return result;
  };

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values.
  _.object = function(list, values) {
    var result = {};
    for (var i = 0, length = getLength(list); i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // Generator function to create the findIndex and findLastIndex functions
  function createPredicateIndexFinder(dir) {
    return function(array, predicate, context) {
      predicate = cb(predicate, context);
      var length = getLength(array);
      var index = dir > 0 ? 0 : length - 1;
      for (; index >= 0 && index < length; index += dir) {
        if (predicate(array[index], index, array)) return index;
      }
      return -1;
    };
  }

  // Returns the first index on an array-like that passes a predicate test
  _.findIndex = createPredicateIndexFinder(1);
  _.findLastIndex = createPredicateIndexFinder(-1);

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iteratee, context) {
    iteratee = cb(iteratee, context, 1);
    var value = iteratee(obj);
    var low = 0, high = getLength(array);
    while (low < high) {
      var mid = Math.floor((low + high) / 2);
      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
    }
    return low;
  };

  // Generator function to create the indexOf and lastIndexOf functions
  function createIndexFinder(dir, predicateFind, sortedIndex) {
    return function(array, item, idx) {
      var i = 0, length = getLength(array);
      if (typeof idx == 'number') {
        if (dir > 0) {
            i = idx >= 0 ? idx : Math.max(idx + length, i);
        } else {
            length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
        }
      } else if (sortedIndex && idx && length) {
        idx = sortedIndex(array, item);
        return array[idx] === item ? idx : -1;
      }
      if (item !== item) {
        idx = predicateFind(slice.call(array, i, length), _.isNaN);
        return idx >= 0 ? idx + i : -1;
      }
      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
        if (array[idx] === item) return idx;
      }
      return -1;
    };
  }

  // Return the position of the first occurrence of an item in an array,
  // or -1 if the item is not included in the array.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (stop == null) {
      stop = start || 0;
      start = 0;
    }
    step = step || 1;

    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var range = Array(length);

    for (var idx = 0; idx < length; idx++, start += step) {
      range[idx] = start;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Determines whether to execute a function as a constructor
  // or a normal function with the provided arguments
  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
    var self = baseCreate(sourceFunc.prototype);
    var result = sourceFunc.apply(self, args);
    if (_.isObject(result)) return result;
    return self;
  };

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = function(func, context) {
    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
    var args = slice.call(arguments, 2);
    var bound = function() {
      return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));
    };
    return bound;
  };

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context. _ acts
  // as a placeholder, allowing any combination of arguments to be pre-filled.
  _.partial = function(func) {
    var boundArgs = slice.call(arguments, 1);
    var bound = function() {
      var position = 0, length = boundArgs.length;
      var args = Array(length);
      for (var i = 0; i < length; i++) {
        args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];
      }
      while (position < arguments.length) args.push(arguments[position++]);
      return executeBound(func, bound, this, this, args);
    };
    return bound;
  };

  // Bind a number of an object's methods to that object. Remaining arguments
  // are the method names to be bound. Useful for ensuring that all callbacks
  // defined on an object belong to it.
  _.bindAll = function(obj) {
    var i, length = arguments.length, key;
    if (length <= 1) throw new Error('bindAll must be passed function names');
    for (i = 1; i < length; i++) {
      key = arguments[i];
      obj[key] = _.bind(obj[key], obj);
    }
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memoize = function(key) {
      var cache = memoize.cache;
      var address = '' + (hasher ? hasher.apply(this, arguments) : key);
      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);
      return cache[address];
    };
    memoize.cache = {};
    return memoize;
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){
      return func.apply(null, args);
    }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = _.partial(_.delay, _, 1);

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  _.throttle = function(func, wait, options) {
    var context, args, result;
    var timeout = null;
    var previous = 0;
    if (!options) options = {};
    var later = function() {
      previous = options.leading === false ? 0 : _.now();
      timeout = null;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    };
    return function() {
      var now = _.now();
      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0 || remaining > wait) {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }
        previous = now;
        result = func.apply(context, args);
        if (!timeout) context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, args, context, timestamp, result;

    var later = function() {
      var last = _.now() - timestamp;

      if (last < wait && last >= 0) {
        timeout = setTimeout(later, wait - last);
      } else {
        timeout = null;
        if (!immediate) {
          result = func.apply(context, args);
          if (!timeout) context = args = null;
        }
      }
    };

    return function() {
      context = this;
      args = arguments;
      timestamp = _.now();
      var callNow = immediate && !timeout;
      if (!timeout) timeout = setTimeout(later, wait);
      if (callNow) {
        result = func.apply(context, args);
        context = args = null;
      }

      return result;
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return _.partial(wrapper, func);
  };

  // Returns a negated version of the passed-in predicate.
  _.negate = function(predicate) {
    return function() {
      return !predicate.apply(this, arguments);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var args = arguments;
    var start = args.length - 1;
    return function() {
      var i = start;
      var result = args[start].apply(this, arguments);
      while (i--) result = args[i].call(this, result);
      return result;
    };
  };

  // Returns a function that will only be executed on and after the Nth call.
  _.after = function(times, func) {
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Returns a function that will only be executed up to (but not including) the Nth call.
  _.before = function(times, func) {
    var memo;
    return function() {
      if (--times > 0) {
        memo = func.apply(this, arguments);
      }
      if (times <= 1) func = null;
      return memo;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = _.partial(_.before, 2);

  // Object Functions
  // ----------------

  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
                      'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

  function collectNonEnumProps(obj, keys) {
    var nonEnumIdx = nonEnumerableProps.length;
    var constructor = obj.constructor;
    var proto = (_.isFunction(constructor) && constructor.prototype) || ObjProto;

    // Constructor is a special case.
    var prop = 'constructor';
    if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);

    while (nonEnumIdx--) {
      prop = nonEnumerableProps[nonEnumIdx];
      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
        keys.push(prop);
      }
    }
  }

  // Retrieve the names of an object's own properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = function(obj) {
    if (!_.isObject(obj)) return [];
    if (nativeKeys) return nativeKeys(obj);
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve all the property names of an object.
  _.allKeys = function(obj) {
    if (!_.isObject(obj)) return [];
    var keys = [];
    for (var key in obj) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };

  // Returns the results of applying the iteratee to each element of the object
  // In contrast to _.map it returns an object
  _.mapObject = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys =  _.keys(obj),
          length = keys.length,
          results = {},
          currentKey;
      for (var index = 0; index < length; index++) {
        currentKey = keys[index];
        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
      }
      return results;
  };

  // Convert an object into a list of `[key, value]` pairs.
  _.pairs = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [keys[i], obj[keys[i]]];
    }
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = createAssigner(_.allKeys);

  // Assigns a given object with all the own properties in the passed-in object(s)
  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
  _.extendOwn = _.assign = createAssigner(_.keys);

  // Returns the first key on an object that passes a predicate test
  _.findKey = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = _.keys(obj), key;
    for (var i = 0, length = keys.length; i < length; i++) {
      key = keys[i];
      if (predicate(obj[key], key, obj)) return key;
    }
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(object, oiteratee, context) {
    var result = {}, obj = object, iteratee, keys;
    if (obj == null) return result;
    if (_.isFunction(oiteratee)) {
      keys = _.allKeys(obj);
      iteratee = optimizeCb(oiteratee, context);
    } else {
      keys = flatten(arguments, false, false, 1);
      iteratee = function(value, key, obj) { return key in obj; };
      obj = Object(obj);
    }
    for (var i = 0, length = keys.length; i < length; i++) {
      var key = keys[i];
      var value = obj[key];
      if (iteratee(value, key, obj)) result[key] = value;
    }
    return result;
  };

   // Return a copy of the object without the blacklisted properties.
  _.omit = function(obj, iteratee, context) {
    if (_.isFunction(iteratee)) {
      iteratee = _.negate(iteratee);
    } else {
      var keys = _.map(flatten(arguments, false, false, 1), String);
      iteratee = function(value, key) {
        return !_.contains(keys, key);
      };
    }
    return _.pick(obj, iteratee, context);
  };

  // Fill in a given object with default properties.
  _.defaults = createAssigner(_.allKeys, true);

  // Creates an object that inherits from the given prototype object.
  // If additional properties are provided then they will be added to the
  // created object.
  _.create = function(prototype, props) {
    var result = baseCreate(prototype);
    if (props) _.extendOwn(result, props);
    return result;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Returns whether an object has a given set of `key:value` pairs.
  _.isMatch = function(object, attrs) {
    var keys = _.keys(attrs), length = keys.length;
    if (object == null) return !length;
    var obj = Object(object);
    for (var i = 0; i < length; i++) {
      var key = keys[i];
      if (attrs[key] !== obj[key] || !(key in obj)) return false;
    }
    return true;
  };


  // Internal recursive comparison function for `isEqual`.
  var eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a === 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className !== toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
      case '[object RegExp]':
      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return '' + a === '' + b;
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive.
        // Object(NaN) is equivalent to NaN
        if (+a !== +a) return +b !== +b;
        // An `egal` comparison is performed for other numeric values.
        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a === +b;
    }

    var areArrays = className === '[object Array]';
    if (!areArrays) {
      if (typeof a != 'object' || typeof b != 'object') return false;

      // Objects with different constructors are not equivalent, but `Object`s or `Array`s
      // from different frames are.
      var aCtor = a.constructor, bCtor = b.constructor;
      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
                               _.isFunction(bCtor) && bCtor instanceof bCtor)
                          && ('constructor' in a && 'constructor' in b)) {
        return false;
      }
    }
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

    // Initializing stack of traversed objects.
    // It's done here since we only need them for objects and arrays comparison.
    aStack = aStack || [];
    bStack = bStack || [];
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] === a) return bStack[length] === b;
    }

    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);

    // Recursively compare objects and arrays.
    if (areArrays) {
      // Compare array lengths to determine if a deep comparison is necessary.
      length = a.length;
      if (length !== b.length) return false;
      // Deep compare the contents, ignoring non-numeric properties.
      while (length--) {
        if (!eq(a[length], b[length], aStack, bStack)) return false;
      }
    } else {
      // Deep compare objects.
      var keys = _.keys(a), key;
      length = keys.length;
      // Ensure that both objects contain the same number of properties before comparing deep equality.
      if (_.keys(b).length !== length) return false;
      while (length--) {
        // Deep compare each member
        key = keys[length];
        if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return true;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
    return _.keys(obj).length === 0;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) === '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    var type = typeof obj;
    return type === 'function' || type === 'object' && !!obj;
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.
  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) === '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE < 9), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return _.has(obj, 'callee');
    };
  }

  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
  // IE 11 (#1621), and in Safari 8 (#1929).
  if (typeof /./ != 'function' && typeof Int8Array != 'object') {
    _.isFunction = function(obj) {
      return typeof obj == 'function' || false;
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
  _.isNaN = function(obj) {
    return _.isNumber(obj) && obj !== +obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, key) {
    return obj != null && hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iteratees.
  _.identity = function(value) {
    return value;
  };

  // Predicate-generating functions. Often useful outside of Underscore.
  _.constant = function(value) {
    return function() {
      return value;
    };
  };

  _.noop = function(){};

  _.property = property;

  // Generates a function for a given object that returns a given property.
  _.propertyOf = function(obj) {
    return obj == null ? function(){} : function(key) {
      return obj[key];
    };
  };

  // Returns a predicate for checking whether an object has a given set of
  // `key:value` pairs.
  _.matcher = _.matches = function(attrs) {
    attrs = _.extendOwn({}, attrs);
    return function(obj) {
      return _.isMatch(obj, attrs);
    };
  };

  // Run a function **n** times.
  _.times = function(n, iteratee, context) {
    var accum = Array(Math.max(0, n));
    iteratee = optimizeCb(iteratee, context, 1);
    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // A (possibly faster) way to get the current timestamp as an integer.
  _.now = Date.now || function() {
    return new Date().getTime();
  };

   // List of HTML entities for escaping.
  var escapeMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#x27;',
    '`': '&#x60;'
  };
  var unescapeMap = _.invert(escapeMap);

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  var createEscaper = function(map) {
    var escaper = function(match) {
      return map[match];
    };
    // Regexes for identifying a key that needs to be escaped
    var source = '(?:' + _.keys(map).join('|') + ')';
    var testRegexp = RegExp(source);
    var replaceRegexp = RegExp(source, 'g');
    return function(string) {
      string = string == null ? '' : '' + string;
      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
    };
  };
  _.escape = createEscaper(escapeMap);
  _.unescape = createEscaper(unescapeMap);

  // If the value of the named `property` is a function then invoke it with the
  // `object` as context; otherwise, return it.
  _.result = function(object, property, fallback) {
    var value = object == null ? void 0 : object[property];
    if (value === void 0) {
      value = fallback;
    }
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'":      "'",
    '\\':     '\\',
    '\r':     'r',
    '\n':     'n',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escaper = /\\|'|\r|\n|\u2028|\u2029/g;

  var escapeChar = function(match) {
    return '\\' + escapes[match];
  };

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  // NB: `oldSettings` only exists for backwards compatibility.
  _.template = function(text, settings, oldSettings) {
    if (!settings && oldSettings) settings = oldSettings;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset).replace(escaper, escapeChar);
      index = offset + match.length;

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      } else if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      } else if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }

      // Adobe VMs need the match returned to produce the correct offest.
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + 'return __p;\n';

    try {
      var render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled source as a convenience for precompilation.
    var argument = settings.variable || 'obj';
    template.source = 'function(' + argument + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function. Start chaining a wrapped Underscore object.
  _.chain = function(obj) {
    var instance = _(obj);
    instance._chain = true;
    return instance;
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var result = function(instance, obj) {
    return instance._chain ? _(obj).chain() : obj;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    _.each(_.functions(obj), function(name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result(this, func.apply(_, args));
      };
    });
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
      return result(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  _.each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return result(this, method.apply(this._wrapped, arguments));
    };
  });

  // Extracts the result from a wrapped and chained object.
  _.prototype.value = function() {
    return this._wrapped;
  };

  // Provide unwrapping proxy for some methods used in engine operations
  // such as arithmetic and JSON stringification.
  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;

  _.prototype.toString = function() {
    return '' + this._wrapped;
  };

  // AMD registration happens at the end for compatibility with AMD loaders
  // that may not enforce next-turn semantics on modules. Even though general
  // practice for AMD registration is to be anonymous, underscore registers
  // as a named module because, like jQuery, it is a base library that is
  // popular enough to be bundled in a third party lib, but not be part of
  // an AMD load request. Those cases could generate an error when an
  // anonymous define() is called outside of a loader request.
  if (typeof define === 'function' && define.amd) {
    define('underscore', [], function() {
      return _;
    });
  }
}.call(this));

},{}]},{},[24]);
