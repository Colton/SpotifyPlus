(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
module.exports = {
  "sNotificationTitleAlbumReleased": "Album veröffentlicht",
  "sNotificationBodyAlbumReleased": "{0} von {1} ist jetzt auf Spotify verfügbar.",
  "sNotificationBodyExclusiveAlbumReleased": "Exklusive Veröffentlichung:<br> {0} von {1} ist ab sofort nur auf Spotify verfügbar.",
  "sNotificationTitleApplicationRelease": "Aktualisierung",
  "sNotificationBodyApplicationReleaseAndroid": "Eine neue Version von Spotify für Android ist jetzt verfügbar.",
  "sNotificationBodyApplicationReleaseIOS": "Eine neue Version von Spotify für iOS ist jetzt verfügbar.",
  "sNotificationBodyApplicationReleaseLink": "Du kannst Spotify jetzt in deinem Webbrowser benutzen.",
  "sNotificationBodyApplicationReleaseMftLaunch": "Spotify ist jetzt gratis für Handys und Tablets verfügbar!",
  "sNotificationBodyApplicationReleaseMftReminder": "Nicht verpassen: Spotify ist jetzt überall kostenlos. Jetzt auf iPhone, iPad und Android-Gerät installieren.",
  "sNotificationBodyApplicationReleaseMftSeason": "Neues iPhone, iPad oder Android-Gerät? Finde heraus, wie Du kostenlos Musik hören kannst.",
  "sNotificationTitleFriendJoined": "Ein Freund benutzt jetzt Spotify",
  "sNotificationBodyFriendJoined": "Dein Freund {0} benutzt jetzt auch Spotify.",
  "sNotificationBodyMultipleAlbumsReleased": "{0} und {2} weitere Alben von {1} sind jetzt auf Spotify verfügbar.",
  "sNotificationBodyMultipleAlbumsReleasedSingular": "{0} und 1 weiteres Album von {1} sind jetzt auf Spotify verfügbar.",
  "sNotificationBodyMultipleExclusiveAlbumsReleased": "Exklusive Veröffentlichung: {0} und {2} weitere Alben von {1} sind ab sofort nur auf Spotify verfügbar.",
  "sNotificationBodyMultipleExclusiveAlbumsReleasedSingular": "Exklusive Veröffentlichung:<br> {0} und 1 weiteres Album von {1} sind jetzt exklusiv auf Spotify verfügbar.",
  "sNotificationTitleMessagePlayed": "Abgespielter Anhang",
  "sNotificationBodyMessagePlayed": "{0} hat den von dir gesendeten Anhang abgepielt.",
  "sNotificationTitleNewFollower": "Neuer Follower",
  "sNotificationBodyNewFollower": "{0} folgt dir jetzt.",
  "sNotificationTitlePlaylistSubscribe": "Neuer Follower für die Playlist",
  "sNotificationBodyPlaylistSubscribe": "{0} folgt jetzt deiner Playlist: {1}.",
  "sNotificationTitlePlaylistUpdated": "Playlist aktualisiert",
  "sNotificationBodyPlaylistUpdatedPlural": "{0} fügte {2} Songs zu {1} hinzu.",
  "sNotificationBodyPlaylistUpdatedSingular": "{0} fügte einen Songs zu {1} hinzu.",
  "sNotificationBodyToplistSubscribe": "{0} folgt jetzt Deinen Top-Songs.",
  "sNotificationBodyToplistUpdatedName": "Top-Songs",
  "sNotificationTitleSocialReactionPlay": "Neu abgespielt",
  "sNotificationBodySocialReactionPlaySongShare": "{0} hat den Song, den du geteilt hast, gehört: {2} von {1}.",
  "sNotificationBodySocialReactionPlayAlbumShare": "{0} hat das Album, das du geteilt hast, gehört: {2} by {1}.",
  "sNotificationBodySocialReactionPlayArtistShare": "{0} hat den Künstler, den du geteilt hast, gehört: {1}.",
  "sNotificationBodySocialReactionPlayPlaylistShare": "{0} hat die Playlist, die du geteilt hast, gehört: {1}.",
  "sNotificationBodySocialReactionPlaySongSocialStory": "{0} hat {2} von {1} aus deiner Aktivität gehört.",
  "sNotificationBodySocialReactionPlayAlbumSocialStory": "{0} hat {2} von {1} aus deiner Aktivität gehört.",
  "sNotificationBodySocialReactionPlayArtistSocialStory": "{0} hat {1} aus deiner Aktivität gehört.",
  "sNotificationBodySocialReactionPlayPlaylistSocialStory": "{0} hat eine Playlist aus deiner Aktivität gehört: {1}.",
  "sNotificationTitleSocialReactionLike": "Neu und gefällt",
  "sNotificationBodySocialReactionLikeSongShare": "{0} hat den Song gemocht, den du geteilt hast: {2} von {1}.",
  "sNotificationBodySocialReactionLikeAlbumShare": "{0} hat das Album gemocht, das du geteilt hast: {2} von {1}.",
  "sNotificationBodySocialReactionLikeArtistShare": "{0} hat den Künstler gemocht, den du geteilt hast: {1}.",
  "sNotificationBodySocialReactionLikePlaylistShare": "{0} hat die Playlist gemocht, die du geteilt hast: {1}.",
  "sNotificationBodySocialReactionLikeSongSocialStory": "{0} hat {2} von {1} aus deiner Aktivität gemocht.",
  "sNotificationBodySocialReactionLikeAlbumSocialStory": "{0} hat {2} von {1} aus deiner Aktivität gemocht.",
  "sNotificationBodySocialReactionLikeArtistSocialStory": "{0} hat {1} aus deiner Aktivität gemocht.",
  "sNotificationBodySocialReactionLikePlaylistSocialStory": "{0} hat eine Playlist aus deiner Aktivität gemocht: {1}",
  "sClearAllButton": "Alle entfernen.",
  "sLoadError": "Leider konnten deine Benachrichtigungen gerade nicht geladen werden.",
  "sNoMoreMessage": "Du hast keine Nachrichten.",
  "sTitle": "Benachrichtigungen",
  "s1Hour": "Vor etwa 1 Stunde",
  "s1Minute": "Vor etwa 1 Minute",
  "sDaysAgo": "Vor {0} Tagen",
  "sHoursAgo": "Vor {0} Stunden",
  "sJustNow": "Gerade eben",
  "sMinutesAgo": "Vor {0} Minuten",
  "sOverAYear": "Vor über einem Jahr",
  "sSecondsAgo": "Vor {0} Sekunden",
  "sYesterday": "Gestern",
  "ListTwo": " {0} und {1}",
  "ListStart": " {0}, {1} ",
  "ListMiddle": " {0}, {1} ",
  "ListEnd": " {0} und {1} "
};
},{}],2:[function(require,module,exports){
module.exports = {
  "sNotificationTitleAlbumReleased": "Άλμπουμ που κυκλοφόρησε",
  "sNotificationBodyAlbumReleased": "Το {0} από {1} είναι πλέον διαθέσιμο στο Spotify.",
  "sNotificationBodyExclusiveAlbumReleased": "Αποκλειστική κυκλοφορία:<br>Το {0} από {1} είναι τώρα διαθέσιμο αποκλειστικά στο Spotify.",
  "sNotificationTitleApplicationRelease": "Ενημέρωση",
  "sNotificationBodyApplicationReleaseAndroid": "Μια νέα έκδοση του Spotify για Android είναι πλέον διαθέσιμη.",
  "sNotificationBodyApplicationReleaseIOS": "Μια νέα έκδοση του Spotify για iOS είναι πλέον διαθέσιμη.",
  "sNotificationBodyApplicationReleaseLink": "Μπορείς πλέον να χρησιμοποιείς το Spotify στο πρόγραμμα περιήγησης web που διαθέτεις.",
  "sNotificationBodyApplicationReleaseMftLaunch": "Τώρα το Spotify είναι δωρεάν για κινητό και tablet!",
  "sNotificationBodyApplicationReleaseMftReminder": "Μην το χάσεις - το Spotify είναι τώρα δωρεάν παντού. Εγκατάστησέ το τώρα σε iPhone, iPad και Android.",
  "sNotificationBodyApplicationReleaseMftSeason": "Έχεις καινούργιο iPhone, iPad ή Android; Μάθε πώς μπορείς να ακούς μουσική δωρεάν.",
  "sNotificationTitleFriendJoined": "Εντάχθηκε φίλος",
  "sNotificationBodyFriendJoined": "Ο φίλος/Η φίλη σου {0} μόλις έγινε μέλος του Spotify.",
  "sNotificationBodyMultipleAlbumsReleased": "Το {0} και {2} άλλα άλμπουμ από {1} είναι πλέον διαθέσιμα στο Spotify.",
  "sNotificationBodyMultipleAlbumsReleasedSingular": "Το {0} και άλλο 1 άλμπουμ από {1} είναι πλέον διαθέσιμα στο Spotify.",
  "sNotificationBodyMultipleExclusiveAlbumsReleased": "Αποκλειστική κυκλοφορία:<br>Το {0} και άλλα {2} άλμπουμ από {1} είναι τώρα διαθέσιμα αποκλειστικά στο Spotify.",
  "sNotificationBodyMultipleExclusiveAlbumsReleasedSingular": "Αποκλειστική κυκλοφορία:<br>Το {0} και άλλο 1 άλμπουμ από {1} είναι τώρα διαθέσιμα αποκλειστικά στο Spotify.",
  "sNotificationTitleMessagePlayed": "Έγινε αναπαραγωγή του συνημμένου",
  "sNotificationBodyMessagePlayed": "Ο/Η {0} άκουσε το συνημμένο που έστειλες.",
  "sNotificationTitleNewFollower": "Νέος οπαδός",
  "sNotificationBodyNewFollower": "Ο/Η {0} άρχισε να σε ακολουθεί.",
  "sNotificationTitlePlaylistSubscribe": "Νέος οπαδός λίστας",
  "sNotificationBodyPlaylistSubscribe": "Ο/Η {0} ακολουθεί πλέον τη λίστα σου {1}.",
  "sNotificationTitlePlaylistUpdated": "Η λίστα ενημερώθηκε",
  "sNotificationBodyPlaylistUpdatedPlural": "Ο χρήστης {0} πρόσθεσε {2} τραγούδια στο {1}.",
  "sNotificationBodyPlaylistUpdatedSingular": "Ο χρήστης {0} πρόσθεσε ένα τραγούδι στο {1}.",
  "sNotificationBodyToplistSubscribe": "Ο χρήστης {0} ακολουθεί πλέον τα κορυφαία σου τραγούδια.",
  "sNotificationBodyToplistUpdatedName": "Κορυφαία τραγούδια",
  "sNotificationTitleSocialReactionPlay": "Νέα αναπαραγωγή",
  "sNotificationBodySocialReactionPlaySongShare": "Ο χρήστης {0} άκουσε το τραγούδι που κοινοποίησες: {2} από {1}.",
  "sNotificationBodySocialReactionPlayAlbumShare": "Ο χρήστης {0} άκουσε το άλμπουμ που κοινοποίησες: {2} από {1}.",
  "sNotificationBodySocialReactionPlayArtistShare": "Ο χρήστης {0} άκουσε τον καλλιτέχνη που κοινοποίησες: {1}.",
  "sNotificationBodySocialReactionPlayPlaylistShare": "Ο χρήστης {0} άκουσε τη λίστα που κοινοποίησες: {1}.",
  "sNotificationBodySocialReactionPlaySongSocialStory": "Ο χρήστης {0} άκουσε το {2} από {1} από τη δραστηριότητά σου.",
  "sNotificationBodySocialReactionPlayAlbumSocialStory": "Ο χρήστης {0} άκουσε το {2} από {1} από τη δραστηριότητά σου.",
  "sNotificationBodySocialReactionPlayArtistSocialStory": "Ο χρήστης {0} άκουσε το {1} από τη δραστηριότητά σου.",
  "sNotificationBodySocialReactionPlayPlaylistSocialStory": "Ο χρήστης {0} άκουσε μια λίστα από τη δραστηριότητά σου: {1}.",
  "sNotificationTitleSocialReactionLike": "Νέο «μου αρέσει»",
  "sNotificationBodySocialReactionLikeSongShare": "Το τραγούδι που κοινοποίησες, {2} από {1}, αρέσει στον χρήστη {0}.",
  "sNotificationBodySocialReactionLikeAlbumShare": "Το άλμπουμ που κοινοποίησες, {2} από {1}, αρέσει στον χρήστη {0}.",
  "sNotificationBodySocialReactionLikeArtistShare": "Ο καλλιτέχνης που κοινοποίησες, {1}, αρέσει στον χρήστη {0}.",
  "sNotificationBodySocialReactionLikePlaylistShare": "Η λίστα που κοινοποίησες, {1}, αρέσει στον χρήστη {0}.",
  "sNotificationBodySocialReactionLikeSongSocialStory": "Το {2} από {1} από τη δραστηριότητά σου αρέσει στον χρήστη {0}.",
  "sNotificationBodySocialReactionLikeAlbumSocialStory": "Το {2} από {1} από τη δραστηριότητά σου αρέσει στον χρήστη {0}.",
  "sNotificationBodySocialReactionLikeArtistSocialStory": "Το {1} από τη δραστηριότητά σου αρέσει στον χρήστη {0}.",
  "sNotificationBodySocialReactionLikePlaylistSocialStory": "Η λίστα από τη δραστηριότητά σου, {1}, αρέσει στον χρήστη {0}.",
  "sClearAllButton": "Απαλοιφή όλων",
  "sLoadError": "Δυστυχώς, δεν μπορούμε να λάβουμε τις ειδοποιήσεις σου αυτή τη στιγμή.",
  "sNoMoreMessage": "Δεν έχεις καμία ειδοποίηση.",
  "sTitle": "Ειδοποιήσεις",
  "s1Hour": "Πριν από περίπου 1 ώρα",
  "s1Minute": "Πριν από περίπου 1 λεπτό",
  "sDaysAgo": "Πριν από {0} μέρες",
  "sHoursAgo": "Πριν από {0} ώρες",
  "sJustNow": "Μόλις τώρα",
  "sMinutesAgo": "Πριν από {0} λεπτά",
  "sOverAYear": "Πάνω από ένα χρόνο πριν",
  "sSecondsAgo": "Πριν από {0} δευτερόλεπτα",
  "sYesterday": "Χθες",
  "ListTwo": "{0} και {1}",
  "ListStart": "{0}, {1}",
  "ListMiddle": "{0}, {1}",
  "ListEnd": "{0} και {1}"
};
},{}],3:[function(require,module,exports){
module.exports = {
  "sNotificationTitleAlbumReleased": "Album Released",
  "sNotificationBodyAlbumReleased": "{0} by {1} is now available on Spotify.",
  "sNotificationBodyExclusiveAlbumReleased": "Exclusive release:<br>{0} by {1} is now available exclusively on Spotify.",
  "sNotificationTitleApplicationRelease": "Update",
  "sNotificationBodyApplicationReleaseAndroid": "A new version of Spotify for Android is now available.",
  "sNotificationBodyApplicationReleaseIOS": "A new version of Spotify for iOS is now available.",
  "sNotificationBodyApplicationReleaseLink": "You can now use Spotify in your web browser.",
  "sNotificationBodyApplicationReleaseMftLaunch": "Spotify is now free on mobile and tablet!",
  "sNotificationBodyApplicationReleaseMftReminder": "Don't miss out - Spotify is now free everywhere. Install now on iPhone, iPad and Android.",
  "sNotificationBodyApplicationReleaseMftSeason": "Got a new iPhone, iPad or Android? Find out how to listen for free.",
  "sNotificationTitleFriendJoined": "Friend Joined",
  "sNotificationBodyFriendJoined": "Your friend {0} just joined Spotify.",
  "sNotificationBodyMultipleAlbumsReleased": "{0} and {2} other albums by {1} are now available on Spotify.",
  "sNotificationBodyMultipleAlbumsReleasedSingular": "{0} and 1 other album by {1} are now available on Spotify.",
  "sNotificationBodyMultipleExclusiveAlbumsReleased": "Exclusive release:<br>{0} and {2} other albums by {1} are now available exclusively on Spotify.",
  "sNotificationBodyMultipleExclusiveAlbumsReleasedSingular": "Exclusive release:<br>{0} and 1 other album by {1} are now available exclusively on Spotify.",
  "sNotificationTitleMessagePlayed": "Attachment Played",
  "sNotificationBodyMessagePlayed": "{0} played the attachment that you sent.",
  "sNotificationTitleNewFollower": "New Follower",
  "sNotificationBodyNewFollower": "{0} started following you.",
  "sNotificationTitlePlaylistSubscribe": "New Playlist Follower",
  "sNotificationBodyPlaylistSubscribe": "{0} is now following your playlist: {1}.",
  "sNotificationTitlePlaylistUpdated": "Playlist Updated",
  "sNotificationBodyPlaylistUpdatedPlural": "{0} added {2} songs to {1}.",
  "sNotificationBodyPlaylistUpdatedSingular": "{0} added a song to {1}.",
  "sNotificationBodyToplistSubscribe": "{0} is now following your top songs.",
  "sNotificationBodyToplistUpdatedName": "Top Songs",
  "sNotificationTitleSocialReactionPlay": "New Play",
  "sNotificationBodySocialReactionPlaySongShare": "{0} played the song you shared: {2} by {1}.",
  "sNotificationBodySocialReactionPlayAlbumShare": "{0} played the album you shared: {2} by {1}.",
  "sNotificationBodySocialReactionPlayArtistShare": "{0} played the artist you shared: {1}.",
  "sNotificationBodySocialReactionPlayPlaylistShare": "{0} played the playlist you shared: {1}.",
  "sNotificationBodySocialReactionPlaySongSocialStory": "{0} played {2} by {1} from your activity.",
  "sNotificationBodySocialReactionPlayAlbumSocialStory": "{0} played {2} by {1} from your activity.",
  "sNotificationBodySocialReactionPlayArtistSocialStory": "{0} played {1} from your activity.",
  "sNotificationBodySocialReactionPlayPlaylistSocialStory": "{0} played a playlist from your activity: {1}.",
  "sNotificationTitleSocialReactionLike": "New Like",
  "sNotificationBodySocialReactionLikeSongShare": "{0} liked the song you shared: {2} by {1}.",
  "sNotificationBodySocialReactionLikeAlbumShare": "{0} liked the album you shared: {2} by {1}.",
  "sNotificationBodySocialReactionLikeArtistShare": "{0} liked the artist you shared: {1}.",
  "sNotificationBodySocialReactionLikePlaylistShare": "{0} liked the playlist you shared: {1}.",
  "sNotificationBodySocialReactionLikeSongSocialStory": "{0} liked {2} by {1} from your activity.",
  "sNotificationBodySocialReactionLikeAlbumSocialStory": "{0} liked {2} by {1} from your activity.",
  "sNotificationBodySocialReactionLikeArtistSocialStory": "{0} liked {1} from your activity.",
  "sNotificationBodySocialReactionLikePlaylistSocialStory": "{0} liked a playlist from your activity: {1}.",
  "sClearAllButton": "Clear All",
  "sLoadError": "Sorry. We cannot get your notifications right now.",
  "sNoMoreMessage": "You don't have any notifications.",
  "sTitle": "Notifications",
  "s1Hour": "About 1 hour ago",
  "s1Minute": "About 1 minute ago",
  "sDaysAgo": "{0} days ago",
  "sHoursAgo": "{0} hours ago",
  "sJustNow": "Just now",
  "sMinutesAgo": "{0} minutes ago",
  "sOverAYear": "Over a year ago",
  "sSecondsAgo": "{0} seconds ago",
  "sYesterday": "Yesterday",
  "ListTwo" : "{0} and {1}",
  "ListStart" : "{0}, {1}",
  "ListMiddle" : "{0}, {1}",
  "ListEnd" : "{0}, and {1}"
}
;
},{}],4:[function(require,module,exports){
module.exports = {
  "sNotificationTitleAlbumReleased": "Álbum lanzado",
  "sNotificationBodyAlbumReleased": "{0} de {1} está ahora disponible en Spotify.",
  "sNotificationBodyExclusiveAlbumReleased": "Lanzamiento exclusivo: <br> {0} de {1} ya está disponible exclusivamente en Spotify.",
  "sNotificationTitleApplicationRelease": "Actualización",
  "sNotificationBodyApplicationReleaseAndroid": "Una nueva versión de Spotify está disponible para Android.",
  "sNotificationBodyApplicationReleaseIOS": "Una nueva versión de Spotify está disponible para iOS.",
  "sNotificationBodyApplicationReleaseLink": "Ahora puedes usar Spotify en tu navegador de internet. ",
  "sNotificationBodyApplicationReleaseMftLaunch": "¡Ahora Spotify es gratis en móvil y tablet!",
  "sNotificationBodyApplicationReleaseMftReminder": "No lo dejes pasar - Ahora Spotify es gratis en todos lados. Instálalo ahora en iPhone, iPad y Android.",
  "sNotificationBodyApplicationReleaseMftSeason": "¿Tienes un iPhone, iPad o Android nuevo? Pues descubre cómo escuchar música gratis.",
  "sNotificationTitleFriendJoined": "Un amigo se ha unido",
  "sNotificationBodyFriendJoined": "Tu amigo {0} se acaba de unir a Spotify.",
  "sNotificationBodyMultipleAlbumsReleased": "{0} y {2} álbumes más de {1} están ahora disponibles en Spotify.",
  "sNotificationBodyMultipleAlbumsReleasedSingular": "{0} y 1 álbum más de {1} están ahora disponibles en Spotify.",
  "sNotificationBodyMultipleExclusiveAlbumsReleased": "Lanzamiento exclusivo:<br>{0} y {2} álbumes más de {1} están ahora disponibles exclusivamente en Spotify.",
  "sNotificationBodyMultipleExclusiveAlbumsReleasedSingular": "Lanzamiento exclusivo: <br>{0} y 1 álbum más de {1} ya están disponibles exclusivamente en Spotify.",
  "sNotificationTitleMessagePlayed": "El archivo anexo ha sido reproducido",
  "sNotificationBodyMessagePlayed": "{0} ha(n) reproducido el archivo anexo que enviaste.",
  "sNotificationTitleNewFollower": "Nuevo seguidor",
  "sNotificationBodyNewFollower": "{0} empezó a seguirte.",
  "sNotificationTitlePlaylistSubscribe": "Nuevo seguidor de playlist",
  "sNotificationBodyPlaylistSubscribe": "{0} ahora sigue tu playlist: {1}.",
  "sNotificationTitlePlaylistUpdated": "Playlist actualizada",
  "sNotificationBodyPlaylistUpdatedPlural": "{0} agregó {2} canciones a {1}.",
  "sNotificationBodyPlaylistUpdatedSingular": "{0} agregó una canción a {1}.",
  "sNotificationBodyToplistSubscribe": "{0} ahora sigue tus canciones favoritas.",
  "sNotificationBodyToplistUpdatedName": "Canciones más reproducidas",
  "sNotificationTitleSocialReactionPlay": "Nueva reproducción",
  "sNotificationBodySocialReactionPlaySongShare": "{0} escuchó la canción que compartiste: {2} de {1}.",
  "sNotificationBodySocialReactionPlayAlbumShare": "{0} escuchó el álbum que compartiste: {2} de{1}.",
  "sNotificationBodySocialReactionPlayArtistShare": "{0} escuchó al artista que compartiste: {1}.",
  "sNotificationBodySocialReactionPlayPlaylistShare": "{0} escuchó la playlist que compartiste: {1}.",
  "sNotificationBodySocialReactionPlaySongSocialStory": "{0} escuchó {2} de {1} de tu actividad.",
  "sNotificationBodySocialReactionPlayAlbumSocialStory": "{0} escuchó {2} de {1} de tu actividad.",
  "sNotificationBodySocialReactionPlayArtistSocialStory": "{0} escuchó {1} de tu actividad.",
  "sNotificationBodySocialReactionPlayPlaylistSocialStory": "{0} escuchó una playlist de tu actividad: {1}.",
  "sNotificationTitleSocialReactionLike": "Nuevo \"Me gusta\"",
  "sNotificationBodySocialReactionLikeSongShare": "A {0} le gustó la canción que compartiste: {2} de {1}.",
  "sNotificationBodySocialReactionLikeAlbumShare": "A {0} le gustó el álbum que compartiste: {2} de{1}.",
  "sNotificationBodySocialReactionLikeArtistShare": "A {0} le gustó el artista que compartiste: {1}.",
  "sNotificationBodySocialReactionLikePlaylistShare": "A {0} le gustó la playlist que compartiste: {1}.",
  "sNotificationBodySocialReactionLikeSongSocialStory": "A {0} le gustó {2} de {1} de tu actividad.",
  "sNotificationBodySocialReactionLikeAlbumSocialStory": "A {0} le gustó {2} de {1} de tu actividad.",
  "sNotificationBodySocialReactionLikeArtistSocialStory": "A {0} le gustó {1} de tu actividad.",
  "sNotificationBodySocialReactionLikePlaylistSocialStory": "A {0} le gustó una playlist de tu actividad: {1}.",
  "sClearAllButton": "Borrar todo",
  "sLoadError": "Lo sentimos, no podemos recibir tus notificaciones.",
  "sNoMoreMessage": "No tienes ninguna notificación.",
  "sTitle": "Notificaciones",
  "s1Hour": "Hace una hora",
  "s1Minute": "Hace un minuto ",
  "sDaysAgo": "Hace {0} días ",
  "sHoursAgo": "Hace {0} horas ",
  "sJustNow": "Ahora",
  "sMinutesAgo": "Hace {0} minutos ",
  "sOverAYear": "Hace más de un año",
  "sSecondsAgo": "Hace {0} segundos",
  "sYesterday": "Ayer",
  "ListTwo": "{0} y {1}",
  "ListStart": "{0}, {1}",
  "ListMiddle": "{0}, {1}",
  "ListEnd": "{0} y {1}"
};
},{}],5:[function(require,module,exports){
module.exports = {
  "sNotificationTitleAlbumReleased": "Álbum publicado",
  "sNotificationBodyAlbumReleased": "Ahora está disponible en Spotify {0} de {1}.",
  "sNotificationBodyExclusiveAlbumReleased": "Lanzamiento exclusivo:<br>Ya está disponible exclusivamente en Spotify {0} de {1}.",
  "sNotificationTitleApplicationRelease": "Actualización",
  "sNotificationBodyApplicationReleaseAndroid": "Ahora está disponible una nueva versión de Spotify para Android.",
  "sNotificationBodyApplicationReleaseIOS": "Ahora está disponible una nueva versión de Spotify para iOS.",
  "sNotificationBodyApplicationReleaseLink": "Ahora puedes usar Spotify en tu navegador web.",
  "sNotificationBodyApplicationReleaseMftLaunch": "¡Ahora Spotify es gratis para celular y tablet!",
  "sNotificationBodyApplicationReleaseMftReminder": "No te lo pierdas: ahora Spotify es gratis en cualquier parte. Instálalo ya en iPhone, iPad y Android.",
  "sNotificationBodyApplicationReleaseMftSeason": "¿Tienes un iPhone, iPad o Android nuevo? Pues descubre cómo escuchar música gratis.",
  "sNotificationTitleFriendJoined": "Un amigo se ha unido",
  "sNotificationBodyFriendJoined": "Tu amigo/a {0} acaba de unirse a Spotify.",
  "sNotificationBodyMultipleAlbumsReleased": "Ya están disponibles en Spotify {0} y {2} álbumes más de {1}.",
  "sNotificationBodyMultipleAlbumsReleasedSingular": "Ya están disponibles en Spotify {0} y otro álbum más de {1}.",
  "sNotificationBodyMultipleExclusiveAlbumsReleased": "Lanzamiento exclusivo:<br>Ya están disponibles exclusivamente en Spotify {0} y {2} álbumes más de {1}.",
  "sNotificationBodyMultipleExclusiveAlbumsReleasedSingular": "Lanzamiento exclusivo:<br>Ya están disponibles exclusivamente en Spotify {0} y otro álbum más de {1}.",
  "sNotificationTitleMessagePlayed": "Adjunto reproducido",
  "sNotificationBodyMessagePlayed": "{0} ha reproducido el adjunto que enviaste.",
  "sNotificationTitleNewFollower": "Nuevo seguidor",
  "sNotificationBodyNewFollower": "{0} ha comenzado a seguirte.",
  "sNotificationTitlePlaylistSubscribe": "Nuevo seguidor de playlist",
  "sNotificationBodyPlaylistSubscribe": "{0} ahora sigue tu playlist {1}.",
  "sNotificationTitlePlaylistUpdated": "Playlist actualizada",
  "sNotificationBodyPlaylistUpdatedPlural": "{0} ha añadido {2} canciones a {1}.",
  "sNotificationBodyPlaylistUpdatedSingular": "{0} ha añadido una canción a {1}.",
  "sNotificationBodyToplistSubscribe": "{0} ahora sigue tus canciones más escuchadas.",
  "sNotificationBodyToplistUpdatedName": "Canciones más escuchadas",
  "sNotificationTitleSocialReactionPlay": "Nueva reproducción",
  "sNotificationBodySocialReactionPlaySongShare": "{0} ha escuchado una canción que compartiste: {2} de {1}.",
  "sNotificationBodySocialReactionPlayAlbumShare": "{0} ha escuchado un álbum que compartiste: {2} de {1}.",
  "sNotificationBodySocialReactionPlayArtistShare": "{0} ha escuchado un artista que compartiste: {1}.",
  "sNotificationBodySocialReactionPlayPlaylistShare": "{0} ha escuchado una playlist que compartiste: {1}.",
  "sNotificationBodySocialReactionPlaySongSocialStory": "{0} ha escuchado {2} de {1} a partir de tu actividad.",
  "sNotificationBodySocialReactionPlayAlbumSocialStory": "{0} ha escuchado {2} de {1} a partir de tu actividad.",
  "sNotificationBodySocialReactionPlayArtistSocialStory": "{0} ha escuchado a {1} a partir de tu actividad.",
  "sNotificationBodySocialReactionPlayPlaylistSocialStory": "{0} ha escuchado una playlist a partir de tu actividad: {1}.",
  "sNotificationTitleSocialReactionLike": "Nuevo \"me gusta\"",
  "sNotificationBodySocialReactionLikeSongShare": "A {0} le ha gustado una canción que compartiste: {2} de {1}.",
  "sNotificationBodySocialReactionLikeAlbumShare": "A {0} le ha gustado un álbum que compartiste: {2} de {1}.",
  "sNotificationBodySocialReactionLikeArtistShare": "A {0} le ha gustado un artista que compartiste: {1}.",
  "sNotificationBodySocialReactionLikePlaylistShare": "A {0} le ha gustado una playlist compartiste: {1}.",
  "sNotificationBodySocialReactionLikeSongSocialStory": "A {0} le ha gustado {2} de {1} a partir de tu actividad.",
  "sNotificationBodySocialReactionLikeAlbumSocialStory": "A {0} le ha gustado {2} de {1} a partir de tu actividad.",
  "sNotificationBodySocialReactionLikeArtistSocialStory": "A {0} le ha gustado {1} a partir de tu actividad.",
  "sNotificationBodySocialReactionLikePlaylistSocialStory": "A {0} le ha gustado una playlist a partir de tu actividad: {1}.",
  "sClearAllButton": "Borrar todas",
  "sLoadError": "Lo sentimos. En este momento no nos es posible obtener tus notificaciones.",
  "sNoMoreMessage": "No tienes ninguna notificación.",
  "sTitle": "Notificaciones",
  "s1Hour": "Hace alrededor de una hora",
  "s1Minute": "Hace alrededor de un minuto",
  "sDaysAgo": "Hace {0} días",
  "sHoursAgo": "Hace {0} h",
  "sJustNow": "Hace un momento",
  "sMinutesAgo": "Hace {0} min",
  "sOverAYear": "Hace más de un año",
  "sSecondsAgo": "Hace {0} segundos",
  "sYesterday": "Ayer",
  "ListTwo": "{0} y {1}",
  "ListStart": "{0}, {1}",
  "ListMiddle": "{0}, {1}",
  "ListEnd": "{0} y {1}"
};
},{}],6:[function(require,module,exports){
module.exports = {
  "sNotificationTitleAlbumReleased": "Albumi julkaistu",
  "sNotificationBodyAlbumReleased": "{0} artistilta {1} on nyt saatavilla Spotifyssa.",
  "sNotificationBodyExclusiveAlbumReleased": "Vain meillä:<br/>{0} artistilta {1} on nyt saatavilla vain Spotifyssa.",
  "sNotificationTitleApplicationRelease": "Päivitä",
  "sNotificationBodyApplicationReleaseAndroid": "Uusi Spotify-versio Androidille on nyt saatavilla.",
  "sNotificationBodyApplicationReleaseIOS": "Uusi Spotify-versio iOS:lle on nyt saatavilla.",
  "sNotificationBodyApplicationReleaseLink": "Voit nyt käyttää Spotify-palvelua verkkoselaimellasi.",
  "sNotificationBodyApplicationReleaseMftLaunch": "Spotify on nyt ilmainen mobiili- ja tablet-laitteissa!",
  "sNotificationBodyApplicationReleaseMftReminder": "Älä jää turhaan jälkijunaan - Spotify on nyt ilmainen kaikkialla. Asenna nyt iPhoneen, iPadiin tai Androidiin.",
  "sNotificationBodyApplicationReleaseMftSeason": "Uusi iPhone, iPad tai Android? Katso, miten voit kuunnella ilmaiseksi.",
  "sNotificationTitleFriendJoined": "Ystävä liittyi",
  "sNotificationBodyFriendJoined": "Ystäväsi {0} liittyi juuri Spotify-palveluun.",
  "sNotificationBodyMultipleAlbumsReleased": "{0} ja {2} muuta artistin {1} albumia ovat nyt saatavilla Spotifyssa.",
  "sNotificationBodyMultipleAlbumsReleasedSingular": "{0} ja 1 muu artistin {1} albumi ovat nyt saatavilla Spotifyssa.",
  "sNotificationBodyMultipleExclusiveAlbumsReleased": "Vain meillä: {0} ja {2} muuta artistin {1} albumia ovat nyt saatavilla vain Spotifyssa.",
  "sNotificationBodyMultipleExclusiveAlbumsReleasedSingular": "Vain meillä:<br/>{0} ja 1 muu artistin {1} albumi ovat nyt saatavilla vain Spotifyssa.",
  "sNotificationTitleMessagePlayed": "Liite toistettu",
  "sNotificationBodyMessagePlayed": "{0} toisti lähettämäsi liitteen.",
  "sNotificationTitleNewFollower": "Uusi seuraaja",
  "sNotificationBodyNewFollower": "{0} alkoi seurata sinua.",
  "sNotificationTitlePlaylistSubscribe": "Uusi soittolistan seuraaja",
  "sNotificationBodyPlaylistSubscribe": "{0} seuraa nyt soittolistaasi: {1}.",
  "sNotificationTitlePlaylistUpdated": "Soittolista päivittynyt",
  "sNotificationBodyPlaylistUpdatedPlural": "{0} lisäsi {2} kappaletta kohteeseen {1}.",
  "sNotificationBodyPlaylistUpdatedSingular": "{0} lisäsi kappaleen kohteeseen {1}.",
  "sNotificationBodyToplistSubscribe": "{0} seuraa nyt soitetuimpia kappaleitasi.",
  "sNotificationBodyToplistUpdatedName": "Suosituimmat kappaleet",
  "sNotificationTitleSocialReactionPlay": "Uusi toisto",
  "sNotificationBodySocialReactionPlaySongShare": "{0} soitti jakamasi kappaleen {2} artistilta {1}.",
  "sNotificationBodySocialReactionPlayAlbumShare": "{0} soitti jakamasi albumin {2} artistilta {1}.",
  "sNotificationBodySocialReactionPlayArtistShare": "{0} soitti jakamaasi artistia {1}",
  "sNotificationBodySocialReactionPlayPlaylistShare": "{0} soitti jakamasi soittolistan {1}",
  "sNotificationBodySocialReactionPlaySongSocialStory": "{0} soitti toimissasi näkyvän kohteen {2} ({1}).",
  "sNotificationBodySocialReactionPlayAlbumSocialStory": "{0} soitti toimissasi näkyvän kohteen {2} ({1}).",
  "sNotificationBodySocialReactionPlayArtistSocialStory": "{0} soitti toimissasi näkyvän kohteen {1}.",
  "sNotificationBodySocialReactionPlayPlaylistSocialStory": "{0} soitti toimissasi näkyvän soittolistan: {1}.",
  "sNotificationTitleSocialReactionLike": "Uusi tykkäys",
  "sNotificationBodySocialReactionLikeSongShare": "{0} tykkäsi jakamastasi artistin {1} kappaleesta {2}.",
  "sNotificationBodySocialReactionLikeAlbumShare": "{0} tykkäsi jakamastasi artistin {1} albumista {2}.",
  "sNotificationBodySocialReactionLikeArtistShare": "{0} tykkäsi jakamastasi artistista {1}.",
  "sNotificationBodySocialReactionLikePlaylistShare": "{0} tykkäsi jakamastasi soittolistasta {1}.",
  "sNotificationBodySocialReactionLikeSongSocialStory": "{0} tykkäsi toimissasi näkyvästä kohteesta {2} ({1}).",
  "sNotificationBodySocialReactionLikeAlbumSocialStory": "{0} tykkäsi toimissasi näkyvästä kohteesta {2} ({1}).",
  "sNotificationBodySocialReactionLikeArtistSocialStory": "{0} tykkäsi toimissasi näkyvästä kohteesta {1}.",
  "sNotificationBodySocialReactionLikePlaylistSocialStory": "{0} tykkäsi toimissasi näkyvästä soittolistasta: {1}.",
  "sClearAllButton": "Poista kaikki",
  "sLoadError": "Valitettavasti ilmoitustesi haku ei nyt onnistu.",
  "sNoMoreMessage": "Sinulla ei ole ilmoituksia.",
  "sTitle": "Ilmoitukset",
  "s1Hour": "Noin 1 tunti sitten",
  "s1Minute": "Noin 1 minuutti sitten",
  "sDaysAgo": "{0} päivää sitten",
  "sHoursAgo": " {0} tuntia sitten",
  "sJustNow": "Juuri nyt",
  "sMinutesAgo": "{0} minuuttia sitten",
  "sOverAYear": "Yli vuosi sitten",
  "sSecondsAgo": "{0} sekuntia sitten",
  "sYesterday": "Eilen",
  "ListTwo": "{0} ja {1}",
  "ListStart": "{0}, {1}",
  "ListMiddle": "{0}, {1}",
  "ListEnd": "{0} ja {1}"
};
},{}],7:[function(require,module,exports){
module.exports = {
  "sNotificationTitleAlbumReleased": "Album lancé",
  "sNotificationBodyAlbumReleased": "{0} de {1} est maintenant disponible sur Spotify.",
  "sNotificationBodyExclusiveAlbumReleased": "Nouveauté exclusive :<br>{0} de {1} est maintenant offert en exclusivité sur Spotify.",
  "sNotificationTitleApplicationRelease": "Mise à jour",
  "sNotificationBodyApplicationReleaseAndroid": "Une nouvelle version de Spotify est maintenant disponible pour Android.",
  "sNotificationBodyApplicationReleaseIOS": "Une nouvelle version de Spotify est maintenant disponible pour iOS.",
  "sNotificationBodyApplicationReleaseLink": "Vous pouvez maintenant utiliser Spotify dans votre navigateur Internet.",
  "sNotificationBodyApplicationReleaseMftLaunch": "Spotify est désormais gratuit pour les mobiles et les tablettes!",
  "sNotificationBodyApplicationReleaseMftReminder": "Offre à ne pas manquer! Spotify est désormais gratuit partout. Installez l'application dès maintenant sur votre iPhone, votre iPad ou votre Android.",
  "sNotificationBodyApplicationReleaseMftSeason": "Vous avez un nouvel appareil iPhone, iPad ou Android? Découvrez comment écouter Spotify gratuitement.",
  "sNotificationTitleFriendJoined": "Arrivée d'un ami",
  "sNotificationBodyFriendJoined": "Votre ami {0} a tout juste joint Spotify.",
  "sNotificationBodyMultipleAlbumsReleased": "{0} et {2} autres albums de {1} sont maintenant disponibles sur Spotify.",
  "sNotificationBodyMultipleAlbumsReleasedSingular": "{0} et 1 autre album de {1} sont maintenant disponibles sur Spotify.",
  "sNotificationBodyMultipleExclusiveAlbumsReleased": "Nouveauté exclusive :<br>{0} et {2} autres albums de {1} sont maintenant offerts exclusivement sur Spotify.",
  "sNotificationBodyMultipleExclusiveAlbumsReleasedSingular": "Nouveauté exclusive :<br>{0} et 1 autre album de {1} sont maintenant offerts exclusivement sur Spotify.",
  "sNotificationTitleMessagePlayed": "Pièce jointe lue",
  "sNotificationBodyMessagePlayed": "{0} a écouté la pièce jointe que vous avez envoyée.",
  "sNotificationTitleNewFollower": "Nouvel abonné",
  "sNotificationBodyNewFollower": "{0} a commencé à vous suivre.",
  "sNotificationTitlePlaylistSubscribe": "Nouvel abonné à une liste de lecture",
  "sNotificationBodyPlaylistSubscribe": "{0} suit maintenant votre liste de lecture : {1}.",
  "sNotificationTitlePlaylistUpdated": "Liste de lecture mise à jour",
  "sNotificationBodyPlaylistUpdatedPlural": "{0} a ajouté {2} chansons à {1}.",
  "sNotificationBodyPlaylistUpdatedSingular": "{0} a ajouté une chanson à {1}.",
  "sNotificationBodyToplistSubscribe": "{0} suit maintenant vos meilleures chansons.",
  "sNotificationBodyToplistUpdatedName": "Top titres",
  "sNotificationTitleSocialReactionPlay": "Nouvelle lecture",
  "sNotificationBodySocialReactionPlaySongShare": "{0} a écouté le titre que vous avez partagé : {2} de {1}.",
  "sNotificationBodySocialReactionPlayAlbumShare": "{0} a écouté l'album que vous avez partagé : {2} de {1}.",
  "sNotificationBodySocialReactionPlayArtistShare": "{0} a écouté l'artiste que vous avez partagé : {1}.",
  "sNotificationBodySocialReactionPlayPlaylistShare": "{0} a écouté la liste de lecture que vous avez partagée : {1}.",
  "sNotificationBodySocialReactionPlaySongSocialStory": "{0} a écouté {2} de {1} à partir de votre activité.",
  "sNotificationBodySocialReactionPlayAlbumSocialStory": "{0} a écouté {2} de {1} à partir de votre activité.",
  "sNotificationBodySocialReactionPlayArtistSocialStory": "{0} a écouté {1} à partir de votre activité.",
  "sNotificationBodySocialReactionPlayPlaylistSocialStory": "{0} a écouté une liste de lecture à partir de votre activité : {1}.",
  "sNotificationTitleSocialReactionLike": "Nouveau J'aime",
  "sNotificationBodySocialReactionLikeSongShare": "{0} a aimé le titre que vous avez partagé : {2} de {1}.",
  "sNotificationBodySocialReactionLikeAlbumShare": "{0} a aimé l'album que vous avez partagé : {2} de {1}.",
  "sNotificationBodySocialReactionLikeArtistShare": "{0} a aimé l'artiste que vous avez partagé : {1}.",
  "sNotificationBodySocialReactionLikePlaylistShare": "{0} a aimé la liste de lecture que vous avez partagée : {1}.",
  "sNotificationBodySocialReactionLikeSongSocialStory": "{0} a aimé {2} de {1} à partir de votre activité.",
  "sNotificationBodySocialReactionLikeAlbumSocialStory": "{0} a aimé {2} de {1} à partir de votre activité.",
  "sNotificationBodySocialReactionLikeArtistSocialStory": "{0} a aimé {1} à partir de votre activité.",
  "sNotificationBodySocialReactionLikePlaylistSocialStory": "{0} a aimé une liste de lecture à partir de votre activité : {1}.",
  "sClearAllButton": "Effacer tout",
  "sLoadError": "Désolés! Nous ne pouvons pas afficher vos notifications pour l'instant.",
  "sNoMoreMessage": "Vous n'avez aucune notification.",
  "sTitle": "Notifications",
  "s1Hour": "Il y a environ 1 heure",
  "s1Minute": "Il y a environ 1 minute",
  "sDaysAgo": "Il y a {0} jours",
  "sHoursAgo": "Il y a {0} heures",
  "sJustNow": "À l'instant",
  "sMinutesAgo": "Il y a {0} minutes",
  "sOverAYear": "Il y a plus d'un an",
  "sSecondsAgo": "Il y a {0} secondes",
  "sYesterday": "Hier",
  "ListTwo": "{0} et {1}",
  "ListStart": "{0}, {1}",
  "ListMiddle": "{0}, {1}",
  "ListEnd": "{0}, et {1}"
};
},{}],8:[function(require,module,exports){
module.exports = {
  "sNotificationTitleAlbumReleased": "Album disponible",
  "sNotificationBodyAlbumReleased": "{0} de {1} est maintenant disponible sur Spotify.",
  "sNotificationBodyExclusiveAlbumReleased": "Nouveauté exclusive :<br>{0} de {1} est maintenant disponible sur Spotify.",
  "sNotificationTitleApplicationRelease": "Mise à jour",
  "sNotificationBodyApplicationReleaseAndroid": "Une nouvelle version de Spotify est maintenant disponible sur Android.",
  "sNotificationBodyApplicationReleaseIOS": "Une nouvelle version de Spotify est maintenant disponible sur iOS.",
  "sNotificationBodyApplicationReleaseLink": "Vous pouvez maintenant utiliser Spotify dans votre navigateur Internet.",
  "sNotificationBodyApplicationReleaseMftLaunch": "Spotify est désormais gratuit sur les mobiles et les tablettes !",
  "sNotificationBodyApplicationReleaseMftReminder": "Avis aux amateurs : Spotify est désormais gratuit partout. Installez l'appli dès maintenant sur votre iPhone, iPad ou Android.",
  "sNotificationBodyApplicationReleaseMftSeason": "Vous avez un nouvel iPhone, iPad ou appareil Android ? Découvrez comment écouter Spotify gratuitement.",
  "sNotificationTitleFriendJoined": "Arrivée d'un ami",
  "sNotificationBodyFriendJoined": "Votre ami {0} a rejoint Spotify.",
  "sNotificationBodyMultipleAlbumsReleased": "{0} et {2} autres albums de {1} sont maintenant disponibles sur Spotify.",
  "sNotificationBodyMultipleAlbumsReleasedSingular": "{0} et 1 autre album de {1} sont maintenant disponibles sur Spotify.",
  "sNotificationBodyMultipleExclusiveAlbumsReleased": "Nouveauté exclusive :<br>{0} et {2} autres albums de {1} sont maintenant disponibles sur Spotify.",
  "sNotificationBodyMultipleExclusiveAlbumsReleasedSingular": "Nouveauté exclusive :<br>{0} et 1 autre album sont maintenant disponibles sur Spotify.",
  "sNotificationTitleMessagePlayed": "Pièce jointe écoutée",
  "sNotificationBodyMessagePlayed": "{0} a écouté la pièce jointe que vous avez envoyée.",
  "sNotificationTitleNewFollower": "Nouvel abonné",
  "sNotificationBodyNewFollower": "{0} s'est abonné à vous.",
  "sNotificationTitlePlaylistSubscribe": "Nouvel abonné à une playlist",
  "sNotificationBodyPlaylistSubscribe": "{0} est abonné à votre playlist : {1}.",
  "sNotificationTitlePlaylistUpdated": "Playlist mise à jour",
  "sNotificationBodyPlaylistUpdatedPlural": "{0} a ajouté {2} chansons à {1}.",
  "sNotificationBodyPlaylistUpdatedSingular": "{0} a ajouté une chanson à {1}.",
  "sNotificationBodyToplistSubscribe": "{0} s'est abonné à vos Top chansons.",
  "sNotificationBodyToplistUpdatedName": "Top titres",
  "sNotificationTitleSocialReactionPlay": "Nouvelle lecture",
  "sNotificationBodySocialReactionPlaySongShare": "{0} a écouté le titre que vous avez partagé : {2} de {1}.",
  "sNotificationBodySocialReactionPlayAlbumShare": "{0} a écouté l'album que vous avez partagé : {2} de {1}.",
  "sNotificationBodySocialReactionPlayArtistShare": "{0} a écouté l'artiste que vous avez partagé : {1}.",
  "sNotificationBodySocialReactionPlayPlaylistShare": "{0} a écouté la playlist que vous avez partagée : {1}.",
  "sNotificationBodySocialReactionPlaySongSocialStory": "{0} a écouté {2} de {1} à partir de votre activité.",
  "sNotificationBodySocialReactionPlayAlbumSocialStory": "{0} a écouté {2} de {1} à partir de votre activité.",
  "sNotificationBodySocialReactionPlayArtistSocialStory": "{0} a écouté {1} à partir de votre activité.",
  "sNotificationBodySocialReactionPlayPlaylistSocialStory": "{0} a écouté une playlist à partir de votre activité : {1}.",
  "sNotificationTitleSocialReactionLike": "Nouveau J'aime",
  "sNotificationBodySocialReactionLikeSongShare": "{0} a aimé le titre que vous avez partagé : {2} de {1}.",
  "sNotificationBodySocialReactionLikeAlbumShare": "{0} a aimé l'album que vous avez partagé : {2} de {1}.",
  "sNotificationBodySocialReactionLikeArtistShare": "{0} a aimé l'artiste que vous avez partagé : {1}.",
  "sNotificationBodySocialReactionLikePlaylistShare": "{0} a aimé la playlist que vous avez partagée : {1}.",
  "sNotificationBodySocialReactionLikeSongSocialStory": "{0} a aimé {2} de {1} à partir de votre activité.",
  "sNotificationBodySocialReactionLikeAlbumSocialStory": "{0} a aimé {2} de {1} à partir de votre activité.",
  "sNotificationBodySocialReactionLikeArtistSocialStory": "{0} a aimé {1} à partir de votre activité.",
  "sNotificationBodySocialReactionLikePlaylistSocialStory": "{0} a aimé une playlist à partir de votre activité : {1}.",
  "sClearAllButton": "Effacer tout",
  "sLoadError": "Désolés. Nous ne pouvons pas afficher vos notifications pour l'instant.",
  "sNoMoreMessage": "Vous n'avez aucune notification.",
  "sTitle": "Notifications",
  "s1Hour": "Il y a environ 1 heure",
  "s1Minute": "Il y a environ 1 minute",
  "sDaysAgo": "Il y a {0} jours",
  "sHoursAgo": "Il y a {0} heures",
  "sJustNow": "À l'instant",
  "sMinutesAgo": "Il y a {0} minutes",
  "sOverAYear": "Il y a plus d'un an",
  "sSecondsAgo": "Il y a {0} secondes",
  "sYesterday": "Hier",
  "ListTwo": "{0} et {1}",
  "ListStart": "{0}, {1}",
  "ListMiddle": "{0}, {1}",
  "ListEnd": "{0} et {1}"
};
},{}],9:[function(require,module,exports){
module.exports = {
  "sNotificationTitleAlbumReleased": "Kiadott album",
  "sNotificationBodyAlbumReleased": "{1} – {0} már elérhető a Spotifyon.",
  "sNotificationBodyExclusiveAlbumReleased": "Exkluzív újdonság:<br>{1}: {0} – kizárólag a Spotifyon.",
  "sNotificationTitleApplicationRelease": "Frissítés",
  "sNotificationBodyApplicationReleaseAndroid": "Elérhető a Spotify új verziója Androidra.",
  "sNotificationBodyApplicationReleaseIOS": "Elérhető a Spotify új verziója iOS-re.",
  "sNotificationBodyApplicationReleaseLink": "A Spotifyt mostantól böngészőben is használhatod.",
  "sNotificationBodyApplicationReleaseMftLaunch": "A Spotify most ingyenes mobilon és táblagépen!",
  "sNotificationBodyApplicationReleaseMftReminder": "Ne szalaszd el – a Spotify most ingyenes minden eszközön. Telepítsd most iPhone, iPad és Android-készülékre.",
  "sNotificationBodyApplicationReleaseMftSeason": "Új iPhone, iPad vagy Android-készüléked van? Tudd meg, hogyan hallgathatsz dalokat ingyen.",
  "sNotificationTitleFriendJoined": "Egy barátod csatlakozott",
  "sNotificationBodyFriendJoined": "A barátod ({0}) épp most csatlakozott a Spotifyhoz.",
  "sNotificationBodyMultipleAlbumsReleased": "{1} {0} című albuma, valamint {2} további albuma már elérhető a Spotifyon.",
  "sNotificationBodyMultipleAlbumsReleasedSingular": "{1} {0} albuma és 1 további albuma már elérhető a Spotifyon.",
  "sNotificationBodyMultipleExclusiveAlbumsReleased": "Exkluzív újdonság:<br>{1} {0} című albuma és {2} további albuma kizárólag a Spotifyon.",
  "sNotificationBodyMultipleExclusiveAlbumsReleasedSingular": "Exkluzív újdonság:<br>{1} {0} című albuma és 1 további albuma kizárólag a Spotifyon.",
  "sNotificationTitleMessagePlayed": "A mellékletet lejátszották",
  "sNotificationBodyMessagePlayed": "{0} lejátszotta az általad küldött mellékletet.",
  "sNotificationTitleNewFollower": "Új követő",
  "sNotificationBodyNewFollower": "{0} mostantól követ téged.",
  "sNotificationTitlePlaylistSubscribe": "Új követője van a lejátszási listának",
  "sNotificationBodyPlaylistSubscribe": "{0} követi a lejátszási listádat: {1}.",
  "sNotificationTitlePlaylistUpdated": "Lejátszási lista frissítve",
  "sNotificationBodyPlaylistUpdatedPlural": "{0} felvett {2} számot {1} nevű lejátszási listájára.",
  "sNotificationBodyPlaylistUpdatedSingular": "{0} felvett egy számot {1} nevű lejátszási listájára",
  "sNotificationBodyToplistSubscribe": "{0} figyelemmel kíséri, mit szeretsz a legjobban hallgatni.",
  "sNotificationBodyToplistUpdatedName": "Toplista",
  "sNotificationTitleSocialReactionPlay": "Új lejátszás",
  "sNotificationBodySocialReactionPlaySongShare": "{0} lejátszotta az általad megosztott dalt: {1} – {2}.",
  "sNotificationBodySocialReactionPlayAlbumShare": "{0} lejátszotta az általad megosztott albumot: {1} – {2}.",
  "sNotificationBodySocialReactionPlayArtistShare": "{0} meghallgatta az általad megosztott előadót: {1}.",
  "sNotificationBodySocialReactionPlayPlaylistShare": "{0} lejátszotta az általad megosztott lejátszási listát: {1}.",
  "sNotificationBodySocialReactionPlaySongSocialStory": "{0} lejátszotta a következőt az eseményeid közül: {1} – {2}.",
  "sNotificationBodySocialReactionPlayAlbumSocialStory": "{0} lejátszotta a következőt az eseményeid közül: {1} – {2}.",
  "sNotificationBodySocialReactionPlayArtistSocialStory": "{0} lejátszotta a következőt az eseményeid közül: {1}.",
  "sNotificationBodySocialReactionPlayPlaylistSocialStory": "{0} lejátszott egy lejátszási listát az eseményeidből: {1}.",
  "sNotificationTitleSocialReactionLike": "Új kedvelés",
  "sNotificationBodySocialReactionLikeSongShare": "{0} kedvelte az általad megosztott dalt: {1} – {2}.",
  "sNotificationBodySocialReactionLikeAlbumShare": "{0} kedvelte az általad megosztott albumot: {1} – {2}.",
  "sNotificationBodySocialReactionLikeArtistShare": "{0} kedvelte az általad megosztott előadót: {1}.",
  "sNotificationBodySocialReactionLikePlaylistShare": "{0} kedvelte az általad megosztott lejátszási listát: {1}.",
  "sNotificationBodySocialReactionLikeSongSocialStory": "{0} kedvelte a következőt az eseményeid közül: {1} – {2}.",
  "sNotificationBodySocialReactionLikeAlbumSocialStory": "{0} kedvelte a következőt az eseményeid közül: {1} – {2}.",
  "sNotificationBodySocialReactionLikeArtistSocialStory": "{0} kedvelte a következőt az eseményeid közül: {1}.",
  "sNotificationBodySocialReactionLikePlaylistSocialStory": "{0} kedvelt egy lejátszási listát az eseményeidből: {1}.",
  "sClearAllButton": "Összes törlése",
  "sLoadError": "Sajnáljuk. Most nem érkeznek meg az értesítéseid.",
  "sNoMoreMessage": "Nincsenek értesítéseid.",
  "sTitle": "Értesítések",
  "s1Hour": "Körülbelül 1 órája",
  "s1Minute": "Körülbelül 1 perce",
  "sDaysAgo": "{0} napja",
  "sHoursAgo": "{0} órája",
  "sJustNow": "Épp most",
  "sMinutesAgo": "{0} perce",
  "sOverAYear": "Több mint egy éve",
  "sSecondsAgo": "{0} másodperce",
  "sYesterday": "Tegnap",
  "ListTwo": "{0} és {1}",
  "ListStart": "{0}, {1}",
  "ListMiddle": "{0}, {1}",
  "ListEnd": "{0} és {1}"
};
},{}],10:[function(require,module,exports){
module.exports = {
  "sNotificationTitleAlbumReleased": "Rilis Album",
  "sNotificationBodyAlbumReleased": "{0} dari {1} kini tersedia di Spotify.",
  "sNotificationBodyExclusiveAlbumReleased": "Rilis eksklusif:<br>{0} dari {1} sekarang tersedia secara eksklusif di Spotify.",
  "sNotificationTitleApplicationRelease": "Pembaruan",
  "sNotificationBodyApplicationReleaseAndroid": "Versi baru Spotify untuk Android sekarang sudah tersedia.",
  "sNotificationBodyApplicationReleaseIOS": "Versi Spotify terbaru untuk iOS kini telah tersedia.",
  "sNotificationBodyApplicationReleaseLink": "Sekarang kamu dapat menggunakan Spotify di browser web.",
  "sNotificationBodyApplicationReleaseMftLaunch": "Spotify kini tersedia gratis di ponsel dan tablet!",
  "sNotificationBodyApplicationReleaseMftReminder": "Jangan ketinggalan - Spotify kini percuma di mana sahaja. Pasang sekarang pada iPhone, iPad dan Android.",
  "sNotificationBodyApplicationReleaseMftSeason": "Mendapat iPhone baru, iPad atau Android? Ketahui cara untuk mendengar secara percuma.",
  "sNotificationTitleFriendJoined": "Teman yang Bergabung",
  "sNotificationBodyFriendJoined": "Temanmu {0} baru saja bergabung dengan Spotify.",
  "sNotificationBodyMultipleAlbumsReleased": "{0} dan {2} album lainnya dari {1} sekarang tersedia di Spotify.",
  "sNotificationBodyMultipleAlbumsReleasedSingular": "{0} dan 1 album lainnya dari {1} sekarang tersedia di Spotify.",
  "sNotificationBodyMultipleExclusiveAlbumsReleased": "Rilis eksklusif:<br>{0} dan {2} album lainnya  dari {1} sekarang tersedia secara eksklusif di Spotify.",
  "sNotificationBodyMultipleExclusiveAlbumsReleasedSingular": "Rilis eksklusif:<br>{0} dan 1 album lainnya dari {1} sekarang tersedia secara eksklusif di Spotify.",
  "sNotificationTitleMessagePlayed": "Lampiran yang Dimainkan",
  "sNotificationBodyMessagePlayed": "{0} memainkan lampiran yang kamu kirimkan.",
  "sNotificationTitleNewFollower": "Pengikut Baru",
  "sNotificationBodyNewFollower": "{0} mulai mengikutimu.",
  "sNotificationTitlePlaylistSubscribe": "Pengikut Playlist Baru",
  "sNotificationBodyPlaylistSubscribe": "{0} sekarang mengikuti playlist kamu: {1}.",
  "sNotificationTitlePlaylistUpdated": "Playlist Diperbarui",
  "sNotificationBodyPlaylistUpdatedPlural": "{0} menambahkan {2} lagu ke {1}.",
  "sNotificationBodyPlaylistUpdatedSingular": "{0} menambahkan satu lagu ke {1}.",
  "sNotificationBodyToplistSubscribe": "{0} sekarang mengikuti lagu teratasmu.",
  "sNotificationBodyToplistUpdatedName": "Lagu Teratas",
  "sNotificationTitleSocialReactionPlay": "Play Baru",
  "sNotificationBodySocialReactionPlaySongShare": "{0} memainkan lagu yang kamu share: {2} oleh {1}.",
  "sNotificationBodySocialReactionPlayAlbumShare": "{0} memainkan album yang kamu share: {2} oleh {1}.",
  "sNotificationBodySocialReactionPlayArtistShare": "{0} memainkan artis yang kamu share: {1}.",
  "sNotificationBodySocialReactionPlayPlaylistShare": "{0} memainkan playlist yang kamu share: {1}.",
  "sNotificationBodySocialReactionPlaySongSocialStory": "{0} memainkan {2} oleh {1} dari aktivitasmu.",
  "sNotificationBodySocialReactionPlayAlbumSocialStory": "{0} memainkan {2} oleh {1} dari aktivitasmu.",
  "sNotificationBodySocialReactionPlayArtistSocialStory": "{0} memainkan {1} dari aktivitasmu.",
  "sNotificationBodySocialReactionPlayPlaylistSocialStory": "{0} memainkan playlist dari aktivitasmu: {1}.",
  "sNotificationTitleSocialReactionLike": "Baru Disukai",
  "sNotificationBodySocialReactionLikeSongShare": "{0} menyukai lagu yang kamu bagikan: {2} oleh {1}.",
  "sNotificationBodySocialReactionLikeAlbumShare": "{0} menyukai album yang kamu bagikan: {2} oleh {1}.",
  "sNotificationBodySocialReactionLikeArtistShare": "{0} menyukai artis yang kamu bagikan: {1}.",
  "sNotificationBodySocialReactionLikePlaylistShare": "{0} menyukai playlist yang kamu bagikan: {1}.",
  "sNotificationBodySocialReactionLikeSongSocialStory": "{0} menyukai {2} oleh {1} dari aktivitasmu.",
  "sNotificationBodySocialReactionLikeAlbumSocialStory": "{0} menyukai {2} oleh {1} dari aktivitasmu.",
  "sNotificationBodySocialReactionLikeArtistSocialStory": "{0} menyukai {1} dari aktivitasmu.",
  "sNotificationBodySocialReactionLikePlaylistSocialStory": "{0} menyukai playlist dari aktivitasmu: {1}.",
  "sClearAllButton": "Hapus Semua",
  "sLoadError": "Maaf. Kami tidak bisa mengambil pemberitahuan kamu saat ini.",
  "sNoMoreMessage": "Kamu tidak memiliki pemberitahuan apa pun.",
  "sTitle": "Pemberitahuan",
  "s1Hour": "Sekitar 1 jam yang lalu",
  "s1Minute": "Sekitar 1 menit yang lalu",
  "sDaysAgo": "{0} hari yang lalu",
  "sHoursAgo": "{0} jam yang lalu",
  "sJustNow": "Baru saja",
  "sMinutesAgo": "{0} menit yang lalu",
  "sOverAYear": "Lebih dari setahun yang lalu",
  "sSecondsAgo": "{0} detik yang lalu",
  "sYesterday": "Kemarin",
  "ListTwo": "{0} dan {1}",
  "ListStart": "{0}, {1}",
  "ListMiddle": "{0}, {1}",
  "ListEnd": "{0}, dan {1}"
};
},{}],11:[function(require,module,exports){
'use strict';

// This file will likely become a generated file in the future. Please
// avoid adding extra APIs or exports here.

var i18n = require('../../../libs/spotify-i18n')({
  'de': require('./de.lang'),
  'el': require('./el.lang'),
  'en': require('./en.lang'),
  'es': require('./es.lang'),
  'es-419': require('./es-419.lang'),
  'fi': require('./fi.lang'),
  'fr': require('./fr.lang'),
  'fr-CA': require('./fr-CA.lang'),
  'hu': require('./hu.lang'),
  'id': require('./id.lang'),
  'it': require('./it.lang'),
  'ja': require('./ja.lang'),
  'nl': require('./nl.lang'),
  'pl': require('./pl.lang'),
  'pt-BR': require('./pt-BR.lang'),
  'sv': require('./sv.lang'),
  'tr': require('./tr.lang'),
  'zh-Hant': require('./zh-Hant.lang'),
  'zsm': require('./zsm.lang')
});

module.exports = i18n;

},{"../../../libs/spotify-i18n":104,"./de.lang":1,"./el.lang":2,"./en.lang":3,"./es-419.lang":4,"./es.lang":5,"./fi.lang":6,"./fr-CA.lang":7,"./fr.lang":8,"./hu.lang":9,"./id.lang":10,"./it.lang":12,"./ja.lang":13,"./nl.lang":14,"./pl.lang":15,"./pt-BR.lang":16,"./sv.lang":17,"./tr.lang":18,"./zh-Hant.lang":19,"./zsm.lang":20}],12:[function(require,module,exports){
module.exports = {
  "sNotificationTitleAlbumReleased": "Album disponibile",
  "sNotificationBodyAlbumReleased": "{0} di {1} è ora disponibile su Spotify.",
  "sNotificationBodyExclusiveAlbumReleased": "Uscita in esclusiva:<br> {0} di {1} è ora disponibile in esclusiva su Spotify.",
  "sNotificationTitleApplicationRelease": "Aggiorna",
  "sNotificationBodyApplicationReleaseAndroid": "Ora disponibile una nuova versione di Spotify per Android.",
  "sNotificationBodyApplicationReleaseIOS": "Ora disponibile una nuova versione di Spotify per iOS.",
  "sNotificationBodyApplicationReleaseLink": "Ora puoi utilizzare Spotify nel tuo Web browser.",
  "sNotificationBodyApplicationReleaseMftLaunch": "Ora Spotify è gratuito su cellulare e tablet.",
  "sNotificationBodyApplicationReleaseMftReminder": "Non perdere l'occasione. Ora Spotify è gratuito ovunque. Installalo ora su iPhone, iPad e Android.",
  "sNotificationBodyApplicationReleaseMftSeason": "Hai un nuovo iPhone, iPad o Android? Scopri come ascoltare musica gratis.",
  "sNotificationTitleFriendJoined": "Amico iscritto",
  "sNotificationBodyFriendJoined": "Il tuo amico {0} si è appena iscritto a Spotify.",
  "sNotificationBodyMultipleAlbumsReleased": "{0} e {2} altri album di {1} ora sono disponibili su Spotify.",
  "sNotificationBodyMultipleAlbumsReleasedSingular": "{0} e 1 altro album di {1} ora sono disponibili su Spotify.",
  "sNotificationBodyMultipleExclusiveAlbumsReleased": "Uscita in esclusiva:<br> {0} e {2} altri album di {1} sono ora disponibili in esclusiva su Spotify.",
  "sNotificationBodyMultipleExclusiveAlbumsReleasedSingular": "Uscita in esclusiva:<br> {0} e 1 altro album di {1} sono ora disponibili in esclusiva su Spotify.",
  "sNotificationTitleMessagePlayed": "Allegato ascoltato",
  "sNotificationBodyMessagePlayed": "{0} hanno ascoltato l'allegato che hai inviato.",
  "sNotificationTitleNewFollower": "Nuovo follower",
  "sNotificationBodyNewFollower": "{0} ha iniziato a seguirti.",
  "sNotificationTitlePlaylistSubscribe": "Nuovo follower della playlist",
  "sNotificationBodyPlaylistSubscribe": "{0} ora segue la tua playlist: {1}.",
  "sNotificationTitlePlaylistUpdated": "Playlist aggiornata",
  "sNotificationBodyPlaylistUpdatedPlural": "{0} ha aggiunto {2} brani a {1}.",
  "sNotificationBodyPlaylistUpdatedSingular": "{0} ha aggiunto un brano a {1}.",
  "sNotificationBodyToplistSubscribe": "{0} ora sta seguendo i tuoi brani top.",
  "sNotificationBodyToplistUpdatedName": "Brani Top",
  "sNotificationTitleSocialReactionPlay": "Nuovo Play",
  "sNotificationBodySocialReactionPlaySongShare": "{0} ha riprodotto il brano che hai condiviso: {2} di {1}.",
  "sNotificationBodySocialReactionPlayAlbumShare": "{0} ha riprodotto l'album che hai condiviso: {2} di {1}.",
  "sNotificationBodySocialReactionPlayArtistShare": "{0} ha ascoltato l'artista che hai condiviso: {1}.",
  "sNotificationBodySocialReactionPlayPlaylistShare": "{0} ha riprodotto la playlist che hai condiviso: {1}.",
  "sNotificationBodySocialReactionPlaySongSocialStory": "{0} ha riprodotto {2} di {1} dalla tua attività.",
  "sNotificationBodySocialReactionPlayAlbumSocialStory": "{0} ha riprodotto {2} di {1} dalla tua attività.",
  "sNotificationBodySocialReactionPlayArtistSocialStory": "{0} ha riprodotto {1} dalla tua attività.",
  "sNotificationBodySocialReactionPlayPlaylistSocialStory": "{0} ha riprodotto una playlist dalla tua attività: {1}.",
  "sNotificationTitleSocialReactionLike": "Nuovo Mi piace",
  "sNotificationBodySocialReactionLikeSongShare": "A {0} è piaciuto il brano che hai condiviso: {2} di {1}.",
  "sNotificationBodySocialReactionLikeAlbumShare": "A {0} è piaciuto l'album che hai condiviso: {2} di {1}.",
  "sNotificationBodySocialReactionLikeArtistShare": "A {0} è piaciuto l'artista che hai condiviso: {1}.",
  "sNotificationBodySocialReactionLikePlaylistShare": "A {0} è piaciuta la playlist che hai condiviso: {1}.",
  "sNotificationBodySocialReactionLikeSongSocialStory": "A {0} è piaciuto {2} di {1} dalla tua attività.",
  "sNotificationBodySocialReactionLikeAlbumSocialStory": "A {0} è piaciuto {2} di {1} dalla tua attività.",
  "sNotificationBodySocialReactionLikeArtistSocialStory": "A {0} è piaciuto {1} dalla tua attività.",
  "sNotificationBodySocialReactionLikePlaylistSocialStory": "A {0} è piaciuta la playlist dalla tua attività: {1}.",
  "sClearAllButton": "Cancella tutto",
  "sLoadError": "Spiacenti, ma al momento non possiamo accedere alle tue notifiche.",
  "sNoMoreMessage": "Non hai alcuna notifica.",
  "sTitle": "Notifiche",
  "s1Hour": "Circa 1 ora fa",
  "s1Minute": "Circa 1 minuto fa",
  "sDaysAgo": "{0} giorni fa",
  "sHoursAgo": "{0} ore fa",
  "sJustNow": "Proprio ora",
  "sMinutesAgo": "{0} minuti fa",
  "sOverAYear": "Più di un anno fa",
  "sSecondsAgo": "{0} secondi fa",
  "sYesterday": "Ieri",
  "ListTwo": "{0} e {1}",
  "ListStart": "{0}, {1}",
  "ListMiddle": "{0}, {1}",
  "ListEnd": "{0} e {1}"
};
},{}],13:[function(require,module,exports){
module.exports = {
  "sNotificationTitleAlbumReleased": "リリースされたアルバム",
  "sNotificationBodyAlbumReleased": "{1}の{0}はSpotifyで利用できるようになりました。",
  "sNotificationBodyExclusiveAlbumReleased": "独占リリース:<br/>{1}の{0}はSpotifyだけで聴くとこができます。",
  "sNotificationTitleApplicationRelease": "更新",
  "sNotificationBodyApplicationReleaseAndroid": "Android用Spotifyの新しいバージョンが利用可能です。",
  "sNotificationBodyApplicationReleaseIOS": "iOS用Spotifyの新しいバージョンが利用可能です。",
  "sNotificationBodyApplicationReleaseLink": "ご使用のWebブラウザでSpotifyを利用できるようになりました。",
  "sNotificationBodyApplicationReleaseMftLaunch": "Spotifyがモバイルとタブレットで無料で利用できるようになりました!",
  "sNotificationBodyApplicationReleaseMftReminder": "お見逃しなく - Spotifyがどこでも無料で利用できるようになりました。iPhone、iPad、Androidにインストールできるようになりました",
  "sNotificationBodyApplicationReleaseMftSeason": "新しいiPhone、iPad、Androidを手に入れましたか? 無料で利用する方法をご確認ください。",
  "sNotificationTitleFriendJoined": "登録済みの友達",
  "sNotificationBodyFriendJoined": "友達の{0}さんはSpotifyに加入しました。",
  "sNotificationBodyMultipleAlbumsReleased": "{1}の{0}と {2}その他のアルバムがSpotifyで聴けるようになりました。",
  "sNotificationBodyMultipleAlbumsReleasedSingular": "{1}の{0}と他1枚のアルバムがSpotifyで聴けるようになりました。",
  "sNotificationBodyMultipleExclusiveAlbumsReleased": "独占リリース:<br/>{1}の{0}と{2}とその他のアルバムはSpotifyだけで聴くことができます。",
  "sNotificationBodyMultipleExclusiveAlbumsReleasedSingular": "独占リリース:<br/>{1}の{0}と他1枚のアルバムはSpotifyだけで利用できるようになりました。",
  "sNotificationTitleMessagePlayed": "再生された添付ファイル",
  "sNotificationBodyMessagePlayed": "{0}は、あなたが送信した添付ファイルを再生しました。",
  "sNotificationTitleNewFollower": "新規フォロワー",
  "sNotificationBodyNewFollower": "{0}さんはあなたをフォローし始めました。",
  "sNotificationTitlePlaylistSubscribe": "新規プレイリストのフォロワー",
  "sNotificationBodyPlaylistSubscribe": "{0}さんはあなたのプレイリスト{1}をフォローしています。",
  "sNotificationTitlePlaylistUpdated": "更新済みのプレイリスト",
  "sNotificationBodyPlaylistUpdatedPlural": "{0}さんは{2}曲を{1}に追加しました。",
  "sNotificationBodyPlaylistUpdatedSingular": "{0}さんは曲を{1}に追加しました。",
  "sNotificationBodyToplistSubscribe": "{0}さんはあなたのトップ曲をフォローしています。",
  "sNotificationBodyToplistUpdatedName": "トップ曲",
  "sNotificationTitleSocialReactionPlay": "再生の新着情報",
  "sNotificationBodySocialReactionPlaySongShare": "{0}さんはあなたが共有した曲（{1}の{2}）を聴きました。",
  "sNotificationBodySocialReactionPlayAlbumShare": "{0}さんはあなたが共有したアルバムを聴きました: {1}の{2}",
  "sNotificationBodySocialReactionPlayArtistShare": "{0}さんはあなたが共有したアーティストの曲を聴きました: {1}",
  "sNotificationBodySocialReactionPlayPlaylistShare": "{0}さんはあなたが共有したプレイリストの曲を聴きました: {1}",
  "sNotificationBodySocialReactionPlaySongSocialStory": "{0}さんはあなたのアクティビティから{1}の{2}を聴きました。",
  "sNotificationBodySocialReactionPlayAlbumSocialStory": "{0}さんはあなたのアクティビティから{1}の{2}を聴きました。",
  "sNotificationBodySocialReactionPlayArtistSocialStory": "{0}さんはあなたのアクティビティから{1}を聴きました。",
  "sNotificationBodySocialReactionPlayPlaylistSocialStory": "{0}さんはあなたのアクティビティからプレイリスト（{1}）の曲を聴きました。",
  "sNotificationTitleSocialReactionLike": "いいねの新着情報",
  "sNotificationBodySocialReactionLikeSongShare": "{0}さんはあなたが共有した曲を気に入りました: {1}の{2}",
  "sNotificationBodySocialReactionLikeAlbumShare": "{0}さんはあなたが共有したアルバムを気に入りました: {1}の{2}",
  "sNotificationBodySocialReactionLikeArtistShare": "{0}さんはあなたが共有したアーティストの曲をお気に入りに追加しました: {1}",
  "sNotificationBodySocialReactionLikePlaylistShare": "{0}さんはあなたが共有したプレイリストの曲を気に入りました: {1}",
  "sNotificationBodySocialReactionLikeSongSocialStory": "{0}さんはあなたのアクティビティから{1}の{2}を気に入りました。",
  "sNotificationBodySocialReactionLikeAlbumSocialStory": "{0}さんはあなたのアクティビティから{1}の{2}を気に入りました。",
  "sNotificationBodySocialReactionLikeArtistSocialStory": "{0}さんはあなたのアクティビティ、{1}を気に入りました。",
  "sNotificationBodySocialReactionLikePlaylistSocialStory": "{0}さんはあなたのアクティビティからプレイリスト（{1}）の曲を気に入りました。",
  "sClearAllButton": "すべて消去",
  "sLoadError": "残念ながら、あなたへのお知らせを取得できません。",
  "sNoMoreMessage": "通知がありません。",
  "sTitle": "通知",
  "s1Hour": "約1時間前",
  "s1Minute": "約1分前",
  "sDaysAgo": "{0}日前",
  "sHoursAgo": "{0}時間前",
  "sJustNow": "今すぐ",
  "sMinutesAgo": "{0}分前",
  "sOverAYear": "1年以上前",
  "sSecondsAgo": "{0}秒前",
  "sYesterday": "昨日",
  "ListTwo": "{0}と{1}",
  "ListStart": "{0}、{1}",
  "ListMiddle": "{0}、{1}",
  "ListEnd": "{0}、と{1}"
};
},{}],14:[function(require,module,exports){
module.exports = {
  "sNotificationTitleAlbumReleased": "Album uitgebracht",
  "sNotificationBodyAlbumReleased": "{0} van {1} is nu beschikbaar op Spotify.",
  "sNotificationBodyExclusiveAlbumReleased": "Exclusieve release:<br>{0} van {1} is nu exclusief op Spotify te beluisteren.",
  "sNotificationTitleApplicationRelease": "Update",
  "sNotificationBodyApplicationReleaseAndroid": "Een nieuwe versie van Spotify voor Android is nu beschikbaar.",
  "sNotificationBodyApplicationReleaseIOS": "Een nieuwe versie van Spotify voor iOS is nu beschikbaar.",
  "sNotificationBodyApplicationReleaseLink": "Je kan Spotify nu ook in je webbrowser gebruiken.",
  "sNotificationBodyApplicationReleaseMftLaunch": "Spotify is nu gratis op je mobiel en tablet!",
  "sNotificationBodyApplicationReleaseMftReminder": "Mis het niet! Spotify is nu overal gratis. Nu installeren op iPhone, iPad en Android.",
  "sNotificationBodyApplicationReleaseMftSeason": "Heb je een nieuwe iPhone, iPad of een nieuw Android-toestel? Ontdek hoe je gratis kunt luisteren.",
  "sNotificationTitleFriendJoined": "Vriend heeft zich aangemeld",
  "sNotificationBodyFriendJoined": "Je vriend {0} heeft zich zojuist aangemeld bij Spotify.",
  "sNotificationBodyMultipleAlbumsReleased": "{0} en {2} andere albums van {1} zijn nu op Spotify te beluisteren.",
  "sNotificationBodyMultipleAlbumsReleasedSingular": "{0} en 1 ander album van {1} zijn nu op Spotify te beluisteren.",
  "sNotificationBodyMultipleExclusiveAlbumsReleased": "Exclusieve release:<br>{0} en {2} andere albums van {1} zijn nu exclusief op Spotify te beluisteren.",
  "sNotificationBodyMultipleExclusiveAlbumsReleasedSingular": "Exclusieve release:<br>{0} en 1 ander album van {1} zijn nu exclusief op Spotify te beluisteren.",
  "sNotificationTitleMessagePlayed": "Bijlage is afgespeeld",
  "sNotificationBodyMessagePlayed": "{0} heeft de bijlage afgespeeld die je hebt verzonden.",
  "sNotificationTitleNewFollower": "Nieuwe volger",
  "sNotificationBodyNewFollower": "{0} volgt je nu.",
  "sNotificationTitlePlaylistSubscribe": "Nieuwe volger afspeellijst",
  "sNotificationBodyPlaylistSubscribe": "{0} volgt nu je afspeellijst {1}.",
  "sNotificationTitlePlaylistUpdated": "Bijgewerkte afspeellijst",
  "sNotificationBodyPlaylistUpdatedPlural": "{0} heeft {2} nummers toegevoegd aan {1}.",
  "sNotificationBodyPlaylistUpdatedSingular": "{0} heeft een nummer toegevoegd aan {1}.",
  "sNotificationBodyToplistSubscribe": "{0} volgt nu je topnummers.",
  "sNotificationBodyToplistUpdatedName": "Topnummers",
  "sNotificationTitleSocialReactionPlay": "Nieuw afgespeeld",
  "sNotificationBodySocialReactionPlaySongShare": "{0} heeft het nummer afgespeeld dat je hebt gedeeld: {2} van {1}.",
  "sNotificationBodySocialReactionPlayAlbumShare": "{0} heeft het album afgespeeld dat je hebt gedeeld: {2} van {1}.",
  "sNotificationBodySocialReactionPlayArtistShare": "{0} heeft de artiest afgespeeld die je hebt gedeeld: {1}.",
  "sNotificationBodySocialReactionPlayPlaylistShare": "{0} heeft de afspeellijst afgespeeld die je hebt gedeeld: {1}.",
  "sNotificationBodySocialReactionPlaySongSocialStory": "{0} heeft {2} van {1} afgespeeld vanuit jouw activiteit.",
  "sNotificationBodySocialReactionPlayAlbumSocialStory": "{0} heeft {2} van {1} afgespeeld vanuit jouw activiteit.",
  "sNotificationBodySocialReactionPlayArtistSocialStory": "{0} heeft {1} afgespeeld vanuit jouw activiteit.",
  "sNotificationBodySocialReactionPlayPlaylistSocialStory": "{0} heeft een afspeellijst afgespeeld vanuit jouw activiteit: {1}.",
  "sNotificationTitleSocialReactionLike": "Nieuwe Vind ik leuk",
  "sNotificationBodySocialReactionLikeSongShare": "{0} vindt het nummer leuk dat je hebt gedeeld: {2} van {1}.",
  "sNotificationBodySocialReactionLikeAlbumShare": "{0} vindt het album leuk dat je hebt gedeeld: {2} van {1}.",
  "sNotificationBodySocialReactionLikeArtistShare": "{0} vindt de artiest leuk die je hebt gedeeld: {1}.",
  "sNotificationBodySocialReactionLikePlaylistShare": "{0} vindt de afspeellijst leuk die je hebt gedeeld: {1}.",
  "sNotificationBodySocialReactionLikeSongSocialStory": "{0} vindt {2} van {1} in je activiteit leuk.",
  "sNotificationBodySocialReactionLikeAlbumSocialStory": "{0} vindt {2} van {1} in je activiteit leuk.",
  "sNotificationBodySocialReactionLikeArtistSocialStory": "{0} vindt {1} in je activiteit leuk.",
  "sNotificationBodySocialReactionLikePlaylistSocialStory": "{0} vindt een afspeellijst in je activiteit leuk: {1}.",
  "sClearAllButton": "Alles wissen",
  "sLoadError": "Je meldingen kunnen op dit moment helaas niet worden getoond.",
  "sNoMoreMessage": "Je hebt geen meldingen.",
  "sTitle": "Meldingen",
  "s1Hour": "Ongeveer 1 uur geleden",
  "s1Minute": "Ongeveer 1 minuut geleden",
  "sDaysAgo": "{0} dagen geleden",
  "sHoursAgo": "{0} uur geleden",
  "sJustNow": "Zojuist",
  "sMinutesAgo": "{0} minuten geleden",
  "sOverAYear": "Meer dan een jaar geleden",
  "sSecondsAgo": "{0} seconden geleden",
  "sYesterday": "Gisteren",
  "ListTwo": "{0} en {1}",
  "ListStart": "{0}, {1}",
  "ListMiddle": "{0}, {1}",
  "ListEnd": "{0} en {1}"
};
},{}],15:[function(require,module,exports){
module.exports = {
  "sNotificationTitleAlbumReleased": "Wydany album",
  "sNotificationBodyAlbumReleased": "{0} - {1} jest już dostępny w Spotify.",
  "sNotificationBodyExclusiveAlbumReleased": "Ekskluzywne wydanie:<br>{0} wykonawcy {1} jest już dostępne, wyłącznie w Spotify.",
  "sNotificationTitleApplicationRelease": "Aktualizacja",
  "sNotificationBodyApplicationReleaseAndroid": "Dostępna jest już nowa wersja Spotify dla systemu Android.",
  "sNotificationBodyApplicationReleaseIOS": "Dostępna jest już nowa wersja Spotify dla systemu iOS.",
  "sNotificationBodyApplicationReleaseLink": "Możesz teraz używać Spotify w przeglądarce internetowej.",
  "sNotificationBodyApplicationReleaseMftLaunch": "Spotify jest dostępny bezpłatnie na telefonach komórkowych i tabletach.",
  "sNotificationBodyApplicationReleaseMftReminder": "Nie przegap — Spotify jest już dostępny bezpłatnie na dowolnym urządzeniu. Już teraz zainstaluj go na iPhonie, iPadzie i urządzeniu z systemem Android.",
  "sNotificationBodyApplicationReleaseMftSeason": "Masz nowego iPhona, iPada lub nowe urządzenie z systemem Android? Dowiedz się, jak słuchać za darmo.",
  "sNotificationTitleFriendJoined": "Dołączył Twój znajomy użytkownik",
  "sNotificationBodyFriendJoined": "Twój znajomy {0} właśnie dołączył do Spotify.",
  "sNotificationBodyMultipleAlbumsReleased": "Album {0} oraz {2} inne albumy wykonawcy {1} są już dostępne w Spotify.",
  "sNotificationBodyMultipleAlbumsReleasedSingular": "Album {0} oraz 1 inny album wykonawcy {1} są już dostępne w Spotify.",
  "sNotificationBodyMultipleExclusiveAlbumsReleased": "Ekskluzywne wydanie:<br>{0} oraz {2} inne albumy wykonawcy {1} są już dostępne, wyłącznie w Spotify.",
  "sNotificationBodyMultipleExclusiveAlbumsReleasedSingular": "Ekskluzywne wydanie:<br>{0} oraz 1 inny album wykonawcy {1} są już dostępne, wyłącznie w Spotify.",
  "sNotificationTitleMessagePlayed": "Odtworzony załącznik",
  "sNotificationBodyMessagePlayed": "Wysłany przez Ciebie załącznik został odtworzony przez {0}.",
  "sNotificationTitleNewFollower": "Nowy obserwator",
  "sNotificationBodyNewFollower": "Użytkownik {0} zaczął Cię obserwować.",
  "sNotificationTitlePlaylistSubscribe": "Nowa osoba obserwująca playlistę",
  "sNotificationBodyPlaylistSubscribe": "{0} obserwuje teraz Twoją playlistę: {1}.",
  "sNotificationTitlePlaylistUpdated": "Playlista została zaktualizowana",
  "sNotificationBodyPlaylistUpdatedPlural": "Użytkownik {0} dodał utwory ({2}) do: {1}.",
  "sNotificationBodyPlaylistUpdatedSingular": "Użytkownik {0} dodał utwór do {1}.",
  "sNotificationBodyToplistSubscribe": "{0} obserwuje teraz Twoje najlepsze utwory.",
  "sNotificationBodyToplistUpdatedName": "Najpopularniejsze utwory",
  "sNotificationTitleSocialReactionPlay": "Nowe odtworzenie",
  "sNotificationBodySocialReactionPlaySongShare": "Użytkownik {0} odtwarzał utwór, który udostępniasz: {1} wykonawcy {2}.",
  "sNotificationBodySocialReactionPlayAlbumShare": "Użytkownik {0} odtwarzał album, który udostępniasz: {2} wykonawcy {1}.",
  "sNotificationBodySocialReactionPlayArtistShare": "Użytkownik {0} odtwarzał muzykę wykonawcy, którego udostępniasz: {1}.",
  "sNotificationBodySocialReactionPlayPlaylistShare": "Użytkownik {0} odtwarzał playlistę, którą udostępniasz: {1}.",
  "sNotificationBodySocialReactionPlaySongSocialStory": "Użytkownik {0} odtwarzał {2} wykonawcy {1} spośród Twoich aktywności.",
  "sNotificationBodySocialReactionPlayAlbumSocialStory": "Użytkownik {0} odtwarzał {2} wykonawcy {1} spośród Twoich aktywności.",
  "sNotificationBodySocialReactionPlayArtistSocialStory": "Użytkownik {0} odtwarzał {1} z Twoich aktywności.",
  "sNotificationBodySocialReactionPlayPlaylistSocialStory": "Użytkownik {0} odtwarzał playlistę z Twoich aktywności: {1}.",
  "sNotificationTitleSocialReactionLike": "Nowe polubienie",
  "sNotificationBodySocialReactionLikeSongShare": "Użytkownik {0} lubi utwór, który udostępniasz: {1} – {2}.",
  "sNotificationBodySocialReactionLikeAlbumShare": "Użytkownik {0} lubi album, który udostępniasz: {2} – {1}.",
  "sNotificationBodySocialReactionLikeArtistShare": "Użytkownik {0} lubi wykonawcę, którego udostępniasz: {1}.",
  "sNotificationBodySocialReactionLikePlaylistShare": "Użytkownik {0} lubi playlistę, którą udostępniasz: {1}.",
  "sNotificationBodySocialReactionLikeSongSocialStory": "Użytkownik {0} lubi {2} – {1} z Twoich aktywności.",
  "sNotificationBodySocialReactionLikeAlbumSocialStory": "Użytkownik {0} lubi {2} – {1} z Twoich aktywności.",
  "sNotificationBodySocialReactionLikeArtistSocialStory": "Użytkownik {0} lubi {1} z Twoich aktywności.",
  "sNotificationBodySocialReactionLikePlaylistSocialStory": "Użytkownik {0} lubi playlistę z Twoich aktywności: {1}.",
  "sClearAllButton": "Wyczyść wszystko.",
  "sLoadError": "Niestety nie możemy w tej chwili uzyskać Twoich powiadomień.",
  "sNoMoreMessage": "Nie masz żadnych powiadomień.",
  "sTitle": "Powiadomienia",
  "s1Hour": "Około 1 godziny temu",
  "s1Minute": "Około 1 minuty temu",
  "sDaysAgo": "{0} dni temu",
  "sHoursAgo": "{0} godz. temu",
  "sJustNow": "Właśnie teraz",
  "sMinutesAgo": "{0} minut(y) temu",
  "sOverAYear": "Ponad rok temu",
  "sSecondsAgo": "{0} sek. temu",
  "sYesterday": "Wczoraj",
  "ListTwo": "{0} i {1}",
  "ListStart": "{0}, {1}",
  "ListMiddle": "{0}, {1}",
  "ListEnd": "{0} i {1}"
};
},{}],16:[function(require,module,exports){
module.exports = {
  "sNotificationTitleAlbumReleased": "Álbum lançado",
  "sNotificationBodyAlbumReleased": "Agora {0} de {1} está disponível no Spotify.",
  "sNotificationBodyExclusiveAlbumReleased": "Lançamento exclusivo:<br>Agora {0} de {1} está disponível exclusivamente no Spotify.",
  "sNotificationTitleApplicationRelease": "Atualização",
  "sNotificationBodyApplicationReleaseAndroid": "Está disponível uma nova versão do Spotify para Android.",
  "sNotificationBodyApplicationReleaseIOS": "Está disponível uma nova versão do Spotify para iOS.",
  "sNotificationBodyApplicationReleaseLink": "Agora você pode usar o Spotify em seu navegador da Web.",
  "sNotificationBodyApplicationReleaseMftLaunch": "Agora o Spotify é grátis no celular e no tablet!",
  "sNotificationBodyApplicationReleaseMftReminder": "Não perca - agora o Spotify é grátis em todos os dispositivos. Instale agora no iPhone, iPad e Android.",
  "sNotificationBodyApplicationReleaseMftSeason": "Você tem um iPhone, iPad ou Android novo? Descubra como ouvir de graça.",
  "sNotificationTitleFriendJoined": "Amigo que entrou",
  "sNotificationBodyFriendJoined": "Seu amigo {0} acabou de entrar no Spotify.",
  "sNotificationBodyMultipleAlbumsReleased": "Agora {0} e {2} outros álbuns de {1} estão disponíveis no Spotify.",
  "sNotificationBodyMultipleAlbumsReleasedSingular": "Agora {0} e 1 outro álbum de {1} estão disponíveis no Spotify.",
  "sNotificationBodyMultipleExclusiveAlbumsReleased": "Lançamento exclusivo:<br>Agora {0} e {2} outros álbuns de {1} estão disponíveis exclusivamente no Spotify.",
  "sNotificationBodyMultipleExclusiveAlbumsReleasedSingular": "Lançamento exclusivo:<br>Agora {0} e 1 outro álbum de {1} estão disponíveis exclusivamente no Spotify.",
  "sNotificationTitleMessagePlayed": "Anexo tocado",
  "sNotificationBodyMessagePlayed": "{0} tocou o anexo que você mandou.",
  "sNotificationTitleNewFollower": "Novo seguidor",
  "sNotificationBodyNewFollower": "{0} começou a seguir você.",
  "sNotificationTitlePlaylistSubscribe": "Novo seguidor de playlists",
  "sNotificationBodyPlaylistSubscribe": "Agora {0} está seguindo sua playlist: {1}.",
  "sNotificationTitlePlaylistUpdated": "Playlist atualizada",
  "sNotificationBodyPlaylistUpdatedPlural": "{0} adicionou {2} músicas a {1}.",
  "sNotificationBodyPlaylistUpdatedSingular": "{0} adicionou uma música a {1}.",
  "sNotificationBodyToplistSubscribe": "{0} começou a seguir suas músicas mais tocadas.",
  "sNotificationBodyToplistUpdatedName": "Músicas mais tocadas",
  "sNotificationTitleSocialReactionPlay": "Alguém ouviu você",
  "sNotificationBodySocialReactionPlaySongShare": "{0} tocou a música que você compartilhou: {2} de {1}.",
  "sNotificationBodySocialReactionPlayAlbumShare": "{0} tocou o álbum que você compartilhou: {2} de {1}.",
  "sNotificationBodySocialReactionPlayArtistShare": "{0} tocou o artista que você compartilhou: {1}.",
  "sNotificationBodySocialReactionPlayPlaylistShare": "{0} tocou a playlist que você compartilhou: {1}.",
  "sNotificationBodySocialReactionPlaySongSocialStory": "{0} tocou {2} de {1} a partir de sua atividade.",
  "sNotificationBodySocialReactionPlayAlbumSocialStory": "{0} tocou {2} de {1} a partir de sua atividade.",
  "sNotificationBodySocialReactionPlayArtistSocialStory": "{0} tocou {1} a partir de sua atividade.",
  "sNotificationBodySocialReactionPlayPlaylistSocialStory": "{0} tocou uma playlist a partir de sua atividade: {1}.",
  "sNotificationTitleSocialReactionLike": "Alguém curtiu você",
  "sNotificationBodySocialReactionLikeSongShare": "{0} curtiu a música que você compartilhou: {2} de {1}.",
  "sNotificationBodySocialReactionLikeAlbumShare": "{0} curtiu o álbum que você compartilhou: {2} de {1}.",
  "sNotificationBodySocialReactionLikeArtistShare": "{0} curtiu o artista que você compartilhou: {1}.",
  "sNotificationBodySocialReactionLikePlaylistShare": "{0} curtiu a playlist que você compartilhou: {1}.",
  "sNotificationBodySocialReactionLikeSongSocialStory": "{0} curtiu {2} de {1} de sua atividade.",
  "sNotificationBodySocialReactionLikeAlbumSocialStory": "{0} curtiu {2} de {1} de sua atividade.",
  "sNotificationBodySocialReactionLikeArtistSocialStory": "{0} curtiu {1} de sua atividade.",
  "sNotificationBodySocialReactionLikePlaylistSocialStory": "{0} curtiu uma playlist de sua atividade: {1}.",
  "sClearAllButton": "Limpar tudo",
  "sLoadError": "Desculpe. Não conseguimos pegar suas notificações agora.",
  "sNoMoreMessage": "Você não tem nenhuma notificação.",
  "sTitle": "Notificações",
  "s1Hour": "Cerca de 1 hora atrás",
  "s1Minute": "Cerca de 1 minuto atrás",
  "sDaysAgo": "{0} dias atrás",
  "sHoursAgo": "{0} horas atrás",
  "sJustNow": "Agora mesmo",
  "sMinutesAgo": "{0} minutos atrás",
  "sOverAYear": "Mais de um ano atrás",
  "sSecondsAgo": "{0} segundos atrás",
  "sYesterday": "Ontem",
  "ListTwo": "{0} e {1}",
  "ListStart": "{0}, {1}",
  "ListMiddle": "{0}, {1}",
  "ListEnd": "{0} e {1}"
};
},{}],17:[function(require,module,exports){
module.exports = {
  "sNotificationTitleAlbumReleased": "Nytt album ute",
  "sNotificationBodyAlbumReleased": "Nu finns {0} av {1} på Spotify.",
  "sNotificationBodyExclusiveAlbumReleased": "Exklusiv release:<br>Nu finns {0} av {1} exklusivt på Spotify.",
  "sNotificationTitleApplicationRelease": "Uppdatera",
  "sNotificationBodyApplicationReleaseAndroid": "En ny version av Spotify för Android är tillgänglig.",
  "sNotificationBodyApplicationReleaseIOS": "En ny version av Spotify för iOS är tillgänglig.",
  "sNotificationBodyApplicationReleaseLink": "Nu kan du använda Spotify i webbläsaren.",
  "sNotificationBodyApplicationReleaseMftLaunch": "Nu är Spotify gratis på mobilen och surfplattan!",
  "sNotificationBodyApplicationReleaseMftReminder": "Missa inte att Spotify nu är gratis nästan överallt. Installera Spotify på iPhone, iPad och Android.",
  "sNotificationBodyApplicationReleaseMftSeason": "Har du en ny iPhone, iPad eller Android? Ta reda på hur du kan lyssna gratis.",
  "sNotificationTitleFriendJoined": "En vän har skaffat Spotify",
  "sNotificationBodyFriendJoined": "Din vän {0} har precis skaffat Spotify.",
  "sNotificationBodyMultipleAlbumsReleased": "Nu finns {0} och {2} andra album av {1} på Spotify.",
  "sNotificationBodyMultipleAlbumsReleasedSingular": "Nu finns {0} och ett annat album av {1} på Spotify.",
  "sNotificationBodyMultipleExclusiveAlbumsReleased": "Exklusiv release:<br>Nu finns {0} och {2} andra album av {1} exklusivt på Spotify.",
  "sNotificationBodyMultipleExclusiveAlbumsReleasedSingular": "Exklusiv release:<br>Nu finns {0} och ett annat album av {1} exklusivt på Spotify.",
  "sNotificationTitleMessagePlayed": "Bifogad musik har spelats",
  "sNotificationBodyMessagePlayed": "{0} har spelat den bifogade musiken som du skickade.",
  "sNotificationTitleNewFollower": "Ny följare",
  "sNotificationBodyNewFollower": "{0} har börjat följa dig.",
  "sNotificationTitlePlaylistSubscribe": "Ny spellisteföljare",
  "sNotificationBodyPlaylistSubscribe": "{0} följer nu din spellista: {1}.",
  "sNotificationTitlePlaylistUpdated": "Spellistan har uppdaterats",
  "sNotificationBodyPlaylistUpdatedPlural": "{0} har lagt till {2} låtar i {1}.",
  "sNotificationBodyPlaylistUpdatedSingular": "{0} har lagt till en låt i {1}.",
  "sNotificationBodyToplistSubscribe": "{0} följer nu dina populäraste låtar.",
  "sNotificationBodyToplistUpdatedName": "Topplåtar",
  "sNotificationTitleSocialReactionPlay": "Ny uppspelning",
  "sNotificationBodySocialReactionPlaySongShare": "{0} har spelat spåret du delade: {2} av {1}.",
  "sNotificationBodySocialReactionPlayAlbumShare": "{0} har spelat albumet du delade: {2} av {1}.",
  "sNotificationBodySocialReactionPlayArtistShare": "{0} har spelat artisten du delade: {1}.",
  "sNotificationBodySocialReactionPlayPlaylistShare": "{0} har spelat spellistan du delade: {1}.",
  "sNotificationBodySocialReactionPlaySongSocialStory": "{0} har spelat {2} av {1} från din aktivitet.",
  "sNotificationBodySocialReactionPlayAlbumSocialStory": "{0} har spelat {2} av {1} från din aktivitet.",
  "sNotificationBodySocialReactionPlayArtistSocialStory": "{0} har spelat {1} från din aktivitet.",
  "sNotificationBodySocialReactionPlayPlaylistSocialStory": "{0} har spelat en spellista från din aktivitet: {1}.",
  "sNotificationTitleSocialReactionLike": "Ny gilla-markering",
  "sNotificationBodySocialReactionLikeSongShare": "{0} har gillat spåret du delade: {2} av {1}.",
  "sNotificationBodySocialReactionLikeAlbumShare": "{0} har gillat albumet du delade: {2} av {1}.",
  "sNotificationBodySocialReactionLikeArtistShare": "{0} har gillat artisten du delade: {1}.",
  "sNotificationBodySocialReactionLikePlaylistShare": "{0} har gillat spellistan du delade: {1}.",
  "sNotificationBodySocialReactionLikeSongSocialStory": "{0} har gillat {2} av {1} från din aktivitet.",
  "sNotificationBodySocialReactionLikeAlbumSocialStory": "{0} har gillat {2} av {1} från din aktivitet.",
  "sNotificationBodySocialReactionLikeArtistSocialStory": "{0} har gillat {1} från din aktivitet.",
  "sNotificationBodySocialReactionLikePlaylistSocialStory": "{0} har gillat en spellista från din aktivitet: {1}.",
  "sClearAllButton": "Radera alla",
  "sLoadError": "Tyvärr kan vi inte hämta dina meddelanden just nu.",
  "sNoMoreMessage": "Du har inga meddelanden.",
  "sTitle": "Notifieringar",
  "s1Hour": "För ungefär en timme sedan",
  "s1Minute": "För ungefär en minut sedan",
  "sDaysAgo": "För {0} dagar sedan",
  "sHoursAgo": "För {0} timmar sedan",
  "sJustNow": "Nu",
  "sMinutesAgo": "För {0} minuter sedan",
  "sOverAYear": "För mer än ett år sedan",
  "sSecondsAgo": "För {0} sekunder sedan",
  "sYesterday": "I går",
  "ListTwo": "{0} och {1}",
  "ListStart": "{0}, {1}",
  "ListMiddle": "{0}, {1}",
  "ListEnd": "{0} och {1}"
};
},{}],18:[function(require,module,exports){
module.exports = {
  "sNotificationTitleAlbumReleased": "Çıkan Albüm",
  "sNotificationBodyAlbumReleased": "{0} - {1} şimdi Spotify'da.",
  "sNotificationBodyExclusiveAlbumReleased": "Özel:<br>{0} - {1} şimdi yalnızca Spotify'da.",
  "sNotificationTitleApplicationRelease": "Güncelleme",
  "sNotificationBodyApplicationReleaseAndroid": "Android için yeni bir Spotify sürümü şimdi kullanılabilir.",
  "sNotificationBodyApplicationReleaseIOS": "iOS için yeni bir Spotify sürümü şimdi kullanılabilir.",
  "sNotificationBodyApplicationReleaseLink": "Artık Spotify'ı web tarayıcında kullanabilirsin.",
  "sNotificationBodyApplicationReleaseMftLaunch": "Spotify şimdi cep telefonu ve tabletlerde ücretsiz!",
  "sNotificationBodyApplicationReleaseMftReminder": "Kaçırma - Spotify şimdi her yerde ücretsiz. iPhone, iPad ve Android'e yükle.",
  "sNotificationBodyApplicationReleaseMftSeason": "Yeni bir iPhone, iPad veya Android'in mi var? Ücretsiz dinlemenin yolunu öğren.",
  "sNotificationTitleFriendJoined": "Arkadaşın Katıldı",
  "sNotificationBodyFriendJoined": "Arkadaşın {0} Spotify'a katıldı.",
  "sNotificationBodyMultipleAlbumsReleased": "{1} - {0} ve {2}  albümü daha şimdi Spotify'da.",
  "sNotificationBodyMultipleAlbumsReleasedSingular": "{1} - {0} ve 1 albümü daha şimdi Spotify'da.",
  "sNotificationBodyMultipleExclusiveAlbumsReleased": "Özel:<br>{0} - {1} ve {2} diğer albümü şimdi yalnızca Spotify'da.",
  "sNotificationBodyMultipleExclusiveAlbumsReleasedSingular": "Özel:<br>{0} - {1} ve 1 albümü daha şimdi yalnızca Spotify'da.",
  "sNotificationTitleMessagePlayed": "Ek Çalındı",
  "sNotificationBodyMessagePlayed": "{0} gönderdiğin eki çaldı.",
  "sNotificationTitleNewFollower": "Yeni Takipçi",
  "sNotificationBodyNewFollower": "{0} seni takip etmeye başladı",
  "sNotificationTitlePlaylistSubscribe": "Yeni Çalma Listesi Takipçisi",
  "sNotificationBodyPlaylistSubscribe": "{0} çalma listeni takip ediyor: {1}.",
  "sNotificationTitlePlaylistUpdated": "Çalma Listesi Güncellendi",
  "sNotificationBodyPlaylistUpdatedPlural": "{0}, {2} şarkıyı {1} listesine ekledi.",
  "sNotificationBodyPlaylistUpdatedSingular": "{0}, {1} listesine bir şarkı ekledi.",
  "sNotificationBodyToplistSubscribe": "{0} en çok dinlenen şarkılarını takip ediyor.",
  "sNotificationBodyToplistUpdatedName": "En Çok Dinlenen Şarkılar",
  "sNotificationTitleSocialReactionPlay": "Yeni Çalınan",
  "sNotificationBodySocialReactionPlaySongShare": "{0} paylaştığın bir şarkıyı çaldı: {2} - {1}.",
  "sNotificationBodySocialReactionPlayAlbumShare": "{0} paylaştığın bir albümü çaldı: {2} - {1}.",
  "sNotificationBodySocialReactionPlayArtistShare": "{0} paylaştığın bir sanatçıyı çaldı: {1}.",
  "sNotificationBodySocialReactionPlayPlaylistShare": "{0} paylaştığın bir çalma listesini çaldı: {1}.",
  "sNotificationBodySocialReactionPlaySongSocialStory": "{0} hareketinden {2} - {1} parçasını çaldı.",
  "sNotificationBodySocialReactionPlayAlbumSocialStory": "{0} hareketinden {2} - {1} parçasını çaldı.",
  "sNotificationBodySocialReactionPlayArtistSocialStory": "{0} hareketinden  {1} parçasını çaldı.",
  "sNotificationBodySocialReactionPlayPlaylistSocialStory": "{0} şu hareketinden bir çalma listesi çaldı: {1}.",
  "sNotificationTitleSocialReactionLike": "Yeni Beğenme",
  "sNotificationBodySocialReactionLikeSongShare": "{0} paylaştığın bir şarkıyı beğendi: {2} - {1}.",
  "sNotificationBodySocialReactionLikeAlbumShare": "{0} paylaştığın bir albümü beğendi: {2} - {1}.",
  "sNotificationBodySocialReactionLikeArtistShare": "{0} paylaştığın bir sanatçıyı beğendi: {1}.",
  "sNotificationBodySocialReactionLikePlaylistShare": "{0} paylaştığın bir çalma listesini beğendi: {1}.",
  "sNotificationBodySocialReactionLikeSongSocialStory": "{0} hareketinden {2} - {1} parçasını beğendi.",
  "sNotificationBodySocialReactionLikeAlbumSocialStory": "{0} hareketinden {2} - {1} parçasını beğendi.",
  "sNotificationBodySocialReactionLikeArtistSocialStory": "{0} hareketinden {1} parçasını beğendi.",
  "sNotificationBodySocialReactionLikePlaylistSocialStory": "{0} hareketinden bir çalma listesini beğendi: {1}.",
  "sClearAllButton": "Tümünü Temizle",
  "sLoadError": "Üzgünüz. Bildirimlerini şu anda alamıyoruz.",
  "sNoMoreMessage": "Hiç bildirimin yok.",
  "sTitle": "Bildirimler",
  "s1Hour": "Yaklaşık bir saat önce",
  "s1Minute": "Yaklaşık bir dakika önce",
  "sDaysAgo": "{0} gün önce",
  "sHoursAgo": "{0} saat önce",
  "sJustNow": "Şu anda",
  "sMinutesAgo": "{0} dakika önce",
  "sOverAYear": "Yaklaşık bir yıl önce",
  "sSecondsAgo": "{0} saniye önce",
  "sYesterday": "Dün",
  "ListTwo": "{0} ve {1}",
  "ListStart": "{0}, {1}",
  "ListMiddle": "{0}, {1}",
  "ListEnd": "{0} ve {1}"
};
},{}],19:[function(require,module,exports){
module.exports = {
  "sNotificationTitleAlbumReleased": "專輯發行",
  "sNotificationBodyAlbumReleased": "{1} 的 {0} 已在 Spotify 上架。",
  "sNotificationBodyExclusiveAlbumReleased": "獨家發行：<br> {1} 的 {0} 目前獨家在 Spotify 上推出。",
  "sNotificationTitleApplicationRelease": "更新",
  "sNotificationBodyApplicationReleaseAndroid": "Spotify 最新的 Android 版本已推出。",
  "sNotificationBodyApplicationReleaseIOS": "Spotify 最新的 iOS 版本已推出。",
  "sNotificationBodyApplicationReleaseLink": "你現在可以在網路瀏覽器使用 Spotify。",
  "sNotificationBodyApplicationReleaseMftLaunch": "現在可以在行動裝置和平板上免費使用 Spotify！",
  "sNotificationBodyApplicationReleaseMftReminder": "別錯過了，Spotify 現在到哪都免費。立即安裝在 iPhone、iPad 和 Android。",
  "sNotificationBodyApplicationReleaseMftSeason": "買了新的 iPhone、iPad 或 Android？ 了解如何免費聽音樂。",
  "sNotificationTitleFriendJoined": "你有好友加入",
  "sNotificationBodyFriendJoined": "你的好友 {0} 剛加入了 Spotify。",
  "sNotificationBodyMultipleAlbumsReleased": "{1} 的 {0} 與 {2} 其他專輯目前獨家在 Spotify 上推出。",
  "sNotificationBodyMultipleAlbumsReleasedSingular": "{1} 的 {0} 與另外一張專輯目前獨家在 Spotify 上推出。",
  "sNotificationBodyMultipleExclusiveAlbumsReleased": "獨家發行：<br>{1} 的 {0} 與另外 {2} 張專輯目前獨家在 Spotify 上推出。",
  "sNotificationBodyMultipleExclusiveAlbumsReleasedSingular": "獨家發行：<br>{1} 的 {0} 與另外一張專輯目前獨家在 Spotify 上推出。",
  "sNotificationTitleMessagePlayed": "附件已播放",
  "sNotificationBodyMessagePlayed": "{0} 已播放你傳送的附件。",
  "sNotificationTitleNewFollower": "新粉絲",
  "sNotificationBodyNewFollower": "{0} 開始關注你。",
  "sNotificationTitlePlaylistSubscribe": "最新播放清單粉絲",
  "sNotificationBodyPlaylistSubscribe": "{0} 正在關注你的播放清單：{1}。",
  "sNotificationTitlePlaylistUpdated": "播放清單已更新",
  "sNotificationBodyPlaylistUpdatedPlural": "{0} 新增了 {2} 首歌曲至 {1}。",
  "sNotificationBodyPlaylistUpdatedSingular": "{0} 新增了一首歌曲至 {1}。",
  "sNotificationBodyToplistSubscribe": "{0} 正在關注你的熱門歌曲。",
  "sNotificationBodyToplistUpdatedName": "當紅歌曲",
  "sNotificationTitleSocialReactionPlay": "最新播放",
  "sNotificationBodySocialReactionPlaySongShare": "{0} 播放了你分享的歌曲：{2}-{1}。",
  "sNotificationBodySocialReactionPlayAlbumShare": "{0} 播放了你分享的專輯：{2}-{1}。",
  "sNotificationBodySocialReactionPlayArtistShare": "{0} 播放你分享的藝人：{1}。",
  "sNotificationBodySocialReactionPlayPlaylistShare": "{0} 播放了你分享的播放清單：{1}。 ",
  "sNotificationBodySocialReactionPlaySongSocialStory": "{0} 播放了你個人動態裡的 {2}-{1}。",
  "sNotificationBodySocialReactionPlayAlbumSocialStory": "{0} 播放了你個人動態裡的 {2}-{1}。",
  "sNotificationBodySocialReactionPlayArtistSocialStory": "{0} 播放了你個人動態裡的 {1}。",
  "sNotificationBodySocialReactionPlayPlaylistSocialStory": "{0} 播放了你個人動態：{1} 中的播放清單。",
  "sNotificationTitleSocialReactionLike": "最新按讚",
  "sNotificationBodySocialReactionLikeSongShare": "{0} 對你分享的歌曲：{2}-{1} 說了讚。",
  "sNotificationBodySocialReactionLikeAlbumShare": "{0} 對你分享的專輯：{2}-{1} 說了讚。",
  "sNotificationBodySocialReactionLikeArtistShare": "{0} 對你分享的藝人：{1} 說了讚。",
  "sNotificationBodySocialReactionLikePlaylistShare": "{0} 對你分享的播放清單：{1} 說了讚。",
  "sNotificationBodySocialReactionLikeSongSocialStory": "{0} 對你個人動態裡的 {2}-{1} 說了讚。",
  "sNotificationBodySocialReactionLikeAlbumSocialStory": "{0} 對你個人動態裡的 {2}-{1} 說了讚。",
  "sNotificationBodySocialReactionLikeArtistSocialStory": "{0} 對你個人動態裡的 {1} 說了讚。",
  "sNotificationBodySocialReactionLikePlaylistSocialStory": "{0} 對你個人動態的播放清單：{1} 說了讚。",
  "sClearAllButton": "清除全部",
  "sLoadError": "很抱歉，我們現在無法獲得你的通知。",
  "sNoMoreMessage": "你沒有任何通知。",
  "sTitle": "通知",
  "s1Hour": "約 1 小時前",
  "s1Minute": "約 1 分鐘前",
  "sDaysAgo": "{0} 天前",
  "sHoursAgo": "{0} 小時前",
  "sJustNow": "剛剛",
  "sMinutesAgo": "{0} 分鐘前",
  "sOverAYear": "超過一年前",
  "sSecondsAgo": "{0} 秒前",
  "sYesterday": "昨天",
  "ListTwo": "{1} 和 {0}",
  "ListStart": "{0}, {1}",
  "ListMiddle": "{0}, {1}",
  "ListEnd": "{0}, 和 {1}"
};
},{}],20:[function(require,module,exports){
module.exports = {
  "sNotificationTitleAlbumReleased": "Album Dikeluarkan",
  "sNotificationBodyAlbumReleased": "{0} oleh {1} kini tersedia di Spotify.",
  "sNotificationBodyExclusiveAlbumReleased": "Keluaran eksklusif:<br>{0} oleh {1} kini tersedia secara eksklusif di Spotify.",
  "sNotificationTitleApplicationRelease": "Kemas Kini",
  "sNotificationBodyApplicationReleaseAndroid": "Versi baru Spotify untuk Android kini tersedia.​",
  "sNotificationBodyApplicationReleaseIOS": "Versi baru Spotify untuk iOS kini tersedia.",
  "sNotificationBodyApplicationReleaseLink": "Anda kini boleh menggunakan Spotify dalam pelayar web anda.",
  "sNotificationBodyApplicationReleaseMftLaunch": "Spotify kini percuma pada mudah alih dan tablet!",
  "sNotificationBodyApplicationReleaseMftReminder": "Jangan ketinggalan - Spotify kini percuma di mana sahaja. Pasang sekarang pada iPhone, iPad dan Android.",
  "sNotificationBodyApplicationReleaseMftSeason": "Mendapat iPhone baru, iPad atau Android?  Ketahui cara untuk mendengar secara percuma.",
  "sNotificationTitleFriendJoined": "Rakan yang Menyertai",
  "sNotificationBodyFriendJoined": "Rakan anda {0} baru menyertai Spotify.",
  "sNotificationBodyMultipleAlbumsReleased": "{0} dan {2} album lain oleh {1} kini tersedia di Spotify.",
  "sNotificationBodyMultipleAlbumsReleasedSingular": "{0} dan 1 album lain oleh {1} kini tersedia di Spotify.",
  "sNotificationBodyMultipleExclusiveAlbumsReleased": "Keluaran eksklusif:<br>{0} dan {2} album lain oleh {1} kini tersedia secara eksklusif di Spotify.",
  "sNotificationBodyMultipleExclusiveAlbumsReleasedSingular": "Keluaran ekslusif:<br>{0} dan 1 album lain oleh {1} kini tersedia secara eksklusif di Spotify.",
  "sNotificationTitleMessagePlayed": "Lampiran Dimainkan",
  "sNotificationBodyMessagePlayed": "{0} lampiran yang anda hantar dimainkan.",
  "sNotificationTitleNewFollower": "Pengikut Baru",
  "sNotificationBodyNewFollower": "{0} mulai mengikuti anda.",
  "sNotificationTitlePlaylistSubscribe": "Pengikut Senarai main Baru",
  "sNotificationBodyPlaylistSubscribe": "{0} kini mengikuti senarai main anda: {1}.",
  "sNotificationTitlePlaylistUpdated": "Senarai main Dikemaskini",
  "sNotificationBodyPlaylistUpdatedPlural": "{0} menambah {2} lagu ke {1}.",
  "sNotificationBodyPlaylistUpdatedSingular": "{0} menambah lagu ke {1}.",
  "sNotificationBodyToplistSubscribe": "{0} kini mengikuti lagu paling popular anda.",
  "sNotificationBodyToplistUpdatedName": "Lagu Popular",
  "sNotificationTitleSocialReactionPlay": "Main Baharu",
  "sNotificationBodySocialReactionPlaySongShare": "{0} memainkan lagu yang anda kongsi: {2} oleh {1}.",
  "sNotificationBodySocialReactionPlayAlbumShare": "{0} memainkan album yang anda kongsi: {2} oleh {1}.",
  "sNotificationBodySocialReactionPlayArtistShare": "{0} memainkan artis yang anda kongsi: {1}.",
  "sNotificationBodySocialReactionPlayPlaylistShare": "{0} memainkan senarai main yang anda kongsi: {1}.",
  "sNotificationBodySocialReactionPlaySongSocialStory": "{0} memainkan {2} oleh {1} daripada aktiviti anda.",
  "sNotificationBodySocialReactionPlayAlbumSocialStory": "{0} memainkan {2} oleh {1} daripada aktiviti anda.",
  "sNotificationBodySocialReactionPlayArtistSocialStory": "{0} memainkan {1} daripada aktiviti anda.",
  "sNotificationBodySocialReactionPlayPlaylistSocialStory": "{0} memainkan senarai main daripada aktiviti anda: {1}.",
  "sNotificationTitleSocialReactionLike": "Suka Baru",
  "sNotificationBodySocialReactionLikeSongShare": "{0} menyukai lagu yang anda kongsi: {2} oleh {1}.",
  "sNotificationBodySocialReactionLikeAlbumShare": "{0} menyukai album yang anda kongsi: {2} oleh {1}.",
  "sNotificationBodySocialReactionLikeArtistShare": "{0} menyukai artis yang anda kongsi: {1}.",
  "sNotificationBodySocialReactionLikePlaylistShare": "{0} menyukai senarai main yang anda kongsi: {1}.",
  "sNotificationBodySocialReactionLikeSongSocialStory": "{0} menyukai {2} oleh {1} dari aktiviti anda.",
  "sNotificationBodySocialReactionLikeAlbumSocialStory": "{0} menyukai {2} oleh {1} dari aktiviti anda.",
  "sNotificationBodySocialReactionLikeArtistSocialStory": "{0} menyukai {1} dari aktiviti anda.",
  "sNotificationBodySocialReactionLikePlaylistSocialStory": "{0} menyukai senarai main dari aktiviti anda: {1}.",
  "sClearAllButton": "Kosongkan Semua",
  "sLoadError": "Maaf. Kami tidak mendapat pemberitahuan anda sekarang.",
  "sNoMoreMessage": "Anda tidak mempunyai sebarang pemberitahuan.",
  "sTitle": "Pemberitahuan",
  "s1Hour": "Lebih kurang 1 jam yang lalu",
  "s1Minute": "Lebih kurang 1 minit yang lalu",
  "sDaysAgo": "{0} hari yang lalu",
  "sHoursAgo": "{0} jam yang lalu",
  "sJustNow": "Baru sahaja",
  "sMinutesAgo": "{0} minit yang lalu",
  "sOverAYear": "Lebih setahun yang lalu",
  "sSecondsAgo": "{0} saat yang lalu",
  "sYesterday": "Semalam",
  "ListTwo": "{0} dan {1}",
  "ListStart": "{0}, {1}",
  "ListMiddle": "{0}, {1}",
  "ListEnd": "{0}, dan {1}"
};
},{}],21:[function(require,module,exports){
module.exports={
  "name": "notification-center",
  "version": "2.9.1",
  "license": "UNLICENSED",
  "main": "scripts/main.js",
  "publishConfig": {
    "registry": "http://npm-registry.spotify.net"
  },
  "private": true
}

},{}],22:[function(require,module,exports){
'use strict';

var Config = require('./config').Config;
var Notification = require('./notification').Notification;
var debug = Config.getDebug();

/**
 * Notifications cache constructor.
 * @param {string} username User name to identify the cache.
 * @param {string} localStorageKey Key to be used in local storage.
 * @param {number} maxSize Maximum size of the cache.
 * @constructor
 */
function NotificationsCache(username, localStorageKey, maxSize) {

  /**
   * User name to identify the cache.
   * @type {string}
   * @private
   */
  this._username = username;

  /**
   * Local storage key where serialized notifications are stored.
   * @type {string}
   * @private
   */
  this._localStorageKey = localStorageKey || 'notifications';

  /**
   * Max size of the cache. When maximum size is reached, oldest notifications are removed whenever
   * new ones are added.
   * @type {number}
   * @private
   */
  this._maxSize = maxSize || 500;

  /**
   * Array of cached notifications. First element is the newest, last is the oldest.
   * @type {Notification[]}
   * @private
   */
  this._notifications = [];
}

/**
 * Loads the array of cached notifications from local storage.
 */
NotificationsCache.prototype.loadFromLocalStorage = function () {
  this._notifications = [];
  if (window.localStorage) {
    try {
      var rawNotifications = JSON.parse(window.localStorage.getItem(this._getStorageKey())) || [];
      for (var i = 0, l = rawNotifications.length; i < l; i++) {
        this._notifications[i] = Notification.createNotification(rawNotifications[i]);
      }
      debug('Notifications loaded into memory from local storage', { amount: this._notifications.length });
    } catch (e) {
      this.flush();
      debug('Cache was flushed due to malformed notifications in it');
    }
  } else {
    debug('Local storage is not available');
  }
};

/**
 * Resets memory and local storage cache to a pristine state.
 */
NotificationsCache.prototype.flush = function () {
  this._notifications = [];
  this.persist();
  debug('The local storage cache was flushed');
};

/**
 * Stores the array of cached notifications in local storage. Only the notification's raw data is stored.
 * When loading from local storage, the Notification objects will be recreated from the data.
 */
NotificationsCache.prototype.persist = function () {
  if (window.localStorage) {
    var noteArray = [];
    for (var i = 0, l = this._notifications.length; i < l; i++) {
      noteArray.push(this._notifications[i].getData());
    }
    window.localStorage.setItem(this._getStorageKey(), JSON.stringify(noteArray));
  }
};

/**
 * Adds a new notification to the cache. Does nothing if the notification already exists.
 * @param {Notification} notification The notification to be added to the cache.
 */
NotificationsCache.prototype.addNotification = function (notification) {
  var timeStamp = notification.getTimeStamp();
  var idHex = notification.getIdHex();
  var index = -1;
  var exists = false;

  for (var i = 0, l = this._notifications.length; i < l; i++) {
    if (index == -1 && timeStamp > this._notifications[i].getTimeStamp()) {
      index = i;
    }
    if (this._notifications[i].getIdHex() == idHex) {
      exists = true;
      break;
    }
  }

  if (!exists) {
    if (index == -1) {
      this._notifications.push(notification);
    } else {
      this._notifications.splice(index, 0, notification);
    }
    this._trim();
  }
};

/**
 * Marks all cached notifications as read.
 */
NotificationsCache.prototype.markAllAsRead = function () {
  for (var i = 0, l = this._notifications.length; i < l; i++) {
    this._notifications[i].markAsRead();
  }
  this.persist();
};

/**
 * Returns a page of notifications.
 * @param {string} beforeId Return notifications older than this ID.
 * @param {number} amount Amount of notifications to be returned.
 * @return {Notification[]} An array of notification objects.
 */
NotificationsCache.prototype.getNotifications = function (beforeId, amount) {
  var beforeIdIndex = -1;
  for (var i = 0, l = this._notifications.length; i < l; i++) {
    if (this._notifications[i].getIdHex() === beforeId) {
      beforeIdIndex = i;
      break;
    }
  }
  if (beforeIdIndex > -1 && beforeIdIndex < this._notifications.length - 1) {
    return this._notifications.slice(beforeIdIndex + 1, beforeIdIndex + 1 + amount);
  } else {
    return [];
  }
};

/**
 * Returns the newest notifications.
 * @param {number} amount Number of notifications to be retrieved.
 * @return {Notification[]} Newest notifications.
 */
NotificationsCache.prototype.getNewestNotifications = function (amount) {
  return this._notifications.slice(0, amount);
};

/**
 * Returns all notifications stored in cache.
 * @return {Notification[]} All notifications stored in cache.
 */
NotificationsCache.prototype.getAllNotifications = function () {
  return this._notifications;
};

/**
 * Returns the id of the newest notification stored in cache.
 * @return {string} Id of the newest notification in cache.
 */
NotificationsCache.prototype.getNewestNotificationId = function () {
  return this._notifications[0] ? this._notifications[0].getIdHex() : null;
};

/**
 * Returns the id of the oldest notification stored in cache.
 * @return {string} Id of the oldest notification in cache.
 */
NotificationsCache.prototype.getOldestNotificationId = function () {
  return this._notifications[this._notifications.length - 1] ? this._notifications[this._notifications.length - 1].getIdHex() : null;
};

/**
 * Trims the cache to a maximum size, removing old notifications if needed.
 * @private
 */
NotificationsCache.prototype._trim = function () {
  if (this._notifications.length > this._maxSize) {
    this._notifications.splice(this._maxSize);
  }
};

NotificationsCache.prototype._getStorageKey = function () {
  return this._localStorageKey + '-' + this._username;
};

exports.NotificationsCache = NotificationsCache;

},{"./config":23,"./notification":26}],23:[function(require,module,exports){
'use strict';

var Config = {
  /**
   * Determines if the environment is 'dev' or 'prod'. Set it to dev if you want console logging.
   */
  ENV: 'prod',

  /**
   * Transitional attribute to use the modularized inclient notifications service instead
   * of the old notifications service when set to true.
   */
  USE_INCLIENT: true,

  /**
   * Prefix for the local storage key where the cached notifications will be stored.
   */
  CACHE_STORAGE_KEY: 'notifications',

  /**
   * Maximum size of the local storage cache.
   */
  MAX_CACHE_SIZE: 200,

  /**
   * Default amount of notifications to be fetched on each request.
   */
  DEFAULT_PAGE_SIZE: 20,

  /**
   * Timeout for the first load.
   */
  FIRST_LOAD_TIMEOUT: 2000, // Milliseconds

  /**
   * Timeout to retrieve image resources
   */
  IMAGE_LOAD_TIMEOUT: 2000, // Milliseconds

  /**
   * Returns a logger.
   */
  getLogger: function getLogger() {
    var pkg = require('../package.json');
    var Logger = require('../../../libs/spotify-client-logger');
    if (!this._logger) {
      this._logger = new Logger();
      this._logger.setConstant({ source: pkg.name });
    }
    return this._logger;
  },

  /**
   * Returns a debug
   */
  getDebug: function getDebug() {
    if (!this.debug) {
      var pkg = require('../package.json');
      this.debug = require('debug')(pkg.name);
    }
    return this.debug;
  },

  /**
   * Returns the proto file path.
   * @return {string}
   */
  getProtoFilePath: function getProtoFilePath() {
    if (!this._protoPath) {
      this._protoPath = this.USE_INCLIENT ? 'proto/inclient-notifications.proto' : 'proto/notifications.proto';
    }
    return this._protoPath;
  },

  /**
   * Returns the name of the hermes endpoint that the app must use.
   * @return {string}
   */
  getHermesEndpoint: function getHermesEndpoint() {
    if (!this._hermesEndpoint) {
      this._hermesEndpoint = this.USE_INCLIENT ? 'inclient-notifications' : 'notifications';
    }
    return this._hermesEndpoint;
  }
};

exports.Config = Config;

},{"../../../libs/spotify-client-logger":35,"../package.json":21,"debug":159}],24:[function(require,module,exports){
'use strict';

var cosmos = require('spotify-cosmos-api');
var live = require('../../../libs/spotify-live');
var scrollBarEvents = require('../../../libs/spotify-events/scrollbar');
var strings = require('../i18n');

require('../../../libs/spotify-live-models/client').register();

var Config = require('./config').Config;
var Notification = require('./notification').Notification;
var NotificationsProxy = require('./proxy').NotificationsProxy;
var NotificationsCache = require('./cache').NotificationsCache;

var logger = Config.getLogger();
var debug = Config.getDebug();

/**
 * Notifications controller constructor.
 *
 * @param {string} username Used to initialize the hermes proxy.
 * @constructor
 */
function NotificationsController(username) {
  this._proxy = new NotificationsProxy(username);
  this._cache = new NotificationsCache(username, Config.CACHE_STORAGE_KEY, Config.MAX_CACHE_SIZE);
  this._isFirstLoad = true;
  this._isFetchInProgress = false;
  this._isEndReached = false;
  this._unreadCount = 0;
  this._notificationsLoading = 0;
  this._notificationsRendered = {};
  this._startTime = 0;
  this._firstLoadTimeout = null;
  this._updateBadgeTimeout = null;
  this._receivedAggregateCount = 0;

  this._mainNode = document.getElementById('notification-center');
  this._listNode = document.getElementById('notificationListContent');
  this._listContainerNode = document.getElementById('notification-list');
  this._alertContainerNode = document.getElementById('alert-container');
  this._alertMessageNode = document.getElementById('alert-message');
  this._throbberNode = document.getElementById('throbber-container');
  document.getElementById('title-bar').innerHTML = strings.get('sTitle');

  var notificationListNode = document.getElementById('notification-list');

  notificationListNode.addEventListener('scroll', function () {
    var view = notificationListNode;
    if (view.scrollTop + view.clientHeight > view.scrollHeight - 10) {
      this.onScrollingNearBottom();
    }
  }.bind(this), false);

  this.updateBadgeCount();
  this.startSubscription();

  // Use Cosmos to get events from the container.
  var subscription = cosmos.resolver.subscribe('sp://messages/v1/notification-center', function (error, response) {
    if (error) {
      subscription.cancel();
      return;
    }

    try {
      var object = JSON.parse(response.getBody());
      switch (object.type) {
        case 'on-open':
          this.onPopupShown();
          break;
        case 'on-close':
          this.onPopupClosed();
          break;
      }
    } catch (e) {}
  }.bind(this));

  // Support the old Link communication layer until Cosmos is being used.
  window.addEventListener('message', function (event) {
    try {
      var message = JSON.parse(event.data);
      if (message && message.type === 'WINDOW_FOCUS') {
        this.onPopupShown();
      } else if (message && message.type === 'WINDOW_CLOSED') {
        this.onPopupClosed();
      }
    } catch (e) {/* Do nothing */}
  }.bind(this));

  // Trigger the loading of notifications
  this.performFirstLoad();

  // If coming back online reload the app to recover.
  var client = live('spotify:client');
  client.query('session(online)', function (error, data) {
    if (error) throw error;
    client.get('session').on('update', function (properties) {
      if ('online' in properties && properties.online) location.reload();
    });
  });
}

/**
 * Broadcasts an event to Cosmos (to communicate with the container).
 * @param {string} type The event type.
 * @param {*=} opt_data Optional data to include.
 */
NotificationsController.prototype.broadcast = function (type, opt_data) {
  var object = { type: type };
  if (opt_data !== undefined) object.data = opt_data;

  var request = new cosmos.Request('POST', 'sp://messages/v1/notification-center', null, object);
  cosmos.resolver.resolve(request, function (error, response) {});
};

/**
 * Callback to be invoked when the notification center is opened.
 */
NotificationsController.prototype.onPopupShown = function () {
  logger.userHit('notification-center-open', { unread: this._unreadCount });
  this.updateRenderedTimeStamps();
  this._listContainerNode.classList.remove('hide');
  scrollBarEvents.update();
};

/**
 * Requests the inital batch of notifications to the notifications service.
 */
NotificationsController.prototype.performFirstLoad = function () {
  if (this._isFirstLoad) {
    this._startTime = new Date().getTime();
    this._cache.loadFromLocalStorage();
    this._firstLoadTimeout = window.setTimeout(function () {
      // After the time specified in Config.FIRST_LOAD_TIMEOUT, any notification that has been already rendered is displayed.
      if (Object.keys(this._notificationsRendered).length > 0) {
        debug('Not all notifications could be rendered');
        this.onFirstLoadFinished();
      }
    }.bind(this), Config.FIRST_LOAD_TIMEOUT);

    this._isFetchInProgress = true;
    this._proxy.getLatestNotifications(function (response) {
      this._isFetchInProgress = false;
      if (response.success) {
        if (response.notifications.length > 0) {
          this.onNotificationsReceived(response.notifications);
        } else {
          this.onEmptyNotifications();
        }
        debug('Retrieved latest notifications from server', { amount: response.notifications.length });
      } else {
        debug('Could not retrieve the latest notifications from server', { error: response.error });
        this.onFetchNotificationsFailure();
      }
    }.bind(this));
  }
};

/**
 * Callback to be invoked when the notification center is closed.
 */
NotificationsController.prototype.onPopupClosed = function () {
  if (this._unreadCount > 0) {
    this._proxy.markAllAsRead(function (response) {
      if (response.success) {
        this._cache.markAllAsRead();
        this.setBadgeCount(0);
        debug('Marked all notifications as read');
      } else {
        debug('Could not mark notifications as read on remote', { error: response.error });
      }
    }.bind(this));
  }
  this.removeUnreadClasses();

  // Hiding the list will force the scroll bar to be shown for a bit when the
  // popup is opened next time.
  this._listContainerNode.classList.add('hide');

  scrollBarEvents.update();
};

/**
 * To be called when the first batch of notifications finishes loading.
 */
NotificationsController.prototype.onFirstLoadFinished = function () {
  window.clearTimeout(this._firstLoadTimeout);
  this._isFirstLoad = false;
  this._hideThrobber(true);
  scrollBarEvents.update();
  var time = new Date().getTime() - this._startTime;
  debug('initial-load', {
    loadingTimeMs: time,
    notificationsLoaded: Object.keys(this._notificationsRendered).length
  });
};

/**
 * This is how the notification manager tells us we have reached the end of all notifications on the server.
 */
NotificationsController.prototype.onEmptyNotifications = function () {
  this._isFirstLoad = false;
  this._isEndReached = true;
  this._alertMessageNode.innerHTML = strings.get('sNoMoreMessage');
  this._listContainerNode.classList.add('hide');
  this._alertContainerNode.classList.remove('hide');
  this._hideThrobber(true);
};

/**
 * To be called when the hermes service is failing or there is no connectivity.
 */
NotificationsController.prototype.onFetchNotificationsFailure = function () {
  this._alertMessageNode.innerHTML = strings.get('sLoadError');
  this._listContainerNode.classList.add('hide');
  this._alertContainerNode.classList.remove('hide');
  this._hideThrobber();
};

/**
 * Called when user scrolls near the bottom, to kick of infinite scroll.
 * TODO: Have a pointer to the oldest notification rendered.
 */
NotificationsController.prototype.onScrollingNearBottom = function () {
  if (!this._isFetchInProgress && !this._isEndReached) {
    var nodes = this._listNode.getElementsByClassName('notification');
    if (nodes && nodes.length > 0) this.getPageOfNotifications(nodes[nodes.length - 1].id);
  }
};

/**
 * Recalculates timestamps for all the notifications currently displayed and updates their HTML.
 */
NotificationsController.prototype.updateRenderedTimeStamps = function () {
  var nodes = this._listNode.getElementsByClassName('notification');
  if (!nodes.length) {
    console.error('Got 0 notifications, did the class name .notification go missing?');
  }

  for (var i = 0, l = nodes.length; i < l; i++) {
    var node = nodes[i];
    var timestamp = node.querySelector('.share-meta');
    if (!timestamp) {
      console.error('Could not find .share-meta in notification when updating timestamp');
      break;
    }
    timestamp.innerHTML = Notification.getTimeLabel(node.getAttribute('data-timestamp'));
  }
};

/**
 * Removes the unread class from all the notifications that have it.
 */
NotificationsController.prototype.removeUnreadClasses = function () {
  var unreadNodeList = this._listNode.getElementsByClassName('unread');
  // Copy the NodeList to a local array
  var unreadNodes = [];
  for (var i = 0, l = unreadNodeList.length; i < l; i++) {
    unreadNodes[i] = unreadNodeList[i];
  }
  // Remove the unread class from the notifications
  for (var j = 0, k = unreadNodes.length; j < k; j++) {
    unreadNodes[j].classList.remove('unread');
  }
};

NotificationsController.prototype.postSystemNotification = function (title, body) {
  this.broadcast('new-notifications', [title, body]);
};

/**
 * Handler for incoming notifications. Loads their content and displays them.
 * @param {Notification[]} notifications Received notifications.
 */
NotificationsController.prototype.onNotificationsReceived = function (notifications) {
  this._notificationsLoading += notifications.length;
  debug('Notifications received, going to load and render', { amount: this._notificationsLoading });
  for (var i = 0, l = notifications.length; i < l; i++) {
    var notif = notifications[i];
    this._cache.addNotification(notif);
    notif.loadNodeInfo(function (response) {
      if (response.success) {
        this.renderLoadedNotification(response.notification);
      } else {
        this.notificationFailedToLoad(response.notification);
      }
    }.bind(this));
  }
  this._cache.persist();
};

/**
 * Renders a loaded notification in its correct position in the notification list.
 * @param {Notification} notification Loaded notification to be rendered.
 */
NotificationsController.prototype.renderLoadedNotification = function (notification) {
  this._notificationsLoading--;
  debug('Going to render notification', { loading: this._notificationsLoading, notification: notification });
  if (this._notificationsRendered[notification.getIdHex()]) {
    // Notification is already rendered
    return;
  }

  var nodes = this._listNode.childNodes;
  var indexOfNewNode = 0;
  while (nodes && indexOfNewNode < nodes.length && nodes[indexOfNewNode].getAttribute('data-timestamp') > notification.getTimeStamp()) {
    indexOfNewNode++;
  }

  var node = notification.createNode();
  if (node.classList.contains('unread')) {
    logger.userImpression('unread-notification-rendered', {
      type: node.getAttribute('data-type'),
      uri: node.getAttribute('data-action-uri')
    });
  }
  if (nodes && indexOfNewNode < nodes.length) {
    this._listNode.insertBefore(node, nodes[indexOfNewNode]);
  } else {
    this._listNode.appendChild(node);
  }

  // Set the notification as rendered to avoid rendering it twice.
  this._notificationsRendered[notification.getIdHex()] = true;

  // When all notifications have been rendered, hide the throbber, display the list and reset the scroller.
  if (this._notificationsLoading === 0) {
    if (this._isFirstLoad) {
      this.onFirstLoadFinished();
    } else if (Object.keys(this._notificationsRendered).length === 1) {
      // The notification center was previously in an empty state
      this._hideAlertMessage();
    }
  }

  scrollBarEvents.update();
};

/**
 * Handler for notifications that fail to load.
 * @param {Notification} notification Notification that failed to load.
 */
NotificationsController.prototype.notificationFailedToLoad = function (notification) {
  debug('Notification failed to load', { data: notification });
  this._notificationsLoading--;
  // When all notifications have been rendered, hide the throbber, display the list and reset the scroller.
  if (this._isFirstLoad && this._notificationsLoading === 0) {
    this.onFirstLoadFinished();
  }
};

/**
 * Start notification subscription or polling
 */
NotificationsController.prototype.startSubscription = function () {
  this._proxy.subscribe(function (response) {
    if (!response.success) {
      debug('Could not subscribe to incoming notifications', { error: response.error });
      return;
    }
    debug('Subscribed for incoming notifications');
    response.sub.addEventListener('message', function (event) {
      debug('Message received', { message: event.frames[0] });
      var data = event.frames[0];
      if (data.type === 'TYPE_IN_CLIENT_NOTIFICATION') {
        // A new notification has been received
        if (!this._isFirstLoad) {
          try {
            var notification = Notification.createNotification(data.in_client_data);
            this.onNotificationsReceived([notification]);
            debug('Rendered pubsub notification');

            // Send the notification text to the container, to support system
            // notifications.
            notification.getText(this.postSystemNotification.bind(this));
          } catch (e) {
            debug('Could not create notification from message', { error: e });
          }
        }

        // To avoid race conditions when updating the badge count, a timeout is set. Every new notification
        // that is received within the timeout interval of time, increases a temporal counter
        // and triggers a new timeout, so that when multiple notifications are received at the same time
        // the badge count gets updated once.
        this._receivedAggregateCount++;
        if (this._updateBadgeTimeout !== null) {
          window.clearTimeout(this._updateBadgeTimeout);
        }
        this._updateBadgeTimeout = window.setTimeout(function () {
          this.setBadgeCount(this._unreadCount + this._receivedAggregateCount);
          this._receivedAggregateCount = 0;
          // Show the notification list (for cases when the user had no previous notifications)
          this._alertContainerNode.classList.add('hide');
          this._listContainerNode.classList.remove('hide');
        }.bind(this), 500);
      } else if (data.type === 'TYPE_RESET_NOTIFICATION') {
        // Notifications have been marked as read from another client
        if (!this._isFirstLoad) {
          this._cache.markAllAsRead();
          this.removeUnreadClasses();
        }
        this.setBadgeCount(0);
      }
    }.bind(this));
  }.bind(this));
};

/**
 * Get new badge count. Should only be called at startup, after that we are responsible for keeping the badge count correct.
 */
NotificationsController.prototype.updateBadgeCount = function () {
  this._proxy.getUnreadCount(function (response) {
    if (response.success) {
      this.setBadgeCount(response.unread);
      debug('Unread count updated', { unread: response.unread });
    } else {
      debug('Could not retrieve the unread count', { error: response.error });
    }
  }.bind(this));
};

/**
 * Set a new badge count. Computes the badge count based on unread and unacted upon counts
 * @param {number} newUnreadCount The new unread count.
 */
NotificationsController.prototype.setBadgeCount = function (newUnreadCount) {
  newUnreadCount = typeof newUnreadCount == 'number' ? newUnreadCount : 0;
  if (this._unreadCount != newUnreadCount) {
    window.top.postMessage(JSON.stringify({ type: 'UNREAD_NOTIFICATIONS_COUNT_CHANGE', count: newUnreadCount }), '*');
    this.broadcast('set-unread-count', newUnreadCount);
  }
  this._unreadCount = newUnreadCount;
};

/**
 * Requests a page of notifications. Tries cache first, then hermes service.
 * @param {string} [beforeId] The id of the last notification currently shown.
 */
NotificationsController.prototype.getPageOfNotifications = function (beforeId) {
  var cachedPage = this._cache.getNotifications(beforeId, Config.DEFAULT_PAGE_SIZE);
  debug('Retrieved a page of cached notifications from local storage', { amount: cachedPage.length });
  if (cachedPage.length > 0) {
    this.onNotificationsReceived(cachedPage);
  }
  // If not all the notifications requested were in cache, request them to the hermes service
  if (cachedPage.length < Config.DEFAULT_PAGE_SIZE) {
    var take = Config.DEFAULT_PAGE_SIZE - cachedPage.length;
    this._isFetchInProgress = true;
    this._proxy.getNotificationsFrom(function (response) {
      this._isFetchInProgress = false;
      if (response.success) {
        if (response.notifications.length > 0) {
          this.onNotificationsReceived(response.notifications);
        }
        if (response.notifications.length < take) {
          this._isEndReached = true;
        }
        debug('Retrieved a page of notifications from server', {
          requested: take,
          received: response.notifications.length
        });
      } else {
        debug('Could not retrieve page of notifications', { error: response.error });
        this.onFetchNotificationsFailure();
      }
    }.bind(this), this._cache.getOldestNotificationId(), take);
  }
};

/**
 * Requests the latest cached notifications to the cache layer. Renders them if there are any.
 */
NotificationsController.prototype.getNewestCachedNotifications = function () {
  var cachedPage = this._cache.getNewestNotifications(Config.DEFAULT_PAGE_SIZE);
  debug('Retrieved cached notifications from local storage', { amount: cachedPage.length });
  if (cachedPage.length > 0) {
    this.onNotificationsReceived(cachedPage);
  }
};

/**
 * Hides the throbber and displays the content.
 * @param {boolean} [showList] The notifications container is displayed when true.
 * @private
 */
NotificationsController.prototype._hideThrobber = function (showList) {
  this._throbberNode.classList.add('hide');
  if (showList) {
    this._mainNode.classList.remove('hide');
  }
};

/**
 * Hides the alert message and shows the notifications list.
 * @private
 */
NotificationsController.prototype._hideAlertMessage = function () {
  this._alertContainerNode.classList.add('hide');
  this._listContainerNode.classList.remove('hide');
};

exports.NotificationsController = NotificationsController;

},{"../../../libs/spotify-events/scrollbar":55,"../../../libs/spotify-live":118,"../../../libs/spotify-live-models/client":109,"../i18n":11,"./cache":22,"./config":23,"./notification":26,"./proxy":27,"spotify-cosmos-api":246}],25:[function(require,module,exports){
'use strict';

require('../../../libs/spotify-events/anchor').attach();
require('../../../libs/spotify-api-core');

// Initialize locale.
var i18n = require('../i18n/index');
var helpers = require('../../../libs/spotify-handlebars/helpers');
helpers.numeral.setLocale(i18n.locale());

var live = require('../../../libs/spotify-live');
require('../../../libs/spotify-live-models/client').register();

var NotificationsController = require('./controller').NotificationsController;

live('spotify:client').query('currentUser(username)', function (err, response) {
  new NotificationsController(response.currentUser.username);
});

require('../../../libs/spotify-expose-dev-mode-debug-globals/bridge').init();
require('../../../libs/spotify-expose-dev-mode-debug-globals/live').init();
require('../../../libs/spotify-expose-dev-mode-debug-globals/cosmos').init();

},{"../../../libs/spotify-api-core":32,"../../../libs/spotify-events/anchor":43,"../../../libs/spotify-expose-dev-mode-debug-globals/bridge":58,"../../../libs/spotify-expose-dev-mode-debug-globals/cosmos":59,"../../../libs/spotify-expose-dev-mode-debug-globals/live":61,"../../../libs/spotify-handlebars/helpers":92,"../../../libs/spotify-live":118,"../../../libs/spotify-live-models/client":109,"../i18n/index":11,"./controller":24}],26:[function(require,module,exports){
'use strict';

var strings = require('../i18n/index');
var live = require('../../../libs/spotify-live');
require('../../../libs/spotify-live-models/application').register();
require('../../../libs/spotify-live-models/playlist').register();
require('../../../libs/spotify-live-models/user').register();
require('../../../libs/spotify-live-models/artist').register();
require('../../../libs/spotify-live-models/album').register();
require('../../../libs/spotify-live-models/track').register();

var scrollBarEvents = require('../../../libs/spotify-events/scrollbar');
scrollBarEvents.attach();
scrollBarEvents.update();

var player = require('../../../libs/spotify-events/player');

// Set up Handlebars.
var hbs = require('../../../libs/spotify-handlebars');
hbs.register(require('../../../libs/spotify-handlebars/helpers'));

// Set up application version and play source for logging.
var pkg = require('../package.json');
live('spotify:application').update({
  version: pkg.version
});
document.body.setAttribute('data-play-source', pkg.name);

var Config = require('./config').Config;
var URI = require('spotify-liburi');

var logger = Config.getLogger();
var debug = Config.getDebug();

var options = {
  AVATAR_CONFIG: { width: 48, height: 48, style: 'inset', player: true },
  MAX_NAME_LENGTH: 75
};

/**
 * Cached HTML Element used to sanitize strings via innerText / textContent + innerHTML
 * @type {HTMLElement}
 */
var sanitizerElement = document.createElement('div');

/**
 * Escapes HTML tags as entities for security reasons.
 * Trims a name (album, artist, etc.) to the maximum allowed size.
 * @param {string} name Name to be trimmed.
 * @return {string} Trimmed name.
 */
function sanitize(name) {
  var trimmedName = name.length > options.MAX_NAME_LENGTH ? name.substring(0, options.MAX_NAME_LENGTH - 1) + '…' : name;

  // Prefer textContent as it is the standard and is not style aware.
  if (typeof sanitizerElement.textContent === 'undefined') {
    sanitizerElement.innerText = trimmedName;
  } else {
    sanitizerElement.textContent = trimmedName;
  }
  return sanitizerElement.innerHTML;
}

/**
 * Combines an array of strings into a localized string representation of the
 * list.
 *
 * @param {Array.<string>|...string} var_args A list of strings to return a
 *     list string for.
 * @return {string} A localized string listing the provided items.
 */
function i18nList(var_args) {
  var items = Array.prototype.slice.call(arguments);

  if (items.length == 0) {
    return '';
  } else if (items.length == 1) {
    return items[0];
  } else if (items.length == 2) {
    return strings.get('ListTwo', items[0], items[1]);
  }

  // Use prototype in case we're working with an arguments object here.
  return items.reduce(function (a, b, idx) {
    if (idx == items.length - 1) return strings.get('ListEnd', a, b);
    return strings.get(idx == 0 ? 'ListStart' : 'ListMiddle', a, b);
  });
}

/**
 * Constructor for notifications.
 * @constructor
 * @class Notification
 * @param {object} data An InClientNotificationData object received from the hermes service.
 */
function Notification(data) {
  /**
   * Raw data object. Represents the InClientNotificationData object received from the hermes service.
   * @type {object}
   */
  this.data = data;

  /**
   * Cached image url to be used when rendering the notification.
   * @type {object}
   */
  this.imageObject = null;

  /**
   * Cached HTML content to be used when rendering the notification.
   * @type {string}
   */
  this.contentHtml = null;

  /**
   * Template method that returns the URI where the user should be redirected when the notification is clicked.
   * @return {string} A Spotify URI.
   * @private
   */
  this._getActionUri = function () {
    throw new Error('method must be implemented by notification subclasses');
  };

  /**
   * Returns the image for the notification.
   * @param {function(Object)} onImageObjectReady Callback to be executed when the image URL is loaded.
   * @private
   */
  this._getImageObject = function (onImageObjectReady) {
    var uri = this._getImageObjectUri();
    var type = Notification.getTypeFromUri(uri);

    var emptyImageObject = {
      type: type,
      url: '',
      placeholder: 'placeholder-visible'
    };

    // If loading the image does not return after Config.IMAGE_LOAD_TIMEOUT, return an empty image.
    var imageLoadTimeout = window.setTimeout(function () {
      onImageObjectReady(emptyImageObject);
    }, Config.IMAGE_LOAD_TIMEOUT);

    live(uri).query('image', function (error, data) {
      window.clearTimeout(imageLoadTimeout);
      if (!error && !Notification.isPlaceHolderVisible(data.image)) {
        onImageObjectReady({
          type: type,
          url: data.image
        });
      } else {
        debug('Could not load ' + type + ' image', error);
        onImageObjectReady(emptyImageObject);
      }
    });
  };

  this._getImageObjectUri = function () {
    return this._getActionUri();
  };

  /**
   * Template method that returns the HTML corresponding to the notification content, using the proper translation.
   * Remember to sanitize content prone to XSS attacks.
   * @param {function(string)} onContentHtmlReady Callback to be executed when the content HTML has been built.
   * @private
   */
  this._buildContentHtml = function (onContentHtmlReady) {
    throw new Error('method must be implemented by notification subclasses');
  };
}

/**
 * Types of notifications given by the notification_verb field.
 * @enum {string}
 */
Notification.Type = {
  PLAYLIST_SUBSCRIBE: 'playlist-sub',
  MESSAGE_PLAYED: 'message-played',
  NEW_FOLLOWER: 'new-follower',
  FRIEND_JOINED: 'user-signup',
  PLAYLIST_UPDATED: 'playlist-update',
  ALBUM_RELEASED: 'album-release',
  APP_RELEASED: 'application-release',
  SOCIAL_REACTION: 'social-reaction'
};

/**
 * Subtypes of playlist notifications.
 * @enum {string}
 */
Notification.SubType = {
  NONE: 'none',
  TOPLIST_SUBSCRIBE: 'toplist'
};

/**
 * Types of app release notification.
 * @enum {string}
 */
Notification.AppType = {
  IOS: 'TYPE_IOS_APP',
  ANDROID: 'TYPE_ANDROID_APP',
  LINK: 'TYPE_LINK_APP',
  MFT_LAUNCH: 'TYPE_MFT_LAUNCH',
  MFT_REMINDER: 'TYPE_MFT_REMINDER',
  MFT_SEASON: 'TYPE_MFT_SEASON'
};

/**
 * Builds an HTML link to a Spotify resource.
 * @param {string} contentType Type of content (user, album, playlist, etc.).
 * @param {string} innerText Text to render inside the <a> tag.
 * @param {string} itemGID Resource identifier of the content.
 * @return {string} An HTML formatted string with a link to the resource.
 */
Notification.getContentLink = function (contentType, innerText, itemGID) {
  var contentURI = 'spotify:' + contentType + ':' + itemGID;
  return '<a href="' + contentURI.toSpotifyLink() + '">' + sanitize(innerText) + '</a>';
};

/**
 * Generates a time label using the corresponding translation.
 * @param {integer} timestamp Timestamp to be formatted.
 * @return {string} Formatted timestamp.
 */
Notification.getTimeLabel = function (timestamp) {
  var rightNow = new Date();
  var diff = rightNow.getTime() - timestamp;
  var second = 1000;
  var minute = second * 60;
  var hour = minute * 60;
  var day = hour * 24;

  if (isNaN(diff) || diff < 0) {
    return '';
  } else if (diff < second * 2) {
    return strings.get('sJustNow');
  } else if (diff < minute) {
    return strings.get('sSecondsAgo', [Math.floor(diff / second)]);
  } else if (diff < minute * 2) {
    return strings.get('s1Minute');
  } else if (diff < hour) {
    return strings.get('sMinutesAgo', [Math.floor(diff / minute)]);
  } else if (diff < hour * 2) {
    return strings.get('s1Hour');
  } else if (diff < day) {
    return strings.get('sHoursAgo', [Math.floor(diff / hour)]);
  } else if (diff > day && diff < day * 2) {
    return strings.get('sYesterday');
  } else if (diff < day * 365) {
    return strings.get('sDaysAgo', [Math.floor(diff / day)]);
  } else {
    return strings.get('sOverAYear');
  }
};

/**
 * Returns the type of resource from a Spotify URI.
 * @param {string} uri The Spotify URI.
 * @returns {string} The type of resource.
 */
Notification.getTypeFromUri = function (uri) {
  return uri.split(':')[1];
};

/**
 * Given an image URL determines if the placeholder must be visible.
 * @param {string} imageUrl The image URL.
 * @return {boolean}
 */
Notification.isPlaceHolderVisible = function (imageUrl) {
  return !imageUrl;
};

/**
 * Returns the raw data of a notification.
 * @return {object} Raw data as received from the hermes service.
 */
Notification.prototype.getData = function () {
  return this.data;
};

Notification.prototype.getText = function (callback) {};

/**
 * Tell the notification to load the image URL and the content HTML.
 * @param {Function} callback Callback.
 */
Notification.prototype.loadNodeInfo = function (callback) {
  this._getImageObject(function (imageObject) {
    this.imageObject = imageObject;
    if (this.contentHtml !== null) {
      if (imageObject !== null) {
        callback({ success: true, notification: this });
      } else {
        callback({ success: false });
      }
    }
  }.bind(this));
  this._buildContentHtml(function (contentHtml) {
    this.contentHtml = contentHtml;
    if (this.imageObject !== null) {
      if (contentHtml !== null) {
        callback({ success: true, notification: this });
      } else {
        callback({ success: false });
      }
    }
  }.bind(this));
};

/**
 * Creates a DOM node for the notification. Notification.loadNodeInfo() must be invoked before to ensure
 * that imageNode and contentHTML are already loaded.
 * @return {Node} New DOM element.
 */
Notification.prototype.createNode = function () {
  if (!this.imageObject || !this.contentHtml) {
    return null;
  }

  var template = require('../../../libs/spotify-glue-cat/templates/v1/share-object.hbs');
  var actionUri = this._getActionUri();
  var imageObjectUri = this._getImageObjectUri();

  // Build the node from the handlebars template
  var nodeHtml = template({
    'modifiers': 'list-group-item notification',
    'unread': !this.isRead(),
    'sharer': {
      'name': '',
      'imageUrl': this.imageObject.url,
      'url': actionUri.toSpotifyLink(),
      'uri': imageObjectUri
    },
    'shareData': this.contentHtml,
    'shareMeta': Notification.getTimeLabel(this.getTimeStamp())
  });

  var container = document.createElement('div');
  container.innerHTML = nodeHtml;

  var node = container.firstChild;
  node.id = this.getIdHex();
  node.setAttribute('data-timestamp', this.getTimeStamp());
  node.setAttribute('data-action-uri', actionUri);
  node.setAttribute('data-type', this.data.notification_verb);

  // Register clicks
  node.addEventListener('click', function (event) {
    // Don't do anything when clicking a link
    if (event.target.tagName == 'A') return;
    logger.userHit('notification-click-through', {
      data: this.data,
      type: this.data.notification_verb,
      uri: actionUri
    });
    bridge.request("application_open_uri", [actionUri, null]);
  }.bind(this));

  // Make the node playable if it's an album
  if (this.imageObject.type === 'album') {
    player.update(node);
  }

  return node;
};

/**
 * Returns the ID of the notification.
 * @return {string} The Id of the notification.
 */
Notification.prototype.getIdHex = function () {
  return this.data.state.notification_id_hex;
};

/**
 * Returns the timestamp of the notification.
 * @return {string} The Timestamp of the notification.
 */
Notification.prototype.getTimeStamp = function () {
  return this.data.state.notification_id_ms;
};

/**
 * Returns true if the notifications has been marked as read.
 * @return {boolean} True if the notification is marked as read, false otherwise.
 */
Notification.prototype.isRead = function () {
  return this.data.state.seen;
};

/**
 * Marks the notification as read.
 */
Notification.prototype.markAsRead = function () {
  this.data.state.seen = true;
};

/**
 * Checks the validity of an InClientNotificationData object.
 * @param {object} data An InClientNotificationData object received from the hermes service.
 * @return {boolean} True if the object is valid, false otherwise.
 */
Notification.validateNotificationData = function (data) {
  var isValid = data && data.hasOwnProperty('state') && data.hasOwnProperty('notification_verb') && data.state.hasOwnProperty('notification_id_hex') && data.state.hasOwnProperty('notification_id_ms');

  if (isValid) {
    switch (data.notification_verb) {
      case Notification.Type.ALBUM_RELEASED:
        isValid = data.hasOwnProperty('album_release_object') && data.album_release_object.length > 0;
        break;
      case Notification.Type.APP_RELEASED:
        isValid = data.hasOwnProperty('application_release_object') && data.application_release_object.length > 0;
        break;
      case Notification.Type.FRIEND_JOINED:
        isValid = data.hasOwnProperty('subject') && data.subject.length > 0;
        break;
      case Notification.Type.MESSAGE_PLAYED:
        isValid = data.hasOwnProperty('message_played_object') && data.message_played_object.length > 0;
        break;
      case Notification.Type.NEW_FOLLOWER:
        isValid = data.hasOwnProperty('subject') && data.subject.length > 0;
        break;
      case Notification.Type.PLAYLIST_UPDATED:
        isValid = data.hasOwnProperty('subject') && data.subject.length > 0 && data.hasOwnProperty('track_add_object') && data.track_add_object.length > 0;
        break;
      case Notification.Type.PLAYLIST_SUBSCRIBE:
        isValid = data.hasOwnProperty('subject') && data.subject.length > 0 && data.hasOwnProperty('playlist_sub_object') && data.playlist_sub_object.length > 0;
        break;
      case Notification.Type.SOCIAL_REACTION:
        isValid = false; // employee hack breaking stuff, just disable it.
        break;
    }
  }

  return isValid;
};

/**
 * Factory method to create notification objects from hermes data
 * @param {object} data Object received in a hermes response or loaded from local storage.
 * @return {Notification} A subclassed notification object depending on the notification_verb field.
 */
Notification.createNotification = function (data) {
  if (Notification.validateNotificationData(data)) {
    switch (data.notification_verb) {
      case Notification.Type.ALBUM_RELEASED:
        return new AlbumReleasedNotification(data);
      case Notification.Type.APP_RELEASED:
        return new AppReleasedNotification(data);
      case Notification.Type.FRIEND_JOINED:
        return new FriendJoinedNotification(data);
      case Notification.Type.MESSAGE_PLAYED:
        return new MessagePlayedNotification(data);
      case Notification.Type.NEW_FOLLOWER:
        return new NewFollowerNotification(data);
      case Notification.Type.PLAYLIST_SUBSCRIBE:
        return new PlaylistSubscribeNotification(data);
      case Notification.Type.PLAYLIST_UPDATED:
        return new PlaylistUpdatedNotification(data);
      case Notification.Type.SOCIAL_REACTION:
        return new SocialReactionNotification(data);
      default:
        debug('Trying to create unkown notification type', { data: data });
        throw new Error('Unknown notification type');
    }
  } else {
    debug('Trying to create notification from invalid data', { data: data });
    throw new Error('Invalid notification data');
  }
};

/**
 * Constructor for album-release notifications
 * @param {object} data Object received in a hermes response or loaded from local storage.
 * @constructor
 */
function AlbumReleasedNotification(data) {
  Notification.call(this, data);

  this._getThumbnailType = function () {
    return 'album';
  };

  this._getActionUri = function () {
    return 'spotify:album:' + this.data.album_release_object[0].album_gid;
  };

  this._buildBody = function (album, artist) {
    var info = this.data.album_release_object[0];
    var numAlbums = this.data.album_release_object.length;

    if (numAlbums > 2) {
      return strings.get(info.exclusive ? 'sNotificationBodyMultipleExclusiveAlbumsReleased' : 'sNotificationBodyMultipleAlbumsReleased', album, artist, numAlbums - 1);
    } else if (numAlbums > 1) {
      return strings.get(info.exclusive ? 'sNotificationBodyMultipleExclusiveAlbumsReleasedSingular' : 'sNotificationBodyMultipleAlbumsReleasedSingular', album, artist);
    } else {
      return strings.get(info.exclusive ? 'sNotificationBodyExclusiveAlbumReleased' : 'sNotificationBodyAlbumReleased', album, artist);
    }
  };

  this._buildContentHtml = function (onContentHtmlReady) {
    var info = this.data.album_release_object[0];
    var albumLink = Notification.getContentLink('album', info.album_name, info.album_gid);
    var artistLink = Notification.getContentLink('artist', info.artist_name, info.artist_gid);

    onContentHtmlReady.call(this, this._buildBody(albumLink, artistLink));
  };

  this.getText = function (callback) {
    var info = this.data.album_release_object[0];

    callback(strings.get('sNotificationTitleAlbumReleased'), this._buildBody(info.album_name, info.artist_name).replace(/<br>/, ' '));
  };
}
AlbumReleasedNotification.prototype = new Notification();

/**
 * Constructor for app-released notifications
 * @param {object} data Object received in a hermes response or loaded from local storage.
 * @constructor
 */
function AppReleasedNotification(data) {
  Notification.call(this, data);

  this._getThumbnailType = function () {
    return '';
  };

  this._getActionUri = function () {
    switch (this.data.application_release_object[0].app) {
      case Notification.AppType.MFT_LAUNCH:
      case Notification.AppType.MFT_REMINDER:
      case Notification.AppType.MFT_SEASON:
        return this.data.application_release_object[0].uri;
      default:
        return '';
    }
  };

  this._getBody = function () {
    switch (this.data.application_release_object[0].app) {
      case Notification.AppType.IOS:
        return strings.get('sNotificationBodyApplicationReleaseIOS');
      case Notification.AppType.ANDROID:
        return strings.get('sNotificationBodyApplicationReleaseAndroid');
      case Notification.AppType.LINK:
        return strings.get('sNotificationBodyApplicationReleaseLink');
      case Notification.AppType.MFT_LAUNCH:
        return strings.get('sNotificationBodyApplicationReleaseMftLaunch');
      case Notification.AppType.MFT_REMINDER:
        return strings.get('sNotificationBodyApplicationReleaseMftReminder');
      case Notification.AppType.MFT_SEASON:
        return strings.get('sNotificationBodyApplicationReleaseMftSeason');
    }
  };

  // Overwrites parent method
  this._getImageObject = function (onImageObjectReady) {
    var imageUrl = this.data.application_release_object[0].image_url;
    if (!imageUrl) {
      imageUrl = 'img/spotify-icon.png';
    }
    onImageObjectReady({ type: 'album', url: imageUrl });
  };

  this._buildContentHtml = function (onContentHtmlReady) {
    onContentHtmlReady.call(this, this._getBody());
  };

  this.getText = function (callback) {
    callback(strings.get('sNotificationTitleApplicationRelease'), this._getBody());
  };
}
AppReleasedNotification.prototype = new Notification();

/**
 * Constructor for friend-joined notifications
 * @param {object} data Object received in a hermes response or loaded from local storage.
 * @constructor
 */
function FriendJoinedNotification(data) {
  Notification.call(this, data);

  this._getThumbnailType = function () {
    return 'user';
  };

  this._getActionUri = function () {
    return 'spotify:user:' + this.data.subject[0].canonical_username;
  };

  this._buildContentHtml = function (onContentHtmlReady) {
    var userName = this.data.subject[0].canonical_username;
    var userRealName = this.data.subject[0].real_name;
    var userLink = Notification.getContentLink('user', userRealName, userName);
    onContentHtmlReady.call(this, strings.get('sNotificationBodyFriendJoined', userLink));
  };

  this.getText = function (callback) {
    callback(strings.get('sNotificationTitleFriendJoined'), strings.get('sNotificationBodyFriendJoined', this.data.subject[0].real_name));
  };
}
FriendJoinedNotification.prototype = new Notification();

/**
 * Constructor for message-played notifications.
 * @param {object} data Object received in a Hermes response or loaded from local storage.
 * @constructor
 */
function MessagePlayedNotification(data) {
  Notification.call(this, data);

  this._getThumbnailType = function () {
    return 'user';
  };

  this._getActionUri = function () {
    var obj = this.data.message_played_object[0];

    var pieces = ['spotify:app:messages'];
    pieces.push(encodeURIComponent(obj.thread_id));
    pieces.push(encodeURIComponent(obj.message_id));

    return pieces.join(':');
  };

  this._getImageObjectUri = function () {
    return 'spotify:user:' + this.data.message_played_object[0].user.canonical_username;
  };

  this._buildContentHtml = function (onContentHtmlReady) {
    var obj = this.data.message_played_object[0];
    var userName = obj.user.canonical_username;
    var userRealName = obj.user.real_name;
    var userLink = Notification.getContentLink('user', userRealName, userName);
    onContentHtmlReady.call(this, strings.get('sNotificationBodyMessagePlayed', userLink));
  };

  this.getText = function (callback) {
    callback(strings.get('sNotificationTitleMessagePlayed'), strings.get('sNotificationBodyMessagePlayed', this.data.subject[0].real_name));
  };
}
MessagePlayedNotification.prototype = new Notification();

/**
 * Constructor for new-follower notifications
 * @param {object} data Object received in a hermes response or loaded from local storage.
 * @constructor
 */
function NewFollowerNotification(data) {
  Notification.call(this, data);

  this._getThumbnailType = function () {
    return 'user';
  };

  this._getActionUri = function () {
    return 'spotify:user:' + this.data.subject[0].canonical_username;
  };

  this._buildContentHtml = function (onContentHtmlReady) {
    var userName = this.data.subject[0].canonical_username;
    var userRealName = this.data.subject[0].real_name;
    var userLink = Notification.getContentLink('user', userRealName, userName);
    onContentHtmlReady.call(this, strings.get('sNotificationBodyNewFollower', userLink));
  };

  this.getText = function (callback) {
    callback(strings.get('sNotificationTitleNewFollower'), strings.get('sNotificationBodyNewFollower', this.data.subject[0].real_name));
  };
}
NewFollowerNotification.prototype = new Notification();

/**
 * Constructor for playlist-subscribe notifications
 * @param {object} data Object received in a hermes response or loaded from local storage.
 * @constructor
 */
function PlaylistSubscribeNotification(data) {
  Notification.call(this, data);

  this._getThumbnailType = function () {
    return 'user';
  };

  this._getActionUri = function () {
    //return this.data.playlist_sub_object[0].uri;
    return 'spotify:user:' + this.data.subject[0].canonical_username;
  };

  this._buildContent = function (callback, opt_html) {
    var userName = this.data.subject[0].canonical_username;
    var userRealName = this.data.subject[0].real_name;

    var userInfo = opt_html ? Notification.getContentLink('user', userRealName, userName) : userRealName;

    var playlistUri = this.data.playlist_sub_object[0].uri;
    if (playlistUri.indexOf(Notification.SubType.TOPLIST_SUBSCRIBE) !== -1) {
      callback(strings.get('sNotificationBodyToplistSubscribe', userInfo));
    } else {
      live(playlistUri).query('name', function (error, data) {
        if (!error) {
          var playlistInfo;
          if (opt_html) {
            playlistInfo = '<a href="' + playlistUri.toSpotifyLink() + '">' + sanitize(data.name) + '</a>';
          } else {
            playlistInfo = data.name;
          }
          callback(strings.get('sNotificationBodyPlaylistSubscribe', userInfo, playlistInfo));
        } else {
          debug('error-loading-playlist-model', { error: error });
        }
      }.bind(this));
    }
  };

  this._buildContentHtml = function (onContentHtmlReady) {
    this._buildContent(onContentHtmlReady.bind(this), true);
  };

  this.getText = function (callback) {
    this._buildContent(callback.bind(null, strings.get('sNotificationTitlePlaylistSubscribe')));
  };
}
PlaylistSubscribeNotification.prototype = new Notification();

/**
 * Constructor for playlist-updated notifications
 * @param {object} data Object received in a hermes response or loaded from local storage.
 * @constructor
 */
function PlaylistUpdatedNotification(data) {
  Notification.call(this, data);

  this._getThumbnailType = function () {
    return 'playlist';
  };

  this._getActionUri = function () {
    return this.data.track_add_object[0].uri;
  };

  this._buildContent = function (callback, opt_html) {
    var userName = this.data.subject[0].canonical_username;
    var userRealName = this.data.subject[0].real_name;
    var userInfo = opt_html ? Notification.getContentLink('user', userRealName, userName) : userRealName;

    var playlistUri = this.data.track_add_object[0].uri;
    var trackCount = this.data.track_add_object[0].track_count;

    var playlistName = '';
    if (playlistUri.indexOf(Notification.SubType.TOPLIST_SUBSCRIBE) !== -1) {
      playlistName = strings.get('sNotificationBodyToplistUpdatedName');
      callback(this._getContentForTrackCount(trackCount, userInfo, playlistUri, playlistName, opt_html));
    } else {
      live(playlistUri).query('name', function (error, data) {
        if (!error) {
          callback(this._getContentForTrackCount(trackCount, userInfo, playlistUri, data.name, opt_html));
        } else {
          debug('error-loading-playlist-model', { error: error });
        }
      }.bind(this));
    }
  };

  this._getContentForTrackCount = function (trackCount, userInfo, playlistUri, playlistName, opt_html) {
    var playlistInfo;
    if (opt_html) {
      playlistInfo = '<a href="' + playlistUri.toSpotifyLink() + '">' + sanitize(playlistName) + '</a>';
    } else {
      playlistInfo = playlistName;
    }

    if (trackCount == 1) {
      return strings.get('sNotificationBodyPlaylistUpdatedSingular', userInfo, playlistInfo);
    } else {
      return strings.get('sNotificationBodyPlaylistUpdatedPlural', userInfo, playlistInfo, trackCount);
    }
  };

  this._buildContentHtml = function (onContentHtmlReady) {
    this._buildContent(onContentHtmlReady.bind(this), true);
  };

  this.getText = function (callback) {
    this._buildContent(callback.bind(null, strings.get('sNotificationTitlePlaylistUpdated')));
  };
}
PlaylistUpdatedNotification.prototype = new Notification();

/**
 * Constructor for social-reaction notifications
 * @param {object} data Object received in a hermes response or loaded from local storage.
 * @constructor
 */
function SocialReactionNotification(data) {
  Notification.call(this, data);

  this._getThumbnailType = function () {
    return 'user';
  };

  var buildLink = function buildLink(spotifyUri, name) {
    return '<a href="' + spotifyUri.toSpotifyLink() + '">' + sanitize(name) + '</a>';
  };

  this._getActionUri = function () {
    // Link to the profile of the user who reacted to the story
    return 'spotify:user:' + this.data.subject[0].canonical_username;
  };

  this._buildContent = function (callback, opt_html) {
    var reactorName = this.data.subject[0].canonical_username,
        reactorRealName = this.data.subject[0].real_name,
        reactorInfo = opt_html ? Notification.getContentLink('user', reactorRealName, reactorName) : reactorRealName;

    var notifStoryType = this.data.social_reaction_object[0].story_type,
        notifReactionType = this.data.social_reaction_object[0].reaction;

    var spotifyUri = this.data.social_reaction_object[0].item_uri;

    var uri = URI.fromURI(spotifyUri),
        tokenString = SocialReactionNotification.getTokenString(notifStoryType, uri, notifReactionType);

    if (URI.Type.ARTIST === uri || URI.Type.PLAYLIST === uri) {
      live(uri).query('name', function (error, item) {
        if (error) {
          debug('Could not load social reaction item', error);
        }

        var itemInfo = opt_html ? buildLink(spotifyUri, item.name) : item.name;
        callback(strings.get(tokenString, reactorInfo, itemInfo));
      });
    } else if (URI.Type.TRACK === uri || URI.Type.ALBUM === uri) {
      live(uri).query('name', 'artists', function (error, item) {
        if (error) {
          debug('Could not load social reaction item', error);
        }

        var itemInfo = opt_html ? buildLink(spotifyUri, item.name) : item.name,
            artists = [],
            artistName;

        for (var i = 0; i < item.artists.length; i++) {
          artistName = item.artists[i].name;
          artists.push(opt_html ? buildLink(item.artists[i].uri, artistName) : artistName);
        }

        callback(strings.get(tokenString, reactorInfo, i18nList(artists), itemInfo));
      });
    }
  };

  this._buildContentHtml = function (onContentHtmlReady) {
    this._buildContent(onContentHtmlReady.bind(this), true);
  };

  this.getText = function (callback) {
    var titleStringId;
    switch (this.data.social_reaction_object[0].reaction) {
      case 'LIKED_SOCIAL_REACTION':
        titleStringId = 'sNotificationTitleSocialReactionLike';
        break;
      case 'STREAMED_SOCIAL_REACTION':
        titleStringId = 'sNotificationTitleSocialReactionPlay';
        break;
      default:
        return;
    }

    this._buildContent(callback.bind(null, strings.get(titleStringId)));
  };
}

SocialReactionNotification.prototype = new Notification();

/**
 * Gets the key that indexes into the notifications strings.
 *
 * @param {StoryTypes} storyTypes The story type.
 * @param {Object} uri The uri of the notification (artist, song, etc.).
 * @param {ReactionTypes} reactionType The reaction type.
 * @return {string} The token string.
 */
SocialReactionNotification.getTokenString = function (storyType, uri, reactionType) {
  var baseString = 'sNotificationBodySocialReaction',
      storyTypeString,
      reactionTypeString,
      itemTypeString;

  switch (storyType) {
    case 'FOLLOWED_PROFILE_BOUNCER_STORY':
      storyTypeString = 'SocialStory';
      break;
    case 'PUBLISHED_PLAYLIST_BOUNCER_STORY':
      storyTypeString = 'Share';
      break;
    case 'FOLLOWED_PLAYLIST_BOUNCER_STORY':
      storyTypeString = 'SocialStory';
      break;
    case 'SHARED_URI_BOUNCER_STORY':
      storyTypeString = 'Share';
      break;
    default:
      return null;
  }

  switch (reactionType) {
    case 'LIKED_SOCIAL_REACTION':
      reactionTypeString = 'Like';
      break;
    case 'STREAMED_SOCIAL_REACTION':
      reactionTypeString = 'Play';
      break;
    default:
      return null;
  }

  if (URI.Type.ARTIST === uri) {
    itemTypeString = 'Artist';
  } else if (URI.Type.TRACK === uri) {
    itemTypeString = 'Song';
  } else if (URI.Type.ALBUM === uri) {
    itemTypeString = 'Album';
  } else if (URI.Type.PLAYLIST === uri) {
    itemTypeString = 'Playlist';
  } else {
    return null;
  }

  return baseString + reactionTypeString + itemTypeString + storyTypeString;
};

exports.Notification = Notification;
exports.AlbumReleasedNotification = AlbumReleasedNotification;
exports.AppReleasedNotification = AppReleasedNotification;
exports.FriendJoinedNotification = FriendJoinedNotification;
exports.MessagePlayedNotification = MessagePlayedNotification;
exports.NewFollowerNotification = NewFollowerNotification;
exports.PlaylistSubscribeNotification = PlaylistSubscribeNotification;
exports.PlaylistUpdatedNotification = PlaylistUpdatedNotification;
exports.SocialReactionNotification = SocialReactionNotification;

},{"../../../libs/spotify-events/player":46,"../../../libs/spotify-events/scrollbar":55,"../../../libs/spotify-glue-cat/templates/v1/share-object.hbs":86,"../../../libs/spotify-handlebars":101,"../../../libs/spotify-handlebars/helpers":92,"../../../libs/spotify-live":118,"../../../libs/spotify-live-models/album":106,"../../../libs/spotify-live-models/application":107,"../../../libs/spotify-live-models/artist":108,"../../../libs/spotify-live-models/playlist":110,"../../../libs/spotify-live-models/track":111,"../../../libs/spotify-live-models/user":112,"../i18n/index":11,"../package.json":21,"./config":23,"spotify-liburi":256}],27:[function(require,module,exports){
'use strict';

var hermes = require('../../../libs/api-cjs/scripts/hermes');
var Config = require('./config').Config;
var Notification = require('./notification').Notification;

var debug = Config.getDebug();

/**
 * Notifications proxy constructor.
 * @param {string} username User name to be used in the Hermes URL.
 * @constructor
 */
function NotificationsProxy(username) {
  this._baseUrl = 'hm://' + Config.getHermesEndpoint() + '/feed/' + encodeURIComponent(username + ':inclient') + '/';
  this._schema = hermes.Schema.fromURL(Config.getProtoFilePath());
  debug('Using Hermes URL: ' + this._baseUrl);
}

/**
 * Subscribe to be notified on incoming notifications.
 * @param {Function} callback Callback for the Hermes response.
 */
NotificationsProxy.prototype.subscribe = function (callback) {
  var promise = hermes.Hermes.subscribe(this._baseUrl, [this._schema.type('Notification')], [], []);
  promise.done(this, function (sub) {
    callback({ success: true, sub: sub });
  });
  promise.fail(this, function (_, error) {
    callback({ success: false, error: error });
  });
};

/**
 * Request the unread count.
 * @param {Function} callback Callback for the Hermes response.
 */
NotificationsProxy.prototype.getUnreadCount = function (callback) {
  var hermesUrl = this._baseUrl + 'counts';
  var promise = hermes.Hermes.get(hermesUrl, [this._schema.type('NotificationCounts')], []).send();
  promise.done(this, function (response) {
    var unread = response[0].active;
    callback({ success: true, unread: unread });
  });
  promise.fail(this, function (_, error) {
    callback({ success: false, error: error });
  });
};

/**
 * Mark all notifications as read.
 * @param {Function} callback Callback for the Hermes response.
 */
NotificationsProxy.prototype.markAllAsRead = function (callback) {
  var hermesUrl = this._baseUrl + 'states/all/';
  var promise = hermes.Hermes.request('PUT', hermesUrl, [], [this._schema.type('NotificationState')]).send({ 'seen': true });
  promise.done(this, function () {
    callback({ success: true });
  });
  promise.fail(this, function (_, error) {
    callback({ success: false, error: error });
  });
};

/**
 * Get the latest notifications.
 * @param {Function} callback Callback for the Hermes response.
 */
NotificationsProxy.prototype.getLatestNotifications = function (callback) {
  this._fetchNotifications(callback, this._baseUrl + 'take/' + Config.DEFAULT_PAGE_SIZE);
};

/**
 * Get a page of notifications from the history.
 * @param {Function} callback Callback for the Hermes response.
 * @param {string} fromId Retrieve notifications older than this id.
 * @param {number} [amount] Amount of notifications to get. Defaults to Config.DEFAULT_PAGE_SIZE.
 */
NotificationsProxy.prototype.getNotificationsFrom = function (callback, fromId, amount) {
  var take = amount || Config.DEFAULT_PAGE_SIZE;
  this._fetchNotifications(callback, this._baseUrl + 'from/' + fromId + '/take/' + take);
};

/**
 * Fetch notifications.
 * @param {Function} callback Callback for the Hermes response.
 * @param {string} hermesUrl Hermes URL to be used in the request.
 * @private
 */
NotificationsProxy.prototype._fetchNotifications = function (callback, hermesUrl) {
  var promise = hermes.Hermes.get(hermesUrl, [this._schema.type('NotificationList')], []).send();
  promise.done(this, function (response) {
    var notification;
    var notifications = [];
    var rawNotifications = response[0].notification;
    if (rawNotifications instanceof Array) {
      for (var i = 0, l = rawNotifications.length; i < l; i++) {
        try {
          notification = Notification.createNotification(rawNotifications[i].in_client_data);
        } catch (e) {
          // Discard malformed notifications
          continue;
        }
        notifications.push(notification);
      }
    }
    callback({ success: true, notifications: notifications });
  });
  promise.fail(function (_, error) {
    callback({ success: false, error: error });
  });
};

exports.NotificationsProxy = NotificationsProxy;

},{"../../../libs/api-cjs/scripts/hermes":28,"./config":23,"./notification":26}],28:[function(require,module,exports){
'use strict';

var models = require('./models');

/**
 * Functionality for performing Hermes requests.
 *
 * @exports api/hermes
 * @since 1.0.0
 *
 * @private
 *
 * @example
 * require(['./hermes'], function(hermes) {
 *   // Load a .proto file.
 *   var schema = hermes.Schema.fromURL('proto/suggestion.proto');
 *
 *   // Create a Hermes request object (this will not send the request).
 *   var request = hermes.Hermes.get(
 *       'hm://socialgraph/suggestions/people/',
 *       [schema.type('UserSuggestionReply')],
 *       [schema.type('SuggestionRequest')]);
 *
 *   // Send the request with a parameter (maps to SuggestionRequest in .proto
 *   // file).
 *   request.send({reasons: ['FACEBOOK']}).done(function(frames) {
 *     console.log('You should follow these Facebook friends of yours:');
 *     // Output results (data maps to UserSuggestionReply in .proto file).
 *     frames[0].suggestions.forEach(function(suggestion) {
 *       console.log(suggestion.username);
 *     });
 *   });
 * });
 */

var Loadable = models.Loadable;
var Promise = models.Promise;

/**
 * A map of ReadyState values (same as the WebSocket API).
 * @enum {number}
 *
 * @private
 */
var ReadyState = {
  CONNECTING: 0,
  OPEN: 1,
  CLOSING: 2,
  CLOSED: 3
};

/**
 * Helper function to be used in map() to convert a schema type into a schema
 * type string that can be passed over the bridge. Broken out into a separate
 * function so that we can avoid creating anonymous functions each time when
 * sending a request.
 *
 * @private
 */
function _type(type) {
  return type.schema.id + '#' + type.name;
}

/**
 * @class
 * @classdesc Hermes needs description.
 * @since 1.0.0
 *
 * @private
 */
function Hermes() {}

/**
 * Constructs a Hermes GET request with a given URI and description of the
 * result and argument types. The types come from a Schema that was created
 * earlier.
 *
 * @since 1.0.0
 *
 * @param {string} uri The Hermes hm:// URI for the GET request.
 * @param {Array} resultTypes An array of types for the result of the Hermes
 *     request. Can be empty if you do not care about the result.
 * @param {Array} argumentTypes An array of types for each of the arguments
 *     of the request.
 * @param {number} timeout The timeout of the request, in milliseconds.
 * @return {module:api/hermes~Request} A Hermes request.
 *
 * @see module:api/hermes~Schema#fromURL
 * @see module:api/hermes~Schema#type
 */
Hermes.get = function (uri, resultTypes, argumentTypes, timeout) {
  return new Request('GET', uri, resultTypes, argumentTypes, timeout);
};

/**
 * Constructs a Hermes request with a given method, URI and description of
 * the result and argument types. The types come from a Schema that was
 * created earlier.
 *
 * @param {string} method Hermes-method to use; GET, PUT, PATCH etc.
 * @param {string} uri The Hermes hm:// URI for the request.
 * @param {Array} resultTypes An array of types for the result of the Hermes
 *     request. Can be empty if you do not care about the result.
 * @param {Array} argumentTypes An array of types for each of the arguments
 *     of the request.
 * @param {number} timeout The timeout of the request, in milliseconds.
 * @return {module:api/hermes~Request} A Hermes request.
 *
 * @since 1.7.3
 *
 * @see Schema#fromURL
 * @see Schema#type
 */
Hermes.request = function (method, uri, resultTypes, argumentTypes, timeout) {
  return new Request(method, uri, resultTypes, argumentTypes, timeout);
};

/**
 * Subscribes to a PubSub topic. Returns a promise which will be resolved
 * once the subscription has been created. The promise resolves to a
 * Subscription object which will trigger "message" events.
 *
 * @param {string} uri The Hermes hm:// URI for the PubSub topic.
 * @param {Array} resultTypes An array of types for the messages that come in
 *     through the subscription.
 * @param {Array} argumentTypes An array of types for each of the arguments
 *     of the request.
 * @return {module:api/models~Promise} A promise for the request. When the
 *     promise has been fulfilled, the subscription is running. The object of
 *     the promise will be a Subscription which will have "message" events
 *     triggered on it.
 *
 * @example
 * hermes.Hermes.subscribe('hm://collection/collection', [schema.type('CollectionItems')], [], [])
 *     .done(function(sub) {
 *       console.log('Subscribed.');
 *       sub.addEventListener('message', function(event) {
 *         console.log('Message:', event.frames[0]);
 *       });
 *     })
 *     .fail(function(_, error) {
 *       console.error('Subscribe failed!', error);
 *     });
 */
Hermes.subscribe = function (uri, resultTypes, argumentTypes, args) {
  var promise = new models.Promise();
  var done = function done(data) {
    promise.setDone(new Subscription(data.subscription_id));
  };
  var fail = function fail(_, error) {
    promise.setFail(error);
  };

  var rload = Promise.join(resultTypes.map(function (type) {
    return type.schema.load('id');
  }));
  var aload = Promise.join(argumentTypes.map(function (type) {
    return type.schema.load('id');
  }));
  Promise.join(rload, aload).done(function () {
    var rtypes = resultTypes.map(_type);
    var atypes = argumentTypes.map(_type);
    SP.request('hermes_subscribe', [uri, rtypes, atypes, args], null, done, fail);
  }).fail(fail);

  return promise;
};

/**
 * @class
 * @extends {module:api/models~Loadable}
 * @classdesc A Hermes request that can be sent multiple times with different
 *     arguments. To create a new request, use of the methods of the Hermes
 *     helper class.
 * @since 1.0.0
 *
 * @see module:api/hermes~Hermes#get
 *
 * @private
 */
function Request(method, uri, resultTypes, argumentTypes, timeout) {
  Loadable.call(this);

  this.resolve('uri', uri);
  this.resolve('method', method);
  this.resolve('timeout', timeout || 0);
  this._rtypes = resultTypes;
  this._atypes = argumentTypes;

  // Start loading the schemas of the result and argument types. This might be
  // a combination of different schemas, or it might be the same one for all
  // types. Everything is joined together into a single promise.
  var rload = Promise.join(this._rtypes.map(function (type) {
    return type.schema.load('id');
  }));
  var aload = Promise.join(this._atypes.map(function (type) {
    return type.schema.load('id');
  }));
  this._load = Promise.join(rload, aload);
}
SP.inherit(Request, Loadable);

Loadable.define(Request, ['uri', 'method', 'timeout']);

/**
 * Sends the Hermes request with a unique set of arguments. The number of
 * arguments should match the number of argument types used when creating the
 * request.
 *
 * @since 1.0.0
 *
 * @param {...*} var_args Any number of arguments.
 * @return {module:api/models~Promise} A promise for the request. When the
 *     promise has been fulfilled, the request has completed. The object of
 *     the promise is an array containing all of the replies. Even if there
 *     is only one reply, it will be contained in an array of one element.
 */
Request.prototype.send = function (var_args) {
  var promise = new Promise();
  var request = this;
  var reqArg = [].slice.call(arguments);
  this._load.done(function () {
    var done = function done(data) {
      promise.setDone(data.result);
    };
    var rtypes = request._rtypes.map(_type);
    var atypes = request._atypes.map(_type);
    var requestArgs = [request.uri, request.method, rtypes, atypes, reqArg, request.timeout];
    SP.request('hermes_send_request', requestArgs, promise, done, promise.setFail);
  }).fail(function (o, error) {
    promise.setFail(error);
  });
  return promise;
};

/**
 * To create an instance of this class, use the fromURL method.
 *
 * @class
 * @extends {module:api/models~Loadable}
 * @classdesc A Hermes schema contains a collection of messages and
 *     enumerations. Messages that are contained within the same schema can
 *     refer each other, but not to messages in other schemas.
 * @since 1.0.0
 *
 * @see module:api/hermes~Schema#fromURL
 *
 * @private
 */
function Schema(urls) {
  Loadable.call(this);
  this._urls = urls;
}
SP.inherit(Schema, Loadable);

Loadable.define(Schema, ['id'], '_register');

/**
 * Call this method to load a new schema from a collection of .proto files.
 * The .proto files must be contained within the application's bundle.
 *
 * @param {Array.<string>|string} urls An array of URL strings. Each URL must
 *     point to an existing and valid .proto file. The parameter can also be
 *     a single URL string.
 * @return {module:api/hermes~Schema} A schema for the specified .proto file.
 *
 * @since 1.0.0
 */
Schema.fromURL = function (urls) {
  if (typeof urls === 'string') urls = [urls];
  return new this(urls);
};

/**
 * TODO: Documentation needed.
 *
 * @param {string} name Name.
 *
 * @return {{schema: module:api/hermes~Schema, name: string}}
 *     TODO: Documentation needed.
 */
Schema.prototype.type = function (name) {
  return { schema: this, name: name };
};

/**
 * TODO: Documentation needed.
 *
 * @param {number} propsMask Property mask.
 *
 * @private
 */
Schema.prototype._register = function (propsMask) {
  var load = function load(data) {
    this.resolveMany(propsMask, data);
  };
  var fail = function fail(oops) {
    this.resolveFail(propsMask, oops);
  };
  SP.request('hermes_register_schema', this._urls, this, load, fail);
};

/**
 * @class
 * @extends {module:api/models~BridgeLoadable}
 * @classdesc A running subscription of PubSub messages. To get messages, you
 *     need to listen for the "message" event.
 *
 * @private
 */
function Subscription(id) {
  models.BridgeLoadable.call(this);

  this.readyState = ReadyState.OPEN;
  this._id = id;
}
SP.inherit(Subscription, models.BridgeLoadable);

/**
 * @private
 */
Subscription.prototype._observed = function () {
  if (this.readyState != ReadyState.OPEN) return;

  this.bridgeListen('hermes_event_wait', [this._id]);

  // Listen to close events from the bridge.
  this.addEventListener('close', function onClose() {
    this.removeEventListener('close', onClose);

    // Stop expecting events from the bridge.
    this.bridgeUnlisten();
    this.readyState = ReadyState.CLOSED;
  });
};

/**
 * Stops subscribing to the PubSub topic.
 */
Subscription.prototype.close = function () {
  if (this.readyState != ReadyState.OPEN) return;
  this.readyState = ReadyState.CLOSING;

  SP.request('hermes_unsubscribe', [this._id]);
};

exports.Hermes = Hermes;
exports.ReadyState = ReadyState;
exports.Schema = Schema;
exports.Subscription = Subscription;

},{"./models":29}],29:[function(require,module,exports){
'use strict'; /**
 * Functionality for working with objects in the Spotify universe.
 *
 * @module api/models
 */ /**
 * Request callback that resolves the object of the promise with the request
 * result.
 *
 * @this {module:api/models~Promise}
 *
 * @private
 */var _resolveResult=function _resolveResult(result){this.object.resolveMany(0,result);this.setDone();}; /**
 * Set a promise to done.
 *
 * @this {module:api/models~Promise}
 *
 * @private
 */var _setDone=function _setDone(){this.setDone();}; /**
 * Performs a bridge request and returns a promise for that request.
 *
 * @param {Object} object The object to return in the promise callbacks.
 * @param {string} request The request to make.
 * @param {Array} args Arguments to send with the request.
 * @param {boolean=} opt_resolveResult Whether to also resolve the result on
 *     the object. Useful when the request returns updated data.
 * @return {module:api/models~Promise} A promise that will resolve when the
 *     request is complete.
 */var promisedRequest=function promisedRequest(object,request,args,opt_resolveResult){var promise=new Promise(object);SP.request(request,args,promise,opt_resolveResult?_resolveResult:_setDone,promise.setFail);return promise;}; /**
 * Helper function to create an Artist object from an object containing both the
 * URI and the metadata of the artist. Used to create the "artists" property of
 * both Album and Track.
 *
 * @private
 */var _artists=function _artists(metadataWithUri){return Artist.fromURI(metadataWithUri.uri,metadataWithUri);}; /**
 * Helper function to create an Album object from an object containing both the
 * URI and the metadata of the album. Used to create the "albums" property of
 * AlbumGroups.
 *
 * @private
 */var _albums=function _albums(metadataWithUri){return Album.fromURI(metadataWithUri.uri,metadataWithUri);}; /**
 * Helper function to create a Disc object from an object containing both the
 * URI and the metadata of the disc. Used to create the "discs" property of
 * Albums.
 *
 * @private
 */var _discs=function _discs(metadataWithUri){return Disc.fromURI(metadataWithUri.uri,metadataWithUri);}; /**
 * All "metadata items" (Album, Artist, Playlist, Track and User) are cached on
 * JavaScript side, because it is quite expensive to cross the bridge each time
 * one is needed. The cached items may not contain no metadata, some metadata
 * or all metadata. The items are never evicted from the cache, but a longer
 * term plan is to implement that though, so the user of the API cannot depend
 * on the fact that Item.fromURI always returns the same item for a given URI.
 *
 * @class
 * @since 1.0.0
 * @ignore
 *
 * @param {Function} itemClass The type of the items that the cache is for.
 */function Cache(itemClass){ /**
   * A map of URIs to object instances.
   * @type {Object.<string, Object>}
   * @private
   */this._items={}; /**
   * The type of the items that the cache is for.
   * @type {Function}
   * @private
   */this._class=itemClass;} /**
 * Looks up an item in the cache for this class.
 *
 * @since 1.0.0
 *
 * @param {string} uri The URI of the item to look up.
 * @param {Object=} opt_metadata Metadata to fill the object with if it isn't
 *     in the cache.
 * @return {module:api/models~Loadable} An item from the cache (or a newly
 *     created instance now in the cache).
 */Cache.lookup=function(uri,opt_metadata){return this._cache.lookup(uri,opt_metadata);}; /**
 * Looks up a list of items in the cache for this class.
 *
 * @since 1.3.0
 *
 * @param {Array.<string>} uris The URIs of the items to look up.
 * @return {Array.<module:api/models~Loadable>} A list of items from the cache
 *     (or newly created instances, now also stored in the cache).
 */Cache.lookupMany=function(uris){var result=[];for(var i=0,len=uris.length;i<len;i++){result.push(this._cache.lookup(uris[i]));}return result;}; /**
 * Put an item in the cache.
 *
 * @since 1.0.0
 *
 * @param {string} uri The URI of the item to cache.
 * @param {module:api/models~Loadable} item The item to cache.
 */Cache.prototype.cache=function(uri,item){this._items[uri]=item;}; /**
 * Looks up an item in the cache, creating it and filling it with the provided
 * metadata if it doesn't exist in the cache.
 *
 * @since 1.0.0
 *
 * @param {string} uri The URI of the item to look up.
 * @param {Object=} opt_metadata Metadata to fill the object with if it isn't
 *     in the cache.
 * @return {module:api/models~Loadable} An item from the cache (or a newly
 *     created instance now in the cache).
 */Cache.prototype.lookup=function(uri,opt_metadata){if(!uri)return null;var item=this._items[uri];if(!(item instanceof this._class)){item=new this._class(uri);item.resolveMany(0,opt_metadata);this._items[uri]=item;}return item;}; /**
 * Removes an item from the cache.
 *
 * @since 1.0.0
 *
 * @param {string} uri The URI of the item to remove.
 */Cache.prototype.remove=function(uri){delete this._items[uri];}; /**
 * Updates a property on one or more items in the cache.
 *
 * @since 1.0.0
 *
 * @param {Array.<string>} uris The URIs of one or more items to update.
 * @param {Object} data An object with properties and values to update the
 *     items with.
 */Cache.prototype.update=function(uris,data){for(var i=0,len=uris.length;i<len;i++){var item=this._items[uris[i]];if(item)item.resolveMany(0,data);}}; /**
 * @class
 * @classdesc The base class for all objects that can be observed with
 *     addEventListener.
 * @since 1.0.0
 *
 * @example
 * function MyClass() {
 *   Observable.call(this);
 *
 *   this.something = 127;
 * }
 * SP.inherit(MyClass, Observable);
 */function Observable(){} /**
 * This method is called when the first event listener is added to this
 * Observable. Subclasses may override this method in order to lazily initialize
 * resources related to event listening.
 *
 * @since 1.0.0
 * @ignore
 *
 * @protected
 */Observable.prototype._observed=function(){}; /**
 * Same as the addEventListener in standard JavaScript. Call this method to add
 * an observer to the receiver object, for a given named event.
 *
 * @since 1.0.0
 *
 * @param {string} eventType The name of the event to get notifications for.
 * @param {Function} observer The callback function. To unregister the
 *     callback, the exact same function must be passed to the
 *     removeEventListener method.
 *
 * @see module:api/models~Observable#removeEventListener
 *
 * @example
 * models.player.addEventListener('change', updateNowPlayingWidget);
 */Observable.prototype.addEventListener=function(eventType,observer){if(!observer)return;if(!this._ob){this._ob={};this._obcount=0;}var callbacks=this._ob[eventType];if(callbacks)callbacks.push(observer);else this._ob[eventType]=[observer];this._obcount++;if(this._obcount==1)this._observed();}; /**
 * Same as the removeEventListener in standard JavaScript. Call this method to
 * remove an observer that was previously added.
 *
 * @since 1.0.0
 *
 * @param {string} eventType The name of the event you're getting notifications
 *     for.
 * @param {Function} observer The callback must be the exact same function
 *     instance as was used in the registration, and not just an identical
 *     anonymous function.
 *
 * @see module:api/models~Observable#addEventListener
 *
 * @example
 * models.player.removeEventListener('change', updateNowPlayingWidget);
 */Observable.prototype.removeEventListener=function(eventType,observer){var observers=this._ob||{};var callbacks=observers[eventType]||[];var index=callbacks.indexOf(observer);if(index!=-1){this._obcount--;callbacks.splice(index,1);if(!callbacks.length)delete observers[eventType];if(!this._obcount)delete this._ob;}}; /**
 * Triggers an event for all observer callbacks. Any callback that explicitly
 * returns false or calls preventDefault() will cause the return value of this
 * function to be false.
 *
 * @since 1.0.0
 *
 * @param {{type: string}|string} evt The event object to dispatch (must have a
 *     type property), or simply the event type as a string.
 * @return {boolean} False if the event was prevented; otherwise, true.
 */Observable.prototype.dispatchEvent=function(evt){if(typeof evt=='string'){evt={type:evt};}if(!evt||!evt.type){throw new Error('Dispatched event must have a type.');}if(!evt.target){evt.target=this;}var observers=this._ob||{};var callbacks=(observers[evt.type]||[]).slice(0);if(!callbacks.length)return true;var ret=true;evt.preventDefault=function(){ret=false;};for(var i=0;i<callbacks.length;i++){try{if(callbacks[i].call(this,evt)===false)ret=false;}catch(error){console.error(error);if(SP._throwError)throw error;}}return ret;}; /**
 * @class
 * @classdesc A promise is an object that represents a pending query that will
 *     be resolved at some point in the future. A query may either be done or
 *     it may fail. Depending on the outcome, the appropriate callbacks will be
 *     called. A number of promises may be joined using {@link Promise#join} to
 *     make it easy to run a function once several independent queries have all
 *     been resolved.
 * @since 1.0.0
 *
 * @property {*} object An object that will be passed to the callbacks when the
 *     promise resolves.
 *
 * @param {Object=} opt_object An object that will be passed to the always/
 *     done/fail/each callbacks.
 */function Promise(opt_object){this.object=opt_object;this._done=[];this._fail=[];} /**
 * When the promise is resolved (success or failure doesn't matter), callbacks
 * registered by this method will be invoked. If the promise has already
 * resolved, the callback function will be called immediately, without waiting
 * for the next runloop iteration. The argument to the callback function is the
 * object used to resolve the promise.
 *
 * @since 1.0.0
 *
 * @param {Object|function(Object)} callbackOrThis If this argument is an
 *     object, it will be used as the "this" context object when calling the
 *     callback. If this argument is the callback function instead, the "this"
 *     context object will be the promise when the callback is called.
 * @param {function(Object)=} opt_callback The callback function to invoke,
 *     unless specified as the first argument.
 * @return {module:api/models~Promise} Returns the same instance, so that the
 *     callback method calls can be easily called in sequence.
 *
 * @example
 * models.Artist.fromURI('spotify:artist:74terC9ol9zMo8rfzhSOiG').load('name')
 *     .done(function(artist) { console.log(artist.name); })
 *     .fail(function(artist, error) { console.log(error.message); })
 *     .always(function(artist, maybeError) { console.log('Done or failed.'); });
 */Promise.prototype.always=function(callbackOrThis,opt_callback){var cbFunc,cbThis;if(opt_callback){cbFunc=opt_callback;cbThis=callbackOrThis;}else {cbFunc=callbackOrThis;cbThis=this;}if(typeof cbFunc!='function')throw new Error('A callback function is required');if(this._done){ // If the _done property exists, this promise has not resolved yet.
this._done.push(SP.callback(SP.bind(cbFunc,cbThis)));this._fail.push(SP.callback(SP.bind(cbFunc,cbThis)));}else {cbFunc.apply(cbThis,this._args);}return this;}; /**
 * When the promise is resolved successfully, callbacks registered by this
 * method will be invoked. If the promise has already resolved, the callback
 * function will be called immediately, without waiting for the next runloop
 * iteration. The argument to the callback function is the object used to
 * resolve the promise.
 *
 * @since 1.0.0
 *
 * @param {Object|function(Object)} callbackOrThis If this argument is an
 *     object, it will be used as the "this" context object when calling the
 *     callback. If this argument is the callback function instead, the "this"
 *     context object will be the promise when the callback is called.
 * @param {function(Object)=} opt_callback The callback function to invoke,
 *     unless specified as the first argument.
 * @return {module:api/models~Promise} Returns the same instance, so that the
 *     callback method calls can be easily called in sequence.
 *
 * @example
 * models.Artist.fromURI('spotify:artist:74terC9ol9zMo8rfzhSOiG').load('name')
 *     .done(function(artist) { console.log(artist.name); })
 *     .fail(function(artist, error) { console.log(error.message); });
 */Promise.prototype.done=function(callbackOrThis,opt_callback){var cbFunc,cbThis;if(opt_callback){cbFunc=opt_callback;cbThis=callbackOrThis;}else {cbFunc=callbackOrThis;cbThis=this;}if(typeof cbFunc!='function')throw new Error('A callback function is required');if(this._isDone)cbFunc.apply(cbThis,this._args);else if(this._done) // If the _done property exists, this promise has not resolved yet.
this._done.push(SP.callback(SP.bind(cbFunc,cbThis)));return this;}; /**
 * When the promise fails, callbacks registered by this method will be invoked.
 * If the promise has already failed, the callback function will be called
 * immediately, without waiting for the next runloop iteration. The argument to
 * the callback function is an error object describing the failure.
 *
 * @since 1.0.0
 *
 * @param {Object|function(Object)} callbackOrThis If this argument is an
 *     object, it will be used as the "this" context object when calling the
 *     callback. If this argument is the callback function instead, the "this"
 *     context object will be the promise when the callback is called.
 * @param {function(Object)=} opt_callback The callback function to invoke,
 *     unless specified as the first argument.
 * @return {module:api/models~Promise} Returns the same instance, so that the
 *     callback method calls can be easily called in sequence.
 *
 * @example
 * models.Track.fromURI('spotify:track:6a41rCqZhb2W6rpMolDR08').load('name')
 *     .done(function(track) { console.log(track.name); })
 *     .fail(function(track, error) { console.log(error.message); });
 */Promise.prototype.fail=function(callbackOrThis,opt_callback){var cbFunc,cbThis;if(opt_callback){cbFunc=opt_callback;cbThis=callbackOrThis;}else {cbFunc=callbackOrThis;cbThis=this;}if(typeof cbFunc!='function')throw new Error('A callback function is required');if(this._isFail)cbFunc.apply(cbThis,this._args);else if(this._fail) // If the _fail property exists, this promise has not resolved yet.
this._fail.push(SP.callback(SP.bind(cbFunc,cbThis)));return this;}; /**
 * For joined promises, the callback given to this method will be called once
 * for each of the promises in the join. Promises that fail will not invoke the
 * callback. When adding this callback to the promise, all joined promises that
 * already have completed will invoke the callback, in the order they resolved.
 * The argument to the callback is the same argument as given to the individual
 * promises.
 *
 * @since 1.0.0
 *
 * @param {Object|function(Object)} callbackOrThis If this argument is an
 *     object, it will be used as the "this" context object when calling the
 *     callback. If this argument is the callback function instead, the "this"
 *     context object will be the promise when the callback is called.
 * @param {function(Object)=} opt_callback The callback function to invoke,
 *     unless specified as the first argument.
 * @return {module:api/models~Promise} Returns the same instance, so that the
 *     callback method calls can be easily called in sequence.
 *
 * @example
 * var tracks = getSomeToplist();
 * var promises = [];
 * tracks.forEach(function(track) { promises.push(track.load('name')); });
 * models.Promise.join(promises)
 *     .each(function(track) { console.log('Loaded one track: ' + track.name); })
 *     .done(function(tracks) { console.log('Loaded all tracks.'); })
 *     .fail(function(tracks) { console.log('Failed to load at least one track.'); });
 */Promise.prototype.each=function(callbackOrThis,opt_callback){ // If this is not a joined promise, calling this method will be a no-op.
if(this._objs){var cbFunc,cbThis;if(opt_callback){cbFunc=opt_callback;cbThis=callbackOrThis;}else {cbFunc=callbackOrThis;cbThis=this;}if(typeof cbFunc!='function')throw new Error('A callback function is required');if(this._each){this._each.push(SP.callback(SP.bind(cbFunc,cbThis)));} // Call the newly added each callback for any objects that may already have
// resolved.
for(var i=0,l=this._objs.length;i<l;i++){cbFunc.call(cbThis,this._objs[i]);}}return this;}; /**
 * Resolves the promise, with the object that was specified when creating the
 * instance, set manually afterwards or passed to this method. All callbacks
 * for done will be called in the order they were registered.
 *
 * @since 1.0.0
 *
 * @param {*=} opt_object An optional object that should be passed on to all
 *     done handlers.
 */Promise.prototype.setDone=function(opt_object){if(!this._done)return;var done=this._done;var fail=this._fail;delete this._done;delete this._fail;if(arguments.length==1){this.object=opt_object;}this._isDone=true; // Must be set before invoking the callbacks.
this._args=[this.object];for(var i=0,l=done.length;i<l;i++){done[i].apply(undefined,this._args);} // first arg ignored as target is bound
for(var j=0,k=fail.length;j<k;j++){fail[j].clear();}delete this._each;delete this._join;delete this._numResolved;delete this._oneFailed;}; /**
 * Fails the promise, with the given error reason. All callbacks for fail will
 * be called in the order they were registered.
 *
 * @since 1.0.0
 *
 * @param {Object} error An error object describing what went wrong.
 */Promise.prototype.setFail=function(error){if(!this._done)return;var fail=this._fail;var done=this._done;delete this._done;delete this._fail;this._isFail=true; // Must be set before invoking the callbacks.
this._args=[this.object,error];for(var i=0,l=fail.length;i<l;i++){fail[i].apply(undefined,this._args);} // first arg ignored as target is bound
for(var j=0,k=done.length;j<k;j++){done[j].clear();}delete this._each;delete this._join;delete this._numResolved;delete this._oneFailed;}; /**
 * Joins several promises into a single promise that can be waited on. The done
 * and fail callbacks will be called when all of the promises have resolved or
 * any of the promises has failed respectively. The argument to the callback
 * function is an array with the resolved object of all promises. In addition
 * to these composite callbacks, the returned promise object has a method
 * called each, which can be used to get a callback when each of the promises
 * complete. The each callbacks will never be called again once the promise has
 * resolved or failed.
 *
 * @since 1.0.0
 *
 * @param {Array.<module:api/models~Promise>|...module:api/models~Promise} promises
 *     Either an array of promises to join or the promises as separate
 *     parameters.
 * @return {module:api/models~Promise} A new Promise that will be done/fail
 *     when all of the joined promises are done/failed.
 *
 * @example
 * var p1 = album.load('name');
 * var p2 = track.load('name', 'duration');
 * var wait = models.Promise.join(p1, p2); // or join([p1, p2]);
 * wait.done(albumAndTrackDone).fail(eitherFailed).each(eitherDone);
 */Promise.join=function(promises){var promise=new Promise();promises=SP.varargs(arguments,0,true);promise._join=promises;promise._each=[];promise._objs=[];promise._numResolved=0;if(promises.length===0)promise.setDone([]);for(var i=0,l=promises.length;i<l;i++){promises[i].done(promise,promise._oneDone).fail(promise,promise._oneFail);}return promise;}; /**
 * This method is called whenever a sub-promise resolves. Once all sub-promises
 * have resolved, this promise will also resolve. If one or more of the sub-
 * promises failed, this promise will also fail.
 *
 * @see module:api/models~Promise#join
 *
 * @private
 */Promise.prototype._oneEither=function(object){this._numResolved++;if(this._numResolved<this._join.length)return; // If the function doesn't return above, all promises have resolved. Collect
// all the objects into an array and make that the object of this promise.
this.object=[];for(var i=0,l=this._join.length;i<l;i++){this.object.push(this._join[i].object);} // We no longer need the each callbacks so we need to clean them up.
for(var j=0,k=this._each.length;j<k;j++){this._each[j].clear();} // If one or more of the promises failed, we want this promise to fail too.
if(this._oneFailed)this.setFail();else this.setDone();}; /**
 * Called when one of the joined promises resolves as done. Will go through the
 * list of each callbacks and call them with the same arguments as given to
 * this method. If this method is called after a done or fail callback has been
 * called nothing will happen, because our contract states that we must never
 * call one of the each callbacks after either the done or fail callbacks have
 * been called.
 *
 * @see module:api/models~Promise#join
 *
 * @private
 */Promise.prototype._oneDone=function(object){if(!this._done)return; // Keep track of resolved objects for any each callbacks added after this
// promise has resolved.
this._objs.push(object); // Call the each callbacks.
var nextEach=[];for(var i=0,l=this._each.length;i<l;i++){var cb=this._each[i];nextEach.push(cb.copy());cb.call(undefined,object); // first arg ignored as target is bound
}this._each=nextEach;this._oneEither(object);}; /**
 * Called when one of the joined promises resolves as failed. If this method is
 * called after a done or fail callback has been called nothing will happen,
 * because our contract states that we must never call one of the each
 * callbacks after either the done or fail callbacks have been called.
 *
 * @see module:api/models~Promise#join
 *
 * @private
 */Promise.prototype._oneFail=function(object,error){if(!this._done)return; // Mark the promise as failed. It won't fail straight away though since we
// may have more unresolved promises still in progress. Once all promises
// have resolved, we will resolve this promise as failed.
this._oneFailed=true;this._oneEither(object);}; /**
 * @class
 * @extends {module:api/models~Observable}
 * @classdesc This is the base class for all high level objects that are
 *     exposed in the API. The most important function is the load function,
 *     which must be called by the users of the object to indicate exactly what
 *     properties they are interested in. The caller cannot expect any other
 *     properties to be available on the object, even though some extra
 *     properties might show up there as an optimized fetch operation. The
 *     extra properties can and will change in the future and must not be read.
 * @since 1.0.0
 */function Loadable(){Observable.call(this); // this._done = 0 and this._wait = 0 are implicit since undefined acts the
// same as 0 for bitwise operations. This means that the subclass does not
// need to call this constructor at all.
}SP.inherit(Loadable,Observable); /**
 * Register a group of properties that can all be fetched using the same method
 * call. The method will be invoked once when any of the properties in the
 * group is loaded, and the method must return all of the properties in the
 * group: otherwise they will never be loaded, even if additional load calls
 * are made for those properties. They object will already have recorded that
 * there are no values for those properties.
 *
 * @since 1.0.0
 *
 * @param {Function} clazz The constructor to register properties for.
 * @param {Array.<string>} names The names of the properties.
 * @param {string=} opt_func The name of a function which should be used to
 *     request any of the properties in the group. The function should be on
 *     the prototype of "clazz".
 */Loadable.define=function(clazz,names,opt_func){var proto=clazz.prototype;if(!proto._prop)proto._prop={};if(!proto._next)proto._next=0;var group={mask:0,func:opt_func};for(var i=0,l=names.length;i<l;i++){var mask=1<<proto._next++;group.mask|=mask;proto._prop[names[i]]={mask:mask,group:group};}}; /**
 * Lets the subclasses transform the raw property values into high level objects
 * such as Album or Track. The bridge will in general send URIs for links to
 * other items, which can be passed to Track/Album/etc.fromURI to create the
 * actual objects. The transform method should never start a load of the objects
 * it creates, because that could end up in loading the entire world, and the
 * idea is that it is supposed to be cheap to create objects, and the expensive
 * operations should happen when actually loading the objects.
 *
 * @private
 *
 * @param {string} name Name of the property to make.
 * @param {*} value The value to use for making the property.
 * @return {*} The (possibly transformed) value to assign to the property.
 */Loadable.prototype._make=function(name,value){name='_make_'+name;var func=this[name];return func?func(value):value;}; /**
 * Resolves a single property on an object.
 *
 * @since 1.0.0
 *
 * @param {string} name The name of the property.
 * @param {*} value The new value.
 * @param {boolean=} opt_silent Whether to skip dispatching change events for
 *     any properties that change.
 */Loadable.prototype.resolve=function(name,value,opt_silent){var prop=this._prop[name];if(!prop)return;this._done|=this._prop[name].mask;this._wait&=~this._done;var newValue=this._make(name,value);if(this.hasOwnProperty(name)&&!opt_silent){ // The item already had this value, so if the value changed, dispatch a
// change event for anyone who may have read it and wants to know it
// changed.
var oldValue=this[name];if(oldValue!==newValue){this[name]=newValue;this.dispatchEvent({type:'change:'+name,property:name,oldValue:oldValue});}}else {this[name]=newValue;}if(!this._wait)delete this._wait;}; /**
 * Resolves many properties on an object.
 *
 * @since 1.0.0
 *
 * @param {number} propsMask A bitmask of properties to mark as done and unmark
 *     as waiting.
 * @param {Object} data A map of properties to update and their new values.
 * @param {boolean=} opt_silent Whether to skip dispatching change events for
 *     any properties that change.
 */Loadable.prototype.resolveMany=function(propsMask,data,opt_silent){for(var name in data){this.resolve(name,data[name],opt_silent);}this._done|=propsMask;this._wait&=~propsMask;this.resolveDone();}; /**
 * Signal that all calls to resolve are done, at least for the moment.
 *
 * @since 1.0.0
 *
 * @protected
 */Loadable.prototype.resolveDone=function(){if(!this._reqs)return;var done=[];for(var i=0;i<this._reqs.length;i++){if(!(this._reqs[i]._need&~this._done))done.push(this._reqs.splice(i--,1)[0]);}if(!this._reqs.length)delete this._reqs;if(!this._wait)delete this._wait;for(var j=0,l=done.length;j<l;j++){done[j].setDone();}}; /**
 * Signal that resolving failed.
 *
 * @since 1.0.0
 *
 * @protected
 */Loadable.prototype.resolveFail=function(propsMask,error){this._wait&=~propsMask;if(!this._reqs)return;var fail=[];for(var i=0;i<this._reqs.length;i++){if(this._reqs[i]._need&propsMask)fail.push(this._reqs.splice(i--,1)[0]);}if(!this._reqs.length)delete this._reqs;if(!this._wait)delete this._wait;for(var j=0,l=fail.length;j<l;j++){fail[j].setFail(error);}}; /**
 * Before any properties of an object can be read they must be loaded by calling
 * this function with a list of properties that the caller is interested in. The
 * only way to ensure that any properties are available on an object is to call
 * this method. After specifying what properties to load the caller must wait
 * for the returned promise to resolve before the properties can actually be
 * read from the object. If the promise fails, the properties must not be read.
 * Note that it is possible, and recommended, to call load multiple times with
 * different property lists. The properties should be grouped by how they are
 * used together. By specifiying a minimum set of properties for each call to
 * load, the callback will happen as soon as possible, sometimes without even
 * having to wait for additional metadata to be fetched remotely.
 *
 * @since 1.0.0
 *
 * @param {Array.<string>|...string} properties An array of property names. The
 *     property names that are available for loading can be found in the
 *     documentation for each specific sub-class. Note that instead of passing
 *     in an array, multiple arguments can be passed instead.
 * @return {module:api/models~Promise} A promise to wait for before the
 *     properties can be read.
 *
 * @example
 * models.Track.fromURI('…').load('name', 'duration').done(function(track) {
 *   console.log('The track ' + track.name + ' is ' + track.duration + ' ms long.');
 * });
 */Loadable.prototype.load=function(properties){var args=SP.varargs(arguments);var req=new Promise(this);req._need=this._neededForLoad(args);if(req._need){if(this._reqs)this._reqs.push(req);else this._reqs=[req];this._requestProperties(req._need);}else {req.setDone();}return req;}; /**
 * Checks what properties already exist and returns the intersection of those
 * and the properties to load. The returned value is the bitmask of all
 * properties that are needed, but not yet loaded, including the ones that are
 * waiting to get a reply. If the properties array is empty, a bitmask
 * representing all properties in the object is returned. This can be a very
 * request if properties must be loaded from different sources, so it must only
 * be used when debugging code as a convenience.
 *
 * @since 1.0.0
 *
 * @param {Array} properties An array of properties to get the bitmask for.
 *
 * @private
 */Loadable.prototype._neededForLoad=function(properties){var neededMask=0;for(var i=0,l=properties.length;i<l;i++){var name=properties[i];var prop=this._prop[name];if(!prop)throw new Error(name+' is not a property.');neededMask|=prop.mask;}return neededMask&~this._done;}; /**
 * @private
 */Loadable.prototype._requestProperties=function(propsMask){var groups=[];for(var name in this._prop){var prop=this._prop[name];var mask=prop.group.mask;if(!(mask&propsMask))continue; // skip: no overlap
if(mask&this._wait)continue; // skip: already sent
groups.push(prop.group);this._wait|=mask;propsMask&=~mask;if(!propsMask)break;}for(var i=0,l=groups.length;i<l;i++){var func=this[groups[i].func];if(func)func.call(this,groups[i].mask);}}; /**
 * @class
 * @extends {module:api/models~Loadable}
 * @classdesc Loadable that interacts with the bridge and handles some common
 *     functionality.
 * @since 1.0.0
 * @ignore
 */function BridgeLoadable(){Loadable.call(this);}SP.inherit(BridgeLoadable,Loadable); /**
 * Start listening for bridge events.
 *
 * @ignore
 *
 * @param {string} requestName Request name to make to the bridge.
 * @param {Array} requestArgs Args for the bridge request.
 */BridgeLoadable.prototype.bridgeListen=function(requestName,requestArgs){if(!this._listening){this._requestName=requestName;this._requestArgs=requestArgs;this._listening=true;this._eventWait();}}; /**
 * Stop listening for bridge events.
 *
 * @ignore
 */BridgeLoadable.prototype.bridgeUnlisten=function(){delete this._requestName;delete this._requestArgs; // There's no way to actually cancel the pending request. So we wait for the
// next timeout, and then no further SP.request will be made.
delete this._listening;}; /**
 * Renew the request to wait for a bridge event if we're supposed to be
 * listening.
 *
 * @private
 */BridgeLoadable.prototype._eventWait=function(){if(this._listening)SP.request(this._requestName,this._requestArgs,this,this._eventDone,this._eventFail);}; /**
 * Handler for bridge events, internal implementation.
 *
 * @private
 */BridgeLoadable.prototype._eventDone=function(event){this._eventWait();this.eventDone(event);}; /**
 * Handle an event.
 *
 * Default behavior: resolve the 'data' field from events into property updates
 * on this object. By default, a bridge event is redispatched as a JavaScript
 * event on this, unless a 'receiver' field is specified on the event. If
 * given, the 'receiver' field causes 'this[event.receiver]' to be the event
 * target instead of 'this'.
 *
 * Subclasses should override this method if they need custom functionality to
 * run on every bridge event. This should be a rare case.
 *
 * @param {Object} event Raw event object from the bridge.
 */BridgeLoadable.prototype.eventDone=function(event){if(event.receiver&&this.hasOwnProperty(event.receiver)){ // Event told us to use a member object as the event receiver.
var receiver=this[event.receiver];receiver.resolveMany(0,event.data);receiver.dispatchEvent(event);}else {this.resolveMany(0,event.data);this.dispatchEvent(event);}}; /**
 * Failure handler, internal implementation.
 *
 * @private
 */BridgeLoadable.prototype._eventFail=function(error){if(error.error=='timeout')this._eventWait();this.eventFail(error);}; /**
 * Handle a failure.
 *
 * Subclasses should replace this method if they need custom
 * functionality to run on an error.
 *
 * @param {Object} error Raw error object from the bridge.
 */BridgeLoadable.prototype.eventFail=function(error){}; /**
 * A bridge listener that does not handle events itself, but that can proxy
 * them to another bridge listener.
 *
 * @class
 * @extends {module:api/models~BridgeLoadable}
 * @since 1.2.0
 * @ignore
 */function ProxyListener(){BridgeLoadable.call(this); /**
   * Functions that can modify an event before it is proxied.
   * @type {Array.<Function>}
   * @private
   */this._filters=[]; /**
   * Other BridgeLoadables that will receive the events from this one.
   * @type {Array.<module:api/models~BridgeLoadable>}
   * @private
   */this._receivers=[];}SP.inherit(ProxyListener,BridgeLoadable); /**
 * Adds a filter which will be applied before proxying an event.
 *
 * A filter can prevent an event from being proxied by explicitly returning
 * false. It is also free to modify the event before it is passed on, or
 * otherwise making use of its data.
 *
 * @param {function(Object):boolean} filter A filter to apply to events.
 */ProxyListener.prototype.filter=function(filter){this._filters.push(filter);}; /**
 * Proxies events to the specified bridge listener. More than one receiver is
 * allowed.
 *
 * @param {module:api/models~BridgeLoadable} receiver Bridge listener to
 *     receive events from this one.
 */ProxyListener.prototype.proxyTo=function(receiver){this._receivers.push(receiver);}; /**
 * Applies filters and proxies the event instead of handling it on this
 *     instance.
 *
 * @override
 *
 * @param {Object} evt Raw event object from the bridge.
 */ProxyListener.prototype.eventDone=function(evt){ // Apply all filters before passing the event on to the receivers. However,
// if any of the filter functions return false, the event will not be passed
// on.
var i,len,proxy=true;for(i=0,len=this._filters.length;i<len;i++){if(this._filters[i](evt)===false)proxy=false;}if(!proxy)return;for(i=0,len=this._receivers.length;i<len;i++){this._receivers[i].eventDone(evt);}}; /**
 * @class
 * @extends {module:api/models~BridgeLoadable}
 * @classdesc The base class of all the "metadata objects": Album, Artist,
 *     Playlist, Track and User. It encapsulates all of the metadata request
 *     functionality, which is more or less the same for all types.
 */function MdL(uri){BridgeLoadable.call(this);}SP.inherit(MdL,BridgeLoadable); /**
 * Subclasses must call this method to set up some particulars of that subclass.
 * Failure to load this method will lead to runtime error when loading any
 * properties of the instances.
 */MdL.init=function(clazz,prefix){clazz._type=prefix;}; /**
 * Returns an image URI for a given minimum size in pixels. Note that this
 * method does takes into account the resolution of the device screen, which
 * means that if the application is running on a High-DPI display, such as an
 * iPhone 4 or iPad 3, the number of pixels in the image will be twice as many
 * as the number of requested CSS pixels. An application running on 3G might
 * want to choose to first transfer a half resolution image to get something on
 * the screen quickly and then request the full resolution image only when all
 * low resolution images have been loaded. Note that all of this is taken care
 * of automatically when using the included view classes, so most applications
 * should not need to worry too much about this. Before this method can be
 * called, the image property must have been loaded.
 *
 * @param {number} size The size, in pixels, of the shortest side of the the
 *     image. Note that not all images are square, so the image might be larger
 *     in one direction that the requested size, but it will not be smaller,
 *     unless the size exceeds the maximum image size allowed, which is
 *     platform specific and might change over time. Also note that the image
 *     can be larger than the requested minimum size.
 * @return {string} The URI of the image best suited for the provided size.
 *
 * @since 1.0.0
 *
 * @example
 * album.load('image').done(function() {
 *   div.style.backgroundImage = 'url(' + album.imageForSize(300) + ')';
 * });
 */MdL.prototype.imageForSize=function(size){var images=this.images;size*=window.devicePixelRatio||1;for(var i=0,l=images?images.length:0;i<l;i++){if(images[i][0]>=size||i==l-1)return images[i][1].replace('{size}',size);}return this.image;}; /**
 * Called by load to fetch the metadata of the item.
 *
 * @see MdL#_profile
 *
 * @private
 */MdL.prototype._metadata=function(propsMask){var load=function load(data){this.resolveMany(propsMask,data);};var fail=function fail(oops){this.resolveFail(propsMask,oops);};SP.request(this.constructor._type+'_metadata',[this.uri],this,load,fail);}; /**
 * Called by load to fetch the profile information of the item. The profile
 * information is a type of metadata for the item, but things that are quite
 * expensive to look up and of little interest to most users of the API. The
 * main use of the profile is the Artist object, which has some rarely used
 * properties, such as the biography and portait images. The most likely user
 * of the properties is the artist application. No need to punish every other
 * user of the Artist object.
 *
 * @see MdL#_metadata
 *
 * @private
 */MdL.prototype._profile=function(propsMask){var load=function load(data){this.resolveMany(propsMask,data);};var fail=function fail(oops){this.resolveFail(propsMask,oops);};SP.request(this.constructor._type+'_profile',[this.uri],this,load,fail);}; /**
 * Get a string representation of the object.
 *
 * @return {string} A string representation of the object.
 */MdL.prototype.toString=function(){return this.uri;}; /**
 * Never construct an album object using the default constructor - use
 * fromURI() instead.
 *
 * @class
 * @extends {module:api/models~MdL}
 * @classdesc The album represents any type of album (album, single or
 *     compilation) in the Spotify catalog.
 * @since 1.0.0
 *
 * @property {Array.<module:api/models~Artist>} artists The artists of the
 *     album.
 * @property {string} availability Describes how and when the album is
 *     available for playback for the currently logged in user. The value will
 *     be one of: "available", "banned", "regional", "premium" or
 *     "unavailable". "available" means that the album can be played, "banned"
 *     that the artist has chosen to not make the album available, "regional"
 *     that the album is playable in other regions but not in the region of the
 *     currently logged in user, "premium" means that this is premium only
 *     content and a premium account is needed in order to play the album (the
 *     playable property needs to be checked to actually see if the user can
 *     play it or not), and "unavailable" which means the album is unavailable
 *     for other reasons.
 * @property {Array.<string>} copyrights An array of strings with copyright
 *     holders for the album. The strings will be on the format "(C) 2012
 *     Company", where "(C)" can be a "(P)" and the year and company name is
 *     album specific. For copyright symbols, see:<br>
 *     <a href="http://en.wikipedia.org/wiki/Copyright_symbol">Wikipedia - Copyright symbol</a><br>
 *     <a href="http://en.wikipedia.org/wiki/Sound_recording_copyright_symbol">Wikipedia - Sound recording copyright symbol</a>
 * @property {Array} discs An array of discs which are collections of tracks.
 * @property {string} label The label that owns the rights to the album. By
 *     using this name in the search query "label:<name>" you can get all the
 *     albums for a given label.
 * @property {string} image The image URI for the album.
 *     The format of the image URI is platform dependent, but will always be
 *     something that can be used as the source of an img element or a
 *     background-image in CSS. The size of the image is not defined and might
 *     differ between platforms, so it is recommended that applications use the
 *     imageForSize method to get an appropriately sized image. In general,
 *     it's best to use the Image view from the views framework to display
 *     images - it will load the image in the background (while displaying a
 *     placeholder) and make sure to pick the correct size "intelligently",
 *     based on the current screen resolution and available bandwidth.
 * @property {string} name The name of the album. This is a human readable
 *     string that can be presented to the user. Make sure to call the proper
 *     string decoding method before using the string in the DOM.
 * @property {boolean} playable Indicates if the album is playable by the
 *     currently logged in user. An album can be unplayable for various
 *     reasons, such as regional restrictions or play count restrictions in the
 *     free service.
 * @property {number} popularity The popularity rating of the album. This is a
 *     value between 0 and 100, inclusive, with 0 meaning a very unpopular
 *     album and 100 a highly popular album.
 * @property {module:api/models~Collection} tracks The tracks of this album.
 * @property {string} type The type of album: "album", "single", "compilation"
 *     or undefined if the type is not known.
 * @property {string} uri The URI of the album.
 *
 * @param {string} uri The URI of the album.
 *
 * @see module:api/models~MdL#imageForSize
 * @see String#decodeForText
 * @see String#decodeForHtml
 * @see String#decodeForLink
 * @see module:api/models~Album#fromURI
 */function Album(uri){MdL.call(this);this.resolve('uri',uri);}SP.inherit(Album,MdL);Loadable.define(Album,['uri']);Loadable.define(Album,['availability','artists','date','discs','image','images', // Loaded when 'image' is loaded.
'label','name','playable','popularity','type'],'_metadata');Loadable.define(Album,['copyrights'],'_profile');Loadable.define(Album,['tracks'],'_collections');MdL.init(Album,'album'); /**
 * @private
 */Album.prototype._make_artists=function(value){return value&&value.map(_artists);}; /**
 * @private
 */Album.prototype._make_discs=function(value){return value&&value.map(_discs);}; /**
 * @private
 */Album.prototype._collections=function(){this.resolve('tracks',new BridgeCollection(Track,this.uri,'album_tracks'));this.resolveDone();}; /**
 * Returns the album for a given Spotify URI. The URI is the only property that
 * is loaded on the album immediately.
 *
 * @since 1.0.0
 *
 * @param {string} uri The Spotify URI of the album.
 * @return {module:api/models~Album} The album.
 *
 * @example
 * models.Album.fromURI('spotify:album:0hvxqdv8Bg6BXIbTQFr2Sd').load('name').done(function(album) {
 *   console.log(album.uri + ': ' + album.name.decodeForText());
 *   document.getElementById('album').innerHTML = album.name.decodeForHtml();
 * });
 */Album.fromURI=Cache.lookup; /**
 * Gets a list of albums from a list of URIs.
 *
 * @since 1.3.0
 *
 * @param {Array.<string>} uris List of URIs.
 * @return {Array.<module:api/models~Album>} A list of albums.
 */Album.fromURIs=Cache.lookupMany; /**
 * @private
 */Album._cache=new Cache(Album); /**
 * @class
 * @extends {module:api/models~MdL}
 * @classdesc Contains a list of tracks that belong to a single disc of an
 *     album.
 * @since 1.0.0
 */function Disc(uri){MdL.call(this);this.resolve('uri',uri);this.resolve('tracks',new BridgeCollection(Track,uri,'album_disc_tracks'));}SP.inherit(Disc,MdL);Loadable.define(Disc,['uri','tracks']);Loadable.define(Disc,['album','number'],'_metadata');MdL.init(Disc,'disc'); /**
 * @private
 */Disc.prototype._make_album=function(value){return value&&Album.fromURI(value);}; /**
 * Returns the disc for a given Spotify URI. The URI is the only property that
 * is loaded on the disc immediately.
 *
 * @since 1.0.0
 *
 * @param {string} uri The Spotify URI of the disc.
 * @return {module:api/models~Disc} The disc.
 *
 * @example
 * models.Disc.fromURI('spotify:album:1P1LYaTMV1LnDiHA3LOows:1').load('number').done(function(disc) {
 *   console.log(disc.uri + ': ' + disc.number);
 *   document.getElementById('discNumber').innerHTML = disc.number;
 * });
 */Disc.fromURI=Cache.lookup; /**
 * Gets a list of discs from a list of URIs.
 *
 * @since 1.3.0
 *
 * @param {Array.<string>} uris List of URIs.
 * @return {Array.<module:api/models~Disc>} A list of discs.
 */Disc.fromURIs=Cache.lookupMany; /**
 * @private
 */Disc._cache=new Cache(Disc); /**
 * @class
 * @extends {module:api/models~Loadable}
 * @classdesc Contains functionality related to the underlying client that is
 *     running this application.
 * @since 1.5.0
 * @ignore
 *
 * @property {Object.<string, boolean>} features The set of feature flags for
 *     this client. Each key in this object is the name of a feature, and the
 *     value is a boolean indicating whether the feature is enabled.
 */function Client(){BridgeLoadable.call(this);}SP.inherit(Client,BridgeLoadable); /**
 * @private
 */Client.prototype._observed=function(){this.bridgeListen('client_event_wait',[]);};Loadable.define(Client,['features'],'_features');Loadable.define(Client,['hide_hpto'],'_hide_hpto'); /**
 * @private
 */Client.prototype._features=function(propsMask){var load=function load(data){this.resolveMany(propsMask,data);};var fail=function fail(oops){this.resolveFail(propsMask,oops);};SP.request('client_features',[],this,load,fail);}; /**
 * @private
 */Client.prototype._hide_hpto=function(propsMask){var load=function load(data){this.resolveMany(propsMask,data);};var fail=function fail(oops){this.resolveFail(propsMask,oops);};SP.request('client_get_hide_hpto',[],this,load,fail);}; /**
 * Show the platform-specific sharing UI.
 *
 * @param {module:api/models~BridgeLoadable|string} item Item object to share.
 *     URI as a string is supported for now, but marked as deprecated.
 * @param {string=} opt_message Message to render initially in the sharing UI.
 * @param {{x: number, y: number}=} opt_point Point at which the sharing UI
 *     should be rendered. This point is in x,y coordinates relative to the
 *     application viewport.
 * @return {module:api/models~Promise} A Promise which will resolve
 *     successfully if the sharing UI is opened, and which will fail if the
 *     sharing UI could not be opened.
 *
 * @example
 * var item = models.Track.fromURI('spotify:track:2P2S1wxZYQYHRYDip79JiY');
 * var element = document.getElementById('myButton');
 * var rect = element.getBoundingClientRect();
 * models.client.showShareUI(item, 'Check out this track!',
 *     {x: rect.left, y: rect.top}).done(sharingOpenedSuccessfully);
 */Client.prototype.showShareUI=function(item,opt_message,opt_point){var uri=item.uri||item;var message=opt_message||'';var args=[uri,message];if(opt_point&&'x' in opt_point&&'y' in opt_point){args.push(opt_point.x);args.push(opt_point.y);}return promisedRequest(this,'client_show_share_ui',args);}; /**
 * Show the platform-specific context UI.
 *
 * @param {Array.<module:api/models~BridgeLoadable>|module:api/models~BridgeLoadable} item
 *     Items to show context UI for. The items in the array should be of the
 *     same type.
 * @param {{x: number, y: number}=} opt_point Point at which the context UI
 *     should be rendered. This point is in x,y coordinates relative to the
 *     application viewport.
 * @param {module:api/models~BridgeLoadable=} opt_origin
 *     Origin where the items come from.
 * @param {number=} opt_index Index of item within collection.
 * @return {module:api/models~Promise} A Promise which will resolve
 *     successfully if the context UI is opened, and which will fail if the
 *     context UI could not be opened.
 *
 * @example
 * var items = [
 *   models.Track.fromURI('spotify:track:2e2Z8FeqqvUClWqc23nuX1'),
 *   models.Track.fromURI('spotify:track:3k68IqyXiefjfjKy3BVOX0'),
 *   models.Track.fromURI('spotify:track:3jRHAsjvnSTmB5crrpqyTj')
 * ];
 * var element = document.getElementById('track');
 * var rect = element.getBoundingClientRect();
 * models.client.showContextUI(items, { x: rect.left, y: rect.top })
 *     .done(contextUIOpenedSuccessfully)
 *     .fail(contextUINotOpened);
 */Client.prototype.showContextUI=function(items,opt_point,opt_origin,opt_index){var uris=Array.isArray(items)?SP.uris(items):[items.uri];var args=[uris];if(opt_point&&'x' in opt_point&&'y' in opt_point){args.push(opt_point.x);args.push(opt_point.y);}if(opt_origin&&opt_origin.uri){args.push(opt_origin.uri);}if(typeof opt_index!=='undefined'&&opt_index%1===0){args.push(opt_index);}return promisedRequest(this,'client_show_context_ui',args);}; /**
 * Broadcast a string message to all apps listening to the "broadcast" event.
 *
 * @param {string} message Event name.
 * @return {module:api/models~Promise} A Promise which will resolve
 *     successfully if the event was sent.
 *
 * @example
 * models.client.addEventListener('broadcast', function(event) {
 *   console.log('Event: ', event.message); // == 'my-event'
 * });
 * models.client.broadcast('my-event');
 */Client.prototype.broadcast=function(message){return promisedRequest(this,'client_broadcast',[message]);}; /**
 * @class
 * @extends {module:api/models~BridgeLoadable}
 * @classdesc The application object manages the interaction between your
 *     application and the Spotify client it runs within. The arguments that
 *     were used to start the application can be accessed and observed, so that
 *     the application is notified whenever they change. Like all other objects
 *     in the Spotify API, the caller must make sure the object is loaded
 *     before accessing any of its properties.
 * @since 1.0.0
 *
 * @property {Array} arguments The arguments that were used to start the
 *     application, or the most recent arguments if they have changed since
 *     starting. Observe the "arguments" event to get notified when this
 *     happens.
 * @property {Array} dropped The most recent spotify items that were
 *     dragged and dropped into the app. Observe the "dropped" event to
 *     get notified when this happens.
 * @property {string} identifier The application identifier.
 * @property {string} name The localized application name.
 * @property {string} uri The URI of the application, without any arguments.
 *
 * @example
 * models.application.load('arguments').done(doSomethingWithTheArguments);
 * models.application.addEventListener('arguments', doSomethingWithTheArguments);
 */function Application(){BridgeLoadable.call(this);}SP.inherit(Application,BridgeLoadable); /**
 * @name module:api/models~Application#arguments
 * @desc Fired when the application's arguments have changed.
 * @event
 *
 * @param {Object} event The event object.
 */ /**
 * @name module:api/models~Application#activate
 * @desc Fired when the application is activated.
 * @event
 *
 * @param {Object} event The event object.
 */ /**
 * @name module:api/models~Application#deactivate
 * @desc Fired when the application is deactivated.
 * @event
 *
 * @param {Object} event The event object.
 */ /**
 * @name module:api/models~Application#dropped
 * @desc Fired when spotify items are dragged and dropped into the application.
 * @event
 *
 * @param {Object} event The event object.
 */Loadable.define(Application,['arguments','dropped','identifier','name','uri'],'_query'); /**
 * @private
 */Application.prototype._observed=function(){this.bridgeListen('application_event_wait',[]);}; /**
 * @private
 */Application.prototype._make_dropped=function(value){return value&&value.map(function(i){return fromURI(i);});}; /**
 * @private
 */Application.prototype._query=function(propsMask){var load=function load(data){this.resolveMany(propsMask,data);};var fail=function fail(oops){this.resolveFail(propsMask,oops);};SP.request('application_query',[],this,load,fail);}; /**
 * Makes a request to the current system to activate the application. Whether
 * or not this request is granted is not guaranteed, and implementations are
 * free to ignore this request.
 *
 * @since 1.0.0
 *
 * @example
 * finishedInitialization(…, function() {
 *   models.application.activate();
 * });
 */Application.prototype.activate=function(){return promisedRequest(this,'application_activate',[this.uri]);}; /**
 * Makes a request to the current system to deactivate the application. Whether
 * or not this request is granted is not guaranteed, and implementations are
 * free to ignore this request.
 *
 * @since 1.0.0
 *
 * @example
 * finishedDestruction(…, function() {
 *   models.application.deactivate();
 * });
 */Application.prototype.deactivate=function(){return promisedRequest(this,'application_deactivate',[this.uri]);}; /**
 * If specified in the application's manifest that a loading screen should be
 * put up in place of the application itself, when starting the application,
 * call this method to indicate that the application has finished loading
 * whatever it needs to display the initial state. Also call this method if the
 * manifest specifies that it can restore itself exactly to the state it had
 * when last deactivated. This will hide the screenshot of the application that
 * was made when the application deactivated, and is now used to hide the load.
 *
 * Note that there is no guarantee that the client will keep the loading screen
 * forever, if the application never calls this method. The client can choose
 * to hide the loading screen after an arbitrary timeout even if the
 * application has not completely finished loading, so care should be taken to
 * ensure that the state restoration is as fast as possible.
 *
 * @since 1.0.0
 *
 * @example
 * loadSavedStateFromLocalStorageAndRestoreDOM(…, function() {
 *   models.application.hideLoadingScreen();
 * });
 */Application.prototype.hideLoadingScreen=function(){SP.request('application_notify_loaded',[]);}; /**
 * Reads a single file from the application's bundle. The path is relative to
 * the root of the bundle. If there is a localized version of the file (in a
 * .loc sub-directory, e.g., en.loc, fr.loc), it will be returned instead of
 * the non-localized version.
 *
 * @since 1.0.0
 *
 * @param {string} path The file path, relative to the root of the
 *     application's bundle.
 * @return {module:api/models~Promise} A promise that will be fulfilled when
 *     the data has been read. The object of the promise is the data of the
 *     file.
 *
 * @example
 * models.application.readFile('messages.txt').done(gotMessages).fail(didNotGetMessages);
 * function gotMessages(messages) { … }
 * function didNotGetMessages() { … }
 */Application.prototype.readFile=function(path){var promise=new Promise();var request=new XMLHttpRequest();request.open('GET',path,true);request.onreadystatechange=function(e){if(request.readyState!==4)return;if(request.status!==200&&request.status!==0){promise.setFail();}else {promise.setDone(request.responseText);}};request.send(null);return promise;}; /**
 * Instructs the Spotify client to perform its default action on the given
 * URI. Depending on the URI resource kind (track, search, playlist etc.)
 * the client may or may not navigate to it. Depending on which platform
 * you're running on, this might behave differently (to conform with the
 * default behavior for the platform).
 *
 * @since 1.0.0
 *
 * @param {string} uri The Spotify URI to navigate to. The URI should be a
 *     well-formed and properly encoded spotify URI.
 * @param {string=} opt_context The history context of the operation. If the
 *     context of the last URI that was navigated to is the same as this
 *     context, the old entry will be removed from the history stack and
 *     replaced by the new URI. Most applications will not have a need to set
 *     the history context and should leave out this parameter.
 * @return {module:api/models~Promise} A promise that will be fulfilled if the
 *     client can navigate the given URI. If the URI is not valid or supported
 *     by the client, it will fail to resolve. It can also fail if the current
 *     application does not have permission to navigate to URIs.
 *
 * @see module:api/models~Application#openApp
 *
 * @example
 * models.application.openURI('spotify:artist:4F84IBURUo98rz4r61KF70');
 */Application.prototype.openURI=function(uri,opt_context){return promisedRequest(this,'application_open_uri',[uri,opt_context||null]);}; /**
 * Launches another Spotify application with, optional, arguments. The
 * application will launch in a view decided by the client and may end up
 * replacing the currently running application. How an application is launched
 * is specified in the manifest of that application.
 *
 * @since 1.0.0
 *
 * @param {string} app The bundle identifier of the application.
 * @param {...string} var_args Zero or more unencoded strings that will be sent
 *     as arguments to the application.
 * @return {module:api/models~Promise} A promise that will be fulfilled if the
 *     client can launch the specified application. If the application is not
 *     known by the client or if the current application does not have
 *     permission to launch applications, it will fail to resolve. Note that
 *     the current application might not be alive to receive the callback, if
 *     the application that is launched replaces the current application.
 *
 * @see module:api/models~Application#openURI
 *
 * @example
 * var uri = myArtist.uri;
 * models.application.openApp('radio', uri);
 */Application.prototype.openApp=function(app,var_args){var arg=SP.varargs(arguments,1);var uriSegments=['spotify','app',app];for(var i=0,l=arg.length;i<l;i++){uriSegments.push(encodeURIComponent(arg[i]));}return this.openURI(uriSegments.join(':'));}; /**
 * Sets the display title of the application. How this title is used, if used
 * at all, is dependent on the client.
 *
 * @since 1.0.0
 *
 * @param {string} title The display title for the application.
 * @param {string=} opt_subtitle An optional subtitle.
 * @return {module:api/models~Promise} A promise that will be fulfilled if the
 *     display title was successfully changed.
 *
 * @example
 * models.application.setTitle('My Application');
 */Application.prototype.setTitle=function(title,opt_subtitle){return promisedRequest(this,'application_set_title',[title,opt_subtitle||'']);}; /**
 * Resolves a resource path into a form suitable for including in an HTML tag.
 *
 * @since 1.27.0
 *
 * @param {string} path The path to resolve.
 * @return {string} The resolved path.
 *
 * @example
 * var path =  models.application.resolvePath("./images/profile.png");
 * var image = document.createElement('img');
 * image.setAttribute('src', path);
 * document.body.appendChild(image);
 */Application.prototype.resolvePath=function(path){return SP.resolvePath(path);}; /**
 * Logs an app specific event to the Spotify data warehouse. All parameters are
 * application dependent (i.e. you don't have to log your app's bundle version
 * nor name), letting you add new log messages on the fly without having to
 * update any logging framework(s).
 *
 * @since 1.0.0
 *
 * @param {string} context Any context you want to associate with the event
 *     (like "spotify:album:521in6R9kcIFL3cOrqFcH1").
 * @param {string} event The name of the event you're logging.
 * @param {string} eventVersion The version of the event you're logging.
 * @param {string} testVersion The A/B test version (if any) currently in use.
 * @param {Object} data Any data you want to assoicate with the event. Must be
 *     a JSON-serializable object.
 * @return {module:api/models~Promise} The promise for the logging event.
 *
 * @example
 * require(['./models#application'], function(app) {
 *   app.clientEvent('Top 10 list', 'click', '1', '', {itemNumber: 3});
 * });
 */Application.prototype.clientEvent=function(context,event,eventVersion,testVersion,data){return promisedRequest(this,'application_client_event',[].slice.call(arguments));}; /**
 * Never construct an artist object using the default constructor - use
 * fromURI() instead.
 *
 * @class
 * @extends {module:api/models~MdL}
 * @classdesc The artist object represents an artist in the Spotify catalog.
 * @since 1.0.0
 *
 * @property {module:api/models~Collection} albums The artist's own albums.
 * @property {string} biography The biography associated with the artist.
 * @property {module:api/models~Collection} genres The genres associated with
 *     the artist.
 * @property {string} image The image URI for the artist.
 *     The format of the image URI is platform dependent, but will always be
 *     something that can be used as the source of an img element or a
 *     background-image in CSS. The size of the image is not defined and might
 *     differ between platforms, so it is recommended that applications use the
 *     imageForSize method to get an appropriately sized image. In general,
 *     it's best to use the Image view from the views framework to display
 *     images - it will load the image in the background (while displaying a
 *     placeholder) and make sure to pick the correct size "intelligently",
 *     based on the current screen resolution and available bandwidth.
 * @property {string} name The name of the artist. This is a human readable
 *     string that can be presented to the user. Make sure to call the proper
 *     string decoding method before using the string in the DOM.
 * @property {number} popularity The popularity rating of the artist. This is a
 *     value between 0 and 100, inclusive, with 0 meaning a very low popularity
 *     and 100 a very high popularity.
 * @property {module:api/models~Collection} portraits Portraits (images) of the
 *     artist.
 * @property {string} uri The URI of the album.
 * @property {Object} years The years during which the artist was/is active.
 *     This value of the property has two fields: "from" and "to".
 * @property {module:api/models~User} user The user associated to the artist,
 *     if any exists. Otherwise null.
 *
 * @param {string} uri The URI of the artist.
 *
 * @see module:api/models~MdL#imageForSize
 * @see String#decodeForText
 * @see String#decodeForHtml
 * @see String#decodeForLink
 * @see module:api/models~Artist#fromURI
 */function Artist(uri){MdL.call(this);this.resolve('uri',uri);}SP.inherit(Artist,MdL);Loadable.define(Artist,['uri']);Loadable.define(Artist,['image','images', // Loaded when 'image' is loaded.
'name','popularity'],'_metadata');Loadable.define(Artist,['biography','genres','portraits','years'],'_profile');Loadable.define(Artist,['user'],'_associatedUser');MdL.init(Artist,'artist'); /**
 * @private
 */Artist.prototype._associatedUser=function(propsMask){var load=function load(data){this.resolveMany(propsMask,data);};var fail=function fail(oops){this.resolveFail(propsMask,oops);};SP.request('artist_associated_user',[this.uri],this,load,fail);}; /**
 * @private
 */Artist.prototype._make_user=function(value){return value&&User.fromURI(value);}; /**
 * Returns the artist for a given Spotify URI. The URI is the only property
 * that is loaded on the artist immediately.
 *
 * @since 1.0.0
 *
 * @param {string} uri The Spotify URI of the artist.
 * @return {module:api/models~Artist} The artist matching the given URI.
 *
 * @example
 * models.Artist.fromURI('spotify:artist:5bWRCM3vFGqamlNxSzNj1O').load('name').done(function(artist) {
 *   console.log(artist.uri + ': ' + artist.name.decodeForText());
 *   document.getElementById('artist').innerHTML = artist.name.decodeForHtml();
 * });
 */Artist.fromURI=Cache.lookup; /**
 * Gets a list of artists from a list of URIs.
 *
 * @since 1.3.0
 *
 * @param {Array.<string>} uris List of URIs.
 * @return {Array.<module:api/models~Artist>} A list of artists.
 */Artist.fromURIs=Cache.lookupMany; /**
 * @private
 */Artist._cache=new Cache(Artist); /**
 * An enum of the different allowed list descriptor types.
 *
 * @enum {string}
 */ListDescriptor.Types={LIST:'list',LISTS:'lists',SORT:'sort',FILTER:'filter',RANGE:'range',SHUFFLE:'shuffle'}; /**
 * Never construct a list descriptor using the default constructor - use create
 * or one of the "get*" methods instead.
 *
 * @class
 * @classdesc Describes the list contained in a collection, including the item
 *     list(s) it's built of and any modifiers (i.e. sorting/ranging/filtering).
 * @since TODO
 *
 * @property {module:api/models~ListDescriptor.Types} type The type of the
 *     descriptor.
 *
 * @param {module:api/models~ListDescriptor.Types} type The type of this list
 *     descriptor. Can be one of: lists, list, sort, filter, range, shuffle.
 * @param {Object=} opt_params Depending on the type this will hold different
 *     parameters. Available options are:
 *     - uri: a Spotify URI identifying the underlying source list.
 *     - lists: an array of list descriptors, used for context groups.
 *     - list: the list descriptor that a modifier is applied to.
 *     - version: for versioning of modifier arguments.
 *     - args: an array of string that hold the arguments to the modifiers.
 *
 * @example
 * var descriptor = new ListDescriptor(ListDescriptor.Types.LIST, {uri: uri});
 * descriptor = new ListDescriptor(ListDescriptor.Types.SORT, {
 *   list: descriptor,
 *   version: 1,
 *   args: ['name', 'asc']
 * });
 */function ListDescriptor(type,opt_params){this.type=type;for(var n in opt_params){this[n]=opt_params[n];}} /**
 * Compares two list descriptors to see if they are equal.
 *
 * @param {module:api/models~ListDescriptor} a The first list descriptor.
 * @param {module:api/models~ListDescriptor} b The second list descriptor.
 *
 * @return {boolean} Returns true if the list descriptors are equal, false
 *     otherwise.
 */ListDescriptor.compare=function(a,b){if(a.type!==b.type){return false;}switch(a.type){case ListDescriptor.Types.LIST:return a.uri===b.uri;case ListDescriptor.Types.LISTS:if(a.lists.length!==b.lists.length){return false;}for(var i=0;i<a.lists.length;i++){if(!ListDescriptor.compare(a.lists[i],b.lists[i])){return false;}}return true;case ListDescriptor.Types.FILTER:case ListDescriptor.Types.RANGE:case ListDescriptor.Types.SHUFFLE:case ListDescriptor.Types.SORT:if(a.version!==b.version){return false;}if(a.args.toString()!==b.args.toString()){return false;}return ListDescriptor.compare(a.list,b.list);default:return false;}}; /**
 * Create a basic list descriptor with a single Spotify URI and without
 * modifiers.
 *
 * @param {string} uri The uri that points to the list resource.
 * @return {module:api/models~ListDescriptor} The created list descriptor.
 */ListDescriptor.create=function(uri){return new ListDescriptor(ListDescriptor.Types.LIST,{uri:uri});}; /**
 * Create a concatenated list descriptor consisting of multiple lists.
 *
 * @param {Array.<module:api/models~ListDescriptor>} lists An array of list
 *     descriptors.
 * @return {module:api/models~ListDescriptor} The created list descriptor.
 */ListDescriptor.createConcatenated=function(lists){return new ListDescriptor(ListDescriptor.Types.LISTS,{lists:lists});}; /**
 * Get a filtered list descriptor for this descriptor.
 *
 * @param {string} operation How to compare when filtering.
 * @param {string} field The field to filter on.
 * @param {string} value The value to compare against when filtering.
 * @return {module:api/models~ListDescriptor} The new list descriptor.
 */ListDescriptor.prototype.filter=function(operation,field,value){return new ListDescriptor(ListDescriptor.Types.FILTER,{list:this,args:[operation,field,value],version:1});}; /**
 * Get a range list descriptor for this descriptor.
 *
 * @param {number} offset The offset to start the range from.
 * @param {number} length The length of the range.
 * @return {module:api/models~ListDescriptor} The new list descriptor.
 */ListDescriptor.prototype.range=function(offset,length){return new ListDescriptor(ListDescriptor.Types.RANGE,{list:this,args:[offset,length],version:1});}; /**
 * Get a shuffled list descriptor for this descriptor.
 *
 * @param {number=} opt_seed An optional seed used to give a deterministic
 *     shuffle.
 * @return {module:api/models~ListDescriptor} The new list descriptor.
 */ListDescriptor.prototype.shuffle=function(opt_seed){return new ListDescriptor(ListDescriptor.Types.SHUFFLE,{list:this,args:[opt_seed||Math.floor(Math.random()*200000000)],version:1});}; /**
 * Get a sorted list descriptor for this descriptor.
 *
 * @param {string} field The field to sort on.
 * @param {string=} opt_direction An optional sorting order, "asc" or "desc". Defaults to ascending.
 * @param {...Object} var_args repeated fields and directions for secondary, tertiary etc. sort order.
 * @return {module:api/models~ListDescriptor} The new list descriptor.
 */ListDescriptor.prototype.sort=function(field,opt_direction,var_args){if(arguments.length>2&&arguments.length%2!=0){throw new Error('Invalid number of parameters');}var args=arguments.length==1?[field,'asc']:Array.prototype.slice.call(arguments);return new ListDescriptor(ListDescriptor.Types.SORT,{list:this,args:args,version:1});}; /**
 * Returns the descriptor that represents the base for the list that this
 * descriptor is for.
 *
 * @return {module:api/models~ListDescriptor} A descriptor of type "list" or
 *     "lists".
 */ListDescriptor.prototype.getBase=function(){switch(this.type){case ListDescriptor.Types.LIST:case ListDescriptor.Types.LISTS:return this;case ListDescriptor.Types.FILTER:case ListDescriptor.Types.RANGE:case ListDescriptor.Types.SHUFFLE:case ListDescriptor.Types.SORT:return this.list?this.list.getBase():null;}return null;}; /**
 * @class
 * @extends {module:api/models~BridgeLoadable}
 * @classdesc A collection represents a list of items. Each item in a given
 *     collection is guaranteed to be of the same kind. The type of the item(s)
 *     depends on what the collection represents - it could be tracks in a
 *     playlist, albums in a toplist etc.
 * @since 1.0.0
 *
 * @property {module:api/models~ListDescriptor} descriptor The list descriptor
 *     that describes the list of items that this collection represents.
 * @property {Function} type The type of the items in the collection.
 * @property {string} uri The URI identifying the collection.
 *
 * @param {module:api/models~Loadable} itemClass A constructor for the items in
 *     the resulting snapshots. All items must be of this type.
 * @param {string} uri The URI that identifies the collection.
 * @param {Function} snapshot A function responsible for getting the items for
 *     snapshots. It should return a promise which resolves to an object with
 *     the properties "array", "length", and (optionally) "metadata".
 * @param {module:api/models~ListDescriptor=} opt_descriptor An optional
 *     descriptor with more info to describe the collection. If one is not
 *     specified, a new one will be created using the specified URI.
 * @param {Function=} opt_itemFactory A factory function responsible for
 *     creating the items in the collection out of the data returned by the
 *     snapshot request. The factory function will be called with two
 *     arguments: the basic data and the corresponding metadata. The metadata
 *     argument might not always be provided.
 *     <p>
 *     If a factory is not provided, the item type's static fromURI method will
 *     be used.
 */function Collection(itemClass,uri,snapshot,opt_descriptor,opt_itemFactory){BridgeLoadable.call(this);this.resolve('descriptor',opt_descriptor instanceof ListDescriptor?opt_descriptor:ListDescriptor.create(opt_descriptor||uri));this.resolve('type',itemClass);this.resolve('uri',uri);this._snapshot=snapshot;this._factory=opt_itemFactory||SP.bind(itemClass.fromURI,itemClass);}SP.inherit(Collection,BridgeLoadable);Loadable.define(Collection,['descriptor','type','uri']); /**
 * Clone this collection, and optionally change the descriptor. This should
 * rarely need to be called without a new descriptor to use, since collections
 * are stateless.
 *
 * @param {module:api/models~ListDescriptor=} opt_newDescriptor The new descriptor
 *     to use.
 */Collection.prototype.clone=function(opt_newDescriptor){return new Collection(this.type,this.uri,this._snapshot,opt_newDescriptor||this.descriptor,this._factory);}; /**
 * Makes a snapshot of the collection, optionally for a limited range. Making a
 * snapshot is the only way to examine the items in the collection, by freezing
 * it at a specific moment in time. The snapshot, once resolved, will never
 * change and can be kept around for as long as required. The start offset and
 * maximum length can, and should, be used to limit the size of the snapshot.
 * When making a snapshot of a playlist, only ask for the tracks that are
 * actually being displayed on screen at the moment, instead of asking for all
 * tracks in the playlist, which could be thousands of tracks. Even if the items
 * are not meant to be displayed it is a good idea to divide the colleciton into
 * chunks of reasonable size, to keep memory usage down and avoid blocking the
 * client. Ask for sequential snapshots of 500 items or so and ask for the next
 * snapshot while working on the first one.
 *
 * @since 1.0.0
 *
 * @param {number=} opt_start The offset of the first item to fetch in the
 *     snapshot. This is a hint to the API, and items before the offset could
 *     end up being fetched. It is however not allowed to read any items that
 *     were not specifically specified.
 * @param {number=} opt_length The maximum length of the range to snapshot.
 *     This is also a hint, and more items could end up being fetched. Note
 *     that the caller must not ask for items outside of the specified range.
 * @param {boolean=} opt_raw An optional parameter specifying if the snapshot
 *     should avoid pre-fetching metadata for the items in the snapshot. For
 *     most use cases this parameter should be left out or set to false. Only
 *     pass true if the only intended use for the snapshot is to get the URIs
 *     of the items.
 * @return {module:api/models~Promise} A promise.
 *
 * @example
 * playlist.tracks.snapshot(0, 50).done(function(snapshot) {
 *   var len = Math.min(snapshot.length, 50);
 *   for (var i = 0; i < len; i++) {
 *     doSomethingWithTrack(snapshot.get(i));
 *   }
 * });
 */Collection.prototype.snapshot=function(opt_start,opt_length,opt_raw){var snapshot=new Snapshot(this,opt_start,opt_length,opt_raw);return snapshot.load('length','range');}; /**
 * Adds one or more items to a collection. The item is added to the end of the
 * collection. Note that it is better to call this method with multiple items
 * than to call it multiple times with a single item, since the tracks are added
 * asynchronously and could end up in the wrong order otherwise. This can happen
 * when the second item to add is already cached by the client, while the first
 * item must be fetched remotely. In this situation the second item would be
 * added before the first. This can either be resolved by always waiting for the
 * item to be added before moving on to the next item, but this is less efficient
 * than simply passing in all items to be added right away.
 *
 * @since 1.0.0
 *
 * @param {Array.<Object>|...Object} items The items to add to the collection.
 *     Can either be a single item, many items or an array of items.
 * @return {module:api/models~Promise} A promise.
 *
 * @example
 * playlist1.tracks.add(models.Track.fromURI('spotify:track:2P2S1wxZYQYHRYDip79JiY'));
 * playlist2.tracks.add(track1, track2, …, trackN).done(addedManyTracks);
 */Collection.prototype.add=function(items){throw new Error('This method has not been implemented.');}; /**
 * Inserts one or more items into a collection. Note that it is better to call
 * this method with multiple items than to call it multiple times with a single
 * item, since the tracks are added asynchronously and could end up in the wrong
 * order otherwise. This can happen when the second item to insert is already
 * cached by the client, while the first item must be fetched remotely. In this
 * situation the second item would be inserted before the first. This can either
 * be resolved by always waiting for the item to be inserted before moving on to
 * the next item, but this is less efficient than simply passing in all items to
 * be inserted right away.
 *
 * @since 1.0.0
 *
 * @param {module:api/models~Reference} ref A reference to where the items
 *     should be inserted into the collection.
 * @param {Array.<Object>|...Object} items The items to insert into the
 *     collection. Can either be a single item, many items or an array of
 *     items.
 * @return {module:api/models~Promise} A promise.
 *
 * @example
 * playlist.tracks.snapshot(function(snapshot) {
 *   var index = …;
 *   playlist.tracks.insert(snapshot.ref(index), track1, track2, track3);
 * });
 */Collection.prototype.insert=function(ref,items){throw new Error('This method has not been implemented.');}; /**
 * Removes an item from the collection.
 *
 * @since 1.0.0
 *
 * @param {module:api/models~Reference} ref A reference to which item should be
 *     removed from the collection.
 * @return {module:api/models~Promise} A promise.
 */Collection.prototype.remove=function(ref){throw new Error('This method has not been implemented.');}; /**
 * Trims items from the end of the collection so that the last item in the
 * collection is the item referred to by the given reference. If the reference
 * is not in the collection, no items will be removed.
 *
 * @since 1.0.0
 *
 * @param {module:api/models~Reference} ref The last item in the collection to
 *     keep.
 * @return {module:api/models~Promise} A promise.
 */Collection.prototype.trim=function(ref){throw new Error('This method has not been implemented.');}; /**
 * Removes all items in the collection.
 *
 * @since 1.0.0
 *
 * @return {module:api/models~Promise} A promise.
 */Collection.prototype.clear=function(){throw new Error('This method has not been implemented.');}; /**
 * Returns a sorted version of the collection. The current collection
 * will not be affected.
 *
 * @since 1.0.0
 *
 * @param {string} field The field by which to sort by.
 *     As of now only collections of tracks are sortable and the fields that
 *     are allowed to sort on for those are:
 *     - album.name: the name of the album the track belongs to.
 *     - artists.name: the artist performing the track.
 *     - addTime: the timestamp when the track was added to a playlist.
 *     - creator: the person who added the track to a playlist.
 *     - disc: the disc number.
 *     - duration: the duration of the track.
 *     - name: the title of the track.
 *     - number: the number of the track on an album disc.
 *     - popularity: how popular the track is.
 *     - seen: if a track has been marked as seen or not.
 * @param {string=} opt_direction The sorting order, ascending or descending.
 *     Is given as "asc" or "desc". If the sording order is not
 *     specified, ascending order is used.
 * @param {...Object} var_args repeated fields and directions for secondary, tertiary etc. sort order.
 * @return {module:api/models~Collection} A sorted collection.
 *
 * @example
 * // Sort the playlist by duration of the tracks, longest first.
 * // The sorted collection can further be filtered if needed.
 * var sorted = playlist.tracks.sort('duration', 'asc');
 */Collection.prototype.sort=function(field,opt_direction,var_args){return this.clone(this.descriptor.sort.apply(this.descriptor,arguments));}; /**
 * Returns a filtered version of the collection. The current collection
 * will not be affected.
 *
 * @since 1.0.0
 *
 * @param {string} operation The operation to use when filtering.
 *     Available operations are "=", "<", "<=", ">=", ">", "!=",
 *     "startswith" and "contains".
 * @param {string} field The field to do the filtering on.
 *     As of now only collections of tracks are filterable and the fields that
 *     are allowed to filter on for those are:
 *     - album.name: the name of the album the track belongs to.
 *     - artists.name: the artist performing the track.
 *     - duration: the duration of the track.
 *     - name: the title of the track.
 *     - playable: whether the track is playable for the current user.
 *     - seen: if a track has been marked as seen or not.
 *     - text: free text filtering based on title, artist name and album name.
 * @param {string} value  The actual value to use when filtering.
 * @return {module:api/models~Collection} The filtered collection.
 *
 * @example
 * // Filter the playlist to only show playable tracks.
 * var filtered = playlist.tracks.filter('=' 'playable', 'true');
 * // Filter the playlist to only show tracks with an artist that starts with 'slayer'.
 * var filtered = playlist.tracks.filter('startswith', 'artist.name', 'slayer');
 * // Filter on the free text field. Note that 'contains' is the only allowed operation here.
 * var filtered = playlist.tracks.filter('contains', 'text', 'miles walkin');
 */Collection.prototype.filter=function(operation,field,value){return this.clone(this.descriptor.filter(operation,field,value));}; /**
 * Returns a ranged version of the collection. The current collection will not
 * be affected.
 *
 * @param {number} offset The offset where to start ranging.
 * @param {number} length The length of the range.
 * @return {module:api/models~Collection} The ranged collection.
 *
 * @example
 * // Create a range of the first twelve tracks of a playlist.
 * var ranged = playlist.tracks.range(0, 12);
 */Collection.prototype.range=function(offset,length){return this.clone(this.descriptor.range(offset,length));}; /**
 * Returns a shuffled version of the collection. The current collection will
 * not be affected.
 *
 * @param {number=} opt_seed An optional seed to create a stable shuffle.
 * @return {module:api/models~Collection} The shuffled collection.
 *
 * @example
 * // Shuffle the playlist.
 * var shuffled = playlist.tracks.shuffle();
 */Collection.prototype.shuffle=function(opt_seed){return this.clone(this.descriptor.shuffle(opt_seed));}; /**
 * Determines if a list of items is part of the collection or not.
 *
 * Note that not all collections implement this feature, as it can be an
 * extremely heavy, in some cases impossible, operation to perform.
 *
 * @function
 * @name Collection#contains
 * @since 1.22.0
 * @param {Array.<Object>|...Object} items The items to verify containment for.
 *     Can either be a single item, many items or an array of items.
 * @return {Promise} A promise that will result in the containment. If a single
 *     item was provided the result is just a Boolean. If multiple items were
 *     provided the result is an array where each index is a Boolean.
 *
 * @example
 * var track1 = models.Track.fromURI('spotify:track:2P2S1wxZYQYHRYDip79JiY');
 * library.tracks.contains(track1).done(function(contains) {
 *   console.log(contains ? 'Yes!' : 'No.');
 * });
 *
 * var track2 = models.Track.fromURI('spotify:track:1hKdDCpiI9mqz1jVHRKG0E');
 * library.tracks.contains([track1, track2]).done(function(contains) {
 *   console.log('Track 1:', contains[0], 'Track 2:', contains[1]);
 * });
 */Collection.prototype.contains=function(items){throw new Error('This method has not been implemented.');}; /**
 * @class
 * @extends {module:api/models~Collection}
 * @classdesc A special collection which will perform all its operations
 *     (snapshot, add, etc.) over the bridge.
 *
 * @property {module:api/models~ListDescriptor} descriptor The list descriptor
 *     that describes the list of items that this collection represents.
 * @property {Function} type The type of the items in the collection.
 * @property {string} uri The URI identifying the collection.
 *
 * @param {module:api/models~BridgeLoadable} itemClass A constructor for the
 *     items in the resulting snapshots. All items must be of this type.
 * @param {string} uri The URI that identifies the collection.
 * @param {string} requestPrefix The prefix to put before bridge requests such
 *     as "_snapshot", "_insert", and "_remove".
 * @param {module:api/models~ListDescriptor=} opt_descriptor An optional
 *     descriptor with more info to describe the collection. If one is not
 *     specified, a new one will be created using the specified URI.
 * @param {Function=} opt_itemFactory A factory function responsible for
 *     creating the items in the collection out of the data returned by the
 *     bridge. The factory function will be called with two arguments: the
 *     basic data and the corresponding metadata. The metadata argument might
 *     not always be provided.
 *     <p>
 *     If a factory is not provided, the item type's static fromURI method will
 *     be used.
 *
 * @private
 */function BridgeCollection(itemClass,uri,requestPrefix,opt_descriptor,opt_itemFactory){Collection.call(this,itemClass,uri,this._requestSnapshot,opt_descriptor,opt_itemFactory);this._prefix=requestPrefix;}SP.inherit(BridgeCollection,Collection); /**
 * Performs the bridge request for fetching a snapshot. Triggered by loading
 * the "length" or "range" properties on a snapshot instance.
 *
 * @param {module:api/models~ListDescriptor} descriptor A descriptor describing
 *     the list which is being snapshotted.
 * @param {number} offset Offset into the snapshot.
 * @param {number} length The length of the snapshot.
 * @param {boolean} raw Whether the data should be raw (no metadata).
 * @return {module:api/models~Promise} A promise.
 *
 * @private
 */BridgeCollection.prototype._requestSnapshot=function(descriptor,offset,length,raw){var promise=new Promise(); // XXX(fxb): This is a hack for making 'toplist_region_*' snapshots work,
//           that have the invalid 'spotify:top:<type>:country:USER' URI.
//           Remove this hack, when Toplist.forCurrentRegion is removed.
if(this._prefix.indexOf('toplist_region_')==0&&descriptor.uri.match(/:country:USER$/)!=null){var onCountryLoaded=function onCountryLoaded(session){descriptor.uri=descriptor.uri.replace(/:country:USER$/,':country:'+session.country);SP.request(this._prefix+'_snapshot',[descriptor,offset,length,raw],promise,promise.setDone,promise.setFail);};new Session().load('country').done(SP.bind(onCountryLoaded,this)).fail(promise.setFail);return promise;}SP.request(this._prefix+'_snapshot',[descriptor,offset,length,raw],promise,promise.setDone,promise.setFail);return promise;};BridgeCollection.prototype.add=function(items){var args=SP.uris(arguments);args.unshift(this.descriptor);return promisedRequest(this,this._prefix+'_append',args);};BridgeCollection.prototype.clear=function(){return promisedRequest(this,this._prefix+'_clear',[this.descriptor]);};BridgeCollection.prototype.clone=function(opt_newDescriptor){return new BridgeCollection(this.type,this.uri,this._prefix,opt_newDescriptor||this.descriptor,this._factory);};BridgeCollection.prototype.insert=function(ref,items){var args=[this.descriptor,ref.index,ref.uri];var uris=SP.uris(arguments,1);return promisedRequest(this,this._prefix+'_insert',args.concat(uris));};BridgeCollection.prototype.remove=function(ref){return promisedRequest(this,this._prefix+'_remove',[this.descriptor,ref.index,ref.uri]);};BridgeCollection.prototype.trim=function(ref){return promisedRequest(this,this._prefix+'_trim',[this.descriptor,ref.index,ref.uri]);};BridgeCollection.prototype.contains=function(items){var args=SP.uris(arguments);args.unshift(this.descriptor);var promise=new Promise();var done=function done(val){if(args.length==2&&!(items instanceof Array))promise.object=val.in_collection[0];else promise.object=val.in_collection;promise.setDone();};SP.request(this._prefix+'_contains',args,promise,done,promise.setFail);return promise;}; /**
 * Never construct a context object using the default constructor - use
 * fromURI() instead.
 *
 * @class
 * @extends {module:api/models~Loadable}
 * @classdesc An opaque context. The player will hold one of these contexts
 *     when a track is playing, rather than holding a reference to the high
 *     level context objects, such as Album or Playlist. This context can be
 *     compared to other contexts to check for equality and it can also be
 *     passed to the play methods of the player object.
 * @since 1.0.0
 *
 * @property {string} uri The URI of the context.
 *
 * @see module:api/models~Context#fromURI
 * @see module:api/models~Player#playContext
 */function Context(uri){Loadable.call(this);this.resolve('uri',uri);}SP.inherit(Context,Loadable);Loadable.define(Context,['uri']); /**
 * Get a string representation of the object.
 *
 * @return {string} A string representation of the object.
 */Context.prototype.toString=function(){return this.uri;}; /**
 * Returns an opaque context for a given Spotify URI. The URI is the only
 * property that is available on the context. It is loaded immediately.
 *
 * @since 1.0.0
 *
 * @param {string} uri The Spotify URI of the context.
 * @return {module:api/models~Context} The opaque context for the URI.
 *
 * @example
 * models.Artist.fromURI('spotify:artist:5bWRCM3vFGqamlNxSzNj1O').load('name').done(function(artist) {
 *   console.log(artist.uri + ': ' + artist.name.decodeForText());
 *   document.getElementById('artist').innerHTML = artist.name.decodeForHtml();
 * });
 */Context.fromURI=function(uri){return new Context(uri);}; /**
 * Never construct a context object using the default constructor - use
 * create() instead.
 *
 * @class
 * @extends {module:api/models~Loadable}
 * @classdesc A context group. The player takes a context group when calling
 *     the playContextGroup method.
 * @since 1.0.0
 *
 * @see module:api/models~Context#create
 * @see module:api/models~Player#playContextGroup
 */function Group(){Loadable.call(this);this.resolve('descriptor',ListDescriptor.createConcatenated([]));}SP.inherit(Group,Loadable);Loadable.define(Group,['descriptor']); /**
 * Add a context to a context group so they can be played together as one large context.
 *
 * @example
 *    var group = models.Group.create(id);
 *    group.add(models.Album.fromURI('spotify:album:5etQDl13KIndMaI2d9PZTy'));
 *    group.add(models.Playlist.fromURI("spotify:user:bobcat.dev:playlist:5aKLARNN2gWLog15rrlhel"));
 */Group.prototype.add=function(context){var descriptor=context.descriptor||ListDescriptor.create(context.uri);this.descriptor.lists.push(descriptor);}; /**
 * Creates a named context group.
 *
 * @since 1.0.0
 *
 * @return {module:api/models~Promise} A promise that will resolve into a Group
 *     once it has been created.
 */Group.create=function(){var group=new Group();var promise=new Promise();promise.setDone(group);return promise;}; /**
 * Never construct a playlist object using the default constructor - use
 * fromURI() instead.
 *
 * @class
 * @extends {module:api/models~MdL}
 * @classdesc The playlist object represents a playlist owned by a certain
 *     Spotify user.
 * @since 1.0.0
 *
 * @property {Object} allows A dictionary of the allowed operations on the
 *     playlist.
 * @property {boolean} collaborative Indicates if this is a collaborative
 *     playlist.
 * @property {string} name The name of the playlist. This is a human readable
 *     string that can be presented to the user. Make sure to call the proper
 *     string decoding method before using the string in the DOM.
 * @property {string} image The image URI for the playlist. The format of the
 *     image URI is platform dependent, but will always be something that can
 *     be used as the source of an img element or a background-image in CSS.
 *     The size of the image is not defined and might differ between platforms,
 *     so it is recommended that applications use the imageForSize method to
 *     get an appropriately sized image. In general, it's best to use the Image
 *     view from the views framework to display images - it will load the image
 *     in the background (while displaying a placeholder) and make sure to pick
 *     the correct size "intelligently", based on the current screen resolution
 *     and available bandwidth.
 * @property {module:api/models~User} owner The owner of a playlist. Depending
 *     on the privacy settings of the Spotify client, this may or may not be
 *     empty.
 * @property {boolean} published Indicates if the playlist belongs to the
 *     currently logged in user's list of public playlists.
 * @property {boolean} subscribed Indicates if the the currently logged in user
 *     is subscribed to this playlist.
 * @property {module:api/models~Collection} subscribers A collection of users
 *     that are currently subscribed to this playlist.
 * @property {module:api/models~Collection} tracks The tracks in this playlist.
 * @property {string} uri The URI of the playlist.
 *
 * @param {string} uri The URI of the playlist.
 *
 * @see module:api/models~MdL#imageForSize
 * @see String#decodeForText
 * @see String#decodeForHtml
 * @see String#decodeForLink
 * @see module:api/models~Playlist#fromURI
 */function Playlist(uri){MdL.call(this);this.resolve('uri',uri);}SP.inherit(Playlist,MdL); /**
 * @name module:api/models~Playlist#insert
 * @desc Fired when a track is inserted into the playlist.
 * @event
 *
 * @param {Object} event The event object. It has an array of the track URIs
 *     that have been inserted called "uris" and a property called "index"
 *     telling the position where the tracks were inserted.
 */ /**
 * @name module:api/models~Playlist#remove
 * @desc Fired when a track is removed into the playlist.
 * @event
 *
 * @param {Object} event The event object. It has two arrays, one containing
 *     the URIs of the tracks that have been removed called "uris", and another
 *     one containing the positions those tracks had in the playlist called
 *     "indices".
 */ /**
 * @name module:api/models~Playlist#change
 * @desc Fired when a property of the playlist changed.
 * @event
 *
 * @param {Object} event The event object.
 */ /**
 * @name module:api/models~Playlist#change:{property}
 * @desc {property} is one of the playlist's properties listed above. Fired
 *     when that specific property changes.
 * @event
 *
 * @param {Object} event The event object.
 */Loadable.define(Playlist,['uri']);Loadable.define(Playlist,['allows','collaborative','subscribed','name','owner','published'],'_metadata');Loadable.define(Playlist,['image','images' // Loaded when 'image' is loaded.
],'_profile');Loadable.define(Playlist,['subscribers','tracks'],'_collections');Loadable.define(Playlist,['popularity'],'_popularity');MdL.init(Playlist,'playlist'); /**
 * @private
 */Playlist.prototype._make_owner=function(value){return value&&User.fromURI(value.uri,value);}; /**
 * @private
 */Playlist.prototype._collections=function(){this.resolve('subscribers',new BridgeCollection(User,this.uri,'playlist_subscribers'));this.resolve('tracks',new BridgeCollection(Track,this.uri,'playlist_tracks'));this.resolveDone();}; /**
 * @private
 */Playlist.prototype._popularity=function(propsMask){var load=function load(data){this.resolveMany(propsMask,data);};var fail=function fail(oops){this.resolveFail(propsMask,oops);};SP.request('playlist_popularity',[this.uri],this,load,fail);}; /**
 * A bridge listener for library events. This is only a proxy so to actually
 * handle the events, another bridge listener needs to receive the events using
 * the proxyTo method.
 *
 * @type {module:api/models~ProxyListener}
 *
 * @private
 */Playlist._libraryListener=null; /**
 * Returns the playlist for a given Spotify URI. The URI is the only property
 * that is loaded on the playlist immediately.
 *
 * @since 1.0.0
 *
 * @param {string} uri the Spotify URI of the playlist.
 * @return {module:api/models~Playlist} A playlist.
 *
 * @example
 * models.Playlist.fromURI(playlistURI).load('name').done(function(playlist) {
 *   console.log(playlist.uri + ': ' + playlist.name.decodeForText());
 *   document.getElementById('playlist').innerHTML = playlist.name.decodeForHtml();
 * });
 */Playlist.fromURI=Cache.lookup; /**
 * Gets a list of playlists from a list of URIs.
 *
 * @since 1.3.0
 *
 * @param {Array.<string>} uris List of URIs.
 * @return {Array.<module:api/models~Playlist>} A list of playlists.
 */Playlist.fromURIs=Cache.lookupMany; /**
 * @private
 */Playlist._cache=new Cache(Playlist); /**
 * Creates a named playlist and adds it to the user's library.
 *
 * @since 1.0.0
 *
 * @param {string} name The name of the playlist. This is how the playlist will
 *     be presented to the user.
 * @return {module:api/models~Promise} A promise that will resolve into a
 *     Playlist once it has been created.
 */Playlist.create=function(name){var promise=new Promise();var done=function done(result){var playlist=new Playlist(result.uri);Playlist._cache.cache(result.uri,playlist);playlist.resolve('name',name);promise.setDone(playlist);};SP.request('playlist_create',[name],promise,done,promise.setFail);return promise;}; /**
 * Sets up (if needed) and returns a proxy listener for library events.
 *
 * @return {module:api/models~ProxyListener} A proxy listener for library
 *     events.
 */Playlist.getOrCreateLibraryListener=function(){var listener=Playlist._libraryListener;if(!listener){listener=new ProxyListener();listener.bridgeListen('library_event_wait',[exports.session.user.uri]); // Apply a filter to library events which will update cached Playlist
// instances.
listener.filter(function(evt){if(evt.type!='insert'&&evt.type!='remove')return;var newState=evt.type=='insert';switch(evt.receiver){case 'playlists':Playlist._cache.update(evt.uris,{subscribed:newState});break;case 'published':Playlist._cache.update(evt.uris,{published:newState});break;}});Playlist._libraryListener=listener;}return listener;}; /**
 * @override
 */Playlist.prototype.resolveMany=function(propsMask,data,opt_silent){Playlist._superClass.resolveMany.call(this,propsMask,data,opt_silent);};Playlist.prototype.load=function(){var args=SP.varargs(arguments);if(Array.prototype.indexOf.call(args,'subscribed')>=0){ // Start listening for library events if we ever load the subscribed
// property.
Playlist.getOrCreateLibraryListener();}return Playlist._superClass.load.apply(this,args);}; /**
 * Called when the first event listener is added to the playlist object. Make a
 * request for the next event for this playlist. If a request has already been
 * made for this playlist, another request will be made but it will fail
 * because only one event request at a time is allowed. This is ok since it
 * happens fairly rarely and will not cause any incorrect behavior.
 *
 * @private
 */Playlist.prototype._observed=function(){this.bridgeListen('playlist_event_wait',[this.uri]);}; /**
 * Override to stop listening on bridge events if there are no JS listeners
 * attached to this playlist.
 *
 * @override
 */Playlist.prototype.eventFail=function(error){if(!this._obcount)this.bridgeUnlisten();Playlist._superClass.eventFail.call(this,error);}; /**
 * Set the name of the playlist.
 *
 * @param {string} name The new name.
 * @return {module:api/models~Promise} A promise.
 */Playlist.prototype.setName=function(name){return promisedRequest(this,'playlist_set_name',[this.uri,name],true);}; /**
 * Don't use this constructor directly.
 *
 * @class
 * @extends {module:api/models~MdL}
 * @classdesc A profile consisting of artist and/or a user. It can be both an
 *     artist and a user if the artist has connected their page to a user
 *     profile.
 *
 * @since 1.20.0
 *
 * @property {string} uri A URI for the profile. This will be a user URI
 *     when the profile consists of a user; otherwise, an artist URI.
 * @property {module:api/models~Artist} artist An artist object. This field
 *     would be null if the profile is not an artist.
 * @property {module:api/models~User} user A user object. This field would be
 *     null if the artist has not merged their page with a user account.
 * @property {string} name The name of the user or artist. If a user profile
 *     name is available and is not equivalent to the username, it will be used;
 *     otherwise the artist name will be used (if the profile is of an artist).
 * @property {string} image An image for the relation. If a user profile
 *     image is available, it will be used; otherwise the artist image will
 *     be used (if the profile is of an artist).
 *
 * @param {string} uri A URI for the profile. This should be a user URI when a
 *     user profile is available; otherwise, an artist URI.
 *
 */function Profile(uri){MdL.call(this);this.resolve('uri',uri);}SP.inherit(Profile,MdL); /**
 * Gets a Profile object based on the provided artist or user URI.
 *
 * @since 1.20.0
 *
 * @param {string} artistOrUserURI An artist or user URI to find the
 *     appropriate Profile object for.
 * @return {module:api/models~Profile} A Profile object.
 */Profile.fromURI=Cache.lookup; /**
 * Gets a list of Profile objects based on the provided artist or user URIs.
 *
 * @since 1.21.0
 *
 * @param {Array.<string>} artistOrUserURIs A list of artist and/or user URIs
 *     to get the appropriate Profile objects for.
 * @return {Array.<module:api/models~Profile>} A list of Profile objects.
 */Profile.fromURIs=Cache.lookupMany;Profile._cache=new Cache(Profile);Loadable.define(Profile,['uri']);Loadable.define(Profile,['artist','user'],'_loadArtistOrUser');Loadable.define(Profile,['name','image','images'],'_metadata');Profile.prototype._make_artist=function(uri){return Artist.fromURI(uri);};Profile.prototype._make_user=function(uri){return User.fromURI(uri);};Profile.prototype._loadArtistOrUser=function(propsMask){var object=exports.fromURI(this.uri),promise;if(object instanceof Artist){promise=object.load('user').done(this,function(){var uri=object.user?object.user.uri:null;this.resolveMany(propsMask,{artist:object.uri,user:uri});});}else if(object instanceof User){promise=object.load('artist').done(this,function(){var uri=object.artist?object.artist.uri:null;this.resolveMany(propsMask,{artist:uri,user:object.uri});});}else {throw new Error('Invalid URI for Profile');}promise.fail(this,function(){this.resolveFail(propsMask,{message:'Failed to resolve artist/user objects'});});}; // This overrides the _metadata method of MdL.
Profile.prototype._metadata=function(propsMask){this.load('artist','user').done(this,function(){if(this.user){this.user.load('name','username','image','images').done(this,function(){var data={name:this.user.name,image:this.user.image,images:this.user.images}; // A name has been manually defined; not empty or simply the undecorated username
// An image has been uploaded for the user profile
var nameDefined=data.name&&data.name.toLowerCase()!==this.user.username,imageUploaded=data.image; // Load profile data unless it is an artist and a user name and/or image haven't been set
if(!this.artist||nameDefined&&imageUploaded)return this.resolveMany(propsMask,data); // Pull artist name and/or image to fill in missing data for the user profile
this.artist.load('name','image','images').done(this,function(artist){ // Fall back to artist name if the user lacks a valid name
if(!nameDefined)data.name=artist.name; // Fall back to artist image if the user lacks a valid image
if(!imageUploaded){data.image=artist.image;data.images=artist.images;}}).always(this,function(){this.resolveMany(propsMask,data);});}).fail(this,function(_,error){this.resolveFail(propsMask,error);});}else {this.artist.load('name','image','images').done(this,function(artist){this.resolveMany(propsMask,{name:artist.name,image:artist.image,images:artist.images});}).fail(this,function(_,error){this.resolveFail(propsMask,error);});}});}; /**
 * Waits for any playlist change event.
 *
 * @since 1.20.0
 *
 * @private
 */Playlist._playlistEventWait=function(){SP.request('playlist_event_wait_any',[],this,this._playlistEventDone,this._playlistEventFail);}; /**
 * @private
 */Playlist._playlistEventDone=function(event){var playlist=Playlist.fromURI(event.data.uri);playlist.resolveMany(0,event.data);playlist.dispatchEvent(event);this._playlistEventWait();}; /**
 * @private
 */Playlist._playlistEventFail=function(error){if(error.error=='timeout')this._playlistEventWait();}; /**
 * @class
 * @classdesc A reference to an item in a snapshot. To remove items from a
 *     collection, first find the item in the snapshot to get a reference to
 *     it, and then call the remove method on the collection, passing it the
 *     reference. If the collection has changed since creating the reference,
 *     the call will fail, and the caller must make a new snapshot and
 *     reference, and try the operation again. Do not directly create instances
 *     of this class. Instead use the find operation on the snapshot.
 * @since 1.0.0
 *
 * @see module:api/models~Collection#remove
 * @see module:api/models~Snapshot#find
 * @see module:api/models~Snapshot#ref
 *
 * @example
 * myTracks.snapshot().done(function(snapshot) {
 *   myTracks.remove(snapshot.find(track));
 * });
 */function Reference(index,uri){this.index=index;this.uri=uri;} /**
 * @class
 * @extends {module:api/models~BridgeLoadable}
 * @classdesc The session object exposes information about the current session.
 * @since 1.0.0
 *
 * @property {string} catalogue The currently logged in user's account catalogue.
 *     e.g. "free"/"daypass"/"premium"/"shuffle".
 * @property {boolean} connecting Set to true if the client is not online and
 *     is in the process of trying to connect to the Spotify servers.
 * @property {string} connection The current network connection type. One of
 *     "none", "gprs", "edge", "3g", "wlan", "ethernet" and "unknown". More
 *     types will be added in the future as more connectivity options become
 *     available. On some platforms this property may not be available, and
 *     will always be set to "unknown".
 * @property {string} country The country that the currently logged in user is
 *     registered in, as a two-letter ISO 3166-1 country code.
 * @property {boolean} developer Set to true if the currently logged in user's
 *     Spotify account has the "app-developer" attribute.
 * @property {string} device The device that the application is running on. One
 *     of "unknown", "mobile", "tablet" and "desktop". More device types could
 *     be added in the future.
 * @property {boolean} incognito Set if the currently logged in user has
 *     instructed the client to not broadcast any activity publically.
 * @property {string} language The language that the Spotify client is
 *     currently using, as a two-letter ISO 639-1 language code.
 * @property {boolean} online Indicates if the client has a connection to the
 *     Spotify servers or not. This can be false either be because the
 *     connection was lost, or because the client was manually put in offline
 *     mode.
 * @property {string} partner Set if the currently logged in user's account is
 *     currently being paid for through partner. If set, it holds the partner's
 *     identifier.
 * @property {string} product The currently logged in user's account product,
 *     e.g., "premium"/"daypass"/"free".
 * @property {number} resolution The resolution of the main screen of the
 *     device that the application is running on. The resolution is defined in
 *     CSS pixel units, meaning that a resolution of 2 would equal two device
 *     pixels per one CSS pixel. This is corresponds to running the application
 *     on a device with a High-DPI display, such as an iPhone 4 or iPad 3. On
 *     regular resolution displays, this value will be 1.
 * @property {string} streaming Set to disabled, if the user cannot stream
 *     music, enabled if the user can stream, or dmca-radio if streaming is
 *     restricted to DMCA radio.
 * @property {number} testGroup The AB test group that the user belongs to. Can
 *     be used to provide different functionality to different set of users to
 *     test new features and compare the behaviors and outcomes of each group.
 * @property {module:api/models~User} user A User instance representing the
 *     currently logged in user.
 */function Session(){BridgeLoadable.call(this);this.resolve('user',User.fromURI('spotify:user:@'));}SP.inherit(Session,BridgeLoadable); /**
 * @name module:api/models~Session#change
 * @desc Fired when a property of the session changed.
 * @event
 *
 * @param {Object} event The event object.
 */ /**
 * @name module:api/models~Session#change:{property}
 * @desc Where {property} is one of the session's properties listed above.
 *     Fired when that specific property changes.
 * @event
 *
 * @param {Object} event The event object.
 */Loadable.define(Session,['user']);Loadable.define(Session,['catalogue','connecting','connection','country','developer','device','incognito','language','online','partner','product','resolution','streaming','testGroup','capabilities'],'_query'); /**
 * @private
 */Session.prototype._observed=function(){this.bridgeListen('session_event_wait',[]);}; /**
 * @private
 */Session.prototype._query=function(propsMask){var load=function load(data){this.resolveMany(propsMask,data);};var fail=function fail(oops){this.resolveFail(propsMask,oops);};SP.request('session_query',[],this,load,fail);}; /**
 * Returns the test group for the currently logged in user for the given
 * test name.
 *
 * @since X.Y.
 *
 * @param {string} name The name of the test.
 * @return {module:api/models~Promise} The promise for the test group. If
 *     successful, the done callback will return the number of the test group.
 *
 * @example
 * require(['./models#session'], function(session) {
 *     session.testGroupForTest("NTX_NO_SIDEBAR")
 *         .done(function(group) {
 *             console.log("Test group: ", group);
 *         });
 });
 */Session.prototype.testGroupForTest=function(name){var promise=new Promise();SP.request('session_test_group',[name],promise,function(result){this.setDone(result.testGroup);},Promise.setFail);return promise;}; /**
 * @class
 * @extends {module:api/models~Loadable}
 * @classdesc A snapshot is a collection frozen in time. Collections can change
 *     their contents at any time, so to examine the items in the collection,
 *     take a snapshot of the the entire collection, or just the part of it
 *     that is interesting. Partial snapshots are preferred when possible,
 *     since they will fetch less data, saving memory and bandwidth. When the
 *     collection changes, the snapshot will remain the same, but it is a good
 *     time to take a new snapshot of the collection (if your app needs to use
 *     up-to-date data).
 *
 *     To make a snapshot, call the snapshot method on the collection. You
 *     should not directly instantiate a snapshot object.
 * @since 1.0.0
 *
 * @property {number} length The total length of the collection at the time the
 *     snapshot was taken. This number can be greater than the range (offset +
 *     length) that the snapshot was created using.
 * @property {{offset: number, length: number}} range The valid range for the
 *     snapshot, used at creation time. The value of the property has two
 *     fields: "offset" and "length".
 *
 * @param {module:api/models~Collection} collection The collection responsible
 *     for this snapshot.
 * @param {number=} opt_start The offset in the collection at which to start
 *     filling the snapshot with items.
 * @param {number=} opt_length The number of items to put in the snapshot.
 * @param {boolean=} opt_raw Whether the request should only fetch the most
 *     basic information rather than also fetch metadata for the items.
 *
 * @see module:api/models~Collection#snapshot
 *
 * @example
 * myAlbum.tracks.snapshot().done(function(snapshot) { … });
 * myArtist.albums.snapshot.done(artistLoaded).fail(artistNotLoaded);
 * myPlaylist.tracks.snapshot(0, 100).done(function(snapshot) { … });
 */function Snapshot(collection,opt_start,opt_length,opt_raw){Loadable.call(this);this._collection=collection;this._off=opt_start===undefined?0:opt_start;this._len=opt_length===undefined?-1:opt_length;this._raw=!!opt_raw;}SP.inherit(Snapshot,Loadable);Loadable.define(Snapshot,['length','range'],'_request'); /**
 * Requests the items for the snapshot using the collection's "_snapshot"
 * method.
 *
 * @private
 */Snapshot.prototype._request=function(){var col=this._collection;col._snapshot(col.descriptor,this._off,this._len,this._raw).done(this,function(result){this._uris=result.array;this._meta=result.metadata||[];this.resolve('length',result.length);this.resolve('range',{offset:this._off,length:this._uris.length});this.resolveDone();}).fail(this,function(error){var propsMask=this._neededForLoad(['length','range']);this.resolveFail(propsMask,error);});}; /**
 * Returns a singe item from the snapshot. If the index is outside the range of
 * the snapshot, null is returned. Since the snapshot is static, the returned
 * item will never be different when calling this method with the same index.
 *
 * @since 1.0.0
 *
 * @param {module:api/models~Reference|number} index The index of the item to
 *     get. Can be a reference returned by the find method.
 * @return {module:api/models~Loadable} The item in the collection.
 *
 * @example
 * myTracks.snapshot(0, 20).done(function(snapshot) {
 *   var track1 = snapshot.get(18); // Returns a Track
 *   var track2 = snapshot.get(23); // Returns null
 * });
 */Snapshot.prototype.get=function(index){if(index instanceof Reference)index=index.index;index-=this._off;if(index<0||index>this._uris.length)return null;return this._collection._factory(this._uris[index],this._meta[index]);}; /**
 * Searches for a given item in the snapshot part of the collection, and returns
 * a reference to the item if found or null if it was not found in the snapshot.
 * If null is returned it just means that item was not found in the snapshot. It
 * could still be somewhere in the collection. The reference is bound to the
 * snapshot's view of the collection, and can be used to remove items from the
 * collection or add new items in a particular location.
 *
 * @since 1.0.0
 *
 * @param {!module:api/models~Loadable} item A collection item, such as Track
 *     or Artist.
 * @param {module:api/models~Reference|number} first The first item to consider
 *     when searching. This parameter is optional. If left out, the search will
 *     start from first item in the snapshot.
 * @return {module:api/models~Reference} A reference object.
 *
 * @example
 * myTracks.snapshot().done(function(snapshot) {
 *   myTracks.remove(snapshot.find(track));
 * });
 */Snapshot.prototype.find=function(item,first){if(first instanceof Reference)first=first.index;var index=this._uris.indexOf(item.uri,first||0);return index==-1?null:new Reference(index+this._off,this._uris[index]);}; /**
 * This is a utility function to get instances of all the items in this
 * snapshot and then calling load on all the individual items and finally
 * joining all the resulting promises.
 *
 * @since 1.0.0
 *
 * @param {Array.<string>|...string} properties An array of property names. The
 *     property names that are available for loading can be found in the
 *     documentation for each specific sub-class. Note that instead of passing
 *     in an array, multiple arguments can be passed instead.
 * @return {module:api/models~Promise} A promise to wait for before the
 *     properties can be read.
 *
 * @example
 * var playlist = Playlist.fromURI(…);
 * playlist.load('tracks').done(function() {
 *   playlist.tracks.snapshot().done(function(snapshot) {
 *     snapshot.loadAll('name').each(function(track) {
 *       console.log(track.name);
 *     });
 *   });
 * });
 *
 * @see module:api/models~Loadable#load
 */Snapshot.prototype.loadAll=function(){var promises=[],items=this.toArray();for(var i=0,len=items.length;i<len;i++){var item=items[i];promises.push(item.load.apply(item,arguments));}return Promise.join(promises);}; /**
 * Makes a reference to an indexed item in the snapshot. The reference can be
 * used to insert to or remove items from the collection that the snapshot came
 * from. Note that the index must be part of the snapshot subset or one past the
 * the length of the collection, so that tracks can be inserted at the very end.
 *
 * @since 1.0.0
 *
 * @param {number} index The item index in the snapshot.
 * @return {module:api/models~Reference} A reference object.
 *
 * @example
 * myTracks.snapshot().done(function(snapshot) {
 *   myTracks.remove(snapshot.ref(0));
 * });
 */Snapshot.prototype.ref=function(index){var item=this.get(index);return new Reference(index,item?item.uri:null);}; /**
 * Creates an array with all of the items in the snapshot. Does not include the
 * empty slots in the snapshot, if any. Be sure that you actually have a need to
 * call this method before using it, since it will create instances of every item
 * in the snapshot, which are usually created lazily.
 *
 * @since 1.0.0
 *
 * @return {Array.<Object>} An array.
 *
 * @example
 * myTracks.snapshot().done(function(snapshot) {
 *   var tracks = snapshot.toArray();
 *   tracks.forEach(doSomethingWithTrack);
 * });
 */Snapshot.prototype.toArray=function(){var array=[],col=this._collection;for(var i=0,l=this._uris.length;i<l;i++){array[i]=col._factory(this._uris[i],this._meta[i]);}return array;}; /**
 * Creates an array with all URIs of the items in the snapshot. Does not include
 * the empty slots in the snapshot, if any. In general, applications should not
 * need to work with URIs directly, but for applications that have their own
 * database of Spotify URIs mapped to their own data it might be useful. If the
 * application does not actually need the metadata of the items in the snapshot
 * it is better to call this method than toArray, to avoid creating a large
 * number of objects that are not needed.
 *
 * @since 1.2.0
 *
 * @return {Array.<string>} An array of URIs.
 */Snapshot.prototype.toURIs=function(){return this._uris.slice();}; /**
 * Never construct a track object using the default constructor - use fromURI()
 * instead.
 *
 * @class
 * @extends {module:api/models~MdL}
 * @classdesc The track represents a track on an album in the Spotify catalog.
 * @since 1.0.0
 *
 * @property {module:api/models~Album} album The album of the track.
 * @property {Array.<module:api/models~Artist>} artists The artists of the
 *     track.
 * @property {string} availability Describes how and when the track is
 *     available for playback for the currently logged in user. The value will
 *     be one of: "available", "banned", "regional", "premium" or
 *     "unavailable". "available" means that the track can be played, "banned"
 *     that the artist has chosen to not make the track available, "regional"
 *     that the track is playable in other regions but not in the region of the
 *     currently logged in user, "premium" means that this is premium only
 *     content and a premium account is needed in order to play the track (the
 *     playable property needs to be checked to actually see if the user can
 *     play it or not), and "unavailable" which means the track is unavailable
 *     for other reasons.
 * @property {number} disc For multi-disc albums, indicates which disc the
 *     track is on. The first disc is disc 1.
 * @property {number} duration The duration of the track, in milliseconds.
 * @property {boolean} explicit True if the track should be displayed with a
 *     label indicating that it contains explicit lyrics. May not be set in all
 *     regions.
 * @property {string} image The image URI for the track. The format of the
 *     image URI is platform dependent, but will always be something that can
 *     be used as the source of an img element or a background-image in CSS.
 *     The size of the image is not defined and might differ between platforms,
 *     so it is recommended that applications use the imageForSize method to
 *     get an appropriately sized image. In general, it's best to use the Image
 *     view from the views framework to display images - it will load the image
 *     in the background (while displaying a placeholder) and make sure to pick
 *     the correct size "intelligently", based on the current screen resolution
 *     and available bandwidth.
 * @property {string} name The name of the playlist. This is a human readable
 *     string that can be presented to the user. Make sure to call the proper
 *     string decoding method before using the string in the DOM.
 * @property {number} number The number of the track on the album/disc it
 *     belongs to. The first track is track 1, the second track is track 2 and
 *     so on. The track number count is reset for each new disc on the album,
 *     and hence the first track on disc two on a two disc album is also known
 *     as track number 1 (and so on, for every new disc on the album).
 * @property {boolean} playable Indicates if the track is playable by the
 *     currently logged in user. If the resource used to construct the track
 *     isn't readily available for playback, Spotify will automatically try to
 *     find another (equivalent) playable copy of the track. This implies that
 *     if this property is set to false, neither this copy or any other copy of
 *     this track (in the Spotify catalog) is playable for the currently logged
 *     in user. A track can be unplayable for various reasons, such as regional
 *     restrictions or play count restrictions in the free service.
 * @property {number} popularity The popularity rating of the track. This is a
 *     value between 0 and 100, inclusive, with 0 meaning a very impopular
 *     track and 100 a highly popular track.
 * @property {string} uri The URI of the playlist.
 *
 * @param {string} uri The URI of the track.
 *
 * @see module:api/models~MdL#imageForSize
 * @see String#decodeForText
 * @see String#decodeForHtml
 * @see String#decodeForLink
 * @see module:api/models~Track#fromURI
 */function Track(uri){MdL.call(this);this.resolve('uri',uri);}SP.inherit(Track,MdL);Loadable.define(Track,['uri']);Loadable.define(Track,['ad_metadata','advertisement','album','artists','availability','disc','duration','explicit','image','images', // Loaded when 'image' is loaded.
'local','name','number','placeholder','playable','popularity'],'_metadata');MdL.init(Track,'track'); /**
 * @private
 */Track.prototype._make_album=function(value){return value&&Album.fromURI(value.uri,value);}; /**
 * @private
 */Track.prototype._make_artists=function(value){return value&&value.map(_artists);}; /**
 * Returns the track for a given Spotify URI. The URI is the only property that
 * is loaded on the track immediately.
 *
 * @since 1.0.0
 *
 * @param {string} uri The Spotify URI of the track.
 * @return {module:api/models~Track} A track.
 *
 * @example
 * models.Track.fromURI('spotify:track:2M5nPOo9UmoQVOWrN8lfN1').load('name').done(function(track) {
 *   console.log(track.uri + ': ' + track.name.decodeForText());
 *   document.getElementById('track').innerHTML = track.name.decodeForHtml();
 * });
 */Track.fromURI=Cache.lookup; /**
 * Gets a list of tracks from a list of URIs.
 *
 * @since 1.3.0
 *
 * @param {Array.<string>} uris List of URIs.
 * @return {Array.<module:api/models~Track>} A list of tracks.
 */Track.fromURIs=Cache.lookupMany; /**
 * @private
 */Track._cache=new Cache(Track); /**
 * Stars the current track for the currently logged-in user.
 *
 * @since 1.0.0
 *
 * @return {module:api/models~Promise} A promise.
 *
 * @deprecated Use {@link module:api/models~Library#star} instead.
 *
 * @example
 * models.Track.fromURI('spotify:track:2M5nPOo9UmoQVOWrN8lfN1').star();
 */Track.prototype.star=function(){return promisedRequest(this,'library_star',[exports.session.user.uri,this.uri]);}; /**
 * Unstars the current track for the currently logged-in user.
 *
 * @since 1.0.0
 *
 * @return {module:api/models~Promise} A promise.
 *
 * @deprecated Use {@link module:api/library~Library#unstar} instead.
 *
 * @example
 * models.Track.fromURI('spotify:track:2M5nPOo9UmoQVOWrN8lfN1').unstar();
 */Track.prototype.unstar=function(){return promisedRequest(this,'library_unstar',[exports.session.user.uri,this.uri]);}; /**
 * Waits for any track change event.
 *
 * @since 1.16.1
 *
 * @private
 */Track._trackEventWait=function(){SP.request('track_event_wait_any',[],this,this._trackEventDone,this._trackEventFail);}; /**
 * @private
 */Track._trackEventDone=function(event){var track=Track.fromURI(event.data.uri);track.resolveMany(0,event.data);track.dispatchEvent(event);this._trackEventWait();}; /**
 * @private
 */Track._trackEventFail=function(error){if(error.error=='timeout')this._trackEventWait();}; /**
 * @class
 * @extends {module:api/models~MdL}
 * @classdesc The user objects represents a unique Spotify user.
 * @since 1.0.0
 *
 * @property {boolean} currentUser A boolean field that indicates whether or
 *     not the user represented by the object is the current session's user.
 * @property {string} identifier An identifier for the user that is unique to
 *     the application. This can be used to identify the currently logged in
 *     user and will not change, but it will be different for each application,
 *     so it cannot be used to track the user between different applications.
 *     This property is only set on the currently logged in user.
 * @property {string} image The image URI for the user's portrait image. This
 *     property may or may not be available, depending on the application's
 *     permissions. The format of the image URI is platform dependent, but will
 *     always be something that can be used as the source of an img element or
 *     a background-image in CSS. The size of the image is not defined and
 *     might differ between platforms, so it is recommended that applications
 *     use the imageForSize method to get an appropriately sized image. In
 *     general, it's best to use the Image view from the views framework to
 *     display images - it will load the image in the background (while
 *     displaying a placeholder) and make sure to pick the correct size
 *     "intelligently", based on the current screen resolution and available
 *     bandwidth.
 * @property {string} name The name of the user. This is a human readable
 *     string that can be presented to the user. Make sure to call the proper
 *     string decoding method before using the string in the DOM.
 * @property {string} uri The URI of the user.
 * @property {string} username The canonical username of the user. This name
 *     should not be presented to the user. Call decodeForText to get a pure
 *     string without escape characters.
 * @property {module:api/models~Artist} artist The artist that the user is
 *     associated to, if any exists. Otherwise null.
 *
 * @param {string} uri The URI of the user.
 *
 * @see module:api/models~MdL#imageForSize
 * @see String#decodeForText
 * @see String#decodeForHtml
 * @see String#decodeForLink
 */function User(uri){MdL.call(this);this.resolve('uri',uri);}SP.inherit(User,MdL);Loadable.define(User,['uri']);Loadable.define(User,['currentUser','identifier','image','images', // Loaded when 'image' is loaded.
'name','subscribed','username'],'_metadata');Loadable.define(User,['artist'],'_associatedArtist');MdL.init(User,'user'); /**
 * @private
 */User.prototype._associatedArtist=function(propsMask){var load=function load(data){this.resolveMany(propsMask,data);};var fail=function fail(oops){this.resolveFail(propsMask,oops);};SP.request('user_associated_artist',[this.uri],this,load,fail);}; /**
 * @private
 */User.prototype._make_artist=function(value){return value&&Artist.fromURI(value);}; /**
 * A bridge listener for relations events. This is only a proxy so to actually
 * handle the events, another bridge listener needs to receive the events using
 * the proxyTo method.
 *
 * @type {module:api/models~ProxyListener}
 *
 * @private
 */User._relationsListener=null; /**
 * Returns the user for a given Spotify URI. The URI is the only property that
 * is loaded on the user immediately.
 *
 * @since 1.0.0
 *
 * @param {string} uri The Spotify URI of the user.
 * @return {module:api/models~User} A user.
 *
 * @example
 * var user = models.User.fromURI('spotify:user:…');
 * user.load('username', 'name').done(function(user) {
 *   console.log(user.username + ': ' + user.name.decodeForText());
 *   document.getElementById('user').innerHTML = user.name.decodeForHtml();
 * });
 */User.fromURI=Cache.lookup; /**
 * Gets a list of users from a list of URIs.
 *
 * @since 1.3.0
 *
 * @param {Array.<string>} uris List of URIs.
 * @return {Array.<module:api/models~User>} A list of users.
 */User.fromURIs=Cache.lookupMany; /**
 * @private
 */User._cache=new Cache(User); /**
 * Returns the user for a given Spotify username. The URI is the only property
 * that is loaded on the user immediately.
 *
 * @since 1.1.0
 *
 * @param {string} username The canonical username of the user.
 * @return {module:api/models~User} A user.
 *
 * @example
 * var user = models.User.fromUsername('**freer!de**');
 * user.load('username', 'name').done(function(user) {
 *   console.log(user.username + ': ' + user.name.decodeForText());
 *   document.getElementById('user').innerHTML = user.name.decodeForHtml();
 * });
 */User.fromUsername=function(username){ // fromURI only accepts characters escaped with lower case hexadecimal.
var escaped=encodeURIComponent(username),i=-1;while((i=escaped.indexOf('%',i+1))>-1){escaped=escaped.substring(0,i+1)+escaped.substring(i+1,i+3).toLowerCase()+escaped.substring(i+3);}return User.fromURI('spotify:user:'+escaped);}; /**
 * Sets up (if needed) and returns a proxy listener for relation events.
 *
 * @return {module:api/models~ProxyListener} A proxy listener for relation
 *     events.
 */User.getOrCreateRelationsListener=function(){var listener=User._relationsListener;if(!listener){listener=new ProxyListener();listener.bridgeListen('relations_event_wait',[exports.session.user.uri]); // Apply a filter to relations events which will update cached User
// instances.
listener.filter(function(evt){if(evt.receiver!='subscriptions'||evt.type!='add'&&evt.type!='remove')return;User._cache.update(evt.uris,{subscribed:evt.type=='add'});});User._relationsListener=listener;}return listener;}; /**
 * @override
 */User.prototype.load=function(){var args=SP.varargs(arguments);if(Array.prototype.indexOf.call(args,'subscribed')>=0){ // Start listening for relation events if we ever load the subscribed
// property.
User.getOrCreateRelationsListener();}return User._superClass.load.apply(this,args);}; /**
 * Generic function for getting an instance that best represents the passed in
 * URI.
 *
 * Only use this function if you don't know what the URI type is, or if the URI
 * can be one of several different types.
 *
 * This function will only return instances of Album, Artist, Disc, Playlist,
 * Track, User or Collection.
 *
 * @since 1.3.0
 *
 * @param {string} uri The URI to get an instance for.
 * @param {Object=} opt_data Optional data to resolve the instance with. Note
 *     that this should only be used if the data was provided together with the
 *     URI.
 * @return {module:api/models~Loadable} An instance representing the provided
 *     URI, or null if the URI could not be understood.
 */var fromURI=function fromURI(uri,opt_data){var parts=uri.split(':');var result=null;switch(parts[1]){case 'album': // spotify:album:<id>:<disc>
if(parts.length==4)result=Disc.fromURI(uri,opt_data);else if(parts.length==3)result=Album.fromURI(uri,opt_data);break;case 'artist':if(parts.length==3)result=Artist.fromURI(uri,opt_data);break;case 'track':if(parts.length==3)result=Track.fromURI(uri,opt_data);break;case 'local':if(parts.length===6)result=Track.fromURI(uri,opt_data);else if(parts.length===4)result=Album.fromURI(uri,opt_data);else if(parts.length===3)result=Artist.fromURI(uri,opt_data);break;case 'user': // spotify:user:<username>:collection
if(parts.length>3&&parts[3]=='collection')return new BridgeCollection(Track,uri,'library_tracks'); // spotify:user:<username>:<playlist:<id>|toplist>
if(parts.length>3&&parts.length<=5&&parts[2]!='facebook')result=Playlist.fromURI(uri,opt_data);else if(parts.length==3)result=User.fromURI(uri,opt_data);break;}return result;}; /*
 * Start waiting for any incoming global playlist and track change events. This
 * is different from the regular playlist events in that the API does not know
 * what playlist it will get updates for and cannot control it in any way. The
 * use case for these events is to update the properties of the playlists (such
 * as allows.offlineSync) and tracks (such as .playable) even when no one is
 * currently observing them.
 */Playlist._playlistEventWait();Track._trackEventWait(); /*
 * Export all of the classes and instances that are available to users of this
 * module. We could set the classes at the top of the file, but the instance
 * must be created here at the bottom because they need the prototypes of the
 * classes to be set up before creating an object.
 */exports.Observable=Observable;exports.Loadable=Loadable;exports.BridgeLoadable=BridgeLoadable;exports.MdL=MdL;exports.Album=Album;exports.Application=Application;exports.Artist=Artist;exports.Cache=Cache;exports.Client=Client;exports.Collection=Collection;exports.BridgeCollection=BridgeCollection;exports.Context=Context;exports.Disc=Disc;exports.Group=Group;exports.ListDescriptor=ListDescriptor;exports.Playlist=Playlist;exports.Profile=Profile;exports.Promise=Promise;exports.Session=Session;exports.Track=Track;exports.User=User;exports.application=new Application();exports.client=new Client();exports.fromURI=fromURI;exports.promisedRequest=promisedRequest;exports.session=new Session();

},{}],30:[function(require,module,exports){
'use strict';

var SpotifyApi = require('./core');

(function () {
  SpotifyApi.prototype._throwError = true;

  var bridge = window._getSpotifyModule('bridge');

  var core;
  /* In CEF3 the core module will be unavailable, thus producing an error. */
  try {
    core = window._getSpotifyModule('core');
  } catch (err) {}

  /**
   * Override the request creation routine with one that reads files using the
   * native C++ readFile() function, if available.
   */
  if (core) SpotifyApi.prototype._createRequest = function (module, callback) {
    // Run asynchronously to mirror the behaviour of other platforms
    this.defer(this, function () {
      var code = core.readFile(module);
      if (undefined === code) {
        throw new Error('Could not load module "' + module + '"; Not found.');
      } else {
        callback(code);
      }
    });
  };

  /**
   * Makes a request to a native function.
   */
  SpotifyApi.prototype.request = function (name, args, caller, success, failed) {
    var contextId = this._getContextIdForRequest();
    var message = JSON.stringify({ name: name, args: args, context: contextId });
    bridge.executeRequest(message, {
      onSuccess: function onSuccess(data) {
        if (success) {
          success.call(caller, JSON.parse(data));
        }
      },
      onFailure: function onFailure(data) {
        data = JSON.parse(data);
        if (failed) {
          failed.call(caller, data);
        }
      }
    });
    this._prepareFlush(name);
  };

  SpotifyApi.api = new SpotifyApi();
  SpotifyApi.api.container = 'desktop';
})();

},{"./core":31}],31:[function(require,module,exports){
'use strict';

/**
 * Core functionality of the Spotify API.
 *
 * @module api/core
 * @ignore
 */

/**
 * @namespace
 * @ignore
 */
var spotify = {};

/*
 * The Spotify API entry point. Only one instance of this class can exist.
 * Applications never directly use this class (expect for that it actually
 * implements the "require" functionality). Frameworks use this class to make
 * requests over the Stitch bridge. Each platform must make a subclass of this
 * class to implement the request communication.
 */

/**
 * This class should never be instantiated by the user; an instance will be
 * available to all imported module under the variable <code>SP</code>.
 *
 * @class
 * @classdesc This class deals with core Spotify API functionality.
 *     <p>
 *     An instance of this class is available in all imported modules under the
 *     variable <code>SP</code>.
 * @since 1.0.0
 * @ignore
 */
function SpotifyApi() {
  this._modules = {};
  this._requested = {};
  this._moduleQueue = [];
  this._delayedFns = [];
  this._parallelReqs = 4;
  this._contextStack = [];
  this._deferredFlush = false;
  this._useLoadingTimeout = false;
  this._patchRequestOpen();
}

module.exports = SpotifyApi;

/**
 * Never construct an AnalyticsContext using the constructor - use the
 * SP.analyticsContext() convenience function instead.
 *
 * @class
 * @classdesc An analytics context can be used to group activity inside of an
 *     application so it can be tracked as a single logical entity.  All API
 *     requests executed when a given context is active will be tagged with the
 *     context id so they can be assigned to the context on the other side of
 *     the bridge. AnalyticsContexts can handle asyncronous callbacks and may
 *     be nested arbitrarily deep.
 * @since 1.6.0
 * @ignore
 *
 * @param {string} name A human readable name for the context.
 *
 * @see module:api/core~SpotifyApi#analyticsContext
 */
SpotifyApi.AnalyticsContext = function (name) {
  this.name = name;
  this.id = SpotifyApi.AnalyticsContext._nextId++;
  this.references = 0;
  this._begin();
};
SpotifyApi.AnalyticsContext._nextId = 1;

/**
 * Add a reference to the context: indicates that there is an outstanding
 * promise that was created in the context.
 */
SpotifyApi.AnalyticsContext.prototype.addReference = function () {
  this.references++;
};

/**
 * Remove a reference to the context: indicates that a promise that was created
 * in the context has been fullfilled.
 */
SpotifyApi.AnalyticsContext.prototype.removeReference = function () {
  this.references--;
  if (this.references === 0) {
    this._end();
  }
};

/**
 * Called when a context is first created: sends a message over the bridge with
 * the context details.
 *
 * @private
 */
SpotifyApi.AnalyticsContext.prototype._begin = function () {
  SpotifyApi.api.request('core_context_begin', [this.id, this.name], this);
};

/**
 * Called when there are no more references to the context: sends a message
 * over the bridge with the context details.
 *
 * @private
 */
SpotifyApi.AnalyticsContext.prototype._end = function () {
  SpotifyApi.api.request('core_context_end', [this.id], this);
};

/**
 * Execute a function in an analytics context.
 *
 * @param {string} name A human readable name to identify the context.
 * @param {Function} func A function to invoke in the context.
 *
 * @example
 * SP.analyticsContext('load-playlist-view', function() {
 *   // do lots of complex loading and nested calls here
 * });
 */
SpotifyApi.prototype.analyticsContext = function (name, func) {
  var context = new SpotifyApi.AnalyticsContext(name);
  context.addReference();
  this._contextStack.push(context);
  try {
    func();
  } finally {
    this._contextStack.pop();
    context.removeReference();
  }
};

/**
 * Never construct a Callback using the constructor - use the SP.callback()
 * convenience function instead.
 *
 * @class
 * @classdesc A callback class that captures a context stack on instantiation
 *     and restores it on invocation.
 * @since 1.7.0
 * @ignore
 *
 * @param {Function} func The function to wrap.
 * @param {Array=} opt_contextStack A context stack to capture. If a stack is
 *     not provided, this defaults to the current context stack.
 *
 * @see module:api/core~SpotifyApi#callback
 * @see module:api/core~SpotifyApi#analyticsContext
 */
SpotifyApi.Callback = function (func, opt_contextStack) {
  this._func = func;
  this._setContextStack(opt_contextStack || SpotifyApi.api._contextStack);
};

/**
 * TODO: Documentation needed.
 *
 * @param {*} context The context to apply to the callback function.
 * @param {Array} args The arguments to apply to the callback function.
 */
SpotifyApi.Callback.prototype.apply = function (context, args) {
  try {
    var oldContextStack = SpotifyApi.api._contextStack;
    SpotifyApi.api._contextStack = this._contextStack;
    this._func.apply(context, args);
  } catch (error) {
    setTimeout(function () {
      throw error;
    }, 0);
  } finally {
    SpotifyApi.api._contextStack = oldContextStack;
    this.clear();
  }
};

/**
 * TODO: Documentation needed.
 *
 * @param {*} context The context to apply to the callback function.
 * @param {...*} var_args The arguments to apply to the callback function.
 */
SpotifyApi.Callback.prototype.call = function (context, var_args) {
  this.apply(context, Array.prototype.slice.call(arguments, 1));
};

/**
 * Creates a copy of the callback instance, incrementing the context stack
 * reference count.
 */
SpotifyApi.Callback.prototype.copy = function () {
  return new this.constructor(this._func, this._contextStack);
};

/**
 * Clear the callback, releasing the context stack: calling it after this will
 * cause an exception to be thrown.
 *
 * Note: If your callback will never be invoked, be sure to call clear to
 * ensure proper cleanup of the instance.
 */
SpotifyApi.Callback.prototype.clear = function () {
  this._releaseContextStack();
  delete this._func;
  delete this._contextStack;
};

/**
 * Set the context stack that should be restored when the callback is invoked.
 *
 * @private
 *
 * @see module:api/core~SpotifyApi.Callback#invoke
 */
SpotifyApi.Callback.prototype._setContextStack = function (contextStack) {
  for (var i = 0, l = contextStack.length; i < l; ++i) {
    contextStack[i].addReference();
  }
  this._contextStack = contextStack.slice(0);
};

/**
 * Remove our reference to each item in the stored context stack.
 *
 * @private
 */
SpotifyApi.Callback.prototype._releaseContextStack = function () {
  var contextStack = this._contextStack;
  for (var i = 0, l = contextStack.length; i < l; ++i) {
    contextStack[l - i - 1].removeReference();
  }
};

/**
 * Return a callback object that when invoked will restore the analytics
 * context stack that was active at the time the callback was created.
 *
 * @param {Function} func The function to wrap.
 * @return {module:api/core~SpotifyApi.Callback} A callback object.
 */
SpotifyApi.prototype.callback = function (func) {
  return new SpotifyApi.Callback(func);
};

/**
 * Return the analytics context id to send over the bridge for the next
 * request.
 *
 * @return {number} The context id.
 *
 * @private
 */
SpotifyApi.prototype._getContextIdForRequest = function () {
  var contexts = this._contextStack;
  return contexts.length ? contexts[contexts.length - 1].id : 0;
};

/**
 * Process the message that are posted to the window to handle the zero-delay
 * timeout system. When calling the delay function a message will be posted to
 * the window and processed in this event handler. It just goes through all
 * registered delayed invocations and calls them in order. Note that the array
 * must be copied first, because the callback could end up putting more stuff
 * on it, which must not run until the _next_ runloop iteration.
 */
window.addEventListener('message', function (event) {
  if (event.source == window && event.data == 'api-delay') {
    event.stopPropagation();
    var functions = SpotifyApi.api._delayedFns.splice(0);
    for (var i = 0, l = functions.length; i < l; i++) {
      functions[i].call();
    }
  }
});

/**
 * All subclasses' implementations of the request method must call this method.
 * It does not matter if it is called in the beginning or end of the request
 * method since the action is deferred until the beginning of the next runloop
 * iteration.
 *
 * @param {string} name The name of the request.
 *
 * @private
 */
SpotifyApi.prototype._prepareFlush = function (name) {
  if (!this._deferredFlush && name != 'core_flush') {
    this._deferredFlush = true;
    this.defer(this, this._flushRequests);
  }
};

/**
 * Sends the "bridge_flush" request across the bridge, indicating that now is
 * a good time to execute any batch jobs that have been building up because of
 * incoming requests. The implementation is free to execute requests right away
 * or wait until this flush request is sent.
 *
 * @private
 */
SpotifyApi.prototype._flushRequests = function () {
  this._deferredFlush = false;
  this.request('core_flush', []);
};

/**
 * Call this function to perform a function as soon as possible, but in the next
 * run loop iteration at the earliest. It is faster than calling setTimeout with
 * a zero timeout argument, since most browsers will artificially increase the
 * timeout to 15 milliseconds (plus/minus a few milliseconds).
 *
 * @param {Object} self The this instance to use in the callback.
 * @param {Function} func The function to call in the next runloop iteration.
 */
SpotifyApi.prototype.defer = function (self, func) {
  if (this._delayedFns.push(this.bind(this.callback(func), self)) == 1) window.postMessage('api-delay', '*');
};

/**
 * Used by require to evaluate the JavaScript module source code. Note that the
 * code in the module will be interpreted in strict JavaScript mode, to ensure
 * that it does not make some common coding mistakes, and it also enables some
 * additional optimizations by the compiler.
 *
 * @param {Object} meta The module's meta object.
 * @param {Array} graph An array containing the object's dependency graph.
 * @param {string} module The module path.
 * @param {string} code The source code of the module.
 * @return {Object} The exported namespace of the module.
 *
 * @private
 */
SpotifyApi.prototype._evalModule = function (meta, graph, module, code) {
  return !/\.lang$/.test(module) ? this._evalJSModule(meta, graph, module, code) : this._evalLangModule(module, code);
};

SpotifyApi.prototype._evalJSModule = function (meta, graph, module, code) {
  var self = this;
  var exports = { __name: module };
  var require = function require(modules, fn) {
    exports.__waiting = true; // require was called inside the module
    var callback = function callback() {
      exports.__waiting = false;
      return fn.apply(this, arguments);
    };
    callback.__native = true;
    return self._require(module, meta, graph, modules, callback);
  };
  try {
    code = '\'use strict\';' + code + '\n//@ sourceURL=' + module;
    new Function('require', 'exports', 'SP', '_code', 'eval(_code)').call({}, require, exports, this, code);
    return exports;
  } catch (error) {
    error.message += ' in ' + module;
    throw error;
  }
};

/**
 * A module containing localized strings.
 * <p>
 * To use string modules, make sure that you have a "SupportedLanguages" key in
 * your manifest, the value of which should be an array of strings
 * corresponding to the languages you support:
 *
 * <pre>
 * {
 *   …
 *   "SupportedLanguages": ["de", "en", "es"],
 *   …
 * }
 * </pre>
 *
 * Second, create locale-directories for each of the languages you support in
 * the root of your application. Inside each of these directories should be
 * another directory called "strings," which will contain the language string
 * files:
 *
 * <pre>
 * $ tree ~/Spotify/my-app
 * ~/Spotify/my-app/
 * ├── de.loc
 * │   └── strings
 * ├── en.loc
 * │   └── strings
 * ├── es.loc
 * │   └── strings
 * ├── index.html
 * ├── manifest.json
 * └── scripts
 *     └── main.js
 *
 * 7 directories, 3 files
 * </pre>
 *
 * You're then ready to add your strings via .lang files. A Lang file is a JSON
 * document containing key-value pairs of identifiers and their corresponding
 * locale strings. Here's an example .lang file:
 *
 * <pre>
 * $ < ~/Spotify/my-app/en.loc/strings/main.lang
 * {
 *   "greeting": "Hello and Welcome!",
 *   "personal-greeting": "Hello {0}, and Welcome!"
 * }
 * </pre>
 *
 * The lang file above is for the en locale, and we'll need corresponding ones
 * for other supported locales as well. Your final directory structure should
 * look similar to this:
 *
 * <pre>
 * $ tree ~/Spotify/my-app
 * ~/Spotify/my-app/
 * ├── de.loc
 * │   └── strings
 * │       └── main.lang
 * ├── en.loc
 * │   └── strings
 * │       └── main.lang
 * ├── es.loc
 * │   └── strings
 * │       └── main.lang
 * ├── index.html
 * ├── manifest.json
 * └── scripts
 *     └── main.js
 *
 * 7 directories, 6 files
 * </pre>
 *
 * Now that you have your files set up, you can then add locale support to your
 * apps. As mentioned above, lang files are imported using the same require()
 * function that we use for importing modules. To import a locale, you simply
 * import strings/<name of the file>.lang:
 *
 * <pre>
 * require('strings/main.lang', function(mainStrings) {
 *   …
 * });
 * </pre>
 *
 * It is important to notice that we did not specify the locale folder to use
 * when requiring the file. This is because the client will automatically
 * resolve the path to the proper string file for the locale. If the above
 * snippet is run in a client using en, then it will import
 * en.loc/strings/main.lang, and the same for other supported languages.
 * <p>
 * NB! As of the moment, only two-character language codes work. However, this
 * is a limitation of the hosting client, not the locale implementation.
 * Support for extended language codes will automatically appear once the
 * hosting clients support them.
 * <p>
 * When your locale strings have been imported, require() will then invoke your
 * callback with an object of the following interface:
 *
 * <pre>
 * interface StringsGetter : Object {
 *   string get(string key [, interface {} interpolatedValue1 … interpolatedValueN]);
 * }
 * </pre>
 *
 * You can then use this object to get the strings from your file, as well as
 * do simple string interpolation (see the example section).
 *
 * @class
 *
 * @property {Object.<string, string>} A map of string ids to translated
 *     strings.
 *
 * @example
 * require('strings/main.lang', function(mainStrings) {
 *   // Returns 'Hello and Welcome!'
 *   mainStrings.get('greeting');
 *
 *   // Returns 'Hello Mark, and Welcome!'
 *   mainStrings.get('personal-greeting', 'Mark');
 *
 *   // Non-existent key, returns 'non-existent'
 *   mainStrings.get('non-existent');
 *
 *   // Non-existent key, returns 'non-existent but still interpolated'
 *   mainStrings.get('non-existent but still {0}', 'interpolated');
 * });
 */
SpotifyApi.LangModule = function (name, strings) {
  this.__name = name;
  this.strings = strings;
};

/**
 * Gets a string from the language module. This function supports substitution
 * of parameters ("{0}" will be replaced with the first additional argument to
 * this method).
 *
 * @param {string} key The key to use when looking up the string. If the string
 *     does not exist, the key will be used as the string instead.
 * @param {...*} var_args Substitution values to use for the string.
 * @return {string} The localized, formatted string.
 */
SpotifyApi.LangModule.prototype.get = function (key, var_args) {
  var format = this.strings.hasOwnProperty(key) ? this.strings[key] : key;

  // Scan the format string for placeholders ("{0}", etc.) and substitute them
  // with the provided arguments.
  var out = '',
      lastIndex = 0,
      startIndex,
      endIndex;
  while ((startIndex = format.indexOf('{', lastIndex)) > -1) {
    endIndex = format.indexOf('}', startIndex + 1);
    // Stop parsing if we can't find a closing curly brace.
    if (endIndex == -1) {
      break;
    }

    // Get the substitution value from the arguments.
    var value = arguments[parseInt(format.substring(startIndex + 1, endIndex)) + 1];
    if (value !== undefined) {
      out += format.substring(lastIndex, startIndex) + value;
    } else {
      // Just leave the placeholder untouched if there is no value.
      out += format.substring(lastIndex, endIndex + 1);
    }

    lastIndex = endIndex + 1;
  }

  return lastIndex ? out + format.substring(lastIndex) : format;
};

/**
 * Evaluates a language module, which is basically just a JSON file. The module
 * that is returned will also have a "get" function which lets people load a
 * localized string with formatting.
 *
 * @param {string} module Name of the module.
 * @param {string} code The JSON data of the module.
 * @return {Object} The exported members of the module.
 *
 * @private
 */
SpotifyApi.prototype._evalLangModule = function (module, code) {
  try {
    return new SpotifyApi.LangModule(module, JSON.parse(code));
  } catch (error) {
    throw new Error('Cannot import language file "' + module + '": ' + error.message);
  }
};

/**
 * Fires a require callback after all of dependencies have finished loading.
 *
 * @param {Object} meta The metadata node to start at.
 *
 * @private
 */
SpotifyApi.prototype._fireCallbacks = function (meta) {
  while (meta) {
    meta.waiting--;
    if (meta.waiting) break;
    meta.unpacked.forEach(function (unpacked) {
      var pos = unpacked.position;
      var exported = meta.args[pos];
      var property = unpacked.property;
      if (!(property in exported)) throw new Error('No "' + property + '" exported in module "' + exported.__name + '"');
      meta.args[pos] = exported[property];
    });
    meta.callback.apply({}, meta.args);
    meta.waiting = 1 / 0; // Infinity
    meta = meta.parent;
  }
};

/**
 * Asynchronously loads a file at a given path. Basically just a
 * handy wrapper around XMLHttpRequest. Will throw an error if
 * the path is not found, or if the request times out.
 *
 * @param  {String}   path     The path to the file.
 * @param  {Function} callback A callback function that handles
 *                             one argument - the body of the file.
 *
 * @private
 *
 */
SpotifyApi.prototype._createRequest = function (path, callback) {
  var request, timeoutMS, xmlHttpTimeout, timedOut;

  request = new XMLHttpRequest();
  request.open('GET', path, true);

  request.onreadystatechange = function () {
    var isDone, iOSHack, isOK;
    isDone = request.readyState === 4;

    if (isDone) {
      clearTimeout(xmlHttpTimeout);

      if (timedOut) {
        throw new Error('Could not load file "' + path + '"; Timed out.');
      }

      // FIXME: Originally the 0 status code for success was for our
      // implementation of Stitch on iOS 4. This is probably not needed
      // anymore, but please test on both iOS 5 and iOS 6 before removing.
      iOSHack = request.status === 0 && !!request.responseText;
      isOK = request.status === 200 || iOSHack;

      if (!isOK) {
        throw new Error('Could not load file "' + path + '"; Not found.');
      }

      callback(request.responseText);
    }
  };

  if (this._useLoadingTimeout) {
    timeoutMS = 1500;
    xmlHttpTimeout = setTimeout(function () {
      timedOut = true;
      request.abort();
    }, timeoutMS);
  }

  request.send(null);
};

/**
 * Loads the executable code of a module via XHR or from the cache.
 *
 * @private
 */
SpotifyApi.prototype._loadModule = function (meta, graph, module, position, property) {
  var self = this;

  var cached = this._modules[module];
  if (cached && !cached.__waiting) {
    meta.args[position] = this._modules[module];
    if (property) meta.unpacked.push({ property: property, position: position });
    this._fireCallbacks(meta);
  } else if (this._requested[module] || !this._parallelReqs) {
    this.defer(this, function () {
      this._loadModule(meta, graph, module, position, property);
    });
  } else {
    this._requested[module] = true;
    this._parallelReqs--;
    this._createRequest(module, function (responseText) {
      self._parallelReqs++;
      var exported = self._modules[module] = self._evalModule(meta, graph, module, responseText);
      meta.args[position] = exported;
      if (property) meta.unpacked.push({ property: property, position: position });
      self._fireCallbacks(meta);
    });
  }
};

/**
 * Resolves any path-related "magic" for a module's require path.
 *
 * @private
 */
SpotifyApi.prototype._resolveModule = function (module) {
  if (!/\.lang$/.test(module)) {
    var _module = module.match(/^(\$(?:[^\/]+)\/)(?!scripts)(.*)/);
    if (_module) module = _module[1] + 'scripts/' + _module[2];
    module += '.js';
  }
  return module;
};

/**
 * Import a module of the Spotify API by specifying the module path as:
 * $framework/module, e.g., $api/models. Store the returned object in a
 * variable of your own choice. The object represents the namespace of the
 * module. You can also use this method to import your own modules, included in
 * the bundle, by passing a relative module path.
 *
 * @param {string} name The module name.
 * @param {Object} parent The meta object of the modules' parent.
 * @param {Array.<string>} graph The dependency graph of the modules.
 * @param {string|Array.<string>} modules The paths of the modules to require.
 * @param {Function} fn The callback function to call when the modules have
 *     been loaded.
 * @return {Object} The module namespace.
 *
 * @private
 */
SpotifyApi.prototype._require = function (name, parent, graph, modules, fn) {
  if (typeof modules == 'string') modules = [modules];
  if (!modules || !modules.length) throw new Error('Missing modules argument to require().');
  if (!fn || typeof fn != 'function') throw new Error('Missing callback function argument to require().');

  var len = modules.length;

  var meta = {
    name: name,
    parent: parent,
    waiting: len,
    callback: fn,
    args: new Array(len),
    unpacked: []
  };

  parent.waiting++;

  for (var i = 0, l = len; i < l; i++) {
    var module = modules[i];
    if (!module) throw new Error('Empty module name in require.');

    // Property unpacking.
    var property = module.split('#');
    module = this._resolveModule(property[0]);
    property = property[1];

    // Dependency checking.
    var modGraph = graph.slice(0);
    var index = graph.indexOf(module);
    modGraph.push(module);
    if (index != -1) {
      modGraph = modGraph.slice(index).join(' -> ');
      throw new Error('Circular Dependency on Module "' + module + '": ' + modGraph);
    }

    this._loadModule(meta, modGraph, module, i, property);
  }
};

/**
 * This function will take an array of parameters (usually from the 'arguments'
 * keyword), and expect it to contain a single array of values, or a variable-
 * length list of values, starting at the specified offset (default 0). This is
 * used to implement methods such as Loadable.load and Promise.join.
 *
 * @since 1.1.0
 *
 * @param {Arguments|Array} values An arguments object or an array to get the
 *     list of values from.
 * @param {number=} opt_offset An offset to start expecting variable arguments
 *     at. For example, if a function always takes one argument plus a list of
 *     values (which can either be a single array or many arguments), you would
 *     pass in an offset of 1. Default is 0.
 * @param {boolean=} opt_copy Force this function to return a copy of the list
 *     so that the return value is safe to retain and/or change.
 * @return {Arguments|Array} Either the arguments object or an array. Unless a
 *     copy of the value list is explicitly requested, the existing list will
 *     be returned when possible (for performance reasons), so do not attempt
 *     to modify the returned value in any way unless asking for it to be
 *     copied.
 *
 * @example
 * function printList(title) {
 *   // Get the items with an offset of 1 (ignoring title).
 *   var items = SP.varargs(arguments, 1);
 *
 *   var html = '&lt;h1&gt;' + title + '&lt;/h1&gt;&lt;ul&gt;';
 *   for (var i = 0; i < items.length; i++) {
 *     html += '&lt;li&gt;' + items[i] + '&lt;/li&gt;';
 *   }
 *   document.write(html + '&lt;/ul&gt;');
 * }
 *
 * // This will work...
 * printList('Numbers', ['one', 'two', 'three']);
 *
 * // ...and so will this.
 * printList('Numbers', 'four', 'five', 'six');
 */
SpotifyApi.prototype.varargs = function (values, opt_offset, opt_copy) {
  if (!opt_offset) opt_offset = 0;

  if (Array.isArray(values[opt_offset])) {
    if (values.length > opt_offset + 1) throw new Error('Ambiguous use of varargs');
    values = values[opt_offset];
    opt_offset = 0;
  }

  return opt_offset || opt_copy ? Array.prototype.slice.call(values, opt_offset) : values;
};

/**
 * Gets a list of URIs from the provided arguments object or array.
 *
 * @since 1.1.0
 *
 * @param {Arguments|Array} values An arguments object or an array to get the
 *     list of URIs from. It is expected to hold objects with a "uri" property.
 * @param {number=} opt_offset An offset to start expecting variable arguments
 *     at. For example, if a function always takes one argument plus a list of
 *     values (which can either be a single array or many arguments), you would
 *     pass in an offset of 1. Default is 0.
 * @return {Array.<string>} A list containing the URIs of the provided objects.
 *
 * @see module:api/core~SpotifyApi#varargs
 */
SpotifyApi.prototype.uris = function (values, opt_offset) {
  var objs = this.varargs(values, opt_offset),
      uris = [];
  for (var i = 0, len = objs.length; i < len; i++) {
    uris.push(objs[i].uri);
  }
  return uris;
};

/**
 * Binds a function to a specific this object. This is a simpler version of the
 * bind method of the Function class, which is not available on all platforms.
 *
 * @since 1.4.0
 *
 * @param {Function} func A function to bind.
 * @param {Object} that The this object to use when invoking the returned
 *     function.
 * @param {...*} var_args Additional arguments to pass into the function before
 *     any arguments passed to the new, bound version of the function.
 * @return {Function} A new function that will invoke the given function.
 */
SpotifyApi.prototype.bind = function (func, that, var_args) {
  if (arguments.length > 2) {
    var slice = Array.prototype.slice;
    var bind = Function.prototype.bind;
    if (bind && func.bind === bind) return bind.apply(func, slice.call(arguments, 1));
    var args = slice.call(arguments, 2);
    return function () {
      return func.apply(that, arguments.length ? args.concat(slice.call(arguments)) : args);
    };
  } else {
    return function () {
      return func.apply(that, arguments);
    };
  }
};

/**
 * Inherit the prototype methods from one constructor into another.
 *
 * @param {Function} childConstructor Child class.
 * @param {Function} parentConstructor Parent class.
 *
 * @example
 * function ParentClass(a, b) { }
 * ParentClass.prototype.foo = function(a) { }
 *
 * function ChildClass(a, b, c) {
 *   ParentClass.call(this, a, b);
 * }
 * SP.inherit(ChildClass, ParentClass);
 *
 * var child = new ChildClass('a', 'b', 'see');
 * child.foo(); // works
 *
 * // In addition, a superclass' implementation of a method can be invoked as
 * // as follows:
 *
 * ChildClass.prototype.foo = function(a) {
 *   ChildClass._superClass.foo.call(this, a);
 *   // other code
 * };
 */
SpotifyApi.prototype.inherit = function (childConstructor, parentConstructor) {
  var TempConstructor = function TempConstructor() {};

  TempConstructor.prototype = childConstructor._superClass = parentConstructor.prototype;
  childConstructor.prototype = new TempConstructor();
  childConstructor.prototype.constructor = childConstructor;
  return childConstructor;
};

/**
 * Patches XMLHttpRequest.prototype.open to add a custom Spotify header.
 * Only applies to same-domain requests.
 * <p>
 * This allows us to mark requests sent from applications, to avoid
 * injecting our tags into files that aren't the source of the webpage.
 *
 * @private
 */
SpotifyApi.prototype._patchRequestOpen = function () {
  var open = XMLHttpRequest.prototype.open;

  /*
   * When a <base> element is present in the head, the browser will
   * interpret local urls as they were joined to the base href.
   * A link element allows us to avoid checking for the base element
   * specifically, as the href property of a link is always the result
   * of the browser interpretation of that link.
   * A link also allows us to use the handy protocol and hostname properties
   * without having to use a regexp to match them.
   */
  var link = document.createElement('a');
  var location = window.location;

  XMLHttpRequest.prototype.open = function (method, url) {
    var result = open.apply(this, arguments);
    link.href = url;

    /**
     * In internet explorer 9, an <a> element might have the protocol property set to ":" and an empty hostname property
     * which means those properties are the same as the document base url, therefore we treat them as local
     */
    if (link.protocol == ':' && !link.hostname || link.protocol == location.protocol && link.hostname == location.hostname) {
      this.setRequestHeader('X-Spotify-Requested-With', 'XMLHttpRequest');
    }
    return result;
  };
};

/**
 * Resolve a path to something that can be included with an HTML tag
 */
SpotifyApi.prototype.resolvePath = function (path) {
  return path;
};

/**
 * Import a module of the Spotify API by specifying the module path as:
 * $framework/module, e.g., $api/models. Store the returned object in a variable
 * of your own choice. The object represents the namespace of the module. You
 * can also use this method to import your own modules, included in the bundle,
 * by passing a relative module path. Note that the code in the module will be
 * interpreted in strict JavaScript mode, to ensure that it does not make some
 * common coding mistakes, and it also enables some additional optimizations by
 * the compiler.
 *
 * @global
 * @since 1.0.0
 *
 * @param {Array.<string>} modules The module paths.
 * @param {Function} callback The function that will be called once all
 *     required modules have been loaded, including the modules that the
 *     required modules themselves depend on.
 *
 * @example
 * require(['scripts/newsfeed', '$api/models'], function(newsfeed, models) {
 *   var player = models.player;
 *   player.playTrack(models.Track.fromURI('spotify:track:2GIyi2hpXSAlMgjEfmd0oF'));
 * });
 */
function _require(modules, callback) {
  return SpotifyApi.api._require('__main__', {
    callback: function callback() {},
    waiting: 1 / 0 // Infinity
  }, [], modules, callback);
}
spotify.require = _require;

/**
 * @class String
 * @classdesc The built-in String class.
 * @global
 */
String;

/**
 * Before using any string returned from the Spotify API, call this method to
 * decode it to a usable string. Note that this method must only be used for
 * cases where the string will never end up being interpreted as HTML (such as
 * when using it in an innerHTML attribute). In that case, the decodeForHtml
 * method should be used instead.
 *
 * @name String#decodeForText
 * @return {string} A string without any escaped characters.
 * @since 1.0.0
 *
 * @see String#decodeForHtml
 * @see String#decodeForLink
 *
 * @example
 * document.getElementById('name').innerText = album.name.decodeForText();
 */
String.prototype.decodeForText = function () {
  return this.toString();
};

/**
 * Before using any string returned from the Spotify API in the DOM in a way
 * such that the string might be interpreted as HTML, such as setting the
 * innerHTML attribute of a node. Note that the recommendation is that the
 * application does not use innerHTML, because it is easy to accidentally
 * introduce dangerous behavior.
 *
 * @name String#decodeForHtml
 * @return {string} An escaped string that does not contain any HTML code.
 * @since 1.0.0
 *
 * @see String#decodeForText
 * @see String#decodeForLink
 *
 * @example
 * document.getElementById('name').innerHTML = track.name.decodeForHtml();
 */
String.prototype.decodeForHtml = function () {
  var e = { '&': '&amp;', '<': '&lt;', '>': '&gt;' };
  var r = function r(c) {
    return e[c];
  };
  return function () {
    return this.replace(/[&<>]/g, r);
  };
}();

/**
 * Before using a URL string returned from the Spotify API in HTML code that
 * constructs links, use this method to decode it into a string that is escaped
 * for links. Note that it is not recommended to build HTML directly using
 * strings. It is better to construct nodes and set the link URL attributes
 * instead. This way there is less chance of introducing dangerous behavior.
 *
 * @name String#decodeForLink
 * @return {string} A URL escaped string.
 * @since 1.0.0
 *
 * @see String#decodeForText
 * @see String#decodeForHtml
 *
 * @example
 * div.innerHTML = '&lt;a href="' + artist.uri.decodeForLink() + '"&gt;Artist&lt;/a&gt;';
 */
String.prototype.decodeForLink = function () {
  return encodeURI(this);
};

/**
 * URI and URL Bases used for toSpotifyURL, toSpotifyURI and toSpotifyLink
 * methods.
 */
SpotifyApi.Bases = {
  uri: 'spotify',
  url: 'http://open.spotify.com'
};

/**
 * Regular expressions used for toSpotifyURL, toSpotifyURI and toSpotifyLink
 * methods.
 */
SpotifyApi.Exps = {
  spotify: /^spotify:(.+)$/,
  http: /^https?:\/\/(play|open)\.spotify\.com\/(.+)$/
};

/**
 * Converts a string Spotify URI to a Spotify URL.
 *
 * @name String#toSpotifyURL
 * @return {String} a string containing a Spotiy URI.
 * @since 1.0.0
 *
 * @see String#toSpotifyURI
 * @see String#toSpotifyLink
 */
String.prototype.toSpotifyURL = function () {
  var matches = this.match(SpotifyApi.Exps.spotify);
  if (!matches) return this;
  var parts = matches.pop().replace(/:$/, '').split(/:/);
  var type = parts.shift();
  if (type == 'search') parts = [parts.join(':')];
  parts.unshift(SpotifyApi.Bases.url, type);
  return parts.join('/');
};

/**
 * Converts a string Spotify URL to a Spotify URI.
 *
 * @name String#toSpotifyURI
 * @return {String} a string containing a Spotiy URL.
 * @since 1.0.0
 *
 * @see String#toSpotifyURL
 * @see String#toSpotifyLink
 */
String.prototype.toSpotifyURI = function () {
  var matches = this.match(SpotifyApi.Exps.http);
  if (!matches) return this;
  var parts = matches.pop().replace(/\/$/, '').split(/\//);
  parts.unshift(SpotifyApi.Bases.uri);
  return parts.join(':');
};

/**
 * Converts a string Spotify URL or Spotify URI to the
 * platform's default type.
 *
 * @name String#toSpotifyLink
 * @return {String} a string containing a Spotiy URL or URL.
 * @since 1.0.0
 *
 * @see String#toSpotifyURL
 * @see String#toSpotifyURI
 */
String.prototype.toSpotifyLink = function () {
  return this.toSpotifyURI();
};

},{}],32:[function(require,module,exports){
'use strict';

var SpotifyApi = require('./client/core');

// This decorates SpotifyApi with monkey patch methods.
require('./client/core.desktop');

// Some apps / libs expect SP.bind, SP.inherits SP.request to be accessible.
// Examples include api/scripts/models.
window.SP = SpotifyApi.api;

exports.SpotifyApi = SpotifyApi;
exports.SP = SpotifyApi.api;
// exports.LangModule = SpotifyApi.LangModule;

},{"./client/core":31,"./client/core.desktop":30}],33:[function(require,module,exports){
'use strict';

// Base function that doesn't have any dependencies on it's own. Expects to get
// state (a plain, empty object) injected in addition to a bridge request
// function.
function cosmosRequest(state, bridge, opts, callback) {

  if (typeof opts.uri !== 'string') throw new Error('Expected uri to be string.');

  if (COSMOS_VERBS.indexOf(opts.method) === -1) throw new Error('Method must match valid verb in uppercase (GET, POST etc)');

  if (opts.body && typeof opts.body !== 'string') throw new Error('If body is provided it should be a string.');

  if (opts.headers && Object.prototype.toString.call(opts.headers) !== '[object Object]') throw new Error('Expected headers be a plain object.');

  var cosmosOptions = {
    action: opts.method,
    uri: opts.uri
  };
  if (opts.body) cosmosOptions.body = opts.body;
  if (opts.headers) cosmosOptions.headers = opts.headers;

  /* Cosmos requires each request to have a unique ID. Ideally, this would be
  uuids, but unfortunately, it is integers. This means that in apps that for
  some reason need to use spotify-cosmos-api, there would between the two
  counters if cosmosRequest started from 0. To make it safe for the two
  implemenations to co-exist if needed, we begin counting at
  significantly higher number: */
  state.requestIDCounter = state.requestIDCounter || TEN_PER_SECOND_FOR_A_YEAR;
  state.requestIDCounter++;

  var requestArguments = [state.requestIDCounter, cosmosOptions];

  var isCanceled = false;
  var stateRequestIDCounter = state.requestIDCounter;

  function cancelFunction() {
    isCanceled = true;
    bridge('cosmos_request_cancel', [stateRequestIDCounter]);
  }

  // run is a recursive function that does a bridge request and then keeps
  // pulling values after every response in the case of a subscription. In
  // case we are not subscribing, or the cancelFunction has been called,
  // run sends cosmos_request_cancel and terminates.
  function run(isFirst, requestIDCounter) {
    var messageName = isFirst ? 'cosmos_request_create' : 'cosmos_request_pull';
    bridge(messageName, requestArguments, function (error, responseString) {
      // The request to cancel may not have gotten to the bridge
      // before the original request got resolved,
      // so make sure not to continue if we detect it's been canceled.
      if (isCanceled) {
        return;
      }
      try {
        if (callback) {
          if (error) {
            callback(error);
          } else {
            callback(null, responseString);
          }
        }
      } finally {
        if (opts.method !== 'SUB') {
          // If the request was a non-SUB, tell core to clean up the request.
          // NOTE: Not sure if this is strictly necessary,
          // have not been to investigate in C++-land, so for now
          // we are just mimicing the behavior of spotify-cosmos-api.
          bridge('cosmos_request_cancel', [requestIDCounter]);
        } else if (!isCanceled) {
          // maybe canceled in above callback
          run(false, requestIDCounter);
        }
      }
    });
  }

  run(true, stateRequestIDCounter);

  return cancelFunction;
}

var TEN_PER_SECOND_FOR_A_YEAR = 10 * 60 * 60 * 24 * 365;

var COSMOS_VERBS = ['GET', 'HEAD', 'POST', 'PUT', 'SUB', 'PATCH', 'DELETE'];

module.exports = cosmosRequest;

},{}],34:[function(require,module,exports){
(function (global){
'use strict';

var debug = require('debug')('spotify-bridge-request');
var defer = require('spotify-deferred');

var cosmosBaseFunction = require('./cosmos');

// NOTE: Implicit global state.
var scheduledCoreFlush = false;
var cosmosState = null;

exports.cosmos = cosmos;
exports.cosmosJSON = cosmosJSON;
exports.request = request;
exports._request = _request;

function cosmos() {
  if (!cosmosState) cosmosState = {};

  var baseArguments = [cosmosState, request];
  var cancelFunction = cosmosBaseFunction.apply(null, baseArguments.concat(Array.prototype.slice.call(arguments)));
  return cancelFunction;
}

function _createCallbackWrapper(callback) {
  return function callbackWrapper(err, response) {
    if (!err) {
      var parsedResponse;
      try {
        parsedResponse = JSON.parse(response.body);
      } catch (e) {
        e.message = 'Failed to parse cosmos response: ' + e.message;
        callback(e);
        return;
      }
      callback(null, parsedResponse);
    } else {
      callback(err, response);
    }
  };
}

function cosmosJSON(opts, callback) {
  if (opts.body) {
    opts.body = JSON.stringify(opts.body);
  }
  var callbackWrapper = callback ? _createCallbackWrapper(callback) : null;
  var cancelFunction = cosmos(opts, callbackWrapper);
  return cancelFunction;
}

function request(name, opt_args, opt_callback) {
  var args = opt_args || [];
  var callback = getCallback(name, args, opt_callback);

  debug('req:' + name, args);

  exports._request(name, args, callback);

  if (name !== 'core_flush' && !scheduledCoreFlush) {
    scheduledCoreFlush = true;
    defer(flushCore);
  }

  return exports;
}

function _request(name, args, callback) {
  global._getSpotifyModule('bridge').executeRequest(JSON.stringify({
    name: name,
    args: args
  }), {
    onSuccess: getSuccessHandler(callback),
    onFailure: getFailureHandler(callback, name, args)
  });
}

function getCallback(name, args, opt_userCallback) {
  var userCallback = opt_userCallback || function () {};

  return function (error, data) {
    if (error) {
      if (error.name === 'timeout') {
        // Set the delay between 300ms and 400ms
        var delay = 300 + Math.floor(Math.random() * 100);

        debug('timeout', error.message);

        // Retry the request
        setTimeout(function () {
          request(name, args, userCallback);
        }, delay);
        return;
      }
    }

    debug('res:' + name, args, data);

    userCallback(error, data);
  };
}

function getSuccessHandler(requestCallback) {
  return function (data) {
    var parsed;

    debug('success', data);

    try {
      parsed = JSON.parse(data);
    } catch (error) {
      requestCallback(error);
    }

    if (parsed) {
      requestCallback(null, parsed);
    }
  };
}

function getFailureHandler(requestCallback, name, args) {
  return function (data) {
    var parsed;

    debug('failure', data);

    try {
      parsed = JSON.parse(data);
    } catch (error) {
      requestCallback(error);
    }

    if (parsed) {
      requestCallback(createError(name, args, parsed));
    }
  };
}

function createError(name, args, response) {
  var argsString = JSON.stringify(args);
  var debug = ' (bridge message: \'' + name + '\', args: ' + argsString + ')';
  var msg = response.message + debug;
  var error = new Error(msg);
  error.name = response.error;

  return error;
}

function flushCore() {
  scheduledCoreFlush = false;
  request('core_flush');
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./cosmos":33,"debug":159,"spotify-deferred":251}],35:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var ClientEvent3 = require('../spotify-logger/messages/ClientEvent3');

var EVENTS = {
  // User (primary)
  USER_IMPRESSION: 'user:impression',
  USER_HIT: 'user:hit',
  // User (secondary - only use if neccesary)
  USER_SELECT: 'user:select',
  USER_HOVER: 'user:hover',
  USER_HOLD_TIMER: 'user:hold',

  // Info
  INFO_TIMER_DEFAULT: 'info:timer',
  INFO_STATE_LOAD_TIMER: 'info:state_load_timer',
  INFO_DEFAULT: 'info:default',
  INFO_WARN: 'info:warn',

  // Error
  ERROR_DEFAULT: 'error:default',
  ERROR_USER_ACTION_FAIL: 'error:user_action_fail',
  ERROR_RENDER_FAIL: 'error:render_fail'
};

var mixin = function mixin(base, addition) {
  var prop;
  for (prop in addition) {
    if (!base[prop]) {
      base[prop] = addition[prop];
    }
  }
};

/**
 * @class Logger Constructor
 * @param {Function} optBridgeRequest used mostly for testing
 */
function Logger() {
  this.timers = {};
}

/**
 * Filters out the data that should be specific fields in the schema
 * @param {object} obj - the mutated data obj
 * @param {object} extraData - the additional data in the log
 */
Logger.prototype._filterSchemaData = function (obj, extraData) {
  ClientEvent3.schema.fields.forEach(function (field) {
    if (extraData[field.name]) {
      obj[field.name] = extraData[field.name];
      delete extraData[field.name];
    }
  });
};

/**
 * Adds the remaining jsonData to the object
 * and overrides existing values
 * @param {object} obj - object that will be mutated
 * @param {object} jsonData
 */
Logger.prototype._addJsonData = function (obj, jsonData) {
  if (obj.json_data) {
    // Override the existing keys
    Object.keys(jsonData).forEach(function (key) {
      obj.json_data[key] = jsonData[key];
    });
  } else {
    obj.json_data = jsonData;
  }
};

/**
 * Builds ordered data array for backend consumption
 * @param {string} event Must be one of CLIENT_EVENT_NAMES or null.
 * @param {string|array} logData
 * @private
 * @return {array}
 */
Logger.prototype._buildBackendData = function (event, logData) {
  var data = {
    source_vendor: 'com.spotify',
    event: event
  };
  var extra;

  if (!logData.length) {
    throw new Error('Need some data to log!');
  }

  if (this.constant) {
    mixin(data, this.constant);
  }

  if (logData.length === 1) {
    if (typeof logData[0] === 'string') {
      data.event_version = logData[0];
      return data;
    } else if (_typeof(logData[0]) === 'object') {
      extra = logData[0];
    } else {
      throw new Error(event + ' must log either an object literal or a string');
    }
  } else {
    // support for the old logging style
    // might not even be needed -- should investigate
    data.event_version = logData[0];
    data.context = logData[2];
    extra = logData[1] || {};
  }

  this._filterSchemaData(data, extra);
  this._addJsonData(data, extra);

  return data;
};

/**
 * Internal log function: sends log to backend.
 * @param {array} backendData
 * @private
 */
Logger.prototype._log = function (backendData) {
  ClientEvent3.log(backendData);
};

// Public Methods

/**
 * All Log Methods
 *
 * @function
 * @param {...strings} optional number of arguments
 * @param {string|object} logData - can have the following key/values
 *        event_version, context, target_uri, name, section
 *        plus any number of optional key/values
 * Example: logger.userHit({
 *           event_version: 'play_button',
 *           context: 'recommended_stations',
 *           target_uri: 'spotify:genre:rock',
 *           name: 'Rock Genre Station'
 *           section: 'Carousel',
 *           customField: 'hello'
 *        });
 * @public
 */

Logger.prototype.userImpression = function () {
  var args = Array.prototype.slice.call(arguments, 0);
  this._log(this._buildBackendData(EVENTS.USER_IMPRESSION, args));
};
Logger.prototype.userHit = function () {
  var args = Array.prototype.slice.call(arguments, 0);
  this._log(this._buildBackendData(EVENTS.USER_HIT, args));
};
Logger.prototype.userSelect = function () {
  var args = Array.prototype.slice.call(arguments, 0);
  this._log(this._buildBackendData(EVENTS.USER_SELECT, args));
};
Logger.prototype.userHover = function () {
  var args = Array.prototype.slice.call(arguments, 0);
  this._log(this._buildBackendData(EVENTS.USER_HOVER, args));
};
Logger.prototype.userHold = function () {
  var args = Array.prototype.slice.call(arguments, 0);
  this._log(this._buildBackendData(EVENTS.USER_HOLD_TIMER, args));
};
Logger.prototype.info = function () {
  var args = Array.prototype.slice.call(arguments, 0);
  this._log(this._buildBackendData(EVENTS.INFO_DEFAULT, args));
};
Logger.prototype.infoWarn = function () {
  var args = Array.prototype.slice.call(arguments, 0);
  this._log(this._buildBackendData(EVENTS.INFO_WARN, args));
};
Logger.prototype.infoStageLoadTimer = function () {
  var args = Array.prototype.slice.call(arguments, 0);
  this._log(this._buildBackendData(EVENTS.INFO_STATE_LOAD_TIMER, args));
};
Logger.prototype.infoTimer = function () {
  var args = Array.prototype.slice.call(arguments, 0);
  this._log(this._buildBackendData(EVENTS.INFO_TIMER_DEFAULT, args));
};
Logger.prototype.error = function () {
  var args = Array.prototype.slice.call(arguments, 0);
  this._log(this._buildBackendData(EVENTS.ERROR_DEFAULT, args));
};
Logger.prototype.errorUserActionFail = function () {
  var args = Array.prototype.slice.call(arguments, 0);
  this._log(this._buildBackendData(EVENTS.ERROR_USER_ACTION_FAIL, args));
};
Logger.prototype.errorRenderFail = function () {
  var args = Array.prototype.slice.call(arguments, 0);
  this._log(this._buildBackendData(EVENTS.ERROR_RENDER_FAIL, args));
};
Logger.prototype.createTimer = function (eventVersion, optKey) {
  var key = eventVersion + (optKey || '');

  this.timers[key] = {
    startTime: Date.now(),
    eventVersion: eventVersion
  };

  return key;
};
Logger.prototype.logTimer = function (key, optData) {
  var timer = this.timers[key];
  var data = optData ? optData : {};

  if (!timer) {
    throw new Error('LogTimer: No record of a timer with key: ' + key);
  }
  data.event_version = timer.eventVersion;
  data.duration = Date.now() - timer.startTime;

  this._log(this._buildBackendData(EVENTS.INFO_TIMER_DEFAULT, [data]));
};

/**
 * @function
 * @param (object) - constant
 * add some data to go into every log event e.g. { featureName: featureValue };
 */

Logger.prototype.setConstant = function (constant) {
  if ((typeof constant === 'undefined' ? 'undefined' : _typeof(constant)) !== 'object') return;
  this.constant = constant;
};
module.exports = Logger;

},{"../spotify-logger/messages/ClientEvent3":127}],36:[function(require,module,exports){
/*
attributes
*/"use strict";

var $ = require("./base");

var trim = require("mout/string/trim"),
    forEach = require("mout/array/forEach"),
    filter = require("mout/array/filter"),
    indexOf = require("mout/array/indexOf");

// attributes

$.implement({

    setAttribute: function setAttribute(name, value) {
        return this.forEach(function (node) {
            node.setAttribute(name, value);
        });
    },

    getAttribute: function getAttribute(name) {
        var attr = this[0].getAttributeNode(name);
        return attr && attr.specified ? attr.value : null;
    },

    hasAttribute: function hasAttribute(name) {
        var node = this[0];
        if (node.hasAttribute) return node.hasAttribute(name);
        var attr = node.getAttributeNode(name);
        return !!(attr && attr.specified);
    },

    removeAttribute: function removeAttribute(name) {
        return this.forEach(function (node) {
            var attr = node.getAttributeNode(name);
            if (attr) node.removeAttributeNode(attr);
        });
    }

});

var accessors = {};

forEach(["type", "value", "name", "href", "title", "id"], function (name) {

    accessors[name] = function (value) {
        return value !== undefined ? this.forEach(function (node) {
            node[name] = value;
        }) : this[0][name];
    };
});

// booleans

forEach(["checked", "disabled", "selected"], function (name) {

    accessors[name] = function (value) {
        return value !== undefined ? this.forEach(function (node) {
            node[name] = !!value;
        }) : !!this[0][name];
    };
});

// className

var classes = function classes(className) {
    var classNames = trim(className).replace(/\s+/g, " ").split(" "),
        uniques = {};

    return filter(classNames, function (className) {
        if (className !== "" && !uniques[className]) return uniques[className] = className;
    }).sort();
};

accessors.className = function (className) {
    return className !== undefined ? this.forEach(function (node) {
        node.className = classes(className).join(" ");
    }) : classes(this[0].className).join(" ");
};

// attribute

$.implement({

    attribute: function attribute(name, value) {
        var accessor = accessors[name];
        if (accessor) return accessor.call(this, value);
        if (value != null) return this.setAttribute(name, value);
        if (value === null) return this.removeAttribute(name);
        if (value === undefined) return this.getAttribute(name);
    }

});

$.implement(accessors);

// shortcuts

$.implement({

    check: function check() {
        return this.checked(true);
    },

    uncheck: function uncheck() {
        return this.checked(false);
    },

    disable: function disable() {
        return this.disabled(true);
    },

    enable: function enable() {
        return this.disabled(false);
    },

    select: function select() {
        return this.selected(true);
    },

    deselect: function deselect() {
        return this.selected(false);
    }

});

// classNames, has / add / remove Class

$.implement({

    classNames: function classNames() {
        return classes(this[0].className);
    },

    hasClass: function hasClass(className) {
        return indexOf(this.classNames(), className) > -1;
    },

    addClass: function addClass(className) {
        return this.forEach(function (node) {
            var nodeClassName = node.className;
            var classNames = classes(nodeClassName + " " + className).join(" ");
            if (nodeClassName !== classNames) node.className = classNames;
        });
    },

    removeClass: function removeClass(className) {
        return this.forEach(function (node) {
            var classNames = classes(node.className);
            forEach(classes(className), function (className) {
                var index = indexOf(classNames, className);
                if (index > -1) classNames.splice(index, 1);
            });
            node.className = classNames.join(" ");
        });
    },

    toggleClass: function toggleClass(className, force) {
        var add = force !== undefined ? force : !this.hasClass(className);
        if (add) this.addClass(className);else this.removeClass(className);
        return !!add;
    }

});

// toString

$.prototype.toString = function () {
    var tag = this.tag(),
        id = this.id(),
        classes = this.classNames();

    var str = tag;
    if (id) str += '#' + id;
    if (classes.length) str += '.' + classes.join(".");
    return str;
};

var textProperty = document.createElement('div').textContent == null ? 'innerText' : 'textContent';

// tag, html, text, data

$.implement({

    tag: function tag() {
        return this[0].tagName.toLowerCase();
    },

    html: function html(_html) {
        return _html !== undefined ? this.forEach(function (node) {
            node.innerHTML = _html;
        }) : this[0].innerHTML;
    },

    text: function text(_text) {
        return _text !== undefined ? this.forEach(function (node) {
            node[textProperty] = _text;
        }) : this[0][textProperty];
    },

    data: function data(key, value) {
        switch (value) {
            case undefined:
                return this.getAttribute("data-" + key);
            case null:
                return this.removeAttribute("data-" + key);
            default:
                return this.setAttribute("data-" + key, value);
        }
    }

});

module.exports = $;

},{"./base":37,"mout/array/filter":197,"mout/array/forEach":200,"mout/array/indexOf":201,"mout/string/trim":230}],37:[function(require,module,exports){
/*
elements
*/"use strict";

var prime = require("prime");

var _forEach = require("mout/array/forEach"),
    _map = require("mout/array/map"),
    _filter = require("mout/array/filter"),
    _every = require("mout/array/every"),
    _some = require("mout/array/some");

// uniqueID

var index = 0,
    __dc = document.__counter,
    counter = document.__counter = (__dc ? parseInt(__dc, 36) + 1 : 0).toString(36),
    key = "uid:" + counter;

var uniqueID = function uniqueID(n) {
    if (n === window) return "window";
    if (n === document) return "document";
    if (n === document.documentElement) return "html";
    return n[key] || (n[key] = (index++).toString(36));
};

var instances = new WeakMap();

// elements prime

var $ = prime({ constructor: function $(n, context) {

        if (n == null) return this && this.constructor === $ ? new Elements() : null;

        var self, uid, instance;

        if (n.constructor !== Elements) {

            self = new Elements();

            if (typeof n === "string") {
                if (!self.search) return null;
                self[self.length++] = context || document;
                return self.search(n);
            }

            if (n.nodeType || n === window) {

                self[self.length++] = n;
            } else if (n.length) {

                // this could be an array, or any object with a length attribute,
                // including another instance of elements from another interface.

                var uniques = {};

                for (var i = 0, l = n.length; i < l; i++) {
                    // perform elements flattening
                    var nodes = $(n[i], context);
                    if (nodes && nodes.length) for (var j = 0, k = nodes.length; j < k; j++) {
                        var node = nodes[j];
                        uid = uniqueID(node);
                        if (!uniques[uid]) {
                            self[self.length++] = node;
                            uniques[uid] = true;
                        }
                    }
                }
            }
        } else {
            self = n;
        }

        if (!self.length) return null;

        // when length is 1 always use the same elements instance

        if (self.length === 1) {
            if (instance = instances.get(self[0])) {
                return instance;
            } else {
                instances.set(self[0], self);
            }
        }

        return self;
    } });

var Elements = prime({

    inherits: $,

    constructor: function Elements() {
        this.length = 0;
    },

    unlink: function unlink() {
        return this.map(function (node) {
            instances.delete(node);
            return node;
        });
    },

    // methods

    forEach: function forEach(method, context) {
        _forEach(this, method, context);
        return this;
    },

    map: function map(method, context) {
        return _map(this, method, context);
    },

    filter: function filter(method, context) {
        return _filter(this, method, context);
    },

    every: function every(method, context) {
        return _every(this, method, context);
    },

    some: function some(method, context) {
        return _some(this, method, context);
    }

});

module.exports = $;

},{"mout/array/every":196,"mout/array/filter":197,"mout/array/forEach":200,"mout/array/map":203,"mout/array/some":205,"prime":235}],38:[function(require,module,exports){
/*
delegation
*/"use strict";

var Map = require("prime/map");

var $ = require("./events");
require('./traversal');

$.implement({

    delegate: function delegate(event, selector, handle) {

        return this.forEach(function (node) {

            var self = $(node);

            var delegation = self._delegation || (self._delegation = {}),
                events = delegation[event] || (delegation[event] = {}),
                map = events[selector] || (events[selector] = new Map());

            if (map.get(handle)) return;

            var action = function action(e) {
                var target = $(e.target || e.srcElement),
                    match = target.matches(selector) ? target : target.parent(selector);

                var res;

                if (match) res = handle.call(self, e, match);

                return res;
            };

            map.set(handle, action);

            self.on(event, action);
        });
    },

    undelegate: function undelegate(event, selector, handle) {

        return this.forEach(function (node) {

            var self = $(node),
                delegation,
                events,
                map;

            if (!(delegation = self._delegation) || !(events = delegation[event]) || !(map = events[selector])) return;

            var action = map.get(handle);

            if (action) {
                self.off(event, action);
                map.remove(action);

                // if there are no more handles in a given selector, delete it
                if (!map.count()) delete events[selector];
                // var evc = evd = 0, x
                var e1 = true,
                    e2 = true,
                    x;
                for (x in events) {
                    e1 = false;
                    break;
                }
                // if no more selectors in a given event type, delete it
                if (e1) delete delegation[event];
                for (x in delegation) {
                    e2 = false;
                    break;
                }
                // if there are no more delegation events in the element, delete the _delegation object
                if (e2) delete self._delegation;
            }
        });
    }

});

module.exports = $;

},{"./events":39,"./traversal":42,"prime/map":236}],39:[function(require,module,exports){
/*
events
*/"use strict";

var Emitter = require("prime/emitter");

var $ = require("./base");

$.implement({

    on: function on(event, handle, useCapture) {

        return this.forEach(function (node) {
            var self = $(node);

            var internalEvent = event + (useCapture ? ":capture" : "");

            Emitter.prototype.on.call(self, internalEvent, handle);

            var domListeners = self._domListeners || (self._domListeners = {});
            if (!domListeners[internalEvent]) {
                var listener = function listener(e) {
                    Emitter.prototype.emit.call(self, internalEvent, e || window.event, Emitter.EMIT_SYNC);
                };
                node.addEventListener(event, listener, useCapture || false);
                domListeners[internalEvent] = listener;
            }
        });
    },

    off: function off(event, handle, useCapture) {

        return this.forEach(function (node) {

            var self = $(node);

            var internalEvent = event + (useCapture ? ":capture" : "");

            var domListeners = self._domListeners,
                domEvent,
                listeners = self._listeners,
                events;

            if (domListeners && (domEvent = domListeners[internalEvent]) && listeners && (events = listeners[internalEvent])) {

                Emitter.prototype.off.call(self, internalEvent, handle);

                if (!self._listeners || !self._listeners[event]) {
                    node.removeEventListener(event, domEvent, false);
                    delete domListeners[event];

                    for (var l in domListeners) {
                        return;
                    }delete self._domListeners;
                }
            }
        });
    },

    emit: function emit() {
        var args = arguments;
        return this.forEach(function (node) {
            Emitter.prototype.emit.apply($(node), args);
        });
    }

});

module.exports = $;

},{"./base":37,"prime/emitter":234}],40:[function(require,module,exports){
/*
elements
*/"use strict";

var $ = require("./base");
require("./attributes");
require("./events");
require("./insertion");
require("./traversal");
require("./delegation");

module.exports = $;

},{"./attributes":36,"./base":37,"./delegation":38,"./events":39,"./insertion":41,"./traversal":42}],41:[function(require,module,exports){
/*
insertion
*/"use strict";

var $ = require("./base");

// base insertion

$.implement({

    appendChild: function appendChild(child) {
        this[0].appendChild($(child)[0]);
        return this;
    },

    insertBefore: function insertBefore(child, ref) {
        this[0].insertBefore($(child)[0], $(ref)[0]);
        return this;
    },

    removeChild: function removeChild(child) {
        this[0].removeChild($(child)[0]);
        return this;
    },

    replaceChild: function replaceChild(child, ref) {
        this[0].replaceChild($(child)[0], $(ref)[0]);
        return this;
    }

});

// before, after, bottom, top

$.implement({

    before: function before(element) {
        element = $(element)[0];
        var parent = element.parentNode;
        if (parent) this.forEach(function (node) {
            parent.insertBefore(node, element);
        });
        return this;
    },

    after: function after(element) {
        element = $(element)[0];
        var parent = element.parentNode;
        if (parent) this.forEach(function (node) {
            parent.insertBefore(node, element.nextSibling);
        });
        return this;
    },

    bottom: function bottom(element) {
        element = $(element)[0];
        return this.forEach(function (node) {
            element.appendChild(node);
        });
    },

    top: function top(element) {
        element = $(element)[0];
        return this.forEach(function (node) {
            element.insertBefore(node, element.firstChild);
        });
    }

});

// insert, replace

$.implement({

    insert: $.prototype.bottom,

    remove: function remove() {
        return this.forEach(function (node) {
            var parent = node.parentNode;
            if (parent) parent.removeChild(node);
        });
    },

    replace: function replace(element) {
        element = $(element)[0];
        element.parentNode.replaceChild(this[0], element);
        return this;
    }

});

module.exports = $;

},{"./base":37}],42:[function(require,module,exports){
/*
traversal
*/"use strict";

var map = require("mout/array/map");

var slick = require("slick");

var $ = require("./base");

var gen = function gen(combinator, expression) {
    return map(slick.parse(expression || "*"), function (part) {
        return combinator + " " + part;
    }).join(", ");
};

var push_ = Array.prototype.push;

$.implement({

    search: function search(expression) {
        if (this.length === 1) return $(slick.search(expression, this[0], new $()));

        var buffer = [];
        for (var i = 0, node; node = this[i]; i++) {
            push_.apply(buffer, slick.search(expression, node));
        }buffer = $(buffer);
        return buffer && buffer.sort();
    },

    find: function find(expression) {
        if (this.length === 1) return $(slick.find(expression, this[0]));

        for (var i = 0, node; node = this[i]; i++) {
            var found = slick.find(expression, node);
            if (found) return $(found);
        }

        return null;
    },

    sort: function sort() {
        return slick.sort(this);
    },

    matches: function matches(expression) {
        return slick.matches(this[0], expression);
    },

    contains: function contains(node) {
        return slick.contains(this[0], node);
    },

    nextSiblings: function nextSiblings(expression) {
        return this.search(gen('~', expression));
    },

    nextSibling: function nextSibling(expression) {
        return this.find(gen('+', expression));
    },

    previousSiblings: function previousSiblings(expression) {
        return this.search(gen('!~', expression));
    },

    previousSibling: function previousSibling(expression) {
        return this.find(gen('!+', expression));
    },

    children: function children(expression) {
        return this.search(gen('>', expression));
    },

    firstChild: function firstChild(expression) {
        return this.find(gen('^', expression));
    },

    lastChild: function lastChild(expression) {
        return this.find(gen('!^', expression));
    },

    parent: function parent(expression) {
        var buffer = [];
        loop: for (var i = 0, node; node = this[i]; i++) {
            while ((node = node.parentNode) && node !== document) {
                if (!expression || slick.matches(node, expression)) {
                    buffer.push(node);
                    break loop;
                    break;
                }
            }
        }return $(buffer);
    },

    parents: function parents(expression) {
        var buffer = [];
        for (var i = 0, node; node = this[i]; i++) {
            while ((node = node.parentNode) && node !== document) {
                if (!expression || slick.matches(node, expression)) buffer.push(node);
            }
        }return $(buffer);
    }

});

module.exports = $;

},{"./base":37,"mout/array/map":203,"slick":239}],43:[function(require,module,exports){
'use strict';

var $ = require('../spotify-elements');
var Navigator = require('../spotify-navigation/navigator');
var AppState = require('../spotify-navigation/app-state');

var SELECTOR = 'a';

var nav = new Navigator();

var handleAnchorClick = function handleAnchorClick(event, node) {
  var anchor = node[0];
  var href = anchor.getAttribute('href');
  if (!href || href[0] === '#') {
    return;
  }

  event.preventDefault();

  var referrer = anchor.getAttribute('data-referrer-id') || document.body.getAttribute('data-referrer-id');

  var state = new AppState(href);

  if (referrer) {
    state.setReferrer(referrer);
  }

  nav.requestOpenState(state);
};

var isAttached = false;

exports.attach = function attach() {
  if (isAttached) {
    return;
  }
  isAttached = true;
  $(document).delegate('click', SELECTOR, handleAnchorClick);
};

exports.detach = function detach() {
  if (!isAttached) {
    return;
  }
  isAttached = false;
  $(document).undelegate('click', SELECTOR, handleAnchorClick);
};

exports.update = function () {};

},{"../spotify-elements":40,"../spotify-navigation/app-state":131,"../spotify-navigation/navigator":132}],44:[function(require,module,exports){
/*
Event Center
*/'use strict';

var Emitter = require('prime/emitter');

module.exports = new Emitter();

},{"prime/emitter":234}],45:[function(require,module,exports){
'use strict';

/**
 * @private
 */

// [SHUFFLE] Used only for showing the message bar when trying to play a track.
var shuffleMode = require('../../spotify-shuffle-mode');
var cosmos = require('spotify-cosmos-api');

var $ = require('../../spotify-elements');
var utils = require('./utils');

var SELECTOR_LIST_ROW = '[data-context] [data-list-item]';
var SELECTOR_PLAY_BUTTON = '[data-button=play]';
var SELECTOR_PLAY_CONTEXT_BUTTON = '[data-button=play-context]';

// This array will store event types for touch handling
var lastEventTypes = [];

// Methods that need implementation from another module.
// This is to support generic handling of user actions from within this module,
// but allow further checks and actions to be performed by another module. This
// allows multiple different implementations of starting playback for example.
var methods = {
  getPlayerVariantUri: utils.createEmptyMethod('getPlayerVariantUri'),
  handlePlayButton: utils.createEmptyMethod('handlePlayButton'),
  handlePlayFromRow: utils.createEmptyMethod('handlePlayFromRow')
};

/**
 * Handle the click of a play button.
 *
 * @param {MouseEvent} event An event object for a click event.
 * @param {Elements} button An element instance from the `elements` package.
 *
 * @private
 */
function handlePlayButtonClick(event, button) {
  var buttonNode = button[0];
  var buttonContextUri = utils.getUriFromButton(buttonNode);

  // We need an associated context URI for the button
  if (!buttonContextUri) {
    return;
  }

  // [SHUFFLE]: track buttons do not work.
  if (shuffleMode.isEnabled() && /^spotify:track:/.test(buttonContextUri)) {
    cosmos.resolver.post({
      url: 'sp://messages/v1/container/user-message',
      body: {
        description: 'Track cannot be played because "shuffle mode" is enabled',
        id: 'shuffle-unplayable-track'
      }
    }, function () {
      // We don't care about reply, if it fails we can't do pretty much anything
    });

    return;
  }

  var playerContextUri = methods.getPlayerVariantUri();
  var isPlayingContext = utils.compareContexts(playerContextUri, buttonContextUri);

  var source = utils.getAttributeValueFromNode(buttonNode, 'data-play-source');

  methods.handlePlayButton(buttonNode, {
    isPlayingContext: isPlayingContext,
    contextUri: buttonContextUri,
    source: source,
    reason: 'playbtn'
  });
}

/**
 * Handle the double click or tap of a list row to start playback.
 *
 * @param {Elements} row An element instance from the `elements` package.
 *
 * @private
 */
function handleListRow(row) {
  var contextNode = row.parent('[data-context]');
  if (contextNode) {
    var rowNode = row[0];
    var source = utils.getAttributeValueFromNode(rowNode, 'data-play-source');
    methods.handlePlayFromRow(rowNode, {
      contextUri: contextNode.data('uri'),
      source: source,
      reason: 'clickrow'
    });
  }
}

/**
 * Handle double clicking on a list row to start playback.
 *
 * @param {MouseEvent} event An event object for a double click.
 * @param {Elements} row An element instance from the `elements` package.
 *
 * @private
 */
function handleRowDoubleClick(event, row) {
  // Only play when not clicking on interactive elements such as buttons
  if (!utils.isInteractiveElement(event.target)) {
    handleListRow(row);
  }
}

/**
 * Handle a key press on a list row.
 * This will take care of starting playback when pressing Enter.
 *
 * @param {KeyboardEvent} event A keyboard event.
 * @param {Elements} row An element instance from the `elements` package.
 *
 * @private
 */
function handleRowKeyDown(event, row) {
  var isEnter = event.keyCode === 13;
  if (isEnter) {
    if (utils.isFormOrLinkElement(event.target)) {
      return;
    }

    event.preventDefault();
    event.stopPropagation();

    handleListRow(row);
  }
}

/**
 * Handle the 'contextmenu' event. This is only for touch handling.
 * This is needed since we use a custom context menu in Spotify, and the handler
 * for that calls `preventDefault` for the 'contextmenu' event, which means the
 * rest of the touch handling will go on as usual. So as we don't get the
 * 'touchcancel' event, we need to catch the 'contextmenu' event here to know
 * that we should not act on the following 'touchend' event.
 *
 * @param {MouseEvent} event A 'contextmenu' event.
 *
 * @private
 */
function handleContextMenu(event) {
  lastEventTypes.push(event.type);
}

/**
 * Handle the start of a touch. Used to detect a tap.
 *
 * @param {TouchEvent} event A touch event.
 *
 * @private
 */
function handleRowTouchStart(event) {
  lastEventTypes.push(event.type);
}

/**
 * Handle the move of a touch. Used to abort detection of a tap.
 *
 * @param {TouchEvent} event A touch event.
 *
 * @private
 */
function handleRowTouchMove(event) {
  lastEventTypes.push(event.type);
}

/**
 * Handle the end of a touch. Used to detect a tap and start playback of a row.
 *
 * @param {TouchEvent} event A touch event.
 * @param {Elements} row An element instance from the `elements` package.
 *
 * @private
 */
function handleRowTouchEnd(event, row) {
  // If this was a tap (only touchstart was triggered before this)
  if (lastEventTypes.length === 1 && lastEventTypes[0] === 'touchstart') {

    // Prevent the simulated mouse events (including click). This is to
    // avoid the simulated click event to click on the play button that
    // appears when selecting a row on touchstart.
    // See: https://jira.spotify.net/browse/KM-7983
    if (!utils.isInteractiveElement(event.target)) {
      event.preventDefault();

      // Tapping on a row should play it
      handleListRow(row);
    }
  }
  lastEventTypes = [];
}

/**
 * Attach the needed event listeners for the module.
 */
exports.attach = function () {
  var doc = $(document);

  doc.delegate('keydown', SELECTOR_LIST_ROW, handleRowKeyDown);
  doc.delegate('click', SELECTOR_PLAY_BUTTON, handlePlayButtonClick);
  doc.delegate('click', SELECTOR_PLAY_CONTEXT_BUTTON, handlePlayButtonClick);
  doc.delegate('dblclick', SELECTOR_LIST_ROW, handleRowDoubleClick);

  /* For touch handling */
  doc.delegate('touchstart', SELECTOR_LIST_ROW, handleRowTouchStart);
  doc.delegate('touchend', SELECTOR_LIST_ROW, handleRowTouchEnd);
  doc.delegate('touchmove', SELECTOR_LIST_ROW, handleRowTouchMove);
  doc.delegate('contextmenu', SELECTOR_LIST_ROW, handleContextMenu);
};

/**
 * Detach the event listeners for the module.
 */
exports.detach = function () {
  var doc = $(document);

  doc.undelegate('keydown', SELECTOR_LIST_ROW, handleRowKeyDown);
  doc.undelegate('click', SELECTOR_PLAY_BUTTON, handlePlayButtonClick);
  doc.undelegate('click', SELECTOR_PLAY_CONTEXT_BUTTON, handlePlayButtonClick);
  doc.undelegate('dblclick', SELECTOR_LIST_ROW, handleRowDoubleClick);

  /* For touch handling */
  doc.undelegate('touchstart', SELECTOR_LIST_ROW, handleRowTouchStart);
  doc.undelegate('touchend', SELECTOR_LIST_ROW, handleRowTouchEnd);
  doc.undelegate('touchmove', SELECTOR_LIST_ROW, handleRowTouchMove);
  doc.undelegate('contextmenu', SELECTOR_LIST_ROW, handleContextMenu);
};

/**
 * Set the external methods for this module to add implementations for starting
 * playback etc.
 *
 * @param {Object} methodDefinitions Object where keys are method names and
 *     values are functions.
 */
exports.setMethods = function (methodDefinitions) {
  for (var name in methodDefinitions) {
    if (methodDefinitions.hasOwnProperty(name)) {
      methods[name] = methodDefinitions[name];
    }
  }
};

},{"../../spotify-elements":40,"../../spotify-shuffle-mode":151,"./utils":48,"spotify-cosmos-api":246}],46:[function(require,module,exports){
'use strict';

var playerWithIndices = require('./withIndices');
var playerWithUids = require('./withUids');

var playerModule = playerWithIndices;

exports.setMode = function (type) {
  switch (type) {
    case 'indices':
      playerModule = playerWithIndices;
      break;
    case 'uids':
      playerModule = playerWithUids;
      break;
  }
};

exports.attach = function () {
  playerModule.attach();
};

exports.detach = function () {
  playerModule.detach();
};

exports.update = function (optNode) {
  playerModule.update(optNode);
};

},{"./withIndices":49,"./withUids":50}],47:[function(require,module,exports){
'use strict';

/**
 * @private
 */

var difference = require('mout/array/difference');
var $ = require('../../spotify-elements');
var live = require('../../spotify-live');

var center = require('../center');
var utils = require('./utils');

var CURRENT = 'current';
var PAUSED = 'paused';
var PLAYING = 'playing';

var LOG_PLAY_BUTTON = 'play-button';
var LOG_PAUSE_BUTTON = 'pause-button';

var SELECTOR_PLAY_BUTTON = '[data-button=play]';
var SELECTOR_PLAY_CONTEXT_BUTTON = '[data-button=play-context]';
var SELECTOR_ALL_PLAY_BUTTONS = SELECTOR_PLAY_BUTTON + ',' + SELECTOR_PLAY_CONTEXT_BUTTON;

// Methods that need implementation from another module.
// This is to support generic handling of DOM updates from within this module,
// but allow further checks and actions to be performed by another module. This
// allows multiple different implementations of highlighting playing objects.
var methods = {
  getPlayerVariantUri: utils.createEmptyMethod('getPlayerVariantUri'),
  getPlayerIsPlaying: utils.createEmptyMethod('getPlayerIsPlaying'),
  getPlayingNodes: utils.createEmptyMethod('getPlayingNodes'),

  // This should be a function that takes a function as the first argument. That
  // function argument should be called whenever the player state has changed.
  subscribeToPlayerChange: utils.createEmptyMethod('subscribeToPlayerChange')
};

var playableChangeHandlers = {};
var playerSubscription = null;

/**
 * Update states in the DOM based on current player state.
 *
 * @param {HTMLElement=} node An optional DOM node. If passed, only nodes inside
 *     of that node will be updated.
 */
function updateDOM(optNode) {
  var containerNode = optNode || document;

  updateButtonsBasedOnPlayable(containerNode);

  var playingNodes = getPlayingNodes(containerNode);
  var currentNodes = getCurrentNodes(containerNode);

  if (currentNodes) {
    var nodesForRemoval = currentNodes;
    if (playingNodes) {
      nodesForRemoval = difference(currentNodes, playingNodes);
    }
    nodesForRemoval.forEach(removePlayingStateFromNode);
  }

  if (playingNodes) {
    var nodesForAddition = playingNodes;
    if (currentNodes) {
      nodesForAddition = difference(playingNodes, currentNodes);
    }
    nodesForAddition.forEach(addPlayingStateToNode);

    var nodesForUpdate = difference(playingNodes, nodesForAddition);
    nodesForUpdate.forEach(updatePlayingStateForNode);
  }
}

/**
 * Update the playable status of all play buttons found inside the passed
 * container node.
 *
 * @param {HTMLElement} containerNode A DOM node to search for nodes inside.
 *
 * @private
 */
function updateButtonsBasedOnPlayable(containerNode) {
  // `[data-button=play]` buttons are used to play something specific *in* a
  // context (defining an index as a track number or uid/uri or range).
  // Those are currently not updated themselves, instead their rows are being
  // set to `.unavailable`.
  var buttons = $(containerNode).search('[data-button=play-context]');
  if (buttons) {
    buttons.forEach(updateButtonBasedOnPlayable);
  }
}

/**
 * Update the playable status of the passed button.
 *
 * @param {HTMLElement} button A button DOM node.
 *
 * @private
 */
function updateButtonBasedOnPlayable(button) {

  // Play buttons in list rows should not be handled, as the buttons are
  // hidden by CSS anyway for unplayable rows.
  if (!!$(button).parent('[data-list-item]')) {
    return;
  }

  var contextURI = utils.getUriFromButton(button);

  // Check if the context has a playable flag specified.
  var playableValue = live(contextURI).get('playable');
  var definesPlayable = playableValue != undefined;

  // If it does, update the `disabled` attribute based on it
  if (definesPlayable) {
    if (playableValue) {
      button.removeAttribute('disabled');
    } else {
      button.setAttribute('disabled', 'disabled');
    }

    if (!playableChangeHandlers[contextURI]) {
      playableChangeHandlers[contextURI] = function (changed) {
        if (!changed.hasOwnProperty('playable')) return;
        // Update all buttons currently in DOM when `playable` changes on a
        // context. Not worth adding logic to only pick out buttons pointing to
        // a specific URI.
        updateButtonsBasedOnPlayable(document.body);
      };
      live(contextURI).on('update', playableChangeHandlers[contextURI]);
    }
  }
}

/**
 * Get the nodes inside the passed container node that are currently marked as
 * playing.
 *
 * @param {HTMLElement} containerNode A DOM node to search for nodes inside.
 *
 * @return {?Elements} An element instance from the `elements` package, or null.
 *
 * @private
 */
function getCurrentNodes(containerNode) {
  return $(containerNode).search('[data-playback-active=true]');
}

/**
 * Get the nodes inside the passed container node that should be marked as
 * playing based on the current player state.
 *
 * @param {HTMLElement} containerNode A DOM node to search for nodes inside.
 *
 * @return {?Elements} An element instance from the `elements` package, or null.
 *
 * @private
 */
function getPlayingNodes(containerNode) {
  var variantUri = methods.getPlayerVariantUri();
  var selectors = utils.getContextSelectorsWithVariants(variantUri);

  var contextNodes = $(containerNode).search(selectors.join(', '));
  if (contextNodes) {
    contextNodes = Array.prototype.slice.call(contextNodes);
  } else {
    contextNodes = [];
  }

  // Pass it through the outside implementation, which might filter out
  // nodes from `contextNodes` and add more nodes to the match.
  return methods.getPlayingNodes(containerNode, contextNodes);
}

/**
 * Remove the playing state from the passed DOM node, as it's no longer playing.
 *
 * @param {HTMLElement} node The DOM node to remove state from.
 *
 * @private
 */
function removePlayingStateFromNode(node) {
  var className = [CURRENT, PAUSED, PLAYING].join(' ');
  node = $(node);
  node.removeClass(className).removeAttribute('data-playback-active');

  if (node.matches(SELECTOR_ALL_PLAY_BUTTONS)) {
    node.attribute('data-log-click', LOG_PLAY_BUTTON);
  }
}

/**
 * Add the playing state to the passed DOM node, as it's now playing.
 *
 * @param {HTMLElement} node The DOM node to add state to.
 *
 * @private
 */
function addPlayingStateToNode(node) {
  var isPlaying = methods.getPlayerIsPlaying();

  var classNames = [CURRENT, isPlaying ? PLAYING : PAUSED].join(' ');

  node = $(node);
  node.addClass(classNames).data('playback-active', true);

  if (node.matches(SELECTOR_ALL_PLAY_BUTTONS)) {
    node.attribute('data-log-click', isPlaying ? LOG_PAUSE_BUTTON : LOG_PLAY_BUTTON);
  }
}

/**
 * Update the playing state for the passed DOM node, as it's still representing
 * the currently playing context, but the player might switch between
 * playing/paused.
 *
 * @param {HTMLElement} node The DOM node to update state for.
 *
 * @private
 */
function updatePlayingStateForNode(node) {
  var isPlaying = methods.getPlayerIsPlaying();

  var currentClassName = isPlaying ? PAUSED : PLAYING;
  var newClassName = isPlaying ? PLAYING : PAUSED;
  var element = $(node);

  if (element.hasClass(currentClassName)) {
    element.removeClass(currentClassName);
  }

  if (!element.hasClass(newClassName)) {
    element.addClass(newClassName);
  }

  if (element.matches(SELECTOR_ALL_PLAY_BUTTONS)) {
    element.attribute('data-log-click', isPlaying ? LOG_PAUSE_BUTTON : LOG_PLAY_BUTTON);
  }
}

/**
 * Handle updating of DOM nodes when they have been added to the DOM by a scroll
 * agent.
 *
 * @param {Object} event Custom event object sent from the scroll agent. Should
 *     contain a `container` property pointing to the DOM node containing the
 *     rows.
 *
 * @private
 */
function handleScrollShowAfter(event) {
  var container = $(event.container);
  var contextNode = null;
  if (container.matches('[data-context]')) {
    contextNode = container;
  } else {
    contextNode = container.parent('[data-context]');
  }

  // We can't pass the context node itself as root because of how the playing
  // state queries are set up.
  var contextParent = contextNode && contextNode[0].parentElement || document;

  updateDOM(contextParent);
}

/**
 * Attach the needed event listeners for the module.
 */
exports.attach = function () {
  playerSubscription = methods.subscribeToPlayerChange(function () {
    updateDOM();
  });

  center.on('scroll-show-after', handleScrollShowAfter);
};

/**
 * Detach the needed event listeners for the module.
 */
exports.detach = function () {
  if (playerSubscription) {
    playerSubscription.cancel();
    playerSubscription = null;
  }

  for (var contextUri in playableChangeHandlers) {
    if (playableChangeHandlers.hasOwnProperty(contextUri)) {
      live(contextUri).off('update', playableChangeHandlers[contextUri]);
    }
  }
  playableChangeHandlers = {};

  center.off('scroll-show-after', handleScrollShowAfter);
};

/**
 * Update things in the DOM.
 */
exports.update = updateDOM;

/**
 * Set the external methods for this module to add implementations for methods
 * needed for highlighting playing objects.
 *
 * @param {Object} methodDefinitions Object where keys are method names and
 *     values are functions.
 */
exports.setMethods = function (methodDefinitions) {
  for (var name in methodDefinitions) {
    if (methodDefinitions.hasOwnProperty(name)) {
      methods[name] = methodDefinitions[name];
    }
  }
};

},{"../../spotify-elements":40,"../../spotify-live":118,"../center":44,"./utils":48,"mout/array/difference":195}],48:[function(require,module,exports){
(function (global){
'use strict';

/**
 * This module might be used by modules outside of spotify-events.
 * @public
 */

var liburi = require('spotify-liburi');
var $ = require('../../spotify-elements');

var getOriginUri = require('../../spotify-live-wrapped-uri').getOriginUri;

/**
 * Get the context URI from a button node or its parents.
 *
 * @param {HTMLElement} button A DOM node for a button.
 *
 * @return {string} The context URI or empty string if not found.
 */
function getUriFromButton(button) {
  var contextNode = button.closest('[data-context]');
  return contextNode && contextNode.getAttribute('data-uri') || '';
}

/**
 * Get the value for the passed attribute name, either from the passed node or
 * from any parent node.
 *
 * @param {HTMLElement} node The node to start searching from.
 * @param {string} attributeName The name of the attribute.
 *
 * @return {string} The value, or empty string if not found.
 */
function getAttributeValueFromNode(node, attributeName) {
  var selector = '[' + attributeName + ']';
  var attributeNode = node.closest(selector);
  return attributeNode && attributeNode.getAttribute(attributeName) || '';
}

/**
 * Check if the passed element is a form or link element.
 *
 * @param {HTMLElement} element A DOM node.
 *
 * @return {boolean} True if it is a form or link element.
 */
function isFormOrLinkElement(element) {
  var tagName = element.tagName.toLowerCase();
  var elements = ['input', 'textarea', 'button', 'select', 'optgroup', 'option', 'a'];
  return elements.indexOf(tagName) > -1;
}

/**
 * Check if the passed element is an interactive element (links, buttons).
 *
 * @param {HTMLElement}  element A DOM node.
 *
 * @return {boolean} True if the element is interactive.
 */
function isInteractiveElement(element) {
  var tagName = element.tagName.toLowerCase();
  return tagName === 'a' || tagName === 'button';
}

/**
 * Get a CSS selector string for a context.
 *
 * @param {string} operator A CSS selector operator ($= or similar).
 * @param {string} uri The context URI.
 *
 * @return {string} The CSS selector string.
 */
function getContextSelector(operator, uri) {
  return '[data-context][data-uri' + operator + uri + ']';
}

/**
 * Get an array of CSS selectors for searching for context nodes inside the DOM.
 *
 * @param {string} uri The context URI to search for. This should be the
 *     currently playing variant URI (for example, when playing a sorted
 *     playlist the sorted URI should be passed).
 *
 * @return {Array.<string>} Array of CSS selector strings.
 */
function getContextSelectors(uri) {
  var ENDSWITH = '$=';
  var SAME = '=';

  var selectors = [getContextSelector(SAME, uri)];

  var normalized = normalizeUri(uri);
  if (uri !== normalized) {
    selectors.push(getContextSelector(SAME, normalized));
  }

  return selectors;
}

/**
 * Get an array of CSS selectors for searching for context nodes inside the DOM.
 * This also includes any variant of the passed context URI. For example, if
 * passing a sorted playlist URI, it will return selectors for matching all
 * variations of that playlist URI, including the regular playlist URI, filtered
 * URI etc.
 *
 * @param {string} uri The context URI to search for. This can be either the
 *     origin URI, or any variant URI. The function will convert it to the
 *     origin URI automatically.
 *
 * @return {Array.<string>} Array of CSS selector strings.
 */
function getContextSelectorsWithVariants(uri) {
  var ENDSWITH = '$=';
  var SAME = '=';

  // Only add the ENDSWITH selectors. Those also match the original.
  // When it's a sorted and/or filtered list, just use the origin.
  var endsWith = getOriginUri(uri) || uri;
  var endsWithNormalized = normalizeUri(endsWith);

  var selectors = [getContextSelector(ENDSWITH, endsWith.replace(/^spotify:/, ':'))];

  if (endsWith !== endsWithNormalized) {
    selectors.push(getContextSelector(ENDSWITH, endsWithNormalized.replace(/^spotify:/, ':')));
  }

  return selectors;
}

/**
 * Check if two context URIs are representing the same context. This will take
 * care of normalizing the casing of URL encoding and filtered/sorted contexts.
 *
 * @param {string} context1 The first context.
 * @param {string} context2 The second context.
 *
 * @return {boolean} True if they represent the same context.
 */
function compareContexts(context1, context2) {
  if (!context1 || !context2) return false;

  context1 = normalizeUri(getOriginUri(context1) || context1);
  context2 = normalizeUri(getOriginUri(context2) || context2);

  return context1 === context2;
}

/**
 * A URI might contain URL encoded characters, and per spec the URL encoding can
 * be either in lowercase or uppercase (should be treated as same URL). If the
 * input URL has lowercase encoding, liburi will convert it into uppercase
 * encoding.
 *
 * @param {string} uri The URI to normalize.
 *
 * @return {string} The normalized URI.
 */
function normalizeUri(uri) {
  var uriObj = liburi.from(uri);
  var normalized = uriObj ? uriObj.toString() : uri;

  // Work around incorrect handling of `spotify:internal:...` URIs by liburi,
  // since it does not recognize `internal` URIs, and therefore uses the default
  // `app` type.
  normalized = normalized.replace(/^spotify:app:internal:/, 'spotify:internal:');

  // Work around the bad conversion of spaces in filtered list URIs. The URI
  // spec we use says that spaces should be encoded as `+`, but the `filterlist`
  // URI uses the regular `%20` encoding for spaces. Passing it through liburi
  // converts it to `+`, so we need to convert it back to `%20` again.
  normalized = normalized.replace(/:internal:filterlist:[^:]+/, function (match) {
    return match.replace(/\+/g, '%20');
  });

  return normalized;
}

/**
 * Create an empty method that will only log a warning when called.
 *
 * @param {string} methodName The name of the method to warn about.
 *
 * @return {Function} The function.
 */
function createEmptyMethod(methodName) {
  return function () {
    if (global.console) {
      console.warn('spotify-events/player: `' + methodName + '` is not implemented.');
    }
  };
}

exports.getUriFromButton = getUriFromButton;
exports.getAttributeValueFromNode = getAttributeValueFromNode;
exports.isFormOrLinkElement = isFormOrLinkElement;
exports.isInteractiveElement = isInteractiveElement;
exports.getContextSelector = getContextSelector;
exports.getContextSelectors = getContextSelectors;
exports.getContextSelectorsWithVariants = getContextSelectorsWithVariants;
exports.compareContexts = compareContexts;
exports.normalizeUri = normalizeUri;
exports.createEmptyMethod = createEmptyMethod;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../spotify-elements":40,"../../spotify-live-wrapped-uri":117,"spotify-liburi":256}],49:[function(require,module,exports){
'use strict';

/**
 * @private
 */

var live = require('../../spotify-live');
var Range = require('../../spotify-range2');
var $ = require('../../spotify-elements');
var find = require('mout/array/find');

var playerActions = require('./actions');
var playerUpdates = require('./updates');
var utils = require('./utils');

var isAttached = false;

exports.attach = function () {
  if (isAttached) return;
  isAttached = true;

  playerActions.setMethods({
    getPlayerVariantUri: getPlayerVariantUri,
    handlePlayButton: handlePlayButton,
    handlePlayFromRow: handlePlayFromRow
  });

  playerUpdates.setMethods({
    getPlayerVariantUri: getPlayerVariantUri,
    getPlayerIsPlaying: getPlayerIsPlaying,
    getPlayingNodes: getPlayingNodes,
    subscribeToPlayerChange: subscribeToPlayerChange
  });

  playerActions.attach();
  playerUpdates.attach();
};

exports.detach = function () {
  if (!isAttached) return;
  isAttached = false;

  playerActions.detach();
  playerUpdates.detach();
};

exports.update = function (optNode) {
  if (!isAttached) return;

  playerUpdates.update(optNode);
};

/**
 * Get the variant URI for the currently playing context. For example, if
 * playing a sorted playlist, this should return the sorted URI.
 *
 * @return {string} The context variant URI, or empty string if nothing is
 *     playing.
 */
function getPlayerVariantUri() {
  var variant = live('spotify:player').get('variant');
  return variant ? variant.uri : '';
}

/**
 * Get the index of the currently playing track within the playing context.
 *
 * @return {number} The index, or -1 if not found.
 */
function getPlayerIndex() {
  var indexObject = live('spotify:player').get('index');
  return indexObject ? indexObject.get('track') : -1;
}

/**
 * Get the URI of the currently playing track.
 *
 * @return {string} The track URI, or empty string if nothing is playing.
 */
function getPlayerTrackUri() {
  var track = live('spotify:player').get('track');
  return track && track.uri || '';
}

/**
 * Get the playing status of the player.
 *
 * @return {boolean} True if the player is currently playing audio.
 */
function getPlayerIsPlaying() {
  var isPlaying = live('spotify:player').get('isPlaying');
  var isPaused = live('spotify:player').get('isPaused');
  return isPlaying && !isPaused;
}

/**
 * Get whether the player is currently shuffling the context.
 *
 * @return {boolean} True if shuffling.
 */
function getPlayerIsShuffling() {
  var options = live('spotify:player').get('options');
  var shufflingContext = options && options.get('shufflingContext');
  return !!shufflingContext;
}

/**
 * Subscribe to player changes.
 *
 * @param {Function} handler A handler function. The data passed to this
 *     function is irrelevent, only the fact that something changed is needed.
 *
 * @return {Object} An object with a `cancel` method to cancel the subscription.
 */
function subscribeToPlayerChange(handler) {
  live('spotify:player').on('update', handler);
  var active = true;
  return {
    cancel: function cancel() {
      if (active) {
        live('spotify:player').off('update', handler);
        active = false;
      }
    }
  };
}

/**
 * Handle the click of a play button.
 * This function should decide what the action should be, and pause/resume
 * playback or start playback of a new context.
 *
 * @param {HTMLElement} buttonNode A button DOM node.
 * @param {Object} data Object of data about the action:
 *     isPlayingContext: (boolean) Whether the button looks to be representing
 *         the currently playing context.
 *     contextUri: (string) The context URI for the button.
 *     source: (string) The 'play source' value, for logging purposes.
 *     reason: (string) The 'play reason' value, for logging purposes.
 */
function handlePlayButton(buttonNode, data) {
  var button = $(buttonNode);
  var playerIndex = getPlayerIndex();
  var range;
  var newIndex;
  var uids;
  var uris;

  var dataRange = button.data('range');
  if (dataRange) {
    range = Range.fromString(dataRange);
    var list = live(data.contextUri).get('rows');
    if (list) {
      var indices = range.toIndices();
      uids = indices.map(function (index) {
        return list.keys[index];
      });
      uris = indices.map(function (index) {
        var track = list.get(index).get('track');
        return track.uri;
      });
    }
    newIndex = null;
  } else {
    var contextIndexNode = null;
    if (button.matches('[data-context-index]')) {
      contextIndexNode = button;
    } else {
      contextIndexNode = button.parent('[data-context-index]');
    }

    if (contextIndexNode) {
      newIndex = parseInt(contextIndexNode.data('context-index'), 10);
      var list = live(data.contextUri).get('rows');
      if (list) {
        uids = [list.keys[newIndex]];
        uris = [list.get(newIndex).get('track').uri];
      }
    } else {
      newIndex = null;
    }
  }

  var shouldPauseResume = false;

  if (data.isPlayingContext) {
    if (range) {
      // null or undefined
      if (playerIndex == null) {
        shouldPauseResume = false;
      } else {
        shouldPauseResume = range.contains(new Range(playerIndex, playerIndex + 1));
      }
    } else if (newIndex != null) {
      shouldPauseResume = newIndex === playerIndex;
    } else {
      shouldPauseResume = true;
    }
  }

  if (shouldPauseResume) {
    if (getPlayerIsPlaying()) {
      live('spotify:player').emit('pause');
    } else {
      live('spotify:player').emit('resume');
    }
  } else {
    var eventData = {
      context: data.contextUri,
      index: newIndex,
      source: data.source,
      reason: data.reason
    };

    if (range) {
      eventData.range = [range.start, range.end];
    }

    if (uids) {
      eventData.uids = uids;
    }

    if (uris) {
      eventData.uris = uris;
    }

    live('spotify:player').emit('play', eventData);
  }
}

/**
 * Handle playing a list row. This function should start playback of a context
 * starting from a specific row.
 *
 * @param {HTMLElement} rowNode A DOM node for a list row.
 * @param {Object} data Object of data about the action:
 *     contextUri: (string) The context URI for the list.
 *     source: (string) The 'play source' value, for logging purposes.
 *     reason: (string) The 'play reason' value, for logging purposes.
 */
function handlePlayFromRow(rowNode, data) {
  var index = parseInt(rowNode.getAttribute('data-context-index'), 10);
  if (isNaN(index)) {
    index = -1;
  }
  var uid = rowNode.getAttribute('data-uid') || '';
  var uri = rowNode.getAttribute('data-uri') || '';

  var eventData = {
    context: data.contextUri,
    index: index,
    source: data.source,
    reason: data.reason
  };

  if (uid) {
    eventData.uids = [uid];
  }

  if (uri) {
    eventData.uris = [uri];
  }

  live('spotify:player').emit('play', eventData);
}

/**
 * Get the nodes inside the passed container node that should be marked as
 * playing.
 *
 * @param {HTMLElement} containerNode The DOM node to search inside.
 * @param {Array.<HTMLElement>} contextNodes Array of DOM nodes that are already
 *     matched based on context URIs. These can be filtered if needed, but
 *     otherwise they should be included in the return value.
 *
 * @return {Array.<HTMLElement>} An array of DOM nodes.
 */
function getPlayingNodes(containerNode, contextNodes) {
  var playerIndex = getPlayerIndex();
  var playerTrackUri = getPlayerTrackUri();
  var variantUri = getPlayerVariantUri();

  // Remove any matched context nodes that have a range specified and where
  // the current player index does not match.
  var filteredContextNodes = filterRanges(playerIndex, contextNodes);

  var selectors = utils.getContextSelectors(variantUri);
  var selectorsWithVariants = utils.getContextSelectorsWithVariants(variantUri);

  var rowNodes = getContextNodesForRows(containerNode, selectors, playerIndex, playerTrackUri) || [];

  var rangeNodes = getContextNodesForRanges(containerNode, selectorsWithVariants, playerIndex) || [];

  var buttonNodes = [];
  if (contextNodes.length) {
    buttonNodes = $(contextNodes).search('[data-button=play-context]');
  }

  // Let `elements` remove any duplicate nodes
  var nodes = $([filteredContextNodes, rowNodes, rangeNodes, buttonNodes]);

  return nodes ? Array.prototype.slice.call(nodes) : [];
}

/**
 * Get the nodes inside the passed container node that match what's currently
 * playing and are list rows.
 *
 * @param {HTMLElement} containerNode The DOM node to search inside.
 * @param {Array.<string>} selectors Array of CSS selectors for matching the
 *     currently playing context.
 * @param {number} index The currently playing index.
 * @param {string} trackUri The URI of the currently playing track.
 *
 * @return {Array.<HTMLElement>} Array of DOM nodes.
 */
function getContextNodesForRows(containerNode, selectors, index, trackUri) {
  var isShuffling = getPlayerIsShuffling();

  // When playing from this client, we highlight the playing index if the
  // playing variant and the list variant are exactly the same.
  //
  // Removed support for connect as we can no longer detect a connect session: KM-9645.

  var useIndexSelector = !isShuffling;
  var useTrackSelector = !!trackUri;

  var selector = selectors.map(function (selector) {
    if (useIndexSelector || useTrackSelector) selector += ' ';
    if (useIndexSelector) selector += '[data-context-index=' + index + ']';
    if (useTrackSelector) selector += '[data-uri="' + trackUri + '"]';
    return selector;
  }).join(', ');

  var nodes = selector && $(containerNode).search(selector);
  if (nodes) {
    nodes = Array.prototype.slice.call(nodes);

    if (isShuffling) {
      // As the lax matching used in this case might yield duplicate rows in a
      // single list, we must filter out those.
      nodes = nodes.filter(function (row, i) {
        var listNode = $(row).parent('[data-list]');
        // If this row is not the first row to be highlighted in this list,
        // filter it out.
        return row === find(nodes, function (row) {
          return listNode === $(row).parent('[data-list]');
        });
      });
    }
  } else {
    nodes = [];
  }

  return nodes;
}

/**
 * Get the nodes inside the passed container node that match what's currently
 * playing and have a matching range specified.
 *
 * @param {HTMLElement} containerNode The DOM node to search inside.
 * @param {Array.<string>} selectors Array of CSS selectors for matching the
 *     currently playing context.
 * @param {number} index The currently playing index.
 *
 * @return {Array.<HTMLElement>} Array of DOM nodes.
 */
function getContextNodesForRanges(containerNode, selectors, index) {
  var rangeAttribute = '[data-range]';

  // It needs to search for all range elements somewhere inside an element
  // marked up as a context, as well as range elements that themselves are
  // contexts.
  selectors = selectors.map(function (selector) {
    var rangeInContextSelector = selector + ' ' + rangeAttribute;
    var rangedContextSelector = selector + rangeAttribute;
    var rangeSelector = rangeInContextSelector + ', ' + rangedContextSelector;
    return rangeSelector;
  });

  var rangeNodes = $(containerNode).search(selectors.join(', '));
  if (rangeNodes) {
    rangeNodes = Array.prototype.slice.call(rangeNodes);
  } else {
    rangeNodes = [];
  }

  return filterRanges(index, rangeNodes);
}

/**
 * Return a new array of nodes where nodes that specify a range that doesn't
 * match the currently playing index are removed.
 *
 * @param {number=} index The currently playing index. Can be undefined/null.
 * @param {Array.<HTMLElement>} nodes Array of DOM nodes.
 *
 * @return {Array.<HTMLElement>} Array of DOM nodes.
 */
function filterRanges(index, nodes) {
  var thisRange = index != null ? new Range(index, index + 1) : null;

  return nodes.filter(function (node) {
    node = $(node);
    var range = node.data('range');

    // Node without a range should always be active
    if (!range) return true;

    // If player has no index, but the node has a range, we can't be sure if
    // it's playing
    if (!thisRange) return false;

    range = Range.fromString(range);
    return range.contains(thisRange);
  });
}

},{"../../spotify-elements":40,"../../spotify-live":118,"../../spotify-range2":150,"./actions":45,"./updates":47,"./utils":48,"mout/array/find":198}],50:[function(require,module,exports){
'use strict';

var live = require('../../spotify-live');
var Range = require('../../spotify-range2');
var $ = require('../../spotify-elements');

var playerActions = require('./actions');
var playerUpdates = require('./updates');
var utils = require('./utils');

var isAttached = false;

exports.attach = function () {
  if (isAttached) return;
  isAttached = true;

  playerActions.setMethods({
    getPlayerVariantUri: getPlayerVariantUri,
    handlePlayButton: handlePlayButton,
    handlePlayFromRow: handlePlayFromRow
  });

  playerUpdates.setMethods({
    getPlayerVariantUri: getPlayerVariantUri,
    getPlayerIsPlaying: getPlayerIsPlaying,
    getPlayingNodes: getPlayingNodes,
    subscribeToPlayerChange: subscribeToPlayerChange
  });

  playerActions.attach();
  playerUpdates.attach();
};

exports.detach = function () {
  if (!isAttached) return;
  isAttached = false;

  playerActions.detach();
  playerUpdates.detach();
};

exports.update = function (optNode) {
  if (!isAttached) return;

  playerUpdates.update(optNode);
};

/**
 * Get the variant URI for the currently playing context. For example, if
 * playing a sorted playlist, this should return the sorted URI.
 *
 * @return {string} The context variant URI, or empty string if nothing is
 *     playing.
 */
function getPlayerVariantUri() {
  var variant = live('spotify:player').get('variant');
  return variant ? variant.uri : '';
}

/**
 * Get the index of the currently playing page.
 *
 * @return {number} The page index, or -1 if not found.
 */
function getPlayerPageIndex() {
  var indexObject = live('spotify:player').get('index');
  var pageIndex = indexObject && indexObject.get('page');
  var hasPageIndex = typeof pageIndex === 'number';
  return hasPageIndex ? pageIndex : -1;
}

/**
 * Get the UID of the currently playing track.
 *
 * @return {string} The UID, or empty string if not found.
 */
function getPlayerTrackUid() {
  return live('spotify:player').get('uid') || '';
}

/**
 * Get the uri of the currently playing track.
 *
 * @return {string} The uri, or empty string if not found.
 */
function getPlayerTrackUri() {
  var track = live('spotify:player').get('track');
  return track ? track.get('uri') || '' : '';
}

/**
 * Get the URI of the currently playing track.
 *
 * @return {string} The track URI, or empty string if nothing is playing.
 */
function getPlayerTrackUri() {
  var track = live('spotify:player').get('track');
  return track && track.uri || '';
}

/**
 * Get the playing status of the player.
 *
 * @return {boolean} True if the player is currently playing audio.
 */
function getPlayerIsPlaying() {
  var isPlaying = live('spotify:player').get('isPlaying');
  var isPaused = live('spotify:player').get('isPaused');
  return isPlaying && !isPaused;
}

/**
 * Get whether the playback was initiated from open.spotify.com
 *
 * This info is needed to be able to do a best-effort of highlighting rows when
 * playing from open.
 *
 * @return {boolean} True if playing from open.spotify.com.
 */
function getPlayerIsPlayingFromOpen() {
  var playOrigin = live('spotify:player').get('playOrigin');
  var externalReferrer = playOrigin && playOrigin.get('externalReferrer');

  return externalReferrer && externalReferrer.indexOf('https://open.spotify.com/') === 0;
}

/**
 * Subscribe to player changes.
 *
 * @param {Function} handler A handler function. The data passed to this
 *     function is irrelevent, only the fact that something changed is needed.
 *
 * @return {Object} An object with a `cancel` method to cancel the subscription.
 */
function subscribeToPlayerChange(handler) {
  live('spotify:player').on('update', handler);
  var active = true;
  return {
    cancel: function cancel() {
      if (active) {
        live('spotify:player').off('update', handler);
        active = false;
      }
    }
  };
}

/**
 * Handle the click of a play button.
 * This function should decide what the action should be, and pause/resume
 * playback or start playback of a new context.
 *
 * @param {HTMLElement} buttonNode A button DOM node.
 * @param {Object} data Object of data about the action:
 *     isPlayingContext: (boolean) Whether the button looks to be representing
 *         the currently playing context.
 *     contextUri: (string) The context URI for the button.
 *     source: (string) The 'play source' value, for logging purposes.
 *     reason: (string) The 'play reason' value, for logging purposes.
 */
function handlePlayButton(buttonNode, data) {
  var isPlaying = data.isPlayingContext;

  var button = $(buttonNode);

  var trackUid = utils.getAttributeValueFromNode(buttonNode, 'data-uid');
  var trackUri = utils.getAttributeValueFromNode(buttonNode, 'data-track-uri');
  var pageIndex = parseInt(utils.getAttributeValueFromNode(buttonNode, 'data-context-page'), 10);

  if (isPlaying) {
    isPlaying = verifyIsPlayingIndex(trackUid, trackUri, pageIndex);
  }

  if (isPlaying) {
    if (getPlayerIsPlaying()) {
      live('spotify:player').emit('pause');
    } else {
      live('spotify:player').emit('resume');
    }
  } else {

    var eventData = {
      context: data.contextUri,
      source: data.source,
      reason: data.reason
    };

    if (trackUid) {
      eventData.uid = trackUid;
    }

    if (trackUri) {
      eventData.trackUri = trackUri;
    }

    if (!isNaN(pageIndex)) {
      eventData.page = pageIndex;
    }

    live('spotify:player').emit('play', eventData);
  }
}

/**
 * Verify that a uid, uri or pageIndex is playing, or that just the context
 * is playing when none of that is set.
 * This is used when we already know that we're playing the context.
 *
 * @param {string} trackUid
 * @param {string} trackUri
 * @param {number} pageIndex
 *
 * @return {boolean} True if it's really playing
 */
function verifyIsPlayingIndex(trackUid, trackUri, pageIndex) {
  if (trackUid) {
    var playerTrackUid = getPlayerTrackUid();
    return playerTrackUid === trackUid;
  }

  if (trackUri) {
    var playerTrackUri = getPlayerTrackUri();
    return playerTrackUri === trackUri;
  }

  if (!isNaN(pageIndex)) {
    var playerPageIndex = getPlayerPageIndex();
    return playerPageIndex === pageIndex;
  }

  // No index given also means it's really playing.
  return true;
}

/**
 * Handle playing a list row. This function should start playback of a context
 * starting from a specific row.
 *
 * @param {HTMLElement} rowNode A DOM node for a list row.
 * @param {Object} data Object of data about the action:
 *     contextUri: (string) The context URI for the list.
 *     source: (string) The 'play source' value, for logging purposes.
 *     reason: (string) The 'play reason' value, for logging purposes.
 */
function handlePlayFromRow(rowNode, data) {
  var eventData = {
    context: data.contextUri,
    source: data.source,
    reason: data.reason
  };

  var uid = rowNode.getAttribute('data-uid');
  if (uid) {
    eventData.uid = uid;
  }

  var pageIndex = parseInt(utils.getAttributeValueFromNode(rowNode, 'data-context-page'), 10);
  if (!isNaN(pageIndex)) {
    eventData.page = pageIndex;
  }

  live('spotify:player').emit('play', eventData);
}

/**
 * Get the nodes inside the passed container node that should be marked as
 * playing.
 *
 * @param {HTMLElement} containerNode The DOM node to search inside.
 * @param {Array.<HTMLElement>} contextNodes Array of DOM nodes that are already
 *     matched based on context URIs. These can be filtered if needed, but
 *     otherwise they should be included in the return value.
 *
 * @return {Array.<HTMLElement>} An array of DOM nodes.
 */
function getPlayingNodes(containerNode, contextNodes) {
  var playerPageIndex = getPlayerPageIndex();
  var playerTrackUid = getPlayerTrackUid();
  var playerTrackUri = getPlayerTrackUri();
  var variantUri = getPlayerVariantUri();

  // Remove any matched context nodes that have a page specified and where
  // the current player page does not match.
  var filteredContextNodes = filterPages(playerPageIndex, contextNodes);

  var selectors = utils.getContextSelectors(variantUri);
  var rowNodes = getContextNodesForRows(containerNode, selectors, playerTrackUid, playerTrackUri) || [];

  var selectorsWithVariants = utils.getContextSelectorsWithVariants(variantUri);
  var pageNodes = getContextNodesForPages(containerNode, selectorsWithVariants, playerPageIndex) || [];

  var buttonNodes = [];
  if (contextNodes.length) {
    buttonNodes = $(contextNodes).search('[data-button=play-context]');
  }

  // Let `elements` remove any duplicate nodes
  var nodes = $([filteredContextNodes, rowNodes, pageNodes, buttonNodes]);

  return nodes ? Array.prototype.slice.call(nodes) : [];
}

/**
 * Get the nodes inside the passed container node that match what's currently
 * playing and are list rows.
 *
 * @param {HTMLElement} containerNode The DOM node to search inside.
 * @param {Array.<string>} selectors Array of CSS selectors for matching the
 *     currently playing context.
 * @param {string} trackUid The UID of the currently playing track.
 *
 * @return {Array.<HTMLElement>} Array of DOM nodes.
 */
function getContextNodesForRows(containerNode, selectors, trackUid, trackUri) {

  // When playing from this client, we highlight the playing UIDs.
  var useTrackSelector = getPlayerIsPlayingFromOpen();

  var selector = selectors.map(function (selector) {
    selector += ' ';
    if (useTrackSelector) selector += '[data-uri=' + trackUri + ']';
    if (!useTrackSelector) selector += '[data-uid=' + trackUid + ']';
    return selector;
  }).join(', ');

  var nodes = $(containerNode).search(selector);
  if (nodes) {
    nodes = Array.prototype.slice.call(nodes);

    if (useTrackSelector) {
      // Gets UID of the first node and find all the nodes
      // with the same UID
      var firstUid = $(nodes[0]).data('uid');
      nodes = nodes.filter(function (row, i) {
        return firstUid === $(row).data('uid');
      });
    }
  } else {
    nodes = [];
  }

  return nodes;
}

/**
 * Get the nodes inside the passed container node that match what's currently
 * playing and have a matching page specified.
 *
 * @param {HTMLElement} containerNode The DOM node to search inside.
 * @param {Array.<string>} selectors Array of CSS selectors for matching the
 *     currently playing context.
 * @param {number} playerPageIndex The currently playing page index.
 *
 * @return {Array.<HTMLElement>} Array of DOM nodes.
 */
function getContextNodesForPages(containerNode, selectors, playerPageIndex) {
  var pageAttribute = '[data-context-page]';

  // It needs to search for all range elements somewhere inside an element
  // marked up as a context, as well as range elements that themselves are
  // contexts.
  selectors = selectors.map(function (selector) {
    var pageInContextSelector = selector + ' ' + pageAttribute;
    var pagedContextSelector = selector + pageAttribute;
    var pageSelector = pageInContextSelector + ', ' + pagedContextSelector;
    return pageSelector;
  });

  var pageNodes = $(containerNode).search(selectors.join(', '));
  if (pageNodes) {
    pageNodes = Array.prototype.slice.call(pageNodes);
  } else {
    pageNodes = [];
  }

  return filterPages(playerPageIndex, pageNodes);
}

/**
 * Return a new array of nodes where nodes that specify a context page that
 * doesn't match the currently playing context page are removed.
 *
 * @param {number} playerPageIndex The currently playing page index.
 * @param {Array.<HTMLElement>} contextNodes Array of already matched nodes.
 *
 * @return {Array.<HTMLElement>} Array of filtered nodes.
 */
function filterPages(playerPageIndex, contextNodes) {
  return contextNodes.filter(function (node) {
    var nodePageIndex = parseInt(node.getAttribute('data-context-page'), 10);

    // Node without a page should always be active
    if (isNaN(nodePageIndex)) return true;

    // If player has no page, but the node has a page, we can't be sure if it's
    // playing.
    if (isNaN(playerPageIndex)) return false;

    // Node that matches the player page should be active
    return playerPageIndex === nodePageIndex;
  });
}

},{"../../spotify-elements":40,"../../spotify-live":118,"../../spotify-range2":150,"./actions":45,"./updates":47,"./utils":48}],51:[function(require,module,exports){
'use strict';

/**
 * Module for handling clicks on the scroll bar track to scroll pages.
 *
 * @private
 */

var BezierEasing = require('bezier-easing');

var config = require('./config');

module.exports = {

  // Called from outside
  setHandler: function setHandler(eventName, scroller, handler) {
    if (eventName === 'clickEnd') {
      scroller._clickEndHandler = handler;
    }
  },

  scrollTo: function scrollTo(scroller, newPosition, useEasing, callback) {
    var startPosition = scroller.view.scrollTop;
    var positionDiff = newPosition - startPosition;

    var startTimestamp = Date.now();
    var totalTime = config.scrollToTransitionMs;

    if (!useEasing) {
      totalTime = config.scrollToLinearTransitionMs;
    }

    // Ease in/out quadratic
    var easing = new BezierEasing(0.455, 0.03, 0.515, 0.955);

    var tick = function tick() {
      var elapsedTime = Date.now() - startTimestamp;
      var totalPercentage = elapsedTime / totalTime;

      var currentPercentage = useEasing ? easing.get(totalPercentage) : totalPercentage;

      scroller.view.scrollTop = startPosition + positionDiff * currentPercentage;

      if (totalPercentage < 1) {
        // Must use setTimeout to not make it flicker. Setting scrollTop in
        // requestAnimationFrame will make it scroll and in the next frame allow
        // the scroll handlers to move elements, making it look very flickery.
        setTimeout(tick, config.frameMs);
      } else {
        scroller.view.scrollTop = startPosition + positionDiff;
        scroller.isClickScrollAnimating = false;
        if (callback) {
          callback();
        }
      }
    };

    scroller.isClickScrollAnimating = true;
    setTimeout(tick, config.frameMs);
  },

  holdClick: function holdClick(scroller) {
    var targetThumbEdge = scroller.clickTargetThumbTop;
    var newPosition = this.getNextScrollValue(scroller);
    var newThumbTop = newPosition / scroller.viewScrollHeight * scroller.viewHeight;
    var newThumbBottom = newThumbTop + scroller.thumbHeight;
    var direction = scroller.clickTargetDirection;

    var isValid = false;
    if (direction === 'up' && newThumbBottom > targetThumbEdge) {
      isValid = true;
    } else if (direction === 'down' && newThumbTop < targetThumbEdge) {
      isValid = true;
    }

    if (isValid) {
      var useEasing = false;

      this.scrollTo(scroller, newPosition, useEasing, function () {
        if (scroller.isClickScrolling) {
          this.holdClick(scroller);
        }
      }.bind(this));
    }
  },

  getNextScrollValue: function getNextScrollValue(scroller) {
    var change = scroller.viewHeight * config.clickScrollDistanceFactor;

    if (scroller.clickTargetDirection === 'up') {
      return scroller.view.scrollTop - change;
    }

    return scroller.view.scrollTop + change;
  },

  setMovementData: function setMovementData(scroller, clientY) {
    var trackTop = scroller.scrollBarTrack.getBoundingClientRect().top;
    var targetThumbEdge = clientY - trackTop;
    var direction = targetThumbEdge < scroller.thumbTop ? 'up' : 'down';

    scroller.clickTargetDirection = direction;
    scroller.clickTargetThumbTop = targetThumbEdge;
  },

  onClickHold: function onClickHold(scroller) {
    scroller.isClickScrolling = true;

    this.holdClick(scroller);
  },

  onMouseMove: function onMouseMove(scroller, event) {
    if (scroller.isMouseOver && event.target === scroller.scrollBarTrack) {
      this.setMovementData(scroller, event.clientY);

      if (scroller.isClickScrolling && !scroller.isClickScrollAnimating) {
        this.holdClick(scroller);
      }
    }
  },

  onMouseUp: function onMouseUp(scroller) {
    scroller.isClickScrolling = false;

    clearTimeout(scroller.clickHoldTimer);

    this.removeHandlers(scroller);

    if (scroller._clickEndHandler) {
      scroller._clickEndHandler();
    }
  },

  onTrackMouseDown: function onTrackMouseDown(scroller, event) {
    var isVisible = scroller.isVisible;
    var isPrimaryButton = event.button === 0;
    var isTargetTrack = event.target === scroller.scrollBarTrack;

    if (isVisible && isPrimaryButton && isTargetTrack) {
      var navigator = window.navigator;
      var isMac = navigator && navigator.userAgent.indexOf('Mac') > -1;
      var isWindows = navigator && navigator.userAgent.indexOf('Windows') > -1;

      if (isMac && event.altKey || isWindows && event.shiftKey) {
        var trackTop = scroller.scrollBarTrack.getBoundingClientRect().top;
        var targetThumbCenter = event.clientY - trackTop;
        var targetThumbTop = Math.max(0, Math.min(scroller.viewHeight - scroller.thumbHeight, targetThumbCenter - scroller.thumbHeight / 2));

        scroller.view.scrollTop = targetThumbTop / (scroller.viewHeight - scroller.thumbHeight) * (scroller.viewScrollHeight - scroller.viewHeight);
      } else {
        this.setMovementData(scroller, event.clientY);

        var targetPosition = this.getNextScrollValue(scroller);
        var useEasing = true;

        this.scrollTo(scroller, targetPosition, useEasing);

        this.addHandlers(scroller);

        scroller.clickHoldTimer = setTimeout(this.onClickHold.bind(this, scroller), config.scrollToTransitionMs + config.clickHoldDelayMs);
      }
    }
  },

  addHandlers: function addHandlers(scroller) {
    scroller._click_onMouseUp = this.onMouseUp.bind(this, scroller);
    scroller._click_onMouseMove = this.onMouseMove.bind(this, scroller);

    document.addEventListener('mouseup', scroller._click_onMouseUp, false);
    document.addEventListener('mousemove', scroller._click_onMouseMove, false);
  },

  removeHandlers: function removeHandlers(scroller) {
    document.removeEventListener('mouseup', scroller._click_onMouseUp, false);
    document.removeEventListener('mousemove', scroller._click_onMouseMove, false);
  },

  attach: function attach(scroller) {
    var onTrackMouseDown = this.onTrackMouseDown.bind(this, scroller);

    scroller.scrollBarTrack.addEventListener('mousedown', onTrackMouseDown, false);

    return function () {
      scroller.scrollBarTrack.removeEventListener('mousedown', onTrackMouseDown, false);
    };
  }

};

},{"./config":52,"bezier-easing":153}],52:[function(require,module,exports){
"use strict";

/**
 * Config with all timer values etc. Easy to have them all in one place, and it
 * also helps for testing, since the config can be used from there too.
 *
 * @private
 */

module.exports = {
  hideAfterMs: 750,
  showAfterMs: 500,

  // Sync with CSS transition duration
  hideTransitionMs: 500,

  expandDelayMs: 150,

  frameMs: 16,
  scrollToTransitionMs: 200,
  scrollToLinearTransitionMs: 120,
  clickHoldDelayMs: 500,
  clickScrollDistanceFactor: 0.95
};

},{}],53:[function(require,module,exports){
'use strict';

/**
 * Module for handling dragging the scroll bar thumb to scroll.
 *
 * @private
 */

module.exports = {

  // Called from outside
  setHandler: function setHandler(eventName, scroller, handler) {
    if (eventName === 'dragStart') {
      scroller._dragStartHandler = handler;
    } else if (eventName === 'dragEnd') {
      scroller._dragEndHandler = handler;
    }
  },

  onThumbMouseDown: function onThumbMouseDown(scroller, event) {
    if (event.button === 0 && scroller.isVisible) {
      scroller.isDragging = true;
      scroller.startDragMouseY = event.clientY;
      scroller.startDragThumbTop = scroller.thumbTop;

      this.addDragHandlers(scroller);

      if (scroller._dragStartHandler) {
        scroller._dragStartHandler();
      }
    }
  },

  onMouseUp: function onMouseUp(scroller, event) {
    if (scroller.isDragging) {
      scroller.isDragging = false;

      this.removeDragHandlers(scroller);

      if (scroller._dragEndHandler) {
        scroller._dragEndHandler();
      }
    }
  },

  onMouseMove: function onMouseMove(scroller, event) {
    var y = event.clientY;
    var startY = scroller.startDragMouseY;

    scroller.thumbTop = Math.max(0, Math.min(scroller.viewHeight - scroller.thumbHeight, scroller.startDragThumbTop + y - startY));

    scroller.view.scrollTop = scroller.thumbTop / (scroller.viewHeight - scroller.thumbHeight) * (scroller.viewScrollHeight - scroller.viewHeight);
  },

  addDragHandlers: function addDragHandlers(scroller) {
    scroller._drag_onMouseMove = this.onMouseMove.bind(this, scroller);
    scroller._drag_onMouseUp = this.onMouseUp.bind(this, scroller);

    document.addEventListener('mousemove', scroller._drag_onMouseMove, false);
    document.addEventListener('mouseup', scroller._drag_onMouseUp, false);
  },

  removeDragHandlers: function removeDragHandlers(scroller) {
    document.removeEventListener('mousemove', scroller._drag_onMouseMove, false);
    document.removeEventListener('mouseup', scroller._drag_onMouseUp, false);
  },

  attach: function attach(scroller) {
    var onThumbMouseDown = this.onThumbMouseDown.bind(this, scroller);

    scroller.scrollBarThumb.addEventListener('mousedown', onThumbMouseDown, false);

    return function () {
      scroller.scrollBarThumb.removeEventListener('mousedown', onThumbMouseDown, false);
    };
  }

};

},{}],54:[function(require,module,exports){
'use strict';

/**
 * Module for handling expanding the scroll bar width on hover.
 *
 * @private
 */

var config = require('./config');

module.exports = {

  expand: function expand(scroller) {
    clearTimeout(scroller.resetExpandedTimer);
    scroller.scrollBarTrack.classList.add('expanded');
  },

  collapse: function collapse(scroller) {
    scroller.scrollBarTrack.classList.remove('expanded');
  },

  // Called from outside
  onHide: function onHide(scroller) {
    if (!scroller.alwaysVisible) {
      clearTimeout(scroller.expandTimer);
      clearTimeout(scroller.resetExpandedTimer);

      scroller.resetExpandedTimer = setTimeout(this.collapse.bind(this, scroller), config.hideTransitionMs);
    }
  },

  onTrackMouseEnter: function onTrackMouseEnter(scroller, event) {
    if (event.target === scroller.scrollBarTrack) {
      if (scroller.isVisible) {
        clearTimeout(scroller.expandTimer);
        clearTimeout(scroller.resetExpandedTimer);
        scroller.expandTimer = setTimeout(function () {
          this.expand(scroller);
        }.bind(this), config.expandDelayMs);
      } else {
        this.expand(scroller);
      }
    }
  },

  onTrackMouseLeave: function onTrackMouseLeave(scroller, event) {
    if (event.target === scroller.scrollBarTrack) {
      if (scroller.isVisible) {
        clearTimeout(scroller.expandTimer);
      } else {
        this.collapse(scroller);
      }
    }
  },

  attach: function attach(scroller) {
    if (scroller.alwaysVisible) {
      this.expand(scroller);

      return function () {};
    } else {
      this.collapse(scroller);

      var onTrackMouseEnter = this.onTrackMouseEnter.bind(this, scroller);
      var onTrackMouseLeave = this.onTrackMouseLeave.bind(this, scroller);

      scroller.scrollBarTrack.addEventListener('mouseenter', onTrackMouseEnter, false);
      scroller.scrollBarTrack.addEventListener('mouseleave', onTrackMouseLeave, false);

      return function () {
        scroller.scrollBarTrack.removeEventListener('mouseenter', onTrackMouseEnter, false);
        scroller.scrollBarTrack.removeEventListener('mouseleave', onTrackMouseLeave, false);
      };
    }
  }

};

},{"./config":52}],55:[function(require,module,exports){
'use strict';

var glue = require('../../spotify-glue-cat');
var cosmos = require('spotify-cosmos-api');

var center = require('../center');
var drag = require('./drag');
var visibility = require('./visibility');
var position = require('./position');
var expansion = require('./expansion');
var click = require('./click');

var scrollers = [];
var scrollerStyle = null;

function Scroller(scrollView) {
  this.view = scrollView;
  this.setInitialState();
  this.addScrollBar();
  this.refresh();

  this.view.setAttribute('data-scroll-area-initialized', '');

  this._onResize = function () {
    this.refresh();
  }.bind(this);
  this._onScroll = function () {
    this.refreshScrollBar();
  }.bind(this);
  this._onThumbDragStart = function (event) {
    event.preventDefault();
    event.stopPropagation();
  };

  // Listen for the scroll event to update view size etc on scroll
  var scrollObject = this.isBody ? window : this.view;
  scrollObject.addEventListener('scroll', this._onScroll, false);

  // Listen for the window resize event, even for scroll areas that are not the
  // body scroll. Since we can't listen for resize events when elements resize,
  // we do a best effort of at least updating when the window resizes (which
  // might affect the size of the scroll area).
  window.addEventListener('resize', this._onResize, false);

  // Prevent dragndrop handling from spotify-events (it will be triggered
  // otherwise since we have to set the draggable attribute to not trigger
  // focus events).
  this.scrollBarThumb.addEventListener('dragstart', this._onThumbDragStart, true);

  this._detachVisibility = visibility.attach(this);
  this._detachPosition = position.attach(this);
  this._detachDrag = drag.attach(this);
  this._detachClick = click.attach(this);
  this._detachExpansion = expansion.attach(this);

  visibility.setHandler('show', this, function () {
    this.refresh();
  }.bind(this));

  visibility.setHandler('hide', this, function () {
    expansion.onHide(this);
  }.bind(this));

  // Events are sent when dragging to allow some use cases where you need to do
  // something while dragging. For example, when dragging the scroll bar in the
  // app sidebar and hovering over the main view, it will not trigger mousemove
  // events since the main view is an iframe. To counter that, zlink is
  // listening to these events and sets pointer-events on the content area.
  drag.setHandler('dragStart', this, function () {
    center.emit('scroll-thumb-drag-start', { id: this.viewId });
  }.bind(this));
  drag.setHandler('dragEnd', this, function () {
    visibility.onDragEnd(this);
    center.emit('scroll-thumb-drag-end', { id: this.viewId });
  }.bind(this));

  click.setHandler('clickEnd', this, function () {
    visibility.onClickEnd(this);
  }.bind(this));
}

Scroller.prototype.setInitialState = function () {
  var scrollerStyleToUse = scrollerStyle || window.__spotify.scroller_style;
  this.alwaysVisible = scrollerStyleToUse === 'always';

  this.scrollBarTrack = null;
  this.scrollBarThumb = null;

  this.isBody = this.view === document.body;
  this.viewId = this.view.getAttribute('data-scroll-area');
  this.viewHeight = 0;
  this.viewScrollHeight = 0;

  this.isVisible = false;
  this.isDragging = false;
  this.isMouseOver = false;
  this.isClickScrolling = false;
  this.isClickScrollAnimating = false;

  this.thumbTop = 0;
  this.thumbHeight = 0;

  this.clickTargetDirection = 'down';
  this.clickTargetThumbTop = 0;

  this.startDragMouseY = 0;
  this.startDragThumbTop = 0;

  this.hideTimer = 0;
  this.mouseOverShowTimer = 0;
};

Scroller.prototype.addScrollBar = function () {
  var track = document.createElement('div');
  var thumb = document.createElement('div');

  track.className = 'scrollbar-track';
  thumb.className = 'scrollbar-thumb';

  if (this.alwaysVisible) {
    track.className += ' always-visible';
  }

  // If the thumb is not set to draggable it will trigger focus events on
  // elements being dragged over. For example, dragging the thumb up to the
  // search input puts focus in the search input, which opens the suggest box.
  // Since we will find this element from the dragndrop module, we also need to
  // prevent any drag handling (find the drag listener further down).
  thumb.setAttribute('draggable', 'true');

  track.appendChild(thumb);
  this.view.appendChild(track);

  this.scrollBarTrack = track;
  this.scrollBarThumb = thumb;
};

Scroller.prototype.setViewSize = function () {
  // Hide the scroll bar while calculating sizes, so the scroll bar doesn't
  // interfere. This can happen if scrolled to the bottom of the scroll view and
  // the scroll height changes to be smaller. If the scroll bar is not hidden
  // while calculating the values here, the scrollHeight will not change, since
  // the scroll bar is taking up space.
  this.scrollBarTrack.style.display = 'none';

  if (this.isBody) {
    this.viewHeight = window.innerHeight || Infinity;
  } else {
    this.viewHeight = this.view.clientHeight || Infinity;
  }

  this.viewScrollHeight = this.view.scrollHeight;

  this.scrollBarTrack.style.display = 'block';
};

Scroller.prototype.setThumbSize = function () {
  var percentage = this.viewHeight / this.viewScrollHeight;
  this.thumbHeight = Math.max(40, this.viewHeight * percentage);
  this.scrollBarThumb.style.height = this.thumbHeight + 'px';
};

Scroller.prototype.setTrackPosition = function () {
  this.scrollBarTrack.style.transform = 'translate3d(0, ' + (this.view.scrollTop + 'px') + ', 0)';
};

Scroller.prototype.refresh = function () {
  this.refreshView();
  this.refreshScrollBar();
};

Scroller.prototype.refreshView = function () {
  this.setViewSize();
};

Scroller.prototype.refreshScrollBar = function () {
  this.setThumbSize();

  if (!this.isBody) {
    this.setTrackPosition();
  }
};

Scroller.prototype.update = function () {
  var oldViewHeight = this.viewHeight;
  var oldScrollHeight = this.viewScrollHeight;

  this.refresh();

  visibility.update(this);

  var newViewHeight = this.viewHeight;
  var newScrollHeight = this.viewScrollHeight;

  if (newViewHeight !== oldViewHeight || newScrollHeight !== oldScrollHeight) {
    visibility.highlight(this);
  }
};

Scroller.prototype.setScrollBarMode = function (mode) {
  this.alwaysVisible = mode === 'always';

  if (this.alwaysVisible) {
    this.scrollBarTrack.classList.add('always-visible');
  } else {
    this.scrollBarTrack.classList.remove('always-visible');
  }

  this._detachVisibility();
  this._detachPosition();
  this._detachDrag();
  this._detachClick();
  this._detachExpansion();

  this._detachVisibility = visibility.attach(this);
  this._detachPosition = position.attach(this);
  this._detachDrag = drag.attach(this);
  this._detachClick = click.attach(this);
  this._detachExpansion = expansion.attach(this);
};

Scroller.prototype.isInDOM = function () {
  var currentNode = this.view.parentNode;
  while (currentNode && currentNode !== document.documentElement) {
    currentNode = currentNode.parentNode;
  }

  // If we still have a current node after the loop, we found the document
  // element, which means it's in DOM.
  return !!currentNode;
};

Scroller.prototype.destroy = function () {
  var scrollObject = this.isBody ? window : this.view;

  scrollObject.removeEventListener('scroll', this._onScroll, false);

  window.removeEventListener('resize', this._onResize, false);

  this.scrollBarThumb.removeEventListener('dragstart', this._onThumbDragStart, true);

  this.view.removeAttribute('data-scroll-area-initialized', '');
  this.view.removeChild(this.scrollBarTrack);

  this._detachVisibility();
  this._detachPosition();
  this._detachDrag();
  this._detachClick();
  this._detachExpansion();
};

var isAttached = false;
var controlMessageSubscription;

exports.update = function (node) {
  if (!isAttached) {
    return;
  }

  // Clean up scrollers that are not in DOM anymore.
  scrollers = scrollers.filter(function (scroller) {
    if (!scroller.isInDOM()) {
      scroller.destroy();
      return false;
    }
    return true;
  });

  // Update all active scrollers
  for (var i = 0, l = scrollers.length; i < l; i++) {
    scrollers[i].update();
  }

  var selector = '[data-scroll-area]';
  var scrollViews = (node || document).querySelectorAll(selector);

  for (var i = 0, l = scrollViews.length; i < l; i++) {
    if (!scrollViews[i].hasAttribute('data-scroll-area-initialized')) {
      var scrollView = scrollViews[i];
      var isBody = scrollView === document.body;

      if (isBody && glue.getVersion() !== 2) {
        continue;
      }

      scrollers.push(new Scroller(scrollView));
    }
  }
};

exports.attach = function () {
  if (isAttached) return;
  isAttached = true;

  var setScrollBarMode = function setScrollBarMode(mode) {
    scrollerStyle = mode;

    for (var i = 0, l = scrollers.length; i < l; i++) {
      scrollers[i].setScrollBarMode(mode);
    }
  };

  controlMessageSubscription = cosmos.resolver.subscribe({
    url: 'sp://messages/v1/container/control'
  }, function (error, response) {
    if (!error) {
      var data = response.getJSONBody();
      if (data) {
        var styleWasChanged = true;
        switch (data.type) {
          case 'set_scroller_style_always_visible':
            setScrollBarMode('always');
            break;
          case 'set_scroller_style_overlay':
            setScrollBarMode('overlay');
            break;
          default:
            styleWasChanged = false;
        }

        // Fix a rendering bug in Chromium. When scroller style changes in the
        // system (changing system preference, connecting/disconnecting a mouse
        // etc), Chromium will render a white area where the scroll bar is
        // supposed to be. By adding and removing a class name we're triggering
        // a re-render and it will look good.
        //
        // https://jira.spotify.net/browse/KM-8285
        // http://crbug.com/538579
        if (styleWasChanged) {
          var performFix = function performFix() {
            var nodes = scrollers.map(function (scroller) {
              return scroller.view;
            });

            // Always include body to fix the main scroll, even if it doesn't
            // have a custom scroll bar.
            if (nodes.indexOf(document.body) === -1) {
              nodes.push(document.body);
            }

            for (var i = 0, l = nodes.length; i < l; i++) {
              nodes[i].classList.add('jmeBDLRW3CRWW3kZZaZ');
              nodes[i].classList.remove('jmeBDLRW3CRWW3kZZaZ');
            }
          };

          // Perform the fix twice (once with a delay), since it sometimes might
          // be slow and won't apply the fix on the first try.
          performFix();
          setTimeout(performFix, 1000);
        }
      }
    } else {
      controlMessageSubscription.cancel();
    }
  });
};

exports.detach = function () {
  if (!isAttached) return;
  isAttached = false;

  for (var i = 0, l = scrollers.length; i < l; i++) {
    scrollers[i].destroy();
  }
  scrollers.length = 0;

  scrollerStyle = null;

  if (controlMessageSubscription) {
    controlMessageSubscription.cancel();
    controlMessageSubscription = null;
  }
};

},{"../../spotify-glue-cat":81,"../center":44,"./click":51,"./drag":53,"./expansion":54,"./position":56,"./visibility":57,"spotify-cosmos-api":246}],56:[function(require,module,exports){
'use strict';

/**
 * Module for handling updating the scroll bar thumb position when scroll
 * position changes.
 *
 * @private
 */

module.exports = {

  setThumbPosition: function setThumbPosition(scroller) {
    if (scroller.viewScrollHeight === scroller.viewHeight) {
      scroller.thumbTop = 0;
    } else {
      scroller.thumbTop = scroller.view.scrollTop / (scroller.viewScrollHeight - scroller.viewHeight) * (scroller.viewHeight - scroller.thumbHeight);
    }

    scroller.scrollBarThumb.style.transform = 'translate3d(0, ' + (scroller.thumbTop + 'px') + ', 0)';
  },

  onScroll: function onScroll(scroller) {
    this.setThumbPosition(scroller);
  },

  attach: function attach(scroller) {
    var onScroll = this.onScroll.bind(this, scroller);

    var scrollObject = scroller.isBody ? window : scroller.view;
    scrollObject.addEventListener('scroll', onScroll, false);

    this.setThumbPosition(scroller);

    return function () {
      scrollObject.removeEventListener('scroll', onScroll, false);
    };
  }

};

},{}],57:[function(require,module,exports){
'use strict';

/**
 * Module for handling the visibility of the scroll bar, based on mouse position
 * and scroll events.
 *
 * @private
 */

var config = require('./config');

module.exports = {

  // Called from outside
  setHandler: function setHandler(eventName, scroller, handler) {
    if (eventName === 'show') {
      scroller._showHandler = handler;
    } else if (eventName === 'hide') {
      scroller._hideHandler = handler;
    }
  },

  refresh: function refresh(scroller) {
    if (scroller.viewScrollHeight > scroller.viewHeight) {
      this.showScrollBar(scroller);
    } else {
      this.hideScrollBar(scroller);
    }
  },

  showScrollBar: function showScrollBar(scroller) {
    if (scroller.isVisible) {
      return;
    }

    if (scroller.viewScrollHeight > scroller.viewHeight) {
      scroller.scrollBarTrack.classList.add('visible');
      scroller.isVisible = true;

      if (scroller._showHandler) {
        scroller._showHandler();
      }
    }
  },

  hideScrollBar: function hideScrollBar(scroller) {
    if (!scroller.isVisible || scroller.isDragging) {
      return;
    }

    scroller.scrollBarTrack.classList.remove('visible');
    scroller.isVisible = false;

    if (scroller._hideHandler) {
      scroller._hideHandler();
    }
  },

  startHideTimer: function startHideTimer(scroller) {
    this.stopHideTimer(scroller);
    scroller.hideTimer = setTimeout(this.hideScrollBar.bind(this, scroller), config.hideAfterMs);
  },

  stopHideTimer: function stopHideTimer(scroller) {
    clearTimeout(scroller.hideTimer);
  },

  // Called from outside
  onDragEnd: function onDragEnd(scroller) {
    if (!scroller.alwaysVisible && !scroller.isMouseOver) {
      this.startHideTimer(scroller);
    }
  },

  // Called from outside
  onClickEnd: function onClickEnd(scroller) {
    if (!scroller.alwaysVisible && !scroller.isMouseOver) {
      this.startHideTimer(scroller);
    }
  },

  onScroll: function onScroll(scroller) {
    if (!scroller.isVisible) {
      this.showScrollBar(scroller);
    }

    if (!scroller.isDragging && !scroller.isClickScrolling && !scroller.isMouseOver) {
      this.startHideTimer(scroller);
    }
  },

  onTrackMouseEnter: function onTrackMouseEnter(scroller, event) {
    if (event.target === scroller.scrollBarTrack) {
      scroller.isMouseOver = true;

      this.stopHideTimer(scroller);

      if (!scroller.isVisible) {
        scroller.mouseOverShowTimer = setTimeout(this.showScrollBar.bind(this, scroller), config.showAfterMs);
      }
    }
  },

  onTrackMouseLeave: function onTrackMouseLeave(scroller, event) {
    if (event.target === scroller.scrollBarTrack) {
      scroller.isMouseOver = false;

      if (!scroller.isDragging && !scroller.isClickScrolling) {
        clearTimeout(scroller.mouseOverShowTimer);

        if (scroller.isVisible) {
          this.startHideTimer(scroller);
        }
      }
    }
  },

  attach: function attach(scroller) {
    if (scroller.alwaysVisible) {
      this.refresh(scroller);

      return function () {};
    } else {
      this.hideScrollBar(scroller);

      var onScroll = this.onScroll.bind(this, scroller);
      var onTrackMouseEnter = this.onTrackMouseEnter.bind(this, scroller);
      var onTrackMouseLeave = this.onTrackMouseLeave.bind(this, scroller);

      var scrollObject = scroller.isBody ? window : scroller.view;
      scrollObject.addEventListener('scroll', onScroll, false);

      scroller.scrollBarTrack.addEventListener('mouseenter', onTrackMouseEnter, false);
      scroller.scrollBarTrack.addEventListener('mouseleave', onTrackMouseLeave, false);

      return function () {
        scrollObject.removeEventListener('scroll', onScroll, false);

        scroller.scrollBarTrack.removeEventListener('mouseenter', onTrackMouseEnter, false);
        scroller.scrollBarTrack.removeEventListener('mouseleave', onTrackMouseLeave, false);
      };
    }
  },

  update: function update(scroller) {
    if (scroller.alwaysVisible) {
      this.refresh(scroller);
    }
  },

  highlight: function highlight(scroller) {
    if (!scroller.alwaysVisible && !scroller.isVisible) {
      this.showScrollBar(scroller);
      this.startHideTimer(scroller);
    }
  }

};

},{"./config":52}],58:[function(require,module,exports){
(function (global){
'use strict';

exports.init = function () {
  require('./expose-debug-global').expose(global, 'bridge', require('../spotify-bridge-request'));
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-bridge-request":34,"./expose-debug-global":60}],59:[function(require,module,exports){
(function (global){
'use strict';

exports.init = function () {
  require('./expose-debug-global').expose(global, 'cosmos', require('spotify-cosmos-api'));
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./expose-debug-global":60,"spotify-cosmos-api":246}],60:[function(require,module,exports){
'use strict';

exports.expose = function (global, name, object) {
  if (global.__spotify && global.__spotify.developer_mode) {
    Object.defineProperty(global, name, {
      get: function get() {
        try {
          throw new Error();
        } catch (error) {
          if (!/injectedscript/i.test(error.stack)) {
            throw new Error('window.' + name + ' should only be accessed from the console');
          }
        }
        return object;
      },
      enumerable: true,
      configurable: true
    });
  }
};

},{}],61:[function(require,module,exports){
(function (global){
'use strict';

exports.init = function () {
  require('./expose-debug-global').expose(global, 'live', require('../spotify-live'));
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-live":118,"./expose-debug-global":60}],62:[function(require,module,exports){
module.exports = {
  "Album": "Album",
  "AndMore": "und {0} weitere",
  "Artist": "Künstler",
  "By": "von",
  "Create Similar Playlist": "Ähnliche Playlist erstellen",
  "Filter": "Filter",
  "Follow": "Folgen",
  "Follower": "Follower",
  "FollowersLabel": "Followers",
  "Following": "Folge ich",
  "FollowingLabel": "Folge ich",
  "ListenersLabel": "Monatliche Hörer",
  "FollowsYou": "Folgt dir",
  "HoldToPreview": "Zum Reinhören gedrückt halten",
  "ListenCount": "{0} Mal abgespielt",
  "ListenReactionMulti": "{0} Hörer in Deinem Netzwerk",
  "ListenReactionSingle": "{0} hört sich das an",
  "LocalFile": "Lokale Datei",
  "More": "Mehr",
  "Pause": "Pause",
  "Play": "Play",
  "Playlist": "Playlist",
  "PressEnterToPlay": "Drück die Eingabetaste zum Abspielen",
  "Popularity": "Beliebtheit",
  "Remove": "Entfernen",
  "RemoveYourMusic": "Aus \"Deine Musik\" entfernen",
  "Save": "Speichern",
  "SaveYourMusic": "In \"Deine Musik\" speichern",
  "Saved": "Gespeichert",
  "ShufflePlay": "Shuffle",
  "Song": "Song",
  "StartRadio": "Radio starten",
  "Time": "Dauer",
  "Toplist": "Top-Songs",
  "Track": "Song",
  "Unfollow": "Nicht mehr folgen",
  "User": "Benutzer",
  "ViewAll": "Mehr Darstellung",
  "HoursShort": "{0} Std.",
  "MinutesShort": "{0} Min.",
  "SecondsShort": "{0} Sek.",
  "ErrorTitle": "Bei der Anzeige dieser Ansicht ist ein Fehler aufgetreten!",
  "ErrorMessage": "Diese Ansicht ist entweder nicht vorhanden oder es ist ein Fehler aufgetreten.",
  "OfflineTitle": "Diese Ansicht ist offline nicht verfügbar.",
  "OfflineMessage": "Geh zum Laden online."
};
},{}],63:[function(require,module,exports){
module.exports = {
  "Album": "Άλμπουμ",
  "AndMore": "και άλλοι {0}",
  "Artist": "Καλλιτέχνης",
  "By": "από",
  "Create Similar Playlist": "Δημιουργία παρόμοιας playlist",
  "Filter": "Φίλτρο",
  "Follow": "Ακολούθησε",
  "Follower": "Οπαδός",
  "FollowersLabel": "Οπαδοί",
  "Following": "Aκολουθείται",
  "FollowingLabel": "Aκολουθείται",
  "ListenersLabel": "Μηνιαίοι ακροατές",
  "FollowsYou": "Σε ακολουθεί",
  "HoldToPreview": "Πάτησε και κράτησε πατημένο για προεπισκόπηση",
  "ListenCount": "{0} αναπαραγωγές",
  "ListenReactionMulti": "{0} ακροατές στο δίκτυό σου",
  "ListenReactionSingle": "Ο χρήστης {0} ακούει αυτό",
  "LocalFile": "Τοπικό αρχείο",
  "More": "Περισσότερα",
  "Pause": "Παύση",
  "Play": "Αναπαραγωγή",
  "Playlist": "Λίστα",
  "PressEnterToPlay": "Πάτησε Enter για αναπαραγωγή",
  "Popularity": "Δημοφιλία",
  "Remove": "Αφαίρεση",
  "RemoveYourMusic": "Αφαίρεση από τη Mουσική σου",
  "Save": "Αποθήκευση",
  "SaveYourMusic": "Αποθήκευση στη Mουσική σου",
  "Saved": "Αποθηκεύτηκε",
  "ShufflePlay": "Τυχαία αναπαραγωγή",
  "Song": "Τραγούδι",
  "StartRadio": "Έναρξη ραδιοφώνου",
  "Time": "Διάρκεια",
  "Toplist": "Κορυφαία τραγούδια",
  "Track": "Τραγούδι",
  "Unfollow": "Άρση ακολούθησης",
  "User": "Χρήστης",
  "ViewAll": "Δες τα όλα",
  "HoursShort": "{0} ώρα",
  "MinutesShort": "{0} λεπ.",
  "SecondsShort": "{0} δευτ.",
  "ErrorTitle": "Προέκυψε σφάλμα κατά την προβολή αυτής της οθόνης!",
  "ErrorMessage": "Η συγκεκριμένη προβολή δεν υπάρχει ή προέκυψε κάποιο σφάλμα.",
  "OfflineTitle": "Αυτή η προβολή δεν είναι διαθέσιμη εκτός σύνδεσης!",
  "OfflineMessage": "Συνδέσου στο διαδίκτυο για να πραγματοποιηθεί φόρτωση."
};
},{}],64:[function(require,module,exports){
module.exports = {
  "Album": "Album",
  "AndMore": "and {0} more",
  "Artist": "Artist",
  "By": "by",
  "Create Similar Playlist": "Create Similar Playlist",
  "Filter": "Filter",
  "Follow": "Follow",
  "Follower": "Follower",
  "FollowersLabel": "Followers",
  "Following": "Following",
  "FollowingLabel": "Following",
  "ListenersLabel": "Monthly Listeners",
  "FollowsYou": "Follows You",
  "HoldToPreview": "Click and Hold to Preview",
  "ListenCount": "{0} plays",
  "ListenReactionMulti": "{0} listeners in your network",
  "ListenReactionSingle": "{0} listens to this",
  "LocalFile": "Local File",
  "More": "More",
  "Pause": "Pause",
  "Play": "Play",
  "Playlist": "Playlist",
  "PressEnterToPlay": "Press Enter to play",
  "Popularity": "Popularity",
  "Remove": "Remove",
  "RemoveYourMusic": "Remove from Your Music",
  "Save": "Save",
  "SaveYourMusic": "Save to Your Music",
  "Saved": "Saved",
  "ShufflePlay": "Shuffle Play",
  "Song": "Song",
  "StartRadio": "Start Radio",
  "Time": "Time",
  "Toplist": "Top songs",
  "Track": "Song",
  "Unfollow": "Unfollow",
  "User": "User",
  "ViewAll": "View All",
  "HoursShort": "{0} hr",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} sec",
  "ErrorTitle": "There was a problem displaying this view!",
  "ErrorMessage": "This view either does not exist or an error occurred.",
  "OfflineTitle": "This view is not available offline!",
  "OfflineMessage": "Please go online to load."
}
;
},{}],65:[function(require,module,exports){
module.exports = {
  "Album": "Álbum",
  "AndMore": "y {0} más",
  "Artist": "Artista",
  "By": "por",
  "Create Similar Playlist": "Crear playlist similar",
  "Filter": "Filtrar",
  "Follow": "Seguir",
  "Follower": "Seguidor",
  "FollowersLabel": "Seguidores",
  "Following": "Siguiendo",
  "FollowingLabel": "Siguiendo",
  "ListenersLabel": "Oyentes mensuales",
  "FollowsYou": "Te sigue",
  "HoldToPreview": "Haz clic y mantén pulsado para oír la muestra preliminar",
  "ListenCount": "{0} reproducciones",
  "ListenReactionMulti": "{0} oyentes en tu red",
  "ListenReactionSingle": "{0} escucha esto",
  "LocalFile": "Archivo local",
  "More": "Más",
  "Pause": "Pausa",
  "Play": "Reproducir",
  "Playlist": "Lista",
  "PressEnterToPlay": "Presiona Enter para reproducir",
  "Popularity": "Popularidad",
  "Remove": "Eliminar",
  "RemoveYourMusic": "Eliminar de Tu Música",
  "Save": "Guardar",
  "SaveYourMusic": "Guardar en Tu Música",
  "Saved": "Guardado",
  "ShufflePlay": "Aleatoria",
  "Song": "Canción",
  "StartRadio": "Comenzar Radio",
  "Time": "Tiempo",
  "Toplist": "Canciones más reproducidas",
  "Track": "Canción",
  "Unfollow": "Dejar de seguir",
  "User": "Usuario",
  "ViewAll": "Ver todos",
  "HoursShort": "{0} hr",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} seg",
  "ErrorTitle": "Hubo un problema al mostrar esta vista.",
  "ErrorMessage": "Puede ser que esta vista no exista, o bien, que haya ocurrido un error.",
  "OfflineTitle": "Esta vista no está disponible sin conexión. ",
  "OfflineMessage": "Conéctate a la red para cargar."
};
},{}],66:[function(require,module,exports){
module.exports = {
  "Album": "Álbum",
  "AndMore": "y {0} más",
  "Artist": "Artista",
  "By": "por",
  "Create Similar Playlist": "Crear playlist similar",
  "Filter": "Filtrar",
  "Follow": "Seguir",
  "Follower": "Seguidor",
  "FollowersLabel": "Seguidores",
  "Following": "Siguiendo",
  "FollowingLabel": "Siguiendo",
  "ListenersLabel": "Oyentes mensuales",
  "FollowsYou": "Te sigue",
  "HoldToPreview": "Pulsa y mantén pulsado para oír la muestra preliminar",
  "ListenCount": "{0} reproducciones",
  "ListenReactionMulti": "{0} oyentes en tu red",
  "ListenReactionSingle": "{0} escucha esto",
  "LocalFile": "Archivo local",
  "More": "Más",
  "Pause": "Pausar",
  "Play": "Reproducir",
  "Playlist": "Lista",
  "PressEnterToPlay": "Pulsa Intro para reproducir",
  "Popularity": "Popularidad",
  "Remove": "Retirar",
  "RemoveYourMusic": "Eliminar de Tu música",
  "Save": "Guardar",
  "SaveYourMusic": "Guardar en Tu música",
  "Saved": "Guardada",
  "ShufflePlay": "Aleatoria",
  "Song": "Canción",
  "StartRadio": "Comenzar radio",
  "Time": "Tiempo",
  "Toplist": "Canciones más escuchadas",
  "Track": "Canción",
  "Unfollow": "Dejar de seguir",
  "User": "Usuario",
  "ViewAll": "Ver todos",
  "HoursShort": "{0} hr",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} seg",
  "ErrorTitle": "Se ha producido un problema al mostrar esta vista.",
  "ErrorMessage": "Esta vista no existe o se ha producido un error.",
  "OfflineTitle": "Esta vista no está disponible sin conexión. ",
  "OfflineMessage": "Por favor, conéctate para cargar."
};
},{}],67:[function(require,module,exports){
module.exports = {
  "Album": "Albumi",
  "AndMore": "ja {0} muuta",
  "Artist": "Artisti",
  "By": "tekijältä",
  "Create Similar Playlist": "Luo samankaltainen soittolista",
  "Filter": "Suodatin",
  "Follow": "Seuraa",
  "Follower": "Seuraaja",
  "FollowersLabel": "Seuraajat",
  "Following": "Seurataan",
  "FollowingLabel": "Seurataan",
  "ListenersLabel": "Kuuntelijat kuukauden aikana",
  "FollowsYou": "Seuraa sinua",
  "HoldToPreview": "Kuuntele pätkä pitämällä tätä painettuna",
  "ListenCount": "{0} toistoa",
  "ListenReactionMulti": "{0} kuuntelijaa verkostossasi",
  "ListenReactionSingle": "{0} kuuntelee tätä",
  "LocalFile": "Paikallinen tiedosto",
  "More": "Lisää",
  "Pause": "Tauko",
  "Play": "Toista",
  "Playlist": "Soittolista",
  "PressEnterToPlay": "Toista painamalla Enter-näppäintä",
  "Popularity": "Suosio",
  "Remove": "Poista",
  "RemoveYourMusic": "Poista Omasta musiikista",
  "Save": "Tallenna",
  "SaveYourMusic": "Tallenna Omaan musiikkiin",
  "Saved": "Tallennettu",
  "ShufflePlay": "Satunnaistoisto",
  "Song": "Kappale",
  "StartRadio": "Käynnistä radio",
  "Time": "Kesto",
  "Toplist": "Suosituimmat kappaleet",
  "Track": "Kappale",
  "Unfollow": "Lopeta seuraaminen",
  "User": "Käyttäjä",
  "ViewAll": "Näytä kaikki",
  "HoursShort": "{0} h",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} s",
  "ErrorTitle": "Tämän näkymän näyttämisessä on ongelmia.",
  "ErrorMessage": "Tätä näkymää ei ole, tai tapahtui virhe.",
  "OfflineTitle": "Tätä näkymää ei voi käyttää offline-tilassa!",
  "OfflineMessage": "Siirry online-tilaan, jotta voit ladata."
};
},{}],68:[function(require,module,exports){
module.exports = {
  "Album": "Album",
  "AndMore": "et {0} autres",
  "Artist": "Artiste",
  "By": "par",
  "Create Similar Playlist": "Créer une liste de lecture semblable",
  "Filter": "Filtrer",
  "Follow": "Suivre",
  "Follower": "Abonné",
  "FollowersLabel": "Abonné",
  "Following": "Suivis",
  "FollowingLabel": "Suivis",
  "ListenersLabel": "Auditeurs mensuels",
  "FollowsYou": "Vous suit",
  "HoldToPreview": "Cliquez longuement pour avoir un aperçu",
  "ListenCount": "{0} écoutes",
  "ListenReactionMulti": "{0} auditeurs dans votre réseau",
  "ListenReactionSingle": "{0} écoute ceci",
  "LocalFile": "Fichier local",
  "More": "Plus",
  "Pause": "Pause",
  "Play": "Lecture",
  "Playlist": "Playlist",
  "PressEnterToPlay": "Appuyez sur Entrée pour faire la lecture",
  "Popularity": "Popularité",
  "Remove": "Supprimer",
  "RemoveYourMusic": "Supprimer de Votre musique",
  "Save": "Sauvegarder",
  "SaveYourMusic": "Enregistrer dans Votre musique",
  "Saved": "Sauvegardé",
  "ShufflePlay": "Lecture aléatoire",
  "Song": "Titre",
  "StartRadio": "Lancer la radio",
  "Time": "Durée",
  "Toplist": "Meilleures chansons",
  "Track": "Titre",
  "Unfollow": "Ne plus suivre",
  "User": "Utilisateur",
  "ViewAll": "Voir tout",
  "HoursShort": "{0} h",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} s",
  "ErrorTitle": "Un problème est survenu lors du chargement de cet affichage!",
  "ErrorMessage": "L'affichage n'existe pas ou une erreur s'est produite.",
  "OfflineTitle": "Cette vue n'est pas disponible hors ligne!",
  "OfflineMessage": "Veuillez accéder à Internet pour charger le contenu."
};
},{}],69:[function(require,module,exports){
module.exports = {
  "Album": "Album",
  "AndMore": "et {0} autres",
  "Artist": "Artiste",
  "By": "par",
  "Create Similar Playlist": "Créer une playlist similaire",
  "Filter": "Filtre",
  "Follow": "S'abonner",
  "Follower": "Abonné",
  "FollowersLabel": "Abonnés",
  "Following": "Abonné",
  "FollowingLabel": "Abonné",
  "ListenersLabel": "Nombres de personnes qui écoutent par mois",
  "FollowsYou": "Est abonné à vous",
  "HoldToPreview": "Cliquez longuement pour avoir un aperçu",
  "ListenCount": "{0} écoutes",
  "ListenReactionMulti": "{0} auditeurs dans votre réseau",
  "ListenReactionSingle": "{0} écoute ceci.",
  "LocalFile": "Fichier local",
  "More": "Plus",
  "Pause": "Pause",
  "Play": "Lire",
  "Playlist": "Playlist",
  "PressEnterToPlay": "Appuyez sur Entrée pour écouter",
  "Popularity": "Popularité",
  "Remove": "Supprimer",
  "RemoveYourMusic": "Supprimer de Ma musique",
  "Save": "Sauvegarder",
  "SaveYourMusic": "Sauvegarder dans Ma musique",
  "Saved": "Sauvegardé",
  "ShufflePlay": "Aléatoire",
  "Song": "Titre",
  "StartRadio": "Ecouter la radio",
  "Time": "Durée",
  "Toplist": "Top titres",
  "Track": "Titre",
  "Unfollow": "Se désabonner",
  "User": "Utilisateur",
  "ViewAll": "Présentation tout",
  "HoursShort": "{0} h",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} s",
  "ErrorTitle": "Problème d'affichage !",
  "ErrorMessage": "Cet affichage n'existe pas ou une erreur s'est produite.",
  "OfflineTitle": "Cet affichage n'est pas disponible hors connexion.",
  "OfflineMessage": "Connectez-vous pour procéder au chargement."
};
},{}],70:[function(require,module,exports){
module.exports = {
  "Album": "Album",
  "AndMore": "és még {0} felhasználó",
  "Artist": "Előadó",
  "By": "tőle:",
  "Create Similar Playlist": "Hasonló műsorlista létrehozása",
  "Filter": "Szűrő",
  "Follow": "Követés",
  "Follower": "Követő",
  "FollowersLabel": "Követők",
  "Following": "Követések",
  "FollowingLabel": "Követések",
  "ListenersLabel": "Hallgatók havonta",
  "FollowsYou": "Téged követ",
  "HoldToPreview": "Tartsd nyomva a belehallgatáshoz",
  "ListenCount": "{0} lejátszás",
  "ListenReactionMulti": "{0} ismerősöd hallgatta meg",
  "ListenReactionSingle": "{0} már meghallgatta",
  "LocalFile": "Helyi fájl",
  "More": "Több",
  "Pause": "Szünet",
  "Play": "Lejátszás",
  "Playlist": "Lejátszási lista",
  "PressEnterToPlay": "Lejátszás az Enterrel",
  "Popularity": "Népszerűség",
  "Remove": "Eltávolítás",
  "RemoveYourMusic": "Törlés a Zenéid közül",
  "Save": "Mentés",
  "SaveYourMusic": "Mentés a Zenéid közé",
  "Saved": "Mentett",
  "ShufflePlay": "Lejátszás keverve",
  "Song": "Dal",
  "StartRadio": "Rádió bekapcsolása",
  "Time": "Idő",
  "Toplist": "Toplista",
  "Track": "Dal",
  "Unfollow": "Nem követem",
  "User": "Felhasználó",
  "ViewAll": "Mindent mutat",
  "HoursShort": "{0} óra",
  "MinutesShort": "{0} perc",
  "SecondsShort": "{0} mp",
  "ErrorTitle": "Egy hiba miatt nem jeleníthető meg ez az oldal",
  "ErrorMessage": "A kért nézet nem létezik, vagy valamilyen műszaki hiba történt.",
  "OfflineTitle": "Ez a nézet internetkapcsolat nélkül nem érhető el.",
  "OfflineMessage": "Csatlakozz az internethez, majd indítsd el."
};
},{}],71:[function(require,module,exports){
module.exports = {
  "Album": "Album",
  "AndMore": "dan {0} lagi",
  "Artist": "Artis",
  "By": "menurut",
  "Create Similar Playlist": "Buat Playlist Serupa",
  "Filter": "Filter",
  "Follow": "Ikuti",
  "Follower": "Pengikut",
  "FollowersLabel": "Pengikut",
  "Following": "Mengikuti",
  "FollowingLabel": "Mengikuti",
  "ListenersLabel": "Pendengar Bulanan",
  "FollowsYou": "Mengikutimu",
  "HoldToPreview": "Klik dan Tahan untuk Pratinjau",
  "ListenCount": "{0} permainan",
  "ListenReactionMulti": "{0} pendengar di jaringanmu",
  "ListenReactionSingle": "{0} mendengarkan ini",
  "LocalFile": "File Lokal",
  "More": "Lainnya",
  "Pause": "Jeda",
  "Play": "Play",
  "Playlist": "Playlist",
  "PressEnterToPlay": "Tekan Enter untuk memainkan",
  "Popularity": "Popularitas",
  "Remove": "Hapus",
  "RemoveYourMusic": "Hapus dari Musik Kamu",
  "Save": "Simpan",
  "SaveYourMusic": "Simpan ke Musik Kamu",
  "Saved": "Tersimpan",
  "ShufflePlay": "Pemutaran Acak",
  "Song": "Lagu",
  "StartRadio": "Mulai Radio",
  "Time": "Waktu",
  "Toplist": "Lagu teratas",
  "Track": "Lagu",
  "Unfollow": "Berhenti mengikuti",
  "User": "Pengguna",
  "ViewAll": "Lihat Semua",
  "HoursShort": "{0} jam",
  "MinutesShort": "{0} mnt",
  "SecondsShort": "{0} dtk",
  "ErrorTitle": "Ada masalah saat menampilkan tampilan ini!",
  "ErrorMessage": "Tampilan ini tidak ada atau terjadi kesalahan.",
  "OfflineTitle": "Tampilan ini tidak tersedia offline.",
  "OfflineMessage": "Alihkan ke online untuk memuat."
};
},{}],72:[function(require,module,exports){
module.exports = {
  "Album": "Album",
  "AndMore": "e altri {0}",
  "Artist": "Artista",
  "By": "per",
  "Create Similar Playlist": "Crea playlist simile",
  "Filter": "Filtra",
  "Follow": "Segui",
  "Follower": "Follower",
  "FollowersLabel": "Follower",
  "Following": "Following",
  "FollowingLabel": "Following",
  "ListenersLabel": "Ascoltatori questo mese",
  "FollowsYou": "Ti segue",
  "HoldToPreview": "Tieni premuto per un'anteprima",
  "ListenCount": "{0} riproduzioni",
  "ListenReactionMulti": "{0} ascoltatori nella tua rete",
  "ListenReactionSingle": "{0} ascolta questo",
  "LocalFile": "File locale",
  "More": "Più",
  "Pause": "Pausa",
  "Play": "Play",
  "Playlist": "Playlist",
  "PressEnterToPlay": "Premi Invio per riprodurre",
  "Popularity": "Popolarità",
  "Remove": "Rimuovi",
  "RemoveYourMusic": "Elimina da La tua musica",
  "Save": "Salva",
  "SaveYourMusic": "Salva in La tua musica",
  "Saved": "Salvato",
  "ShufflePlay": "Riproduzione shuffle",
  "Song": "Brano",
  "StartRadio": "Crea una radio",
  "Time": "Durata",
  "Toplist": "Brani top",
  "Track": "Brano",
  "Unfollow": "Non seguire più",
  "User": "Utente",
  "ViewAll": "Visualizza tutto",
  "HoursShort": "{0} ore",
  "MinutesShort": "{0} min.",
  "SecondsShort": "{0} sec",
  "ErrorTitle": "Si è verificato un errore in questa vista.",
  "ErrorMessage": "La vista non esiste o si è verificato un errore.",
  "OfflineTitle": "Questa vista non è disponibile offline.",
  "OfflineMessage": "Passa online per caricare."
};
},{}],73:[function(require,module,exports){
module.exports = {
  "Album": "アルバム",
  "AndMore": "その他{0}人",
  "Artist": "アーティスト",
  "By": "/",
  "Create Similar Playlist": "同様のプレイリストを作成",
  "Filter": "フィルタ",
  "Follow": "フォロー",
  "Follower": "フォロワー",
  "FollowersLabel": "フォロワー",
  "Following": "フォロー中",
  "FollowingLabel": "フォロー中",
  "ListenersLabel": "今月のリスナー",
  "FollowsYou": "あなたをフォローしています",
  "HoldToPreview": "プレビューするには、クリックを押しします",
  "ListenCount": "{0}回再生",
  "ListenReactionMulti": "ネットワーク内で{0}人が聴いています",
  "ListenReactionSingle": "{0}さんはこれを聴いています",
  "LocalFile": "ローカルファイル",
  "More": "詳細",
  "Pause": "一時停止",
  "Play": "再生",
  "Playlist": "プレイリスト",
  "PressEnterToPlay": "再生するにはEnterキーを押します",
  "Popularity": "人気",
  "Remove": "削除",
  "RemoveYourMusic": "My Musicから削除",
  "Save": "保存",
  "SaveYourMusic": "My Musicに保存",
  "Saved": "保存済み",
  "ShufflePlay": "シャッフルプレイ",
  "Song": "ソング",
  "StartRadio": "Radioを開始",
  "Time": "時間",
  "Toplist": "トップ曲",
  "Track": "ソング",
  "Unfollow": "フォローをやめる",
  "User": "ユーザー",
  "ViewAll": "すべて表示",
  "HoursShort": "{0} 時間",
  "MinutesShort": "{0} 分",
  "SecondsShort": "{0} 秒",
  "ErrorTitle": "このビューを表示しようとしているときに問題が発生しました。",
  "ErrorMessage": "このビューが存在しないか、エラーが発生しました。",
  "OfflineTitle": "このビューはオフラインでは使用できません。",
  "OfflineMessage": "ロードするには、インターネットに接続してください。"
};
},{}],74:[function(require,module,exports){
module.exports = {
  "Album": "Album",
  "AndMore": "en {0} meer",
  "Artist": "Artiest",
  "By": "van",
  "Create Similar Playlist": "Vergelijkbare afspeellijst maken",
  "Filter": "Filter",
  "Follow": "Volgen",
  "Follower": "Volger",
  "FollowersLabel": "Volgers",
  "Following": "Volgend",
  "FollowingLabel": "Volgend",
  "ListenersLabel": "Luisteraars per maand",
  "FollowsYou": "Volgt jou",
  "HoldToPreview": "Klikken en vasthouden om een stukje te horen",
  "ListenCount": "{0} keer afgespeeld",
  "ListenReactionMulti": "{0} luisteraars in jouw netwerk",
  "ListenReactionSingle": "{0} luistert hiernaar",
  "LocalFile": "Lokaal bestand",
  "More": "Meer",
  "Pause": "Pauze",
  "Play": "Afspelen",
  "Playlist": "Afspeellijst",
  "PressEnterToPlay": "Druk op Enter om af te spelen",
  "Popularity": "Populariteit",
  "Remove": "Verwijderen",
  "RemoveYourMusic": "Verwijderen uit Jouw Muziek",
  "Save": "Opslaan",
  "SaveYourMusic": "Opslaan in Jouw Muziek",
  "Saved": "Opgeslagen",
  "ShufflePlay": "Shuffle",
  "Song": "Nummer",
  "StartRadio": "Radio starten",
  "Time": "Tijd",
  "Toplist": "Topnummers",
  "Track": "Nummer",
  "Unfollow": "Niet meer volgen",
  "User": "Gebruiker",
  "ViewAll": "Alles bekijken",
  "HoursShort": "{0} uur",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} sec",
  "ErrorTitle": "Er is een fout opgetreden bij het laden van deze weergave.",
  "ErrorMessage": "Deze weergave bestaat niet of er is een fout opgetreden.",
  "OfflineTitle": "Deze weergave is offline niet beschikbaar!",
  "OfflineMessage": "Ga online om te laden."
};
},{}],75:[function(require,module,exports){
module.exports = {
  "Album": "Album",
  "AndMore": "i {0} więcej",
  "Artist": "Wykonawca",
  "By": "według",
  "Create Similar Playlist": "Utwórz podobną playlistę",
  "Filter": "Filtruj",
  "Follow": "Obserwuj",
  "Follower": "Obserwujący",
  "FollowersLabel": "Obserwatorzy",
  "Following": "Obserwowana",
  "FollowingLabel": "Obserwowana",
  "ListenersLabel": "Słuchacze w tym miesiącu",
  "FollowsYou": "Obserwuje Cię",
  "HoldToPreview": "Aby odsłuchać, kliknij i przytrzymaj.",
  "ListenCount": "Liczba odtworzeń: {0}",
  "ListenReactionMulti": "Liczba słuchaczy w Twojej sieci: {0}",
  "ListenReactionSingle": "Użytkownik {0} słucha tego",
  "LocalFile": "Plik lokalny",
  "More": "Więcej",
  "Pause": "Pauza",
  "Play": "Odtwórz",
  "Playlist": "Playlista",
  "PressEnterToPlay": "Naciśnij Enter, aby odtworzyć",
  "Popularity": "Popularność",
  "Remove": "Usuń",
  "RemoveYourMusic": "Usuń z kolekcji Twoja muzyka",
  "Save": "Zapisz",
  "SaveYourMusic": "Zapisz w kolekcji Twoja muzyka",
  "Saved": "Zapisany",
  "ShufflePlay": "Odtwarzanie losowe",
  "Song": "Utwór",
  "StartRadio": "Włącz radio",
  "Time": "Czas",
  "Toplist": "Najpopularniejsze utwory",
  "Track": "Utwór",
  "Unfollow": "Przestań obserwować",
  "User": "Użytkownik",
  "ViewAll": "Wyświetl wszystko",
  "HoursShort": "{0} godz.",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} s",
  "ErrorTitle": "Podczas wyświetlania tego widoku wystąpił błąd!",
  "ErrorMessage": "Ten widok nie istnieje lub wystąpił błąd.",
  "OfflineTitle": "Ten widok jest niedostępny w trybie offline. ",
  "OfflineMessage": "Przejdź do trybu online, aby załadować."
};
},{}],76:[function(require,module,exports){
module.exports = {
  "Album": "Álbum",
  "AndMore": "e mais {0}",
  "Artist": "Artista",
  "By": "de",
  "Create Similar Playlist": "Criar playlist similar",
  "Filter": "Filtrar",
  "Follow": "Seguir",
  "Follower": "Seguidor",
  "FollowersLabel": "Seguidores",
  "Following": "Seguindo",
  "FollowingLabel": "Seguindo",
  "ListenersLabel": "Ouvintes mensais",
  "FollowsYou": "Segue você",
  "HoldToPreview": "Clique e segure para a prévia",
  "ListenCount": "{0} reproduções",
  "ListenReactionMulti": "{0} ouvintes na sua rede",
  "ListenReactionSingle": "{0} ouvem isso",
  "LocalFile": "Arquivo local",
  "More": "Mais",
  "Pause": "Pause",
  "Play": "Play",
  "Playlist": "Playlist",
  "PressEnterToPlay": "Pressione Enter para tocar",
  "Popularity": "Popularidade",
  "Remove": "Remover",
  "RemoveYourMusic": "Remover de Suas músicas",
  "Save": "Salvar",
  "SaveYourMusic": "Salvar em Suas músicas",
  "Saved": "Salvo",
  "ShufflePlay": "Ordem aleatória",
  "Song": "Música",
  "StartRadio": "Abrir rádio",
  "Time": "Tempo",
  "Toplist": "Músicas mais tocadas",
  "Track": "Música",
  "Unfollow": "Deixar de seguir",
  "User": "Usuário",
  "ViewAll": "Ver tudo",
  "HoursShort": "{0} h",
  "MinutesShort": "{0} m",
  "SecondsShort": "{0} s",
  "ErrorTitle": "Tivemos um problema ao mostrar esta exibição!",
  "ErrorMessage": "A exibição não existe ou ocorreu um erro.",
  "OfflineTitle": "Essa visualização não está disponível offline!",
  "OfflineMessage": "Fique online para carregar."
};
},{}],77:[function(require,module,exports){
module.exports = {
  "Album": "Album",
  "AndMore": "och {0} till",
  "Artist": "Artist",
  "By": "av",
  "Create Similar Playlist": "Skapa en liknande spellista",
  "Filter": "Filtrera",
  "Follow": "Följ",
  "Follower": "Följare",
  "FollowersLabel": "Följare",
  "Following": "Följer",
  "FollowingLabel": "Följer",
  "ListenersLabel": "Lyssnare per månad",
  "FollowsYou": "Följer dig",
  "HoldToPreview": "Klicka och håll kvar för att förhandslyssna",
  "ListenCount": "{0} uppspelningar",
  "ListenReactionMulti": "{0} lyssnare i ditt nätverk",
  "ListenReactionSingle": "{0} lyssnar på detta",
  "LocalFile": "Lokal fil",
  "More": "Mer",
  "Pause": "Pausa",
  "Play": "Spela upp",
  "Playlist": "Spellista",
  "PressEnterToPlay": "Tryck på Retur om du vill lyssna",
  "Popularity": "Popularitet",
  "Remove": "Ta bort",
  "RemoveYourMusic": "Ta bort från Din Musik",
  "Save": "Spara",
  "SaveYourMusic": "Spara i Din Musik",
  "Saved": "Sparade",
  "ShufflePlay": "Slumpmässig uppspelning",
  "Song": "Låt",
  "StartRadio": "Starta radio",
  "Time": "Tid",
  "Toplist": "Topplåtar",
  "Track": "Låt",
  "Unfollow": "Sluta följa",
  "User": "Användare",
  "ViewAll": "Visa alla",
  "HoursShort": "{0} tim",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} sek",
  "ErrorTitle": "Det uppstod ett fel när den här vyn skulle visas!",
  "ErrorMessage": "Den här vyn finns inte eller så uppstod ett fel.",
  "OfflineTitle": "Den här vyn är inte tillgänglig offline.",
  "OfflineMessage": "Anslut till internet om du vill läsa in appen."
};
},{}],78:[function(require,module,exports){
module.exports = {
  "Album": "Albüm",
  "AndMore": "ve {0} daha",
  "Artist": "Sanatçı",
  "By": "-",
  "Create Similar Playlist": "Benzer Çalma Listesi Oluştur",
  "Filter": "Filtrele",
  "Follow": "Takip Et",
  "Follower": "Takipçi",
  "FollowersLabel": "Takipçiler",
  "Following": "Takip Ediliyor",
  "FollowingLabel": "Takip Ediliyor",
  "ListenersLabel": "Aylık Dinleyici",
  "FollowsYou": "Seni Takip Ediyor",
  "HoldToPreview": "Basılı Tut ve Önizle",
  "ListenCount": "{0} dinleme",
  "ListenReactionMulti": "Ağında {0} dinleyici",
  "ListenReactionSingle": "{0} bunu dinliyor",
  "LocalFile": "Yerel Dosya",
  "More": "Daha fazla",
  "Pause": "Duraklat",
  "Play": "Çal",
  "Playlist": "Çalma listesi",
  "PressEnterToPlay": "Çalmak için Enter'a bas",
  "Popularity": "Popülerlik",
  "Remove": "Çıkar",
  "RemoveYourMusic": "Müziklerin'den çıkar",
  "Save": "Kaydet",
  "SaveYourMusic": "Müziklerin'e kaydet",
  "Saved": "Kaydedildi",
  "ShufflePlay": "Karışık Çal",
  "Song": "Şarkı",
  "StartRadio": "Radyoyu Başlat",
  "Time": "Saat",
  "Toplist": "En çok dinlenen şarkılar",
  "Track": "Şarkı",
  "Unfollow": "Takip Etmeyi Bırak",
  "User": "Kullanıcı",
  "ViewAll": "Tümünü Görüntüle",
  "HoursShort": "{0} sa",
  "MinutesShort": "{0} dk",
  "SecondsShort": "{0} sn",
  "ErrorTitle": "Bu öğe görüntülenirken bir sorun oluştu!",
  "ErrorMessage": "Bu görünüm yok veya bir hata oluştu.",
  "OfflineTitle": "Bu görünüm çevrimdışıyken kullanılamaz!",
  "OfflineMessage": "Yüklemek için lütfen çevrimiçi ol."
};
},{}],79:[function(require,module,exports){
module.exports = {
  "Album": "專輯",
  "AndMore": "還有 {0} 首",
  "Artist": "藝人",
  "By": "－",
  "Create Similar Playlist": "建立相似的播放清單",
  "Filter": "篩選",
  "Follow": "關注",
  "Follower": "粉絲",
  "FollowersLabel": "關注者",
  "Following": "正在關注",
  "FollowingLabel": "正在關注",
  "ListenersLabel": "每月聽眾",
  "FollowsYou": "關注你",
  "HoldToPreview": "按住即可預覽",
  "ListenCount": "播放了 {0} 次",
  "ListenReactionMulti": "在你的社群網路中有 {0} 名聽眾",
  "ListenReactionSingle": "{0} 收聽了這首歌曲",
  "LocalFile": "本機檔案",
  "More": "更多",
  "Pause": "暫停",
  "Play": "播放",
  "Playlist": "播放列表",
  "PressEnterToPlay": "請按 Enter 播放",
  "Popularity": "流行",
  "Remove": "移除",
  "RemoveYourMusic": "從你的音樂中移除",
  "Save": "儲存",
  "SaveYourMusic": "儲存至你的音樂",
  "Saved": "已儲存",
  "ShufflePlay": "隨機播放",
  "Song": "歌曲",
  "StartRadio": "啟用電臺",
  "Time": "時間",
  "Toplist": "當紅歌曲",
  "Track": "歌曲",
  "Unfollow": "取消關注",
  "User": "使用者",
  "ViewAll": "檢視全部",
  "HoursShort": "{0} 小時",
  "MinutesShort": "{0} 分鐘",
  "SecondsShort": "{0} 秒鐘",
  "ErrorTitle": "顯示這個畫面時出現問題。",
  "ErrorMessage": "這個畫面可能不存在或發生錯誤。",
  "OfflineTitle": "離線時無法使用這個檢視！",
  "OfflineMessage": "請上網以載入。"
};
},{}],80:[function(require,module,exports){
module.exports = {
  "Album": "Album",
  "AndMore": "dan {0} lagi",
  "Artist": "Artis",
  "By": "oleh",
  "Create Similar Playlist": "Cipta Senarai Main Serupa",
  "Filter": "Penapis",
  "Follow": "Ikut",
  "Follower": "Pengikut",
  "FollowersLabel": "Pengikut",
  "Following": "Mengikuti",
  "FollowingLabel": "Mengikuti",
  "ListenersLabel": "Pendengar Bulanan",
  "FollowsYou": "Megikuti Anda",
  "HoldToPreview": "Klik dan Tahan untuk Pratonton",
  "ListenCount": "{0} main",
  "ListenReactionMulti": "{0} pendengar dalam rangkaian anda",
  "ListenReactionSingle": "{0} mendengar ini",
  "LocalFile": "Fail Setempat",
  "More": "Lebih banyak",
  "Pause": "Jeda",
  "Play": "Main",
  "Playlist": "Senarai main",
  "PressEnterToPlay": "Tekan Enter untuk main",
  "Popularity": "Populariti",
  "Remove": "Keluarkan",
  "RemoveYourMusic": "Keluarkan daripada Muzik Anda",
  "Save": "Simpan",
  "SaveYourMusic": "Simpan ke Muzik Anda",
  "Saved": "Disimpan",
  "ShufflePlay": "Main Rombak",
  "Song": "Lagu",
  "StartRadio": "Mulakan Radio",
  "Time": "Masa",
  "Toplist": "Lagu popular",
  "Track": "Lagu",
  "Unfollow": "Nyahikut",
  "User": "Pengguna",
  "ViewAll": "Lihat Semua",
  "HoursShort": "{0} jam",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} saat",
  "ErrorTitle": "Terdapat masalah memaparkan paparan ini!",
  "ErrorMessage": "Paparan ini sama ada tidak wujud atau ralat berlaku.",
  "OfflineTitle": "Paparan ini tidak tersedia di luar talian!",
  "OfflineMessage": "Sila ke online untuk memuatkan."
};
},{}],81:[function(require,module,exports){
'use strict';

exports.getVersion = require('./src/version').getVersion;
exports.gridOverlay = require('./src/gridOverlay');

},{"./src/gridOverlay":82,"./src/version":83}],82:[function(require,module,exports){
(function (global){
'use strict';

var cosmos = require('spotify-cosmos-api');

var DEFAULT_GRID_COLOR = 'rgba(251, 74, 131, 0.22)';
var DEFAULT_GRID_COLOR_HIGHLIGHT = 'rgba(251, 74, 131, 0.8)';
var GRID_BASELINE = 8;

var overlayElement = null;
var baselineHighlightElement = null;
var gridColor = '';
var highlightGridColor = '';
var gridModes = ['off', 'column', 'baseline'];
var currentModeIndex = 0;

/**
 * Listen for control messages to toggle the grid when a menu item is clicked
 * or a keyboard shortcut is pressed. This only happens if the user is a global
 * app developer.
 */
function listen() {
  var spotify = global.__spotify;
  var productState = spotify && spotify.product_state;
  var appDeveloperFlag = productState && productState['app-developer'];

  if (appDeveloperFlag === '3' || appDeveloperFlag === '7') {
    cosmos.resolver.subscribe({
      url: 'sp://messages/v1/container/control'
    }, function (error, response) {
      if (error) return;
      var data = response.getJSONBody();
      if (data && data.type === 'toggle_grid') {
        toggle();
      }
    });
  }
}

/**
 * Toggle the grid overlay.
 */
function toggle() {
  var newIndex = currentModeIndex + 1;
  if (newIndex > gridModes.length - 1) {
    newIndex = 0;
  }

  var mode = gridModes[newIndex];

  if (mode === 'off') {
    disable();
  } else {
    enable(mode);
  }
}

/**
 * Enable the grid overlay.
 *
 * @param {string} mode The grid mode to enable, 'column' or 'baseline'.
 */
function enable(mode) {
  if (!mode) {
    return;
  }

  if (gridModes[currentModeIndex] === mode) {
    return;
  }

  currentModeIndex = gridModes.indexOf(mode);

  if (overlayElement && overlayElement.parentNode) {
    overlayElement.parentNode.removeChild(overlayElement);
  }

  if (mode === 'baseline') {
    document.addEventListener('mousemove', onMouseMove, false);
  }

  overlayElement = createOverlayElement();

  document.body.appendChild(overlayElement);
}

/**
 * Disable the grid overlay.
 */
function disable() {
  if (gridModes[currentModeIndex] === 'off') {
    return;
  }

  if (overlayElement && overlayElement.parentNode) {
    overlayElement.parentNode.removeChild(overlayElement);
  }

  currentModeIndex = gridModes.indexOf('off');
  overlayElement = null;
  baselineHighlightElement = null;

  document.removeEventListener('mousemove', onMouseMove, false);
}

/**
 * Set the color used for each grid column or baseline line.
 *
 * @param {string} color Any valid CSS color.
 * @param {string=} highlightColor Any valid CSS color. Can be omitted for
 *     column grid.
 */
function setColor(color, highlightColor) {
  gridColor = color;
  highlightGridColor = highlightColor;
}

/**
 * Reset all state in this module.
 */
function reset() {
  overlayElement = null;
  baselineHighlightElement = null;
  gridColor = '';
  highlightGridColor = '';
  currentModeIndex = 0;
}

/**
 * Mouse move handler that highlights the hovered baseline line.
 *
 * @param {Event} event A mousemove event object.
 *
 * @private
 */
function onMouseMove(event) {
  if (!baselineHighlightElement) {
    baselineHighlightElement = document.createElement('div');
    baselineHighlightElement.className = 'grid-overlay-baseline-highlight';
    baselineHighlightElement.style.backgroundColor = highlightGridColor || DEFAULT_GRID_COLOR_HIGHLIGHT;
    overlayElement.appendChild(baselineHighlightElement);
  }

  // Calculate the Y position for the baseline line closest to the pointer
  var pointerPos = event.clientY + window.scrollY;
  var yLineAbove = Math.floor(pointerPos / GRID_BASELINE) * GRID_BASELINE;
  var y = yLineAbove + (pointerPos % GRID_BASELINE > 4 ? GRID_BASELINE : 0);

  baselineHighlightElement.style.top = y - 1 + 'px';
}

/**
 * Create the DOM nodes needed for the overlay, with the correct class names
 * and styles.
 *
 * @return {HTMLElement} The container element for the overlay.
 *
 * @private
 */
function createOverlayElement() {
  var color = gridColor || DEFAULT_GRID_COLOR;

  var container = document.createElement('div');
  container.className = 'grid-overlay container';

  if (gridModes[currentModeIndex] === 'column') {
    var row = document.createElement('div');
    row.className = 'grid-overlay-row row';
    container.appendChild(row);

    var sizeLabel = createSizeLabel();
    container.appendChild(sizeLabel);

    var columnClassNames = 'col-xs-1 col-sm-1 col-md-1 col-lg-1';

    for (var i = 0; i < 12; i++) {
      var column = document.createElement('div');
      column.className = 'grid-overlay-col-' + (i + 1) + ' ' + columnClassNames;

      column.style.backgroundColor = color;

      row.appendChild(column);
    }
  } else if (gridModes[currentModeIndex] === 'baseline') {
    container.classList.add('grid-overlay-baseline');

    var baselinePercentage = (GRID_BASELINE - 1) / GRID_BASELINE * 100 + '%';

    var backgroundImage = ['linear-gradient(', 'to bottom, ', 'transparent, ', 'transparent ' + baselinePercentage + ', ', color + ' ' + baselinePercentage, ')'].join('');

    container.style.backgroundImage = backgroundImage;

    // Because JSDOM is using the package 'cssstyle', which is stupid and
    // doesn't support gradients as values...
    container.style._backgroundImage = backgroundImage;
  }

  return container;
}

/**
 * Create the DOM nodes needed for the grid size label.
 *
 * @return {HTMLElement} A DOM node.
 *
 * @private
 */
function createSizeLabel() {
  var sizes = [{ name: 'Extra Small', id: 'xs' }, { name: 'Small', id: 'sm' }, { name: 'Medium', id: 'md' }, { name: 'Large', id: 'lg' }];

  var labelContainer = document.createElement('div');
  labelContainer.className = 'grid-overlay-label';

  sizes.forEach(function (size) {
    var label = document.createElement('span');
    label.className = 'visible-' + size.id;
    label.textContent = size.name;
    labelContainer.appendChild(label);
  });

  return labelContainer;
}

exports.listen = listen;
exports.toggle = toggle;
exports.enable = enable;
exports.disable = disable;
exports.setColor = setColor;
exports.reset = reset;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"spotify-cosmos-api":246}],83:[function(require,module,exports){
'use strict';

// This should be removed later when nothing is calling this method

exports.getVersion = function () {
  return 1;
};

},{}],84:[function(require,module,exports){
'use strict';

module.exports = {
  'de': require('../i18n/de.lang'),
  'el': require('../i18n/el.lang'),
  'en': require('../i18n/en.lang'),
  'es': require('../i18n/es.lang'),
  'es-419': require('../i18n/es-419.lang'),
  'fi': require('../i18n/fi.lang'),
  'fr': require('../i18n/fr.lang'),
  'fr-CA': require('../i18n/fr-CA.lang'),
  'hu': require('../i18n/hu.lang'),
  'id': require('../i18n/id.lang'),
  'it': require('../i18n/it.lang'),
  'ja': require('../i18n/ja.lang'),
  'nl': require('../i18n/nl.lang'),
  'pl': require('../i18n/pl.lang'),
  'pt-BR': require('../i18n/pt-BR.lang'),
  'sv': require('../i18n/sv.lang'),
  'tr': require('../i18n/tr.lang'),
  'zh-Hant': require('../i18n/zh-Hant.lang'),
  'zsm': require('../i18n/zsm.lang')
};

},{"../i18n/de.lang":62,"../i18n/el.lang":63,"../i18n/en.lang":64,"../i18n/es-419.lang":65,"../i18n/es.lang":66,"../i18n/fi.lang":67,"../i18n/fr-CA.lang":68,"../i18n/fr.lang":69,"../i18n/hu.lang":70,"../i18n/id.lang":71,"../i18n/it.lang":72,"../i18n/ja.lang":73,"../i18n/nl.lang":74,"../i18n/pl.lang":75,"../i18n/pt-BR.lang":76,"../i18n/sv.lang":77,"../i18n/tr.lang":78,"../i18n/zh-Hant.lang":79,"../i18n/zsm.lang":80}],85:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, options, functionType="function", escapeExpression=this.escapeExpression, self=this, helperMissing=helpers.helperMissing;

function program1(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n  <div class=\"mo-image-background-color\">\n    ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.imageUrl), {hash:{},inverse:self.noop,fn:self.program(2, program2, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  </div>\n";
  return buffer;
  }
function program2(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n      <div class=\"mo-image-background\" style=\"background-image: url('";
  if (helper = helpers.imageUrl) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.imageUrl); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "')\"></div>\n    ";
  return buffer;
  }

function program4(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n  <div class=\"mo-wide-image\" ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.imageUrl), {hash:{},inverse:self.noop,fn:self.program(5, program5, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += ">\n";
  return buffer;
  }
function program5(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "style=\"background-image: url('";
  if (helper = helpers.imageUrl) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.imageUrl); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "')\"";
  return buffer;
  }

function program7(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n  <div class=\"mo-image\" ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.imageUrl), {hash:{},inverse:self.noop,fn:self.program(5, program5, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += ">\n";
  return buffer;
  }

  buffer += "<svg class=\"mo-placeholder\" viewBox=\"0 0 10 10\" preserveAspectRatio=\"xMidYMid meet\">\n  <text class=\"playlist-placeholder\" x=\"5\" y=\"9.8\">&#xf135;</text>\n  <text class=\"playlist-folder-placeholder\" x=\"5\" y=\"9.8\">&#xf137;</text>\n  <text class=\"album-placeholder\" x=\"5\" y=\"9.8\">&#xf101;</text>\n  <text class=\"artist-placeholder\" x=\"5\" y=\"9.8\">&#xf103;</text>\n  <text class=\"user-placeholder\" x=\"5\" y=\"9.8\">&#xf15d;</text>\n  <text class=\"genre-placeholder\" x=\"5\" y=\"9.8\">&#xf109;</text>\n  <text class=\"collection-placeholder\" x=\"5\" y=\"9.8\">&#xf157;</text>\n  <text class=\"local-files-placeholder\" x=\"5\" y=\"9.8\">&#xf1fb;</text>\n</svg>\n\n";
  stack1 = (helper = helpers.type || (depth0 && depth0.type),options={hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.uri), "user", "artist", options) : helperMissing.call(depth0, "type", (depth0 && depth0.uri), "user", "artist", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.wideImage), {hash:{},inverse:self.program(7, program7, data),fn:self.program(4, program4, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n</div>\n<span class=\"mo-verified\">\n  <span class=\"spoticon-check-16\"></span>\n</span>\n";
  return buffer;
  });

},{"hbsfy/runtime":191}],86:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
var partial$0 = require('./media/image.hbs');
HandlebarsCompiler.registerPartial('./media/image.hbs', partial$0);
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); partials = this.merge(partials, Handlebars.partials); data = data || {};
  var buffer = "", stack1, helper, options, functionType="function", escapeExpression=this.escapeExpression, self=this, helperMissing=helpers.helperMissing, blockHelperMissing=helpers.blockHelperMissing;

function program1(depth0,data) {
  
  
  return "unread";
  }

function program3(depth0,data) {
  
  var buffer = "", stack1, helper, options;
  buffer += "\n    <a href=\"";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.url), {hash:{},inverse:self.program(6, program6, data),fn:self.program(4, program4, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\" data-log-click=\"media-image\">\n      <div class=\"media-object media-object-simple media-object-link media-object-"
    + escapeExpression((helper = helpers.type || (depth0 && depth0.type),options={hash:{},data:data},helper ? helper.call(depth0, (depth0 && depth0.uri), options) : helperMissing.call(depth0, "type", (depth0 && depth0.uri), options)))
    + " ";
  stack1 = helpers.unless.call(depth0, (depth0 && depth0.imageUrl), {hash:{},inverse:self.noop,fn:self.program(8, program8, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\">\n        <div class=\"mo-image-wrapper\">\n          ";
  stack1 = self.invokePartial(partials['./media/image.hbs'], './media/image.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n        </div>\n      </div>\n    </a>\n  ";
  return buffer;
  }
function program4(depth0,data) {
  
  var stack1, helper;
  if (helper = helpers.url) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.url); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  return escapeExpression(stack1);
  }

function program6(depth0,data) {
  
  var stack1, helper;
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  return escapeExpression(stack1);
  }

function program8(depth0,data) {
  
  
  return "show-placeholder";
  }

function program10(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n    <div class=\"share-meta text-meta text-muted\">\n      ";
  if (helper = helpers.shareMeta) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.shareMeta); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\n    </div>\n  ";
  return buffer;
  }

function program12(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n    <div class=\"share-quote\">\n      ";
  if (helper = helpers.shareQuote) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.shareQuote); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\n    </div>\n  ";
  return buffer;
  }

  buffer += "<div class=\"share-object ";
  if (helper = helpers.modifiers) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.modifiers); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + " ";
  options={hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data}
  if (helper = helpers.unread) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.unread); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.unread) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\" data-log-context=\"share-object\">\n  ";
  options={hash:{},inverse:self.noop,fn:self.program(3, program3, data),data:data}
  if (helper = helpers.sharer) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.sharer); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.sharer) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.noop,fn:self.program(3, program3, data),data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  <div class=\"share-data\">\n    ";
  if (helper = helpers.shareData) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.shareData); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  </div>\n  ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.shareMeta), {hash:{},inverse:self.noop,fn:self.program(10, program10, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.shareQuote), {hash:{},inverse:self.noop,fn:self.program(12, program12, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n</div>\n";
  return buffer;
  });

},{"./media/image.hbs":85,"hbsfy/runtime":191}],87:[function(require,module,exports){
'use strict';

// Usage
// Data {{#compare 'myvalue' value}}has{{else}}doesn't have{{/compare}} myvalue.
// Data {{#compare '5' tracks.length true}}has{{else}}doesn't have{{/compare}} 5 tracks.
// Data {{#compare tracks.length 5 operator='>'}}has more than{{else}}has less than or equal to{{/compare}} 5 tracks.

var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var operators = {
  '==': function _(a, b) {
    /* eslint eqeqeq: 0 */return a == b;
  },
  '===': function _(a, b) {
    return a === b;
  },
  '!=': function _(a, b) {
    /* eslint eqeqeq: 0 */return a != b;
  },
  '<': function _(a, b) {
    return a < b;
  },
  '>': function _(a, b) {
    return a > b;
  },
  '<=': function _(a, b) {
    return a <= b;
  },
  '>=': function _(a, b) {
    return a >= b;
  },
  'typeof': function _typeof(a, b) {
    return (typeof a === 'undefined' ? 'undefined' : _typeof2(a)) == b;
  }
};

function compare(a, b, s) {
  var options = arguments[arguments.length - 1];
  var soft = s !== options ? s : false;
  var operator = soft ? '==' : options.hash.operator || '===';

  var match = operators[operator](a, b);

  return match ? options.fn(this) : options.inverse(this);
}

compare.displayName = 'compare';

module.exports = compare;

},{}],88:[function(require,module,exports){
'use strict';

var duration = function duration(ms) {
  if (isNaN(ms)) return ms;

  var s = Math.round(ms / 1000);
  var oneMinute = 60;
  var oneHour = 60 * oneMinute;

  var hours = Math.floor(s / oneHour);
  var minutes = Math.floor(s % oneHour / oneMinute);
  var seconds = Math.round(s % oneHour % oneMinute);

  // Include hours if needed
  if (hours) {
    hours += ':';

    // If hours are specified, minutes should always be with two digits
    if (minutes < 10) minutes = '0' + minutes;
  } else {
    hours = '';
  }

  // Since minutes should always be displayed, seconds should always be with two digits
  if (seconds < 10) seconds = '0' + seconds;

  return hours + minutes + ':' + seconds;
};

duration.displayName = 'duration';

module.exports = duration;

},{}],89:[function(require,module,exports){
'use strict';

var nameListTooltip = require('./name-list-tooltip');

var facepile = function facepile(list, totalCount, mT, opts) {
  var options = opts;
  var minThresh = mT;

  if (!list) {
    return '';
  }

  if (arguments.length < 4) {
    options = minThresh;
    minThresh = 3;
  }

  minThresh = minThresh || 3;

  var len = list.length;
  var thresh = Math.min(minThresh, len);
  var ret = '';

  // Display faces.
  for (var i = 0; i < thresh; i++) {
    var obj = list[i];
    obj.modifiers = 'media-object-link media-object-simple';
    ret += options.fn(obj);
  }

  // Display badge count for hidden listeners.
  if (totalCount > thresh) {
    ret += options.inverse({
      badgeCount: totalCount - thresh,
      badgeTooltip: nameListTooltip(list.slice(thresh), totalCount - thresh)
    });
  }
  return ret;
};

facepile.displayName = 'facepile';

module.exports = facepile;

},{"./name-list-tooltip":95}],90:[function(require,module,exports){
(function (global){
'use strict';

var getHTTPLink = require('../util/link');

var isDesktop = !!global._getSpotifyModule;

var href = function href(uri) {
  if (isDesktop) return uri;
  return getHTTPLink(uri, 'https://play.spotify.com');
};

href.displayName = 'href';

module.exports = href;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../util/link":102}],91:[function(require,module,exports){
'use strict';

var loc = require('./loc');

var humanizeDuration = function humanizeDuration(ms) {
  if (isNaN(ms)) return ms;

  var s = Math.round(ms / 1000);
  var oneMinute = 60;
  var oneHour = 60 * oneMinute;

  var hours = Math.floor(s / oneHour);
  var minutes = Math.floor(s % oneHour / oneMinute);
  var seconds = Math.round(s % oneHour % oneMinute);

  var formattedDuration = '';

  if (hours) {
    formattedDuration += loc('HoursShort', hours, {});
  }

  if (minutes) {
    formattedDuration += ' ';
    formattedDuration += loc('MinutesShort', minutes, {});
  }

  if (!hours && !minutes || hours === 0 && minutes < 10) {
    formattedDuration += ' ';
    formattedDuration += loc('SecondsShort', seconds, {});
  }

  return formattedDuration.trim();
};

humanizeDuration.displayName = 'humanizeDuration';

module.exports = humanizeDuration;

},{"./loc":94}],92:[function(require,module,exports){
'use strict';

exports.compare = require('./compare');
exports.duration = require('./duration');
exports.facepile = require('./facepile');
exports.href = require('./href');
exports.humanizeDuration = require('./humanize-duration');
exports.list = require('./list');
exports.loc = require('./loc');
exports.nameListTooltip = require('./name-list-tooltip');
exports.numeral = require('./numeral');
exports.share = require('./share');
exports.slice = require('./slice');
exports.type = require('./type');
exports.userReaction = require('./user-reaction');

},{"./compare":87,"./duration":88,"./facepile":89,"./href":90,"./humanize-duration":91,"./list":93,"./loc":94,"./name-list-tooltip":95,"./numeral":96,"./share":97,"./slice":98,"./type":99,"./user-reaction":100}],93:[function(require,module,exports){
'use strict';

var map = require('mout/array/map');

var Handlebars = require('handlebars/dist/cjs/handlebars.runtime').default;

var lists = {};

var list = function list(array) {
  if (!array) {
    return '';
  }

  var args = Array.prototype.slice.call(arguments);
  var options = args.pop();
  var listID = args[1];

  if (array === 'reset') {
    delete lists[listID];
    return '';
  }

  if (listID && lists[listID] === undefined) {
    lists[listID] = -1;
  }

  return map(array, function (item, i) {
    var data = Handlebars.createFrame(options.data || {});
    data.index = listID ? ++lists[listID] : i;
    data.number = data.index + 1;
    data.localIndex = i;
    data.localNumber = i + 1;
    return options.fn(item, { data: data });
  }).join(options.hash && options.hash.join || '');
};

list.displayName = 'list';

module.exports = list;

},{"handlebars/dist/cjs/handlebars.runtime":184,"mout/array/map":203}],94:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var mixIn = require('mout/object/mixIn');
var slice_ = Array.prototype.slice;

var storage = {};

var loc = function loc(key) {
  var value = storage[key];

  if (!value) return '';

  var args = slice_.call(arguments, 1);
  var options = {};

  if (_typeof(args[args.length - 1]) === 'object') {
    options = args.pop();
  }

  var hash = options.hash;

  return value.replace(/\{([\w-]+)\}/g, function (full, match) {
    var n = +match;
    var interpolated;

    if (isNaN(n)) {
      interpolated = hash[match];
    } else {
      interpolated = args[n];
    }

    return interpolated !== null ? interpolated : '';
  });
};

loc.displayName = 'loc';

loc.register = function (object) {
  mixIn(storage, object);
  return this;
};

module.exports = loc;

},{"mout/object/mixIn":224}],95:[function(require,module,exports){
'use strict';

var loc = require('./loc');

var nameListTooltip = function nameListTooltip(users, totalCount) {
  if (totalCount === 0) {
    return undefined;
  }

  var len = users.length;
  var textTokens = users.map(function (user) {
    return user.name;
  });

  if (totalCount - len > 0) {
    var andMoreText = loc('AndMore', totalCount - len);
    textTokens.push(andMoreText);
  }

  return textTokens.join('<br>\n').replace(/'/g, '&#39;');
};

nameListTooltip.displayName = 'nameListTooltip';

module.exports = nameListTooltip;

},{"./loc":94}],96:[function(require,module,exports){
'use strict';

var isNumber = require('mout/lang/isNumber');

/**
 * If the first argument is a number, pipe it through spotify-numeral with an
 * optional format propety in the options hash, otherwise return it untouched.
 *
 * Example usage – results when using fr locale:
 *
 * {{numeral 1000}} -> '1 000'
 * {{numeral 1000 format='0,0.000'}} -> '1 000,000'
 * {{numeral 1000 format='$0,0.00'}} -> '€1 000,00'
 *
 * @param {Number|String} number - The number to format (or string to leave
 *     untouched).
 * @param {Object} [options] - The handlebars options object.
 * @param {Object} [options.hash] - The handlebars options hash object.
 * @param {String} [options.hash.format] - The optional format to pass to
 *     numeraljs.
 * @return {String} The formatted (or untouched) string.
 */
var numeralHelper = function numeralHelper(number, options) {
  var format = options && options.hash && options.hash.format;
  var numeral = numeralHelper._numeral;
  return isNumber(number) ? numeral(number).format(format) : number;
};

numeralHelper.displayName = 'numeral';

module.exports = numeralHelper;

// This is tricky, but is a way to allow for the locale to be injected
// from the consuming app instead of from within spotify-numeral, removing
// the dependency on spotify-quickstart.
module.exports.setLocale = function (locale) {
  numeralHelper._numeral = require('../../spotify-numeral')(locale);
};

},{"../../spotify-numeral":134,"mout/lang/isNumber":213}],97:[function(require,module,exports){
'use strict';

var getHTTPLink = require('../util/link');

var share = function share(uri) {
  return getHTTPLink(uri, 'https://open.spotify.com');
};

share.displayName = 'share';

module.exports = share;

},{"../util/link":102}],98:[function(require,module,exports){
'use strict';

var kindOf = require('mout/lang/kindOf');
var map = require('mout/array/map');
var forEach = require('mout/array/forEach');

var Handlebars = require('handlebars/dist/cjs/handlebars.runtime').default;
var slice_ = Array.prototype.slice;

var slice = function slice(arr) {
  var array = arr;

  if (!array) {
    return '';
  }

  var sep;
  var begin;
  var end;
  var options;

  forEach(slice_.call(arguments, 1), function (arg) {
    switch (kindOf(arg)) {
      case 'String':
        sep = arg;
        break;

      case 'Number':
        if (begin === null) {
          begin = arg;
        } else if (end === null) {
          end = arg;
        }
        break;

      case 'Object':
        options = arg;
        break;

      default:
      // Do nothing.
    }
  });

  if (begin !== null) {
    array = array.slice(begin, end !== null ? end : array.length);
  }

  return map(array, function (item) {
    var data = Handlebars.createFrame(options.data || {});

    return options.fn(item, { data: data });
  }).join(sep || '');
};

slice.displayName = 'slice';

module.exports = slice;

},{"handlebars/dist/cjs/handlebars.runtime":184,"mout/array/forEach":200,"mout/array/map":203,"mout/lang/kindOf":216}],99:[function(require,module,exports){
'use strict';

var getType = require('../util/type');

// This needs at least the uri param to get the type:
// {{type uri}}
//
// If you pass more parameters you can use it like a matcher:
// {{#type uri "track" "album"}}YAY{{/type}}
// This will print 'YAY' for tracks or albums.

var type = function type(uri) {
  if (arguments.length <= 2) {
    // Simple get type.
    return getType(uri);
  }

  // Match type.
  var context = arguments[arguments.length - 1];
  var success = false;
  var uriType = getType(uri);

  for (var i = 1; i < arguments.length - 1; i++) {
    if (uriType === arguments[i]) {
      success = true;
      break;
    }
  }

  return success ? context.fn(this) : context.inverse(this);
};

type.displayName = 'type';

module.exports = type;

},{"../util/type":103}],100:[function(require,module,exports){
'use strict';

var loc = require('./loc');

var userReaction = function userReaction(users, totalCount, reactionType) {
  if (!totalCount) return '';
  var key = reactionType + 'Reaction' + (totalCount > 1 ? 'Multi' : 'Single');

  if (totalCount > 1) {
    return loc(key, totalCount);
  }

  if (!users.length) {
    return '';
  }

  var firstListener = users[0].name;
  return loc(key, firstListener);
};

userReaction.displayName = 'userReaction';

module.exports = userReaction;

},{"./loc":94}],101:[function(require,module,exports){
'use strict';

var kindOf = require('mout/lang/kindOf');

var Handlebars = require('handlebars/dist/cjs/handlebars.runtime').default;

// Expose the runtime to make partials easier to register.
exports.runtime = Handlebars;

exports.register = function (helpers) {
  var list = {};

  if (kindOf(helpers) === 'Function') {
    list[helpers.displayName] = helpers;
  } else {
    list = helpers;
  }

  for (var key in list) {
    if (list.hasOwnProperty(key)) {
      Handlebars.registerHelper(key, list[key]);
    }
  }

  return this;
};

},{"handlebars/dist/cjs/handlebars.runtime":184,"mout/lang/kindOf":216}],102:[function(require,module,exports){
'use strict';

module.exports = function (uri, base) {
  var matches = (uri || '').match(/^spotify:(.+)$/);

  if (!matches) {
    return uri || '';
  }

  var parts = matches.pop().replace(/:$/, '').split(/:/);
  var type = parts.shift();

  if (type === 'search') {
    parts = [parts.join(':')];
  }

  parts.unshift(base, type);

  return parts.join('/');
};

},{}],103:[function(require,module,exports){
'use strict';

module.exports = function (uri) {
  if (!uri || !uri.split) {
    return null;
  }
  var parts = uri.split(':');
  var result = null;
  switch (parts[1]) {
    case 'album':
      // spotify:album:<id>:<disc>
      if (parts.length === 4) {
        return 'disc';
      } else if (parts.length === 3) {
        return 'album';
      }
      break;

    case 'artist':
      if (parts.length === 3) {
        return 'artist';
      }
      break;

    case 'track':
      if (parts.length === 3) {
        return 'track';
      }
      break;

    case 'genre':
      if (parts.length === 3) {
        return 'genre';
      }
      break;

    case 'station':
      if (parts.length > 3) {
        return 'station';
      }
      break;

    case 'local':
      if (parts.length === 6) {
        return 'track';
      } else if (parts.length === 4) {
        return 'album';
      } else if (parts.length === 3) {
        return 'artist';
      }
      break;

    case 'user':
      // spotify:user:<username>:collection
      if (parts.length > 3 && parts[3] === 'collection') {
        return 'collection';
      }

      // spotify:user:<username>:folder:<id>
      if (parts.length === 5 && parts[3] === 'folder') {
        return 'playlist-folder';
      }

      // spotify:user:<username>:<playlist:<id>|starred|toplist>
      if (parts.length > 3 && parts.length <= 5 && parts[2] !== 'facebook') {
        return 'playlist';
      } else if (parts.length === 3) {
        return 'user';
      }
      break;

    case 'internal':
      // spotify:internal:local-files
      return parts[2];

    case 'app':
      // spotify:app:collection:albums, spotify:app:radio
      return parts.slice(1).join('-');

    default:
    // Do nothing.
  }

  return result;
};

},{}],104:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var Translations = require('../spotify-translations');
var glueLocales = require('../spotify-glue-cat/strings');

module.exports = function (localeToStrings) {
  if (!localeToStrings || (typeof localeToStrings === 'undefined' ? 'undefined' : _typeof(localeToStrings)) !== 'object') {
    throw new Error('' + 'Locale strings must be a plain object. ' + 'See spotify-i18n/README.md');
  }

  function getClientLocale() {
    return typeof window !== 'undefined' && window.__spotify && window.__spotify.locale || 'en';
  }

  var locales = localeToStrings;
  var i18n = new Translations();
  i18n.injectData(locales[getClientLocale()] || {});

  return {
    locale: getClientLocale,
    get: i18n.get.bind(i18n),

    glueStrings: function glueStrings() {
      return glueLocales[getClientLocale()];
    },

    appStrings: function appStrings() {
      return locales[getClientLocale()];
    }
  };
};

},{"../spotify-glue-cat/strings":84,"../spotify-translations":152}],105:[function(require,module,exports){
'use strict';

var base = 'spotify:internal:filterlist';
var regExp = /^spotify:internal:filterlist:([^:]*):(.*)$/;

/**
 * Create a URI representing a filtered variant of a list.
 *
 * @param {string} originUri The original list URI.
 * @param {string} query The query string (compatible with Core). Filter
 *     implementations might not look at all values.
 *
 * @return {string} URI of the filtered variant of the list. The URI will have
 *     the query string URL encoded.
 */
exports.create = function (originUri, query) {
  originUri = originUri.replace(/^spotify:/, '');

  query = encodeURIComponent(query);

  return [base, query, originUri].join(':');
};

/**
 * Get the query string from a filter URI.
 *
 * @param {string} filterUri The URI of the filtered list.
 *
 * @return {string} The query string, URL decoded. If URI is
 *     invalid, this returns an empty string.
 */
exports.getQuery = function (filterUri) {
  var matches = filterUri.match(regExp);
  if (!matches) return '';

  return decodeURIComponent(matches[1]);
};

/**
 * Get the URI of the original list.
 *
 * @param {string} filterUri The URI of the filtered list.
 *
 * @return {string} The URI of the original list. If the filter URI is invalid,
 *     this returns an empty string.
 */
exports.getOriginUri = function (filterUri) {
  var matches = filterUri.match(regExp);
  if (!matches) return '';

  return 'spotify:' + matches[2];
};

/**
 * Parse and return all parts of the filter URI.
 *
 * @param {string} filterUri The URI of the filtered list.
 *
 * @return {Object?} An object with properties `direction`, `query` and `originUri`,
 *     or null if the URI is not valid.
 */
exports.parse = function (filterUri) {
  var matches = filterUri.match(regExp);
  if (!matches) return null;

  return {
    query: decodeURIComponent(matches[1]),
    originUri: 'spotify:' + matches[2]
  };
};

/**
 * Test if the provided URI is a valid filter URI.
 *
 * @param {string} filterUri The URI of the filtered list.
 *
 * @return {boolean} True if it's valid, false otherwise.
 */
exports.isValid = function (filterUri) {
  return regExp.test(filterUri);
};

/**
 * The regular expression that matches filter URIs.
 */
exports.regExp = regExp;

},{}],106:[function(require,module,exports){
(function (global){
/**
 * @module spotify-live-models/album
 */
'use strict';

var live = require('../spotify-live');

var liburi = require('spotify-liburi');

var intersection = require('mout/array/intersection');
var contains = require('mout/array/contains');
var mixIn = require('mout/object/mixIn');

var bridge = require('./util/bridge').request;

function isLocalAlbum(uri) {
  return liburi.from(uri).type === liburi.Type.LOCAL_ALBUM;
}

function isLocalArtist(uri) {
  return liburi.from(uri).type === liburi.Type.LOCAL_ARTIST;
}

function updateMetadata(model) {
  if (isLocalAlbum(model.uri)) {
    var uriObject = liburi.from(model.uri);
    if (uriObject) {
      var data = {
        local: true,
        name: uriObject.album,
        artists: [{
          uri: 'spotify:local:',
          name: '',
          local: true
        }]
      };
      if (uriObject.artist) {
        data.artists[0].uri = liburi.localArtistURI(uriObject.artist).toURI();
        data.artists[0].name = uriObject.artist;
        data.artists[0].local = true;
      }
      model.update(data);
    }
  } else {
    bridge('album_metadata', [model.uri], function (error, payload) {
      if (error) {
        if (global.console) console.error(error);
        return;
      }
      model.update(payload);
    });
  }
}

function updateLocal(model) {
  model.update({
    local: isLocalAlbum(model.uri)
  });
}

var idCounter = 1000;

function getRowUri(trackUri) {
  return trackUri.replace('spotify:', 'spotify:row:' + (++idCounter).toString(36) + ':');
}

function updateRows(model) {
  var descriptor = { type: 'list', uri: model.uri };

  bridge('album_tracks_snapshot', [descriptor, 0, 0, false], function (error, payload) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }

    bridge('album_tracks_snapshot', [descriptor, 0, payload.length, false], function (error, payload) {
      if (error) {
        if (global.console) console.error(error);
        return;
      }

      var discs = [];
      var uriId = liburi.from(model.uri).id;

      var rows = payload.metadata && payload.metadata.map(function (trackdata, i) {
        var track = mixIn({ uri: payload.array[i] }, trackdata);
        var discNum = track.disc ? track.disc - 1 : 0;
        track.unavailable = !track.playable;
        setLocalProperty(track);
        if (!discs[discNum]) {
          discs[discNum] = {
            rows: [],
            uri: uriId ? liburi.albumURI(uriId, discNum + 1).toURI() : ''
          };
        }
        var uri = getRowUri(track.uri);
        var trackObject = {
          track: track,
          uri: uri
        };
        discs[discNum].rows.push(trackObject);
        return trackObject;
      });

      model.update({ rows: rows, discs: discs });
    });
  });
}

function setLocalProperty(track) {
  if (track.album && track.album.uri) {
    track.album.local = isLocalAlbum(track.album.uri);
  }
  if (track.artists) {
    for (var i = 0, l = track.artists.length; i < l; i++) {
      var artist = track.artists[i];
      if (artist.uri) {
        artist.local = isLocalArtist(artist.uri);
      }
    }
  }
}

function onWait(model, properties) {
  var hasLocal = contains(properties, 'local');
  var hasRows = contains(properties, 'rows');
  var hasDiscs = contains(properties, 'discs');

  var metaFields = ['artists', 'image', 'images', 'name', 'playable', 'type', 'availability', 'date', 'label', 'copyrights'];

  var hasMetadata = !!intersection(properties, metaFields).length;

  if (hasMetadata) updateMetadata(model);
  if (hasRows || hasDiscs) updateRows(model);
  if (hasLocal) updateLocal(model);
}

var regExp = exports.matches = /^spotify:album:[0-9a-zA-Z]+$|^spotify:local:[^:]*:[^:]*$/;
var registered;
exports.register = function () {
  if (registered) return;
  registered = true;

  live.subscribe(regExp, 'wait', onWait);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  live.unsubscribe(regExp, 'wait', onWait);
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-live":118,"./util/bridge":113,"mout/array/contains":194,"mout/array/intersection":202,"mout/object/mixIn":224,"spotify-liburi":256}],107:[function(require,module,exports){
(function (global){
/**
 * @module spotify-live-models/application
 */
'use strict';

var contains = require('mout/array/contains');
var live = require('../spotify-live');
var bridge = require('./util/bridge').request;
var AppState = require('../spotify-navigation/app-state');

var BACKOFF = 100;

function bridgeWait() {
  bridge('application_event_wait', [], function (error, event) {
    if (!registered) return;
    if (error) {
      setTimeout(function () {
        bridgeWait(model);
      }, BACKOFF);
      if (global.console) console.error(error);
      return;
    }

    var model = live('spotify:application');

    if (event.data && event.data.arguments) {
      model.update({
        arguments: event.data.arguments.join(':')
      });
    }

    // These don't won't happen on Zelda, there we handle it through postMessage. See onMessage.
    switch (event.type) {
      case 'activate':
        model.update({ 'active': true });
        break;

      case 'deactivate':
        model.update({ 'active': false });
        break;
    }

    bridgeWait(model);
  });
}

function onMessage(message) {
  var model = live('spotify:application');

  if (message.data && message.data.name) {
    if (message.data.name === 'set_active') {
      model.update({
        active: message.data.active
      });
    } else if (message.data.name === 'set_arguments') {
      // Arguments come as an array of un-encoded values, but we need to
      // concatenate them to a single colon-separated string for the
      // current design of the API. This is incorrect, as arguments should
      // be encoded if they are joined in a string. We should fix this, but
      // not without a breaking change.
      // https://jira.spotify.net/browse/KM-2353
      model.update({
        arguments: message.data.arguments.join(':')
      });
    } else if (message.data.name === 'set_state') {
      model.update({
        state: AppState.unserialize(message.data.state)
      });
    }
  }
}

function onRegister(model) {
  model.update({
    version: global.__spotify && global.__spotify.app_version || '0.0.0'
  });

  bridge('application_query', [], function (error, payload) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }

    var data = {};
    if (payload.uri) data.appURI = payload.uri;
    if (payload.arguments) data.arguments = payload.arguments.join(':');
    if ('active' in payload) data.active = payload.active;

    model.update(data);
  });
}

function applicationOpenUri(model, event) {
  bridge('application_open_uri', [event.uri]);
}

function applicationReplaceUri(model, event) {

  // This is intended to work like history.replace in the browser.

  // Desktop can also replace further back, so the current appURI needs
  // to be passed.
  // Link can't replace further back anyway, so anything thruthy as the
  // second argument will just replace the current.

  model.get('appURI', function (error, appUri) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }
    bridge('application_open_uri', [event.uri, appUri]);
  });
}

var regExp = exports.matches = /^spotify:application$/;
var registered;
exports.register = function () {
  if (registered) return;
  registered = true;

  live.subscribe(regExp, 'push-history-state', applicationOpenUri);
  live.subscribe(regExp, 'replace-history-state', applicationReplaceUri);
  global.addEventListener('message', onMessage);
  bridgeWait();
  onRegister(live('spotify:application'));
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  live.unsubscribe(regExp, 'push-history-state', applicationOpenUri);
  live.unsubscribe(regExp, 'replace-history-state', applicationReplaceUri);
  global.removeEventListener('message', onMessage);
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-live":118,"../spotify-navigation/app-state":131,"./util/bridge":113,"mout/array/contains":194}],108:[function(require,module,exports){
(function (global){
/**
 * @module spotify-live-models/artist
 */
'use strict';

var liburi = require('spotify-liburi');
var contains = require('mout/array/contains');
var live = require('../spotify-live');
var bridge = require('./util/bridge').request;

function isLocalArtist(uri) {
  return liburi.from(uri).type === liburi.Type.LOCAL_ARTIST;
}

function updateMetadata(model) {
  if (isLocalArtist(model.uri)) {
    var uriObject = liburi.from(model.uri);
    if (uriObject) {
      model.update({
        local: true,
        name: uriObject.artist
      });
    }
  } else {
    bridge('artist_metadata', [model.uri], function (error, payload) {
      if (error) {
        if (global.console) console.error(error);
        return;
      }
      if (!payload.image && !model.get('image')) payload.image = '';
      if (!payload.images && !model.get('images')) payload.images = [];
      model.update(payload);
    });
  }
}

function updateLocal(model) {
  model.update({
    local: isLocalArtist(model.uri)
  });
}

function onWait(model, properties) {
  var hasLocal = contains(properties, 'local');
  var hasMetadata = false;
  var metaFields = ['image', 'images', 'name', 'popularity'];
  for (var i = 0, l = properties.length; i < l; i++) {
    if (contains(metaFields, properties[i])) {
      hasMetadata = true;
      break;
    }
  }

  if (hasMetadata) updateMetadata(model);
  if (hasLocal) updateLocal(model);
}

var regExp = exports.matches = /^spotify:artist:|^spotify:local:[^:]*$/;
var registered;
exports.register = function () {
  if (registered) return;
  registered = true;

  live.subscribe(regExp, 'wait', onWait);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  live.unsubscribe(regExp, 'wait', onWait);
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-live":118,"./util/bridge":113,"mout/array/contains":194,"spotify-liburi":256}],109:[function(require,module,exports){
(function (global){
/**
 * @module spotify-live-models/client
 */
'use strict';

var live = require('../spotify-live');
var bridge = require('./util/bridge').request;
var liburi = require('spotify-liburi');

var BACKOFF = 100;

function updateCurrentUser(model) {
  bridge('user_metadata', ['spotify:user:@'], function (error, payload) {
    if (error) {
      if (global.__spotify && global.__spotify.username) {
        var username = global.__spotify.username;
        model.update({
          currentUser: {
            uri: liburi.profileURI(username).toURI(),
            username: username
          }
        });
      }

      if (global.console) console.error(error);
      return;
    }

    model.update({
      currentUser: {
        uri: liburi.profileURI(payload.username).toURI(),
        name: payload.name,
        username: payload.username
      }
    });
  });
}

function getFeatures(callback) {
  bridge('client_features', [], function (error, payload) {
    if (error) return callback(error);
    callback(null, payload.features);
  });
}

function updateSessionData(model) {
  bridge('session_query', [], function (error, payload) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }

    // Not all the clients expose employee property so it needs to be set if it does not exist
    if (payload.employee === undefined) {
      if (global.__spotify && global.__spotify.product_state && global.__spotify.product_state.employee) {
        // For Zelda
        payload.employee = global.__spotify.product_state.employee === '1' ? true : false;
      } else {
        // Clients older than 0.9.16 do not expose employee flag.
        payload.employee = false;
      }
    }

    model.update({ session: payload });

    // Initiate session subscription since data has been requested once.
    bridgeWaitSession(model);
  });
}

function bridgeWaitSession(model) {
  bridge('session_event_wait', [], function (error, event) {
    if (!registered) return;
    if (error) {
      setTimeout(function () {
        bridgeWaitSession(model);
      }, BACKOFF);
      if (global.console) console.error(error);
      return;
    }

    if (event.type === 'change') {
      model.get('session').update(event.data);
    }

    bridgeWaitSession(model);
  });
}

function showContextMenu(model, data) {
  if (global === window && window.top && window.top.postMessage) {
    window.top.postMessage({
      type: 'client_show_context_ui',
      data: data
    }, '*');
  }
}

function onWait(model, properties) {
  if (properties.indexOf('currentUser') > -1) {
    updateCurrentUser(model);
  }

  if (properties.indexOf('session') > -1) {
    updateSessionData(model);
  }
}

var hasFeatures;

function onFeaturesWait(featuresModel, properties) {
  // If features have been loaded before, every requested feature that
  // generates a 'wait' event after that is not an enabled feature in
  // the client, so we return false for all other properties.
  if (hasFeatures) {
    var features = {};
    properties.forEach(function (prop) {
      features[prop] = false;
    });
    featuresModel.update(features);
  } else {
    hasFeatures = true;
    getFeatures(function (error, features) {
      if (error) {
        if (global.console) console.error(error);
        return;
      }
      featuresModel.update(features);

      // Get a list of features that the model is waiting for still,
      // even after the received features were added.
      var neededFeatures = [];
      properties.forEach(function (prop) {
        if (!(prop in features)) neededFeatures.push(prop);
      });

      // Trigger a new wait handler for the properties it's still waiting for
      onFeaturesWait(featuresModel, neededFeatures);
    });
  }
}

function onInit(model) {
  // Get container_features and put it into it's own place on the client model.
  var __spotify = global.__spotify || {};
  var containerFeatures = live(__spotify.container_features || {});
  containerFeatures.on('wait', function (properties) {
    var update = {};
    for (var i = 0, property; property = properties[i]; i++) {
      update[property] = false;
    }
    containerFeatures.update(update);
  });

  // Listen for wait events on the features model to fetch data
  // through bridge and set other features to false
  var features = live({});
  features.on('wait', function (properties) {
    onFeaturesWait(features, properties);
  });

  model.update({
    features: features,
    containerFeatures: containerFeatures
  });

  // Grab the username from __spotify where available
  if (global.__spotify && global.__spotify.username) {
    var username = global.__spotify.username;
    model.update({
      currentUser: {
        uri: liburi.profileURI(username).toURI(),
        username: username
      }
    });
  }

  // Async fetch from bridge to complete currentUser to a user model
  // while we don't have all the info available elsewhere.
  updateCurrentUser(model);
}

var regExp = exports.matches = /^spotify:client$/;
var registered;
exports.register = function () {
  if (registered) return;
  registered = true;

  live.subscribe(regExp, 'wait', onWait);
  live.subscribe(regExp, 'init', onInit);
  live.subscribe(regExp, 'show-context-menu', showContextMenu);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  live.unsubscribe(regExp, 'wait', onWait);
  live.unsubscribe(regExp, 'init', onInit);
  live.unsubscribe(regExp, 'show-context-menu', showContextMenu);
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-live":118,"./util/bridge":113,"spotify-liburi":256}],110:[function(require,module,exports){
(function (global){
/**
 * @module spotify-live-models/playlist
 */
'use strict';

var contains = require('mout/array/contains');
var mixIn = require('mout/object/mixIn');
var intersection = require('mout/array/intersection');
var interpolate = require('interpolate');

var live = require('../spotify-live');
var liburi = require('spotify-liburi');

var cosmos = require('./util/cosmos');
var bridgeRequest = require('./util/bridge').request;
var debug = require('debug')('spotify-live-models:playlist');

var CLIENT = 'spotify:client';
var BACKOFF = 100;

var OFFLINE_STATUS = {
  NO: 'no',
  WAITING: 'waiting',
  DOWNLOADING: 'downloading',
  YES: 'yes'
};

var endpoints = {
  broadcast: 'sp://messages/v1/playliststate',
  'core-playlist': 'sp://core-playlist/v1/playlist'
};

function onBroadcast(error, response) {
  if (error) {
    if (global.console) console.error(error);
    return;
  }

  live(response.body.uri).update(response.body);
}

var offlineSubscriptions = {};

// This bridge call is only available in the C++ bridge and is used for
// updating subscribed/following state for the playlist.
function bridgeWaitAny(model) {
  bridgeRequest('playlist_event_wait_any', [model.uri], function (error, event) {
    // Bridge (tested in Zelda) has a bug [1] where the callbacks for
    // playlist_event_wait_any are mixed up, so that the response is
    // for a different playlist than the one that was requested.
    // By updating the live model for the URI in the event, and then
    // listen again for that model, we will update the correct models.
    // This should be removed when the bug is fixed. However, nothing
    // will break if it's still there.
    //
    // [1] https://jira.spotify.net/browse/KM-1241
    var eventModel = event && event.data.uri ? live(event.data.uri) : model;
    if (error) {
      setTimeout(function () {
        bridgeWaitAny(eventModel);
      }, BACKOFF);
      if (global.console) console.error(error);
      return;
    }

    if (event.type === 'change') {
      event.data.isFollowing = event.data.subscribed;
      event.data.added = event.data.subscribed;
      eventModel.update(event.data);
    }

    bridgeWaitAny(eventModel);
  });
}

function bridgeWait(model) {
  bridgeRequest('playlist_event_wait', [model.uri], function (error, event) {
    if (error) {
      // Hotfix 2014-10-20: We are matching temporary playlists with this model, and we're not sure
      // what the implications are if we wouldn't. For now we give up when we see a 'invalid-uri'
      // message
      if (error.name !== 'invalid-uri') {
        setTimeout(function () {
          bridgeWait(model);
        }, BACKOFF);
      }
      if (global.console) console.error(error);
      return;
    }

    // The only thing we need to care about here is 'change', other types like
    // 'insert', 'remove', 'move' aren't dealt with via bridge anymore.
    if (event.type === 'change') {
      model.update(event.data);
    }

    bridgeWait(model);
  });
}

function updateMetadata(model, needsImage) {
  bridgeRequest('playlist_metadata', [model.uri], function (error, payload) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }

    model.update(payload);

    // If the payload does not contain any images
    // we need to make a separate bridge request
    if (needsImage && !payload.images) {
      updateImage(model);
    }
  });
}

function updateImage(model) {
  bridgeRequest('playlist_profile', [model.uri], function (error, payload) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }
    if (!payload.image) payload.image = '';
    if (!payload.images) payload.images = [];
    model.update(payload);
  });
}

function updatePopularity(model) {
  bridgeRequest('playlist_popularity', [model.uri], function (error, payload) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }
    model.update(payload);
  });
}

function updateAnnotatedData(model) {
  var uriObject = liburi.from(model.uri);
  if (!uriObject || !uriObject.username || !uriObject.id) {
    debug('invalid uri for annotated data: %o', model.uri);
    model.update({ annotatedImage: null });
    return;
  }

  var encodedUsername = encodeURIComponent(uriObject.username);
  var playlistId = liburi.hexToId(uriObject.id);

  var url = interpolate('hm://playlist-annotate/v1/annotation/user/{username}/playlist/{id}', {
    username: encodedUsername,
    id: playlistId
  });

  cosmos.get({ url: url + '?format=json&bust=' + Date.now() }, function (error, response) {
    if (error) {
      model.update({
        annotatedImage: null
      });
      return;
    }

    var body = response.body;
    model.update({
      annotatedImage: body && body.picture || null
    });
  });
}

function onWait(model, properties) {
  var needsShouldBeOffline = contains(properties, 'shouldBeOffline');
  var needsOfflineStatus = contains(properties, 'offlineStatus');
  var needsOfflineProgress = contains(properties, 'offlineProgress');
  var needsPlayable = contains(properties, 'playable');
  var needsPopularity;
  var needsImage;
  var needsMetadata;
  var needsAnnotatedData;
  var needsFormatListType = contains(properties, 'formatListType');

  var metaFields = ['collaborative', 'subscribed', 'published', 'name', 'owner', 'description', 'allows'];

  properties.forEach(function (key) {
    if (key === 'popularity') needsPopularity = true;
    if (key === 'image' || key === 'images') {
      needsImage = true;
    }
    if (key === 'annotatedImage') {
      needsAnnotatedData = true;
    }
    if (!needsMetadata && contains(metaFields, key)) needsMetadata = true;
  });

  if (needsMetadata) updateMetadata(model, needsImage);else if (needsImage) updateImage(model);

  if (needsAnnotatedData) updateAnnotatedData(model);

  if (needsPopularity) updatePopularity(model);

  if (needsShouldBeOffline || needsOfflineProgress || needsOfflineStatus) updateOffline(model);

  if (needsPlayable) updateAndSubscribePlayable(model);

  if (needsFormatListType) updateFormatListType(model);
}

function onInit(model) {
  bridgeWait(model);
  if (global._getSpotifyModule) {
    bridgeWaitAny(model);
  }
}

function onPublish(model, properties) {
  // Only shouldBeOffline is handled here
  if (!properties.hasOwnProperty('shouldBeOffline')) {
    return;
  }

  live(CLIENT).query('session(capabilities(offlineSync))', function (error, data) {
    if (error && global.console) console.error(error);
    if (error || !data.session.capabilities.offlineSync) {
      sendCantOfflineMessage();
    } else {
      var shouldBeOfflineValue;

      if ('shouldBeOffline' in properties) shouldBeOfflineValue = !!properties.shouldBeOffline;

      if (shouldBeOfflineValue !== undefined) {
        // optimistic update, this gets reverted somewhere else
        updateModelWithOffline(model, { offline_availability: shouldBeOfflineValue ? 'yes' : 'no' });
        publishShouldBeOffline(model, shouldBeOfflineValue);
      }
    }
  }, live.ASAP);
}

function onUpdate(model, data) {
  if ('offlineStatus' in data) {
    var shouldBeOffline = model.get('shouldBeOffline');
    var isDownloading = data.offlineStatus === OFFLINE_STATUS.DOWNLOADING;
    var shouldSubscribe = shouldBeOffline && isDownloading;

    if (shouldSubscribe) {
      subscribeToOfflineProgress(model);
    } else {
      unsubscribeToOfflineProgress(model);
    }
  }
}

function updateOffline(model) {
  cosmos.subscribe({ url: 'sp://offline/v1/resources?uri=' + model.uri }, function (error, response) {

    if (!error) {
      var resource = response.body.resources;
      updateModelWithOffline(model, resource);
    } else {
      // Status -104 means 'No endpoint resolver that could handle the request was found'.
      // If that's the case, we try the old bridge offline messages, and if that's not supported,
      // we treat it like the client doesn't support offline.
      if (error.response && error.response.getStatusCode() === -104) {

        // Desktop detection using the C++ bridge function
        if (global._getSpotifyModule) {
          bridgeRequest('offline_query_state', [model.uri], function (error, data) {
            if (error) {
              if (global.console) console.error(error);
              return;
            }
            updateModelWithOffline(model, { offline_availability: data.enabled ? 'yes' : 'no' });
          });

          // Client doesn't support offline, so set the offline status to 'no'
        } else {
            updateModelWithOffline(model, { offline_availability: 'no' });
          }
      } else {
        if (global.console) console.error(error);
        return;
      }
    }
  });
}

function updateModelWithOffline(model, resource) {
  var shouldBeOffline = false;
  var progress;

  switch (resource.offline_availability) {
    case OFFLINE_STATUS.WAITING:
      shouldBeOffline = true;
      progress = 0;
      break;
    case OFFLINE_STATUS.DOWNLOADING:
      shouldBeOffline = true;
      break;
    case OFFLINE_STATUS.YES:
      shouldBeOffline = true;
      progress = 1;
      break;
    case OFFLINE_STATUS.NO:
      progress = 0;
      break;
  }

  // Updating this one will cause the 'update' event to start listening for
  // progress changes and update offlineProgress.
  model.update({
    shouldBeOffline: shouldBeOffline,
    offlineStatus: resource.offline_availability
  });

  if (progress !== undefined) {
    model.update({
      offlineProgress: progress
    });
  }
}

function updateAndSubscribePlayable(model) {
  // Todo: It would be nice to take the users cache state into account,
  // a ticket for that: KM-8283. 'playable' would then change meaning from
  // 'according to track metadata' to 'according to track metadata and cache
  // state when offline', but that can be seen as a progressive enhancement.
  var playableRows = endpoints['core-playlist'] + '/' + encodeURIComponent(model.uri) + '/metadata?&filter=playable%20eq%20true';
  cosmos.subscribe({
    url: playableRows,
    body: {
      policy: {
        length: true
      }
    }
  }, function (error, response) {
    if (!error) {
      model.update({ playable: !!response.body.metadata.length });
    } else {
      console.error(error);
    }
  });
}

function updateFormatListType(model) {
  var url = 'sp://core-playlist/v1/playlist/' + encodeURIComponent(model.uri) + '/metadata';

  cosmos.get({ url: url }, function (error, response) {
    var formatListType = 'playlist';
    if (!error && response.body && response.body.metadata && response.body.metadata.formatListType) {
      formatListType = response.body.metadata.formatListType;
    }
    model.update({
      formatListType: formatListType
    });
  });
}

function subscribeToOfflineProgress(model) {
  var subscription = offlineSubscriptions[model.uri];
  if (subscription) {
    return;
  }
  offlineSubscriptions[model.uri] = cosmos.subscribe({ url: 'sp://offline/v1/progress?uri=' + model.uri }, function (error, response) {

    if (!error) {
      var progress = response.body.progress;
      model.update({ offlineProgress: progress.percent_complete / 100 || 0 });

      // unsubscribe to offline progress messages when the download is complete
      // (sometimes after a complete download we receive a progress event of 0)
      if (progress.percent_complete === 100) {
        unsubscribeToOfflineProgress(model);
      }
    } else {
      // Status -104 means 'No endpoint resolver that could handle the request was found'.
      // If that's the case, we try the old bridge offline messages, and if that's not supported,
      // we treat it like the client doesn't support offline.
      if (error.response && error.response.getStatusCode() === -104) {

        // Desktop detection using the C++ bridge function
        if (global._getSpotifyModule) {
          bridgeRequest('offline_query_state', [model.uri], function (error, data) {
            if (error) {
              if (global.console) console.error(error);
              return;
            }
            model.update({ offlineProgress: data.enabled ? 1 : 0 });
          });

          // Client doesn't support offline, so set the offline status to 'no'
        } else {
            model.update({ offlineProgress: 0 });
          }
      } else {
        if (global.console) console.error(error);
        return;
      }
    }
  });
}

function unsubscribeToOfflineProgress(model) {
  var subscription = offlineSubscriptions[model.uri];
  if (!subscription) {
    return;
  }

  subscription.cancel();
  delete offlineSubscriptions[model.uri];
}

function publishShouldBeOffline(model, enabled) {
  var method = enabled ? 'post' : 'delete';
  cosmos[method]({ url: 'sp://offline/v1/resources?uri=' + model.uri }, function (error, response) {

    if (error) {
      // Status -104 means 'No endpoint resolver that could handle the request was found'.
      // If that's the case, we try the old bridge offline messages, and if that's not supported,
      // we treat it like the client doesn't support offline.
      if (error.response && error.response.getStatusCode() === -104) {

        // Desktop detection using the C++ bridge function
        if (global._getSpotifyModule) {
          var message = enabled ? 'offline_enable_sync' : 'offline_disable_sync';
          bridgeRequest(message, [model.uri], function (error, data) {

            // Revert the state if it failed
            if (error) {
              updateModelWithOffline(model, {
                offline_availability: enabled ? 'no' : 'yes'
              });
            }
          });

          // Client doesn't support offline, so set the offline status to 'no'
        } else {
            updateModelWithOffline(model, {
              offline_availability: enabled ? 'no' : 'yes'
            });
          }
      } else {
        updateModelWithOffline(model, {
          offline_availability: enabled ? 'no' : 'yes'
        });
      }
    }
  });
}

function sendCantOfflineMessage() {
  cosmos.post({
    url: 'sp://messages/v1/container/user-message',
    body: {
      id: 'cant-offline-playlists'
    }
  });
}

var regExp = exports.matches = /^spotify:user:(.*):playlist|^spotify:internal:temp_playlist:|^spotify:temp-playlist:/;
var broadcastSubscription;
var registered;
exports.register = function () {
  if (registered) return;
  registered = true;

  live.subscribe(regExp, 'wait', onWait);
  live.subscribe(regExp, 'init', onInit);
  live.subscribe(regExp, 'publish', onPublish);
  live.subscribe(regExp, 'update', onUpdate);

  broadcastSubscription = cosmos.subscribe({ url: endpoints.broadcast }, onBroadcast);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  live.unsubscribe(regExp, 'wait', onWait);
  live.unsubscribe(regExp, 'init', onInit);
  live.unsubscribe(regExp, 'publish', onPublish);
  live.unsubscribe(regExp, 'update', onUpdate);

  broadcastSubscription.cancel();
  broadcastSubscription = null;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-live":118,"./util/bridge":113,"./util/cosmos":115,"debug":159,"interpolate":192,"mout/array/contains":194,"mout/array/intersection":202,"mout/object/mixIn":224,"spotify-liburi":256}],111:[function(require,module,exports){
(function (global){
/**
 * @module spotify-live-models/track
 */
'use strict';

var live = require('../spotify-live');
var liburi = require('spotify-liburi');
var intersection = require('mout/array/intersection');
var contains = require('mout/array/contains');
var bridge = require('./util/bridge').request;
var cosmos = require('./util/cosmos');
var util = require('./util/common');

var BACKOFF = 100;
var localFilesRequest = null;

var metaFields = ['album', 'artists', 'availability', 'disc', 'duration', 'explicit', 'image', 'local', 'name', 'number', 'placeholder', 'playable', 'popularity', 'linkedTrack'];

function onWait(model, properties) {
  // Set the 'unavailable' property based on the 'playable' property
  if (contains(properties, 'unavailable')) {
    model.get('playable', function (error, playable) {
      if (error) {
        if (global.console) console.error(error);
        return;
      }
      model.update({ unavailable: !playable });
    });
  }

  var hasMetadata = !!intersection(properties, metaFields).length;

  if (hasMetadata) updateMetadata(model);

  var needsShouldBeOffline = contains(properties, 'shouldBeOffline');
  var needsOfflineProgress = contains(properties, 'offlineProgress');
  if (needsShouldBeOffline || needsOfflineProgress) {
    updateOffline(model);
  }
}

function updateMetadata(model) {
  bridge('track_metadata', [model.uri], function (error, payload) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }
    util.setLocalProperties(payload);
    payload.image = largestImage(payload);

    // The linkedTrack is not available everywhere, so do fallback
    if (payload.linkedTrack) {
      payload.linkedTrack = { uri: payload.linkedTrack };
    } else {
      payload.linkedTrack = null;
    }

    model.update(payload);
  });
}

function largestImage(trackMetadata) {
  var imageURI = trackMetadata.image;
  var largestSize;

  if (trackMetadata.images) {
    for (var i = 0; i < trackMetadata.images.length; i++) {
      var currentImage = trackMetadata.images[i];
      if (!largestSize || currentImage[0] > largestSize) {
        largestSize = currentImage[0];
        imageURI = currentImage[1];
      }
    }
  }

  return imageURI;
}

function updateOffline(model) {

  // Local tracks are available offline if they are playable
  if (liburi.fromString(model.uri).type === liburi.Type.LOCAL) {
    model.get('playable', function (error, playable) {
      if (error) {
        if (global.console) console.error(error);
        return;
      }
      model.update({
        shouldBeOffline: playable,
        offlineProgress: playable ? 1 : 0
      });
    });
    return;
  }

  cosmos.subscribe({ url: 'sp://offline/v1/resources?uri=' + model.uri }, function (error, response) {

    if (!error) {
      var resource = response.body.resources;
      updateModelWithOfflineData(model, resource);
    } else {
      // Status -104 (or 404 in web player) means 'No endpoint resolver that could handle the request was found'.
      // If that's the case, we handle it like the client doesn't support offline.
      var statusCode = error.response && error.response.getStatusCode();
      if (statusCode === -104 || statusCode === 404) {
        updateModelWithOfflineData(model, { offline_availability: 'no' });
      } else {
        if (global.console) console.error(error);
        return;
      }
    }
  });
}

function updateModelWithOfflineData(model, resource) {
  var shouldBeOffline = false;
  var offlineProgress = 0;

  switch (resource.offline_availability) {
    case 'waiting':
      shouldBeOffline = true;offlineProgress = 0;break;
    case 'downloading':
      shouldBeOffline = true;offlineProgress = 0.5;break;
    case 'yes':
      shouldBeOffline = true;offlineProgress = 1;break;
  }

  model.update({
    shouldBeOffline: shouldBeOffline,
    offlineProgress: offlineProgress
  });
}

function waitForLocalFilesChange() {
  localFilesRequest = cosmos.subscribe({ url: 'sp://local-files/v1/changes' }, function (error, response) {
    if (!registered) return;

    if (error) {
      // Status -104 (or 404 in web player) means 'No endpoint resolver that could handle the request was found'.
      // If that's the case, we bail out and don't do anything.
      var statusCode = error.response && error.response.getStatusCode();
      if (statusCode === -104 || statusCode === 404) {
        return;
      }
      if (global.console) console.error(error);
      return;
    }

    var event = response.body;
    var data = event.data;
    var type = event.type;
    var isAdded = type === 'added';
    var isRemoved = type === 'removed';

    if (isAdded || isRemoved) {
      data.tracks.forEach(function (track) {
        live(track.uri).update({
          shouldBeOffline: isAdded,
          offlineProgress: isAdded ? 1 : 0,
          playable: isAdded
        });
      });
    }
  });
}

function waitForTrackChange() {
  bridge('track_event_wait_any', [], function (error, event) {
    if (!registered) return;

    if (error) {
      setTimeout(function () {
        waitForTrackChange();
      }, BACKOFF);
      if (global.console) console.error(error);
      return;
    }

    waitForTrackChange();

    if (event.type === 'change') {
      if (event.data.playable !== undefined) {
        event.data.unavailable = !event.data.playable;
      }
      live(event.data.uri).update(event.data);
    }
  });
}

var regExp = exports.matches = /^spotify:track:|^spotify:local:[^:]*:[^:]*:[^:]*:\d*$/;
var registered;
exports.register = function () {
  if (registered) return;
  registered = true;

  live.subscribe(regExp, 'wait', onWait);

  waitForLocalFilesChange();

  // Only desktop has support for track relinking
  if (!!global._getSpotifyModule) waitForTrackChange();
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  live.unsubscribe(regExp, 'wait', onWait);

  if (localFilesRequest) {
    localFilesRequest.cancel();
    localFilesRequest = null;
  }
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-live":118,"./util/bridge":113,"./util/common":114,"./util/cosmos":115,"mout/array/contains":194,"mout/array/intersection":202,"spotify-liburi":256}],112:[function(require,module,exports){
(function (global){
/**
 * @module spotify-live-models/user
 */
'use strict';

var live = require('../spotify-live');
var liburi = require('spotify-liburi');
var contains = require('mout/array/contains');
var intersection = require('mout/array/intersection');
var bridge = require('./util/bridge').request;

function updateMetadata(model) {
  bridge('user_metadata', [model.uri], function (error, payload) {
    if (error && global.console) console.error(error);

    if (!payload) payload = {};

    payload.username = payload.username || liburi.from(model.uri).username;
    payload.name = payload.name || payload.username;
    payload.image = payload.image || '';
    payload.images = payload.images || [];

    if (payload.subscribed == null) {
      payload.subscribed = false;
    }

    if (payload.currentUser == null) {
      live('spotify:client').query('currentUser(uri)', function (error, data) {
        if (error) {
          if (global.console) console.error(error);
          return;
        }
        model.update({ currentUser: model.uri === data.currentUser.uri });
      });
    }

    model.update(payload);
  });
}

function updateArtist(model) {
  bridge('user_associated_artist', [model.uri], function (error, payload) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }
    var artist = payload.artist ? { uri: payload.artist } : null;
    model.update({ artist: artist });
  });
}

function onWait(model, properties) {
  var hasArtist = contains(properties, 'artist');
  var metaFields = ['currentUser', 'name', 'username', 'image', 'images', 'subscribed'];
  var hasMetadata = !!intersection(properties, metaFields).length;

  if (hasMetadata) updateMetadata(model);
  if (hasArtist) updateArtist(model);
}

var regExp = exports.matches = /^spotify:user:[^:]+$/;
var registered;
exports.register = function () {
  if (registered) return;
  registered = true;

  live.subscribe(regExp, 'wait', onWait);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  live.unsubscribe(regExp, 'wait', onWait);
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-live":118,"./util/bridge":113,"mout/array/contains":194,"mout/array/intersection":202,"spotify-liburi":256}],113:[function(require,module,exports){
/**
 * @module spotify-live-models/util/bridge
 * @private
 */

'use strict';

var bridge = require('../../spotify-bridge-request');

module.exports = {
  request: bridge.request
};

},{"../../spotify-bridge-request":34}],114:[function(require,module,exports){
'use strict';

var liburi = require('spotify-liburi');

function setLocalProperties(track) {
  if (track.album && track.album.uri) {
    var albumType = liburi.from(track.album.uri).type;
    track.album.local = albumType === liburi.Type.LOCAL_ALBUM;
  }
  if (track.artists) {
    for (var i = 0, l = track.artists.length; i < l; i++) {
      var artist = track.artists[i];
      if (artist.uri) {
        var artistType = liburi.from(artist.uri).type;
        artist.local = artistType === liburi.Type.LOCAL_ARTIST;
      }
    }
  }
}

/**
 * Export public interface
 */
module.exports = {
  setLocalProperties: setLocalProperties
};

},{"spotify-liburi":256}],115:[function(require,module,exports){
(function (global){
/**
 * @module spotify-live-models/util/cosmos
 * @private
 */

'use strict';

var cosmos = require('spotify-cosmos-api');

function DELETE(options, opt_callback) {
  options.method = exports.cosmos.Action.DELETE;
  return request(options, opt_callback);
}

function GET(options, opt_callback) {
  options.method = exports.cosmos.Action.GET;
  return request(options, opt_callback);
}

function SUB(options, opt_callback) {
  options.method = exports.cosmos.Action.SUB;
  return request(options, opt_callback);
}

function POST(options, opt_callback) {
  options.method = exports.cosmos.Action.POST;
  return request(options, opt_callback);
}

function PUT(options, opt_callback) {
  options.method = exports.cosmos.Action.PUT;
  return request(options, opt_callback);
}

function HEAD(options, opt_callback) {
  options.method = exports.cosmos.Action.HEAD;
  return request(options, opt_callback);
}

function request(options, opt_callback) {
  var method = options.method;
  delete options.method;

  var subscription, canceled;

  sanitizeURL(options.url, function (error, url) {
    if (error) return opt_callback && opt_callback(error);

    // if you cancel before the userName is replaced.
    if (canceled) return;

    var request = new exports.cosmos.Request(method || exports.cosmos.Action.GET, url, options.headers, options.body);
    subscription = exports.cosmos.resolver.resolve(request, function (error, response) {
      if (!opt_callback) return;
      if (error) return opt_callback(error);
      try {
        opt_callback(null, {
          body: JSON.parse(response.getBody() || '{}'),
          headers: response.getHeaders(),
          status: response.getStatusCode()
        });
      } catch (parseError) {
        parseError.response = response;
        opt_callback(parseError);
      }
    });
  });

  return {
    cancel: function cancel() {
      if (subscription && subscription.cancel) {
        // we already subscribed, cancel it.
        subscription.cancel();
        subscription = null;
      } else if (!canceled) {
        // not subscribed yet, don't even subscribe.
        canceled = true;
      }
      return null;
    }
  };
}

function sanitizeURL(url, callback) {
  if (url.indexOf('@') > -1) {
    callback(null, url.replace('@', encodeURIComponent(global.__spotify.username)));
  } else {
    callback(null, url);
  }
}

exports.request = request;
exports.get = GET;
exports.post = POST;
exports.subscribe = SUB;
exports.delete = DELETE;
exports.put = PUT;
exports.head = HEAD;
exports.cosmos = cosmos;

exports.sanitizeURL = sanitizeURL;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"spotify-cosmos-api":246}],116:[function(require,module,exports){
'use strict';

var base = 'spotify:internal:sortlist';
var regExp = /^spotify:internal:sortlist:(asc|desc):([^:]*):(.*)$/;

/**
 * Create a URI representing a sorted variant of a list.
 *
 * @param {string} originUri The original list URI.
 * @param {string} direction The direction of the sorted list ('asc' or 'desc').
 * @param {string} query The query string (compatible with spotify-live). Sorting
 *     implementations might not look at all values. The list of produced values
 *     from the query will be tried in order from left to right. If two items have
 *     the same value, it will look at the next produced value from this query.
 *     Any spaces in the query will be removed.
 *
 * @return {string} URI of the sorted variant of the list. The URI will have
 *     the query string URL encoded.
 */
exports.create = function (originUri, direction, query) {
  originUri = originUri.replace(/^spotify:/, '');

  query = encodeURIComponent(query);
  query = query.replace(/%20/g, '');

  return [base, direction, query, originUri].join(':');
};

/**
 * Get the direction of the sorted list.
 *
 * @param {string} sortUri The URI of the sorted list.
 *
 * @return {string} The direction of the sort ('asc' or 'desc'). If URI is
 *     invalid, this returns an empty string.
 */
exports.getDirection = function (sortUri) {
  var matches = sortUri.match(regExp);
  if (!matches) return '';

  return matches[1];
};

/**
 * Get the query string from a sort URI.
 *
 * @param {string} sortUri The URI of the sorted list.
 *
 * @return {string} The query string, URL decoded. If URI is
 *     invalid, this returns an empty string.
 */
exports.getQuery = function (sortUri) {
  var matches = sortUri.match(regExp);
  if (!matches) return '';

  return decodeURIComponent(matches[2]);
};

/**
 * Get the URI of the original list.
 *
 * @param {string} sortUri The URI of the sorted list.
 *
 * @return {string} The URI of the original list. If the sort URI is invalid,
 *     this returns an empty string.
 */
exports.getOriginUri = function (sortUri) {
  var matches = sortUri.match(regExp);
  if (!matches) return '';

  return 'spotify:' + matches[3];
};

/**
 * Parse and return all parts of the sort URI.
 *
 * @param {string} sortUri The URI of the sorted list.
 *
 * @return {Object?} An object with properties `direction`, `query` and `originUri`,
 *     or null if the URI is not valid.
 */
exports.parse = function (sortUri) {
  var matches = sortUri.match(regExp);
  if (!matches) return null;

  return {
    direction: matches[1],
    query: decodeURIComponent(matches[2]),
    originUri: 'spotify:' + matches[3]
  };
};

/**
 * Test if the provided URI is a valid sort URI.
 *
 * @param {string} sortUri The URI of the sorted list.
 *
 * @return {boolean} True if it's valid, false otherwise.
 */
exports.isValid = function (sortUri) {
  return regExp.test(sortUri);
};

/**
 * The regular expression that matches sort URIs.
 */
exports.regExp = regExp;

},{}],117:[function(require,module,exports){
'use strict';

var sortUriUtils = require('../spotify-live-sort-uri');
var filterUriUtils = require('../spotify-live-filter-uri');

/**
 * Create a URI representing a wrapped variant of a list.
 *
 * @param {object} opts The options.
 * @param {string} opts.originUri The origin uri.
 * @param {object?} opts.filter The filter, if any
 * @param {object?} opts.sort The sorting, if any
 *
 * @return {string} URI of the wrapped variant of the list.
 */
exports.create = function (opts) {
  var uri = opts.originUri;
  if (opts.filter) {
    uri = filterUriUtils.create(uri, opts.filter.query);
  }
  if (opts.sort) {
    uri = sortUriUtils.create(uri, opts.sort.direction, opts.sort.query);
  }
  return uri;
};

/**
 * Get the URI of the original list.
 *
 * @param {string} sortUri The URI of the wrapped list.
 *
 * @return {string} The URI of the original list. If the wrapped URI is invalid,
 *     this returns an empty string.
 */
exports.getOriginUri = function (wrappedUri) {
  var parsed = exports.parse(wrappedUri);
  return parsed && parsed.originUri || '';
};

/**
 * Parse and return all parts of the wrapped URI.
 *
 * @param {string} wrappedUri The URI of the wrapped list.
 *
 * @return {object} An object with properties `originUri`, `sort` and `filter`.
 */
exports.parse = function (wrappedUri) {
  var sort = sortUriUtils.parse(wrappedUri);
  var filter = filterUriUtils.parse(sort && sort.originUri || wrappedUri);
  if (!(sort || filter)) return null;

  return {
    originUri: filter && filter.originUri || sort && sort.originUri,
    sort: sort,
    filter: filter
  };
};

/**
 * Test if the provided URI is a valid wrapped URI.
 *
 * @param {string} wrappedUri The URI of the wrapped list.
 *
 * @return {boolean} True if it's valid, false otherwise.
 */
exports.isValid = function (wrappedUri) {
  return !!exports.parse(wrappedUri);
};

},{"../spotify-live-filter-uri":105,"../spotify-live-sort-uri":116}],118:[function(require,module,exports){
(function (global){
/**
 * @module live
 */'use strict';

// prime

var prime = require('prime');
var defer = require('prime/defer');
var Emitter = require('prime/emitter');

// mout
var isPlainObject = require('mout/lang/isPlainObject');
var isArray = require('mout/lang/isArray');
var isRegExp = require('mout/lang/isRegExp');
var isNumber = function isNumber(n) {
  return typeof n === 'number';
};
var isString = function isString(s) {
  return typeof s === 'string';
};

var escapeRegExp = require('mout/string/escapeRegExp');

var _difference = require('mout/array/difference');
var filter = require('mout/array/filter');
var combine = require('mout/array/combine');
var map = require('mout/array/map');

var deepMixIn = require('mout/object/deepMixIn');
var pick = require('mout/object/pick');
var keys = require('mout/object/keys');

// finally
var flow = require('finally');

// util
var OrderedSet = require('./util/ordered-set');
var Range = require('../spotify-range2');
var parse = require('./util/parser');
var throttle = require('./util/throttle');

// methods

var isLiveList = function isLiveList(item) {
  return item instanceof LiveList;
};

var isLiveObject = function isLiveObject(item) {
  return item instanceof LiveObject;
};

// Simple, stupid and fast.
// Shallow, not checking hasOwnProperty.
var simpleClone = function simpleClone(object) {
  var clone = {};
  for (var key in object) {
    clone[key] = object[key];
  }
  return clone;
};

var difference = function difference(a, b) {
  return a.length === 0 ? [] : _difference.apply(this, arguments);
};

var values = function values(object, keys) {
  var values = [];
  var key;
  for (var i = 0, len = keys.length; i < len; i++) {
    key = keys[i];
    if (key in object) values.push(object[key]);else values.length++;
  }
  return values;
};

// subtract ranges2 from ranges1
var rdifference = function rdifference(ranges1, ranges2) {
  if (!ranges1.length) return [];

  var resultingRanges = [];

  for (var i = 0, len = ranges1.length; i < len; i++) {
    var range = ranges1[i];
    resultingRanges = resultingRanges.concat(range.subtract(ranges2));
  }

  // Make sure we don't have overlapping ranges
  resultingRanges = new Range(0, 0).merge(resultingRanges);

  // Remove any empty ranges
  resultingRanges = filter(resultingRanges, function (range) {
    return !!range.length;
  });

  return resultingRanges;
};

// merge ranges1 into ranges2
var rcombine = function rcombine(ranges1, ranges2) {
  for (var i = 0, len = ranges1.length; i < len; i++) {
    var range = ranges1[i];
    ranges2 = range.merge(ranges2);
  }
  return ranges2;
};

// util
var IDX = 0;

var slice_ = Array.prototype.slice;

var transform = function transform(item, method) {

  if (isPlainObject(item)) {
    // plain objects need to be liveified
    if ('operations' in item) return new LiveList().update(item.operations);
    return live(item.uri)._update(item, method);
  }

  if (isArray(item)) {
    // arrays need to be liveified
    return new LiveList()._update([{
      type: 'insert',
      index: 0,
      length: item.length,
      values: item
    }], method);
  }
  return item;
};

// Creates a callback with a timeout.
function createTimedCallback(callback, timeout) {
  var called;
  var timeoutId = setTimeout(function () {
    called = true;
    callback(new Error('Timeout Expired: ' + timeout + ' milliseconds'));
  }, timeout);
  return function () {
    if (!called) {
      clearTimeout(timeoutId);
      callback.apply(this, arguments);
    }
  };
};

var LiveList = prime( /** @lends LiveList.prototype */{

  mixin: Emitter,

  /**
   * A representation of an array which may be observed for changes
   * @constructs
   * @mixes Emitter
   * @param {Number} [length] - A number representing the length of the liveList.
   */
  constructor: function LiveList(length) {
    this._data = new OrderedSet(length);
    this._mergeThrottled = throttle(this._merge, this);
    this._waiting = [];

    var self = this;
    var lastWait = '';

    if (live.debug) setInterval(function () {
      var thisWait = self._waiting.toString();
      if (lastWait === thisWait) return;
      lastWait = thisWait;

      if (self._waiting.length) {
        console.warn(self, 'waiting for', self._waiting);
      } else {
        console.warn(self, 'all done');
      }
    }, 2000);
  },

  get index() {
    return this._data.index;
  },

  get length() {
    return this._data.length;
  },

  get keys() {
    return this._data.keys;
  },

  get values() {
    return this._data.values;
  },

  indexOf: function indexOf(key) {
    return this._data.indexOf(key);
  },

  indexOfMany: function indexOfMany(keys) {
    return this._data.indexOfMany(keys);
  },

  valueOf: function valueOf(key) {
    return this._data.valueOf(key);
  },

  hasKey: function hasKey(key) {
    return this._data.hasKey(key);
  },

  forEach: function forEach(fn, ctx) {
    this._data.forEach(fn, ctx);
    return this;
  },

  map: function map(fn, ctx) {
    return this._data.map(fn, ctx);
  },

  _merge: function _merge() {
    var data = this._data; // actual data
    var publish = this._publish; // new items on top of a copy of data || null
    var before = this._before; // an old copy of data || null

    if (publish) {
      delete this._publish;
      if (this._listeners && this._listeners.publish) {
        var publishDiff = data.diff(publish);
        if (publishDiff.length) this.emit('publish', publishDiff, EMIT_SYNC);
      }
    } else if (before) {
      delete this._before;
      if (this._listeners && this._listeners.update) {
        var updateDiff = before.diff(data);
        if (updateDiff.length) this.emit('update', updateDiff, EMIT_SYNC);
      }
    }
    return this;
  },

  _update: function _update(operations, method) {

    var branch;
    if (method === PUBLISH) {
      // it was receiving, cannot publish.
      if (this._before) return this;
      branch = this._publish || (this._publish = this._data.clone());
    } else if (method === UPDATE) {
      // it was publishing, delete it.
      if (this._publish) delete this._publish;
      if (!this._before) this._before = this._data.clone();
      branch = this._data;
    }

    var op;
    for (var opIndex = 0, opLen = operations.length; opIndex < opLen; opIndex++) {
      op = operations[opIndex];
      switch (op.type) {
        case 'length':
          branch.length = op.length;break;
        case 'sort':
          branch.sort(op.compareFunction);break;
        case 'move':
          branch.move(op.from, op.to, op.length);break;
        case 'remove':
          branch.remove(op.index, op.length);break;
        case 'insert':
          var values = [];
          var keys = op.keys || [];
          for (var i = 0, len = op.values.length; i < len; i++) {
            if (!op.keys || !op.keys[i]) keys[i] = (IDX++).toString(36);
            values[i] = transform(op.values[i], method);
          }
          branch.insert(op.index, keys, values);
          break;
      }
    }

    if (method === UPDATE) this._waiting = rdifference(this._waiting, this.index);

    this._mergeThrottled();
    return this;
  },

  publish: function publish(operations) {
    return this._update(operations, PUBLISH);
  },

  update: function update(operations) {
    return this._update(operations, UPDATE);
  },

  /**
   * Serialize the data in this list into a plain object.
   *
   * @param {number=} limit Optional limit parameter. Controls how many levels
   *     deep to serialize.
   *
   * @return {Array} The data array.
   */
  serialize: function serialize(limit) {
    if (limit === 0) return [];

    var array = [];
    var nextLimit = limit === undefined ? undefined : limit - 1;

    for (var i = 0; i < this.length; i++) {
      var value = this.values[i];
      var serializedValue = value;
      if (value && value.serialize) {
        serializedValue = value.serialize(nextLimit);
      }
      array.push(serializedValue);
    }

    return array;
  },

  _getDataFromMask: function _getDataFromMask(mask) {
    var items = [];

    if (mask.length > 0) {
      // The provided mask to a list is the mask for each list item, so we need
      // to loop through all the items and get the data from each item based on
      // the mask.
      for (var i = 0, l = this.length; i < l; i++) {
        var item = this.get(i);
        var parsedItem;
        var isObjectOrList = item && item._getDataFromMask;
        if (isObjectOrList) {
          parsedItem = item._getDataFromMask(mask);
        }
        items.push(parsedItem);
      }
    }

    return items;
  },

  _query: function _query(selector, callback, mode) {
    var self = this;

    var query = function query() {
      queryList(self, selector, function (error, data, wasSync) {
        if (error) return callback(error);

        if (!wasSync) {
          self._query(selector, callback, mode);
        } else {
          callback(null, data);
        }
      });
    };

    if (mode === ASYNC) defer(query);else query();
  },

  /**
   * Query properties in this list.
   * This can be called in two different ways: with a callback or without. When
   * calling it with a callback, it will wait for any missing data and always
   * return the data you queried for. When calling it without a callback, it
   * will return an array structure with only the data that was found in the
   * object at the moment. It will not kick off any events for waiting for
   * properties.
   *
   * @param {String} selector - The query selector. Only selectors without
   *     filters are supported when not providing a callback.
   * @param {Array} params - The query replace parameters.
   * @param {LiveList~queryCallback} callback - The callback that handles the response.
   * @param {Object} [mode] live.SYNC: Force sync, 2: live.ASAP: Don't force async
   * @param {Number} timeout - optional timeout in milliseconds
   *
   * @return {LiveList|Array} If no callback is passed it returns an array with
   *                             the data matching the query, that was found at
   *                             the moment in the list.
   *                             If a callback is passed it returns the instance.
   */
  query: function query(selector, params, callback, mode, timeout) {
    /**
     * @callback LiveList~queryCallback
     * @param {Error|Null} error - An error that you can throw, or null.
     * @param {Array} [data] - The response as an array.
     */
    if (typeof params === 'function') {
      // shift for empty params
      timeout = mode;
      mode = callback;
      callback = params;
      params = [];
    }

    if (!callback) {
      return this._getDataFromMask(parse(selector, params).mask);
    }

    if (!mode) {
      mode = ASYNC;
    } else if (isNumber(mode)) {
      // shift once again
      timeout = mode;
      mode = ASYNC;
    }

    if (timeout) {
      callback = createTimedCallback(callback, timeout);
    }

    this._query(parse(selector, params), callback, mode);
    return this;
  },

  _wait: function _wait(ranges) {
    if (!this._required) {
      // if _required is set, it was deferred already
      this._required = [];
      defer(function () {
        var missingFromIndex = this.missing(this._required);
        var missingFromWaiting = rdifference(missingFromIndex, this._waiting);
        this._waiting = rcombine(this._waiting, missingFromWaiting);
        delete this._required;
        if (missingFromWaiting.length) this.emit('wait', missingFromWaiting, EMIT_SYNC);
      }, this);
    }
    this._required = rcombine(this._required, ranges);
  },

  missing: function missing(ranges) {
    return rdifference(ranges, this.index);
  },

  // the raw, unbeautified get
  // this can callback sync or async
  _get: function _get(ranges, callback) {
    if (this.missing(ranges).length) {
      // has missing stuff (no matter what)
      this._wait(ranges);

      var check = function check() {
        var needed = this.missing(ranges);
        if (!needed.length) {
          this.off('update', check);
          callback.call(this);
        }
      };

      this.on('update', check);
    } else {
      // the callback is called with 'true' when syncronous.
      callback.call(this, null, true);
    }
  },

  /**
   * Checks if the range has been set with values in the list.
   *
   * @param {number} fromIndex The index to start from.
   * @param {number=} toIndex Optional index to stop at (non-inclusive). If no
   *     toIndex is specified, it will default to the index after fromIndex, to
   *     check for the single item at fromIndex.
   *
   * @return {Boolean} True if the range has been set.
   */
  has: function has(fromIndex, toIndex) {
    var hasToIndex = toIndex !== undefined;
    if (!hasToIndex) toIndex = fromIndex + 1;

    var range = new Range(fromIndex, toIndex);

    return range.contained(this.index);
  },

  /**
   * Gets items from the list between the specified indices.
   * @param {Number} what - The index to start from.
   * @param {Number} [toIndex=fromIndex + 1] - The index to stop at (non-inclusive).
   * @param {LiveList~getCallback} [callback] - Optional callback function. If no toIndex
   *     is specified, the callback can be placed as the second argument.
   * @param {Object} [mode] live.SYNC: Force sync, 2: live.ASAP: Don't force async
   * @param {Number} timeout - optional timeout in milliseconds
   * @return {LiveList|Array} If no callback is specified, returns the requested items in an array.
   *                          If a callback is specified, the method returns the instance.
   */
  get: function get(fromIndex, toIndex) {
    /**
     * @callback LiveList~getCallback
     * @param {Error|Null} error - An error that you can throw, or null.
     * @param {Array|*} [data] - The response as an array.
     *                           If toIndex is not specified a single item on the list is passed.
     */

    // fast, get one
    if (arguments.length === 1) {
      if (isNumber(fromIndex)) return this.values[fromIndex];
      if (isString(fromIndex)) return this.valueOf(fromIndex);
    }

    var self = this;

    var args = slice_.call(arguments);
    var callback, mode, requested;

    for (var i = 0, len = args.length; i < len; i++) {
      var arg = args[i];
      if (typeof arg === 'function') {
        var split = args.splice(i, 3);
        len = args.length;
        callback = split[0];
        if (split[1]) {
          if (split[1] === SYNC || split[1] === ASYNC || split[1] === ASAP) {
            mode = split[1];
          } else {
            // assume this arg is a timeout
            mode = ASYNC;
            callback = createTimedCallback(callback, split[1]);
            break;
          }
          // is there a timeout ?
          if (split[2] && mode !== SYNC) {
            callback = createTimedCallback(callback, split[2]);
          }
        } else {
          mode = ASYNC;
        }
        break;
      }
    }

    var asArray = false;
    var asSingleValue = false;

    if (fromIndex instanceof Range) {
      // one range
      requested = args;
      asArray = !callback && requested.length > 1;
    } else if (isArray(fromIndex)) {
      // array of ranges
      asArray = true;
      requested = fromIndex;
    } else {
      // numbers ?
      var hasToIndex = !isNaN(toIndex);
      if (!hasToIndex) toIndex = fromIndex + 1;
      asSingleValue = !hasToIndex;
      requested = [new Range(fromIndex, toIndex)];
    }

    var result = function result() {
      return map(requested, function (range) {
        return self.values.slice(range.start, range.end);
      });
    };

    var done = function done() {
      if (asArray) callback.call(self, null, result());else if (asSingleValue) callback.call(self, null, self.values[fromIndex]);else callback.apply(self, [null].concat(result()));
    };

    if (!callback) {
      if (asArray) return result();
      return result()[0];
    } else if (mode === SYNC) {
      done();
    } else {
      if (mode === ASYNC && !this.missing(requested).length) {
        // it has all the data but needs to be ASYNC
        defer(function () {
          this._get(requested, done);
        }, this);
      } else {
        this._get(requested, done);
      }
    }
    return this;
  }

});

var LiveObject = prime( /** @lends LiveObject.prototype */{

  mixin: Emitter,

  /**
   * A representation of an object which may be observed for changes
   * @constructs
   * @mixes Emitter
   */
  constructor: function LiveObject(_uri) {
    this.uri = _uri;
    this._data = { uri: _uri };
    this._mergeThrottled = throttle(this._merge, this);
    this.index = [];
    this._waiting = [];
    this.emit('init', EMIT_SYNC);

    var self = this;
    var lastWait = '';

    if (live.debug) setInterval(function () {
      var thisWait = self._waiting.toString();
      if (lastWait === thisWait) return;
      lastWait = thisWait;

      if (self._waiting.length) {
        console.warn(self, self._waiting);
      } else {
        console.warn(self, 'all done');
      }
    }, 2000);
  },

  emit: function emit() {
    var uri = this.uri;
    if (uri) {
      var keys = emitters.keys;
      var values = emitters.values;
      var key;
      var args;

      for (var i = 0, len = keys.length; i < len; i++) {
        key = keys[i];
        if (uri.match(key)) {
          if (!args) {
            args = new Array(arguments.length);
            for (var j = 0; j < arguments.length; ++j) {
              args[j] = arguments[j];
            }
            args.splice(1, 0, this);
          }
          var emitter = values[i];
          emitter.emit.apply(emitter, args);
        }
      }
    }

    Emitter.prototype.emit.apply(this, arguments);
  },

  _merge: function _merge() {
    var data = this._data; // the data
    var before = this._before; // an old copy of data
    var publish = this._publish; // published data
    var value;
    var key;

    // published changes
    if (publish) {
      delete this._publish;

      // emit change events if the object has a uri that can be subscribed too,
      // or the object in itself has listeners
      if (this.uri || this._listeners && this._listeners.publish) {
        var publishEvent = {};

        for (key in publish) {
          value = publish[key];
          if (data[key] !== value) publishEvent[key] = value;
        }

        if (Object.keys(publishEvent).length) {
          this.emit('publish', publishEvent, EMIT_SYNC);
        }
      }
    }

    // if there are changes
    if (before) {
      delete this._before;

      var updateEvent = {};

      // emit change events if the object has a uri that can be subscribed too,
      // or the object in itself has listeners
      if (this.uri || this._listeners && this._listeners.update) {
        // check changed and added keys
        for (key in data) {
          value = data[key];
          // there was no key, or value is different
          if (!(key in before) || before[key] !== value) updateEvent[key] = value;
        }

        // check deleted keys
        for (key in before) {
          value = before[key];
          // there is no key so it was deleted
          if (!(key in data)) updateEvent[key] = undefined;
        }

        if (Object.keys(updateEvent).length) {
          this.emit('update', updateEvent, EMIT_SYNC);
        }
      }
    }

    return this;
  },

  _update: function _update(object, method) {
    var branch;

    if (method === PUBLISH) {
      branch = this._publish || (this._publish = simpleClone(this._data));
    } else if (method === UPDATE) {
      if (!this._before) this._before = simpleClone(this._data);
      branch = this._data;
    }

    var value;
    for (var key in object) {
      value = object[key];
      var previous = !(key in branch) ? undefined : branch[key];

      if (isLiveList(previous)) {
        // updating lists with an array will keep the reference but replace every item.
        if (isArray(value)) {

          previous._update([{
            type: 'remove',
            index: 0,
            length: previous.length
          }, {
            type: 'insert',
            index: 0,
            values: value
          }], method);
          continue;
        } else if (isPlainObject(value) && 'operations' in value) {
          previous._update(value.operations, method);
          continue;
        }
      }

      if (method === UPDATE && value === undefined) delete branch[key];else branch[key] = transform(value, method);
    }

    if (method === UPDATE) {
      this.index = keys(branch);
      this._waiting = difference(this._waiting, this.index);
    }

    this._mergeThrottled();
    return this;
  },

  delete: function _delete(key) {
    var object = {};
    object[key] = undefined;
    return this.update(object);
  },

  update: function update(object) {
    return this._update(object, UPDATE);
  },

  publish: function publish(object) {
    return this._update(object, PUBLISH);
  },

  /**
   * Serialize the data in this object into a plain object.
   *
   * @param {number=} limit Optional limit parameter. Controls how many levels
   *     deep to serialize.
   *
   * @return {Object} The data object.
   */
  serialize: function serialize(limit) {
    if (limit === 0) return {};

    var object = {};
    var data = this._data;
    var nextLimit = limit === undefined ? undefined : limit - 1;

    for (var key in data) {
      var value = data[key];
      if (value === undefined) continue;
      var serializedValue = value;
      if (value && value.serialize) {
        serializedValue = value.serialize(nextLimit);
      }
      object[key] = serializedValue;
    }

    return object;
  },

  _getDataFromMask: function _getDataFromMask(mask) {
    var data = {};

    for (var i = 0, l = mask.length; i < l; i++) {
      var thisMask = mask[i];
      var nextMask = thisMask.mask;
      var key = thisMask.key;

      var realValue = this.get(key);
      var value = realValue;

      // Set the value to an empty object or array, and then it will be filled
      // in with the found data in the next step.
      if (isLiveObject(realValue)) value = {};
      if (isLiveList(realValue)) value = [];

      if (nextMask) {
        if (isLiveObject(realValue)) {
          var innerData = realValue._getDataFromMask(nextMask);
          deepMixIn(value, innerData);
        } else if (isLiveList(realValue)) {
          value = realValue._getDataFromMask(nextMask);
        }
      }

      data[key] = value;
    }

    return data;
  },

  _query: function _query(selector, callback, mode) {
    var self = this;

    var query = function query() {
      queryObject(self, selector, function (error, data, wasSync) {
        if (error) return callback.call(this, error);

        if (!wasSync) {
          self._query(selector, callback, mode);
        } else {
          callback.call(this, null, data);
        }
      });
    };

    if (mode === ASYNC) defer(query);else query();
  },

  /**
   * Query properties in this object.
   * This can be called in two different ways: with a callback or without. When
   * calling it with a callback, it will wait for any missing properties and
   * always return the data you queried for. When calling it without a callback,
   * it will return an object structure with only the data that was found in the
   * object at the moment. It will not kick off any events for waiting for
   * properties.
   *
   * @param {String} selector - The query selector. Only selectors without
   *     filters are supported when not providing a callback.
   * @param {Array} params - The query replace parameters. Optional.
   * @param {LiveObject~queryCallback} callback - The callback function.
   * @param {Object} [mode] live.SYNC: Force sync, 2: live.ASAP: Don't force async
   * @param {Number} timeout - optional timeout in milliseconds
   *
   * @return {LiveObject|Object} If no callback is passed it returns an object
   *                             with the data matching the query, that was found
   *                             at the moment in the object.
   *                             If a callback is passed it returns the instance.
   */
  query: function query(selector, params, callback, mode, timeout) {
    /**
     * @callback LiveObject~queryCallback
     * @param {Error|Null} error - An error that you can throw, or null.
     * @param {LiveObject} [data] - The response as a plain object.
     */
    if (typeof params === 'function') {
      // shift for empty params
      timeout = mode;
      mode = callback;
      callback = params;
      params = [];
    }

    if (!callback) {
      return this._getDataFromMask(parse(selector, params).mask);
    }

    if (!mode) {
      mode = ASYNC;
    } else if (isNumber(mode)) {
      // shift once again
      timeout = mode;
      mode = ASYNC;
    }

    if (timeout) {
      callback = createTimedCallback(callback, timeout);
    }

    this._query(parse(selector, params), callback, mode);
    return this;
  },

  _wait: function _wait(keys) {
    if (!this._required) {
      // if _required is set, it was deferred already
      this._required = [];
      defer(function () {
        var missingFromIndex = this.missing(this._required);
        var missingFromWaiting = difference(missingFromIndex, this._waiting);
        this._waiting = combine(this._waiting, missingFromWaiting);
        delete this._required;
        if (missingFromWaiting.length) this.emit('wait', missingFromWaiting, EMIT_SYNC);
      }, this);
    }
    this._required = combine(this._required, keys);
  },

  missing: function missing(keys) {
    return difference(keys, this.index);
  },

  /**
   * Checks if the key has been set in the object.
   *
   * @param {string} key The name of the key.
   *
   * @return {Boolean} True if the key has been set.
   */
  has: function has(key) {
    return this.index.indexOf(key) > -1;
  },

  // the raw, unbeautified get
  // this can callback sync or async
  _get: function _get(keys, callback) {
    if (this.missing(keys).length) {
      this._wait(keys);

      var check = function check() {
        var needed = this.missing(keys);
        if (!needed.length) {
          this.off('update', check);
          callback.call(this);
        }
      };
      this.on('update', check);
    } else {
      // the callback is called with 'true' when syncronous.
      callback.call(this, null, true);
    }
  },

  /**
   * Gets values from the object.
   * @param {...String|Array} keys - An array of strings as arguments.
   * @param {LiveObject~getCallback} [callback] - Optional callback function.
   * @param {Object} [mode] live.SYNC: Force sync, 2: live.ASAP: Don't force async
   * @param {Number} timeout - optional timeout in milliseconds
   * @return {LiveObject|Array|*} If no callback is passed and keys is either an array or multiple arguments
   *                             returns the values in an array.
   *                             If no callback is passed and keys is a single parameter it
   *                             returns the requested value (any type).
   *                             If a callback is passed it returns the instance.
   */
  get: function get(key) {
    /**
     * @callback LiveObject~getCallback
     * @param {Error|Null} error - An error that you can throw, or null.
     * @param {Array|...*} [data] - If keys are requested as arguments (any #)
     *                              it will return many results as arguments.
     *                              If keys are requested as an array (any #), it will return data as an array
     * @param {Number} [mode] 1: FORCE SYNC, 2: DON'T FORCE ASYNC
     */

    // fast, get one
    var data = this._data;
    if (arguments.length === 1 && isString(key)) return data[key];

    var self = this;

    var args = slice_.call(arguments);
    var callback, mode, keys;

    for (var i = 0, len = args.length; i < len; i++) {
      var arg = args[i];
      if (typeof arg === 'function') {
        var split = args.splice(i, 3);
        len = args.length;
        callback = split[0];
        if (split[1]) {
          if (split[1] === SYNC || split[1] === ASYNC || split[1] === ASAP) {
            mode = split[1];
          } else {
            // assume this arg is a timeout
            mode = ASYNC;
            callback = createTimedCallback(callback, split[1]);
            break;
          }
          // is there a timeout ?
          if (split[2] && mode !== SYNC) {
            callback = createTimedCallback(callback, split[2]);
          }
        } else {
          mode = ASYNC;
        }
        break;
      }
    }

    var asArray = false;

    if (isArray(key)) {
      keys = key;
      asArray = true;
    } else {
      keys = args;
    }

    var done = function done() {
      var vals = values(data, keys);
      if (asArray) {
        callback.call(self, null, vals);
      } else {
        vals.unshift(null); // unshift no error
        callback.apply(self, vals);
      }
    };

    if (!callback) {
      return values(data, keys);
    } else if (mode === SYNC) {
      done();
    } else {
      if (mode === ASYNC && !this.missing(keys).length) {
        // it has all the data but needs to be ASYNC
        defer(function () {
          self._get(keys, done);
        });
      } else {
        this._get(keys, done);
      }
    }

    return this;
  }

});

var queryAny = function queryAny(object, selector, callback) {
  if (isPlainObject(object) || isLiveObject(object)) return queryObject(object, selector, callback);else if (isArray(object) || isLiveList(object)) return queryList(object, selector, callback);else return callback(null, object, true);
};

var queryObject = function queryObject(object, selector, callback) {
  var data = {};
  var isSync = true;

  if (!selector) callback(null, data, isSync);

  var keys = map(selector.mask, 'key');

  var done = function done(values) {
    flow().parallel(values, function (objectValue, i) {
      var control = this;
      queryAny(objectValue, selector.mask[i], function (error, dataValue, wasSync) {
        if (error) return control.break(error);
        if (!wasSync) isSync = false;
        if (data[keys[i]]) deepMixIn(data[keys[i]], dataValue);else data[keys[i]] = dataValue;
        control.done();
      });
    }).finally(function (error) {
      callback(error, data, isSync);
    });
  };

  if (isLiveObject(object)) {
    object._get(keys, function (error, wasSync) {
      if (error) return callback(error);
      if (!wasSync) isSync = false;
      var values = map(keys, function (key) {
        return object._data[key];
      });
      done(values);
    });
  } else {
    var values = pick(object, keys);
    done(values);
  }
};

var satisfies = function satisfies(value, op, right) {
  if (!op) return !!value;
  if (isRegExp(right)) return right.test(value);

  if (op === '=') return value === right;
  if (op === '!=') return value !== right;

  if (isNumber(right)) {
    if (op === '>') return value > right;
    if (op === '>=') return value >= right;
    if (op === '<') return value < right;
    if (op === '<=') return value <= right;
  }

  if (isString(right)) {
    var escapedRight = escapeRegExp(right);
    // starts with
    if (op === '^=') return new RegExp('^' + escapedRight).test(value);
    // ends with
    if (op === '$=') return new RegExp(escapedRight + '$').test(value);
    // contains separated by space e.g. 'list of things to look for' ~= 'list'
    if (op === '~=') return new RegExp('(^|\\s)' + escapedRight + '(\\s|$)').test(value);
    // contains separated by - e.g. 'list-of-things-to-look-for' ~= 'things'
    if (op === '|=') return new RegExp('^' + escapedRight + '(-|$)').test(value);
    // contains e.g. 'listofthingstolookfor' ~= 'look'
    if (op === ' *=') return value.toString().indexOf(right) !== -1;
  }

  return false;
};

var filterArray = function filterArray(array, left, op, right, callback) {
  var isSync = true;

  var filtered = [];

  flow().parallel(array, function (item, i) {
    var ctrl = this;

    if (isLiveObject(item)) {
      item._get([left], function (error, wasSync) {
        if (error) return ctrl.break(error);
        if (!wasSync) isSync = false;
        var value = item._data[left];
        if (satisfies(value, op, right)) filtered[i] = item;
        ctrl.done();
      });
    } else if (isPlainObject(item)) {
      if (satisfies(item[left], op, right)) filtered[i] = item;
      ctrl.done();
    } else {
      // filter objects only
      ctrl.done();
    }
  }).finally(function (error) {
    if (error) return callback(error);
    var clean = [];
    for (var i = 0; i < filtered.length; i++) {
      if (i in filtered) clean.push(filtered[i]);
    }callback(null, clean, isSync);
  });
};

// default filter that filters the whole list.
var defaultFilters = [[{
  left: 0,
  op: ':'
}]];

var queryList = function queryList(list, selector, callback) {
  var isSync = true;
  // if there are no filters we need to query the full length
  if (!selector.filters) selector.filters = defaultFilters;

  // single filter.
  // must be sequential.
  flow().sequential(selector.filters, function (conditions) {
    var sequential = this;

    var ref = [];

    // list of conditions in a single filter.
    // can be parallel.
    flow().parallel(conditions, function (condition) {
      var parallel = this;

      var left = condition.left;
      var right = condition.right;
      var op = condition.op;

      if ('left' in condition && !('right' in condition) && isNumber(left)) {
        if (!op) right = left + 1;else if (op === ':') right = list.length;
        op = ':';
      }

      if ('right' in condition && !('left' in condition) && isNumber(right) && op === ':') {
        left = 0;
      }

      // filter by range.
      if (isNumber(left) && isNumber(right) && op === ':') {
        // if the list is an array it means it has already been filtered.
        if (isArray(list)) {
          var filtered = slice_.call(list, left, right);
          ref = ref.concat(filtered);
          parallel.done();
        } else {
          list._get([new Range(left, right)], function (error, wasSync) {
            if (error) return parallel.break(error);

            for (var i = left; i < right; i++) {
              ref.push(list.values[i]);
            }if (!wasSync) isSync = false;
            parallel.done();
          });
        }
      } else {

        var done = function done(array) {
          filterArray(array, left, op, right, function (error, filtered, wasSync) {
            if (error) return parallel.break(error);

            if (!wasSync) isSync = false;
            ref = ref.concat(filtered);
            parallel.done();
          });
        };

        if (isArray(list)) {
          done(list);
        } else {
          // the list is not an array, never been filtered.
          // assume full length.
          // call a function that filters an array once you arraify it.
          list._get([new Range(0, list.length)], function (error, wasSync) {
            if (error) return parallel.break(error);

            var array = [];
            for (var i = 0; i < list.length; i++) {
              array.push(list.values[i]);
            }if (!wasSync) isSync = false;
            done(array);
          });
        }
      }

      // parallel finished
    }).finally(function (error) {
      if (error) return sequential.break(error);
      list = ref;
      sequential.continue();
    });

    // sequential finished
  }).finally(function (error) {
    if (error) return callback(error);

    var data = [];

    // final parallel
    flow().parallel(list, function (item, i) {
      var control = this;
      queryAny(item, selector, function (err, res, wasSync) {
        if (!wasSync) isSync = false;
        if (data[i]) deepMixIn(data[i], res);else data[i] = res;
        control.done(err);
      });
    }).finally(function (err) {
      callback(err, data, isSync);
    });
  });
};

var cache = {};

/**
 * Create a new instance of a object, based on an unique identifier.
 * @function
 * @static
 * @param {String|LiveObject} item - An object with an uri property, or an uri as a string.
 * @return {LiveObject|LiveList} An instance of LiveObject or LiveList.
 */
var live = function live(item) {
  if (isArray(item)) {
    return new LiveList().update([{
      type: 'insert',
      index: 0,
      length: item.length,
      values: item
    }]);
  } else if (isNumber(item)) {
    return new LiveList(item);
  } else if (isString(item)) {
    return cache[item] || (cache[item] = new LiveObject(item));
  } else if (isPlainObject(item)) {
    return live(item.uri).update(item);
  } else if (isLiveList(item) || isLiveObject(item)) {
    return item;
  }

  return new LiveObject();
};

// Allow localStorage.debug to also control live.debug.
if (global.localStorage && global.localStorage.debug && (global.localStorage.debug.indexOf('spotify-live') > -1 || global.localStorage.debug.indexOf('*') > -1)) {
  live.debug = true;
}

var emitters = {
  keys: [],
  values: []
};

/**
 * Subscribe to the specific event of objects matching the pattern.
 * @function
 * @static
 * @param {RegExp} match - Regular expression for matching uris.
 * @param {String} name - The name of the event to listen for.
 * @param {Function} handle - The event handle.
 * @return {Function} The live function.
 */
live.subscribe = function (match, name, handle) {
  if (match.matches) match = match.matches;

  var string = match.toString();

  var keys = emitters.keys;
  var values = emitters.values;

  var emitter;
  for (var i = 0, len = keys.length; i < len; i++) {
    var key = keys[i];
    if (key.toString() === string) {
      emitter = values[i];
      if (emitter) break;
    }
  }

  if (!emitter) {
    keys.push(match);
    values.push(emitter = new Emitter());
  }

  emitter.on(name, handle);

  return this;
};

/**
 * Unsubscribe to the specific event of objects matching the pattern.
 * @function
 * @static
 * @param {RegExp} match - Regular expression for matching uris.
 * @param {String} name - The name of the event to unsubscribe from.
 * @param {Function} handle - The event handle.
 * @return {Function} The live function.
 */
live.unsubscribe = function (match, name, handle) {
  if (match.matches) match = match.matches;

  var string = match.toString();

  var keys = emitters.keys;
  var values = emitters.values;

  var emitter;
  for (var i = 0, len = keys.length; i < len; i++) {
    var key = keys[i];
    if (key.toString() === string) {
      emitter = values[i];
      if (emitter) break;
    }
  }

  if (emitter) emitter.off(name, handle);

  return this;
};

/**
 * Delete a model from the live cache.
 *
 * @param {string} uri A uri.
 *
 * @return {Function} The live function.
 */
live.delete = function (uri) {
  delete cache[uri];
  return this;
};

/**
 * Purge the entire cache.
 *
 * @return {Function} The live function.
 */
live.purge = function () {
  cache = {};
  return this;
};

/**
 * Check if live has an object for the URI in the cache.
 *
 * @param {string} uri A uri.
 *
 * @return {Boolean} True if the object is in the cache.
 */
live.has = function (uri) {
  return !!cache[uri];
};

var EMIT_SYNC = live.EMIT_SYNC = Emitter.EMIT_SYNC;

var ASYNC = live.ASYNC = 'ASYNC';
var SYNC = live.SYNC = 'SYNC';
var ASAP = live.ASAP = 'ASAP';

var PUBLISH = 3;
var UPDATE = 4;

/**
 * @static
 * @see LiveObject
 */
live.Object = LiveObject;

/**
 * @static
 * @see LiveList
 */
live.List = LiveList;

module.exports = live;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-range2":150,"./util/ordered-set":120,"./util/parser":121,"./util/throttle":122,"finally":161,"mout/array/combine":193,"mout/array/difference":195,"mout/array/filter":197,"mout/array/map":203,"mout/lang/isArray":211,"mout/lang/isPlainObject":214,"mout/lang/isRegExp":215,"mout/object/deepMixIn":219,"mout/object/keys":223,"mout/object/pick":225,"mout/string/escapeRegExp":227,"prime":235,"prime/defer":233,"prime/emitter":234}],119:[function(require,module,exports){
/**
 * @module spotify-live/diff
 */
'use strict';

// Original code from: https://github.com/codeparty/arraydiff
// License: MIT
// This has been forked to allow for optimizations and patching operations.

// Based on some rough benchmarking, this algorithm is about O(n^2) worst case,
// and it can compute diffs on random arrays of length 1024 in about 34ms,
// though just a few changes on an array of length 1024 takes about 0.5ms

var splice_ = Array.prototype.splice;
var slice_ = Array.prototype.slice;

var annotate = function annotate(before, after) {
  // Find all items in both the before and after array, and represent them
  // as moves. Many of these "moves" may end up being discarded in the last
  // pass if they are from an index to the same index, but we don't know this
  // up front, since we haven't yet offset the indices.
  //
  // Also keep a map of all the indicies accounted for in the before and after
  // arrays. These maps are used next to create insert and remove diffs.
  var beforeLength = before.length;
  var afterLength = after.length;
  var moves = [];
  var beforeMarked = {};
  var afterMarked = {};
  for (var beforeIndex = 0; beforeIndex < beforeLength; beforeIndex++) {
    var beforeItem = before[beforeIndex];
    for (var afterIndex = 0; afterIndex < afterLength; afterIndex++) {
      if (afterMarked[afterIndex]) continue;
      if (beforeItem !== after[afterIndex]) continue;
      var from = beforeIndex;
      var to = afterIndex;
      var length = 0;
      do {
        beforeMarked[beforeIndex++] = afterMarked[afterIndex++] = true;
        length++;
      } while (beforeIndex < beforeLength && afterIndex < afterLength && before[beforeIndex] === after[afterIndex] && !afterMarked[afterIndex]);
      var moveDiff = {
        type: 'move',
        from: from,
        to: to,
        length: length
      };
      moves.push(moveDiff);
      beforeIndex--;
      break;
    }
  }

  // Create a remove for all of the items in the before array that were
  // not marked as being matched in the after array as well
  var removes = [];
  for (beforeIndex = 0; beforeIndex < beforeLength;) {
    if (beforeMarked[beforeIndex]) {
      beforeIndex++;
      continue;
    }
    var index = beforeIndex;
    var length = 0;
    while (beforeIndex < beforeLength && !beforeMarked[beforeIndex++]) {
      length++;
    }
    var removeDiff = {
      type: 'remove',
      index: index,
      length: length,
      values: slice_.call(before, index, index + length)
    };
    removes.push(removeDiff);
  }

  // Create an insert for all of the items in the after array that were
  // not marked as being matched in the before array as well
  var inserts = [];
  for (afterIndex = 0; afterIndex < afterLength;) {
    if (afterMarked[afterIndex]) {
      afterIndex++;
      continue;
    }
    var index = afterIndex;
    var length = 0;
    while (afterIndex < afterLength && !afterMarked[afterIndex++]) {
      length++;
    }
    var values = slice_.call(after, index, index + length);
    inserts.push({ type: 'insert', index: index, length: length, values: values });
  }

  return [removes, moves, inserts];
};

var offset = function offset(removes, moves, inserts) {

  var insertsLength = inserts.length;
  var removesLength = removes.length;
  var movesLength = moves.length;
  var i, j;

  // Offset subsequent removes and moves by removes
  var count = 0;
  for (i = 0; i < removesLength; i++) {
    var remove = removes[i];
    remove.index -= count;
    count += remove.length;
    for (j = 0; j < movesLength; j++) {
      var move = moves[j];
      if (move.from >= remove.index) move.from -= remove.length;
    }
  }

  // Offset moves by inserts
  for (i = insertsLength; i--;) {
    var insert = inserts[i];
    var length = insert.length;
    for (j = movesLength; j--;) {
      var move = moves[j];
      if (move.to >= insert.index) move.to -= length;
    }
  }

  // Offset the to of moves by later moves
  for (i = movesLength; i-- > 1;) {
    var move = moves[i];
    if (move.to === move.from) continue;
    for (j = i; j--;) {
      var earlier = moves[j];
      if (earlier.to >= move.to) earlier.to -= move.length;
      if (earlier.to >= move.from) earlier.to += move.length;
    }
  }

  // Only output moves that end up having an effect after offsetting
  var outputMoves = [];

  // Offset the from of moves by earlier moves
  for (i = 0; i < movesLength; i++) {
    var move = moves[i];
    if (move.to === move.from) continue;
    outputMoves.push(move);
    for (j = i + 1; j < movesLength; j++) {
      var later = moves[j];
      if (later.from >= move.from) later.from -= move.length;
      if (later.from >= move.to) later.from += move.length;
    }
  }

  // try to reduce the number of move events
  reduceMoves(outputMoves);

  return removes.concat(outputMoves, inserts);
};

var reduceMoves = function reduceMoves(moves) {
  for (var i = 0; i < moves.length; i++) {

    // if we detect a move operation of a lots of items to a near position, we
    // can swap it by a move operation of less items to a farther position
    // (which is going to be much more performant).
    //
    // Example:
    // [1, 2, 3, 4, 5, 6, 7] => [2, 3, 4, 5, 6, 7, 1]
    // We could move [2, 3, 4, 5, 6, 7] one position ahead, but it's better to
    // move [1] six positions behind.
    if (moves[i].length > Math.abs(moves[i].to - moves[i].from)) {
      var from = moves[i].from;
      var to = moves[i].to;
      var length = moves[i].length;

      moves[i].length = Math.abs(moves[i].to - moves[i].from);
      moves[i].from = to;
      moves[i].to = to + length;
    }
  }
};

var insert = function insert(array, index, values) {
  for (var i = 0; i < values.length; i++) {
    if (i in values) {
      var idx = index + i;
      if (array.length < idx) array.length = idx;
      array.splice(idx, 0, values[i]);
    }
  }
  return values;
};

var remove = function remove(array, index, length) {
  return splice_.call(array, index, length);
};

var move = function move(array, from, to, length) {
  var moved = remove(array, from, length);
  insert(array, to, moved);
  return moved;
};

var patch = function patch(array, operations) {
  for (var i = 0; i < operations.length; i++) {
    var operation = operations[i];
    switch (operation.type) {
      case 'move':
        move(array, operation.from, operation.to, operation.length);break;
      case 'remove':
        remove(array, operation.index, operation.length);break;
      case 'insert':
        insert(array, operation.index, operation.values);break;
    }
  }
  return array;
};

var diff = function diff(before, after) {
  var operations = annotate(before, after);
  return offset.apply(this, operations);
};

diff.annotate = annotate;
diff.offset = offset;

diff.remove = remove;
diff.insert = insert;
diff.move = move;
diff.patch = patch;

module.exports = diff;

},{}],120:[function(require,module,exports){
/**
 * @module spotify-live/util/ordered-set
 * @private
 */
'use strict';

// prime

var prime = require('prime');

// mout
var forEach = require('mout/array/forEach');

var Range = require('../../spotify-range2');
var _diff = require('./diff');

var OrderedSet = prime({

  constructor: function constructor(length) {
    if (!length) length = 0;
    this.index = [];
    this.keys = new Array(length);
    this.values = new Array(length);
    this.objectStorage = {};
  },

  get length() {
    return this.keys.length;
  },

  set length(value) {
    this.keys.length = value;
    this.values.length = value;
  },

  forEach: function forEach(fn, ctx) {
    var index = this.index;
    main: for (var k = 0; k < index.length; k++) {
      var range = index[k];
      for (var i = range.start; i < range.end; i++) {
        if (fn.call(ctx, this.values[i], i, this.keys[i], this) === false) break main;
      }
    }
    return this;
  },

  map: function map(fn, ctx) {
    var values = new Array(this.length);
    this.forEach(function (value, index, key) {
      values[index] = fn.call(ctx, value, index, key, this);
    }, this);
    return values;
  },

  copy: function copy(set) {
    this.index = set.index.slice();
    this.keys = set.keys.slice();
    this.values = set.values.slice();
    var length = this.keys.length;
    this.objectStorage = {};
    for (var i = 0; i < length; i++) {
      this.objectStorage[this.keys[i]] = this.values[i];
    }
    return this;
  },

  clone: function clone() {
    return new OrderedSet().copy(this);
  },

  indexOf: function indexOf(key) {
    var index = -1;
    this.forEach(function (v, i, k) {
      if (key === k) {
        index = i;
        return false;
      }
    });
    return index;
  },

  indexOfMany: function indexOfMany(keys) {
    var indexedKeys = {};
    var found = 0;
    var output = [];

    // create a hash with the keys that are going to be searched, so we can
    // access them really fast later
    for (var i = 0; i < keys.length; i++) {
      indexedKeys[keys[i]] = -1;
    }

    this.forEach(function (v, i, k) {
      // If the element one that is being searched, add its position
      // to the output array
      if (k in indexedKeys) {
        indexedKeys[k] = i;
        found++;

        // when we have found all the search keys, we do not need to iterate
        // any more
        if (found >= keys.length) {
          return false;
        }
      }
    });

    for (i = 0; i < keys.length; i++) {
      output[i] = indexedKeys[keys[i]];
    }

    return output;
  },

  valueOf: function valueOf(key) {
    return this.objectStorage[key] || null;
  },

  hasKey: function hasKey(key) {
    return this.objectStorage.hasOwnProperty(key);
  },

  sort: function sort(fn) {
    var keys = this.keys;
    var values = this.values;
    var operations = _diff(values.slice(), values.sort(fn));

    forEach(operations, function (op) {
      // unless something is broken, a sort only produces moves.
      _diff.move(keys, op.from, op.to, op.length);
    });

    return this;
  },

  move: function move(from, to, length) {
    if (from > this.length) return [];
    if (from + length > this.length) length = from - this.length;
    if (to > this.length) to = this.length;
    if (from === to) return [];

    _diff.move(this.keys, from, to, length);
    _diff.move(this.values, from, to, length);

    return this;
  },

  insert: function insert(index, keys, values) {
    if (keys.length !== values.length) throw new Error('length mismatch');

    var range = new Range(index, index + keys.length);
    this.index = range.insert(this.index);

    _diff.insert(this.keys, index, keys);
    _diff.insert(this.values, index, values);

    for (var i = 0, length = keys.length; i < length; i++) {
      this.objectStorage[keys[i]] = values[i];
    }

    return this;
  },

  remove: function remove(index, length) {
    if (index >= this.length) return [];
    if (index + length > this.length) length = this.length;
    var range = new Range(index, index + length);
    this.index = range.extract(this.index);

    for (var i = 0; i < length; i++) {
      delete this.objectStorage[this.keys[i + index]];
    }
    _diff.remove(this.keys, index, length);
    _diff.remove(this.values, index, length);

    return this;
  },

  diff: function diff(target) {
    var operations = _diff.annotate(this.keys, target.keys);

    forEach(operations[0], function (op) {
      // remove
      op.keys = op.values;
      op.values = this.values.slice(op.index, op.index + op.length);
    }, this);

    forEach(operations[1], function (op) {
      // move
      op.keys = op.values;
      op.values = this.values.slice(op.from, op.from + op.length);
    }, this);

    forEach(operations[2], function (op) {
      // insert
      op.keys = op.values;
      op.values = target.values.slice(op.index, op.index + op.length);
    });

    return _diff.offset.apply(_diff, operations);
  },

  patch: function patch(operations) {
    forEach(operations, function (op) {
      switch (op.type) {
        case 'move':
          this.move(op.from, op.to, op.length);break;
        case 'remove':
          this.remove(op.index, op.length);break;
        case 'insert':
          this.insert(op.index, op.keys, op.values);break;
      }
    }, this);
    return this;
  }

});

module.exports = OrderedSet;

},{"../../spotify-range2":150,"./diff":119,"mout/array/forEach":200,"prime":235}],121:[function(require,module,exports){
/**
 * @module spotify-live/util/parser
 */
'use strict';

var normalize = function normalize(value) {
  if (value !== '' && !isNaN(value)) return +value;else if (value === 'true') return true;else if (value === 'false') return false;else if (value === 'null') return null;else if (value === 'undefined') return undefined;
  return value;
};

function escapeForRegExp(str) {
  return str.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
};

var COMMA = ',';
var BMASK = '(';
var EMASK = ')';
var BFILTER = '[';
var EFILTER = ']';
var EQUALS = '=';
var WHITESPACE = '\\s';

var operators = ['=', '!=', '>=', '<=', '>', '<', '^=', '$=', '~=', '|=', '*='];

var keyBlacklist = COMMA + BMASK + EMASK + escapeForRegExp(BFILTER) + escapeForRegExp(EFILTER) + EQUALS + WHITESPACE;
var keyBlacklistCharacterClass = '[^' + keyBlacklist + ']';

var KEY_CHARACTER_REG_EXP = new RegExp(keyBlacklistCharacterClass);
var EXACT_KEY_REG_EXP = new RegExp('^' + keyBlacklistCharacterClass + '+$');

var OPERATORS_REG_EXP = new RegExp(operators.map(escapeForRegExp).join('|'));
var REPLACE_REG_EXP = /\$([\d]+)/;
var RANGE_FILTER_REG_EXP = /^(\d*):(\d*)$/;

var parse = function parse(string, params) {
  if (!params) params = [];

  var selector = { mask: [] };
  var history = [selector];

  var key = '';
  var filter;

  var filterStr = '';
  var left = '';
  var right = '';
  var op = '';

  for (var i = 0; i < string.length + 1; i++) {
    var c = string.charAt(i);

    if (filter) {
      // parse the filter
      filterStr = filterStr.trim();
      if (c === COMMA || c === EFILTER) {
        var matches;
        if (matches = filterStr.match(RANGE_FILTER_REG_EXP)) {
          left = matches[1];
          op = ':';
          right = matches[2];
        } else if (matches = filterStr.match(OPERATORS_REG_EXP)) {
          left = filterStr.substring(0, matches.index);
          op = matches[0];
          right = filterStr.substring(matches.index + op.length);
        } else if (matches = filterStr.match(EXACT_KEY_REG_EXP)) {
          left = matches[0];
        } else {
          throw new SyntaxError('syntax error: `' + filterStr + '` contains characters not valid in a filter');
        }

        filterStr = '';

        var condition = {};

        if (left) {
          var leftMatch = left.match(REPLACE_REG_EXP);
          left = leftMatch ? params[+leftMatch[1]] : normalize(left);
          condition.left = left;
        }

        if (op) condition.op = op;

        if (right) {
          var rightMatch = right.match(REPLACE_REG_EXP);
          right = rightMatch ? params[+rightMatch[1]] : normalize(right);
          condition.right = right;
        }

        if ('left' in condition || 'right' in condition) filter.push(condition);

        right = '';
        left = '';
        op = '';

        if (c === EFILTER) {
          if (filter.length) {
            var filters = selector.filters || (selector.filters = []);
            filters.push(filter);
          }

          filter = null;
        }
        continue;
      }

      filterStr += c;
    } else {
      // parse the key

      if (c && KEY_CHARACTER_REG_EXP.test(c)) {
        // key
        key += c;
      } else if (key && (!c || c === COMMA || c === BMASK || c === BFILTER || c === EMASK)) {
        // end key
        // end word is "a!" or "b(a!)" or "a!,c" or "a!(" or "a!["
        var keyMatch = key.match(REPLACE_REG_EXP);
        // begin a new selector
        history[0].mask.push(selector = { key: keyMatch ? params[+keyMatch[1]] : normalize(key) });
        key = '';
      } else if (c && key) {
        throw new SyntaxError('syntax error: `' + c + '` is not a valid character in a key');
      }

      if (c === BMASK) {
        selector.mask = [];
        history.unshift(selector);
      } else if (c === EMASK) {
        history.shift();
      }

      if (c === BFILTER) {
        filter = [];
      }
    }
  }

  if (history.length !== 1) throw new SyntaxError('syntax error');

  return history[0];
};

/** exports */
module.exports = parse;

},{}],122:[function(require,module,exports){
/**
 * @module spotify-live/util/throttle
 * @private
 */
'use strict';

var defer = require('prime/defer');
var isInteger = function isInteger(n) {
  return typeof n === 'number' && n % 1 === 0;
};

var slice = Array.prototype.slice;

var _throttle = function _throttle(fn, method, context) {
  var queued, args, cancel;

  return function () {
    args = arguments;
    if (!queued) {
      queued = true;
      cancel = method(function (time) {
        queued = false;
        fn.apply(context, slice.call(args).concat(time));
      });
    }
    return cancel;
  };
};

var throttle = function throttle(callback, argument, context) {
  if (isInteger(argument)) return throttle.timeout(callback, argument, context);else return throttle.immediate(callback, argument);
};

throttle.timeout = function (callback, ms, context) {
  return _throttle(callback, function (run) {
    return defer.timeout(run, ms, context);
  }, context);
};

throttle.frame = function (callback, context) {
  return _throttle(callback, function (run) {
    return defer.frame(run, context);
  }, context);
};

throttle.immediate = function (callback, context) {
  return _throttle(callback, function (run) {
    return defer.immediate(run, context);
  }, context);
};

module.exports = throttle;

},{"prime/defer":233}],123:[function(require,module,exports){
'use strict';

var languages = require('./languages.json');

function lookup(language, to) {
  var lang = languages[language];
  if (lang[to]) {
    return lang[to];
  } else {
    return language;
  }
}

module.exports = lookup;
module.exports.all = function () {
  return Object.keys(languages);
};

},{"./languages.json":124}],124:[function(require,module,exports){
module.exports={
  "de": {
    "smartling": "de-DE"
  },
  "el": {
    "smartling": "el-GR"
  },
  "en": {
    "smartling": "en-GB"
  },
  "es": {
    "numeral": "es-ES",
    "smartling": "es-ES"
  },
  "es-419": {
    "moment": "es",
    "numeral": "es-ES",
    "smartling": "es-LA"
  },
  "fi": {
    "smartling": "fi-FI"
  },
  "fr": {
    "smartling": "fr-FR"
  },
  "fr-CA": {
    "smartling": "fr-CA",
    "moment": "fr-ca"
  },
  "hu": {
    "smartling": "hu-HU"
  },
  "id": {
    "smartling": "id-ID"
  },
  "it": {
    "smartling": "it-IT"
  },
  "ja": {
    "smartling": "ja-JP"
  },
  "nl": {
    "numeral": "nl-nl",
    "smartling": "nl-NL"
  },
  "pl": {
    "smartling": "pl-PL"
  },
  "pt-BR": {
    "moment": "pt-br",
    "numeral": "pt-br",
    "smartling": "pt-BR"
  },
  "sv": {
    "smartling": "sv-SE"
  },
  "tr": {
    "smartling": "tr-TR"
  },
  "zh-Hant": {
    "moment": "zh-tw",
    "smartling": "zh-TW"
  },
  "zsm": {
    "moment": "ms-my",
    "smartling": "ms-MY"
  }
}
},{}],125:[function(require,module,exports){
'use strict';

var schemer = require('./schemer');
var cosmos = require('spotify-cosmos-api');
var debug = require('debug');

var id = 0;

module.exports = function log(schema, data) {
  /*eslint-disable camelcase */
  var body = schemer(schema, Object.assign({}, {
    message_name: schema.name,
    message_version: schema.schema_version
  }, data));

  // Logging cosmos endpoint requires all values to be strings.
  body.fields = body.fields.map(function (f) {
    if (typeof f === 'string') return f;
    if (f == null) return '';
    return JSON.stringify(f);
  });

  var qualifiedName = schema.name + schema.schema_version;
  /*eslint-enable camelcase */

  var messageDebug = debug('spotify-logger:' + qualifiedName);
  var requestId = ++id;

  messageDebug('REQ %s#%s %s', qualifiedName, requestId, JSON.stringify(body));

  cosmos.resolver.post({
    url: 'sp://logging/v1/log',
    body: body
  }, function (error, response) {
    if (error) return console.error(error, body);
    messageDebug('RES %s#%s %d', qualifiedName, requestId, response.getStatusCode());
  });
};

},{"./schemer":126,"debug":159,"spotify-cosmos-api":246}],126:[function(require,module,exports){
'use strict';

var validation = require('../vendor/avro-trunk/lang/js/lib/validator');
var debug = require('debug')(require('../package.json').name + ':');

module.exports = function (schema, data) {

  debug(schema.name);

  var name = data.message_name;
  var version = data.message_version;
  var copy = Object.assign({}, data);

  if (version !== schema.schema_version) throw new Error('' + 'Invalid message version: received Message with message_version ' + version + ' but the Schema requires version ' + schema.schema_version);

  // Create positional array of field values as required by cosmos and
  // log-parser, and also create an avro Field for each value to allow
  // validation.
  var fields = schema.fields.map(function (f) {
    var type = f.type;
    var value = copy[f.name];

    // If field is a union, attempt to infer the type by grabbing the first
    // non-null type from the schema.
    if (Array.isArray(f.type)) {
      copy[f.name] = {};
      var firstNoneNullType = type.filter(function (t) {
        return t !== 'null';
      })[0];
      copy[f.name][firstNoneNullType] = value;
      debug('union `%s` (%s) : `%s`', f.name, firstNoneNullType, value);
    } else {
      copy[f.name] = value;
      debug('field `%s` : `%s`', f.name, value);
    }
    return value === undefined ? f.default : value;
  })
  // remove name, version
  .slice(2);

  validation.Validator.validate(schema, copy);

  return {
    message: name,
    version: version,
    fields: fields
  };
};

module.exports.Validator = validation.Validator;
module.exports.ProtocolValidator = validation.ProtocolValidator;

},{"../package.json":128,"../vendor/avro-trunk/lang/js/lib/validator":130,"debug":159}],127:[function(require,module,exports){
'use strict';

var schema = require('../schemas/ClientEvent3.json');
var log = require('../lib/log');

module.exports = {
  schema: schema,
  log: log.bind(null, schema)
};

},{"../lib/log":125,"../schemas/ClientEvent3.json":129}],128:[function(require,module,exports){
module.exports={
  "name": "spotify-logger",
  "version": "1.0.0",
  "description": "Generate / consume log-parser schemas in JS",
  "bin": {
    "spotify-logger-schemas-generator": "bin/schemas-generator",
    "spotify-logger-messages-generator": "bin/messages-generator"
  },
  "main": "lib/log.js",
  "dependencies": {},
  "devDependencies": {},
  "scripts": {
    "dev": "echo App scripts have been removed. Please see docs/app-development.md for more information. && exit 1",
    "prod": "echo App scripts have been removed. Please see docs/app-development.md for more information. && exit 1",
    "spa": "echo App scripts have been removed. Please see docs/app-development.md for more information. && exit 1",
    "enable": "echo App scripts have been removed. Please see docs/app-development.md for more information. && exit 1"
  },
  "author": "Drew Petersen <drewp@spotify.com>",
  "license": "UNLICENSED",
  "private": true
}
},{}],129:[function(require,module,exports){
module.exports={
  "type": "record",
  "name": "ClientEvent",
  "namespace": "com.spotify.Message",
  "doc": "A generic client event primarily used by Stitch Apps",
  "fields": [
    {
      "name": "message_name",
      "type": "string"
    },
    {
      "name": "message_version",
      "type": "int"
    },
    {
      "name": "source",
      "type": [
        "null",
        "string"
      ],
      "doc": "Source which generated the event, will mostly be set to the App-ID",
      "default": null
    },
    {
      "name": "context",
      "type": [
        "null",
        "string"
      ],
      "doc": "Optional context within the app",
      "default": null
    },
    {
      "name": "event",
      "type": [
        "null",
        "string"
      ],
      "doc": "Event name",
      "default": null
    },
    {
      "name": "event_version",
      "type": [
        "null",
        "string"
      ],
      "doc": "Optional event version, can be used as a version or sub-type",
      "default": null
    },
    {
      "name": "test_version",
      "type": [
        "null",
        "string"
      ],
      "doc": "Optional test case if A/B testing",
      "default": null
    },
    {
      "name": "source_version",
      "type": [
        "null",
        "string"
      ],
      "doc": "The version of the app",
      "default": null
    },
    {
      "name": "source_vendor",
      "type": [
        "null",
        "string"
      ],
      "doc": "The app vendor",
      "default": null
    },
    {
      "name": "json_data",
      "type": [
        "null",
        "string"
      ],
      "doc": "Additional JSON data specific to the event being sent",
      "default": null
    }
  ],
  "schema_version": 3
}
},{}],130:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

// Licensed to the Apache Software Foundation (ASF) under one or more
// contributor license agreements.  See the NOTICE file distributed with
// this work for additional information regarding copyright ownership.
// The ASF licenses this file to You under the Apache License, Version 2.0
// (the "License"); you may not use this file except in compliance with
// the License.  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

if (typeof require !== 'undefined') {
  var _ = require("underscore");
}

var AvroSpec = {
  PrimitiveTypes: ['null', 'boolean', 'int', 'long', 'float', 'double', 'bytes', 'string'],
  ComplexTypes: ['record', 'enum', 'array', 'map', 'union', 'fixed']
};
AvroSpec.Types = AvroSpec.PrimitiveTypes.concat(AvroSpec.ComplexTypes);

var InvalidSchemaError = function InvalidSchemaError(msg) {
  return new Error('InvalidSchemaError: ' + msg);
};
var InvalidProtocolError = function InvalidProtocolError(msg) {
  return new Error('InvalidProtocolError: ' + msg);
};
var ValidationError = function ValidationError(msg) {
  return new Error('ValidationError: ' + msg);
};
var ProtocolValidationError = function ProtocolValidationError(msg) {
  return new Error('ProtocolValidationError: ' + msg);
};

function Record(name, namespace, fields) {
  function validateArgs(name, namespace, fields) {
    if (!_.isString(name)) {
      throw new InvalidSchemaError('Record name must be string');
    }

    if (!_.isNull(namespace) && !_.isUndefined(namespace) && !_.isString(namespace)) {
      throw new InvalidSchemaError('Record namespace must be string or null');
    }

    if (!_.isArray(fields)) {
      throw new InvalidSchemaError('Record name must be string');
    }
  }

  validateArgs(name, namespace, fields);

  this.name = name;
  this.namespace = namespace;
  this.fields = fields;
}

function makeFullyQualifiedTypeName(schema, namespace) {
  var typeName = null;
  if (_.isString(schema)) {
    typeName = schema;
  } else if (_.isObject(schema)) {
    if (_.isString(schema.namespace)) {
      namespace = schema.namespace;
    }
    if (_.isString(schema.name)) {
      typeName = schema.name;
    } else if (_.isString(schema.type)) {
      typeName = schema.type;
    }
    /** BEGIN CHANGE BY drewp **/
    else if (_.has(schema, 'valueSchema') && _.isString(schema.valueSchema.type)) {
        typeName = makeFullyQualifiedTypeName(schema.valueSchema, namespace);
      }
    /** END CHANGE BY drewp **/
  } else {
      throw new InvalidSchemaError('unable to determine fully qualified type name from schema ' + JSON.stringify(schema) + ' in namespace ' + namespace);
    }

  if (!_.isString(typeName)) {
    throw new InvalidSchemaError('unable to determine type name from schema ' + JSON.stringify(schema) + ' in namespace ' + namespace);
  }

  if (typeName.indexOf('.') !== -1) {
    return typeName;
  } else if (_.contains(AvroSpec.PrimitiveTypes, typeName)) {
    return typeName;
  } else if (_.isString(namespace)) {
    return namespace + '.' + typeName;
  } else {
    return typeName;
  }
}

function Union(typeSchemas, namespace) {
  this.branchNames = function () {
    return _.map(typeSchemas, function (typeSchema) {
      return makeFullyQualifiedTypeName(typeSchema, namespace);
    });
  };

  function validateArgs(typeSchemas) {
    if (!_.isArray(typeSchemas) || _.isEmpty(typeSchemas)) {
      throw new InvalidSchemaError('Union must have at least 1 branch');
    }
  }

  validateArgs(typeSchemas);

  this.typeSchemas = typeSchemas;
  this.namespace = namespace;
}

function Enum(symbols) {

  function validateArgs(symbols) {
    if (!_.isArray(symbols)) {
      throw new InvalidSchemaError('Enum must have array of symbols, got ' + JSON.stringify(symbols));
    }
    if (!_.all(symbols, function (symbol) {
      return _.isString(symbol);
    })) {
      throw new InvalidSchemaError('Enum symbols must be strings, got ' + JSON.stringify(symbols));
    }
  }

  validateArgs(symbols);

  this.symbols = symbols;
}

function AvroArray(itemSchema) {

  function validateArgs(itemSchema) {
    if (_.isNull(itemSchema) || _.isUndefined(itemSchema)) {
      throw new InvalidSchemaError('Array "items" schema should not be null or undefined');
    }
  }

  validateArgs(itemSchema);

  this.itemSchema = itemSchema;
}

function Map(valueSchema) {
  function validateArgs(valueSchema) {
    if (_.isNull(valueSchema) || _.isUndefined(valueSchema)) {
      throw new InvalidSchemaError('Map "values" schema should not be null or undefined');
    }
  }

  validateArgs(valueSchema);

  this.valueSchema = valueSchema;
}

function Field(name, schema) {
  function validateArgs(name, schema) {
    if (!_.isString(name)) {
      throw new InvalidSchemaError('Field name must be string');
    }
  }

  this.name = name;
  this.schema = schema;
}

function Primitive(type) {
  function validateArgs(type) {
    if (!_.isString(type)) {
      throw new InvalidSchemaError('Primitive type name must be a string');
    }

    if (!_.contains(AvroSpec.PrimitiveTypes, type)) {
      throw new InvalidSchemaError('Primitive type must be one of: ' + JSON.stringify(AvroSpec.PrimitiveTypes) + '; got ' + type);
    }
  }

  validateArgs(type);

  this.type = type;
}

function Validator(schema, namespace, namedTypes) {
  this.validate = function (obj) {
    return _validate(this.schema, obj);
  };

  var _validate = function _validate(schema, obj) {
    if (schema instanceof Record) {
      return _validateRecord(schema, obj);
    } else if (schema instanceof Union) {
      return _validateUnion(schema, obj);
    } else if (schema instanceof Enum) {
      return _validateEnum(schema, obj);
    } else if (schema instanceof AvroArray) {
      return _validateArray(schema, obj);
    } else if (schema instanceof Map) {
      return _validateMap(schema, obj);
    } else if (schema instanceof Primitive) {
      return _validatePrimitive(schema, obj);
    } else {
      throw new InvalidSchemaError('validation not yet implemented: ' + JSON.stringify(schema));
    }
  };

  var _validateRecord = function _validateRecord(schema, obj) {
    if (!_.isObject(obj) || _.isArray(obj)) {
      throw new ValidationError('Expected record Javascript type to be non-array object, got ' + JSON.stringify(obj));
    }

    var schemaFieldNames = _.pluck(schema.fields, 'name').sort();
    var objFieldNames = _.keys(obj).sort();
    if (!_.isEqual(schemaFieldNames, objFieldNames)) {
      throw new ValidationError('Expected record fields ' + JSON.stringify(schemaFieldNames) + '; got ' + JSON.stringify(objFieldNames));
    }

    return _.all(schema.fields, function (field) {
      return _validate(field.schema, obj[field.name]);
    });
  };

  var _validateUnion = function _validateUnion(schema, obj) {
    if (_.isObject(obj)) {
      if (_.isArray(obj)) {
        throw new ValidationError('Expected union Javascript type to be non-array object (or null), got ' + JSON.stringify(obj));
      } else if (_.size(obj) !== 1) {
        throw new ValidationError('Expected union Javascript object to be object with exactly 1 key (or null), got ' + JSON.stringify(obj));
      } else {
        var unionBranch = _.keys(obj)[0];
        if (unionBranch === "") {
          throw new ValidationError('Expected union Javascript object to contain non-empty string branch, got ' + JSON.stringify(obj));
        }
        if (_.contains(schema.branchNames(), unionBranch)) {
          return true;
        } else {
          throw new ValidationError('Expected union branch to be one of ' + JSON.stringify(schema.branchNames()) + '; got ' + JSON.stringify(unionBranch));
        }
      }
    } else if (_.isNull(obj)) {
      if (_.contains(schema.branchNames(), 'null')) {
        return true;
      } else {
        throw new ValidationError('Expected union branch to be one of ' + JSON.stringify(schema.branchNames()) + '; got ' + JSON.stringify(obj));
      }
    } else {
      throw new ValidationError('Expected union Javascript object to be non-array object of size 1 or null, got ' + JSON.stringify(obj));
    }
  };

  var _validateEnum = function _validateEnum(schema, obj) {
    if (_.isString(obj)) {
      if (_.contains(schema.symbols, obj)) {
        return true;
      } else {
        throw new ValidationError('Expected enum value to be one of ' + JSON.stringify(schema.symbols) + '; got ' + JSON.stringify(obj));
      }
    } else {
      throw new ValidationError('Expected enum Javascript object to be string, got ' + JSON.stringify(obj));
    }
  };

  var _validateArray = function _validateArray(schema, obj) {
    if (_.isArray(obj)) {
      return _.all(obj, function (member) {
        return _validate(schema.itemSchema, member);
      });
    } else {
      throw new ValidationError('Expected array Javascript object to be array, got ' + JSON.stringify(obj));
    }
  };

  var _validateMap = function _validateMap(schema, obj) {
    if (_.isObject(obj) && !_.isArray(obj)) {
      return _.all(obj, function (value) {
        return _validate(schema.valueSchema, value);
      });
    } else if (_.isArray(obj)) {
      throw new ValidationError('Expected map Javascript object to be non-array object, got array ' + JSON.stringify(obj));
    } else {
      throw new ValidationError('Expected map Javascript object to be non-array object, got ' + JSON.stringify(obj));
    }
  };

  var _validatePrimitive = function _validatePrimitive(schema, obj) {
    switch (schema.type) {
      case 'null':
        if (_.isNull(obj) || _.isUndefined(obj)) {
          return true;
        } else {
          throw new ValidationError('Expected Javascript null or undefined for Avro null, got ' + JSON.stringify(obj));
        }
        break;
      case 'boolean':
        if (_.isBoolean(obj)) {
          return true;
        } else {
          throw new ValidationError('Expected Javascript boolean for Avro boolean, got ' + JSON.stringify(obj));
        }
        break;
      case 'int':
        if (_.isNumber(obj) && Math.floor(obj) === obj && Math.abs(obj) <= Math.pow(2, 31)) {
          return true;
        } else {
          throw new ValidationError('Expected Javascript int32 number for Avro int, got ' + JSON.stringify(obj));
        }
        break;
      case 'long':
        if (_.isNumber(obj) && Math.floor(obj) === obj && Math.abs(obj) <= Math.pow(2, 63)) {
          return true;
        } else {
          throw new ValidationError('Expected Javascript int64 number for Avro long, got ' + JSON.stringify(obj));
        }
        break;
      case 'float':
        if (_.isNumber(obj)) {
          // TODO: handle NaN?
          return true;
        } else {
          throw new ValidationError('Expected Javascript float number for Avro float, got ' + JSON.stringify(obj));
        }
        break;
      case 'double':
        if (_.isNumber(obj)) {
          // TODO: handle NaN?
          return true;
        } else {
          throw new ValidationError('Expected Javascript double number for Avro double, got ' + JSON.stringify(obj));
        }
        break;
      case 'bytes':
        throw new InvalidSchemaError('not yet implemented: ' + schema.type);
      case 'string':
        if (_.isString(obj)) {
          // TODO: handle NaN?
          return true;
        } else {
          throw new ValidationError('Expected Javascript string for Avro string, got ' + JSON.stringify(obj));
        }
        break;
      default:
        throw new InvalidSchemaError('unrecognized primitive type: ' + schema.type);
    }
  };

  // TODO: namespace handling is rudimentary. multiple namespaces within a certain nested schema definition
  // are probably buggy.
  var _namedTypes = namedTypes || {};
  var _saveNamedType = function _saveNamedType(fullyQualifiedTypeName, schema) {
    if (_.has(_namedTypes, fullyQualifiedTypeName)) {
      if (!_.isEqual(_namedTypes[fullyQualifiedTypeName], schema)) {
        throw new InvalidSchemaError('conflicting definitions for type ' + fullyQualifiedTypeName + ': ' + JSON.stringify(_namedTypes[fullyQualifiedTypeName]) + ' and ' + JSON.stringify(schema));
      }
    } else {
      _namedTypes[fullyQualifiedTypeName] = schema;
    }
  };

  var _lookupTypeByFullyQualifiedName = function _lookupTypeByFullyQualifiedName(fullyQualifiedTypeName) {
    if (_.has(_namedTypes, fullyQualifiedTypeName)) {
      return _namedTypes[fullyQualifiedTypeName];
    } else {
      return null;
    }
  };

  var _parseNamedType = function _parseNamedType(schema, namespace) {
    if (_.contains(AvroSpec.PrimitiveTypes, schema)) {
      return new Primitive(schema);
    } else if (!_.isNull(_lookupTypeByFullyQualifiedName(makeFullyQualifiedTypeName(schema, namespace)))) {
      return _lookupTypeByFullyQualifiedName(makeFullyQualifiedTypeName(schema, namespace));
    } else {
      throw new InvalidSchemaError('unknown type name: ' + JSON.stringify(schema) + '; known type names are ' + JSON.stringify(_.keys(_namedTypes)));
    }
  };

  var _parseSchema = function _parseSchema(schema, parentSchema, namespace) {
    if (_.isNull(schema) || _.isUndefined(schema)) {
      throw new InvalidSchemaError('schema is null, in parentSchema: ' + JSON.stringify(parentSchema));
    } else if (_.isString(schema)) {
      return _parseNamedType(schema, namespace);
    } else if (_.isObject(schema) && !_.isArray(schema)) {
      if (schema.type === 'record') {
        var newRecord = new Record(schema.name, schema.namespace, _.map(schema.fields, function (field) {
          return new Field(field.name, _parseSchema(field.type, schema, schema.namespace || namespace));
        }));
        _saveNamedType(makeFullyQualifiedTypeName(schema, namespace), newRecord);
        return newRecord;
      } else if (schema.type === 'enum') {
        if (_.has(schema, 'symbols')) {
          var newEnum = new Enum(schema.symbols);
          _saveNamedType(makeFullyQualifiedTypeName(schema, namespace), newEnum);
          return newEnum;
        } else {
          throw new InvalidSchemaError('enum must specify symbols, got ' + JSON.stringify(schema));
        }
      } else if (schema.type === 'array') {
        if (_.has(schema, 'items')) {
          return new AvroArray(_parseSchema(schema.items, schema, namespace));
        } else {
          throw new InvalidSchemaError('array must specify "items" schema, got ' + JSON.stringify(schema));
        }
      } else if (schema.type === 'map') {
        if (_.has(schema, 'values')) {
          return new Map(_parseSchema(schema.values, schema, namespace));
        } else {
          throw new InvalidSchemaError('map must specify "values" schema, got ' + JSON.stringify(schema));
        }
      } else if (_.has(schema, 'type') && _.contains(AvroSpec.PrimitiveTypes, schema.type)) {
        return _parseNamedType(schema.type, namespace);
      } else {
        throw new InvalidSchemaError('not yet implemented: ' + schema.type);
      }
    } else if (_.isArray(schema)) {
      if (_.isEmpty(schema)) {
        throw new InvalidSchemaError('unions must have at least 1 branch');
      }
      var branchTypes = _.map(schema, function (branchType) {
        return _parseSchema(branchType, schema, namespace);
      });
      return new Union(branchTypes, namespace);
    } else {
      throw new InvalidSchemaError('unexpected Javascript type for schema: ' + (typeof schema === 'undefined' ? 'undefined' : _typeof(schema)));
    }
  };

  this.rawSchema = schema;
  this.schema = _parseSchema(schema, null, namespace);
}

Validator.validate = function (schema, obj) {
  return new Validator(schema).validate(obj);
};

function ProtocolValidator(protocol) {
  this.validate = function (typeName, obj) {
    var fullyQualifiedTypeName = makeFullyQualifiedTypeName(typeName, protocol.namespace);
    if (!_.has(_typeSchemaValidators, fullyQualifiedTypeName)) {
      throw new ProtocolValidationError('Protocol does not contain definition for type ' + JSON.stringify(fullyQualifiedTypeName) + ' (fully qualified from input "' + typeName + '"); known types are ' + JSON.stringify(_.keys(_typeSchemaValidators)));
    }
    return _typeSchemaValidators[fullyQualifiedTypeName].validate(obj);
  };

  var _typeSchemaValidators = {};
  var _initSchemaValidators = function _initSchemaValidators(protocol) {
    var namedTypes = {};
    if (!_.has(protocol, 'protocol') || !_.isString(protocol.protocol)) {
      throw new InvalidProtocolError('Protocol must contain a "protocol" attribute with a string value');
    }
    if (_.isArray(protocol.types)) {
      _.each(protocol.types, function (typeSchema) {
        var schemaValidator = new Validator(typeSchema, protocol.namespace, namedTypes);
        var fullyQualifiedTypeName = makeFullyQualifiedTypeName(typeSchema, protocol.namespace);
        _typeSchemaValidators[fullyQualifiedTypeName] = schemaValidator;
      });
    }
  };

  _initSchemaValidators(protocol);
}

ProtocolValidator.validate = function (protocol, typeName, obj) {
  return new ProtocolValidator(protocol).validate(typeName, obj);
};

if (typeof exports !== 'undefined') {
  exports['Validator'] = Validator;
  exports['ProtocolValidator'] = ProtocolValidator;
}

},{"underscore":257}],131:[function(require,module,exports){
'use strict';

/**
 * Object representing state of an app.
 *
 * @param {String} uri Spotify URI of app.
 * @constructor
 */

function AppState(uri) {
  /**
   * Spotify URI.
   *
   * @type {String}
   */
  this._uri = undefined;

  /**
   * String identifying what requested a state.
   *
   * @type {String}
   */
  this._referrer = undefined;

  if (uri !== undefined) {
    this.setURI(uri);
  }
}

/**
 * Create new instance of AppState based on JSON string.
 *
 * @param {String} json Serialized representation of AppState object.
 * @return {AppState} Instance of AppState.
 */
AppState.unserialize = function (json) {
  var s = JSON.parse(json);
  var a = new AppState();
  a.setURI(s.uri);
  a.setReferrer(s.referrer);
  return a;
};

/**
 * Test if another object is considered equal to this.
 *
 * @param {AppState} state AppState instance to compare.
 */
AppState.prototype.equals = function (state) {
  return typeof this._uri === 'string' && state instanceof AppState && this._uri === state._uri && this._referrer === state._referrer;
};

/**
 * Get App identifier.
 *
 * @return {String} Id of app contained in URI.
 */
AppState.prototype.getAppId = function () {
  var uri = this.getURI();
  var parts = uri.split(':');
  if (parts.length < 3) {
    return undefined;
  }
  if (parts[1] !== 'app') {
    return undefined;
  }
  if (parts[2] === '') {
    return undefined;
  }
  return parts[2];
};

/**
 * Get Referrer value.
 *
 * @return {String} Referrer value as string.
 */
AppState.prototype.getReferrer = function () {
  return this._referrer;
};

/**
 * Get URI value.
 *
 * @return {String} URI as string.
 */
AppState.prototype.getURI = function () {
  if (this._uri === undefined) {
    throw new Error('URI not set');
  }
  return this._uri;
};

/**
 * Create serialized representation of this instance.
 *
 * @return {String} Serialized representation of AppState object.
 */
AppState.prototype.serialize = function () {
  return JSON.stringify({
    uri: this.getURI(),
    referrer: this.getReferrer()
  });
};

/**
 * Set Referrer value.
 *
 * @param {String} referrer Referrer string.
 */
AppState.prototype.setReferrer = function (referrer) {
  this._referrer = referrer;
};

/**
 * Set URI value.
 *
 * @param {String} uri Spotify URI for app.
 */
AppState.prototype.setURI = function (uri) {
  if (typeof uri !== 'string') {
    throw new TypeError('URI must be string');
  }
  this._uri = uri;
};

module.exports = AppState;

},{}],132:[function(require,module,exports){
(function (global){
'use strict';

var inherit = require('spotify-inheritance/inherit');
var EventEmitter = require('spotify-eventemitter');
var AppState = require('./app-state');
var _global = global.top || global;

/**
 * Class containing methods for navigating.
 *
 * @constructor
 */
function Navigator() {
  EventEmitter.call(this);

  /**
   * Locally bound handler function for message event on global.
   *
   * @type {Function}
   */
  this._messageHandler = this._messageHandler.bind(this);
}

inherit(Navigator, EventEmitter);

/**
 * Maps constants to string values of known events.
 */
Navigator.EVENTS = {
  OPEN_STATE: 'navigation_open_state'
};

/**
 * Identify posted message and trigger relevant callbacks
 * based on the message contents.
 *
 * @param {Object} message Message object caused by postMessage.
 */
Navigator.prototype._messageHandler = function (message) {
  if (!message.data.type) {
    return;
  }
  var name = message.data.type;
  if (name === Navigator.EVENTS.OPEN_STATE) {
    var appState = AppState.unserialize(message.data.state);
    this.emitSync(name, { state: appState });
  }
};

/**
 * Start listening to messages.
 */
Navigator.prototype.attachListener = function () {
  _global.addEventListener('message', this._messageHandler);
};

/**
 * Stop listening to messages.
 */
Navigator.prototype.detachListener = function () {
  _global.removeEventListener('message', this._messageHandler);
};

/**
 * Send an open request message.
 *
 * @param {AppState} state AppState instance to base open action on.
 */
Navigator.prototype.requestOpenState = function (state) {
  _global.postMessage({
    type: Navigator.EVENTS.OPEN_STATE,
    state: state.serialize()
  }, '*');
};

module.exports = Navigator;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./app-state":131,"spotify-eventemitter":252,"spotify-inheritance/inherit":255}],133:[function(require,module,exports){
'use strict';

module.exports = function (numeral) {
  return {
    delimiters: {
      thousands: ',',
      decimal: '.'
    },
    abbreviations: {
      thousand: 'k',
      million: 'm',
      billion: 'b',
      trillion: 't'
    },
    ordinal: function ordinal(number) {
      var b = number % 10;
      return ~ ~(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
    },
    currency: {
      symbol: '$'
    }
  };
};

},{}],134:[function(require,module,exports){
'use strict';

var numeral = require('./numeraljs/numeral');
var locales = require('../spotify-locales');

module.exports = function (currentLanguage) {

  // We need to explicitly require all languages listed in spotify-locales
  // so that Quickstart can access them at runtime
  // (dynamic paths can't be cached).
  var languages = {
    'de': require('./numeraljs/languages/de'),
    // Custom en.js file
    'en': require('./en')(numeral),
    // es-419 falls back to es-es in Numeral.js
    'es-ES': require('./numeraljs/languages/es-ES'),
    'fi': require('./numeraljs/languages/fi'),
    'fr': require('./numeraljs/languages/fr'),
    'fr-CA': require('./numeraljs/languages/fr-CA'),
    'hu': require('./numeraljs/languages/hu'),
    'id': require('./numeraljs/languages/id'),
    'it': require('./numeraljs/languages/it'),
    'ja': require('./numeraljs/languages/ja'),
    'nl-nl': require('./numeraljs/languages/nl-nl'),
    'pl': require('./numeraljs/languages/pl'),
    'pt-br': require('./numeraljs/languages/pt-br'),
    'sv': require('./numeraljs/languages/sv'),
    'tr': require('./numeraljs/languages/tr')
  };

  var numeralLocale = locales(currentLanguage, 'numeral');
  if (!languages[numeralLocale]) {
    numeralLocale = 'en';
  }
  numeral.language(numeralLocale, languages[numeralLocale]);
  numeral.language(numeralLocale);

  return numeral;
};

},{"../spotify-locales":123,"./en":133,"./numeraljs/languages/de":135,"./numeraljs/languages/es-ES":136,"./numeraljs/languages/fi":137,"./numeraljs/languages/fr":139,"./numeraljs/languages/fr-CA":138,"./numeraljs/languages/hu":140,"./numeraljs/languages/id":141,"./numeraljs/languages/it":142,"./numeraljs/languages/ja":143,"./numeraljs/languages/nl-nl":144,"./numeraljs/languages/pl":145,"./numeraljs/languages/pt-br":146,"./numeraljs/languages/sv":147,"./numeraljs/languages/tr":148,"./numeraljs/numeral":149}],135:[function(require,module,exports){
'use strict';

/*!
 * numeral.js language configuration
 * language : German (de) – generally useful in Germany, Austria, Luxembourg, Belgium
 * author : Marco Krage : https://github.com/sinky
 */
(function () {
    var language = {
        delimiters: {
            thousands: '.',
            decimal: ','
        },
        abbreviations: {
            thousand: 'k',
            million: 'm',
            billion: 'b',
            trillion: 't'
        },
        ordinal: function ordinal(number) {
            return '.';
        },
        currency: {
            symbol: '€'
        }
    };

    // Node
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = language;
    }
})();

},{}],136:[function(require,module,exports){
'use strict';

/*!
 * numeral.js language configuration
 * language : spanish Spain
 * author : Hernan Garcia : https://github.com/hgarcia
 */
(function () {
    var language = {
        delimiters: {
            thousands: '.',
            decimal: ','
        },
        abbreviations: {
            thousand: 'k',
            million: 'mm',
            billion: 'b',
            trillion: 't'
        },
        ordinal: function ordinal(number) {
            var b = number % 10;
            return b === 1 || b === 3 ? 'er' : b === 2 ? 'do' : b === 7 || b === 0 ? 'mo' : b === 8 ? 'vo' : b === 9 ? 'no' : 'to';
        },
        currency: {
            symbol: '€'
        }
    };

    // Node
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = language;
    }
})();

},{}],137:[function(require,module,exports){
'use strict';

/*!
 * numeral.js language configuration
 * language : Finnish
 * author : Sami Saada : https://github.com/samitheberber
 */
(function () {
    var language = {
        delimiters: {
            thousands: ' ',
            decimal: ','
        },
        abbreviations: {
            thousand: 'k',
            million: 'M',
            billion: 'G',
            trillion: 'T'
        },
        ordinal: function ordinal(number) {
            return '.';
        },
        currency: {
            symbol: '€'
        }
    };

    // Node
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = language;
    }
})();

},{}],138:[function(require,module,exports){
'use strict';

/*!
 * numeral.js language configuration
 * language : french (Canada) (fr-CA)
 * author : Léo Renaud-Allaire : https://github.com/renaudleo
 */
(function () {
    var language = {
        delimiters: {
            thousands: ' ',
            decimal: ','
        },
        abbreviations: {
            thousand: 'k',
            million: 'M',
            billion: 'G',
            trillion: 'T'
        },
        ordinal: function ordinal(number) {
            return number === 1 ? 'er' : 'e';
        },
        currency: {
            symbol: '$'
        }
    };

    // Node
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = language;
    }
})();

},{}],139:[function(require,module,exports){
'use strict';

/*!
 * numeral.js language configuration
 * language : french (fr)
 * author : Adam Draper : https://github.com/adamwdraper
 */
(function () {
    var language = {
        delimiters: {
            thousands: ' ',
            decimal: ','
        },
        abbreviations: {
            thousand: 'k',
            million: 'm',
            billion: 'b',
            trillion: 't'
        },
        ordinal: function ordinal(number) {
            return number === 1 ? 'er' : 'e';
        },
        currency: {
            symbol: '€'
        }
    };

    // Node
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = language;
    }
})();

},{}],140:[function(require,module,exports){
'use strict';

/*!
 * numeral.js language configuration
 * language : Hungarian (hu)
 * author : Peter Bakondy : https://github.com/pbakondy
 */
(function () {
    var language = {
        delimiters: {
            thousands: ' ',
            decimal: ','
        },
        abbreviations: {
            thousand: 'E', // ezer
            million: 'M', // millió
            billion: 'Mrd', // milliárd
            trillion: 'T' // trillió
        },
        ordinal: function ordinal(number) {
            return '.';
        },
        currency: {
            symbol: ' Ft'
        }
    };

    // Node
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = language;
    }
})();

},{}],141:[function(require,module,exports){
'use strict';

/*!
 * numeral.js language configuration
 * language : Indonesian (id)
 */
(function () {
    var language = {
        delimiters: {
            thousands: ',',
            decimal: '.'
        },
        abbreviations: {
            thousand: 'ribu',
            million: 'juta',
            billion: 'miliar',
            trillion: 'triliun'
        },
        ordinal: function ordinal(number) {
            // According to Spotify's internal Indonesian specialist,
            // there is no ordinal symbol in Indonesian (like st, nd, th, º, ª),
            // they just use the word (equivalent to writing: first, second,
            // third, instead of 1st, 2nd, 3rd). And as we don't have such
            // capability to translate all numbers to words, this function
            // returns an empty string and wherever there's a ordinal, it will
            // just show up as the cardinal number.
            return '';
        },
        currency: {
            symbol: 'Rp'
        }
    };

    // Node
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = language;
    }
})();

},{}],142:[function(require,module,exports){
'use strict';

/*!
 * numeral.js language configuration
 * language : italian Italy (it)
 * author : Giacomo Trombi : http://cinquepunti.it
 */
(function () {
    var language = {
        delimiters: {
            thousands: '.',
            decimal: ','
        },
        abbreviations: {
            thousand: 'mila',
            million: 'mil',
            billion: 'b',
            trillion: 't'
        },
        ordinal: function ordinal(number) {
            return 'º';
        },
        currency: {
            symbol: '€'
        }
    };

    // Node
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = language;
    }
})();

},{}],143:[function(require,module,exports){
'use strict';

/*!
 * numeral.js language configuration
 * language : japanese
 * author : teppeis : https://github.com/teppeis
 */
(function () {
    var language = {
        delimiters: {
            thousands: ',',
            decimal: '.'
        },
        abbreviations: {
            thousand: '千',
            million: '百万',
            billion: '十億',
            trillion: '兆'
        },
        ordinal: function ordinal(number) {
            return '.';
        },
        currency: {
            symbol: '¥'
        }
    };

    // Node
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = language;
    }
})();

},{}],144:[function(require,module,exports){
'use strict';

/*!
 * numeral.js language configuration
 * language : netherlands-dutch (nl-nl)
 * author : Dave Clayton : https://github.com/davedx
 */
(function () {
    var language = {
        delimiters: {
            thousands: '.',
            decimal: ','
        },
        abbreviations: {
            thousand: 'k',
            million: 'mln',
            billion: 'mrd',
            trillion: 'bln'
        },
        ordinal: function ordinal(number) {
            var remainder = number % 100;
            return number !== 0 && remainder <= 1 || remainder === 8 || remainder >= 20 ? 'ste' : 'de';
        },
        currency: {
            symbol: '€ '
        }
    };

    // Node
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = language;
    }
})();

},{}],145:[function(require,module,exports){
'use strict';

/*!
 * numeral.js language configuration
 * language : polish (pl)
 * author : Dominik Bulaj : https://github.com/dominikbulaj
 */
(function () {
    var language = {
        delimiters: {
            thousands: ' ',
            decimal: ','
        },
        abbreviations: {
            thousand: 'tys.',
            million: 'mln',
            billion: 'mld',
            trillion: 'bln'
        },
        ordinal: function ordinal(number) {
            return '.';
        },
        currency: {
            symbol: 'PLN'
        }
    };

    // Node
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = language;
    }
})();

},{}],146:[function(require,module,exports){
'use strict';

/*!
 * numeral.js language configuration
 * language : portuguese brazil (pt-br)
 * author : Ramiro Varandas Jr : https://github.com/ramirovjr
 */
(function () {
    var language = {
        delimiters: {
            thousands: '.',
            decimal: ','
        },
        abbreviations: {
            thousand: 'mil',
            million: 'milhões',
            billion: 'b',
            trillion: 't'
        },
        ordinal: function ordinal(number) {
            return 'º';
        },
        currency: {
            symbol: 'R$'
        }
    };

    // Node
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = language;
    }
})();

},{}],147:[function(require,module,exports){
'use strict';

/*!
 * numeral.js language configuration
 * language : swedish
 * author :
 */
(function () {
    var language = {
        delimiters: {
            thousands: ' ',
            decimal: ','
        },
        abbreviations: {
            thousand: 't',
            million: 'mn',
            billion: 'md',
            trillion: 'bn'
        },
        ordinal: function ordinal(number) {
            return '.';
        },
        currency: {
            symbol: 'SEK'
        }
    };

    // Node
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = language;
    }
})();

},{}],148:[function(require,module,exports){
'use strict';

/*!
 * numeral.js language configuration
 * language : turkish (tr)
 * author : Ecmel Ercan : https://github.com/ecmel, Erhan Gundogan : https://github.com/erhangundogan, Burak Yiğit Kaya: https://github.com/BYK
 */
(function () {
    var suffixes = {
        1: '\'inci',
        5: '\'inci',
        8: '\'inci',
        70: '\'inci',
        80: '\'inci',

        2: '\'nci',
        7: '\'nci',
        20: '\'nci',
        50: '\'nci',

        3: '\'üncü',
        4: '\'üncü',
        100: '\'üncü',

        6: '\'ncı',

        9: '\'uncu',
        10: '\'uncu',
        30: '\'uncu',

        60: '\'ıncı',
        90: '\'ıncı'
    },
        language = {
        delimiters: {
            thousands: '.',
            decimal: ','
        },
        abbreviations: {
            thousand: 'bin',
            million: 'milyon',
            billion: 'milyar',
            trillion: 'trilyon'
        },
        ordinal: function ordinal(number) {
            if (number === 0) {
                // special case for zero
                return '\'ıncı';
            }

            var a = number % 10,
                b = number % 100 - a,
                c = number >= 100 ? 100 : null;

            return suffixes[a] || suffixes[b] || suffixes[c];
        },
        currency: {
            symbol: '₺'
        }
    };

    // Node
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = language;
    }
})();

},{}],149:[function(require,module,exports){
'use strict';

/*!
 * numeral.js
 * version : 1.5.3
 * author : Adam Draper
 * license : MIT
 * http://adamwdraper.github.com/Numeral-js/
 */

(function () {

    /************************************
        Constants
    ************************************/

    var _numeral,
        VERSION = '1.5.3',

    // internal storage for language config files
    languages = {},
        currentLanguage = 'en',
        zeroFormat = null,
        defaultFormat = '0,0',

    // check for nodeJS
    hasModule = typeof module !== 'undefined' && module.exports;

    /************************************
        Constructors
    ************************************/

    // Numeral prototype object
    function Numeral(number) {
        this._value = number;
    }

    /**
     * Implementation of toFixed() that treats floats more like decimals
     *
     * Fixes binary rounding issues (eg. (0.615).toFixed(2) === '0.61') that present
     * problems for accounting- and finance-related software.
     */
    function toFixed(value, precision, roundingFunction, optionals) {
        var power = Math.pow(10, precision),
            optionalsRegExp,
            output;

        //roundingFunction = (roundingFunction !== undefined ? roundingFunction : Math.round);
        // Multiply up by precision, round accurately, then divide and use native toFixed():
        output = (roundingFunction(value * power) / power).toFixed(precision);

        if (optionals) {
            optionalsRegExp = new RegExp('0{1,' + optionals + '}$');
            output = output.replace(optionalsRegExp, '');
        }

        return output;
    }

    /************************************
        Formatting
    ************************************/

    // determine what type of formatting we need to do
    function formatNumeral(n, format, roundingFunction) {
        var output;

        // figure out what kind of format we are dealing with
        if (format.indexOf('$') > -1) {
            // currency!!!!!
            output = formatCurrency(n, format, roundingFunction);
        } else if (format.indexOf('%') > -1) {
            // percentage
            output = formatPercentage(n, format, roundingFunction);
        } else if (format.indexOf(':') > -1) {
            // time
            output = formatTime(n, format);
        } else {
            // plain ol' numbers or bytes
            output = formatNumber(n._value, format, roundingFunction);
        }

        // return string
        return output;
    }

    // revert to number
    function unformatNumeral(n, string) {
        var stringOriginal = string,
            thousandRegExp,
            millionRegExp,
            billionRegExp,
            trillionRegExp,
            suffixes = ['KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'],
            bytesMultiplier = false,
            power;

        if (string.indexOf(':') > -1) {
            n._value = unformatTime(string);
        } else {
            if (string === zeroFormat) {
                n._value = 0;
            } else {
                if (languages[currentLanguage].delimiters.decimal !== '.') {
                    string = string.replace(/\./g, '').replace(languages[currentLanguage].delimiters.decimal, '.');
                }

                // see if abbreviations are there so that we can multiply to the correct number
                thousandRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.thousand + '(?:\\)|(\\' + languages[currentLanguage].currency.symbol + ')?(?:\\))?)?$');
                millionRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.million + '(?:\\)|(\\' + languages[currentLanguage].currency.symbol + ')?(?:\\))?)?$');
                billionRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.billion + '(?:\\)|(\\' + languages[currentLanguage].currency.symbol + ')?(?:\\))?)?$');
                trillionRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.trillion + '(?:\\)|(\\' + languages[currentLanguage].currency.symbol + ')?(?:\\))?)?$');

                // see if bytes are there so that we can multiply to the correct number
                for (power = 0; power <= suffixes.length; power++) {
                    bytesMultiplier = string.indexOf(suffixes[power]) > -1 ? Math.pow(1024, power + 1) : false;

                    if (bytesMultiplier) {
                        break;
                    }
                }

                // do some math to create our number
                n._value = (bytesMultiplier ? bytesMultiplier : 1) * (stringOriginal.match(thousandRegExp) ? Math.pow(10, 3) : 1) * (stringOriginal.match(millionRegExp) ? Math.pow(10, 6) : 1) * (stringOriginal.match(billionRegExp) ? Math.pow(10, 9) : 1) * (stringOriginal.match(trillionRegExp) ? Math.pow(10, 12) : 1) * (string.indexOf('%') > -1 ? 0.01 : 1) * ((string.split('-').length + Math.min(string.split('(').length - 1, string.split(')').length - 1)) % 2 ? 1 : -1) * Number(string.replace(/[^0-9\.]+/g, ''));

                // round if we are talking about bytes
                n._value = bytesMultiplier ? Math.ceil(n._value) : n._value;
            }
        }
        return n._value;
    }

    function formatCurrency(n, format, roundingFunction) {
        var symbolIndex = format.indexOf('$'),
            openParenIndex = format.indexOf('('),
            minusSignIndex = format.indexOf('-'),
            space = '',
            spliceIndex,
            output;

        // check for space before or after currency
        if (format.indexOf(' $') > -1) {
            space = ' ';
            format = format.replace(' $', '');
        } else if (format.indexOf('$ ') > -1) {
            space = ' ';
            format = format.replace('$ ', '');
        } else {
            format = format.replace('$', '');
        }

        // format the number
        output = formatNumber(n._value, format, roundingFunction);

        // position the symbol
        if (symbolIndex <= 1) {
            if (output.indexOf('(') > -1 || output.indexOf('-') > -1) {
                output = output.split('');
                spliceIndex = 1;
                if (symbolIndex < openParenIndex || symbolIndex < minusSignIndex) {
                    // the symbol appears before the "(" or "-"
                    spliceIndex = 0;
                }
                output.splice(spliceIndex, 0, languages[currentLanguage].currency.symbol + space);
                output = output.join('');
            } else {
                output = languages[currentLanguage].currency.symbol + space + output;
            }
        } else {
            if (output.indexOf(')') > -1) {
                output = output.split('');
                output.splice(-1, 0, space + languages[currentLanguage].currency.symbol);
                output = output.join('');
            } else {
                output = output + space + languages[currentLanguage].currency.symbol;
            }
        }

        return output;
    }

    function formatPercentage(n, format, roundingFunction) {
        var space = '',
            output,
            value = n._value * 100;

        // check for space before %
        if (format.indexOf(' %') > -1) {
            space = ' ';
            format = format.replace(' %', '');
        } else {
            format = format.replace('%', '');
        }

        output = formatNumber(value, format, roundingFunction);

        if (output.indexOf(')') > -1) {
            output = output.split('');
            output.splice(-1, 0, space + '%');
            output = output.join('');
        } else {
            output = output + space + '%';
        }

        return output;
    }

    function formatTime(n) {
        var hours = Math.floor(n._value / 60 / 60),
            minutes = Math.floor((n._value - hours * 60 * 60) / 60),
            seconds = Math.round(n._value - hours * 60 * 60 - minutes * 60);
        return hours + ':' + (minutes < 10 ? '0' + minutes : minutes) + ':' + (seconds < 10 ? '0' + seconds : seconds);
    }

    function unformatTime(string) {
        var timeArray = string.split(':'),
            seconds = 0;
        // turn hours and minutes into seconds and add them all up
        if (timeArray.length === 3) {
            // hours
            seconds = seconds + Number(timeArray[0]) * 60 * 60;
            // minutes
            seconds = seconds + Number(timeArray[1]) * 60;
            // seconds
            seconds = seconds + Number(timeArray[2]);
        } else if (timeArray.length === 2) {
            // minutes
            seconds = seconds + Number(timeArray[0]) * 60;
            // seconds
            seconds = seconds + Number(timeArray[1]);
        }
        return Number(seconds);
    }

    function formatNumber(value, format, roundingFunction) {
        var negP = false,
            signed = false,
            optDec = false,
            abbr = '',
            abbrK = false,
            // force abbreviation to thousands
        abbrM = false,
            // force abbreviation to millions
        abbrB = false,
            // force abbreviation to billions
        abbrT = false,
            // force abbreviation to trillions
        abbrForce = false,
            // force abbreviation
        bytes = '',
            ord = '',
            abs = Math.abs(value),
            suffixes = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'],
            min,
            max,
            power,
            w,
            precision,
            thousands,
            d = '',
            neg = false;

        // check if number is zero and a custom zero format has been set
        if (value === 0 && zeroFormat !== null) {
            return zeroFormat;
        } else {
            // see if we should use parentheses for negative number or if we should prefix with a sign
            // if both are present we default to parentheses
            if (format.indexOf('(') > -1) {
                negP = true;
                format = format.slice(1, -1);
            } else if (format.indexOf('+') > -1) {
                signed = true;
                format = format.replace(/\+/g, '');
            }

            // see if abbreviation is wanted
            if (format.indexOf('a') > -1) {
                // check if abbreviation is specified
                abbrK = format.indexOf('aK') >= 0;
                abbrM = format.indexOf('aM') >= 0;
                abbrB = format.indexOf('aB') >= 0;
                abbrT = format.indexOf('aT') >= 0;
                abbrForce = abbrK || abbrM || abbrB || abbrT;

                // check for space before abbreviation
                if (format.indexOf(' a') > -1) {
                    abbr = ' ';
                    format = format.replace(' a', '');
                } else {
                    format = format.replace('a', '');
                }

                if (abs >= Math.pow(10, 12) && !abbrForce || abbrT) {
                    // trillion
                    abbr = abbr + languages[currentLanguage].abbreviations.trillion;
                    value = value / Math.pow(10, 12);
                } else if (abs < Math.pow(10, 12) && abs >= Math.pow(10, 9) && !abbrForce || abbrB) {
                    // billion
                    abbr = abbr + languages[currentLanguage].abbreviations.billion;
                    value = value / Math.pow(10, 9);
                } else if (abs < Math.pow(10, 9) && abs >= Math.pow(10, 6) && !abbrForce || abbrM) {
                    // million
                    abbr = abbr + languages[currentLanguage].abbreviations.million;
                    value = value / Math.pow(10, 6);
                } else if (abs < Math.pow(10, 6) && abs >= Math.pow(10, 3) && !abbrForce || abbrK) {
                    // thousand
                    abbr = abbr + languages[currentLanguage].abbreviations.thousand;
                    value = value / Math.pow(10, 3);
                }
            }

            // see if we are formatting bytes
            if (format.indexOf('b') > -1) {
                // check for space before
                if (format.indexOf(' b') > -1) {
                    bytes = ' ';
                    format = format.replace(' b', '');
                } else {
                    format = format.replace('b', '');
                }

                for (power = 0; power <= suffixes.length; power++) {
                    min = Math.pow(1024, power);
                    max = Math.pow(1024, power + 1);

                    if (value >= min && value < max) {
                        bytes = bytes + suffixes[power];
                        if (min > 0) {
                            value = value / min;
                        }
                        break;
                    }
                }
            }

            // see if ordinal is wanted
            if (format.indexOf('o') > -1) {
                // check for space before
                if (format.indexOf(' o') > -1) {
                    ord = ' ';
                    format = format.replace(' o', '');
                } else {
                    format = format.replace('o', '');
                }

                ord = ord + languages[currentLanguage].ordinal(value);
            }

            if (format.indexOf('[.]') > -1) {
                optDec = true;
                format = format.replace('[.]', '.');
            }

            w = value.toString().split('.')[0];
            precision = format.split('.')[1];
            thousands = format.indexOf(',');

            if (precision) {
                if (precision.indexOf('[') > -1) {
                    precision = precision.replace(']', '');
                    precision = precision.split('[');
                    d = toFixed(value, precision[0].length + precision[1].length, roundingFunction, precision[1].length);
                } else {
                    d = toFixed(value, precision.length, roundingFunction);
                }

                w = d.split('.')[0];

                if (d.split('.')[1].length) {
                    d = languages[currentLanguage].delimiters.decimal + d.split('.')[1];
                } else {
                    d = '';
                }

                if (optDec && Number(d.slice(1)) === 0) {
                    d = '';
                }
            } else {
                w = toFixed(value, null, roundingFunction);
            }

            // format number
            if (w.indexOf('-') > -1) {
                w = w.slice(1);
                neg = true;
            }

            if (thousands > -1) {
                w = w.toString().replace(/(\d)(?=(\d{3})+(?!\d))/g, '$1' + languages[currentLanguage].delimiters.thousands);
            }

            if (format.indexOf('.') === 0) {
                w = '';
            }

            return (negP && neg ? '(' : '') + (!negP && neg ? '-' : '') + (!neg && signed ? '+' : '') + w + d + (ord ? ord : '') + (abbr ? abbr : '') + (bytes ? bytes : '') + (negP && neg ? ')' : '');
        }
    }

    /************************************
        Top Level Functions
    ************************************/

    _numeral = function numeral(input) {
        if (_numeral.isNumeral(input)) {
            input = input.value();
        } else if (input === 0 || typeof input === 'undefined') {
            input = 0;
        } else if (!Number(input)) {
            input = _numeral.fn.unformat(input);
        }

        return new Numeral(Number(input));
    };

    // version number
    _numeral.version = VERSION;

    // compare numeral object
    _numeral.isNumeral = function (obj) {
        return obj instanceof Numeral;
    };

    // This function will load languages and then set the global language.  If
    // no arguments are passed in, it will simply return the current global
    // language key.
    _numeral.language = function (key, values) {
        if (!key) {
            return currentLanguage;
        }

        if (key && !values) {
            if (!languages[key]) {
                throw new Error('Unknown language : ' + key);
            }
            currentLanguage = key;
        }

        if (values || !languages[key]) {
            loadLanguage(key, values);
        }

        return _numeral;
    };

    // This function provides access to the loaded language data.  If
    // no arguments are passed in, it will simply return the current
    // global language object.
    _numeral.languageData = function (key) {
        if (!key) {
            return languages[currentLanguage];
        }

        if (!languages[key]) {
            throw new Error('Unknown language : ' + key);
        }

        return languages[key];
    };

    _numeral.language('en', {
        delimiters: {
            thousands: ',',
            decimal: '.'
        },
        abbreviations: {
            thousand: 'k',
            million: 'm',
            billion: 'b',
            trillion: 't'
        },
        ordinal: function ordinal(number) {
            var b = number % 10;
            return ~ ~(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
        },
        currency: {
            symbol: '$'
        }
    });

    _numeral.zeroFormat = function (format) {
        zeroFormat = typeof format === 'string' ? format : null;
    };

    _numeral.defaultFormat = function (format) {
        defaultFormat = typeof format === 'string' ? format : '0.0';
    };

    /************************************
        Helpers
    ************************************/

    function loadLanguage(key, values) {
        languages[key] = values;
    }

    /************************************
        Floating-point helpers
    ************************************/

    // The floating-point helper functions and implementation
    // borrows heavily from sinful.js: http://guipn.github.io/sinful.js/

    /**
     * Array.prototype.reduce for browsers that don't support it
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce#Compatibility
     */
    if ('function' !== typeof Array.prototype.reduce) {
        Array.prototype.reduce = function (callback, opt_initialValue) {
            'use strict';

            if (null === this || 'undefined' === typeof this) {
                // At the moment all modern browsers, that support strict mode, have
                // native implementation of Array.prototype.reduce. For instance, IE8
                // does not support strict mode, so this check is actually useless.
                throw new TypeError('Array.prototype.reduce called on null or undefined');
            }

            if ('function' !== typeof callback) {
                throw new TypeError(callback + ' is not a function');
            }

            var index,
                value,
                length = this.length >>> 0,
                isValueSet = false;

            if (1 < arguments.length) {
                value = opt_initialValue;
                isValueSet = true;
            }

            for (index = 0; length > index; ++index) {
                if (this.hasOwnProperty(index)) {
                    if (isValueSet) {
                        value = callback(value, this[index], index, this);
                    } else {
                        value = this[index];
                        isValueSet = true;
                    }
                }
            }

            if (!isValueSet) {
                throw new TypeError('Reduce of empty array with no initial value');
            }

            return value;
        };
    }

    /**
     * Computes the multiplier necessary to make x >= 1,
     * effectively eliminating miscalculations caused by
     * finite precision.
     */
    function multiplier(x) {
        var parts = x.toString().split('.');
        if (parts.length < 2) {
            return 1;
        }
        return Math.pow(10, parts[1].length);
    }

    /**
     * Given a variable number of arguments, returns the maximum
     * multiplier that must be used to normalize an operation involving
     * all of them.
     */
    function correctionFactor() {
        var args = Array.prototype.slice.call(arguments);
        return args.reduce(function (prev, next) {
            var mp = multiplier(prev),
                mn = multiplier(next);
            return mp > mn ? mp : mn;
        }, -Infinity);
    }

    /************************************
        Numeral Prototype
    ************************************/

    _numeral.fn = Numeral.prototype = {

        clone: function clone() {
            return _numeral(this);
        },

        format: function format(inputString, roundingFunction) {
            return formatNumeral(this, inputString ? inputString : defaultFormat, roundingFunction !== undefined ? roundingFunction : Math.round);
        },

        unformat: function unformat(inputString) {
            if (Object.prototype.toString.call(inputString) === '[object Number]') {
                return inputString;
            }
            return unformatNumeral(this, inputString ? inputString : defaultFormat);
        },

        value: function value() {
            return this._value;
        },

        valueOf: function valueOf() {
            return this._value;
        },

        set: function set(value) {
            this._value = Number(value);
            return this;
        },

        add: function add(value) {
            var corrFactor = correctionFactor.call(null, this._value, value);
            function cback(accum, curr, currI, O) {
                return accum + corrFactor * curr;
            }
            this._value = [this._value, value].reduce(cback, 0) / corrFactor;
            return this;
        },

        subtract: function subtract(value) {
            var corrFactor = correctionFactor.call(null, this._value, value);
            function cback(accum, curr, currI, O) {
                return accum - corrFactor * curr;
            }
            this._value = [value].reduce(cback, this._value * corrFactor) / corrFactor;
            return this;
        },

        multiply: function multiply(value) {
            function cback(accum, curr, currI, O) {
                var corrFactor = correctionFactor(accum, curr);
                return accum * corrFactor * (curr * corrFactor) / (corrFactor * corrFactor);
            }
            this._value = [this._value, value].reduce(cback, 1);
            return this;
        },

        divide: function divide(value) {
            function cback(accum, curr, currI, O) {
                var corrFactor = correctionFactor(accum, curr);
                return accum * corrFactor / (curr * corrFactor);
            }
            this._value = [this._value, value].reduce(cback);
            return this;
        },

        difference: function difference(value) {
            return Math.abs(_numeral(this._value).subtract(value).value());
        }

    };

    /************************************
        Exposing Numeral
    ************************************/

    module.exports = _numeral;
}).call(undefined);

},{}],150:[function(require,module,exports){
/**
 * @module spotify-range2
 */
'use strict';

var prime = require('prime');

var map = require('mout/array/map');

var push_ = Array.prototype.push;
var slice_ = Array.prototype.slice;

var Range = prime( /** @lends Range.prototype */{

  /**
   * The representation of a range
   * @constructs
   * @param {Number} start The start of the range.
   * @param {Number} end The end of the range.
   */
  constructor: function Range(start, end) {
    this.update(start, end);
  },

  /** Update a range. */
  update: function update(start, end) {
    if (start !== null) this.start = start;
    if (end !== null) this.end = end;
    if (this.start === null || this.end === null) throw new Error('invalid range');
    if (this.start > this.end) throw new Error('invalid range');
    this.length = this.end - this.start;
    return this;
  },

  /** Copy a range. */
  copy: function copy() {
    return new Range(this.start, this.end);
  },

  /** Range is above range. */
  above: function above(range) {
    if (!range) return false;
    return this.start >= range.end;
  },

  /** Range is below range. */
  below: function below(range) {
    if (!range) return false;
    return this.end <= range.start;
  },

  adjacent: function adjacent(range) {
    if (!range) return false;
    return this.end === range.start || this.start === range.end;
  },

  /** Range intersects range. */
  intersects: function intersects(range) {
    if (!range) return false;
    return !this.above(range) && !this.below(range);
  },

  /** Range contains range. */
  contains: function contains(range) {
    if (!range) return false;
    return this.start <= range.start && this.end >= range.end;
  },

  /** Range is contained by ranges. */
  contained: function contained(range) {
    var ranges;
    if (range instanceof Range) ranges = arguments;else ranges = range;
    if (!ranges) return false;

    for (var i = 0; ranges[i] !== undefined; i++) {
      var r = ranges[i];
      if (r.start <= this.start && r.end >= this.end) {
        return true;
      }
    }
    return false;
  },

  /** Range fits two ranges. */
  fits: function fits(prev, next) {
    if (!prev && !next) return true;
    if (!prev) return this.end <= next.start;
    if (!next) return this.start >= prev.end;
    return this.start >= prev.end && this.end <= next.start;
  },

  // get the section of this range contained between two ranges
  // [0, 20] » [0, 8], [16, 20] » [8, 16]

  /** portion of a range between two ranges. */
  between: function between(prev, next) {
    if (!prev && !next) return this.copy();
    if (!prev) return this.start >= next.start ? null : new Range(this.start, Math.min(this.end, next.start));
    if (!next) return this.end <= prev.end ? null : new Range(Math.max(prev.end, this.start), this.end);

    return this.end > prev.end && this.start < next.start ? new Range(Math.max(prev.end, this.start), Math.min(next.start, this.end)) : null;
  },

  // [0, 8] » [0, 2], [4, 5] = [0, 2], [4, 5]
  // [3, 6] » [5, 7] = [5, 6]
  // [6, 9] » [5, 7] = [6, 7]

  /** intersection of a range with many ranges */
  intersection: function intersection(range) {
    var intersected = [];
    var ranges;
    if (range instanceof Range) ranges = arguments;else ranges = range;
    for (var k = 0; k < ranges.length; k++) {
      var r = ranges[k];
      if (this.below(r)) break;

      if (r.intersects(this)) intersected.push(new Range(Math.max(this.start, r.start), Math.min(this.end, r.end)));
    }
    return intersected;
  },

  // subtract ranges from this range
  // [0, 8] » [0, 2], [4, 5] = [2, 4], [5, 8]

  /** subtract many ranges from the range. */
  subtract: function subtract(range) {
    var subtracted = [];
    var ranges;
    if (range instanceof Range) ranges = arguments;else ranges = range;
    for (var k = -1; k < ranges.length; k++) {
      var prev = ranges[k];
      var next = ranges[k + 1];
      var between = this.between(prev, next);
      if (between) subtracted.push(between);
    }
    return subtracted;
  },

  // extract this range from ranges
  // [0, 8] » [0, 2], [5, 8] = []
  // [8, 20] » [0, 2], [5, 8] = [0, 2], [5, 8]
  // [0, 10] » [5, 10], [15, 20] = [5, 10]
  // [10, 20] » [5, 80], [90, 100] = [5, 70] [80, 90]
  // [10, 20] » [0, 10], [20, 30] = [0, 20]

  /** extract the range from many ranges. */
  extract: function extract(range) {
    var ranges = range instanceof Range ? slice_.call(arguments) : range.slice();

    for (var k = 0; k < ranges.length; k++) {
      var prev = ranges[k - 1];
      var next = ranges[k];

      var newRange = null;

      if (this.below(next)) {
        newRange = new Range(next.start - this.length, next.end - this.length);
      } else if (this.intersects(next)) {
        var subtracted = next.subtract(this);
        if (subtracted.length === 2) {
          // is contained
          newRange = new Range(subtracted[0].start, subtracted[1].end - this.length);
        } else if (subtracted.length === 1) {
          if (next.end > this.end) {
            // second segment kept
            newRange = new Range(subtracted[0].start - this.length, subtracted[0].end - this.length);
          } else if (this.start > next.start) {
            // first segment kept
            newRange = new Range(subtracted[0].start, subtracted[0].end);
          }
        } else {
          // gets eaten
          ranges.splice(k--, 1); // decrease k
        }
      } else {
          ranges.splice(k, 1, next.copy());
        }

      if (newRange) {
        if (prev && prev.end === newRange.start) {
          // touches previous
          ranges.splice(k-- - 1, 2, new Range(prev.start, newRange.end)); // decrease k due to splicing
        } else {
            ranges.splice(k, 1, newRange);
          }
      }
    }

    return ranges;
  },

  // [2,3] » [0,1], [2,3] = [0,1], [2,4]
  // [1,2] » [0,6] = [0,7]
  // [0,1] » [0,1], [5,6] = [0,2], [6,7]
  // [4,6] » [0,1], [5,6] = [0,1], [4,6], [7,8]

  // TODO: this can be slightly better. merging can be done in one loop.

  /** insert the range in many ranges. */
  insert: function insert(range) {
    var ranges = range instanceof Range ? slice_.call(arguments) : range.slice();

    for (var k = 0; k < ranges.length; k++) {
      var next = ranges[k];

      if (this.start >= next.end) {
        ranges.splice(k, 1, next.copy());
      } else if (this.start > next.start && this.start < next.end) {
        ranges.splice(k, 1, new Range(next.start, this.start), new Range(this.start, next.end));
      } else {
        ranges.splice(k, 1, new Range(next.start + this.length, next.end + this.length));
      }
    }

    return this.merge(ranges);
  },

  // merge this range in ranges
  // [0, 8] » [0, 2], [5, 8] = [0, 8]
  // [8, 20] » [0, 2], [5, 8] = [0, 2], [5, 20]
  // [0, 10] » [5, 10], [15, 20] = [0, 10], [15, 20]

  /** merge many ranges to the range. */
  merge: function merge(range) {
    var ranges;
    if (range instanceof Range) ranges = arguments;else ranges = range;

    ranges = map(ranges, function (r) {
      return r.copy();
    });

    if (!ranges.length) return [this.copy()];

    var k;
    var l;

    for (k = -1, l = ranges.length; k < l; k++) {
      var prev = ranges[k];
      var next = ranges[k + 1];
      var between = this.between(prev, next);

      if (between) {
        if (!prev && next) {
          if (between.end === next.start) {
            next.update(between.start, next.end);
          } else {
            k++; // increase k since we had a push
            ranges.unshift(between);
          }
        } else if (prev && next) {
          if (prev.end === between.start && between.end === next.start) {
            prev.update(prev.start, next.end);
            ranges.splice(k-- + 1, 1); // remove the next, decrease k since we had a splice
          } else if (prev.end === between.start) {
              prev.update(prev.start, between.end);
            } else if (between.end === next.start) {
              next.update(between.start, next.end);
            } else {
              ranges.splice(k + 1, 0, between);
            }
        } else if (prev && !next) {
          if (prev.end === between.start) {
            prev.update(prev.start, between.end);
          } else {
            k++; // increase k since we had a push
            ranges.push(between);
          }
        }
      }
    }

    return ranges;
  },

  /** Remove range from many ranges
      - The range(s) you pass is what you remove from */
  remove: function remove(range) {
    var ranges;
    if (range instanceof Range) ranges = arguments;else ranges = range;
    var result = [];
    for (var i = 0; i < ranges.length; i++) {
      var remaining = ranges[i].subtract(this);
      if (remaining.length) push_.apply(result, remaining);
    }
    return result;
  },

  /** Range to an array of indices */
  toIndices: function toIndices() {
    var indices = [];
    for (var i = this.start; i < this.end; i++) {
      indices.push(i);
    }return indices;
  },

  /** Range to a string */
  toString: function toString() {
    return [this.start, this.end] + '';
  }

});

/**
 * Range from a string
 * @memberof Range
 * @static
 * @param {String} string - The string.
 * @return {Range} The range.
 */
Range.fromString = function (string) {
  var parts = string.split(',');
  return new Range(+parts[0], +parts[1]);
};

/**
 * Ranges from an array of indices
 * @memberof Range
 * @static
 * @param {Array} indices - An array of indices.
 * @return {Array} An array of Ranges.
 */
Range.fromIndices = function (indices) {
  indices.sort(function (a, b) {
    return a > b ? 1 : -1;
  });

  var ranges = [];
  var rstart;
  var rend;

  for (var i = 0; i < indices.length; i++) {
    rstart = indices[i];
    rend = rstart;
    while (indices[i + 1] - indices[i] === 1) {
      rend = indices[i + 1]; // increment the index if the numbers sequential
      i++;
    }
    ranges.push(new Range(rstart, rend + 1));
  }

  return ranges;
};

/**
 * A function that returns a range.
 * @function
 * @see Range
 * @param {Number} start The start of the range.
 * @param {Number} end The end of the range.
 */
module.exports = Range;

},{"mout/array/map":203,"prime":235}],151:[function(require,module,exports){
(function (global){
'use strict';

module.exports = {
  ENABLED: '1',
  DISABLED: '0',
  TEST_NAME: 'ab-desktop-shuffle',
  isEnabled: function isEnabled() {
    return global.__spotify && global.__spotify.product_state && global.__spotify.product_state[this.TEST_NAME] === this.ENABLED || false;
  }

};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],152:[function(require,module,exports){
'use strict';

function Translations() {
  this._data = {};

  // ensure that the context of the get method is always this object
  this.get = this.get.bind(this);
}

/**
 * Default implementation if the
 * locale is not loaded
 */
Translations.prototype.injectData = function (data) {
  this._data = data;
};

/**
 * Get a translation
 */
Translations.prototype.get = function (key, var_args) {
  var format = this._data.hasOwnProperty(key) ? this._data[key] : key;
  var args = arguments;

  return format.replace(/\{(\d+?)\}/g, function (str, num) {
    var value = args[+num + 1];

    // Do not change by a ||. A value of an empty string would make it fail.
    return typeof value !== 'undefined' ? value : str;
  });
};

/**
 * Gets the raw translations data
 * @return {Object} Locale object
 */
Translations.prototype.getData = function () {
  return this._data;
};

/**
 * Creates a translations instance with the specified data
 *
 * @param {Object} data Translations object
 * @return {Translations}
 */
Translations.createWithData = function (data) {
  var translations = new Translations();
  translations.injectData(data);
  return translations;
};

module.exports = Translations;

},{}],153:[function(require,module,exports){
/**
 * BezierEasing - use bezier curve for transition easing function
 * by Gaëtan Renaudeau 2014 - 2015 – MIT License
 *
 * Credits: is based on Firefox's nsSMILKeySpline.cpp
 * Usage:
 * var spline = BezierEasing([ 0.25, 0.1, 0.25, 1.0 ])
 * spline.get(x) => returns the easing value | x must be in [0, 1] range
 *
 */

// These values are established by empiricism with tests (tradeoff: performance VS precision)
var NEWTON_ITERATIONS = 4;
var NEWTON_MIN_SLOPE = 0.001;
var SUBDIVISION_PRECISION = 0.0000001;
var SUBDIVISION_MAX_ITERATIONS = 10;

var kSplineTableSize = 11;
var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);

var float32ArraySupported = typeof Float32Array === "function";

function A (aA1, aA2) { return 1.0 - 3.0 * aA2 + 3.0 * aA1; }
function B (aA1, aA2) { return 3.0 * aA2 - 6.0 * aA1; }
function C (aA1)      { return 3.0 * aA1; }

// Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.
function calcBezier (aT, aA1, aA2) {
  return ((A(aA1, aA2)*aT + B(aA1, aA2))*aT + C(aA1))*aT;
}

// Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.
function getSlope (aT, aA1, aA2) {
  return 3.0 * A(aA1, aA2)*aT*aT + 2.0 * B(aA1, aA2) * aT + C(aA1);
}

function binarySubdivide (aX, aA, aB, mX1, mX2) {
  var currentX, currentT, i = 0;
  do {
    currentT = aA + (aB - aA) / 2.0;
    currentX = calcBezier(currentT, mX1, mX2) - aX;
    if (currentX > 0.0) {
      aB = currentT;
    } else {
      aA = currentT;
    }
  } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);
  return currentT;
}

function newtonRaphsonIterate (aX, aGuessT, mX1, mX2) {
  for (var i = 0; i < NEWTON_ITERATIONS; ++i) {
    var currentSlope = getSlope(aGuessT, mX1, mX2);
    if (currentSlope === 0.0) return aGuessT;
    var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
    aGuessT -= currentX / currentSlope;
  }
  return aGuessT;
}

/**
 * points is an array of [ mX1, mY1, mX2, mY2 ]
 */
function BezierEasing (points, b, c, d) {
  if (arguments.length === 4) {
    return new BezierEasing([ points, b, c, d ]);
  }
  if (!(this instanceof BezierEasing)) return new BezierEasing(points);

  if (!points || points.length !== 4) {
    throw new Error("BezierEasing: points must contains 4 values");
  }
  for (var i=0; i<4; ++i) {
    if (typeof points[i] !== "number" || isNaN(points[i]) || !isFinite(points[i])) {
      throw new Error("BezierEasing: points should be integers.");
    }
  }
  if (points[0] < 0 || points[0] > 1 || points[2] < 0 || points[2] > 1) {
    throw new Error("BezierEasing x values must be in [0, 1] range.");
  }

  this._str = "BezierEasing("+points+")";
  this._css = "cubic-bezier("+points+")";
  this._p = points;
  this._mSampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);
  this._precomputed = false;

  this.get = this.get.bind(this);
}

BezierEasing.prototype = {

  get: function (x) {
    var mX1 = this._p[0],
      mY1 = this._p[1],
      mX2 = this._p[2],
      mY2 = this._p[3];
    if (!this._precomputed) this._precompute();
    if (mX1 === mY1 && mX2 === mY2) return x; // linear
    // Because JavaScript number are imprecise, we should guarantee the extremes are right.
    if (x === 0) return 0;
    if (x === 1) return 1;
    return calcBezier(this._getTForX(x), mY1, mY2);
  },

  getPoints: function() {
    return this._p;
  },

  toString: function () {
    return this._str;
  },

  toCSS: function () {
    return this._css;
  },

  // Private part

  _precompute: function () {
    var mX1 = this._p[0],
      mY1 = this._p[1],
      mX2 = this._p[2],
      mY2 = this._p[3];
    this._precomputed = true;
    if (mX1 !== mY1 || mX2 !== mY2)
      this._calcSampleValues();
  },

  _calcSampleValues: function () {
    var mX1 = this._p[0],
      mX2 = this._p[2];
    for (var i = 0; i < kSplineTableSize; ++i) {
      this._mSampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
    }
  },

  /**
   * getTForX chose the fastest heuristic to determine the percentage value precisely from a given X projection.
   */
  _getTForX: function (aX) {
    var mX1 = this._p[0],
      mX2 = this._p[2],
      mSampleValues = this._mSampleValues;

    var intervalStart = 0.0;
    var currentSample = 1;
    var lastSample = kSplineTableSize - 1;

    for (; currentSample !== lastSample && mSampleValues[currentSample] <= aX; ++currentSample) {
      intervalStart += kSampleStepSize;
    }
    --currentSample;

    // Interpolate to provide an initial guess for t
    var dist = (aX - mSampleValues[currentSample]) / (mSampleValues[currentSample+1] - mSampleValues[currentSample]);
    var guessForT = intervalStart + dist * kSampleStepSize;

    var initialSlope = getSlope(guessForT, mX1, mX2);
    if (initialSlope >= NEWTON_MIN_SLOPE) {
      return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
    } else if (initialSlope === 0.0) {
      return guessForT;
    } else {
      return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
    }
  }
};

// CSS mapping
BezierEasing.css = {
  "ease":        BezierEasing.ease      = BezierEasing(0.25, 0.1, 0.25, 1.0),
  "linear":      BezierEasing.linear    = BezierEasing(0.00, 0.0, 1.00, 1.0),
  "ease-in":     BezierEasing.easeIn    = BezierEasing(0.42, 0.0, 1.00, 1.0),
  "ease-out":    BezierEasing.easeOut   = BezierEasing(0.00, 0.0, 0.58, 1.0),
  "ease-in-out": BezierEasing.easeInOut = BezierEasing(0.42, 0.0, 0.58, 1.0)
};

module.exports = BezierEasing;

},{}],154:[function(require,module,exports){
'use strict';

exports.message = require('./src/message');
exports.request = require('./src/request');
exports.response = require('./src/response');
exports.playerstate = require('./src/player_state');

},{"./src/message":155,"./src/player_state":156,"./src/request":157,"./src/response":158}],155:[function(require,module,exports){
/**
 * A set of Message headers.
 *
 * @name exports.Headers
 * @typedef {Object.<string, string>}
 */
exports.Headers;

/**
 * A body of a Request-Response.
 *
 * @name exports.Body
 * @typedef {*}
 */
exports.Body;

/**
 * A serialized Message object.
 *
 * @name Spotify.Cosmos.SerializedMessage
 * @typedef {{
 *   uri: Spotify.Cosmos.URI,
 *   headers: Spotify.Cosmos.Headers,
 *   body: Spotify.Cosmos.Body
 * }}
 */
exports.SerializedMessage;

/**
 * Encapsulates a message.
 *
 * A message is an entity that has a URI, headers and a body.
 *
 * @constructs Spotify.Cosmos.Message
 * @param {Spotify.Cosmos.URI} uri The URI of the message
 * @param {Spotify.Cosmos.Headers=} opt_headers The optional headers of the
 *     message.
 * @param {Spotify.Cosmos.Body=} opt_body The optional body of the message.
 */
function Message(uri, opt_headers, opt_body) {
  if (uri == null)
    throw new TypeError('Invalid `uri` argument for Message.');

  /**
   * The URI of the Message.
   *
   * @type {Spotify.Cosmos.URI}
   * @protected
   */
  this._uri = uri;

  /**
   * The headers of the Message.
   *
   * @type {Spotify.Cosmos.Headers}
   * @protected
   */
  this._headers = {};

  /**
   * The body of the Message.
   *
   * @type {Spotify.Cosmos.Body}
   * @protected
   */
  this._body = this._encodeBody(opt_body || '');

  if (opt_headers) this._setHeaders(opt_headers);
}
exports.Message = Message;

/**
 * Creates a new Message from a SerializedMessage object.
 *
 * @param {Spotify.Cosmos.SerializedMessage} object The serialized request.
 * @return {Spotify.Cosmos.Message|null} The new Message object or null.
 */
Message.fromObject = function(object) {
  return (object && object.uri) ?
    new Message(
        object.uri,
        object.headers,
        object.body
    ) : null;
};

/**
 * Encodes a message body to a string.
 *
 * @param {*} body The value for the body.
 * @return {string} The body encoded as a string.
 */
Message.prototype._encodeBody = function(body) {
  if (typeof body != 'string') {
    body = JSON.stringify(body);
  }
  return body;
};

/**
 * Returns the URI of the message.
 *
 * @return {Spotify.Cosmos.URI} The URI of the message.
 */
Message.prototype.getURI = function() {
  return this._uri;
};

/**
 * Returns the mimetype of the message.
 *
 * @return {Spotify.Cosmos.MimeType} The mimetype of the message.
 */
Message.prototype.getMimeType = function() {
  return this._headers['accept'];
};

/**
 * Returns the value of a message's headers.
 *
 * @param {string} name The name of the header.
 * @return {string|null} The header value or null if the header wasn't set.
 */
Message.prototype.getHeader = function(name) {
  return this._headers[name.toLowerCase()] || null;
};

/**
 * Returns the headers of the message.
 *
 * @return {Spotify.Cosmos.Headers} The headers of the message.
 */
Message.prototype.getHeaders = function() {
  var _headers = this._headers;
  var headers = {};
  for (var name in _headers) {
    if (!_headers.hasOwnProperty(name)) continue;
    headers[name] = _headers[name];
  }
  return headers;
};

/**
 * Sets a bunch of headers to the message's headers.
 *
 * @param {Spotify.Cosmos.Headers} headers The headers to set to the message.
 * @protected
 */
Message.prototype._setHeaders = function(headers) {
  var _headers = this._headers;
  for (var name in headers) {
    if (!headers.hasOwnProperty(name)) continue;
    _headers[name.toLowerCase()] = headers[name];
  }
  return this;
};

/**
 * Returns the body of the message.
 *
 * @return {Spotify.Cosmos.Body} The body of the message.
 */
Message.prototype.getBody = function() {
  return this._body;
};

/**
 * Returns the body as a JSON object.
 *
 * @return {Object|null} The body of the message parsed as a JSON value. Can
 *     be null if the body is not a proper JSON string.
 */
Message.prototype.getJSONBody = function() {
  try {
    return JSON.parse(this._body);
  } catch(e) {
    return null;
  }
};

/**
 * Creates a new Message instance with data copied from the current instance.
 *
 * @param {Spotify.Cosmos.Headers=} opt_headers The optional headers of the
 *     message.
 * @param {Spotify.Cosmos.Body=} opt_body The optional body of the message.
 */
Message.prototype.copy = function(opt_headers, opt_body) {
  return new Message(
      this._uri,
      this._copyHeaders(opt_headers),
      typeof opt_body != 'undefined' ? opt_body : this._body
  );
};

/**
 * Copies the headers of the message.
 *
 * @param {Spotify.Cosmos.Headers=} opt_headers The optional headers of the
 *     message.
 * @return {Spotify.Cosmos.Headers} The headers of the message.
 */
Message.prototype._copyHeaders = function(opt_headers) {
  var headers;
  if (opt_headers) {
    var _headers = this._headers;
    var name;
    headers = {};
    for (name in _headers) {
      if (!_headers.hasOwnProperty(name)) continue;
      headers[name] = _headers[name];
    }
    for (name in opt_headers) {
      if (!opt_headers.hasOwnProperty(name)) continue;
      headers[name.toLowerCase()] = opt_headers[name];
    }
  } else {
    headers = this._headers;
  }
  return headers;
};

/**
 * Serializes the message into a plain object.
 *
 * @return {Spotify.Cosmos.SerializedMessage} The serialized object.
 */
Message.prototype.serialize = function() {
  return this.toJSON();
};

/**
 * Returns a JSON-object representation of the message.
 *
 * @return {Object} The JSON representation of the message.
 */
Message.prototype.toJSON = function() {
  return {
    uri: this._uri,
    headers: this._headers,
    body: this._body
  };
};

},{}],156:[function(require,module,exports){
var inherit = require('spotify-inheritance').inherit;

/**
 * PlayerState is used for two distinct purposes: Pushing new state to the
 * player (this is done when you request to play a completely new context with
 * 'play' method) and retrieving player state updates.
 *
 * Changing properties on PlayerState objects will not change the state of
 * the player unless you pass it to the 'play' method.
 *
 * @param {Object} stateData the data for the playerState.
 */
function PlayerState(stateData) {
  Serializable.call(this, [
    'action',
    'context',
    'tracks',
    'index',
    'playing',
    'loading',
    'track',
    'position',
    'duration',
    'volume',
    'options',
    'play_origin',
    'next_page_url',
    'prev_page_url'
  ]);

  stateData = stateData || {};
  /**
   * What kind of the action player should perform.
   * It's set directly before sending the request.
   * @type {String}
   */
  this.action = stateData.action;

  /**
   * Spotify uri describing the context that
   * will be played e.g playlist, album or artist.
   * Example: spotify:artist:4XaUmUGjidSklcDHxv3XWf,
   * spotify:user:daftpunkofficial:playlist:5nrg0D90OlFyveVfrQD0zE,
   * spotify:album:2nXJkqkS1tIKIyhBcFMmwz
   *
   * @type {String}
   */
  this.context = stateData.context;

  /**
   * The list of tracks uris to play in the given context.
   * Example: [
   *    spotify:track:0bXpmJyHHYPk6QBFj25bYF,
   *    spotify:track:6DXFVsLcEvOTSrkG9G1Cb1,
   *    spotify:track:6rxEjkoar48SssZePbtb2x
   * ]
   *
   * @type {Array.<String>}
   */
  this.tracks = stateData.tracks;

  /**
   * Which element on the this.tracks list should
   * be played.
   *
   * @type {Number}
   */
  this.index = stateData.index;

  /**
   * Is the player currently playing
   */
  this.playing = stateData.playing;
  this.loading = stateData.loading;

  /**
   * Current track URI
   * @type {String}
   */
  this.track = stateData.track;


  this.position = stateData.position;

  this.volume = stateData.volume;

  /**
   * Current track duration in miliseconds?
   * @type {Number}
   */
  this.duration = stateData.duration;

  /**
   * See PlayOptions description
   * @type {cosmos-bindings-js/scripts/player_state~PlayOptions}
   */
  this.options = new PlayOptions(stateData.options);

  /**
   * See PlayOrigin description
   * @type {cosmos-bindings-js/scripts/player_state~PlayOrigin}
   */
  this.play_origin = new PlayOrigin(stateData.play_origin);

  /**
   * Before the list of tracks that are to be played ends, a request will be sent
   * to this URL, which is supposed to return a list of tracks. That list of
   * tracks will then be appended to the list of tracks in the context.
   *
   * The response payload of the next_page_url should look like this:
   *
   * {
   *   "tracks": [
   *     { "track": "spotify:track:$TRACK-ID1", "context": "spotify:album:$ALBUM-ID1" },
   *     { "track": "spotify:track:$TRACK-ID2", "context": "spotify:album:$ALBUM-ID1" },
   *     { "track": "spotify:track:$TRACK-ID3", "context": "spotify:album:$ALBUM-ID1" },
   *   ],
   *   "next_page_url": "...", // Optional
   *   "prev_page_url": "..." // Optional
   * }
   *
   * May be null, which is the same as a URL that would return an empty list
   * of tracks (but with null, no network request is made).
   */
  this.next_page_url = stateData.next_page_url;

  /**
   * Like `next_page_url`, but for going backwards in the context.
   */
  this.prev_page_url = stateData.prev_page_url;
}
inherit(PlayerState, Serializable);

/**
 * Ovverides prototype method.
 * Converts play options and origin to
 * serializable to make sure only correct data
 * is returned.
 * @return {Object} Data associated with player state.
 */
PlayerState.prototype.serialize = function() {
  if (this.options && !(this.options instanceof PlayOptions)) {
    this.options = new PlayOptions(this.options);
  }

  if (this.play_origin && !(this.play_origin instanceof PlayOrigin)) {
    this.play_origin = new PlayOrigin(this.play_origin);
  }

  return this.constructor.prototype.serialize.call(this);
};

/**
 * Possible player actions.
 */
PlayerState.ACTIONS = {
  UNKNOWN: 'unknown',
  PLAY: 'play',
  UPDATE: 'update',
  STOP: 'stop',
  RESUME: 'resume',
  PAUSE: 'pause',
  SKIP_PREV: 'skip_prev',
  SKIP_NEXT: 'skip_next'
};

function PlayOrigin(data) {
  Serializable.call(this, [
    'source',
    'source_context',
    'reason',
    'referrer',
    'referrer_version',
    'referrer_vendor'
  ]);

  data = data || {};

  /**
   * What kind of playlist did we play from?
   *
   * The default value of this property is "unknown". Must have a value.
   *
   * Valid values include 'album', 'artist', 'extlink', 'playlist', 'playqueue',
   * 'radio', 'search', 'unknown'.
   *
   * For an up to date list of valid values, see `PLAY_SOURCES` in
   * https://git.spotify.net/cgit.cgi/log-parser.git/tree/spotify/log_parser/messages_specs.py
   */
  this.source = data.source || 'unknown';

  /**
   * The uri of the view that initiated the playback.
   */
  this.source_context = data.source_context || 'unknown';

  /**
   * Why was the song started?
   *
   * The default value of this property is "unknown". Must have a value.
   *
   * A list of valid values that might be used by features:
   *
   * unknown    = Client doesn't know
   * clickrow   = A row in the song list was clicked/opened
   * playbtn    = The play button was pressed
   * urlopen    = A Url was opened
   *
   * For a complete and up to date list of valid values, see `PLAY_REASONS` in
   * https://git.spotify.net/cgit.cgi/log-parser.git/tree/spotify/log_parser/messages_specs.py
   */
  this.reason = data.reason || 'unknown';

  /**
   * Either a remote site or a spotify app which initiated the request.
   *
   * NOTE: This normally should be a readonly property and not be set
   * explicitly in the PlayerState as the Player will overwrite it when sending the request.
   */
  this.referrer = data.referrer || 'unknown';

  /**
   * The version of the referrer, where applicable. It usually makes sense to
   * set this value to the version of the JS app version, for instance "0.7.5".
   *
   * NOTE: This normally should be a readonly property and not be set
   * explicitly in the PlayerState as the Player will overwrite it when sending the request.
   */
  this.referrer_version = data.referrer_version || 'unknown';

  /**
   * The vendor of the referrer, where applicable.
   * For example com.soundrop, com.spotify.
   *
   * NOTE: This normally should be a readonly property and not be set
   * explicitly in the PlayerState as the Player will overwrite it when sending the request.
   */
  this.referrer_vendor = data.referrer_vendor || 'unknown';
}
inherit(PlayOrigin, Serializable);

/**
 * What kind of options user has
 * with the player. By default
 * all 'can_*' properties are set to true.
 * You might want to restrict some of them
 * in the special cases like ads (no skipping)
 * or radio no skipping prev.
 * @constructor
 * @param {Object} options The options data.
 */
function PlayOptions(options) {
  Serializable.call(this, [
    'repeat',
    'shuffle',
    'can_repeat',
    'can_shuffle',
    'can_skip_prev',
    'can_skip_next',
    'can_seek',
    'use_dmca_rules'
  ]);
  options = options || {};

  /**
   * True if repeat (repeat all, not single track repeat) is (or is to be) enabled.
   *
   * Default value is false
   */
  this.repeat = options.repeat !== undefined ? options.repeat : false;

  /**
   * True if shuffle is (or is to be) enabled.
   *
   * Default value is false
   */
  this.shuffle = options.shuffle !== undefined ? options.shuffle : false;

  /**
   * True if this context can be repeated. This would be false for instance in the
   * case of radio.
   *
   * Default value is true.
   */
  this.can_repeat = options.can_repeat !== undefined ? options.can_repeat : true;

  /**
   * True if this context can be shuffled. This would be false for instance in the
   * case of radio.
   *
   * Default value is true.
   */
  this.can_shuffle = options.can_shuffle !== undefined ? options.can_shuffle : true;

  /**
   * True if the user is (or should be) allowed to skip to the previous track.
   *
   * Default value is true.
   */
  this.can_skip_prev = options.can_skip_prev !== undefined ? options.can_skip_prev : true;

  /**
   * True if the user is (or should be) allowed to skip to the next track.
   *
   * Default value is true.
   */
  this.can_skip_next = options.can_skip_next !== undefined ? options.can_skip_next : true;

  /**
   * True if the user is (or should be) allowed to seek to a certain time in the
   * currently playing track.
   *
   * Default value is true.
   */
  this.can_seek = options.can_seek !== undefined ? options.can_seek : true;

  /**
   * True if the track player should automatically apply DMCA rules when playing.
   * DMCA rules should be enabled for users that have free radio in the US, and
   * controls how many tracks the user are allowed to skip etc.
   *
   * Default value is false.
   */
  this.use_dmca_rules = options.use_dmca_rules !== undefined ? options.use_dmca_rules : false;
}
inherit(PlayOptions, Serializable);

/**
 * The object accepting only defined properties.
 * To make sure only valid properties are passed
 * always use 'serialize()' when object value needed.
 * @constructor
 * @param {Array.<string>} allowedProps The list of the properties
 * that are supported for the object.
 */
function Serializable(allowedProps) {
  this._props = allowedProps || [];
}

/**
 * The JSON representation of the object.
 * @return {Object} Data associated with current player state.
 */
Serializable.prototype.serialize = function() {
  var data = {};
  var prop;

  for (var i = 0, l = this._props.length; i < l; i++) {
    prop = this._props[i];
    if (this[prop] !== undefined) {
      if (this[prop] instanceof Serializable) {
        data[prop] = this[prop].serialize();
      } else {
        data[prop] = this[prop];
      }
    }
  }

  return data;
};

exports.PlayerState = PlayerState;

},{"spotify-inheritance":254}],157:[function(require,module,exports){
var inherit = require('spotify-inheritance').inherit;

var Message = require('./message').Message;

/**
 * Request actions.
 *
 * @name exports.Action
 * @enum {string}
 */
exports.Action = {
  DELETE: 'DELETE',
  GET: 'GET',
  HEAD: 'HEAD',
  POST: 'POST',
  PUT: 'PUT',
  SUB: 'SUB',
  PATCH: 'PATCH'
};

/**
 * A serialized Request object.
 *
 * @name Spotify.Cosmos.SerializedRequest
 * @typedef {{
 *   uri: Spotify.Cosmos.URI,
 *   headers: Spotify.Cosmos.Headers,
 *   body: Spotify.Cosmos.Body
 * }}
 */
exports.SerializedRequest;

/**
 * Encapsulates a request to the handlers.
 *
 * Instances of this class are "immutable" and should not be changed.
 *
 * @constructs Spotify.Cosmos.Request
 * @extends Spotify.Cosmos.Message
 * @param {Spotify.Cosmos.Action} action The action of the request.
 * @param {Spotify.Cosmos.URI} uri The URI of the request
 * @param {Spotify.Cosmos.Headers=} opt_headers The optional headers of the
 *     request.
 * @param {Spotify.Cosmos.Body=} opt_body The optional body of the request.
 */
function Request(action, uri, opt_headers, opt_body) {
  if (!(this instanceof Request))
    return new Request(action, uri, opt_headers, opt_body);
  if (!action)
    throw new TypeError('Invalid `action` argument for Request.');
  Message.call(this, uri, opt_headers, opt_body);

  /**
   * The action of the request.
   *
   * @type {Spotify.Cosmos.Action}
   * @protected
   */
  this._action = action;
}
inherit(Request, Message);
exports.Request = Request;

/**
 * Creates a new Request from a SerializedRequest object.
 *
 * @param {Spotify.Cosmos.SerializedRequest} object The serialized request.
 * @return {Spotify.Cosmos.Request|null} The new Request object or null.
 */
Request.fromObject = function(object) {
  return (object && object.action && object.uri) ?
    new Request(
        object.action,
        object.uri,
        object.headers,
        object.body
    ) : null;
};

/**
 * Returns the action of the request.
 *
 * @return {Spotify.Cosmos.Action} The action of the request.
 */
Request.prototype.getAction = function() {
  return this._action;
};

/**
 * @inheritDoc
 */
Request.prototype.copy = function(opt_headers, opt_body) {
  return new Request(
      this._action,
      this._uri,
      this._copyHeaders(opt_headers),
      typeof opt_body != 'undefined' ? opt_body : this._body
  );
};

/**
 * @inheritDoc
 */
Request.prototype.toJSON = function() {
  return {
    action: this._action,
    uri: this._uri,
    headers: this._headers,
    body: this._body
  };
};



},{"./message":155,"spotify-inheritance":254}],158:[function(require,module,exports){
var inherit = require('spotify-inheritance').inherit;

var Message = require('./message').Message;

/**
 * Statuscode.
 * The statuses with negative numbers are reserved for
 * errors that originate within the cosmos library.
 *
 * @name exports.StatusCode
 * @enum {number}
 */
exports.StatusCode = {
  OK: 200,
  CREATED: 201,
  ACCEPTED: 202,
  BAD_REQUEST: 400,
  UNAUTHORIZED: 401,
  FORBIDDEN: 403,
  NOT_FOUND: 404,
  METHOD_NOT_ALLOWED: 405,
  TIMED_OUT: 408,
  CONFLICT: 409,
  GONE: 410,
  INTERNAL_SERVER_ERROR: 500,
  NOT_IMPLEMENTED: 501,
  BAD_GATEWAY: 502,
  SERVICE_UNAVAILABLE: 503,

  /** Something went wrong, but the exact reason is not known. */
  ERROR_UNKNOWN: -100,

  /** A resource allocation required to complete the request failed. */
  ERROR_ALLOCATION_FAILED: -101,

  /** The body could not be decoded because it does
   not conform to the encoding header field. */
  ERROR_INVALID_ENCODING: -102,

  /** The router detected an infinite loop while processing the request. */
  ERROR_INFINITE_LOOP: -103,

  /** No endpoint resolver that could handle the request was found. */
  ERROR_RESOLVER_NOT_FOUND: -104
};

/**
 * A serialized Response object.
 *
 * @name Spotify.Cosmos.SerializedResponse
 * @typedef {{
 *   uri: Spotify.Cosmos.URI,
 *   status: Spotify.Cosmos.StatusCode,
 *   headers: Spotify.Cosmos.Headers,
 *   body: Spotify.Cosmos.Body
 * }}
 */
exports.SerializedResponse;

/**
 * Encapsulates a response from the handlers.
 *
 * @constructs Spotify.Cosmos.Response
 * @extends Spotify.Cosmos.Message
 * @param {Spotify.Cosmos.URI} uri The URI of the response
 * @param {Spotify.Cosmos.StatusCode} status The status of the response.
 * @param {Spotify.Cosmos.Headers=} opt_headers The optional headers of the
 *     response.
 * @param {Spotify.Cosmos.Body=} opt_body The optional body of the response.
 */
function Response(uri, status, opt_headers, opt_body) {
  if (!(this instanceof Response))
    return new Response(uri, status, opt_headers, opt_body, opt_requestURI);
  if (typeof status == 'undefined' || status == null)
    throw new TypeError('Invalid `status` argument for Response.');

  Message.call(this, uri, opt_headers, opt_body);

  /**
   * The Status of the Response.
   *
   * @type {Spotify.Cosmos.StatusCode}
   * @protected
   */
  this._status = status;
}
inherit(Response, Message);
exports.Response = Response;

/**
 * Creates a new Response from a SerializedResponse object.
 *
 * @param {Spotify.Cosmos.SerializedResponse} object The serialized response.
 * @return {Spotify.Cosmos.Response|null} The new Response object or null.
 */
Response.fromObject = function(object) {
  return (object && object.uri && object.status) ?
    new Response(
        object.uri,
        object.status,
        object.headers,
        object.body
    ) : null;
};

/**
 * @inheritDoc
 */
Response.prototype.getMimeType = function() {
  return this._headers['content-type'];
};

/**
 * Returns the status code of the Response.
 *
 * @return {Spotify.Cosmos.StatusCode} The status code of the response.
 */
Response.prototype.getStatusCode = function() {
  return this._status;
};

/**
 * @inheritDoc
 */
Response.prototype.copy = function(opt_headers, opt_body) {
  return new Response(
      this._uri,
      this._status,
      this._copyHeaders(opt_headers),
      typeof opt_body != 'undefined' ? opt_body : this._body
  );
};

/**
 * @inheritDoc
 */
Response.prototype.toJSON = function() {
  return {
    uri: this._uri,
    status: this._status,
    headers: this._headers,
    body: this._body
  };
};


},{"./message":155,"spotify-inheritance":254}],159:[function(require,module,exports){

/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = require('./debug');
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // is webkit? http://stackoverflow.com/a/16459606/376773
  return ('WebkitAppearance' in document.documentElement.style) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (window.console && (console.firebug || (console.exception && console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  return JSON.stringify(v);
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs() {
  var args = arguments;
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return args;

  var c = 'color: ' + this.color;
  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
  return args;
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}
  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage(){
  try {
    return window.localStorage;
  } catch (e) {}
}

},{"./debug":160}],160:[function(require,module,exports){

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = debug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = require('ms');

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lowercased letter, i.e. "n".
 */

exports.formatters = {};

/**
 * Previously assigned color.
 */

var prevColor = 0;

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 *
 * @return {Number}
 * @api private
 */

function selectColor() {
  return exports.colors[prevColor++ % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function debug(namespace) {

  // define the `disabled` version
  function disabled() {
  }
  disabled.enabled = false;

  // define the `enabled` version
  function enabled() {

    var self = enabled;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // add the `color` if not set
    if (null == self.useColors) self.useColors = exports.useColors();
    if (null == self.color && self.useColors) self.color = selectColor();

    var args = Array.prototype.slice.call(arguments);

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %o
      args = ['%o'].concat(args);
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    if ('function' === typeof exports.formatArgs) {
      args = exports.formatArgs.apply(self, args);
    }
    var logFn = enabled.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }
  enabled.enabled = true;

  var fn = exports.enabled(namespace) ? enabled : disabled;

  fn.namespace = namespace;

  return fn;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  var split = (namespaces || '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

},{"ms":232}],161:[function(require,module,exports){
/*
Finally
*/'use strict';

var prime = require('prime');

var kindOf = require('mout/lang/kindOf');
var map = require('mout/array/map');
var slice = require('mout/array/slice');
var forEach = require('mout/array/forEach');
var reduce = require('mout/array/reduce');

var each = require('mout/collection/forEach');
var cmap = require('mout/collection/map');

var push_ = Array.prototype.push;

/* create the flow */
var Flow = prime({

  /* options */
  constructor: function Flow() {
    this._seq = [];
  },

  /* add steps to the flow */
  then: function() {
    this._push(this._callbacks(arguments));
    return this;
  },

  _parallel: function(parallel, args) {
    var self = this;
    return function() {
      var control = new Controller(self, self._index++);
      self._controls.push(control);
      parallel.apply(control, args ? args.concat(slice(arguments)) : arguments);
    };
  },

  _push: function(parallels, args) {
    if (!parallels.length) return;
    this._seq.push(map(parallels, function(parallel) {
      return this._parallel(parallel, args);
    }, this));
  },

  _callbacks: function(callbacks) {
    return reduce(callbacks, function(a, b) {
      if (kindOf(b) === 'Array') push_.apply(a, b);
      else a.push(b);
      return a;
    }, []);
  },

  /* will make a sequential entry for each entry in the object */
  sequential: function(object) {
    var callbacks = this._callbacks(slice(arguments, 1));
    each(object, function(value, key) {
      this._push(callbacks, [value, key]);
    }, this);
    return this;
  },

  /* will make a single sequential entry with one parallel for each entry in the object */
  parallel: function(object, parallel) {
    var parallels = cmap(object, function(value, key) {
      return this._parallel(parallel, [value, key]);
    }, this);
    if (parallels.length) this._seq.push(parallels);
    return this;
  },

  /* assign last step and execute the flow */
  finally: function() {
    this.then.apply(this, arguments);
    this._continue.call(this);
    return this;
  },

  /* execute the flow with arguments to the first step */
  run: function() {
    this._continue.apply(this, arguments);
    return this;
  },

  // private

  _break: function() {
    this._seq.splice(0, this._seq.length - 1);
    this._continue.apply(this, arguments);
  },

  _spread: function(error, args) {
    var seq = this._next();
    if (!seq || !(seq = seq[0])) return;
    if (!args || !args.length) args = [undefined];
    this._length = args.length;
    forEach(args, function(arg) {
      seq(error, arg);
    });
  },

  _continue: function() {
    var seq = this._next();
    if (!seq) return;
    this._length = seq.length;
    var args = arguments;
    forEach(seq, function(parallel) {
      parallel.apply(null, args);
    });
  },

  _next: function() {
    var seq = this._seq.shift();
    if (!seq) return;

    if (this._controls) forEach(this._controls, function(control) { // kill old controls
      control._kill();
    });

    // reset variables

    this._arguments = [];
    this._errors = [];
    this._controls = [];
    this._index = 0;

    return seq;
  },

  _done: function(index, error, data) {
    this._arguments[index] = data;
    if (error) this._errors.push(error);
    if (!--this._length) {
      var errors = null;
      if (this._errors.length === 1) errors = this._errors[0];
      else if (this._errors.length) errors = new Error(map(this._errors, function(e) {
        return e.message;
      }).join('\n'));
      this._continue.apply(this, [errors].concat(this._arguments));
    }
    else this._controls[index]._kill();
  }

});

/* control the flow */
var Controller = function Controller(flow, index) {

  var dead;

  this._kill = function() {
    dead = true;
  };

  /* break the flow */
  this.break = function() {
    if (!dead) flow._break.apply(flow, arguments);
  };

  /* step in the next sequential */
  this.continue = function() {
    if (!dead) flow._continue.apply(flow, arguments);
  };

  /* spread results to the next sequential */
  this.spread = function(error, args) {
    if (!dead) flow._spread(error, args);
  };

  /* set the the current parallel in the sequential as complete */
  var done = this.done = function(error, data) {
    if (!dead) flow._done.call(flow, index, error, data);
  };

};

/* public interface */
module.exports = function() {
  var flow = new Flow();
  flow.then.apply(flow, arguments);
  return flow;
};

},{"mout/array/forEach":162,"mout/array/map":163,"mout/array/reduce":164,"mout/array/slice":165,"mout/collection/forEach":166,"mout/collection/map":168,"mout/lang/kindOf":176,"prime":183}],162:[function(require,module,exports){


    /**
     * Array forEach
     */
    function forEach(arr, callback, thisObj) {
        if (arr == null) {
            return;
        }
        var i = -1,
            len = arr.length;
        while (++i < len) {
            // we iterate over sparse items since there is no way to make it
            // work properly on IE 7-8. see #64
            if ( callback.call(thisObj, arr[i], i, arr) === false ) {
                break;
            }
        }
    }

    module.exports = forEach;



},{}],163:[function(require,module,exports){
var makeIterator = require('../function/makeIterator_');

    /**
     * Array map
     */
    function map(arr, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        var results = [];
        if (arr == null){
            return results;
        }

        var i = -1, len = arr.length;
        while (++i < len) {
            results[i] = callback(arr[i], i, arr);
        }

        return results;
    }

     module.exports = map;


},{"../function/makeIterator_":170}],164:[function(require,module,exports){


    /**
     * Array reduce
     */
    function reduce(arr, fn, initVal) {
        // check for args.length since initVal might be "undefined" see #gh-57
        var hasInit = arguments.length > 2,
            result = initVal;

        if (arr == null || !arr.length) {
            if (!hasInit) {
                throw new Error('reduce of empty array with no initial value');
            } else {
                return initVal;
            }
        }

        var i = -1, len = arr.length;
        while (++i < len) {
            if (!hasInit) {
                result = arr[i];
                hasInit = true;
            } else {
                result = fn(result, arr[i], i, arr);
            }
        }

        return result;
    }

    module.exports = reduce;


},{}],165:[function(require,module,exports){


    /**
     * Create slice of source array or array-like object
     */
    function slice(arr, start, end){
        var len = arr.length;

        if (start == null) {
            start = 0;
        } else if (start < 0) {
            start = Math.max(len + start, 0);
        } else {
            start = Math.min(start, len);
        }

        if (end == null) {
            end = len;
        } else if (end < 0) {
            end = Math.max(len + end, 0);
        } else {
            end = Math.min(end, len);
        }

        var result = [];
        while (start < end) {
            result.push(arr[start++]);
        }

        return result;
    }

    module.exports = slice;



},{}],166:[function(require,module,exports){
var make = require('./make_');
var arrForEach = require('../array/forEach');
var objForEach = require('../object/forOwn');

    /**
     */
    module.exports = make(arrForEach, objForEach);



},{"../array/forEach":162,"../object/forOwn":179,"./make_":167}],167:[function(require,module,exports){
var slice = require('../array/slice');

    /**
     * internal method used to create other collection modules.
     */
    function makeCollectionMethod(arrMethod, objMethod, defaultReturn) {
        return function(){
            var args = slice(arguments);
            if (args[0] == null) {
                return defaultReturn;
            }
            // array-like is treated as array
            return (typeof args[0].length === 'number')? arrMethod.apply(null, args) : objMethod.apply(null, args);
        };
    }

    module.exports = makeCollectionMethod;



},{"../array/slice":165}],168:[function(require,module,exports){
var isObject = require('../lang/isObject');
var values = require('../object/values');
var arrMap = require('../array/map');
var makeIterator = require('../function/makeIterator_');

    /**
     * Map collection values, returns Array.
     */
    function map(list, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        // list.length to check array-like object, if not array-like
        // we simply map all the object values
        if( isObject(list) && list.length == null ){
            list = values(list);
        }
        return arrMap(list, function (val, key, list) {
            return callback(val, key, list);
        });
    }

    module.exports = map;



},{"../array/map":163,"../function/makeIterator_":170,"../lang/isObject":175,"../object/values":182}],169:[function(require,module,exports){


    /**
     * Returns the first argument provided to it.
     */
    function identity(val){
        return val;
    }

    module.exports = identity;



},{}],170:[function(require,module,exports){
var identity = require('./identity');
var prop = require('./prop');
var deepMatches = require('../object/deepMatches');

    /**
     * Converts argument into a valid iterator.
     * Used internally on most array/object/collection methods that receives a
     * callback/iterator providing a shortcut syntax.
     */
    function makeIterator(src, thisObj){
        if (src == null) {
            return identity;
        }
        switch(typeof src) {
            case 'function':
                // function is the first to improve perf (most common case)
                // also avoid using `Function#call` if not needed, which boosts
                // perf a lot in some cases
                return (typeof thisObj !== 'undefined')? function(val, i, arr){
                    return src.call(thisObj, val, i, arr);
                } : src;
            case 'object':
                return function(val){
                    return deepMatches(val, src);
                };
            case 'string':
            case 'number':
                return prop(src);
        }
    }

    module.exports = makeIterator;



},{"../object/deepMatches":177,"./identity":169,"./prop":171}],171:[function(require,module,exports){


    /**
     * Returns a function that gets a property of the passed object
     */
    function prop(name){
        return function(obj){
            return obj[name];
        };
    }

    module.exports = prop;



},{}],172:[function(require,module,exports){
var mixIn = require('../object/mixIn');

    /**
     * Create Object using prototypal inheritance and setting custom properties.
     * - Mix between Douglas Crockford Prototypal Inheritance <http://javascript.crockford.com/prototypal.html> and the EcmaScript 5 `Object.create()` method.
     * @param {object} parent    Parent Object.
     * @param {object} [props] Object properties.
     * @return {object} Created object.
     */
    function createObject(parent, props){
        function F(){}
        F.prototype = parent;
        return mixIn(new F(), props);

    }
    module.exports = createObject;



},{"../object/mixIn":181}],173:[function(require,module,exports){
var isKind = require('./isKind');
    /**
     */
    var isArray = Array.isArray || function (val) {
        return isKind(val, 'Array');
    };
    module.exports = isArray;


},{"./isKind":174}],174:[function(require,module,exports){
var kindOf = require('./kindOf');
    /**
     * Check if value is from a specific "kind".
     */
    function isKind(val, kind){
        return kindOf(val) === kind;
    }
    module.exports = isKind;


},{"./kindOf":176}],175:[function(require,module,exports){
var isKind = require('./isKind');
    /**
     */
    function isObject(val) {
        return isKind(val, 'Object');
    }
    module.exports = isObject;


},{"./isKind":174}],176:[function(require,module,exports){


    var _rKind = /^\[object (.*)\]$/,
        _toString = Object.prototype.toString,
        UNDEF;

    /**
     * Gets the "kind" of value. (e.g. "String", "Number", etc)
     */
    function kindOf(val) {
        if (val === null) {
            return 'Null';
        } else if (val === UNDEF) {
            return 'Undefined';
        } else {
            return _rKind.exec( _toString.call(val) )[1];
        }
    }
    module.exports = kindOf;


},{}],177:[function(require,module,exports){
var forOwn = require('./forOwn');
var isArray = require('../lang/isArray');

    function containsMatch(array, pattern) {
        var i = -1, length = array.length;
        while (++i < length) {
            if (deepMatches(array[i], pattern)) {
                return true;
            }
        }

        return false;
    }

    function matchArray(target, pattern) {
        var i = -1, patternLength = pattern.length;
        while (++i < patternLength) {
            if (!containsMatch(target, pattern[i])) {
                return false;
            }
        }

        return true;
    }

    function matchObject(target, pattern) {
        var result = true;
        forOwn(pattern, function(val, key) {
            if (!deepMatches(target[key], val)) {
                // Return false to break out of forOwn early
                return (result = false);
            }
        });

        return result;
    }

    /**
     * Recursively check if the objects match.
     */
    function deepMatches(target, pattern){
        if (target && typeof target === 'object') {
            if (isArray(target) && isArray(pattern)) {
                return matchArray(target, pattern);
            } else {
                return matchObject(target, pattern);
            }
        } else {
            return target === pattern;
        }
    }

    module.exports = deepMatches;



},{"../lang/isArray":173,"./forOwn":179}],178:[function(require,module,exports){
var hasOwn = require('./hasOwn');

    var _hasDontEnumBug,
        _dontEnums;

    function checkDontEnum(){
        _dontEnums = [
                'toString',
                'toLocaleString',
                'valueOf',
                'hasOwnProperty',
                'isPrototypeOf',
                'propertyIsEnumerable',
                'constructor'
            ];

        _hasDontEnumBug = true;

        for (var key in {'toString': null}) {
            _hasDontEnumBug = false;
        }
    }

    /**
     * Similar to Array/forEach but works over object properties and fixes Don't
     * Enum bug on IE.
     * based on: http://whattheheadsaid.com/2010/10/a-safer-object-keys-compatibility-implementation
     */
    function forIn(obj, fn, thisObj){
        var key, i = 0;
        // no need to check if argument is a real object that way we can use
        // it for arrays, functions, date, etc.

        //post-pone check till needed
        if (_hasDontEnumBug == null) checkDontEnum();

        for (key in obj) {
            if (exec(fn, obj, key, thisObj) === false) {
                break;
            }
        }


        if (_hasDontEnumBug) {
            var ctor = obj.constructor,
                isProto = !!ctor && obj === ctor.prototype;

            while (key = _dontEnums[i++]) {
                // For constructor, if it is a prototype object the constructor
                // is always non-enumerable unless defined otherwise (and
                // enumerated above).  For non-prototype objects, it will have
                // to be defined on this object, since it cannot be defined on
                // any prototype objects.
                //
                // For other [[DontEnum]] properties, check if the value is
                // different than Object prototype value.
                if (
                    (key !== 'constructor' ||
                        (!isProto && hasOwn(obj, key))) &&
                    obj[key] !== Object.prototype[key]
                ) {
                    if (exec(fn, obj, key, thisObj) === false) {
                        break;
                    }
                }
            }
        }
    }

    function exec(fn, obj, key, thisObj){
        return fn.call(thisObj, obj[key], key, obj);
    }

    module.exports = forIn;



},{"./hasOwn":180}],179:[function(require,module,exports){
var hasOwn = require('./hasOwn');
var forIn = require('./forIn');

    /**
     * Similar to Array/forEach but works over object properties and fixes Don't
     * Enum bug on IE.
     * based on: http://whattheheadsaid.com/2010/10/a-safer-object-keys-compatibility-implementation
     */
    function forOwn(obj, fn, thisObj){
        forIn(obj, function(val, key){
            if (hasOwn(obj, key)) {
                return fn.call(thisObj, obj[key], key, obj);
            }
        });
    }

    module.exports = forOwn;



},{"./forIn":178,"./hasOwn":180}],180:[function(require,module,exports){


    /**
     * Safer Object.hasOwnProperty
     */
     function hasOwn(obj, prop){
         return Object.prototype.hasOwnProperty.call(obj, prop);
     }

     module.exports = hasOwn;



},{}],181:[function(require,module,exports){
var forOwn = require('./forOwn');

    /**
    * Combine properties from all the objects into first one.
    * - This method affects target object in place, if you want to create a new Object pass an empty object as first param.
    * @param {object} target    Target Object
    * @param {...object} objects    Objects to be combined (0...n objects).
    * @return {object} Target Object.
    */
    function mixIn(target, objects){
        var i = 0,
            n = arguments.length,
            obj;
        while(++i < n){
            obj = arguments[i];
            if (obj != null) {
                forOwn(obj, copyProp, target);
            }
        }
        return target;
    }

    function copyProp(val, key){
        this[key] = val;
    }

    module.exports = mixIn;


},{"./forOwn":179}],182:[function(require,module,exports){
var forOwn = require('./forOwn');

    /**
     * Get object values
     */
    function values(obj) {
        var vals = [];
        forOwn(obj, function(val, key){
            vals.push(val);
        });
        return vals;
    }

    module.exports = values;



},{"./forOwn":179}],183:[function(require,module,exports){
/*
prime
 - prototypal inheritance
*/"use strict"

var hasOwn = require("mout/object/hasOwn"),
    mixIn  = require("mout/object/mixIn"),
    create = require("mout/lang/createObject"),
    kindOf = require("mout/lang/kindOf")

var hasDescriptors = true

try {
    Object.defineProperty({}, "~", {})
    Object.getOwnPropertyDescriptor({}, "~")
} catch (e){
    hasDescriptors = false
}

// we only need to be able to implement "toString" and "valueOf" in IE < 9
var hasEnumBug = !({valueOf: 0}).propertyIsEnumerable("valueOf"),
    buggy      = ["toString", "valueOf"]

var verbs = /^constructor|inherits|mixin$/

var implement = function(proto){
    var prototype = this.prototype

    for (var key in proto){
        if (key.match(verbs)) continue
        if (hasDescriptors){
            var descriptor = Object.getOwnPropertyDescriptor(proto, key)
            if (descriptor){
                Object.defineProperty(prototype, key, descriptor)
                continue
            }
        }
        prototype[key] = proto[key]
    }

    if (hasEnumBug) for (var i = 0; (key = buggy[i]); i++){
        var value = proto[key]
        if (value !== Object.prototype[key]) prototype[key] = value
    }

    return this
}

var prime = function(proto){

    if (kindOf(proto) === "Function") proto = {constructor: proto}

    var superprime = proto.inherits

    // if our nice proto object has no own constructor property
    // then we proceed using a ghosting constructor that all it does is
    // call the parent's constructor if it has a superprime, else an empty constructor
    // proto.constructor becomes the effective constructor
    var constructor = (hasOwn(proto, "constructor")) ? proto.constructor : (superprime) ? function(){
        return superprime.apply(this, arguments)
    } : function(){}

    if (superprime){

        mixIn(constructor, superprime)

        var superproto = superprime.prototype
        // inherit from superprime
        var cproto = constructor.prototype = create(superproto)

        // setting constructor.parent to superprime.prototype
        // because it's the shortest possible absolute reference
        constructor.parent = superproto
        cproto.constructor = constructor
    }

    if (!constructor.implement) constructor.implement = implement

    var mixins = proto.mixin
    if (mixins){
        if (kindOf(mixins) !== "Array") mixins = [mixins]
        for (var i = 0; i < mixins.length; i++) constructor.implement(create(mixins[i].prototype))
    }

    // implement proto and return constructor
    return constructor.implement(proto)

}

module.exports = prime

},{"mout/lang/createObject":172,"mout/lang/kindOf":176,"mout/object/hasOwn":180,"mout/object/mixIn":181}],184:[function(require,module,exports){
"use strict";
/*globals Handlebars: true */
var base = require("./handlebars/base");

// Each of these augment the Handlebars object. No need to setup here.
// (This is done to easily share code between commonjs and browse envs)
var SafeString = require("./handlebars/safe-string")["default"];
var Exception = require("./handlebars/exception")["default"];
var Utils = require("./handlebars/utils");
var runtime = require("./handlebars/runtime");

// For compatibility and usage outside of module systems, make the Handlebars object a namespace
var create = function() {
  var hb = new base.HandlebarsEnvironment();

  Utils.extend(hb, base);
  hb.SafeString = SafeString;
  hb.Exception = Exception;
  hb.Utils = Utils;

  hb.VM = runtime;
  hb.template = function(spec) {
    return runtime.template(spec, hb);
  };

  return hb;
};

var Handlebars = create();
Handlebars.create = create;

exports["default"] = Handlebars;
},{"./handlebars/base":185,"./handlebars/exception":186,"./handlebars/runtime":187,"./handlebars/safe-string":188,"./handlebars/utils":189}],185:[function(require,module,exports){
"use strict";
var Utils = require("./utils");
var Exception = require("./exception")["default"];

var VERSION = "1.3.0";
exports.VERSION = VERSION;var COMPILER_REVISION = 4;
exports.COMPILER_REVISION = COMPILER_REVISION;
var REVISION_CHANGES = {
  1: '<= 1.0.rc.2', // 1.0.rc.2 is actually rev2 but doesn't report it
  2: '== 1.0.0-rc.3',
  3: '== 1.0.0-rc.4',
  4: '>= 1.0.0'
};
exports.REVISION_CHANGES = REVISION_CHANGES;
var isArray = Utils.isArray,
    isFunction = Utils.isFunction,
    toString = Utils.toString,
    objectType = '[object Object]';

function HandlebarsEnvironment(helpers, partials) {
  this.helpers = helpers || {};
  this.partials = partials || {};

  registerDefaultHelpers(this);
}

exports.HandlebarsEnvironment = HandlebarsEnvironment;HandlebarsEnvironment.prototype = {
  constructor: HandlebarsEnvironment,

  logger: logger,
  log: log,

  registerHelper: function(name, fn, inverse) {
    if (toString.call(name) === objectType) {
      if (inverse || fn) { throw new Exception('Arg not supported with multiple helpers'); }
      Utils.extend(this.helpers, name);
    } else {
      if (inverse) { fn.not = inverse; }
      this.helpers[name] = fn;
    }
  },

  registerPartial: function(name, str) {
    if (toString.call(name) === objectType) {
      Utils.extend(this.partials,  name);
    } else {
      this.partials[name] = str;
    }
  }
};

function registerDefaultHelpers(instance) {
  instance.registerHelper('helperMissing', function(arg) {
    if(arguments.length === 2) {
      return undefined;
    } else {
      throw new Exception("Missing helper: '" + arg + "'");
    }
  });

  instance.registerHelper('blockHelperMissing', function(context, options) {
    var inverse = options.inverse || function() {}, fn = options.fn;

    if (isFunction(context)) { context = context.call(this); }

    if(context === true) {
      return fn(this);
    } else if(context === false || context == null) {
      return inverse(this);
    } else if (isArray(context)) {
      if(context.length > 0) {
        return instance.helpers.each(context, options);
      } else {
        return inverse(this);
      }
    } else {
      return fn(context);
    }
  });

  instance.registerHelper('each', function(context, options) {
    var fn = options.fn, inverse = options.inverse;
    var i = 0, ret = "", data;

    if (isFunction(context)) { context = context.call(this); }

    if (options.data) {
      data = createFrame(options.data);
    }

    if(context && typeof context === 'object') {
      if (isArray(context)) {
        for(var j = context.length; i<j; i++) {
          if (data) {
            data.index = i;
            data.first = (i === 0);
            data.last  = (i === (context.length-1));
          }
          ret = ret + fn(context[i], { data: data });
        }
      } else {
        for(var key in context) {
          if(context.hasOwnProperty(key)) {
            if(data) { 
              data.key = key; 
              data.index = i;
              data.first = (i === 0);
            }
            ret = ret + fn(context[key], {data: data});
            i++;
          }
        }
      }
    }

    if(i === 0){
      ret = inverse(this);
    }

    return ret;
  });

  instance.registerHelper('if', function(conditional, options) {
    if (isFunction(conditional)) { conditional = conditional.call(this); }

    // Default behavior is to render the positive path if the value is truthy and not empty.
    // The `includeZero` option may be set to treat the condtional as purely not empty based on the
    // behavior of isEmpty. Effectively this determines if 0 is handled by the positive path or negative.
    if ((!options.hash.includeZero && !conditional) || Utils.isEmpty(conditional)) {
      return options.inverse(this);
    } else {
      return options.fn(this);
    }
  });

  instance.registerHelper('unless', function(conditional, options) {
    return instance.helpers['if'].call(this, conditional, {fn: options.inverse, inverse: options.fn, hash: options.hash});
  });

  instance.registerHelper('with', function(context, options) {
    if (isFunction(context)) { context = context.call(this); }

    if (!Utils.isEmpty(context)) return options.fn(context);
  });

  instance.registerHelper('log', function(context, options) {
    var level = options.data && options.data.level != null ? parseInt(options.data.level, 10) : 1;
    instance.log(level, context);
  });
}

var logger = {
  methodMap: { 0: 'debug', 1: 'info', 2: 'warn', 3: 'error' },

  // State enum
  DEBUG: 0,
  INFO: 1,
  WARN: 2,
  ERROR: 3,
  level: 3,

  // can be overridden in the host environment
  log: function(level, obj) {
    if (logger.level <= level) {
      var method = logger.methodMap[level];
      if (typeof console !== 'undefined' && console[method]) {
        console[method].call(console, obj);
      }
    }
  }
};
exports.logger = logger;
function log(level, obj) { logger.log(level, obj); }

exports.log = log;var createFrame = function(object) {
  var obj = {};
  Utils.extend(obj, object);
  return obj;
};
exports.createFrame = createFrame;
},{"./exception":186,"./utils":189}],186:[function(require,module,exports){
"use strict";

var errorProps = ['description', 'fileName', 'lineNumber', 'message', 'name', 'number', 'stack'];

function Exception(message, node) {
  var line;
  if (node && node.firstLine) {
    line = node.firstLine;

    message += ' - ' + line + ':' + node.firstColumn;
  }

  var tmp = Error.prototype.constructor.call(this, message);

  // Unfortunately errors are not enumerable in Chrome (at least), so `for prop in tmp` doesn't work.
  for (var idx = 0; idx < errorProps.length; idx++) {
    this[errorProps[idx]] = tmp[errorProps[idx]];
  }

  if (line) {
    this.lineNumber = line;
    this.column = node.firstColumn;
  }
}

Exception.prototype = new Error();

exports["default"] = Exception;
},{}],187:[function(require,module,exports){
"use strict";
var Utils = require("./utils");
var Exception = require("./exception")["default"];
var COMPILER_REVISION = require("./base").COMPILER_REVISION;
var REVISION_CHANGES = require("./base").REVISION_CHANGES;

function checkRevision(compilerInfo) {
  var compilerRevision = compilerInfo && compilerInfo[0] || 1,
      currentRevision = COMPILER_REVISION;

  if (compilerRevision !== currentRevision) {
    if (compilerRevision < currentRevision) {
      var runtimeVersions = REVISION_CHANGES[currentRevision],
          compilerVersions = REVISION_CHANGES[compilerRevision];
      throw new Exception("Template was precompiled with an older version of Handlebars than the current runtime. "+
            "Please update your precompiler to a newer version ("+runtimeVersions+") or downgrade your runtime to an older version ("+compilerVersions+").");
    } else {
      // Use the embedded version info since the runtime doesn't know about this revision yet
      throw new Exception("Template was precompiled with a newer version of Handlebars than the current runtime. "+
            "Please update your runtime to a newer version ("+compilerInfo[1]+").");
    }
  }
}

exports.checkRevision = checkRevision;// TODO: Remove this line and break up compilePartial

function template(templateSpec, env) {
  if (!env) {
    throw new Exception("No environment passed to template");
  }

  // Note: Using env.VM references rather than local var references throughout this section to allow
  // for external users to override these as psuedo-supported APIs.
  var invokePartialWrapper = function(partial, name, context, helpers, partials, data) {
    var result = env.VM.invokePartial.apply(this, arguments);
    if (result != null) { return result; }

    if (env.compile) {
      var options = { helpers: helpers, partials: partials, data: data };
      partials[name] = env.compile(partial, { data: data !== undefined }, env);
      return partials[name](context, options);
    } else {
      throw new Exception("The partial " + name + " could not be compiled when running in runtime-only mode");
    }
  };

  // Just add water
  var container = {
    escapeExpression: Utils.escapeExpression,
    invokePartial: invokePartialWrapper,
    programs: [],
    program: function(i, fn, data) {
      var programWrapper = this.programs[i];
      if(data) {
        programWrapper = program(i, fn, data);
      } else if (!programWrapper) {
        programWrapper = this.programs[i] = program(i, fn);
      }
      return programWrapper;
    },
    merge: function(param, common) {
      var ret = param || common;

      if (param && common && (param !== common)) {
        ret = {};
        Utils.extend(ret, common);
        Utils.extend(ret, param);
      }
      return ret;
    },
    programWithDepth: env.VM.programWithDepth,
    noop: env.VM.noop,
    compilerInfo: null
  };

  return function(context, options) {
    options = options || {};
    var namespace = options.partial ? options : env,
        helpers,
        partials;

    if (!options.partial) {
      helpers = options.helpers;
      partials = options.partials;
    }
    var result = templateSpec.call(
          container,
          namespace, context,
          helpers,
          partials,
          options.data);

    if (!options.partial) {
      env.VM.checkRevision(container.compilerInfo);
    }

    return result;
  };
}

exports.template = template;function programWithDepth(i, fn, data /*, $depth */) {
  var args = Array.prototype.slice.call(arguments, 3);

  var prog = function(context, options) {
    options = options || {};

    return fn.apply(this, [context, options.data || data].concat(args));
  };
  prog.program = i;
  prog.depth = args.length;
  return prog;
}

exports.programWithDepth = programWithDepth;function program(i, fn, data) {
  var prog = function(context, options) {
    options = options || {};

    return fn(context, options.data || data);
  };
  prog.program = i;
  prog.depth = 0;
  return prog;
}

exports.program = program;function invokePartial(partial, name, context, helpers, partials, data) {
  var options = { partial: true, helpers: helpers, partials: partials, data: data };

  if(partial === undefined) {
    throw new Exception("The partial " + name + " could not be found");
  } else if(partial instanceof Function) {
    return partial(context, options);
  }
}

exports.invokePartial = invokePartial;function noop() { return ""; }

exports.noop = noop;
},{"./base":185,"./exception":186,"./utils":189}],188:[function(require,module,exports){
"use strict";
// Build out our basic SafeString type
function SafeString(string) {
  this.string = string;
}

SafeString.prototype.toString = function() {
  return "" + this.string;
};

exports["default"] = SafeString;
},{}],189:[function(require,module,exports){
"use strict";
/*jshint -W004 */
var SafeString = require("./safe-string")["default"];

var escape = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#x27;",
  "`": "&#x60;"
};

var badChars = /[&<>"'`]/g;
var possible = /[&<>"'`]/;

function escapeChar(chr) {
  return escape[chr] || "&amp;";
}

function extend(obj, value) {
  for(var key in value) {
    if(Object.prototype.hasOwnProperty.call(value, key)) {
      obj[key] = value[key];
    }
  }
}

exports.extend = extend;var toString = Object.prototype.toString;
exports.toString = toString;
// Sourced from lodash
// https://github.com/bestiejs/lodash/blob/master/LICENSE.txt
var isFunction = function(value) {
  return typeof value === 'function';
};
// fallback for older versions of Chrome and Safari
if (isFunction(/x/)) {
  isFunction = function(value) {
    return typeof value === 'function' && toString.call(value) === '[object Function]';
  };
}
var isFunction;
exports.isFunction = isFunction;
var isArray = Array.isArray || function(value) {
  return (value && typeof value === 'object') ? toString.call(value) === '[object Array]' : false;
};
exports.isArray = isArray;

function escapeExpression(string) {
  // don't escape SafeStrings, since they're already safe
  if (string instanceof SafeString) {
    return string.toString();
  } else if (!string && string !== 0) {
    return "";
  }

  // Force a string conversion as this will be done by the append regardless and
  // the regex test will do this transparently behind the scenes, causing issues if
  // an object's to string has escaped characters in it.
  string = "" + string;

  if(!possible.test(string)) { return string; }
  return string.replace(badChars, escapeChar);
}

exports.escapeExpression = escapeExpression;function isEmpty(value) {
  if (!value && value !== 0) {
    return true;
  } else if (isArray(value) && value.length === 0) {
    return true;
  } else {
    return false;
  }
}

exports.isEmpty = isEmpty;
},{"./safe-string":188}],190:[function(require,module,exports){
// Create a simple path alias to allow browserify to resolve
// the runtime on a supported path.
module.exports = require('./dist/cjs/handlebars.runtime');

},{"./dist/cjs/handlebars.runtime":184}],191:[function(require,module,exports){
module.exports = require("handlebars/runtime")["default"];

},{"handlebars/runtime":190}],192:[function(require,module,exports){

/**
 port of http://www.bbc.co.uk/glow/docs/1.7/api/glow.lang.shtml #interpolate
  Modified to be stand-alone and offer support for delimters of random length
  @description Replaces placeholders in a string with data from an object

  @param {String} template The string containing {placeholders}
  @param {Object} data Object containing the data to be merged in to the template
    The object can contain nested data objects and arrays, with nested object properties and array elements are accessed using dot notation. eg foo.bar or foo.0.
    The data labels in the object cannot contain characters used in the template delimiters, so if the data must be allowed to contain the default { and } delimiters, the delimters must be changed using the option below.
  @param {Object} opts Options object
    @param {String} [opts.delimiter="{}"] Alternative label delimiter(s) for the template. Needs to be symmetric, i.e. '{{}}', '<%%>'

  @returns {String}
 */

function interpolate (template, data, opts) {
  var regex,
      lDel,
      rDel,
      delLen,
      lDelLen,
      delimiter,
      // For escaping strings to go in regex
      regexEscape = /([$\^\\\/()|?+*\[\]{}.\-])/g;

  opts = opts || {};

  delimiter = opts.delimiter || '{}';
  delLen = delimiter.length;
  lDelLen = Math.ceil(delLen / 2);
  // escape delimiters for regex
  lDel = delimiter.substr(0, lDelLen).replace(regexEscape, "\\$1");
  rDel = delimiter.substr(lDelLen, delLen).replace(regexEscape, "\\$1") || lDel;

  // construct the new regex
  regex = new RegExp(lDel + "[^" + lDel + rDel + "]+" + rDel, "g");

  return template.replace(regex, function (placeholder) {
    var key = placeholder.slice(lDelLen, -lDelLen),
        keyParts = key.split("."),
        val,
        i = 0,
        len = keyParts.length;

    if (key in data) {
      // need to be backwards compatible with "flattened" data.
      val = data[key];
    }
    else {
      // look up the chain
      val = data;
      for (; i < len; i++) {
        if (keyParts[i] in val) {
          val = val[ keyParts[i] ];
        } else {
          return placeholder;
        }
      }
    }
    return val;
  });
}

module.exports = interpolate;

},{}],193:[function(require,module,exports){
var indexOf = require('./indexOf');

    /**
     * Combines an array with all the items of another.
     * Does not allow duplicates and is case and type sensitive.
     */
    function combine(arr1, arr2) {
        if (arr2 == null) {
            return arr1;
        }

        var i = -1, len = arr2.length;
        while (++i < len) {
            if (indexOf(arr1, arr2[i]) === -1) {
                arr1.push(arr2[i]);
            }
        }

        return arr1;
    }
    module.exports = combine;


},{"./indexOf":201}],194:[function(require,module,exports){
var indexOf = require('./indexOf');

    /**
     * If array contains values.
     */
    function contains(arr, val) {
        return indexOf(arr, val) !== -1;
    }
    module.exports = contains;


},{"./indexOf":201}],195:[function(require,module,exports){
var unique = require('./unique');
var filter = require('./filter');
var some = require('./some');
var contains = require('./contains');
var slice = require('./slice');


    /**
     * Return a new Array with elements that aren't present in the other Arrays.
     */
    function difference(arr) {
        var arrs = slice(arguments, 1),
            result = filter(unique(arr), function(needle){
                return !some(arrs, function(haystack){
                    return contains(haystack, needle);
                });
            });
        return result;
    }

    module.exports = difference;



},{"./contains":194,"./filter":197,"./slice":204,"./some":205,"./unique":206}],196:[function(require,module,exports){
var makeIterator = require('../function/makeIterator_');

    /**
     * Array every
     */
    function every(arr, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        var result = true;
        if (arr == null) {
            return result;
        }

        var i = -1, len = arr.length;
        while (++i < len) {
            // we iterate over sparse items since there is no way to make it
            // work properly on IE 7-8. see #64
            if (!callback(arr[i], i, arr) ) {
                result = false;
                break;
            }
        }

        return result;
    }

    module.exports = every;


},{"../function/makeIterator_":208}],197:[function(require,module,exports){
var makeIterator = require('../function/makeIterator_');

    /**
     * Array filter
     */
    function filter(arr, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        var results = [];
        if (arr == null) {
            return results;
        }

        var i = -1, len = arr.length, value;
        while (++i < len) {
            value = arr[i];
            if (callback(value, i, arr)) {
                results.push(value);
            }
        }

        return results;
    }

    module.exports = filter;



},{"../function/makeIterator_":208}],198:[function(require,module,exports){
var findIndex = require('./findIndex');

    /**
     * Returns first item that matches criteria
     */
    function find(arr, iterator, thisObj){
        var idx = findIndex(arr, iterator, thisObj);
        return idx >= 0? arr[idx] : void(0);
    }

    module.exports = find;



},{"./findIndex":199}],199:[function(require,module,exports){
var makeIterator = require('../function/makeIterator_');

    /**
     * Returns the index of the first item that matches criteria
     */
    function findIndex(arr, iterator, thisObj){
        iterator = makeIterator(iterator, thisObj);
        if (arr == null) {
            return -1;
        }

        var i = -1, len = arr.length;
        while (++i < len) {
            if (iterator(arr[i], i, arr)) {
                return i;
            }
        }

        return -1;
    }

    module.exports = findIndex;


},{"../function/makeIterator_":208}],200:[function(require,module,exports){
arguments[4][162][0].apply(exports,arguments)
},{"dup":162}],201:[function(require,module,exports){


    /**
     * Array.indexOf
     */
    function indexOf(arr, item, fromIndex) {
        fromIndex = fromIndex || 0;
        if (arr == null) {
            return -1;
        }

        var len = arr.length,
            i = fromIndex < 0 ? len + fromIndex : fromIndex;
        while (i < len) {
            // we iterate over sparse items since there is no way to make it
            // work properly on IE 7-8. see #64
            if (arr[i] === item) {
                return i;
            }

            i++;
        }

        return -1;
    }

    module.exports = indexOf;


},{}],202:[function(require,module,exports){
var unique = require('./unique');
var filter = require('./filter');
var every = require('./every');
var contains = require('./contains');
var slice = require('./slice');


    /**
     * Return a new Array with elements common to all Arrays.
     * - based on underscore.js implementation
     */
    function intersection(arr) {
        var arrs = slice(arguments, 1),
            result = filter(unique(arr), function(needle){
                return every(arrs, function(haystack){
                    return contains(haystack, needle);
                });
            });
        return result;
    }

    module.exports = intersection;



},{"./contains":194,"./every":196,"./filter":197,"./slice":204,"./unique":206}],203:[function(require,module,exports){
arguments[4][163][0].apply(exports,arguments)
},{"../function/makeIterator_":208,"dup":163}],204:[function(require,module,exports){
arguments[4][165][0].apply(exports,arguments)
},{"dup":165}],205:[function(require,module,exports){
var makeIterator = require('../function/makeIterator_');

    /**
     * Array some
     */
    function some(arr, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        var result = false;
        if (arr == null) {
            return result;
        }

        var i = -1, len = arr.length;
        while (++i < len) {
            // we iterate over sparse items since there is no way to make it
            // work properly on IE 7-8. see #64
            if ( callback(arr[i], i, arr) ) {
                result = true;
                break;
            }
        }

        return result;
    }

    module.exports = some;


},{"../function/makeIterator_":208}],206:[function(require,module,exports){
var filter = require('./filter');

    /**
     * @return {array} Array of unique items
     */
    function unique(arr, compare){
        compare = compare || isEqual;
        return filter(arr, function(item, i, arr){
            var n = arr.length;
            while (++i < n) {
                if ( compare(item, arr[i]) ) {
                    return false;
                }
            }
            return true;
        });
    }

    function isEqual(a, b){
        return a === b;
    }

    module.exports = unique;



},{"./filter":197}],207:[function(require,module,exports){
arguments[4][169][0].apply(exports,arguments)
},{"dup":169}],208:[function(require,module,exports){
arguments[4][170][0].apply(exports,arguments)
},{"../object/deepMatches":218,"./identity":207,"./prop":209,"dup":170}],209:[function(require,module,exports){
arguments[4][171][0].apply(exports,arguments)
},{"dup":171}],210:[function(require,module,exports){
arguments[4][172][0].apply(exports,arguments)
},{"../object/mixIn":224,"dup":172}],211:[function(require,module,exports){
arguments[4][173][0].apply(exports,arguments)
},{"./isKind":212,"dup":173}],212:[function(require,module,exports){
arguments[4][174][0].apply(exports,arguments)
},{"./kindOf":216,"dup":174}],213:[function(require,module,exports){
var isKind = require('./isKind');
    /**
     */
    function isNumber(val) {
        return isKind(val, 'Number');
    }
    module.exports = isNumber;


},{"./isKind":212}],214:[function(require,module,exports){


    /**
     * Checks if the value is created by the `Object` constructor.
     */
    function isPlainObject(value) {
        return (!!value && typeof value === 'object' &&
            value.constructor === Object);
    }

    module.exports = isPlainObject;



},{}],215:[function(require,module,exports){
var isKind = require('./isKind');
    /**
     */
    function isRegExp(val) {
        return isKind(val, 'RegExp');
    }
    module.exports = isRegExp;


},{"./isKind":212}],216:[function(require,module,exports){
arguments[4][176][0].apply(exports,arguments)
},{"dup":176}],217:[function(require,module,exports){


    /**
     * Typecast a value to a String, using an empty string value for null or
     * undefined.
     */
    function toString(val){
        return val == null ? '' : val.toString();
    }

    module.exports = toString;



},{}],218:[function(require,module,exports){
arguments[4][177][0].apply(exports,arguments)
},{"../lang/isArray":211,"./forOwn":221,"dup":177}],219:[function(require,module,exports){
var forOwn = require('./forOwn');
var isPlainObject = require('../lang/isPlainObject');

    /**
     * Mixes objects into the target object, recursively mixing existing child
     * objects.
     */
    function deepMixIn(target, objects) {
        var i = 0,
            n = arguments.length,
            obj;

        while(++i < n){
            obj = arguments[i];
            if (obj) {
                forOwn(obj, copyProp, target);
            }
        }

        return target;
    }

    function copyProp(val, key) {
        var existing = this[key];
        if (isPlainObject(val) && isPlainObject(existing)) {
            deepMixIn(existing, val);
        } else {
            this[key] = val;
        }
    }

    module.exports = deepMixIn;



},{"../lang/isPlainObject":214,"./forOwn":221}],220:[function(require,module,exports){
arguments[4][178][0].apply(exports,arguments)
},{"./hasOwn":222,"dup":178}],221:[function(require,module,exports){
arguments[4][179][0].apply(exports,arguments)
},{"./forIn":220,"./hasOwn":222,"dup":179}],222:[function(require,module,exports){
arguments[4][180][0].apply(exports,arguments)
},{"dup":180}],223:[function(require,module,exports){
var forOwn = require('./forOwn');

    /**
     * Get object keys
     */
     var keys = Object.keys || function (obj) {
            var keys = [];
            forOwn(obj, function(val, key){
                keys.push(key);
            });
            return keys;
        };

    module.exports = keys;



},{"./forOwn":221}],224:[function(require,module,exports){
arguments[4][181][0].apply(exports,arguments)
},{"./forOwn":221,"dup":181}],225:[function(require,module,exports){
var slice = require('../array/slice');

    /**
     * Return a copy of the object, filtered to only have values for the whitelisted keys.
     */
    function pick(obj, var_keys){
        var keys = typeof arguments[1] !== 'string'? arguments[1] : slice(arguments, 1),
            out = {},
            i = 0, key;
        while (key = keys[i++]) {
            out[key] = obj[key];
        }
        return out;
    }

    module.exports = pick;



},{"../array/slice":204}],226:[function(require,module,exports){

    /**
     * Contains all Unicode white-spaces. Taken from
     * http://en.wikipedia.org/wiki/Whitespace_character.
     */
    module.exports = [
        ' ', '\n', '\r', '\t', '\f', '\v', '\u00A0', '\u1680', '\u180E',
        '\u2000', '\u2001', '\u2002', '\u2003', '\u2004', '\u2005', '\u2006',
        '\u2007', '\u2008', '\u2009', '\u200A', '\u2028', '\u2029', '\u202F',
        '\u205F', '\u3000'
    ];


},{}],227:[function(require,module,exports){
var toString = require('../lang/toString');

    /**
     * Escape RegExp string chars.
     */
    function escapeRegExp(str) {
        return toString(str).replace(/\W/g,'\\$&');
    }

    module.exports = escapeRegExp;



},{"../lang/toString":217}],228:[function(require,module,exports){
var toString = require('../lang/toString');
var WHITE_SPACES = require('./WHITE_SPACES');
    /**
     * Remove chars from beginning of string.
     */
    function ltrim(str, chars) {
        str = toString(str);
        chars = chars || WHITE_SPACES;

        var start = 0,
            len = str.length,
            charLen = chars.length,
            found = true,
            i, c;

        while (found && start < len) {
            found = false;
            i = -1;
            c = str.charAt(start);

            while (++i < charLen) {
                if (c === chars[i]) {
                    found = true;
                    start++;
                    break;
                }
            }
        }

        return (start >= len) ? '' : str.substr(start, len);
    }

    module.exports = ltrim;


},{"../lang/toString":217,"./WHITE_SPACES":226}],229:[function(require,module,exports){
var toString = require('../lang/toString');
var WHITE_SPACES = require('./WHITE_SPACES');
    /**
     * Remove chars from end of string.
     */
    function rtrim(str, chars) {
        str = toString(str);
        chars = chars || WHITE_SPACES;

        var end = str.length - 1,
            charLen = chars.length,
            found = true,
            i, c;

        while (found && end >= 0) {
            found = false;
            i = -1;
            c = str.charAt(end);

            while (++i < charLen) {
                if (c === chars[i]) {
                    found = true;
                    end--;
                    break;
                }
            }
        }

        return (end >= 0) ? str.substring(0, end + 1) : '';
    }

    module.exports = rtrim;


},{"../lang/toString":217,"./WHITE_SPACES":226}],230:[function(require,module,exports){
var toString = require('../lang/toString');
var WHITE_SPACES = require('./WHITE_SPACES');
var ltrim = require('./ltrim');
var rtrim = require('./rtrim');
    /**
     * Remove white-spaces from beginning and end of string.
     */
    function trim(str, chars) {
        str = toString(str);
        chars = chars || WHITE_SPACES;
        return ltrim(rtrim(str, chars), chars);
    }

    module.exports = trim;


},{"../lang/toString":217,"./WHITE_SPACES":226,"./ltrim":228,"./rtrim":229}],231:[function(require,module,exports){


    /**
     * Get current time in miliseconds
     */
    function now(){
        // yes, we defer the work to another function to allow mocking it
        // during the tests
        return now.get();
    }

    now.get = (typeof Date.now === 'function')? Date.now : function(){
        return +(new Date());
    };

    module.exports = now;



},{}],232:[function(require,module,exports){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} options
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options){
  options = options || {};
  if ('string' == typeof val) return parse(val);
  return options.long
    ? long(val)
    : short(val);
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = '' + str;
  if (str.length > 10000) return;
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
  if (!match) return;
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function short(ms) {
  if (ms >= d) return Math.round(ms / d) + 'd';
  if (ms >= h) return Math.round(ms / h) + 'h';
  if (ms >= m) return Math.round(ms / m) + 'm';
  if (ms >= s) return Math.round(ms / s) + 's';
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function long(ms) {
  return plural(ms, d, 'day')
    || plural(ms, h, 'hour')
    || plural(ms, m, 'minute')
    || plural(ms, s, 'second')
    || ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) return;
  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
  return Math.ceil(ms / n) + ' ' + name + 's';
}

},{}],233:[function(require,module,exports){
(function (process,global){
/*
defer
*/"use strict"

var kindOf  = require("mout/lang/kindOf"),
    now     = require("mout/time/now"),
    forEach = require("mout/array/forEach"),
    indexOf = require("mout/array/indexOf")

var callbacks = {
    timeout: {},
    frame: [],
    immediate: []
}

var push = function(collection, callback, context, defer){

    var iterator = function(){
        iterate(collection)
    }

    if (!collection.length) defer(iterator)

    var entry = {
        callback: callback,
        context: context
    }

    collection.push(entry)

    return function(){
        var io = indexOf(collection, entry)
        if (io > -1) collection.splice(io, 1)
    }
}

var iterate = function(collection){
    var time = now()

    forEach(collection.splice(0), function(entry) {
        entry.callback.call(entry.context, time)
    })
}

var defer = function(callback, argument, context){
    return (kindOf(argument) === "Number") ? defer.timeout(callback, argument, context) : defer.immediate(callback, argument)
}

if (global.process && process.nextTick){

    defer.immediate = function(callback, context){
        return push(callbacks.immediate, callback, context, process.nextTick)
    }

} else if (global.setImmediate){

    defer.immediate = function(callback, context){
        return push(callbacks.immediate, callback, context, setImmediate)
    }

} else if (global.postMessage && global.addEventListener){

    addEventListener("message", function(event){
        if (event.source === global && event.data === "@deferred"){
            event.stopPropagation()
            iterate(callbacks.immediate)
        }
    }, true)

    defer.immediate = function(callback, context){
        return push(callbacks.immediate, callback, context, function(){
            postMessage("@deferred", "*")
        })
    }

} else {

    defer.immediate = function(callback, context){
        return push(callbacks.immediate, callback, context, function(iterator){
            setTimeout(iterator, 0)
        })
    }

}

var requestAnimationFrame = global.requestAnimationFrame ||
    global.webkitRequestAnimationFrame ||
    global.mozRequestAnimationFrame ||
    global.oRequestAnimationFrame ||
    global.msRequestAnimationFrame ||
    function(callback) {
        setTimeout(callback, 1e3 / 60)
    }

defer.frame = function(callback, context){
    return push(callbacks.frame, callback, context, requestAnimationFrame)
}

var clear

defer.timeout = function(callback, ms, context){
    var ct = callbacks.timeout

    if (!clear) clear = defer.immediate(function(){
        clear = null
        callbacks.timeout = {}
    })

    return push(ct[ms] || (ct[ms] = []), callback, context, function(iterator){
        setTimeout(iterator, ms)
    })
}

module.exports = defer

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"_process":237,"mout/array/forEach":200,"mout/array/indexOf":201,"mout/lang/kindOf":216,"mout/time/now":231}],234:[function(require,module,exports){
/*
Emitter
*/"use strict"

var indexOf = require("mout/array/indexOf"),
    forEach = require("mout/array/forEach")

var prime = require("./index"),
    defer = require("./defer")

var slice = Array.prototype.slice;

var Emitter = prime({

    constructor: function(stoppable){
        this._stoppable = stoppable
    },

    on: function(event, fn){
        var listeners = this._listeners || (this._listeners = {}),
            events = listeners[event] || (listeners[event] = [])

        if (indexOf(events, fn) === -1) events.push(fn)

        return this
    },

    off: function(event, fn){
        var listeners = this._listeners, events
        if (listeners && (events = listeners[event])){

            var io = indexOf(events, fn)
            if (io > -1) events.splice(io, 1)
            if (!events.length) delete listeners[event];
            for (var l in listeners) return this
            delete this._listeners
        }
        return this
    },

    emit: function(event){
        var self = this,
            args = slice.call(arguments, 1)

        var emit = function(){
            var listeners = self._listeners, events
            if (listeners && (events = listeners[event])){
                forEach(events.slice(0), function(event){
                    var result = event.apply(self, args)
                    if (self._stoppable) return result
                })
            }
        }

        if (args[args.length - 1] === Emitter.EMIT_SYNC){
            args.pop()
            emit()
        } else {
            defer(emit)
        }

        return this
    }

})

Emitter.EMIT_SYNC = {}

module.exports = Emitter

},{"./defer":233,"./index":235,"mout/array/forEach":200,"mout/array/indexOf":201}],235:[function(require,module,exports){
arguments[4][183][0].apply(exports,arguments)
},{"dup":183,"mout/lang/createObject":210,"mout/lang/kindOf":216,"mout/object/hasOwn":222,"mout/object/mixIn":224}],236:[function(require,module,exports){
/*
Map
*/"use strict"

var indexOf = require("mout/array/indexOf")

var prime = require("./index")

var Map = prime({

    constructor: function Map(){
        this.length = 0
        this._values = []
        this._keys = []
    },

    set: function(key, value){
        var index = indexOf(this._keys, key)

        if (index === -1){
            this._keys.push(key)
            this._values.push(value)
            this.length++
        } else {
            this._values[index] = value
        }

        return this
    },

    get: function(key){
        var index = indexOf(this._keys, key)
        return (index === -1) ? null : this._values[index]
    },

    count: function(){
        return this.length
    },

    forEach: function(method, context){
        for (var i = 0, l = this.length; i < l; i++){
            if (method.call(context, this._values[i], this._keys[i], this) === false) break
        }
        return this
    },

    map: function(method, context){
        var results = new Map
        this.forEach(function(value, key){
            results.set(key, method.call(context, value, key, this))
        }, this)
        return results
    },

    filter: function(method, context){
        var results = new Map
        this.forEach(function(value, key){
            if (method.call(context, value, key, this)) results.set(key, value)
        }, this)
        return results
    },

    every: function(method, context){
        var every = true
        this.forEach(function(value, key){
            if (!method.call(context, value, key, this)) return (every = false)
        }, this)
        return every
    },

    some: function(method, context){
        var some = false
        this.forEach(function(value, key){
            if (method.call(context, value, key, this)) return !(some = true)
        }, this)
        return some
    },

    indexOf: function(value){
        var index = indexOf(this._values, value)
        return (index > -1) ? this._keys[index] : null
    },

    remove: function(value){
        var index = indexOf(this._values, value)

        if (index !== -1){
            this._values.splice(index, 1)
            this.length--
            return this._keys.splice(index, 1)[0]
        }

        return null
    },

    unset: function(key){
        var index = indexOf(this._keys, key)

        if (index !== -1){
            this._keys.splice(index, 1)
            this.length--
            return this._values.splice(index, 1)[0]
        }

        return null
    },

    keys: function(){
        return this._keys.slice()
    },

    values: function(){
        return this._values.slice()
    }

})

var map = function(){
    return new Map
}

map.prototype = Map.prototype

module.exports = map

},{"./index":235,"mout/array/indexOf":201}],237:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],238:[function(require,module,exports){
/*
Slick Finder
*/"use strict"

// Notable changes from Slick.Finder 1.0.x

// faster bottom -> up expression matching
// prefers mental sanity over *obsessive compulsive* milliseconds savings
// uses prototypes instead of objects
// tries to use matchesSelector smartly, whenever available
// can populate objects as well as arrays
// lots of stuff is broken or not implemented

var parse = require("./parser")

// utilities

var index = 0,
    counter = document.__counter = (parseInt(document.__counter || -1, 36) + 1).toString(36),
    key = "uid:" + counter

var uniqueID = function(n, xml){
    if (n === window) return "window"
    if (n === document) return "document"
    if (n === document.documentElement) return "html"

    if (xml) {
        var uid = n.getAttribute(key)
        if (!uid) {
            uid = (index++).toString(36)
            n.setAttribute(key, uid)
        }
        return uid
    } else {
        return n[key] || (n[key] = (index++).toString(36))
    }
}

var uniqueIDXML = function(n) {
    return uniqueID(n, true)
}

var isArray = Array.isArray || function(object){
    return Object.prototype.toString.call(object) === "[object Array]"
}

// tests

var uniqueIndex = 0;

var HAS = {

    GET_ELEMENT_BY_ID: function(test, id){
        id = "slick_" + (uniqueIndex++);
        // checks if the document has getElementById, and it works
        test.innerHTML = '<a id="' + id + '"></a>'
        return !!this.getElementById(id)
    },

    QUERY_SELECTOR: function(test){
        // this supposedly fixes a webkit bug with matchesSelector / querySelector & nth-child
        test.innerHTML = '_<style>:nth-child(2){}</style>'

        // checks if the document has querySelectorAll, and it works
        test.innerHTML = '<a class="MiX"></a>'

        return test.querySelectorAll('.MiX').length === 1
    },

    EXPANDOS: function(test, id){
        id = "slick_" + (uniqueIndex++);
        // checks if the document has elements that support expandos
        test._custom_property_ = id
        return test._custom_property_ === id
    },

    // TODO: use this ?

    // CHECKED_QUERY_SELECTOR: function(test){
    //
    //     // checks if the document supports the checked query selector
    //     test.innerHTML = '<select><option selected="selected">a</option></select>'
    //     return test.querySelectorAll(':checked').length === 1
    // },

    // TODO: use this ?

    // EMPTY_ATTRIBUTE_QUERY_SELECTOR: function(test){
    //
    //     // checks if the document supports the empty attribute query selector
    //     test.innerHTML = '<a class=""></a>'
    //     return test.querySelectorAll('[class*=""]').length === 1
    // },

    MATCHES_SELECTOR: function(test){

        test.className = "MiX"

        // checks if the document has matchesSelector, and we can use it.

        var matches = test.matchesSelector || test.mozMatchesSelector || test.webkitMatchesSelector

        // if matchesSelector trows errors on incorrect syntax we can use it
        if (matches) try {
            matches.call(test, ':slick')
        } catch(e){
            // just as a safety precaution, also test if it works on mixedcase (like querySelectorAll)
            return matches.call(test, ".MiX") ? matches : false
        }

        return false
    },

    GET_ELEMENTS_BY_CLASS_NAME: function(test){
        test.innerHTML = '<a class="f"></a><a class="b"></a>'
        if (test.getElementsByClassName('b').length !== 1) return false

        test.firstChild.className = 'b'
        if (test.getElementsByClassName('b').length !== 2) return false

        // Opera 9.6 getElementsByClassName doesnt detects the class if its not the first one
        test.innerHTML = '<a class="a"></a><a class="f b a"></a>'
        if (test.getElementsByClassName('a').length !== 2) return false

        // tests passed
        return true
    },

    // no need to know

    // GET_ELEMENT_BY_ID_NOT_NAME: function(test, id){
    //     test.innerHTML = '<a name="'+ id +'"></a><b id="'+ id +'"></b>'
    //     return this.getElementById(id) !== test.firstChild
    // },

    // this is always checked for and fixed

    // STAR_GET_ELEMENTS_BY_TAG_NAME: function(test){
    //
    //     // IE returns comment nodes for getElementsByTagName('*') for some documents
    //     test.appendChild(this.createComment(''))
    //     if (test.getElementsByTagName('*').length > 0) return false
    //
    //     // IE returns closed nodes (EG:"</foo>") for getElementsByTagName('*') for some documents
    //     test.innerHTML = 'foo</foo>'
    //     if (test.getElementsByTagName('*').length) return false
    //
    //     // tests passed
    //     return true
    // },

    // this is always checked for and fixed

    // STAR_QUERY_SELECTOR: function(test){
    //
    //     // returns closed nodes (EG:"</foo>") for querySelector('*') for some documents
    //     test.innerHTML = 'foo</foo>'
    //     return !!(test.querySelectorAll('*').length)
    // },

    GET_ATTRIBUTE: function(test){
        // tests for working getAttribute implementation
        var shout = "fus ro dah"
        test.innerHTML = '<a class="' + shout + '"></a>'
        return test.firstChild.getAttribute('class') === shout
    }

}

// Finder

var Finder = function Finder(document){

    this.document        = document
    var root = this.root = document.documentElement
    this.tested          = {}

    // uniqueID

    this.uniqueID = this.has("EXPANDOS") ? uniqueID : uniqueIDXML

    // getAttribute

    this.getAttribute = (this.has("GET_ATTRIBUTE")) ? function(node, name){

        return node.getAttribute(name)

    } : function(node, name){

        node = node.getAttributeNode(name)
        return (node && node.specified) ? node.value : null

    }

    // hasAttribute

    this.hasAttribute = (root.hasAttribute) ? function(node, attribute){

        return node.hasAttribute(attribute)

    } : function(node, attribute) {

        node = node.getAttributeNode(attribute)
        return !!(node && node.specified)

    }

    // contains

    this.contains = (document.contains && root.contains) ? function(context, node){

        return context.contains(node)

    } : (root.compareDocumentPosition) ? function(context, node){

        return context === node || !!(context.compareDocumentPosition(node) & 16)

    } : function(context, node){

        do {
            if (node === context) return true
        } while ((node = node.parentNode))

        return false
    }

    // sort
    // credits to Sizzle (http://sizzlejs.com/)

    this.sorter = (root.compareDocumentPosition) ? function(a, b){

        if (!a.compareDocumentPosition || !b.compareDocumentPosition) return 0
        return a.compareDocumentPosition(b) & 4 ? -1 : a === b ? 0 : 1

    } : ('sourceIndex' in root) ? function(a, b){

        if (!a.sourceIndex || !b.sourceIndex) return 0
        return a.sourceIndex - b.sourceIndex

    } : (document.createRange) ? function(a, b){

        if (!a.ownerDocument || !b.ownerDocument) return 0
        var aRange = a.ownerDocument.createRange(),
            bRange = b.ownerDocument.createRange()

        aRange.setStart(a, 0)
        aRange.setEnd(a, 0)
        bRange.setStart(b, 0)
        bRange.setEnd(b, 0)
        return aRange.compareBoundaryPoints(Range.START_TO_END, bRange)

    } : null

    this.failed = {}

    var nativeMatches = this.has("MATCHES_SELECTOR")

    if (nativeMatches) this.matchesSelector = function(node, expression){

        if (this.failed[expression]) return null

        try {
            return nativeMatches.call(node, expression)
        } catch(e){
            if (slick.debug) console.warn("matchesSelector failed on " + expression)
            this.failed[expression] = true
            return null
        }

    }

    if (this.has("QUERY_SELECTOR")){

        this.querySelectorAll = function(node, expression){

            if (this.failed[expression]) return true

            var result, _id, _expression, _combinator, _node


            // non-document rooted QSA
            // credits to Andrew Dupont

            if (node !== this.document){

                _combinator = expression[0].combinator

                _id         = node.getAttribute("id")
                _expression = expression

                if (!_id){
                    _node = node
                    _id = "__slick__"
                    _node.setAttribute("id", _id)
                }

                expression = "#" + _id + " " + _expression


                // these combinators need a parentNode due to how querySelectorAll works, which is:
                // finding all the elements that match the given selector
                // then filtering by the ones that have the specified element as an ancestor
                if (_combinator.indexOf("~") > -1 || _combinator.indexOf("+") > -1){

                    node = node.parentNode
                    if (!node) result = true
                    // if node has no parentNode, we return "true" as if it failed, without polluting the failed cache

                }

            }

            if (!result) try {
                result = node.querySelectorAll(expression.toString())
            } catch(e){
                if (slick.debug) console.warn("querySelectorAll failed on " + (_expression || expression))
                result = this.failed[_expression || expression] = true
            }

            if (_node) _node.removeAttribute("id")

            return result

        }

    }

}

Finder.prototype.has = function(FEATURE){

    var tested        = this.tested,
        testedFEATURE = tested[FEATURE]

    if (testedFEATURE != null) return testedFEATURE

    var root     = this.root,
        document = this.document,
        testNode = document.createElement("div")

    testNode.setAttribute("style", "display: none;")

    root.appendChild(testNode)

    var TEST = HAS[FEATURE], result = false

    if (TEST) try {
        result = TEST.call(document, testNode)
    } catch(e){}

    if (slick.debug && !result) console.warn("document has no " + FEATURE)

    root.removeChild(testNode)

    return tested[FEATURE] = result

}

var combinators = {

    " ": function(node, part, push){

        var item, items

        var noId = !part.id, noTag = !part.tag, noClass = !part.classes

        if (part.id && node.getElementById && this.has("GET_ELEMENT_BY_ID")){
            item = node.getElementById(part.id)

            // return only if id is found, else keep checking
            // might be a tad slower on non-existing ids, but less insane

            if (item && item.getAttribute('id') === part.id){
                items = [item]
                noId = true
                // if tag is star, no need to check it in match()
                if (part.tag === "*") noTag = true
            }
        }

        if (!items){

            if (part.classes && node.getElementsByClassName && this.has("GET_ELEMENTS_BY_CLASS_NAME")){
                items = node.getElementsByClassName(part.classList)
                noClass = true
                // if tag is star, no need to check it in match()
                if (part.tag === "*") noTag = true
            } else {
                items = node.getElementsByTagName(part.tag)
                // if tag is star, need to check it in match because it could select junk, boho
                if (part.tag !== "*") noTag = true
            }

            if (!items || !items.length) return false

        }

        for (var i = 0; item = items[i++];)
            if ((noTag && noId && noClass && !part.attributes && !part.pseudos) || this.match(item, part, noTag, noId, noClass))
                push(item)

        return true

    },

    ">": function(node, part, push){ // direct children
        if ((node = node.firstChild)) do {
            if (node.nodeType == 1 && this.match(node, part)) push(node)
        } while ((node = node.nextSibling))
    },

    "+": function(node, part, push){ // next sibling
        while ((node = node.nextSibling)) if (node.nodeType == 1){
            if (this.match(node, part)) push(node)
            break
        }
    },

    "^": function(node, part, push){ // first child
        node = node.firstChild
        if (node){
            if (node.nodeType === 1){
                if (this.match(node, part)) push(node)
            } else {
                combinators['+'].call(this, node, part, push)
            }
        }
    },

    "~": function(node, part, push){ // next siblings
        while ((node = node.nextSibling)){
            if (node.nodeType === 1 && this.match(node, part)) push(node)
        }
    },

    "++": function(node, part, push){ // next sibling and previous sibling
        combinators['+'].call(this, node, part, push)
        combinators['!+'].call(this, node, part, push)
    },

    "~~": function(node, part, push){ // next siblings and previous siblings
        combinators['~'].call(this, node, part, push)
        combinators['!~'].call(this, node, part, push)
    },

    "!": function(node, part, push){ // all parent nodes up to document
        while ((node = node.parentNode)) if (node !== this.document && this.match(node, part)) push(node)
    },

    "!>": function(node, part, push){ // direct parent (one level)
        node = node.parentNode
        if (node !== this.document && this.match(node, part)) push(node)
    },

    "!+": function(node, part, push){ // previous sibling
        while ((node = node.previousSibling)) if (node.nodeType == 1){
            if (this.match(node, part)) push(node)
            break
        }
    },

    "!^": function(node, part, push){ // last child
        node = node.lastChild
        if (node){
            if (node.nodeType == 1){
                if (this.match(node, part)) push(node)
            } else {
                combinators['!+'].call(this, node, part, push)
            }
        }
    },

    "!~": function(node, part, push){ // previous siblings
        while ((node = node.previousSibling)){
            if (node.nodeType === 1 && this.match(node, part)) push(node)
        }
    }

}

Finder.prototype.search = function(context, expression, found){

    if (!context) context = this.document
    else if (!context.nodeType && context.document) context = context.document

    var expressions = parse(expression)

    // no expressions were parsed. todo: is this really necessary?
    if (!expressions || !expressions.length) throw new Error("invalid expression")

    if (!found) found = []

    var uniques, push = isArray(found) ? function(node){
        found[found.length] = node
    } : function(node){
        found[found.length++] = node
    }

    // if there is more than one expression we need to check for duplicates when we push to found
    // this simply saves the old push and wraps it around an uid dupe check.
    if (expressions.length > 1){
        uniques = {}
        var plush = push
        push = function(node){
            var uid = uniqueID(node)
            if (!uniques[uid]){
                uniques[uid] = true
                plush(node)
            }
        }
    }

    // walker

    var node, nodes, part

    main: for (var i = 0; expression = expressions[i++];){

        // querySelector

        // TODO: more functional tests

        // if there is querySelectorAll (and the expression does not fail) use it.
        if (!slick.noQSA && this.querySelectorAll){

            nodes = this.querySelectorAll(context, expression)
            if (nodes !== true){
                if (nodes && nodes.length) for (var j = 0; node = nodes[j++];) if (node.nodeName > '@'){
                    push(node)
                }
                continue main
            }
        }

        // if there is only one part in the expression we don't need to check each part for duplicates.
        // todo: this might be too naive. while solid, there can be expression sequences that do not
        // produce duplicates. "body div" for instance, can never give you each div more than once.
        // "body div a" on the other hand might.
        if (expression.length === 1){

            part = expression[0]
            combinators[part.combinator].call(this, context, part, push)

        } else {

            var cs = [context], c, f, u, p = function(node){
                var uid = uniqueID(node)
                if (!u[uid]){
                    u[uid] = true
                    f[f.length] = node
                }
            }

            // loop the expression parts
            for (var j = 0; part = expression[j++];){
                f = []; u = {}
                // loop the contexts
                for (var k = 0; c = cs[k++];) combinators[part.combinator].call(this, c, part, p)
                // nothing was found, the expression failed, continue to the next expression.
                if (!f.length) continue main
                cs = f // set the contexts for future parts (if any)
            }

            if (i === 0) found = f // first expression. directly set found.
            else for (var l = 0; l < f.length; l++) push(f[l]) // any other expression needs to push to found.
        }

    }

    if (uniques && found && found.length > 1) this.sort(found)

    return found

}

Finder.prototype.sort = function(nodes){
    return this.sorter ? Array.prototype.sort.call(nodes, this.sorter) : nodes
}

// TODO: most of these pseudo selectors include <html> and qsa doesnt. fixme.

var pseudos = {


    // TODO: returns different results than qsa empty.

    'empty': function(){
        return !(this && this.nodeType === 1) && !(this.innerText || this.textContent || '').length
    },

    'not': function(expression){
        return !slick.matches(this, expression)
    },

    'contains': function(text){
        return (this.innerText || this.textContent || '').indexOf(text) > -1
    },

    'first-child': function(){
        var node = this
        while ((node = node.previousSibling)) if (node.nodeType == 1) return false
        return true
    },

    'last-child': function(){
        var node = this
        while ((node = node.nextSibling)) if (node.nodeType == 1) return false
        return true
    },

    'only-child': function(){
        var prev = this
        while ((prev = prev.previousSibling)) if (prev.nodeType == 1) return false

        var next = this
        while ((next = next.nextSibling)) if (next.nodeType == 1) return false

        return true
    },

    'first-of-type': function(){
        var node = this, nodeName = node.nodeName
        while ((node = node.previousSibling)) if (node.nodeName == nodeName) return false
        return true
    },

    'last-of-type': function(){
        var node = this, nodeName = node.nodeName
        while ((node = node.nextSibling)) if (node.nodeName == nodeName) return false
        return true
    },

    'only-of-type': function(){
        var prev = this, nodeName = this.nodeName
        while ((prev = prev.previousSibling)) if (prev.nodeName == nodeName) return false
        var next = this
        while ((next = next.nextSibling)) if (next.nodeName == nodeName) return false
        return true
    },

    'enabled': function(){
        return !this.disabled
    },

    'disabled': function(){
        return this.disabled
    },

    'checked': function(){
        return this.checked || this.selected
    },

    'selected': function(){
        return this.selected
    },

    'focus': function(){
        var doc = this.ownerDocument
        return doc.activeElement === this && (this.href || this.type || slick.hasAttribute(this, 'tabindex'))
    },

    'root': function(){
        return (this === this.ownerDocument.documentElement)
    }

}

Finder.prototype.match = function(node, bit, noTag, noId, noClass){

    // TODO: more functional tests ?

    if (!slick.noQSA && this.matchesSelector){
        var matches = this.matchesSelector(node, bit)
        if (matches !== null) return matches
    }

    // normal matching

    if (!noTag && bit.tag){

        var nodeName = node.nodeName.toLowerCase()
        if (bit.tag === "*"){
            if (nodeName < "@") return false
        } else if (nodeName != bit.tag){
            return false
        }

    }

    if (!noId && bit.id && node.getAttribute('id') !== bit.id) return false

    var i, part

    if (!noClass && bit.classes){

        var className = this.getAttribute(node, "class")
        if (!className) return false

        for (part in bit.classes) if (!RegExp('(^|\\s)' + bit.classes[part] + '(\\s|$)').test(className)) return false
    }

    var name, value

    if (bit.attributes) for (i = 0; part = bit.attributes[i++];){

        var operator  = part.operator,
            escaped   = part.escapedValue

        name  = part.name
        value = part.value

        if (!operator){

            if (!this.hasAttribute(node, name)) return false

        } else {

            var actual = this.getAttribute(node, name)
            if (actual == null) return false

            switch (operator){
                case '^=' : if (!RegExp(      '^' + escaped            ).test(actual)) return false; break
                case '$=' : if (!RegExp(            escaped + '$'      ).test(actual)) return false; break
                case '~=' : if (!RegExp('(^|\\s)' + escaped + '(\\s|$)').test(actual)) return false; break
                case '|=' : if (!RegExp(      '^' + escaped + '(-|$)'  ).test(actual)) return false; break

                case '='  : if (actual !== value) return false; break
                case '*=' : if (actual.indexOf(value) === -1) return false; break
                default   : return false
            }

        }
    }

    if (bit.pseudos) for (i = 0; part = bit.pseudos[i++];){

        name  = part.name
        value = part.value

        if (pseudos[name]) return pseudos[name].call(node, value)

        if (value != null){
            if (this.getAttribute(node, name) !== value) return false
        } else {
            if (!this.hasAttribute(node, name)) return false
        }

    }

    return true

}

Finder.prototype.matches = function(node, expression){

    var expressions = parse(expression)

    if (expressions.length === 1 && expressions[0].length === 1){ // simplest match
        return this.match(node, expressions[0][0])
    }

    // TODO: more functional tests ?

    if (!slick.noQSA && this.matchesSelector){
        var matches = this.matchesSelector(node, expressions)
        if (matches !== null) return matches
    }

    var nodes = this.search(this.document, expression, {length: 0})

    for (var i = 0, res; res = nodes[i++];) if (node === res) return true
    return false

}

var finders = {}

var finder = function(context){
    var doc = context || document
    if (doc.ownerDocument) doc = doc.ownerDocument
    else if (doc.document) doc = doc.document

    if (doc.nodeType !== 9) throw new TypeError("invalid document")

    var uid = uniqueID(doc)
    return finders[uid] || (finders[uid] = new Finder(doc))
}

// ... API ...

var slick = function(expression, context){
    return slick.search(expression, context)
}

slick.search = function(expression, context, found){
    return finder(context).search(context, expression, found)
}

slick.find = function(expression, context){
    return finder(context).search(context, expression)[0] || null
}

slick.getAttribute = function(node, name){
    return finder(node).getAttribute(node, name)
}

slick.hasAttribute = function(node, name){
    return finder(node).hasAttribute(node, name)
}

slick.contains = function(context, node){
    return finder(context).contains(context, node)
}

slick.matches = function(node, expression){
    return finder(node).matches(node, expression)
}

slick.sort = function(nodes){
    if (nodes && nodes.length > 1) finder(nodes[0]).sort(nodes)
    return nodes
}

slick.parse = parse;

// slick.debug = true
// slick.noQSA  = true

module.exports = slick

},{"./parser":240}],239:[function(require,module,exports){
(function (global){
/*
slick
*/"use strict"

module.exports = "document" in global ? require("./finder") : { parse: require("./parser") }

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./finder":238,"./parser":240}],240:[function(require,module,exports){
/*
Slick Parser
 - originally created by the almighty Thomas Aylott <@subtlegradient> (http://subtlegradient.com)
*/"use strict"

// Notable changes from Slick.Parser 1.0.x

// The parser now uses 2 classes: Expressions and Expression
// `new Expressions` produces an array-like object containing a list of Expression objects
// - Expressions::toString() produces a cleaned up expressions string
// `new Expression` produces an array-like object
// - Expression::toString() produces a cleaned up expression string
// The only exposed method is parse, which produces a (cached) `new Expressions` instance
// parsed.raw is no longer present, use .toString()
// parsed.expression is now useless, just use the indices
// parsed.reverse() has been removed for now, due to its apparent uselessness
// Other changes in the Expressions object:
// - classNames are now unique, and save both escaped and unescaped values
// - attributes now save both escaped and unescaped values
// - pseudos now save both escaped and unescaped values

var escapeRe   = /([-.*+?^${}()|[\]\/\\])/g,
    unescapeRe = /\\/g

var escape = function(string){
    // XRegExp v2.0.0-beta-3
    // « https://github.com/slevithan/XRegExp/blob/master/src/xregexp.js
    return (string + "").replace(escapeRe, '\\$1')
}

var unescape = function(string){
    return (string + "").replace(unescapeRe, '')
}

var slickRe = RegExp(
/*
#!/usr/bin/env ruby
puts "\t\t" + DATA.read.gsub(/\(\?x\)|\s+#.*$|\s+|\\$|\\n/,'')
__END__
    "(?x)^(?:\
      \\s* ( , ) \\s*               # Separator          \n\
    | \\s* ( <combinator>+ ) \\s*   # Combinator         \n\
    |      ( \\s+ )                 # CombinatorChildren \n\
    |      ( <unicode>+ | \\* )     # Tag                \n\
    | \\#  ( <unicode>+       )     # ID                 \n\
    | \\.  ( <unicode>+       )     # ClassName          \n\
    |                               # Attribute          \n\
    \\[  \
        \\s* (<unicode1>+)  (?:  \
            \\s* ([*^$!~|]?=)  (?:  \
                \\s* (?:\
                    ([\"']?)(.*?)\\9 \
                )\
            )  \
        )?  \\s*  \
    \\](?!\\]) \n\
    |   :+ ( <unicode>+ )(?:\
    \\( (?:\
        (?:([\"'])([^\\12]*)\\12)|((?:\\([^)]+\\)|[^()]*)+)\
    ) \\)\
    )?\
    )"
*/
"^(?:\\s*(,)\\s*|\\s*(<combinator>+)\\s*|(\\s+)|(<unicode>+|\\*)|\\#(<unicode>+)|\\.(<unicode>+)|\\[\\s*(<unicode1>+)(?:\\s*([*^$!~|]?=)(?:\\s*(?:([\"']?)(.*?)\\9)))?\\s*\\](?!\\])|(:+)(<unicode>+)(?:\\((?:(?:([\"'])([^\\13]*)\\13)|((?:\\([^)]+\\)|[^()]*)+))\\))?)"
    .replace(/<combinator>/, '[' + escape(">+~`!@$%^&={}\\;</") + ']')
    .replace(/<unicode>/g, '(?:[\\w\\u00a1-\\uFFFF-]|\\\\[^\\s0-9a-f])')
    .replace(/<unicode1>/g, '(?:[:\\w\\u00a1-\\uFFFF-]|\\\\[^\\s0-9a-f])')
)

// Part

var Part = function Part(combinator){
    this.combinator = combinator || " "
    this.tag = "*"
}

Part.prototype.toString = function(){

    if (!this.raw){

        var xpr = "", k, part

        xpr += this.tag || "*"
        if (this.id) xpr += "#" + this.id
        if (this.classes) xpr += "." + this.classList.join(".")
        if (this.attributes) for (k = 0; part = this.attributes[k++];){
            xpr += "[" + part.name + (part.operator ? part.operator + '"' + part.value + '"' : '') + "]"
        }
        if (this.pseudos) for (k = 0; part = this.pseudos[k++];){
            xpr += ":" + part.name
            if (part.value) xpr += "(" + part.value + ")"
        }

        this.raw = xpr

    }

    return this.raw
}

// Expression

var Expression = function Expression(){
    this.length = 0
}

Expression.prototype.toString = function(){

    if (!this.raw){

        var xpr = ""

        for (var j = 0, bit; bit = this[j++];){
            if (j !== 1) xpr += " "
            if (bit.combinator !== " ") xpr += bit.combinator + " "
            xpr += bit
        }

        this.raw = xpr

    }

    return this.raw
}

var replacer = function(
    rawMatch,

    separator,
    combinator,
    combinatorChildren,

    tagName,
    id,
    className,

    attributeKey,
    attributeOperator,
    attributeQuote,
    attributeValue,

    pseudoMarker,
    pseudoClass,
    pseudoQuote,
    pseudoClassQuotedValue,
    pseudoClassValue
){

    var expression, current

    if (separator || !this.length){
        expression = this[this.length++] = new Expression
        if (separator) return ''
    }

    if (!expression) expression = this[this.length - 1]

    if (combinator || combinatorChildren || !expression.length){
        current = expression[expression.length++] = new Part(combinator)
    }

    if (!current) current = expression[expression.length - 1]

    if (tagName){

        current.tag = unescape(tagName)

    } else if (id){

        current.id = unescape(id)

    } else if (className){

        var unescaped = unescape(className)

        var classes = current.classes || (current.classes = {})
        if (!classes[unescaped]){
            classes[unescaped] = escape(className)
            var classList = current.classList || (current.classList = [])
            classList.push(unescaped)
            classList.sort()
        }

    } else if (pseudoClass){

        pseudoClassValue = pseudoClassValue || pseudoClassQuotedValue

        ;(current.pseudos || (current.pseudos = [])).push({
            type         : pseudoMarker.length == 1 ? 'class' : 'element',
            name         : unescape(pseudoClass),
            escapedName  : escape(pseudoClass),
            value        : pseudoClassValue ? unescape(pseudoClassValue) : null,
            escapedValue : pseudoClassValue ? escape(pseudoClassValue) : null
        })

    } else if (attributeKey){

        attributeValue = attributeValue ? escape(attributeValue) : null

        ;(current.attributes || (current.attributes = [])).push({
            operator     : attributeOperator,
            name         : unescape(attributeKey),
            escapedName  : escape(attributeKey),
            value        : attributeValue ? unescape(attributeValue) : null,
            escapedValue : attributeValue ? escape(attributeValue) : null
        })

    }

    return ''

}

// Expressions

var Expressions = function Expressions(expression){
    this.length = 0

    var self = this

    var original = expression, replaced

    while (expression){
        replaced = expression.replace(slickRe, function(){
            return replacer.apply(self, arguments)
        })
        if (replaced === expression) throw new Error(original + ' is an invalid expression')
        expression = replaced
    }
}

Expressions.prototype.toString = function(){
    if (!this.raw){
        var expressions = []
        for (var i = 0, expression; expression = this[i++];) expressions.push(expression)
        this.raw = expressions.join(", ")
    }

    return this.raw
}

var cache = {}

var parse = function(expression){
    if (expression == null) return null
    expression = ('' + expression).replace(/^\s+|\s+$/g, '')
    return cache[expression] || (cache[expression] = new Expressions(expression))
}

module.exports = parse

},{}],241:[function(require,module,exports){
/*jslint node: true */

'use strict';

var ClientRequest = require('./request').ClientRequest;

/**
 * An autoincremented id that is used to distinguish Resolver instances.
 *
 * @type {number}
 * @private
 */
var resolverUID = 0;

/**
 * A resolver takes a request for a resources and sends it through the
 * transport.
 *
 * @constructs Resolver
 */
function Resolver() {
  if (!(this instanceof Resolver))
    return new Resolver();

  /**
   * The resolver's id.
   *
   * @type {number}
   * @protected
   */
  this._id = resolverUID++;

  /**
   * An incrementing ID used for tracking requests.
   *
   * @type {number}
   * @protected
   */
  this._requestID = 0;

  /**
   * Storage for the sent request handlers waiting for a response.
   *
   * @type {Object.<string, function>}
   * @protected
   */
  this._handlers = {};
}
exports.Resolver = Resolver;

/**
 * Adds a handler to the internal storage.
 *
 * @param {number} requestID The identifier for the request.
 * @param {ClientRequest} handler The handler for the request.
 * @protected
 */
Resolver.prototype._addHandler = function(requestID, handler) {
  this._handlers[requestID] = handler;
  return this;
};

/**
 * Removes a handler from the internal storage.
 *
 * @param {number} requestID The identifier for the request.
 * @protected
 */
Resolver.prototype._removeHandler = function(requestID) {
  this._handlers[requestID] = null;
  return this;
};

/**
 * Sends a request through the transport.
 *
 * Subclasses of this class need to implement this method.
 *
 * @param {number} requestID The id of the request.
 * @param {Object} data The payload data for the request.
 * @protected
 */
Resolver.prototype._sendRequest = function(requestID, data) {
  throw new Error('Resolver _sendRequest not implemented.');
};

/**
 * Handles a response from the transport.
 *
 * @param {Object} response The response from the transport.
 * @protected
 */
Resolver.prototype._handleResponse = function(response) {
  throw new Error('Resolver _handleResponse not implemented.');
};

/**
 * Dispatches a request handler with some data.
 *
 * @param {number} requestID The request handler to dispatch.
 * @param {Object} data The response data to send back.
 * @protected
 */
Resolver.prototype._dispatchResponse = function(requestID, requestType, data) {
  var handler = this._handlers[requestID];
  if (!handler) return;
  handler._handleResponse(requestType, data);
};

/**
 * Resolves a request (represented by the data) through the transport.
 *
 * @param {Object} data The data representing the request.
 * @param {function} onsuccess The success handler for the request.
 * @param {function} onerror The error handler for the request.
 */
Resolver.prototype._resolve = function(data, onsuccess, onerror) {
  if (!data || !onsuccess || !onerror ||
      typeof onsuccess != 'function' || typeof onerror != 'function')
    throw new TypeError('Invalid argument length for `resolve`.');

  var requestID = ++this._requestID;
  var request = new ClientRequest(this, requestID, data, onsuccess, onerror);

  this._addHandler(requestID, request);

  request.onClose = this._removeHandler.bind(this);
  request.open();

  return request;
};

/**
 * Resolves a single request (represented by the data) through the transport.
 *
 * @param {Object} data The data representing the request.
 * @param {function} onsuccess The success handler for the request.
 * @param {function} onerror The error handler for the request.
 */
Resolver.prototype.resolve = function(data, onsuccess, onerror) {
  throw new Error('Resolver resolve not implemented.');
};

/**
 * Resolves a subscription request (represented by the data) through the transport.
 *
 * @param {Object} data The data representing the request.
 * @param {function} onsuccess The success handler for the request.
 * @param {function} onerror The error handler for the request.
 */
Resolver.prototype.subscribe = function(data, onsuccess, onerror) {
  throw new Error('Resolver subscribe not implemented.');
};

},{"./request":245}],242:[function(require,module,exports){
(function (global){
/*jslint node: true */

'use strict';

var defer = require('spotify-deferred');
var Resolver = require('./bootstrap').Resolver;

/**
 * A mock resolver for a nodejs environment.
 *
 * This resolver uses regular callbacks as a transport.
 *
 * @constructs Cosmos.MockResolver
 * @extends Cosmos.Resolver
 */
function MockResolver() {
  if (!(this instanceof MockResolver))
    return new MockResolver();
  Resolver.call(this);

  // rebind the _handleResponse method so that we can reuse it for both
  // addEventListener and removeEventListener
  this._handleResponse = this._handleResponse.bind(this);

  /**
   * The identifier for request messages.
   *
   * @type {string}
   * @protected
   */
  this._requestMessageType = 'cosmos-request';

  /**
   * The identifier for response messages.
   *
   * @type {string}
   * @protected
   */
  this._responseMessageType = 'cosmos-response';

  /**
   * Prefix for the requests ids to prevent clashes
   * with bridge requests in webplayer
   *
   * @type {string}
   * @private
   */
  this._requestIdPrefix = 'cosmos_';

  this._handlersMap = {};

  // attach the handler
  this.attach();
}
MockResolver.prototype = new Resolver();
MockResolver.prototype.constructor = MockResolver;
exports.MockResolver = MockResolver;

/**
 * @inheritDoc
 */
MockResolver.prototype._sendRequest = function(requestName, requestID, data) {
  var self = this;

  var message = {
    type: this._requestMessageType,
    resolver: this._id,
    id: this._requestIdPrefix + requestID,
    name: requestName,
    payload: data.serialize ? data.serialize() : data
  };

  if (!this._handlersMap[data._action]) {
    return;
  }

  if (!this._handlersMap[data._action][data._uri]) {
    return;
  }

  this._handlersMap[data._action][data._uri](data, function (status, resp) {
    message.payload = {
      body: typeof resp !== 'undefined' ? resp : status,
      uri: data._uri,
      status: typeof resp !== 'undefined' ? status : 200
    };
    message.type = self._responseMessageType;

    var response = {
      data: message
    };
    self._handleResponse(response);
  });
};

/**
 * @inheritDoc
 */
MockResolver.prototype._handleResponse = function(response) {
  var data = response.data;
  if (typeof data == 'string') {
    try {
      data = JSON.parse(response.data);
    } catch (e) {
      return;
    }
  }
  if (data.type != this._responseMessageType ||
      data.resolver != this._id ||
      !data.payload) return;
  var id = data.id || '';
  var requestID = parseInt(id.replace(this._requestIdPrefix, ''), 10);
  var requestName = data.name || '';
  if (!requestID || !requestName) return;
  this._dispatchResponse(requestID, requestName, data.payload);
};

/**
 * Attaches the resolver so that it could process calls from the window object.
 */
MockResolver.prototype.attach = function() {
  var win = global.window;
  if (win) {
    win._cosmosRequest = this.resolve.bind(this);
  }
};

/**
 * Detaches the resolver so that it doesn't process calls from the window object.
 */
MockResolver.prototype.detach = function() {
  var win = global.window;
  if (win) {
    delete win._cosmosRequest;
  }
};

/**
 * Specific method for the mock resolver to add request handlers
 *
 * @param {string}   method       Type of method (GET, POST, PUT, SUB)
 * @param {string}   uri          Request to handle
 * @param {Function} fn           Function that handles the request
 */
MockResolver.prototype.addHandler = function(method, uri, fn) {
  if (!this._handlersMap[method]) {
    this._handlersMap[method] = {};
  }

  this._handlersMap[method][uri] = fn;
};

/**
 * Specific method for the mock resolver to remove a specific request handler
 *
 * @param {string}   method       Type of method (GET, POST, PUT, SUB)
 * @param {string}   uri          Request to handle
 */
MockResolver.prototype.removeHandler = function(method, uri) {
  if (!this._handlersMap[method]) {
    return;
  }

  if (this._handlersMap[method][uri]) {
    delete this._handlersMap[method][uri];
  }
};

/**
 * Specific method for the mock resolver to remove all handlers
 */
MockResolver.prototype.clearHandlers = function() {
  this._handlersMap = {};
};

/**
 * Resolves a single request (represented by the data) through the transport.
 * Single requests need to be closed immediately after the response is
 * received.
 *
 * @param {Object} data The data representing the request.
 * @param {function} onsuccess The success handler for the request.
 * @param {function} onerror The error handler for the request.
 */
MockResolver.prototype.resolve = function(data, onsuccess, onerror) {
  function onResult(callback, response) {
    defer(callback.bind(this, response));
    request.close();
  }

  var request = this._resolve(data, onResult.bind(this, onsuccess), onResult.bind(this, onerror));
  return request;
};

/**
 * Resolves a  subscription request (represented by the data) through the transport.
 * Subscriptions stay open until they're explicitly closed.
 * Every time the request returns some data pull for next
 * batch is sent.
 *
 * @param {Object} data The data representing the request.
 * @param {function} onsuccess The success handler for the request.
 * @param {function} onerror The error handler for the request.
 */
MockResolver.prototype.subscribe = function(data, onsuccess, onerror) {
  return this._resolve(data, onsuccess, onerror);
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./bootstrap":241,"spotify-deferred":248}],243:[function(require,module,exports){
(function (global){
/*jslint node: true */

'use strict';

var SpotifyApi = global.SpotifyApi;
var useApiRequest = !!(SpotifyApi && SpotifyApi.api &&
    typeof SpotifyApi.api.request === 'function');

var Resolver = require('./bootstrap').Resolver;
var defer = require('spotify-deferred');

/**
 * A resolver for a native environment.
 *
 * This resolver uses the Stitch bridge as a transport
 *
 * @constructs Cosmos.NativeResolver
 * @extends Cosmos.Resolver
 * @param {Object} spBridge Spotify CPP/JS bridge
 */
function NativeResolver(spBridge) {
  if (!(this instanceof NativeResolver))
    return new NativeResolver();
  if (!spBridge) {
    throw new TypeError('Missing `spBridge` parameter');
  }
  Resolver.call(this);

  this._bridge = spBridge;

  this._deferredFlush = false;
}
NativeResolver.prototype = new Resolver();
NativeResolver.prototype.constructor = NativeResolver;
exports.NativeResolver = NativeResolver;

/**
 * Prepare bridge flush.
 * TODO: Move to the separate module
 */
NativeResolver.prototype._prepareCoreFlush = function() {
  if (!this._deferredFlush) {
    this._deferredFlush = true;
    this._defer(this, this._flushRequests);
  }
};

/**
 * Flush bridge requests.
 * TODO: Move to the separate module
 */
NativeResolver.prototype._flushRequests = function() {
  this._deferredFlush = false;
  var flushMsg = JSON.stringify({ name: 'core_flush', args: []});
  this._sendBridgeRequest(flushMsg, {
    onSuccess: function() {},
    onFailure: function() {}
  });
};

/**
 * Defer the function call.
 * TODO: Move to the separate module
 */
NativeResolver.prototype._defer = function(context, callback) {
  defer(callback.bind(context));
};

/**
 * If SpotifyApi is loaded, use api requests to send messages to bridge
 * TODO: Use proxy that will handle Cosmos/Stitch calls for the resolver.
 */
NativeResolver.prototype._sendRequest = function(requestName, requestId, data) {
  var self = this;
  data = (data.serialize ? data.serialize() : data);

  var args = [requestId, data];
  var caller = { self: this, id: requestId, type: requestName };

  if (useApiRequest) {
    this._sendApiRequest(requestName, args, caller, this._handleResponse, this._handleError);
  } else {
    this._sendCosmosRequest(requestName, args, caller, this._handleResponse, this._handleError);
  }
};


/**
 * Talk to bridge directly from Cosmos
 * TODO: Move to the separate module
 */
NativeResolver.prototype._sendCosmosRequest = function(requestName, args, caller, onSuccess, onError) {
  var message = JSON.stringify({
    name: requestName,
    args: args
  });

  this._sendBridgeRequest(message, {
    onSuccess: function(data) {
      onSuccess.call(caller, JSON.parse(data));
    },
    onFailure: function(data) {
      data = JSON.parse(data);
      onError.call(caller, data);
    }
  });

  this._prepareCoreFlush();
};

/**
 * Send message to the bridge
 * @param {string} message The message to send to the bridge.
 * @param {Object.<string, function>} callbackMap The `onSuccess`
 * and `onFailure` functions to be executed after request is completed.
 * TODO: Use proxy that will handle Cosmos/Stitch calls for the resolver.
 */
NativeResolver.prototype._sendBridgeRequest = function(message, callbackMap) {
  this._bridge.executeRequest(message, callbackMap || {});
};

/**
 * Use old API to send messages to the bridge.
 * TODO: Move to the separate module
 */
NativeResolver.prototype._sendApiRequest = function(requestName, args, caller, onSuccess, onError) {
  SpotifyApi.api.request(
      requestName,
      args,
      caller,
      onSuccess,
      onError
  );
};

/**
 * Handles successful responses from the bridge
 * @param {Object} data The response data.
 */
NativeResolver.prototype._handleResponse = function(data) {
  this.self._dispatchResponse(this.id, this.type, data.responses && data.responses[0] || data);
};

/**
 * Handles failed responses from the bridge
 * @param {Object} error The error data.
 */
NativeResolver.prototype._handleError = function(error) {
  this.self._dispatchResponse(this.id, this.type, error);
};

/**
 * Resolves a single request (represented by the data) through the transport.
 * Single requests need to be closed immediately after the response is
 * received.
 *
 * @param {Object} data The data representing the request.
 * @param {function} onsuccess The success handler for the request.
 * @param {function} onerror The error handler for the request.
 */
NativeResolver.prototype.resolve = function(data, onsuccess, onerror) {
  function onResult(callback, response) {
    this._defer(this, callback.bind(this, response));
    request.close();
  }

  var request = this._resolve(data, onResult.bind(this, onsuccess), onResult.bind(this, onerror));
  return request;
};

/**
 * Resolves a  subscription request (represented by the data) through the transport.
 * Subscriptions stay open until they're explicitly closed.
 * Every time the request returns some data pull for next
 * batch is sent.
 *
 * @param {Object} data The data representing the request.
 * @param {function} onsuccess The success handler for the request.
 * @param {function} onerror The error handler for the request.
 */
NativeResolver.prototype.subscribe = function(data, onsuccess, onerror) {
  function onResult(callback, response) {
    callback.call(this, response);
    request.pull();
  }

  var request = this._resolve(data, onResult.bind(this, onsuccess), onResult.bind(this, onerror));
  return request;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./bootstrap":241,"spotify-deferred":248}],244:[function(require,module,exports){
(function (global){
/*jslint node: true */

'use strict';

var defer = require('spotify-deferred');
var Resolver = require('./bootstrap').Resolver;

/**
 * A resolver for a web-based environment.
 *
 * This resolver uses postMessage as a transport.
 *
 * @constructs Cosmos.WebResolver
 * @extends Cosmos.Resolver
 * @type {string=} opt_target The optional target for the postMessage calls.
 */
function WebResolver(opt_target) {
  if (!(this instanceof WebResolver))
    return new WebResolver(opt_target);
  Resolver.call(this);

  /**
   * The target for postMessage calls.
   *
   * @type {string}
   * @protected
   */
  this._target = opt_target || '*';

  // rebind the _handleResponse method so that we can reuse it for both
  // addEventListener and removeEventListener
  this._handleResponse = this._handleResponse.bind(this);

  /**
   * The identifier for request messages.
   *
   * @type {string}
   * @protected
   */
  this._requestMessageType = 'cosmos-request';

  /**
   * The identifier for response messages.
   *
   * @type {string}
   * @protected
   */
  this._responseMessageType = 'cosmos-response';

  /**
   * Prefix for the requests ids to prevent clashes
   * with bridge requests in webplayer
   *
   * @type {string}
   * @private
   */
  this._requestIdPrefix = 'cosmos_';

  // attach the handler
  this.attach();
}
WebResolver.prototype = new Resolver();
WebResolver.prototype.constructor = WebResolver;
exports.WebResolver = WebResolver;

/**
 * @inheritDoc
 */
WebResolver.prototype._sendRequest = function(requestName, requestID, data) {
  var top = global.window.top;

  var message = {
    type: this._requestMessageType,
    resolver: this._id,
    id: this._requestIdPrefix + requestID,
    name: requestName,
    payload: data.serialize ? data.serialize() : data
  };
  top.postMessage(JSON.stringify(message), this._target);
};

/**
 * @inheritDoc
 */
WebResolver.prototype._handleResponse = function(response) {
  var data = response.data;
  if (typeof data == 'string') {
    try {
      data = JSON.parse(response.data);
    } catch (e) {
      return;
    }
  }
  if (data.type != this._responseMessageType ||
      data.resolver != this._id ||
      !data.payload) return;
  var id = data.id || '';
  var requestID = parseInt(id.replace(this._requestIdPrefix, ''), 10);
  var requestName = data.name || '';
  if (!requestID || !requestName) return;
  this._dispatchResponse(requestID, requestName, data.payload);
};

/**
 * Attaches the resolver so that it could process postMessage calls.
 */
WebResolver.prototype.attach = function() {
  var win = global.window;
  if (win.addEvent && !win.addEventListener) {
    win.addEvent('onmessage', this._handleResponse);
  } else {
    win.addEventListener('message', this._handleResponse, false);
  }
};

/**
 * Detaches the resolver so that it doesn't process postMessage calls.
 */
WebResolver.prototype.detach = function() {
  var win = global.window;
  if (win.removeEvent && !win.removeEventListener) {
    win.removeEvent('onmessage', this._handleResponse);
  } else {
    win.removeEventListener('message', this._handleResponse, false);
  }
};

/**
 * Resolves a single request (represented by the data) through the transport.
 * Single requests need to be closed immediately after the response is
 * received.
 *
 * @param {Object} data The data representing the request.
 * @param {function} onsuccess The success handler for the request.
 * @param {function} onerror The error handler for the request.
 */
WebResolver.prototype.resolve = function(data, onsuccess, onerror) {
  function onResult(callback, response) {
    defer(callback.bind(this, response));
    request.close();
  }

  var request = this._resolve(data, onResult.bind(this, onsuccess), onResult.bind(this, onerror));
  return request;
};

/**
 * Resolves a  subscription request (represented by the data) through the transport.
 * Subscriptions stay open until they're explicitly closed.
 * Every time the request returns some data pull for next
 * batch is sent.
 *
 * @param {Object} data The data representing the request.
 * @param {function} onsuccess The success handler for the request.
 * @param {function} onerror The error handler for the request.
 */
WebResolver.prototype.subscribe = function(data, onsuccess, onerror) {
  return this._resolve(data, onsuccess, onerror);
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./bootstrap":241,"spotify-deferred":248}],245:[function(require,module,exports){
/*jslint node: true */

'use strict';

var defer = require('spotify-deferred');

/**
 * The representation of the connection to the client.
 * With introduction of Cosmos subscription the model of making
 * client requests changed.
 * Each Cosmos requests now needs to be explicitly cancelled to
 * close the connection.
 * Simple requests that only send or retrieve data (e.g POST and GET)
 * need to send 'cosmos_request_cancel' message immediately after the response
 * is received.
 * Subscription requests need to send a 'cosmos_request_pull' message every time
 * they receive data. The consumer of the subscription needs to cancel the subscription
 * when no more data should be sent from the provider.
 */
function ClientRequest(resolver, requestId, data, onsuccess, onerror) {

  /**
   * Request identifier.
   * @type {number}
   */
  this._requestId = requestId;

  /**
   * Either web or native request resolver.
   * @type {Cosmos.Resolver}
   */
  this._resolver = resolver;

  /**
   * Data that should be passed with every request.
   * @type {*}
   */
  this._requestData = data;

  /**
   * Triggered on success
   * @type {function}
   */
  this._successCallback = onsuccess;

  /**
   * Triggered on error
   * @type {function}
   */
  this._errorCallback = onerror;

  /**
   * Current state of the request.
   * @type {ClientRequest.status}
   */
  this._status = ClientRequest.status.INITIALIZED;
}
exports.ClientRequest = ClientRequest;

/**
 * Possible state of the ClientRequest instance.
 */
ClientRequest.status = {
  INITIALIZED: 'INITIALIZED',
  CLOSED: 'CLOSED',
  OPEN: 'OPEN'
};

/**
 * Possible desktop bridge messages.
 */
ClientRequest.messages = {
  OPEN: 'cosmos_request_create',
  PULL: 'cosmos_request_pull',
  CLOSE: 'cosmos_request_cancel'
};

/**
 * Opens the connection with the client.
 */
ClientRequest.prototype.open = function() {
  if (this._status === ClientRequest.status.INITIALIZED) {
    this._status = ClientRequest.status.OPEN;
    this._sendRequest(ClientRequest.messages.OPEN, this._requestData);
  }
};

/**
 * Send pull request for the open connection.
 * For subscriptions pull should resolve to a
 * piece of data.
 */
ClientRequest.prototype.pull = function() {
  if (this._status === ClientRequest.status.OPEN) {
    this._sendRequest(ClientRequest.messages.PULL, this._requestData);
  }
  return this._status;
};

/**
 * Closes the connection with the client.
 */
ClientRequest.prototype.close = function() {
  if (this._status === ClientRequest.status.OPEN) {
    this._status = ClientRequest.status.CLOSE;
    this._sendRequest(ClientRequest.messages.CLOSE);
  }
};

ClientRequest.prototype.onClose = function() {};

/**
 * Sends the request to the platform specific resolver
 * @param {string} requestName The message type. One of the {ClientRequest.messages}.
 * @param {object?} data The data to send with the request.
 */
ClientRequest.prototype._sendRequest = function(requestName, data) {
  this._resolver._sendRequest(requestName, this._requestId, data || {});
};

/**
 * Handles the response for the given request
 * @param {String} requestName The message type. One of the {ClientRequest.messages}.
 * @param {Object} data The response data.
 */
ClientRequest.prototype._handleResponse = function(requestName, data) {
  var self = this;
  var status = data && data.status;
  var callback;

  if (requestName === ClientRequest.messages.CLOSE) {
    this._successCallback = null;
    this._errorCallback = null;
    this._requestData = null;
    this.onClose(this._requestId);
    return;
  }

  callback = this._successCallback;
  callback = typeof callback === 'function' ? callback : function() {};
  defer(callback.bind(this, data));
};

},{"spotify-deferred":248}],246:[function(require,module,exports){
(function (global){
'use strict';

var window = global.window || {};
var process = global.process;

var common = require('cosmos-common-js');
var Resolver = require('./scripts/resolver').Resolver;

var SPResolver = null;
var spResolver = null;

var hasNativeBridge = window._getSpotifyModule &&
    typeof window._getSpotifyModule === 'function' &&
    window._getSpotifyModule('bridge');

var nodeRegex = /(node)|(grunt)|(iojs)(\.exe)*$/;
var isNodeJs = process && process.title && nodeRegex.test(process.argv[0]);

if (!isNodeJs) {
  if (hasNativeBridge) {
    SPResolver = require('./env/bootstrap.native.js').NativeResolver;
    spResolver = new SPResolver(hasNativeBridge);
  } else {
    SPResolver = require('./env/bootstrap.web.js').WebResolver;
    spResolver = new SPResolver();
  }
} else {
  SPResolver = require('./env/bootstrap.mock.js').MockResolver;
  spResolver = new SPResolver();

  exports.mockResolver = {
    addHandler: spResolver.addHandler.bind(spResolver),
    removeHandler: spResolver.removeHandler.bind(spResolver),
    clearHandlers: spResolver.clearHandlers.bind(spResolver)
  };
}

exports.Resolver = Resolver;
exports.Action = common.request.Action;
exports.Request = common.request.Request;
exports.Response = common.response.Response;
exports.resolver = spResolver ? new Resolver(spResolver) : null;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./env/bootstrap.mock.js":242,"./env/bootstrap.native.js":243,"./env/bootstrap.web.js":244,"./scripts/resolver":249,"cosmos-common-js":154}],247:[function(require,module,exports){
/**
 * @file
 * Unified window messaging facility.
 *
 * This module exports two functions to the Spotify
 * namespace which allows other subsystems to handle
 * particular types of messages sent through the native
 * window.postMessage method.
 *
 * @see Spotify.addMessageHandler
 * @see Spotify.removeMessageHandler
 */
'use strict';

var POST_ROUTER_ID = 'post-router-msg-' + new Date().getTime();

var hasStructuredClone = false;

var setImmediate = setImmediate ? setImmediate : setTimeout;

var CURRENT_WINDOW_ORIGIN = undefined;

if (typeof window !== 'undefined') {
  CURRENT_WINDOW_ORIGIN = (window.location.origin ||
      window.location.protocol + '//' + window.location.hostname);

  // Hacky solution to make it work for the webplayer.
  if (!window.__forceNoStructuredClone) {
    // Check if the platform has support for structured cloning.
    //
    // In platforms where this is supported, sending a postMessage with an
    // object that contains a function will throw an error, as it is not
    // cloneable.
    try {
      window.postMessage({
        toString: function() {
          return "clone-test";
        }
      }, CURRENT_WINDOW_ORIGIN);
      hasStructuredClone = false;
    } catch(e) {
      hasStructuredClone = true;
    }
  }
}

/**
 * Storage for message handlers.
 *
 * @type {Object.<string, Spotify.Shell.MessageHandler>}
 * @private
 */
var handlers = {};


/**
 * Variable to check if the window is already listening to postMessage events
 *
 * @type {bool}
 * @private
 */
var isListening = false;


function handleImmediateMessage(data) {
  var handler = handlers[data.type];
  if (!handler) return;
  handler.fn.call(this, data);
}


/**
 * Main event handler for the window message event.
 *
 * @param {Event} event The message event object.
 * @private
 */
function handlePostMessage(event) {
  var data = event.data;
  if (!hasStructuredClone) {
    if (typeof data == 'string') {
      try {
        data = JSON.parse(data);
      } catch (e) {
        return;
      }
    } else {
      // We only expect strings.
      return;
    }
  }
  if (event.origin == CURRENT_WINDOW_ORIGIN) {
    data = data[POST_ROUTER_ID];
    if (!data) {
      // Not our data, return immediately.
      return;
    }
  }
  var handler = handlers[data.type];
  if (!handler || handler.origin != '*' && event.origin !== handler.origin) {
    return;
  }
  handler.fn.call(this, data, event);
}

/**
 * Attaches the handlePostMessage function to PostMessage events
 *
 * @private
 */
var startListening = function() {
  if (window.attachEvent && !window.addEventListener) {
    // IE8 and Below
    window.attachEvent('onmessage', handlePostMessage);
  } else if (window.attachEvent && window.addEventListener) {
    // IE9
    window.addEventListener('message', handlePostMessage, false);
  } else if (window.addEventListener) {
    // Everyone else
    window.addEventListener('message', handlePostMessage, false);
  }
};


/**
 * Adds a message handler for a particular message type.
 *
 * The message handler function will be invoked when the window receives
 * a message marked as a particular type, receiving an argument. The
 * argument will be the data payload of the event decoded from JSON.
 *
 * @param {string} type The type of the message to handle.
 * @param {function} fn The handler function.
 * @param {string} origin needed
 * @throws {Error} Thrown if the message type being handled already has
 *     a handler function.
 */
var addMessageHandler = function(type, fn, origin) {
  if (typeof window !== 'undefined' && !isListening) {
    startListening();
    isListening = true;
  }

  if (!origin) {
    origin = CURRENT_WINDOW_ORIGIN;
  }

  if (handlers[type]) {
    throw new Error('Rehandling of message "' + type + '" not allowed.');
  }
  handlers[type] = {
    fn: fn,
    origin: origin
  };
  return;
};


/**
 * Removes a message handler for a particular message type.
 *
 * @param {string} type The type of the message to remove.
 * @param {Spotify.Shell.MessageHandler} fn The handler function.
 * @return {boolean} True if the handler function was succesfully removed.
 */
var removeMessageHandler = function(type, fn) {
  if (handlers[type] && (!fn || handlers[type].fn === fn)) {
    handlers[type] = null;
    return true;
  }
  return false;
};


/**
 * Sends a message to the event handler
 *
 * @param {string} type The type of the message to remove.
 * @param {Object} data JSON object to pass to the handler
 */
var sendMessage = function(type, data, destWindow, origin) {
  data = data || {};
  data.type = type;

  if (typeof window === 'undefined') {
    return setImmediate(handleImmediateMessage.bind(null, data));
  }

  destWindow = destWindow || window;

  if (!origin) {
    origin = CURRENT_WINDOW_ORIGIN;
  }

  destWindow.postMessage(JSON.stringify(data), origin);
};

var sendLocalMessage = function(type, data) {
  data = data || {};
  data.type = type;

  if (typeof window === 'undefined') {
    return setImmediate(handleImmediateMessage.bind(null, data));
  }

  // Wrap the data in a custom object to quickly identify the message.
  var wrapper = {};
  wrapper[POST_ROUTER_ID] = data;

  window.postMessage(hasStructuredClone ?
                     wrapper :
                     JSON.stringify(wrapper), CURRENT_WINDOW_ORIGIN);
};


/**
 * Export public interface
 */
module.exports = {
  addMessageHandler: addMessageHandler,
  removeMessageHandler: removeMessageHandler,
  sendMessage: sendMessage,
  sendLocalMessage: sendLocalMessage,
  WINDOW_ORIGIN: CURRENT_WINDOW_ORIGIN
};

},{}],248:[function(require,module,exports){
/**
 * @file
 * Introduces a function called "defer" that allows functions to be
 * executed in the next available tick.
 *
 * Unlike "setTimeout", "defer" executes the function at the nearest
 * possible time without clamping.
 *
 * @see Spotify.defer
 */
'use strict';

var PostRouter = require('spotify-postrouter');


/**
 * Storage for deferred functions to be executed.
 *
 * @type {Array.<function()>}
 * @private
 */
var deferred = [];


/**
 * A bound version of the postMessage routine used to trigger deferred
 * execution.
 *
 * @type {function()}
 * @private
 */
var send = function () {
  PostRouter.sendLocalMessage('execute_deferreds');
};


/**
 * Executes the deferred functions when the window
 * receives an 'execute_deferreds' message.
 *
 * @private
 */
function executeDeferreds() {
  var fns = deferred.splice(0);
  if (!fns.length) return;
  for (var i = 0, l = fns.length; i < l; i++) {
    try {
      fns[i]();
    } finally {
      // Do nothing.
      null;
    }
  }
}

PostRouter.addMessageHandler('execute_deferreds', executeDeferreds);


/**
 * Executes the function applied at the nearest possible time without
 * clamping.
 *
 * @param {function()} fn The function to execute.
 */
var defer = function(fn) {
  var trigger = !deferred.length;
  deferred.push(fn);
  if (trigger) send();
};


/**
 * Export public interface
 */
module.exports = defer;

},{"spotify-postrouter":247}],249:[function(require,module,exports){
var common = require('cosmos-common-js');

var Request = common.request.Request;
var Action = common.request.Action;
var Response = common.response.Response;

/**
 * Checks whether a status is successful.
 *
 * We define a successful status to be something within the 200 to 299 range.
 *
 * @param {number} status The status to check.
 */
function _isSuccessStatus(status) {
  // This constitutes a successfull status.
  return (status >= 200 && status <= 299);
};


function Resolver(spResolver) {
  if (!spResolver || typeof spResolver.resolve !== 'function') {
    throw TypeError('Incorrect resolver argument');
  }

  this._resolver = spResolver;
}

/**
 * The basic, generic method of sending the requests.
 *
 * For params description:
 * @borrows Resolver#_resolve as Resolver#resolve
 */
Resolver.prototype.resolve = function(request, callback) {
  return this._resolve(request, callback);
};

/**
 * Convenience method for doing GET requests.
 * resolver.get('sp://player') is an equivalent of
 * resolver.resolve(new Request('GET', 'sp://player')).
 *
 * @param {string|Object.<string, object>} options If is a string
 * will be parsed as url. If more data is needed, object notation
 * should be used.
 *  param options.url {string} The url of the request.
 *  param options.body {object=} The request body.
 *  param options.headers {object=} The request headers.
 * @param {function(error=, object?)} callback The function
 * executed after the request has been completed.
 *
 * @return {RequestHandler} The cancellable request handler.
 */
Resolver.prototype.get = function(options, callback) {
  return this._resolveFromParams(Action.GET, options, callback);
};

/**
 * Convenience method for doing POST requests.
 * resolver.post('sp://player') is an equivalent of
 * resolver.resolve(new Request('POST', 'sp://player'))
 *
 * @see Resolver#get for params description and returned value.
 */
Resolver.prototype.post = function(options, callback) {
  return this._resolveFromParams(Action.POST, options, callback);
};

/**
 * Convenience method for doing SUB requests.
 * resolver.subscribe('sp://player') is an equivalent of
 * resolver.resolve(new Request('SUB', 'sp://player'))
 *
 * @see Resolver#get for params description and returned value.
 */
Resolver.prototype.subscribe = function(options, callback) {
  return this._resolveFromParams(Action.SUB, options, callback);
};

/**
 * Convenience method for doing PUT requests.
 * resolver.put('sp://ads/v1/settings/session') is an equivalent of
 * resolver.resolve(new Request('PUT', 'sp://ads/v1/settings/session'))
 *
 * @see Resolver#get for params description and returned value.
 */
Resolver.prototype.put = function(options, callback) {
  return this._resolveFromParams(Action.PUT, options, callback);
};

/**
 * Convenience method for doing PATCH requests.
 * resolver.patch('sp://ads/v1/settings/session') is an equivalent of
 * resolver.resolve(new Request('PATCH', 'sp://ads/v1/settings/session'))
 *
 * @see Resolver#get for params description and returned value.
 */
Resolver.prototype.patch = function(options, callback) {
  return this._resolveFromParams(Action.PATCH, options, callback);
};

/**
 * Convenience method for doing DELETE requests.
 * resolver.delete('sp://player') is an equivalent of
 * resolver.resolve(new Request('DELETE', 'sp://player'))
 *
 * @see Resolver#get for params description and returned value.
 */
Resolver.prototype.delete = function(options, callback) {
  return this._resolveFromParams(Action.DELETE, options, callback);
};

/**
 * @private
 * Sends the request to the platform specific request resolver.
 * If the request action is 'SUB' it will send subscribe request
 * In any other case it will send simple resolve request.
 *
 * @param {Cosmos.Request} request A request object.
 * @param {function(error=, object?)} callback The function
 * executed after the request has been completed.
 *
 * @return {RequestHandler} The cancellable request handler.
 */
Resolver.prototype._resolve = function(request, callback) {
  if (!callback || typeof callback !== 'function') {
    callback = function() {};
  }

  var requestHandler;

  function onSuccess(serverResponse) {
    if (!requestHandler._request) {
      return;
    }

    var response = Response.fromObject(serverResponse);
    if (!response) {
      var error = new Error(
        'Failed to parse response: ' + JSON.stringify(serverResponse));
      return callback(error);
    }

    if (_isSuccessStatus(response.getStatusCode())) {
      return callback(null, response);
    } else {
      // Extract just the initial part of the request uri. It's good to have something
      // but it is also good to avoid having everything, since that can hurt dashboards
      // that group error messages.
      var requestEndpoint = request.toJSON().uri.match(/[^\:]*(\:\/\/)?[^\/]*/)[0];
      var errorMessage = (
        response.getHeader("error") ||
        "Request to " + requestEndpoint + " failed with status code " + response.getStatusCode());
      var error = new Error(errorMessage);
      error.response = response;
      return callback(error, response);
    }
  }

  function onError(serverResponse) {
    return callback(serverResponse instanceof Error ?
      serverResponse :
      new Error('Request failed: ' + JSON.stringify(serverResponse)));
  }

  var resolveFn = request.getAction() === Action.SUB ?
      this._resolver.subscribe : this._resolver.resolve;

  var clientRequest = resolveFn.call(this._resolver, request, onSuccess, onError);

  requestHandler = new RequestHandler(clientRequest);
  return requestHandler;
};

/**
 * @private
 * Creates Request object from supplied params.
 * @param {string} method Request method. One of the Request.Action.
 * @param {string|Object.<string, object>} options If is a string
 * will be parsed as url. If more data is needed, object notation
 * should be used.
 *  param options.url {string} The url of the request.
 *  param options.body {object=} The request body.
 *  param options.headers {object=} The request headers.
 * @param {function(error=, object?)} callback The function
 * executed after the request has been completed.
 *
 * @return {RequestHandler} The cancellable request handler.
 */
Resolver.prototype._resolveFromParams = function(method, options, callback) {
  options = options || {};

  var url = typeof options === 'string' ? options : options.url;
  var headers = options.headers;
  var body = options.body;

  var request = new Request(method, url, headers, body);

  return this._resolve(request, callback);
};

/**
 * The object that wraps the clientRequest
 * in a very simple interface.
 * Separates the implementation of the ClientRequest
 * from the request handler returned by Cosmos API.
 *
 * @param {Cosmos.ClientRequest} request The object
 * representing the newly opened request to the client.
 * Usually a request will be a subscription that
 * needs a close handler.
 */
function RequestHandler(request) {
  if (!request || typeof request.close !== 'function')
    throw new TypeError('Invalid `request` argument.');

  this._request = request;
}

/**
 * Closes the request and removes the object.
 */
RequestHandler.prototype.cancel = function() {
  if (this._request) {
    this._request.close();
    this._request = null;
  }
};

exports.Resolver = Resolver;

},{"cosmos-common-js":154}],250:[function(require,module,exports){
'use strict';

/**
 * The Base62 Converter
 *
 * @class Base62
 * @constructor
 *
 */

var digits = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
var invHexDigits = {};
var invDigits = {};

for (var i = 0; i < digits.length; ++i) { invDigits[digits[i]] = i; }
for (var i = 0; i < 16; ++i) { invHexDigits['0123456789abcdef'[i]] = i; }
for (var i = 0; i < 16; ++i) { invHexDigits['0123456789ABCDEF'[i]] = i; }

/**
 * lhs *= rhs
 * @private
 */
function mul(lhs, rhs, base) {
  var rest = 0;
  for (var i = 0; i < lhs.length; ++i) {
    var tmp = lhs[i] * rhs + rest;
    lhs[i] = tmp % base;
    rest = ~~(tmp / base);
  }
  while (rest) {
    lhs.push(rest % base);
    rest = ~~(rest / base);
  }
}

/**
 * acc += lhs * rhs
 * @private
 */
function madd(acc, lhs, rhs, base) {
  var rest = 0;
  for (var i = 0; i < lhs.length; ++i) {
    var tmp = ~~acc[i] + lhs[i] * rhs + rest;
    acc[i] = tmp % base;
    rest = ~~(tmp / base);
  }
  while (rest) {
    var tmp = ~~acc[i] + rest;
    acc[i] = tmp % base;
    rest = ~~(tmp / base);
    ++i;
  }
}

/**
 * Change base
 * @private
 */
function convert(data, fromBase, toBase) {
  var r = [0];
  var b = [1];
  for (var i = 0; i < data.length; ++i) {
    madd(r, b, data[i], toBase);
    mul(b, fromBase, toBase);
  }
  return r;
}

/**
 * Decode to
 * @private
 */
function mapr(data, mapping) {
  for (var i = 0, r = []; i < data.length; ++i) { r.push(mapping[data[i]]); }
  return r.reverse();
}

/**
 * Pad with 0s
 * @private
 */
function pad(data, length) {
  while (data.length < length) { data.push(0); }
  return data;
}

module.exports = {

  /**
   * Converts from array of bytes to base62 encoded string.
   *
   * @public
   * @name Spotify.Utils.Base62#fromBytes
   * @function
   * @param {Array.<number>} data Array of byte numbers.
   * @param {?number} length Do zeropadding until at least this length.
   * @return {string} Base62 encoded string.
  **/
  fromBytes: function(data, length) {
    var r = convert(data.slice(0).reverse(), 256, 62);
    return mapr(pad(r, length), digits).join('');
  },

  /**
   * Converts from base62 encoded string to array of bytes
   *
   * @public
   * @name Spotify.Utils.Base62#toBytes
   * @function
   * @param {string} str Base62 encoded string.
   * @param {?number} length Do zeropadding until at least this length.
   * @return {Array.<number>} Array of byte numbers.
  **/
  toBytes: function(str, length) {
    var r = convert(mapr(str, invDigits), 62, 256);
    return pad(r, length).reverse();
  },

  /**
   * Converts from base62 encoded string to hex encoded string
   *
   * @public
   * @name Spotify.Utils.Base62#toHex
   * @function
   * @param {string} str Base62 encoded string.
   * @param {?number} length Do zeropadding until at least this length.
   * @return {string} Hex encoded string.
  **/
  toHex: function(str, length) {
    var r = convert(mapr(str, invDigits), 62, 16);
    return mapr(pad(r, length), digits).join('');
  },

  /**
   * Converts from hex encoded strign to base62 encoded string
   *
   * @public
   * @name Spotify.Utils.Base62#fromHex
   * @function
   * @param {string} str Hex encoded string.
   * @param {?number} length Do zeropadding until at least this length.
   * @return {string} Base62 encoded string.
  **/
  fromHex: function(str, length) {
    var r = convert(mapr(str, invHexDigits), 16, 62);
    return mapr(pad(r, length), digits).join('');
  }

};

},{}],251:[function(require,module,exports){
(function() {
  /**
   * @file
   * Introduces a function called "defer" that allows functions to be
   * executed in the next available tick.
   *
   * Unlike "setTimeout", "defer" executes the function at the nearest
   * possible time without clamping.
   *
   * @see Spotify.defer
   */
  'use strict';

  var hasWindow = typeof window != 'undefined';
  var hasDefineProperty = typeof Object.defineProperty == 'function';

  if (hasWindow && window.__modDefFn) {
    // If deferred has been attached to the global scope
    module.exports = window.__modDefFn;
    return;
  }

  /**
   * Storage for deferred functions to be executed.
   *
   * @type {Array.<function()>}
   * @private
   */
  var deferred = [];


  /**
   * A bound version of the postMessage routine used to trigger deferred
   * execution.
   *
   * @type {function()}
   * @private
   */
  var send;
  var origin;

  if (hasWindow && window.postMessage) {
    origin = (window.location.origin ||
          window.location.protocol + '//' + window.location.hostname);
    send = window.postMessage.bind(window, '@execute_deferreds', origin);
    if (!window.__hasDeferredHandler) {
      if (hasDefineProperty) {
        Object.defineProperty(window, '__hasDeferredHandler', {value: 1});
      } else {
        window.__hasDeferredHandler = 1;
      }
      var handler = function(e) {
        if (e.origin != origin && e.data != '@execute_deferreds') {
          return;
        }
        executeDeferreds();
      };
      if (window.addEventListener) {
        window.addEventListener('message', handler);
      } else {
        window.attachEvent('onmessage', handler);
      }
    }
  } else if (typeof setImmediate != 'undefined') {
    send = setImmediate.bind(null, executeDeferreds);
  } else {
    send = setTimeout.bind(null, executeDeferreds, 10);
  }


  /**
   * Executes the deferred functions when the window
   * receives an 'execute_deferreds' message.
   *
   * @private
   */
  function executeDeferreds() {
    var fns = deferred.splice(0);
    if (!fns.length) return;
    for (var i = 0, l = fns.length; i < l; i++) {
      try {
        fns[i]();
      } finally {
        // Do nothing.
        null;
      }
    }
  }


  /**
   * Executes the function applied at the nearest possible time without
   * clamping.
   *
   * @param {function()} fn The function to execute.
   */
  var defer = function(fn) {
    var trigger = !deferred.length;
    deferred.push(fn);
    if (trigger) send();
  };

  if (hasWindow && !window.__modDefFn) {
    if (hasDefineProperty) {
      Object.defineProperty(window, '__modDefFn', {value: defer});
    } else {
      window.__modDefFn = defer;
    }
  }

  /**
   * Export public interface
   */
  module.exports = defer;

})();

},{}],252:[function(require,module,exports){
/**
 * @module spotify-eventemitter
 */
'use strict';

/**
 * @private
 */
var _defer = require('spotify-deferred');

/**
 * The event handlers.
 *
 * @typedef {Array.<function>}
 * @private
 */
var EventHandlers;

/**
 * Represents an Event.
 *
 * **NOTE**: The Event class is an internal class: you cannot instantiate it
 * directly. Instead, you should use the provided
 * {@link module:spotify-eventemitter.createEvent} function.
 *
 * @constructor
 * @param {string} type The type name of the event object.
 * @param {Object} props An object that will be added as properties of the
 *     event object.
 * @see {@link module:spotify-eventemitter.createEvent}
 */
function Event(type, props) {
  /**
   * The type of the event.
   *
   * @type {string}
   */
  this.type = type;

  /**
   * A flag for whether preventDefault was called.
   *
   * @type {boolean}
   * @private
   */
  this._prevented = false;

  /**
   * A flag for whether stopPropagation was called
   *
   * @type {boolean}
   * @private
   */
  this._stopped = false;

  /**
   * A flag for whether stopImmediatePropagation was called.
   *
   * @type {boolean}
   * @private
   */
  this._immediateStopped = false;

  if (props) {
    for (var key in props) {
      if (key == 'type') {
        continue;
      }
      this[key] = props[key];
    }
  }
}

/**
 * Prevents the default operation for the event.
 */
Event.prototype.preventDefault = function() {
  this._prevented = true;
};

/**
 * Returns whether preventDefault was called on the event.
 *
 * @return {boolean} True if preventDefault was called, false otherwise.
 */
Event.prototype.isDefaultPrevented = function() {
  return this._prevented;
};

/**
 * Stops the propagation of the event.
 */
Event.prototype.stopPropagation = function() {
  this._stopped = true;
};

/**
 * Returns whether stopPropagation was called on the event.
 *
 * @return {boolean} True if stopPropagation was called, false otherwise.
 */
Event.prototype.isPropagationStopped = function() {
  return this._stopped;
};

/**
 * Stops the immediate propagation of the event.
 *
 * Handlers added after any event handler calling this method will not receive
 * the event.
 */
Event.prototype.stopImmediatePropagation = function() {
  this._immediateStopped = true;
};

/**
 * Returns whether stopImmediatePropagation was called on the event.
 *
 * @return {boolean} True if stopImmediatePropagation was called, false
 *     otherwise.
 */
Event.prototype.isImmediatePropagationStopped = function() {
  return this._immediateStopped;
};

/**
 * An EventEmitter is an object that can be listened to for events.
 *
 * Instances of this class are not usually used directly; instead, a class that
 * needs EventEmitter functionality would inherit from the EventEmitter class
 * so that it's instances can use events.
 *
 * @constructor
 * @alias module:spotify-eventemitter
 *
 * @example <caption>Direct usage</caption>
 * var EventEmitter = require('spotify-eventemitter');
 * var emitter = new EventEmitter();
 * emitter.addListener('someEvent', function() {
 *     console.log('someEvent fired!');
 * });
 * emitter.emit('someEvent');
 * @example <caption>Inheritance</caption>
 * var EventEmitter = require('spotify-eventemitter');
 * var inherit = require('spotify-inherit/inherit');
 *
 * function MyClass() {
 *   EventEmitter.call(this);
 * }
 * inherit(MyClass, EventEmitter);
 *
 * var instance = new MyClass();
 * instance.addListener('someEvent', function() {
 *     console.log('someEvent fired!');
 * });
 * instance.emit('someEvent');
 */
function EventEmitter() {
  /**
   * A map of event names to event handlers.
   *
   * @type {Object.<string, module:spotify-eventemitter~EventHandlers>}
   * @private
   */
  this._listenerMap;
}

/**
 * Creates a new Event object.
 *
 * @param {string} type The type name of the event.
 * @param {Object=} opt_params An object containing properties for the new event
 *     object.
 * @return {module:spotify-eventemitter~Event} The new event object.
 */
EventEmitter.createEvent = function(type, opt_params) {
  return new Event(type, opt_params);
};

/**
 * Adds an event listener to the emitter.
 *
 * This method is idempotent: calling it multiple times using the same type
 * and listener arguments will only set the listener once. This behaviour is
 * done to prevent accidental additions of the same event listener.
 *
 * @param {string} type The type of event to listen to.
 * @param {function} listener A function to be called when the emitter fires
 *     the event specified in the type.
 * @return {module:spotify-eventemitter} The event emitter.
 */
EventEmitter.prototype.addListener = function(type, listener) {
  var _listenerMap = this._listenerMap || (this._listenerMap = {});
  var listeners = _listenerMap[type] || (_listenerMap[type] = []);
  if (listeners.indexOf(listener) != -1) {
    // Handler already added, return quickly.
    return this;
  }
  listeners.push(listener);
  return this;
};

/**
 * Adds multiple event listeners to the emitter.
 *
 * @param {Object.<string, function>} eventListeners An object, the keys of
 *     which correspond to the name of events to listen to, and the value of
 *     each of these keys should be a function that would be added as the
 *     listener for that event.
 * @return {module:spotify-eventemitter} The event emitter.
 */
EventEmitter.prototype.addListeners = function(eventListeners) {
  for (var type in eventListeners) {
    this.addListener(type, eventListeners[type]);
  }
  return this;
};

/**
 * Adds a "once" event listener to the emitter, which will be removed right
 * after it has been fired.
 *
 * In order to achieve the "once" behaviour, the listener argument passed to
 * this method is wrapped in a function, which is then returned by the method.
 *
 * Because of this wrapping, this method is not idempotent: calling it multiple
 * times with the same type and listener arguments will result to multiple
 * event listeners attached.
 *
 * @param {string} type The type of event to listen to.
 * @param {function} listener A function to be called when the emitter fires
 *     the event specified in the type and then automatically removed.
 * @return {function} The function used to wrap the listener function argument.
 *     This function can be used as an argument to removeEvent.
 */
EventEmitter.prototype.addOnceListener = function(type, listener) {
  var wrapper = function() {
    this.removeListener(type, wrapper);
    return listener.apply(this, arguments);
  };
  this.addListener(type, wrapper);
  return wrapper;
};

/**
 * Removes an event listener from the emitter.
 *
 * @param {string} type The type of event to remove.
 * @param {function} listener The listener function to remove. This must be a
 *     function that was added previously using addEvent.
 * @return {module:spotify-eventemitter} The event emitter.
 */
EventEmitter.prototype.removeListener = function(type, listener) {
  var _listenerMap = this._listenerMap;
  var listeners = _listenerMap && _listenerMap[type];
  if (!listeners) {
    return this;
  }
  var index = listeners.indexOf(listener);
  if (index == -1) {
    return this;
  }
  listeners.splice(index, 1);
  if (!listeners.length) {
    _listenerMap[type] = null;
  }
  return this;
};

/**
 * Removes all event listeners from the emitter for a particular type.
 *
 * @param {string} type The event type to remove.
 * @return {module:spotify-eventemitter} The event emitter.
 */
EventEmitter.prototype.removeAllListeners = function(type) {
  var _listenerMap = this._listenerMap;
  if (!_listenerMap) {
    return this;
  }
  _listenerMap[type] = null;
  return this;
};

/**
 * Removes multiple event listeners from the emitter.
 *
 * @param {Object.<string, function>} eventListeners An object, the keys of
 *     which correspond to the name of events to listen to, and the value of
 *     each of these keys should be a function that would be added as the
 *     listener for that event.
 * @return {module:spotify-eventemitter} The event emitter.
 */
EventEmitter.prototype.removeListeners = function(eventListeners) {
  for (var type in eventListeners) {
    this.removeListener(type, eventListeners[type]);
  }
  return this;
};

/**
 * Creates and emits an event on the emitter.
 *
 * This method invokes all the added event listeners of the `type` provided in
 * the order they were added, passing in a new Event object created using the
 * provided `type` and `opt_params` arguments.
 *
 * This method emits events asynchronously: the listeners are not called until
 * the next run loop.
 *
 * @param {string} type The type name of the event to emit.
 * @param {Object=} opt_params An object containing parameters for the Event
 *     object.
 * @return {module:spotify-eventemitter~Event} The Event object that was
 *     created.
 */
EventEmitter.prototype.emit = function(type, opt_params) {
  var event = new Event(type, opt_params);
  _defer(function() {
    this.emitEventSync(event);
  }.bind(this));
  return event;
};

/**
 * Emits an event on the emitter.
 *
 * This method invokes all the added event listeners of the `type` of the 
 * `event` provided in the order they were added, passing in the `event` as an
 * argument.
 *
 * This method emits events asynchronously: the listeners are not called until
 * the next run loop.
 *
 * @param {module:spotify-eventemitter~Event} event The Event object.
 * @return {module:spotify-eventemitter~Event} The Event object that was passed.
 */
EventEmitter.prototype.emitEvent = function(event) {
  _defer(function() {
    this.emitEventSync(event);
  }.bind(this));
  return event;
};

/**
 * Creates and synchronously emits an event on the emitter.
 *
 * This method invokes all the added event listeners of the `type` provided in
 * the order they were added, passing in a new Event object created using the
 * provided `type` and `opt_params` arguments.
 *
 * @param {string} type The type name of event to emit.
 * @param {Object=} opt_params An object containing parameters for the event
 *     object.
 * @return {module:spotify-eventemitter~Event} The Event object that was
 *     created.
 */
EventEmitter.prototype.emitSync = function(type, opt_params) {
  var event = new Event(type, opt_params);
  this.emitEventSync(event);
  return event;
};

/**
 * Synchronously emits an event on the emitter.
 *
 * This method invokes all the added event listeners of the `type` of the
 * `event` provided in the order they were added, passing in the `event` as an
 * argument.
 *
 * @param {module:spotify-eventemitter~Event} event The Event object.
 * @return {module:spotify-eventemitter~Event} The Event object that was passed.
 */
EventEmitter.prototype.emitEventSync = function(event) {
  var type = event.type;
  var _listenerMap = this._listenerMap;
  var listeners = _listenerMap && _listenerMap[type];
  if (!listeners || !listeners.length) {
    return event;
  }
  listeners = listeners.slice(0);
  for (var i = 0, l = listeners.length; i < l; i++) {
    listeners[i].call(this, event);
    if (event.isImmediatePropagationStopped()) {
      break;
    }
  }
  return event;
};

// DEPRECATED METHODS:

/**
 * Adds an event listener to the emitter.
 *
 * **NOTE**: This method has been deprecated in favor of
 * {@link module:spotify-eventemitter#addListener}.
 *
 * This method is idempotent: calling it multiple times using the same type
 * and listener arguments will only set the listener once. This behaviour is
 * done to prevent accidental additions of the same event listener.
 *
 * @deprecated since v2.0.0.
 * @param {string} type The type of event to listen to.
 * @param {function} listener A function to be called when the emitter fires
 *     the event specified in the type.
 * @return {module:spotify-eventemitter} The event emitter.
 * @see {@link module:spotify-eventemitter#addListener}
 */
EventEmitter.prototype.addEvent = function(type, listener) {
  return this.addListener(type, listener);
};

/**
 * Adds multiple event listeners to the emitter.
 *
 * **NOTE**: This method has been deprecated in favor of
 * {@link module:spotify-eventemitter#addListeners}.
 *
 * @deprecated since v2.0.0.
 * @param {Object.<string, function>} eventListeners An object, the keys of
 *     which correspond to the name of events to listen to, and the value of
 *     each of these keys should be a function that would be added as the
 *     listener for that event.
 * @return {module:spotify-eventemitter} The event emitter.
 * @see {@link module:spotify-eventemitter#addListeners}
 */
EventEmitter.prototype.addEvents = function(eventListeners) {
  return this.addListeners(eventListeners);
};

/**
 * Adds a "once" event listener to the emitter, which will be removed right
 * after it has been fired.
 *
 * **NOTE**: This method has been deprecated in favor of
 * {@link module:spotify-eventemitter#addOnceListener}.
 *
 * In order to achieve the "once" behaviour, the listener argument passed to
 * this method is wrapped in a function, which is then returned by the method.
 *
 * Because of this wrapping, this method is not idempotent: calling it multiple
 * times with the same type and listener arguments will result to multiple
 * event listeners attached.
 *
 * @deprecated since v2.0.0.
 * @param {string} type The type of event to listen to.
 * @param {function} listener A function to be called when the emitter fires
 *     the event specified in the type and then automatically removed.
 * @return {function} The function used to wrap the listener function argument.
 *     This function can be used as an argument to removeEvent.
 * @see {@link module:spotify-eventemitter#addOnceListener}
 */
EventEmitter.prototype.addOnceEvent = function(type, listener) {
  return this.addOnceListener(type, listener);
};

/**
 * Removes an event listener from the emitter.
 *
 * **NOTE**: This method has been deprecated in favor of
 * {@link module:spotify-eventemitter#removeListener}.
 *
 * @deprecated since v2.0.0.
 * @param {string} type The type of event to remove.
 * @param {function} listener The listener function to remove. This must be a
 *     function that was added previously using addEvent.
 * @return {module:spotify-eventemitter} The event emitter.
 * @see {@link module:spotify-eventemitter#removeListener}
 */
EventEmitter.prototype.removeEvent = function(type, listener) {
  return this.removeListener(type, listener);
};

/**
 * Removes multiple event listeners from the emitter.
 *
 * **NOTE**: This method has been deprecated in favor of
 * {@link module:spotify-eventemitter#removeListeners}.
 *
 * @deprecated since v2.0.0.
 * @param {Object.<string, function>} events An object, the keys of which
 *     correspond to the name of events to remove, and the value of each of
 *     these keys should be a function that would be removed as a listener.
 * @return {module:spotify-eventemitter} The event emitter.
 * @see {@link module:spotify-eventemitter#removeListeners}
 */
EventEmitter.prototype.removeEvents = function(eventListeners) {
  return this.removeListeners(eventListeners);
};

/**
 * Fires an event on the emitter, optionally passing arguments to the listeners.
 *
 * **NOTE**: This method has been deprecated in favor of
 * {@link module:spotify-eventemitter#emit}.
 *
 * This method fire events asynchronously: the listeners are not called until
 * the next run loop. A third boolean parameter can be passed to change this
 * behaviour.
 *
 * @deprecated since v2.0.0.
 * @param {string} type The type of event to fire.
 * @param {Array.<*>=} opt_args A set of objects that would be passed to the
 *     event listeners as arguments.
 * @param {boolean=} opt_priority Passing true will fire the event synchronously.
 * @return {module:spotify-eventemitter} The event emitter.
 * @see {@link module:spotify-eventemitter#emit}
 */
EventEmitter.prototype.fireEvent = function(type, opt_args, opt_priority) {
  if (opt_priority) {
    this.fireEventSync(type, opt_args);
  } else {
    var self = this;
    _defer(function() { self.fireEventSync(type, opt_args); });
  }
  return this;
};

/**
 * Fires an event on the emitter synchronously, optionally passing arguments to
 * the listeners.
 *
 * **NOTE**: This method has been deprecated in favor of
 * {@link module:spotify-eventemitter#emitSync}.
 *
 * @deprecated since v2.0.0.
 * @param {string} type The type of event to fire.
 * @param {Array.<*>=} opt_args A set of objects that would be passed to the
 *     event listeners as arguments.
 * @return {module:spotify-eventemitter} The event emitter.
 * @see {@link module:spotify-eventemitter#emitSync}
 */
EventEmitter.prototype.fireEventSync = function(type, opt_args) {
  var self = this;
  var events = this._listenerMap && this._listenerMap[type];
  if (!events || !events.length) return this;
  events = events.slice(0);
  var i, l;
  if (!opt_args) {
    for (i = 0, l = events.length; i < l; i++) {
      events[i].call(self);
    }
  } else {
    if (!Array.isArray(opt_args)) {
      opt_args = [opt_args];
    }
    for (i = 0, l = events.length; i < l; i++) {
      events[i].apply(self, opt_args);
    }
  }
  return this;
};

/**
 * Adds an event listener to the emitter.
 *
 * **NOTE**: This method has been deprecated in favor of
 * {@link module:spotify-eventemitter#addListener}.
 *
 * This method is idempotent: calling it multiple times using the same type
 * and listener arguments will only set the listener once. This behaviour is
 * done to prevent accidental additions of the same event listener.
 *
 * @deprecated since v2.0.0.
 * @param {string} type The type of event to listen to.
 * @param {function} listener A function to be called when the emitter fires
 *     the event specified in the type.
 * @return {module:spotify-eventemitter} The event emitter.
 * @see {@link module:spotify-eventemitter#addListener}
 */
EventEmitter.prototype.on = function(type, listener) {
  return this.addEvent(type, listener);
};

/**
 * Adds a "once" event listener to the emitter, which will be removed right
 * after it has been fired.
 *
 * **NOTE**: This method has been deprecated in favor of
 * {@link module:spotify-eventemitter#addOnceListener}.
 *
 * In order to achieve the "once" behaviour, the listener argument passed to
 * this method is wrapped in a function, which is then returned by the method.
 *
 * Because of this wrapping, this method is not idempotent: calling it multiple
 * times with the same type and listener arguments will result to multiple
 * event listeners attached.
 *
 * @deprecated since v2.0.0.
 * @param {string} type The type of event to listen to.
 * @param {function} listener A function to be called when the emitter fires
 *     the event specified in the type and then automatically removed.
 * @return {function} The function used to wrap the listener function argument.
 *     This function can be used as an argument to removeEvent.
 * @see {@link module:spotify-eventemitter#addOnceListener}
 */
EventEmitter.prototype.once = function(type, listener) {
  return this.addOnceEvent(type, listener);
};

/**
 * Removes an event listener or all event listeners from the emitter.
 *
 * **NOTE**: This method has been deprecated in favor of
 * {@link module:spotify-eventemitter#removeListener}.
 *
 * @deprecated since v2.0.0.
 * @param {string} type The type of event to remove.
 * @param {function=} opt_listener The listener function to remove. This must be
 *     a function that was added previously using addEvent. If this parameter is
 *     not given, all event listeners of the corresponding `type` argument will
 *     be removed.
 * @return {module:spotify-eventemitter} The event emitter.
 * @see {@link module:spotify-eventemitter#removeListener}
 * @see {@link module:spotify-eventemitter#removeListeners}
 */
EventEmitter.prototype.off = function(type, opt_listener) {
  if (typeof opt_listener === 'function') {
    return this.removeEvent(type, opt_listener);
  }
  // if no listener set, remove all the listeners from the event
  this._listenerMap[type] = null;
  return this;
};

/**
 * Exporting
 */
module.exports = EventEmitter;

},{"spotify-deferred":251}],253:[function(require,module,exports){
'use strict';

/**
 * Function to add properties to an object
 * @param {Object} obj The input object
 * @param {Object} args The objects which are going to be injected
 * @return {Object} The extended object
 */
var extend = function(obj, args) {
  var source;

  for (var i = 1; i < arguments.length; i++) {
    source = arguments[i];
    if (source) {
      for (var prop in source) {
        if (source.hasOwnProperty(prop)) {
          obj[prop] = source[prop];
        }
      }
    }
  }
  return obj;
};


/**
 * Export public interface
 */
module.exports = extend;

},{}],254:[function(require,module,exports){
'use strict';

module.exports = {
  inherit: require('./inherit'),
  extend: require('./extend')
};

},{"./extend":253,"./inherit":255}],255:[function(require,module,exports){
'use strict';

/**
 * Makes a class inherit from a superclass' prototype indirectly.
 *
 * @param {Spotify.ClassLike} Sub The class that will inherit.
 * @param {Spotify.ClassLike} Super The class to inherit from.
 */
var inherit = function(Sub, Super) {
  var superProto = Super.prototype;
  function Superclass() {}
  Superclass.prototype = Sub._super = superProto;
  Superclass.prototype.constructor = Super;
  Sub.prototype = new Superclass();
};


/**
 * Export public interface
 */
module.exports = inherit;

},{}],256:[function(require,module,exports){
'use strict';

/**
 * @private
 */
var Base62 = require('spotify-crypto/src/base62');

/**
 * The URI prefix for URIs.
 *
 * @const
 * @private
 */
var URI_PREFIX = 'spotify:';

/**
 * The URL prefix for Play.
 *
 * @const
 * @private
 */
var PLAY_HTTP_PREFIX = 'http://play.spotify.com/';

/**
 * The HTTPS URL prefix for Play.
 *
 * @const
 * @private
 */
var PLAY_HTTPS_PREFIX = 'https://play.spotify.com/';

/**
 * The URL prefix for Open.
 *
 * @const
 * @private
 */
var OPEN_HTTP_PREFIX = 'http://open.spotify.com/';

/**
 * The HTTPS URL prefix for Open.
 *
 * @const
 * @private
 */
var OPEN_HTTPS_PREFIX = 'https://open.spotify.com/';

var ERROR_INVALID = new TypeError('Invalid Spotify URI!');
var ERROR_NOT_IMPLEMENTED = new TypeError('Not implemented!');


/**
 * The format for the URI to parse.
 *
 * @enum {number}
 * @private
 */
var Format = {
  URI: 0,
  URL: 1
};

/**
 * Represents the result of a URI splitting operation.
 *
 * @typedef {{
 *    format: Format,
 *    components: Array.<string>
 * }}
 * @see _splitIntoComponents
 * @private
 */
var SplittedURI;

/**
 * Split an string URI or HTTP/HTTPS URL into components, skipping the prefix.
 *
 * @param {string} str A string URI to split.
 * @return {SplittedURI} The parsed URI.
 * @private
 */
var _splitIntoComponents = function(str) {
  var components;
  var format;
  var anchor;

  var hashSplit = str.split('#');

  if (hashSplit.length > 1) {
    // first token
    str = hashSplit.shift();
    // last token
    anchor = hashSplit.pop();
  }

  if (str.indexOf(URI_PREFIX) === 0) {
    components = str.slice(URI_PREFIX.length).split(':');
    format = Format.URI;
  } else {
    // For HTTP URLs, ignore any query string argument
    str = str.split('?')[0];

    if (str.indexOf(PLAY_HTTP_PREFIX) === 0) {
      components = str.slice(PLAY_HTTP_PREFIX.length).split('/');
    } else if (str.indexOf(PLAY_HTTPS_PREFIX) === 0) {
      components = str.slice(PLAY_HTTPS_PREFIX.length).split('/');
    } else if (str.indexOf(OPEN_HTTP_PREFIX) === 0) {
      components = str.slice(OPEN_HTTP_PREFIX.length).split('/');
    } else if (str.indexOf(OPEN_HTTPS_PREFIX) === 0) {
      components = str.slice(OPEN_HTTPS_PREFIX.length).split('/');
    } else {
      throw ERROR_INVALID;
    }
    format = Format.URL;
  }

  if (anchor) {
    components.push(anchor);
  }

  return {
    format: format,
    components: components
  };
};

/**
 * Encodes a component according to a format.
 *
 * @param {string} component A component string.
 * @param {Format} format A format.
 * @return {string} An encoded component string.
 * @private
 */
var _encodeComponent = function(component, format) {
  component = encodeURIComponent(component);
  if (format === Format.URI) {
    component = component.replace(/%20/g, '+');
  }

  // encode characters that are not encoded by default by encodeURIComponent
  // but that the Spotify URI spec encodes: !'*()
  component = component.replace(/[!'()]/g, escape);
  component = component.replace(/\*/g, '%2A');

  return component;
};

/**
 * Decodes a component according to a format.
 *
 * @param {string} component An encoded component string.
 * @param {Format} format A format.
 * @return {string} An decoded component string.
 * @private
 */
var _decodeComponent = function(component, format) {
  var part = format == Format.URI ? component.replace(/\+/g, '%20') : component;
  return decodeURIComponent(part);
};

/**
 * Returns the components of a URI as an array.
 *
 * @param {URI} uri A uri.
 * @param {Format} format The output format.
 * @return {Array.<string>} An array of uri components.
 * @private
 */
var _getComponents = function(uri, format) {
  var base62;
  if (uri.id) {
    base62 = uri._base62Id;
  }

  var components;
  var i;
  var len;
  switch (uri.type) {
    case URI.Type.ALBUM:
      components = [URI.Type.ALBUM, base62];
      if (uri.disc) {
        components.push(uri.disc);
      }
      return components;
    case URI.Type.AD:
      return [URI.Type.AD, uri._base62Id];
    case URI.Type.ARTIST:
      return [URI.Type.ARTIST, base62];
    case URI.Type.ARTIST_TOPLIST:
      return [URI.Type.ARTIST, base62, URI.Type.TOP, uri.toplist];
    case URI.Type.SEARCH:
      return [URI.Type.SEARCH, _encodeComponent(uri.query, format)];
    case URI.Type.TRACK:
      if (uri.anchor) {
        base62 += '#' + uri.anchor;
      }
      return [URI.Type.TRACK, base62];
    case URI.Type.TRACKSET:
      var trackIds = [];
      for (i = 0, len = uri.tracks.length; i < len; i++) {
        trackIds.push(uri.tracks[i]._base62Id);
      }
      trackIds = [trackIds.join(',')];
      // Index can be 0 sometimes (required for trackset)
      if (uri.index !== null) {
        trackIds.push('#', uri.index);
      }
      return [URI.Type.TRACKSET, _encodeComponent(uri.name)].concat(trackIds);
    case URI.Type.FACEBOOK:
      return [URI.Type.USER, URI.Type.FACEBOOK, uri.uid];
    case URI.Type.AUDIO_FILE:
      return [URI.Type.AUDIO_FILE, uri.extension, uri._base62Id];
    case URI.Type.FOLDER:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.FOLDER, uri._base62Id];
    case URI.Type.FOLLOWERS:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.FOLLOWERS];
    case URI.Type.FOLLOWING:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.FOLLOWING];
    case URI.Type.PLAYLIST:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.PLAYLIST, base62];
    case URI.Type.STARRED:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.STARRED];
    case URI.Type.TEMP_PLAYLIST:
      return [URI.Type.TEMP_PLAYLIST, uri.origin, uri.data];
    case URI.Type.CONTEXT_GROUP:
      return [URI.Type.CONTEXT_GROUP, uri.origin, uri.name];
    case URI.Type.USER_TOPLIST:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.TOP, uri.toplist];
    // Legacy Toplist
    case URI.Type.USER_TOP_TRACKS:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.TOPLIST];
    case URI.Type.TOPLIST:
      return [URI.Type.TOP, uri.toplist].concat(uri.global ? [URI.Type.GLOBAL] : ['country', uri.country]);
    case URI.Type.INBOX:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.INBOX];
    case URI.Type.ROOTLIST:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.ROOTLIST];
    case URI.Type.PUBLISHED_ROOTLIST:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.PUBLISHED_ROOTLIST];
    case URI.Type.COLLECTION_TRACK_LIST:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.COLLECTION_TRACK_LIST, base62];
    case URI.Type.PROFILE:
      if (uri.args && uri.args.length > 0)
        return [URI.Type.USER, _encodeComponent(uri.username, format)].concat(uri.args);
      return [URI.Type.USER, _encodeComponent(uri.username, format)];
    case URI.Type.LOCAL_ARTIST:
      return [URI.Type.LOCAL, _encodeComponent(uri.artist, format)];
    case URI.Type.LOCAL_ALBUM:
      return [URI.Type.LOCAL, _encodeComponent(uri.artist, format), _encodeComponent(uri.album, format)];
    case URI.Type.LOCAL:
      return [URI.Type.LOCAL,
        _encodeComponent(uri.artist, format),
        _encodeComponent(uri.album, format),
        _encodeComponent(uri.track, format),
        uri.duration];
    case URI.Type.LIBRARY:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.LIBRARY].concat(uri.category ? [uri.category] : []);
    case URI.Type.IMAGE:
      return [URI.Type.IMAGE, uri._base62Id];
    case URI.Type.MOSAIC:
      components = uri.ids.slice(0);
      components.unshift(URI.Type.MOSAIC);
      return components;
    case URI.Type.RADIO:
      return [URI.Type.RADIO, uri.args];
    case URI.Type.SPECIAL:
      components = [URI.Type.SPECIAL];
      var args = uri.args || [];
      for (i = 0, len = args.length; i < len; ++i)
        components.push(_encodeComponent(args[i], format));
      return components;
    case URI.Type.STATION:
      components = [URI.Type.STATION];
      var args = uri.args || [];
      for (i = 0, len = args.length; i < len; i++) {
        components.push(_encodeComponent(args[i], format));
      }
      return components;
    case URI.Type.APPLICATION:
      components = [URI.Type.APP, uri._base62Id];
      var args = uri.args || [];
      for (i = 0, len = args.length; i < len; ++i)
        components.push(_encodeComponent(args[i], format));
      return components;
    case URI.Type.COLLECTION_ALBUM:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.COLLECTION, URI.Type.ALBUM, base62];
    case URI.Type.COLLECTION_MISSING_ALBUM:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.COLLECTION, URI.Type.ALBUM, base62, 'missing'];
    case URI.Type.COLLECTION_ARTIST:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.COLLECTION, URI.Type.ARTIST, base62];
    case URI.Type.COLLECTION:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.COLLECTION].concat(uri.category ? [uri.category] : []);
    case URI.Type.EPISODE:
      return [URI.Type.EPISODE, base62];
    default:
      throw ERROR_INVALID;
  }
};

/**
 * Parses the components of a URI into a real URI object.
 *
 * @param {Array.<string>} components The components of the URI as a string
 *     array.
 * @param {Format} format The format of the source string.
 * @return {URI} The URI object.
 * @private
 */
var _parseFromComponents = function(components, format) {
  var _current = 0;

  var _getNextComponent = function() {
    return components[_current++];
  };

  var _getIdComponent = function() {
    var component = _getNextComponent();

    if (component.length > 22) {
      throw new Error('Invalid ID');
    }
    return component;
  };

  var _getRemainingComponents = function() {
    return components.slice(_current);
  };

  var _getRemainingString = function() {
    var separator = (format == Format.URI) ? ':' : '/';
    return components.slice(_current).join(separator);
  };

  var part = _getNextComponent();
  var id;
  var i;
  var len;

  switch (part) {
    case URI.Type.ALBUM:
      return URI.albumURI(_getIdComponent(), parseInt(_getNextComponent(), 10));
    case URI.Type.AD:
      return URI.adURI(_getNextComponent());
    case URI.Type.ARTIST:
      id = _getIdComponent();
      if (_getNextComponent() == URI.Type.TOP) {
        return URI.artistToplistURI(id, _getNextComponent());
      } else {
        return URI.artistURI(id);
      }
    case URI.Type.AUDIO_FILE:
      return URI.audioFileURI(_getNextComponent(), _getNextComponent());
    case URI.Type.TEMP_PLAYLIST:
      return URI.temporaryPlaylistURI(_getNextComponent(), _getRemainingString());
    case URI.Type.SEARCH:
      return URI.searchURI(_decodeComponent(_getRemainingString(), format));
    case URI.Type.TRACK:
      return URI.trackURI(_getIdComponent(), _getNextComponent());
    case URI.Type.TRACKSET:
      var name = _decodeComponent(_getNextComponent());
      var tracksArray = _getNextComponent();
      var hashSign = _getNextComponent();
      var index = parseInt(_getNextComponent(), 10);
      // Sanity check: %23 is URL code for "#"
      if (hashSign !== '%23' || isNaN(index)) {
        index = null;
      }
      var tracksetTracks = [];
      if (tracksArray) {
        tracksArray = _decodeComponent(tracksArray).split(',');
        for (i = 0, len = tracksArray.length; i < len; i++) {
          var trackId = tracksArray[i];
          tracksetTracks.push(URI.trackURI(trackId));
        }
      }
      return URI.tracksetURI(tracksetTracks, name, index);
    case URI.Type.CONTEXT_GROUP:
      return URI.contextGroupURI(_getNextComponent(), _getNextComponent());
    case URI.Type.TOP:
      var type = _getNextComponent();
      if (_getNextComponent() == URI.Type.GLOBAL) {
        return URI.toplistURI(type, null, true);
      } else {
        return URI.toplistURI(type, _getNextComponent(), false);
      }
    case URI.Type.USER:
      var username = _decodeComponent(_getNextComponent(), format);
      var text = _getNextComponent();
      if (username == URI.Type.FACEBOOK && text != null) {
        return URI.facebookURI(parseInt(text, 10));
      } else if (text != null) {
        switch (text) {
          case URI.Type.PLAYLIST:
            return URI.playlistURI(username, _getIdComponent());
          case URI.Type.FOLDER:
            return URI.folderURI(username, _getIdComponent());
          case URI.Type.COLLECTION_TRACK_LIST:
            return URI.collectionTrackList(username, _getIdComponent());
          case URI.Type.COLLECTION:
            var collectionItemType = _getNextComponent();
            switch (collectionItemType) {
              case URI.Type.ALBUM:
                id = _getIdComponent();
                if (_getNextComponent() === 'missing') {
                  return URI.collectionMissingAlbumURI(username, id);
                } else {
                  return URI.collectionAlbumURI(username, id);
                }
              case URI.Type.ARTIST:
                return URI.collectionArtistURI(username, _getIdComponent());
              default:
                return URI.collectionURI(username, collectionItemType);
            }
          case URI.Type.STARRED:
            return URI.starredURI(username);
          case URI.Type.FOLLOWERS:
            return URI.followersURI(username);
          case URI.Type.FOLLOWING:
            return URI.followingURI(username);
          case URI.Type.TOP:
            return URI.userToplistURI(username, _getNextComponent());
          case URI.Type.INBOX:
            return URI.inboxURI(username);
          case URI.Type.ROOTLIST:
            return URI.rootlistURI(username);
          case URI.Type.PUBLISHED_ROOTLIST:
            return URI.publishedRootlistURI(username);
          case URI.Type.TOPLIST:
            // legacy toplist
            return URI.userTopTracksURI(username);
          case URI.Type.LIBRARY:
            return URI.libraryURI(username, _getNextComponent());
        }
      }
      var rem = _getRemainingComponents();
      if (text != null && rem.length > 0) {
        return URI.profileURI(username, [text].concat(rem));
      } else if (text != null) {
        return URI.profileURI(username, [text]);
      } else {
        return URI.profileURI(username);
      }
    case URI.Type.LOCAL:
      var artistNameComponent = _getNextComponent();
      var artistName = artistNameComponent && _decodeComponent(artistNameComponent, format);
      var albumNameComponent = _getNextComponent();
      var albumName = albumNameComponent && _decodeComponent(albumNameComponent, format);
      var trackNameComponent = _getNextComponent();
      var trackName = trackNameComponent && _decodeComponent(trackNameComponent, format);
      var durationComponent = _getNextComponent();
      var duration = parseInt(durationComponent, 10);
      if (trackNameComponent !== undefined) {
        return URI.localURI(artistName, albumName, trackName, duration);
      } else if (albumNameComponent !== undefined) {
        return URI.localAlbumURI(artistName, albumName);
      } else {
        return URI.localArtistURI(artistName);
      }
    case URI.Type.IMAGE:
      return URI.imageURI(_getIdComponent());
    case URI.Type.MOSAIC:
      return URI.mosaicURI(components.slice(_current));
    case URI.Type.RADIO:
      return URI.radioURI(_getRemainingString());
    case URI.Type.SPECIAL:
      var args = _getRemainingComponents();
      for (i = 0, len = args.length; i < len; ++i)
        args[i] = _decodeComponent(args[i], format);
      return URI.specialURI(args);
    case URI.Type.STATION:
      return URI.stationURI(_getRemainingComponents());
    case URI.Type.EPISODE:
      return URI.episodeURI(_getIdComponent());
    default:
      if (part === URI.Type.APP) {
        id = _getNextComponent();
      } else {
        id = part;
      }
      var args = _getRemainingComponents();
      for (i = 0, len = args.length; i < len; ++i)
        args[i] = _decodeComponent(args[i], format);
      return URI.applicationURI(id, args);
  }

  throw ERROR_INVALID;
};

/**
 * A class holding information about a uri.
 *
 * @constructor
 * @param {URI.Type} type The uri type.
 * @param {Object} props The uri properties.
 */
function URI(type, props) {
  /**
   * The uri type.
   *
   * @type {string}
   */
  this.type = type;

  // Merge properties into URI object.
  for (var prop in props) {
    if (typeof props[prop] == 'function') {
      continue;
    }
    this[prop] = props[prop];
  }
}

// Lazy convert the id to hexadecimal only when requested
Object.defineProperty(URI.prototype, 'id', {
  get: function() {
    if (!this._hexId) {
      this._hexId = this._base62Id ? URI.idToHex(this._base62Id) : undefined;
    }
    return this._hexId;
  },
  set: function(id) {
    this._base62Id = id ? URI.hexToId(id) : undefined;
    this._hexId = undefined;
  },
  enumerable: true,
  configurable: true
});

/**
 * Creates an application URI object from the current URI object.
 *
 * If the current URI object is already an application type, a copy is made.
 *
 * @return {URI} The current URI as an application URI.
 */
URI.prototype.toAppType = function() {
  if (this.type == URI.Type.APPLICATION) {
    return URI.applicationURI(this.id, this.args);
  } else {
    var components = _getComponents(this, Format.URL);
    var id = components.shift();
    var len = components.length;
    if (len) {
      while (len--) {
        components[len] = _decodeComponent(components[len], Format.URL);
      }
    }
    if (this.type == URI.Type.RADIO) {
      components = components.shift().split(':');
    }
    var result = URI.applicationURI(id, components);
    return result;
  }
};

/**
 * Creates a URI object from an application URI object.
 *
 * If the current URI object is not an application type, a copy is made.
 *
 * @return {URI} The current URI as a real typed URI.
 */
URI.prototype.toRealType = function() {
  if (this.type == URI.Type.APPLICATION) {
    return _parseFromComponents([this.id].concat(this.args), Format.URI);
  } else {
    return new URI(null, this);
  }
};

/**
 * Returns the URI representation of this URI.
 *
 * @return {String} The URI representation of this uri.
 */
URI.prototype.toURI = function() {
  return URI_PREFIX + _getComponents(this, Format.URI).join(':');
};

/**
 * Returns the String representation of this URI.
 *
 * @return {String} The URI representation of this uri.
 * @see {URI#toURI}
 */
URI.prototype.toString = function() {
  return this.toURI();
};

/**
 * Get the URL path of this uri.
 *
 * @param {boolean} opt_leadingSlash True if a leading slash should be prepended.
 * @return {String} The path of this uri.
 */
URI.prototype.toURLPath = function(opt_leadingSlash) {
  var components = _getComponents(this, Format.URL);
  if (components[0] === URI.Type.APP) {
    components.shift();
  }

  // Some URIs are allowed to have empty components. It should be investigated
  // whether we need to strip empty components at all from any URIs. For now,
  // we check specifically for tracksets and local tracks and strip empty
  // components for all other URIs.
  //
  // For tracksets, it's permissible to have a path that looks like
  // 'trackset//trackURI' because the identifier parameter for a trackset can
  // be blank. For local tracks, some metadata can be missing, like missing
  // album name would be 'spotify:local:artist::track:duration'.
  var isTrackset = components[0] === URI.Type.TRACKSET;
  var isLocalTrack = components[0] === URI.Type.LOCAL;
  var shouldStripEmptyComponents = !isTrackset && !isLocalTrack;

  if (shouldStripEmptyComponents) {
    var _temp = [];
    for (var i = 0, l = components.length; i < l; i++) {
      var component = components[i];
      if (!!component) {
        _temp.push(component);
      }
    }
    components = _temp;
  }
  var path = components.join('/');
  return opt_leadingSlash ? '/' + path : path;
};

/**
 * Returns the Play URL string for the uri.
 *
 * @return {string} The Play URL string for the uri.
 */
URI.prototype.toPlayURL = function() {
    return PLAY_HTTPS_PREFIX + this.toURLPath();
};

/**
 * Returns the URL string for the uri.
 *
 * @return {string} The URL string for the uri.
 * @see {URL#toPlayURL}
 */
URI.prototype.toURL = function() {
  return this.toPlayURL();
};

/**
 * Returns the Open URL string for the uri.
 *
 * @return {string} The Open URL string for the uri.
 */
URI.prototype.toOpenURL = function() {
  return OPEN_HTTPS_PREFIX + this.toURLPath();
};

/**
 * Returns the Play HTTPS URL string for the uri.
 *
 * @return {string} The Play HTTPS URL string for the uri.
 */
URI.prototype.toSecurePlayURL = function() {
    return this.toPlayURL();
};

/**
 * Returns the HTTPS URL string for the uri.
 *
 * @return {string} The HTTPS URL string for the uri.
 * @see {URL#toSecurePlayURL}
 */
URI.prototype.toSecureURL = function() {
  return this.toPlayURL();
};

/**
 * Returns the Open HTTPS URL string for the uri.
 *
 * @return {string} The Open HTTPS URL string for the uri.
 */
URI.prototype.toSecureOpenURL = function() {
  return this.toOpenURL();
};

/**
 * Returns the id of the uri as a bytestring.
 *
 * @return {Array} The id of the uri as a bytestring.
 */
URI.prototype.idToByteString = function() {
  var data = Base62.toBytes(this._base62Id);
  data = data.map(function(i) {
    return String.fromCharCode(i);
  }).join('');
  while (data.length < 16) {
    data = String.fromCharCode(0) + data;
  }
  return data;
};

/**
 * The various URI Types.
 *
 * Note that some of the types in this enum are not real URI types, but are
 * actually URI particles. They are marked so.
 *
 * @enum {string}
 */
URI.Type = {
  EMPTY: 'empty',
  ALBUM: 'album',
  AD: 'ad',
  /** URI particle; not an actual URI. */
  APP: 'app',
  APPLICATION: 'application',
  ARTIST: 'artist',
  ARTIST_TOPLIST: 'artist-toplist',
  AUDIO_FILE: 'audiofile',
  COLLECTION: 'collection',
  COLLECTION_ALBUM: 'collection-album',
  COLLECTION_MISSING_ALBUM: 'collection-missing-album',
  COLLECTION_ARTIST: 'collection-artist',
  CONTEXT_GROUP: 'context-group',
  EPISODE: 'episode',
  /** URI particle; not an actual URI. */
  FACEBOOK: 'facebook',
  FOLDER: 'folder',
  FOLLOWERS: 'followers',
  FOLLOWING: 'following',
  /** URI particle; not an actual URI. */
  GLOBAL: 'global',
  IMAGE: 'image',
  INBOX: 'inbox',
  LOCAL_ARTIST: 'local-artist',
  LOCAL_ALBUM: 'local-album',
  LOCAL: 'local',
  LIBRARY: 'library',
  MOSAIC: 'mosaic',
  PLAYLIST: 'playlist',
  PROFILE: 'profile',
  PUBLISHED_ROOTLIST: 'published-rootlist',
  RADIO: 'radio',
  ROOTLIST: 'rootlist',
  COLLECTION_TRACK_LIST: 'collectiontracklist',
  SEARCH: 'search',
  SPECIAL: 'special',
  STARRED: 'starred',
  STATION: 'station',
  TEMP_PLAYLIST: 'temp-playlist',
  /** URI particle; not an actual URI. */
  TOP: 'top',
  TOPLIST: 'toplist',
  TRACK: 'track',
  TRACKSET: 'trackset',
  /** URI particle; not an actual URI. */
  USER: 'user',
  USER_TOPLIST: 'user-toplist',
  USER_TOP_TRACKS: 'user-top-tracks',
  /** Deprecated contant. Please use USER_TOP_TRACKS. */
  USET_TOP_TRACKS: 'user-top-tracks'
};

/**
 * Creates a new URI object from a parsed string argument.
 *
 * @param {string} str The string that will be parsed into a URI object.
 * @throws TypeError If the string argument is not a valid URI, a TypeError will
 *     be thrown.
 * @return {URI} The parsed URI object.
 */
URI.fromString = function(str) {
  var splitted = _splitIntoComponents(str);
  return _parseFromComponents(splitted.components, splitted.format);
};

/**
 * Parses a given object into a URI instance.
 *
 * Unlike URI.fromString, this function could receive any kind of value. If
 * the value is already a URI instance, it is simply returned.
 * Otherwise the value will be stringified before parsing.
 *
 * This function also does not throw an error like URI.fromString, but
 * instead simply returns null if it can't parse the value.
 *
 * @param {*} value The value to parse.
 * @return {URI?} The corresponding URI instance, or null if the
 *     passed value is not a valid value.
 */
URI.from = function(value) {
  try {
    if (value instanceof URI) {
      return value;
    }
    if (typeof value == 'object' && value.type) {
      return new URI(null, value);
    }
    return URI.fromString(value.toString());
  } catch(e) {
    return null;
  }
};

/**
 * Creates a new URI from a bytestring.
 *
 * @param {URI.Type} type The type of the URI.
 * @param {ByteString} idByteString The ID of the URI as a bytestring.
 * @param {Object} opt_args Optional arguments to the URI constructor.
 * @return {URI} The URI object created.
 */
URI.fromByteString = function(type, idByteString, opt_args) {
  var bytes = [];
  for (var i = 0; i < idByteString.length; i++) {
    bytes.push(idByteString.charCodeAt(i));
  }
  var id = Base62.fromBytes(bytes, 22);
  var args = opt_args || {};
  args.id = id;
  return new URI(type, args);
};

/**
 * Clones a given SpotifyURI instance.
 *
 * @param {URI} uri The uri to clone.
 * @return {URI?} An instance of URI.
 */
URI.clone = function(uri) {
  if (!(uri instanceof URI)) {
    return null;
  }
  return new URI(null, uri);
};

/**
 * @deprecated
 */
URI.getCanonical = function(username) {
  return this.getCanonical(username);
};

/**
 * Returns the canonical representation of a username.
 *
 * @param {string} username The username to encode.
 * @return {string} The encoded canonical representation of the username.
 */
URI.getCanonicalUsername = function(username) {
  return _encodeComponent(username, Format.URI);
};

/**
 * Returns the non-canonical representation of a username.
 *
 * @param {string} username The username to encode.
 * @return {string} The unencoded canonical representation of the username.
 */
URI.getDisplayUsername = function(username) {
  return _decodeComponent(username, Format.URI);
};

/**
 * Returns the hex representation of a Base62 encoded id.
 *
 * @param {string} id The base62 encoded id.
 * @return {string} The hex representation of the base62 id.
 */
URI.idToHex = function(id) {
  if (id.length == 22) {
    return Base62.toHex(id, 32);
  }
  return id;
};

/**
 * Returns the base62 representation of a hex encoded id.
 *
 * @param {string} hex The hex encoded id.
 * @return {string} The base62 representation of the id.
 */
URI.hexToId = function(hex) {
  if (hex.length == 32) {
    return Base62.fromHex(hex, 22);
  }
  return hex;
};

/**
 * Creates a new empty URI.
 *
 * @return {URI} The empty URI.
 */
URI.emptyURI = function() {
  return new URI(URI.Type.EMPTY, {});
};

/**
 * Creates a new 'album' type URI.
 *
 * @param {string} id The id of the album.
 * @param {number} disc The disc number of the album.
 * @return {URI} The album URI.
 */
URI.albumURI = function(id, disc) {
  return new URI(URI.Type.ALBUM, {id: id, disc: disc});
};

/**
 * Creates a new 'ad' type URI.
 *
 * @param {string} id The id of the ad.
 * @return {URI} The ad URI.
 */
URI.adURI = function(id) {
  return new URI(URI.Type.AD, {id: id});
};

/**
 * Creates a new 'audiofile' type URI.
 *
 * @param {string} extension The extension of the audiofile.
 * @param {string} id The id of the extension.
 * @return {URI} The audiofile URI.
 */
URI.audioFileURI = function(extension, id) {
  return new URI(URI.Type.AUDIO_FILE, {id: id, extension: extension});
};

/**
 * Creates a new 'artist' type URI.
 *
 * @param {string} id The id of the artist.
 * @return {URI} The artist URI.
 */
URI.artistURI = function(id) {
  return new URI(URI.Type.ARTIST, {id: id});
};

/**
 * Creates a new 'artist-toplist' type URI.
 *
 * @param {string} id The id of the artist.
 * @param {string} toplist The toplist type.
 * @return {URI} The artist-toplist URI.
 */
URI.artistToplistURI = function(id, toplist) {
  return new URI(URI.Type.ARTIST_TOPLIST, {id: id, toplist: toplist});
};

/**
 * Creates a new 'search' type URI.
 *
 * @param {string} query The unencoded search query.
 * @return {URI} The search URI
 */
URI.searchURI = function(query) {
  return new URI(URI.Type.SEARCH, {query: query});
};

/**
 * Creates a new 'track' type URI.
 *
 * @param {string} id The id of the track.
 * @param {string} anchor The point in the track formatted as mm:ss
 * @return {URI} The track URI.
 */
URI.trackURI = function(id, anchor) {
  return new URI(URI.Type.TRACK, {id: id, anchor: anchor});
};

/**
 * Creates a new 'trackset' type URI.
 *
 * @param {Array.<URI>} tracks An array of 'track' type URIs.
 * @param {string} name The name of the trackset.
 * @param {number} index The index in the trackset.
 * @return {URI} The trackset URI.
 */
URI.tracksetURI = function(tracks, name, index) {
  return new URI(URI.Type.TRACKSET, {
    tracks: tracks,
    name: name || '',
    index: isNaN(index) ? null : index
  });
};

/**
 * Creates a new 'facebook' type URI.
 *
 * @param {string} uid The user id.
 * @return {URI} The facebook URI.
 */
URI.facebookURI = function(uid) {
  return new URI(URI.Type.FACEBOOK, {uid: uid});
};

/**
 * Creates a new 'followers' type URI.
 *
 * @param {string} username The non-canonical username.
 * @return {URI} The followers URI.
 */
URI.followersURI = function(username) {
  return new URI(URI.Type.FOLLOWERS, {username: username});
};

/**
 * Creates a new 'following' type URI.
 *
 * @param {string} username The non-canonical username.
 * @return {URI} The following URI.
 */
URI.followingURI = function(username) {
  return new URI(URI.Type.FOLLOWING, {username: username});
};

/**
 * Creates a new 'playlist' type URI.
 *
 * @param {string} username The non-canonical username of the playlist owner.
 * @param {string} id The id of the playlist.
 * @return {URI} The playlist URI.
 */
URI.playlistURI = function(username, id) {
  return new URI(URI.Type.PLAYLIST, {username: username, id: id});
};

/**
 * Creates a new 'folder' type URI.
 *
 * @param {string} username The non-canonical username of the folder owner.
 * @param {string} id The id of the folder.
 * @return {URI} The folder URI.
 */
URI.folderURI = function(username, id) {
  return new URI(URI.Type.FOLDER, {username: username, id: id});
};

/**
 * Creates a new 'collectiontracklist' type URI.
 *
 * @param {string} username The non-canonical username of the collection owner.
 * @param {string} id The id of the tracklist.
 * @return {URI} The collectiontracklist URI.
 */
URI.collectionTrackList = function(username, id) {
  return new URI(URI.Type.COLLECTION_TRACK_LIST, {username: username, id: id});
};

/**
 * Creates a new 'starred' type URI.
 *
 * @param {string} username The non-canonical username of the starred list owner.
 * @return {URI} The starred URI.
 */
URI.starredURI = function(username) {
  return new URI(URI.Type.STARRED, {username: username});
};

/**
 * Creates a new 'user-toplist' type URI.
 *
 * @param {string} username The non-canonical username of the toplist owner.
 * @param {string} toplist The toplist type.
 * @return {URI} The user-toplist URI.
 */
URI.userToplistURI = function(username, toplist) {
  return new URI(URI.Type.USER_TOPLIST, {username: username, toplist: toplist});
};

/**
 * Creates a new 'user-top-tracks' type URI.
 *
 * @deprecated
 * @param {string} username The non-canonical username of the toplist owner.
 * @return {URI} The user-top-tracks URI.
 */
URI.userTopTracksURI = function(username) {
  return new URI(URI.Type.USER_TOP_TRACKS, {username: username});
};

/**
 * Creates a new 'toplist' type URI.
 *
 * @param {string} toplist The toplist type.
 * @param {string} country The country code for the toplist.
 * @param {boolean} global True if this is a global rather than a country list.
 * @return {URI} The toplist URI.
 */
URI.toplistURI = function(toplist, country, global) {
  return new URI(URI.Type.TOPLIST, {toplist: toplist, country: country, global: !!global});
};

/**
 * Creates a new 'inbox' type URI.
 *
 * @param {string} username The non-canonical username of the inbox owner.
 * @return {URI} The inbox URI.
 */
URI.inboxURI = function(username) {
  return new URI(URI.Type.INBOX, {username: username});
};

/**
 * Creates a new 'rootlist' type URI.
 *
 * @param {string} username The non-canonical username of the rootlist owner.
 * @return {URI} The rootlist URI.
 */
URI.rootlistURI = function(username) {
  return new URI(URI.Type.ROOTLIST, {username: username});
};

/**
 * Creates a new 'published-rootlist' type URI.
 *
 * @param {string} username The non-canonical username of the published-rootlist owner.
 * @return {URI} The published-rootlist URI.
 */
URI.publishedRootlistURI = function(username) {
  return new URI(URI.Type.PUBLISHED_ROOTLIST, {username: username});
};

/**
 * Creates a new 'local-artist' type URI.
 *
 * @param {string} artist The artist name.
 * @return {URI} The local-artist URI.
 */
URI.localArtistURI = function(artist) {
  return new URI(URI.Type.LOCAL_ARTIST, {artist: artist});
};

/**
 * Creates a new 'local-album' type URI.
 *
 * @param {string} artist The artist name.
 * @param {string} album The album name.
 * @return {URI} The local-album URI.
 */
URI.localAlbumURI = function(artist, album) {
  return new URI(URI.Type.LOCAL_ALBUM, {artist: artist, album: album});
};

/**
 * Creates a new 'local' type URI.
 *
 * @param {string} artist The artist name.
 * @param {string} album The album name.
 * @param {string} track The track name.
 * @param {number} duration The track duration in ms.
 * @return {URI} The local URI.
 */
URI.localURI = function(artist, album, track, duration) {
  return new URI(URI.Type.LOCAL, {
    artist: artist,
    album: album,
    track: track,
    duration: duration
  });
};

/**
 * Creates a new 'library' type URI.
 *
 * @param {string} username The non-canonical username of the rootlist owner.
 * @param {string} category The category of the library.
 * @return {URI} The library URI.
 */
URI.libraryURI = function(username, category) {
  return new URI(URI.Type.LIBRARY, {username: username, category: category});
};

/**
 * Creates a new 'collection' type URI.
 *
 * @param {string} username The non-canonical username of the rootlist owner.
 * @param {string} category The category of the collection.
 * @return {URI} The collection URI.
 */
URI.collectionURI = function(username, category) {
  return new URI(URI.Type.COLLECTION, {username: username, category: category});
};

/**
 * Creates a new 'temp-playlist' type URI.
 *
 * @param {string} origin The origin of the temporary playlist.
 * @param {string} data Additional data for the playlist.
 * @return {URI} The temp-playlist URI.
 */
URI.temporaryPlaylistURI = function(origin, data) {
  return new URI(URI.Type.TEMP_PLAYLIST, {origin: origin, data: data});
};

/**
 * Creates a new 'context-group' type URI.
 *
 * @deprecated
 * @param {string} origin The origin of the temporary playlist.
 * @param {string} name The name of the context group.
 * @return {URI} The context-group URI.
 */
URI.contextGroupURI = function(origin, name) {
  return new URI(URI.Type.CONTEXT_GROUP, {origin: origin, name: name});
};

/**
 * Creates a new 'profile' type URI.
 *
 * @param {string} username The non-canonical username of the rootlist owner.
 * @param {Array.<string>} args A list of arguments.
 * @return {URI} The profile URI.
 */
URI.profileURI = function(username, args) {
  return new URI(URI.Type.PROFILE, {username: username, args: args});
};

/**
 * Creates a new 'image' type URI.
 *
 * @param {string} id The id of the image.
 * @return {URI} The image URI.
 */
URI.imageURI = function(id) {
  return new URI(URI.Type.IMAGE, {id: id});
};

/**
 * Creates a new 'mosaic' type URI.
 *
 * @param {Array.<string>} ids The ids of the mosaic immages.
 * @return {URI} The mosaic URI.
 */
URI.mosaicURI = function(ids) {
  return new URI(URI.Type.MOSAIC, {ids: ids});
};

/**
 * Creates a new 'radio' type URI.
 *
 * @param {string} args The radio seed arguments.
 * @return {URI} The radio URI.
 */
URI.radioURI = function(args) {
  args = typeof args === 'undefined' ? '' : args;
  return new URI(URI.Type.RADIO, {args: args});
};

/**
 * Creates a new 'special' type URI.
 *
 * @param {Array.<string>} args An array containing the other arguments.
 * @return {URI} The special URI.
 */
URI.specialURI = function(args) {
  args = typeof args === 'undefined' ? [] : args;
  return new URI(URI.Type.SPECIAL, {args: args});
};

/**
 * Creates a new 'station' type URI.
 *
 * @param {Array.<string>} args An array of arguments for the station.
 * @return {URI} The station URI.
 */
URI.stationURI = function(args) {
  args = typeof args === 'undefined' ? [] : args;
  return new URI(URI.Type.STATION, {args: args});
};

/**
 * Creates a new 'application' type URI.
 *
 * @param {string} id The id of the application.
 * @param {Array.<string>} args An array containing the arguments to the app.
 * @return {URI} The application URI.
 */
URI.applicationURI = function(id, args) {
  args = typeof args === 'undefined' ? [] : args;
  return new URI(URI.Type.APPLICATION, {id: id, args: args});
};

/**
 * Creates a new 'collection-album' type URI.
 *
 * @param {string} username The non-canonical username of the rootlist owner.
 * @param {string} id The id of the album.
 * @return {URI} The collection-album URI.
 */
URI.collectionAlbumURI = function(username, id) {
  return new URI(URI.Type.COLLECTION_ALBUM, {username: username, id: id});
};

/**
 * Creates a new 'collection-album-missing' type URI.
 *
 * @param {string} username The non-canonical username of the rootlist owner.
 * @param {string} id The id of the album.
 * @return {URI} The collection-album-missing URI.
 */
URI.collectionMissingAlbumURI = function(username, id) {
  return new URI(URI.Type.COLLECTION_MISSING_ALBUM, {username: username, id: id});
};

/**
 * Creates a new 'collection-artist' type URI.
 *
 * @param {string} username The non-canonical username of the rootlist owner.
 * @param {string} id The id of the artist.
 * @return {URI} The collection-artist URI.
 */
URI.collectionArtistURI = function(username, id) {
  return new URI(URI.Type.COLLECTION_ARTIST, {username: username, id: id});
};

/**
 * Creates a new 'episode' type URI.
 *
 * @param {string} id The id of the episode.
 * @return {URI} The episode URI.
 */
URI.episodeURI = function(id) {
  return new URI(URI.Type.EPISODE, {id: id});
};

/**
 * Export public interface
 */
module.exports = URI;

},{"spotify-crypto/src/base62":250}],257:[function(require,module,exports){
//     Underscore.js 1.8.3
//     http://underscorejs.org
//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `exports` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var
    push             = ArrayProto.push,
    slice            = ArrayProto.slice,
    toString         = ObjProto.toString,
    hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind,
    nativeCreate       = Object.create;

  // Naked function reference for surrogate-prototype-swapping.
  var Ctor = function(){};

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.8.3';

  // Internal function that returns an efficient (for current engines) version
  // of the passed-in callback, to be repeatedly applied in other Underscore
  // functions.
  var optimizeCb = function(func, context, argCount) {
    if (context === void 0) return func;
    switch (argCount == null ? 3 : argCount) {
      case 1: return function(value) {
        return func.call(context, value);
      };
      case 2: return function(value, other) {
        return func.call(context, value, other);
      };
      case 3: return function(value, index, collection) {
        return func.call(context, value, index, collection);
      };
      case 4: return function(accumulator, value, index, collection) {
        return func.call(context, accumulator, value, index, collection);
      };
    }
    return function() {
      return func.apply(context, arguments);
    };
  };

  // A mostly-internal function to generate callbacks that can be applied
  // to each element in a collection, returning the desired result — either
  // identity, an arbitrary callback, a property matcher, or a property accessor.
  var cb = function(value, context, argCount) {
    if (value == null) return _.identity;
    if (_.isFunction(value)) return optimizeCb(value, context, argCount);
    if (_.isObject(value)) return _.matcher(value);
    return _.property(value);
  };
  _.iteratee = function(value, context) {
    return cb(value, context, Infinity);
  };

  // An internal function for creating assigner functions.
  var createAssigner = function(keysFunc, undefinedOnly) {
    return function(obj) {
      var length = arguments.length;
      if (length < 2 || obj == null) return obj;
      for (var index = 1; index < length; index++) {
        var source = arguments[index],
            keys = keysFunc(source),
            l = keys.length;
        for (var i = 0; i < l; i++) {
          var key = keys[i];
          if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];
        }
      }
      return obj;
    };
  };

  // An internal function for creating a new object that inherits from another.
  var baseCreate = function(prototype) {
    if (!_.isObject(prototype)) return {};
    if (nativeCreate) return nativeCreate(prototype);
    Ctor.prototype = prototype;
    var result = new Ctor;
    Ctor.prototype = null;
    return result;
  };

  var property = function(key) {
    return function(obj) {
      return obj == null ? void 0 : obj[key];
    };
  };

  // Helper for collection methods to determine whether a collection
  // should be iterated as an array or as an object
  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
  var getLength = property('length');
  var isArrayLike = function(collection) {
    var length = getLength(collection);
    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
  };

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles raw objects in addition to array-likes. Treats all
  // sparse array-likes as if they were dense.
  _.each = _.forEach = function(obj, iteratee, context) {
    iteratee = optimizeCb(iteratee, context);
    var i, length;
    if (isArrayLike(obj)) {
      for (i = 0, length = obj.length; i < length; i++) {
        iteratee(obj[i], i, obj);
      }
    } else {
      var keys = _.keys(obj);
      for (i = 0, length = keys.length; i < length; i++) {
        iteratee(obj[keys[i]], keys[i], obj);
      }
    }
    return obj;
  };

  // Return the results of applying the iteratee to each element.
  _.map = _.collect = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length,
        results = Array(length);
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      results[index] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
  };

  // Create a reducing function iterating left or right.
  function createReduce(dir) {
    // Optimized iterator function as using arguments.length
    // in the main function will deoptimize the, see #1991.
    function iterator(obj, iteratee, memo, keys, index, length) {
      for (; index >= 0 && index < length; index += dir) {
        var currentKey = keys ? keys[index] : index;
        memo = iteratee(memo, obj[currentKey], currentKey, obj);
      }
      return memo;
    }

    return function(obj, iteratee, memo, context) {
      iteratee = optimizeCb(iteratee, context, 4);
      var keys = !isArrayLike(obj) && _.keys(obj),
          length = (keys || obj).length,
          index = dir > 0 ? 0 : length - 1;
      // Determine the initial value if none is provided.
      if (arguments.length < 3) {
        memo = obj[keys ? keys[index] : index];
        index += dir;
      }
      return iterator(obj, iteratee, memo, keys, index, length);
    };
  }

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`.
  _.reduce = _.foldl = _.inject = createReduce(1);

  // The right-associative version of reduce, also known as `foldr`.
  _.reduceRight = _.foldr = createReduce(-1);

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, predicate, context) {
    var key;
    if (isArrayLike(obj)) {
      key = _.findIndex(obj, predicate, context);
    } else {
      key = _.findKey(obj, predicate, context);
    }
    if (key !== void 0 && key !== -1) return obj[key];
  };

  // Return all the elements that pass a truth test.
  // Aliased as `select`.
  _.filter = _.select = function(obj, predicate, context) {
    var results = [];
    predicate = cb(predicate, context);
    _.each(obj, function(value, index, list) {
      if (predicate(value, index, list)) results.push(value);
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, predicate, context) {
    return _.filter(obj, _.negate(cb(predicate)), context);
  };

  // Determine whether all of the elements match a truth test.
  // Aliased as `all`.
  _.every = _.all = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (!predicate(obj[currentKey], currentKey, obj)) return false;
    }
    return true;
  };

  // Determine if at least one element in the object matches a truth test.
  // Aliased as `any`.
  _.some = _.any = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (predicate(obj[currentKey], currentKey, obj)) return true;
    }
    return false;
  };

  // Determine if the array or object contains a given item (using `===`).
  // Aliased as `includes` and `include`.
  _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {
    if (!isArrayLike(obj)) obj = _.values(obj);
    if (typeof fromIndex != 'number' || guard) fromIndex = 0;
    return _.indexOf(obj, item, fromIndex) >= 0;
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function(value) {
      var func = isFunc ? method : value[method];
      return func == null ? func : func.apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, _.property(key));
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs) {
    return _.filter(obj, _.matcher(attrs));
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.find(obj, _.matcher(attrs));
  };

  // Return the maximum element (or element-based computation).
  _.max = function(obj, iteratee, context) {
    var result = -Infinity, lastComputed = -Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value > result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iteratee, context) {
    var result = Infinity, lastComputed = Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value < result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed < lastComputed || computed === Infinity && result === Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Shuffle a collection, using the modern version of the
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
  _.shuffle = function(obj) {
    var set = isArrayLike(obj) ? obj : _.values(obj);
    var length = set.length;
    var shuffled = Array(length);
    for (var index = 0, rand; index < length; index++) {
      rand = _.random(0, index);
      if (rand !== index) shuffled[index] = shuffled[rand];
      shuffled[rand] = set[index];
    }
    return shuffled;
  };

  // Sample **n** random values from a collection.
  // If **n** is not specified, returns a single random element.
  // The internal `guard` argument allows it to work with `map`.
  _.sample = function(obj, n, guard) {
    if (n == null || guard) {
      if (!isArrayLike(obj)) obj = _.values(obj);
      return obj[_.random(obj.length - 1)];
    }
    return _.shuffle(obj).slice(0, Math.max(0, n));
  };

  // Sort the object's values by a criterion produced by an iteratee.
  _.sortBy = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value: value,
        index: index,
        criteria: iteratee(value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index - right.index;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(behavior) {
    return function(obj, iteratee, context) {
      var result = {};
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index) {
        var key = iteratee(value, index, obj);
        behavior(result, value, key);
      });
      return result;
    };
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key].push(value); else result[key] = [value];
  });

  // Indexes the object's values by a criterion, similar to `groupBy`, but for
  // when you know that your index values will be unique.
  _.indexBy = group(function(result, value, key) {
    result[key] = value;
  });

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key]++; else result[key] = 1;
  });

  // Safely create a real, live array from anything iterable.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (isArrayLike(obj)) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return isArrayLike(obj) ? obj.length : _.keys(obj).length;
  };

  // Split a collection into two arrays: one whose elements all satisfy the given
  // predicate, and one whose elements all do not satisfy the predicate.
  _.partition = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var pass = [], fail = [];
    _.each(obj, function(value, key, obj) {
      (predicate(value, key, obj) ? pass : fail).push(value);
    });
    return [pass, fail];
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[0];
    return _.initial(array, array.length - n);
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array.
  _.last = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[array.length - 1];
    return _.rest(array, Math.max(0, array.length - n));
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, n == null || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, _.identity);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, strict, startIndex) {
    var output = [], idx = 0;
    for (var i = startIndex || 0, length = getLength(input); i < length; i++) {
      var value = input[i];
      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
        //flatten current level of array or arguments object
        if (!shallow) value = flatten(value, shallow, strict);
        var j = 0, len = value.length;
        output.length += len;
        while (j < len) {
          output[idx++] = value[j++];
        }
      } else if (!strict) {
        output[idx++] = value;
      }
    }
    return output;
  };

  // Flatten out an array, either recursively (by default), or just one level.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, false);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iteratee, context) {
    if (!_.isBoolean(isSorted)) {
      context = iteratee;
      iteratee = isSorted;
      isSorted = false;
    }
    if (iteratee != null) iteratee = cb(iteratee, context);
    var result = [];
    var seen = [];
    for (var i = 0, length = getLength(array); i < length; i++) {
      var value = array[i],
          computed = iteratee ? iteratee(value, i, array) : value;
      if (isSorted) {
        if (!i || seen !== computed) result.push(value);
        seen = computed;
      } else if (iteratee) {
        if (!_.contains(seen, computed)) {
          seen.push(computed);
          result.push(value);
        }
      } else if (!_.contains(result, value)) {
        result.push(value);
      }
    }
    return result;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(flatten(arguments, true, true));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    var result = [];
    var argsLength = arguments.length;
    for (var i = 0, length = getLength(array); i < length; i++) {
      var item = array[i];
      if (_.contains(result, item)) continue;
      for (var j = 1; j < argsLength; j++) {
        if (!_.contains(arguments[j], item)) break;
      }
      if (j === argsLength) result.push(item);
    }
    return result;
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = flatten(arguments, true, true, 1);
    return _.filter(array, function(value){
      return !_.contains(rest, value);
    });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    return _.unzip(arguments);
  };

  // Complement of _.zip. Unzip accepts an array of arrays and groups
  // each array's elements on shared indices
  _.unzip = function(array) {
    var length = array && _.max(array, getLength).length || 0;
    var result = Array(length);

    for (var index = 0; index < length; index++) {
      result[index] = _.pluck(array, index);
    }
    return result;
  };

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values.
  _.object = function(list, values) {
    var result = {};
    for (var i = 0, length = getLength(list); i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // Generator function to create the findIndex and findLastIndex functions
  function createPredicateIndexFinder(dir) {
    return function(array, predicate, context) {
      predicate = cb(predicate, context);
      var length = getLength(array);
      var index = dir > 0 ? 0 : length - 1;
      for (; index >= 0 && index < length; index += dir) {
        if (predicate(array[index], index, array)) return index;
      }
      return -1;
    };
  }

  // Returns the first index on an array-like that passes a predicate test
  _.findIndex = createPredicateIndexFinder(1);
  _.findLastIndex = createPredicateIndexFinder(-1);

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iteratee, context) {
    iteratee = cb(iteratee, context, 1);
    var value = iteratee(obj);
    var low = 0, high = getLength(array);
    while (low < high) {
      var mid = Math.floor((low + high) / 2);
      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
    }
    return low;
  };

  // Generator function to create the indexOf and lastIndexOf functions
  function createIndexFinder(dir, predicateFind, sortedIndex) {
    return function(array, item, idx) {
      var i = 0, length = getLength(array);
      if (typeof idx == 'number') {
        if (dir > 0) {
            i = idx >= 0 ? idx : Math.max(idx + length, i);
        } else {
            length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
        }
      } else if (sortedIndex && idx && length) {
        idx = sortedIndex(array, item);
        return array[idx] === item ? idx : -1;
      }
      if (item !== item) {
        idx = predicateFind(slice.call(array, i, length), _.isNaN);
        return idx >= 0 ? idx + i : -1;
      }
      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
        if (array[idx] === item) return idx;
      }
      return -1;
    };
  }

  // Return the position of the first occurrence of an item in an array,
  // or -1 if the item is not included in the array.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (stop == null) {
      stop = start || 0;
      start = 0;
    }
    step = step || 1;

    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var range = Array(length);

    for (var idx = 0; idx < length; idx++, start += step) {
      range[idx] = start;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Determines whether to execute a function as a constructor
  // or a normal function with the provided arguments
  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
    var self = baseCreate(sourceFunc.prototype);
    var result = sourceFunc.apply(self, args);
    if (_.isObject(result)) return result;
    return self;
  };

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = function(func, context) {
    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
    var args = slice.call(arguments, 2);
    var bound = function() {
      return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));
    };
    return bound;
  };

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context. _ acts
  // as a placeholder, allowing any combination of arguments to be pre-filled.
  _.partial = function(func) {
    var boundArgs = slice.call(arguments, 1);
    var bound = function() {
      var position = 0, length = boundArgs.length;
      var args = Array(length);
      for (var i = 0; i < length; i++) {
        args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];
      }
      while (position < arguments.length) args.push(arguments[position++]);
      return executeBound(func, bound, this, this, args);
    };
    return bound;
  };

  // Bind a number of an object's methods to that object. Remaining arguments
  // are the method names to be bound. Useful for ensuring that all callbacks
  // defined on an object belong to it.
  _.bindAll = function(obj) {
    var i, length = arguments.length, key;
    if (length <= 1) throw new Error('bindAll must be passed function names');
    for (i = 1; i < length; i++) {
      key = arguments[i];
      obj[key] = _.bind(obj[key], obj);
    }
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memoize = function(key) {
      var cache = memoize.cache;
      var address = '' + (hasher ? hasher.apply(this, arguments) : key);
      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);
      return cache[address];
    };
    memoize.cache = {};
    return memoize;
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){
      return func.apply(null, args);
    }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = _.partial(_.delay, _, 1);

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  _.throttle = function(func, wait, options) {
    var context, args, result;
    var timeout = null;
    var previous = 0;
    if (!options) options = {};
    var later = function() {
      previous = options.leading === false ? 0 : _.now();
      timeout = null;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    };
    return function() {
      var now = _.now();
      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0 || remaining > wait) {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }
        previous = now;
        result = func.apply(context, args);
        if (!timeout) context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, args, context, timestamp, result;

    var later = function() {
      var last = _.now() - timestamp;

      if (last < wait && last >= 0) {
        timeout = setTimeout(later, wait - last);
      } else {
        timeout = null;
        if (!immediate) {
          result = func.apply(context, args);
          if (!timeout) context = args = null;
        }
      }
    };

    return function() {
      context = this;
      args = arguments;
      timestamp = _.now();
      var callNow = immediate && !timeout;
      if (!timeout) timeout = setTimeout(later, wait);
      if (callNow) {
        result = func.apply(context, args);
        context = args = null;
      }

      return result;
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return _.partial(wrapper, func);
  };

  // Returns a negated version of the passed-in predicate.
  _.negate = function(predicate) {
    return function() {
      return !predicate.apply(this, arguments);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var args = arguments;
    var start = args.length - 1;
    return function() {
      var i = start;
      var result = args[start].apply(this, arguments);
      while (i--) result = args[i].call(this, result);
      return result;
    };
  };

  // Returns a function that will only be executed on and after the Nth call.
  _.after = function(times, func) {
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Returns a function that will only be executed up to (but not including) the Nth call.
  _.before = function(times, func) {
    var memo;
    return function() {
      if (--times > 0) {
        memo = func.apply(this, arguments);
      }
      if (times <= 1) func = null;
      return memo;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = _.partial(_.before, 2);

  // Object Functions
  // ----------------

  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
                      'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

  function collectNonEnumProps(obj, keys) {
    var nonEnumIdx = nonEnumerableProps.length;
    var constructor = obj.constructor;
    var proto = (_.isFunction(constructor) && constructor.prototype) || ObjProto;

    // Constructor is a special case.
    var prop = 'constructor';
    if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);

    while (nonEnumIdx--) {
      prop = nonEnumerableProps[nonEnumIdx];
      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
        keys.push(prop);
      }
    }
  }

  // Retrieve the names of an object's own properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = function(obj) {
    if (!_.isObject(obj)) return [];
    if (nativeKeys) return nativeKeys(obj);
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve all the property names of an object.
  _.allKeys = function(obj) {
    if (!_.isObject(obj)) return [];
    var keys = [];
    for (var key in obj) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };

  // Returns the results of applying the iteratee to each element of the object
  // In contrast to _.map it returns an object
  _.mapObject = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys =  _.keys(obj),
          length = keys.length,
          results = {},
          currentKey;
      for (var index = 0; index < length; index++) {
        currentKey = keys[index];
        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
      }
      return results;
  };

  // Convert an object into a list of `[key, value]` pairs.
  _.pairs = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [keys[i], obj[keys[i]]];
    }
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = createAssigner(_.allKeys);

  // Assigns a given object with all the own properties in the passed-in object(s)
  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
  _.extendOwn = _.assign = createAssigner(_.keys);

  // Returns the first key on an object that passes a predicate test
  _.findKey = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = _.keys(obj), key;
    for (var i = 0, length = keys.length; i < length; i++) {
      key = keys[i];
      if (predicate(obj[key], key, obj)) return key;
    }
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(object, oiteratee, context) {
    var result = {}, obj = object, iteratee, keys;
    if (obj == null) return result;
    if (_.isFunction(oiteratee)) {
      keys = _.allKeys(obj);
      iteratee = optimizeCb(oiteratee, context);
    } else {
      keys = flatten(arguments, false, false, 1);
      iteratee = function(value, key, obj) { return key in obj; };
      obj = Object(obj);
    }
    for (var i = 0, length = keys.length; i < length; i++) {
      var key = keys[i];
      var value = obj[key];
      if (iteratee(value, key, obj)) result[key] = value;
    }
    return result;
  };

   // Return a copy of the object without the blacklisted properties.
  _.omit = function(obj, iteratee, context) {
    if (_.isFunction(iteratee)) {
      iteratee = _.negate(iteratee);
    } else {
      var keys = _.map(flatten(arguments, false, false, 1), String);
      iteratee = function(value, key) {
        return !_.contains(keys, key);
      };
    }
    return _.pick(obj, iteratee, context);
  };

  // Fill in a given object with default properties.
  _.defaults = createAssigner(_.allKeys, true);

  // Creates an object that inherits from the given prototype object.
  // If additional properties are provided then they will be added to the
  // created object.
  _.create = function(prototype, props) {
    var result = baseCreate(prototype);
    if (props) _.extendOwn(result, props);
    return result;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Returns whether an object has a given set of `key:value` pairs.
  _.isMatch = function(object, attrs) {
    var keys = _.keys(attrs), length = keys.length;
    if (object == null) return !length;
    var obj = Object(object);
    for (var i = 0; i < length; i++) {
      var key = keys[i];
      if (attrs[key] !== obj[key] || !(key in obj)) return false;
    }
    return true;
  };


  // Internal recursive comparison function for `isEqual`.
  var eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a === 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className !== toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
      case '[object RegExp]':
      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return '' + a === '' + b;
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive.
        // Object(NaN) is equivalent to NaN
        if (+a !== +a) return +b !== +b;
        // An `egal` comparison is performed for other numeric values.
        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a === +b;
    }

    var areArrays = className === '[object Array]';
    if (!areArrays) {
      if (typeof a != 'object' || typeof b != 'object') return false;

      // Objects with different constructors are not equivalent, but `Object`s or `Array`s
      // from different frames are.
      var aCtor = a.constructor, bCtor = b.constructor;
      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
                               _.isFunction(bCtor) && bCtor instanceof bCtor)
                          && ('constructor' in a && 'constructor' in b)) {
        return false;
      }
    }
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

    // Initializing stack of traversed objects.
    // It's done here since we only need them for objects and arrays comparison.
    aStack = aStack || [];
    bStack = bStack || [];
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] === a) return bStack[length] === b;
    }

    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);

    // Recursively compare objects and arrays.
    if (areArrays) {
      // Compare array lengths to determine if a deep comparison is necessary.
      length = a.length;
      if (length !== b.length) return false;
      // Deep compare the contents, ignoring non-numeric properties.
      while (length--) {
        if (!eq(a[length], b[length], aStack, bStack)) return false;
      }
    } else {
      // Deep compare objects.
      var keys = _.keys(a), key;
      length = keys.length;
      // Ensure that both objects contain the same number of properties before comparing deep equality.
      if (_.keys(b).length !== length) return false;
      while (length--) {
        // Deep compare each member
        key = keys[length];
        if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return true;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
    return _.keys(obj).length === 0;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) === '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    var type = typeof obj;
    return type === 'function' || type === 'object' && !!obj;
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.
  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) === '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE < 9), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return _.has(obj, 'callee');
    };
  }

  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
  // IE 11 (#1621), and in Safari 8 (#1929).
  if (typeof /./ != 'function' && typeof Int8Array != 'object') {
    _.isFunction = function(obj) {
      return typeof obj == 'function' || false;
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
  _.isNaN = function(obj) {
    return _.isNumber(obj) && obj !== +obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, key) {
    return obj != null && hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iteratees.
  _.identity = function(value) {
    return value;
  };

  // Predicate-generating functions. Often useful outside of Underscore.
  _.constant = function(value) {
    return function() {
      return value;
    };
  };

  _.noop = function(){};

  _.property = property;

  // Generates a function for a given object that returns a given property.
  _.propertyOf = function(obj) {
    return obj == null ? function(){} : function(key) {
      return obj[key];
    };
  };

  // Returns a predicate for checking whether an object has a given set of
  // `key:value` pairs.
  _.matcher = _.matches = function(attrs) {
    attrs = _.extendOwn({}, attrs);
    return function(obj) {
      return _.isMatch(obj, attrs);
    };
  };

  // Run a function **n** times.
  _.times = function(n, iteratee, context) {
    var accum = Array(Math.max(0, n));
    iteratee = optimizeCb(iteratee, context, 1);
    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // A (possibly faster) way to get the current timestamp as an integer.
  _.now = Date.now || function() {
    return new Date().getTime();
  };

   // List of HTML entities for escaping.
  var escapeMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#x27;',
    '`': '&#x60;'
  };
  var unescapeMap = _.invert(escapeMap);

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  var createEscaper = function(map) {
    var escaper = function(match) {
      return map[match];
    };
    // Regexes for identifying a key that needs to be escaped
    var source = '(?:' + _.keys(map).join('|') + ')';
    var testRegexp = RegExp(source);
    var replaceRegexp = RegExp(source, 'g');
    return function(string) {
      string = string == null ? '' : '' + string;
      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
    };
  };
  _.escape = createEscaper(escapeMap);
  _.unescape = createEscaper(unescapeMap);

  // If the value of the named `property` is a function then invoke it with the
  // `object` as context; otherwise, return it.
  _.result = function(object, property, fallback) {
    var value = object == null ? void 0 : object[property];
    if (value === void 0) {
      value = fallback;
    }
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'":      "'",
    '\\':     '\\',
    '\r':     'r',
    '\n':     'n',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escaper = /\\|'|\r|\n|\u2028|\u2029/g;

  var escapeChar = function(match) {
    return '\\' + escapes[match];
  };

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  // NB: `oldSettings` only exists for backwards compatibility.
  _.template = function(text, settings, oldSettings) {
    if (!settings && oldSettings) settings = oldSettings;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset).replace(escaper, escapeChar);
      index = offset + match.length;

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      } else if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      } else if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }

      // Adobe VMs need the match returned to produce the correct offest.
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + 'return __p;\n';

    try {
      var render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled source as a convenience for precompilation.
    var argument = settings.variable || 'obj';
    template.source = 'function(' + argument + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function. Start chaining a wrapped Underscore object.
  _.chain = function(obj) {
    var instance = _(obj);
    instance._chain = true;
    return instance;
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var result = function(instance, obj) {
    return instance._chain ? _(obj).chain() : obj;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    _.each(_.functions(obj), function(name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result(this, func.apply(_, args));
      };
    });
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
      return result(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  _.each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return result(this, method.apply(this._wrapped, arguments));
    };
  });

  // Extracts the result from a wrapped and chained object.
  _.prototype.value = function() {
    return this._wrapped;
  };

  // Provide unwrapping proxy for some methods used in engine operations
  // such as arithmetic and JSON stringification.
  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;

  _.prototype.toString = function() {
    return '' + this._wrapped;
  };

  // AMD registration happens at the end for compatibility with AMD loaders
  // that may not enforce next-turn semantics on modules. Even though general
  // practice for AMD registration is to be anonymous, underscore registers
  // as a named module because, like jQuery, it is a base library that is
  // popular enough to be bundled in a third party lib, but not be part of
  // an AMD load request. Those cases could generate an error when an
  // anonymous define() is called outside of a loader request.
  if (typeof define === 'function' && define.amd) {
    define('underscore', [], function() {
      return _;
    });
  }
}.call(this));

},{}]},{},[25]);
