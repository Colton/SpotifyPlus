(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
module.exports = {
  "albums": "Alben",
  "all-tracks": "Alle Titel",
  "appName": "Suchen",
  "artists": "Künstler",
  "back-to-original-query": "Stattdessen nach  „{0}“ suchen.",
  "did-you-mean-1": "Meintest du  „{0}“?",
  "did-you-mean-2": "Meintest du  „{0}“ oder  „{1}“?",
  "empty-search": "Das Suchwort ist zu lang, bitte versuche es mit einem kürzeren Wort erneut.",
  "empty-search-result": "Keine Suchergebnisse für {0}.",
  "error-text": "Hoppla, da ist wohl etwas schief gelaufen.",
  "facebook-friend": "Facebook-Freund",
  "find-people-with-great-playlists": "Finde User mit tollen Playlists.",
  "followers": "Followers",
  "following": "Folge ich",
  "genres": "Genres und Stimmungen",
  "go-online-to-search": "Geh online, um Millionen von Songs zu durchsuchen.",
  "most-relevant": "Am relevantesten",
  "new": "Neu",
  "no-offline-results-found": "Keine Offline-Ergebnisse für '{0}'.",
  "no-results-found-for": "Keine Ergebnisse für '{0}'",
  "no-tracks": "Deine Suche hat keine Übereinstimmung mit unserem Katalog ergeben.  Bitte überprüfe die Schreibweise aller Worte oder versuche es mit einer anderen oder einfacheren Suche.",
  "now-you-can-search-for-users": "Jetzt kannst du nach Usern suchen!",
  "now-you-can-search-for-users-to-follow": "Jetzt kannst du nach Usern suchen, denen du folgen kannst!",
  "offline-subtitle": "Die Suchfunktion steht nicht zur Verfügung, wenn du offline bist. Stelle eine Internetverbindung her, und versuche es dann erneut.",
  "offline-title": "Gehe online, um nach Musik zu suchen",
  "playlists": "Playlists",
  "please-check-spelling": "Bitte achte darauf, dass Du alle Wörter richtig geschrieben hast, oder versuch es mit weniger oder anderen Suchwörtern.",
  "popular-tracks": "Beliebte Songs",
  "profiles": "Profile",
  "search-paragraph-albums": "Alben anzeigen für {0}.",
  "search-paragraph-artists": "Künstler anzeigen für {0}.",
  "search-paragraph-genres": "Genres und Stimmungen für {0} werden angezeigt",
  "search-paragraph-playlists": "Playlists anzeigen für {0}.",
  "search-paragraph-profiles": "Profile anzeigen für {0}.",
  "search-paragraph-results": "Ergebnisse anzeigen für {0}.",
  "search-paragraph-tracks": "Songs für {0} anzeigen",
  "search-paragraph-genre-results": "Es werden {0} Ergebnisse angezeigt.",
  "search-paragraph-genre-albums": "Es werden {0} Alben angezeigt.",
  "search-paragraph-genre-artists": "Es werden {0} Künstler angezeigt.",
  "search-paragraph-genre-playlists": "Es werden {0} Playlists angezeigt.",
  "search-paragraph-genre-profiles": "Es werden {0} Profile angezeigt.",
  "search-paragraph-genre-tracks": "{0} Songs anzeigen",
  "see-all": "Alle ansehen",
  "snapshot-failed": "Ein Fehler ist aufgetreten. Bitte versuche es erneut.",
  "tracks": "Songs",
  "try-again": "Erneut versuchen"
};
},{}],2:[function(require,module,exports){
module.exports = {
  "albums": "Άλμπουμ",
  "all-tracks": "Όλα τα τραγούδια",
  "appName": "Αναζήτηση",
  "artists": "Καλλιτέχνες",
  "back-to-original-query": "Εναλλακτικά, κάνε αναζήτηση για «{0}».",
  "did-you-mean-1": "Μήπως εννοούσες «{0}»;",
  "did-you-mean-2": "Μήπως εννοούσες «{0}» ή «{1}»;",
  "empty-search": "Η λέξη-κλειδί αναζήτησης είναι πολύ μεγάλη, δοκίμασε μια μικρότερη λέξη.",
  "empty-search-result": "Δεν υπάρχουν αποτελέσματα αναζήτησης για {0}.",
  "error-text": "Ωχ, κάτι δεν πήγε καλά. ",
  "facebook-friend": "Φίλος/η από το Facebook",
  "find-people-with-great-playlists": "Βρες άτομα που δημιουργούν εξαιρετικές λίστες.",
  "followers": "Οπαδοί",
  "following": "Aκολουθείται",
  "genres": "Είδη και διαθέσεις",
  "go-online-to-search": "Συνδέσου στο διαδίκτυο για να αναζητήσεις εκατομμύρια τραγούδια.",
  "most-relevant": "Πιο συναφή",
  "new": "Νέο",
  "no-offline-results-found": "Δεν βρέθηκαν αποτελέσματα εκτός σύνδεσης για “{0}”.",
  "no-results-found-for": "Δεν βρέθηκαν αποτελέσματα για «{0}»",
  "no-tracks": "Η αναζήτησή σου δεν ταιριάζει με κανένα τραγούδι στον κατάλογό μας. Βεβαιώσου ότι όλες οι λέξεις είναι γραμμένες σωστά. Μπορείς επίσης να δοκιμάσεις διαφορετικές ή πιο απλές αναζητήσεις.",
  "now-you-can-search-for-users": "Τώρα μπορείς να αναζητήσεις χρήστες!",
  "now-you-can-search-for-users-to-follow": "Τώρα μπορείς να αναζητήσεις τους χρήστες που θέλεις να ακολουθείς!",
  "offline-subtitle": "Η αναζήτηση δεν είναι διαθέσιμη όταν βρίσκεσαι εκτός σύνδεσης. Συνδέσου στο διαδίκτυο και δοκίμασε ξανά.",
  "offline-title": "Συνδέσου στο διαδίκτυο για να αναζητήσεις μουσική",
  "playlists": "Λίστες",
  "please-check-spelling": "Βεβαιώσου ότι έχεις γράψει σωστά τις λέξεις ή χρησιμοποίησε λιγότερες ή διαφορετικές λέξεις-κλειδιά.",
  "popular-tracks": "Δημοφιλή τραγούδια",
  "profiles": "Προφίλ",
  "search-paragraph-albums": "Εμφανίζονται τα άλμπουμ για {0}.",
  "search-paragraph-artists": "Εμφανίζονται οι καλλιτέχνες για {0}.",
  "search-paragraph-genres": "Εμφανίζει τα είδη και τις διαθέσεις για {0}.",
  "search-paragraph-playlists": "Εμφανίζονται οι λίστες για {0}.",
  "search-paragraph-profiles": "Εμφανίζονται τα προφίλ για {0}.",
  "search-paragraph-results": "Εμφανίζονται τα αποτελέσματα για {0}.",
  "search-paragraph-tracks": "Εμφανίζονται τα τραγούδια για {0}.",
  "search-paragraph-genre-results": "Εμφάνιση {0} αποτελεσμάτων.",
  "search-paragraph-genre-albums": "Εμφάνιση {0} άλμπουμ.",
  "search-paragraph-genre-artists": "Εμφάνιση {0} καλλιτεχνών.",
  "search-paragraph-genre-playlists": "Εμφάνιση {0} λιστών.",
  "search-paragraph-genre-profiles": "Εμφάνιση {0} προφίλ.",
  "search-paragraph-genre-tracks": "Εμφανίζονται {0} τραγούδια.",
  "see-all": "Δες τα όλα",
  "snapshot-failed": "Προέκυψε σφάλμα. Δοκίμασε νέα αναζήτηση.",
  "tracks": "Τραγούδια",
  "try-again": "Δοκίμασε ξανά"
};
},{}],3:[function(require,module,exports){
module.exports = {
  "albums": "Albums",
  "all-tracks": "All Songs",
  "appName": "Search",
  "artists": "Artists",
  "back-to-original-query": "Search instead for “{0}”.",
  "did-you-mean-1": "Did you mean “{0}”?",
  "did-you-mean-2": "Did you mean “{0}” or “{1}”?",
  "empty-search": "The search keyword is too long, please try something shorter.",
  "empty-search-result": "No search results for {0}.",
  "error-text": "Ooops, something went wrong.",
  "facebook-friend": "Facebook friend",
  "find-people-with-great-playlists": "Find people who make great playlists.",
  "followers": "Followers",
  "following": "Following",
  "genres": "Genres & Moods",
  "go-online-to-search": "Go online to search millions of songs.",
  "most-relevant": "Most Relevant",
  "new": "New",
  "no-offline-results-found": "No offline results found for “{0}”.",
  "no-results-found-for": "No results found for “{0}”",
  "no-tracks": "Your search did not match any songs in our catalogue. Please ensure all words are spelled correctly. You could also try different or simpler searches.",
  "now-you-can-search-for-users": "Now you can search for users!",
  "now-you-can-search-for-users-to-follow": "Now you can search for users to Follow!",
  "offline-subtitle": "Search isn't available while you're offline. Please connect to the Internet and try again.",
  "offline-title": "Go online to search for music",
  "playlists": "Playlists",
  "please-check-spelling": "Please make sure your words are spelled correctly, or use fewer or different keywords.",
  "popular-tracks": "Popular Songs",
  "profiles": "Profiles",
  "search-paragraph-albums": "Showing albums for {0}.",
  "search-paragraph-artists": "Showing artists for {0}.",
  "search-paragraph-genres": "Showing genres & moods for {0}.",
  "search-paragraph-playlists": "Showing playlists for {0}.",
  "search-paragraph-profiles": "Showing profiles for {0}.",
  "search-paragraph-results": "Showing results for {0}.",
  "search-paragraph-tracks": "Showing songs for {0}.",
  "search-paragraph-genre-results": "Showing {0} results.",
  "search-paragraph-genre-albums": "Showing {0} albums.",
  "search-paragraph-genre-artists": "Showing {0} artists.",
  "search-paragraph-genre-playlists": "Showing {0} playlists.",
  "search-paragraph-genre-profiles": "Showing {0} profiles.",
  "search-paragraph-genre-tracks": "Showing {0} songs.",
  "see-all": "See All",
  "snapshot-failed": "An error occurred. Please try searching again.",
  "tracks": "Songs",
  "try-again": "Try again"
};
},{}],4:[function(require,module,exports){
module.exports = {
  "albums": "Álbumes",
  "all-tracks": "Todas las canciones",
  "appName": "Buscar",
  "artists": "Artistas",
  "back-to-original-query": "Mostrar sólo “{0}”.",
  "did-you-mean-1": "¿Te refieres a “{0}”?",
  "did-you-mean-2": "¿Te refieres a “{0}” o “{1}”?",
  "empty-search": "El término buscado es demasiado largo; por favor, prueba con algo más corto.",
  "empty-search-result": "Sin resultados de búsqueda para {0}.",
  "error-text": "Lo sentimos, algo ha salido mal.  ",
  "facebook-friend": "Amigo de Facebook",
  "find-people-with-great-playlists": "Encuentra usuarios que hagan excelentes playlists.",
  "followers": "Seguidores",
  "following": "Siguiendo",
  "genres": "Géneros y estados de ánimo",
  "go-online-to-search": "Conéctate para buscar millones de canciones.",
  "most-relevant": "Lo más relevante",
  "new": "Nuevo",
  "no-offline-results-found": "No se encontraron resultados para \"{0}\" en modo offline.",
  "no-results-found-for": "No se encontraron resultados para \"{0}\".",
  "no-tracks": "Tu búsqueda no coincide con ninguna de las canciones incluidas en nuestro catálogo. Asegúrate de que todas las palabras estén escritas correctamente. También podrías intentar hacer una búsqueda distinta o más sencilla.",
  "now-you-can-search-for-users": "¡Ahora puedes buscar usuarios!",
  "now-you-can-search-for-users-to-follow": "¡Ahora puedes buscar usuarios para Seguir!",
  "offline-subtitle": "La búsqueda no está disponible cuando te encuentras sin conexión.  Por favor, conéctate a Internet e inténtalo nuevamente. ",
  "offline-title": "Conéctate a la red para buscar música",
  "playlists": "Playlists",
  "please-check-spelling": "Asegúrate de escribir correctamente las palabras, o utiliza menos palabras clave o palabras clave diferentes.",
  "popular-tracks": "Canciones populares",
  "profiles": "Perfiles",
  "search-paragraph-albums": "Mostrando álbumes para {0}.",
  "search-paragraph-artists": "Mostrando artistas para {0}.",
  "search-paragraph-genres": "Mostrando géneros y estados de ánimo para {0}.",
  "search-paragraph-playlists": "Mostrando playlists para {0}.",
  "search-paragraph-profiles": "Mostrando perfiles para {0}.",
  "search-paragraph-results": "Mostrando resultados para {0}.",
  "search-paragraph-tracks": "Mostrando canciones para {0}.",
  "search-paragraph-genre-results": "Mostrando {0} resultados.",
  "search-paragraph-genre-albums": "Mostrando {0} álbumes.",
  "search-paragraph-genre-artists": "Mostrando {0} artistas.",
  "search-paragraph-genre-playlists": "Mostrando {0} playlists.",
  "search-paragraph-genre-profiles": "Mostrando {0} perfiles.",
  "search-paragraph-genre-tracks": "Mostrando {0} canciones.",
  "see-all": "Ver todas",
  "snapshot-failed": "Se ha producido un error. Por favor, intenta realizar la búsqueda de nuevo.",
  "tracks": "Canciones",
  "try-again": "Intentar de nuevo"
};
},{}],5:[function(require,module,exports){
module.exports = {
  "albums": "Álbumes",
  "all-tracks": "Todas las canciones",
  "appName": "Buscar",
  "artists": "Artistas",
  "back-to-original-query": "Buscar “{0}”.",
  "did-you-mean-1": "¿Quieres decir “{0}”?",
  "did-you-mean-2": "¿Quieres decir “{0}” o “{1}”?",
  "empty-search": "El término buscado es demasiado largo; por favor, prueba con algo más corto.",
  "empty-search-result": "No hay resultados para {0}.",
  "error-text": "Vaya, algo no ha ido como debía.",
  "facebook-friend": "Amigo de Facebook",
  "find-people-with-great-playlists": "Encuentra a gente que hace playlists geniales.",
  "followers": "Seguidores",
  "following": "Siguiendo",
  "genres": "Géneros y estados de ánimo",
  "go-online-to-search": "Conéctate a Internet para buscar entre millones de canciones.",
  "most-relevant": "Más relevantes",
  "new": "Nuevo",
  "no-offline-results-found": "No se ha encontrado ningún resultado para “{0}” en el contenido sin conexión.",
  "no-results-found-for": "No se ha encontrado ningún resultado para “{0}”",
  "no-tracks": "No hemos encontrado en nuestro catálogo ninguna canción que se corresponda con esta búsqueda. Verifica que todas las palabras estén escritas correctamente. También puedes buscar con palabras distintas o más sencillas.",
  "now-you-can-search-for-users": "¡Ahora puedes buscar a usuarios!",
  "now-you-can-search-for-users-to-follow": "¡Ahora puedes buscar a usuarios para seguir!",
  "offline-subtitle": "La búsqueda no está disponible sin conexión. Por favor, conéctate a Internet y prueba de nuevo.",
  "offline-title": "Conéctate a Internet para buscar música",
  "playlists": "Playlists",
  "please-check-spelling": "Por favor, asegúrate de que las palabras estén correctamente escritas o prueba con menos palabras o con otras distintas.",
  "popular-tracks": "Canciones populares",
  "profiles": "Perfiles",
  "search-paragraph-albums": "Mostrando álbumes para {0}.",
  "search-paragraph-artists": "Mostrando artistas para {0}.",
  "search-paragraph-genres": "Mostrando géneros y estados de ánimo para {0}.",
  "search-paragraph-playlists": "Mostrando playlists para {0}.",
  "search-paragraph-profiles": "Mostrando perfiles para {0}.",
  "search-paragraph-results": "Mostrando resultados para {0}.",
  "search-paragraph-tracks": "Mostrando canciones para {0}.",
  "search-paragraph-genre-results": "Mostrando resultados con {0}.",
  "search-paragraph-genre-albums": "Mostrando álbumes con {0}.",
  "search-paragraph-genre-artists": "Mostrando artistas con {0}.",
  "search-paragraph-genre-playlists": "Mostrando playlists con {0}.",
  "search-paragraph-genre-profiles": "Mostrando perfiles con {0}.",
  "search-paragraph-genre-tracks": "Mostrando {0} canciones.",
  "see-all": "Ver todas",
  "snapshot-failed": "Se ha producido un error. Por favor, intenta buscar de nuevo.",
  "tracks": "Canciones",
  "try-again": "Probar de nuevo"
};
},{}],6:[function(require,module,exports){
module.exports = {
  "albums": "Albumit",
  "all-tracks": "Kaikki kappaleet",
  "appName": "Hae",
  "artists": "Artistit",
  "back-to-original-query": "Hae sen sijaan kohdetta {0}.",
  "did-you-mean-1": "Tarkoititko: {0}?",
  "did-you-mean-2": "Tarkoititko {0} vai {1}?",
  "empty-search": "Haettava avainsana on liian pitkä. Käytä lyhyempää sanaa.",
  "empty-search-result": "Ei hakutuloksia: {0}.",
  "error-text": "Hupsista, jotain meni vikaan.",
  "facebook-friend": "Facebook-kaveri",
  "find-people-with-great-playlists": "Etsi henkilöitä, jotka laativat hyviä soittolistoja.",
  "followers": "Seuraajat",
  "following": "Seurataan",
  "genres": "Tyylilajit & mielentilat",
  "go-online-to-search": "Siirry online-tilaan, jotta voit hakea miljoonista kappaleista.",
  "most-relevant": "Parhaiten vastaava",
  "new": "Uusi",
  "no-offline-results-found": "Hakuehdolla {0} ei löytynyt offline-tuloksia",
  "no-results-found-for": "Hakuehdolla {0} ei löytynyt tuloksia",
  "no-tracks": "Luettelostamme ei löytynyt yhtään hakuehtojasi vastaavaa kappaletta. Varmista, että hakusanat on kirjoitettu oikein. Voit myös kokeilla erilaista tai yksinkertaisempaa hakua.",
  "now-you-can-search-for-users": "Voit nyt hakea käyttäjiä!",
  "now-you-can-search-for-users-to-follow": "Voit nyt hakea seurattavia käyttäjiä!",
  "offline-subtitle": "Hakua ei voi käyttää offline-tilassa. Muodosta internetyhteys ja yritä uudelleen.",
  "offline-title": "Etsi musiikkia online-tilassa",
  "playlists": "Soittolistat",
  "please-check-spelling": "Tarkista, että kirjoitit sanat oikein, tai käytä vähemmän tai erilaisia avainsanoja.",
  "popular-tracks": "Suositut kappaleet",
  "profiles": "Profiilit",
  "search-paragraph-albums": "Näytetään albumit: {0}.",
  "search-paragraph-artists": "Näytetään artistit: {0}.",
  "search-paragraph-genres": "Näytetään tyylilajit ja mielentilat: {0}.",
  "search-paragraph-playlists": "Näytetään soittolistat: {0}.",
  "search-paragraph-profiles": "Näytetään profiilit: {0}.",
  "search-paragraph-results": "Näytetään tulokset haulle {0}.",
  "search-paragraph-tracks": "Näytetään hakua {0} vastaavat kappaleet.",
  "search-paragraph-genre-results": "Näytetään {0} tulosta.",
  "search-paragraph-genre-albums": "Näytetään {0} albumia.",
  "search-paragraph-genre-artists": "Näytetään {0} artistia.",
  "search-paragraph-genre-playlists": "Näytetään {0} soittolistaa.",
  "search-paragraph-genre-profiles": "Näytetään {0} profiilia.",
  "search-paragraph-genre-tracks": "Näytetään {0} kappaletta.",
  "see-all": "Näytä kaikki",
  "snapshot-failed": "Tapahtui virhe. Yritä hakua uudelleen.",
  "tracks": "Kappaleet",
  "try-again": "Yritä uudelleen"
};
},{}],7:[function(require,module,exports){
module.exports = {
  "albums": "Albums",
  "all-tracks": "Tous les titres",
  "appName": "Rechercher",
  "artists": "Artistes",
  "back-to-original-query": "Recherchez plutôt « {0} ».",
  "did-you-mean-1": "Voulez-vous dire « {0} »?",
  "did-you-mean-2": "Vouliez-vous dire « {0} » ou « {1} »?",
  "empty-search": "Ce mot-clé est trop long. Veuillez essayer avec un mot plus court.",
  "empty-search-result": "Aucun résultat correspondant à {0}.",
  "error-text": "Une erreur s'est produite. ",
  "facebook-friend": "Ami Facebook",
  "find-people-with-great-playlists": "Trouvez les meilleurs créateurs de listes de lecture.",
  "followers": "Abonné",
  "following": "Suivis",
  "genres": "Genres et ambiances",
  "go-online-to-search": "Connectez-vous pour accéder à des millions de titres.",
  "most-relevant": "Les plus pertinents",
  "new": "Nouveau",
  "no-offline-results-found": "Aucun résultat hors ligne correspondant à « {0} » n'a été trouvé.",
  "no-results-found-for": "Aucun résultat pour « {0} »",
  "no-tracks": "Le titre que vous cherchez ne correspond à aucun des titres de notre catalogue. Veuillez vérifier l'orthographe de chaque mot. Vous pourriez essayer une orthographe différente ou simplifier votre recherche.",
  "now-you-can-search-for-users": "Vous pouvez maintenant rechercher des utilisateurs!",
  "now-you-can-search-for-users-to-follow": "Vous pouvez maintenant rechercher des utilisateurs à suivre!",
  "offline-subtitle": "La fonction de recherche n'est pas disponible hors connexion. Connectez-vous à Internet et réessayez.",
  "offline-title": "Connectez-vous pour rechercher de la musique",
  "playlists": "Playlists",
  "please-check-spelling": "Veuillez vérifier l'orthographe, utiliser moins de mots-clés ou utiliser d'autres mots-clés.",
  "popular-tracks": "Titres les plus écoutés",
  "profiles": "Profils",
  "search-paragraph-albums": "Albums correspondant à {0}.",
  "search-paragraph-artists": "Artistes correspondant à {0}.",
  "search-paragraph-genres": "Genres et ambiances correspondant à {0}.",
  "search-paragraph-playlists": "Listes de lecture correspondant à {0}.",
  "search-paragraph-profiles": "Profils correspondant à {0}.",
  "search-paragraph-results": "Résultats correspondant à {0}.",
  "search-paragraph-tracks": "Titres correspondant à {0}.",
  "search-paragraph-genre-results": "{0} résultats affichés.",
  "search-paragraph-genre-albums": "{0} albums affichés.",
  "search-paragraph-genre-artists": "{0} artistes affichés.",
  "search-paragraph-genre-playlists": "{0} listes de lecture affichées.",
  "search-paragraph-genre-profiles": "{0} profils affichés.",
  "search-paragraph-genre-tracks": "{0} titres affichés.",
  "see-all": "Voir tout",
  "snapshot-failed": "Une erreur est survenue. Veuillez relancer votre recherche.",
  "tracks": "Titres",
  "try-again": "Réessayer"
};
},{}],8:[function(require,module,exports){
module.exports = {
  "albums": "Albums",
  "all-tracks": "Tous les titres",
  "appName": "Recherche",
  "artists": "Artistes",
  "back-to-original-query": "Essayez de rechercher “{0}”.",
  "did-you-mean-1": "Voulez-vous dire “{0}” ?",
  "did-you-mean-2": "Voulez-vous dire “{0}” ou “{1}” ?",
  "empty-search": "Ce mot-clé est trop long, essayez un mot plus court.",
  "empty-search-result": "Aucun résultat correspondant à {0}.",
  "error-text": "Une erreur s'est produite. ",
  "facebook-friend": "Ami Facebook",
  "find-people-with-great-playlists": "Trouvez les meilleurs créateurs de playlists.",
  "followers": "Abonnés",
  "following": "Abonné",
  "genres": "Genres et ambiances",
  "go-online-to-search": "Connectez-vous pour rechercher parmi des millions de titres.",
  "most-relevant": "Les plus pertinents",
  "new": "Nouveau",
  "no-offline-results-found": "Aucun résultat pour « {0} »",
  "no-results-found-for": "Aucun résultat pour « {0} »",
  "no-tracks": "Nous n'avons trouvé aucun titre correspondant à votre recherche. Vérifiez l’orthographe de chaque mot. Vous pouvez aussi essayer de les écrire différemment ou de simplifier votre recherche.",
  "now-you-can-search-for-users": "Vous pouvez maintenant rechercher des utilisateurs !",
  "now-you-can-search-for-users-to-follow": "Vous pouvez maintenant rechercher des utilisateurs auxquels vous abonner !",
  "offline-subtitle": "La fonction de recherche n'est pas disponible hors connexion. Connectez-vous à Internet et réessayez.",
  "offline-title": "Connectez-vous pour rechercher de la musique",
  "playlists": "Playlists",
  "please-check-spelling": "Veuillez vérifier l'orthographe ou utiliser moins de mots-clés ou d'autres mots-clés.",
  "popular-tracks": "Titres populaires",
  "profiles": "Profils",
  "search-paragraph-albums": "Albums correspondant à {0}.",
  "search-paragraph-artists": "Artistes correspondant à {0}.",
  "search-paragraph-genres": "Afficher les genres et ambiances pour {0}",
  "search-paragraph-playlists": "Playlists correspondant à {0}.",
  "search-paragraph-profiles": "Profils correspondant à {0}.",
  "search-paragraph-results": "Résultats correspondant à {0}.",
  "search-paragraph-tracks": "Titres correspondant à {0}.",
  "search-paragraph-genre-results": "{0} résultats affichés.",
  "search-paragraph-genre-albums": "{0} albums affichés.",
  "search-paragraph-genre-artists": "{0} artistes affichés.",
  "search-paragraph-genre-playlists": "{0} playlists affichées.",
  "search-paragraph-genre-profiles": "{0} profils affichés.",
  "search-paragraph-genre-tracks": "Afficher {0} titres",
  "see-all": "Voir tout",
  "snapshot-failed": "Une erreur est survenue. Merci de relancer votre recherche.",
  "tracks": "Titres",
  "try-again": "Réessayez"
};
},{}],9:[function(require,module,exports){
module.exports = {
  "albums": "Albumok",
  "all-tracks": "Minden dal",
  "appName": "Keresés",
  "artists": "Előadók",
  "back-to-original-query": "Inkább keress erre: „{0}”.",
  "did-you-mean-1": "Erre gondoltál: „{0}”?",
  "did-you-mean-2": "Melyikre gondoltál ezek közül: „{0}” és „{1}”?",
  "empty-search": "A keresési kulcsszó túl hosszú. Próbálkozz valami rövidebbel.",
  "empty-search-result": "Nincsenek keresési eredmények ehhez: {0}.",
  "error-text": "Hoppá, valami elromlott.",
  "facebook-friend": "Facebookos ismerős",
  "find-people-with-great-playlists": "Keress olyan embereket, akik jó lejátszási listákat készítenek.",
  "followers": "Követők",
  "following": "Követések",
  "genres": "Műfajok és hangulatok",
  "go-online-to-search": "Az internethez csatlakozva zeneszámok milliói között kereshetsz.",
  "most-relevant": "A leginkább jellemző",
  "new": "Új",
  "no-offline-results-found": "Nincs offline találat a(z) „{0}” kifejezésre.",
  "no-results-found-for": "Nincs találat a(z) „{0}” kifejezésre",
  "no-tracks": "Nem találtunk semmit a katalógusunkban. Nézd meg, nem gépeltél-e el valamit. Más, esetleg egyszerűbb kifejezésekre is rákereshetsz.",
  "now-you-can-search-for-users": "Most már felhasználókat is kereshetsz!",
  "now-you-can-search-for-users-to-follow": "Most már kereshetsz követhető felhasználókat is!",
  "offline-subtitle": "A keresés nem érhető el offline üzemmódban. Kapcsolódj az internethez, és próbálkozz újra.",
  "offline-title": "Zene kereséséhez kapcsolódj az internethez",
  "playlists": "Lejátszási listák",
  "please-check-spelling": "Ellenőrizd, hogy nem gépeltél-e el valamit, esetleg próbálkozz más vagy kevesebb szóból álló kifejezéssel.",
  "popular-tracks": "Népszerű számok",
  "profiles": "Profilok",
  "search-paragraph-albums": "Albumok megjelenítése ehhez: {0}.",
  "search-paragraph-artists": "Előadók megjelenítése ehhez: {0}.",
  "search-paragraph-genres": "Stílusok és hangulatok: {0}",
  "search-paragraph-playlists": "Lejátszási listák megjelenítése ehhez: {0}.",
  "search-paragraph-profiles": "Profilok megjelenítése ehhez: {0}.",
  "search-paragraph-results": "Eredmények megjelenítése ehhez: {0}.",
  "search-paragraph-tracks": "A keresett [{0}] kifejezéshez talált számok láthatók. ",
  "search-paragraph-genre-results": "{0} találat látható.",
  "search-paragraph-genre-albums": "{0} album látható.",
  "search-paragraph-genre-artists": "{0} előadó látható.",
  "search-paragraph-genre-playlists": "{0} lejátszási lista látható.",
  "search-paragraph-genre-profiles": "{0} profil látható.",
  "search-paragraph-genre-tracks": "{0} szám látható.",
  "see-all": "Mind",
  "snapshot-failed": "Hiba történt. Próbálkozz ismét a kereséssel.",
  "tracks": "Dalok",
  "try-again": "Próbáld meg újra"
};
},{}],10:[function(require,module,exports){
module.exports = {
  "albums": "Album",
  "all-tracks": "Semua lagu",
  "appName": "Cari",
  "artists": "Artis",
  "back-to-original-query": "Cari “{0}” sebagai gantinya.",
  "did-you-mean-1": "Apakah Maksudnya “{0}”?",
  "did-you-mean-2": "Apakah maksudnya “{0}” atau “{1}”?",
  "empty-search": "Kata kunci pencarian terlalu panjang, coba dengan yang lebih pendek.",
  "empty-search-result": "Tidak ada hasil pencarian untuk {0}.",
  "error-text": "Ups, ada yang salah.",
  "facebook-friend": "Teman Facebook",
  "find-people-with-great-playlists": "Cari orang yang membuat playlist keren.",
  "followers": "Pengikut",
  "following": "Mengikuti",
  "genres": "Genres & Moods",
  "go-online-to-search": "Alihkan online untuk mencari jutaan lagu.",
  "most-relevant": "Paling Relevan",
  "new": "Baru",
  "no-offline-results-found": "Tidak ditemukan hasil offline untuk “{0}”.",
  "no-results-found-for": "Tidak ditemukan hasil untuk “{0}”",
  "no-tracks": "Pencarian kamu tidak cocok dengan lagu apa pun dalam katalog kami. Pastikan semua kata dieja dengan benar. Kamu juga dapat mencoba pencarian lain atau yang lebih sederhana.",
  "now-you-can-search-for-users": "Sekarang kamu dapat mencari pengguna!",
  "now-you-can-search-for-users-to-follow": "Sekarang kamu dapat mencari pengguna untuk diikuti!",
  "offline-subtitle": "Pencarian tidak tersedia saat kamu offline. Hubungkan ke internet dan coba lagi.",
  "offline-title": "Alihkan online untuk mencari musik",
  "playlists": "Playlist",
  "please-check-spelling": "Pastikan kata-katamu dieja dengan benar, atau gunakan lebih sedikit atau kata kunci yang berbeda.",
  "popular-tracks": "Lagu Populer",
  "profiles": "Profil",
  "search-paragraph-albums": "Menampilkan album untuk {0}.",
  "search-paragraph-artists": "Menampilkan artis untuk {0}.",
  "search-paragraph-genres": "Menampilkan genres & moods untuk {0}.",
  "search-paragraph-playlists": "Menampilkan playlist untuk {0}.",
  "search-paragraph-profiles": "Menampilkan profil untuk {0}.",
  "search-paragraph-results": "Menampilkan hasil untuk {0}.",
  "search-paragraph-tracks": "Menampilkan lagu untuk {0}.",
  "search-paragraph-genre-results": "Menampilkan {0} hasil.",
  "search-paragraph-genre-albums": "Menampilkan {0} album.",
  "search-paragraph-genre-artists": "Menampilkan {0} artis.",
  "search-paragraph-genre-playlists": "Menampilkan {0} playlist.",
  "search-paragraph-genre-profiles": "Menampilkan {0} daftar putar.",
  "search-paragraph-genre-tracks": "Menampilkan {0} lagu.",
  "see-all": "Lihat Semua",
  "snapshot-failed": "Terjadi kesalahan. Coba cari lagi.",
  "tracks": "Lagu",
  "try-again": "Coba lagi"
};
},{}],11:[function(require,module,exports){
'use strict';

// This file will likely become a generated file in the future. Please
// avoid adding extra APIs or exports here.

var i18n = require('../../../libs/spotify-i18n')({
  'de': require('./de.lang'),
  'el': require('./el.lang'),
  'en': require('./en.lang'),
  'es': require('./es.lang'),
  'es-419': require('./es-419.lang'),
  'fi': require('./fi.lang'),
  'fr': require('./fr.lang'),
  'fr-CA': require('./fr-CA.lang'),
  'hu': require('./hu.lang'),
  'id': require('./id.lang'),
  'it': require('./it.lang'),
  'ja': require('./ja.lang'),
  'nl': require('./nl.lang'),
  'pl': require('./pl.lang'),
  'pt-BR': require('./pt-BR.lang'),
  'sv': require('./sv.lang'),
  'tr': require('./tr.lang'),
  'zh-Hant': require('./zh-Hant.lang'),
  'zsm': require('./zsm.lang')
});

module.exports = i18n;

},{"../../../libs/spotify-i18n":207,"./de.lang":1,"./el.lang":2,"./en.lang":3,"./es-419.lang":4,"./es.lang":5,"./fi.lang":6,"./fr-CA.lang":7,"./fr.lang":8,"./hu.lang":9,"./id.lang":10,"./it.lang":12,"./ja.lang":13,"./nl.lang":14,"./pl.lang":15,"./pt-BR.lang":16,"./sv.lang":17,"./tr.lang":18,"./zh-Hant.lang":19,"./zsm.lang":20}],12:[function(require,module,exports){
module.exports = {
  "albums": "Album",
  "all-tracks": "Tutti i brani ",
  "appName": "Cerca",
  "artists": "Artisti",
  "back-to-original-query": "Cerca piuttosto \"{0}\".",
  "did-you-mean-1": "Intendevi \"{0}\"?",
  "did-you-mean-2": "Intendevi \"{0}\" o \"{1}\"?",
  "empty-search": "Parola chiave di ricerca troppo lunga. Prova con qualcosa di più corto.",
  "empty-search-result": "Nessun risultato di ricerca per {0}.",
  "error-text": "Ops, si sono verificati degli errori.",
  "facebook-friend": "Amico su Facebook",
  "find-people-with-great-playlists": "Trova le persone che creano grandi playlist.",
  "followers": "Follower",
  "following": "Following",
  "genres": "Generi e mood",
  "go-online-to-search": "Passa online per cercare milioni di brani.",
  "most-relevant": "Più pertinenti",
  "new": "Nuova",
  "no-offline-results-found": "Nessun risultato offline trovato per \"{0}\".",
  "no-results-found-for": "Nessun risultato trovato per \"{0}\"",
  "no-tracks": "La tua ricerca non ha restituito nessun brano nel nostro catalogo. Verifica che tutte le parole siano state digitate correttamente. Puoi anche effettuare ricerche diverse o più semplici.",
  "now-you-can-search-for-users": "Ora puoi cercare gli utenti!",
  "now-you-can-search-for-users-to-follow": "Ora puoi cercare utenti da seguire!",
  "offline-subtitle": "La ricerca non è disponibile quando sei offline. Connettiti a Internet e prova di nuovo.",
  "offline-title": "Passa online per cercare musica",
  "playlists": "Playlist",
  "please-check-spelling": "Controlla di aver digitato tutte le parole correttamente o usa meno parole chiave o parole diverse.",
  "popular-tracks": "Brani popolari",
  "profiles": "Profili",
  "search-paragraph-albums": "Visualizzazione album per {0}.",
  "search-paragraph-artists": "Visualizzazione artisti per {0}.",
  "search-paragraph-genres": "Visualizzazione generi e mood per {0}.",
  "search-paragraph-playlists": "Visualizzazione playlist per {0}.",
  "search-paragraph-profiles": "Visualizzazione dei profili per {0}.",
  "search-paragraph-results": "Visualizzazione risultati per {0}.",
  "search-paragraph-tracks": "Visualizzazione brani per {0}.",
  "search-paragraph-genre-results": "{0} risultati visualizzati.",
  "search-paragraph-genre-albums": "{0} album visualizzati.",
  "search-paragraph-genre-artists": " {0} artisti visualizzati.",
  "search-paragraph-genre-playlists": "{0} playlist visualizzate.",
  "search-paragraph-genre-profiles": "{0} profili visualizzati.",
  "search-paragraph-genre-tracks": "{0} brani mostrati",
  "see-all": "Vedi tutti",
  "snapshot-failed": "Si è verificato un errore. Prova a ripetere la ricerca.",
  "tracks": "Brani",
  "try-again": "Riprova"
};
},{}],13:[function(require,module,exports){
module.exports = {
  "albums": "アルバム",
  "all-tracks": "すべての曲",
  "appName": "検索",
  "artists": "アーティスト",
  "back-to-original-query": "「{0}」の代わりに検索してください。",
  "did-you-mean-1": "「{0}」という意味ですか?",
  "did-you-mean-2": "「{0}」または「{1}」という意味ですか?",
  "empty-search": "検索キーワードが長すぎます。もっと短くしてみてください。",
  "empty-search-result": "{0}の検索結果がありません。",
  "error-text": "エラーが発生したようです。",
  "facebook-friend": "Facebookの友達",
  "find-people-with-great-playlists": "魅力的なプレイリストを作成しているユーザーを検索しましょう。",
  "followers": "フォロワー",
  "following": "フォロー中",
  "genres": "ジャンル＆気分",
  "go-online-to-search": "インターネットに接続して、何百万もの曲を検索しましょう。",
  "most-relevant": "関連性が高い順",
  "new": "新規",
  "no-offline-results-found": "オフライン検索で「{0}」に該当する結果は見つかりませんでした。",
  "no-results-found-for": "「{0}」に該当する結果は見つかりませんでした",
  "no-tracks": "検索に一致する曲がカタログ内にありません。単語の綴りが正しいか確認してください。別の単語や、別の検索方法で検索してください。",
  "now-you-can-search-for-users": "ユーザー検索が可能になりました!",
  "now-you-can-search-for-users-to-follow": "ユーザーを検索してフォローできるようになりました!",
  "offline-subtitle": "オフラインでは、検索は利用できません。インターネットに接続して、再試行してください。",
  "offline-title": "インターネットに接続して曲を検索",
  "playlists": "プレイリスト",
  "please-check-spelling": "単語の綴りが正しいか確認し、少ない単語で検索するか、別のキーワードで検索してください。",
  "popular-tracks": "人気曲",
  "profiles": "プロフィール",
  "search-paragraph-albums": "{0}のアルバムを表示しています。",
  "search-paragraph-artists": "{0}のアーティストを表示しています。",
  "search-paragraph-genres": "{0}のジャンル＆気分を表示しています。",
  "search-paragraph-playlists": "{0}のプレイリストを表示しています。",
  "search-paragraph-profiles": "{0}さんのプロフィールを表示。",
  "search-paragraph-results": "{0}の結果を表示しています。",
  "search-paragraph-tracks": "{0}の曲を表示しています。",
  "search-paragraph-genre-results": "結果を{0}個表示しています。",
  "search-paragraph-genre-albums": "アルバムを{0}枚表示しています。",
  "search-paragraph-genre-artists": "アーティストを{0}組表示しています。",
  "search-paragraph-genre-playlists": "プレイリストを{0}個表示しています。",
  "search-paragraph-genre-profiles": "プロフィールを{0}件表示しています。",
  "search-paragraph-genre-tracks": "{0}曲表示しています。",
  "see-all": "すべて表示",
  "snapshot-failed": "エラーが発生しました。もう一度検索してみてください。",
  "tracks": "ソング",
  "try-again": "再試行する"
};
},{}],14:[function(require,module,exports){
module.exports = {
  "albums": "Albums",
  "all-tracks": "Alle nummers",
  "appName": "Zoeken",
  "artists": "Artiesten",
  "back-to-original-query": "Je kan ook zoeken naar “{0}”.",
  "did-you-mean-1": "Bedoel je “{0}”?",
  "did-you-mean-2": "Bedoel je “{0}” of “{1}”?",
  "empty-search": "Het zoekwoord is te lang, probeer een kortere zoekopdracht.",
  "empty-search-result": "Geen zoekresultaten voor {0}.",
  "error-text": "Er is helaas iets mis gegaan.",
  "facebook-friend": "Facebook-vriend",
  "find-people-with-great-playlists": "Vind mensen die geweldige afspeellijsten maken.",
  "followers": "Volgers",
  "following": "Volgend",
  "genres": "Genres en stemmingen",
  "go-online-to-search": "Ga online en zoek in miljoenen nummers.",
  "most-relevant": "Meest relevant",
  "new": "Nieuw",
  "no-offline-results-found": "Geen offline resultaten gevonden voor “{0}”.",
  "no-results-found-for": "Geen resultaten gevonden voor “{0}”",
  "no-tracks": "Er zijn geen zoekresultaten in onze catalogus gevonden. Zorg ervoor dat alle woorden correct zijn gespeld. Je kunt ook een andere of eenvoudigere zoekopdracht opgeven.",
  "now-you-can-search-for-users": "Nu kun je gebruikers zoeken!",
  "now-you-can-search-for-users-to-follow": "Nu kun je gebruikers zoeken om te volgen!",
  "offline-subtitle": "De zoekfunctie is niet beschikbaar wanneer je offline bent. Maak verbinding met internet en probeer het opnieuw.",
  "offline-title": "Ga online om muziek te zoeken",
  "playlists": "Afspeellijsten",
  "please-check-spelling": "Controleer of alle woorden correct zijn gespeld, of gebruik minder of andere zoekwoorden.",
  "popular-tracks": "Populaire nummers",
  "profiles": "Profielen",
  "search-paragraph-albums": "Albums voor {0} worden getoond.",
  "search-paragraph-artists": "Artiesten voor {0} worden getoond.",
  "search-paragraph-genres": "Genres en stemmingen worden weergegeven voor {0}.",
  "search-paragraph-playlists": "Afspeellijsten voor {0} worden getoond.",
  "search-paragraph-profiles": "Profielen voor {0} worden getoond.",
  "search-paragraph-results": "Resultaten voor {0} worden getoond.",
  "search-paragraph-tracks": "Nummers voor {0} worden weergegeven.",
  "search-paragraph-genre-results": "{0} resultaten worden weergegeven.",
  "search-paragraph-genre-albums": "{0} albums worden weergegeven.",
  "search-paragraph-genre-artists": "{0} artiesten worden weergegeven.",
  "search-paragraph-genre-playlists": "{0} afspeellijsten worden weergegeven.",
  "search-paragraph-genre-profiles": "{0} profielen worden weergegeven.",
  "search-paragraph-genre-tracks": "{0}-nummers worden weergeven",
  "see-all": "Alles bekijken",
  "snapshot-failed": "Er is een fout opgetreden, probeer het opnieuw.",
  "tracks": "Nummers",
  "try-again": "Probeer het nog eens"
};
},{}],15:[function(require,module,exports){
module.exports = {
  "albums": "Albumy",
  "all-tracks": "Wszystkie utwory",
  "appName": "Szukaj",
  "artists": "Wykonawcy",
  "back-to-original-query": "Szukaj zamiast tego “{0}”.",
  "did-you-mean-1": "Czy chodzi Ci o “{0}”?",
  "did-you-mean-2": "Masz na myśli “{0}” czy “{1}”?",
  "empty-search": "Wyszukiwane wyrażenie jest za długie. Użyj czegoś krótszego.",
  "empty-search-result": "Brak wyników wyszukiwania dla {0}.",
  "error-text": "Niestety, nie udało się.",
  "facebook-friend": "Osoba znajoma z Facebooka",
  "find-people-with-great-playlists": "Wyszukuj osoby, które tworzą świetne playlisty.",
  "followers": "Obserwatorzy",
  "following": "Obserwowana",
  "genres": "Gatunki i nastroje",
  "go-online-to-search": "Przejdź do trybu online, aby wyszukiwać wśród milionów utworów.",
  "most-relevant": "Najlepiej pasujące",
  "new": "Nowość",
  "no-offline-results-found": "Brak wyników w trybie offline dla zapytania „{0}”.",
  "no-results-found-for": "Brak wyników dla: {0}",
  "no-tracks": "Do Twojego wyszukiwania nie pasuje żaden utwór z Twoich zbiorów. Sprawdź, czy nie ma błędów w pisowni. Możesz też skorzystać z innych lub prostszych metod wyszukiwania.",
  "now-you-can-search-for-users": "Teraz można też wyszukiwać użytkowników!",
  "now-you-can-search-for-users-to-follow": "Teraz można też wyszukiwać użytkowników do obserwowania!",
  "offline-subtitle": "Wyszukiwanie jest niedostępne w trybie offline. Połącz się z Internetem i spróbuj ponownie.",
  "offline-title": "Aby wyszukiwać muzykę, przejdź do trybu online",
  "playlists": "Playlisty",
  "please-check-spelling": "Upewnij się, że w wyrazach nie ma literówek lub użyj mniejszej liczby albo innych słów kluczowych.",
  "popular-tracks": "Popularne utwory",
  "profiles": "Profile",
  "search-paragraph-albums": "Oto albumy dla {0}.",
  "search-paragraph-artists": "Oto wykonawcy dla {0}.",
  "search-paragraph-genres": "Oto gatunki i nastroje dla {0}.",
  "search-paragraph-playlists": "Oto playlisty dla {0}.",
  "search-paragraph-profiles": "Oto profile dla {0}.",
  "search-paragraph-results": "Oto wyniki dla {0}.",
  "search-paragraph-tracks": "Utwory znalezione dla {0}.",
  "search-paragraph-genre-results": "Liczba wyświetlonych wyników: {0}.",
  "search-paragraph-genre-albums": "Liczba wyświetlonych albumów: {0}.",
  "search-paragraph-genre-artists": "Liczba wyświetlonych wykonawców: {0}.",
  "search-paragraph-genre-playlists": "Liczba wyświetlonych playlist: {0}.",
  "search-paragraph-genre-profiles": "Liczba wyświetlonych profili: {0}.",
  "search-paragraph-genre-tracks": "Pokaż utwory: {0}.",
  "see-all": "Zobacz wszystko",
  "snapshot-failed": "Wystąpił błąd. Spróbuj wyszukać ponownie.",
  "tracks": "Utwory",
  "try-again": "Spróbuj ponownie"
};
},{}],16:[function(require,module,exports){
module.exports = {
  "albums": "Álbuns",
  "all-tracks": "Todas as músicas",
  "appName": "Buscar",
  "artists": "Artistas",
  "back-to-original-query": "Buscar então por “{0}”.",
  "did-you-mean-1": "Você quis dizer “{0}”?",
  "did-you-mean-2": "Você quis dizer “{0}” ou “{1}”?",
  "empty-search": "A palavra-chave da busca é muito longa, tente algo mais curto.",
  "empty-search-result": "Nenhum resultado de busca para {0}.",
  "error-text": "Ôpa, algo deu errado.",
  "facebook-friend": "Amigo do Facebook",
  "find-people-with-great-playlists": "Encontrar amigos que criam ótimas playlists.",
  "followers": "Seguidores",
  "following": "Seguindo",
  "genres": "Gêneros & Momentos",
  "go-online-to-search": "Fique online para buscar milhões de músicas.",
  "most-relevant": "Mais relevantes",
  "new": "Nova",
  "no-offline-results-found": "Nenhum resultado offline encontrado para “{0}”.",
  "no-results-found-for": "Nenhum resultado encontrado para “{0}”",
  "no-tracks": "Sua busca não encontrou nenhuma música no nosso catálogo. Confira se todas as palavras estão escritas corretamente. Você também pode tentar buscas diferentes ou mais simples.",
  "now-you-can-search-for-users": "Agora você pode buscar usuários!",
  "now-you-can-search-for-users-to-follow": "Agora você pode buscar usuários para seguir!",
  "offline-subtitle": "A busca não está disponível offline. Se conecte à Internet e tente de novo.",
  "offline-title": "Fique online para buscar músicas",
  "playlists": "Playlists",
  "please-check-spelling": "Confira se você escreveu as palavras corretamente ou use menos palavras-chave ou palavras-chave diferentes.",
  "popular-tracks": "Músicas populares",
  "profiles": "Perfis",
  "search-paragraph-albums": "Mostrando álbuns para {0}.",
  "search-paragraph-artists": "Mostrando artistas para {0}.",
  "search-paragraph-genres": "Mostrando gêneros & momentos para {0}.",
  "search-paragraph-playlists": "Mostrando playlists para {0}.",
  "search-paragraph-profiles": "Mostrando perfis para {0}.",
  "search-paragraph-results": "Mostrando resultados para {0}.",
  "search-paragraph-tracks": "Mostrando músicas de {0}.",
  "search-paragraph-genre-results": "Mostrando {0} resultados.",
  "search-paragraph-genre-albums": "Mostrando {0} álbuns.",
  "search-paragraph-genre-artists": "Mostrando {0} artistas.",
  "search-paragraph-genre-playlists": "Mostrando {0} playlists.",
  "search-paragraph-genre-profiles": "Mostrando {0} perfis.",
  "search-paragraph-genre-tracks": "Mostrando {0} músicas.",
  "see-all": "Ver todos",
  "snapshot-failed": "Ocorreu um erro. Tente buscar de novo.",
  "tracks": "Músicas",
  "try-again": "Tente de novo"
};
},{}],17:[function(require,module,exports){
module.exports = {
  "albums": "Album",
  "all-tracks": "Alla spår",
  "appName": "Sök",
  "artists": "Artister",
  "back-to-original-query": "Sök efter {0} i stället.",
  "did-you-mean-1": "Menade du {0}?",
  "did-you-mean-2": "Menade du {0} eller {1}?",
  "empty-search": "Sökordet är för långt. Försök med något kortare.",
  "empty-search-result": "Inga sökresultat för {0}.",
  "error-text": "Hoppsan, något blev fel. ",
  "facebook-friend": "Facebook-vän",
  "find-people-with-great-playlists": "Sök efter användare som skapar riktigt bra spellistor.",
  "followers": "Följare",
  "following": "Följer",
  "genres": "Genrer och teman",
  "go-online-to-search": "Koppla upp dig och sök bland miljontals låtar.",
  "most-relevant": "Mest liknande",
  "new": "Ny",
  "no-offline-results-found": "Inga offlineresultat hittades för {0}.",
  "no-results-found-for": "Inga resultat för {0}",
  "no-tracks": "Sökningen matchade inga låtar i vår katalog. Kontrollera att alla ord är rätt stavade. Du kan också pröva andra eller enklare sökningar.",
  "now-you-can-search-for-users": "Nu kan du söka efter användare!",
  "now-you-can-search-for-users-to-follow": "Nu kan du söka efter användare som du vill följa!",
  "offline-subtitle": "Sökfunktionen kan inte användas i offlineläge Anslut till internet och försök igen.",
  "offline-title": "Koppla upp dig och sök efter musik",
  "playlists": "Spellistor",
  "please-check-spelling": "Kontrollera att orden är rättstavade eller använd färre eller andra sökord.",
  "popular-tracks": "Populära låtar",
  "profiles": "Profiler",
  "search-paragraph-albums": "Visar album för {0}.",
  "search-paragraph-artists": "Visar artister för {0}.",
  "search-paragraph-genres": "Visar genrer och stämningar för {0}.",
  "search-paragraph-playlists": "Visar spellistor för {0}.",
  "search-paragraph-profiles": "Visar profiler för {0}.",
  "search-paragraph-results": "Visar resultat för {0}.",
  "search-paragraph-tracks": "Visar låtar för {0}.",
  "search-paragraph-genre-results": "Visar {0} resultat.",
  "search-paragraph-genre-albums": "Visar {0} album.",
  "search-paragraph-genre-artists": "Visar {0} artister.",
  "search-paragraph-genre-playlists": "Visar {0} spellistor.",
  "search-paragraph-genre-profiles": "Visar {0} profiler.",
  "search-paragraph-genre-tracks": "Visar {0} låtar.",
  "see-all": "Visa alla",
  "snapshot-failed": "Det uppstod ett fel. Sök igen.",
  "tracks": "Låtar",
  "try-again": "Försök igen"
};
},{}],18:[function(require,module,exports){
module.exports = {
  "albums": "Albümler",
  "all-tracks": "Tüm Şarkılar",
  "appName": "Ara",
  "artists": "Sanatçılar",
  "back-to-original-query": "Onun yerine “{0}” için arama yap.",
  "did-you-mean-1": "Şunu mu demek istedin: “{0}”?",
  "did-you-mean-2": "Şunu mu demek istedin: “{0}” ya da “{1}”?",
  "empty-search": "Arama sözcüğü çok uzun, lütfen daha kısa bir şey ara.",
  "empty-search-result": "{0} için arama sonucu yok",
  "error-text": "Aman! Bir şeyler ters gitti. ",
  "facebook-friend": "Facebook arkadaşı",
  "find-people-with-great-playlists": "Harika çalma listesi yapan insanları bul.",
  "followers": "Takipçiler",
  "following": "Takip Ediliyor",
  "genres": "Türler ve Ruh Halleri",
  "go-online-to-search": "Milyonlarca şarkıyı aramak için çevrimiçi ol.",
  "most-relevant": "En Benzer",
  "new": "Yeni",
  "no-offline-results-found": "Hiç çevrimdışı sonuç bulunamadı: “{0}”",
  "no-results-found-for": "Hiç sonuç bulunamadı: “{0}”",
  "no-tracks": "Araman kataloğumuzdaki herhangi bir şarkıyla eşleşmedi. Lütfen tüm kelimelerin doğru yazıldığından emin ol. Daha farklı ya da daha basit aramalar da deneyebilirsin.",
  "now-you-can-search-for-users": "Şimdi kullanıcıları bulabilirsin!",
  "now-you-can-search-for-users-to-follow": "Şimdi Takip edeceğin kullanıcıları bulabilirsin!",
  "offline-subtitle": "Çevrimdışıyken Arama kullanılamaz. Lütfen İnternet'e bağlan ve tekrar dene.",
  "offline-title": "Müzikleri aramak için çevrimiçi ol",
  "playlists": "Çalma Listeleri",
  "please-check-spelling": "Lütfen kelimeleri doğru yazdığından emin ol ya da daha az veya farklı anahtar kelimeler kullan.",
  "popular-tracks": "Popüler Şarkılar",
  "profiles": "Profiller",
  "search-paragraph-albums": "{0} için albümler gösteriliyor.",
  "search-paragraph-artists": "{0} için sanatçılar gösteriliyor.",
  "search-paragraph-genres": "{0} için türler ve ruh halleri gösteriliyor.",
  "search-paragraph-playlists": "{0} için çalma listeleri gösteriliyor.",
  "search-paragraph-profiles": "{0} için profiller gösteriliyor.",
  "search-paragraph-results": "{0} için sonuçlar gösteriliyor.",
  "search-paragraph-tracks": "{0} için şarkılar gösteriliyor.",
  "search-paragraph-genre-results": "{0} sonuç gösteriliyor.",
  "search-paragraph-genre-albums": "{0} albüm gösteriliyor.",
  "search-paragraph-genre-artists": "{0} sanatçı gösteriliyor.",
  "search-paragraph-genre-playlists": "{0} çalma listesi gösteriliyor.",
  "search-paragraph-genre-profiles": "{0} profil gösteriliyor.",
  "search-paragraph-genre-tracks": "{0} şarkıları gösteriliyor.",
  "see-all": "Tümünü Gör",
  "snapshot-failed": "Bir hata oluştu. Lütfen tekrar aramayı dene.",
  "tracks": "Şarkılar",
  "try-again": "Tekrar dene"
};
},{}],19:[function(require,module,exports){
module.exports = {
  "albums": "專輯",
  "all-tracks": "所有歌曲",
  "appName": "搜尋",
  "artists": "藝人",
  "back-to-original-query": "重新搜尋「{0} 」。",
  "did-you-mean-1": "你是指「{0}」嗎？",
  "did-you-mean-2": "你是指「 {0}」或「{1} 」嗎？",
  "empty-search": "搜尋關鍵字太長，請再試一次。",
  "empty-search-result": "暫無 {0} 的搜尋結果。",
  "error-text": "哎呀！發生錯誤。",
  "facebook-friend": "Facebook 好友",
  "find-people-with-great-playlists": "尋找擁有精彩播放清單的朋友。",
  "followers": "關注者",
  "following": "正在關注",
  "genres": "風格與心情",
  "go-online-to-search": "請上網以搜尋百萬首歌曲。",
  "most-relevant": "相關性最高",
  "new": "新",
  "no-offline-results-found": "找不到「{0}」的離線搜尋結果。",
  "no-results-found-for": "找不到「{0}」的搜尋結果",
  "no-tracks": "我們的歌曲目錄沒有符合你搜尋的結果，請確認你所輸入的文字正確無誤。建議改用其他字彙或簡化搜尋。",
  "now-you-can-search-for-users": "現在你可搜尋使用者！",
  "now-you-can-search-for-users-to-follow": "現在你可搜尋和關注其他使用者！",
  "offline-subtitle": "離線時無法進行搜尋。請連上網路然後再試一次。",
  "offline-title": "請上網以搜尋音樂",
  "playlists": "播放列表",
  "please-check-spelling": "請確認所有拼字正確，或使用較少關鍵字或其他關鍵字。",
  "popular-tracks": "熱門歌曲",
  "profiles": "個人檔案",
  "search-paragraph-albums": "顯示搜尋專輯 {0} 的結果。 ",
  "search-paragraph-artists": "顯示藝人中的 {0} 搜尋結果。",
  "search-paragraph-genres": "顯示「{0}」風格與心情的搜尋結果。",
  "search-paragraph-playlists": "顯示播放清單中的 {0} 搜尋結果。",
  "search-paragraph-profiles": "顯示個人檔案中的 {0} 搜尋結果。",
  "search-paragraph-results": "顯示搜尋 {0} 的結果",
  "search-paragraph-tracks": "顯示 {0} 的歌曲搜尋結果。",
  "search-paragraph-genre-results": "顯示 {0} 筆搜尋結果。",
  "search-paragraph-genre-albums": "顯示 {0} 張專輯。",
  "search-paragraph-genre-artists": "顯示 {0} 位藝人。",
  "search-paragraph-genre-playlists": "顯示 {0} 個播放清單。",
  "search-paragraph-genre-profiles": "顯示 {0} 筆個人檔案。",
  "search-paragraph-genre-tracks": "顯示 {0} 首歌曲。",
  "see-all": "查看全部",
  "snapshot-failed": "發生錯誤，請再試一次。",
  "tracks": "歌曲",
  "try-again": "再試一次"
};
},{}],20:[function(require,module,exports){
module.exports = {
  "albums": "Album",
  "all-tracks": "Semua Lagu",
  "appName": "Cari",
  "artists": "Artis",
  "back-to-original-query": "Sebaiknya, cari “{0}”.",
  "did-you-mean-1": "Adakah anda maksudkan “{0}”?",
  "did-you-mean-2": "Adakah anda maksudkan “{0}” atau “{1}”?",
  "empty-search": "Kata kunci carian terlalu panjang, sila cuba yang lebih pendek.",
  "empty-search-result": "Tiada hasil carian untuk {0}.",
  "error-text": "Ooops, suatu kesilapan telah berlaku.",
  "facebook-friend": "Rakan Facebook",
  "find-people-with-great-playlists": "Cari rakan yang membuat senarai main hebat.",
  "followers": "Pengikut",
  "following": "Mengikuti",
  "genres": " Genre & Suasana Hati",
  "go-online-to-search": "Pergi ke dalam talian untuk mencari berjuta-juta lagu.",
  "most-relevant": "Paling Relevan",
  "new": "Baru",
  "no-offline-results-found": "Tiada hasil offline ditemui untuk “{0}”.",
  "no-results-found-for": "Tiada hasil ditemui untuk “{0}”",
  "no-tracks": "Carian anda tidak sepadan dengan sebarang lagu dalam katalog kami. Sila pastikan semua perkataan dieja dengan betul. Anda juga boleh mencuba carian yang berbeza atau lebih ringkas.",
  "now-you-can-search-for-users": "Kini anda boleh mencari pengguna!",
  "now-you-can-search-for-users-to-follow": "Kini anda boleh mencari pengguna untuk Diikuti!",
  "offline-subtitle": "Carian tidak tersedia semasa anda berada di luar talian. Sila sambung ke Internet dan cuba lagi.",
  "offline-title": "Pergi ke dalam talian untuk mencari muzik",
  "playlists": "Senarai Main",
  "please-check-spelling": "Sila pastikan perkataan anda dieja dengan betul atau gunakan kata kunci yang sedikit atau berbeza.",
  "popular-tracks": "Lagu Popular",
  "profiles": "Profil",
  "search-paragraph-albums": "Menunjukkan album untuk {0}.",
  "search-paragraph-artists": "Menunjukkan artis untuk {0}.",
  "search-paragraph-genres": "Menunjukkan genre & suasana untuk {0}.",
  "search-paragraph-playlists": "Menunjukkan senarai main untuk {0}.",
  "search-paragraph-profiles": "Menunjukkan profil untuk {0}.",
  "search-paragraph-results": "Menunjukkan hasil untuk {0}.",
  "search-paragraph-tracks": "Menunjukkan lagu untuk {0}.",
  "search-paragraph-genre-results": "Menunjukkan {0} keputusan.",
  "search-paragraph-genre-albums": "Menunjukkan {0} album.",
  "search-paragraph-genre-artists": "Menunjukkan {0} artis.",
  "search-paragraph-genre-playlists": "Menunjukkan {0} playlist.",
  "search-paragraph-genre-profiles": "Menunjukkan {0} profil.",
  "search-paragraph-genre-tracks": "Menunjukkan {0} lagu.",
  "see-all": "Lihat Semua",
  "snapshot-failed": "Ralat berlaku Sila cuba cari lagi.",
  "tracks": "Lagu",
  "try-again": "Cuba lagi"
};
},{}],21:[function(require,module,exports){
module.exports={
  "author": "Martin Jönsson",
  "main": "scripts/main.js",
  "name": "search",
  "version": "9.0.5",
  "license": "UNLICENSED",
  "private": true
}

},{}],22:[function(require,module,exports){
'use strict';

var config = exports;
var packagejson = require('../package.json');

config.LONER_LIMIT = {
  artists: 40,
  albums: 40,
  profiles: 40,
  playlists: 40,
  tracks: 100,
  genres: 40
};

config.MAX_WIDTH = 1416;
config.PADDING = 32;
config.MIN_WIDTH = 368;
config.ORDER = ['artists', 'albums', 'playlists', 'profiles', 'genres'];
config.MINIMAL_MARGIN = 10;
config.HEADER_SIZE = 100;

config.APP_URI = 'spotify:app:' + packagejson.name;

},{"../package.json":21}],23:[function(require,module,exports){
'use strict';

var events = require('../../../libs/spotify-events');
var layoutOrganizer = require('./layout-organizer');
var tracklist = require('./tracklist');
var render = require('./render');
var config = require('./config');
var debounce = require('mout/function/debounce');

require('../../../libs/spotify-events/contextmenu');

var Request = require('../../../libs/bfs-km-searchview').requests.Search;

var header = function () {
  'use strict';

  var query = '';
  var categories = [];
  var tracks = {};
  var width = window.innerWidth;

  var session = null;
  var logger = null;
  var context = null;

  function init(_logger, _query, _category, _session, _context) {
    session = _session;
    logger = _logger;
    context = _context;
    query = _query;
    render.query(query, 'results');

    if (!session.getOnline()) {
      onOffline();
      return;
    }

    var request;

    request = Request.create();

    request.setVersion('v2');
    request.setEndpoint('search');
    request.setQuery(query);
    request.setParameter('limit', '12');
    request.setParameter('tracks-limit', '100');

    context.sendRequest(request, {}, onData, onFail);
  }

  function onResize() {
    // windows&desktop bug when going from search to new view and back
    if (window.innerWidth === 0) {
      return;
    }
    // wsp stacks actually resize
    if (window.innerWidth - 4 === width) {
      return;
    }
    if (window.innerWidth !== width) {
      layoutOrganizer.update();
    }
    updateEvents();
  }

  var debouncedOnResize = debounce(onResize, 200);

  function listen() {
    window.addEventListener('resize', debouncedOnResize);
  }

  function unlisten() {
    window.removeEventListener('resize', debouncedOnResize);
  }

  function mangleData(json) {
    categories = [];
    config.ORDER.forEach(function (type) {
      if (json[type] && json[type].total) {
        json[type].hits.forEach(function (hit) {
          hit.title = hit.name;
        });
        // Searchview sends search-single uris in v2.
        if (type === 'genres') {
          json[type].hits.forEach(function (hit) {
            hit.uri = hit.uri.replace('spotify:app:search-single:', 'spotify:search:');
          });
        }
        categories.push({
          name: type,
          total: json[type].total,
          hits: json[type].hits
        });
      }
    });
  }

  function onData(json) {
    logger.attachData(json);

    mangleData(json);

    tracks = {};
    if (json.tracks && json.tracks.hits.length > 0) {
      tracks = json.tracks;
    }

    if (categories.length || tracks.hits) {
      logger.logSearchResults('all');
      unlisten();
      listen();
      setup();
    } else {
      logger.logSearchNoResults('all');
      document.querySelector('.s-query').classList.add('hide');
      document.documentElement.classList.add('full-height');
      var noResult = document.querySelector('.no-result');
      noResult.innerHTML = render.noResult(query);
      noResult.classList.remove('hide');
      noResult.classList.add('show-error-screen');
    }
    document.querySelector('.throbberWrapper').classList.add('hide');
  }

  function setupHeader() {
    // set the complete data.
    layoutOrganizer.init(categories, query);
    // paint
    layoutOrganizer.paint();
  }

  function updateEvents() {
    events.update();
  }

  function setup() {
    setupHeader();
    tracklist.init(logger, tracks, query, session, context);

    updateEvents();
  }

  function onFail(err) {
    console.error(err);
    document.documentElement.classList.add('full-height');
    var noResult = document.querySelector('.no-result');
    noResult.innerHTML = render.error();
    noResult.classList.remove('hide');
    noResult.classList.add('show-error-screen');
    document.querySelector('.throbberWrapper').classList.add('hide');
  }

  function onOffline() {
    tracklist.init(logger, null, query, session, context);
    var noResult = document.querySelector('.no-result');
    noResult.innerHTML = render.offline(query);
    document.querySelector('.throbberWrapper').classList.add('hide');
  }

  function detach() {
    unlisten();
    tracklist.detach();
  }

  return {
    init: init,
    onFail: onFail,
    detach: detach
  };
}();

module.exports = header;

},{"../../../libs/bfs-km-searchview":53,"../../../libs/spotify-events":90,"../../../libs/spotify-events/contextmenu":78,"./config":22,"./layout-organizer":24,"./render":28,"./tracklist":30,"mout/function/debounce":366}],24:[function(require,module,exports){
'use strict';

var config = require('./config');
var render = require('./render');
var wireframer = require('./utils/wireframer');
var fitter = require('./utils/fitter');

var CATEGORY_HEIGHT = 220;

var margin = config.MINIMAL_MARGIN;
var cols = null;
var database = null;
var total = null;
var hits = null;
var fit = null;
var wireframe = [];
var index = 0;
var leftPixels = 0;
var topPixels = 0;
var queryString = '';

/**
 * Responsible for painting one single item in the header
 *
 * @param {Object} item The item which should get painted
 * @param {integer} index The index in the loop of the item
 */
var paintItem = function paintItem(item, itemIndex) {
  return render.listItem({
    uri: item.uri,
    image: render.catImage(item),
    marginLeft: itemIndex ? margin : 0
  });
};

/**
 * Responsible for painting one row
 */
var paintRow = function paintRow() {
  var paintItems = database[index].hits.slice(0).splice(0, fit[index]);
  var itemsHTML = paintItems.map(paintItem).join('');

  var linkTitle = paintItems.length < total[index];
  // Don't show button if <3 cover fits, because of localization issues
  var showButton = fit[index] > 2 && linkTitle;

  var width = (config.HEADER_SIZE + margin) * fit[index];
  var category = database[index].name;
  var uri = config.APP_URI + ':' + encodeURIComponent(queryString) + ':' + category;
  var categoryHTML = render.category({
    height: CATEGORY_HEIGHT,
    hits: itemsHTML,
    category: category,
    left: leftPixels,
    linkTitle: linkTitle,
    showButton: showButton,
    top: topPixels,
    total: total[index],
    width: width - margin,
    uri: uri
  });

  leftPixels += width;
  index += 1;

  return categoryHTML;
};

/**
 * Responsible for painting the complete header
 */
var paint = function paint() {
  index = topPixels = leftPixels = 0;
  var headerHTML = '';

  wireframe.forEach(function (row) {
    leftPixels = 0;
    headerHTML += row.map(paintRow).join('');
    topPixels += CATEGORY_HEIGHT;
  });

  var header = document.querySelector('.s-header');
  header.className = 's-header rows-' + wireframe.length;
  header.innerHTML = headerHTML;
};

/**
 * Get the width of a scrollbar
 */
var scrollbarsize = function scrollbarsize() {
  var scrollbarWidth = 0;
  if (document.body.scrollHeight >= document.body.clientHeight) {
    var scrollDiv = document.createElement('div');
    scrollDiv.style.width = '100px';
    scrollDiv.style.height = '100px';
    scrollDiv.style.overflow = 'scroll';
    scrollDiv.style.position = 'absolute';
    scrollDiv.style.top = '-9999px';
    document.body.appendChild(scrollDiv);
    scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
    document.body.removeChild(scrollDiv);
  }
  return scrollbarWidth;
};

/**
 * Calculates sizes we need to be able to calculate the layout
 */
var setSizes = function setSizes() {
  var width = Math.min(window.innerWidth - config.PADDING * 2, config.MAX_WIDTH);
  var windowWidth = Math.max(config.MIN_WIDTH, width - scrollbarsize()); // don't go smaller than MIN_WIDTH
  cols = Math.floor((windowWidth + config.MINIMAL_MARGIN) / (config.HEADER_SIZE + config.MINIMAL_MARGIN));
  margin = Math.floor((windowWidth - cols * config.HEADER_SIZE) / (cols - 1));
};

/**
 * On resize we need to update the calculations
 */
var update = function update() {
  setSizes();
  wireframe = wireframer(hits, cols);
  fit = fitter(wireframe, hits, cols);

  paint();
};

/**
 * Initialize the module with data
 */
var init = function init(data, query) {
  database = data;
  queryString = query;

  total = database.map(function (category) {
    return category.total;
  });

  hits = database.map(function (category) {
    return category.hits.length;
  });

  update();
};

module.exports = {
  paint: paint,
  update: update,
  init: init
};

},{"./config":22,"./render":28,"./utils/fitter":35,"./utils/wireframer":38}],25:[function(require,module,exports){
'use strict';

var elements = require('../../../../libs/spotify-elements');
var cosmos = require('spotify-cosmos-api');
var config = require('../config');
var doc = elements(document);

var uiMetricsLogger = {
  query: null,
  category: null,
  logger: null
};

uiMetricsLogger.CHANNEL = 'sp://messages/v1/search_intent_id';
uiMetricsLogger.CONTEXT_MENU_CLICK_CHANNEL = 'sp://messages/v1/context_menu_click';

uiMetricsLogger.init = function (logger, query, category, session) {
  this.logger = logger;
  this.query = query;
  this.category = category;
  this.session = session;
  this.hasSearchIntentID = false;
  this.timerCounter = 0;
  this.getSearchIntentID();
};

uiMetricsLogger.subscribeForSearchIntentID = function (callback) {
  cosmos.resolver.subscribe(this.CHANNEL, function (error, response) {
    if (error) return;

    try {
      var json = JSON.parse(response.getBody());
      // Check if json is valid, has to be from suggest and have search_intent_id.
      // If the query is empty it means search got loaded from url navigation and that's ok.
      // But if it has a query, make sure it's the same as in the search app since
      // otherwise other stacks of search will get updated.
      var validJson = json.sender === 'suggest' && json.search_intent_id && (!json.query || json.query === this.query);
      if (validJson) {
        this.hasSearchIntentID = this.session.getPlatform() === 'web';
        if (callback) {
          callback(json.search_intent_id);
        }
      }
    } catch (e) {
      // continue regardless of error
    }
  }.bind(this));
  cosmos.resolver.subscribe(this.CONTEXT_MENU_CLICK_CHANNEL, function (error, response) {
    if (error) {
      return;
    }
    try {
      var body = JSON.parse(response.getBody());
      if (body.appURI === config.APP_URI) {
        this.logger.logSearchContextMenu(body.id);
      }
    } catch (exception) {
      // continue regardless of error
    }
  }.bind(this));
};

uiMetricsLogger.getSearchIntentID = function () {
  if (this.hasSearchIntentID) return;

  cosmos.resolver.post({
    url: this.CHANNEL,
    body: {
      sender: 'search'
    }
  });

  // on web, try again for 15 seconds until we get it, this is helpful if search gets
  // loaded from url navigation, in which case suggest will not be completely loaded.
  if (this.session.getPlatform() === 'web') {
    if (this.timerCounter < 15) {
      this.timerCounter++;
      setTimeout(this.getSearchIntentID.bind(this), 1000);
    }
  }
};

var SELECTORS = {
  artistNameInAlbumCover: '.mo-subtitle > [data-log-click="artist-name"]',
  playlistOwnerInPlaylistCover: '.mo-subtitle > [data-log-click="owner-name"]',
  coverImage: '[data-log-click="media-image"]',
  coverTitle: '[data-log-click="media-title"]',
  playButton: '[data-log-click="play-button"]',
  seeAll: '.see-all',
  seeAllTitle: '.title.link',
  trackRow: '[data-list-item]',
  artistNameInTracklist: '[data-log-context="artist-cell"] > [data-log-click="artist-name"]',
  albumNameInTracklist: '[data-log-context="album-cell"] > [data-log-click="album-name"]'
};

uiMetricsLogger.attach = function () {
  doc.delegate('click', SELECTORS.coverImage, function (event, element) {
    this.logger.logSearchResultsCoverImage(element.data('uri'));
  }.bind(this));

  doc.delegate('click', SELECTORS.coverTitle, function (event, element) {
    this.logger.logSearchResultsCoverTitle(element.data('uri'));
  }.bind(this));

  doc.delegate('click', SELECTORS.seeAll, function (event, element) {
    this.logger.logSearchResultsSeeAll(element.data('category'));
  }.bind(this));

  doc.delegate('click', SELECTORS.seeAllTitle, function (event, element) {
    this.logger.logSearchResultsSeeAll(element.data('category'));
  }.bind(this));

  doc.delegate('click', SELECTORS.playButton, function (event, element) {
    this.logger.logSearchResultsPlayButton(element.parent('[data-uri]').data('uri'));
  }.bind(this));

  doc.delegate('dblclick', SELECTORS.trackRow, function (event, element) {
    this.logger.logSearchResultsPlayTrackInTracklist(element.data('uri'));
  }.bind(this));

  doc.delegate('click', SELECTORS.artistNameInAlbumCover, function (event, element) {
    this.logger.logSearchResultsArtistNameInAlbumCover(element.data('uri'));
  }.bind(this));

  doc.delegate('click', SELECTORS.playlistOwnerInPlaylistCover, function (event, element) {
    this.logger.logSearchResultsPlaylistOwnerInPlaylistCover(element.data('uri'));
  }.bind(this));

  doc.delegate('click', SELECTORS.artistNameInTracklist, function (event, element) {
    this.logger.logSearchResultsArtistNameInTracklist(element.data('uri'), element.parent('[data-uri]').data('uri'));
  }.bind(this));

  doc.delegate('click', SELECTORS.albumNameInTracklist, function (event, element) {
    this.logger.logSearchResultsAlbumNameInTracklist(element.data('uri'), element.parent('[data-uri]').data('uri'));
  }.bind(this));
};

module.exports = uiMetricsLogger;

},{"../../../../libs/spotify-elements":70,"../config":22,"spotify-cosmos-api":416}],26:[function(require,module,exports){
'use strict';

var live = require('../../../libs/spotify-live');
var events = require('../../../libs/spotify-events');
var LonerScroller = require('./scrollers/lego-scroller');
var tracklist = require('./tracklist');
var render = require('./render');
var config = require('./config');
var $ = require('../../../libs/spotify-elements');
var lonerContainerTemplate = require('../templates/loner-container.hbs');

var loadMoreURI = null;
var model = null;
var query = null;
var category = null;
var list = null;
var scroller = null;

var session = null;
var logger = null;
var context = null;

var Request = require('../../../libs/bfs-km-searchview').requests.Search;

function init(_logger, _query, _category, _session, _context) {
  session = _session;
  logger = _logger;
  context = _context;

  query = _query;
  category = '' + _category;
  render.query(query, category);

  var request;

  request = Request.create();

  request.setVersion('v2');
  request.setEndpoint('search-' + category);
  request.setQuery(query);
  request.setParameter(category + '-limit', '' + config.LONER_LIMIT[category]);

  context.sendRequest(request, {}, onData, onFail);
}

function detach() {
  if (list) {
    list.off('wait', onHitsWait);
  }
  if (scroller) {
    scroller.detach();
  }
  tracklist.detach();
}

function onHitsWait(ranges) {
  if (!loadMoreURI) {
    return;
  }

  document.querySelector('.throbberLoader').classList.remove('hide');

  var success;
  var failure;

  success = function success(json) {
    document.querySelector('.throbberLoader').classList.add('hide');
    logger.attachData(json);
    updateData(json[category], ranges[0].start);
  };

  failure = function failure() {
    document.querySelector('.throbberLoader').classList.add('hide');
  };

  context.send(loadMoreURI, {}, success, failure);
}

function onData(json) {
  logger.attachData(json);

  if (json[category].hits.length === 0) {
    logger.logSearchNoResults(category);
    document.querySelector('.s-query').classList.add('hide');
    document.documentElement.classList.add('full-height');
    var noResult = document.querySelector('.no-result');
    noResult.innerHTML = render.noResult(query);
    noResult.classList.remove('hide');
    noResult.classList.add('show-error-screen');
  } else {
    logger.logSearchResults(category);
    if (category === 'tracks') {
      tracklist.init(logger, json[category], query, session, context);
    } else {
      initLoner(json[category]);
    }
  }

  document.querySelector('.throbberWrapper').classList.add('hide');
}

function mangle(data) {
  data.hits.forEach(function (hit) {
    hit.title = hit.name;
  });
  // Searchview sends search-single uris in v2.
  if (category === 'genres') {
    data.hits.forEach(function (hit) {
      hit.uri = hit.uri.replace('spotify:app:search-single:', 'spotify:search:');
    });
  }
  return data;
}

function updateData(_data, index) {
  var data = mangle(_data);

  var hitsHTML = data.hits.map(function (item) {
    return {
      html: render.catImage(item)
    };
  });

  // hack, otherwise the cb in .query(cb) in scroller will never run
  for (var i = hitsHTML.length; i < config.LONER_LIMIT[category]; i++) {
    hitsHTML[i] = {
      html: ''
    };
  }

  list.update([{
    type: 'insert',
    index: index || 0,
    values: hitsHTML
  }]);

  loadMoreURI = data.loadMoreURI;
  if (scroller) {
    scroller.completed = !loadMoreURI;
  }
}

function initLoner(data) {
  var uri = 'spotify:search:loner:' + query;
  model = live({
    hits: [],
    uri: uri
  });
  list = model.get('hits');

  updateData(data);
  list.on('wait', onHitsWait);

  list.query('[0:' + data.hits.length + '](html)', function (err, json) {
    document.querySelector('.s-list').innerHTML = lonerContainerTemplate(json);
    var scrollerNode = $('[data-scroll-container="true"]');
    scroller = new LonerScroller(scrollerNode, uri);
    scroller.attach();
    scroller.update();
    events.update();
  });
}

function onFail() {
  document.documentElement.classList.add('full-height');
  var noResult = document.querySelector('.no-result');
  noResult.innerHTML = render.error();
  noResult.classList.remove('hide');
  noResult.classList.add('show-error-screen');
  document.querySelector('.throbberWrapper').classList.add('hide');
}

module.exports = {
  init: init,
  detach: detach
};

},{"../../../libs/bfs-km-searchview":53,"../../../libs/spotify-elements":70,"../../../libs/spotify-events":90,"../../../libs/spotify-live":251,"../templates/loner-container.hbs":42,"./config":22,"./render":28,"./scrollers/lego-scroller":29,"./tracklist":30}],27:[function(require,module,exports){
'use strict';

var glue = require('../../../libs/spotify-glue-cat');
glue.gridOverlay.listen();

var live = require('../../../libs/spotify-live');
require('../../../libs/spotify-live-models/client').register();
require('../../../libs/spotify-live-models/add').register();
require('../../../libs/spotify-live-models/application').register();
require('../../../libs/spotify-live-models/player').register();
require('../../../libs/spotify-live-models/client-storage').register();
require('../../../libs/spotify-live-models/session-storage').register();
require('../../../libs/spotify-live-models/list-variant').register();
require('../../../libs/spotify-live-models/sortlist').register();

var events = require('../../../libs/spotify-events');
events.attach();
events.update();

var locale = window.__spotify && window.__spotify.locale || 'en';

var handlebars = require('../../../libs/spotify-handlebars');
var helpers = require('../../../libs/spotify-handlebars/helpers');
var strings = require('../i18n/index.js');
var glueStrings = require('../../../libs/spotify-glue-cat/strings/index.js');
helpers.loc.register(glueStrings[locale]);
helpers.loc.register(strings.appStrings());
helpers.numeral.setLocale(locale);
handlebars.register(helpers);

var areArgumentsOK = require('./utils/are-arguments-ok');
var header = require('./header');
var loner = require('./loner');
var config = require('./config');
var templateBootstrap = require('../templates/bootstrap.hbs');
var uiMetricsLogger = require('./logging/ui-metrics-logger');

var Context = require('../../../libs/bfs-km-searchview').Context;
var Logger = require('../../../libs/bfs-km-logger').Logger;
var Session = require('../../../libs/bfs-km-session').Session;
var types = require('bfs-km-types');
var debounce = require('mout/function/debounce');

var vm = null;
var query = null;
var category = null;
var argz = null;

var session = null;
var logger = null;
var context = null;
var online = null;

var run = function run() {
  if (vm) {
    vm.detach();
  }

  document.documentElement.classList.add(session.getPlatform());
  document.querySelector('.container').innerHTML = templateBootstrap();
  events.update();

  var args = argz.split(':');
  if (!areArgumentsOK(args)) {
    header.onFail('Error: Arguments.');
    return;
  }

  category = args.length > 1 ? args[args.length - 1] : 'all';
  if (category && (!! ~config.ORDER.indexOf(category) || category === 'tracks')) {
    args.splice(-1, 1);
  } else {
    category = 'all';
  }

  query = args.join(':');

  logger.setQuery(query);

  uiMetricsLogger.init(logger, query, category, session);

  if (category !== 'all') {
    logger.setPage(3);
    document.documentElement.classList.add('loner');
    vm = loner;
  } else {
    logger.setPage(2);
    vm = header;
  }

  vm.init(logger, query, category, session, context);
};

// Hack: since tracklist initializes asynchronously after a local-files request,
// it's possible to init twice at once (i.e. once from onSessionChange and once
// from parseArguments) introducing a race condition where detach() can fail to
// teardown the first instance. This is a quick workaround until the app can be
// restructured.
run = debounce(run, 500, true);

var parseArguments = function parseArguments(data) {
  var properArguments = data && data.arguments && data.arguments !== argz;
  if (properArguments) {
    argz = data.arguments;
    run();
  }
};

var onSessionChange = function onSessionChange(json) {
  if (types.conforms(json, { 'online': false })) {
    if (json.online !== online) {
      online = json.online;

      run();
    }
  }
};

var init = function init() {
  session = new Session();
  logger = Logger.create(session);
  context = Context.create(session, live);

  uiMetricsLogger.attach();
  uiMetricsLogger.subscribeForSearchIntentID(function (searchIntentId) {
    logger.setSearchIntentId(searchIntentId);
  });
  live('spotify:application').query('arguments', function (err, data) {
    parseArguments(data);
  }).on('update', function (data) {
    parseArguments(data);
  });

  // This workaround enables the first sort of the popularity column to be descending
  // (most popular at the top). As of August 4, 2015, the search app is the only app
  // where sorting by popularity is possible. This should be generalized (i.e. allow
  // a column data attribute to specify natural sort direction) so other apps can
  // sort by popularity.
  live.subscribe(/(^spotify:track:|^spotify:local:)/, 'wait', function (track, properties) {
    if (properties.indexOf('negPopularity') > -1) {
      track.update({
        negPopularity: -1 * track.get('popularity')
      });
    }
  });

  var client = live('spotify:client');

  client.query('session(online)', function (error, json) {
    if (types.conforms(json, { 'session': {} })) {
      onSessionChange(json.session);
    }

    client.get('session').on('update', function (sessionJson) {
      onSessionChange(sessionJson);
    });
  });
};

init();

require('../../../libs/spotify-expose-dev-mode-debug-globals/bridge').init();
require('../../../libs/spotify-expose-dev-mode-debug-globals/live').init();
require('../../../libs/spotify-expose-dev-mode-debug-globals/cosmos').init();

},{"../../../libs/bfs-km-logger":47,"../../../libs/bfs-km-searchview":53,"../../../libs/bfs-km-session":61,"../../../libs/spotify-events":90,"../../../libs/spotify-expose-dev-mode-debug-globals/bridge":133,"../../../libs/spotify-expose-dev-mode-debug-globals/cosmos":134,"../../../libs/spotify-expose-dev-mode-debug-globals/live":136,"../../../libs/spotify-glue-cat":156,"../../../libs/spotify-glue-cat/strings/index.js":159,"../../../libs/spotify-handlebars":204,"../../../libs/spotify-handlebars/helpers":195,"../../../libs/spotify-live":251,"../../../libs/spotify-live-models/add":212,"../../../libs/spotify-live-models/application":218,"../../../libs/spotify-live-models/client":220,"../../../libs/spotify-live-models/client-storage":219,"../../../libs/spotify-live-models/list-variant":221,"../../../libs/spotify-live-models/player":226,"../../../libs/spotify-live-models/session-storage":230,"../../../libs/spotify-live-models/sortlist":238,"../i18n/index.js":11,"../templates/bootstrap.hbs":39,"./config":22,"./header":23,"./logging/ui-metrics-logger":25,"./loner":26,"./utils/are-arguments-ok":33,"bfs-km-types":303,"mout/function/debounce":366}],28:[function(require,module,exports){
'use strict';

var loc = require('../../../libs/spotify-handlebars/helpers/loc');
var catMediaObject = require('../../../libs/spotify-glue-cat/templates/v1/media-object.hbs');
var type = require('../../../libs/spotify-handlebars/util/type');
var locale = window.__spotify && window.__spotify.locale || 'en';
var numberFormat = new Intl.NumberFormat(locale);
var templateSearchParagraph = require('../templates/search-paragraph.hbs');
var templateCategory = require('../templates/category.hbs');
var templateListItem = require('../templates/list-item.hbs');
var templateErrorAndOffline = require('../../../libs/spotify-glue-cat/templates/v1/error-and-offline.hbs');

var render = function () {
  'use strict';

  var parseItemForCat = function parseItemForCat(item) {
    var modifiers = [];
    var itemType;

    if (/^spotify:app:/.test(item.uri)) {
      itemType = 'app';
    } else {
      itemType = type(item.uri);
    }

    if (item.image === null || item.image === undefined) {
      modifiers.push('show-placeholder');
    }

    item.imageUrl = item.image || '';

    if (item.artists) {
      // save default artists
      item._artists = item._artists || item.artists;

      item.artists = {
        name: item._artists[0].name,
        uri: item._artists[0].uri
      };
    }

    if (item.verified) {
      modifiers.push('verified');
    }

    if (itemType === 'user' || itemType === 'app') {
      modifiers.push('media-object-link');
    }

    if (item.author) {
      var uri = item.uri.split(':').splice(0, 3).join(':');
      item.owner = {
        name: item.author,
        uri: uri
      };
    }

    // Some users/playlists might have follower count or not, force meta to ' ' to not break layout.
    if (itemType === 'user' || itemType === 'playlist') {
      if (item.following) {
        item.meta = loc('following');
      } else if (item.facebook) {
        item.meta = loc('facebook-friend');
      }

      var followers = '';
      if (typeof item.followersCount === 'number') {
        followers = numberFormat.format(item.followersCount) + ' ' + loc('followers');
      }

      if (item.meta && followers) {
        item.meta += ' • ' + followers;
      } else if (followers) {
        item.meta = followers;
      } else {
        item.meta = item.meta || ' ';
      }
    } else if (itemType === 'artist') {
      item.meta = item.following ? loc('following') : ' ';
    }

    if (!(item.artists || item.owner)) {
      item.hideSubtitle = true;
    }

    item.modifiers = modifiers.join(' ');
  };

  var catImage = function catImage(item) {
    parseItemForCat(item);
    return catMediaObject(item);
  };

  var listItem = function listItem(item) {
    return templateListItem(item);
  };

  var category = function category(categoryData) {
    return templateCategory(categoryData);
  };

  var query = function query(_queryValue, categoryData) {
    var queryValue = _queryValue;
    var localizationString = 'search-paragraph-';

    if (queryValue.indexOf('genre:') === 0) {
      // Remove genre:, and any ""
      queryValue = queryValue.replace(/genre:/, '').replace(/"/g, '');
      localizationString += 'genre-';
    }

    document.querySelector('.s-query').innerHTML = templateSearchParagraph({
      searchParagraph: loc(localizationString + categoryData, queryValue)
    });
    document.querySelector('.s-query').classList.remove('hide');
  };

  var noResult = function noResult(queryValue) {
    return templateErrorAndOffline({
      errorTitle: loc('no-results-found-for', queryValue),
      errorMessage: loc('please-check-spelling')
    });
  };

  var error = function error() {
    return templateErrorAndOffline({
      errorTitle: loc('snapshot-failed')
    });
  };

  var offline = function offline(queryValue) {
    return templateErrorAndOffline({
      offlineTitle: loc('no-offline-results-found', queryValue),
      offlineMessage: loc('go-online-to-search')
    });
  };

  return {
    catImage: catImage,
    listItem: listItem,
    category: category,
    query: query,
    noResult: noResult,
    error: error,
    offline: offline
  };
}();

module.exports = render;

},{"../../../libs/spotify-glue-cat/templates/v1/error-and-offline.hbs":160,"../../../libs/spotify-glue-cat/templates/v1/media-object.hbs":162,"../../../libs/spotify-handlebars/helpers/loc":197,"../../../libs/spotify-handlebars/util/type":206,"../templates/category.hbs":40,"../templates/list-item.hbs":41,"../templates/search-paragraph.hbs":44}],29:[function(require,module,exports){
'use strict';

var prime = require('prime');
var forEach = require('mout/array/forEach');
var indexOf = require('mout/array/indexOf');
var forIn = require('mout/object/forIn');
var kindOf = require('mout/lang/kindOf');
var Emitter = require('prime/emitter'); // this is only to be able to pass EMIT_SYNC

var $ = require('../../../../libs/spotify-elements');

var zen = require('../../../../libs/spotify-elements/zen');

var live = require('../../../../libs/spotify-live');

var throttle = require('../../../../libs/spotify-events/util/throttle');
var center = require('../../../../libs/spotify-events/center');

var config = require('../config');
var pageTemplate = require('../../templates/loner-page.hbs');

var Scroller = prime({

  /**
   * An infinite scroller helper.
   *
   * @constructs
   *
   * @param {HTMLElement|elements} containerNode An element that is the
   *     container for the pages of items.
   */
  constructor: function Scroller(containerNode, uri) {
    this.container = $(containerNode);
    this.modelURI = uri;
    this.pages = [];

    this.paused = false;
    this.completed = false;
    this.lastPageOffset = 0;
    this.numberOfItems = 0;
    this.threshold = 2000;
    this.requestsForNodes = [];

    this.setupContainer();
  },

  /**
   * Attach the scroller.
   * This starts listening to scroll events.
   */
  attach: function attach() {
    this.updateWithThrottling = throttle(this.update, this);
    $(window).on('scroll', this.updateWithThrottling);
    this.updateWithThrottling();
  },

  /**
   * Detach the scroller.
   * This stops listening to scroll events.
   */
  detach: function detach() {
    $(window).off('scroll', this.updateWithThrottling);
  },

  /**
   * Set up the container node with filler nodes in the top
   * and bottom and some state data.
   */
  setupContainer: function setupContainer() {
    var container = this.container;

    if (container._hasScrollData) return;
    container._hasScrollData = true;

    // Create empty placeholders that will replace page nodes
    var topFiller = zen('div.scroll-filler-top');
    var bottomFiller = zen('div.scroll-filler-bottom');
    topFiller.top(container);
    bottomFiller.bottom(container);
    container._topFiller = topFiller;
    container._bottomFiller = bottomFiller;
    topFiller._height = 0;
    bottomFiller._height = 0;

    var offset = container.offset = this.getElementOffset(container);
    this.lastPageOffset = offset;

    // Find all page containers inside this container
    var pageNodes = container.children('[data-scroll-page=true]');
    if (pageNodes) {
      forEach(pageNodes, function (page) {
        this.addNewPage($(page));
      }.bind(this));
    }
  },

  /**
   * Add a new page to the bottom of the page storage.
   * This does not actually add it to the DOM.
   *
   * @param {HTMLElement|elements} page The page node.
   * @param {number} pageHeight The height of the page.
   */
  addNewPage: function addNewPage(page, pageHeight) {
    var height = pageHeight || page[0].getBoundingClientRect().height;

    page.pageHeight = height;
    page.pageOffset = this.lastPageOffset;
    page.numItems = (page.search('[data-scroll-page-item=true]') || { length: 0 }).length;

    this.lastPageOffset += page.pageHeight;
    this.pages.push(page);
    this.numberOfItems += page.numItems;
  },

  /**
   * Hide a page of items from the DOM.
   * This will replace a page of items with empty space
   * in one of the filler elements.
   *
   * @param {HTMLElement|elements} page The page node.
   * @param {string} side What side to hide it from ('top' or 'bottom').
   */
  hidePage: function hidePage(page, side) {
    var container = page.parent();
    if (!container) return;

    page.remove();
    page._container = container;
    page._removedFromSide = side;
  },

  /**
   * Show a page of items in the DOM.
   *
   * @param {HTMLElement|elements} page The page node.
   * @param {HTMLElement|elements} previousPage The previous page node.
   */
  showPage: function showPage(page, previousPage) {
    if (page.parent()) return;

    var container = page._container;
    if (!container) return;

    center.emit('scroll-show-before', { container: container, pageNode: page }, Emitter.EMIT_SYNC);

    var side = page._removedFromSide;

    if (side === 'top') {
      page.after(previousPage);
    } else {
      page.before(container._bottomFiller);
    }

    center.emit('scroll-show-after', { container: container, pageNode: page });
  },

  /**
   * Get the pages that are currently in view for this container.
   * It might include pages that are not really visible, but
   * within the threshold.
   *
   * @param {number} scrollPosition The scroll position to check for.
   *
   * @return {Array.<HTMLElement>} An array of pge nodes.
   */
  getPagesInView: function getPagesInView(scrollPosition) {
    var topEdge = scrollPosition - this.threshold;
    var bottomEdge = scrollPosition + window.innerHeight + this.threshold;

    var pagesInView = [];

    // Check all pages in each container
    forEach(this.pages, function (page) {
      if (page.pageOffset + page.pageHeight > topEdge && page.pageOffset < bottomEdge) {
        pagesInView.push(page);
      }
    });

    return pagesInView;
  },

  /**
   * Request a new page of items.
   * If a previous request is not done yet, this will just return.
   *
   * @param {HTMLElement|elements} pageNode The page node.
   */
  requestNewPage: function requestNewPage(previousPageNode) {
    var previousPage = $(previousPageNode);

    var requestsForNodes = this.requestsForNodes;
    if (indexOf(requestsForNodes, previousPage) > -1) return;

    requestsForNodes.push(previousPage);

    var uri = this.modelURI;
    if (!uri) return;

    var collectionProperty = 'hits';
    var itemProperties = 'html';

    // Create the query string to get the data we need
    var itemOffset = this.numberOfItems;
    var pageSize = config.LONER_LIMIT.artists;
    var start = itemOffset;
    var end = itemOffset + pageSize;
    var query = 'uri,' + collectionProperty + '[' + start + ':' + end + '](' + itemProperties + ')';

    live(uri).query(query, function (error, data) {
      if (error) throw error;

      // Decorate the data, collect the URIs
      forEach(data[collectionProperty], function (item, i) {
        item.index = start + i;
        item.number = item.index + 1;
        forIn(item, function (value) {
          if (kindOf(value) === 'Array') {
            var lastArrayItem = value[value.length - 1];
            if (kindOf(lastArrayItem) === 'Object') {
              lastArrayItem.last = true;
            }
          }
        });
      });

      var container = this.container;

      var html = pageTemplate(data);
      var pageNode = $(zen('div').html(html).children()[0]);

      center.emit('scroll-show-before', { container: container, pageNode: pageNode }, Emitter.EMIT_SYNC);

      // Insert it into the DOM and storage.
      // If the previous page is still in the DOM, we add this page after that one.
      // If the previous page is NOT still in the DOM (this happens if you scroll
      // up again before the new page has been loaded), we must temporarily add
      // the new page to the DOM to get its dimensions, and then we manually
      // substitute the page with a higher filler node in the bottom.
      var pageHeight;
      if (previousPage.parent()) {
        pageNode.after(previousPage);
        pageHeight = pageNode[0].getBoundingClientRect().height;
      } else {
        // Get dimensions.
        container.appendChild(pageNode);
        pageHeight = pageNode[0].getBoundingClientRect().height;

        // Hide the page (this removes it from DOM and sets needed properties).
        this.hidePage(pageNode, 'bottom');

        // Substitute the page with more space in the filler node.
        var filler = container._bottomFiller;
        filler._height += pageHeight;
        filler[0].style.height = filler._height + 'px';
      }
      this.addNewPage(pageNode, pageHeight);
      center.emit('scroll-show-after', { container: container, pageNode: pageNode });

      // Remove it from the temporary storage to let the script
      // know that it is no longer waiting for the next page.
      var index = requestsForNodes.indexOf(previousPage);
      if (index > -1) requestsForNodes.splice(index, 1);

      // Check boundaries again to see if we need to get more data
      this.updateWithThrottling();
    }.bind(this));
  },

  /**
   * Get the scrollTop
   *
   * @return {number} The amount of pixels from the top.
   */
  getScrollTop: function getScrollTop() {
    return document.body.scrollTop || document.documentElement.scrollTop;
  },

  /**
   * Get the Y offset for an element, relative to the top of the document.
   *
   * @param  {elements} node An elements instance.
   *
   * @return {number} The Y offset.
   */
  getElementOffset: function getElementOffset(node) {
    return node[0].getBoundingClientRect().top + this.getScrollTop();
  },

  /**
   * Update the DOM to only have the needed pages of items.
   */
  update: function update() {
    if (this.paused) return;
    if (this.pages.length === 0) return;

    // Get all pages that are currently in view (or close to)
    var threshold = this.threshold;
    var scrollTop = this.getScrollTop();
    var pages = this.pages;
    var pagesInView = this.getPagesInView(scrollTop);

    // If there are no pages in view, don't do anything more
    if (pagesInView.length === 0) return;

    // Check all pages of this container, and see if there is any page that should be hidden
    forEach(pages, function (page) {
      if (!page.parent()) return;

      if (indexOf(pagesInView, page) === -1) {
        var isAboveViewport = page.pageOffset + page.pageHeight < scrollTop - threshold;
        var side = isAboveViewport ? 'top' : 'bottom';
        this.hidePage(page, side);
      }
    }.bind(this));

    var container = this.container;

    // Set the height of the filler nodes to replace the space taken up by the hidden pages
    var firstVisiblePage = $(pagesInView[0]);
    container._topFiller._height = firstVisiblePage.pageOffset - container.offset;
    container._topFiller[0].style.height = container._topFiller._height + 'px';
    var lastVisiblePage = $(pagesInView[pagesInView.length - 1]);
    container._bottomFiller._height = this.lastPageOffset - lastVisiblePage.pageOffset - lastVisiblePage.pageHeight;
    container._bottomFiller[0].style.height = container._bottomFiller._height + 'px';

    // Show all pages that should be in the view
    var previousNode = container._topFiller;
    forEach(pagesInView, function (page) {
      this.showPage(page, previousNode);
      previousNode = page;
    }.bind(this));

    // If all data has not been fetched already, make a new request
    if (!this.completed) {
      var lastNode = pages[pages.length - 1];
      if (lastNode.pageOffset + lastNode.pageHeight < scrollTop + window.innerHeight + threshold) {
        this.requestNewPage(lastNode);
      }
    }
  }

});

module.exports = Scroller;

},{"../../../../libs/spotify-elements":70,"../../../../libs/spotify-elements/zen":73,"../../../../libs/spotify-events/center":77,"../../../../libs/spotify-events/util/throttle":131,"../../../../libs/spotify-live":251,"../../templates/loner-page.hbs":43,"../config":22,"mout/array/forEach":356,"mout/array/indexOf":357,"mout/lang/kindOf":381,"mout/object/forIn":388,"prime":404,"prime/emitter":403}],30:[function(require,module,exports){
'use strict';

var SearchTracklist = require('./tracklists/search-tracklist');
var localTracks = require('./tracklists/local-tracks');

var tracklist = {};
var lists = [];

tracklist.init = function (logger, _tracks, query, session, context) {
  var tracks = _tracks || {};
  tracks.hits = tracks.hits || [];
  tracks.relevanceCutoff = tracks.relevanceCutoff || 0;

  // Display more local files if offline
  var localTracksCount = session.getOnline() ? 15 : 300;

  localTracks.init(query, localTracksCount, function (error, localtracks) {
    if (error) {
      // TODO (mart): log error
    }

    Array.prototype.splice.apply(tracks.hits, [tracks.relevanceCutoff, 0].concat(localtracks));

    if (tracks.hits.length) {
      logger.attachData({
        'tracks': {
          'hits': localtracks
        }
      });
      document.querySelector('.s-list').innerHTML = '';
      var showTitle = false;
      var loadOnScroll = false;

      if (tracks.relevanceCutoff) {
        showTitle = true;
        var relevanttracks = {
          hits: tracks.hits.splice(0, tracks.relevanceCutoff)
        };
        lists.push(new SearchTracklist(logger, relevanttracks, 'most-relevant', showTitle, query, context, loadOnScroll));
      }

      if (tracks.hits.length) {
        loadOnScroll = true;
        lists.push(new SearchTracklist(logger, tracks, 'all-tracks', showTitle, query, context, loadOnScroll));
      }
    } else if (!session.getOnline()) {
      // If we are offline and there's no tracks, show the no-result
      document.documentElement.classList.add('full-height');
      var noResult = document.querySelector('.no-result');
      noResult.classList.add('show-offline-screen');
      noResult.classList.remove('hide');
      document.querySelector('.s-query').classList.add('hide');
    }
  });
};

tracklist.detach = function () {
  lists.map(function (list) {
    list.detach();
  });
};

module.exports = tracklist;

},{"./tracklists/local-tracks":31,"./tracklists/search-tracklist":32}],31:[function(require,module,exports){
(function (global){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var cosmos = require('spotify-cosmos-api');
var pick = require('mout/object/pick');
var liburi = require('spotify-liburi');

function localFilesZelda(query, length, callback) {
  var uri = 'sp://local-files/v1/tracks';
  uri += '?offset=0';
  uri += '&length=' + length;
  uri += '&query=' + global.encodeURIComponent(query);
  cosmos.resolver.get(uri, function (error, response) {
    if (error !== null) {
      callback(error, null);
    } else {
      var files = response.getJSONBody();
      if (files === null) {
        callback(new global.Error('Bad JSON!'), null);
      } else {
        callback(null, localFilesZeldaCopier(files));
      }
    }
  });
}

function localFilesZeldaCopier(files) {
  return files.map(function (file) {
    var copied = pick(file, 'album', 'artists', 'duration', 'local', 'name', 'popularity', 'unavailable', 'uri');
    copied.album = _typeof(file.album) === 'object' ? pick(file.album, 'name', 'uri') : null;
    copied.artists = file.artists.map(function (artist) {
      return pick(artist, 'name', 'uri');
    });
    setLocalProperty(copied);
    return copied;
  });
}

// This method is borrowed from apps/playlist-desktop/src/local-files.js.
// TODO: these fields should possibly come from the sp://local-files response.
function setLocalProperty(track) {
  track.localFileAvailable = track.local && !track.unavailable;
  if (track.album && track.album.uri) {
    var albumType = liburi.from(track.album.uri).type;
    track.album.local = albumType === liburi.Type.LOCAL_ALBUM;
  }
  if (track.artists) {
    for (var i = 0, l = track.artists.length; i < l; i++) {
      var artist = track.artists[i];
      if (artist.uri) {
        var artistType = liburi.from(artist.uri).type;
        artist.local = artistType === liburi.Type.LOCAL_ARTIST;
      }
    }
  }
}

module.exports = {
  init: localFilesZelda
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"mout/object/pick":394,"spotify-cosmos-api":416,"spotify-liburi":426}],32:[function(require,module,exports){
'use strict';

var live = require('../../../../libs/spotify-live');
var events = require('../../../../libs/spotify-events');
var tracklistTemplate = require('../../../../libs/spotify-glue-cat/templates/v1/tracklist-search.hbs');
var rowTemplate = require('../../../../libs/spotify-glue-cat/templates/v1/tracklist-search-row.hbs');
var titleTemplate = require('../../templates/title.hbs');
var center = require('../../../../libs/spotify-events/center');
var hash = require('../utils/hash');
var selection = require('../../../../libs/spotify-events/selection');
var sortUriUtils = require('../../../../libs/spotify-live-sort-uri');

var SearchTracklist = function SearchTracklist(logger, tracks, title, showTitle, query, context, loadOnScroll) {
  this.totalTracks = [];
  this.isShortList = false;
  this.loadMoreURI = '';
  this.shouldLoadMore = true;
  this.loadOnScroll = loadOnScroll;
  this.trackList = null;
  this.trackListEl = null;
  this.tracklistUri = '';
  this.logger = logger;
  this.context = context;
  this.loadMoreURI = tracks.loadMoreURI;
  this.tracklistUri = 'spotify:internal:search:tracklist:' + hash(query + title);
  this.totalTracks = tracks.hits;

  // Hack to deal with short lists
  this.isShortList = this.totalTracks.length < 3;

  this.onScrollRequest = this.onScrollRequest.bind(this);
  this.onScrollRequestMore = this.onScrollRequestMore.bind(this);
  this.onListSwap = this.onListSwap.bind(this);

  var html = '';

  if (showTitle) {
    html += titleTemplate({
      title: title
    });
  }

  // Inject total tracks into a live model
  var data = {
    uri: this.tracklistUri,
    rows: this.totalTracks.map(this.getRow)
  };
  var model = live(data);

  // Store a reference to the live model so it can be updated when loading more tracks
  this.trackList = model.get('rows');

  html += tracklistTemplate({
    uri: this.tracklistUri,
    sortable: true,
    modifiers: title
  });

  document.querySelector('.s-list').insertAdjacentHTML('beforeend', html);

  this.trackListEl = document.querySelector('.tracklist-search.' + title);
  if (!this.loadOnScroll) {
    var tbodyEl = this.trackListEl.tBodies[0];
    // Remove scroll container
    tbodyEl.classList.remove('data-scroll-container');
    // Static list must render immediately
    tbodyEl.innerHTML = this.renderRowsHtml(data.rows);
  } else {
    center.on('scroll-request', this.onScrollRequest);
    center.on('scroll-request-more', this.onScrollRequestMore);
  }
  center.on('list-swap', this.onListSwap); // Enables sorting

  // Make the popularity column sortable.
  // Doing this in JS is more forward-compatible than copying and modifying the tracklist-search template.
  this.trackListEl.querySelector('.tl-popularity').setAttribute('data-sort', 'track(negPopularity)');
  selection.reset();

  events.update();
};

/**
 * Helper for turning track objects into rendered DOM nodes.
 *
 * @param {Array} tracks Array of track objects.
 * @param {number} offset The offset for the index.
 *
 * @return {Array} An array of DOM nodes.
 */
SearchTracklist.prototype.getRowElements = function (tracks, offset) {
  var html = '';

  tracks.forEach(function (track, index) {
    html += rowTemplate({ track: track, index: (offset + index).toString() });
  });

  var tbody = document.createElement('tbody');
  tbody.innerHTML = html;
  return Array.prototype.slice.call(tbody.children);
};

/**
 * Wrap track object inside a row object.
 * This normalizes track objects coming from hm://searchview and sp://local-files.
 * The objects must have consistent fields to allow for live model sort queries.
 * @param track
 * @returns {Object} A tracklist row for live models.
 */
SearchTracklist.prototype.getRow = function (track) {
  // Boolean fields must be present for live queries.
  track.explicit = !!track.explicit;
  track.local = !!track.local;
  track.album.local = !!track.album.local;
  track.artists = track.artists.map(function (artist) {
    artist.local = !!artist.local;
    return artist;
  });
  // Disc and number fields are also necessary to enable sorting.
  track.disc = 0;
  track.number = 0;

  if ('available' in track) {
    track.unavailable = !track.available;
  }

  return { track: track };
};

/**
 * @callback trackObjects~Callback
 * @param {Error} Error object or null.
 * @param {Array} Array of track objects.
 */

/**
 * Get the next page of track objects and update the live model.
 *
 * @param {trackObjects~Callback} callback
 */
SearchTracklist.prototype.getNextPage = function (callback) {
  if (!this.loadMoreURI || !this.shouldLoadMore) {
    return;
  }

  document.querySelector('.throbberLoader').classList.remove('hide');

  var success = function (json) {
    document.querySelector('.throbberLoader').classList.add('hide');
    this.logger.attachData(json);

    this.loadMoreURI = json.tracks.loadMoreURI;

    this.totalTracks.push.apply(this.totalTracks, json.tracks.hits);

    this.trackList.update([{
      type: 'insert',
      index: this.trackList.length,
      values: json.tracks.hits.map(this.getRow)
    }]);

    callback(null, json.tracks);
  }.bind(this);

  var failure = function failure(error) {
    document.querySelector('.throbberLoader').classList.add('hide');
    callback(error);
  };

  this.context.send(this.loadMoreURI, {}, success, failure);
};

/**
 * Get the tracks within a range. It can be synchronous or asynchronous.
 * If this range is not loaded yet, request a new page.
 *
 * @param {number} start Start index.
 * @param {number} end End index (not inclusive).
 * @param {trackObjects~Callback} callback
 */
SearchTracklist.prototype.getRange = function (start, end, callback) {
  if (this.isShortList) {
    this.isShortList = false;
    // Hack because scroll.js fails with short lists
    try {
      callback(null, this.totalTracks);
    } catch (e) {
      // continue regardless of error
    }
  } else if (end <= this.trackList.length) {
      var tracks = [];
      for (var i = start; i < end; i++) {
        tracks.push(this.totalTracks[i]);
      }
      callback(null, tracks);
    } else {
      this.getNextPage(function nextPageCallback(error, nextTracks) {
        if (error) {
          callback(error);
          return;
        }
        callback(null, nextTracks);
      });
    }
};

/**
 * @callback scrollRequest~Callback
 * @param {Error} Error object or null.
 * @param {Array} Array of rendered DOM nodes fulfilling a scroll range request.
 * @param {Number} Total number of items.
 */

/**
 * Called by spotify-events scroll agent.
 * @param container {Element} DOM node of scroll container.
 * @param range {Range} Object containing start and end indexes.
 * @param callback {scrollRequest~Callback}
 */
SearchTracklist.prototype.onScrollRequest = function (container, range, fn) {
  var callback = fn || function () {};

  this.getRange(range.start, range.end, function rangeCallback(error, tracks) {
    if (error) {
      callback(error);
      return;
    }
    callback(null, this.getRowElements(tracks, range.start), this.totalTracks.length);
  }.bind(this));
};

SearchTracklist.prototype.onScrollRequestMore = function (container, callback) {
  this.getNextPage(function (error) {
    if (error) {
      callback(error);
      return;
    }
    callback(null, this.totalTracks.length);
  }.bind(this));
};

SearchTracklist.prototype.onListSwap = function (event) {
  // Throw away listSwap events that don't match this list
  var parsedUri = sortUriUtils.parse(event.before);
  var listSwapTracklistUri = parsedUri && parsedUri.originUri || event.before;

  if (listSwapTracklistUri !== this.tracklistUri) {
    return;
  }

  // Disable further track results upon sorting the list
  this.shouldLoadMore = false;
  this.updateListFromUri(event.after);
};

SearchTracklist.prototype.updateListFromUri = function (uri) {
  live(uri).query('rows(track(name,uri,duration,popularity,explicit,local,artists(name,uri,local),album(name,uri,local)))', function (error, data) {
    if (error) throw error;

    // Update totalTracks so that scroll callbacks render the right tracks
    this.totalTracks = data.rows.map(function (row) {
      return row.track;
    });

    if (this.loadOnScroll) {
      // Reset scroll to cause track rows to be re-rendered
      center.emit('scroll-reset', this.trackListEl.tBodies[0], data.rows.length);
    } else {
      this.trackListEl.tBodies[0].innerHTML = this.renderRowsHtml(data.rows);
    }

    // Update the track list data-uri so the sorting events work properly
    this.trackListEl.setAttribute('data-uri', uri);
  }.bind(this));
};

SearchTracklist.prototype.renderRowsHtml = function (rows) {
  var htmlRows = [];
  rows.forEach(function (row, index) {
    // GLUE 442 workaround - https://ghe.spotify.net/design/glue/issues/442
    row.index = index + '';
    htmlRows.push(rowTemplate(row));
  });
  return htmlRows.join('');
};

SearchTracklist.prototype.detach = function () {
  center.off('scroll-request', this.onScrollRequest);
  center.off('scroll-request-more', this.onScrollRequestMore);
  center.off('list-swap', this.onListSwap);
};

module.exports = SearchTracklist;

},{"../../../../libs/spotify-events":90,"../../../../libs/spotify-events/center":77,"../../../../libs/spotify-events/selection":113,"../../../../libs/spotify-glue-cat/templates/v1/tracklist-search-row.hbs":166,"../../../../libs/spotify-glue-cat/templates/v1/tracklist-search.hbs":167,"../../../../libs/spotify-live":251,"../../../../libs/spotify-live-sort-uri":249,"../../templates/title.hbs":45,"../utils/hash":36}],33:[function(require,module,exports){
'use strict';

var areArgumentsOK = function areArgumentsOK(args) {
  'use strict';

  var maxChars = 300;
  var length = args.length;

  if (length === 0) {
    return false;
  }

  for (var i = 0; i < length; i += 1) {
    if (typeof args[i] === 'undefined' || args[i] && args[i].length > maxChars) {
      return false;
    }
  }

  return true;
};

module.exports = areArgumentsOK;

},{}],34:[function(require,module,exports){
'use strict';

var min = require('mout/array/min');

var fill = function fill(arr, cols) {
  'use strict';

  var sum = function sum(a, b) {
    return a + b;
  };

  var _min = min(arr);

  while (arr.reduce(sum) < cols) {
    arr[arr.lastIndexOf(_min)] += 1;
    _min = min(arr);
  }
  return arr;
};

module.exports = fill;

},{"mout/array/min":361}],35:[function(require,module,exports){
'use strict';

var trim = require('./trim');
var fill = require('./fill');

/*
 * This function gives an array of how many items fit for each category
 * See test/utils/test.fitter.js for examples.
 */

var fitter = function fitter(wireframe, total, cols) {
  'use strict';

  var fit = [];

  var index = 0;
  wireframe.forEach(function (row) {
    var rowArray = total.slice(index, index + row.length);

    var sum = rowArray.reduce(function (a, b) {
      return a + b;
    });

    var fitted = rowArray;
    if (sum > cols) {
      fitted = trim(rowArray, cols);
    } else if (sum < cols) {
      fitted = fill(rowArray, cols);
    }

    fitted.forEach(function (value) {
      fit.push(value);
    });

    index += row.length;
  });

  return fit;
};

module.exports = fitter;

},{"./fill":34,"./trim":37}],36:[function(require,module,exports){
'use strict';

var hash = function hash(string) {
  'use strict';

  var res = 0;

  for (var i = 0, l = string.length; i < l; i++) {
    res = (res << 5) - res + string.charCodeAt(i);
  }

  return res;
};

module.exports = hash;

},{}],37:[function(require,module,exports){
'use strict';

var max = require('mout/array/max');

var trim = function trim(arr, cols) {
  'use strict';

  // quick-trim

  arr.forEach(function (value, index) {
    arr[index] = value > cols ? cols : value;
  });

  var sum = function sum(a, b) {
    return a + b;
  };

  var _max = max(arr);
  while (arr.reduce(sum) > cols) {
    arr[arr.lastIndexOf(_max)] -= 1;
    _max = max(arr);
  }
  return arr;
};

module.exports = trim;

},{"mout/array/max":360}],38:[function(require,module,exports){
'use strict';

/**
 * This will pick out the structure of the search header.
 * TODO: algorithmitize this?
 * This is only supported for 2 rows and 5 categories at the moment.
 * If we add more categories it will go to 1 row.
 */
/* warning, here be dragons */
var wireframer = function wireframer(total, cols) {
  'use strict';

  if (cols < 1 || total.length === 0) {
    return [];
  } else if (total.length === 5) {
    if (total[0] + total[1] >= cols && total[2] + total[3] + total[4] >= cols) {
      return [[1, 1], [1, 1, 1]];
    } else if (total[0] + total[1] + total[2] >= cols && total[3] + total[4] >= cols) {
      return [[1, 1, 1], [1, 1]];
    }
    return [[1, 1, 1, 1, 1]];
  } else if (total.length === 4) {
    if (total[0] + total[1] >= cols && total[2] + total[3] >= cols) {
      return [[1, 1], [1, 1]];
    } else if (total[0] + total[1] + total[2] >= cols && total[3] >= cols) {
      return [[1, 1, 1], [1]];
    } else if (total[0] >= cols && total[1] + total[2] + total[3] >= cols) {
      return [[1], [1, 1, 1]];
    }
    return [[1, 1, 1, 1]];
  } else if (total.length === 3) {
    if (total[0] + total[1] >= cols && total[2] >= cols) {
      return [[1, 1], [1]];
    } else if (total[0] >= cols && total[1] + total[2] >= cols) {
      return [[1], [1, 1]];
    }
    return [[1, 1, 1]];
  } else if (total.length === 2) {
    return [[1, 1]];
  } else if (total.length === 1) {
    return [[1]];
  }
  return [new Array(total.length + 1).join('1').split('').map(parseFloat)];
};

module.exports = wireframer;

},{}],39:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  


  return "<section class=\"s-query\"></section>\n<section class=\"s-header\"></section>\n<section class=\"s-list\"></section>\n<section class=\"no-result hide\" data-ta-id=\"noResults\"></section>\n<div class=\"throbberWrapper\"><div class=\"throbber-large\"><div></div></div></div>\n<div class=\"throbberLoader hide\"><div class=\"throbber\"><div></div></div></div>\n\n";
  });

},{"hbsfy/runtime":347}],40:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, options, functionType="function", escapeExpression=this.escapeExpression, self=this, blockHelperMissing=helpers.blockHelperMissing, helperMissing=helpers.helperMissing;

function program1(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "<a href=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\">";
  return buffer;
  }

function program3(depth0,data) {
  
  
  return "</a>";
  }

function program5(depth0,data) {
  
  
  return "hide";
  }

  buffer += "<section style=\"width: ";
  if (helper = helpers.width) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.width); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "px; height: ";
  if (helper = helpers.height) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.height); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "px; top: ";
  if (helper = helpers.top) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.top); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "px; left: ";
  if (helper = helpers.left) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.left); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "px\" class=\"pod ";
  if (helper = helpers.category) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.category); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-max-length=\"";
  if (helper = helpers.total) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.total); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-category=\"";
  if (helper = helpers.category) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.category); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-ta-id=\"";
  if (helper = helpers.category) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.category); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "Section\">\n  <div class=\"section-divider section-divider-borderless\">\n    <div class=\"title\" data-ta-id=\"title\" data-category=\"";
  if (helper = helpers.category) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.category); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\">\n      ";
  options={hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data}
  if (helper = helpers.linkTitle) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.linkTitle); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.linkTitle) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n        "
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, (depth0 && depth0.category), options) : helperMissing.call(depth0, "loc", (depth0 && depth0.category), options)))
    + "\n      ";
  options={hash:{},inverse:self.noop,fn:self.program(3, program3, data),data:data}
  if (helper = helpers.linkTitle) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.linkTitle); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.linkTitle) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.noop,fn:self.program(3, program3, data),data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    </div>\n    <div class=\"section-auxiliary\">\n      <a href=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-category=\"";
  if (helper = helpers.category) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.category); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-ta-id=\"seeAll\" class=\"see-all ";
  options={hash:{},inverse:self.program(5, program5, data),fn:self.noop,data:data}
  if (helper = helpers.showButton) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.showButton); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.showButton) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.program(5, program5, data),fn:self.noop,data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\">\n        "
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "see-all", options) : helperMissing.call(depth0, "loc", "see-all", options)))
    + "\n      </a>\n    </div>\n  </div>\n\n  <ul class=\"grid list-unstyled\">\n    ";
  if (helper = helpers.hits) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.hits); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  </ul>\n</section>\n";
  return buffer;
  });

},{"hbsfy/runtime":347}],41:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, functionType="function", escapeExpression=this.escapeExpression;


  buffer += "<li style=\"margin-left: ";
  if (helper = helpers.marginLeft) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.marginLeft); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "px\"\n    data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"\n    data-ta-id=\"item\">\n  ";
  if (helper = helpers.image) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.image); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n</li>\n";
  return buffer;
  });

},{"hbsfy/runtime":347}],42:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
var partial$0 = require('./loner-page.hbs');
HandlebarsCompiler.registerPartial('./loner-page.hbs', partial$0);
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); partials = this.merge(partials, Handlebars.partials); data = data || {};
  var buffer = "", stack1, self=this;


  buffer += "<div data-scroll-container=\"true\">\n  ";
  stack1 = self.invokePartial(partials['./loner-page.hbs'], './loner-page.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n</div>\n";
  return buffer;
  });

},{"./loner-page.hbs":43,"hbsfy/runtime":347}],43:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, options, functionType="function", self=this, blockHelperMissing=helpers.blockHelperMissing;

function program1(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n    ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.html), {hash:{},inverse:self.noop,fn:self.program(2, program2, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  ";
  return buffer;
  }
function program2(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n      <li class=\"col-xs-6 col-sm-4 col-md-3 col-lg-2\" data-scroll-page-item=\"true\" data-ta-id=\"item\">\n        <div>\n          ";
  if (helper = helpers.html) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.html); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n        </div>\n      </li>\n    ";
  return buffer;
  }

  buffer += "<ul data-scroll-page=\"true\" class=\"standard-grid row list-unstyled\">\n  ";
  options={hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data}
  if (helper = helpers.hits) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.hits); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.hits) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n</div>\n";
  return buffer;
  });

},{"hbsfy/runtime":347}],44:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, functionType="function", escapeExpression=this.escapeExpression;


  buffer += "<div><h3 data-ta-id=\"queryParagraph\">";
  if (helper = helpers.searchParagraph) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.searchParagraph); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</h3></div>\n";
  return buffer;
  });

},{"hbsfy/runtime":347}],45:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", helper, options, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;


  buffer += "<div class=\"section-divider section-divider-borderless\">\n  <div data-ta-id=\"title\" data-category=\"tracks\">\n    "
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, (depth0 && depth0.title), options) : helperMissing.call(depth0, "loc", (depth0 && depth0.title), options)))
    + "\n  </div>\n</div>\n";
  return buffer;
  });

},{"hbsfy/runtime":347}],46:[function(require,module,exports){
(function (global){
'use strict';

var Request = require('../../bfs-km-request').Request;
var Session = require('../../bfs-km-session').Session;
var schemas = require('./schemas/schemas.js');
var types = require('bfs-km-types');

var ALBUMS = 'albums';
var ALBUM_NAME_IN_TRACKLIST = 'album_name_in_tracklist';
var APPLICATION_CLIENT_EVENT = 'application_client_event';
var ARTIST_NAME_IN_ALBUM_COVER = 'artist_name_in_album_cover';
var ARTIST_NAME_IN_TRACKLIST = 'artist_name_in_tracklist';
var ARTISTS = 'artists';
var ATTACHMENT = 'attachment';
var CATEGORY = 'category';
var CLEAR_HISTORY = 'clearHistory';
var CONTEXT = 'context';
var CONTEXT_MENU = 'context_menu';
var COVER_IMAGE = 'cover_image';
var COVER_TITLE = 'cover_title';
var DATA = 'data';
var EMPTY = '';
var EVENT = 'event';
var EVENT_VERSION = 'event_version';
var GENRES = 'genres';
var HEADER = 'header';
var HISTORY = 'history';
var HISTORY_ITEM = 'historyItem';
var HIT_COUNTS = 'hitCounts';
var HITS = 'hits';
var INDEX = 'index';
var INFO_DEFAULT = 'info:default';
var LOCALE = 'locale';
var LOGGING_DATA = 'loggingData';
var NO_RESULTS = 'no_results';
var PAGE = 'page';
var PLAY_BUTTON = 'play_button';
var PLAY_TRACK_IN_TRACKLIST = 'play_track_in_tracklist';
var PLAYLIST_OWNER_IN_PLAYLIST_COVER = 'playlist_owner_in_playlist_cover';
var PLAYLISTS = 'playlists';
var PROFILES = 'profiles';
var ROW = 'row';
var QUERY = 'query';
var RESULTS = 'results';
var SEARCH_INTENT = 'search_intent';
var SEARCH_INTENT_SESSION_ID = 'searchIntentSessionId';
var SEARCH_INTENT_SESSION_NEW = 'searchIntentSessionNew';
var SEARCH_INTENT_SESSION_OLD = 'searchIntentSessionOld';
var SECTION = 'section';
var SEE_ALL = 'see_all';
var SHOW_ALL_RESULTS = 'showAllResults';
var SORTED_CATEGORY = 'sortedCategory';
var TEST_VERSION = 'test_version';
var TRACKS = 'tracks';
var TYPE = 'type';
var URI = 'uri';
var USER_HIT = 'user:hit';
var USER_IMPRESSION = 'user:impression';

/**
 * Constructs a new logger.
 */
var Logger = function Logger(session, applicationClientEvent) {
  types.check.type(session, Session);
  types.check.type(applicationClientEvent, Request);

  this.request = {};
  this.session = session;
  this.storage = {};

  this.request.applicationClientEvent = applicationClientEvent;

  this.storage[ATTACHMENT] = {};
  this.storage[HIT_COUNTS] = {};
  this.storage[INDEX] = {};
  this.storage[PAGE] = EMPTY;
  this.storage[QUERY] = EMPTY;
  this.storage[ROW] = {};
  this.storage[SEARCH_INTENT_SESSION_NEW] = EMPTY;
  this.storage[SEARCH_INTENT_SESSION_OLD] = EMPTY;
};

/**
 * Static method that creates a new logger with the default dependencies.
 */
Logger.create = function (session) {
  var applicationClientEvent;

  types.check.type(session, Session);

  applicationClientEvent = Request.create(APPLICATION_CLIENT_EVENT);

  return new Logger(session, applicationClientEvent);
};

/**
 * Static method that creates a mock logger that must log the given json.
 */
Logger.createMockThatMustLog = function (json) {
  var Mock;
  var session;
  var applicationClientEvent;

  types.check.object(json);

  Mock = types.mock(Logger);

  Mock.prototype.log = function (context, event, eventVersion, testVersion, data) {
    var object;

    types.check.string(context);
    types.check.string(event);
    types.check.string(eventVersion);
    types.check.string(testVersion);
    types.check.object(data);

    object = {};

    object[CONTEXT] = context;
    object[EVENT] = event;
    object[EVENT_VERSION] = eventVersion;
    object[TEST_VERSION] = testVersion;
    object[DATA] = data;

    types.assert(json, object);
  };

  session = Session.createMock();
  applicationClientEvent = Request.createMockThatRespondsWithSeries([], {});

  return new Mock(session, applicationClientEvent);
};

/**
 * Populates a few data dictionaries with data from searchview and computes the
 * number of entities in each category.
 */
Logger.prototype.attachData = function (data) {
  var index;
  var processCategory;
  var processHit;

  types.check.object(data);

  index = 1;

  processHit = function processHit(hit, row) {
    var offset;
    var uri;

    types.check.object(hit);
    types.check.number(row);

    uri = hit[URI];
    offset = this.storage[HIT_COUNTS][this.getCategoryFromUri(uri)];

    this.storage[ATTACHMENT][uri] = types.clone(types.fallback.object(hit[LOGGING_DATA], {}));
    this.storage[INDEX][uri] = offset + index++;
    this.storage[ROW][uri] = offset + row;
  };

  processHit = processHit.bind(this);

  processCategory = function processCategory(type) {
    types.check.string(type);

    if (types.is.object(data[type]) && types.is.array(data[type][HITS])) {
      if (!types.is.number(this.storage[HIT_COUNTS][type])) {
        this.storage[HIT_COUNTS][type] = 0;
      }

      data[type][HITS].forEach(processHit);

      this.storage[HIT_COUNTS][type] += data[type][HITS].length;
    }
  };

  processCategory = processCategory.bind(this);

  if (types.is.array(data[SORTED_CATEGORY])) {
    data[SORTED_CATEGORY].forEach(processCategory);
  } else {
    processCategory(ALBUMS);
    processCategory(ARTISTS);
    processCategory(GENRES);
    processCategory(PLAYLISTS);
    processCategory(PROFILES);
    processCategory(TRACKS);
  }
};

/**
 * Clones the logger instance.
 */
Logger.prototype.clone = function () {
  var applicationClientEvent;
  var that;

  applicationClientEvent = this.request.applicationClientEvent.clone();

  that = new this.constructor(applicationClientEvent);

  that.storage = types.clone(this.storage);

  return that;
};

/**
 * Clears the data dictionaries.
 */
Logger.prototype.detachData = function () {
  this.storage[ATTACHMENT] = {};
  this.storage[HIT_COUNTS] = {};
  this.storage[INDEX] = {};
  this.storage[ROW] = {};
};

/**
 * Attempts to retrieve the category from the given uri.
 */
Logger.prototype.getCategoryFromUri = function (uri) {
  types.check.string(uri);

  if (/^spotify:album:([^:]+)$/.test(uri)) {
    return ALBUMS;
  }

  if (/^spotify:artist:([^:]+)$/.test(uri)) {
    return ARTISTS;
  }

  if (/^spotify:app:genre:([^:]+)$/.test(uri)) {
    return GENRES;
  }

  if (/^spotify:user:([^:]+):playlist:([^:]+)$/.test(uri)) {
    return PLAYLISTS;
  }

  if (/^spotify:user:([^:]+)$/.test(uri)) {
    return PROFILES;
  }

  if (/^spotify:track:([^:]+)$/.test(uri)) {
    return TRACKS;
  }

  return EMPTY;
};

/**
 * Generic method for logging a client event.
 */
Logger.prototype.log = function (context, event, eventVersion, testVersion, data) {
  var parameters;

  types.check.string(context);
  types.check.string(event);
  types.check.string(eventVersion);
  types.check.string(testVersion);
  types.check.object(data);

  parameters = [context, event, eventVersion, testVersion, data];

  this.request.applicationClientEvent.send(parameters);
};

/* ========================================================================== */
/* SEARCH                                                                     */
/* ========================================================================== */

/**
 * Logs a search event.
 */
Logger.prototype.logSearchContextMenu = function (type) {
  var data;

  types.check.string(type);

  data = {};

  data[LOCALE] = this.session.getLocale();
  data[PAGE] = this.storage[PAGE];
  data[QUERY] = this.storage[QUERY];
  data[SEARCH_INTENT_SESSION_ID] = this.storage[SEARCH_INTENT_SESSION_NEW];
  data[TYPE] = type;

  this.log(EMPTY, USER_HIT, CONTEXT_MENU, EMPTY, data);
};

/**
 * Logs a search event.
 */
Logger.prototype.logSearchNoResults = function (category) {
  var data;

  types.check.string(category);

  data = {};

  data[CATEGORY] = category;
  data[LOCALE] = this.session.getLocale();
  data[PAGE] = this.storage[PAGE];
  data[QUERY] = this.storage[QUERY];
  data[SEARCH_INTENT_SESSION_ID] = this.storage[SEARCH_INTENT_SESSION_NEW];

  this.log(NO_RESULTS, INFO_DEFAULT, EMPTY, EMPTY, data);
};

/**
 * Logs a search event.
 */
Logger.prototype.logSearchResults = function (category) {
  var data;

  types.check.string(category);

  data = {};

  data[CATEGORY] = category;
  data[HIT_COUNTS] = this.storage[HIT_COUNTS];
  data[LOCALE] = this.session.getLocale();
  data[PAGE] = this.storage[PAGE];
  data[QUERY] = this.storage[QUERY];
  data[SEARCH_INTENT_SESSION_ID] = this.storage[SEARCH_INTENT_SESSION_NEW];

  this.log(RESULTS, USER_IMPRESSION, EMPTY, EMPTY, data);
};

/**
 * Logs a search event.
 */
Logger.prototype.logSearchResultsAlbumNameInTracklist = function (uri, trackURI) {
  var data;

  types.check.string(uri);
  types.check.string(trackURI);

  data = {};

  data[ATTACHMENT] = this.storage[ATTACHMENT][uri];
  data[CATEGORY] = TRACKS;
  data[HIT_COUNTS] = this.storage[HIT_COUNTS];
  data[LOCALE] = this.session.getLocale();
  data[PAGE] = this.storage[PAGE];
  data[QUERY] = this.storage[QUERY];
  data[ROW] = this.storage[ROW][trackURI];
  data[SEARCH_INTENT_SESSION_ID] = this.storage[SEARCH_INTENT_SESSION_NEW];
  data[URI] = uri;

  this.log(RESULTS, USER_HIT, ALBUM_NAME_IN_TRACKLIST, EMPTY, data);
};

/**
 * Logs a search event.
 */
Logger.prototype.logSearchResultsArtistNameInAlbumCover = function (uri) {
  var data;

  types.check.string(uri);

  data = {};

  data[CATEGORY] = ALBUMS;
  data[HIT_COUNTS] = this.storage[HIT_COUNTS];
  data[LOCALE] = this.session.getLocale();
  data[PAGE] = this.storage[PAGE];
  data[QUERY] = this.storage[QUERY];
  data[SEARCH_INTENT_SESSION_ID] = this.storage[SEARCH_INTENT_SESSION_NEW];
  data[URI] = uri;

  this.log(RESULTS, USER_HIT, ARTIST_NAME_IN_ALBUM_COVER, EMPTY, data);
};

/**
 * Logs a search event.
 */
Logger.prototype.logSearchResultsArtistNameInTracklist = function (uri, trackURI) {
  var data;

  types.check.string(uri);
  types.check.string(trackURI);

  data = {};

  data[ATTACHMENT] = this.storage[ATTACHMENT][uri];
  data[CATEGORY] = TRACKS;
  data[HIT_COUNTS] = this.storage[HIT_COUNTS];
  data[LOCALE] = this.session.getLocale();
  data[PAGE] = this.storage[PAGE];
  data[QUERY] = this.storage[QUERY];
  data[ROW] = this.storage[ROW][trackURI];
  data[SEARCH_INTENT_SESSION_ID] = this.storage[SEARCH_INTENT_SESSION_NEW];
  data[URI] = uri;

  this.log(RESULTS, USER_HIT, ARTIST_NAME_IN_TRACKLIST, EMPTY, data);
};

/**
 * Logs a search event.
 */
Logger.prototype.logSearchResultsCoverImage = function (uri) {
  var data;

  types.check.string(uri);

  data = {};

  data[ATTACHMENT] = this.storage[ATTACHMENT][uri];
  data[CATEGORY] = this.getCategoryFromUri(uri);
  data[HIT_COUNTS] = this.storage[HIT_COUNTS];
  data[LOCALE] = this.session.getLocale();
  data[PAGE] = this.storage[PAGE];
  data[QUERY] = this.storage[QUERY];
  data[SEARCH_INTENT_SESSION_ID] = this.storage[SEARCH_INTENT_SESSION_NEW];
  data[URI] = uri;

  this.log(RESULTS, USER_HIT, COVER_IMAGE, EMPTY, data);
};

/**
 * Logs a search event.
 */
Logger.prototype.logSearchResultsCoverTitle = function (uri) {
  var data;

  types.check.string(uri);

  data = {};

  data[ATTACHMENT] = this.storage[ATTACHMENT][uri];
  data[CATEGORY] = this.getCategoryFromUri(uri);
  data[HIT_COUNTS] = this.storage[HIT_COUNTS];
  data[LOCALE] = this.session.getLocale();
  data[PAGE] = this.storage[PAGE];
  data[QUERY] = this.storage[QUERY];
  data[SEARCH_INTENT_SESSION_ID] = this.storage[SEARCH_INTENT_SESSION_NEW];
  data[URI] = uri;

  this.log(RESULTS, USER_HIT, COVER_TITLE, EMPTY, data);
};

/**
 * Logs a search event.
 */
Logger.prototype.logSearchResultsPlayButton = function (uri) {
  var data;

  types.check.string(uri);

  data = {};

  data[ATTACHMENT] = this.storage[ATTACHMENT][uri];
  data[CATEGORY] = this.getCategoryFromUri(uri);
  data[HIT_COUNTS] = this.storage[HIT_COUNTS];
  data[LOCALE] = this.session.getLocale();
  data[PAGE] = this.storage[PAGE];
  data[QUERY] = this.storage[QUERY];
  data[SEARCH_INTENT_SESSION_ID] = this.storage[SEARCH_INTENT_SESSION_NEW];
  data[URI] = uri;

  this.log(RESULTS, USER_HIT, PLAY_BUTTON, EMPTY, data);
};

/**
 * Logs a search event.
 */
Logger.prototype.logSearchResultsPlaylistOwnerInPlaylistCover = function (uri) {
  var data;

  types.check.string(uri);

  data = {};

  data[CATEGORY] = PLAYLISTS;
  data[HIT_COUNTS] = this.storage[HIT_COUNTS];
  data[LOCALE] = this.session.getLocale();
  data[PAGE] = this.storage[PAGE];
  data[QUERY] = this.storage[QUERY];
  data[SEARCH_INTENT_SESSION_ID] = this.storage[SEARCH_INTENT_SESSION_NEW];
  data[URI] = uri;

  this.log(RESULTS, USER_HIT, PLAYLIST_OWNER_IN_PLAYLIST_COVER, EMPTY, data);
};

/**
 * Logs a search event.
 */
Logger.prototype.logSearchResultsPlayTrackInTracklist = function (uri) {
  var data;

  types.check.string(uri);

  data = {};

  data[ATTACHMENT] = this.storage[ATTACHMENT][uri];
  data[CATEGORY] = TRACKS;
  data[HIT_COUNTS] = this.storage[HIT_COUNTS];
  data[LOCALE] = this.session.getLocale();
  data[PAGE] = this.storage[PAGE];
  data[QUERY] = this.storage[QUERY];
  data[ROW] = this.storage[ROW][uri];
  data[SEARCH_INTENT_SESSION_ID] = this.storage[SEARCH_INTENT_SESSION_NEW];
  data[URI] = uri;

  this.log(RESULTS, USER_HIT, PLAY_TRACK_IN_TRACKLIST, EMPTY, data);
};

/**
 * Logs a search event.
 */
Logger.prototype.logSearchResultsSeeAll = function (category) {
  var data;

  types.check.string(category);

  data = {};

  data[CATEGORY] = category;
  data[HIT_COUNTS] = this.storage[HIT_COUNTS];
  data[LOCALE] = this.session.getLocale();
  data[PAGE] = this.storage[PAGE];
  data[QUERY] = this.storage[QUERY];
  data[SEARCH_INTENT_SESSION_ID] = this.storage[SEARCH_INTENT_SESSION_NEW];

  this.log(RESULTS, USER_HIT, SEE_ALL, EMPTY, data);
};

/* ========================================================================== */
/* SUGGEST                                                                    */
/* ========================================================================== */

/**
 * Logs a suggest event.
 */
Logger.prototype.logSuggestHistoryClearHistory = function () {
  var data;

  data = {};

  data[LOCALE] = this.session.getLocale();
  data[PAGE] = this.storage[PAGE];
  data[QUERY] = this.storage[QUERY];

  this.log(HISTORY, USER_HIT, CLEAR_HISTORY, EMPTY, data);
};

/**
 * Logs a suggest event.
 */
Logger.prototype.logSuggestHistoryHistoryItem = function () {
  var data;

  data = {};

  data[LOCALE] = this.session.getLocale();
  data[PAGE] = this.storage[PAGE];
  data[QUERY] = this.storage[QUERY];

  this.log(HISTORY, USER_HIT, HISTORY_ITEM, EMPTY, data);
};

/**
 * Logs a suggest event.
 */
Logger.prototype.logSuggestResultsEntity = function (json) {
  var data;

  if (!types.conforms(json, schemas.suggest, true)) {
    throw new global.Error('The given json does not conform to its schema!');
  }

  data = types.clone(json);

  data[HIT_COUNTS] = this.storage[HIT_COUNTS];
  data[LOCALE] = this.session.getLocale();
  data[PAGE] = this.storage[PAGE];
  data[QUERY] = this.storage[QUERY];
  data[SEARCH_INTENT_SESSION_ID] = this.storage[SEARCH_INTENT_SESSION_NEW];

  this.log(RESULTS, USER_HIT, data[SECTION], EMPTY, data);
};

/**
 * Logs a suggest event.
 */
Logger.prototype.logSuggestResultsHeader = function (section) {
  var data;

  types.check.string(section);

  data = {};

  data[HIT_COUNTS] = this.storage[HIT_COUNTS];
  data[LOCALE] = this.session.getLocale();
  data[PAGE] = this.storage[PAGE];
  data[QUERY] = this.storage[QUERY];
  data[SEARCH_INTENT_SESSION_ID] = this.storage[SEARCH_INTENT_SESSION_NEW];
  data[SECTION] = section;

  this.log(RESULTS, USER_HIT, HEADER, EMPTY, data);
};

/**
 * Logs a suggest event.
 */
Logger.prototype.logSuggestResultsShowAllResults = function () {
  var data;

  data = {};

  data[HIT_COUNTS] = this.storage[HIT_COUNTS];
  data[LOCALE] = this.session.getLocale();
  data[PAGE] = this.storage[PAGE];
  data[QUERY] = this.storage[QUERY];
  data[SEARCH_INTENT_SESSION_ID] = this.storage[SEARCH_INTENT_SESSION_NEW];

  this.log(RESULTS, USER_HIT, SHOW_ALL_RESULTS, EMPTY, data);
};

/**
 * Logs a suggest event.
 */
Logger.prototype.logSuggestSearchIntent = function () {
  var data;

  data = {};

  data[LOCALE] = this.session.getLocale();
  data[PAGE] = this.storage[PAGE];
  data[QUERY] = this.storage[QUERY];
  data[SEARCH_INTENT_SESSION_NEW] = this.storage[SEARCH_INTENT_SESSION_NEW];
  data[SEARCH_INTENT_SESSION_OLD] = this.storage[SEARCH_INTENT_SESSION_OLD];

  this.log(EMPTY, INFO_DEFAULT, SEARCH_INTENT, EMPTY, data);
};

/**
 * Sets the hit counts.
 */
Logger.prototype.setHitCounts = function (hitCounts) {
  types.check.object(hitCounts);

  this.storage[HIT_COUNTS] = types.clone(hitCounts);

  return this;
};

/**
 * Sets the page.
 */
Logger.prototype.setPage = function (page) {
  types.check.number(page);

  this.storage[PAGE] = page;

  return this;
};

/**
 * Sets the query.
 */
Logger.prototype.setQuery = function (query) {
  types.check.string(query);

  this.storage[QUERY] = query;

  return this;
};

/**
 * Sets the search intent id.
 */
Logger.prototype.setSearchIntentId = function (searchIntentId) {
  types.check.string(searchIntentId);

  this.storage[SEARCH_INTENT_SESSION_OLD] = this.storage[SEARCH_INTENT_SESSION_NEW];
  this.storage[SEARCH_INTENT_SESSION_NEW] = searchIntentId;

  return this;
};

module.exports = Logger;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../bfs-km-request":51,"../../bfs-km-session":61,"./schemas/schemas.js":48,"bfs-km-types":303}],47:[function(require,module,exports){
'use strict';

exports.Logger = require('./Logger.js');

},{"./Logger.js":46}],48:[function(require,module,exports){
'use strict';

exports.suggest = require('./suggest.json');

},{"./suggest.json":49}],49:[function(require,module,exports){
module.exports={
  "index" : 0,
  "log" : {},
  "row" : 0,
  "section" : "",
  "uri" : ""
}

},{}],50:[function(require,module,exports){
(function (global){
'use strict';

var types = require('bfs-km-types');
var bridge = require('../../spotify-bridge-request');

var EMPTY = '';

/**
 * Constructs a new request.
 */
var Request = function Request(type) {
  types.check.string(type);

  this.observers = [];
  this.type = type;
};

/**
 * Static method that creates a new request with the default dependencies.
 */
Request.create = function (type) {
  types.check.string(type);

  return new Request(type);
};

/**
 * Static method that creates a mock request which produces the given series of
 * responses.
 */
Request.createMockThatRespondsWithSeries = function (series, response) {
  var Mock;

  types.check.array(series);
  types.check.object(response);

  Mock = types.mock(Request);

  Mock.prototype.dispatch = function (parameters, caller, success, failure) {
    var current;

    types.check.array(parameters);
    types.check.type(caller, global.Object);
    types.check.function(success);
    types.check.function(failure);

    if (series.length > 0) {
      current = series.shift();

      if (current === true) {
        success.call(caller, response);
      }

      if (current === false) {
        failure.call(caller);
      }
    }
  };

  Mock.prototype.retry = function (parameters) {
    types.check.array(parameters);

    this.send(parameters);
  };

  return new Mock(EMPTY);
};

/**
 * Clones the request instance. The clone will have no observers attached.
 */
Request.prototype.clone = function () {
  var that;

  that = new this.constructor(this.type);

  return that;
};

/**
 * Dispatches the request over the bridge.
 */
Request.prototype.dispatch = function (parameters, caller, success, failure) {
  types.check.array(parameters);
  types.check.type(caller, global.Object);
  types.check.function(success);
  types.check.function(failure);

  bridge.request(this.type, parameters, function (error, result) {
    if (error) failure.call(caller, error);else success.call(caller, result);
  });
};

/**
 * Attaches an observer callback which is triggered on successful responses.
 */
Request.prototype.observe = function (observer) {
  types.check.function(observer);

  if (this.observers.indexOf(observer) === -1) {
    this.observers.push(observer);
  }
};

/**
 * Retries sending the request with a randomized back-off of around 1000 ms.
 */
Request.prototype.retry = function (parameters) {
  var send;

  types.check.array(parameters);

  send = this.send.bind(this, parameters);

  global.setTimeout(send, 900 + global.Math.floor(global.Math.random() * 200));
};

/**
 * Sends the request. Notifies all observers on success. Retries on failure.
 */
Request.prototype.send = function (parameters) {
  var failure;
  var success;

  types.check.array(parameters);

  failure = function () {
    this.retry(parameters);
  }.bind(this);

  success = function (response) {
    response = types.fallback.object(response, {});

    this.observers.forEach(function (observer) {
      observer(types.clone(response));
    });
  }.bind(this);

  this.dispatch(parameters, this, success, failure);
};

module.exports = Request;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../spotify-bridge-request":64,"bfs-km-types":303}],51:[function(require,module,exports){
'use strict';

exports.Request = require('./Request.js');

},{"./Request.js":50}],52:[function(require,module,exports){
(function (global){
'use strict';

var requests = require('./requests/requests.js');
var Session = require('../../bfs-km-session').Session;
var types = require('bfs-km-types');
var proxyConfiguration = require('./proxyConfiguration');

var CATALOGUE = 'catalogue';
var COUNTRY = 'country';
var GET = 'GET';
var LOCALE = 'locale';
var PLATFORM = 'platform';
var USERNAME = 'username';

/**
 * Constructs a new context.
 */
var Context = function Context(session, live) {
  types.check.type(session, Session);

  this.id = 0;
  this.session = session;
  this.proxyConfig = proxyConfiguration.getConfiguration(live);
};

/**
 * Static method that creates a new context with the default dependencies.
 */
Context.create = function (session, live) {
  types.check.type(session, Session);

  return new Context(session, live);
};

/**
 * Static method that creates a mock context which responds with the given
 * serialized json response for all requests.
 */
Context.createMockThatRespondsWith = function (response) {
  var Mock;

  types.check.string(response);

  Mock = types.mock(Context);

  Mock.prototype.resolve = function (uri, caller, success, failure) {
    var json;

    types.check.string(uri);
    types.check.type(caller, global.Object);
    types.check.function(success);
    types.check.function(failure);

    try {
      json = global.JSON.parse(response);
    } catch (error) {
      failure.call(caller, error);

      return;
    }

    success.call(caller, json);
  };

  return new Mock(Session.createMock());
};

/**
 * Clones the context instance.
 */
Context.prototype.clone = function () {
  var that;

  that = new this.constructor(this.session);

  return that;
};

/**
 * Helper method that creates a new hub request.
 */
Context.prototype.newHubRequest = function () {
  return requests.Hub.create();
};

/**
 * Helper method that creates a new search request.
 */
Context.prototype.newSearchRequest = function () {
  return requests.Search.create();
};

/**
 * Resolve the given uri based on the proxy configuration.
 */
Context.prototype.resolve = function (uri, caller, success, failure) {
  this.proxyConfig.then(function (proxy) {
    if (proxy.enabled) {
      this._localhostRequest(uri, proxy, success, failure, caller);
      return;
    }

    this._cosmosRequest(uri, caller, success, failure);
  }.bind(this));
};

/**
 * Resolves the given uri using the cosmos resolver and calls the succes
 * callback or the failure callback depending on whether the request was
 * successful or not.
 */
Context.prototype._cosmosRequest = function (uri, caller, success, failure) {
  var cosmos;
  var id;
  var callback;

  cosmos = require('spotify-cosmos-api');

  types.check.string(uri);
  types.check.type(caller, global.Object);
  types.check.function(success);
  types.check.function(failure);

  id = ++this.id;

  callback = function callback(error, response) {
    var json;

    if (id === this.id) {
      if (types.is.type(error, global.Error)) {
        failure.call(caller, error);
      } else {
        json = response.getJSONBody();

        if (types.is.object(json)) {
          success.call(caller, json);
        } else {
          failure.call(caller, new global.Error('Received malformed json!'));
        }
      }
    }
  };

  callback = callback.bind(this);

  cosmos.resolver.resolve(new cosmos.Request(GET, uri), callback);
};

/**
 * Make a request to the proxy running locally.
 */
Context.prototype._localhostRequest = function (uri, proxy, success, failure, caller) {
  types.check.string(uri);
  types.check.type(caller, global.Object);
  types.check.function(success);
  types.check.function(failure);

  var id = ++this.id;
  var httpUri = uri.replace(/^hm:\/\//, proxy.host + ':' + proxy.port + '/');
  var xhr = new XMLHttpRequest();

  xhr.onreadystatechange = function () {
    if (id !== this.id || xhr.readyState !== 4) {
      return;
    }

    var json = null;
    if (xhr.status === 200) {
      try {
        json = JSON.parse(xhr.response);
      } catch (error) {
        failure.call(caller, error);
      }
    }

    if (types.is.object(json)) {
      success.call(caller, json);
    } else {
      failure.call(caller, new global.Error('Received malformed json!'));
    }
  }.bind(this);

  xhr.open('GET', httpUri, true);
  xhr.setRequestHeader('x-spotify-catalogue', proxy.catalogue);
  xhr.setRequestHeader('x-spotify-country', proxy.country);
  xhr.setRequestHeader('x-spotify-employee', String(proxy.employee));
  xhr.setRequestHeader('x-spotify-username', proxy.username);
  xhr.send();
};

/**
 * Sends a request to the given uri. If the request fails, the given failure
 * callback is called with the Error as its argument. If the request succeeds,
 * the given success callback is called with the json response as its argument.
 * No context parameters are appended to the uri.
 */
Context.prototype.send = function (uri, caller, success, failure) {
  types.check.string(uri);
  types.check.type(caller, global.Object);
  types.check.function(success);
  types.check.function(failure);

  this.resolve(uri, caller, success, failure);
};

/**
 * Sends a request to the uri of the given request. If the request fails, the
 * given failure callback is called with the Error as its argument. If the
 * request succeeds, the given success callback is called with the json response
 * as its argument. All context parameters are appended to the uri.
 */
Context.prototype.sendRequest = function (request, caller, success, failure) {
  var cloned;
  var uri;

  types.check.type(request, requests.Request);
  types.check.type(caller, global.Object);
  types.check.function(success);
  types.check.function(failure);

  cloned = request.clone();

  cloned.setParameter(CATALOGUE, this.session.getCatalogue());
  cloned.setParameter(COUNTRY, this.session.getCountry());
  cloned.setParameter(LOCALE, this.session.getLocale());
  cloned.setParameter(PLATFORM, this.session.getPlatform());
  cloned.setParameter(USERNAME, this.session.getUsername());

  uri = cloned.toUri();

  this.resolve(uri, caller, success, failure);
};

module.exports = Context;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../bfs-km-session":61,"./proxyConfiguration":54,"./requests/requests.js":59,"bfs-km-types":303,"spotify-cosmos-api":416}],53:[function(require,module,exports){
'use strict';

exports.Context = require('./Context.js');
exports.requests = require('./requests/requests.js');
exports.proxyConfiguration = require('./proxyConfiguration');

},{"./Context.js":52,"./proxyConfiguration":54,"./requests/requests.js":59}],54:[function(require,module,exports){
'use strict';

var proxyConfigurationState = require('./proxyConfigurationState');

var STORAGE_NAMESPACE = 'search-proxy';
var STORAGE_FIELDS = ['enabled', 'host', 'port', 'catalogue', 'username', 'country', 'employee'];
var STORAGE_FIELDS_WITH_NAMESPACE = STORAGE_FIELDS.map(formatStorageKey);

var DEFAULT_CONFIGURATION = {
  enabled: false,
  host: 'http://localhost',
  port: '8081',
  catalogue: 'free',
  username: null,
  country: null,
  employee: false
};

exports = module.exports = function (live) {
  return {
    getConfiguration: getConfiguration.bind(null, live),
    getDefaultConfiguration: getDefaultConfiguration,
    getUserData: getUserData.bind(null, live),
    getAllPreferences: getAllPreferences.bind(null, live),
    updatePreferences: updatePreferences.bind(null, live)
  };
};

/**
 * Get the proxy configuration based on user data & preferences.
 */
exports.getConfiguration = getConfiguration;

function getConfiguration(live) {
  return Promise.all([getDefaultConfiguration(), getUserData(live), getAllPreferences(live)]).then(function (data) {
    var defaultConfiguration = data[0];
    var userData = data[1];
    var preferences = data[2];

    return proxyConfigurationState(defaultConfiguration, userData, preferences);
  });
}

/**
 * Get the default configuration used by searchview.
 */
exports.getDefaultConfiguration = getDefaultConfiguration;

function getDefaultConfiguration() {
  return Promise.resolve(DEFAULT_CONFIGURATION);
}

/**
 * Get user data from live model.
 */
exports.getUserData = getUserData;

function getUserData(live) {
  return new Promise(function (resolve, reject) {
    live('spotify:client').query('currentUser(username), session(country)', function (err, data) {
      if (err) {
        reject(err);
        return;
      }

      resolve({
        username: data.currentUser.username,
        country: data.session.country,
        catalogue: window.__spotify.product_state.catalogue
      });
    });
  });
}

/**
 * Get all user's proxy preferences defined in the settings page.
 */
exports.getAllPreferences = getAllPreferences;

function getAllPreferences(live) {
  return new Promise(function (resolve, reject) {
    live('spotify:client-storage').get(STORAGE_FIELDS_WITH_NAMESPACE, function (err, storageData) {
      if (err) {
        reject(err);
        return;
      }

      // Map `storageData` with `STORAGE_FIELDS`.
      // It uses `STORAGE_FIELDS` values as keys and `storageData` as values.
      var result = STORAGE_FIELDS.reduce(function (acc, key, index) {
        var value = storageData[index];

        if (value === 'true') {
          value = true;
        } else if (value === 'false') {
          value = false;
        }

        acc[key] = value;
        return acc;
      }, {});

      resolve(result);
    });
  });
}

/**
 * Update the given keys.
 */
exports.updatePreferences = updatePreferences;

function updatePreferences(live, data) {
  // Preprend the storage namespace to the keys.
  var storageData = Object.keys(data).reduce(function (acc, key) {
    acc[formatStorageKey(key)] = data[key];
    return acc;
  }, {});

  live('spotify:client-storage').publish(storageData);

  return Promise.resolve();
}

/**
 * Format a key using the storage namespace.
 */
function formatStorageKey(key) {
  return STORAGE_NAMESPACE + ':' + key;
}

},{"./proxyConfigurationState":55}],55:[function(require,module,exports){
'use strict';

exports = module.exports = proxyConfigurationState;

/**
 * Merge DEFAULT_STATE, userData and preferences into one object.
 * @public
 */
function proxyConfigurationState(defaultState, userData, preferences) {
  var filterUserData = excludeEmptyProperties(userData);
  var filterPreferences = excludeEmptyProperties(preferences);

  var state = Object.assign({}, defaultState, filterUserData, filterPreferences);

  return state;
}

/**
 * Exclude properties that are considered as "empty".
 * @private
 */
function excludeEmptyProperties(data) {
  if (!data) {
    return {};
  }

  var res = Object.keys(data).reduce(function (acc, key) {
    var value = data[key];

    // Exclude if the property is not defined or an emtpy string.
    if (value === undefined || value === null || value === '') {
      return acc;
    }

    acc[key] = value;

    return acc;
  }, {});

  return res;
}

},{}],56:[function(require,module,exports){
(function (global){
'use strict';

var Request = require('./Request.js');
var types = require('bfs-km-types');

var BASE_URI = 'hm://hubview/km/';
var EMPTY = '';
var HUB = 'hub';
var SUB_HUB = 'sub-hub';
var SUB_SUB_HUB = 'sub-sub-hub';
var SYMBOL_FORWARD_SLASH = '/';
var VERSION = 'version';

/**
 * Constructs a new hub request.
 */
var Hub = function Hub() {
  Request.call(this);

  this.storage[HUB] = EMPTY;
  this.storage[SUB_HUB] = EMPTY;
  this.storage[SUB_SUB_HUB] = EMPTY;
  this.storage[VERSION] = EMPTY;
};

types.extend(Hub, Request);

/**
 * Static method that creates a new request.
 */
Hub.create = function () {
  return new Hub();
};

/**
 * Static method that creates a mock request.
 */
Hub.createMock = function () {
  var Mock;

  Mock = types.mock(Hub);

  return new Mock();
};

/**
 * Clones the request instance.
 */
Hub.prototype.clone = function () {
  var that;

  that = new this.constructor();

  that.storage = types.clone(this.storage);

  return that;
};

/**
 * Gets the base uri for the request.
 */
Hub.prototype.getBaseUri = function () {
  var uri;

  uri = EMPTY;

  uri += BASE_URI;
  uri += global.encodeURIComponent(this.storage[VERSION]);
  uri += SYMBOL_FORWARD_SLASH;
  uri += global.encodeURIComponent(this.storage[HUB]);

  if (this.storage[SUB_HUB] === '') {
    return uri;
  }

  uri += SYMBOL_FORWARD_SLASH;
  uri += global.encodeURIComponent(this.storage[SUB_HUB]);

  if (this.storage[SUB_SUB_HUB] === '') {
    return uri;
  }

  uri += SYMBOL_FORWARD_SLASH;
  uri += global.encodeURIComponent(this.storage[SUB_SUB_HUB]);

  return uri;
};

/**
 * Gets the hub.
 */
Hub.prototype.getHub = function () {
  return this.storage[HUB];
};

/**
 * Gets the sub hub.
 */
Hub.prototype.getSubHub = function () {
  return this.storage[SUB_HUB];
};

/**
 * Gets the sub sub hub.
 */
Hub.prototype.getSubSubHub = function () {
  return this.storage[SUB_SUB_HUB];
};

/**
 * Gets the version.
 */
Hub.prototype.getVersion = function () {
  return this.storage[VERSION];
};

/**
 * Sets the hub.
 */
Hub.prototype.setHub = function (hub) {
  types.check.string(hub);

  this.storage[HUB] = hub;

  return this;
};

/**
 * Sets the sub hub.
 */
Hub.prototype.setSubHub = function (subHub) {
  types.check.string(subHub);

  this.storage[SUB_HUB] = subHub;

  return this;
};

/**
 * Sets the sub sub hub.
 */
Hub.prototype.setSubSubHub = function (subSubHub) {
  types.check.string(subSubHub);

  this.storage[SUB_SUB_HUB] = subSubHub;

  return this;
};

/**
 * Sets the version.
 */
Hub.prototype.setVersion = function (version) {
  types.check.string(version);

  this.storage[VERSION] = version;

  return this;
};

module.exports = Hub;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./Request.js":57,"bfs-km-types":303}],57:[function(require,module,exports){
(function (global){
'use strict';

var types = require('bfs-km-types');

var EMPTY = '';
var PARAMETERS = 'parameters';
var SYMBOL_AMPERSAND = '&';
var SYMBOL_EQUALITY_SIGN = '=';
var SYMBOL_QUESTION_MARK = '?';

/**
 * Constructs a new request.
 */
var Request = function Request() {
  this.storage = {};

  this.storage[PARAMETERS] = {};
};

types.define(Request);

/**
 * Clones the request instance.
 */
Request.prototype.clone = function () {
  throw new global.Error('Abstract method!');
};

/**
 * Gets the base uri for the request.
 */
Request.prototype.getBaseUri = function () {
  throw new global.Error('Abstract method!');
};

/**
 * Gets the parameter with the given key. Returns null if the parameter with the
 * given key is unset.
 */
Request.prototype.getParameter = function (key) {
  types.check.string(key);

  return types.fallback.string(this.storage[PARAMETERS][key], null);
};

/**
 * Sets the parameter with the given key to the given value. Note that the value
 * must be a string.
 */
Request.prototype.setParameter = function (key, value) {
  types.check.string(key);
  types.check.string(value);

  this.storage[PARAMETERS][key] = value;

  return this;
};

/**
 * Sets all parameters defined by the given object. Note that all values must be
 * strings.
 */
Request.prototype.setParameters = function (object) {
  types.check.object(object);

  Object.keys(object).forEach(function (key) {
    this.setParameter(key, object[key]);
  }.bind(this));

  return this;
};

/**
 * Converts the request to a uri.
 */
Request.prototype.toUri = function () {
  var query;
  var uri;

  uri = this.getBaseUri();

  query = EMPTY;

  Object.keys(this.storage[PARAMETERS]).forEach(function (key) {
    query += query.length === 0 ? SYMBOL_QUESTION_MARK : SYMBOL_AMPERSAND;
    query += global.encodeURIComponent(key);
    query += SYMBOL_EQUALITY_SIGN;
    query += global.encodeURIComponent(this.storage[PARAMETERS][key]);
  }.bind(this));

  uri += query;

  return uri;
};

module.exports = Request;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"bfs-km-types":303}],58:[function(require,module,exports){
(function (global){
'use strict';

var Request = require('./Request.js');
var types = require('bfs-km-types');

var BASE_URI = 'hm://searchview/km/';
var EMPTY = '';
var ENDPOINT = 'endpoint';
var QUERY = 'query';
var SYMBOL_FORWARD_SLASH = '/';
var VERSION = 'version';

/**
 * Constructs a new search request.
 */
var Search = function Search() {
  Request.call(this);

  this.storage[ENDPOINT] = EMPTY;
  this.storage[QUERY] = EMPTY;
  this.storage[VERSION] = EMPTY;
};

types.extend(Search, Request);

/**
 * Static method that creates a new request.
 */
Search.create = function () {
  return new Search();
};

/**
 * Static method that creates a mock request.
 */
Search.createMock = function () {
  var Mock;

  Mock = types.mock(Search);

  return new Mock();
};

/**
 * Clones the request instance.
 */
Search.prototype.clone = function () {
  var that;

  that = new this.constructor();

  that.storage = types.clone(this.storage);

  return that;
};

/**
 * Gets the base uri for the request.
 */
Search.prototype.getBaseUri = function () {
  var uri;

  uri = EMPTY;

  uri += BASE_URI;
  uri += global.encodeURIComponent(this.storage[VERSION]);
  uri += SYMBOL_FORWARD_SLASH;
  uri += global.encodeURIComponent(this.storage[ENDPOINT]);
  uri += SYMBOL_FORWARD_SLASH;
  uri += global.encodeURIComponent(this.storage[QUERY]);

  return uri;
};

/**
 * Gets the endpoint.
 */
Search.prototype.getEndpoint = function () {
  return this.storage[ENDPOINT];
};

/**
 * Gets the query.
 */
Search.prototype.getQuery = function () {
  return this.storage[QUERY];
};

/**
 * Gets the version.
 */
Search.prototype.getVersion = function () {
  return this.storage[VERSION];
};

/**
 * Sets the endpoint.
 */
Search.prototype.setEndpoint = function (endpoint) {
  types.check.string(endpoint);

  this.storage[ENDPOINT] = endpoint;

  return this;
};

/**
 * Sets the query.
 */
Search.prototype.setQuery = function (query) {
  types.check.string(query);

  this.storage[QUERY] = query;

  return this;
};

/**
 * Sets the version.
 */
Search.prototype.setVersion = function (version) {
  types.check.string(version);

  this.storage[VERSION] = version;

  return this;
};

module.exports = Search;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./Request.js":57,"bfs-km-types":303}],59:[function(require,module,exports){
'use strict';

exports.Hub = require('./Hub.js');
exports.Request = require('./Request.js');
exports.Search = require('./Search.js');

},{"./Hub.js":56,"./Request.js":57,"./Search.js":58}],60:[function(require,module,exports){
'use strict';

var types = require('bfs-km-types');

var platform = require('./platform.js');

/**
 * Constructs a new session.
 */
var Session = function Session() {
  this.storage = {
    catalogue: '',
    country: '',
    incognito: false,
    locale: '',
    online: true,
    platform: platform,
    username: ''
  };

  this.listen();
};

/**
 * A static method that creates a mock session.
 */
Session.createMock = function () {
  var Mock;

  Mock = types.mock(Session);

  Mock.prototype.listen = function () {};

  return new Mock();
};

/**
 * Gets the catalogue.
 */
Session.prototype.getCatalogue = function () {
  return this.storage.catalogue;
};

/**
 * Gets the country.
 */
Session.prototype.getCountry = function () {
  return this.storage.country;
};

/**
 * Gets the incognito flag.
 */
Session.prototype.getIncognito = function () {
  return this.storage.incognito;
};

/**
 * Gets the locale.
 */
Session.prototype.getLocale = function () {
  return this.storage.locale;
};

/**
 * Gets the online flag.
 */
Session.prototype.getOnline = function () {
  return this.storage.online;
};

/**
 * Gets the platform.
 */
Session.prototype.getPlatform = function () {
  return this.storage.platform;
};

/**
 * Gets the username.
 */
Session.prototype.getUsername = function () {
  return this.storage.username;
};

/**
 * A method that makes the session listen for state changes from the client.
 */
Session.prototype.listen = function () {
  var live;
  var client;
  var query;

  live = require('../../spotify-live');
  client = live('spotify:client');

  if (platform === 'web') {
    query = 'currentUser(username), session(catalogue, country, incognito, language, online)';
  } else {
    query = 'currentUser(username), session(country, incognito, language, online)';
  }

  client.query(query, function (error, json) {
    if (types.conforms(json, { currentUser: {} })) {
      this.parseCurrentUser(json.currentUser);
    }

    client.get('currentUser').on('update', function (data) {
      this.parseCurrentUser(data);
    }.bind(this));

    if (types.conforms(json, { session: {} })) {
      this.parseSession(json.session);
    }

    client.get('session').on('update', function (data) {
      this.parseSession(data);
    }.bind(this));
  }.bind(this));
};

/**
 * Parses the currentUser data.
 */
Session.prototype.parseCurrentUser = function (json) {
  if (types.conforms(json, { username: '' })) {
    this.storage.username = json.username;
  }
};

/**
 * Parses the session data.
 */
Session.prototype.parseSession = function (json) {
  if (types.conforms(json, { catalogue: '' })) {
    this.storage.catalogue = json.catalogue;
  }

  if (types.conforms(json, { country: '' })) {
    this.storage.country = json.country;
  }

  if (types.conforms(json, { incognito: false })) {
    this.storage.incognito = json.incognito;
  }

  if (types.conforms(json, { language: '' })) {
    this.storage.locale = json.language;
  }

  if (types.conforms(json, { online: false })) {
    this.storage.online = json.online;
  }
};

module.exports = Session;

},{"../../spotify-live":251,"./platform.js":62,"bfs-km-types":303}],61:[function(require,module,exports){
'use strict';

exports.Session = require('./Session.js');

},{"./Session.js":60}],62:[function(require,module,exports){
(function (global){
'use strict';

var types = require('bfs-km-types');

var platform = function platform() {
  if (types.is.function(global._getSpotifyModule)) {
    if (types.is.object(global.__spotify)) {
      return 'zelda';
    }
    return 'desktop';
  }
  return 'web';
};

module.exports = platform();

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"bfs-km-types":303}],63:[function(require,module,exports){
'use strict';

// Base function that doesn't have any dependencies on it's own. Expects to get
// state (a plain, empty object) injected in addition to a bridge request
// function.
function cosmosRequest(state, bridge, opts, callback) {

  if (typeof opts.uri !== 'string') throw new Error('Expected uri to be string.');

  if (COSMOS_VERBS.indexOf(opts.method) === -1) throw new Error('Method must match valid verb in uppercase (GET, POST etc)');

  if (opts.body && typeof opts.body !== 'string') throw new Error('If body is provided it should be a string.');

  if (opts.headers && Object.prototype.toString.call(opts.headers) !== '[object Object]') throw new Error('Expected headers be a plain object.');

  var cosmosOptions = {
    action: opts.method,
    uri: opts.uri
  };
  if (opts.body) cosmosOptions.body = opts.body;
  if (opts.headers) cosmosOptions.headers = opts.headers;

  /* Cosmos requires each request to have a unique ID. Ideally, this would be
  uuids, but unfortunately, it is integers. This means that in apps that for
  some reason need to use spotify-cosmos-api, there would between the two
  counters if cosmosRequest started from 0. To make it safe for the two
  implemenations to co-exist if needed, we begin counting at
  significantly higher number: */
  state.requestIDCounter = state.requestIDCounter || TEN_PER_SECOND_FOR_A_YEAR;
  state.requestIDCounter++;

  var requestArguments = [state.requestIDCounter, cosmosOptions];

  var isCanceled = false;
  var stateRequestIDCounter = state.requestIDCounter;

  function cancelFunction() {
    isCanceled = true;
    bridge('cosmos_request_cancel', [stateRequestIDCounter]);
  }

  // run is a recursive function that does a bridge request and then keeps
  // pulling values after every response in the case of a subscription. In
  // case we are not subscribing, or the cancelFunction has been called,
  // run sends cosmos_request_cancel and terminates.
  function run(isFirst, requestIDCounter) {
    var messageName = isFirst ? 'cosmos_request_create' : 'cosmos_request_pull';
    bridge(messageName, requestArguments, function (error, responseString) {
      // The request to cancel may not have gotten to the bridge
      // before the original request got resolved,
      // so make sure not to continue if we detect it's been canceled.
      if (isCanceled) {
        return;
      }
      try {
        if (callback) {
          if (error) {
            callback(error);
          } else {
            callback(null, responseString);
          }
        }
      } finally {
        if (opts.method !== 'SUB') {
          // If the request was a non-SUB, tell core to clean up the request.
          // NOTE: Not sure if this is strictly necessary,
          // have not been to investigate in C++-land, so for now
          // we are just mimicing the behavior of spotify-cosmos-api.
          bridge('cosmos_request_cancel', [requestIDCounter]);
        } else if (!isCanceled) {
          // maybe canceled in above callback
          run(false, requestIDCounter);
        }
      }
    });
  }

  run(true, stateRequestIDCounter);

  return cancelFunction;
}

var TEN_PER_SECOND_FOR_A_YEAR = 10 * 60 * 60 * 24 * 365;

var COSMOS_VERBS = ['GET', 'HEAD', 'POST', 'PUT', 'SUB', 'PATCH', 'DELETE'];

module.exports = cosmosRequest;

},{}],64:[function(require,module,exports){
(function (global){
'use strict';

var debug = require('debug')('spotify-bridge-request');
var defer = require('spotify-deferred');

var cosmosBaseFunction = require('./cosmos');

// NOTE: Implicit global state.
var scheduledCoreFlush = false;
var cosmosState = null;

exports.cosmos = cosmos;
exports.cosmosJSON = cosmosJSON;
exports.request = request;
exports._request = _request;

function cosmos() {
  if (!cosmosState) cosmosState = {};

  var baseArguments = [cosmosState, request];
  var cancelFunction = cosmosBaseFunction.apply(null, baseArguments.concat(Array.prototype.slice.call(arguments)));
  return cancelFunction;
}

function _createCallbackWrapper(callback) {
  return function callbackWrapper(err, response) {
    if (!err) {
      var parsedResponse;
      try {
        parsedResponse = JSON.parse(response.body);
      } catch (e) {
        e.message = 'Failed to parse cosmos response: ' + e.message;
        callback(e);
        return;
      }
      callback(null, parsedResponse);
    } else {
      callback(err, response);
    }
  };
}

function cosmosJSON(opts, callback) {
  if (opts.body) {
    opts.body = JSON.stringify(opts.body);
  }
  var callbackWrapper = callback ? _createCallbackWrapper(callback) : null;
  var cancelFunction = cosmos(opts, callbackWrapper);
  return cancelFunction;
}

function request(name, opt_args, opt_callback) {
  var args = opt_args || [];
  var callback = getCallback(name, args, opt_callback);

  debug('req:' + name, args);

  exports._request(name, args, callback);

  if (name !== 'core_flush' && !scheduledCoreFlush) {
    scheduledCoreFlush = true;
    defer(flushCore);
  }

  return exports;
}

function _request(name, args, callback) {
  global._getSpotifyModule('bridge').executeRequest(JSON.stringify({
    name: name,
    args: args
  }), {
    onSuccess: getSuccessHandler(callback),
    onFailure: getFailureHandler(callback, name, args)
  });
}

function getCallback(name, args, opt_userCallback) {
  var userCallback = opt_userCallback || function () {};

  return function (error, data) {
    if (error) {
      if (error.name === 'timeout') {
        // Set the delay between 300ms and 400ms
        var delay = 300 + Math.floor(Math.random() * 100);

        debug('timeout', error.message);

        // Retry the request
        setTimeout(function () {
          request(name, args, userCallback);
        }, delay);
        return;
      }
    }

    debug('res:' + name, args, data);

    userCallback(error, data);
  };
}

function getSuccessHandler(requestCallback) {
  return function (data) {
    var parsed;

    debug('success', data);

    try {
      parsed = JSON.parse(data);
    } catch (error) {
      requestCallback(error);
    }

    if (parsed) {
      requestCallback(null, parsed);
    }
  };
}

function getFailureHandler(requestCallback, name, args) {
  return function (data) {
    var parsed;

    debug('failure', data);

    try {
      parsed = JSON.parse(data);
    } catch (error) {
      requestCallback(error);
    }

    if (parsed) {
      requestCallback(createError(name, args, parsed));
    }
  };
}

function createError(name, args, response) {
  var argsString = JSON.stringify(args);
  var debug = ' (bridge message: \'' + name + '\', args: ' + argsString + ')';
  var msg = response.message + debug;
  var error = new Error(msg);
  error.name = response.error;

  return error;
}

function flushCore() {
  scheduledCoreFlush = false;
  request('core_flush');
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./cosmos":63,"debug":314,"spotify-deferred":421}],65:[function(require,module,exports){
'use strict';

var parser = require('../spotify-live/util/parser');

var sortMap = {
  track: {
    _replace: '',
    artists: {
      _replace: 'artist'
    },
    disc: {
      _replace: 'discNumber'
    },
    number: {
      _replace: 'trackNumber'
    },
    duration: {
      _replace: 'length'
    }
  },
  timeSinceAdded: {
    _reverse: true,
    _replace: 'addTime'
  },
  addedBy: {
    _replace: '',
    name: {
      _replace: 'addedByDisplayName'
    }
  }
};

function reverse(direction) {
  return direction === 'ASC' ? 'DESC' : 'ASC';
}

function walk(query, mapping, opt_direction, incomingCollector) {
  var results = [];
  var collector = incomingCollector && incomingCollector.slice() || [];

  for (var item, i = 0; item = query.mask[i]; i++) {
    var itemCollector = collector.slice();

    if (item.key) {
      var hasReplace = mapping && mapping[item.key] && mapping[item.key]._replace != null;

      var value = hasReplace ? mapping[item.key]._replace : item.key;
      if (value !== '') {

        // Only add the direction if there's not another sub object
        if (!item.mask) {
          var doReverse = !!(mapping && mapping[item.key] && mapping[item.key]._reverse);
          if (opt_direction) {
            opt_direction = opt_direction.toUpperCase();
            var direction = doReverse ? reverse(opt_direction) : opt_direction;
            value += ' ' + direction;
          }
        }
        itemCollector.push(value);
      }
    }

    if (item.mask) {
      var subLookUp = walk(item, mapping[item.key], opt_direction, itemCollector);
      if (subLookUp.length) {
        results.push(subLookUp);
      }
    } else {
      if (itemCollector.length) {
        results.push(itemCollector.join('.'));
      }
    }
  }
  return results;
}

function getParams(query, opt_direction, opt_map) {
  var parsed = parser(query);
  if (!query) return null;

  var map = opt_map || sortMap;
  var result = walk(parsed, map, opt_direction);

  return result.join(',');
}

module.exports = getParams;

},{"../spotify-live/util/parser":254}],66:[function(require,module,exports){
/*
attributes
*/"use strict";

var $ = require("./base");

var trim = require("mout/string/trim"),
    forEach = require("mout/array/forEach"),
    filter = require("mout/array/filter"),
    indexOf = require("mout/array/indexOf");

// attributes

$.implement({

    setAttribute: function setAttribute(name, value) {
        return this.forEach(function (node) {
            node.setAttribute(name, value);
        });
    },

    getAttribute: function getAttribute(name) {
        var attr = this[0].getAttributeNode(name);
        return attr && attr.specified ? attr.value : null;
    },

    hasAttribute: function hasAttribute(name) {
        var node = this[0];
        if (node.hasAttribute) return node.hasAttribute(name);
        var attr = node.getAttributeNode(name);
        return !!(attr && attr.specified);
    },

    removeAttribute: function removeAttribute(name) {
        return this.forEach(function (node) {
            var attr = node.getAttributeNode(name);
            if (attr) node.removeAttributeNode(attr);
        });
    }

});

var accessors = {};

forEach(["type", "value", "name", "href", "title", "id"], function (name) {

    accessors[name] = function (value) {
        return value !== undefined ? this.forEach(function (node) {
            node[name] = value;
        }) : this[0][name];
    };
});

// booleans

forEach(["checked", "disabled", "selected"], function (name) {

    accessors[name] = function (value) {
        return value !== undefined ? this.forEach(function (node) {
            node[name] = !!value;
        }) : !!this[0][name];
    };
});

// className

var classes = function classes(className) {
    var classNames = trim(className).replace(/\s+/g, " ").split(" "),
        uniques = {};

    return filter(classNames, function (className) {
        if (className !== "" && !uniques[className]) return uniques[className] = className;
    }).sort();
};

accessors.className = function (className) {
    return className !== undefined ? this.forEach(function (node) {
        node.className = classes(className).join(" ");
    }) : classes(this[0].className).join(" ");
};

// attribute

$.implement({

    attribute: function attribute(name, value) {
        var accessor = accessors[name];
        if (accessor) return accessor.call(this, value);
        if (value != null) return this.setAttribute(name, value);
        if (value === null) return this.removeAttribute(name);
        if (value === undefined) return this.getAttribute(name);
    }

});

$.implement(accessors);

// shortcuts

$.implement({

    check: function check() {
        return this.checked(true);
    },

    uncheck: function uncheck() {
        return this.checked(false);
    },

    disable: function disable() {
        return this.disabled(true);
    },

    enable: function enable() {
        return this.disabled(false);
    },

    select: function select() {
        return this.selected(true);
    },

    deselect: function deselect() {
        return this.selected(false);
    }

});

// classNames, has / add / remove Class

$.implement({

    classNames: function classNames() {
        return classes(this[0].className);
    },

    hasClass: function hasClass(className) {
        return indexOf(this.classNames(), className) > -1;
    },

    addClass: function addClass(className) {
        return this.forEach(function (node) {
            var nodeClassName = node.className;
            var classNames = classes(nodeClassName + " " + className).join(" ");
            if (nodeClassName !== classNames) node.className = classNames;
        });
    },

    removeClass: function removeClass(className) {
        return this.forEach(function (node) {
            var classNames = classes(node.className);
            forEach(classes(className), function (className) {
                var index = indexOf(classNames, className);
                if (index > -1) classNames.splice(index, 1);
            });
            node.className = classNames.join(" ");
        });
    },

    toggleClass: function toggleClass(className, force) {
        var add = force !== undefined ? force : !this.hasClass(className);
        if (add) this.addClass(className);else this.removeClass(className);
        return !!add;
    }

});

// toString

$.prototype.toString = function () {
    var tag = this.tag(),
        id = this.id(),
        classes = this.classNames();

    var str = tag;
    if (id) str += '#' + id;
    if (classes.length) str += '.' + classes.join(".");
    return str;
};

var textProperty = document.createElement('div').textContent == null ? 'innerText' : 'textContent';

// tag, html, text, data

$.implement({

    tag: function tag() {
        return this[0].tagName.toLowerCase();
    },

    html: function html(_html) {
        return _html !== undefined ? this.forEach(function (node) {
            node.innerHTML = _html;
        }) : this[0].innerHTML;
    },

    text: function text(_text) {
        return _text !== undefined ? this.forEach(function (node) {
            node[textProperty] = _text;
        }) : this[0][textProperty];
    },

    data: function data(key, value) {
        switch (value) {
            case undefined:
                return this.getAttribute("data-" + key);
            case null:
                return this.removeAttribute("data-" + key);
            default:
                return this.setAttribute("data-" + key, value);
        }
    }

});

module.exports = $;

},{"./base":67,"mout/array/filter":353,"mout/array/forEach":356,"mout/array/indexOf":357,"mout/string/trim":399}],67:[function(require,module,exports){
/*
elements
*/"use strict";

var prime = require("prime");

var _forEach = require("mout/array/forEach"),
    _map = require("mout/array/map"),
    _filter = require("mout/array/filter"),
    _every = require("mout/array/every"),
    _some = require("mout/array/some");

// uniqueID

var index = 0,
    __dc = document.__counter,
    counter = document.__counter = (__dc ? parseInt(__dc, 36) + 1 : 0).toString(36),
    key = "uid:" + counter;

var uniqueID = function uniqueID(n) {
    if (n === window) return "window";
    if (n === document) return "document";
    if (n === document.documentElement) return "html";
    return n[key] || (n[key] = (index++).toString(36));
};

var instances = new WeakMap();

// elements prime

var $ = prime({ constructor: function $(n, context) {

        if (n == null) return this && this.constructor === $ ? new Elements() : null;

        var self, uid, instance;

        if (n.constructor !== Elements) {

            self = new Elements();

            if (typeof n === "string") {
                if (!self.search) return null;
                self[self.length++] = context || document;
                return self.search(n);
            }

            if (n.nodeType || n === window) {

                self[self.length++] = n;
            } else if (n.length) {

                // this could be an array, or any object with a length attribute,
                // including another instance of elements from another interface.

                var uniques = {};

                for (var i = 0, l = n.length; i < l; i++) {
                    // perform elements flattening
                    var nodes = $(n[i], context);
                    if (nodes && nodes.length) for (var j = 0, k = nodes.length; j < k; j++) {
                        var node = nodes[j];
                        uid = uniqueID(node);
                        if (!uniques[uid]) {
                            self[self.length++] = node;
                            uniques[uid] = true;
                        }
                    }
                }
            }
        } else {
            self = n;
        }

        if (!self.length) return null;

        // when length is 1 always use the same elements instance

        if (self.length === 1) {
            if (instance = instances.get(self[0])) {
                return instance;
            } else {
                instances.set(self[0], self);
            }
        }

        return self;
    } });

var Elements = prime({

    inherits: $,

    constructor: function Elements() {
        this.length = 0;
    },

    unlink: function unlink() {
        return this.map(function (node) {
            instances.delete(node);
            return node;
        });
    },

    // methods

    forEach: function forEach(method, context) {
        _forEach(this, method, context);
        return this;
    },

    map: function map(method, context) {
        return _map(this, method, context);
    },

    filter: function filter(method, context) {
        return _filter(this, method, context);
    },

    every: function every(method, context) {
        return _every(this, method, context);
    },

    some: function some(method, context) {
        return _some(this, method, context);
    }

});

module.exports = $;

},{"mout/array/every":352,"mout/array/filter":353,"mout/array/forEach":356,"mout/array/map":359,"mout/array/some":364,"prime":404}],68:[function(require,module,exports){
/*
delegation
*/"use strict";

var Map = require("prime/map");

var $ = require("./events");
require('./traversal');

$.implement({

    delegate: function delegate(event, selector, handle) {

        return this.forEach(function (node) {

            var self = $(node);

            var delegation = self._delegation || (self._delegation = {}),
                events = delegation[event] || (delegation[event] = {}),
                map = events[selector] || (events[selector] = new Map());

            if (map.get(handle)) return;

            var action = function action(e) {
                var target = $(e.target || e.srcElement),
                    match = target.matches(selector) ? target : target.parent(selector);

                var res;

                if (match) res = handle.call(self, e, match);

                return res;
            };

            map.set(handle, action);

            self.on(event, action);
        });
    },

    undelegate: function undelegate(event, selector, handle) {

        return this.forEach(function (node) {

            var self = $(node),
                delegation,
                events,
                map;

            if (!(delegation = self._delegation) || !(events = delegation[event]) || !(map = events[selector])) return;

            var action = map.get(handle);

            if (action) {
                self.off(event, action);
                map.remove(action);

                // if there are no more handles in a given selector, delete it
                if (!map.count()) delete events[selector];
                // var evc = evd = 0, x
                var e1 = true,
                    e2 = true,
                    x;
                for (x in events) {
                    e1 = false;
                    break;
                }
                // if no more selectors in a given event type, delete it
                if (e1) delete delegation[event];
                for (x in delegation) {
                    e2 = false;
                    break;
                }
                // if there are no more delegation events in the element, delete the _delegation object
                if (e2) delete self._delegation;
            }
        });
    }

});

module.exports = $;

},{"./events":69,"./traversal":72,"prime/map":405}],69:[function(require,module,exports){
/*
events
*/"use strict";

var Emitter = require("prime/emitter");

var $ = require("./base");

$.implement({

    on: function on(event, handle, useCapture) {

        return this.forEach(function (node) {
            var self = $(node);

            var internalEvent = event + (useCapture ? ":capture" : "");

            Emitter.prototype.on.call(self, internalEvent, handle);

            var domListeners = self._domListeners || (self._domListeners = {});
            if (!domListeners[internalEvent]) {
                var listener = function listener(e) {
                    Emitter.prototype.emit.call(self, internalEvent, e || window.event, Emitter.EMIT_SYNC);
                };
                node.addEventListener(event, listener, useCapture || false);
                domListeners[internalEvent] = listener;
            }
        });
    },

    off: function off(event, handle, useCapture) {

        return this.forEach(function (node) {

            var self = $(node);

            var internalEvent = event + (useCapture ? ":capture" : "");

            var domListeners = self._domListeners,
                domEvent,
                listeners = self._listeners,
                events;

            if (domListeners && (domEvent = domListeners[internalEvent]) && listeners && (events = listeners[internalEvent])) {

                Emitter.prototype.off.call(self, internalEvent, handle);

                if (!self._listeners || !self._listeners[event]) {
                    node.removeEventListener(event, domEvent, false);
                    delete domListeners[event];

                    for (var l in domListeners) {
                        return;
                    }delete self._domListeners;
                }
            }
        });
    },

    emit: function emit() {
        var args = arguments;
        return this.forEach(function (node) {
            Emitter.prototype.emit.apply($(node), args);
        });
    }

});

module.exports = $;

},{"./base":67,"prime/emitter":403}],70:[function(require,module,exports){
/*
elements
*/"use strict";

var $ = require("./base");
require("./attributes");
require("./events");
require("./insertion");
require("./traversal");
require("./delegation");

module.exports = $;

},{"./attributes":66,"./base":67,"./delegation":68,"./events":69,"./insertion":71,"./traversal":72}],71:[function(require,module,exports){
/*
insertion
*/"use strict";

var $ = require("./base");

// base insertion

$.implement({

    appendChild: function appendChild(child) {
        this[0].appendChild($(child)[0]);
        return this;
    },

    insertBefore: function insertBefore(child, ref) {
        this[0].insertBefore($(child)[0], $(ref)[0]);
        return this;
    },

    removeChild: function removeChild(child) {
        this[0].removeChild($(child)[0]);
        return this;
    },

    replaceChild: function replaceChild(child, ref) {
        this[0].replaceChild($(child)[0], $(ref)[0]);
        return this;
    }

});

// before, after, bottom, top

$.implement({

    before: function before(element) {
        element = $(element)[0];
        var parent = element.parentNode;
        if (parent) this.forEach(function (node) {
            parent.insertBefore(node, element);
        });
        return this;
    },

    after: function after(element) {
        element = $(element)[0];
        var parent = element.parentNode;
        if (parent) this.forEach(function (node) {
            parent.insertBefore(node, element.nextSibling);
        });
        return this;
    },

    bottom: function bottom(element) {
        element = $(element)[0];
        return this.forEach(function (node) {
            element.appendChild(node);
        });
    },

    top: function top(element) {
        element = $(element)[0];
        return this.forEach(function (node) {
            element.insertBefore(node, element.firstChild);
        });
    }

});

// insert, replace

$.implement({

    insert: $.prototype.bottom,

    remove: function remove() {
        return this.forEach(function (node) {
            var parent = node.parentNode;
            if (parent) parent.removeChild(node);
        });
    },

    replace: function replace(element) {
        element = $(element)[0];
        element.parentNode.replaceChild(this[0], element);
        return this;
    }

});

module.exports = $;

},{"./base":67}],72:[function(require,module,exports){
/*
traversal
*/"use strict";

var map = require("mout/array/map");

var slick = require("slick");

var $ = require("./base");

var gen = function gen(combinator, expression) {
    return map(slick.parse(expression || "*"), function (part) {
        return combinator + " " + part;
    }).join(", ");
};

var push_ = Array.prototype.push;

$.implement({

    search: function search(expression) {
        if (this.length === 1) return $(slick.search(expression, this[0], new $()));

        var buffer = [];
        for (var i = 0, node; node = this[i]; i++) {
            push_.apply(buffer, slick.search(expression, node));
        }buffer = $(buffer);
        return buffer && buffer.sort();
    },

    find: function find(expression) {
        if (this.length === 1) return $(slick.find(expression, this[0]));

        for (var i = 0, node; node = this[i]; i++) {
            var found = slick.find(expression, node);
            if (found) return $(found);
        }

        return null;
    },

    sort: function sort() {
        return slick.sort(this);
    },

    matches: function matches(expression) {
        return slick.matches(this[0], expression);
    },

    contains: function contains(node) {
        return slick.contains(this[0], node);
    },

    nextSiblings: function nextSiblings(expression) {
        return this.search(gen('~', expression));
    },

    nextSibling: function nextSibling(expression) {
        return this.find(gen('+', expression));
    },

    previousSiblings: function previousSiblings(expression) {
        return this.search(gen('!~', expression));
    },

    previousSibling: function previousSibling(expression) {
        return this.find(gen('!+', expression));
    },

    children: function children(expression) {
        return this.search(gen('>', expression));
    },

    firstChild: function firstChild(expression) {
        return this.find(gen('^', expression));
    },

    lastChild: function lastChild(expression) {
        return this.find(gen('!^', expression));
    },

    parent: function parent(expression) {
        var buffer = [];
        loop: for (var i = 0, node; node = this[i]; i++) {
            while ((node = node.parentNode) && node !== document) {
                if (!expression || slick.matches(node, expression)) {
                    buffer.push(node);
                    break loop;
                    break;
                }
            }
        }return $(buffer);
    },

    parents: function parents(expression) {
        var buffer = [];
        for (var i = 0, node; node = this[i]; i++) {
            while ((node = node.parentNode) && node !== document) {
                if (!expression || slick.matches(node, expression)) buffer.push(node);
            }
        }return $(buffer);
    }

});

module.exports = $;

},{"./base":67,"mout/array/map":359,"slick":408}],73:[function(require,module,exports){
/*
zen
*/"use strict";

var forEach = require("mout/array/forEach"),
    map = require("mout/array/map");

var parse = require("slick/parser");

var $ = require("./base");

module.exports = function (expression, doc) {

    return $(map(parse(expression), function (expression) {

        var previous, result;

        forEach(expression, function (part, i) {

            var node = (doc || document).createElement(part.tag);

            if (part.id) node.id = part.id;

            if (part.classList) node.className = part.classList.join(" ");

            if (part.attributes) forEach(part.attributes, function (attribute) {
                node.setAttribute(attribute.name, attribute.value || "");
            });

            if (part.pseudos) forEach(part.pseudos, function (pseudo) {
                var n = $(node),
                    method = n[pseudo.name];
                if (method) method.call(n, pseudo.value);
            });

            if (i === 0) {

                result = node;
            } else if (part.combinator === " ") {

                previous.appendChild(node);
            } else if (part.combinator === "+") {
                var parentNode = previous.parentNode;
                if (parentNode) parentNode.appendChild(node);
            }

            previous = node;
        });

        return result;
    }));
};

},{"./base":67,"mout/array/forEach":356,"mout/array/map":359,"slick/parser":409}],74:[function(require,module,exports){
'use strict';

var $ = require('../spotify-elements');
var forIn = require('mout/object/forIn');
var live = require('../spotify-live');
var center = require('./center');

var IS_ADDED_PROPERTY = 'added';
var FOLLOWERSCOUNT_PROPERTY = 'followersCount';
var FOLLOWINGCOUNT_PROPERTY = 'followingCount';
var BUTTON_SELECTOR = '[data-button=add]';
var JUSTCHANGED_CLASSNAME = 'just-changed';
var ADDED_CLASSNAME = 'added';

var dataPropertiesForAdd = [IS_ADDED_PROPERTY, FOLLOWERSCOUNT_PROPERTY, FOLLOWINGCOUNT_PROPERTY];

var changeHandlers = {};

function getAddedClass(node) {
  var addedClassNode = node[0].closest('data-class-added');
  return addedClassNode ? addedClassNode.getAttribute('data-class-added') : ADDED_CLASSNAME;
}

function getURIFromNode(node) {
  var stateNode = node[0].closest('[data-uri]');
  if (!stateNode) {
    return null;
  }
  return stateNode.getAttribute('data-uri');
}

var eventHandlers = {

  click: function click(event, node) {
    var stateNode = $(node[0].closest('[data-uri]'));
    if (!stateNode) return;

    var uri = stateNode.data('uri');
    if (!uri) return;

    var addedClass = getAddedClass(node);
    var shouldBeAdded = !stateNode.hasClass(addedClass);
    var data = {
      added: shouldBeAdded
    };

    node.addClass(JUSTCHANGED_CLASSNAME);

    // using capture=true to handle buttons with inner divs (used for changing button text)
    node.on('mouseout', function mouseoutHandler(event) {
      if (event.target !== node[0]) return;
      node.off('mouseout', mouseoutHandler);
      node.removeClass(JUSTCHANGED_CLASSNAME);
    }, true);

    // Publish will trigger the update event, which will then update the UI
    live(uri).publish(data);
  },

  changeHandler: function changeHandler(key, value, uri) {
    if (key === IS_ADDED_PROPERTY) {
      var numAffectedButtons = actions.setStateForURI(uri, value);
      if (numAffectedButtons === 0) {
        live(uri).off('update', changeHandlers[uri]);
        delete changeHandlers[uri];
      }
    }

    if (dataPropertiesForAdd.indexOf(key) > -1) {
      center.emit('add-data-change', { uri: uri, model: live(uri), key: key, value: value });
    }
  }

};

var actions = {

  setStateForURI: function setStateForURI(uri, isAdded) {
    var numAffectedButtons = 0;

    var nodes = $(document).search(BUTTON_SELECTOR);
    if (!nodes) return numAffectedButtons;

    for (var i = 0, l = nodes.length; i < l; i++) {
      var node = $(nodes[i]);
      var buttonURI = getURIFromNode(node);
      if (uri === buttonURI) {
        numAffectedButtons++;
        actions.setStateForButtonNode(node, isAdded);
      }
    }

    return numAffectedButtons;
  },

  setStateForButtonNode: function setStateForButtonNode(node, isAdded) {
    var stateNode = $(node[0].closest('[data-uri]'));
    if (!stateNode) return;

    var addedClass = getAddedClass(node);
    actions.setVisualState(isAdded, stateNode, node, addedClass);
  },

  setVisualState: function setVisualState(isAdded, node, button, className) {
    if (isAdded) {
      if (!node.hasClass(className)) node.addClass(className);
      var tooltipRemove = button.data('tooltip-remove');
      if (tooltipRemove) {
        button.setAttribute('data-tooltip', tooltipRemove);
        button.setAttribute('aria-label', tooltipRemove);
      }
      button.setAttribute('data-log-click', 'remove-button');
    } else {
      if (node.hasClass(className)) node.removeClass(className);
      var tooltipAdd = button.data('tooltip-add');
      if (tooltipAdd) {
        button.setAttribute('data-tooltip', tooltipAdd);
        button.setAttribute('aria-label', tooltipAdd);
      }
      button.setAttribute('data-log-click', 'add-button');
    }
  },

  addListenerForNode: function addListenerForNode(node) {
    var uri = getURIFromNode(node);

    // If we have already added a change handler for this URI,
    // we don't want to add another one, so we cancel early.
    // Before cancelling though, we should update button states
    // with the current state from the live model, since there
    // might be new buttons in the DOM.
    if (changeHandlers[uri]) {
      live(uri).get('added', function (error, isAdded) {
        if (error) throw error;
        actions.setStateForButtonNode(node, isAdded);
      });
      return;
    }

    changeHandlers[uri] = function (properties) {
      for (var key in properties) {
        var value = properties[key];
        eventHandlers.changeHandler(key, value, uri);
      };
    };

    var model = live(uri);

    // Get the initial state and update the button
    model.get('added', function (error, isAdded) {
      if (error) throw error;
      actions.setStateForButtonNode(node, isAdded);

      // When the initial state is known, we listen for updates
      // so we can update all buttons for this URI later.
      model.on('update', changeHandlers[uri]);
    });
  }

};

var handleScrollShow = function handleScrollShow(data) {
  update(data.pageNode, data.nodes);
};

// Export for testing
exports._classNames = {
  ADDED: ADDED_CLASSNAME,
  JUSTCHANGED: JUSTCHANGED_CLASSNAME
};

var isAttached = false;

exports.attach = function attach() {
  if (isAttached) return;
  isAttached = true;

  $(document).delegate('click', BUTTON_SELECTOR, eventHandlers.click);

  center.on('scroll-show-before', handleScrollShow);
};

exports.detach = function detach() {
  if (!isAttached) return;
  isAttached = false;

  $(document).undelegate('click', BUTTON_SELECTOR, eventHandlers.click);
  center.off('scroll-show-before', handleScrollShow);
};

var update = exports.update = function update(node, nodes) {
  if (!isAttached) return;

  // If the node passed in is a button node, just add listeners for that
  if (node && $(node).matches(BUTTON_SELECTOR)) {
    actions.addListenerForNode($(node));

    // Otherwise search all the children of the node (or the document
    // if node is not provided) for buttons.
  } else {

      var nodes = ($(nodes) || $(node) || $(document)).search(BUTTON_SELECTOR);
      if (!nodes) return;

      for (var i = 0, l = nodes.length; i < l; i++) {
        actions.addListenerForNode($(nodes[i]));
      }
    }
};

},{"../spotify-elements":70,"../spotify-live":251,"./center":77,"mout/object/forIn":388}],75:[function(require,module,exports){
'use strict';

var $ = require('../spotify-elements');
var Navigator = require('../spotify-navigation/navigator');
var AppState = require('../spotify-navigation/app-state');

var SELECTOR = 'a';

var nav = new Navigator();

var handleAnchorClick = function handleAnchorClick(event, node) {
  var anchor = node[0];
  var href = anchor.getAttribute('href');
  if (!href || href[0] === '#') {
    return;
  }

  event.preventDefault();

  var referrer = anchor.getAttribute('data-referrer-id') || document.body.getAttribute('data-referrer-id');

  var state = new AppState(href);

  if (referrer) {
    state.setReferrer(referrer);
  }

  nav.requestOpenState(state);
};

var isAttached = false;

exports.attach = function attach() {
  if (isAttached) {
    return;
  }
  isAttached = true;
  $(document).delegate('click', SELECTOR, handleAnchorClick);
};

exports.detach = function detach() {
  if (!isAttached) {
    return;
  }
  isAttached = false;
  $(document).undelegate('click', SELECTOR, handleAnchorClick);
};

exports.update = function () {};

},{"../spotify-elements":70,"../spotify-navigation/app-state":268,"../spotify-navigation/navigator":270}],76:[function(require,module,exports){
(function (global){
'use strict';

var $ = require('../spotify-elements');
var doc = $(document);
var win = $(window);

// Decides how many pixels allowed between two touchmoves to determine if it is a swipe
var SWIPE_SENSITIVITY = 1;
// Constant that sets the amount of pixels allowed to move without locking the horizontal scroll
var SCROLL_LOCK_LIMIT = 10;
// The divider used to calculate the swipe speed. A larger number will make a slower swipe
var SWIPE_LAG = 14;

var handleClickLeft = function handleClickLeft(event, node) {
  handleButtonClick(node, true);
};

var handleClickRight = function handleClickRight(event, node) {
  handleButtonClick(node, false);
};

var getCarouselInner = function getCarouselInner(node) {
  return node.search('[data-carousel-inner]');
};

var getCarouselObjectsWidth = function getCarouselObjectsWidth(carouselInner) {
  var mediaObjects = $(carouselInner).search('.media-object');
  if (!mediaObjects) {
    return;
  }
  var mediaObjectWidth = parseFloat(global.getComputedStyle(mediaObjects[0]).width);
  var carouselInnerWidth = parseFloat(global.getComputedStyle(carouselInner).width);
  var carouselTotalWidth = carouselInner.scrollWidth;

  return {
    mediaObjectWidth: mediaObjectWidth,
    carouselInnerWidth: carouselInnerWidth,
    carouselTotalWidth: carouselTotalWidth
  };
};

var calculateMinLeftPixels = function calculateMinLeftPixels(carouselInner) {
  var minLeft = 0;
  // Determine number of pages based on numbers per page and total number of objects
  var carouselObjectsWidth = getCarouselObjectsWidth(carouselInner);
  var objectsPerPage = Math.round(carouselObjectsWidth.carouselInnerWidth / carouselObjectsWidth.mediaObjectWidth);
  var totalNrOfObjects = Math.round(carouselObjectsWidth.carouselTotalWidth / carouselObjectsWidth.mediaObjectWidth);
  var nrOfPages = Math.ceil(totalNrOfObjects / objectsPerPage);
  minLeft = -(carouselObjectsWidth.carouselInnerWidth * (nrOfPages - 1));
  return minLeft;
};

var handleTouchStart = function handleTouchStart(event, node) {
  // Disable swiping the carousel if scrolling down/up the page
  var scrollBlocked = false;
  doc.on('scroll', handleScroll);
  function handleScroll(event) {
    if (!scrollBlocked) {
      doc.undelegate('touchmove', '[data-carousel]', handleTouchMove);
      doc.undelegate('touchend', '[data-carousel]', handleTouchEnd);
    } else {
      event.preventDefault();
    }
  }

  // Get carousel element
  var carouselInner = getCarouselInner(node);
  if (!carouselInner) {
    return;
  }
  carouselInner = carouselInner[0];
  var startX;
  var previousX;
  var deltaX;
  // minLeft is always a negative number or 0. This is the minimum LEFT position of the carousel.
  var minLeft = calculateMinLeftPixels(carouselInner);
  if (minLeft === 0) {
    return;
  }
  doc.delegate('touchmove', '[data-carousel]', handleTouchMove);
  doc.delegate('touchend', '[data-carousel]', handleTouchEnd);

  // Get start coordinates
  if (event.touches) {
    startX = event.touches[0].pageX;
    previousX = startX;
  }

  function handleTouchMove(event) {
    if (!carouselInner) {
      return;
    }
    addDragTransition();

    if (event.touches) {
      var x = event.touches[0].pageX;
      deltaX = previousX - x;
      // Get position of carousel
      var positionLeft = carouselPosition(carouselInner);
      positionLeft = getPositionInPixels(positionLeft, carouselInner);
      // Set adjusted position
      var adjust = positionLeft - deltaX;
      // Check that carousel position doesn't exceed limits
      adjust = checkLimitsPixels(adjust, minLeft);
      carouselInner.style.left = adjust + 'px';
      previousX = x;

      if (deltaX > SCROLL_LOCK_LIMIT) {
        scrollBlocked = true;
      }
      if (scrollBlocked) {
        event.preventDefault();
      }
    }
  };

  function handleTouchEnd(event) {
    doc.undelegate('touchmove', '[data-carousel]', handleTouchMove);
    doc.undelegate('touchend', '[data-carousel]', handleTouchEnd);
    doc.off('scroll', handleScroll);
    if (!carouselInner) {
      return;
    }
    // If considered as a swipe, swipe
    if (Math.abs(deltaX) > SWIPE_SENSITIVITY) {
      swipe(deltaX);
    }
    updateButtonsOnTouch(node);
  };

  /* Touch swipe functions */

  var swipe = function swipe(deltaX) {
    addSwipeTransition();
    // Get position of carousel
    var leftValue = carouselPosition(carouselInner);
    leftValue = getPositionInPixels(leftValue, carouselInner);

    var carouselObjectsWidth = getCarouselObjectsWidth(carouselInner);
    // Get width of one mediaobject to us as an interval in the calculation for setting the swipe speed
    var mediaObjectWidth = parseInt(carouselObjectsWidth.mediaObjectWidth);
    if (!mediaObjectWidth) {
      return;
    }
    // Calculate position to swipe to based on value of deltaX (e.g. swipe acceleration) and SWIPE_LAG
    // SWIPE_LAG can be changed to a lower/higher value to increase/decrease speed.
    var adjust = leftValue + mediaObjectWidth * (-deltaX / SWIPE_LAG);
    // Check that carousel position doesn't exceed limits
    adjust = checkLimitsPixels(adjust, minLeft);
    carouselInner.style.left = adjust + 'px';
  };

  var updateButtonsOnTouch = function updateButtonsOnTouch(node) {
    var carouselId = node.data('carousel');
    var positionLeft = carouselPosition(carouselInner);
    positionLeft = getPositionInPixels(positionLeft, carouselInner);
    var carouselRight = $('[data-carousel=' + carouselId + '][data-button=carousel-right]');
    var carouselLeft = $('[data-carousel=' + carouselId + '][data-button=carousel-left]');

    if (Math.round(positionLeft) <= Math.round(minLeft)) {
      carouselRight.setAttribute('disabled', 'disabled');
    } else {
      carouselRight.removeAttribute('disabled');
    }

    if (positionLeft >= 0) {
      carouselLeft.setAttribute('disabled', 'disabled');
    } else {
      carouselLeft.removeAttribute('disabled');
    }
  };

  var addSwipeTransition = function addSwipeTransition() {
    if (!carouselInner) {
      return;
    }
    // Add swipe transition and remove drag + click transition
    $(carouselInner).addClass('crsl-inner-swipe').removeClass('crsl-inner-drag');
  };

  var addDragTransition = function addDragTransition() {
    if (!carouselInner) {
      return;
    }
    // Add drag transition and remove swipe + click transition
    $(carouselInner).addClass('crsl-inner-drag').removeClass('crsl-inner-swipe');
  };
};

var resetTransitions = function resetTransitions(carouselInner) {
  if (!carouselInner) {
    return;
  }
  // Add click transition and remove drag + swipe transition
  $(carouselInner).removeClass('crsl-inner-drag').removeClass('crsl-inner-swipe');
};

var checkLimitsPixels = function checkLimitsPixels(adjust, minLeft) {
  adjust = Math.min(adjust, 0);
  adjust = Math.max(adjust, minLeft);
  return adjust;
};

var carouselPosition = function carouselPosition(carouselInner) {
  return carouselInner.style.left || '0';
};

var getPositionInPixels = function getPositionInPixels(positionLeft, carouselInner) {
  var isInPx = positionLeft.endsWith('px');
  positionLeft = parseFloat(positionLeft);
  // If current unit isn't px, change to px
  if (!isInPx) {
    var currentPage = Math.abs(positionLeft / 100);
    // var carouselInnerWidth = carouselInner.clientWidth;
    var carouselInnerWidth = getCarouselObjectsWidth(carouselInner).carouselInnerWidth;
    positionLeft = -carouselInnerWidth * currentPage;
  }
  return positionLeft;
};

var getNextPageInPercent = function getNextPageInPercent(positionLeft, carouselInner, isLeft) {
  var carouselInnerWidth = carouselInner.clientWidth;
  var minLeft = calculateMinLeftPixels(carouselInner);
  var isInPercent = positionLeft.endsWith('%');
  positionLeft = parseInt(positionLeft);
  // If current unit isn't %, change to %
  var nextPage;
  if (!isInPercent) {
    nextPage = Math.abs(positionLeft / carouselInnerWidth);
    // If position is to the end left and button is right
    if (positionLeft === 0 && !isLeft) {
      nextPage = -100;
    }
    // If position is to the end right and button is left
    else if (positionLeft === minLeft && isLeft) {
        nextPage = (nextPage - 1) * -100;
      } else {
        nextPage = isLeft ? Math.floor(nextPage) : Math.ceil(nextPage);
        nextPage = nextPage * -100;
      }
  }
  // If current unit already is in percent
  else {
      nextPage = isLeft ? positionLeft + 100 : positionLeft - 100;
    }
  return nextPage;
};

var handleButtonClick = function handleButtonClick(buttonNode, isLeft) {
  if (buttonNode.hasAttribute('disabled')) {
    return;
  }
  var carouselId = buttonNode.data('carousel');
  var carouselInner = $('[data-carousel=' + carouselId + '][data-carousel-main] [data-carousel-inner]')[0];
  var positionLeft = carouselPosition(carouselInner);

  var adjust;
  if (positionLeft) {
    // Get next page in %
    var nextPage = getNextPageInPercent(positionLeft, carouselInner, isLeft);
    adjust = nextPage;
  } else {
    adjust = isLeft ? 0 : -100;
  }
  // Reset transitions
  resetTransitions(carouselInner);
  carouselInner.style.left = adjust + '%';
  updateButtonStates(carouselId);
};

var updateButtonStates = function updateButtonStates(carouselId) {
  var carouselRight = $('[data-carousel=' + carouselId + '][data-button=carousel-right]');
  var carouselLeft = $('[data-carousel=' + carouselId + '][data-button=carousel-left]');
  var carousel = $('[data-carousel=' + carouselId + '][data-carousel-main]');
  var carouselInner = $(carousel).search('[data-carousel-inner]')[0];
  var leftAdjust = carouselInner.style.left ? parseInt(carouselInner.style.left) : 0;

  if (leftAdjust >= 0) {
    carouselLeft.setAttribute('disabled', 'disabled');
  } else {
    carouselLeft.removeAttribute('disabled');
  }

  if (carouselInner.clientWidth - leftAdjust / 100 * carouselInner.clientWidth + 10 > carouselInner.scrollWidth) {
    carouselRight.setAttribute('disabled', 'disabled');
  } else {
    carouselRight.removeAttribute('disabled');
  }
};

var updateAllButtons = function updateAllButtons(node) {
  node = $(node) || doc;
  var carousels = node.search('[data-carousel-main]');
  if (carousels) {
    carousels.forEach(function (carousel) {
      updateButtonStates($(carousel).data('carousel'));
    });
  }
};

var isAttached = false;

exports.update = function update(node) {
  if (!isAttached) return;

  updateAllButtons(node);
};

exports.attach = function () {
  if (isAttached) return;
  isAttached = true;

  doc.delegate('click', '[data-button=carousel-right]', handleClickRight);
  doc.delegate('click', '[data-button=carousel-left]', handleClickLeft);
  doc.delegate('touchstart', '[data-carousel][data-carousel-main]', handleTouchStart);

  win.on('resize', updateAllButtons);

  // Polyfill from: https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith
  if (!String.prototype.endsWith) {
    String.prototype.endsWith = function (searchString, position) {
      var subjectString = this.toString();
      if (position === undefined || position > subjectString.length) {
        position = subjectString.length;
      }
      position -= searchString.length;
      var lastIndex = subjectString.indexOf(searchString, position);
      return lastIndex !== -1 && lastIndex === position;
    };
  }
};

exports.detach = function () {
  if (!isAttached) return;
  isAttached = false;

  doc.undelegate('click', '[data-button=carousel-right]', handleClickRight);
  doc.undelegate('click', '[data-button=carousel-left]', handleClickLeft);
  doc.undelegate('touchstart', '[data-carousel][data-carousel-main]', handleTouchStart);

  win.off('resize', updateAllButtons);
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-elements":70}],77:[function(require,module,exports){
/*
Event Center
*/'use strict';

var Emitter = require('prime/emitter');

module.exports = new Emitter();

},{"prime/emitter":403}],78:[function(require,module,exports){
'use strict';

var $ = require('../spotify-elements');
var live = require('../spotify-live');
var selection = require('./selection');
var wrappedUriUtils = require('../spotify-live-wrapped-uri');
var cosmos = require('./util/cosmos');

var CONTEXTMENU = ['a[data-uri]', '[data-contextmenu]'].join(',');

var makeContextMenuData = function makeContextMenuData(selectionContexts, primaryIndex, uris, x, y) {
  var contexts = [];
  for (var i = 0, selectionContext; selectionContext = selectionContexts[i]; i++) {
    var keys = selectionContext.keys || [];
    var indices = selectionContext.indices || [];
    primaryIndex = primaryIndex || indices[0];
    primaryIndex = primaryIndex == null ? null : primaryIndex;

    var contextUri = selectionContext.uri;
    var liveList = live(contextUri).get('rows');

    var contextData = {
      uri: contextUri,
      keys: keys,
      indices: indices,
      primaryIndex: primaryIndex
    };

    var origin = selectionContext.origin;
    if (origin) {
      if (primaryIndex != null) {
        var wrappedList = live(contextUri).get('rows');
        var originList = live(origin.uri).get('rows');
        if (wrappedList && originList) {
          var key = wrappedList.keys[primaryIndex];
          origin.primaryIndex = originList.indexOf(key);
        }
      }
      contextData.origin = origin;
    }
    contexts.push(contextData);
  }
  return {
    contexts: contexts,
    x: x,
    y: y,
    uris: uris
  };
};

var handleContextMenuEvent = function handleContextMenuEvent(event, node) {
  event.preventDefault();
  event.stopPropagation();

  var x = event.clientX,
      y = event.clientY;

  if (node[0].tagName.toLowerCase() === 'a') {
    var uri = node.data('uri');
    if (uri) {
      showContextMenu({ uris: [uri], x: x, y: y });
    }
  } else {
    var contextNode = node.parent('[data-list]');
    var contextURI;
    if (contextNode) contextURI = contextNode.data('uri');

    var index = +node.data('index');

    var isSelected = false;
    var omitContext = false;
    var indices = selection.getIndicesPerList();

    if (contextNode) {
      isSelected = selection.isNodeSelected(node);
      // If the selection is shared between different lists, don't pass a contextURI.
      omitContext = indices.length > 1;
    }
    var uris = isSelected ? selection.getUris() : [node.data('uri')];
    showContextMenu(makeContextMenuData(indices, index, uris, x, y));
  }
};

var handleContextMenuButton = function handleContextMenuButton(event, node) {
  var parent;
  var uri = node.data('uri') || (parent = node.parent('[data-uri]')) && parent.data('uri');
  if (!uri) return;

  // The context menu can't know what to offer for a custom list.
  // In case of a sorted and/or filtered list, pass the origin list.
  uri = wrappedUriUtils.getOriginUri(uri) || uri;

  var contextURI = (parent = node.parent('[data-list][data-uri]')) && parent.data('uri');
  var contextIndex = (parent = node.parent('[data-index]')) && +parent.data('index');

  var contextMenuNode = $(node[0].closest('[data-button="contextmenu"]'));
  var relativeTo = contextMenuNode || parent || node;

  var rect = relativeTo[0].getBoundingClientRect();
  var x = rect.left + rect.width / 2;
  var y = rect.top + rect.height;

  // The coordinate must be within the app viewport
  if (y > window.innerHeight) y = window.innerHeight - 1;
  if (x > window.innerWidth) x = window.innerWidth - 1;

  var indices = contextIndex == null ? null : [contextIndex];
  contextIndex = contextIndex == null ? null : contextIndex;

  var context;
  if (contextURI) {
    context = { uri: contextURI };

    if (indices) {
      context.indices = indices;

      var liveList = live(contextURI).get('rows');
      context.keys = liveList ? indices.map(function (selectedIndex) {
        return liveList.keys[selectedIndex];
      }) : [];
    }

    // Add originList
    var origin = wrappedUriUtils.getOriginUri(contextURI);
    if (origin) {
      context.origin = { uri: origin };

      if (indices) {
        var wrappedList = live(contextURI).get('rows');
        var originList = live(origin).get('rows');
        if (wrappedList && originList) {
          var originIndices = indices.map(function (index) {
            var key = wrappedList.keys[index];
            return originList.indexOf(key);
          });
          var originKeys = indices.map(function (index) {
            return wrappedList.keys[index];
          });
          context.origin.indices = originIndices;
          context.origin.keys = originKeys;
        }
      }
    }
  }
  showContextMenu(makeContextMenuData([context], contextIndex, [uri], x, y));
  contextMenuNode.addClass('contextmenu-active');

  var cancel = cosmos.subscribe({ url: 'sp://messages/v1/context_menu_state' }, function (error, response) {
    if (!error && response.body.state === 'hide') {
      contextMenuNode.removeClass('contextmenu-active');
      cancel();
    }
  });
};

var showContextMenu = function showContextMenu(data) {
  var application = live('spotify:application');
  application.query('appURI', function (error, application_data) {
    if (!error) {
      data.appURI = application_data.appURI;
    }
    var client = live('spotify:client');
    client.emit('show-context-menu', data);
  });
};

var isAttached = false;

exports.attach = function attach() {
  if (isAttached) return;
  isAttached = true;

  $(document).delegate('contextmenu', CONTEXTMENU, handleContextMenuEvent);
  $(document).delegate('click', '[data-button=contextmenu]', handleContextMenuButton);
};

exports.detach = function detach() {
  if (!isAttached) return;
  isAttached = false;

  $(document).undelegate('contextmenu', CONTEXTMENU, handleContextMenuEvent);
  $(document).undelegate('click', '[data-button=contextmenu]', handleContextMenuButton);
};

exports.update = function () {};

},{"../spotify-elements":70,"../spotify-live":251,"../spotify-live-wrapped-uri":250,"./selection":113,"./util/cosmos":128}],79:[function(require,module,exports){
/**
 * @module spotify-events/dragndrop/custom/rootlist
 * @private
 */
'use strict';

var $ = require('../../../spotify-elements');

var liburi = require('spotify-liburi');
var live = require('../../../spotify-live');
var intersection = require('mout/array/intersection');

var hooks = require('../util/hooks');
var eventModel = require('../util/eventmodel');
var selection = require('../../selection');

var SELECTOR_LIST = '[data-list]';
var SELECTOR_LIST_ITEM = '[data-list-item]';
var SELECTOR_DRAGGABLE = 'a, [draggable]';
var ATTR_TARGET = 'data-drop-target';

var dragFolderElement = null;

/**
 * Handler for the dragstart event.
 *
 * @param {MouseEvent} event Event object for a dragstart event.
 * @param {HTMLElement} target The target element.
 */
function onDragStart(event, target) {
  dragFolderElement = null;

  var uris = selection.getUris();
  if (uris.length > 1) return;

  var uri = uris[0];
  var uriObject = uri && liburi.fromString(uri);
  if (!uriObject) return;

  // If dragging a folder, we need to temporarily save the folder DOM node,
  // so that while dragging over items we can check whether to show the drop
  // indicator. Dropping a folder inside itself should not be allowed.
  if (uriObject.type === liburi.Type.FOLDER) {
    var selectedNodes = selection.getNodes();
    for (var i = 0, l = selectedNodes.length; i < l; i++) {
      var node = selectedNodes[i];
      if (node.getAttribute('data-uri') === uri) {
        dragFolderElement = node;
        break;
      }
    }
  }
}

/**
 * Handler for ending a drag.
 *
 * @param {MouseEvent} event A dragend event object.
 * @param {HTMLElement} target DOM element for the drop target.
 */
function onDragEnd(event, target) {
  dragFolderElement = null;
}

/**
 * Hook handler for setting drag data.
 *
 * @param {MouseEvent} event Event object for a dragstart event.
 * @param {Array.<string>} uris Array of URIs being dragged.
 * @param {string=} opt_context Optional context URI.
 */
function onSetDragData(event, uris, opt_context) {
  if (opt_context !== 'spotify:rootlist') {
    var followedPlaylistCount = 0;
    for (var i = 0, l = uris.length; i < l; i++) {
      var uriObject = liburi.from(uris[i]);
      var type = uriObject && uriObject.type;
      if (type === liburi.Type.PLAYLIST) {
        var isFollowing = live(uris[i]).get('added');
        if (isFollowing) followedPlaylistCount++;
      } else {
        // If the item is not a playlist, it means we are dragging either only
        // items of another type, or playlists as well as other types.
        break;
      }
    }

    // Dropping only playlists that you are following in the rootlist should
    // not be allowed. If multiple playlists are dragged and some of them are
    // not being followed, dropping is allowed (and the receiver should handle
    // only inserting the new ones). To allow telling these cases apart while
    // not having access to drag data, we set a special MIME type that can be
    // checked later.
    if (followedPlaylistCount === uris.length) {
      event.dataTransfer.setData('text/x-spotify-only-followed-playlists', '');
    }
  }
}

/**
 * Hook handler for validating a list drop.
 *
 * @param {Object} result Result object. Setting the `valid` property will
 *     affect whether the drop is allowed.
 * @param {MouseEvent} event Some kind of drag and drop event.
 * @param {HTMLElement} list A DOM node marked up as a list.
 * @param {string} location The location of the cursor in relation to the list.
 *     This can be either 'inside' or 'below'. The value 'below' means that the
 *     cursor was below the last list found in the DOM.
 */
function onListDropValidation(result, event, list, location) {
  var contextUri = list.getAttribute('data-uri');
  if (contextUri === 'spotify:rootlist') {

    // Dropping only already followed playlists into the rootlist should not
    // be allowed, since you can only have playlists once in the rootlist.
    if (hasOnlyFollowedPlaylists(event)) {
      result.valid = false;
      return;
    }

    // Dropping a folder inside or right below itself should not be allowed
    if (isInsideDraggedFolder(event, location)) {
      result.valid = false;
      return;
    }

    // Dropping on the bottom half of a folder should not be allowed as a list
    // target, but will be a regular target for the folder instead. However, if
    // the dragged items match the list target, dropping should be handled by
    // list code instead of target code (dragover should still not validate as
    // we want the active drop target style and not the list indicator).
    if (isInFolderBottomHalf(event)) {
      if (event.type !== 'drop' || !isMatchingTarget(event, list)) {
        result.valid = false;
        return;
      }
    }
  }
}

/**
 * Hook handler for validating a target.
 *
 * @param {Object} result Result object. Setting the `valid` property will
 *     affect whether the drop is allowed.
 * @param {MouseEvent} event Some kind of drag and drop event.
 * @param {HTMLElement} target DOM node for target that matches MIME types.
 */
function onTargetValidation(result, event, target) {
  var list = target.closest(SELECTOR_LIST);
  if (list) {
    var contextUri = list.getAttribute('data-uri');
    if (contextUri === 'spotify:rootlist') {

      // Dropping only already followed playlists into the rootlist should not
      // be allowed, since you can only have playlists once in the rootlist.
      if (hasOnlyFollowedPlaylists(event)) {
        result.valid = false;
        return;
      }

      // Dropping valid rootlist items on the top half of a folder should not
      // be allowed as a regular target, but will be a list drop target instead.
      // For leave events, we need to validate the whole row as valid, so that
      // the target styling is removed correctly.
      if (event.type !== 'dragleave' && isMatchingTarget(event, list)) {
        var folderNode = getFolderNode(event);
        if (folderNode) {
          if (isBelowMiddleOfNode(event.clientY, folderNode)) {
            result.valid = true;
          } else {
            result.valid = false;
          }
          return;
        }
      }
    }
  }
}

/**
 * Hook handler for getting the indices being moved.
 *
 * @param {string} contextUri The context URI.
 * @param {LiveList} liveList Live list to be changed.
 * @param {Array.<number>} indices Array of indices in the list.
 */
function onGetMoveIndices(contextUri, liveList, indices) {
  if (contextUri === 'spotify:rootlist') {
    var firstIndex = indices[0];
    var firstRow = liveList.get(firstIndex);
    var firstItem = firstRow && firstRow.get('playlist');
    var firstUri = firstItem && firstItem.uri;
    var firstUriType = firstUri && liburi.fromString(firstUri).type;
    var isFolder = firstUriType === liburi.Type.FOLDER;

    if (isFolder) {

      // Add all indices for the folder contents and the end marker
      if (indices.length === 1) {
        var length = getFolderLength(liveList, firstUri, firstIndex);
        for (var i = 1; i <= length; i++) {
          indices.push(firstIndex + i);
        }
      }

      // Abort the move operation if it only contains moving a folder start
      // marker, since moving folders should always move the entire folder.
      // Aborting by returning zero indices.
      if (indices.length === 1) {
        indices.length = 0;
        return;
      }

      var lastRow = liveList.get(indices[indices.length - 1]);
      var lastItem = lastRow && lastRow.get('playlist');
      var lastUri = lastItem && lastItem.uri;

      // Abort the move operation if moving a folder and the last item to move
      // is not the end marker for the folder. Aborting by returning zero
      // indices.
      if (lastUri !== firstUri + ':end') {
        indices.length = 0;
        return;
      }
    }
  }
}

/**
 * Check if only dragging playlists that are being followed already.
 *
 * @param {MouseEvent} event Some kind of drag and drop event.
 *
 * @return {boolean} True if only followed playlists are being dragged.
 */
function hasOnlyFollowedPlaylists(event) {
  var types = event.dataTransfer.types;
  if (types.indexOf('text/x-spotify-only-followed-playlists') > -1) {
    return true;
  }

  return false;
}

/**
 * Check if dragging a folder into (or below) itself.
 *
 * @param {MouseEvent} event Some kind of drag and drop event.
 * @param {string} location The location of the cursor in relation to the list.
 *     This can be either 'inside' or 'below'. The value 'below' means that the
 *     cursor was below the last list found in the DOM.
 *
 * @return {boolean} True if dragging into the same folder being dragged.
 */
function isInsideDraggedFolder(event, location) {
  if (dragFolderElement) {
    var rowNode = location === 'below' ? getLastRowNode() : getRowNode(event);
    if (rowNode) {
      var targetIndex = +rowNode.getAttribute('data-index');
      if (location === 'inside') {
        if (!isBelowMiddleOfNode(event.clientY, rowNode)) {
          targetIndex--;
        }
      }
      if (isIndexInsideDraggedFolder(targetIndex)) {
        return true;
      }
    }
  }

  return false;
}

/**
 * Check if dragging onto the bottom half of a folder.
 *
 * @param {MouseEvent} event Some kind of drag and drop event.
 *
 * @return {boolean} True if dragging onto the bottom half.
 */
function isInFolderBottomHalf(event) {
  var folderNode = getFolderNode(event);
  if (folderNode) {
    return isBelowMiddleOfNode(event.clientY, folderNode);
  }
  return false;
}

/**
 * Check if the position is below the middle of the node.
 *
 * @param {number} y The Y position relative to the viewport.
 * @param {HTMLElement} node DOM node to check against.
 *
 * @return {boolean} True if the position is below.
 */
function isBelowMiddleOfNode(y, node) {
  var rect = node.getBoundingClientRect();
  return y >= rect.top + rect.height / 2;
}

/**
 * Check if the index is inside (or right below) the folder being dragged.
 *
 * @param {number} index Current target index.
 *
 * @return {boolean} True if the target index is inside the folder.
 */
function isIndexInsideDraggedFolder(index) {
  if (!dragFolderElement) return false;

  var liveList = live('spotify:rootlist').get('rows');
  if (!liveList) return false;

  var folderUri = dragFolderElement.getAttribute('data-uri');
  if (!folderUri) return false;

  var start = +dragFolderElement.getAttribute('data-index');
  var end = start + getFolderLength(liveList, folderUri, start);

  if (start > -1 && end > start && index >= start && index <= end) {
    return true;
  }

  return false;
}

/**
 * Check if the MIME types in the drag event matches the MIME types for the
 * specified drop target.
 *
 * @param {MouseEvent} event Some kind of drag and drop event.
 * @param {HTMLElement} node A DOM node.
 *
 * @return {boolean} True if the element matches the event.
 */
function isMatchingTarget(event, node) {
  var eventTypes = event.dataTransfer.types;
  var nodeTypes = node.getAttribute(ATTR_TARGET);

  if (nodeTypes) {
    var matching = intersection(nodeTypes.split('|'), eventTypes);
    if (matching.length > 0) return true;
  }

  return false;
}

/**
 * Get the folder row node from the event.
 *
 * @param {MouseEvent} event Some kind of drag and drop event.
 *
 * @return {HTMLElement?} DOM node for the folder, or null if not found.
 */
function getFolderNode(event) {
  var rowNode = getRowNode(event);
  if (rowNode) {
    var uri = rowNode.getAttribute('data-uri');
    var uriObject = liburi.from(uri);
    if (uriObject && uriObject.type === liburi.Type.FOLDER) {
      return rowNode;
    }
  }

  return null;
}

/**
 * Get the list row element from the event target.
 * If the event target itself isn't a list row, it will step out in the parent
 * tree until it finds a row.
 *
 * @param {MouseEvent} event Some kind of drag and drop event.
 *
 * @return {HTMLElement?} The list row element, or null if not found.
 */
function getRowNode(event) {
  return event.target.closest(SELECTOR_LIST_ITEM);
}

/**
 * Get the last list row from the last list in the DOM.
 *
 * @return {HTMLElement?} The list row element, or null if not found.
 */
function getLastRowNode() {
  var lists = $(SELECTOR_LIST);
  var lastList = lists && lists[lists.length - 1];
  if (lastList) {
    var listItems = $(lastList).search(SELECTOR_LIST_ITEM);
    var lastItem = listItems && listItems[listItems.length - 1];
    if (lastItem) return lastItem;
  }

  return null;
}

/**
 * Get the length of a folder, including the contents and end marker, but not
 * the start marker.
 *
 * @param {LiveList} liveList Live list for the rootlist.
 * @param {string} folderUri The folder URI.
 * @param {number} index The index where the folder start marker is.
 *
 * @return {number} The length of the folder.
 */
function getFolderLength(liveList, folderUri, index) {
  var rowAtIndex = liveList.get(index);
  var itemAtIndex = rowAtIndex && rowAtIndex.get('playlist');
  var uriAtIndex = itemAtIndex && itemAtIndex.uri;
  if (uriAtIndex !== folderUri) return 0;

  var folderEndUri = folderUri + ':end';
  var amount = 0;

  for (var i = index + 1, l = liveList.length; i < l; i++) {
    amount++;

    rowAtIndex = liveList.get(i);
    itemAtIndex = rowAtIndex && rowAtIndex.get('playlist');
    uriAtIndex = itemAtIndex && itemAtIndex.uri;
    if (uriAtIndex === folderEndUri) break;
  }

  return amount;
}

/**
 * Attach the module.
 */
function attach() {
  eventModel.delegate('dragstart', SELECTOR_DRAGGABLE, onDragStart);
  eventModel.delegate('dragend', 'body', onDragEnd);

  hooks.add('set-drag-data', onSetDragData);
  hooks.add('list-drop-validation', onListDropValidation);
  hooks.add('target-validation', onTargetValidation);
  hooks.add('get-move-indices', onGetMoveIndices);
}

/**
 * Detach the module.
 */
function detach() {
  eventModel.undelegate('dragstart', SELECTOR_DRAGGABLE, onDragStart);
  eventModel.undelegate('dragend', 'body', onDragEnd);

  hooks.remove('set-drag-data', onSetDragData);
  hooks.remove('list-drop-validation', onListDropValidation);
  hooks.remove('target-validation', onTargetValidation);
  hooks.remove('get-move-indices', onGetMoveIndices);
}

exports.attach = attach;
exports.detach = detach;

},{"../../../spotify-elements":70,"../../../spotify-live":251,"../../selection":113,"../util/eventmodel":86,"../util/hooks":87,"mout/array/intersection":358,"spotify-liburi":426}],80:[function(require,module,exports){
/**
 * @module spotify-events/dragndrop/custom/sortlist
 * @private
 */
'use strict';

var $ = require('../../../spotify-elements');
var liburi = require('spotify-liburi');
var sortUriUtils = require('../../../spotify-live-sort-uri');

var hooks = require('../util/hooks');
var eventModel = require('../util/eventmodel');
var selection = require('../../selection');

var SELECTOR_DRAGGABLE = 'a, [draggable]';
var SELECTOR_LIST = '[data-list]';

var dragSelectionState = null;

/**
 * Handler for the dragstart event.
 *
 * @param {MouseEvent} event Event object for a dragstart event.
 * @param {HTMLElement} target The target element.
 */
function onDragStart(event, target) {
  dragSelectionState = selection.getIndicesPerList();
}

/**
 * Handler for ending a drag.
 *
 * @param {MouseEvent} event A dragend event object.
 * @param {HTMLElement} target DOM element for the drop target.
 */
function onDragEnd(event, target) {
  dragSelectionState = null;
}

/**
 * Hook handler for validating a list drop.
 *
 * @param {Object} result Result object. Setting the `valid` property will
 *     affect whether the drop is allowed.
 * @param {MouseEvent} event Some kind of drag and drop event.
 * @param {HTMLElement} list A DOM node marked up as a list.
 * @param {string} location The location of the cursor in relation to the list.
 *     This can be either 'inside' or 'below'. The value 'below' means that the
 *     cursor was below the last list found in the DOM.
 */
function onListDropValidation(result, event, list, location) {
  var contextUri = list.getAttribute('data-uri');
  if (!contextUri) return;

  // Dropping in sorted lists should not allow specific drop positions,
  if (sortUriUtils.isValid(contextUri) && event.type !== 'drop') {
    result.valid = false;
  }
}

/**
 * Hook handler for validating a list target.
 *
 * @param {Object} result Result object. Setting the `valid` property will
 *     affect whether the drop is allowed.
 * @param {HTMLElement} list A DOM node marked up as a list.
 */
function onListTargetValidation(result, list) {
  var contextUri = list.getAttribute('data-uri');
  if (!contextUri) return;

  // Bail on all invalid uris
  if (!sortUriUtils.isValid(contextUri)) return;

  // We should support incoming drag and drops as well, like from the
  // now playing view for example
  if (!dragSelectionState) {
    result.valid = true;
    return;
  }

  // Dropping in sorted lists should be allowed as a regular target
  if (dragSelectionState.length === 1) {
    if (dragSelectionState[0].uri !== contextUri) {
      result.valid = true;
    }
  }
}

/**
 * Hook handler for checking if a list is a track list.
 *
 * @param {Object} result Result object. Setting the `valid` property will
 *     affect the result.
 * @param {LiveList} liveList The live list.
 * @param {string} contextUri The context URI.
 */
function onIsListOfTracks(result, liveList, contextUri) {
  if (sortUriUtils.isValid(contextUri)) {
    var originUri = sortUriUtils.getOriginUri(contextUri);
    if (originUri) {
      var uriObject = liburi.from(originUri);
      var type = uriObject && uriObject.type;
      if (type === liburi.Type.PLAYLIST) {
        result.valid = true;
      }
    }
  }
}

/**
 * Attach the module.
 */
function attach() {
  eventModel.delegate('dragstart', SELECTOR_DRAGGABLE, onDragStart);
  eventModel.delegate('dragend', 'body', onDragEnd);

  hooks.add('list-drop-validation', onListDropValidation);
  hooks.add('list-target-validation', onListTargetValidation);
  hooks.add('is-list-of-tracks', onIsListOfTracks);
}

/**
 * Detach the module.
 */
function detach() {
  eventModel.undelegate('dragstart', SELECTOR_DRAGGABLE, onDragStart);
  eventModel.undelegate('dragend', 'body', onDragEnd);

  hooks.remove('list-drop-validation', onListDropValidation);
  hooks.remove('list-target-validation', onListTargetValidation);
  hooks.remove('is-list-of-tracks', onIsListOfTracks);
}

exports.attach = attach;
exports.detach = detach;

},{"../../../spotify-elements":70,"../../../spotify-live-sort-uri":249,"../../selection":113,"../util/eventmodel":86,"../util/hooks":87,"spotify-liburi":426}],81:[function(require,module,exports){
(function (global){
/**
 * @module spotify-events/dragndrop/dragdata
 * @private
 */
'use strict';

var live = require('../../spotify-live');
var liburi = require('spotify-liburi');
var forOwn = require('mout/object/forOwn');

var selection = require('../selection');
var hooks = require('./util/hooks');
var eventModel = require('./util/eventmodel');
var itemText = require('./util/itemtext');
var getLogContext = require('../util/get-log-context');

var SELECTOR_DRAGGABLE = 'a, [draggable]';

/**
 * Handler for the dragstart event.
 *
 * @param {MouseEvent} event Event object for a dragstart event.
 * @param {HTMLElement} target The target element.
 */
function onDragStart(event, target) {
  var isSelected = selection.isNodeSelected(target);

  if (isSelected) {
    var uris = selection.getUris();
    if (uris.length > 0) {
      var state = selection.getIndicesPerList();
      var singleContext = state.length === 1;
      var context = singleContext ? state[0] && state[0].uri : null;
      if (context) {
        setEventData(event, uris, null, context, getLogContext(target));
      } else {
        setEventData(event, uris, null, null, getLogContext(target));
      }
    }
  } else {
    var uri = target.getAttribute('data-uri');
    if (!uri) {
      var uriObject = liburi.from(target.getAttribute('href'));
      uri = uriObject ? uriObject.toURI() : '';
    }
    var dragText = itemText.getForElement(target);

    if (uri) {
      setEventData(event, [uri], [dragText], null, getLogContext(target));
    }
  }
}

/**
 * Set drag data on the event.
 * This includes regular MIME types such as plain text and html, but also custom
 * Spotify MIME types that can be used to detect the dragged content while
 * dragging (you can't access data while dragging, so there is no other way
 * to detect what kind of items are being dragged).
 *
 * @param {MouseEvent} event Event object for a dragstart event.
 * @param {Array.<string>} uris Array of Spotify URIs.
 * @param {Array.<string>=} opt_dragTexts Optional drag texts for each URI.
 * @param {string=} opt_context Optional context URI.
 * @param {string=} opt_logContext Optional log context.
 */
function setEventData(event, uris, opt_dragTexts, opt_context, opt_logContext) {
  var urlsPerMimeType = getUrlsPerMimeType(uris);
  var urls = getUrlsForUris(uris);
  var urlList = urls.join('\n');
  var html = getLinkHTML(uris, urls, opt_dragTexts);

  // We set this before others because safari overrides any data that was set
  // before this particular mimetype was set.
  event.dataTransfer.setData('text/uri-list', urlList);

  for (var type in urlsPerMimeType) {
    var urlsForType = urlsPerMimeType[type];
    event.dataTransfer.setData(type, urlsForType.join('\n'));
  };

  event.dataTransfer.setData('text/plain', urlList);
  event.dataTransfer.setData('text/html', html);

  if (opt_context) {

    // Provide the context as drag data. This can be used in the drop event to
    // know where it came from.
    event.dataTransfer.setData('text/x-spotify-data-context', opt_context);
  }

  if (opt_logContext) {
    event.dataTransfer.setData('text/x-spotify-data-log-context', opt_logContext);
  }

  event.dataTransfer.setData('text/x-spotify-data-app-uri', global.__spotify && global.__spotify.app_uri || null);

  hooks.run('set-drag-data', event, uris, opt_context);
}

/**
 * Get URLs for the URIs organized by MIME type.
 *
 * @param  {Array.<string>} uris Array of Spotify URIs.
 *
 * @return {Object.<string, Array.<string>>} Object of arrays of URLs.
 */
function getUrlsPerMimeType(uris) {
  var urlsPerMimeType = {};
  for (var i = 0, l = uris.length; i < l; i++) {
    var uri = uris[i];
    var type = getMimeType(uri);
    var urlsForType = urlsPerMimeType[type] || (urlsPerMimeType[type] = []);
    urlsForType.push(getShareLink(uri));
  }
  return urlsPerMimeType;
}

/**
 * Get URLs for the URIs.
 *
 * @param {Array.<string>} uris Array of Spotify URIs.
 *
 * @return {Array.<string>} Array of share URLs.
 */
function getUrlsForUris(uris) {
  var urls = new Array(uris.length);
  for (var i = 0, l = uris.length; i < l; i++) {
    urls[i] = getShareLink(uris[i]);
  }
  return urls;
}

/**
 * Get a share URL from a Spotify URI.
 *
 * @param {string} uri A Spotify URI.
 *
 * @return {string} The share URL.
 */
function getShareLink(uri) {
  var uriObject = liburi.from(uri);
  return uriObject ? uriObject.toOpenURL() : uri;
}

/**
 * Get the custom Spotify MIME type for a URI.
 *
 * @param {string} uri A Spotify URI.
 *
 * @return {string} The MIME type.
 */
function getMimeType(uri) {
  var type = 'text/x-spotify-';

  var uriObject = liburi.from(uri);
  if (uriObject) {
    var uriType = uriObject.type;

    if (uriType === liburi.Type.TRACK || uriType === liburi.Type.LOCAL) {
      return type + 'tracks';
    }
    if (uriType === liburi.Type.ALBUM || uriType === liburi.Type.LOCAL_ALBUM) {
      return type + 'albums';
    }
    if (uriType === liburi.Type.ARTIST || uriType === liburi.Type.LOCAL_ARTIST) {
      return type + 'artists';
    }
    if (uriType === liburi.Type.USER || uriType === liburi.Type.PROFILE) {
      return type + 'users';
    }
    if (uriType === liburi.Type.PLAYLIST) {
      return type + 'playlists';
    }
    if (uriType === liburi.Type.FOLDER) {
      return type + 'folders';
    }
    if (uriType === liburi.Type.STATION) {
      return type + 'stations';
    }
  }

  return type + 'unknown';
}

/**
 * Get the HTML for links to the given URLs.
 *
 * @param {Array.<string>} uris Array of Spotify URIs.
 * @param {Array.<string>} urls Array of Spotify URLs used for sharing.
 * @param {Array.<string>=} opt_dragTexts Optional drag texts for each URI.
 *
 * @return {string} String of HTML.
 */
function getLinkHTML(uris, urls, opt_dragTexts) {
  var html = '';

  for (var i = 0, l = uris.length; i < l; i++) {
    var textFromArgs = opt_dragTexts && opt_dragTexts[i];
    var text = textFromArgs || itemText.getForUri(uris[i]);

    html += '<a href="' + urls[i] + '">' + text + '</a>';

    if (i < uris.length - 1) {
      html += '<br>';
    }
  }

  return html;
}

/**
 * Attach the module.
 */
function attach() {
  eventModel.delegate('dragstart', SELECTOR_DRAGGABLE, onDragStart);
}

/**
 * Detach the module.
 */
function detach() {
  eventModel.undelegate('dragstart', SELECTOR_DRAGGABLE, onDragStart);
}

exports.attach = attach;
exports.detach = detach;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../spotify-live":251,"../selection":113,"../util/get-log-context":130,"./util/eventmodel":86,"./util/hooks":87,"./util/itemtext":88,"mout/object/forOwn":389,"spotify-liburi":426}],82:[function(require,module,exports){
/**
 * @module spotify-events/dragndrop/dragimage
 * @private
 */
'use strict';

var live = require('../../spotify-live');
var liburi = require('spotify-liburi');
var defer = require('prime/defer');

var selection = require('../selection');
var eventModel = require('./util/eventmodel');
var itemText = require('./util/itemtext');

// TODO: Actually load localized strings.
// Problem now is that we need quickstart-spotify to load @loc paths, and that
// makes it harder to run unit tests.
var localizedStrings = require('../strings/en.json');

var SELECTOR_DRAGGABLE = 'a, [draggable]';
var DRAGIMAGE_POS_X = -10;
var DRAGIMAGE_POS_Y = -5;

var dragImageElement = null;
var dragImageShelter = null;

/**
 * Handler for the dragstart event.
 *
 * @param {MouseEvent} event Event object for a dragstart event.
 * @param {HTMLElement} target The target element.
 */
function onDragStart(event, target) {
  var isSelected = selection.isNodeSelected(target);

  var text = '';

  if (isSelected) {
    var uris = selection.getUris();
    if (uris.length === 1) {
      text = itemText.getForUri(uris[0]);
    } else {
      text = uris.length + ' ' + getLocalizedTypeFromUris(uris);
    }
  } else {
    text = itemText.getForElement(target);
  }

  var dragImage = getDragImage(text);

  event.dataTransfer.setDragImage(dragImage, DRAGIMAGE_POS_X, DRAGIMAGE_POS_Y);

  removeDragImage();
}

/**
 * Get the drag image element with the specified text set.
 *
 * @param {string} text The text to set.
 *
 * @return {HTMLElement} The drag image element.
 */
function getDragImage(text) {
  if (!dragImageElement) {
    dragImageElement = document.createElement('div');
    dragImageElement.className = 'dnd-image';
  }
  if (!dragImageShelter) {
    dragImageShelter = document.createElement('div');
    dragImageShelter.className = 'dnd-image-shelter';
  }

  dragImageElement.textContent = text;

  document.body.appendChild(dragImageElement);
  document.body.appendChild(dragImageShelter);

  return dragImageElement;
}

/**
 * Remove the drag image element and the shelter it hides behind.
 * This must be delayed a tick to let the native drag and drop handling
 * get the time to read the image.
 */
function removeDragImage() {
  defer(function () {
    if (dragImageElement && dragImageElement.parentNode) {
      dragImageElement.parentNode.removeChild(dragImageElement);
    }
    if (dragImageShelter && dragImageShelter.parentNode) {
      dragImageShelter.parentNode.removeChild(dragImageShelter);
    }
  });
}

/**
 * Get a localized type for a list of URIs.
 * This could be for example 'tracks', 'playlists' etc. Falls back to 'items'
 * if the URIs are of different type. As this is only called when we drag
 * multiple items, we don't need the singular form.
 *
 * @param {Array.<string>} uris Array of URIs.
 *
 * @return {string} The localized type.
 */
function getLocalizedTypeFromUris(uris) {
  var type = 'item';

  var uriObjectForFirst = liburi.from(uris[0]);
  var typeForFirst = uriObjectForFirst && uriObjectForFirst.type;

  if (typeForFirst) {
    type = typeForFirst;

    for (var i = 0, l = uris.length; i < l; i++) {
      var uriObject = liburi.from(uris[i]);
      if (!uriObject || uriObject.type !== typeForFirst) {
        type = 'item';
        break;
      }
    }
  }

  // User URIs are parsed with type 'profile' in liburi, but we want 'user'
  if (type === 'profile') {
    type = 'user';
  }

  var pluralType = type + 's';

  // Get the localized version of the plural type
  var localized = localizedStrings['drag_tooltip_many_' + pluralType];

  // If the type was not the generic 'items' type and no localization was found,
  // localize the generic type.
  if (!localized && pluralType !== 'items') {
    localized = localizedStrings['drag_tooltip_many_items'];
  }

  // Return the localized type, or if nothing is found, fall back to the type
  return localized || pluralType;
}

/**
 * Attach the module.
 */
function attach() {
  eventModel.delegate('dragstart', SELECTOR_DRAGGABLE, onDragStart);
}

/**
 * Detach the module.
 */
function detach() {
  eventModel.undelegate('dragstart', SELECTOR_DRAGGABLE, onDragStart);
}

exports.attach = attach;
exports.detach = detach;

},{"../../spotify-live":251,"../selection":113,"../strings/en.json":121,"./util/eventmodel":86,"./util/itemtext":88,"prime/defer":402,"spotify-liburi":426}],83:[function(require,module,exports){
/**
 * @module spotify-events/dragndrop
 */
'use strict';

var dragDataModule = require('./dragdata');
var dragImageModule = require('./dragimage');
var targetModule = require('./target');
var listModule = require('./list');

// Custom behaviors
var sortlistModule = require('./custom/sortlist');
var rootlistModule = require('./custom/rootlist');

/**
 * Attach the module.
 */
function attach() {
  dragDataModule.attach();
  dragImageModule.attach();
  targetModule.attach();
  listModule.attach();

  sortlistModule.attach();
  rootlistModule.attach();
}

/**
 * Detach the module.
 */
function detach() {
  dragDataModule.detach();
  dragImageModule.detach();
  targetModule.detach();
  listModule.detach();

  sortlistModule.detach();
  rootlistModule.detach();
}

exports.attach = attach;
exports.detach = detach;
exports.update = function () {};

},{"./custom/rootlist":79,"./custom/sortlist":80,"./dragdata":81,"./dragimage":82,"./list":84,"./target":85}],84:[function(require,module,exports){
/**
 * @module spotify-events/dragndrop/list
 * @private
 */
'use strict';

var $ = require('../../spotify-elements');
var intersection = require('mout/array/intersection');
var flow = require('finally');
var Range = require('../../spotify-range2');
var live = require('../../spotify-live');
var liburi = require('spotify-liburi');
var listOperations = require('spotify-live-list-operations');

var hooks = require('./util/hooks');
var eventModel = require('./util/eventmodel');
var selection = require('../selection');

var SELECTOR_DROP_TARGET = '[data-drop-target]';
var SELECTOR_LIST = '[data-list]';
var SELECTOR_LIST_ITEM = '[data-list-item]';
var SELECTOR_LIST_TARGET = SELECTOR_DROP_TARGET + ', body';
var SELECTOR_DRAGGABLE = 'a, [draggable]';
var ATTR_TARGET = 'data-drop-target';

var dropIndicator = null;
var draggedLinkContext = null;
var disabledLists = {};

/**
 * Handler for the dragstart event.
 *
 * @param {MouseEvent} event Event object for a dragstart event.
 * @param {HTMLElement} target The target element.
 */
function onDragStart(event, target) {
  draggedLinkContext = null;

  // clear the selectionState cache
  cachedSelectionState.clear();

  var matchingTarget = getMatchingTarget(event);
  if (matchingTarget) {
    var isInList = $(matchingTarget).matches(SELECTOR_LIST);
    if (isInList) {
      var uri = matchingTarget.getAttribute('data-uri');

      // Dragging a link from inside a list needs to store the list context,
      // since it is not allowed to drop a dragged link inside the same list.
      if (target.tagName.toLowerCase() === 'a') {
        draggedLinkContext = uri;
      }

      // Dragging is disallowed for lists where we're waiting for a list move
      // to finish. This is to prevent multiple moves to be called before the
      // response from the first comes back.
      if (disabledLists[uri]) {
        event.preventDefault();
        return;
      }

      var rowNode = getRowNode(event);
      if (rowNode) {
        var index = getTargetIndex(event.clientY, rowNode);
        if (index !== -1) {
          event.dataTransfer.setData('text/x-spotify-data-log-source-index', index);
        }
      }
    }
  }
}

/**
 * Handler for dragging over a drop target.
 *
 * @param {MouseEvent} event A dragover event object.
 * @param {HTMLElement} target DOM element for the drop target. This can be the
 *     body element even if it's not a drop target.
 */
function onDragOver(event, target) {
  var positionedListDrop = false;
  var rowNode = null;

  var isBody = target === document.body;
  var list = null;
  if (isBody) list = getListTargetFromBody(event);else list = getMatchingListTarget(event);

  // If we found a list from the event, we must validate if it's allowed to drop
  // in the list.
  if (list) {
    var location = isBody ? 'below' : 'inside';
    if (validateListDrop(event, list, location)) {
      if (isBody) {
        positionedListDrop = true;
      } else {
        rowNode = getRowNode(event);
        if (rowNode) {
          positionedListDrop = true;
        }
      }
    }
  }

  if (positionedListDrop) {
    event.preventDefault();

    if (isBody) showDropIndicatorBelowList(list);else if (rowNode) showDropIndicatorForRow(rowNode, event.clientY);
  } else {
    hideDropIndicator();

    var listHookResult = { valid: false };
    if (list) {
      hooks.run('list-target-validation', listHookResult, list);
    }

    // The list might be accepted as a drop target even if dropping in a
    // specific position was not accepted. In that case we need to prevent the
    // default action to tell the browser that we accept drops here.
    if (listHookResult.valid) {
      event.preventDefault();
    } else if (!isBody && list) {
      var targetHookResult = { valid: false };
      hooks.run('target-validation', targetHookResult, event, target);

      // If we know that dropping is not allowed here at all, we need to remove
      // the drop effect from the cursor. This is mainly since the handler in
      // targets.js has already handled the event and accepted it, which sets
      // the drop effect.
      if (!targetHookResult.valid) {
        event.dataTransfer.dropEffect = 'none';
      }
    }
  }
}

/**
 * Handler for dragging out from a drop target.
 *
 * @param {MouseEvent} event A dragleave event object.
 * @param {HTMLElement} target DOM element for the drop target.
 */
function onDragLeave(event, target) {
  hideDropIndicator();
}

/**
 * Handler for ending a drag.
 *
 * @param {MouseEvent} event A dragend event object.
 * @param {HTMLElement} target DOM element for the drop target.
 */
function onDragEnd(event, target) {
  hideDropIndicator();
  draggedLinkContext = null;
}

/**
 * Handler for dropping onto a drop target.
 *
 * @param {MouseEvent} event A drop event object.
 * @param {HTMLElement} target DOM element for the drop target.
 */
function onDrop(event, target) {
  hideDropIndicator();

  var isBody = target === document.body;
  var list = null;
  if (isBody) list = getListTargetFromBody(event);else list = getMatchingListTarget(event);

  if (list) {
    var location = isBody ? 'below' : 'inside';
    if (validateListDrop(event, list, location)) {
      var contextUri = list.getAttribute('data-uri');
      if (contextUri) {
        performListChangesForEvent(event, list, contextUri, location);
        event.handled = true;
      }
    }
  }
}

/**
 * Show the drop indicator below the provided list element.
 *
 * @param {HTMLElement} list A list element.
 */
function showDropIndicatorBelowList(list) {
  var listRect = list.getBoundingClientRect();
  showDropIndicator(listRect.left, listRect.bottom, listRect.width);
}

/**
 * Show the drop indicator above or below a list row.
 *
 * @param {HTMLElement} rowNode A list row element.
 * @param {number} cursorY The cursor Y position, relative to the viewport.
 */
function showDropIndicatorForRow(rowNode, cursorY) {
  var belowMiddle = isBelowMiddleOfNode(cursorY, rowNode);
  var rowRect = rowNode.getBoundingClientRect();
  var x = rowRect.left;
  var y = rowRect.top + (belowMiddle ? rowRect.height : 0);
  showDropIndicator(x, y, rowRect.width);
}

/**
 * Show the drop indicator line for the specified row and cursor position.
 * If the cursor position is below the middle of the row, the indicator will be
 * placed below the row, otherwise above the row.
 *
 * @param {number} x The X position relative to the viewport.
 * @param {number} y The Y position relative to the viewport.
 * @param {number} width The width of the indicator.
 */
function showDropIndicator(x, y, width) {

  // Don't use window.scroll X/Y because cross browser issues.
  // https://developer.mozilla.org/en-US/docs/Web/API/Window.scrollY
  var indicatorAbsX = window.pageXOffset + x;
  var indicatorAbsY = window.pageYOffset + y;
  var indicatorWidth = width;

  if (!dropIndicator) {
    dropIndicator = document.createElement('div');
    dropIndicator.className = 'tr-drag-indicator';
  }

  dropIndicator.style.left = indicatorAbsX + 'px';
  dropIndicator.style.width = indicatorWidth + 'px';
  dropIndicator.style.top = indicatorAbsY + 'px';

  if (!dropIndicator.parentNode) {
    document.body.appendChild(dropIndicator);
  }
}

/**
 * Hide the drop indicator.
 */
function hideDropIndicator() {
  if (dropIndicator && dropIndicator.parentNode) {
    dropIndicator.parentNode.removeChild(dropIndicator);
  }
}

/**
 * Perform the list changes that are needed from the drop event.
 *
 * @param {MouseEvent} event A drop event.
 * @param {HTMLElement} list The list DOM node.
 * @param {string} contextUri The context URI for the list.
 * @param {string} location The location of the cursor in relation to the list.
 *     This can be either 'inside' or 'below'. The value 'below' means that the
 *     cursor was below the last list found in the DOM.
 */
function performListChangesForEvent(event, list, contextUri, location) {
  var liveList = live(contextUri).get('rows');
  if (!liveList) return;

  var targetIndex = 0;

  if (location === 'below') {
    var lastRowNode = getLastRowFromLastList();

    // Dropping below a list without rows will use target index 0
    if (lastRowNode) {
      targetIndex = getTargetIndex(event.clientY, lastRowNode);
    }
  } else {
    var rowNode = getRowNode(event);
    if (!rowNode) return;
    targetIndex = getTargetIndex(event.clientY, rowNode);
  }

  var sourceContext = event.dataTransfer.getData('text/x-spotify-data-context');
  var isSameContext = sourceContext && sourceContext === contextUri;

  if (isSameContext) {
    performMoveChanges(contextUri, liveList, targetIndex);
  } else {
    performInsertChanges(event, list, contextUri, liveList, targetIndex);
  }
  event.data = {
    targetIndex: targetIndex
  };
}

/**
 * Move the selected items to a target index in the list.
 *
 * @param {string} contextUri The context URI of the list.
 * @param {LiveList} liveList The live list for the context.
 * @param {number} targetIndex The target index in the list.
 */
function performMoveChanges(contextUri, liveList, targetIndex) {
  var indices = getMoveIndices(contextUri, liveList);

  // Selection can be nothing. This can happen if you select a row, drag it
  // and before dropping, the row is removed by something else (on another
  // device perhaps). Dropping should in that case not perform any action.
  // Similarly, if dragging multiple rows and some of the rows are removed
  // while dragging, only the rows that are still in the list will be moved.
  if (indices.length === 0) return;

  var operations = listOperations.getMoveOperations(indices, targetIndex);

  // If the list changed while dragging, it might happen that we end up
  // dropping at the same index as we're dragging from, which would give
  // us no operations to perform.
  if (operations.length === 0) return;

  liveList.publish(operations);

  temporarilyDisableList(contextUri, liveList);
}

/**
 * Insert items from the event into the list at the target index.
 *
 * @param {MouseEvent} event A drop event.
 * @param {HTMLElement} list The list DOM node.
 * @param {string} contextUri The context URI for the list.
 * @param {LiveList} liveList The live list for the context.
 * @param {number} targetIndex The target index in the list.
 */
function performInsertChanges(event, list, contextUri, liveList, targetIndex) {
  getInsertValues(event, list, liveList, contextUri, function (error, values) {
    if (error) return;
    if (values.length === 0) return;

    var operations = [{ type: 'insert', index: targetIndex, values: values }];

    liveList.publish(operations);

    temporarilyDisableList(contextUri, liveList);
  });
}

/**
 * Check if dropping at the current position in a list is allowed.
 *
 * @param {MouseEvent} event Some kind of drag and drop event.
 * @param {HTMLElement} list A DOM node marked up as a list.
 * @param {string} location The location of the cursor in relation to the list.
 *     This can be either 'inside' or 'below'. The value 'below' means that the
 *     cursor was below the last list found in the DOM.
 *
 * @return {boolean} True if it's a valid drop position.
 */
function validateListDrop(event, list, location) {

  // All positions are valid if we're not dragging from a context in the first
  // place. If we do have a context though, we need to validate the position.
  var types = event.dataTransfer.types;
  var isDraggingFromContext = types.indexOf('text/x-spotify-data-context') > -1;
  if (isDraggingFromContext) {
    if (!validatePotentialOperations(event, list, location)) {
      return false;
    }
  }

  var uri = list.getAttribute('data-uri');
  if (uri && draggedLinkContext === uri) {
    return false;
  }

  var result = { valid: true };
  hooks.run('list-drop-validation', result, event, list, location);

  return !!result.valid;
}

/**
 * Simple wrapper to cache calls to selection.getIndicesPerList()
 *
 * @return {Object} The result of selection.getIndicesPerList()
 */
var cachedSelectionState = function () {
  var cache = {
    lastTime: 0,
    lastValue: null
  };
  var CACHE_TIMEOUT = 500;

  return {
    get: function get() {
      var now = Date.now();

      if (now - cache.lastTime > CACHE_TIMEOUT) {
        cache = {
          lastValue: selection.getIndicesPerList(),
          lastTime: now
        };
      }

      return cache.lastValue;
    },
    clear: function clear() {
      cache.lastTime = 0;
    }
  };
}();

/**
 * Check if dropping at the current event position would actually result in
 * operations that would change the list.
 *
 * @param {MouseEvent} event Some kind of drag and drop event.
 * @param {HTMLElement} list A DOM node marked up as a list.
 * @param {string} location The location of the cursor in relation to the list.
 *     This can be either 'inside' or 'below'. The value 'below' means that the
 *     cursor was below the last list found in the DOM.
 *
 * @return {boolean} True if it would result in a change.
 */
function validatePotentialOperations(event, list, location) {
  // get a cached version of the selectionState
  var selectionState = cachedSelectionState.get();

  // Dropping inside the only selected range inside the only container that
  // has a selection is not allowed, as that would result in no change.
  if (selectionState.length === 1) {

    // Dropping inside a different context is always fine
    var contextUri = list.getAttribute('data-uri');
    if (contextUri !== selectionState[0].uri) {
      return true;
    }

    var selectedRanges = Range.fromIndices(selectionState[0].indicesWithHidden);

    if (selectedRanges.length === 1) {
      var selectedRange = selectedRanges[0];

      // Include the next row in the selected range to handle holding on the
      // top part of the next row, which would be a no-op. The bottom part of
      // the previous row will be taken care of by the code below.
      selectedRange.update(selectedRange.start, selectedRange.end + 1);

      var rowNode = location === 'below' ? getLastRowFromLastList() : getRowNode(event);
      if (rowNode) {
        var targetIndex = getTargetIndex(event.clientY, rowNode);
        if (targetIndex > -1) {
          var targetRange = new Range(targetIndex, targetIndex + 1);

          // If the target index is inside the selected range, it's not allowed
          // to drop, as that would be a no-op.
          if (targetRange.contained(selectedRange)) {
            return false;
          }
        }
      }
    }
  }

  return true;
}

/**
 * Get the drop target element that is matching the event target and the drag
 * MIME types of the event. This will start with the event target and step
 * outwards in the DOM tree to find the first matching element.
 *
 * @param {MouseEvent} event Some kind of drag and drop event.
 *
 * @return {HTMLElement?} The element or null if not found.
 */
function getMatchingTarget(event) {
  var currentNode = event.target;

  while (currentNode) {
    if (isMatchingTarget(event, currentNode)) {
      return currentNode;
    }
    currentNode = currentNode.parentElement;
  }

  return null;
}

/**
 * Get the list element that is matching the event target and the drag MIME
 * types of the event. This will start with the event target and step outwards
 * in the DOM tree to find the first matching element.
 *
 * @param {MouseEvent} event Some kind of drag and drop event.
 *
 * @return {HTMLElement?} The list element or null if not found.
 */
function getMatchingListTarget(event) {
  var currentNode = event.target;

  while (currentNode) {
    var isList = $(currentNode).matches(SELECTOR_LIST);
    if (isList && isMatchingTarget(event, currentNode)) {
      return currentNode;
    }
    currentNode = currentNode.parentElement;
  }

  return null;
}

/**
 * Get a valid list target from the end of body.
 *
 * @param {MouseEvent} event Some kind of drag and drop event.
 *
 * @return {HTMLElement?} The list element or null if not found.
 */
function getListTargetFromBody(event) {
  var lastList = getLastListNode();
  if (lastList) {
    var sameParent = event.target.contains(lastList);
    if (sameParent && isMatchingTarget(event, lastList)) {
      if (isBelowNode(event.clientX, event.clientY, lastList)) {
        return lastList;
      }
    }
  }

  return null;
}

/**
 * Get the list row element from the event target.
 * If the event target itself isn't a list row, it will step out in the parent
 * tree until it finds a row.
 *
 * @param {MouseEvent} event Some kind of drag and drop event.
 *
 * @return {HTMLElement?} The list row element, or null if not found.
 */
function getRowNode(event) {
  return event.target.closest(SELECTOR_LIST_ITEM);
}

/**
 * Get the last list row from the last list in the DOM.
 *
 * @return {HTMLElement?} The list row element, or null if not found.
 */
function getLastRowFromLastList() {
  var lastList = getLastListNode();
  if (lastList) {
    var listItems = $(lastList).search(SELECTOR_LIST_ITEM);
    var lastItem = listItems && listItems[listItems.length - 1];
    if (lastItem) return lastItem;
  }

  return null;
}

/**
 * Get the last list in the DOM.
 *
 * @return {HTMLElement?} The list element, or null if not found.
 */
function getLastListNode() {
  var lists = $(SELECTOR_LIST);
  var lastList = lists && lists[lists.length - 1];
  return lastList || null;
}

/**
 * Get the target index based on a cursor position and the row that the cursor
 * is on.
 *
 * @param {number} y The Y position relative to the viewport.
 * @param {HTMLElement} rowNode The DOM node for the row.
 *
 * @return {number} The target index or -1 if not found.
 */
function getTargetIndex(y, rowNode) {
  var index = rowNode.getAttribute('data-index');

  if (index === null) {
    index = -1;
  } else {
    index = parseInt(index, 10);

    if (isNaN(index)) {
      index = -1;
    } else {
      // If cursor is in the bottom part of the row, dropping will place items
      // after the row, so we need to increment the index.
      if (isBelowMiddleOfNode(y, rowNode)) {
        index++;
      }
    }
  }

  return index;
}

/**
 * Get the indices of the rows to move.
 *
 * @param {string} contextUri The context URI.
 * @param {LiveList} liveList The live list to be changed.
 *
 * @return {Array.<number>} Array of indices.
 */
function getMoveIndices(contextUri, liveList) {
  // As we need the indices, we must use the current selection state,
  // since the list might have changed since the start of the drag.
  // We are only in this function if we are dragging in the same
  // context, so the current selection state will always be valid.
  var selectionState = selection.getIndicesPerList();
  if (selectionState.length !== 1) return [];

  var firstContainer = selectionState[0];
  var selectedIndices = firstContainer.indices;
  var indices = selectedIndices.slice();

  if (indices.length === 0) return [];

  hooks.run('get-move-indices', contextUri, liveList, indices);

  // The indices must be sorted for the utility that creates the list operations
  indices.sort(function (a, b) {
    return a - b;
  });

  return indices;
}

/**
 * Get the values to use for insertion in the list. This will get the event data
 * for the matching MIME types.
 *
 * @param {MouseEvent} event A drop event.
 * @param {HTMLElement} list The list DOM node.
 * @param {LiveList} liveList The live list for the context.
 * @param {string} contextUri The context URI for the list.
 * @param {Function} callback A callback function. The data argument will be an
 *     array of object values.
 */
function getInsertValues(event, list, liveList, contextUri, callback) {
  var eventTypes = event.dataTransfer.types;
  var listTypes = list.getAttribute(ATTR_TARGET);
  if (!listTypes) return callback(null, []);

  var matchingTypes = intersection(listTypes.split('|'), eventTypes);
  if (matchingTypes.length === 0) return callback(null, []);

  var data = getDataFromTypes(event, matchingTypes);

  var isTrackList = isListOfTracks(liveList, contextUri);

  getRowsFromData(data, isTrackList, function (error, rows) {
    if (error) return callback(error);

    callback(null, rows);
  });
}

/**
 * Get the event data associated with the provided MIME types.
 *
 * @param {MouseEvent} event Some kind of drag and drop event.
 * @param {Array.<string>} types Array of MIME types.
 *
 * @return {Object.<string, Array>} Object where key is MIME type and value is
 *     array of values (URIs).
 */
function getDataFromTypes(event, types) {
  var data = {};

  for (var i = 0, l = types.length; i < l; i++) {
    var type = types[i];
    var itemsInData = data[type] = [];

    // A MIME type that starts with text/x-spotify is always containing a list
    // of Open URLs separated by '\n'.
    var hasURIs = type.indexOf('text/x-spotify') === 0;

    var dataForType = event.dataTransfer.getData(type);
    var items = hasURIs ? dataForType.split('\n') : [dataForType];
    for (var n = 0, len = items.length; n < len; n++) {
      var item = items[n];
      if (hasURIs) {
        var uriObject = liburi.from(item);
        if (uriObject) {
          itemsInData.push(uriObject.toURI());
        }
      } else {
        itemsInData.push(item);
      }
    }
  }

  return data;
}

/**
 * Get list row data from the event data. This might expand items if the list
 * is a track list (dropping an album into a track list will expand the album
 * into its tracks and return track rows instead).
 *
 * @param {Object.<string, Array>} data Data from drop event.
 * @param {boolean} isTrackList True if the list is a track list.
 * @param {Function} callback A callback function. The data argument will be an
 *     array of object values.
 */
function getRowsFromData(data, isTrackList, callback) {
  var flowFunctions = [];

  if (data['text/x-spotify-tracks']) {
    flowFunctions.push(function () {
      this.done(null, getRowObjects('track', data['text/x-spotify-tracks']));
    });
  }

  if (data['text/x-spotify-albums']) {
    flowFunctions.push(function () {
      var albums = data['text/x-spotify-albums'];
      if (isTrackList) fetchListTrackRows(albums, this);else this.done(null, getRowObjects('album', albums));
    });
  }

  if (data['text/x-spotify-playlists']) {
    flowFunctions.push(function () {
      var playlists = data['text/x-spotify-playlists'];
      if (isTrackList) fetchListTrackRows(playlists, this);else this.done(null, getRowObjects('playlist', playlists));
    });
  }

  if (data['text/x-spotify-artists']) {
    flowFunctions.push(function () {
      this.done(null, getRowObjects('artist', data['text/x-spotify-artists']));
    });
  }

  if (data['text/x-spotify-users']) {
    flowFunctions.push(function () {
      this.done(null, getRowObjects('user', data['text/x-spotify-users']));
    });
  }

  flow(flowFunctions).finally(function (error) {
    if (error) return callback(error);

    var arrays = Array.prototype.slice.call(arguments, 1);
    var rows = [];
    rows = rows.concat.apply(rows, arrays);

    callback(null, rows);
  });
}

/**
 * Fetch the track rows from a set of list URIs. This is for the expansion of
 * for example an album into the tracks of the album.
 *
 * @param {Array.<string>} listUris Array of list URIs.
 * @param {Object} control Flow control object.
 */
function fetchListTrackRows(listUris, control) {
  flow().parallel(listUris, function (listUri) {
    var innerControl = this;
    live(listUri).query('rows(track(uri))', function (error, data) {
      if (error) return innerControl.done(null, []);
      var rows = data.rows.map(function (row) {
        return live(row);
      });
      innerControl.done(null, rows);
    }, live.ASAP);
  }).finally(function (error) {
    if (error) return control.done(null, []);
    var arrays = Array.prototype.slice.call(arguments, 1);
    var rows = [];
    rows = rows.concat.apply(rows, arrays);
    control.done(null, rows);
  });
}

/**
 * Fetch the live object for the row of an item.
 *
 * @param {string} itemType The type of an item (for example 'track').
 * @param {Array.<string>} uris Array of item URIs.
 *
 * @return {Array.<LiveObject>} Array of row live objects.
 */
function getRowObjects(itemType, uris) {
  return uris.map(function (uri) {
    var row = {};
    row[itemType] = { uri: uri };
    return live(row);
  });
}

/**
 * Check if the list is a track list.
 *
 * @param {LiveList} liveList The live list.
 * @param {string} contextUri The context URI for the list.
 *
 * @return {boolean} True if the list is a track list.
 */
function isListOfTracks(liveList, contextUri) {
  var uriObject = liburi.from(contextUri);
  var type = uriObject && uriObject.type;
  if (type === liburi.Type.PLAYLIST) return true;

  var result = { valid: false };
  hooks.run('is-list-of-tracks', result, liveList, contextUri);

  if (!result.valid) {
    var firstRow = liveList.get(0);
    var firstTrack = firstRow && firstRow.get('track');
    if (firstTrack) return true;
  }

  return !!result.valid;
}

/**
 * Check if the position is below the bottom edge of the node.
 *
 * @param {number} x The X position relative to the viewport.
 * @param {number} y The Y position relative to the viewport.
 * @param {HTMLElement} node DOM node to check against.
 *
 * @return {boolean} True if the position is below.
 */
function isBelowNode(x, y, node) {
  var rect = node.getBoundingClientRect();
  var below = y >= rect.bottom;
  var betweenX = x >= rect.left && x <= rect.right;
  return below && betweenX;
}

/**
 * Check if the position is below the middle of the node.
 *
 * @param {number} y The Y position relative to the viewport.
 * @param {HTMLElement} node DOM node to check against.
 *
 * @return {boolean} True if the position is below.
 */
function isBelowMiddleOfNode(y, node) {
  var rect = node.getBoundingClientRect();
  return y >= rect.top + rect.height / 2;
}

/**
 * Check if the MIME types in the drag event matches the MIME types for the
 * specified drop target.
 *
 * @param {MouseEvent} event Some kind of drag and drop event.
 * @param {HTMLElement} node A DOM node.
 *
 * @return {boolean} True if the element matches the event.
 */
function isMatchingTarget(event, node) {
  var eventTypes = event.dataTransfer.types;
  var nodeTypes = node.getAttribute(ATTR_TARGET);

  if (nodeTypes) {
    var matching = intersection(nodeTypes.split('|'), eventTypes);
    if (matching.length > 0) return true;
  }

  return false;
}

/**
 * Temporarily disable drag and dropping inside a list until the move or insert
 * is done. This is to prevent multiple operations to be called before the
 * response from the first comes back. We consider the operation done when we
 * receive the next update event, since it's very tricky to know when this
 * specific move is done. To prevent possible errors with being disabled
 * infinitely, we will enable it again after a certain timeout. This could
 * happen for example if the live list is switched out for a new list, in which
 * case we won't get the update event.
 *
 * @param {string} contextUri The context URI.
 * @param {LiveList} liveList The live list that was changed.
 */
function temporarilyDisableList(contextUri, liveList) {

  disabledLists[contextUri] = true;

  var timer;

  var handler = function handler(operations) {
    clearTimeout(timer);
    liveList.off('update', handler);

    // Wait slighly longer to allow the change to trickle down to DOM
    setTimeout(function () {
      delete disabledLists[contextUri];
    }, 100);
  };

  liveList.on('update', handler);

  timer = setTimeout(handler, 500);
}

/**
 * Attach the module.
 */
function attach() {
  eventModel.delegate('dragstart', SELECTOR_DRAGGABLE, onDragStart);
  eventModel.delegate('dragover', SELECTOR_LIST_TARGET, onDragOver);
  eventModel.delegate('dragleave', SELECTOR_LIST_TARGET, onDragLeave);
  eventModel.delegate('dragend', 'body', onDragEnd);
  eventModel.delegate('drop', SELECTOR_LIST_TARGET, onDrop);
}

/**
 * Detach the module.
 */
function detach() {
  eventModel.undelegate('dragstart', SELECTOR_DRAGGABLE, onDragStart);
  eventModel.undelegate('dragover', SELECTOR_LIST_TARGET, onDragOver);
  eventModel.undelegate('dragleave', SELECTOR_LIST_TARGET, onDragLeave);
  eventModel.undelegate('dragend', 'body', onDragEnd);
  eventModel.undelegate('drop', SELECTOR_LIST_TARGET, onDrop);
}

exports.attach = attach;
exports.detach = detach;

},{"../../spotify-elements":70,"../../spotify-live":251,"../../spotify-range2":289,"../selection":113,"./util/eventmodel":86,"./util/hooks":87,"finally":317,"mout/array/intersection":358,"spotify-liburi":426,"spotify-live-list-operations":427}],85:[function(require,module,exports){
(function (global){
/**
 * @module spotify-events/dragndrop/target
 * @private
 */
'use strict';

var $ = require('../../spotify-elements');
var liburi = require('spotify-liburi');
var defer = require('prime/defer');

var center = require('../center');
var eventModel = require('./util/eventmodel');
var hooks = require('./util/hooks');
var getLogContext = require('../util/get-log-context');
var UserDragAndDropInteraction1 = require('../../spotify-logger/messages/UserDragAndDropInteraction1');

var SELECTOR_DROP_TARGET = '[data-drop-target]';
var SELECTOR_DRAGGABLE = 'a, [draggable]';
var ATTR_TARGET = 'data-drop-target';
var ATTR_NO_CLASSNAME = 'data-drop-no-classname';
var CLASSNAME_ACTIVE = 'drop-target-active';

var longHoldTimerId = 0;
var longHoldTimerDuration = 1000;
var draggedElement = null;
var lastEnteredElement = null;

/**
 * Handler for starting to drag.
 *
 * @param {MouseEvent} event A dragstart event object.
 * @param {HTMLElement} node The draggable DOM element.
 */
function onDragStart(event, node) {
  draggedElement = node;
  lastEnteredElement = null;
}

/**
 * Handler for ending a drag.
 *
 * @param {MouseEvent} event A dragend event object.
 * @param {HTMLElement} target DOM element for the drop target.
 */
function onDragEnd(event, target) {
  draggedElement = null;
  lastEnteredElement = null;

  stopLongHoldTimer();
  removeAnyActiveClass();
}

/**
 * Handler for dragging into a drop target.
 *
 * @param {MouseEvent} event A dragenter event object.
 * @param {HTMLElement} target DOM element for the drop target.
 */
function onDragEnter(event, target) {
  if (validateTarget(event, target)) {
    setEnter(event, target);
  }
}

/**
 * Handler for dragging out from a drop target.
 *
 * @param {MouseEvent} event A dragleave event object.
 * @param {HTMLElement} target DOM element for the drop target.
 */
function onDragLeave(event, target) {
  if (validateTarget(event, target)) {
    setLeave(event, target);
  }
}

/**
 * Handler for dragging over a drop target.
 *
 * @param {MouseEvent} event A dragover event object.
 * @param {HTMLElement} target DOM element for the drop target.
 */
function onDragOver(event, target) {
  if (validateTarget(event, target)) {

    // Tell the event that we are accepting drops on this target
    event.preventDefault();

    // Since other code might have set the dropEffect to something else,
    // we need to override that, since we're now accepting drops
    event.dataTransfer.dropEffect = 'copy';

    setEnter(event, target);

    // If the target is not valid, remove any styling for active drop target
  } else {
      setLeave(event, target);
    }
}

/**
 * Handler for dropping on a drop target.
 *
 * @param {MouseEvent} event A drop event object.
 * @param {HTMLElement} target DOM element for the drop target.
 */
function onDrop(event, target) {
  stopLongHoldTimer();

  // Dropping should remove active target class name.
  // Dropping outside of a target doesn't need this, as the target is only
  // active when hovering it.
  removeAnyActiveClass();

  if (validateTarget(event, target)) {
    var types = getMimeTypesForTarget(event, target);
    var dropData = getDropData(event, types);
    var sourceUri = event.dataTransfer.getData('text/x-spotify-data-context') || null;
    var sourceLogContext = event.dataTransfer.getData('text/x-spotify-data-log-context') || null;
    var sourceAppUri = event.dataTransfer.getData('text/x-spotify-data-app-uri') || null;
    var sourceIndex = parseInt(event.dataTransfer.getData('text/x-spotify-data-log-source-index'), 0);
    if (isNaN(sourceIndex)) sourceIndex = null;

    var targetUriNode = target.closest('[data-uri]');
    var targetUri = targetUriNode && targetUriNode.getAttribute('data-uri') || null;
    var targetLogContext = getLogContext(target);
    var targetAppUri = global.__spotify && global.__spotify.app_uri || null;

    // Give any other delegates a chance to handle the drop, and if so pass
    // that info along in the event.
    defer(function () {
      center.emit('drop', {
        handled: event.handled,
        node: target,
        sourceUri: sourceUri,
        targetUri: targetUri,
        data: dropData
      });

      var firstItem = dropData[Object.keys(dropData)[0]][0];
      var itemType = liburi.from(firstItem).type;
      var numberOfItems = Object.keys(dropData).reduce(function (sum, key) {
        return sum + dropData[key].length;
      }, 0);
      var targetIndex = event.data && event.data.targetIndex || null;

      UserDragAndDropInteraction1.log({
        item_type: itemType,
        item_uri: firstItem,
        number_items: numberOfItems,
        source_view_uri: sourceAppUri,
        source_uri: sourceUri,
        source_index: sourceIndex,
        source_component: sourceLogContext,
        target_view_uri: targetAppUri,
        target_uri: targetUri,
        target_index: targetIndex,
        target_component: targetLogContext
      });
    });
  }

  // Prevent navigation on drop
  event.preventDefault();

  // Reset here since our multi-frame architecture means we're not guaranteed
  // to have gotten a dragstart event in this frame prior to dropping.
  lastEnteredElement = null;
}

/**
 * Set target to be entered, including setting style and sending event.
 *
 * @param {MouseEvent} event A dragenter event object.
 * @param {HTMLElement} target DOM element for the drop target.
 */
function setEnter(event, target) {
  if (target === lastEnteredElement) {
    return;
  }

  lastEnteredElement = target;

  if (!target.hasAttribute(ATTR_NO_CLASSNAME)) {
    $(target).addClass(CLASSNAME_ACTIVE);
  }

  var types = getMimeTypesForTarget(event, target);
  center.emit('dragenter', { node: target, types: types });

  startLongHoldTimer(target, types);
}

/**
 * Set target to be left, including removing style and sending event.
 *
 * @param {MouseEvent} event A dragleave event object.
 * @param {HTMLElement} target DOM element for the drop target.
 */
function setLeave(event, target) {
  if (target !== lastEnteredElement) {
    return;
  }

  lastEnteredElement = null;

  if (!target.hasAttribute(ATTR_NO_CLASSNAME)) {
    $(target).removeClass(CLASSNAME_ACTIVE);
  }

  var types = getMimeTypesForTarget(event, target);
  center.emit('dragleave', { node: target, types: types });

  stopLongHoldTimer();
}

/**
 * Check if the drop target matches the MIME types for the event.
 *
 * @param {MouseEvent} event Some kind of drag and drop event.
 * @param {HTMLElement} target DOM element for the drop target.
 *
 * @return {boolean} True if the target is valid.
 */
function validateTarget(event, target) {

  // The element being dragged is not accepted as a drop target
  if (target === draggedElement) {
    return false;
  }

  var types = getMimeTypesForTarget(event, target);

  if (types.length) {
    var result = { valid: true };
    hooks.run('target-validation', result, event, target);

    if (result.valid) {
      return true;
    }
  }

  return false;
}

/**
 * Get the data associated with the drop, grouped by MIME type.
 * If the data contained Spotify URLs, they will be converted to Spotify URIs.
 *
 * @param {MouseEvent} event Event object for a drop event.
 * @param {Array.<string>} types Array of MIME types.
 *
 * @return {Object.<string, Array.<string>>} Data object of arrays of item
 *     URIs, grouped by MIME type.
 */
function getDropData(event, types) {
  var data = {};

  for (var i = 0, l = types.length; i < l; i++) {
    var itemsInData = data[types[i]] = [];
    var dataForType = event.dataTransfer.getData(types[i]);
    var hasURIs = types[i].indexOf('text/x-spotify') === 0;
    var items = hasURIs ? dataForType.split('\n') : [dataForType];

    for (var n = 0, len = items.length; n < len; n++) {
      var item = items[n];
      if (hasURIs) {
        var uriObject = liburi.from(item);
        if (uriObject) item = uriObject.toURI();
      }
      if (item) itemsInData.push(item);
    }
  }

  var hasContextData = types.indexOf('text/x-spotify-data-context') > -1;
  if (hasContextData) {
    data['text/x-spotify-data-context'] = [event.dataTransfer.getData('text/x-spotify-data-context')];
  }

  return data;
}

/**
 * Start a timer for emitting an event for long-hold on a target.
 * If one is already started, it will use the previous timer and not restart it.
 *
 * @param {HTMLElement} target A DOM element for the drop target.
 * @param {Array.<string>} types Array of MIME types.
 */
function startLongHoldTimer(target, types) {

  // Don't start a new timer if we already have one running
  if (longHoldTimerId) return;

  longHoldTimerId = setTimeout(function () {
    center.emit('dragover-long', { node: target, types: types });
  }, longHoldTimerDuration);
}

/**
 * Stop any running timer for emitting an event for long-hold on a target.
 */
function stopLongHoldTimer() {
  clearTimeout(longHoldTimerId);

  // Reset the timer ID so we can know that there is no timer running
  longHoldTimerId = 0;
}

/**
 * Remove the active class name from any element that has it.
 */
function removeAnyActiveClass() {
  var active = $('.' + CLASSNAME_ACTIVE);
  if (active) {
    active.removeClass(CLASSNAME_ACTIVE);
  }
}

/**
 * Get the MIME types that are matching both the drag event and the target.
 *
 * @param {MouseEvent} event Any kind of drag and drop event.
 * @param {HTMLElement} target A DOM element.
 *
 * @return {Array.<string>} Array of MIME types.
 */
function getMimeTypesForTarget(event, target) {
  var mimeTypes = [];
  var dataTypes = event.dataTransfer.types;

  var targetTypes = target.getAttribute(ATTR_TARGET);
  if (targetTypes) {
    targetTypes = targetTypes.split('|');

    for (var i = 0, l = dataTypes.length; i < l; i++) {
      var type = dataTypes[i];
      if (targetTypes.indexOf(type) > -1) {
        mimeTypes.push(type);
      }
    }
  }

  return mimeTypes;
}

/**
 * Attach the module.
 */
function attach() {
  eventModel.delegate('dragstart', SELECTOR_DRAGGABLE, onDragStart);
  eventModel.delegate('dragenter', SELECTOR_DROP_TARGET, onDragEnter);
  eventModel.delegate('dragleave', SELECTOR_DROP_TARGET, onDragLeave);
  eventModel.delegate('dragover', SELECTOR_DROP_TARGET, onDragOver);
  eventModel.delegate('dragend', 'body', onDragEnd);
  eventModel.delegate('drop', SELECTOR_DROP_TARGET, onDrop);
}

/**
 * Detach the module.
 */
function detach() {
  eventModel.undelegate('dragstart', SELECTOR_DRAGGABLE, onDragStart);
  eventModel.undelegate('dragenter', SELECTOR_DROP_TARGET, onDragEnter);
  eventModel.undelegate('dragleave', SELECTOR_DROP_TARGET, onDragLeave);
  eventModel.undelegate('dragover', SELECTOR_DROP_TARGET, onDragOver);
  eventModel.undelegate('dragend', 'body', onDragEnd);
  eventModel.undelegate('drop', SELECTOR_DROP_TARGET, onDrop);
}

exports.attach = attach;
exports.detach = detach;

// Exporting for testing
var originalDuration = longHoldTimerDuration;
exports.setLongHoldDuration = function setLongHoldDuration(duration) {
  longHoldTimerDuration = duration;
};
exports.resetLongHoldDuration = function resetLongHoldDuration() {
  longHoldTimerDuration = originalDuration;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../spotify-elements":70,"../../spotify-logger/messages/UserDragAndDropInteraction1":262,"../center":77,"../util/get-log-context":130,"./util/eventmodel":86,"./util/hooks":87,"prime/defer":402,"spotify-liburi":426}],86:[function(require,module,exports){
/**
 * @module spotify-events/dragndrop/util/eventmodel
 * @private
 *
 * This module is made to be an abstraction of the event model for drag and
 * drop. It also exposes a delegation interface which allows you to only
 * listen for events for targets matching a certain selector.
 *
 * The need for this abstraction is to simplify the code listening to drag
 * and drop events.
 *
 * - The raw events we get from the browser are sometimes not that easy to
 *   work with. For example, when moving from one target to another, we get
 *   a dragenter event before the dragleave event, which can cause confusion.
 *   This abstraction flips that around, so that you always get the dragleave
 *   event before the dragenter event.
 *
 * - The raw events also trigger for children. For example, if moving the
 *   cursor from one element to one of its children, we get a dragenter event
 *   for the child element and a dragleave for the outer element. This makes
 *   it difficult to highlight drop targets based on dragenter/dragleave.
 *   This abstraction helps by making sure the handler is not called if moving
 *   to a child element inside an element that matches the selector. There
 *   is an exception though when moving to a child that is also matching a
 *   selector, the outer element is then left and the child is entered.
 *
 * @example
 * function onDragEnter(event, target) {
 *   event instanceof MouseEvent; // true
 *   target instanceof HTMLElement; // true
 *   target.matches('[data-drop-target]'); // true
 * }
 *
 * // Start listening
 * eventmodel.delegate('dragenter', '[data-drop-target]', onDragEnter);
 *
 * // Stop listening
 * eventmodel.undelegate('dragenter', '[data-drop-target]', onDragEnter);
 */
'use strict';

var $ = require('../../../spotify-elements');

var attached = {};
var delegations = {};
var movementHandlerCount = 0;

// State variables
var hasEntered = false;
var lastEnteredElement = null;
var lastEnterTarget = null;
var lastEnterEvent = null;
var wasLastEventEnter = false;

/**
 * Reset the temporary state variables used while dragging.
 */
function resetState() {
  hasEntered = false;
  lastEnteredElement = null;
  lastEnterTarget = null;
  lastEnterEvent = null;
  wasLastEventEnter = false;
}

/**
 * Generic handler for any event.
 * This function will look at the current delegations and run the handler
 * functions for the matching delegations.
 * Some events will be handled by calling a special handler, which in some cases
 * later will check for matching delegations.
 *
 * @param {Event} event Event object.
 */
function onEvent(event) {
  var handler = getPrimaryHandler(event.type);
  if (handler) {
    handler(event);
  } else {
    handleDelegationsForEvent(event);
  }
}

/**
 * Handler for a dragenter event.
 * Depending on state, this might save the event for later and call the
 * handler at a later point, to ensure that the dragenter event is sent
 * after the dragleave.
 *
 * @param {MouseEvent} event Event object for a dragenter event.
 */
function onPrimaryDragEnter(event) {
  wasLastEventEnter = true;

  if (hasEntered) {
    if (lastEnteredElement !== event.target) {
      lastEnterEvent = event;
    }
  } else {
    hasEntered = true;
    lastEnteredElement = event.target;
    handleDelegationsForEvent(event);
  }
}

/**
 * Handler for a dragleave event.
 * Depending on state, this might also trigger the handlers for a dragenter
 * event, if there was a saved event from before.
 *
 * @param {MouseEvent} event Event object for a dragleave event.
 */
function onPrimaryDragLeave(event) {
  wasLastEventEnter = false;
  lastEnteredElement = null;

  handleDelegationsForEvent(event);

  if (hasEntered) {
    if (lastEnterEvent) {
      lastEnteredElement = lastEnterEvent.target;
      handleDelegationsForEvent(lastEnterEvent);
      lastEnterEvent = null;
    } else {
      hasEntered = false;
    }
  }
}

/**
 * Handler for a drop event.
 * This is handled by a special handler only to reset some state.
 *
 * @param {MouseEvent} event Event object for a drop event.
 */
function onPrimaryDrop(event) {
  resetState();
  handleDelegationsForEvent(event);
}

/**
 * Handler for a dragend event.
 * This is handled by a special handler only to reset some state.
 *
 * @param {MouseEvent} event Event object for a drop event.
 */
function onPrimaryDragEnd(event) {
  resetState();
  handleDelegationsForEvent(event);
}

/**
 * Delegation handler for a dragenter event.
 * After matching against stored delegations, we need to do some final checking
 * before calling the user handler.
 *
 * @param {MouseEvent} event Event object for a dragenter event.
 * @param {HTMLElement} target A DOM element.
 * @param {Function} handler The user handler.
 * @param {string} selector A CSS selector string.
 */
function onDragEnter(event, target, handler, selector) {
  if (target !== lastEnterTarget) {
    lastEnterTarget = target;
    callUserHandler(event, target, handler);
  }
}

/**
 * Delegation handler for a dragleave event.
 * After matching against stored delegations, we need to do some final checking
 * before calling the user handler.
 *
 * @param {MouseEvent} event Event object for a dragleave event.
 * @param {HTMLElement} target A DOM element.
 * @param {Function} handler The user handler.
 * @param {string} selector A CSS selector string.
 */
function onDragLeave(event, target, handler, selector) {
  var shouldCallUserHandler = false;

  var lastElement = lastEnterEvent && lastEnterEvent.target;
  if (lastElement) {
    var isSameElement = target === lastElement;
    var isEnteringChild = !isSameElement && target.contains(lastElement);
    var isEnteringMatchingElement = $(lastElement).matches(selector);
    if (!isSameElement && (!isEnteringChild || isEnteringMatchingElement)) {
      shouldCallUserHandler = true;
    }
  }

  // Most often the sequence of events will be dragenter->dragenter->dragleave
  // when moving into one element and then into another element. But if the
  // sequence is just dragenter->dragleave, we should also call the user
  // handler. This would happen if there is no new entered element.
  if (!wasLastEventEnter) {
    shouldCallUserHandler = true;
  }

  if (shouldCallUserHandler) {
    lastEnterTarget = null;
    callUserHandler(event, target, handler);
  }
}

/**
 * Find matching delegations and call the handlers.
 *
 * @param {Event} event Event object.
 */
function handleDelegationsForEvent(event) {
  var type = event.type;
  var delegationData = delegations[type];

  if (delegationData && delegationData.length > 0) {

    delegationData.forEach(function (data) {
      var selector = data.selector;
      var matchingTarget = event.target.closest(selector);

      if (matchingTarget) {
        var handler = getHandler(type) || callUserHandler;
        handler(event, matchingTarget, data.handler, selector);
      }
    });
  }
}

/**
 * Call the user handler for a delegation.
 *
 * @param {Event} event Event object.
 * @param {HTMLElement} target A DOM element.
 * @param {Function} handler The user handler.
 * @param {string} selector A CSS selector string.
 */
function callUserHandler(event, target, handler, selector) {
  handler.call(exports, event, target);
}

/**
 * Get any handler that needs to be called for a raw event before looking
 * for any delegations.
 *
 * @param {string} type Event type.
 *
 * @return {Function?} The handler function or null if no special handler
 *     should be called.
 */
function getPrimaryHandler(type) {
  switch (type) {
    case 'dragenter':
      return onPrimaryDragEnter;
    case 'dragleave':
      return onPrimaryDragLeave;
    case 'dragend':
      return onPrimaryDragEnd;
    case 'drop':
      return onPrimaryDrop;
  }
  return null;
}

/**
 * Get any handler that needs to be called after matching delegations,
 * but before calling the user handler.
 *
 * @param {string} type Event type.
 *
 * @return {Function?} The handler function or null if no special handler
 *     should be called.
 */
function getHandler(type) {
  switch (type) {
    case 'dragenter':
      return onDragEnter;
    case 'dragleave':
      return onDragLeave;
  }
  return null;
}

/**
 * Check if the event type is one of the events that need special handling
 * for movement (enter/leave events).
 *
 * @param {string} type Event type.
 *
 * @return {boolean} True if the type is a movement type, false otherwise.
 */
function isMovementType(type) {
  switch (type) {
    case 'dragenter':
      return true;
    case 'dragleave':
      return true;
    case 'dragend':
      return true;
    case 'drop':
      return true;
  }
  return false;
}

/**
 * Attach a global event listener on document for the specified type.
 *
 * @param {string} type Event type.
 */
function attach(type) {
  if (attached[type]) return;
  attached[type] = true;
  document.addEventListener(type, onEvent, false);
}

/**
 * Detach a global event listener on document for the specified type.
 *
 * @param {string} type Event type.
 */
function detach(type) {
  if (!attached[type]) return;
  attached[type] = false;
  document.removeEventListener(type, onEvent, false);
}

/**
 * Start listening for an event via event delegation for the specified
 * selector.
 *
 * @example
 * var selector = '[data-drop-target]';
 * eventModel.delegate('dragenter', selector, function(event, target) {
 *   event instanceof MouseEvent; // true
 *   target instanceof HTMLElement; // true
 *   target.matches('[data-drop-target]'); // true
 * });
 */
function delegate(type, selector, handler) {
  if (isMovementType(type)) {
    movementHandlerCount++;
    if (movementHandlerCount === 1) {
      attach('dragenter');
      attach('dragleave');
      attach('dragend');
      attach('drop');
    }
  } else if (!attached[type]) {
    attach(type);
  }

  if (!delegations[type]) delegations[type] = [];

  delegations[type].push({ selector: selector, handler: handler });
}

/**
 * Stop listening for an event via event delegation for the specified
 * selector and handler.
 *
 * @example
 * eventModel.undelegate('dragenter', '[data-drop-target]', handler);
 */
function undelegate(type, selector, handler) {
  if (isMovementType(type)) {
    movementHandlerCount = Math.max(0, movementHandlerCount - 1);
    if (movementHandlerCount === 0) {
      detach('dragenter');
      detach('dragleave');
      detach('dragend');
      detach('drop');
    }
  }

  var delegationsForType = delegations[type];
  if (delegationsForType) {
    for (var i = 0, l = delegationsForType.length; i < l; i++) {
      var data = delegationsForType[i];
      if (data.selector === selector && data.handler === handler) {
        delegationsForType.splice(i, 1);
        break;
      }
    }

    if (!isMovementType && delegationsForType.length === 0) {
      detach(type);
    }
  }
}

exports.delegate = delegate;
exports.undelegate = undelegate;

},{"../../../spotify-elements":70}],87:[function(require,module,exports){
/**
 * Hooks
 *
 * Almost like an event emitter. You can add hooks for different ids, and when
 * a hook for an ID is run, the handlers are called.
 *
 * @module spotify-events/dragndrop/util/hooks
 * @private
 */
'use strict';

var hooks = {};

/**
 * Add a hook handler for a specific hook ID.
 *
 * @param {string} id The hook ID.
 * @param {function} handler The handler function. The hook sets the arguments.
 */
function add(id, handler) {
  if (!hooks[id]) hooks[id] = [];
  hooks[id].push(handler);
}

/**
 * Remove a hook handler for a specific hook ID.
 *
 * @param {string} id The hook ID.
 * @param {function} handler The handler function.
 */
function remove(id, handler) {
  if (hooks[id]) {
    var index = hooks[id].indexOf(handler);
    if (index > -1) {
      hooks[id].splice(index, 1);
    }
  }
}

/**
 * Run the hook handlers for a specific hook ID.
 *
 * @param {string} id The hook ID.
 * @param {...*} var_args Arguments to pass to the handlers.
 */
function run(id, var_args) {
  var handlers = hooks[id];
  if (handlers && handlers.length > 0) {
    var args = Array.prototype.slice.call(arguments, 1);
    for (var i = 0, l = handlers.length; i < l; i++) {
      handlers[i].apply(null, args);
    }
  }
}

exports.add = add;
exports.remove = remove;
exports.run = run;

},{}],88:[function(require,module,exports){
/**
 * @module spotify-events/dragndrop/util/itemtext
 * @private
 */
'use strict';

var live = require('../../../spotify-live');
var liburi = require('spotify-liburi');

/**
 * Get the text for a URI.
 *
 * @param {string} uri Any URI.
 *
 * @return {string} The text.
 */
function getForUri(uri) {
  var uriObject = liburi.from(uri);
  if (!uriObject) return '';

  var type = uriObject.type;

  if (type === liburi.Type.TRACK || type === liburi.Type.LOCAL) {
    return getForTrack(uri);
  } else if (type === liburi.Type.ARTIST || type === liburi.Type.LOCAL_ARTIST) {
    return getForArtist(uri);
  } else if (type === liburi.Type.ALBUM || type === liburi.Type.LOCAL_ALBUM) {
    return getForAlbum(uri);
  } else if (type === liburi.Type.PLAYLIST) {
    return getForPlaylist(uri);
  } else if (type === liburi.Type.USER || type === liburi.Type.PROFILE) {
    return getForUser(uri);
  } else if (type === liburi.Type.FOLDER) {
    return getForFolder(uri);
  } else if (type === liburi.Type.STATION) {
    return getForStation(uri);
  }

  return '';
}

/**
 * Get the text for a track URI.
 *
 * Examples:
 * Track Name – First Artist, Second Artist, Third Artist (and so on...)
 * Track Name
 *
 * @param {string} uri Track URI.
 *
 * @return {string} The text.
 */
function getForTrack(uri) {
  var object = live(uri);
  var itemName = object.get('name');
  if (!itemName) return '';

  var artists = object.get('artists');
  if (!artists || artists.length === 0) return itemName;

  var artistNames = artists.get(0, artists.length).map(function (artist) {
    return artist.get('name');
  }).join(', ');
  if (!artistNames) return itemName;

  return separateDragTextItems(itemName, artistNames);
}

/**
 * Get the text for an artist URI.
 *
 * Examples:
 * Artist Name
 *
 * @param {string} uri Artist URI.
 *
 * @return {string} The text.
 */
function getForArtist(uri) {
  return live(uri).get('name') || '';
}

/**
 * Get the text for an album URI.
 *
 * Examples:
 * Artist Name – Album Name
 * Album Name
 *
 * @param {string} uri Album URI.
 *
 * @return {string} The text.
 */
function getForAlbum(uri) {
  var object = live(uri);
  var itemName = object.get('name');
  if (!itemName) return '';

  var artists = object.get('artists');
  if (!artists || artists.length === 0) return itemName;

  var artistName = artists.get(0).get('name');
  if (!artistName) return itemName;

  return separateDragTextItems(artistName, itemName);
}

/**
 * Get the text for a playlist URI.
 *
 * Examples:
 * Playlist Name – Owner Name
 * Playlist Name – owner_username
 * Playlist Name
 *
 * @param {string} uri Playlist URI.
 *
 * @return {string} The text.
 */
function getForPlaylist(uri) {
  var object = live(uri);
  var itemName = object.get('name');
  if (!itemName) return '';

  var owner = object.get('owner');
  var ownerName = owner && (owner.get('name') || owner.get('username'));
  if (!ownerName) return itemName;

  return separateDragTextItems(itemName, ownerName);
}

/**
 * Get the text for a playlist URI.
 *
 * Examples:
 * User Name
 * username
 *
 * @param {string} uri Playlist URI.
 *
 * @return {string} The text.
 */
function getForUser(uri) {
  var object = live(uri);
  var itemName = object.get('name');
  if (itemName) return itemName;

  var uriObject = liburi.fromString(uri);
  var username = uriObject && uriObject.username;
  return username || '';
}

/**
 * Get the text for a folder URI.
 *
 * Examples:
 * Folder Name
 *
 * @param {string} uri Folder URI.
 *
 * @return {string} The text.
 */
function getForFolder(uri) {
  return live(uri).get('name');
}

/**
 * Get the text for a station URI.
 *
 * Examples:
 * Station Name
 *
 * @param {string} uri Station URI.
 *
 * @return {string} The text.
 */
function getForStation(uri) {
  return live(uri).get('name');
}

/**
 * Separate two strings by the special dash ('en dash', &#8211;) we use.
 *
 * @param {string} item1 First string.
 * @param {string} item2 Second string.
 *
 * @return {string} Final string.
 */
function separateDragTextItems(item1, item2) {
  return item1 + ' – ' + item2;
}

/**
 * Get the text for an element.
 *
 * @param {HTMLElement} target The target element being dragged.
 *
 * @return {string} The drag text.
 */
function getForElement(target) {
  var title = target.getAttribute('data-drag-text');
  if (title) return title;

  var uri = target.getAttribute('data-uri');
  if (uri) {
    title = getForUri(uri);
    if (title) return title;
  }

  title = target.getAttribute('title');
  if (title) return title;

  return target.textContent;
}

exports.getForUri = getForUri;
exports.getForElement = getForElement;

},{"../../../spotify-live":251,"spotify-liburi":426}],89:[function(require,module,exports){
'use strict';

var $ = require('../spotify-elements');
var live = require('../spotify-live');
var center = require('./center');
var stickyEvents = require('./sticky');
var cosmos = require('./util/cosmos');
var merge = require('mout/object/merge');
var deepEquals = require('mout/lang/deepEquals');
var getOriginUri = require('../spotify-live-wrapped-uri').getOriginUri;
var appUtil = require('./util/app');
var shuffleMode = require('../spotify-shuffle-mode');

var SCROLL_PADDING = 8;
var STRING_FILTER_KEY = 'list-filter-string-';
var SESSION_STORAGE = 'spotify:session-storage';

function update(node) {
  if (!isAttached) return;

  node = $(node) || $(document);
  var nodes = node.matches('[data-filter]') ? [node[0]] : node.search('[data-filter]');
  if (!nodes) return;
  nodes.forEach(function (node) {
    var uri = getURI(node);
    if (!uri) return;

    // When no state is initialized for the uri, initialize it and set the string from the DOM.
    // This is the case when the playlist app loaded a URI that globally has a filter string set.
    var hasState = states[uri];
    if (!hasState) {
      var inputElement = $(node).find('input[type=text]')[0];
      var value = inputElement.value;
      if (value) {
        updateState(uri, {
          activated: true,
          enteredString: value
        });
      }
    }

    handleStale(uri);
  });
}

function handleStale(uri) {
  render(uri);
  logUsage(uri);

  var state = getState(uri);
  var stateHasBeenEmitted = deepEquals(state, lastEmittedStates[uri]);
  if (!stateHasBeenEmitted) {
    lastEmittedStates[uri] = state;
    var value = state.activated ? state.enteredString : '';
    emitFilterRequest(uri, value);
    persistFilterOnSessionStorage(uri, value);
  }
}

function render(uri) {
  var $candidateContainers = $(document).search('[data-uri] [data-filter]');
  if (!$candidateContainers) return;

  var $matchingCandidates = $candidateContainers.filter(function (container) {
    return getURI(container) === uri;
  });
  $matchingCandidates.forEach(function (mainElement) {
    var state = getState(uri);
    var inputElement = $(mainElement).find('input[type=text]')[0];
    var wrapperElement = $(mainElement).find('.h-search-wrapper')[0];
    if (state.activated) {
      if (!$(wrapperElement).hasClass('focus')) {
        $(wrapperElement).addClass('focus');

        mainElement.setAttribute('data-sticky', '');
        stickyEvents.update();
      }

      // NOTE: Setting input.value makes the cursor jump
      // which is annoying when changing typos in the
      // search field. Only set value if text ACTUALLY
      // changes:
      if (inputElement.value !== state.enteredString) {
        inputElement.value = state.enteredString;
      }
    } else {
      inputElement.blur();
      if ($(wrapperElement).hasClass('focus')) {
        $(wrapperElement).removeClass('focus');

        mainElement.removeAttribute('data-sticky');
        stickyEvents.update();
      }
      inputElement.value = '';
    }
  });
}

function focusAndSelectInput(inputElement) {

  // Only focus and select the input text if doesn't have focus already.
  if (document.activeElement != inputElement) {
    inputElement.focus();
    inputElement.select();
  }
}

function scrollIntoView(inputElement) {
  var rect = inputElement.getBoundingClientRect();

  // [SHUFFLE]
  // If sticky header is displayed, let's compensate scroll position with header's height
  // (otherwise the focused filter input might end up under the sticky header)
  var stickyHeaderOffset = 0;
  if (shuffleMode.isEnabled()) {
    var stickyHeader = $('.h-sticky-header [data-sticky-active]');
    if (stickyHeader) {
      stickyHeaderOffset = stickyHeader[0].offsetHeight;
    }
  }

  // Only scroll if the input is out of view
  var filterFieldOffset = rect.top - SCROLL_PADDING - stickyHeaderOffset;
  if (filterFieldOffset < 0 || rect.bottom > window.innerHeight) {
    window.scrollTo(0, window.pageYOffset + filterFieldOffset);
  }
}

function logUsage(uri) {
  var state = getState(uri);
  if (state.enteredString && !getState(uri).usageLogged) {
    updateState(uri, { usageLogged: true });
    // Fields must be in the same order as in logparser
    // AND all fields MUST be present or logging wont happen
    // and will fail silently. https://ghe.spotify.net/datainfra/log-parser/blob/94e6a896efa5d781b0cac54f3dcf92c9c4ee3c73/spotify/log_parser/messages_specs.py#L777

    cosmos.post({
      url: 'sp://logging/v1/log',
      body: {
        'message': 'ClientEvent',
        'version': 3,
        'fields': [window.__spotify.app_uri, // source
        'spotify-events-filter', // context
        'user:typing', // event
        'input-field', // event-version
        '', // test-version
        '', // source-version
        '', // source-vendor
        '' // json-data
        ]
      }
    });
  }
}

function emitFilterRequest(uri, value) {
  center.emit('filter-request', uri, value);
}

function persistFilterOnSessionStorage(uri, value) {
  uri = getOriginUri(uri) || uri;

  var key = STRING_FILTER_KEY + uri;
  var publish = {};
  publish[key] = value;
  live(SESSION_STORAGE).publish(publish);
}

function handleCancelClick(e) {
  clear(getURI(e.target));
}

function handleInputInput(e) {
  updateState(getURI(e.target), { enteredString: e.target.value });
}

function handleInputKeyup(e) {
  var isEscape = e.keyCode === 27;
  if (isEscape) clear(getURI(e.target));
}

function handleInputFocus(e) {
  updateState(getURI(e.target), { activated: true });
}
function handleInputFocusOut(e) {
  var state = getState(getURI(e.target));
  if (state.enteredString === '') updateState(getURI(e.target), { activated: false });
}

function clear(uri) {
  updateState(uri, { activated: false, enteredString: '' });
}

function getState(uri) {
  return states[uri] || {
    activated: false,
    enteredString: ''
  };
}

function updateState(uri, update) {
  states[uri] = merge(getState(uri), update);
  handleStale(uri);
}

function getURI(element) {
  var uri = element.getAttribute('data-uri');
  if (!uri) {
    var parents = $(element).parents('[data-uri]');
    if (parents) uri = parents[0].getAttribute('data-uri');
  }
  uri = getOriginUri(uri) || uri;

  // We use the data-uri as a key for state, but the uri of the
  // container might change to the "sorted" versions of the
  // original uri. From a filter UX state standpoint, these are the
  // same, so we normalize it here.
  return uri || null;
}

var states;
var lastEmittedStates;

var isAttached = false;
var controlMessageSubscription;
var attach = function attach() {
  if (isAttached) return;
  isAttached = true;
  states = {};
  lastEmittedStates = {};
  controlMessageSubscription = cosmos.subscribe({
    url: 'sp://messages/v1/container/control'
  }, function (_, response) {
    if (!appUtil.isActive()) return;

    var isMessageOfTypeFind = response && response.body && response.body.type === 'filter';
    if (!isMessageOfTypeFind) return;
    $('[data-filter]').forEach(function (mainElement, i) {
      updateState(getURI(mainElement), {
        activated: true
      });

      var inputElement = $(mainElement).find('input[type=text]')[0];
      if (inputElement) {

        // Only scroll first filter into view.
        if (i === 0) {
          scrollIntoView(inputElement);
        }

        focusAndSelectInput(inputElement);
      }
    });
  });

  center.on('filter-reset', clear);

  $(document).delegate('click', '[data-filter] .h-search-close', handleCancelClick);
  $(document).delegate('click', '[data-filter-reset]', handleCancelClick);
  $(document).delegate('input', '[data-filter] input', handleInputInput);
  $(document).delegate('keyup', '[data-filter] input', handleInputKeyup);
  $(document).delegate('focusin', '[data-filter] input', handleInputFocus);
  $(document).delegate('focusout', '[data-filter] input', handleInputFocusOut);
};

var detach = function detach() {
  if (!isAttached) return;
  states = null;
  controlMessageSubscription.cancel();

  center.off('filter-reset', clear);

  $(document).undelegate('click', '[data-filter] .h-search-close', handleCancelClick);
  $(document).undelegate('click', '[data-filter-reset]', handleCancelClick);
  $(document).undelegate('input', '[data-filter] input', handleInputInput);
  $(document).undelegate('keyup', '[data-filter] input', handleInputKeyup);
  $(document).undelegate('focusin', '[data-filter] input', handleInputFocus);
  $(document).undelegate('focusout', '[data-filter] input', handleInputFocusOut);
  isAttached = false;
};

// Tells native container that the current app can handle filter
// commands. Enables filter commands in the native menu,
// along with corresponding keyboard shortcuts.
var broadcast = function broadcast(enabled) {
  if (enabled === undefined) throw new Error('broadcast requires enabled argument');
  cosmos.post({
    url: 'sp://messages/v1/container/control',
    body: {
      type: 'update_menu_state',
      enable_filter_item: enabled
    }
  });
};

module.exports = {
  attach: attach,
  detach: detach,
  update: update,
  broadcast: broadcast
};

},{"../spotify-elements":70,"../spotify-live":251,"../spotify-live-wrapped-uri":250,"../spotify-shuffle-mode":290,"./center":77,"./sticky":120,"./util/app":127,"./util/cosmos":128,"mout/lang/deepEquals":373,"mout/object/merge":392}],90:[function(require,module,exports){
'use strict';

var modules = [require('./anchor'), require('./player'), require('./dragndrop'), require('./add'), require('./selection'), require('./contextmenu'), require('./navbar'), require('./offline'), require('./sticky'), require('./filter'), require('./watch'), require('./tooltip'), require('./list'), require('./menu'), require('./scroll'), require('./carousel'), require('./scrollbar'), require('./slider'), require('./select'), require('./sort'), require('./shuffle'), require('./thumbs'), require('./touch-mediaobjects'), require('./list-quick-jump')];

var events = {};

var isAttached = false;

events.update = function update(node) {
  if (!isAttached) return;

  modules.forEach(function (module) {
    module.update(node);
  });
};

events.attach = function attach() {
  if (isAttached) return;
  isAttached = true;

  modules.forEach(function (module) {
    module.attach();
  });
};

events.detach = function detach() {
  if (!isAttached) return;
  isAttached = false;

  modules.forEach(function (module) {
    module.detach();
  });
};

module.exports = events;

},{"./add":74,"./anchor":75,"./carousel":76,"./contextmenu":78,"./dragndrop":83,"./filter":89,"./list":92,"./list-quick-jump":91,"./menu":93,"./navbar":94,"./offline":95,"./player":97,"./scroll":102,"./scrollbar":107,"./select":110,"./selection":113,"./shuffle":117,"./slider":118,"./sort":119,"./sticky":120,"./thumbs":122,"./tooltip":123,"./touch-mediaobjects":124,"./watch":132}],91:[function(require,module,exports){
(function (global){
'use strict';

var center = require('./center');
var cosmos = require('./util/cosmos');
var ClientEvent3 = require('../spotify-logger/messages/ClientEvent3');

var SPACE_KEYCODE = 32;
var BACKSPACE_KEYCODE = 8;
var DELETE_KEYCODE = 46;

exports.attach = function attach() {
  document.addEventListener('keypress', onKeyPress, false);
  document.addEventListener('keydown', onKeyDown, false);
};

exports.detach = function detach() {
  document.removeEventListener('keypress', onKeyPress, false);
  document.removeEventListener('keydown', onKeyDown, false);
};

exports.update = function () {};

var selector = ':not([data-sticky-active]) > [data-list-quick-jump]';
var SEARCH_STRING_CONCATENATION_TIMEOUT = 1000;

var searchStringsByUri = {};
var searchTimeoutsByUri = {};
var searchTimestampsByUri = {};

// onKeyPress is needed to read characters properly
function onKeyPress(event) {
  if (shouldEventBeIgnored(event)) return;
  processEvent(event);
}

// onKeyDown is needed to read <backspace>
function onKeyDown(event) {
  if (shouldEventBeIgnored(event)) return;

  var isBackspace = event.keyCode === BACKSPACE_KEYCODE;

  if (!isBackspace) return;
  processEvent(event);
}

function processEvent(event) {
  var isBackspace = event.keyCode === BACKSPACE_KEYCODE;

  var letter = event.keyCode === SPACE_KEYCODE ? ' ' : String.fromCharCode(event.keyCode).trim();
  if (!letter && !isBackspace) return;

  var listNode = getListNode(event.target);
  if (!listNode) return;

  var uri = getUri(listNode);
  if (!uri) return;

  // No need to do anything if there is no active search and user presses
  // BACKSPACE, since that would temporarily disable using SPACE for toggling
  // music, even though no quick-jump was actually made (KM-10204)
  if (isBackspace && !searchStringsByUri[uri]) return;

  if (!(uri in searchStringsByUri)) searchStringsByUri[uri] = '';

  if (isBackspace) {
    searchStringsByUri[uri] = searchStringsByUri[uri].slice(0, -1);
  } else if (letter) {
    searchStringsByUri[uri] += letter;
  }

  center.emit('list-quick-jump-request', uri, searchStringsByUri[uri] || null);

  if (searchTimeoutsByUri[uri]) clearTimeout(searchTimeoutsByUri[uri]);

  if (event.keyCode === SPACE_KEYCODE) {
    event.preventDefault(); // Prevent space from scrolling page
  }

  var shortcutsToIgnore = [{ keyCode: SPACE_KEYCODE }, { keyCode: BACKSPACE_KEYCODE }, { keyCode: DELETE_KEYCODE }];

  // Tell container to ignore <space>, <backspace> and <delete> shortcuts
  // until further notice
  cosmos.post({
    url: 'sp://messages/v1/ignoreshortcuts',
    body: {
      action: 'ignore',
      shortcuts: shortcutsToIgnore
    }
  });

  searchTimeoutsByUri[uri] = setTimeout(function () {
    // Tell container to stop ignoring <space>, <backspace> and <delete>
    // shortcuts
    cosmos.post({
      url: 'sp://messages/v1/ignoreshortcuts',
      body: {
        action: 'unignore',
        shortcuts: shortcutsToIgnore
      }
    });

    delete searchStringsByUri[uri];
    delete searchTimeoutsByUri[uri];
    delete searchTimestampsByUri[uri];
    center.emit('list-quick-jump-request', uri, null);
  }, SEARCH_STRING_CONCATENATION_TIMEOUT);

  if (searchStringsByUri[uri].length <= 20) {
    var timeSinceLastLetter = Date.now() - searchTimestampsByUri[uri] || null;
    ClientEvent3.log({
      source: global.__spotify && global.__spotify.app_uri || null,
      context: uri,
      event_version: 'list-quick-jump',
      event: 'user:type',
      json_data: {
        str: searchStringsByUri[uri],
        letter: letter,
        was_backspace: isBackspace,
        time_since_last_letter: timeSinceLastLetter
      }
    });
  }

  searchTimestampsByUri[uri] = Date.now();
}

function shouldEventBeIgnored(event) {
  return event.metaKey || event.ctrlKey || event.target.matches('input, textarea, [contenteditable]');
}

function getListNode(target) {
  var listNode = target.closest(selector);
  if (!listNode) {
    var listNodes = document.querySelectorAll(selector);
    var hasOnlyOneListNode = listNodes && listNodes.length === 1;

    if (hasOnlyOneListNode) {
      listNode = listNodes[0];
    }
  }
  return listNode;
}

function getUri(listNode) {
  var uriParent = listNode.closest('[data-uri]');
  return uriParent && uriParent.getAttribute('data-uri');
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-logger/messages/ClientEvent3":260,"./center":77,"./util/cosmos":128}],92:[function(require,module,exports){
(function (global){
'use strict';

var $ = require('../spotify-elements');
var live = require('../spotify-live');
var center = require('./center');
var selection = require('./selection');
var cosmos = require('./util/cosmos');
var appUtil = require('./util/app');

var ROW_SELECTOR = '[data-list-item]';
var UNAVAILABLE_CLASS_NAME = 'unavailable';
var OFFLINE_DOWNLOADED_CLASS_NAME = 'offline-downloaded';
var OFFLINE_DOWNLOADING_CLASS_NAME = 'offline-downloading';
var OFFLINE_WAITING_CLASS_NAME = 'offline-waiting';

var storedTrackURIsForUnplayable = {};
var storedTrackURIsForOffline = {};

function updatePlayabilityForRows(uri, playable) {
  var rows = $(document).search(ROW_SELECTOR + '[data-uri="' + uri + '"]');
  if (rows) {
    updatePlayabilityForElements(rows, playable);
  }
}

function updatePlayabilityForElements(elements, playable) {
  if (playable) {
    elements.removeClass(UNAVAILABLE_CLASS_NAME);
  } else {
    elements.addClass(UNAVAILABLE_CLASS_NAME);
  }
}

function updateOfflineForRows(uri, shouldBeOffline, offlineProgress) {
  var rows = $(document).search(ROW_SELECTOR + '[data-uri="' + uri + '"]');
  if (rows) {

    // This will take an elements object as the first argument, so it can contain multiple rows
    updateOfflineForElements(rows, shouldBeOffline, offlineProgress);
  }
}

function updateOfflineForElements(elements, shouldBeOffline, offlineProgress) {

  // The track is either already downloaded or will be soon
  if (shouldBeOffline) {

    // Download done
    if (offlineProgress === 1) {
      elements.addClass(OFFLINE_DOWNLOADED_CLASS_NAME);
      elements.removeClass(OFFLINE_DOWNLOADING_CLASS_NAME);
      elements.removeClass(OFFLINE_WAITING_CLASS_NAME);

      // Waiting to be downloaded
    } else if (offlineProgress === 0) {
        elements.addClass(OFFLINE_WAITING_CLASS_NAME);
        elements.removeClass(OFFLINE_DOWNLOADED_CLASS_NAME);
        elements.removeClass(OFFLINE_DOWNLOADING_CLASS_NAME);

        // Downloading at the moment
      } else {
          elements.addClass(OFFLINE_DOWNLOADING_CLASS_NAME);
          elements.removeClass(OFFLINE_DOWNLOADED_CLASS_NAME);
          elements.removeClass(OFFLINE_WAITING_CLASS_NAME);
        }

    // The track is not supposed to be downloaded offline
  } else {
      elements.removeClass(OFFLINE_DOWNLOADED_CLASS_NAME);
      elements.removeClass(OFFLINE_DOWNLOADING_CLASS_NAME);
      elements.removeClass(OFFLINE_WAITING_CLASS_NAME);
    }
}

function updateUnplayableRows(node, opt_rows) {
  var rows = opt_rows || ($(node) || $(document)).search(ROW_SELECTOR);
  if (rows) {
    rows.forEach(function (row) {
      var uri = $(row).data('uri');

      var model = live(uri);
      var playable = model.get('playable');

      if (playable !== undefined) {
        updatePlayabilityForElements($(row), playable);
      }

      if (uri in storedTrackURIsForUnplayable) return;
      storedTrackURIsForUnplayable[uri] = true;

      model.on('update', function (properties) {
        if ('playable' in properties) {
          updatePlayabilityForRows(uri, properties.playable);
        }
      });
    });
  }
}

function updateOfflineSyncing(node, opt_rows) {
  var rows = opt_rows || ($(node) || $(document)).search(ROW_SELECTOR);
  if (rows) {
    rows.forEach(function (row) {
      var uri = $(row).data('uri');
      var model = live(uri);

      // Try to query the data sync if possible (live.ASAP), to try to set the
      // class names before adding the rows to the DOM (by the scroller), to
      // avoid flickering.
      model.query('shouldBeOffline, offlineProgress', function (error, data) {
        if (error) throw error;
        updateOfflineForElements($(row), data.shouldBeOffline, data.offlineProgress);

        if (uri in storedTrackURIsForOffline) return;
        storedTrackURIsForOffline[uri] = true;

        model.on('update', function (properties) {
          if ('shouldBeOffline' in properties || 'offlineProgress' in properties) {
            updateOfflineForRows(uri, model.get('shouldBeOffline'), model.get('offlineProgress'));
          }
        });
      }, live.ASAP);
    });
  }
}

function handleKeyDown(event) {
  if (!event.target.closest(ROW_SELECTOR) || ignoredShortcuts[JSON.stringify({ keyCode: event.keyCode })]) return;

  var shouldRemove = false;
  var isWindows = /Win/.test(global.window.navigator.userAgent);

  var isBackspace = event.keyCode === 8;
  var isDelete = event.keyCode === 46;

  if (isWindows) {
    shouldRemove = isDelete;
  } else {
    shouldRemove = isBackspace || isDelete;
  }

  if (shouldRemove) {
    removeCurrentlySelectedListItems();
  }
}

function removeCurrentlySelectedListItems() {
  var lists = selection.getIndicesPerList();
  if (lists.length > 0) {
    var firstContainerIndex = null;
    var firstIndex = null;
    lists.forEach(function (list) {
      // Delete from origin list where applicable
      // TODO: We could just remove from the list directly, without going
      // through the origin list. Removing from a sorted list will pass
      // the change on to the origin list automatically.
      if (list.origin) {
        list = list.origin;
      }
      var model = live(list.uri);

      var indices = list.indices.sort(function (a, b) {
        return a - b;
      });

      model.query('allows(removeTracks)', function (error, data) {
        if (error) throw error;
        if (!data.allows.removeTracks) return;

        model.get('rows', function (error, liveList) {
          if (error) throw error;
          var operations = indices.map(function (index, indexInArray) {
            return { type: 'remove', index: index - indexInArray, length: 1 };
          });
          liveList.publish(operations);

          if (firstIndex === null) {
            firstIndex = indices[0];
            firstContainerIndex = list.containerIndex;
          }
        });
      });
    });
  }
}

function handleScrollShow(data) {
  updateUnplayableRows(data.container, data.nodes);
  updateOfflineSyncing(data.container, data.nodes);
}

// Exported for testing
exports._classNames = {
  UNAVAILABLE: UNAVAILABLE_CLASS_NAME,
  OFFLINE_WAITING: OFFLINE_WAITING_CLASS_NAME,
  OFFLINE_DOWNLOADING: OFFLINE_DOWNLOADING_CLASS_NAME,
  OFFLINE_DOWNLOADED: OFFLINE_DOWNLOADED_CLASS_NAME
};

var isAttached = false;

exports.update = function update(node) {
  if (!isAttached) return;

  updateUnplayableRows(node);
  updateOfflineSyncing(node);
};

var doc = $(document);
var deleteSubscription;
var ignoredShortcutsSubscription;
var ignoredShortcuts = {};
exports.attach = function () {
  if (isAttached) return;
  isAttached = true;

  doc.on('keydown', handleKeyDown);
  center.on('scroll-show-before', handleScrollShow);

  deleteSubscription = cosmos.subscribe({ url: 'sp://messages/v1/container/control' }, function (error, response) {
    if (error) throw error;
    var data = response.body;
    if (data && data.type === 'delete' && appUtil.isActiveAndFocused()) {
      removeCurrentlySelectedListItems();
    }
  });

  ignoredShortcutsSubscription = cosmos.subscribe({
    url: 'sp://messages/v1/ignoreshortcuts'
  }, function (error, response) {
    if (response.body.action === 'ignore') {
      response.body.shortcuts.forEach(function (shortcut) {
        ignoredShortcuts[JSON.stringify(shortcut)] = 1;
      });
    } else if (response.body.action === 'unignore') {
      response.body.shortcuts.forEach(function (shortcut) {
        delete ignoredShortcuts[JSON.stringify(shortcut)];
      });
    }
  });
};
exports.detach = function () {
  if (!isAttached) return;
  isAttached = false;

  doc.off('keydown', handleKeyDown);
  center.off('scroll-show-before', handleScrollShow);

  if (deleteSubscription) {
    deleteSubscription.cancel();
    deleteSubscription = null;
  }
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-elements":70,"../spotify-live":251,"./center":77,"./selection":113,"./util/app":127,"./util/cosmos":128}],93:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.attach = attach;
exports.detach = detach;
exports.update = update;

var _throttle = require('./util/throttle');

var _throttle2 = _interopRequireDefault(_throttle);

var _center = require('./center');

var _center2 = _interopRequireDefault(_center);

var _spotifyNavigation = require('../spotify-navigation');

var _spotifyNavigation2 = _interopRequireDefault(_spotifyNavigation);

var _appState = require('../spotify-navigation/app-state');

var _appState2 = _interopRequireDefault(_appState);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SELECTOR_MENU = '[data-menu]';
var SELECTOR_MENU_ITEM = '[data-menu-item]';
var SELECTOR_MENU_ITEM_DISABLED = '[data-menu-item-disabled]';
var SELECTOR_MENU_ITEM_ENABLED = '[data-menu-item]:not([data-menu-item-disabled])';
var ATTRIBUTE_MENU = 'data-menu';
var ATTRIBUTE_MENU_ITEM = 'data-menu-item';
var CLASS_SUBMENU = '.dropdown-submenu';
var CLASS_MENU = '.dropdown-menu';

var navigator = new _spotifyNavigation2.default.Navigator();

var isAttached = false;

// The state will take the following shape (a nested structure that can be any
// number of levels deep):
// {
//   menu: { // null if root menu is not open
//     node: menuNode,
//     selectedNode: menuItemNode, // or null
//     menu: { // null if a sub menu is not open
//       node: subMenuNode,
//       selectedNode: subMenuItemNode, // or null,
//       menu: null, // null if a sub menu is not open
//       parent: <back-reference>, // a reference to the object one level up
//     },
//     parent: null, // always null for the root menu
//   }
// }
var state = {
  menu: null
};

/**
 * Handler for when an element gets focused.
 *
 * @param {FocusEvent} event A focus event.
 */
function onFocus(event) {
  var targetMenu = event.target.closest(SELECTOR_MENU);
  if (targetMenu && !state.menu) {
    state.menu = {
      node: targetMenu,
      selectedNode: null,
      menu: null,
      active: true,
      parent: null
    };

    targetMenu.addEventListener('mousemove', onMouseMoveThrottled);
    targetMenu.addEventListener('mouseleave', onMouseLeave);

    // We need to ensure that before triggering the "touchstart" event in the <LI> element
    // of the node, we emulate the mouse being moved over it. This way, the listeners are
    // attached and they will fire.
    // Note: this "mouseMove" call cannot be throttled, because the "touchstart" that will
    // trigger in the <LI> will happen before the throttler fires the event. Additionally,
    // there's no need to use the throttling logic for the touchstart event.
    targetMenu.addEventListener('touchstart', onMouseMove, true);
  }
}

/**
 * Handler for when an element loses focus.
 *
 * @param {FocusEvent} event A blur event.
 */
function onBlur(event) {
  var target = event.target;
  var relatedTarget = event.relatedTarget;


  if (state.menu && target === state.menu.node) {
    // A blur on the menu (target) can mean an element inside of it gains focus.
    // No need to reset then.
    if (!relatedTarget || !target.contains(relatedTarget)) {
      hideMenu();
    }
  }
}

/**
 * Handler for when a key is pressed.
 *
 * @param {KeyboardEvent} event A keyboard event.
 */
function onKeyDown(event) {
  // Only act on events when a menu is open
  if (!state.menu) {
    return;
  }

  var keyCode = event.keyCode;
  var isEnter = keyCode === 13;
  var isEscape = keyCode === 27;
  var isUp = keyCode === 38;
  var isDown = keyCode === 40;
  var isLeft = keyCode === 37;
  var isRight = keyCode === 39;

  if (isEnter) {
    // Look for links to follow inside the current menu item.
    var activeMenuState = getStateForActiveMenu();
    var selectedMenuItem = activeMenuState.selectedNode;
    var link = selectedMenuItem && selectedMenuItem.querySelector('a[href]');
    if (link) {
      navigator.requestOpenState(new _appState2.default(link.getAttribute('href')));
    }
    emitActivateItemEvent(selectedMenuItem);
    return;
  }

  if (isEscape) {
    hideMenu();
    return;
  }

  if (isUp || isDown) {
    var _activeMenuState = getStateForActiveMenu();
    if (_activeMenuState.node) {
      var newActiveMenuItem = isDown ? getMenuItemBelow(_activeMenuState) : getMenuItemAbove(_activeMenuState);

      if (newActiveMenuItem) {
        selectItemInMenu(_activeMenuState, _activeMenuState, newActiveMenuItem);
      }
    }
    return;
  }

  if (isRight) {
    var _activeMenuState2 = getStateForActiveMenu();
    if (_activeMenuState2.selectedNode) {
      if (_activeMenuState2.selectedNode.matches(CLASS_SUBMENU)) {

        // Open the sub menu if not open already (might have been opened by the
        // mouse cursor)
        if (!_activeMenuState2.menu) {
          openSubMenu(_activeMenuState2, _activeMenuState2.selectedNode);
        }

        // Select the first item in the sub menu
        var subMenuNode = _activeMenuState2.menu.node;
        var firstItemInSubMenu =
        // We'd like to get firstElementChild to avoid text nodes, but since
        // JSDom doesn't support that, fall back to firstChild for tests.
        subMenuNode.firstElementChild || subMenuNode.firstChild;
        selectItemInMenu(_activeMenuState2, _activeMenuState2.menu, firstItemInSubMenu);
      }
    }
    return;
  }

  if (isLeft) {
    var _activeMenuState3 = getStateForActiveMenu();
    if (_activeMenuState3.parent) {
      closeSubMenuOf(_activeMenuState3.parent);
    }
    return;
  }
}

/**
 * Handler for when the mouse is moved over a menu.
 * This is only attached for the current menu (if there is a current menu).
 *
 * @param {MouseEvent} event A mouse event.
 */
function onMouseMove(event) {
  var isMenu = event.target.matches(CLASS_MENU);
  if (isMenu) {
    return;
  }

  var targetItem = event.target.closest(SELECTOR_MENU_ITEM);
  if (!targetItem) {
    return;
  }

  var targetMenu = targetItem.closest(CLASS_MENU);
  var targetMenuState = getStateForMenu(targetMenu);
  var activeMenuState = getStateForActiveMenu();

  if (targetItem === activeMenuState.selectedNode) {
    return;
  }

  if (targetItem.matches(SELECTOR_MENU_ITEM_DISABLED)) {
    deselectItemInMenu(activeMenuState);
  } else {
    selectItemInMenu(activeMenuState, targetMenuState, targetItem);
    activeMenuState = getStateForActiveMenu();
  }

  // When hovering over an item that has a sub menu, open the sub menu if not
  // open already.
  if (targetItem.matches(CLASS_SUBMENU)) {
    if (!targetMenuState.menu) {
      openSubMenu(targetMenuState, targetItem);
    }

    // When hovering over a regular item and a sub menu is currently shown, close
    // the sub menu.
  } else if (activeMenuState.menu) {
      closeSubMenuOf(activeMenuState);
    }
}
var onMouseMoveThrottled = (0, _throttle2.default)(onMouseMove);

/**
 * Handler for when the mouse leaves a menu.
 * This is only attached for the current menu (if there is a current menu).
 *
 * @param {MouseEvent} event A mouse event.
 */
function onMouseLeave(event) {
  if (!event.relatedTarget || !event.relatedTarget.closest(SELECTOR_MENU)) {
    var activeMenuState = getStateForActiveMenu();
    deselectItemInMenu(activeMenuState);
    if (activeMenuState.menu) {
      closeSubMenuOf(activeMenuState);
    }
  }
}

/**
 * Handler for when the current menu item is clicked.
 * This is only attached for the current menu item (if there is one).
 *
 * @param {MouseEvent} event A mouse event.
 */
function onItemClick(event) {
  var targetMenu = event.target.closest(CLASS_MENU);
  var targetMenuState = getStateForMenu(targetMenu);
  var itemNode = targetMenuState.selectedNode;

  emitActivateItemEvent(itemNode);
}

/**
 * In order to prevent the simulated click event when using a touchscreen,
 * we prevent default so click won't trigger. That click event would otherwise
 * trigger a click on the layer beneath since the menu is closed after activating an item.
 *
 * @param {TouchEvent} event a Touch event.
 */
function onItemTouchStart(event) {
  event.preventDefault();
  onItemClick(event);
}

/**
 * Emit a center event to activate the current item.
 *
 * @param {HTMLElement} itemNode HTML element for the item.
 */
function emitActivateItemEvent(itemNode) {
  _center2.default.emit('menu-activate-item', {
    menu: {
      id: state.menu.node.getAttribute(ATTRIBUTE_MENU) || '',
      element: state.menu.node
    },
    item: {
      id: itemNode.getAttribute(ATTRIBUTE_MENU_ITEM) || '',
      element: itemNode
    }
  });
}

/**
 * Set the current menu item to a new item.
 *
 * @param {Object} activeMenuState Menu state object for the currently active
 *   menu.
 * @param {Object} targetMenuState Menu state object for the menu where the item
 *   that is to be selected is located.
 * @param {HTMLElement} itemNode An HTML element for the menu item.
 */
function selectItemInMenu(activeMenuState, targetMenuState, itemNode) {
  var isTargetSubMenu = activeMenuState.menu === targetMenuState;
  var isTargetParentMenu = isSecondContainedInFirst(targetMenuState, activeMenuState);

  // If the item is in a sub menu we only want to remove any item event
  // listeners. Removing visual selection should only happen when moving within
  // the same menu.
  if (isTargetSubMenu) {
    removeItemListeners(activeMenuState.selectedNode);
  } else {
    deselectItemInMenu(activeMenuState);
  }

  // Deselect the currently selected item in parent menu, if moving from sub
  // menu to the parent menu.
  if (isTargetParentMenu) {
    deselectItemInMenu(targetMenuState);
  }

  activeMenuState.active = false;

  if (targetMenuState.selectedNode !== itemNode) {
    itemNode.classList.add('selected');
    addItemListeners(itemNode);
    targetMenuState.selectedNode = itemNode;
  }

  targetMenuState.active = true;
}

/**
 * Deselect any selected item in the menu represented by the passed state.
 *
 * @param {Object} menuState The menu state object.
 */
function deselectItemInMenu(menuState) {
  if (menuState.selectedNode) {
    var itemNode = menuState.selectedNode;
    itemNode.classList.remove('selected');
    removeItemListeners(itemNode);
    menuState.selectedNode = null;
  }
}

/**
 * Add the click listeners from an item node.
 *
 * @param {HTMLElement} itemNode An HTML element for the menu item.
 */
function addItemListeners(itemNode) {
  itemNode.addEventListener('click', onItemClick);
  itemNode.addEventListener('touchstart', onItemTouchStart);
}

/**
 * Remove the click listeners from an item node.
 *
 * @param {HTMLElement} itemNode An HTML element for the menu item.
 */
function removeItemListeners(itemNode) {
  itemNode.removeEventListener('click', onItemClick);
  itemNode.removeEventListener('touchstart', onItemTouchStart);
}

/**
 * Open a sub menu for the provided menu state object and item node.
 *
 * @param {Object} menuState The menu state object for the parent menu.
 * @param {HTMLElement} itemNode An HTML element for the menu item.
 */
function openSubMenu(menuState, itemNode) {
  var menuNode = itemNode.querySelector(CLASS_MENU);
  if (menuNode) {
    menuState.menu = {
      parent: menuState,
      node: menuNode,
      selectedNode: null,
      menu: null,
      active: false
    };
    menuNode.classList.add('open');
  }
}

/**
 * Close all sub menus for the provided menu state object.
 *
 * @param {Object} menuState The menu state object for the parent menu.
 */
function closeSubMenuOf(menuState) {
  // Close deeper sub menus first
  if (menuState.menu.menu) {
    closeSubMenuOf(menuState.menu);
  }

  if (menuState.menu.active) {
    menuState.menu.active = false;
    menuState.active = true;
  }

  deselectItemInMenu(menuState.menu);
  menuState.menu.node.classList.remove('open');
  menuState.menu = null;
}

/**
 * Hide the current menu by broadcasting a message via center.
 * A listener can be added via center and the handler will then really hide it.
 *
 * @example
 * center.on('menu-hide', function(event) {
 *   if (event.menu.id === 'profile-menu') {
 *     hideProfileMenu();
 *   }
 * });
 */
function hideMenu() {
  if (state.menu) {
    var menuNode = state.menu.node;

    menuNode.removeEventListener('mousemove', onMouseMoveThrottled);
    menuNode.removeEventListener('mouseleave', onMouseLeave);
    menuNode.removeEventListener('touchstart', onMouseMove, true);

    // Remove any sub menus
    var menuState = state.menu;
    while (menuState) {
      deselectItemInMenu(menuState);
      menuState.node.classList.remove('open');
      menuState = menuState.menu;
    }

    delete state.menu;

    _center2.default.emit('menu-hide', {
      menu: {
        id: menuNode.getAttribute(ATTRIBUTE_MENU) || '',
        element: menuNode
      }
    });
  }
}

/**
 * Test if the second menu state object is contained in the second state object.
 *
 * @param {Object} first Menu state object.
 * @param {Object} second Menu state object.
 *
 * @return {Boolean}        True if it is.
 */
function isSecondContainedInFirst(first, second) {
  var statePart = first.menu;
  while (statePart && statePart !== second) {
    statePart = statePart.menu;
  }

  return !!statePart;
}

/**
 * Get the menu state object for the provided menu node. This assumes the node
 * is part of the state tree.
 *
 * @param {HTMLElement} menuNode The menu element.
 *
 * @return {Object} Menu state object.
 */
function getStateForMenu(menuNode) {
  var statePart = state.menu;
  while (statePart && statePart.node !== menuNode) {
    statePart = statePart.menu;
  }

  return statePart;
}

/**
 * Get the menu state object for the currently active menu.
 *
 * @return {Object} Menu state object.
 */
function getStateForActiveMenu() {
  var statePart = state.menu;
  while (statePart && !statePart.active) {
    statePart = statePart.menu;
  }

  return statePart;
}

/**
 * Find the menu item that is below the current one.
 * This will skip disabled menu items as well as any elements that are not
 * defined as menu items. If there is no menu item below the current one,
 * this will return null.
 *
 * @param {Object} activeMenuState Menu state object for the currently active
 *   menu.
 *
 * @return {HTMLElement?} The HTML element for the menu item, or null.
 */
function getMenuItemBelow(activeMenuState) {
  if (!activeMenuState.selectedNode) {
    return activeMenuState.node.querySelector(SELECTOR_MENU_ITEM_ENABLED);
  }

  var item = activeMenuState.selectedNode.nextElementSibling;
  while (item) {
    var isMenuItem = item.matches(SELECTOR_MENU_ITEM);
    var isDisabled = item.matches(SELECTOR_MENU_ITEM_DISABLED);
    if (isMenuItem && !isDisabled) {
      break;
    }
    item = item.nextElementSibling;
  }

  return item;
}

/**
 * Find the menu item that is above the current one.
 * This will skip disabled menu items as well as any elements that are not
 * defined as menu items. If there is no menu item above the current one,
 * this will return null.
 *
 * @param {Object} activeMenuState Menu state object for the currently active
 *   menu.
 *
 * @return {HTMLElement?} The HTML element for the menu item, or null.
 */
function getMenuItemAbove(activeMenuState) {
  if (!activeMenuState.selectedNode) {
    var results = activeMenuState.node.querySelectorAll(SELECTOR_MENU_ITEM_ENABLED);
    return results[results.length - 1] || null;
  }

  var item = activeMenuState.selectedNode.previousElementSibling;
  while (item) {
    var isMenuItem = item.matches(SELECTOR_MENU_ITEM);
    var isDisabled = item.matches(SELECTOR_MENU_ITEM_DISABLED);
    if (isMenuItem && !isDisabled) {
      break;
    }
    item = item.previousElementSibling;
  }

  return item;
}

/**
 * The spotify-events style attach function. Should be called once when DOM
 * is ready.
 */
function attach() {
  if (isAttached) return;
  isAttached = true;

  document.addEventListener('keydown', onKeyDown);

  // use capture to work around the non-bubbling events
  document.addEventListener('focus', onFocus, true);
  document.addEventListener('blur', onBlur, true);
}

/**
 * The spotify-events style detach function. Should be called when you no
 * longer need the events.
 */
function detach() {
  if (!isAttached) return;
  isAttached = false;

  state.menu = null;

  document.removeEventListener('keydown', onKeyDown);
  document.removeEventListener('focus', onFocus, true);
  document.removeEventListener('blur', onBlur, true);
}

/**
 * The spotify-events style update function. Should be called when DOM
 * changes.
 */
function update() {}

},{"../spotify-navigation":269,"../spotify-navigation/app-state":268,"./center":77,"./util/throttle":131}],94:[function(require,module,exports){
(function (global){
'use strict';

var $ = require('../spotify-elements');

var live = require('../spotify-live');
var center = require('./center');

var NAVBAR_ATTR_NAME = 'data-navbar';
var ITEM_ID_ATTR_NAME = 'data-navbar-item-id';
var ITEM_MATCHER_ATTR_NAME = 'data-navbar-item-matcher';
var VIEW_ID_ATTR_NAME = 'data-navbar-view-id';
var ACTIVE_ID_ATTR_NAME = 'data-navbar-active-id';
var HISTORY_POS_ATTR_NAME = 'data-navbar-history-position';
var CLASSNAME_ACTIVE = 'active';
var OVERFLOW_MENU_ID = 'navbar-overflow-menu';
var STICKY_WRAPPER_ATTR_NAME = 'data-sticky-fixed-wrapper';

var APPLICATION_MODEL_URI = 'spotify:application';

var isDesktop = !!global._getSpotifyModule;

var navbarOverflowItems;
var isShowingNavbarOverflow;
var shouldShowNavbarOverflow;

var getSelector = function getSelector(name, opt_operator, opt_matcher) {
  if (opt_operator && opt_matcher) return '[' + name + opt_operator + '"' + opt_matcher + '"' + ']';
  return '[' + name + ']';
};

var handleClick = function handleClick(event, tab) {
  var id = tab.getAttribute(ITEM_ID_ATTR_NAME);

  if (id === OVERFLOW_MENU_ID) {
    shouldShowNavbarOverflow = true;
    updateOverflowMenu();
    return;
  }

  activateItem(id);
  // Prevent any default click action (like link navigation)
  event.preventDefault();
};

var activateItem = function activateItem(id) {
  updateScrollPosition();

  var view = getView(id);
  var tabs = getTabsForId(id);

  // Set styles for navbar items and show/hide views
  setActive(id, tabs, view);
};

var onMessage = function onMessage(message) {
  if (message.data && message.data.name === 'navbar-overflow-click') {
    activateItem(message.data.itemId);
  }

  if (message.data && message.data.name === 'hide-navbar-overflow') {
    hideOverflow();
  }
};

var updateOverflowMenu = function updateOverflowMenu() {
  var moreMenuItem = document.querySelector('[data-navbar-item-id=navbar-overflow-menu]');
  if (!moreMenuItem) return;

  var canBeOpen = navbarOverflowItems && navbarOverflowItems.length;
  if (!canBeOpen) {
    shouldShowNavbarOverflow = false;
  }

  // There's no check for isShowingNavbarOverflow, the event is intentionally
  // resent on update, to support resizing.
  if (shouldShowNavbarOverflow) {
    isShowingNavbarOverflow = true;
    var descriptors = navbarOverflowItems.map(function (item) {
      var link = item.querySelector('a[href]');

      // The text is in the <a> element inside the item.
      return {
        name: item.firstElementChild && item.firstElementChild.textContent || '',
        id: item.getAttribute(ITEM_ID_ATTR_NAME),
        url: link && link.getAttribute('href'),
        active: item.classList.contains('active')
      };
    });

    var targetRect = moreMenuItem.getBoundingClientRect();
    global.top.postMessage({
      type: 'show-navbar-overflow',
      items: descriptors,
      right: targetRect.right,
      top: targetRect.bottom
    }, '*');
  }

  if (!shouldShowNavbarOverflow && isShowingNavbarOverflow) {
    isShowingNavbarOverflow = false;
    global.top.postMessage({
      type: 'hide-navbar-overflow'
    }, '*');
  }
};

var hideOverflow = function hideOverflow() {
  if (isShowingNavbarOverflow) {
    shouldShowNavbarOverflow = false;
    updateOverflowMenu();
  }
};

var getViews = function getViews() {
  var views = document.querySelectorAll(getSelector(VIEW_ID_ATTR_NAME));
  return Array.prototype.slice.call(views);
};

var getTabs = function getTabs() {
  var tabs = document.querySelectorAll(getSelector(ITEM_ID_ATTR_NAME));
  return Array.prototype.slice.call(tabs);
};

var getTabsForId = function getTabsForId(tabId) {
  if (!tabId) {
    return [];
  }
  // This is intentionally selecting on all of the document
  var tabs = document.querySelectorAll(getSelector(ITEM_ID_ATTR_NAME, '=', tabId));
  return Array.prototype.slice.call(tabs);
};

var getActiveTab = function getActiveTab() {
  var navbar = getNavbar();
  if (!navbar) return;
  var activeTabId = navbar.getAttribute(ACTIVE_ID_ATTR_NAME);
  var activeTabs = getTabsForId(activeTabId);
  return activeTabs[0];
};

var getView = function getView(id) {
  return document.querySelector(getSelector(VIEW_ID_ATTR_NAME, '=', id));
};

var getFirstTabId = function getFirstTabId() {
  var tab = document.querySelector(getSelector(ITEM_ID_ATTR_NAME));
  if (tab) {
    if (tab.getAttribute(ITEM_ID_ATTR_NAME) === OVERFLOW_MENU_ID) {
      return null;
    }
    return tab.getAttribute(ITEM_ID_ATTR_NAME);
  }
  return null;
};

var setActiveForMatchingId = function setActiveForMatchingId(ids) {
  // Off the list of passed ids, find the first one that matches a tab, then set
  // that one as active.
  var count = 0;
  var tabs;
  var id;
  while (count < ids.length && (!tabs || !tabs.length)) {
    if (ids[count]) {
      id = ids[count];
      tabs = getTabsForId(id);
    }
    count++;
  }
  var useID = id;

  if (!tabs || !tabs.length) {
    return;
  }
  var view = getView(useID);

  setActive(useID, tabs, view);
};

var setActive = function setActive(id, tabs, view) {
  var currentActiveTab = getActiveTab();
  var currentActiveId = currentActiveTab && currentActiveTab.getAttribute(ITEM_ID_ATTR_NAME);

  // Abort if the new tab is already active
  if (currentActiveId === id) return;

  setActiveTabs(id, tabs);
  setActiveView(id, view);

  center.emit('navbar-change', { id: id });
};

var setActiveTabs = function setActiveTabs(id, tabs) {
  var navbar = getNavbar();
  if (!navbar) return;

  navbar.setAttribute(ACTIVE_ID_ATTR_NAME, id);

  tabs.forEach(function (tab) {
    tab.classList.add(CLASSNAME_ACTIVE);
  });

  // Remove the active class name from all tabs except the ones that should be active
  var tabs = getTabs();
  if (tabs.length) {
    tabs.forEach(function (_tab) {
      if (_tab.getAttribute(ITEM_ID_ATTR_NAME) !== id) {
        _tab.classList.remove(CLASSNAME_ACTIVE);
      }
    });
  }
};

var setActiveView = function setActiveView(id, view) {
  if (!view) {
    return;
  }

  var views = getViews();

  // Hide all views except the one that should be active
  for (var i = 0, l = views.length; i < l; i++) {
    if (views[i] !== view[0]) {
      hide(views[i]);
    }
  }

  show(view);
};

var hide = function hide(element) {
  element.style.display = 'none';
};
var show = function show(element) {
  element.style.display = 'block';
};

var updateForNode = function updateForNode(node) {
  var navbar = getNavbar(node);
  if (!navbar) return;

  live(APPLICATION_MODEL_URI).query('appURI, arguments', function (error, data) {
    if (error) throw error;

    var uri = fixAppURI(data.appURI);
    var fullAppURI = uri;
    if (data.arguments) {
      fullAppURI += ':' + data.arguments;
    }
    var id = getIdFromMatchers(fullAppURI);

    if (id) {
      // This is only the case when matchers (ITEM_MATCHER_ATTR_NAME) are used in DOM.
      setActiveForMatchingId([id]);
    } else {
      // For cases where id is only to be matched from one argument, find the id to
      // highlight by looking at the argument at HISTORY_POS_ATTR_NAME.
      var argumentIndex = +navbar.getAttribute(HISTORY_POS_ATTR_NAME) || 0;
      var idAtArgumentIndex = data.arguments.split(':')[argumentIndex];

      // For cases where nothing matches, also pass the first tab ID. This is
      // how the first tab is highlighted by default.
      var firstTabId = getFirstTabId();

      setActiveForMatchingId([fullAppURI, idAtArgumentIndex, firstTabId]);
    }
  });
};

function updateForOverflow(node) {
  var navbar = getNavbar(node);
  if (!navbar) return;

  var itemSelector = '[data-navbar] > [data-navbar-item-id]:not(.overflow-menu-button)';
  var items = node.querySelectorAll(itemSelector);
  if (!items) return;

  items = Array.prototype.slice.call(items);

  var overflowMenuButton = navbar.querySelector('.overflow-menu-button');

  // If we have less than two items, only show the navbar and be done. We need
  // at least two items for messurement and chances are a "more" menu won't be
  // needed.
  if (items.length < 2) {
    navbar.style.visibility = 'visible';
    if (overflowMenuButton) overflowMenuButton.style.display = 'none';
    return;
  }

  var navbarWidth = getWidth(navbar);
  if (!navbarWidth) {
    // The navbar isn't rendered. Bail out.
    return;
  }

  // Reset to the initial rendering state to be able to measure items.
  if (overflowMenuButton) overflowMenuButton.style.display = 'inline';

  items.forEach(function (item, i) {
    item.style.display = 'block';
    item.classList.remove('last-visible');
  });

  var sizing = measureNavbar(items, overflowMenuButton);

  // If stuff doesn't completely fit, reduce the available space by the "more"
  // menu with, then calculate what needs to go in it.
  var availableSpace = navbarWidth;
  var firstOverflown = getFirstOverflownIndex(availableSpace, sizing.itemWidths);
  var needsMoreMenu = items.length !== firstOverflown;

  if (needsMoreMenu) {
    availableSpace -= sizing.overflowMenuButtonWidth;
    firstOverflown = getFirstOverflownIndex(availableSpace, sizing.itemWidths);
  }

  if (!navbarOverflowItems) {
    navbarOverflowItems = [];
  }
  navbarOverflowItems.length = 0;

  items.forEach(function (item, i) {
    var shouldBeInOverflow = i >= firstOverflown;
    if (shouldBeInOverflow) navbarOverflowItems.push(item);

    // If we don't draw an overflow menu, set the last-visible class on the
    // very last item so its margin-right is removed.
    var isLastInNotOverflown = !needsMoreMenu && i === items.length - 1;

    item.style.display = shouldBeInOverflow ? 'none' : 'block';
    item.classList.toggle('last-visible', isLastInNotOverflown);
  });

  if (overflowMenuButton) {
    overflowMenuButton.style.display = needsMoreMenu ? 'inline' : 'none';
  }

  // Update items and position, possibly close the menu
  updateOverflowMenu();
  navbar.style.visibility = 'visible';
}

function updateScrollPosition() {
  var scrollTop = window.pageYOffset;
  var stickyElements = Array.prototype.slice.call(document.querySelectorAll('[' + STICKY_WRAPPER_ATTR_NAME + ']'));

  if (stickyElements.length === 0) return;

  // Get the `top` value of a sticky element that is
  // in a fixed position (negative value)
  // and the closest to the top (smallest top value).
  var topTarget = stickyElements.reduce(function (res, el) {
    var top = el.getBoundingClientRect().top;
    return top < res ? top : res;
  }, 0);

  if (topTarget < 0) {
    // Add 1 px to have the sticky element in fixed position.
    window.scrollTo(0, topTarget + scrollTop + 1);
  }
}

function handleResize() {
  updateForOverflow(document.body);
}

function measureNavbar(items, overflowMenuButton) {
  // Find out what the margin per item is my messuring beween the first 2 items.
  var item1 = items[0];
  var item2 = items[1];

  var right1 = Math.floor(item1.getBoundingClientRect().right);
  var left2 = Math.floor(item2.getBoundingClientRect().left);
  var marginPerSide = (left2 - right1) / 2;

  var itemWidths = [];
  if (items) {
    itemWidths = items.map(function (item, i, all) {
      var marginLeft = i === 0 ? 0 : marginPerSide;
      var marginRight = i === all.length - 1 ? 0 : marginPerSide;
      return getWidth(item) + marginLeft + marginRight;
    });
  }

  // When the overflowMenuButton is showns, it's always at the end, so it has
  // no right margin.
  var overflowMenuButtonWidth = 0;
  if (overflowMenuButton) {
    overflowMenuButtonWidth = getWidth(overflowMenuButton) + marginPerSide;
  }

  return {
    itemWidths: itemWidths,
    overflowMenuButtonWidth: overflowMenuButtonWidth
  };
}

function getWidth(element) {
  return element && element.offsetWidth || 0;
}

function getFirstOverflownIndex(space, sizes) {
  var count = 0;
  var used = 0;
  while (sizes[count] !== undefined && used < space) {
    used += sizes[count];
    // This is actually expected to return up to .length of the sizes.
    // That will be the case when everything fits.
    count++;
  }
  if (used < space) return count;
  return count - 1;
}

// Hack to get around bridge bug (reported at WP-471) where WP reports
// the uri with the arguments as well.
var fixAppURI = function fixAppURI(uri) {
  return uri.split(':').slice(0, 3).join(':');
};

// Matchers allow you to tell a tab to be active for a pattern of the app arguments.
// If you define data-navbar-item-matcher="user:.*?:playlist:.*$" you tell the tab
// to be active when the arguments match that regexp.
var storedMatchers = {};
var getMatchers = function getMatchers(node) {
  var matchers = node.querySelectorAll(getSelector(ITEM_MATCHER_ATTR_NAME));
  if (!matchers.length) return;

  matchers = Array.prototype.slice.call(matchers);
  matchers.forEach(function (matcher) {
    var regexp = matcher.getAttribute(ITEM_MATCHER_ATTR_NAME);
    var id = matcher.getAttribute(ITEM_ID_ATTR_NAME);
    storedMatchers[regexp] = id;
  });
};

var getIdFromMatchers = function getIdFromMatchers(uri) {
  for (var regexp in storedMatchers) {
    if (storedMatchers.hasOwnProperty(regexp)) {
      var regexpObj = new RegExp(regexp);
      if (regexpObj.test(uri)) return storedMatchers[regexp];
    }
  }
  return null;
};

var getNavbar = function getNavbar(opt_node) {
  var node = opt_node || document.documentElement;
  var selector = getSelector(NAVBAR_ATTR_NAME);
  return node.matches(selector) ? node : node.querySelector(selector);
};

var onApplicationChange = function onApplicationChange(event) {
  if ('arguments' in event || 'active' in event) {
    updateForNode(document.documentElement);
  }
};

var isAttached = false;

exports.update = function update(node) {
  if (!isAttached) return;

  updateForNode(node || document.documentElement);
  getMatchers(node || document.documentElement);
  updateForOverflow(node || document.documentElement);
};

exports.attach = function attach() {
  if (isAttached) return;
  isAttached = true;

  $(document).delegate('click', getSelector(ITEM_ID_ATTR_NAME), handleClick);
  window.addEventListener('message', onMessage);
  live(APPLICATION_MODEL_URI).on('update', onApplicationChange);
  window.addEventListener('resize', handleResize);
  center.on('navbar-hide', hideOverflow);
};

exports.detach = function detach() {
  if (!isAttached) return;
  isAttached = false;

  navbarOverflowItems = null;
  isShowingNavbarOverflow = false;
  shouldShowNavbarOverflow = false;

  $(document).undelegate('click', getSelector(ITEM_ID_ATTR_NAME), handleClick);
  window.removeEventListener('message', onMessage);
  live(APPLICATION_MODEL_URI).off('update', onApplicationChange);
  window.removeEventListener('resize', handleResize);
  center.off('navbar-hide', hideOverflow);
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-elements":70,"../spotify-live":251,"./center":77}],95:[function(require,module,exports){
'use strict';

var $ = require('../spotify-elements');
var live = require('../spotify-live');

var sessionModel;

function onSessionUpdate(properties) {
  if ('online' in properties) {
    if (properties.online) {
      $(document.body).removeClass('offline');
    } else {
      $(document.body).addClass('offline');
    }
  }
}

function updateWithSessionValue() {
  live('spotify:client').query('session(online)', function (error, data) {
    if (error) throw error;
    onSessionUpdate({ online: data.session.online });
  });
}

var isAttached = false;

exports.update = function () {
  if (!isAttached) return;

  updateWithSessionValue();
};

exports.attach = function () {
  if (isAttached) return;
  isAttached = true;

  if (!sessionModel) {
    live('spotify:client').get('session', function (error, session) {
      if (error) throw error;
      sessionModel = session;
      sessionModel.on('update', onSessionUpdate);
    });
  }
};

exports.detach = function () {
  if (!isAttached) return;
  isAttached = false;

  if (sessionModel) {
    sessionModel.off('update', onSessionUpdate);
    sessionModel = null;
  }
};

},{"../spotify-elements":70,"../spotify-live":251}],96:[function(require,module,exports){
'use strict';

/**
 * @private
 */

// [SHUFFLE] Used only for showing the message bar when trying to play a track.
var shuffleMode = require('../../spotify-shuffle-mode');
var cosmos = require('spotify-cosmos-api');

var $ = require('../../spotify-elements');
var utils = require('./utils');

var SELECTOR_LIST_ROW = '[data-context] [data-list-item]';
var SELECTOR_PLAY_BUTTON = '[data-button=play]';
var SELECTOR_PLAY_CONTEXT_BUTTON = '[data-button=play-context]';

// This array will store event types for touch handling
var lastEventTypes = [];

// Methods that need implementation from another module.
// This is to support generic handling of user actions from within this module,
// but allow further checks and actions to be performed by another module. This
// allows multiple different implementations of starting playback for example.
var methods = {
  getPlayerVariantUri: utils.createEmptyMethod('getPlayerVariantUri'),
  handlePlayButton: utils.createEmptyMethod('handlePlayButton'),
  handlePlayFromRow: utils.createEmptyMethod('handlePlayFromRow')
};

/**
 * Handle the click of a play button.
 *
 * @param {MouseEvent} event An event object for a click event.
 * @param {Elements} button An element instance from the `elements` package.
 *
 * @private
 */
function handlePlayButtonClick(event, button) {
  var buttonNode = button[0];
  var buttonContextUri = utils.getUriFromButton(buttonNode);

  // We need an associated context URI for the button
  if (!buttonContextUri) {
    return;
  }

  // [SHUFFLE]: track buttons do not work.
  if (shuffleMode.isEnabled() && /^spotify:track:/.test(buttonContextUri)) {
    cosmos.resolver.post({
      url: 'sp://messages/v1/container/user-message',
      body: {
        description: 'Track cannot be played because "shuffle mode" is enabled',
        id: 'shuffle-unplayable-track'
      }
    }, function () {
      // We don't care about reply, if it fails we can't do pretty much anything
    });

    return;
  }

  var playerContextUri = methods.getPlayerVariantUri();
  var isPlayingContext = utils.compareContexts(playerContextUri, buttonContextUri);

  var source = utils.getAttributeValueFromNode(buttonNode, 'data-play-source');

  methods.handlePlayButton(buttonNode, {
    isPlayingContext: isPlayingContext,
    contextUri: buttonContextUri,
    source: source,
    reason: 'playbtn'
  });
}

/**
 * Handle the double click or tap of a list row to start playback.
 *
 * @param {Elements} row An element instance from the `elements` package.
 *
 * @private
 */
function handleListRow(row) {
  var contextNode = row.parent('[data-context]');
  if (contextNode) {
    var rowNode = row[0];
    var source = utils.getAttributeValueFromNode(rowNode, 'data-play-source');
    methods.handlePlayFromRow(rowNode, {
      contextUri: contextNode.data('uri'),
      source: source,
      reason: 'clickrow'
    });
  }
}

/**
 * Handle double clicking on a list row to start playback.
 *
 * @param {MouseEvent} event An event object for a double click.
 * @param {Elements} row An element instance from the `elements` package.
 *
 * @private
 */
function handleRowDoubleClick(event, row) {
  // Only play when not clicking on interactive elements such as buttons
  if (!utils.isInteractiveElement(event.target)) {
    handleListRow(row);
  }
}

/**
 * Handle a key press on a list row.
 * This will take care of starting playback when pressing Enter.
 *
 * @param {KeyboardEvent} event A keyboard event.
 * @param {Elements} row An element instance from the `elements` package.
 *
 * @private
 */
function handleRowKeyDown(event, row) {
  var isEnter = event.keyCode === 13;
  if (isEnter) {
    if (utils.isFormOrLinkElement(event.target)) {
      return;
    }

    event.preventDefault();
    event.stopPropagation();

    handleListRow(row);
  }
}

/**
 * Handle the 'contextmenu' event. This is only for touch handling.
 * This is needed since we use a custom context menu in Spotify, and the handler
 * for that calls `preventDefault` for the 'contextmenu' event, which means the
 * rest of the touch handling will go on as usual. So as we don't get the
 * 'touchcancel' event, we need to catch the 'contextmenu' event here to know
 * that we should not act on the following 'touchend' event.
 *
 * @param {MouseEvent} event A 'contextmenu' event.
 *
 * @private
 */
function handleContextMenu(event) {
  lastEventTypes.push(event.type);
}

/**
 * Handle the start of a touch. Used to detect a tap.
 *
 * @param {TouchEvent} event A touch event.
 *
 * @private
 */
function handleRowTouchStart(event) {
  lastEventTypes.push(event.type);
}

/**
 * Handle the move of a touch. Used to abort detection of a tap.
 *
 * @param {TouchEvent} event A touch event.
 *
 * @private
 */
function handleRowTouchMove(event) {
  lastEventTypes.push(event.type);
}

/**
 * Handle the end of a touch. Used to detect a tap and start playback of a row.
 *
 * @param {TouchEvent} event A touch event.
 * @param {Elements} row An element instance from the `elements` package.
 *
 * @private
 */
function handleRowTouchEnd(event, row) {
  // If this was a tap (only touchstart was triggered before this)
  if (lastEventTypes.length === 1 && lastEventTypes[0] === 'touchstart') {

    // Prevent the simulated mouse events (including click). This is to
    // avoid the simulated click event to click on the play button that
    // appears when selecting a row on touchstart.
    // See: https://jira.spotify.net/browse/KM-7983
    if (!utils.isInteractiveElement(event.target)) {
      event.preventDefault();

      // Tapping on a row should play it
      handleListRow(row);
    }
  }
  lastEventTypes = [];
}

/**
 * Attach the needed event listeners for the module.
 */
exports.attach = function () {
  var doc = $(document);

  doc.delegate('keydown', SELECTOR_LIST_ROW, handleRowKeyDown);
  doc.delegate('click', SELECTOR_PLAY_BUTTON, handlePlayButtonClick);
  doc.delegate('click', SELECTOR_PLAY_CONTEXT_BUTTON, handlePlayButtonClick);
  doc.delegate('dblclick', SELECTOR_LIST_ROW, handleRowDoubleClick);

  /* For touch handling */
  doc.delegate('touchstart', SELECTOR_LIST_ROW, handleRowTouchStart);
  doc.delegate('touchend', SELECTOR_LIST_ROW, handleRowTouchEnd);
  doc.delegate('touchmove', SELECTOR_LIST_ROW, handleRowTouchMove);
  doc.delegate('contextmenu', SELECTOR_LIST_ROW, handleContextMenu);
};

/**
 * Detach the event listeners for the module.
 */
exports.detach = function () {
  var doc = $(document);

  doc.undelegate('keydown', SELECTOR_LIST_ROW, handleRowKeyDown);
  doc.undelegate('click', SELECTOR_PLAY_BUTTON, handlePlayButtonClick);
  doc.undelegate('click', SELECTOR_PLAY_CONTEXT_BUTTON, handlePlayButtonClick);
  doc.undelegate('dblclick', SELECTOR_LIST_ROW, handleRowDoubleClick);

  /* For touch handling */
  doc.undelegate('touchstart', SELECTOR_LIST_ROW, handleRowTouchStart);
  doc.undelegate('touchend', SELECTOR_LIST_ROW, handleRowTouchEnd);
  doc.undelegate('touchmove', SELECTOR_LIST_ROW, handleRowTouchMove);
  doc.undelegate('contextmenu', SELECTOR_LIST_ROW, handleContextMenu);
};

/**
 * Set the external methods for this module to add implementations for starting
 * playback etc.
 *
 * @param {Object} methodDefinitions Object where keys are method names and
 *     values are functions.
 */
exports.setMethods = function (methodDefinitions) {
  for (var name in methodDefinitions) {
    if (methodDefinitions.hasOwnProperty(name)) {
      methods[name] = methodDefinitions[name];
    }
  }
};

},{"../../spotify-elements":70,"../../spotify-shuffle-mode":290,"./utils":99,"spotify-cosmos-api":416}],97:[function(require,module,exports){
'use strict';

var playerWithIndices = require('./withIndices');
var playerWithUids = require('./withUids');

var playerModule = playerWithIndices;

exports.setMode = function (type) {
  switch (type) {
    case 'indices':
      playerModule = playerWithIndices;
      break;
    case 'uids':
      playerModule = playerWithUids;
      break;
  }
};

exports.attach = function () {
  playerModule.attach();
};

exports.detach = function () {
  playerModule.detach();
};

exports.update = function (optNode) {
  playerModule.update(optNode);
};

},{"./withIndices":100,"./withUids":101}],98:[function(require,module,exports){
'use strict';

/**
 * @private
 */

var difference = require('mout/array/difference');
var $ = require('../../spotify-elements');
var live = require('../../spotify-live');

var center = require('../center');
var utils = require('./utils');

var CURRENT = 'current';
var PAUSED = 'paused';
var PLAYING = 'playing';

var LOG_PLAY_BUTTON = 'play-button';
var LOG_PAUSE_BUTTON = 'pause-button';

var SELECTOR_PLAY_BUTTON = '[data-button=play]';
var SELECTOR_PLAY_CONTEXT_BUTTON = '[data-button=play-context]';
var SELECTOR_ALL_PLAY_BUTTONS = SELECTOR_PLAY_BUTTON + ',' + SELECTOR_PLAY_CONTEXT_BUTTON;

// Methods that need implementation from another module.
// This is to support generic handling of DOM updates from within this module,
// but allow further checks and actions to be performed by another module. This
// allows multiple different implementations of highlighting playing objects.
var methods = {
  getPlayerVariantUri: utils.createEmptyMethod('getPlayerVariantUri'),
  getPlayerIsPlaying: utils.createEmptyMethod('getPlayerIsPlaying'),
  getPlayingNodes: utils.createEmptyMethod('getPlayingNodes'),

  // This should be a function that takes a function as the first argument. That
  // function argument should be called whenever the player state has changed.
  subscribeToPlayerChange: utils.createEmptyMethod('subscribeToPlayerChange')
};

var playableChangeHandlers = {};
var playerSubscription = null;

/**
 * Update states in the DOM based on current player state.
 *
 * @param {HTMLElement=} node An optional DOM node. If passed, only nodes inside
 *     of that node will be updated.
 */
function updateDOM(optNode) {
  var containerNode = optNode || document;

  updateButtonsBasedOnPlayable(containerNode);

  var playingNodes = getPlayingNodes(containerNode);
  var currentNodes = getCurrentNodes(containerNode);

  if (currentNodes) {
    var nodesForRemoval = currentNodes;
    if (playingNodes) {
      nodesForRemoval = difference(currentNodes, playingNodes);
    }
    nodesForRemoval.forEach(removePlayingStateFromNode);
  }

  if (playingNodes) {
    var nodesForAddition = playingNodes;
    if (currentNodes) {
      nodesForAddition = difference(playingNodes, currentNodes);
    }
    nodesForAddition.forEach(addPlayingStateToNode);

    var nodesForUpdate = difference(playingNodes, nodesForAddition);
    nodesForUpdate.forEach(updatePlayingStateForNode);
  }
}

/**
 * Update the playable status of all play buttons found inside the passed
 * container node.
 *
 * @param {HTMLElement} containerNode A DOM node to search for nodes inside.
 *
 * @private
 */
function updateButtonsBasedOnPlayable(containerNode) {
  // `[data-button=play]` buttons are used to play something specific *in* a
  // context (defining an index as a track number or uid/uri or range).
  // Those are currently not updated themselves, instead their rows are being
  // set to `.unavailable`.
  var buttons = $(containerNode).search('[data-button=play-context]');
  if (buttons) {
    buttons.forEach(updateButtonBasedOnPlayable);
  }
}

/**
 * Update the playable status of the passed button.
 *
 * @param {HTMLElement} button A button DOM node.
 *
 * @private
 */
function updateButtonBasedOnPlayable(button) {

  // Play buttons in list rows should not be handled, as the buttons are
  // hidden by CSS anyway for unplayable rows.
  if (!!$(button).parent('[data-list-item]')) {
    return;
  }

  var contextURI = utils.getUriFromButton(button);

  // Check if the context has a playable flag specified.
  var playableValue = live(contextURI).get('playable');
  var definesPlayable = playableValue != undefined;

  // If it does, update the `disabled` attribute based on it
  if (definesPlayable) {
    if (playableValue) {
      button.removeAttribute('disabled');
    } else {
      button.setAttribute('disabled', 'disabled');
    }

    if (!playableChangeHandlers[contextURI]) {
      playableChangeHandlers[contextURI] = function (changed) {
        if (!changed.hasOwnProperty('playable')) return;
        // Update all buttons currently in DOM when `playable` changes on a
        // context. Not worth adding logic to only pick out buttons pointing to
        // a specific URI.
        updateButtonsBasedOnPlayable(document.body);
      };
      live(contextURI).on('update', playableChangeHandlers[contextURI]);
    }
  }
}

/**
 * Get the nodes inside the passed container node that are currently marked as
 * playing.
 *
 * @param {HTMLElement} containerNode A DOM node to search for nodes inside.
 *
 * @return {?Elements} An element instance from the `elements` package, or null.
 *
 * @private
 */
function getCurrentNodes(containerNode) {
  return $(containerNode).search('[data-playback-active=true]');
}

/**
 * Get the nodes inside the passed container node that should be marked as
 * playing based on the current player state.
 *
 * @param {HTMLElement} containerNode A DOM node to search for nodes inside.
 *
 * @return {?Elements} An element instance from the `elements` package, or null.
 *
 * @private
 */
function getPlayingNodes(containerNode) {
  var variantUri = methods.getPlayerVariantUri();
  var selectors = utils.getContextSelectorsWithVariants(variantUri);

  var contextNodes = $(containerNode).search(selectors.join(', '));
  if (contextNodes) {
    contextNodes = Array.prototype.slice.call(contextNodes);
  } else {
    contextNodes = [];
  }

  // Pass it through the outside implementation, which might filter out
  // nodes from `contextNodes` and add more nodes to the match.
  return methods.getPlayingNodes(containerNode, contextNodes);
}

/**
 * Remove the playing state from the passed DOM node, as it's no longer playing.
 *
 * @param {HTMLElement} node The DOM node to remove state from.
 *
 * @private
 */
function removePlayingStateFromNode(node) {
  var className = [CURRENT, PAUSED, PLAYING].join(' ');
  node = $(node);
  node.removeClass(className).removeAttribute('data-playback-active');

  if (node.matches(SELECTOR_ALL_PLAY_BUTTONS)) {
    node.attribute('data-log-click', LOG_PLAY_BUTTON);
  }
}

/**
 * Add the playing state to the passed DOM node, as it's now playing.
 *
 * @param {HTMLElement} node The DOM node to add state to.
 *
 * @private
 */
function addPlayingStateToNode(node) {
  var isPlaying = methods.getPlayerIsPlaying();

  var classNames = [CURRENT, isPlaying ? PLAYING : PAUSED].join(' ');

  node = $(node);
  node.addClass(classNames).data('playback-active', true);

  if (node.matches(SELECTOR_ALL_PLAY_BUTTONS)) {
    node.attribute('data-log-click', isPlaying ? LOG_PAUSE_BUTTON : LOG_PLAY_BUTTON);
  }
}

/**
 * Update the playing state for the passed DOM node, as it's still representing
 * the currently playing context, but the player might switch between
 * playing/paused.
 *
 * @param {HTMLElement} node The DOM node to update state for.
 *
 * @private
 */
function updatePlayingStateForNode(node) {
  var isPlaying = methods.getPlayerIsPlaying();

  var currentClassName = isPlaying ? PAUSED : PLAYING;
  var newClassName = isPlaying ? PLAYING : PAUSED;
  var element = $(node);

  if (element.hasClass(currentClassName)) {
    element.removeClass(currentClassName);
  }

  if (!element.hasClass(newClassName)) {
    element.addClass(newClassName);
  }

  if (element.matches(SELECTOR_ALL_PLAY_BUTTONS)) {
    element.attribute('data-log-click', isPlaying ? LOG_PAUSE_BUTTON : LOG_PLAY_BUTTON);
  }
}

/**
 * Handle updating of DOM nodes when they have been added to the DOM by a scroll
 * agent.
 *
 * @param {Object} event Custom event object sent from the scroll agent. Should
 *     contain a `container` property pointing to the DOM node containing the
 *     rows.
 *
 * @private
 */
function handleScrollShowAfter(event) {
  var container = $(event.container);
  var contextNode = null;
  if (container.matches('[data-context]')) {
    contextNode = container;
  } else {
    contextNode = container.parent('[data-context]');
  }

  // We can't pass the context node itself as root because of how the playing
  // state queries are set up.
  var contextParent = contextNode && contextNode[0].parentElement || document;

  updateDOM(contextParent);
}

/**
 * Attach the needed event listeners for the module.
 */
exports.attach = function () {
  playerSubscription = methods.subscribeToPlayerChange(function () {
    updateDOM();
  });

  center.on('scroll-show-after', handleScrollShowAfter);
};

/**
 * Detach the needed event listeners for the module.
 */
exports.detach = function () {
  if (playerSubscription) {
    playerSubscription.cancel();
    playerSubscription = null;
  }

  for (var contextUri in playableChangeHandlers) {
    if (playableChangeHandlers.hasOwnProperty(contextUri)) {
      live(contextUri).off('update', playableChangeHandlers[contextUri]);
    }
  }
  playableChangeHandlers = {};

  center.off('scroll-show-after', handleScrollShowAfter);
};

/**
 * Update things in the DOM.
 */
exports.update = updateDOM;

/**
 * Set the external methods for this module to add implementations for methods
 * needed for highlighting playing objects.
 *
 * @param {Object} methodDefinitions Object where keys are method names and
 *     values are functions.
 */
exports.setMethods = function (methodDefinitions) {
  for (var name in methodDefinitions) {
    if (methodDefinitions.hasOwnProperty(name)) {
      methods[name] = methodDefinitions[name];
    }
  }
};

},{"../../spotify-elements":70,"../../spotify-live":251,"../center":77,"./utils":99,"mout/array/difference":350}],99:[function(require,module,exports){
(function (global){
'use strict';

/**
 * This module might be used by modules outside of spotify-events.
 * @public
 */

var liburi = require('spotify-liburi');
var $ = require('../../spotify-elements');

var getOriginUri = require('../../spotify-live-wrapped-uri').getOriginUri;

/**
 * Get the context URI from a button node or its parents.
 *
 * @param {HTMLElement} button A DOM node for a button.
 *
 * @return {string} The context URI or empty string if not found.
 */
function getUriFromButton(button) {
  var contextNode = button.closest('[data-context]');
  return contextNode && contextNode.getAttribute('data-uri') || '';
}

/**
 * Get the value for the passed attribute name, either from the passed node or
 * from any parent node.
 *
 * @param {HTMLElement} node The node to start searching from.
 * @param {string} attributeName The name of the attribute.
 *
 * @return {string} The value, or empty string if not found.
 */
function getAttributeValueFromNode(node, attributeName) {
  var selector = '[' + attributeName + ']';
  var attributeNode = node.closest(selector);
  return attributeNode && attributeNode.getAttribute(attributeName) || '';
}

/**
 * Check if the passed element is a form or link element.
 *
 * @param {HTMLElement} element A DOM node.
 *
 * @return {boolean} True if it is a form or link element.
 */
function isFormOrLinkElement(element) {
  var tagName = element.tagName.toLowerCase();
  var elements = ['input', 'textarea', 'button', 'select', 'optgroup', 'option', 'a'];
  return elements.indexOf(tagName) > -1;
}

/**
 * Check if the passed element is an interactive element (links, buttons).
 *
 * @param {HTMLElement}  element A DOM node.
 *
 * @return {boolean} True if the element is interactive.
 */
function isInteractiveElement(element) {
  var tagName = element.tagName.toLowerCase();
  return tagName === 'a' || tagName === 'button';
}

/**
 * Get a CSS selector string for a context.
 *
 * @param {string} operator A CSS selector operator ($= or similar).
 * @param {string} uri The context URI.
 *
 * @return {string} The CSS selector string.
 */
function getContextSelector(operator, uri) {
  return '[data-context][data-uri' + operator + uri + ']';
}

/**
 * Get an array of CSS selectors for searching for context nodes inside the DOM.
 *
 * @param {string} uri The context URI to search for. This should be the
 *     currently playing variant URI (for example, when playing a sorted
 *     playlist the sorted URI should be passed).
 *
 * @return {Array.<string>} Array of CSS selector strings.
 */
function getContextSelectors(uri) {
  var ENDSWITH = '$=';
  var SAME = '=';

  var selectors = [getContextSelector(SAME, uri)];

  var normalized = normalizeUri(uri);
  if (uri !== normalized) {
    selectors.push(getContextSelector(SAME, normalized));
  }

  return selectors;
}

/**
 * Get an array of CSS selectors for searching for context nodes inside the DOM.
 * This also includes any variant of the passed context URI. For example, if
 * passing a sorted playlist URI, it will return selectors for matching all
 * variations of that playlist URI, including the regular playlist URI, filtered
 * URI etc.
 *
 * @param {string} uri The context URI to search for. This can be either the
 *     origin URI, or any variant URI. The function will convert it to the
 *     origin URI automatically.
 *
 * @return {Array.<string>} Array of CSS selector strings.
 */
function getContextSelectorsWithVariants(uri) {
  var ENDSWITH = '$=';
  var SAME = '=';

  // Only add the ENDSWITH selectors. Those also match the original.
  // When it's a sorted and/or filtered list, just use the origin.
  var endsWith = getOriginUri(uri) || uri;
  var endsWithNormalized = normalizeUri(endsWith);

  var selectors = [getContextSelector(ENDSWITH, endsWith.replace(/^spotify:/, ':'))];

  if (endsWith !== endsWithNormalized) {
    selectors.push(getContextSelector(ENDSWITH, endsWithNormalized.replace(/^spotify:/, ':')));
  }

  return selectors;
}

/**
 * Check if two context URIs are representing the same context. This will take
 * care of normalizing the casing of URL encoding and filtered/sorted contexts.
 *
 * @param {string} context1 The first context.
 * @param {string} context2 The second context.
 *
 * @return {boolean} True if they represent the same context.
 */
function compareContexts(context1, context2) {
  if (!context1 || !context2) return false;

  context1 = normalizeUri(getOriginUri(context1) || context1);
  context2 = normalizeUri(getOriginUri(context2) || context2);

  return context1 === context2;
}

/**
 * A URI might contain URL encoded characters, and per spec the URL encoding can
 * be either in lowercase or uppercase (should be treated as same URL). If the
 * input URL has lowercase encoding, liburi will convert it into uppercase
 * encoding.
 *
 * @param {string} uri The URI to normalize.
 *
 * @return {string} The normalized URI.
 */
function normalizeUri(uri) {
  var uriObj = liburi.from(uri);
  var normalized = uriObj ? uriObj.toString() : uri;

  // Work around incorrect handling of `spotify:internal:...` URIs by liburi,
  // since it does not recognize `internal` URIs, and therefore uses the default
  // `app` type.
  normalized = normalized.replace(/^spotify:app:internal:/, 'spotify:internal:');

  // Work around the bad conversion of spaces in filtered list URIs. The URI
  // spec we use says that spaces should be encoded as `+`, but the `filterlist`
  // URI uses the regular `%20` encoding for spaces. Passing it through liburi
  // converts it to `+`, so we need to convert it back to `%20` again.
  normalized = normalized.replace(/:internal:filterlist:[^:]+/, function (match) {
    return match.replace(/\+/g, '%20');
  });

  return normalized;
}

/**
 * Create an empty method that will only log a warning when called.
 *
 * @param {string} methodName The name of the method to warn about.
 *
 * @return {Function} The function.
 */
function createEmptyMethod(methodName) {
  return function () {
    if (global.console) {
      console.warn('spotify-events/player: `' + methodName + '` is not implemented.');
    }
  };
}

exports.getUriFromButton = getUriFromButton;
exports.getAttributeValueFromNode = getAttributeValueFromNode;
exports.isFormOrLinkElement = isFormOrLinkElement;
exports.isInteractiveElement = isInteractiveElement;
exports.getContextSelector = getContextSelector;
exports.getContextSelectors = getContextSelectors;
exports.getContextSelectorsWithVariants = getContextSelectorsWithVariants;
exports.compareContexts = compareContexts;
exports.normalizeUri = normalizeUri;
exports.createEmptyMethod = createEmptyMethod;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../spotify-elements":70,"../../spotify-live-wrapped-uri":250,"spotify-liburi":426}],100:[function(require,module,exports){
'use strict';

/**
 * @private
 */

var live = require('../../spotify-live');
var Range = require('../../spotify-range2');
var $ = require('../../spotify-elements');
var find = require('mout/array/find');

var playerActions = require('./actions');
var playerUpdates = require('./updates');
var utils = require('./utils');

var isAttached = false;

exports.attach = function () {
  if (isAttached) return;
  isAttached = true;

  playerActions.setMethods({
    getPlayerVariantUri: getPlayerVariantUri,
    handlePlayButton: handlePlayButton,
    handlePlayFromRow: handlePlayFromRow
  });

  playerUpdates.setMethods({
    getPlayerVariantUri: getPlayerVariantUri,
    getPlayerIsPlaying: getPlayerIsPlaying,
    getPlayingNodes: getPlayingNodes,
    subscribeToPlayerChange: subscribeToPlayerChange
  });

  playerActions.attach();
  playerUpdates.attach();
};

exports.detach = function () {
  if (!isAttached) return;
  isAttached = false;

  playerActions.detach();
  playerUpdates.detach();
};

exports.update = function (optNode) {
  if (!isAttached) return;

  playerUpdates.update(optNode);
};

/**
 * Get the variant URI for the currently playing context. For example, if
 * playing a sorted playlist, this should return the sorted URI.
 *
 * @return {string} The context variant URI, or empty string if nothing is
 *     playing.
 */
function getPlayerVariantUri() {
  var variant = live('spotify:player').get('variant');
  return variant ? variant.uri : '';
}

/**
 * Get the index of the currently playing track within the playing context.
 *
 * @return {number} The index, or -1 if not found.
 */
function getPlayerIndex() {
  var indexObject = live('spotify:player').get('index');
  return indexObject ? indexObject.get('track') : -1;
}

/**
 * Get the URI of the currently playing track.
 *
 * @return {string} The track URI, or empty string if nothing is playing.
 */
function getPlayerTrackUri() {
  var track = live('spotify:player').get('track');
  return track && track.uri || '';
}

/**
 * Get the playing status of the player.
 *
 * @return {boolean} True if the player is currently playing audio.
 */
function getPlayerIsPlaying() {
  var isPlaying = live('spotify:player').get('isPlaying');
  var isPaused = live('spotify:player').get('isPaused');
  return isPlaying && !isPaused;
}

/**
 * Get whether the player is currently shuffling the context.
 *
 * @return {boolean} True if shuffling.
 */
function getPlayerIsShuffling() {
  var options = live('spotify:player').get('options');
  var shufflingContext = options && options.get('shufflingContext');
  return !!shufflingContext;
}

/**
 * Subscribe to player changes.
 *
 * @param {Function} handler A handler function. The data passed to this
 *     function is irrelevent, only the fact that something changed is needed.
 *
 * @return {Object} An object with a `cancel` method to cancel the subscription.
 */
function subscribeToPlayerChange(handler) {
  live('spotify:player').on('update', handler);
  var active = true;
  return {
    cancel: function cancel() {
      if (active) {
        live('spotify:player').off('update', handler);
        active = false;
      }
    }
  };
}

/**
 * Handle the click of a play button.
 * This function should decide what the action should be, and pause/resume
 * playback or start playback of a new context.
 *
 * @param {HTMLElement} buttonNode A button DOM node.
 * @param {Object} data Object of data about the action:
 *     isPlayingContext: (boolean) Whether the button looks to be representing
 *         the currently playing context.
 *     contextUri: (string) The context URI for the button.
 *     source: (string) The 'play source' value, for logging purposes.
 *     reason: (string) The 'play reason' value, for logging purposes.
 */
function handlePlayButton(buttonNode, data) {
  var button = $(buttonNode);
  var playerIndex = getPlayerIndex();
  var range;
  var newIndex;
  var uids;
  var uris;

  var dataRange = button.data('range');
  if (dataRange) {
    range = Range.fromString(dataRange);
    var list = live(data.contextUri).get('rows');
    if (list) {
      var indices = range.toIndices();
      uids = indices.map(function (index) {
        return list.keys[index];
      });
      uris = indices.map(function (index) {
        var track = list.get(index).get('track');
        return track.uri;
      });
    }
    newIndex = null;
  } else {
    var contextIndexNode = null;
    if (button.matches('[data-context-index]')) {
      contextIndexNode = button;
    } else {
      contextIndexNode = button.parent('[data-context-index]');
    }

    if (contextIndexNode) {
      newIndex = parseInt(contextIndexNode.data('context-index'), 10);
      var list = live(data.contextUri).get('rows');
      if (list) {
        uids = [list.keys[newIndex]];
        uris = [list.get(newIndex).get('track').uri];
      }
    } else {
      newIndex = null;
    }
  }

  var shouldPauseResume = false;

  if (data.isPlayingContext) {
    if (range) {
      // null or undefined
      if (playerIndex == null) {
        shouldPauseResume = false;
      } else {
        shouldPauseResume = range.contains(new Range(playerIndex, playerIndex + 1));
      }
    } else if (newIndex != null) {
      shouldPauseResume = newIndex === playerIndex;
    } else {
      shouldPauseResume = true;
    }
  }

  if (shouldPauseResume) {
    if (getPlayerIsPlaying()) {
      live('spotify:player').emit('pause');
    } else {
      live('spotify:player').emit('resume');
    }
  } else {
    var eventData = {
      context: data.contextUri,
      index: newIndex,
      source: data.source,
      reason: data.reason
    };

    if (range) {
      eventData.range = [range.start, range.end];
    }

    if (uids) {
      eventData.uids = uids;
    }

    if (uris) {
      eventData.uris = uris;
    }

    live('spotify:player').emit('play', eventData);
  }
}

/**
 * Handle playing a list row. This function should start playback of a context
 * starting from a specific row.
 *
 * @param {HTMLElement} rowNode A DOM node for a list row.
 * @param {Object} data Object of data about the action:
 *     contextUri: (string) The context URI for the list.
 *     source: (string) The 'play source' value, for logging purposes.
 *     reason: (string) The 'play reason' value, for logging purposes.
 */
function handlePlayFromRow(rowNode, data) {
  var index = parseInt(rowNode.getAttribute('data-context-index'), 10);
  if (isNaN(index)) {
    index = -1;
  }
  var uid = rowNode.getAttribute('data-uid') || '';
  var uri = rowNode.getAttribute('data-uri') || '';

  var eventData = {
    context: data.contextUri,
    index: index,
    source: data.source,
    reason: data.reason
  };

  if (uid) {
    eventData.uids = [uid];
  }

  if (uri) {
    eventData.uris = [uri];
  }

  live('spotify:player').emit('play', eventData);
}

/**
 * Get the nodes inside the passed container node that should be marked as
 * playing.
 *
 * @param {HTMLElement} containerNode The DOM node to search inside.
 * @param {Array.<HTMLElement>} contextNodes Array of DOM nodes that are already
 *     matched based on context URIs. These can be filtered if needed, but
 *     otherwise they should be included in the return value.
 *
 * @return {Array.<HTMLElement>} An array of DOM nodes.
 */
function getPlayingNodes(containerNode, contextNodes) {
  var playerIndex = getPlayerIndex();
  var playerTrackUri = getPlayerTrackUri();
  var variantUri = getPlayerVariantUri();

  // Remove any matched context nodes that have a range specified and where
  // the current player index does not match.
  var filteredContextNodes = filterRanges(playerIndex, contextNodes);

  var selectors = utils.getContextSelectors(variantUri);
  var selectorsWithVariants = utils.getContextSelectorsWithVariants(variantUri);

  var rowNodes = getContextNodesForRows(containerNode, selectors, playerIndex, playerTrackUri) || [];

  var rangeNodes = getContextNodesForRanges(containerNode, selectorsWithVariants, playerIndex) || [];

  var buttonNodes = [];
  if (contextNodes.length) {
    buttonNodes = $(contextNodes).search('[data-button=play-context]');
  }

  // Let `elements` remove any duplicate nodes
  var nodes = $([filteredContextNodes, rowNodes, rangeNodes, buttonNodes]);

  return nodes ? Array.prototype.slice.call(nodes) : [];
}

/**
 * Get the nodes inside the passed container node that match what's currently
 * playing and are list rows.
 *
 * @param {HTMLElement} containerNode The DOM node to search inside.
 * @param {Array.<string>} selectors Array of CSS selectors for matching the
 *     currently playing context.
 * @param {number} index The currently playing index.
 * @param {string} trackUri The URI of the currently playing track.
 *
 * @return {Array.<HTMLElement>} Array of DOM nodes.
 */
function getContextNodesForRows(containerNode, selectors, index, trackUri) {
  var isShuffling = getPlayerIsShuffling();

  // When playing from this client, we highlight the playing index if the
  // playing variant and the list variant are exactly the same.
  //
  // Removed support for connect as we can no longer detect a connect session: KM-9645.

  var useIndexSelector = !isShuffling;
  var useTrackSelector = !!trackUri;

  var selector = selectors.map(function (selector) {
    if (useIndexSelector || useTrackSelector) selector += ' ';
    if (useIndexSelector) selector += '[data-context-index=' + index + ']';
    if (useTrackSelector) selector += '[data-uri="' + trackUri + '"]';
    return selector;
  }).join(', ');

  var nodes = selector && $(containerNode).search(selector);
  if (nodes) {
    nodes = Array.prototype.slice.call(nodes);

    if (isShuffling) {
      // As the lax matching used in this case might yield duplicate rows in a
      // single list, we must filter out those.
      nodes = nodes.filter(function (row, i) {
        var listNode = $(row).parent('[data-list]');
        // If this row is not the first row to be highlighted in this list,
        // filter it out.
        return row === find(nodes, function (row) {
          return listNode === $(row).parent('[data-list]');
        });
      });
    }
  } else {
    nodes = [];
  }

  return nodes;
}

/**
 * Get the nodes inside the passed container node that match what's currently
 * playing and have a matching range specified.
 *
 * @param {HTMLElement} containerNode The DOM node to search inside.
 * @param {Array.<string>} selectors Array of CSS selectors for matching the
 *     currently playing context.
 * @param {number} index The currently playing index.
 *
 * @return {Array.<HTMLElement>} Array of DOM nodes.
 */
function getContextNodesForRanges(containerNode, selectors, index) {
  var rangeAttribute = '[data-range]';

  // It needs to search for all range elements somewhere inside an element
  // marked up as a context, as well as range elements that themselves are
  // contexts.
  selectors = selectors.map(function (selector) {
    var rangeInContextSelector = selector + ' ' + rangeAttribute;
    var rangedContextSelector = selector + rangeAttribute;
    var rangeSelector = rangeInContextSelector + ', ' + rangedContextSelector;
    return rangeSelector;
  });

  var rangeNodes = $(containerNode).search(selectors.join(', '));
  if (rangeNodes) {
    rangeNodes = Array.prototype.slice.call(rangeNodes);
  } else {
    rangeNodes = [];
  }

  return filterRanges(index, rangeNodes);
}

/**
 * Return a new array of nodes where nodes that specify a range that doesn't
 * match the currently playing index are removed.
 *
 * @param {number=} index The currently playing index. Can be undefined/null.
 * @param {Array.<HTMLElement>} nodes Array of DOM nodes.
 *
 * @return {Array.<HTMLElement>} Array of DOM nodes.
 */
function filterRanges(index, nodes) {
  var thisRange = index != null ? new Range(index, index + 1) : null;

  return nodes.filter(function (node) {
    node = $(node);
    var range = node.data('range');

    // Node without a range should always be active
    if (!range) return true;

    // If player has no index, but the node has a range, we can't be sure if
    // it's playing
    if (!thisRange) return false;

    range = Range.fromString(range);
    return range.contains(thisRange);
  });
}

},{"../../spotify-elements":70,"../../spotify-live":251,"../../spotify-range2":289,"./actions":96,"./updates":98,"./utils":99,"mout/array/find":354}],101:[function(require,module,exports){
'use strict';

var live = require('../../spotify-live');
var Range = require('../../spotify-range2');
var $ = require('../../spotify-elements');

var playerActions = require('./actions');
var playerUpdates = require('./updates');
var utils = require('./utils');

var isAttached = false;

exports.attach = function () {
  if (isAttached) return;
  isAttached = true;

  playerActions.setMethods({
    getPlayerVariantUri: getPlayerVariantUri,
    handlePlayButton: handlePlayButton,
    handlePlayFromRow: handlePlayFromRow
  });

  playerUpdates.setMethods({
    getPlayerVariantUri: getPlayerVariantUri,
    getPlayerIsPlaying: getPlayerIsPlaying,
    getPlayingNodes: getPlayingNodes,
    subscribeToPlayerChange: subscribeToPlayerChange
  });

  playerActions.attach();
  playerUpdates.attach();
};

exports.detach = function () {
  if (!isAttached) return;
  isAttached = false;

  playerActions.detach();
  playerUpdates.detach();
};

exports.update = function (optNode) {
  if (!isAttached) return;

  playerUpdates.update(optNode);
};

/**
 * Get the variant URI for the currently playing context. For example, if
 * playing a sorted playlist, this should return the sorted URI.
 *
 * @return {string} The context variant URI, or empty string if nothing is
 *     playing.
 */
function getPlayerVariantUri() {
  var variant = live('spotify:player').get('variant');
  return variant ? variant.uri : '';
}

/**
 * Get the index of the currently playing page.
 *
 * @return {number} The page index, or -1 if not found.
 */
function getPlayerPageIndex() {
  var indexObject = live('spotify:player').get('index');
  var pageIndex = indexObject && indexObject.get('page');
  var hasPageIndex = typeof pageIndex === 'number';
  return hasPageIndex ? pageIndex : -1;
}

/**
 * Get the UID of the currently playing track.
 *
 * @return {string} The UID, or empty string if not found.
 */
function getPlayerTrackUid() {
  return live('spotify:player').get('uid') || '';
}

/**
 * Get the uri of the currently playing track.
 *
 * @return {string} The uri, or empty string if not found.
 */
function getPlayerTrackUri() {
  var track = live('spotify:player').get('track');
  return track ? track.get('uri') || '' : '';
}

/**
 * Get the URI of the currently playing track.
 *
 * @return {string} The track URI, or empty string if nothing is playing.
 */
function getPlayerTrackUri() {
  var track = live('spotify:player').get('track');
  return track && track.uri || '';
}

/**
 * Get the playing status of the player.
 *
 * @return {boolean} True if the player is currently playing audio.
 */
function getPlayerIsPlaying() {
  var isPlaying = live('spotify:player').get('isPlaying');
  var isPaused = live('spotify:player').get('isPaused');
  return isPlaying && !isPaused;
}

/**
 * Get whether the playback was initiated from open.spotify.com
 *
 * This info is needed to be able to do a best-effort of highlighting rows when
 * playing from open.
 *
 * @return {boolean} True if playing from open.spotify.com.
 */
function getPlayerIsPlayingFromOpen() {
  var playOrigin = live('spotify:player').get('playOrigin');
  var externalReferrer = playOrigin && playOrigin.get('externalReferrer');

  return externalReferrer && externalReferrer.indexOf('https://open.spotify.com/') === 0;
}

/**
 * Subscribe to player changes.
 *
 * @param {Function} handler A handler function. The data passed to this
 *     function is irrelevent, only the fact that something changed is needed.
 *
 * @return {Object} An object with a `cancel` method to cancel the subscription.
 */
function subscribeToPlayerChange(handler) {
  live('spotify:player').on('update', handler);
  var active = true;
  return {
    cancel: function cancel() {
      if (active) {
        live('spotify:player').off('update', handler);
        active = false;
      }
    }
  };
}

/**
 * Handle the click of a play button.
 * This function should decide what the action should be, and pause/resume
 * playback or start playback of a new context.
 *
 * @param {HTMLElement} buttonNode A button DOM node.
 * @param {Object} data Object of data about the action:
 *     isPlayingContext: (boolean) Whether the button looks to be representing
 *         the currently playing context.
 *     contextUri: (string) The context URI for the button.
 *     source: (string) The 'play source' value, for logging purposes.
 *     reason: (string) The 'play reason' value, for logging purposes.
 */
function handlePlayButton(buttonNode, data) {
  var isPlaying = data.isPlayingContext;

  var button = $(buttonNode);

  var trackUid = utils.getAttributeValueFromNode(buttonNode, 'data-uid');
  var trackUri = utils.getAttributeValueFromNode(buttonNode, 'data-track-uri');
  var pageIndex = parseInt(utils.getAttributeValueFromNode(buttonNode, 'data-context-page'), 10);

  if (isPlaying) {
    isPlaying = verifyIsPlayingIndex(trackUid, trackUri, pageIndex);
  }

  if (isPlaying) {
    if (getPlayerIsPlaying()) {
      live('spotify:player').emit('pause');
    } else {
      live('spotify:player').emit('resume');
    }
  } else {

    var eventData = {
      context: data.contextUri,
      source: data.source,
      reason: data.reason
    };

    if (trackUid) {
      eventData.uid = trackUid;
    }

    if (trackUri) {
      eventData.trackUri = trackUri;
    }

    if (!isNaN(pageIndex)) {
      eventData.page = pageIndex;
    }

    live('spotify:player').emit('play', eventData);
  }
}

/**
 * Verify that a uid, uri or pageIndex is playing, or that just the context
 * is playing when none of that is set.
 * This is used when we already know that we're playing the context.
 *
 * @param {string} trackUid
 * @param {string} trackUri
 * @param {number} pageIndex
 *
 * @return {boolean} True if it's really playing
 */
function verifyIsPlayingIndex(trackUid, trackUri, pageIndex) {
  if (trackUid) {
    var playerTrackUid = getPlayerTrackUid();
    return playerTrackUid === trackUid;
  }

  if (trackUri) {
    var playerTrackUri = getPlayerTrackUri();
    return playerTrackUri === trackUri;
  }

  if (!isNaN(pageIndex)) {
    var playerPageIndex = getPlayerPageIndex();
    return playerPageIndex === pageIndex;
  }

  // No index given also means it's really playing.
  return true;
}

/**
 * Handle playing a list row. This function should start playback of a context
 * starting from a specific row.
 *
 * @param {HTMLElement} rowNode A DOM node for a list row.
 * @param {Object} data Object of data about the action:
 *     contextUri: (string) The context URI for the list.
 *     source: (string) The 'play source' value, for logging purposes.
 *     reason: (string) The 'play reason' value, for logging purposes.
 */
function handlePlayFromRow(rowNode, data) {
  var eventData = {
    context: data.contextUri,
    source: data.source,
    reason: data.reason
  };

  var uid = rowNode.getAttribute('data-uid');
  if (uid) {
    eventData.uid = uid;
  }

  var pageIndex = parseInt(utils.getAttributeValueFromNode(rowNode, 'data-context-page'), 10);
  if (!isNaN(pageIndex)) {
    eventData.page = pageIndex;
  }

  live('spotify:player').emit('play', eventData);
}

/**
 * Get the nodes inside the passed container node that should be marked as
 * playing.
 *
 * @param {HTMLElement} containerNode The DOM node to search inside.
 * @param {Array.<HTMLElement>} contextNodes Array of DOM nodes that are already
 *     matched based on context URIs. These can be filtered if needed, but
 *     otherwise they should be included in the return value.
 *
 * @return {Array.<HTMLElement>} An array of DOM nodes.
 */
function getPlayingNodes(containerNode, contextNodes) {
  var playerPageIndex = getPlayerPageIndex();
  var playerTrackUid = getPlayerTrackUid();
  var playerTrackUri = getPlayerTrackUri();
  var variantUri = getPlayerVariantUri();

  // Remove any matched context nodes that have a page specified and where
  // the current player page does not match.
  var filteredContextNodes = filterPages(playerPageIndex, contextNodes);

  var selectors = utils.getContextSelectors(variantUri);
  var rowNodes = getContextNodesForRows(containerNode, selectors, playerTrackUid, playerTrackUri) || [];

  var selectorsWithVariants = utils.getContextSelectorsWithVariants(variantUri);
  var pageNodes = getContextNodesForPages(containerNode, selectorsWithVariants, playerPageIndex) || [];

  var buttonNodes = [];
  if (contextNodes.length) {
    buttonNodes = $(contextNodes).search('[data-button=play-context]');
  }

  // Let `elements` remove any duplicate nodes
  var nodes = $([filteredContextNodes, rowNodes, pageNodes, buttonNodes]);

  return nodes ? Array.prototype.slice.call(nodes) : [];
}

/**
 * Get the nodes inside the passed container node that match what's currently
 * playing and are list rows.
 *
 * @param {HTMLElement} containerNode The DOM node to search inside.
 * @param {Array.<string>} selectors Array of CSS selectors for matching the
 *     currently playing context.
 * @param {string} trackUid The UID of the currently playing track.
 *
 * @return {Array.<HTMLElement>} Array of DOM nodes.
 */
function getContextNodesForRows(containerNode, selectors, trackUid, trackUri) {

  // When playing from this client, we highlight the playing UIDs.
  var useTrackSelector = getPlayerIsPlayingFromOpen();

  var selector = selectors.map(function (selector) {
    selector += ' ';
    if (useTrackSelector) selector += '[data-uri=' + trackUri + ']';
    if (!useTrackSelector) selector += '[data-uid=' + trackUid + ']';
    return selector;
  }).join(', ');

  var nodes = $(containerNode).search(selector);
  if (nodes) {
    nodes = Array.prototype.slice.call(nodes);

    if (useTrackSelector) {
      // Gets UID of the first node and find all the nodes
      // with the same UID
      var firstUid = $(nodes[0]).data('uid');
      nodes = nodes.filter(function (row, i) {
        return firstUid === $(row).data('uid');
      });
    }
  } else {
    nodes = [];
  }

  return nodes;
}

/**
 * Get the nodes inside the passed container node that match what's currently
 * playing and have a matching page specified.
 *
 * @param {HTMLElement} containerNode The DOM node to search inside.
 * @param {Array.<string>} selectors Array of CSS selectors for matching the
 *     currently playing context.
 * @param {number} playerPageIndex The currently playing page index.
 *
 * @return {Array.<HTMLElement>} Array of DOM nodes.
 */
function getContextNodesForPages(containerNode, selectors, playerPageIndex) {
  var pageAttribute = '[data-context-page]';

  // It needs to search for all range elements somewhere inside an element
  // marked up as a context, as well as range elements that themselves are
  // contexts.
  selectors = selectors.map(function (selector) {
    var pageInContextSelector = selector + ' ' + pageAttribute;
    var pagedContextSelector = selector + pageAttribute;
    var pageSelector = pageInContextSelector + ', ' + pagedContextSelector;
    return pageSelector;
  });

  var pageNodes = $(containerNode).search(selectors.join(', '));
  if (pageNodes) {
    pageNodes = Array.prototype.slice.call(pageNodes);
  } else {
    pageNodes = [];
  }

  return filterPages(playerPageIndex, pageNodes);
}

/**
 * Return a new array of nodes where nodes that specify a context page that
 * doesn't match the currently playing context page are removed.
 *
 * @param {number} playerPageIndex The currently playing page index.
 * @param {Array.<HTMLElement>} contextNodes Array of already matched nodes.
 *
 * @return {Array.<HTMLElement>} Array of filtered nodes.
 */
function filterPages(playerPageIndex, contextNodes) {
  return contextNodes.filter(function (node) {
    var nodePageIndex = parseInt(node.getAttribute('data-context-page'), 10);

    // Node without a page should always be active
    if (isNaN(nodePageIndex)) return true;

    // If player has no page, but the node has a page, we can't be sure if it's
    // playing.
    if (isNaN(playerPageIndex)) return false;

    // Node that matches the player page should be active
    return playerPageIndex === nodePageIndex;
  });
}

},{"../../spotify-elements":70,"../../spotify-live":251,"../../spotify-range2":289,"./actions":96,"./updates":98,"./utils":99}],102:[function(require,module,exports){
'use strict';

var Range = require('../spotify-range2');

var contains = require('mout/array/contains');

var $ = require('../spotify-elements');

var SYNC = require('prime/emitter').EMIT_SYNC;

var throttle = require('./util/throttle');
var ListManager = require('./util/ListManager.js');

var center = require('./center');

var doc = $(document);
var win = $(window);

var scrollContainers = [];
var listManagers = [];
var scrollHandlers = [];
var pendingScrollContainers = [];
var pendingHiddenIndices = [];
var cleanupHandlers = [];

var getBounds = function getBounds(view, container) {
  var dde = document.documentElement;

  if (view === window || view === document.body) view = dde;
  var viewTop = view === dde ? 0 : view.getBoundingClientRect().top;

  var viewHeight = view.clientHeight;
  var containerTop = container.getBoundingClientRect().top;
  var containerHeight = container.offsetHeight;

  var viewBox = {
    top: viewTop,
    height: viewHeight,
    bottom: viewTop + viewHeight
  };

  var containerBox = {
    top: containerTop,
    height: containerHeight,
    bottom: containerTop + containerHeight
  };

  return {
    view: viewBox,
    container: containerBox
  };
};

var getRange = function getRange(view, container, height, hotZone) {
  hotZone = hotZone || 0;
  var bounds = getBounds(view, container);
  var top = -(bounds.container.top - bounds.view.top);
  var startsAt = Math.floor((top - hotZone) / height);
  var endsAt = Math.ceil((top + bounds.view.height + hotZone) / height);
  if (startsAt < 0) startsAt = 0;
  if (endsAt <= startsAt) return false;
  return new Range(startsAt, endsAt);
};

var init = function init(view, container, length, height, tag) {
  var view0 = view[0];
  var container0 = container[0];

  container.addClass('scroll-container-enabled');

  var manager = new ListManager(container0, {
    height: height,
    length: length,
    tag: tag,
    debug: false,
    request: function request(range, callback) {
      center.emit('scroll-request', container0, range, callback, SYNC);
    }
  });
  listManagers.push(manager);

  // Update the manager with previously saved hidden indices.
  // This allows the scroller to take hidden indices into account even for the
  // first render.
  var pendingIndex = pendingScrollContainers.indexOf(container);
  if (pendingIndex > -1) {
    manager.reset(length, pendingHiddenIndices[pendingIndex]);
    pendingScrollContainers.splice(pendingIndex, 1);
    pendingHiddenIndices.splice(pendingIndex, 1);
  }

  manager.on('before-show', function (range, nodes) {
    center.emit('scroll-show-before', {
      pageNode: container,
      container: container,
      range: range,
      nodes: nodes
    }, SYNC);
  });

  manager.on('after-show', function (range, nodes) {
    center.emit('scroll-show-after', {
      pageNode: container,
      container: container,
      range: range,
      nodes: nodes
    }, SYNC);
  });

  manager.on('index-change', function (index) {
    center.emit('scroll-index-change', {
      pageNode: container,
      container: container,
      ranges: index
    }, SYNC);
  });

  var hasRequestedMore = false;

  var scroll = function scroll() {
    var bounds = getBounds(view0, container0);
    var show = getRange(view0, container0, height);

    if (show) {
      var padding = 2;
      show = new Range(show.start - padding, show.end + padding);
      manager.show(new Range(show.start, show.end));
    }

    // If the scroll position is close enough to the end, an event should be
    // emitted to allow for more content to be loaded. Not all lists will use this,
    // but some lists want to lazy load content by loading more when you reach the
    // bottom, and then they can listen for this event.
    if (!hasRequestedMore) {
      if (bounds.container.bottom < 2000) {
        hasRequestedMore = true;

        // Emit the event and also pass a callback to the event.
        // The receiver of this event should pass the new total length of the list
        // as the second argument to the callback.
        center.emit('scroll-request-more', container0, function (error, length) {
          if (error) throw error;
          hasRequestedMore = false;
          scrollReset(container0, length);
        });
      }
    }
  };

  scrollHandlers.push(scroll);

  scroll = container._scrollEvent = throttle(scroll);

  var scrollReset = function scrollReset(c, height, opt_hiddenIndices, opt_fromIndex) {
    if ($(c) === container) {
      var hasFromIndex = typeof opt_fromIndex === 'number';
      if (hasFromIndex && opt_fromIndex > 0) {
        manager.resetFrom(opt_fromIndex, height, opt_hiddenIndices);
      } else {
        manager.reset(height, opt_hiddenIndices);
      }
      scroll();
    }
  };

  center.on('scroll-reset', scrollReset);
  container._scrollResetEvent = scrollReset;

  var scrollToIndex = function scrollToIndex(c, index, opt_offsetScrollPosition) {
    if (view0 !== window) {
      throw new Error('Can\'t scroll to index if view is not `window`');
      return;
    }

    if ($(c) === container) {
      var bounds = getBounds(view0, container0);

      // Let's say we scroll the sidebar to show the playlist at 200px from
      // the top or the bottom (depending if it was above or below fold).
      // If the sidebar height is smaller than 400px, we vertically center the
      // playlist:
      var offset = Math.min(opt_offsetScrollPosition || 0, (bounds.view.height - manager.height) / 2);

      var indexTopRelativeToContainer = manager.height * index;
      var position = bounds.container.top + indexTopRelativeToContainer;

      var scrollY = position + window.pageYOffset;
      var stickyOffset = (doc.search('[data-sticky-active]') || []).map(function (sticky) {
        return sticky.offsetHeight;
      }).reduce(function (a, b) {
        return a + b;
      }, 0);

      if (position <= stickyOffset) {
        // item is above viewport
        scrollY -= offset + stickyOffset;
      } else if (position + manager.height > bounds.view.height) {
        // item is below viewport
        scrollY += offset + manager.height - bounds.view.height;
      } else {
        // item is in viewport
        return;
      }

      view0.scrollTo(0, scrollY);
    }
  };

  center.on('scroll-to-index', scrollToIndex);

  view.on('scroll', scroll);
  win.on('resize', scroll);
  scroll();

  cleanupHandlers.push(function () {
    center.off('scroll-reset', scrollReset);
    center.off('scroll-to-index', scrollToIndex);
    view.off('scroll', scroll);
    win.off('resize', scroll);

    container.removeClass('scroll-container-enabled');
  });
};

function onScrollSetHidden(data) {
  var hiddenIndices = data.indices;

  var container = $(data.itemContainer);
  var index = scrollContainers.indexOf(container);
  if (index > -1) {
    var manager = listManagers[index];
    if (manager) {
      manager.reset(manager.length, hiddenIndices);
    }
    var scrollHandler = scrollHandlers[index];
    if (scrollHandler) {
      scrollHandler();
    }
  } else {
    pendingScrollContainers.push(container);
    pendingHiddenIndices.push(hiddenIndices);
  }
}

var isAttached = false;

exports.update = function (node) {
  if (!isAttached) return;

  node = $(node) || doc;

  var scrollNodes = doc.search('[data-scroll-container]');

  var handlers = [];
  var managers = [];
  scrollContainers = scrollContainers.filter(function (container, index) {
    if (!contains(scrollNodes, container[0])) {
      container._view.off('scroll', container._scrollEvent);
      win.off('resize', container._scrollEvent);
      center.off('scroll-reset', container._scrollResetEvent);
      delete container._scrollEvent;
      delete container._scrollResetEvent;
      return false;
    }
    managers.push(listManagers[index]);
    handlers.push(scrollHandlers[index]);
    return true;
  });
  listManagers = managers;
  scrollHandlers = handlers;

  if (node !== doc) scrollNodes = node.search('[data-scroll-container]');

  if (scrollNodes) scrollNodes.forEach(function (node0) {
    var container = $(node0);

    if (container._scrollEvent || node0.children.length) return;

    scrollContainers.push(container);
    var view = container.parent('[data-scroll-view]') || win;
    container._view = view;

    var callback = function callback(error, children, length) {
      if (error) throw error;
      children = $(children);
      children.insert(container);

      var second = children[1];
      var height = second.offsetHeight;
      var tag = $(second).tag();
      children.remove();
      init(view, container, length, height, tag);
    };

    center.emit('scroll-request', container[0], new Range(0, 3), callback, SYNC);
  });
};

exports.attach = function () {
  if (isAttached) return;
  isAttached = true;

  center.on('scroll-set-hidden', onScrollSetHidden);
};

exports.detach = function () {
  if (!isAttached) return;
  isAttached = false;

  center.off('scroll-set-hidden', onScrollSetHidden);

  cleanupHandlers.forEach(function (cleanupHandler) {
    cleanupHandler();
  });
  cleanupHandlers = [];
};

},{"../spotify-elements":70,"../spotify-range2":289,"./center":77,"./util/ListManager.js":125,"./util/throttle":131,"mout/array/contains":349,"prime/emitter":403}],103:[function(require,module,exports){
'use strict';

/**
 * Module for handling clicks on the scroll bar track to scroll pages.
 *
 * @private
 */

var BezierEasing = require('bezier-easing');

var config = require('./config');

module.exports = {

  // Called from outside
  setHandler: function setHandler(eventName, scroller, handler) {
    if (eventName === 'clickEnd') {
      scroller._clickEndHandler = handler;
    }
  },

  scrollTo: function scrollTo(scroller, newPosition, useEasing, callback) {
    var startPosition = scroller.view.scrollTop;
    var positionDiff = newPosition - startPosition;

    var startTimestamp = Date.now();
    var totalTime = config.scrollToTransitionMs;

    if (!useEasing) {
      totalTime = config.scrollToLinearTransitionMs;
    }

    // Ease in/out quadratic
    var easing = new BezierEasing(0.455, 0.03, 0.515, 0.955);

    var tick = function tick() {
      var elapsedTime = Date.now() - startTimestamp;
      var totalPercentage = elapsedTime / totalTime;

      var currentPercentage = useEasing ? easing.get(totalPercentage) : totalPercentage;

      scroller.view.scrollTop = startPosition + positionDiff * currentPercentage;

      if (totalPercentage < 1) {
        // Must use setTimeout to not make it flicker. Setting scrollTop in
        // requestAnimationFrame will make it scroll and in the next frame allow
        // the scroll handlers to move elements, making it look very flickery.
        setTimeout(tick, config.frameMs);
      } else {
        scroller.view.scrollTop = startPosition + positionDiff;
        scroller.isClickScrollAnimating = false;
        if (callback) {
          callback();
        }
      }
    };

    scroller.isClickScrollAnimating = true;
    setTimeout(tick, config.frameMs);
  },

  holdClick: function holdClick(scroller) {
    var targetThumbEdge = scroller.clickTargetThumbTop;
    var newPosition = this.getNextScrollValue(scroller);
    var newThumbTop = newPosition / scroller.viewScrollHeight * scroller.viewHeight;
    var newThumbBottom = newThumbTop + scroller.thumbHeight;
    var direction = scroller.clickTargetDirection;

    var isValid = false;
    if (direction === 'up' && newThumbBottom > targetThumbEdge) {
      isValid = true;
    } else if (direction === 'down' && newThumbTop < targetThumbEdge) {
      isValid = true;
    }

    if (isValid) {
      var useEasing = false;

      this.scrollTo(scroller, newPosition, useEasing, function () {
        if (scroller.isClickScrolling) {
          this.holdClick(scroller);
        }
      }.bind(this));
    }
  },

  getNextScrollValue: function getNextScrollValue(scroller) {
    var change = scroller.viewHeight * config.clickScrollDistanceFactor;

    if (scroller.clickTargetDirection === 'up') {
      return scroller.view.scrollTop - change;
    }

    return scroller.view.scrollTop + change;
  },

  setMovementData: function setMovementData(scroller, clientY) {
    var trackTop = scroller.scrollBarTrack.getBoundingClientRect().top;
    var targetThumbEdge = clientY - trackTop;
    var direction = targetThumbEdge < scroller.thumbTop ? 'up' : 'down';

    scroller.clickTargetDirection = direction;
    scroller.clickTargetThumbTop = targetThumbEdge;
  },

  onClickHold: function onClickHold(scroller) {
    scroller.isClickScrolling = true;

    this.holdClick(scroller);
  },

  onMouseMove: function onMouseMove(scroller, event) {
    if (scroller.isMouseOver && event.target === scroller.scrollBarTrack) {
      this.setMovementData(scroller, event.clientY);

      if (scroller.isClickScrolling && !scroller.isClickScrollAnimating) {
        this.holdClick(scroller);
      }
    }
  },

  onMouseUp: function onMouseUp(scroller) {
    scroller.isClickScrolling = false;

    clearTimeout(scroller.clickHoldTimer);

    this.removeHandlers(scroller);

    if (scroller._clickEndHandler) {
      scroller._clickEndHandler();
    }
  },

  onTrackMouseDown: function onTrackMouseDown(scroller, event) {
    var isVisible = scroller.isVisible;
    var isPrimaryButton = event.button === 0;
    var isTargetTrack = event.target === scroller.scrollBarTrack;

    if (isVisible && isPrimaryButton && isTargetTrack) {
      var navigator = window.navigator;
      var isMac = navigator && navigator.userAgent.indexOf('Mac') > -1;
      var isWindows = navigator && navigator.userAgent.indexOf('Windows') > -1;

      if (isMac && event.altKey || isWindows && event.shiftKey) {
        var trackTop = scroller.scrollBarTrack.getBoundingClientRect().top;
        var targetThumbCenter = event.clientY - trackTop;
        var targetThumbTop = Math.max(0, Math.min(scroller.viewHeight - scroller.thumbHeight, targetThumbCenter - scroller.thumbHeight / 2));

        scroller.view.scrollTop = targetThumbTop / (scroller.viewHeight - scroller.thumbHeight) * (scroller.viewScrollHeight - scroller.viewHeight);
      } else {
        this.setMovementData(scroller, event.clientY);

        var targetPosition = this.getNextScrollValue(scroller);
        var useEasing = true;

        this.scrollTo(scroller, targetPosition, useEasing);

        this.addHandlers(scroller);

        scroller.clickHoldTimer = setTimeout(this.onClickHold.bind(this, scroller), config.scrollToTransitionMs + config.clickHoldDelayMs);
      }
    }
  },

  addHandlers: function addHandlers(scroller) {
    scroller._click_onMouseUp = this.onMouseUp.bind(this, scroller);
    scroller._click_onMouseMove = this.onMouseMove.bind(this, scroller);

    document.addEventListener('mouseup', scroller._click_onMouseUp, false);
    document.addEventListener('mousemove', scroller._click_onMouseMove, false);
  },

  removeHandlers: function removeHandlers(scroller) {
    document.removeEventListener('mouseup', scroller._click_onMouseUp, false);
    document.removeEventListener('mousemove', scroller._click_onMouseMove, false);
  },

  attach: function attach(scroller) {
    var onTrackMouseDown = this.onTrackMouseDown.bind(this, scroller);

    scroller.scrollBarTrack.addEventListener('mousedown', onTrackMouseDown, false);

    return function () {
      scroller.scrollBarTrack.removeEventListener('mousedown', onTrackMouseDown, false);
    };
  }

};

},{"./config":104,"bezier-easing":292}],104:[function(require,module,exports){
"use strict";

/**
 * Config with all timer values etc. Easy to have them all in one place, and it
 * also helps for testing, since the config can be used from there too.
 *
 * @private
 */

module.exports = {
  hideAfterMs: 750,
  showAfterMs: 500,

  // Sync with CSS transition duration
  hideTransitionMs: 500,

  expandDelayMs: 150,

  frameMs: 16,
  scrollToTransitionMs: 200,
  scrollToLinearTransitionMs: 120,
  clickHoldDelayMs: 500,
  clickScrollDistanceFactor: 0.95
};

},{}],105:[function(require,module,exports){
'use strict';

/**
 * Module for handling dragging the scroll bar thumb to scroll.
 *
 * @private
 */

module.exports = {

  // Called from outside
  setHandler: function setHandler(eventName, scroller, handler) {
    if (eventName === 'dragStart') {
      scroller._dragStartHandler = handler;
    } else if (eventName === 'dragEnd') {
      scroller._dragEndHandler = handler;
    }
  },

  onThumbMouseDown: function onThumbMouseDown(scroller, event) {
    if (event.button === 0 && scroller.isVisible) {
      scroller.isDragging = true;
      scroller.startDragMouseY = event.clientY;
      scroller.startDragThumbTop = scroller.thumbTop;

      this.addDragHandlers(scroller);

      if (scroller._dragStartHandler) {
        scroller._dragStartHandler();
      }
    }
  },

  onMouseUp: function onMouseUp(scroller, event) {
    if (scroller.isDragging) {
      scroller.isDragging = false;

      this.removeDragHandlers(scroller);

      if (scroller._dragEndHandler) {
        scroller._dragEndHandler();
      }
    }
  },

  onMouseMove: function onMouseMove(scroller, event) {
    var y = event.clientY;
    var startY = scroller.startDragMouseY;

    scroller.thumbTop = Math.max(0, Math.min(scroller.viewHeight - scroller.thumbHeight, scroller.startDragThumbTop + y - startY));

    scroller.view.scrollTop = scroller.thumbTop / (scroller.viewHeight - scroller.thumbHeight) * (scroller.viewScrollHeight - scroller.viewHeight);
  },

  addDragHandlers: function addDragHandlers(scroller) {
    scroller._drag_onMouseMove = this.onMouseMove.bind(this, scroller);
    scroller._drag_onMouseUp = this.onMouseUp.bind(this, scroller);

    document.addEventListener('mousemove', scroller._drag_onMouseMove, false);
    document.addEventListener('mouseup', scroller._drag_onMouseUp, false);
  },

  removeDragHandlers: function removeDragHandlers(scroller) {
    document.removeEventListener('mousemove', scroller._drag_onMouseMove, false);
    document.removeEventListener('mouseup', scroller._drag_onMouseUp, false);
  },

  attach: function attach(scroller) {
    var onThumbMouseDown = this.onThumbMouseDown.bind(this, scroller);

    scroller.scrollBarThumb.addEventListener('mousedown', onThumbMouseDown, false);

    return function () {
      scroller.scrollBarThumb.removeEventListener('mousedown', onThumbMouseDown, false);
    };
  }

};

},{}],106:[function(require,module,exports){
'use strict';

/**
 * Module for handling expanding the scroll bar width on hover.
 *
 * @private
 */

var config = require('./config');

module.exports = {

  expand: function expand(scroller) {
    clearTimeout(scroller.resetExpandedTimer);
    scroller.scrollBarTrack.classList.add('expanded');
  },

  collapse: function collapse(scroller) {
    scroller.scrollBarTrack.classList.remove('expanded');
  },

  // Called from outside
  onHide: function onHide(scroller) {
    if (!scroller.alwaysVisible) {
      clearTimeout(scroller.expandTimer);
      clearTimeout(scroller.resetExpandedTimer);

      scroller.resetExpandedTimer = setTimeout(this.collapse.bind(this, scroller), config.hideTransitionMs);
    }
  },

  onTrackMouseEnter: function onTrackMouseEnter(scroller, event) {
    if (event.target === scroller.scrollBarTrack) {
      if (scroller.isVisible) {
        clearTimeout(scroller.expandTimer);
        clearTimeout(scroller.resetExpandedTimer);
        scroller.expandTimer = setTimeout(function () {
          this.expand(scroller);
        }.bind(this), config.expandDelayMs);
      } else {
        this.expand(scroller);
      }
    }
  },

  onTrackMouseLeave: function onTrackMouseLeave(scroller, event) {
    if (event.target === scroller.scrollBarTrack) {
      if (scroller.isVisible) {
        clearTimeout(scroller.expandTimer);
      } else {
        this.collapse(scroller);
      }
    }
  },

  attach: function attach(scroller) {
    if (scroller.alwaysVisible) {
      this.expand(scroller);

      return function () {};
    } else {
      this.collapse(scroller);

      var onTrackMouseEnter = this.onTrackMouseEnter.bind(this, scroller);
      var onTrackMouseLeave = this.onTrackMouseLeave.bind(this, scroller);

      scroller.scrollBarTrack.addEventListener('mouseenter', onTrackMouseEnter, false);
      scroller.scrollBarTrack.addEventListener('mouseleave', onTrackMouseLeave, false);

      return function () {
        scroller.scrollBarTrack.removeEventListener('mouseenter', onTrackMouseEnter, false);
        scroller.scrollBarTrack.removeEventListener('mouseleave', onTrackMouseLeave, false);
      };
    }
  }

};

},{"./config":104}],107:[function(require,module,exports){
'use strict';

var glue = require('../../spotify-glue-cat');
var cosmos = require('spotify-cosmos-api');

var center = require('../center');
var drag = require('./drag');
var visibility = require('./visibility');
var position = require('./position');
var expansion = require('./expansion');
var click = require('./click');

var scrollers = [];
var scrollerStyle = null;

function Scroller(scrollView) {
  this.view = scrollView;
  this.setInitialState();
  this.addScrollBar();
  this.refresh();

  this.view.setAttribute('data-scroll-area-initialized', '');

  this._onResize = function () {
    this.refresh();
  }.bind(this);
  this._onScroll = function () {
    this.refreshScrollBar();
  }.bind(this);
  this._onThumbDragStart = function (event) {
    event.preventDefault();
    event.stopPropagation();
  };

  // Listen for the scroll event to update view size etc on scroll
  var scrollObject = this.isBody ? window : this.view;
  scrollObject.addEventListener('scroll', this._onScroll, false);

  // Listen for the window resize event, even for scroll areas that are not the
  // body scroll. Since we can't listen for resize events when elements resize,
  // we do a best effort of at least updating when the window resizes (which
  // might affect the size of the scroll area).
  window.addEventListener('resize', this._onResize, false);

  // Prevent dragndrop handling from spotify-events (it will be triggered
  // otherwise since we have to set the draggable attribute to not trigger
  // focus events).
  this.scrollBarThumb.addEventListener('dragstart', this._onThumbDragStart, true);

  this._detachVisibility = visibility.attach(this);
  this._detachPosition = position.attach(this);
  this._detachDrag = drag.attach(this);
  this._detachClick = click.attach(this);
  this._detachExpansion = expansion.attach(this);

  visibility.setHandler('show', this, function () {
    this.refresh();
  }.bind(this));

  visibility.setHandler('hide', this, function () {
    expansion.onHide(this);
  }.bind(this));

  // Events are sent when dragging to allow some use cases where you need to do
  // something while dragging. For example, when dragging the scroll bar in the
  // app sidebar and hovering over the main view, it will not trigger mousemove
  // events since the main view is an iframe. To counter that, zlink is
  // listening to these events and sets pointer-events on the content area.
  drag.setHandler('dragStart', this, function () {
    center.emit('scroll-thumb-drag-start', { id: this.viewId });
  }.bind(this));
  drag.setHandler('dragEnd', this, function () {
    visibility.onDragEnd(this);
    center.emit('scroll-thumb-drag-end', { id: this.viewId });
  }.bind(this));

  click.setHandler('clickEnd', this, function () {
    visibility.onClickEnd(this);
  }.bind(this));
}

Scroller.prototype.setInitialState = function () {
  var scrollerStyleToUse = scrollerStyle || window.__spotify.scroller_style;
  this.alwaysVisible = scrollerStyleToUse === 'always';

  this.scrollBarTrack = null;
  this.scrollBarThumb = null;

  this.isBody = this.view === document.body;
  this.viewId = this.view.getAttribute('data-scroll-area');
  this.viewHeight = 0;
  this.viewScrollHeight = 0;

  this.isVisible = false;
  this.isDragging = false;
  this.isMouseOver = false;
  this.isClickScrolling = false;
  this.isClickScrollAnimating = false;

  this.thumbTop = 0;
  this.thumbHeight = 0;

  this.clickTargetDirection = 'down';
  this.clickTargetThumbTop = 0;

  this.startDragMouseY = 0;
  this.startDragThumbTop = 0;

  this.hideTimer = 0;
  this.mouseOverShowTimer = 0;
};

Scroller.prototype.addScrollBar = function () {
  var track = document.createElement('div');
  var thumb = document.createElement('div');

  track.className = 'scrollbar-track';
  thumb.className = 'scrollbar-thumb';

  if (this.alwaysVisible) {
    track.className += ' always-visible';
  }

  // If the thumb is not set to draggable it will trigger focus events on
  // elements being dragged over. For example, dragging the thumb up to the
  // search input puts focus in the search input, which opens the suggest box.
  // Since we will find this element from the dragndrop module, we also need to
  // prevent any drag handling (find the drag listener further down).
  thumb.setAttribute('draggable', 'true');

  track.appendChild(thumb);
  this.view.appendChild(track);

  this.scrollBarTrack = track;
  this.scrollBarThumb = thumb;
};

Scroller.prototype.setViewSize = function () {
  // Hide the scroll bar while calculating sizes, so the scroll bar doesn't
  // interfere. This can happen if scrolled to the bottom of the scroll view and
  // the scroll height changes to be smaller. If the scroll bar is not hidden
  // while calculating the values here, the scrollHeight will not change, since
  // the scroll bar is taking up space.
  this.scrollBarTrack.style.display = 'none';

  if (this.isBody) {
    this.viewHeight = window.innerHeight || Infinity;
  } else {
    this.viewHeight = this.view.clientHeight || Infinity;
  }

  this.viewScrollHeight = this.view.scrollHeight;

  this.scrollBarTrack.style.display = 'block';
};

Scroller.prototype.setThumbSize = function () {
  var percentage = this.viewHeight / this.viewScrollHeight;
  this.thumbHeight = Math.max(40, this.viewHeight * percentage);
  this.scrollBarThumb.style.height = this.thumbHeight + 'px';
};

Scroller.prototype.setTrackPosition = function () {
  this.scrollBarTrack.style.transform = 'translate3d(0, ' + (this.view.scrollTop + 'px') + ', 0)';
};

Scroller.prototype.refresh = function () {
  this.refreshView();
  this.refreshScrollBar();
};

Scroller.prototype.refreshView = function () {
  this.setViewSize();
};

Scroller.prototype.refreshScrollBar = function () {
  this.setThumbSize();

  if (!this.isBody) {
    this.setTrackPosition();
  }
};

Scroller.prototype.update = function () {
  var oldViewHeight = this.viewHeight;
  var oldScrollHeight = this.viewScrollHeight;

  this.refresh();

  visibility.update(this);

  var newViewHeight = this.viewHeight;
  var newScrollHeight = this.viewScrollHeight;

  if (newViewHeight !== oldViewHeight || newScrollHeight !== oldScrollHeight) {
    visibility.highlight(this);
  }
};

Scroller.prototype.setScrollBarMode = function (mode) {
  this.alwaysVisible = mode === 'always';

  if (this.alwaysVisible) {
    this.scrollBarTrack.classList.add('always-visible');
  } else {
    this.scrollBarTrack.classList.remove('always-visible');
  }

  this._detachVisibility();
  this._detachPosition();
  this._detachDrag();
  this._detachClick();
  this._detachExpansion();

  this._detachVisibility = visibility.attach(this);
  this._detachPosition = position.attach(this);
  this._detachDrag = drag.attach(this);
  this._detachClick = click.attach(this);
  this._detachExpansion = expansion.attach(this);
};

Scroller.prototype.isInDOM = function () {
  var currentNode = this.view.parentNode;
  while (currentNode && currentNode !== document.documentElement) {
    currentNode = currentNode.parentNode;
  }

  // If we still have a current node after the loop, we found the document
  // element, which means it's in DOM.
  return !!currentNode;
};

Scroller.prototype.destroy = function () {
  var scrollObject = this.isBody ? window : this.view;

  scrollObject.removeEventListener('scroll', this._onScroll, false);

  window.removeEventListener('resize', this._onResize, false);

  this.scrollBarThumb.removeEventListener('dragstart', this._onThumbDragStart, true);

  this.view.removeAttribute('data-scroll-area-initialized', '');
  this.view.removeChild(this.scrollBarTrack);

  this._detachVisibility();
  this._detachPosition();
  this._detachDrag();
  this._detachClick();
  this._detachExpansion();
};

var isAttached = false;
var controlMessageSubscription;

exports.update = function (node) {
  if (!isAttached) {
    return;
  }

  // Clean up scrollers that are not in DOM anymore.
  scrollers = scrollers.filter(function (scroller) {
    if (!scroller.isInDOM()) {
      scroller.destroy();
      return false;
    }
    return true;
  });

  // Update all active scrollers
  for (var i = 0, l = scrollers.length; i < l; i++) {
    scrollers[i].update();
  }

  var selector = '[data-scroll-area]';
  var scrollViews = (node || document).querySelectorAll(selector);

  for (var i = 0, l = scrollViews.length; i < l; i++) {
    if (!scrollViews[i].hasAttribute('data-scroll-area-initialized')) {
      var scrollView = scrollViews[i];
      var isBody = scrollView === document.body;

      if (isBody && glue.getVersion() !== 2) {
        continue;
      }

      scrollers.push(new Scroller(scrollView));
    }
  }
};

exports.attach = function () {
  if (isAttached) return;
  isAttached = true;

  var setScrollBarMode = function setScrollBarMode(mode) {
    scrollerStyle = mode;

    for (var i = 0, l = scrollers.length; i < l; i++) {
      scrollers[i].setScrollBarMode(mode);
    }
  };

  controlMessageSubscription = cosmos.resolver.subscribe({
    url: 'sp://messages/v1/container/control'
  }, function (error, response) {
    if (!error) {
      var data = response.getJSONBody();
      if (data) {
        var styleWasChanged = true;
        switch (data.type) {
          case 'set_scroller_style_always_visible':
            setScrollBarMode('always');
            break;
          case 'set_scroller_style_overlay':
            setScrollBarMode('overlay');
            break;
          default:
            styleWasChanged = false;
        }

        // Fix a rendering bug in Chromium. When scroller style changes in the
        // system (changing system preference, connecting/disconnecting a mouse
        // etc), Chromium will render a white area where the scroll bar is
        // supposed to be. By adding and removing a class name we're triggering
        // a re-render and it will look good.
        //
        // https://jira.spotify.net/browse/KM-8285
        // http://crbug.com/538579
        if (styleWasChanged) {
          var performFix = function performFix() {
            var nodes = scrollers.map(function (scroller) {
              return scroller.view;
            });

            // Always include body to fix the main scroll, even if it doesn't
            // have a custom scroll bar.
            if (nodes.indexOf(document.body) === -1) {
              nodes.push(document.body);
            }

            for (var i = 0, l = nodes.length; i < l; i++) {
              nodes[i].classList.add('jmeBDLRW3CRWW3kZZaZ');
              nodes[i].classList.remove('jmeBDLRW3CRWW3kZZaZ');
            }
          };

          // Perform the fix twice (once with a delay), since it sometimes might
          // be slow and won't apply the fix on the first try.
          performFix();
          setTimeout(performFix, 1000);
        }
      }
    } else {
      controlMessageSubscription.cancel();
    }
  });
};

exports.detach = function () {
  if (!isAttached) return;
  isAttached = false;

  for (var i = 0, l = scrollers.length; i < l; i++) {
    scrollers[i].destroy();
  }
  scrollers.length = 0;

  scrollerStyle = null;

  if (controlMessageSubscription) {
    controlMessageSubscription.cancel();
    controlMessageSubscription = null;
  }
};

},{"../../spotify-glue-cat":156,"../center":77,"./click":103,"./drag":105,"./expansion":106,"./position":108,"./visibility":109,"spotify-cosmos-api":416}],108:[function(require,module,exports){
'use strict';

/**
 * Module for handling updating the scroll bar thumb position when scroll
 * position changes.
 *
 * @private
 */

module.exports = {

  setThumbPosition: function setThumbPosition(scroller) {
    if (scroller.viewScrollHeight === scroller.viewHeight) {
      scroller.thumbTop = 0;
    } else {
      scroller.thumbTop = scroller.view.scrollTop / (scroller.viewScrollHeight - scroller.viewHeight) * (scroller.viewHeight - scroller.thumbHeight);
    }

    scroller.scrollBarThumb.style.transform = 'translate3d(0, ' + (scroller.thumbTop + 'px') + ', 0)';
  },

  onScroll: function onScroll(scroller) {
    this.setThumbPosition(scroller);
  },

  attach: function attach(scroller) {
    var onScroll = this.onScroll.bind(this, scroller);

    var scrollObject = scroller.isBody ? window : scroller.view;
    scrollObject.addEventListener('scroll', onScroll, false);

    this.setThumbPosition(scroller);

    return function () {
      scrollObject.removeEventListener('scroll', onScroll, false);
    };
  }

};

},{}],109:[function(require,module,exports){
'use strict';

/**
 * Module for handling the visibility of the scroll bar, based on mouse position
 * and scroll events.
 *
 * @private
 */

var config = require('./config');

module.exports = {

  // Called from outside
  setHandler: function setHandler(eventName, scroller, handler) {
    if (eventName === 'show') {
      scroller._showHandler = handler;
    } else if (eventName === 'hide') {
      scroller._hideHandler = handler;
    }
  },

  refresh: function refresh(scroller) {
    if (scroller.viewScrollHeight > scroller.viewHeight) {
      this.showScrollBar(scroller);
    } else {
      this.hideScrollBar(scroller);
    }
  },

  showScrollBar: function showScrollBar(scroller) {
    if (scroller.isVisible) {
      return;
    }

    if (scroller.viewScrollHeight > scroller.viewHeight) {
      scroller.scrollBarTrack.classList.add('visible');
      scroller.isVisible = true;

      if (scroller._showHandler) {
        scroller._showHandler();
      }
    }
  },

  hideScrollBar: function hideScrollBar(scroller) {
    if (!scroller.isVisible || scroller.isDragging) {
      return;
    }

    scroller.scrollBarTrack.classList.remove('visible');
    scroller.isVisible = false;

    if (scroller._hideHandler) {
      scroller._hideHandler();
    }
  },

  startHideTimer: function startHideTimer(scroller) {
    this.stopHideTimer(scroller);
    scroller.hideTimer = setTimeout(this.hideScrollBar.bind(this, scroller), config.hideAfterMs);
  },

  stopHideTimer: function stopHideTimer(scroller) {
    clearTimeout(scroller.hideTimer);
  },

  // Called from outside
  onDragEnd: function onDragEnd(scroller) {
    if (!scroller.alwaysVisible && !scroller.isMouseOver) {
      this.startHideTimer(scroller);
    }
  },

  // Called from outside
  onClickEnd: function onClickEnd(scroller) {
    if (!scroller.alwaysVisible && !scroller.isMouseOver) {
      this.startHideTimer(scroller);
    }
  },

  onScroll: function onScroll(scroller) {
    if (!scroller.isVisible) {
      this.showScrollBar(scroller);
    }

    if (!scroller.isDragging && !scroller.isClickScrolling && !scroller.isMouseOver) {
      this.startHideTimer(scroller);
    }
  },

  onTrackMouseEnter: function onTrackMouseEnter(scroller, event) {
    if (event.target === scroller.scrollBarTrack) {
      scroller.isMouseOver = true;

      this.stopHideTimer(scroller);

      if (!scroller.isVisible) {
        scroller.mouseOverShowTimer = setTimeout(this.showScrollBar.bind(this, scroller), config.showAfterMs);
      }
    }
  },

  onTrackMouseLeave: function onTrackMouseLeave(scroller, event) {
    if (event.target === scroller.scrollBarTrack) {
      scroller.isMouseOver = false;

      if (!scroller.isDragging && !scroller.isClickScrolling) {
        clearTimeout(scroller.mouseOverShowTimer);

        if (scroller.isVisible) {
          this.startHideTimer(scroller);
        }
      }
    }
  },

  attach: function attach(scroller) {
    if (scroller.alwaysVisible) {
      this.refresh(scroller);

      return function () {};
    } else {
      this.hideScrollBar(scroller);

      var onScroll = this.onScroll.bind(this, scroller);
      var onTrackMouseEnter = this.onTrackMouseEnter.bind(this, scroller);
      var onTrackMouseLeave = this.onTrackMouseLeave.bind(this, scroller);

      var scrollObject = scroller.isBody ? window : scroller.view;
      scrollObject.addEventListener('scroll', onScroll, false);

      scroller.scrollBarTrack.addEventListener('mouseenter', onTrackMouseEnter, false);
      scroller.scrollBarTrack.addEventListener('mouseleave', onTrackMouseLeave, false);

      return function () {
        scrollObject.removeEventListener('scroll', onScroll, false);

        scroller.scrollBarTrack.removeEventListener('mouseenter', onTrackMouseEnter, false);
        scroller.scrollBarTrack.removeEventListener('mouseleave', onTrackMouseLeave, false);
      };
    }
  },

  update: function update(scroller) {
    if (scroller.alwaysVisible) {
      this.refresh(scroller);
    }
  },

  highlight: function highlight(scroller) {
    if (!scroller.alwaysVisible && !scroller.isVisible) {
      this.showScrollBar(scroller);
      this.startHideTimer(scroller);
    }
  }

};

},{"./config":104}],110:[function(require,module,exports){
/**
 * @module spotify-events/select
 */
'use strict';

var $ = require('../spotify-elements');
var center = require('./center');

var live = require('../spotify-live');

var ATTR_SELECT = 'select';
var ATTR_PROPERTY = 'select-property';
var SELECTOR_SELECT = '[data-' + ATTR_SELECT + ']';

// Stored nodes, used to not add listeners multiple times
var storedNodes = [];

/**
 * Handle a change on a select node.
 *
 * @param {MouseEvent} event Event object.
 * @param {Elements} elem An elements DOM node for the select.
 */
function handleChange(event, elem) {
  var property = elem.data(ATTR_PROPERTY);
  var node = elem[0];
  // If a property is set, update the model. That will later trigger
  // an update of the view and a change event on center will be sent.
  if (property) {
    publish(node, property);
    // If no property is set, just emit a change event on center.
  } else {
      emitUpdate(node, selectedValue(node));
    }
}

/**
 * Return the value attribute of the selected option
 *
 * @param {Elements} elem An elements DOM node for the select
 */
function selectedValue(node) {
  var selected = node.options[node.selectedIndex];
  return selected.value;
}

/**
 * Handle when a select-option event happens on center.
 *
 * @param {Object} event An object with data.
 */
function onSelectSet(event) {
  if (!event.id) return;

  var elem = $('[data-' + ATTR_SELECT + '=' + event.id + ']');
  if (!elem) return;

  var node = elem[0];
  var value = event.selected;

  // updating the node will trigger a DOM event,
  // delegated to handleChange in this module.
  var property = elem.data(ATTR_PROPERTY);

  if (property) {
    publish(node, property, value);
  } else {
    setState(node, value);
  }
}

/**
 * Publish new data to the live model. If no data-uri is found from
 * the passed node, nothing happens.
 *
 * @param {HtmlElement} node A DOM node for the select
 * @param {string} property A property name on the live model
 * @param {string=} opt_value Optional value to set the property to.
 *     If not provided, the selected option's value is fetched from the DOM.
 */
function publish(node, property, opt_value) {
  var uri = getUriFromNode(node);
  if (!uri) return;

  var model = live(uri);

  // If the model doesn't have a current value, we can't safely
  // set a new value without maybe being wrong.
  var value = model.get(property);
  if (value === undefined) return;

  var newValue = opt_value === undefined ? selectedValue(node) : opt_value;

  var data = {};
  data[property] = newValue;

  // Publishing the new value to the model will trigger the update
  // handler added here in this module to send an center event,
  // and update the DOM if needed.
  model.publish(data);
}

/**
 * Update the state of one select node.
 *
 * @param {HTMLElement} node A DOM node for the select.
 */
function updateNode(node) {
  if (storedNodes.indexOf(node) > -1) return;
  storedNodes.push(node);

  var elem = $(node);
  var property = elem.data(ATTR_PROPERTY);
  if (!property) return;

  var uri = getUriFromNode(node);
  if (!uri) return;

  var model = live(uri);

  model.get(property, function (error, value) {
    if (error) throw error;

    setState(node, value);

    model.on('update', function (properties) {
      if (property in properties) {
        setState(node, properties[property]);
      }
    });
  });
}

/**
 * Update a select node based on a value.
 *
 * @param {HTMLElement} node A DOM node for a select.
 * @param {string} value The value attribute of the option to select
 */
function setState(node, value) {
  updateNodeWithValue(node, value);
  emitUpdate(node, value);
}

/**
 * Update a select based on an option's value attribute
 *
 * @param {HTMLElement} node A DOM node for a select.
 * @param {string} value The value attribute of the option to select
 */
function updateNodeWithValue(node, value) {
  var selectElement = $(node);
  var optionElement = selectElement.find('option[value="' + value + '"]');
  if (optionElement && !optionElement.attribute('selected')) {
    optionElement.select();
  }
}

/**
 * Emit a change event on center. It will have the following format:
 * {
 *   element: HTMLElement,
 *   id: 'id from data-select attribute' || null,
 *   selected: the new selected value
 * }
 *
 * @param {HTMLElement} node A DOM node for a select.
 * @param {string} value Attribute of the selected option
 */
function emitUpdate(node, selected) {
  var id = $(node).data(ATTR_SELECT) || null;
  center.emit('select-change', {
    element: node,
    id: id,
    selected: selected
  });
}

/**
 * Get a URI from a node.
 *
 * @param {HTMLElement} node A DOM node.
 *
 * @return {string?} A URI string or null if not found.
 */
function getUriFromNode(node) {
  var stateNode = node.closest('[data-uri]');
  if (!stateNode) return null;
  return stateNode.getAttribute('data-uri');
}

var isAttached = false;

exports.update = function (opt_node) {
  if (!isAttached) return;

  var nodes = $(opt_node || document).search(SELECTOR_SELECT);
  if (!nodes) return;

  nodes.forEach(updateNode);
};

exports.attach = function () {
  if (isAttached) return;
  isAttached = true;

  var doc = $(document);
  doc.delegate('change', SELECTOR_SELECT, handleChange);

  center.on('select-set', onSelectSet);
};

exports.detach = function () {
  if (!isAttached) return;
  isAttached = false;

  var doc = $(document);
  doc.undelegate('change', SELECTOR_SELECT, handleChange);

  center.off('select-set', onSelectSet);
};

},{"../spotify-elements":70,"../spotify-live":251,"./center":77}],111:[function(require,module,exports){
/**
 * @module spotify-events/selection/containers
 * @private
 */
'use strict';

var $ = require('../../spotify-elements');
var live = require('../../spotify-live');

/**
 * Container DOM nodes.
 *
 * @type {Array.<HTMLElement>}
 */
var containers = [];

/**
 * Forget the known containers.
 */
function reset() {
  containers.length = 0;
}

/**
 * Update container storage based on the current DOM.
 */
function update() {
  var nodes = $(document).search(':not(.sticky-clone) > [data-list]');
  if (!nodes) return;

  // Don't drop any containers. If they are removed from the DOM we just keep
  // the reference along with the selection state at the same index. Clearing
  // has to be done manually instead.

  // Append new containers to the end of the list.
  nodes.forEach(function (container) {
    if (containers.indexOf(container) === -1) {
      containers.push(container);
    }
  });
}

/**
 * Get the number of rows in the container at the specified index.
 *
 * @param {number} index The container index.
 *
 * @return {number} The number of rows.
 */
function getContainerLength(index) {
  var container = $(containers[index]);
  if (!container) return 0;

  var uri = container.data('uri');
  if (!uri) return 0;

  var list = live(uri).get('rows');
  if (!list) return 0;

  return list.length;
}

/**
 * Get the index of a container based on URI.
 *
 * @param {string} uri The URI of the container.
 *
 * @return {number} The index of the container. Returns -1 if not found.
 */
function getContainerIndex(uri) {
  for (var i = 0, l = containers.length; i < l; i++) {
    var containerUri = getUri(i);
    if (containerUri === uri) return i;
  }

  return -1;
}

/**
 * Get the URI for a container.
 *
 * @param {number} index The container index.
 *
 * @return {string?} The URI or null if not found.
 */
function getUri(index) {
  var element = containers[index];
  var uri = element && element.getAttribute('data-uri');
  return uri || null;
}

/**
 * Get the URIs for all containers.
 *
 * @return {Array.<string?>} Array of URIs.
 */
function getUris() {
  var uris = [];
  for (var i = 0, l = containers.length; i < l; i++) {
    uris.push(getUri(i));
  }
  return uris;
}

/**
 * Get the live list for a container.
 *
 * @param {number} index The container index.
 *
 * @return {LiveList?} A live list or null if not found.
 */
function getLiveList(index) {
  var uri = getUri(index);
  var list = live(uri).get('rows');
  return list || null;
}

exports.elements = containers;
exports.reset = reset;
exports.update = update;
exports.getContainerLength = getContainerLength;
exports.getContainerIndex = getContainerIndex;
exports.getUri = getUri;
exports.getUris = getUris;
exports.getLiveList = getLiveList;

},{"../../spotify-elements":70,"../../spotify-live":251}],112:[function(require,module,exports){
(function (global){
/**
 * spotify-events/selection/controller
 * @private
 */
'use strict';

var $ = require('../../spotify-elements');
var intersection = require('mout/array/intersection');
var live = require('../../spotify-live');
var liburi = require('spotify-liburi');

var center = require('../center');
var selection = require('./index');
var model = require('./model');
var rows = require('./rows');
var containers = require('./containers');
var positions = require('./positions');
var Position = require('../util/Position');
var cosmos = require('../util/cosmos');

var focusEventValid = false;

// Listeners per URI (key is URI)
var listListeners = {};
var listListenerUris = [];

var SELECTABLE = '[data-list-item]';
var CLIPBOARD_ENDPOINT = 'sp://desktop/v1/clipboard';

/**
 * Check whether the event occured on the documentElement.
 *
 * @param {Event} event A event object.
 *
 * @return {boolean}
 */
function isOnDocument(event) {
  return event.target === document.documentElement;
}

/**
 * Get the row node from a mouse event.
 *
 * @param {MouseEvent} event A mouse event object.
 *
 * @return {HTMLElement} A DOM node.
 */
function getNodeFromEvent(event) {
  return event.target.closest(SELECTABLE);
}

/**
 * Check if a target is inside a filter component.
 *
 * @param {HTMLElement} target A DOM node.
 *
 * @return {boolean} Whether the target was inside a filter component.
 */
function isFilterTarget(target) {
  return target !== document && !!target.closest('[data-filter]');
}

/**
 * Handle a mousedown event.
 *
 * @param {MouseEvent|TouchEvent} event A mouse or touch event.
 * @param {boolean=} opt_isMouseUp Pass true if this is a simulated mousedown
 *     triggered by a mouseup event.
 */
function handleMouseDown(event, opt_isMouseUp) {
  if (isOnDocument(event)) return;

  focusEventValid = false;
  var node = getNodeFromEvent(event);
  if (node) {
    handleRowMouseDown(event, node, opt_isMouseUp);
  } else {
    handleOutsideMouseDown(event);
  }
}

/**
 * Handle when the mouse is pressed down on a list row.
 *
 * @param {MouseEvent|TouchEvent} event A mouse or touch event.
 * @param {HTMLElemtn} rowNode The DOM node for the clicked row.
 * @param {boolean=} opt_isMouseUp Pass true if this is a simulated mousedown
 *     triggered by a mouseup event.
 */
function handleRowMouseDown(event, rowNode, opt_isMouseUp) {
  var button = getButtonFromEvent(event);
  var isPrimaryButton = button === 1;

  // If we can't find a valid position for the DOM node, we can't handle
  // selection correctly.
  var position = positions.getFromNode(rowNode);
  if (!position) return;

  var isSelected = model.isSelected(position);
  var singleMultiSelect = isMac() ? event.metaKey : event.ctrlKey;
  var multiselect = event.shiftKey || singleMultiSelect;
  var singleClick = !event.shiftKey;

  if (!isMultiSelectEnabled()) {
    singleMultiSelect = multiselect = false;
    singleClick = true;
  }

  // Remove selection if a selected item is clicked with cmd/ctrl
  if (multiselect && singleClick && isSelected && isPrimaryButton) {

    // For multiselect, make sure we do the deselection only on mouseup
    if (!opt_isMouseUp) return;
    handleDeselectOnSingleMultiSelect(position);

    // Select multiple items if clicked with shift key
  } else if (!singleClick) {

      // Optimize by doing this only on mousedown
      if (opt_isMouseUp) return;
      handleShiftMultiSelect(position);

      // Select a single item
    } else {

        // Handle the case when the primary button is pressed down on a selected item.
        // The method will be called once again in that case, on mouse up. This is
        // to allow the drag and drop to abort the selection change.

        // So we do the actual selection on mouseup, where we know it's not a drag n drop thing.
        if (isPrimaryButton && isSelected && !opt_isMouseUp) {
          return;
        }
        // For multiselect, make sure we do the selection only on mouseup
        if (multiselect && !opt_isMouseUp) {
          return;
        }

        handleSingleSelect(position, event, opt_isMouseUp);
      }
  rows.update();
}

/**
 * Handle when the mouse is pressed down outside a list row.
 *
 * @param {MouseEvent} event A mouse event.
 */
function handleOutsideMouseDown(event) {
  var isSort = !!event.target.closest('[data-sort]');
  var isFilter = isFilterTarget(event.target);
  var hasSelection = model.hasSelection();

  // Deselect if clicked outside the list.
  // Clicking sort headers should just sort, not clear selection.
  if (!(isSort || isFilter) && hasSelection) {
    model.clear();
    rows.update();
  }
}

/**
 * Handle a focus event.
 *
 * @param {MouseEvent} event A mouse event.
 */
function handleFocus(event) {
  if (!focusEventValid) return;
  var node = getNodeFromEvent(event);
  if (node) {
    handleRowFocus(event, node);
  } else {
    handleOutsideFocus(event);
  }
  focusEventValid = false;
}

/**
 * Handle when a row receives focus.
 *
 * @param {MouseEvent} event A mouse event.
 * @param {HTMLElement} rowNode The DOM node for the focused row.
 */
function handleRowFocus(event, rowNode) {
  var position = positions.getFromNode(rowNode);

  // Invalid positions and already selected rows don't need to be handled
  if (!position || model.isSelected(position)) {
    return;
  }

  model.clear();
  model.add(position);
  model.setFocus(position);
  model.setOrigin(position);
  rows.update();
}

/**
 * Handle when an element outside the table receives focus.
 *
 * @param {MouseEvent} event A mouse event.
 */
function handleOutsideFocus(event) {
  if (isFilterTarget(event.target)) return;
  model.clear();
  rows.update();
}

/**
 * Handle when the mouse button is released.
 *
 * @param {MouseEvent|TouchEvent} event A mouse or touch event.
 */
function handleMouseUp(event) {
  if (isOnDocument(event)) return;

  handleMouseDown(event, true);
}

/**
 * Handle deselecting a currently selected row in a multi-select situation
 * (cmd/ctrl). This might mean that we need to adjust origin and focus as well.
 *
 * @param {Position} position Position clicked on.
 */
function handleDeselectOnSingleMultiSelect(position) {
  var origin = model.getOrigin();
  var focus = model.getFocus();
  var dir = positions.getDirection(origin, focus);

  // When removing the node that is both origin and focus, there will be no
  // direction in which the origin/focus could be moved. Like here:

  // Click A, CMD click C, CMD click B, CMD click B again.

  // Native desktop will now still have origin on B. MacOS Finder does move
  // origin but it's hard to know how it decides.

  // For a predictable behaviour, default to look downwards, and always reverse
  // the direction when no selected node is found.

  if (!dir) dir = 1;

  var isOrigin = position.isSame(origin);
  var isFocus = position.isSame(focus);
  var above, below;

  if (isOrigin || isFocus) {
    above = getClosestSelected(position, 'up');
    below = getClosestSelected(position, 'down');
  }

  // If direction is down (1), the next after origin is found below
  if (isOrigin) {
    model.setOrigin(dir === 1 ? below || above : above || below);
  }

  // If direction is down (1), the next after focus is found above
  if (position.isSame(focus)) {
    model.setFocus(dir === 1 ? above || below : below || above);
  }

  model.remove(position);
}

/**
 * Handle multi-selecting a range from the current focus to the new position.
 * This also handles deselecting as needed.
 *
 * @param {Position} position Position clicked on.
 */
function handleShiftMultiSelect(position) {
  var origin = model.getOrigin();
  var focus = model.getFocus();

  // Remove selection from origin to old focus.
  // If it's part of the new selection it will be re-added.
  if (origin && focus && !origin.isSame(focus)) {
    model.remove(origin, focus);
  }

  // If there is no origin, we will set the origin to the first selectable row
  if (!origin) {
    origin = new Position(0, 0);
    model.setOrigin(origin);
  }

  // Add selection from the current origin to the clicked position
  model.add(origin, position);
  model.setFocus(position);
}

/**
 * Handle a normal mousedown without any multi-select keys.
 *
 * @param {Position} position Position clicked on.
 * @param {MouseEvent|TouchEvent} event A mouse or touch event.
 * @param {boolean=} opt_isMouseUp Pass true if this is a simulated mousedown
 *     triggered by a mouseup event.
 */
function handleSingleSelect(position, event, opt_isMouseUp) {
  var origin = model.getOrigin();

  var button = getButtonFromEvent(event);
  var isPrimaryButton = button === 1;
  var isSecondaryButton = button === 2;

  var isSelected = model.isSelected(position);
  var singleMultiSelect = isMac() ? event.metaKey : event.ctrlKey;
  var multiselect = event.shiftKey || singleMultiSelect;

  if (!isMultiSelectEnabled()) {
    singleMultiSelect = multiselect = false;
  }

  // Left click without cmd/ctrl/shift clears selection.
  // Also right click on something that wasn't selected clears.
  var isRegularPrimary = !multiselect && isPrimaryButton;
  var isSelectedSecondary = !isSelected && isSecondaryButton;
  if (isRegularPrimary || isSelectedSecondary) {
    model.clear();
  }

  // Add item to selection
  model.add(position);
  model.setFocus(position, { isTouch: isTouchEvent(event) });

  // When adding to an existing selection, leave origin alone.
  var isNextToSelection;
  if (origin && !origin.isSame(position)) {
    var next = positions.getClosest(position, 'down');

    isNextToSelection = next && model.isSelected(next);
    if (!isNextToSelection) {
      var prev = positions.getClosest(position, 'up');
      isNextToSelection = prev && model.isSelected(prev);
    }
  }
  if (!isNextToSelection) {
    model.setOrigin(position);
  }
}

/**
 * Handler for when a key is pressed down in the list. Depending on the key,
 * this will either move the selection (up and down arrows), shrink/grow the
 * selection (shift up and down arrows) or clear the selection (escape key).
 *
 * @param {KeyboardEvent} event The event object.
 */
function handleKeyDown(event) {
  if (isFilterTarget(event.target)) return;

  focusEventValid = true;
  var isUp = event.keyCode === 38;
  var isDown = event.keyCode === 40;

  if (!isKeyboardNavEnabled()) return;

  if (!isUp && !isDown) return;

  var origin = model.getOrigin();
  var focus = model.getFocus();
  var next = focus;

  do {
    next = next && positions.getClosest(next, isDown ? 'down' : 'up');
  } while (next && model.isPositionHidden(next));

  // Only move the selection if the up or down key was pressed.
  // And only do it if the cmd/ctrl key is not also pressed.
  // The cmd/ctrl key will change the volume in the client.
  if ((isUp || isDown) && !event.metaKey && !event.ctrlKey && next) {

    // Multi-select must have a previous selection position
    if (event.shiftKey && isMultiSelectEnabled() && origin && focus) {
      var keyDirection = isDown ? 1 : -1;
      var direction = positions.getDirection(origin, focus);
      var isSingleRange = direction === 0;
      if (isSingleRange || keyDirection === direction) {
        model.add(next);
        scrollIntoView(next);
      } else {
        model.remove(focus);
      }

      // If multi-select can't be performed, just move the current selection
    } else {
        model.clear();
        model.add(next);
        model.setOrigin(next);
        scrollIntoView(next);
        event.preventDefault(); // Prevent normal scrolling
      }

    // Always set the new focus to the row above or below
    model.setFocus(next);
  }

  rows.update();
}

/**
 * Handle when a section of a list is scrolled into view.
 * This needs to update selection state of the row nodes.
 *
 * @param {Object} event Event object.
 */
function handleScrollShowAfter(event) {
  var node = event.pageNode && event.pageNode[0];
  rows.update(node);
}

/**
 * Handle setting which indices are hidden.
 *
 * @param {Object} data Object with properties `hiddenIndices` (array of
 *     indices) and `uri` (URI of the list).
 */
function handleSetHidden(data) {
  model.setHiddenIndices(data.indices, data.uri);
}

/**
 * Add a row to the selection based on a list URI.
 * TODO: Remove logic to handle global lists.
 *
 * @param {string} listUri The list URI.
 * @param {number} index The index within the list.
 * @param {boolean=} opt_doNotScrollIntoView Optionally skip scrolling added index into view
 */
function handleAddByUri(listUri, index, opt_doNotScrollIntoView) {
  var uriNodes = $('[data-uri=' + listUri + ']');
  var matches = intersection(containers.elements, uriNodes);

  if (!matches || matches.length < 1) {
    return;
  }

  var container = $(matches[0]);
  var containerIndex = container && containers.elements.indexOf(container[0]);
  var listIsPlayContext = container && container.matches('[data-context]');

  if (listIsPlayContext) {
    // Selection is not based on the global container that is defined via data-context,
    // so the indices need to be resolved to match the selection containers.
    var localPosition = positions.getPositionFromGlobalIndex(index);
    containerIndex = localPosition.containerIndex;
    index = localPosition.index;
  } else if (containerIndex === -1) {
    console && console.warn && console.warn('No container matching this uri was found or selection doesn\'t know ' + 'about the container. Possibly you need to run events.update.');
    return;
  }

  if (!isMultiSelectEnabled()) model.clear();

  var position = new Position(containerIndex, index);
  if (!model.getOrigin()) model.setOrigin(position);
  model.setFocus(position);
  model.add(position);

  rows.update();

  if (opt_doNotScrollIntoView !== true) {
    scrollIntoView(position);
  }
}

/**
 * Handle a select_all event from Cosmos.
 */
function handleSelectAll() {
  if (!isMultiSelectEnabled()) {
    return false;
  }

  model.clear();

  var first = new Position(0, 0);
  model.setOrigin(first);

  var last = positions.getLastPositionForSelectAll();
  model.setFocus(last);

  model.add(first, last);
  rows.update();
}

/**
 * Handle a copy event from Cosmos.
 */
function handleCopy() {
  cosmos.put({ url: CLIPBOARD_ENDPOINT, body: getSelectedUrls().join('\n') });
}

/**
 * Handle a cut event from Cosmos.
 */
function handleCut() {
  handleCopy();

  cosmos.post({ url: 'sp://messages/v1/container/control', body: { type: 'delete' } });
}

/**
 * Gets list of uris for selected rows
 *
 * @return {Array.<string>} Array of URIs.
 */
function handleGetUris() {
  var selections = model.selections;
  var uris = [];

  for (var container = 0; container < selections.length; container++) {
    var containerSelection = selections[container];
    if (!containerSelection) continue;

    var entity;

    var list = containers.getLiveList(container);
    if (!list) continue;

    // * Order the keys
    // Since the user can select tracks in any order,
    // the selection is an unordered set until we actually retrieve the
    // uris of the selection. In this case we want to get the uris
    // in the same order as they are shown in the list.
    var orderedSelectedKeys = list.keys.filter(function (key) {
      return !!containerSelection[key];
    });

    for (var i = 0, l = orderedSelectedKeys.length; i < l; i++) {
      var item = list.valueOf(orderedSelectedKeys[i]);
      if (!item) continue;

      entity = item.get('track');
      if (!entity) entity = item.get('playlist');
      if (!entity) entity = item.get('album');
      if (!entity) entity = item.get('artist');
      if (!entity) entity = item.get('user');
      if (!entity) entity = item;

      uris.push(entity.get('uri'));
    }
  }

  return uris;
}

/**
 * Returns the HTTPS urls of the selected rows
 *
 * @return {Array.<string>} Array of URLs.
 */
function getSelectedUrls() {
  var uris = handleGetUris();
  var urls = [];
  for (var i = 0; i < uris.length; i++) {
    var uriObj = liburi.from(uris[i]);
    if (uriObj) {
      urls.push(uriObj.toOpenURL());
    }
  }
  return urls;
}

/**
 * Get the mouse button number identifier from an event object.
 *
 * @param {MouseEvent|TouchEvent} event A mouse event.
 *
 * @return {number} A number representing the pressed button:
 *     0: No button pressed
 *     1: Primary button (usually left)
 *     2: Secondary button (usually right)
 *     3: Middle (usually the wheel)
 */
function getButtonFromEvent(event) {

  // Touches don't have buttons, so treat all touches as a primary button
  if (isTouchEvent(event)) {
    return 1;
  }

  switch (event.button) {
    case 0:
      return 1;
    case 2:
      return 2;
    case 1:
      return 3;
    default:
      return 0;
  }
}

/**
 * Check if the user agent is on a Mac.
 *
 * @return {boolean} True if Mac, false otherwise.
 */
function isMac() {
  if (!global.window) return false;
  if (!global.window.navigator) return false;
  var userAgent = global.window.navigator.userAgent || '';
  return userAgent.indexOf('Mac') > -1;
}

/**
 * Check if multi-select is enabled.
 * We currently disable it for the Web Player, since not much can be done with
 * a multi-selection there.
 *
 * @return {boolean} True if enabled, false otherwise.
 */
function isMultiSelectEnabled() {
  if ($('body').data('multi-select-disabled') !== null) return false;
  if (!global.window) return false;
  return !!global.window._getSpotifyModule;
}

/**
 * Check if keyboard selection is enabled.
 * If it's not enabled it is not possible to move the selection with arrow
 * keys or extend it with shift + arrow keys.
 *
 * @return {boolean} True if enabled, false otherwise.
 */
function isKeyboardNavEnabled() {
  return $('body').data('keyboard-select-disabled') === null;
}

/**
 * Check if the event is a touch event.
 *
 * @param {Event} event Event object.
 *
 * @return {boolean} True if it is a touch event object.
 */
function isTouchEvent(event) {
  return !!event.changedTouches;
}

/**
 * Get the closest selected position in the specified direction.
 *
 * @param {Position} position A position.
 * @param {string} direction The direction to search in: 'up' or 'down'.
 *
 * @return {Position?} A position or null if not found.
 */
function getClosestSelected(position, direction) {
  while (position) {
    position = positions.getClosest(position, direction);
    if (position && model.isSelected(position)) return position;
  }
  return null;
}

/**
 * Scroll the position into view.
 *
 * @param {Position} position A position.
 */
function scrollIntoView(position) {
  var container = containers.elements[position.containerIndex];
  var scrollContainer = container && container.querySelector('[data-scroll-container]');
  if (scrollContainer) {
    center.emit('scroll-to-index', scrollContainer, position.index);
  } else {
    var node = positions.getNodeFromPosition(position);
    if (!node) return;

    var offset = node.getBoundingClientRect().top;
    if (offset < 0 || offset >= window.innerHeight) {
      node.scrollIntoView(offset < 0);
    }
  }
}

/**
 * Update the list listeners for the current containers.
 */
function updateListListeners() {
  var uris = containers.getUris();

  for (var i = 0, l = uris.length; i < l; i++) {
    var uri = uris[i];
    if (uri && listListenerUris.indexOf(uri) === -1) {
      var list = live(uri).get('rows');
      if (list) {
        var listener = createListListener(uri);
        list.on('update', listener);
        listListeners[uri] = listener;
        listListenerUris.push(uri);
      }
    }
  }
}

/**
 * Create an event listener for list updates.
 * When an update happens, the selection model will be updated for the right
 * container.
 *
 * @param {string} uri A URI for a list.
 *
 * @return {function} A listener function.
 */
function createListListener(uri) {
  return function (operations) {
    var uris = containers.getUris();
    var containerIndex = uris.indexOf(uri);
    if (containerIndex > -1) {

      // If something was removed from the list, we must update the selection
      // state, as something that was selected might have been removed.
      // Insert and move operations don't affect the current selection state,
      // as everything is based on row IDs, which don't change.
      for (var i = 0, l = operations.length; i < l; i++) {
        var operation = operations[i];
        if (operation.type === 'remove') {
          model.updateContainer(containerIndex);
          break;
        }
      }

      // Update the rows visually based on the model state
      rows.update();
    }
  };
}

/**
 * Remove all list listeners.
 */
function resetListListeners() {
  for (var i = 0, l = listListenerUris.length; i < l; i++) {
    var uri = listListenerUris[i];
    var listener = listListeners[uri];
    var list = live(uri).get('rows');
    if (list && listener) {
      list.off('update', listener);
      delete listListeners[uri];
      listListenerUris.splice(i, 1);
      i--;l--;
    }
  }
}

function handleListSwap(event) {
  var rowsListBefore = live(event.before).get('rows');
  if (!rowsListBefore) return;

  var selectionBefore = selection.getIndicesPerList().filter(function (indicesPerList) {
    return indicesPerList.uri === event.before;
  })[0];

  var selectedKeysBefore = [];
  if (selectionBefore) {
    selectedKeysBefore = selectionBefore.indices.map(function (index) {
      return rowsListBefore.keys[index];
    });
  }

  center.on('scroll-reset', function onScrollReset() {
    center.off('scroll-reset', onScrollReset);

    live(event.after).get('rows', function (error, rowsListAfter) {
      selectedKeysBefore.forEach(function (selectedKeyBefore) {
        var indexAfter = rowsListAfter.keys.indexOf(selectedKeyBefore);
        if (indexAfter !== -1) {
          handleAddByUri(event.after, indexAfter, true);
        }
      });
    }, live.ASAP);
  });
}

exports.handleMouseDown = handleMouseDown;
exports.handleMouseUp = handleMouseUp;
exports.handleKeyDown = handleKeyDown;
exports.handleFocus = handleFocus;
exports.handleScrollShowAfter = handleScrollShowAfter;
exports.handleSetHidden = handleSetHidden;
exports.handleAddByUri = handleAddByUri;
exports.handleSelectAll = handleSelectAll;
exports.handleCopy = handleCopy;
exports.handleCut = handleCut;
exports.handleGetUris = handleGetUris;
exports.updateListListeners = updateListListeners;
exports.resetListListeners = resetListListeners;
exports.handleListSwap = handleListSwap;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../spotify-elements":70,"../../spotify-live":251,"../center":77,"../util/Position":126,"../util/cosmos":128,"./containers":111,"./index":113,"./model":114,"./positions":115,"./rows":116,"mout/array/intersection":358,"spotify-liburi":426}],113:[function(require,module,exports){
/**
 * spotify-events/selection
 */
'use strict';

var $ = require('../../spotify-elements');
var live = require('../../spotify-live');
var getOriginUri = require('../../spotify-live-wrapped-uri').getOriginUri;

var center = require('../center');
var controller = require('./controller');
var containers = require('./containers');
var model = require('./model');
var rows = require('./rows');
var positions = require('./positions');
var Position = require('../util/Position');
var appUtil = require('../util/app');

var cosmos = require('../util/cosmos');

var controlMessageSubscription;

/**
 * Attach event listeners etc.
 */
exports.attach = function () {
  var doc = $(document);
  doc.on('mousedown', controller.handleMouseDown);
  doc.on('touchstart', controller.handleMouseDown);
  doc.on('mouseup', controller.handleMouseUp);
  doc.on('touchend', controller.handleMouseUp);
  doc.on('keydown', controller.handleKeyDown);
  doc.on('focus', controller.handleFocus, true);

  center.on('scroll-show-after', controller.handleScrollShowAfter);
  center.on('selection-set-hidden', controller.handleSetHidden);
  center.on('list-swap', controller.handleListSwap);

  // Creating an "intentional bug".. By switching to use row IDs internally
  // for the selection model, we no longer need to manually update indices
  // as long as the new list has the same IDs (which we require anyway for
  // other reasons). We stopped using this event a long time ago anyway,
  // because it never really worked without odd behaviors. I've done a
  // code search (indexed Nov 23 2014), and there is not a single place
  // where this event is used, except in old versions of spotify-events,
  // which is not a problem. Technically, not responding to this event
  // is a breaking change, but for simplicity's sake let's stop handling it.
  // Fixing code that never gets used just for the sake of it makes no sense.
  // If someone really needs this in the future, we can fix it then.
  // So, this line should be commented for now.
  //
  // center.on('update-indices', controller.handleUpdateIndices);

  controlMessageSubscription = cosmos.subscribe({ url: 'sp://messages/v1/container/control' }, function (error, response) {
    if (error) throw error;
    var data = response.body;
    if (data && appUtil.isActiveAndFocused()) {
      if (data.type === 'select_all') {
        controller.handleSelectAll();
      } else if (data.type === 'copy') {
        controller.handleCopy();
      } else if (data.type === 'cut') {
        controller.handleCut();
      }
    }
  });
};

/**
 * Detach event listeners etc.
 */
exports.detach = function () {
  var doc = $(document);
  doc.off('mousedown', controller.handleMouseDown);
  doc.off('touchstart', controller.handleMouseDown);
  doc.off('mouseup', controller.handleMouseUp);
  doc.off('touchend', controller.handleMouseUp);
  doc.off('keydown', controller.handleKeyDown);
  doc.off('focus', controller.handleFocus, true);

  center.off('scroll-show-after', controller.handleScrollShowAfter);
  center.off('selection-set-hidden', controller.handleSetHidden);
  center.off('list-swap', controller.handleListSwap);

  // See comment in `attach` for the long story why this is commented.
  // center.off('update-indices', controller.handleUpdateIndices);

  if (controlMessageSubscription) {
    controlMessageSubscription.cancel();
    controlMessageSubscription = null;
  }
};

/**
 * Update the module based on the current DOM state.
 */
exports.update = function () {
  containers.update();
  controller.updateListListeners();
};

/**
 * Add a row to the selection based on a list URI.
 *
 * @param {string} listUri The list URI.
 * @param {number} index The index within the list.
 */
exports.add = function (listUri, index) {
  controller.handleAddByUri(listUri, index);
};

/**
 * Check if the selection has any holes (contains many ranges).
 *
 * @return {boolean} True if it has holes, false otherwise.
 */
exports.hasHoles = function () {
  return model.hasHoles();
};

/**
 * Check if the row node is selected.
 *
 * @param {HTMLElement|Elements} node A DOM node for a row.
 *
 * @return {boolean} True if it is selected, false otherwise.
 */
exports.isNodeSelected = function (node) {
  node = 'innerHTML' in node ? node : node[0];
  if (!node) return false;

  var position = positions.getFromNode(node);
  if (!position) return false;

  return model.isSelected(position);
};

/**
 * Reset the selection state and its knowledge of any containers.
 */
exports.reset = function () {
  controller.resetListListeners();
  model.reset();
  rows.update();
  containers.reset();
};

/**
 * Clear the current selection.
 */
exports.clear = function () {
  model.clear();
  rows.update();
};

/**
 * Set the origin to a new position.
 *
 * @param {number} containerIndex The index of the container.
 * @param {number} index The index within the container.
 */
exports.setOrigin = function (containerIndex, index) {
  model.setOrigin(new Position(containerIndex, index));
};

/**
 * Set the focus to a new position.
 *
 * @param {number} containerIndex The index of the container.
 * @param {number} index The index within the container.
 */
exports.setFocus = function (containerIndex, index) {
  model.setFocus(new Position(containerIndex, index));
};

/**
 * Get the current origin position.
 *
 * @return {Object?} An object with numeric properties `containerIndex`
 *     and `index`, or null if no origin is set.
 */
exports.getOrigin = function () {
  var origin = model.getOrigin();
  if (!origin) return null;
  return {
    containerIndex: origin.containerIndex,
    index: origin.index
  };
};

/**
 * Get the current focus position.
 *
 * @return {Object?} An object with numeric properties `containerIndex`
 *     and `index`, or null if no origin is set.
 */
exports.getFocus = function () {
  var focus = model.getFocus();
  if (!focus) return null;
  return {
    containerIndex: focus.containerIndex,
    index: focus.index
  };
};

/**
 * Get all selected indices organized by list.
 *
 * @return {Array.<Object>} Array of objects of this structure:
 *     {
 *       containerIndex: 0,
 *
 *       // This is the list in the UI (could be sorted or unsorted)
 *       uri: 'spotify:internal:sortlist:asc:track(name):list',
 *       keys: ['c', 'd', 'e', 'j', 'o', 't'],
 *       indices: [3, 4, 5, 10, 15, 20], // Ordered indices in the list
 *
 *       // If all items between two selected items are hidden, they will be
 *       // included here to allow nice ranges to be created from this. It will
 *       // also include hidden items right after the last selected item.
 *       keysWithHidden: ['c', 'd', 'e', 'j', 'k', 'l', 'm', 'n', 'o', 't'],
 *       indicesWithHidden: [3, 4, 5, 10, 11, 12, 13, 14, 15, 20],
 *
 *       // Optional object for the unsorted list if the list is a sorted list
 *       origin: {
 *         uri: 'spotify:list',
 *         keys: ['c', 'd', 'e', 'j', 'o', 't'],
 *         indices: [7, 19, 8, 14, 0, 9] // Unordered indices in the original list
 *       }
 *     }
 */
exports.getIndicesPerList = function () {
  var selections = model.selections;
  var indicesPerList = [];

  for (var i = 0; i < selections.length; i++) {
    var containerSelection = selections[i];
    if (containerSelection && Object.keys(containerSelection).length) {

      var uri = containers.getUri(i);
      if (!uri) continue;

      var list = containers.getLiveList(i);
      if (!list) continue;

      var indices = model.getIndicesForContainer(i);
      if (!indices) continue;

      var keys = indices.map(function (selectedIndex) {
        return list.keys[selectedIndex];
      });

      var indicesWithHidden = model.getIndicesWithHiddenForContainer(i);
      var keysWithHidden = indicesWithHidden.map(function (selectedIndex) {
        return list.keys[selectedIndex];
      });

      var context = {
        containerIndex: i,
        uri: uri,
        indices: indices,
        keys: keys,
        indicesWithHidden: indicesWithHidden,
        keysWithHidden: keysWithHidden
      };

      var originUri = getOriginUri(uri);
      if (originUri) {
        var wrappedList = live(uri).get('rows');
        var originList = live(originUri).get('rows');

        var originIndices;
        var originKeys;
        if (wrappedList && originList) {
          var key;
          var originListKeyIndexMap = {};
          originIndices = new Array(indices.length);
          originKeys = new Array(indices.length);

          for (var i = 0, keys = originList.keys; i < keys.length; i++) {
            originListKeyIndexMap[keys[i]] = i;
          };

          for (var j = 0; j < indices.length; j++) {
            key = wrappedList.keys[indices[j]];
            originIndices[j] = originListKeyIndexMap[key];
            originKeys[j] = originList.keys[originIndices[j]];
          }
        }
        context.origin = {
          uri: originUri,
          indices: originIndices || [],
          keys: originKeys || []
        };
      }

      indicesPerList.push(context);
    }
  }

  return indicesPerList;
};

/**
 * Get all selected indices relative to the full page (across all containers).
 *
 * @return {Object?} The value null if no global context is found or if found,
 *     an object of this structure:
 *     {
 *       uri: 'spotify:context:uri',
 *       indices: [0, 3, 56, 120],
 *
 *       // These elements are Elements instances from the 'elements' npm
 *       // package. This should be fixed in a future major version, to be
 *       // normal HTML elements.
 *       containers: [
 *         containerElement1,
 *         containerElement1,
 *         containerElement4,
 *         containerElement5
 *       ]
 *     }
 */
exports.getIndicesGlobal = function () {
  var selections = model.selections;
  var elements = containers.elements;
  var indices = [];
  var selectionContainers = [];

  if (elements.length === 0) {
    return null;
  }
  var contextUriContainer = elements[0].closest('[data-context]');
  var contextUri = contextUriContainer && contextUriContainer.getAttribute('data-uri');

  if (!contextUri) return null;

  for (var container = 0; container < selections.length; container++) {
    var containerSelection = selections[container];
    var list = containers.getLiveList(container);
    if (list && containerSelection) {

      var orderedSelectedKeys = list.keys.filter(function (key) {
        return !!containerSelection[key];
      });

      for (var i = 0, l = orderedSelectedKeys.length; i < l; i++) {
        var j = list.keys.indexOf(orderedSelectedKeys[i]);
        indices.push(positions.getGlobalIndexFromPosition(new Position(container, j)));
        selectionContainers.push($(elements[container]));
      }
    }
  }

  return {
    uri: contextUri,
    indices: indices,
    containers: selectionContainers
  };
};

/**
 * Get the URI of all selected rows.
 *
 * @return {Array.<string>} Array of URIs.
 */
exports.getUris = function () {
  return controller.handleGetUris();
};

/**
 * Get the nodes for all selected rows that can be found.
 *
 * @return {Array.<HTMLElement>} Array of DOM nodes.
 */
exports.getNodes = function () {
  return rows.getSelectedRows();
};

},{"../../spotify-elements":70,"../../spotify-live":251,"../../spotify-live-wrapped-uri":250,"../center":77,"../util/Position":126,"../util/app":127,"../util/cosmos":128,"./containers":111,"./controller":112,"./model":114,"./positions":115,"./rows":116}],114:[function(require,module,exports){
/**
 * @module spotify-events/selection/model
 * @private
 */
'use strict';

var live = require('../../spotify-live');
var Range = require('../../spotify-range2');
var containers = require('./containers');
var positions = require('./positions');
var Position = require('../util/Position');

/**
 * Selections for all known containers.
 * Each container's selection space is represented as an object where keys are
 * row IDs. This allows for quick lookups.
 *
 * @type {Array.<Object.<string, boolean>>}
 */
var selections = [];

/**
 * Hidden items for all known containers.
 * Each container is represented as an object where keys are row IDs. This
 * allows for quick lookups.
 *
 * @type {Object.<number, Object.<string, boolean>>}
 */
var hiddenKeysPerContainer = {};

var originContainerIndex = null;
var originKey = null;
var focusContainerIndex = null;
var focusKey = null;
var focusIsTouch = false;

/**
 * Get the current origin.
 *
 * @return {Position?} The origin position or null if not set.
 */
function getOrigin() {
  if (originContainerIndex === null) return null;
  if (originKey === null) return null;

  var list = containers.getLiveList(originContainerIndex);
  if (list) {
    var index = list.keys.indexOf(originKey);
    if (index === -1) return null;
    var position = new Position(originContainerIndex, index);
    return position;
  }
  return null;
}

/**
 * Get the current focus. This is the position for the keyboard focus.
 *
 * @return {Position?} The focus position or null if not set.
 */
function getFocus() {
  if (focusContainerIndex === null) return null;
  if (focusKey === null) return null;

  var list = containers.getLiveList(focusContainerIndex);
  if (list) {
    var index = list.keys.indexOf(focusKey);
    var position = new Position(focusContainerIndex, index);
    return position;
  }
  return null;
}

/**
 * Set the current origin.
 *
 * @param {Position?} position A position or null if removing the origin.
 */
function setOrigin(position) {
  if (position) {
    var list = containers.getLiveList(position.containerIndex);
    if (list) {
      originContainerIndex = position.containerIndex;
      originKey = list.keys[position.index] || null;
      return;
    }
  }

  originContainerIndex = null;
  originKey = null;
}

/**
 * Set the current focus.
 *
 * @param {Position?} position A position or null if removing the focus.
 */
function setFocus(position, options) {
  focusIsTouch = !!(options && options.isTouch);

  if (position) {
    var list = containers.getLiveList(position.containerIndex);
    if (list) {
      focusContainerIndex = position.containerIndex;
      focusKey = list.keys[position.index];
      return;
    }
  }

  focusContainerIndex = null;
  focusKey = null;
}

/**
 * Check if the current focus was triggered by a touch.
 * This is done since we might want to have different styles for selection focus
 * when triggered by a touch event.
 *
 * @return {boolean} True if triggered by touch.
 */
function wasFocusTriggeredByTouch() {
  return focusIsTouch;
}

/**
 * Handle setting which indices are hidden.
 *
 * @param {Array.<number>} hiddenIndices Array of indices that are hidden.
 * @param {string} containerUri The URI of the container.
 */
function setHiddenIndices(hiddenIndices, containerUri) {
  var list = live(containerUri).get('rows');
  if (list) {
    var keys = list.keys;
    var hiddenKeys = {};
    for (var i = 0, l = hiddenIndices.length; i < l; i++) {
      var key = keys[hiddenIndices[i]];
      if (key) hiddenKeys[key] = true;
    }

    var containerIndex = containers.getContainerIndex(containerUri);

    hiddenKeysPerContainer[containerIndex] = hiddenKeys;

    updateContainer(containerIndex);
  }
}

/**
 * Check if given position is hidden.
 *
 * @param {Position} from The position to check.
 * @return {boolean} True if position is hidden.
 */
function isPositionHidden(pos) {
  var idsPerContainer = getIds(pos, pos);
  var id = idsPerContainer[0][0];
  var hiddenKeys = hiddenKeysPerContainer[pos.containerIndex];
  return hiddenKeys && hiddenKeys[id];
}

/**
 * Add rows to the selection.
 *
 * @param {Position} from The start position to add.
 * @param {Position=} opt_to The end position to add. If not provided, it will
 *     only add a single row to the selection.
 */
function add(from, opt_to) {
  var to = opt_to || from;

  // Flip the positions if the direction is up.
  if (positions.getDirection(from, to) === -1) {
    var temp = from;
    from = to;
    to = temp;
  }

  var idsPerContainer = getIds(from, to);

  for (var i = 0, l = idsPerContainer.length; i < l; i++) {
    var containerIndex = from.containerIndex + i;
    var selected = selections[containerIndex] || (selections[containerIndex] = Object.create(null));
    var ids = idsPerContainer[i];
    var hiddenKeys = hiddenKeysPerContainer[containerIndex];

    // Set all new items as selected, unless they're hidden
    for (var j = 0, id; id = ids[j]; j++) {
      if (!hiddenKeys || !hiddenKeys[id]) {
        selected[id] = true;
      }
    }
  }
}

/**
 * Remove rows from the selection.
 *
 * @param {Position} from The start position to remove.
 * @param {Position=} opt_to The end position to remove. If not provided, it will
 *     only remove a single row from the selection.
 */
function remove(from, opt_to) {
  var to = opt_to || from;

  // Flip the positions if the direction is up.
  if (positions.getDirection(from, to) === -1) {
    var temp = from;
    from = to;
    to = temp;
  }

  var idsPerContainer = getIds(from, to);

  for (var i = 0, l = idsPerContainer.length; i < l; i++) {
    var containerIndex = from.containerIndex + i;
    var selected = selections[containerIndex] || (selections[containerIndex] = Object.create(null));
    var ids = idsPerContainer[i];

    // Loop the row ids that are to be removed and remove them from the selection.
    // That's usually faster than looping the selection since there's no UI for
    // removing a big chunk of selection in one go.
    for (var j = 0, id; id = ids[j]; j++) {
      delete selected[id];
    }
  }
}

/**
 * Clear the current selection.
 */
function clear() {
  selections.length = 0;
  setOrigin(null);
  setFocus(null);
}

/**
 * Reset the current selection state.
 */
function reset() {
  clear();
  hiddenKeysPerContainer = {};
}

/**
 * Update the model state based on the current state of the list.
 * If items were removed from the list, removed items that were selected
 * will be removed from selection state.
 */
function updateContainer(containerIndex) {
  var keys = selections[containerIndex];
  if (!keys) return;

  var list = containers.getLiveList(containerIndex);
  if (!list) return;

  for (var key in keys) {
    var hasKey = list.hasKey(key);
    var shouldDelete = !hasKey;
    if (!shouldDelete) {
      var hiddenKeys = hiddenKeysPerContainer[containerIndex];
      var shouldDelete = hiddenKeys ? hiddenKeys[key] : false;
    }
    if (shouldDelete) {
      delete keys[key];
    }
  }
}

/**
 * Get ranges for the provided global range.
 *
 * @param {Position} from The start position.
 * @param {Position} to The end position. This position must be below the
 *     `from` position.
 *
 * @return {Array.<Range>} Array of ranges. There will be one range per
 *     matching container.
 */
function getRanges(from, to) {
  var ranges = [];

  var fromContainer = from.containerIndex;
  var toContainer = to.containerIndex;

  for (var i = fromContainer; i <= toContainer; i++) {
    var fromIndex = i === fromContainer ? from.index : 0;
    var toIndex;
    if (i === toContainer) {
      toIndex = to.index;
    } else {
      var containerLength = containers.getContainerLength(i);
      if (containerLength > 0) {
        toIndex = containerLength - 1;
      }
    }

    if (toIndex === undefined) {
      ranges.push(new Range(0, 0));
    } else {
      ranges.push(new Range(fromIndex, toIndex + 1));
    }
  }

  return ranges;
}

/**
 * Get IDs for the provided global range.
 *
 * @param {Position} from The start position.
 * @param {Position} to The end position. This position must be below the
 *     `from` position.
 *
 * @return {Array.<Array.<string>>} Array of IDs per container.
 */
function getIds(from, to, opt_keys) {
  var idsPerContainer = [];

  var fromContainer = from.containerIndex;
  var toContainer = to.containerIndex;

  for (var i = fromContainer; i <= toContainer; i++) {
    var fromIndex = i === fromContainer ? from.index : 0;
    var toIndex;
    if (i === toContainer) {
      toIndex = to.index;
    } else {
      var containerLength = containers.getContainerLength(i);
      if (containerLength > 0) {
        toIndex = containerLength - 1;
      }
    }

    if (toIndex === undefined) {
      idsPerContainer.push([]);
    } else {
      var ids = [];
      idsPerContainer.push(ids);

      var containerUri = containers.getUri(i);
      var list = live(containerUri).get('rows');
      if (list) {
        var keys = list.keys;

        for (var n = fromIndex; n < toIndex + 1; n++) {
          ids.push(keys[n]);
        }
      }
    }
  }

  return idsPerContainer;
}

/**
 * Check if the position is selected.
 *
 * @param {Position} position A position.
 *
 * @return {boolean} True if it is selected, false otherwise.
 */
function isSelected(position) {

  // Get the ranges of the according container
  var keys = selections[position.containerIndex];
  if (!keys) return false;

  // Check if the row is within the selected ranges for the container
  var list = containers.getLiveList(position.containerIndex);
  if (list) {
    var key = list.keys[position.index];
    return !!keys[key];
  }

  return false;
}

/**
 * Check if the selection has any holes (contains many ranges).
 *
 * @return {boolean} True if it has holes, false otherwise.
 */
function hasHoles() {
  var rangeCount = 0;

  for (var containerIndex = 0; containerIndex < selections.length; containerIndex++) {
    var containerSelection = selections[containerIndex];
    var list = containers.getLiveList(containerIndex);

    var keys = Object.keys(containerSelection);

    // A selection in more than one container means the selection has holes
    if (keys.length > 0) {
      rangeCount++;

      // Also more than one range in only one container means it has holes.
      if (list) {
        var indices = [];
        for (var j = 0, len = keys.length; j < len; j++) {
          indices.push(list.indexOf(keys[j]));
        }
        indices.sort(function (a, b) {
          return a - b;
        });
        var previousIndex;
        for (var i = 0, l = indices.length; i < l; i++) {
          var index = indices[i];
          if (i > 0 && index > previousIndex + 1) {
            rangeCount++;
            break;
          }
          previousIndex = index;
        }
      }
    }
    if (rangeCount > 1) return true;
  }

  return false;
}

/**
 * Check if there is any selection in any container.
 *
 * @return {boolean} True if there is a selection.
 */
function hasSelection() {
  for (var i = 0, l = selections.length; i < l; i++) {
    if (selections[i] && Object.keys(selections[i]).length > 0) {
      return true;
    }
  }

  return false;
}

/**
 * Get the selected indices for a container.
 *
 * @param {number} containerIndex The container index.
 *
 * @return {Array.<number>?} An array of indices or null if nothing is selected.
 */
function getIndicesForContainer(containerIndex) {
  var unorderedKeys = selections[containerIndex];
  if (!unorderedKeys) return null;
  var indices = [];

  var list = containers.getLiveList(containerIndex);

  var orderedKeys = list.keys.filter(function (key) {
    return !!unorderedKeys[key];
  });

  if (list && orderedKeys.length) {
    if (orderedKeys.length > 1) {
      // indexOfMany() is much more perfomant for big selections
      indices = list.indexOfMany(orderedKeys);
    } else {
      // for a single selected item, indexOf() is a little bit more perfomant
      indices = [list.indexOf(orderedKeys[0])];
    }
  }

  return indices.length ? indices : null;
}

/**
 * Get the selected indices for a container, including hidden items that join
 * two ranges. For example, in a list [A, B, C, D, E, F, G, H], everything is
 * selected except C, D, F and G. There are hidden items, C, D, F and G. This
 * method would then return the indices of all items except H,
 * [0, 1, 2, 3, 4, 5, 6]. It does include hidden items right after the last
 * selected one.
 *
 * @param {number} containerIndex The container index.
 *
 * @return {Array.<number>?} An array of indices or null if nothing is selected.
 */
function getIndicesWithHiddenForContainer(containerIndex) {
  var indices = getIndicesForContainer(containerIndex);
  if (!indices) return null;

  var hiddenKeys = hiddenKeysPerContainer[containerIndex];
  if (!hiddenKeys) return indices;

  var ranges = Range.fromIndices(indices);
  if (ranges.length === 1) return indices;

  var list = containers.getLiveList(containerIndex);
  if (!list) return indices;

  var hiddenIds = Object.keys(hiddenKeys);
  var hiddenIndices = [];

  if (hiddenIds.length) {
    if (hiddenIds.length > 1) {
      // indexOfMany() is much more perfomant for big selections
      hiddenIndices = list.indexOfMany(hiddenIds);
    } else {
      // for a single selected item, indexOf() is a little bit more perfomant
      hiddenIndices = [list.indexOf(hiddenIds[0])];
    }
  }

  hiddenIndices = hiddenIndices.filter(function (index) {
    return index > -1;
  });

  var hiddenRanges = Range.fromIndices(hiddenIndices);
  var hiddenStarts = hiddenRanges.map(function (range) {
    return range.start;
  });
  var hiddenEnds = hiddenRanges.map(function (range) {
    return range.end;
  });

  for (var i = 0, l = ranges.length; i < l; i++) {
    var range = ranges[i];
    var nextRange = ranges[i + 1];

    var indexOfRange = hiddenStarts.indexOf(range.end);
    if (indexOfRange > -1) {
      var hiddenEnd = hiddenEnds[indexOfRange];
      if (!nextRange || hiddenEnd === nextRange.start) {
        var hiddenIndicesInRange = hiddenRanges[indexOfRange].toIndices();
        if (hiddenIndicesInRange.length > 0) {
          indices = indices.concat(hiddenIndicesInRange);
        }
      }
    }
  }

  indices.sort(function (a, b) {
    return a - b;
  });

  return indices.length ? indices : null;
}

exports.selections = selections;
exports.getOrigin = getOrigin;
exports.getFocus = getFocus;
exports.setOrigin = setOrigin;
exports.setFocus = setFocus;
exports.wasFocusTriggeredByTouch = wasFocusTriggeredByTouch;
exports.setHiddenIndices = setHiddenIndices;
exports.isPositionHidden = isPositionHidden;
exports.add = add;
exports.remove = remove;
exports.clear = clear;
exports.reset = reset;
exports.updateContainer = updateContainer;
exports.isSelected = isSelected;
exports.hasHoles = hasHoles;
exports.hasSelection = hasSelection;
exports.getIndicesForContainer = getIndicesForContainer;
exports.getIndicesWithHiddenForContainer = getIndicesWithHiddenForContainer;

},{"../../spotify-live":251,"../../spotify-range2":289,"../util/Position":126,"./containers":111,"./positions":115}],115:[function(require,module,exports){
/**
 * @module spotify-events/selection/positions
 * @private
 */
'use strict';

var $ = require('../../spotify-elements');

var containers = require('./containers');
var Position = require('../util/Position');

/**
 * Get the closest position in the specified direction.
 *
 * @param {Position} position A position.
 * @param {string} direction The direction to search in: 'up' or 'down'.
 *
 * @return {Position?} A position or null if not found.
 */
function getClosest(position, direction) {
  var isDown = direction === 'down';
  var containerIndex = position.containerIndex;
  var index = position.index;

  // Find next position within the current container
  var containerLength = containers.getContainerLength(containerIndex);
  var nextIndex = isDown ? index + 1 : index - 1;
  if (nextIndex < containerLength && nextIndex >= 0) {
    return new Position(containerIndex, nextIndex);
  }

  // Out of bounds, traverse containers
  containerIndex = isDown ? containerIndex + 1 : containerIndex - 1;
  containerLength = containers.getContainerLength(containerIndex);
  if (containerLength) {
    nextIndex = isDown ? 0 : containerLength - 1;
    return new Position(containerIndex, nextIndex);
  }

  return null;
}

/**
 * Get a position from a row node.
 *
 * @param {HTMLElement} node A DOM node for a list row.
 *
 * @return {Position?} A position or null if not found.
 */
function getFromNode(node) {

  // We need a parent node, since we will be checking if the row is inside
  // one of the known selection containers.
  if (!node.parentNode) return null;

  // We also need a data-index attribute on the row to get the index for the
  // row within the current selection container.
  if (!node.hasAttribute('data-index')) return null;

  var elements = containers.elements;
  if (elements.length === 0) return null;

  for (var i = 0, l = elements.length; i < l; i++) {
    if (elements[i] && containsNode(elements[i], node)) {
      var row = +node.getAttribute('data-index');
      return new Position(i, row);
    }
  }

  return null;
}

/**
 * Check if an element contains another node.
 *
 * @param {HTMLElement} element The container element.
 * @param {HTMLElement} child The potential child node.
 *
 * @return {boolean} True if element contains the child, false otherwise.
 */
function containsNode(element, child) {
  while (child && child.parentNode !== element) {
    child = child.parentNode;
  }
  return !!child;
}

/**
 * Get the row node that the specified position represents.
 *
 * @param {Position} position A position.
 *
 * @return {HTMLElement?} A DOM node or null if not found.
 */
function getNodeFromPosition(position) {
  var container = containers.elements[position.containerIndex];
  if (!container) return null;
  var node = $(container).find('[data-index=' + position.index + ']');
  return node ? node[0] : null;
}

/**
 * Get the direction from one position to another.
 *
 * @param {Position} from First position.
 * @param {Position} to Second position.
 *
 * @return {number} A number representing the direction.
 *     -1 is up
 *      0 is same
 *      1 is down
 */
function getDirection(from, to) {
  if (!from || !to) return 0;

  // With different containers we can just compare the containers
  if (from.containerIndex !== to.containerIndex) return from.containerIndex < to.containerIndex ? 1 : -1;

  // Within the same container, compare the row indices
  if (from.index === to.index) return 0;
  return from.index < to.index ? 1 : -1;
}

/**
 * Get data about in which container and where inside that the provided
 * global index is.
 *
 * @param {number} globalIndex An index relative to the full page (all
 *     selection containers).
 *
 * @return {Position} A position.
 */
function getPositionFromGlobalIndex(globalIndex) {
  var resolvedIndex = globalIndex;
  var resolvedContainerIndex = 0;
  var containerLength;
  var countIndices = 0;

  // Subtract the amount of tracks in containers until passing globalIndex
  for (var i = 0, l = containers.elements.length; i < l; i++) {

    containerLength = containers.getContainerLength(i);
    countIndices += containerLength;

    if (countIndices > globalIndex) break;

    resolvedContainerIndex = i + 1;
    resolvedIndex -= containerLength;
  }

  return new Position(resolvedContainerIndex, resolvedIndex);
}

/**
 * Get the global index relative to the full page (across all selection
 * containers) from a position object.
 *
 * @param {Position} position A position.
 *
 * @return {number} A global index.
 */
function getGlobalIndexFromPosition(position) {
  var resolvedIndex = position.index;

  // Subtract length of previous lists
  for (var i = position.containerIndex - 1; i >= 0; i--) {
    resolvedIndex += containers.getContainerLength(i);
  }

  return resolvedIndex;
}

/**
 * Get last position on page.
 *
 * @return {Position} A position.
 */
function getLastPosition() {
  var lastContainerIndex = containers.elements.length - 1;
  var lastIndex = containers.getContainerLength(lastContainerIndex) - 1;

  return new Position(lastContainerIndex, lastIndex);
}

/**
 * Get last position for "select all" on page, disregarding containers with
 * [data-select-all="false"].
 *
 * @return {Position} A position.
 */
function getLastPositionForSelectAll() {
  var lastContainerIndex = containers.elements.filter(function (element) {
    return element.getAttribute('data-list-may-select-all') !== 'false';
  }).length - 1;
  var lastIndex = containers.getContainerLength(lastContainerIndex) - 1;

  return new Position(lastContainerIndex, lastIndex);
}

exports.getClosest = getClosest;
exports.getFromNode = getFromNode;
exports.getNodeFromPosition = getNodeFromPosition;
exports.getDirection = getDirection;
exports.getPositionFromGlobalIndex = getPositionFromGlobalIndex;
exports.getGlobalIndexFromPosition = getGlobalIndexFromPosition;
exports.getLastPosition = getLastPosition;
exports.getLastPositionForSelectAll = getLastPositionForSelectAll;

},{"../../spotify-elements":70,"../util/Position":126,"./containers":111}],116:[function(require,module,exports){
/**
 * @module spotify-events/selection/rows
 * @private
 */
'use strict';

var $ = require('../../spotify-elements');
var difference = require('mout/array/difference');

var model = require('./model');
var containers = require('./containers');
var positions = require('./positions');

var SELECTOR_ROW = '[data-list-item]';
var CLASSNAME_SELECTED = 'selected';
var CLASSNAME_FOCUSED = 'selection-focus';
var CLASSNAME_FOCUSED_TOUCH = 'selection-focus-touch';
var focusTimeout;

/**
 * Update the selection state of rows.
 *
 * @param {HTMLElement=} opt_node Optional DOM node. If provided, the update
 *     will only affect rows found inside this node.
 */
function update(opt_node) {
  var currentlySelectedRows = getSelectedRows(opt_node);
  var rowsToBeSelected = getRowsToSelect(opt_node);

  var rowsToDeselect = difference(currentlySelectedRows, rowsToBeSelected);
  var rowsToSelect = difference(rowsToBeSelected, currentlySelectedRows);

  currentlySelectedRows.forEach(function (row) {
    $(row).removeClass(CLASSNAME_FOCUSED);
    $(row).removeClass(CLASSNAME_FOCUSED_TOUCH);
  });

  // Remove styles for selected rows that should now be deselected
  rowsToDeselect.forEach(function (row) {
    $(row).removeClass(CLASSNAME_SELECTED);
  });

  // Add styles for unselected rows that should now be selected
  rowsToSelect.forEach(function (row) {
    $(row).addClass(CLASSNAME_SELECTED);
  });

  // Add styles for the row with the selection focus
  var focus = model.getFocus();
  if (focus) {
    var focusNode = positions.getNodeFromPosition(focus);
    if (focusNode) {
      // If the focusNode is not yet in the viewport and we `focus()` it, the
      // browser will bluntly scroll it into view, which looks bad. (KM-6508)
      clearTimeout(focusTimeout);
      focusTimeout = setTimeout(function () {
        var isInputFocused = document.activeElement && $(document.activeElement).matches('input, textarea');
        var isButtonFocused = document.activeElement && $(document.activeElement).matches('button');
        if (isElementInViewport(focusNode) && !isInputFocused && !isButtonFocused) {
          focusNode.focus();
        }
      }, 0);
      $(focusNode).addClass(CLASSNAME_FOCUSED);

      if (model.wasFocusTriggeredByTouch()) {
        $(focusNode).addClass(CLASSNAME_FOCUSED_TOUCH);
      }
    }
  }
}

/**
 * Get the rows that are currently selected, found inside the known containers.
 *
 * @param {HTMLElement=} opt_node Optional DOM node. If provided, it will only
 *     search inside this node.
 *
 * @return {Array.<HTMLElement>} Array of DOM nodes.
 */
function getSelectedRows(opt_node) {
  var elements = opt_node ? [opt_node] : containers.elements;
  var rows = [];

  elements.forEach(function (container) {
    var nodes = $(container).search(SELECTOR_ROW + '.' + CLASSNAME_SELECTED);
    if (nodes) Array.prototype.push.apply(rows, nodes);
  });

  return rows;
}

/**
 * Get the rows that should be selected, found inside the known containers.
 *
 * @param {HTMLElement=} opt_node Optional DOM node. If provided, it will only
 *     search inside this node.
 *
 * @return {Array.<HTMLElement>} Array of DOM nodes.
 */
function getRowsToSelect(opt_node) {
  var rows = [];
  var containerElements = containers.elements;

  model.selections.forEach(function (keys, index) {
    if (!keys) return;

    var list = containers.getLiveList(index);
    if (!list) return;

    var container = containerElements[index];
    // If a node was passed, only check the container if it contains the node
    if (opt_node && !containerElements[index].contains(opt_node)) {
      container = null;
    }
    if (!container) return;

    var listNodes = $(container).search(SELECTOR_ROW);
    if (!listNodes) return;

    var nodes = listNodes.filter(function (listNode) {
      var nodeIndex = +listNode.getAttribute('data-index');
      var nodeRowId = list.keys[nodeIndex];
      return !!keys[nodeRowId];
    });

    Array.prototype.push.apply(rows, nodes);
  });
  return rows;
}

function isElementInViewport(el) {
  var rect = el.getBoundingClientRect();
  return rect.top >= 0 && rect.bottom <= document.documentElement.clientHeight;
}

exports.update = update;
exports.getSelectedRows = getSelectedRows;

},{"../../spotify-elements":70,"./containers":111,"./model":114,"./positions":115,"mout/array/difference":350}],117:[function(require,module,exports){
'use strict';

var SHUFFLE_CLASS = 'shuffle-mode';
var shuffleMode = require('../spotify-shuffle-mode');
var rootNode = document.documentElement;
var rootClassList = rootNode.classList;

function setClass() {
  if (shuffleMode.isEnabled()) {
    rootClassList.add(SHUFFLE_CLASS);
  } else {
    rootClassList.remove(SHUFFLE_CLASS);
  }
}

var isAttached = false;

exports.attach = function attach() {
  if (isAttached) return;
  isAttached = true;

  setClass();
};

exports.detach = function detach() {
  if (!isAttached) return;
  isAttached = false;

  rootClassList.remove(SHUFFLE_CLASS);
};

exports.update = function update(node) {
  if (!isAttached) return;

  if (node === rootNode) {
    setClass();
  }
};

},{"../spotify-shuffle-mode":290}],118:[function(require,module,exports){
/**
 * @module spotify-events/slider
 */
'use strict';

var $ = require('../spotify-elements');
var center = require('./center');

var live = require('../spotify-live');

var ATTR_SLIDER = 'slider';
var ATTR_PROPERTY = 'slider-property';
var SELECTOR_SLIDER = '[data-' + ATTR_SLIDER + ']';
var CLASSNAME_ENABLED = 'enabled';
var CLASSNAME_DISABLED = 'disabled';
var ATTR_ALLOWED = 'slider-allowed-property';

var SPACE_KEY_CODE = 32;

// Stored nodes, used to not add listeners multiple times
var storedNodes = [];

/**
 * Handle a click on a slider node.
 *
 * @param {MouseEvent} event Event object.
 * @param {Elements} elem An elements DOM node for the slider.
 */
function handleClick(event, elem) {
  var property = elem.data(ATTR_PROPERTY);

  if (elem.data(ATTR_ALLOWED) && !live(elem.data('uri')).get(elem.data(ATTR_ALLOWED))) {
    return;
  }

  // If a property is set, update the model. That will later trigger
  // an update of the view and a change event on center will be sent.
  if (property) {
    toggleAndPublish(elem[0], property);

    // If no property is set, just flip the visual style and emit
    // a change event on center.
  } else {
      setState(elem[0], !elem.hasClass(CLASSNAME_ENABLED));
    }
}

/**
 * Handle a keyboard event on a slider node.
 *
 * @param {KeyboardEvent} event Event object.
 * @param {Elements} elem An elements DOM node for the slider.
 */
function handleKeyUp(event, elem) {
  if (event.keyCode !== SPACE_KEY_CODE) {
    return;
  }

  handleClick(event, elem);
};

/**
 * Handle when a slider-set event happens on center.
 *
 * @param {Object} event An object with data.
 */
function onSliderSet(event) {
  if (!event.id) return;

  var elem = $('[data-' + ATTR_SLIDER + '=' + event.id + ']');
  if (!elem) return;

  var node = elem[0];
  var enabled = !!event.enabled;

  var property = elem.data(ATTR_PROPERTY);

  if (property) {
    toggleAndPublish(node, property, enabled);
  } else {
    setState(node, enabled);
  }
}

/**
 * Update the live model with new data. If no data-uri is found from
 * the passed node, nothing happens.
 *
 * @param {HTMLElement} node A DOM node for the slider.
 * @param {string} property A property name on the model.
 * @param {boolean=} opt_enabled Optional boolean flag. If true, this
 *     sets it to true, if false this sets it to false. If not provided,
 *     this sets it to the opposite of the current value in the model.
 */
function toggleAndPublish(node, property, opt_enabled) {
  var uri = getUriFromNode(node);
  if (!uri) return;

  var model = live(uri);

  // If the model doesn't have a current value, we can't safely
  // set a new value without maybe being wrong.
  var value = model.get(property);
  if (value === undefined) return;

  var newValue = opt_enabled === undefined ? !value : opt_enabled;

  var data = {};
  data[property] = newValue;

  // Publishing the new value to the model will trigger the update
  // handler added here in this module to update the visual state
  // of the button.
  model.publish(data);
}

/**
 * Update the state of one slider node.
 *
 * @param {HTMLElement} node A DOM node for the slider.
 */
function updateNode(node) {

  // Don't handle the same URI and node twice.
  if (storedNodes.indexOf(node) > -1) return;
  storedNodes.push(node);

  var elem = $(node);
  var property = elem.data(ATTR_PROPERTY);
  var allowedProperty = elem.data(ATTR_ALLOWED);

  if (!property) return;

  var uri = getUriFromNode(node);
  if (!uri) return;

  var model = live(uri);

  model.get(property, function (error, value) {
    if (error) throw error;

    setState(node, !!value);

    model.on('update', function (properties) {
      if (property in properties) {
        setState(node, !!properties[property]);
      }

      if (allowedProperty && allowedProperty in properties) {
        disableNode(node, !properties[allowedProperty]);
      }
    });
  });
}

/**
 * Update a slider node based on a value.
 *
 * @param {HTMLElement} node A DOM node for a slider.
 * @param {boolean} enabled True if should be enabled, false otherwise.
 */
function setState(node, enabled) {
  updateNodeWithValue(node, enabled);
  emitUpdate(node, enabled);
}

/**
 * Update a slider node based on a value.
 *
 * @param {HTMLElement} node A DOM node for a slider.
 * @param {boolean} enabled True if should be enabled, false otherwise.
 */
function updateNodeWithValue(node, enabled) {
  var elem = $(node);
  if (enabled) {
    elem.addClass(CLASSNAME_ENABLED);
  } else {
    elem.removeClass(CLASSNAME_ENABLED);
  }
}

/**
 * Update a slider node based on whether is disabled
 *
 * @param {HTMLElement} node A DOM node for a slider.
 * @param {boolean} disabled True if should be disabled, false otherwise.
 */
function disableNode(node, disabled) {
  var elem = $(node);
  if (disabled) {
    elem.addClass(CLASSNAME_DISABLED);
  } else {
    elem.removeClass(CLASSNAME_DISABLED);
  }
}

/**
 * Emit a change event on center. It will have the following format:
 * {
 *   element: HTMLElement,
 *   id: 'id from data-slider attribute' || null,
 *   enabled: true // the new value
 * }
 *
 * @param {HTMLElement} node A DOM node for a slider.
 * @param {boolean} enabled True if enabled, false otherwise.
 */
function emitUpdate(node, enabled) {
  var id = $(node).data(ATTR_SLIDER) || null;
  center.emit('slider-change', {
    element: node,
    id: id,
    enabled: enabled
  });
}

/**
 * Get a URI from a node.
 *
 * @param {HTMLElement} node A DOM node.
 *
 * @return {string?} A URI string or null if not found.
 */
function getUriFromNode(node) {
  var stateNode = node.closest('[data-uri]');
  if (!stateNode) return null;
  return stateNode.getAttribute('data-uri');
}

var isAttached = false;

/**
 * Update the module based on the current DOM state.
 *
 * @param {HTMLElement=} opt_node Optional DOM node to make changes inside.
 */
exports.update = function (opt_node) {
  if (!isAttached) return;

  var nodes = $(opt_node || document).search(SELECTOR_SLIDER);
  if (!nodes) return;

  nodes.forEach(updateNode);
};

/**
 * Attach event listeners etc.
 */
exports.attach = function () {
  if (isAttached) return;
  isAttached = true;

  var doc = $(document);
  doc.delegate('click', SELECTOR_SLIDER, handleClick);
  doc.delegate('keyup', SELECTOR_SLIDER, handleKeyUp);

  center.on('slider-set', onSliderSet);
};

/**
 * Detach event listeners etc.
 */
exports.detach = function () {
  if (!isAttached) return;
  isAttached = false;

  var doc = $(document);
  doc.undelegate('click', SELECTOR_SLIDER, handleClick);
  doc.undelegate('keyup', SELECTOR_SLIDER, handleKeyUp);

  center.off('slider-set', onSliderSet);
};

},{"../spotify-elements":70,"../spotify-live":251,"./center":77}],119:[function(require,module,exports){
'use strict';

var $ = require('../spotify-elements');
require('../spotify-elements/attributes');
require('../spotify-elements/traversal');

var live = require('../spotify-live');
var center = require('./center');
var sortUriUtils = require('../spotify-live-sort-uri');

var UIInteraction4 = require('../spotify-logger/messages/UIInteraction4');

var ASC = 'tl-sort-asc';
var DESC = 'tl-sort-desc';

var handleSort = function handleSort(event, node) {
  var listNode = node.parent('[data-list]');
  if (!listNode) return;

  var uri = listNode.data('uri');
  if (!uri) return;

  var model = live(uri);

  var queryCurrent = sortUriUtils.getQuery(uri);
  var directionCurrent = sortUriUtils.getDirection(uri);

  var query = node.data('sort');

  var reverse = directionCurrent === 'asc' ? 'desc' : 'asc';
  var direction = queryCurrent === query ? reverse : 'asc';
  var reset = queryCurrent === query && directionCurrent === 'desc';

  var origin = sortUriUtils.getOriginUri(uri) || uri;

  var nextUri;
  if (reset) {
    nextUri = origin;
    query = null;
    direction = null;
  } else {
    nextUri = sortUriUtils.create(origin, direction, query);
  }

  // The first time a live model for the sorted URI is created, the sortlist
  // model will set up the sorting queries based on the URI.
  var nextList = live(nextUri);

  // We then need to trigger the sort to happen by asking for rows
  // The app itself will most likely request rows anyway, but by doing it
  // early might make it slightly faster.
  nextList.get('rows', function () {});

  var player = live('spotify:player');

  player.get('variant', function (error, context) {
    if (error) throw error;

    if (context && context.get('uri') === uri) {
      player.emit('update-context', {
        context: nextUri
      });
    }
  });

  setClassNames(listNode, query, direction);

  center.emit('sort-header-click', {
    uri: origin,
    requested: {
      query: query || null,
      direction: direction || null
    },
    current: {
      query: queryCurrent || null,
      direction: directionCurrent || null
    }
  });

  center.emit('list-swap', { before: uri, after: nextUri });

  UIInteraction4.log({
    feature_id: live('spotify:application').get('appURI') || 'unknown',
    section_id: 'sort-header',
    target_uri: nextUri,
    interaction_type: 'hit',
    user_intent: 'sort',
    timestamp: Math.round(Date.now() / 1000)
  });
};

var setClassNames = function setClassNames(list, opt_query, opt_direction) {

  var uri = list.data('uri');
  var query = opt_query !== undefined ? opt_query : sortUriUtils.getQuery(uri);
  var direction = opt_direction !== undefined ? opt_direction : sortUriUtils.getDirection(uri);
  var headers = list.search('[data-sort]');
  if (!headers) return;

  for (var i = 0, header; header = $(headers[i]); i++) {
    header.removeClass(ASC + ' ' + DESC);
    if (header.data('sort') === query) {
      header.addClass(direction === 'asc' ? ASC : DESC);
    }
  }
};

var handlePreviousProxyClick = function handlePreviousProxyClick(event, node) {
  handleSort(null, node.previousSibling());
};

var isAttached = false;

exports.update = function (node) {
  if (!isAttached) return;

  node = $(node) || $(document);

  var lists = node.matches('[data-list]') ? [node] : node.search('[data-list]');
  if (!lists) return;

  for (var i = 0, list; list = $(lists[i]); i++) {
    var headers = list.search('[data-sort]');
    if (!headers) continue;
    setClassNames(list);
  }
};

exports.attach = function attach() {
  if (isAttached) return;
  isAttached = true;

  $(document).delegate('click', '[data-sort]', handleSort);
  $(document).delegate('click', '[data-sort-previous]', handlePreviousProxyClick);
};

exports.detach = function detach() {
  if (!isAttached) return;
  isAttached = false;

  $(document).undelegate('click', '[data-sort]', handleSort);
  $(document).undelegate('click', '[data-sort-previous]', handlePreviousProxyClick);
};

},{"../spotify-elements":70,"../spotify-elements/attributes":66,"../spotify-elements/traversal":72,"../spotify-live":251,"../spotify-live-sort-uri":249,"../spotify-logger/messages/UIInteraction4":261,"./center":77}],120:[function(require,module,exports){
'use strict';

var throttle = require('./util/throttle');
var center = require('./center');
var sort = require('./sort');

var DEFAULT_STICKY_CLASS_NAME = 'sticky-top';
var TTL_STICKIES = 4000;
var TTL_POSITIONS = 0;

var isAttached = false;
var nodesGBCR = null;
var rootGBCR = null;
var timestamp;

var updateStickies = function updateStickies(nodes) {
  var rects = getRects(TTL_STICKIES);
  var scrollTop = window.scrollY;
  var width = rects.root.width;
  var top = rects.root.top;
  var height = 0;

  resetOldStickies();

  (nodes instanceof Array ? nodes : rects.nodes).forEach(function (nodeInfo, i) {
    var node = nodeInfo.node;
    var rect = nodeInfo.rect;
    var stickyClone = node.stickyClone;
    var stickyClassName = nodeInfo.stickyClassName;

    // Check if the node should be sticked or not (if true, it should be).
    if (rect.top - top < scrollTop) {
      if (!(stickyClone || node).classList.contains(stickyClassName)) {
        // <THEAD>s can't be made sticky, so we clone it and add it to the DOM.
        if (node.nodeName.toLowerCase() === 'thead' && !node.stickyClone) {
          node = createClone(node);
        }

        node.classList.add(stickyClassName);

        // Update styles accordingly.
        node.setAttribute('data-sticky-active', '');
        node.style.right = width - rect.right + 'px';
        node.style.left = rect.left + 'px';
        node.style.position = 'fixed';
        node.style.top = height + 'px';
      } else {
        (stickyClone || node).style.top = height + 'px';
      }

      // Increment the top reference and the height. Do it even if the element is already sticked.
      height += rect.height;
      top += rect.height;
    } else {
      if ((stickyClone || node).classList.contains(stickyClassName)) {
        resetSticky(node);
      }
    }
  });
};

var updatePositions = function updatePositions() {
  var rects = getRects(TTL_POSITIONS);
  var width = rects.root.width;

  // Update left and right.
  rects.nodes.forEach(function (nodeInfo, i) {
    var node = nodeInfo.node;
    var rect = nodeInfo.rect;

    if (node.stickyClone) {
      node = node.stickyClone;
    }

    if (node.classList.contains(nodeInfo.stickyClassName)) {
      node.style.right = width - rect.right + 'px';
      node.style.left = rect.left + 'px';
    }
  });
};

var resetSticky = function resetSticky(node) {
  // <THEAD>s can't be made sticky, so verify if we are using a clone and remove it from the DOM.
  if (node.nodeName.toLowerCase() === 'thead' && node.stickyClone) {
    removeClone(node);
  }

  node.classList.remove(getStickyClassName(node));

  // Update styles accordingly.
  node.removeAttribute('data-sticky-active', '');
  node.style.right = '';
  node.style.left = '';
  node.style.position = '';
  node.style.top = '';
};

var resetOldStickies = function resetOldStickies() {
  var selector = '[data-sticky-active]:not([data-sticky])';
  var nodes = document.querySelectorAll(selector);
  for (var i = 0, l = nodes.length; i < l; i++) {
    if (!nodes[i].isStickyClone) {
      resetSticky(nodes[i]);
    }
  }
};

var getRects = function getRects(ttl) {
  var reference = timestamp + ttl;
  var nodes = document.querySelectorAll('[data-sticky]');

  // Refresh timestamp (always).
  timestamp = Date.now();

  // If the reference time is still valid, and nodes are the same, then return data.
  if (reference > timestamp && nodesGBCR && nodes.length === nodesGBCR.length) {
    var equal = true;

    for (var i = 0; i < nodes.length; i++) {
      equal = equal && nodes[i] === nodesGBCR[i].node;
    }

    if (equal) {
      return {
        nodes: nodesGBCR,
        root: rootGBCR
      };
    }
  }

  // Otherwise, compute and cache.
  rootGBCR = document.documentElement.getBoundingClientRect();
  nodesGBCR = Array.prototype.map.call(document.querySelectorAll('[data-sticky]'), function (node) {
    var parentRect = node.parentNode.getBoundingClientRect();
    var nodeRect = node.getBoundingClientRect();

    // Return a structure per node. Only some fields are stored in the rect object (the ones used).
    return {
      stickyClassName: getStickyClassName(node),
      node: node,
      rect: {
        top: parentRect.top,
        height: nodeRect.height,
        left: parentRect.left,
        right: parentRect.right
      }
    };
  });

  return {
    nodes: nodesGBCR,
    root: rootGBCR
  };
};

var createClone = function createClone(node) {
  var div = document.createElement('div');
  var thead = node.cloneNode(true);
  var table = node.parentNode.cloneNode(false);
  var onListSwap;

  table.appendChild(thead).removeAttribute('data-sticky');
  div.appendChild(table);
  div.className = 'sticky-clone';
  div.isStickyClone = true;

  onListSwap = function onListSwap(data) {
    var table = thead.parentNode;
    var uri = table && table.getAttribute('data-uri');

    // Update the "data-uri" of the cloned table, and the sort state of the original one.
    if (uri) {
      table.setAttribute('data-uri', data.after);
      sort.update(node.parentNode);
    };
  };

  center.on('list-swap', onListSwap);

  node.parentNode.parentNode.appendChild(div);
  node.style.visibility = 'hidden';
  node.stickyListSwapListener = onListSwap;
  node.stickyClone = div;

  return div;
};

var removeClone = function removeClone(node) {
  var stickyClone = node.stickyClone;

  if (stickyClone.parentNode) {
    stickyClone.parentNode.removeChild(stickyClone);
  }

  if (node.stickyListSwapListener) {
    center.off('list-swap', node.stickyListSwapListener);
  }

  node.style.removeProperty('visibility');

  delete node.stickyClone;
  delete node.stickyListSwapListener;
};

var getStickyClassName = function getStickyClassName(stickyNode) {
  var root = document.documentElement;
  var classSticky;
  var node;

  for (node = stickyNode; node !== root; node = node.parentNode) {
    if (classSticky = node.getAttribute('data-class-sticky')) {
      return classSticky;
    }
  }

  return DEFAULT_STICKY_CLASS_NAME;
};

exports.DEFAULT_STICKY_CLASS_NAME = DEFAULT_STICKY_CLASS_NAME;

exports.attach = function attach() {
  if (!isAttached) {
    isAttached = true;

    window.addEventListener('scroll', updateStickies);
    window.addEventListener('resize', updatePositions);
  }
};

exports.detach = function detach() {
  if (isAttached) {
    isAttached = false;

    window.removeEventListener('scroll', updateStickies);
    window.removeEventListener('resize', updatePositions);

    nodesGBCR = null;
    rootGBCR = null;
  }
};

exports.update = function (optNode) {
  if (isAttached) {
    nodesGBCR = null;
    rootGBCR = null;

    updateStickies();
  }
};

exports._getStickyClassName = getStickyClassName;

},{"./center":77,"./sort":119,"./util/throttle":131}],121:[function(require,module,exports){
module.exports={
  "drag_tooltip_many_items": "items",
  "drag_tooltip_many_tracks": "tracks",
  "drag_tooltip_many_artists": "artists",
  "drag_tooltip_many_albums": "albums",
  "drag_tooltip_many_playlists": "playlists",
  "drag_tooltip_many_users": "users"
}
},{}],122:[function(require,module,exports){
'use strict';

var $ = require('../spotify-elements');
var live = require('../spotify-live');
var dom = require('./util/dom');

var SELECTOR_THUMBS_DOWN_BUTTON = '[data-button=thumbs-down]';
var SELECTOR_THUMBS_UP_BUTTON = '[data-button=thumbs-up]';

/**
 * Handle the click on a Thumbs button.
 *
 * @param {MouseEvent} event An event object for a click event.
 * @param {HTMLElement} button A button DOM node.
 *
 * @private
 */
function handleThumbsButtonClick(event, button) {
  var type = dom.getAttributeFromNodeOrParent(button[0], 'data-button');
  var trackUri = dom.getAttributeFromNodeOrParent(button[0], 'data-uri');
  var contextUri = dom.getContextFromNodeOrParent(button[0]);

  // Must use track uri
  if (!trackUri || !contextUri) return;

  // Emit thumb event on context
  if (type === 'thumbs-down') {
    live(contextUri).emit('thumb-down', trackUri);
  } else if (type === 'thumbs-up') {
    live(contextUri).emit('thumb-up', trackUri);
  }
};

var isAttached = false;

/**
 * Attach the event listeners for the module.
 * Part of the spotify-events interface.
 */
exports.attach = function () {
  if (isAttached) return;
  isAttached = true;

  var doc = $(document);
  doc.delegate('click', SELECTOR_THUMBS_DOWN_BUTTON, handleThumbsButtonClick);
  doc.delegate('click', SELECTOR_THUMBS_UP_BUTTON, handleThumbsButtonClick);
};

/**
 * Detach the event listeners for the module.
 * Part of the spotify-events interface.
 */
exports.detach = function () {
  if (!isAttached) return;
  isAttached = false;

  var doc = $(document);
  doc.undelegate('click', SELECTOR_THUMBS_DOWN_BUTTON, handleThumbsButtonClick);
  doc.undelegate('click', SELECTOR_THUMBS_UP_BUTTON, handleThumbsButtonClick);
};

exports.update = function (optNode) {};

},{"../spotify-elements":70,"../spotify-live":251,"./util/dom":129}],123:[function(require,module,exports){
'use strict';

var $ = require('../spotify-elements');
var zen = require('../spotify-elements/zen');

var tooltipMargin = 8; // We want some spacing around the tooltip

var tooltip = zen('div#tooltip');
var tooltipNode = tooltip[0];
var tooltipTextNode = zen('span')[0];
var tooltipArrowTop = zen('div.tooltip-arrow-top');
var tooltipArrowBottom = zen('div.tooltip-arrow-bottom');
tooltip.appendChild(tooltipArrowTop);
tooltip.appendChild(tooltipArrowBottom);
tooltip.appendChild(tooltipTextNode);

var attachedNode = null;
var tooltipNodeAttached = false;

// tooltipArrow will point to the current visible tooltipArrow
// that can be either tooltipArrowTop or tooltipArrowBottom
var tooltipArrow = null;

var addTooltipToDOM = function addTooltipToDOM() {
  document.body.appendChild(tooltipNode);
  tooltipNodeAttached = true;
};

var removeTooltipFromDOM = function removeTooltipFromDOM() {
  attachedNode = null;
  if (tooltipNode.parentNode) document.body.removeChild(tooltipNode);

  tooltipNodeAttached = false;
};

var showTooltip = function showTooltip(event, node) {
  var realNode = node[0];
  var top = 0;
  var left = 0;

  var tooltipText = node.data('tooltip') || node.getAttribute('title');
  if (!tooltipText) return;

  // Remember the node we set the text from so that text can be updated.
  attachedNode = node;

  if (!node.tooltipCheck) {
    node.removeAttribute('title');
    node.setAttribute('data-tooltip', tooltipText);
    node.tooltipCheck = true;
  }

  if (!tooltipNodeAttached) addTooltipToDOM();

  setText(tooltipText);

  var tooltipHeight = tooltipNode.clientHeight;
  var tooltipWidth = tooltipNode.offsetWidth;

  // Don't use window.scrollY because cross browser issues.
  // https://developer.mozilla.org/en-US/docs/Web/API/Window.scrollY
  var scrollY = window.pageYOffset;

  var bounds = realNode.getBoundingClientRect();
  var targetHeight = realNode.offsetHeight;
  var targetWidth = realNode.offsetWidth;
  var targetTop = parseInt(bounds.top) + scrollY;
  var targetLeft = parseInt(bounds.left);
  var targetCenter = targetLeft + targetWidth / 2;
  var targetBottom = targetTop + targetHeight;
  var viewportWidth = document.documentElement.clientWidth;
  var viewportHeight = document.documentElement.clientHeight;

  // Decide if the tooltip should be over or under the node
  if (targetBottom + tooltipHeight + tooltipMargin - scrollY > viewportHeight) {
    // On top
    top = targetTop - tooltipHeight - tooltipMargin;
    tooltipArrowTop.removeClass('visible');
    tooltipArrowBottom.addClass('visible');
    tooltipArrow = tooltipArrowBottom;
  } else {
    top = targetTop + targetHeight + tooltipMargin;
    if (top - scrollY > viewportHeight) {
      top = viewportHeight - tooltipHeight;
    }
    tooltipArrowTop.addClass('visible');
    tooltipArrowBottom.removeClass('visible');
    tooltipArrow = tooltipArrowTop;
  }

  var distanceToTheRight = viewportWidth - tooltipMargin - targetCenter;
  var distanceToTheLeft = targetCenter - tooltipMargin;
  var tooltipOffsetRight = Math.max(0, tooltipWidth / 2 - distanceToTheRight);
  var tooltipOffsetLeft = Math.max(0, tooltipWidth / 2 - distanceToTheLeft);

  left = targetCenter - tooltipWidth / 2 - (tooltipOffsetRight || -tooltipOffsetLeft);

  tooltipNode.style.top = top + 'px';
  tooltipNode.style.left = left + 'px';
  tooltipArrow[0].style.left = targetCenter - left + 'px';

  if (node.hasAttribute('data-tooltip-instant')) {
    tooltip.addClass('instant');
  } else {
    tooltip.removeClass('instant');
  }

  tooltip.addClass('visible');
};

var hideTooltip = function hideTooltip() {
  attachedNode = null;
  setText('');
  tooltip.removeClass('visible');
  tooltipNode.style.left = 0;
  tooltipNode.style.top = 0;
  if (tooltipArrow) {
    tooltipArrow[0].style.left = 0;
  }
};

var setText = function setText(text) {
  tooltipTextNode.innerHTML = text;
};

var isAttached = false;

exports.attach = function attach() {
  if (isAttached) return;
  isAttached = true;

  var doc = $(document);
  doc.delegate('mouseover', '[data-tooltip]', showTooltip);
  doc.delegate('mouseout', '[data-tooltip]', hideTooltip);
  doc.on('keydown', hideTooltip);
  doc.on('mousedown', hideTooltip);
};

exports.detach = function detach() {
  if (!isAttached) return;
  isAttached = false;

  removeTooltipFromDOM();
  var doc = $(document);
  doc.undelegate('mouseover', '[data-tooltip]', showTooltip);
  doc.undelegate('mouseout', '[data-tooltip]', hideTooltip);
  doc.off('keydown', hideTooltip);
  doc.off('mousedown', hideTooltip);
};

/** Forces an update of the tooltip text. */
exports.update = function update() {
  if (!isAttached) return;

  if (!attachedNode) return;

  if (attachedNode.data('tooltip')) {
    showTooltip(null, attachedNode);
  } else {
    // The tooltip no longer has text and should be hidden.
    hideTooltip();
  }
};

// Export for testing purposes
exports._setText = setText;

},{"../spotify-elements":70,"../spotify-elements/zen":73}],124:[function(require,module,exports){
'use strict';

var $ = require('../spotify-elements');

var doc = $(document);
var hoverActive = true;

/* Store events in an array */
var touchArray = [];
var addEvent = function addEvent(touchEvent) {
  touchArray.push(touchEvent);
};

function getMediaObjects() {
  return doc.search('.media-object');
}

function isMediaObject(element) {
  return !!element.closest('.media-object');
}

function handleEvent(e) {
  var target = e.target;
  if (isMediaObject(target)) {
    switch (e.type) {
      case 'touchstart':
        addEvent(e);
        if (hoverActive) {
          disableHover(e);
        }
        break;

      case 'touchmove':
        addEvent(e);
        break;

      case 'touchend':

        if (target && touchArray.length === 1 && touchArray[0].type === 'touchstart') {
          e.preventDefault();
          target.click();
        }
        touchArray = [];
        break;

      case 'contextmenu':
        addEvent(e);
        break;

      case 'mousemove':
        if (!hoverActive) {
          enableHover(e);
        }
        break;
    }
  }
}

function disableHover(e) {
  var mediaObjects = getMediaObjects();
  if (mediaObjects) {
    mediaObjects.forEach(function (object) {
      // Find available hover elements
      var overlay = $(object).find('.mo-overlay');
      // Hide hover elements
      if (overlay) {
        var add = $(object).find('.mo-add');
        var play = $(object).find('.mo-play');
        var more = $(object).find('.mo-more');
        var del = $(object).find('.mo-delete');

        hide(overlay);
        if (add) {
          hide(add);
        }
        if (play) {
          hide(play);
        }
        if (more) {
          hide(more);
        }
        if (del) {
          hide(del);
        }
      }
    });
    hoverActive = false;
  }

  function hide(element) {
    element.addClass('not-visible');
  }
}

function enableHover(e) {
  var mediaObjects = getMediaObjects();
  if (mediaObjects) {
    // Show hover elements
    mediaObjects.forEach(function (object) {
      var elements = $(object).search('.not-visible');
      if (elements) {
        show(elements);
        hoverActive = true;
      }
    });
  }

  function show(element) {
    element.removeClass('not-visible');
  }
}

var isAttached = false;

exports.attach = function () {
  if (isAttached) return;
  isAttached = true;

  doc.on('touchstart', handleEvent);
  doc.on('touchmove', handleEvent);
  doc.on('touchend', handleEvent);
  doc.on('mousemove', handleEvent);
  doc.on('contextmenu', handleEvent);
};

exports.detach = function () {
  if (!isAttached) return;
  isAttached = false;

  doc.off('touchstart', handleEvent);
  doc.off('touchmove', handleEvent);
  doc.off('touchend', handleEvent);
  doc.off('mousemove', handleEvent);
  doc.off('contextmenu', handleEvent);
};

exports.update = function () {};

exports._reset = function () {
  hoverActive = true;
  touchArray = [];
};

},{"../spotify-elements":70}],125:[function(require,module,exports){
'use strict';

var prime = require('prime');
var Emitter = require('prime/emitter');
var Range = require('../../spotify-range2');

var SYNC = Emitter.EMIT_SYNC;

module.exports = prime({
  mixin: Emitter,

  constructor: function constructor(container, params) {
    this.container = container;

    this.height = params.height || 0;
    this.length = params.length || 0;

    this.tag = params.tag || 'li';
    this.request = params.request;

    // Unique call identificator.
    this._id = 0;

    this.reset();
  },

  resetFrom: function resetFrom(fromIndex, length, hiddenIndices) {
    var range = this._range;

    // Redirect the call to reset.
    if (fromIndex < range.end) {
      this.reset(length, hiddenIndices);
      this.show(range);
    }
  },

  reset: function reset(length, hiddenIndices) {
    var tag = this.tag;
    var totalHeight;

    if (typeof length !== 'undefined') {
      this.length = length;
    }

    totalHeight = this.length * this.height;

    // Hidden indices are not supported anymore (legacy).
    if (hiddenIndices) {
      throw new TypeError('Hidden indices are not supported anymore!');
    }

    this.container.innerHTML = '<' + tag + ' style="height:' + totalHeight + 'px"></' + tag + '>' + '<' + tag + ' style="height:0px"></' + tag + '>';

    this._range = new Range(0, 0);
    this._waitingRange = new Range(0, 0);

    // An array of ranges representing the visible nodes.
    this.emit('index-change', [], SYNC);
  },

  show: function show(range) {
    var length = this.length;
    var actual = this._range;
    var waiting = this._waitingRange;

    // Limit range to the [0, length) interval.
    var bound = new Range(Math.max(0, range.start), Math.min(length, range.end));

    // If the range requested is the same, do nothing.
    if (bound.start === actual.start && bound.end === actual.end) {
      return;
    }

    // If the range requested is the same, do nothing.
    if (bound.start === waiting.start && bound.end === waiting.end) {
      return;
    }

    this._drawRange(bound);
  },

  _drawRange: function _drawRange(range) {
    var container = this.container;
    var oldRange = this._range;
    var height = this.height;
    var length = this.length;
    var tag = this.tag;
    var id = ++this._id;
    var self = this;

    this._waitingRange = range;

    // Request the whole range. We will manually intersect later with the current one.
    this.request(range, function (err, nodes) {
      var oldLength = oldRange.length;
      var newLength = range.length;
      var diff = 0;
      var first;
      var last;
      var i;

      // If a new range has been requested in the meantime, don't draw/modify anything.
      if (id !== self._id) {
        return;
      }

      // Cache the range requested.
      self._range = range;
      self._waitingRange = new Range(0, 0);

      // Get first and last nodes as references. We will use them for removing/adding nodes.
      first = container.firstChild;
      last = container.lastChild;

      // Change heights of the paddings.
      first.style.height = range.start * height + 'px';
      last.style.height = (length - range.end) * height + 'px';

      // Remove old nodes. Since nodes change their position when removing them one by one,
      // we have to keep the cumulative sum of nodes removed cached.
      oldRange.subtract(range).forEach(function (subrange) {
        var length = subrange.length;

        for (i = 0; i < length; i++) {
          // We add one to the children index because the first child is not a row but the top padding.
          container.removeChild(container.children[subrange.start - oldRange.start - diff + 1]);
        }

        diff += length;
      });

      // Add new nodes. If the new nodes are below the old range, insert them at the top;
      // otherwise, insert them at the bottom.
      range.subtract(oldRange).forEach(function (subrange) {
        var length = subrange.length;
        var start = subrange.start - range.start;
        var subnodes = nodes.slice(start, start + length);
        var ref;

        // Emit a change before.
        self.emit('before-show', subrange, subnodes, SYNC);

        // Get the reference node. If the range is below, then insert at the top.
        // Otherwise, insert at the bottom.
        if (subrange.below(oldRange)) {
          ref = first.nextSibling;
        } else {
          ref = last;
        }

        for (i = 0; i < length; i++) {
          container.insertBefore(subnodes[i], ref);
        }

        // Emit a change after.
        self.emit('after-show', subrange, subnodes, SYNC);
      });

      self.emit('index-change', [range], SYNC);
    });
  }
});

},{"../../spotify-range2":289,"prime":404,"prime/emitter":403}],126:[function(require,module,exports){
'use strict';

var Position = function Position(containerIndex, index) {
  this.containerIndex = containerIndex;
  this.index = index;
};

Position.prototype.isSame = function (position) {
  return this.containerIndex === position.containerIndex && this.index === position.index;
};

module.exports = Position;

},{}],127:[function(require,module,exports){
'use strict';

var live = require('../../spotify-live');

function checkIfActive() {
  return live('spotify:application').get('active') || false;
}

function checkIfFocused() {

  // If the active element of the top frame has a contentWindow that matches
  // this window, it means the iframe of this app is in focus.
  var topActiveElement = window.top.document.activeElement;
  var activeWindow = topActiveElement && topActiveElement.contentWindow;
  if (activeWindow) {
    return activeWindow === window;
  }

  // Top frame (zlink)
  if (window.top === window) {
    return true;
  }

  return false;
};

exports.isActive = function () {
  return checkIfActive();
};

exports.isActiveAndFocused = function () {
  return checkIfActive() && checkIfFocused();
};

},{"../../spotify-live":251}],128:[function(require,module,exports){
/**
 * @module spotify-events/util/cosmos
 * @private
 */

'use strict';

var live = require('../../spotify-live');
var cosmos = require('spotify-cosmos-api');
var liburi = require('spotify-liburi');

var ASAP = live.ASAP;

function DELETE(options, opt_callback) {
  options.method = exports.cosmos.Action.DELETE;
  return request(options, opt_callback);
}

function GET(options, opt_callback) {
  options.method = exports.cosmos.Action.GET;
  return request(options, opt_callback);
}

function SUB(options, opt_callback) {
  options.method = exports.cosmos.Action.SUB;
  return request(options, opt_callback);
}

function POST(options, opt_callback) {
  options.method = exports.cosmos.Action.POST;
  return request(options, opt_callback);
}

function PUT(options, opt_callback) {
  options.method = exports.cosmos.Action.PUT;
  return request(options, opt_callback);
}

function HEAD(options, opt_callback) {
  options.method = exports.cosmos.Action.HEAD;
  return request(options, opt_callback);
}

function request(options, opt_callback) {
  var method = options.method;
  delete options.method;

  var subscription, canceled;

  sanitizeURL(options.url, function (error, url) {
    if (error) return opt_callback && opt_callback(error);

    // if you cancel before the userName is replaced.
    if (canceled) return;

    var request = new exports.cosmos.Request(method || exports.cosmos.Action.GET, url, options.headers, options.body);
    subscription = exports.cosmos.resolver.resolve(request, function (error, response) {
      if (!opt_callback) return;
      if (error) return opt_callback(error);
      try {
        opt_callback(null, {
          body: JSON.parse(response.getBody() || '{}'),
          headers: response.getHeaders(),
          status: response.getStatusCode()
        });
      } catch (parseError) {
        parseError.response = response;
        opt_callback(parseError);
      }
    });
  });

  return {
    cancel: function cancel() {
      if (subscription && subscription.cancel) {
        // we already subscribed, cancel it.
        subscription.cancel();
        subscription = null;
      } else if (!canceled) {
        // not subscribed yet, don't even subscribe.
        canceled = true;
      }
      return null;
    }
  };
}

function sanitizeURL(url, callback) {
  if (url.indexOf('@') > -1) {
    live('spotify:client').query('currentUser(username)', function (error, data) {
      if (error) return callback(error);
      callback(null, url.replace('@', liburi.getCanonicalUsername(data.currentUser.username)));
    }, ASAP);
  } else {
    callback(null, url);
  }
}

exports.request = request;
exports.get = GET;
exports.post = POST;
exports.subscribe = SUB;
exports.delete = DELETE;
exports.put = PUT;
exports.head = HEAD;
exports.cosmos = cosmos;

exports.sanitizeURL = sanitizeURL;

},{"../../spotify-live":251,"spotify-cosmos-api":416,"spotify-liburi":426}],129:[function(require,module,exports){
'use strict';

/**
 * @public
 */

/**
 * Get the context URI from the specified node or its parents.
 *
 * @param {HTMLElement} node A DOM node.
 *
 * @return {string} The context URI or empty string if not found.
 */

function getContextFromNodeOrParent(node) {
  var contextNode = node.closest('[data-context]');
  return contextNode && contextNode.getAttribute('data-uri') || '';
};

/**
 * Get the value for the passed attribute name, either from the passed node
 * or from any parent node.
 *
 * @param {HTMLElement} node The node to start searching from.
 * @param {string} attributeName The name of the attribute.
 *
 * @return {string} The value, or empty string if not found.
 */
function getAttributeFromNodeOrParent(node, attributeName) {
  var selector = '[' + attributeName + ']';
  var attributeNode = node.closest(selector);
  return attributeNode && attributeNode.getAttribute(attributeName) || '';
};

exports.getContextFromNodeOrParent = getContextFromNodeOrParent;
exports.getAttributeFromNodeOrParent = getAttributeFromNodeOrParent;

},{}],130:[function(require,module,exports){
'use strict';

module.exports = function getLogContext(target) {
  var currentNode = target;
  var logContext = [];
  while (currentNode) {
    if (currentNode.matches && currentNode.matches('[data-log-context]')) {
      logContext.unshift(currentNode.getAttribute('data-log-context'));
    }
    currentNode = currentNode.parentNode;
  }
  return logContext.join('/') || null;
};

},{}],131:[function(require,module,exports){
'use strict';

var defer = require('prime/defer');

/**
 * Throttle the function calls to only trigger once per tick.
 * This will return a new function that you will use when you want
 * to call your function. Calling it multiple times in the same
 * run loop will only really call it once.
 *
 * @param {function} fn A function.
 * @param {Object=} opt_ctx The context to run the function in ('this').
 *
 * @return {function} A new function.
 */
function throttle(fn, opt_ctx) {
  var queued = false;
  var args;

  return function () {
    args = arguments;
    if (!queued) {
      queued = true;
      defer.frame(function () {
        queued = false;
        fn.apply(opt_ctx, args);
      });
    }
  };
}

module.exports = throttle;

},{"prime/defer":402}],132:[function(require,module,exports){
'use strict';

var $ = require('../spotify-elements');
var live = require('../spotify-live');

var update = function update(node) {

  var observables = ($(node) || $(document)).search('[data-watch]');

  if (observables) observables.forEach(function (node) {
    node = $(node);
    var key = node.data('watch');

    if (!key) return;

    var observed = node._observed || (node._observed = {});

    if (observed[key]) return;
    observed[key] = true;

    var parent;

    var uriNode = node[0].closest('[data-uri]');
    var uri = uriNode && uriNode.getAttribute('data-uri');

    if (!uri) return;

    var model = live(uri);

    var updateText = function updateText(event) {
      if (key in event) {
        var value = event[key];
        node.text(value == null ? '' : value);
      }
    };

    model.get(key, function (err, value) {
      if (err) throw err;
      var event = {};
      event[key] = value;
      updateText(event);
    });

    model.on('update', updateText);
  });
};

var isAttached = false;

exports.update = function (optNode) {
  if (!isAttached) return;

  update(optNode);
};
exports.attach = function () {
  if (isAttached) return;
  isAttached = true;
};
exports.detach = function () {
  if (!isAttached) return;
  isAttached = false;
};

},{"../spotify-elements":70,"../spotify-live":251}],133:[function(require,module,exports){
(function (global){
'use strict';

exports.init = function () {
  require('./expose-debug-global').expose(global, 'bridge', require('../spotify-bridge-request'));
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-bridge-request":64,"./expose-debug-global":135}],134:[function(require,module,exports){
(function (global){
'use strict';

exports.init = function () {
  require('./expose-debug-global').expose(global, 'cosmos', require('spotify-cosmos-api'));
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./expose-debug-global":135,"spotify-cosmos-api":416}],135:[function(require,module,exports){
'use strict';

exports.expose = function (global, name, object) {
  if (global.__spotify && global.__spotify.developer_mode) {
    Object.defineProperty(global, name, {
      get: function get() {
        try {
          throw new Error();
        } catch (error) {
          if (!/injectedscript/i.test(error.stack)) {
            throw new Error('window.' + name + ' should only be accessed from the console');
          }
        }
        return object;
      },
      enumerable: true,
      configurable: true
    });
  }
};

},{}],136:[function(require,module,exports){
(function (global){
'use strict';

exports.init = function () {
  require('./expose-debug-global').expose(global, 'live', require('../spotify-live'));
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-live":251,"./expose-debug-global":135}],137:[function(require,module,exports){
module.exports = {
  "Album": "Album",
  "AndMore": "und {0} weitere",
  "Artist": "Künstler",
  "By": "von",
  "Create Similar Playlist": "Ähnliche Playlist erstellen",
  "Filter": "Filter",
  "Follow": "Folgen",
  "Follower": "Follower",
  "FollowersLabel": "Followers",
  "Following": "Folge ich",
  "FollowingLabel": "Folge ich",
  "ListenersLabel": "Monatliche Hörer",
  "FollowsYou": "Folgt dir",
  "HoldToPreview": "Zum Reinhören gedrückt halten",
  "ListenCount": "{0} Mal abgespielt",
  "ListenReactionMulti": "{0} Hörer in Deinem Netzwerk",
  "ListenReactionSingle": "{0} hört sich das an",
  "LocalFile": "Lokale Datei",
  "More": "Mehr",
  "Pause": "Pause",
  "Play": "Play",
  "Playlist": "Playlist",
  "PressEnterToPlay": "Drück die Eingabetaste zum Abspielen",
  "Popularity": "Beliebtheit",
  "Remove": "Entfernen",
  "RemoveYourMusic": "Aus \"Deine Musik\" entfernen",
  "Save": "Speichern",
  "SaveYourMusic": "In \"Deine Musik\" speichern",
  "Saved": "Gespeichert",
  "ShufflePlay": "Shuffle",
  "Song": "Song",
  "StartRadio": "Radio starten",
  "Time": "Dauer",
  "Toplist": "Top-Songs",
  "Track": "Song",
  "Unfollow": "Nicht mehr folgen",
  "User": "Benutzer",
  "ViewAll": "Mehr Darstellung",
  "HoursShort": "{0} Std.",
  "MinutesShort": "{0} Min.",
  "SecondsShort": "{0} Sek.",
  "ErrorTitle": "Bei der Anzeige dieser Ansicht ist ein Fehler aufgetreten!",
  "ErrorMessage": "Diese Ansicht ist entweder nicht vorhanden oder es ist ein Fehler aufgetreten.",
  "OfflineTitle": "Diese Ansicht ist offline nicht verfügbar.",
  "OfflineMessage": "Geh zum Laden online."
};
},{}],138:[function(require,module,exports){
module.exports = {
  "Album": "Άλμπουμ",
  "AndMore": "και άλλοι {0}",
  "Artist": "Καλλιτέχνης",
  "By": "από",
  "Create Similar Playlist": "Δημιουργία παρόμοιας playlist",
  "Filter": "Φίλτρο",
  "Follow": "Ακολούθησε",
  "Follower": "Οπαδός",
  "FollowersLabel": "Οπαδοί",
  "Following": "Aκολουθείται",
  "FollowingLabel": "Aκολουθείται",
  "ListenersLabel": "Μηνιαίοι ακροατές",
  "FollowsYou": "Σε ακολουθεί",
  "HoldToPreview": "Πάτησε και κράτησε πατημένο για προεπισκόπηση",
  "ListenCount": "{0} αναπαραγωγές",
  "ListenReactionMulti": "{0} ακροατές στο δίκτυό σου",
  "ListenReactionSingle": "Ο χρήστης {0} ακούει αυτό",
  "LocalFile": "Τοπικό αρχείο",
  "More": "Περισσότερα",
  "Pause": "Παύση",
  "Play": "Αναπαραγωγή",
  "Playlist": "Λίστα",
  "PressEnterToPlay": "Πάτησε Enter για αναπαραγωγή",
  "Popularity": "Δημοφιλία",
  "Remove": "Αφαίρεση",
  "RemoveYourMusic": "Αφαίρεση από τη Mουσική σου",
  "Save": "Αποθήκευση",
  "SaveYourMusic": "Αποθήκευση στη Mουσική σου",
  "Saved": "Αποθηκεύτηκε",
  "ShufflePlay": "Τυχαία αναπαραγωγή",
  "Song": "Τραγούδι",
  "StartRadio": "Έναρξη ραδιοφώνου",
  "Time": "Διάρκεια",
  "Toplist": "Κορυφαία τραγούδια",
  "Track": "Τραγούδι",
  "Unfollow": "Άρση ακολούθησης",
  "User": "Χρήστης",
  "ViewAll": "Δες τα όλα",
  "HoursShort": "{0} ώρα",
  "MinutesShort": "{0} λεπ.",
  "SecondsShort": "{0} δευτ.",
  "ErrorTitle": "Προέκυψε σφάλμα κατά την προβολή αυτής της οθόνης!",
  "ErrorMessage": "Η συγκεκριμένη προβολή δεν υπάρχει ή προέκυψε κάποιο σφάλμα.",
  "OfflineTitle": "Αυτή η προβολή δεν είναι διαθέσιμη εκτός σύνδεσης!",
  "OfflineMessage": "Συνδέσου στο διαδίκτυο για να πραγματοποιηθεί φόρτωση."
};
},{}],139:[function(require,module,exports){
module.exports = {
  "Album": "Album",
  "AndMore": "and {0} more",
  "Artist": "Artist",
  "By": "by",
  "Create Similar Playlist": "Create Similar Playlist",
  "Filter": "Filter",
  "Follow": "Follow",
  "Follower": "Follower",
  "FollowersLabel": "Followers",
  "Following": "Following",
  "FollowingLabel": "Following",
  "ListenersLabel": "Monthly Listeners",
  "FollowsYou": "Follows You",
  "HoldToPreview": "Click and Hold to Preview",
  "ListenCount": "{0} plays",
  "ListenReactionMulti": "{0} listeners in your network",
  "ListenReactionSingle": "{0} listens to this",
  "LocalFile": "Local File",
  "More": "More",
  "Pause": "Pause",
  "Play": "Play",
  "Playlist": "Playlist",
  "PressEnterToPlay": "Press Enter to play",
  "Popularity": "Popularity",
  "Remove": "Remove",
  "RemoveYourMusic": "Remove from Your Music",
  "Save": "Save",
  "SaveYourMusic": "Save to Your Music",
  "Saved": "Saved",
  "ShufflePlay": "Shuffle Play",
  "Song": "Song",
  "StartRadio": "Start Radio",
  "Time": "Time",
  "Toplist": "Top songs",
  "Track": "Song",
  "Unfollow": "Unfollow",
  "User": "User",
  "ViewAll": "View All",
  "HoursShort": "{0} hr",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} sec",
  "ErrorTitle": "There was a problem displaying this view!",
  "ErrorMessage": "This view either does not exist or an error occurred.",
  "OfflineTitle": "This view is not available offline!",
  "OfflineMessage": "Please go online to load."
}
;
},{}],140:[function(require,module,exports){
module.exports = {
  "Album": "Álbum",
  "AndMore": "y {0} más",
  "Artist": "Artista",
  "By": "por",
  "Create Similar Playlist": "Crear playlist similar",
  "Filter": "Filtrar",
  "Follow": "Seguir",
  "Follower": "Seguidor",
  "FollowersLabel": "Seguidores",
  "Following": "Siguiendo",
  "FollowingLabel": "Siguiendo",
  "ListenersLabel": "Oyentes mensuales",
  "FollowsYou": "Te sigue",
  "HoldToPreview": "Haz clic y mantén pulsado para oír la muestra preliminar",
  "ListenCount": "{0} reproducciones",
  "ListenReactionMulti": "{0} oyentes en tu red",
  "ListenReactionSingle": "{0} escucha esto",
  "LocalFile": "Archivo local",
  "More": "Más",
  "Pause": "Pausa",
  "Play": "Reproducir",
  "Playlist": "Lista",
  "PressEnterToPlay": "Presiona Enter para reproducir",
  "Popularity": "Popularidad",
  "Remove": "Eliminar",
  "RemoveYourMusic": "Eliminar de Tu Música",
  "Save": "Guardar",
  "SaveYourMusic": "Guardar en Tu Música",
  "Saved": "Guardado",
  "ShufflePlay": "Aleatoria",
  "Song": "Canción",
  "StartRadio": "Comenzar Radio",
  "Time": "Tiempo",
  "Toplist": "Canciones más reproducidas",
  "Track": "Canción",
  "Unfollow": "Dejar de seguir",
  "User": "Usuario",
  "ViewAll": "Ver todos",
  "HoursShort": "{0} hr",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} seg",
  "ErrorTitle": "Hubo un problema al mostrar esta vista.",
  "ErrorMessage": "Puede ser que esta vista no exista, o bien, que haya ocurrido un error.",
  "OfflineTitle": "Esta vista no está disponible sin conexión. ",
  "OfflineMessage": "Conéctate a la red para cargar."
};
},{}],141:[function(require,module,exports){
module.exports = {
  "Album": "Álbum",
  "AndMore": "y {0} más",
  "Artist": "Artista",
  "By": "por",
  "Create Similar Playlist": "Crear playlist similar",
  "Filter": "Filtrar",
  "Follow": "Seguir",
  "Follower": "Seguidor",
  "FollowersLabel": "Seguidores",
  "Following": "Siguiendo",
  "FollowingLabel": "Siguiendo",
  "ListenersLabel": "Oyentes mensuales",
  "FollowsYou": "Te sigue",
  "HoldToPreview": "Pulsa y mantén pulsado para oír la muestra preliminar",
  "ListenCount": "{0} reproducciones",
  "ListenReactionMulti": "{0} oyentes en tu red",
  "ListenReactionSingle": "{0} escucha esto",
  "LocalFile": "Archivo local",
  "More": "Más",
  "Pause": "Pausar",
  "Play": "Reproducir",
  "Playlist": "Lista",
  "PressEnterToPlay": "Pulsa Intro para reproducir",
  "Popularity": "Popularidad",
  "Remove": "Retirar",
  "RemoveYourMusic": "Eliminar de Tu música",
  "Save": "Guardar",
  "SaveYourMusic": "Guardar en Tu música",
  "Saved": "Guardada",
  "ShufflePlay": "Aleatoria",
  "Song": "Canción",
  "StartRadio": "Comenzar radio",
  "Time": "Tiempo",
  "Toplist": "Canciones más escuchadas",
  "Track": "Canción",
  "Unfollow": "Dejar de seguir",
  "User": "Usuario",
  "ViewAll": "Ver todos",
  "HoursShort": "{0} hr",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} seg",
  "ErrorTitle": "Se ha producido un problema al mostrar esta vista.",
  "ErrorMessage": "Esta vista no existe o se ha producido un error.",
  "OfflineTitle": "Esta vista no está disponible sin conexión. ",
  "OfflineMessage": "Por favor, conéctate para cargar."
};
},{}],142:[function(require,module,exports){
module.exports = {
  "Album": "Albumi",
  "AndMore": "ja {0} muuta",
  "Artist": "Artisti",
  "By": "tekijältä",
  "Create Similar Playlist": "Luo samankaltainen soittolista",
  "Filter": "Suodatin",
  "Follow": "Seuraa",
  "Follower": "Seuraaja",
  "FollowersLabel": "Seuraajat",
  "Following": "Seurataan",
  "FollowingLabel": "Seurataan",
  "ListenersLabel": "Kuuntelijat kuukauden aikana",
  "FollowsYou": "Seuraa sinua",
  "HoldToPreview": "Kuuntele pätkä pitämällä tätä painettuna",
  "ListenCount": "{0} toistoa",
  "ListenReactionMulti": "{0} kuuntelijaa verkostossasi",
  "ListenReactionSingle": "{0} kuuntelee tätä",
  "LocalFile": "Paikallinen tiedosto",
  "More": "Lisää",
  "Pause": "Tauko",
  "Play": "Toista",
  "Playlist": "Soittolista",
  "PressEnterToPlay": "Toista painamalla Enter-näppäintä",
  "Popularity": "Suosio",
  "Remove": "Poista",
  "RemoveYourMusic": "Poista Omasta musiikista",
  "Save": "Tallenna",
  "SaveYourMusic": "Tallenna Omaan musiikkiin",
  "Saved": "Tallennettu",
  "ShufflePlay": "Satunnaistoisto",
  "Song": "Kappale",
  "StartRadio": "Käynnistä radio",
  "Time": "Kesto",
  "Toplist": "Suosituimmat kappaleet",
  "Track": "Kappale",
  "Unfollow": "Lopeta seuraaminen",
  "User": "Käyttäjä",
  "ViewAll": "Näytä kaikki",
  "HoursShort": "{0} h",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} s",
  "ErrorTitle": "Tämän näkymän näyttämisessä on ongelmia.",
  "ErrorMessage": "Tätä näkymää ei ole, tai tapahtui virhe.",
  "OfflineTitle": "Tätä näkymää ei voi käyttää offline-tilassa!",
  "OfflineMessage": "Siirry online-tilaan, jotta voit ladata."
};
},{}],143:[function(require,module,exports){
module.exports = {
  "Album": "Album",
  "AndMore": "et {0} autres",
  "Artist": "Artiste",
  "By": "par",
  "Create Similar Playlist": "Créer une liste de lecture semblable",
  "Filter": "Filtrer",
  "Follow": "Suivre",
  "Follower": "Abonné",
  "FollowersLabel": "Abonné",
  "Following": "Suivis",
  "FollowingLabel": "Suivis",
  "ListenersLabel": "Auditeurs mensuels",
  "FollowsYou": "Vous suit",
  "HoldToPreview": "Cliquez longuement pour avoir un aperçu",
  "ListenCount": "{0} écoutes",
  "ListenReactionMulti": "{0} auditeurs dans votre réseau",
  "ListenReactionSingle": "{0} écoute ceci",
  "LocalFile": "Fichier local",
  "More": "Plus",
  "Pause": "Pause",
  "Play": "Lecture",
  "Playlist": "Playlist",
  "PressEnterToPlay": "Appuyez sur Entrée pour faire la lecture",
  "Popularity": "Popularité",
  "Remove": "Supprimer",
  "RemoveYourMusic": "Supprimer de Votre musique",
  "Save": "Sauvegarder",
  "SaveYourMusic": "Enregistrer dans Votre musique",
  "Saved": "Sauvegardé",
  "ShufflePlay": "Lecture aléatoire",
  "Song": "Titre",
  "StartRadio": "Lancer la radio",
  "Time": "Durée",
  "Toplist": "Meilleures chansons",
  "Track": "Titre",
  "Unfollow": "Ne plus suivre",
  "User": "Utilisateur",
  "ViewAll": "Voir tout",
  "HoursShort": "{0} h",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} s",
  "ErrorTitle": "Un problème est survenu lors du chargement de cet affichage!",
  "ErrorMessage": "L'affichage n'existe pas ou une erreur s'est produite.",
  "OfflineTitle": "Cette vue n'est pas disponible hors ligne!",
  "OfflineMessage": "Veuillez accéder à Internet pour charger le contenu."
};
},{}],144:[function(require,module,exports){
module.exports = {
  "Album": "Album",
  "AndMore": "et {0} autres",
  "Artist": "Artiste",
  "By": "par",
  "Create Similar Playlist": "Créer une playlist similaire",
  "Filter": "Filtre",
  "Follow": "S'abonner",
  "Follower": "Abonné",
  "FollowersLabel": "Abonnés",
  "Following": "Abonné",
  "FollowingLabel": "Abonné",
  "ListenersLabel": "Nombres de personnes qui écoutent par mois",
  "FollowsYou": "Est abonné à vous",
  "HoldToPreview": "Cliquez longuement pour avoir un aperçu",
  "ListenCount": "{0} écoutes",
  "ListenReactionMulti": "{0} auditeurs dans votre réseau",
  "ListenReactionSingle": "{0} écoute ceci.",
  "LocalFile": "Fichier local",
  "More": "Plus",
  "Pause": "Pause",
  "Play": "Lire",
  "Playlist": "Playlist",
  "PressEnterToPlay": "Appuyez sur Entrée pour écouter",
  "Popularity": "Popularité",
  "Remove": "Supprimer",
  "RemoveYourMusic": "Supprimer de Ma musique",
  "Save": "Sauvegarder",
  "SaveYourMusic": "Sauvegarder dans Ma musique",
  "Saved": "Sauvegardé",
  "ShufflePlay": "Aléatoire",
  "Song": "Titre",
  "StartRadio": "Ecouter la radio",
  "Time": "Durée",
  "Toplist": "Top titres",
  "Track": "Titre",
  "Unfollow": "Se désabonner",
  "User": "Utilisateur",
  "ViewAll": "Présentation tout",
  "HoursShort": "{0} h",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} s",
  "ErrorTitle": "Problème d'affichage !",
  "ErrorMessage": "Cet affichage n'existe pas ou une erreur s'est produite.",
  "OfflineTitle": "Cet affichage n'est pas disponible hors connexion.",
  "OfflineMessage": "Connectez-vous pour procéder au chargement."
};
},{}],145:[function(require,module,exports){
module.exports = {
  "Album": "Album",
  "AndMore": "és még {0} felhasználó",
  "Artist": "Előadó",
  "By": "tőle:",
  "Create Similar Playlist": "Hasonló műsorlista létrehozása",
  "Filter": "Szűrő",
  "Follow": "Követés",
  "Follower": "Követő",
  "FollowersLabel": "Követők",
  "Following": "Követések",
  "FollowingLabel": "Követések",
  "ListenersLabel": "Hallgatók havonta",
  "FollowsYou": "Téged követ",
  "HoldToPreview": "Tartsd nyomva a belehallgatáshoz",
  "ListenCount": "{0} lejátszás",
  "ListenReactionMulti": "{0} ismerősöd hallgatta meg",
  "ListenReactionSingle": "{0} már meghallgatta",
  "LocalFile": "Helyi fájl",
  "More": "Több",
  "Pause": "Szünet",
  "Play": "Lejátszás",
  "Playlist": "Lejátszási lista",
  "PressEnterToPlay": "Lejátszás az Enterrel",
  "Popularity": "Népszerűség",
  "Remove": "Eltávolítás",
  "RemoveYourMusic": "Törlés a Zenéid közül",
  "Save": "Mentés",
  "SaveYourMusic": "Mentés a Zenéid közé",
  "Saved": "Mentett",
  "ShufflePlay": "Lejátszás keverve",
  "Song": "Dal",
  "StartRadio": "Rádió bekapcsolása",
  "Time": "Idő",
  "Toplist": "Toplista",
  "Track": "Dal",
  "Unfollow": "Nem követem",
  "User": "Felhasználó",
  "ViewAll": "Mindent mutat",
  "HoursShort": "{0} óra",
  "MinutesShort": "{0} perc",
  "SecondsShort": "{0} mp",
  "ErrorTitle": "Egy hiba miatt nem jeleníthető meg ez az oldal",
  "ErrorMessage": "A kért nézet nem létezik, vagy valamilyen műszaki hiba történt.",
  "OfflineTitle": "Ez a nézet internetkapcsolat nélkül nem érhető el.",
  "OfflineMessage": "Csatlakozz az internethez, majd indítsd el."
};
},{}],146:[function(require,module,exports){
module.exports = {
  "Album": "Album",
  "AndMore": "dan {0} lagi",
  "Artist": "Artis",
  "By": "menurut",
  "Create Similar Playlist": "Buat Playlist Serupa",
  "Filter": "Filter",
  "Follow": "Ikuti",
  "Follower": "Pengikut",
  "FollowersLabel": "Pengikut",
  "Following": "Mengikuti",
  "FollowingLabel": "Mengikuti",
  "ListenersLabel": "Pendengar Bulanan",
  "FollowsYou": "Mengikutimu",
  "HoldToPreview": "Klik dan Tahan untuk Pratinjau",
  "ListenCount": "{0} permainan",
  "ListenReactionMulti": "{0} pendengar di jaringanmu",
  "ListenReactionSingle": "{0} mendengarkan ini",
  "LocalFile": "File Lokal",
  "More": "Lainnya",
  "Pause": "Jeda",
  "Play": "Play",
  "Playlist": "Playlist",
  "PressEnterToPlay": "Tekan Enter untuk memainkan",
  "Popularity": "Popularitas",
  "Remove": "Hapus",
  "RemoveYourMusic": "Hapus dari Musik Kamu",
  "Save": "Simpan",
  "SaveYourMusic": "Simpan ke Musik Kamu",
  "Saved": "Tersimpan",
  "ShufflePlay": "Pemutaran Acak",
  "Song": "Lagu",
  "StartRadio": "Mulai Radio",
  "Time": "Waktu",
  "Toplist": "Lagu teratas",
  "Track": "Lagu",
  "Unfollow": "Berhenti mengikuti",
  "User": "Pengguna",
  "ViewAll": "Lihat Semua",
  "HoursShort": "{0} jam",
  "MinutesShort": "{0} mnt",
  "SecondsShort": "{0} dtk",
  "ErrorTitle": "Ada masalah saat menampilkan tampilan ini!",
  "ErrorMessage": "Tampilan ini tidak ada atau terjadi kesalahan.",
  "OfflineTitle": "Tampilan ini tidak tersedia offline.",
  "OfflineMessage": "Alihkan ke online untuk memuat."
};
},{}],147:[function(require,module,exports){
module.exports = {
  "Album": "Album",
  "AndMore": "e altri {0}",
  "Artist": "Artista",
  "By": "per",
  "Create Similar Playlist": "Crea playlist simile",
  "Filter": "Filtra",
  "Follow": "Segui",
  "Follower": "Follower",
  "FollowersLabel": "Follower",
  "Following": "Following",
  "FollowingLabel": "Following",
  "ListenersLabel": "Ascoltatori questo mese",
  "FollowsYou": "Ti segue",
  "HoldToPreview": "Tieni premuto per un'anteprima",
  "ListenCount": "{0} riproduzioni",
  "ListenReactionMulti": "{0} ascoltatori nella tua rete",
  "ListenReactionSingle": "{0} ascolta questo",
  "LocalFile": "File locale",
  "More": "Più",
  "Pause": "Pausa",
  "Play": "Play",
  "Playlist": "Playlist",
  "PressEnterToPlay": "Premi Invio per riprodurre",
  "Popularity": "Popolarità",
  "Remove": "Rimuovi",
  "RemoveYourMusic": "Elimina da La tua musica",
  "Save": "Salva",
  "SaveYourMusic": "Salva in La tua musica",
  "Saved": "Salvato",
  "ShufflePlay": "Riproduzione shuffle",
  "Song": "Brano",
  "StartRadio": "Crea una radio",
  "Time": "Durata",
  "Toplist": "Brani top",
  "Track": "Brano",
  "Unfollow": "Non seguire più",
  "User": "Utente",
  "ViewAll": "Visualizza tutto",
  "HoursShort": "{0} ore",
  "MinutesShort": "{0} min.",
  "SecondsShort": "{0} sec",
  "ErrorTitle": "Si è verificato un errore in questa vista.",
  "ErrorMessage": "La vista non esiste o si è verificato un errore.",
  "OfflineTitle": "Questa vista non è disponibile offline.",
  "OfflineMessage": "Passa online per caricare."
};
},{}],148:[function(require,module,exports){
module.exports = {
  "Album": "アルバム",
  "AndMore": "その他{0}人",
  "Artist": "アーティスト",
  "By": "/",
  "Create Similar Playlist": "同様のプレイリストを作成",
  "Filter": "フィルタ",
  "Follow": "フォロー",
  "Follower": "フォロワー",
  "FollowersLabel": "フォロワー",
  "Following": "フォロー中",
  "FollowingLabel": "フォロー中",
  "ListenersLabel": "今月のリスナー",
  "FollowsYou": "あなたをフォローしています",
  "HoldToPreview": "プレビューするには、クリックを押しします",
  "ListenCount": "{0}回再生",
  "ListenReactionMulti": "ネットワーク内で{0}人が聴いています",
  "ListenReactionSingle": "{0}さんはこれを聴いています",
  "LocalFile": "ローカルファイル",
  "More": "詳細",
  "Pause": "一時停止",
  "Play": "再生",
  "Playlist": "プレイリスト",
  "PressEnterToPlay": "再生するにはEnterキーを押します",
  "Popularity": "人気",
  "Remove": "削除",
  "RemoveYourMusic": "My Musicから削除",
  "Save": "保存",
  "SaveYourMusic": "My Musicに保存",
  "Saved": "保存済み",
  "ShufflePlay": "シャッフルプレイ",
  "Song": "ソング",
  "StartRadio": "Radioを開始",
  "Time": "時間",
  "Toplist": "トップ曲",
  "Track": "ソング",
  "Unfollow": "フォローをやめる",
  "User": "ユーザー",
  "ViewAll": "すべて表示",
  "HoursShort": "{0} 時間",
  "MinutesShort": "{0} 分",
  "SecondsShort": "{0} 秒",
  "ErrorTitle": "このビューを表示しようとしているときに問題が発生しました。",
  "ErrorMessage": "このビューが存在しないか、エラーが発生しました。",
  "OfflineTitle": "このビューはオフラインでは使用できません。",
  "OfflineMessage": "ロードするには、インターネットに接続してください。"
};
},{}],149:[function(require,module,exports){
module.exports = {
  "Album": "Album",
  "AndMore": "en {0} meer",
  "Artist": "Artiest",
  "By": "van",
  "Create Similar Playlist": "Vergelijkbare afspeellijst maken",
  "Filter": "Filter",
  "Follow": "Volgen",
  "Follower": "Volger",
  "FollowersLabel": "Volgers",
  "Following": "Volgend",
  "FollowingLabel": "Volgend",
  "ListenersLabel": "Luisteraars per maand",
  "FollowsYou": "Volgt jou",
  "HoldToPreview": "Klikken en vasthouden om een stukje te horen",
  "ListenCount": "{0} keer afgespeeld",
  "ListenReactionMulti": "{0} luisteraars in jouw netwerk",
  "ListenReactionSingle": "{0} luistert hiernaar",
  "LocalFile": "Lokaal bestand",
  "More": "Meer",
  "Pause": "Pauze",
  "Play": "Afspelen",
  "Playlist": "Afspeellijst",
  "PressEnterToPlay": "Druk op Enter om af te spelen",
  "Popularity": "Populariteit",
  "Remove": "Verwijderen",
  "RemoveYourMusic": "Verwijderen uit Jouw Muziek",
  "Save": "Opslaan",
  "SaveYourMusic": "Opslaan in Jouw Muziek",
  "Saved": "Opgeslagen",
  "ShufflePlay": "Shuffle",
  "Song": "Nummer",
  "StartRadio": "Radio starten",
  "Time": "Tijd",
  "Toplist": "Topnummers",
  "Track": "Nummer",
  "Unfollow": "Niet meer volgen",
  "User": "Gebruiker",
  "ViewAll": "Alles bekijken",
  "HoursShort": "{0} uur",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} sec",
  "ErrorTitle": "Er is een fout opgetreden bij het laden van deze weergave.",
  "ErrorMessage": "Deze weergave bestaat niet of er is een fout opgetreden.",
  "OfflineTitle": "Deze weergave is offline niet beschikbaar!",
  "OfflineMessage": "Ga online om te laden."
};
},{}],150:[function(require,module,exports){
module.exports = {
  "Album": "Album",
  "AndMore": "i {0} więcej",
  "Artist": "Wykonawca",
  "By": "według",
  "Create Similar Playlist": "Utwórz podobną playlistę",
  "Filter": "Filtruj",
  "Follow": "Obserwuj",
  "Follower": "Obserwujący",
  "FollowersLabel": "Obserwatorzy",
  "Following": "Obserwowana",
  "FollowingLabel": "Obserwowana",
  "ListenersLabel": "Słuchacze w tym miesiącu",
  "FollowsYou": "Obserwuje Cię",
  "HoldToPreview": "Aby odsłuchać, kliknij i przytrzymaj.",
  "ListenCount": "Liczba odtworzeń: {0}",
  "ListenReactionMulti": "Liczba słuchaczy w Twojej sieci: {0}",
  "ListenReactionSingle": "Użytkownik {0} słucha tego",
  "LocalFile": "Plik lokalny",
  "More": "Więcej",
  "Pause": "Pauza",
  "Play": "Odtwórz",
  "Playlist": "Playlista",
  "PressEnterToPlay": "Naciśnij Enter, aby odtworzyć",
  "Popularity": "Popularność",
  "Remove": "Usuń",
  "RemoveYourMusic": "Usuń z kolekcji Twoja muzyka",
  "Save": "Zapisz",
  "SaveYourMusic": "Zapisz w kolekcji Twoja muzyka",
  "Saved": "Zapisany",
  "ShufflePlay": "Odtwarzanie losowe",
  "Song": "Utwór",
  "StartRadio": "Włącz radio",
  "Time": "Czas",
  "Toplist": "Najpopularniejsze utwory",
  "Track": "Utwór",
  "Unfollow": "Przestań obserwować",
  "User": "Użytkownik",
  "ViewAll": "Wyświetl wszystko",
  "HoursShort": "{0} godz.",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} s",
  "ErrorTitle": "Podczas wyświetlania tego widoku wystąpił błąd!",
  "ErrorMessage": "Ten widok nie istnieje lub wystąpił błąd.",
  "OfflineTitle": "Ten widok jest niedostępny w trybie offline. ",
  "OfflineMessage": "Przejdź do trybu online, aby załadować."
};
},{}],151:[function(require,module,exports){
module.exports = {
  "Album": "Álbum",
  "AndMore": "e mais {0}",
  "Artist": "Artista",
  "By": "de",
  "Create Similar Playlist": "Criar playlist similar",
  "Filter": "Filtrar",
  "Follow": "Seguir",
  "Follower": "Seguidor",
  "FollowersLabel": "Seguidores",
  "Following": "Seguindo",
  "FollowingLabel": "Seguindo",
  "ListenersLabel": "Ouvintes mensais",
  "FollowsYou": "Segue você",
  "HoldToPreview": "Clique e segure para a prévia",
  "ListenCount": "{0} reproduções",
  "ListenReactionMulti": "{0} ouvintes na sua rede",
  "ListenReactionSingle": "{0} ouvem isso",
  "LocalFile": "Arquivo local",
  "More": "Mais",
  "Pause": "Pause",
  "Play": "Play",
  "Playlist": "Playlist",
  "PressEnterToPlay": "Pressione Enter para tocar",
  "Popularity": "Popularidade",
  "Remove": "Remover",
  "RemoveYourMusic": "Remover de Suas músicas",
  "Save": "Salvar",
  "SaveYourMusic": "Salvar em Suas músicas",
  "Saved": "Salvo",
  "ShufflePlay": "Ordem aleatória",
  "Song": "Música",
  "StartRadio": "Abrir rádio",
  "Time": "Tempo",
  "Toplist": "Músicas mais tocadas",
  "Track": "Música",
  "Unfollow": "Deixar de seguir",
  "User": "Usuário",
  "ViewAll": "Ver tudo",
  "HoursShort": "{0} h",
  "MinutesShort": "{0} m",
  "SecondsShort": "{0} s",
  "ErrorTitle": "Tivemos um problema ao mostrar esta exibição!",
  "ErrorMessage": "A exibição não existe ou ocorreu um erro.",
  "OfflineTitle": "Essa visualização não está disponível offline!",
  "OfflineMessage": "Fique online para carregar."
};
},{}],152:[function(require,module,exports){
module.exports = {
  "Album": "Album",
  "AndMore": "och {0} till",
  "Artist": "Artist",
  "By": "av",
  "Create Similar Playlist": "Skapa en liknande spellista",
  "Filter": "Filtrera",
  "Follow": "Följ",
  "Follower": "Följare",
  "FollowersLabel": "Följare",
  "Following": "Följer",
  "FollowingLabel": "Följer",
  "ListenersLabel": "Lyssnare per månad",
  "FollowsYou": "Följer dig",
  "HoldToPreview": "Klicka och håll kvar för att förhandslyssna",
  "ListenCount": "{0} uppspelningar",
  "ListenReactionMulti": "{0} lyssnare i ditt nätverk",
  "ListenReactionSingle": "{0} lyssnar på detta",
  "LocalFile": "Lokal fil",
  "More": "Mer",
  "Pause": "Pausa",
  "Play": "Spela upp",
  "Playlist": "Spellista",
  "PressEnterToPlay": "Tryck på Retur om du vill lyssna",
  "Popularity": "Popularitet",
  "Remove": "Ta bort",
  "RemoveYourMusic": "Ta bort från Din Musik",
  "Save": "Spara",
  "SaveYourMusic": "Spara i Din Musik",
  "Saved": "Sparade",
  "ShufflePlay": "Slumpmässig uppspelning",
  "Song": "Låt",
  "StartRadio": "Starta radio",
  "Time": "Tid",
  "Toplist": "Topplåtar",
  "Track": "Låt",
  "Unfollow": "Sluta följa",
  "User": "Användare",
  "ViewAll": "Visa alla",
  "HoursShort": "{0} tim",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} sek",
  "ErrorTitle": "Det uppstod ett fel när den här vyn skulle visas!",
  "ErrorMessage": "Den här vyn finns inte eller så uppstod ett fel.",
  "OfflineTitle": "Den här vyn är inte tillgänglig offline.",
  "OfflineMessage": "Anslut till internet om du vill läsa in appen."
};
},{}],153:[function(require,module,exports){
module.exports = {
  "Album": "Albüm",
  "AndMore": "ve {0} daha",
  "Artist": "Sanatçı",
  "By": "-",
  "Create Similar Playlist": "Benzer Çalma Listesi Oluştur",
  "Filter": "Filtrele",
  "Follow": "Takip Et",
  "Follower": "Takipçi",
  "FollowersLabel": "Takipçiler",
  "Following": "Takip Ediliyor",
  "FollowingLabel": "Takip Ediliyor",
  "ListenersLabel": "Aylık Dinleyici",
  "FollowsYou": "Seni Takip Ediyor",
  "HoldToPreview": "Basılı Tut ve Önizle",
  "ListenCount": "{0} dinleme",
  "ListenReactionMulti": "Ağında {0} dinleyici",
  "ListenReactionSingle": "{0} bunu dinliyor",
  "LocalFile": "Yerel Dosya",
  "More": "Daha fazla",
  "Pause": "Duraklat",
  "Play": "Çal",
  "Playlist": "Çalma listesi",
  "PressEnterToPlay": "Çalmak için Enter'a bas",
  "Popularity": "Popülerlik",
  "Remove": "Çıkar",
  "RemoveYourMusic": "Müziklerin'den çıkar",
  "Save": "Kaydet",
  "SaveYourMusic": "Müziklerin'e kaydet",
  "Saved": "Kaydedildi",
  "ShufflePlay": "Karışık Çal",
  "Song": "Şarkı",
  "StartRadio": "Radyoyu Başlat",
  "Time": "Saat",
  "Toplist": "En çok dinlenen şarkılar",
  "Track": "Şarkı",
  "Unfollow": "Takip Etmeyi Bırak",
  "User": "Kullanıcı",
  "ViewAll": "Tümünü Görüntüle",
  "HoursShort": "{0} sa",
  "MinutesShort": "{0} dk",
  "SecondsShort": "{0} sn",
  "ErrorTitle": "Bu öğe görüntülenirken bir sorun oluştu!",
  "ErrorMessage": "Bu görünüm yok veya bir hata oluştu.",
  "OfflineTitle": "Bu görünüm çevrimdışıyken kullanılamaz!",
  "OfflineMessage": "Yüklemek için lütfen çevrimiçi ol."
};
},{}],154:[function(require,module,exports){
module.exports = {
  "Album": "專輯",
  "AndMore": "還有 {0} 首",
  "Artist": "藝人",
  "By": "－",
  "Create Similar Playlist": "建立相似的播放清單",
  "Filter": "篩選",
  "Follow": "關注",
  "Follower": "粉絲",
  "FollowersLabel": "關注者",
  "Following": "正在關注",
  "FollowingLabel": "正在關注",
  "ListenersLabel": "每月聽眾",
  "FollowsYou": "關注你",
  "HoldToPreview": "按住即可預覽",
  "ListenCount": "播放了 {0} 次",
  "ListenReactionMulti": "在你的社群網路中有 {0} 名聽眾",
  "ListenReactionSingle": "{0} 收聽了這首歌曲",
  "LocalFile": "本機檔案",
  "More": "更多",
  "Pause": "暫停",
  "Play": "播放",
  "Playlist": "播放列表",
  "PressEnterToPlay": "請按 Enter 播放",
  "Popularity": "流行",
  "Remove": "移除",
  "RemoveYourMusic": "從你的音樂中移除",
  "Save": "儲存",
  "SaveYourMusic": "儲存至你的音樂",
  "Saved": "已儲存",
  "ShufflePlay": "隨機播放",
  "Song": "歌曲",
  "StartRadio": "啟用電臺",
  "Time": "時間",
  "Toplist": "當紅歌曲",
  "Track": "歌曲",
  "Unfollow": "取消關注",
  "User": "使用者",
  "ViewAll": "檢視全部",
  "HoursShort": "{0} 小時",
  "MinutesShort": "{0} 分鐘",
  "SecondsShort": "{0} 秒鐘",
  "ErrorTitle": "顯示這個畫面時出現問題。",
  "ErrorMessage": "這個畫面可能不存在或發生錯誤。",
  "OfflineTitle": "離線時無法使用這個檢視！",
  "OfflineMessage": "請上網以載入。"
};
},{}],155:[function(require,module,exports){
module.exports = {
  "Album": "Album",
  "AndMore": "dan {0} lagi",
  "Artist": "Artis",
  "By": "oleh",
  "Create Similar Playlist": "Cipta Senarai Main Serupa",
  "Filter": "Penapis",
  "Follow": "Ikut",
  "Follower": "Pengikut",
  "FollowersLabel": "Pengikut",
  "Following": "Mengikuti",
  "FollowingLabel": "Mengikuti",
  "ListenersLabel": "Pendengar Bulanan",
  "FollowsYou": "Megikuti Anda",
  "HoldToPreview": "Klik dan Tahan untuk Pratonton",
  "ListenCount": "{0} main",
  "ListenReactionMulti": "{0} pendengar dalam rangkaian anda",
  "ListenReactionSingle": "{0} mendengar ini",
  "LocalFile": "Fail Setempat",
  "More": "Lebih banyak",
  "Pause": "Jeda",
  "Play": "Main",
  "Playlist": "Senarai main",
  "PressEnterToPlay": "Tekan Enter untuk main",
  "Popularity": "Populariti",
  "Remove": "Keluarkan",
  "RemoveYourMusic": "Keluarkan daripada Muzik Anda",
  "Save": "Simpan",
  "SaveYourMusic": "Simpan ke Muzik Anda",
  "Saved": "Disimpan",
  "ShufflePlay": "Main Rombak",
  "Song": "Lagu",
  "StartRadio": "Mulakan Radio",
  "Time": "Masa",
  "Toplist": "Lagu popular",
  "Track": "Lagu",
  "Unfollow": "Nyahikut",
  "User": "Pengguna",
  "ViewAll": "Lihat Semua",
  "HoursShort": "{0} jam",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} saat",
  "ErrorTitle": "Terdapat masalah memaparkan paparan ini!",
  "ErrorMessage": "Paparan ini sama ada tidak wujud atau ralat berlaku.",
  "OfflineTitle": "Paparan ini tidak tersedia di luar talian!",
  "OfflineMessage": "Sila ke online untuk memuatkan."
};
},{}],156:[function(require,module,exports){
'use strict';

exports.getVersion = require('./src/version').getVersion;
exports.gridOverlay = require('./src/gridOverlay');

},{"./src/gridOverlay":157,"./src/version":158}],157:[function(require,module,exports){
(function (global){
'use strict';

var cosmos = require('spotify-cosmos-api');

var DEFAULT_GRID_COLOR = 'rgba(251, 74, 131, 0.22)';
var DEFAULT_GRID_COLOR_HIGHLIGHT = 'rgba(251, 74, 131, 0.8)';
var GRID_BASELINE = 8;

var overlayElement = null;
var baselineHighlightElement = null;
var gridColor = '';
var highlightGridColor = '';
var gridModes = ['off', 'column', 'baseline'];
var currentModeIndex = 0;

/**
 * Listen for control messages to toggle the grid when a menu item is clicked
 * or a keyboard shortcut is pressed. This only happens if the user is a global
 * app developer.
 */
function listen() {
  var spotify = global.__spotify;
  var productState = spotify && spotify.product_state;
  var appDeveloperFlag = productState && productState['app-developer'];

  if (appDeveloperFlag === '3' || appDeveloperFlag === '7') {
    cosmos.resolver.subscribe({
      url: 'sp://messages/v1/container/control'
    }, function (error, response) {
      if (error) return;
      var data = response.getJSONBody();
      if (data && data.type === 'toggle_grid') {
        toggle();
      }
    });
  }
}

/**
 * Toggle the grid overlay.
 */
function toggle() {
  var newIndex = currentModeIndex + 1;
  if (newIndex > gridModes.length - 1) {
    newIndex = 0;
  }

  var mode = gridModes[newIndex];

  if (mode === 'off') {
    disable();
  } else {
    enable(mode);
  }
}

/**
 * Enable the grid overlay.
 *
 * @param {string} mode The grid mode to enable, 'column' or 'baseline'.
 */
function enable(mode) {
  if (!mode) {
    return;
  }

  if (gridModes[currentModeIndex] === mode) {
    return;
  }

  currentModeIndex = gridModes.indexOf(mode);

  if (overlayElement && overlayElement.parentNode) {
    overlayElement.parentNode.removeChild(overlayElement);
  }

  if (mode === 'baseline') {
    document.addEventListener('mousemove', onMouseMove, false);
  }

  overlayElement = createOverlayElement();

  document.body.appendChild(overlayElement);
}

/**
 * Disable the grid overlay.
 */
function disable() {
  if (gridModes[currentModeIndex] === 'off') {
    return;
  }

  if (overlayElement && overlayElement.parentNode) {
    overlayElement.parentNode.removeChild(overlayElement);
  }

  currentModeIndex = gridModes.indexOf('off');
  overlayElement = null;
  baselineHighlightElement = null;

  document.removeEventListener('mousemove', onMouseMove, false);
}

/**
 * Set the color used for each grid column or baseline line.
 *
 * @param {string} color Any valid CSS color.
 * @param {string=} highlightColor Any valid CSS color. Can be omitted for
 *     column grid.
 */
function setColor(color, highlightColor) {
  gridColor = color;
  highlightGridColor = highlightColor;
}

/**
 * Reset all state in this module.
 */
function reset() {
  overlayElement = null;
  baselineHighlightElement = null;
  gridColor = '';
  highlightGridColor = '';
  currentModeIndex = 0;
}

/**
 * Mouse move handler that highlights the hovered baseline line.
 *
 * @param {Event} event A mousemove event object.
 *
 * @private
 */
function onMouseMove(event) {
  if (!baselineHighlightElement) {
    baselineHighlightElement = document.createElement('div');
    baselineHighlightElement.className = 'grid-overlay-baseline-highlight';
    baselineHighlightElement.style.backgroundColor = highlightGridColor || DEFAULT_GRID_COLOR_HIGHLIGHT;
    overlayElement.appendChild(baselineHighlightElement);
  }

  // Calculate the Y position for the baseline line closest to the pointer
  var pointerPos = event.clientY + window.scrollY;
  var yLineAbove = Math.floor(pointerPos / GRID_BASELINE) * GRID_BASELINE;
  var y = yLineAbove + (pointerPos % GRID_BASELINE > 4 ? GRID_BASELINE : 0);

  baselineHighlightElement.style.top = y - 1 + 'px';
}

/**
 * Create the DOM nodes needed for the overlay, with the correct class names
 * and styles.
 *
 * @return {HTMLElement} The container element for the overlay.
 *
 * @private
 */
function createOverlayElement() {
  var color = gridColor || DEFAULT_GRID_COLOR;

  var container = document.createElement('div');
  container.className = 'grid-overlay container';

  if (gridModes[currentModeIndex] === 'column') {
    var row = document.createElement('div');
    row.className = 'grid-overlay-row row';
    container.appendChild(row);

    var sizeLabel = createSizeLabel();
    container.appendChild(sizeLabel);

    var columnClassNames = 'col-xs-1 col-sm-1 col-md-1 col-lg-1';

    for (var i = 0; i < 12; i++) {
      var column = document.createElement('div');
      column.className = 'grid-overlay-col-' + (i + 1) + ' ' + columnClassNames;

      column.style.backgroundColor = color;

      row.appendChild(column);
    }
  } else if (gridModes[currentModeIndex] === 'baseline') {
    container.classList.add('grid-overlay-baseline');

    var baselinePercentage = (GRID_BASELINE - 1) / GRID_BASELINE * 100 + '%';

    var backgroundImage = ['linear-gradient(', 'to bottom, ', 'transparent, ', 'transparent ' + baselinePercentage + ', ', color + ' ' + baselinePercentage, ')'].join('');

    container.style.backgroundImage = backgroundImage;

    // Because JSDOM is using the package 'cssstyle', which is stupid and
    // doesn't support gradients as values...
    container.style._backgroundImage = backgroundImage;
  }

  return container;
}

/**
 * Create the DOM nodes needed for the grid size label.
 *
 * @return {HTMLElement} A DOM node.
 *
 * @private
 */
function createSizeLabel() {
  var sizes = [{ name: 'Extra Small', id: 'xs' }, { name: 'Small', id: 'sm' }, { name: 'Medium', id: 'md' }, { name: 'Large', id: 'lg' }];

  var labelContainer = document.createElement('div');
  labelContainer.className = 'grid-overlay-label';

  sizes.forEach(function (size) {
    var label = document.createElement('span');
    label.className = 'visible-' + size.id;
    label.textContent = size.name;
    labelContainer.appendChild(label);
  });

  return labelContainer;
}

exports.listen = listen;
exports.toggle = toggle;
exports.enable = enable;
exports.disable = disable;
exports.setColor = setColor;
exports.reset = reset;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"spotify-cosmos-api":416}],158:[function(require,module,exports){
'use strict';

// This should be removed later when nothing is calling this method

exports.getVersion = function () {
  return 1;
};

},{}],159:[function(require,module,exports){
'use strict';

module.exports = {
  'de': require('../i18n/de.lang'),
  'el': require('../i18n/el.lang'),
  'en': require('../i18n/en.lang'),
  'es': require('../i18n/es.lang'),
  'es-419': require('../i18n/es-419.lang'),
  'fi': require('../i18n/fi.lang'),
  'fr': require('../i18n/fr.lang'),
  'fr-CA': require('../i18n/fr-CA.lang'),
  'hu': require('../i18n/hu.lang'),
  'id': require('../i18n/id.lang'),
  'it': require('../i18n/it.lang'),
  'ja': require('../i18n/ja.lang'),
  'nl': require('../i18n/nl.lang'),
  'pl': require('../i18n/pl.lang'),
  'pt-BR': require('../i18n/pt-BR.lang'),
  'sv': require('../i18n/sv.lang'),
  'tr': require('../i18n/tr.lang'),
  'zh-Hant': require('../i18n/zh-Hant.lang'),
  'zsm': require('../i18n/zsm.lang')
};

},{"../i18n/de.lang":137,"../i18n/el.lang":138,"../i18n/en.lang":139,"../i18n/es-419.lang":140,"../i18n/es.lang":141,"../i18n/fi.lang":142,"../i18n/fr-CA.lang":143,"../i18n/fr.lang":144,"../i18n/hu.lang":145,"../i18n/id.lang":146,"../i18n/it.lang":147,"../i18n/ja.lang":148,"../i18n/nl.lang":149,"../i18n/pl.lang":150,"../i18n/pt-BR.lang":151,"../i18n/sv.lang":152,"../i18n/tr.lang":153,"../i18n/zh-Hant.lang":154,"../i18n/zsm.lang":155}],160:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, functionType="function", self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1, helper, options;
  buffer += "\n        <h1 class=\"hdr-l\">"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "ErrorTitle", options) : helperMissing.call(depth0, "loc", "ErrorTitle", options)))
    + "</h1>\n        <div class=\"message\">";
  stack1 = (helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "ErrorMessage", options) : helperMissing.call(depth0, "loc", "ErrorMessage", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "</div>\n      ";
  return buffer;
  }

function program3(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n        <h1 class=\"hdr-l\">";
  if (helper = helpers.errorTitle) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.errorTitle); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</h1>\n        <div class=\"message\">";
  if (helper = helpers.errorMessage) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.errorMessage); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "</div>\n      ";
  return buffer;
  }

function program5(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n        <a class=\"button button-white\" href=\"";
  if (helper = helpers.errorEscapeUrl) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.errorEscapeUrl); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-log-click=\"error-escape\">";
  if (helper = helpers.errorEscapeMessage) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.errorEscapeMessage); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</a>\n      ";
  return buffer;
  }

function program7(depth0,data) {
  
  var buffer = "", stack1, helper, options;
  buffer += "\n        <h1 class=\"hdr-l\">"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "OfflineTitle", options) : helperMissing.call(depth0, "loc", "OfflineTitle", options)))
    + "</h1>\n        <div class=\"message\">";
  stack1 = (helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "OfflineMessage", options) : helperMissing.call(depth0, "loc", "OfflineMessage", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "</div>\n      ";
  return buffer;
  }

function program9(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n        <h1 class=\"hdr-l\">";
  if (helper = helpers.offlineTitle) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.offlineTitle); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</h1>\n        <div class=\"message\">";
  if (helper = helpers.offlineMessage) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.offlineMessage); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "</div>\n      ";
  return buffer;
  }

function program11(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n        <a class=\"button button-white\" href=\"";
  if (helper = helpers.offlineEscapeUrl) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.offlineEscapeUrl); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-log-click=\"offline-escape\">";
  if (helper = helpers.offlineEscapeMessage) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.offlineEscapeMessage); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</a>\n      ";
  return buffer;
  }

function program13(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n  <div class=\"error-version text-muted\">";
  if (helper = helpers.errorVersion) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.errorVersion); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</div>\n  ";
  return buffer;
  }

  buffer += "<div class=\"error-and-offline\" data-log-context=\"error-and-offline\">\n  <div class=\"container\">\n    <div class=\"error-content\">\n      ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.useDefaultError), {hash:{},inverse:self.program(3, program3, data),fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.errorEscapeMessage), {hash:{},inverse:self.noop,fn:self.program(5, program5, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    </div>\n    <div class=\"offline-content\">\n      ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.useDefaultOffline), {hash:{},inverse:self.program(9, program9, data),fn:self.program(7, program7, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.offlineEscapeMessage), {hash:{},inverse:self.noop,fn:self.program(11, program11, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    </div>\n  </div>\n  ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.errorVersion), {hash:{},inverse:self.noop,fn:self.program(13, program13, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n</div>\n";
  return buffer;
  });

},{"hbsfy/runtime":347}],161:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
var partial$0 = require('./media/image.hbs');
HandlebarsCompiler.registerPartial('./media/image.hbs', partial$0);
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); partials = this.merge(partials, Handlebars.partials); data = data || {};
  var buffer = "", stack1, helper, options, functionType="function", escapeExpression=this.escapeExpression, helperMissing=helpers.helperMissing, self=this, blockHelperMissing=helpers.blockHelperMissing;

function program1(depth0,data) {
  
  var buffer = "", stack1, helper, options;
  buffer += "\n  <div class=\"facepile\" data-tooltip title=\"";
  if (helper = helpers.name) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.name); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-tooltip-instant>\n    <div class=\"media-object media-object-image media-object-link media-object-simple media-object-"
    + escapeExpression((helper = helpers.type || (depth0 && depth0.type),options={hash:{},data:data},helper ? helper.call(depth0, (depth0 && depth0.uri), options) : helperMissing.call(depth0, "type", (depth0 && depth0.uri), options)))
    + " ";
  options={hash:{},inverse:self.program(2, program2, data),fn:self.noop,data:data}
  if (helper = helpers.imageUrl) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.imageUrl); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.imageUrl) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.program(2, program2, data),fn:self.noop,data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\"\n      data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"\n      data-log-context=\"media-object\"\n      data-contextmenu>\n      <div class=\"mo-wrapper\">\n        <div class=\"mo-image-wrapper\">\n          <a href=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-log-click=\"media-image\">\n            ";
  stack1 = self.invokePartial(partials['./media/image.hbs'], './media/image.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n          </a>\n        </div>\n      </div>\n    </div>\n  </div>\n";
  return buffer;
  }
function program2(depth0,data) {
  
  
  return "show-placeholder";
  }

function program4(depth0,data,depth1) {
  
  var buffer = "", stack1, helper;
  buffer += "\n  <button\n    type=\"button\"\n    class=\"button facepile-badge\"\n    title=\"";
  if (helper = helpers.badgeTooltip) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.badgeTooltip); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"\n    data-tooltip\n    data-tooltip-instant\n    data-modal=\"spotify:modal:socialproof:"
    + escapeExpression(((stack1 = (depth1 && depth1.uri)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\"\n  >\n    +";
  if (helper = helpers.badgeCount) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.badgeCount); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\n  </button>\n";
  return buffer;
  }

  stack1 = (helper = helpers.facepile || (depth0 && depth0.facepile),options={hash:{},inverse:self.programWithDepth(4, program4, data, depth0),fn:self.program(1, program1, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.listeners), (depth0 && depth0.totalListeners), options) : helperMissing.call(depth0, "facepile", (depth0 && depth0.listeners), (depth0 && depth0.totalListeners), options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n";
  return buffer;
  });

},{"./media/image.hbs":164,"hbsfy/runtime":347}],162:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
var partial$0 = require('./media/image.hbs');
HandlebarsCompiler.registerPartial('./media/image.hbs', partial$0);
var partial$1 = require('./media/controllers.hbs');
HandlebarsCompiler.registerPartial('./media/controllers.hbs', partial$1);
var partial$2 = require('./media/info.hbs');
HandlebarsCompiler.registerPartial('./media/info.hbs', partial$2);
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); partials = this.merge(partials, Handlebars.partials); data = data || {};
  var buffer = "", stack1, helper, options, functionType="function", escapeExpression=this.escapeExpression, helperMissing=helpers.helperMissing, self=this, blockHelperMissing=helpers.blockHelperMissing;

function program1(depth0,data) {
  
  
  return "data-context";
  }

function program3(depth0,data) {
  
  
  return "\"mo-wide-image-wrapper\"";
  }

function program5(depth0,data) {
  
  
  return "\"mo-image-wrapper\"";
  }

function program7(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n        <div data-drag-text=\"";
  if (helper = helpers.title) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.title); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-log-click=\"media-image\" draggable=\"true\">\n      ";
  return buffer;
  }

function program9(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n        <a data-drag-text=\"";
  if (helper = helpers.title) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.title); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" href=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-log-click=\"media-image\">\n      ";
  return buffer;
  }

function program11(depth0,data) {
  
  
  return "\n        </div>\n      ";
  }

function program13(depth0,data) {
  
  
  return "\n        </a>\n      ";
  }

  buffer += "<div class=\"media-object media-object-"
    + escapeExpression((helper = helpers.type || (depth0 && depth0.type),options={hash:{},data:data},helper ? helper.call(depth0, (depth0 && depth0.uri), options) : helperMissing.call(depth0, "type", (depth0 && depth0.uri), options)))
    + " ";
  if (helper = helpers.modifiers) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.modifiers); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"\n  ";
  options={hash:{},inverse:self.program(1, program1, data),fn:self.noop,data:data}
  if (helper = helpers.noContext) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.noContext); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.noContext) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.program(1, program1, data),fn:self.noop,data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"\n  data-log-context=\"media-object\" data-log-data='{ \"name\": \"";
  if (helper = helpers.name) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.name); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\", \"target_uri\": \"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" }' data-contextmenu>\n  <div class=\"mo-wrapper\">\n    <div class=";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.wideImage), {hash:{},inverse:self.program(5, program5, data),fn:self.program(3, program3, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += ">\n      ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.noLink), {hash:{},inverse:self.program(9, program9, data),fn:self.program(7, program7, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n      ";
  stack1 = self.invokePartial(partials['./media/image.hbs'], './media/image.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      <div class=\"mo-overlay\"></div>\n\n      ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.noLink), {hash:{},inverse:self.program(13, program13, data),fn:self.program(11, program11, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n      ";
  stack1 = self.invokePartial(partials['./media/controllers.hbs'], './media/controllers.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    </div>\n    ";
  stack1 = self.invokePartial(partials['./media/info.hbs'], './media/info.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  </div>\n</div>\n";
  return buffer;
  });

},{"./media/controllers.hbs":163,"./media/image.hbs":164,"./media/info.hbs":165,"hbsfy/runtime":347}],163:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, options, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, self=this, functionType="function", blockHelperMissing=helpers.blockHelperMissing;

function program1(depth0,data) {
  
  var buffer = "", stack1, helper, options;
  buffer += "\n  ";
  stack1 = (helper = helpers.type || (depth0 && depth0.type),options={hash:{},inverse:self.noop,fn:self.program(2, program2, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.uri), "track", "album", options) : helperMissing.call(depth0, "type", (depth0 && depth0.uri), "track", "album", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  ";
  stack1 = (helper = helpers.type || (depth0 && depth0.type),options={hash:{},inverse:self.noop,fn:self.program(4, program4, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.uri), "playlist", "station", "artist", options) : helperMissing.call(depth0, "type", (depth0 && depth0.uri), "playlist", "station", "artist", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n";
  return buffer;
  }
function program2(depth0,data) {
  
  var buffer = "", helper, options;
  buffer += "\n    <button type=\"button\" data-button=\"add\" class=\"button button-icon-only button-add mo-add\" data-tooltip=\""
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Save", options) : helperMissing.call(depth0, "loc", "Save", options)))
    + "\" data-tooltip-add=\""
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Save", options) : helperMissing.call(depth0, "loc", "Save", options)))
    + "\" data-tooltip-remove=\""
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Remove", options) : helperMissing.call(depth0, "loc", "Remove", options)))
    + "\" data-log-click=\"add-button\"></button>\n  ";
  return buffer;
  }

function program4(depth0,data) {
  
  var buffer = "", stack1, helper, options;
  buffer += "\n    ";
  options={hash:{},inverse:self.program(5, program5, data),fn:self.noop,data:data}
  if (helper = helpers.currentUserPlaylist) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.currentUserPlaylist); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.currentUserPlaylist) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.program(5, program5, data),fn:self.noop,data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  ";
  return buffer;
  }
function program5(depth0,data) {
  
  var buffer = "", helper, options;
  buffer += "\n    <button type=\"button\" data-button=\"add\" class=\"button button-icon-only button-add mo-add\" data-tooltip=\""
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Follow", options) : helperMissing.call(depth0, "loc", "Follow", options)))
    + "\" data-tooltip-add=\""
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Follow", options) : helperMissing.call(depth0, "loc", "Follow", options)))
    + "\" data-tooltip-remove=\""
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Unfollow", options) : helperMissing.call(depth0, "loc", "Unfollow", options)))
    + "\" data-log-click=\"follow-button\"></button>\n    ";
  return buffer;
  }

function program7(depth0,data) {
  
  var buffer = "", stack1, helper, options;
  buffer += "\n    data-button=\"play\"\n    ";
  options={hash:{},inverse:self.noop,fn:self.program(8, program8, data),data:data}
  if (helper = helpers.range) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.range); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.range) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.noop,fn:self.program(8, program8, data),data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  ";
  return buffer;
  }
function program8(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "data-range=\"";
  if (helper = helpers.start) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.start); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + ",";
  if (helper = helpers.end) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.end); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"";
  return buffer;
  }

function program10(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n    ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.contextPage), {hash:{},inverse:self.program(14, program14, data),fn:self.program(11, program11, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  ";
  return buffer;
  }
function program11(depth0,data) {
  
  var buffer = "", stack1, helper, options;
  buffer += "\n      data-button=\"play\"\n      ";
  options={hash:{},inverse:self.noop,fn:self.program(12, program12, data),data:data}
  if (helper = helpers.contextPage) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.contextPage); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.contextPage) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.noop,fn:self.program(12, program12, data),data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    ";
  return buffer;
  }
function program12(depth0,data) {
  
  var buffer = "";
  buffer += "data-context-page=\""
    + escapeExpression((typeof depth0 === functionType ? depth0.apply(depth0) : depth0))
    + "\"";
  return buffer;
  }

function program14(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n      ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.trackUri), {hash:{},inverse:self.program(18, program18, data),fn:self.program(15, program15, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    ";
  return buffer;
  }
function program15(depth0,data) {
  
  var buffer = "", stack1, helper, options;
  buffer += "\n        ";
  options={hash:{},inverse:self.noop,fn:self.program(16, program16, data),data:data}
  if (helper = helpers.trackUri) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.trackUri); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.trackUri) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.noop,fn:self.program(16, program16, data),data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n        data-button=\"play\"\n      ";
  return buffer;
  }
function program16(depth0,data) {
  
  var buffer = "";
  buffer += "data-track-uri=\""
    + escapeExpression((typeof depth0 === functionType ? depth0.apply(depth0) : depth0))
    + "\"";
  return buffer;
  }

function program18(depth0,data) {
  
  
  return "\n        data-button=\"play-context\"\n      ";
  }

function program20(depth0,data) {
  
  var buffer = "", helper, options;
  buffer += "data-tooltip=\""
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "HoldToPreview", options) : helperMissing.call(depth0, "loc", "HoldToPreview", options)))
    + "\"";
  return buffer;
  }

function program22(depth0,data) {
  
  var buffer = "", helper, options;
  buffer += "\n  <button type=\"button\" data-button=\"contextmenu\" class=\"button button-icon-only button-more mo-more\" data-tooltip=\""
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "More", options) : helperMissing.call(depth0, "loc", "More", options)))
    + "\" data-log-click=\"context-menu-button\"></button>\n";
  return buffer;
  }

function program24(depth0,data) {
  
  
  return "\n<button type=\"button\" class=\"button button-icon-only mo-delete\" data-log-click=\"delete-button\"></button>\n";
  }

  stack1 = (helper = helpers.type || (depth0 && depth0.type),options={hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.uri), "playlist", "track", "album", "station", "artist", options) : helperMissing.call(depth0, "type", (depth0 && depth0.uri), "playlist", "track", "album", "station", "artist", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n<button type=\"button\" class=\"button button-play mo-play\" data-log-click=\"play-button\"\n  ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.range), {hash:{},inverse:self.program(10, program10, data),fn:self.program(7, program7, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n  ";
  options={hash:{},inverse:self.noop,fn:self.program(20, program20, data),data:data}
  if (helper = helpers.preview) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.preview); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.preview) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.noop,fn:self.program(20, program20, data),data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += ">\n</button>\n\n";
  stack1 = (helper = helpers.type || (depth0 && depth0.type),options={hash:{},inverse:self.noop,fn:self.program(22, program22, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.uri), "playlist", "track", "album", "artist", options) : helperMissing.call(depth0, "type", (depth0 && depth0.uri), "playlist", "track", "album", "artist", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n";
  options={hash:{},inverse:self.noop,fn:self.program(24, program24, data),data:data}
  if (helper = helpers.canDelete) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.canDelete); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.canDelete) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.noop,fn:self.program(24, program24, data),data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n";
  return buffer;
  });

},{"hbsfy/runtime":347}],164:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, options, functionType="function", escapeExpression=this.escapeExpression, self=this, helperMissing=helpers.helperMissing;

function program1(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n  <div class=\"mo-image-background-color\">\n    ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.imageUrl), {hash:{},inverse:self.noop,fn:self.program(2, program2, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  </div>\n";
  return buffer;
  }
function program2(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n      <div class=\"mo-image-background\" style=\"background-image: url('";
  if (helper = helpers.imageUrl) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.imageUrl); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "')\"></div>\n    ";
  return buffer;
  }

function program4(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n  <div class=\"mo-wide-image\" ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.imageUrl), {hash:{},inverse:self.noop,fn:self.program(5, program5, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += ">\n";
  return buffer;
  }
function program5(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "style=\"background-image: url('";
  if (helper = helpers.imageUrl) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.imageUrl); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "')\"";
  return buffer;
  }

function program7(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n  <div class=\"mo-image\" ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.imageUrl), {hash:{},inverse:self.noop,fn:self.program(5, program5, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += ">\n";
  return buffer;
  }

  buffer += "<svg class=\"mo-placeholder\" viewBox=\"0 0 10 10\" preserveAspectRatio=\"xMidYMid meet\">\n  <text class=\"playlist-placeholder\" x=\"5\" y=\"9.8\">&#xf135;</text>\n  <text class=\"playlist-folder-placeholder\" x=\"5\" y=\"9.8\">&#xf137;</text>\n  <text class=\"album-placeholder\" x=\"5\" y=\"9.8\">&#xf101;</text>\n  <text class=\"artist-placeholder\" x=\"5\" y=\"9.8\">&#xf103;</text>\n  <text class=\"user-placeholder\" x=\"5\" y=\"9.8\">&#xf15d;</text>\n  <text class=\"genre-placeholder\" x=\"5\" y=\"9.8\">&#xf109;</text>\n  <text class=\"collection-placeholder\" x=\"5\" y=\"9.8\">&#xf157;</text>\n  <text class=\"local-files-placeholder\" x=\"5\" y=\"9.8\">&#xf1fb;</text>\n</svg>\n\n";
  stack1 = (helper = helpers.type || (depth0 && depth0.type),options={hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.uri), "user", "artist", options) : helperMissing.call(depth0, "type", (depth0 && depth0.uri), "user", "artist", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.wideImage), {hash:{},inverse:self.program(7, program7, data),fn:self.program(4, program4, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n</div>\n<span class=\"mo-verified\">\n  <span class=\"spoticon-check-16\"></span>\n</span>\n";
  return buffer;
  });

},{"hbsfy/runtime":347}],165:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
var partial$0 = require('./../facepile-common.hbs');
HandlebarsCompiler.registerPartial('./../facepile-common.hbs', partial$0);
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); partials = this.merge(partials, Handlebars.partials); data = data || {};
  var buffer = "", stack1, helper, options, functionType="function", escapeExpression=this.escapeExpression, self=this, blockHelperMissing=helpers.blockHelperMissing;

function program1(depth0,data) {
  
  
  return "meta";
  }

function program3(depth0,data) {
  
  
  return "description";
  }

function program5(depth0,data) {
  
  
  return "socialproof";
  }

function program7(depth0,data) {
  
  
  return "subtitle";
  }

function program9(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n      <div class=\"mo-title\" title=\"";
  if (helper = helpers.name) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.name); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-log-click=\"media-title\" draggable=\"true\">\n    ";
  return buffer;
  }

function program11(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n      <a class=\"mo-title\" title=\"";
  if (helper = helpers.name) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.name); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" href=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-log-click=\"media-title\">\n    ";
  return buffer;
  }

function program13(depth0,data) {
  
  
  return "\n      </div>\n    ";
  }

function program15(depth0,data) {
  
  
  return "\n      </a>\n    ";
  }

function program17(depth0,data) {
  
  var buffer = "", stack1, helper, options;
  buffer += "\n      <div class=\"mo-subtitle text-muted one-line\">\n        ";
  options={hash:{},inverse:self.noop,fn:self.program(18, program18, data),data:data}
  if (helper = helpers.artists) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.artists); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.artists) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.noop,fn:self.program(18, program18, data),data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n        ";
  options={hash:{},inverse:self.noop,fn:self.program(20, program20, data),data:data}
  if (helper = helpers.owner) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.owner); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.owner) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.noop,fn:self.program(20, program20, data),data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      </div>\n    ";
  return buffer;
  }
function program18(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n          <a title=\"";
  if (helper = helpers.name) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.name); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" href=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-log-click=\"artist-name\">";
  if (helper = helpers.name) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.name); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</a>\n        ";
  return buffer;
  }

function program20(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n          <a title=\"";
  if (helper = helpers.name) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.name); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" href=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-log-click=\"owner-name\">";
  if (helper = helpers.name) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.name); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</a>\n        ";
  return buffer;
  }

function program22(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n      <div class=\"mo-description\">";
  if (helper = helpers.description) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.description); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</div>\n    ";
  return buffer;
  }

function program24(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n      ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.totalListeners), {hash:{},inverse:self.noop,fn:self.program(25, program25, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    ";
  return buffer;
  }
function program25(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n        ";
  stack1 = self.invokePartial(partials['./../facepile-common.hbs'], './../facepile-common.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      ";
  return buffer;
  }

function program27(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n      <div class=\"mo-meta\">";
  if (helper = helpers.meta) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.meta); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</div>\n    ";
  return buffer;
  }

  buffer += "<div class=\"mo-info ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.meta), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.description), {hash:{},inverse:self.noop,fn:self.program(3, program3, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.socialproof), {hash:{},inverse:self.noop,fn:self.program(5, program5, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  options={hash:{},inverse:self.program(7, program7, data),fn:self.noop,data:data}
  if (helper = helpers.hideSubtitle) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.hideSubtitle); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.hideSubtitle) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.program(7, program7, data),fn:self.noop,data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\" data-log-context=\"media-info\">\n  <div class=\"mo-info-wrapper\">\n    ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.noLink), {hash:{},inverse:self.program(11, program11, data),fn:self.program(9, program9, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n        <span class=\"mo-title-border\">\n          ";
  if (helper = helpers.name) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.name); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\n          <span class=\"ellipsis\">&nbsp;</span>\n        </span>\n    ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.noLink), {hash:{},inverse:self.program(15, program15, data),fn:self.program(13, program13, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n    ";
  options={hash:{},inverse:self.program(17, program17, data),fn:self.noop,data:data}
  if (helper = helpers.hideSubtitle) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.hideSubtitle); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.hideSubtitle) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.program(17, program17, data),fn:self.noop,data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n    ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.description), {hash:{},inverse:self.noop,fn:self.program(22, program22, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n    ";
  options={hash:{},inverse:self.noop,fn:self.program(24, program24, data),data:data}
  if (helper = helpers.socialproof) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.socialproof); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.socialproof) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.noop,fn:self.program(24, program24, data),data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n    ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.meta), {hash:{},inverse:self.noop,fn:self.program(27, program27, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    <div class=\"media-link-hider\"></div>\n    ";
  if (helper = helpers.customContent) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.customContent); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  </div>\n</div>\n";
  return buffer;
  });

},{"./../facepile-common.hbs":161,"hbsfy/runtime":347}],166:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
var partial$0 = require('./tracklist/row-start.hbs');
HandlebarsCompiler.registerPartial('./tracklist/row-start.hbs', partial$0);
var partial$1 = require('./tracklist/play.hbs');
HandlebarsCompiler.registerPartial('./tracklist/play.hbs', partial$1);
var partial$2 = require('./tracklist/save.hbs');
HandlebarsCompiler.registerPartial('./tracklist/save.hbs', partial$2);
var partial$3 = require('./tracklist/name.hbs');
HandlebarsCompiler.registerPartial('./tracklist/name.hbs', partial$3);
var partial$4 = require('./tracklist/artists.hbs');
HandlebarsCompiler.registerPartial('./tracklist/artists.hbs', partial$4);
var partial$5 = require('./tracklist/album.hbs');
HandlebarsCompiler.registerPartial('./tracklist/album.hbs', partial$5);
var partial$6 = require('./tracklist/local.hbs');
HandlebarsCompiler.registerPartial('./tracklist/local.hbs', partial$6);
var partial$7 = require('./tracklist/more.hbs');
HandlebarsCompiler.registerPartial('./tracklist/more.hbs', partial$7);
var partial$8 = require('./tracklist/time.hbs');
HandlebarsCompiler.registerPartial('./tracklist/time.hbs', partial$8);
var partial$9 = require('./tracklist/popularity.hbs');
HandlebarsCompiler.registerPartial('./tracklist/popularity.hbs', partial$9);
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); partials = this.merge(partials, Handlebars.partials); data = data || {};
  var buffer = "", stack1, self=this;


  stack1 = self.invokePartial(partials['./tracklist/row-start.hbs'], './tracklist/row-start.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  ";
  stack1 = self.invokePartial(partials['./tracklist/play.hbs'], './tracklist/play.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  ";
  stack1 = self.invokePartial(partials['./tracklist/save.hbs'], './tracklist/save.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  ";
  stack1 = self.invokePartial(partials['./tracklist/name.hbs'], './tracklist/name.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  ";
  stack1 = self.invokePartial(partials['./tracklist/artists.hbs'], './tracklist/artists.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  ";
  stack1 = self.invokePartial(partials['./tracklist/album.hbs'], './tracklist/album.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  ";
  stack1 = self.invokePartial(partials['./tracklist/local.hbs'], './tracklist/local.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  ";
  stack1 = self.invokePartial(partials['./tracklist/more.hbs'], './tracklist/more.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  ";
  stack1 = self.invokePartial(partials['./tracklist/time.hbs'], './tracklist/time.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  ";
  stack1 = self.invokePartial(partials['./tracklist/popularity.hbs'], './tracklist/popularity.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n</tr>\n";
  return buffer;
  });

},{"./tracklist/album.hbs":168,"./tracklist/artists.hbs":169,"./tracklist/local.hbs":180,"./tracklist/more.hbs":181,"./tracklist/name.hbs":182,"./tracklist/play.hbs":183,"./tracklist/popularity.hbs":184,"./tracklist/row-start.hbs":185,"./tracklist/save.hbs":186,"./tracklist/time.hbs":189,"hbsfy/runtime":347}],167:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
var partial$0 = require('./tracklist/table-attributes.hbs');
HandlebarsCompiler.registerPartial('./tracklist/table-attributes.hbs', partial$0);
var partial$1 = require('./tracklist/header/play.hbs');
HandlebarsCompiler.registerPartial('./tracklist/header/play.hbs', partial$1);
var partial$2 = require('./tracklist/header/save.hbs');
HandlebarsCompiler.registerPartial('./tracklist/header/save.hbs', partial$2);
var partial$3 = require('./tracklist/header/name.hbs');
HandlebarsCompiler.registerPartial('./tracklist/header/name.hbs', partial$3);
var partial$4 = require('./tracklist/header/explicit.hbs');
HandlebarsCompiler.registerPartial('./tracklist/header/explicit.hbs', partial$4);
var partial$5 = require('./tracklist/header/artists.hbs');
HandlebarsCompiler.registerPartial('./tracklist/header/artists.hbs', partial$5);
var partial$6 = require('./tracklist/header/album.hbs');
HandlebarsCompiler.registerPartial('./tracklist/header/album.hbs', partial$6);
var partial$7 = require('./tracklist/header/local.hbs');
HandlebarsCompiler.registerPartial('./tracklist/header/local.hbs', partial$7);
var partial$8 = require('./tracklist/header/more.hbs');
HandlebarsCompiler.registerPartial('./tracklist/header/more.hbs', partial$8);
var partial$9 = require('./tracklist/header/time.hbs');
HandlebarsCompiler.registerPartial('./tracklist/header/time.hbs', partial$9);
var partial$10 = require('./tracklist/header/popularity.hbs');
HandlebarsCompiler.registerPartial('./tracklist/header/popularity.hbs', partial$10);
var partial$11 = require('./tracklist/table-body-attributes.hbs');
HandlebarsCompiler.registerPartial('./tracklist/table-body-attributes.hbs', partial$11);
var partial$12 = require('./tracklist-search-row.hbs');
HandlebarsCompiler.registerPartial('./tracklist-search-row.hbs', partial$12);
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); partials = this.merge(partials, Handlebars.partials); data = data || {};
  var buffer = "", stack1, helper, options, self=this, functionType="function", escapeExpression=this.escapeExpression, helperMissing=helpers.helperMissing;

function program1(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n      ";
  stack1 = self.invokePartial(partials['./tracklist-search-row.hbs'], './tracklist-search-row.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    ";
  return buffer;
  }

  buffer += "<table class=\"tracklist-search ";
  if (helper = helpers.modifiers) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.modifiers); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" ";
  stack1 = self.invokePartial(partials['./tracklist/table-attributes.hbs'], './tracklist/table-attributes.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += ">\n  <thead class=\"tl-header\">\n    <tr>\n      ";
  stack1 = self.invokePartial(partials['./tracklist/header/play.hbs'], './tracklist/header/play.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      ";
  stack1 = self.invokePartial(partials['./tracklist/header/save.hbs'], './tracklist/header/save.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      ";
  stack1 = self.invokePartial(partials['./tracklist/header/name.hbs'], './tracklist/header/name.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      ";
  stack1 = self.invokePartial(partials['./tracklist/header/explicit.hbs'], './tracklist/header/explicit.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      ";
  stack1 = self.invokePartial(partials['./tracklist/header/artists.hbs'], './tracklist/header/artists.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      ";
  stack1 = self.invokePartial(partials['./tracklist/header/album.hbs'], './tracklist/header/album.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      ";
  stack1 = self.invokePartial(partials['./tracklist/header/local.hbs'], './tracklist/header/local.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      ";
  stack1 = self.invokePartial(partials['./tracklist/header/more.hbs'], './tracklist/header/more.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      ";
  stack1 = self.invokePartial(partials['./tracklist/header/time.hbs'], './tracklist/header/time.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      ";
  stack1 = self.invokePartial(partials['./tracklist/header/popularity.hbs'], './tracklist/header/popularity.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    </tr>\n  </thead>\n  <tbody ";
  stack1 = self.invokePartial(partials['./tracklist/table-body-attributes.hbs'], './tracklist/table-body-attributes.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += ">\n    ";
  stack1 = (helper = helpers.list || (depth0 && depth0.list),options={hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.rows), options) : helperMissing.call(depth0, "list", (depth0 && depth0.rows), options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  </tbody>\n</table>\n";
  return buffer;
  });

},{"./tracklist-search-row.hbs":166,"./tracklist/header/album.hbs":170,"./tracklist/header/artists.hbs":171,"./tracklist/header/explicit.hbs":172,"./tracklist/header/local.hbs":173,"./tracklist/header/more.hbs":174,"./tracklist/header/name.hbs":175,"./tracklist/header/play.hbs":176,"./tracklist/header/popularity.hbs":177,"./tracklist/header/save.hbs":178,"./tracklist/header/time.hbs":179,"./tracklist/table-attributes.hbs":187,"./tracklist/table-body-attributes.hbs":188,"hbsfy/runtime":347}],168:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, functionType="function", escapeExpression=this.escapeExpression, self=this, blockHelperMissing=helpers.blockHelperMissing;

function program1(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n    ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.local), {hash:{},inverse:self.program(4, program4, data),fn:self.program(2, program2, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  ";
  return buffer;
  }
function program2(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n      ";
  if (helper = helpers.name) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.name); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\n    ";
  return buffer;
  }

function program4(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n      <a title=\"";
  if (helper = helpers.name) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.name); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" href=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-log-click=\"album-name\">";
  if (helper = helpers.name) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.name); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</a>\n    ";
  return buffer;
  }

  buffer += "<td class=\"tl-cell tl-albums\" data-log-context=\"album-cell\">\n  ";
  stack1 = ((stack1 = ((stack1 = ((stack1 = (depth0 && depth0.track)),stack1 == null || stack1 === false ? stack1 : stack1.album)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1)),blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data}));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n</td>\n";
  return buffer;
  });

},{"hbsfy/runtime":347}],169:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, options, functionType="function", escapeExpression=this.escapeExpression, self=this, helperMissing=helpers.helperMissing;

function program1(depth0,data) {
  
  var stack1;
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.local), {hash:{},inverse:self.program(4, program4, data),fn:self.program(2, program2, data),data:data});
  if(stack1 || stack1 === 0) { return stack1; }
  else { return ''; }
  }
function program2(depth0,data) {
  
  var stack1, helper;
  if (helper = helpers.name) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.name); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  return escapeExpression(stack1);
  }

function program4(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "<a title=\"";
  if (helper = helpers.name) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.name); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" href=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-log-click=\"artist-name\">";
  if (helper = helpers.name) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.name); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</a>";
  return buffer;
  }

  buffer += "<td class=\"tl-cell tl-artists\" data-log-context=\"artist-cell\">\n  ";
  stack1 = (helper = helpers.slice || (depth0 && depth0.slice),options={hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data},helper ? helper.call(depth0, ((stack1 = (depth0 && depth0.track)),stack1 == null || stack1 === false ? stack1 : stack1.artists), ", ", options) : helperMissing.call(depth0, "slice", ((stack1 = (depth0 && depth0.track)),stack1 == null || stack1 === false ? stack1 : stack1.artists), ", ", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n</td>\n";
  return buffer;
  });

},{"hbsfy/runtime":347}],170:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, options, self=this, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;

function program1(depth0,data) {
  
  var buffer = "", stack1, helper, options;
  buffer += "\n  tl-sort-\n  ";
  stack1 = (helper = helpers.compare || (depth0 && depth0.compare),options={hash:{},inverse:self.program(4, program4, data),fn:self.program(2, program2, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.sortDirection), "asc", options) : helperMissing.call(depth0, "compare", (depth0 && depth0.sortDirection), "asc", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n";
  return buffer;
  }
function program2(depth0,data) {
  
  
  return "\n    asc\n  ";
  }

function program4(depth0,data) {
  
  
  return "\n    desc\n  ";
  }

function program6(depth0,data) {
  
  
  return "data-sort=\"track(album(name),disc,number)\"";
  }

  buffer += "<th class=\"tl-albums\n";
  stack1 = (helper = helpers.compare || (depth0 && depth0.compare),options={hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data},helper ? helper.call(depth0, "track(album(name),disc,number)", (depth0 && depth0.sortQuery), options) : helperMissing.call(depth0, "compare", "track(album(name),disc,number)", (depth0 && depth0.sortQuery), options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\" ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.sortable), {hash:{},inverse:self.noop,fn:self.program(6, program6, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += ">"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Album", options) : helperMissing.call(depth0, "loc", "Album", options)))
    + "</th>\n";
  return buffer;
  });

},{"hbsfy/runtime":347}],171:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, options, self=this, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;

function program1(depth0,data) {
  
  var buffer = "", stack1, helper, options;
  buffer += "\n  tl-sort-\n  ";
  stack1 = (helper = helpers.compare || (depth0 && depth0.compare),options={hash:{},inverse:self.program(4, program4, data),fn:self.program(2, program2, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.sortDirection), "asc", options) : helperMissing.call(depth0, "compare", (depth0 && depth0.sortDirection), "asc", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n";
  return buffer;
  }
function program2(depth0,data) {
  
  
  return "\n    asc\n  ";
  }

function program4(depth0,data) {
  
  
  return "\n    desc\n  ";
  }

function program6(depth0,data) {
  
  
  return "data-sort=\"track(artists[0:1](name),album(name),disc,number)\"";
  }

  buffer += "<th class=\"tl-artists\n";
  stack1 = (helper = helpers.compare || (depth0 && depth0.compare),options={hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data},helper ? helper.call(depth0, "track(artists[0:1](name),album(name),disc,number)", (depth0 && depth0.sortQuery), options) : helperMissing.call(depth0, "compare", "track(artists[0:1](name),album(name),disc,number)", (depth0 && depth0.sortQuery), options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\" ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.sortable), {hash:{},inverse:self.noop,fn:self.program(6, program6, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += ">"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Artist", options) : helperMissing.call(depth0, "loc", "Artist", options)))
    + "</th>\n";
  return buffer;
  });

},{"hbsfy/runtime":347}],172:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, self=this;

function program1(depth0,data) {
  
  
  return "data-sort-previous";
  }

  buffer += "<th class=\"tl-explicit\" ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.sortable), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "></th>\n";
  return buffer;
  });

},{"hbsfy/runtime":347}],173:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, self=this;

function program1(depth0,data) {
  
  
  return "data-sort-previous";
  }

  buffer += "<th class=\"tl-local\" ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.sortable), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "></th>";
  return buffer;
  });

},{"hbsfy/runtime":347}],174:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, self=this;

function program1(depth0,data) {
  
  
  return "data-sort-previous";
  }

  buffer += "<th class=\"tl-more\" ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.sortable), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "></th>\r";
  return buffer;
  });

},{"hbsfy/runtime":347}],175:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, options, self=this, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;

function program1(depth0,data) {
  
  var buffer = "", stack1, helper, options;
  buffer += "\n  tl-sort-\n  ";
  stack1 = (helper = helpers.compare || (depth0 && depth0.compare),options={hash:{},inverse:self.program(4, program4, data),fn:self.program(2, program2, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.sortDirection), "asc", options) : helperMissing.call(depth0, "compare", (depth0 && depth0.sortDirection), "asc", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n";
  return buffer;
  }
function program2(depth0,data) {
  
  
  return "\n    asc\n  ";
  }

function program4(depth0,data) {
  
  
  return "\n    desc\n  ";
  }

function program6(depth0,data) {
  
  
  return "data-sort=\"track(name)\"";
  }

  buffer += "<th class=\"tl-name\n";
  stack1 = (helper = helpers.compare || (depth0 && depth0.compare),options={hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data},helper ? helper.call(depth0, "track(name)", (depth0 && depth0.sortQuery), options) : helperMissing.call(depth0, "compare", "track(name)", (depth0 && depth0.sortQuery), options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\" ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.sortable), {hash:{},inverse:self.noop,fn:self.program(6, program6, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += ">"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Song", options) : helperMissing.call(depth0, "loc", "Song", options)))
    + "</th>\n";
  return buffer;
  });

},{"hbsfy/runtime":347}],176:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  


  return "<th class=\"tl-play\"></th>\n";
  });

},{"hbsfy/runtime":347}],177:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  


  return "<th class=\"tl-popularity\"></th>\n";
  });

},{"hbsfy/runtime":347}],178:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  


  return "<th class=\"tl-save\"></th>\n";
  });

},{"hbsfy/runtime":347}],179:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, options, self=this, helperMissing=helpers.helperMissing;

function program1(depth0,data) {
  
  var buffer = "", stack1, helper, options;
  buffer += "\n  tl-sort-\n  ";
  stack1 = (helper = helpers.compare || (depth0 && depth0.compare),options={hash:{},inverse:self.program(4, program4, data),fn:self.program(2, program2, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.sortDirection), "asc", options) : helperMissing.call(depth0, "compare", (depth0 && depth0.sortDirection), "asc", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n";
  return buffer;
  }
function program2(depth0,data) {
  
  
  return "\n    asc\n  ";
  }

function program4(depth0,data) {
  
  
  return "\n    desc\n  ";
  }

function program6(depth0,data) {
  
  
  return "data-sort=\"track(duration)\"";
  }

  buffer += "<th class=\"tl-time\n";
  stack1 = (helper = helpers.compare || (depth0 && depth0.compare),options={hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data},helper ? helper.call(depth0, "track(duration)", (depth0 && depth0.sortQuery), options) : helperMissing.call(depth0, "compare", "track(duration)", (depth0 && depth0.sortQuery), options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\" ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.sortable), {hash:{},inverse:self.noop,fn:self.program(6, program6, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "></th>\n";
  return buffer;
  });

},{"hbsfy/runtime":347}],180:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {
  
  var buffer = "", helper, options;
  buffer += "\n  <span class=\"tl-item-local spoticon-localfile-16\" data-tooltip=\""
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "LocalFile", options) : helperMissing.call(depth0, "loc", "LocalFile", options)))
    + "\"></span>\n  ";
  return buffer;
  }

  buffer += "<td class=\"tl-cell tl-local\">\n  ";
  stack1 = helpers['if'].call(depth0, ((stack1 = (depth0 && depth0.track)),stack1 == null || stack1 === false ? stack1 : stack1.local), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n</td>\n";
  return buffer;
  });

},{"hbsfy/runtime":347}],181:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, options, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, functionType="function";


  buffer += "<td class=\"tl-cell tl-more\">\n  <button\n    type=\"button\"\n    data-button=\"contextmenu\"\n    class=\"button button-icon-only button-more\"\n    data-tooltip=\""
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "More", options) : helperMissing.call(depth0, "loc", "More", options)))
    + "\"\n    data-log-click=\"more-button\"\n    data-log-data='{ \"index\": "
    + escapeExpression(((stack1 = (data == null || data === false ? data : data.index)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + ", \"target_uri\": \"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" }'></button>\n</td>\n";
  return buffer;
  });

},{"hbsfy/runtime":347}],182:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, options, self=this, functionType="function", blockHelperMissing=helpers.blockHelperMissing, escapeExpression=this.escapeExpression;

function program1(depth0,data) {
  
  
  return "\n  <td class=\"tl-cell tl-name\" data-log-context=\"name-cell\">\n";
  }

function program3(depth0,data) {
  
  
  return "\n  <td class=\"tl-cell tl-name\" colspan=\"2\" data-log-context=\"name-cell\">\n";
  }

function program5(depth0,data) {
  
  
  return "tl-item-new";
  }

function program7(depth0,data) {
  
  
  return "</td><td class=\"tl-cell tl-explicit\"><span class=\"label\" data-log-click=\"explicit\">EXPLICIT</span>";
  }

  stack1 = helpers['if'].call(depth0, ((stack1 = (depth0 && depth0.track)),stack1 == null || stack1 === false ? stack1 : stack1.explicit), {hash:{},inverse:self.program(3, program3, data),fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n<div class=\"tl-highlight ";
  options={hash:{},inverse:self.noop,fn:self.program(5, program5, data),data:data}
  if (helper = helpers['new']) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0['new']); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers['new']) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.noop,fn:self.program(5, program5, data),data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\" data-log-click=\"name\">\n  "
    + escapeExpression(((stack1 = ((stack1 = (depth0 && depth0.track)),stack1 == null || stack1 === false ? stack1 : stack1.name)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\n</div>\n";
  stack1 = ((stack1 = ((stack1 = ((stack1 = (depth0 && depth0.track)),stack1 == null || stack1 === false ? stack1 : stack1.explicit)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1)),blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.noop,fn:self.program(7, program7, data),data:data}));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n</td>\n";
  return buffer;
  });

},{"hbsfy/runtime":347}],183:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  


  return "<td class=\"tl-cell tl-play\">\n  <button\n    type=\"button\"\n    data-button=\"play\"\n    class=\"button button-icon-with-stroke button-play\"\n    data-log-click=\"play-button\"></button>\n</td>\n";
  });

},{"hbsfy/runtime":347}],184:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, self=this, functionType="function";

function program1(depth0,data) {
  
  var buffer = "", stack1, helper, options;
  buffer += " data-tooltip=\""
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "ListenCount", ((stack1 = (depth0 && depth0.track)),stack1 == null || stack1 === false ? stack1 : stack1.listenCount), options) : helperMissing.call(depth0, "loc", "ListenCount", ((stack1 = (depth0 && depth0.track)),stack1 == null || stack1 === false ? stack1 : stack1.listenCount), options)))
    + "\" data-tooltip-instant";
  return buffer;
  }

  buffer += "<td class=\"tl-cell tl-popularity\"";
  stack1 = helpers['if'].call(depth0, ((stack1 = (depth0 && depth0.track)),stack1 == null || stack1 === false ? stack1 : stack1.listenCount), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += ">\n  <div class=\"pop-meter\">\n    <div class=\"pop-meter-background\"></div>\n    <div class=\"pop-meter-overlay\" style=\"width: "
    + escapeExpression(((stack1 = ((stack1 = (depth0 && depth0.track)),stack1 == null || stack1 === false ? stack1 : stack1.popularity)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "%\"></div>\n  </div>\n</td>\n";
  return buffer;
  });

},{"hbsfy/runtime":347}],185:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, options, functionType="function", escapeExpression=this.escapeExpression, self=this, helperMissing=helpers.helperMissing;

function program1(depth0,data) {
  
  var stack1, helper;
  if (helper = helpers.name) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.name); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  return escapeExpression(stack1);
  }

function program3(depth0,data) {
  
  var stack1, helper;
  if (helper = helpers.index) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.index); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  return escapeExpression(stack1);
  }

function program5(depth0,data) {
  
  var stack1;
  return escapeExpression(((stack1 = (data == null || data === false ? data : data.index)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1));
  }

function program7(depth0,data) {
  
  var stack1, helper;
  if (helper = helpers.contextIndex) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.contextIndex); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  return escapeExpression(stack1);
  }

function program9(depth0,data) {
  
  var stack1;
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.index), {hash:{},inverse:self.program(5, program5, data),fn:self.program(3, program3, data),data:data});
  if(stack1 || stack1 === 0) { return stack1; }
  else { return ''; }
  }

function program11(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "data-uid=\"";
  if (helper = helpers.uid) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uid); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"";
  return buffer;
  }

function program13(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n        ";
  stack1 = helpers['if'].call(depth0, ((stack1 = (depth0 && depth0.track)),stack1 == null || stack1 === false ? stack1 : stack1.offlineProgress), {hash:{},inverse:self.program(19, program19, data),fn:self.program(14, program14, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      ";
  return buffer;
  }
function program14(depth0,data) {
  
  var buffer = "", stack1, helper, options;
  buffer += "\n          ";
  stack1 = (helper = helpers.compare || (depth0 && depth0.compare),options={hash:{},inverse:self.program(17, program17, data),fn:self.program(15, program15, data),data:data},helper ? helper.call(depth0, ((stack1 = (depth0 && depth0.track)),stack1 == null || stack1 === false ? stack1 : stack1.offlineProgress), 1, options) : helperMissing.call(depth0, "compare", ((stack1 = (depth0 && depth0.track)),stack1 == null || stack1 === false ? stack1 : stack1.offlineProgress), 1, options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n        ";
  return buffer;
  }
function program15(depth0,data) {
  
  
  return "\n            offline-downloaded\n          ";
  }

function program17(depth0,data) {
  
  
  return "\n            offline-downloading\n          ";
  }

function program19(depth0,data) {
  
  
  return "\n          offline-waiting\n        ";
  }

function program21(depth0,data) {
  
  
  return "playing";
  }

function program23(depth0,data) {
  
  
  return "selected";
  }

function program25(depth0,data) {
  
  
  return "added";
  }

function program27(depth0,data) {
  
  
  return "unavailable";
  }

function program29(depth0,data) {
  
  
  return "local";
  }

function program31(depth0,data) {
  
  
  return "local-file-available";
  }

function program33(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "thumbs-";
  if (helper = helpers.thumb) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.thumb); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1);
  return buffer;
  }

function program35(depth0,data) {
  
  
  return "thumbs-none";
  }

  buffer += "<tr tabindex=\"0\"\n    aria-label=\""
    + escapeExpression(((stack1 = ((stack1 = (depth0 && depth0.track)),stack1 == null || stack1 === false ? stack1 : stack1.name)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + " "
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "By", options) : helperMissing.call(depth0, "loc", "By", options)))
    + " ";
  stack1 = (helper = helpers.slice || (depth0 && depth0.slice),options={hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data},helper ? helper.call(depth0, ((stack1 = (depth0 && depth0.track)),stack1 == null || stack1 === false ? stack1 : stack1.artists), ", ", options) : helperMissing.call(depth0, "slice", ((stack1 = (depth0 && depth0.track)),stack1 == null || stack1 === false ? stack1 : stack1.artists), ", ", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += ". "
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "PressEnterToPlay", options) : helperMissing.call(depth0, "loc", "PressEnterToPlay", options)))
    + ".\"\n    data-list-item=\"true\" data-uri=\""
    + escapeExpression(((stack1 = ((stack1 = (depth0 && depth0.track)),stack1 == null || stack1 === false ? stack1 : stack1.uri)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\"\n    data-index=\"";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.index), {hash:{},inverse:self.program(5, program5, data),fn:self.program(3, program3, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\"\n    data-context-index=\"";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.contextIndex), {hash:{},inverse:self.program(9, program9, data),fn:self.program(7, program7, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\"\n    ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.uid), {hash:{},inverse:self.noop,fn:self.program(11, program11, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    data-scroll-page-item=\"";
  if (helper = helpers.scrollPageItem) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.scrollPageItem); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" draggable=\"true\"\n    data-log-data='{\n      \"index\": ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.index), {hash:{},inverse:self.program(5, program5, data),fn:self.program(3, program3, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += ",\n      \"target_uri\": \""
    + escapeExpression(((stack1 = ((stack1 = (depth0 && depth0.track)),stack1 == null || stack1 === false ? stack1 : stack1.uri)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\",\n      \"name\": \""
    + escapeExpression(((stack1 = ((stack1 = (depth0 && depth0.track)),stack1 == null || stack1 === false ? stack1 : stack1.name)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\"\n    }'\n    class=\"tl-row\n      ";
  stack1 = helpers['if'].call(depth0, ((stack1 = (depth0 && depth0.track)),stack1 == null || stack1 === false ? stack1 : stack1.shouldBeOffline), {hash:{},inverse:self.noop,fn:self.program(13, program13, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      ";
  stack1 = helpers['if'].call(depth0, ((stack1 = (depth0 && depth0.track)),stack1 == null || stack1 === false ? stack1 : stack1.playing), {hash:{},inverse:self.noop,fn:self.program(21, program21, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      ";
  stack1 = helpers['if'].call(depth0, ((stack1 = (depth0 && depth0.track)),stack1 == null || stack1 === false ? stack1 : stack1.selected), {hash:{},inverse:self.noop,fn:self.program(23, program23, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      ";
  stack1 = helpers['if'].call(depth0, ((stack1 = (depth0 && depth0.track)),stack1 == null || stack1 === false ? stack1 : stack1.added), {hash:{},inverse:self.noop,fn:self.program(25, program25, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      ";
  stack1 = helpers['if'].call(depth0, ((stack1 = (depth0 && depth0.track)),stack1 == null || stack1 === false ? stack1 : stack1.unavailable), {hash:{},inverse:self.noop,fn:self.program(27, program27, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      ";
  stack1 = helpers['if'].call(depth0, ((stack1 = (depth0 && depth0.track)),stack1 == null || stack1 === false ? stack1 : stack1.local), {hash:{},inverse:self.noop,fn:self.program(29, program29, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      ";
  stack1 = helpers['if'].call(depth0, ((stack1 = (depth0 && depth0.track)),stack1 == null || stack1 === false ? stack1 : stack1.localFileAvailable), {hash:{},inverse:self.noop,fn:self.program(31, program31, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.thumb), {hash:{},inverse:self.program(35, program35, data),fn:self.program(33, program33, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    \"\n    data-contextmenu>\n";
  return buffer;
  });

},{"hbsfy/runtime":347}],186:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", helper, options, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;


  buffer += "<td class=\"tl-cell tl-save\">\n  <button type=\"button\" data-button=\"add\"\n    class=\"button button-icon-only button-add\"\n    data-tooltip=\""
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "SaveYourMusic", options) : helperMissing.call(depth0, "loc", "SaveYourMusic", options)))
    + "\"\n    data-tooltip-add=\""
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "SaveYourMusic", options) : helperMissing.call(depth0, "loc", "SaveYourMusic", options)))
    + "\"\n    data-tooltip-remove=\""
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "RemoveYourMusic", options) : helperMissing.call(depth0, "loc", "RemoveYourMusic", options)))
    + "\"\n    data-log-click=\"save-button\"></button>\n</td>\n";
  return buffer;
  });

},{"hbsfy/runtime":347}],187:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, options, functionType="function", escapeExpression=this.escapeExpression, self=this, blockHelperMissing=helpers.blockHelperMissing;

function program1(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\ndata-insert=\"";
  if (helper = helpers.insertTracks) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.insertTracks); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"\ndata-remove=\"";
  if (helper = helpers.removeTracks) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.removeTracks); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"\n";
  return buffer;
  }

function program3(depth0,data) {
  
  
  return "\ndata-context=\"true\"\n";
  }

function program5(depth0,data) {
  
  
  return "\ndata-list-quick-jump=\"true\"\n";
  }

  buffer += "data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"\ndata-list=\"true\"\n";
  options={hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data}
  if (helper = helpers.allows) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.allows); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.allows) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n";
  options={hash:{},inverse:self.program(3, program3, data),fn:self.noop,data:data}
  if (helper = helpers.noContext) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.noContext); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.noContext) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.program(3, program3, data),fn:self.noop,data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.quickJump), {hash:{},inverse:self.noop,fn:self.program(5, program5, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n";
  return buffer;
  });

},{"hbsfy/runtime":347}],188:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  


  return "data-list-items=\"true\"\ndata-scroll-container\n";
  });

},{"hbsfy/runtime":347}],189:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, options, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;


  buffer += "<td class=\"tl-cell tl-time\" data-log-context=\"time-cell\">\n  <span data-log-click=\"duration\">"
    + escapeExpression((helper = helpers.duration || (depth0 && depth0.duration),options={hash:{},data:data},helper ? helper.call(depth0, ((stack1 = (depth0 && depth0.track)),stack1 == null || stack1 === false ? stack1 : stack1.duration), options) : helperMissing.call(depth0, "duration", ((stack1 = (depth0 && depth0.track)),stack1 == null || stack1 === false ? stack1 : stack1.duration), options)))
    + "</span>\n</td>\n";
  return buffer;
  });

},{"hbsfy/runtime":347}],190:[function(require,module,exports){
'use strict';

// Usage
// Data {{#compare 'myvalue' value}}has{{else}}doesn't have{{/compare}} myvalue.
// Data {{#compare '5' tracks.length true}}has{{else}}doesn't have{{/compare}} 5 tracks.
// Data {{#compare tracks.length 5 operator='>'}}has more than{{else}}has less than or equal to{{/compare}} 5 tracks.

var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var operators = {
  '==': function _(a, b) {
    /* eslint eqeqeq: 0 */return a == b;
  },
  '===': function _(a, b) {
    return a === b;
  },
  '!=': function _(a, b) {
    /* eslint eqeqeq: 0 */return a != b;
  },
  '<': function _(a, b) {
    return a < b;
  },
  '>': function _(a, b) {
    return a > b;
  },
  '<=': function _(a, b) {
    return a <= b;
  },
  '>=': function _(a, b) {
    return a >= b;
  },
  'typeof': function _typeof(a, b) {
    return (typeof a === 'undefined' ? 'undefined' : _typeof2(a)) == b;
  }
};

function compare(a, b, s) {
  var options = arguments[arguments.length - 1];
  var soft = s !== options ? s : false;
  var operator = soft ? '==' : options.hash.operator || '===';

  var match = operators[operator](a, b);

  return match ? options.fn(this) : options.inverse(this);
}

compare.displayName = 'compare';

module.exports = compare;

},{}],191:[function(require,module,exports){
'use strict';

var duration = function duration(ms) {
  if (isNaN(ms)) return ms;

  var s = Math.round(ms / 1000);
  var oneMinute = 60;
  var oneHour = 60 * oneMinute;

  var hours = Math.floor(s / oneHour);
  var minutes = Math.floor(s % oneHour / oneMinute);
  var seconds = Math.round(s % oneHour % oneMinute);

  // Include hours if needed
  if (hours) {
    hours += ':';

    // If hours are specified, minutes should always be with two digits
    if (minutes < 10) minutes = '0' + minutes;
  } else {
    hours = '';
  }

  // Since minutes should always be displayed, seconds should always be with two digits
  if (seconds < 10) seconds = '0' + seconds;

  return hours + minutes + ':' + seconds;
};

duration.displayName = 'duration';

module.exports = duration;

},{}],192:[function(require,module,exports){
'use strict';

var nameListTooltip = require('./name-list-tooltip');

var facepile = function facepile(list, totalCount, mT, opts) {
  var options = opts;
  var minThresh = mT;

  if (!list) {
    return '';
  }

  if (arguments.length < 4) {
    options = minThresh;
    minThresh = 3;
  }

  minThresh = minThresh || 3;

  var len = list.length;
  var thresh = Math.min(minThresh, len);
  var ret = '';

  // Display faces.
  for (var i = 0; i < thresh; i++) {
    var obj = list[i];
    obj.modifiers = 'media-object-link media-object-simple';
    ret += options.fn(obj);
  }

  // Display badge count for hidden listeners.
  if (totalCount > thresh) {
    ret += options.inverse({
      badgeCount: totalCount - thresh,
      badgeTooltip: nameListTooltip(list.slice(thresh), totalCount - thresh)
    });
  }
  return ret;
};

facepile.displayName = 'facepile';

module.exports = facepile;

},{"./name-list-tooltip":198}],193:[function(require,module,exports){
(function (global){
'use strict';

var getHTTPLink = require('../util/link');

var isDesktop = !!global._getSpotifyModule;

var href = function href(uri) {
  if (isDesktop) return uri;
  return getHTTPLink(uri, 'https://play.spotify.com');
};

href.displayName = 'href';

module.exports = href;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../util/link":205}],194:[function(require,module,exports){
'use strict';

var loc = require('./loc');

var humanizeDuration = function humanizeDuration(ms) {
  if (isNaN(ms)) return ms;

  var s = Math.round(ms / 1000);
  var oneMinute = 60;
  var oneHour = 60 * oneMinute;

  var hours = Math.floor(s / oneHour);
  var minutes = Math.floor(s % oneHour / oneMinute);
  var seconds = Math.round(s % oneHour % oneMinute);

  var formattedDuration = '';

  if (hours) {
    formattedDuration += loc('HoursShort', hours, {});
  }

  if (minutes) {
    formattedDuration += ' ';
    formattedDuration += loc('MinutesShort', minutes, {});
  }

  if (!hours && !minutes || hours === 0 && minutes < 10) {
    formattedDuration += ' ';
    formattedDuration += loc('SecondsShort', seconds, {});
  }

  return formattedDuration.trim();
};

humanizeDuration.displayName = 'humanizeDuration';

module.exports = humanizeDuration;

},{"./loc":197}],195:[function(require,module,exports){
'use strict';

exports.compare = require('./compare');
exports.duration = require('./duration');
exports.facepile = require('./facepile');
exports.href = require('./href');
exports.humanizeDuration = require('./humanize-duration');
exports.list = require('./list');
exports.loc = require('./loc');
exports.nameListTooltip = require('./name-list-tooltip');
exports.numeral = require('./numeral');
exports.share = require('./share');
exports.slice = require('./slice');
exports.type = require('./type');
exports.userReaction = require('./user-reaction');

},{"./compare":190,"./duration":191,"./facepile":192,"./href":193,"./humanize-duration":194,"./list":196,"./loc":197,"./name-list-tooltip":198,"./numeral":199,"./share":200,"./slice":201,"./type":202,"./user-reaction":203}],196:[function(require,module,exports){
'use strict';

var map = require('mout/array/map');

var Handlebars = require('handlebars/dist/cjs/handlebars.runtime').default;

var lists = {};

var list = function list(array) {
  if (!array) {
    return '';
  }

  var args = Array.prototype.slice.call(arguments);
  var options = args.pop();
  var listID = args[1];

  if (array === 'reset') {
    delete lists[listID];
    return '';
  }

  if (listID && lists[listID] === undefined) {
    lists[listID] = -1;
  }

  return map(array, function (item, i) {
    var data = Handlebars.createFrame(options.data || {});
    data.index = listID ? ++lists[listID] : i;
    data.number = data.index + 1;
    data.localIndex = i;
    data.localNumber = i + 1;
    return options.fn(item, { data: data });
  }).join(options.hash && options.hash.join || '');
};

list.displayName = 'list';

module.exports = list;

},{"handlebars/dist/cjs/handlebars.runtime":340,"mout/array/map":359}],197:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var mixIn = require('mout/object/mixIn');
var slice_ = Array.prototype.slice;

var storage = {};

var loc = function loc(key) {
  var value = storage[key];

  if (!value) return '';

  var args = slice_.call(arguments, 1);
  var options = {};

  if (_typeof(args[args.length - 1]) === 'object') {
    options = args.pop();
  }

  var hash = options.hash;

  return value.replace(/\{([\w-]+)\}/g, function (full, match) {
    var n = +match;
    var interpolated;

    if (isNaN(n)) {
      interpolated = hash[match];
    } else {
      interpolated = args[n];
    }

    return interpolated !== null ? interpolated : '';
  });
};

loc.displayName = 'loc';

loc.register = function (object) {
  mixIn(storage, object);
  return this;
};

module.exports = loc;

},{"mout/object/mixIn":393}],198:[function(require,module,exports){
'use strict';

var loc = require('./loc');

var nameListTooltip = function nameListTooltip(users, totalCount) {
  if (totalCount === 0) {
    return undefined;
  }

  var len = users.length;
  var textTokens = users.map(function (user) {
    return user.name;
  });

  if (totalCount - len > 0) {
    var andMoreText = loc('AndMore', totalCount - len);
    textTokens.push(andMoreText);
  }

  return textTokens.join('<br>\n').replace(/'/g, '&#39;');
};

nameListTooltip.displayName = 'nameListTooltip';

module.exports = nameListTooltip;

},{"./loc":197}],199:[function(require,module,exports){
'use strict';

var isNumber = require('mout/lang/isNumber');

/**
 * If the first argument is a number, pipe it through spotify-numeral with an
 * optional format propety in the options hash, otherwise return it untouched.
 *
 * Example usage – results when using fr locale:
 *
 * {{numeral 1000}} -> '1 000'
 * {{numeral 1000 format='0,0.000'}} -> '1 000,000'
 * {{numeral 1000 format='$0,0.00'}} -> '€1 000,00'
 *
 * @param {Number|String} number - The number to format (or string to leave
 *     untouched).
 * @param {Object} [options] - The handlebars options object.
 * @param {Object} [options.hash] - The handlebars options hash object.
 * @param {String} [options.hash.format] - The optional format to pass to
 *     numeraljs.
 * @return {String} The formatted (or untouched) string.
 */
var numeralHelper = function numeralHelper(number, options) {
  var format = options && options.hash && options.hash.format;
  var numeral = numeralHelper._numeral;
  return isNumber(number) ? numeral(number).format(format) : number;
};

numeralHelper.displayName = 'numeral';

module.exports = numeralHelper;

// This is tricky, but is a way to allow for the locale to be injected
// from the consuming app instead of from within spotify-numeral, removing
// the dependency on spotify-quickstart.
module.exports.setLocale = function (locale) {
  numeralHelper._numeral = require('../../spotify-numeral')(locale);
};

},{"../../spotify-numeral":272,"mout/lang/isNumber":377}],200:[function(require,module,exports){
'use strict';

var getHTTPLink = require('../util/link');

var share = function share(uri) {
  return getHTTPLink(uri, 'https://open.spotify.com');
};

share.displayName = 'share';

module.exports = share;

},{"../util/link":205}],201:[function(require,module,exports){
'use strict';

var kindOf = require('mout/lang/kindOf');
var map = require('mout/array/map');
var forEach = require('mout/array/forEach');

var Handlebars = require('handlebars/dist/cjs/handlebars.runtime').default;
var slice_ = Array.prototype.slice;

var slice = function slice(arr) {
  var array = arr;

  if (!array) {
    return '';
  }

  var sep;
  var begin;
  var end;
  var options;

  forEach(slice_.call(arguments, 1), function (arg) {
    switch (kindOf(arg)) {
      case 'String':
        sep = arg;
        break;

      case 'Number':
        if (begin === null) {
          begin = arg;
        } else if (end === null) {
          end = arg;
        }
        break;

      case 'Object':
        options = arg;
        break;

      default:
      // Do nothing.
    }
  });

  if (begin !== null) {
    array = array.slice(begin, end !== null ? end : array.length);
  }

  return map(array, function (item) {
    var data = Handlebars.createFrame(options.data || {});

    return options.fn(item, { data: data });
  }).join(sep || '');
};

slice.displayName = 'slice';

module.exports = slice;

},{"handlebars/dist/cjs/handlebars.runtime":340,"mout/array/forEach":356,"mout/array/map":359,"mout/lang/kindOf":381}],202:[function(require,module,exports){
'use strict';

var getType = require('../util/type');

// This needs at least the uri param to get the type:
// {{type uri}}
//
// If you pass more parameters you can use it like a matcher:
// {{#type uri "track" "album"}}YAY{{/type}}
// This will print 'YAY' for tracks or albums.

var type = function type(uri) {
  if (arguments.length <= 2) {
    // Simple get type.
    return getType(uri);
  }

  // Match type.
  var context = arguments[arguments.length - 1];
  var success = false;
  var uriType = getType(uri);

  for (var i = 1; i < arguments.length - 1; i++) {
    if (uriType === arguments[i]) {
      success = true;
      break;
    }
  }

  return success ? context.fn(this) : context.inverse(this);
};

type.displayName = 'type';

module.exports = type;

},{"../util/type":206}],203:[function(require,module,exports){
'use strict';

var loc = require('./loc');

var userReaction = function userReaction(users, totalCount, reactionType) {
  if (!totalCount) return '';
  var key = reactionType + 'Reaction' + (totalCount > 1 ? 'Multi' : 'Single');

  if (totalCount > 1) {
    return loc(key, totalCount);
  }

  if (!users.length) {
    return '';
  }

  var firstListener = users[0].name;
  return loc(key, firstListener);
};

userReaction.displayName = 'userReaction';

module.exports = userReaction;

},{"./loc":197}],204:[function(require,module,exports){
'use strict';

var kindOf = require('mout/lang/kindOf');

var Handlebars = require('handlebars/dist/cjs/handlebars.runtime').default;

// Expose the runtime to make partials easier to register.
exports.runtime = Handlebars;

exports.register = function (helpers) {
  var list = {};

  if (kindOf(helpers) === 'Function') {
    list[helpers.displayName] = helpers;
  } else {
    list = helpers;
  }

  for (var key in list) {
    if (list.hasOwnProperty(key)) {
      Handlebars.registerHelper(key, list[key]);
    }
  }

  return this;
};

},{"handlebars/dist/cjs/handlebars.runtime":340,"mout/lang/kindOf":381}],205:[function(require,module,exports){
'use strict';

module.exports = function (uri, base) {
  var matches = (uri || '').match(/^spotify:(.+)$/);

  if (!matches) {
    return uri || '';
  }

  var parts = matches.pop().replace(/:$/, '').split(/:/);
  var type = parts.shift();

  if (type === 'search') {
    parts = [parts.join(':')];
  }

  parts.unshift(base, type);

  return parts.join('/');
};

},{}],206:[function(require,module,exports){
'use strict';

module.exports = function (uri) {
  if (!uri || !uri.split) {
    return null;
  }
  var parts = uri.split(':');
  var result = null;
  switch (parts[1]) {
    case 'album':
      // spotify:album:<id>:<disc>
      if (parts.length === 4) {
        return 'disc';
      } else if (parts.length === 3) {
        return 'album';
      }
      break;

    case 'artist':
      if (parts.length === 3) {
        return 'artist';
      }
      break;

    case 'track':
      if (parts.length === 3) {
        return 'track';
      }
      break;

    case 'genre':
      if (parts.length === 3) {
        return 'genre';
      }
      break;

    case 'station':
      if (parts.length > 3) {
        return 'station';
      }
      break;

    case 'local':
      if (parts.length === 6) {
        return 'track';
      } else if (parts.length === 4) {
        return 'album';
      } else if (parts.length === 3) {
        return 'artist';
      }
      break;

    case 'user':
      // spotify:user:<username>:collection
      if (parts.length > 3 && parts[3] === 'collection') {
        return 'collection';
      }

      // spotify:user:<username>:folder:<id>
      if (parts.length === 5 && parts[3] === 'folder') {
        return 'playlist-folder';
      }

      // spotify:user:<username>:<playlist:<id>|starred|toplist>
      if (parts.length > 3 && parts.length <= 5 && parts[2] !== 'facebook') {
        return 'playlist';
      } else if (parts.length === 3) {
        return 'user';
      }
      break;

    case 'internal':
      // spotify:internal:local-files
      return parts[2];

    case 'app':
      // spotify:app:collection:albums, spotify:app:radio
      return parts.slice(1).join('-');

    default:
    // Do nothing.
  }

  return result;
};

},{}],207:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var Translations = require('../spotify-translations');
var glueLocales = require('../spotify-glue-cat/strings');

module.exports = function (localeToStrings) {
  if (!localeToStrings || (typeof localeToStrings === 'undefined' ? 'undefined' : _typeof(localeToStrings)) !== 'object') {
    throw new Error('' + 'Locale strings must be a plain object. ' + 'See spotify-i18n/README.md');
  }

  function getClientLocale() {
    return typeof window !== 'undefined' && window.__spotify && window.__spotify.locale || 'en';
  }

  var locales = localeToStrings;
  var i18n = new Translations();
  i18n.injectData(locales[getClientLocale()] || {});

  return {
    locale: getClientLocale,
    get: i18n.get.bind(i18n),

    glueStrings: function glueStrings() {
      return glueLocales[getClientLocale()];
    },

    appStrings: function appStrings() {
      return locales[getClientLocale()];
    }
  };
};

},{"../spotify-glue-cat/strings":159,"../spotify-translations":291}],208:[function(require,module,exports){
'use strict';

var base = 'spotify:internal:filterlist';
var regExp = /^spotify:internal:filterlist:([^:]*):(.*)$/;

/**
 * Create a URI representing a filtered variant of a list.
 *
 * @param {string} originUri The original list URI.
 * @param {string} query The query string (compatible with Core). Filter
 *     implementations might not look at all values.
 *
 * @return {string} URI of the filtered variant of the list. The URI will have
 *     the query string URL encoded.
 */
exports.create = function (originUri, query) {
  originUri = originUri.replace(/^spotify:/, '');

  query = encodeURIComponent(query);

  return [base, query, originUri].join(':');
};

/**
 * Get the query string from a filter URI.
 *
 * @param {string} filterUri The URI of the filtered list.
 *
 * @return {string} The query string, URL decoded. If URI is
 *     invalid, this returns an empty string.
 */
exports.getQuery = function (filterUri) {
  var matches = filterUri.match(regExp);
  if (!matches) return '';

  return decodeURIComponent(matches[1]);
};

/**
 * Get the URI of the original list.
 *
 * @param {string} filterUri The URI of the filtered list.
 *
 * @return {string} The URI of the original list. If the filter URI is invalid,
 *     this returns an empty string.
 */
exports.getOriginUri = function (filterUri) {
  var matches = filterUri.match(regExp);
  if (!matches) return '';

  return 'spotify:' + matches[2];
};

/**
 * Parse and return all parts of the filter URI.
 *
 * @param {string} filterUri The URI of the filtered list.
 *
 * @return {Object?} An object with properties `direction`, `query` and `originUri`,
 *     or null if the URI is not valid.
 */
exports.parse = function (filterUri) {
  var matches = filterUri.match(regExp);
  if (!matches) return null;

  return {
    query: decodeURIComponent(matches[1]),
    originUri: 'spotify:' + matches[2]
  };
};

/**
 * Test if the provided URI is a valid filter URI.
 *
 * @param {string} filterUri The URI of the filtered list.
 *
 * @return {boolean} True if it's valid, false otherwise.
 */
exports.isValid = function (filterUri) {
  return regExp.test(filterUri);
};

/**
 * The regular expression that matches filter URIs.
 */
exports.regExp = regExp;

},{}],209:[function(require,module,exports){
(function (global){
'use strict';

var live = require('../../spotify-live');
var cosmos = require('../util/cosmos');
var Collection = require('./collection');

var endpoints = {
  isInCollection: 'sp://core-collection/v1/contains',
  updateIsInCollection: 'sp://core-collection/v1/items',
  changes: 'hm://collection-web/v1/@/changes',
  broadcast: 'sp://messages/v1/collectionstate',
  pubsub: 'hm://collection/collection/@/json'
};

var onCollectionPublish = function onCollectionPublish(error, response) {
  if (error) {
    if (global.console) console.error(error);
    return;
  }

  // Currently, we only store tracks in collection2, and derive albums from
  // these. Because of this, we only get tracks in the pubsub events, but
  // adding/removing a track might have altered the calculated Collection state
  // of its album. To check this, we pass the change set down to
  // the changes endpoint and will receive a list of objects with
  // uri and isInCollection properties that we can forward to live.
  cosmos.sanitizeURL(endpoints.changes, function (error, url) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }

    // FIXME: Hack alert
    // Because of enum weirdness in Java, we need to
    // uppercase the value in the type field.
    // Remove this map once FESK-1921 is fixed.
    response.body.items = response.body.items.map(function (item) {
      item.type = item.type.toUpperCase();
      return item;
    });
    // End hack alert

    cosmos.post({ url: url, body: response.body }, function (error, response) {
      if (error) {
        if (global.console) console.error(error);
        return;
      }
      response.body.items.forEach(function (item) {
        if (item.hasOwnProperty('isInCollection') && !item.hasOwnProperty('added')) {
          // Patch items to contain added
          item.added = item.isInCollection;
        }
      });
      live(response.body.items);
    });
  });
};

var albumCollection;
var broadcastSubscription;
var collectionSubscription;

var regExp = exports.matches = /^spotify:album:[^:]+$/;
var registered = false;
exports.register = function () {
  if (registered) return;
  registered = true;

  albumCollection = new Collection(endpoints);

  live.subscribe(regExp, 'publish', albumCollection.onPublish);
  live.subscribe(regExp, 'wait', albumCollection.onWait);

  broadcastSubscription = cosmos.subscribe({ url: endpoints.broadcast }, Collection.onBroadcast);
  collectionSubscription = cosmos.subscribe({ url: endpoints.pubsub }, onCollectionPublish);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  live.unsubscribe(regExp, 'publish', albumCollection.onPublish);
  live.unsubscribe(regExp, 'wait', albumCollection.onWait);

  albumCollection = null;

  if (broadcastSubscription) {
    broadcastSubscription.cancel();
    broadcastSubscription = null;
  }

  if (collectionSubscription) {
    collectionSubscription.cancel();
    collectionSubscription = null;
  }
};

exports._endpoints = endpoints;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../spotify-live":251,"../util/cosmos":247,"./collection":211}],210:[function(require,module,exports){
'use strict';

var profile = require('./profile');

var regExp = exports.matches = /^spotify:artist:/;
var registered;
exports.register = function () {
  if (registered) return;
  registered = true;

  profile.register(regExp);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  profile.unregister(regExp);
};

},{"./profile":215}],211:[function(require,module,exports){
(function (global){
'use strict';

// This model will take a URI and create a live model for that URI.
//
//
// It will listen for publish events on the live model. The publish
// events are only triggered when someone actually wants to update
// something on the backend.
// When a publish event is detected, it will:
//
// * If the changed property was "added", it will contact
//   the backend to update the stored collection state. If this
//   fails, it will set it to the opposite of what was pusblished.
//
// * On success, broadcast the changes to the rest of the client via
//   cosmos, as "isInCollection" / "isFollowing" and as "added".
//
// This model will also listen for update events on the live model.
// The update event will be triggered when someone changes the data
// on the live model, without an intention to update the backend.
// When an update event is detected, it will:
//
// This model will also listen for broadcast events from the rest
// of the client. When a broadcast event is received, this happens:
//
// * If the URI for the broadcast message does not match this model,
//   do nothing.
//
// * It will then update the live model with the data it received
//   from the broadcast event. This will trigger the update listener
//   described above, but it won't run the code because all properties
//   are there.

var prime = require('prime');
var defer = require('prime/defer');

var live = require('../../spotify-live');
var contains = require('mout/array/contains');

var cosmos = require('../util/cosmos');

var INSUFFICIENT_STORAGE = 507;

// COLLECTION

var Collection = prime({

  constructor: function constructor(endpoints) {
    var self = this;
    this.endpoints = endpoints;
    this.onPublish = this.onPublish.bind(this);
    this.waitQueue = [];
    this.onWait = this.onWait.bind(this);
    this.fetch = this.fetch.bind(this);
  },

  onPublish: function onPublish(model, data) {
    // If the property is "added", update the backend with the new value
    // If the update fails, revert the state
    // If the update does not fail, broadcast the new state, as "isInCollection" and "added"
    if ('added' in data) {

      var endpoints = this.endpoints;
      var state = !!data.added;

      // optimistic
      model.update({ added: state });

      var method = state ? 'post' : 'delete';
      this._publish(method, [model], function (error, data) {
        if (error) {
          // that's what being optimistic gets you
          model.update({ added: !state });
          if (error.response && error.response.getStatusCode() === INSUFFICIENT_STORAGE) {
            cosmos.post({
              url: 'sp://messages/v1/container/user-message',
              body: { id: 'collection-limit-exceeded' }
            });
          }
        } else {
          cosmos.post({ url: endpoints.broadcast, body: { uri: model.uri, isInCollection: state, added: state } });
          if (data && data.items) {
            data.items.forEach(function (item) {
              // Patch items to contain added
              item.added = item.isInCollection;
              cosmos.post({ url: endpoints.broadcast, body: item });
            });
          }
        }
      });
    }
  },

  onWait: function onWait(model, properties) {
    if (contains(properties, 'added')) {
      this.fetch(model);
    }
  },

  fetch: function fetch(model) {
    var endpoints = this.endpoints;
    var queue = this.waitQueue;

    queue.push(model);

    // The first thing that gets added to the queue should defer a batch fetch
    // for the next tick. On the next tick, it will batch fetch status for all
    // models added to the queue.
    if (queue.length === 1) {
      defer(this._fetchBatch, this);
    }
  },

  _fetchBatch: function _fetchBatch() {
    var queue = this.waitQueue;
    if (queue.length === 0) return;

    // Create a new queue for requests coming after this
    this.waitQueue = [];

    this._contains(queue, function (error, result) {
      // Collection returns 404 for a user without a collection. This is sent as an error,
      // but we will just interpret that as `isInCollection` is false. All other errors
      // we just throw.
      if (error && (!error.response || error.response && error.response.getStatusCode() !== 404)) {
        if (global.console) console.error(error);
        return;
      }

      queue.forEach(function (model, i) {
        var added = false;
        if (!error) added = result[i];
        model.update({ added: added });
      });
    });
  },

  _contains: function _contains(models, callback) {
    var url = this.endpoints.isInCollection;
    var body = this._getRequestBody(models);

    cosmos.post({ url: url, body: body }, function (error, result) {
      callback(error, result && result.body && result.body.found);
    });
  },

  _publish: function _publish(method, models, callback) {
    var url = this.endpoints.updateIsInCollection;
    var body = this._getRequestBody(models);

    cosmos[method]({ url: url, body: body }, function (error, result) {
      callback(error, result && result.body);
    });
  },

  _getRequestBody: function _getRequestBody(models) {
    return {
      items: models.map(function (model) {
        return model.uri;
      }),
      source: global.__spotify && global.__spotify.app_uri || null
    };
  }

});

// ----------------------

Collection.onBroadcast = function (error, response) {
  if (error) {
    if (global.console) console.error(error);
    return;
  }

  var value;
  if ('added' in response.body) value = response.body.added;
  // Deal with older versions of this package that send isInCollection / isFollowing
  else if ('isInCollection' in response.body) value = response.body.isInCollection;

  live(response.body.uri).update({
    added: value
  });
};

module.exports = Collection;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../spotify-live":251,"../util/cosmos":247,"mout/array/contains":349,"prime":404,"prime/defer":402}],212:[function(require,module,exports){
'use strict';

var album = require('./album');
var artist = require('./artist');
var playlist = require('./playlist');
var track = require('./track');
var user = require('./user');
var local = require('./local');

exports.register = function () {
  album.register();
  artist.register();
  playlist.register();
  track.register();
  user.register();
  local.register();
};

exports.unregister = function () {
  album.unregister();
  artist.unregister();
  playlist.unregister();
  track.unregister();
  user.unregister();
  local.unregister();
};

},{"./album":209,"./artist":210,"./local":213,"./playlist":214,"./track":216,"./user":217}],213:[function(require,module,exports){
'use strict';

var live = require('../../spotify-live');
var contains = require('mout/array/contains');

var onWait = function onWait(model, properties) {
  if (contains(properties, 'added')) {
    // Neither tracks nor albums or artists can ever be added to YM.
    model.update({ added: false });
  }
};

// Matches local track, albums and artists.
var regExp = exports.matches = /^spotify:local:[^:]*:[^:]*:[^:]*:\d*$|^spotify:local:[^:]*:[^:]*$|^spotify:local:[^:]*$/;
var registered = false;
exports.register = function () {
  if (registered) return;
  registered = true;

  live.subscribe(regExp, 'wait', onWait);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  live.unsubscribe(regExp, 'wait', onWait);
};

},{"../../spotify-live":251,"mout/array/contains":349}],214:[function(require,module,exports){
(function (global){
'use strict';

// The 'playlist' function will be called when a new live object is
// created for the pattern in playlist.matches. We use this function
// to automatically add data to the live model when requested, and to
// push any needed updates to the backend.
//
//
// It will listen for publish events on the live model. The publish
// events are only triggered when someone actually wants to update
// something on the backend.
// When a publish event is detected, it will:
//
// * Broadcast the changes to the rest of the client via cosmos.
//
// * If the changed property was `added`, it will contact
//   the backend to update the stored collection state for the
//   currently logged in user. If this fails, it will revert the
//   state for the live model and broadcast the reverted state.
//
// This function will also listen for update events on the live model.
// The update event will be triggered when someone changes the data
// on the live model, without an intention to update the backend.
// When an update event is detected, it will:
//
// This function will also listen for broadcast events from the rest
// of the client. When a broadcast event is received, this happens:
//
// * If the URI for the broadcast message does not match this model,
//   do nothing.
//
// * It will then update the live model with the data it received
//   from the broadcast event. This will trigger the update listener
//   described above, but it won't run the code because all properties
//   are there.

var contains = require('mout/array/contains');

var live = require('../../spotify-live');
var liburi = require('spotify-liburi');

var cosmos = require('../util/cosmos');
var bridge = require('../util/bridge').request;

var endpoints = {
  broadcast: 'sp://messages/v1/followstate'
};

function onPublish(model, data) {
  // If the property is "added", update the backend with the new
  // value. If the update fails somewhere along the way, revert the state
  // and broadcast the reverted state to the rest of the client.
  if ('added' in data) {
    model.update({ added: data.added });

    if (model.get('followersCount') != null) {
      model.update({
        followersCount: model.get('followersCount') + (data.added ? 1 : -1)
      });
    }

    updateBackend(model, !!data.added, function (error) {
      if (error) {
        // Revert optimistic change
        model.update({ added: !data.added });

        if (model.get('followersCount') != null) {
          model.update({
            followersCount: model.get('followersCount') + (!data.added ? 1 : -1)
          });
        }
      } else {
        broadcast(model);
      }
    });
  }
}

function onBroadcast(error, response) {
  if (error) {
    if (global.console) console.error(error);
    return;
  }
  var value;
  if ('added' in response.body) {
    value = response.body.added;
  } else if ('isFollowing' in response.body) {
    value = response.body.isFollowing;
  }

  if (value !== undefined) {
    live(response.body.uri).update({
      added: value
    });
  }
}

function fetchAdded(model) {
  cosmos.get({
    url: 'sp://core-playlist/v1/playlist/' + encodeURIComponent(model.uri) + '/metadata',
    body: {
      policy: {
        followed: true
      }
    }
  }, function (error, response) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }
    model.update({
      added: response.body.metadata.followed
    });
  });
}

function fetchFollowersCount(model) {
  bridge('playlist_subscribers_snapshot', [{ type: 'list', uri: model.uri }, 0, 0], function (error, data) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }
    model.update({
      followersCount: data.length
    });
  });
}

function getRequestData(callback) {
  // Assumes that the client live object either already has the data about the current user,
  // or that there is code included for getting this data on request.
  live('spotify:client').query('currentUser(username)', function (error, data) {
    if (error) return callback(error);

    callback(null, {
      username: data.currentUser.username
    });
  });
}

function broadcast(model) {
  var value = model.get('added');
  cosmos.post({
    url: endpoints.broadcast,
    body: {
      uri: model.uri,
      isFollowing: value,
      added: value
    }
  });
}

function updateBackend(model, added, callback) {
  if (added) {
    cosmos.post({
      url: 'sp://core-playlist/v1/rootlist',
      body: {
        operation: 'add',
        uris: [model.uri],
        before: 'start'
      }
    }, function (error, response) {
      if (error) return callback(error);
      model.update({
        added: true
      });
      callback(null);
    });
  } else {
    // Removing using Core needs the `rowId`, which we don't necessarily have,
    // so stick with old bridge message for now. It's only adding that needs to
    // be done using Core to fix KM-8804.
    bridge('library_unsubscribe', [liburi.profileURI(__spotify.username).toURI(), model.uri], function (error, data) {
      if (error) return callback(error, data);
      callback(null, data);
    });
  };
}

var onWait = function onWait(model, properties) {
  var needsAdded = contains(properties, 'added');
  var needsFollowersCount = contains(properties, 'followersCount');
  if (needsAdded) {
    var subscribed = model.get('subscribed');
    if (subscribed !== undefined) {
      model.update({ added: subscribed });
    } else {
      fetchAdded(model);
    }
  }
  if (needsFollowersCount) {
    fetchFollowersCount(model);
  }
};

var regExp = exports.matches = /^spotify:user:[^:]+:playlist:[^:]+$/;

var broadcastSubscription;
var registered;
exports.register = function () {
  if (registered) return;
  registered = true;

  live.subscribe(regExp, 'publish', onPublish);
  live.subscribe(regExp, 'wait', onWait);
  broadcastSubscription = cosmos.subscribe({ url: endpoints.broadcast }, onBroadcast);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  live.unsubscribe(regExp, 'publish', onPublish);
  live.unsubscribe(regExp, 'wait', onWait);

  broadcastSubscription.cancel();
  broadcastSubscription = null;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../spotify-live":251,"../util/bridge":246,"../util/cosmos":247,"mout/array/contains":349,"spotify-liburi":426}],215:[function(require,module,exports){
(function (global){
'use strict';

// This model will, when registered to live, listen for publish
// events on the live model. The publish events are only triggered
// when someone actually wants to update something on the backend.
// When a publish event is detected, it will:
//
// * Broadcast the changes to the rest of the client via cosmos.
//
// * If the changed property was isFollowing, it will contact
//   the backend to update the stored following state for the
//   currently logged in user. If this fails, it will revert the
//   state for the live model and broadcast the reverted state.
//
// This function will also listen for update events on the live model.
// The update event will be triggered when someone changes the data
// on the live model, without an intention to update the backend.
// When an update event is detected, it will:
//
// * If the changed property was isFollowing, it will automatically
//   update followersCount on the live model.
//
// This function will also listen for broadcast events from the rest
// of the client. When a broadcast event is received, this happens:
//
// * If the URI for the broadcast message does not match this model,
//   do nothing.
//
// * It will then update the live model with the data it received
//   from the broadcast event. This will trigger the update listener
//   described above, but it won't run the code because all properties
//   are there.
//

var intersection = require('mout/array/intersection');
var live = require('../../spotify-live');
var cosmos = require('../util/cosmos');
var requestsInProgress = {};

var endpoints = {
  isFollowing: 'hm://socialgraph/v2/is_following?format=json',
  followCounts: 'hm://socialgraph/v2/counts?format=json',
  updateIsFollowing: 'hm://socialgraph/v2/following?format=json',
  broadcast: 'sp://messages/v1/followstate'
};

function onUpdate(model, data) {

  // Only update followers count if that data was not present in the changed data
  if ('added' in data && !('followersCount' in data)) {
    var followersCount = model.get('followersCount');
    if (followersCount !== undefined) {
      var newFollowersCount = followersCount + (data.added ? 1 : -1);
      model.update({ followersCount: newFollowersCount });
    }
  }
}

function onPublish(model, data) {
  // If the property is added, update the backend with the new value.
  // If the update fails, revert the model state.
  // If the update is successful, broadcast the state to the client.
  if ('added' in data) {
    // if there is a request in course, do not launch a new request
    // as this can mess up with the Backend
    if (requestsInProgress[model.uri]) {
      return;
    }
    requestsInProgress[model.uri] = true;

    // we're optimistic this will work
    model.update({ 'added': data.added });

    updateBackend(model, !!data.added, function (error) {
      // request finished, we can accept more requests now
      delete requestsInProgress[model.uri];
      if (error) {
        // such is life.
        model.update({ added: !data.added });
      } else {
        model.update({ added: data.added });
        broadcast(model);
      }
    });
  }
}

function onBroadcast(error, response) {
  if (error) {
    if (global.console) console.error(error);
    return;
  }

  var body = response.body;
  var data = {};

  if ('added' in body) data.added = body.added;
  // Also accept broadcast from older versions that only send "isFollowing"
  else if ('isFollowing' in body) data.added = body.isFollowing;

  if ('followersCount' in body) data.followersCount = body.followersCount;
  if ('followingCount' in body) data.followingCount = body.followingCount;

  live(body.uri).update(data);
}

function onWait(model, properties) {
  if (intersection(properties, followProperties).length) getRequestData(model, function (error, data) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }
    updateIsFollowing(model, data);
    updateCounts(model, data);
  });
}

function updateIsFollowing(model, requestData, opt_callback) {
  var options = {
    url: endpoints.isFollowing,
    body: requestData
  };
  cosmos.get(options, function (error, response) {
    if (error && opt_callback) return opt_callback(error);
    if (error) {
      if (global.console) console.error(error);
      return;
    }

    var value = response.body[0].is_following;
    model.update({ added: value });

    if (opt_callback) opt_callback();
  });
}

function updateCounts(model, requestData, opt_callback) {
  var options = {
    url: endpoints.followCounts,
    body: requestData
  };
  cosmos.get(options, function (error, response) {
    if (error && opt_callback) return opt_callback(error);
    if (error) {
      if (global.console) console.error(error);
      return;
    }

    var body = response.body[0];

    model.update({
      followersCount: body.followers_count,
      followingCount: body.following_count
    });

    if (opt_callback) opt_callback();
  });
}

function getRequestData(model, callback) {
  // Assumes that the client live object either already has the data about the current user,
  // or that there is code included for getting this data on request.
  live('spotify:client').query('currentUser(uri)', function (error, data) {
    if (error) return callback(error);

    callback(null, {
      // Social graph v2 expects decoded uris (i.e. spotify:user:someone!
      // rather than spotify:user:someone%21). `currentUser(uri)` returns a
      // uri-encoded user name.
      source_uri: decodeURIComponent(data.currentUser.uri),
      target_uris: [decodeURIComponent(model.uri)]
    });
  });
}

function updateBackend(model, isFollowing, callback) {

  getRequestData(model, function (error, data) {
    if (error) return callback(error);
    var requestMethod = isFollowing ? 'post' : 'delete';
    cosmos[requestMethod]({ url: endpoints.updateIsFollowing, body: data }, function (error) {
      if (error) return callback(error);
      callback(null);
    });
  });
}

function broadcast(model) {
  var added = model.get('added');
  cosmos.post({
    url: endpoints.broadcast,
    body: {
      uri: model.uri,
      isFollowing: added,
      added: added,
      followersCount: model.get('followersCount'),
      followingCount: model.get('followingCount')
    }
  });
}

var followProperties = ['added', 'followersCount', 'followingCount'];

var broadcastSubscription;

exports.register = function (regExp) {
  live.subscribe(regExp, 'wait', onWait);
  live.subscribe(regExp, 'update', onUpdate);
  live.subscribe(regExp, 'publish', onPublish);

  // reset the requestsInProgress variable
  requestsInProgress = {};

  if (!broadcastSubscription) {
    broadcastSubscription = cosmos.subscribe({ url: endpoints.broadcast }, onBroadcast);
  }
};

exports.unregister = function (regExp) {
  live.unsubscribe(regExp, 'wait', onWait);
  live.unsubscribe(regExp, 'update', onUpdate);
  live.unsubscribe(regExp, 'publish', onPublish);

  if (broadcastSubscription) {
    broadcastSubscription.cancel();
    broadcastSubscription = null;
  }
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../spotify-live":251,"../util/cosmos":247,"mout/array/intersection":358}],216:[function(require,module,exports){
(function (global){
'use strict';

var live = require('../../spotify-live');
var cosmos = require('../util/cosmos');
var Collection = require('./collection');

var endpoints = {
  isInCollection: 'sp://core-collection/v1/contains',
  updateIsInCollection: 'sp://core-collection/v1/items',
  broadcast: 'sp://messages/v1/collectionstate',
  pubsub: 'hm://collection/collection/@/json'
};

var onCollectionPublish = function onCollectionPublish(error, response) {
  if (error) {
    if (global.console) console.error(error);
    return;
  }

  var items = response.body.items;
  items.forEach(function (item) {
    // FIXME: Hack alert
    // Because of enum weirdness in Java, we need to
    // uppercase the value in the type field.
    // Remove this once FESK-1921 is fixed.
    if (item.type.toUpperCase() === 'TRACK') {
      var uri = 'spotify:track:' + item.identifier;
      live(uri).update({ added: !item.removed });
    }
  });
};

var trackCollection;
var broadcastSubscription;
var collectionSubscription;

var regExp = exports.matches = /^spotify:track:[^:]+$/;
var registered = false;
exports.register = function () {
  if (registered) return;
  registered = true;

  trackCollection = new Collection(endpoints);

  live.subscribe(regExp, 'publish', trackCollection.onPublish);
  live.subscribe(regExp, 'wait', trackCollection.onWait);

  broadcastSubscription = cosmos.subscribe({ url: endpoints.broadcast }, Collection.onBroadcast);
  collectionSubscription = cosmos.subscribe({ url: endpoints.pubsub }, onCollectionPublish);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  live.unsubscribe(regExp, 'publish', trackCollection.onPublish);
  live.unsubscribe(regExp, 'wait', trackCollection.onWait);

  trackCollection = null;

  if (broadcastSubscription) {
    broadcastSubscription.cancel();
    broadcastSubscription = null;
  }

  if (collectionSubscription) {
    collectionSubscription.cancel();
    collectionSubscription = null;
  }
};

exports._endpoints = endpoints;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../spotify-live":251,"../util/cosmos":247,"./collection":211}],217:[function(require,module,exports){
'use strict';

var profile = require('./profile');

var regExp = exports.matches = /^spotify:user:[^:]+$/;
var registered;
exports.register = function () {
  if (registered) return;
  registered = true;

  profile.register(regExp);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  profile.unregister(regExp);
};

},{"./profile":215}],218:[function(require,module,exports){
(function (global){
/**
 * @module spotify-live-models/application
 */
'use strict';

var contains = require('mout/array/contains');
var live = require('../spotify-live');
var bridge = require('./util/bridge').request;
var AppState = require('../spotify-navigation/app-state');

var BACKOFF = 100;

function bridgeWait() {
  bridge('application_event_wait', [], function (error, event) {
    if (!registered) return;
    if (error) {
      setTimeout(function () {
        bridgeWait(model);
      }, BACKOFF);
      if (global.console) console.error(error);
      return;
    }

    var model = live('spotify:application');

    if (event.data && event.data.arguments) {
      model.update({
        arguments: event.data.arguments.join(':')
      });
    }

    // These don't won't happen on Zelda, there we handle it through postMessage. See onMessage.
    switch (event.type) {
      case 'activate':
        model.update({ 'active': true });
        break;

      case 'deactivate':
        model.update({ 'active': false });
        break;
    }

    bridgeWait(model);
  });
}

function onMessage(message) {
  var model = live('spotify:application');

  if (message.data && message.data.name) {
    if (message.data.name === 'set_active') {
      model.update({
        active: message.data.active
      });
    } else if (message.data.name === 'set_arguments') {
      // Arguments come as an array of un-encoded values, but we need to
      // concatenate them to a single colon-separated string for the
      // current design of the API. This is incorrect, as arguments should
      // be encoded if they are joined in a string. We should fix this, but
      // not without a breaking change.
      // https://jira.spotify.net/browse/KM-2353
      model.update({
        arguments: message.data.arguments.join(':')
      });
    } else if (message.data.name === 'set_state') {
      model.update({
        state: AppState.unserialize(message.data.state)
      });
    }
  }
}

function onRegister(model) {
  model.update({
    version: global.__spotify && global.__spotify.app_version || '0.0.0'
  });

  bridge('application_query', [], function (error, payload) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }

    var data = {};
    if (payload.uri) data.appURI = payload.uri;
    if (payload.arguments) data.arguments = payload.arguments.join(':');
    if ('active' in payload) data.active = payload.active;

    model.update(data);
  });
}

function applicationOpenUri(model, event) {
  bridge('application_open_uri', [event.uri]);
}

function applicationReplaceUri(model, event) {

  // This is intended to work like history.replace in the browser.

  // Desktop can also replace further back, so the current appURI needs
  // to be passed.
  // Link can't replace further back anyway, so anything thruthy as the
  // second argument will just replace the current.

  model.get('appURI', function (error, appUri) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }
    bridge('application_open_uri', [event.uri, appUri]);
  });
}

var regExp = exports.matches = /^spotify:application$/;
var registered;
exports.register = function () {
  if (registered) return;
  registered = true;

  live.subscribe(regExp, 'push-history-state', applicationOpenUri);
  live.subscribe(regExp, 'replace-history-state', applicationReplaceUri);
  global.addEventListener('message', onMessage);
  bridgeWait();
  onRegister(live('spotify:application'));
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  live.unsubscribe(regExp, 'push-history-state', applicationOpenUri);
  live.unsubscribe(regExp, 'replace-history-state', applicationReplaceUri);
  global.removeEventListener('message', onMessage);
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-live":251,"../spotify-navigation/app-state":268,"./util/bridge":246,"mout/array/contains":349}],219:[function(require,module,exports){
(function (global){
/**
 * @module spotify-live-models/client-storage
 */
'use strict';

var forOwn = require('mout/object/forOwn');
var combine = require('mout/array/combine');
var remove = require('mout/array/remove');
var contains = require('mout/array/contains');

var URI = 'spotify:client-storage';
var live = require('../spotify-live');
var cosmos = require('./util/cosmos');
var endpoints = {
  broadcast: 'sp://messages/v1/client-storage'
};

var waiting = [];

function onInit(model) {
  // Set a flag for showing that the model has been implemented and
  // registered. This is so that we can check this in player without
  // making a breaking change. Would be great with a future live API
  // to see if someone has implemented a specific model.
  model.update({ implemented: true });
}

function onWait(model, properties) {
  // Ask the top frame to broadcast the properties.
  // Values will be null when they weren't stored.
  waiting = combine(waiting, properties);
  global.top.postMessage({
    type: 'client_storage',
    name: 'broadcast_client_storage',
    data: properties
  }, '*');
}

function onPublish(model, properties) {
  // Tell the top frame to persist and broadcast
  global.top.postMessage({
    type: 'client_storage',
    name: 'set_client_storage',
    data: properties
  }, '*');

  // Optimistic update
  model.update(properties);
}

function onBroadcast(error, event) {
  var update = {};
  var model = live(URI);
  forOwn(event.body, function (value, key) {

    // Update model if this instance of storage knows that the model waits for it
    var isWaiting = contains(waiting, key);

    // Or if the model has a potentially outdated value in the live cache
    var hasKey = model.get(key) !== undefined;

    if (isWaiting || hasKey) update[key] = value;
    if (isWaiting) remove(waiting, key);
  });
  model.update(update);
}

var broadcastSubscription;
var regExp = exports.matches = new RegExp('^' + URI + '$');
var registered;

exports.register = function () {
  if (registered) return;
  registered = true;

  live.subscribe(regExp, 'init', onInit);
  live.subscribe(regExp, 'wait', onWait);
  live.subscribe(regExp, 'publish', onPublish);
  broadcastSubscription = cosmos.subscribe({ url: endpoints.broadcast }, onBroadcast);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  live.unsubscribe(regExp, 'init', onInit);
  live.unsubscribe(regExp, 'wait', onWait);
  live.unsubscribe(regExp, 'publish', onPublish);

  if (broadcastSubscription) {
    broadcastSubscription.cancel();
    broadcastSubscription = null;
  }
  waiting.length = 0;
};

exports._endpoints = endpoints;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-live":251,"./util/cosmos":247,"mout/array/combine":348,"mout/array/contains":349,"mout/array/remove":362,"mout/object/forOwn":389}],220:[function(require,module,exports){
(function (global){
/**
 * @module spotify-live-models/client
 */
'use strict';

var live = require('../spotify-live');
var bridge = require('./util/bridge').request;
var liburi = require('spotify-liburi');

var BACKOFF = 100;

function updateCurrentUser(model) {
  bridge('user_metadata', ['spotify:user:@'], function (error, payload) {
    if (error) {
      if (global.__spotify && global.__spotify.username) {
        var username = global.__spotify.username;
        model.update({
          currentUser: {
            uri: liburi.profileURI(username).toURI(),
            username: username
          }
        });
      }

      if (global.console) console.error(error);
      return;
    }

    model.update({
      currentUser: {
        uri: liburi.profileURI(payload.username).toURI(),
        name: payload.name,
        username: payload.username
      }
    });
  });
}

function getFeatures(callback) {
  bridge('client_features', [], function (error, payload) {
    if (error) return callback(error);
    callback(null, payload.features);
  });
}

function updateSessionData(model) {
  bridge('session_query', [], function (error, payload) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }

    // Not all the clients expose employee property so it needs to be set if it does not exist
    if (payload.employee === undefined) {
      if (global.__spotify && global.__spotify.product_state && global.__spotify.product_state.employee) {
        // For Zelda
        payload.employee = global.__spotify.product_state.employee === '1' ? true : false;
      } else {
        // Clients older than 0.9.16 do not expose employee flag.
        payload.employee = false;
      }
    }

    model.update({ session: payload });

    // Initiate session subscription since data has been requested once.
    bridgeWaitSession(model);
  });
}

function bridgeWaitSession(model) {
  bridge('session_event_wait', [], function (error, event) {
    if (!registered) return;
    if (error) {
      setTimeout(function () {
        bridgeWaitSession(model);
      }, BACKOFF);
      if (global.console) console.error(error);
      return;
    }

    if (event.type === 'change') {
      model.get('session').update(event.data);
    }

    bridgeWaitSession(model);
  });
}

function showContextMenu(model, data) {
  if (global === window && window.top && window.top.postMessage) {
    window.top.postMessage({
      type: 'client_show_context_ui',
      data: data
    }, '*');
  }
}

function onWait(model, properties) {
  if (properties.indexOf('currentUser') > -1) {
    updateCurrentUser(model);
  }

  if (properties.indexOf('session') > -1) {
    updateSessionData(model);
  }
}

var hasFeatures;

function onFeaturesWait(featuresModel, properties) {
  // If features have been loaded before, every requested feature that
  // generates a 'wait' event after that is not an enabled feature in
  // the client, so we return false for all other properties.
  if (hasFeatures) {
    var features = {};
    properties.forEach(function (prop) {
      features[prop] = false;
    });
    featuresModel.update(features);
  } else {
    hasFeatures = true;
    getFeatures(function (error, features) {
      if (error) {
        if (global.console) console.error(error);
        return;
      }
      featuresModel.update(features);

      // Get a list of features that the model is waiting for still,
      // even after the received features were added.
      var neededFeatures = [];
      properties.forEach(function (prop) {
        if (!(prop in features)) neededFeatures.push(prop);
      });

      // Trigger a new wait handler for the properties it's still waiting for
      onFeaturesWait(featuresModel, neededFeatures);
    });
  }
}

function onInit(model) {
  // Get container_features and put it into it's own place on the client model.
  var __spotify = global.__spotify || {};
  var containerFeatures = live(__spotify.container_features || {});
  containerFeatures.on('wait', function (properties) {
    var update = {};
    for (var i = 0, property; property = properties[i]; i++) {
      update[property] = false;
    }
    containerFeatures.update(update);
  });

  // Listen for wait events on the features model to fetch data
  // through bridge and set other features to false
  var features = live({});
  features.on('wait', function (properties) {
    onFeaturesWait(features, properties);
  });

  model.update({
    features: features,
    containerFeatures: containerFeatures
  });

  // Grab the username from __spotify where available
  if (global.__spotify && global.__spotify.username) {
    var username = global.__spotify.username;
    model.update({
      currentUser: {
        uri: liburi.profileURI(username).toURI(),
        username: username
      }
    });
  }

  // Async fetch from bridge to complete currentUser to a user model
  // while we don't have all the info available elsewhere.
  updateCurrentUser(model);
}

var regExp = exports.matches = /^spotify:client$/;
var registered;
exports.register = function () {
  if (registered) return;
  registered = true;

  live.subscribe(regExp, 'wait', onWait);
  live.subscribe(regExp, 'init', onInit);
  live.subscribe(regExp, 'show-context-menu', showContextMenu);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  live.unsubscribe(regExp, 'wait', onWait);
  live.unsubscribe(regExp, 'init', onInit);
  live.unsubscribe(regExp, 'show-context-menu', showContextMenu);
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-live":251,"./util/bridge":246,"spotify-liburi":426}],221:[function(require,module,exports){
/**
 * @module spotify-live-models/list-variant
 */
'use strict';

var contains = require('mout/array/contains');
var showUnplayableTracks = require('./util/unplayable-tracks-playlist-setting.js');
var legacySortUris = require('./sorting/legacy-sort-uris');

var live = require('../spotify-live');
var sortUriUtils = require('../spotify-live-sort-uri');
var filterUriUtils = require('../spotify-live-filter-uri');
var URI = require('spotify-liburi');

var SESSION_STORAGE = 'spotify:session-storage';
var CLIENT_STORAGE = 'spotify:client-storage';
var SORT_VARIANT_KEY = 'list-variant-';
var STRING_FILTER_KEY = 'list-filter-string-';

var sessionStorageListeners = {};

function onWait(model, properties) {
  if (!contains(properties, 'listVariant')) {
    return;
  }

  var uri = getOriginUri(model.uri);

  // listVariant objects are shared amongst all variants.
  var listVariant = live(uri).get('listVariant');
  if (!listVariant) {
    listVariant = live({
      origin: {
        uri: uri
      }
    });
    listVariant.on('wait', onVariantWait.bind(null, listVariant));
  }

  model.update({ listVariant: listVariant });

  // If the model is a variant, set that list variant on the origin too
  // so it can be accessed there for the next variant to ask.
  if (uri !== model.uri) {
    live(uri).update({ listVariant: listVariant });
  }
}

function onVariantWait(model, properties) {
  if (contains(properties, 'currentUri')) {
    addAndWatchCurrentUri(model);
    // This will fulfill and watch all other properties
    return;
  }

  if (contains(properties, 'filterString')) {
    addAndWatchFilterString(model);
  }
  if (contains(properties, 'sortQuery') || contains(properties, 'sortDirection') || contains(properties, 'sortUri')) {
    addAndWatchSortQuery(model);
  }
  if (contains(properties, 'showUnplayable')) {
    addAndWatchUnplayable(model);
  }
}

function addAndWatchCurrentUri(model) {

  model.on('update', update);
  update();

  function update() {
    var props = 'filterString, sortQuery, sortDirection, sortUri, showUnplayable, origin(uri)';
    model.query(props, function (error, data) {
      if (error) {
        console.error('Error when getting', props, ':', Error);
        return;
      }

      var result = data.origin.uri;
      var filters = [];

      if (data.filterString) {
        filters.push('text contains ' + encodeURIComponent(data.filterString));
      }

      if (!data.showUnplayable) {
        filters.push('playable eq true');
      }

      if (filters.length) {
        result = filterUriUtils.create(result, filters.join(','));
      }

      var sortUriParams = data.sortUri && sortUriUtils.parse(data.sortUri);

      if (sortUriParams) {
        result = sortUriUtils.create(result, sortUriParams.direction, sortUriParams.query);
      }

      model.update({
        currentUri: result
      });
    });
  }
}

var showUnplayablePref;
var updateUnavailablePrefOn = [];

function addAndWatchUnplayable(model) {
  var uri = model.get('origin').uri;
  var type = URI.fromString(uri).type;

  if (type !== URI.Type.PLAYLIST) {
    model.update({ showUnplayable: true });
    return;
  }

  updateUnavailablePrefOn.push(model);
  if (showUnplayablePref != null) {
    model.update({ showUnplayable: showUnplayablePref });
    return;
  }

  showUnplayableTracks.subscribe(function (error, showUnplayable) {
    // Cache this globally as we will never cancel this subscribe here.
    // The same setting is valid for all models.
    if (error) {
      console.error(error);
      showUnplayable = false; // Should default to hide unplayable.
    }

    showUnplayablePref = showUnplayable;
    for (var i = 0; i < updateUnavailablePrefOn.length; i++) {
      updateUnavailablePrefOn[i].update({ showUnplayable: showUnplayable });
    }
  });
}

function addAndWatchSortQuery(model) {
  var uri = model.get('origin').uri;

  var clientStorage = live(CLIENT_STORAGE);
  var key = SORT_VARIANT_KEY + uri;
  if (clientStorage.get('implemented')) {
    updateSortParams(model, uri, key);
    clientStorage.on('update', function (changed) {
      if (changed.hasOwnProperty(key)) {
        updateSortParams(model, uri, key);
      }
    });
  } else {
    // There is no clientStorage. Update the model with defaults.
    var update = getDefaultQueryParams(uri);
    model.update(update);
  }
}

function updateSortParams(model, uri, key) {
  var clientStorage = live(CLIENT_STORAGE);

  clientStorage.get(key, function (error, variant) {
    // Respond with the sort variant if it's a valid sort URI
    var sortParams = variant && sortUriUtils.parse(variant);
    if (!error && sortParams) {
      // Check for legacy sort URIs and convert them by publishing
      // the updated version on client-storage
      var convertedFromLegacy = legacySortUris.legacyQueries[sortParams.query];

      if (convertedFromLegacy != null && convertedFromLegacy !== sortParams.query) {
        // Fix the legacy query on storage
        var fixedUri = sortUriUtils.create(uri, sortParams.direction, convertedFromLegacy);
        var publish = {};
        publish[key] = fixedUri;
        clientStorage.publish(publish);
        // This will trigger another update which will then set the sort params.
        return;
      }

      model.update({
        sortQuery: sortParams.query,
        sortDirection: sortParams.direction, // this is 'asc' or 'desc'
        sortUri: variant
      });
    } else if (variant === uri) {
      // This was unsorted.
      model.update({
        sortQuery: null,
        sortDirection: null,
        sortUri: null
      });
    } else {
      // There was nothing valid in store. Update the model with defaults.
      var update = getDefaultQueryParams(uri);
      model.update(update);
    }
  });
}

function getDefaultQueryParams(uri) {
  var sortQuery = null;
  var sortDirection = null;
  var sortUri = null;

  var isLocalFiles = uri === 'spotify:internal:local-files';
  if (isLocalFiles) {
    // Local files should be sorted by trackname by default
    sortQuery = 'track(name)';
    sortDirection = 'asc';
    sortUri = sortUriUtils.create(uri, sortDirection, sortQuery);
  }

  return {
    sortQuery: sortQuery,
    sortDirection: sortDirection,
    sortUri: sortUri
  };
}

function addAndWatchFilterString(model) {
  var uri = model.get('origin').uri; // The variant object itself doesn't have a uri, this is the one for the list it's about
  var sessionStorage = live(SESSION_STORAGE);
  var key = STRING_FILTER_KEY + uri;

  if (sessionStorage.get('implemented')) {
    updateFilterString(model, uri, key);
    sessionStorage.on('update', function (changed) {
      if (changed.hasOwnProperty(key)) {
        updateFilterString(model, uri, key);
      }
    });
  } else {
    model.update({ 'filterString': '' });
  }
};

function updateFilterString(model, uri, key) {
  var sessionStorage = live(SESSION_STORAGE);

  sessionStorage.get(key, function (error, value) {
    model.update({ 'filterString': value || '' });
  }, live.ASAP);
}

function getOriginUri(uri) {
  var sorted = sortUriUtils.parse(uri);
  if (sorted) uri = sorted.originUri;

  var filtered = filterUriUtils.parse(uri);
  if (filtered) uri = filtered.originUri;

  return uri;
}

function updateRegisteredStatus(status) {
  registered = status;
  live('spotify:list-variant').update({ implemented: status });
}

var regExp = exports.matches = /^spotify:/;
var registered;
exports.register = function () {
  if (registered) return;

  live.subscribe(regExp, 'wait', onWait);
  updateRegisteredStatus(true);
};

exports.unregister = function () {
  if (!registered) return;

  updateUnavailablePrefOn = [];
  showUnplayablePref = null;

  live.unsubscribe(regExp, 'wait', onWait);
  updateRegisteredStatus(false);
};

},{"../spotify-live":251,"../spotify-live-filter-uri":208,"../spotify-live-sort-uri":249,"./sorting/legacy-sort-uris":232,"./util/unplayable-tracks-playlist-setting.js":248,"mout/array/contains":349,"spotify-liburi":426}],222:[function(require,module,exports){
'use strict';

var cosmos = require('../util/cosmos');

var ARTIST_CONTEXT_URL = 'hm://artistplaycontext/';

function getContext(contextUri, options, opt_callback) {

  var url = contextUri.split(':').join('/');
  var resolverUrl = ARTIST_CONTEXT_URL + url + '/km';
  var postObject = { url: resolverUrl };

  cosmos.get(postObject, opt_callback);
}

module.exports = {
  getContext: getContext
};

},{"../util/cosmos":247}],223:[function(require,module,exports){
(function (global){
/**
 * @module spotify-live-models/player/control
 * @private
 */
'use strict';

var shuffleMode = require('../../spotify-shuffle-mode');
var cosmosPlayer = require('./cosmos-player');
var playerApi = require('./player-api');
var playlistResolver = require('./playlist-resolver');
var artistResolver = require('./artist-resolver');

var dataUtils = require('./data');

var cosmos = require('../util/cosmos');

/**
 * Check AB test if it should use new artist context resolver.
 *
 * @param {Function=} callback Callback function.
 **/
function shouldUseArtistContextPlayerResolver(callback) {
  var ARTIST_CONTEXT_TEST = 'Rollout_short_artist_context_desktop';
  cosmos.post({
    url: 'sp://abba/v1/flags',
    body: { flags: [ARTIST_CONTEXT_TEST] }
  }, function (_, response) {
    var flags = response && response.body && response.body.flags || [];
    var featureFlagCell = flags[0] && flags[0].featureName === ARTIST_CONTEXT_TEST && flags[0].cell;

    callback(featureFlagCell === 'Rollout');
  });
}

/**
 * Request to play a list of track URIs.
 *
 * @param {Array.<string>} trackUris Array of track URIs.
 * @param {?Array.<string>} opt_ids Array of one id per track. Not needed when the context never needs to be updated.
 * @param {Object} playOptions An object with play options.
 * @param {Function=} opt_callback Callback function.
 */
function playTrackUris(trackUris, opt_ids, playOptions, opt_callback) {
  playerApi.play(trackUris, opt_ids, playOptions, opt_callback);
}

/**
 * Request to play a context through the cosmos track resolver.
 *
 * @param {string} contextUri Context URI.
 * @param {Object} playOptions An object with play options.
 * @param {Function=} opt_callback Optional callback function.
 */
function playFromResolver(contextUri, playOptions, opt_callback) {
  playerApi.playFromResolver(contextUri, playOptions, opt_callback);
}

/**
 * Play a context directly, only supported on context player
 *
 * @param {Object} context Context object that CP can deal with.
 * @param {Object} playOptions An object with play options.
 * @param {Function=} opt_callback Optional callback function.
 */
function playContext(context, playOptions, opt_callback) {
  playerApi.playContext(context, playOptions, opt_callback);
}

/**
 * Request to play a context through the playlist resolver.
 *
 * @param {string} contextUri Context URI.
 * @param {Object} playOptions An object with play options.
 * @param {Function=} opt_callback Optional callback function.
 */
function playFromPlaylistResolver(contextUri, playOptions, opt_callback) {
  // For playlist playback we don't need to support ranges, so we'll
  // always just pick the first.
  var skipToIndex = {};

  // Todo: This should be cleaned up, we don't need a list of uids because we
  // never need ranges now. We do that stuff using pages.
  if (playOptions.uids) {
    skipToIndex.track_uid = playOptions.uids[0];
  } else if (playOptions.uid) {
    skipToIndex.track_uid = playOptions.uid;
  }

  // Todo: This should be cleaned up, we don't need a list of uids because we
  // never need ranges now. We do that stuff using pages.
  if (playOptions.uris) {
    skipToIndex.track_uri = playOptions.uris[0];
  } else if (playOptions.trackUri) {
    skipToIndex.track_uri = playOptions.trackUri;
  }

  var preparePlayOptions = {};
  if (Object.keys(skipToIndex).length) {
    preparePlayOptions.skip_to_index = skipToIndex;
  }
  if (shuffleMode.isEnabled()) {
    preparePlayOptions.player_options_override = {
      shuffling_context: true
    };
  }

  var playOrigin = {
    view_uri: playOptions.context,

    // fills in source_start & source_end
    // example values: browse, playlist-owned-by-self-non-collaborative
    feature_identifier: playOptions.source,

    // fills in referer
    // example values: spotify:app:browse
    referrer_identifier: playOptions.contextPlayerReferrer,

    // fills in referrer version
    feature_version: playOptions.referrerVersion
  };

  var options = {
    prepare_play_options: preparePlayOptions,
    play_origin: playOrigin
  };

  playlistResolver.play(contextUri, options, opt_callback);
}

/**
 * Request to play a single track.
 *
 * @param {string} uri The track URI.
 * @param {Object} playOptions An object with play options.
 * @param {Function=} opt_callback Optional callback function.
 */
function playTrack(uri, playOptions, opt_callback) {
  playOptions.context = uri;
  playOptions.track = uri;
  playOptions.index = 0;
  playTrackUris([uri], null, playOptions, opt_callback);
}

/**
 * Request to play tracks found in the list of rows.
 *
 * @param {LiveList} rows A live list of rows with tracks.
 * @param {Object} playOptions An object with play options.
 * @param {Function=} opt_callback Optional callback function.
 */
function playRows(rows, playOptions, opt_callback) {
  var index = playOptions.index;
  var range = playOptions.range;

  if (index === null && range) {
    dataUtils.getFirstPlayableRow(rows, range, function (error, index) {
      if (error && opt_callback) return opt_callback(error);
      if (error) {
        if (global.console) console.error(error);
        return;
      }

      var trackUris = dataUtils.getTracksFromRows(rows);
      playOptions.index = index;

      playTrackUris(trackUris, rows.keys, playOptions, opt_callback);
    });
  } else {
    var trackUris = dataUtils.getTracksFromRows(rows);
    playTrackUris(trackUris, rows.keys, playOptions, opt_callback);
  }
}

/**
 * Request to play artist context.
 *
 * @param {string} contextUri Context URI.
 * @param {Function=} opt_callback Optional callback function.
 */
function playFromArtist(uri, playOptions, opt_callback) {
  shouldUseArtistContextPlayerResolver(function (playFromArtistResolver) {
    if (playFromArtistResolver) {
      artistResolver.getContext(uri, playOptions, function (error, data) {
        if (error && opt_callback) return opt_callback(error);
        if (error) {
          if (global.console) console.error(error);
          return;
        }

        var contextObject = data.body;
        playContext(contextObject, playOptions, opt_callback);
      });
    } else {
      // If artist resolver is not enabled yet use regular resolver
      playFromResolver(uri, playOptions, opt_callback);
    }
  });
}

/**
 * Request to update the player with tracks from the provided rows list.
 * This will update the player silently without interrupting playback.
 *
 * @param {LiveList} rows A live list of rows with tracks.
 * @param {Object} playOptions An object with play options.
 * @param {Function=} opt_callback Optional callback function.
 */
function updateWithRows(rows, playOptions, opt_callback) {

  var tracks = dataUtils.getTracksFromRows(rows);

  // Context Player matches on UIDs so let's not provide index
  delete playOptions.index;
  playerApi.update(tracks, rows.keys, playOptions, opt_callback);
}

/**
 * Request to update the player with tracks from the cosmos track resolver.
 * This will update the player silently without interrupting playback.
 *
 * @param {Object} playOptions An object with play options.
 * @param {Function=} opt_callback Optional callback function.
 */
function updateWithResolver(playOptions, opt_callback) {

  /*
    Todo:
    When currently playing from tracklist, keys need to be passed on to the new playlist and folder resolver
  */

  cosmosPlayer.update(playOptions, null, opt_callback);
}

/**
 * Request to pause the playback.
 *
 * @param {Function=} opt_callback Optional callback function.
 */
function pause(opt_callback) {
  playerApi.pause(opt_callback);
}

/**
 * Request to resume the playback.
 *
 * @param {Function=} opt_callback Optional callback function.
 */
function resume(opt_callback) {
  playerApi.resume(opt_callback);
}

/**
 * Request to skip to the previous track.
 *
 * @param {Function=} opt_callback Optional callback function.
 */
function skipPrev(opt_callback) {
  cosmosPlayer.skipPrev(opt_callback);
}

/**
 * Request to skip to the next track.
 *
 * @param {Function=} opt_callback Optional callback function.
 */
function skipNext(opt_callback) {
  cosmosPlayer.skipNext(opt_callback);
}

exports.playTrack = playTrack;
exports.playRows = playRows;
exports.playFromResolver = playFromResolver;
exports.playContext = playContext;
exports.playFromArtist = playFromArtist;
exports.updateWithRows = updateWithRows;
exports.updateWithResolver = updateWithResolver;
exports.pause = pause;
exports.resume = resume;
exports.skipPrev = skipPrev;
exports.skipNext = skipNext;
exports.playFromPlaylistResolver = playFromPlaylistResolver;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../spotify-shuffle-mode":290,"../util/cosmos":247,"./artist-resolver":222,"./cosmos-player":224,"./data":225,"./player-api":227,"./playlist-resolver":228}],224:[function(require,module,exports){
/**
 * @module spotify-live-models/player/cosmos-player
 * @private
 */
'use strict';

var cosmos = require('../util/cosmos');

var PLAYER_URI = 'sp://player/v2/main';
var TRACK_RESOLVER_URI = 'hm://track-resolver/v1?uri=';

var deepFillIn = require('mout/object/deepFillIn');
var isStationUri = require('../station').isStationUri;

var ACTIONS = {
  PLAY: 'play',
  PAUSE: 'pause',
  RESUME: 'resume',
  UPDATE: 'update',
  SKIP_PREV: 'skip_prev',
  SKIP_NEXT: 'skip_next'
};

/**
 * Request to play a list of URIs or a resolvable context URI.
 *
 * @param {Object} options Object with options and data of what to play.
 * @param {?Array} opt_trackUris List of track URIs to play.
 * @param {Function=} opt_callback Callback function.
 */
function play(options, opt_trackUris, opt_callback) {
  if (opt_trackUris) options.tracks = opt_trackUris;
  var state = createCosmosState(options.context, options);

  state.action = ACTIONS.PLAY;

  postPlayerState(state, opt_callback);
}

/**
 * Request to pause the playback.
 *
 * @param {Function=} opt_callback Optional callback function.
 */
function pause(opt_callback) {
  cosmos.post({ url: PLAYER_URI, body: { action: ACTIONS.PAUSE } }, opt_callback);
}

/**
 * Request to resume the playback.
 *
 * @param {Function=} opt_callback Optional callback function.
 */
function resume(opt_callback) {
  cosmos.post({ url: PLAYER_URI, body: { action: ACTIONS.RESUME } }, opt_callback);
}

/**
 * Request to skip playback back.
 *
 * @param {Function=} opt_callback Optional callback function.
 */
function skipPrev(opt_callback) {
  cosmos.post({ url: PLAYER_URI, body: { action: ACTIONS.SKIP_PREV } }, opt_callback);
}

/**
 * Request to skip playback forward.
 *
 * @param {Function=} opt_callback Optional callback function.
 */
function skipNext(opt_callback) {
  cosmos.post({ url: PLAYER_URI, body: { action: ACTIONS.SKIP_NEXT } }, opt_callback);
}

/**
 * Request to update the player with the new state. This will not interupt
 * playback if the context is the same.
 *
 * @param {Object} state State object for the cosmos player.
 * @param {?Array} opt_trackUris List of track URIs to play.
 * @param {Function=} opt_callback Optional callback function.
 */
function update(options, opt_trackUris, opt_callback) {
  if (opt_trackUris) options.tracks = opt_trackUris;
  var state = createCosmosState(options.context, options);

  state.action = ACTIONS.UPDATE;

  // Up the index by one, since the comsos player expects the next track when updating to a different context.
  state.index++;

  // If the new index is past the end of the list, make it the last index of
  // the list. This will make it work for the case where the list only contains
  // a single track. For lists containing more tracks, this will make the player
  // continue playing the current track as a lone track (without any context)
  // and then pick up the right context with the right highlight and all after
  // that track has played.
  if (state.tracks && state.tracks.length <= state.index) {
    state.index = state.tracks.length - 1;
  }

  postPlayerState(state, opt_callback);
}

/**
 * Post the state object to the cosmos player.
 *
 * @param {Object} state State object for the cosmos player.
 * @param {Function=} opt_callback Optional callback function.
 */
function postPlayerState(state, opt_callback) {
  if (state.context) {
    cosmos.sanitizeURL(state.context, function (error, uri) {
      if (error) return opt_callback(error);
      state.context = uri;

      if (!state.tracks) {
        if (/^spotify:user:[^:]+:(playlist:)/.test(uri)) state.next_page_url = uri;else state.next_page_url = TRACK_RESOLVER_URI + encodeURI(uri);

        // Set tracks to an empty array since cosmos player on core js expects it.
        // REMOVE ME! 2014-10-24, see KM-3914.
        state.tracks = [];
      }

      cosmos.post({ url: PLAYER_URI, body: state }, opt_callback);
    });
  } else {
    cosmos.post({ url: PLAYER_URI, body: state }, opt_callback);
  }
}

/**
 * Request to get the current state of the cosmos player.
 *
 * @param {Function} callback Callback function.
 */
function getState(callback) {
  cosmos.get({ url: PLAYER_URI }, function (error, response) {
    if (error) return callback(error);
    callback(null, response.body);
  });
}

/**
 * Request to get the current state of the cosmos player whenever the player
 * changes.
 *
 * @param {Function} callback Callback function.
 *
 * @return {Object} An object with a method to unsubscribe.
 */
function subscribe(callback) {
  var subscription = cosmos.subscribe({ url: PLAYER_URI }, function (error, response) {
    if (error) return callback(error);
    callback(null, response.body);
  });

  return {
    unsubscribe: function unsubscribe() {
      if (!subscription) return;
      subscription.cancel();
      subscription = null;
    }
  };
}

/**
 * Create a state object for the cosmos player.
 *
 * @param {string} contextUri  Context URI.
 * @param {Object} playOptions An object with play options.
 *
 * @return {Object} An object with state in a format that the cosmos player understands.
 */
function createCosmosState(contextUri, playOptions) {

  var isStationContext = isStationUri(contextUri);
  var defaultState = {
    context: null,
    index: null,
    track: null,
    options: {
      can_repeat: true,
      can_shuffle: !isStationContext,
      can_skip_prev: !isStationContext,
      can_skip_next: true,
      can_seek: true,
      use_dmca_rules: false,
      repeat: false,
      repeat_track: false,
      shuffle_context: false
    },
    play_origin: {
      source: 'unknown',
      reason: 'unknown',
      referrer: 'unknown',
      referrer_version: 'unknown',
      referrer_vendor: 'unknown'
    }
  };

  var state = {
    context: contextUri,
    play_origin: {
      source: playOptions.source,
      reason: playOptions.reason,
      referrer: playOptions.referrer,
      referrer_version: playOptions.referrerVersion
    }
  };

  if ('tracks' in playOptions) state.tracks = playOptions.tracks;
  if ('index' in playOptions) state.index = playOptions.index;
  if ('track' in playOptions) state.track = playOptions.track;

  deepFillIn(state, defaultState);

  return state;
}

exports.play = play;
exports.pause = pause;
exports.resume = resume;
exports.skipPrev = skipPrev;
exports.skipNext = skipNext;
exports.update = update;
exports.getState = getState;
exports.subscribe = subscribe;

},{"../station":239,"../util/cosmos":247,"mout/object/deepFillIn":383}],225:[function(require,module,exports){
/**
 * @module spotify-live-models/player/data
 * @private
 */
'use strict';

var live = require('../../spotify-live');
var Range = require('../../spotify-range2');

var playerApi = require('./player-api');

/**
 * Default values for play options.
 */
var PLAY_OPTIONS_DEFAULTS = {
  page: null,
  uid: null,
  trackUri: null,
  index: null,
  source: 'unknown',
  reason: 'unknown'
};

/**
 * Get the first playable row from range in a list of rows.
 *
 * @param {LiveList} rows A live list of rows.
 * @param {Range} range A range object.
 * @param {Function} callback A callback where the second argument is the
 *     index of the first playable row. If no playable track is found, the
 *     index will be the first index in the range.
 */
function getFirstPlayableRow(rows, range, callback) {
  var index = range.start;

  isRowPlayable(rows.get(index), function playableCallback(error, playable) {
    if (playable) return callback(null, index);
    if (index === range.end - 1) return callback(null, range.start);

    isRowPlayable(rows.get(++index), playableCallback);
  });
}

/**
 * Check if the row is playable.
 *
 * @param {LiveObject?} row A row live object. If this is falsy, the callback
 *     is returned with false immediately.
 * @param {Function} callback A callback where the second argument is the
 *     boolean flag for playable. The callback may run synchronously or
 *     asynchronously.
 */
function isRowPlayable(row, callback) {
  if (!row) return callback(null, false);

  row.query('track(playable)', function (error, data) {
    if (error) return callback(error);
    callback(null, data.track.playable);
  }, live.ASAP);
}

/**
 * Get options for play actions based on a data object and other state
 * like referrer set on the player or application object.
 *
 * @param {Object} data A data object.
 * @param {Function} callback A callback, where the second argument is a data
 *     object with the options.
 */
function getPlayOptions(data, callback) {
  getReferrer(function (error, viewUri, baseUri) {
    if (error) return callback(error);

    Object.keys(PLAY_OPTIONS_DEFAULTS).forEach(function (key) {
      if (data[key] === undefined) {
        data[key] = PLAY_OPTIONS_DEFAULTS[key];
      }
    });

    if (data.range) {
      data.range = new Range(data.range[0], data.range[1]);
    }

    data.referrer = viewUri;
    data.contextPlayerReferrer = baseUri;
    data.referrerVersion = getReferrerVersion();

    callback(null, data);
  });
}

/**
 * Get a list of track URIs from a live list of rows.
 *
 * @param {LiveList} rows A live list of rows.
 *
 * @return {Array.<string>} Array of track URIs. If a row is not set in the list,
 *     or if the row doesn't have a track object with a URI, an 'undefined' value
 *     will be put in that position in the output array.
 */
function getTracksFromRows(rows) {
  return rows.map(function (row) {
    var track = row && row.get('track');
    return track && track.uri;
  });
}

/**
 * Get the latest player state, in the format of the player live model.
 *
 * @param {Function} callback Callback function.
 */
function getPlayerState(callback) {
  playerApi.getState(callback);
}

/**
 * Subscribe to the cosmos player to get the latest player state,
 * in the format of the player live model.
 *
 * @param {Function} callback Callback function.
 * @return {Object} An object with a method to unsubscribe.
 */
function subscribeForPlayerState(callback) {
  return playerApi.subscribe(callback);
}

/**
 * Get the referrer for the player. This is usually the path back to the app in
 * the state where the playback started. It can be set by the user in the `referrer`
 * property of the player live object. If nothing is set there, it will generate
 * the referrer by combining the app URI with the app arguments.
 *
 * @param {Function} callback A callback where the second argument is the referrer.
 */
function getReferrer(callback) {
  // 'referrer' corresponds to fullURI below
  var referrer = live('spotify:player').get('referrer');
  var referrerBaseUri = live('spotify:player').get('referrerBaseUri');
  if (referrer) {
    if (!referrerBaseUri) {
      console.warn('referrer field is set on the player model (' + referrer + '), but referrerBaseUri isn\'t');
    }
    return callback(null, referrer, referrerBaseUri || '');
  }

  live('spotify:application').get('appURI', 'arguments', function (error, uri, args) {
    if (error) return callback(error);
    var fullUri = args ? uri + ':' + args : uri;
    callback(null, fullUri, uri);
  });
}

/**
 * Get the referrer version. This is usually the version of the app. It can be set
 * by the user in the `version` property of the application live object. If nothing
 * is set there, it will use the default version '0.0.0'.
 *
 * @return {string} The version string.
 */
function getReferrerVersion() {
  return live('spotify:application').get('version') || '0.0.0';
}

exports.getReferrer = getReferrer;
exports.getReferrerVersion = getReferrerVersion;
exports.getFirstPlayableRow = getFirstPlayableRow;
exports.isRowPlayable = isRowPlayable;
exports.getPlayOptions = getPlayOptions;
exports.getTracksFromRows = getTracksFromRows;
exports.getPlayerState = getPlayerState;
exports.subscribeForPlayerState = subscribeForPlayerState;

},{"../../spotify-live":251,"../../spotify-range2":289,"./player-api":227}],226:[function(require,module,exports){
(function (global){
/**
 * @module spotify-live-models/player
 */
'use strict';

var live = require('../../spotify-live');
var shuffleMode = require('../../spotify-shuffle-mode');
var URI = require('spotify-liburi');
var cosmos = require('spotify-cosmos-api');

var playerApi = require('./player-api');
var playbackControl = require('./control');
var dataUtils = require('./data');
var updatesUtils = require('./updates');
var sortUriUtils = require('../../spotify-live-sort-uri');
var filterUriUtils = require('../../spotify-live-filter-uri');
var createStationPlayContext = require('../station/create-play-context');
var createStationPlayOptions = require('../station/create-play-options');
var isStationUri = require('../station').isStationUri;

var TYPE_TRACK = 'track';
var TYPE_TRACK_RESOLVER = 'track-resolver';
var TYPE_ROWS = 'rows';
var TYPE_CP_RESOLVER_PLAYLIST = 'context-player-resolver-playlist';
var TYPE_CP_CONTEXT = 'context-player-context';
var TYPE_CONTEXT_OBJECT = 'context-object';
var TYPE_STATION_CONTEXT = 'context-station-context';
var TYPE_CP_ARTIST_CONTEXT = 'context-player-artist';
var TYPE_CONTEXT_EPISODE = 'context-episode';
var VARIANT_KEY = 'list-variant-';
var lastPlayRequestId = 0;

// This data store will keep context objects keyed by context URI. The values
// are context objects in the format of spotify-player Context:
// https://ghe.spotify.net/spotify-sdk/spotify-player/blob/master/lib/v2/types.js#L164
var contextDataStore = {};

/**
 * Handler for when properties are requested from the model.
 *
 * @param {LiveObject} model The player live object.
 */
function onWait(model) {
  updateState(model);
}

/**
 * Handler for when the model needs to be updated by polling the player.
 *
 * @param {LiveObject} model The player live object.
 */
function onSync(model) {
  updateState(model);
}

/**
 * Handler for when the real player is updated.
 *
 * @param {Error?} error An error object, or null.
 * @param {Object} data Data object in the format of this live model.
 */
function onPlayerStateUpdate(error, data) {
  if (error) {
    if (global.console) console.error(error);
    return;
  }
  var model = live('spotify:player');
  if (model.get('pending')) return;
  model.update(data);
}

/**
 * Handler for when the model receives the 'update' event.
 *
 * @param {LiveObject} model The player live object.
 */
function onUpdate(model) {
  var index = model.get('index') && model.get('index').get('track');
  if (index != null) {
    updatesUtils.setPlayingIndex(index);
  }

  updatesUtils.clean(model);
}

/**
 * Handler for when the model receives the 'play' event.
 *
 * @param {LiveObject} model The player live object.
 * @param {Object} event The event object with data about what to play.
 *     Can contain the following properties:
 *       `context` (string, context URI)
 *       `index` (number, index within context to play)
 *       `uid` (string, uid within context to play)
 *       `page` (number, index for the context player page)
 *       `range` (array of two values, start and end index)
 *       `uids` (array of uids representing an index or a range)
 *       `uris` (array of uris connected to the uids)
 *       `source` (string)
 *       `reason` (string)
 */
function onPlay(model, event) {
  var context = event.context;
  if (!context) return;

  // The `index` property might be `null`, which should mean that no specific
  // index should be played.
  if (typeof event.index !== 'number') {
    delete event.index;
  }

  // [SHUFFLE] If we are in shuffle mode and we get a request for a specific
  // track, refuse to play.
  if (shuffleMode.isEnabled()) {
    if (event.hasOwnProperty('index') || event.hasOwnProperty('uid')) {
      cosmos.resolver.post({
        url: 'sp://messages/v1/container/user-message',
        body: {
          description: 'Track cannot be played because "shuffle mode" is enabled',
          id: 'shuffle-unplayable-track'
        }
      });
      return;
    }
  }

  var playRequestId = ++lastPlayRequestId;

  // Update the model optimistically
  model.update(playerApi.addContext({
    isPlaying: true,
    isPaused: false,
    index: event.index === undefined ? null : { page: 0, track: event.index },
    track: event.trackUri === undefined ? null : { uri: event.trackUri },
    contextUpdatedCrossFrame: false
  }, context));

  // Get options for the play action based on event data and other state
  // Todo: getPlayOptions creates options that fit the cosmos/v1 implementation.
  // We could probably do this a bit later from cosmos-player.js
  dataUtils.getPlayOptions(event, function (error, options) {
    if (error || !options.context) return updateState(model); // Revert state

    // Canonical contexts can have sorted and/or filtered state that needs
    // to be respected client-wide. We therefore query for the correct variant
    // to be played.
    // For spotify:internal uris on the other hand, we don't look for variants.
    // This would also be the case for contexts that already represent variants.
    // Please see docs for details.
    if (/^spotify:internal:/.test(options.context)) {
      playWithOptions(model, playRequestId, options);
      return;
    }

    if (live('spotify:list-variant').get('implemented')) {
      live(options.context).query('listVariant(currentUri, sortUri)', function (error, data) {
        if (error) return updateState(model); // Revert state

        // Abort if a new play request has happened since this request started
        if (lastPlayRequestId !== playRequestId) {
          return;
        }

        options.context = data.listVariant.currentUri;

        playWithOptions(model, playRequestId, options);
      });
    } else {
      playWithOptions(model, playRequestId, options);
    }
  });
}

/**
 * Handler for when the model receives the 'pause' event.
 *
 * @param {LiveObject} model The player live object.
 */
function onPause(model) {
  if (model.get('isPlaying') === false || model.get('isPaused') === true) {
    return;
  }

  model.update({ isPaused: true });

  playbackControl.pause(function (error) {
    if (error) return model.update({ isPaused: false });
  });
}

/**
 * Handler for when the model receives the 'resume' event.
 *
 * @param {LiveObject} model The player live object.
 */
function onResume(model) {
  if (model.get('isPlaying') === true && model.get('isPaused') === false) {
    return;
  }

  model.update({ isPaused: false });

  playbackControl.resume(function (error) {
    if (error) return model.update({ isPaused: true });
  });
}

/**
 * Handler for when the model receives the 'skip-previous' event.
 *
 * @param {LiveObject} model The player live object.
 */
function onSkipPrev() {
  // Skip prev often starts playback, but not when you're on the first track.
  // Therefor no optimistic update of 'playing' here.
  playbackControl.skipPrev();
}

/**
 * Handler for when the model receives the 'skip-next' event.
 *
 * @param {LiveObject} model The player live object.
 */
function onSkipNext() {
  // Skip next often starts playback, but not when you're on the last track.
  // Therefor no optimistic update of 'playing' here.
  playbackControl.skipNext();
}

/**
 * Handler for when the model receives the 'update-context' event.
 *
 * @param {LiveObject} model The player live object.
 * @param {Object} event An event object with a `context` property (string).
 */
function onUpdateContext(model, event) {
  var contextUri = event.context;
  if (!contextUri) return;

  var context = live(contextUri);
  var playRequestId = ++lastPlayRequestId;

  var currentIndex = model.get('index') && model.get('index').get('track');
  var currentContext = model.get('variant');

  // Update player model optimistically with context and no index.
  // We can't know the index yet, so we must set it to nothing to
  // not get wrong highlights.
  model.update(playerApi.addContext({
    index: null,
    pending: true,
    contextUpdatedCrossFrame: false
  }, contextUri));

  // We need the rows list to be able to get the index and play the list.
  live(contextUri).get('rows', function (error, rowsList) {
    if (error) {
      model.update({ pending: false });
      if (global.console) console.error(error);
      return;
    }

    var options = { context: contextUri };
    dataUtils.getPlayOptions(options, function (error, options) {

      // Abort if a new play request has happened since this request started
      if (lastPlayRequestId !== playRequestId) {
        return;
      }

      // Store which row is currently playing, so that we can get the index
      // of the playing row in another list.
      updatesUtils.setPlayingIndex(currentIndex, currentContext.get('rows'));

      // Find the index of the currently playing track in new list, to do an
      // optimistic update. This is not optional, since the actual player only appends
      // the next context and will not send an update until the next skip.
      // (If it does, because of play/pause for example, it will still report the old
      // list that we're not showing in the UI)

      // At the same time, find the index that we will use to actually update the playback
      var updateIndices = updatesUtils.getPlayingAndUpdateIndicesInList(rowsList);
      options.index = updateIndices.update;
      if (updateIndices.playing != null) model.update({ index: { page: 0, track: updateIndices.playing } });

      if (model.get('playOrigin') && model.get('playOrigin').get('referrerIdentifier') !== options.referrer) {
        model.update({ contextUpdatedCrossFrame: true });
      }

      playbackControl.updateWithRows(rowsList, options, function (error) {
        model.update({ pending: false });
        if (error) return updateState(model); // Revert state
      });

      updatesUtils.listen(rowsList, options, function (options) {
        playbackControl.updateWithRows(rowsList, options, function (error) {
          if (error) return updateState(model); // Revert state
        });
      });
    });
  });
}

/**
 * Request to start playback based on passed options.
 * If the request fails, it will revert the player model to the latest
 * state.
 *
 * @param {LiveObject} model The player live object.
 * @param {string} playRequestId The ID for this request.
 * @param {Object} options Object with options and data of what to play.
 */
function playWithOptions(model, playRequestId, options) {
  var contextUri = options.context;
  var resolverType = getPlaybackResolverType(contextUri);

  if (resolverType === TYPE_TRACK) {
    playbackControl.playTrack(contextUri, options, function (error) {
      if (error) return updateState(model); // Revert state
    });
  } else if (resolverType === TYPE_TRACK_RESOLVER) {
      playbackControl.playFromResolver(contextUri, options, function (error) {
        if (error) return updateState(model); // Revert state
      });
    } else if (resolverType === TYPE_ROWS) {
        var isSortedList = sortUriUtils.isValid(contextUri);

        // If it's a sorted list that is played by rows, we want to request all the track
        // URIs of the sorted list and then play that list of tracks. We will wait for all
        // tracks to be fetched and sorted, to allow clicking play on a media object in
        // Browse for example and have it play the stored sorted variant of the playlist.
        if (isSortedList) {
          getSortedRows(contextUri, function (error, rowsList) {
            if (error) return updateState(model); // Revert state

            // Abort if a new play request has happened since this request started
            if (lastPlayRequestId !== playRequestId) {
              return;
            }

            playRows(model, rowsList, options);
          });

          // Play any other context from the rows list
        } else {
            live(contextUri).query('rows(track(uri))', function (err) {
              if (!err && lastPlayRequestId === playRequestId) {
                playRows(model, live(contextUri).get('rows'), options);
              }
            });
          }
      } else if (resolverType === TYPE_CP_RESOLVER_PLAYLIST) {
        playbackControl.playFromPlaylistResolver(contextUri, options, function (error) {
          if (error) return updateState(model); // Revert state
        });
      } else if (resolverType === TYPE_CONTEXT_OBJECT) {
          var context = contextDataStore[contextUri];
          playbackControl.playContext(context, options, function (error) {
            if (error) return updateState(model); // Revert state
          });
        } else if (resolverType === TYPE_CP_CONTEXT) {

            var context = {
              url: 'context://' + contextUri,
              entity_uri: contextUri
            };

            playbackControl.playContext(context, options, function (error) {
              if (error) return updateState(model); // Revert state
            });
          } else if (resolverType === TYPE_STATION_CONTEXT) {
              var station = live(contextUri);
              station.query('rows', function (err) {
                if (!err) {
                  playbackControl.playContext(createStationPlayContext(station), createStationPlayOptions(station, options), function (error) {
                    if (error) return updateState(model); // Revert state
                  });
                }
              });
            } else if (resolverType === TYPE_CP_ARTIST_CONTEXT) {
                playbackControl.playFromArtist(contextUri, options, function (error) {
                  if (error) return updateState(model); // Revert state
                });
              } else if (resolverType === TYPE_CONTEXT_EPISODE) {
                  var episodeQueryTimeout = 3000;
                  live(contextUri).query('episode(name, manifestId, show(name))', function (error, data) {
                    if (error) return updateState(model); // Revert state

                    var episode = data.episode;
                    var context = {
                      'uri': contextUri,
                      'pages': [{
                        'tracks': {
                          'uri': contextUri,
                          'metadata': {
                            'title': episode.name,
                            'album_title': episode.show.name,
                            'media.type': 'video',
                            'media.manifest_id': episode.manifestId
                          }
                        }
                      }],
                      'restrictions': {
                        'disallow_skipping_prev_reasons': ['disallow-video'],
                        'disallow_skipping_next_reasons': ['disallow-video'],
                        'disallow_toggling_repeat_context_reasons': ['disallow-video'],
                        'disallow_toggling_repeat_track_reasons': ['disallow-video'],
                        'disallow_toggling_shuffle_reasons': ['disallow-video']
                      }
                    };

                    if (!options.player_options_override) {
                      options.player_options_override = {};
                    }
                    // Avoid repeating context when playing episode
                    // This might be removed in future when we have proper shows support
                    options.player_options_override.repeating_context = false;
                    options.player_options_override.repeating_track = false;

                    playbackControl.playContext(context, options, function (error) {
                      if (error) return updateState(model); // Revert state
                    });
                  }, episodeQueryTimeout);
                }
}

/**
 * Request to start playback based on passed rows list and options.
 * If the request fails, it will revert the player model to the latest
 * state.
 *
 * @param {LiveObject} model The player live object.
 * @param {LiveList} rowsList The rows live list.
 * @param {Object} options Object with options and data of what to play.
 */
function playRows(model, rowsList, options) {
  playbackControl.playRows(rowsList, options, function (error) {
    if (error) return updateState(model); // Revert state

    updatesUtils.listen(rowsList, options, function (options) {
      playbackControl.updateWithRows(rowsList, options, function (error) {
        if (error) return updateState(model); // Revert state
      });
    });
  });
}

/**
 * Get the type of playback resolver to use for a certain context URI.
 *
 * @param {string} contextUri Context URI.
 *
 * @return {string} A resolver type. One of 'track-resolver', 'rows' or 'track'.
 */
function getPlaybackResolverType(contextUri) {
  var contextType = URI.from(contextUri).type;

  var isTrack = contextType === URI.Type.TRACK;
  var isPlaylist = contextType === URI.Type.PLAYLIST;
  var isPlaylistFolder = contextType === URI.Type.FOLDER;
  var isArtist = contextType === URI.Type.ARTIST;
  var isSortedList = sortUriUtils.isValid(contextUri);
  var isFilteredList = filterUriUtils.isValid(contextUri);
  var isStation = isStationUri(contextUri);
  var isEpisode = contextType === URI.Type.EPISODE;

  if (isTrack) return TYPE_TRACK;

  if (isPlaylist) {
    return TYPE_CP_RESOLVER_PLAYLIST;
  }

  if (isPlaylistFolder) {
    return TYPE_CP_CONTEXT;
  }

  if (isStation) return TYPE_STATION_CONTEXT;

  var originContextType, originUri;
  if (isSortedList) {
    originUri = sortUriUtils.parse(contextUri).originUri;

    // If the sorted URI is in fact a filtered URI, the origin URI that _that_ is based on
    // needs to be taken into account when judging the originContextType.
    if (filterUriUtils.isValid(originUri)) originUri = filterUriUtils.parse(originUri).originUri;

    originContextType = URI.from(originUri).type;

    if (originContextType === URI.Type.PLAYLIST) {
      return TYPE_CP_RESOLVER_PLAYLIST;
    }

    return TYPE_ROWS;
  }

  if (isFilteredList) {
    // If the sorted URI is in fact a filtered URI, the origin URI that _that_ is based on
    // needs to be taken into account when judging the originContextType.
    originUri = filterUriUtils.parse(contextUri).originUri;
    originContextType = URI.from(originUri).type;

    if (originContextType === URI.Type.PLAYLIST) {
      return TYPE_CP_RESOLVER_PLAYLIST;
    }

    return TYPE_ROWS;
  }

  var contextData = contextDataStore[contextUri];
  if (contextData) {
    return TYPE_CONTEXT_OBJECT;
  }

  // If it's a different URI, check if we have rows
  var rowsList = live(contextUri).get('rows');
  if (rowsList && rowsList.length) {
    return TYPE_ROWS;
  }

  // If it's an artist context but context object or rows were not defined
  if (isArtist) {
    return TYPE_CP_ARTIST_CONTEXT;
  }

  if (isEpisode) {
    return TYPE_CONTEXT_EPISODE;
  }

  // If no rows are available, final hope is on the track resolver
  return TYPE_TRACK_RESOLVER;
}

/**
 * Get the stored variant of the list. For example, if a user has sorted a
 * playlist, that is stored in the client, so playing the playlist from another
 * place should play the stored sorted variant.
 *
 * @param {string} listUri The normal list URI.
 * @param {Function} callback Callback function where second argument is the
 *     URI of the variant to play. This could be the original list URI.
 */
function getStoredSortUri(listUri, callback) {
  live('spotify:client').query('containerFeatures(clientStorage)', function (error, data) {
    if (error) return callback(null, listUri);

    var defaultUri = listUri;

    if (data.containerFeatures.clientStorage) {
      var key = VARIANT_KEY + listUri;
      var clientStorage = live('spotify:client-storage');

      // Check whether the client storage live model has been registered.
      // This is so that we can check this without making this a
      // breaking change. Would be great with a future live API to see
      // if someone has implemented a specific model.
      if (clientStorage.get('implemented')) {
        clientStorage.get(key, function (error, variant) {
          if (error) return callback(null, defaultUri);

          // Respond with the sort variant if it's a valid sort URI
          if (variant && sortUriUtils.isValid(variant) || variant === listUri) {
            return callback(null, variant);
          }

          // Fall back to the regular playlist URI if it's not valid
          callback(null, defaultUri);
        });
      } else {

        // Fall back to the regular playlist URI if client storage is not implemented
        callback(null, defaultUri);
      }
    } else {
      callback(null, defaultUri);
    }
  });
}

/**
 * Get the live list for the rows of the sorted URI.
 *
 * @param {string} sortUri The URI of the sorted list.
 * @param {Function} callback Callback function where second argument is the
 *     sorted live list.
 */
function getSortedRows(sortUri, callback) {
  var playlistUri = sortUriUtils.getOriginUri(sortUri);

  // Get the rows list for the regular playlist.
  // We could have queried for the track of every row, but by not querying we
  // avoid the conversions from live objects to plain objects.
  live(playlistUri).get('rows', function (error, rows) {
    if (error) return callback(error);

    // Get the live models for all rows.
    rows.get(0, rows.length, function (error) {
      if (error) return callback(error);

      // When we know we have the rows, we can safely sort the list
      live(sortUri).get('rows', function (error, rowsList) {
        if (error) return callback(error);

        // Finally return the sorted rows list
        callback(null, rowsList);
      });
    });
  });
}

/**
 * Update the player model with the current data of the cosmos player model.
 *
 * @param {LiveObject} model The player live object.
 */
function updateState(model) {
  dataUtils.getPlayerState(function (error, data) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }
    model.update(data);
  });
}

var regExp = exports.matches = /^spotify:player$/;
var registered;
var playerSubscription;

exports.register = function () {
  if (registered) return;
  registered = true;

  live.subscribe(regExp, 'play', onPlay);
  live.subscribe(regExp, 'pause', onPause);
  live.subscribe(regExp, 'resume', onResume);
  live.subscribe(regExp, 'skip-previous', onSkipPrev);
  live.subscribe(regExp, 'skip-next', onSkipNext);
  live.subscribe(regExp, 'update-context', onUpdateContext);
  live.subscribe(regExp, 'update', onUpdate);
  live.subscribe(regExp, 'wait', onWait);
  live.subscribe(regExp, 'sync-position', onSync);

  playerSubscription = dataUtils.subscribeForPlayerState(onPlayerStateUpdate);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  live.unsubscribe(regExp, 'play', onPlay);
  live.unsubscribe(regExp, 'pause', onPause);
  live.unsubscribe(regExp, 'resume', onResume);
  live.unsubscribe(regExp, 'skip-previous', onSkipPrev);
  live.unsubscribe(regExp, 'skip-next', onSkipNext);
  live.unsubscribe(regExp, 'update-context', onUpdateContext);
  live.unsubscribe(regExp, 'update', onUpdate);
  live.unsubscribe(regExp, 'wait', onWait);
  live.unsubscribe(regExp, 'sync-position', onSync);

  playerSubscription.unsubscribe();
  playerSubscription = null;
};

exports.setContextData = function (contextUri, contextData) {
  contextDataStore[contextUri] = contextData;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../spotify-live":251,"../../spotify-live-filter-uri":208,"../../spotify-live-sort-uri":249,"../../spotify-shuffle-mode":290,"../station":239,"../station/create-play-context":240,"../station/create-play-options":241,"./control":223,"./data":225,"./player-api":227,"./updates":229,"spotify-cosmos-api":416,"spotify-liburi":426}],227:[function(require,module,exports){
(function (global){
/**
 * @module spotify-live-models/player/player-api
 * @private
 */
'use strict';

var dataUtils = require('./data');
var cosmosUtil = require('../util/cosmos');

var live = require('../../spotify-live');
var sortUriUtils = require('../../spotify-live-sort-uri');
var filterUriUtils = require('../../spotify-live-filter-uri');

var PlayerApi = require('spotify-player/lib/v2');
var cosmos = require('spotify-cosmos-api');
var shuffleMode = require('../../spotify-shuffle-mode');

var TRACK_RESOLVER_URI = 'hm://track-resolver/v2?uri=';

var player;

function getPlayer(callback) {

  if (player) {
    callback(player);
    return;
  }

  // One of a fixed list of features, since this is used for logging. It should
  // be the readable name of the feature, for example "radio", "album", "playlist"
  // and it should be the same for a given feature across platforms.
  // The list is probably this:
  // https://ghe.spotify.net/datainfra/log-parser/blob/master/spotify/log_parser/messages_specs.py#L29
  var featureIdentifier;

  // The version of the feature itself
  var featureVersion;

  var appManifest = global.__spotify && global.__spotify.app_manifest;
  if (appManifest) {
    featureVersion = appManifest.BundleVersion || null;
    featureIdentifier = appManifest.BundleIdentifier || null;
  }

  // Hard coded overwrites for apps where we needed to choose a new
  // BundleIdentifier for compat reasons
  // Todo: This is incomplete and would better be fixed by letting features
  // provide values specifically for this. See KM-6973.
  var overwrites = {
    'playlist-desktop': 'playlist'
  };

  if (featureIdentifier && overwrites[featureIdentifier]) featureIdentifier = overwrites[featureIdentifier];

  // The uri of the view that's supposed to show the context where the track is
  // playing, including arguments. That's called referrer in terms of the
  // player live model.
  dataUtils.getReferrer(function (error, viewUri, baseUri) {
    if (error && console) {
      console.error('The player API could not be initialized due to a missing referrer!', error);
      return;
    }

    var options = baseUri ? { referrerIdentifier: baseUri } : null;

    player = new PlayerApi.Player(cosmos.resolver, viewUri, featureIdentifier, featureVersion, options);
    callback(player);

    // The viewUri on this player instance can't ever change, so since we cache
    // it we have to destroy it when arguments change.
    live('spotify:application').on('update', function (data) {
      if ('arguments' in data) {
        player = null;
      }
    });
  });
}

function play(trackUris, opt_rowIds, playOptions, opt_callback) {
  getPlayer(function (player) {
    var tracks = new Array(trackUris.length);
    for (var i = 0; i < trackUris.length; i++) {
      var trackUri = trackUris[i];

      var track = { uri: trackUri };

      // [SHUFFLE]
      // To make the Shuffle rules work correctly, we need to pass album URI
      // and artist URI along with each track.
      if (shuffleMode.isEnabled()) {
        var album = live(trackUri).get('album');
        var artists = live(trackUri).get('artists');
        var albumUri = album && album.uri;
        var artistUri = artists && artists.get(0) && artists.get(0).uri;

        if (albumUri) {
          track.album_uri = albumUri;
        }

        if (artistUri) {
          track.artist_uri = artistUri;
        }
      }

      if (opt_rowIds) {
        track.uid = '' + opt_rowIds[i];
      }

      tracks[i] = track;
    }

    var context = {
      pages: [{
        tracks: tracks
      }],
      metadata: {
        'zelda.context_uri': playOptions.context
      },
      entity_uri: getOriginUri(playOptions.context)
    };

    var options = {};
    if (typeof playOptions.index === 'number') {
      options.skip_to_index = {
        page: 0,
        track: playOptions.index
      };
    }

    if (shuffleMode.isEnabled()) {
      options.player_options_override = {
        'shuffling_context': true
      };
    }

    player.play(context, options, opt_callback);
  });
}

function playContext(context, playOptions, opt_callback) {
  if (shuffleMode.isEnabled()) {
    playOptions.player_options_override = {
      'shuffling_context': true
    };
  }

  if (playOptions.uid || playOptions.uri || playOptions.page) {
    playOptions.skip_to = {};
    if (playOptions.uid) {
      playOptions.skip_to.track_uid = playOptions.uid;
    } else if (playOptions.uri) {
      playOptions.skip_to.track_uri = playOptions.uri;
    }

    // Together with UID send page_index property, so Connect can
    // figure out where to look for a track that needs to
    // be played. (Connect doesn't support UIDs at the moment).
    if (playOptions.page) {
      playOptions.skip_to.page_index = playOptions.page;
    }
  }

  getPlayer(function (player) {
    player.play(context, playOptions || {}, opt_callback);
  });
}

function update(trackUris, opt_rowIds, playOptions, opt_callback) {
  getPlayer(function (player) {

    var length = trackUris.length;
    var tracks = new Array(length);

    // Todo: When currently playing from the new playlist and folder resolver,
    // uids provided by the core resolver need to be used.

    for (var i = 0; i < length; i++) {

      tracks[i] = {
        uri: trackUris[i]
      };
      if (opt_rowIds) tracks[i].uid = '' + opt_rowIds[i];
    }

    var context = {
      pages: [{
        tracks: tracks
      }],
      metadata: {
        'zelda.context_uri': playOptions.context
      },
      entity_uri: getOriginUri(playOptions.context)
    };

    player.update(context, opt_callback);
  });
}

function playFromResolver(contextUri, playOptions, opt_callback) {
  getPlayer(function (player) {
    cosmosUtil.sanitizeURL(contextUri, function (error, uri) {
      if (error) {
        if (opt_callback) opt_callback(error);
        return;
      }

      var context = {
        entity_uri: uri
      };

      var options = null;
      if (typeof playOptions.index === 'number') {
        options = {
          skip_to_index: {
            page: 0,
            track: playOptions.index
          }
        };
      } else if (playOptions.trackUri) {
        options = {
          skip_to_index: {
            track_uri: playOptions.trackUri
          }
        };
      }

      context.pages = [{ page_url: TRACK_RESOLVER_URI + encodeURI(uri) }];

      player.play(context, options, opt_callback);
    });
  });
}

var cancelSubscribe;

function subscribe(callback, options) {
  cancelSubscribe = false;
  options = options || {};

  var subscription;
  getPlayer(function (player) {
    if (cancelSubscribe) return;
    subscription = player.subscribe(function (error, response) {
      if (error) {
        return callback(error);
      }
      callback(null, addContext(response.getJSONBody()));
    }, options);
  });

  return {
    unsubscribe: function unsubscribe() {
      cancelSubscribe = true;
      if (!subscription) return;
      subscription.cancel();
      subscription = null;
    }
  };
}

function getState(callback) {
  getPlayer(function (player) {
    player.getState(function (error, response) {
      if (error) {
        callback(error, null);
      } else {
        callback(null, addContext(response.getJSONBody()));
      }
    });
  });
}

function pause(opt_callback) {
  getPlayer(function (player) {
    player.pause(opt_callback);
  });
}

function resume(opt_callback) {
  getPlayer(function (player) {
    player.resume(opt_callback);
  });
}

function clear() {
  player = null;
}

/**
 * Adds the context to a given player state.
 *
 * @param {Object} data Input data in the format of the cosmos player live model (v2).
 * @param {string?} opt_uri Optional URI to be used in first place.
 * @return {Object} Data object.
 */
function addContext(data, opt_uri) {
  var uri = opt_uri || // We provide the URI of the context.
  data.context_metadata['zelda.context_uri'] || // Best case scenario.
  data.context_uri || // No special context, use the standard one.
  data.track && data.track.uri || // If a track is present, use it.
  null; // Nothing found; there's nothing being played.

  var context = getOriginUri(uri);

  // Avoid writing it into the context. People should always use the context object.
  delete data.context_uri;

  if (uri) {
    data.variant = { uri: uri };
    data.context = { uri: context };
  } else {
    data.variant = null;
    data.context = null;
  }

  // Track and index are flagged as "optional", meaning that when the player is stopped
  // will not be returned. Because of the way "live" works (waiting for properties until
  // they're set), it could happen that we wait forever for "track" and "index". For
  // aoviding this, we set them both to "null".
  data.track = data.track || null;
  data.index = data.index || null;

  if (data.track) {
    data.uid = data.track.uid;
    delete data.track.uid;
  } else {
    data.uid = null;
  }

  return removeUnderscores(data);
}

/**
 * Returns the original URI from a given filtered & sorted URI. For example, given
 * this URL:
 *
 * spotify:internal:sortlist:desc:track(name):internal:filterlist:playable%20eq%20true:user:myuser:playlist:7h5o3lf1ithsxec0wgjznj
 *
 * This method would return:
 *
 * spotify:user:myuser:playlist:7h5o3lf1ithsxec0wgjznj
 *
 * @param {string} uri An internal URI format with sort and/or query parts.
 * @return {string} The original URI.
 */
function getOriginUri(uri) {
  if (!uri) {
    return uri;
  }

  var sorted = sortUriUtils.parse(uri);
  if (sorted) uri = sorted.originUri;

  var filtered = filterUriUtils.parse(uri);
  if (filtered) uri = filtered.originUri;

  return uri;
}

/**
 * Transforms C++ syntax for variable names and keys (underscore_names) to the JS format
 * (camelCase).
 */
function removeUnderscores(data) {
  var transformedKey;

  for (var key in data) {
    if (data.hasOwnProperty(key)) {
      transformedKey = key.replace(/_(.)/g, function (str, chr) {
        return chr.toUpperCase();
      });

      if (data[key] instanceof Object) {
        data[transformedKey] = removeUnderscores(data[key]);
      } else {
        data[transformedKey] = data[key];
      }

      if (transformedKey !== key) {
        delete data[key];
      }
    }
  }

  return data;
}

exports.play = play;
exports.playFromResolver = playFromResolver;
exports.playContext = playContext;
exports.pause = pause;
exports.resume = resume;
exports.update = update;
exports.subscribe = subscribe;
exports.getState = getState;
exports.clear = clear;
exports.addContext = addContext;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../spotify-live":251,"../../spotify-live-filter-uri":208,"../../spotify-live-sort-uri":249,"../../spotify-shuffle-mode":290,"../util/cosmos":247,"./data":225,"spotify-cosmos-api":416,"spotify-player/lib/v2":428}],228:[function(require,module,exports){
'use strict';

var cosmos = require('../util/cosmos');

var sortUriUtils = require('../../spotify-live-sort-uri');
var filterUriUtils = require('../../spotify-live-filter-uri');
var coreSortParams = require('../../spotify-core-sort-params');

var PLAYLIST_RESOLVER = 'sp://core-playlist/v1/playlist/';

// Todo: This is playlist-desktop/src/core-datasource/parse-uri.js
// but it's much easier to make it common when we OneRepo™.
function parseURI(uri) {
  var parsedSortUri = sortUriUtils.parse(uri);
  if (parsedSortUri) uri = parsedSortUri.originUri;
  var parsedFilterUri = filterUriUtils.parse(uri);
  if (parsedFilterUri) uri = parsedFilterUri.originUri;
  return {
    uri: uri,
    sort: parsedSortUri,
    filter: parsedFilterUri
  };
}

function play(contextUri, options, opt_callback) {

  var parsed = parseURI(contextUri);

  var query = [];
  if (parsed.sort) {
    var direction = parsed.sort.direction === 'desc' ? 'DESC' : 'ASC';
    query.push('sort=' + encodeURIComponent(coreSortParams(parsed.sort.query, direction)));
  }

  var filters = [];
  if (parsed.filter) {
    var filtersFromQuery = parsed.filter.query.split(',').map(function (filter) {
      return encodeURIComponent(filter);
    });
    filters.push.apply(filters, filtersFromQuery);
  }
  if (filters.length) {
    query.push('filter=' + filters.join(','));
  }

  // Include a contextUri that is then reflected as the context in the player state
  query.push('uri=' + encodeURIComponent(contextUri));

  var queryString = '';
  if (query.length) {
    queryString = '?' + query.join('&');
  }

  var url = encodeURIComponent(parsed.uri);
  var resolverUrl = PLAYLIST_RESOLVER + url + '/play' + queryString;
  var postObject = { url: resolverUrl };
  if (options) postObject.body = options;

  cosmos.post(postObject, opt_callback);
}

module.exports = {
  play: play
};

},{"../../spotify-core-sort-params":65,"../../spotify-live-filter-uri":208,"../../spotify-live-sort-uri":249,"../util/cosmos":247}],229:[function(require,module,exports){
/**
 * @module spotify-live-models/player/updates
 * @private
 */
'use strict';

var lastRowsList;
var lastRowsListUri;
var lastRowsListHandler;
var lastRowsListReferrer;
var playerRowKey;
var playerKeys;

/**
 * Listen for updates on a rows list and update the player when
 * changes happen.
 *
 * @param {LiveList} rowsList A live list of rows.
 * @param {Object} options Object with options and data of what to play.
 * @param {Function} handler A handler function that gets called whenever
 *     the list is updated. Gets called with one argument: an options object.
 */
function listen(rowsList, options, handler) {
  if (lastRowsList) {
    removeRowsListener();
  }

  lastRowsList = rowsList;
  lastRowsListUri = options.context;
  lastRowsListReferrer = options.contextPlayerReferrer;

  lastRowsListHandler = function lastRowsListHandler() {
    // Todo: Only add this for TPM.
    options.index = getPlayingAndUpdateIndicesInList(rowsList).update;
    handler(options);
  };

  rowsList.on('update', lastRowsListHandler);
}

/**
 * Check if the last added rows listener is still valid for the current
 * player state, and clean up the update handler if it's not valid.
 *
 * @param {LiveObject} model The player live object.
 */
function clean(model) {
  if (!lastRowsListHandler) return;

  var context = model.get('variant');

  // Remove listener if the player context is no longer the same
  if ((context && context.uri) !== lastRowsListUri) {
    removeRowsListener();

    // Remove listener if the player referrer is no longer the same
  } else {
      var origin = model.get('playOrigin');
      var playerReferrer = origin && origin.get('referrerIdentifier');

      if (playerReferrer !== lastRowsListReferrer && !model.get('contextUpdatedCrossFrame')) {
        removeRowsListener();
      }
    }
}

/**
 * Save which item is currently playing.
 *
 * @param {number} index The index for the playing row.
 */
function setPlayingIndex(index, optRowsList) {
  if (!lastRowsList && !optRowsList) {
    return;
  }

  // If the index is out of bounds (e.g. is -1 because the track is not found),
  // then just keep the old playerRowKey.
  if (index < 0) {
    return;
  }

  var list = optRowsList || lastRowsList;

  playerRowKey = list.keys[index] || null;
  playerKeys = list.keys.slice();
}

/**
 * Remove the saved rows listener data.
 */
function removeRowsListener() {
  if (lastRowsList) {
    lastRowsList.off('update', lastRowsListHandler);
  }

  lastRowsList = null;
  lastRowsListUri = '';
  lastRowsListHandler = null;
  lastRowsListReferrer = '';
}

/**
 * Get the index of the playing row in the provided list.
 *
 * @param {LiveList} rowsList A live list of rows.
 *
 * @return {number} The index of the playing row, or -1 if not found.
 */
function getPlayingAndUpdateIndicesInList(rowsList) {
  if (!playerRowKey) return { update: -1, playing: -1 };

  // Find the currently playing row in the new list
  var playingIndexInNewList = rowsList.keys.indexOf(playerRowKey);
  var updateIndex = playingIndexInNewList;

  // If the playing row was not found in the new list, loop through the row
  // keys of the list that the player is currently playing from, and try to
  // find the next row key that exist both in the currently playing list and
  // the new list.
  if (playingIndexInNewList === -1) {
    var indexInPlayerList = playerKeys.indexOf(playerRowKey);
    for (var i = indexInPlayerList, l = playerKeys.length; i < l; i++) {
      updateIndex = rowsList.keys.indexOf(playerKeys[i]);
      if (updateIndex > -1) {

        // Index must be -1 since we've moved down several rows. The cosmos
        // player wants the index of the next row, so before passing it to
        // cosmos, the index will be incremented again.
        updateIndex--;

        break;
      }
    }
  }

  return {
    update: updateIndex,
    playing: playingIndexInNewList
  };
}

/**
 * Check if the player is currently playing from a rows list.
 *
 * @param {string} opt_uri Context URI. If passed, it checks for that specific URI.
 *
 * @return {boolean} True if it is playing from a rows list, false otherwise.
 */
function isPlayingFromRowsContext(opt_uri) {
  if (opt_uri) return lastRowsListUri === opt_uri;

  return !!lastRowsList;
}

exports.setPlayingIndex = setPlayingIndex;
exports.listen = listen;
exports.clean = clean;
exports.getPlayingAndUpdateIndicesInList = getPlayingAndUpdateIndicesInList;
exports.isPlayingFromRowsContext = isPlayingFromRowsContext;

},{}],230:[function(require,module,exports){
(function (global){
/**
 * @module spotify-live-models/session-storage
 */
'use strict';

var forOwn = require('mout/object/forOwn');
var combine = require('mout/array/combine');
var remove = require('mout/array/remove');
var contains = require('mout/array/contains');

var URI = 'spotify:session-storage';
var live = require('../spotify-live');
var cosmos = require('./util/cosmos');
var endpoints = {
  broadcast: 'sp://messages/v1/session-storage'
};

var waiting = [];

function onInit(model) {
  // Set a flag for showing that the model has been implemented and
  // registered. This is so that we can check this in player without
  // making a breaking change.
  model.update({ implemented: true });
}

function onWait(model, properties) {
  // Ask the top frame to broadcast the properties.
  // Values will be null when they weren't stored.
  waiting = combine(waiting, properties);
  global.top.postMessage({
    type: 'session_storage',
    name: 'broadcast_session_storage',
    data: properties
  }, '*');
}

function onPublish(model, properties) {
  // Tell the top frame to persist and broadcast
  global.top.postMessage({
    type: 'session_storage',
    name: 'set_session_storage',
    data: properties
  }, '*');

  // Optimistic update
  model.update(properties);
}

function onBroadcast(error, event) {
  var update = {};
  var model = live(URI);

  forOwn(event.body, function (value, key) {

    // Update model if this instance of storage knows that the model waits for it
    var isWaiting = contains(waiting, key);

    // Or if the model has a potentially outdated value in the live cache
    var hasKey = model.get(key) !== undefined;

    if (isWaiting || hasKey) update[key] = value;
    if (isWaiting) remove(waiting, key);
  });
  model.update(update);
}

var broadcastSubscription;
var regExp = exports.matches = new RegExp('^' + URI + '$');
var registered;

exports.register = function () {
  if (registered) return;
  registered = true;

  live.subscribe(regExp, 'init', onInit);
  live.subscribe(regExp, 'wait', onWait);
  live.subscribe(regExp, 'publish', onPublish);
  broadcastSubscription = cosmos.subscribe({ url: endpoints.broadcast }, onBroadcast);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  live.unsubscribe(regExp, 'init', onInit);
  live.unsubscribe(regExp, 'wait', onWait);
  live.unsubscribe(regExp, 'publish', onPublish);

  if (broadcastSubscription) {
    broadcastSubscription.cancel();
    broadcastSubscription = null;
  }
  waiting.length = 0;
};

exports._endpoints = endpoints;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-live":251,"./util/cosmos":247,"mout/array/combine":348,"mout/array/contains":349,"mout/array/remove":362,"mout/object/forOwn":389}],231:[function(require,module,exports){
"use strict";

/**
 * This module splits up a list into many chunks.
 *
 * @module spotify-live-models/sorting/chunker
 * @private
 */

/**
 * Splits up an array of data into smaller chunks.
 *
 * @param {Array} list The array to be split up.
 * @param {number=} opt_size Optional size of each chunk.
 *
 * @return {Array} Array of chunks, where each chunk is an array of data.
 */
module.exports = function (list, opt_size) {

  function split(array, segments) {
    segments = segments || 2;
    var results = [];
    if (array == null) {
      return results;
    }

    var minLength = Math.floor(array.length / segments);
    var remainder = array.length % segments;
    var i = 0;
    var len = array.length;
    var segmentIndex = 0;
    var segmentLength;

    while (i < len) {
      segmentLength = minLength;
      if (segmentIndex < remainder) {
        segmentLength++;
      }

      results.push(array.slice(i, i + segmentLength));

      segmentIndex++;
      i += segmentLength;
    }

    return results;
  }

  var size = opt_size || 50;
  var chunkCount = Math.ceil(list.length / size);
  var chunks = split(list, chunkCount);

  return chunks;
};

},{}],232:[function(require,module,exports){
/**
 * This file contains transformations from legacy sort queries to new sort
 * queries. We need this because when a user sorts by a certain column, we store
 * the full URI for that list and the sort query is part of the URI. Whenever
 * we change the sort query of a column, we will break sorting for users who
 * have a stored sort state with the old query. That's why we need to maintain
 * this conversion from old to new to make the right list load for all users.
 *
 * When to remove a conversion needs to be weighed case by case I guess. If a
 * user sorts by a certain column and doesn't launch the client for three months
 * and we change the query during that time, it's expected to still work for
 * that user when logging in the next time.
 *
 * History of this file is in the play-desktop app,
 * https://ghe.spotify.net/zelda/client-zelda-js/blob/master/apps/playlist-desktop/src/legacy-sort-uris.js
 */
'use strict';

exports.legacyQueries = {
  // Change date: 2015-03-16
  'track(album(name))': 'track(album(name),disc,number)',
  // Change date: 2015-03-16
  'track(artists(name))': 'track(artists[0:1](name),album(name),disc,number)',
  // Change date: 2015-03-17, value changed 2015-07-14 because we introduced the conversion below.
  'track(addedBy)': 'addedBy(name)',
  // Change date: 2015-07-14
  'track(addedBy(name))': 'addedBy(name)',
  // Change date: 2015-06-26
  'timeSinceAdded': 'timeSinceAdded,track(album(name),disc,number)'
};

},{}],233:[function(require,module,exports){
'use strict';

/**
 * This module helps posting chunked data to/from a worker.
 *
 * @module spotify-live-models/sorting/poster
 * @private
 */

/**
 * Posts data from/to a worker.
 *
 * @param {Object} worker A web worker.
 * @param {Array} chunks Array of split up data.
 * @param {number} index Index of the current chunk to post. Initiate the
 *     poster with 0, and it posts all data sequentially until all data
 *     is posted.
 * @param {string} id An ID for the full payload.
 */
module.exports = function poster(worker, chunks, index, id) {
  'use strict';

  var data = {
    items: chunks[index],
    id: id
  };

  if (index === chunks.length - 1) {
    data.last = true;
  }

  worker.postMessage(data);

  if (!data.last) {
    poster(worker, chunks, index + 1, id);
  }
};

},{}],234:[function(require,module,exports){
(function (global){
'use strict';

/**
 * This module sorts an array of data in the best possible way.
 * If Web Workers are supported, it will spawn new workers and
 * sort on different threads to speed it up.
 *
 * @module spotify-live-models/sorting/sort
 * @private
 */

var chunker = require('./chunker');
var poster = require('./poster');
var sorter = require('./sorter');
var sortWorker = require('./sortworker');
var defer = require('prime/defer');

var workerFile;
var workers = {};
var callbacks = {};
var waitingForReset = {};

// A generated ID will be stored here for each sorted list. Whenever a sorted
// list is asked to resort, a new ID will be generated and set here for that
// list. That allows us to cancel a previous sort if a newer one has started
// before the old one finished.
var idCounter = 0;
var lastIds = {};

/**
 * The local sorter that sorts on the main thread.
 *
 * @param {string} sortUri URI of the sorted list.
 * @param {Array.<Object>} items Array of items to sort. Each item is
 *     an object with the properties `data` and `key`. The `data`
 *     property is an array of values to sort on. The `key` property
 *     is a string for the row ID.
 * @param {Function} callback Async callback where the data is the array of
 *     sorted items.
*/
function localSorter(sortUri, items, callback) {
  items = sorter(items);

  // Saving the callback as the latest callback for this sorted list
  // will allow us to only respond with the latest sorted values (if
  // multiple sort calls were made at the same time).
  callbacks[sortUri] = callback;

  // Make the callback async
  defer(function () {

    // Only allow the latest callback to run
    if (callback === callbacks[sortUri]) {
      delete callbacks[sortUri];

      callback(null, items);
    }
  });
}

/**
 * The Web Worker sorter.
 *
 * @param {string} sortUri URI of the sorted list.
 * @param {Array.<Object>} items Array of items to sort. Each item is
 *     an object with the properties `data` and `key`. The `data`
 *     property is an array of values to sort on. The `key` property
 *     is a string for the row ID.
 * @param {Function} callback Async callback where the data is the array of
 *     sorted items.
 */
function workerSorter(sortUri, items, callback) {
  var worker = workers[sortUri];

  // If we already have a worker for this sorted list, reset that worker
  // and tell it to sort the new data. By saving the callback we make sure
  // that the original worker event handler will run the latest callback
  // when the sorting is done.
  if (worker) {
    callbacks[sortUri] = callback;
    waitingForReset[sortUri] = (waitingForReset[sortUri] || 0) + 1;
    var id = (++idCounter).toString(36);
    lastIds[sortUri] = id;
    worker.postMessage({ reset: true, newId: id });
    sendItemsToWorker(items, worker, id);
    return;
  }

  worker = new Worker(workerFile);
  workers[sortUri] = worker;
  callbacks[sortUri] = callback;

  var id = (++idCounter).toString(36);
  lastIds[sortUri] = id;
  sendItemsToWorker(items, worker, id);

  var result = { items: [] };

  worker.addEventListener('message', function (event) {
    onWorkerMessage(event, result, sortUri);
  }, false);
}

/**
 * Event handler for receiving a message from a worker.
 * This will handle collecting all chunks of data and post it to the latest
 * callback when all chunks have been received.
 *
 * @param {Event} event An event object from the worker 'message' event.
 * @param {Object} result An object with a property `items` for the sorted items.
 * @param {string} sortUri The sort URI for the current sort.
 */
function onWorkerMessage(event, result, sortUri) {

  // When the main thread tells the worker to reset, the worker will respond with
  // a message to reset the array of already sorted items.
  if (event.data.reset) {
    waitingForReset[sortUri]--;
    result.items.length = 0;
    return;
  }

  // Skip messages that don't belong to the latest sort
  if (event.data.id !== lastIds[sortUri]) {
    return;
  }

  // If we are still waiting for reset messages, don't continue to add more items
  // to the list of sorted items.
  if (waitingForReset[sortUri]) {
    return;
  }

  // If we are not waiting for any resets, just save the chunk of sorted items.
  result.items = result.items.concat(event.data.items);

  // When all data has been passed over from the worker, kill the worker and run
  // the latest registered callback for this sorted list.
  if (event.data.last) {
    workers[sortUri].terminate();

    var callback = callbacks[sortUri];
    delete callbacks[sortUri];
    delete workers[sortUri];

    callback(null, result.items);
  }
}

/**
 * Create the Web Worker file path.
 * Since the worker can't share objects with the main thead, we can't share
 * dependencies. To solve this, we convert the dependencies to strings and pass
 * them as arguments to the worker file.
 * To circumvent the need of a separate file for the worker, we make the worker
 * itself and the passed dependencies a single string and make a blob out of it.
 * From the blob we can get a URL that we can pass to the worker constructor.
 *
 * @return {string} Blob URL that can be passed to the worker.
 */
function createWorkerFile() {
  var workerStr = sortWorker.toString();
  var sortStr = sorter.toString();
  var chunkerStr = chunker.toString();
  var posterStr = poster.toString();
  var argsStr = [sortStr, chunkerStr, posterStr].join(', ');
  var stringWorker = '(' + workerStr + ')(' + argsStr + ')';

  var blob = new Blob([stringWorker], { type: 'text/javascript' });
  var url = URL.createObjectURL(blob);

  return url;
}

/**
 * Send the provided items to the provided worker. It will do this by splitting
 * the items into chunks and sending the chunks.
 *
 * @param {Array} items An array of items.
 * @param {Worker} worker A worker instance.
 * @param {string} id The ID for the payload.
 */
function sendItemsToWorker(data, worker, id) {
  var chunks = chunker(data);
  poster(worker, chunks, 0, id);
}

/**
 * Get the sort function to use.
 * If Web Workers are supported, it will use that, otherwise it will use the
 * default sorter on the main thread.
 * Having the code in a function allows for testing where worker support can
 * be removed and added while running the tests.
 *
 * @return {Function} The sorter function.
 */
function getSorter() {
  if (global.Worker && global.Blob && global.URL) {
    if (!workerFile) {
      workerFile = createWorkerFile();
    }
    return workerSorter;
  } else {
    return localSorter;
  }
}

/**
 * Sort the data using the best supported method.
 *
 * @param {string} sortUri URI of the sorted list.
 * @param {Array.<Object>} items Array of items to sort. Each item is
 *     an object with the properties `data` and `key`. The `data`
 *     property is an array of values to sort on. The `key` property
 *     is a string for the row ID.
 * @param {Function} callback Async callback where the data is the array of
 *     sorted items.
 */
module.exports = function (sortUri, items, callback) {
  var sort = getSorter();
  sort(sortUri, items, callback);
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./chunker":231,"./poster":233,"./sorter":235,"./sortworker":236,"prime/defer":402}],235:[function(require,module,exports){
'use strict';

/**
 * This module sorts an array of data.
 *
 * @module spotify-live-models/sorting/sorter
 * @private
 */

/**
 * Sorts an array of data. Supports multiple levels of values
 * (if two items are the same, it tests the values in the next level).
 *
 * @param {Array.<Object>} data Array of items to sort. Each item is
 *     an object with the properties `data` and `key`. The `data`
 *     property is an array of values to sort on. The `key` property
 *     is a string for the row ID.
 *
 * @return {Array.<Object>} A new array of the same objects that were
 *     passed in, but sorted.
 */
module.exports = function (data) {
  'use strict';

  data.sort(function (a, b) {

    var length = a.data.length;

    for (var i = 0; i < length; i++) {
      var aValue = a.data[i];
      var bValue = b.data[i];

      var aNumber = parseInt(aValue, 10);
      var bNumber = parseInt(bValue, 10);

      var aStartsWithNumber = !isNaN(aNumber);
      var bStartsWithNumber = !isNaN(bNumber);

      if (aStartsWithNumber && bStartsWithNumber) {
        if (aNumber < bNumber) return -1;
        if (aNumber > bNumber) return 1;
      } else if (aStartsWithNumber) {
        return -1;
      } else if (bStartsWithNumber) {
        return 1;
      }

      if (aValue.localeCompare) {
        var value = aValue.localeCompare(bValue);
        if (value !== 0) return value;
      } else {
        if (aValue < bValue) return -1;
        if (aValue > bValue) return 1;
      }
    }
  });

  return data;
};

},{}],236:[function(require,module,exports){
'use strict';

/**
 * This is the Web Worker file that sorts the data and passes it back again.
 * The file cannot be passed directly to new Worker(), as it needs some
 * dependencies. These dependencies are required before creating the worker,
 * and then serialized together with this file into a single blob, which is
 * used to create the worker.
 *
 * @module spotify-live-models/sorting/sortworker
 * @private
 */

/**
 * Sort worker.
 *
 * @param {Function} sort Function that sorts an array of data based on a
 *     property.
 * @param {Function} chunk Function that splits up data into chunks.
 * @param {Function} post Function that posts chunks of data back to main
 *     thread.
 * @param {Object} opt_worker Optional worker instance (mainly for testability).
 */
module.exports = function (sort, chunk, post, opt_worker) {
  'use strict';

  var worker = opt_worker || self;

  var itemsToSort = [];
  var id = null;

  worker.addEventListener('message', function (event) {

    // When the main thread tells the worker to reset, the worker will respond with
    // a message to reset the array of already sorted items.
    if (event.data.reset) {
      itemsToSort.length = 0;
      id = event.data.newId;
      worker.postMessage({ reset: true, newId: id });
      return;
    }

    // Only set the stored id for the first message
    if (id === null) {
      id = event.data.id;
    }

    // If the event id does not match the stored id, don't do anything.
    // This allows a sort to be aborted in the middle.
    if (id !== event.data.id) {
      return;
    }

    itemsToSort = itemsToSort.concat(event.data.items);

    if (event.data.last) {
      var sortedItems = sort(itemsToSort);
      var chunks = chunk(sortedItems);
      post(worker, chunks, 0, id);
    }
  }, false);
};

},{}],237:[function(require,module,exports){
'use strict';

/**
 * Get the row values used for sorting.
 *
 * @module spotify-live-models/sorting/values
 * @private
 */

/**
 * Get the values from the row based on the passed mask.
 * String values will be sanitized (lowercase, removing articles like 'the' etc).
 * The values can then be used for sorting.
 *
 * @param {Object} mask A mask object from the query parser.
 * @param {Object} row Row data object.
 *
 * @return {Array>} Array of values to sort on.
 *
 * @example
 * var parse = require('../../spotify-live/util/parser');
 * var mask = parse('track(name), track(artists(name))').mask;
 * var row = {track: {name: 'Track', artists: [{name: 'Artist'}]}};
 * var values = getValues(mask, row);
 * console.log(values);
 * // ['track', 'artist']
 */
function getValues(mask, row) {
  var result = [];
  mask.forEach(function (m) {
    var k = m.key;
    var value = row[k];

    // If the value is an array, we will concatenate all the
    // values with a comma in between, so that sorting takes
    // all values into account. An example is sorting tracks
    // based on 'artists(name)', where there can be many
    // artists for a track. We will in that case concatenate
    // all artists with comma in between and use a string with
    // all the artists when we compare in the sort function.
    if (Array.isArray(value)) {
      if (m.mask) {
        var values = [];
        for (var i = 0, l = value.length; i < l; i++) {
          values = values.concat(getValues(m.mask, value[i]));
        }
        result.push(values.join(', '));
      } else {
        result.push(value.join(', '));
      }
    } else {
      if (m.mask) result.push.apply(result, getValues(m.mask, value));else result.push(value);
    }
  });

  result = sanitizeStrings(result);

  return result;
}

/**
 * Sanitize string values. This includes trimming whitespace, converting
 * the string to lower case and removing common articles like 'the'.
 *
 * @param {Array} values Array of values.
 *
 * @return {Array} A new array of sanitized values.
 */
function sanitizeStrings(values) {
  var numberRe = /\b[0-9]+\b/g;
  var pad = '000000';

  return values.map(function (value) {
    if (typeof value !== 'string') return value;

    value = value.toLowerCase();

    // Remove the first article
    var articles = ['the ', '(the) '];
    for (var i = 0, article; article = articles[i]; i++) {
      if (value.indexOf(article) === 0) {
        value = value.replace(article, '');
        break;
      }
    }

    // Zero-pad numbers for natural numeric sorting (i.e. 2 before 10)
    value = value.replace(numberRe, function (match) {
      if (match.length >= pad.length) return match;
      return pad.substr(0, pad.length - match.length) + match;
    });

    return value.trim();
  });
}

module.exports = getValues;

},{}],238:[function(require,module,exports){
(function (global){
/**
 * @module spotify-live-models/sortlist
 */
'use strict';

var live = require('../spotify-live');
var mixIn = require('mout/object/mixIn');

var Range = require('../spotify-range2');
var diff = require('../spotify-live/util/diff');
var parse = require('../spotify-live/util/parser');
var sortUriUtils = require('../spotify-live-sort-uri');
var listOperations = require('spotify-live-list-operations');

var sort = require('./sorting/sort');
var getValues = require('./sorting/values');

// A generated ID will be stored here for each sorted list. Whenever a sorted
// list is asked to resort, a new ID will be generated and set here for that
// list. That allows us to cancel a previous sort if a newer one has started
// before the old one finished.
var idCounter = 0;
var lastIds = {};

/**
 * Event handler for the live 'init' event on sorted models. Keeps sorted model
 * and tracking model in sync (properties, not rows).
 *
 * This will set up an update listener for the tracking model, so that any
 * changes to the tracking model are also applied to the sort model.
 *
 * This also sets up a publish listener for the sorted model, so that anything
 * that is published on the sorted model gets published on the tracking model,
 * which can then update backend with the data and then update the tracking
 * model with the correct data, which will then trickle back down to the
 * sorted model.
 *
 * @param {LiveObject} sortModel The sorted live model.
 */
function onInit(sortModel) {
  var trackingModel = getTrackingModel(sortModel.uri);

  lastIds[sortModel.uri] = (++idCounter).toString(36);

  // Update the sorted model when any property on the tracking model changes (except rows)
  trackingModel.on('update', function (properties) {
    var updateObject = mixIn({}, properties);
    delete updateObject.rows;
    sortModel.update(updateObject);
  });

  // Update the tracking model when any property on the sort model changes (except rows)
  sortModel.on('publish', function (properties) {
    var updateObject = mixIn({}, properties);
    delete updateObject.rows;
    trackingModel.publish(updateObject);
  });
}

/**
 * Event handler for the live 'wait' event on sorted models.
 * This will fetch any requested property from the tracking model, or if
 * rows are requested, it will perform a sort of the rows from the tracking
 * model.
 *
 * It will also listen for changes. If a change is published on the sorted list,
 * it will be republished on the tracking list. When the tracking list is updated
 * with the new data (maybe after a save on the backend), the sorted list will be
 * updated and resorted if needed.
 *
 * @param {LiveObject} sortModel The sorted live model.
 * @param {Array} properties Array of properties that the model is waiting for.
 */
function onWait(sortModel, properties) {
  var trackingModel = getTrackingModel(sortModel.uri);

  properties.forEach(function (key) {

    // Requesting rows will create a live list of rows, perform sorting,
    // fill the list with the sorted items and also start to listen for changes.
    if (key === 'rows') {
      setRowsProperty(sortModel, trackingModel);

      // Requesting any other property than rows will just get that property from
      // the tracking model.
    } else {
        trackingModel.get(key, function (error, value) {
          if (error) {
            if (global.console) console.error(error);
            return;
          }
          var obj = {};
          obj[key] = value;
          sortModel.update(obj);
        });
      }
  });
}

/**
 * Set the `rows` property on the sort model. It will create a new live list
 * and perform sorting based on the rows of the tracking model. It will also
 * set up listeners for any changes to the lists to automatically keep
 * everything in sync.
 *
 * @param {LiveObject} sortModel The live object for the sorted list.
 * @param {LiveObject} trackingModel The live object for the list the sorted
 *     list is tracking.
 */
function setRowsProperty(sortModel, trackingModel) {
  var sortParams = sortUriUtils.parse(sortModel.uri);
  var direction = sortParams.direction;
  var query = sortParams.query;

  // Start the first sort
  performRowSorting(trackingModel, sortModel, query, direction);

  // Whenever a publish call happens on the sorted list, publish it to the
  // tracking list.
  sortModel.get('rows', function (error, sortList) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }
    sortList.on('publish', function (operations) {
      var trackingList = trackingModel.get('rows');
      if (!trackingList) return;
      syncRows(trackingList, operations, 'publish');
    });
  });

  // We need to get the rows list of the tracking model to be able to know the
  // length of the list, so that we can create the rows list for the sorted list.
  trackingModel.get('rows', function (error, trackingList) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }

    // Listen for updates on the tracking list and apply the changes (and
    // maybe resort if needed) on the sorted list.
    trackingList.on('update', function (operations) {
      var sortList = sortModel.get('rows');
      if (!sortList) return;
      var mustSort = syncRows(sortList, operations, 'update');
      if (mustSort) performRowSorting(trackingModel, sortModel, query, direction);
    });
  });
}

/**
 * Get the tracking model for a sort URI.
 * For an ascending sort URI, the tracking model would be the original list.
 * For a descending sort URI, the tracking model would be the ascending sort list.
 *
 * @param {string} sortUri The sort URI.
 *
 * @return {LiveObject} The live object for the tracking model.
 */
function getTrackingModel(sortUri) {
  var parsed = sortUriUtils.parse(sortUri);
  var direction = parsed.direction;
  var originUri = parsed.originUri;
  var query = parsed.query;

  // We can use the sorting from the ascending list when requesting the
  // descending list, by just depending on the ascending list. Asking for
  // data from the ascending list will make that list ask for the data
  // from the original list and then sort it, and then the descending list
  // will reverse that.
  if (direction === 'desc') {
    return live(sortUriUtils.create(originUri, 'asc', query));
  } else {
    return live(originUri);
  }
}

/**
 * Get data that is needed for performing a sort.
 *
 * @param {Array.<Object>} rows Array of objects of metadata about the rows.
 * @param {Object} mask A mask object from the query parser.
 * @param {LiveList} trackingList The live list for the list the sorted
 *     list is tracking.
 *
 * @return {Array.<Object>} A new array of items used for sorting. Each item is
 *     an object with the properties `data` and `key`. The `data`
 *     property is an array of values to sort on. The `key` property
 *     is a string for the row ID.
 *
 * @example
 * {
 *   data: ['Name of Song', 'Whatever', 100, 0],
 *   key: '0'
 * }
 */
function getSortData(rows, mask, trackingList) {
  return rows.map(function (row, i) {
    var array = getValues(mask, row);
    array.push(i);
    return { data: array, key: trackingList.keys[i] };
  });
}

/**
 * Perform sorting of all rows in a list.
 *
 * @param {LiveObject} trackingModel The model that the sort model is tracking.
 *     For ascending lists, this is the original model. For descending lists,
 *     this is the ascending sort model.
 * @param {LiveObject} sortModel The model to perform the sort on.
 * @param {string} sortQuery The sort query (live compatible query).
 * @param {string} sortDirection The sort direction ('asc' or 'desc').
 */
function performRowSorting(trackingModel, sortModel, sortQuery, sortDirection) {
  lastIds[sortModel.uri] = (++idCounter).toString(36);
  var sortId = lastIds[sortModel.uri];

  // Querying the rows of the tracking model might perform a sort. An example is when
  // getting the sort for a descending list, it will query the rows from the ascending
  // list, which will in turn query the rows from the original list and then perform a
  // sort. When the ascending sort is done, the query will be done and the descending
  // list can just use the ascending list and reverse it.
  trackingModel.get('rows', function (error, rows) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }

    // Create a list of loaded rows. This allows partial loading of a list,
    // and the sorted version will only contain the loaded rows.
    var rowsToSort = [];
    var keys = [];
    for (var i = 0, l = rows.length; i < l; i++) {
      if (rows.get(i)) {
        rowsToSort.push(rows.get(i));
        keys.push(rows.keys[i]);
      }
    }

    // Empty lists won't sort anyway, so quit here, but empty the sorted list
    // to make it up to date.
    if (rowsToSort.length === 0) {
      var sortList = sortModel.get('rows');
      if (sortList) {
        sortList.update([{
          type: 'remove',
          index: 0,
          length: sortList.length
        }]);
      } else {
        sortModel.update({ rows: [] });
      }
      return;
    }

    var partialTrackingList = live([]);

    partialTrackingList.update([{
      type: 'insert',
      index: 0,
      values: rowsToSort,
      keys: keys
    }]);

    // Now we have a list containing only the loaded rows
    partialTrackingList.query(sortQuery, function (error, rows) {
      if (error) {
        if (global.console) console.error(error);
        return;
      }

      // If direction is descending, the tracking model is ascending. Simply reverse that.
      if (sortDirection === 'desc') {
        updateListWithReversedData(sortModel, partialTrackingList);

        // For an ascending sort, perform a real sort.
      } else {

          var mask = parse(sortQuery).mask;
          var sortData = getSortData(rows, mask, partialTrackingList);

          sort(sortModel.uri, sortData, function (error, sortedData) {
            if (error) {
              if (global.console) console.error(error);
              return;
            }
            if (lastIds[sortModel.uri] !== sortId) return;
            updateListWithSortedData(sortModel, partialTrackingList, sortedData);
          });
        }
    });
  });
}

/**
 * Update the sorted live list with the right data after a sort.
 *
 * @param {LiveObject} sortModel The live object for the sorted list.
 * @param {LiveList} trackingList The live list for the list the sorted
 *     list is tracking.
 * @param {Array.<Object>} sortedItems Array of sorted items. Each item is
 *     an object with a property `key`, which is a string for the row ID.
 */
function updateListWithSortedData(sortModel, trackingList, sortedItems) {
  var sortList = sortModel.get('rows');

  // Copy the rows from the list that the sorted list is tracking,
  // if the sorted list has no tracks yet. Only for the first time.
  if (!sortList) {
    sortList = new live.List();
    sortModel.update({ rows: sortList });
  }

  var length = sortedItems.length;
  var keys = new Array(length);
  var values = new Array(length);

  for (var i = 0, l = sortedItems.length; i < l; i++) {
    keys[i] = sortedItems[i].key;
    values[i] = trackingList.valueOf(keys[i]);
  }

  sortList.update([{
    type: 'remove',
    index: 0,
    length: sortList.length
  }, {
    type: 'insert',
    index: 0,
    keys: keys,
    values: values
  }]);
}

/**
 * Update the sorted live list with the data of the list it is tracking,
 * but reversed.
 *
 * @param {LiveObject} sortModel The live object for the sorted list.
 * @param {LiveList} trackingList The live list for the list the sorted
 *     list is tracking.
 */
function updateListWithReversedData(sortModel, trackingList) {
  var sortList = sortModel.get('rows');

  if (!sortList) {
    sortList = new live.List();
    sortModel.update({ rows: sortList });
  }

  sortList.update([{
    type: 'remove',
    index: 0,
    length: sortList.length
  }, {
    type: 'insert',
    index: 0,
    length: trackingList.length,
    values: trackingList.values.slice().reverse(),
    keys: trackingList.keys.slice().reverse()
  }]);
}

/**
 * Converting the passed in operations to be relative to the list that was
 * passed in. Passing operations for a sorted list can convert the operations
 * to be used for the original list. This also updates (or publishes) the list
 * with the converted operations.
 *
 * @param {LiveList} rows The list to sync operations to.
 * @param {Array.<Object>} operations Array of operation objects.
 * @param {string} mode The mode for updates. 'update' or 'publish'.
 *
 * @return {boolean} True if a resort must happen after applying the operations.
 */
function syncRows(rows, operations, mode) {
  var mustSort = false;

  operations.forEach(function (operation) {
    var newOperations = [];

    switch (operation.type) {

      // If rows are removed from the tracking list, we can "simply" remove
      // the same rows from the sorted model.
      case 'remove':
        newOperations = convertRemoveOperationForList(rows, operation);
        break;

      // If rows are inserted in the tracking list, we must add the rows to
      // the sorted list and resort. Where we insert doesn't matter as we will
      // perform a new sort anyway.
      case 'insert':
        newOperations = [{
          type: 'insert', index: 0,
          values: operation.values, keys: operation.keys
        }];
        mustSort = true;
        break;

      // If rows are moved in the tracking list, we don't need to perform any
      // new moves directly, but we will need to perform a resort, as sorting
      // uses stable sort (falls back on index in original list if compared
      // values are the same).
      case 'move':
        mustSort = true;
        break;
    }

    if (mode === 'publish') {
      rows.publish(newOperations);
    } else if (mode === 'update') {
      rows.update(newOperations);
    }
  });

  return mustSort;
}

/**
 * Convert a remove operation from one list to an operation that can
 * be used in another list. An example is when we have an operation that
 * happened in the original list, we need to convert that to operations
 * that can be applied to the sorted list.
 *
 * @param {LiveList} list The live list to create the operations for.
 * @param {Object} operation The input 'remove' operation.
 *
 * @return {Array.<Object>} Array of remove operation objects.
 */
function convertRemoveOperationForList(list, operation) {
  var indices = [];
  var operationKeys = operation.keys;

  list.keys.forEach(function (key, i) {
    if (operationKeys.indexOf(key) > -1) indices.push(i);
  });

  return listOperations.getRemoveOperations(indices);
}

var regExp = exports.matches = /^spotify:internal:sortlist:(asc|desc):([^:]*):(.*)$/;

var registered = false;
exports.register = function () {
  if (registered) return;
  registered = true;

  live.subscribe(regExp, 'init', onInit);
  live.subscribe(regExp, 'wait', onWait);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  live.unsubscribe(regExp, 'init', onInit);
  live.unsubscribe(regExp, 'wait', onWait);
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-live":251,"../spotify-live-sort-uri":249,"../spotify-live/util/diff":252,"../spotify-live/util/parser":254,"../spotify-range2":289,"./sorting/sort":234,"./sorting/values":237,"mout/object/mixIn":393,"spotify-live-list-operations":427}],239:[function(require,module,exports){
'use strict';

/**
 * @module spotify-live-models/station
 */

var live = require('../spotify-live');

// Utilities
var trackToRow = require('./station/track-to-row');
var contains = require('mout/array/contains');
var spotifyURI = require('spotify-liburi');
var messageProxy = require('./station/station-message-proxy.js');
var thumbActions = require('./station/thumb-actions');

var appUri; // The app where this live model is being used.

var URI = exports.URI = 'spotify:station:';
var regExp = exports.matches = new RegExp('^' + URI + '(' + '((artist:|album:|track:)[a-zA-Z0-9]{22})' + '|' + '(user:[^:]+:' + '(playlist:[a-zA-Z0-9]{22}|top:tracks|toplist))' + '|' + '(user:[^:]+:cluster:[a-zA-Z0-9]{22})' + '|' + '(genre:[a-zA-Z0-9]*)' + ')');
exports.isStationUri = regExp.test.bind(regExp);

var DEFAULT_FETCH_COUNT = 15;

// Station Types
var PLAYLIST = 'playlist';
var TRACK = 'track';
var ALBUM = 'album';
var ARTIST = 'artist';
var GENRE = 'genre';
var CLUSTER = 'cluster';
var UNKNOWN = 'unknown';

var registered = false;
var queryReplySubscription;
var metadataUpdateSubscription;

var trackingRows = []; // A list of stations that need row updates.
var trackingMetadata = []; // A list of stations that need metadata updates.

/**
 * Get the station's base seed from the live model uri
 * @param {Object} model
 * @return {String}
 */
function getBaseSeedFromUri(model) {
  var seed = model.uri.replace(/^spotify:station:/, 'spotify:');
  return decodeURIComponent(seed);
}

/**
 * Get the station type
 * @param {String} seed
 * @return {String}
 */
function getType(seed) {
  var uri = spotifyURI.from(seed);
  if (!uri) {
    return UNKNOWN;
  }
  var contextType = uri.type;
  if (contextType === spotifyURI.Type.PLAYLIST) {
    return PLAYLIST;
  } else if (contextType === spotifyURI.Type.ARTIST) {
    return ARTIST;
  } else if (contextType === spotifyURI.Type.ALBUM) {
    return ALBUM;
  } else if (contextType === spotifyURI.Type.TRACK) {
    return TRACK;
  } else if (seed.indexOf('spotify:genre:') === 0) {
    return GENRE;
  } else if (seed.indexOf(':cluster:') > 0) {
    return CLUSTER;
  } else {
    return UNKNOWN;
  }
}

/**
 * Thumb up a track
 * @param {Object} model
 * @param {String} trackUID
 */
function onThumbUp(model, trackUri) {
  messageProxy.thumb({
    'stationUri': model.get('uri'),
    'trackUri': trackUri,
    'thumb': thumbActions.UP
  });
}

/**
 * Thumb down a track
 * @param {Object} model
 * @param {String} trackUID
 */
function onThumbDown(model, trackUri) {
  messageProxy.thumb({
    'stationUri': model.get('uri'),
    'trackUri': trackUri,
    'thumb': thumbActions.DOWN
  });
}

/**
 * Post a request for data from the container (station-manager in zlink).
 * @param {Object} model
 * @param {Array} properties
 * @param {Boolean} needsRows
 * @param {Integer} fetchCount
 */
function requestStationData(model, properties, needsRows, fetchCount) {
  var count = needsRows ? fetchCount || model.get('fetchCount') : false;
  messageProxy.request({
    'appUri': appUri,
    'stationUri': model.get('uri'),
    'metadata': properties,
    'trackCount': count
  });
}

/**
 * Get the appURI to compare against the referrerIdentifier from the player
 */
function getAppUri() {
  live('spotify:application').query('appURI', function (error, data) {
    if (!error) {
      appUri = data.appURI;
    }
  });
}

/**
 * Callback for rows wait event.
 * @param {Object} model
 * @param {Array} ranges
 */
function onRowsWait(model, ranges) {
  if (ranges && ranges.length > 0) {
    var fetchCount = 0;
    var largestTrack = 0;
    ranges.forEach(function (a) {
      if (a.end > largestTrack) {
        largestTrack = a.end;
      }
    });
    fetchCount = largestTrack - model.get('rows').length;
    requestStationData(model, [], true, fetchCount);
  }
}

/**
 * Subscriber for request reply messages
 * @param {Object} opts
 */
function onRequestReply(opts) {
  var sentAppUri = opts.appUri;
  var stationUri = opts.stationUri;
  var station = opts.station;
  if (sentAppUri === appUri) {
    if (station.hasOwnProperty('tracks')) {
      if (trackingRows.indexOf(stationUri) !== -1) {
        var timeStamp = new Date().getTime();
        station.rows = station.tracks.map(trackToRow.bind(null, timeStamp));
      }
      // Never keep a tracks object in the station (needs to be rows).
      delete station.tracks;
    }
    live(stationUri).update(station);
  }
}

/**
 * Subscriber for updateMetadata messages
 * @param {Object} opts
 */
function onUpdateMetadata(opts) {
  var stationUri = opts.stationUri;
  var metadata = opts.metadata;
  if (trackingMetadata.indexOf(stationUri) === -1) {
    return;
  }
  if (metadata.hasOwnProperty('tracks')) {
    if (trackingRows.indexOf(stationUri) !== -1) {
      var timeStamp = new Date().getTime();
      metadata.rows = metadata.tracks.map(trackToRow.bind(null, timeStamp));
    }
    // Never keep a tracks object in the station (needs to be rows).
    delete metadata.tracks;
  }
  live(stationUri).update(metadata);
}

/**
 * When the model intializes
 * @param {Object} model
 */
function onInit(model) {
  var baseSeed = getBaseSeedFromUri(model);
  if (!baseSeed) {
    return;
  }
  model.update({
    baseSeed: baseSeed,
    type: getType(baseSeed),
    added: false, // set this by default
    fetchCount: DEFAULT_FETCH_COUNT
  });
  model.on('update', function onModelUpdate(properties) {
    if (properties.hasOwnProperty('rows')) {
      model.get('rows').on('wait', onRowsWait.bind(null, model));
      model.off('update', onModelUpdate);
    }
  });
  trackingMetadata.push(model.get('uri'));
}

/**
 * Model publish listener
 * @param {Object} model station
 * @param {Object} properties
 */
function onPublish(model, properties) {
  if (properties.hasOwnProperty('added')) {
    var added = properties.added;
    if (typeof added === 'boolean') {
      model.update({ added: added });
      messageProxy.add({
        'stationUri': model.get('uri'),
        'add': added
      });
    } else {
      console.error('Added can only be a boolean');
    }
  }
}

/**
 * Unset props listener
 * @param {Object} model station
 * @param {Object} properties
 */
function onWait(model, properties) {
  var rowsIndex = -1;
  var needsMetadata;
  var metaFields = ['name', 'subtitle', 'relatedArtists', 'image', 'nextPageUrl'];

  properties.forEach(function (key, index) {
    if (key === 'rows') {
      rowsIndex = index;
    }
    if (!needsMetadata && contains(metaFields, key)) {
      needsMetadata = true;
    }
  });

  if (rowsIndex !== -1) {
    trackingRows.push(model.get('uri'));
    properties.splice(rowsIndex, 1);
    requestStationData(model, properties, true);
  } else if (needsMetadata) {
    requestStationData(model, properties);
  }
}

exports.register = function (stationMessageProxy) {
  if (registered) {
    return;
  }
  registered = true;

  // used only for testing
  if (stationMessageProxy) {
    messageProxy = stationMessageProxy;
  }

  live.subscribe(regExp, 'wait', onWait);
  live.subscribe(regExp, 'init', onInit);
  live.subscribe(regExp, 'thumb-up', onThumbUp);
  live.subscribe(regExp, 'thumb-down', onThumbDown);
  live.subscribe(regExp, 'publish', onPublish);
  queryReplySubscription = messageProxy.subscribeTo_requestReply(onRequestReply);
  metadataUpdateSubscription = messageProxy.subscribeTo_updateMetadata(onUpdateMetadata);
  getAppUri();
};

exports.unregister = function () {
  if (!registered) {
    return;
  }
  registered = false;

  live.unsubscribe(regExp, 'wait', onWait);
  live.unsubscribe(regExp, 'init', onInit);
  live.unsubscribe(regExp, 'thumb-up', onThumbUp);
  live.unsubscribe(regExp, 'thumb-down', onThumbDown);
  live.unsubscribe(regExp, 'publish', onPublish);
  queryReplySubscription.cancel();
  metadataUpdateSubscription.cancel();
  trackingRows = [];
  trackingMetadata = [];
};

},{"../spotify-live":251,"./station/station-message-proxy.js":243,"./station/thumb-actions":244,"./station/track-to-row":245,"mout/array/contains":349,"spotify-liburi":426}],240:[function(require,module,exports){
'use strict';

var rowToPlayerTrack = require('./row-to-player-track');

var PLAYER_RESTRICTIONS = {
  'disallow_toggling_repeat_context_reasons': ['disallow-radio'],
  'disallow_toggling_repeat_track_reasons': ['disallow-radio'],
  'disallow_toggling_shuffle_reasons': ['disallow-radio']
};

/**
 * Create an array of tracks formatted for the context player
 * @param {Object} model
 * @return {Array} tracks array
 */
function createPlayerTracks(model) {
  var rows = model.get('rows');
  if (!rows) {
    return [];
  }
  return rows.values.map(rowToPlayerTrack);
}

/**
 * Construct a context object for context-player
 * @param {Object} model station live model
 * @return {Object} context
 */
module.exports = function createPlayContext(model) {
  return {
    'entity_uri': model.get('uri'),
    'pages': [{
      'tracks': createPlayerTracks(model),
      'next_page_url': model.get('nextPageUrl')
    }],
    'metadata': {
      'context_description': model.get('name')
    },
    'restrictions': PLAYER_RESTRICTIONS
  };
};

},{"./row-to-player-track":242}],241:[function(require,module,exports){
'use strict';

var PLAYER_OPTIONS = {
  'shuffling_context': false,
  'repeating_context': false,
  'repeating_track': false
};

/**
 * This is neccesary because you dont get pages back from the context-player.
 * So if you want to resume a station with a set of rows (not pages)
 * you have to know the index of the last played row,
 * which you can get by comparing currentTrackUid with the row's Uid.
 * @param {Object} model station live model
 * @return {Int} index
 */
function getLastIndex(model) {
  var rows = model.get('rows');
  var currentTrackUid = model.get('currentTrackUid');

  if (!rows || !currentTrackUid) {
    return 0;
  }

  var currentIndex;

  var foundRow = rows.values.some(function (row, index) {
    if (row.get('uid') === currentTrackUid) {
      currentIndex = index;
      return true;
    }
  });

  return foundRow ? currentIndex : 0;
};

/**
 * Creates the context-player options for a station context
 * @param {Object} model station model
 * @param {Object} options optional
 * @return {Object} playOptions
 */
module.exports = function createPlayOptions(model, options) {
  if (options && (options.index || options.index === 0)) {
    var trackIndex = options.index;
  } else {
    var trackIndex = getLastIndex(model);
  }
  var playOptions = {
    'skip_to_index': {
      'page': 0,
      'track': trackIndex
    },
    'player_options_override': PLAYER_OPTIONS
  };
  if (options && options.uid) {
    playOptions.uid = options.uid;
  }
  return playOptions;
};

},{}],242:[function(require,module,exports){
'use strict';

/**
 * Converts a station row into a track for the context-player
 * @param {Object} row station row
 * @return {Object} track
 */

module.exports = function rowToPlayerTrack(row) {
  return {
    'uid': row.get('uid'),
    'uri': row.get('track').get('uri'),
    'album_uri': row.get('track').get('albumUri'),
    'artist_uri': row.get('track').get('artistUri'),
    'metadata': {
      'image_url': row.get('track').get('image'),
      'radio.thumb': row.get('thumb')
    }
  };
};

},{}],243:[function(require,module,exports){
'use strict';

/**
 * Station Message Proxy
 * This module is used to standarize the I/O of station messages
 * posted and subscribed by apps with stations. Mainly used to manage
 * the communication between apps and the station-manager in zlink.
 * For example: posting to the request message endpoint, certain object keys
 * are required, and when you add a subscriber
 * to that request endpoint, that function receives the same key/values.
 *
 * In the app:
 * stationMessageProxy.request({
 *  'appUri': 'spotfiy:app:stations',
 *  'stationUri': 'spotify:station:genre:rock',
 *  'metadata': true,
 *  'rowCount': 15
 * });
 *
 * In station-manager:
 * stationMessageProxy.subscribeTo_request(function(obj){
 *  obj.appUri // 'spotfiy:app:stations'
 *  obj.stationUri // 'spotify:station:genre:rock',
 *  obj.metadata // true
 *  obj.rowCount // 15
 * });
 */

var bridge = require('../../spotify-bridge-request');

// Message Uris
var baseUri = 'sp://messages/v1/station/';
var URIS = {
  ADD: baseUri + 'add',
  CREATE: baseUri + 'create',
  THUMB: baseUri + 'thumb',
  REQUEST: baseUri + 'request',
  REQUEST_REPLY: baseUri + 'request/reply',
  UPDATE_METADATA: baseUri + 'update/metadata',
  UPDATE_LAST_PLAYED: baseUri + 'update/lastPlayed',
  REQUEST_ALL: baseUri + 'request-all',
  REQUEST_ALL_REPLY: baseUri + 'request-all/reply',
  REQUEST_SAVED: baseUri + 'request-saved',
  REQUEST_SAVED_REPLY: baseUri + 'request-saved/reply'
};

// Module's Name
var NAME = 'station-message-proxy';

// Message Body Keys (the only valid keys that these proxy methods accept)
var KEY_APP_URI = 'appUri';
var KEY_STATION_URI = 'stationUri';
var KEY_METADATA = 'metadata';
var KEY_TRACK_COUNT = 'trackCount';
var KEY_STATION = 'station';
var KEY_ADD = 'add';
var KEY_THUMB = 'thumb';
var KEY_TRACK_URI = 'trackUri';
var KEY_SAVED_STATIONS = 'saved_stations';
var KEY_USER_STATIONS = 'user_stations';
var KEY_GENRE_STATIONS = 'genre_stations';
var KEY_RECOMMENDED_STATIONS = 'recommended_stations';
var KEY_CLUSTER_STATIONS = 'cluster_stations';
var KEY_CLUSTER_FORMAT_NAME = 'cluster_format_name';

/**
 * A hasmap of all the available methods you can call and 'subscribeTo'
 * and their required object keys.
 */
var API_METHODS = {
  'add': {
    'requiredKeys': [KEY_STATION_URI, KEY_ADD],
    'uri': URIS.ADD
  },
  'request': {
    'requiredKeys': [KEY_APP_URI, KEY_STATION_URI, KEY_METADATA, KEY_TRACK_COUNT],
    'uri': URIS.REQUEST
  },
  'requestReply': {
    'requiredKeys': [KEY_APP_URI, KEY_STATION_URI, KEY_STATION],
    'uri': URIS.REQUEST_REPLY
  },
  'updateMetadata': {
    'requiredKeys': [KEY_STATION_URI, KEY_METADATA],
    'uri': URIS.UPDATE_METADATA
  },
  'updateLastPlayed': {
    'requiredKeys': [KEY_STATION_URI],
    'uri': URIS.UPDATE_LAST_PLAYED
  },
  'thumb': {
    'requiredKeys': [KEY_STATION_URI, KEY_TRACK_URI, KEY_THUMB],
    'uri': URIS.THUMB
  },
  'requestAll': {
    'requiredKeys': [],
    'uri': URIS.REQUEST_ALL
  },
  'requestAllReply': {
    'requiredKeys': [KEY_CLUSTER_FORMAT_NAME, KEY_CLUSTER_STATIONS, KEY_USER_STATIONS, KEY_RECOMMENDED_STATIONS, KEY_GENRE_STATIONS],
    'uri': URIS.REQUEST_ALL_REPLY
  },
  'requestSaved': {
    'requiredKeys': [],
    'uri': URIS.REQUEST_SAVED
  },
  'requestSavedReply': {
    'requiredKeys': [KEY_SAVED_STATIONS],
    'uri': URIS.REQUEST_SAVED_REPLY
  }
};

function _cosmosError(fnName, error) {
  if (error) {
    console.error(NAME + ':' + fnName + ': ' + error);
  }
}

function _createSubscribeWrapper(fnName, subscriber) {
  return function wrapper(error, response) {
    if (error || !response || !response.body) {
      console.error(NAME + ':' + fnName + ' ', error);
      return;
    }
    var body;
    try {
      body = JSON.parse(response.body);
    } catch (e) {
      console.error(NAME + ':' + fnName + ': ' + e);
      return;
    }
    subscriber(body);
  };
}

function _subscribe(fnName, uri, subscriber) {
  if (typeof subscriber !== 'function') {
    throw new Error(NAME + ':' + fnName + ' needs a function.');
  }
  return bridge.cosmos({ method: 'SUB', uri: uri }, _createSubscribeWrapper('subscribeTo' + fnName, subscriber));
}

function _post(fnName, uri, requiredKeys, opts) {
  var body = {};
  requiredKeys.forEach(function (key) {
    if (!opts.hasOwnProperty(key)) {
      throw new Error(NAME + ':' + fnName + ':request missing keys: ' + requiredKeys);
    }
    body[key] = opts[key];
  });

  bridge.cosmos({ method: 'POST', uri: uri, body: JSON.stringify(body) }, _cosmosError.bind(null, 'request'));
}

var API = {};

Object.keys(API_METHODS).forEach(function (method) {
  API[method] = _post.bind(null, method, API_METHODS[method].uri, API_METHODS[method].requiredKeys);

  API['subscribeTo_' + method] = _subscribe.bind(null, method, API_METHODS[method].uri);
});

// Only for unit tests - do not use these directly
API.URIS = URIS;

module.exports = API;

},{"../../spotify-bridge-request":64}],244:[function(require,module,exports){
'use strict';

module.exports = {
  UP: 'ups',
  DOWN: 'downs'
};

},{}],245:[function(require,module,exports){
'use strict';

/**
 * Convert track objects coming from station-manager into a row.
 * @param {Object} track
 * @return {Object} row
 */

module.exports = function trackToRow(timeStamp, track, index) {
  var metadata = track.metadata || {};
  var artistUri = track.artist_uri || metadata.artist_uri;
  var albumUri = track.album_uri || metadata.album_uri;
  var uid = track.uid;

  if (!track.uid) {
    var id = track.uri.replace('spotify:track:', '');
    uid = timeStamp + id + index;
  }

  return {
    uid: uid,
    uri: uid,
    thumb: metadata['radio.thumb'] || '',
    track: {
      uri: track.uri,
      name: metadata.title,
      image: metadata.image_url,
      artistUri: artistUri,
      albumUri: albumUri,
      artists: [{ name: metadata.artist_name, uri: artistUri }],
      album: { name: metadata.album_title, uri: albumUri }
    }
  };
};

},{}],246:[function(require,module,exports){
/**
 * @module spotify-live-models/util/bridge
 * @private
 */

'use strict';

var bridge = require('../../spotify-bridge-request');

module.exports = {
  request: bridge.request
};

},{"../../spotify-bridge-request":64}],247:[function(require,module,exports){
(function (global){
/**
 * @module spotify-live-models/util/cosmos
 * @private
 */

'use strict';

var cosmos = require('spotify-cosmos-api');

function DELETE(options, opt_callback) {
  options.method = exports.cosmos.Action.DELETE;
  return request(options, opt_callback);
}

function GET(options, opt_callback) {
  options.method = exports.cosmos.Action.GET;
  return request(options, opt_callback);
}

function SUB(options, opt_callback) {
  options.method = exports.cosmos.Action.SUB;
  return request(options, opt_callback);
}

function POST(options, opt_callback) {
  options.method = exports.cosmos.Action.POST;
  return request(options, opt_callback);
}

function PUT(options, opt_callback) {
  options.method = exports.cosmos.Action.PUT;
  return request(options, opt_callback);
}

function HEAD(options, opt_callback) {
  options.method = exports.cosmos.Action.HEAD;
  return request(options, opt_callback);
}

function request(options, opt_callback) {
  var method = options.method;
  delete options.method;

  var subscription, canceled;

  sanitizeURL(options.url, function (error, url) {
    if (error) return opt_callback && opt_callback(error);

    // if you cancel before the userName is replaced.
    if (canceled) return;

    var request = new exports.cosmos.Request(method || exports.cosmos.Action.GET, url, options.headers, options.body);
    subscription = exports.cosmos.resolver.resolve(request, function (error, response) {
      if (!opt_callback) return;
      if (error) return opt_callback(error);
      try {
        opt_callback(null, {
          body: JSON.parse(response.getBody() || '{}'),
          headers: response.getHeaders(),
          status: response.getStatusCode()
        });
      } catch (parseError) {
        parseError.response = response;
        opt_callback(parseError);
      }
    });
  });

  return {
    cancel: function cancel() {
      if (subscription && subscription.cancel) {
        // we already subscribed, cancel it.
        subscription.cancel();
        subscription = null;
      } else if (!canceled) {
        // not subscribed yet, don't even subscribe.
        canceled = true;
      }
      return null;
    }
  };
}

function sanitizeURL(url, callback) {
  if (url.indexOf('@') > -1) {
    callback(null, url.replace('@', encodeURIComponent(global.__spotify.username)));
  } else {
    callback(null, url);
  }
}

exports.request = request;
exports.get = GET;
exports.post = POST;
exports.subscribe = SUB;
exports.delete = DELETE;
exports.put = PUT;
exports.head = HEAD;
exports.cosmos = cosmos;

exports.sanitizeURL = sanitizeURL;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"spotify-cosmos-api":416}],248:[function(require,module,exports){
'use strict';

var Preferences = require('../../spotify-preferences');

var preferences = null;
var showUnplayableTracks = null;

var isInitialized = false;
var initCallbacks = [];

/**
 * Initialize the module and start listening for preference updates.
 */

function init(callback) {

  initCallbacks.push(callback);
  if (initCallbacks.length > 1) {
    // We already kicked of the subscription
    return;
  }

  subscribe(function (error, value) {
    if (!error) {
      showUnplayableTracks = !!value;
    }
    isInitialized = true;

    var cb;
    while (cb = initCallbacks.pop()) {
      cb(showUnplayableTracks);
    }
  });
}

/**
 * Subscribe for changes of the 'Show Unplayable Tracks' preference.
 *
 * @param {Function} callback Callback function that gets called for
 *                            each change.
 *
 * @return {Object} An object with a `cancel` method.
 */
function subscribe(callback) {
  var preferences = new Preferences('ui');

  return preferences.subscribe('show_unplayable_tracks', function (error, value) {
    if (error) return callback(error);
    callback(null, !!value);
  });
}

exports.subscribe = subscribe;

},{"../../spotify-preferences":288}],249:[function(require,module,exports){
'use strict';

var base = 'spotify:internal:sortlist';
var regExp = /^spotify:internal:sortlist:(asc|desc):([^:]*):(.*)$/;

/**
 * Create a URI representing a sorted variant of a list.
 *
 * @param {string} originUri The original list URI.
 * @param {string} direction The direction of the sorted list ('asc' or 'desc').
 * @param {string} query The query string (compatible with spotify-live). Sorting
 *     implementations might not look at all values. The list of produced values
 *     from the query will be tried in order from left to right. If two items have
 *     the same value, it will look at the next produced value from this query.
 *     Any spaces in the query will be removed.
 *
 * @return {string} URI of the sorted variant of the list. The URI will have
 *     the query string URL encoded.
 */
exports.create = function (originUri, direction, query) {
  originUri = originUri.replace(/^spotify:/, '');

  query = encodeURIComponent(query);
  query = query.replace(/%20/g, '');

  return [base, direction, query, originUri].join(':');
};

/**
 * Get the direction of the sorted list.
 *
 * @param {string} sortUri The URI of the sorted list.
 *
 * @return {string} The direction of the sort ('asc' or 'desc'). If URI is
 *     invalid, this returns an empty string.
 */
exports.getDirection = function (sortUri) {
  var matches = sortUri.match(regExp);
  if (!matches) return '';

  return matches[1];
};

/**
 * Get the query string from a sort URI.
 *
 * @param {string} sortUri The URI of the sorted list.
 *
 * @return {string} The query string, URL decoded. If URI is
 *     invalid, this returns an empty string.
 */
exports.getQuery = function (sortUri) {
  var matches = sortUri.match(regExp);
  if (!matches) return '';

  return decodeURIComponent(matches[2]);
};

/**
 * Get the URI of the original list.
 *
 * @param {string} sortUri The URI of the sorted list.
 *
 * @return {string} The URI of the original list. If the sort URI is invalid,
 *     this returns an empty string.
 */
exports.getOriginUri = function (sortUri) {
  var matches = sortUri.match(regExp);
  if (!matches) return '';

  return 'spotify:' + matches[3];
};

/**
 * Parse and return all parts of the sort URI.
 *
 * @param {string} sortUri The URI of the sorted list.
 *
 * @return {Object?} An object with properties `direction`, `query` and `originUri`,
 *     or null if the URI is not valid.
 */
exports.parse = function (sortUri) {
  var matches = sortUri.match(regExp);
  if (!matches) return null;

  return {
    direction: matches[1],
    query: decodeURIComponent(matches[2]),
    originUri: 'spotify:' + matches[3]
  };
};

/**
 * Test if the provided URI is a valid sort URI.
 *
 * @param {string} sortUri The URI of the sorted list.
 *
 * @return {boolean} True if it's valid, false otherwise.
 */
exports.isValid = function (sortUri) {
  return regExp.test(sortUri);
};

/**
 * The regular expression that matches sort URIs.
 */
exports.regExp = regExp;

},{}],250:[function(require,module,exports){
'use strict';

var sortUriUtils = require('../spotify-live-sort-uri');
var filterUriUtils = require('../spotify-live-filter-uri');

/**
 * Create a URI representing a wrapped variant of a list.
 *
 * @param {object} opts The options.
 * @param {string} opts.originUri The origin uri.
 * @param {object?} opts.filter The filter, if any
 * @param {object?} opts.sort The sorting, if any
 *
 * @return {string} URI of the wrapped variant of the list.
 */
exports.create = function (opts) {
  var uri = opts.originUri;
  if (opts.filter) {
    uri = filterUriUtils.create(uri, opts.filter.query);
  }
  if (opts.sort) {
    uri = sortUriUtils.create(uri, opts.sort.direction, opts.sort.query);
  }
  return uri;
};

/**
 * Get the URI of the original list.
 *
 * @param {string} sortUri The URI of the wrapped list.
 *
 * @return {string} The URI of the original list. If the wrapped URI is invalid,
 *     this returns an empty string.
 */
exports.getOriginUri = function (wrappedUri) {
  var parsed = exports.parse(wrappedUri);
  return parsed && parsed.originUri || '';
};

/**
 * Parse and return all parts of the wrapped URI.
 *
 * @param {string} wrappedUri The URI of the wrapped list.
 *
 * @return {object} An object with properties `originUri`, `sort` and `filter`.
 */
exports.parse = function (wrappedUri) {
  var sort = sortUriUtils.parse(wrappedUri);
  var filter = filterUriUtils.parse(sort && sort.originUri || wrappedUri);
  if (!(sort || filter)) return null;

  return {
    originUri: filter && filter.originUri || sort && sort.originUri,
    sort: sort,
    filter: filter
  };
};

/**
 * Test if the provided URI is a valid wrapped URI.
 *
 * @param {string} wrappedUri The URI of the wrapped list.
 *
 * @return {boolean} True if it's valid, false otherwise.
 */
exports.isValid = function (wrappedUri) {
  return !!exports.parse(wrappedUri);
};

},{"../spotify-live-filter-uri":208,"../spotify-live-sort-uri":249}],251:[function(require,module,exports){
(function (global){
/**
 * @module live
 */'use strict';

// prime

var prime = require('prime');
var defer = require('prime/defer');
var Emitter = require('prime/emitter');

// mout
var isPlainObject = require('mout/lang/isPlainObject');
var isArray = require('mout/lang/isArray');
var isRegExp = require('mout/lang/isRegExp');
var isNumber = function isNumber(n) {
  return typeof n === 'number';
};
var isString = function isString(s) {
  return typeof s === 'string';
};

var escapeRegExp = require('mout/string/escapeRegExp');

var _difference = require('mout/array/difference');
var filter = require('mout/array/filter');
var combine = require('mout/array/combine');
var map = require('mout/array/map');

var deepMixIn = require('mout/object/deepMixIn');
var pick = require('mout/object/pick');
var keys = require('mout/object/keys');

// finally
var flow = require('finally');

// util
var OrderedSet = require('./util/ordered-set');
var Range = require('../spotify-range2');
var parse = require('./util/parser');
var throttle = require('./util/throttle');

// methods

var isLiveList = function isLiveList(item) {
  return item instanceof LiveList;
};

var isLiveObject = function isLiveObject(item) {
  return item instanceof LiveObject;
};

// Simple, stupid and fast.
// Shallow, not checking hasOwnProperty.
var simpleClone = function simpleClone(object) {
  var clone = {};
  for (var key in object) {
    clone[key] = object[key];
  }
  return clone;
};

var difference = function difference(a, b) {
  return a.length === 0 ? [] : _difference.apply(this, arguments);
};

var values = function values(object, keys) {
  var values = [];
  var key;
  for (var i = 0, len = keys.length; i < len; i++) {
    key = keys[i];
    if (key in object) values.push(object[key]);else values.length++;
  }
  return values;
};

// subtract ranges2 from ranges1
var rdifference = function rdifference(ranges1, ranges2) {
  if (!ranges1.length) return [];

  var resultingRanges = [];

  for (var i = 0, len = ranges1.length; i < len; i++) {
    var range = ranges1[i];
    resultingRanges = resultingRanges.concat(range.subtract(ranges2));
  }

  // Make sure we don't have overlapping ranges
  resultingRanges = new Range(0, 0).merge(resultingRanges);

  // Remove any empty ranges
  resultingRanges = filter(resultingRanges, function (range) {
    return !!range.length;
  });

  return resultingRanges;
};

// merge ranges1 into ranges2
var rcombine = function rcombine(ranges1, ranges2) {
  for (var i = 0, len = ranges1.length; i < len; i++) {
    var range = ranges1[i];
    ranges2 = range.merge(ranges2);
  }
  return ranges2;
};

// util
var IDX = 0;

var slice_ = Array.prototype.slice;

var transform = function transform(item, method) {

  if (isPlainObject(item)) {
    // plain objects need to be liveified
    if ('operations' in item) return new LiveList().update(item.operations);
    return live(item.uri)._update(item, method);
  }

  if (isArray(item)) {
    // arrays need to be liveified
    return new LiveList()._update([{
      type: 'insert',
      index: 0,
      length: item.length,
      values: item
    }], method);
  }
  return item;
};

// Creates a callback with a timeout.
function createTimedCallback(callback, timeout) {
  var called;
  var timeoutId = setTimeout(function () {
    called = true;
    callback(new Error('Timeout Expired: ' + timeout + ' milliseconds'));
  }, timeout);
  return function () {
    if (!called) {
      clearTimeout(timeoutId);
      callback.apply(this, arguments);
    }
  };
};

var LiveList = prime( /** @lends LiveList.prototype */{

  mixin: Emitter,

  /**
   * A representation of an array which may be observed for changes
   * @constructs
   * @mixes Emitter
   * @param {Number} [length] - A number representing the length of the liveList.
   */
  constructor: function LiveList(length) {
    this._data = new OrderedSet(length);
    this._mergeThrottled = throttle(this._merge, this);
    this._waiting = [];

    var self = this;
    var lastWait = '';

    if (live.debug) setInterval(function () {
      var thisWait = self._waiting.toString();
      if (lastWait === thisWait) return;
      lastWait = thisWait;

      if (self._waiting.length) {
        console.warn(self, 'waiting for', self._waiting);
      } else {
        console.warn(self, 'all done');
      }
    }, 2000);
  },

  get index() {
    return this._data.index;
  },

  get length() {
    return this._data.length;
  },

  get keys() {
    return this._data.keys;
  },

  get values() {
    return this._data.values;
  },

  indexOf: function indexOf(key) {
    return this._data.indexOf(key);
  },

  indexOfMany: function indexOfMany(keys) {
    return this._data.indexOfMany(keys);
  },

  valueOf: function valueOf(key) {
    return this._data.valueOf(key);
  },

  hasKey: function hasKey(key) {
    return this._data.hasKey(key);
  },

  forEach: function forEach(fn, ctx) {
    this._data.forEach(fn, ctx);
    return this;
  },

  map: function map(fn, ctx) {
    return this._data.map(fn, ctx);
  },

  _merge: function _merge() {
    var data = this._data; // actual data
    var publish = this._publish; // new items on top of a copy of data || null
    var before = this._before; // an old copy of data || null

    if (publish) {
      delete this._publish;
      if (this._listeners && this._listeners.publish) {
        var publishDiff = data.diff(publish);
        if (publishDiff.length) this.emit('publish', publishDiff, EMIT_SYNC);
      }
    } else if (before) {
      delete this._before;
      if (this._listeners && this._listeners.update) {
        var updateDiff = before.diff(data);
        if (updateDiff.length) this.emit('update', updateDiff, EMIT_SYNC);
      }
    }
    return this;
  },

  _update: function _update(operations, method) {

    var branch;
    if (method === PUBLISH) {
      // it was receiving, cannot publish.
      if (this._before) return this;
      branch = this._publish || (this._publish = this._data.clone());
    } else if (method === UPDATE) {
      // it was publishing, delete it.
      if (this._publish) delete this._publish;
      if (!this._before) this._before = this._data.clone();
      branch = this._data;
    }

    var op;
    for (var opIndex = 0, opLen = operations.length; opIndex < opLen; opIndex++) {
      op = operations[opIndex];
      switch (op.type) {
        case 'length':
          branch.length = op.length;break;
        case 'sort':
          branch.sort(op.compareFunction);break;
        case 'move':
          branch.move(op.from, op.to, op.length);break;
        case 'remove':
          branch.remove(op.index, op.length);break;
        case 'insert':
          var values = [];
          var keys = op.keys || [];
          for (var i = 0, len = op.values.length; i < len; i++) {
            if (!op.keys || !op.keys[i]) keys[i] = (IDX++).toString(36);
            values[i] = transform(op.values[i], method);
          }
          branch.insert(op.index, keys, values);
          break;
      }
    }

    if (method === UPDATE) this._waiting = rdifference(this._waiting, this.index);

    this._mergeThrottled();
    return this;
  },

  publish: function publish(operations) {
    return this._update(operations, PUBLISH);
  },

  update: function update(operations) {
    return this._update(operations, UPDATE);
  },

  /**
   * Serialize the data in this list into a plain object.
   *
   * @param {number=} limit Optional limit parameter. Controls how many levels
   *     deep to serialize.
   *
   * @return {Array} The data array.
   */
  serialize: function serialize(limit) {
    if (limit === 0) return [];

    var array = [];
    var nextLimit = limit === undefined ? undefined : limit - 1;

    for (var i = 0; i < this.length; i++) {
      var value = this.values[i];
      var serializedValue = value;
      if (value && value.serialize) {
        serializedValue = value.serialize(nextLimit);
      }
      array.push(serializedValue);
    }

    return array;
  },

  _getDataFromMask: function _getDataFromMask(mask) {
    var items = [];

    if (mask.length > 0) {
      // The provided mask to a list is the mask for each list item, so we need
      // to loop through all the items and get the data from each item based on
      // the mask.
      for (var i = 0, l = this.length; i < l; i++) {
        var item = this.get(i);
        var parsedItem;
        var isObjectOrList = item && item._getDataFromMask;
        if (isObjectOrList) {
          parsedItem = item._getDataFromMask(mask);
        }
        items.push(parsedItem);
      }
    }

    return items;
  },

  _query: function _query(selector, callback, mode) {
    var self = this;

    var query = function query() {
      queryList(self, selector, function (error, data, wasSync) {
        if (error) return callback(error);

        if (!wasSync) {
          self._query(selector, callback, mode);
        } else {
          callback(null, data);
        }
      });
    };

    if (mode === ASYNC) defer(query);else query();
  },

  /**
   * Query properties in this list.
   * This can be called in two different ways: with a callback or without. When
   * calling it with a callback, it will wait for any missing data and always
   * return the data you queried for. When calling it without a callback, it
   * will return an array structure with only the data that was found in the
   * object at the moment. It will not kick off any events for waiting for
   * properties.
   *
   * @param {String} selector - The query selector. Only selectors without
   *     filters are supported when not providing a callback.
   * @param {Array} params - The query replace parameters.
   * @param {LiveList~queryCallback} callback - The callback that handles the response.
   * @param {Object} [mode] live.SYNC: Force sync, 2: live.ASAP: Don't force async
   * @param {Number} timeout - optional timeout in milliseconds
   *
   * @return {LiveList|Array} If no callback is passed it returns an array with
   *                             the data matching the query, that was found at
   *                             the moment in the list.
   *                             If a callback is passed it returns the instance.
   */
  query: function query(selector, params, callback, mode, timeout) {
    /**
     * @callback LiveList~queryCallback
     * @param {Error|Null} error - An error that you can throw, or null.
     * @param {Array} [data] - The response as an array.
     */
    if (typeof params === 'function') {
      // shift for empty params
      timeout = mode;
      mode = callback;
      callback = params;
      params = [];
    }

    if (!callback) {
      return this._getDataFromMask(parse(selector, params).mask);
    }

    if (!mode) {
      mode = ASYNC;
    } else if (isNumber(mode)) {
      // shift once again
      timeout = mode;
      mode = ASYNC;
    }

    if (timeout) {
      callback = createTimedCallback(callback, timeout);
    }

    this._query(parse(selector, params), callback, mode);
    return this;
  },

  _wait: function _wait(ranges) {
    if (!this._required) {
      // if _required is set, it was deferred already
      this._required = [];
      defer(function () {
        var missingFromIndex = this.missing(this._required);
        var missingFromWaiting = rdifference(missingFromIndex, this._waiting);
        this._waiting = rcombine(this._waiting, missingFromWaiting);
        delete this._required;
        if (missingFromWaiting.length) this.emit('wait', missingFromWaiting, EMIT_SYNC);
      }, this);
    }
    this._required = rcombine(this._required, ranges);
  },

  missing: function missing(ranges) {
    return rdifference(ranges, this.index);
  },

  // the raw, unbeautified get
  // this can callback sync or async
  _get: function _get(ranges, callback) {
    if (this.missing(ranges).length) {
      // has missing stuff (no matter what)
      this._wait(ranges);

      var check = function check() {
        var needed = this.missing(ranges);
        if (!needed.length) {
          this.off('update', check);
          callback.call(this);
        }
      };

      this.on('update', check);
    } else {
      // the callback is called with 'true' when syncronous.
      callback.call(this, null, true);
    }
  },

  /**
   * Checks if the range has been set with values in the list.
   *
   * @param {number} fromIndex The index to start from.
   * @param {number=} toIndex Optional index to stop at (non-inclusive). If no
   *     toIndex is specified, it will default to the index after fromIndex, to
   *     check for the single item at fromIndex.
   *
   * @return {Boolean} True if the range has been set.
   */
  has: function has(fromIndex, toIndex) {
    var hasToIndex = toIndex !== undefined;
    if (!hasToIndex) toIndex = fromIndex + 1;

    var range = new Range(fromIndex, toIndex);

    return range.contained(this.index);
  },

  /**
   * Gets items from the list between the specified indices.
   * @param {Number} what - The index to start from.
   * @param {Number} [toIndex=fromIndex + 1] - The index to stop at (non-inclusive).
   * @param {LiveList~getCallback} [callback] - Optional callback function. If no toIndex
   *     is specified, the callback can be placed as the second argument.
   * @param {Object} [mode] live.SYNC: Force sync, 2: live.ASAP: Don't force async
   * @param {Number} timeout - optional timeout in milliseconds
   * @return {LiveList|Array} If no callback is specified, returns the requested items in an array.
   *                          If a callback is specified, the method returns the instance.
   */
  get: function get(fromIndex, toIndex) {
    /**
     * @callback LiveList~getCallback
     * @param {Error|Null} error - An error that you can throw, or null.
     * @param {Array|*} [data] - The response as an array.
     *                           If toIndex is not specified a single item on the list is passed.
     */

    // fast, get one
    if (arguments.length === 1) {
      if (isNumber(fromIndex)) return this.values[fromIndex];
      if (isString(fromIndex)) return this.valueOf(fromIndex);
    }

    var self = this;

    var args = slice_.call(arguments);
    var callback, mode, requested;

    for (var i = 0, len = args.length; i < len; i++) {
      var arg = args[i];
      if (typeof arg === 'function') {
        var split = args.splice(i, 3);
        len = args.length;
        callback = split[0];
        if (split[1]) {
          if (split[1] === SYNC || split[1] === ASYNC || split[1] === ASAP) {
            mode = split[1];
          } else {
            // assume this arg is a timeout
            mode = ASYNC;
            callback = createTimedCallback(callback, split[1]);
            break;
          }
          // is there a timeout ?
          if (split[2] && mode !== SYNC) {
            callback = createTimedCallback(callback, split[2]);
          }
        } else {
          mode = ASYNC;
        }
        break;
      }
    }

    var asArray = false;
    var asSingleValue = false;

    if (fromIndex instanceof Range) {
      // one range
      requested = args;
      asArray = !callback && requested.length > 1;
    } else if (isArray(fromIndex)) {
      // array of ranges
      asArray = true;
      requested = fromIndex;
    } else {
      // numbers ?
      var hasToIndex = !isNaN(toIndex);
      if (!hasToIndex) toIndex = fromIndex + 1;
      asSingleValue = !hasToIndex;
      requested = [new Range(fromIndex, toIndex)];
    }

    var result = function result() {
      return map(requested, function (range) {
        return self.values.slice(range.start, range.end);
      });
    };

    var done = function done() {
      if (asArray) callback.call(self, null, result());else if (asSingleValue) callback.call(self, null, self.values[fromIndex]);else callback.apply(self, [null].concat(result()));
    };

    if (!callback) {
      if (asArray) return result();
      return result()[0];
    } else if (mode === SYNC) {
      done();
    } else {
      if (mode === ASYNC && !this.missing(requested).length) {
        // it has all the data but needs to be ASYNC
        defer(function () {
          this._get(requested, done);
        }, this);
      } else {
        this._get(requested, done);
      }
    }
    return this;
  }

});

var LiveObject = prime( /** @lends LiveObject.prototype */{

  mixin: Emitter,

  /**
   * A representation of an object which may be observed for changes
   * @constructs
   * @mixes Emitter
   */
  constructor: function LiveObject(_uri) {
    this.uri = _uri;
    this._data = { uri: _uri };
    this._mergeThrottled = throttle(this._merge, this);
    this.index = [];
    this._waiting = [];
    this.emit('init', EMIT_SYNC);

    var self = this;
    var lastWait = '';

    if (live.debug) setInterval(function () {
      var thisWait = self._waiting.toString();
      if (lastWait === thisWait) return;
      lastWait = thisWait;

      if (self._waiting.length) {
        console.warn(self, self._waiting);
      } else {
        console.warn(self, 'all done');
      }
    }, 2000);
  },

  emit: function emit() {
    var uri = this.uri;
    if (uri) {
      var keys = emitters.keys;
      var values = emitters.values;
      var key;
      var args;

      for (var i = 0, len = keys.length; i < len; i++) {
        key = keys[i];
        if (uri.match(key)) {
          if (!args) {
            args = new Array(arguments.length);
            for (var j = 0; j < arguments.length; ++j) {
              args[j] = arguments[j];
            }
            args.splice(1, 0, this);
          }
          var emitter = values[i];
          emitter.emit.apply(emitter, args);
        }
      }
    }

    Emitter.prototype.emit.apply(this, arguments);
  },

  _merge: function _merge() {
    var data = this._data; // the data
    var before = this._before; // an old copy of data
    var publish = this._publish; // published data
    var value;
    var key;

    // published changes
    if (publish) {
      delete this._publish;

      // emit change events if the object has a uri that can be subscribed too,
      // or the object in itself has listeners
      if (this.uri || this._listeners && this._listeners.publish) {
        var publishEvent = {};

        for (key in publish) {
          value = publish[key];
          if (data[key] !== value) publishEvent[key] = value;
        }

        if (Object.keys(publishEvent).length) {
          this.emit('publish', publishEvent, EMIT_SYNC);
        }
      }
    }

    // if there are changes
    if (before) {
      delete this._before;

      var updateEvent = {};

      // emit change events if the object has a uri that can be subscribed too,
      // or the object in itself has listeners
      if (this.uri || this._listeners && this._listeners.update) {
        // check changed and added keys
        for (key in data) {
          value = data[key];
          // there was no key, or value is different
          if (!(key in before) || before[key] !== value) updateEvent[key] = value;
        }

        // check deleted keys
        for (key in before) {
          value = before[key];
          // there is no key so it was deleted
          if (!(key in data)) updateEvent[key] = undefined;
        }

        if (Object.keys(updateEvent).length) {
          this.emit('update', updateEvent, EMIT_SYNC);
        }
      }
    }

    return this;
  },

  _update: function _update(object, method) {
    var branch;

    if (method === PUBLISH) {
      branch = this._publish || (this._publish = simpleClone(this._data));
    } else if (method === UPDATE) {
      if (!this._before) this._before = simpleClone(this._data);
      branch = this._data;
    }

    var value;
    for (var key in object) {
      value = object[key];
      var previous = !(key in branch) ? undefined : branch[key];

      if (isLiveList(previous)) {
        // updating lists with an array will keep the reference but replace every item.
        if (isArray(value)) {

          previous._update([{
            type: 'remove',
            index: 0,
            length: previous.length
          }, {
            type: 'insert',
            index: 0,
            values: value
          }], method);
          continue;
        } else if (isPlainObject(value) && 'operations' in value) {
          previous._update(value.operations, method);
          continue;
        }
      }

      if (method === UPDATE && value === undefined) delete branch[key];else branch[key] = transform(value, method);
    }

    if (method === UPDATE) {
      this.index = keys(branch);
      this._waiting = difference(this._waiting, this.index);
    }

    this._mergeThrottled();
    return this;
  },

  delete: function _delete(key) {
    var object = {};
    object[key] = undefined;
    return this.update(object);
  },

  update: function update(object) {
    return this._update(object, UPDATE);
  },

  publish: function publish(object) {
    return this._update(object, PUBLISH);
  },

  /**
   * Serialize the data in this object into a plain object.
   *
   * @param {number=} limit Optional limit parameter. Controls how many levels
   *     deep to serialize.
   *
   * @return {Object} The data object.
   */
  serialize: function serialize(limit) {
    if (limit === 0) return {};

    var object = {};
    var data = this._data;
    var nextLimit = limit === undefined ? undefined : limit - 1;

    for (var key in data) {
      var value = data[key];
      if (value === undefined) continue;
      var serializedValue = value;
      if (value && value.serialize) {
        serializedValue = value.serialize(nextLimit);
      }
      object[key] = serializedValue;
    }

    return object;
  },

  _getDataFromMask: function _getDataFromMask(mask) {
    var data = {};

    for (var i = 0, l = mask.length; i < l; i++) {
      var thisMask = mask[i];
      var nextMask = thisMask.mask;
      var key = thisMask.key;

      var realValue = this.get(key);
      var value = realValue;

      // Set the value to an empty object or array, and then it will be filled
      // in with the found data in the next step.
      if (isLiveObject(realValue)) value = {};
      if (isLiveList(realValue)) value = [];

      if (nextMask) {
        if (isLiveObject(realValue)) {
          var innerData = realValue._getDataFromMask(nextMask);
          deepMixIn(value, innerData);
        } else if (isLiveList(realValue)) {
          value = realValue._getDataFromMask(nextMask);
        }
      }

      data[key] = value;
    }

    return data;
  },

  _query: function _query(selector, callback, mode) {
    var self = this;

    var query = function query() {
      queryObject(self, selector, function (error, data, wasSync) {
        if (error) return callback.call(this, error);

        if (!wasSync) {
          self._query(selector, callback, mode);
        } else {
          callback.call(this, null, data);
        }
      });
    };

    if (mode === ASYNC) defer(query);else query();
  },

  /**
   * Query properties in this object.
   * This can be called in two different ways: with a callback or without. When
   * calling it with a callback, it will wait for any missing properties and
   * always return the data you queried for. When calling it without a callback,
   * it will return an object structure with only the data that was found in the
   * object at the moment. It will not kick off any events for waiting for
   * properties.
   *
   * @param {String} selector - The query selector. Only selectors without
   *     filters are supported when not providing a callback.
   * @param {Array} params - The query replace parameters. Optional.
   * @param {LiveObject~queryCallback} callback - The callback function.
   * @param {Object} [mode] live.SYNC: Force sync, 2: live.ASAP: Don't force async
   * @param {Number} timeout - optional timeout in milliseconds
   *
   * @return {LiveObject|Object} If no callback is passed it returns an object
   *                             with the data matching the query, that was found
   *                             at the moment in the object.
   *                             If a callback is passed it returns the instance.
   */
  query: function query(selector, params, callback, mode, timeout) {
    /**
     * @callback LiveObject~queryCallback
     * @param {Error|Null} error - An error that you can throw, or null.
     * @param {LiveObject} [data] - The response as a plain object.
     */
    if (typeof params === 'function') {
      // shift for empty params
      timeout = mode;
      mode = callback;
      callback = params;
      params = [];
    }

    if (!callback) {
      return this._getDataFromMask(parse(selector, params).mask);
    }

    if (!mode) {
      mode = ASYNC;
    } else if (isNumber(mode)) {
      // shift once again
      timeout = mode;
      mode = ASYNC;
    }

    if (timeout) {
      callback = createTimedCallback(callback, timeout);
    }

    this._query(parse(selector, params), callback, mode);
    return this;
  },

  _wait: function _wait(keys) {
    if (!this._required) {
      // if _required is set, it was deferred already
      this._required = [];
      defer(function () {
        var missingFromIndex = this.missing(this._required);
        var missingFromWaiting = difference(missingFromIndex, this._waiting);
        this._waiting = combine(this._waiting, missingFromWaiting);
        delete this._required;
        if (missingFromWaiting.length) this.emit('wait', missingFromWaiting, EMIT_SYNC);
      }, this);
    }
    this._required = combine(this._required, keys);
  },

  missing: function missing(keys) {
    return difference(keys, this.index);
  },

  /**
   * Checks if the key has been set in the object.
   *
   * @param {string} key The name of the key.
   *
   * @return {Boolean} True if the key has been set.
   */
  has: function has(key) {
    return this.index.indexOf(key) > -1;
  },

  // the raw, unbeautified get
  // this can callback sync or async
  _get: function _get(keys, callback) {
    if (this.missing(keys).length) {
      this._wait(keys);

      var check = function check() {
        var needed = this.missing(keys);
        if (!needed.length) {
          this.off('update', check);
          callback.call(this);
        }
      };
      this.on('update', check);
    } else {
      // the callback is called with 'true' when syncronous.
      callback.call(this, null, true);
    }
  },

  /**
   * Gets values from the object.
   * @param {...String|Array} keys - An array of strings as arguments.
   * @param {LiveObject~getCallback} [callback] - Optional callback function.
   * @param {Object} [mode] live.SYNC: Force sync, 2: live.ASAP: Don't force async
   * @param {Number} timeout - optional timeout in milliseconds
   * @return {LiveObject|Array|*} If no callback is passed and keys is either an array or multiple arguments
   *                             returns the values in an array.
   *                             If no callback is passed and keys is a single parameter it
   *                             returns the requested value (any type).
   *                             If a callback is passed it returns the instance.
   */
  get: function get(key) {
    /**
     * @callback LiveObject~getCallback
     * @param {Error|Null} error - An error that you can throw, or null.
     * @param {Array|...*} [data] - If keys are requested as arguments (any #)
     *                              it will return many results as arguments.
     *                              If keys are requested as an array (any #), it will return data as an array
     * @param {Number} [mode] 1: FORCE SYNC, 2: DON'T FORCE ASYNC
     */

    // fast, get one
    var data = this._data;
    if (arguments.length === 1 && isString(key)) return data[key];

    var self = this;

    var args = slice_.call(arguments);
    var callback, mode, keys;

    for (var i = 0, len = args.length; i < len; i++) {
      var arg = args[i];
      if (typeof arg === 'function') {
        var split = args.splice(i, 3);
        len = args.length;
        callback = split[0];
        if (split[1]) {
          if (split[1] === SYNC || split[1] === ASYNC || split[1] === ASAP) {
            mode = split[1];
          } else {
            // assume this arg is a timeout
            mode = ASYNC;
            callback = createTimedCallback(callback, split[1]);
            break;
          }
          // is there a timeout ?
          if (split[2] && mode !== SYNC) {
            callback = createTimedCallback(callback, split[2]);
          }
        } else {
          mode = ASYNC;
        }
        break;
      }
    }

    var asArray = false;

    if (isArray(key)) {
      keys = key;
      asArray = true;
    } else {
      keys = args;
    }

    var done = function done() {
      var vals = values(data, keys);
      if (asArray) {
        callback.call(self, null, vals);
      } else {
        vals.unshift(null); // unshift no error
        callback.apply(self, vals);
      }
    };

    if (!callback) {
      return values(data, keys);
    } else if (mode === SYNC) {
      done();
    } else {
      if (mode === ASYNC && !this.missing(keys).length) {
        // it has all the data but needs to be ASYNC
        defer(function () {
          self._get(keys, done);
        });
      } else {
        this._get(keys, done);
      }
    }

    return this;
  }

});

var queryAny = function queryAny(object, selector, callback) {
  if (isPlainObject(object) || isLiveObject(object)) return queryObject(object, selector, callback);else if (isArray(object) || isLiveList(object)) return queryList(object, selector, callback);else return callback(null, object, true);
};

var queryObject = function queryObject(object, selector, callback) {
  var data = {};
  var isSync = true;

  if (!selector) callback(null, data, isSync);

  var keys = map(selector.mask, 'key');

  var done = function done(values) {
    flow().parallel(values, function (objectValue, i) {
      var control = this;
      queryAny(objectValue, selector.mask[i], function (error, dataValue, wasSync) {
        if (error) return control.break(error);
        if (!wasSync) isSync = false;
        if (data[keys[i]]) deepMixIn(data[keys[i]], dataValue);else data[keys[i]] = dataValue;
        control.done();
      });
    }).finally(function (error) {
      callback(error, data, isSync);
    });
  };

  if (isLiveObject(object)) {
    object._get(keys, function (error, wasSync) {
      if (error) return callback(error);
      if (!wasSync) isSync = false;
      var values = map(keys, function (key) {
        return object._data[key];
      });
      done(values);
    });
  } else {
    var values = pick(object, keys);
    done(values);
  }
};

var satisfies = function satisfies(value, op, right) {
  if (!op) return !!value;
  if (isRegExp(right)) return right.test(value);

  if (op === '=') return value === right;
  if (op === '!=') return value !== right;

  if (isNumber(right)) {
    if (op === '>') return value > right;
    if (op === '>=') return value >= right;
    if (op === '<') return value < right;
    if (op === '<=') return value <= right;
  }

  if (isString(right)) {
    var escapedRight = escapeRegExp(right);
    // starts with
    if (op === '^=') return new RegExp('^' + escapedRight).test(value);
    // ends with
    if (op === '$=') return new RegExp(escapedRight + '$').test(value);
    // contains separated by space e.g. 'list of things to look for' ~= 'list'
    if (op === '~=') return new RegExp('(^|\\s)' + escapedRight + '(\\s|$)').test(value);
    // contains separated by - e.g. 'list-of-things-to-look-for' ~= 'things'
    if (op === '|=') return new RegExp('^' + escapedRight + '(-|$)').test(value);
    // contains e.g. 'listofthingstolookfor' ~= 'look'
    if (op === ' *=') return value.toString().indexOf(right) !== -1;
  }

  return false;
};

var filterArray = function filterArray(array, left, op, right, callback) {
  var isSync = true;

  var filtered = [];

  flow().parallel(array, function (item, i) {
    var ctrl = this;

    if (isLiveObject(item)) {
      item._get([left], function (error, wasSync) {
        if (error) return ctrl.break(error);
        if (!wasSync) isSync = false;
        var value = item._data[left];
        if (satisfies(value, op, right)) filtered[i] = item;
        ctrl.done();
      });
    } else if (isPlainObject(item)) {
      if (satisfies(item[left], op, right)) filtered[i] = item;
      ctrl.done();
    } else {
      // filter objects only
      ctrl.done();
    }
  }).finally(function (error) {
    if (error) return callback(error);
    var clean = [];
    for (var i = 0; i < filtered.length; i++) {
      if (i in filtered) clean.push(filtered[i]);
    }callback(null, clean, isSync);
  });
};

// default filter that filters the whole list.
var defaultFilters = [[{
  left: 0,
  op: ':'
}]];

var queryList = function queryList(list, selector, callback) {
  var isSync = true;
  // if there are no filters we need to query the full length
  if (!selector.filters) selector.filters = defaultFilters;

  // single filter.
  // must be sequential.
  flow().sequential(selector.filters, function (conditions) {
    var sequential = this;

    var ref = [];

    // list of conditions in a single filter.
    // can be parallel.
    flow().parallel(conditions, function (condition) {
      var parallel = this;

      var left = condition.left;
      var right = condition.right;
      var op = condition.op;

      if ('left' in condition && !('right' in condition) && isNumber(left)) {
        if (!op) right = left + 1;else if (op === ':') right = list.length;
        op = ':';
      }

      if ('right' in condition && !('left' in condition) && isNumber(right) && op === ':') {
        left = 0;
      }

      // filter by range.
      if (isNumber(left) && isNumber(right) && op === ':') {
        // if the list is an array it means it has already been filtered.
        if (isArray(list)) {
          var filtered = slice_.call(list, left, right);
          ref = ref.concat(filtered);
          parallel.done();
        } else {
          list._get([new Range(left, right)], function (error, wasSync) {
            if (error) return parallel.break(error);

            for (var i = left; i < right; i++) {
              ref.push(list.values[i]);
            }if (!wasSync) isSync = false;
            parallel.done();
          });
        }
      } else {

        var done = function done(array) {
          filterArray(array, left, op, right, function (error, filtered, wasSync) {
            if (error) return parallel.break(error);

            if (!wasSync) isSync = false;
            ref = ref.concat(filtered);
            parallel.done();
          });
        };

        if (isArray(list)) {
          done(list);
        } else {
          // the list is not an array, never been filtered.
          // assume full length.
          // call a function that filters an array once you arraify it.
          list._get([new Range(0, list.length)], function (error, wasSync) {
            if (error) return parallel.break(error);

            var array = [];
            for (var i = 0; i < list.length; i++) {
              array.push(list.values[i]);
            }if (!wasSync) isSync = false;
            done(array);
          });
        }
      }

      // parallel finished
    }).finally(function (error) {
      if (error) return sequential.break(error);
      list = ref;
      sequential.continue();
    });

    // sequential finished
  }).finally(function (error) {
    if (error) return callback(error);

    var data = [];

    // final parallel
    flow().parallel(list, function (item, i) {
      var control = this;
      queryAny(item, selector, function (err, res, wasSync) {
        if (!wasSync) isSync = false;
        if (data[i]) deepMixIn(data[i], res);else data[i] = res;
        control.done(err);
      });
    }).finally(function (err) {
      callback(err, data, isSync);
    });
  });
};

var cache = {};

/**
 * Create a new instance of a object, based on an unique identifier.
 * @function
 * @static
 * @param {String|LiveObject} item - An object with an uri property, or an uri as a string.
 * @return {LiveObject|LiveList} An instance of LiveObject or LiveList.
 */
var live = function live(item) {
  if (isArray(item)) {
    return new LiveList().update([{
      type: 'insert',
      index: 0,
      length: item.length,
      values: item
    }]);
  } else if (isNumber(item)) {
    return new LiveList(item);
  } else if (isString(item)) {
    return cache[item] || (cache[item] = new LiveObject(item));
  } else if (isPlainObject(item)) {
    return live(item.uri).update(item);
  } else if (isLiveList(item) || isLiveObject(item)) {
    return item;
  }

  return new LiveObject();
};

// Allow localStorage.debug to also control live.debug.
if (global.localStorage && global.localStorage.debug && (global.localStorage.debug.indexOf('spotify-live') > -1 || global.localStorage.debug.indexOf('*') > -1)) {
  live.debug = true;
}

var emitters = {
  keys: [],
  values: []
};

/**
 * Subscribe to the specific event of objects matching the pattern.
 * @function
 * @static
 * @param {RegExp} match - Regular expression for matching uris.
 * @param {String} name - The name of the event to listen for.
 * @param {Function} handle - The event handle.
 * @return {Function} The live function.
 */
live.subscribe = function (match, name, handle) {
  if (match.matches) match = match.matches;

  var string = match.toString();

  var keys = emitters.keys;
  var values = emitters.values;

  var emitter;
  for (var i = 0, len = keys.length; i < len; i++) {
    var key = keys[i];
    if (key.toString() === string) {
      emitter = values[i];
      if (emitter) break;
    }
  }

  if (!emitter) {
    keys.push(match);
    values.push(emitter = new Emitter());
  }

  emitter.on(name, handle);

  return this;
};

/**
 * Unsubscribe to the specific event of objects matching the pattern.
 * @function
 * @static
 * @param {RegExp} match - Regular expression for matching uris.
 * @param {String} name - The name of the event to unsubscribe from.
 * @param {Function} handle - The event handle.
 * @return {Function} The live function.
 */
live.unsubscribe = function (match, name, handle) {
  if (match.matches) match = match.matches;

  var string = match.toString();

  var keys = emitters.keys;
  var values = emitters.values;

  var emitter;
  for (var i = 0, len = keys.length; i < len; i++) {
    var key = keys[i];
    if (key.toString() === string) {
      emitter = values[i];
      if (emitter) break;
    }
  }

  if (emitter) emitter.off(name, handle);

  return this;
};

/**
 * Delete a model from the live cache.
 *
 * @param {string} uri A uri.
 *
 * @return {Function} The live function.
 */
live.delete = function (uri) {
  delete cache[uri];
  return this;
};

/**
 * Purge the entire cache.
 *
 * @return {Function} The live function.
 */
live.purge = function () {
  cache = {};
  return this;
};

/**
 * Check if live has an object for the URI in the cache.
 *
 * @param {string} uri A uri.
 *
 * @return {Boolean} True if the object is in the cache.
 */
live.has = function (uri) {
  return !!cache[uri];
};

var EMIT_SYNC = live.EMIT_SYNC = Emitter.EMIT_SYNC;

var ASYNC = live.ASYNC = 'ASYNC';
var SYNC = live.SYNC = 'SYNC';
var ASAP = live.ASAP = 'ASAP';

var PUBLISH = 3;
var UPDATE = 4;

/**
 * @static
 * @see LiveObject
 */
live.Object = LiveObject;

/**
 * @static
 * @see LiveList
 */
live.List = LiveList;

module.exports = live;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-range2":289,"./util/ordered-set":253,"./util/parser":254,"./util/throttle":255,"finally":317,"mout/array/combine":348,"mout/array/difference":350,"mout/array/filter":353,"mout/array/map":359,"mout/lang/isArray":375,"mout/lang/isPlainObject":379,"mout/lang/isRegExp":380,"mout/object/deepMixIn":385,"mout/object/keys":391,"mout/object/pick":394,"mout/string/escapeRegExp":396,"prime":404,"prime/defer":402,"prime/emitter":403}],252:[function(require,module,exports){
/**
 * @module spotify-live/diff
 */
'use strict';

// Original code from: https://github.com/codeparty/arraydiff
// License: MIT
// This has been forked to allow for optimizations and patching operations.

// Based on some rough benchmarking, this algorithm is about O(n^2) worst case,
// and it can compute diffs on random arrays of length 1024 in about 34ms,
// though just a few changes on an array of length 1024 takes about 0.5ms

var splice_ = Array.prototype.splice;
var slice_ = Array.prototype.slice;

var annotate = function annotate(before, after) {
  // Find all items in both the before and after array, and represent them
  // as moves. Many of these "moves" may end up being discarded in the last
  // pass if they are from an index to the same index, but we don't know this
  // up front, since we haven't yet offset the indices.
  //
  // Also keep a map of all the indicies accounted for in the before and after
  // arrays. These maps are used next to create insert and remove diffs.
  var beforeLength = before.length;
  var afterLength = after.length;
  var moves = [];
  var beforeMarked = {};
  var afterMarked = {};
  for (var beforeIndex = 0; beforeIndex < beforeLength; beforeIndex++) {
    var beforeItem = before[beforeIndex];
    for (var afterIndex = 0; afterIndex < afterLength; afterIndex++) {
      if (afterMarked[afterIndex]) continue;
      if (beforeItem !== after[afterIndex]) continue;
      var from = beforeIndex;
      var to = afterIndex;
      var length = 0;
      do {
        beforeMarked[beforeIndex++] = afterMarked[afterIndex++] = true;
        length++;
      } while (beforeIndex < beforeLength && afterIndex < afterLength && before[beforeIndex] === after[afterIndex] && !afterMarked[afterIndex]);
      var moveDiff = {
        type: 'move',
        from: from,
        to: to,
        length: length
      };
      moves.push(moveDiff);
      beforeIndex--;
      break;
    }
  }

  // Create a remove for all of the items in the before array that were
  // not marked as being matched in the after array as well
  var removes = [];
  for (beforeIndex = 0; beforeIndex < beforeLength;) {
    if (beforeMarked[beforeIndex]) {
      beforeIndex++;
      continue;
    }
    var index = beforeIndex;
    var length = 0;
    while (beforeIndex < beforeLength && !beforeMarked[beforeIndex++]) {
      length++;
    }
    var removeDiff = {
      type: 'remove',
      index: index,
      length: length,
      values: slice_.call(before, index, index + length)
    };
    removes.push(removeDiff);
  }

  // Create an insert for all of the items in the after array that were
  // not marked as being matched in the before array as well
  var inserts = [];
  for (afterIndex = 0; afterIndex < afterLength;) {
    if (afterMarked[afterIndex]) {
      afterIndex++;
      continue;
    }
    var index = afterIndex;
    var length = 0;
    while (afterIndex < afterLength && !afterMarked[afterIndex++]) {
      length++;
    }
    var values = slice_.call(after, index, index + length);
    inserts.push({ type: 'insert', index: index, length: length, values: values });
  }

  return [removes, moves, inserts];
};

var offset = function offset(removes, moves, inserts) {

  var insertsLength = inserts.length;
  var removesLength = removes.length;
  var movesLength = moves.length;
  var i, j;

  // Offset subsequent removes and moves by removes
  var count = 0;
  for (i = 0; i < removesLength; i++) {
    var remove = removes[i];
    remove.index -= count;
    count += remove.length;
    for (j = 0; j < movesLength; j++) {
      var move = moves[j];
      if (move.from >= remove.index) move.from -= remove.length;
    }
  }

  // Offset moves by inserts
  for (i = insertsLength; i--;) {
    var insert = inserts[i];
    var length = insert.length;
    for (j = movesLength; j--;) {
      var move = moves[j];
      if (move.to >= insert.index) move.to -= length;
    }
  }

  // Offset the to of moves by later moves
  for (i = movesLength; i-- > 1;) {
    var move = moves[i];
    if (move.to === move.from) continue;
    for (j = i; j--;) {
      var earlier = moves[j];
      if (earlier.to >= move.to) earlier.to -= move.length;
      if (earlier.to >= move.from) earlier.to += move.length;
    }
  }

  // Only output moves that end up having an effect after offsetting
  var outputMoves = [];

  // Offset the from of moves by earlier moves
  for (i = 0; i < movesLength; i++) {
    var move = moves[i];
    if (move.to === move.from) continue;
    outputMoves.push(move);
    for (j = i + 1; j < movesLength; j++) {
      var later = moves[j];
      if (later.from >= move.from) later.from -= move.length;
      if (later.from >= move.to) later.from += move.length;
    }
  }

  // try to reduce the number of move events
  reduceMoves(outputMoves);

  return removes.concat(outputMoves, inserts);
};

var reduceMoves = function reduceMoves(moves) {
  for (var i = 0; i < moves.length; i++) {

    // if we detect a move operation of a lots of items to a near position, we
    // can swap it by a move operation of less items to a farther position
    // (which is going to be much more performant).
    //
    // Example:
    // [1, 2, 3, 4, 5, 6, 7] => [2, 3, 4, 5, 6, 7, 1]
    // We could move [2, 3, 4, 5, 6, 7] one position ahead, but it's better to
    // move [1] six positions behind.
    if (moves[i].length > Math.abs(moves[i].to - moves[i].from)) {
      var from = moves[i].from;
      var to = moves[i].to;
      var length = moves[i].length;

      moves[i].length = Math.abs(moves[i].to - moves[i].from);
      moves[i].from = to;
      moves[i].to = to + length;
    }
  }
};

var insert = function insert(array, index, values) {
  for (var i = 0; i < values.length; i++) {
    if (i in values) {
      var idx = index + i;
      if (array.length < idx) array.length = idx;
      array.splice(idx, 0, values[i]);
    }
  }
  return values;
};

var remove = function remove(array, index, length) {
  return splice_.call(array, index, length);
};

var move = function move(array, from, to, length) {
  var moved = remove(array, from, length);
  insert(array, to, moved);
  return moved;
};

var patch = function patch(array, operations) {
  for (var i = 0; i < operations.length; i++) {
    var operation = operations[i];
    switch (operation.type) {
      case 'move':
        move(array, operation.from, operation.to, operation.length);break;
      case 'remove':
        remove(array, operation.index, operation.length);break;
      case 'insert':
        insert(array, operation.index, operation.values);break;
    }
  }
  return array;
};

var diff = function diff(before, after) {
  var operations = annotate(before, after);
  return offset.apply(this, operations);
};

diff.annotate = annotate;
diff.offset = offset;

diff.remove = remove;
diff.insert = insert;
diff.move = move;
diff.patch = patch;

module.exports = diff;

},{}],253:[function(require,module,exports){
/**
 * @module spotify-live/util/ordered-set
 * @private
 */
'use strict';

// prime

var prime = require('prime');

// mout
var forEach = require('mout/array/forEach');

var Range = require('../../spotify-range2');
var _diff = require('./diff');

var OrderedSet = prime({

  constructor: function constructor(length) {
    if (!length) length = 0;
    this.index = [];
    this.keys = new Array(length);
    this.values = new Array(length);
    this.objectStorage = {};
  },

  get length() {
    return this.keys.length;
  },

  set length(value) {
    this.keys.length = value;
    this.values.length = value;
  },

  forEach: function forEach(fn, ctx) {
    var index = this.index;
    main: for (var k = 0; k < index.length; k++) {
      var range = index[k];
      for (var i = range.start; i < range.end; i++) {
        if (fn.call(ctx, this.values[i], i, this.keys[i], this) === false) break main;
      }
    }
    return this;
  },

  map: function map(fn, ctx) {
    var values = new Array(this.length);
    this.forEach(function (value, index, key) {
      values[index] = fn.call(ctx, value, index, key, this);
    }, this);
    return values;
  },

  copy: function copy(set) {
    this.index = set.index.slice();
    this.keys = set.keys.slice();
    this.values = set.values.slice();
    var length = this.keys.length;
    this.objectStorage = {};
    for (var i = 0; i < length; i++) {
      this.objectStorage[this.keys[i]] = this.values[i];
    }
    return this;
  },

  clone: function clone() {
    return new OrderedSet().copy(this);
  },

  indexOf: function indexOf(key) {
    var index = -1;
    this.forEach(function (v, i, k) {
      if (key === k) {
        index = i;
        return false;
      }
    });
    return index;
  },

  indexOfMany: function indexOfMany(keys) {
    var indexedKeys = {};
    var found = 0;
    var output = [];

    // create a hash with the keys that are going to be searched, so we can
    // access them really fast later
    for (var i = 0; i < keys.length; i++) {
      indexedKeys[keys[i]] = -1;
    }

    this.forEach(function (v, i, k) {
      // If the element one that is being searched, add its position
      // to the output array
      if (k in indexedKeys) {
        indexedKeys[k] = i;
        found++;

        // when we have found all the search keys, we do not need to iterate
        // any more
        if (found >= keys.length) {
          return false;
        }
      }
    });

    for (i = 0; i < keys.length; i++) {
      output[i] = indexedKeys[keys[i]];
    }

    return output;
  },

  valueOf: function valueOf(key) {
    return this.objectStorage[key] || null;
  },

  hasKey: function hasKey(key) {
    return this.objectStorage.hasOwnProperty(key);
  },

  sort: function sort(fn) {
    var keys = this.keys;
    var values = this.values;
    var operations = _diff(values.slice(), values.sort(fn));

    forEach(operations, function (op) {
      // unless something is broken, a sort only produces moves.
      _diff.move(keys, op.from, op.to, op.length);
    });

    return this;
  },

  move: function move(from, to, length) {
    if (from > this.length) return [];
    if (from + length > this.length) length = from - this.length;
    if (to > this.length) to = this.length;
    if (from === to) return [];

    _diff.move(this.keys, from, to, length);
    _diff.move(this.values, from, to, length);

    return this;
  },

  insert: function insert(index, keys, values) {
    if (keys.length !== values.length) throw new Error('length mismatch');

    var range = new Range(index, index + keys.length);
    this.index = range.insert(this.index);

    _diff.insert(this.keys, index, keys);
    _diff.insert(this.values, index, values);

    for (var i = 0, length = keys.length; i < length; i++) {
      this.objectStorage[keys[i]] = values[i];
    }

    return this;
  },

  remove: function remove(index, length) {
    if (index >= this.length) return [];
    if (index + length > this.length) length = this.length;
    var range = new Range(index, index + length);
    this.index = range.extract(this.index);

    for (var i = 0; i < length; i++) {
      delete this.objectStorage[this.keys[i + index]];
    }
    _diff.remove(this.keys, index, length);
    _diff.remove(this.values, index, length);

    return this;
  },

  diff: function diff(target) {
    var operations = _diff.annotate(this.keys, target.keys);

    forEach(operations[0], function (op) {
      // remove
      op.keys = op.values;
      op.values = this.values.slice(op.index, op.index + op.length);
    }, this);

    forEach(operations[1], function (op) {
      // move
      op.keys = op.values;
      op.values = this.values.slice(op.from, op.from + op.length);
    }, this);

    forEach(operations[2], function (op) {
      // insert
      op.keys = op.values;
      op.values = target.values.slice(op.index, op.index + op.length);
    });

    return _diff.offset.apply(_diff, operations);
  },

  patch: function patch(operations) {
    forEach(operations, function (op) {
      switch (op.type) {
        case 'move':
          this.move(op.from, op.to, op.length);break;
        case 'remove':
          this.remove(op.index, op.length);break;
        case 'insert':
          this.insert(op.index, op.keys, op.values);break;
      }
    }, this);
    return this;
  }

});

module.exports = OrderedSet;

},{"../../spotify-range2":289,"./diff":252,"mout/array/forEach":356,"prime":404}],254:[function(require,module,exports){
/**
 * @module spotify-live/util/parser
 */
'use strict';

var normalize = function normalize(value) {
  if (value !== '' && !isNaN(value)) return +value;else if (value === 'true') return true;else if (value === 'false') return false;else if (value === 'null') return null;else if (value === 'undefined') return undefined;
  return value;
};

function escapeForRegExp(str) {
  return str.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
};

var COMMA = ',';
var BMASK = '(';
var EMASK = ')';
var BFILTER = '[';
var EFILTER = ']';
var EQUALS = '=';
var WHITESPACE = '\\s';

var operators = ['=', '!=', '>=', '<=', '>', '<', '^=', '$=', '~=', '|=', '*='];

var keyBlacklist = COMMA + BMASK + EMASK + escapeForRegExp(BFILTER) + escapeForRegExp(EFILTER) + EQUALS + WHITESPACE;
var keyBlacklistCharacterClass = '[^' + keyBlacklist + ']';

var KEY_CHARACTER_REG_EXP = new RegExp(keyBlacklistCharacterClass);
var EXACT_KEY_REG_EXP = new RegExp('^' + keyBlacklistCharacterClass + '+$');

var OPERATORS_REG_EXP = new RegExp(operators.map(escapeForRegExp).join('|'));
var REPLACE_REG_EXP = /\$([\d]+)/;
var RANGE_FILTER_REG_EXP = /^(\d*):(\d*)$/;

var parse = function parse(string, params) {
  if (!params) params = [];

  var selector = { mask: [] };
  var history = [selector];

  var key = '';
  var filter;

  var filterStr = '';
  var left = '';
  var right = '';
  var op = '';

  for (var i = 0; i < string.length + 1; i++) {
    var c = string.charAt(i);

    if (filter) {
      // parse the filter
      filterStr = filterStr.trim();
      if (c === COMMA || c === EFILTER) {
        var matches;
        if (matches = filterStr.match(RANGE_FILTER_REG_EXP)) {
          left = matches[1];
          op = ':';
          right = matches[2];
        } else if (matches = filterStr.match(OPERATORS_REG_EXP)) {
          left = filterStr.substring(0, matches.index);
          op = matches[0];
          right = filterStr.substring(matches.index + op.length);
        } else if (matches = filterStr.match(EXACT_KEY_REG_EXP)) {
          left = matches[0];
        } else {
          throw new SyntaxError('syntax error: `' + filterStr + '` contains characters not valid in a filter');
        }

        filterStr = '';

        var condition = {};

        if (left) {
          var leftMatch = left.match(REPLACE_REG_EXP);
          left = leftMatch ? params[+leftMatch[1]] : normalize(left);
          condition.left = left;
        }

        if (op) condition.op = op;

        if (right) {
          var rightMatch = right.match(REPLACE_REG_EXP);
          right = rightMatch ? params[+rightMatch[1]] : normalize(right);
          condition.right = right;
        }

        if ('left' in condition || 'right' in condition) filter.push(condition);

        right = '';
        left = '';
        op = '';

        if (c === EFILTER) {
          if (filter.length) {
            var filters = selector.filters || (selector.filters = []);
            filters.push(filter);
          }

          filter = null;
        }
        continue;
      }

      filterStr += c;
    } else {
      // parse the key

      if (c && KEY_CHARACTER_REG_EXP.test(c)) {
        // key
        key += c;
      } else if (key && (!c || c === COMMA || c === BMASK || c === BFILTER || c === EMASK)) {
        // end key
        // end word is "a!" or "b(a!)" or "a!,c" or "a!(" or "a!["
        var keyMatch = key.match(REPLACE_REG_EXP);
        // begin a new selector
        history[0].mask.push(selector = { key: keyMatch ? params[+keyMatch[1]] : normalize(key) });
        key = '';
      } else if (c && key) {
        throw new SyntaxError('syntax error: `' + c + '` is not a valid character in a key');
      }

      if (c === BMASK) {
        selector.mask = [];
        history.unshift(selector);
      } else if (c === EMASK) {
        history.shift();
      }

      if (c === BFILTER) {
        filter = [];
      }
    }
  }

  if (history.length !== 1) throw new SyntaxError('syntax error');

  return history[0];
};

/** exports */
module.exports = parse;

},{}],255:[function(require,module,exports){
/**
 * @module spotify-live/util/throttle
 * @private
 */
'use strict';

var defer = require('prime/defer');
var isInteger = function isInteger(n) {
  return typeof n === 'number' && n % 1 === 0;
};

var slice = Array.prototype.slice;

var _throttle = function _throttle(fn, method, context) {
  var queued, args, cancel;

  return function () {
    args = arguments;
    if (!queued) {
      queued = true;
      cancel = method(function (time) {
        queued = false;
        fn.apply(context, slice.call(args).concat(time));
      });
    }
    return cancel;
  };
};

var throttle = function throttle(callback, argument, context) {
  if (isInteger(argument)) return throttle.timeout(callback, argument, context);else return throttle.immediate(callback, argument);
};

throttle.timeout = function (callback, ms, context) {
  return _throttle(callback, function (run) {
    return defer.timeout(run, ms, context);
  }, context);
};

throttle.frame = function (callback, context) {
  return _throttle(callback, function (run) {
    return defer.frame(run, context);
  }, context);
};

throttle.immediate = function (callback, context) {
  return _throttle(callback, function (run) {
    return defer.immediate(run, context);
  }, context);
};

module.exports = throttle;

},{"prime/defer":402}],256:[function(require,module,exports){
'use strict';

var languages = require('./languages.json');

function lookup(language, to) {
  var lang = languages[language];
  if (lang[to]) {
    return lang[to];
  } else {
    return language;
  }
}

module.exports = lookup;
module.exports.all = function () {
  return Object.keys(languages);
};

},{"./languages.json":257}],257:[function(require,module,exports){
module.exports={
  "de": {
    "smartling": "de-DE"
  },
  "el": {
    "smartling": "el-GR"
  },
  "en": {
    "smartling": "en-GB"
  },
  "es": {
    "numeral": "es-ES",
    "smartling": "es-ES"
  },
  "es-419": {
    "moment": "es",
    "numeral": "es-ES",
    "smartling": "es-LA"
  },
  "fi": {
    "smartling": "fi-FI"
  },
  "fr": {
    "smartling": "fr-FR"
  },
  "fr-CA": {
    "smartling": "fr-CA",
    "moment": "fr-ca"
  },
  "hu": {
    "smartling": "hu-HU"
  },
  "id": {
    "smartling": "id-ID"
  },
  "it": {
    "smartling": "it-IT"
  },
  "ja": {
    "smartling": "ja-JP"
  },
  "nl": {
    "numeral": "nl-nl",
    "smartling": "nl-NL"
  },
  "pl": {
    "smartling": "pl-PL"
  },
  "pt-BR": {
    "moment": "pt-br",
    "numeral": "pt-br",
    "smartling": "pt-BR"
  },
  "sv": {
    "smartling": "sv-SE"
  },
  "tr": {
    "smartling": "tr-TR"
  },
  "zh-Hant": {
    "moment": "zh-tw",
    "smartling": "zh-TW"
  },
  "zsm": {
    "moment": "ms-my",
    "smartling": "ms-MY"
  }
}
},{}],258:[function(require,module,exports){
'use strict';

var schemer = require('./schemer');
var cosmos = require('spotify-cosmos-api');
var debug = require('debug');

var id = 0;

module.exports = function log(schema, data) {
  /*eslint-disable camelcase */
  var body = schemer(schema, Object.assign({}, {
    message_name: schema.name,
    message_version: schema.schema_version
  }, data));

  // Logging cosmos endpoint requires all values to be strings.
  body.fields = body.fields.map(function (f) {
    if (typeof f === 'string') return f;
    if (f == null) return '';
    return JSON.stringify(f);
  });

  var qualifiedName = schema.name + schema.schema_version;
  /*eslint-enable camelcase */

  var messageDebug = debug('spotify-logger:' + qualifiedName);
  var requestId = ++id;

  messageDebug('REQ %s#%s %s', qualifiedName, requestId, JSON.stringify(body));

  cosmos.resolver.post({
    url: 'sp://logging/v1/log',
    body: body
  }, function (error, response) {
    if (error) return console.error(error, body);
    messageDebug('RES %s#%s %d', qualifiedName, requestId, response.getStatusCode());
  });
};

},{"./schemer":259,"debug":314,"spotify-cosmos-api":416}],259:[function(require,module,exports){
'use strict';

var validation = require('../vendor/avro-trunk/lang/js/lib/validator');
var debug = require('debug')(require('../package.json').name + ':');

module.exports = function (schema, data) {

  debug(schema.name);

  var name = data.message_name;
  var version = data.message_version;
  var copy = Object.assign({}, data);

  if (version !== schema.schema_version) throw new Error('' + 'Invalid message version: received Message with message_version ' + version + ' but the Schema requires version ' + schema.schema_version);

  // Create positional array of field values as required by cosmos and
  // log-parser, and also create an avro Field for each value to allow
  // validation.
  var fields = schema.fields.map(function (f) {
    var type = f.type;
    var value = copy[f.name];

    // If field is a union, attempt to infer the type by grabbing the first
    // non-null type from the schema.
    if (Array.isArray(f.type)) {
      copy[f.name] = {};
      var firstNoneNullType = type.filter(function (t) {
        return t !== 'null';
      })[0];
      copy[f.name][firstNoneNullType] = value;
      debug('union `%s` (%s) : `%s`', f.name, firstNoneNullType, value);
    } else {
      copy[f.name] = value;
      debug('field `%s` : `%s`', f.name, value);
    }
    return value === undefined ? f.default : value;
  })
  // remove name, version
  .slice(2);

  validation.Validator.validate(schema, copy);

  return {
    message: name,
    version: version,
    fields: fields
  };
};

module.exports.Validator = validation.Validator;
module.exports.ProtocolValidator = validation.ProtocolValidator;

},{"../package.json":263,"../vendor/avro-trunk/lang/js/lib/validator":267,"debug":314}],260:[function(require,module,exports){
'use strict';

var schema = require('../schemas/ClientEvent3.json');
var log = require('../lib/log');

module.exports = {
  schema: schema,
  log: log.bind(null, schema)
};

},{"../lib/log":258,"../schemas/ClientEvent3.json":264}],261:[function(require,module,exports){
'use strict';

var schema = require('../schemas/UIInteraction4.json');
var log = require('../lib/log');

module.exports = {
  schema: schema,
  log: log.bind(null, schema)
};

},{"../lib/log":258,"../schemas/UIInteraction4.json":265}],262:[function(require,module,exports){
'use strict';

var schema = require('../schemas/UserDragAndDropInteraction1.json');
var log = require('../lib/log');

module.exports = {
  schema: schema,
  log: log.bind(null, schema)
};

},{"../lib/log":258,"../schemas/UserDragAndDropInteraction1.json":266}],263:[function(require,module,exports){
module.exports={
  "name": "spotify-logger",
  "version": "1.0.0",
  "description": "Generate / consume log-parser schemas in JS",
  "bin": {
    "spotify-logger-schemas-generator": "bin/schemas-generator",
    "spotify-logger-messages-generator": "bin/messages-generator"
  },
  "main": "lib/log.js",
  "dependencies": {},
  "devDependencies": {},
  "scripts": {
    "dev": "echo App scripts have been removed. Please see docs/app-development.md for more information. && exit 1",
    "prod": "echo App scripts have been removed. Please see docs/app-development.md for more information. && exit 1",
    "spa": "echo App scripts have been removed. Please see docs/app-development.md for more information. && exit 1",
    "enable": "echo App scripts have been removed. Please see docs/app-development.md for more information. && exit 1"
  },
  "author": "Drew Petersen <drewp@spotify.com>",
  "license": "UNLICENSED",
  "private": true
}
},{}],264:[function(require,module,exports){
module.exports={
  "type": "record",
  "name": "ClientEvent",
  "namespace": "com.spotify.Message",
  "doc": "A generic client event primarily used by Stitch Apps",
  "fields": [
    {
      "name": "message_name",
      "type": "string"
    },
    {
      "name": "message_version",
      "type": "int"
    },
    {
      "name": "source",
      "type": [
        "null",
        "string"
      ],
      "doc": "Source which generated the event, will mostly be set to the App-ID",
      "default": null
    },
    {
      "name": "context",
      "type": [
        "null",
        "string"
      ],
      "doc": "Optional context within the app",
      "default": null
    },
    {
      "name": "event",
      "type": [
        "null",
        "string"
      ],
      "doc": "Event name",
      "default": null
    },
    {
      "name": "event_version",
      "type": [
        "null",
        "string"
      ],
      "doc": "Optional event version, can be used as a version or sub-type",
      "default": null
    },
    {
      "name": "test_version",
      "type": [
        "null",
        "string"
      ],
      "doc": "Optional test case if A/B testing",
      "default": null
    },
    {
      "name": "source_version",
      "type": [
        "null",
        "string"
      ],
      "doc": "The version of the app",
      "default": null
    },
    {
      "name": "source_vendor",
      "type": [
        "null",
        "string"
      ],
      "doc": "The app vendor",
      "default": null
    },
    {
      "name": "json_data",
      "type": [
        "null",
        "string"
      ],
      "doc": "Additional JSON data specific to the event being sent",
      "default": null
    }
  ],
  "schema_version": 3
}
},{}],265:[function(require,module,exports){
module.exports={
  "type": "record",
  "name": "UIInteraction",
  "namespace": "com.spotify.Message",
  "doc": "A UI interaction log",
  "fields": [
    {
      "name": "message_name",
      "type": "string"
    },
    {
      "name": "message_version",
      "type": "int"
    },
    {
      "name": "request_id",
      "type": [
        "null",
        "string"
      ],
      "doc": "Request ID from Spaces Log",
      "default": null
    },
    {
      "name": "feature_id",
      "type": [
        "null",
        "string"
      ],
      "doc": "Uri of the feature page (e.g., Music, Start Page, etc.)",
      "default": null
    },
    {
      "name": "section_id",
      "type": [
        "null",
        "string"
      ],
      "doc": "Section or block of the page (e.g., Early Morning)",
      "default": null
    },
    {
      "name": "block_index",
      "type": [
        "null",
        "int"
      ],
      "doc": "Index of block on page",
      "default": null
    },
    {
      "name": "item_index",
      "type": [
        "null",
        "int"
      ],
      "doc": "Index of item in block",
      "default": null
    },
    {
      "name": "target_uri",
      "type": [
        "null",
        "string"
      ],
      "doc": "Destination of interaction",
      "default": null
    },
    {
      "name": "interaction_type",
      "type": [
        "null",
        "string"
      ],
      "doc": "Type of interaction (e.g., hit, swipe, hold, hover, etc.)",
      "default": null
    },
    {
      "name": "user_intent",
      "type": [
        "null",
        "string"
      ],
      "doc": "Grouping of interactions based on user intent (e.g., play, navigate-forward, navigate-back)",
      "default": null
    },
    {
      "name": "timestamp",
      "type": [
        "null",
        "double"
      ],
      "doc": "Unix timestamp of event",
      "default": null
    }
  ],
  "schema_version": 4
}
},{}],266:[function(require,module,exports){
module.exports={
  "type": "record",
  "name": "UserDragAndDropInteraction",
  "namespace": "com.spotify.Message",
  "doc": "Logged whenever a user drags and drops (currently desktop only) an item in the client. Only completed drag and drops are logged and not canceled/failed ones.",
  "fields": [
    {
      "name": "message_name",
      "type": "string"
    },
    {
      "name": "message_version",
      "type": "int"
    },
    {
      "name": "item_type",
      "type": [
        "null",
        "string"
      ],
      "doc": "Type of item, eg \"track\".",
      "default": null
    },
    {
      "name": "item_uri",
      "type": [
        "null",
        "string"
      ],
      "doc": "Uri of item that was dropped and only the first if multiple.",
      "default": null
    },
    {
      "name": "number_items",
      "type": [
        "null",
        "long"
      ],
      "doc": "Number of items dropped.",
      "default": null
    },
    {
      "name": "source_view_uri",
      "type": [
        "null",
        "string"
      ],
      "doc": "View uri from where the drag started, eg \"spotify:app:playlist-desktop\".",
      "default": null
    },
    {
      "name": "source_uri",
      "type": [
        "null",
        "string"
      ],
      "doc": "Uri of the context from where the drag started, eg: \"spotify:user:spotify:playlist:1m6DKwKNM1YLcm3OX6RzJg\".",
      "default": null
    },
    {
      "name": "source_index",
      "type": [
        "null",
        "long"
      ],
      "doc": "Index of the item from where the drag started.",
      "default": null
    },
    {
      "name": "source_component",
      "type": [
        "null",
        "string"
      ],
      "doc": "Id of the component from where the drag started, eg: \"header/title\" if the user dragged a playlist via the playlist title in the header.",
      "default": null
    },
    {
      "name": "target_view_uri",
      "type": [
        "null",
        "string"
      ],
      "doc": "View uri where the drop ended, eg \"spotify:app:zlink\".",
      "default": null
    },
    {
      "name": "target_uri",
      "type": [
        "null",
        "string"
      ],
      "doc": "Uri of the context where the drop ended, \"spotify:user:spotify:rootlist\".",
      "default": null
    },
    {
      "name": "target_index",
      "type": [
        "null",
        "long"
      ],
      "doc": "Index where dropped.",
      "default": null
    },
    {
      "name": "target_component",
      "type": [
        "null",
        "string"
      ],
      "doc": "Id of the component where the drop ended, eg: \"player/queue\" if dropped on the Queue button in the player component.",
      "default": null
    },
    {
      "name": "ms_duration",
      "type": [
        "null",
        "long"
      ],
      "doc": "The duration in milliseconds from the start of the drag until the end of the drop.",
      "default": null
    }
  ],
  "schema_version": 1
}
},{}],267:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

// Licensed to the Apache Software Foundation (ASF) under one or more
// contributor license agreements.  See the NOTICE file distributed with
// this work for additional information regarding copyright ownership.
// The ASF licenses this file to You under the Apache License, Version 2.0
// (the "License"); you may not use this file except in compliance with
// the License.  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

if (typeof require !== 'undefined') {
  var _ = require("underscore");
}

var AvroSpec = {
  PrimitiveTypes: ['null', 'boolean', 'int', 'long', 'float', 'double', 'bytes', 'string'],
  ComplexTypes: ['record', 'enum', 'array', 'map', 'union', 'fixed']
};
AvroSpec.Types = AvroSpec.PrimitiveTypes.concat(AvroSpec.ComplexTypes);

var InvalidSchemaError = function InvalidSchemaError(msg) {
  return new Error('InvalidSchemaError: ' + msg);
};
var InvalidProtocolError = function InvalidProtocolError(msg) {
  return new Error('InvalidProtocolError: ' + msg);
};
var ValidationError = function ValidationError(msg) {
  return new Error('ValidationError: ' + msg);
};
var ProtocolValidationError = function ProtocolValidationError(msg) {
  return new Error('ProtocolValidationError: ' + msg);
};

function Record(name, namespace, fields) {
  function validateArgs(name, namespace, fields) {
    if (!_.isString(name)) {
      throw new InvalidSchemaError('Record name must be string');
    }

    if (!_.isNull(namespace) && !_.isUndefined(namespace) && !_.isString(namespace)) {
      throw new InvalidSchemaError('Record namespace must be string or null');
    }

    if (!_.isArray(fields)) {
      throw new InvalidSchemaError('Record name must be string');
    }
  }

  validateArgs(name, namespace, fields);

  this.name = name;
  this.namespace = namespace;
  this.fields = fields;
}

function makeFullyQualifiedTypeName(schema, namespace) {
  var typeName = null;
  if (_.isString(schema)) {
    typeName = schema;
  } else if (_.isObject(schema)) {
    if (_.isString(schema.namespace)) {
      namespace = schema.namespace;
    }
    if (_.isString(schema.name)) {
      typeName = schema.name;
    } else if (_.isString(schema.type)) {
      typeName = schema.type;
    }
    /** BEGIN CHANGE BY drewp **/
    else if (_.has(schema, 'valueSchema') && _.isString(schema.valueSchema.type)) {
        typeName = makeFullyQualifiedTypeName(schema.valueSchema, namespace);
      }
    /** END CHANGE BY drewp **/
  } else {
      throw new InvalidSchemaError('unable to determine fully qualified type name from schema ' + JSON.stringify(schema) + ' in namespace ' + namespace);
    }

  if (!_.isString(typeName)) {
    throw new InvalidSchemaError('unable to determine type name from schema ' + JSON.stringify(schema) + ' in namespace ' + namespace);
  }

  if (typeName.indexOf('.') !== -1) {
    return typeName;
  } else if (_.contains(AvroSpec.PrimitiveTypes, typeName)) {
    return typeName;
  } else if (_.isString(namespace)) {
    return namespace + '.' + typeName;
  } else {
    return typeName;
  }
}

function Union(typeSchemas, namespace) {
  this.branchNames = function () {
    return _.map(typeSchemas, function (typeSchema) {
      return makeFullyQualifiedTypeName(typeSchema, namespace);
    });
  };

  function validateArgs(typeSchemas) {
    if (!_.isArray(typeSchemas) || _.isEmpty(typeSchemas)) {
      throw new InvalidSchemaError('Union must have at least 1 branch');
    }
  }

  validateArgs(typeSchemas);

  this.typeSchemas = typeSchemas;
  this.namespace = namespace;
}

function Enum(symbols) {

  function validateArgs(symbols) {
    if (!_.isArray(symbols)) {
      throw new InvalidSchemaError('Enum must have array of symbols, got ' + JSON.stringify(symbols));
    }
    if (!_.all(symbols, function (symbol) {
      return _.isString(symbol);
    })) {
      throw new InvalidSchemaError('Enum symbols must be strings, got ' + JSON.stringify(symbols));
    }
  }

  validateArgs(symbols);

  this.symbols = symbols;
}

function AvroArray(itemSchema) {

  function validateArgs(itemSchema) {
    if (_.isNull(itemSchema) || _.isUndefined(itemSchema)) {
      throw new InvalidSchemaError('Array "items" schema should not be null or undefined');
    }
  }

  validateArgs(itemSchema);

  this.itemSchema = itemSchema;
}

function Map(valueSchema) {
  function validateArgs(valueSchema) {
    if (_.isNull(valueSchema) || _.isUndefined(valueSchema)) {
      throw new InvalidSchemaError('Map "values" schema should not be null or undefined');
    }
  }

  validateArgs(valueSchema);

  this.valueSchema = valueSchema;
}

function Field(name, schema) {
  function validateArgs(name, schema) {
    if (!_.isString(name)) {
      throw new InvalidSchemaError('Field name must be string');
    }
  }

  this.name = name;
  this.schema = schema;
}

function Primitive(type) {
  function validateArgs(type) {
    if (!_.isString(type)) {
      throw new InvalidSchemaError('Primitive type name must be a string');
    }

    if (!_.contains(AvroSpec.PrimitiveTypes, type)) {
      throw new InvalidSchemaError('Primitive type must be one of: ' + JSON.stringify(AvroSpec.PrimitiveTypes) + '; got ' + type);
    }
  }

  validateArgs(type);

  this.type = type;
}

function Validator(schema, namespace, namedTypes) {
  this.validate = function (obj) {
    return _validate(this.schema, obj);
  };

  var _validate = function _validate(schema, obj) {
    if (schema instanceof Record) {
      return _validateRecord(schema, obj);
    } else if (schema instanceof Union) {
      return _validateUnion(schema, obj);
    } else if (schema instanceof Enum) {
      return _validateEnum(schema, obj);
    } else if (schema instanceof AvroArray) {
      return _validateArray(schema, obj);
    } else if (schema instanceof Map) {
      return _validateMap(schema, obj);
    } else if (schema instanceof Primitive) {
      return _validatePrimitive(schema, obj);
    } else {
      throw new InvalidSchemaError('validation not yet implemented: ' + JSON.stringify(schema));
    }
  };

  var _validateRecord = function _validateRecord(schema, obj) {
    if (!_.isObject(obj) || _.isArray(obj)) {
      throw new ValidationError('Expected record Javascript type to be non-array object, got ' + JSON.stringify(obj));
    }

    var schemaFieldNames = _.pluck(schema.fields, 'name').sort();
    var objFieldNames = _.keys(obj).sort();
    if (!_.isEqual(schemaFieldNames, objFieldNames)) {
      throw new ValidationError('Expected record fields ' + JSON.stringify(schemaFieldNames) + '; got ' + JSON.stringify(objFieldNames));
    }

    return _.all(schema.fields, function (field) {
      return _validate(field.schema, obj[field.name]);
    });
  };

  var _validateUnion = function _validateUnion(schema, obj) {
    if (_.isObject(obj)) {
      if (_.isArray(obj)) {
        throw new ValidationError('Expected union Javascript type to be non-array object (or null), got ' + JSON.stringify(obj));
      } else if (_.size(obj) !== 1) {
        throw new ValidationError('Expected union Javascript object to be object with exactly 1 key (or null), got ' + JSON.stringify(obj));
      } else {
        var unionBranch = _.keys(obj)[0];
        if (unionBranch === "") {
          throw new ValidationError('Expected union Javascript object to contain non-empty string branch, got ' + JSON.stringify(obj));
        }
        if (_.contains(schema.branchNames(), unionBranch)) {
          return true;
        } else {
          throw new ValidationError('Expected union branch to be one of ' + JSON.stringify(schema.branchNames()) + '; got ' + JSON.stringify(unionBranch));
        }
      }
    } else if (_.isNull(obj)) {
      if (_.contains(schema.branchNames(), 'null')) {
        return true;
      } else {
        throw new ValidationError('Expected union branch to be one of ' + JSON.stringify(schema.branchNames()) + '; got ' + JSON.stringify(obj));
      }
    } else {
      throw new ValidationError('Expected union Javascript object to be non-array object of size 1 or null, got ' + JSON.stringify(obj));
    }
  };

  var _validateEnum = function _validateEnum(schema, obj) {
    if (_.isString(obj)) {
      if (_.contains(schema.symbols, obj)) {
        return true;
      } else {
        throw new ValidationError('Expected enum value to be one of ' + JSON.stringify(schema.symbols) + '; got ' + JSON.stringify(obj));
      }
    } else {
      throw new ValidationError('Expected enum Javascript object to be string, got ' + JSON.stringify(obj));
    }
  };

  var _validateArray = function _validateArray(schema, obj) {
    if (_.isArray(obj)) {
      return _.all(obj, function (member) {
        return _validate(schema.itemSchema, member);
      });
    } else {
      throw new ValidationError('Expected array Javascript object to be array, got ' + JSON.stringify(obj));
    }
  };

  var _validateMap = function _validateMap(schema, obj) {
    if (_.isObject(obj) && !_.isArray(obj)) {
      return _.all(obj, function (value) {
        return _validate(schema.valueSchema, value);
      });
    } else if (_.isArray(obj)) {
      throw new ValidationError('Expected map Javascript object to be non-array object, got array ' + JSON.stringify(obj));
    } else {
      throw new ValidationError('Expected map Javascript object to be non-array object, got ' + JSON.stringify(obj));
    }
  };

  var _validatePrimitive = function _validatePrimitive(schema, obj) {
    switch (schema.type) {
      case 'null':
        if (_.isNull(obj) || _.isUndefined(obj)) {
          return true;
        } else {
          throw new ValidationError('Expected Javascript null or undefined for Avro null, got ' + JSON.stringify(obj));
        }
        break;
      case 'boolean':
        if (_.isBoolean(obj)) {
          return true;
        } else {
          throw new ValidationError('Expected Javascript boolean for Avro boolean, got ' + JSON.stringify(obj));
        }
        break;
      case 'int':
        if (_.isNumber(obj) && Math.floor(obj) === obj && Math.abs(obj) <= Math.pow(2, 31)) {
          return true;
        } else {
          throw new ValidationError('Expected Javascript int32 number for Avro int, got ' + JSON.stringify(obj));
        }
        break;
      case 'long':
        if (_.isNumber(obj) && Math.floor(obj) === obj && Math.abs(obj) <= Math.pow(2, 63)) {
          return true;
        } else {
          throw new ValidationError('Expected Javascript int64 number for Avro long, got ' + JSON.stringify(obj));
        }
        break;
      case 'float':
        if (_.isNumber(obj)) {
          // TODO: handle NaN?
          return true;
        } else {
          throw new ValidationError('Expected Javascript float number for Avro float, got ' + JSON.stringify(obj));
        }
        break;
      case 'double':
        if (_.isNumber(obj)) {
          // TODO: handle NaN?
          return true;
        } else {
          throw new ValidationError('Expected Javascript double number for Avro double, got ' + JSON.stringify(obj));
        }
        break;
      case 'bytes':
        throw new InvalidSchemaError('not yet implemented: ' + schema.type);
      case 'string':
        if (_.isString(obj)) {
          // TODO: handle NaN?
          return true;
        } else {
          throw new ValidationError('Expected Javascript string for Avro string, got ' + JSON.stringify(obj));
        }
        break;
      default:
        throw new InvalidSchemaError('unrecognized primitive type: ' + schema.type);
    }
  };

  // TODO: namespace handling is rudimentary. multiple namespaces within a certain nested schema definition
  // are probably buggy.
  var _namedTypes = namedTypes || {};
  var _saveNamedType = function _saveNamedType(fullyQualifiedTypeName, schema) {
    if (_.has(_namedTypes, fullyQualifiedTypeName)) {
      if (!_.isEqual(_namedTypes[fullyQualifiedTypeName], schema)) {
        throw new InvalidSchemaError('conflicting definitions for type ' + fullyQualifiedTypeName + ': ' + JSON.stringify(_namedTypes[fullyQualifiedTypeName]) + ' and ' + JSON.stringify(schema));
      }
    } else {
      _namedTypes[fullyQualifiedTypeName] = schema;
    }
  };

  var _lookupTypeByFullyQualifiedName = function _lookupTypeByFullyQualifiedName(fullyQualifiedTypeName) {
    if (_.has(_namedTypes, fullyQualifiedTypeName)) {
      return _namedTypes[fullyQualifiedTypeName];
    } else {
      return null;
    }
  };

  var _parseNamedType = function _parseNamedType(schema, namespace) {
    if (_.contains(AvroSpec.PrimitiveTypes, schema)) {
      return new Primitive(schema);
    } else if (!_.isNull(_lookupTypeByFullyQualifiedName(makeFullyQualifiedTypeName(schema, namespace)))) {
      return _lookupTypeByFullyQualifiedName(makeFullyQualifiedTypeName(schema, namespace));
    } else {
      throw new InvalidSchemaError('unknown type name: ' + JSON.stringify(schema) + '; known type names are ' + JSON.stringify(_.keys(_namedTypes)));
    }
  };

  var _parseSchema = function _parseSchema(schema, parentSchema, namespace) {
    if (_.isNull(schema) || _.isUndefined(schema)) {
      throw new InvalidSchemaError('schema is null, in parentSchema: ' + JSON.stringify(parentSchema));
    } else if (_.isString(schema)) {
      return _parseNamedType(schema, namespace);
    } else if (_.isObject(schema) && !_.isArray(schema)) {
      if (schema.type === 'record') {
        var newRecord = new Record(schema.name, schema.namespace, _.map(schema.fields, function (field) {
          return new Field(field.name, _parseSchema(field.type, schema, schema.namespace || namespace));
        }));
        _saveNamedType(makeFullyQualifiedTypeName(schema, namespace), newRecord);
        return newRecord;
      } else if (schema.type === 'enum') {
        if (_.has(schema, 'symbols')) {
          var newEnum = new Enum(schema.symbols);
          _saveNamedType(makeFullyQualifiedTypeName(schema, namespace), newEnum);
          return newEnum;
        } else {
          throw new InvalidSchemaError('enum must specify symbols, got ' + JSON.stringify(schema));
        }
      } else if (schema.type === 'array') {
        if (_.has(schema, 'items')) {
          return new AvroArray(_parseSchema(schema.items, schema, namespace));
        } else {
          throw new InvalidSchemaError('array must specify "items" schema, got ' + JSON.stringify(schema));
        }
      } else if (schema.type === 'map') {
        if (_.has(schema, 'values')) {
          return new Map(_parseSchema(schema.values, schema, namespace));
        } else {
          throw new InvalidSchemaError('map must specify "values" schema, got ' + JSON.stringify(schema));
        }
      } else if (_.has(schema, 'type') && _.contains(AvroSpec.PrimitiveTypes, schema.type)) {
        return _parseNamedType(schema.type, namespace);
      } else {
        throw new InvalidSchemaError('not yet implemented: ' + schema.type);
      }
    } else if (_.isArray(schema)) {
      if (_.isEmpty(schema)) {
        throw new InvalidSchemaError('unions must have at least 1 branch');
      }
      var branchTypes = _.map(schema, function (branchType) {
        return _parseSchema(branchType, schema, namespace);
      });
      return new Union(branchTypes, namespace);
    } else {
      throw new InvalidSchemaError('unexpected Javascript type for schema: ' + (typeof schema === 'undefined' ? 'undefined' : _typeof(schema)));
    }
  };

  this.rawSchema = schema;
  this.schema = _parseSchema(schema, null, namespace);
}

Validator.validate = function (schema, obj) {
  return new Validator(schema).validate(obj);
};

function ProtocolValidator(protocol) {
  this.validate = function (typeName, obj) {
    var fullyQualifiedTypeName = makeFullyQualifiedTypeName(typeName, protocol.namespace);
    if (!_.has(_typeSchemaValidators, fullyQualifiedTypeName)) {
      throw new ProtocolValidationError('Protocol does not contain definition for type ' + JSON.stringify(fullyQualifiedTypeName) + ' (fully qualified from input "' + typeName + '"); known types are ' + JSON.stringify(_.keys(_typeSchemaValidators)));
    }
    return _typeSchemaValidators[fullyQualifiedTypeName].validate(obj);
  };

  var _typeSchemaValidators = {};
  var _initSchemaValidators = function _initSchemaValidators(protocol) {
    var namedTypes = {};
    if (!_.has(protocol, 'protocol') || !_.isString(protocol.protocol)) {
      throw new InvalidProtocolError('Protocol must contain a "protocol" attribute with a string value');
    }
    if (_.isArray(protocol.types)) {
      _.each(protocol.types, function (typeSchema) {
        var schemaValidator = new Validator(typeSchema, protocol.namespace, namedTypes);
        var fullyQualifiedTypeName = makeFullyQualifiedTypeName(typeSchema, protocol.namespace);
        _typeSchemaValidators[fullyQualifiedTypeName] = schemaValidator;
      });
    }
  };

  _initSchemaValidators(protocol);
}

ProtocolValidator.validate = function (protocol, typeName, obj) {
  return new ProtocolValidator(protocol).validate(typeName, obj);
};

if (typeof exports !== 'undefined') {
  exports['Validator'] = Validator;
  exports['ProtocolValidator'] = ProtocolValidator;
}

},{"underscore":447}],268:[function(require,module,exports){
'use strict';

/**
 * Object representing state of an app.
 *
 * @param {String} uri Spotify URI of app.
 * @constructor
 */

function AppState(uri) {
  /**
   * Spotify URI.
   *
   * @type {String}
   */
  this._uri = undefined;

  /**
   * String identifying what requested a state.
   *
   * @type {String}
   */
  this._referrer = undefined;

  if (uri !== undefined) {
    this.setURI(uri);
  }
}

/**
 * Create new instance of AppState based on JSON string.
 *
 * @param {String} json Serialized representation of AppState object.
 * @return {AppState} Instance of AppState.
 */
AppState.unserialize = function (json) {
  var s = JSON.parse(json);
  var a = new AppState();
  a.setURI(s.uri);
  a.setReferrer(s.referrer);
  return a;
};

/**
 * Test if another object is considered equal to this.
 *
 * @param {AppState} state AppState instance to compare.
 */
AppState.prototype.equals = function (state) {
  return typeof this._uri === 'string' && state instanceof AppState && this._uri === state._uri && this._referrer === state._referrer;
};

/**
 * Get App identifier.
 *
 * @return {String} Id of app contained in URI.
 */
AppState.prototype.getAppId = function () {
  var uri = this.getURI();
  var parts = uri.split(':');
  if (parts.length < 3) {
    return undefined;
  }
  if (parts[1] !== 'app') {
    return undefined;
  }
  if (parts[2] === '') {
    return undefined;
  }
  return parts[2];
};

/**
 * Get Referrer value.
 *
 * @return {String} Referrer value as string.
 */
AppState.prototype.getReferrer = function () {
  return this._referrer;
};

/**
 * Get URI value.
 *
 * @return {String} URI as string.
 */
AppState.prototype.getURI = function () {
  if (this._uri === undefined) {
    throw new Error('URI not set');
  }
  return this._uri;
};

/**
 * Create serialized representation of this instance.
 *
 * @return {String} Serialized representation of AppState object.
 */
AppState.prototype.serialize = function () {
  return JSON.stringify({
    uri: this.getURI(),
    referrer: this.getReferrer()
  });
};

/**
 * Set Referrer value.
 *
 * @param {String} referrer Referrer string.
 */
AppState.prototype.setReferrer = function (referrer) {
  this._referrer = referrer;
};

/**
 * Set URI value.
 *
 * @param {String} uri Spotify URI for app.
 */
AppState.prototype.setURI = function (uri) {
  if (typeof uri !== 'string') {
    throw new TypeError('URI must be string');
  }
  this._uri = uri;
};

module.exports = AppState;

},{}],269:[function(require,module,exports){
'use strict';

module.exports = {
  AppState: require('./app-state'),
  Navigator: require('./navigator')
};

},{"./app-state":268,"./navigator":270}],270:[function(require,module,exports){
(function (global){
'use strict';

var inherit = require('spotify-inheritance/inherit');
var EventEmitter = require('spotify-eventemitter');
var AppState = require('./app-state');
var _global = global.top || global;

/**
 * Class containing methods for navigating.
 *
 * @constructor
 */
function Navigator() {
  EventEmitter.call(this);

  /**
   * Locally bound handler function for message event on global.
   *
   * @type {Function}
   */
  this._messageHandler = this._messageHandler.bind(this);
}

inherit(Navigator, EventEmitter);

/**
 * Maps constants to string values of known events.
 */
Navigator.EVENTS = {
  OPEN_STATE: 'navigation_open_state'
};

/**
 * Identify posted message and trigger relevant callbacks
 * based on the message contents.
 *
 * @param {Object} message Message object caused by postMessage.
 */
Navigator.prototype._messageHandler = function (message) {
  if (!message.data.type) {
    return;
  }
  var name = message.data.type;
  if (name === Navigator.EVENTS.OPEN_STATE) {
    var appState = AppState.unserialize(message.data.state);
    this.emitSync(name, { state: appState });
  }
};

/**
 * Start listening to messages.
 */
Navigator.prototype.attachListener = function () {
  _global.addEventListener('message', this._messageHandler);
};

/**
 * Stop listening to messages.
 */
Navigator.prototype.detachListener = function () {
  _global.removeEventListener('message', this._messageHandler);
};

/**
 * Send an open request message.
 *
 * @param {AppState} state AppState instance to base open action on.
 */
Navigator.prototype.requestOpenState = function (state) {
  _global.postMessage({
    type: Navigator.EVENTS.OPEN_STATE,
    state: state.serialize()
  }, '*');
};

module.exports = Navigator;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./app-state":268,"spotify-eventemitter":422,"spotify-inheritance/inherit":425}],271:[function(require,module,exports){
'use strict';

module.exports = function (numeral) {
  return {
    delimiters: {
      thousands: ',',
      decimal: '.'
    },
    abbreviations: {
      thousand: 'k',
      million: 'm',
      billion: 'b',
      trillion: 't'
    },
    ordinal: function ordinal(number) {
      var b = number % 10;
      return ~ ~(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
    },
    currency: {
      symbol: '$'
    }
  };
};

},{}],272:[function(require,module,exports){
'use strict';

var numeral = require('./numeraljs/numeral');
var locales = require('../spotify-locales');

module.exports = function (currentLanguage) {

  // We need to explicitly require all languages listed in spotify-locales
  // so that Quickstart can access them at runtime
  // (dynamic paths can't be cached).
  var languages = {
    'de': require('./numeraljs/languages/de'),
    // Custom en.js file
    'en': require('./en')(numeral),
    // es-419 falls back to es-es in Numeral.js
    'es-ES': require('./numeraljs/languages/es-ES'),
    'fi': require('./numeraljs/languages/fi'),
    'fr': require('./numeraljs/languages/fr'),
    'fr-CA': require('./numeraljs/languages/fr-CA'),
    'hu': require('./numeraljs/languages/hu'),
    'id': require('./numeraljs/languages/id'),
    'it': require('./numeraljs/languages/it'),
    'ja': require('./numeraljs/languages/ja'),
    'nl-nl': require('./numeraljs/languages/nl-nl'),
    'pl': require('./numeraljs/languages/pl'),
    'pt-br': require('./numeraljs/languages/pt-br'),
    'sv': require('./numeraljs/languages/sv'),
    'tr': require('./numeraljs/languages/tr')
  };

  var numeralLocale = locales(currentLanguage, 'numeral');
  if (!languages[numeralLocale]) {
    numeralLocale = 'en';
  }
  numeral.language(numeralLocale, languages[numeralLocale]);
  numeral.language(numeralLocale);

  return numeral;
};

},{"../spotify-locales":256,"./en":271,"./numeraljs/languages/de":273,"./numeraljs/languages/es-ES":274,"./numeraljs/languages/fi":275,"./numeraljs/languages/fr":277,"./numeraljs/languages/fr-CA":276,"./numeraljs/languages/hu":278,"./numeraljs/languages/id":279,"./numeraljs/languages/it":280,"./numeraljs/languages/ja":281,"./numeraljs/languages/nl-nl":282,"./numeraljs/languages/pl":283,"./numeraljs/languages/pt-br":284,"./numeraljs/languages/sv":285,"./numeraljs/languages/tr":286,"./numeraljs/numeral":287}],273:[function(require,module,exports){
'use strict';

/*!
 * numeral.js language configuration
 * language : German (de) – generally useful in Germany, Austria, Luxembourg, Belgium
 * author : Marco Krage : https://github.com/sinky
 */
(function () {
    var language = {
        delimiters: {
            thousands: '.',
            decimal: ','
        },
        abbreviations: {
            thousand: 'k',
            million: 'm',
            billion: 'b',
            trillion: 't'
        },
        ordinal: function ordinal(number) {
            return '.';
        },
        currency: {
            symbol: '€'
        }
    };

    // Node
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = language;
    }
})();

},{}],274:[function(require,module,exports){
'use strict';

/*!
 * numeral.js language configuration
 * language : spanish Spain
 * author : Hernan Garcia : https://github.com/hgarcia
 */
(function () {
    var language = {
        delimiters: {
            thousands: '.',
            decimal: ','
        },
        abbreviations: {
            thousand: 'k',
            million: 'mm',
            billion: 'b',
            trillion: 't'
        },
        ordinal: function ordinal(number) {
            var b = number % 10;
            return b === 1 || b === 3 ? 'er' : b === 2 ? 'do' : b === 7 || b === 0 ? 'mo' : b === 8 ? 'vo' : b === 9 ? 'no' : 'to';
        },
        currency: {
            symbol: '€'
        }
    };

    // Node
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = language;
    }
})();

},{}],275:[function(require,module,exports){
'use strict';

/*!
 * numeral.js language configuration
 * language : Finnish
 * author : Sami Saada : https://github.com/samitheberber
 */
(function () {
    var language = {
        delimiters: {
            thousands: ' ',
            decimal: ','
        },
        abbreviations: {
            thousand: 'k',
            million: 'M',
            billion: 'G',
            trillion: 'T'
        },
        ordinal: function ordinal(number) {
            return '.';
        },
        currency: {
            symbol: '€'
        }
    };

    // Node
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = language;
    }
})();

},{}],276:[function(require,module,exports){
'use strict';

/*!
 * numeral.js language configuration
 * language : french (Canada) (fr-CA)
 * author : Léo Renaud-Allaire : https://github.com/renaudleo
 */
(function () {
    var language = {
        delimiters: {
            thousands: ' ',
            decimal: ','
        },
        abbreviations: {
            thousand: 'k',
            million: 'M',
            billion: 'G',
            trillion: 'T'
        },
        ordinal: function ordinal(number) {
            return number === 1 ? 'er' : 'e';
        },
        currency: {
            symbol: '$'
        }
    };

    // Node
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = language;
    }
})();

},{}],277:[function(require,module,exports){
'use strict';

/*!
 * numeral.js language configuration
 * language : french (fr)
 * author : Adam Draper : https://github.com/adamwdraper
 */
(function () {
    var language = {
        delimiters: {
            thousands: ' ',
            decimal: ','
        },
        abbreviations: {
            thousand: 'k',
            million: 'm',
            billion: 'b',
            trillion: 't'
        },
        ordinal: function ordinal(number) {
            return number === 1 ? 'er' : 'e';
        },
        currency: {
            symbol: '€'
        }
    };

    // Node
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = language;
    }
})();

},{}],278:[function(require,module,exports){
'use strict';

/*!
 * numeral.js language configuration
 * language : Hungarian (hu)
 * author : Peter Bakondy : https://github.com/pbakondy
 */
(function () {
    var language = {
        delimiters: {
            thousands: ' ',
            decimal: ','
        },
        abbreviations: {
            thousand: 'E', // ezer
            million: 'M', // millió
            billion: 'Mrd', // milliárd
            trillion: 'T' // trillió
        },
        ordinal: function ordinal(number) {
            return '.';
        },
        currency: {
            symbol: ' Ft'
        }
    };

    // Node
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = language;
    }
})();

},{}],279:[function(require,module,exports){
'use strict';

/*!
 * numeral.js language configuration
 * language : Indonesian (id)
 */
(function () {
    var language = {
        delimiters: {
            thousands: ',',
            decimal: '.'
        },
        abbreviations: {
            thousand: 'ribu',
            million: 'juta',
            billion: 'miliar',
            trillion: 'triliun'
        },
        ordinal: function ordinal(number) {
            // According to Spotify's internal Indonesian specialist,
            // there is no ordinal symbol in Indonesian (like st, nd, th, º, ª),
            // they just use the word (equivalent to writing: first, second,
            // third, instead of 1st, 2nd, 3rd). And as we don't have such
            // capability to translate all numbers to words, this function
            // returns an empty string and wherever there's a ordinal, it will
            // just show up as the cardinal number.
            return '';
        },
        currency: {
            symbol: 'Rp'
        }
    };

    // Node
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = language;
    }
})();

},{}],280:[function(require,module,exports){
'use strict';

/*!
 * numeral.js language configuration
 * language : italian Italy (it)
 * author : Giacomo Trombi : http://cinquepunti.it
 */
(function () {
    var language = {
        delimiters: {
            thousands: '.',
            decimal: ','
        },
        abbreviations: {
            thousand: 'mila',
            million: 'mil',
            billion: 'b',
            trillion: 't'
        },
        ordinal: function ordinal(number) {
            return 'º';
        },
        currency: {
            symbol: '€'
        }
    };

    // Node
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = language;
    }
})();

},{}],281:[function(require,module,exports){
'use strict';

/*!
 * numeral.js language configuration
 * language : japanese
 * author : teppeis : https://github.com/teppeis
 */
(function () {
    var language = {
        delimiters: {
            thousands: ',',
            decimal: '.'
        },
        abbreviations: {
            thousand: '千',
            million: '百万',
            billion: '十億',
            trillion: '兆'
        },
        ordinal: function ordinal(number) {
            return '.';
        },
        currency: {
            symbol: '¥'
        }
    };

    // Node
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = language;
    }
})();

},{}],282:[function(require,module,exports){
'use strict';

/*!
 * numeral.js language configuration
 * language : netherlands-dutch (nl-nl)
 * author : Dave Clayton : https://github.com/davedx
 */
(function () {
    var language = {
        delimiters: {
            thousands: '.',
            decimal: ','
        },
        abbreviations: {
            thousand: 'k',
            million: 'mln',
            billion: 'mrd',
            trillion: 'bln'
        },
        ordinal: function ordinal(number) {
            var remainder = number % 100;
            return number !== 0 && remainder <= 1 || remainder === 8 || remainder >= 20 ? 'ste' : 'de';
        },
        currency: {
            symbol: '€ '
        }
    };

    // Node
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = language;
    }
})();

},{}],283:[function(require,module,exports){
'use strict';

/*!
 * numeral.js language configuration
 * language : polish (pl)
 * author : Dominik Bulaj : https://github.com/dominikbulaj
 */
(function () {
    var language = {
        delimiters: {
            thousands: ' ',
            decimal: ','
        },
        abbreviations: {
            thousand: 'tys.',
            million: 'mln',
            billion: 'mld',
            trillion: 'bln'
        },
        ordinal: function ordinal(number) {
            return '.';
        },
        currency: {
            symbol: 'PLN'
        }
    };

    // Node
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = language;
    }
})();

},{}],284:[function(require,module,exports){
'use strict';

/*!
 * numeral.js language configuration
 * language : portuguese brazil (pt-br)
 * author : Ramiro Varandas Jr : https://github.com/ramirovjr
 */
(function () {
    var language = {
        delimiters: {
            thousands: '.',
            decimal: ','
        },
        abbreviations: {
            thousand: 'mil',
            million: 'milhões',
            billion: 'b',
            trillion: 't'
        },
        ordinal: function ordinal(number) {
            return 'º';
        },
        currency: {
            symbol: 'R$'
        }
    };

    // Node
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = language;
    }
})();

},{}],285:[function(require,module,exports){
'use strict';

/*!
 * numeral.js language configuration
 * language : swedish
 * author :
 */
(function () {
    var language = {
        delimiters: {
            thousands: ' ',
            decimal: ','
        },
        abbreviations: {
            thousand: 't',
            million: 'mn',
            billion: 'md',
            trillion: 'bn'
        },
        ordinal: function ordinal(number) {
            return '.';
        },
        currency: {
            symbol: 'SEK'
        }
    };

    // Node
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = language;
    }
})();

},{}],286:[function(require,module,exports){
'use strict';

/*!
 * numeral.js language configuration
 * language : turkish (tr)
 * author : Ecmel Ercan : https://github.com/ecmel, Erhan Gundogan : https://github.com/erhangundogan, Burak Yiğit Kaya: https://github.com/BYK
 */
(function () {
    var suffixes = {
        1: '\'inci',
        5: '\'inci',
        8: '\'inci',
        70: '\'inci',
        80: '\'inci',

        2: '\'nci',
        7: '\'nci',
        20: '\'nci',
        50: '\'nci',

        3: '\'üncü',
        4: '\'üncü',
        100: '\'üncü',

        6: '\'ncı',

        9: '\'uncu',
        10: '\'uncu',
        30: '\'uncu',

        60: '\'ıncı',
        90: '\'ıncı'
    },
        language = {
        delimiters: {
            thousands: '.',
            decimal: ','
        },
        abbreviations: {
            thousand: 'bin',
            million: 'milyon',
            billion: 'milyar',
            trillion: 'trilyon'
        },
        ordinal: function ordinal(number) {
            if (number === 0) {
                // special case for zero
                return '\'ıncı';
            }

            var a = number % 10,
                b = number % 100 - a,
                c = number >= 100 ? 100 : null;

            return suffixes[a] || suffixes[b] || suffixes[c];
        },
        currency: {
            symbol: '₺'
        }
    };

    // Node
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = language;
    }
})();

},{}],287:[function(require,module,exports){
'use strict';

/*!
 * numeral.js
 * version : 1.5.3
 * author : Adam Draper
 * license : MIT
 * http://adamwdraper.github.com/Numeral-js/
 */

(function () {

    /************************************
        Constants
    ************************************/

    var _numeral,
        VERSION = '1.5.3',

    // internal storage for language config files
    languages = {},
        currentLanguage = 'en',
        zeroFormat = null,
        defaultFormat = '0,0',

    // check for nodeJS
    hasModule = typeof module !== 'undefined' && module.exports;

    /************************************
        Constructors
    ************************************/

    // Numeral prototype object
    function Numeral(number) {
        this._value = number;
    }

    /**
     * Implementation of toFixed() that treats floats more like decimals
     *
     * Fixes binary rounding issues (eg. (0.615).toFixed(2) === '0.61') that present
     * problems for accounting- and finance-related software.
     */
    function toFixed(value, precision, roundingFunction, optionals) {
        var power = Math.pow(10, precision),
            optionalsRegExp,
            output;

        //roundingFunction = (roundingFunction !== undefined ? roundingFunction : Math.round);
        // Multiply up by precision, round accurately, then divide and use native toFixed():
        output = (roundingFunction(value * power) / power).toFixed(precision);

        if (optionals) {
            optionalsRegExp = new RegExp('0{1,' + optionals + '}$');
            output = output.replace(optionalsRegExp, '');
        }

        return output;
    }

    /************************************
        Formatting
    ************************************/

    // determine what type of formatting we need to do
    function formatNumeral(n, format, roundingFunction) {
        var output;

        // figure out what kind of format we are dealing with
        if (format.indexOf('$') > -1) {
            // currency!!!!!
            output = formatCurrency(n, format, roundingFunction);
        } else if (format.indexOf('%') > -1) {
            // percentage
            output = formatPercentage(n, format, roundingFunction);
        } else if (format.indexOf(':') > -1) {
            // time
            output = formatTime(n, format);
        } else {
            // plain ol' numbers or bytes
            output = formatNumber(n._value, format, roundingFunction);
        }

        // return string
        return output;
    }

    // revert to number
    function unformatNumeral(n, string) {
        var stringOriginal = string,
            thousandRegExp,
            millionRegExp,
            billionRegExp,
            trillionRegExp,
            suffixes = ['KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'],
            bytesMultiplier = false,
            power;

        if (string.indexOf(':') > -1) {
            n._value = unformatTime(string);
        } else {
            if (string === zeroFormat) {
                n._value = 0;
            } else {
                if (languages[currentLanguage].delimiters.decimal !== '.') {
                    string = string.replace(/\./g, '').replace(languages[currentLanguage].delimiters.decimal, '.');
                }

                // see if abbreviations are there so that we can multiply to the correct number
                thousandRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.thousand + '(?:\\)|(\\' + languages[currentLanguage].currency.symbol + ')?(?:\\))?)?$');
                millionRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.million + '(?:\\)|(\\' + languages[currentLanguage].currency.symbol + ')?(?:\\))?)?$');
                billionRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.billion + '(?:\\)|(\\' + languages[currentLanguage].currency.symbol + ')?(?:\\))?)?$');
                trillionRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.trillion + '(?:\\)|(\\' + languages[currentLanguage].currency.symbol + ')?(?:\\))?)?$');

                // see if bytes are there so that we can multiply to the correct number
                for (power = 0; power <= suffixes.length; power++) {
                    bytesMultiplier = string.indexOf(suffixes[power]) > -1 ? Math.pow(1024, power + 1) : false;

                    if (bytesMultiplier) {
                        break;
                    }
                }

                // do some math to create our number
                n._value = (bytesMultiplier ? bytesMultiplier : 1) * (stringOriginal.match(thousandRegExp) ? Math.pow(10, 3) : 1) * (stringOriginal.match(millionRegExp) ? Math.pow(10, 6) : 1) * (stringOriginal.match(billionRegExp) ? Math.pow(10, 9) : 1) * (stringOriginal.match(trillionRegExp) ? Math.pow(10, 12) : 1) * (string.indexOf('%') > -1 ? 0.01 : 1) * ((string.split('-').length + Math.min(string.split('(').length - 1, string.split(')').length - 1)) % 2 ? 1 : -1) * Number(string.replace(/[^0-9\.]+/g, ''));

                // round if we are talking about bytes
                n._value = bytesMultiplier ? Math.ceil(n._value) : n._value;
            }
        }
        return n._value;
    }

    function formatCurrency(n, format, roundingFunction) {
        var symbolIndex = format.indexOf('$'),
            openParenIndex = format.indexOf('('),
            minusSignIndex = format.indexOf('-'),
            space = '',
            spliceIndex,
            output;

        // check for space before or after currency
        if (format.indexOf(' $') > -1) {
            space = ' ';
            format = format.replace(' $', '');
        } else if (format.indexOf('$ ') > -1) {
            space = ' ';
            format = format.replace('$ ', '');
        } else {
            format = format.replace('$', '');
        }

        // format the number
        output = formatNumber(n._value, format, roundingFunction);

        // position the symbol
        if (symbolIndex <= 1) {
            if (output.indexOf('(') > -1 || output.indexOf('-') > -1) {
                output = output.split('');
                spliceIndex = 1;
                if (symbolIndex < openParenIndex || symbolIndex < minusSignIndex) {
                    // the symbol appears before the "(" or "-"
                    spliceIndex = 0;
                }
                output.splice(spliceIndex, 0, languages[currentLanguage].currency.symbol + space);
                output = output.join('');
            } else {
                output = languages[currentLanguage].currency.symbol + space + output;
            }
        } else {
            if (output.indexOf(')') > -1) {
                output = output.split('');
                output.splice(-1, 0, space + languages[currentLanguage].currency.symbol);
                output = output.join('');
            } else {
                output = output + space + languages[currentLanguage].currency.symbol;
            }
        }

        return output;
    }

    function formatPercentage(n, format, roundingFunction) {
        var space = '',
            output,
            value = n._value * 100;

        // check for space before %
        if (format.indexOf(' %') > -1) {
            space = ' ';
            format = format.replace(' %', '');
        } else {
            format = format.replace('%', '');
        }

        output = formatNumber(value, format, roundingFunction);

        if (output.indexOf(')') > -1) {
            output = output.split('');
            output.splice(-1, 0, space + '%');
            output = output.join('');
        } else {
            output = output + space + '%';
        }

        return output;
    }

    function formatTime(n) {
        var hours = Math.floor(n._value / 60 / 60),
            minutes = Math.floor((n._value - hours * 60 * 60) / 60),
            seconds = Math.round(n._value - hours * 60 * 60 - minutes * 60);
        return hours + ':' + (minutes < 10 ? '0' + minutes : minutes) + ':' + (seconds < 10 ? '0' + seconds : seconds);
    }

    function unformatTime(string) {
        var timeArray = string.split(':'),
            seconds = 0;
        // turn hours and minutes into seconds and add them all up
        if (timeArray.length === 3) {
            // hours
            seconds = seconds + Number(timeArray[0]) * 60 * 60;
            // minutes
            seconds = seconds + Number(timeArray[1]) * 60;
            // seconds
            seconds = seconds + Number(timeArray[2]);
        } else if (timeArray.length === 2) {
            // minutes
            seconds = seconds + Number(timeArray[0]) * 60;
            // seconds
            seconds = seconds + Number(timeArray[1]);
        }
        return Number(seconds);
    }

    function formatNumber(value, format, roundingFunction) {
        var negP = false,
            signed = false,
            optDec = false,
            abbr = '',
            abbrK = false,
            // force abbreviation to thousands
        abbrM = false,
            // force abbreviation to millions
        abbrB = false,
            // force abbreviation to billions
        abbrT = false,
            // force abbreviation to trillions
        abbrForce = false,
            // force abbreviation
        bytes = '',
            ord = '',
            abs = Math.abs(value),
            suffixes = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'],
            min,
            max,
            power,
            w,
            precision,
            thousands,
            d = '',
            neg = false;

        // check if number is zero and a custom zero format has been set
        if (value === 0 && zeroFormat !== null) {
            return zeroFormat;
        } else {
            // see if we should use parentheses for negative number or if we should prefix with a sign
            // if both are present we default to parentheses
            if (format.indexOf('(') > -1) {
                negP = true;
                format = format.slice(1, -1);
            } else if (format.indexOf('+') > -1) {
                signed = true;
                format = format.replace(/\+/g, '');
            }

            // see if abbreviation is wanted
            if (format.indexOf('a') > -1) {
                // check if abbreviation is specified
                abbrK = format.indexOf('aK') >= 0;
                abbrM = format.indexOf('aM') >= 0;
                abbrB = format.indexOf('aB') >= 0;
                abbrT = format.indexOf('aT') >= 0;
                abbrForce = abbrK || abbrM || abbrB || abbrT;

                // check for space before abbreviation
                if (format.indexOf(' a') > -1) {
                    abbr = ' ';
                    format = format.replace(' a', '');
                } else {
                    format = format.replace('a', '');
                }

                if (abs >= Math.pow(10, 12) && !abbrForce || abbrT) {
                    // trillion
                    abbr = abbr + languages[currentLanguage].abbreviations.trillion;
                    value = value / Math.pow(10, 12);
                } else if (abs < Math.pow(10, 12) && abs >= Math.pow(10, 9) && !abbrForce || abbrB) {
                    // billion
                    abbr = abbr + languages[currentLanguage].abbreviations.billion;
                    value = value / Math.pow(10, 9);
                } else if (abs < Math.pow(10, 9) && abs >= Math.pow(10, 6) && !abbrForce || abbrM) {
                    // million
                    abbr = abbr + languages[currentLanguage].abbreviations.million;
                    value = value / Math.pow(10, 6);
                } else if (abs < Math.pow(10, 6) && abs >= Math.pow(10, 3) && !abbrForce || abbrK) {
                    // thousand
                    abbr = abbr + languages[currentLanguage].abbreviations.thousand;
                    value = value / Math.pow(10, 3);
                }
            }

            // see if we are formatting bytes
            if (format.indexOf('b') > -1) {
                // check for space before
                if (format.indexOf(' b') > -1) {
                    bytes = ' ';
                    format = format.replace(' b', '');
                } else {
                    format = format.replace('b', '');
                }

                for (power = 0; power <= suffixes.length; power++) {
                    min = Math.pow(1024, power);
                    max = Math.pow(1024, power + 1);

                    if (value >= min && value < max) {
                        bytes = bytes + suffixes[power];
                        if (min > 0) {
                            value = value / min;
                        }
                        break;
                    }
                }
            }

            // see if ordinal is wanted
            if (format.indexOf('o') > -1) {
                // check for space before
                if (format.indexOf(' o') > -1) {
                    ord = ' ';
                    format = format.replace(' o', '');
                } else {
                    format = format.replace('o', '');
                }

                ord = ord + languages[currentLanguage].ordinal(value);
            }

            if (format.indexOf('[.]') > -1) {
                optDec = true;
                format = format.replace('[.]', '.');
            }

            w = value.toString().split('.')[0];
            precision = format.split('.')[1];
            thousands = format.indexOf(',');

            if (precision) {
                if (precision.indexOf('[') > -1) {
                    precision = precision.replace(']', '');
                    precision = precision.split('[');
                    d = toFixed(value, precision[0].length + precision[1].length, roundingFunction, precision[1].length);
                } else {
                    d = toFixed(value, precision.length, roundingFunction);
                }

                w = d.split('.')[0];

                if (d.split('.')[1].length) {
                    d = languages[currentLanguage].delimiters.decimal + d.split('.')[1];
                } else {
                    d = '';
                }

                if (optDec && Number(d.slice(1)) === 0) {
                    d = '';
                }
            } else {
                w = toFixed(value, null, roundingFunction);
            }

            // format number
            if (w.indexOf('-') > -1) {
                w = w.slice(1);
                neg = true;
            }

            if (thousands > -1) {
                w = w.toString().replace(/(\d)(?=(\d{3})+(?!\d))/g, '$1' + languages[currentLanguage].delimiters.thousands);
            }

            if (format.indexOf('.') === 0) {
                w = '';
            }

            return (negP && neg ? '(' : '') + (!negP && neg ? '-' : '') + (!neg && signed ? '+' : '') + w + d + (ord ? ord : '') + (abbr ? abbr : '') + (bytes ? bytes : '') + (negP && neg ? ')' : '');
        }
    }

    /************************************
        Top Level Functions
    ************************************/

    _numeral = function numeral(input) {
        if (_numeral.isNumeral(input)) {
            input = input.value();
        } else if (input === 0 || typeof input === 'undefined') {
            input = 0;
        } else if (!Number(input)) {
            input = _numeral.fn.unformat(input);
        }

        return new Numeral(Number(input));
    };

    // version number
    _numeral.version = VERSION;

    // compare numeral object
    _numeral.isNumeral = function (obj) {
        return obj instanceof Numeral;
    };

    // This function will load languages and then set the global language.  If
    // no arguments are passed in, it will simply return the current global
    // language key.
    _numeral.language = function (key, values) {
        if (!key) {
            return currentLanguage;
        }

        if (key && !values) {
            if (!languages[key]) {
                throw new Error('Unknown language : ' + key);
            }
            currentLanguage = key;
        }

        if (values || !languages[key]) {
            loadLanguage(key, values);
        }

        return _numeral;
    };

    // This function provides access to the loaded language data.  If
    // no arguments are passed in, it will simply return the current
    // global language object.
    _numeral.languageData = function (key) {
        if (!key) {
            return languages[currentLanguage];
        }

        if (!languages[key]) {
            throw new Error('Unknown language : ' + key);
        }

        return languages[key];
    };

    _numeral.language('en', {
        delimiters: {
            thousands: ',',
            decimal: '.'
        },
        abbreviations: {
            thousand: 'k',
            million: 'm',
            billion: 'b',
            trillion: 't'
        },
        ordinal: function ordinal(number) {
            var b = number % 10;
            return ~ ~(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
        },
        currency: {
            symbol: '$'
        }
    });

    _numeral.zeroFormat = function (format) {
        zeroFormat = typeof format === 'string' ? format : null;
    };

    _numeral.defaultFormat = function (format) {
        defaultFormat = typeof format === 'string' ? format : '0.0';
    };

    /************************************
        Helpers
    ************************************/

    function loadLanguage(key, values) {
        languages[key] = values;
    }

    /************************************
        Floating-point helpers
    ************************************/

    // The floating-point helper functions and implementation
    // borrows heavily from sinful.js: http://guipn.github.io/sinful.js/

    /**
     * Array.prototype.reduce for browsers that don't support it
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce#Compatibility
     */
    if ('function' !== typeof Array.prototype.reduce) {
        Array.prototype.reduce = function (callback, opt_initialValue) {
            'use strict';

            if (null === this || 'undefined' === typeof this) {
                // At the moment all modern browsers, that support strict mode, have
                // native implementation of Array.prototype.reduce. For instance, IE8
                // does not support strict mode, so this check is actually useless.
                throw new TypeError('Array.prototype.reduce called on null or undefined');
            }

            if ('function' !== typeof callback) {
                throw new TypeError(callback + ' is not a function');
            }

            var index,
                value,
                length = this.length >>> 0,
                isValueSet = false;

            if (1 < arguments.length) {
                value = opt_initialValue;
                isValueSet = true;
            }

            for (index = 0; length > index; ++index) {
                if (this.hasOwnProperty(index)) {
                    if (isValueSet) {
                        value = callback(value, this[index], index, this);
                    } else {
                        value = this[index];
                        isValueSet = true;
                    }
                }
            }

            if (!isValueSet) {
                throw new TypeError('Reduce of empty array with no initial value');
            }

            return value;
        };
    }

    /**
     * Computes the multiplier necessary to make x >= 1,
     * effectively eliminating miscalculations caused by
     * finite precision.
     */
    function multiplier(x) {
        var parts = x.toString().split('.');
        if (parts.length < 2) {
            return 1;
        }
        return Math.pow(10, parts[1].length);
    }

    /**
     * Given a variable number of arguments, returns the maximum
     * multiplier that must be used to normalize an operation involving
     * all of them.
     */
    function correctionFactor() {
        var args = Array.prototype.slice.call(arguments);
        return args.reduce(function (prev, next) {
            var mp = multiplier(prev),
                mn = multiplier(next);
            return mp > mn ? mp : mn;
        }, -Infinity);
    }

    /************************************
        Numeral Prototype
    ************************************/

    _numeral.fn = Numeral.prototype = {

        clone: function clone() {
            return _numeral(this);
        },

        format: function format(inputString, roundingFunction) {
            return formatNumeral(this, inputString ? inputString : defaultFormat, roundingFunction !== undefined ? roundingFunction : Math.round);
        },

        unformat: function unformat(inputString) {
            if (Object.prototype.toString.call(inputString) === '[object Number]') {
                return inputString;
            }
            return unformatNumeral(this, inputString ? inputString : defaultFormat);
        },

        value: function value() {
            return this._value;
        },

        valueOf: function valueOf() {
            return this._value;
        },

        set: function set(value) {
            this._value = Number(value);
            return this;
        },

        add: function add(value) {
            var corrFactor = correctionFactor.call(null, this._value, value);
            function cback(accum, curr, currI, O) {
                return accum + corrFactor * curr;
            }
            this._value = [this._value, value].reduce(cback, 0) / corrFactor;
            return this;
        },

        subtract: function subtract(value) {
            var corrFactor = correctionFactor.call(null, this._value, value);
            function cback(accum, curr, currI, O) {
                return accum - corrFactor * curr;
            }
            this._value = [value].reduce(cback, this._value * corrFactor) / corrFactor;
            return this;
        },

        multiply: function multiply(value) {
            function cback(accum, curr, currI, O) {
                var corrFactor = correctionFactor(accum, curr);
                return accum * corrFactor * (curr * corrFactor) / (corrFactor * corrFactor);
            }
            this._value = [this._value, value].reduce(cback, 1);
            return this;
        },

        divide: function divide(value) {
            function cback(accum, curr, currI, O) {
                var corrFactor = correctionFactor(accum, curr);
                return accum * corrFactor / (curr * corrFactor);
            }
            this._value = [this._value, value].reduce(cback);
            return this;
        },

        difference: function difference(value) {
            return Math.abs(_numeral(this._value).subtract(value).value());
        }

    };

    /************************************
        Exposing Numeral
    ************************************/

    module.exports = _numeral;
}).call(undefined);

},{}],288:[function(require,module,exports){

'use strict';

/**
 * Module dependencies
 */

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var extend = require('extend'),
    bridge = require('../spotify-bridge-request'),
    batch = require('spotify-batch');

/**
 * Bridge methods
 */

var PREF_ALL = 'preferences_all';
var PREF_GET = 'preferences_get';
var PREF_SET = 'preferences_set';
var PREF_SUB = 'preferences_event_wait';

/**
 * Converts a string with dot notation into
 * a nested object where the last key is
 * set to value
 *
 *  eg: f('foo.bar', 123) = {foo: {bar: 123}}
 *
 * @api private
 * @param {String} string
 * @param {Mixed} value
 * @param {String} delimiter - optional
 */

function TransformStringIntoObjectAndSetValue(string, value, delimiter) {
  var object = {};
  string.split(delimiter || '.').reduce(function (o, c, i, a) {
    if (i < a.length - 1) {
      o[c] = {};
    } else {
      o[c] = value;
    }

    return o[c];
  }, object);

  return object;
}

/**
 * Converts an object with nest objects into a flat object
 *
 *  eg: f({foo: {bar: 123}}) = {'foo.bar': 123}
 *
 * @api private
 * @param {String} string
 * @param {String} delimiter - optional
 */

function TransformObjectIntoFlatObject(object, delimiter) {
  var flattened = {};
  delimiter = delimiter || '.';
  function traverse(o, key) {
    var tmp = null;
    for (var p in o) {
      if ('object' == _typeof(o[p])) {
        key = key ? [key, p].join(delimiter) : p;
        traverse(o[p], key);
      } else {
        tmp = key ? [key, p].join(delimiter) : p;
        flattened[tmp] = o[p];
      }
    }
  }

  traverse(object);
  return flattened;
}

/**
 * Normalizes data from bridge responses
 *
 * @api private
 * @param {String} key
 * @param {Object} data
 * @param {Boolean} preserve - optional (Default: false)
 */

function NormalizeData(key, data, preserve) {
  var out = {};
  var regex = '*' == key ? null : RegExp('^' + key);
  var targets = null;

  if ('object' != (typeof data === 'undefined' ? 'undefined' : _typeof(data))) {
    return data;
  }

  targets = Object.keys(data).map(function (key) {
    if (null == regex || regex.test(key)) {
      return [key, data[key]];
    }
  }).filter(Boolean).reduce(function (t, c) {
    t[c[0]] = c[1];
    return t;
  }, {});

  Object.keys(targets).forEach(function (key) {
    // extend output object with transformed properties
    extend(true, out, TransformStringIntoObjectAndSetValue(key, targets[key]));
  });

  if ('*' == key || true === preserve) {
    return out;
  } else {
    return key.split('.').reduce(function (o, k) {
      return o[k];
    }, out);
  }
}

/**
 * Subscribes to a key.
 *
 * @api private
 * @param {Function} rpc The RPC to use.
 * @param {String} key The key (including path).
 * @param {*} lastValue The last value of the key (used for comparing).
 * @param {Function} fn Subscribe handler.
 * @param {Object=} sub Subscription object, optional.
 */

function SubscribeToKey(rpc, key, lastValue, fn, sub) {
  sub = sub || {
    isCancelled: false,
    cancel: function cancel() {
      this.isCancelled = true;
    }
  };

  rpc(PREF_SUB, [], function (err, res) {
    if (sub.isCancelled) return;

    var didValueChange = false;

    if (res) {
      var value = NormalizeData(key, res);
      if (value !== lastValue) {
        lastValue = value;
        didValueChange = true;
      }
    }

    // Resubscribe since one subscription is only for one response
    SubscribeToKey(rpc, key, lastValue, fn, sub);

    if (didValueChange) {
      fn(null, lastValue);
    }
  });

  return sub;
}

/**
 * `Preferences' constructor
 *
 * @api public
 * @param {String} path - optional (Default: '*')
 * @param {Function} rpc - optional
 */

module.exports = Preferences;
function Preferences(path, rpc) {
  if (!(this instanceof Preferences)) {
    return new Preferences(path, rpc);
  }

  this.path = path || '*';
  this.rpc = rpc || bridge.request.bind(bridge);
}

/**
 * Retrieves all preferences at path.
 * If path is '*' then all preferences
 * are retrieved.
 *
 * @api public
 * @param {Function} fn
 */

Preferences.prototype.all = function (fn) {
  var self = this;
  var path = this.path;

  this.rpc(PREF_ALL, [], function (err, res) {
    if (err) {
      return fn(err);
    } else if ('*' == path) {
      fn(null, res);
    } else {
      fn(null, NormalizeData(path, res, true));
    }
  });

  return this;
};

/**
 * Sets a preference at key at path
 * with value
 *
 * @api public
 * @param {String} key
 * @param {Mixed} value
 * @param {Function} fn
 */

Preferences.prototype.set = function (key, value, fn) {
  var self = this;
  var path = this.path;
  var tmp = null;
  var map = null;
  var jobs = null;

  // handle batch jobs to extend bridge preferences
  if ('object' == (typeof key === 'undefined' ? 'undefined' : _typeof(key))) {
    fn = value;

    map = TransformObjectIntoFlatObject(key);
    jobs = batch().concurrency(1);
    Object.keys(map).forEach(function (k) {
      jobs.push(function (next) {
        self.set(k, map[k], next);
      });
    });

    jobs.run(fn);
  } else {
    key = '*' == path ? key : [path, key].join('.');
    this.rpc(PREF_SET, [key, value], fn);
  }
  return this;
};

/**
 * Sets a preference bitflag at path, based on the inputs.
 *
 * @api public
 * @param {String} key
 * @param {Array} flagBoolPairs
 * @param {Function} fn
 */

Preferences.prototype.setAtomicFlags = function (key, flagBoolPairs, fn) {
  var self = this;

  self.get(key, function (err, value) {
    if (err) return fn(err);

    flagBoolPairs.forEach(function (pair) {
      var flag = pair[0];
      var bool = pair[1];
      if (bool === undefined || bool === null) return;
      if (bool) value |= flag;else value &= ~flag;
    });

    self.set(key, value, fn);
  });
};

/**
 * Gets a preference at key at path
 *
 * @api public
 * @param {String} key
 * @param {Function} fn
 */

Preferences.prototype.get = function (key, fn) {
  var self = this;
  key = '*' == this.path ? key : [this.path, key].join('.');

  // try to get property first
  this.rpc(PREF_GET, [key], function (err, res) {
    var value = res ? NormalizeData(key, res) : null;
    if (null == value) {
      self.rpc(PREF_ALL, [], function (err, res) {
        if (err) {
          return fn(err);
        } else {
          fn(null, NormalizeData(key, res));
        }
      });
    } else {
      fn(null, NormalizeData(key, res));
    }
  });
  return this;
};

/**
 * Subscribes to a preference at key at path
 *
 * @api public
 * @param {String} key
 * @param {Function} fn
 */

Preferences.prototype.subscribe = function (key, fn) {
  var self = this;
  var sub = null;
  var cancelled = false;

  // Get initial value and then subscribe for changes
  this.get(key, function (err, res) {
    if (cancelled) return;
    var keyWithPath = '*' == self.path ? key : [self.path, key].join('.');
    sub = SubscribeToKey(self.rpc, keyWithPath, res, fn);

    // Respond to the GET (initial value for SUB)
    fn(err, res);
  });

  return {
    cancel: function cancel() {
      cancelled = true;
      if (sub) {
        sub.cancel();
      }
    }
  };
};

},{"../spotify-bridge-request":64,"extend":316,"spotify-batch":410}],289:[function(require,module,exports){
/**
 * @module spotify-range2
 */
'use strict';

var prime = require('prime');

var map = require('mout/array/map');

var push_ = Array.prototype.push;
var slice_ = Array.prototype.slice;

var Range = prime( /** @lends Range.prototype */{

  /**
   * The representation of a range
   * @constructs
   * @param {Number} start The start of the range.
   * @param {Number} end The end of the range.
   */
  constructor: function Range(start, end) {
    this.update(start, end);
  },

  /** Update a range. */
  update: function update(start, end) {
    if (start !== null) this.start = start;
    if (end !== null) this.end = end;
    if (this.start === null || this.end === null) throw new Error('invalid range');
    if (this.start > this.end) throw new Error('invalid range');
    this.length = this.end - this.start;
    return this;
  },

  /** Copy a range. */
  copy: function copy() {
    return new Range(this.start, this.end);
  },

  /** Range is above range. */
  above: function above(range) {
    if (!range) return false;
    return this.start >= range.end;
  },

  /** Range is below range. */
  below: function below(range) {
    if (!range) return false;
    return this.end <= range.start;
  },

  adjacent: function adjacent(range) {
    if (!range) return false;
    return this.end === range.start || this.start === range.end;
  },

  /** Range intersects range. */
  intersects: function intersects(range) {
    if (!range) return false;
    return !this.above(range) && !this.below(range);
  },

  /** Range contains range. */
  contains: function contains(range) {
    if (!range) return false;
    return this.start <= range.start && this.end >= range.end;
  },

  /** Range is contained by ranges. */
  contained: function contained(range) {
    var ranges;
    if (range instanceof Range) ranges = arguments;else ranges = range;
    if (!ranges) return false;

    for (var i = 0; ranges[i] !== undefined; i++) {
      var r = ranges[i];
      if (r.start <= this.start && r.end >= this.end) {
        return true;
      }
    }
    return false;
  },

  /** Range fits two ranges. */
  fits: function fits(prev, next) {
    if (!prev && !next) return true;
    if (!prev) return this.end <= next.start;
    if (!next) return this.start >= prev.end;
    return this.start >= prev.end && this.end <= next.start;
  },

  // get the section of this range contained between two ranges
  // [0, 20] » [0, 8], [16, 20] » [8, 16]

  /** portion of a range between two ranges. */
  between: function between(prev, next) {
    if (!prev && !next) return this.copy();
    if (!prev) return this.start >= next.start ? null : new Range(this.start, Math.min(this.end, next.start));
    if (!next) return this.end <= prev.end ? null : new Range(Math.max(prev.end, this.start), this.end);

    return this.end > prev.end && this.start < next.start ? new Range(Math.max(prev.end, this.start), Math.min(next.start, this.end)) : null;
  },

  // [0, 8] » [0, 2], [4, 5] = [0, 2], [4, 5]
  // [3, 6] » [5, 7] = [5, 6]
  // [6, 9] » [5, 7] = [6, 7]

  /** intersection of a range with many ranges */
  intersection: function intersection(range) {
    var intersected = [];
    var ranges;
    if (range instanceof Range) ranges = arguments;else ranges = range;
    for (var k = 0; k < ranges.length; k++) {
      var r = ranges[k];
      if (this.below(r)) break;

      if (r.intersects(this)) intersected.push(new Range(Math.max(this.start, r.start), Math.min(this.end, r.end)));
    }
    return intersected;
  },

  // subtract ranges from this range
  // [0, 8] » [0, 2], [4, 5] = [2, 4], [5, 8]

  /** subtract many ranges from the range. */
  subtract: function subtract(range) {
    var subtracted = [];
    var ranges;
    if (range instanceof Range) ranges = arguments;else ranges = range;
    for (var k = -1; k < ranges.length; k++) {
      var prev = ranges[k];
      var next = ranges[k + 1];
      var between = this.between(prev, next);
      if (between) subtracted.push(between);
    }
    return subtracted;
  },

  // extract this range from ranges
  // [0, 8] » [0, 2], [5, 8] = []
  // [8, 20] » [0, 2], [5, 8] = [0, 2], [5, 8]
  // [0, 10] » [5, 10], [15, 20] = [5, 10]
  // [10, 20] » [5, 80], [90, 100] = [5, 70] [80, 90]
  // [10, 20] » [0, 10], [20, 30] = [0, 20]

  /** extract the range from many ranges. */
  extract: function extract(range) {
    var ranges = range instanceof Range ? slice_.call(arguments) : range.slice();

    for (var k = 0; k < ranges.length; k++) {
      var prev = ranges[k - 1];
      var next = ranges[k];

      var newRange = null;

      if (this.below(next)) {
        newRange = new Range(next.start - this.length, next.end - this.length);
      } else if (this.intersects(next)) {
        var subtracted = next.subtract(this);
        if (subtracted.length === 2) {
          // is contained
          newRange = new Range(subtracted[0].start, subtracted[1].end - this.length);
        } else if (subtracted.length === 1) {
          if (next.end > this.end) {
            // second segment kept
            newRange = new Range(subtracted[0].start - this.length, subtracted[0].end - this.length);
          } else if (this.start > next.start) {
            // first segment kept
            newRange = new Range(subtracted[0].start, subtracted[0].end);
          }
        } else {
          // gets eaten
          ranges.splice(k--, 1); // decrease k
        }
      } else {
          ranges.splice(k, 1, next.copy());
        }

      if (newRange) {
        if (prev && prev.end === newRange.start) {
          // touches previous
          ranges.splice(k-- - 1, 2, new Range(prev.start, newRange.end)); // decrease k due to splicing
        } else {
            ranges.splice(k, 1, newRange);
          }
      }
    }

    return ranges;
  },

  // [2,3] » [0,1], [2,3] = [0,1], [2,4]
  // [1,2] » [0,6] = [0,7]
  // [0,1] » [0,1], [5,6] = [0,2], [6,7]
  // [4,6] » [0,1], [5,6] = [0,1], [4,6], [7,8]

  // TODO: this can be slightly better. merging can be done in one loop.

  /** insert the range in many ranges. */
  insert: function insert(range) {
    var ranges = range instanceof Range ? slice_.call(arguments) : range.slice();

    for (var k = 0; k < ranges.length; k++) {
      var next = ranges[k];

      if (this.start >= next.end) {
        ranges.splice(k, 1, next.copy());
      } else if (this.start > next.start && this.start < next.end) {
        ranges.splice(k, 1, new Range(next.start, this.start), new Range(this.start, next.end));
      } else {
        ranges.splice(k, 1, new Range(next.start + this.length, next.end + this.length));
      }
    }

    return this.merge(ranges);
  },

  // merge this range in ranges
  // [0, 8] » [0, 2], [5, 8] = [0, 8]
  // [8, 20] » [0, 2], [5, 8] = [0, 2], [5, 20]
  // [0, 10] » [5, 10], [15, 20] = [0, 10], [15, 20]

  /** merge many ranges to the range. */
  merge: function merge(range) {
    var ranges;
    if (range instanceof Range) ranges = arguments;else ranges = range;

    ranges = map(ranges, function (r) {
      return r.copy();
    });

    if (!ranges.length) return [this.copy()];

    var k;
    var l;

    for (k = -1, l = ranges.length; k < l; k++) {
      var prev = ranges[k];
      var next = ranges[k + 1];
      var between = this.between(prev, next);

      if (between) {
        if (!prev && next) {
          if (between.end === next.start) {
            next.update(between.start, next.end);
          } else {
            k++; // increase k since we had a push
            ranges.unshift(between);
          }
        } else if (prev && next) {
          if (prev.end === between.start && between.end === next.start) {
            prev.update(prev.start, next.end);
            ranges.splice(k-- + 1, 1); // remove the next, decrease k since we had a splice
          } else if (prev.end === between.start) {
              prev.update(prev.start, between.end);
            } else if (between.end === next.start) {
              next.update(between.start, next.end);
            } else {
              ranges.splice(k + 1, 0, between);
            }
        } else if (prev && !next) {
          if (prev.end === between.start) {
            prev.update(prev.start, between.end);
          } else {
            k++; // increase k since we had a push
            ranges.push(between);
          }
        }
      }
    }

    return ranges;
  },

  /** Remove range from many ranges
      - The range(s) you pass is what you remove from */
  remove: function remove(range) {
    var ranges;
    if (range instanceof Range) ranges = arguments;else ranges = range;
    var result = [];
    for (var i = 0; i < ranges.length; i++) {
      var remaining = ranges[i].subtract(this);
      if (remaining.length) push_.apply(result, remaining);
    }
    return result;
  },

  /** Range to an array of indices */
  toIndices: function toIndices() {
    var indices = [];
    for (var i = this.start; i < this.end; i++) {
      indices.push(i);
    }return indices;
  },

  /** Range to a string */
  toString: function toString() {
    return [this.start, this.end] + '';
  }

});

/**
 * Range from a string
 * @memberof Range
 * @static
 * @param {String} string - The string.
 * @return {Range} The range.
 */
Range.fromString = function (string) {
  var parts = string.split(',');
  return new Range(+parts[0], +parts[1]);
};

/**
 * Ranges from an array of indices
 * @memberof Range
 * @static
 * @param {Array} indices - An array of indices.
 * @return {Array} An array of Ranges.
 */
Range.fromIndices = function (indices) {
  indices.sort(function (a, b) {
    return a > b ? 1 : -1;
  });

  var ranges = [];
  var rstart;
  var rend;

  for (var i = 0; i < indices.length; i++) {
    rstart = indices[i];
    rend = rstart;
    while (indices[i + 1] - indices[i] === 1) {
      rend = indices[i + 1]; // increment the index if the numbers sequential
      i++;
    }
    ranges.push(new Range(rstart, rend + 1));
  }

  return ranges;
};

/**
 * A function that returns a range.
 * @function
 * @see Range
 * @param {Number} start The start of the range.
 * @param {Number} end The end of the range.
 */
module.exports = Range;

},{"mout/array/map":359,"prime":404}],290:[function(require,module,exports){
(function (global){
'use strict';

module.exports = {
  ENABLED: '1',
  DISABLED: '0',
  TEST_NAME: 'ab-desktop-shuffle',
  isEnabled: function isEnabled() {
    return global.__spotify && global.__spotify.product_state && global.__spotify.product_state[this.TEST_NAME] === this.ENABLED || false;
  }

};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],291:[function(require,module,exports){
'use strict';

function Translations() {
  this._data = {};

  // ensure that the context of the get method is always this object
  this.get = this.get.bind(this);
}

/**
 * Default implementation if the
 * locale is not loaded
 */
Translations.prototype.injectData = function (data) {
  this._data = data;
};

/**
 * Get a translation
 */
Translations.prototype.get = function (key, var_args) {
  var format = this._data.hasOwnProperty(key) ? this._data[key] : key;
  var args = arguments;

  return format.replace(/\{(\d+?)\}/g, function (str, num) {
    var value = args[+num + 1];

    // Do not change by a ||. A value of an empty string would make it fail.
    return typeof value !== 'undefined' ? value : str;
  });
};

/**
 * Gets the raw translations data
 * @return {Object} Locale object
 */
Translations.prototype.getData = function () {
  return this._data;
};

/**
 * Creates a translations instance with the specified data
 *
 * @param {Object} data Translations object
 * @return {Translations}
 */
Translations.createWithData = function (data) {
  var translations = new Translations();
  translations.injectData(data);
  return translations;
};

module.exports = Translations;

},{}],292:[function(require,module,exports){
/**
 * BezierEasing - use bezier curve for transition easing function
 * by Gaëtan Renaudeau 2014 - 2015 – MIT License
 *
 * Credits: is based on Firefox's nsSMILKeySpline.cpp
 * Usage:
 * var spline = BezierEasing([ 0.25, 0.1, 0.25, 1.0 ])
 * spline.get(x) => returns the easing value | x must be in [0, 1] range
 *
 */

// These values are established by empiricism with tests (tradeoff: performance VS precision)
var NEWTON_ITERATIONS = 4;
var NEWTON_MIN_SLOPE = 0.001;
var SUBDIVISION_PRECISION = 0.0000001;
var SUBDIVISION_MAX_ITERATIONS = 10;

var kSplineTableSize = 11;
var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);

var float32ArraySupported = typeof Float32Array === "function";

function A (aA1, aA2) { return 1.0 - 3.0 * aA2 + 3.0 * aA1; }
function B (aA1, aA2) { return 3.0 * aA2 - 6.0 * aA1; }
function C (aA1)      { return 3.0 * aA1; }

// Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.
function calcBezier (aT, aA1, aA2) {
  return ((A(aA1, aA2)*aT + B(aA1, aA2))*aT + C(aA1))*aT;
}

// Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.
function getSlope (aT, aA1, aA2) {
  return 3.0 * A(aA1, aA2)*aT*aT + 2.0 * B(aA1, aA2) * aT + C(aA1);
}

function binarySubdivide (aX, aA, aB, mX1, mX2) {
  var currentX, currentT, i = 0;
  do {
    currentT = aA + (aB - aA) / 2.0;
    currentX = calcBezier(currentT, mX1, mX2) - aX;
    if (currentX > 0.0) {
      aB = currentT;
    } else {
      aA = currentT;
    }
  } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);
  return currentT;
}

function newtonRaphsonIterate (aX, aGuessT, mX1, mX2) {
  for (var i = 0; i < NEWTON_ITERATIONS; ++i) {
    var currentSlope = getSlope(aGuessT, mX1, mX2);
    if (currentSlope === 0.0) return aGuessT;
    var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
    aGuessT -= currentX / currentSlope;
  }
  return aGuessT;
}

/**
 * points is an array of [ mX1, mY1, mX2, mY2 ]
 */
function BezierEasing (points, b, c, d) {
  if (arguments.length === 4) {
    return new BezierEasing([ points, b, c, d ]);
  }
  if (!(this instanceof BezierEasing)) return new BezierEasing(points);

  if (!points || points.length !== 4) {
    throw new Error("BezierEasing: points must contains 4 values");
  }
  for (var i=0; i<4; ++i) {
    if (typeof points[i] !== "number" || isNaN(points[i]) || !isFinite(points[i])) {
      throw new Error("BezierEasing: points should be integers.");
    }
  }
  if (points[0] < 0 || points[0] > 1 || points[2] < 0 || points[2] > 1) {
    throw new Error("BezierEasing x values must be in [0, 1] range.");
  }

  this._str = "BezierEasing("+points+")";
  this._css = "cubic-bezier("+points+")";
  this._p = points;
  this._mSampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);
  this._precomputed = false;

  this.get = this.get.bind(this);
}

BezierEasing.prototype = {

  get: function (x) {
    var mX1 = this._p[0],
      mY1 = this._p[1],
      mX2 = this._p[2],
      mY2 = this._p[3];
    if (!this._precomputed) this._precompute();
    if (mX1 === mY1 && mX2 === mY2) return x; // linear
    // Because JavaScript number are imprecise, we should guarantee the extremes are right.
    if (x === 0) return 0;
    if (x === 1) return 1;
    return calcBezier(this._getTForX(x), mY1, mY2);
  },

  getPoints: function() {
    return this._p;
  },

  toString: function () {
    return this._str;
  },

  toCSS: function () {
    return this._css;
  },

  // Private part

  _precompute: function () {
    var mX1 = this._p[0],
      mY1 = this._p[1],
      mX2 = this._p[2],
      mY2 = this._p[3];
    this._precomputed = true;
    if (mX1 !== mY1 || mX2 !== mY2)
      this._calcSampleValues();
  },

  _calcSampleValues: function () {
    var mX1 = this._p[0],
      mX2 = this._p[2];
    for (var i = 0; i < kSplineTableSize; ++i) {
      this._mSampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
    }
  },

  /**
   * getTForX chose the fastest heuristic to determine the percentage value precisely from a given X projection.
   */
  _getTForX: function (aX) {
    var mX1 = this._p[0],
      mX2 = this._p[2],
      mSampleValues = this._mSampleValues;

    var intervalStart = 0.0;
    var currentSample = 1;
    var lastSample = kSplineTableSize - 1;

    for (; currentSample !== lastSample && mSampleValues[currentSample] <= aX; ++currentSample) {
      intervalStart += kSampleStepSize;
    }
    --currentSample;

    // Interpolate to provide an initial guess for t
    var dist = (aX - mSampleValues[currentSample]) / (mSampleValues[currentSample+1] - mSampleValues[currentSample]);
    var guessForT = intervalStart + dist * kSampleStepSize;

    var initialSlope = getSlope(guessForT, mX1, mX2);
    if (initialSlope >= NEWTON_MIN_SLOPE) {
      return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
    } else if (initialSlope === 0.0) {
      return guessForT;
    } else {
      return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
    }
  }
};

// CSS mapping
BezierEasing.css = {
  "ease":        BezierEasing.ease      = BezierEasing(0.25, 0.1, 0.25, 1.0),
  "linear":      BezierEasing.linear    = BezierEasing(0.00, 0.0, 1.00, 1.0),
  "ease-in":     BezierEasing.easeIn    = BezierEasing(0.42, 0.0, 1.00, 1.0),
  "ease-out":    BezierEasing.easeOut   = BezierEasing(0.00, 0.0, 0.58, 1.0),
  "ease-in-out": BezierEasing.easeInOut = BezierEasing(0.42, 0.0, 0.58, 1.0)
};

module.exports = BezierEasing;

},{}],293:[function(require,module,exports){
(function (global){
var check = require('./check.js');
var compare = require('./compare.js');

/**
 * Throws an Error if there are differences between the two given instances. The
 * error message will contain the difference summary. Compares arrays, booleans,
 * numbers, objects and strings as well as null and undefined by value and other
 * types by reference.
 */
var assert = function (one, two) {
  var summary;

  summary = compare(one, two, '');

  if (summary !== null) {
    throw new global.Error(summary);
  }
};

/**
 * Throws an Error if the given method does not throw when called with the given
 * args for the given instance.
 */
assert.throws = function (instance, method, args) {
  var unexpected;

  check.function(method);
  check.array(args);

  unexpected = new Error('Expected an error to be thrown!');

  try {
    method.apply(instance, args);

    throw unexpected;
  } catch (error) {
    if (error === unexpected) {
      throw unexpected;
    }
  }
};

module.exports = assert;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./check.js":294,"./compare.js":296}],294:[function(require,module,exports){
(function (global){
var is = require('./is.js');

/**
 * Throws a TypeError if the given instance is not an array.
 */
exports.array = function (instance) {
  if (!is.array(instance)) {
    throw new global.TypeError('Expected array!');
  }
};

/**
 * Throws a TypeError if the given instance is not a boolean.
 */
exports.boolean = function (instance) {
  if (!is.boolean(instance)) {
    throw new global.TypeError('Expected boolean!');
  }
};

/**
 * Throws a TypeError if the given instance is not a function.
 */
exports.function = function (instance) {
  if (!is.function(instance)) {
    throw new global.TypeError('Expected function!');
  }
};

/**
 * Throws a TypeError if the given instance is not null.
 */
exports.null = function (instance) {
  if (!is.null(instance)) {
    throw new global.TypeError('Expected null!');
  }
};

/**
 * Throws a TypeError if the given instance is not a number.
 */
exports.number = function (instance) {
  if (!is.number(instance)) {
    throw new global.TypeError('Expected number!');
  }
};

/**
 * Throws a TypeError if the given instance is not an object.
 */
exports.object = function (instance) {
  if (!is.object(instance)) {
    throw new global.TypeError('Expected object!');
  }
};

/**
 * Throws a TypeError if the given instance is not a string.
 */
exports.string = function (instance) {
  if (!is.string(instance)) {
    throw new global.TypeError('Expected string!');
  }
};

/**
 * Throws a TypeError if the given instance does not descend from the given
 * constructor.
 */
exports.type = function (instance, constructor) {
  if (!is.type(instance, constructor)) {
    throw new global.TypeError('Expected type!');
  }
};

/**
 * Throws a TypeError if the given instance is not undefined.
 */
exports.undefined = function (instance) {
  if (!is.undefined(instance)) {
    throw new global.TypeError('Expected undefined!');
  }
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./is.js":304}],295:[function(require,module,exports){
(function (global){
var is = require('./is.js');
var name = require('./name.js');

/**
 * Attemps to clone the given instance. Only arrays, booleans, numbers, objects
 * and strings as well as null and undefined are accepted. If any other type is
 * encountered, a TypeError is thrown.
 */
var clone = function (instance) {
  var array;
  var i;
  var k;
  var l;
  var object;

  if (is.array(instance)) {
    array = [];

    for (i = 0, l = instance.length; i < l; i++) {
      array[i] = clone(instance[i]);
    }

    return array;
  }

  if (is.boolean(instance)) {
    return instance;
  }

  if (is.null(instance)) {
    return instance;
  }

  if (is.number(instance)) {
    return instance;
  }

  if (is.object(instance)) {
    object = {};

    for (k in instance) {
      object[k] = clone(instance[k]);
    }

    return object;
  }

  if (is.string(instance)) {
    return instance;
  }

  if (is.undefined(instance)) {
    return instance;
  }

  throw new global.TypeError('Unexpected type "' + name(instance) + '"!');
};

module.exports = clone;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./is.js":304,"./name.js":306}],296:[function(require,module,exports){
var is = require('./is.js');
var name = require('./name.js');

/**
 * Creates a difference summary between the two given instances. Compares
 * arrays, booleans, numbers, objects and strings as well as null and undefined
 * by value and other types by reference. Returns null if the two given
 * instances are identical.
 */
var compare = function (one, two, prefix) {
  var i;
  var k;
  var l;
  var m;
  var result;
  var summary;

  result = '\n';

  if (!is.string(prefix)) {
    prefix = '';
  }

  if (is.array(one)) {
    if (!is.array(two)) {
      return 'expected type "' + name(one) + '" but found type "' + name(two) + '"\n';
    }

    for (i = 0, l = one.length, m = two.length; i < l && i < m; i++) {
      summary = compare(one[i], two[i], prefix + '    ');

      if (summary !== null) {
        result += prefix + '"' + i + '": ' + summary;
      }
    }

    for (; i < l; i++) {
      result += prefix + '"' + i + '": the item is missing\n';
    }

    for (; i < m; i++) {
      result += prefix + '"' + i + '": the item was not expected\n';
    }

    return result !== '\n' ? result : null;
  }

  if (is.boolean(one)) {
    if (!is.boolean(two)) {
      return 'expected type "' + name(one) + '" but found type "' + name(two) + '"\n';
    }

    if (one.valueOf() !== two.valueOf()) {
      return 'expected ' + one.valueOf() + ' but found ' + two.valueOf() + '\n';
    }

    return null;
  }

  if (is.null(one)) {
    if (!is.null(two)) {
      return 'expected type "' + name(one) + '" but found type "' + name(two) + '"\n';
    }

    return null;
  }

  if (is.number(one)) {
    if (!is.number(two)) {
      return 'expected type "' + name(one) + '" but found type "' + name(two) + '"\n';
    }

    if (one.valueOf() !== two.valueOf()) {
      return 'expected ' + one.valueOf() + ' but found ' + two.valueOf() + '\n';
    }

    return null;
  }

  if (is.object(one)) {
    if (!is.object(two)) {
      return 'expected type "' + name(one) + '" but found type "' + name(two) + '"\n';
    }

    for (k in one) {
      if (!(k in two)) {
        result += prefix + '"' + k + '": the item is missing\n';
      } else {
        summary = compare(one[k], two[k], prefix + '    ');

        if (summary !== null) {
          result += prefix + '"' + k + '": ' + summary;
        }
      }
    }

    for (k in two) {
      if (!(k in one)) {
        result += prefix + '"' + k + '": the item was not expected\n';
      }
    }

    return result !== '\n' ? result : null;
  }

  if (is.string(one)) {
    if (!is.string(two)) {
      return 'expected type "' + name(one) + '" but found type "' + name(two) + '"\n';
    }

    if (one.valueOf() !== two.valueOf()) {
      return 'expected "' + one.valueOf() + '" but found "' + two.valueOf() + '"\n';
    }

    return null;
  }

  if (is.undefined(one)) {
    if (!is.undefined(two)) {
      return 'expected type "' + name(one) + '" but found type "' + name(two) + '"\n';
    }

    return null;
  }

  if (two == null || two.constructor !== one.constructor) {
    return 'expected an instance of type "' + name(one) + '"\n';
  } else {
    if (one !== two) {
      return 'expected a different instance of type "' + name(one) + '"\n';
    }
  }

  return null;
};

module.exports = compare;

},{"./is.js":304,"./name.js":306}],297:[function(require,module,exports){
var is = require('./is.js');

/**
 * Checks whether the given actual json conforms to the given schema. This
 * asserts that all required fields are present and have the correct types. It
 * also asserts that all optional fields either are present and have the correct
 * types or are missing in the given actual json.
 */
var conforms = function (actual, schema, verbose, path) {
  var i;
  var l;
  var result;
  var k;
  var parts;

  if (!is.boolean(verbose)) {
    verbose = false;
  }

  if (!is.string(path)) {
    path = 'root';
  }

  if (is.array(schema)) {
    if (is.array(actual)) {
      if (schema.length === 0) {
        return true;
      }

      if (schema.length !== 1) {
        if (verbose) {
          console.warn(path + ': expected an array with exactly one element in the schema but found ' + schema.length + ' elements');
        }

        return false;
      }

      result = true;

      for (i = 0, l = actual.length; i < l; i++) {
        if (!conforms(actual[i], schema[0], verbose, path + '[' + i + ']')) {
          result = false;
        }
      }

      return result;
    } else {
      if (verbose) {
        console.warn(path + ': expected an array but found', actual);
      }

      return false;
    }
  }

  if (is.boolean(schema)) {
    if (is.boolean(actual)) {
      return true;
    } else {
      if (verbose) {
        console.warn(path + ': expected a boolean but found', actual);
      }

      return false;
    }
  }

  if (is.number(schema)) {
    if (is.number(actual)) {
      return true;
    } else {
      if (verbose) {
        console.warn(path + ': expected a number but found', actual);
      }

      return false;
    }
  }

  if (is.object(schema)) {
    if (is.object(actual)) {
      result = true;

      for (k in schema) {
        parts = /^([^?]+)\?$/.exec(k);

        if (parts === null) {
          if (!conforms(actual[k], schema[k], verbose, path + '.' + k)) {
            result = false;
          }
        } else {
          if (actual[parts[1]] != null) {
            if (!conforms(actual[parts[1]], schema[k], verbose, path + '.' + k)) {
              result = false;
            }
          }
        }
      }

      return result;
    } else {
      if (verbose) {
        console.warn(path + ': expected an object but found', actual);
      }

      return false;
    }
  }

  if (is.string(schema)) {
    if (is.string(actual)) {
      return true;
    } else {
      if (verbose) {
        console.warn(path + ': expected a string but found', actual);
      }

      return false;
    }
  }

  if (verbose) {
    console.warn(path + ': expected a supported type in the schema but found', schema);
  }

  return false;
};

module.exports = conforms;

},{"./is.js":304}],298:[function(require,module,exports){
(function (global){
var check = require('./check.js');

/**
 * Makes base a pure class.
 */
var define = function (base) {
  check.function(base);

  base.prototype = global.Object.create(null);
  base.prototype.constructor = base;
};

module.exports = define;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./check.js":294}],299:[function(require,module,exports){
var is = require('./is.js');
var name = require('./name.js');

/**
 * Determines if the two given instances are identical. Compares arrays,
 * booleans, numbers, objects and strings as well as null and undefined by value
 * and other types by reference.
 */
var equals = function (one, two) {
  var i;
  var k;
  var l;

  if (is.array(one)) {
    if (!is.array(two)) {
      return false;
    }

    if (one.length !== two.length) {
      return false;
    }

    for (i = 0, l = one.length; i < l; i++) {
      if (!equals(one[i], two[i])) {
        return false;
      }
    }

    return true;
  }

  if (is.boolean(one)) {
    if (!is.boolean(two)) {
      return false;
    }

    if (one.valueOf() !== two.valueOf()) {
      return false;
    }

    return true;
  }

  if (is.null(one)) {
    if (!is.null(two)) {
      return false;
    }

    return true;
  }

  if (is.number(one)) {
    if (!is.number(two)) {
      return false;
    }

    if (one.valueOf() !== two.valueOf()) {
      return false;
    }

    return true;
  }

  if (is.object(one)) {
    if (!is.object(two)) {
      return false;
    }

    for (k in one) {
      if (!(k in two)) {
        return false;
      }

      if (!equals(one[k], two[k])) {
        return false;
      }
    }

    for (k in two) {
      if (!(k in one)) {
        return false;
      }
    }

    return true;
  }

  if (is.string(one)) {
    if (!is.string(two)) {
      return false;
    }

    if (one.valueOf() !== two.valueOf()) {
      return false;
    }

    return true;
  }

  if (is.undefined(one)) {
    if (!is.undefined(two)) {
      return false;
    }

    return true;
  }

  return one === two;
};

module.exports = equals;

},{"./is.js":304,"./name.js":306}],300:[function(require,module,exports){
(function (global){
var check = require('./check.js');

/**
 * Makes derived extend base.
 */
var extend = function (derived, base) {
  check.function(derived);
  check.function(base);

  derived.prototype = global.Object.create(base.prototype);
  derived.prototype.constructor = derived;
};

module.exports = extend;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./check.js":294}],301:[function(require,module,exports){
var is = require('./is.js');

/**
 * Returns the given fallback if the given instance is not an array.
 */
exports.array = function (instance, fallback) {
  return is.array(instance) ? instance : fallback;
};

/**
 * Returns the given fallback if the given instance is not a boolean.
 */
exports.boolean = function (instance, fallback) {
  return is.boolean(instance) ? instance : fallback;
};

/**
 * Returns the given fallback if the given instance is not a function.
 */
exports.function = function (instance, fallback) {
  return is.function(instance) ? instance : fallback;
};

/**
 * Returns the given fallback if the given instance is not null.
 */
exports.null = function (instance, fallback) {
  return is.null(instance) ? instance : fallback;
};

/**
 * Returns the given fallback if the given instance is not a number.
 */
exports.number = function (instance, fallback) {
  return is.number(instance) ? instance : fallback;
};

/**
 * Returns the given fallback if the given instance is not an object.
 */
exports.object = function (instance, fallback) {
  return is.object(instance) ? instance : fallback;
};

/**
 * Returns the given fallback if the given instance is not a string.
 */
exports.string = function (instance, fallback) {
  return is.string(instance) ? instance : fallback;
};

/**
 * Returns the given fallback if the given instance does not descend from the
 * given constructor.
 */
exports.type = function (instance, constructor, fallback) {
  return is.type(instance, constructor) ? instance : fallback;
};

/**
 * Returns the given fallback if the given instance is not undefined.
 */
exports.undefined = function (instance, fallback) {
  return is.undefined(instance) ? instance : fallback;
};

},{"./is.js":304}],302:[function(require,module,exports){
/**
 * Creates a function wrapper that always returns the given value.
 */
var fixture = function (value) {
  return function () {
    return value;
  };
};

module.exports = fixture;

},{}],303:[function(require,module,exports){
exports.assert = require('./assert.js');
exports.check = require('./check.js');
exports.clone = require('./clone.js');
exports.compare = require('./compare.js');
exports.conforms = require('./conforms.js');
exports.define = require('./define.js');
exports.equals = require('./equals.js');
exports.extend = require('./extend.js');
exports.fallback = require('./fallback.js');
exports.fixture = require('./fixture.js');
exports.is = require('./is.js');
exports.mock = require('./mock.js');
exports.name = require('./name.js');
exports.spy = require('./spy.js');
exports.stub = require('./stub.js');

},{"./assert.js":293,"./check.js":294,"./clone.js":295,"./compare.js":296,"./conforms.js":297,"./define.js":298,"./equals.js":299,"./extend.js":300,"./fallback.js":301,"./fixture.js":302,"./is.js":304,"./mock.js":305,"./name.js":306,"./spy.js":307,"./stub.js":308}],304:[function(require,module,exports){
(function (global){
/**
 * Determines if the given instance is an array.
 */
exports.array = function (instance) {
  return instance != null && instance.constructor === global.Array;
};

/**
 * Determines if the given instance is a boolean.
 */
exports.boolean = function (instance) {
  return instance != null && instance.constructor === global.Boolean;
};

/**
 * Determines if the given instance is a function.
 */
exports.function = function (instance) {
  return instance != null && instance.constructor === global.Function;
};

/**
 * Determines if the given instance is null.
 */
exports.null = function (instance) {
  return instance === null;
};

/**
 * Determines if the given instance is a number.
 */
exports.number = function (instance) {
  return instance != null && instance.constructor === global.Number;
};

/**
 * Determines if the given instance is an object.
 */
exports.object = function (instance) {
  return instance != null && instance.constructor === global.Object;
};

/**
 * Determines if the given instance is a string.
 */
exports.string = function (instance) {
  return instance != null && instance.constructor === global.String;
};

/**
 * Determines if the given instance descends from the given constructor.
 */
exports.type = function (instance, constructor) {
  return instance != null && constructor != null && instance instanceof constructor;
};

/**
 * Determines if the given instance is undefined.
 */
exports.undefined = function (instance) {
  return instance === global.undefined;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],305:[function(require,module,exports){
(function (global){
var check = require('./check.js');
var extend = require('./extend.js');
var is = require('./is.js');

/**
 * Creates a mock for the given base class with the given implementation that
 * can be used for unit testing. The methods defined on implementation will be
 * used instead of the methods defined on the base class.
 */
var mock = function (base, implementation) {
  var derived;
  var keys;
  var i;
  var key;

  check.function(base);

  derived = function () {
    base.apply(this, arguments);
  };

  extend(derived, base);

  derived.create = function () {
    var that;

    that = global.Object.create(derived.prototype);

    derived.apply(that, arguments);

    return that;
  };

  if (implementation != null) {
    check.object(implementation);

    keys = global.Object.getOwnPropertyNames(implementation);

    for (i = 0; i < keys.length; i++) {
      key = keys[i];

      if (key !== 'constructor' && is.function(implementation[key])) {
        if (is.function(base.prototype[key])) {
          derived.prototype[key] = implementation[key];
        } else {
          throw new global.Error('Method "' + key + '" doesn\'t override any method defined on the base class!');
        }
      }
    }
  }

  return derived;
};

module.exports = mock;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./check.js":294,"./extend.js":300,"./is.js":304}],306:[function(require,module,exports){
var is = require('./is.js');

/**
 * Attempts to read the type name for the given instance.
 */
var name = function (instance) {
  if (is.null(instance)) {
    return 'Null';
  }

  if (is.undefined(instance)) {
    return 'Undefined';
  }

  if (is.function(instance.constructor) && is.string(instance.constructor.name)) {
    return instance.constructor.name;
  }

  return '';
};

module.exports = name;

},{"./is.js":304}],307:[function(require,module,exports){
(function (global){
var check = require('./check.js');

/**
 * Creates a spy function that records all function calls into the given calls
 * array.
 */
var spy = function (calls) {
  check.array(calls);

  return function () {
    calls.push({ 'caller' : this, 'arguments' : global.Array.prototype.slice.call(arguments) });
  };
};

module.exports = spy;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./check.js":294}],308:[function(require,module,exports){
(function (global){
var check = require('./check.js');
var extend = require('./extend.js');
var is = require('./is.js');

/**
 * Creates a stub for the given base class with the given implementation that
 * can be used for unit testing.
 */
var stub = function (base, implementation) {
  var derived;
  var prototype;
  var keys;
  var i;
  var key;

  check.function(base);
  check.object(implementation);

  derived = function () {
    var key;

    for (key in implementation) {
      this[key] = implementation[key];
    }
  };

  extend(derived, base);

  derived.create = function () {
    var that;

    that = global.Object.create(derived.prototype);

    derived.apply(that, arguments);

    return that;
  };

  prototype = base.prototype;

  while (prototype != null && prototype !== global.Object.prototype) {
    keys = global.Object.getOwnPropertyNames(prototype);

    for (i = 0; i < keys.length; i++) {
      key = keys[i];

      if (key !== 'constructor' && is.function(prototype[key])) {
        if (is.function(implementation[key])) {
          derived.prototype[key] = implementation[key];
        } else {
          derived.prototype[key] = (function (key) {
            return function () {
              throw new global.Error('Method stub "' + key + '" called!');
            };
          })(key);
        }
      }
    }

    prototype = global.Object.getPrototypeOf(prototype);
  }

  return derived;
};

module.exports = stub;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./check.js":294,"./extend.js":300,"./is.js":304}],309:[function(require,module,exports){
'use strict';

exports.message = require('./src/message');
exports.request = require('./src/request');
exports.response = require('./src/response');
exports.playerstate = require('./src/player_state');

},{"./src/message":310,"./src/player_state":311,"./src/request":312,"./src/response":313}],310:[function(require,module,exports){
/**
 * A set of Message headers.
 *
 * @name exports.Headers
 * @typedef {Object.<string, string>}
 */
exports.Headers;

/**
 * A body of a Request-Response.
 *
 * @name exports.Body
 * @typedef {*}
 */
exports.Body;

/**
 * A serialized Message object.
 *
 * @name Spotify.Cosmos.SerializedMessage
 * @typedef {{
 *   uri: Spotify.Cosmos.URI,
 *   headers: Spotify.Cosmos.Headers,
 *   body: Spotify.Cosmos.Body
 * }}
 */
exports.SerializedMessage;

/**
 * Encapsulates a message.
 *
 * A message is an entity that has a URI, headers and a body.
 *
 * @constructs Spotify.Cosmos.Message
 * @param {Spotify.Cosmos.URI} uri The URI of the message
 * @param {Spotify.Cosmos.Headers=} opt_headers The optional headers of the
 *     message.
 * @param {Spotify.Cosmos.Body=} opt_body The optional body of the message.
 */
function Message(uri, opt_headers, opt_body) {
  if (uri == null)
    throw new TypeError('Invalid `uri` argument for Message.');

  /**
   * The URI of the Message.
   *
   * @type {Spotify.Cosmos.URI}
   * @protected
   */
  this._uri = uri;

  /**
   * The headers of the Message.
   *
   * @type {Spotify.Cosmos.Headers}
   * @protected
   */
  this._headers = {};

  /**
   * The body of the Message.
   *
   * @type {Spotify.Cosmos.Body}
   * @protected
   */
  this._body = this._encodeBody(opt_body || '');

  if (opt_headers) this._setHeaders(opt_headers);
}
exports.Message = Message;

/**
 * Creates a new Message from a SerializedMessage object.
 *
 * @param {Spotify.Cosmos.SerializedMessage} object The serialized request.
 * @return {Spotify.Cosmos.Message|null} The new Message object or null.
 */
Message.fromObject = function(object) {
  return (object && object.uri) ?
    new Message(
        object.uri,
        object.headers,
        object.body
    ) : null;
};

/**
 * Encodes a message body to a string.
 *
 * @param {*} body The value for the body.
 * @return {string} The body encoded as a string.
 */
Message.prototype._encodeBody = function(body) {
  if (typeof body != 'string') {
    body = JSON.stringify(body);
  }
  return body;
};

/**
 * Returns the URI of the message.
 *
 * @return {Spotify.Cosmos.URI} The URI of the message.
 */
Message.prototype.getURI = function() {
  return this._uri;
};

/**
 * Returns the mimetype of the message.
 *
 * @return {Spotify.Cosmos.MimeType} The mimetype of the message.
 */
Message.prototype.getMimeType = function() {
  return this._headers['accept'];
};

/**
 * Returns the value of a message's headers.
 *
 * @param {string} name The name of the header.
 * @return {string|null} The header value or null if the header wasn't set.
 */
Message.prototype.getHeader = function(name) {
  return this._headers[name.toLowerCase()] || null;
};

/**
 * Returns the headers of the message.
 *
 * @return {Spotify.Cosmos.Headers} The headers of the message.
 */
Message.prototype.getHeaders = function() {
  var _headers = this._headers;
  var headers = {};
  for (var name in _headers) {
    if (!_headers.hasOwnProperty(name)) continue;
    headers[name] = _headers[name];
  }
  return headers;
};

/**
 * Sets a bunch of headers to the message's headers.
 *
 * @param {Spotify.Cosmos.Headers} headers The headers to set to the message.
 * @protected
 */
Message.prototype._setHeaders = function(headers) {
  var _headers = this._headers;
  for (var name in headers) {
    if (!headers.hasOwnProperty(name)) continue;
    _headers[name.toLowerCase()] = headers[name];
  }
  return this;
};

/**
 * Returns the body of the message.
 *
 * @return {Spotify.Cosmos.Body} The body of the message.
 */
Message.prototype.getBody = function() {
  return this._body;
};

/**
 * Returns the body as a JSON object.
 *
 * @return {Object|null} The body of the message parsed as a JSON value. Can
 *     be null if the body is not a proper JSON string.
 */
Message.prototype.getJSONBody = function() {
  try {
    return JSON.parse(this._body);
  } catch(e) {
    return null;
  }
};

/**
 * Creates a new Message instance with data copied from the current instance.
 *
 * @param {Spotify.Cosmos.Headers=} opt_headers The optional headers of the
 *     message.
 * @param {Spotify.Cosmos.Body=} opt_body The optional body of the message.
 */
Message.prototype.copy = function(opt_headers, opt_body) {
  return new Message(
      this._uri,
      this._copyHeaders(opt_headers),
      typeof opt_body != 'undefined' ? opt_body : this._body
  );
};

/**
 * Copies the headers of the message.
 *
 * @param {Spotify.Cosmos.Headers=} opt_headers The optional headers of the
 *     message.
 * @return {Spotify.Cosmos.Headers} The headers of the message.
 */
Message.prototype._copyHeaders = function(opt_headers) {
  var headers;
  if (opt_headers) {
    var _headers = this._headers;
    var name;
    headers = {};
    for (name in _headers) {
      if (!_headers.hasOwnProperty(name)) continue;
      headers[name] = _headers[name];
    }
    for (name in opt_headers) {
      if (!opt_headers.hasOwnProperty(name)) continue;
      headers[name.toLowerCase()] = opt_headers[name];
    }
  } else {
    headers = this._headers;
  }
  return headers;
};

/**
 * Serializes the message into a plain object.
 *
 * @return {Spotify.Cosmos.SerializedMessage} The serialized object.
 */
Message.prototype.serialize = function() {
  return this.toJSON();
};

/**
 * Returns a JSON-object representation of the message.
 *
 * @return {Object} The JSON representation of the message.
 */
Message.prototype.toJSON = function() {
  return {
    uri: this._uri,
    headers: this._headers,
    body: this._body
  };
};

},{}],311:[function(require,module,exports){
var inherit = require('spotify-inheritance').inherit;

/**
 * PlayerState is used for two distinct purposes: Pushing new state to the
 * player (this is done when you request to play a completely new context with
 * 'play' method) and retrieving player state updates.
 *
 * Changing properties on PlayerState objects will not change the state of
 * the player unless you pass it to the 'play' method.
 *
 * @param {Object} stateData the data for the playerState.
 */
function PlayerState(stateData) {
  Serializable.call(this, [
    'action',
    'context',
    'tracks',
    'index',
    'playing',
    'loading',
    'track',
    'position',
    'duration',
    'volume',
    'options',
    'play_origin',
    'next_page_url',
    'prev_page_url'
  ]);

  stateData = stateData || {};
  /**
   * What kind of the action player should perform.
   * It's set directly before sending the request.
   * @type {String}
   */
  this.action = stateData.action;

  /**
   * Spotify uri describing the context that
   * will be played e.g playlist, album or artist.
   * Example: spotify:artist:4XaUmUGjidSklcDHxv3XWf,
   * spotify:user:daftpunkofficial:playlist:5nrg0D90OlFyveVfrQD0zE,
   * spotify:album:2nXJkqkS1tIKIyhBcFMmwz
   *
   * @type {String}
   */
  this.context = stateData.context;

  /**
   * The list of tracks uris to play in the given context.
   * Example: [
   *    spotify:track:0bXpmJyHHYPk6QBFj25bYF,
   *    spotify:track:6DXFVsLcEvOTSrkG9G1Cb1,
   *    spotify:track:6rxEjkoar48SssZePbtb2x
   * ]
   *
   * @type {Array.<String>}
   */
  this.tracks = stateData.tracks;

  /**
   * Which element on the this.tracks list should
   * be played.
   *
   * @type {Number}
   */
  this.index = stateData.index;

  /**
   * Is the player currently playing
   */
  this.playing = stateData.playing;
  this.loading = stateData.loading;

  /**
   * Current track URI
   * @type {String}
   */
  this.track = stateData.track;


  this.position = stateData.position;

  this.volume = stateData.volume;

  /**
   * Current track duration in miliseconds?
   * @type {Number}
   */
  this.duration = stateData.duration;

  /**
   * See PlayOptions description
   * @type {cosmos-bindings-js/scripts/player_state~PlayOptions}
   */
  this.options = new PlayOptions(stateData.options);

  /**
   * See PlayOrigin description
   * @type {cosmos-bindings-js/scripts/player_state~PlayOrigin}
   */
  this.play_origin = new PlayOrigin(stateData.play_origin);

  /**
   * Before the list of tracks that are to be played ends, a request will be sent
   * to this URL, which is supposed to return a list of tracks. That list of
   * tracks will then be appended to the list of tracks in the context.
   *
   * The response payload of the next_page_url should look like this:
   *
   * {
   *   "tracks": [
   *     { "track": "spotify:track:$TRACK-ID1", "context": "spotify:album:$ALBUM-ID1" },
   *     { "track": "spotify:track:$TRACK-ID2", "context": "spotify:album:$ALBUM-ID1" },
   *     { "track": "spotify:track:$TRACK-ID3", "context": "spotify:album:$ALBUM-ID1" },
   *   ],
   *   "next_page_url": "...", // Optional
   *   "prev_page_url": "..." // Optional
   * }
   *
   * May be null, which is the same as a URL that would return an empty list
   * of tracks (but with null, no network request is made).
   */
  this.next_page_url = stateData.next_page_url;

  /**
   * Like `next_page_url`, but for going backwards in the context.
   */
  this.prev_page_url = stateData.prev_page_url;
}
inherit(PlayerState, Serializable);

/**
 * Ovverides prototype method.
 * Converts play options and origin to
 * serializable to make sure only correct data
 * is returned.
 * @return {Object} Data associated with player state.
 */
PlayerState.prototype.serialize = function() {
  if (this.options && !(this.options instanceof PlayOptions)) {
    this.options = new PlayOptions(this.options);
  }

  if (this.play_origin && !(this.play_origin instanceof PlayOrigin)) {
    this.play_origin = new PlayOrigin(this.play_origin);
  }

  return this.constructor.prototype.serialize.call(this);
};

/**
 * Possible player actions.
 */
PlayerState.ACTIONS = {
  UNKNOWN: 'unknown',
  PLAY: 'play',
  UPDATE: 'update',
  STOP: 'stop',
  RESUME: 'resume',
  PAUSE: 'pause',
  SKIP_PREV: 'skip_prev',
  SKIP_NEXT: 'skip_next'
};

function PlayOrigin(data) {
  Serializable.call(this, [
    'source',
    'source_context',
    'reason',
    'referrer',
    'referrer_version',
    'referrer_vendor'
  ]);

  data = data || {};

  /**
   * What kind of playlist did we play from?
   *
   * The default value of this property is "unknown". Must have a value.
   *
   * Valid values include 'album', 'artist', 'extlink', 'playlist', 'playqueue',
   * 'radio', 'search', 'unknown'.
   *
   * For an up to date list of valid values, see `PLAY_SOURCES` in
   * https://git.spotify.net/cgit.cgi/log-parser.git/tree/spotify/log_parser/messages_specs.py
   */
  this.source = data.source || 'unknown';

  /**
   * The uri of the view that initiated the playback.
   */
  this.source_context = data.source_context || 'unknown';

  /**
   * Why was the song started?
   *
   * The default value of this property is "unknown". Must have a value.
   *
   * A list of valid values that might be used by features:
   *
   * unknown    = Client doesn't know
   * clickrow   = A row in the song list was clicked/opened
   * playbtn    = The play button was pressed
   * urlopen    = A Url was opened
   *
   * For a complete and up to date list of valid values, see `PLAY_REASONS` in
   * https://git.spotify.net/cgit.cgi/log-parser.git/tree/spotify/log_parser/messages_specs.py
   */
  this.reason = data.reason || 'unknown';

  /**
   * Either a remote site or a spotify app which initiated the request.
   *
   * NOTE: This normally should be a readonly property and not be set
   * explicitly in the PlayerState as the Player will overwrite it when sending the request.
   */
  this.referrer = data.referrer || 'unknown';

  /**
   * The version of the referrer, where applicable. It usually makes sense to
   * set this value to the version of the JS app version, for instance "0.7.5".
   *
   * NOTE: This normally should be a readonly property and not be set
   * explicitly in the PlayerState as the Player will overwrite it when sending the request.
   */
  this.referrer_version = data.referrer_version || 'unknown';

  /**
   * The vendor of the referrer, where applicable.
   * For example com.soundrop, com.spotify.
   *
   * NOTE: This normally should be a readonly property and not be set
   * explicitly in the PlayerState as the Player will overwrite it when sending the request.
   */
  this.referrer_vendor = data.referrer_vendor || 'unknown';
}
inherit(PlayOrigin, Serializable);

/**
 * What kind of options user has
 * with the player. By default
 * all 'can_*' properties are set to true.
 * You might want to restrict some of them
 * in the special cases like ads (no skipping)
 * or radio no skipping prev.
 * @constructor
 * @param {Object} options The options data.
 */
function PlayOptions(options) {
  Serializable.call(this, [
    'repeat',
    'shuffle',
    'can_repeat',
    'can_shuffle',
    'can_skip_prev',
    'can_skip_next',
    'can_seek',
    'use_dmca_rules'
  ]);
  options = options || {};

  /**
   * True if repeat (repeat all, not single track repeat) is (or is to be) enabled.
   *
   * Default value is false
   */
  this.repeat = options.repeat !== undefined ? options.repeat : false;

  /**
   * True if shuffle is (or is to be) enabled.
   *
   * Default value is false
   */
  this.shuffle = options.shuffle !== undefined ? options.shuffle : false;

  /**
   * True if this context can be repeated. This would be false for instance in the
   * case of radio.
   *
   * Default value is true.
   */
  this.can_repeat = options.can_repeat !== undefined ? options.can_repeat : true;

  /**
   * True if this context can be shuffled. This would be false for instance in the
   * case of radio.
   *
   * Default value is true.
   */
  this.can_shuffle = options.can_shuffle !== undefined ? options.can_shuffle : true;

  /**
   * True if the user is (or should be) allowed to skip to the previous track.
   *
   * Default value is true.
   */
  this.can_skip_prev = options.can_skip_prev !== undefined ? options.can_skip_prev : true;

  /**
   * True if the user is (or should be) allowed to skip to the next track.
   *
   * Default value is true.
   */
  this.can_skip_next = options.can_skip_next !== undefined ? options.can_skip_next : true;

  /**
   * True if the user is (or should be) allowed to seek to a certain time in the
   * currently playing track.
   *
   * Default value is true.
   */
  this.can_seek = options.can_seek !== undefined ? options.can_seek : true;

  /**
   * True if the track player should automatically apply DMCA rules when playing.
   * DMCA rules should be enabled for users that have free radio in the US, and
   * controls how many tracks the user are allowed to skip etc.
   *
   * Default value is false.
   */
  this.use_dmca_rules = options.use_dmca_rules !== undefined ? options.use_dmca_rules : false;
}
inherit(PlayOptions, Serializable);

/**
 * The object accepting only defined properties.
 * To make sure only valid properties are passed
 * always use 'serialize()' when object value needed.
 * @constructor
 * @param {Array.<string>} allowedProps The list of the properties
 * that are supported for the object.
 */
function Serializable(allowedProps) {
  this._props = allowedProps || [];
}

/**
 * The JSON representation of the object.
 * @return {Object} Data associated with current player state.
 */
Serializable.prototype.serialize = function() {
  var data = {};
  var prop;

  for (var i = 0, l = this._props.length; i < l; i++) {
    prop = this._props[i];
    if (this[prop] !== undefined) {
      if (this[prop] instanceof Serializable) {
        data[prop] = this[prop].serialize();
      } else {
        data[prop] = this[prop];
      }
    }
  }

  return data;
};

exports.PlayerState = PlayerState;

},{"spotify-inheritance":424}],312:[function(require,module,exports){
var inherit = require('spotify-inheritance').inherit;

var Message = require('./message').Message;

/**
 * Request actions.
 *
 * @name exports.Action
 * @enum {string}
 */
exports.Action = {
  DELETE: 'DELETE',
  GET: 'GET',
  HEAD: 'HEAD',
  POST: 'POST',
  PUT: 'PUT',
  SUB: 'SUB',
  PATCH: 'PATCH'
};

/**
 * A serialized Request object.
 *
 * @name Spotify.Cosmos.SerializedRequest
 * @typedef {{
 *   uri: Spotify.Cosmos.URI,
 *   headers: Spotify.Cosmos.Headers,
 *   body: Spotify.Cosmos.Body
 * }}
 */
exports.SerializedRequest;

/**
 * Encapsulates a request to the handlers.
 *
 * Instances of this class are "immutable" and should not be changed.
 *
 * @constructs Spotify.Cosmos.Request
 * @extends Spotify.Cosmos.Message
 * @param {Spotify.Cosmos.Action} action The action of the request.
 * @param {Spotify.Cosmos.URI} uri The URI of the request
 * @param {Spotify.Cosmos.Headers=} opt_headers The optional headers of the
 *     request.
 * @param {Spotify.Cosmos.Body=} opt_body The optional body of the request.
 */
function Request(action, uri, opt_headers, opt_body) {
  if (!(this instanceof Request))
    return new Request(action, uri, opt_headers, opt_body);
  if (!action)
    throw new TypeError('Invalid `action` argument for Request.');
  Message.call(this, uri, opt_headers, opt_body);

  /**
   * The action of the request.
   *
   * @type {Spotify.Cosmos.Action}
   * @protected
   */
  this._action = action;
}
inherit(Request, Message);
exports.Request = Request;

/**
 * Creates a new Request from a SerializedRequest object.
 *
 * @param {Spotify.Cosmos.SerializedRequest} object The serialized request.
 * @return {Spotify.Cosmos.Request|null} The new Request object or null.
 */
Request.fromObject = function(object) {
  return (object && object.action && object.uri) ?
    new Request(
        object.action,
        object.uri,
        object.headers,
        object.body
    ) : null;
};

/**
 * Returns the action of the request.
 *
 * @return {Spotify.Cosmos.Action} The action of the request.
 */
Request.prototype.getAction = function() {
  return this._action;
};

/**
 * @inheritDoc
 */
Request.prototype.copy = function(opt_headers, opt_body) {
  return new Request(
      this._action,
      this._uri,
      this._copyHeaders(opt_headers),
      typeof opt_body != 'undefined' ? opt_body : this._body
  );
};

/**
 * @inheritDoc
 */
Request.prototype.toJSON = function() {
  return {
    action: this._action,
    uri: this._uri,
    headers: this._headers,
    body: this._body
  };
};



},{"./message":310,"spotify-inheritance":424}],313:[function(require,module,exports){
var inherit = require('spotify-inheritance').inherit;

var Message = require('./message').Message;

/**
 * Statuscode.
 * The statuses with negative numbers are reserved for
 * errors that originate within the cosmos library.
 *
 * @name exports.StatusCode
 * @enum {number}
 */
exports.StatusCode = {
  OK: 200,
  CREATED: 201,
  ACCEPTED: 202,
  BAD_REQUEST: 400,
  UNAUTHORIZED: 401,
  FORBIDDEN: 403,
  NOT_FOUND: 404,
  METHOD_NOT_ALLOWED: 405,
  TIMED_OUT: 408,
  CONFLICT: 409,
  GONE: 410,
  INTERNAL_SERVER_ERROR: 500,
  NOT_IMPLEMENTED: 501,
  BAD_GATEWAY: 502,
  SERVICE_UNAVAILABLE: 503,

  /** Something went wrong, but the exact reason is not known. */
  ERROR_UNKNOWN: -100,

  /** A resource allocation required to complete the request failed. */
  ERROR_ALLOCATION_FAILED: -101,

  /** The body could not be decoded because it does
   not conform to the encoding header field. */
  ERROR_INVALID_ENCODING: -102,

  /** The router detected an infinite loop while processing the request. */
  ERROR_INFINITE_LOOP: -103,

  /** No endpoint resolver that could handle the request was found. */
  ERROR_RESOLVER_NOT_FOUND: -104
};

/**
 * A serialized Response object.
 *
 * @name Spotify.Cosmos.SerializedResponse
 * @typedef {{
 *   uri: Spotify.Cosmos.URI,
 *   status: Spotify.Cosmos.StatusCode,
 *   headers: Spotify.Cosmos.Headers,
 *   body: Spotify.Cosmos.Body
 * }}
 */
exports.SerializedResponse;

/**
 * Encapsulates a response from the handlers.
 *
 * @constructs Spotify.Cosmos.Response
 * @extends Spotify.Cosmos.Message
 * @param {Spotify.Cosmos.URI} uri The URI of the response
 * @param {Spotify.Cosmos.StatusCode} status The status of the response.
 * @param {Spotify.Cosmos.Headers=} opt_headers The optional headers of the
 *     response.
 * @param {Spotify.Cosmos.Body=} opt_body The optional body of the response.
 */
function Response(uri, status, opt_headers, opt_body) {
  if (!(this instanceof Response))
    return new Response(uri, status, opt_headers, opt_body, opt_requestURI);
  if (typeof status == 'undefined' || status == null)
    throw new TypeError('Invalid `status` argument for Response.');

  Message.call(this, uri, opt_headers, opt_body);

  /**
   * The Status of the Response.
   *
   * @type {Spotify.Cosmos.StatusCode}
   * @protected
   */
  this._status = status;
}
inherit(Response, Message);
exports.Response = Response;

/**
 * Creates a new Response from a SerializedResponse object.
 *
 * @param {Spotify.Cosmos.SerializedResponse} object The serialized response.
 * @return {Spotify.Cosmos.Response|null} The new Response object or null.
 */
Response.fromObject = function(object) {
  return (object && object.uri && object.status) ?
    new Response(
        object.uri,
        object.status,
        object.headers,
        object.body
    ) : null;
};

/**
 * @inheritDoc
 */
Response.prototype.getMimeType = function() {
  return this._headers['content-type'];
};

/**
 * Returns the status code of the Response.
 *
 * @return {Spotify.Cosmos.StatusCode} The status code of the response.
 */
Response.prototype.getStatusCode = function() {
  return this._status;
};

/**
 * @inheritDoc
 */
Response.prototype.copy = function(opt_headers, opt_body) {
  return new Response(
      this._uri,
      this._status,
      this._copyHeaders(opt_headers),
      typeof opt_body != 'undefined' ? opt_body : this._body
  );
};

/**
 * @inheritDoc
 */
Response.prototype.toJSON = function() {
  return {
    uri: this._uri,
    status: this._status,
    headers: this._headers,
    body: this._body
  };
};


},{"./message":310,"spotify-inheritance":424}],314:[function(require,module,exports){

/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = require('./debug');
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // is webkit? http://stackoverflow.com/a/16459606/376773
  return ('WebkitAppearance' in document.documentElement.style) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (window.console && (console.firebug || (console.exception && console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  return JSON.stringify(v);
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs() {
  var args = arguments;
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return args;

  var c = 'color: ' + this.color;
  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
  return args;
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}
  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage(){
  try {
    return window.localStorage;
  } catch (e) {}
}

},{"./debug":315}],315:[function(require,module,exports){

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = debug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = require('ms');

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lowercased letter, i.e. "n".
 */

exports.formatters = {};

/**
 * Previously assigned color.
 */

var prevColor = 0;

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 *
 * @return {Number}
 * @api private
 */

function selectColor() {
  return exports.colors[prevColor++ % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function debug(namespace) {

  // define the `disabled` version
  function disabled() {
  }
  disabled.enabled = false;

  // define the `enabled` version
  function enabled() {

    var self = enabled;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // add the `color` if not set
    if (null == self.useColors) self.useColors = exports.useColors();
    if (null == self.color && self.useColors) self.color = selectColor();

    var args = Array.prototype.slice.call(arguments);

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %o
      args = ['%o'].concat(args);
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    if ('function' === typeof exports.formatArgs) {
      args = exports.formatArgs.apply(self, args);
    }
    var logFn = enabled.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }
  enabled.enabled = true;

  var fn = exports.enabled(namespace) ? enabled : disabled;

  fn.namespace = namespace;

  return fn;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  var split = (namespaces || '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

},{"ms":401}],316:[function(require,module,exports){
var hasOwn = Object.prototype.hasOwnProperty;
var toStr = Object.prototype.toString;
var undefined;

var isArray = function isArray(arr) {
	if (typeof Array.isArray === 'function') {
		return Array.isArray(arr);
	}

	return toStr.call(arr) === '[object Array]';
};

var isPlainObject = function isPlainObject(obj) {
	'use strict';
	if (!obj || toStr.call(obj) !== '[object Object]') {
		return false;
	}

	var has_own_constructor = hasOwn.call(obj, 'constructor');
	var has_is_property_of_method = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');
	// Not own constructor property must be Object
	if (obj.constructor && !has_own_constructor && !has_is_property_of_method) {
		return false;
	}

	// Own properties are enumerated firstly, so to speed up,
	// if last one is own, then all properties are own.
	var key;
	for (key in obj) {}

	return key === undefined || hasOwn.call(obj, key);
};

module.exports = function extend() {
	'use strict';
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[0],
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if (typeof target === 'boolean') {
		deep = target;
		target = arguments[1] || {};
		// skip the boolean and the target
		i = 2;
	} else if ((typeof target !== 'object' && typeof target !== 'function') || target == null) {
		target = {};
	}

	for (; i < length; ++i) {
		options = arguments[i];
		// Only deal with non-null/undefined values
		if (options != null) {
			// Extend the base object
			for (name in options) {
				src = target[name];
				copy = options[name];

				// Prevent never-ending loop
				if (target === copy) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {
					if (copyIsArray) {
						copyIsArray = false;
						clone = src && isArray(src) ? src : [];
					} else {
						clone = src && isPlainObject(src) ? src : {};
					}

					// Never move original objects, clone them
					target[name] = extend(deep, clone, copy);

				// Don't bring in undefined values
				} else if (copy !== undefined) {
					target[name] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};


},{}],317:[function(require,module,exports){
/*
Finally
*/'use strict';

var prime = require('prime');

var kindOf = require('mout/lang/kindOf');
var map = require('mout/array/map');
var slice = require('mout/array/slice');
var forEach = require('mout/array/forEach');
var reduce = require('mout/array/reduce');

var each = require('mout/collection/forEach');
var cmap = require('mout/collection/map');

var push_ = Array.prototype.push;

/* create the flow */
var Flow = prime({

  /* options */
  constructor: function Flow() {
    this._seq = [];
  },

  /* add steps to the flow */
  then: function() {
    this._push(this._callbacks(arguments));
    return this;
  },

  _parallel: function(parallel, args) {
    var self = this;
    return function() {
      var control = new Controller(self, self._index++);
      self._controls.push(control);
      parallel.apply(control, args ? args.concat(slice(arguments)) : arguments);
    };
  },

  _push: function(parallels, args) {
    if (!parallels.length) return;
    this._seq.push(map(parallels, function(parallel) {
      return this._parallel(parallel, args);
    }, this));
  },

  _callbacks: function(callbacks) {
    return reduce(callbacks, function(a, b) {
      if (kindOf(b) === 'Array') push_.apply(a, b);
      else a.push(b);
      return a;
    }, []);
  },

  /* will make a sequential entry for each entry in the object */
  sequential: function(object) {
    var callbacks = this._callbacks(slice(arguments, 1));
    each(object, function(value, key) {
      this._push(callbacks, [value, key]);
    }, this);
    return this;
  },

  /* will make a single sequential entry with one parallel for each entry in the object */
  parallel: function(object, parallel) {
    var parallels = cmap(object, function(value, key) {
      return this._parallel(parallel, [value, key]);
    }, this);
    if (parallels.length) this._seq.push(parallels);
    return this;
  },

  /* assign last step and execute the flow */
  finally: function() {
    this.then.apply(this, arguments);
    this._continue.call(this);
    return this;
  },

  /* execute the flow with arguments to the first step */
  run: function() {
    this._continue.apply(this, arguments);
    return this;
  },

  // private

  _break: function() {
    this._seq.splice(0, this._seq.length - 1);
    this._continue.apply(this, arguments);
  },

  _spread: function(error, args) {
    var seq = this._next();
    if (!seq || !(seq = seq[0])) return;
    if (!args || !args.length) args = [undefined];
    this._length = args.length;
    forEach(args, function(arg) {
      seq(error, arg);
    });
  },

  _continue: function() {
    var seq = this._next();
    if (!seq) return;
    this._length = seq.length;
    var args = arguments;
    forEach(seq, function(parallel) {
      parallel.apply(null, args);
    });
  },

  _next: function() {
    var seq = this._seq.shift();
    if (!seq) return;

    if (this._controls) forEach(this._controls, function(control) { // kill old controls
      control._kill();
    });

    // reset variables

    this._arguments = [];
    this._errors = [];
    this._controls = [];
    this._index = 0;

    return seq;
  },

  _done: function(index, error, data) {
    this._arguments[index] = data;
    if (error) this._errors.push(error);
    if (!--this._length) {
      var errors = null;
      if (this._errors.length === 1) errors = this._errors[0];
      else if (this._errors.length) errors = new Error(map(this._errors, function(e) {
        return e.message;
      }).join('\n'));
      this._continue.apply(this, [errors].concat(this._arguments));
    }
    else this._controls[index]._kill();
  }

});

/* control the flow */
var Controller = function Controller(flow, index) {

  var dead;

  this._kill = function() {
    dead = true;
  };

  /* break the flow */
  this.break = function() {
    if (!dead) flow._break.apply(flow, arguments);
  };

  /* step in the next sequential */
  this.continue = function() {
    if (!dead) flow._continue.apply(flow, arguments);
  };

  /* spread results to the next sequential */
  this.spread = function(error, args) {
    if (!dead) flow._spread(error, args);
  };

  /* set the the current parallel in the sequential as complete */
  var done = this.done = function(error, data) {
    if (!dead) flow._done.call(flow, index, error, data);
  };

};

/* public interface */
module.exports = function() {
  var flow = new Flow();
  flow.then.apply(flow, arguments);
  return flow;
};

},{"mout/array/forEach":318,"mout/array/map":319,"mout/array/reduce":320,"mout/array/slice":321,"mout/collection/forEach":322,"mout/collection/map":324,"mout/lang/kindOf":332,"prime":339}],318:[function(require,module,exports){


    /**
     * Array forEach
     */
    function forEach(arr, callback, thisObj) {
        if (arr == null) {
            return;
        }
        var i = -1,
            len = arr.length;
        while (++i < len) {
            // we iterate over sparse items since there is no way to make it
            // work properly on IE 7-8. see #64
            if ( callback.call(thisObj, arr[i], i, arr) === false ) {
                break;
            }
        }
    }

    module.exports = forEach;



},{}],319:[function(require,module,exports){
var makeIterator = require('../function/makeIterator_');

    /**
     * Array map
     */
    function map(arr, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        var results = [];
        if (arr == null){
            return results;
        }

        var i = -1, len = arr.length;
        while (++i < len) {
            results[i] = callback(arr[i], i, arr);
        }

        return results;
    }

     module.exports = map;


},{"../function/makeIterator_":326}],320:[function(require,module,exports){


    /**
     * Array reduce
     */
    function reduce(arr, fn, initVal) {
        // check for args.length since initVal might be "undefined" see #gh-57
        var hasInit = arguments.length > 2,
            result = initVal;

        if (arr == null || !arr.length) {
            if (!hasInit) {
                throw new Error('reduce of empty array with no initial value');
            } else {
                return initVal;
            }
        }

        var i = -1, len = arr.length;
        while (++i < len) {
            if (!hasInit) {
                result = arr[i];
                hasInit = true;
            } else {
                result = fn(result, arr[i], i, arr);
            }
        }

        return result;
    }

    module.exports = reduce;


},{}],321:[function(require,module,exports){


    /**
     * Create slice of source array or array-like object
     */
    function slice(arr, start, end){
        var len = arr.length;

        if (start == null) {
            start = 0;
        } else if (start < 0) {
            start = Math.max(len + start, 0);
        } else {
            start = Math.min(start, len);
        }

        if (end == null) {
            end = len;
        } else if (end < 0) {
            end = Math.max(len + end, 0);
        } else {
            end = Math.min(end, len);
        }

        var result = [];
        while (start < end) {
            result.push(arr[start++]);
        }

        return result;
    }

    module.exports = slice;



},{}],322:[function(require,module,exports){
var make = require('./make_');
var arrForEach = require('../array/forEach');
var objForEach = require('../object/forOwn');

    /**
     */
    module.exports = make(arrForEach, objForEach);



},{"../array/forEach":318,"../object/forOwn":335,"./make_":323}],323:[function(require,module,exports){
var slice = require('../array/slice');

    /**
     * internal method used to create other collection modules.
     */
    function makeCollectionMethod(arrMethod, objMethod, defaultReturn) {
        return function(){
            var args = slice(arguments);
            if (args[0] == null) {
                return defaultReturn;
            }
            // array-like is treated as array
            return (typeof args[0].length === 'number')? arrMethod.apply(null, args) : objMethod.apply(null, args);
        };
    }

    module.exports = makeCollectionMethod;



},{"../array/slice":321}],324:[function(require,module,exports){
var isObject = require('../lang/isObject');
var values = require('../object/values');
var arrMap = require('../array/map');
var makeIterator = require('../function/makeIterator_');

    /**
     * Map collection values, returns Array.
     */
    function map(list, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        // list.length to check array-like object, if not array-like
        // we simply map all the object values
        if( isObject(list) && list.length == null ){
            list = values(list);
        }
        return arrMap(list, function (val, key, list) {
            return callback(val, key, list);
        });
    }

    module.exports = map;



},{"../array/map":319,"../function/makeIterator_":326,"../lang/isObject":331,"../object/values":338}],325:[function(require,module,exports){


    /**
     * Returns the first argument provided to it.
     */
    function identity(val){
        return val;
    }

    module.exports = identity;



},{}],326:[function(require,module,exports){
var identity = require('./identity');
var prop = require('./prop');
var deepMatches = require('../object/deepMatches');

    /**
     * Converts argument into a valid iterator.
     * Used internally on most array/object/collection methods that receives a
     * callback/iterator providing a shortcut syntax.
     */
    function makeIterator(src, thisObj){
        if (src == null) {
            return identity;
        }
        switch(typeof src) {
            case 'function':
                // function is the first to improve perf (most common case)
                // also avoid using `Function#call` if not needed, which boosts
                // perf a lot in some cases
                return (typeof thisObj !== 'undefined')? function(val, i, arr){
                    return src.call(thisObj, val, i, arr);
                } : src;
            case 'object':
                return function(val){
                    return deepMatches(val, src);
                };
            case 'string':
            case 'number':
                return prop(src);
        }
    }

    module.exports = makeIterator;



},{"../object/deepMatches":333,"./identity":325,"./prop":327}],327:[function(require,module,exports){


    /**
     * Returns a function that gets a property of the passed object
     */
    function prop(name){
        return function(obj){
            return obj[name];
        };
    }

    module.exports = prop;



},{}],328:[function(require,module,exports){
var mixIn = require('../object/mixIn');

    /**
     * Create Object using prototypal inheritance and setting custom properties.
     * - Mix between Douglas Crockford Prototypal Inheritance <http://javascript.crockford.com/prototypal.html> and the EcmaScript 5 `Object.create()` method.
     * @param {object} parent    Parent Object.
     * @param {object} [props] Object properties.
     * @return {object} Created object.
     */
    function createObject(parent, props){
        function F(){}
        F.prototype = parent;
        return mixIn(new F(), props);

    }
    module.exports = createObject;



},{"../object/mixIn":337}],329:[function(require,module,exports){
var isKind = require('./isKind');
    /**
     */
    var isArray = Array.isArray || function (val) {
        return isKind(val, 'Array');
    };
    module.exports = isArray;


},{"./isKind":330}],330:[function(require,module,exports){
var kindOf = require('./kindOf');
    /**
     * Check if value is from a specific "kind".
     */
    function isKind(val, kind){
        return kindOf(val) === kind;
    }
    module.exports = isKind;


},{"./kindOf":332}],331:[function(require,module,exports){
var isKind = require('./isKind');
    /**
     */
    function isObject(val) {
        return isKind(val, 'Object');
    }
    module.exports = isObject;


},{"./isKind":330}],332:[function(require,module,exports){


    var _rKind = /^\[object (.*)\]$/,
        _toString = Object.prototype.toString,
        UNDEF;

    /**
     * Gets the "kind" of value. (e.g. "String", "Number", etc)
     */
    function kindOf(val) {
        if (val === null) {
            return 'Null';
        } else if (val === UNDEF) {
            return 'Undefined';
        } else {
            return _rKind.exec( _toString.call(val) )[1];
        }
    }
    module.exports = kindOf;


},{}],333:[function(require,module,exports){
var forOwn = require('./forOwn');
var isArray = require('../lang/isArray');

    function containsMatch(array, pattern) {
        var i = -1, length = array.length;
        while (++i < length) {
            if (deepMatches(array[i], pattern)) {
                return true;
            }
        }

        return false;
    }

    function matchArray(target, pattern) {
        var i = -1, patternLength = pattern.length;
        while (++i < patternLength) {
            if (!containsMatch(target, pattern[i])) {
                return false;
            }
        }

        return true;
    }

    function matchObject(target, pattern) {
        var result = true;
        forOwn(pattern, function(val, key) {
            if (!deepMatches(target[key], val)) {
                // Return false to break out of forOwn early
                return (result = false);
            }
        });

        return result;
    }

    /**
     * Recursively check if the objects match.
     */
    function deepMatches(target, pattern){
        if (target && typeof target === 'object') {
            if (isArray(target) && isArray(pattern)) {
                return matchArray(target, pattern);
            } else {
                return matchObject(target, pattern);
            }
        } else {
            return target === pattern;
        }
    }

    module.exports = deepMatches;



},{"../lang/isArray":329,"./forOwn":335}],334:[function(require,module,exports){
var hasOwn = require('./hasOwn');

    var _hasDontEnumBug,
        _dontEnums;

    function checkDontEnum(){
        _dontEnums = [
                'toString',
                'toLocaleString',
                'valueOf',
                'hasOwnProperty',
                'isPrototypeOf',
                'propertyIsEnumerable',
                'constructor'
            ];

        _hasDontEnumBug = true;

        for (var key in {'toString': null}) {
            _hasDontEnumBug = false;
        }
    }

    /**
     * Similar to Array/forEach but works over object properties and fixes Don't
     * Enum bug on IE.
     * based on: http://whattheheadsaid.com/2010/10/a-safer-object-keys-compatibility-implementation
     */
    function forIn(obj, fn, thisObj){
        var key, i = 0;
        // no need to check if argument is a real object that way we can use
        // it for arrays, functions, date, etc.

        //post-pone check till needed
        if (_hasDontEnumBug == null) checkDontEnum();

        for (key in obj) {
            if (exec(fn, obj, key, thisObj) === false) {
                break;
            }
        }


        if (_hasDontEnumBug) {
            var ctor = obj.constructor,
                isProto = !!ctor && obj === ctor.prototype;

            while (key = _dontEnums[i++]) {
                // For constructor, if it is a prototype object the constructor
                // is always non-enumerable unless defined otherwise (and
                // enumerated above).  For non-prototype objects, it will have
                // to be defined on this object, since it cannot be defined on
                // any prototype objects.
                //
                // For other [[DontEnum]] properties, check if the value is
                // different than Object prototype value.
                if (
                    (key !== 'constructor' ||
                        (!isProto && hasOwn(obj, key))) &&
                    obj[key] !== Object.prototype[key]
                ) {
                    if (exec(fn, obj, key, thisObj) === false) {
                        break;
                    }
                }
            }
        }
    }

    function exec(fn, obj, key, thisObj){
        return fn.call(thisObj, obj[key], key, obj);
    }

    module.exports = forIn;



},{"./hasOwn":336}],335:[function(require,module,exports){
var hasOwn = require('./hasOwn');
var forIn = require('./forIn');

    /**
     * Similar to Array/forEach but works over object properties and fixes Don't
     * Enum bug on IE.
     * based on: http://whattheheadsaid.com/2010/10/a-safer-object-keys-compatibility-implementation
     */
    function forOwn(obj, fn, thisObj){
        forIn(obj, function(val, key){
            if (hasOwn(obj, key)) {
                return fn.call(thisObj, obj[key], key, obj);
            }
        });
    }

    module.exports = forOwn;



},{"./forIn":334,"./hasOwn":336}],336:[function(require,module,exports){


    /**
     * Safer Object.hasOwnProperty
     */
     function hasOwn(obj, prop){
         return Object.prototype.hasOwnProperty.call(obj, prop);
     }

     module.exports = hasOwn;



},{}],337:[function(require,module,exports){
var forOwn = require('./forOwn');

    /**
    * Combine properties from all the objects into first one.
    * - This method affects target object in place, if you want to create a new Object pass an empty object as first param.
    * @param {object} target    Target Object
    * @param {...object} objects    Objects to be combined (0...n objects).
    * @return {object} Target Object.
    */
    function mixIn(target, objects){
        var i = 0,
            n = arguments.length,
            obj;
        while(++i < n){
            obj = arguments[i];
            if (obj != null) {
                forOwn(obj, copyProp, target);
            }
        }
        return target;
    }

    function copyProp(val, key){
        this[key] = val;
    }

    module.exports = mixIn;


},{"./forOwn":335}],338:[function(require,module,exports){
var forOwn = require('./forOwn');

    /**
     * Get object values
     */
    function values(obj) {
        var vals = [];
        forOwn(obj, function(val, key){
            vals.push(val);
        });
        return vals;
    }

    module.exports = values;



},{"./forOwn":335}],339:[function(require,module,exports){
/*
prime
 - prototypal inheritance
*/"use strict"

var hasOwn = require("mout/object/hasOwn"),
    mixIn  = require("mout/object/mixIn"),
    create = require("mout/lang/createObject"),
    kindOf = require("mout/lang/kindOf")

var hasDescriptors = true

try {
    Object.defineProperty({}, "~", {})
    Object.getOwnPropertyDescriptor({}, "~")
} catch (e){
    hasDescriptors = false
}

// we only need to be able to implement "toString" and "valueOf" in IE < 9
var hasEnumBug = !({valueOf: 0}).propertyIsEnumerable("valueOf"),
    buggy      = ["toString", "valueOf"]

var verbs = /^constructor|inherits|mixin$/

var implement = function(proto){
    var prototype = this.prototype

    for (var key in proto){
        if (key.match(verbs)) continue
        if (hasDescriptors){
            var descriptor = Object.getOwnPropertyDescriptor(proto, key)
            if (descriptor){
                Object.defineProperty(prototype, key, descriptor)
                continue
            }
        }
        prototype[key] = proto[key]
    }

    if (hasEnumBug) for (var i = 0; (key = buggy[i]); i++){
        var value = proto[key]
        if (value !== Object.prototype[key]) prototype[key] = value
    }

    return this
}

var prime = function(proto){

    if (kindOf(proto) === "Function") proto = {constructor: proto}

    var superprime = proto.inherits

    // if our nice proto object has no own constructor property
    // then we proceed using a ghosting constructor that all it does is
    // call the parent's constructor if it has a superprime, else an empty constructor
    // proto.constructor becomes the effective constructor
    var constructor = (hasOwn(proto, "constructor")) ? proto.constructor : (superprime) ? function(){
        return superprime.apply(this, arguments)
    } : function(){}

    if (superprime){

        mixIn(constructor, superprime)

        var superproto = superprime.prototype
        // inherit from superprime
        var cproto = constructor.prototype = create(superproto)

        // setting constructor.parent to superprime.prototype
        // because it's the shortest possible absolute reference
        constructor.parent = superproto
        cproto.constructor = constructor
    }

    if (!constructor.implement) constructor.implement = implement

    var mixins = proto.mixin
    if (mixins){
        if (kindOf(mixins) !== "Array") mixins = [mixins]
        for (var i = 0; i < mixins.length; i++) constructor.implement(create(mixins[i].prototype))
    }

    // implement proto and return constructor
    return constructor.implement(proto)

}

module.exports = prime

},{"mout/lang/createObject":328,"mout/lang/kindOf":332,"mout/object/hasOwn":336,"mout/object/mixIn":337}],340:[function(require,module,exports){
"use strict";
/*globals Handlebars: true */
var base = require("./handlebars/base");

// Each of these augment the Handlebars object. No need to setup here.
// (This is done to easily share code between commonjs and browse envs)
var SafeString = require("./handlebars/safe-string")["default"];
var Exception = require("./handlebars/exception")["default"];
var Utils = require("./handlebars/utils");
var runtime = require("./handlebars/runtime");

// For compatibility and usage outside of module systems, make the Handlebars object a namespace
var create = function() {
  var hb = new base.HandlebarsEnvironment();

  Utils.extend(hb, base);
  hb.SafeString = SafeString;
  hb.Exception = Exception;
  hb.Utils = Utils;

  hb.VM = runtime;
  hb.template = function(spec) {
    return runtime.template(spec, hb);
  };

  return hb;
};

var Handlebars = create();
Handlebars.create = create;

exports["default"] = Handlebars;
},{"./handlebars/base":341,"./handlebars/exception":342,"./handlebars/runtime":343,"./handlebars/safe-string":344,"./handlebars/utils":345}],341:[function(require,module,exports){
"use strict";
var Utils = require("./utils");
var Exception = require("./exception")["default"];

var VERSION = "1.3.0";
exports.VERSION = VERSION;var COMPILER_REVISION = 4;
exports.COMPILER_REVISION = COMPILER_REVISION;
var REVISION_CHANGES = {
  1: '<= 1.0.rc.2', // 1.0.rc.2 is actually rev2 but doesn't report it
  2: '== 1.0.0-rc.3',
  3: '== 1.0.0-rc.4',
  4: '>= 1.0.0'
};
exports.REVISION_CHANGES = REVISION_CHANGES;
var isArray = Utils.isArray,
    isFunction = Utils.isFunction,
    toString = Utils.toString,
    objectType = '[object Object]';

function HandlebarsEnvironment(helpers, partials) {
  this.helpers = helpers || {};
  this.partials = partials || {};

  registerDefaultHelpers(this);
}

exports.HandlebarsEnvironment = HandlebarsEnvironment;HandlebarsEnvironment.prototype = {
  constructor: HandlebarsEnvironment,

  logger: logger,
  log: log,

  registerHelper: function(name, fn, inverse) {
    if (toString.call(name) === objectType) {
      if (inverse || fn) { throw new Exception('Arg not supported with multiple helpers'); }
      Utils.extend(this.helpers, name);
    } else {
      if (inverse) { fn.not = inverse; }
      this.helpers[name] = fn;
    }
  },

  registerPartial: function(name, str) {
    if (toString.call(name) === objectType) {
      Utils.extend(this.partials,  name);
    } else {
      this.partials[name] = str;
    }
  }
};

function registerDefaultHelpers(instance) {
  instance.registerHelper('helperMissing', function(arg) {
    if(arguments.length === 2) {
      return undefined;
    } else {
      throw new Exception("Missing helper: '" + arg + "'");
    }
  });

  instance.registerHelper('blockHelperMissing', function(context, options) {
    var inverse = options.inverse || function() {}, fn = options.fn;

    if (isFunction(context)) { context = context.call(this); }

    if(context === true) {
      return fn(this);
    } else if(context === false || context == null) {
      return inverse(this);
    } else if (isArray(context)) {
      if(context.length > 0) {
        return instance.helpers.each(context, options);
      } else {
        return inverse(this);
      }
    } else {
      return fn(context);
    }
  });

  instance.registerHelper('each', function(context, options) {
    var fn = options.fn, inverse = options.inverse;
    var i = 0, ret = "", data;

    if (isFunction(context)) { context = context.call(this); }

    if (options.data) {
      data = createFrame(options.data);
    }

    if(context && typeof context === 'object') {
      if (isArray(context)) {
        for(var j = context.length; i<j; i++) {
          if (data) {
            data.index = i;
            data.first = (i === 0);
            data.last  = (i === (context.length-1));
          }
          ret = ret + fn(context[i], { data: data });
        }
      } else {
        for(var key in context) {
          if(context.hasOwnProperty(key)) {
            if(data) { 
              data.key = key; 
              data.index = i;
              data.first = (i === 0);
            }
            ret = ret + fn(context[key], {data: data});
            i++;
          }
        }
      }
    }

    if(i === 0){
      ret = inverse(this);
    }

    return ret;
  });

  instance.registerHelper('if', function(conditional, options) {
    if (isFunction(conditional)) { conditional = conditional.call(this); }

    // Default behavior is to render the positive path if the value is truthy and not empty.
    // The `includeZero` option may be set to treat the condtional as purely not empty based on the
    // behavior of isEmpty. Effectively this determines if 0 is handled by the positive path or negative.
    if ((!options.hash.includeZero && !conditional) || Utils.isEmpty(conditional)) {
      return options.inverse(this);
    } else {
      return options.fn(this);
    }
  });

  instance.registerHelper('unless', function(conditional, options) {
    return instance.helpers['if'].call(this, conditional, {fn: options.inverse, inverse: options.fn, hash: options.hash});
  });

  instance.registerHelper('with', function(context, options) {
    if (isFunction(context)) { context = context.call(this); }

    if (!Utils.isEmpty(context)) return options.fn(context);
  });

  instance.registerHelper('log', function(context, options) {
    var level = options.data && options.data.level != null ? parseInt(options.data.level, 10) : 1;
    instance.log(level, context);
  });
}

var logger = {
  methodMap: { 0: 'debug', 1: 'info', 2: 'warn', 3: 'error' },

  // State enum
  DEBUG: 0,
  INFO: 1,
  WARN: 2,
  ERROR: 3,
  level: 3,

  // can be overridden in the host environment
  log: function(level, obj) {
    if (logger.level <= level) {
      var method = logger.methodMap[level];
      if (typeof console !== 'undefined' && console[method]) {
        console[method].call(console, obj);
      }
    }
  }
};
exports.logger = logger;
function log(level, obj) { logger.log(level, obj); }

exports.log = log;var createFrame = function(object) {
  var obj = {};
  Utils.extend(obj, object);
  return obj;
};
exports.createFrame = createFrame;
},{"./exception":342,"./utils":345}],342:[function(require,module,exports){
"use strict";

var errorProps = ['description', 'fileName', 'lineNumber', 'message', 'name', 'number', 'stack'];

function Exception(message, node) {
  var line;
  if (node && node.firstLine) {
    line = node.firstLine;

    message += ' - ' + line + ':' + node.firstColumn;
  }

  var tmp = Error.prototype.constructor.call(this, message);

  // Unfortunately errors are not enumerable in Chrome (at least), so `for prop in tmp` doesn't work.
  for (var idx = 0; idx < errorProps.length; idx++) {
    this[errorProps[idx]] = tmp[errorProps[idx]];
  }

  if (line) {
    this.lineNumber = line;
    this.column = node.firstColumn;
  }
}

Exception.prototype = new Error();

exports["default"] = Exception;
},{}],343:[function(require,module,exports){
"use strict";
var Utils = require("./utils");
var Exception = require("./exception")["default"];
var COMPILER_REVISION = require("./base").COMPILER_REVISION;
var REVISION_CHANGES = require("./base").REVISION_CHANGES;

function checkRevision(compilerInfo) {
  var compilerRevision = compilerInfo && compilerInfo[0] || 1,
      currentRevision = COMPILER_REVISION;

  if (compilerRevision !== currentRevision) {
    if (compilerRevision < currentRevision) {
      var runtimeVersions = REVISION_CHANGES[currentRevision],
          compilerVersions = REVISION_CHANGES[compilerRevision];
      throw new Exception("Template was precompiled with an older version of Handlebars than the current runtime. "+
            "Please update your precompiler to a newer version ("+runtimeVersions+") or downgrade your runtime to an older version ("+compilerVersions+").");
    } else {
      // Use the embedded version info since the runtime doesn't know about this revision yet
      throw new Exception("Template was precompiled with a newer version of Handlebars than the current runtime. "+
            "Please update your runtime to a newer version ("+compilerInfo[1]+").");
    }
  }
}

exports.checkRevision = checkRevision;// TODO: Remove this line and break up compilePartial

function template(templateSpec, env) {
  if (!env) {
    throw new Exception("No environment passed to template");
  }

  // Note: Using env.VM references rather than local var references throughout this section to allow
  // for external users to override these as psuedo-supported APIs.
  var invokePartialWrapper = function(partial, name, context, helpers, partials, data) {
    var result = env.VM.invokePartial.apply(this, arguments);
    if (result != null) { return result; }

    if (env.compile) {
      var options = { helpers: helpers, partials: partials, data: data };
      partials[name] = env.compile(partial, { data: data !== undefined }, env);
      return partials[name](context, options);
    } else {
      throw new Exception("The partial " + name + " could not be compiled when running in runtime-only mode");
    }
  };

  // Just add water
  var container = {
    escapeExpression: Utils.escapeExpression,
    invokePartial: invokePartialWrapper,
    programs: [],
    program: function(i, fn, data) {
      var programWrapper = this.programs[i];
      if(data) {
        programWrapper = program(i, fn, data);
      } else if (!programWrapper) {
        programWrapper = this.programs[i] = program(i, fn);
      }
      return programWrapper;
    },
    merge: function(param, common) {
      var ret = param || common;

      if (param && common && (param !== common)) {
        ret = {};
        Utils.extend(ret, common);
        Utils.extend(ret, param);
      }
      return ret;
    },
    programWithDepth: env.VM.programWithDepth,
    noop: env.VM.noop,
    compilerInfo: null
  };

  return function(context, options) {
    options = options || {};
    var namespace = options.partial ? options : env,
        helpers,
        partials;

    if (!options.partial) {
      helpers = options.helpers;
      partials = options.partials;
    }
    var result = templateSpec.call(
          container,
          namespace, context,
          helpers,
          partials,
          options.data);

    if (!options.partial) {
      env.VM.checkRevision(container.compilerInfo);
    }

    return result;
  };
}

exports.template = template;function programWithDepth(i, fn, data /*, $depth */) {
  var args = Array.prototype.slice.call(arguments, 3);

  var prog = function(context, options) {
    options = options || {};

    return fn.apply(this, [context, options.data || data].concat(args));
  };
  prog.program = i;
  prog.depth = args.length;
  return prog;
}

exports.programWithDepth = programWithDepth;function program(i, fn, data) {
  var prog = function(context, options) {
    options = options || {};

    return fn(context, options.data || data);
  };
  prog.program = i;
  prog.depth = 0;
  return prog;
}

exports.program = program;function invokePartial(partial, name, context, helpers, partials, data) {
  var options = { partial: true, helpers: helpers, partials: partials, data: data };

  if(partial === undefined) {
    throw new Exception("The partial " + name + " could not be found");
  } else if(partial instanceof Function) {
    return partial(context, options);
  }
}

exports.invokePartial = invokePartial;function noop() { return ""; }

exports.noop = noop;
},{"./base":341,"./exception":342,"./utils":345}],344:[function(require,module,exports){
"use strict";
// Build out our basic SafeString type
function SafeString(string) {
  this.string = string;
}

SafeString.prototype.toString = function() {
  return "" + this.string;
};

exports["default"] = SafeString;
},{}],345:[function(require,module,exports){
"use strict";
/*jshint -W004 */
var SafeString = require("./safe-string")["default"];

var escape = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#x27;",
  "`": "&#x60;"
};

var badChars = /[&<>"'`]/g;
var possible = /[&<>"'`]/;

function escapeChar(chr) {
  return escape[chr] || "&amp;";
}

function extend(obj, value) {
  for(var key in value) {
    if(Object.prototype.hasOwnProperty.call(value, key)) {
      obj[key] = value[key];
    }
  }
}

exports.extend = extend;var toString = Object.prototype.toString;
exports.toString = toString;
// Sourced from lodash
// https://github.com/bestiejs/lodash/blob/master/LICENSE.txt
var isFunction = function(value) {
  return typeof value === 'function';
};
// fallback for older versions of Chrome and Safari
if (isFunction(/x/)) {
  isFunction = function(value) {
    return typeof value === 'function' && toString.call(value) === '[object Function]';
  };
}
var isFunction;
exports.isFunction = isFunction;
var isArray = Array.isArray || function(value) {
  return (value && typeof value === 'object') ? toString.call(value) === '[object Array]' : false;
};
exports.isArray = isArray;

function escapeExpression(string) {
  // don't escape SafeStrings, since they're already safe
  if (string instanceof SafeString) {
    return string.toString();
  } else if (!string && string !== 0) {
    return "";
  }

  // Force a string conversion as this will be done by the append regardless and
  // the regex test will do this transparently behind the scenes, causing issues if
  // an object's to string has escaped characters in it.
  string = "" + string;

  if(!possible.test(string)) { return string; }
  return string.replace(badChars, escapeChar);
}

exports.escapeExpression = escapeExpression;function isEmpty(value) {
  if (!value && value !== 0) {
    return true;
  } else if (isArray(value) && value.length === 0) {
    return true;
  } else {
    return false;
  }
}

exports.isEmpty = isEmpty;
},{"./safe-string":344}],346:[function(require,module,exports){
// Create a simple path alias to allow browserify to resolve
// the runtime on a supported path.
module.exports = require('./dist/cjs/handlebars.runtime');

},{"./dist/cjs/handlebars.runtime":340}],347:[function(require,module,exports){
module.exports = require("handlebars/runtime")["default"];

},{"handlebars/runtime":346}],348:[function(require,module,exports){
var indexOf = require('./indexOf');

    /**
     * Combines an array with all the items of another.
     * Does not allow duplicates and is case and type sensitive.
     */
    function combine(arr1, arr2) {
        if (arr2 == null) {
            return arr1;
        }

        var i = -1, len = arr2.length;
        while (++i < len) {
            if (indexOf(arr1, arr2[i]) === -1) {
                arr1.push(arr2[i]);
            }
        }

        return arr1;
    }
    module.exports = combine;


},{"./indexOf":357}],349:[function(require,module,exports){
var indexOf = require('./indexOf');

    /**
     * If array contains values.
     */
    function contains(arr, val) {
        return indexOf(arr, val) !== -1;
    }
    module.exports = contains;


},{"./indexOf":357}],350:[function(require,module,exports){
var unique = require('./unique');
var filter = require('./filter');
var some = require('./some');
var contains = require('./contains');
var slice = require('./slice');


    /**
     * Return a new Array with elements that aren't present in the other Arrays.
     */
    function difference(arr) {
        var arrs = slice(arguments, 1),
            result = filter(unique(arr), function(needle){
                return !some(arrs, function(haystack){
                    return contains(haystack, needle);
                });
            });
        return result;
    }

    module.exports = difference;



},{"./contains":349,"./filter":353,"./slice":363,"./some":364,"./unique":365}],351:[function(require,module,exports){
var is = require('../lang/is');
var isArray = require('../lang/isArray');
var every = require('./every');

    /**
     * Compares if both arrays have the same elements
     */
    function equals(a, b, callback){
        callback = callback || is;

        if (!isArray(a) || !isArray(b)) {
            return callback(a, b);
        }

        if (a.length !== b.length) {
            return false;
        }

        return every(a, makeCompare(callback), b);
    }

    function makeCompare(callback) {
        return function(value, i) {
            return i in this && callback(value, this[i]);
        };
    }

    module.exports = equals;



},{"../lang/is":374,"../lang/isArray":375,"./every":352}],352:[function(require,module,exports){
var makeIterator = require('../function/makeIterator_');

    /**
     * Array every
     */
    function every(arr, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        var result = true;
        if (arr == null) {
            return result;
        }

        var i = -1, len = arr.length;
        while (++i < len) {
            // we iterate over sparse items since there is no way to make it
            // work properly on IE 7-8. see #64
            if (!callback(arr[i], i, arr) ) {
                result = false;
                break;
            }
        }

        return result;
    }

    module.exports = every;


},{"../function/makeIterator_":368}],353:[function(require,module,exports){
var makeIterator = require('../function/makeIterator_');

    /**
     * Array filter
     */
    function filter(arr, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        var results = [];
        if (arr == null) {
            return results;
        }

        var i = -1, len = arr.length, value;
        while (++i < len) {
            value = arr[i];
            if (callback(value, i, arr)) {
                results.push(value);
            }
        }

        return results;
    }

    module.exports = filter;



},{"../function/makeIterator_":368}],354:[function(require,module,exports){
var findIndex = require('./findIndex');

    /**
     * Returns first item that matches criteria
     */
    function find(arr, iterator, thisObj){
        var idx = findIndex(arr, iterator, thisObj);
        return idx >= 0? arr[idx] : void(0);
    }

    module.exports = find;



},{"./findIndex":355}],355:[function(require,module,exports){
var makeIterator = require('../function/makeIterator_');

    /**
     * Returns the index of the first item that matches criteria
     */
    function findIndex(arr, iterator, thisObj){
        iterator = makeIterator(iterator, thisObj);
        if (arr == null) {
            return -1;
        }

        var i = -1, len = arr.length;
        while (++i < len) {
            if (iterator(arr[i], i, arr)) {
                return i;
            }
        }

        return -1;
    }

    module.exports = findIndex;


},{"../function/makeIterator_":368}],356:[function(require,module,exports){
arguments[4][318][0].apply(exports,arguments)
},{"dup":318}],357:[function(require,module,exports){


    /**
     * Array.indexOf
     */
    function indexOf(arr, item, fromIndex) {
        fromIndex = fromIndex || 0;
        if (arr == null) {
            return -1;
        }

        var len = arr.length,
            i = fromIndex < 0 ? len + fromIndex : fromIndex;
        while (i < len) {
            // we iterate over sparse items since there is no way to make it
            // work properly on IE 7-8. see #64
            if (arr[i] === item) {
                return i;
            }

            i++;
        }

        return -1;
    }

    module.exports = indexOf;


},{}],358:[function(require,module,exports){
var unique = require('./unique');
var filter = require('./filter');
var every = require('./every');
var contains = require('./contains');
var slice = require('./slice');


    /**
     * Return a new Array with elements common to all Arrays.
     * - based on underscore.js implementation
     */
    function intersection(arr) {
        var arrs = slice(arguments, 1),
            result = filter(unique(arr), function(needle){
                return every(arrs, function(haystack){
                    return contains(haystack, needle);
                });
            });
        return result;
    }

    module.exports = intersection;



},{"./contains":349,"./every":352,"./filter":353,"./slice":363,"./unique":365}],359:[function(require,module,exports){
arguments[4][319][0].apply(exports,arguments)
},{"../function/makeIterator_":368,"dup":319}],360:[function(require,module,exports){
var makeIterator = require('../function/makeIterator_');

    /**
     * Return maximum value inside array
     */
    function max(arr, iterator, thisObj){
        if (arr == null || !arr.length) {
            return Infinity;
        } else if (arr.length && !iterator) {
            return Math.max.apply(Math, arr);
        } else {
            iterator = makeIterator(iterator, thisObj);
            var result,
                compare = -Infinity,
                value,
                temp;

            var i = -1, len = arr.length;
            while (++i < len) {
                value = arr[i];
                temp = iterator(value, i, arr);
                if (temp > compare) {
                    compare = temp;
                    result = value;
                }
            }

            return result;
        }
    }

    module.exports = max;



},{"../function/makeIterator_":368}],361:[function(require,module,exports){
var makeIterator = require('../function/makeIterator_');

    /**
     * Return minimum value inside array
     */
    function min(arr, iterator, thisObj){
        if (arr == null || !arr.length) {
            return -Infinity;
        } else if (arr.length && !iterator) {
            return Math.min.apply(Math, arr);
        } else {
            iterator = makeIterator(iterator, thisObj);
            var result,
                compare = Infinity,
                value,
                temp;

            var i = -1, len = arr.length;
            while (++i < len) {
                value = arr[i];
                temp = iterator(value, i, arr);
                if (temp < compare) {
                    compare = temp;
                    result = value;
                }
            }

            return result;
        }
    }

    module.exports = min;



},{"../function/makeIterator_":368}],362:[function(require,module,exports){
var indexOf = require('./indexOf');

    /**
     * Remove a single item from the array.
     * (it won't remove duplicates, just a single item)
     */
    function remove(arr, item){
        var idx = indexOf(arr, item);
        if (idx !== -1) arr.splice(idx, 1);
    }

    module.exports = remove;


},{"./indexOf":357}],363:[function(require,module,exports){
arguments[4][321][0].apply(exports,arguments)
},{"dup":321}],364:[function(require,module,exports){
var makeIterator = require('../function/makeIterator_');

    /**
     * Array some
     */
    function some(arr, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        var result = false;
        if (arr == null) {
            return result;
        }

        var i = -1, len = arr.length;
        while (++i < len) {
            // we iterate over sparse items since there is no way to make it
            // work properly on IE 7-8. see #64
            if ( callback(arr[i], i, arr) ) {
                result = true;
                break;
            }
        }

        return result;
    }

    module.exports = some;


},{"../function/makeIterator_":368}],365:[function(require,module,exports){
var filter = require('./filter');

    /**
     * @return {array} Array of unique items
     */
    function unique(arr, compare){
        compare = compare || isEqual;
        return filter(arr, function(item, i, arr){
            var n = arr.length;
            while (++i < n) {
                if ( compare(item, arr[i]) ) {
                    return false;
                }
            }
            return true;
        });
    }

    function isEqual(a, b){
        return a === b;
    }

    module.exports = unique;



},{"./filter":353}],366:[function(require,module,exports){


    /**
     * Debounce callback execution
     */
    function debounce(fn, threshold, isAsap){
        var timeout, result;
        function debounced(){
            var args = arguments, context = this;
            function delayed(){
                if (! isAsap) {
                    result = fn.apply(context, args);
                }
                timeout = null;
            }
            if (timeout) {
                clearTimeout(timeout);
            } else if (isAsap) {
                result = fn.apply(context, args);
            }
            timeout = setTimeout(delayed, threshold);
            return result;
        }
        debounced.cancel = function(){
            clearTimeout(timeout);
        };
        return debounced;
    }

    module.exports = debounce;



},{}],367:[function(require,module,exports){
arguments[4][325][0].apply(exports,arguments)
},{"dup":325}],368:[function(require,module,exports){
arguments[4][326][0].apply(exports,arguments)
},{"../object/deepMatches":384,"./identity":367,"./prop":369,"dup":326}],369:[function(require,module,exports){
arguments[4][327][0].apply(exports,arguments)
},{"dup":327}],370:[function(require,module,exports){
var kindOf = require('./kindOf');
var isPlainObject = require('./isPlainObject');
var mixIn = require('../object/mixIn');

    /**
     * Clone native types.
     */
    function clone(val){
        switch (kindOf(val)) {
            case 'Object':
                return cloneObject(val);
            case 'Array':
                return cloneArray(val);
            case 'RegExp':
                return cloneRegExp(val);
            case 'Date':
                return cloneDate(val);
            default:
                return val;
        }
    }

    function cloneObject(source) {
        if (isPlainObject(source)) {
            return mixIn({}, source);
        } else {
            return source;
        }
    }

    function cloneRegExp(r) {
        var flags = '';
        flags += r.multiline ? 'm' : '';
        flags += r.global ? 'g' : '';
        flags += r.ignoreCase ? 'i' : '';
        return new RegExp(r.source, flags);
    }

    function cloneDate(date) {
        return new Date(+date);
    }

    function cloneArray(arr) {
        return arr.slice();
    }

    module.exports = clone;



},{"../object/mixIn":393,"./isPlainObject":379,"./kindOf":381}],371:[function(require,module,exports){
arguments[4][328][0].apply(exports,arguments)
},{"../object/mixIn":393,"dup":328}],372:[function(require,module,exports){
var clone = require('./clone');
var forOwn = require('../object/forOwn');
var kindOf = require('./kindOf');
var isPlainObject = require('./isPlainObject');

    /**
     * Recursively clone native types.
     */
    function deepClone(val, instanceClone) {
        switch ( kindOf(val) ) {
            case 'Object':
                return cloneObject(val, instanceClone);
            case 'Array':
                return cloneArray(val, instanceClone);
            default:
                return clone(val);
        }
    }

    function cloneObject(source, instanceClone) {
        if (isPlainObject(source)) {
            var out = {};
            forOwn(source, function(val, key) {
                this[key] = deepClone(val, instanceClone);
            }, out);
            return out;
        } else if (instanceClone) {
            return instanceClone(source);
        } else {
            return source;
        }
    }

    function cloneArray(arr, instanceClone) {
        var out = [],
            i = -1,
            n = arr.length,
            val;
        while (++i < n) {
            out[i] = deepClone(arr[i], instanceClone);
        }
        return out;
    }

    module.exports = deepClone;




},{"../object/forOwn":389,"./clone":370,"./isPlainObject":379,"./kindOf":381}],373:[function(require,module,exports){
var is = require('./is');
var isObject = require('./isObject');
var isArray = require('./isArray');
var objEquals = require('../object/equals');
var arrEquals = require('../array/equals');

    /**
     * Recursively checks for same properties and values.
     */
    function deepEquals(a, b, callback){
        callback = callback || is;

        var bothObjects = isObject(a) && isObject(b);
        var bothArrays = !bothObjects && isArray(a) && isArray(b);

        if (!bothObjects && !bothArrays) {
            return callback(a, b);
        }

        function compare(a, b){
            return deepEquals(a, b, callback);
        }

        var method = bothObjects ? objEquals : arrEquals;
        return method(a, b, compare);
    }

    module.exports = deepEquals;



},{"../array/equals":351,"../object/equals":386,"./is":374,"./isArray":375,"./isObject":378}],374:[function(require,module,exports){


    /**
     * Check if both arguments are egal.
     */
    function is(x, y){
        // implementation borrowed from harmony:egal spec
        if (x === y) {
          // 0 === -0, but they are not identical
          return x !== 0 || 1 / x === 1 / y;
        }

        // NaN !== NaN, but they are identical.
        // NaNs are the only non-reflexive value, i.e., if x !== x,
        // then x is a NaN.
        // isNaN is broken: it converts its argument to number, so
        // isNaN("foo") => true
        return x !== x && y !== y;
    }

    module.exports = is;



},{}],375:[function(require,module,exports){
arguments[4][329][0].apply(exports,arguments)
},{"./isKind":376,"dup":329}],376:[function(require,module,exports){
arguments[4][330][0].apply(exports,arguments)
},{"./kindOf":381,"dup":330}],377:[function(require,module,exports){
var isKind = require('./isKind');
    /**
     */
    function isNumber(val) {
        return isKind(val, 'Number');
    }
    module.exports = isNumber;


},{"./isKind":376}],378:[function(require,module,exports){
arguments[4][331][0].apply(exports,arguments)
},{"./isKind":376,"dup":331}],379:[function(require,module,exports){


    /**
     * Checks if the value is created by the `Object` constructor.
     */
    function isPlainObject(value) {
        return (!!value && typeof value === 'object' &&
            value.constructor === Object);
    }

    module.exports = isPlainObject;



},{}],380:[function(require,module,exports){
var isKind = require('./isKind');
    /**
     */
    function isRegExp(val) {
        return isKind(val, 'RegExp');
    }
    module.exports = isRegExp;


},{"./isKind":376}],381:[function(require,module,exports){
arguments[4][332][0].apply(exports,arguments)
},{"dup":332}],382:[function(require,module,exports){


    /**
     * Typecast a value to a String, using an empty string value for null or
     * undefined.
     */
    function toString(val){
        return val == null ? '' : val.toString();
    }

    module.exports = toString;



},{}],383:[function(require,module,exports){
var forOwn = require('./forOwn');
var isPlainObject = require('../lang/isPlainObject');

    /**
     * Deeply copy missing properties in the target from the defaults.
     */
    function deepFillIn(target, defaults){
        var i = 0,
            n = arguments.length,
            obj;

        while(++i < n) {
            obj = arguments[i];
            if (obj) {
                // jshint loopfunc: true
                forOwn(obj, function(newValue, key) {
                    var curValue = target[key];
                    if (curValue == null) {
                        target[key] = newValue;
                    } else if (isPlainObject(curValue) &&
                               isPlainObject(newValue)) {
                        deepFillIn(curValue, newValue);
                    }
                });
            }
        }

        return target;
    }

    module.exports = deepFillIn;



},{"../lang/isPlainObject":379,"./forOwn":389}],384:[function(require,module,exports){
arguments[4][333][0].apply(exports,arguments)
},{"../lang/isArray":375,"./forOwn":389,"dup":333}],385:[function(require,module,exports){
var forOwn = require('./forOwn');
var isPlainObject = require('../lang/isPlainObject');

    /**
     * Mixes objects into the target object, recursively mixing existing child
     * objects.
     */
    function deepMixIn(target, objects) {
        var i = 0,
            n = arguments.length,
            obj;

        while(++i < n){
            obj = arguments[i];
            if (obj) {
                forOwn(obj, copyProp, target);
            }
        }

        return target;
    }

    function copyProp(val, key) {
        var existing = this[key];
        if (isPlainObject(val) && isPlainObject(existing)) {
            deepMixIn(existing, val);
        } else {
            this[key] = val;
        }
    }

    module.exports = deepMixIn;



},{"../lang/isPlainObject":379,"./forOwn":389}],386:[function(require,module,exports){
var hasOwn = require('./hasOwn');
var every = require('./every');
var isObject = require('../lang/isObject');
var is = require('../lang/is');

    // Makes a function to compare the object values from the specified compare
    // operation callback.
    function makeCompare(callback) {
        return function(value, key) {
            return hasOwn(this, key) && callback(value, this[key]);
        };
    }

    function checkProperties(value, key) {
        return hasOwn(this, key);
    }

    /**
     * Checks if two objects have the same keys and values.
     */
    function equals(a, b, callback) {
        callback = callback || is;

        if (!isObject(a) || !isObject(b)) {
            return callback(a, b);
        }

        return (every(a, makeCompare(callback), b) &&
                every(b, checkProperties, a));
    }

    module.exports = equals;


},{"../lang/is":374,"../lang/isObject":378,"./every":387,"./hasOwn":390}],387:[function(require,module,exports){
var forOwn = require('./forOwn');
var makeIterator = require('../function/makeIterator_');

    /**
     * Object every
     */
    function every(obj, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        var result = true;
        forOwn(obj, function(val, key) {
            // we consider any falsy values as "false" on purpose so shorthand
            // syntax can be used to check property existence
            if (!callback(val, key, obj)) {
                result = false;
                return false; // break
            }
        });
        return result;
    }

    module.exports = every;



},{"../function/makeIterator_":368,"./forOwn":389}],388:[function(require,module,exports){
arguments[4][334][0].apply(exports,arguments)
},{"./hasOwn":390,"dup":334}],389:[function(require,module,exports){
arguments[4][335][0].apply(exports,arguments)
},{"./forIn":388,"./hasOwn":390,"dup":335}],390:[function(require,module,exports){
arguments[4][336][0].apply(exports,arguments)
},{"dup":336}],391:[function(require,module,exports){
var forOwn = require('./forOwn');

    /**
     * Get object keys
     */
     var keys = Object.keys || function (obj) {
            var keys = [];
            forOwn(obj, function(val, key){
                keys.push(key);
            });
            return keys;
        };

    module.exports = keys;



},{"./forOwn":389}],392:[function(require,module,exports){
var hasOwn = require('./hasOwn');
var deepClone = require('../lang/deepClone');
var isObject = require('../lang/isObject');

    /**
     * Deep merge objects.
     */
    function merge() {
        var i = 1,
            key, val, obj, target;

        // make sure we don't modify source element and it's properties
        // objects are passed by reference
        target = deepClone( arguments[0] );

        while (obj = arguments[i++]) {
            for (key in obj) {
                if ( ! hasOwn(obj, key) ) {
                    continue;
                }

                val = obj[key];

                if ( isObject(val) && isObject(target[key]) ){
                    // inception, deep merge objects
                    target[key] = merge(target[key], val);
                } else {
                    // make sure arrays, regexp, date, objects are cloned
                    target[key] = deepClone(val);
                }

            }
        }

        return target;
    }

    module.exports = merge;



},{"../lang/deepClone":372,"../lang/isObject":378,"./hasOwn":390}],393:[function(require,module,exports){
arguments[4][337][0].apply(exports,arguments)
},{"./forOwn":389,"dup":337}],394:[function(require,module,exports){
var slice = require('../array/slice');

    /**
     * Return a copy of the object, filtered to only have values for the whitelisted keys.
     */
    function pick(obj, var_keys){
        var keys = typeof arguments[1] !== 'string'? arguments[1] : slice(arguments, 1),
            out = {},
            i = 0, key;
        while (key = keys[i++]) {
            out[key] = obj[key];
        }
        return out;
    }

    module.exports = pick;



},{"../array/slice":363}],395:[function(require,module,exports){

    /**
     * Contains all Unicode white-spaces. Taken from
     * http://en.wikipedia.org/wiki/Whitespace_character.
     */
    module.exports = [
        ' ', '\n', '\r', '\t', '\f', '\v', '\u00A0', '\u1680', '\u180E',
        '\u2000', '\u2001', '\u2002', '\u2003', '\u2004', '\u2005', '\u2006',
        '\u2007', '\u2008', '\u2009', '\u200A', '\u2028', '\u2029', '\u202F',
        '\u205F', '\u3000'
    ];


},{}],396:[function(require,module,exports){
var toString = require('../lang/toString');

    /**
     * Escape RegExp string chars.
     */
    function escapeRegExp(str) {
        return toString(str).replace(/\W/g,'\\$&');
    }

    module.exports = escapeRegExp;



},{"../lang/toString":382}],397:[function(require,module,exports){
var toString = require('../lang/toString');
var WHITE_SPACES = require('./WHITE_SPACES');
    /**
     * Remove chars from beginning of string.
     */
    function ltrim(str, chars) {
        str = toString(str);
        chars = chars || WHITE_SPACES;

        var start = 0,
            len = str.length,
            charLen = chars.length,
            found = true,
            i, c;

        while (found && start < len) {
            found = false;
            i = -1;
            c = str.charAt(start);

            while (++i < charLen) {
                if (c === chars[i]) {
                    found = true;
                    start++;
                    break;
                }
            }
        }

        return (start >= len) ? '' : str.substr(start, len);
    }

    module.exports = ltrim;


},{"../lang/toString":382,"./WHITE_SPACES":395}],398:[function(require,module,exports){
var toString = require('../lang/toString');
var WHITE_SPACES = require('./WHITE_SPACES');
    /**
     * Remove chars from end of string.
     */
    function rtrim(str, chars) {
        str = toString(str);
        chars = chars || WHITE_SPACES;

        var end = str.length - 1,
            charLen = chars.length,
            found = true,
            i, c;

        while (found && end >= 0) {
            found = false;
            i = -1;
            c = str.charAt(end);

            while (++i < charLen) {
                if (c === chars[i]) {
                    found = true;
                    end--;
                    break;
                }
            }
        }

        return (end >= 0) ? str.substring(0, end + 1) : '';
    }

    module.exports = rtrim;


},{"../lang/toString":382,"./WHITE_SPACES":395}],399:[function(require,module,exports){
var toString = require('../lang/toString');
var WHITE_SPACES = require('./WHITE_SPACES');
var ltrim = require('./ltrim');
var rtrim = require('./rtrim');
    /**
     * Remove white-spaces from beginning and end of string.
     */
    function trim(str, chars) {
        str = toString(str);
        chars = chars || WHITE_SPACES;
        return ltrim(rtrim(str, chars), chars);
    }

    module.exports = trim;


},{"../lang/toString":382,"./WHITE_SPACES":395,"./ltrim":397,"./rtrim":398}],400:[function(require,module,exports){


    /**
     * Get current time in miliseconds
     */
    function now(){
        // yes, we defer the work to another function to allow mocking it
        // during the tests
        return now.get();
    }

    now.get = (typeof Date.now === 'function')? Date.now : function(){
        return +(new Date());
    };

    module.exports = now;



},{}],401:[function(require,module,exports){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} options
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options){
  options = options || {};
  if ('string' == typeof val) return parse(val);
  return options.long
    ? long(val)
    : short(val);
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = '' + str;
  if (str.length > 10000) return;
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
  if (!match) return;
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function short(ms) {
  if (ms >= d) return Math.round(ms / d) + 'd';
  if (ms >= h) return Math.round(ms / h) + 'h';
  if (ms >= m) return Math.round(ms / m) + 'm';
  if (ms >= s) return Math.round(ms / s) + 's';
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function long(ms) {
  return plural(ms, d, 'day')
    || plural(ms, h, 'hour')
    || plural(ms, m, 'minute')
    || plural(ms, s, 'second')
    || ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) return;
  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
  return Math.ceil(ms / n) + ' ' + name + 's';
}

},{}],402:[function(require,module,exports){
(function (process,global){
/*
defer
*/"use strict"

var kindOf  = require("mout/lang/kindOf"),
    now     = require("mout/time/now"),
    forEach = require("mout/array/forEach"),
    indexOf = require("mout/array/indexOf")

var callbacks = {
    timeout: {},
    frame: [],
    immediate: []
}

var push = function(collection, callback, context, defer){

    var iterator = function(){
        iterate(collection)
    }

    if (!collection.length) defer(iterator)

    var entry = {
        callback: callback,
        context: context
    }

    collection.push(entry)

    return function(){
        var io = indexOf(collection, entry)
        if (io > -1) collection.splice(io, 1)
    }
}

var iterate = function(collection){
    var time = now()

    forEach(collection.splice(0), function(entry) {
        entry.callback.call(entry.context, time)
    })
}

var defer = function(callback, argument, context){
    return (kindOf(argument) === "Number") ? defer.timeout(callback, argument, context) : defer.immediate(callback, argument)
}

if (global.process && process.nextTick){

    defer.immediate = function(callback, context){
        return push(callbacks.immediate, callback, context, process.nextTick)
    }

} else if (global.setImmediate){

    defer.immediate = function(callback, context){
        return push(callbacks.immediate, callback, context, setImmediate)
    }

} else if (global.postMessage && global.addEventListener){

    addEventListener("message", function(event){
        if (event.source === global && event.data === "@deferred"){
            event.stopPropagation()
            iterate(callbacks.immediate)
        }
    }, true)

    defer.immediate = function(callback, context){
        return push(callbacks.immediate, callback, context, function(){
            postMessage("@deferred", "*")
        })
    }

} else {

    defer.immediate = function(callback, context){
        return push(callbacks.immediate, callback, context, function(iterator){
            setTimeout(iterator, 0)
        })
    }

}

var requestAnimationFrame = global.requestAnimationFrame ||
    global.webkitRequestAnimationFrame ||
    global.mozRequestAnimationFrame ||
    global.oRequestAnimationFrame ||
    global.msRequestAnimationFrame ||
    function(callback) {
        setTimeout(callback, 1e3 / 60)
    }

defer.frame = function(callback, context){
    return push(callbacks.frame, callback, context, requestAnimationFrame)
}

var clear

defer.timeout = function(callback, ms, context){
    var ct = callbacks.timeout

    if (!clear) clear = defer.immediate(function(){
        clear = null
        callbacks.timeout = {}
    })

    return push(ct[ms] || (ct[ms] = []), callback, context, function(iterator){
        setTimeout(iterator, ms)
    })
}

module.exports = defer

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"_process":406,"mout/array/forEach":356,"mout/array/indexOf":357,"mout/lang/kindOf":381,"mout/time/now":400}],403:[function(require,module,exports){
/*
Emitter
*/"use strict"

var indexOf = require("mout/array/indexOf"),
    forEach = require("mout/array/forEach")

var prime = require("./index"),
    defer = require("./defer")

var slice = Array.prototype.slice;

var Emitter = prime({

    constructor: function(stoppable){
        this._stoppable = stoppable
    },

    on: function(event, fn){
        var listeners = this._listeners || (this._listeners = {}),
            events = listeners[event] || (listeners[event] = [])

        if (indexOf(events, fn) === -1) events.push(fn)

        return this
    },

    off: function(event, fn){
        var listeners = this._listeners, events
        if (listeners && (events = listeners[event])){

            var io = indexOf(events, fn)
            if (io > -1) events.splice(io, 1)
            if (!events.length) delete listeners[event];
            for (var l in listeners) return this
            delete this._listeners
        }
        return this
    },

    emit: function(event){
        var self = this,
            args = slice.call(arguments, 1)

        var emit = function(){
            var listeners = self._listeners, events
            if (listeners && (events = listeners[event])){
                forEach(events.slice(0), function(event){
                    var result = event.apply(self, args)
                    if (self._stoppable) return result
                })
            }
        }

        if (args[args.length - 1] === Emitter.EMIT_SYNC){
            args.pop()
            emit()
        } else {
            defer(emit)
        }

        return this
    }

})

Emitter.EMIT_SYNC = {}

module.exports = Emitter

},{"./defer":402,"./index":404,"mout/array/forEach":356,"mout/array/indexOf":357}],404:[function(require,module,exports){
arguments[4][339][0].apply(exports,arguments)
},{"dup":339,"mout/lang/createObject":371,"mout/lang/kindOf":381,"mout/object/hasOwn":390,"mout/object/mixIn":393}],405:[function(require,module,exports){
/*
Map
*/"use strict"

var indexOf = require("mout/array/indexOf")

var prime = require("./index")

var Map = prime({

    constructor: function Map(){
        this.length = 0
        this._values = []
        this._keys = []
    },

    set: function(key, value){
        var index = indexOf(this._keys, key)

        if (index === -1){
            this._keys.push(key)
            this._values.push(value)
            this.length++
        } else {
            this._values[index] = value
        }

        return this
    },

    get: function(key){
        var index = indexOf(this._keys, key)
        return (index === -1) ? null : this._values[index]
    },

    count: function(){
        return this.length
    },

    forEach: function(method, context){
        for (var i = 0, l = this.length; i < l; i++){
            if (method.call(context, this._values[i], this._keys[i], this) === false) break
        }
        return this
    },

    map: function(method, context){
        var results = new Map
        this.forEach(function(value, key){
            results.set(key, method.call(context, value, key, this))
        }, this)
        return results
    },

    filter: function(method, context){
        var results = new Map
        this.forEach(function(value, key){
            if (method.call(context, value, key, this)) results.set(key, value)
        }, this)
        return results
    },

    every: function(method, context){
        var every = true
        this.forEach(function(value, key){
            if (!method.call(context, value, key, this)) return (every = false)
        }, this)
        return every
    },

    some: function(method, context){
        var some = false
        this.forEach(function(value, key){
            if (method.call(context, value, key, this)) return !(some = true)
        }, this)
        return some
    },

    indexOf: function(value){
        var index = indexOf(this._values, value)
        return (index > -1) ? this._keys[index] : null
    },

    remove: function(value){
        var index = indexOf(this._values, value)

        if (index !== -1){
            this._values.splice(index, 1)
            this.length--
            return this._keys.splice(index, 1)[0]
        }

        return null
    },

    unset: function(key){
        var index = indexOf(this._keys, key)

        if (index !== -1){
            this._keys.splice(index, 1)
            this.length--
            return this._values.splice(index, 1)[0]
        }

        return null
    },

    keys: function(){
        return this._keys.slice()
    },

    values: function(){
        return this._values.slice()
    }

})

var map = function(){
    return new Map
}

map.prototype = Map.prototype

module.exports = map

},{"./index":404,"mout/array/indexOf":357}],406:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],407:[function(require,module,exports){
/*
Slick Finder
*/"use strict"

// Notable changes from Slick.Finder 1.0.x

// faster bottom -> up expression matching
// prefers mental sanity over *obsessive compulsive* milliseconds savings
// uses prototypes instead of objects
// tries to use matchesSelector smartly, whenever available
// can populate objects as well as arrays
// lots of stuff is broken or not implemented

var parse = require("./parser")

// utilities

var index = 0,
    counter = document.__counter = (parseInt(document.__counter || -1, 36) + 1).toString(36),
    key = "uid:" + counter

var uniqueID = function(n, xml){
    if (n === window) return "window"
    if (n === document) return "document"
    if (n === document.documentElement) return "html"

    if (xml) {
        var uid = n.getAttribute(key)
        if (!uid) {
            uid = (index++).toString(36)
            n.setAttribute(key, uid)
        }
        return uid
    } else {
        return n[key] || (n[key] = (index++).toString(36))
    }
}

var uniqueIDXML = function(n) {
    return uniqueID(n, true)
}

var isArray = Array.isArray || function(object){
    return Object.prototype.toString.call(object) === "[object Array]"
}

// tests

var uniqueIndex = 0;

var HAS = {

    GET_ELEMENT_BY_ID: function(test, id){
        id = "slick_" + (uniqueIndex++);
        // checks if the document has getElementById, and it works
        test.innerHTML = '<a id="' + id + '"></a>'
        return !!this.getElementById(id)
    },

    QUERY_SELECTOR: function(test){
        // this supposedly fixes a webkit bug with matchesSelector / querySelector & nth-child
        test.innerHTML = '_<style>:nth-child(2){}</style>'

        // checks if the document has querySelectorAll, and it works
        test.innerHTML = '<a class="MiX"></a>'

        return test.querySelectorAll('.MiX').length === 1
    },

    EXPANDOS: function(test, id){
        id = "slick_" + (uniqueIndex++);
        // checks if the document has elements that support expandos
        test._custom_property_ = id
        return test._custom_property_ === id
    },

    // TODO: use this ?

    // CHECKED_QUERY_SELECTOR: function(test){
    //
    //     // checks if the document supports the checked query selector
    //     test.innerHTML = '<select><option selected="selected">a</option></select>'
    //     return test.querySelectorAll(':checked').length === 1
    // },

    // TODO: use this ?

    // EMPTY_ATTRIBUTE_QUERY_SELECTOR: function(test){
    //
    //     // checks if the document supports the empty attribute query selector
    //     test.innerHTML = '<a class=""></a>'
    //     return test.querySelectorAll('[class*=""]').length === 1
    // },

    MATCHES_SELECTOR: function(test){

        test.className = "MiX"

        // checks if the document has matchesSelector, and we can use it.

        var matches = test.matchesSelector || test.mozMatchesSelector || test.webkitMatchesSelector

        // if matchesSelector trows errors on incorrect syntax we can use it
        if (matches) try {
            matches.call(test, ':slick')
        } catch(e){
            // just as a safety precaution, also test if it works on mixedcase (like querySelectorAll)
            return matches.call(test, ".MiX") ? matches : false
        }

        return false
    },

    GET_ELEMENTS_BY_CLASS_NAME: function(test){
        test.innerHTML = '<a class="f"></a><a class="b"></a>'
        if (test.getElementsByClassName('b').length !== 1) return false

        test.firstChild.className = 'b'
        if (test.getElementsByClassName('b').length !== 2) return false

        // Opera 9.6 getElementsByClassName doesnt detects the class if its not the first one
        test.innerHTML = '<a class="a"></a><a class="f b a"></a>'
        if (test.getElementsByClassName('a').length !== 2) return false

        // tests passed
        return true
    },

    // no need to know

    // GET_ELEMENT_BY_ID_NOT_NAME: function(test, id){
    //     test.innerHTML = '<a name="'+ id +'"></a><b id="'+ id +'"></b>'
    //     return this.getElementById(id) !== test.firstChild
    // },

    // this is always checked for and fixed

    // STAR_GET_ELEMENTS_BY_TAG_NAME: function(test){
    //
    //     // IE returns comment nodes for getElementsByTagName('*') for some documents
    //     test.appendChild(this.createComment(''))
    //     if (test.getElementsByTagName('*').length > 0) return false
    //
    //     // IE returns closed nodes (EG:"</foo>") for getElementsByTagName('*') for some documents
    //     test.innerHTML = 'foo</foo>'
    //     if (test.getElementsByTagName('*').length) return false
    //
    //     // tests passed
    //     return true
    // },

    // this is always checked for and fixed

    // STAR_QUERY_SELECTOR: function(test){
    //
    //     // returns closed nodes (EG:"</foo>") for querySelector('*') for some documents
    //     test.innerHTML = 'foo</foo>'
    //     return !!(test.querySelectorAll('*').length)
    // },

    GET_ATTRIBUTE: function(test){
        // tests for working getAttribute implementation
        var shout = "fus ro dah"
        test.innerHTML = '<a class="' + shout + '"></a>'
        return test.firstChild.getAttribute('class') === shout
    }

}

// Finder

var Finder = function Finder(document){

    this.document        = document
    var root = this.root = document.documentElement
    this.tested          = {}

    // uniqueID

    this.uniqueID = this.has("EXPANDOS") ? uniqueID : uniqueIDXML

    // getAttribute

    this.getAttribute = (this.has("GET_ATTRIBUTE")) ? function(node, name){

        return node.getAttribute(name)

    } : function(node, name){

        node = node.getAttributeNode(name)
        return (node && node.specified) ? node.value : null

    }

    // hasAttribute

    this.hasAttribute = (root.hasAttribute) ? function(node, attribute){

        return node.hasAttribute(attribute)

    } : function(node, attribute) {

        node = node.getAttributeNode(attribute)
        return !!(node && node.specified)

    }

    // contains

    this.contains = (document.contains && root.contains) ? function(context, node){

        return context.contains(node)

    } : (root.compareDocumentPosition) ? function(context, node){

        return context === node || !!(context.compareDocumentPosition(node) & 16)

    } : function(context, node){

        do {
            if (node === context) return true
        } while ((node = node.parentNode))

        return false
    }

    // sort
    // credits to Sizzle (http://sizzlejs.com/)

    this.sorter = (root.compareDocumentPosition) ? function(a, b){

        if (!a.compareDocumentPosition || !b.compareDocumentPosition) return 0
        return a.compareDocumentPosition(b) & 4 ? -1 : a === b ? 0 : 1

    } : ('sourceIndex' in root) ? function(a, b){

        if (!a.sourceIndex || !b.sourceIndex) return 0
        return a.sourceIndex - b.sourceIndex

    } : (document.createRange) ? function(a, b){

        if (!a.ownerDocument || !b.ownerDocument) return 0
        var aRange = a.ownerDocument.createRange(),
            bRange = b.ownerDocument.createRange()

        aRange.setStart(a, 0)
        aRange.setEnd(a, 0)
        bRange.setStart(b, 0)
        bRange.setEnd(b, 0)
        return aRange.compareBoundaryPoints(Range.START_TO_END, bRange)

    } : null

    this.failed = {}

    var nativeMatches = this.has("MATCHES_SELECTOR")

    if (nativeMatches) this.matchesSelector = function(node, expression){

        if (this.failed[expression]) return null

        try {
            return nativeMatches.call(node, expression)
        } catch(e){
            if (slick.debug) console.warn("matchesSelector failed on " + expression)
            this.failed[expression] = true
            return null
        }

    }

    if (this.has("QUERY_SELECTOR")){

        this.querySelectorAll = function(node, expression){

            if (this.failed[expression]) return true

            var result, _id, _expression, _combinator, _node


            // non-document rooted QSA
            // credits to Andrew Dupont

            if (node !== this.document){

                _combinator = expression[0].combinator

                _id         = node.getAttribute("id")
                _expression = expression

                if (!_id){
                    _node = node
                    _id = "__slick__"
                    _node.setAttribute("id", _id)
                }

                expression = "#" + _id + " " + _expression


                // these combinators need a parentNode due to how querySelectorAll works, which is:
                // finding all the elements that match the given selector
                // then filtering by the ones that have the specified element as an ancestor
                if (_combinator.indexOf("~") > -1 || _combinator.indexOf("+") > -1){

                    node = node.parentNode
                    if (!node) result = true
                    // if node has no parentNode, we return "true" as if it failed, without polluting the failed cache

                }

            }

            if (!result) try {
                result = node.querySelectorAll(expression.toString())
            } catch(e){
                if (slick.debug) console.warn("querySelectorAll failed on " + (_expression || expression))
                result = this.failed[_expression || expression] = true
            }

            if (_node) _node.removeAttribute("id")

            return result

        }

    }

}

Finder.prototype.has = function(FEATURE){

    var tested        = this.tested,
        testedFEATURE = tested[FEATURE]

    if (testedFEATURE != null) return testedFEATURE

    var root     = this.root,
        document = this.document,
        testNode = document.createElement("div")

    testNode.setAttribute("style", "display: none;")

    root.appendChild(testNode)

    var TEST = HAS[FEATURE], result = false

    if (TEST) try {
        result = TEST.call(document, testNode)
    } catch(e){}

    if (slick.debug && !result) console.warn("document has no " + FEATURE)

    root.removeChild(testNode)

    return tested[FEATURE] = result

}

var combinators = {

    " ": function(node, part, push){

        var item, items

        var noId = !part.id, noTag = !part.tag, noClass = !part.classes

        if (part.id && node.getElementById && this.has("GET_ELEMENT_BY_ID")){
            item = node.getElementById(part.id)

            // return only if id is found, else keep checking
            // might be a tad slower on non-existing ids, but less insane

            if (item && item.getAttribute('id') === part.id){
                items = [item]
                noId = true
                // if tag is star, no need to check it in match()
                if (part.tag === "*") noTag = true
            }
        }

        if (!items){

            if (part.classes && node.getElementsByClassName && this.has("GET_ELEMENTS_BY_CLASS_NAME")){
                items = node.getElementsByClassName(part.classList)
                noClass = true
                // if tag is star, no need to check it in match()
                if (part.tag === "*") noTag = true
            } else {
                items = node.getElementsByTagName(part.tag)
                // if tag is star, need to check it in match because it could select junk, boho
                if (part.tag !== "*") noTag = true
            }

            if (!items || !items.length) return false

        }

        for (var i = 0; item = items[i++];)
            if ((noTag && noId && noClass && !part.attributes && !part.pseudos) || this.match(item, part, noTag, noId, noClass))
                push(item)

        return true

    },

    ">": function(node, part, push){ // direct children
        if ((node = node.firstChild)) do {
            if (node.nodeType == 1 && this.match(node, part)) push(node)
        } while ((node = node.nextSibling))
    },

    "+": function(node, part, push){ // next sibling
        while ((node = node.nextSibling)) if (node.nodeType == 1){
            if (this.match(node, part)) push(node)
            break
        }
    },

    "^": function(node, part, push){ // first child
        node = node.firstChild
        if (node){
            if (node.nodeType === 1){
                if (this.match(node, part)) push(node)
            } else {
                combinators['+'].call(this, node, part, push)
            }
        }
    },

    "~": function(node, part, push){ // next siblings
        while ((node = node.nextSibling)){
            if (node.nodeType === 1 && this.match(node, part)) push(node)
        }
    },

    "++": function(node, part, push){ // next sibling and previous sibling
        combinators['+'].call(this, node, part, push)
        combinators['!+'].call(this, node, part, push)
    },

    "~~": function(node, part, push){ // next siblings and previous siblings
        combinators['~'].call(this, node, part, push)
        combinators['!~'].call(this, node, part, push)
    },

    "!": function(node, part, push){ // all parent nodes up to document
        while ((node = node.parentNode)) if (node !== this.document && this.match(node, part)) push(node)
    },

    "!>": function(node, part, push){ // direct parent (one level)
        node = node.parentNode
        if (node !== this.document && this.match(node, part)) push(node)
    },

    "!+": function(node, part, push){ // previous sibling
        while ((node = node.previousSibling)) if (node.nodeType == 1){
            if (this.match(node, part)) push(node)
            break
        }
    },

    "!^": function(node, part, push){ // last child
        node = node.lastChild
        if (node){
            if (node.nodeType == 1){
                if (this.match(node, part)) push(node)
            } else {
                combinators['!+'].call(this, node, part, push)
            }
        }
    },

    "!~": function(node, part, push){ // previous siblings
        while ((node = node.previousSibling)){
            if (node.nodeType === 1 && this.match(node, part)) push(node)
        }
    }

}

Finder.prototype.search = function(context, expression, found){

    if (!context) context = this.document
    else if (!context.nodeType && context.document) context = context.document

    var expressions = parse(expression)

    // no expressions were parsed. todo: is this really necessary?
    if (!expressions || !expressions.length) throw new Error("invalid expression")

    if (!found) found = []

    var uniques, push = isArray(found) ? function(node){
        found[found.length] = node
    } : function(node){
        found[found.length++] = node
    }

    // if there is more than one expression we need to check for duplicates when we push to found
    // this simply saves the old push and wraps it around an uid dupe check.
    if (expressions.length > 1){
        uniques = {}
        var plush = push
        push = function(node){
            var uid = uniqueID(node)
            if (!uniques[uid]){
                uniques[uid] = true
                plush(node)
            }
        }
    }

    // walker

    var node, nodes, part

    main: for (var i = 0; expression = expressions[i++];){

        // querySelector

        // TODO: more functional tests

        // if there is querySelectorAll (and the expression does not fail) use it.
        if (!slick.noQSA && this.querySelectorAll){

            nodes = this.querySelectorAll(context, expression)
            if (nodes !== true){
                if (nodes && nodes.length) for (var j = 0; node = nodes[j++];) if (node.nodeName > '@'){
                    push(node)
                }
                continue main
            }
        }

        // if there is only one part in the expression we don't need to check each part for duplicates.
        // todo: this might be too naive. while solid, there can be expression sequences that do not
        // produce duplicates. "body div" for instance, can never give you each div more than once.
        // "body div a" on the other hand might.
        if (expression.length === 1){

            part = expression[0]
            combinators[part.combinator].call(this, context, part, push)

        } else {

            var cs = [context], c, f, u, p = function(node){
                var uid = uniqueID(node)
                if (!u[uid]){
                    u[uid] = true
                    f[f.length] = node
                }
            }

            // loop the expression parts
            for (var j = 0; part = expression[j++];){
                f = []; u = {}
                // loop the contexts
                for (var k = 0; c = cs[k++];) combinators[part.combinator].call(this, c, part, p)
                // nothing was found, the expression failed, continue to the next expression.
                if (!f.length) continue main
                cs = f // set the contexts for future parts (if any)
            }

            if (i === 0) found = f // first expression. directly set found.
            else for (var l = 0; l < f.length; l++) push(f[l]) // any other expression needs to push to found.
        }

    }

    if (uniques && found && found.length > 1) this.sort(found)

    return found

}

Finder.prototype.sort = function(nodes){
    return this.sorter ? Array.prototype.sort.call(nodes, this.sorter) : nodes
}

// TODO: most of these pseudo selectors include <html> and qsa doesnt. fixme.

var pseudos = {


    // TODO: returns different results than qsa empty.

    'empty': function(){
        return !(this && this.nodeType === 1) && !(this.innerText || this.textContent || '').length
    },

    'not': function(expression){
        return !slick.matches(this, expression)
    },

    'contains': function(text){
        return (this.innerText || this.textContent || '').indexOf(text) > -1
    },

    'first-child': function(){
        var node = this
        while ((node = node.previousSibling)) if (node.nodeType == 1) return false
        return true
    },

    'last-child': function(){
        var node = this
        while ((node = node.nextSibling)) if (node.nodeType == 1) return false
        return true
    },

    'only-child': function(){
        var prev = this
        while ((prev = prev.previousSibling)) if (prev.nodeType == 1) return false

        var next = this
        while ((next = next.nextSibling)) if (next.nodeType == 1) return false

        return true
    },

    'first-of-type': function(){
        var node = this, nodeName = node.nodeName
        while ((node = node.previousSibling)) if (node.nodeName == nodeName) return false
        return true
    },

    'last-of-type': function(){
        var node = this, nodeName = node.nodeName
        while ((node = node.nextSibling)) if (node.nodeName == nodeName) return false
        return true
    },

    'only-of-type': function(){
        var prev = this, nodeName = this.nodeName
        while ((prev = prev.previousSibling)) if (prev.nodeName == nodeName) return false
        var next = this
        while ((next = next.nextSibling)) if (next.nodeName == nodeName) return false
        return true
    },

    'enabled': function(){
        return !this.disabled
    },

    'disabled': function(){
        return this.disabled
    },

    'checked': function(){
        return this.checked || this.selected
    },

    'selected': function(){
        return this.selected
    },

    'focus': function(){
        var doc = this.ownerDocument
        return doc.activeElement === this && (this.href || this.type || slick.hasAttribute(this, 'tabindex'))
    },

    'root': function(){
        return (this === this.ownerDocument.documentElement)
    }

}

Finder.prototype.match = function(node, bit, noTag, noId, noClass){

    // TODO: more functional tests ?

    if (!slick.noQSA && this.matchesSelector){
        var matches = this.matchesSelector(node, bit)
        if (matches !== null) return matches
    }

    // normal matching

    if (!noTag && bit.tag){

        var nodeName = node.nodeName.toLowerCase()
        if (bit.tag === "*"){
            if (nodeName < "@") return false
        } else if (nodeName != bit.tag){
            return false
        }

    }

    if (!noId && bit.id && node.getAttribute('id') !== bit.id) return false

    var i, part

    if (!noClass && bit.classes){

        var className = this.getAttribute(node, "class")
        if (!className) return false

        for (part in bit.classes) if (!RegExp('(^|\\s)' + bit.classes[part] + '(\\s|$)').test(className)) return false
    }

    var name, value

    if (bit.attributes) for (i = 0; part = bit.attributes[i++];){

        var operator  = part.operator,
            escaped   = part.escapedValue

        name  = part.name
        value = part.value

        if (!operator){

            if (!this.hasAttribute(node, name)) return false

        } else {

            var actual = this.getAttribute(node, name)
            if (actual == null) return false

            switch (operator){
                case '^=' : if (!RegExp(      '^' + escaped            ).test(actual)) return false; break
                case '$=' : if (!RegExp(            escaped + '$'      ).test(actual)) return false; break
                case '~=' : if (!RegExp('(^|\\s)' + escaped + '(\\s|$)').test(actual)) return false; break
                case '|=' : if (!RegExp(      '^' + escaped + '(-|$)'  ).test(actual)) return false; break

                case '='  : if (actual !== value) return false; break
                case '*=' : if (actual.indexOf(value) === -1) return false; break
                default   : return false
            }

        }
    }

    if (bit.pseudos) for (i = 0; part = bit.pseudos[i++];){

        name  = part.name
        value = part.value

        if (pseudos[name]) return pseudos[name].call(node, value)

        if (value != null){
            if (this.getAttribute(node, name) !== value) return false
        } else {
            if (!this.hasAttribute(node, name)) return false
        }

    }

    return true

}

Finder.prototype.matches = function(node, expression){

    var expressions = parse(expression)

    if (expressions.length === 1 && expressions[0].length === 1){ // simplest match
        return this.match(node, expressions[0][0])
    }

    // TODO: more functional tests ?

    if (!slick.noQSA && this.matchesSelector){
        var matches = this.matchesSelector(node, expressions)
        if (matches !== null) return matches
    }

    var nodes = this.search(this.document, expression, {length: 0})

    for (var i = 0, res; res = nodes[i++];) if (node === res) return true
    return false

}

var finders = {}

var finder = function(context){
    var doc = context || document
    if (doc.ownerDocument) doc = doc.ownerDocument
    else if (doc.document) doc = doc.document

    if (doc.nodeType !== 9) throw new TypeError("invalid document")

    var uid = uniqueID(doc)
    return finders[uid] || (finders[uid] = new Finder(doc))
}

// ... API ...

var slick = function(expression, context){
    return slick.search(expression, context)
}

slick.search = function(expression, context, found){
    return finder(context).search(context, expression, found)
}

slick.find = function(expression, context){
    return finder(context).search(context, expression)[0] || null
}

slick.getAttribute = function(node, name){
    return finder(node).getAttribute(node, name)
}

slick.hasAttribute = function(node, name){
    return finder(node).hasAttribute(node, name)
}

slick.contains = function(context, node){
    return finder(context).contains(context, node)
}

slick.matches = function(node, expression){
    return finder(node).matches(node, expression)
}

slick.sort = function(nodes){
    if (nodes && nodes.length > 1) finder(nodes[0]).sort(nodes)
    return nodes
}

slick.parse = parse;

// slick.debug = true
// slick.noQSA  = true

module.exports = slick

},{"./parser":409}],408:[function(require,module,exports){
(function (global){
/*
slick
*/"use strict"

module.exports = "document" in global ? require("./finder") : { parse: require("./parser") }

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./finder":407,"./parser":409}],409:[function(require,module,exports){
/*
Slick Parser
 - originally created by the almighty Thomas Aylott <@subtlegradient> (http://subtlegradient.com)
*/"use strict"

// Notable changes from Slick.Parser 1.0.x

// The parser now uses 2 classes: Expressions and Expression
// `new Expressions` produces an array-like object containing a list of Expression objects
// - Expressions::toString() produces a cleaned up expressions string
// `new Expression` produces an array-like object
// - Expression::toString() produces a cleaned up expression string
// The only exposed method is parse, which produces a (cached) `new Expressions` instance
// parsed.raw is no longer present, use .toString()
// parsed.expression is now useless, just use the indices
// parsed.reverse() has been removed for now, due to its apparent uselessness
// Other changes in the Expressions object:
// - classNames are now unique, and save both escaped and unescaped values
// - attributes now save both escaped and unescaped values
// - pseudos now save both escaped and unescaped values

var escapeRe   = /([-.*+?^${}()|[\]\/\\])/g,
    unescapeRe = /\\/g

var escape = function(string){
    // XRegExp v2.0.0-beta-3
    // « https://github.com/slevithan/XRegExp/blob/master/src/xregexp.js
    return (string + "").replace(escapeRe, '\\$1')
}

var unescape = function(string){
    return (string + "").replace(unescapeRe, '')
}

var slickRe = RegExp(
/*
#!/usr/bin/env ruby
puts "\t\t" + DATA.read.gsub(/\(\?x\)|\s+#.*$|\s+|\\$|\\n/,'')
__END__
    "(?x)^(?:\
      \\s* ( , ) \\s*               # Separator          \n\
    | \\s* ( <combinator>+ ) \\s*   # Combinator         \n\
    |      ( \\s+ )                 # CombinatorChildren \n\
    |      ( <unicode>+ | \\* )     # Tag                \n\
    | \\#  ( <unicode>+       )     # ID                 \n\
    | \\.  ( <unicode>+       )     # ClassName          \n\
    |                               # Attribute          \n\
    \\[  \
        \\s* (<unicode1>+)  (?:  \
            \\s* ([*^$!~|]?=)  (?:  \
                \\s* (?:\
                    ([\"']?)(.*?)\\9 \
                )\
            )  \
        )?  \\s*  \
    \\](?!\\]) \n\
    |   :+ ( <unicode>+ )(?:\
    \\( (?:\
        (?:([\"'])([^\\12]*)\\12)|((?:\\([^)]+\\)|[^()]*)+)\
    ) \\)\
    )?\
    )"
*/
"^(?:\\s*(,)\\s*|\\s*(<combinator>+)\\s*|(\\s+)|(<unicode>+|\\*)|\\#(<unicode>+)|\\.(<unicode>+)|\\[\\s*(<unicode1>+)(?:\\s*([*^$!~|]?=)(?:\\s*(?:([\"']?)(.*?)\\9)))?\\s*\\](?!\\])|(:+)(<unicode>+)(?:\\((?:(?:([\"'])([^\\13]*)\\13)|((?:\\([^)]+\\)|[^()]*)+))\\))?)"
    .replace(/<combinator>/, '[' + escape(">+~`!@$%^&={}\\;</") + ']')
    .replace(/<unicode>/g, '(?:[\\w\\u00a1-\\uFFFF-]|\\\\[^\\s0-9a-f])')
    .replace(/<unicode1>/g, '(?:[:\\w\\u00a1-\\uFFFF-]|\\\\[^\\s0-9a-f])')
)

// Part

var Part = function Part(combinator){
    this.combinator = combinator || " "
    this.tag = "*"
}

Part.prototype.toString = function(){

    if (!this.raw){

        var xpr = "", k, part

        xpr += this.tag || "*"
        if (this.id) xpr += "#" + this.id
        if (this.classes) xpr += "." + this.classList.join(".")
        if (this.attributes) for (k = 0; part = this.attributes[k++];){
            xpr += "[" + part.name + (part.operator ? part.operator + '"' + part.value + '"' : '') + "]"
        }
        if (this.pseudos) for (k = 0; part = this.pseudos[k++];){
            xpr += ":" + part.name
            if (part.value) xpr += "(" + part.value + ")"
        }

        this.raw = xpr

    }

    return this.raw
}

// Expression

var Expression = function Expression(){
    this.length = 0
}

Expression.prototype.toString = function(){

    if (!this.raw){

        var xpr = ""

        for (var j = 0, bit; bit = this[j++];){
            if (j !== 1) xpr += " "
            if (bit.combinator !== " ") xpr += bit.combinator + " "
            xpr += bit
        }

        this.raw = xpr

    }

    return this.raw
}

var replacer = function(
    rawMatch,

    separator,
    combinator,
    combinatorChildren,

    tagName,
    id,
    className,

    attributeKey,
    attributeOperator,
    attributeQuote,
    attributeValue,

    pseudoMarker,
    pseudoClass,
    pseudoQuote,
    pseudoClassQuotedValue,
    pseudoClassValue
){

    var expression, current

    if (separator || !this.length){
        expression = this[this.length++] = new Expression
        if (separator) return ''
    }

    if (!expression) expression = this[this.length - 1]

    if (combinator || combinatorChildren || !expression.length){
        current = expression[expression.length++] = new Part(combinator)
    }

    if (!current) current = expression[expression.length - 1]

    if (tagName){

        current.tag = unescape(tagName)

    } else if (id){

        current.id = unescape(id)

    } else if (className){

        var unescaped = unescape(className)

        var classes = current.classes || (current.classes = {})
        if (!classes[unescaped]){
            classes[unescaped] = escape(className)
            var classList = current.classList || (current.classList = [])
            classList.push(unescaped)
            classList.sort()
        }

    } else if (pseudoClass){

        pseudoClassValue = pseudoClassValue || pseudoClassQuotedValue

        ;(current.pseudos || (current.pseudos = [])).push({
            type         : pseudoMarker.length == 1 ? 'class' : 'element',
            name         : unescape(pseudoClass),
            escapedName  : escape(pseudoClass),
            value        : pseudoClassValue ? unescape(pseudoClassValue) : null,
            escapedValue : pseudoClassValue ? escape(pseudoClassValue) : null
        })

    } else if (attributeKey){

        attributeValue = attributeValue ? escape(attributeValue) : null

        ;(current.attributes || (current.attributes = [])).push({
            operator     : attributeOperator,
            name         : unescape(attributeKey),
            escapedName  : escape(attributeKey),
            value        : attributeValue ? unescape(attributeValue) : null,
            escapedValue : attributeValue ? escape(attributeValue) : null
        })

    }

    return ''

}

// Expressions

var Expressions = function Expressions(expression){
    this.length = 0

    var self = this

    var original = expression, replaced

    while (expression){
        replaced = expression.replace(slickRe, function(){
            return replacer.apply(self, arguments)
        })
        if (replaced === expression) throw new Error(original + ' is an invalid expression')
        expression = replaced
    }
}

Expressions.prototype.toString = function(){
    if (!this.raw){
        var expressions = []
        for (var i = 0, expression; expression = this[i++];) expressions.push(expression)
        this.raw = expressions.join(", ")
    }

    return this.raw
}

var cache = {}

var parse = function(expression){
    if (expression == null) return null
    expression = ('' + expression).replace(/^\s+|\s+$/g, '')
    return cache[expression] || (cache[expression] = new Expressions(expression))
}

module.exports = parse

},{}],410:[function(require,module,exports){

/**
 * `Batch' constructor
 *
 * @api public
 * @param {Number} max - optional (Default: Infinity)
 */

module.exports = Batch;
function Batch (max) {
  if (!(this instanceof Batch)) {
    return new Batch(max);
  }

  var self = this;

  this.m = 0; // max
  this.c = 0; // concurrency
  this.jobs = [];

  this.concurrency(Infinity);
  this.max(max);

  Object.defineProperty(this, 'length', {
    get: function () {
      return self.jobs.length;
    }
  });
}

/**
 * Set batch concurrency
 *
 * @api public
 * @param {Number} n
 */

Batch.prototype.concurrency = function (n) {
  if (n > 0) {
    this.c = n;
  }
  return this;
};

/**
 * Set max job limit
 *
 * @api publc
 * @param {Number} n
 */

Batch.prototype.max = function (n) {
  this.m = 'number' == typeof n && n > 0 ? n : Infinity;
  return this;
};

/**
 * Push job onto queue
 *
 * @api publc
 * @param {Function} fn
 */

Batch.prototype.push = function (fn) {
  if ('function' != typeof fn) {
    throw new TypeError("expecting a function");
  } else if (this.length < this.m) {
    this.jobs.push(fn);
  }
  return this;
};

/**
 * Shift job off of queue
 *
 * @api public
 */

Batch.prototype.shift = function () {
  return this.jobs.shift();
};

/**
 * Dequeues all queued jobs
 *
 * @api public
 * @param {Function} done - optional
 */

Batch.prototype.run = function (done) {
  done = 'function' == typeof done ? done : Function();
  var self = this;
  var c = this.c;
  var i = 0;

  // empty queue
  if (0 == this.length) {
    return done(null);
  }

  function dequeue  () {
    var job = null;
    if (0 == self.length) {
      return false;
    }

    job = self.shift();

    if ('function' != typeof job) {
      return;
    }

    try { job(next); }
    catch (err) {
      done(err)
      return false;
    }

    function next (err) {
      if (err) {
        done(err);
      } else if (self.length) {
        dequeue();
      } else {
        done();
      }
    }
  }

  while (i++ < c) {
    if (false === dequeue()) {
      break;
    }
  }

  return this;
};

},{}],411:[function(require,module,exports){
/*jslint node: true */

'use strict';

var ClientRequest = require('./request').ClientRequest;

/**
 * An autoincremented id that is used to distinguish Resolver instances.
 *
 * @type {number}
 * @private
 */
var resolverUID = 0;

/**
 * A resolver takes a request for a resources and sends it through the
 * transport.
 *
 * @constructs Resolver
 */
function Resolver() {
  if (!(this instanceof Resolver))
    return new Resolver();

  /**
   * The resolver's id.
   *
   * @type {number}
   * @protected
   */
  this._id = resolverUID++;

  /**
   * An incrementing ID used for tracking requests.
   *
   * @type {number}
   * @protected
   */
  this._requestID = 0;

  /**
   * Storage for the sent request handlers waiting for a response.
   *
   * @type {Object.<string, function>}
   * @protected
   */
  this._handlers = {};
}
exports.Resolver = Resolver;

/**
 * Adds a handler to the internal storage.
 *
 * @param {number} requestID The identifier for the request.
 * @param {ClientRequest} handler The handler for the request.
 * @protected
 */
Resolver.prototype._addHandler = function(requestID, handler) {
  this._handlers[requestID] = handler;
  return this;
};

/**
 * Removes a handler from the internal storage.
 *
 * @param {number} requestID The identifier for the request.
 * @protected
 */
Resolver.prototype._removeHandler = function(requestID) {
  this._handlers[requestID] = null;
  return this;
};

/**
 * Sends a request through the transport.
 *
 * Subclasses of this class need to implement this method.
 *
 * @param {number} requestID The id of the request.
 * @param {Object} data The payload data for the request.
 * @protected
 */
Resolver.prototype._sendRequest = function(requestID, data) {
  throw new Error('Resolver _sendRequest not implemented.');
};

/**
 * Handles a response from the transport.
 *
 * @param {Object} response The response from the transport.
 * @protected
 */
Resolver.prototype._handleResponse = function(response) {
  throw new Error('Resolver _handleResponse not implemented.');
};

/**
 * Dispatches a request handler with some data.
 *
 * @param {number} requestID The request handler to dispatch.
 * @param {Object} data The response data to send back.
 * @protected
 */
Resolver.prototype._dispatchResponse = function(requestID, requestType, data) {
  var handler = this._handlers[requestID];
  if (!handler) return;
  handler._handleResponse(requestType, data);
};

/**
 * Resolves a request (represented by the data) through the transport.
 *
 * @param {Object} data The data representing the request.
 * @param {function} onsuccess The success handler for the request.
 * @param {function} onerror The error handler for the request.
 */
Resolver.prototype._resolve = function(data, onsuccess, onerror) {
  if (!data || !onsuccess || !onerror ||
      typeof onsuccess != 'function' || typeof onerror != 'function')
    throw new TypeError('Invalid argument length for `resolve`.');

  var requestID = ++this._requestID;
  var request = new ClientRequest(this, requestID, data, onsuccess, onerror);

  this._addHandler(requestID, request);

  request.onClose = this._removeHandler.bind(this);
  request.open();

  return request;
};

/**
 * Resolves a single request (represented by the data) through the transport.
 *
 * @param {Object} data The data representing the request.
 * @param {function} onsuccess The success handler for the request.
 * @param {function} onerror The error handler for the request.
 */
Resolver.prototype.resolve = function(data, onsuccess, onerror) {
  throw new Error('Resolver resolve not implemented.');
};

/**
 * Resolves a subscription request (represented by the data) through the transport.
 *
 * @param {Object} data The data representing the request.
 * @param {function} onsuccess The success handler for the request.
 * @param {function} onerror The error handler for the request.
 */
Resolver.prototype.subscribe = function(data, onsuccess, onerror) {
  throw new Error('Resolver subscribe not implemented.');
};

},{"./request":415}],412:[function(require,module,exports){
(function (global){
/*jslint node: true */

'use strict';

var defer = require('spotify-deferred');
var Resolver = require('./bootstrap').Resolver;

/**
 * A mock resolver for a nodejs environment.
 *
 * This resolver uses regular callbacks as a transport.
 *
 * @constructs Cosmos.MockResolver
 * @extends Cosmos.Resolver
 */
function MockResolver() {
  if (!(this instanceof MockResolver))
    return new MockResolver();
  Resolver.call(this);

  // rebind the _handleResponse method so that we can reuse it for both
  // addEventListener and removeEventListener
  this._handleResponse = this._handleResponse.bind(this);

  /**
   * The identifier for request messages.
   *
   * @type {string}
   * @protected
   */
  this._requestMessageType = 'cosmos-request';

  /**
   * The identifier for response messages.
   *
   * @type {string}
   * @protected
   */
  this._responseMessageType = 'cosmos-response';

  /**
   * Prefix for the requests ids to prevent clashes
   * with bridge requests in webplayer
   *
   * @type {string}
   * @private
   */
  this._requestIdPrefix = 'cosmos_';

  this._handlersMap = {};

  // attach the handler
  this.attach();
}
MockResolver.prototype = new Resolver();
MockResolver.prototype.constructor = MockResolver;
exports.MockResolver = MockResolver;

/**
 * @inheritDoc
 */
MockResolver.prototype._sendRequest = function(requestName, requestID, data) {
  var self = this;

  var message = {
    type: this._requestMessageType,
    resolver: this._id,
    id: this._requestIdPrefix + requestID,
    name: requestName,
    payload: data.serialize ? data.serialize() : data
  };

  if (!this._handlersMap[data._action]) {
    return;
  }

  if (!this._handlersMap[data._action][data._uri]) {
    return;
  }

  this._handlersMap[data._action][data._uri](data, function (status, resp) {
    message.payload = {
      body: typeof resp !== 'undefined' ? resp : status,
      uri: data._uri,
      status: typeof resp !== 'undefined' ? status : 200
    };
    message.type = self._responseMessageType;

    var response = {
      data: message
    };
    self._handleResponse(response);
  });
};

/**
 * @inheritDoc
 */
MockResolver.prototype._handleResponse = function(response) {
  var data = response.data;
  if (typeof data == 'string') {
    try {
      data = JSON.parse(response.data);
    } catch (e) {
      return;
    }
  }
  if (data.type != this._responseMessageType ||
      data.resolver != this._id ||
      !data.payload) return;
  var id = data.id || '';
  var requestID = parseInt(id.replace(this._requestIdPrefix, ''), 10);
  var requestName = data.name || '';
  if (!requestID || !requestName) return;
  this._dispatchResponse(requestID, requestName, data.payload);
};

/**
 * Attaches the resolver so that it could process calls from the window object.
 */
MockResolver.prototype.attach = function() {
  var win = global.window;
  if (win) {
    win._cosmosRequest = this.resolve.bind(this);
  }
};

/**
 * Detaches the resolver so that it doesn't process calls from the window object.
 */
MockResolver.prototype.detach = function() {
  var win = global.window;
  if (win) {
    delete win._cosmosRequest;
  }
};

/**
 * Specific method for the mock resolver to add request handlers
 *
 * @param {string}   method       Type of method (GET, POST, PUT, SUB)
 * @param {string}   uri          Request to handle
 * @param {Function} fn           Function that handles the request
 */
MockResolver.prototype.addHandler = function(method, uri, fn) {
  if (!this._handlersMap[method]) {
    this._handlersMap[method] = {};
  }

  this._handlersMap[method][uri] = fn;
};

/**
 * Specific method for the mock resolver to remove a specific request handler
 *
 * @param {string}   method       Type of method (GET, POST, PUT, SUB)
 * @param {string}   uri          Request to handle
 */
MockResolver.prototype.removeHandler = function(method, uri) {
  if (!this._handlersMap[method]) {
    return;
  }

  if (this._handlersMap[method][uri]) {
    delete this._handlersMap[method][uri];
  }
};

/**
 * Specific method for the mock resolver to remove all handlers
 */
MockResolver.prototype.clearHandlers = function() {
  this._handlersMap = {};
};

/**
 * Resolves a single request (represented by the data) through the transport.
 * Single requests need to be closed immediately after the response is
 * received.
 *
 * @param {Object} data The data representing the request.
 * @param {function} onsuccess The success handler for the request.
 * @param {function} onerror The error handler for the request.
 */
MockResolver.prototype.resolve = function(data, onsuccess, onerror) {
  function onResult(callback, response) {
    defer(callback.bind(this, response));
    request.close();
  }

  var request = this._resolve(data, onResult.bind(this, onsuccess), onResult.bind(this, onerror));
  return request;
};

/**
 * Resolves a  subscription request (represented by the data) through the transport.
 * Subscriptions stay open until they're explicitly closed.
 * Every time the request returns some data pull for next
 * batch is sent.
 *
 * @param {Object} data The data representing the request.
 * @param {function} onsuccess The success handler for the request.
 * @param {function} onerror The error handler for the request.
 */
MockResolver.prototype.subscribe = function(data, onsuccess, onerror) {
  return this._resolve(data, onsuccess, onerror);
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./bootstrap":411,"spotify-deferred":418}],413:[function(require,module,exports){
(function (global){
/*jslint node: true */

'use strict';

var SpotifyApi = global.SpotifyApi;
var useApiRequest = !!(SpotifyApi && SpotifyApi.api &&
    typeof SpotifyApi.api.request === 'function');

var Resolver = require('./bootstrap').Resolver;
var defer = require('spotify-deferred');

/**
 * A resolver for a native environment.
 *
 * This resolver uses the Stitch bridge as a transport
 *
 * @constructs Cosmos.NativeResolver
 * @extends Cosmos.Resolver
 * @param {Object} spBridge Spotify CPP/JS bridge
 */
function NativeResolver(spBridge) {
  if (!(this instanceof NativeResolver))
    return new NativeResolver();
  if (!spBridge) {
    throw new TypeError('Missing `spBridge` parameter');
  }
  Resolver.call(this);

  this._bridge = spBridge;

  this._deferredFlush = false;
}
NativeResolver.prototype = new Resolver();
NativeResolver.prototype.constructor = NativeResolver;
exports.NativeResolver = NativeResolver;

/**
 * Prepare bridge flush.
 * TODO: Move to the separate module
 */
NativeResolver.prototype._prepareCoreFlush = function() {
  if (!this._deferredFlush) {
    this._deferredFlush = true;
    this._defer(this, this._flushRequests);
  }
};

/**
 * Flush bridge requests.
 * TODO: Move to the separate module
 */
NativeResolver.prototype._flushRequests = function() {
  this._deferredFlush = false;
  var flushMsg = JSON.stringify({ name: 'core_flush', args: []});
  this._sendBridgeRequest(flushMsg, {
    onSuccess: function() {},
    onFailure: function() {}
  });
};

/**
 * Defer the function call.
 * TODO: Move to the separate module
 */
NativeResolver.prototype._defer = function(context, callback) {
  defer(callback.bind(context));
};

/**
 * If SpotifyApi is loaded, use api requests to send messages to bridge
 * TODO: Use proxy that will handle Cosmos/Stitch calls for the resolver.
 */
NativeResolver.prototype._sendRequest = function(requestName, requestId, data) {
  var self = this;
  data = (data.serialize ? data.serialize() : data);

  var args = [requestId, data];
  var caller = { self: this, id: requestId, type: requestName };

  if (useApiRequest) {
    this._sendApiRequest(requestName, args, caller, this._handleResponse, this._handleError);
  } else {
    this._sendCosmosRequest(requestName, args, caller, this._handleResponse, this._handleError);
  }
};


/**
 * Talk to bridge directly from Cosmos
 * TODO: Move to the separate module
 */
NativeResolver.prototype._sendCosmosRequest = function(requestName, args, caller, onSuccess, onError) {
  var message = JSON.stringify({
    name: requestName,
    args: args
  });

  this._sendBridgeRequest(message, {
    onSuccess: function(data) {
      onSuccess.call(caller, JSON.parse(data));
    },
    onFailure: function(data) {
      data = JSON.parse(data);
      onError.call(caller, data);
    }
  });

  this._prepareCoreFlush();
};

/**
 * Send message to the bridge
 * @param {string} message The message to send to the bridge.
 * @param {Object.<string, function>} callbackMap The `onSuccess`
 * and `onFailure` functions to be executed after request is completed.
 * TODO: Use proxy that will handle Cosmos/Stitch calls for the resolver.
 */
NativeResolver.prototype._sendBridgeRequest = function(message, callbackMap) {
  this._bridge.executeRequest(message, callbackMap || {});
};

/**
 * Use old API to send messages to the bridge.
 * TODO: Move to the separate module
 */
NativeResolver.prototype._sendApiRequest = function(requestName, args, caller, onSuccess, onError) {
  SpotifyApi.api.request(
      requestName,
      args,
      caller,
      onSuccess,
      onError
  );
};

/**
 * Handles successful responses from the bridge
 * @param {Object} data The response data.
 */
NativeResolver.prototype._handleResponse = function(data) {
  this.self._dispatchResponse(this.id, this.type, data.responses && data.responses[0] || data);
};

/**
 * Handles failed responses from the bridge
 * @param {Object} error The error data.
 */
NativeResolver.prototype._handleError = function(error) {
  this.self._dispatchResponse(this.id, this.type, error);
};

/**
 * Resolves a single request (represented by the data) through the transport.
 * Single requests need to be closed immediately after the response is
 * received.
 *
 * @param {Object} data The data representing the request.
 * @param {function} onsuccess The success handler for the request.
 * @param {function} onerror The error handler for the request.
 */
NativeResolver.prototype.resolve = function(data, onsuccess, onerror) {
  function onResult(callback, response) {
    this._defer(this, callback.bind(this, response));
    request.close();
  }

  var request = this._resolve(data, onResult.bind(this, onsuccess), onResult.bind(this, onerror));
  return request;
};

/**
 * Resolves a  subscription request (represented by the data) through the transport.
 * Subscriptions stay open until they're explicitly closed.
 * Every time the request returns some data pull for next
 * batch is sent.
 *
 * @param {Object} data The data representing the request.
 * @param {function} onsuccess The success handler for the request.
 * @param {function} onerror The error handler for the request.
 */
NativeResolver.prototype.subscribe = function(data, onsuccess, onerror) {
  function onResult(callback, response) {
    callback.call(this, response);
    request.pull();
  }

  var request = this._resolve(data, onResult.bind(this, onsuccess), onResult.bind(this, onerror));
  return request;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./bootstrap":411,"spotify-deferred":418}],414:[function(require,module,exports){
(function (global){
/*jslint node: true */

'use strict';

var defer = require('spotify-deferred');
var Resolver = require('./bootstrap').Resolver;

/**
 * A resolver for a web-based environment.
 *
 * This resolver uses postMessage as a transport.
 *
 * @constructs Cosmos.WebResolver
 * @extends Cosmos.Resolver
 * @type {string=} opt_target The optional target for the postMessage calls.
 */
function WebResolver(opt_target) {
  if (!(this instanceof WebResolver))
    return new WebResolver(opt_target);
  Resolver.call(this);

  /**
   * The target for postMessage calls.
   *
   * @type {string}
   * @protected
   */
  this._target = opt_target || '*';

  // rebind the _handleResponse method so that we can reuse it for both
  // addEventListener and removeEventListener
  this._handleResponse = this._handleResponse.bind(this);

  /**
   * The identifier for request messages.
   *
   * @type {string}
   * @protected
   */
  this._requestMessageType = 'cosmos-request';

  /**
   * The identifier for response messages.
   *
   * @type {string}
   * @protected
   */
  this._responseMessageType = 'cosmos-response';

  /**
   * Prefix for the requests ids to prevent clashes
   * with bridge requests in webplayer
   *
   * @type {string}
   * @private
   */
  this._requestIdPrefix = 'cosmos_';

  // attach the handler
  this.attach();
}
WebResolver.prototype = new Resolver();
WebResolver.prototype.constructor = WebResolver;
exports.WebResolver = WebResolver;

/**
 * @inheritDoc
 */
WebResolver.prototype._sendRequest = function(requestName, requestID, data) {
  var top = global.window.top;

  var message = {
    type: this._requestMessageType,
    resolver: this._id,
    id: this._requestIdPrefix + requestID,
    name: requestName,
    payload: data.serialize ? data.serialize() : data
  };
  top.postMessage(JSON.stringify(message), this._target);
};

/**
 * @inheritDoc
 */
WebResolver.prototype._handleResponse = function(response) {
  var data = response.data;
  if (typeof data == 'string') {
    try {
      data = JSON.parse(response.data);
    } catch (e) {
      return;
    }
  }
  if (data.type != this._responseMessageType ||
      data.resolver != this._id ||
      !data.payload) return;
  var id = data.id || '';
  var requestID = parseInt(id.replace(this._requestIdPrefix, ''), 10);
  var requestName = data.name || '';
  if (!requestID || !requestName) return;
  this._dispatchResponse(requestID, requestName, data.payload);
};

/**
 * Attaches the resolver so that it could process postMessage calls.
 */
WebResolver.prototype.attach = function() {
  var win = global.window;
  if (win.addEvent && !win.addEventListener) {
    win.addEvent('onmessage', this._handleResponse);
  } else {
    win.addEventListener('message', this._handleResponse, false);
  }
};

/**
 * Detaches the resolver so that it doesn't process postMessage calls.
 */
WebResolver.prototype.detach = function() {
  var win = global.window;
  if (win.removeEvent && !win.removeEventListener) {
    win.removeEvent('onmessage', this._handleResponse);
  } else {
    win.removeEventListener('message', this._handleResponse, false);
  }
};

/**
 * Resolves a single request (represented by the data) through the transport.
 * Single requests need to be closed immediately after the response is
 * received.
 *
 * @param {Object} data The data representing the request.
 * @param {function} onsuccess The success handler for the request.
 * @param {function} onerror The error handler for the request.
 */
WebResolver.prototype.resolve = function(data, onsuccess, onerror) {
  function onResult(callback, response) {
    defer(callback.bind(this, response));
    request.close();
  }

  var request = this._resolve(data, onResult.bind(this, onsuccess), onResult.bind(this, onerror));
  return request;
};

/**
 * Resolves a  subscription request (represented by the data) through the transport.
 * Subscriptions stay open until they're explicitly closed.
 * Every time the request returns some data pull for next
 * batch is sent.
 *
 * @param {Object} data The data representing the request.
 * @param {function} onsuccess The success handler for the request.
 * @param {function} onerror The error handler for the request.
 */
WebResolver.prototype.subscribe = function(data, onsuccess, onerror) {
  return this._resolve(data, onsuccess, onerror);
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./bootstrap":411,"spotify-deferred":418}],415:[function(require,module,exports){
/*jslint node: true */

'use strict';

var defer = require('spotify-deferred');

/**
 * The representation of the connection to the client.
 * With introduction of Cosmos subscription the model of making
 * client requests changed.
 * Each Cosmos requests now needs to be explicitly cancelled to
 * close the connection.
 * Simple requests that only send or retrieve data (e.g POST and GET)
 * need to send 'cosmos_request_cancel' message immediately after the response
 * is received.
 * Subscription requests need to send a 'cosmos_request_pull' message every time
 * they receive data. The consumer of the subscription needs to cancel the subscription
 * when no more data should be sent from the provider.
 */
function ClientRequest(resolver, requestId, data, onsuccess, onerror) {

  /**
   * Request identifier.
   * @type {number}
   */
  this._requestId = requestId;

  /**
   * Either web or native request resolver.
   * @type {Cosmos.Resolver}
   */
  this._resolver = resolver;

  /**
   * Data that should be passed with every request.
   * @type {*}
   */
  this._requestData = data;

  /**
   * Triggered on success
   * @type {function}
   */
  this._successCallback = onsuccess;

  /**
   * Triggered on error
   * @type {function}
   */
  this._errorCallback = onerror;

  /**
   * Current state of the request.
   * @type {ClientRequest.status}
   */
  this._status = ClientRequest.status.INITIALIZED;
}
exports.ClientRequest = ClientRequest;

/**
 * Possible state of the ClientRequest instance.
 */
ClientRequest.status = {
  INITIALIZED: 'INITIALIZED',
  CLOSED: 'CLOSED',
  OPEN: 'OPEN'
};

/**
 * Possible desktop bridge messages.
 */
ClientRequest.messages = {
  OPEN: 'cosmos_request_create',
  PULL: 'cosmos_request_pull',
  CLOSE: 'cosmos_request_cancel'
};

/**
 * Opens the connection with the client.
 */
ClientRequest.prototype.open = function() {
  if (this._status === ClientRequest.status.INITIALIZED) {
    this._status = ClientRequest.status.OPEN;
    this._sendRequest(ClientRequest.messages.OPEN, this._requestData);
  }
};

/**
 * Send pull request for the open connection.
 * For subscriptions pull should resolve to a
 * piece of data.
 */
ClientRequest.prototype.pull = function() {
  if (this._status === ClientRequest.status.OPEN) {
    this._sendRequest(ClientRequest.messages.PULL, this._requestData);
  }
  return this._status;
};

/**
 * Closes the connection with the client.
 */
ClientRequest.prototype.close = function() {
  if (this._status === ClientRequest.status.OPEN) {
    this._status = ClientRequest.status.CLOSE;
    this._sendRequest(ClientRequest.messages.CLOSE);
  }
};

ClientRequest.prototype.onClose = function() {};

/**
 * Sends the request to the platform specific resolver
 * @param {string} requestName The message type. One of the {ClientRequest.messages}.
 * @param {object?} data The data to send with the request.
 */
ClientRequest.prototype._sendRequest = function(requestName, data) {
  this._resolver._sendRequest(requestName, this._requestId, data || {});
};

/**
 * Handles the response for the given request
 * @param {String} requestName The message type. One of the {ClientRequest.messages}.
 * @param {Object} data The response data.
 */
ClientRequest.prototype._handleResponse = function(requestName, data) {
  var self = this;
  var status = data && data.status;
  var callback;

  if (requestName === ClientRequest.messages.CLOSE) {
    this._successCallback = null;
    this._errorCallback = null;
    this._requestData = null;
    this.onClose(this._requestId);
    return;
  }

  callback = this._successCallback;
  callback = typeof callback === 'function' ? callback : function() {};
  defer(callback.bind(this, data));
};

},{"spotify-deferred":418}],416:[function(require,module,exports){
(function (global){
'use strict';

var window = global.window || {};
var process = global.process;

var common = require('cosmos-common-js');
var Resolver = require('./scripts/resolver').Resolver;

var SPResolver = null;
var spResolver = null;

var hasNativeBridge = window._getSpotifyModule &&
    typeof window._getSpotifyModule === 'function' &&
    window._getSpotifyModule('bridge');

var nodeRegex = /(node)|(grunt)|(iojs)(\.exe)*$/;
var isNodeJs = process && process.title && nodeRegex.test(process.argv[0]);

if (!isNodeJs) {
  if (hasNativeBridge) {
    SPResolver = require('./env/bootstrap.native.js').NativeResolver;
    spResolver = new SPResolver(hasNativeBridge);
  } else {
    SPResolver = require('./env/bootstrap.web.js').WebResolver;
    spResolver = new SPResolver();
  }
} else {
  SPResolver = require('./env/bootstrap.mock.js').MockResolver;
  spResolver = new SPResolver();

  exports.mockResolver = {
    addHandler: spResolver.addHandler.bind(spResolver),
    removeHandler: spResolver.removeHandler.bind(spResolver),
    clearHandlers: spResolver.clearHandlers.bind(spResolver)
  };
}

exports.Resolver = Resolver;
exports.Action = common.request.Action;
exports.Request = common.request.Request;
exports.Response = common.response.Response;
exports.resolver = spResolver ? new Resolver(spResolver) : null;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./env/bootstrap.mock.js":412,"./env/bootstrap.native.js":413,"./env/bootstrap.web.js":414,"./scripts/resolver":419,"cosmos-common-js":309}],417:[function(require,module,exports){
/**
 * @file
 * Unified window messaging facility.
 *
 * This module exports two functions to the Spotify
 * namespace which allows other subsystems to handle
 * particular types of messages sent through the native
 * window.postMessage method.
 *
 * @see Spotify.addMessageHandler
 * @see Spotify.removeMessageHandler
 */
'use strict';

var POST_ROUTER_ID = 'post-router-msg-' + new Date().getTime();

var hasStructuredClone = false;

var setImmediate = setImmediate ? setImmediate : setTimeout;

var CURRENT_WINDOW_ORIGIN = undefined;

if (typeof window !== 'undefined') {
  CURRENT_WINDOW_ORIGIN = (window.location.origin ||
      window.location.protocol + '//' + window.location.hostname);

  // Hacky solution to make it work for the webplayer.
  if (!window.__forceNoStructuredClone) {
    // Check if the platform has support for structured cloning.
    //
    // In platforms where this is supported, sending a postMessage with an
    // object that contains a function will throw an error, as it is not
    // cloneable.
    try {
      window.postMessage({
        toString: function() {
          return "clone-test";
        }
      }, CURRENT_WINDOW_ORIGIN);
      hasStructuredClone = false;
    } catch(e) {
      hasStructuredClone = true;
    }
  }
}

/**
 * Storage for message handlers.
 *
 * @type {Object.<string, Spotify.Shell.MessageHandler>}
 * @private
 */
var handlers = {};


/**
 * Variable to check if the window is already listening to postMessage events
 *
 * @type {bool}
 * @private
 */
var isListening = false;


function handleImmediateMessage(data) {
  var handler = handlers[data.type];
  if (!handler) return;
  handler.fn.call(this, data);
}


/**
 * Main event handler for the window message event.
 *
 * @param {Event} event The message event object.
 * @private
 */
function handlePostMessage(event) {
  var data = event.data;
  if (!hasStructuredClone) {
    if (typeof data == 'string') {
      try {
        data = JSON.parse(data);
      } catch (e) {
        return;
      }
    } else {
      // We only expect strings.
      return;
    }
  }
  if (event.origin == CURRENT_WINDOW_ORIGIN) {
    data = data[POST_ROUTER_ID];
    if (!data) {
      // Not our data, return immediately.
      return;
    }
  }
  var handler = handlers[data.type];
  if (!handler || handler.origin != '*' && event.origin !== handler.origin) {
    return;
  }
  handler.fn.call(this, data, event);
}

/**
 * Attaches the handlePostMessage function to PostMessage events
 *
 * @private
 */
var startListening = function() {
  if (window.attachEvent && !window.addEventListener) {
    // IE8 and Below
    window.attachEvent('onmessage', handlePostMessage);
  } else if (window.attachEvent && window.addEventListener) {
    // IE9
    window.addEventListener('message', handlePostMessage, false);
  } else if (window.addEventListener) {
    // Everyone else
    window.addEventListener('message', handlePostMessage, false);
  }
};


/**
 * Adds a message handler for a particular message type.
 *
 * The message handler function will be invoked when the window receives
 * a message marked as a particular type, receiving an argument. The
 * argument will be the data payload of the event decoded from JSON.
 *
 * @param {string} type The type of the message to handle.
 * @param {function} fn The handler function.
 * @param {string} origin needed
 * @throws {Error} Thrown if the message type being handled already has
 *     a handler function.
 */
var addMessageHandler = function(type, fn, origin) {
  if (typeof window !== 'undefined' && !isListening) {
    startListening();
    isListening = true;
  }

  if (!origin) {
    origin = CURRENT_WINDOW_ORIGIN;
  }

  if (handlers[type]) {
    throw new Error('Rehandling of message "' + type + '" not allowed.');
  }
  handlers[type] = {
    fn: fn,
    origin: origin
  };
  return;
};


/**
 * Removes a message handler for a particular message type.
 *
 * @param {string} type The type of the message to remove.
 * @param {Spotify.Shell.MessageHandler} fn The handler function.
 * @return {boolean} True if the handler function was succesfully removed.
 */
var removeMessageHandler = function(type, fn) {
  if (handlers[type] && (!fn || handlers[type].fn === fn)) {
    handlers[type] = null;
    return true;
  }
  return false;
};


/**
 * Sends a message to the event handler
 *
 * @param {string} type The type of the message to remove.
 * @param {Object} data JSON object to pass to the handler
 */
var sendMessage = function(type, data, destWindow, origin) {
  data = data || {};
  data.type = type;

  if (typeof window === 'undefined') {
    return setImmediate(handleImmediateMessage.bind(null, data));
  }

  destWindow = destWindow || window;

  if (!origin) {
    origin = CURRENT_WINDOW_ORIGIN;
  }

  destWindow.postMessage(JSON.stringify(data), origin);
};

var sendLocalMessage = function(type, data) {
  data = data || {};
  data.type = type;

  if (typeof window === 'undefined') {
    return setImmediate(handleImmediateMessage.bind(null, data));
  }

  // Wrap the data in a custom object to quickly identify the message.
  var wrapper = {};
  wrapper[POST_ROUTER_ID] = data;

  window.postMessage(hasStructuredClone ?
                     wrapper :
                     JSON.stringify(wrapper), CURRENT_WINDOW_ORIGIN);
};


/**
 * Export public interface
 */
module.exports = {
  addMessageHandler: addMessageHandler,
  removeMessageHandler: removeMessageHandler,
  sendMessage: sendMessage,
  sendLocalMessage: sendLocalMessage,
  WINDOW_ORIGIN: CURRENT_WINDOW_ORIGIN
};

},{}],418:[function(require,module,exports){
/**
 * @file
 * Introduces a function called "defer" that allows functions to be
 * executed in the next available tick.
 *
 * Unlike "setTimeout", "defer" executes the function at the nearest
 * possible time without clamping.
 *
 * @see Spotify.defer
 */
'use strict';

var PostRouter = require('spotify-postrouter');


/**
 * Storage for deferred functions to be executed.
 *
 * @type {Array.<function()>}
 * @private
 */
var deferred = [];


/**
 * A bound version of the postMessage routine used to trigger deferred
 * execution.
 *
 * @type {function()}
 * @private
 */
var send = function () {
  PostRouter.sendLocalMessage('execute_deferreds');
};


/**
 * Executes the deferred functions when the window
 * receives an 'execute_deferreds' message.
 *
 * @private
 */
function executeDeferreds() {
  var fns = deferred.splice(0);
  if (!fns.length) return;
  for (var i = 0, l = fns.length; i < l; i++) {
    try {
      fns[i]();
    } finally {
      // Do nothing.
      null;
    }
  }
}

PostRouter.addMessageHandler('execute_deferreds', executeDeferreds);


/**
 * Executes the function applied at the nearest possible time without
 * clamping.
 *
 * @param {function()} fn The function to execute.
 */
var defer = function(fn) {
  var trigger = !deferred.length;
  deferred.push(fn);
  if (trigger) send();
};


/**
 * Export public interface
 */
module.exports = defer;

},{"spotify-postrouter":417}],419:[function(require,module,exports){
var common = require('cosmos-common-js');

var Request = common.request.Request;
var Action = common.request.Action;
var Response = common.response.Response;

/**
 * Checks whether a status is successful.
 *
 * We define a successful status to be something within the 200 to 299 range.
 *
 * @param {number} status The status to check.
 */
function _isSuccessStatus(status) {
  // This constitutes a successfull status.
  return (status >= 200 && status <= 299);
};


function Resolver(spResolver) {
  if (!spResolver || typeof spResolver.resolve !== 'function') {
    throw TypeError('Incorrect resolver argument');
  }

  this._resolver = spResolver;
}

/**
 * The basic, generic method of sending the requests.
 *
 * For params description:
 * @borrows Resolver#_resolve as Resolver#resolve
 */
Resolver.prototype.resolve = function(request, callback) {
  return this._resolve(request, callback);
};

/**
 * Convenience method for doing GET requests.
 * resolver.get('sp://player') is an equivalent of
 * resolver.resolve(new Request('GET', 'sp://player')).
 *
 * @param {string|Object.<string, object>} options If is a string
 * will be parsed as url. If more data is needed, object notation
 * should be used.
 *  param options.url {string} The url of the request.
 *  param options.body {object=} The request body.
 *  param options.headers {object=} The request headers.
 * @param {function(error=, object?)} callback The function
 * executed after the request has been completed.
 *
 * @return {RequestHandler} The cancellable request handler.
 */
Resolver.prototype.get = function(options, callback) {
  return this._resolveFromParams(Action.GET, options, callback);
};

/**
 * Convenience method for doing POST requests.
 * resolver.post('sp://player') is an equivalent of
 * resolver.resolve(new Request('POST', 'sp://player'))
 *
 * @see Resolver#get for params description and returned value.
 */
Resolver.prototype.post = function(options, callback) {
  return this._resolveFromParams(Action.POST, options, callback);
};

/**
 * Convenience method for doing SUB requests.
 * resolver.subscribe('sp://player') is an equivalent of
 * resolver.resolve(new Request('SUB', 'sp://player'))
 *
 * @see Resolver#get for params description and returned value.
 */
Resolver.prototype.subscribe = function(options, callback) {
  return this._resolveFromParams(Action.SUB, options, callback);
};

/**
 * Convenience method for doing PUT requests.
 * resolver.put('sp://ads/v1/settings/session') is an equivalent of
 * resolver.resolve(new Request('PUT', 'sp://ads/v1/settings/session'))
 *
 * @see Resolver#get for params description and returned value.
 */
Resolver.prototype.put = function(options, callback) {
  return this._resolveFromParams(Action.PUT, options, callback);
};

/**
 * Convenience method for doing PATCH requests.
 * resolver.patch('sp://ads/v1/settings/session') is an equivalent of
 * resolver.resolve(new Request('PATCH', 'sp://ads/v1/settings/session'))
 *
 * @see Resolver#get for params description and returned value.
 */
Resolver.prototype.patch = function(options, callback) {
  return this._resolveFromParams(Action.PATCH, options, callback);
};

/**
 * Convenience method for doing DELETE requests.
 * resolver.delete('sp://player') is an equivalent of
 * resolver.resolve(new Request('DELETE', 'sp://player'))
 *
 * @see Resolver#get for params description and returned value.
 */
Resolver.prototype.delete = function(options, callback) {
  return this._resolveFromParams(Action.DELETE, options, callback);
};

/**
 * @private
 * Sends the request to the platform specific request resolver.
 * If the request action is 'SUB' it will send subscribe request
 * In any other case it will send simple resolve request.
 *
 * @param {Cosmos.Request} request A request object.
 * @param {function(error=, object?)} callback The function
 * executed after the request has been completed.
 *
 * @return {RequestHandler} The cancellable request handler.
 */
Resolver.prototype._resolve = function(request, callback) {
  if (!callback || typeof callback !== 'function') {
    callback = function() {};
  }

  var requestHandler;

  function onSuccess(serverResponse) {
    if (!requestHandler._request) {
      return;
    }

    var response = Response.fromObject(serverResponse);
    if (!response) {
      var error = new Error(
        'Failed to parse response: ' + JSON.stringify(serverResponse));
      return callback(error);
    }

    if (_isSuccessStatus(response.getStatusCode())) {
      return callback(null, response);
    } else {
      // Extract just the initial part of the request uri. It's good to have something
      // but it is also good to avoid having everything, since that can hurt dashboards
      // that group error messages.
      var requestEndpoint = request.toJSON().uri.match(/[^\:]*(\:\/\/)?[^\/]*/)[0];
      var errorMessage = (
        response.getHeader("error") ||
        "Request to " + requestEndpoint + " failed with status code " + response.getStatusCode());
      var error = new Error(errorMessage);
      error.response = response;
      return callback(error, response);
    }
  }

  function onError(serverResponse) {
    return callback(serverResponse instanceof Error ?
      serverResponse :
      new Error('Request failed: ' + JSON.stringify(serverResponse)));
  }

  var resolveFn = request.getAction() === Action.SUB ?
      this._resolver.subscribe : this._resolver.resolve;

  var clientRequest = resolveFn.call(this._resolver, request, onSuccess, onError);

  requestHandler = new RequestHandler(clientRequest);
  return requestHandler;
};

/**
 * @private
 * Creates Request object from supplied params.
 * @param {string} method Request method. One of the Request.Action.
 * @param {string|Object.<string, object>} options If is a string
 * will be parsed as url. If more data is needed, object notation
 * should be used.
 *  param options.url {string} The url of the request.
 *  param options.body {object=} The request body.
 *  param options.headers {object=} The request headers.
 * @param {function(error=, object?)} callback The function
 * executed after the request has been completed.
 *
 * @return {RequestHandler} The cancellable request handler.
 */
Resolver.prototype._resolveFromParams = function(method, options, callback) {
  options = options || {};

  var url = typeof options === 'string' ? options : options.url;
  var headers = options.headers;
  var body = options.body;

  var request = new Request(method, url, headers, body);

  return this._resolve(request, callback);
};

/**
 * The object that wraps the clientRequest
 * in a very simple interface.
 * Separates the implementation of the ClientRequest
 * from the request handler returned by Cosmos API.
 *
 * @param {Cosmos.ClientRequest} request The object
 * representing the newly opened request to the client.
 * Usually a request will be a subscription that
 * needs a close handler.
 */
function RequestHandler(request) {
  if (!request || typeof request.close !== 'function')
    throw new TypeError('Invalid `request` argument.');

  this._request = request;
}

/**
 * Closes the request and removes the object.
 */
RequestHandler.prototype.cancel = function() {
  if (this._request) {
    this._request.close();
    this._request = null;
  }
};

exports.Resolver = Resolver;

},{"cosmos-common-js":309}],420:[function(require,module,exports){
'use strict';

/**
 * The Base62 Converter
 *
 * @class Base62
 * @constructor
 *
 */

var digits = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
var invHexDigits = {};
var invDigits = {};

for (var i = 0; i < digits.length; ++i) { invDigits[digits[i]] = i; }
for (var i = 0; i < 16; ++i) { invHexDigits['0123456789abcdef'[i]] = i; }
for (var i = 0; i < 16; ++i) { invHexDigits['0123456789ABCDEF'[i]] = i; }

/**
 * lhs *= rhs
 * @private
 */
function mul(lhs, rhs, base) {
  var rest = 0;
  for (var i = 0; i < lhs.length; ++i) {
    var tmp = lhs[i] * rhs + rest;
    lhs[i] = tmp % base;
    rest = ~~(tmp / base);
  }
  while (rest) {
    lhs.push(rest % base);
    rest = ~~(rest / base);
  }
}

/**
 * acc += lhs * rhs
 * @private
 */
function madd(acc, lhs, rhs, base) {
  var rest = 0;
  for (var i = 0; i < lhs.length; ++i) {
    var tmp = ~~acc[i] + lhs[i] * rhs + rest;
    acc[i] = tmp % base;
    rest = ~~(tmp / base);
  }
  while (rest) {
    var tmp = ~~acc[i] + rest;
    acc[i] = tmp % base;
    rest = ~~(tmp / base);
    ++i;
  }
}

/**
 * Change base
 * @private
 */
function convert(data, fromBase, toBase) {
  var r = [0];
  var b = [1];
  for (var i = 0; i < data.length; ++i) {
    madd(r, b, data[i], toBase);
    mul(b, fromBase, toBase);
  }
  return r;
}

/**
 * Decode to
 * @private
 */
function mapr(data, mapping) {
  for (var i = 0, r = []; i < data.length; ++i) { r.push(mapping[data[i]]); }
  return r.reverse();
}

/**
 * Pad with 0s
 * @private
 */
function pad(data, length) {
  while (data.length < length) { data.push(0); }
  return data;
}

module.exports = {

  /**
   * Converts from array of bytes to base62 encoded string.
   *
   * @public
   * @name Spotify.Utils.Base62#fromBytes
   * @function
   * @param {Array.<number>} data Array of byte numbers.
   * @param {?number} length Do zeropadding until at least this length.
   * @return {string} Base62 encoded string.
  **/
  fromBytes: function(data, length) {
    var r = convert(data.slice(0).reverse(), 256, 62);
    return mapr(pad(r, length), digits).join('');
  },

  /**
   * Converts from base62 encoded string to array of bytes
   *
   * @public
   * @name Spotify.Utils.Base62#toBytes
   * @function
   * @param {string} str Base62 encoded string.
   * @param {?number} length Do zeropadding until at least this length.
   * @return {Array.<number>} Array of byte numbers.
  **/
  toBytes: function(str, length) {
    var r = convert(mapr(str, invDigits), 62, 256);
    return pad(r, length).reverse();
  },

  /**
   * Converts from base62 encoded string to hex encoded string
   *
   * @public
   * @name Spotify.Utils.Base62#toHex
   * @function
   * @param {string} str Base62 encoded string.
   * @param {?number} length Do zeropadding until at least this length.
   * @return {string} Hex encoded string.
  **/
  toHex: function(str, length) {
    var r = convert(mapr(str, invDigits), 62, 16);
    return mapr(pad(r, length), digits).join('');
  },

  /**
   * Converts from hex encoded strign to base62 encoded string
   *
   * @public
   * @name Spotify.Utils.Base62#fromHex
   * @function
   * @param {string} str Hex encoded string.
   * @param {?number} length Do zeropadding until at least this length.
   * @return {string} Base62 encoded string.
  **/
  fromHex: function(str, length) {
    var r = convert(mapr(str, invHexDigits), 16, 62);
    return mapr(pad(r, length), digits).join('');
  }

};

},{}],421:[function(require,module,exports){
(function() {
  /**
   * @file
   * Introduces a function called "defer" that allows functions to be
   * executed in the next available tick.
   *
   * Unlike "setTimeout", "defer" executes the function at the nearest
   * possible time without clamping.
   *
   * @see Spotify.defer
   */
  'use strict';

  var hasWindow = typeof window != 'undefined';
  var hasDefineProperty = typeof Object.defineProperty == 'function';

  if (hasWindow && window.__modDefFn) {
    // If deferred has been attached to the global scope
    module.exports = window.__modDefFn;
    return;
  }

  /**
   * Storage for deferred functions to be executed.
   *
   * @type {Array.<function()>}
   * @private
   */
  var deferred = [];


  /**
   * A bound version of the postMessage routine used to trigger deferred
   * execution.
   *
   * @type {function()}
   * @private
   */
  var send;
  var origin;

  if (hasWindow && window.postMessage) {
    origin = (window.location.origin ||
          window.location.protocol + '//' + window.location.hostname);
    send = window.postMessage.bind(window, '@execute_deferreds', origin);
    if (!window.__hasDeferredHandler) {
      if (hasDefineProperty) {
        Object.defineProperty(window, '__hasDeferredHandler', {value: 1});
      } else {
        window.__hasDeferredHandler = 1;
      }
      var handler = function(e) {
        if (e.origin != origin && e.data != '@execute_deferreds') {
          return;
        }
        executeDeferreds();
      };
      if (window.addEventListener) {
        window.addEventListener('message', handler);
      } else {
        window.attachEvent('onmessage', handler);
      }
    }
  } else if (typeof setImmediate != 'undefined') {
    send = setImmediate.bind(null, executeDeferreds);
  } else {
    send = setTimeout.bind(null, executeDeferreds, 10);
  }


  /**
   * Executes the deferred functions when the window
   * receives an 'execute_deferreds' message.
   *
   * @private
   */
  function executeDeferreds() {
    var fns = deferred.splice(0);
    if (!fns.length) return;
    for (var i = 0, l = fns.length; i < l; i++) {
      try {
        fns[i]();
      } finally {
        // Do nothing.
        null;
      }
    }
  }


  /**
   * Executes the function applied at the nearest possible time without
   * clamping.
   *
   * @param {function()} fn The function to execute.
   */
  var defer = function(fn) {
    var trigger = !deferred.length;
    deferred.push(fn);
    if (trigger) send();
  };

  if (hasWindow && !window.__modDefFn) {
    if (hasDefineProperty) {
      Object.defineProperty(window, '__modDefFn', {value: defer});
    } else {
      window.__modDefFn = defer;
    }
  }

  /**
   * Export public interface
   */
  module.exports = defer;

})();

},{}],422:[function(require,module,exports){
/**
 * @module spotify-eventemitter
 */
'use strict';

/**
 * @private
 */
var _defer = require('spotify-deferred');

/**
 * The event handlers.
 *
 * @typedef {Array.<function>}
 * @private
 */
var EventHandlers;

/**
 * Represents an Event.
 *
 * **NOTE**: The Event class is an internal class: you cannot instantiate it
 * directly. Instead, you should use the provided
 * {@link module:spotify-eventemitter.createEvent} function.
 *
 * @constructor
 * @param {string} type The type name of the event object.
 * @param {Object} props An object that will be added as properties of the
 *     event object.
 * @see {@link module:spotify-eventemitter.createEvent}
 */
function Event(type, props) {
  /**
   * The type of the event.
   *
   * @type {string}
   */
  this.type = type;

  /**
   * A flag for whether preventDefault was called.
   *
   * @type {boolean}
   * @private
   */
  this._prevented = false;

  /**
   * A flag for whether stopPropagation was called
   *
   * @type {boolean}
   * @private
   */
  this._stopped = false;

  /**
   * A flag for whether stopImmediatePropagation was called.
   *
   * @type {boolean}
   * @private
   */
  this._immediateStopped = false;

  if (props) {
    for (var key in props) {
      if (key == 'type') {
        continue;
      }
      this[key] = props[key];
    }
  }
}

/**
 * Prevents the default operation for the event.
 */
Event.prototype.preventDefault = function() {
  this._prevented = true;
};

/**
 * Returns whether preventDefault was called on the event.
 *
 * @return {boolean} True if preventDefault was called, false otherwise.
 */
Event.prototype.isDefaultPrevented = function() {
  return this._prevented;
};

/**
 * Stops the propagation of the event.
 */
Event.prototype.stopPropagation = function() {
  this._stopped = true;
};

/**
 * Returns whether stopPropagation was called on the event.
 *
 * @return {boolean} True if stopPropagation was called, false otherwise.
 */
Event.prototype.isPropagationStopped = function() {
  return this._stopped;
};

/**
 * Stops the immediate propagation of the event.
 *
 * Handlers added after any event handler calling this method will not receive
 * the event.
 */
Event.prototype.stopImmediatePropagation = function() {
  this._immediateStopped = true;
};

/**
 * Returns whether stopImmediatePropagation was called on the event.
 *
 * @return {boolean} True if stopImmediatePropagation was called, false
 *     otherwise.
 */
Event.prototype.isImmediatePropagationStopped = function() {
  return this._immediateStopped;
};

/**
 * An EventEmitter is an object that can be listened to for events.
 *
 * Instances of this class are not usually used directly; instead, a class that
 * needs EventEmitter functionality would inherit from the EventEmitter class
 * so that it's instances can use events.
 *
 * @constructor
 * @alias module:spotify-eventemitter
 *
 * @example <caption>Direct usage</caption>
 * var EventEmitter = require('spotify-eventemitter');
 * var emitter = new EventEmitter();
 * emitter.addListener('someEvent', function() {
 *     console.log('someEvent fired!');
 * });
 * emitter.emit('someEvent');
 * @example <caption>Inheritance</caption>
 * var EventEmitter = require('spotify-eventemitter');
 * var inherit = require('spotify-inherit/inherit');
 *
 * function MyClass() {
 *   EventEmitter.call(this);
 * }
 * inherit(MyClass, EventEmitter);
 *
 * var instance = new MyClass();
 * instance.addListener('someEvent', function() {
 *     console.log('someEvent fired!');
 * });
 * instance.emit('someEvent');
 */
function EventEmitter() {
  /**
   * A map of event names to event handlers.
   *
   * @type {Object.<string, module:spotify-eventemitter~EventHandlers>}
   * @private
   */
  this._listenerMap;
}

/**
 * Creates a new Event object.
 *
 * @param {string} type The type name of the event.
 * @param {Object=} opt_params An object containing properties for the new event
 *     object.
 * @return {module:spotify-eventemitter~Event} The new event object.
 */
EventEmitter.createEvent = function(type, opt_params) {
  return new Event(type, opt_params);
};

/**
 * Adds an event listener to the emitter.
 *
 * This method is idempotent: calling it multiple times using the same type
 * and listener arguments will only set the listener once. This behaviour is
 * done to prevent accidental additions of the same event listener.
 *
 * @param {string} type The type of event to listen to.
 * @param {function} listener A function to be called when the emitter fires
 *     the event specified in the type.
 * @return {module:spotify-eventemitter} The event emitter.
 */
EventEmitter.prototype.addListener = function(type, listener) {
  var _listenerMap = this._listenerMap || (this._listenerMap = {});
  var listeners = _listenerMap[type] || (_listenerMap[type] = []);
  if (listeners.indexOf(listener) != -1) {
    // Handler already added, return quickly.
    return this;
  }
  listeners.push(listener);
  return this;
};

/**
 * Adds multiple event listeners to the emitter.
 *
 * @param {Object.<string, function>} eventListeners An object, the keys of
 *     which correspond to the name of events to listen to, and the value of
 *     each of these keys should be a function that would be added as the
 *     listener for that event.
 * @return {module:spotify-eventemitter} The event emitter.
 */
EventEmitter.prototype.addListeners = function(eventListeners) {
  for (var type in eventListeners) {
    this.addListener(type, eventListeners[type]);
  }
  return this;
};

/**
 * Adds a "once" event listener to the emitter, which will be removed right
 * after it has been fired.
 *
 * In order to achieve the "once" behaviour, the listener argument passed to
 * this method is wrapped in a function, which is then returned by the method.
 *
 * Because of this wrapping, this method is not idempotent: calling it multiple
 * times with the same type and listener arguments will result to multiple
 * event listeners attached.
 *
 * @param {string} type The type of event to listen to.
 * @param {function} listener A function to be called when the emitter fires
 *     the event specified in the type and then automatically removed.
 * @return {function} The function used to wrap the listener function argument.
 *     This function can be used as an argument to removeEvent.
 */
EventEmitter.prototype.addOnceListener = function(type, listener) {
  var wrapper = function() {
    this.removeListener(type, wrapper);
    return listener.apply(this, arguments);
  };
  this.addListener(type, wrapper);
  return wrapper;
};

/**
 * Removes an event listener from the emitter.
 *
 * @param {string} type The type of event to remove.
 * @param {function} listener The listener function to remove. This must be a
 *     function that was added previously using addEvent.
 * @return {module:spotify-eventemitter} The event emitter.
 */
EventEmitter.prototype.removeListener = function(type, listener) {
  var _listenerMap = this._listenerMap;
  var listeners = _listenerMap && _listenerMap[type];
  if (!listeners) {
    return this;
  }
  var index = listeners.indexOf(listener);
  if (index == -1) {
    return this;
  }
  listeners.splice(index, 1);
  if (!listeners.length) {
    _listenerMap[type] = null;
  }
  return this;
};

/**
 * Removes all event listeners from the emitter for a particular type.
 *
 * @param {string} type The event type to remove.
 * @return {module:spotify-eventemitter} The event emitter.
 */
EventEmitter.prototype.removeAllListeners = function(type) {
  var _listenerMap = this._listenerMap;
  if (!_listenerMap) {
    return this;
  }
  _listenerMap[type] = null;
  return this;
};

/**
 * Removes multiple event listeners from the emitter.
 *
 * @param {Object.<string, function>} eventListeners An object, the keys of
 *     which correspond to the name of events to listen to, and the value of
 *     each of these keys should be a function that would be added as the
 *     listener for that event.
 * @return {module:spotify-eventemitter} The event emitter.
 */
EventEmitter.prototype.removeListeners = function(eventListeners) {
  for (var type in eventListeners) {
    this.removeListener(type, eventListeners[type]);
  }
  return this;
};

/**
 * Creates and emits an event on the emitter.
 *
 * This method invokes all the added event listeners of the `type` provided in
 * the order they were added, passing in a new Event object created using the
 * provided `type` and `opt_params` arguments.
 *
 * This method emits events asynchronously: the listeners are not called until
 * the next run loop.
 *
 * @param {string} type The type name of the event to emit.
 * @param {Object=} opt_params An object containing parameters for the Event
 *     object.
 * @return {module:spotify-eventemitter~Event} The Event object that was
 *     created.
 */
EventEmitter.prototype.emit = function(type, opt_params) {
  var event = new Event(type, opt_params);
  _defer(function() {
    this.emitEventSync(event);
  }.bind(this));
  return event;
};

/**
 * Emits an event on the emitter.
 *
 * This method invokes all the added event listeners of the `type` of the 
 * `event` provided in the order they were added, passing in the `event` as an
 * argument.
 *
 * This method emits events asynchronously: the listeners are not called until
 * the next run loop.
 *
 * @param {module:spotify-eventemitter~Event} event The Event object.
 * @return {module:spotify-eventemitter~Event} The Event object that was passed.
 */
EventEmitter.prototype.emitEvent = function(event) {
  _defer(function() {
    this.emitEventSync(event);
  }.bind(this));
  return event;
};

/**
 * Creates and synchronously emits an event on the emitter.
 *
 * This method invokes all the added event listeners of the `type` provided in
 * the order they were added, passing in a new Event object created using the
 * provided `type` and `opt_params` arguments.
 *
 * @param {string} type The type name of event to emit.
 * @param {Object=} opt_params An object containing parameters for the event
 *     object.
 * @return {module:spotify-eventemitter~Event} The Event object that was
 *     created.
 */
EventEmitter.prototype.emitSync = function(type, opt_params) {
  var event = new Event(type, opt_params);
  this.emitEventSync(event);
  return event;
};

/**
 * Synchronously emits an event on the emitter.
 *
 * This method invokes all the added event listeners of the `type` of the
 * `event` provided in the order they were added, passing in the `event` as an
 * argument.
 *
 * @param {module:spotify-eventemitter~Event} event The Event object.
 * @return {module:spotify-eventemitter~Event} The Event object that was passed.
 */
EventEmitter.prototype.emitEventSync = function(event) {
  var type = event.type;
  var _listenerMap = this._listenerMap;
  var listeners = _listenerMap && _listenerMap[type];
  if (!listeners || !listeners.length) {
    return event;
  }
  listeners = listeners.slice(0);
  for (var i = 0, l = listeners.length; i < l; i++) {
    listeners[i].call(this, event);
    if (event.isImmediatePropagationStopped()) {
      break;
    }
  }
  return event;
};

// DEPRECATED METHODS:

/**
 * Adds an event listener to the emitter.
 *
 * **NOTE**: This method has been deprecated in favor of
 * {@link module:spotify-eventemitter#addListener}.
 *
 * This method is idempotent: calling it multiple times using the same type
 * and listener arguments will only set the listener once. This behaviour is
 * done to prevent accidental additions of the same event listener.
 *
 * @deprecated since v2.0.0.
 * @param {string} type The type of event to listen to.
 * @param {function} listener A function to be called when the emitter fires
 *     the event specified in the type.
 * @return {module:spotify-eventemitter} The event emitter.
 * @see {@link module:spotify-eventemitter#addListener}
 */
EventEmitter.prototype.addEvent = function(type, listener) {
  return this.addListener(type, listener);
};

/**
 * Adds multiple event listeners to the emitter.
 *
 * **NOTE**: This method has been deprecated in favor of
 * {@link module:spotify-eventemitter#addListeners}.
 *
 * @deprecated since v2.0.0.
 * @param {Object.<string, function>} eventListeners An object, the keys of
 *     which correspond to the name of events to listen to, and the value of
 *     each of these keys should be a function that would be added as the
 *     listener for that event.
 * @return {module:spotify-eventemitter} The event emitter.
 * @see {@link module:spotify-eventemitter#addListeners}
 */
EventEmitter.prototype.addEvents = function(eventListeners) {
  return this.addListeners(eventListeners);
};

/**
 * Adds a "once" event listener to the emitter, which will be removed right
 * after it has been fired.
 *
 * **NOTE**: This method has been deprecated in favor of
 * {@link module:spotify-eventemitter#addOnceListener}.
 *
 * In order to achieve the "once" behaviour, the listener argument passed to
 * this method is wrapped in a function, which is then returned by the method.
 *
 * Because of this wrapping, this method is not idempotent: calling it multiple
 * times with the same type and listener arguments will result to multiple
 * event listeners attached.
 *
 * @deprecated since v2.0.0.
 * @param {string} type The type of event to listen to.
 * @param {function} listener A function to be called when the emitter fires
 *     the event specified in the type and then automatically removed.
 * @return {function} The function used to wrap the listener function argument.
 *     This function can be used as an argument to removeEvent.
 * @see {@link module:spotify-eventemitter#addOnceListener}
 */
EventEmitter.prototype.addOnceEvent = function(type, listener) {
  return this.addOnceListener(type, listener);
};

/**
 * Removes an event listener from the emitter.
 *
 * **NOTE**: This method has been deprecated in favor of
 * {@link module:spotify-eventemitter#removeListener}.
 *
 * @deprecated since v2.0.0.
 * @param {string} type The type of event to remove.
 * @param {function} listener The listener function to remove. This must be a
 *     function that was added previously using addEvent.
 * @return {module:spotify-eventemitter} The event emitter.
 * @see {@link module:spotify-eventemitter#removeListener}
 */
EventEmitter.prototype.removeEvent = function(type, listener) {
  return this.removeListener(type, listener);
};

/**
 * Removes multiple event listeners from the emitter.
 *
 * **NOTE**: This method has been deprecated in favor of
 * {@link module:spotify-eventemitter#removeListeners}.
 *
 * @deprecated since v2.0.0.
 * @param {Object.<string, function>} events An object, the keys of which
 *     correspond to the name of events to remove, and the value of each of
 *     these keys should be a function that would be removed as a listener.
 * @return {module:spotify-eventemitter} The event emitter.
 * @see {@link module:spotify-eventemitter#removeListeners}
 */
EventEmitter.prototype.removeEvents = function(eventListeners) {
  return this.removeListeners(eventListeners);
};

/**
 * Fires an event on the emitter, optionally passing arguments to the listeners.
 *
 * **NOTE**: This method has been deprecated in favor of
 * {@link module:spotify-eventemitter#emit}.
 *
 * This method fire events asynchronously: the listeners are not called until
 * the next run loop. A third boolean parameter can be passed to change this
 * behaviour.
 *
 * @deprecated since v2.0.0.
 * @param {string} type The type of event to fire.
 * @param {Array.<*>=} opt_args A set of objects that would be passed to the
 *     event listeners as arguments.
 * @param {boolean=} opt_priority Passing true will fire the event synchronously.
 * @return {module:spotify-eventemitter} The event emitter.
 * @see {@link module:spotify-eventemitter#emit}
 */
EventEmitter.prototype.fireEvent = function(type, opt_args, opt_priority) {
  if (opt_priority) {
    this.fireEventSync(type, opt_args);
  } else {
    var self = this;
    _defer(function() { self.fireEventSync(type, opt_args); });
  }
  return this;
};

/**
 * Fires an event on the emitter synchronously, optionally passing arguments to
 * the listeners.
 *
 * **NOTE**: This method has been deprecated in favor of
 * {@link module:spotify-eventemitter#emitSync}.
 *
 * @deprecated since v2.0.0.
 * @param {string} type The type of event to fire.
 * @param {Array.<*>=} opt_args A set of objects that would be passed to the
 *     event listeners as arguments.
 * @return {module:spotify-eventemitter} The event emitter.
 * @see {@link module:spotify-eventemitter#emitSync}
 */
EventEmitter.prototype.fireEventSync = function(type, opt_args) {
  var self = this;
  var events = this._listenerMap && this._listenerMap[type];
  if (!events || !events.length) return this;
  events = events.slice(0);
  var i, l;
  if (!opt_args) {
    for (i = 0, l = events.length; i < l; i++) {
      events[i].call(self);
    }
  } else {
    if (!Array.isArray(opt_args)) {
      opt_args = [opt_args];
    }
    for (i = 0, l = events.length; i < l; i++) {
      events[i].apply(self, opt_args);
    }
  }
  return this;
};

/**
 * Adds an event listener to the emitter.
 *
 * **NOTE**: This method has been deprecated in favor of
 * {@link module:spotify-eventemitter#addListener}.
 *
 * This method is idempotent: calling it multiple times using the same type
 * and listener arguments will only set the listener once. This behaviour is
 * done to prevent accidental additions of the same event listener.
 *
 * @deprecated since v2.0.0.
 * @param {string} type The type of event to listen to.
 * @param {function} listener A function to be called when the emitter fires
 *     the event specified in the type.
 * @return {module:spotify-eventemitter} The event emitter.
 * @see {@link module:spotify-eventemitter#addListener}
 */
EventEmitter.prototype.on = function(type, listener) {
  return this.addEvent(type, listener);
};

/**
 * Adds a "once" event listener to the emitter, which will be removed right
 * after it has been fired.
 *
 * **NOTE**: This method has been deprecated in favor of
 * {@link module:spotify-eventemitter#addOnceListener}.
 *
 * In order to achieve the "once" behaviour, the listener argument passed to
 * this method is wrapped in a function, which is then returned by the method.
 *
 * Because of this wrapping, this method is not idempotent: calling it multiple
 * times with the same type and listener arguments will result to multiple
 * event listeners attached.
 *
 * @deprecated since v2.0.0.
 * @param {string} type The type of event to listen to.
 * @param {function} listener A function to be called when the emitter fires
 *     the event specified in the type and then automatically removed.
 * @return {function} The function used to wrap the listener function argument.
 *     This function can be used as an argument to removeEvent.
 * @see {@link module:spotify-eventemitter#addOnceListener}
 */
EventEmitter.prototype.once = function(type, listener) {
  return this.addOnceEvent(type, listener);
};

/**
 * Removes an event listener or all event listeners from the emitter.
 *
 * **NOTE**: This method has been deprecated in favor of
 * {@link module:spotify-eventemitter#removeListener}.
 *
 * @deprecated since v2.0.0.
 * @param {string} type The type of event to remove.
 * @param {function=} opt_listener The listener function to remove. This must be
 *     a function that was added previously using addEvent. If this parameter is
 *     not given, all event listeners of the corresponding `type` argument will
 *     be removed.
 * @return {module:spotify-eventemitter} The event emitter.
 * @see {@link module:spotify-eventemitter#removeListener}
 * @see {@link module:spotify-eventemitter#removeListeners}
 */
EventEmitter.prototype.off = function(type, opt_listener) {
  if (typeof opt_listener === 'function') {
    return this.removeEvent(type, opt_listener);
  }
  // if no listener set, remove all the listeners from the event
  this._listenerMap[type] = null;
  return this;
};

/**
 * Exporting
 */
module.exports = EventEmitter;

},{"spotify-deferred":421}],423:[function(require,module,exports){
'use strict';

/**
 * Function to add properties to an object
 * @param {Object} obj The input object
 * @param {Object} args The objects which are going to be injected
 * @return {Object} The extended object
 */
var extend = function(obj, args) {
  var source;

  for (var i = 1; i < arguments.length; i++) {
    source = arguments[i];
    if (source) {
      for (var prop in source) {
        if (source.hasOwnProperty(prop)) {
          obj[prop] = source[prop];
        }
      }
    }
  }
  return obj;
};


/**
 * Export public interface
 */
module.exports = extend;

},{}],424:[function(require,module,exports){
'use strict';

module.exports = {
  inherit: require('./inherit'),
  extend: require('./extend')
};

},{"./extend":423,"./inherit":425}],425:[function(require,module,exports){
'use strict';

/**
 * Makes a class inherit from a superclass' prototype indirectly.
 *
 * @param {Spotify.ClassLike} Sub The class that will inherit.
 * @param {Spotify.ClassLike} Super The class to inherit from.
 */
var inherit = function(Sub, Super) {
  var superProto = Super.prototype;
  function Superclass() {}
  Superclass.prototype = Sub._super = superProto;
  Superclass.prototype.constructor = Super;
  Sub.prototype = new Superclass();
};


/**
 * Export public interface
 */
module.exports = inherit;

},{}],426:[function(require,module,exports){
'use strict';

/**
 * @private
 */
var Base62 = require('spotify-crypto/src/base62');

/**
 * The URI prefix for URIs.
 *
 * @const
 * @private
 */
var URI_PREFIX = 'spotify:';

/**
 * The URL prefix for Play.
 *
 * @const
 * @private
 */
var PLAY_HTTP_PREFIX = 'http://play.spotify.com/';

/**
 * The HTTPS URL prefix for Play.
 *
 * @const
 * @private
 */
var PLAY_HTTPS_PREFIX = 'https://play.spotify.com/';

/**
 * The URL prefix for Open.
 *
 * @const
 * @private
 */
var OPEN_HTTP_PREFIX = 'http://open.spotify.com/';

/**
 * The HTTPS URL prefix for Open.
 *
 * @const
 * @private
 */
var OPEN_HTTPS_PREFIX = 'https://open.spotify.com/';

var ERROR_INVALID = new TypeError('Invalid Spotify URI!');
var ERROR_NOT_IMPLEMENTED = new TypeError('Not implemented!');


/**
 * The format for the URI to parse.
 *
 * @enum {number}
 * @private
 */
var Format = {
  URI: 0,
  URL: 1
};

/**
 * Represents the result of a URI splitting operation.
 *
 * @typedef {{
 *    format: Format,
 *    components: Array.<string>
 * }}
 * @see _splitIntoComponents
 * @private
 */
var SplittedURI;

/**
 * Split an string URI or HTTP/HTTPS URL into components, skipping the prefix.
 *
 * @param {string} str A string URI to split.
 * @return {SplittedURI} The parsed URI.
 * @private
 */
var _splitIntoComponents = function(str) {
  var components;
  var format;
  var anchor;

  var hashSplit = str.split('#');

  if (hashSplit.length > 1) {
    // first token
    str = hashSplit.shift();
    // last token
    anchor = hashSplit.pop();
  }

  if (str.indexOf(URI_PREFIX) === 0) {
    components = str.slice(URI_PREFIX.length).split(':');
    format = Format.URI;
  } else {
    // For HTTP URLs, ignore any query string argument
    str = str.split('?')[0];

    if (str.indexOf(PLAY_HTTP_PREFIX) === 0) {
      components = str.slice(PLAY_HTTP_PREFIX.length).split('/');
    } else if (str.indexOf(PLAY_HTTPS_PREFIX) === 0) {
      components = str.slice(PLAY_HTTPS_PREFIX.length).split('/');
    } else if (str.indexOf(OPEN_HTTP_PREFIX) === 0) {
      components = str.slice(OPEN_HTTP_PREFIX.length).split('/');
    } else if (str.indexOf(OPEN_HTTPS_PREFIX) === 0) {
      components = str.slice(OPEN_HTTPS_PREFIX.length).split('/');
    } else {
      throw ERROR_INVALID;
    }
    format = Format.URL;
  }

  if (anchor) {
    components.push(anchor);
  }

  return {
    format: format,
    components: components
  };
};

/**
 * Encodes a component according to a format.
 *
 * @param {string} component A component string.
 * @param {Format} format A format.
 * @return {string} An encoded component string.
 * @private
 */
var _encodeComponent = function(component, format) {
  component = encodeURIComponent(component);
  if (format === Format.URI) {
    component = component.replace(/%20/g, '+');
  }

  // encode characters that are not encoded by default by encodeURIComponent
  // but that the Spotify URI spec encodes: !'*()
  component = component.replace(/[!'()]/g, escape);
  component = component.replace(/\*/g, '%2A');

  return component;
};

/**
 * Decodes a component according to a format.
 *
 * @param {string} component An encoded component string.
 * @param {Format} format A format.
 * @return {string} An decoded component string.
 * @private
 */
var _decodeComponent = function(component, format) {
  var part = format == Format.URI ? component.replace(/\+/g, '%20') : component;
  return decodeURIComponent(part);
};

/**
 * Returns the components of a URI as an array.
 *
 * @param {URI} uri A uri.
 * @param {Format} format The output format.
 * @return {Array.<string>} An array of uri components.
 * @private
 */
var _getComponents = function(uri, format) {
  var base62;
  if (uri.id) {
    base62 = uri._base62Id;
  }

  var components;
  var i;
  var len;
  switch (uri.type) {
    case URI.Type.ALBUM:
      components = [URI.Type.ALBUM, base62];
      if (uri.disc) {
        components.push(uri.disc);
      }
      return components;
    case URI.Type.AD:
      return [URI.Type.AD, uri._base62Id];
    case URI.Type.ARTIST:
      return [URI.Type.ARTIST, base62];
    case URI.Type.ARTIST_TOPLIST:
      return [URI.Type.ARTIST, base62, URI.Type.TOP, uri.toplist];
    case URI.Type.SEARCH:
      return [URI.Type.SEARCH, _encodeComponent(uri.query, format)];
    case URI.Type.TRACK:
      if (uri.anchor) {
        base62 += '#' + uri.anchor;
      }
      return [URI.Type.TRACK, base62];
    case URI.Type.TRACKSET:
      var trackIds = [];
      for (i = 0, len = uri.tracks.length; i < len; i++) {
        trackIds.push(uri.tracks[i]._base62Id);
      }
      trackIds = [trackIds.join(',')];
      // Index can be 0 sometimes (required for trackset)
      if (uri.index !== null) {
        trackIds.push('#', uri.index);
      }
      return [URI.Type.TRACKSET, _encodeComponent(uri.name)].concat(trackIds);
    case URI.Type.FACEBOOK:
      return [URI.Type.USER, URI.Type.FACEBOOK, uri.uid];
    case URI.Type.AUDIO_FILE:
      return [URI.Type.AUDIO_FILE, uri.extension, uri._base62Id];
    case URI.Type.FOLDER:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.FOLDER, uri._base62Id];
    case URI.Type.FOLLOWERS:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.FOLLOWERS];
    case URI.Type.FOLLOWING:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.FOLLOWING];
    case URI.Type.PLAYLIST:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.PLAYLIST, base62];
    case URI.Type.STARRED:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.STARRED];
    case URI.Type.TEMP_PLAYLIST:
      return [URI.Type.TEMP_PLAYLIST, uri.origin, uri.data];
    case URI.Type.CONTEXT_GROUP:
      return [URI.Type.CONTEXT_GROUP, uri.origin, uri.name];
    case URI.Type.USER_TOPLIST:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.TOP, uri.toplist];
    // Legacy Toplist
    case URI.Type.USER_TOP_TRACKS:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.TOPLIST];
    case URI.Type.TOPLIST:
      return [URI.Type.TOP, uri.toplist].concat(uri.global ? [URI.Type.GLOBAL] : ['country', uri.country]);
    case URI.Type.INBOX:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.INBOX];
    case URI.Type.ROOTLIST:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.ROOTLIST];
    case URI.Type.PUBLISHED_ROOTLIST:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.PUBLISHED_ROOTLIST];
    case URI.Type.COLLECTION_TRACK_LIST:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.COLLECTION_TRACK_LIST, base62];
    case URI.Type.PROFILE:
      if (uri.args && uri.args.length > 0)
        return [URI.Type.USER, _encodeComponent(uri.username, format)].concat(uri.args);
      return [URI.Type.USER, _encodeComponent(uri.username, format)];
    case URI.Type.LOCAL_ARTIST:
      return [URI.Type.LOCAL, _encodeComponent(uri.artist, format)];
    case URI.Type.LOCAL_ALBUM:
      return [URI.Type.LOCAL, _encodeComponent(uri.artist, format), _encodeComponent(uri.album, format)];
    case URI.Type.LOCAL:
      return [URI.Type.LOCAL,
        _encodeComponent(uri.artist, format),
        _encodeComponent(uri.album, format),
        _encodeComponent(uri.track, format),
        uri.duration];
    case URI.Type.LIBRARY:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.LIBRARY].concat(uri.category ? [uri.category] : []);
    case URI.Type.IMAGE:
      return [URI.Type.IMAGE, uri._base62Id];
    case URI.Type.MOSAIC:
      components = uri.ids.slice(0);
      components.unshift(URI.Type.MOSAIC);
      return components;
    case URI.Type.RADIO:
      return [URI.Type.RADIO, uri.args];
    case URI.Type.SPECIAL:
      components = [URI.Type.SPECIAL];
      var args = uri.args || [];
      for (i = 0, len = args.length; i < len; ++i)
        components.push(_encodeComponent(args[i], format));
      return components;
    case URI.Type.STATION:
      components = [URI.Type.STATION];
      var args = uri.args || [];
      for (i = 0, len = args.length; i < len; i++) {
        components.push(_encodeComponent(args[i], format));
      }
      return components;
    case URI.Type.APPLICATION:
      components = [URI.Type.APP, uri._base62Id];
      var args = uri.args || [];
      for (i = 0, len = args.length; i < len; ++i)
        components.push(_encodeComponent(args[i], format));
      return components;
    case URI.Type.COLLECTION_ALBUM:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.COLLECTION, URI.Type.ALBUM, base62];
    case URI.Type.COLLECTION_MISSING_ALBUM:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.COLLECTION, URI.Type.ALBUM, base62, 'missing'];
    case URI.Type.COLLECTION_ARTIST:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.COLLECTION, URI.Type.ARTIST, base62];
    case URI.Type.COLLECTION:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.COLLECTION].concat(uri.category ? [uri.category] : []);
    case URI.Type.EPISODE:
      return [URI.Type.EPISODE, base62];
    default:
      throw ERROR_INVALID;
  }
};

/**
 * Parses the components of a URI into a real URI object.
 *
 * @param {Array.<string>} components The components of the URI as a string
 *     array.
 * @param {Format} format The format of the source string.
 * @return {URI} The URI object.
 * @private
 */
var _parseFromComponents = function(components, format) {
  var _current = 0;

  var _getNextComponent = function() {
    return components[_current++];
  };

  var _getIdComponent = function() {
    var component = _getNextComponent();

    if (component.length > 22) {
      throw new Error('Invalid ID');
    }
    return component;
  };

  var _getRemainingComponents = function() {
    return components.slice(_current);
  };

  var _getRemainingString = function() {
    var separator = (format == Format.URI) ? ':' : '/';
    return components.slice(_current).join(separator);
  };

  var part = _getNextComponent();
  var id;
  var i;
  var len;

  switch (part) {
    case URI.Type.ALBUM:
      return URI.albumURI(_getIdComponent(), parseInt(_getNextComponent(), 10));
    case URI.Type.AD:
      return URI.adURI(_getNextComponent());
    case URI.Type.ARTIST:
      id = _getIdComponent();
      if (_getNextComponent() == URI.Type.TOP) {
        return URI.artistToplistURI(id, _getNextComponent());
      } else {
        return URI.artistURI(id);
      }
    case URI.Type.AUDIO_FILE:
      return URI.audioFileURI(_getNextComponent(), _getNextComponent());
    case URI.Type.TEMP_PLAYLIST:
      return URI.temporaryPlaylistURI(_getNextComponent(), _getRemainingString());
    case URI.Type.SEARCH:
      return URI.searchURI(_decodeComponent(_getRemainingString(), format));
    case URI.Type.TRACK:
      return URI.trackURI(_getIdComponent(), _getNextComponent());
    case URI.Type.TRACKSET:
      var name = _decodeComponent(_getNextComponent());
      var tracksArray = _getNextComponent();
      var hashSign = _getNextComponent();
      var index = parseInt(_getNextComponent(), 10);
      // Sanity check: %23 is URL code for "#"
      if (hashSign !== '%23' || isNaN(index)) {
        index = null;
      }
      var tracksetTracks = [];
      if (tracksArray) {
        tracksArray = _decodeComponent(tracksArray).split(',');
        for (i = 0, len = tracksArray.length; i < len; i++) {
          var trackId = tracksArray[i];
          tracksetTracks.push(URI.trackURI(trackId));
        }
      }
      return URI.tracksetURI(tracksetTracks, name, index);
    case URI.Type.CONTEXT_GROUP:
      return URI.contextGroupURI(_getNextComponent(), _getNextComponent());
    case URI.Type.TOP:
      var type = _getNextComponent();
      if (_getNextComponent() == URI.Type.GLOBAL) {
        return URI.toplistURI(type, null, true);
      } else {
        return URI.toplistURI(type, _getNextComponent(), false);
      }
    case URI.Type.USER:
      var username = _decodeComponent(_getNextComponent(), format);
      var text = _getNextComponent();
      if (username == URI.Type.FACEBOOK && text != null) {
        return URI.facebookURI(parseInt(text, 10));
      } else if (text != null) {
        switch (text) {
          case URI.Type.PLAYLIST:
            return URI.playlistURI(username, _getIdComponent());
          case URI.Type.FOLDER:
            return URI.folderURI(username, _getIdComponent());
          case URI.Type.COLLECTION_TRACK_LIST:
            return URI.collectionTrackList(username, _getIdComponent());
          case URI.Type.COLLECTION:
            var collectionItemType = _getNextComponent();
            switch (collectionItemType) {
              case URI.Type.ALBUM:
                id = _getIdComponent();
                if (_getNextComponent() === 'missing') {
                  return URI.collectionMissingAlbumURI(username, id);
                } else {
                  return URI.collectionAlbumURI(username, id);
                }
              case URI.Type.ARTIST:
                return URI.collectionArtistURI(username, _getIdComponent());
              default:
                return URI.collectionURI(username, collectionItemType);
            }
          case URI.Type.STARRED:
            return URI.starredURI(username);
          case URI.Type.FOLLOWERS:
            return URI.followersURI(username);
          case URI.Type.FOLLOWING:
            return URI.followingURI(username);
          case URI.Type.TOP:
            return URI.userToplistURI(username, _getNextComponent());
          case URI.Type.INBOX:
            return URI.inboxURI(username);
          case URI.Type.ROOTLIST:
            return URI.rootlistURI(username);
          case URI.Type.PUBLISHED_ROOTLIST:
            return URI.publishedRootlistURI(username);
          case URI.Type.TOPLIST:
            // legacy toplist
            return URI.userTopTracksURI(username);
          case URI.Type.LIBRARY:
            return URI.libraryURI(username, _getNextComponent());
        }
      }
      var rem = _getRemainingComponents();
      if (text != null && rem.length > 0) {
        return URI.profileURI(username, [text].concat(rem));
      } else if (text != null) {
        return URI.profileURI(username, [text]);
      } else {
        return URI.profileURI(username);
      }
    case URI.Type.LOCAL:
      var artistNameComponent = _getNextComponent();
      var artistName = artistNameComponent && _decodeComponent(artistNameComponent, format);
      var albumNameComponent = _getNextComponent();
      var albumName = albumNameComponent && _decodeComponent(albumNameComponent, format);
      var trackNameComponent = _getNextComponent();
      var trackName = trackNameComponent && _decodeComponent(trackNameComponent, format);
      var durationComponent = _getNextComponent();
      var duration = parseInt(durationComponent, 10);
      if (trackNameComponent !== undefined) {
        return URI.localURI(artistName, albumName, trackName, duration);
      } else if (albumNameComponent !== undefined) {
        return URI.localAlbumURI(artistName, albumName);
      } else {
        return URI.localArtistURI(artistName);
      }
    case URI.Type.IMAGE:
      return URI.imageURI(_getIdComponent());
    case URI.Type.MOSAIC:
      return URI.mosaicURI(components.slice(_current));
    case URI.Type.RADIO:
      return URI.radioURI(_getRemainingString());
    case URI.Type.SPECIAL:
      var args = _getRemainingComponents();
      for (i = 0, len = args.length; i < len; ++i)
        args[i] = _decodeComponent(args[i], format);
      return URI.specialURI(args);
    case URI.Type.STATION:
      return URI.stationURI(_getRemainingComponents());
    case URI.Type.EPISODE:
      return URI.episodeURI(_getIdComponent());
    default:
      if (part === URI.Type.APP) {
        id = _getNextComponent();
      } else {
        id = part;
      }
      var args = _getRemainingComponents();
      for (i = 0, len = args.length; i < len; ++i)
        args[i] = _decodeComponent(args[i], format);
      return URI.applicationURI(id, args);
  }

  throw ERROR_INVALID;
};

/**
 * A class holding information about a uri.
 *
 * @constructor
 * @param {URI.Type} type The uri type.
 * @param {Object} props The uri properties.
 */
function URI(type, props) {
  /**
   * The uri type.
   *
   * @type {string}
   */
  this.type = type;

  // Merge properties into URI object.
  for (var prop in props) {
    if (typeof props[prop] == 'function') {
      continue;
    }
    this[prop] = props[prop];
  }
}

// Lazy convert the id to hexadecimal only when requested
Object.defineProperty(URI.prototype, 'id', {
  get: function() {
    if (!this._hexId) {
      this._hexId = this._base62Id ? URI.idToHex(this._base62Id) : undefined;
    }
    return this._hexId;
  },
  set: function(id) {
    this._base62Id = id ? URI.hexToId(id) : undefined;
    this._hexId = undefined;
  },
  enumerable: true,
  configurable: true
});

/**
 * Creates an application URI object from the current URI object.
 *
 * If the current URI object is already an application type, a copy is made.
 *
 * @return {URI} The current URI as an application URI.
 */
URI.prototype.toAppType = function() {
  if (this.type == URI.Type.APPLICATION) {
    return URI.applicationURI(this.id, this.args);
  } else {
    var components = _getComponents(this, Format.URL);
    var id = components.shift();
    var len = components.length;
    if (len) {
      while (len--) {
        components[len] = _decodeComponent(components[len], Format.URL);
      }
    }
    if (this.type == URI.Type.RADIO) {
      components = components.shift().split(':');
    }
    var result = URI.applicationURI(id, components);
    return result;
  }
};

/**
 * Creates a URI object from an application URI object.
 *
 * If the current URI object is not an application type, a copy is made.
 *
 * @return {URI} The current URI as a real typed URI.
 */
URI.prototype.toRealType = function() {
  if (this.type == URI.Type.APPLICATION) {
    return _parseFromComponents([this.id].concat(this.args), Format.URI);
  } else {
    return new URI(null, this);
  }
};

/**
 * Returns the URI representation of this URI.
 *
 * @return {String} The URI representation of this uri.
 */
URI.prototype.toURI = function() {
  return URI_PREFIX + _getComponents(this, Format.URI).join(':');
};

/**
 * Returns the String representation of this URI.
 *
 * @return {String} The URI representation of this uri.
 * @see {URI#toURI}
 */
URI.prototype.toString = function() {
  return this.toURI();
};

/**
 * Get the URL path of this uri.
 *
 * @param {boolean} opt_leadingSlash True if a leading slash should be prepended.
 * @return {String} The path of this uri.
 */
URI.prototype.toURLPath = function(opt_leadingSlash) {
  var components = _getComponents(this, Format.URL);
  if (components[0] === URI.Type.APP) {
    components.shift();
  }

  // Some URIs are allowed to have empty components. It should be investigated
  // whether we need to strip empty components at all from any URIs. For now,
  // we check specifically for tracksets and local tracks and strip empty
  // components for all other URIs.
  //
  // For tracksets, it's permissible to have a path that looks like
  // 'trackset//trackURI' because the identifier parameter for a trackset can
  // be blank. For local tracks, some metadata can be missing, like missing
  // album name would be 'spotify:local:artist::track:duration'.
  var isTrackset = components[0] === URI.Type.TRACKSET;
  var isLocalTrack = components[0] === URI.Type.LOCAL;
  var shouldStripEmptyComponents = !isTrackset && !isLocalTrack;

  if (shouldStripEmptyComponents) {
    var _temp = [];
    for (var i = 0, l = components.length; i < l; i++) {
      var component = components[i];
      if (!!component) {
        _temp.push(component);
      }
    }
    components = _temp;
  }
  var path = components.join('/');
  return opt_leadingSlash ? '/' + path : path;
};

/**
 * Returns the Play URL string for the uri.
 *
 * @return {string} The Play URL string for the uri.
 */
URI.prototype.toPlayURL = function() {
    return PLAY_HTTPS_PREFIX + this.toURLPath();
};

/**
 * Returns the URL string for the uri.
 *
 * @return {string} The URL string for the uri.
 * @see {URL#toPlayURL}
 */
URI.prototype.toURL = function() {
  return this.toPlayURL();
};

/**
 * Returns the Open URL string for the uri.
 *
 * @return {string} The Open URL string for the uri.
 */
URI.prototype.toOpenURL = function() {
  return OPEN_HTTPS_PREFIX + this.toURLPath();
};

/**
 * Returns the Play HTTPS URL string for the uri.
 *
 * @return {string} The Play HTTPS URL string for the uri.
 */
URI.prototype.toSecurePlayURL = function() {
    return this.toPlayURL();
};

/**
 * Returns the HTTPS URL string for the uri.
 *
 * @return {string} The HTTPS URL string for the uri.
 * @see {URL#toSecurePlayURL}
 */
URI.prototype.toSecureURL = function() {
  return this.toPlayURL();
};

/**
 * Returns the Open HTTPS URL string for the uri.
 *
 * @return {string} The Open HTTPS URL string for the uri.
 */
URI.prototype.toSecureOpenURL = function() {
  return this.toOpenURL();
};

/**
 * Returns the id of the uri as a bytestring.
 *
 * @return {Array} The id of the uri as a bytestring.
 */
URI.prototype.idToByteString = function() {
  var data = Base62.toBytes(this._base62Id);
  data = data.map(function(i) {
    return String.fromCharCode(i);
  }).join('');
  while (data.length < 16) {
    data = String.fromCharCode(0) + data;
  }
  return data;
};

/**
 * The various URI Types.
 *
 * Note that some of the types in this enum are not real URI types, but are
 * actually URI particles. They are marked so.
 *
 * @enum {string}
 */
URI.Type = {
  EMPTY: 'empty',
  ALBUM: 'album',
  AD: 'ad',
  /** URI particle; not an actual URI. */
  APP: 'app',
  APPLICATION: 'application',
  ARTIST: 'artist',
  ARTIST_TOPLIST: 'artist-toplist',
  AUDIO_FILE: 'audiofile',
  COLLECTION: 'collection',
  COLLECTION_ALBUM: 'collection-album',
  COLLECTION_MISSING_ALBUM: 'collection-missing-album',
  COLLECTION_ARTIST: 'collection-artist',
  CONTEXT_GROUP: 'context-group',
  EPISODE: 'episode',
  /** URI particle; not an actual URI. */
  FACEBOOK: 'facebook',
  FOLDER: 'folder',
  FOLLOWERS: 'followers',
  FOLLOWING: 'following',
  /** URI particle; not an actual URI. */
  GLOBAL: 'global',
  IMAGE: 'image',
  INBOX: 'inbox',
  LOCAL_ARTIST: 'local-artist',
  LOCAL_ALBUM: 'local-album',
  LOCAL: 'local',
  LIBRARY: 'library',
  MOSAIC: 'mosaic',
  PLAYLIST: 'playlist',
  PROFILE: 'profile',
  PUBLISHED_ROOTLIST: 'published-rootlist',
  RADIO: 'radio',
  ROOTLIST: 'rootlist',
  COLLECTION_TRACK_LIST: 'collectiontracklist',
  SEARCH: 'search',
  SPECIAL: 'special',
  STARRED: 'starred',
  STATION: 'station',
  TEMP_PLAYLIST: 'temp-playlist',
  /** URI particle; not an actual URI. */
  TOP: 'top',
  TOPLIST: 'toplist',
  TRACK: 'track',
  TRACKSET: 'trackset',
  /** URI particle; not an actual URI. */
  USER: 'user',
  USER_TOPLIST: 'user-toplist',
  USER_TOP_TRACKS: 'user-top-tracks',
  /** Deprecated contant. Please use USER_TOP_TRACKS. */
  USET_TOP_TRACKS: 'user-top-tracks'
};

/**
 * Creates a new URI object from a parsed string argument.
 *
 * @param {string} str The string that will be parsed into a URI object.
 * @throws TypeError If the string argument is not a valid URI, a TypeError will
 *     be thrown.
 * @return {URI} The parsed URI object.
 */
URI.fromString = function(str) {
  var splitted = _splitIntoComponents(str);
  return _parseFromComponents(splitted.components, splitted.format);
};

/**
 * Parses a given object into a URI instance.
 *
 * Unlike URI.fromString, this function could receive any kind of value. If
 * the value is already a URI instance, it is simply returned.
 * Otherwise the value will be stringified before parsing.
 *
 * This function also does not throw an error like URI.fromString, but
 * instead simply returns null if it can't parse the value.
 *
 * @param {*} value The value to parse.
 * @return {URI?} The corresponding URI instance, or null if the
 *     passed value is not a valid value.
 */
URI.from = function(value) {
  try {
    if (value instanceof URI) {
      return value;
    }
    if (typeof value == 'object' && value.type) {
      return new URI(null, value);
    }
    return URI.fromString(value.toString());
  } catch(e) {
    return null;
  }
};

/**
 * Creates a new URI from a bytestring.
 *
 * @param {URI.Type} type The type of the URI.
 * @param {ByteString} idByteString The ID of the URI as a bytestring.
 * @param {Object} opt_args Optional arguments to the URI constructor.
 * @return {URI} The URI object created.
 */
URI.fromByteString = function(type, idByteString, opt_args) {
  var bytes = [];
  for (var i = 0; i < idByteString.length; i++) {
    bytes.push(idByteString.charCodeAt(i));
  }
  var id = Base62.fromBytes(bytes, 22);
  var args = opt_args || {};
  args.id = id;
  return new URI(type, args);
};

/**
 * Clones a given SpotifyURI instance.
 *
 * @param {URI} uri The uri to clone.
 * @return {URI?} An instance of URI.
 */
URI.clone = function(uri) {
  if (!(uri instanceof URI)) {
    return null;
  }
  return new URI(null, uri);
};

/**
 * @deprecated
 */
URI.getCanonical = function(username) {
  return this.getCanonical(username);
};

/**
 * Returns the canonical representation of a username.
 *
 * @param {string} username The username to encode.
 * @return {string} The encoded canonical representation of the username.
 */
URI.getCanonicalUsername = function(username) {
  return _encodeComponent(username, Format.URI);
};

/**
 * Returns the non-canonical representation of a username.
 *
 * @param {string} username The username to encode.
 * @return {string} The unencoded canonical representation of the username.
 */
URI.getDisplayUsername = function(username) {
  return _decodeComponent(username, Format.URI);
};

/**
 * Returns the hex representation of a Base62 encoded id.
 *
 * @param {string} id The base62 encoded id.
 * @return {string} The hex representation of the base62 id.
 */
URI.idToHex = function(id) {
  if (id.length == 22) {
    return Base62.toHex(id, 32);
  }
  return id;
};

/**
 * Returns the base62 representation of a hex encoded id.
 *
 * @param {string} hex The hex encoded id.
 * @return {string} The base62 representation of the id.
 */
URI.hexToId = function(hex) {
  if (hex.length == 32) {
    return Base62.fromHex(hex, 22);
  }
  return hex;
};

/**
 * Creates a new empty URI.
 *
 * @return {URI} The empty URI.
 */
URI.emptyURI = function() {
  return new URI(URI.Type.EMPTY, {});
};

/**
 * Creates a new 'album' type URI.
 *
 * @param {string} id The id of the album.
 * @param {number} disc The disc number of the album.
 * @return {URI} The album URI.
 */
URI.albumURI = function(id, disc) {
  return new URI(URI.Type.ALBUM, {id: id, disc: disc});
};

/**
 * Creates a new 'ad' type URI.
 *
 * @param {string} id The id of the ad.
 * @return {URI} The ad URI.
 */
URI.adURI = function(id) {
  return new URI(URI.Type.AD, {id: id});
};

/**
 * Creates a new 'audiofile' type URI.
 *
 * @param {string} extension The extension of the audiofile.
 * @param {string} id The id of the extension.
 * @return {URI} The audiofile URI.
 */
URI.audioFileURI = function(extension, id) {
  return new URI(URI.Type.AUDIO_FILE, {id: id, extension: extension});
};

/**
 * Creates a new 'artist' type URI.
 *
 * @param {string} id The id of the artist.
 * @return {URI} The artist URI.
 */
URI.artistURI = function(id) {
  return new URI(URI.Type.ARTIST, {id: id});
};

/**
 * Creates a new 'artist-toplist' type URI.
 *
 * @param {string} id The id of the artist.
 * @param {string} toplist The toplist type.
 * @return {URI} The artist-toplist URI.
 */
URI.artistToplistURI = function(id, toplist) {
  return new URI(URI.Type.ARTIST_TOPLIST, {id: id, toplist: toplist});
};

/**
 * Creates a new 'search' type URI.
 *
 * @param {string} query The unencoded search query.
 * @return {URI} The search URI
 */
URI.searchURI = function(query) {
  return new URI(URI.Type.SEARCH, {query: query});
};

/**
 * Creates a new 'track' type URI.
 *
 * @param {string} id The id of the track.
 * @param {string} anchor The point in the track formatted as mm:ss
 * @return {URI} The track URI.
 */
URI.trackURI = function(id, anchor) {
  return new URI(URI.Type.TRACK, {id: id, anchor: anchor});
};

/**
 * Creates a new 'trackset' type URI.
 *
 * @param {Array.<URI>} tracks An array of 'track' type URIs.
 * @param {string} name The name of the trackset.
 * @param {number} index The index in the trackset.
 * @return {URI} The trackset URI.
 */
URI.tracksetURI = function(tracks, name, index) {
  return new URI(URI.Type.TRACKSET, {
    tracks: tracks,
    name: name || '',
    index: isNaN(index) ? null : index
  });
};

/**
 * Creates a new 'facebook' type URI.
 *
 * @param {string} uid The user id.
 * @return {URI} The facebook URI.
 */
URI.facebookURI = function(uid) {
  return new URI(URI.Type.FACEBOOK, {uid: uid});
};

/**
 * Creates a new 'followers' type URI.
 *
 * @param {string} username The non-canonical username.
 * @return {URI} The followers URI.
 */
URI.followersURI = function(username) {
  return new URI(URI.Type.FOLLOWERS, {username: username});
};

/**
 * Creates a new 'following' type URI.
 *
 * @param {string} username The non-canonical username.
 * @return {URI} The following URI.
 */
URI.followingURI = function(username) {
  return new URI(URI.Type.FOLLOWING, {username: username});
};

/**
 * Creates a new 'playlist' type URI.
 *
 * @param {string} username The non-canonical username of the playlist owner.
 * @param {string} id The id of the playlist.
 * @return {URI} The playlist URI.
 */
URI.playlistURI = function(username, id) {
  return new URI(URI.Type.PLAYLIST, {username: username, id: id});
};

/**
 * Creates a new 'folder' type URI.
 *
 * @param {string} username The non-canonical username of the folder owner.
 * @param {string} id The id of the folder.
 * @return {URI} The folder URI.
 */
URI.folderURI = function(username, id) {
  return new URI(URI.Type.FOLDER, {username: username, id: id});
};

/**
 * Creates a new 'collectiontracklist' type URI.
 *
 * @param {string} username The non-canonical username of the collection owner.
 * @param {string} id The id of the tracklist.
 * @return {URI} The collectiontracklist URI.
 */
URI.collectionTrackList = function(username, id) {
  return new URI(URI.Type.COLLECTION_TRACK_LIST, {username: username, id: id});
};

/**
 * Creates a new 'starred' type URI.
 *
 * @param {string} username The non-canonical username of the starred list owner.
 * @return {URI} The starred URI.
 */
URI.starredURI = function(username) {
  return new URI(URI.Type.STARRED, {username: username});
};

/**
 * Creates a new 'user-toplist' type URI.
 *
 * @param {string} username The non-canonical username of the toplist owner.
 * @param {string} toplist The toplist type.
 * @return {URI} The user-toplist URI.
 */
URI.userToplistURI = function(username, toplist) {
  return new URI(URI.Type.USER_TOPLIST, {username: username, toplist: toplist});
};

/**
 * Creates a new 'user-top-tracks' type URI.
 *
 * @deprecated
 * @param {string} username The non-canonical username of the toplist owner.
 * @return {URI} The user-top-tracks URI.
 */
URI.userTopTracksURI = function(username) {
  return new URI(URI.Type.USER_TOP_TRACKS, {username: username});
};

/**
 * Creates a new 'toplist' type URI.
 *
 * @param {string} toplist The toplist type.
 * @param {string} country The country code for the toplist.
 * @param {boolean} global True if this is a global rather than a country list.
 * @return {URI} The toplist URI.
 */
URI.toplistURI = function(toplist, country, global) {
  return new URI(URI.Type.TOPLIST, {toplist: toplist, country: country, global: !!global});
};

/**
 * Creates a new 'inbox' type URI.
 *
 * @param {string} username The non-canonical username of the inbox owner.
 * @return {URI} The inbox URI.
 */
URI.inboxURI = function(username) {
  return new URI(URI.Type.INBOX, {username: username});
};

/**
 * Creates a new 'rootlist' type URI.
 *
 * @param {string} username The non-canonical username of the rootlist owner.
 * @return {URI} The rootlist URI.
 */
URI.rootlistURI = function(username) {
  return new URI(URI.Type.ROOTLIST, {username: username});
};

/**
 * Creates a new 'published-rootlist' type URI.
 *
 * @param {string} username The non-canonical username of the published-rootlist owner.
 * @return {URI} The published-rootlist URI.
 */
URI.publishedRootlistURI = function(username) {
  return new URI(URI.Type.PUBLISHED_ROOTLIST, {username: username});
};

/**
 * Creates a new 'local-artist' type URI.
 *
 * @param {string} artist The artist name.
 * @return {URI} The local-artist URI.
 */
URI.localArtistURI = function(artist) {
  return new URI(URI.Type.LOCAL_ARTIST, {artist: artist});
};

/**
 * Creates a new 'local-album' type URI.
 *
 * @param {string} artist The artist name.
 * @param {string} album The album name.
 * @return {URI} The local-album URI.
 */
URI.localAlbumURI = function(artist, album) {
  return new URI(URI.Type.LOCAL_ALBUM, {artist: artist, album: album});
};

/**
 * Creates a new 'local' type URI.
 *
 * @param {string} artist The artist name.
 * @param {string} album The album name.
 * @param {string} track The track name.
 * @param {number} duration The track duration in ms.
 * @return {URI} The local URI.
 */
URI.localURI = function(artist, album, track, duration) {
  return new URI(URI.Type.LOCAL, {
    artist: artist,
    album: album,
    track: track,
    duration: duration
  });
};

/**
 * Creates a new 'library' type URI.
 *
 * @param {string} username The non-canonical username of the rootlist owner.
 * @param {string} category The category of the library.
 * @return {URI} The library URI.
 */
URI.libraryURI = function(username, category) {
  return new URI(URI.Type.LIBRARY, {username: username, category: category});
};

/**
 * Creates a new 'collection' type URI.
 *
 * @param {string} username The non-canonical username of the rootlist owner.
 * @param {string} category The category of the collection.
 * @return {URI} The collection URI.
 */
URI.collectionURI = function(username, category) {
  return new URI(URI.Type.COLLECTION, {username: username, category: category});
};

/**
 * Creates a new 'temp-playlist' type URI.
 *
 * @param {string} origin The origin of the temporary playlist.
 * @param {string} data Additional data for the playlist.
 * @return {URI} The temp-playlist URI.
 */
URI.temporaryPlaylistURI = function(origin, data) {
  return new URI(URI.Type.TEMP_PLAYLIST, {origin: origin, data: data});
};

/**
 * Creates a new 'context-group' type URI.
 *
 * @deprecated
 * @param {string} origin The origin of the temporary playlist.
 * @param {string} name The name of the context group.
 * @return {URI} The context-group URI.
 */
URI.contextGroupURI = function(origin, name) {
  return new URI(URI.Type.CONTEXT_GROUP, {origin: origin, name: name});
};

/**
 * Creates a new 'profile' type URI.
 *
 * @param {string} username The non-canonical username of the rootlist owner.
 * @param {Array.<string>} args A list of arguments.
 * @return {URI} The profile URI.
 */
URI.profileURI = function(username, args) {
  return new URI(URI.Type.PROFILE, {username: username, args: args});
};

/**
 * Creates a new 'image' type URI.
 *
 * @param {string} id The id of the image.
 * @return {URI} The image URI.
 */
URI.imageURI = function(id) {
  return new URI(URI.Type.IMAGE, {id: id});
};

/**
 * Creates a new 'mosaic' type URI.
 *
 * @param {Array.<string>} ids The ids of the mosaic immages.
 * @return {URI} The mosaic URI.
 */
URI.mosaicURI = function(ids) {
  return new URI(URI.Type.MOSAIC, {ids: ids});
};

/**
 * Creates a new 'radio' type URI.
 *
 * @param {string} args The radio seed arguments.
 * @return {URI} The radio URI.
 */
URI.radioURI = function(args) {
  args = typeof args === 'undefined' ? '' : args;
  return new URI(URI.Type.RADIO, {args: args});
};

/**
 * Creates a new 'special' type URI.
 *
 * @param {Array.<string>} args An array containing the other arguments.
 * @return {URI} The special URI.
 */
URI.specialURI = function(args) {
  args = typeof args === 'undefined' ? [] : args;
  return new URI(URI.Type.SPECIAL, {args: args});
};

/**
 * Creates a new 'station' type URI.
 *
 * @param {Array.<string>} args An array of arguments for the station.
 * @return {URI} The station URI.
 */
URI.stationURI = function(args) {
  args = typeof args === 'undefined' ? [] : args;
  return new URI(URI.Type.STATION, {args: args});
};

/**
 * Creates a new 'application' type URI.
 *
 * @param {string} id The id of the application.
 * @param {Array.<string>} args An array containing the arguments to the app.
 * @return {URI} The application URI.
 */
URI.applicationURI = function(id, args) {
  args = typeof args === 'undefined' ? [] : args;
  return new URI(URI.Type.APPLICATION, {id: id, args: args});
};

/**
 * Creates a new 'collection-album' type URI.
 *
 * @param {string} username The non-canonical username of the rootlist owner.
 * @param {string} id The id of the album.
 * @return {URI} The collection-album URI.
 */
URI.collectionAlbumURI = function(username, id) {
  return new URI(URI.Type.COLLECTION_ALBUM, {username: username, id: id});
};

/**
 * Creates a new 'collection-album-missing' type URI.
 *
 * @param {string} username The non-canonical username of the rootlist owner.
 * @param {string} id The id of the album.
 * @return {URI} The collection-album-missing URI.
 */
URI.collectionMissingAlbumURI = function(username, id) {
  return new URI(URI.Type.COLLECTION_MISSING_ALBUM, {username: username, id: id});
};

/**
 * Creates a new 'collection-artist' type URI.
 *
 * @param {string} username The non-canonical username of the rootlist owner.
 * @param {string} id The id of the artist.
 * @return {URI} The collection-artist URI.
 */
URI.collectionArtistURI = function(username, id) {
  return new URI(URI.Type.COLLECTION_ARTIST, {username: username, id: id});
};

/**
 * Creates a new 'episode' type URI.
 *
 * @param {string} id The id of the episode.
 * @return {URI} The episode URI.
 */
URI.episodeURI = function(id) {
  return new URI(URI.Type.EPISODE, {id: id});
};

/**
 * Export public interface
 */
module.exports = URI;

},{"spotify-crypto/src/base62":420}],427:[function(require,module,exports){
'use strict';

var Range = require('spotify-range2');

/**
 * Get the needed operations for inserting items at a specific index.
 *
 * @param {Array} items Array of items to insert.
 * @param {number} index Index to insert the items at, relative to the list
 *     before the operations.
 *
 * @return {Array.<Object>} Array of operation objects.
 */
function getInsertOperations(items, index) {
  return [{type: 'insert', index: index, values: items}];
}

/**
 * Get the needed operations for removing items from the specified indices.
 *
 * @param {Array.<number>} indices Array of indices relative to the list before
 *     the operations.
 *
 * @return {Array.<Object>} Array of operation objects.
 */
function getRemoveOperations(indices) {
  var ranges = Range.fromIndices(indices);

  var removed = 0;
  var operations = [];

  for (var r = 0, range; (range = ranges[r]); r++) {
    operations.push({type: 'remove', index: range.start - removed, length: range.length});
    removed += range.length;
  }

  return operations;
}

/**
 * Get the needed operations for moving items from a set of indices to a
 * target index.
 *
 * @param {Array.<number>} fromIndices Array of indices relative to the list
 *     before the operations.
 * @param {number} toIndex Index to move the items to, relative to the list
 *     before the operations.
 *
 * @return {Array.<Object>} Array of operation objects.
 */
function getMoveOperations(fromIndices, toIndex) {

  // We're going through one range at a time, and when a range is moved down,
  // we need to decrease the start of the next range to account for the
  // range we moved down (since each operation is based on the result of
  // the previous operation).
  var movedAbove = 0;

  // The maximum index starts at the index we want to move to.
  // When operations are created to move ranges, this maximum index
  // is increased to always point to the bottom index of the moved
  // items. If five items are moved from far down up to the 'to' index,
  // the new maxIndex will be toIndex + 5.
  var maxIndex = toIndex;

  var ranges = Range.fromIndices(fromIndices);
  var r, range;
  var toRange;

  // Find any range that intersects with the 'to' index. Referred below as
  // the 'to' range. This range can't be split, so we need to move items to
  // positions above or below this range if it exists.
  for (r = 0; (range = ranges[r]); r++) {
    if (range.start <= toIndex && range.end >= toIndex) {
      toRange = range;
      break;
    }
  }

  var operations = [];

  for (r = 0; (range = ranges[r]); r++) {
    var length = range.length;
    var to;
    var from = range.start - movedAbove;

    // If the 'to' index is inside a range
    if (toRange) {

      // Range is above the 'to' range, so move it to right above that range.
      if (range.end < toRange.start) {
        from = range.start - movedAbove;
        to = toRange.start - length;
        movedAbove += length;

      // Range is the 'to' range, which means it will not move anywhere.
      } else if (range === toRange) {
        maxIndex = Math.max(maxIndex, range.end);
        continue;

      // Range is below the 'to' range, so move it to the maximum index
      // we've reached so far.
      } else {
        from = range.start;
        to = maxIndex;
        maxIndex = Math.max(maxIndex, to + length);
      }

    // If the 'to' index is not inside a range
    } else {

      // Range is above the 'to' index, so move it to right above the maximum index.
      if (range.end < toIndex) {
        from = range.start - movedAbove;
        to = maxIndex - length;
        movedAbove += length;

      // Range is below the 'to' index, so move it to the maximum index we've
      // reached so far.
      } else {
        from = range.start;
        to = maxIndex;
        maxIndex = Math.max(maxIndex, to + length);
      }
    }

    operations.push({type: 'move', from: from, length: length, to: to});
  }

  return operations;
}

exports.getInsertOperations = getInsertOperations;
exports.getRemoveOperations = getRemoveOperations;
exports.getMoveOperations = getMoveOperations;

},{"spotify-range2":432}],428:[function(require,module,exports){
var player = require("./player");
var types = require("./types");
var play = require("./play");

exports.Play = play.Play;
exports.Player = player.Player;
exports.PlayerContext = types.Context;
exports.PlayOptions = types.PlayOptions;
exports.PlayerRestrictions = types.Restrictions;
exports.PlayerSuppressions = types.Suppressions;
exports.PlayerTrack = types.Track;
exports.PlayerContextPage = types.ContextPage;
exports.IndexPath = types.IndexPath;

},{"./play":429,"./player":430,"./types":431}],429:[function(require,module,exports){
var cosmos = require('spotify-cosmos-api');
var nodefn = require('when/node');

/**
 * Play is exposed as Player.Play. It represents a prepared playback action.
 * Play objects are obtained from the preparePlay method on the Player; the
 * constructor is not a public API.
 *
 * Instantiating a Play object does not make a Cosmos request, the caller is
 * expected to make that call and pass in a promise of the result in the
 * createSessionPromise parameter.
 *
 * @param {Cosmos.resolver} resolver The resolver to send requests to.
 * @param {Promise} createSessionPromise A promise of a Cosmos.Response for
 *     the call to sp://player/v2/xyz/session.
 * @param {Player} player The player that initiated the call.
 * @param {function()=Number} getTime Clock. Should usually return
 *     new Date().getTime()
 * @param {module:spotify-player/types.Context} The context that was passed
 *     to the preparePlay call.
 * @param {Cosmos.PlayOptions=} opt_options The options that were passed to
 *     the preparePlay call.
 */
function Play(resolver, createSessionPromise, player, getTime, context, opt_options) {
  if (!(this instanceof Play)) {
    return new Play(resolver, createSessionPromise, player, getTime, context, opt_options);
  }

  if (!resolver || !createSessionPromise || !player || !getTime || !context) {
    throw new TypeError('Missing parameters for Play');
  }

  /**
   * @type {Cosmos.resolver}
   */
  this._resolver = resolver;

  /**
   * @type {Promise}
   */
  this._createSessionPromise = createSessionPromise;

  /**
   * @type {Player}
   */
  this._player = player;

  /**
   * @type {function()=Number}
   */
  this._getTime = getTime;

  /**
   * @type {module:spotify-player/types.Context}
   */
  this._context = context;

  /**
   * @type {Cosmos.PlayOptions=}
   */
  this._opt_options = opt_options;
}

/**
 * @return Promise of the session URL
 */
Play.prototype._sessionUrl = function() {
  return this._createSessionPromise.then(function(response) {
    return response.getJSONBody().session;
  });
};

Play.prototype._createPlayRequest = function(sessionUrl) {
  var body = {
    logging_params: {
      command_initiated_time: this._getTime()
    }
  };
  return new cosmos.Request(cosmos.Action.POST, sessionUrl + '/play', null, body);
};

Play.prototype._createUpdateRequest = function(sessionUrl, body) {
  body.logging_params = {
    command_initiated_time: this._getTime()
  };
  return new cosmos.Request(cosmos.Action.POST, sessionUrl + '/update', null, body);
};

/**
 * Perform the playback action that this handle represents.
 *
 * It is legal to call play more than once, but the playback action is only
 * prefetched the first time. If subsequent preparation is required, a new
 * Play object should be obtained.
 */
Play.prototype.play = function(opt_callback) {
  opt_callback = opt_callback || function() {};

  var self = this;
  if (this._createSessionPromise) {
    this._sessionUrl()
      .then(function(sessionUrl) {
        return nodefn.call(
          self._resolver.resolve.bind(self._resolver), self._createPlayRequest(sessionUrl));
      })
      .done(function() {
          opt_callback(null);
        }, function(error) {
          if (error.response && error.response.getStatusCode() === 404) {
            // The session has been invalidated. Try again without prefetching.
            self._createSessionPromise = null;
            self.play(opt_callback);
          } else {
            var wrappedError = new Error('Failed to prepare playback session: ' + error.message);
            wrappedError.cause = function() { return error; };
            opt_callback(wrappedError);
          }
        });
  } else {
    this._player.play(this._context, this._opt_options, opt_callback);
  }
};

Play.prototype._update = function(body, opt_callback) {
  opt_callback = opt_callback || function() {};

  var self = this;
  if (!this._createSessionPromise) {
    return opt_callback(new Error('Cannot update invalidated Play'));
  }

  this._sessionUrl()
    .then(function(sessionUrl) {
      return nodefn.call(
        self._resolver.resolve.bind(self._resolver), self._createUpdateRequest(sessionUrl, body));
    })
    .done(function() {
        opt_callback(null);
      }, function(error) {
        var wrappedError = new Error('Failed to update playback session: ' + error.message);
        wrappedError.cause = function() { return error; };
        opt_callback(wrappedError);
      });
};

Play.prototype.updateContext = function(context, opt_callback) {
  this._update({ context: context }, opt_callback);
};

Play.prototype.updatePage = function(page, opt_callback) {
  this._update({ page: page }, opt_callback);
};

Play.prototype.updateTrack = function(track, opt_callback) {
  this._update({ track: track }, opt_callback);
};

Play.prototype.updateViewUri = function(view_uri, opt_callback) {
  this._update({ view_uri: view_uri }, opt_callback);
};

/**
 * Invalidate the handle. This will cause any ongoing prefetching work to be
 * cancelled. It is good if any holder of a handle calls this method as soon
 * as it knows that it is not interested in its play action anymore.
 *
 * It is illegal to call play after this has been called. Invalidating an
 * invalidated Play is a no-op.
 */
Play.prototype.invalidate = function(opt_callback) {
  if (!this._createSessionPromise) {
    // Already invalidated
    return;
  }

  opt_callback = opt_callback || function() {};

  var self = this;
  this._sessionUrl().done(function(sessionUrl) {
    var request = new cosmos.Request(
      cosmos.Action.DELETE, sessionUrl, null, null);
    self._resolver.resolve(request, function() {
      opt_callback(null);
    });
  }, function() {
    // Ignore errors
    opt_callback(null);
  });

  this._createSessionPromise = null;
};

exports.Play = Play;

},{"spotify-cosmos-api":416,"when/node":466}],430:[function(require,module,exports){
var cosmos = require('spotify-cosmos-api');
var nodefn = require('when/node');
var play = require('./play');

var PLAYER_URI = 'sp://player/v2/';
var DEFAULT_PLAYER_ID = 'main';

/**
 * The object decribing the context for the playback
 * Can be used to pass viewUri or externalReferrer specific
 * for the play action.
 *
 * @typedef {Object} ContextConfig
 * @property {Cosmos.PlayerContext} context The context to play
 * @property {string=} opt_viewId Optional. Set to override the default viewUri
 * @property {string=} opt_externalReferrer Optional. Set to indicate that
 *      the playback is owne by external website/app.
 */

/**
 * Player is the main entry point to control music playback with cosmos.
 *
 * Player in itself isn't what deals with playback; it is merely an object
 * that controls playback and provides ability to observe the player state.
 * There can be more than one Player object at the same time, and they
 * will sync up as one would expect.
 *
 * In practice there will be at least one Player object per feature that
 * wants to control playback. The feature can choose to create one per view
 * or have only one object, it doesn't really matter.
 *
 * @param {Cosmos.resolver} resolver The resolver to send requests to.
 * @param {String} viewUri The uri of the view that owns the playback.
 * @param {String} featureIdentifier The identifier of the feature that started
 *     playback. This is arguably the most important field of this class. It is
 *     used for logging messages, in particular EndSong and EndVideo. (In EndSong,
 *     it ends up in source_start / source_end.) It should be a short human
 *     readable name of the feature, for example "radio", "album", "playlist".
 *     Ideally, it should be the same for a given feature across platforms.
 *
 *     Each feature should have only one string constant that it passes in here.
 *     You must not pass lots of distinct values here; for instance do not send
 *     something that contains the username or artist identifier.
 * @param {String} featureVersion The version of the feature. It often makes sense to set
 *     this value to the version of the spm package, for instance "0.7.5".
 * @param {{playerId: string}} opt_options The additional parameters for the player.
 *  param {string} options.playerId Can be used to override the id of the player
 *      which will result in a different endpoint for the player requests.
 */
function Player(resolver, viewUri, featureIdentifier, featureVersion, opt_options) {
  if (!(this instanceof Player)) {
    return new Player(resolver, viewUri, featureIdentifier, featureVersion);
  }

  if (!resolver || !viewUri || !featureIdentifier || !featureVersion) {
    throw new TypeError('Missing parameters for Player');
  }

  this._getTime = opt_options && opt_options.getTime || function() {
    return new Date().getTime();
  };

  /**
   * @type {string}
   */
  this._id = opt_options && opt_options.playerId || DEFAULT_PLAYER_ID;

  /**
   * @type {string}
   */
  this._referrerIdentifier = opt_options && opt_options.referrerIdentifier;

  /**
   * @type {Cosmos.resolver}
   */
  this._resolver = resolver;

  /**
   * @type {string}
   */
  this._viewUri = viewUri;

  /**
   * @type {string}
   */
  this._featureId = featureIdentifier;

  /**
   * @type {string}
   */
  this._featureVersion = featureVersion;
}

/**
 * The actions that can be understood by the PlayerResolver
 * in Cosmos Router.
 */
Player.Actions = {
  PLAY: 'play',
  SESSION: 'session',
  STOP: 'stop',
  UPDATE: 'update',
  PAUSE: 'pause',
  RESUME: 'resume',
  SKIP_NEXT: 'skip_next',
  SKIP_PREV: 'skip_prev',
  SHUFFLE: 'set_shuffling_context',
  REPEAT_CONTEXT: 'set_repeating_context',
  REPEAT_TRACK: 'set_repeating_track',
  SEEK_TO: 'seek_to'
};

/**
 * Private helper method for play and preparePlay
 */
Player.prototype._playOrPrepare = function(action, context, opt_options, opt_callback) {
  if (!context)
    throw new TypeError('Invalid `context` object');

  // Allow to not send the opt_options
  if (opt_options instanceof Function && !opt_callback) {
    opt_callback = opt_options;
    opt_options = null;
  }

  var params = {};
  params.context = context;
  params.play_origin = this._makePlayOrigin();
  params.options = opt_options;

  return this._sendRequestWithParams(action, params, opt_callback);
};

/**
 * Plays the given context.
 * Since both options and callback are optional this method can
 * take from 1 to 3 arguments. if callback is specified, it has to be
 * the last argument:
 *
 *    player.play(myContext);
 *    player.play(myContext, myPlayOptions);
 *    player.play(myContext, function myCallback() {});
 *    player.play(myContext, myPlayOptions, function myCallback() {});
 *
 * @param {module:spotify-player/types.Context} context The context to play.
 * @param {Cosmos.PlayOptions=} opt_options Optional play options.
 * @param {function(Error, Cosmos.Response?)=} opt_callback Optional
 *    callback that will be executed after player request is resolved.
 *
 *    NOTE: The reponse in the callback only has information about the
 *    request itself (i.e. if it was resolved correctly). If you want to have
 *    information about currently playing context you should subscribe to
 *    player events or fetch the current state using. getContext.
 *
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.play = function(context, opt_options, opt_callback) {
  return this._playOrPrepare(Player.Actions.PLAY, context, opt_options, opt_callback);
};

/**
 * This method is like play, but it doesn't actually initiate playback, it
 * merely expresses intent that the user is rather likely going to do a play
 * action like this soon.
 *
 * @return {Player.Play} A handle that is used for actually performing the
 *     playback action. When the object will no longer be used, the user is
 *     responsible for calling invalidate on it, otherwise it will keep
 *     holding resources. As long as this object is not invalidated, the
 *     playback system will take that as a hint that it should try to prepare
 *     playback like this.
 */
Player.prototype.preparePlay = function(context, opt_options) {
  var sessionPromise = nodefn.call(
    this._playOrPrepare.bind(this), Player.Actions.SESSION, context, opt_options);

  return new play.Play(this._resolver, sessionPromise, this, this._getTime, context, opt_options);
};

/**
 * Stop the playback and clear the context.
 *
 * @param {function=} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.stop = function(opt_callback) {
  return this._sendRequestWithAction(Player.Actions.STOP, opt_callback);
};

/**
 * Update the current context.
 *
 * @see https://short.spotify.net/0I for more detailed information on the
 *    implementation.
 *
 * @param {module:spotify-player/types.Context} context The context to update to.
 * @param {function=} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.update = function(context, opt_callback) {
  if (!context)
    throw new TypeError('Invalid `context` object');

  var params = { context: context };
  return this._sendRequestWithParams(Player.Actions.UPDATE, params, opt_callback);
};

/**
 * Resume the playback.
 *
 * @param {function=} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.resume = function(opt_callback) {
  return this._sendRequestWithAction(Player.Actions.RESUME, opt_callback);
};

/**
 * Pause the playback.
 *
 * @param {function=} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.pause = function(opt_callback) {
  return this._sendRequestWithAction(Player.Actions.PAUSE, opt_callback);
};

/**
 * Skip to the previous song.
 *
 * @param {Object=} opt_skip_options The object with the skip options
 *    like allow_seeking
 * @param {function=} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.skipToPrevTrack = function(opt_skip_options, opt_callback) {
  if (arguments.length === 1) {
    // In order to keep backwards compatibility we still need to support
    // passing just the callback as the first parameter
    if (typeof opt_skip_options === 'function') {
      opt_callback = opt_skip_options;
      opt_skip_options = null;
    }
  }
  var params = {};
  if (opt_skip_options) {
    params.options = opt_skip_options;
  }
  return this._sendRequestWithParams(Player.Actions.SKIP_PREV, params, opt_callback);
};

/**
 * Skip to the next song.
 *
 * @param {function=} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.skipToNextTrack = function(opt_callback) {
  return this._sendRequestWithAction(Player.Actions.SKIP_NEXT, opt_callback);
};

/**
 * Skip backwards until it gets to the specified track. This method never skips
 * to the beginning of the current track. For that, use seekTo.
 *
 * @discussion If the reverse runs out of tracks or skipping becomes disallowed
 *    for some other reason, this method will give up when it can no longer
 *    continue. This means that calling this for MFT users will almost
 *    certainly be a bad idea.
 *
 *    The intended purpose of this method is to make it possible to implement
 *    a view of the current future/reverse and allow the user to skip in it.
 *
 *    This method will look at the track URI and the track's UID (if present)
 *    to determine when it has reached its goal.
 *
 * @param {Object} track The track object, as it was provided from the
 *    player state reverse.
 * @param {function=} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.skipToSpecificPrevTrack = function(track, opt_callback) {
  return this._sendRequestWithParams(Player.Actions.SKIP_PREV, { track: track }, opt_callback);
};

/**
 * Skip forwards until it gets to the specified track.
 *
 * @discussion See discussion for -skipToPreviousTrack:
 *
 * @param {Object} track The track object, as it was provided from the
 *    player state reverse.
 * @param {function=} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.skipToSpecificNextTrack = function(track, opt_callback) {
  return this._sendRequestWithParams(Player.Actions.SKIP_NEXT, { track: track }, opt_callback);
};

/**
 * Deprecated alias for skipToPrevTrack
 */
Player.prototype.skipToPrev = Player.prototype.skipToPrevTrack;

/**
 * Deprecated alias for skipToNextTrack
 */
Player.prototype.skipToNext = Player.prototype.skipToNextTrack;

/**
 * Set the shuffle flag
 *
 * @param {boolean} isShuffling The value of the flag to set.
 * @param {function=} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.setShufflingContext = function(isShuffling, opt_callback) {
  return this._sendRequestWithParam(Player.Actions.SHUFFLE, isShuffling, opt_callback);
};

/**
 * Repeat the whole context
 *
 * @param {boolean} isRepeating The value of the flag to set.
 * @param {function=} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.setRepeatingContext = function(isRepeating, opt_callback) {
  return this._sendRequestWithParam(Player.Actions.REPEAT_CONTEXT, isRepeating, opt_callback);
};

/**
 * Repeat the single track
 *
 * @param {boolean} isRepeating The value of the flag to set.
 * @param {function=} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.setRepeatingTrack = function(isRepeating, opt_callback) {
  return this._sendRequestWithParam(Player.Actions.REPEAT_TRACK, isRepeating, opt_callback);
};

/**
 * Set the seek position. It should be set in seconds.
 *
 * @param {boolean} positionInMs Position to seek to in miliseconds.
 * @param {function=} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.seekTo = function(positionInMs, opt_callback) {
  return this._sendRequestWithParam(Player.Actions.SEEK_TO, positionInMs, opt_callback);
};

/**
 * Gets the current player state as an opaque string that can later be used to restore the
 * current state.
 *
 * @param {function(Error, Cosmos.Response=)} callback The function
 *    that will be called when the snapshot is available.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.save = function(callback) {
  var requestUri = this.getPlayerEndpointUri() + '/snapshot';
  var request = new cosmos.Request(cosmos.Action.GET, requestUri);
  return this._resolver.resolve(request, callback);
};

/**
 * Restores a state string that was previously saved by save().
 *
 * @param {string} state The state to restore.
 * @param {function(Error, Cosmos.Response=)} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.restore = function(state, opt_callback) {
  var requestUri = this.getPlayerEndpointUri() + '/snapshot';
  var request = new cosmos.Request(cosmos.Action.PUT, requestUri, null, state);
  return this._resolver.resolve(request, opt_callback);
};

/**
 * Gets the current player queue as an string that can later be modified to replace
 * the current queue.
 *
 * @param {function(Error, Cosmos.Response=)} callback The function
 *    that will be called when the queue is available.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */

Player.prototype.getQueue = function(callback) {
  var requestUri = this.getPlayerEndpointUri() + '/queue';
  var request = new cosmos.Request(cosmos.Action.GET, requestUri);
  return this._resolver.resolve(request, callback);
};

/**
 * Replace the player queue. The state will not replace the current one of the player if
 * the revision does not match the current revision of the player. This happens when
 * the player queue was changed elsewhere by the time it was received until it was set.
 * A response-status of 409 will inform about this situation.
 *
 * @param {string} state The queue-state to replace with.
 * @param {function(Error, Cosmos.Response=)} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.setQueue = function(state, opt_callback) {
  var requestUri = this.getPlayerEndpointUri() + '/queue';
  var request = new cosmos.Request(cosmos.Action.PUT, requestUri, null, state);
  return this._resolver.resolve(request, opt_callback);
};

/**
 * Subscribe to queue changes. There will be an initial callback when subscribing.
 */
Player.prototype.subscribeToQueue = function(callback) {
  var request = new cosmos.Request(cosmos.Action.SUB, this.getPlayerEndpointUri() + '/queue');
  return this._resolver.resolve(request, callback);
};

/**
 * Get the current player state.
 *
 * @param {function(Error, Cosmos.Response=)} callback The function
 *    that will be called when the state is available.
 * @param {Object=} opt_params The additional parameters for the request.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.getState = function(callback, opt_params) {
  var request = new cosmos.Request(
    cosmos.Action.GET, this.getPlayerEndpointUriWithParams(opt_params));
  return this._resolver.resolve(request, callback);
};

/**
 * Subscribe to the player events
 *
 * @param {function(Error, Cosmos.Response=)} callback The function
 *    that will be called every time the event occurs.
 * @param {Object=} opt_params The additional parameters for the request.
 * @return {RequestHandle} The subscription handle.
 *
 *    This object can be used to cancel the subscription
 *    by calling 'cancel()' on it:
 *
 *    var sub = player.subscribe(function(err, response) { });
 *    sub.cancel();
 */
Player.prototype.subscribe = function(callback, opt_params) {
  var request = new cosmos.Request(
    cosmos.Action.SUB, this.getPlayerEndpointUriWithParams(opt_params));
  return this._resolver.resolve(request, callback);
};

/**
 * Subscribe to player error events
 */
Player.prototype.onError = function(callback) {
  var request = new cosmos.Request(cosmos.Action.SUB, this.getPlayerEndpointUri() + '/error');
  return this._resolver.resolve(request, callback);
};

Player.prototype._makePlayOrigin = function() {
  return {
    view_uri: this._viewUri,
    feature_identifier: this._featureId,
    feature_version: this._featureVersion,
    referrer_identifier: this._referrerIdentifier
  };
};

Player.prototype.getPlayerEndpointUri = function() {
  return PLAYER_URI + this._id;
};

Player.prototype.getPlayerEndpointUriWithParams = function(params) {
  params = params || {};

  var paramsArray = Object.keys(params).reduce(function(arr, key) {
    arr.push(key + '=' + encodeURIComponent(params[key]));
    return arr;
  }, []);

  if (paramsArray.length > 0) {
    return this.getPlayerEndpointUri() + '?' + paramsArray.join('&');
  } else {
    return this.getPlayerEndpointUri();
  }
};

/**
 * @private
 * Sends context-less request.
 *
 * @param {string} action The action to perform on the player.
 * @param {function=} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype._sendRequestWithAction = function(action, opt_callback) {
  return this._sendRequestWithParams(action, null, opt_callback);
};

/**
 * @private
 * Sends the request that only expects the single value in the body.
 *
 * @param {string} action The action to perform on the player.
 * @param {*} paramValue The value to send to the player.
 * @param {function=} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype._sendRequestWithParam = function(action, paramValue, opt_callback) {
  var params = {
    value: paramValue
  };
  return this._sendRequestWithParams(action, params, opt_callback);
};

/**
 * @private
 * Sends request with context and optional options.
 *
 * @param {string} action The action to perform on the player.
 * @param {Object?} params The context to play.
 * @param {function=} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype._sendRequestWithParams = function(action, params, opt_callback) {
  var requestUri = this.getPlayerEndpointUri() + '/' + action;
  var body = params || {};
  body.logging_params = {
    command_initiated_time: this._getTime()
  };
  var request = new cosmos.Request(
    cosmos.Action.POST, requestUri, null, body);
  return this._resolver.resolve(request, opt_callback);
};

exports.Player = Player;

},{"./play":429,"spotify-cosmos-api":416,"when/node":466}],431:[function(require,module,exports){
/**
 * A PlayerTrack represents a single track in a context.
 *
 * @typedef {Object}
 * @property {String} uri
 *    The URI of the track. This will be one of the Spotify URIs, such as
 *    spotify:track:GID or spotify:local:DATA.
 * @property {String} album_uri
 *    The URI of the album that the track appears on. This property must always
 *    be set if the track URI is set. This is a requirement so that functions
 *    like MFT rules and biased shuffle can operate without having to fetch
 *    additional metadata for each track.
 * @property {String} artist_uri
 *    The URI of the main artist of the track. This property must always be set
 *    if the track URI is set. This is a requirement so that functions like MFT
 *    rules and biased shuffle can operate without having to fetch additional
 *    metadata for each track.
 * @property {Object} metadata
 *    A map with custom metadata for the track. This map can hold anything that
 *    the feature decides to put in it. Features should be prepared that the
 *    metadata can disappear and be able to work around that situation.
 *    The metadata is passed around and persisted, so it will usually stick
 *    around, but there are certain situations where the data is lost because of
 *    transferring the track over legacy protocols, to Connect enabled speakers
 *    and back.
 */
exports.Track;

/**
 * PlayerRestrictions is used to encapsulate limitations of a player or a
 * context. The caller can specify that restrictions should apply when playing a
 * given context (see PlayerContext.restrictions), and a player can notify that
 * restrictions (see PlayState.restrictions).
 *
 * @typedef {Object}
 * @property {Array.<String>} disallow_skipping_prev_reasons
 *    The reasons why skipping to the previous track should be / is disallowed.
 * @property {Array.<String>} disallow_skipping_next_reasons
 *    The reasons why skipping to the next track should be / is disallowed.
 * @property {Array.<String>} disallow_peeking_prev_reasons
 *    The reasons why peeking at the previous track should be / is disallowed.
 * @property {Array.<String>} disallow_peeking_next_reasons
 *    The reasons why peeking at the next track should be / is disallowed.
 * @property {Array.<String>} disallow_skipping_to_reasons
 *    The reasons why skipping to a specific track should be / is disallowed.
 * @property {Array.<String>} disallow_pausing_reasons
 *    The reasons why pausing playback should be / is disallowed.
 * @property {Array.<String>} disallow_resuming_reasons
 *    The reasons why resuming playback should be / is disallowed.
 * @property {Array.<String>} disallow_toggling_repeat_context_reasons
 *    The reasons why toggling repeat context should be / is disallowed.
 * @property {Array.<String>} disallow_toggling_repeat_track_reasons
 *    The reasons why toggling repeat track should be / is disallowed.
 * @property {Array.<String>} disallow_toggling_shuffle_reasons
 *    The reasons why toggling shuffle should be / is disallowed.
 * @property {Array.<String>} disallow_seeking_reasons
 *    The reasons why seeking within a track should be / is disallowed.
 * @property {Array.<String>} disallow_muting_reasons
 *    The reasons why muting audio should be / is disallowed.
 */
exports.Restrictions;

/**
 * PlayerSuppressions are used to disable certain player rules while playing a
 * context. The caller can specify that suppressions should apply when playing a
 * context (see PlayerOptions.suppressions), and a player can notify those
 * suppressions (see PlayState.suppressions).
 *
 * @typedef {Object}
 * @property {Array.<String>} providers
 *    The provider identifiers of the rules that should be disabled.
 */
exports.Suppressions;

/**
 * An object representing the index of the track to play within a context.
 * In the simplest case there is only one page thus its index should be 0.
 *
 * @typedef {Object}
 * @property {Number} page The index of the page to find the track in.
 * @property {Number} track The index of the track in the page.
 */
exports.IndexPath;

/**
 * This structure holds options that should be applied to the player: they are
 * either specified at a global or per-context level. When they are specified
 * globally, finishing the current context or starting to play a new context
 * does not change the player options: specifying them at a context-level means
 * that the previous global setting will be restored when the player is asked to
 * play another context.
 *
 * @typedef {Object}
 * @property {Boolean} shuffling_context
 *    Specifies if the player should shuffle the context or not.
 * @property {Boolean} repeating_context
 *    Specifies if the player should repeat the context or not.
 * @property {Boolean} repeating_track
 *    Specifies if the player should repeat the current track or not.
 */
exports.PlayerOptions;

/**
 * Options for a specific playback request. This object can specify for instance
 * which track to play within the given context, where to seek within the track
 * etc.
 *
 * @typedef {Object}
 * @property {module:spotify-player/types.IndexPath} skip_to_index
 *    The index in the context to start playing from. It is possible to specify
 *    a page that is not yet loaded, in which case the page will be downloaded
 *    before playback starts. The context player state will indicate that the
 *    playback is delayed because of loading the page.
 * @property {Number} seek_to
 *    The number of milliseconds to seek into the track when starting to
 *    play it.
 * @property {Boolean} initially_paused
 *    When this property is set, the context player will load the context but
 *    will not start playing audio for the first track. The is_paused property
 *    is set in the context player state to indicate that playback is paused. To
 *    start playing the track, call the `resume` method on the context player.
 * @property {module:spotify-player/types.PlayerOptions} player_options_override
 *    Use this to temporarily override the player options for this play request
 *    only. This can for instance be used to implement shuffle play buttons that
 *    enable shuffling but only for this particular context.
 */
exports.PlayOptions;

/**
 * Allows the list of tracks that will be played to be split up into chunks.
 * Pages may loaded or unloaded: an unloaded page will be loaded by the player
 * when it needs more tracks to play.
 *
 * @typedef {Object}
 * @property {String} page_url
 *     The URL of this page. If this property is set to a valid URL, it will be
 *     used to fetch the tracks of the page. The URL must be something that is
 *     supported by the context page loader in use, e.g., Hermes endpoints or
 *     Spotify playlist URIs. In the latter case, the context page loader will
 *     trigger the loaded signal each time the underlying playlist changes. If
 *     the tracks for the (static) context page are already provided in the
 *     tracks property, the page is considered loaded and the URL can be left
 *     empty.
 * @property {String} next_page_url
 *     The URL of the next context page. When the context page is stored in a
 *     context, the next page URL will be used to automatically append new pages
 *     at the end of the pages (or the fallback page) array. The new page
 *     will have its page URL set according to the next page URL of the last
 *     page in the context. The context page loaded will be used at some point
 *     to fetch the tracks for the new page. When the new page is fetched from
 *     the backend, it can also have the next page URL set, and yet another page
 *     is added to the context.
 * @property {Array<module:spotify-player/types.Track>} tracks
 *     An optional array with the tracks of this context page. When the context
 *     page is not loaded, the property is not initialized, and a context page
 *     loader will be used to fetch a loaded version of the page. In a loaded
 *     page this property will be set to an array of tracks. Note that the array
 *     can be empty, which means that the page does not have any tracks. This is
 *     not the same as a page that is not loaded, which may or may not have
 *     tracks.
 */
exports.ContextPage;

/**
 * Describes a set of tracks to be played.
 *
 * @typedef {Object}
 * @property {String} entity_uri
 *    An optional Spotify URI that represents what this entire context contains.
 *    For established entities like playlist, album, artist, this should be their
 *    respective URIs. This can be used for inter-feature playback status
 *    indication.
 *
 *    For instance, when the search page starts to play an artist, it should
 *    provide the artist URI in this field. The playback status indication for
 *    that artist in the search result list should be set if the current context
 *    entity URI matches the artist URI. On the artist page, the artist play
 *    button should also look at the entity URI for playback indication.
 * @property {Object} metadata
 *    A map with custom metadata for the track. This map can hold anything that
 *    the feature decides to put in it. Features should be prepared that the
 *    metadata can disappear and be able to work around that situation.
 *    The metadata is passed around and persisted, so it will usually stick
 *    around, but there are certain situations where the data is lost because of
 *    transferring the track over legacy protocols, to Connect enabled speakers
 *    and back.
 * @property {Array<module:spotify-player/types.ContextPage>} pages
 *    An array of context pages that contain the tracks that should be played
 *    for this context. The context pages may or may not be loaded when passing
 *    the context to the player for playback. Note that if the last context page
 *    has a next page URL, at some point a new context page will be added to the
 *    end of the array, for that page URL. This will happen when playback is
 *    nearing the end of the available context pages.
 * @property {Array<module:spotify-player/types.ContextPage>} fallback_pages
 *    A vector of context pages that contain the tracks that should be used as a
 *    fallback if some rule does not allow the tracks in the future to be
 *    played.  An example of this is the MFT rules, which has a number of
 *    restrictions of how many times a track and album can be played during a
 *    given time period.  Another example is the DMCA rules that is used for the
 *    radio feature. When a fallback track is picked from the fallback pages, it
 *    must be removed from the page, so that it is not used again later. The
 *    fallback track can be provided by the feature that starts playback or
 *    they will be populated by the player if they are needed and none are
 *    provided.
 * @property {module:spotify-player/types.Restricitions} restrictions
 *    The restrictons that should be applied to the player when playing tracks
 *    from the context, e.g., whether the user is allowed to skip backward and
 *    forward in the context or enable shuffling and repeating. Note that the
 *    actual restrictions of the player at any given moment is decided not only
 *    by the context restrictions but also by the rules that are applied, e.g.,
 *    the MFT rules will always disable skipping backward, and will disable
 *    skipping forward as well when the user has reached the maximum number of
 *    skips allowed per time period.
 */
exports.Context;

},{}],432:[function(require,module,exports){
/**
 * @module spotify-range2
 */'use strict';

var prime = require('prime');

var map = require('mout/array/map');

var push_ = Array.prototype.push;
var slice_ = Array.prototype.slice;

var Range = prime(/** @lends Range.prototype */{

  /**
   * The representation of a range
   * @constructs
   * @param {Number} start The start of the range.
   * @param {Number} end The end of the range.
   */
  constructor: function Range(start, end) {
    this.update(start, end);
  },

  /** Update a range. */
  update: function(start, end) {
    if (start != null) this.start = start;
    if (end != null) this.end = end;
    if (this.start == null || this.end == null) throw new Error('invalid range');
    if (this.start > this.end) throw new Error('invalid range');
    this.length = this.end - this.start;
    return this;
  },

  /** Copy a range. */
  copy: function() {
    return new Range(this.start, this.end);
  },

  /** Range is above range. */
  above: function(range) {
    if (!range) return false;
    return this.start >= range.end;
  },

  /** Range is below range. */
  below: function(range) {
    if (!range) return false;
    return this.end <= range.start;
  },

  adjacent: function(range) {
    if (!range) return false;
    return this.end === range.start || this.start === range.end;
  },

  /** Range intersects range. */
  intersects: function(range) {
    if (!range) return false;
    return !this.above(range) && !this.below(range);
  },

  /** Range contains range. */
  contains: function(range) {
    if (!range) return false;
    return (this.start <= range.start && this.end >= range.end);
  },

  /** Range is contained by ranges. */
  contained: function(range) {
    var ranges;
    if (range instanceof Range) ranges = arguments;
    else ranges = range;
    if (!ranges) return false;

    for (var i = 0; (range = ranges[i]); i++) {
      if (range.start <= this.start && range.end >= this.end)
        return true;
    }
    return false;
  },

  /** Range fits two ranges. */
  fits: function(prev, next) {
    if (!prev && !next) return true;
    if (!prev) return this.end <= next.start;
    if (!next) return this.start >= prev.end;
    return this.start >= prev.end && this.end <= next.start;
  },

  // get the section of this range contained between two ranges
  // [0, 20] » [0, 8], [16, 20] » [8, 16]

  /** portion of a range between two ranges. */
  between: function(prev, next) {
    if (!prev && !next) return this.copy();
    if (!prev) return this.start >= next.start ? null : new Range(this.start, Math.min(this.end, next.start));
    if (!next) return this.end <= prev.end ? null : new Range(Math.max(prev.end, this.start), this.end);

    return this.end > prev.end && this.start < next.start ?
        new Range(Math.max(prev.end, this.start), Math.min(next.start, this.end)) :
        null;
  },

  // [0, 8] » [0, 2], [4, 5] = [0, 2], [4, 5]
  // [3, 6] » [5, 7] = [5, 6]
  // [6, 9] » [5, 7] = [6, 7]

  /** intersection of a range with many ranges */
  intersection: function(range) {
    var intersected = [], ranges;
    if (range instanceof Range) ranges = arguments;
    else ranges = range;
    for (var k = 0; k < ranges.length; k++) {
      var r = ranges[k];
      if (this.below(r)) break;

      if (r.intersects(this)) intersected.push(new Range(Math.max(this.start, r.start), Math.min(this.end, r.end)));
    }
    return intersected;
  },

  // subtract ranges from this range
  // [0, 8] » [0, 2], [4, 5] = [2, 4], [5, 8]

  /** subtract many ranges from the range. */
  subtract: function(range) {
    var subtracted = [], ranges;
    if (range instanceof Range) ranges = arguments;
    else ranges = range;
    for (var k = -1; k < ranges.length; k++) {
      var prev = ranges[k];
      var next = ranges[k + 1];
      var between = this.between(prev, next);
      if (between) subtracted.push(between);
    }
    return subtracted;
  },

  // extract this range from ranges
  // [0, 8] » [0, 2], [5, 8] = []
  // [8, 20] » [0, 2], [5, 8] = [0, 2], [5, 8]
  // [0, 10] » [5, 10], [15, 20] = [5, 10]
  // [10, 20] » [5, 80], [90, 100] = [5, 70] [80, 90]
  // [10, 20] » [0, 10], [20, 30] = [0, 20]

  /** extract the range from many ranges. */
  extract: function(range) {
    var ranges = (range instanceof Range) ? slice_.call(arguments) : range.slice();

    for (var k = 0; k < ranges.length; k++) {
      var prev = ranges[k - 1];
      var next = ranges[k];

      var newRange = null;

      if (this.below(next)) {
        newRange = new Range(next.start - this.length, next.end - this.length);
      } else if (this.intersects(next)) {
        var subtracted = next.subtract(this);
        if (subtracted.length === 2) { // is contained
          newRange = new Range(subtracted[0].start, subtracted[1].end - this.length);
        } else if (subtracted.length === 1) {
          if (next.end > this.end) { // second segment kept
            newRange = new Range(subtracted[0].start - this.length, subtracted[0].end - this.length);
          } else if (this.start > next.start) { // first segment kept
            newRange = new Range(subtracted[0].start, subtracted[0].end);
          }
        } else { // gets eaten
          ranges.splice(k--, 1); // decrease k
        }
      } else {
        ranges.splice(k, 1, next.copy());
      }

      if (newRange) {
        if (prev && prev.end === newRange.start) { // touches previous
          ranges.splice(k-- - 1, 2, new Range(prev.start, newRange.end)); // decrease k due to splicing
        } else {
          ranges.splice(k, 1, newRange);
        }
      }

    }

    return ranges;
  },

  // [2,3] » [0,1], [2,3] = [0,1], [2,4]
  // [1,2] » [0,6] = [0,7]
  // [0,1] » [0,1], [5,6] = [0,2], [6,7]
  // [4,6] » [0,1], [5,6] = [0,1], [4,6], [7,8]

  // TODO: this can be slightly better. merging can be done in one loop.

  /** insert the range in many ranges. */
  insert: function(range) {
    var ranges = (range instanceof Range) ? slice_.call(arguments) : range.slice();

    for (var k = 0; k < ranges.length; k++) {
      var next = ranges[k];

      if (this.start >= next.end) {

        ranges.splice(k, 1, next.copy());

      } else if (this.start > next.start && this.start < next.end) {

        ranges.splice(k, 1, new Range(next.start, this.start), new Range(this.start, next.end));

      } else {

        ranges.splice(k, 1, new Range(next.start + this.length, next.end + this.length));

      }

    }

    return this.merge(ranges);

  },

  // merge this range in ranges
  // [0, 8] » [0, 2], [5, 8] = [0, 8]
  // [8, 20] » [0, 2], [5, 8] = [0, 2], [5, 20]
  // [0, 10] » [5, 10], [15, 20] = [0, 10], [15, 20]

  /** merge many ranges to the range. */
  merge: function(range) {
    var ranges;
    if (range instanceof Range) ranges = arguments;
    else ranges = range;

    ranges = map(ranges, function(r) {
      return r.copy();
    });

    if (!ranges.length) return [this.copy()];

    for (var k = -1, l = ranges.length; k < l; k++) {

      var prev = ranges[k];
      var next = ranges[k + 1];
      var between = this.between(prev, next);

      if (between) {

        if (!prev && next) {

          if (between.end === next.start) {
            next.update(between.start, next.end);
          } else {
            k++; // increase k since we had a push
            ranges.unshift(between);
          }

        } else if (prev && next) {

          if (prev.end === between.start && between.end === next.start) {
            prev.update(prev.start, next.end);
            ranges.splice(k-- + 1, 1); // remove the next, decrease k since we had a splice
          } else if (prev.end === between.start) {
            prev.update(prev.start, between.end);
          } else if (between.end === next.start) {
            next.update(between.start, next.end);
          } else {
            ranges.splice(k + 1, 0, between);
          }

        } else if (prev && !next) {

          if (prev.end === between.start) {
            prev.update(prev.start, between.end);
          } else {
            k++; // increase k since we had a push
            ranges.push(between);
          }
        }

      }

    }

    return ranges;
  },

  /** Remove range from many ranges
      - The range(s) you pass is what you remove from */
  remove: function(range) {
    var ranges;
    if (range instanceof Range) ranges = arguments;
    else ranges = range;
    var result = [];
    for (var i = 0; i < ranges.length; i++) {
      var remaining = ranges[i].subtract(this);
      if (remaining.length) push_.apply(result, remaining);
    }
    return result;
  },

  /** Range to an array of indices */
  toIndices: function() {
    var indices = [];
    for (var i = this.start; i < this.end; i++) indices.push(i);
    return indices;
  },

  /** Range to a string */
  toString: function() {
    return [this.start, this.end] + '';
  }

});

/**
 * Range from a string
 * @memberof Range
 * @static
 * @param {String} string - The string.
 * @return {Range} The range.
 */
Range.fromString = function(string) {
  var parts = string.split(',');
  return new Range(+parts[0], +parts[1]);
};

/**
 * Ranges from an array of indices
 * @memberof Range
 * @static
 * @param {Array} indices - An array of indices.
 * @return {Array} An array of Ranges.
 */
Range.fromIndices = function(indices) {
  indices.sort(function(a, b) {
    return a > b ? 1 : -1;
  });

  var ranges = [], rstart, rend;

  for (var i = 0; i < indices.length; i++) {
    rstart = indices[i];
    rend = rstart;
    while (indices[i + 1] - indices[i] === 1) {
      rend = indices[i + 1]; // increment the index if the numbers sequential
      i++;
    }
    ranges.push(new Range(rstart, rend + 1));
  }

  return ranges;
};

/**
 * A function that returns a range.
 * @function
 * @see Range
 * @param {Number} start The start of the range.
 * @param {Number} end The end of the range.
 */
module.exports = Range;

},{"mout/array/map":433,"prime":446}],433:[function(require,module,exports){
arguments[4][319][0].apply(exports,arguments)
},{"../function/makeIterator_":435,"dup":319}],434:[function(require,module,exports){
arguments[4][325][0].apply(exports,arguments)
},{"dup":325}],435:[function(require,module,exports){
arguments[4][326][0].apply(exports,arguments)
},{"../object/deepMatches":441,"./identity":434,"./prop":436,"dup":326}],436:[function(require,module,exports){
arguments[4][327][0].apply(exports,arguments)
},{"dup":327}],437:[function(require,module,exports){
arguments[4][328][0].apply(exports,arguments)
},{"../object/mixIn":445,"dup":328}],438:[function(require,module,exports){
arguments[4][329][0].apply(exports,arguments)
},{"./isKind":439,"dup":329}],439:[function(require,module,exports){
arguments[4][330][0].apply(exports,arguments)
},{"./kindOf":440,"dup":330}],440:[function(require,module,exports){
arguments[4][332][0].apply(exports,arguments)
},{"dup":332}],441:[function(require,module,exports){
arguments[4][333][0].apply(exports,arguments)
},{"../lang/isArray":438,"./forOwn":443,"dup":333}],442:[function(require,module,exports){
arguments[4][334][0].apply(exports,arguments)
},{"./hasOwn":444,"dup":334}],443:[function(require,module,exports){
arguments[4][335][0].apply(exports,arguments)
},{"./forIn":442,"./hasOwn":444,"dup":335}],444:[function(require,module,exports){
arguments[4][336][0].apply(exports,arguments)
},{"dup":336}],445:[function(require,module,exports){
arguments[4][337][0].apply(exports,arguments)
},{"./forOwn":443,"dup":337}],446:[function(require,module,exports){
arguments[4][339][0].apply(exports,arguments)
},{"dup":339,"mout/lang/createObject":437,"mout/lang/kindOf":440,"mout/object/hasOwn":444,"mout/object/mixIn":445}],447:[function(require,module,exports){
//     Underscore.js 1.8.3
//     http://underscorejs.org
//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `exports` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var
    push             = ArrayProto.push,
    slice            = ArrayProto.slice,
    toString         = ObjProto.toString,
    hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind,
    nativeCreate       = Object.create;

  // Naked function reference for surrogate-prototype-swapping.
  var Ctor = function(){};

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.8.3';

  // Internal function that returns an efficient (for current engines) version
  // of the passed-in callback, to be repeatedly applied in other Underscore
  // functions.
  var optimizeCb = function(func, context, argCount) {
    if (context === void 0) return func;
    switch (argCount == null ? 3 : argCount) {
      case 1: return function(value) {
        return func.call(context, value);
      };
      case 2: return function(value, other) {
        return func.call(context, value, other);
      };
      case 3: return function(value, index, collection) {
        return func.call(context, value, index, collection);
      };
      case 4: return function(accumulator, value, index, collection) {
        return func.call(context, accumulator, value, index, collection);
      };
    }
    return function() {
      return func.apply(context, arguments);
    };
  };

  // A mostly-internal function to generate callbacks that can be applied
  // to each element in a collection, returning the desired result — either
  // identity, an arbitrary callback, a property matcher, or a property accessor.
  var cb = function(value, context, argCount) {
    if (value == null) return _.identity;
    if (_.isFunction(value)) return optimizeCb(value, context, argCount);
    if (_.isObject(value)) return _.matcher(value);
    return _.property(value);
  };
  _.iteratee = function(value, context) {
    return cb(value, context, Infinity);
  };

  // An internal function for creating assigner functions.
  var createAssigner = function(keysFunc, undefinedOnly) {
    return function(obj) {
      var length = arguments.length;
      if (length < 2 || obj == null) return obj;
      for (var index = 1; index < length; index++) {
        var source = arguments[index],
            keys = keysFunc(source),
            l = keys.length;
        for (var i = 0; i < l; i++) {
          var key = keys[i];
          if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];
        }
      }
      return obj;
    };
  };

  // An internal function for creating a new object that inherits from another.
  var baseCreate = function(prototype) {
    if (!_.isObject(prototype)) return {};
    if (nativeCreate) return nativeCreate(prototype);
    Ctor.prototype = prototype;
    var result = new Ctor;
    Ctor.prototype = null;
    return result;
  };

  var property = function(key) {
    return function(obj) {
      return obj == null ? void 0 : obj[key];
    };
  };

  // Helper for collection methods to determine whether a collection
  // should be iterated as an array or as an object
  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
  var getLength = property('length');
  var isArrayLike = function(collection) {
    var length = getLength(collection);
    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
  };

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles raw objects in addition to array-likes. Treats all
  // sparse array-likes as if they were dense.
  _.each = _.forEach = function(obj, iteratee, context) {
    iteratee = optimizeCb(iteratee, context);
    var i, length;
    if (isArrayLike(obj)) {
      for (i = 0, length = obj.length; i < length; i++) {
        iteratee(obj[i], i, obj);
      }
    } else {
      var keys = _.keys(obj);
      for (i = 0, length = keys.length; i < length; i++) {
        iteratee(obj[keys[i]], keys[i], obj);
      }
    }
    return obj;
  };

  // Return the results of applying the iteratee to each element.
  _.map = _.collect = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length,
        results = Array(length);
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      results[index] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
  };

  // Create a reducing function iterating left or right.
  function createReduce(dir) {
    // Optimized iterator function as using arguments.length
    // in the main function will deoptimize the, see #1991.
    function iterator(obj, iteratee, memo, keys, index, length) {
      for (; index >= 0 && index < length; index += dir) {
        var currentKey = keys ? keys[index] : index;
        memo = iteratee(memo, obj[currentKey], currentKey, obj);
      }
      return memo;
    }

    return function(obj, iteratee, memo, context) {
      iteratee = optimizeCb(iteratee, context, 4);
      var keys = !isArrayLike(obj) && _.keys(obj),
          length = (keys || obj).length,
          index = dir > 0 ? 0 : length - 1;
      // Determine the initial value if none is provided.
      if (arguments.length < 3) {
        memo = obj[keys ? keys[index] : index];
        index += dir;
      }
      return iterator(obj, iteratee, memo, keys, index, length);
    };
  }

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`.
  _.reduce = _.foldl = _.inject = createReduce(1);

  // The right-associative version of reduce, also known as `foldr`.
  _.reduceRight = _.foldr = createReduce(-1);

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, predicate, context) {
    var key;
    if (isArrayLike(obj)) {
      key = _.findIndex(obj, predicate, context);
    } else {
      key = _.findKey(obj, predicate, context);
    }
    if (key !== void 0 && key !== -1) return obj[key];
  };

  // Return all the elements that pass a truth test.
  // Aliased as `select`.
  _.filter = _.select = function(obj, predicate, context) {
    var results = [];
    predicate = cb(predicate, context);
    _.each(obj, function(value, index, list) {
      if (predicate(value, index, list)) results.push(value);
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, predicate, context) {
    return _.filter(obj, _.negate(cb(predicate)), context);
  };

  // Determine whether all of the elements match a truth test.
  // Aliased as `all`.
  _.every = _.all = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (!predicate(obj[currentKey], currentKey, obj)) return false;
    }
    return true;
  };

  // Determine if at least one element in the object matches a truth test.
  // Aliased as `any`.
  _.some = _.any = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (predicate(obj[currentKey], currentKey, obj)) return true;
    }
    return false;
  };

  // Determine if the array or object contains a given item (using `===`).
  // Aliased as `includes` and `include`.
  _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {
    if (!isArrayLike(obj)) obj = _.values(obj);
    if (typeof fromIndex != 'number' || guard) fromIndex = 0;
    return _.indexOf(obj, item, fromIndex) >= 0;
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function(value) {
      var func = isFunc ? method : value[method];
      return func == null ? func : func.apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, _.property(key));
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs) {
    return _.filter(obj, _.matcher(attrs));
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.find(obj, _.matcher(attrs));
  };

  // Return the maximum element (or element-based computation).
  _.max = function(obj, iteratee, context) {
    var result = -Infinity, lastComputed = -Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value > result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iteratee, context) {
    var result = Infinity, lastComputed = Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value < result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed < lastComputed || computed === Infinity && result === Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Shuffle a collection, using the modern version of the
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
  _.shuffle = function(obj) {
    var set = isArrayLike(obj) ? obj : _.values(obj);
    var length = set.length;
    var shuffled = Array(length);
    for (var index = 0, rand; index < length; index++) {
      rand = _.random(0, index);
      if (rand !== index) shuffled[index] = shuffled[rand];
      shuffled[rand] = set[index];
    }
    return shuffled;
  };

  // Sample **n** random values from a collection.
  // If **n** is not specified, returns a single random element.
  // The internal `guard` argument allows it to work with `map`.
  _.sample = function(obj, n, guard) {
    if (n == null || guard) {
      if (!isArrayLike(obj)) obj = _.values(obj);
      return obj[_.random(obj.length - 1)];
    }
    return _.shuffle(obj).slice(0, Math.max(0, n));
  };

  // Sort the object's values by a criterion produced by an iteratee.
  _.sortBy = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value: value,
        index: index,
        criteria: iteratee(value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index - right.index;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(behavior) {
    return function(obj, iteratee, context) {
      var result = {};
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index) {
        var key = iteratee(value, index, obj);
        behavior(result, value, key);
      });
      return result;
    };
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key].push(value); else result[key] = [value];
  });

  // Indexes the object's values by a criterion, similar to `groupBy`, but for
  // when you know that your index values will be unique.
  _.indexBy = group(function(result, value, key) {
    result[key] = value;
  });

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key]++; else result[key] = 1;
  });

  // Safely create a real, live array from anything iterable.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (isArrayLike(obj)) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return isArrayLike(obj) ? obj.length : _.keys(obj).length;
  };

  // Split a collection into two arrays: one whose elements all satisfy the given
  // predicate, and one whose elements all do not satisfy the predicate.
  _.partition = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var pass = [], fail = [];
    _.each(obj, function(value, key, obj) {
      (predicate(value, key, obj) ? pass : fail).push(value);
    });
    return [pass, fail];
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[0];
    return _.initial(array, array.length - n);
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array.
  _.last = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[array.length - 1];
    return _.rest(array, Math.max(0, array.length - n));
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, n == null || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, _.identity);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, strict, startIndex) {
    var output = [], idx = 0;
    for (var i = startIndex || 0, length = getLength(input); i < length; i++) {
      var value = input[i];
      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
        //flatten current level of array or arguments object
        if (!shallow) value = flatten(value, shallow, strict);
        var j = 0, len = value.length;
        output.length += len;
        while (j < len) {
          output[idx++] = value[j++];
        }
      } else if (!strict) {
        output[idx++] = value;
      }
    }
    return output;
  };

  // Flatten out an array, either recursively (by default), or just one level.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, false);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iteratee, context) {
    if (!_.isBoolean(isSorted)) {
      context = iteratee;
      iteratee = isSorted;
      isSorted = false;
    }
    if (iteratee != null) iteratee = cb(iteratee, context);
    var result = [];
    var seen = [];
    for (var i = 0, length = getLength(array); i < length; i++) {
      var value = array[i],
          computed = iteratee ? iteratee(value, i, array) : value;
      if (isSorted) {
        if (!i || seen !== computed) result.push(value);
        seen = computed;
      } else if (iteratee) {
        if (!_.contains(seen, computed)) {
          seen.push(computed);
          result.push(value);
        }
      } else if (!_.contains(result, value)) {
        result.push(value);
      }
    }
    return result;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(flatten(arguments, true, true));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    var result = [];
    var argsLength = arguments.length;
    for (var i = 0, length = getLength(array); i < length; i++) {
      var item = array[i];
      if (_.contains(result, item)) continue;
      for (var j = 1; j < argsLength; j++) {
        if (!_.contains(arguments[j], item)) break;
      }
      if (j === argsLength) result.push(item);
    }
    return result;
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = flatten(arguments, true, true, 1);
    return _.filter(array, function(value){
      return !_.contains(rest, value);
    });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    return _.unzip(arguments);
  };

  // Complement of _.zip. Unzip accepts an array of arrays and groups
  // each array's elements on shared indices
  _.unzip = function(array) {
    var length = array && _.max(array, getLength).length || 0;
    var result = Array(length);

    for (var index = 0; index < length; index++) {
      result[index] = _.pluck(array, index);
    }
    return result;
  };

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values.
  _.object = function(list, values) {
    var result = {};
    for (var i = 0, length = getLength(list); i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // Generator function to create the findIndex and findLastIndex functions
  function createPredicateIndexFinder(dir) {
    return function(array, predicate, context) {
      predicate = cb(predicate, context);
      var length = getLength(array);
      var index = dir > 0 ? 0 : length - 1;
      for (; index >= 0 && index < length; index += dir) {
        if (predicate(array[index], index, array)) return index;
      }
      return -1;
    };
  }

  // Returns the first index on an array-like that passes a predicate test
  _.findIndex = createPredicateIndexFinder(1);
  _.findLastIndex = createPredicateIndexFinder(-1);

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iteratee, context) {
    iteratee = cb(iteratee, context, 1);
    var value = iteratee(obj);
    var low = 0, high = getLength(array);
    while (low < high) {
      var mid = Math.floor((low + high) / 2);
      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
    }
    return low;
  };

  // Generator function to create the indexOf and lastIndexOf functions
  function createIndexFinder(dir, predicateFind, sortedIndex) {
    return function(array, item, idx) {
      var i = 0, length = getLength(array);
      if (typeof idx == 'number') {
        if (dir > 0) {
            i = idx >= 0 ? idx : Math.max(idx + length, i);
        } else {
            length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
        }
      } else if (sortedIndex && idx && length) {
        idx = sortedIndex(array, item);
        return array[idx] === item ? idx : -1;
      }
      if (item !== item) {
        idx = predicateFind(slice.call(array, i, length), _.isNaN);
        return idx >= 0 ? idx + i : -1;
      }
      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
        if (array[idx] === item) return idx;
      }
      return -1;
    };
  }

  // Return the position of the first occurrence of an item in an array,
  // or -1 if the item is not included in the array.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (stop == null) {
      stop = start || 0;
      start = 0;
    }
    step = step || 1;

    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var range = Array(length);

    for (var idx = 0; idx < length; idx++, start += step) {
      range[idx] = start;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Determines whether to execute a function as a constructor
  // or a normal function with the provided arguments
  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
    var self = baseCreate(sourceFunc.prototype);
    var result = sourceFunc.apply(self, args);
    if (_.isObject(result)) return result;
    return self;
  };

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = function(func, context) {
    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
    var args = slice.call(arguments, 2);
    var bound = function() {
      return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));
    };
    return bound;
  };

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context. _ acts
  // as a placeholder, allowing any combination of arguments to be pre-filled.
  _.partial = function(func) {
    var boundArgs = slice.call(arguments, 1);
    var bound = function() {
      var position = 0, length = boundArgs.length;
      var args = Array(length);
      for (var i = 0; i < length; i++) {
        args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];
      }
      while (position < arguments.length) args.push(arguments[position++]);
      return executeBound(func, bound, this, this, args);
    };
    return bound;
  };

  // Bind a number of an object's methods to that object. Remaining arguments
  // are the method names to be bound. Useful for ensuring that all callbacks
  // defined on an object belong to it.
  _.bindAll = function(obj) {
    var i, length = arguments.length, key;
    if (length <= 1) throw new Error('bindAll must be passed function names');
    for (i = 1; i < length; i++) {
      key = arguments[i];
      obj[key] = _.bind(obj[key], obj);
    }
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memoize = function(key) {
      var cache = memoize.cache;
      var address = '' + (hasher ? hasher.apply(this, arguments) : key);
      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);
      return cache[address];
    };
    memoize.cache = {};
    return memoize;
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){
      return func.apply(null, args);
    }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = _.partial(_.delay, _, 1);

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  _.throttle = function(func, wait, options) {
    var context, args, result;
    var timeout = null;
    var previous = 0;
    if (!options) options = {};
    var later = function() {
      previous = options.leading === false ? 0 : _.now();
      timeout = null;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    };
    return function() {
      var now = _.now();
      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0 || remaining > wait) {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }
        previous = now;
        result = func.apply(context, args);
        if (!timeout) context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, args, context, timestamp, result;

    var later = function() {
      var last = _.now() - timestamp;

      if (last < wait && last >= 0) {
        timeout = setTimeout(later, wait - last);
      } else {
        timeout = null;
        if (!immediate) {
          result = func.apply(context, args);
          if (!timeout) context = args = null;
        }
      }
    };

    return function() {
      context = this;
      args = arguments;
      timestamp = _.now();
      var callNow = immediate && !timeout;
      if (!timeout) timeout = setTimeout(later, wait);
      if (callNow) {
        result = func.apply(context, args);
        context = args = null;
      }

      return result;
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return _.partial(wrapper, func);
  };

  // Returns a negated version of the passed-in predicate.
  _.negate = function(predicate) {
    return function() {
      return !predicate.apply(this, arguments);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var args = arguments;
    var start = args.length - 1;
    return function() {
      var i = start;
      var result = args[start].apply(this, arguments);
      while (i--) result = args[i].call(this, result);
      return result;
    };
  };

  // Returns a function that will only be executed on and after the Nth call.
  _.after = function(times, func) {
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Returns a function that will only be executed up to (but not including) the Nth call.
  _.before = function(times, func) {
    var memo;
    return function() {
      if (--times > 0) {
        memo = func.apply(this, arguments);
      }
      if (times <= 1) func = null;
      return memo;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = _.partial(_.before, 2);

  // Object Functions
  // ----------------

  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
                      'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

  function collectNonEnumProps(obj, keys) {
    var nonEnumIdx = nonEnumerableProps.length;
    var constructor = obj.constructor;
    var proto = (_.isFunction(constructor) && constructor.prototype) || ObjProto;

    // Constructor is a special case.
    var prop = 'constructor';
    if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);

    while (nonEnumIdx--) {
      prop = nonEnumerableProps[nonEnumIdx];
      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
        keys.push(prop);
      }
    }
  }

  // Retrieve the names of an object's own properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = function(obj) {
    if (!_.isObject(obj)) return [];
    if (nativeKeys) return nativeKeys(obj);
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve all the property names of an object.
  _.allKeys = function(obj) {
    if (!_.isObject(obj)) return [];
    var keys = [];
    for (var key in obj) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };

  // Returns the results of applying the iteratee to each element of the object
  // In contrast to _.map it returns an object
  _.mapObject = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys =  _.keys(obj),
          length = keys.length,
          results = {},
          currentKey;
      for (var index = 0; index < length; index++) {
        currentKey = keys[index];
        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
      }
      return results;
  };

  // Convert an object into a list of `[key, value]` pairs.
  _.pairs = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [keys[i], obj[keys[i]]];
    }
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = createAssigner(_.allKeys);

  // Assigns a given object with all the own properties in the passed-in object(s)
  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
  _.extendOwn = _.assign = createAssigner(_.keys);

  // Returns the first key on an object that passes a predicate test
  _.findKey = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = _.keys(obj), key;
    for (var i = 0, length = keys.length; i < length; i++) {
      key = keys[i];
      if (predicate(obj[key], key, obj)) return key;
    }
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(object, oiteratee, context) {
    var result = {}, obj = object, iteratee, keys;
    if (obj == null) return result;
    if (_.isFunction(oiteratee)) {
      keys = _.allKeys(obj);
      iteratee = optimizeCb(oiteratee, context);
    } else {
      keys = flatten(arguments, false, false, 1);
      iteratee = function(value, key, obj) { return key in obj; };
      obj = Object(obj);
    }
    for (var i = 0, length = keys.length; i < length; i++) {
      var key = keys[i];
      var value = obj[key];
      if (iteratee(value, key, obj)) result[key] = value;
    }
    return result;
  };

   // Return a copy of the object without the blacklisted properties.
  _.omit = function(obj, iteratee, context) {
    if (_.isFunction(iteratee)) {
      iteratee = _.negate(iteratee);
    } else {
      var keys = _.map(flatten(arguments, false, false, 1), String);
      iteratee = function(value, key) {
        return !_.contains(keys, key);
      };
    }
    return _.pick(obj, iteratee, context);
  };

  // Fill in a given object with default properties.
  _.defaults = createAssigner(_.allKeys, true);

  // Creates an object that inherits from the given prototype object.
  // If additional properties are provided then they will be added to the
  // created object.
  _.create = function(prototype, props) {
    var result = baseCreate(prototype);
    if (props) _.extendOwn(result, props);
    return result;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Returns whether an object has a given set of `key:value` pairs.
  _.isMatch = function(object, attrs) {
    var keys = _.keys(attrs), length = keys.length;
    if (object == null) return !length;
    var obj = Object(object);
    for (var i = 0; i < length; i++) {
      var key = keys[i];
      if (attrs[key] !== obj[key] || !(key in obj)) return false;
    }
    return true;
  };


  // Internal recursive comparison function for `isEqual`.
  var eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a === 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className !== toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
      case '[object RegExp]':
      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return '' + a === '' + b;
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive.
        // Object(NaN) is equivalent to NaN
        if (+a !== +a) return +b !== +b;
        // An `egal` comparison is performed for other numeric values.
        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a === +b;
    }

    var areArrays = className === '[object Array]';
    if (!areArrays) {
      if (typeof a != 'object' || typeof b != 'object') return false;

      // Objects with different constructors are not equivalent, but `Object`s or `Array`s
      // from different frames are.
      var aCtor = a.constructor, bCtor = b.constructor;
      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
                               _.isFunction(bCtor) && bCtor instanceof bCtor)
                          && ('constructor' in a && 'constructor' in b)) {
        return false;
      }
    }
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

    // Initializing stack of traversed objects.
    // It's done here since we only need them for objects and arrays comparison.
    aStack = aStack || [];
    bStack = bStack || [];
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] === a) return bStack[length] === b;
    }

    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);

    // Recursively compare objects and arrays.
    if (areArrays) {
      // Compare array lengths to determine if a deep comparison is necessary.
      length = a.length;
      if (length !== b.length) return false;
      // Deep compare the contents, ignoring non-numeric properties.
      while (length--) {
        if (!eq(a[length], b[length], aStack, bStack)) return false;
      }
    } else {
      // Deep compare objects.
      var keys = _.keys(a), key;
      length = keys.length;
      // Ensure that both objects contain the same number of properties before comparing deep equality.
      if (_.keys(b).length !== length) return false;
      while (length--) {
        // Deep compare each member
        key = keys[length];
        if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return true;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
    return _.keys(obj).length === 0;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) === '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    var type = typeof obj;
    return type === 'function' || type === 'object' && !!obj;
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.
  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) === '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE < 9), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return _.has(obj, 'callee');
    };
  }

  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
  // IE 11 (#1621), and in Safari 8 (#1929).
  if (typeof /./ != 'function' && typeof Int8Array != 'object') {
    _.isFunction = function(obj) {
      return typeof obj == 'function' || false;
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
  _.isNaN = function(obj) {
    return _.isNumber(obj) && obj !== +obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, key) {
    return obj != null && hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iteratees.
  _.identity = function(value) {
    return value;
  };

  // Predicate-generating functions. Often useful outside of Underscore.
  _.constant = function(value) {
    return function() {
      return value;
    };
  };

  _.noop = function(){};

  _.property = property;

  // Generates a function for a given object that returns a given property.
  _.propertyOf = function(obj) {
    return obj == null ? function(){} : function(key) {
      return obj[key];
    };
  };

  // Returns a predicate for checking whether an object has a given set of
  // `key:value` pairs.
  _.matcher = _.matches = function(attrs) {
    attrs = _.extendOwn({}, attrs);
    return function(obj) {
      return _.isMatch(obj, attrs);
    };
  };

  // Run a function **n** times.
  _.times = function(n, iteratee, context) {
    var accum = Array(Math.max(0, n));
    iteratee = optimizeCb(iteratee, context, 1);
    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // A (possibly faster) way to get the current timestamp as an integer.
  _.now = Date.now || function() {
    return new Date().getTime();
  };

   // List of HTML entities for escaping.
  var escapeMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#x27;',
    '`': '&#x60;'
  };
  var unescapeMap = _.invert(escapeMap);

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  var createEscaper = function(map) {
    var escaper = function(match) {
      return map[match];
    };
    // Regexes for identifying a key that needs to be escaped
    var source = '(?:' + _.keys(map).join('|') + ')';
    var testRegexp = RegExp(source);
    var replaceRegexp = RegExp(source, 'g');
    return function(string) {
      string = string == null ? '' : '' + string;
      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
    };
  };
  _.escape = createEscaper(escapeMap);
  _.unescape = createEscaper(unescapeMap);

  // If the value of the named `property` is a function then invoke it with the
  // `object` as context; otherwise, return it.
  _.result = function(object, property, fallback) {
    var value = object == null ? void 0 : object[property];
    if (value === void 0) {
      value = fallback;
    }
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'":      "'",
    '\\':     '\\',
    '\r':     'r',
    '\n':     'n',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escaper = /\\|'|\r|\n|\u2028|\u2029/g;

  var escapeChar = function(match) {
    return '\\' + escapes[match];
  };

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  // NB: `oldSettings` only exists for backwards compatibility.
  _.template = function(text, settings, oldSettings) {
    if (!settings && oldSettings) settings = oldSettings;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset).replace(escaper, escapeChar);
      index = offset + match.length;

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      } else if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      } else if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }

      // Adobe VMs need the match returned to produce the correct offest.
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + 'return __p;\n';

    try {
      var render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled source as a convenience for precompilation.
    var argument = settings.variable || 'obj';
    template.source = 'function(' + argument + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function. Start chaining a wrapped Underscore object.
  _.chain = function(obj) {
    var instance = _(obj);
    instance._chain = true;
    return instance;
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var result = function(instance, obj) {
    return instance._chain ? _(obj).chain() : obj;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    _.each(_.functions(obj), function(name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result(this, func.apply(_, args));
      };
    });
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
      return result(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  _.each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return result(this, method.apply(this._wrapped, arguments));
    };
  });

  // Extracts the result from a wrapped and chained object.
  _.prototype.value = function() {
    return this._wrapped;
  };

  // Provide unwrapping proxy for some methods used in engine operations
  // such as arithmetic and JSON stringification.
  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;

  _.prototype.toString = function() {
    return '' + this._wrapped;
  };

  // AMD registration happens at the end for compatibility with AMD loaders
  // that may not enforce next-turn semantics on modules. Even though general
  // practice for AMD registration is to be anonymous, underscore registers
  // as a named module because, like jQuery, it is a base library that is
  // popular enough to be bundled in a third party lib, but not be part of
  // an AMD load request. Those cases could generate an error when an
  // anonymous define() is called outside of a loader request.
  if (typeof define === 'function' && define.amd) {
    define('underscore', [], function() {
      return _;
    });
  }
}.call(this));

},{}],448:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function (require) {

	var makePromise = require('./makePromise');
	var Scheduler = require('./Scheduler');
	var async = require('./env').asap;

	return makePromise({
		scheduler: new Scheduler(async)
	});

});
})(typeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); });

},{"./Scheduler":449,"./env":461,"./makePromise":464}],449:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	// Credit to Twisol (https://github.com/Twisol) for suggesting
	// this type of extensible queue + trampoline approach for next-tick conflation.

	/**
	 * Async task scheduler
	 * @param {function} async function to schedule a single async function
	 * @constructor
	 */
	function Scheduler(async) {
		this._async = async;
		this._running = false;

		this._queue = this;
		this._queueLen = 0;
		this._afterQueue = {};
		this._afterQueueLen = 0;

		var self = this;
		this.drain = function() {
			self._drain();
		};
	}

	/**
	 * Enqueue a task
	 * @param {{ run:function }} task
	 */
	Scheduler.prototype.enqueue = function(task) {
		this._queue[this._queueLen++] = task;
		this.run();
	};

	/**
	 * Enqueue a task to run after the main task queue
	 * @param {{ run:function }} task
	 */
	Scheduler.prototype.afterQueue = function(task) {
		this._afterQueue[this._afterQueueLen++] = task;
		this.run();
	};

	Scheduler.prototype.run = function() {
		if (!this._running) {
			this._running = true;
			this._async(this.drain);
		}
	};

	/**
	 * Drain the handler queue entirely, and then the after queue
	 */
	Scheduler.prototype._drain = function() {
		var i = 0;
		for (; i < this._queueLen; ++i) {
			this._queue[i].run();
			this._queue[i] = void 0;
		}

		this._queueLen = 0;
		this._running = false;

		for (i = 0; i < this._afterQueueLen; ++i) {
			this._afterQueue[i].run();
			this._afterQueue[i] = void 0;
		}

		this._afterQueueLen = 0;
	};

	return Scheduler;

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));

},{}],450:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	/**
	 * Custom error type for promises rejected by promise.timeout
	 * @param {string} message
	 * @constructor
	 */
	function TimeoutError (message) {
		Error.call(this);
		this.message = message;
		this.name = TimeoutError.name;
		if (typeof Error.captureStackTrace === 'function') {
			Error.captureStackTrace(this, TimeoutError);
		}
	}

	TimeoutError.prototype = Object.create(Error.prototype);
	TimeoutError.prototype.constructor = TimeoutError;

	return TimeoutError;
});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));
},{}],451:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	makeApply.tryCatchResolve = tryCatchResolve;

	return makeApply;

	function makeApply(Promise, call) {
		if(arguments.length < 2) {
			call = tryCatchResolve;
		}

		return apply;

		function apply(f, thisArg, args) {
			var p = Promise._defer();
			var l = args.length;
			var params = new Array(l);
			callAndResolve({ f:f, thisArg:thisArg, args:args, params:params, i:l-1, call:call }, p._handler);

			return p;
		}

		function callAndResolve(c, h) {
			if(c.i < 0) {
				return call(c.f, c.thisArg, c.params, h);
			}

			var handler = Promise._handler(c.args[c.i]);
			handler.fold(callAndResolveNext, c, void 0, h);
		}

		function callAndResolveNext(c, x, h) {
			c.params[c.i] = x;
			c.i -= 1;
			callAndResolve(c, h);
		}
	}

	function tryCatchResolve(f, thisArg, args, resolver) {
		try {
			resolver.resolve(f.apply(thisArg, args));
		} catch(e) {
			resolver.reject(e);
		}
	}

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));



},{}],452:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function(require) {

	var state = require('../state');
	var applier = require('../apply');

	return function array(Promise) {

		var applyFold = applier(Promise);
		var toPromise = Promise.resolve;
		var all = Promise.all;

		var ar = Array.prototype.reduce;
		var arr = Array.prototype.reduceRight;
		var slice = Array.prototype.slice;

		// Additional array combinators

		Promise.any = any;
		Promise.some = some;
		Promise.settle = settle;

		Promise.map = map;
		Promise.filter = filter;
		Promise.reduce = reduce;
		Promise.reduceRight = reduceRight;

		/**
		 * When this promise fulfills with an array, do
		 * onFulfilled.apply(void 0, array)
		 * @param {function} onFulfilled function to apply
		 * @returns {Promise} promise for the result of applying onFulfilled
		 */
		Promise.prototype.spread = function(onFulfilled) {
			return this.then(all).then(function(array) {
				return onFulfilled.apply(this, array);
			});
		};

		return Promise;

		/**
		 * One-winner competitive race.
		 * Return a promise that will fulfill when one of the promises
		 * in the input array fulfills, or will reject when all promises
		 * have rejected.
		 * @param {array} promises
		 * @returns {Promise} promise for the first fulfilled value
		 */
		function any(promises) {
			var p = Promise._defer();
			var resolver = p._handler;
			var l = promises.length>>>0;

			var pending = l;
			var errors = [];

			for (var h, x, i = 0; i < l; ++i) {
				x = promises[i];
				if(x === void 0 && !(i in promises)) {
					--pending;
					continue;
				}

				h = Promise._handler(x);
				if(h.state() > 0) {
					resolver.become(h);
					Promise._visitRemaining(promises, i, h);
					break;
				} else {
					h.visit(resolver, handleFulfill, handleReject);
				}
			}

			if(pending === 0) {
				resolver.reject(new RangeError('any(): array must not be empty'));
			}

			return p;

			function handleFulfill(x) {
				/*jshint validthis:true*/
				errors = null;
				this.resolve(x); // this === resolver
			}

			function handleReject(e) {
				/*jshint validthis:true*/
				if(this.resolved) { // this === resolver
					return;
				}

				errors.push(e);
				if(--pending === 0) {
					this.reject(errors);
				}
			}
		}

		/**
		 * N-winner competitive race
		 * Return a promise that will fulfill when n input promises have
		 * fulfilled, or will reject when it becomes impossible for n
		 * input promises to fulfill (ie when promises.length - n + 1
		 * have rejected)
		 * @param {array} promises
		 * @param {number} n
		 * @returns {Promise} promise for the earliest n fulfillment values
		 *
		 * @deprecated
		 */
		function some(promises, n) {
			/*jshint maxcomplexity:7*/
			var p = Promise._defer();
			var resolver = p._handler;

			var results = [];
			var errors = [];

			var l = promises.length>>>0;
			var nFulfill = 0;
			var nReject;
			var x, i; // reused in both for() loops

			// First pass: count actual array items
			for(i=0; i<l; ++i) {
				x = promises[i];
				if(x === void 0 && !(i in promises)) {
					continue;
				}
				++nFulfill;
			}

			// Compute actual goals
			n = Math.max(n, 0);
			nReject = (nFulfill - n + 1);
			nFulfill = Math.min(n, nFulfill);

			if(n > nFulfill) {
				resolver.reject(new RangeError('some(): array must contain at least '
				+ n + ' item(s), but had ' + nFulfill));
			} else if(nFulfill === 0) {
				resolver.resolve(results);
			}

			// Second pass: observe each array item, make progress toward goals
			for(i=0; i<l; ++i) {
				x = promises[i];
				if(x === void 0 && !(i in promises)) {
					continue;
				}

				Promise._handler(x).visit(resolver, fulfill, reject, resolver.notify);
			}

			return p;

			function fulfill(x) {
				/*jshint validthis:true*/
				if(this.resolved) { // this === resolver
					return;
				}

				results.push(x);
				if(--nFulfill === 0) {
					errors = null;
					this.resolve(results);
				}
			}

			function reject(e) {
				/*jshint validthis:true*/
				if(this.resolved) { // this === resolver
					return;
				}

				errors.push(e);
				if(--nReject === 0) {
					results = null;
					this.reject(errors);
				}
			}
		}

		/**
		 * Apply f to the value of each promise in a list of promises
		 * and return a new list containing the results.
		 * @param {array} promises
		 * @param {function(x:*, index:Number):*} f mapping function
		 * @returns {Promise}
		 */
		function map(promises, f) {
			return Promise._traverse(f, promises);
		}

		/**
		 * Filter the provided array of promises using the provided predicate.  Input may
		 * contain promises and values
		 * @param {Array} promises array of promises and values
		 * @param {function(x:*, index:Number):boolean} predicate filtering predicate.
		 *  Must return truthy (or promise for truthy) for items to retain.
		 * @returns {Promise} promise that will fulfill with an array containing all items
		 *  for which predicate returned truthy.
		 */
		function filter(promises, predicate) {
			var a = slice.call(promises);
			return Promise._traverse(predicate, a).then(function(keep) {
				return filterSync(a, keep);
			});
		}

		function filterSync(promises, keep) {
			// Safe because we know all promises have fulfilled if we've made it this far
			var l = keep.length;
			var filtered = new Array(l);
			for(var i=0, j=0; i<l; ++i) {
				if(keep[i]) {
					filtered[j++] = Promise._handler(promises[i]).value;
				}
			}
			filtered.length = j;
			return filtered;

		}

		/**
		 * Return a promise that will always fulfill with an array containing
		 * the outcome states of all input promises.  The returned promise
		 * will never reject.
		 * @param {Array} promises
		 * @returns {Promise} promise for array of settled state descriptors
		 */
		function settle(promises) {
			return all(promises.map(settleOne));
		}

		function settleOne(p) {
			var h = Promise._handler(p);
			if(h.state() === 0) {
				return toPromise(p).then(state.fulfilled, state.rejected);
			}

			h._unreport();
			return state.inspect(h);
		}

		/**
		 * Traditional reduce function, similar to `Array.prototype.reduce()`, but
		 * input may contain promises and/or values, and reduceFunc
		 * may return either a value or a promise, *and* initialValue may
		 * be a promise for the starting value.
		 * @param {Array|Promise} promises array or promise for an array of anything,
		 *      may contain a mix of promises and values.
		 * @param {function(accumulated:*, x:*, index:Number):*} f reduce function
		 * @returns {Promise} that will resolve to the final reduced value
		 */
		function reduce(promises, f /*, initialValue */) {
			return arguments.length > 2 ? ar.call(promises, liftCombine(f), arguments[2])
					: ar.call(promises, liftCombine(f));
		}

		/**
		 * Traditional reduce function, similar to `Array.prototype.reduceRight()`, but
		 * input may contain promises and/or values, and reduceFunc
		 * may return either a value or a promise, *and* initialValue may
		 * be a promise for the starting value.
		 * @param {Array|Promise} promises array or promise for an array of anything,
		 *      may contain a mix of promises and values.
		 * @param {function(accumulated:*, x:*, index:Number):*} f reduce function
		 * @returns {Promise} that will resolve to the final reduced value
		 */
		function reduceRight(promises, f /*, initialValue */) {
			return arguments.length > 2 ? arr.call(promises, liftCombine(f), arguments[2])
					: arr.call(promises, liftCombine(f));
		}

		function liftCombine(f) {
			return function(z, x, i) {
				return applyFold(f, void 0, [z,x,i]);
			};
		}
	};

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));

},{"../apply":451,"../state":465}],453:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	return function flow(Promise) {

		var resolve = Promise.resolve;
		var reject = Promise.reject;
		var origCatch = Promise.prototype['catch'];

		/**
		 * Handle the ultimate fulfillment value or rejection reason, and assume
		 * responsibility for all errors.  If an error propagates out of result
		 * or handleFatalError, it will be rethrown to the host, resulting in a
		 * loud stack track on most platforms and a crash on some.
		 * @param {function?} onResult
		 * @param {function?} onError
		 * @returns {undefined}
		 */
		Promise.prototype.done = function(onResult, onError) {
			this._handler.visit(this._handler.receiver, onResult, onError);
		};

		/**
		 * Add Error-type and predicate matching to catch.  Examples:
		 * promise.catch(TypeError, handleTypeError)
		 *   .catch(predicate, handleMatchedErrors)
		 *   .catch(handleRemainingErrors)
		 * @param onRejected
		 * @returns {*}
		 */
		Promise.prototype['catch'] = Promise.prototype.otherwise = function(onRejected) {
			if (arguments.length < 2) {
				return origCatch.call(this, onRejected);
			}

			if(typeof onRejected !== 'function') {
				return this.ensure(rejectInvalidPredicate);
			}

			return origCatch.call(this, createCatchFilter(arguments[1], onRejected));
		};

		/**
		 * Wraps the provided catch handler, so that it will only be called
		 * if the predicate evaluates truthy
		 * @param {?function} handler
		 * @param {function} predicate
		 * @returns {function} conditional catch handler
		 */
		function createCatchFilter(handler, predicate) {
			return function(e) {
				return evaluatePredicate(e, predicate)
					? handler.call(this, e)
					: reject(e);
			};
		}

		/**
		 * Ensures that onFulfilledOrRejected will be called regardless of whether
		 * this promise is fulfilled or rejected.  onFulfilledOrRejected WILL NOT
		 * receive the promises' value or reason.  Any returned value will be disregarded.
		 * onFulfilledOrRejected may throw or return a rejected promise to signal
		 * an additional error.
		 * @param {function} handler handler to be called regardless of
		 *  fulfillment or rejection
		 * @returns {Promise}
		 */
		Promise.prototype['finally'] = Promise.prototype.ensure = function(handler) {
			if(typeof handler !== 'function') {
				return this;
			}

			return this.then(function(x) {
				return runSideEffect(handler, this, identity, x);
			}, function(e) {
				return runSideEffect(handler, this, reject, e);
			});
		};

		function runSideEffect (handler, thisArg, propagate, value) {
			var result = handler.call(thisArg);
			return maybeThenable(result)
				? propagateValue(result, propagate, value)
				: propagate(value);
		}

		function propagateValue (result, propagate, x) {
			return resolve(result).then(function () {
				return propagate(x);
			});
		}

		/**
		 * Recover from a failure by returning a defaultValue.  If defaultValue
		 * is a promise, it's fulfillment value will be used.  If defaultValue is
		 * a promise that rejects, the returned promise will reject with the
		 * same reason.
		 * @param {*} defaultValue
		 * @returns {Promise} new promise
		 */
		Promise.prototype['else'] = Promise.prototype.orElse = function(defaultValue) {
			return this.then(void 0, function() {
				return defaultValue;
			});
		};

		/**
		 * Shortcut for .then(function() { return value; })
		 * @param  {*} value
		 * @return {Promise} a promise that:
		 *  - is fulfilled if value is not a promise, or
		 *  - if value is a promise, will fulfill with its value, or reject
		 *    with its reason.
		 */
		Promise.prototype['yield'] = function(value) {
			return this.then(function() {
				return value;
			});
		};

		/**
		 * Runs a side effect when this promise fulfills, without changing the
		 * fulfillment value.
		 * @param {function} onFulfilledSideEffect
		 * @returns {Promise}
		 */
		Promise.prototype.tap = function(onFulfilledSideEffect) {
			return this.then(onFulfilledSideEffect)['yield'](this);
		};

		return Promise;
	};

	function rejectInvalidPredicate() {
		throw new TypeError('catch predicate must be a function');
	}

	function evaluatePredicate(e, predicate) {
		return isError(predicate) ? e instanceof predicate : predicate(e);
	}

	function isError(predicate) {
		return predicate === Error
			|| (predicate != null && predicate.prototype instanceof Error);
	}

	function maybeThenable(x) {
		return (typeof x === 'object' || typeof x === 'function') && x !== null;
	}

	function identity(x) {
		return x;
	}

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));

},{}],454:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */
/** @author Jeff Escalante */

(function(define) { 'use strict';
define(function() {

	return function fold(Promise) {

		Promise.prototype.fold = function(f, z) {
			var promise = this._beget();

			this._handler.fold(function(z, x, to) {
				Promise._handler(z).fold(function(x, z, to) {
					to.resolve(f.call(this, z, x));
				}, x, this, to);
			}, z, promise._handler.receiver, promise._handler);

			return promise;
		};

		return Promise;
	};

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));

},{}],455:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function(require) {

	var inspect = require('../state').inspect;

	return function inspection(Promise) {

		Promise.prototype.inspect = function() {
			return inspect(Promise._handler(this));
		};

		return Promise;
	};

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));

},{"../state":465}],456:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	return function generate(Promise) {

		var resolve = Promise.resolve;

		Promise.iterate = iterate;
		Promise.unfold = unfold;

		return Promise;

		/**
		 * @deprecated Use github.com/cujojs/most streams and most.iterate
		 * Generate a (potentially infinite) stream of promised values:
		 * x, f(x), f(f(x)), etc. until condition(x) returns true
		 * @param {function} f function to generate a new x from the previous x
		 * @param {function} condition function that, given the current x, returns
		 *  truthy when the iterate should stop
		 * @param {function} handler function to handle the value produced by f
		 * @param {*|Promise} x starting value, may be a promise
		 * @return {Promise} the result of the last call to f before
		 *  condition returns true
		 */
		function iterate(f, condition, handler, x) {
			return unfold(function(x) {
				return [x, f(x)];
			}, condition, handler, x);
		}

		/**
		 * @deprecated Use github.com/cujojs/most streams and most.unfold
		 * Generate a (potentially infinite) stream of promised values
		 * by applying handler(generator(seed)) iteratively until
		 * condition(seed) returns true.
		 * @param {function} unspool function that generates a [value, newSeed]
		 *  given a seed.
		 * @param {function} condition function that, given the current seed, returns
		 *  truthy when the unfold should stop
		 * @param {function} handler function to handle the value produced by unspool
		 * @param x {*|Promise} starting value, may be a promise
		 * @return {Promise} the result of the last value produced by unspool before
		 *  condition returns true
		 */
		function unfold(unspool, condition, handler, x) {
			return resolve(x).then(function(seed) {
				return resolve(condition(seed)).then(function(done) {
					return done ? seed : resolve(unspool(seed)).spread(next);
				});
			});

			function next(item, newSeed) {
				return resolve(handler(item)).then(function() {
					return unfold(unspool, condition, handler, newSeed);
				});
			}
		}
	};

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));

},{}],457:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	return function progress(Promise) {

		/**
		 * @deprecated
		 * Register a progress handler for this promise
		 * @param {function} onProgress
		 * @returns {Promise}
		 */
		Promise.prototype.progress = function(onProgress) {
			return this.then(void 0, void 0, onProgress);
		};

		return Promise;
	};

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));

},{}],458:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function(require) {

	var env = require('../env');
	var TimeoutError = require('../TimeoutError');

	function setTimeout(f, ms, x, y) {
		return env.setTimer(function() {
			f(x, y, ms);
		}, ms);
	}

	return function timed(Promise) {
		/**
		 * Return a new promise whose fulfillment value is revealed only
		 * after ms milliseconds
		 * @param {number} ms milliseconds
		 * @returns {Promise}
		 */
		Promise.prototype.delay = function(ms) {
			var p = this._beget();
			this._handler.fold(handleDelay, ms, void 0, p._handler);
			return p;
		};

		function handleDelay(ms, x, h) {
			setTimeout(resolveDelay, ms, x, h);
		}

		function resolveDelay(x, h) {
			h.resolve(x);
		}

		/**
		 * Return a new promise that rejects after ms milliseconds unless
		 * this promise fulfills earlier, in which case the returned promise
		 * fulfills with the same value.
		 * @param {number} ms milliseconds
		 * @param {Error|*=} reason optional rejection reason to use, defaults
		 *   to a TimeoutError if not provided
		 * @returns {Promise}
		 */
		Promise.prototype.timeout = function(ms, reason) {
			var p = this._beget();
			var h = p._handler;

			var t = setTimeout(onTimeout, ms, reason, p._handler);

			this._handler.visit(h,
				function onFulfill(x) {
					env.clearTimer(t);
					this.resolve(x); // this = h
				},
				function onReject(x) {
					env.clearTimer(t);
					this.reject(x); // this = h
				},
				h.notify);

			return p;
		};

		function onTimeout(reason, h, ms) {
			var e = typeof reason === 'undefined'
				? new TimeoutError('timed out after ' + ms + 'ms')
				: reason;
			h.reject(e);
		}

		return Promise;
	};

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));

},{"../TimeoutError":450,"../env":461}],459:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function(require) {

	var setTimer = require('../env').setTimer;
	var format = require('../format');

	return function unhandledRejection(Promise) {

		var logError = noop;
		var logInfo = noop;
		var localConsole;

		if(typeof console !== 'undefined') {
			// Alias console to prevent things like uglify's drop_console option from
			// removing console.log/error. Unhandled rejections fall into the same
			// category as uncaught exceptions, and build tools shouldn't silence them.
			localConsole = console;
			logError = typeof localConsole.error !== 'undefined'
				? function (e) { localConsole.error(e); }
				: function (e) { localConsole.log(e); };

			logInfo = typeof localConsole.info !== 'undefined'
				? function (e) { localConsole.info(e); }
				: function (e) { localConsole.log(e); };
		}

		Promise.onPotentiallyUnhandledRejection = function(rejection) {
			enqueue(report, rejection);
		};

		Promise.onPotentiallyUnhandledRejectionHandled = function(rejection) {
			enqueue(unreport, rejection);
		};

		Promise.onFatalRejection = function(rejection) {
			enqueue(throwit, rejection.value);
		};

		var tasks = [];
		var reported = [];
		var running = null;

		function report(r) {
			if(!r.handled) {
				reported.push(r);
				logError('Potentially unhandled rejection [' + r.id + '] ' + format.formatError(r.value));
			}
		}

		function unreport(r) {
			var i = reported.indexOf(r);
			if(i >= 0) {
				reported.splice(i, 1);
				logInfo('Handled previous rejection [' + r.id + '] ' + format.formatObject(r.value));
			}
		}

		function enqueue(f, x) {
			tasks.push(f, x);
			if(running === null) {
				running = setTimer(flush, 0);
			}
		}

		function flush() {
			running = null;
			while(tasks.length > 0) {
				tasks.shift()(tasks.shift());
			}
		}

		return Promise;
	};

	function throwit(e) {
		throw e;
	}

	function noop() {}

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));

},{"../env":461,"../format":462}],460:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	return function addWith(Promise) {
		/**
		 * Returns a promise whose handlers will be called with `this` set to
		 * the supplied receiver.  Subsequent promises derived from the
		 * returned promise will also have their handlers called with receiver
		 * as `this`. Calling `with` with undefined or no arguments will return
		 * a promise whose handlers will again be called in the usual Promises/A+
		 * way (no `this`) thus safely undoing any previous `with` in the
		 * promise chain.
		 *
		 * WARNING: Promises returned from `with`/`withThis` are NOT Promises/A+
		 * compliant, specifically violating 2.2.5 (http://promisesaplus.com/#point-41)
		 *
		 * @param {object} receiver `this` value for all handlers attached to
		 *  the returned promise.
		 * @returns {Promise}
		 */
		Promise.prototype['with'] = Promise.prototype.withThis = function(receiver) {
			var p = this._beget();
			var child = p._handler;
			child.receiver = receiver;
			this._handler.chain(child, receiver);
			return p;
		};

		return Promise;
	};

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));


},{}],461:[function(require,module,exports){
(function (process){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

/*global process,document,setTimeout,clearTimeout,MutationObserver,WebKitMutationObserver*/
(function(define) { 'use strict';
define(function(require) {
	/*jshint maxcomplexity:6*/

	// Sniff "best" async scheduling option
	// Prefer process.nextTick or MutationObserver, then check for
	// setTimeout, and finally vertx, since its the only env that doesn't
	// have setTimeout

	var MutationObs;
	var capturedSetTimeout = typeof setTimeout !== 'undefined' && setTimeout;

	// Default env
	var setTimer = function(f, ms) { return setTimeout(f, ms); };
	var clearTimer = function(t) { return clearTimeout(t); };
	var asap = function (f) { return capturedSetTimeout(f, 0); };

	// Detect specific env
	if (isNode()) { // Node
		asap = function (f) { return process.nextTick(f); };

	} else if (MutationObs = hasMutationObserver()) { // Modern browser
		asap = initMutationObserver(MutationObs);

	} else if (!capturedSetTimeout) { // vert.x
		var vertxRequire = require;
		var vertx = vertxRequire('vertx');
		setTimer = function (f, ms) { return vertx.setTimer(ms, f); };
		clearTimer = vertx.cancelTimer;
		asap = vertx.runOnLoop || vertx.runOnContext;
	}

	return {
		setTimer: setTimer,
		clearTimer: clearTimer,
		asap: asap
	};

	function isNode () {
		return typeof process !== 'undefined' &&
			Object.prototype.toString.call(process) === '[object process]';
	}

	function hasMutationObserver () {
		return (typeof MutationObserver === 'function' && MutationObserver) ||
			(typeof WebKitMutationObserver === 'function' && WebKitMutationObserver);
	}

	function initMutationObserver(MutationObserver) {
		var scheduled;
		var node = document.createTextNode('');
		var o = new MutationObserver(run);
		o.observe(node, { characterData: true });

		function run() {
			var f = scheduled;
			scheduled = void 0;
			f();
		}

		var i = 0;
		return function (f) {
			scheduled = f;
			node.data = (i ^= 1);
		};
	}
});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));

}).call(this,require('_process'))
},{"_process":406}],462:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	return {
		formatError: formatError,
		formatObject: formatObject,
		tryStringify: tryStringify
	};

	/**
	 * Format an error into a string.  If e is an Error and has a stack property,
	 * it's returned.  Otherwise, e is formatted using formatObject, with a
	 * warning added about e not being a proper Error.
	 * @param {*} e
	 * @returns {String} formatted string, suitable for output to developers
	 */
	function formatError(e) {
		var s = typeof e === 'object' && e !== null && (e.stack || e.message) ? e.stack || e.message : formatObject(e);
		return e instanceof Error ? s : s + ' (WARNING: non-Error used)';
	}

	/**
	 * Format an object, detecting "plain" objects and running them through
	 * JSON.stringify if possible.
	 * @param {Object} o
	 * @returns {string}
	 */
	function formatObject(o) {
		var s = String(o);
		if(s === '[object Object]' && typeof JSON !== 'undefined') {
			s = tryStringify(o, s);
		}
		return s;
	}

	/**
	 * Try to return the result of JSON.stringify(x).  If that fails, return
	 * defaultValue
	 * @param {*} x
	 * @param {*} defaultValue
	 * @returns {String|*} JSON.stringify(x) or defaultValue
	 */
	function tryStringify(x, defaultValue) {
		try {
			return JSON.stringify(x);
		} catch(e) {
			return defaultValue;
		}
	}

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));

},{}],463:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	return function liftAll(liftOne, combine, dst, src) {
		if(typeof combine === 'undefined') {
			combine = defaultCombine;
		}

		return Object.keys(src).reduce(function(dst, key) {
			var f = src[key];
			return typeof f === 'function' ? combine(dst, liftOne(f), key) : dst;
		}, typeof dst === 'undefined' ? defaultDst(src) : dst);
	};

	function defaultCombine(o, f, k) {
		o[k] = f;
		return o;
	}

	function defaultDst(src) {
		return typeof src === 'function' ? src.bind() : Object.create(src);
	}
});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));

},{}],464:[function(require,module,exports){
(function (process){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	return function makePromise(environment) {

		var tasks = environment.scheduler;
		var emitRejection = initEmitRejection();

		var objectCreate = Object.create ||
			function(proto) {
				function Child() {}
				Child.prototype = proto;
				return new Child();
			};

		/**
		 * Create a promise whose fate is determined by resolver
		 * @constructor
		 * @returns {Promise} promise
		 * @name Promise
		 */
		function Promise(resolver, handler) {
			this._handler = resolver === Handler ? handler : init(resolver);
		}

		/**
		 * Run the supplied resolver
		 * @param resolver
		 * @returns {Pending}
		 */
		function init(resolver) {
			var handler = new Pending();

			try {
				resolver(promiseResolve, promiseReject, promiseNotify);
			} catch (e) {
				promiseReject(e);
			}

			return handler;

			/**
			 * Transition from pre-resolution state to post-resolution state, notifying
			 * all listeners of the ultimate fulfillment or rejection
			 * @param {*} x resolution value
			 */
			function promiseResolve (x) {
				handler.resolve(x);
			}
			/**
			 * Reject this promise with reason, which will be used verbatim
			 * @param {Error|*} reason rejection reason, strongly suggested
			 *   to be an Error type
			 */
			function promiseReject (reason) {
				handler.reject(reason);
			}

			/**
			 * @deprecated
			 * Issue a progress event, notifying all progress listeners
			 * @param {*} x progress event payload to pass to all listeners
			 */
			function promiseNotify (x) {
				handler.notify(x);
			}
		}

		// Creation

		Promise.resolve = resolve;
		Promise.reject = reject;
		Promise.never = never;

		Promise._defer = defer;
		Promise._handler = getHandler;

		/**
		 * Returns a trusted promise. If x is already a trusted promise, it is
		 * returned, otherwise returns a new trusted Promise which follows x.
		 * @param  {*} x
		 * @return {Promise} promise
		 */
		function resolve(x) {
			return isPromise(x) ? x
				: new Promise(Handler, new Async(getHandler(x)));
		}

		/**
		 * Return a reject promise with x as its reason (x is used verbatim)
		 * @param {*} x
		 * @returns {Promise} rejected promise
		 */
		function reject(x) {
			return new Promise(Handler, new Async(new Rejected(x)));
		}

		/**
		 * Return a promise that remains pending forever
		 * @returns {Promise} forever-pending promise.
		 */
		function never() {
			return foreverPendingPromise; // Should be frozen
		}

		/**
		 * Creates an internal {promise, resolver} pair
		 * @private
		 * @returns {Promise}
		 */
		function defer() {
			return new Promise(Handler, new Pending());
		}

		// Transformation and flow control

		/**
		 * Transform this promise's fulfillment value, returning a new Promise
		 * for the transformed result.  If the promise cannot be fulfilled, onRejected
		 * is called with the reason.  onProgress *may* be called with updates toward
		 * this promise's fulfillment.
		 * @param {function=} onFulfilled fulfillment handler
		 * @param {function=} onRejected rejection handler
		 * @param {function=} onProgress @deprecated progress handler
		 * @return {Promise} new promise
		 */
		Promise.prototype.then = function(onFulfilled, onRejected, onProgress) {
			var parent = this._handler;
			var state = parent.join().state();

			if ((typeof onFulfilled !== 'function' && state > 0) ||
				(typeof onRejected !== 'function' && state < 0)) {
				// Short circuit: value will not change, simply share handler
				return new this.constructor(Handler, parent);
			}

			var p = this._beget();
			var child = p._handler;

			parent.chain(child, parent.receiver, onFulfilled, onRejected, onProgress);

			return p;
		};

		/**
		 * If this promise cannot be fulfilled due to an error, call onRejected to
		 * handle the error. Shortcut for .then(undefined, onRejected)
		 * @param {function?} onRejected
		 * @return {Promise}
		 */
		Promise.prototype['catch'] = function(onRejected) {
			return this.then(void 0, onRejected);
		};

		/**
		 * Creates a new, pending promise of the same type as this promise
		 * @private
		 * @returns {Promise}
		 */
		Promise.prototype._beget = function() {
			return begetFrom(this._handler, this.constructor);
		};

		function begetFrom(parent, Promise) {
			var child = new Pending(parent.receiver, parent.join().context);
			return new Promise(Handler, child);
		}

		// Array combinators

		Promise.all = all;
		Promise.race = race;
		Promise._traverse = traverse;

		/**
		 * Return a promise that will fulfill when all promises in the
		 * input array have fulfilled, or will reject when one of the
		 * promises rejects.
		 * @param {array} promises array of promises
		 * @returns {Promise} promise for array of fulfillment values
		 */
		function all(promises) {
			return traverseWith(snd, null, promises);
		}

		/**
		 * Array<Promise<X>> -> Promise<Array<f(X)>>
		 * @private
		 * @param {function} f function to apply to each promise's value
		 * @param {Array} promises array of promises
		 * @returns {Promise} promise for transformed values
		 */
		function traverse(f, promises) {
			return traverseWith(tryCatch2, f, promises);
		}

		function traverseWith(tryMap, f, promises) {
			var handler = typeof f === 'function' ? mapAt : settleAt;

			var resolver = new Pending();
			var pending = promises.length >>> 0;
			var results = new Array(pending);

			for (var i = 0, x; i < promises.length && !resolver.resolved; ++i) {
				x = promises[i];

				if (x === void 0 && !(i in promises)) {
					--pending;
					continue;
				}

				traverseAt(promises, handler, i, x, resolver);
			}

			if(pending === 0) {
				resolver.become(new Fulfilled(results));
			}

			return new Promise(Handler, resolver);

			function mapAt(i, x, resolver) {
				if(!resolver.resolved) {
					traverseAt(promises, settleAt, i, tryMap(f, x, i), resolver);
				}
			}

			function settleAt(i, x, resolver) {
				results[i] = x;
				if(--pending === 0) {
					resolver.become(new Fulfilled(results));
				}
			}
		}

		function traverseAt(promises, handler, i, x, resolver) {
			if (maybeThenable(x)) {
				var h = getHandlerMaybeThenable(x);
				var s = h.state();

				if (s === 0) {
					h.fold(handler, i, void 0, resolver);
				} else if (s > 0) {
					handler(i, h.value, resolver);
				} else {
					resolver.become(h);
					visitRemaining(promises, i+1, h);
				}
			} else {
				handler(i, x, resolver);
			}
		}

		Promise._visitRemaining = visitRemaining;
		function visitRemaining(promises, start, handler) {
			for(var i=start; i<promises.length; ++i) {
				markAsHandled(getHandler(promises[i]), handler);
			}
		}

		function markAsHandled(h, handler) {
			if(h === handler) {
				return;
			}

			var s = h.state();
			if(s === 0) {
				h.visit(h, void 0, h._unreport);
			} else if(s < 0) {
				h._unreport();
			}
		}

		/**
		 * Fulfill-reject competitive race. Return a promise that will settle
		 * to the same state as the earliest input promise to settle.
		 *
		 * WARNING: The ES6 Promise spec requires that race()ing an empty array
		 * must return a promise that is pending forever.  This implementation
		 * returns a singleton forever-pending promise, the same singleton that is
		 * returned by Promise.never(), thus can be checked with ===
		 *
		 * @param {array} promises array of promises to race
		 * @returns {Promise} if input is non-empty, a promise that will settle
		 * to the same outcome as the earliest input promise to settle. if empty
		 * is empty, returns a promise that will never settle.
		 */
		function race(promises) {
			if(typeof promises !== 'object' || promises === null) {
				return reject(new TypeError('non-iterable passed to race()'));
			}

			// Sigh, race([]) is untestable unless we return *something*
			// that is recognizable without calling .then() on it.
			return promises.length === 0 ? never()
				 : promises.length === 1 ? resolve(promises[0])
				 : runRace(promises);
		}

		function runRace(promises) {
			var resolver = new Pending();
			var i, x, h;
			for(i=0; i<promises.length; ++i) {
				x = promises[i];
				if (x === void 0 && !(i in promises)) {
					continue;
				}

				h = getHandler(x);
				if(h.state() !== 0) {
					resolver.become(h);
					visitRemaining(promises, i+1, h);
					break;
				} else {
					h.visit(resolver, resolver.resolve, resolver.reject);
				}
			}
			return new Promise(Handler, resolver);
		}

		// Promise internals
		// Below this, everything is @private

		/**
		 * Get an appropriate handler for x, without checking for cycles
		 * @param {*} x
		 * @returns {object} handler
		 */
		function getHandler(x) {
			if(isPromise(x)) {
				return x._handler.join();
			}
			return maybeThenable(x) ? getHandlerUntrusted(x) : new Fulfilled(x);
		}

		/**
		 * Get a handler for thenable x.
		 * NOTE: You must only call this if maybeThenable(x) == true
		 * @param {object|function|Promise} x
		 * @returns {object} handler
		 */
		function getHandlerMaybeThenable(x) {
			return isPromise(x) ? x._handler.join() : getHandlerUntrusted(x);
		}

		/**
		 * Get a handler for potentially untrusted thenable x
		 * @param {*} x
		 * @returns {object} handler
		 */
		function getHandlerUntrusted(x) {
			try {
				var untrustedThen = x.then;
				return typeof untrustedThen === 'function'
					? new Thenable(untrustedThen, x)
					: new Fulfilled(x);
			} catch(e) {
				return new Rejected(e);
			}
		}

		/**
		 * Handler for a promise that is pending forever
		 * @constructor
		 */
		function Handler() {}

		Handler.prototype.when
			= Handler.prototype.become
			= Handler.prototype.notify // deprecated
			= Handler.prototype.fail
			= Handler.prototype._unreport
			= Handler.prototype._report
			= noop;

		Handler.prototype._state = 0;

		Handler.prototype.state = function() {
			return this._state;
		};

		/**
		 * Recursively collapse handler chain to find the handler
		 * nearest to the fully resolved value.
		 * @returns {object} handler nearest the fully resolved value
		 */
		Handler.prototype.join = function() {
			var h = this;
			while(h.handler !== void 0) {
				h = h.handler;
			}
			return h;
		};

		Handler.prototype.chain = function(to, receiver, fulfilled, rejected, progress) {
			this.when({
				resolver: to,
				receiver: receiver,
				fulfilled: fulfilled,
				rejected: rejected,
				progress: progress
			});
		};

		Handler.prototype.visit = function(receiver, fulfilled, rejected, progress) {
			this.chain(failIfRejected, receiver, fulfilled, rejected, progress);
		};

		Handler.prototype.fold = function(f, z, c, to) {
			this.when(new Fold(f, z, c, to));
		};

		/**
		 * Handler that invokes fail() on any handler it becomes
		 * @constructor
		 */
		function FailIfRejected() {}

		inherit(Handler, FailIfRejected);

		FailIfRejected.prototype.become = function(h) {
			h.fail();
		};

		var failIfRejected = new FailIfRejected();

		/**
		 * Handler that manages a queue of consumers waiting on a pending promise
		 * @constructor
		 */
		function Pending(receiver, inheritedContext) {
			Promise.createContext(this, inheritedContext);

			this.consumers = void 0;
			this.receiver = receiver;
			this.handler = void 0;
			this.resolved = false;
		}

		inherit(Handler, Pending);

		Pending.prototype._state = 0;

		Pending.prototype.resolve = function(x) {
			this.become(getHandler(x));
		};

		Pending.prototype.reject = function(x) {
			if(this.resolved) {
				return;
			}

			this.become(new Rejected(x));
		};

		Pending.prototype.join = function() {
			if (!this.resolved) {
				return this;
			}

			var h = this;

			while (h.handler !== void 0) {
				h = h.handler;
				if (h === this) {
					return this.handler = cycle();
				}
			}

			return h;
		};

		Pending.prototype.run = function() {
			var q = this.consumers;
			var handler = this.handler;
			this.handler = this.handler.join();
			this.consumers = void 0;

			for (var i = 0; i < q.length; ++i) {
				handler.when(q[i]);
			}
		};

		Pending.prototype.become = function(handler) {
			if(this.resolved) {
				return;
			}

			this.resolved = true;
			this.handler = handler;
			if(this.consumers !== void 0) {
				tasks.enqueue(this);
			}

			if(this.context !== void 0) {
				handler._report(this.context);
			}
		};

		Pending.prototype.when = function(continuation) {
			if(this.resolved) {
				tasks.enqueue(new ContinuationTask(continuation, this.handler));
			} else {
				if(this.consumers === void 0) {
					this.consumers = [continuation];
				} else {
					this.consumers.push(continuation);
				}
			}
		};

		/**
		 * @deprecated
		 */
		Pending.prototype.notify = function(x) {
			if(!this.resolved) {
				tasks.enqueue(new ProgressTask(x, this));
			}
		};

		Pending.prototype.fail = function(context) {
			var c = typeof context === 'undefined' ? this.context : context;
			this.resolved && this.handler.join().fail(c);
		};

		Pending.prototype._report = function(context) {
			this.resolved && this.handler.join()._report(context);
		};

		Pending.prototype._unreport = function() {
			this.resolved && this.handler.join()._unreport();
		};

		/**
		 * Wrap another handler and force it into a future stack
		 * @param {object} handler
		 * @constructor
		 */
		function Async(handler) {
			this.handler = handler;
		}

		inherit(Handler, Async);

		Async.prototype.when = function(continuation) {
			tasks.enqueue(new ContinuationTask(continuation, this));
		};

		Async.prototype._report = function(context) {
			this.join()._report(context);
		};

		Async.prototype._unreport = function() {
			this.join()._unreport();
		};

		/**
		 * Handler that wraps an untrusted thenable and assimilates it in a future stack
		 * @param {function} then
		 * @param {{then: function}} thenable
		 * @constructor
		 */
		function Thenable(then, thenable) {
			Pending.call(this);
			tasks.enqueue(new AssimilateTask(then, thenable, this));
		}

		inherit(Pending, Thenable);

		/**
		 * Handler for a fulfilled promise
		 * @param {*} x fulfillment value
		 * @constructor
		 */
		function Fulfilled(x) {
			Promise.createContext(this);
			this.value = x;
		}

		inherit(Handler, Fulfilled);

		Fulfilled.prototype._state = 1;

		Fulfilled.prototype.fold = function(f, z, c, to) {
			runContinuation3(f, z, this, c, to);
		};

		Fulfilled.prototype.when = function(cont) {
			runContinuation1(cont.fulfilled, this, cont.receiver, cont.resolver);
		};

		var errorId = 0;

		/**
		 * Handler for a rejected promise
		 * @param {*} x rejection reason
		 * @constructor
		 */
		function Rejected(x) {
			Promise.createContext(this);

			this.id = ++errorId;
			this.value = x;
			this.handled = false;
			this.reported = false;

			this._report();
		}

		inherit(Handler, Rejected);

		Rejected.prototype._state = -1;

		Rejected.prototype.fold = function(f, z, c, to) {
			to.become(this);
		};

		Rejected.prototype.when = function(cont) {
			if(typeof cont.rejected === 'function') {
				this._unreport();
			}
			runContinuation1(cont.rejected, this, cont.receiver, cont.resolver);
		};

		Rejected.prototype._report = function(context) {
			tasks.afterQueue(new ReportTask(this, context));
		};

		Rejected.prototype._unreport = function() {
			if(this.handled) {
				return;
			}
			this.handled = true;
			tasks.afterQueue(new UnreportTask(this));
		};

		Rejected.prototype.fail = function(context) {
			this.reported = true;
			emitRejection('unhandledRejection', this);
			Promise.onFatalRejection(this, context === void 0 ? this.context : context);
		};

		function ReportTask(rejection, context) {
			this.rejection = rejection;
			this.context = context;
		}

		ReportTask.prototype.run = function() {
			if(!this.rejection.handled && !this.rejection.reported) {
				this.rejection.reported = true;
				emitRejection('unhandledRejection', this.rejection) ||
					Promise.onPotentiallyUnhandledRejection(this.rejection, this.context);
			}
		};

		function UnreportTask(rejection) {
			this.rejection = rejection;
		}

		UnreportTask.prototype.run = function() {
			if(this.rejection.reported) {
				emitRejection('rejectionHandled', this.rejection) ||
					Promise.onPotentiallyUnhandledRejectionHandled(this.rejection);
			}
		};

		// Unhandled rejection hooks
		// By default, everything is a noop

		Promise.createContext
			= Promise.enterContext
			= Promise.exitContext
			= Promise.onPotentiallyUnhandledRejection
			= Promise.onPotentiallyUnhandledRejectionHandled
			= Promise.onFatalRejection
			= noop;

		// Errors and singletons

		var foreverPendingHandler = new Handler();
		var foreverPendingPromise = new Promise(Handler, foreverPendingHandler);

		function cycle() {
			return new Rejected(new TypeError('Promise cycle'));
		}

		// Task runners

		/**
		 * Run a single consumer
		 * @constructor
		 */
		function ContinuationTask(continuation, handler) {
			this.continuation = continuation;
			this.handler = handler;
		}

		ContinuationTask.prototype.run = function() {
			this.handler.join().when(this.continuation);
		};

		/**
		 * Run a queue of progress handlers
		 * @constructor
		 */
		function ProgressTask(value, handler) {
			this.handler = handler;
			this.value = value;
		}

		ProgressTask.prototype.run = function() {
			var q = this.handler.consumers;
			if(q === void 0) {
				return;
			}

			for (var c, i = 0; i < q.length; ++i) {
				c = q[i];
				runNotify(c.progress, this.value, this.handler, c.receiver, c.resolver);
			}
		};

		/**
		 * Assimilate a thenable, sending it's value to resolver
		 * @param {function} then
		 * @param {object|function} thenable
		 * @param {object} resolver
		 * @constructor
		 */
		function AssimilateTask(then, thenable, resolver) {
			this._then = then;
			this.thenable = thenable;
			this.resolver = resolver;
		}

		AssimilateTask.prototype.run = function() {
			var h = this.resolver;
			tryAssimilate(this._then, this.thenable, _resolve, _reject, _notify);

			function _resolve(x) { h.resolve(x); }
			function _reject(x)  { h.reject(x); }
			function _notify(x)  { h.notify(x); }
		};

		function tryAssimilate(then, thenable, resolve, reject, notify) {
			try {
				then.call(thenable, resolve, reject, notify);
			} catch (e) {
				reject(e);
			}
		}

		/**
		 * Fold a handler value with z
		 * @constructor
		 */
		function Fold(f, z, c, to) {
			this.f = f; this.z = z; this.c = c; this.to = to;
			this.resolver = failIfRejected;
			this.receiver = this;
		}

		Fold.prototype.fulfilled = function(x) {
			this.f.call(this.c, this.z, x, this.to);
		};

		Fold.prototype.rejected = function(x) {
			this.to.reject(x);
		};

		Fold.prototype.progress = function(x) {
			this.to.notify(x);
		};

		// Other helpers

		/**
		 * @param {*} x
		 * @returns {boolean} true iff x is a trusted Promise
		 */
		function isPromise(x) {
			return x instanceof Promise;
		}

		/**
		 * Test just enough to rule out primitives, in order to take faster
		 * paths in some code
		 * @param {*} x
		 * @returns {boolean} false iff x is guaranteed *not* to be a thenable
		 */
		function maybeThenable(x) {
			return (typeof x === 'object' || typeof x === 'function') && x !== null;
		}

		function runContinuation1(f, h, receiver, next) {
			if(typeof f !== 'function') {
				return next.become(h);
			}

			Promise.enterContext(h);
			tryCatchReject(f, h.value, receiver, next);
			Promise.exitContext();
		}

		function runContinuation3(f, x, h, receiver, next) {
			if(typeof f !== 'function') {
				return next.become(h);
			}

			Promise.enterContext(h);
			tryCatchReject3(f, x, h.value, receiver, next);
			Promise.exitContext();
		}

		/**
		 * @deprecated
		 */
		function runNotify(f, x, h, receiver, next) {
			if(typeof f !== 'function') {
				return next.notify(x);
			}

			Promise.enterContext(h);
			tryCatchReturn(f, x, receiver, next);
			Promise.exitContext();
		}

		function tryCatch2(f, a, b) {
			try {
				return f(a, b);
			} catch(e) {
				return reject(e);
			}
		}

		/**
		 * Return f.call(thisArg, x), or if it throws return a rejected promise for
		 * the thrown exception
		 */
		function tryCatchReject(f, x, thisArg, next) {
			try {
				next.become(getHandler(f.call(thisArg, x)));
			} catch(e) {
				next.become(new Rejected(e));
			}
		}

		/**
		 * Same as above, but includes the extra argument parameter.
		 */
		function tryCatchReject3(f, x, y, thisArg, next) {
			try {
				f.call(thisArg, x, y, next);
			} catch(e) {
				next.become(new Rejected(e));
			}
		}

		/**
		 * @deprecated
		 * Return f.call(thisArg, x), or if it throws, *return* the exception
		 */
		function tryCatchReturn(f, x, thisArg, next) {
			try {
				next.notify(f.call(thisArg, x));
			} catch(e) {
				next.notify(e);
			}
		}

		function inherit(Parent, Child) {
			Child.prototype = objectCreate(Parent.prototype);
			Child.prototype.constructor = Child;
		}

		function snd(x, y) {
			return y;
		}

		function noop() {}

		function initEmitRejection() {
			/*global process, self, CustomEvent*/
			if(typeof process !== 'undefined' && process !== null
				&& typeof process.emit === 'function') {
				// Returning falsy here means to call the default
				// onPotentiallyUnhandledRejection API.  This is safe even in
				// browserify since process.emit always returns falsy in browserify:
				// https://github.com/defunctzombie/node-process/blob/master/browser.js#L40-L46
				return function(type, rejection) {
					return type === 'unhandledRejection'
						? process.emit(type, rejection.value, rejection)
						: process.emit(type, rejection);
				};
			} else if(typeof self !== 'undefined' && typeof CustomEvent === 'function') {
				return (function(noop, self, CustomEvent) {
					var hasCustomEvent = false;
					try {
						var ev = new CustomEvent('unhandledRejection');
						hasCustomEvent = ev instanceof CustomEvent;
					} catch (e) {}

					return !hasCustomEvent ? noop : function(type, rejection) {
						var ev = new CustomEvent(type, {
							detail: {
								reason: rejection.value,
								key: rejection
							},
							bubbles: false,
							cancelable: true
						});

						return !self.dispatchEvent(ev);
					};
				}(noop, self, CustomEvent));
			}

			return noop;
		}

		return Promise;
	};
});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));

}).call(this,require('_process'))
},{"_process":406}],465:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	return {
		pending: toPendingState,
		fulfilled: toFulfilledState,
		rejected: toRejectedState,
		inspect: inspect
	};

	function toPendingState() {
		return { state: 'pending' };
	}

	function toRejectedState(e) {
		return { state: 'rejected', reason: e };
	}

	function toFulfilledState(x) {
		return { state: 'fulfilled', value: x };
	}

	function inspect(handler) {
		var state = handler.state();
		return state === 0 ? toPendingState()
			 : state > 0   ? toFulfilledState(handler.value)
			               : toRejectedState(handler.value);
	}

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));

},{}],466:[function(require,module,exports){
/** @license MIT License (c) copyright 2013 original author or authors */

/**
 * Collection of helpers for interfacing with node-style asynchronous functions
 * using promises.
 *
 * @author Brian Cavalier
 * @contributor Renato Zannon
 */

(function(define) {
define(function(require) {

	var when = require('./when');
	var _liftAll = require('./lib/liftAll');
	var setTimer = require('./lib/env').setTimer;
	var slice = Array.prototype.slice;

	var _apply = require('./lib/apply')(when.Promise, dispatch);

	return {
		lift: lift,
		liftAll: liftAll,
		apply: apply,
		call: call,
		createCallback: createCallback,
		bindCallback: bindCallback,
		liftCallback: liftCallback
	};

	/**
	 * Takes a node-style async function and calls it immediately (with an optional
	 * array of arguments or promises for arguments). It returns a promise whose
	 * resolution depends on whether the async functions calls its callback with the
	 * conventional error argument or not.
	 *
	 * With this it becomes possible to leverage existing APIs while still reaping
	 * the benefits of promises.
	 *
	 * @example
	 *    function onlySmallNumbers(n, callback) {
	 *		if(n < 10) {
	 *			callback(null, n + 10);
	 *		} else {
	 *			callback(new Error("Calculation failed"));
	 *		}
	 *	}
	 *
	 *    var nodefn = require("when/node/function");
	 *
	 *    // Logs '15'
	 *    nodefn.apply(onlySmallNumbers, [5]).then(console.log, console.error);
	 *
	 *    // Logs 'Calculation failed'
	 *    nodefn.apply(onlySmallNumbers, [15]).then(console.log, console.error);
	 *
	 * @param {function} f node-style function that will be called
	 * @param {Array} [args] array of arguments to func
	 * @returns {Promise} promise for the value func passes to its callback
	 */
	function apply(f, args) {
		return _apply(f, this, args || []);
	}

	function dispatch(f, thisArg, args, h) {
		var cb = createCallback(h);
		try {
			switch(args.length) {
				case 2: f.call(thisArg, args[0], args[1], cb); break;
				case 1: f.call(thisArg, args[0], cb); break;
				case 0: f.call(thisArg, cb); break;
				default:
					args.push(cb);
					f.apply(thisArg, args);
			}
		} catch(e) {
			h.reject(e);
		}
	}

	/**
	 * Has the same behavior that {@link apply} has, with the difference that the
	 * arguments to the function are provided individually, while {@link apply} accepts
	 * a single array.
	 *
	 * @example
	 *    function sumSmallNumbers(x, y, callback) {
	 *		var result = x + y;
	 *		if(result < 10) {
	 *			callback(null, result);
	 *		} else {
	 *			callback(new Error("Calculation failed"));
	 *		}
	 *	}
	 *
	 *    // Logs '5'
	 *    nodefn.call(sumSmallNumbers, 2, 3).then(console.log, console.error);
	 *
	 *    // Logs 'Calculation failed'
	 *    nodefn.call(sumSmallNumbers, 5, 10).then(console.log, console.error);
	 *
	 * @param {function} f node-style function that will be called
	 * @param {...*} [args] arguments that will be forwarded to the function
	 * @returns {Promise} promise for the value func passes to its callback
	 */
	function call(f /*, args... */) {
		return _apply(f, this, slice.call(arguments, 1));
	}

	/**
	 * Takes a node-style function and returns new function that wraps the
	 * original and, instead of taking a callback, returns a promise. Also, it
	 * knows how to handle promises given as arguments, waiting for their
	 * resolution before executing.
	 *
	 * Upon execution, the orginal function is executed as well. If it passes
	 * a truthy value as the first argument to the callback, it will be
	 * interpreted as an error condition, and the promise will be rejected
	 * with it. Otherwise, the call is considered a resolution, and the promise
	 * is resolved with the callback's second argument.
	 *
	 * @example
	 *    var fs = require("fs"), nodefn = require("when/node/function");
	 *
	 *    var promiseRead = nodefn.lift(fs.readFile);
	 *
	 *    // The promise is resolved with the contents of the file if everything
	 *    // goes ok
	 *    promiseRead('exists.txt').then(console.log, console.error);
	 *
	 *    // And will be rejected if something doesn't work out
	 *    // (e.g. the files does not exist)
	 *    promiseRead('doesnt_exist.txt').then(console.log, console.error);
	 *
	 *
	 * @param {Function} f node-style function to be lifted
	 * @param {...*} [args] arguments to be prepended for the new function @deprecated
	 * @returns {Function} a promise-returning function
	 */
	function lift(f /*, args... */) {
		var args1 = arguments.length > 1 ? slice.call(arguments, 1) : [];
		return function() {
			// TODO: Simplify once partialing has been removed
			var l = args1.length;
			var al = arguments.length;
			var args = new Array(al + l);
			var i;
			for(i=0; i<l; ++i) {
				args[i] = args1[i];
			}
			for(i=0; i<al; ++i) {
				args[i+l] = arguments[i];
			}
			return _apply(f, this, args);
		};
	}

	/**
	 * Lift all the functions/methods on src
	 * @param {object|function} src source whose functions will be lifted
	 * @param {function?} combine optional function for customizing the lifting
	 *  process. It is passed dst, the lifted function, and the property name of
	 *  the original function on src.
	 * @param {(object|function)?} dst option destination host onto which to place lifted
	 *  functions. If not provided, liftAll returns a new object.
	 * @returns {*} If dst is provided, returns dst with lifted functions as
	 *  properties.  If dst not provided, returns a new object with lifted functions.
	 */
	function liftAll(src, combine, dst) {
		return _liftAll(lift, combine, dst, src);
	}

	/**
	 * Takes an object that responds to the resolver interface, and returns
	 * a function that will resolve or reject it depending on how it is called.
	 *
	 * @example
	 *	function callbackTakingFunction(callback) {
	 *		if(somethingWrongHappened) {
	 *			callback(error);
	 *		} else {
	 *			callback(null, interestingValue);
	 *		}
	 *	}
	 *
	 *	var when = require('when'), nodefn = require('when/node/function');
	 *
	 *	var deferred = when.defer();
	 *	callbackTakingFunction(nodefn.createCallback(deferred.resolver));
	 *
	 *	deferred.promise.then(function(interestingValue) {
	 *		// Use interestingValue
	 *	});
	 *
	 * @param {Resolver} resolver that will be 'attached' to the callback
	 * @returns {Function} a node-style callback function
	 */
	function createCallback(resolver) {
		return function(err, value) {
			if(err) {
				resolver.reject(err);
			} else if(arguments.length > 2) {
				resolver.resolve(slice.call(arguments, 1));
			} else {
				resolver.resolve(value);
			}
		};
	}

	/**
	 * Attaches a node-style callback to a promise, ensuring the callback is
	 * called for either fulfillment or rejection. Returns a promise with the same
	 * state as the passed-in promise.
	 *
	 * @example
	 *	var deferred = when.defer();
	 *
	 *	function callback(err, value) {
	 *		// Handle err or use value
	 *	}
	 *
	 *	bindCallback(deferred.promise, callback);
	 *
	 *	deferred.resolve('interesting value');
	 *
	 * @param {Promise} promise The promise to be attached to.
	 * @param {Function} callback The node-style callback to attach.
	 * @returns {Promise} A promise with the same state as the passed-in promise.
	 */
	function bindCallback(promise, callback) {
		promise = when(promise);

		if (callback) {
			promise.then(success, wrapped);
		}

		return promise;

		function success(value) {
			wrapped(null, value);
		}

		function wrapped(err, value) {
			setTimer(function () {
				callback(err, value);
			}, 0);
		}
	}

	/**
	 * Takes a node-style callback and returns new function that accepts a
	 * promise, calling the original callback when the promise is either
	 * fulfilled or rejected with the appropriate arguments.
	 *
	 * @example
	 *	var deferred = when.defer();
	 *
	 *	function callback(err, value) {
	 *		// Handle err or use value
	 *	}
	 *
	 *	var wrapped = liftCallback(callback);
	 *
	 *	// `wrapped` can now be passed around at will
	 *	wrapped(deferred.promise);
	 *
	 *	deferred.resolve('interesting value');
	 *
	 * @param {Function} callback The node-style callback to wrap.
	 * @returns {Function} The lifted, promise-accepting function.
	 */
	function liftCallback(callback) {
		return function(promise) {
			return bindCallback(promise, callback);
		};
	}
});

})(typeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); });




},{"./lib/apply":451,"./lib/env":461,"./lib/liftAll":463,"./when":467}],467:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */

/**
 * Promises/A+ and when() implementation
 * when is part of the cujoJS family of libraries (http://cujojs.com/)
 * @author Brian Cavalier
 * @author John Hann
 */
(function(define) { 'use strict';
define(function (require) {

	var timed = require('./lib/decorators/timed');
	var array = require('./lib/decorators/array');
	var flow = require('./lib/decorators/flow');
	var fold = require('./lib/decorators/fold');
	var inspect = require('./lib/decorators/inspect');
	var generate = require('./lib/decorators/iterate');
	var progress = require('./lib/decorators/progress');
	var withThis = require('./lib/decorators/with');
	var unhandledRejection = require('./lib/decorators/unhandledRejection');
	var TimeoutError = require('./lib/TimeoutError');

	var Promise = [array, flow, fold, generate, progress,
		inspect, withThis, timed, unhandledRejection]
		.reduce(function(Promise, feature) {
			return feature(Promise);
		}, require('./lib/Promise'));

	var apply = require('./lib/apply')(Promise);

	// Public API

	when.promise     = promise;              // Create a pending promise
	when.resolve     = Promise.resolve;      // Create a resolved promise
	when.reject      = Promise.reject;       // Create a rejected promise

	when.lift        = lift;                 // lift a function to return promises
	when['try']      = attempt;              // call a function and return a promise
	when.attempt     = attempt;              // alias for when.try

	when.iterate     = Promise.iterate;      // DEPRECATED (use cujojs/most streams) Generate a stream of promises
	when.unfold      = Promise.unfold;       // DEPRECATED (use cujojs/most streams) Generate a stream of promises

	when.join        = join;                 // Join 2 or more promises

	when.all         = all;                  // Resolve a list of promises
	when.settle      = settle;               // Settle a list of promises

	when.any         = lift(Promise.any);    // One-winner race
	when.some        = lift(Promise.some);   // Multi-winner race
	when.race        = lift(Promise.race);   // First-to-settle race

	when.map         = map;                  // Array.map() for promises
	when.filter      = filter;               // Array.filter() for promises
	when.reduce      = lift(Promise.reduce);       // Array.reduce() for promises
	when.reduceRight = lift(Promise.reduceRight);  // Array.reduceRight() for promises

	when.isPromiseLike = isPromiseLike;      // Is something promise-like, aka thenable

	when.Promise     = Promise;              // Promise constructor
	when.defer       = defer;                // Create a {promise, resolve, reject} tuple

	// Error types

	when.TimeoutError = TimeoutError;

	/**
	 * Get a trusted promise for x, or by transforming x with onFulfilled
	 *
	 * @param {*} x
	 * @param {function?} onFulfilled callback to be called when x is
	 *   successfully fulfilled.  If promiseOrValue is an immediate value, callback
	 *   will be invoked immediately.
	 * @param {function?} onRejected callback to be called when x is
	 *   rejected.
	 * @param {function?} onProgress callback to be called when progress updates
	 *   are issued for x. @deprecated
	 * @returns {Promise} a new promise that will fulfill with the return
	 *   value of callback or errback or the completion value of promiseOrValue if
	 *   callback and/or errback is not supplied.
	 */
	function when(x, onFulfilled, onRejected, onProgress) {
		var p = Promise.resolve(x);
		if (arguments.length < 2) {
			return p;
		}

		return p.then(onFulfilled, onRejected, onProgress);
	}

	/**
	 * Creates a new promise whose fate is determined by resolver.
	 * @param {function} resolver function(resolve, reject, notify)
	 * @returns {Promise} promise whose fate is determine by resolver
	 */
	function promise(resolver) {
		return new Promise(resolver);
	}

	/**
	 * Lift the supplied function, creating a version of f that returns
	 * promises, and accepts promises as arguments.
	 * @param {function} f
	 * @returns {Function} version of f that returns promises
	 */
	function lift(f) {
		return function() {
			for(var i=0, l=arguments.length, a=new Array(l); i<l; ++i) {
				a[i] = arguments[i];
			}
			return apply(f, this, a);
		};
	}

	/**
	 * Call f in a future turn, with the supplied args, and return a promise
	 * for the result.
	 * @param {function} f
	 * @returns {Promise}
	 */
	function attempt(f /*, args... */) {
		/*jshint validthis:true */
		for(var i=0, l=arguments.length-1, a=new Array(l); i<l; ++i) {
			a[i] = arguments[i+1];
		}
		return apply(f, this, a);
	}

	/**
	 * Creates a {promise, resolver} pair, either or both of which
	 * may be given out safely to consumers.
	 * @return {{promise: Promise, resolve: function, reject: function, notify: function}}
	 */
	function defer() {
		return new Deferred();
	}

	function Deferred() {
		var p = Promise._defer();

		function resolve(x) { p._handler.resolve(x); }
		function reject(x) { p._handler.reject(x); }
		function notify(x) { p._handler.notify(x); }

		this.promise = p;
		this.resolve = resolve;
		this.reject = reject;
		this.notify = notify;
		this.resolver = { resolve: resolve, reject: reject, notify: notify };
	}

	/**
	 * Determines if x is promise-like, i.e. a thenable object
	 * NOTE: Will return true for *any thenable object*, and isn't truly
	 * safe, since it may attempt to access the `then` property of x (i.e.
	 *  clever/malicious getters may do weird things)
	 * @param {*} x anything
	 * @returns {boolean} true if x is promise-like
	 */
	function isPromiseLike(x) {
		return x && typeof x.then === 'function';
	}

	/**
	 * Return a promise that will resolve only once all the supplied arguments
	 * have resolved. The resolution value of the returned promise will be an array
	 * containing the resolution values of each of the arguments.
	 * @param {...*} arguments may be a mix of promises and values
	 * @returns {Promise}
	 */
	function join(/* ...promises */) {
		return Promise.all(arguments);
	}

	/**
	 * Return a promise that will fulfill once all input promises have
	 * fulfilled, or reject when any one input promise rejects.
	 * @param {array|Promise} promises array (or promise for an array) of promises
	 * @returns {Promise}
	 */
	function all(promises) {
		return when(promises, Promise.all);
	}

	/**
	 * Return a promise that will always fulfill with an array containing
	 * the outcome states of all input promises.  The returned promise
	 * will only reject if `promises` itself is a rejected promise.
	 * @param {array|Promise} promises array (or promise for an array) of promises
	 * @returns {Promise} promise for array of settled state descriptors
	 */
	function settle(promises) {
		return when(promises, Promise.settle);
	}

	/**
	 * Promise-aware array map function, similar to `Array.prototype.map()`,
	 * but input array may contain promises or values.
	 * @param {Array|Promise} promises array of anything, may contain promises and values
	 * @param {function(x:*, index:Number):*} mapFunc map function which may
	 *  return a promise or value
	 * @returns {Promise} promise that will fulfill with an array of mapped values
	 *  or reject if any input promise rejects.
	 */
	function map(promises, mapFunc) {
		return when(promises, function(promises) {
			return Promise.map(promises, mapFunc);
		});
	}

	/**
	 * Filter the provided array of promises using the provided predicate.  Input may
	 * contain promises and values
	 * @param {Array|Promise} promises array of promises and values
	 * @param {function(x:*, index:Number):boolean} predicate filtering predicate.
	 *  Must return truthy (or promise for truthy) for items to retain.
	 * @returns {Promise} promise that will fulfill with an array containing all items
	 *  for which predicate returned truthy.
	 */
	function filter(promises, predicate) {
		return when(promises, function(promises) {
			return Promise.filter(promises, predicate);
		});
	}

	return when;
});
})(typeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); });

},{"./lib/Promise":448,"./lib/TimeoutError":450,"./lib/apply":451,"./lib/decorators/array":452,"./lib/decorators/flow":453,"./lib/decorators/fold":454,"./lib/decorators/inspect":455,"./lib/decorators/iterate":456,"./lib/decorators/progress":457,"./lib/decorators/timed":458,"./lib/decorators/unhandledRejection":459,"./lib/decorators/with":460}]},{},[27]);
