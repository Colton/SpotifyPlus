(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
module.exports = {
  "app.name": "Sender",
  "app.description": "Sender",
  "app.offlineTitle": "Deine Sender sind offline nicht verfügbar.",
  "app.offlineMessage": "Geh zum Laden online.",
  "app.errorTitle": "Deine Sender sind nicht verfügbar.",
  "app.errorMessage": "Deine Sender können im Moment leider nicht geladen werden. Bitte versuch es später noch mal.",
  "app.emptyTitle": "Deine Radiosender werden hier angezeigt.",
  "app.emptyMessage": "Suche nach Künstler, Song, Playlist oder Album, um einen Radiosender zu starten.",
  "app.sortBy": "Nach 'Zuletzt gefolgt' sortiert",
  "station.album": "Album-Radio",
  "station.artist": "Künstler-Radio",
  "station.genre": "Genre-Radio",
  "station.playlist": "Playlist-Radio",
  "station.track": "Song-Radio"
};
},{}],2:[function(require,module,exports){
module.exports = {
  "app.name": "σταθμοί",
  "app.description": "σταθμοί",
  "app.offlineTitle": "Οι Σταθμοί σου δεν είναι διαθέσιμοι εκτός σύνδεσης",
  "app.offlineMessage": "Συνδέσου στο διαδίκτυο για να πραγματοποιηθεί φόρτωση.",
  "app.errorTitle": "Οι Σταθμοί σου δεν είναι διαθέσιμοι.",
  "app.errorMessage": "Δεν μπορούμε να φορτώσουμε τους σταθμούς σου αυτή τη στιγμή. Δοκίμασε ξανά αργότερα.",
  "app.emptyTitle": "Οι σταθμοί σου θα εμφανίζονται εδώ.",
  "app.emptyMessage": "Αναζήτησε καλλιτέχνη, τραγούδι, λίστα ή άλμπουμ για να ξεκινήσεις έναν ραδιοφωνικό σταθμό.",
  "app.sortBy": "Ταξινόμηση με βάση τους πρόσφατους οπαδούς",
  "station.album": "Ραδιόφωνο άλμπουμ",
  "station.artist": "Ραδιόφωνο καλλιτέχνη",
  "station.genre": "Ραδιόφωνο είδους",
  "station.playlist": "Ραδιόφωνο λίστας",
  "station.track": "Ραδιόφωνο τραγουδιού"
};
},{}],3:[function(require,module,exports){
module.exports = {
  "app.name": "stations",
  "app.description": "stations",
  "app.offlineTitle": "Your Stations are not available offline",
  "app.offlineMessage": "Please go online to load.",
  "app.errorTitle": "Your Stations aren't available.",
  "app.errorMessage": "We can't load your stations right now. Please try later.",
  "app.emptyTitle": "Your stations will appear here.",
  "app.emptyMessage": "Search for an artist, song, playlist or album to start a radio station.",
  "app.sortBy": "Sorted by recently followed",
  "station.album": "Album Radio",
  "station.artist": "Artist Radio",
  "station.genre": "Genre Radio",
  "station.playlist": "Playlist Radio",
  "station.track": "Song Radio"
}
;
},{}],4:[function(require,module,exports){
module.exports = {
  "app.name": "estaciones",
  "app.description": "estaciones",
  "app.offlineTitle": "Tus Estaciones no están disponibles en modo offline",
  "app.offlineMessage": "Conéctate a la red para cargar.",
  "app.errorTitle": "Tus Estaciones no están disponibles.",
  "app.errorMessage": "Por el momento no podemos cargar tus estaciones. Inténtalo más tarde.",
  "app.emptyTitle": "Tus estaciones aparecerán aquí. ",
  "app.emptyMessage": "Busca un artista, canción, playlist o álbum para iniciar una estación de radio.",
  "app.sortBy": "Clasificadas por seguidas recientemente",
  "station.album": "Radio de álbum",
  "station.artist": "Radio de artista",
  "station.genre": "Radio de género",
  "station.playlist": "Radio de playlist",
  "station.track": "Radio de canción"
};
},{}],5:[function(require,module,exports){
module.exports = {
  "app.name": "emisoras",
  "app.description": "emisoras",
  "app.offlineTitle": "Tus emisoras no están disponibles sin conexión",
  "app.offlineMessage": "Por favor, conéctate para cargar.",
  "app.errorTitle": "Tus emisoras no están disponibles.",
  "app.errorMessage": "En este momento no podemos cargar tus emisoras. Por favor, prueba de nuevo más tarde.",
  "app.emptyTitle": "Aquí aparecen tus emisoras.",
  "app.emptyMessage": "Busca un artista, canción, playlist o álbum para iniciar una emisora de radio.",
  "app.sortBy": "Ordenad. por fecha de seguir",
  "station.album": "Radio de álbum",
  "station.artist": "Radio de artista",
  "station.genre": "Radio de género",
  "station.playlist": "Radio de playlist",
  "station.track": "Radio de canción"
};
},{}],6:[function(require,module,exports){
module.exports = {
  "app.name": "kanavat",
  "app.description": "kanavat",
  "app.offlineTitle": "Radiokanavia ei voi käyttää offline-tilassa",
  "app.offlineMessage": "Siirry online-tilaan, jotta voit ladata.",
  "app.errorTitle": "Radiokanavat eivät ole käytettävissä.",
  "app.errorMessage": "Valitettavasti radiokanavien lataaminen ei juuri nyt onnistu. Yritä myöhemmin uudelleen.",
  "app.emptyTitle": "Radiokanavasi näkyvät tässä.",
  "app.emptyMessage": "Käynnistä radiokanava hakemalla artistia, kappaletta, soittolistaa tai albumia.",
  "app.sortBy": "Lajiteltu viimeksi seurattujen mukaan",
  "station.album": "Albumiradio",
  "station.artist": "Artistiradio",
  "station.genre": "Lajiradio",
  "station.playlist": "Soittolistaradio",
  "station.track": "Kappaleradio"
};
},{}],7:[function(require,module,exports){
module.exports = {
  "app.name": "stations",
  "app.description": "stations",
  "app.offlineTitle": "Vos stations ne sont pas disponibles hors ligne",
  "app.offlineMessage": "Veuillez accéder à Internet pour charger le contenu.",
  "app.errorTitle": "Vos stations ne sont pas disponibles.",
  "app.errorMessage": "Impossible de charger vos stations pour le moment. Veuillez réessayer plus tard.",
  "app.emptyTitle": "Vos stations apparaîtront ici",
  "app.emptyMessage": "Pour lancer une station de radio, recherchez un artiste, une chanson, une liste de lecture ou un album.",
  "app.sortBy": "Tri effectué en fonction des abonnements récents",
  "station.album": "Radio liée à l'album",
  "station.artist": "Radio liée à un artiste",
  "station.genre": "Radio par genre",
  "station.playlist": "Radio liée à la playlist",
  "station.track": "Radio liée à la chanson"
};
},{}],8:[function(require,module,exports){
module.exports = {
  "app.name": "radios",
  "app.description": "radios",
  "app.offlineTitle": "Vos stations de radio ne sont pas disponibles hors connexion",
  "app.offlineMessage": "Connectez-vous pour procéder au chargement.",
  "app.errorTitle": "Vos stations de radio ne sont pas disponibles.",
  "app.errorMessage": "Impossible de charger vos stations de radio pour l'instant. Merci de réessayer plus tard.",
  "app.emptyTitle": "Vos radios apparaîtront ici.",
  "app.emptyMessage": "Recherchez un artiste, un titre, une playlist ou un album pour lancer une radio.",
  "app.sortBy": "Tri par date d'abonnement",
  "station.album": "Radio liée à l'album",
  "station.artist": "Radio de l'artiste",
  "station.genre": "Radio liée au genre",
  "station.playlist": "Radio liée à la playlist",
  "station.track": "Radio liée au titre"
};
},{}],9:[function(require,module,exports){
module.exports = {
  "app.name": "rádió",
  "app.description": "rádió",
  "app.offlineTitle": "Internetkapcsolat nélkül nem érhetők el a rádióid",
  "app.offlineMessage": "Csatlakozz az internethez, majd indítsd el.",
  "app.errorTitle": "Nem érhetők el a rádióid.",
  "app.errorMessage": "Most nem tudjuk betölteni a rádióidat. Próbálkozz újra később.",
  "app.emptyTitle": "Itt fognak megjelenni a rádióid.",
  "app.emptyMessage": "A rádió indításához csak keress egy előadót, számot, lejátszási listát vagy albumot.",
  "app.sortBy": "Követés ideje alapján rendezve",
  "station.album": "Albumrádió",
  "station.artist": "Előadói rádió",
  "station.genre": "Műfaji rádió",
  "station.playlist": "Lejátszási listás rádió",
  "station.track": "Zeneszámos rádió"
};
},{}],10:[function(require,module,exports){
module.exports = {
  "app.name": "stasiun radio",
  "app.description": "stasiun radio",
  "app.offlineTitle": "Stasiun Radio Kamu tidak tersedia offline",
  "app.offlineMessage": "Alihkan ke online untuk memuat.",
  "app.errorTitle": "Stasiun Radio Kamu tidak tersedia.",
  "app.errorMessage": "Kami tidak dapat memuat stasiun radio kamu saat ini. Coba lagi nanti.",
  "app.emptyTitle": "Stasiun radio kamu akan ditampilkan di sini.",
  "app.emptyMessage": "Cari artis, lagu, playlist, atau album untuk memainkan stasiun radio.",
  "app.sortBy": "Diurutkan dari yang terakhir mengikuti",
  "station.album": "Album Radio",
  "station.artist": "Radio Artis",
  "station.genre": "Radio Genre",
  "station.playlist": "Playlist Radio",
  "station.track": "Radio Lagu"
};
},{}],11:[function(require,module,exports){
'use strict';

// This file will likely become a generated file in the future. Please
// avoid adding extra APIs or exports here.

var i18n = require('../../../libs/spotify-i18n')({
  'de': require('./de.lang'),
  'el': require('./el.lang'),
  'en': require('./en.lang'),
  'es': require('./es.lang'),
  'es-419': require('./es-419.lang'),
  'fi': require('./fi.lang'),
  'fr': require('./fr.lang'),
  'fr-CA': require('./fr-CA.lang'),
  'hu': require('./hu.lang'),
  'id': require('./id.lang'),
  'it': require('./it.lang'),
  'ja': require('./ja.lang'),
  'nl': require('./nl.lang'),
  'pl': require('./pl.lang'),
  'pt-BR': require('./pt-BR.lang'),
  'sv': require('./sv.lang'),
  'tr': require('./tr.lang'),
  'zh-Hant': require('./zh-Hant.lang'),
  'zsm': require('./zsm.lang')
});

module.exports = i18n;

},{"../../../libs/spotify-i18n":159,"./de.lang":1,"./el.lang":2,"./en.lang":3,"./es-419.lang":4,"./es.lang":5,"./fi.lang":6,"./fr-CA.lang":7,"./fr.lang":8,"./hu.lang":9,"./id.lang":10,"./it.lang":12,"./ja.lang":13,"./nl.lang":14,"./pl.lang":15,"./pt-BR.lang":16,"./sv.lang":17,"./tr.lang":18,"./zh-Hant.lang":19,"./zsm.lang":20}],12:[function(require,module,exports){
module.exports = {
  "app.name": "stazioni",
  "app.description": "stazioni",
  "app.offlineTitle": "Le tue stazioni non sono disponibili offline",
  "app.offlineMessage": "Passa online per caricare.",
  "app.errorTitle": "Le tue stazioni non sono disponibili.",
  "app.errorMessage": "Non è possibile caricare le stazioni in questo momento. Riprova più tardi.",
  "app.emptyTitle": "Le tue stazioni compaiono qui.",
  "app.emptyMessage": "Cerca un artista, un brano, una playlist o un album per creare una stazione radio.",
  "app.sortBy": "Ordinati per seguiti di recente",
  "station.album": "Radio dall'album",
  "station.artist": "Radio dell'artista",
  "station.genre": "Radio per genere",
  "station.playlist": "Radio dalla playlist",
  "station.track": "Radio dal brano"
};
},{}],13:[function(require,module,exports){
module.exports = {
  "app.name": "ステーション",
  "app.description": "ステーション",
  "app.offlineTitle": "マイラジオはオフラインでは利用できません",
  "app.offlineMessage": "ロードするには、インターネットに接続してください。",
  "app.errorTitle": "マイラジオは利用できません。",
  "app.errorMessage": "現在、マイラジオをロードできません。しばらくしてから再試行してください。",
  "app.emptyTitle": "マイラジオはここに表示されます。",
  "app.emptyMessage": "Radioステーションを開始するには、アーティスト、曲、プレイリスト、またはアルバムで検索してください。",
  "app.sortBy": "最近フォローしたラジオステーション",
  "station.album": "アルバムRadio",
  "station.artist": "アーティストRadio",
  "station.genre": "ジャンルRadio",
  "station.playlist": "プレイリストRadio",
  "station.track": "曲Radio"
};
},{}],14:[function(require,module,exports){
module.exports = {
  "app.name": "zenders",
  "app.description": "zenders",
  "app.offlineTitle": "Jouw zenders zijn niet offline beschikbaar",
  "app.offlineMessage": "Ga online om te laden.",
  "app.errorTitle": "Jouw zenders zijn niet beschikbaar.",
  "app.errorMessage": "We kunnen op dit moment je zenders niet laden. Probeer het later opnieuw.",
  "app.emptyTitle": "Je zenders worden hier weergegeven.",
  "app.emptyMessage": "Zoek naar een artiest, nummer, afspeellijst of album om een radiozender te starten.",
  "app.sortBy": "Gesorteerd op onlangs gevolgd",
  "station.album": "Albumradio",
  "station.artist": "Artiestenradio",
  "station.genre": "Genreradio",
  "station.playlist": "Afspeellijstenradio",
  "station.track": "Nummerradio"
};
},{}],15:[function(require,module,exports){
module.exports = {
  "app.name": "stacje",
  "app.description": "stacje",
  "app.offlineTitle": "Twoje stacje radiowe są niedostępne w trybie offline",
  "app.offlineMessage": "Przejdź do trybu online, aby załadować.",
  "app.errorTitle": "Twoje stacje radiowe są niedostępne.",
  "app.errorMessage": "W tej chwili nie można załadować Twoich stacji radiowych. Spróbuj ponownie później.",
  "app.emptyTitle": "W tym miejscu pojawią się Twoje stacje.",
  "app.emptyMessage": "Wyszukaj wykonawcę, utwór, playlistę lub album, aby włączyć stację radiową.",
  "app.sortBy": "Sortowane wg ostatnio obserwowanych",
  "station.album": "Radio albumu",
  "station.artist": "Radio wykonawcy",
  "station.genre": "Radio gatunku",
  "station.playlist": "Radio playlisty",
  "station.track": "Radio utworu"
};
},{}],16:[function(require,module,exports){
module.exports = {
  "app.name": "estações",
  "app.description": "estações",
  "app.offlineTitle": "Suas estações não estão disponíveis offline",
  "app.offlineMessage": "Fique online para carregar.",
  "app.errorTitle": "Suas estações não estão disponíveis.",
  "app.errorMessage": "Não conseguimos carregar suas estações. Tente mais tarde.",
  "app.emptyTitle": "Suas estações vão aparecer aqui.",
  "app.emptyMessage": "Busque um artista, música, playlist ou álbum para dar início a uma estação de rádio.",
  "app.sortBy": "Classificado por seguidos recentemente",
  "station.album": "Rádio do álbum",
  "station.artist": "Rádio do artista",
  "station.genre": "Rádio do gênero",
  "station.playlist": "Rádio da playlist",
  "station.track": "Rádio da música"
};
},{}],17:[function(require,module,exports){
module.exports = {
  "app.name": "stationer",
  "app.description": "stationer",
  "app.offlineTitle": "Dina stationer är inte tillgängliga offline",
  "app.offlineMessage": "Anslut till internet om du vill läsa in appen.",
  "app.errorTitle": "Dina stationer är inte tillgängliga.",
  "app.errorMessage": "Det går inte att läsa in dina stationer just nu. Försök igen senare.",
  "app.emptyTitle": "Stationerna visas här.",
  "app.emptyMessage": "Sök efter artist, låt, spellista eller album om du vill starta en radiostation.",
  "app.sortBy": "Sorterat efter nyligen följda",
  "station.album": "Albumradio",
  "station.artist": "Artistradio",
  "station.genre": "Genreradio",
  "station.playlist": "Spellisteradio",
  "station.track": "Spårradio"
};
},{}],18:[function(require,module,exports){
module.exports = {
  "app.name": "istasyon",
  "app.description": "istasyon",
  "app.offlineTitle": "İstasyonların çevrimdışı kullanılamaz",
  "app.offlineMessage": "Yüklemek için lütfen çevrimiçi ol.",
  "app.errorTitle": "İstasyonların kullanılamıyor.",
  "app.errorMessage": "Şu anda istasyonlarını yükleyemiyoruz. Lütfen daha sonra yeniden dene.",
  "app.emptyTitle": "İstasyonların burada görünür.",
  "app.emptyMessage": "Bir radyo istasyonu başlatmak için sanatçı, şarkı, çalma listesi veya albüm arat.",
  "app.sortBy": "Yeni takip edilenlere göre sıralandı",
  "station.album": "Albüm Radyosu",
  "station.artist": "Sanatçı Radyosu",
  "station.genre": "Türe Göre Radyo",
  "station.playlist": "Çalma Listesi Radyosu",
  "station.track": "Şarkı Radyosu"
};
},{}],19:[function(require,module,exports){
module.exports = {
  "app.name": "電台",
  "app.description": "電台",
  "app.offlineTitle": "無法離線使用你的電台",
  "app.offlineMessage": "請上網以載入。",
  "app.errorTitle": "無法使用你的電台。",
  "app.errorMessage": "目前無法載入你的電台， 請稍後再試一次。",
  "app.emptyTitle": "你的電台會顯示在這裡。",
  "app.emptyMessage": "搜尋藝人、歌曲、播放清單或專輯，即可開啟電台。",
  "app.sortBy": "依最近關注排序",
  "station.album": "專輯電台",
  "station.artist": "藝人電台",
  "station.genre": "曲風電台",
  "station.playlist": "播放清單電台",
  "station.track": "歌曲電台"
};
},{}],20:[function(require,module,exports){
module.exports = {
  "app.name": "stesen",
  "app.description": "stesen",
  "app.offlineTitle": "Stesen anda tidak tersedia di luar talian",
  "app.offlineMessage": "Sila ke online untuk memuatkan.",
  "app.errorTitle": "Stesen anda tidak tersedia.",
  "app.errorMessage": "Kami tidak dapat memuatkan stesen anda sekarang. Sila cuba lagi kemudian.",
  "app.emptyTitle": "Stesen anda akan muncul di sini.",
  "app.emptyMessage": "Cari artis, lagu, senarai main atau album untuk memulakan stesen radio.",
  "app.sortBy": "Diisih mengikut lagu yang baru diikuti",
  "station.album": "Radio Album",
  "station.artist": "Radio Artis",
  "station.genre": "Radio Genre",
  "station.playlist": "Radio Senarai Main",
  "station.track": "Radio Lagu"
};
},{}],21:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = appStateBuilder;
var stationsQuery = 'stations(name, uri, type, baseSeed, added, image, subtitle(name, uri))';

function appStateBuilder(live) {
  var appState = live('stations:app');

  function _getAppStateStations() {
    return appState.get('stations');
  }
  function _findStationIndex(savedStations, stationUri) {
    var foundIndex = -1;
    savedStations.some(function (station, index) {
      if (station.uri === stationUri) {
        foundIndex = index;
        return true;
      }
      return false;
    });
    return foundIndex;
  }
  function _sameStations(s1, s2) {
    if (s1.length !== s2.length) {
      return false;
    }
    var notSame = s1.some(function (station, index) {
      var name = station.get('name');
      return station.uri !== s2[index].uri || name !== s2[index].name;
    });
    return !notSame;
  }
  function getStations() {
    return new Promise(function (resolve, reject) {
      appState.query(stationsQuery, function (err, data) {
        if (err) {
          console.log(err);
          reject(false);
        } else {
          resolve(data.stations);
        }
      }, 1000);
    });
  }
  function addOnAppStateUpdate(fn) {
    if (typeof fn !== 'function') {
      throw new Error('appState:addOnAppStateUpdate requires a function');
    }
    appState.on('update', fn);
  }
  function removeOnAppStateUpdate(fn) {
    if (typeof fn !== 'function') {
      throw new Error('appState:removeOnAppStateUpdate requires a function');
    }
    appState.off('update', fn);
  }
  function addOnStationsUpdate(fn) {
    if (typeof fn !== 'function') {
      throw new Error('appState:addOnStationsUpdate requires a function');
    }
    var stations = _getAppStateStations();
    if (!stations) {
      console.log('appState has no stations');
      return;
    }
    stations.on('update', fn);
  }
  function removeOnStationsUpdate(fn) {
    if (typeof fn !== 'function') {
      throw new Error('appState:removeOnStationsUpdate requires a function');
    }
    var stations = _getAppStateStations();
    if (!stations) {
      console.log('appState has no stations');
      return;
    }
    stations.off('update', fn);
  }
  function updateError(error) {
    if (typeof error !== 'boolean') {
      throw new Error('appState:updateError requires a boolean');
    }
    appState.update({ error: error });
  }
  function updateStations(stations) {
    if (!stations || !Array.isArray(stations)) {
      throw new Error('appState:updateStations requires an array.');
    }
    var savedStations = _getAppStateStations();
    if (!savedStations) {
      appState.update({ stations: stations });
    } else {
      if (!_sameStations(savedStations.values, stations)) {
        // Dont replace the stations directly
        // as we'd lose our stations subscribers
        savedStations.update([{ type: 'remove', index: 0, length: savedStations.length }, { type: 'insert', index: 0, values: stations }]);
      }
    }
  }
  function removeStation(stationUri) {
    if (!stationUri) {
      throw new Error('appState:removeStation requires a stationUri');
    }
    var stations = _getAppStateStations();
    if (!stations) {
      console.log('appState has no stations');
      return;
    }
    var foundIndex = _findStationIndex(stations.values, stationUri);
    if (foundIndex === -1) {
      console.log('appState:removeStation unfound: ' + stationUri);
      return;
    }
    stations.update([{ type: 'remove', index: foundIndex, length: 1 }]);
  }
  function addStation(stationUri) {
    if (!stationUri) {
      throw new Error('appState:addStation requires a stationUri');
    }
    var stations = _getAppStateStations();
    if (!stations) {
      console.log('appState has no stations');
      return;
    }
    var foundIndex = _findStationIndex(stations.values, stationUri);
    if (foundIndex !== -1) {
      console.log('appState:addStation found: ' + stationUri + '. Not adding');
      return;
    }
    stations.update([{ type: 'insert', index: 0, values: [{ uri: stationUri }] }]);
  }
  return {
    getStations: getStations,
    addOnAppStateUpdate: addOnAppStateUpdate,
    removeOnAppStateUpdate: removeOnAppStateUpdate,
    addOnStationsUpdate: addOnStationsUpdate,
    removeOnStationsUpdate: removeOnStationsUpdate,
    updateError: updateError,
    updateStations: updateStations,
    removeStation: removeStation,
    addStation: addStation
  };
}

},{}],22:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = clientFollowController;

var _stationMessageProxy = require('../../../../libs/spotify-live-models/station/station-message-proxy');

var _stationMessageProxy2 = _interopRequireDefault(_stationMessageProxy);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function clientFollowController(appState) {
  function onStationAdd(opts) {
    if (opts.add) {
      appState.addStation(opts.stationUri);
    } else {
      appState.removeStation(opts.stationUri);
    }
  }
  _stationMessageProxy2.default.subscribeTo_add(onStationAdd);
}

},{"../../../../libs/spotify-live-models/station/station-message-proxy":201}],23:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Gets data from the backend and updates appState
 * @param {Object} stationMessageProxy
 * @param {Object} appState
 * @param {Integer} errorTimeoutT - only to be used by unit tests
 */

exports.default = function (stationMessageProxy, appState, errorTimeoutT) {
  var errorTimeout = errorTimeoutT || 10000; // 10 seconds.
  var requestSavedReplyTimeout = void 0;

  var updateAppStateWithError = appState.updateError.bind(null, true);

  function onRequestSavedReply(data) {
    clearTimeout(requestSavedReplyTimeout);
    appState.updateStations(data.saved_stations);
  }
  stationMessageProxy.subscribeTo_requestSavedReply(onRequestSavedReply);
  stationMessageProxy.requestSaved();

  // If we dont get a onRequestSavedReply in time, render an error.
  requestSavedReplyTimeout = setTimeout(updateAppStateWithError, errorTimeout);
};

},{}],24:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = localStorage;

var _ramda = require('ramda');

var _ramda2 = _interopRequireDefault(_ramda);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var onAppStateUpdate = void 0;

function localStorage(storage, appState) {
  function logError(error) {
    console.log('local-storage: error: ' + error);
  }
  function checkError(err) {
    if (err) {
      logError(err);
    }
  }
  function getStorageStationsCallback(err, data) {
    if (err || !data) {
      console.log('getStorageStationsCallbackErr', err);
    } else {
      appState.updateStations(JSON.parse(data));
    }
  }
  function storeStations(stations) {
    storage.set('stations', JSON.stringify(stations), checkError);
  }
  function getAndStoreSavedStations() {
    appState.getStations().then(storeStations).catch(logError);
  }
  function onSavedStationsAdded() {
    getAndStoreSavedStations();
    appState.removeOnAppStateUpdate(onAppStateUpdate);
    appState.addOnStationsUpdate(getAndStoreSavedStations);
  }
  onAppStateUpdate = _ramda2.default.cond([[_ramda2.default.prop('stations'), onSavedStationsAdded]]);

  appState.addOnAppStateUpdate(onAppStateUpdate);
  storage.get('stations', getStorageStationsCallback);
}

},{"ramda":378}],25:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Mananges the functions that render html via handlebars templates.
 * @param {object} templates - a hash map of handlebars templates
 * @param {object} strings - appStrings
 * @param {object} stationCreatorWidget - mananges the station search module
 */

exports.default = function (templates, strings, stationCreatorWidget) {
  function emptyView() {
    return templates.empty({
      emptyTitle: strings['app.emptyTitle'],
      emptyMessage: strings['app.emptyMessage']
    });
  }
  function stationsView(stations) {
    return templates.stations({
      stations: stations,
      title: strings['app.sortBy']
    });
  }
  function errorView() {
    var div = document.createElement('div');
    div.className = 'error-and-offline-container';
    div.innerHTML = templates.offlineError({
      offlineTitle: strings['app.offlineTitle'],
      offlineMessage: strings['app.offlineMessage'],
      errorTitle: strings['app.errorTitle'],
      errorMessage: strings['app.errorMessage']
    });
    document.body.appendChild(div);
  }
  function addCreateButton() {
    var actionButton = document.querySelector('.action-button');
    if (actionButton) {
      stationCreatorWidget.addButtonToElement(actionButton);
    }
  }
  return {
    emptyView: emptyView,
    addCreateButton: addCreateButton,
    stationsView: stationsView,
    errorView: errorView
  };
};

},{}],26:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.remove = remove;
exports.show = show;

var _DOM_class_utils = require('../utils/DOM_class_utils');

var _DOM_class_utils2 = _interopRequireDefault(_DOM_class_utils);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var addClass = _DOM_class_utils2.default.addClass;

function remove() {
  var container = document.querySelector('.error-and-offline-container');
  if (container) {
    document.body.removeChild(container);
  }
}

function show() {
  addClass('show-error-screen', document.body);
}

},{"../utils/DOM_class_utils":30}],27:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, functionType="function", escapeExpression=this.escapeExpression;


  buffer += "<div class=\"empty-content\">\n  <div class=\"empty-container\">\n    <div class=\"message\">\n      <h1 class=\"hdr-l\">";
  if (helper = helpers.emptyTitle) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.emptyTitle); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</h1>\n      <p class=\"empty-body\">";
  if (helper = helpers.emptyMessage) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.emptyMessage); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "</p>\n      <div class=\"action-button\"></div>\n    </div>\n  </div>\n</div>\n";
  return buffer;
  });

},{"hbsfy/runtime":320}],28:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
var partial$0 = require('../../../../../libs/spotify-glue-cat/templates/v1/media-object-station.hbs');
HandlebarsCompiler.registerPartial('../../../../../libs/spotify-glue-cat/templates/v1/media-object-station.hbs', partial$0);
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); partials = this.merge(partials, Handlebars.partials); data = data || {};
  var buffer = "", stack1, self=this;


  buffer += "<div class=\"col-xs-6 col-sm-4 col-md-3 col-lg-2 image-grid\">\n";
  stack1 = self.invokePartial(partials['../../../../../libs/spotify-glue-cat/templates/v1/media-object-station.hbs'], '../../../../../libs/spotify-glue-cat/templates/v1/media-object-station.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n</div>\n";
  return buffer;
  });

},{"../../../../../libs/spotify-glue-cat/templates/v1/media-object-station.hbs":137,"hbsfy/runtime":320}],29:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, functionType="function", escapeExpression=this.escapeExpression;


  buffer += "<div class=\"row section-divider\">\n  <h3 class=\"stations-title\">";
  if (helper = helpers.title) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.title); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</h3>\n</div>\n<div class=\"standard-grid row\">";
  if (helper = helpers.stations) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.stations); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "</div>\n";
  return buffer;
  });

},{"hbsfy/runtime":320}],30:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * DOM Utility Functions so we don't have to use all of mootools
 */

function clean(str) {
  var a = str.replace(/\s+/g, ' ');
  var b = a.replace(/^\s+|\s+$/g, '');
  return b;
}

function addClass(className, el) {
  if (el.className.indexOf(className) === -1) {
    el.className = clean(el.className + ' ' + className);
  }
}
function removeClass(className, el) {
  el.className = el.className.replace(new RegExp('(^|\\s)' + className + '(?:\\s|$)'), '$1');
}
function validateClass(uri) {
  var str = uri.replace(/:/g, '');
  str = str.replace(/%/g, '');
  str = str.replace(/\./g, '');
  return str;
}

// used as a handlebar helper as well
validateClass.displayName = 'validateClass';

exports.default = {
  removeClass: removeClass,
  addClass: addClass,
  validateClass: validateClass
};

},{}],31:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Returns a function that takes a string of html
 * and sets the innerHTML of a preset DOM selector
 * @param String DOM selector e.g. '.container'
 * @return Function
 */

exports.default = function (selector) {
  return function (html) {
    document.querySelector(selector).innerHTML = html;
  };
};

},{}],32:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

exports.default = function (a) {
  return function () {
    console.log(arguments);
    return a.apply(this, arguments);
  };
};

},{}],33:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createHtmlInjector = require('../utils/create-html-injector');

var _createHtmlInjector2 = _interopRequireDefault(_createHtmlInjector);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

exports.default = (0, _createHtmlInjector2.default)('.stations-container');

},{"../utils/create-html-injector":31}],34:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
/**
 * Converts a station live model into a media object
 * @param {Object} station live model
 * @return {Object} media-object
 */

exports.default = function (appStrings) {
  return function (station) {
    return {
      uri: station.uri,
      modifiers: 'added',
      name: station.name,
      imageUrl: station.image,
      meta: appStrings['station.' + station.type],
      overlayImageUrl: station.image,
      seedUri: station.baseSeed,

      artists: [{
        name: station.subtitle.name || '',
        uri: station.subtitle.uri || '' }]
    };
  };
};

},{}],35:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _ramda = require('ramda');

var _ramda2 = _interopRequireDefault(_ramda);

var _injectStationsHtml = require('./utils/inject-stations-html');

var _injectStationsHtml2 = _interopRequireDefault(_injectStationsHtml);

var _debug = require('./utils/debug');

var _debug2 = _interopRequireDefault(_debug);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * View Controller manages the rendering of all the views in this app.
 * There are no exposed public methods other than the intial exported function.
 * The controller listens for changes on the appState
 * and either renders an error, an empty view, or a stations view. Once the
 * appState contains stations we will remove the error view from the DOM,
 * as it is no longer needed for the rest of the life of the app.
 * @param {object} events - spotify-events
 * @param {object} appState - the application state './app-state.js'
 * @param {object} renderManager - './render-manager/'
 * @param {object} showRemoveError - './show-remove-error/'
 * @param {function} stationToMediaObject - './utils/station-to-media-object.js'
 * @param {object} templates - a hash of all the handlebars templates
 */

exports.default = function (events, appState, renderManager, showRemoveError, stationToMediaObject, templates) {
  var onAppStateUpdate = void 0;

  // Query the appState live object and display the stations
  function getAndDisplaySavedStations() {
    appState.getStations() // returns an array
    .then(_ramda2.default.pipe(_ramda2.default.transduce( // array to a string
    // create html string
    _ramda2.default.map(_ramda2.default.pipe(stationToMediaObject, templates.station)), _ramda2.default.add, // add the html strings together (reduce)
    '' // start with an empty string
    ), _ramda2.default.ifElse(_ramda2.default.identity, // if there is not an empty string after transduce
    renderManager.stationsView, // show stations template
    renderManager.emptyView // else show empty template
    ), _injectStationsHtml2.default, // add the html to the DOM
    renderManager.addCreateButton, // works only with the empty template
    showRemoveError.remove, // remove the error view completely
    events.update)).catch((0, _debug2.default)(showRemoveError.show)); // log out the error if this fails
  }

  // When savedStations are added to the appState for the first time.
  function onSavedStationsAdded() {
    getAndDisplaySavedStations();
    appState.removeOnAppStateUpdate(onAppStateUpdate);
    appState.addOnStationsUpdate(getAndDisplaySavedStations);
  }

  /**
   * When the appState object is updated
   * If there is an error show the error screen
   * If there are savedStations then call onSavedStationsAdded
   * @param {object} data live update object
   */
  onAppStateUpdate = _ramda2.default.cond([[_ramda2.default.prop('error'), showRemoveError.show], [_ramda2.default.prop('stations'), onSavedStationsAdded]]);

  appState.addOnAppStateUpdate(onAppStateUpdate);
  renderManager.errorView();
};

},{"./utils/debug":32,"./utils/inject-stations-html":33,"ramda":378}],36:[function(require,module,exports){
'use strict';

var _spotifyGlueCat = require('../../../libs/spotify-glue-cat');

var _spotifyGlueCat2 = _interopRequireDefault(_spotifyGlueCat);

var _spotifyLive = require('../../../libs/spotify-live');

var _spotifyLive2 = _interopRequireDefault(_spotifyLive);

var _spotifyEvents = require('../../../libs/spotify-events');

var _spotifyEvents2 = _interopRequireDefault(_spotifyEvents);

var _spotifyLiveModels = require('../../../libs/spotify-live-models');

var _spotifyLiveModels2 = _interopRequireDefault(_spotifyLiveModels);

var _spotifyLocalStorage = require('../../../libs/spotify-local-storage');

var _spotifyLocalStorage2 = _interopRequireDefault(_spotifyLocalStorage);

var _station = require('../../../libs/spotify-live-models/station');

var _station2 = _interopRequireDefault(_station);

var _spotifyHandlebars = require('../../../libs/spotify-handlebars');

var _spotifyHandlebars2 = _interopRequireDefault(_spotifyHandlebars);

var _helpers = require('../../../libs/spotify-handlebars/helpers');

var _helpers2 = _interopRequireDefault(_helpers);

var _i18n = require('../i18n');

var _i18n2 = _interopRequireDefault(_i18n);

var _spotifyDomLogger = require('../../../libs/spotify-dom-logger');

var _spotifyDomLogger2 = _interopRequireDefault(_spotifyDomLogger);

var _stationMessageProxy = require('../../../libs/spotify-live-models/station/station-message-proxy');

var _stationMessageProxy2 = _interopRequireDefault(_stationMessageProxy);

var _stationCreatorWidget = require('../../../libs/station-creator-widget');

var _stationCreatorWidget2 = _interopRequireDefault(_stationCreatorWidget);

var _appState = require('./app/app-state');

var _appState2 = _interopRequireDefault(_appState);

var _errorAndOffline = require('../../../libs/spotify-glue-cat/templates/v1/error-and-offline.hbs');

var _errorAndOffline2 = _interopRequireDefault(_errorAndOffline);

var _station3 = require('./app/templates/station.hbs');

var _station4 = _interopRequireDefault(_station3);

var _stations = require('./app/templates/stations.hbs');

var _stations2 = _interopRequireDefault(_stations);

var _empty = require('./app/templates/empty.hbs');

var _empty2 = _interopRequireDefault(_empty);

var _showRemoveError = require('./app/show-remove-error');

var showRemoveError = _interopRequireWildcard(_showRemoveError);

var _renderManager = require('./app/render-manager');

var _renderManager2 = _interopRequireDefault(_renderManager);

var _stationToMediaObject = require('./app/utils/station-to-media-object');

var _stationToMediaObject2 = _interopRequireDefault(_stationToMediaObject);

var _viewController = require('./app/view-controller');

var _viewController2 = _interopRequireDefault(_viewController);

var _clientFollowController = require('./app/client-follow-controller');

var _clientFollowController2 = _interopRequireDefault(_clientFollowController);

var _localStorage = require('./app/local-storage');

var _localStorage2 = _interopRequireDefault(_localStorage);

var _getBackendData = require('./app/get-backend-data');

var _getBackendData2 = _interopRequireDefault(_getBackendData);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_spotifyGlueCat2.default.gridOverlay.listen();

_spotifyLiveModels2.default.register();

_station2.default.register();

_spotifyEvents2.default.attach();
_spotifyEvents2.default.update();

var glueStrings = _i18n2.default.glueStrings();
var appStrings = _i18n2.default.appStrings();

_helpers2.default.loc.register(glueStrings);
_helpers2.default.loc.register(appStrings);
_helpers2.default.numeral.setLocale(_i18n2.default.locale());
_spotifyHandlebars2.default.register(_helpers2.default);

new _spotifyDomLogger2.default().init();

var appState = (0, _appState2.default)(_spotifyLive2.default);

// A hash of all the templates set here for easy test mocking.
var templates = { offlineError: _errorAndOffline2.default, station: _station4.default, stations: _stations2.default, empty: _empty2.default };

var renderManager = (0, _renderManager2.default)(templates, appStrings, _stationCreatorWidget2.default);
var stationToMediaObject = (0, _stationToMediaObject2.default)(appStrings);

// It's important that these requires are in this order.
(0, _viewController2.default)(_spotifyEvents2.default, appState, renderManager, showRemoveError, stationToMediaObject, templates);

(0, _clientFollowController2.default)(appState);
(0, _localStorage2.default)(_spotifyLocalStorage2.default, appState);
(0, _getBackendData2.default)(_stationMessageProxy2.default, appState);

require('../../../libs/spotify-expose-dev-mode-debug-globals/bridge').init();
require('../../../libs/spotify-expose-dev-mode-debug-globals/live').init();
require('../../../libs/spotify-expose-dev-mode-debug-globals/cosmos').init();

},{"../../../libs/spotify-dom-logger":40,"../../../libs/spotify-events":65,"../../../libs/spotify-expose-dev-mode-debug-globals/bridge":108,"../../../libs/spotify-expose-dev-mode-debug-globals/cosmos":109,"../../../libs/spotify-expose-dev-mode-debug-globals/live":111,"../../../libs/spotify-glue-cat":131,"../../../libs/spotify-glue-cat/templates/v1/error-and-offline.hbs":135,"../../../libs/spotify-handlebars":156,"../../../libs/spotify-handlebars/helpers":147,"../../../libs/spotify-live":212,"../../../libs/spotify-live-models":176,"../../../libs/spotify-live-models/station":197,"../../../libs/spotify-live-models/station/station-message-proxy":201,"../../../libs/spotify-local-storage":217,"../../../libs/station-creator-widget":274,"../i18n":11,"./app/app-state":21,"./app/client-follow-controller":22,"./app/get-backend-data":23,"./app/local-storage":24,"./app/render-manager":25,"./app/show-remove-error":26,"./app/templates/empty.hbs":27,"./app/templates/station.hbs":28,"./app/templates/stations.hbs":29,"./app/utils/station-to-media-object":34,"./app/view-controller":35}],37:[function(require,module,exports){
'use strict';

// Base function that doesn't have any dependencies on it's own. Expects to get
// state (a plain, empty object) injected in addition to a bridge request
// function.
function cosmosRequest(state, bridge, opts, callback) {

  if (typeof opts.uri !== 'string') throw new Error('Expected uri to be string.');

  if (COSMOS_VERBS.indexOf(opts.method) === -1) throw new Error('Method must match valid verb in uppercase (GET, POST etc)');

  if (opts.body && typeof opts.body !== 'string') throw new Error('If body is provided it should be a string.');

  if (opts.headers && Object.prototype.toString.call(opts.headers) !== '[object Object]') throw new Error('Expected headers be a plain object.');

  var cosmosOptions = {
    action: opts.method,
    uri: opts.uri
  };
  if (opts.body) cosmosOptions.body = opts.body;
  if (opts.headers) cosmosOptions.headers = opts.headers;

  /* Cosmos requires each request to have a unique ID. Ideally, this would be
  uuids, but unfortunately, it is integers. This means that in apps that for
  some reason need to use spotify-cosmos-api, there would between the two
  counters if cosmosRequest started from 0. To make it safe for the two
  implemenations to co-exist if needed, we begin counting at
  significantly higher number: */
  state.requestIDCounter = state.requestIDCounter || TEN_PER_SECOND_FOR_A_YEAR;
  state.requestIDCounter++;

  var requestArguments = [state.requestIDCounter, cosmosOptions];

  var isCanceled = false;
  var stateRequestIDCounter = state.requestIDCounter;

  function cancelFunction() {
    isCanceled = true;
    bridge('cosmos_request_cancel', [stateRequestIDCounter]);
  }

  // run is a recursive function that does a bridge request and then keeps
  // pulling values after every response in the case of a subscription. In
  // case we are not subscribing, or the cancelFunction has been called,
  // run sends cosmos_request_cancel and terminates.
  function run(isFirst, requestIDCounter) {
    var messageName = isFirst ? 'cosmos_request_create' : 'cosmos_request_pull';
    bridge(messageName, requestArguments, function (error, responseString) {
      // The request to cancel may not have gotten to the bridge
      // before the original request got resolved,
      // so make sure not to continue if we detect it's been canceled.
      if (isCanceled) {
        return;
      }
      try {
        if (callback) {
          if (error) {
            callback(error);
          } else {
            callback(null, responseString);
          }
        }
      } finally {
        if (opts.method !== 'SUB') {
          // If the request was a non-SUB, tell core to clean up the request.
          // NOTE: Not sure if this is strictly necessary,
          // have not been to investigate in C++-land, so for now
          // we are just mimicing the behavior of spotify-cosmos-api.
          bridge('cosmos_request_cancel', [requestIDCounter]);
        } else if (!isCanceled) {
          // maybe canceled in above callback
          run(false, requestIDCounter);
        }
      }
    });
  }

  run(true, stateRequestIDCounter);

  return cancelFunction;
}

var TEN_PER_SECOND_FOR_A_YEAR = 10 * 60 * 60 * 24 * 365;

var COSMOS_VERBS = ['GET', 'HEAD', 'POST', 'PUT', 'SUB', 'PATCH', 'DELETE'];

module.exports = cosmosRequest;

},{}],38:[function(require,module,exports){
(function (global){
'use strict';

var debug = require('debug')('spotify-bridge-request');
var defer = require('spotify-deferred');

var cosmosBaseFunction = require('./cosmos');

// NOTE: Implicit global state.
var scheduledCoreFlush = false;
var cosmosState = null;

exports.cosmos = cosmos;
exports.cosmosJSON = cosmosJSON;
exports.request = request;
exports._request = _request;

function cosmos() {
  if (!cosmosState) cosmosState = {};

  var baseArguments = [cosmosState, request];
  var cancelFunction = cosmosBaseFunction.apply(null, baseArguments.concat(Array.prototype.slice.call(arguments)));
  return cancelFunction;
}

function _createCallbackWrapper(callback) {
  return function callbackWrapper(err, response) {
    if (!err) {
      var parsedResponse;
      try {
        parsedResponse = JSON.parse(response.body);
      } catch (e) {
        e.message = 'Failed to parse cosmos response: ' + e.message;
        callback(e);
        return;
      }
      callback(null, parsedResponse);
    } else {
      callback(err, response);
    }
  };
}

function cosmosJSON(opts, callback) {
  if (opts.body) {
    opts.body = JSON.stringify(opts.body);
  }
  var callbackWrapper = callback ? _createCallbackWrapper(callback) : null;
  var cancelFunction = cosmos(opts, callbackWrapper);
  return cancelFunction;
}

function request(name, opt_args, opt_callback) {
  var args = opt_args || [];
  var callback = getCallback(name, args, opt_callback);

  debug('req:' + name, args);

  exports._request(name, args, callback);

  if (name !== 'core_flush' && !scheduledCoreFlush) {
    scheduledCoreFlush = true;
    defer(flushCore);
  }

  return exports;
}

function _request(name, args, callback) {
  global._getSpotifyModule('bridge').executeRequest(JSON.stringify({
    name: name,
    args: args
  }), {
    onSuccess: getSuccessHandler(callback),
    onFailure: getFailureHandler(callback, name, args)
  });
}

function getCallback(name, args, opt_userCallback) {
  var userCallback = opt_userCallback || function () {};

  return function (error, data) {
    if (error) {
      if (error.name === 'timeout') {
        // Set the delay between 300ms and 400ms
        var delay = 300 + Math.floor(Math.random() * 100);

        debug('timeout', error.message);

        // Retry the request
        setTimeout(function () {
          request(name, args, userCallback);
        }, delay);
        return;
      }
    }

    debug('res:' + name, args, data);

    userCallback(error, data);
  };
}

function getSuccessHandler(requestCallback) {
  return function (data) {
    var parsed;

    debug('success', data);

    try {
      parsed = JSON.parse(data);
    } catch (error) {
      requestCallback(error);
    }

    if (parsed) {
      requestCallback(null, parsed);
    }
  };
}

function getFailureHandler(requestCallback, name, args) {
  return function (data) {
    var parsed;

    debug('failure', data);

    try {
      parsed = JSON.parse(data);
    } catch (error) {
      requestCallback(error);
    }

    if (parsed) {
      requestCallback(createError(name, args, parsed));
    }
  };
}

function createError(name, args, response) {
  var argsString = JSON.stringify(args);
  var debug = ' (bridge message: \'' + name + '\', args: ' + argsString + ')';
  var msg = response.message + debug;
  var error = new Error(msg);
  error.name = response.error;

  return error;
}

function flushCore() {
  scheduledCoreFlush = false;
  request('core_flush');
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./cosmos":37,"debug":287,"spotify-deferred":393}],39:[function(require,module,exports){
'use strict';

var parser = require('../spotify-live/util/parser');

var sortMap = {
  track: {
    _replace: '',
    artists: {
      _replace: 'artist'
    },
    disc: {
      _replace: 'discNumber'
    },
    number: {
      _replace: 'trackNumber'
    },
    duration: {
      _replace: 'length'
    }
  },
  timeSinceAdded: {
    _reverse: true,
    _replace: 'addTime'
  },
  addedBy: {
    _replace: '',
    name: {
      _replace: 'addedByDisplayName'
    }
  }
};

function reverse(direction) {
  return direction === 'ASC' ? 'DESC' : 'ASC';
}

function walk(query, mapping, opt_direction, incomingCollector) {
  var results = [];
  var collector = incomingCollector && incomingCollector.slice() || [];

  for (var item, i = 0; item = query.mask[i]; i++) {
    var itemCollector = collector.slice();

    if (item.key) {
      var hasReplace = mapping && mapping[item.key] && mapping[item.key]._replace != null;

      var value = hasReplace ? mapping[item.key]._replace : item.key;
      if (value !== '') {

        // Only add the direction if there's not another sub object
        if (!item.mask) {
          var doReverse = !!(mapping && mapping[item.key] && mapping[item.key]._reverse);
          if (opt_direction) {
            opt_direction = opt_direction.toUpperCase();
            var direction = doReverse ? reverse(opt_direction) : opt_direction;
            value += ' ' + direction;
          }
        }
        itemCollector.push(value);
      }
    }

    if (item.mask) {
      var subLookUp = walk(item, mapping[item.key], opt_direction, itemCollector);
      if (subLookUp.length) {
        results.push(subLookUp);
      }
    } else {
      if (itemCollector.length) {
        results.push(itemCollector.join('.'));
      }
    }
  }
  return results;
}

function getParams(query, opt_direction, opt_map) {
  var parsed = parser(query);
  if (!query) return null;

  var map = opt_map || sortMap;
  var result = walk(parsed, map, opt_direction);

  return result.join(',');
}

module.exports = getParams;

},{"../spotify-live/util/parser":215}],40:[function(require,module,exports){
(function (global){
'use strict';

var ClientEvent3 = require('../spotify-logger/messages/ClientEvent3');
var objectAssign = require('../../vendor/object-assign');

/**
 * See README.md for documentation on how to use.
 *
 * @param {Object} options Options for the logger.
 * @param {Logger} options.logger A Logger instance used for the logging. Must be provided and
 *     should have two methods: userSelect and userHit.
 */
function DomLogger(opt_options) {
  opt_options = opt_options || {};
  this.document = opt_options.document || document;
  this.appName = (global.__spotify && global.__spotify.app_uri && global.__spotify.app_uri.match(/^spotify:app:([^:]+)/) || [null, null])[1];
  if (this.appName === null) {
    console.warn('__spotify.app_uri is null. This is needed for proper logging via spotify-dom-logger.');
  }
  this.base_json_data = {};
};

DomLogger.GATHERED_ATTRIBUTES = ['data-log-click', 'data-log-context', 'data-log-data'];

/**
 * Initializes the DOM logger.
 * @public
 */
DomLogger.prototype.init = function () {
  this.document.addEventListener('click', this._handleClick.bind(this), true);
};

/**
 * Set Constant values in the json_data field.
 * @public
 * @param {Object} data - an object literal of data you want kept constant.
 */
DomLogger.prototype.setConstantData = function (data) {
  this.base_json_data = data;
};

/**
 * Actually calls the log method from ClientEvent3.
 * @private
 */
DomLogger.prototype._logData = function (event, context, eventVersion, data) {
  var jsonData = objectAssign({}, this.base_json_data, data);
  ClientEvent3.log({
    context: context,
    event: event,
    event_version: eventVersion,
    source: this.appName,
    source_vendor: 'com.spotify',
    json_data: jsonData
  });
};

/**
 * Log a click on the specified event.
 * @param {Node} element DOM element.
 */
DomLogger.prototype.logClick = function (clickedElement) {
  // Go up the DOM tree until an element with the "data-log-click" attribute is found.
  var element = clickedElement;
  var identifier = 'unknown-element';

  var attrs = this._gatherAttributes(DomLogger.GATHERED_ATTRIBUTES, element);

  // Use the nearest data-log-click if one was found.
  if (attrs.values['data-log-click'].length) {
    element = attrs.nodes['data-log-click'].pop();
    identifier = attrs.values['data-log-click'].pop();
  }

  // Parse and merge all data-log-data JSON strings.
  var data = attrs.values['data-log-data'] ? this._mergeJSONStrings(attrs.values['data-log-data']) : {};

  // Optionally blank.
  var context = attrs.values['data-log-context'].join('/');

  if (element.getAttribute('data-log-click-as-select')) {
    this._logData('user:select', context, identifier, data);
  } else {
    this._logData('user:hit', context, identifier, data);
  }
};

/**
 * Handles a click in the document.
 * @param  {Object} event Event data.
 */
DomLogger.prototype._handleClick = function (event) {
  this.logClick(event.target);
};

/**
 * Give an array of strings, assume each is a JSON string representing an
 * object, parse each, and merge their properties (top level only).
 * @return {Object}
 */
DomLogger.prototype._mergeJSONStrings = function (datas) {
  try {
    datas = datas.map(function (item) {
      return JSON.parse(item);
    });
  } catch (e) {
    console.log('Failed to parse data-log-data (needs to be proper JSON):', datas);
    datas = [];
  }

  return datas.reduce(function (accum, cur) {
    Object.keys(cur).forEach(function (key) {
      accum[key] = cur[key];
    });
    return accum;
  }, {});
};

/**
 * Given an array of string attribute names, recursively traverse the DOM
 * upwards, collecting the attribute values and nodes containing those values.
 *
 * @example of returned object
 * {
 *   nodes: {
 *     'data-log-click': [Node, Node]
 *   },
 *   values: {
 *     'data-log-click': ['play-button', 'track-row']
 *   }
 * }
 */
DomLogger.prototype._gatherAttributes = function (attributes, element, opt_resultMap) {
  var resultMap = opt_resultMap || {
    nodes: {},
    values: {}
  };

  if (element.parentNode && element.parentNode.getAttribute) {
    this._gatherAttributes(attributes, element.parentNode, resultMap);
  }

  for (var i = 0; i < attributes.length; i++) {
    var name = attributes[i];
    var value = element.getAttribute(name);

    // Ensure name is present in map regardless of presence on a node.
    resultMap.values[name] = resultMap.values[name] || [];
    // Same for nodes map
    resultMap.nodes[name] = resultMap.nodes[name] || [];

    if (value) {
      resultMap.values[name].push(value);
      resultMap.nodes[name].push(element);
    }
  }

  return resultMap;
};

module.exports = DomLogger;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../vendor/object-assign":440,"../spotify-logger/messages/ClientEvent3":222}],41:[function(require,module,exports){
/*
attributes
*/"use strict";

var $ = require("./base");

var trim = require("mout/string/trim"),
    forEach = require("mout/array/forEach"),
    filter = require("mout/array/filter"),
    indexOf = require("mout/array/indexOf");

// attributes

$.implement({

    setAttribute: function setAttribute(name, value) {
        return this.forEach(function (node) {
            node.setAttribute(name, value);
        });
    },

    getAttribute: function getAttribute(name) {
        var attr = this[0].getAttributeNode(name);
        return attr && attr.specified ? attr.value : null;
    },

    hasAttribute: function hasAttribute(name) {
        var node = this[0];
        if (node.hasAttribute) return node.hasAttribute(name);
        var attr = node.getAttributeNode(name);
        return !!(attr && attr.specified);
    },

    removeAttribute: function removeAttribute(name) {
        return this.forEach(function (node) {
            var attr = node.getAttributeNode(name);
            if (attr) node.removeAttributeNode(attr);
        });
    }

});

var accessors = {};

forEach(["type", "value", "name", "href", "title", "id"], function (name) {

    accessors[name] = function (value) {
        return value !== undefined ? this.forEach(function (node) {
            node[name] = value;
        }) : this[0][name];
    };
});

// booleans

forEach(["checked", "disabled", "selected"], function (name) {

    accessors[name] = function (value) {
        return value !== undefined ? this.forEach(function (node) {
            node[name] = !!value;
        }) : !!this[0][name];
    };
});

// className

var classes = function classes(className) {
    var classNames = trim(className).replace(/\s+/g, " ").split(" "),
        uniques = {};

    return filter(classNames, function (className) {
        if (className !== "" && !uniques[className]) return uniques[className] = className;
    }).sort();
};

accessors.className = function (className) {
    return className !== undefined ? this.forEach(function (node) {
        node.className = classes(className).join(" ");
    }) : classes(this[0].className).join(" ");
};

// attribute

$.implement({

    attribute: function attribute(name, value) {
        var accessor = accessors[name];
        if (accessor) return accessor.call(this, value);
        if (value != null) return this.setAttribute(name, value);
        if (value === null) return this.removeAttribute(name);
        if (value === undefined) return this.getAttribute(name);
    }

});

$.implement(accessors);

// shortcuts

$.implement({

    check: function check() {
        return this.checked(true);
    },

    uncheck: function uncheck() {
        return this.checked(false);
    },

    disable: function disable() {
        return this.disabled(true);
    },

    enable: function enable() {
        return this.disabled(false);
    },

    select: function select() {
        return this.selected(true);
    },

    deselect: function deselect() {
        return this.selected(false);
    }

});

// classNames, has / add / remove Class

$.implement({

    classNames: function classNames() {
        return classes(this[0].className);
    },

    hasClass: function hasClass(className) {
        return indexOf(this.classNames(), className) > -1;
    },

    addClass: function addClass(className) {
        return this.forEach(function (node) {
            var nodeClassName = node.className;
            var classNames = classes(nodeClassName + " " + className).join(" ");
            if (nodeClassName !== classNames) node.className = classNames;
        });
    },

    removeClass: function removeClass(className) {
        return this.forEach(function (node) {
            var classNames = classes(node.className);
            forEach(classes(className), function (className) {
                var index = indexOf(classNames, className);
                if (index > -1) classNames.splice(index, 1);
            });
            node.className = classNames.join(" ");
        });
    },

    toggleClass: function toggleClass(className, force) {
        var add = force !== undefined ? force : !this.hasClass(className);
        if (add) this.addClass(className);else this.removeClass(className);
        return !!add;
    }

});

// toString

$.prototype.toString = function () {
    var tag = this.tag(),
        id = this.id(),
        classes = this.classNames();

    var str = tag;
    if (id) str += '#' + id;
    if (classes.length) str += '.' + classes.join(".");
    return str;
};

var textProperty = document.createElement('div').textContent == null ? 'innerText' : 'textContent';

// tag, html, text, data

$.implement({

    tag: function tag() {
        return this[0].tagName.toLowerCase();
    },

    html: function html(_html) {
        return _html !== undefined ? this.forEach(function (node) {
            node.innerHTML = _html;
        }) : this[0].innerHTML;
    },

    text: function text(_text) {
        return _text !== undefined ? this.forEach(function (node) {
            node[textProperty] = _text;
        }) : this[0][textProperty];
    },

    data: function data(key, value) {
        switch (value) {
            case undefined:
                return this.getAttribute("data-" + key);
            case null:
                return this.removeAttribute("data-" + key);
            default:
                return this.setAttribute("data-" + key, value);
        }
    }

});

module.exports = $;

},{"./base":42,"mout/array/filter":327,"mout/array/forEach":330,"mout/array/indexOf":331,"mout/string/trim":370}],42:[function(require,module,exports){
/*
elements
*/"use strict";

var prime = require("prime");

var _forEach = require("mout/array/forEach"),
    _map = require("mout/array/map"),
    _filter = require("mout/array/filter"),
    _every = require("mout/array/every"),
    _some = require("mout/array/some");

// uniqueID

var index = 0,
    __dc = document.__counter,
    counter = document.__counter = (__dc ? parseInt(__dc, 36) + 1 : 0).toString(36),
    key = "uid:" + counter;

var uniqueID = function uniqueID(n) {
    if (n === window) return "window";
    if (n === document) return "document";
    if (n === document.documentElement) return "html";
    return n[key] || (n[key] = (index++).toString(36));
};

var instances = new WeakMap();

// elements prime

var $ = prime({ constructor: function $(n, context) {

        if (n == null) return this && this.constructor === $ ? new Elements() : null;

        var self, uid, instance;

        if (n.constructor !== Elements) {

            self = new Elements();

            if (typeof n === "string") {
                if (!self.search) return null;
                self[self.length++] = context || document;
                return self.search(n);
            }

            if (n.nodeType || n === window) {

                self[self.length++] = n;
            } else if (n.length) {

                // this could be an array, or any object with a length attribute,
                // including another instance of elements from another interface.

                var uniques = {};

                for (var i = 0, l = n.length; i < l; i++) {
                    // perform elements flattening
                    var nodes = $(n[i], context);
                    if (nodes && nodes.length) for (var j = 0, k = nodes.length; j < k; j++) {
                        var node = nodes[j];
                        uid = uniqueID(node);
                        if (!uniques[uid]) {
                            self[self.length++] = node;
                            uniques[uid] = true;
                        }
                    }
                }
            }
        } else {
            self = n;
        }

        if (!self.length) return null;

        // when length is 1 always use the same elements instance

        if (self.length === 1) {
            if (instance = instances.get(self[0])) {
                return instance;
            } else {
                instances.set(self[0], self);
            }
        }

        return self;
    } });

var Elements = prime({

    inherits: $,

    constructor: function Elements() {
        this.length = 0;
    },

    unlink: function unlink() {
        return this.map(function (node) {
            instances.delete(node);
            return node;
        });
    },

    // methods

    forEach: function forEach(method, context) {
        _forEach(this, method, context);
        return this;
    },

    map: function map(method, context) {
        return _map(this, method, context);
    },

    filter: function filter(method, context) {
        return _filter(this, method, context);
    },

    every: function every(method, context) {
        return _every(this, method, context);
    },

    some: function some(method, context) {
        return _some(this, method, context);
    }

});

module.exports = $;

},{"mout/array/every":326,"mout/array/filter":327,"mout/array/forEach":330,"mout/array/map":333,"mout/array/some":336,"prime":375}],43:[function(require,module,exports){
/*
delegation
*/"use strict";

var Map = require("prime/map");

var $ = require("./events");
require('./traversal');

$.implement({

    delegate: function delegate(event, selector, handle) {

        return this.forEach(function (node) {

            var self = $(node);

            var delegation = self._delegation || (self._delegation = {}),
                events = delegation[event] || (delegation[event] = {}),
                map = events[selector] || (events[selector] = new Map());

            if (map.get(handle)) return;

            var action = function action(e) {
                var target = $(e.target || e.srcElement),
                    match = target.matches(selector) ? target : target.parent(selector);

                var res;

                if (match) res = handle.call(self, e, match);

                return res;
            };

            map.set(handle, action);

            self.on(event, action);
        });
    },

    undelegate: function undelegate(event, selector, handle) {

        return this.forEach(function (node) {

            var self = $(node),
                delegation,
                events,
                map;

            if (!(delegation = self._delegation) || !(events = delegation[event]) || !(map = events[selector])) return;

            var action = map.get(handle);

            if (action) {
                self.off(event, action);
                map.remove(action);

                // if there are no more handles in a given selector, delete it
                if (!map.count()) delete events[selector];
                // var evc = evd = 0, x
                var e1 = true,
                    e2 = true,
                    x;
                for (x in events) {
                    e1 = false;
                    break;
                }
                // if no more selectors in a given event type, delete it
                if (e1) delete delegation[event];
                for (x in delegation) {
                    e2 = false;
                    break;
                }
                // if there are no more delegation events in the element, delete the _delegation object
                if (e2) delete self._delegation;
            }
        });
    }

});

module.exports = $;

},{"./events":44,"./traversal":47,"prime/map":376}],44:[function(require,module,exports){
/*
events
*/"use strict";

var Emitter = require("prime/emitter");

var $ = require("./base");

$.implement({

    on: function on(event, handle, useCapture) {

        return this.forEach(function (node) {
            var self = $(node);

            var internalEvent = event + (useCapture ? ":capture" : "");

            Emitter.prototype.on.call(self, internalEvent, handle);

            var domListeners = self._domListeners || (self._domListeners = {});
            if (!domListeners[internalEvent]) {
                var listener = function listener(e) {
                    Emitter.prototype.emit.call(self, internalEvent, e || window.event, Emitter.EMIT_SYNC);
                };
                node.addEventListener(event, listener, useCapture || false);
                domListeners[internalEvent] = listener;
            }
        });
    },

    off: function off(event, handle, useCapture) {

        return this.forEach(function (node) {

            var self = $(node);

            var internalEvent = event + (useCapture ? ":capture" : "");

            var domListeners = self._domListeners,
                domEvent,
                listeners = self._listeners,
                events;

            if (domListeners && (domEvent = domListeners[internalEvent]) && listeners && (events = listeners[internalEvent])) {

                Emitter.prototype.off.call(self, internalEvent, handle);

                if (!self._listeners || !self._listeners[event]) {
                    node.removeEventListener(event, domEvent, false);
                    delete domListeners[event];

                    for (var l in domListeners) {
                        return;
                    }delete self._domListeners;
                }
            }
        });
    },

    emit: function emit() {
        var args = arguments;
        return this.forEach(function (node) {
            Emitter.prototype.emit.apply($(node), args);
        });
    }

});

module.exports = $;

},{"./base":42,"prime/emitter":374}],45:[function(require,module,exports){
/*
elements
*/"use strict";

var $ = require("./base");
require("./attributes");
require("./events");
require("./insertion");
require("./traversal");
require("./delegation");

module.exports = $;

},{"./attributes":41,"./base":42,"./delegation":43,"./events":44,"./insertion":46,"./traversal":47}],46:[function(require,module,exports){
/*
insertion
*/"use strict";

var $ = require("./base");

// base insertion

$.implement({

    appendChild: function appendChild(child) {
        this[0].appendChild($(child)[0]);
        return this;
    },

    insertBefore: function insertBefore(child, ref) {
        this[0].insertBefore($(child)[0], $(ref)[0]);
        return this;
    },

    removeChild: function removeChild(child) {
        this[0].removeChild($(child)[0]);
        return this;
    },

    replaceChild: function replaceChild(child, ref) {
        this[0].replaceChild($(child)[0], $(ref)[0]);
        return this;
    }

});

// before, after, bottom, top

$.implement({

    before: function before(element) {
        element = $(element)[0];
        var parent = element.parentNode;
        if (parent) this.forEach(function (node) {
            parent.insertBefore(node, element);
        });
        return this;
    },

    after: function after(element) {
        element = $(element)[0];
        var parent = element.parentNode;
        if (parent) this.forEach(function (node) {
            parent.insertBefore(node, element.nextSibling);
        });
        return this;
    },

    bottom: function bottom(element) {
        element = $(element)[0];
        return this.forEach(function (node) {
            element.appendChild(node);
        });
    },

    top: function top(element) {
        element = $(element)[0];
        return this.forEach(function (node) {
            element.insertBefore(node, element.firstChild);
        });
    }

});

// insert, replace

$.implement({

    insert: $.prototype.bottom,

    remove: function remove() {
        return this.forEach(function (node) {
            var parent = node.parentNode;
            if (parent) parent.removeChild(node);
        });
    },

    replace: function replace(element) {
        element = $(element)[0];
        element.parentNode.replaceChild(this[0], element);
        return this;
    }

});

module.exports = $;

},{"./base":42}],47:[function(require,module,exports){
/*
traversal
*/"use strict";

var map = require("mout/array/map");

var slick = require("slick");

var $ = require("./base");

var gen = function gen(combinator, expression) {
    return map(slick.parse(expression || "*"), function (part) {
        return combinator + " " + part;
    }).join(", ");
};

var push_ = Array.prototype.push;

$.implement({

    search: function search(expression) {
        if (this.length === 1) return $(slick.search(expression, this[0], new $()));

        var buffer = [];
        for (var i = 0, node; node = this[i]; i++) {
            push_.apply(buffer, slick.search(expression, node));
        }buffer = $(buffer);
        return buffer && buffer.sort();
    },

    find: function find(expression) {
        if (this.length === 1) return $(slick.find(expression, this[0]));

        for (var i = 0, node; node = this[i]; i++) {
            var found = slick.find(expression, node);
            if (found) return $(found);
        }

        return null;
    },

    sort: function sort() {
        return slick.sort(this);
    },

    matches: function matches(expression) {
        return slick.matches(this[0], expression);
    },

    contains: function contains(node) {
        return slick.contains(this[0], node);
    },

    nextSiblings: function nextSiblings(expression) {
        return this.search(gen('~', expression));
    },

    nextSibling: function nextSibling(expression) {
        return this.find(gen('+', expression));
    },

    previousSiblings: function previousSiblings(expression) {
        return this.search(gen('!~', expression));
    },

    previousSibling: function previousSibling(expression) {
        return this.find(gen('!+', expression));
    },

    children: function children(expression) {
        return this.search(gen('>', expression));
    },

    firstChild: function firstChild(expression) {
        return this.find(gen('^', expression));
    },

    lastChild: function lastChild(expression) {
        return this.find(gen('!^', expression));
    },

    parent: function parent(expression) {
        var buffer = [];
        loop: for (var i = 0, node; node = this[i]; i++) {
            while ((node = node.parentNode) && node !== document) {
                if (!expression || slick.matches(node, expression)) {
                    buffer.push(node);
                    break loop;
                    break;
                }
            }
        }return $(buffer);
    },

    parents: function parents(expression) {
        var buffer = [];
        for (var i = 0, node; node = this[i]; i++) {
            while ((node = node.parentNode) && node !== document) {
                if (!expression || slick.matches(node, expression)) buffer.push(node);
            }
        }return $(buffer);
    }

});

module.exports = $;

},{"./base":42,"mout/array/map":333,"slick":380}],48:[function(require,module,exports){
/*
zen
*/"use strict";

var forEach = require("mout/array/forEach"),
    map = require("mout/array/map");

var parse = require("slick/parser");

var $ = require("./base");

module.exports = function (expression, doc) {

    return $(map(parse(expression), function (expression) {

        var previous, result;

        forEach(expression, function (part, i) {

            var node = (doc || document).createElement(part.tag);

            if (part.id) node.id = part.id;

            if (part.classList) node.className = part.classList.join(" ");

            if (part.attributes) forEach(part.attributes, function (attribute) {
                node.setAttribute(attribute.name, attribute.value || "");
            });

            if (part.pseudos) forEach(part.pseudos, function (pseudo) {
                var n = $(node),
                    method = n[pseudo.name];
                if (method) method.call(n, pseudo.value);
            });

            if (i === 0) {

                result = node;
            } else if (part.combinator === " ") {

                previous.appendChild(node);
            } else if (part.combinator === "+") {
                var parentNode = previous.parentNode;
                if (parentNode) parentNode.appendChild(node);
            }

            previous = node;
        });

        return result;
    }));
};

},{"./base":42,"mout/array/forEach":330,"mout/array/map":333,"slick/parser":381}],49:[function(require,module,exports){
'use strict';

var $ = require('../spotify-elements');
var forIn = require('mout/object/forIn');
var live = require('../spotify-live');
var center = require('./center');

var IS_ADDED_PROPERTY = 'added';
var FOLLOWERSCOUNT_PROPERTY = 'followersCount';
var FOLLOWINGCOUNT_PROPERTY = 'followingCount';
var BUTTON_SELECTOR = '[data-button=add]';
var JUSTCHANGED_CLASSNAME = 'just-changed';
var ADDED_CLASSNAME = 'added';

var dataPropertiesForAdd = [IS_ADDED_PROPERTY, FOLLOWERSCOUNT_PROPERTY, FOLLOWINGCOUNT_PROPERTY];

var changeHandlers = {};

function getAddedClass(node) {
  var addedClassNode = node[0].closest('data-class-added');
  return addedClassNode ? addedClassNode.getAttribute('data-class-added') : ADDED_CLASSNAME;
}

function getURIFromNode(node) {
  var stateNode = node[0].closest('[data-uri]');
  if (!stateNode) {
    return null;
  }
  return stateNode.getAttribute('data-uri');
}

var eventHandlers = {

  click: function click(event, node) {
    var stateNode = $(node[0].closest('[data-uri]'));
    if (!stateNode) return;

    var uri = stateNode.data('uri');
    if (!uri) return;

    var addedClass = getAddedClass(node);
    var shouldBeAdded = !stateNode.hasClass(addedClass);
    var data = {
      added: shouldBeAdded
    };

    node.addClass(JUSTCHANGED_CLASSNAME);

    // using capture=true to handle buttons with inner divs (used for changing button text)
    node.on('mouseout', function mouseoutHandler(event) {
      if (event.target !== node[0]) return;
      node.off('mouseout', mouseoutHandler);
      node.removeClass(JUSTCHANGED_CLASSNAME);
    }, true);

    // Publish will trigger the update event, which will then update the UI
    live(uri).publish(data);
  },

  changeHandler: function changeHandler(key, value, uri) {
    if (key === IS_ADDED_PROPERTY) {
      var numAffectedButtons = actions.setStateForURI(uri, value);
      if (numAffectedButtons === 0) {
        live(uri).off('update', changeHandlers[uri]);
        delete changeHandlers[uri];
      }
    }

    if (dataPropertiesForAdd.indexOf(key) > -1) {
      center.emit('add-data-change', { uri: uri, model: live(uri), key: key, value: value });
    }
  }

};

var actions = {

  setStateForURI: function setStateForURI(uri, isAdded) {
    var numAffectedButtons = 0;

    var nodes = $(document).search(BUTTON_SELECTOR);
    if (!nodes) return numAffectedButtons;

    for (var i = 0, l = nodes.length; i < l; i++) {
      var node = $(nodes[i]);
      var buttonURI = getURIFromNode(node);
      if (uri === buttonURI) {
        numAffectedButtons++;
        actions.setStateForButtonNode(node, isAdded);
      }
    }

    return numAffectedButtons;
  },

  setStateForButtonNode: function setStateForButtonNode(node, isAdded) {
    var stateNode = $(node[0].closest('[data-uri]'));
    if (!stateNode) return;

    var addedClass = getAddedClass(node);
    actions.setVisualState(isAdded, stateNode, node, addedClass);
  },

  setVisualState: function setVisualState(isAdded, node, button, className) {
    if (isAdded) {
      if (!node.hasClass(className)) node.addClass(className);
      var tooltipRemove = button.data('tooltip-remove');
      if (tooltipRemove) {
        button.setAttribute('data-tooltip', tooltipRemove);
        button.setAttribute('aria-label', tooltipRemove);
      }
      button.setAttribute('data-log-click', 'remove-button');
    } else {
      if (node.hasClass(className)) node.removeClass(className);
      var tooltipAdd = button.data('tooltip-add');
      if (tooltipAdd) {
        button.setAttribute('data-tooltip', tooltipAdd);
        button.setAttribute('aria-label', tooltipAdd);
      }
      button.setAttribute('data-log-click', 'add-button');
    }
  },

  addListenerForNode: function addListenerForNode(node) {
    var uri = getURIFromNode(node);

    // If we have already added a change handler for this URI,
    // we don't want to add another one, so we cancel early.
    // Before cancelling though, we should update button states
    // with the current state from the live model, since there
    // might be new buttons in the DOM.
    if (changeHandlers[uri]) {
      live(uri).get('added', function (error, isAdded) {
        if (error) throw error;
        actions.setStateForButtonNode(node, isAdded);
      });
      return;
    }

    changeHandlers[uri] = function (properties) {
      for (var key in properties) {
        var value = properties[key];
        eventHandlers.changeHandler(key, value, uri);
      };
    };

    var model = live(uri);

    // Get the initial state and update the button
    model.get('added', function (error, isAdded) {
      if (error) throw error;
      actions.setStateForButtonNode(node, isAdded);

      // When the initial state is known, we listen for updates
      // so we can update all buttons for this URI later.
      model.on('update', changeHandlers[uri]);
    });
  }

};

var handleScrollShow = function handleScrollShow(data) {
  update(data.pageNode, data.nodes);
};

// Export for testing
exports._classNames = {
  ADDED: ADDED_CLASSNAME,
  JUSTCHANGED: JUSTCHANGED_CLASSNAME
};

var isAttached = false;

exports.attach = function attach() {
  if (isAttached) return;
  isAttached = true;

  $(document).delegate('click', BUTTON_SELECTOR, eventHandlers.click);

  center.on('scroll-show-before', handleScrollShow);
};

exports.detach = function detach() {
  if (!isAttached) return;
  isAttached = false;

  $(document).undelegate('click', BUTTON_SELECTOR, eventHandlers.click);
  center.off('scroll-show-before', handleScrollShow);
};

var update = exports.update = function update(node, nodes) {
  if (!isAttached) return;

  // If the node passed in is a button node, just add listeners for that
  if (node && $(node).matches(BUTTON_SELECTOR)) {
    actions.addListenerForNode($(node));

    // Otherwise search all the children of the node (or the document
    // if node is not provided) for buttons.
  } else {

      var nodes = ($(nodes) || $(node) || $(document)).search(BUTTON_SELECTOR);
      if (!nodes) return;

      for (var i = 0, l = nodes.length; i < l; i++) {
        actions.addListenerForNode($(nodes[i]));
      }
    }
};

},{"../spotify-elements":45,"../spotify-live":212,"./center":52,"mout/object/forIn":359}],50:[function(require,module,exports){
'use strict';

var $ = require('../spotify-elements');
var Navigator = require('../spotify-navigation/navigator');
var AppState = require('../spotify-navigation/app-state');

var SELECTOR = 'a';

var nav = new Navigator();

var handleAnchorClick = function handleAnchorClick(event, node) {
  var anchor = node[0];
  var href = anchor.getAttribute('href');
  if (!href || href[0] === '#') {
    return;
  }

  event.preventDefault();

  var referrer = anchor.getAttribute('data-referrer-id') || document.body.getAttribute('data-referrer-id');

  var state = new AppState(href);

  if (referrer) {
    state.setReferrer(referrer);
  }

  nav.requestOpenState(state);
};

var isAttached = false;

exports.attach = function attach() {
  if (isAttached) {
    return;
  }
  isAttached = true;
  $(document).delegate('click', SELECTOR, handleAnchorClick);
};

exports.detach = function detach() {
  if (!isAttached) {
    return;
  }
  isAttached = false;
  $(document).undelegate('click', SELECTOR, handleAnchorClick);
};

exports.update = function () {};

},{"../spotify-elements":45,"../spotify-navigation/app-state":230,"../spotify-navigation/navigator":232}],51:[function(require,module,exports){
(function (global){
'use strict';

var $ = require('../spotify-elements');
var doc = $(document);
var win = $(window);

// Decides how many pixels allowed between two touchmoves to determine if it is a swipe
var SWIPE_SENSITIVITY = 1;
// Constant that sets the amount of pixels allowed to move without locking the horizontal scroll
var SCROLL_LOCK_LIMIT = 10;
// The divider used to calculate the swipe speed. A larger number will make a slower swipe
var SWIPE_LAG = 14;

var handleClickLeft = function handleClickLeft(event, node) {
  handleButtonClick(node, true);
};

var handleClickRight = function handleClickRight(event, node) {
  handleButtonClick(node, false);
};

var getCarouselInner = function getCarouselInner(node) {
  return node.search('[data-carousel-inner]');
};

var getCarouselObjectsWidth = function getCarouselObjectsWidth(carouselInner) {
  var mediaObjects = $(carouselInner).search('.media-object');
  if (!mediaObjects) {
    return;
  }
  var mediaObjectWidth = parseFloat(global.getComputedStyle(mediaObjects[0]).width);
  var carouselInnerWidth = parseFloat(global.getComputedStyle(carouselInner).width);
  var carouselTotalWidth = carouselInner.scrollWidth;

  return {
    mediaObjectWidth: mediaObjectWidth,
    carouselInnerWidth: carouselInnerWidth,
    carouselTotalWidth: carouselTotalWidth
  };
};

var calculateMinLeftPixels = function calculateMinLeftPixels(carouselInner) {
  var minLeft = 0;
  // Determine number of pages based on numbers per page and total number of objects
  var carouselObjectsWidth = getCarouselObjectsWidth(carouselInner);
  var objectsPerPage = Math.round(carouselObjectsWidth.carouselInnerWidth / carouselObjectsWidth.mediaObjectWidth);
  var totalNrOfObjects = Math.round(carouselObjectsWidth.carouselTotalWidth / carouselObjectsWidth.mediaObjectWidth);
  var nrOfPages = Math.ceil(totalNrOfObjects / objectsPerPage);
  minLeft = -(carouselObjectsWidth.carouselInnerWidth * (nrOfPages - 1));
  return minLeft;
};

var handleTouchStart = function handleTouchStart(event, node) {
  // Disable swiping the carousel if scrolling down/up the page
  var scrollBlocked = false;
  doc.on('scroll', handleScroll);
  function handleScroll(event) {
    if (!scrollBlocked) {
      doc.undelegate('touchmove', '[data-carousel]', handleTouchMove);
      doc.undelegate('touchend', '[data-carousel]', handleTouchEnd);
    } else {
      event.preventDefault();
    }
  }

  // Get carousel element
  var carouselInner = getCarouselInner(node);
  if (!carouselInner) {
    return;
  }
  carouselInner = carouselInner[0];
  var startX;
  var previousX;
  var deltaX;
  // minLeft is always a negative number or 0. This is the minimum LEFT position of the carousel.
  var minLeft = calculateMinLeftPixels(carouselInner);
  if (minLeft === 0) {
    return;
  }
  doc.delegate('touchmove', '[data-carousel]', handleTouchMove);
  doc.delegate('touchend', '[data-carousel]', handleTouchEnd);

  // Get start coordinates
  if (event.touches) {
    startX = event.touches[0].pageX;
    previousX = startX;
  }

  function handleTouchMove(event) {
    if (!carouselInner) {
      return;
    }
    addDragTransition();

    if (event.touches) {
      var x = event.touches[0].pageX;
      deltaX = previousX - x;
      // Get position of carousel
      var positionLeft = carouselPosition(carouselInner);
      positionLeft = getPositionInPixels(positionLeft, carouselInner);
      // Set adjusted position
      var adjust = positionLeft - deltaX;
      // Check that carousel position doesn't exceed limits
      adjust = checkLimitsPixels(adjust, minLeft);
      carouselInner.style.left = adjust + 'px';
      previousX = x;

      if (deltaX > SCROLL_LOCK_LIMIT) {
        scrollBlocked = true;
      }
      if (scrollBlocked) {
        event.preventDefault();
      }
    }
  };

  function handleTouchEnd(event) {
    doc.undelegate('touchmove', '[data-carousel]', handleTouchMove);
    doc.undelegate('touchend', '[data-carousel]', handleTouchEnd);
    doc.off('scroll', handleScroll);
    if (!carouselInner) {
      return;
    }
    // If considered as a swipe, swipe
    if (Math.abs(deltaX) > SWIPE_SENSITIVITY) {
      swipe(deltaX);
    }
    updateButtonsOnTouch(node);
  };

  /* Touch swipe functions */

  var swipe = function swipe(deltaX) {
    addSwipeTransition();
    // Get position of carousel
    var leftValue = carouselPosition(carouselInner);
    leftValue = getPositionInPixels(leftValue, carouselInner);

    var carouselObjectsWidth = getCarouselObjectsWidth(carouselInner);
    // Get width of one mediaobject to us as an interval in the calculation for setting the swipe speed
    var mediaObjectWidth = parseInt(carouselObjectsWidth.mediaObjectWidth);
    if (!mediaObjectWidth) {
      return;
    }
    // Calculate position to swipe to based on value of deltaX (e.g. swipe acceleration) and SWIPE_LAG
    // SWIPE_LAG can be changed to a lower/higher value to increase/decrease speed.
    var adjust = leftValue + mediaObjectWidth * (-deltaX / SWIPE_LAG);
    // Check that carousel position doesn't exceed limits
    adjust = checkLimitsPixels(adjust, minLeft);
    carouselInner.style.left = adjust + 'px';
  };

  var updateButtonsOnTouch = function updateButtonsOnTouch(node) {
    var carouselId = node.data('carousel');
    var positionLeft = carouselPosition(carouselInner);
    positionLeft = getPositionInPixels(positionLeft, carouselInner);
    var carouselRight = $('[data-carousel=' + carouselId + '][data-button=carousel-right]');
    var carouselLeft = $('[data-carousel=' + carouselId + '][data-button=carousel-left]');

    if (Math.round(positionLeft) <= Math.round(minLeft)) {
      carouselRight.setAttribute('disabled', 'disabled');
    } else {
      carouselRight.removeAttribute('disabled');
    }

    if (positionLeft >= 0) {
      carouselLeft.setAttribute('disabled', 'disabled');
    } else {
      carouselLeft.removeAttribute('disabled');
    }
  };

  var addSwipeTransition = function addSwipeTransition() {
    if (!carouselInner) {
      return;
    }
    // Add swipe transition and remove drag + click transition
    $(carouselInner).addClass('crsl-inner-swipe').removeClass('crsl-inner-drag');
  };

  var addDragTransition = function addDragTransition() {
    if (!carouselInner) {
      return;
    }
    // Add drag transition and remove swipe + click transition
    $(carouselInner).addClass('crsl-inner-drag').removeClass('crsl-inner-swipe');
  };
};

var resetTransitions = function resetTransitions(carouselInner) {
  if (!carouselInner) {
    return;
  }
  // Add click transition and remove drag + swipe transition
  $(carouselInner).removeClass('crsl-inner-drag').removeClass('crsl-inner-swipe');
};

var checkLimitsPixels = function checkLimitsPixels(adjust, minLeft) {
  adjust = Math.min(adjust, 0);
  adjust = Math.max(adjust, minLeft);
  return adjust;
};

var carouselPosition = function carouselPosition(carouselInner) {
  return carouselInner.style.left || '0';
};

var getPositionInPixels = function getPositionInPixels(positionLeft, carouselInner) {
  var isInPx = positionLeft.endsWith('px');
  positionLeft = parseFloat(positionLeft);
  // If current unit isn't px, change to px
  if (!isInPx) {
    var currentPage = Math.abs(positionLeft / 100);
    // var carouselInnerWidth = carouselInner.clientWidth;
    var carouselInnerWidth = getCarouselObjectsWidth(carouselInner).carouselInnerWidth;
    positionLeft = -carouselInnerWidth * currentPage;
  }
  return positionLeft;
};

var getNextPageInPercent = function getNextPageInPercent(positionLeft, carouselInner, isLeft) {
  var carouselInnerWidth = carouselInner.clientWidth;
  var minLeft = calculateMinLeftPixels(carouselInner);
  var isInPercent = positionLeft.endsWith('%');
  positionLeft = parseInt(positionLeft);
  // If current unit isn't %, change to %
  var nextPage;
  if (!isInPercent) {
    nextPage = Math.abs(positionLeft / carouselInnerWidth);
    // If position is to the end left and button is right
    if (positionLeft === 0 && !isLeft) {
      nextPage = -100;
    }
    // If position is to the end right and button is left
    else if (positionLeft === minLeft && isLeft) {
        nextPage = (nextPage - 1) * -100;
      } else {
        nextPage = isLeft ? Math.floor(nextPage) : Math.ceil(nextPage);
        nextPage = nextPage * -100;
      }
  }
  // If current unit already is in percent
  else {
      nextPage = isLeft ? positionLeft + 100 : positionLeft - 100;
    }
  return nextPage;
};

var handleButtonClick = function handleButtonClick(buttonNode, isLeft) {
  if (buttonNode.hasAttribute('disabled')) {
    return;
  }
  var carouselId = buttonNode.data('carousel');
  var carouselInner = $('[data-carousel=' + carouselId + '][data-carousel-main] [data-carousel-inner]')[0];
  var positionLeft = carouselPosition(carouselInner);

  var adjust;
  if (positionLeft) {
    // Get next page in %
    var nextPage = getNextPageInPercent(positionLeft, carouselInner, isLeft);
    adjust = nextPage;
  } else {
    adjust = isLeft ? 0 : -100;
  }
  // Reset transitions
  resetTransitions(carouselInner);
  carouselInner.style.left = adjust + '%';
  updateButtonStates(carouselId);
};

var updateButtonStates = function updateButtonStates(carouselId) {
  var carouselRight = $('[data-carousel=' + carouselId + '][data-button=carousel-right]');
  var carouselLeft = $('[data-carousel=' + carouselId + '][data-button=carousel-left]');
  var carousel = $('[data-carousel=' + carouselId + '][data-carousel-main]');
  var carouselInner = $(carousel).search('[data-carousel-inner]')[0];
  var leftAdjust = carouselInner.style.left ? parseInt(carouselInner.style.left) : 0;

  if (leftAdjust >= 0) {
    carouselLeft.setAttribute('disabled', 'disabled');
  } else {
    carouselLeft.removeAttribute('disabled');
  }

  if (carouselInner.clientWidth - leftAdjust / 100 * carouselInner.clientWidth + 10 > carouselInner.scrollWidth) {
    carouselRight.setAttribute('disabled', 'disabled');
  } else {
    carouselRight.removeAttribute('disabled');
  }
};

var updateAllButtons = function updateAllButtons(node) {
  node = $(node) || doc;
  var carousels = node.search('[data-carousel-main]');
  if (carousels) {
    carousels.forEach(function (carousel) {
      updateButtonStates($(carousel).data('carousel'));
    });
  }
};

var isAttached = false;

exports.update = function update(node) {
  if (!isAttached) return;

  updateAllButtons(node);
};

exports.attach = function () {
  if (isAttached) return;
  isAttached = true;

  doc.delegate('click', '[data-button=carousel-right]', handleClickRight);
  doc.delegate('click', '[data-button=carousel-left]', handleClickLeft);
  doc.delegate('touchstart', '[data-carousel][data-carousel-main]', handleTouchStart);

  win.on('resize', updateAllButtons);

  // Polyfill from: https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith
  if (!String.prototype.endsWith) {
    String.prototype.endsWith = function (searchString, position) {
      var subjectString = this.toString();
      if (position === undefined || position > subjectString.length) {
        position = subjectString.length;
      }
      position -= searchString.length;
      var lastIndex = subjectString.indexOf(searchString, position);
      return lastIndex !== -1 && lastIndex === position;
    };
  }
};

exports.detach = function () {
  if (!isAttached) return;
  isAttached = false;

  doc.undelegate('click', '[data-button=carousel-right]', handleClickRight);
  doc.undelegate('click', '[data-button=carousel-left]', handleClickLeft);
  doc.undelegate('touchstart', '[data-carousel][data-carousel-main]', handleTouchStart);

  win.off('resize', updateAllButtons);
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-elements":45}],52:[function(require,module,exports){
/*
Event Center
*/'use strict';

var Emitter = require('prime/emitter');

module.exports = new Emitter();

},{"prime/emitter":374}],53:[function(require,module,exports){
'use strict';

var $ = require('../spotify-elements');
var live = require('../spotify-live');
var selection = require('./selection');
var wrappedUriUtils = require('../spotify-live-wrapped-uri');
var cosmos = require('./util/cosmos');

var CONTEXTMENU = ['a[data-uri]', '[data-contextmenu]'].join(',');

var makeContextMenuData = function makeContextMenuData(selectionContexts, primaryIndex, uris, x, y) {
  var contexts = [];
  for (var i = 0, selectionContext; selectionContext = selectionContexts[i]; i++) {
    var keys = selectionContext.keys || [];
    var indices = selectionContext.indices || [];
    primaryIndex = primaryIndex || indices[0];
    primaryIndex = primaryIndex == null ? null : primaryIndex;

    var contextUri = selectionContext.uri;
    var liveList = live(contextUri).get('rows');

    var contextData = {
      uri: contextUri,
      keys: keys,
      indices: indices,
      primaryIndex: primaryIndex
    };

    var origin = selectionContext.origin;
    if (origin) {
      if (primaryIndex != null) {
        var wrappedList = live(contextUri).get('rows');
        var originList = live(origin.uri).get('rows');
        if (wrappedList && originList) {
          var key = wrappedList.keys[primaryIndex];
          origin.primaryIndex = originList.indexOf(key);
        }
      }
      contextData.origin = origin;
    }
    contexts.push(contextData);
  }
  return {
    contexts: contexts,
    x: x,
    y: y,
    uris: uris
  };
};

var handleContextMenuEvent = function handleContextMenuEvent(event, node) {
  event.preventDefault();
  event.stopPropagation();

  var x = event.clientX,
      y = event.clientY;

  if (node[0].tagName.toLowerCase() === 'a') {
    var uri = node.data('uri');
    if (uri) {
      showContextMenu({ uris: [uri], x: x, y: y });
    }
  } else {
    var contextNode = node.parent('[data-list]');
    var contextURI;
    if (contextNode) contextURI = contextNode.data('uri');

    var index = +node.data('index');

    var isSelected = false;
    var omitContext = false;
    var indices = selection.getIndicesPerList();

    if (contextNode) {
      isSelected = selection.isNodeSelected(node);
      // If the selection is shared between different lists, don't pass a contextURI.
      omitContext = indices.length > 1;
    }
    var uris = isSelected ? selection.getUris() : [node.data('uri')];
    showContextMenu(makeContextMenuData(indices, index, uris, x, y));
  }
};

var handleContextMenuButton = function handleContextMenuButton(event, node) {
  var parent;
  var uri = node.data('uri') || (parent = node.parent('[data-uri]')) && parent.data('uri');
  if (!uri) return;

  // The context menu can't know what to offer for a custom list.
  // In case of a sorted and/or filtered list, pass the origin list.
  uri = wrappedUriUtils.getOriginUri(uri) || uri;

  var contextURI = (parent = node.parent('[data-list][data-uri]')) && parent.data('uri');
  var contextIndex = (parent = node.parent('[data-index]')) && +parent.data('index');

  var contextMenuNode = $(node[0].closest('[data-button="contextmenu"]'));
  var relativeTo = contextMenuNode || parent || node;

  var rect = relativeTo[0].getBoundingClientRect();
  var x = rect.left + rect.width / 2;
  var y = rect.top + rect.height;

  // The coordinate must be within the app viewport
  if (y > window.innerHeight) y = window.innerHeight - 1;
  if (x > window.innerWidth) x = window.innerWidth - 1;

  var indices = contextIndex == null ? null : [contextIndex];
  contextIndex = contextIndex == null ? null : contextIndex;

  var context;
  if (contextURI) {
    context = { uri: contextURI };

    if (indices) {
      context.indices = indices;

      var liveList = live(contextURI).get('rows');
      context.keys = liveList ? indices.map(function (selectedIndex) {
        return liveList.keys[selectedIndex];
      }) : [];
    }

    // Add originList
    var origin = wrappedUriUtils.getOriginUri(contextURI);
    if (origin) {
      context.origin = { uri: origin };

      if (indices) {
        var wrappedList = live(contextURI).get('rows');
        var originList = live(origin).get('rows');
        if (wrappedList && originList) {
          var originIndices = indices.map(function (index) {
            var key = wrappedList.keys[index];
            return originList.indexOf(key);
          });
          var originKeys = indices.map(function (index) {
            return wrappedList.keys[index];
          });
          context.origin.indices = originIndices;
          context.origin.keys = originKeys;
        }
      }
    }
  }
  showContextMenu(makeContextMenuData([context], contextIndex, [uri], x, y));
  contextMenuNode.addClass('contextmenu-active');

  var cancel = cosmos.subscribe({ url: 'sp://messages/v1/context_menu_state' }, function (error, response) {
    if (!error && response.body.state === 'hide') {
      contextMenuNode.removeClass('contextmenu-active');
      cancel();
    }
  });
};

var showContextMenu = function showContextMenu(data) {
  var application = live('spotify:application');
  application.query('appURI', function (error, application_data) {
    if (!error) {
      data.appURI = application_data.appURI;
    }
    var client = live('spotify:client');
    client.emit('show-context-menu', data);
  });
};

var isAttached = false;

exports.attach = function attach() {
  if (isAttached) return;
  isAttached = true;

  $(document).delegate('contextmenu', CONTEXTMENU, handleContextMenuEvent);
  $(document).delegate('click', '[data-button=contextmenu]', handleContextMenuButton);
};

exports.detach = function detach() {
  if (!isAttached) return;
  isAttached = false;

  $(document).undelegate('contextmenu', CONTEXTMENU, handleContextMenuEvent);
  $(document).undelegate('click', '[data-button=contextmenu]', handleContextMenuButton);
};

exports.update = function () {};

},{"../spotify-elements":45,"../spotify-live":212,"../spotify-live-wrapped-uri":211,"./selection":88,"./util/cosmos":103}],54:[function(require,module,exports){
/**
 * @module spotify-events/dragndrop/custom/rootlist
 * @private
 */
'use strict';

var $ = require('../../../spotify-elements');

var liburi = require('spotify-liburi');
var live = require('../../../spotify-live');
var intersection = require('mout/array/intersection');

var hooks = require('../util/hooks');
var eventModel = require('../util/eventmodel');
var selection = require('../../selection');

var SELECTOR_LIST = '[data-list]';
var SELECTOR_LIST_ITEM = '[data-list-item]';
var SELECTOR_DRAGGABLE = 'a, [draggable]';
var ATTR_TARGET = 'data-drop-target';

var dragFolderElement = null;

/**
 * Handler for the dragstart event.
 *
 * @param {MouseEvent} event Event object for a dragstart event.
 * @param {HTMLElement} target The target element.
 */
function onDragStart(event, target) {
  dragFolderElement = null;

  var uris = selection.getUris();
  if (uris.length > 1) return;

  var uri = uris[0];
  var uriObject = uri && liburi.fromString(uri);
  if (!uriObject) return;

  // If dragging a folder, we need to temporarily save the folder DOM node,
  // so that while dragging over items we can check whether to show the drop
  // indicator. Dropping a folder inside itself should not be allowed.
  if (uriObject.type === liburi.Type.FOLDER) {
    var selectedNodes = selection.getNodes();
    for (var i = 0, l = selectedNodes.length; i < l; i++) {
      var node = selectedNodes[i];
      if (node.getAttribute('data-uri') === uri) {
        dragFolderElement = node;
        break;
      }
    }
  }
}

/**
 * Handler for ending a drag.
 *
 * @param {MouseEvent} event A dragend event object.
 * @param {HTMLElement} target DOM element for the drop target.
 */
function onDragEnd(event, target) {
  dragFolderElement = null;
}

/**
 * Hook handler for setting drag data.
 *
 * @param {MouseEvent} event Event object for a dragstart event.
 * @param {Array.<string>} uris Array of URIs being dragged.
 * @param {string=} opt_context Optional context URI.
 */
function onSetDragData(event, uris, opt_context) {
  if (opt_context !== 'spotify:rootlist') {
    var followedPlaylistCount = 0;
    for (var i = 0, l = uris.length; i < l; i++) {
      var uriObject = liburi.from(uris[i]);
      var type = uriObject && uriObject.type;
      if (type === liburi.Type.PLAYLIST) {
        var isFollowing = live(uris[i]).get('added');
        if (isFollowing) followedPlaylistCount++;
      } else {
        // If the item is not a playlist, it means we are dragging either only
        // items of another type, or playlists as well as other types.
        break;
      }
    }

    // Dropping only playlists that you are following in the rootlist should
    // not be allowed. If multiple playlists are dragged and some of them are
    // not being followed, dropping is allowed (and the receiver should handle
    // only inserting the new ones). To allow telling these cases apart while
    // not having access to drag data, we set a special MIME type that can be
    // checked later.
    if (followedPlaylistCount === uris.length) {
      event.dataTransfer.setData('text/x-spotify-only-followed-playlists', '');
    }
  }
}

/**
 * Hook handler for validating a list drop.
 *
 * @param {Object} result Result object. Setting the `valid` property will
 *     affect whether the drop is allowed.
 * @param {MouseEvent} event Some kind of drag and drop event.
 * @param {HTMLElement} list A DOM node marked up as a list.
 * @param {string} location The location of the cursor in relation to the list.
 *     This can be either 'inside' or 'below'. The value 'below' means that the
 *     cursor was below the last list found in the DOM.
 */
function onListDropValidation(result, event, list, location) {
  var contextUri = list.getAttribute('data-uri');
  if (contextUri === 'spotify:rootlist') {

    // Dropping only already followed playlists into the rootlist should not
    // be allowed, since you can only have playlists once in the rootlist.
    if (hasOnlyFollowedPlaylists(event)) {
      result.valid = false;
      return;
    }

    // Dropping a folder inside or right below itself should not be allowed
    if (isInsideDraggedFolder(event, location)) {
      result.valid = false;
      return;
    }

    // Dropping on the bottom half of a folder should not be allowed as a list
    // target, but will be a regular target for the folder instead. However, if
    // the dragged items match the list target, dropping should be handled by
    // list code instead of target code (dragover should still not validate as
    // we want the active drop target style and not the list indicator).
    if (isInFolderBottomHalf(event)) {
      if (event.type !== 'drop' || !isMatchingTarget(event, list)) {
        result.valid = false;
        return;
      }
    }
  }
}

/**
 * Hook handler for validating a target.
 *
 * @param {Object} result Result object. Setting the `valid` property will
 *     affect whether the drop is allowed.
 * @param {MouseEvent} event Some kind of drag and drop event.
 * @param {HTMLElement} target DOM node for target that matches MIME types.
 */
function onTargetValidation(result, event, target) {
  var list = target.closest(SELECTOR_LIST);
  if (list) {
    var contextUri = list.getAttribute('data-uri');
    if (contextUri === 'spotify:rootlist') {

      // Dropping only already followed playlists into the rootlist should not
      // be allowed, since you can only have playlists once in the rootlist.
      if (hasOnlyFollowedPlaylists(event)) {
        result.valid = false;
        return;
      }

      // Dropping valid rootlist items on the top half of a folder should not
      // be allowed as a regular target, but will be a list drop target instead.
      // For leave events, we need to validate the whole row as valid, so that
      // the target styling is removed correctly.
      if (event.type !== 'dragleave' && isMatchingTarget(event, list)) {
        var folderNode = getFolderNode(event);
        if (folderNode) {
          if (isBelowMiddleOfNode(event.clientY, folderNode)) {
            result.valid = true;
          } else {
            result.valid = false;
          }
          return;
        }
      }
    }
  }
}

/**
 * Hook handler for getting the indices being moved.
 *
 * @param {string} contextUri The context URI.
 * @param {LiveList} liveList Live list to be changed.
 * @param {Array.<number>} indices Array of indices in the list.
 */
function onGetMoveIndices(contextUri, liveList, indices) {
  if (contextUri === 'spotify:rootlist') {
    var firstIndex = indices[0];
    var firstRow = liveList.get(firstIndex);
    var firstItem = firstRow && firstRow.get('playlist');
    var firstUri = firstItem && firstItem.uri;
    var firstUriType = firstUri && liburi.fromString(firstUri).type;
    var isFolder = firstUriType === liburi.Type.FOLDER;

    if (isFolder) {

      // Add all indices for the folder contents and the end marker
      if (indices.length === 1) {
        var length = getFolderLength(liveList, firstUri, firstIndex);
        for (var i = 1; i <= length; i++) {
          indices.push(firstIndex + i);
        }
      }

      // Abort the move operation if it only contains moving a folder start
      // marker, since moving folders should always move the entire folder.
      // Aborting by returning zero indices.
      if (indices.length === 1) {
        indices.length = 0;
        return;
      }

      var lastRow = liveList.get(indices[indices.length - 1]);
      var lastItem = lastRow && lastRow.get('playlist');
      var lastUri = lastItem && lastItem.uri;

      // Abort the move operation if moving a folder and the last item to move
      // is not the end marker for the folder. Aborting by returning zero
      // indices.
      if (lastUri !== firstUri + ':end') {
        indices.length = 0;
        return;
      }
    }
  }
}

/**
 * Check if only dragging playlists that are being followed already.
 *
 * @param {MouseEvent} event Some kind of drag and drop event.
 *
 * @return {boolean} True if only followed playlists are being dragged.
 */
function hasOnlyFollowedPlaylists(event) {
  var types = event.dataTransfer.types;
  if (types.indexOf('text/x-spotify-only-followed-playlists') > -1) {
    return true;
  }

  return false;
}

/**
 * Check if dragging a folder into (or below) itself.
 *
 * @param {MouseEvent} event Some kind of drag and drop event.
 * @param {string} location The location of the cursor in relation to the list.
 *     This can be either 'inside' or 'below'. The value 'below' means that the
 *     cursor was below the last list found in the DOM.
 *
 * @return {boolean} True if dragging into the same folder being dragged.
 */
function isInsideDraggedFolder(event, location) {
  if (dragFolderElement) {
    var rowNode = location === 'below' ? getLastRowNode() : getRowNode(event);
    if (rowNode) {
      var targetIndex = +rowNode.getAttribute('data-index');
      if (location === 'inside') {
        if (!isBelowMiddleOfNode(event.clientY, rowNode)) {
          targetIndex--;
        }
      }
      if (isIndexInsideDraggedFolder(targetIndex)) {
        return true;
      }
    }
  }

  return false;
}

/**
 * Check if dragging onto the bottom half of a folder.
 *
 * @param {MouseEvent} event Some kind of drag and drop event.
 *
 * @return {boolean} True if dragging onto the bottom half.
 */
function isInFolderBottomHalf(event) {
  var folderNode = getFolderNode(event);
  if (folderNode) {
    return isBelowMiddleOfNode(event.clientY, folderNode);
  }
  return false;
}

/**
 * Check if the position is below the middle of the node.
 *
 * @param {number} y The Y position relative to the viewport.
 * @param {HTMLElement} node DOM node to check against.
 *
 * @return {boolean} True if the position is below.
 */
function isBelowMiddleOfNode(y, node) {
  var rect = node.getBoundingClientRect();
  return y >= rect.top + rect.height / 2;
}

/**
 * Check if the index is inside (or right below) the folder being dragged.
 *
 * @param {number} index Current target index.
 *
 * @return {boolean} True if the target index is inside the folder.
 */
function isIndexInsideDraggedFolder(index) {
  if (!dragFolderElement) return false;

  var liveList = live('spotify:rootlist').get('rows');
  if (!liveList) return false;

  var folderUri = dragFolderElement.getAttribute('data-uri');
  if (!folderUri) return false;

  var start = +dragFolderElement.getAttribute('data-index');
  var end = start + getFolderLength(liveList, folderUri, start);

  if (start > -1 && end > start && index >= start && index <= end) {
    return true;
  }

  return false;
}

/**
 * Check if the MIME types in the drag event matches the MIME types for the
 * specified drop target.
 *
 * @param {MouseEvent} event Some kind of drag and drop event.
 * @param {HTMLElement} node A DOM node.
 *
 * @return {boolean} True if the element matches the event.
 */
function isMatchingTarget(event, node) {
  var eventTypes = event.dataTransfer.types;
  var nodeTypes = node.getAttribute(ATTR_TARGET);

  if (nodeTypes) {
    var matching = intersection(nodeTypes.split('|'), eventTypes);
    if (matching.length > 0) return true;
  }

  return false;
}

/**
 * Get the folder row node from the event.
 *
 * @param {MouseEvent} event Some kind of drag and drop event.
 *
 * @return {HTMLElement?} DOM node for the folder, or null if not found.
 */
function getFolderNode(event) {
  var rowNode = getRowNode(event);
  if (rowNode) {
    var uri = rowNode.getAttribute('data-uri');
    var uriObject = liburi.from(uri);
    if (uriObject && uriObject.type === liburi.Type.FOLDER) {
      return rowNode;
    }
  }

  return null;
}

/**
 * Get the list row element from the event target.
 * If the event target itself isn't a list row, it will step out in the parent
 * tree until it finds a row.
 *
 * @param {MouseEvent} event Some kind of drag and drop event.
 *
 * @return {HTMLElement?} The list row element, or null if not found.
 */
function getRowNode(event) {
  return event.target.closest(SELECTOR_LIST_ITEM);
}

/**
 * Get the last list row from the last list in the DOM.
 *
 * @return {HTMLElement?} The list row element, or null if not found.
 */
function getLastRowNode() {
  var lists = $(SELECTOR_LIST);
  var lastList = lists && lists[lists.length - 1];
  if (lastList) {
    var listItems = $(lastList).search(SELECTOR_LIST_ITEM);
    var lastItem = listItems && listItems[listItems.length - 1];
    if (lastItem) return lastItem;
  }

  return null;
}

/**
 * Get the length of a folder, including the contents and end marker, but not
 * the start marker.
 *
 * @param {LiveList} liveList Live list for the rootlist.
 * @param {string} folderUri The folder URI.
 * @param {number} index The index where the folder start marker is.
 *
 * @return {number} The length of the folder.
 */
function getFolderLength(liveList, folderUri, index) {
  var rowAtIndex = liveList.get(index);
  var itemAtIndex = rowAtIndex && rowAtIndex.get('playlist');
  var uriAtIndex = itemAtIndex && itemAtIndex.uri;
  if (uriAtIndex !== folderUri) return 0;

  var folderEndUri = folderUri + ':end';
  var amount = 0;

  for (var i = index + 1, l = liveList.length; i < l; i++) {
    amount++;

    rowAtIndex = liveList.get(i);
    itemAtIndex = rowAtIndex && rowAtIndex.get('playlist');
    uriAtIndex = itemAtIndex && itemAtIndex.uri;
    if (uriAtIndex === folderEndUri) break;
  }

  return amount;
}

/**
 * Attach the module.
 */
function attach() {
  eventModel.delegate('dragstart', SELECTOR_DRAGGABLE, onDragStart);
  eventModel.delegate('dragend', 'body', onDragEnd);

  hooks.add('set-drag-data', onSetDragData);
  hooks.add('list-drop-validation', onListDropValidation);
  hooks.add('target-validation', onTargetValidation);
  hooks.add('get-move-indices', onGetMoveIndices);
}

/**
 * Detach the module.
 */
function detach() {
  eventModel.undelegate('dragstart', SELECTOR_DRAGGABLE, onDragStart);
  eventModel.undelegate('dragend', 'body', onDragEnd);

  hooks.remove('set-drag-data', onSetDragData);
  hooks.remove('list-drop-validation', onListDropValidation);
  hooks.remove('target-validation', onTargetValidation);
  hooks.remove('get-move-indices', onGetMoveIndices);
}

exports.attach = attach;
exports.detach = detach;

},{"../../../spotify-elements":45,"../../../spotify-live":212,"../../selection":88,"../util/eventmodel":61,"../util/hooks":62,"mout/array/intersection":332,"spotify-liburi":398}],55:[function(require,module,exports){
/**
 * @module spotify-events/dragndrop/custom/sortlist
 * @private
 */
'use strict';

var $ = require('../../../spotify-elements');
var liburi = require('spotify-liburi');
var sortUriUtils = require('../../../spotify-live-sort-uri');

var hooks = require('../util/hooks');
var eventModel = require('../util/eventmodel');
var selection = require('../../selection');

var SELECTOR_DRAGGABLE = 'a, [draggable]';
var SELECTOR_LIST = '[data-list]';

var dragSelectionState = null;

/**
 * Handler for the dragstart event.
 *
 * @param {MouseEvent} event Event object for a dragstart event.
 * @param {HTMLElement} target The target element.
 */
function onDragStart(event, target) {
  dragSelectionState = selection.getIndicesPerList();
}

/**
 * Handler for ending a drag.
 *
 * @param {MouseEvent} event A dragend event object.
 * @param {HTMLElement} target DOM element for the drop target.
 */
function onDragEnd(event, target) {
  dragSelectionState = null;
}

/**
 * Hook handler for validating a list drop.
 *
 * @param {Object} result Result object. Setting the `valid` property will
 *     affect whether the drop is allowed.
 * @param {MouseEvent} event Some kind of drag and drop event.
 * @param {HTMLElement} list A DOM node marked up as a list.
 * @param {string} location The location of the cursor in relation to the list.
 *     This can be either 'inside' or 'below'. The value 'below' means that the
 *     cursor was below the last list found in the DOM.
 */
function onListDropValidation(result, event, list, location) {
  var contextUri = list.getAttribute('data-uri');
  if (!contextUri) return;

  // Dropping in sorted lists should not allow specific drop positions,
  if (sortUriUtils.isValid(contextUri) && event.type !== 'drop') {
    result.valid = false;
  }
}

/**
 * Hook handler for validating a list target.
 *
 * @param {Object} result Result object. Setting the `valid` property will
 *     affect whether the drop is allowed.
 * @param {HTMLElement} list A DOM node marked up as a list.
 */
function onListTargetValidation(result, list) {
  var contextUri = list.getAttribute('data-uri');
  if (!contextUri) return;

  // Bail on all invalid uris
  if (!sortUriUtils.isValid(contextUri)) return;

  // We should support incoming drag and drops as well, like from the
  // now playing view for example
  if (!dragSelectionState) {
    result.valid = true;
    return;
  }

  // Dropping in sorted lists should be allowed as a regular target
  if (dragSelectionState.length === 1) {
    if (dragSelectionState[0].uri !== contextUri) {
      result.valid = true;
    }
  }
}

/**
 * Hook handler for checking if a list is a track list.
 *
 * @param {Object} result Result object. Setting the `valid` property will
 *     affect the result.
 * @param {LiveList} liveList The live list.
 * @param {string} contextUri The context URI.
 */
function onIsListOfTracks(result, liveList, contextUri) {
  if (sortUriUtils.isValid(contextUri)) {
    var originUri = sortUriUtils.getOriginUri(contextUri);
    if (originUri) {
      var uriObject = liburi.from(originUri);
      var type = uriObject && uriObject.type;
      if (type === liburi.Type.PLAYLIST) {
        result.valid = true;
      }
    }
  }
}

/**
 * Attach the module.
 */
function attach() {
  eventModel.delegate('dragstart', SELECTOR_DRAGGABLE, onDragStart);
  eventModel.delegate('dragend', 'body', onDragEnd);

  hooks.add('list-drop-validation', onListDropValidation);
  hooks.add('list-target-validation', onListTargetValidation);
  hooks.add('is-list-of-tracks', onIsListOfTracks);
}

/**
 * Detach the module.
 */
function detach() {
  eventModel.undelegate('dragstart', SELECTOR_DRAGGABLE, onDragStart);
  eventModel.undelegate('dragend', 'body', onDragEnd);

  hooks.remove('list-drop-validation', onListDropValidation);
  hooks.remove('list-target-validation', onListTargetValidation);
  hooks.remove('is-list-of-tracks', onIsListOfTracks);
}

exports.attach = attach;
exports.detach = detach;

},{"../../../spotify-elements":45,"../../../spotify-live-sort-uri":210,"../../selection":88,"../util/eventmodel":61,"../util/hooks":62,"spotify-liburi":398}],56:[function(require,module,exports){
(function (global){
/**
 * @module spotify-events/dragndrop/dragdata
 * @private
 */
'use strict';

var live = require('../../spotify-live');
var liburi = require('spotify-liburi');
var forOwn = require('mout/object/forOwn');

var selection = require('../selection');
var hooks = require('./util/hooks');
var eventModel = require('./util/eventmodel');
var itemText = require('./util/itemtext');
var getLogContext = require('../util/get-log-context');

var SELECTOR_DRAGGABLE = 'a, [draggable]';

/**
 * Handler for the dragstart event.
 *
 * @param {MouseEvent} event Event object for a dragstart event.
 * @param {HTMLElement} target The target element.
 */
function onDragStart(event, target) {
  var isSelected = selection.isNodeSelected(target);

  if (isSelected) {
    var uris = selection.getUris();
    if (uris.length > 0) {
      var state = selection.getIndicesPerList();
      var singleContext = state.length === 1;
      var context = singleContext ? state[0] && state[0].uri : null;
      if (context) {
        setEventData(event, uris, null, context, getLogContext(target));
      } else {
        setEventData(event, uris, null, null, getLogContext(target));
      }
    }
  } else {
    var uri = target.getAttribute('data-uri');
    if (!uri) {
      var uriObject = liburi.from(target.getAttribute('href'));
      uri = uriObject ? uriObject.toURI() : '';
    }
    var dragText = itemText.getForElement(target);

    if (uri) {
      setEventData(event, [uri], [dragText], null, getLogContext(target));
    }
  }
}

/**
 * Set drag data on the event.
 * This includes regular MIME types such as plain text and html, but also custom
 * Spotify MIME types that can be used to detect the dragged content while
 * dragging (you can't access data while dragging, so there is no other way
 * to detect what kind of items are being dragged).
 *
 * @param {MouseEvent} event Event object for a dragstart event.
 * @param {Array.<string>} uris Array of Spotify URIs.
 * @param {Array.<string>=} opt_dragTexts Optional drag texts for each URI.
 * @param {string=} opt_context Optional context URI.
 * @param {string=} opt_logContext Optional log context.
 */
function setEventData(event, uris, opt_dragTexts, opt_context, opt_logContext) {
  var urlsPerMimeType = getUrlsPerMimeType(uris);
  var urls = getUrlsForUris(uris);
  var urlList = urls.join('\n');
  var html = getLinkHTML(uris, urls, opt_dragTexts);

  // We set this before others because safari overrides any data that was set
  // before this particular mimetype was set.
  event.dataTransfer.setData('text/uri-list', urlList);

  for (var type in urlsPerMimeType) {
    var urlsForType = urlsPerMimeType[type];
    event.dataTransfer.setData(type, urlsForType.join('\n'));
  };

  event.dataTransfer.setData('text/plain', urlList);
  event.dataTransfer.setData('text/html', html);

  if (opt_context) {

    // Provide the context as drag data. This can be used in the drop event to
    // know where it came from.
    event.dataTransfer.setData('text/x-spotify-data-context', opt_context);
  }

  if (opt_logContext) {
    event.dataTransfer.setData('text/x-spotify-data-log-context', opt_logContext);
  }

  event.dataTransfer.setData('text/x-spotify-data-app-uri', global.__spotify && global.__spotify.app_uri || null);

  hooks.run('set-drag-data', event, uris, opt_context);
}

/**
 * Get URLs for the URIs organized by MIME type.
 *
 * @param  {Array.<string>} uris Array of Spotify URIs.
 *
 * @return {Object.<string, Array.<string>>} Object of arrays of URLs.
 */
function getUrlsPerMimeType(uris) {
  var urlsPerMimeType = {};
  for (var i = 0, l = uris.length; i < l; i++) {
    var uri = uris[i];
    var type = getMimeType(uri);
    var urlsForType = urlsPerMimeType[type] || (urlsPerMimeType[type] = []);
    urlsForType.push(getShareLink(uri));
  }
  return urlsPerMimeType;
}

/**
 * Get URLs for the URIs.
 *
 * @param {Array.<string>} uris Array of Spotify URIs.
 *
 * @return {Array.<string>} Array of share URLs.
 */
function getUrlsForUris(uris) {
  var urls = new Array(uris.length);
  for (var i = 0, l = uris.length; i < l; i++) {
    urls[i] = getShareLink(uris[i]);
  }
  return urls;
}

/**
 * Get a share URL from a Spotify URI.
 *
 * @param {string} uri A Spotify URI.
 *
 * @return {string} The share URL.
 */
function getShareLink(uri) {
  var uriObject = liburi.from(uri);
  return uriObject ? uriObject.toOpenURL() : uri;
}

/**
 * Get the custom Spotify MIME type for a URI.
 *
 * @param {string} uri A Spotify URI.
 *
 * @return {string} The MIME type.
 */
function getMimeType(uri) {
  var type = 'text/x-spotify-';

  var uriObject = liburi.from(uri);
  if (uriObject) {
    var uriType = uriObject.type;

    if (uriType === liburi.Type.TRACK || uriType === liburi.Type.LOCAL) {
      return type + 'tracks';
    }
    if (uriType === liburi.Type.ALBUM || uriType === liburi.Type.LOCAL_ALBUM) {
      return type + 'albums';
    }
    if (uriType === liburi.Type.ARTIST || uriType === liburi.Type.LOCAL_ARTIST) {
      return type + 'artists';
    }
    if (uriType === liburi.Type.USER || uriType === liburi.Type.PROFILE) {
      return type + 'users';
    }
    if (uriType === liburi.Type.PLAYLIST) {
      return type + 'playlists';
    }
    if (uriType === liburi.Type.FOLDER) {
      return type + 'folders';
    }
    if (uriType === liburi.Type.STATION) {
      return type + 'stations';
    }
  }

  return type + 'unknown';
}

/**
 * Get the HTML for links to the given URLs.
 *
 * @param {Array.<string>} uris Array of Spotify URIs.
 * @param {Array.<string>} urls Array of Spotify URLs used for sharing.
 * @param {Array.<string>=} opt_dragTexts Optional drag texts for each URI.
 *
 * @return {string} String of HTML.
 */
function getLinkHTML(uris, urls, opt_dragTexts) {
  var html = '';

  for (var i = 0, l = uris.length; i < l; i++) {
    var textFromArgs = opt_dragTexts && opt_dragTexts[i];
    var text = textFromArgs || itemText.getForUri(uris[i]);

    html += '<a href="' + urls[i] + '">' + text + '</a>';

    if (i < uris.length - 1) {
      html += '<br>';
    }
  }

  return html;
}

/**
 * Attach the module.
 */
function attach() {
  eventModel.delegate('dragstart', SELECTOR_DRAGGABLE, onDragStart);
}

/**
 * Detach the module.
 */
function detach() {
  eventModel.undelegate('dragstart', SELECTOR_DRAGGABLE, onDragStart);
}

exports.attach = attach;
exports.detach = detach;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../spotify-live":212,"../selection":88,"../util/get-log-context":105,"./util/eventmodel":61,"./util/hooks":62,"./util/itemtext":63,"mout/object/forOwn":360,"spotify-liburi":398}],57:[function(require,module,exports){
/**
 * @module spotify-events/dragndrop/dragimage
 * @private
 */
'use strict';

var live = require('../../spotify-live');
var liburi = require('spotify-liburi');
var defer = require('prime/defer');

var selection = require('../selection');
var eventModel = require('./util/eventmodel');
var itemText = require('./util/itemtext');

// TODO: Actually load localized strings.
// Problem now is that we need quickstart-spotify to load @loc paths, and that
// makes it harder to run unit tests.
var localizedStrings = require('../strings/en.json');

var SELECTOR_DRAGGABLE = 'a, [draggable]';
var DRAGIMAGE_POS_X = -10;
var DRAGIMAGE_POS_Y = -5;

var dragImageElement = null;
var dragImageShelter = null;

/**
 * Handler for the dragstart event.
 *
 * @param {MouseEvent} event Event object for a dragstart event.
 * @param {HTMLElement} target The target element.
 */
function onDragStart(event, target) {
  var isSelected = selection.isNodeSelected(target);

  var text = '';

  if (isSelected) {
    var uris = selection.getUris();
    if (uris.length === 1) {
      text = itemText.getForUri(uris[0]);
    } else {
      text = uris.length + ' ' + getLocalizedTypeFromUris(uris);
    }
  } else {
    text = itemText.getForElement(target);
  }

  var dragImage = getDragImage(text);

  event.dataTransfer.setDragImage(dragImage, DRAGIMAGE_POS_X, DRAGIMAGE_POS_Y);

  removeDragImage();
}

/**
 * Get the drag image element with the specified text set.
 *
 * @param {string} text The text to set.
 *
 * @return {HTMLElement} The drag image element.
 */
function getDragImage(text) {
  if (!dragImageElement) {
    dragImageElement = document.createElement('div');
    dragImageElement.className = 'dnd-image';
  }
  if (!dragImageShelter) {
    dragImageShelter = document.createElement('div');
    dragImageShelter.className = 'dnd-image-shelter';
  }

  dragImageElement.textContent = text;

  document.body.appendChild(dragImageElement);
  document.body.appendChild(dragImageShelter);

  return dragImageElement;
}

/**
 * Remove the drag image element and the shelter it hides behind.
 * This must be delayed a tick to let the native drag and drop handling
 * get the time to read the image.
 */
function removeDragImage() {
  defer(function () {
    if (dragImageElement && dragImageElement.parentNode) {
      dragImageElement.parentNode.removeChild(dragImageElement);
    }
    if (dragImageShelter && dragImageShelter.parentNode) {
      dragImageShelter.parentNode.removeChild(dragImageShelter);
    }
  });
}

/**
 * Get a localized type for a list of URIs.
 * This could be for example 'tracks', 'playlists' etc. Falls back to 'items'
 * if the URIs are of different type. As this is only called when we drag
 * multiple items, we don't need the singular form.
 *
 * @param {Array.<string>} uris Array of URIs.
 *
 * @return {string} The localized type.
 */
function getLocalizedTypeFromUris(uris) {
  var type = 'item';

  var uriObjectForFirst = liburi.from(uris[0]);
  var typeForFirst = uriObjectForFirst && uriObjectForFirst.type;

  if (typeForFirst) {
    type = typeForFirst;

    for (var i = 0, l = uris.length; i < l; i++) {
      var uriObject = liburi.from(uris[i]);
      if (!uriObject || uriObject.type !== typeForFirst) {
        type = 'item';
        break;
      }
    }
  }

  // User URIs are parsed with type 'profile' in liburi, but we want 'user'
  if (type === 'profile') {
    type = 'user';
  }

  var pluralType = type + 's';

  // Get the localized version of the plural type
  var localized = localizedStrings['drag_tooltip_many_' + pluralType];

  // If the type was not the generic 'items' type and no localization was found,
  // localize the generic type.
  if (!localized && pluralType !== 'items') {
    localized = localizedStrings['drag_tooltip_many_items'];
  }

  // Return the localized type, or if nothing is found, fall back to the type
  return localized || pluralType;
}

/**
 * Attach the module.
 */
function attach() {
  eventModel.delegate('dragstart', SELECTOR_DRAGGABLE, onDragStart);
}

/**
 * Detach the module.
 */
function detach() {
  eventModel.undelegate('dragstart', SELECTOR_DRAGGABLE, onDragStart);
}

exports.attach = attach;
exports.detach = detach;

},{"../../spotify-live":212,"../selection":88,"../strings/en.json":96,"./util/eventmodel":61,"./util/itemtext":63,"prime/defer":373,"spotify-liburi":398}],58:[function(require,module,exports){
/**
 * @module spotify-events/dragndrop
 */
'use strict';

var dragDataModule = require('./dragdata');
var dragImageModule = require('./dragimage');
var targetModule = require('./target');
var listModule = require('./list');

// Custom behaviors
var sortlistModule = require('./custom/sortlist');
var rootlistModule = require('./custom/rootlist');

/**
 * Attach the module.
 */
function attach() {
  dragDataModule.attach();
  dragImageModule.attach();
  targetModule.attach();
  listModule.attach();

  sortlistModule.attach();
  rootlistModule.attach();
}

/**
 * Detach the module.
 */
function detach() {
  dragDataModule.detach();
  dragImageModule.detach();
  targetModule.detach();
  listModule.detach();

  sortlistModule.detach();
  rootlistModule.detach();
}

exports.attach = attach;
exports.detach = detach;
exports.update = function () {};

},{"./custom/rootlist":54,"./custom/sortlist":55,"./dragdata":56,"./dragimage":57,"./list":59,"./target":60}],59:[function(require,module,exports){
/**
 * @module spotify-events/dragndrop/list
 * @private
 */
'use strict';

var $ = require('../../spotify-elements');
var intersection = require('mout/array/intersection');
var flow = require('finally');
var Range = require('../../spotify-range2');
var live = require('../../spotify-live');
var liburi = require('spotify-liburi');
var listOperations = require('spotify-live-list-operations');

var hooks = require('./util/hooks');
var eventModel = require('./util/eventmodel');
var selection = require('../selection');

var SELECTOR_DROP_TARGET = '[data-drop-target]';
var SELECTOR_LIST = '[data-list]';
var SELECTOR_LIST_ITEM = '[data-list-item]';
var SELECTOR_LIST_TARGET = SELECTOR_DROP_TARGET + ', body';
var SELECTOR_DRAGGABLE = 'a, [draggable]';
var ATTR_TARGET = 'data-drop-target';

var dropIndicator = null;
var draggedLinkContext = null;
var disabledLists = {};

/**
 * Handler for the dragstart event.
 *
 * @param {MouseEvent} event Event object for a dragstart event.
 * @param {HTMLElement} target The target element.
 */
function onDragStart(event, target) {
  draggedLinkContext = null;

  // clear the selectionState cache
  cachedSelectionState.clear();

  var matchingTarget = getMatchingTarget(event);
  if (matchingTarget) {
    var isInList = $(matchingTarget).matches(SELECTOR_LIST);
    if (isInList) {
      var uri = matchingTarget.getAttribute('data-uri');

      // Dragging a link from inside a list needs to store the list context,
      // since it is not allowed to drop a dragged link inside the same list.
      if (target.tagName.toLowerCase() === 'a') {
        draggedLinkContext = uri;
      }

      // Dragging is disallowed for lists where we're waiting for a list move
      // to finish. This is to prevent multiple moves to be called before the
      // response from the first comes back.
      if (disabledLists[uri]) {
        event.preventDefault();
        return;
      }

      var rowNode = getRowNode(event);
      if (rowNode) {
        var index = getTargetIndex(event.clientY, rowNode);
        if (index !== -1) {
          event.dataTransfer.setData('text/x-spotify-data-log-source-index', index);
        }
      }
    }
  }
}

/**
 * Handler for dragging over a drop target.
 *
 * @param {MouseEvent} event A dragover event object.
 * @param {HTMLElement} target DOM element for the drop target. This can be the
 *     body element even if it's not a drop target.
 */
function onDragOver(event, target) {
  var positionedListDrop = false;
  var rowNode = null;

  var isBody = target === document.body;
  var list = null;
  if (isBody) list = getListTargetFromBody(event);else list = getMatchingListTarget(event);

  // If we found a list from the event, we must validate if it's allowed to drop
  // in the list.
  if (list) {
    var location = isBody ? 'below' : 'inside';
    if (validateListDrop(event, list, location)) {
      if (isBody) {
        positionedListDrop = true;
      } else {
        rowNode = getRowNode(event);
        if (rowNode) {
          positionedListDrop = true;
        }
      }
    }
  }

  if (positionedListDrop) {
    event.preventDefault();

    if (isBody) showDropIndicatorBelowList(list);else if (rowNode) showDropIndicatorForRow(rowNode, event.clientY);
  } else {
    hideDropIndicator();

    var listHookResult = { valid: false };
    if (list) {
      hooks.run('list-target-validation', listHookResult, list);
    }

    // The list might be accepted as a drop target even if dropping in a
    // specific position was not accepted. In that case we need to prevent the
    // default action to tell the browser that we accept drops here.
    if (listHookResult.valid) {
      event.preventDefault();
    } else if (!isBody && list) {
      var targetHookResult = { valid: false };
      hooks.run('target-validation', targetHookResult, event, target);

      // If we know that dropping is not allowed here at all, we need to remove
      // the drop effect from the cursor. This is mainly since the handler in
      // targets.js has already handled the event and accepted it, which sets
      // the drop effect.
      if (!targetHookResult.valid) {
        event.dataTransfer.dropEffect = 'none';
      }
    }
  }
}

/**
 * Handler for dragging out from a drop target.
 *
 * @param {MouseEvent} event A dragleave event object.
 * @param {HTMLElement} target DOM element for the drop target.
 */
function onDragLeave(event, target) {
  hideDropIndicator();
}

/**
 * Handler for ending a drag.
 *
 * @param {MouseEvent} event A dragend event object.
 * @param {HTMLElement} target DOM element for the drop target.
 */
function onDragEnd(event, target) {
  hideDropIndicator();
  draggedLinkContext = null;
}

/**
 * Handler for dropping onto a drop target.
 *
 * @param {MouseEvent} event A drop event object.
 * @param {HTMLElement} target DOM element for the drop target.
 */
function onDrop(event, target) {
  hideDropIndicator();

  var isBody = target === document.body;
  var list = null;
  if (isBody) list = getListTargetFromBody(event);else list = getMatchingListTarget(event);

  if (list) {
    var location = isBody ? 'below' : 'inside';
    if (validateListDrop(event, list, location)) {
      var contextUri = list.getAttribute('data-uri');
      if (contextUri) {
        performListChangesForEvent(event, list, contextUri, location);
        event.handled = true;
      }
    }
  }
}

/**
 * Show the drop indicator below the provided list element.
 *
 * @param {HTMLElement} list A list element.
 */
function showDropIndicatorBelowList(list) {
  var listRect = list.getBoundingClientRect();
  showDropIndicator(listRect.left, listRect.bottom, listRect.width);
}

/**
 * Show the drop indicator above or below a list row.
 *
 * @param {HTMLElement} rowNode A list row element.
 * @param {number} cursorY The cursor Y position, relative to the viewport.
 */
function showDropIndicatorForRow(rowNode, cursorY) {
  var belowMiddle = isBelowMiddleOfNode(cursorY, rowNode);
  var rowRect = rowNode.getBoundingClientRect();
  var x = rowRect.left;
  var y = rowRect.top + (belowMiddle ? rowRect.height : 0);
  showDropIndicator(x, y, rowRect.width);
}

/**
 * Show the drop indicator line for the specified row and cursor position.
 * If the cursor position is below the middle of the row, the indicator will be
 * placed below the row, otherwise above the row.
 *
 * @param {number} x The X position relative to the viewport.
 * @param {number} y The Y position relative to the viewport.
 * @param {number} width The width of the indicator.
 */
function showDropIndicator(x, y, width) {

  // Don't use window.scroll X/Y because cross browser issues.
  // https://developer.mozilla.org/en-US/docs/Web/API/Window.scrollY
  var indicatorAbsX = window.pageXOffset + x;
  var indicatorAbsY = window.pageYOffset + y;
  var indicatorWidth = width;

  if (!dropIndicator) {
    dropIndicator = document.createElement('div');
    dropIndicator.className = 'tr-drag-indicator';
  }

  dropIndicator.style.left = indicatorAbsX + 'px';
  dropIndicator.style.width = indicatorWidth + 'px';
  dropIndicator.style.top = indicatorAbsY + 'px';

  if (!dropIndicator.parentNode) {
    document.body.appendChild(dropIndicator);
  }
}

/**
 * Hide the drop indicator.
 */
function hideDropIndicator() {
  if (dropIndicator && dropIndicator.parentNode) {
    dropIndicator.parentNode.removeChild(dropIndicator);
  }
}

/**
 * Perform the list changes that are needed from the drop event.
 *
 * @param {MouseEvent} event A drop event.
 * @param {HTMLElement} list The list DOM node.
 * @param {string} contextUri The context URI for the list.
 * @param {string} location The location of the cursor in relation to the list.
 *     This can be either 'inside' or 'below'. The value 'below' means that the
 *     cursor was below the last list found in the DOM.
 */
function performListChangesForEvent(event, list, contextUri, location) {
  var liveList = live(contextUri).get('rows');
  if (!liveList) return;

  var targetIndex = 0;

  if (location === 'below') {
    var lastRowNode = getLastRowFromLastList();

    // Dropping below a list without rows will use target index 0
    if (lastRowNode) {
      targetIndex = getTargetIndex(event.clientY, lastRowNode);
    }
  } else {
    var rowNode = getRowNode(event);
    if (!rowNode) return;
    targetIndex = getTargetIndex(event.clientY, rowNode);
  }

  var sourceContext = event.dataTransfer.getData('text/x-spotify-data-context');
  var isSameContext = sourceContext && sourceContext === contextUri;

  if (isSameContext) {
    performMoveChanges(contextUri, liveList, targetIndex);
  } else {
    performInsertChanges(event, list, contextUri, liveList, targetIndex);
  }
  event.data = {
    targetIndex: targetIndex
  };
}

/**
 * Move the selected items to a target index in the list.
 *
 * @param {string} contextUri The context URI of the list.
 * @param {LiveList} liveList The live list for the context.
 * @param {number} targetIndex The target index in the list.
 */
function performMoveChanges(contextUri, liveList, targetIndex) {
  var indices = getMoveIndices(contextUri, liveList);

  // Selection can be nothing. This can happen if you select a row, drag it
  // and before dropping, the row is removed by something else (on another
  // device perhaps). Dropping should in that case not perform any action.
  // Similarly, if dragging multiple rows and some of the rows are removed
  // while dragging, only the rows that are still in the list will be moved.
  if (indices.length === 0) return;

  var operations = listOperations.getMoveOperations(indices, targetIndex);

  // If the list changed while dragging, it might happen that we end up
  // dropping at the same index as we're dragging from, which would give
  // us no operations to perform.
  if (operations.length === 0) return;

  liveList.publish(operations);

  temporarilyDisableList(contextUri, liveList);
}

/**
 * Insert items from the event into the list at the target index.
 *
 * @param {MouseEvent} event A drop event.
 * @param {HTMLElement} list The list DOM node.
 * @param {string} contextUri The context URI for the list.
 * @param {LiveList} liveList The live list for the context.
 * @param {number} targetIndex The target index in the list.
 */
function performInsertChanges(event, list, contextUri, liveList, targetIndex) {
  getInsertValues(event, list, liveList, contextUri, function (error, values) {
    if (error) return;
    if (values.length === 0) return;

    var operations = [{ type: 'insert', index: targetIndex, values: values }];

    liveList.publish(operations);

    temporarilyDisableList(contextUri, liveList);
  });
}

/**
 * Check if dropping at the current position in a list is allowed.
 *
 * @param {MouseEvent} event Some kind of drag and drop event.
 * @param {HTMLElement} list A DOM node marked up as a list.
 * @param {string} location The location of the cursor in relation to the list.
 *     This can be either 'inside' or 'below'. The value 'below' means that the
 *     cursor was below the last list found in the DOM.
 *
 * @return {boolean} True if it's a valid drop position.
 */
function validateListDrop(event, list, location) {

  // All positions are valid if we're not dragging from a context in the first
  // place. If we do have a context though, we need to validate the position.
  var types = event.dataTransfer.types;
  var isDraggingFromContext = types.indexOf('text/x-spotify-data-context') > -1;
  if (isDraggingFromContext) {
    if (!validatePotentialOperations(event, list, location)) {
      return false;
    }
  }

  var uri = list.getAttribute('data-uri');
  if (uri && draggedLinkContext === uri) {
    return false;
  }

  var result = { valid: true };
  hooks.run('list-drop-validation', result, event, list, location);

  return !!result.valid;
}

/**
 * Simple wrapper to cache calls to selection.getIndicesPerList()
 *
 * @return {Object} The result of selection.getIndicesPerList()
 */
var cachedSelectionState = function () {
  var cache = {
    lastTime: 0,
    lastValue: null
  };
  var CACHE_TIMEOUT = 500;

  return {
    get: function get() {
      var now = Date.now();

      if (now - cache.lastTime > CACHE_TIMEOUT) {
        cache = {
          lastValue: selection.getIndicesPerList(),
          lastTime: now
        };
      }

      return cache.lastValue;
    },
    clear: function clear() {
      cache.lastTime = 0;
    }
  };
}();

/**
 * Check if dropping at the current event position would actually result in
 * operations that would change the list.
 *
 * @param {MouseEvent} event Some kind of drag and drop event.
 * @param {HTMLElement} list A DOM node marked up as a list.
 * @param {string} location The location of the cursor in relation to the list.
 *     This can be either 'inside' or 'below'. The value 'below' means that the
 *     cursor was below the last list found in the DOM.
 *
 * @return {boolean} True if it would result in a change.
 */
function validatePotentialOperations(event, list, location) {
  // get a cached version of the selectionState
  var selectionState = cachedSelectionState.get();

  // Dropping inside the only selected range inside the only container that
  // has a selection is not allowed, as that would result in no change.
  if (selectionState.length === 1) {

    // Dropping inside a different context is always fine
    var contextUri = list.getAttribute('data-uri');
    if (contextUri !== selectionState[0].uri) {
      return true;
    }

    var selectedRanges = Range.fromIndices(selectionState[0].indicesWithHidden);

    if (selectedRanges.length === 1) {
      var selectedRange = selectedRanges[0];

      // Include the next row in the selected range to handle holding on the
      // top part of the next row, which would be a no-op. The bottom part of
      // the previous row will be taken care of by the code below.
      selectedRange.update(selectedRange.start, selectedRange.end + 1);

      var rowNode = location === 'below' ? getLastRowFromLastList() : getRowNode(event);
      if (rowNode) {
        var targetIndex = getTargetIndex(event.clientY, rowNode);
        if (targetIndex > -1) {
          var targetRange = new Range(targetIndex, targetIndex + 1);

          // If the target index is inside the selected range, it's not allowed
          // to drop, as that would be a no-op.
          if (targetRange.contained(selectedRange)) {
            return false;
          }
        }
      }
    }
  }

  return true;
}

/**
 * Get the drop target element that is matching the event target and the drag
 * MIME types of the event. This will start with the event target and step
 * outwards in the DOM tree to find the first matching element.
 *
 * @param {MouseEvent} event Some kind of drag and drop event.
 *
 * @return {HTMLElement?} The element or null if not found.
 */
function getMatchingTarget(event) {
  var currentNode = event.target;

  while (currentNode) {
    if (isMatchingTarget(event, currentNode)) {
      return currentNode;
    }
    currentNode = currentNode.parentElement;
  }

  return null;
}

/**
 * Get the list element that is matching the event target and the drag MIME
 * types of the event. This will start with the event target and step outwards
 * in the DOM tree to find the first matching element.
 *
 * @param {MouseEvent} event Some kind of drag and drop event.
 *
 * @return {HTMLElement?} The list element or null if not found.
 */
function getMatchingListTarget(event) {
  var currentNode = event.target;

  while (currentNode) {
    var isList = $(currentNode).matches(SELECTOR_LIST);
    if (isList && isMatchingTarget(event, currentNode)) {
      return currentNode;
    }
    currentNode = currentNode.parentElement;
  }

  return null;
}

/**
 * Get a valid list target from the end of body.
 *
 * @param {MouseEvent} event Some kind of drag and drop event.
 *
 * @return {HTMLElement?} The list element or null if not found.
 */
function getListTargetFromBody(event) {
  var lastList = getLastListNode();
  if (lastList) {
    var sameParent = event.target.contains(lastList);
    if (sameParent && isMatchingTarget(event, lastList)) {
      if (isBelowNode(event.clientX, event.clientY, lastList)) {
        return lastList;
      }
    }
  }

  return null;
}

/**
 * Get the list row element from the event target.
 * If the event target itself isn't a list row, it will step out in the parent
 * tree until it finds a row.
 *
 * @param {MouseEvent} event Some kind of drag and drop event.
 *
 * @return {HTMLElement?} The list row element, or null if not found.
 */
function getRowNode(event) {
  return event.target.closest(SELECTOR_LIST_ITEM);
}

/**
 * Get the last list row from the last list in the DOM.
 *
 * @return {HTMLElement?} The list row element, or null if not found.
 */
function getLastRowFromLastList() {
  var lastList = getLastListNode();
  if (lastList) {
    var listItems = $(lastList).search(SELECTOR_LIST_ITEM);
    var lastItem = listItems && listItems[listItems.length - 1];
    if (lastItem) return lastItem;
  }

  return null;
}

/**
 * Get the last list in the DOM.
 *
 * @return {HTMLElement?} The list element, or null if not found.
 */
function getLastListNode() {
  var lists = $(SELECTOR_LIST);
  var lastList = lists && lists[lists.length - 1];
  return lastList || null;
}

/**
 * Get the target index based on a cursor position and the row that the cursor
 * is on.
 *
 * @param {number} y The Y position relative to the viewport.
 * @param {HTMLElement} rowNode The DOM node for the row.
 *
 * @return {number} The target index or -1 if not found.
 */
function getTargetIndex(y, rowNode) {
  var index = rowNode.getAttribute('data-index');

  if (index === null) {
    index = -1;
  } else {
    index = parseInt(index, 10);

    if (isNaN(index)) {
      index = -1;
    } else {
      // If cursor is in the bottom part of the row, dropping will place items
      // after the row, so we need to increment the index.
      if (isBelowMiddleOfNode(y, rowNode)) {
        index++;
      }
    }
  }

  return index;
}

/**
 * Get the indices of the rows to move.
 *
 * @param {string} contextUri The context URI.
 * @param {LiveList} liveList The live list to be changed.
 *
 * @return {Array.<number>} Array of indices.
 */
function getMoveIndices(contextUri, liveList) {
  // As we need the indices, we must use the current selection state,
  // since the list might have changed since the start of the drag.
  // We are only in this function if we are dragging in the same
  // context, so the current selection state will always be valid.
  var selectionState = selection.getIndicesPerList();
  if (selectionState.length !== 1) return [];

  var firstContainer = selectionState[0];
  var selectedIndices = firstContainer.indices;
  var indices = selectedIndices.slice();

  if (indices.length === 0) return [];

  hooks.run('get-move-indices', contextUri, liveList, indices);

  // The indices must be sorted for the utility that creates the list operations
  indices.sort(function (a, b) {
    return a - b;
  });

  return indices;
}

/**
 * Get the values to use for insertion in the list. This will get the event data
 * for the matching MIME types.
 *
 * @param {MouseEvent} event A drop event.
 * @param {HTMLElement} list The list DOM node.
 * @param {LiveList} liveList The live list for the context.
 * @param {string} contextUri The context URI for the list.
 * @param {Function} callback A callback function. The data argument will be an
 *     array of object values.
 */
function getInsertValues(event, list, liveList, contextUri, callback) {
  var eventTypes = event.dataTransfer.types;
  var listTypes = list.getAttribute(ATTR_TARGET);
  if (!listTypes) return callback(null, []);

  var matchingTypes = intersection(listTypes.split('|'), eventTypes);
  if (matchingTypes.length === 0) return callback(null, []);

  var data = getDataFromTypes(event, matchingTypes);

  var isTrackList = isListOfTracks(liveList, contextUri);

  getRowsFromData(data, isTrackList, function (error, rows) {
    if (error) return callback(error);

    callback(null, rows);
  });
}

/**
 * Get the event data associated with the provided MIME types.
 *
 * @param {MouseEvent} event Some kind of drag and drop event.
 * @param {Array.<string>} types Array of MIME types.
 *
 * @return {Object.<string, Array>} Object where key is MIME type and value is
 *     array of values (URIs).
 */
function getDataFromTypes(event, types) {
  var data = {};

  for (var i = 0, l = types.length; i < l; i++) {
    var type = types[i];
    var itemsInData = data[type] = [];

    // A MIME type that starts with text/x-spotify is always containing a list
    // of Open URLs separated by '\n'.
    var hasURIs = type.indexOf('text/x-spotify') === 0;

    var dataForType = event.dataTransfer.getData(type);
    var items = hasURIs ? dataForType.split('\n') : [dataForType];
    for (var n = 0, len = items.length; n < len; n++) {
      var item = items[n];
      if (hasURIs) {
        var uriObject = liburi.from(item);
        if (uriObject) {
          itemsInData.push(uriObject.toURI());
        }
      } else {
        itemsInData.push(item);
      }
    }
  }

  return data;
}

/**
 * Get list row data from the event data. This might expand items if the list
 * is a track list (dropping an album into a track list will expand the album
 * into its tracks and return track rows instead).
 *
 * @param {Object.<string, Array>} data Data from drop event.
 * @param {boolean} isTrackList True if the list is a track list.
 * @param {Function} callback A callback function. The data argument will be an
 *     array of object values.
 */
function getRowsFromData(data, isTrackList, callback) {
  var flowFunctions = [];

  if (data['text/x-spotify-tracks']) {
    flowFunctions.push(function () {
      this.done(null, getRowObjects('track', data['text/x-spotify-tracks']));
    });
  }

  if (data['text/x-spotify-albums']) {
    flowFunctions.push(function () {
      var albums = data['text/x-spotify-albums'];
      if (isTrackList) fetchListTrackRows(albums, this);else this.done(null, getRowObjects('album', albums));
    });
  }

  if (data['text/x-spotify-playlists']) {
    flowFunctions.push(function () {
      var playlists = data['text/x-spotify-playlists'];
      if (isTrackList) fetchListTrackRows(playlists, this);else this.done(null, getRowObjects('playlist', playlists));
    });
  }

  if (data['text/x-spotify-artists']) {
    flowFunctions.push(function () {
      this.done(null, getRowObjects('artist', data['text/x-spotify-artists']));
    });
  }

  if (data['text/x-spotify-users']) {
    flowFunctions.push(function () {
      this.done(null, getRowObjects('user', data['text/x-spotify-users']));
    });
  }

  flow(flowFunctions).finally(function (error) {
    if (error) return callback(error);

    var arrays = Array.prototype.slice.call(arguments, 1);
    var rows = [];
    rows = rows.concat.apply(rows, arrays);

    callback(null, rows);
  });
}

/**
 * Fetch the track rows from a set of list URIs. This is for the expansion of
 * for example an album into the tracks of the album.
 *
 * @param {Array.<string>} listUris Array of list URIs.
 * @param {Object} control Flow control object.
 */
function fetchListTrackRows(listUris, control) {
  flow().parallel(listUris, function (listUri) {
    var innerControl = this;
    live(listUri).query('rows(track(uri))', function (error, data) {
      if (error) return innerControl.done(null, []);
      var rows = data.rows.map(function (row) {
        return live(row);
      });
      innerControl.done(null, rows);
    }, live.ASAP);
  }).finally(function (error) {
    if (error) return control.done(null, []);
    var arrays = Array.prototype.slice.call(arguments, 1);
    var rows = [];
    rows = rows.concat.apply(rows, arrays);
    control.done(null, rows);
  });
}

/**
 * Fetch the live object for the row of an item.
 *
 * @param {string} itemType The type of an item (for example 'track').
 * @param {Array.<string>} uris Array of item URIs.
 *
 * @return {Array.<LiveObject>} Array of row live objects.
 */
function getRowObjects(itemType, uris) {
  return uris.map(function (uri) {
    var row = {};
    row[itemType] = { uri: uri };
    return live(row);
  });
}

/**
 * Check if the list is a track list.
 *
 * @param {LiveList} liveList The live list.
 * @param {string} contextUri The context URI for the list.
 *
 * @return {boolean} True if the list is a track list.
 */
function isListOfTracks(liveList, contextUri) {
  var uriObject = liburi.from(contextUri);
  var type = uriObject && uriObject.type;
  if (type === liburi.Type.PLAYLIST) return true;

  var result = { valid: false };
  hooks.run('is-list-of-tracks', result, liveList, contextUri);

  if (!result.valid) {
    var firstRow = liveList.get(0);
    var firstTrack = firstRow && firstRow.get('track');
    if (firstTrack) return true;
  }

  return !!result.valid;
}

/**
 * Check if the position is below the bottom edge of the node.
 *
 * @param {number} x The X position relative to the viewport.
 * @param {number} y The Y position relative to the viewport.
 * @param {HTMLElement} node DOM node to check against.
 *
 * @return {boolean} True if the position is below.
 */
function isBelowNode(x, y, node) {
  var rect = node.getBoundingClientRect();
  var below = y >= rect.bottom;
  var betweenX = x >= rect.left && x <= rect.right;
  return below && betweenX;
}

/**
 * Check if the position is below the middle of the node.
 *
 * @param {number} y The Y position relative to the viewport.
 * @param {HTMLElement} node DOM node to check against.
 *
 * @return {boolean} True if the position is below.
 */
function isBelowMiddleOfNode(y, node) {
  var rect = node.getBoundingClientRect();
  return y >= rect.top + rect.height / 2;
}

/**
 * Check if the MIME types in the drag event matches the MIME types for the
 * specified drop target.
 *
 * @param {MouseEvent} event Some kind of drag and drop event.
 * @param {HTMLElement} node A DOM node.
 *
 * @return {boolean} True if the element matches the event.
 */
function isMatchingTarget(event, node) {
  var eventTypes = event.dataTransfer.types;
  var nodeTypes = node.getAttribute(ATTR_TARGET);

  if (nodeTypes) {
    var matching = intersection(nodeTypes.split('|'), eventTypes);
    if (matching.length > 0) return true;
  }

  return false;
}

/**
 * Temporarily disable drag and dropping inside a list until the move or insert
 * is done. This is to prevent multiple operations to be called before the
 * response from the first comes back. We consider the operation done when we
 * receive the next update event, since it's very tricky to know when this
 * specific move is done. To prevent possible errors with being disabled
 * infinitely, we will enable it again after a certain timeout. This could
 * happen for example if the live list is switched out for a new list, in which
 * case we won't get the update event.
 *
 * @param {string} contextUri The context URI.
 * @param {LiveList} liveList The live list that was changed.
 */
function temporarilyDisableList(contextUri, liveList) {

  disabledLists[contextUri] = true;

  var timer;

  var handler = function handler(operations) {
    clearTimeout(timer);
    liveList.off('update', handler);

    // Wait slighly longer to allow the change to trickle down to DOM
    setTimeout(function () {
      delete disabledLists[contextUri];
    }, 100);
  };

  liveList.on('update', handler);

  timer = setTimeout(handler, 500);
}

/**
 * Attach the module.
 */
function attach() {
  eventModel.delegate('dragstart', SELECTOR_DRAGGABLE, onDragStart);
  eventModel.delegate('dragover', SELECTOR_LIST_TARGET, onDragOver);
  eventModel.delegate('dragleave', SELECTOR_LIST_TARGET, onDragLeave);
  eventModel.delegate('dragend', 'body', onDragEnd);
  eventModel.delegate('drop', SELECTOR_LIST_TARGET, onDrop);
}

/**
 * Detach the module.
 */
function detach() {
  eventModel.undelegate('dragstart', SELECTOR_DRAGGABLE, onDragStart);
  eventModel.undelegate('dragover', SELECTOR_LIST_TARGET, onDragOver);
  eventModel.undelegate('dragleave', SELECTOR_LIST_TARGET, onDragLeave);
  eventModel.undelegate('dragend', 'body', onDragEnd);
  eventModel.undelegate('drop', SELECTOR_LIST_TARGET, onDrop);
}

exports.attach = attach;
exports.detach = detach;

},{"../../spotify-elements":45,"../../spotify-live":212,"../../spotify-range2":251,"../selection":88,"./util/eventmodel":61,"./util/hooks":62,"finally":290,"mout/array/intersection":332,"spotify-liburi":398,"spotify-live-list-operations":399}],60:[function(require,module,exports){
(function (global){
/**
 * @module spotify-events/dragndrop/target
 * @private
 */
'use strict';

var $ = require('../../spotify-elements');
var liburi = require('spotify-liburi');
var defer = require('prime/defer');

var center = require('../center');
var eventModel = require('./util/eventmodel');
var hooks = require('./util/hooks');
var getLogContext = require('../util/get-log-context');
var UserDragAndDropInteraction1 = require('../../spotify-logger/messages/UserDragAndDropInteraction1');

var SELECTOR_DROP_TARGET = '[data-drop-target]';
var SELECTOR_DRAGGABLE = 'a, [draggable]';
var ATTR_TARGET = 'data-drop-target';
var ATTR_NO_CLASSNAME = 'data-drop-no-classname';
var CLASSNAME_ACTIVE = 'drop-target-active';

var longHoldTimerId = 0;
var longHoldTimerDuration = 1000;
var draggedElement = null;
var lastEnteredElement = null;

/**
 * Handler for starting to drag.
 *
 * @param {MouseEvent} event A dragstart event object.
 * @param {HTMLElement} node The draggable DOM element.
 */
function onDragStart(event, node) {
  draggedElement = node;
  lastEnteredElement = null;
}

/**
 * Handler for ending a drag.
 *
 * @param {MouseEvent} event A dragend event object.
 * @param {HTMLElement} target DOM element for the drop target.
 */
function onDragEnd(event, target) {
  draggedElement = null;
  lastEnteredElement = null;

  stopLongHoldTimer();
  removeAnyActiveClass();
}

/**
 * Handler for dragging into a drop target.
 *
 * @param {MouseEvent} event A dragenter event object.
 * @param {HTMLElement} target DOM element for the drop target.
 */
function onDragEnter(event, target) {
  if (validateTarget(event, target)) {
    setEnter(event, target);
  }
}

/**
 * Handler for dragging out from a drop target.
 *
 * @param {MouseEvent} event A dragleave event object.
 * @param {HTMLElement} target DOM element for the drop target.
 */
function onDragLeave(event, target) {
  if (validateTarget(event, target)) {
    setLeave(event, target);
  }
}

/**
 * Handler for dragging over a drop target.
 *
 * @param {MouseEvent} event A dragover event object.
 * @param {HTMLElement} target DOM element for the drop target.
 */
function onDragOver(event, target) {
  if (validateTarget(event, target)) {

    // Tell the event that we are accepting drops on this target
    event.preventDefault();

    // Since other code might have set the dropEffect to something else,
    // we need to override that, since we're now accepting drops
    event.dataTransfer.dropEffect = 'copy';

    setEnter(event, target);

    // If the target is not valid, remove any styling for active drop target
  } else {
      setLeave(event, target);
    }
}

/**
 * Handler for dropping on a drop target.
 *
 * @param {MouseEvent} event A drop event object.
 * @param {HTMLElement} target DOM element for the drop target.
 */
function onDrop(event, target) {
  stopLongHoldTimer();

  // Dropping should remove active target class name.
  // Dropping outside of a target doesn't need this, as the target is only
  // active when hovering it.
  removeAnyActiveClass();

  if (validateTarget(event, target)) {
    var types = getMimeTypesForTarget(event, target);
    var dropData = getDropData(event, types);
    var sourceUri = event.dataTransfer.getData('text/x-spotify-data-context') || null;
    var sourceLogContext = event.dataTransfer.getData('text/x-spotify-data-log-context') || null;
    var sourceAppUri = event.dataTransfer.getData('text/x-spotify-data-app-uri') || null;
    var sourceIndex = parseInt(event.dataTransfer.getData('text/x-spotify-data-log-source-index'), 0);
    if (isNaN(sourceIndex)) sourceIndex = null;

    var targetUriNode = target.closest('[data-uri]');
    var targetUri = targetUriNode && targetUriNode.getAttribute('data-uri') || null;
    var targetLogContext = getLogContext(target);
    var targetAppUri = global.__spotify && global.__spotify.app_uri || null;

    // Give any other delegates a chance to handle the drop, and if so pass
    // that info along in the event.
    defer(function () {
      center.emit('drop', {
        handled: event.handled,
        node: target,
        sourceUri: sourceUri,
        targetUri: targetUri,
        data: dropData
      });

      var firstItem = dropData[Object.keys(dropData)[0]][0];
      var itemType = liburi.from(firstItem).type;
      var numberOfItems = Object.keys(dropData).reduce(function (sum, key) {
        return sum + dropData[key].length;
      }, 0);
      var targetIndex = event.data && event.data.targetIndex || null;

      UserDragAndDropInteraction1.log({
        item_type: itemType,
        item_uri: firstItem,
        number_items: numberOfItems,
        source_view_uri: sourceAppUri,
        source_uri: sourceUri,
        source_index: sourceIndex,
        source_component: sourceLogContext,
        target_view_uri: targetAppUri,
        target_uri: targetUri,
        target_index: targetIndex,
        target_component: targetLogContext
      });
    });
  }

  // Prevent navigation on drop
  event.preventDefault();

  // Reset here since our multi-frame architecture means we're not guaranteed
  // to have gotten a dragstart event in this frame prior to dropping.
  lastEnteredElement = null;
}

/**
 * Set target to be entered, including setting style and sending event.
 *
 * @param {MouseEvent} event A dragenter event object.
 * @param {HTMLElement} target DOM element for the drop target.
 */
function setEnter(event, target) {
  if (target === lastEnteredElement) {
    return;
  }

  lastEnteredElement = target;

  if (!target.hasAttribute(ATTR_NO_CLASSNAME)) {
    $(target).addClass(CLASSNAME_ACTIVE);
  }

  var types = getMimeTypesForTarget(event, target);
  center.emit('dragenter', { node: target, types: types });

  startLongHoldTimer(target, types);
}

/**
 * Set target to be left, including removing style and sending event.
 *
 * @param {MouseEvent} event A dragleave event object.
 * @param {HTMLElement} target DOM element for the drop target.
 */
function setLeave(event, target) {
  if (target !== lastEnteredElement) {
    return;
  }

  lastEnteredElement = null;

  if (!target.hasAttribute(ATTR_NO_CLASSNAME)) {
    $(target).removeClass(CLASSNAME_ACTIVE);
  }

  var types = getMimeTypesForTarget(event, target);
  center.emit('dragleave', { node: target, types: types });

  stopLongHoldTimer();
}

/**
 * Check if the drop target matches the MIME types for the event.
 *
 * @param {MouseEvent} event Some kind of drag and drop event.
 * @param {HTMLElement} target DOM element for the drop target.
 *
 * @return {boolean} True if the target is valid.
 */
function validateTarget(event, target) {

  // The element being dragged is not accepted as a drop target
  if (target === draggedElement) {
    return false;
  }

  var types = getMimeTypesForTarget(event, target);

  if (types.length) {
    var result = { valid: true };
    hooks.run('target-validation', result, event, target);

    if (result.valid) {
      return true;
    }
  }

  return false;
}

/**
 * Get the data associated with the drop, grouped by MIME type.
 * If the data contained Spotify URLs, they will be converted to Spotify URIs.
 *
 * @param {MouseEvent} event Event object for a drop event.
 * @param {Array.<string>} types Array of MIME types.
 *
 * @return {Object.<string, Array.<string>>} Data object of arrays of item
 *     URIs, grouped by MIME type.
 */
function getDropData(event, types) {
  var data = {};

  for (var i = 0, l = types.length; i < l; i++) {
    var itemsInData = data[types[i]] = [];
    var dataForType = event.dataTransfer.getData(types[i]);
    var hasURIs = types[i].indexOf('text/x-spotify') === 0;
    var items = hasURIs ? dataForType.split('\n') : [dataForType];

    for (var n = 0, len = items.length; n < len; n++) {
      var item = items[n];
      if (hasURIs) {
        var uriObject = liburi.from(item);
        if (uriObject) item = uriObject.toURI();
      }
      if (item) itemsInData.push(item);
    }
  }

  var hasContextData = types.indexOf('text/x-spotify-data-context') > -1;
  if (hasContextData) {
    data['text/x-spotify-data-context'] = [event.dataTransfer.getData('text/x-spotify-data-context')];
  }

  return data;
}

/**
 * Start a timer for emitting an event for long-hold on a target.
 * If one is already started, it will use the previous timer and not restart it.
 *
 * @param {HTMLElement} target A DOM element for the drop target.
 * @param {Array.<string>} types Array of MIME types.
 */
function startLongHoldTimer(target, types) {

  // Don't start a new timer if we already have one running
  if (longHoldTimerId) return;

  longHoldTimerId = setTimeout(function () {
    center.emit('dragover-long', { node: target, types: types });
  }, longHoldTimerDuration);
}

/**
 * Stop any running timer for emitting an event for long-hold on a target.
 */
function stopLongHoldTimer() {
  clearTimeout(longHoldTimerId);

  // Reset the timer ID so we can know that there is no timer running
  longHoldTimerId = 0;
}

/**
 * Remove the active class name from any element that has it.
 */
function removeAnyActiveClass() {
  var active = $('.' + CLASSNAME_ACTIVE);
  if (active) {
    active.removeClass(CLASSNAME_ACTIVE);
  }
}

/**
 * Get the MIME types that are matching both the drag event and the target.
 *
 * @param {MouseEvent} event Any kind of drag and drop event.
 * @param {HTMLElement} target A DOM element.
 *
 * @return {Array.<string>} Array of MIME types.
 */
function getMimeTypesForTarget(event, target) {
  var mimeTypes = [];
  var dataTypes = event.dataTransfer.types;

  var targetTypes = target.getAttribute(ATTR_TARGET);
  if (targetTypes) {
    targetTypes = targetTypes.split('|');

    for (var i = 0, l = dataTypes.length; i < l; i++) {
      var type = dataTypes[i];
      if (targetTypes.indexOf(type) > -1) {
        mimeTypes.push(type);
      }
    }
  }

  return mimeTypes;
}

/**
 * Attach the module.
 */
function attach() {
  eventModel.delegate('dragstart', SELECTOR_DRAGGABLE, onDragStart);
  eventModel.delegate('dragenter', SELECTOR_DROP_TARGET, onDragEnter);
  eventModel.delegate('dragleave', SELECTOR_DROP_TARGET, onDragLeave);
  eventModel.delegate('dragover', SELECTOR_DROP_TARGET, onDragOver);
  eventModel.delegate('dragend', 'body', onDragEnd);
  eventModel.delegate('drop', SELECTOR_DROP_TARGET, onDrop);
}

/**
 * Detach the module.
 */
function detach() {
  eventModel.undelegate('dragstart', SELECTOR_DRAGGABLE, onDragStart);
  eventModel.undelegate('dragenter', SELECTOR_DROP_TARGET, onDragEnter);
  eventModel.undelegate('dragleave', SELECTOR_DROP_TARGET, onDragLeave);
  eventModel.undelegate('dragover', SELECTOR_DROP_TARGET, onDragOver);
  eventModel.undelegate('dragend', 'body', onDragEnd);
  eventModel.undelegate('drop', SELECTOR_DROP_TARGET, onDrop);
}

exports.attach = attach;
exports.detach = detach;

// Exporting for testing
var originalDuration = longHoldTimerDuration;
exports.setLongHoldDuration = function setLongHoldDuration(duration) {
  longHoldTimerDuration = duration;
};
exports.resetLongHoldDuration = function resetLongHoldDuration() {
  longHoldTimerDuration = originalDuration;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../spotify-elements":45,"../../spotify-logger/messages/UserDragAndDropInteraction1":224,"../center":52,"../util/get-log-context":105,"./util/eventmodel":61,"./util/hooks":62,"prime/defer":373,"spotify-liburi":398}],61:[function(require,module,exports){
/**
 * @module spotify-events/dragndrop/util/eventmodel
 * @private
 *
 * This module is made to be an abstraction of the event model for drag and
 * drop. It also exposes a delegation interface which allows you to only
 * listen for events for targets matching a certain selector.
 *
 * The need for this abstraction is to simplify the code listening to drag
 * and drop events.
 *
 * - The raw events we get from the browser are sometimes not that easy to
 *   work with. For example, when moving from one target to another, we get
 *   a dragenter event before the dragleave event, which can cause confusion.
 *   This abstraction flips that around, so that you always get the dragleave
 *   event before the dragenter event.
 *
 * - The raw events also trigger for children. For example, if moving the
 *   cursor from one element to one of its children, we get a dragenter event
 *   for the child element and a dragleave for the outer element. This makes
 *   it difficult to highlight drop targets based on dragenter/dragleave.
 *   This abstraction helps by making sure the handler is not called if moving
 *   to a child element inside an element that matches the selector. There
 *   is an exception though when moving to a child that is also matching a
 *   selector, the outer element is then left and the child is entered.
 *
 * @example
 * function onDragEnter(event, target) {
 *   event instanceof MouseEvent; // true
 *   target instanceof HTMLElement; // true
 *   target.matches('[data-drop-target]'); // true
 * }
 *
 * // Start listening
 * eventmodel.delegate('dragenter', '[data-drop-target]', onDragEnter);
 *
 * // Stop listening
 * eventmodel.undelegate('dragenter', '[data-drop-target]', onDragEnter);
 */
'use strict';

var $ = require('../../../spotify-elements');

var attached = {};
var delegations = {};
var movementHandlerCount = 0;

// State variables
var hasEntered = false;
var lastEnteredElement = null;
var lastEnterTarget = null;
var lastEnterEvent = null;
var wasLastEventEnter = false;

/**
 * Reset the temporary state variables used while dragging.
 */
function resetState() {
  hasEntered = false;
  lastEnteredElement = null;
  lastEnterTarget = null;
  lastEnterEvent = null;
  wasLastEventEnter = false;
}

/**
 * Generic handler for any event.
 * This function will look at the current delegations and run the handler
 * functions for the matching delegations.
 * Some events will be handled by calling a special handler, which in some cases
 * later will check for matching delegations.
 *
 * @param {Event} event Event object.
 */
function onEvent(event) {
  var handler = getPrimaryHandler(event.type);
  if (handler) {
    handler(event);
  } else {
    handleDelegationsForEvent(event);
  }
}

/**
 * Handler for a dragenter event.
 * Depending on state, this might save the event for later and call the
 * handler at a later point, to ensure that the dragenter event is sent
 * after the dragleave.
 *
 * @param {MouseEvent} event Event object for a dragenter event.
 */
function onPrimaryDragEnter(event) {
  wasLastEventEnter = true;

  if (hasEntered) {
    if (lastEnteredElement !== event.target) {
      lastEnterEvent = event;
    }
  } else {
    hasEntered = true;
    lastEnteredElement = event.target;
    handleDelegationsForEvent(event);
  }
}

/**
 * Handler for a dragleave event.
 * Depending on state, this might also trigger the handlers for a dragenter
 * event, if there was a saved event from before.
 *
 * @param {MouseEvent} event Event object for a dragleave event.
 */
function onPrimaryDragLeave(event) {
  wasLastEventEnter = false;
  lastEnteredElement = null;

  handleDelegationsForEvent(event);

  if (hasEntered) {
    if (lastEnterEvent) {
      lastEnteredElement = lastEnterEvent.target;
      handleDelegationsForEvent(lastEnterEvent);
      lastEnterEvent = null;
    } else {
      hasEntered = false;
    }
  }
}

/**
 * Handler for a drop event.
 * This is handled by a special handler only to reset some state.
 *
 * @param {MouseEvent} event Event object for a drop event.
 */
function onPrimaryDrop(event) {
  resetState();
  handleDelegationsForEvent(event);
}

/**
 * Handler for a dragend event.
 * This is handled by a special handler only to reset some state.
 *
 * @param {MouseEvent} event Event object for a drop event.
 */
function onPrimaryDragEnd(event) {
  resetState();
  handleDelegationsForEvent(event);
}

/**
 * Delegation handler for a dragenter event.
 * After matching against stored delegations, we need to do some final checking
 * before calling the user handler.
 *
 * @param {MouseEvent} event Event object for a dragenter event.
 * @param {HTMLElement} target A DOM element.
 * @param {Function} handler The user handler.
 * @param {string} selector A CSS selector string.
 */
function onDragEnter(event, target, handler, selector) {
  if (target !== lastEnterTarget) {
    lastEnterTarget = target;
    callUserHandler(event, target, handler);
  }
}

/**
 * Delegation handler for a dragleave event.
 * After matching against stored delegations, we need to do some final checking
 * before calling the user handler.
 *
 * @param {MouseEvent} event Event object for a dragleave event.
 * @param {HTMLElement} target A DOM element.
 * @param {Function} handler The user handler.
 * @param {string} selector A CSS selector string.
 */
function onDragLeave(event, target, handler, selector) {
  var shouldCallUserHandler = false;

  var lastElement = lastEnterEvent && lastEnterEvent.target;
  if (lastElement) {
    var isSameElement = target === lastElement;
    var isEnteringChild = !isSameElement && target.contains(lastElement);
    var isEnteringMatchingElement = $(lastElement).matches(selector);
    if (!isSameElement && (!isEnteringChild || isEnteringMatchingElement)) {
      shouldCallUserHandler = true;
    }
  }

  // Most often the sequence of events will be dragenter->dragenter->dragleave
  // when moving into one element and then into another element. But if the
  // sequence is just dragenter->dragleave, we should also call the user
  // handler. This would happen if there is no new entered element.
  if (!wasLastEventEnter) {
    shouldCallUserHandler = true;
  }

  if (shouldCallUserHandler) {
    lastEnterTarget = null;
    callUserHandler(event, target, handler);
  }
}

/**
 * Find matching delegations and call the handlers.
 *
 * @param {Event} event Event object.
 */
function handleDelegationsForEvent(event) {
  var type = event.type;
  var delegationData = delegations[type];

  if (delegationData && delegationData.length > 0) {

    delegationData.forEach(function (data) {
      var selector = data.selector;
      var matchingTarget = event.target.closest(selector);

      if (matchingTarget) {
        var handler = getHandler(type) || callUserHandler;
        handler(event, matchingTarget, data.handler, selector);
      }
    });
  }
}

/**
 * Call the user handler for a delegation.
 *
 * @param {Event} event Event object.
 * @param {HTMLElement} target A DOM element.
 * @param {Function} handler The user handler.
 * @param {string} selector A CSS selector string.
 */
function callUserHandler(event, target, handler, selector) {
  handler.call(exports, event, target);
}

/**
 * Get any handler that needs to be called for a raw event before looking
 * for any delegations.
 *
 * @param {string} type Event type.
 *
 * @return {Function?} The handler function or null if no special handler
 *     should be called.
 */
function getPrimaryHandler(type) {
  switch (type) {
    case 'dragenter':
      return onPrimaryDragEnter;
    case 'dragleave':
      return onPrimaryDragLeave;
    case 'dragend':
      return onPrimaryDragEnd;
    case 'drop':
      return onPrimaryDrop;
  }
  return null;
}

/**
 * Get any handler that needs to be called after matching delegations,
 * but before calling the user handler.
 *
 * @param {string} type Event type.
 *
 * @return {Function?} The handler function or null if no special handler
 *     should be called.
 */
function getHandler(type) {
  switch (type) {
    case 'dragenter':
      return onDragEnter;
    case 'dragleave':
      return onDragLeave;
  }
  return null;
}

/**
 * Check if the event type is one of the events that need special handling
 * for movement (enter/leave events).
 *
 * @param {string} type Event type.
 *
 * @return {boolean} True if the type is a movement type, false otherwise.
 */
function isMovementType(type) {
  switch (type) {
    case 'dragenter':
      return true;
    case 'dragleave':
      return true;
    case 'dragend':
      return true;
    case 'drop':
      return true;
  }
  return false;
}

/**
 * Attach a global event listener on document for the specified type.
 *
 * @param {string} type Event type.
 */
function attach(type) {
  if (attached[type]) return;
  attached[type] = true;
  document.addEventListener(type, onEvent, false);
}

/**
 * Detach a global event listener on document for the specified type.
 *
 * @param {string} type Event type.
 */
function detach(type) {
  if (!attached[type]) return;
  attached[type] = false;
  document.removeEventListener(type, onEvent, false);
}

/**
 * Start listening for an event via event delegation for the specified
 * selector.
 *
 * @example
 * var selector = '[data-drop-target]';
 * eventModel.delegate('dragenter', selector, function(event, target) {
 *   event instanceof MouseEvent; // true
 *   target instanceof HTMLElement; // true
 *   target.matches('[data-drop-target]'); // true
 * });
 */
function delegate(type, selector, handler) {
  if (isMovementType(type)) {
    movementHandlerCount++;
    if (movementHandlerCount === 1) {
      attach('dragenter');
      attach('dragleave');
      attach('dragend');
      attach('drop');
    }
  } else if (!attached[type]) {
    attach(type);
  }

  if (!delegations[type]) delegations[type] = [];

  delegations[type].push({ selector: selector, handler: handler });
}

/**
 * Stop listening for an event via event delegation for the specified
 * selector and handler.
 *
 * @example
 * eventModel.undelegate('dragenter', '[data-drop-target]', handler);
 */
function undelegate(type, selector, handler) {
  if (isMovementType(type)) {
    movementHandlerCount = Math.max(0, movementHandlerCount - 1);
    if (movementHandlerCount === 0) {
      detach('dragenter');
      detach('dragleave');
      detach('dragend');
      detach('drop');
    }
  }

  var delegationsForType = delegations[type];
  if (delegationsForType) {
    for (var i = 0, l = delegationsForType.length; i < l; i++) {
      var data = delegationsForType[i];
      if (data.selector === selector && data.handler === handler) {
        delegationsForType.splice(i, 1);
        break;
      }
    }

    if (!isMovementType && delegationsForType.length === 0) {
      detach(type);
    }
  }
}

exports.delegate = delegate;
exports.undelegate = undelegate;

},{"../../../spotify-elements":45}],62:[function(require,module,exports){
/**
 * Hooks
 *
 * Almost like an event emitter. You can add hooks for different ids, and when
 * a hook for an ID is run, the handlers are called.
 *
 * @module spotify-events/dragndrop/util/hooks
 * @private
 */
'use strict';

var hooks = {};

/**
 * Add a hook handler for a specific hook ID.
 *
 * @param {string} id The hook ID.
 * @param {function} handler The handler function. The hook sets the arguments.
 */
function add(id, handler) {
  if (!hooks[id]) hooks[id] = [];
  hooks[id].push(handler);
}

/**
 * Remove a hook handler for a specific hook ID.
 *
 * @param {string} id The hook ID.
 * @param {function} handler The handler function.
 */
function remove(id, handler) {
  if (hooks[id]) {
    var index = hooks[id].indexOf(handler);
    if (index > -1) {
      hooks[id].splice(index, 1);
    }
  }
}

/**
 * Run the hook handlers for a specific hook ID.
 *
 * @param {string} id The hook ID.
 * @param {...*} var_args Arguments to pass to the handlers.
 */
function run(id, var_args) {
  var handlers = hooks[id];
  if (handlers && handlers.length > 0) {
    var args = Array.prototype.slice.call(arguments, 1);
    for (var i = 0, l = handlers.length; i < l; i++) {
      handlers[i].apply(null, args);
    }
  }
}

exports.add = add;
exports.remove = remove;
exports.run = run;

},{}],63:[function(require,module,exports){
/**
 * @module spotify-events/dragndrop/util/itemtext
 * @private
 */
'use strict';

var live = require('../../../spotify-live');
var liburi = require('spotify-liburi');

/**
 * Get the text for a URI.
 *
 * @param {string} uri Any URI.
 *
 * @return {string} The text.
 */
function getForUri(uri) {
  var uriObject = liburi.from(uri);
  if (!uriObject) return '';

  var type = uriObject.type;

  if (type === liburi.Type.TRACK || type === liburi.Type.LOCAL) {
    return getForTrack(uri);
  } else if (type === liburi.Type.ARTIST || type === liburi.Type.LOCAL_ARTIST) {
    return getForArtist(uri);
  } else if (type === liburi.Type.ALBUM || type === liburi.Type.LOCAL_ALBUM) {
    return getForAlbum(uri);
  } else if (type === liburi.Type.PLAYLIST) {
    return getForPlaylist(uri);
  } else if (type === liburi.Type.USER || type === liburi.Type.PROFILE) {
    return getForUser(uri);
  } else if (type === liburi.Type.FOLDER) {
    return getForFolder(uri);
  } else if (type === liburi.Type.STATION) {
    return getForStation(uri);
  }

  return '';
}

/**
 * Get the text for a track URI.
 *
 * Examples:
 * Track Name – First Artist, Second Artist, Third Artist (and so on...)
 * Track Name
 *
 * @param {string} uri Track URI.
 *
 * @return {string} The text.
 */
function getForTrack(uri) {
  var object = live(uri);
  var itemName = object.get('name');
  if (!itemName) return '';

  var artists = object.get('artists');
  if (!artists || artists.length === 0) return itemName;

  var artistNames = artists.get(0, artists.length).map(function (artist) {
    return artist.get('name');
  }).join(', ');
  if (!artistNames) return itemName;

  return separateDragTextItems(itemName, artistNames);
}

/**
 * Get the text for an artist URI.
 *
 * Examples:
 * Artist Name
 *
 * @param {string} uri Artist URI.
 *
 * @return {string} The text.
 */
function getForArtist(uri) {
  return live(uri).get('name') || '';
}

/**
 * Get the text for an album URI.
 *
 * Examples:
 * Artist Name – Album Name
 * Album Name
 *
 * @param {string} uri Album URI.
 *
 * @return {string} The text.
 */
function getForAlbum(uri) {
  var object = live(uri);
  var itemName = object.get('name');
  if (!itemName) return '';

  var artists = object.get('artists');
  if (!artists || artists.length === 0) return itemName;

  var artistName = artists.get(0).get('name');
  if (!artistName) return itemName;

  return separateDragTextItems(artistName, itemName);
}

/**
 * Get the text for a playlist URI.
 *
 * Examples:
 * Playlist Name – Owner Name
 * Playlist Name – owner_username
 * Playlist Name
 *
 * @param {string} uri Playlist URI.
 *
 * @return {string} The text.
 */
function getForPlaylist(uri) {
  var object = live(uri);
  var itemName = object.get('name');
  if (!itemName) return '';

  var owner = object.get('owner');
  var ownerName = owner && (owner.get('name') || owner.get('username'));
  if (!ownerName) return itemName;

  return separateDragTextItems(itemName, ownerName);
}

/**
 * Get the text for a playlist URI.
 *
 * Examples:
 * User Name
 * username
 *
 * @param {string} uri Playlist URI.
 *
 * @return {string} The text.
 */
function getForUser(uri) {
  var object = live(uri);
  var itemName = object.get('name');
  if (itemName) return itemName;

  var uriObject = liburi.fromString(uri);
  var username = uriObject && uriObject.username;
  return username || '';
}

/**
 * Get the text for a folder URI.
 *
 * Examples:
 * Folder Name
 *
 * @param {string} uri Folder URI.
 *
 * @return {string} The text.
 */
function getForFolder(uri) {
  return live(uri).get('name');
}

/**
 * Get the text for a station URI.
 *
 * Examples:
 * Station Name
 *
 * @param {string} uri Station URI.
 *
 * @return {string} The text.
 */
function getForStation(uri) {
  return live(uri).get('name');
}

/**
 * Separate two strings by the special dash ('en dash', &#8211;) we use.
 *
 * @param {string} item1 First string.
 * @param {string} item2 Second string.
 *
 * @return {string} Final string.
 */
function separateDragTextItems(item1, item2) {
  return item1 + ' – ' + item2;
}

/**
 * Get the text for an element.
 *
 * @param {HTMLElement} target The target element being dragged.
 *
 * @return {string} The drag text.
 */
function getForElement(target) {
  var title = target.getAttribute('data-drag-text');
  if (title) return title;

  var uri = target.getAttribute('data-uri');
  if (uri) {
    title = getForUri(uri);
    if (title) return title;
  }

  title = target.getAttribute('title');
  if (title) return title;

  return target.textContent;
}

exports.getForUri = getForUri;
exports.getForElement = getForElement;

},{"../../../spotify-live":212,"spotify-liburi":398}],64:[function(require,module,exports){
'use strict';

var $ = require('../spotify-elements');
var live = require('../spotify-live');
var center = require('./center');
var stickyEvents = require('./sticky');
var cosmos = require('./util/cosmos');
var merge = require('mout/object/merge');
var deepEquals = require('mout/lang/deepEquals');
var getOriginUri = require('../spotify-live-wrapped-uri').getOriginUri;
var appUtil = require('./util/app');
var shuffleMode = require('../spotify-shuffle-mode');

var SCROLL_PADDING = 8;
var STRING_FILTER_KEY = 'list-filter-string-';
var SESSION_STORAGE = 'spotify:session-storage';

function update(node) {
  if (!isAttached) return;

  node = $(node) || $(document);
  var nodes = node.matches('[data-filter]') ? [node[0]] : node.search('[data-filter]');
  if (!nodes) return;
  nodes.forEach(function (node) {
    var uri = getURI(node);
    if (!uri) return;

    // When no state is initialized for the uri, initialize it and set the string from the DOM.
    // This is the case when the playlist app loaded a URI that globally has a filter string set.
    var hasState = states[uri];
    if (!hasState) {
      var inputElement = $(node).find('input[type=text]')[0];
      var value = inputElement.value;
      if (value) {
        updateState(uri, {
          activated: true,
          enteredString: value
        });
      }
    }

    handleStale(uri);
  });
}

function handleStale(uri) {
  render(uri);
  logUsage(uri);

  var state = getState(uri);
  var stateHasBeenEmitted = deepEquals(state, lastEmittedStates[uri]);
  if (!stateHasBeenEmitted) {
    lastEmittedStates[uri] = state;
    var value = state.activated ? state.enteredString : '';
    emitFilterRequest(uri, value);
    persistFilterOnSessionStorage(uri, value);
  }
}

function render(uri) {
  var $candidateContainers = $(document).search('[data-uri] [data-filter]');
  if (!$candidateContainers) return;

  var $matchingCandidates = $candidateContainers.filter(function (container) {
    return getURI(container) === uri;
  });
  $matchingCandidates.forEach(function (mainElement) {
    var state = getState(uri);
    var inputElement = $(mainElement).find('input[type=text]')[0];
    var wrapperElement = $(mainElement).find('.h-search-wrapper')[0];
    if (state.activated) {
      if (!$(wrapperElement).hasClass('focus')) {
        $(wrapperElement).addClass('focus');

        mainElement.setAttribute('data-sticky', '');
        stickyEvents.update();
      }

      // NOTE: Setting input.value makes the cursor jump
      // which is annoying when changing typos in the
      // search field. Only set value if text ACTUALLY
      // changes:
      if (inputElement.value !== state.enteredString) {
        inputElement.value = state.enteredString;
      }
    } else {
      inputElement.blur();
      if ($(wrapperElement).hasClass('focus')) {
        $(wrapperElement).removeClass('focus');

        mainElement.removeAttribute('data-sticky');
        stickyEvents.update();
      }
      inputElement.value = '';
    }
  });
}

function focusAndSelectInput(inputElement) {

  // Only focus and select the input text if doesn't have focus already.
  if (document.activeElement != inputElement) {
    inputElement.focus();
    inputElement.select();
  }
}

function scrollIntoView(inputElement) {
  var rect = inputElement.getBoundingClientRect();

  // [SHUFFLE]
  // If sticky header is displayed, let's compensate scroll position with header's height
  // (otherwise the focused filter input might end up under the sticky header)
  var stickyHeaderOffset = 0;
  if (shuffleMode.isEnabled()) {
    var stickyHeader = $('.h-sticky-header [data-sticky-active]');
    if (stickyHeader) {
      stickyHeaderOffset = stickyHeader[0].offsetHeight;
    }
  }

  // Only scroll if the input is out of view
  var filterFieldOffset = rect.top - SCROLL_PADDING - stickyHeaderOffset;
  if (filterFieldOffset < 0 || rect.bottom > window.innerHeight) {
    window.scrollTo(0, window.pageYOffset + filterFieldOffset);
  }
}

function logUsage(uri) {
  var state = getState(uri);
  if (state.enteredString && !getState(uri).usageLogged) {
    updateState(uri, { usageLogged: true });
    // Fields must be in the same order as in logparser
    // AND all fields MUST be present or logging wont happen
    // and will fail silently. https://ghe.spotify.net/datainfra/log-parser/blob/94e6a896efa5d781b0cac54f3dcf92c9c4ee3c73/spotify/log_parser/messages_specs.py#L777

    cosmos.post({
      url: 'sp://logging/v1/log',
      body: {
        'message': 'ClientEvent',
        'version': 3,
        'fields': [window.__spotify.app_uri, // source
        'spotify-events-filter', // context
        'user:typing', // event
        'input-field', // event-version
        '', // test-version
        '', // source-version
        '', // source-vendor
        '' // json-data
        ]
      }
    });
  }
}

function emitFilterRequest(uri, value) {
  center.emit('filter-request', uri, value);
}

function persistFilterOnSessionStorage(uri, value) {
  uri = getOriginUri(uri) || uri;

  var key = STRING_FILTER_KEY + uri;
  var publish = {};
  publish[key] = value;
  live(SESSION_STORAGE).publish(publish);
}

function handleCancelClick(e) {
  clear(getURI(e.target));
}

function handleInputInput(e) {
  updateState(getURI(e.target), { enteredString: e.target.value });
}

function handleInputKeyup(e) {
  var isEscape = e.keyCode === 27;
  if (isEscape) clear(getURI(e.target));
}

function handleInputFocus(e) {
  updateState(getURI(e.target), { activated: true });
}
function handleInputFocusOut(e) {
  var state = getState(getURI(e.target));
  if (state.enteredString === '') updateState(getURI(e.target), { activated: false });
}

function clear(uri) {
  updateState(uri, { activated: false, enteredString: '' });
}

function getState(uri) {
  return states[uri] || {
    activated: false,
    enteredString: ''
  };
}

function updateState(uri, update) {
  states[uri] = merge(getState(uri), update);
  handleStale(uri);
}

function getURI(element) {
  var uri = element.getAttribute('data-uri');
  if (!uri) {
    var parents = $(element).parents('[data-uri]');
    if (parents) uri = parents[0].getAttribute('data-uri');
  }
  uri = getOriginUri(uri) || uri;

  // We use the data-uri as a key for state, but the uri of the
  // container might change to the "sorted" versions of the
  // original uri. From a filter UX state standpoint, these are the
  // same, so we normalize it here.
  return uri || null;
}

var states;
var lastEmittedStates;

var isAttached = false;
var controlMessageSubscription;
var attach = function attach() {
  if (isAttached) return;
  isAttached = true;
  states = {};
  lastEmittedStates = {};
  controlMessageSubscription = cosmos.subscribe({
    url: 'sp://messages/v1/container/control'
  }, function (_, response) {
    if (!appUtil.isActive()) return;

    var isMessageOfTypeFind = response && response.body && response.body.type === 'filter';
    if (!isMessageOfTypeFind) return;
    $('[data-filter]').forEach(function (mainElement, i) {
      updateState(getURI(mainElement), {
        activated: true
      });

      var inputElement = $(mainElement).find('input[type=text]')[0];
      if (inputElement) {

        // Only scroll first filter into view.
        if (i === 0) {
          scrollIntoView(inputElement);
        }

        focusAndSelectInput(inputElement);
      }
    });
  });

  center.on('filter-reset', clear);

  $(document).delegate('click', '[data-filter] .h-search-close', handleCancelClick);
  $(document).delegate('click', '[data-filter-reset]', handleCancelClick);
  $(document).delegate('input', '[data-filter] input', handleInputInput);
  $(document).delegate('keyup', '[data-filter] input', handleInputKeyup);
  $(document).delegate('focusin', '[data-filter] input', handleInputFocus);
  $(document).delegate('focusout', '[data-filter] input', handleInputFocusOut);
};

var detach = function detach() {
  if (!isAttached) return;
  states = null;
  controlMessageSubscription.cancel();

  center.off('filter-reset', clear);

  $(document).undelegate('click', '[data-filter] .h-search-close', handleCancelClick);
  $(document).undelegate('click', '[data-filter-reset]', handleCancelClick);
  $(document).undelegate('input', '[data-filter] input', handleInputInput);
  $(document).undelegate('keyup', '[data-filter] input', handleInputKeyup);
  $(document).undelegate('focusin', '[data-filter] input', handleInputFocus);
  $(document).undelegate('focusout', '[data-filter] input', handleInputFocusOut);
  isAttached = false;
};

// Tells native container that the current app can handle filter
// commands. Enables filter commands in the native menu,
// along with corresponding keyboard shortcuts.
var broadcast = function broadcast(enabled) {
  if (enabled === undefined) throw new Error('broadcast requires enabled argument');
  cosmos.post({
    url: 'sp://messages/v1/container/control',
    body: {
      type: 'update_menu_state',
      enable_filter_item: enabled
    }
  });
};

module.exports = {
  attach: attach,
  detach: detach,
  update: update,
  broadcast: broadcast
};

},{"../spotify-elements":45,"../spotify-live":212,"../spotify-live-wrapped-uri":211,"../spotify-shuffle-mode":252,"./center":52,"./sticky":95,"./util/app":102,"./util/cosmos":103,"mout/lang/deepEquals":344,"mout/object/merge":363}],65:[function(require,module,exports){
'use strict';

var modules = [require('./anchor'), require('./player'), require('./dragndrop'), require('./add'), require('./selection'), require('./contextmenu'), require('./navbar'), require('./offline'), require('./sticky'), require('./filter'), require('./watch'), require('./tooltip'), require('./list'), require('./menu'), require('./scroll'), require('./carousel'), require('./scrollbar'), require('./slider'), require('./select'), require('./sort'), require('./shuffle'), require('./thumbs'), require('./touch-mediaobjects'), require('./list-quick-jump')];

var events = {};

var isAttached = false;

events.update = function update(node) {
  if (!isAttached) return;

  modules.forEach(function (module) {
    module.update(node);
  });
};

events.attach = function attach() {
  if (isAttached) return;
  isAttached = true;

  modules.forEach(function (module) {
    module.attach();
  });
};

events.detach = function detach() {
  if (!isAttached) return;
  isAttached = false;

  modules.forEach(function (module) {
    module.detach();
  });
};

module.exports = events;

},{"./add":49,"./anchor":50,"./carousel":51,"./contextmenu":53,"./dragndrop":58,"./filter":64,"./list":67,"./list-quick-jump":66,"./menu":68,"./navbar":69,"./offline":70,"./player":72,"./scroll":77,"./scrollbar":82,"./select":85,"./selection":88,"./shuffle":92,"./slider":93,"./sort":94,"./sticky":95,"./thumbs":97,"./tooltip":98,"./touch-mediaobjects":99,"./watch":107}],66:[function(require,module,exports){
(function (global){
'use strict';

var center = require('./center');
var cosmos = require('./util/cosmos');
var ClientEvent3 = require('../spotify-logger/messages/ClientEvent3');

var SPACE_KEYCODE = 32;
var BACKSPACE_KEYCODE = 8;
var DELETE_KEYCODE = 46;

exports.attach = function attach() {
  document.addEventListener('keypress', onKeyPress, false);
  document.addEventListener('keydown', onKeyDown, false);
};

exports.detach = function detach() {
  document.removeEventListener('keypress', onKeyPress, false);
  document.removeEventListener('keydown', onKeyDown, false);
};

exports.update = function () {};

var selector = ':not([data-sticky-active]) > [data-list-quick-jump]';
var SEARCH_STRING_CONCATENATION_TIMEOUT = 1000;

var searchStringsByUri = {};
var searchTimeoutsByUri = {};
var searchTimestampsByUri = {};

// onKeyPress is needed to read characters properly
function onKeyPress(event) {
  if (shouldEventBeIgnored(event)) return;
  processEvent(event);
}

// onKeyDown is needed to read <backspace>
function onKeyDown(event) {
  if (shouldEventBeIgnored(event)) return;

  var isBackspace = event.keyCode === BACKSPACE_KEYCODE;

  if (!isBackspace) return;
  processEvent(event);
}

function processEvent(event) {
  var isBackspace = event.keyCode === BACKSPACE_KEYCODE;

  var letter = event.keyCode === SPACE_KEYCODE ? ' ' : String.fromCharCode(event.keyCode).trim();
  if (!letter && !isBackspace) return;

  var listNode = getListNode(event.target);
  if (!listNode) return;

  var uri = getUri(listNode);
  if (!uri) return;

  // No need to do anything if there is no active search and user presses
  // BACKSPACE, since that would temporarily disable using SPACE for toggling
  // music, even though no quick-jump was actually made (KM-10204)
  if (isBackspace && !searchStringsByUri[uri]) return;

  if (!(uri in searchStringsByUri)) searchStringsByUri[uri] = '';

  if (isBackspace) {
    searchStringsByUri[uri] = searchStringsByUri[uri].slice(0, -1);
  } else if (letter) {
    searchStringsByUri[uri] += letter;
  }

  center.emit('list-quick-jump-request', uri, searchStringsByUri[uri] || null);

  if (searchTimeoutsByUri[uri]) clearTimeout(searchTimeoutsByUri[uri]);

  if (event.keyCode === SPACE_KEYCODE) {
    event.preventDefault(); // Prevent space from scrolling page
  }

  var shortcutsToIgnore = [{ keyCode: SPACE_KEYCODE }, { keyCode: BACKSPACE_KEYCODE }, { keyCode: DELETE_KEYCODE }];

  // Tell container to ignore <space>, <backspace> and <delete> shortcuts
  // until further notice
  cosmos.post({
    url: 'sp://messages/v1/ignoreshortcuts',
    body: {
      action: 'ignore',
      shortcuts: shortcutsToIgnore
    }
  });

  searchTimeoutsByUri[uri] = setTimeout(function () {
    // Tell container to stop ignoring <space>, <backspace> and <delete>
    // shortcuts
    cosmos.post({
      url: 'sp://messages/v1/ignoreshortcuts',
      body: {
        action: 'unignore',
        shortcuts: shortcutsToIgnore
      }
    });

    delete searchStringsByUri[uri];
    delete searchTimeoutsByUri[uri];
    delete searchTimestampsByUri[uri];
    center.emit('list-quick-jump-request', uri, null);
  }, SEARCH_STRING_CONCATENATION_TIMEOUT);

  if (searchStringsByUri[uri].length <= 20) {
    var timeSinceLastLetter = Date.now() - searchTimestampsByUri[uri] || null;
    ClientEvent3.log({
      source: global.__spotify && global.__spotify.app_uri || null,
      context: uri,
      event_version: 'list-quick-jump',
      event: 'user:type',
      json_data: {
        str: searchStringsByUri[uri],
        letter: letter,
        was_backspace: isBackspace,
        time_since_last_letter: timeSinceLastLetter
      }
    });
  }

  searchTimestampsByUri[uri] = Date.now();
}

function shouldEventBeIgnored(event) {
  return event.metaKey || event.ctrlKey || event.target.matches('input, textarea, [contenteditable]');
}

function getListNode(target) {
  var listNode = target.closest(selector);
  if (!listNode) {
    var listNodes = document.querySelectorAll(selector);
    var hasOnlyOneListNode = listNodes && listNodes.length === 1;

    if (hasOnlyOneListNode) {
      listNode = listNodes[0];
    }
  }
  return listNode;
}

function getUri(listNode) {
  var uriParent = listNode.closest('[data-uri]');
  return uriParent && uriParent.getAttribute('data-uri');
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-logger/messages/ClientEvent3":222,"./center":52,"./util/cosmos":103}],67:[function(require,module,exports){
(function (global){
'use strict';

var $ = require('../spotify-elements');
var live = require('../spotify-live');
var center = require('./center');
var selection = require('./selection');
var cosmos = require('./util/cosmos');
var appUtil = require('./util/app');

var ROW_SELECTOR = '[data-list-item]';
var UNAVAILABLE_CLASS_NAME = 'unavailable';
var OFFLINE_DOWNLOADED_CLASS_NAME = 'offline-downloaded';
var OFFLINE_DOWNLOADING_CLASS_NAME = 'offline-downloading';
var OFFLINE_WAITING_CLASS_NAME = 'offline-waiting';

var storedTrackURIsForUnplayable = {};
var storedTrackURIsForOffline = {};

function updatePlayabilityForRows(uri, playable) {
  var rows = $(document).search(ROW_SELECTOR + '[data-uri="' + uri + '"]');
  if (rows) {
    updatePlayabilityForElements(rows, playable);
  }
}

function updatePlayabilityForElements(elements, playable) {
  if (playable) {
    elements.removeClass(UNAVAILABLE_CLASS_NAME);
  } else {
    elements.addClass(UNAVAILABLE_CLASS_NAME);
  }
}

function updateOfflineForRows(uri, shouldBeOffline, offlineProgress) {
  var rows = $(document).search(ROW_SELECTOR + '[data-uri="' + uri + '"]');
  if (rows) {

    // This will take an elements object as the first argument, so it can contain multiple rows
    updateOfflineForElements(rows, shouldBeOffline, offlineProgress);
  }
}

function updateOfflineForElements(elements, shouldBeOffline, offlineProgress) {

  // The track is either already downloaded or will be soon
  if (shouldBeOffline) {

    // Download done
    if (offlineProgress === 1) {
      elements.addClass(OFFLINE_DOWNLOADED_CLASS_NAME);
      elements.removeClass(OFFLINE_DOWNLOADING_CLASS_NAME);
      elements.removeClass(OFFLINE_WAITING_CLASS_NAME);

      // Waiting to be downloaded
    } else if (offlineProgress === 0) {
        elements.addClass(OFFLINE_WAITING_CLASS_NAME);
        elements.removeClass(OFFLINE_DOWNLOADED_CLASS_NAME);
        elements.removeClass(OFFLINE_DOWNLOADING_CLASS_NAME);

        // Downloading at the moment
      } else {
          elements.addClass(OFFLINE_DOWNLOADING_CLASS_NAME);
          elements.removeClass(OFFLINE_DOWNLOADED_CLASS_NAME);
          elements.removeClass(OFFLINE_WAITING_CLASS_NAME);
        }

    // The track is not supposed to be downloaded offline
  } else {
      elements.removeClass(OFFLINE_DOWNLOADED_CLASS_NAME);
      elements.removeClass(OFFLINE_DOWNLOADING_CLASS_NAME);
      elements.removeClass(OFFLINE_WAITING_CLASS_NAME);
    }
}

function updateUnplayableRows(node, opt_rows) {
  var rows = opt_rows || ($(node) || $(document)).search(ROW_SELECTOR);
  if (rows) {
    rows.forEach(function (row) {
      var uri = $(row).data('uri');

      var model = live(uri);
      var playable = model.get('playable');

      if (playable !== undefined) {
        updatePlayabilityForElements($(row), playable);
      }

      if (uri in storedTrackURIsForUnplayable) return;
      storedTrackURIsForUnplayable[uri] = true;

      model.on('update', function (properties) {
        if ('playable' in properties) {
          updatePlayabilityForRows(uri, properties.playable);
        }
      });
    });
  }
}

function updateOfflineSyncing(node, opt_rows) {
  var rows = opt_rows || ($(node) || $(document)).search(ROW_SELECTOR);
  if (rows) {
    rows.forEach(function (row) {
      var uri = $(row).data('uri');
      var model = live(uri);

      // Try to query the data sync if possible (live.ASAP), to try to set the
      // class names before adding the rows to the DOM (by the scroller), to
      // avoid flickering.
      model.query('shouldBeOffline, offlineProgress', function (error, data) {
        if (error) throw error;
        updateOfflineForElements($(row), data.shouldBeOffline, data.offlineProgress);

        if (uri in storedTrackURIsForOffline) return;
        storedTrackURIsForOffline[uri] = true;

        model.on('update', function (properties) {
          if ('shouldBeOffline' in properties || 'offlineProgress' in properties) {
            updateOfflineForRows(uri, model.get('shouldBeOffline'), model.get('offlineProgress'));
          }
        });
      }, live.ASAP);
    });
  }
}

function handleKeyDown(event) {
  if (!event.target.closest(ROW_SELECTOR) || ignoredShortcuts[JSON.stringify({ keyCode: event.keyCode })]) return;

  var shouldRemove = false;
  var isWindows = /Win/.test(global.window.navigator.userAgent);

  var isBackspace = event.keyCode === 8;
  var isDelete = event.keyCode === 46;

  if (isWindows) {
    shouldRemove = isDelete;
  } else {
    shouldRemove = isBackspace || isDelete;
  }

  if (shouldRemove) {
    removeCurrentlySelectedListItems();
  }
}

function removeCurrentlySelectedListItems() {
  var lists = selection.getIndicesPerList();
  if (lists.length > 0) {
    var firstContainerIndex = null;
    var firstIndex = null;
    lists.forEach(function (list) {
      // Delete from origin list where applicable
      // TODO: We could just remove from the list directly, without going
      // through the origin list. Removing from a sorted list will pass
      // the change on to the origin list automatically.
      if (list.origin) {
        list = list.origin;
      }
      var model = live(list.uri);

      var indices = list.indices.sort(function (a, b) {
        return a - b;
      });

      model.query('allows(removeTracks)', function (error, data) {
        if (error) throw error;
        if (!data.allows.removeTracks) return;

        model.get('rows', function (error, liveList) {
          if (error) throw error;
          var operations = indices.map(function (index, indexInArray) {
            return { type: 'remove', index: index - indexInArray, length: 1 };
          });
          liveList.publish(operations);

          if (firstIndex === null) {
            firstIndex = indices[0];
            firstContainerIndex = list.containerIndex;
          }
        });
      });
    });
  }
}

function handleScrollShow(data) {
  updateUnplayableRows(data.container, data.nodes);
  updateOfflineSyncing(data.container, data.nodes);
}

// Exported for testing
exports._classNames = {
  UNAVAILABLE: UNAVAILABLE_CLASS_NAME,
  OFFLINE_WAITING: OFFLINE_WAITING_CLASS_NAME,
  OFFLINE_DOWNLOADING: OFFLINE_DOWNLOADING_CLASS_NAME,
  OFFLINE_DOWNLOADED: OFFLINE_DOWNLOADED_CLASS_NAME
};

var isAttached = false;

exports.update = function update(node) {
  if (!isAttached) return;

  updateUnplayableRows(node);
  updateOfflineSyncing(node);
};

var doc = $(document);
var deleteSubscription;
var ignoredShortcutsSubscription;
var ignoredShortcuts = {};
exports.attach = function () {
  if (isAttached) return;
  isAttached = true;

  doc.on('keydown', handleKeyDown);
  center.on('scroll-show-before', handleScrollShow);

  deleteSubscription = cosmos.subscribe({ url: 'sp://messages/v1/container/control' }, function (error, response) {
    if (error) throw error;
    var data = response.body;
    if (data && data.type === 'delete' && appUtil.isActiveAndFocused()) {
      removeCurrentlySelectedListItems();
    }
  });

  ignoredShortcutsSubscription = cosmos.subscribe({
    url: 'sp://messages/v1/ignoreshortcuts'
  }, function (error, response) {
    if (response.body.action === 'ignore') {
      response.body.shortcuts.forEach(function (shortcut) {
        ignoredShortcuts[JSON.stringify(shortcut)] = 1;
      });
    } else if (response.body.action === 'unignore') {
      response.body.shortcuts.forEach(function (shortcut) {
        delete ignoredShortcuts[JSON.stringify(shortcut)];
      });
    }
  });
};
exports.detach = function () {
  if (!isAttached) return;
  isAttached = false;

  doc.off('keydown', handleKeyDown);
  center.off('scroll-show-before', handleScrollShow);

  if (deleteSubscription) {
    deleteSubscription.cancel();
    deleteSubscription = null;
  }
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-elements":45,"../spotify-live":212,"./center":52,"./selection":88,"./util/app":102,"./util/cosmos":103}],68:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.attach = attach;
exports.detach = detach;
exports.update = update;

var _throttle = require('./util/throttle');

var _throttle2 = _interopRequireDefault(_throttle);

var _center = require('./center');

var _center2 = _interopRequireDefault(_center);

var _spotifyNavigation = require('../spotify-navigation');

var _spotifyNavigation2 = _interopRequireDefault(_spotifyNavigation);

var _appState = require('../spotify-navigation/app-state');

var _appState2 = _interopRequireDefault(_appState);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SELECTOR_MENU = '[data-menu]';
var SELECTOR_MENU_ITEM = '[data-menu-item]';
var SELECTOR_MENU_ITEM_DISABLED = '[data-menu-item-disabled]';
var SELECTOR_MENU_ITEM_ENABLED = '[data-menu-item]:not([data-menu-item-disabled])';
var ATTRIBUTE_MENU = 'data-menu';
var ATTRIBUTE_MENU_ITEM = 'data-menu-item';
var CLASS_SUBMENU = '.dropdown-submenu';
var CLASS_MENU = '.dropdown-menu';

var navigator = new _spotifyNavigation2.default.Navigator();

var isAttached = false;

// The state will take the following shape (a nested structure that can be any
// number of levels deep):
// {
//   menu: { // null if root menu is not open
//     node: menuNode,
//     selectedNode: menuItemNode, // or null
//     menu: { // null if a sub menu is not open
//       node: subMenuNode,
//       selectedNode: subMenuItemNode, // or null,
//       menu: null, // null if a sub menu is not open
//       parent: <back-reference>, // a reference to the object one level up
//     },
//     parent: null, // always null for the root menu
//   }
// }
var state = {
  menu: null
};

/**
 * Handler for when an element gets focused.
 *
 * @param {FocusEvent} event A focus event.
 */
function onFocus(event) {
  var targetMenu = event.target.closest(SELECTOR_MENU);
  if (targetMenu && !state.menu) {
    state.menu = {
      node: targetMenu,
      selectedNode: null,
      menu: null,
      active: true,
      parent: null
    };

    targetMenu.addEventListener('mousemove', onMouseMoveThrottled);
    targetMenu.addEventListener('mouseleave', onMouseLeave);

    // We need to ensure that before triggering the "touchstart" event in the <LI> element
    // of the node, we emulate the mouse being moved over it. This way, the listeners are
    // attached and they will fire.
    // Note: this "mouseMove" call cannot be throttled, because the "touchstart" that will
    // trigger in the <LI> will happen before the throttler fires the event. Additionally,
    // there's no need to use the throttling logic for the touchstart event.
    targetMenu.addEventListener('touchstart', onMouseMove, true);
  }
}

/**
 * Handler for when an element loses focus.
 *
 * @param {FocusEvent} event A blur event.
 */
function onBlur(event) {
  var target = event.target;
  var relatedTarget = event.relatedTarget;


  if (state.menu && target === state.menu.node) {
    // A blur on the menu (target) can mean an element inside of it gains focus.
    // No need to reset then.
    if (!relatedTarget || !target.contains(relatedTarget)) {
      hideMenu();
    }
  }
}

/**
 * Handler for when a key is pressed.
 *
 * @param {KeyboardEvent} event A keyboard event.
 */
function onKeyDown(event) {
  // Only act on events when a menu is open
  if (!state.menu) {
    return;
  }

  var keyCode = event.keyCode;
  var isEnter = keyCode === 13;
  var isEscape = keyCode === 27;
  var isUp = keyCode === 38;
  var isDown = keyCode === 40;
  var isLeft = keyCode === 37;
  var isRight = keyCode === 39;

  if (isEnter) {
    // Look for links to follow inside the current menu item.
    var activeMenuState = getStateForActiveMenu();
    var selectedMenuItem = activeMenuState.selectedNode;
    var link = selectedMenuItem && selectedMenuItem.querySelector('a[href]');
    if (link) {
      navigator.requestOpenState(new _appState2.default(link.getAttribute('href')));
    }
    emitActivateItemEvent(selectedMenuItem);
    return;
  }

  if (isEscape) {
    hideMenu();
    return;
  }

  if (isUp || isDown) {
    var _activeMenuState = getStateForActiveMenu();
    if (_activeMenuState.node) {
      var newActiveMenuItem = isDown ? getMenuItemBelow(_activeMenuState) : getMenuItemAbove(_activeMenuState);

      if (newActiveMenuItem) {
        selectItemInMenu(_activeMenuState, _activeMenuState, newActiveMenuItem);
      }
    }
    return;
  }

  if (isRight) {
    var _activeMenuState2 = getStateForActiveMenu();
    if (_activeMenuState2.selectedNode) {
      if (_activeMenuState2.selectedNode.matches(CLASS_SUBMENU)) {

        // Open the sub menu if not open already (might have been opened by the
        // mouse cursor)
        if (!_activeMenuState2.menu) {
          openSubMenu(_activeMenuState2, _activeMenuState2.selectedNode);
        }

        // Select the first item in the sub menu
        var subMenuNode = _activeMenuState2.menu.node;
        var firstItemInSubMenu =
        // We'd like to get firstElementChild to avoid text nodes, but since
        // JSDom doesn't support that, fall back to firstChild for tests.
        subMenuNode.firstElementChild || subMenuNode.firstChild;
        selectItemInMenu(_activeMenuState2, _activeMenuState2.menu, firstItemInSubMenu);
      }
    }
    return;
  }

  if (isLeft) {
    var _activeMenuState3 = getStateForActiveMenu();
    if (_activeMenuState3.parent) {
      closeSubMenuOf(_activeMenuState3.parent);
    }
    return;
  }
}

/**
 * Handler for when the mouse is moved over a menu.
 * This is only attached for the current menu (if there is a current menu).
 *
 * @param {MouseEvent} event A mouse event.
 */
function onMouseMove(event) {
  var isMenu = event.target.matches(CLASS_MENU);
  if (isMenu) {
    return;
  }

  var targetItem = event.target.closest(SELECTOR_MENU_ITEM);
  if (!targetItem) {
    return;
  }

  var targetMenu = targetItem.closest(CLASS_MENU);
  var targetMenuState = getStateForMenu(targetMenu);
  var activeMenuState = getStateForActiveMenu();

  if (targetItem === activeMenuState.selectedNode) {
    return;
  }

  if (targetItem.matches(SELECTOR_MENU_ITEM_DISABLED)) {
    deselectItemInMenu(activeMenuState);
  } else {
    selectItemInMenu(activeMenuState, targetMenuState, targetItem);
    activeMenuState = getStateForActiveMenu();
  }

  // When hovering over an item that has a sub menu, open the sub menu if not
  // open already.
  if (targetItem.matches(CLASS_SUBMENU)) {
    if (!targetMenuState.menu) {
      openSubMenu(targetMenuState, targetItem);
    }

    // When hovering over a regular item and a sub menu is currently shown, close
    // the sub menu.
  } else if (activeMenuState.menu) {
      closeSubMenuOf(activeMenuState);
    }
}
var onMouseMoveThrottled = (0, _throttle2.default)(onMouseMove);

/**
 * Handler for when the mouse leaves a menu.
 * This is only attached for the current menu (if there is a current menu).
 *
 * @param {MouseEvent} event A mouse event.
 */
function onMouseLeave(event) {
  if (!event.relatedTarget || !event.relatedTarget.closest(SELECTOR_MENU)) {
    var activeMenuState = getStateForActiveMenu();
    deselectItemInMenu(activeMenuState);
    if (activeMenuState.menu) {
      closeSubMenuOf(activeMenuState);
    }
  }
}

/**
 * Handler for when the current menu item is clicked.
 * This is only attached for the current menu item (if there is one).
 *
 * @param {MouseEvent} event A mouse event.
 */
function onItemClick(event) {
  var targetMenu = event.target.closest(CLASS_MENU);
  var targetMenuState = getStateForMenu(targetMenu);
  var itemNode = targetMenuState.selectedNode;

  emitActivateItemEvent(itemNode);
}

/**
 * In order to prevent the simulated click event when using a touchscreen,
 * we prevent default so click won't trigger. That click event would otherwise
 * trigger a click on the layer beneath since the menu is closed after activating an item.
 *
 * @param {TouchEvent} event a Touch event.
 */
function onItemTouchStart(event) {
  event.preventDefault();
  onItemClick(event);
}

/**
 * Emit a center event to activate the current item.
 *
 * @param {HTMLElement} itemNode HTML element for the item.
 */
function emitActivateItemEvent(itemNode) {
  _center2.default.emit('menu-activate-item', {
    menu: {
      id: state.menu.node.getAttribute(ATTRIBUTE_MENU) || '',
      element: state.menu.node
    },
    item: {
      id: itemNode.getAttribute(ATTRIBUTE_MENU_ITEM) || '',
      element: itemNode
    }
  });
}

/**
 * Set the current menu item to a new item.
 *
 * @param {Object} activeMenuState Menu state object for the currently active
 *   menu.
 * @param {Object} targetMenuState Menu state object for the menu where the item
 *   that is to be selected is located.
 * @param {HTMLElement} itemNode An HTML element for the menu item.
 */
function selectItemInMenu(activeMenuState, targetMenuState, itemNode) {
  var isTargetSubMenu = activeMenuState.menu === targetMenuState;
  var isTargetParentMenu = isSecondContainedInFirst(targetMenuState, activeMenuState);

  // If the item is in a sub menu we only want to remove any item event
  // listeners. Removing visual selection should only happen when moving within
  // the same menu.
  if (isTargetSubMenu) {
    removeItemListeners(activeMenuState.selectedNode);
  } else {
    deselectItemInMenu(activeMenuState);
  }

  // Deselect the currently selected item in parent menu, if moving from sub
  // menu to the parent menu.
  if (isTargetParentMenu) {
    deselectItemInMenu(targetMenuState);
  }

  activeMenuState.active = false;

  if (targetMenuState.selectedNode !== itemNode) {
    itemNode.classList.add('selected');
    addItemListeners(itemNode);
    targetMenuState.selectedNode = itemNode;
  }

  targetMenuState.active = true;
}

/**
 * Deselect any selected item in the menu represented by the passed state.
 *
 * @param {Object} menuState The menu state object.
 */
function deselectItemInMenu(menuState) {
  if (menuState.selectedNode) {
    var itemNode = menuState.selectedNode;
    itemNode.classList.remove('selected');
    removeItemListeners(itemNode);
    menuState.selectedNode = null;
  }
}

/**
 * Add the click listeners from an item node.
 *
 * @param {HTMLElement} itemNode An HTML element for the menu item.
 */
function addItemListeners(itemNode) {
  itemNode.addEventListener('click', onItemClick);
  itemNode.addEventListener('touchstart', onItemTouchStart);
}

/**
 * Remove the click listeners from an item node.
 *
 * @param {HTMLElement} itemNode An HTML element for the menu item.
 */
function removeItemListeners(itemNode) {
  itemNode.removeEventListener('click', onItemClick);
  itemNode.removeEventListener('touchstart', onItemTouchStart);
}

/**
 * Open a sub menu for the provided menu state object and item node.
 *
 * @param {Object} menuState The menu state object for the parent menu.
 * @param {HTMLElement} itemNode An HTML element for the menu item.
 */
function openSubMenu(menuState, itemNode) {
  var menuNode = itemNode.querySelector(CLASS_MENU);
  if (menuNode) {
    menuState.menu = {
      parent: menuState,
      node: menuNode,
      selectedNode: null,
      menu: null,
      active: false
    };
    menuNode.classList.add('open');
  }
}

/**
 * Close all sub menus for the provided menu state object.
 *
 * @param {Object} menuState The menu state object for the parent menu.
 */
function closeSubMenuOf(menuState) {
  // Close deeper sub menus first
  if (menuState.menu.menu) {
    closeSubMenuOf(menuState.menu);
  }

  if (menuState.menu.active) {
    menuState.menu.active = false;
    menuState.active = true;
  }

  deselectItemInMenu(menuState.menu);
  menuState.menu.node.classList.remove('open');
  menuState.menu = null;
}

/**
 * Hide the current menu by broadcasting a message via center.
 * A listener can be added via center and the handler will then really hide it.
 *
 * @example
 * center.on('menu-hide', function(event) {
 *   if (event.menu.id === 'profile-menu') {
 *     hideProfileMenu();
 *   }
 * });
 */
function hideMenu() {
  if (state.menu) {
    var menuNode = state.menu.node;

    menuNode.removeEventListener('mousemove', onMouseMoveThrottled);
    menuNode.removeEventListener('mouseleave', onMouseLeave);
    menuNode.removeEventListener('touchstart', onMouseMove, true);

    // Remove any sub menus
    var menuState = state.menu;
    while (menuState) {
      deselectItemInMenu(menuState);
      menuState.node.classList.remove('open');
      menuState = menuState.menu;
    }

    delete state.menu;

    _center2.default.emit('menu-hide', {
      menu: {
        id: menuNode.getAttribute(ATTRIBUTE_MENU) || '',
        element: menuNode
      }
    });
  }
}

/**
 * Test if the second menu state object is contained in the second state object.
 *
 * @param {Object} first Menu state object.
 * @param {Object} second Menu state object.
 *
 * @return {Boolean}        True if it is.
 */
function isSecondContainedInFirst(first, second) {
  var statePart = first.menu;
  while (statePart && statePart !== second) {
    statePart = statePart.menu;
  }

  return !!statePart;
}

/**
 * Get the menu state object for the provided menu node. This assumes the node
 * is part of the state tree.
 *
 * @param {HTMLElement} menuNode The menu element.
 *
 * @return {Object} Menu state object.
 */
function getStateForMenu(menuNode) {
  var statePart = state.menu;
  while (statePart && statePart.node !== menuNode) {
    statePart = statePart.menu;
  }

  return statePart;
}

/**
 * Get the menu state object for the currently active menu.
 *
 * @return {Object} Menu state object.
 */
function getStateForActiveMenu() {
  var statePart = state.menu;
  while (statePart && !statePart.active) {
    statePart = statePart.menu;
  }

  return statePart;
}

/**
 * Find the menu item that is below the current one.
 * This will skip disabled menu items as well as any elements that are not
 * defined as menu items. If there is no menu item below the current one,
 * this will return null.
 *
 * @param {Object} activeMenuState Menu state object for the currently active
 *   menu.
 *
 * @return {HTMLElement?} The HTML element for the menu item, or null.
 */
function getMenuItemBelow(activeMenuState) {
  if (!activeMenuState.selectedNode) {
    return activeMenuState.node.querySelector(SELECTOR_MENU_ITEM_ENABLED);
  }

  var item = activeMenuState.selectedNode.nextElementSibling;
  while (item) {
    var isMenuItem = item.matches(SELECTOR_MENU_ITEM);
    var isDisabled = item.matches(SELECTOR_MENU_ITEM_DISABLED);
    if (isMenuItem && !isDisabled) {
      break;
    }
    item = item.nextElementSibling;
  }

  return item;
}

/**
 * Find the menu item that is above the current one.
 * This will skip disabled menu items as well as any elements that are not
 * defined as menu items. If there is no menu item above the current one,
 * this will return null.
 *
 * @param {Object} activeMenuState Menu state object for the currently active
 *   menu.
 *
 * @return {HTMLElement?} The HTML element for the menu item, or null.
 */
function getMenuItemAbove(activeMenuState) {
  if (!activeMenuState.selectedNode) {
    var results = activeMenuState.node.querySelectorAll(SELECTOR_MENU_ITEM_ENABLED);
    return results[results.length - 1] || null;
  }

  var item = activeMenuState.selectedNode.previousElementSibling;
  while (item) {
    var isMenuItem = item.matches(SELECTOR_MENU_ITEM);
    var isDisabled = item.matches(SELECTOR_MENU_ITEM_DISABLED);
    if (isMenuItem && !isDisabled) {
      break;
    }
    item = item.previousElementSibling;
  }

  return item;
}

/**
 * The spotify-events style attach function. Should be called once when DOM
 * is ready.
 */
function attach() {
  if (isAttached) return;
  isAttached = true;

  document.addEventListener('keydown', onKeyDown);

  // use capture to work around the non-bubbling events
  document.addEventListener('focus', onFocus, true);
  document.addEventListener('blur', onBlur, true);
}

/**
 * The spotify-events style detach function. Should be called when you no
 * longer need the events.
 */
function detach() {
  if (!isAttached) return;
  isAttached = false;

  state.menu = null;

  document.removeEventListener('keydown', onKeyDown);
  document.removeEventListener('focus', onFocus, true);
  document.removeEventListener('blur', onBlur, true);
}

/**
 * The spotify-events style update function. Should be called when DOM
 * changes.
 */
function update() {}

},{"../spotify-navigation":231,"../spotify-navigation/app-state":230,"./center":52,"./util/throttle":106}],69:[function(require,module,exports){
(function (global){
'use strict';

var $ = require('../spotify-elements');

var live = require('../spotify-live');
var center = require('./center');

var NAVBAR_ATTR_NAME = 'data-navbar';
var ITEM_ID_ATTR_NAME = 'data-navbar-item-id';
var ITEM_MATCHER_ATTR_NAME = 'data-navbar-item-matcher';
var VIEW_ID_ATTR_NAME = 'data-navbar-view-id';
var ACTIVE_ID_ATTR_NAME = 'data-navbar-active-id';
var HISTORY_POS_ATTR_NAME = 'data-navbar-history-position';
var CLASSNAME_ACTIVE = 'active';
var OVERFLOW_MENU_ID = 'navbar-overflow-menu';
var STICKY_WRAPPER_ATTR_NAME = 'data-sticky-fixed-wrapper';

var APPLICATION_MODEL_URI = 'spotify:application';

var isDesktop = !!global._getSpotifyModule;

var navbarOverflowItems;
var isShowingNavbarOverflow;
var shouldShowNavbarOverflow;

var getSelector = function getSelector(name, opt_operator, opt_matcher) {
  if (opt_operator && opt_matcher) return '[' + name + opt_operator + '"' + opt_matcher + '"' + ']';
  return '[' + name + ']';
};

var handleClick = function handleClick(event, tab) {
  var id = tab.getAttribute(ITEM_ID_ATTR_NAME);

  if (id === OVERFLOW_MENU_ID) {
    shouldShowNavbarOverflow = true;
    updateOverflowMenu();
    return;
  }

  activateItem(id);
  // Prevent any default click action (like link navigation)
  event.preventDefault();
};

var activateItem = function activateItem(id) {
  updateScrollPosition();

  var view = getView(id);
  var tabs = getTabsForId(id);

  // Set styles for navbar items and show/hide views
  setActive(id, tabs, view);
};

var onMessage = function onMessage(message) {
  if (message.data && message.data.name === 'navbar-overflow-click') {
    activateItem(message.data.itemId);
  }

  if (message.data && message.data.name === 'hide-navbar-overflow') {
    hideOverflow();
  }
};

var updateOverflowMenu = function updateOverflowMenu() {
  var moreMenuItem = document.querySelector('[data-navbar-item-id=navbar-overflow-menu]');
  if (!moreMenuItem) return;

  var canBeOpen = navbarOverflowItems && navbarOverflowItems.length;
  if (!canBeOpen) {
    shouldShowNavbarOverflow = false;
  }

  // There's no check for isShowingNavbarOverflow, the event is intentionally
  // resent on update, to support resizing.
  if (shouldShowNavbarOverflow) {
    isShowingNavbarOverflow = true;
    var descriptors = navbarOverflowItems.map(function (item) {
      var link = item.querySelector('a[href]');

      // The text is in the <a> element inside the item.
      return {
        name: item.firstElementChild && item.firstElementChild.textContent || '',
        id: item.getAttribute(ITEM_ID_ATTR_NAME),
        url: link && link.getAttribute('href'),
        active: item.classList.contains('active')
      };
    });

    var targetRect = moreMenuItem.getBoundingClientRect();
    global.top.postMessage({
      type: 'show-navbar-overflow',
      items: descriptors,
      right: targetRect.right,
      top: targetRect.bottom
    }, '*');
  }

  if (!shouldShowNavbarOverflow && isShowingNavbarOverflow) {
    isShowingNavbarOverflow = false;
    global.top.postMessage({
      type: 'hide-navbar-overflow'
    }, '*');
  }
};

var hideOverflow = function hideOverflow() {
  if (isShowingNavbarOverflow) {
    shouldShowNavbarOverflow = false;
    updateOverflowMenu();
  }
};

var getViews = function getViews() {
  var views = document.querySelectorAll(getSelector(VIEW_ID_ATTR_NAME));
  return Array.prototype.slice.call(views);
};

var getTabs = function getTabs() {
  var tabs = document.querySelectorAll(getSelector(ITEM_ID_ATTR_NAME));
  return Array.prototype.slice.call(tabs);
};

var getTabsForId = function getTabsForId(tabId) {
  if (!tabId) {
    return [];
  }
  // This is intentionally selecting on all of the document
  var tabs = document.querySelectorAll(getSelector(ITEM_ID_ATTR_NAME, '=', tabId));
  return Array.prototype.slice.call(tabs);
};

var getActiveTab = function getActiveTab() {
  var navbar = getNavbar();
  if (!navbar) return;
  var activeTabId = navbar.getAttribute(ACTIVE_ID_ATTR_NAME);
  var activeTabs = getTabsForId(activeTabId);
  return activeTabs[0];
};

var getView = function getView(id) {
  return document.querySelector(getSelector(VIEW_ID_ATTR_NAME, '=', id));
};

var getFirstTabId = function getFirstTabId() {
  var tab = document.querySelector(getSelector(ITEM_ID_ATTR_NAME));
  if (tab) {
    if (tab.getAttribute(ITEM_ID_ATTR_NAME) === OVERFLOW_MENU_ID) {
      return null;
    }
    return tab.getAttribute(ITEM_ID_ATTR_NAME);
  }
  return null;
};

var setActiveForMatchingId = function setActiveForMatchingId(ids) {
  // Off the list of passed ids, find the first one that matches a tab, then set
  // that one as active.
  var count = 0;
  var tabs;
  var id;
  while (count < ids.length && (!tabs || !tabs.length)) {
    if (ids[count]) {
      id = ids[count];
      tabs = getTabsForId(id);
    }
    count++;
  }
  var useID = id;

  if (!tabs || !tabs.length) {
    return;
  }
  var view = getView(useID);

  setActive(useID, tabs, view);
};

var setActive = function setActive(id, tabs, view) {
  var currentActiveTab = getActiveTab();
  var currentActiveId = currentActiveTab && currentActiveTab.getAttribute(ITEM_ID_ATTR_NAME);

  // Abort if the new tab is already active
  if (currentActiveId === id) return;

  setActiveTabs(id, tabs);
  setActiveView(id, view);

  center.emit('navbar-change', { id: id });
};

var setActiveTabs = function setActiveTabs(id, tabs) {
  var navbar = getNavbar();
  if (!navbar) return;

  navbar.setAttribute(ACTIVE_ID_ATTR_NAME, id);

  tabs.forEach(function (tab) {
    tab.classList.add(CLASSNAME_ACTIVE);
  });

  // Remove the active class name from all tabs except the ones that should be active
  var tabs = getTabs();
  if (tabs.length) {
    tabs.forEach(function (_tab) {
      if (_tab.getAttribute(ITEM_ID_ATTR_NAME) !== id) {
        _tab.classList.remove(CLASSNAME_ACTIVE);
      }
    });
  }
};

var setActiveView = function setActiveView(id, view) {
  if (!view) {
    return;
  }

  var views = getViews();

  // Hide all views except the one that should be active
  for (var i = 0, l = views.length; i < l; i++) {
    if (views[i] !== view[0]) {
      hide(views[i]);
    }
  }

  show(view);
};

var hide = function hide(element) {
  element.style.display = 'none';
};
var show = function show(element) {
  element.style.display = 'block';
};

var updateForNode = function updateForNode(node) {
  var navbar = getNavbar(node);
  if (!navbar) return;

  live(APPLICATION_MODEL_URI).query('appURI, arguments', function (error, data) {
    if (error) throw error;

    var uri = fixAppURI(data.appURI);
    var fullAppURI = uri;
    if (data.arguments) {
      fullAppURI += ':' + data.arguments;
    }
    var id = getIdFromMatchers(fullAppURI);

    if (id) {
      // This is only the case when matchers (ITEM_MATCHER_ATTR_NAME) are used in DOM.
      setActiveForMatchingId([id]);
    } else {
      // For cases where id is only to be matched from one argument, find the id to
      // highlight by looking at the argument at HISTORY_POS_ATTR_NAME.
      var argumentIndex = +navbar.getAttribute(HISTORY_POS_ATTR_NAME) || 0;
      var idAtArgumentIndex = data.arguments.split(':')[argumentIndex];

      // For cases where nothing matches, also pass the first tab ID. This is
      // how the first tab is highlighted by default.
      var firstTabId = getFirstTabId();

      setActiveForMatchingId([fullAppURI, idAtArgumentIndex, firstTabId]);
    }
  });
};

function updateForOverflow(node) {
  var navbar = getNavbar(node);
  if (!navbar) return;

  var itemSelector = '[data-navbar] > [data-navbar-item-id]:not(.overflow-menu-button)';
  var items = node.querySelectorAll(itemSelector);
  if (!items) return;

  items = Array.prototype.slice.call(items);

  var overflowMenuButton = navbar.querySelector('.overflow-menu-button');

  // If we have less than two items, only show the navbar and be done. We need
  // at least two items for messurement and chances are a "more" menu won't be
  // needed.
  if (items.length < 2) {
    navbar.style.visibility = 'visible';
    if (overflowMenuButton) overflowMenuButton.style.display = 'none';
    return;
  }

  var navbarWidth = getWidth(navbar);
  if (!navbarWidth) {
    // The navbar isn't rendered. Bail out.
    return;
  }

  // Reset to the initial rendering state to be able to measure items.
  if (overflowMenuButton) overflowMenuButton.style.display = 'inline';

  items.forEach(function (item, i) {
    item.style.display = 'block';
    item.classList.remove('last-visible');
  });

  var sizing = measureNavbar(items, overflowMenuButton);

  // If stuff doesn't completely fit, reduce the available space by the "more"
  // menu with, then calculate what needs to go in it.
  var availableSpace = navbarWidth;
  var firstOverflown = getFirstOverflownIndex(availableSpace, sizing.itemWidths);
  var needsMoreMenu = items.length !== firstOverflown;

  if (needsMoreMenu) {
    availableSpace -= sizing.overflowMenuButtonWidth;
    firstOverflown = getFirstOverflownIndex(availableSpace, sizing.itemWidths);
  }

  if (!navbarOverflowItems) {
    navbarOverflowItems = [];
  }
  navbarOverflowItems.length = 0;

  items.forEach(function (item, i) {
    var shouldBeInOverflow = i >= firstOverflown;
    if (shouldBeInOverflow) navbarOverflowItems.push(item);

    // If we don't draw an overflow menu, set the last-visible class on the
    // very last item so its margin-right is removed.
    var isLastInNotOverflown = !needsMoreMenu && i === items.length - 1;

    item.style.display = shouldBeInOverflow ? 'none' : 'block';
    item.classList.toggle('last-visible', isLastInNotOverflown);
  });

  if (overflowMenuButton) {
    overflowMenuButton.style.display = needsMoreMenu ? 'inline' : 'none';
  }

  // Update items and position, possibly close the menu
  updateOverflowMenu();
  navbar.style.visibility = 'visible';
}

function updateScrollPosition() {
  var scrollTop = window.pageYOffset;
  var stickyElements = Array.prototype.slice.call(document.querySelectorAll('[' + STICKY_WRAPPER_ATTR_NAME + ']'));

  if (stickyElements.length === 0) return;

  // Get the `top` value of a sticky element that is
  // in a fixed position (negative value)
  // and the closest to the top (smallest top value).
  var topTarget = stickyElements.reduce(function (res, el) {
    var top = el.getBoundingClientRect().top;
    return top < res ? top : res;
  }, 0);

  if (topTarget < 0) {
    // Add 1 px to have the sticky element in fixed position.
    window.scrollTo(0, topTarget + scrollTop + 1);
  }
}

function handleResize() {
  updateForOverflow(document.body);
}

function measureNavbar(items, overflowMenuButton) {
  // Find out what the margin per item is my messuring beween the first 2 items.
  var item1 = items[0];
  var item2 = items[1];

  var right1 = Math.floor(item1.getBoundingClientRect().right);
  var left2 = Math.floor(item2.getBoundingClientRect().left);
  var marginPerSide = (left2 - right1) / 2;

  var itemWidths = [];
  if (items) {
    itemWidths = items.map(function (item, i, all) {
      var marginLeft = i === 0 ? 0 : marginPerSide;
      var marginRight = i === all.length - 1 ? 0 : marginPerSide;
      return getWidth(item) + marginLeft + marginRight;
    });
  }

  // When the overflowMenuButton is showns, it's always at the end, so it has
  // no right margin.
  var overflowMenuButtonWidth = 0;
  if (overflowMenuButton) {
    overflowMenuButtonWidth = getWidth(overflowMenuButton) + marginPerSide;
  }

  return {
    itemWidths: itemWidths,
    overflowMenuButtonWidth: overflowMenuButtonWidth
  };
}

function getWidth(element) {
  return element && element.offsetWidth || 0;
}

function getFirstOverflownIndex(space, sizes) {
  var count = 0;
  var used = 0;
  while (sizes[count] !== undefined && used < space) {
    used += sizes[count];
    // This is actually expected to return up to .length of the sizes.
    // That will be the case when everything fits.
    count++;
  }
  if (used < space) return count;
  return count - 1;
}

// Hack to get around bridge bug (reported at WP-471) where WP reports
// the uri with the arguments as well.
var fixAppURI = function fixAppURI(uri) {
  return uri.split(':').slice(0, 3).join(':');
};

// Matchers allow you to tell a tab to be active for a pattern of the app arguments.
// If you define data-navbar-item-matcher="user:.*?:playlist:.*$" you tell the tab
// to be active when the arguments match that regexp.
var storedMatchers = {};
var getMatchers = function getMatchers(node) {
  var matchers = node.querySelectorAll(getSelector(ITEM_MATCHER_ATTR_NAME));
  if (!matchers.length) return;

  matchers = Array.prototype.slice.call(matchers);
  matchers.forEach(function (matcher) {
    var regexp = matcher.getAttribute(ITEM_MATCHER_ATTR_NAME);
    var id = matcher.getAttribute(ITEM_ID_ATTR_NAME);
    storedMatchers[regexp] = id;
  });
};

var getIdFromMatchers = function getIdFromMatchers(uri) {
  for (var regexp in storedMatchers) {
    if (storedMatchers.hasOwnProperty(regexp)) {
      var regexpObj = new RegExp(regexp);
      if (regexpObj.test(uri)) return storedMatchers[regexp];
    }
  }
  return null;
};

var getNavbar = function getNavbar(opt_node) {
  var node = opt_node || document.documentElement;
  var selector = getSelector(NAVBAR_ATTR_NAME);
  return node.matches(selector) ? node : node.querySelector(selector);
};

var onApplicationChange = function onApplicationChange(event) {
  if ('arguments' in event || 'active' in event) {
    updateForNode(document.documentElement);
  }
};

var isAttached = false;

exports.update = function update(node) {
  if (!isAttached) return;

  updateForNode(node || document.documentElement);
  getMatchers(node || document.documentElement);
  updateForOverflow(node || document.documentElement);
};

exports.attach = function attach() {
  if (isAttached) return;
  isAttached = true;

  $(document).delegate('click', getSelector(ITEM_ID_ATTR_NAME), handleClick);
  window.addEventListener('message', onMessage);
  live(APPLICATION_MODEL_URI).on('update', onApplicationChange);
  window.addEventListener('resize', handleResize);
  center.on('navbar-hide', hideOverflow);
};

exports.detach = function detach() {
  if (!isAttached) return;
  isAttached = false;

  navbarOverflowItems = null;
  isShowingNavbarOverflow = false;
  shouldShowNavbarOverflow = false;

  $(document).undelegate('click', getSelector(ITEM_ID_ATTR_NAME), handleClick);
  window.removeEventListener('message', onMessage);
  live(APPLICATION_MODEL_URI).off('update', onApplicationChange);
  window.removeEventListener('resize', handleResize);
  center.off('navbar-hide', hideOverflow);
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-elements":45,"../spotify-live":212,"./center":52}],70:[function(require,module,exports){
'use strict';

var $ = require('../spotify-elements');
var live = require('../spotify-live');

var sessionModel;

function onSessionUpdate(properties) {
  if ('online' in properties) {
    if (properties.online) {
      $(document.body).removeClass('offline');
    } else {
      $(document.body).addClass('offline');
    }
  }
}

function updateWithSessionValue() {
  live('spotify:client').query('session(online)', function (error, data) {
    if (error) throw error;
    onSessionUpdate({ online: data.session.online });
  });
}

var isAttached = false;

exports.update = function () {
  if (!isAttached) return;

  updateWithSessionValue();
};

exports.attach = function () {
  if (isAttached) return;
  isAttached = true;

  if (!sessionModel) {
    live('spotify:client').get('session', function (error, session) {
      if (error) throw error;
      sessionModel = session;
      sessionModel.on('update', onSessionUpdate);
    });
  }
};

exports.detach = function () {
  if (!isAttached) return;
  isAttached = false;

  if (sessionModel) {
    sessionModel.off('update', onSessionUpdate);
    sessionModel = null;
  }
};

},{"../spotify-elements":45,"../spotify-live":212}],71:[function(require,module,exports){
'use strict';

/**
 * @private
 */

// [SHUFFLE] Used only for showing the message bar when trying to play a track.
var shuffleMode = require('../../spotify-shuffle-mode');
var cosmos = require('spotify-cosmos-api');

var $ = require('../../spotify-elements');
var utils = require('./utils');

var SELECTOR_LIST_ROW = '[data-context] [data-list-item]';
var SELECTOR_PLAY_BUTTON = '[data-button=play]';
var SELECTOR_PLAY_CONTEXT_BUTTON = '[data-button=play-context]';

// This array will store event types for touch handling
var lastEventTypes = [];

// Methods that need implementation from another module.
// This is to support generic handling of user actions from within this module,
// but allow further checks and actions to be performed by another module. This
// allows multiple different implementations of starting playback for example.
var methods = {
  getPlayerVariantUri: utils.createEmptyMethod('getPlayerVariantUri'),
  handlePlayButton: utils.createEmptyMethod('handlePlayButton'),
  handlePlayFromRow: utils.createEmptyMethod('handlePlayFromRow')
};

/**
 * Handle the click of a play button.
 *
 * @param {MouseEvent} event An event object for a click event.
 * @param {Elements} button An element instance from the `elements` package.
 *
 * @private
 */
function handlePlayButtonClick(event, button) {
  var buttonNode = button[0];
  var buttonContextUri = utils.getUriFromButton(buttonNode);

  // We need an associated context URI for the button
  if (!buttonContextUri) {
    return;
  }

  // [SHUFFLE]: track buttons do not work.
  if (shuffleMode.isEnabled() && /^spotify:track:/.test(buttonContextUri)) {
    cosmos.resolver.post({
      url: 'sp://messages/v1/container/user-message',
      body: {
        description: 'Track cannot be played because "shuffle mode" is enabled',
        id: 'shuffle-unplayable-track'
      }
    }, function () {
      // We don't care about reply, if it fails we can't do pretty much anything
    });

    return;
  }

  var playerContextUri = methods.getPlayerVariantUri();
  var isPlayingContext = utils.compareContexts(playerContextUri, buttonContextUri);

  var source = utils.getAttributeValueFromNode(buttonNode, 'data-play-source');

  methods.handlePlayButton(buttonNode, {
    isPlayingContext: isPlayingContext,
    contextUri: buttonContextUri,
    source: source,
    reason: 'playbtn'
  });
}

/**
 * Handle the double click or tap of a list row to start playback.
 *
 * @param {Elements} row An element instance from the `elements` package.
 *
 * @private
 */
function handleListRow(row) {
  var contextNode = row.parent('[data-context]');
  if (contextNode) {
    var rowNode = row[0];
    var source = utils.getAttributeValueFromNode(rowNode, 'data-play-source');
    methods.handlePlayFromRow(rowNode, {
      contextUri: contextNode.data('uri'),
      source: source,
      reason: 'clickrow'
    });
  }
}

/**
 * Handle double clicking on a list row to start playback.
 *
 * @param {MouseEvent} event An event object for a double click.
 * @param {Elements} row An element instance from the `elements` package.
 *
 * @private
 */
function handleRowDoubleClick(event, row) {
  // Only play when not clicking on interactive elements such as buttons
  if (!utils.isInteractiveElement(event.target)) {
    handleListRow(row);
  }
}

/**
 * Handle a key press on a list row.
 * This will take care of starting playback when pressing Enter.
 *
 * @param {KeyboardEvent} event A keyboard event.
 * @param {Elements} row An element instance from the `elements` package.
 *
 * @private
 */
function handleRowKeyDown(event, row) {
  var isEnter = event.keyCode === 13;
  if (isEnter) {
    if (utils.isFormOrLinkElement(event.target)) {
      return;
    }

    event.preventDefault();
    event.stopPropagation();

    handleListRow(row);
  }
}

/**
 * Handle the 'contextmenu' event. This is only for touch handling.
 * This is needed since we use a custom context menu in Spotify, and the handler
 * for that calls `preventDefault` for the 'contextmenu' event, which means the
 * rest of the touch handling will go on as usual. So as we don't get the
 * 'touchcancel' event, we need to catch the 'contextmenu' event here to know
 * that we should not act on the following 'touchend' event.
 *
 * @param {MouseEvent} event A 'contextmenu' event.
 *
 * @private
 */
function handleContextMenu(event) {
  lastEventTypes.push(event.type);
}

/**
 * Handle the start of a touch. Used to detect a tap.
 *
 * @param {TouchEvent} event A touch event.
 *
 * @private
 */
function handleRowTouchStart(event) {
  lastEventTypes.push(event.type);
}

/**
 * Handle the move of a touch. Used to abort detection of a tap.
 *
 * @param {TouchEvent} event A touch event.
 *
 * @private
 */
function handleRowTouchMove(event) {
  lastEventTypes.push(event.type);
}

/**
 * Handle the end of a touch. Used to detect a tap and start playback of a row.
 *
 * @param {TouchEvent} event A touch event.
 * @param {Elements} row An element instance from the `elements` package.
 *
 * @private
 */
function handleRowTouchEnd(event, row) {
  // If this was a tap (only touchstart was triggered before this)
  if (lastEventTypes.length === 1 && lastEventTypes[0] === 'touchstart') {

    // Prevent the simulated mouse events (including click). This is to
    // avoid the simulated click event to click on the play button that
    // appears when selecting a row on touchstart.
    // See: https://jira.spotify.net/browse/KM-7983
    if (!utils.isInteractiveElement(event.target)) {
      event.preventDefault();

      // Tapping on a row should play it
      handleListRow(row);
    }
  }
  lastEventTypes = [];
}

/**
 * Attach the needed event listeners for the module.
 */
exports.attach = function () {
  var doc = $(document);

  doc.delegate('keydown', SELECTOR_LIST_ROW, handleRowKeyDown);
  doc.delegate('click', SELECTOR_PLAY_BUTTON, handlePlayButtonClick);
  doc.delegate('click', SELECTOR_PLAY_CONTEXT_BUTTON, handlePlayButtonClick);
  doc.delegate('dblclick', SELECTOR_LIST_ROW, handleRowDoubleClick);

  /* For touch handling */
  doc.delegate('touchstart', SELECTOR_LIST_ROW, handleRowTouchStart);
  doc.delegate('touchend', SELECTOR_LIST_ROW, handleRowTouchEnd);
  doc.delegate('touchmove', SELECTOR_LIST_ROW, handleRowTouchMove);
  doc.delegate('contextmenu', SELECTOR_LIST_ROW, handleContextMenu);
};

/**
 * Detach the event listeners for the module.
 */
exports.detach = function () {
  var doc = $(document);

  doc.undelegate('keydown', SELECTOR_LIST_ROW, handleRowKeyDown);
  doc.undelegate('click', SELECTOR_PLAY_BUTTON, handlePlayButtonClick);
  doc.undelegate('click', SELECTOR_PLAY_CONTEXT_BUTTON, handlePlayButtonClick);
  doc.undelegate('dblclick', SELECTOR_LIST_ROW, handleRowDoubleClick);

  /* For touch handling */
  doc.undelegate('touchstart', SELECTOR_LIST_ROW, handleRowTouchStart);
  doc.undelegate('touchend', SELECTOR_LIST_ROW, handleRowTouchEnd);
  doc.undelegate('touchmove', SELECTOR_LIST_ROW, handleRowTouchMove);
  doc.undelegate('contextmenu', SELECTOR_LIST_ROW, handleContextMenu);
};

/**
 * Set the external methods for this module to add implementations for starting
 * playback etc.
 *
 * @param {Object} methodDefinitions Object where keys are method names and
 *     values are functions.
 */
exports.setMethods = function (methodDefinitions) {
  for (var name in methodDefinitions) {
    if (methodDefinitions.hasOwnProperty(name)) {
      methods[name] = methodDefinitions[name];
    }
  }
};

},{"../../spotify-elements":45,"../../spotify-shuffle-mode":252,"./utils":74,"spotify-cosmos-api":388}],72:[function(require,module,exports){
'use strict';

var playerWithIndices = require('./withIndices');
var playerWithUids = require('./withUids');

var playerModule = playerWithIndices;

exports.setMode = function (type) {
  switch (type) {
    case 'indices':
      playerModule = playerWithIndices;
      break;
    case 'uids':
      playerModule = playerWithUids;
      break;
  }
};

exports.attach = function () {
  playerModule.attach();
};

exports.detach = function () {
  playerModule.detach();
};

exports.update = function (optNode) {
  playerModule.update(optNode);
};

},{"./withIndices":75,"./withUids":76}],73:[function(require,module,exports){
'use strict';

/**
 * @private
 */

var difference = require('mout/array/difference');
var $ = require('../../spotify-elements');
var live = require('../../spotify-live');

var center = require('../center');
var utils = require('./utils');

var CURRENT = 'current';
var PAUSED = 'paused';
var PLAYING = 'playing';

var LOG_PLAY_BUTTON = 'play-button';
var LOG_PAUSE_BUTTON = 'pause-button';

var SELECTOR_PLAY_BUTTON = '[data-button=play]';
var SELECTOR_PLAY_CONTEXT_BUTTON = '[data-button=play-context]';
var SELECTOR_ALL_PLAY_BUTTONS = SELECTOR_PLAY_BUTTON + ',' + SELECTOR_PLAY_CONTEXT_BUTTON;

// Methods that need implementation from another module.
// This is to support generic handling of DOM updates from within this module,
// but allow further checks and actions to be performed by another module. This
// allows multiple different implementations of highlighting playing objects.
var methods = {
  getPlayerVariantUri: utils.createEmptyMethod('getPlayerVariantUri'),
  getPlayerIsPlaying: utils.createEmptyMethod('getPlayerIsPlaying'),
  getPlayingNodes: utils.createEmptyMethod('getPlayingNodes'),

  // This should be a function that takes a function as the first argument. That
  // function argument should be called whenever the player state has changed.
  subscribeToPlayerChange: utils.createEmptyMethod('subscribeToPlayerChange')
};

var playableChangeHandlers = {};
var playerSubscription = null;

/**
 * Update states in the DOM based on current player state.
 *
 * @param {HTMLElement=} node An optional DOM node. If passed, only nodes inside
 *     of that node will be updated.
 */
function updateDOM(optNode) {
  var containerNode = optNode || document;

  updateButtonsBasedOnPlayable(containerNode);

  var playingNodes = getPlayingNodes(containerNode);
  var currentNodes = getCurrentNodes(containerNode);

  if (currentNodes) {
    var nodesForRemoval = currentNodes;
    if (playingNodes) {
      nodesForRemoval = difference(currentNodes, playingNodes);
    }
    nodesForRemoval.forEach(removePlayingStateFromNode);
  }

  if (playingNodes) {
    var nodesForAddition = playingNodes;
    if (currentNodes) {
      nodesForAddition = difference(playingNodes, currentNodes);
    }
    nodesForAddition.forEach(addPlayingStateToNode);

    var nodesForUpdate = difference(playingNodes, nodesForAddition);
    nodesForUpdate.forEach(updatePlayingStateForNode);
  }
}

/**
 * Update the playable status of all play buttons found inside the passed
 * container node.
 *
 * @param {HTMLElement} containerNode A DOM node to search for nodes inside.
 *
 * @private
 */
function updateButtonsBasedOnPlayable(containerNode) {
  // `[data-button=play]` buttons are used to play something specific *in* a
  // context (defining an index as a track number or uid/uri or range).
  // Those are currently not updated themselves, instead their rows are being
  // set to `.unavailable`.
  var buttons = $(containerNode).search('[data-button=play-context]');
  if (buttons) {
    buttons.forEach(updateButtonBasedOnPlayable);
  }
}

/**
 * Update the playable status of the passed button.
 *
 * @param {HTMLElement} button A button DOM node.
 *
 * @private
 */
function updateButtonBasedOnPlayable(button) {

  // Play buttons in list rows should not be handled, as the buttons are
  // hidden by CSS anyway for unplayable rows.
  if (!!$(button).parent('[data-list-item]')) {
    return;
  }

  var contextURI = utils.getUriFromButton(button);

  // Check if the context has a playable flag specified.
  var playableValue = live(contextURI).get('playable');
  var definesPlayable = playableValue != undefined;

  // If it does, update the `disabled` attribute based on it
  if (definesPlayable) {
    if (playableValue) {
      button.removeAttribute('disabled');
    } else {
      button.setAttribute('disabled', 'disabled');
    }

    if (!playableChangeHandlers[contextURI]) {
      playableChangeHandlers[contextURI] = function (changed) {
        if (!changed.hasOwnProperty('playable')) return;
        // Update all buttons currently in DOM when `playable` changes on a
        // context. Not worth adding logic to only pick out buttons pointing to
        // a specific URI.
        updateButtonsBasedOnPlayable(document.body);
      };
      live(contextURI).on('update', playableChangeHandlers[contextURI]);
    }
  }
}

/**
 * Get the nodes inside the passed container node that are currently marked as
 * playing.
 *
 * @param {HTMLElement} containerNode A DOM node to search for nodes inside.
 *
 * @return {?Elements} An element instance from the `elements` package, or null.
 *
 * @private
 */
function getCurrentNodes(containerNode) {
  return $(containerNode).search('[data-playback-active=true]');
}

/**
 * Get the nodes inside the passed container node that should be marked as
 * playing based on the current player state.
 *
 * @param {HTMLElement} containerNode A DOM node to search for nodes inside.
 *
 * @return {?Elements} An element instance from the `elements` package, or null.
 *
 * @private
 */
function getPlayingNodes(containerNode) {
  var variantUri = methods.getPlayerVariantUri();
  var selectors = utils.getContextSelectorsWithVariants(variantUri);

  var contextNodes = $(containerNode).search(selectors.join(', '));
  if (contextNodes) {
    contextNodes = Array.prototype.slice.call(contextNodes);
  } else {
    contextNodes = [];
  }

  // Pass it through the outside implementation, which might filter out
  // nodes from `contextNodes` and add more nodes to the match.
  return methods.getPlayingNodes(containerNode, contextNodes);
}

/**
 * Remove the playing state from the passed DOM node, as it's no longer playing.
 *
 * @param {HTMLElement} node The DOM node to remove state from.
 *
 * @private
 */
function removePlayingStateFromNode(node) {
  var className = [CURRENT, PAUSED, PLAYING].join(' ');
  node = $(node);
  node.removeClass(className).removeAttribute('data-playback-active');

  if (node.matches(SELECTOR_ALL_PLAY_BUTTONS)) {
    node.attribute('data-log-click', LOG_PLAY_BUTTON);
  }
}

/**
 * Add the playing state to the passed DOM node, as it's now playing.
 *
 * @param {HTMLElement} node The DOM node to add state to.
 *
 * @private
 */
function addPlayingStateToNode(node) {
  var isPlaying = methods.getPlayerIsPlaying();

  var classNames = [CURRENT, isPlaying ? PLAYING : PAUSED].join(' ');

  node = $(node);
  node.addClass(classNames).data('playback-active', true);

  if (node.matches(SELECTOR_ALL_PLAY_BUTTONS)) {
    node.attribute('data-log-click', isPlaying ? LOG_PAUSE_BUTTON : LOG_PLAY_BUTTON);
  }
}

/**
 * Update the playing state for the passed DOM node, as it's still representing
 * the currently playing context, but the player might switch between
 * playing/paused.
 *
 * @param {HTMLElement} node The DOM node to update state for.
 *
 * @private
 */
function updatePlayingStateForNode(node) {
  var isPlaying = methods.getPlayerIsPlaying();

  var currentClassName = isPlaying ? PAUSED : PLAYING;
  var newClassName = isPlaying ? PLAYING : PAUSED;
  var element = $(node);

  if (element.hasClass(currentClassName)) {
    element.removeClass(currentClassName);
  }

  if (!element.hasClass(newClassName)) {
    element.addClass(newClassName);
  }

  if (element.matches(SELECTOR_ALL_PLAY_BUTTONS)) {
    element.attribute('data-log-click', isPlaying ? LOG_PAUSE_BUTTON : LOG_PLAY_BUTTON);
  }
}

/**
 * Handle updating of DOM nodes when they have been added to the DOM by a scroll
 * agent.
 *
 * @param {Object} event Custom event object sent from the scroll agent. Should
 *     contain a `container` property pointing to the DOM node containing the
 *     rows.
 *
 * @private
 */
function handleScrollShowAfter(event) {
  var container = $(event.container);
  var contextNode = null;
  if (container.matches('[data-context]')) {
    contextNode = container;
  } else {
    contextNode = container.parent('[data-context]');
  }

  // We can't pass the context node itself as root because of how the playing
  // state queries are set up.
  var contextParent = contextNode && contextNode[0].parentElement || document;

  updateDOM(contextParent);
}

/**
 * Attach the needed event listeners for the module.
 */
exports.attach = function () {
  playerSubscription = methods.subscribeToPlayerChange(function () {
    updateDOM();
  });

  center.on('scroll-show-after', handleScrollShowAfter);
};

/**
 * Detach the needed event listeners for the module.
 */
exports.detach = function () {
  if (playerSubscription) {
    playerSubscription.cancel();
    playerSubscription = null;
  }

  for (var contextUri in playableChangeHandlers) {
    if (playableChangeHandlers.hasOwnProperty(contextUri)) {
      live(contextUri).off('update', playableChangeHandlers[contextUri]);
    }
  }
  playableChangeHandlers = {};

  center.off('scroll-show-after', handleScrollShowAfter);
};

/**
 * Update things in the DOM.
 */
exports.update = updateDOM;

/**
 * Set the external methods for this module to add implementations for methods
 * needed for highlighting playing objects.
 *
 * @param {Object} methodDefinitions Object where keys are method names and
 *     values are functions.
 */
exports.setMethods = function (methodDefinitions) {
  for (var name in methodDefinitions) {
    if (methodDefinitions.hasOwnProperty(name)) {
      methods[name] = methodDefinitions[name];
    }
  }
};

},{"../../spotify-elements":45,"../../spotify-live":212,"../center":52,"./utils":74,"mout/array/difference":324}],74:[function(require,module,exports){
(function (global){
'use strict';

/**
 * This module might be used by modules outside of spotify-events.
 * @public
 */

var liburi = require('spotify-liburi');
var $ = require('../../spotify-elements');

var getOriginUri = require('../../spotify-live-wrapped-uri').getOriginUri;

/**
 * Get the context URI from a button node or its parents.
 *
 * @param {HTMLElement} button A DOM node for a button.
 *
 * @return {string} The context URI or empty string if not found.
 */
function getUriFromButton(button) {
  var contextNode = button.closest('[data-context]');
  return contextNode && contextNode.getAttribute('data-uri') || '';
}

/**
 * Get the value for the passed attribute name, either from the passed node or
 * from any parent node.
 *
 * @param {HTMLElement} node The node to start searching from.
 * @param {string} attributeName The name of the attribute.
 *
 * @return {string} The value, or empty string if not found.
 */
function getAttributeValueFromNode(node, attributeName) {
  var selector = '[' + attributeName + ']';
  var attributeNode = node.closest(selector);
  return attributeNode && attributeNode.getAttribute(attributeName) || '';
}

/**
 * Check if the passed element is a form or link element.
 *
 * @param {HTMLElement} element A DOM node.
 *
 * @return {boolean} True if it is a form or link element.
 */
function isFormOrLinkElement(element) {
  var tagName = element.tagName.toLowerCase();
  var elements = ['input', 'textarea', 'button', 'select', 'optgroup', 'option', 'a'];
  return elements.indexOf(tagName) > -1;
}

/**
 * Check if the passed element is an interactive element (links, buttons).
 *
 * @param {HTMLElement}  element A DOM node.
 *
 * @return {boolean} True if the element is interactive.
 */
function isInteractiveElement(element) {
  var tagName = element.tagName.toLowerCase();
  return tagName === 'a' || tagName === 'button';
}

/**
 * Get a CSS selector string for a context.
 *
 * @param {string} operator A CSS selector operator ($= or similar).
 * @param {string} uri The context URI.
 *
 * @return {string} The CSS selector string.
 */
function getContextSelector(operator, uri) {
  return '[data-context][data-uri' + operator + uri + ']';
}

/**
 * Get an array of CSS selectors for searching for context nodes inside the DOM.
 *
 * @param {string} uri The context URI to search for. This should be the
 *     currently playing variant URI (for example, when playing a sorted
 *     playlist the sorted URI should be passed).
 *
 * @return {Array.<string>} Array of CSS selector strings.
 */
function getContextSelectors(uri) {
  var ENDSWITH = '$=';
  var SAME = '=';

  var selectors = [getContextSelector(SAME, uri)];

  var normalized = normalizeUri(uri);
  if (uri !== normalized) {
    selectors.push(getContextSelector(SAME, normalized));
  }

  return selectors;
}

/**
 * Get an array of CSS selectors for searching for context nodes inside the DOM.
 * This also includes any variant of the passed context URI. For example, if
 * passing a sorted playlist URI, it will return selectors for matching all
 * variations of that playlist URI, including the regular playlist URI, filtered
 * URI etc.
 *
 * @param {string} uri The context URI to search for. This can be either the
 *     origin URI, or any variant URI. The function will convert it to the
 *     origin URI automatically.
 *
 * @return {Array.<string>} Array of CSS selector strings.
 */
function getContextSelectorsWithVariants(uri) {
  var ENDSWITH = '$=';
  var SAME = '=';

  // Only add the ENDSWITH selectors. Those also match the original.
  // When it's a sorted and/or filtered list, just use the origin.
  var endsWith = getOriginUri(uri) || uri;
  var endsWithNormalized = normalizeUri(endsWith);

  var selectors = [getContextSelector(ENDSWITH, endsWith.replace(/^spotify:/, ':'))];

  if (endsWith !== endsWithNormalized) {
    selectors.push(getContextSelector(ENDSWITH, endsWithNormalized.replace(/^spotify:/, ':')));
  }

  return selectors;
}

/**
 * Check if two context URIs are representing the same context. This will take
 * care of normalizing the casing of URL encoding and filtered/sorted contexts.
 *
 * @param {string} context1 The first context.
 * @param {string} context2 The second context.
 *
 * @return {boolean} True if they represent the same context.
 */
function compareContexts(context1, context2) {
  if (!context1 || !context2) return false;

  context1 = normalizeUri(getOriginUri(context1) || context1);
  context2 = normalizeUri(getOriginUri(context2) || context2);

  return context1 === context2;
}

/**
 * A URI might contain URL encoded characters, and per spec the URL encoding can
 * be either in lowercase or uppercase (should be treated as same URL). If the
 * input URL has lowercase encoding, liburi will convert it into uppercase
 * encoding.
 *
 * @param {string} uri The URI to normalize.
 *
 * @return {string} The normalized URI.
 */
function normalizeUri(uri) {
  var uriObj = liburi.from(uri);
  var normalized = uriObj ? uriObj.toString() : uri;

  // Work around incorrect handling of `spotify:internal:...` URIs by liburi,
  // since it does not recognize `internal` URIs, and therefore uses the default
  // `app` type.
  normalized = normalized.replace(/^spotify:app:internal:/, 'spotify:internal:');

  // Work around the bad conversion of spaces in filtered list URIs. The URI
  // spec we use says that spaces should be encoded as `+`, but the `filterlist`
  // URI uses the regular `%20` encoding for spaces. Passing it through liburi
  // converts it to `+`, so we need to convert it back to `%20` again.
  normalized = normalized.replace(/:internal:filterlist:[^:]+/, function (match) {
    return match.replace(/\+/g, '%20');
  });

  return normalized;
}

/**
 * Create an empty method that will only log a warning when called.
 *
 * @param {string} methodName The name of the method to warn about.
 *
 * @return {Function} The function.
 */
function createEmptyMethod(methodName) {
  return function () {
    if (global.console) {
      console.warn('spotify-events/player: `' + methodName + '` is not implemented.');
    }
  };
}

exports.getUriFromButton = getUriFromButton;
exports.getAttributeValueFromNode = getAttributeValueFromNode;
exports.isFormOrLinkElement = isFormOrLinkElement;
exports.isInteractiveElement = isInteractiveElement;
exports.getContextSelector = getContextSelector;
exports.getContextSelectors = getContextSelectors;
exports.getContextSelectorsWithVariants = getContextSelectorsWithVariants;
exports.compareContexts = compareContexts;
exports.normalizeUri = normalizeUri;
exports.createEmptyMethod = createEmptyMethod;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../spotify-elements":45,"../../spotify-live-wrapped-uri":211,"spotify-liburi":398}],75:[function(require,module,exports){
'use strict';

/**
 * @private
 */

var live = require('../../spotify-live');
var Range = require('../../spotify-range2');
var $ = require('../../spotify-elements');
var find = require('mout/array/find');

var playerActions = require('./actions');
var playerUpdates = require('./updates');
var utils = require('./utils');

var isAttached = false;

exports.attach = function () {
  if (isAttached) return;
  isAttached = true;

  playerActions.setMethods({
    getPlayerVariantUri: getPlayerVariantUri,
    handlePlayButton: handlePlayButton,
    handlePlayFromRow: handlePlayFromRow
  });

  playerUpdates.setMethods({
    getPlayerVariantUri: getPlayerVariantUri,
    getPlayerIsPlaying: getPlayerIsPlaying,
    getPlayingNodes: getPlayingNodes,
    subscribeToPlayerChange: subscribeToPlayerChange
  });

  playerActions.attach();
  playerUpdates.attach();
};

exports.detach = function () {
  if (!isAttached) return;
  isAttached = false;

  playerActions.detach();
  playerUpdates.detach();
};

exports.update = function (optNode) {
  if (!isAttached) return;

  playerUpdates.update(optNode);
};

/**
 * Get the variant URI for the currently playing context. For example, if
 * playing a sorted playlist, this should return the sorted URI.
 *
 * @return {string} The context variant URI, or empty string if nothing is
 *     playing.
 */
function getPlayerVariantUri() {
  var variant = live('spotify:player').get('variant');
  return variant ? variant.uri : '';
}

/**
 * Get the index of the currently playing track within the playing context.
 *
 * @return {number} The index, or -1 if not found.
 */
function getPlayerIndex() {
  var indexObject = live('spotify:player').get('index');
  return indexObject ? indexObject.get('track') : -1;
}

/**
 * Get the URI of the currently playing track.
 *
 * @return {string} The track URI, or empty string if nothing is playing.
 */
function getPlayerTrackUri() {
  var track = live('spotify:player').get('track');
  return track && track.uri || '';
}

/**
 * Get the playing status of the player.
 *
 * @return {boolean} True if the player is currently playing audio.
 */
function getPlayerIsPlaying() {
  var isPlaying = live('spotify:player').get('isPlaying');
  var isPaused = live('spotify:player').get('isPaused');
  return isPlaying && !isPaused;
}

/**
 * Get whether the player is currently shuffling the context.
 *
 * @return {boolean} True if shuffling.
 */
function getPlayerIsShuffling() {
  var options = live('spotify:player').get('options');
  var shufflingContext = options && options.get('shufflingContext');
  return !!shufflingContext;
}

/**
 * Subscribe to player changes.
 *
 * @param {Function} handler A handler function. The data passed to this
 *     function is irrelevent, only the fact that something changed is needed.
 *
 * @return {Object} An object with a `cancel` method to cancel the subscription.
 */
function subscribeToPlayerChange(handler) {
  live('spotify:player').on('update', handler);
  var active = true;
  return {
    cancel: function cancel() {
      if (active) {
        live('spotify:player').off('update', handler);
        active = false;
      }
    }
  };
}

/**
 * Handle the click of a play button.
 * This function should decide what the action should be, and pause/resume
 * playback or start playback of a new context.
 *
 * @param {HTMLElement} buttonNode A button DOM node.
 * @param {Object} data Object of data about the action:
 *     isPlayingContext: (boolean) Whether the button looks to be representing
 *         the currently playing context.
 *     contextUri: (string) The context URI for the button.
 *     source: (string) The 'play source' value, for logging purposes.
 *     reason: (string) The 'play reason' value, for logging purposes.
 */
function handlePlayButton(buttonNode, data) {
  var button = $(buttonNode);
  var playerIndex = getPlayerIndex();
  var range;
  var newIndex;
  var uids;
  var uris;

  var dataRange = button.data('range');
  if (dataRange) {
    range = Range.fromString(dataRange);
    var list = live(data.contextUri).get('rows');
    if (list) {
      var indices = range.toIndices();
      uids = indices.map(function (index) {
        return list.keys[index];
      });
      uris = indices.map(function (index) {
        var track = list.get(index).get('track');
        return track.uri;
      });
    }
    newIndex = null;
  } else {
    var contextIndexNode = null;
    if (button.matches('[data-context-index]')) {
      contextIndexNode = button;
    } else {
      contextIndexNode = button.parent('[data-context-index]');
    }

    if (contextIndexNode) {
      newIndex = parseInt(contextIndexNode.data('context-index'), 10);
      var list = live(data.contextUri).get('rows');
      if (list) {
        uids = [list.keys[newIndex]];
        uris = [list.get(newIndex).get('track').uri];
      }
    } else {
      newIndex = null;
    }
  }

  var shouldPauseResume = false;

  if (data.isPlayingContext) {
    if (range) {
      // null or undefined
      if (playerIndex == null) {
        shouldPauseResume = false;
      } else {
        shouldPauseResume = range.contains(new Range(playerIndex, playerIndex + 1));
      }
    } else if (newIndex != null) {
      shouldPauseResume = newIndex === playerIndex;
    } else {
      shouldPauseResume = true;
    }
  }

  if (shouldPauseResume) {
    if (getPlayerIsPlaying()) {
      live('spotify:player').emit('pause');
    } else {
      live('spotify:player').emit('resume');
    }
  } else {
    var eventData = {
      context: data.contextUri,
      index: newIndex,
      source: data.source,
      reason: data.reason
    };

    if (range) {
      eventData.range = [range.start, range.end];
    }

    if (uids) {
      eventData.uids = uids;
    }

    if (uris) {
      eventData.uris = uris;
    }

    live('spotify:player').emit('play', eventData);
  }
}

/**
 * Handle playing a list row. This function should start playback of a context
 * starting from a specific row.
 *
 * @param {HTMLElement} rowNode A DOM node for a list row.
 * @param {Object} data Object of data about the action:
 *     contextUri: (string) The context URI for the list.
 *     source: (string) The 'play source' value, for logging purposes.
 *     reason: (string) The 'play reason' value, for logging purposes.
 */
function handlePlayFromRow(rowNode, data) {
  var index = parseInt(rowNode.getAttribute('data-context-index'), 10);
  if (isNaN(index)) {
    index = -1;
  }
  var uid = rowNode.getAttribute('data-uid') || '';
  var uri = rowNode.getAttribute('data-uri') || '';

  var eventData = {
    context: data.contextUri,
    index: index,
    source: data.source,
    reason: data.reason
  };

  if (uid) {
    eventData.uids = [uid];
  }

  if (uri) {
    eventData.uris = [uri];
  }

  live('spotify:player').emit('play', eventData);
}

/**
 * Get the nodes inside the passed container node that should be marked as
 * playing.
 *
 * @param {HTMLElement} containerNode The DOM node to search inside.
 * @param {Array.<HTMLElement>} contextNodes Array of DOM nodes that are already
 *     matched based on context URIs. These can be filtered if needed, but
 *     otherwise they should be included in the return value.
 *
 * @return {Array.<HTMLElement>} An array of DOM nodes.
 */
function getPlayingNodes(containerNode, contextNodes) {
  var playerIndex = getPlayerIndex();
  var playerTrackUri = getPlayerTrackUri();
  var variantUri = getPlayerVariantUri();

  // Remove any matched context nodes that have a range specified and where
  // the current player index does not match.
  var filteredContextNodes = filterRanges(playerIndex, contextNodes);

  var selectors = utils.getContextSelectors(variantUri);
  var selectorsWithVariants = utils.getContextSelectorsWithVariants(variantUri);

  var rowNodes = getContextNodesForRows(containerNode, selectors, playerIndex, playerTrackUri) || [];

  var rangeNodes = getContextNodesForRanges(containerNode, selectorsWithVariants, playerIndex) || [];

  var buttonNodes = [];
  if (contextNodes.length) {
    buttonNodes = $(contextNodes).search('[data-button=play-context]');
  }

  // Let `elements` remove any duplicate nodes
  var nodes = $([filteredContextNodes, rowNodes, rangeNodes, buttonNodes]);

  return nodes ? Array.prototype.slice.call(nodes) : [];
}

/**
 * Get the nodes inside the passed container node that match what's currently
 * playing and are list rows.
 *
 * @param {HTMLElement} containerNode The DOM node to search inside.
 * @param {Array.<string>} selectors Array of CSS selectors for matching the
 *     currently playing context.
 * @param {number} index The currently playing index.
 * @param {string} trackUri The URI of the currently playing track.
 *
 * @return {Array.<HTMLElement>} Array of DOM nodes.
 */
function getContextNodesForRows(containerNode, selectors, index, trackUri) {
  var isShuffling = getPlayerIsShuffling();

  // When playing from this client, we highlight the playing index if the
  // playing variant and the list variant are exactly the same.
  //
  // Removed support for connect as we can no longer detect a connect session: KM-9645.

  var useIndexSelector = !isShuffling;
  var useTrackSelector = !!trackUri;

  var selector = selectors.map(function (selector) {
    if (useIndexSelector || useTrackSelector) selector += ' ';
    if (useIndexSelector) selector += '[data-context-index=' + index + ']';
    if (useTrackSelector) selector += '[data-uri="' + trackUri + '"]';
    return selector;
  }).join(', ');

  var nodes = selector && $(containerNode).search(selector);
  if (nodes) {
    nodes = Array.prototype.slice.call(nodes);

    if (isShuffling) {
      // As the lax matching used in this case might yield duplicate rows in a
      // single list, we must filter out those.
      nodes = nodes.filter(function (row, i) {
        var listNode = $(row).parent('[data-list]');
        // If this row is not the first row to be highlighted in this list,
        // filter it out.
        return row === find(nodes, function (row) {
          return listNode === $(row).parent('[data-list]');
        });
      });
    }
  } else {
    nodes = [];
  }

  return nodes;
}

/**
 * Get the nodes inside the passed container node that match what's currently
 * playing and have a matching range specified.
 *
 * @param {HTMLElement} containerNode The DOM node to search inside.
 * @param {Array.<string>} selectors Array of CSS selectors for matching the
 *     currently playing context.
 * @param {number} index The currently playing index.
 *
 * @return {Array.<HTMLElement>} Array of DOM nodes.
 */
function getContextNodesForRanges(containerNode, selectors, index) {
  var rangeAttribute = '[data-range]';

  // It needs to search for all range elements somewhere inside an element
  // marked up as a context, as well as range elements that themselves are
  // contexts.
  selectors = selectors.map(function (selector) {
    var rangeInContextSelector = selector + ' ' + rangeAttribute;
    var rangedContextSelector = selector + rangeAttribute;
    var rangeSelector = rangeInContextSelector + ', ' + rangedContextSelector;
    return rangeSelector;
  });

  var rangeNodes = $(containerNode).search(selectors.join(', '));
  if (rangeNodes) {
    rangeNodes = Array.prototype.slice.call(rangeNodes);
  } else {
    rangeNodes = [];
  }

  return filterRanges(index, rangeNodes);
}

/**
 * Return a new array of nodes where nodes that specify a range that doesn't
 * match the currently playing index are removed.
 *
 * @param {number=} index The currently playing index. Can be undefined/null.
 * @param {Array.<HTMLElement>} nodes Array of DOM nodes.
 *
 * @return {Array.<HTMLElement>} Array of DOM nodes.
 */
function filterRanges(index, nodes) {
  var thisRange = index != null ? new Range(index, index + 1) : null;

  return nodes.filter(function (node) {
    node = $(node);
    var range = node.data('range');

    // Node without a range should always be active
    if (!range) return true;

    // If player has no index, but the node has a range, we can't be sure if
    // it's playing
    if (!thisRange) return false;

    range = Range.fromString(range);
    return range.contains(thisRange);
  });
}

},{"../../spotify-elements":45,"../../spotify-live":212,"../../spotify-range2":251,"./actions":71,"./updates":73,"./utils":74,"mout/array/find":328}],76:[function(require,module,exports){
'use strict';

var live = require('../../spotify-live');
var Range = require('../../spotify-range2');
var $ = require('../../spotify-elements');

var playerActions = require('./actions');
var playerUpdates = require('./updates');
var utils = require('./utils');

var isAttached = false;

exports.attach = function () {
  if (isAttached) return;
  isAttached = true;

  playerActions.setMethods({
    getPlayerVariantUri: getPlayerVariantUri,
    handlePlayButton: handlePlayButton,
    handlePlayFromRow: handlePlayFromRow
  });

  playerUpdates.setMethods({
    getPlayerVariantUri: getPlayerVariantUri,
    getPlayerIsPlaying: getPlayerIsPlaying,
    getPlayingNodes: getPlayingNodes,
    subscribeToPlayerChange: subscribeToPlayerChange
  });

  playerActions.attach();
  playerUpdates.attach();
};

exports.detach = function () {
  if (!isAttached) return;
  isAttached = false;

  playerActions.detach();
  playerUpdates.detach();
};

exports.update = function (optNode) {
  if (!isAttached) return;

  playerUpdates.update(optNode);
};

/**
 * Get the variant URI for the currently playing context. For example, if
 * playing a sorted playlist, this should return the sorted URI.
 *
 * @return {string} The context variant URI, or empty string if nothing is
 *     playing.
 */
function getPlayerVariantUri() {
  var variant = live('spotify:player').get('variant');
  return variant ? variant.uri : '';
}

/**
 * Get the index of the currently playing page.
 *
 * @return {number} The page index, or -1 if not found.
 */
function getPlayerPageIndex() {
  var indexObject = live('spotify:player').get('index');
  var pageIndex = indexObject && indexObject.get('page');
  var hasPageIndex = typeof pageIndex === 'number';
  return hasPageIndex ? pageIndex : -1;
}

/**
 * Get the UID of the currently playing track.
 *
 * @return {string} The UID, or empty string if not found.
 */
function getPlayerTrackUid() {
  return live('spotify:player').get('uid') || '';
}

/**
 * Get the uri of the currently playing track.
 *
 * @return {string} The uri, or empty string if not found.
 */
function getPlayerTrackUri() {
  var track = live('spotify:player').get('track');
  return track ? track.get('uri') || '' : '';
}

/**
 * Get the URI of the currently playing track.
 *
 * @return {string} The track URI, or empty string if nothing is playing.
 */
function getPlayerTrackUri() {
  var track = live('spotify:player').get('track');
  return track && track.uri || '';
}

/**
 * Get the playing status of the player.
 *
 * @return {boolean} True if the player is currently playing audio.
 */
function getPlayerIsPlaying() {
  var isPlaying = live('spotify:player').get('isPlaying');
  var isPaused = live('spotify:player').get('isPaused');
  return isPlaying && !isPaused;
}

/**
 * Get whether the playback was initiated from open.spotify.com
 *
 * This info is needed to be able to do a best-effort of highlighting rows when
 * playing from open.
 *
 * @return {boolean} True if playing from open.spotify.com.
 */
function getPlayerIsPlayingFromOpen() {
  var playOrigin = live('spotify:player').get('playOrigin');
  var externalReferrer = playOrigin && playOrigin.get('externalReferrer');

  return externalReferrer && externalReferrer.indexOf('https://open.spotify.com/') === 0;
}

/**
 * Subscribe to player changes.
 *
 * @param {Function} handler A handler function. The data passed to this
 *     function is irrelevent, only the fact that something changed is needed.
 *
 * @return {Object} An object with a `cancel` method to cancel the subscription.
 */
function subscribeToPlayerChange(handler) {
  live('spotify:player').on('update', handler);
  var active = true;
  return {
    cancel: function cancel() {
      if (active) {
        live('spotify:player').off('update', handler);
        active = false;
      }
    }
  };
}

/**
 * Handle the click of a play button.
 * This function should decide what the action should be, and pause/resume
 * playback or start playback of a new context.
 *
 * @param {HTMLElement} buttonNode A button DOM node.
 * @param {Object} data Object of data about the action:
 *     isPlayingContext: (boolean) Whether the button looks to be representing
 *         the currently playing context.
 *     contextUri: (string) The context URI for the button.
 *     source: (string) The 'play source' value, for logging purposes.
 *     reason: (string) The 'play reason' value, for logging purposes.
 */
function handlePlayButton(buttonNode, data) {
  var isPlaying = data.isPlayingContext;

  var button = $(buttonNode);

  var trackUid = utils.getAttributeValueFromNode(buttonNode, 'data-uid');
  var trackUri = utils.getAttributeValueFromNode(buttonNode, 'data-track-uri');
  var pageIndex = parseInt(utils.getAttributeValueFromNode(buttonNode, 'data-context-page'), 10);

  if (isPlaying) {
    isPlaying = verifyIsPlayingIndex(trackUid, trackUri, pageIndex);
  }

  if (isPlaying) {
    if (getPlayerIsPlaying()) {
      live('spotify:player').emit('pause');
    } else {
      live('spotify:player').emit('resume');
    }
  } else {

    var eventData = {
      context: data.contextUri,
      source: data.source,
      reason: data.reason
    };

    if (trackUid) {
      eventData.uid = trackUid;
    }

    if (trackUri) {
      eventData.trackUri = trackUri;
    }

    if (!isNaN(pageIndex)) {
      eventData.page = pageIndex;
    }

    live('spotify:player').emit('play', eventData);
  }
}

/**
 * Verify that a uid, uri or pageIndex is playing, or that just the context
 * is playing when none of that is set.
 * This is used when we already know that we're playing the context.
 *
 * @param {string} trackUid
 * @param {string} trackUri
 * @param {number} pageIndex
 *
 * @return {boolean} True if it's really playing
 */
function verifyIsPlayingIndex(trackUid, trackUri, pageIndex) {
  if (trackUid) {
    var playerTrackUid = getPlayerTrackUid();
    return playerTrackUid === trackUid;
  }

  if (trackUri) {
    var playerTrackUri = getPlayerTrackUri();
    return playerTrackUri === trackUri;
  }

  if (!isNaN(pageIndex)) {
    var playerPageIndex = getPlayerPageIndex();
    return playerPageIndex === pageIndex;
  }

  // No index given also means it's really playing.
  return true;
}

/**
 * Handle playing a list row. This function should start playback of a context
 * starting from a specific row.
 *
 * @param {HTMLElement} rowNode A DOM node for a list row.
 * @param {Object} data Object of data about the action:
 *     contextUri: (string) The context URI for the list.
 *     source: (string) The 'play source' value, for logging purposes.
 *     reason: (string) The 'play reason' value, for logging purposes.
 */
function handlePlayFromRow(rowNode, data) {
  var eventData = {
    context: data.contextUri,
    source: data.source,
    reason: data.reason
  };

  var uid = rowNode.getAttribute('data-uid');
  if (uid) {
    eventData.uid = uid;
  }

  var pageIndex = parseInt(utils.getAttributeValueFromNode(rowNode, 'data-context-page'), 10);
  if (!isNaN(pageIndex)) {
    eventData.page = pageIndex;
  }

  live('spotify:player').emit('play', eventData);
}

/**
 * Get the nodes inside the passed container node that should be marked as
 * playing.
 *
 * @param {HTMLElement} containerNode The DOM node to search inside.
 * @param {Array.<HTMLElement>} contextNodes Array of DOM nodes that are already
 *     matched based on context URIs. These can be filtered if needed, but
 *     otherwise they should be included in the return value.
 *
 * @return {Array.<HTMLElement>} An array of DOM nodes.
 */
function getPlayingNodes(containerNode, contextNodes) {
  var playerPageIndex = getPlayerPageIndex();
  var playerTrackUid = getPlayerTrackUid();
  var playerTrackUri = getPlayerTrackUri();
  var variantUri = getPlayerVariantUri();

  // Remove any matched context nodes that have a page specified and where
  // the current player page does not match.
  var filteredContextNodes = filterPages(playerPageIndex, contextNodes);

  var selectors = utils.getContextSelectors(variantUri);
  var rowNodes = getContextNodesForRows(containerNode, selectors, playerTrackUid, playerTrackUri) || [];

  var selectorsWithVariants = utils.getContextSelectorsWithVariants(variantUri);
  var pageNodes = getContextNodesForPages(containerNode, selectorsWithVariants, playerPageIndex) || [];

  var buttonNodes = [];
  if (contextNodes.length) {
    buttonNodes = $(contextNodes).search('[data-button=play-context]');
  }

  // Let `elements` remove any duplicate nodes
  var nodes = $([filteredContextNodes, rowNodes, pageNodes, buttonNodes]);

  return nodes ? Array.prototype.slice.call(nodes) : [];
}

/**
 * Get the nodes inside the passed container node that match what's currently
 * playing and are list rows.
 *
 * @param {HTMLElement} containerNode The DOM node to search inside.
 * @param {Array.<string>} selectors Array of CSS selectors for matching the
 *     currently playing context.
 * @param {string} trackUid The UID of the currently playing track.
 *
 * @return {Array.<HTMLElement>} Array of DOM nodes.
 */
function getContextNodesForRows(containerNode, selectors, trackUid, trackUri) {

  // When playing from this client, we highlight the playing UIDs.
  var useTrackSelector = getPlayerIsPlayingFromOpen();

  var selector = selectors.map(function (selector) {
    selector += ' ';
    if (useTrackSelector) selector += '[data-uri=' + trackUri + ']';
    if (!useTrackSelector) selector += '[data-uid=' + trackUid + ']';
    return selector;
  }).join(', ');

  var nodes = $(containerNode).search(selector);
  if (nodes) {
    nodes = Array.prototype.slice.call(nodes);

    if (useTrackSelector) {
      // Gets UID of the first node and find all the nodes
      // with the same UID
      var firstUid = $(nodes[0]).data('uid');
      nodes = nodes.filter(function (row, i) {
        return firstUid === $(row).data('uid');
      });
    }
  } else {
    nodes = [];
  }

  return nodes;
}

/**
 * Get the nodes inside the passed container node that match what's currently
 * playing and have a matching page specified.
 *
 * @param {HTMLElement} containerNode The DOM node to search inside.
 * @param {Array.<string>} selectors Array of CSS selectors for matching the
 *     currently playing context.
 * @param {number} playerPageIndex The currently playing page index.
 *
 * @return {Array.<HTMLElement>} Array of DOM nodes.
 */
function getContextNodesForPages(containerNode, selectors, playerPageIndex) {
  var pageAttribute = '[data-context-page]';

  // It needs to search for all range elements somewhere inside an element
  // marked up as a context, as well as range elements that themselves are
  // contexts.
  selectors = selectors.map(function (selector) {
    var pageInContextSelector = selector + ' ' + pageAttribute;
    var pagedContextSelector = selector + pageAttribute;
    var pageSelector = pageInContextSelector + ', ' + pagedContextSelector;
    return pageSelector;
  });

  var pageNodes = $(containerNode).search(selectors.join(', '));
  if (pageNodes) {
    pageNodes = Array.prototype.slice.call(pageNodes);
  } else {
    pageNodes = [];
  }

  return filterPages(playerPageIndex, pageNodes);
}

/**
 * Return a new array of nodes where nodes that specify a context page that
 * doesn't match the currently playing context page are removed.
 *
 * @param {number} playerPageIndex The currently playing page index.
 * @param {Array.<HTMLElement>} contextNodes Array of already matched nodes.
 *
 * @return {Array.<HTMLElement>} Array of filtered nodes.
 */
function filterPages(playerPageIndex, contextNodes) {
  return contextNodes.filter(function (node) {
    var nodePageIndex = parseInt(node.getAttribute('data-context-page'), 10);

    // Node without a page should always be active
    if (isNaN(nodePageIndex)) return true;

    // If player has no page, but the node has a page, we can't be sure if it's
    // playing.
    if (isNaN(playerPageIndex)) return false;

    // Node that matches the player page should be active
    return playerPageIndex === nodePageIndex;
  });
}

},{"../../spotify-elements":45,"../../spotify-live":212,"../../spotify-range2":251,"./actions":71,"./updates":73,"./utils":74}],77:[function(require,module,exports){
'use strict';

var Range = require('../spotify-range2');

var contains = require('mout/array/contains');

var $ = require('../spotify-elements');

var SYNC = require('prime/emitter').EMIT_SYNC;

var throttle = require('./util/throttle');
var ListManager = require('./util/ListManager.js');

var center = require('./center');

var doc = $(document);
var win = $(window);

var scrollContainers = [];
var listManagers = [];
var scrollHandlers = [];
var pendingScrollContainers = [];
var pendingHiddenIndices = [];
var cleanupHandlers = [];

var getBounds = function getBounds(view, container) {
  var dde = document.documentElement;

  if (view === window || view === document.body) view = dde;
  var viewTop = view === dde ? 0 : view.getBoundingClientRect().top;

  var viewHeight = view.clientHeight;
  var containerTop = container.getBoundingClientRect().top;
  var containerHeight = container.offsetHeight;

  var viewBox = {
    top: viewTop,
    height: viewHeight,
    bottom: viewTop + viewHeight
  };

  var containerBox = {
    top: containerTop,
    height: containerHeight,
    bottom: containerTop + containerHeight
  };

  return {
    view: viewBox,
    container: containerBox
  };
};

var getRange = function getRange(view, container, height, hotZone) {
  hotZone = hotZone || 0;
  var bounds = getBounds(view, container);
  var top = -(bounds.container.top - bounds.view.top);
  var startsAt = Math.floor((top - hotZone) / height);
  var endsAt = Math.ceil((top + bounds.view.height + hotZone) / height);
  if (startsAt < 0) startsAt = 0;
  if (endsAt <= startsAt) return false;
  return new Range(startsAt, endsAt);
};

var init = function init(view, container, length, height, tag) {
  var view0 = view[0];
  var container0 = container[0];

  container.addClass('scroll-container-enabled');

  var manager = new ListManager(container0, {
    height: height,
    length: length,
    tag: tag,
    debug: false,
    request: function request(range, callback) {
      center.emit('scroll-request', container0, range, callback, SYNC);
    }
  });
  listManagers.push(manager);

  // Update the manager with previously saved hidden indices.
  // This allows the scroller to take hidden indices into account even for the
  // first render.
  var pendingIndex = pendingScrollContainers.indexOf(container);
  if (pendingIndex > -1) {
    manager.reset(length, pendingHiddenIndices[pendingIndex]);
    pendingScrollContainers.splice(pendingIndex, 1);
    pendingHiddenIndices.splice(pendingIndex, 1);
  }

  manager.on('before-show', function (range, nodes) {
    center.emit('scroll-show-before', {
      pageNode: container,
      container: container,
      range: range,
      nodes: nodes
    }, SYNC);
  });

  manager.on('after-show', function (range, nodes) {
    center.emit('scroll-show-after', {
      pageNode: container,
      container: container,
      range: range,
      nodes: nodes
    }, SYNC);
  });

  manager.on('index-change', function (index) {
    center.emit('scroll-index-change', {
      pageNode: container,
      container: container,
      ranges: index
    }, SYNC);
  });

  var hasRequestedMore = false;

  var scroll = function scroll() {
    var bounds = getBounds(view0, container0);
    var show = getRange(view0, container0, height);

    if (show) {
      var padding = 2;
      show = new Range(show.start - padding, show.end + padding);
      manager.show(new Range(show.start, show.end));
    }

    // If the scroll position is close enough to the end, an event should be
    // emitted to allow for more content to be loaded. Not all lists will use this,
    // but some lists want to lazy load content by loading more when you reach the
    // bottom, and then they can listen for this event.
    if (!hasRequestedMore) {
      if (bounds.container.bottom < 2000) {
        hasRequestedMore = true;

        // Emit the event and also pass a callback to the event.
        // The receiver of this event should pass the new total length of the list
        // as the second argument to the callback.
        center.emit('scroll-request-more', container0, function (error, length) {
          if (error) throw error;
          hasRequestedMore = false;
          scrollReset(container0, length);
        });
      }
    }
  };

  scrollHandlers.push(scroll);

  scroll = container._scrollEvent = throttle(scroll);

  var scrollReset = function scrollReset(c, height, opt_hiddenIndices, opt_fromIndex) {
    if ($(c) === container) {
      var hasFromIndex = typeof opt_fromIndex === 'number';
      if (hasFromIndex && opt_fromIndex > 0) {
        manager.resetFrom(opt_fromIndex, height, opt_hiddenIndices);
      } else {
        manager.reset(height, opt_hiddenIndices);
      }
      scroll();
    }
  };

  center.on('scroll-reset', scrollReset);
  container._scrollResetEvent = scrollReset;

  var scrollToIndex = function scrollToIndex(c, index, opt_offsetScrollPosition) {
    if (view0 !== window) {
      throw new Error('Can\'t scroll to index if view is not `window`');
      return;
    }

    if ($(c) === container) {
      var bounds = getBounds(view0, container0);

      // Let's say we scroll the sidebar to show the playlist at 200px from
      // the top or the bottom (depending if it was above or below fold).
      // If the sidebar height is smaller than 400px, we vertically center the
      // playlist:
      var offset = Math.min(opt_offsetScrollPosition || 0, (bounds.view.height - manager.height) / 2);

      var indexTopRelativeToContainer = manager.height * index;
      var position = bounds.container.top + indexTopRelativeToContainer;

      var scrollY = position + window.pageYOffset;
      var stickyOffset = (doc.search('[data-sticky-active]') || []).map(function (sticky) {
        return sticky.offsetHeight;
      }).reduce(function (a, b) {
        return a + b;
      }, 0);

      if (position <= stickyOffset) {
        // item is above viewport
        scrollY -= offset + stickyOffset;
      } else if (position + manager.height > bounds.view.height) {
        // item is below viewport
        scrollY += offset + manager.height - bounds.view.height;
      } else {
        // item is in viewport
        return;
      }

      view0.scrollTo(0, scrollY);
    }
  };

  center.on('scroll-to-index', scrollToIndex);

  view.on('scroll', scroll);
  win.on('resize', scroll);
  scroll();

  cleanupHandlers.push(function () {
    center.off('scroll-reset', scrollReset);
    center.off('scroll-to-index', scrollToIndex);
    view.off('scroll', scroll);
    win.off('resize', scroll);

    container.removeClass('scroll-container-enabled');
  });
};

function onScrollSetHidden(data) {
  var hiddenIndices = data.indices;

  var container = $(data.itemContainer);
  var index = scrollContainers.indexOf(container);
  if (index > -1) {
    var manager = listManagers[index];
    if (manager) {
      manager.reset(manager.length, hiddenIndices);
    }
    var scrollHandler = scrollHandlers[index];
    if (scrollHandler) {
      scrollHandler();
    }
  } else {
    pendingScrollContainers.push(container);
    pendingHiddenIndices.push(hiddenIndices);
  }
}

var isAttached = false;

exports.update = function (node) {
  if (!isAttached) return;

  node = $(node) || doc;

  var scrollNodes = doc.search('[data-scroll-container]');

  var handlers = [];
  var managers = [];
  scrollContainers = scrollContainers.filter(function (container, index) {
    if (!contains(scrollNodes, container[0])) {
      container._view.off('scroll', container._scrollEvent);
      win.off('resize', container._scrollEvent);
      center.off('scroll-reset', container._scrollResetEvent);
      delete container._scrollEvent;
      delete container._scrollResetEvent;
      return false;
    }
    managers.push(listManagers[index]);
    handlers.push(scrollHandlers[index]);
    return true;
  });
  listManagers = managers;
  scrollHandlers = handlers;

  if (node !== doc) scrollNodes = node.search('[data-scroll-container]');

  if (scrollNodes) scrollNodes.forEach(function (node0) {
    var container = $(node0);

    if (container._scrollEvent || node0.children.length) return;

    scrollContainers.push(container);
    var view = container.parent('[data-scroll-view]') || win;
    container._view = view;

    var callback = function callback(error, children, length) {
      if (error) throw error;
      children = $(children);
      children.insert(container);

      var second = children[1];
      var height = second.offsetHeight;
      var tag = $(second).tag();
      children.remove();
      init(view, container, length, height, tag);
    };

    center.emit('scroll-request', container[0], new Range(0, 3), callback, SYNC);
  });
};

exports.attach = function () {
  if (isAttached) return;
  isAttached = true;

  center.on('scroll-set-hidden', onScrollSetHidden);
};

exports.detach = function () {
  if (!isAttached) return;
  isAttached = false;

  center.off('scroll-set-hidden', onScrollSetHidden);

  cleanupHandlers.forEach(function (cleanupHandler) {
    cleanupHandler();
  });
  cleanupHandlers = [];
};

},{"../spotify-elements":45,"../spotify-range2":251,"./center":52,"./util/ListManager.js":100,"./util/throttle":106,"mout/array/contains":323,"prime/emitter":374}],78:[function(require,module,exports){
'use strict';

/**
 * Module for handling clicks on the scroll bar track to scroll pages.
 *
 * @private
 */

var BezierEasing = require('bezier-easing');

var config = require('./config');

module.exports = {

  // Called from outside
  setHandler: function setHandler(eventName, scroller, handler) {
    if (eventName === 'clickEnd') {
      scroller._clickEndHandler = handler;
    }
  },

  scrollTo: function scrollTo(scroller, newPosition, useEasing, callback) {
    var startPosition = scroller.view.scrollTop;
    var positionDiff = newPosition - startPosition;

    var startTimestamp = Date.now();
    var totalTime = config.scrollToTransitionMs;

    if (!useEasing) {
      totalTime = config.scrollToLinearTransitionMs;
    }

    // Ease in/out quadratic
    var easing = new BezierEasing(0.455, 0.03, 0.515, 0.955);

    var tick = function tick() {
      var elapsedTime = Date.now() - startTimestamp;
      var totalPercentage = elapsedTime / totalTime;

      var currentPercentage = useEasing ? easing.get(totalPercentage) : totalPercentage;

      scroller.view.scrollTop = startPosition + positionDiff * currentPercentage;

      if (totalPercentage < 1) {
        // Must use setTimeout to not make it flicker. Setting scrollTop in
        // requestAnimationFrame will make it scroll and in the next frame allow
        // the scroll handlers to move elements, making it look very flickery.
        setTimeout(tick, config.frameMs);
      } else {
        scroller.view.scrollTop = startPosition + positionDiff;
        scroller.isClickScrollAnimating = false;
        if (callback) {
          callback();
        }
      }
    };

    scroller.isClickScrollAnimating = true;
    setTimeout(tick, config.frameMs);
  },

  holdClick: function holdClick(scroller) {
    var targetThumbEdge = scroller.clickTargetThumbTop;
    var newPosition = this.getNextScrollValue(scroller);
    var newThumbTop = newPosition / scroller.viewScrollHeight * scroller.viewHeight;
    var newThumbBottom = newThumbTop + scroller.thumbHeight;
    var direction = scroller.clickTargetDirection;

    var isValid = false;
    if (direction === 'up' && newThumbBottom > targetThumbEdge) {
      isValid = true;
    } else if (direction === 'down' && newThumbTop < targetThumbEdge) {
      isValid = true;
    }

    if (isValid) {
      var useEasing = false;

      this.scrollTo(scroller, newPosition, useEasing, function () {
        if (scroller.isClickScrolling) {
          this.holdClick(scroller);
        }
      }.bind(this));
    }
  },

  getNextScrollValue: function getNextScrollValue(scroller) {
    var change = scroller.viewHeight * config.clickScrollDistanceFactor;

    if (scroller.clickTargetDirection === 'up') {
      return scroller.view.scrollTop - change;
    }

    return scroller.view.scrollTop + change;
  },

  setMovementData: function setMovementData(scroller, clientY) {
    var trackTop = scroller.scrollBarTrack.getBoundingClientRect().top;
    var targetThumbEdge = clientY - trackTop;
    var direction = targetThumbEdge < scroller.thumbTop ? 'up' : 'down';

    scroller.clickTargetDirection = direction;
    scroller.clickTargetThumbTop = targetThumbEdge;
  },

  onClickHold: function onClickHold(scroller) {
    scroller.isClickScrolling = true;

    this.holdClick(scroller);
  },

  onMouseMove: function onMouseMove(scroller, event) {
    if (scroller.isMouseOver && event.target === scroller.scrollBarTrack) {
      this.setMovementData(scroller, event.clientY);

      if (scroller.isClickScrolling && !scroller.isClickScrollAnimating) {
        this.holdClick(scroller);
      }
    }
  },

  onMouseUp: function onMouseUp(scroller) {
    scroller.isClickScrolling = false;

    clearTimeout(scroller.clickHoldTimer);

    this.removeHandlers(scroller);

    if (scroller._clickEndHandler) {
      scroller._clickEndHandler();
    }
  },

  onTrackMouseDown: function onTrackMouseDown(scroller, event) {
    var isVisible = scroller.isVisible;
    var isPrimaryButton = event.button === 0;
    var isTargetTrack = event.target === scroller.scrollBarTrack;

    if (isVisible && isPrimaryButton && isTargetTrack) {
      var navigator = window.navigator;
      var isMac = navigator && navigator.userAgent.indexOf('Mac') > -1;
      var isWindows = navigator && navigator.userAgent.indexOf('Windows') > -1;

      if (isMac && event.altKey || isWindows && event.shiftKey) {
        var trackTop = scroller.scrollBarTrack.getBoundingClientRect().top;
        var targetThumbCenter = event.clientY - trackTop;
        var targetThumbTop = Math.max(0, Math.min(scroller.viewHeight - scroller.thumbHeight, targetThumbCenter - scroller.thumbHeight / 2));

        scroller.view.scrollTop = targetThumbTop / (scroller.viewHeight - scroller.thumbHeight) * (scroller.viewScrollHeight - scroller.viewHeight);
      } else {
        this.setMovementData(scroller, event.clientY);

        var targetPosition = this.getNextScrollValue(scroller);
        var useEasing = true;

        this.scrollTo(scroller, targetPosition, useEasing);

        this.addHandlers(scroller);

        scroller.clickHoldTimer = setTimeout(this.onClickHold.bind(this, scroller), config.scrollToTransitionMs + config.clickHoldDelayMs);
      }
    }
  },

  addHandlers: function addHandlers(scroller) {
    scroller._click_onMouseUp = this.onMouseUp.bind(this, scroller);
    scroller._click_onMouseMove = this.onMouseMove.bind(this, scroller);

    document.addEventListener('mouseup', scroller._click_onMouseUp, false);
    document.addEventListener('mousemove', scroller._click_onMouseMove, false);
  },

  removeHandlers: function removeHandlers(scroller) {
    document.removeEventListener('mouseup', scroller._click_onMouseUp, false);
    document.removeEventListener('mousemove', scroller._click_onMouseMove, false);
  },

  attach: function attach(scroller) {
    var onTrackMouseDown = this.onTrackMouseDown.bind(this, scroller);

    scroller.scrollBarTrack.addEventListener('mousedown', onTrackMouseDown, false);

    return function () {
      scroller.scrollBarTrack.removeEventListener('mousedown', onTrackMouseDown, false);
    };
  }

};

},{"./config":79,"bezier-easing":281}],79:[function(require,module,exports){
"use strict";

/**
 * Config with all timer values etc. Easy to have them all in one place, and it
 * also helps for testing, since the config can be used from there too.
 *
 * @private
 */

module.exports = {
  hideAfterMs: 750,
  showAfterMs: 500,

  // Sync with CSS transition duration
  hideTransitionMs: 500,

  expandDelayMs: 150,

  frameMs: 16,
  scrollToTransitionMs: 200,
  scrollToLinearTransitionMs: 120,
  clickHoldDelayMs: 500,
  clickScrollDistanceFactor: 0.95
};

},{}],80:[function(require,module,exports){
'use strict';

/**
 * Module for handling dragging the scroll bar thumb to scroll.
 *
 * @private
 */

module.exports = {

  // Called from outside
  setHandler: function setHandler(eventName, scroller, handler) {
    if (eventName === 'dragStart') {
      scroller._dragStartHandler = handler;
    } else if (eventName === 'dragEnd') {
      scroller._dragEndHandler = handler;
    }
  },

  onThumbMouseDown: function onThumbMouseDown(scroller, event) {
    if (event.button === 0 && scroller.isVisible) {
      scroller.isDragging = true;
      scroller.startDragMouseY = event.clientY;
      scroller.startDragThumbTop = scroller.thumbTop;

      this.addDragHandlers(scroller);

      if (scroller._dragStartHandler) {
        scroller._dragStartHandler();
      }
    }
  },

  onMouseUp: function onMouseUp(scroller, event) {
    if (scroller.isDragging) {
      scroller.isDragging = false;

      this.removeDragHandlers(scroller);

      if (scroller._dragEndHandler) {
        scroller._dragEndHandler();
      }
    }
  },

  onMouseMove: function onMouseMove(scroller, event) {
    var y = event.clientY;
    var startY = scroller.startDragMouseY;

    scroller.thumbTop = Math.max(0, Math.min(scroller.viewHeight - scroller.thumbHeight, scroller.startDragThumbTop + y - startY));

    scroller.view.scrollTop = scroller.thumbTop / (scroller.viewHeight - scroller.thumbHeight) * (scroller.viewScrollHeight - scroller.viewHeight);
  },

  addDragHandlers: function addDragHandlers(scroller) {
    scroller._drag_onMouseMove = this.onMouseMove.bind(this, scroller);
    scroller._drag_onMouseUp = this.onMouseUp.bind(this, scroller);

    document.addEventListener('mousemove', scroller._drag_onMouseMove, false);
    document.addEventListener('mouseup', scroller._drag_onMouseUp, false);
  },

  removeDragHandlers: function removeDragHandlers(scroller) {
    document.removeEventListener('mousemove', scroller._drag_onMouseMove, false);
    document.removeEventListener('mouseup', scroller._drag_onMouseUp, false);
  },

  attach: function attach(scroller) {
    var onThumbMouseDown = this.onThumbMouseDown.bind(this, scroller);

    scroller.scrollBarThumb.addEventListener('mousedown', onThumbMouseDown, false);

    return function () {
      scroller.scrollBarThumb.removeEventListener('mousedown', onThumbMouseDown, false);
    };
  }

};

},{}],81:[function(require,module,exports){
'use strict';

/**
 * Module for handling expanding the scroll bar width on hover.
 *
 * @private
 */

var config = require('./config');

module.exports = {

  expand: function expand(scroller) {
    clearTimeout(scroller.resetExpandedTimer);
    scroller.scrollBarTrack.classList.add('expanded');
  },

  collapse: function collapse(scroller) {
    scroller.scrollBarTrack.classList.remove('expanded');
  },

  // Called from outside
  onHide: function onHide(scroller) {
    if (!scroller.alwaysVisible) {
      clearTimeout(scroller.expandTimer);
      clearTimeout(scroller.resetExpandedTimer);

      scroller.resetExpandedTimer = setTimeout(this.collapse.bind(this, scroller), config.hideTransitionMs);
    }
  },

  onTrackMouseEnter: function onTrackMouseEnter(scroller, event) {
    if (event.target === scroller.scrollBarTrack) {
      if (scroller.isVisible) {
        clearTimeout(scroller.expandTimer);
        clearTimeout(scroller.resetExpandedTimer);
        scroller.expandTimer = setTimeout(function () {
          this.expand(scroller);
        }.bind(this), config.expandDelayMs);
      } else {
        this.expand(scroller);
      }
    }
  },

  onTrackMouseLeave: function onTrackMouseLeave(scroller, event) {
    if (event.target === scroller.scrollBarTrack) {
      if (scroller.isVisible) {
        clearTimeout(scroller.expandTimer);
      } else {
        this.collapse(scroller);
      }
    }
  },

  attach: function attach(scroller) {
    if (scroller.alwaysVisible) {
      this.expand(scroller);

      return function () {};
    } else {
      this.collapse(scroller);

      var onTrackMouseEnter = this.onTrackMouseEnter.bind(this, scroller);
      var onTrackMouseLeave = this.onTrackMouseLeave.bind(this, scroller);

      scroller.scrollBarTrack.addEventListener('mouseenter', onTrackMouseEnter, false);
      scroller.scrollBarTrack.addEventListener('mouseleave', onTrackMouseLeave, false);

      return function () {
        scroller.scrollBarTrack.removeEventListener('mouseenter', onTrackMouseEnter, false);
        scroller.scrollBarTrack.removeEventListener('mouseleave', onTrackMouseLeave, false);
      };
    }
  }

};

},{"./config":79}],82:[function(require,module,exports){
'use strict';

var glue = require('../../spotify-glue-cat');
var cosmos = require('spotify-cosmos-api');

var center = require('../center');
var drag = require('./drag');
var visibility = require('./visibility');
var position = require('./position');
var expansion = require('./expansion');
var click = require('./click');

var scrollers = [];
var scrollerStyle = null;

function Scroller(scrollView) {
  this.view = scrollView;
  this.setInitialState();
  this.addScrollBar();
  this.refresh();

  this.view.setAttribute('data-scroll-area-initialized', '');

  this._onResize = function () {
    this.refresh();
  }.bind(this);
  this._onScroll = function () {
    this.refreshScrollBar();
  }.bind(this);
  this._onThumbDragStart = function (event) {
    event.preventDefault();
    event.stopPropagation();
  };

  // Listen for the scroll event to update view size etc on scroll
  var scrollObject = this.isBody ? window : this.view;
  scrollObject.addEventListener('scroll', this._onScroll, false);

  // Listen for the window resize event, even for scroll areas that are not the
  // body scroll. Since we can't listen for resize events when elements resize,
  // we do a best effort of at least updating when the window resizes (which
  // might affect the size of the scroll area).
  window.addEventListener('resize', this._onResize, false);

  // Prevent dragndrop handling from spotify-events (it will be triggered
  // otherwise since we have to set the draggable attribute to not trigger
  // focus events).
  this.scrollBarThumb.addEventListener('dragstart', this._onThumbDragStart, true);

  this._detachVisibility = visibility.attach(this);
  this._detachPosition = position.attach(this);
  this._detachDrag = drag.attach(this);
  this._detachClick = click.attach(this);
  this._detachExpansion = expansion.attach(this);

  visibility.setHandler('show', this, function () {
    this.refresh();
  }.bind(this));

  visibility.setHandler('hide', this, function () {
    expansion.onHide(this);
  }.bind(this));

  // Events are sent when dragging to allow some use cases where you need to do
  // something while dragging. For example, when dragging the scroll bar in the
  // app sidebar and hovering over the main view, it will not trigger mousemove
  // events since the main view is an iframe. To counter that, zlink is
  // listening to these events and sets pointer-events on the content area.
  drag.setHandler('dragStart', this, function () {
    center.emit('scroll-thumb-drag-start', { id: this.viewId });
  }.bind(this));
  drag.setHandler('dragEnd', this, function () {
    visibility.onDragEnd(this);
    center.emit('scroll-thumb-drag-end', { id: this.viewId });
  }.bind(this));

  click.setHandler('clickEnd', this, function () {
    visibility.onClickEnd(this);
  }.bind(this));
}

Scroller.prototype.setInitialState = function () {
  var scrollerStyleToUse = scrollerStyle || window.__spotify.scroller_style;
  this.alwaysVisible = scrollerStyleToUse === 'always';

  this.scrollBarTrack = null;
  this.scrollBarThumb = null;

  this.isBody = this.view === document.body;
  this.viewId = this.view.getAttribute('data-scroll-area');
  this.viewHeight = 0;
  this.viewScrollHeight = 0;

  this.isVisible = false;
  this.isDragging = false;
  this.isMouseOver = false;
  this.isClickScrolling = false;
  this.isClickScrollAnimating = false;

  this.thumbTop = 0;
  this.thumbHeight = 0;

  this.clickTargetDirection = 'down';
  this.clickTargetThumbTop = 0;

  this.startDragMouseY = 0;
  this.startDragThumbTop = 0;

  this.hideTimer = 0;
  this.mouseOverShowTimer = 0;
};

Scroller.prototype.addScrollBar = function () {
  var track = document.createElement('div');
  var thumb = document.createElement('div');

  track.className = 'scrollbar-track';
  thumb.className = 'scrollbar-thumb';

  if (this.alwaysVisible) {
    track.className += ' always-visible';
  }

  // If the thumb is not set to draggable it will trigger focus events on
  // elements being dragged over. For example, dragging the thumb up to the
  // search input puts focus in the search input, which opens the suggest box.
  // Since we will find this element from the dragndrop module, we also need to
  // prevent any drag handling (find the drag listener further down).
  thumb.setAttribute('draggable', 'true');

  track.appendChild(thumb);
  this.view.appendChild(track);

  this.scrollBarTrack = track;
  this.scrollBarThumb = thumb;
};

Scroller.prototype.setViewSize = function () {
  // Hide the scroll bar while calculating sizes, so the scroll bar doesn't
  // interfere. This can happen if scrolled to the bottom of the scroll view and
  // the scroll height changes to be smaller. If the scroll bar is not hidden
  // while calculating the values here, the scrollHeight will not change, since
  // the scroll bar is taking up space.
  this.scrollBarTrack.style.display = 'none';

  if (this.isBody) {
    this.viewHeight = window.innerHeight || Infinity;
  } else {
    this.viewHeight = this.view.clientHeight || Infinity;
  }

  this.viewScrollHeight = this.view.scrollHeight;

  this.scrollBarTrack.style.display = 'block';
};

Scroller.prototype.setThumbSize = function () {
  var percentage = this.viewHeight / this.viewScrollHeight;
  this.thumbHeight = Math.max(40, this.viewHeight * percentage);
  this.scrollBarThumb.style.height = this.thumbHeight + 'px';
};

Scroller.prototype.setTrackPosition = function () {
  this.scrollBarTrack.style.transform = 'translate3d(0, ' + (this.view.scrollTop + 'px') + ', 0)';
};

Scroller.prototype.refresh = function () {
  this.refreshView();
  this.refreshScrollBar();
};

Scroller.prototype.refreshView = function () {
  this.setViewSize();
};

Scroller.prototype.refreshScrollBar = function () {
  this.setThumbSize();

  if (!this.isBody) {
    this.setTrackPosition();
  }
};

Scroller.prototype.update = function () {
  var oldViewHeight = this.viewHeight;
  var oldScrollHeight = this.viewScrollHeight;

  this.refresh();

  visibility.update(this);

  var newViewHeight = this.viewHeight;
  var newScrollHeight = this.viewScrollHeight;

  if (newViewHeight !== oldViewHeight || newScrollHeight !== oldScrollHeight) {
    visibility.highlight(this);
  }
};

Scroller.prototype.setScrollBarMode = function (mode) {
  this.alwaysVisible = mode === 'always';

  if (this.alwaysVisible) {
    this.scrollBarTrack.classList.add('always-visible');
  } else {
    this.scrollBarTrack.classList.remove('always-visible');
  }

  this._detachVisibility();
  this._detachPosition();
  this._detachDrag();
  this._detachClick();
  this._detachExpansion();

  this._detachVisibility = visibility.attach(this);
  this._detachPosition = position.attach(this);
  this._detachDrag = drag.attach(this);
  this._detachClick = click.attach(this);
  this._detachExpansion = expansion.attach(this);
};

Scroller.prototype.isInDOM = function () {
  var currentNode = this.view.parentNode;
  while (currentNode && currentNode !== document.documentElement) {
    currentNode = currentNode.parentNode;
  }

  // If we still have a current node after the loop, we found the document
  // element, which means it's in DOM.
  return !!currentNode;
};

Scroller.prototype.destroy = function () {
  var scrollObject = this.isBody ? window : this.view;

  scrollObject.removeEventListener('scroll', this._onScroll, false);

  window.removeEventListener('resize', this._onResize, false);

  this.scrollBarThumb.removeEventListener('dragstart', this._onThumbDragStart, true);

  this.view.removeAttribute('data-scroll-area-initialized', '');
  this.view.removeChild(this.scrollBarTrack);

  this._detachVisibility();
  this._detachPosition();
  this._detachDrag();
  this._detachClick();
  this._detachExpansion();
};

var isAttached = false;
var controlMessageSubscription;

exports.update = function (node) {
  if (!isAttached) {
    return;
  }

  // Clean up scrollers that are not in DOM anymore.
  scrollers = scrollers.filter(function (scroller) {
    if (!scroller.isInDOM()) {
      scroller.destroy();
      return false;
    }
    return true;
  });

  // Update all active scrollers
  for (var i = 0, l = scrollers.length; i < l; i++) {
    scrollers[i].update();
  }

  var selector = '[data-scroll-area]';
  var scrollViews = (node || document).querySelectorAll(selector);

  for (var i = 0, l = scrollViews.length; i < l; i++) {
    if (!scrollViews[i].hasAttribute('data-scroll-area-initialized')) {
      var scrollView = scrollViews[i];
      var isBody = scrollView === document.body;

      if (isBody && glue.getVersion() !== 2) {
        continue;
      }

      scrollers.push(new Scroller(scrollView));
    }
  }
};

exports.attach = function () {
  if (isAttached) return;
  isAttached = true;

  var setScrollBarMode = function setScrollBarMode(mode) {
    scrollerStyle = mode;

    for (var i = 0, l = scrollers.length; i < l; i++) {
      scrollers[i].setScrollBarMode(mode);
    }
  };

  controlMessageSubscription = cosmos.resolver.subscribe({
    url: 'sp://messages/v1/container/control'
  }, function (error, response) {
    if (!error) {
      var data = response.getJSONBody();
      if (data) {
        var styleWasChanged = true;
        switch (data.type) {
          case 'set_scroller_style_always_visible':
            setScrollBarMode('always');
            break;
          case 'set_scroller_style_overlay':
            setScrollBarMode('overlay');
            break;
          default:
            styleWasChanged = false;
        }

        // Fix a rendering bug in Chromium. When scroller style changes in the
        // system (changing system preference, connecting/disconnecting a mouse
        // etc), Chromium will render a white area where the scroll bar is
        // supposed to be. By adding and removing a class name we're triggering
        // a re-render and it will look good.
        //
        // https://jira.spotify.net/browse/KM-8285
        // http://crbug.com/538579
        if (styleWasChanged) {
          var performFix = function performFix() {
            var nodes = scrollers.map(function (scroller) {
              return scroller.view;
            });

            // Always include body to fix the main scroll, even if it doesn't
            // have a custom scroll bar.
            if (nodes.indexOf(document.body) === -1) {
              nodes.push(document.body);
            }

            for (var i = 0, l = nodes.length; i < l; i++) {
              nodes[i].classList.add('jmeBDLRW3CRWW3kZZaZ');
              nodes[i].classList.remove('jmeBDLRW3CRWW3kZZaZ');
            }
          };

          // Perform the fix twice (once with a delay), since it sometimes might
          // be slow and won't apply the fix on the first try.
          performFix();
          setTimeout(performFix, 1000);
        }
      }
    } else {
      controlMessageSubscription.cancel();
    }
  });
};

exports.detach = function () {
  if (!isAttached) return;
  isAttached = false;

  for (var i = 0, l = scrollers.length; i < l; i++) {
    scrollers[i].destroy();
  }
  scrollers.length = 0;

  scrollerStyle = null;

  if (controlMessageSubscription) {
    controlMessageSubscription.cancel();
    controlMessageSubscription = null;
  }
};

},{"../../spotify-glue-cat":131,"../center":52,"./click":78,"./drag":80,"./expansion":81,"./position":83,"./visibility":84,"spotify-cosmos-api":388}],83:[function(require,module,exports){
'use strict';

/**
 * Module for handling updating the scroll bar thumb position when scroll
 * position changes.
 *
 * @private
 */

module.exports = {

  setThumbPosition: function setThumbPosition(scroller) {
    if (scroller.viewScrollHeight === scroller.viewHeight) {
      scroller.thumbTop = 0;
    } else {
      scroller.thumbTop = scroller.view.scrollTop / (scroller.viewScrollHeight - scroller.viewHeight) * (scroller.viewHeight - scroller.thumbHeight);
    }

    scroller.scrollBarThumb.style.transform = 'translate3d(0, ' + (scroller.thumbTop + 'px') + ', 0)';
  },

  onScroll: function onScroll(scroller) {
    this.setThumbPosition(scroller);
  },

  attach: function attach(scroller) {
    var onScroll = this.onScroll.bind(this, scroller);

    var scrollObject = scroller.isBody ? window : scroller.view;
    scrollObject.addEventListener('scroll', onScroll, false);

    this.setThumbPosition(scroller);

    return function () {
      scrollObject.removeEventListener('scroll', onScroll, false);
    };
  }

};

},{}],84:[function(require,module,exports){
'use strict';

/**
 * Module for handling the visibility of the scroll bar, based on mouse position
 * and scroll events.
 *
 * @private
 */

var config = require('./config');

module.exports = {

  // Called from outside
  setHandler: function setHandler(eventName, scroller, handler) {
    if (eventName === 'show') {
      scroller._showHandler = handler;
    } else if (eventName === 'hide') {
      scroller._hideHandler = handler;
    }
  },

  refresh: function refresh(scroller) {
    if (scroller.viewScrollHeight > scroller.viewHeight) {
      this.showScrollBar(scroller);
    } else {
      this.hideScrollBar(scroller);
    }
  },

  showScrollBar: function showScrollBar(scroller) {
    if (scroller.isVisible) {
      return;
    }

    if (scroller.viewScrollHeight > scroller.viewHeight) {
      scroller.scrollBarTrack.classList.add('visible');
      scroller.isVisible = true;

      if (scroller._showHandler) {
        scroller._showHandler();
      }
    }
  },

  hideScrollBar: function hideScrollBar(scroller) {
    if (!scroller.isVisible || scroller.isDragging) {
      return;
    }

    scroller.scrollBarTrack.classList.remove('visible');
    scroller.isVisible = false;

    if (scroller._hideHandler) {
      scroller._hideHandler();
    }
  },

  startHideTimer: function startHideTimer(scroller) {
    this.stopHideTimer(scroller);
    scroller.hideTimer = setTimeout(this.hideScrollBar.bind(this, scroller), config.hideAfterMs);
  },

  stopHideTimer: function stopHideTimer(scroller) {
    clearTimeout(scroller.hideTimer);
  },

  // Called from outside
  onDragEnd: function onDragEnd(scroller) {
    if (!scroller.alwaysVisible && !scroller.isMouseOver) {
      this.startHideTimer(scroller);
    }
  },

  // Called from outside
  onClickEnd: function onClickEnd(scroller) {
    if (!scroller.alwaysVisible && !scroller.isMouseOver) {
      this.startHideTimer(scroller);
    }
  },

  onScroll: function onScroll(scroller) {
    if (!scroller.isVisible) {
      this.showScrollBar(scroller);
    }

    if (!scroller.isDragging && !scroller.isClickScrolling && !scroller.isMouseOver) {
      this.startHideTimer(scroller);
    }
  },

  onTrackMouseEnter: function onTrackMouseEnter(scroller, event) {
    if (event.target === scroller.scrollBarTrack) {
      scroller.isMouseOver = true;

      this.stopHideTimer(scroller);

      if (!scroller.isVisible) {
        scroller.mouseOverShowTimer = setTimeout(this.showScrollBar.bind(this, scroller), config.showAfterMs);
      }
    }
  },

  onTrackMouseLeave: function onTrackMouseLeave(scroller, event) {
    if (event.target === scroller.scrollBarTrack) {
      scroller.isMouseOver = false;

      if (!scroller.isDragging && !scroller.isClickScrolling) {
        clearTimeout(scroller.mouseOverShowTimer);

        if (scroller.isVisible) {
          this.startHideTimer(scroller);
        }
      }
    }
  },

  attach: function attach(scroller) {
    if (scroller.alwaysVisible) {
      this.refresh(scroller);

      return function () {};
    } else {
      this.hideScrollBar(scroller);

      var onScroll = this.onScroll.bind(this, scroller);
      var onTrackMouseEnter = this.onTrackMouseEnter.bind(this, scroller);
      var onTrackMouseLeave = this.onTrackMouseLeave.bind(this, scroller);

      var scrollObject = scroller.isBody ? window : scroller.view;
      scrollObject.addEventListener('scroll', onScroll, false);

      scroller.scrollBarTrack.addEventListener('mouseenter', onTrackMouseEnter, false);
      scroller.scrollBarTrack.addEventListener('mouseleave', onTrackMouseLeave, false);

      return function () {
        scrollObject.removeEventListener('scroll', onScroll, false);

        scroller.scrollBarTrack.removeEventListener('mouseenter', onTrackMouseEnter, false);
        scroller.scrollBarTrack.removeEventListener('mouseleave', onTrackMouseLeave, false);
      };
    }
  },

  update: function update(scroller) {
    if (scroller.alwaysVisible) {
      this.refresh(scroller);
    }
  },

  highlight: function highlight(scroller) {
    if (!scroller.alwaysVisible && !scroller.isVisible) {
      this.showScrollBar(scroller);
      this.startHideTimer(scroller);
    }
  }

};

},{"./config":79}],85:[function(require,module,exports){
/**
 * @module spotify-events/select
 */
'use strict';

var $ = require('../spotify-elements');
var center = require('./center');

var live = require('../spotify-live');

var ATTR_SELECT = 'select';
var ATTR_PROPERTY = 'select-property';
var SELECTOR_SELECT = '[data-' + ATTR_SELECT + ']';

// Stored nodes, used to not add listeners multiple times
var storedNodes = [];

/**
 * Handle a change on a select node.
 *
 * @param {MouseEvent} event Event object.
 * @param {Elements} elem An elements DOM node for the select.
 */
function handleChange(event, elem) {
  var property = elem.data(ATTR_PROPERTY);
  var node = elem[0];
  // If a property is set, update the model. That will later trigger
  // an update of the view and a change event on center will be sent.
  if (property) {
    publish(node, property);
    // If no property is set, just emit a change event on center.
  } else {
      emitUpdate(node, selectedValue(node));
    }
}

/**
 * Return the value attribute of the selected option
 *
 * @param {Elements} elem An elements DOM node for the select
 */
function selectedValue(node) {
  var selected = node.options[node.selectedIndex];
  return selected.value;
}

/**
 * Handle when a select-option event happens on center.
 *
 * @param {Object} event An object with data.
 */
function onSelectSet(event) {
  if (!event.id) return;

  var elem = $('[data-' + ATTR_SELECT + '=' + event.id + ']');
  if (!elem) return;

  var node = elem[0];
  var value = event.selected;

  // updating the node will trigger a DOM event,
  // delegated to handleChange in this module.
  var property = elem.data(ATTR_PROPERTY);

  if (property) {
    publish(node, property, value);
  } else {
    setState(node, value);
  }
}

/**
 * Publish new data to the live model. If no data-uri is found from
 * the passed node, nothing happens.
 *
 * @param {HtmlElement} node A DOM node for the select
 * @param {string} property A property name on the live model
 * @param {string=} opt_value Optional value to set the property to.
 *     If not provided, the selected option's value is fetched from the DOM.
 */
function publish(node, property, opt_value) {
  var uri = getUriFromNode(node);
  if (!uri) return;

  var model = live(uri);

  // If the model doesn't have a current value, we can't safely
  // set a new value without maybe being wrong.
  var value = model.get(property);
  if (value === undefined) return;

  var newValue = opt_value === undefined ? selectedValue(node) : opt_value;

  var data = {};
  data[property] = newValue;

  // Publishing the new value to the model will trigger the update
  // handler added here in this module to send an center event,
  // and update the DOM if needed.
  model.publish(data);
}

/**
 * Update the state of one select node.
 *
 * @param {HTMLElement} node A DOM node for the select.
 */
function updateNode(node) {
  if (storedNodes.indexOf(node) > -1) return;
  storedNodes.push(node);

  var elem = $(node);
  var property = elem.data(ATTR_PROPERTY);
  if (!property) return;

  var uri = getUriFromNode(node);
  if (!uri) return;

  var model = live(uri);

  model.get(property, function (error, value) {
    if (error) throw error;

    setState(node, value);

    model.on('update', function (properties) {
      if (property in properties) {
        setState(node, properties[property]);
      }
    });
  });
}

/**
 * Update a select node based on a value.
 *
 * @param {HTMLElement} node A DOM node for a select.
 * @param {string} value The value attribute of the option to select
 */
function setState(node, value) {
  updateNodeWithValue(node, value);
  emitUpdate(node, value);
}

/**
 * Update a select based on an option's value attribute
 *
 * @param {HTMLElement} node A DOM node for a select.
 * @param {string} value The value attribute of the option to select
 */
function updateNodeWithValue(node, value) {
  var selectElement = $(node);
  var optionElement = selectElement.find('option[value="' + value + '"]');
  if (optionElement && !optionElement.attribute('selected')) {
    optionElement.select();
  }
}

/**
 * Emit a change event on center. It will have the following format:
 * {
 *   element: HTMLElement,
 *   id: 'id from data-select attribute' || null,
 *   selected: the new selected value
 * }
 *
 * @param {HTMLElement} node A DOM node for a select.
 * @param {string} value Attribute of the selected option
 */
function emitUpdate(node, selected) {
  var id = $(node).data(ATTR_SELECT) || null;
  center.emit('select-change', {
    element: node,
    id: id,
    selected: selected
  });
}

/**
 * Get a URI from a node.
 *
 * @param {HTMLElement} node A DOM node.
 *
 * @return {string?} A URI string or null if not found.
 */
function getUriFromNode(node) {
  var stateNode = node.closest('[data-uri]');
  if (!stateNode) return null;
  return stateNode.getAttribute('data-uri');
}

var isAttached = false;

exports.update = function (opt_node) {
  if (!isAttached) return;

  var nodes = $(opt_node || document).search(SELECTOR_SELECT);
  if (!nodes) return;

  nodes.forEach(updateNode);
};

exports.attach = function () {
  if (isAttached) return;
  isAttached = true;

  var doc = $(document);
  doc.delegate('change', SELECTOR_SELECT, handleChange);

  center.on('select-set', onSelectSet);
};

exports.detach = function () {
  if (!isAttached) return;
  isAttached = false;

  var doc = $(document);
  doc.undelegate('change', SELECTOR_SELECT, handleChange);

  center.off('select-set', onSelectSet);
};

},{"../spotify-elements":45,"../spotify-live":212,"./center":52}],86:[function(require,module,exports){
/**
 * @module spotify-events/selection/containers
 * @private
 */
'use strict';

var $ = require('../../spotify-elements');
var live = require('../../spotify-live');

/**
 * Container DOM nodes.
 *
 * @type {Array.<HTMLElement>}
 */
var containers = [];

/**
 * Forget the known containers.
 */
function reset() {
  containers.length = 0;
}

/**
 * Update container storage based on the current DOM.
 */
function update() {
  var nodes = $(document).search(':not(.sticky-clone) > [data-list]');
  if (!nodes) return;

  // Don't drop any containers. If they are removed from the DOM we just keep
  // the reference along with the selection state at the same index. Clearing
  // has to be done manually instead.

  // Append new containers to the end of the list.
  nodes.forEach(function (container) {
    if (containers.indexOf(container) === -1) {
      containers.push(container);
    }
  });
}

/**
 * Get the number of rows in the container at the specified index.
 *
 * @param {number} index The container index.
 *
 * @return {number} The number of rows.
 */
function getContainerLength(index) {
  var container = $(containers[index]);
  if (!container) return 0;

  var uri = container.data('uri');
  if (!uri) return 0;

  var list = live(uri).get('rows');
  if (!list) return 0;

  return list.length;
}

/**
 * Get the index of a container based on URI.
 *
 * @param {string} uri The URI of the container.
 *
 * @return {number} The index of the container. Returns -1 if not found.
 */
function getContainerIndex(uri) {
  for (var i = 0, l = containers.length; i < l; i++) {
    var containerUri = getUri(i);
    if (containerUri === uri) return i;
  }

  return -1;
}

/**
 * Get the URI for a container.
 *
 * @param {number} index The container index.
 *
 * @return {string?} The URI or null if not found.
 */
function getUri(index) {
  var element = containers[index];
  var uri = element && element.getAttribute('data-uri');
  return uri || null;
}

/**
 * Get the URIs for all containers.
 *
 * @return {Array.<string?>} Array of URIs.
 */
function getUris() {
  var uris = [];
  for (var i = 0, l = containers.length; i < l; i++) {
    uris.push(getUri(i));
  }
  return uris;
}

/**
 * Get the live list for a container.
 *
 * @param {number} index The container index.
 *
 * @return {LiveList?} A live list or null if not found.
 */
function getLiveList(index) {
  var uri = getUri(index);
  var list = live(uri).get('rows');
  return list || null;
}

exports.elements = containers;
exports.reset = reset;
exports.update = update;
exports.getContainerLength = getContainerLength;
exports.getContainerIndex = getContainerIndex;
exports.getUri = getUri;
exports.getUris = getUris;
exports.getLiveList = getLiveList;

},{"../../spotify-elements":45,"../../spotify-live":212}],87:[function(require,module,exports){
(function (global){
/**
 * spotify-events/selection/controller
 * @private
 */
'use strict';

var $ = require('../../spotify-elements');
var intersection = require('mout/array/intersection');
var live = require('../../spotify-live');
var liburi = require('spotify-liburi');

var center = require('../center');
var selection = require('./index');
var model = require('./model');
var rows = require('./rows');
var containers = require('./containers');
var positions = require('./positions');
var Position = require('../util/Position');
var cosmos = require('../util/cosmos');

var focusEventValid = false;

// Listeners per URI (key is URI)
var listListeners = {};
var listListenerUris = [];

var SELECTABLE = '[data-list-item]';
var CLIPBOARD_ENDPOINT = 'sp://desktop/v1/clipboard';

/**
 * Check whether the event occured on the documentElement.
 *
 * @param {Event} event A event object.
 *
 * @return {boolean}
 */
function isOnDocument(event) {
  return event.target === document.documentElement;
}

/**
 * Get the row node from a mouse event.
 *
 * @param {MouseEvent} event A mouse event object.
 *
 * @return {HTMLElement} A DOM node.
 */
function getNodeFromEvent(event) {
  return event.target.closest(SELECTABLE);
}

/**
 * Check if a target is inside a filter component.
 *
 * @param {HTMLElement} target A DOM node.
 *
 * @return {boolean} Whether the target was inside a filter component.
 */
function isFilterTarget(target) {
  return target !== document && !!target.closest('[data-filter]');
}

/**
 * Handle a mousedown event.
 *
 * @param {MouseEvent|TouchEvent} event A mouse or touch event.
 * @param {boolean=} opt_isMouseUp Pass true if this is a simulated mousedown
 *     triggered by a mouseup event.
 */
function handleMouseDown(event, opt_isMouseUp) {
  if (isOnDocument(event)) return;

  focusEventValid = false;
  var node = getNodeFromEvent(event);
  if (node) {
    handleRowMouseDown(event, node, opt_isMouseUp);
  } else {
    handleOutsideMouseDown(event);
  }
}

/**
 * Handle when the mouse is pressed down on a list row.
 *
 * @param {MouseEvent|TouchEvent} event A mouse or touch event.
 * @param {HTMLElemtn} rowNode The DOM node for the clicked row.
 * @param {boolean=} opt_isMouseUp Pass true if this is a simulated mousedown
 *     triggered by a mouseup event.
 */
function handleRowMouseDown(event, rowNode, opt_isMouseUp) {
  var button = getButtonFromEvent(event);
  var isPrimaryButton = button === 1;

  // If we can't find a valid position for the DOM node, we can't handle
  // selection correctly.
  var position = positions.getFromNode(rowNode);
  if (!position) return;

  var isSelected = model.isSelected(position);
  var singleMultiSelect = isMac() ? event.metaKey : event.ctrlKey;
  var multiselect = event.shiftKey || singleMultiSelect;
  var singleClick = !event.shiftKey;

  if (!isMultiSelectEnabled()) {
    singleMultiSelect = multiselect = false;
    singleClick = true;
  }

  // Remove selection if a selected item is clicked with cmd/ctrl
  if (multiselect && singleClick && isSelected && isPrimaryButton) {

    // For multiselect, make sure we do the deselection only on mouseup
    if (!opt_isMouseUp) return;
    handleDeselectOnSingleMultiSelect(position);

    // Select multiple items if clicked with shift key
  } else if (!singleClick) {

      // Optimize by doing this only on mousedown
      if (opt_isMouseUp) return;
      handleShiftMultiSelect(position);

      // Select a single item
    } else {

        // Handle the case when the primary button is pressed down on a selected item.
        // The method will be called once again in that case, on mouse up. This is
        // to allow the drag and drop to abort the selection change.

        // So we do the actual selection on mouseup, where we know it's not a drag n drop thing.
        if (isPrimaryButton && isSelected && !opt_isMouseUp) {
          return;
        }
        // For multiselect, make sure we do the selection only on mouseup
        if (multiselect && !opt_isMouseUp) {
          return;
        }

        handleSingleSelect(position, event, opt_isMouseUp);
      }
  rows.update();
}

/**
 * Handle when the mouse is pressed down outside a list row.
 *
 * @param {MouseEvent} event A mouse event.
 */
function handleOutsideMouseDown(event) {
  var isSort = !!event.target.closest('[data-sort]');
  var isFilter = isFilterTarget(event.target);
  var hasSelection = model.hasSelection();

  // Deselect if clicked outside the list.
  // Clicking sort headers should just sort, not clear selection.
  if (!(isSort || isFilter) && hasSelection) {
    model.clear();
    rows.update();
  }
}

/**
 * Handle a focus event.
 *
 * @param {MouseEvent} event A mouse event.
 */
function handleFocus(event) {
  if (!focusEventValid) return;
  var node = getNodeFromEvent(event);
  if (node) {
    handleRowFocus(event, node);
  } else {
    handleOutsideFocus(event);
  }
  focusEventValid = false;
}

/**
 * Handle when a row receives focus.
 *
 * @param {MouseEvent} event A mouse event.
 * @param {HTMLElement} rowNode The DOM node for the focused row.
 */
function handleRowFocus(event, rowNode) {
  var position = positions.getFromNode(rowNode);

  // Invalid positions and already selected rows don't need to be handled
  if (!position || model.isSelected(position)) {
    return;
  }

  model.clear();
  model.add(position);
  model.setFocus(position);
  model.setOrigin(position);
  rows.update();
}

/**
 * Handle when an element outside the table receives focus.
 *
 * @param {MouseEvent} event A mouse event.
 */
function handleOutsideFocus(event) {
  if (isFilterTarget(event.target)) return;
  model.clear();
  rows.update();
}

/**
 * Handle when the mouse button is released.
 *
 * @param {MouseEvent|TouchEvent} event A mouse or touch event.
 */
function handleMouseUp(event) {
  if (isOnDocument(event)) return;

  handleMouseDown(event, true);
}

/**
 * Handle deselecting a currently selected row in a multi-select situation
 * (cmd/ctrl). This might mean that we need to adjust origin and focus as well.
 *
 * @param {Position} position Position clicked on.
 */
function handleDeselectOnSingleMultiSelect(position) {
  var origin = model.getOrigin();
  var focus = model.getFocus();
  var dir = positions.getDirection(origin, focus);

  // When removing the node that is both origin and focus, there will be no
  // direction in which the origin/focus could be moved. Like here:

  // Click A, CMD click C, CMD click B, CMD click B again.

  // Native desktop will now still have origin on B. MacOS Finder does move
  // origin but it's hard to know how it decides.

  // For a predictable behaviour, default to look downwards, and always reverse
  // the direction when no selected node is found.

  if (!dir) dir = 1;

  var isOrigin = position.isSame(origin);
  var isFocus = position.isSame(focus);
  var above, below;

  if (isOrigin || isFocus) {
    above = getClosestSelected(position, 'up');
    below = getClosestSelected(position, 'down');
  }

  // If direction is down (1), the next after origin is found below
  if (isOrigin) {
    model.setOrigin(dir === 1 ? below || above : above || below);
  }

  // If direction is down (1), the next after focus is found above
  if (position.isSame(focus)) {
    model.setFocus(dir === 1 ? above || below : below || above);
  }

  model.remove(position);
}

/**
 * Handle multi-selecting a range from the current focus to the new position.
 * This also handles deselecting as needed.
 *
 * @param {Position} position Position clicked on.
 */
function handleShiftMultiSelect(position) {
  var origin = model.getOrigin();
  var focus = model.getFocus();

  // Remove selection from origin to old focus.
  // If it's part of the new selection it will be re-added.
  if (origin && focus && !origin.isSame(focus)) {
    model.remove(origin, focus);
  }

  // If there is no origin, we will set the origin to the first selectable row
  if (!origin) {
    origin = new Position(0, 0);
    model.setOrigin(origin);
  }

  // Add selection from the current origin to the clicked position
  model.add(origin, position);
  model.setFocus(position);
}

/**
 * Handle a normal mousedown without any multi-select keys.
 *
 * @param {Position} position Position clicked on.
 * @param {MouseEvent|TouchEvent} event A mouse or touch event.
 * @param {boolean=} opt_isMouseUp Pass true if this is a simulated mousedown
 *     triggered by a mouseup event.
 */
function handleSingleSelect(position, event, opt_isMouseUp) {
  var origin = model.getOrigin();

  var button = getButtonFromEvent(event);
  var isPrimaryButton = button === 1;
  var isSecondaryButton = button === 2;

  var isSelected = model.isSelected(position);
  var singleMultiSelect = isMac() ? event.metaKey : event.ctrlKey;
  var multiselect = event.shiftKey || singleMultiSelect;

  if (!isMultiSelectEnabled()) {
    singleMultiSelect = multiselect = false;
  }

  // Left click without cmd/ctrl/shift clears selection.
  // Also right click on something that wasn't selected clears.
  var isRegularPrimary = !multiselect && isPrimaryButton;
  var isSelectedSecondary = !isSelected && isSecondaryButton;
  if (isRegularPrimary || isSelectedSecondary) {
    model.clear();
  }

  // Add item to selection
  model.add(position);
  model.setFocus(position, { isTouch: isTouchEvent(event) });

  // When adding to an existing selection, leave origin alone.
  var isNextToSelection;
  if (origin && !origin.isSame(position)) {
    var next = positions.getClosest(position, 'down');

    isNextToSelection = next && model.isSelected(next);
    if (!isNextToSelection) {
      var prev = positions.getClosest(position, 'up');
      isNextToSelection = prev && model.isSelected(prev);
    }
  }
  if (!isNextToSelection) {
    model.setOrigin(position);
  }
}

/**
 * Handler for when a key is pressed down in the list. Depending on the key,
 * this will either move the selection (up and down arrows), shrink/grow the
 * selection (shift up and down arrows) or clear the selection (escape key).
 *
 * @param {KeyboardEvent} event The event object.
 */
function handleKeyDown(event) {
  if (isFilterTarget(event.target)) return;

  focusEventValid = true;
  var isUp = event.keyCode === 38;
  var isDown = event.keyCode === 40;

  if (!isKeyboardNavEnabled()) return;

  if (!isUp && !isDown) return;

  var origin = model.getOrigin();
  var focus = model.getFocus();
  var next = focus;

  do {
    next = next && positions.getClosest(next, isDown ? 'down' : 'up');
  } while (next && model.isPositionHidden(next));

  // Only move the selection if the up or down key was pressed.
  // And only do it if the cmd/ctrl key is not also pressed.
  // The cmd/ctrl key will change the volume in the client.
  if ((isUp || isDown) && !event.metaKey && !event.ctrlKey && next) {

    // Multi-select must have a previous selection position
    if (event.shiftKey && isMultiSelectEnabled() && origin && focus) {
      var keyDirection = isDown ? 1 : -1;
      var direction = positions.getDirection(origin, focus);
      var isSingleRange = direction === 0;
      if (isSingleRange || keyDirection === direction) {
        model.add(next);
        scrollIntoView(next);
      } else {
        model.remove(focus);
      }

      // If multi-select can't be performed, just move the current selection
    } else {
        model.clear();
        model.add(next);
        model.setOrigin(next);
        scrollIntoView(next);
        event.preventDefault(); // Prevent normal scrolling
      }

    // Always set the new focus to the row above or below
    model.setFocus(next);
  }

  rows.update();
}

/**
 * Handle when a section of a list is scrolled into view.
 * This needs to update selection state of the row nodes.
 *
 * @param {Object} event Event object.
 */
function handleScrollShowAfter(event) {
  var node = event.pageNode && event.pageNode[0];
  rows.update(node);
}

/**
 * Handle setting which indices are hidden.
 *
 * @param {Object} data Object with properties `hiddenIndices` (array of
 *     indices) and `uri` (URI of the list).
 */
function handleSetHidden(data) {
  model.setHiddenIndices(data.indices, data.uri);
}

/**
 * Add a row to the selection based on a list URI.
 * TODO: Remove logic to handle global lists.
 *
 * @param {string} listUri The list URI.
 * @param {number} index The index within the list.
 * @param {boolean=} opt_doNotScrollIntoView Optionally skip scrolling added index into view
 */
function handleAddByUri(listUri, index, opt_doNotScrollIntoView) {
  var uriNodes = $('[data-uri=' + listUri + ']');
  var matches = intersection(containers.elements, uriNodes);

  if (!matches || matches.length < 1) {
    return;
  }

  var container = $(matches[0]);
  var containerIndex = container && containers.elements.indexOf(container[0]);
  var listIsPlayContext = container && container.matches('[data-context]');

  if (listIsPlayContext) {
    // Selection is not based on the global container that is defined via data-context,
    // so the indices need to be resolved to match the selection containers.
    var localPosition = positions.getPositionFromGlobalIndex(index);
    containerIndex = localPosition.containerIndex;
    index = localPosition.index;
  } else if (containerIndex === -1) {
    console && console.warn && console.warn('No container matching this uri was found or selection doesn\'t know ' + 'about the container. Possibly you need to run events.update.');
    return;
  }

  if (!isMultiSelectEnabled()) model.clear();

  var position = new Position(containerIndex, index);
  if (!model.getOrigin()) model.setOrigin(position);
  model.setFocus(position);
  model.add(position);

  rows.update();

  if (opt_doNotScrollIntoView !== true) {
    scrollIntoView(position);
  }
}

/**
 * Handle a select_all event from Cosmos.
 */
function handleSelectAll() {
  if (!isMultiSelectEnabled()) {
    return false;
  }

  model.clear();

  var first = new Position(0, 0);
  model.setOrigin(first);

  var last = positions.getLastPositionForSelectAll();
  model.setFocus(last);

  model.add(first, last);
  rows.update();
}

/**
 * Handle a copy event from Cosmos.
 */
function handleCopy() {
  cosmos.put({ url: CLIPBOARD_ENDPOINT, body: getSelectedUrls().join('\n') });
}

/**
 * Handle a cut event from Cosmos.
 */
function handleCut() {
  handleCopy();

  cosmos.post({ url: 'sp://messages/v1/container/control', body: { type: 'delete' } });
}

/**
 * Gets list of uris for selected rows
 *
 * @return {Array.<string>} Array of URIs.
 */
function handleGetUris() {
  var selections = model.selections;
  var uris = [];

  for (var container = 0; container < selections.length; container++) {
    var containerSelection = selections[container];
    if (!containerSelection) continue;

    var entity;

    var list = containers.getLiveList(container);
    if (!list) continue;

    // * Order the keys
    // Since the user can select tracks in any order,
    // the selection is an unordered set until we actually retrieve the
    // uris of the selection. In this case we want to get the uris
    // in the same order as they are shown in the list.
    var orderedSelectedKeys = list.keys.filter(function (key) {
      return !!containerSelection[key];
    });

    for (var i = 0, l = orderedSelectedKeys.length; i < l; i++) {
      var item = list.valueOf(orderedSelectedKeys[i]);
      if (!item) continue;

      entity = item.get('track');
      if (!entity) entity = item.get('playlist');
      if (!entity) entity = item.get('album');
      if (!entity) entity = item.get('artist');
      if (!entity) entity = item.get('user');
      if (!entity) entity = item;

      uris.push(entity.get('uri'));
    }
  }

  return uris;
}

/**
 * Returns the HTTPS urls of the selected rows
 *
 * @return {Array.<string>} Array of URLs.
 */
function getSelectedUrls() {
  var uris = handleGetUris();
  var urls = [];
  for (var i = 0; i < uris.length; i++) {
    var uriObj = liburi.from(uris[i]);
    if (uriObj) {
      urls.push(uriObj.toOpenURL());
    }
  }
  return urls;
}

/**
 * Get the mouse button number identifier from an event object.
 *
 * @param {MouseEvent|TouchEvent} event A mouse event.
 *
 * @return {number} A number representing the pressed button:
 *     0: No button pressed
 *     1: Primary button (usually left)
 *     2: Secondary button (usually right)
 *     3: Middle (usually the wheel)
 */
function getButtonFromEvent(event) {

  // Touches don't have buttons, so treat all touches as a primary button
  if (isTouchEvent(event)) {
    return 1;
  }

  switch (event.button) {
    case 0:
      return 1;
    case 2:
      return 2;
    case 1:
      return 3;
    default:
      return 0;
  }
}

/**
 * Check if the user agent is on a Mac.
 *
 * @return {boolean} True if Mac, false otherwise.
 */
function isMac() {
  if (!global.window) return false;
  if (!global.window.navigator) return false;
  var userAgent = global.window.navigator.userAgent || '';
  return userAgent.indexOf('Mac') > -1;
}

/**
 * Check if multi-select is enabled.
 * We currently disable it for the Web Player, since not much can be done with
 * a multi-selection there.
 *
 * @return {boolean} True if enabled, false otherwise.
 */
function isMultiSelectEnabled() {
  if ($('body').data('multi-select-disabled') !== null) return false;
  if (!global.window) return false;
  return !!global.window._getSpotifyModule;
}

/**
 * Check if keyboard selection is enabled.
 * If it's not enabled it is not possible to move the selection with arrow
 * keys or extend it with shift + arrow keys.
 *
 * @return {boolean} True if enabled, false otherwise.
 */
function isKeyboardNavEnabled() {
  return $('body').data('keyboard-select-disabled') === null;
}

/**
 * Check if the event is a touch event.
 *
 * @param {Event} event Event object.
 *
 * @return {boolean} True if it is a touch event object.
 */
function isTouchEvent(event) {
  return !!event.changedTouches;
}

/**
 * Get the closest selected position in the specified direction.
 *
 * @param {Position} position A position.
 * @param {string} direction The direction to search in: 'up' or 'down'.
 *
 * @return {Position?} A position or null if not found.
 */
function getClosestSelected(position, direction) {
  while (position) {
    position = positions.getClosest(position, direction);
    if (position && model.isSelected(position)) return position;
  }
  return null;
}

/**
 * Scroll the position into view.
 *
 * @param {Position} position A position.
 */
function scrollIntoView(position) {
  var container = containers.elements[position.containerIndex];
  var scrollContainer = container && container.querySelector('[data-scroll-container]');
  if (scrollContainer) {
    center.emit('scroll-to-index', scrollContainer, position.index);
  } else {
    var node = positions.getNodeFromPosition(position);
    if (!node) return;

    var offset = node.getBoundingClientRect().top;
    if (offset < 0 || offset >= window.innerHeight) {
      node.scrollIntoView(offset < 0);
    }
  }
}

/**
 * Update the list listeners for the current containers.
 */
function updateListListeners() {
  var uris = containers.getUris();

  for (var i = 0, l = uris.length; i < l; i++) {
    var uri = uris[i];
    if (uri && listListenerUris.indexOf(uri) === -1) {
      var list = live(uri).get('rows');
      if (list) {
        var listener = createListListener(uri);
        list.on('update', listener);
        listListeners[uri] = listener;
        listListenerUris.push(uri);
      }
    }
  }
}

/**
 * Create an event listener for list updates.
 * When an update happens, the selection model will be updated for the right
 * container.
 *
 * @param {string} uri A URI for a list.
 *
 * @return {function} A listener function.
 */
function createListListener(uri) {
  return function (operations) {
    var uris = containers.getUris();
    var containerIndex = uris.indexOf(uri);
    if (containerIndex > -1) {

      // If something was removed from the list, we must update the selection
      // state, as something that was selected might have been removed.
      // Insert and move operations don't affect the current selection state,
      // as everything is based on row IDs, which don't change.
      for (var i = 0, l = operations.length; i < l; i++) {
        var operation = operations[i];
        if (operation.type === 'remove') {
          model.updateContainer(containerIndex);
          break;
        }
      }

      // Update the rows visually based on the model state
      rows.update();
    }
  };
}

/**
 * Remove all list listeners.
 */
function resetListListeners() {
  for (var i = 0, l = listListenerUris.length; i < l; i++) {
    var uri = listListenerUris[i];
    var listener = listListeners[uri];
    var list = live(uri).get('rows');
    if (list && listener) {
      list.off('update', listener);
      delete listListeners[uri];
      listListenerUris.splice(i, 1);
      i--;l--;
    }
  }
}

function handleListSwap(event) {
  var rowsListBefore = live(event.before).get('rows');
  if (!rowsListBefore) return;

  var selectionBefore = selection.getIndicesPerList().filter(function (indicesPerList) {
    return indicesPerList.uri === event.before;
  })[0];

  var selectedKeysBefore = [];
  if (selectionBefore) {
    selectedKeysBefore = selectionBefore.indices.map(function (index) {
      return rowsListBefore.keys[index];
    });
  }

  center.on('scroll-reset', function onScrollReset() {
    center.off('scroll-reset', onScrollReset);

    live(event.after).get('rows', function (error, rowsListAfter) {
      selectedKeysBefore.forEach(function (selectedKeyBefore) {
        var indexAfter = rowsListAfter.keys.indexOf(selectedKeyBefore);
        if (indexAfter !== -1) {
          handleAddByUri(event.after, indexAfter, true);
        }
      });
    }, live.ASAP);
  });
}

exports.handleMouseDown = handleMouseDown;
exports.handleMouseUp = handleMouseUp;
exports.handleKeyDown = handleKeyDown;
exports.handleFocus = handleFocus;
exports.handleScrollShowAfter = handleScrollShowAfter;
exports.handleSetHidden = handleSetHidden;
exports.handleAddByUri = handleAddByUri;
exports.handleSelectAll = handleSelectAll;
exports.handleCopy = handleCopy;
exports.handleCut = handleCut;
exports.handleGetUris = handleGetUris;
exports.updateListListeners = updateListListeners;
exports.resetListListeners = resetListListeners;
exports.handleListSwap = handleListSwap;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../spotify-elements":45,"../../spotify-live":212,"../center":52,"../util/Position":101,"../util/cosmos":103,"./containers":86,"./index":88,"./model":89,"./positions":90,"./rows":91,"mout/array/intersection":332,"spotify-liburi":398}],88:[function(require,module,exports){
/**
 * spotify-events/selection
 */
'use strict';

var $ = require('../../spotify-elements');
var live = require('../../spotify-live');
var getOriginUri = require('../../spotify-live-wrapped-uri').getOriginUri;

var center = require('../center');
var controller = require('./controller');
var containers = require('./containers');
var model = require('./model');
var rows = require('./rows');
var positions = require('./positions');
var Position = require('../util/Position');
var appUtil = require('../util/app');

var cosmos = require('../util/cosmos');

var controlMessageSubscription;

/**
 * Attach event listeners etc.
 */
exports.attach = function () {
  var doc = $(document);
  doc.on('mousedown', controller.handleMouseDown);
  doc.on('touchstart', controller.handleMouseDown);
  doc.on('mouseup', controller.handleMouseUp);
  doc.on('touchend', controller.handleMouseUp);
  doc.on('keydown', controller.handleKeyDown);
  doc.on('focus', controller.handleFocus, true);

  center.on('scroll-show-after', controller.handleScrollShowAfter);
  center.on('selection-set-hidden', controller.handleSetHidden);
  center.on('list-swap', controller.handleListSwap);

  // Creating an "intentional bug".. By switching to use row IDs internally
  // for the selection model, we no longer need to manually update indices
  // as long as the new list has the same IDs (which we require anyway for
  // other reasons). We stopped using this event a long time ago anyway,
  // because it never really worked without odd behaviors. I've done a
  // code search (indexed Nov 23 2014), and there is not a single place
  // where this event is used, except in old versions of spotify-events,
  // which is not a problem. Technically, not responding to this event
  // is a breaking change, but for simplicity's sake let's stop handling it.
  // Fixing code that never gets used just for the sake of it makes no sense.
  // If someone really needs this in the future, we can fix it then.
  // So, this line should be commented for now.
  //
  // center.on('update-indices', controller.handleUpdateIndices);

  controlMessageSubscription = cosmos.subscribe({ url: 'sp://messages/v1/container/control' }, function (error, response) {
    if (error) throw error;
    var data = response.body;
    if (data && appUtil.isActiveAndFocused()) {
      if (data.type === 'select_all') {
        controller.handleSelectAll();
      } else if (data.type === 'copy') {
        controller.handleCopy();
      } else if (data.type === 'cut') {
        controller.handleCut();
      }
    }
  });
};

/**
 * Detach event listeners etc.
 */
exports.detach = function () {
  var doc = $(document);
  doc.off('mousedown', controller.handleMouseDown);
  doc.off('touchstart', controller.handleMouseDown);
  doc.off('mouseup', controller.handleMouseUp);
  doc.off('touchend', controller.handleMouseUp);
  doc.off('keydown', controller.handleKeyDown);
  doc.off('focus', controller.handleFocus, true);

  center.off('scroll-show-after', controller.handleScrollShowAfter);
  center.off('selection-set-hidden', controller.handleSetHidden);
  center.off('list-swap', controller.handleListSwap);

  // See comment in `attach` for the long story why this is commented.
  // center.off('update-indices', controller.handleUpdateIndices);

  if (controlMessageSubscription) {
    controlMessageSubscription.cancel();
    controlMessageSubscription = null;
  }
};

/**
 * Update the module based on the current DOM state.
 */
exports.update = function () {
  containers.update();
  controller.updateListListeners();
};

/**
 * Add a row to the selection based on a list URI.
 *
 * @param {string} listUri The list URI.
 * @param {number} index The index within the list.
 */
exports.add = function (listUri, index) {
  controller.handleAddByUri(listUri, index);
};

/**
 * Check if the selection has any holes (contains many ranges).
 *
 * @return {boolean} True if it has holes, false otherwise.
 */
exports.hasHoles = function () {
  return model.hasHoles();
};

/**
 * Check if the row node is selected.
 *
 * @param {HTMLElement|Elements} node A DOM node for a row.
 *
 * @return {boolean} True if it is selected, false otherwise.
 */
exports.isNodeSelected = function (node) {
  node = 'innerHTML' in node ? node : node[0];
  if (!node) return false;

  var position = positions.getFromNode(node);
  if (!position) return false;

  return model.isSelected(position);
};

/**
 * Reset the selection state and its knowledge of any containers.
 */
exports.reset = function () {
  controller.resetListListeners();
  model.reset();
  rows.update();
  containers.reset();
};

/**
 * Clear the current selection.
 */
exports.clear = function () {
  model.clear();
  rows.update();
};

/**
 * Set the origin to a new position.
 *
 * @param {number} containerIndex The index of the container.
 * @param {number} index The index within the container.
 */
exports.setOrigin = function (containerIndex, index) {
  model.setOrigin(new Position(containerIndex, index));
};

/**
 * Set the focus to a new position.
 *
 * @param {number} containerIndex The index of the container.
 * @param {number} index The index within the container.
 */
exports.setFocus = function (containerIndex, index) {
  model.setFocus(new Position(containerIndex, index));
};

/**
 * Get the current origin position.
 *
 * @return {Object?} An object with numeric properties `containerIndex`
 *     and `index`, or null if no origin is set.
 */
exports.getOrigin = function () {
  var origin = model.getOrigin();
  if (!origin) return null;
  return {
    containerIndex: origin.containerIndex,
    index: origin.index
  };
};

/**
 * Get the current focus position.
 *
 * @return {Object?} An object with numeric properties `containerIndex`
 *     and `index`, or null if no origin is set.
 */
exports.getFocus = function () {
  var focus = model.getFocus();
  if (!focus) return null;
  return {
    containerIndex: focus.containerIndex,
    index: focus.index
  };
};

/**
 * Get all selected indices organized by list.
 *
 * @return {Array.<Object>} Array of objects of this structure:
 *     {
 *       containerIndex: 0,
 *
 *       // This is the list in the UI (could be sorted or unsorted)
 *       uri: 'spotify:internal:sortlist:asc:track(name):list',
 *       keys: ['c', 'd', 'e', 'j', 'o', 't'],
 *       indices: [3, 4, 5, 10, 15, 20], // Ordered indices in the list
 *
 *       // If all items between two selected items are hidden, they will be
 *       // included here to allow nice ranges to be created from this. It will
 *       // also include hidden items right after the last selected item.
 *       keysWithHidden: ['c', 'd', 'e', 'j', 'k', 'l', 'm', 'n', 'o', 't'],
 *       indicesWithHidden: [3, 4, 5, 10, 11, 12, 13, 14, 15, 20],
 *
 *       // Optional object for the unsorted list if the list is a sorted list
 *       origin: {
 *         uri: 'spotify:list',
 *         keys: ['c', 'd', 'e', 'j', 'o', 't'],
 *         indices: [7, 19, 8, 14, 0, 9] // Unordered indices in the original list
 *       }
 *     }
 */
exports.getIndicesPerList = function () {
  var selections = model.selections;
  var indicesPerList = [];

  for (var i = 0; i < selections.length; i++) {
    var containerSelection = selections[i];
    if (containerSelection && Object.keys(containerSelection).length) {

      var uri = containers.getUri(i);
      if (!uri) continue;

      var list = containers.getLiveList(i);
      if (!list) continue;

      var indices = model.getIndicesForContainer(i);
      if (!indices) continue;

      var keys = indices.map(function (selectedIndex) {
        return list.keys[selectedIndex];
      });

      var indicesWithHidden = model.getIndicesWithHiddenForContainer(i);
      var keysWithHidden = indicesWithHidden.map(function (selectedIndex) {
        return list.keys[selectedIndex];
      });

      var context = {
        containerIndex: i,
        uri: uri,
        indices: indices,
        keys: keys,
        indicesWithHidden: indicesWithHidden,
        keysWithHidden: keysWithHidden
      };

      var originUri = getOriginUri(uri);
      if (originUri) {
        var wrappedList = live(uri).get('rows');
        var originList = live(originUri).get('rows');

        var originIndices;
        var originKeys;
        if (wrappedList && originList) {
          var key;
          var originListKeyIndexMap = {};
          originIndices = new Array(indices.length);
          originKeys = new Array(indices.length);

          for (var i = 0, keys = originList.keys; i < keys.length; i++) {
            originListKeyIndexMap[keys[i]] = i;
          };

          for (var j = 0; j < indices.length; j++) {
            key = wrappedList.keys[indices[j]];
            originIndices[j] = originListKeyIndexMap[key];
            originKeys[j] = originList.keys[originIndices[j]];
          }
        }
        context.origin = {
          uri: originUri,
          indices: originIndices || [],
          keys: originKeys || []
        };
      }

      indicesPerList.push(context);
    }
  }

  return indicesPerList;
};

/**
 * Get all selected indices relative to the full page (across all containers).
 *
 * @return {Object?} The value null if no global context is found or if found,
 *     an object of this structure:
 *     {
 *       uri: 'spotify:context:uri',
 *       indices: [0, 3, 56, 120],
 *
 *       // These elements are Elements instances from the 'elements' npm
 *       // package. This should be fixed in a future major version, to be
 *       // normal HTML elements.
 *       containers: [
 *         containerElement1,
 *         containerElement1,
 *         containerElement4,
 *         containerElement5
 *       ]
 *     }
 */
exports.getIndicesGlobal = function () {
  var selections = model.selections;
  var elements = containers.elements;
  var indices = [];
  var selectionContainers = [];

  if (elements.length === 0) {
    return null;
  }
  var contextUriContainer = elements[0].closest('[data-context]');
  var contextUri = contextUriContainer && contextUriContainer.getAttribute('data-uri');

  if (!contextUri) return null;

  for (var container = 0; container < selections.length; container++) {
    var containerSelection = selections[container];
    var list = containers.getLiveList(container);
    if (list && containerSelection) {

      var orderedSelectedKeys = list.keys.filter(function (key) {
        return !!containerSelection[key];
      });

      for (var i = 0, l = orderedSelectedKeys.length; i < l; i++) {
        var j = list.keys.indexOf(orderedSelectedKeys[i]);
        indices.push(positions.getGlobalIndexFromPosition(new Position(container, j)));
        selectionContainers.push($(elements[container]));
      }
    }
  }

  return {
    uri: contextUri,
    indices: indices,
    containers: selectionContainers
  };
};

/**
 * Get the URI of all selected rows.
 *
 * @return {Array.<string>} Array of URIs.
 */
exports.getUris = function () {
  return controller.handleGetUris();
};

/**
 * Get the nodes for all selected rows that can be found.
 *
 * @return {Array.<HTMLElement>} Array of DOM nodes.
 */
exports.getNodes = function () {
  return rows.getSelectedRows();
};

},{"../../spotify-elements":45,"../../spotify-live":212,"../../spotify-live-wrapped-uri":211,"../center":52,"../util/Position":101,"../util/app":102,"../util/cosmos":103,"./containers":86,"./controller":87,"./model":89,"./positions":90,"./rows":91}],89:[function(require,module,exports){
/**
 * @module spotify-events/selection/model
 * @private
 */
'use strict';

var live = require('../../spotify-live');
var Range = require('../../spotify-range2');
var containers = require('./containers');
var positions = require('./positions');
var Position = require('../util/Position');

/**
 * Selections for all known containers.
 * Each container's selection space is represented as an object where keys are
 * row IDs. This allows for quick lookups.
 *
 * @type {Array.<Object.<string, boolean>>}
 */
var selections = [];

/**
 * Hidden items for all known containers.
 * Each container is represented as an object where keys are row IDs. This
 * allows for quick lookups.
 *
 * @type {Object.<number, Object.<string, boolean>>}
 */
var hiddenKeysPerContainer = {};

var originContainerIndex = null;
var originKey = null;
var focusContainerIndex = null;
var focusKey = null;
var focusIsTouch = false;

/**
 * Get the current origin.
 *
 * @return {Position?} The origin position or null if not set.
 */
function getOrigin() {
  if (originContainerIndex === null) return null;
  if (originKey === null) return null;

  var list = containers.getLiveList(originContainerIndex);
  if (list) {
    var index = list.keys.indexOf(originKey);
    if (index === -1) return null;
    var position = new Position(originContainerIndex, index);
    return position;
  }
  return null;
}

/**
 * Get the current focus. This is the position for the keyboard focus.
 *
 * @return {Position?} The focus position or null if not set.
 */
function getFocus() {
  if (focusContainerIndex === null) return null;
  if (focusKey === null) return null;

  var list = containers.getLiveList(focusContainerIndex);
  if (list) {
    var index = list.keys.indexOf(focusKey);
    var position = new Position(focusContainerIndex, index);
    return position;
  }
  return null;
}

/**
 * Set the current origin.
 *
 * @param {Position?} position A position or null if removing the origin.
 */
function setOrigin(position) {
  if (position) {
    var list = containers.getLiveList(position.containerIndex);
    if (list) {
      originContainerIndex = position.containerIndex;
      originKey = list.keys[position.index] || null;
      return;
    }
  }

  originContainerIndex = null;
  originKey = null;
}

/**
 * Set the current focus.
 *
 * @param {Position?} position A position or null if removing the focus.
 */
function setFocus(position, options) {
  focusIsTouch = !!(options && options.isTouch);

  if (position) {
    var list = containers.getLiveList(position.containerIndex);
    if (list) {
      focusContainerIndex = position.containerIndex;
      focusKey = list.keys[position.index];
      return;
    }
  }

  focusContainerIndex = null;
  focusKey = null;
}

/**
 * Check if the current focus was triggered by a touch.
 * This is done since we might want to have different styles for selection focus
 * when triggered by a touch event.
 *
 * @return {boolean} True if triggered by touch.
 */
function wasFocusTriggeredByTouch() {
  return focusIsTouch;
}

/**
 * Handle setting which indices are hidden.
 *
 * @param {Array.<number>} hiddenIndices Array of indices that are hidden.
 * @param {string} containerUri The URI of the container.
 */
function setHiddenIndices(hiddenIndices, containerUri) {
  var list = live(containerUri).get('rows');
  if (list) {
    var keys = list.keys;
    var hiddenKeys = {};
    for (var i = 0, l = hiddenIndices.length; i < l; i++) {
      var key = keys[hiddenIndices[i]];
      if (key) hiddenKeys[key] = true;
    }

    var containerIndex = containers.getContainerIndex(containerUri);

    hiddenKeysPerContainer[containerIndex] = hiddenKeys;

    updateContainer(containerIndex);
  }
}

/**
 * Check if given position is hidden.
 *
 * @param {Position} from The position to check.
 * @return {boolean} True if position is hidden.
 */
function isPositionHidden(pos) {
  var idsPerContainer = getIds(pos, pos);
  var id = idsPerContainer[0][0];
  var hiddenKeys = hiddenKeysPerContainer[pos.containerIndex];
  return hiddenKeys && hiddenKeys[id];
}

/**
 * Add rows to the selection.
 *
 * @param {Position} from The start position to add.
 * @param {Position=} opt_to The end position to add. If not provided, it will
 *     only add a single row to the selection.
 */
function add(from, opt_to) {
  var to = opt_to || from;

  // Flip the positions if the direction is up.
  if (positions.getDirection(from, to) === -1) {
    var temp = from;
    from = to;
    to = temp;
  }

  var idsPerContainer = getIds(from, to);

  for (var i = 0, l = idsPerContainer.length; i < l; i++) {
    var containerIndex = from.containerIndex + i;
    var selected = selections[containerIndex] || (selections[containerIndex] = Object.create(null));
    var ids = idsPerContainer[i];
    var hiddenKeys = hiddenKeysPerContainer[containerIndex];

    // Set all new items as selected, unless they're hidden
    for (var j = 0, id; id = ids[j]; j++) {
      if (!hiddenKeys || !hiddenKeys[id]) {
        selected[id] = true;
      }
    }
  }
}

/**
 * Remove rows from the selection.
 *
 * @param {Position} from The start position to remove.
 * @param {Position=} opt_to The end position to remove. If not provided, it will
 *     only remove a single row from the selection.
 */
function remove(from, opt_to) {
  var to = opt_to || from;

  // Flip the positions if the direction is up.
  if (positions.getDirection(from, to) === -1) {
    var temp = from;
    from = to;
    to = temp;
  }

  var idsPerContainer = getIds(from, to);

  for (var i = 0, l = idsPerContainer.length; i < l; i++) {
    var containerIndex = from.containerIndex + i;
    var selected = selections[containerIndex] || (selections[containerIndex] = Object.create(null));
    var ids = idsPerContainer[i];

    // Loop the row ids that are to be removed and remove them from the selection.
    // That's usually faster than looping the selection since there's no UI for
    // removing a big chunk of selection in one go.
    for (var j = 0, id; id = ids[j]; j++) {
      delete selected[id];
    }
  }
}

/**
 * Clear the current selection.
 */
function clear() {
  selections.length = 0;
  setOrigin(null);
  setFocus(null);
}

/**
 * Reset the current selection state.
 */
function reset() {
  clear();
  hiddenKeysPerContainer = {};
}

/**
 * Update the model state based on the current state of the list.
 * If items were removed from the list, removed items that were selected
 * will be removed from selection state.
 */
function updateContainer(containerIndex) {
  var keys = selections[containerIndex];
  if (!keys) return;

  var list = containers.getLiveList(containerIndex);
  if (!list) return;

  for (var key in keys) {
    var hasKey = list.hasKey(key);
    var shouldDelete = !hasKey;
    if (!shouldDelete) {
      var hiddenKeys = hiddenKeysPerContainer[containerIndex];
      var shouldDelete = hiddenKeys ? hiddenKeys[key] : false;
    }
    if (shouldDelete) {
      delete keys[key];
    }
  }
}

/**
 * Get ranges for the provided global range.
 *
 * @param {Position} from The start position.
 * @param {Position} to The end position. This position must be below the
 *     `from` position.
 *
 * @return {Array.<Range>} Array of ranges. There will be one range per
 *     matching container.
 */
function getRanges(from, to) {
  var ranges = [];

  var fromContainer = from.containerIndex;
  var toContainer = to.containerIndex;

  for (var i = fromContainer; i <= toContainer; i++) {
    var fromIndex = i === fromContainer ? from.index : 0;
    var toIndex;
    if (i === toContainer) {
      toIndex = to.index;
    } else {
      var containerLength = containers.getContainerLength(i);
      if (containerLength > 0) {
        toIndex = containerLength - 1;
      }
    }

    if (toIndex === undefined) {
      ranges.push(new Range(0, 0));
    } else {
      ranges.push(new Range(fromIndex, toIndex + 1));
    }
  }

  return ranges;
}

/**
 * Get IDs for the provided global range.
 *
 * @param {Position} from The start position.
 * @param {Position} to The end position. This position must be below the
 *     `from` position.
 *
 * @return {Array.<Array.<string>>} Array of IDs per container.
 */
function getIds(from, to, opt_keys) {
  var idsPerContainer = [];

  var fromContainer = from.containerIndex;
  var toContainer = to.containerIndex;

  for (var i = fromContainer; i <= toContainer; i++) {
    var fromIndex = i === fromContainer ? from.index : 0;
    var toIndex;
    if (i === toContainer) {
      toIndex = to.index;
    } else {
      var containerLength = containers.getContainerLength(i);
      if (containerLength > 0) {
        toIndex = containerLength - 1;
      }
    }

    if (toIndex === undefined) {
      idsPerContainer.push([]);
    } else {
      var ids = [];
      idsPerContainer.push(ids);

      var containerUri = containers.getUri(i);
      var list = live(containerUri).get('rows');
      if (list) {
        var keys = list.keys;

        for (var n = fromIndex; n < toIndex + 1; n++) {
          ids.push(keys[n]);
        }
      }
    }
  }

  return idsPerContainer;
}

/**
 * Check if the position is selected.
 *
 * @param {Position} position A position.
 *
 * @return {boolean} True if it is selected, false otherwise.
 */
function isSelected(position) {

  // Get the ranges of the according container
  var keys = selections[position.containerIndex];
  if (!keys) return false;

  // Check if the row is within the selected ranges for the container
  var list = containers.getLiveList(position.containerIndex);
  if (list) {
    var key = list.keys[position.index];
    return !!keys[key];
  }

  return false;
}

/**
 * Check if the selection has any holes (contains many ranges).
 *
 * @return {boolean} True if it has holes, false otherwise.
 */
function hasHoles() {
  var rangeCount = 0;

  for (var containerIndex = 0; containerIndex < selections.length; containerIndex++) {
    var containerSelection = selections[containerIndex];
    var list = containers.getLiveList(containerIndex);

    var keys = Object.keys(containerSelection);

    // A selection in more than one container means the selection has holes
    if (keys.length > 0) {
      rangeCount++;

      // Also more than one range in only one container means it has holes.
      if (list) {
        var indices = [];
        for (var j = 0, len = keys.length; j < len; j++) {
          indices.push(list.indexOf(keys[j]));
        }
        indices.sort(function (a, b) {
          return a - b;
        });
        var previousIndex;
        for (var i = 0, l = indices.length; i < l; i++) {
          var index = indices[i];
          if (i > 0 && index > previousIndex + 1) {
            rangeCount++;
            break;
          }
          previousIndex = index;
        }
      }
    }
    if (rangeCount > 1) return true;
  }

  return false;
}

/**
 * Check if there is any selection in any container.
 *
 * @return {boolean} True if there is a selection.
 */
function hasSelection() {
  for (var i = 0, l = selections.length; i < l; i++) {
    if (selections[i] && Object.keys(selections[i]).length > 0) {
      return true;
    }
  }

  return false;
}

/**
 * Get the selected indices for a container.
 *
 * @param {number} containerIndex The container index.
 *
 * @return {Array.<number>?} An array of indices or null if nothing is selected.
 */
function getIndicesForContainer(containerIndex) {
  var unorderedKeys = selections[containerIndex];
  if (!unorderedKeys) return null;
  var indices = [];

  var list = containers.getLiveList(containerIndex);

  var orderedKeys = list.keys.filter(function (key) {
    return !!unorderedKeys[key];
  });

  if (list && orderedKeys.length) {
    if (orderedKeys.length > 1) {
      // indexOfMany() is much more perfomant for big selections
      indices = list.indexOfMany(orderedKeys);
    } else {
      // for a single selected item, indexOf() is a little bit more perfomant
      indices = [list.indexOf(orderedKeys[0])];
    }
  }

  return indices.length ? indices : null;
}

/**
 * Get the selected indices for a container, including hidden items that join
 * two ranges. For example, in a list [A, B, C, D, E, F, G, H], everything is
 * selected except C, D, F and G. There are hidden items, C, D, F and G. This
 * method would then return the indices of all items except H,
 * [0, 1, 2, 3, 4, 5, 6]. It does include hidden items right after the last
 * selected one.
 *
 * @param {number} containerIndex The container index.
 *
 * @return {Array.<number>?} An array of indices or null if nothing is selected.
 */
function getIndicesWithHiddenForContainer(containerIndex) {
  var indices = getIndicesForContainer(containerIndex);
  if (!indices) return null;

  var hiddenKeys = hiddenKeysPerContainer[containerIndex];
  if (!hiddenKeys) return indices;

  var ranges = Range.fromIndices(indices);
  if (ranges.length === 1) return indices;

  var list = containers.getLiveList(containerIndex);
  if (!list) return indices;

  var hiddenIds = Object.keys(hiddenKeys);
  var hiddenIndices = [];

  if (hiddenIds.length) {
    if (hiddenIds.length > 1) {
      // indexOfMany() is much more perfomant for big selections
      hiddenIndices = list.indexOfMany(hiddenIds);
    } else {
      // for a single selected item, indexOf() is a little bit more perfomant
      hiddenIndices = [list.indexOf(hiddenIds[0])];
    }
  }

  hiddenIndices = hiddenIndices.filter(function (index) {
    return index > -1;
  });

  var hiddenRanges = Range.fromIndices(hiddenIndices);
  var hiddenStarts = hiddenRanges.map(function (range) {
    return range.start;
  });
  var hiddenEnds = hiddenRanges.map(function (range) {
    return range.end;
  });

  for (var i = 0, l = ranges.length; i < l; i++) {
    var range = ranges[i];
    var nextRange = ranges[i + 1];

    var indexOfRange = hiddenStarts.indexOf(range.end);
    if (indexOfRange > -1) {
      var hiddenEnd = hiddenEnds[indexOfRange];
      if (!nextRange || hiddenEnd === nextRange.start) {
        var hiddenIndicesInRange = hiddenRanges[indexOfRange].toIndices();
        if (hiddenIndicesInRange.length > 0) {
          indices = indices.concat(hiddenIndicesInRange);
        }
      }
    }
  }

  indices.sort(function (a, b) {
    return a - b;
  });

  return indices.length ? indices : null;
}

exports.selections = selections;
exports.getOrigin = getOrigin;
exports.getFocus = getFocus;
exports.setOrigin = setOrigin;
exports.setFocus = setFocus;
exports.wasFocusTriggeredByTouch = wasFocusTriggeredByTouch;
exports.setHiddenIndices = setHiddenIndices;
exports.isPositionHidden = isPositionHidden;
exports.add = add;
exports.remove = remove;
exports.clear = clear;
exports.reset = reset;
exports.updateContainer = updateContainer;
exports.isSelected = isSelected;
exports.hasHoles = hasHoles;
exports.hasSelection = hasSelection;
exports.getIndicesForContainer = getIndicesForContainer;
exports.getIndicesWithHiddenForContainer = getIndicesWithHiddenForContainer;

},{"../../spotify-live":212,"../../spotify-range2":251,"../util/Position":101,"./containers":86,"./positions":90}],90:[function(require,module,exports){
/**
 * @module spotify-events/selection/positions
 * @private
 */
'use strict';

var $ = require('../../spotify-elements');

var containers = require('./containers');
var Position = require('../util/Position');

/**
 * Get the closest position in the specified direction.
 *
 * @param {Position} position A position.
 * @param {string} direction The direction to search in: 'up' or 'down'.
 *
 * @return {Position?} A position or null if not found.
 */
function getClosest(position, direction) {
  var isDown = direction === 'down';
  var containerIndex = position.containerIndex;
  var index = position.index;

  // Find next position within the current container
  var containerLength = containers.getContainerLength(containerIndex);
  var nextIndex = isDown ? index + 1 : index - 1;
  if (nextIndex < containerLength && nextIndex >= 0) {
    return new Position(containerIndex, nextIndex);
  }

  // Out of bounds, traverse containers
  containerIndex = isDown ? containerIndex + 1 : containerIndex - 1;
  containerLength = containers.getContainerLength(containerIndex);
  if (containerLength) {
    nextIndex = isDown ? 0 : containerLength - 1;
    return new Position(containerIndex, nextIndex);
  }

  return null;
}

/**
 * Get a position from a row node.
 *
 * @param {HTMLElement} node A DOM node for a list row.
 *
 * @return {Position?} A position or null if not found.
 */
function getFromNode(node) {

  // We need a parent node, since we will be checking if the row is inside
  // one of the known selection containers.
  if (!node.parentNode) return null;

  // We also need a data-index attribute on the row to get the index for the
  // row within the current selection container.
  if (!node.hasAttribute('data-index')) return null;

  var elements = containers.elements;
  if (elements.length === 0) return null;

  for (var i = 0, l = elements.length; i < l; i++) {
    if (elements[i] && containsNode(elements[i], node)) {
      var row = +node.getAttribute('data-index');
      return new Position(i, row);
    }
  }

  return null;
}

/**
 * Check if an element contains another node.
 *
 * @param {HTMLElement} element The container element.
 * @param {HTMLElement} child The potential child node.
 *
 * @return {boolean} True if element contains the child, false otherwise.
 */
function containsNode(element, child) {
  while (child && child.parentNode !== element) {
    child = child.parentNode;
  }
  return !!child;
}

/**
 * Get the row node that the specified position represents.
 *
 * @param {Position} position A position.
 *
 * @return {HTMLElement?} A DOM node or null if not found.
 */
function getNodeFromPosition(position) {
  var container = containers.elements[position.containerIndex];
  if (!container) return null;
  var node = $(container).find('[data-index=' + position.index + ']');
  return node ? node[0] : null;
}

/**
 * Get the direction from one position to another.
 *
 * @param {Position} from First position.
 * @param {Position} to Second position.
 *
 * @return {number} A number representing the direction.
 *     -1 is up
 *      0 is same
 *      1 is down
 */
function getDirection(from, to) {
  if (!from || !to) return 0;

  // With different containers we can just compare the containers
  if (from.containerIndex !== to.containerIndex) return from.containerIndex < to.containerIndex ? 1 : -1;

  // Within the same container, compare the row indices
  if (from.index === to.index) return 0;
  return from.index < to.index ? 1 : -1;
}

/**
 * Get data about in which container and where inside that the provided
 * global index is.
 *
 * @param {number} globalIndex An index relative to the full page (all
 *     selection containers).
 *
 * @return {Position} A position.
 */
function getPositionFromGlobalIndex(globalIndex) {
  var resolvedIndex = globalIndex;
  var resolvedContainerIndex = 0;
  var containerLength;
  var countIndices = 0;

  // Subtract the amount of tracks in containers until passing globalIndex
  for (var i = 0, l = containers.elements.length; i < l; i++) {

    containerLength = containers.getContainerLength(i);
    countIndices += containerLength;

    if (countIndices > globalIndex) break;

    resolvedContainerIndex = i + 1;
    resolvedIndex -= containerLength;
  }

  return new Position(resolvedContainerIndex, resolvedIndex);
}

/**
 * Get the global index relative to the full page (across all selection
 * containers) from a position object.
 *
 * @param {Position} position A position.
 *
 * @return {number} A global index.
 */
function getGlobalIndexFromPosition(position) {
  var resolvedIndex = position.index;

  // Subtract length of previous lists
  for (var i = position.containerIndex - 1; i >= 0; i--) {
    resolvedIndex += containers.getContainerLength(i);
  }

  return resolvedIndex;
}

/**
 * Get last position on page.
 *
 * @return {Position} A position.
 */
function getLastPosition() {
  var lastContainerIndex = containers.elements.length - 1;
  var lastIndex = containers.getContainerLength(lastContainerIndex) - 1;

  return new Position(lastContainerIndex, lastIndex);
}

/**
 * Get last position for "select all" on page, disregarding containers with
 * [data-select-all="false"].
 *
 * @return {Position} A position.
 */
function getLastPositionForSelectAll() {
  var lastContainerIndex = containers.elements.filter(function (element) {
    return element.getAttribute('data-list-may-select-all') !== 'false';
  }).length - 1;
  var lastIndex = containers.getContainerLength(lastContainerIndex) - 1;

  return new Position(lastContainerIndex, lastIndex);
}

exports.getClosest = getClosest;
exports.getFromNode = getFromNode;
exports.getNodeFromPosition = getNodeFromPosition;
exports.getDirection = getDirection;
exports.getPositionFromGlobalIndex = getPositionFromGlobalIndex;
exports.getGlobalIndexFromPosition = getGlobalIndexFromPosition;
exports.getLastPosition = getLastPosition;
exports.getLastPositionForSelectAll = getLastPositionForSelectAll;

},{"../../spotify-elements":45,"../util/Position":101,"./containers":86}],91:[function(require,module,exports){
/**
 * @module spotify-events/selection/rows
 * @private
 */
'use strict';

var $ = require('../../spotify-elements');
var difference = require('mout/array/difference');

var model = require('./model');
var containers = require('./containers');
var positions = require('./positions');

var SELECTOR_ROW = '[data-list-item]';
var CLASSNAME_SELECTED = 'selected';
var CLASSNAME_FOCUSED = 'selection-focus';
var CLASSNAME_FOCUSED_TOUCH = 'selection-focus-touch';
var focusTimeout;

/**
 * Update the selection state of rows.
 *
 * @param {HTMLElement=} opt_node Optional DOM node. If provided, the update
 *     will only affect rows found inside this node.
 */
function update(opt_node) {
  var currentlySelectedRows = getSelectedRows(opt_node);
  var rowsToBeSelected = getRowsToSelect(opt_node);

  var rowsToDeselect = difference(currentlySelectedRows, rowsToBeSelected);
  var rowsToSelect = difference(rowsToBeSelected, currentlySelectedRows);

  currentlySelectedRows.forEach(function (row) {
    $(row).removeClass(CLASSNAME_FOCUSED);
    $(row).removeClass(CLASSNAME_FOCUSED_TOUCH);
  });

  // Remove styles for selected rows that should now be deselected
  rowsToDeselect.forEach(function (row) {
    $(row).removeClass(CLASSNAME_SELECTED);
  });

  // Add styles for unselected rows that should now be selected
  rowsToSelect.forEach(function (row) {
    $(row).addClass(CLASSNAME_SELECTED);
  });

  // Add styles for the row with the selection focus
  var focus = model.getFocus();
  if (focus) {
    var focusNode = positions.getNodeFromPosition(focus);
    if (focusNode) {
      // If the focusNode is not yet in the viewport and we `focus()` it, the
      // browser will bluntly scroll it into view, which looks bad. (KM-6508)
      clearTimeout(focusTimeout);
      focusTimeout = setTimeout(function () {
        var isInputFocused = document.activeElement && $(document.activeElement).matches('input, textarea');
        var isButtonFocused = document.activeElement && $(document.activeElement).matches('button');
        if (isElementInViewport(focusNode) && !isInputFocused && !isButtonFocused) {
          focusNode.focus();
        }
      }, 0);
      $(focusNode).addClass(CLASSNAME_FOCUSED);

      if (model.wasFocusTriggeredByTouch()) {
        $(focusNode).addClass(CLASSNAME_FOCUSED_TOUCH);
      }
    }
  }
}

/**
 * Get the rows that are currently selected, found inside the known containers.
 *
 * @param {HTMLElement=} opt_node Optional DOM node. If provided, it will only
 *     search inside this node.
 *
 * @return {Array.<HTMLElement>} Array of DOM nodes.
 */
function getSelectedRows(opt_node) {
  var elements = opt_node ? [opt_node] : containers.elements;
  var rows = [];

  elements.forEach(function (container) {
    var nodes = $(container).search(SELECTOR_ROW + '.' + CLASSNAME_SELECTED);
    if (nodes) Array.prototype.push.apply(rows, nodes);
  });

  return rows;
}

/**
 * Get the rows that should be selected, found inside the known containers.
 *
 * @param {HTMLElement=} opt_node Optional DOM node. If provided, it will only
 *     search inside this node.
 *
 * @return {Array.<HTMLElement>} Array of DOM nodes.
 */
function getRowsToSelect(opt_node) {
  var rows = [];
  var containerElements = containers.elements;

  model.selections.forEach(function (keys, index) {
    if (!keys) return;

    var list = containers.getLiveList(index);
    if (!list) return;

    var container = containerElements[index];
    // If a node was passed, only check the container if it contains the node
    if (opt_node && !containerElements[index].contains(opt_node)) {
      container = null;
    }
    if (!container) return;

    var listNodes = $(container).search(SELECTOR_ROW);
    if (!listNodes) return;

    var nodes = listNodes.filter(function (listNode) {
      var nodeIndex = +listNode.getAttribute('data-index');
      var nodeRowId = list.keys[nodeIndex];
      return !!keys[nodeRowId];
    });

    Array.prototype.push.apply(rows, nodes);
  });
  return rows;
}

function isElementInViewport(el) {
  var rect = el.getBoundingClientRect();
  return rect.top >= 0 && rect.bottom <= document.documentElement.clientHeight;
}

exports.update = update;
exports.getSelectedRows = getSelectedRows;

},{"../../spotify-elements":45,"./containers":86,"./model":89,"./positions":90,"mout/array/difference":324}],92:[function(require,module,exports){
'use strict';

var SHUFFLE_CLASS = 'shuffle-mode';
var shuffleMode = require('../spotify-shuffle-mode');
var rootNode = document.documentElement;
var rootClassList = rootNode.classList;

function setClass() {
  if (shuffleMode.isEnabled()) {
    rootClassList.add(SHUFFLE_CLASS);
  } else {
    rootClassList.remove(SHUFFLE_CLASS);
  }
}

var isAttached = false;

exports.attach = function attach() {
  if (isAttached) return;
  isAttached = true;

  setClass();
};

exports.detach = function detach() {
  if (!isAttached) return;
  isAttached = false;

  rootClassList.remove(SHUFFLE_CLASS);
};

exports.update = function update(node) {
  if (!isAttached) return;

  if (node === rootNode) {
    setClass();
  }
};

},{"../spotify-shuffle-mode":252}],93:[function(require,module,exports){
/**
 * @module spotify-events/slider
 */
'use strict';

var $ = require('../spotify-elements');
var center = require('./center');

var live = require('../spotify-live');

var ATTR_SLIDER = 'slider';
var ATTR_PROPERTY = 'slider-property';
var SELECTOR_SLIDER = '[data-' + ATTR_SLIDER + ']';
var CLASSNAME_ENABLED = 'enabled';
var CLASSNAME_DISABLED = 'disabled';
var ATTR_ALLOWED = 'slider-allowed-property';

var SPACE_KEY_CODE = 32;

// Stored nodes, used to not add listeners multiple times
var storedNodes = [];

/**
 * Handle a click on a slider node.
 *
 * @param {MouseEvent} event Event object.
 * @param {Elements} elem An elements DOM node for the slider.
 */
function handleClick(event, elem) {
  var property = elem.data(ATTR_PROPERTY);

  if (elem.data(ATTR_ALLOWED) && !live(elem.data('uri')).get(elem.data(ATTR_ALLOWED))) {
    return;
  }

  // If a property is set, update the model. That will later trigger
  // an update of the view and a change event on center will be sent.
  if (property) {
    toggleAndPublish(elem[0], property);

    // If no property is set, just flip the visual style and emit
    // a change event on center.
  } else {
      setState(elem[0], !elem.hasClass(CLASSNAME_ENABLED));
    }
}

/**
 * Handle a keyboard event on a slider node.
 *
 * @param {KeyboardEvent} event Event object.
 * @param {Elements} elem An elements DOM node for the slider.
 */
function handleKeyUp(event, elem) {
  if (event.keyCode !== SPACE_KEY_CODE) {
    return;
  }

  handleClick(event, elem);
};

/**
 * Handle when a slider-set event happens on center.
 *
 * @param {Object} event An object with data.
 */
function onSliderSet(event) {
  if (!event.id) return;

  var elem = $('[data-' + ATTR_SLIDER + '=' + event.id + ']');
  if (!elem) return;

  var node = elem[0];
  var enabled = !!event.enabled;

  var property = elem.data(ATTR_PROPERTY);

  if (property) {
    toggleAndPublish(node, property, enabled);
  } else {
    setState(node, enabled);
  }
}

/**
 * Update the live model with new data. If no data-uri is found from
 * the passed node, nothing happens.
 *
 * @param {HTMLElement} node A DOM node for the slider.
 * @param {string} property A property name on the model.
 * @param {boolean=} opt_enabled Optional boolean flag. If true, this
 *     sets it to true, if false this sets it to false. If not provided,
 *     this sets it to the opposite of the current value in the model.
 */
function toggleAndPublish(node, property, opt_enabled) {
  var uri = getUriFromNode(node);
  if (!uri) return;

  var model = live(uri);

  // If the model doesn't have a current value, we can't safely
  // set a new value without maybe being wrong.
  var value = model.get(property);
  if (value === undefined) return;

  var newValue = opt_enabled === undefined ? !value : opt_enabled;

  var data = {};
  data[property] = newValue;

  // Publishing the new value to the model will trigger the update
  // handler added here in this module to update the visual state
  // of the button.
  model.publish(data);
}

/**
 * Update the state of one slider node.
 *
 * @param {HTMLElement} node A DOM node for the slider.
 */
function updateNode(node) {

  // Don't handle the same URI and node twice.
  if (storedNodes.indexOf(node) > -1) return;
  storedNodes.push(node);

  var elem = $(node);
  var property = elem.data(ATTR_PROPERTY);
  var allowedProperty = elem.data(ATTR_ALLOWED);

  if (!property) return;

  var uri = getUriFromNode(node);
  if (!uri) return;

  var model = live(uri);

  model.get(property, function (error, value) {
    if (error) throw error;

    setState(node, !!value);

    model.on('update', function (properties) {
      if (property in properties) {
        setState(node, !!properties[property]);
      }

      if (allowedProperty && allowedProperty in properties) {
        disableNode(node, !properties[allowedProperty]);
      }
    });
  });
}

/**
 * Update a slider node based on a value.
 *
 * @param {HTMLElement} node A DOM node for a slider.
 * @param {boolean} enabled True if should be enabled, false otherwise.
 */
function setState(node, enabled) {
  updateNodeWithValue(node, enabled);
  emitUpdate(node, enabled);
}

/**
 * Update a slider node based on a value.
 *
 * @param {HTMLElement} node A DOM node for a slider.
 * @param {boolean} enabled True if should be enabled, false otherwise.
 */
function updateNodeWithValue(node, enabled) {
  var elem = $(node);
  if (enabled) {
    elem.addClass(CLASSNAME_ENABLED);
  } else {
    elem.removeClass(CLASSNAME_ENABLED);
  }
}

/**
 * Update a slider node based on whether is disabled
 *
 * @param {HTMLElement} node A DOM node for a slider.
 * @param {boolean} disabled True if should be disabled, false otherwise.
 */
function disableNode(node, disabled) {
  var elem = $(node);
  if (disabled) {
    elem.addClass(CLASSNAME_DISABLED);
  } else {
    elem.removeClass(CLASSNAME_DISABLED);
  }
}

/**
 * Emit a change event on center. It will have the following format:
 * {
 *   element: HTMLElement,
 *   id: 'id from data-slider attribute' || null,
 *   enabled: true // the new value
 * }
 *
 * @param {HTMLElement} node A DOM node for a slider.
 * @param {boolean} enabled True if enabled, false otherwise.
 */
function emitUpdate(node, enabled) {
  var id = $(node).data(ATTR_SLIDER) || null;
  center.emit('slider-change', {
    element: node,
    id: id,
    enabled: enabled
  });
}

/**
 * Get a URI from a node.
 *
 * @param {HTMLElement} node A DOM node.
 *
 * @return {string?} A URI string or null if not found.
 */
function getUriFromNode(node) {
  var stateNode = node.closest('[data-uri]');
  if (!stateNode) return null;
  return stateNode.getAttribute('data-uri');
}

var isAttached = false;

/**
 * Update the module based on the current DOM state.
 *
 * @param {HTMLElement=} opt_node Optional DOM node to make changes inside.
 */
exports.update = function (opt_node) {
  if (!isAttached) return;

  var nodes = $(opt_node || document).search(SELECTOR_SLIDER);
  if (!nodes) return;

  nodes.forEach(updateNode);
};

/**
 * Attach event listeners etc.
 */
exports.attach = function () {
  if (isAttached) return;
  isAttached = true;

  var doc = $(document);
  doc.delegate('click', SELECTOR_SLIDER, handleClick);
  doc.delegate('keyup', SELECTOR_SLIDER, handleKeyUp);

  center.on('slider-set', onSliderSet);
};

/**
 * Detach event listeners etc.
 */
exports.detach = function () {
  if (!isAttached) return;
  isAttached = false;

  var doc = $(document);
  doc.undelegate('click', SELECTOR_SLIDER, handleClick);
  doc.undelegate('keyup', SELECTOR_SLIDER, handleKeyUp);

  center.off('slider-set', onSliderSet);
};

},{"../spotify-elements":45,"../spotify-live":212,"./center":52}],94:[function(require,module,exports){
'use strict';

var $ = require('../spotify-elements');
require('../spotify-elements/attributes');
require('../spotify-elements/traversal');

var live = require('../spotify-live');
var center = require('./center');
var sortUriUtils = require('../spotify-live-sort-uri');

var UIInteraction4 = require('../spotify-logger/messages/UIInteraction4');

var ASC = 'tl-sort-asc';
var DESC = 'tl-sort-desc';

var handleSort = function handleSort(event, node) {
  var listNode = node.parent('[data-list]');
  if (!listNode) return;

  var uri = listNode.data('uri');
  if (!uri) return;

  var model = live(uri);

  var queryCurrent = sortUriUtils.getQuery(uri);
  var directionCurrent = sortUriUtils.getDirection(uri);

  var query = node.data('sort');

  var reverse = directionCurrent === 'asc' ? 'desc' : 'asc';
  var direction = queryCurrent === query ? reverse : 'asc';
  var reset = queryCurrent === query && directionCurrent === 'desc';

  var origin = sortUriUtils.getOriginUri(uri) || uri;

  var nextUri;
  if (reset) {
    nextUri = origin;
    query = null;
    direction = null;
  } else {
    nextUri = sortUriUtils.create(origin, direction, query);
  }

  // The first time a live model for the sorted URI is created, the sortlist
  // model will set up the sorting queries based on the URI.
  var nextList = live(nextUri);

  // We then need to trigger the sort to happen by asking for rows
  // The app itself will most likely request rows anyway, but by doing it
  // early might make it slightly faster.
  nextList.get('rows', function () {});

  var player = live('spotify:player');

  player.get('variant', function (error, context) {
    if (error) throw error;

    if (context && context.get('uri') === uri) {
      player.emit('update-context', {
        context: nextUri
      });
    }
  });

  setClassNames(listNode, query, direction);

  center.emit('sort-header-click', {
    uri: origin,
    requested: {
      query: query || null,
      direction: direction || null
    },
    current: {
      query: queryCurrent || null,
      direction: directionCurrent || null
    }
  });

  center.emit('list-swap', { before: uri, after: nextUri });

  UIInteraction4.log({
    feature_id: live('spotify:application').get('appURI') || 'unknown',
    section_id: 'sort-header',
    target_uri: nextUri,
    interaction_type: 'hit',
    user_intent: 'sort',
    timestamp: Math.round(Date.now() / 1000)
  });
};

var setClassNames = function setClassNames(list, opt_query, opt_direction) {

  var uri = list.data('uri');
  var query = opt_query !== undefined ? opt_query : sortUriUtils.getQuery(uri);
  var direction = opt_direction !== undefined ? opt_direction : sortUriUtils.getDirection(uri);
  var headers = list.search('[data-sort]');
  if (!headers) return;

  for (var i = 0, header; header = $(headers[i]); i++) {
    header.removeClass(ASC + ' ' + DESC);
    if (header.data('sort') === query) {
      header.addClass(direction === 'asc' ? ASC : DESC);
    }
  }
};

var handlePreviousProxyClick = function handlePreviousProxyClick(event, node) {
  handleSort(null, node.previousSibling());
};

var isAttached = false;

exports.update = function (node) {
  if (!isAttached) return;

  node = $(node) || $(document);

  var lists = node.matches('[data-list]') ? [node] : node.search('[data-list]');
  if (!lists) return;

  for (var i = 0, list; list = $(lists[i]); i++) {
    var headers = list.search('[data-sort]');
    if (!headers) continue;
    setClassNames(list);
  }
};

exports.attach = function attach() {
  if (isAttached) return;
  isAttached = true;

  $(document).delegate('click', '[data-sort]', handleSort);
  $(document).delegate('click', '[data-sort-previous]', handlePreviousProxyClick);
};

exports.detach = function detach() {
  if (!isAttached) return;
  isAttached = false;

  $(document).undelegate('click', '[data-sort]', handleSort);
  $(document).undelegate('click', '[data-sort-previous]', handlePreviousProxyClick);
};

},{"../spotify-elements":45,"../spotify-elements/attributes":41,"../spotify-elements/traversal":47,"../spotify-live":212,"../spotify-live-sort-uri":210,"../spotify-logger/messages/UIInteraction4":223,"./center":52}],95:[function(require,module,exports){
'use strict';

var throttle = require('./util/throttle');
var center = require('./center');
var sort = require('./sort');

var DEFAULT_STICKY_CLASS_NAME = 'sticky-top';
var TTL_STICKIES = 4000;
var TTL_POSITIONS = 0;

var isAttached = false;
var nodesGBCR = null;
var rootGBCR = null;
var timestamp;

var updateStickies = function updateStickies(nodes) {
  var rects = getRects(TTL_STICKIES);
  var scrollTop = window.scrollY;
  var width = rects.root.width;
  var top = rects.root.top;
  var height = 0;

  resetOldStickies();

  (nodes instanceof Array ? nodes : rects.nodes).forEach(function (nodeInfo, i) {
    var node = nodeInfo.node;
    var rect = nodeInfo.rect;
    var stickyClone = node.stickyClone;
    var stickyClassName = nodeInfo.stickyClassName;

    // Check if the node should be sticked or not (if true, it should be).
    if (rect.top - top < scrollTop) {
      if (!(stickyClone || node).classList.contains(stickyClassName)) {
        // <THEAD>s can't be made sticky, so we clone it and add it to the DOM.
        if (node.nodeName.toLowerCase() === 'thead' && !node.stickyClone) {
          node = createClone(node);
        }

        node.classList.add(stickyClassName);

        // Update styles accordingly.
        node.setAttribute('data-sticky-active', '');
        node.style.right = width - rect.right + 'px';
        node.style.left = rect.left + 'px';
        node.style.position = 'fixed';
        node.style.top = height + 'px';
      } else {
        (stickyClone || node).style.top = height + 'px';
      }

      // Increment the top reference and the height. Do it even if the element is already sticked.
      height += rect.height;
      top += rect.height;
    } else {
      if ((stickyClone || node).classList.contains(stickyClassName)) {
        resetSticky(node);
      }
    }
  });
};

var updatePositions = function updatePositions() {
  var rects = getRects(TTL_POSITIONS);
  var width = rects.root.width;

  // Update left and right.
  rects.nodes.forEach(function (nodeInfo, i) {
    var node = nodeInfo.node;
    var rect = nodeInfo.rect;

    if (node.stickyClone) {
      node = node.stickyClone;
    }

    if (node.classList.contains(nodeInfo.stickyClassName)) {
      node.style.right = width - rect.right + 'px';
      node.style.left = rect.left + 'px';
    }
  });
};

var resetSticky = function resetSticky(node) {
  // <THEAD>s can't be made sticky, so verify if we are using a clone and remove it from the DOM.
  if (node.nodeName.toLowerCase() === 'thead' && node.stickyClone) {
    removeClone(node);
  }

  node.classList.remove(getStickyClassName(node));

  // Update styles accordingly.
  node.removeAttribute('data-sticky-active', '');
  node.style.right = '';
  node.style.left = '';
  node.style.position = '';
  node.style.top = '';
};

var resetOldStickies = function resetOldStickies() {
  var selector = '[data-sticky-active]:not([data-sticky])';
  var nodes = document.querySelectorAll(selector);
  for (var i = 0, l = nodes.length; i < l; i++) {
    if (!nodes[i].isStickyClone) {
      resetSticky(nodes[i]);
    }
  }
};

var getRects = function getRects(ttl) {
  var reference = timestamp + ttl;
  var nodes = document.querySelectorAll('[data-sticky]');

  // Refresh timestamp (always).
  timestamp = Date.now();

  // If the reference time is still valid, and nodes are the same, then return data.
  if (reference > timestamp && nodesGBCR && nodes.length === nodesGBCR.length) {
    var equal = true;

    for (var i = 0; i < nodes.length; i++) {
      equal = equal && nodes[i] === nodesGBCR[i].node;
    }

    if (equal) {
      return {
        nodes: nodesGBCR,
        root: rootGBCR
      };
    }
  }

  // Otherwise, compute and cache.
  rootGBCR = document.documentElement.getBoundingClientRect();
  nodesGBCR = Array.prototype.map.call(document.querySelectorAll('[data-sticky]'), function (node) {
    var parentRect = node.parentNode.getBoundingClientRect();
    var nodeRect = node.getBoundingClientRect();

    // Return a structure per node. Only some fields are stored in the rect object (the ones used).
    return {
      stickyClassName: getStickyClassName(node),
      node: node,
      rect: {
        top: parentRect.top,
        height: nodeRect.height,
        left: parentRect.left,
        right: parentRect.right
      }
    };
  });

  return {
    nodes: nodesGBCR,
    root: rootGBCR
  };
};

var createClone = function createClone(node) {
  var div = document.createElement('div');
  var thead = node.cloneNode(true);
  var table = node.parentNode.cloneNode(false);
  var onListSwap;

  table.appendChild(thead).removeAttribute('data-sticky');
  div.appendChild(table);
  div.className = 'sticky-clone';
  div.isStickyClone = true;

  onListSwap = function onListSwap(data) {
    var table = thead.parentNode;
    var uri = table && table.getAttribute('data-uri');

    // Update the "data-uri" of the cloned table, and the sort state of the original one.
    if (uri) {
      table.setAttribute('data-uri', data.after);
      sort.update(node.parentNode);
    };
  };

  center.on('list-swap', onListSwap);

  node.parentNode.parentNode.appendChild(div);
  node.style.visibility = 'hidden';
  node.stickyListSwapListener = onListSwap;
  node.stickyClone = div;

  return div;
};

var removeClone = function removeClone(node) {
  var stickyClone = node.stickyClone;

  if (stickyClone.parentNode) {
    stickyClone.parentNode.removeChild(stickyClone);
  }

  if (node.stickyListSwapListener) {
    center.off('list-swap', node.stickyListSwapListener);
  }

  node.style.removeProperty('visibility');

  delete node.stickyClone;
  delete node.stickyListSwapListener;
};

var getStickyClassName = function getStickyClassName(stickyNode) {
  var root = document.documentElement;
  var classSticky;
  var node;

  for (node = stickyNode; node !== root; node = node.parentNode) {
    if (classSticky = node.getAttribute('data-class-sticky')) {
      return classSticky;
    }
  }

  return DEFAULT_STICKY_CLASS_NAME;
};

exports.DEFAULT_STICKY_CLASS_NAME = DEFAULT_STICKY_CLASS_NAME;

exports.attach = function attach() {
  if (!isAttached) {
    isAttached = true;

    window.addEventListener('scroll', updateStickies);
    window.addEventListener('resize', updatePositions);
  }
};

exports.detach = function detach() {
  if (isAttached) {
    isAttached = false;

    window.removeEventListener('scroll', updateStickies);
    window.removeEventListener('resize', updatePositions);

    nodesGBCR = null;
    rootGBCR = null;
  }
};

exports.update = function (optNode) {
  if (isAttached) {
    nodesGBCR = null;
    rootGBCR = null;

    updateStickies();
  }
};

exports._getStickyClassName = getStickyClassName;

},{"./center":52,"./sort":94,"./util/throttle":106}],96:[function(require,module,exports){
module.exports={
  "drag_tooltip_many_items": "items",
  "drag_tooltip_many_tracks": "tracks",
  "drag_tooltip_many_artists": "artists",
  "drag_tooltip_many_albums": "albums",
  "drag_tooltip_many_playlists": "playlists",
  "drag_tooltip_many_users": "users"
}
},{}],97:[function(require,module,exports){
'use strict';

var $ = require('../spotify-elements');
var live = require('../spotify-live');
var dom = require('./util/dom');

var SELECTOR_THUMBS_DOWN_BUTTON = '[data-button=thumbs-down]';
var SELECTOR_THUMBS_UP_BUTTON = '[data-button=thumbs-up]';

/**
 * Handle the click on a Thumbs button.
 *
 * @param {MouseEvent} event An event object for a click event.
 * @param {HTMLElement} button A button DOM node.
 *
 * @private
 */
function handleThumbsButtonClick(event, button) {
  var type = dom.getAttributeFromNodeOrParent(button[0], 'data-button');
  var trackUri = dom.getAttributeFromNodeOrParent(button[0], 'data-uri');
  var contextUri = dom.getContextFromNodeOrParent(button[0]);

  // Must use track uri
  if (!trackUri || !contextUri) return;

  // Emit thumb event on context
  if (type === 'thumbs-down') {
    live(contextUri).emit('thumb-down', trackUri);
  } else if (type === 'thumbs-up') {
    live(contextUri).emit('thumb-up', trackUri);
  }
};

var isAttached = false;

/**
 * Attach the event listeners for the module.
 * Part of the spotify-events interface.
 */
exports.attach = function () {
  if (isAttached) return;
  isAttached = true;

  var doc = $(document);
  doc.delegate('click', SELECTOR_THUMBS_DOWN_BUTTON, handleThumbsButtonClick);
  doc.delegate('click', SELECTOR_THUMBS_UP_BUTTON, handleThumbsButtonClick);
};

/**
 * Detach the event listeners for the module.
 * Part of the spotify-events interface.
 */
exports.detach = function () {
  if (!isAttached) return;
  isAttached = false;

  var doc = $(document);
  doc.undelegate('click', SELECTOR_THUMBS_DOWN_BUTTON, handleThumbsButtonClick);
  doc.undelegate('click', SELECTOR_THUMBS_UP_BUTTON, handleThumbsButtonClick);
};

exports.update = function (optNode) {};

},{"../spotify-elements":45,"../spotify-live":212,"./util/dom":104}],98:[function(require,module,exports){
'use strict';

var $ = require('../spotify-elements');
var zen = require('../spotify-elements/zen');

var tooltipMargin = 8; // We want some spacing around the tooltip

var tooltip = zen('div#tooltip');
var tooltipNode = tooltip[0];
var tooltipTextNode = zen('span')[0];
var tooltipArrowTop = zen('div.tooltip-arrow-top');
var tooltipArrowBottom = zen('div.tooltip-arrow-bottom');
tooltip.appendChild(tooltipArrowTop);
tooltip.appendChild(tooltipArrowBottom);
tooltip.appendChild(tooltipTextNode);

var attachedNode = null;
var tooltipNodeAttached = false;

// tooltipArrow will point to the current visible tooltipArrow
// that can be either tooltipArrowTop or tooltipArrowBottom
var tooltipArrow = null;

var addTooltipToDOM = function addTooltipToDOM() {
  document.body.appendChild(tooltipNode);
  tooltipNodeAttached = true;
};

var removeTooltipFromDOM = function removeTooltipFromDOM() {
  attachedNode = null;
  if (tooltipNode.parentNode) document.body.removeChild(tooltipNode);

  tooltipNodeAttached = false;
};

var showTooltip = function showTooltip(event, node) {
  var realNode = node[0];
  var top = 0;
  var left = 0;

  var tooltipText = node.data('tooltip') || node.getAttribute('title');
  if (!tooltipText) return;

  // Remember the node we set the text from so that text can be updated.
  attachedNode = node;

  if (!node.tooltipCheck) {
    node.removeAttribute('title');
    node.setAttribute('data-tooltip', tooltipText);
    node.tooltipCheck = true;
  }

  if (!tooltipNodeAttached) addTooltipToDOM();

  setText(tooltipText);

  var tooltipHeight = tooltipNode.clientHeight;
  var tooltipWidth = tooltipNode.offsetWidth;

  // Don't use window.scrollY because cross browser issues.
  // https://developer.mozilla.org/en-US/docs/Web/API/Window.scrollY
  var scrollY = window.pageYOffset;

  var bounds = realNode.getBoundingClientRect();
  var targetHeight = realNode.offsetHeight;
  var targetWidth = realNode.offsetWidth;
  var targetTop = parseInt(bounds.top) + scrollY;
  var targetLeft = parseInt(bounds.left);
  var targetCenter = targetLeft + targetWidth / 2;
  var targetBottom = targetTop + targetHeight;
  var viewportWidth = document.documentElement.clientWidth;
  var viewportHeight = document.documentElement.clientHeight;

  // Decide if the tooltip should be over or under the node
  if (targetBottom + tooltipHeight + tooltipMargin - scrollY > viewportHeight) {
    // On top
    top = targetTop - tooltipHeight - tooltipMargin;
    tooltipArrowTop.removeClass('visible');
    tooltipArrowBottom.addClass('visible');
    tooltipArrow = tooltipArrowBottom;
  } else {
    top = targetTop + targetHeight + tooltipMargin;
    if (top - scrollY > viewportHeight) {
      top = viewportHeight - tooltipHeight;
    }
    tooltipArrowTop.addClass('visible');
    tooltipArrowBottom.removeClass('visible');
    tooltipArrow = tooltipArrowTop;
  }

  var distanceToTheRight = viewportWidth - tooltipMargin - targetCenter;
  var distanceToTheLeft = targetCenter - tooltipMargin;
  var tooltipOffsetRight = Math.max(0, tooltipWidth / 2 - distanceToTheRight);
  var tooltipOffsetLeft = Math.max(0, tooltipWidth / 2 - distanceToTheLeft);

  left = targetCenter - tooltipWidth / 2 - (tooltipOffsetRight || -tooltipOffsetLeft);

  tooltipNode.style.top = top + 'px';
  tooltipNode.style.left = left + 'px';
  tooltipArrow[0].style.left = targetCenter - left + 'px';

  if (node.hasAttribute('data-tooltip-instant')) {
    tooltip.addClass('instant');
  } else {
    tooltip.removeClass('instant');
  }

  tooltip.addClass('visible');
};

var hideTooltip = function hideTooltip() {
  attachedNode = null;
  setText('');
  tooltip.removeClass('visible');
  tooltipNode.style.left = 0;
  tooltipNode.style.top = 0;
  if (tooltipArrow) {
    tooltipArrow[0].style.left = 0;
  }
};

var setText = function setText(text) {
  tooltipTextNode.innerHTML = text;
};

var isAttached = false;

exports.attach = function attach() {
  if (isAttached) return;
  isAttached = true;

  var doc = $(document);
  doc.delegate('mouseover', '[data-tooltip]', showTooltip);
  doc.delegate('mouseout', '[data-tooltip]', hideTooltip);
  doc.on('keydown', hideTooltip);
  doc.on('mousedown', hideTooltip);
};

exports.detach = function detach() {
  if (!isAttached) return;
  isAttached = false;

  removeTooltipFromDOM();
  var doc = $(document);
  doc.undelegate('mouseover', '[data-tooltip]', showTooltip);
  doc.undelegate('mouseout', '[data-tooltip]', hideTooltip);
  doc.off('keydown', hideTooltip);
  doc.off('mousedown', hideTooltip);
};

/** Forces an update of the tooltip text. */
exports.update = function update() {
  if (!isAttached) return;

  if (!attachedNode) return;

  if (attachedNode.data('tooltip')) {
    showTooltip(null, attachedNode);
  } else {
    // The tooltip no longer has text and should be hidden.
    hideTooltip();
  }
};

// Export for testing purposes
exports._setText = setText;

},{"../spotify-elements":45,"../spotify-elements/zen":48}],99:[function(require,module,exports){
'use strict';

var $ = require('../spotify-elements');

var doc = $(document);
var hoverActive = true;

/* Store events in an array */
var touchArray = [];
var addEvent = function addEvent(touchEvent) {
  touchArray.push(touchEvent);
};

function getMediaObjects() {
  return doc.search('.media-object');
}

function isMediaObject(element) {
  return !!element.closest('.media-object');
}

function handleEvent(e) {
  var target = e.target;
  if (isMediaObject(target)) {
    switch (e.type) {
      case 'touchstart':
        addEvent(e);
        if (hoverActive) {
          disableHover(e);
        }
        break;

      case 'touchmove':
        addEvent(e);
        break;

      case 'touchend':

        if (target && touchArray.length === 1 && touchArray[0].type === 'touchstart') {
          e.preventDefault();
          target.click();
        }
        touchArray = [];
        break;

      case 'contextmenu':
        addEvent(e);
        break;

      case 'mousemove':
        if (!hoverActive) {
          enableHover(e);
        }
        break;
    }
  }
}

function disableHover(e) {
  var mediaObjects = getMediaObjects();
  if (mediaObjects) {
    mediaObjects.forEach(function (object) {
      // Find available hover elements
      var overlay = $(object).find('.mo-overlay');
      // Hide hover elements
      if (overlay) {
        var add = $(object).find('.mo-add');
        var play = $(object).find('.mo-play');
        var more = $(object).find('.mo-more');
        var del = $(object).find('.mo-delete');

        hide(overlay);
        if (add) {
          hide(add);
        }
        if (play) {
          hide(play);
        }
        if (more) {
          hide(more);
        }
        if (del) {
          hide(del);
        }
      }
    });
    hoverActive = false;
  }

  function hide(element) {
    element.addClass('not-visible');
  }
}

function enableHover(e) {
  var mediaObjects = getMediaObjects();
  if (mediaObjects) {
    // Show hover elements
    mediaObjects.forEach(function (object) {
      var elements = $(object).search('.not-visible');
      if (elements) {
        show(elements);
        hoverActive = true;
      }
    });
  }

  function show(element) {
    element.removeClass('not-visible');
  }
}

var isAttached = false;

exports.attach = function () {
  if (isAttached) return;
  isAttached = true;

  doc.on('touchstart', handleEvent);
  doc.on('touchmove', handleEvent);
  doc.on('touchend', handleEvent);
  doc.on('mousemove', handleEvent);
  doc.on('contextmenu', handleEvent);
};

exports.detach = function () {
  if (!isAttached) return;
  isAttached = false;

  doc.off('touchstart', handleEvent);
  doc.off('touchmove', handleEvent);
  doc.off('touchend', handleEvent);
  doc.off('mousemove', handleEvent);
  doc.off('contextmenu', handleEvent);
};

exports.update = function () {};

exports._reset = function () {
  hoverActive = true;
  touchArray = [];
};

},{"../spotify-elements":45}],100:[function(require,module,exports){
'use strict';

var prime = require('prime');
var Emitter = require('prime/emitter');
var Range = require('../../spotify-range2');

var SYNC = Emitter.EMIT_SYNC;

module.exports = prime({
  mixin: Emitter,

  constructor: function constructor(container, params) {
    this.container = container;

    this.height = params.height || 0;
    this.length = params.length || 0;

    this.tag = params.tag || 'li';
    this.request = params.request;

    // Unique call identificator.
    this._id = 0;

    this.reset();
  },

  resetFrom: function resetFrom(fromIndex, length, hiddenIndices) {
    var range = this._range;

    // Redirect the call to reset.
    if (fromIndex < range.end) {
      this.reset(length, hiddenIndices);
      this.show(range);
    }
  },

  reset: function reset(length, hiddenIndices) {
    var tag = this.tag;
    var totalHeight;

    if (typeof length !== 'undefined') {
      this.length = length;
    }

    totalHeight = this.length * this.height;

    // Hidden indices are not supported anymore (legacy).
    if (hiddenIndices) {
      throw new TypeError('Hidden indices are not supported anymore!');
    }

    this.container.innerHTML = '<' + tag + ' style="height:' + totalHeight + 'px"></' + tag + '>' + '<' + tag + ' style="height:0px"></' + tag + '>';

    this._range = new Range(0, 0);
    this._waitingRange = new Range(0, 0);

    // An array of ranges representing the visible nodes.
    this.emit('index-change', [], SYNC);
  },

  show: function show(range) {
    var length = this.length;
    var actual = this._range;
    var waiting = this._waitingRange;

    // Limit range to the [0, length) interval.
    var bound = new Range(Math.max(0, range.start), Math.min(length, range.end));

    // If the range requested is the same, do nothing.
    if (bound.start === actual.start && bound.end === actual.end) {
      return;
    }

    // If the range requested is the same, do nothing.
    if (bound.start === waiting.start && bound.end === waiting.end) {
      return;
    }

    this._drawRange(bound);
  },

  _drawRange: function _drawRange(range) {
    var container = this.container;
    var oldRange = this._range;
    var height = this.height;
    var length = this.length;
    var tag = this.tag;
    var id = ++this._id;
    var self = this;

    this._waitingRange = range;

    // Request the whole range. We will manually intersect later with the current one.
    this.request(range, function (err, nodes) {
      var oldLength = oldRange.length;
      var newLength = range.length;
      var diff = 0;
      var first;
      var last;
      var i;

      // If a new range has been requested in the meantime, don't draw/modify anything.
      if (id !== self._id) {
        return;
      }

      // Cache the range requested.
      self._range = range;
      self._waitingRange = new Range(0, 0);

      // Get first and last nodes as references. We will use them for removing/adding nodes.
      first = container.firstChild;
      last = container.lastChild;

      // Change heights of the paddings.
      first.style.height = range.start * height + 'px';
      last.style.height = (length - range.end) * height + 'px';

      // Remove old nodes. Since nodes change their position when removing them one by one,
      // we have to keep the cumulative sum of nodes removed cached.
      oldRange.subtract(range).forEach(function (subrange) {
        var length = subrange.length;

        for (i = 0; i < length; i++) {
          // We add one to the children index because the first child is not a row but the top padding.
          container.removeChild(container.children[subrange.start - oldRange.start - diff + 1]);
        }

        diff += length;
      });

      // Add new nodes. If the new nodes are below the old range, insert them at the top;
      // otherwise, insert them at the bottom.
      range.subtract(oldRange).forEach(function (subrange) {
        var length = subrange.length;
        var start = subrange.start - range.start;
        var subnodes = nodes.slice(start, start + length);
        var ref;

        // Emit a change before.
        self.emit('before-show', subrange, subnodes, SYNC);

        // Get the reference node. If the range is below, then insert at the top.
        // Otherwise, insert at the bottom.
        if (subrange.below(oldRange)) {
          ref = first.nextSibling;
        } else {
          ref = last;
        }

        for (i = 0; i < length; i++) {
          container.insertBefore(subnodes[i], ref);
        }

        // Emit a change after.
        self.emit('after-show', subrange, subnodes, SYNC);
      });

      self.emit('index-change', [range], SYNC);
    });
  }
});

},{"../../spotify-range2":251,"prime":375,"prime/emitter":374}],101:[function(require,module,exports){
'use strict';

var Position = function Position(containerIndex, index) {
  this.containerIndex = containerIndex;
  this.index = index;
};

Position.prototype.isSame = function (position) {
  return this.containerIndex === position.containerIndex && this.index === position.index;
};

module.exports = Position;

},{}],102:[function(require,module,exports){
'use strict';

var live = require('../../spotify-live');

function checkIfActive() {
  return live('spotify:application').get('active') || false;
}

function checkIfFocused() {

  // If the active element of the top frame has a contentWindow that matches
  // this window, it means the iframe of this app is in focus.
  var topActiveElement = window.top.document.activeElement;
  var activeWindow = topActiveElement && topActiveElement.contentWindow;
  if (activeWindow) {
    return activeWindow === window;
  }

  // Top frame (zlink)
  if (window.top === window) {
    return true;
  }

  return false;
};

exports.isActive = function () {
  return checkIfActive();
};

exports.isActiveAndFocused = function () {
  return checkIfActive() && checkIfFocused();
};

},{"../../spotify-live":212}],103:[function(require,module,exports){
/**
 * @module spotify-events/util/cosmos
 * @private
 */

'use strict';

var live = require('../../spotify-live');
var cosmos = require('spotify-cosmos-api');
var liburi = require('spotify-liburi');

var ASAP = live.ASAP;

function DELETE(options, opt_callback) {
  options.method = exports.cosmos.Action.DELETE;
  return request(options, opt_callback);
}

function GET(options, opt_callback) {
  options.method = exports.cosmos.Action.GET;
  return request(options, opt_callback);
}

function SUB(options, opt_callback) {
  options.method = exports.cosmos.Action.SUB;
  return request(options, opt_callback);
}

function POST(options, opt_callback) {
  options.method = exports.cosmos.Action.POST;
  return request(options, opt_callback);
}

function PUT(options, opt_callback) {
  options.method = exports.cosmos.Action.PUT;
  return request(options, opt_callback);
}

function HEAD(options, opt_callback) {
  options.method = exports.cosmos.Action.HEAD;
  return request(options, opt_callback);
}

function request(options, opt_callback) {
  var method = options.method;
  delete options.method;

  var subscription, canceled;

  sanitizeURL(options.url, function (error, url) {
    if (error) return opt_callback && opt_callback(error);

    // if you cancel before the userName is replaced.
    if (canceled) return;

    var request = new exports.cosmos.Request(method || exports.cosmos.Action.GET, url, options.headers, options.body);
    subscription = exports.cosmos.resolver.resolve(request, function (error, response) {
      if (!opt_callback) return;
      if (error) return opt_callback(error);
      try {
        opt_callback(null, {
          body: JSON.parse(response.getBody() || '{}'),
          headers: response.getHeaders(),
          status: response.getStatusCode()
        });
      } catch (parseError) {
        parseError.response = response;
        opt_callback(parseError);
      }
    });
  });

  return {
    cancel: function cancel() {
      if (subscription && subscription.cancel) {
        // we already subscribed, cancel it.
        subscription.cancel();
        subscription = null;
      } else if (!canceled) {
        // not subscribed yet, don't even subscribe.
        canceled = true;
      }
      return null;
    }
  };
}

function sanitizeURL(url, callback) {
  if (url.indexOf('@') > -1) {
    live('spotify:client').query('currentUser(username)', function (error, data) {
      if (error) return callback(error);
      callback(null, url.replace('@', liburi.getCanonicalUsername(data.currentUser.username)));
    }, ASAP);
  } else {
    callback(null, url);
  }
}

exports.request = request;
exports.get = GET;
exports.post = POST;
exports.subscribe = SUB;
exports.delete = DELETE;
exports.put = PUT;
exports.head = HEAD;
exports.cosmos = cosmos;

exports.sanitizeURL = sanitizeURL;

},{"../../spotify-live":212,"spotify-cosmos-api":388,"spotify-liburi":398}],104:[function(require,module,exports){
'use strict';

/**
 * @public
 */

/**
 * Get the context URI from the specified node or its parents.
 *
 * @param {HTMLElement} node A DOM node.
 *
 * @return {string} The context URI or empty string if not found.
 */

function getContextFromNodeOrParent(node) {
  var contextNode = node.closest('[data-context]');
  return contextNode && contextNode.getAttribute('data-uri') || '';
};

/**
 * Get the value for the passed attribute name, either from the passed node
 * or from any parent node.
 *
 * @param {HTMLElement} node The node to start searching from.
 * @param {string} attributeName The name of the attribute.
 *
 * @return {string} The value, or empty string if not found.
 */
function getAttributeFromNodeOrParent(node, attributeName) {
  var selector = '[' + attributeName + ']';
  var attributeNode = node.closest(selector);
  return attributeNode && attributeNode.getAttribute(attributeName) || '';
};

exports.getContextFromNodeOrParent = getContextFromNodeOrParent;
exports.getAttributeFromNodeOrParent = getAttributeFromNodeOrParent;

},{}],105:[function(require,module,exports){
'use strict';

module.exports = function getLogContext(target) {
  var currentNode = target;
  var logContext = [];
  while (currentNode) {
    if (currentNode.matches && currentNode.matches('[data-log-context]')) {
      logContext.unshift(currentNode.getAttribute('data-log-context'));
    }
    currentNode = currentNode.parentNode;
  }
  return logContext.join('/') || null;
};

},{}],106:[function(require,module,exports){
'use strict';

var defer = require('prime/defer');

/**
 * Throttle the function calls to only trigger once per tick.
 * This will return a new function that you will use when you want
 * to call your function. Calling it multiple times in the same
 * run loop will only really call it once.
 *
 * @param {function} fn A function.
 * @param {Object=} opt_ctx The context to run the function in ('this').
 *
 * @return {function} A new function.
 */
function throttle(fn, opt_ctx) {
  var queued = false;
  var args;

  return function () {
    args = arguments;
    if (!queued) {
      queued = true;
      defer.frame(function () {
        queued = false;
        fn.apply(opt_ctx, args);
      });
    }
  };
}

module.exports = throttle;

},{"prime/defer":373}],107:[function(require,module,exports){
'use strict';

var $ = require('../spotify-elements');
var live = require('../spotify-live');

var update = function update(node) {

  var observables = ($(node) || $(document)).search('[data-watch]');

  if (observables) observables.forEach(function (node) {
    node = $(node);
    var key = node.data('watch');

    if (!key) return;

    var observed = node._observed || (node._observed = {});

    if (observed[key]) return;
    observed[key] = true;

    var parent;

    var uriNode = node[0].closest('[data-uri]');
    var uri = uriNode && uriNode.getAttribute('data-uri');

    if (!uri) return;

    var model = live(uri);

    var updateText = function updateText(event) {
      if (key in event) {
        var value = event[key];
        node.text(value == null ? '' : value);
      }
    };

    model.get(key, function (err, value) {
      if (err) throw err;
      var event = {};
      event[key] = value;
      updateText(event);
    });

    model.on('update', updateText);
  });
};

var isAttached = false;

exports.update = function (optNode) {
  if (!isAttached) return;

  update(optNode);
};
exports.attach = function () {
  if (isAttached) return;
  isAttached = true;
};
exports.detach = function () {
  if (!isAttached) return;
  isAttached = false;
};

},{"../spotify-elements":45,"../spotify-live":212}],108:[function(require,module,exports){
(function (global){
'use strict';

exports.init = function () {
  require('./expose-debug-global').expose(global, 'bridge', require('../spotify-bridge-request'));
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-bridge-request":38,"./expose-debug-global":110}],109:[function(require,module,exports){
(function (global){
'use strict';

exports.init = function () {
  require('./expose-debug-global').expose(global, 'cosmos', require('spotify-cosmos-api'));
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./expose-debug-global":110,"spotify-cosmos-api":388}],110:[function(require,module,exports){
'use strict';

exports.expose = function (global, name, object) {
  if (global.__spotify && global.__spotify.developer_mode) {
    Object.defineProperty(global, name, {
      get: function get() {
        try {
          throw new Error();
        } catch (error) {
          if (!/injectedscript/i.test(error.stack)) {
            throw new Error('window.' + name + ' should only be accessed from the console');
          }
        }
        return object;
      },
      enumerable: true,
      configurable: true
    });
  }
};

},{}],111:[function(require,module,exports){
(function (global){
'use strict';

exports.init = function () {
  require('./expose-debug-global').expose(global, 'live', require('../spotify-live'));
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-live":212,"./expose-debug-global":110}],112:[function(require,module,exports){
module.exports = {
  "Album": "Album",
  "AndMore": "und {0} weitere",
  "Artist": "Künstler",
  "By": "von",
  "Create Similar Playlist": "Ähnliche Playlist erstellen",
  "Filter": "Filter",
  "Follow": "Folgen",
  "Follower": "Follower",
  "FollowersLabel": "Followers",
  "Following": "Folge ich",
  "FollowingLabel": "Folge ich",
  "ListenersLabel": "Monatliche Hörer",
  "FollowsYou": "Folgt dir",
  "HoldToPreview": "Zum Reinhören gedrückt halten",
  "ListenCount": "{0} Mal abgespielt",
  "ListenReactionMulti": "{0} Hörer in Deinem Netzwerk",
  "ListenReactionSingle": "{0} hört sich das an",
  "LocalFile": "Lokale Datei",
  "More": "Mehr",
  "Pause": "Pause",
  "Play": "Play",
  "Playlist": "Playlist",
  "PressEnterToPlay": "Drück die Eingabetaste zum Abspielen",
  "Popularity": "Beliebtheit",
  "Remove": "Entfernen",
  "RemoveYourMusic": "Aus \"Deine Musik\" entfernen",
  "Save": "Speichern",
  "SaveYourMusic": "In \"Deine Musik\" speichern",
  "Saved": "Gespeichert",
  "ShufflePlay": "Shuffle",
  "Song": "Song",
  "StartRadio": "Radio starten",
  "Time": "Dauer",
  "Toplist": "Top-Songs",
  "Track": "Song",
  "Unfollow": "Nicht mehr folgen",
  "User": "Benutzer",
  "ViewAll": "Mehr Darstellung",
  "HoursShort": "{0} Std.",
  "MinutesShort": "{0} Min.",
  "SecondsShort": "{0} Sek.",
  "ErrorTitle": "Bei der Anzeige dieser Ansicht ist ein Fehler aufgetreten!",
  "ErrorMessage": "Diese Ansicht ist entweder nicht vorhanden oder es ist ein Fehler aufgetreten.",
  "OfflineTitle": "Diese Ansicht ist offline nicht verfügbar.",
  "OfflineMessage": "Geh zum Laden online."
};
},{}],113:[function(require,module,exports){
module.exports = {
  "Album": "Άλμπουμ",
  "AndMore": "και άλλοι {0}",
  "Artist": "Καλλιτέχνης",
  "By": "από",
  "Create Similar Playlist": "Δημιουργία παρόμοιας playlist",
  "Filter": "Φίλτρο",
  "Follow": "Ακολούθησε",
  "Follower": "Οπαδός",
  "FollowersLabel": "Οπαδοί",
  "Following": "Aκολουθείται",
  "FollowingLabel": "Aκολουθείται",
  "ListenersLabel": "Μηνιαίοι ακροατές",
  "FollowsYou": "Σε ακολουθεί",
  "HoldToPreview": "Πάτησε και κράτησε πατημένο για προεπισκόπηση",
  "ListenCount": "{0} αναπαραγωγές",
  "ListenReactionMulti": "{0} ακροατές στο δίκτυό σου",
  "ListenReactionSingle": "Ο χρήστης {0} ακούει αυτό",
  "LocalFile": "Τοπικό αρχείο",
  "More": "Περισσότερα",
  "Pause": "Παύση",
  "Play": "Αναπαραγωγή",
  "Playlist": "Λίστα",
  "PressEnterToPlay": "Πάτησε Enter για αναπαραγωγή",
  "Popularity": "Δημοφιλία",
  "Remove": "Αφαίρεση",
  "RemoveYourMusic": "Αφαίρεση από τη Mουσική σου",
  "Save": "Αποθήκευση",
  "SaveYourMusic": "Αποθήκευση στη Mουσική σου",
  "Saved": "Αποθηκεύτηκε",
  "ShufflePlay": "Τυχαία αναπαραγωγή",
  "Song": "Τραγούδι",
  "StartRadio": "Έναρξη ραδιοφώνου",
  "Time": "Διάρκεια",
  "Toplist": "Κορυφαία τραγούδια",
  "Track": "Τραγούδι",
  "Unfollow": "Άρση ακολούθησης",
  "User": "Χρήστης",
  "ViewAll": "Δες τα όλα",
  "HoursShort": "{0} ώρα",
  "MinutesShort": "{0} λεπ.",
  "SecondsShort": "{0} δευτ.",
  "ErrorTitle": "Προέκυψε σφάλμα κατά την προβολή αυτής της οθόνης!",
  "ErrorMessage": "Η συγκεκριμένη προβολή δεν υπάρχει ή προέκυψε κάποιο σφάλμα.",
  "OfflineTitle": "Αυτή η προβολή δεν είναι διαθέσιμη εκτός σύνδεσης!",
  "OfflineMessage": "Συνδέσου στο διαδίκτυο για να πραγματοποιηθεί φόρτωση."
};
},{}],114:[function(require,module,exports){
module.exports = {
  "Album": "Album",
  "AndMore": "and {0} more",
  "Artist": "Artist",
  "By": "by",
  "Create Similar Playlist": "Create Similar Playlist",
  "Filter": "Filter",
  "Follow": "Follow",
  "Follower": "Follower",
  "FollowersLabel": "Followers",
  "Following": "Following",
  "FollowingLabel": "Following",
  "ListenersLabel": "Monthly Listeners",
  "FollowsYou": "Follows You",
  "HoldToPreview": "Click and Hold to Preview",
  "ListenCount": "{0} plays",
  "ListenReactionMulti": "{0} listeners in your network",
  "ListenReactionSingle": "{0} listens to this",
  "LocalFile": "Local File",
  "More": "More",
  "Pause": "Pause",
  "Play": "Play",
  "Playlist": "Playlist",
  "PressEnterToPlay": "Press Enter to play",
  "Popularity": "Popularity",
  "Remove": "Remove",
  "RemoveYourMusic": "Remove from Your Music",
  "Save": "Save",
  "SaveYourMusic": "Save to Your Music",
  "Saved": "Saved",
  "ShufflePlay": "Shuffle Play",
  "Song": "Song",
  "StartRadio": "Start Radio",
  "Time": "Time",
  "Toplist": "Top songs",
  "Track": "Song",
  "Unfollow": "Unfollow",
  "User": "User",
  "ViewAll": "View All",
  "HoursShort": "{0} hr",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} sec",
  "ErrorTitle": "There was a problem displaying this view!",
  "ErrorMessage": "This view either does not exist or an error occurred.",
  "OfflineTitle": "This view is not available offline!",
  "OfflineMessage": "Please go online to load."
}
;
},{}],115:[function(require,module,exports){
module.exports = {
  "Album": "Álbum",
  "AndMore": "y {0} más",
  "Artist": "Artista",
  "By": "por",
  "Create Similar Playlist": "Crear playlist similar",
  "Filter": "Filtrar",
  "Follow": "Seguir",
  "Follower": "Seguidor",
  "FollowersLabel": "Seguidores",
  "Following": "Siguiendo",
  "FollowingLabel": "Siguiendo",
  "ListenersLabel": "Oyentes mensuales",
  "FollowsYou": "Te sigue",
  "HoldToPreview": "Haz clic y mantén pulsado para oír la muestra preliminar",
  "ListenCount": "{0} reproducciones",
  "ListenReactionMulti": "{0} oyentes en tu red",
  "ListenReactionSingle": "{0} escucha esto",
  "LocalFile": "Archivo local",
  "More": "Más",
  "Pause": "Pausa",
  "Play": "Reproducir",
  "Playlist": "Lista",
  "PressEnterToPlay": "Presiona Enter para reproducir",
  "Popularity": "Popularidad",
  "Remove": "Eliminar",
  "RemoveYourMusic": "Eliminar de Tu Música",
  "Save": "Guardar",
  "SaveYourMusic": "Guardar en Tu Música",
  "Saved": "Guardado",
  "ShufflePlay": "Aleatoria",
  "Song": "Canción",
  "StartRadio": "Comenzar Radio",
  "Time": "Tiempo",
  "Toplist": "Canciones más reproducidas",
  "Track": "Canción",
  "Unfollow": "Dejar de seguir",
  "User": "Usuario",
  "ViewAll": "Ver todos",
  "HoursShort": "{0} hr",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} seg",
  "ErrorTitle": "Hubo un problema al mostrar esta vista.",
  "ErrorMessage": "Puede ser que esta vista no exista, o bien, que haya ocurrido un error.",
  "OfflineTitle": "Esta vista no está disponible sin conexión. ",
  "OfflineMessage": "Conéctate a la red para cargar."
};
},{}],116:[function(require,module,exports){
module.exports = {
  "Album": "Álbum",
  "AndMore": "y {0} más",
  "Artist": "Artista",
  "By": "por",
  "Create Similar Playlist": "Crear playlist similar",
  "Filter": "Filtrar",
  "Follow": "Seguir",
  "Follower": "Seguidor",
  "FollowersLabel": "Seguidores",
  "Following": "Siguiendo",
  "FollowingLabel": "Siguiendo",
  "ListenersLabel": "Oyentes mensuales",
  "FollowsYou": "Te sigue",
  "HoldToPreview": "Pulsa y mantén pulsado para oír la muestra preliminar",
  "ListenCount": "{0} reproducciones",
  "ListenReactionMulti": "{0} oyentes en tu red",
  "ListenReactionSingle": "{0} escucha esto",
  "LocalFile": "Archivo local",
  "More": "Más",
  "Pause": "Pausar",
  "Play": "Reproducir",
  "Playlist": "Lista",
  "PressEnterToPlay": "Pulsa Intro para reproducir",
  "Popularity": "Popularidad",
  "Remove": "Retirar",
  "RemoveYourMusic": "Eliminar de Tu música",
  "Save": "Guardar",
  "SaveYourMusic": "Guardar en Tu música",
  "Saved": "Guardada",
  "ShufflePlay": "Aleatoria",
  "Song": "Canción",
  "StartRadio": "Comenzar radio",
  "Time": "Tiempo",
  "Toplist": "Canciones más escuchadas",
  "Track": "Canción",
  "Unfollow": "Dejar de seguir",
  "User": "Usuario",
  "ViewAll": "Ver todos",
  "HoursShort": "{0} hr",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} seg",
  "ErrorTitle": "Se ha producido un problema al mostrar esta vista.",
  "ErrorMessage": "Esta vista no existe o se ha producido un error.",
  "OfflineTitle": "Esta vista no está disponible sin conexión. ",
  "OfflineMessage": "Por favor, conéctate para cargar."
};
},{}],117:[function(require,module,exports){
module.exports = {
  "Album": "Albumi",
  "AndMore": "ja {0} muuta",
  "Artist": "Artisti",
  "By": "tekijältä",
  "Create Similar Playlist": "Luo samankaltainen soittolista",
  "Filter": "Suodatin",
  "Follow": "Seuraa",
  "Follower": "Seuraaja",
  "FollowersLabel": "Seuraajat",
  "Following": "Seurataan",
  "FollowingLabel": "Seurataan",
  "ListenersLabel": "Kuuntelijat kuukauden aikana",
  "FollowsYou": "Seuraa sinua",
  "HoldToPreview": "Kuuntele pätkä pitämällä tätä painettuna",
  "ListenCount": "{0} toistoa",
  "ListenReactionMulti": "{0} kuuntelijaa verkostossasi",
  "ListenReactionSingle": "{0} kuuntelee tätä",
  "LocalFile": "Paikallinen tiedosto",
  "More": "Lisää",
  "Pause": "Tauko",
  "Play": "Toista",
  "Playlist": "Soittolista",
  "PressEnterToPlay": "Toista painamalla Enter-näppäintä",
  "Popularity": "Suosio",
  "Remove": "Poista",
  "RemoveYourMusic": "Poista Omasta musiikista",
  "Save": "Tallenna",
  "SaveYourMusic": "Tallenna Omaan musiikkiin",
  "Saved": "Tallennettu",
  "ShufflePlay": "Satunnaistoisto",
  "Song": "Kappale",
  "StartRadio": "Käynnistä radio",
  "Time": "Kesto",
  "Toplist": "Suosituimmat kappaleet",
  "Track": "Kappale",
  "Unfollow": "Lopeta seuraaminen",
  "User": "Käyttäjä",
  "ViewAll": "Näytä kaikki",
  "HoursShort": "{0} h",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} s",
  "ErrorTitle": "Tämän näkymän näyttämisessä on ongelmia.",
  "ErrorMessage": "Tätä näkymää ei ole, tai tapahtui virhe.",
  "OfflineTitle": "Tätä näkymää ei voi käyttää offline-tilassa!",
  "OfflineMessage": "Siirry online-tilaan, jotta voit ladata."
};
},{}],118:[function(require,module,exports){
module.exports = {
  "Album": "Album",
  "AndMore": "et {0} autres",
  "Artist": "Artiste",
  "By": "par",
  "Create Similar Playlist": "Créer une liste de lecture semblable",
  "Filter": "Filtrer",
  "Follow": "Suivre",
  "Follower": "Abonné",
  "FollowersLabel": "Abonné",
  "Following": "Suivis",
  "FollowingLabel": "Suivis",
  "ListenersLabel": "Auditeurs mensuels",
  "FollowsYou": "Vous suit",
  "HoldToPreview": "Cliquez longuement pour avoir un aperçu",
  "ListenCount": "{0} écoutes",
  "ListenReactionMulti": "{0} auditeurs dans votre réseau",
  "ListenReactionSingle": "{0} écoute ceci",
  "LocalFile": "Fichier local",
  "More": "Plus",
  "Pause": "Pause",
  "Play": "Lecture",
  "Playlist": "Playlist",
  "PressEnterToPlay": "Appuyez sur Entrée pour faire la lecture",
  "Popularity": "Popularité",
  "Remove": "Supprimer",
  "RemoveYourMusic": "Supprimer de Votre musique",
  "Save": "Sauvegarder",
  "SaveYourMusic": "Enregistrer dans Votre musique",
  "Saved": "Sauvegardé",
  "ShufflePlay": "Lecture aléatoire",
  "Song": "Titre",
  "StartRadio": "Lancer la radio",
  "Time": "Durée",
  "Toplist": "Meilleures chansons",
  "Track": "Titre",
  "Unfollow": "Ne plus suivre",
  "User": "Utilisateur",
  "ViewAll": "Voir tout",
  "HoursShort": "{0} h",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} s",
  "ErrorTitle": "Un problème est survenu lors du chargement de cet affichage!",
  "ErrorMessage": "L'affichage n'existe pas ou une erreur s'est produite.",
  "OfflineTitle": "Cette vue n'est pas disponible hors ligne!",
  "OfflineMessage": "Veuillez accéder à Internet pour charger le contenu."
};
},{}],119:[function(require,module,exports){
module.exports = {
  "Album": "Album",
  "AndMore": "et {0} autres",
  "Artist": "Artiste",
  "By": "par",
  "Create Similar Playlist": "Créer une playlist similaire",
  "Filter": "Filtre",
  "Follow": "S'abonner",
  "Follower": "Abonné",
  "FollowersLabel": "Abonnés",
  "Following": "Abonné",
  "FollowingLabel": "Abonné",
  "ListenersLabel": "Nombres de personnes qui écoutent par mois",
  "FollowsYou": "Est abonné à vous",
  "HoldToPreview": "Cliquez longuement pour avoir un aperçu",
  "ListenCount": "{0} écoutes",
  "ListenReactionMulti": "{0} auditeurs dans votre réseau",
  "ListenReactionSingle": "{0} écoute ceci.",
  "LocalFile": "Fichier local",
  "More": "Plus",
  "Pause": "Pause",
  "Play": "Lire",
  "Playlist": "Playlist",
  "PressEnterToPlay": "Appuyez sur Entrée pour écouter",
  "Popularity": "Popularité",
  "Remove": "Supprimer",
  "RemoveYourMusic": "Supprimer de Ma musique",
  "Save": "Sauvegarder",
  "SaveYourMusic": "Sauvegarder dans Ma musique",
  "Saved": "Sauvegardé",
  "ShufflePlay": "Aléatoire",
  "Song": "Titre",
  "StartRadio": "Ecouter la radio",
  "Time": "Durée",
  "Toplist": "Top titres",
  "Track": "Titre",
  "Unfollow": "Se désabonner",
  "User": "Utilisateur",
  "ViewAll": "Présentation tout",
  "HoursShort": "{0} h",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} s",
  "ErrorTitle": "Problème d'affichage !",
  "ErrorMessage": "Cet affichage n'existe pas ou une erreur s'est produite.",
  "OfflineTitle": "Cet affichage n'est pas disponible hors connexion.",
  "OfflineMessage": "Connectez-vous pour procéder au chargement."
};
},{}],120:[function(require,module,exports){
module.exports = {
  "Album": "Album",
  "AndMore": "és még {0} felhasználó",
  "Artist": "Előadó",
  "By": "tőle:",
  "Create Similar Playlist": "Hasonló műsorlista létrehozása",
  "Filter": "Szűrő",
  "Follow": "Követés",
  "Follower": "Követő",
  "FollowersLabel": "Követők",
  "Following": "Követések",
  "FollowingLabel": "Követések",
  "ListenersLabel": "Hallgatók havonta",
  "FollowsYou": "Téged követ",
  "HoldToPreview": "Tartsd nyomva a belehallgatáshoz",
  "ListenCount": "{0} lejátszás",
  "ListenReactionMulti": "{0} ismerősöd hallgatta meg",
  "ListenReactionSingle": "{0} már meghallgatta",
  "LocalFile": "Helyi fájl",
  "More": "Több",
  "Pause": "Szünet",
  "Play": "Lejátszás",
  "Playlist": "Lejátszási lista",
  "PressEnterToPlay": "Lejátszás az Enterrel",
  "Popularity": "Népszerűség",
  "Remove": "Eltávolítás",
  "RemoveYourMusic": "Törlés a Zenéid közül",
  "Save": "Mentés",
  "SaveYourMusic": "Mentés a Zenéid közé",
  "Saved": "Mentett",
  "ShufflePlay": "Lejátszás keverve",
  "Song": "Dal",
  "StartRadio": "Rádió bekapcsolása",
  "Time": "Idő",
  "Toplist": "Toplista",
  "Track": "Dal",
  "Unfollow": "Nem követem",
  "User": "Felhasználó",
  "ViewAll": "Mindent mutat",
  "HoursShort": "{0} óra",
  "MinutesShort": "{0} perc",
  "SecondsShort": "{0} mp",
  "ErrorTitle": "Egy hiba miatt nem jeleníthető meg ez az oldal",
  "ErrorMessage": "A kért nézet nem létezik, vagy valamilyen műszaki hiba történt.",
  "OfflineTitle": "Ez a nézet internetkapcsolat nélkül nem érhető el.",
  "OfflineMessage": "Csatlakozz az internethez, majd indítsd el."
};
},{}],121:[function(require,module,exports){
module.exports = {
  "Album": "Album",
  "AndMore": "dan {0} lagi",
  "Artist": "Artis",
  "By": "menurut",
  "Create Similar Playlist": "Buat Playlist Serupa",
  "Filter": "Filter",
  "Follow": "Ikuti",
  "Follower": "Pengikut",
  "FollowersLabel": "Pengikut",
  "Following": "Mengikuti",
  "FollowingLabel": "Mengikuti",
  "ListenersLabel": "Pendengar Bulanan",
  "FollowsYou": "Mengikutimu",
  "HoldToPreview": "Klik dan Tahan untuk Pratinjau",
  "ListenCount": "{0} permainan",
  "ListenReactionMulti": "{0} pendengar di jaringanmu",
  "ListenReactionSingle": "{0} mendengarkan ini",
  "LocalFile": "File Lokal",
  "More": "Lainnya",
  "Pause": "Jeda",
  "Play": "Play",
  "Playlist": "Playlist",
  "PressEnterToPlay": "Tekan Enter untuk memainkan",
  "Popularity": "Popularitas",
  "Remove": "Hapus",
  "RemoveYourMusic": "Hapus dari Musik Kamu",
  "Save": "Simpan",
  "SaveYourMusic": "Simpan ke Musik Kamu",
  "Saved": "Tersimpan",
  "ShufflePlay": "Pemutaran Acak",
  "Song": "Lagu",
  "StartRadio": "Mulai Radio",
  "Time": "Waktu",
  "Toplist": "Lagu teratas",
  "Track": "Lagu",
  "Unfollow": "Berhenti mengikuti",
  "User": "Pengguna",
  "ViewAll": "Lihat Semua",
  "HoursShort": "{0} jam",
  "MinutesShort": "{0} mnt",
  "SecondsShort": "{0} dtk",
  "ErrorTitle": "Ada masalah saat menampilkan tampilan ini!",
  "ErrorMessage": "Tampilan ini tidak ada atau terjadi kesalahan.",
  "OfflineTitle": "Tampilan ini tidak tersedia offline.",
  "OfflineMessage": "Alihkan ke online untuk memuat."
};
},{}],122:[function(require,module,exports){
module.exports = {
  "Album": "Album",
  "AndMore": "e altri {0}",
  "Artist": "Artista",
  "By": "per",
  "Create Similar Playlist": "Crea playlist simile",
  "Filter": "Filtra",
  "Follow": "Segui",
  "Follower": "Follower",
  "FollowersLabel": "Follower",
  "Following": "Following",
  "FollowingLabel": "Following",
  "ListenersLabel": "Ascoltatori questo mese",
  "FollowsYou": "Ti segue",
  "HoldToPreview": "Tieni premuto per un'anteprima",
  "ListenCount": "{0} riproduzioni",
  "ListenReactionMulti": "{0} ascoltatori nella tua rete",
  "ListenReactionSingle": "{0} ascolta questo",
  "LocalFile": "File locale",
  "More": "Più",
  "Pause": "Pausa",
  "Play": "Play",
  "Playlist": "Playlist",
  "PressEnterToPlay": "Premi Invio per riprodurre",
  "Popularity": "Popolarità",
  "Remove": "Rimuovi",
  "RemoveYourMusic": "Elimina da La tua musica",
  "Save": "Salva",
  "SaveYourMusic": "Salva in La tua musica",
  "Saved": "Salvato",
  "ShufflePlay": "Riproduzione shuffle",
  "Song": "Brano",
  "StartRadio": "Crea una radio",
  "Time": "Durata",
  "Toplist": "Brani top",
  "Track": "Brano",
  "Unfollow": "Non seguire più",
  "User": "Utente",
  "ViewAll": "Visualizza tutto",
  "HoursShort": "{0} ore",
  "MinutesShort": "{0} min.",
  "SecondsShort": "{0} sec",
  "ErrorTitle": "Si è verificato un errore in questa vista.",
  "ErrorMessage": "La vista non esiste o si è verificato un errore.",
  "OfflineTitle": "Questa vista non è disponibile offline.",
  "OfflineMessage": "Passa online per caricare."
};
},{}],123:[function(require,module,exports){
module.exports = {
  "Album": "アルバム",
  "AndMore": "その他{0}人",
  "Artist": "アーティスト",
  "By": "/",
  "Create Similar Playlist": "同様のプレイリストを作成",
  "Filter": "フィルタ",
  "Follow": "フォロー",
  "Follower": "フォロワー",
  "FollowersLabel": "フォロワー",
  "Following": "フォロー中",
  "FollowingLabel": "フォロー中",
  "ListenersLabel": "今月のリスナー",
  "FollowsYou": "あなたをフォローしています",
  "HoldToPreview": "プレビューするには、クリックを押しします",
  "ListenCount": "{0}回再生",
  "ListenReactionMulti": "ネットワーク内で{0}人が聴いています",
  "ListenReactionSingle": "{0}さんはこれを聴いています",
  "LocalFile": "ローカルファイル",
  "More": "詳細",
  "Pause": "一時停止",
  "Play": "再生",
  "Playlist": "プレイリスト",
  "PressEnterToPlay": "再生するにはEnterキーを押します",
  "Popularity": "人気",
  "Remove": "削除",
  "RemoveYourMusic": "My Musicから削除",
  "Save": "保存",
  "SaveYourMusic": "My Musicに保存",
  "Saved": "保存済み",
  "ShufflePlay": "シャッフルプレイ",
  "Song": "ソング",
  "StartRadio": "Radioを開始",
  "Time": "時間",
  "Toplist": "トップ曲",
  "Track": "ソング",
  "Unfollow": "フォローをやめる",
  "User": "ユーザー",
  "ViewAll": "すべて表示",
  "HoursShort": "{0} 時間",
  "MinutesShort": "{0} 分",
  "SecondsShort": "{0} 秒",
  "ErrorTitle": "このビューを表示しようとしているときに問題が発生しました。",
  "ErrorMessage": "このビューが存在しないか、エラーが発生しました。",
  "OfflineTitle": "このビューはオフラインでは使用できません。",
  "OfflineMessage": "ロードするには、インターネットに接続してください。"
};
},{}],124:[function(require,module,exports){
module.exports = {
  "Album": "Album",
  "AndMore": "en {0} meer",
  "Artist": "Artiest",
  "By": "van",
  "Create Similar Playlist": "Vergelijkbare afspeellijst maken",
  "Filter": "Filter",
  "Follow": "Volgen",
  "Follower": "Volger",
  "FollowersLabel": "Volgers",
  "Following": "Volgend",
  "FollowingLabel": "Volgend",
  "ListenersLabel": "Luisteraars per maand",
  "FollowsYou": "Volgt jou",
  "HoldToPreview": "Klikken en vasthouden om een stukje te horen",
  "ListenCount": "{0} keer afgespeeld",
  "ListenReactionMulti": "{0} luisteraars in jouw netwerk",
  "ListenReactionSingle": "{0} luistert hiernaar",
  "LocalFile": "Lokaal bestand",
  "More": "Meer",
  "Pause": "Pauze",
  "Play": "Afspelen",
  "Playlist": "Afspeellijst",
  "PressEnterToPlay": "Druk op Enter om af te spelen",
  "Popularity": "Populariteit",
  "Remove": "Verwijderen",
  "RemoveYourMusic": "Verwijderen uit Jouw Muziek",
  "Save": "Opslaan",
  "SaveYourMusic": "Opslaan in Jouw Muziek",
  "Saved": "Opgeslagen",
  "ShufflePlay": "Shuffle",
  "Song": "Nummer",
  "StartRadio": "Radio starten",
  "Time": "Tijd",
  "Toplist": "Topnummers",
  "Track": "Nummer",
  "Unfollow": "Niet meer volgen",
  "User": "Gebruiker",
  "ViewAll": "Alles bekijken",
  "HoursShort": "{0} uur",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} sec",
  "ErrorTitle": "Er is een fout opgetreden bij het laden van deze weergave.",
  "ErrorMessage": "Deze weergave bestaat niet of er is een fout opgetreden.",
  "OfflineTitle": "Deze weergave is offline niet beschikbaar!",
  "OfflineMessage": "Ga online om te laden."
};
},{}],125:[function(require,module,exports){
module.exports = {
  "Album": "Album",
  "AndMore": "i {0} więcej",
  "Artist": "Wykonawca",
  "By": "według",
  "Create Similar Playlist": "Utwórz podobną playlistę",
  "Filter": "Filtruj",
  "Follow": "Obserwuj",
  "Follower": "Obserwujący",
  "FollowersLabel": "Obserwatorzy",
  "Following": "Obserwowana",
  "FollowingLabel": "Obserwowana",
  "ListenersLabel": "Słuchacze w tym miesiącu",
  "FollowsYou": "Obserwuje Cię",
  "HoldToPreview": "Aby odsłuchać, kliknij i przytrzymaj.",
  "ListenCount": "Liczba odtworzeń: {0}",
  "ListenReactionMulti": "Liczba słuchaczy w Twojej sieci: {0}",
  "ListenReactionSingle": "Użytkownik {0} słucha tego",
  "LocalFile": "Plik lokalny",
  "More": "Więcej",
  "Pause": "Pauza",
  "Play": "Odtwórz",
  "Playlist": "Playlista",
  "PressEnterToPlay": "Naciśnij Enter, aby odtworzyć",
  "Popularity": "Popularność",
  "Remove": "Usuń",
  "RemoveYourMusic": "Usuń z kolekcji Twoja muzyka",
  "Save": "Zapisz",
  "SaveYourMusic": "Zapisz w kolekcji Twoja muzyka",
  "Saved": "Zapisany",
  "ShufflePlay": "Odtwarzanie losowe",
  "Song": "Utwór",
  "StartRadio": "Włącz radio",
  "Time": "Czas",
  "Toplist": "Najpopularniejsze utwory",
  "Track": "Utwór",
  "Unfollow": "Przestań obserwować",
  "User": "Użytkownik",
  "ViewAll": "Wyświetl wszystko",
  "HoursShort": "{0} godz.",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} s",
  "ErrorTitle": "Podczas wyświetlania tego widoku wystąpił błąd!",
  "ErrorMessage": "Ten widok nie istnieje lub wystąpił błąd.",
  "OfflineTitle": "Ten widok jest niedostępny w trybie offline. ",
  "OfflineMessage": "Przejdź do trybu online, aby załadować."
};
},{}],126:[function(require,module,exports){
module.exports = {
  "Album": "Álbum",
  "AndMore": "e mais {0}",
  "Artist": "Artista",
  "By": "de",
  "Create Similar Playlist": "Criar playlist similar",
  "Filter": "Filtrar",
  "Follow": "Seguir",
  "Follower": "Seguidor",
  "FollowersLabel": "Seguidores",
  "Following": "Seguindo",
  "FollowingLabel": "Seguindo",
  "ListenersLabel": "Ouvintes mensais",
  "FollowsYou": "Segue você",
  "HoldToPreview": "Clique e segure para a prévia",
  "ListenCount": "{0} reproduções",
  "ListenReactionMulti": "{0} ouvintes na sua rede",
  "ListenReactionSingle": "{0} ouvem isso",
  "LocalFile": "Arquivo local",
  "More": "Mais",
  "Pause": "Pause",
  "Play": "Play",
  "Playlist": "Playlist",
  "PressEnterToPlay": "Pressione Enter para tocar",
  "Popularity": "Popularidade",
  "Remove": "Remover",
  "RemoveYourMusic": "Remover de Suas músicas",
  "Save": "Salvar",
  "SaveYourMusic": "Salvar em Suas músicas",
  "Saved": "Salvo",
  "ShufflePlay": "Ordem aleatória",
  "Song": "Música",
  "StartRadio": "Abrir rádio",
  "Time": "Tempo",
  "Toplist": "Músicas mais tocadas",
  "Track": "Música",
  "Unfollow": "Deixar de seguir",
  "User": "Usuário",
  "ViewAll": "Ver tudo",
  "HoursShort": "{0} h",
  "MinutesShort": "{0} m",
  "SecondsShort": "{0} s",
  "ErrorTitle": "Tivemos um problema ao mostrar esta exibição!",
  "ErrorMessage": "A exibição não existe ou ocorreu um erro.",
  "OfflineTitle": "Essa visualização não está disponível offline!",
  "OfflineMessage": "Fique online para carregar."
};
},{}],127:[function(require,module,exports){
module.exports = {
  "Album": "Album",
  "AndMore": "och {0} till",
  "Artist": "Artist",
  "By": "av",
  "Create Similar Playlist": "Skapa en liknande spellista",
  "Filter": "Filtrera",
  "Follow": "Följ",
  "Follower": "Följare",
  "FollowersLabel": "Följare",
  "Following": "Följer",
  "FollowingLabel": "Följer",
  "ListenersLabel": "Lyssnare per månad",
  "FollowsYou": "Följer dig",
  "HoldToPreview": "Klicka och håll kvar för att förhandslyssna",
  "ListenCount": "{0} uppspelningar",
  "ListenReactionMulti": "{0} lyssnare i ditt nätverk",
  "ListenReactionSingle": "{0} lyssnar på detta",
  "LocalFile": "Lokal fil",
  "More": "Mer",
  "Pause": "Pausa",
  "Play": "Spela upp",
  "Playlist": "Spellista",
  "PressEnterToPlay": "Tryck på Retur om du vill lyssna",
  "Popularity": "Popularitet",
  "Remove": "Ta bort",
  "RemoveYourMusic": "Ta bort från Din Musik",
  "Save": "Spara",
  "SaveYourMusic": "Spara i Din Musik",
  "Saved": "Sparade",
  "ShufflePlay": "Slumpmässig uppspelning",
  "Song": "Låt",
  "StartRadio": "Starta radio",
  "Time": "Tid",
  "Toplist": "Topplåtar",
  "Track": "Låt",
  "Unfollow": "Sluta följa",
  "User": "Användare",
  "ViewAll": "Visa alla",
  "HoursShort": "{0} tim",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} sek",
  "ErrorTitle": "Det uppstod ett fel när den här vyn skulle visas!",
  "ErrorMessage": "Den här vyn finns inte eller så uppstod ett fel.",
  "OfflineTitle": "Den här vyn är inte tillgänglig offline.",
  "OfflineMessage": "Anslut till internet om du vill läsa in appen."
};
},{}],128:[function(require,module,exports){
module.exports = {
  "Album": "Albüm",
  "AndMore": "ve {0} daha",
  "Artist": "Sanatçı",
  "By": "-",
  "Create Similar Playlist": "Benzer Çalma Listesi Oluştur",
  "Filter": "Filtrele",
  "Follow": "Takip Et",
  "Follower": "Takipçi",
  "FollowersLabel": "Takipçiler",
  "Following": "Takip Ediliyor",
  "FollowingLabel": "Takip Ediliyor",
  "ListenersLabel": "Aylık Dinleyici",
  "FollowsYou": "Seni Takip Ediyor",
  "HoldToPreview": "Basılı Tut ve Önizle",
  "ListenCount": "{0} dinleme",
  "ListenReactionMulti": "Ağında {0} dinleyici",
  "ListenReactionSingle": "{0} bunu dinliyor",
  "LocalFile": "Yerel Dosya",
  "More": "Daha fazla",
  "Pause": "Duraklat",
  "Play": "Çal",
  "Playlist": "Çalma listesi",
  "PressEnterToPlay": "Çalmak için Enter'a bas",
  "Popularity": "Popülerlik",
  "Remove": "Çıkar",
  "RemoveYourMusic": "Müziklerin'den çıkar",
  "Save": "Kaydet",
  "SaveYourMusic": "Müziklerin'e kaydet",
  "Saved": "Kaydedildi",
  "ShufflePlay": "Karışık Çal",
  "Song": "Şarkı",
  "StartRadio": "Radyoyu Başlat",
  "Time": "Saat",
  "Toplist": "En çok dinlenen şarkılar",
  "Track": "Şarkı",
  "Unfollow": "Takip Etmeyi Bırak",
  "User": "Kullanıcı",
  "ViewAll": "Tümünü Görüntüle",
  "HoursShort": "{0} sa",
  "MinutesShort": "{0} dk",
  "SecondsShort": "{0} sn",
  "ErrorTitle": "Bu öğe görüntülenirken bir sorun oluştu!",
  "ErrorMessage": "Bu görünüm yok veya bir hata oluştu.",
  "OfflineTitle": "Bu görünüm çevrimdışıyken kullanılamaz!",
  "OfflineMessage": "Yüklemek için lütfen çevrimiçi ol."
};
},{}],129:[function(require,module,exports){
module.exports = {
  "Album": "專輯",
  "AndMore": "還有 {0} 首",
  "Artist": "藝人",
  "By": "－",
  "Create Similar Playlist": "建立相似的播放清單",
  "Filter": "篩選",
  "Follow": "關注",
  "Follower": "粉絲",
  "FollowersLabel": "關注者",
  "Following": "正在關注",
  "FollowingLabel": "正在關注",
  "ListenersLabel": "每月聽眾",
  "FollowsYou": "關注你",
  "HoldToPreview": "按住即可預覽",
  "ListenCount": "播放了 {0} 次",
  "ListenReactionMulti": "在你的社群網路中有 {0} 名聽眾",
  "ListenReactionSingle": "{0} 收聽了這首歌曲",
  "LocalFile": "本機檔案",
  "More": "更多",
  "Pause": "暫停",
  "Play": "播放",
  "Playlist": "播放列表",
  "PressEnterToPlay": "請按 Enter 播放",
  "Popularity": "流行",
  "Remove": "移除",
  "RemoveYourMusic": "從你的音樂中移除",
  "Save": "儲存",
  "SaveYourMusic": "儲存至你的音樂",
  "Saved": "已儲存",
  "ShufflePlay": "隨機播放",
  "Song": "歌曲",
  "StartRadio": "啟用電臺",
  "Time": "時間",
  "Toplist": "當紅歌曲",
  "Track": "歌曲",
  "Unfollow": "取消關注",
  "User": "使用者",
  "ViewAll": "檢視全部",
  "HoursShort": "{0} 小時",
  "MinutesShort": "{0} 分鐘",
  "SecondsShort": "{0} 秒鐘",
  "ErrorTitle": "顯示這個畫面時出現問題。",
  "ErrorMessage": "這個畫面可能不存在或發生錯誤。",
  "OfflineTitle": "離線時無法使用這個檢視！",
  "OfflineMessage": "請上網以載入。"
};
},{}],130:[function(require,module,exports){
module.exports = {
  "Album": "Album",
  "AndMore": "dan {0} lagi",
  "Artist": "Artis",
  "By": "oleh",
  "Create Similar Playlist": "Cipta Senarai Main Serupa",
  "Filter": "Penapis",
  "Follow": "Ikut",
  "Follower": "Pengikut",
  "FollowersLabel": "Pengikut",
  "Following": "Mengikuti",
  "FollowingLabel": "Mengikuti",
  "ListenersLabel": "Pendengar Bulanan",
  "FollowsYou": "Megikuti Anda",
  "HoldToPreview": "Klik dan Tahan untuk Pratonton",
  "ListenCount": "{0} main",
  "ListenReactionMulti": "{0} pendengar dalam rangkaian anda",
  "ListenReactionSingle": "{0} mendengar ini",
  "LocalFile": "Fail Setempat",
  "More": "Lebih banyak",
  "Pause": "Jeda",
  "Play": "Main",
  "Playlist": "Senarai main",
  "PressEnterToPlay": "Tekan Enter untuk main",
  "Popularity": "Populariti",
  "Remove": "Keluarkan",
  "RemoveYourMusic": "Keluarkan daripada Muzik Anda",
  "Save": "Simpan",
  "SaveYourMusic": "Simpan ke Muzik Anda",
  "Saved": "Disimpan",
  "ShufflePlay": "Main Rombak",
  "Song": "Lagu",
  "StartRadio": "Mulakan Radio",
  "Time": "Masa",
  "Toplist": "Lagu popular",
  "Track": "Lagu",
  "Unfollow": "Nyahikut",
  "User": "Pengguna",
  "ViewAll": "Lihat Semua",
  "HoursShort": "{0} jam",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} saat",
  "ErrorTitle": "Terdapat masalah memaparkan paparan ini!",
  "ErrorMessage": "Paparan ini sama ada tidak wujud atau ralat berlaku.",
  "OfflineTitle": "Paparan ini tidak tersedia di luar talian!",
  "OfflineMessage": "Sila ke online untuk memuatkan."
};
},{}],131:[function(require,module,exports){
'use strict';

exports.getVersion = require('./src/version').getVersion;
exports.gridOverlay = require('./src/gridOverlay');

},{"./src/gridOverlay":132,"./src/version":133}],132:[function(require,module,exports){
(function (global){
'use strict';

var cosmos = require('spotify-cosmos-api');

var DEFAULT_GRID_COLOR = 'rgba(251, 74, 131, 0.22)';
var DEFAULT_GRID_COLOR_HIGHLIGHT = 'rgba(251, 74, 131, 0.8)';
var GRID_BASELINE = 8;

var overlayElement = null;
var baselineHighlightElement = null;
var gridColor = '';
var highlightGridColor = '';
var gridModes = ['off', 'column', 'baseline'];
var currentModeIndex = 0;

/**
 * Listen for control messages to toggle the grid when a menu item is clicked
 * or a keyboard shortcut is pressed. This only happens if the user is a global
 * app developer.
 */
function listen() {
  var spotify = global.__spotify;
  var productState = spotify && spotify.product_state;
  var appDeveloperFlag = productState && productState['app-developer'];

  if (appDeveloperFlag === '3' || appDeveloperFlag === '7') {
    cosmos.resolver.subscribe({
      url: 'sp://messages/v1/container/control'
    }, function (error, response) {
      if (error) return;
      var data = response.getJSONBody();
      if (data && data.type === 'toggle_grid') {
        toggle();
      }
    });
  }
}

/**
 * Toggle the grid overlay.
 */
function toggle() {
  var newIndex = currentModeIndex + 1;
  if (newIndex > gridModes.length - 1) {
    newIndex = 0;
  }

  var mode = gridModes[newIndex];

  if (mode === 'off') {
    disable();
  } else {
    enable(mode);
  }
}

/**
 * Enable the grid overlay.
 *
 * @param {string} mode The grid mode to enable, 'column' or 'baseline'.
 */
function enable(mode) {
  if (!mode) {
    return;
  }

  if (gridModes[currentModeIndex] === mode) {
    return;
  }

  currentModeIndex = gridModes.indexOf(mode);

  if (overlayElement && overlayElement.parentNode) {
    overlayElement.parentNode.removeChild(overlayElement);
  }

  if (mode === 'baseline') {
    document.addEventListener('mousemove', onMouseMove, false);
  }

  overlayElement = createOverlayElement();

  document.body.appendChild(overlayElement);
}

/**
 * Disable the grid overlay.
 */
function disable() {
  if (gridModes[currentModeIndex] === 'off') {
    return;
  }

  if (overlayElement && overlayElement.parentNode) {
    overlayElement.parentNode.removeChild(overlayElement);
  }

  currentModeIndex = gridModes.indexOf('off');
  overlayElement = null;
  baselineHighlightElement = null;

  document.removeEventListener('mousemove', onMouseMove, false);
}

/**
 * Set the color used for each grid column or baseline line.
 *
 * @param {string} color Any valid CSS color.
 * @param {string=} highlightColor Any valid CSS color. Can be omitted for
 *     column grid.
 */
function setColor(color, highlightColor) {
  gridColor = color;
  highlightGridColor = highlightColor;
}

/**
 * Reset all state in this module.
 */
function reset() {
  overlayElement = null;
  baselineHighlightElement = null;
  gridColor = '';
  highlightGridColor = '';
  currentModeIndex = 0;
}

/**
 * Mouse move handler that highlights the hovered baseline line.
 *
 * @param {Event} event A mousemove event object.
 *
 * @private
 */
function onMouseMove(event) {
  if (!baselineHighlightElement) {
    baselineHighlightElement = document.createElement('div');
    baselineHighlightElement.className = 'grid-overlay-baseline-highlight';
    baselineHighlightElement.style.backgroundColor = highlightGridColor || DEFAULT_GRID_COLOR_HIGHLIGHT;
    overlayElement.appendChild(baselineHighlightElement);
  }

  // Calculate the Y position for the baseline line closest to the pointer
  var pointerPos = event.clientY + window.scrollY;
  var yLineAbove = Math.floor(pointerPos / GRID_BASELINE) * GRID_BASELINE;
  var y = yLineAbove + (pointerPos % GRID_BASELINE > 4 ? GRID_BASELINE : 0);

  baselineHighlightElement.style.top = y - 1 + 'px';
}

/**
 * Create the DOM nodes needed for the overlay, with the correct class names
 * and styles.
 *
 * @return {HTMLElement} The container element for the overlay.
 *
 * @private
 */
function createOverlayElement() {
  var color = gridColor || DEFAULT_GRID_COLOR;

  var container = document.createElement('div');
  container.className = 'grid-overlay container';

  if (gridModes[currentModeIndex] === 'column') {
    var row = document.createElement('div');
    row.className = 'grid-overlay-row row';
    container.appendChild(row);

    var sizeLabel = createSizeLabel();
    container.appendChild(sizeLabel);

    var columnClassNames = 'col-xs-1 col-sm-1 col-md-1 col-lg-1';

    for (var i = 0; i < 12; i++) {
      var column = document.createElement('div');
      column.className = 'grid-overlay-col-' + (i + 1) + ' ' + columnClassNames;

      column.style.backgroundColor = color;

      row.appendChild(column);
    }
  } else if (gridModes[currentModeIndex] === 'baseline') {
    container.classList.add('grid-overlay-baseline');

    var baselinePercentage = (GRID_BASELINE - 1) / GRID_BASELINE * 100 + '%';

    var backgroundImage = ['linear-gradient(', 'to bottom, ', 'transparent, ', 'transparent ' + baselinePercentage + ', ', color + ' ' + baselinePercentage, ')'].join('');

    container.style.backgroundImage = backgroundImage;

    // Because JSDOM is using the package 'cssstyle', which is stupid and
    // doesn't support gradients as values...
    container.style._backgroundImage = backgroundImage;
  }

  return container;
}

/**
 * Create the DOM nodes needed for the grid size label.
 *
 * @return {HTMLElement} A DOM node.
 *
 * @private
 */
function createSizeLabel() {
  var sizes = [{ name: 'Extra Small', id: 'xs' }, { name: 'Small', id: 'sm' }, { name: 'Medium', id: 'md' }, { name: 'Large', id: 'lg' }];

  var labelContainer = document.createElement('div');
  labelContainer.className = 'grid-overlay-label';

  sizes.forEach(function (size) {
    var label = document.createElement('span');
    label.className = 'visible-' + size.id;
    label.textContent = size.name;
    labelContainer.appendChild(label);
  });

  return labelContainer;
}

exports.listen = listen;
exports.toggle = toggle;
exports.enable = enable;
exports.disable = disable;
exports.setColor = setColor;
exports.reset = reset;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"spotify-cosmos-api":388}],133:[function(require,module,exports){
'use strict';

// This should be removed later when nothing is calling this method

exports.getVersion = function () {
  return 1;
};

},{}],134:[function(require,module,exports){
'use strict';

module.exports = {
  'de': require('../i18n/de.lang'),
  'el': require('../i18n/el.lang'),
  'en': require('../i18n/en.lang'),
  'es': require('../i18n/es.lang'),
  'es-419': require('../i18n/es-419.lang'),
  'fi': require('../i18n/fi.lang'),
  'fr': require('../i18n/fr.lang'),
  'fr-CA': require('../i18n/fr-CA.lang'),
  'hu': require('../i18n/hu.lang'),
  'id': require('../i18n/id.lang'),
  'it': require('../i18n/it.lang'),
  'ja': require('../i18n/ja.lang'),
  'nl': require('../i18n/nl.lang'),
  'pl': require('../i18n/pl.lang'),
  'pt-BR': require('../i18n/pt-BR.lang'),
  'sv': require('../i18n/sv.lang'),
  'tr': require('../i18n/tr.lang'),
  'zh-Hant': require('../i18n/zh-Hant.lang'),
  'zsm': require('../i18n/zsm.lang')
};

},{"../i18n/de.lang":112,"../i18n/el.lang":113,"../i18n/en.lang":114,"../i18n/es-419.lang":115,"../i18n/es.lang":116,"../i18n/fi.lang":117,"../i18n/fr-CA.lang":118,"../i18n/fr.lang":119,"../i18n/hu.lang":120,"../i18n/id.lang":121,"../i18n/it.lang":122,"../i18n/ja.lang":123,"../i18n/nl.lang":124,"../i18n/pl.lang":125,"../i18n/pt-BR.lang":126,"../i18n/sv.lang":127,"../i18n/tr.lang":128,"../i18n/zh-Hant.lang":129,"../i18n/zsm.lang":130}],135:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, functionType="function", self=this;

function program1(depth0,data) {
  
  var buffer = "", stack1, helper, options;
  buffer += "\n        <h1 class=\"hdr-l\">"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "ErrorTitle", options) : helperMissing.call(depth0, "loc", "ErrorTitle", options)))
    + "</h1>\n        <div class=\"message\">";
  stack1 = (helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "ErrorMessage", options) : helperMissing.call(depth0, "loc", "ErrorMessage", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "</div>\n      ";
  return buffer;
  }

function program3(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n        <h1 class=\"hdr-l\">";
  if (helper = helpers.errorTitle) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.errorTitle); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</h1>\n        <div class=\"message\">";
  if (helper = helpers.errorMessage) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.errorMessage); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "</div>\n      ";
  return buffer;
  }

function program5(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n        <a class=\"button button-white\" href=\"";
  if (helper = helpers.errorEscapeUrl) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.errorEscapeUrl); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-log-click=\"error-escape\">";
  if (helper = helpers.errorEscapeMessage) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.errorEscapeMessage); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</a>\n      ";
  return buffer;
  }

function program7(depth0,data) {
  
  var buffer = "", stack1, helper, options;
  buffer += "\n        <h1 class=\"hdr-l\">"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "OfflineTitle", options) : helperMissing.call(depth0, "loc", "OfflineTitle", options)))
    + "</h1>\n        <div class=\"message\">";
  stack1 = (helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "OfflineMessage", options) : helperMissing.call(depth0, "loc", "OfflineMessage", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "</div>\n      ";
  return buffer;
  }

function program9(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n        <h1 class=\"hdr-l\">";
  if (helper = helpers.offlineTitle) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.offlineTitle); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</h1>\n        <div class=\"message\">";
  if (helper = helpers.offlineMessage) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.offlineMessage); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "</div>\n      ";
  return buffer;
  }

function program11(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n        <a class=\"button button-white\" href=\"";
  if (helper = helpers.offlineEscapeUrl) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.offlineEscapeUrl); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-log-click=\"offline-escape\">";
  if (helper = helpers.offlineEscapeMessage) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.offlineEscapeMessage); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</a>\n      ";
  return buffer;
  }

function program13(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n  <div class=\"error-version text-muted\">";
  if (helper = helpers.errorVersion) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.errorVersion); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</div>\n  ";
  return buffer;
  }

  buffer += "<div class=\"error-and-offline\" data-log-context=\"error-and-offline\">\n  <div class=\"container\">\n    <div class=\"error-content\">\n      ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.useDefaultError), {hash:{},inverse:self.program(3, program3, data),fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.errorEscapeMessage), {hash:{},inverse:self.noop,fn:self.program(5, program5, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    </div>\n    <div class=\"offline-content\">\n      ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.useDefaultOffline), {hash:{},inverse:self.program(9, program9, data),fn:self.program(7, program7, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.offlineEscapeMessage), {hash:{},inverse:self.noop,fn:self.program(11, program11, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    </div>\n  </div>\n  ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.errorVersion), {hash:{},inverse:self.noop,fn:self.program(13, program13, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n</div>\n";
  return buffer;
  });

},{"hbsfy/runtime":320}],136:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
var partial$0 = require('./media/image.hbs');
HandlebarsCompiler.registerPartial('./media/image.hbs', partial$0);
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); partials = this.merge(partials, Handlebars.partials); data = data || {};
  var buffer = "", stack1, helper, options, functionType="function", escapeExpression=this.escapeExpression, helperMissing=helpers.helperMissing, self=this, blockHelperMissing=helpers.blockHelperMissing;

function program1(depth0,data) {
  
  var buffer = "", stack1, helper, options;
  buffer += "\n  <div class=\"facepile\" data-tooltip title=\"";
  if (helper = helpers.name) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.name); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-tooltip-instant>\n    <div class=\"media-object media-object-image media-object-link media-object-simple media-object-"
    + escapeExpression((helper = helpers.type || (depth0 && depth0.type),options={hash:{},data:data},helper ? helper.call(depth0, (depth0 && depth0.uri), options) : helperMissing.call(depth0, "type", (depth0 && depth0.uri), options)))
    + " ";
  options={hash:{},inverse:self.program(2, program2, data),fn:self.noop,data:data}
  if (helper = helpers.imageUrl) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.imageUrl); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.imageUrl) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.program(2, program2, data),fn:self.noop,data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\"\n      data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"\n      data-log-context=\"media-object\"\n      data-contextmenu>\n      <div class=\"mo-wrapper\">\n        <div class=\"mo-image-wrapper\">\n          <a href=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-log-click=\"media-image\">\n            ";
  stack1 = self.invokePartial(partials['./media/image.hbs'], './media/image.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n          </a>\n        </div>\n      </div>\n    </div>\n  </div>\n";
  return buffer;
  }
function program2(depth0,data) {
  
  
  return "show-placeholder";
  }

function program4(depth0,data,depth1) {
  
  var buffer = "", stack1, helper;
  buffer += "\n  <button\n    type=\"button\"\n    class=\"button facepile-badge\"\n    title=\"";
  if (helper = helpers.badgeTooltip) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.badgeTooltip); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"\n    data-tooltip\n    data-tooltip-instant\n    data-modal=\"spotify:modal:socialproof:"
    + escapeExpression(((stack1 = (depth1 && depth1.uri)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\"\n  >\n    +";
  if (helper = helpers.badgeCount) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.badgeCount); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\n  </button>\n";
  return buffer;
  }

  stack1 = (helper = helpers.facepile || (depth0 && depth0.facepile),options={hash:{},inverse:self.programWithDepth(4, program4, data, depth0),fn:self.program(1, program1, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.listeners), (depth0 && depth0.totalListeners), options) : helperMissing.call(depth0, "facepile", (depth0 && depth0.listeners), (depth0 && depth0.totalListeners), options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n";
  return buffer;
  });

},{"./media/image.hbs":140,"hbsfy/runtime":320}],137:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
var partial$0 = require('./media/image.hbs');
HandlebarsCompiler.registerPartial('./media/image.hbs', partial$0);
var partial$1 = require('./media/controllers.hbs');
HandlebarsCompiler.registerPartial('./media/controllers.hbs', partial$1);
var partial$2 = require('./media/info.hbs');
HandlebarsCompiler.registerPartial('./media/info.hbs', partial$2);
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); partials = this.merge(partials, Handlebars.partials); data = data || {};
  var buffer = "", stack1, helper, options, functionType="function", escapeExpression=this.escapeExpression, helperMissing=helpers.helperMissing, self=this, blockHelperMissing=helpers.blockHelperMissing;

function program1(depth0,data) {
  
  
  return "data-context";
  }

function program3(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n        <div data-drag-text=\"";
  if (helper = helpers.title) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.title); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-log-click=\"media-image\" draggable=\"true\">\n      ";
  return buffer;
  }

function program5(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n        <a data-drag-text=\"";
  if (helper = helpers.title) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.title); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" href=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-log-click=\"media-image\">\n      ";
  return buffer;
  }

function program7(depth0,data) {
  
  
  return "\n        </div>\n      ";
  }

function program9(depth0,data) {
  
  
  return "\n        </a>\n      ";
  }

  buffer += "<div class=\"media-object media-object-station media-object-station-"
    + escapeExpression((helper = helpers.type || (depth0 && depth0.type),options={hash:{},data:data},helper ? helper.call(depth0, (depth0 && depth0.seedUri), options) : helperMissing.call(depth0, "type", (depth0 && depth0.seedUri), options)))
    + " ";
  if (helper = helpers.modifiers) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.modifiers); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"\n  ";
  options={hash:{},inverse:self.program(1, program1, data),fn:self.noop,data:data}
  if (helper = helpers.noContext) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.noContext); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.noContext) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.program(1, program1, data),fn:self.noop,data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"\n  data-log-context=\"media-object\" data-log-data='{ \"name\": \"";
  if (helper = helpers.name) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.name); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\", \"target_uri\": \"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" }' data-contextmenu>\n  <div class=\"mo-wrapper\">\n    <div class=\"mo-image-wrapper\">\n      ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.noLink), {hash:{},inverse:self.program(5, program5, data),fn:self.program(3, program3, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n      ";
  stack1 = self.invokePartial(partials['./media/image.hbs'], './media/image.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n      <div class=\"mo-station-layer mo-station-highlight\" style=\"background-color:";
  if (helper = helpers.dominantColor) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.dominantColor); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"></div>\n      <div class=\"mo-station-layer mo-station-mask\"></div>\n      <div class=\"mo-station-overlay\" style=\"background-image: url(";
  if (helper = helpers.overlayImageUrl) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.overlayImageUrl); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + ")\"></div>\n      <div class=\"mo-overlay\"></div>\n\n      ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.noLink), {hash:{},inverse:self.program(9, program9, data),fn:self.program(7, program7, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n      ";
  stack1 = self.invokePartial(partials['./media/controllers.hbs'], './media/controllers.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    </div>\n    ";
  stack1 = self.invokePartial(partials['./media/info.hbs'], './media/info.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  </div>\n</div>\n";
  return buffer;
  });

},{"./media/controllers.hbs":139,"./media/image.hbs":140,"./media/info.hbs":141,"hbsfy/runtime":320}],138:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
var partial$0 = require('./media/image.hbs');
HandlebarsCompiler.registerPartial('./media/image.hbs', partial$0);
var partial$1 = require('./media/controllers.hbs');
HandlebarsCompiler.registerPartial('./media/controllers.hbs', partial$1);
var partial$2 = require('./media/info.hbs');
HandlebarsCompiler.registerPartial('./media/info.hbs', partial$2);
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); partials = this.merge(partials, Handlebars.partials); data = data || {};
  var buffer = "", stack1, helper, options, functionType="function", escapeExpression=this.escapeExpression, helperMissing=helpers.helperMissing, self=this, blockHelperMissing=helpers.blockHelperMissing;

function program1(depth0,data) {
  
  
  return "data-context";
  }

function program3(depth0,data) {
  
  
  return "\"mo-wide-image-wrapper\"";
  }

function program5(depth0,data) {
  
  
  return "\"mo-image-wrapper\"";
  }

function program7(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n        <div data-drag-text=\"";
  if (helper = helpers.title) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.title); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-log-click=\"media-image\" draggable=\"true\">\n      ";
  return buffer;
  }

function program9(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n        <a data-drag-text=\"";
  if (helper = helpers.title) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.title); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" href=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-log-click=\"media-image\">\n      ";
  return buffer;
  }

function program11(depth0,data) {
  
  
  return "\n        </div>\n      ";
  }

function program13(depth0,data) {
  
  
  return "\n        </a>\n      ";
  }

  buffer += "<div class=\"media-object media-object-"
    + escapeExpression((helper = helpers.type || (depth0 && depth0.type),options={hash:{},data:data},helper ? helper.call(depth0, (depth0 && depth0.uri), options) : helperMissing.call(depth0, "type", (depth0 && depth0.uri), options)))
    + " ";
  if (helper = helpers.modifiers) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.modifiers); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"\n  ";
  options={hash:{},inverse:self.program(1, program1, data),fn:self.noop,data:data}
  if (helper = helpers.noContext) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.noContext); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.noContext) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.program(1, program1, data),fn:self.noop,data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"\n  data-log-context=\"media-object\" data-log-data='{ \"name\": \"";
  if (helper = helpers.name) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.name); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\", \"target_uri\": \"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" }' data-contextmenu>\n  <div class=\"mo-wrapper\">\n    <div class=";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.wideImage), {hash:{},inverse:self.program(5, program5, data),fn:self.program(3, program3, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += ">\n      ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.noLink), {hash:{},inverse:self.program(9, program9, data),fn:self.program(7, program7, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n      ";
  stack1 = self.invokePartial(partials['./media/image.hbs'], './media/image.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      <div class=\"mo-overlay\"></div>\n\n      ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.noLink), {hash:{},inverse:self.program(13, program13, data),fn:self.program(11, program11, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n      ";
  stack1 = self.invokePartial(partials['./media/controllers.hbs'], './media/controllers.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    </div>\n    ";
  stack1 = self.invokePartial(partials['./media/info.hbs'], './media/info.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  </div>\n</div>\n";
  return buffer;
  });

},{"./media/controllers.hbs":139,"./media/image.hbs":140,"./media/info.hbs":141,"hbsfy/runtime":320}],139:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, options, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression, self=this, functionType="function", blockHelperMissing=helpers.blockHelperMissing;

function program1(depth0,data) {
  
  var buffer = "", stack1, helper, options;
  buffer += "\n  ";
  stack1 = (helper = helpers.type || (depth0 && depth0.type),options={hash:{},inverse:self.noop,fn:self.program(2, program2, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.uri), "track", "album", options) : helperMissing.call(depth0, "type", (depth0 && depth0.uri), "track", "album", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  ";
  stack1 = (helper = helpers.type || (depth0 && depth0.type),options={hash:{},inverse:self.noop,fn:self.program(4, program4, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.uri), "playlist", "station", "artist", options) : helperMissing.call(depth0, "type", (depth0 && depth0.uri), "playlist", "station", "artist", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n";
  return buffer;
  }
function program2(depth0,data) {
  
  var buffer = "", helper, options;
  buffer += "\n    <button type=\"button\" data-button=\"add\" class=\"button button-icon-only button-add mo-add\" data-tooltip=\""
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Save", options) : helperMissing.call(depth0, "loc", "Save", options)))
    + "\" data-tooltip-add=\""
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Save", options) : helperMissing.call(depth0, "loc", "Save", options)))
    + "\" data-tooltip-remove=\""
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Remove", options) : helperMissing.call(depth0, "loc", "Remove", options)))
    + "\" data-log-click=\"add-button\"></button>\n  ";
  return buffer;
  }

function program4(depth0,data) {
  
  var buffer = "", stack1, helper, options;
  buffer += "\n    ";
  options={hash:{},inverse:self.program(5, program5, data),fn:self.noop,data:data}
  if (helper = helpers.currentUserPlaylist) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.currentUserPlaylist); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.currentUserPlaylist) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.program(5, program5, data),fn:self.noop,data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  ";
  return buffer;
  }
function program5(depth0,data) {
  
  var buffer = "", helper, options;
  buffer += "\n    <button type=\"button\" data-button=\"add\" class=\"button button-icon-only button-add mo-add\" data-tooltip=\""
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Follow", options) : helperMissing.call(depth0, "loc", "Follow", options)))
    + "\" data-tooltip-add=\""
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Follow", options) : helperMissing.call(depth0, "loc", "Follow", options)))
    + "\" data-tooltip-remove=\""
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Unfollow", options) : helperMissing.call(depth0, "loc", "Unfollow", options)))
    + "\" data-log-click=\"follow-button\"></button>\n    ";
  return buffer;
  }

function program7(depth0,data) {
  
  var buffer = "", stack1, helper, options;
  buffer += "\n    data-button=\"play\"\n    ";
  options={hash:{},inverse:self.noop,fn:self.program(8, program8, data),data:data}
  if (helper = helpers.range) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.range); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.range) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.noop,fn:self.program(8, program8, data),data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  ";
  return buffer;
  }
function program8(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "data-range=\"";
  if (helper = helpers.start) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.start); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + ",";
  if (helper = helpers.end) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.end); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"";
  return buffer;
  }

function program10(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n    ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.contextPage), {hash:{},inverse:self.program(14, program14, data),fn:self.program(11, program11, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  ";
  return buffer;
  }
function program11(depth0,data) {
  
  var buffer = "", stack1, helper, options;
  buffer += "\n      data-button=\"play\"\n      ";
  options={hash:{},inverse:self.noop,fn:self.program(12, program12, data),data:data}
  if (helper = helpers.contextPage) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.contextPage); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.contextPage) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.noop,fn:self.program(12, program12, data),data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    ";
  return buffer;
  }
function program12(depth0,data) {
  
  var buffer = "";
  buffer += "data-context-page=\""
    + escapeExpression((typeof depth0 === functionType ? depth0.apply(depth0) : depth0))
    + "\"";
  return buffer;
  }

function program14(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n      ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.trackUri), {hash:{},inverse:self.program(18, program18, data),fn:self.program(15, program15, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    ";
  return buffer;
  }
function program15(depth0,data) {
  
  var buffer = "", stack1, helper, options;
  buffer += "\n        ";
  options={hash:{},inverse:self.noop,fn:self.program(16, program16, data),data:data}
  if (helper = helpers.trackUri) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.trackUri); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.trackUri) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.noop,fn:self.program(16, program16, data),data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n        data-button=\"play\"\n      ";
  return buffer;
  }
function program16(depth0,data) {
  
  var buffer = "";
  buffer += "data-track-uri=\""
    + escapeExpression((typeof depth0 === functionType ? depth0.apply(depth0) : depth0))
    + "\"";
  return buffer;
  }

function program18(depth0,data) {
  
  
  return "\n        data-button=\"play-context\"\n      ";
  }

function program20(depth0,data) {
  
  var buffer = "", helper, options;
  buffer += "data-tooltip=\""
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "HoldToPreview", options) : helperMissing.call(depth0, "loc", "HoldToPreview", options)))
    + "\"";
  return buffer;
  }

function program22(depth0,data) {
  
  var buffer = "", helper, options;
  buffer += "\n  <button type=\"button\" data-button=\"contextmenu\" class=\"button button-icon-only button-more mo-more\" data-tooltip=\""
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "More", options) : helperMissing.call(depth0, "loc", "More", options)))
    + "\" data-log-click=\"context-menu-button\"></button>\n";
  return buffer;
  }

function program24(depth0,data) {
  
  
  return "\n<button type=\"button\" class=\"button button-icon-only mo-delete\" data-log-click=\"delete-button\"></button>\n";
  }

  stack1 = (helper = helpers.type || (depth0 && depth0.type),options={hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.uri), "playlist", "track", "album", "station", "artist", options) : helperMissing.call(depth0, "type", (depth0 && depth0.uri), "playlist", "track", "album", "station", "artist", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n<button type=\"button\" class=\"button button-play mo-play\" data-log-click=\"play-button\"\n  ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.range), {hash:{},inverse:self.program(10, program10, data),fn:self.program(7, program7, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n  ";
  options={hash:{},inverse:self.noop,fn:self.program(20, program20, data),data:data}
  if (helper = helpers.preview) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.preview); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.preview) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.noop,fn:self.program(20, program20, data),data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += ">\n</button>\n\n";
  stack1 = (helper = helpers.type || (depth0 && depth0.type),options={hash:{},inverse:self.noop,fn:self.program(22, program22, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.uri), "playlist", "track", "album", "artist", options) : helperMissing.call(depth0, "type", (depth0 && depth0.uri), "playlist", "track", "album", "artist", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n";
  options={hash:{},inverse:self.noop,fn:self.program(24, program24, data),data:data}
  if (helper = helpers.canDelete) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.canDelete); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.canDelete) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.noop,fn:self.program(24, program24, data),data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n";
  return buffer;
  });

},{"hbsfy/runtime":320}],140:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, options, functionType="function", escapeExpression=this.escapeExpression, self=this, helperMissing=helpers.helperMissing;

function program1(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n  <div class=\"mo-image-background-color\">\n    ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.imageUrl), {hash:{},inverse:self.noop,fn:self.program(2, program2, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  </div>\n";
  return buffer;
  }
function program2(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n      <div class=\"mo-image-background\" style=\"background-image: url('";
  if (helper = helpers.imageUrl) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.imageUrl); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "')\"></div>\n    ";
  return buffer;
  }

function program4(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n  <div class=\"mo-wide-image\" ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.imageUrl), {hash:{},inverse:self.noop,fn:self.program(5, program5, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += ">\n";
  return buffer;
  }
function program5(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "style=\"background-image: url('";
  if (helper = helpers.imageUrl) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.imageUrl); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "')\"";
  return buffer;
  }

function program7(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n  <div class=\"mo-image\" ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.imageUrl), {hash:{},inverse:self.noop,fn:self.program(5, program5, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += ">\n";
  return buffer;
  }

  buffer += "<svg class=\"mo-placeholder\" viewBox=\"0 0 10 10\" preserveAspectRatio=\"xMidYMid meet\">\n  <text class=\"playlist-placeholder\" x=\"5\" y=\"9.8\">&#xf135;</text>\n  <text class=\"playlist-folder-placeholder\" x=\"5\" y=\"9.8\">&#xf137;</text>\n  <text class=\"album-placeholder\" x=\"5\" y=\"9.8\">&#xf101;</text>\n  <text class=\"artist-placeholder\" x=\"5\" y=\"9.8\">&#xf103;</text>\n  <text class=\"user-placeholder\" x=\"5\" y=\"9.8\">&#xf15d;</text>\n  <text class=\"genre-placeholder\" x=\"5\" y=\"9.8\">&#xf109;</text>\n  <text class=\"collection-placeholder\" x=\"5\" y=\"9.8\">&#xf157;</text>\n  <text class=\"local-files-placeholder\" x=\"5\" y=\"9.8\">&#xf1fb;</text>\n</svg>\n\n";
  stack1 = (helper = helpers.type || (depth0 && depth0.type),options={hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.uri), "user", "artist", options) : helperMissing.call(depth0, "type", (depth0 && depth0.uri), "user", "artist", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.wideImage), {hash:{},inverse:self.program(7, program7, data),fn:self.program(4, program4, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n</div>\n<span class=\"mo-verified\">\n  <span class=\"spoticon-check-16\"></span>\n</span>\n";
  return buffer;
  });

},{"hbsfy/runtime":320}],141:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
var partial$0 = require('./../facepile-common.hbs');
HandlebarsCompiler.registerPartial('./../facepile-common.hbs', partial$0);
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); partials = this.merge(partials, Handlebars.partials); data = data || {};
  var buffer = "", stack1, helper, options, functionType="function", escapeExpression=this.escapeExpression, self=this, blockHelperMissing=helpers.blockHelperMissing;

function program1(depth0,data) {
  
  
  return "meta";
  }

function program3(depth0,data) {
  
  
  return "description";
  }

function program5(depth0,data) {
  
  
  return "socialproof";
  }

function program7(depth0,data) {
  
  
  return "subtitle";
  }

function program9(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n      <div class=\"mo-title\" title=\"";
  if (helper = helpers.name) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.name); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-log-click=\"media-title\" draggable=\"true\">\n    ";
  return buffer;
  }

function program11(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n      <a class=\"mo-title\" title=\"";
  if (helper = helpers.name) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.name); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" href=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-log-click=\"media-title\">\n    ";
  return buffer;
  }

function program13(depth0,data) {
  
  
  return "\n      </div>\n    ";
  }

function program15(depth0,data) {
  
  
  return "\n      </a>\n    ";
  }

function program17(depth0,data) {
  
  var buffer = "", stack1, helper, options;
  buffer += "\n      <div class=\"mo-subtitle text-muted one-line\">\n        ";
  options={hash:{},inverse:self.noop,fn:self.program(18, program18, data),data:data}
  if (helper = helpers.artists) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.artists); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.artists) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.noop,fn:self.program(18, program18, data),data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n        ";
  options={hash:{},inverse:self.noop,fn:self.program(20, program20, data),data:data}
  if (helper = helpers.owner) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.owner); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.owner) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.noop,fn:self.program(20, program20, data),data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      </div>\n    ";
  return buffer;
  }
function program18(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n          <a title=\"";
  if (helper = helpers.name) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.name); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" href=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-log-click=\"artist-name\">";
  if (helper = helpers.name) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.name); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</a>\n        ";
  return buffer;
  }

function program20(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n          <a title=\"";
  if (helper = helpers.name) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.name); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" href=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-log-click=\"owner-name\">";
  if (helper = helpers.name) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.name); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</a>\n        ";
  return buffer;
  }

function program22(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n      <div class=\"mo-description\">";
  if (helper = helpers.description) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.description); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</div>\n    ";
  return buffer;
  }

function program24(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n      ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.totalListeners), {hash:{},inverse:self.noop,fn:self.program(25, program25, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    ";
  return buffer;
  }
function program25(depth0,data) {
  
  var buffer = "", stack1;
  buffer += "\n        ";
  stack1 = self.invokePartial(partials['./../facepile-common.hbs'], './../facepile-common.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n      ";
  return buffer;
  }

function program27(depth0,data) {
  
  var buffer = "", stack1, helper;
  buffer += "\n      <div class=\"mo-meta\">";
  if (helper = helpers.meta) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.meta); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</div>\n    ";
  return buffer;
  }

  buffer += "<div class=\"mo-info ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.meta), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.description), {hash:{},inverse:self.noop,fn:self.program(3, program3, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.socialproof), {hash:{},inverse:self.noop,fn:self.program(5, program5, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  options={hash:{},inverse:self.program(7, program7, data),fn:self.noop,data:data}
  if (helper = helpers.hideSubtitle) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.hideSubtitle); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.hideSubtitle) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.program(7, program7, data),fn:self.noop,data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\" data-log-context=\"media-info\">\n  <div class=\"mo-info-wrapper\">\n    ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.noLink), {hash:{},inverse:self.program(11, program11, data),fn:self.program(9, program9, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n        <span class=\"mo-title-border\">\n          ";
  if (helper = helpers.name) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.name); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\n          <span class=\"ellipsis\">&nbsp;</span>\n        </span>\n    ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.noLink), {hash:{},inverse:self.program(15, program15, data),fn:self.program(13, program13, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n    ";
  options={hash:{},inverse:self.program(17, program17, data),fn:self.noop,data:data}
  if (helper = helpers.hideSubtitle) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.hideSubtitle); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.hideSubtitle) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.program(17, program17, data),fn:self.noop,data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n    ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.description), {hash:{},inverse:self.noop,fn:self.program(22, program22, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n    ";
  options={hash:{},inverse:self.noop,fn:self.program(24, program24, data),data:data}
  if (helper = helpers.socialproof) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.socialproof); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.socialproof) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.noop,fn:self.program(24, program24, data),data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n    ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.meta), {hash:{},inverse:self.noop,fn:self.program(27, program27, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    <div class=\"media-link-hider\"></div>\n    ";
  if (helper = helpers.customContent) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.customContent); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n  </div>\n</div>\n";
  return buffer;
  });

},{"./../facepile-common.hbs":136,"hbsfy/runtime":320}],142:[function(require,module,exports){
'use strict';

// Usage
// Data {{#compare 'myvalue' value}}has{{else}}doesn't have{{/compare}} myvalue.
// Data {{#compare '5' tracks.length true}}has{{else}}doesn't have{{/compare}} 5 tracks.
// Data {{#compare tracks.length 5 operator='>'}}has more than{{else}}has less than or equal to{{/compare}} 5 tracks.

var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var operators = {
  '==': function _(a, b) {
    /* eslint eqeqeq: 0 */return a == b;
  },
  '===': function _(a, b) {
    return a === b;
  },
  '!=': function _(a, b) {
    /* eslint eqeqeq: 0 */return a != b;
  },
  '<': function _(a, b) {
    return a < b;
  },
  '>': function _(a, b) {
    return a > b;
  },
  '<=': function _(a, b) {
    return a <= b;
  },
  '>=': function _(a, b) {
    return a >= b;
  },
  'typeof': function _typeof(a, b) {
    return (typeof a === 'undefined' ? 'undefined' : _typeof2(a)) == b;
  }
};

function compare(a, b, s) {
  var options = arguments[arguments.length - 1];
  var soft = s !== options ? s : false;
  var operator = soft ? '==' : options.hash.operator || '===';

  var match = operators[operator](a, b);

  return match ? options.fn(this) : options.inverse(this);
}

compare.displayName = 'compare';

module.exports = compare;

},{}],143:[function(require,module,exports){
'use strict';

var duration = function duration(ms) {
  if (isNaN(ms)) return ms;

  var s = Math.round(ms / 1000);
  var oneMinute = 60;
  var oneHour = 60 * oneMinute;

  var hours = Math.floor(s / oneHour);
  var minutes = Math.floor(s % oneHour / oneMinute);
  var seconds = Math.round(s % oneHour % oneMinute);

  // Include hours if needed
  if (hours) {
    hours += ':';

    // If hours are specified, minutes should always be with two digits
    if (minutes < 10) minutes = '0' + minutes;
  } else {
    hours = '';
  }

  // Since minutes should always be displayed, seconds should always be with two digits
  if (seconds < 10) seconds = '0' + seconds;

  return hours + minutes + ':' + seconds;
};

duration.displayName = 'duration';

module.exports = duration;

},{}],144:[function(require,module,exports){
'use strict';

var nameListTooltip = require('./name-list-tooltip');

var facepile = function facepile(list, totalCount, mT, opts) {
  var options = opts;
  var minThresh = mT;

  if (!list) {
    return '';
  }

  if (arguments.length < 4) {
    options = minThresh;
    minThresh = 3;
  }

  minThresh = minThresh || 3;

  var len = list.length;
  var thresh = Math.min(minThresh, len);
  var ret = '';

  // Display faces.
  for (var i = 0; i < thresh; i++) {
    var obj = list[i];
    obj.modifiers = 'media-object-link media-object-simple';
    ret += options.fn(obj);
  }

  // Display badge count for hidden listeners.
  if (totalCount > thresh) {
    ret += options.inverse({
      badgeCount: totalCount - thresh,
      badgeTooltip: nameListTooltip(list.slice(thresh), totalCount - thresh)
    });
  }
  return ret;
};

facepile.displayName = 'facepile';

module.exports = facepile;

},{"./name-list-tooltip":150}],145:[function(require,module,exports){
(function (global){
'use strict';

var getHTTPLink = require('../util/link');

var isDesktop = !!global._getSpotifyModule;

var href = function href(uri) {
  if (isDesktop) return uri;
  return getHTTPLink(uri, 'https://play.spotify.com');
};

href.displayName = 'href';

module.exports = href;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../util/link":157}],146:[function(require,module,exports){
'use strict';

var loc = require('./loc');

var humanizeDuration = function humanizeDuration(ms) {
  if (isNaN(ms)) return ms;

  var s = Math.round(ms / 1000);
  var oneMinute = 60;
  var oneHour = 60 * oneMinute;

  var hours = Math.floor(s / oneHour);
  var minutes = Math.floor(s % oneHour / oneMinute);
  var seconds = Math.round(s % oneHour % oneMinute);

  var formattedDuration = '';

  if (hours) {
    formattedDuration += loc('HoursShort', hours, {});
  }

  if (minutes) {
    formattedDuration += ' ';
    formattedDuration += loc('MinutesShort', minutes, {});
  }

  if (!hours && !minutes || hours === 0 && minutes < 10) {
    formattedDuration += ' ';
    formattedDuration += loc('SecondsShort', seconds, {});
  }

  return formattedDuration.trim();
};

humanizeDuration.displayName = 'humanizeDuration';

module.exports = humanizeDuration;

},{"./loc":149}],147:[function(require,module,exports){
'use strict';

exports.compare = require('./compare');
exports.duration = require('./duration');
exports.facepile = require('./facepile');
exports.href = require('./href');
exports.humanizeDuration = require('./humanize-duration');
exports.list = require('./list');
exports.loc = require('./loc');
exports.nameListTooltip = require('./name-list-tooltip');
exports.numeral = require('./numeral');
exports.share = require('./share');
exports.slice = require('./slice');
exports.type = require('./type');
exports.userReaction = require('./user-reaction');

},{"./compare":142,"./duration":143,"./facepile":144,"./href":145,"./humanize-duration":146,"./list":148,"./loc":149,"./name-list-tooltip":150,"./numeral":151,"./share":152,"./slice":153,"./type":154,"./user-reaction":155}],148:[function(require,module,exports){
'use strict';

var map = require('mout/array/map');

var Handlebars = require('handlebars/dist/cjs/handlebars.runtime').default;

var lists = {};

var list = function list(array) {
  if (!array) {
    return '';
  }

  var args = Array.prototype.slice.call(arguments);
  var options = args.pop();
  var listID = args[1];

  if (array === 'reset') {
    delete lists[listID];
    return '';
  }

  if (listID && lists[listID] === undefined) {
    lists[listID] = -1;
  }

  return map(array, function (item, i) {
    var data = Handlebars.createFrame(options.data || {});
    data.index = listID ? ++lists[listID] : i;
    data.number = data.index + 1;
    data.localIndex = i;
    data.localNumber = i + 1;
    return options.fn(item, { data: data });
  }).join(options.hash && options.hash.join || '');
};

list.displayName = 'list';

module.exports = list;

},{"handlebars/dist/cjs/handlebars.runtime":313,"mout/array/map":333}],149:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var mixIn = require('mout/object/mixIn');
var slice_ = Array.prototype.slice;

var storage = {};

var loc = function loc(key) {
  var value = storage[key];

  if (!value) return '';

  var args = slice_.call(arguments, 1);
  var options = {};

  if (_typeof(args[args.length - 1]) === 'object') {
    options = args.pop();
  }

  var hash = options.hash;

  return value.replace(/\{([\w-]+)\}/g, function (full, match) {
    var n = +match;
    var interpolated;

    if (isNaN(n)) {
      interpolated = hash[match];
    } else {
      interpolated = args[n];
    }

    return interpolated !== null ? interpolated : '';
  });
};

loc.displayName = 'loc';

loc.register = function (object) {
  mixIn(storage, object);
  return this;
};

module.exports = loc;

},{"mout/object/mixIn":364}],150:[function(require,module,exports){
'use strict';

var loc = require('./loc');

var nameListTooltip = function nameListTooltip(users, totalCount) {
  if (totalCount === 0) {
    return undefined;
  }

  var len = users.length;
  var textTokens = users.map(function (user) {
    return user.name;
  });

  if (totalCount - len > 0) {
    var andMoreText = loc('AndMore', totalCount - len);
    textTokens.push(andMoreText);
  }

  return textTokens.join('<br>\n').replace(/'/g, '&#39;');
};

nameListTooltip.displayName = 'nameListTooltip';

module.exports = nameListTooltip;

},{"./loc":149}],151:[function(require,module,exports){
'use strict';

var isNumber = require('mout/lang/isNumber');

/**
 * If the first argument is a number, pipe it through spotify-numeral with an
 * optional format propety in the options hash, otherwise return it untouched.
 *
 * Example usage – results when using fr locale:
 *
 * {{numeral 1000}} -> '1 000'
 * {{numeral 1000 format='0,0.000'}} -> '1 000,000'
 * {{numeral 1000 format='$0,0.00'}} -> '€1 000,00'
 *
 * @param {Number|String} number - The number to format (or string to leave
 *     untouched).
 * @param {Object} [options] - The handlebars options object.
 * @param {Object} [options.hash] - The handlebars options hash object.
 * @param {String} [options.hash.format] - The optional format to pass to
 *     numeraljs.
 * @return {String} The formatted (or untouched) string.
 */
var numeralHelper = function numeralHelper(number, options) {
  var format = options && options.hash && options.hash.format;
  var numeral = numeralHelper._numeral;
  return isNumber(number) ? numeral(number).format(format) : number;
};

numeralHelper.displayName = 'numeral';

module.exports = numeralHelper;

// This is tricky, but is a way to allow for the locale to be injected
// from the consuming app instead of from within spotify-numeral, removing
// the dependency on spotify-quickstart.
module.exports.setLocale = function (locale) {
  numeralHelper._numeral = require('../../spotify-numeral')(locale);
};

},{"../../spotify-numeral":234,"mout/lang/isNumber":348}],152:[function(require,module,exports){
'use strict';

var getHTTPLink = require('../util/link');

var share = function share(uri) {
  return getHTTPLink(uri, 'https://open.spotify.com');
};

share.displayName = 'share';

module.exports = share;

},{"../util/link":157}],153:[function(require,module,exports){
'use strict';

var kindOf = require('mout/lang/kindOf');
var map = require('mout/array/map');
var forEach = require('mout/array/forEach');

var Handlebars = require('handlebars/dist/cjs/handlebars.runtime').default;
var slice_ = Array.prototype.slice;

var slice = function slice(arr) {
  var array = arr;

  if (!array) {
    return '';
  }

  var sep;
  var begin;
  var end;
  var options;

  forEach(slice_.call(arguments, 1), function (arg) {
    switch (kindOf(arg)) {
      case 'String':
        sep = arg;
        break;

      case 'Number':
        if (begin === null) {
          begin = arg;
        } else if (end === null) {
          end = arg;
        }
        break;

      case 'Object':
        options = arg;
        break;

      default:
      // Do nothing.
    }
  });

  if (begin !== null) {
    array = array.slice(begin, end !== null ? end : array.length);
  }

  return map(array, function (item) {
    var data = Handlebars.createFrame(options.data || {});

    return options.fn(item, { data: data });
  }).join(sep || '');
};

slice.displayName = 'slice';

module.exports = slice;

},{"handlebars/dist/cjs/handlebars.runtime":313,"mout/array/forEach":330,"mout/array/map":333,"mout/lang/kindOf":352}],154:[function(require,module,exports){
'use strict';

var getType = require('../util/type');

// This needs at least the uri param to get the type:
// {{type uri}}
//
// If you pass more parameters you can use it like a matcher:
// {{#type uri "track" "album"}}YAY{{/type}}
// This will print 'YAY' for tracks or albums.

var type = function type(uri) {
  if (arguments.length <= 2) {
    // Simple get type.
    return getType(uri);
  }

  // Match type.
  var context = arguments[arguments.length - 1];
  var success = false;
  var uriType = getType(uri);

  for (var i = 1; i < arguments.length - 1; i++) {
    if (uriType === arguments[i]) {
      success = true;
      break;
    }
  }

  return success ? context.fn(this) : context.inverse(this);
};

type.displayName = 'type';

module.exports = type;

},{"../util/type":158}],155:[function(require,module,exports){
'use strict';

var loc = require('./loc');

var userReaction = function userReaction(users, totalCount, reactionType) {
  if (!totalCount) return '';
  var key = reactionType + 'Reaction' + (totalCount > 1 ? 'Multi' : 'Single');

  if (totalCount > 1) {
    return loc(key, totalCount);
  }

  if (!users.length) {
    return '';
  }

  var firstListener = users[0].name;
  return loc(key, firstListener);
};

userReaction.displayName = 'userReaction';

module.exports = userReaction;

},{"./loc":149}],156:[function(require,module,exports){
'use strict';

var kindOf = require('mout/lang/kindOf');

var Handlebars = require('handlebars/dist/cjs/handlebars.runtime').default;

// Expose the runtime to make partials easier to register.
exports.runtime = Handlebars;

exports.register = function (helpers) {
  var list = {};

  if (kindOf(helpers) === 'Function') {
    list[helpers.displayName] = helpers;
  } else {
    list = helpers;
  }

  for (var key in list) {
    if (list.hasOwnProperty(key)) {
      Handlebars.registerHelper(key, list[key]);
    }
  }

  return this;
};

},{"handlebars/dist/cjs/handlebars.runtime":313,"mout/lang/kindOf":352}],157:[function(require,module,exports){
'use strict';

module.exports = function (uri, base) {
  var matches = (uri || '').match(/^spotify:(.+)$/);

  if (!matches) {
    return uri || '';
  }

  var parts = matches.pop().replace(/:$/, '').split(/:/);
  var type = parts.shift();

  if (type === 'search') {
    parts = [parts.join(':')];
  }

  parts.unshift(base, type);

  return parts.join('/');
};

},{}],158:[function(require,module,exports){
'use strict';

module.exports = function (uri) {
  if (!uri || !uri.split) {
    return null;
  }
  var parts = uri.split(':');
  var result = null;
  switch (parts[1]) {
    case 'album':
      // spotify:album:<id>:<disc>
      if (parts.length === 4) {
        return 'disc';
      } else if (parts.length === 3) {
        return 'album';
      }
      break;

    case 'artist':
      if (parts.length === 3) {
        return 'artist';
      }
      break;

    case 'track':
      if (parts.length === 3) {
        return 'track';
      }
      break;

    case 'genre':
      if (parts.length === 3) {
        return 'genre';
      }
      break;

    case 'station':
      if (parts.length > 3) {
        return 'station';
      }
      break;

    case 'local':
      if (parts.length === 6) {
        return 'track';
      } else if (parts.length === 4) {
        return 'album';
      } else if (parts.length === 3) {
        return 'artist';
      }
      break;

    case 'user':
      // spotify:user:<username>:collection
      if (parts.length > 3 && parts[3] === 'collection') {
        return 'collection';
      }

      // spotify:user:<username>:folder:<id>
      if (parts.length === 5 && parts[3] === 'folder') {
        return 'playlist-folder';
      }

      // spotify:user:<username>:<playlist:<id>|starred|toplist>
      if (parts.length > 3 && parts.length <= 5 && parts[2] !== 'facebook') {
        return 'playlist';
      } else if (parts.length === 3) {
        return 'user';
      }
      break;

    case 'internal':
      // spotify:internal:local-files
      return parts[2];

    case 'app':
      // spotify:app:collection:albums, spotify:app:radio
      return parts.slice(1).join('-');

    default:
    // Do nothing.
  }

  return result;
};

},{}],159:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var Translations = require('../spotify-translations');
var glueLocales = require('../spotify-glue-cat/strings');

module.exports = function (localeToStrings) {
  if (!localeToStrings || (typeof localeToStrings === 'undefined' ? 'undefined' : _typeof(localeToStrings)) !== 'object') {
    throw new Error('' + 'Locale strings must be a plain object. ' + 'See spotify-i18n/README.md');
  }

  function getClientLocale() {
    return typeof window !== 'undefined' && window.__spotify && window.__spotify.locale || 'en';
  }

  var locales = localeToStrings;
  var i18n = new Translations();
  i18n.injectData(locales[getClientLocale()] || {});

  return {
    locale: getClientLocale,
    get: i18n.get.bind(i18n),

    glueStrings: function glueStrings() {
      return glueLocales[getClientLocale()];
    },

    appStrings: function appStrings() {
      return locales[getClientLocale()];
    }
  };
};

},{"../spotify-glue-cat/strings":134,"../spotify-translations":253}],160:[function(require,module,exports){
'use strict';

var base = 'spotify:internal:filterlist';
var regExp = /^spotify:internal:filterlist:([^:]*):(.*)$/;

/**
 * Create a URI representing a filtered variant of a list.
 *
 * @param {string} originUri The original list URI.
 * @param {string} query The query string (compatible with Core). Filter
 *     implementations might not look at all values.
 *
 * @return {string} URI of the filtered variant of the list. The URI will have
 *     the query string URL encoded.
 */
exports.create = function (originUri, query) {
  originUri = originUri.replace(/^spotify:/, '');

  query = encodeURIComponent(query);

  return [base, query, originUri].join(':');
};

/**
 * Get the query string from a filter URI.
 *
 * @param {string} filterUri The URI of the filtered list.
 *
 * @return {string} The query string, URL decoded. If URI is
 *     invalid, this returns an empty string.
 */
exports.getQuery = function (filterUri) {
  var matches = filterUri.match(regExp);
  if (!matches) return '';

  return decodeURIComponent(matches[1]);
};

/**
 * Get the URI of the original list.
 *
 * @param {string} filterUri The URI of the filtered list.
 *
 * @return {string} The URI of the original list. If the filter URI is invalid,
 *     this returns an empty string.
 */
exports.getOriginUri = function (filterUri) {
  var matches = filterUri.match(regExp);
  if (!matches) return '';

  return 'spotify:' + matches[2];
};

/**
 * Parse and return all parts of the filter URI.
 *
 * @param {string} filterUri The URI of the filtered list.
 *
 * @return {Object?} An object with properties `direction`, `query` and `originUri`,
 *     or null if the URI is not valid.
 */
exports.parse = function (filterUri) {
  var matches = filterUri.match(regExp);
  if (!matches) return null;

  return {
    query: decodeURIComponent(matches[1]),
    originUri: 'spotify:' + matches[2]
  };
};

/**
 * Test if the provided URI is a valid filter URI.
 *
 * @param {string} filterUri The URI of the filtered list.
 *
 * @return {boolean} True if it's valid, false otherwise.
 */
exports.isValid = function (filterUri) {
  return regExp.test(filterUri);
};

/**
 * The regular expression that matches filter URIs.
 */
exports.regExp = regExp;

},{}],161:[function(require,module,exports){
(function (global){
'use strict';

var live = require('../../spotify-live');
var cosmos = require('../util/cosmos');
var Collection = require('./collection');

var endpoints = {
  isInCollection: 'sp://core-collection/v1/contains',
  updateIsInCollection: 'sp://core-collection/v1/items',
  changes: 'hm://collection-web/v1/@/changes',
  broadcast: 'sp://messages/v1/collectionstate',
  pubsub: 'hm://collection/collection/@/json'
};

var onCollectionPublish = function onCollectionPublish(error, response) {
  if (error) {
    if (global.console) console.error(error);
    return;
  }

  // Currently, we only store tracks in collection2, and derive albums from
  // these. Because of this, we only get tracks in the pubsub events, but
  // adding/removing a track might have altered the calculated Collection state
  // of its album. To check this, we pass the change set down to
  // the changes endpoint and will receive a list of objects with
  // uri and isInCollection properties that we can forward to live.
  cosmos.sanitizeURL(endpoints.changes, function (error, url) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }

    // FIXME: Hack alert
    // Because of enum weirdness in Java, we need to
    // uppercase the value in the type field.
    // Remove this map once FESK-1921 is fixed.
    response.body.items = response.body.items.map(function (item) {
      item.type = item.type.toUpperCase();
      return item;
    });
    // End hack alert

    cosmos.post({ url: url, body: response.body }, function (error, response) {
      if (error) {
        if (global.console) console.error(error);
        return;
      }
      response.body.items.forEach(function (item) {
        if (item.hasOwnProperty('isInCollection') && !item.hasOwnProperty('added')) {
          // Patch items to contain added
          item.added = item.isInCollection;
        }
      });
      live(response.body.items);
    });
  });
};

var albumCollection;
var broadcastSubscription;
var collectionSubscription;

var regExp = exports.matches = /^spotify:album:[^:]+$/;
var registered = false;
exports.register = function () {
  if (registered) return;
  registered = true;

  albumCollection = new Collection(endpoints);

  live.subscribe(regExp, 'publish', albumCollection.onPublish);
  live.subscribe(regExp, 'wait', albumCollection.onWait);

  broadcastSubscription = cosmos.subscribe({ url: endpoints.broadcast }, Collection.onBroadcast);
  collectionSubscription = cosmos.subscribe({ url: endpoints.pubsub }, onCollectionPublish);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  live.unsubscribe(regExp, 'publish', albumCollection.onPublish);
  live.unsubscribe(regExp, 'wait', albumCollection.onWait);

  albumCollection = null;

  if (broadcastSubscription) {
    broadcastSubscription.cancel();
    broadcastSubscription = null;
  }

  if (collectionSubscription) {
    collectionSubscription.cancel();
    collectionSubscription = null;
  }
};

exports._endpoints = endpoints;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../spotify-live":212,"../util/cosmos":208,"./collection":163}],162:[function(require,module,exports){
'use strict';

var profile = require('./profile');

var regExp = exports.matches = /^spotify:artist:/;
var registered;
exports.register = function () {
  if (registered) return;
  registered = true;

  profile.register(regExp);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  profile.unregister(regExp);
};

},{"./profile":167}],163:[function(require,module,exports){
(function (global){
'use strict';

// This model will take a URI and create a live model for that URI.
//
//
// It will listen for publish events on the live model. The publish
// events are only triggered when someone actually wants to update
// something on the backend.
// When a publish event is detected, it will:
//
// * If the changed property was "added", it will contact
//   the backend to update the stored collection state. If this
//   fails, it will set it to the opposite of what was pusblished.
//
// * On success, broadcast the changes to the rest of the client via
//   cosmos, as "isInCollection" / "isFollowing" and as "added".
//
// This model will also listen for update events on the live model.
// The update event will be triggered when someone changes the data
// on the live model, without an intention to update the backend.
// When an update event is detected, it will:
//
// This model will also listen for broadcast events from the rest
// of the client. When a broadcast event is received, this happens:
//
// * If the URI for the broadcast message does not match this model,
//   do nothing.
//
// * It will then update the live model with the data it received
//   from the broadcast event. This will trigger the update listener
//   described above, but it won't run the code because all properties
//   are there.

var prime = require('prime');
var defer = require('prime/defer');

var live = require('../../spotify-live');
var contains = require('mout/array/contains');

var cosmos = require('../util/cosmos');

var INSUFFICIENT_STORAGE = 507;

// COLLECTION

var Collection = prime({

  constructor: function constructor(endpoints) {
    var self = this;
    this.endpoints = endpoints;
    this.onPublish = this.onPublish.bind(this);
    this.waitQueue = [];
    this.onWait = this.onWait.bind(this);
    this.fetch = this.fetch.bind(this);
  },

  onPublish: function onPublish(model, data) {
    // If the property is "added", update the backend with the new value
    // If the update fails, revert the state
    // If the update does not fail, broadcast the new state, as "isInCollection" and "added"
    if ('added' in data) {

      var endpoints = this.endpoints;
      var state = !!data.added;

      // optimistic
      model.update({ added: state });

      var method = state ? 'post' : 'delete';
      this._publish(method, [model], function (error, data) {
        if (error) {
          // that's what being optimistic gets you
          model.update({ added: !state });
          if (error.response && error.response.getStatusCode() === INSUFFICIENT_STORAGE) {
            cosmos.post({
              url: 'sp://messages/v1/container/user-message',
              body: { id: 'collection-limit-exceeded' }
            });
          }
        } else {
          cosmos.post({ url: endpoints.broadcast, body: { uri: model.uri, isInCollection: state, added: state } });
          if (data && data.items) {
            data.items.forEach(function (item) {
              // Patch items to contain added
              item.added = item.isInCollection;
              cosmos.post({ url: endpoints.broadcast, body: item });
            });
          }
        }
      });
    }
  },

  onWait: function onWait(model, properties) {
    if (contains(properties, 'added')) {
      this.fetch(model);
    }
  },

  fetch: function fetch(model) {
    var endpoints = this.endpoints;
    var queue = this.waitQueue;

    queue.push(model);

    // The first thing that gets added to the queue should defer a batch fetch
    // for the next tick. On the next tick, it will batch fetch status for all
    // models added to the queue.
    if (queue.length === 1) {
      defer(this._fetchBatch, this);
    }
  },

  _fetchBatch: function _fetchBatch() {
    var queue = this.waitQueue;
    if (queue.length === 0) return;

    // Create a new queue for requests coming after this
    this.waitQueue = [];

    this._contains(queue, function (error, result) {
      // Collection returns 404 for a user without a collection. This is sent as an error,
      // but we will just interpret that as `isInCollection` is false. All other errors
      // we just throw.
      if (error && (!error.response || error.response && error.response.getStatusCode() !== 404)) {
        if (global.console) console.error(error);
        return;
      }

      queue.forEach(function (model, i) {
        var added = false;
        if (!error) added = result[i];
        model.update({ added: added });
      });
    });
  },

  _contains: function _contains(models, callback) {
    var url = this.endpoints.isInCollection;
    var body = this._getRequestBody(models);

    cosmos.post({ url: url, body: body }, function (error, result) {
      callback(error, result && result.body && result.body.found);
    });
  },

  _publish: function _publish(method, models, callback) {
    var url = this.endpoints.updateIsInCollection;
    var body = this._getRequestBody(models);

    cosmos[method]({ url: url, body: body }, function (error, result) {
      callback(error, result && result.body);
    });
  },

  _getRequestBody: function _getRequestBody(models) {
    return {
      items: models.map(function (model) {
        return model.uri;
      }),
      source: global.__spotify && global.__spotify.app_uri || null
    };
  }

});

// ----------------------

Collection.onBroadcast = function (error, response) {
  if (error) {
    if (global.console) console.error(error);
    return;
  }

  var value;
  if ('added' in response.body) value = response.body.added;
  // Deal with older versions of this package that send isInCollection / isFollowing
  else if ('isInCollection' in response.body) value = response.body.isInCollection;

  live(response.body.uri).update({
    added: value
  });
};

module.exports = Collection;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../spotify-live":212,"../util/cosmos":208,"mout/array/contains":323,"prime":375,"prime/defer":373}],164:[function(require,module,exports){
'use strict';

var album = require('./album');
var artist = require('./artist');
var playlist = require('./playlist');
var track = require('./track');
var user = require('./user');
var local = require('./local');

exports.register = function () {
  album.register();
  artist.register();
  playlist.register();
  track.register();
  user.register();
  local.register();
};

exports.unregister = function () {
  album.unregister();
  artist.unregister();
  playlist.unregister();
  track.unregister();
  user.unregister();
  local.unregister();
};

},{"./album":161,"./artist":162,"./local":165,"./playlist":166,"./track":168,"./user":169}],165:[function(require,module,exports){
'use strict';

var live = require('../../spotify-live');
var contains = require('mout/array/contains');

var onWait = function onWait(model, properties) {
  if (contains(properties, 'added')) {
    // Neither tracks nor albums or artists can ever be added to YM.
    model.update({ added: false });
  }
};

// Matches local track, albums and artists.
var regExp = exports.matches = /^spotify:local:[^:]*:[^:]*:[^:]*:\d*$|^spotify:local:[^:]*:[^:]*$|^spotify:local:[^:]*$/;
var registered = false;
exports.register = function () {
  if (registered) return;
  registered = true;

  live.subscribe(regExp, 'wait', onWait);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  live.unsubscribe(regExp, 'wait', onWait);
};

},{"../../spotify-live":212,"mout/array/contains":323}],166:[function(require,module,exports){
(function (global){
'use strict';

// The 'playlist' function will be called when a new live object is
// created for the pattern in playlist.matches. We use this function
// to automatically add data to the live model when requested, and to
// push any needed updates to the backend.
//
//
// It will listen for publish events on the live model. The publish
// events are only triggered when someone actually wants to update
// something on the backend.
// When a publish event is detected, it will:
//
// * Broadcast the changes to the rest of the client via cosmos.
//
// * If the changed property was `added`, it will contact
//   the backend to update the stored collection state for the
//   currently logged in user. If this fails, it will revert the
//   state for the live model and broadcast the reverted state.
//
// This function will also listen for update events on the live model.
// The update event will be triggered when someone changes the data
// on the live model, without an intention to update the backend.
// When an update event is detected, it will:
//
// This function will also listen for broadcast events from the rest
// of the client. When a broadcast event is received, this happens:
//
// * If the URI for the broadcast message does not match this model,
//   do nothing.
//
// * It will then update the live model with the data it received
//   from the broadcast event. This will trigger the update listener
//   described above, but it won't run the code because all properties
//   are there.

var contains = require('mout/array/contains');

var live = require('../../spotify-live');
var liburi = require('spotify-liburi');

var cosmos = require('../util/cosmos');
var bridge = require('../util/bridge').request;

var endpoints = {
  broadcast: 'sp://messages/v1/followstate'
};

function onPublish(model, data) {
  // If the property is "added", update the backend with the new
  // value. If the update fails somewhere along the way, revert the state
  // and broadcast the reverted state to the rest of the client.
  if ('added' in data) {
    model.update({ added: data.added });

    if (model.get('followersCount') != null) {
      model.update({
        followersCount: model.get('followersCount') + (data.added ? 1 : -1)
      });
    }

    updateBackend(model, !!data.added, function (error) {
      if (error) {
        // Revert optimistic change
        model.update({ added: !data.added });

        if (model.get('followersCount') != null) {
          model.update({
            followersCount: model.get('followersCount') + (!data.added ? 1 : -1)
          });
        }
      } else {
        broadcast(model);
      }
    });
  }
}

function onBroadcast(error, response) {
  if (error) {
    if (global.console) console.error(error);
    return;
  }
  var value;
  if ('added' in response.body) {
    value = response.body.added;
  } else if ('isFollowing' in response.body) {
    value = response.body.isFollowing;
  }

  if (value !== undefined) {
    live(response.body.uri).update({
      added: value
    });
  }
}

function fetchAdded(model) {
  cosmos.get({
    url: 'sp://core-playlist/v1/playlist/' + encodeURIComponent(model.uri) + '/metadata',
    body: {
      policy: {
        followed: true
      }
    }
  }, function (error, response) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }
    model.update({
      added: response.body.metadata.followed
    });
  });
}

function fetchFollowersCount(model) {
  bridge('playlist_subscribers_snapshot', [{ type: 'list', uri: model.uri }, 0, 0], function (error, data) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }
    model.update({
      followersCount: data.length
    });
  });
}

function getRequestData(callback) {
  // Assumes that the client live object either already has the data about the current user,
  // or that there is code included for getting this data on request.
  live('spotify:client').query('currentUser(username)', function (error, data) {
    if (error) return callback(error);

    callback(null, {
      username: data.currentUser.username
    });
  });
}

function broadcast(model) {
  var value = model.get('added');
  cosmos.post({
    url: endpoints.broadcast,
    body: {
      uri: model.uri,
      isFollowing: value,
      added: value
    }
  });
}

function updateBackend(model, added, callback) {
  if (added) {
    cosmos.post({
      url: 'sp://core-playlist/v1/rootlist',
      body: {
        operation: 'add',
        uris: [model.uri],
        before: 'start'
      }
    }, function (error, response) {
      if (error) return callback(error);
      model.update({
        added: true
      });
      callback(null);
    });
  } else {
    // Removing using Core needs the `rowId`, which we don't necessarily have,
    // so stick with old bridge message for now. It's only adding that needs to
    // be done using Core to fix KM-8804.
    bridge('library_unsubscribe', [liburi.profileURI(__spotify.username).toURI(), model.uri], function (error, data) {
      if (error) return callback(error, data);
      callback(null, data);
    });
  };
}

var onWait = function onWait(model, properties) {
  var needsAdded = contains(properties, 'added');
  var needsFollowersCount = contains(properties, 'followersCount');
  if (needsAdded) {
    var subscribed = model.get('subscribed');
    if (subscribed !== undefined) {
      model.update({ added: subscribed });
    } else {
      fetchAdded(model);
    }
  }
  if (needsFollowersCount) {
    fetchFollowersCount(model);
  }
};

var regExp = exports.matches = /^spotify:user:[^:]+:playlist:[^:]+$/;

var broadcastSubscription;
var registered;
exports.register = function () {
  if (registered) return;
  registered = true;

  live.subscribe(regExp, 'publish', onPublish);
  live.subscribe(regExp, 'wait', onWait);
  broadcastSubscription = cosmos.subscribe({ url: endpoints.broadcast }, onBroadcast);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  live.unsubscribe(regExp, 'publish', onPublish);
  live.unsubscribe(regExp, 'wait', onWait);

  broadcastSubscription.cancel();
  broadcastSubscription = null;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../spotify-live":212,"../util/bridge":206,"../util/cosmos":208,"mout/array/contains":323,"spotify-liburi":398}],167:[function(require,module,exports){
(function (global){
'use strict';

// This model will, when registered to live, listen for publish
// events on the live model. The publish events are only triggered
// when someone actually wants to update something on the backend.
// When a publish event is detected, it will:
//
// * Broadcast the changes to the rest of the client via cosmos.
//
// * If the changed property was isFollowing, it will contact
//   the backend to update the stored following state for the
//   currently logged in user. If this fails, it will revert the
//   state for the live model and broadcast the reverted state.
//
// This function will also listen for update events on the live model.
// The update event will be triggered when someone changes the data
// on the live model, without an intention to update the backend.
// When an update event is detected, it will:
//
// * If the changed property was isFollowing, it will automatically
//   update followersCount on the live model.
//
// This function will also listen for broadcast events from the rest
// of the client. When a broadcast event is received, this happens:
//
// * If the URI for the broadcast message does not match this model,
//   do nothing.
//
// * It will then update the live model with the data it received
//   from the broadcast event. This will trigger the update listener
//   described above, but it won't run the code because all properties
//   are there.
//

var intersection = require('mout/array/intersection');
var live = require('../../spotify-live');
var cosmos = require('../util/cosmos');
var requestsInProgress = {};

var endpoints = {
  isFollowing: 'hm://socialgraph/v2/is_following?format=json',
  followCounts: 'hm://socialgraph/v2/counts?format=json',
  updateIsFollowing: 'hm://socialgraph/v2/following?format=json',
  broadcast: 'sp://messages/v1/followstate'
};

function onUpdate(model, data) {

  // Only update followers count if that data was not present in the changed data
  if ('added' in data && !('followersCount' in data)) {
    var followersCount = model.get('followersCount');
    if (followersCount !== undefined) {
      var newFollowersCount = followersCount + (data.added ? 1 : -1);
      model.update({ followersCount: newFollowersCount });
    }
  }
}

function onPublish(model, data) {
  // If the property is added, update the backend with the new value.
  // If the update fails, revert the model state.
  // If the update is successful, broadcast the state to the client.
  if ('added' in data) {
    // if there is a request in course, do not launch a new request
    // as this can mess up with the Backend
    if (requestsInProgress[model.uri]) {
      return;
    }
    requestsInProgress[model.uri] = true;

    // we're optimistic this will work
    model.update({ 'added': data.added });

    updateBackend(model, !!data.added, function (error) {
      // request finished, we can accept more requests now
      delete requestsInProgress[model.uri];
      if (error) {
        // such is life.
        model.update({ added: !data.added });
      } else {
        model.update({ added: data.added });
        broadcast(model);
      }
    });
  }
}

function onBroadcast(error, response) {
  if (error) {
    if (global.console) console.error(error);
    return;
  }

  var body = response.body;
  var data = {};

  if ('added' in body) data.added = body.added;
  // Also accept broadcast from older versions that only send "isFollowing"
  else if ('isFollowing' in body) data.added = body.isFollowing;

  if ('followersCount' in body) data.followersCount = body.followersCount;
  if ('followingCount' in body) data.followingCount = body.followingCount;

  live(body.uri).update(data);
}

function onWait(model, properties) {
  if (intersection(properties, followProperties).length) getRequestData(model, function (error, data) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }
    updateIsFollowing(model, data);
    updateCounts(model, data);
  });
}

function updateIsFollowing(model, requestData, opt_callback) {
  var options = {
    url: endpoints.isFollowing,
    body: requestData
  };
  cosmos.get(options, function (error, response) {
    if (error && opt_callback) return opt_callback(error);
    if (error) {
      if (global.console) console.error(error);
      return;
    }

    var value = response.body[0].is_following;
    model.update({ added: value });

    if (opt_callback) opt_callback();
  });
}

function updateCounts(model, requestData, opt_callback) {
  var options = {
    url: endpoints.followCounts,
    body: requestData
  };
  cosmos.get(options, function (error, response) {
    if (error && opt_callback) return opt_callback(error);
    if (error) {
      if (global.console) console.error(error);
      return;
    }

    var body = response.body[0];

    model.update({
      followersCount: body.followers_count,
      followingCount: body.following_count
    });

    if (opt_callback) opt_callback();
  });
}

function getRequestData(model, callback) {
  // Assumes that the client live object either already has the data about the current user,
  // or that there is code included for getting this data on request.
  live('spotify:client').query('currentUser(uri)', function (error, data) {
    if (error) return callback(error);

    callback(null, {
      // Social graph v2 expects decoded uris (i.e. spotify:user:someone!
      // rather than spotify:user:someone%21). `currentUser(uri)` returns a
      // uri-encoded user name.
      source_uri: decodeURIComponent(data.currentUser.uri),
      target_uris: [decodeURIComponent(model.uri)]
    });
  });
}

function updateBackend(model, isFollowing, callback) {

  getRequestData(model, function (error, data) {
    if (error) return callback(error);
    var requestMethod = isFollowing ? 'post' : 'delete';
    cosmos[requestMethod]({ url: endpoints.updateIsFollowing, body: data }, function (error) {
      if (error) return callback(error);
      callback(null);
    });
  });
}

function broadcast(model) {
  var added = model.get('added');
  cosmos.post({
    url: endpoints.broadcast,
    body: {
      uri: model.uri,
      isFollowing: added,
      added: added,
      followersCount: model.get('followersCount'),
      followingCount: model.get('followingCount')
    }
  });
}

var followProperties = ['added', 'followersCount', 'followingCount'];

var broadcastSubscription;

exports.register = function (regExp) {
  live.subscribe(regExp, 'wait', onWait);
  live.subscribe(regExp, 'update', onUpdate);
  live.subscribe(regExp, 'publish', onPublish);

  // reset the requestsInProgress variable
  requestsInProgress = {};

  if (!broadcastSubscription) {
    broadcastSubscription = cosmos.subscribe({ url: endpoints.broadcast }, onBroadcast);
  }
};

exports.unregister = function (regExp) {
  live.unsubscribe(regExp, 'wait', onWait);
  live.unsubscribe(regExp, 'update', onUpdate);
  live.unsubscribe(regExp, 'publish', onPublish);

  if (broadcastSubscription) {
    broadcastSubscription.cancel();
    broadcastSubscription = null;
  }
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../spotify-live":212,"../util/cosmos":208,"mout/array/intersection":332}],168:[function(require,module,exports){
(function (global){
'use strict';

var live = require('../../spotify-live');
var cosmos = require('../util/cosmos');
var Collection = require('./collection');

var endpoints = {
  isInCollection: 'sp://core-collection/v1/contains',
  updateIsInCollection: 'sp://core-collection/v1/items',
  broadcast: 'sp://messages/v1/collectionstate',
  pubsub: 'hm://collection/collection/@/json'
};

var onCollectionPublish = function onCollectionPublish(error, response) {
  if (error) {
    if (global.console) console.error(error);
    return;
  }

  var items = response.body.items;
  items.forEach(function (item) {
    // FIXME: Hack alert
    // Because of enum weirdness in Java, we need to
    // uppercase the value in the type field.
    // Remove this once FESK-1921 is fixed.
    if (item.type.toUpperCase() === 'TRACK') {
      var uri = 'spotify:track:' + item.identifier;
      live(uri).update({ added: !item.removed });
    }
  });
};

var trackCollection;
var broadcastSubscription;
var collectionSubscription;

var regExp = exports.matches = /^spotify:track:[^:]+$/;
var registered = false;
exports.register = function () {
  if (registered) return;
  registered = true;

  trackCollection = new Collection(endpoints);

  live.subscribe(regExp, 'publish', trackCollection.onPublish);
  live.subscribe(regExp, 'wait', trackCollection.onWait);

  broadcastSubscription = cosmos.subscribe({ url: endpoints.broadcast }, Collection.onBroadcast);
  collectionSubscription = cosmos.subscribe({ url: endpoints.pubsub }, onCollectionPublish);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  live.unsubscribe(regExp, 'publish', trackCollection.onPublish);
  live.unsubscribe(regExp, 'wait', trackCollection.onWait);

  trackCollection = null;

  if (broadcastSubscription) {
    broadcastSubscription.cancel();
    broadcastSubscription = null;
  }

  if (collectionSubscription) {
    collectionSubscription.cancel();
    collectionSubscription = null;
  }
};

exports._endpoints = endpoints;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../spotify-live":212,"../util/cosmos":208,"./collection":163}],169:[function(require,module,exports){
'use strict';

var profile = require('./profile');

var regExp = exports.matches = /^spotify:user:[^:]+$/;
var registered;
exports.register = function () {
  if (registered) return;
  registered = true;

  profile.register(regExp);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  profile.unregister(regExp);
};

},{"./profile":167}],170:[function(require,module,exports){
(function (global){
/**
 * @module spotify-live-models/album
 */
'use strict';

var live = require('../spotify-live');

var liburi = require('spotify-liburi');

var intersection = require('mout/array/intersection');
var contains = require('mout/array/contains');
var mixIn = require('mout/object/mixIn');

var bridge = require('./util/bridge').request;

function isLocalAlbum(uri) {
  return liburi.from(uri).type === liburi.Type.LOCAL_ALBUM;
}

function isLocalArtist(uri) {
  return liburi.from(uri).type === liburi.Type.LOCAL_ARTIST;
}

function updateMetadata(model) {
  if (isLocalAlbum(model.uri)) {
    var uriObject = liburi.from(model.uri);
    if (uriObject) {
      var data = {
        local: true,
        name: uriObject.album,
        artists: [{
          uri: 'spotify:local:',
          name: '',
          local: true
        }]
      };
      if (uriObject.artist) {
        data.artists[0].uri = liburi.localArtistURI(uriObject.artist).toURI();
        data.artists[0].name = uriObject.artist;
        data.artists[0].local = true;
      }
      model.update(data);
    }
  } else {
    bridge('album_metadata', [model.uri], function (error, payload) {
      if (error) {
        if (global.console) console.error(error);
        return;
      }
      model.update(payload);
    });
  }
}

function updateLocal(model) {
  model.update({
    local: isLocalAlbum(model.uri)
  });
}

var idCounter = 1000;

function getRowUri(trackUri) {
  return trackUri.replace('spotify:', 'spotify:row:' + (++idCounter).toString(36) + ':');
}

function updateRows(model) {
  var descriptor = { type: 'list', uri: model.uri };

  bridge('album_tracks_snapshot', [descriptor, 0, 0, false], function (error, payload) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }

    bridge('album_tracks_snapshot', [descriptor, 0, payload.length, false], function (error, payload) {
      if (error) {
        if (global.console) console.error(error);
        return;
      }

      var discs = [];
      var uriId = liburi.from(model.uri).id;

      var rows = payload.metadata && payload.metadata.map(function (trackdata, i) {
        var track = mixIn({ uri: payload.array[i] }, trackdata);
        var discNum = track.disc ? track.disc - 1 : 0;
        track.unavailable = !track.playable;
        setLocalProperty(track);
        if (!discs[discNum]) {
          discs[discNum] = {
            rows: [],
            uri: uriId ? liburi.albumURI(uriId, discNum + 1).toURI() : ''
          };
        }
        var uri = getRowUri(track.uri);
        var trackObject = {
          track: track,
          uri: uri
        };
        discs[discNum].rows.push(trackObject);
        return trackObject;
      });

      model.update({ rows: rows, discs: discs });
    });
  });
}

function setLocalProperty(track) {
  if (track.album && track.album.uri) {
    track.album.local = isLocalAlbum(track.album.uri);
  }
  if (track.artists) {
    for (var i = 0, l = track.artists.length; i < l; i++) {
      var artist = track.artists[i];
      if (artist.uri) {
        artist.local = isLocalArtist(artist.uri);
      }
    }
  }
}

function onWait(model, properties) {
  var hasLocal = contains(properties, 'local');
  var hasRows = contains(properties, 'rows');
  var hasDiscs = contains(properties, 'discs');

  var metaFields = ['artists', 'image', 'images', 'name', 'playable', 'type', 'availability', 'date', 'label', 'copyrights'];

  var hasMetadata = !!intersection(properties, metaFields).length;

  if (hasMetadata) updateMetadata(model);
  if (hasRows || hasDiscs) updateRows(model);
  if (hasLocal) updateLocal(model);
}

var regExp = exports.matches = /^spotify:album:[0-9a-zA-Z]+$|^spotify:local:[^:]*:[^:]*$/;
var registered;
exports.register = function () {
  if (registered) return;
  registered = true;

  live.subscribe(regExp, 'wait', onWait);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  live.unsubscribe(regExp, 'wait', onWait);
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-live":212,"./util/bridge":206,"mout/array/contains":323,"mout/array/intersection":332,"mout/object/mixIn":364,"spotify-liburi":398}],171:[function(require,module,exports){
(function (global){
/**
 * @module spotify-live-models/application
 */
'use strict';

var contains = require('mout/array/contains');
var live = require('../spotify-live');
var bridge = require('./util/bridge').request;
var AppState = require('../spotify-navigation/app-state');

var BACKOFF = 100;

function bridgeWait() {
  bridge('application_event_wait', [], function (error, event) {
    if (!registered) return;
    if (error) {
      setTimeout(function () {
        bridgeWait(model);
      }, BACKOFF);
      if (global.console) console.error(error);
      return;
    }

    var model = live('spotify:application');

    if (event.data && event.data.arguments) {
      model.update({
        arguments: event.data.arguments.join(':')
      });
    }

    // These don't won't happen on Zelda, there we handle it through postMessage. See onMessage.
    switch (event.type) {
      case 'activate':
        model.update({ 'active': true });
        break;

      case 'deactivate':
        model.update({ 'active': false });
        break;
    }

    bridgeWait(model);
  });
}

function onMessage(message) {
  var model = live('spotify:application');

  if (message.data && message.data.name) {
    if (message.data.name === 'set_active') {
      model.update({
        active: message.data.active
      });
    } else if (message.data.name === 'set_arguments') {
      // Arguments come as an array of un-encoded values, but we need to
      // concatenate them to a single colon-separated string for the
      // current design of the API. This is incorrect, as arguments should
      // be encoded if they are joined in a string. We should fix this, but
      // not without a breaking change.
      // https://jira.spotify.net/browse/KM-2353
      model.update({
        arguments: message.data.arguments.join(':')
      });
    } else if (message.data.name === 'set_state') {
      model.update({
        state: AppState.unserialize(message.data.state)
      });
    }
  }
}

function onRegister(model) {
  model.update({
    version: global.__spotify && global.__spotify.app_version || '0.0.0'
  });

  bridge('application_query', [], function (error, payload) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }

    var data = {};
    if (payload.uri) data.appURI = payload.uri;
    if (payload.arguments) data.arguments = payload.arguments.join(':');
    if ('active' in payload) data.active = payload.active;

    model.update(data);
  });
}

function applicationOpenUri(model, event) {
  bridge('application_open_uri', [event.uri]);
}

function applicationReplaceUri(model, event) {

  // This is intended to work like history.replace in the browser.

  // Desktop can also replace further back, so the current appURI needs
  // to be passed.
  // Link can't replace further back anyway, so anything thruthy as the
  // second argument will just replace the current.

  model.get('appURI', function (error, appUri) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }
    bridge('application_open_uri', [event.uri, appUri]);
  });
}

var regExp = exports.matches = /^spotify:application$/;
var registered;
exports.register = function () {
  if (registered) return;
  registered = true;

  live.subscribe(regExp, 'push-history-state', applicationOpenUri);
  live.subscribe(regExp, 'replace-history-state', applicationReplaceUri);
  global.addEventListener('message', onMessage);
  bridgeWait();
  onRegister(live('spotify:application'));
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  live.unsubscribe(regExp, 'push-history-state', applicationOpenUri);
  live.unsubscribe(regExp, 'replace-history-state', applicationReplaceUri);
  global.removeEventListener('message', onMessage);
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-live":212,"../spotify-navigation/app-state":230,"./util/bridge":206,"mout/array/contains":323}],172:[function(require,module,exports){
(function (global){
/**
 * @module spotify-live-models/artist
 */
'use strict';

var liburi = require('spotify-liburi');
var contains = require('mout/array/contains');
var live = require('../spotify-live');
var bridge = require('./util/bridge').request;

function isLocalArtist(uri) {
  return liburi.from(uri).type === liburi.Type.LOCAL_ARTIST;
}

function updateMetadata(model) {
  if (isLocalArtist(model.uri)) {
    var uriObject = liburi.from(model.uri);
    if (uriObject) {
      model.update({
        local: true,
        name: uriObject.artist
      });
    }
  } else {
    bridge('artist_metadata', [model.uri], function (error, payload) {
      if (error) {
        if (global.console) console.error(error);
        return;
      }
      if (!payload.image && !model.get('image')) payload.image = '';
      if (!payload.images && !model.get('images')) payload.images = [];
      model.update(payload);
    });
  }
}

function updateLocal(model) {
  model.update({
    local: isLocalArtist(model.uri)
  });
}

function onWait(model, properties) {
  var hasLocal = contains(properties, 'local');
  var hasMetadata = false;
  var metaFields = ['image', 'images', 'name', 'popularity'];
  for (var i = 0, l = properties.length; i < l; i++) {
    if (contains(metaFields, properties[i])) {
      hasMetadata = true;
      break;
    }
  }

  if (hasMetadata) updateMetadata(model);
  if (hasLocal) updateLocal(model);
}

var regExp = exports.matches = /^spotify:artist:|^spotify:local:[^:]*$/;
var registered;
exports.register = function () {
  if (registered) return;
  registered = true;

  live.subscribe(regExp, 'wait', onWait);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  live.unsubscribe(regExp, 'wait', onWait);
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-live":212,"./util/bridge":206,"mout/array/contains":323,"spotify-liburi":398}],173:[function(require,module,exports){
(function (global){
/**
 * @module spotify-live-models/client-storage
 */
'use strict';

var forOwn = require('mout/object/forOwn');
var combine = require('mout/array/combine');
var remove = require('mout/array/remove');
var contains = require('mout/array/contains');

var URI = 'spotify:client-storage';
var live = require('../spotify-live');
var cosmos = require('./util/cosmos');
var endpoints = {
  broadcast: 'sp://messages/v1/client-storage'
};

var waiting = [];

function onInit(model) {
  // Set a flag for showing that the model has been implemented and
  // registered. This is so that we can check this in player without
  // making a breaking change. Would be great with a future live API
  // to see if someone has implemented a specific model.
  model.update({ implemented: true });
}

function onWait(model, properties) {
  // Ask the top frame to broadcast the properties.
  // Values will be null when they weren't stored.
  waiting = combine(waiting, properties);
  global.top.postMessage({
    type: 'client_storage',
    name: 'broadcast_client_storage',
    data: properties
  }, '*');
}

function onPublish(model, properties) {
  // Tell the top frame to persist and broadcast
  global.top.postMessage({
    type: 'client_storage',
    name: 'set_client_storage',
    data: properties
  }, '*');

  // Optimistic update
  model.update(properties);
}

function onBroadcast(error, event) {
  var update = {};
  var model = live(URI);
  forOwn(event.body, function (value, key) {

    // Update model if this instance of storage knows that the model waits for it
    var isWaiting = contains(waiting, key);

    // Or if the model has a potentially outdated value in the live cache
    var hasKey = model.get(key) !== undefined;

    if (isWaiting || hasKey) update[key] = value;
    if (isWaiting) remove(waiting, key);
  });
  model.update(update);
}

var broadcastSubscription;
var regExp = exports.matches = new RegExp('^' + URI + '$');
var registered;

exports.register = function () {
  if (registered) return;
  registered = true;

  live.subscribe(regExp, 'init', onInit);
  live.subscribe(regExp, 'wait', onWait);
  live.subscribe(regExp, 'publish', onPublish);
  broadcastSubscription = cosmos.subscribe({ url: endpoints.broadcast }, onBroadcast);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  live.unsubscribe(regExp, 'init', onInit);
  live.unsubscribe(regExp, 'wait', onWait);
  live.unsubscribe(regExp, 'publish', onPublish);

  if (broadcastSubscription) {
    broadcastSubscription.cancel();
    broadcastSubscription = null;
  }
  waiting.length = 0;
};

exports._endpoints = endpoints;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-live":212,"./util/cosmos":208,"mout/array/combine":322,"mout/array/contains":323,"mout/array/remove":334,"mout/object/forOwn":360}],174:[function(require,module,exports){
(function (global){
/**
 * @module spotify-live-models/client
 */
'use strict';

var live = require('../spotify-live');
var bridge = require('./util/bridge').request;
var liburi = require('spotify-liburi');

var BACKOFF = 100;

function updateCurrentUser(model) {
  bridge('user_metadata', ['spotify:user:@'], function (error, payload) {
    if (error) {
      if (global.__spotify && global.__spotify.username) {
        var username = global.__spotify.username;
        model.update({
          currentUser: {
            uri: liburi.profileURI(username).toURI(),
            username: username
          }
        });
      }

      if (global.console) console.error(error);
      return;
    }

    model.update({
      currentUser: {
        uri: liburi.profileURI(payload.username).toURI(),
        name: payload.name,
        username: payload.username
      }
    });
  });
}

function getFeatures(callback) {
  bridge('client_features', [], function (error, payload) {
    if (error) return callback(error);
    callback(null, payload.features);
  });
}

function updateSessionData(model) {
  bridge('session_query', [], function (error, payload) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }

    // Not all the clients expose employee property so it needs to be set if it does not exist
    if (payload.employee === undefined) {
      if (global.__spotify && global.__spotify.product_state && global.__spotify.product_state.employee) {
        // For Zelda
        payload.employee = global.__spotify.product_state.employee === '1' ? true : false;
      } else {
        // Clients older than 0.9.16 do not expose employee flag.
        payload.employee = false;
      }
    }

    model.update({ session: payload });

    // Initiate session subscription since data has been requested once.
    bridgeWaitSession(model);
  });
}

function bridgeWaitSession(model) {
  bridge('session_event_wait', [], function (error, event) {
    if (!registered) return;
    if (error) {
      setTimeout(function () {
        bridgeWaitSession(model);
      }, BACKOFF);
      if (global.console) console.error(error);
      return;
    }

    if (event.type === 'change') {
      model.get('session').update(event.data);
    }

    bridgeWaitSession(model);
  });
}

function showContextMenu(model, data) {
  if (global === window && window.top && window.top.postMessage) {
    window.top.postMessage({
      type: 'client_show_context_ui',
      data: data
    }, '*');
  }
}

function onWait(model, properties) {
  if (properties.indexOf('currentUser') > -1) {
    updateCurrentUser(model);
  }

  if (properties.indexOf('session') > -1) {
    updateSessionData(model);
  }
}

var hasFeatures;

function onFeaturesWait(featuresModel, properties) {
  // If features have been loaded before, every requested feature that
  // generates a 'wait' event after that is not an enabled feature in
  // the client, so we return false for all other properties.
  if (hasFeatures) {
    var features = {};
    properties.forEach(function (prop) {
      features[prop] = false;
    });
    featuresModel.update(features);
  } else {
    hasFeatures = true;
    getFeatures(function (error, features) {
      if (error) {
        if (global.console) console.error(error);
        return;
      }
      featuresModel.update(features);

      // Get a list of features that the model is waiting for still,
      // even after the received features were added.
      var neededFeatures = [];
      properties.forEach(function (prop) {
        if (!(prop in features)) neededFeatures.push(prop);
      });

      // Trigger a new wait handler for the properties it's still waiting for
      onFeaturesWait(featuresModel, neededFeatures);
    });
  }
}

function onInit(model) {
  // Get container_features and put it into it's own place on the client model.
  var __spotify = global.__spotify || {};
  var containerFeatures = live(__spotify.container_features || {});
  containerFeatures.on('wait', function (properties) {
    var update = {};
    for (var i = 0, property; property = properties[i]; i++) {
      update[property] = false;
    }
    containerFeatures.update(update);
  });

  // Listen for wait events on the features model to fetch data
  // through bridge and set other features to false
  var features = live({});
  features.on('wait', function (properties) {
    onFeaturesWait(features, properties);
  });

  model.update({
    features: features,
    containerFeatures: containerFeatures
  });

  // Grab the username from __spotify where available
  if (global.__spotify && global.__spotify.username) {
    var username = global.__spotify.username;
    model.update({
      currentUser: {
        uri: liburi.profileURI(username).toURI(),
        username: username
      }
    });
  }

  // Async fetch from bridge to complete currentUser to a user model
  // while we don't have all the info available elsewhere.
  updateCurrentUser(model);
}

var regExp = exports.matches = /^spotify:client$/;
var registered;
exports.register = function () {
  if (registered) return;
  registered = true;

  live.subscribe(regExp, 'wait', onWait);
  live.subscribe(regExp, 'init', onInit);
  live.subscribe(regExp, 'show-context-menu', showContextMenu);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  live.unsubscribe(regExp, 'wait', onWait);
  live.unsubscribe(regExp, 'init', onInit);
  live.unsubscribe(regExp, 'show-context-menu', showContextMenu);
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-live":212,"./util/bridge":206,"spotify-liburi":398}],175:[function(require,module,exports){
'use strict';

var live = require('../spotify-live');
var cosmos = require('./util/cosmos');

function onWait(model, properties) {
  model.on('wait', function (keys) {
    if (keys.indexOf('episode') > -1) {
      cosmos.get({
        url: 'sp://core-show/unstable/decorate',
        body: { items: [model.uri] }
      }, function (error, data) {
        if (error) throw error;

        var episode = data.body.items[model.uri];
        model.update({ episode: episode });
      });
    }
  });
}

var regExp = exports.matches = /^spotify:episode:[^:]+$/;
var registered;
exports.register = function () {
  if (registered) return;
  registered = true;

  live.subscribe(regExp, 'wait', onWait);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  live.unsubscribe(regExp, 'wait', onWait);
};

},{"../spotify-live":212,"./util/cosmos":208}],176:[function(require,module,exports){
'use strict';

var album = require('./album');
var application = require('./application');
var artist = require('./artist');
var client = require('./client');
var clientStorage = require('./client-storage');
var sessionStorage = require('./session-storage');
var player = require('./player');
var playlist = require('./playlist');
var sortlist = require('./sortlist');
var track = require('./track');
var user = require('./user');
var add = require('./add');
var localFiles = require('./local-files');
var listVariant = require('./list-variant');
var episode = require('./episode');

exports.register = function () {
  album.register();
  application.register();
  artist.register();
  client.register();
  clientStorage.register();
  sessionStorage.register();
  player.register();
  playlist.register();
  sortlist.register();
  track.register();
  user.register();
  add.register();
  localFiles.register();
  listVariant.register();
  episode.register();
};

exports.unregister = function () {
  album.unregister();
  application.unregister();
  artist.unregister();
  client.unregister();
  clientStorage.unregister();
  sessionStorage.unregister();
  player.unregister();
  playlist.unregister();
  sortlist.unregister();
  track.unregister();
  user.unregister();
  add.unregister();
  localFiles.unregister();
  listVariant.unregister();
  episode.unregister();
};

},{"./add":164,"./album":170,"./application":171,"./artist":172,"./client":174,"./client-storage":173,"./episode":175,"./list-variant":177,"./local-files":178,"./player":183,"./playlist":187,"./session-storage":188,"./sortlist":196,"./track":204,"./user":205}],177:[function(require,module,exports){
/**
 * @module spotify-live-models/list-variant
 */
'use strict';

var contains = require('mout/array/contains');
var showUnplayableTracks = require('./util/unplayable-tracks-playlist-setting.js');
var legacySortUris = require('./sorting/legacy-sort-uris');

var live = require('../spotify-live');
var sortUriUtils = require('../spotify-live-sort-uri');
var filterUriUtils = require('../spotify-live-filter-uri');
var URI = require('spotify-liburi');

var SESSION_STORAGE = 'spotify:session-storage';
var CLIENT_STORAGE = 'spotify:client-storage';
var SORT_VARIANT_KEY = 'list-variant-';
var STRING_FILTER_KEY = 'list-filter-string-';

var sessionStorageListeners = {};

function onWait(model, properties) {
  if (!contains(properties, 'listVariant')) {
    return;
  }

  var uri = getOriginUri(model.uri);

  // listVariant objects are shared amongst all variants.
  var listVariant = live(uri).get('listVariant');
  if (!listVariant) {
    listVariant = live({
      origin: {
        uri: uri
      }
    });
    listVariant.on('wait', onVariantWait.bind(null, listVariant));
  }

  model.update({ listVariant: listVariant });

  // If the model is a variant, set that list variant on the origin too
  // so it can be accessed there for the next variant to ask.
  if (uri !== model.uri) {
    live(uri).update({ listVariant: listVariant });
  }
}

function onVariantWait(model, properties) {
  if (contains(properties, 'currentUri')) {
    addAndWatchCurrentUri(model);
    // This will fulfill and watch all other properties
    return;
  }

  if (contains(properties, 'filterString')) {
    addAndWatchFilterString(model);
  }
  if (contains(properties, 'sortQuery') || contains(properties, 'sortDirection') || contains(properties, 'sortUri')) {
    addAndWatchSortQuery(model);
  }
  if (contains(properties, 'showUnplayable')) {
    addAndWatchUnplayable(model);
  }
}

function addAndWatchCurrentUri(model) {

  model.on('update', update);
  update();

  function update() {
    var props = 'filterString, sortQuery, sortDirection, sortUri, showUnplayable, origin(uri)';
    model.query(props, function (error, data) {
      if (error) {
        console.error('Error when getting', props, ':', Error);
        return;
      }

      var result = data.origin.uri;
      var filters = [];

      if (data.filterString) {
        filters.push('text contains ' + encodeURIComponent(data.filterString));
      }

      if (!data.showUnplayable) {
        filters.push('playable eq true');
      }

      if (filters.length) {
        result = filterUriUtils.create(result, filters.join(','));
      }

      var sortUriParams = data.sortUri && sortUriUtils.parse(data.sortUri);

      if (sortUriParams) {
        result = sortUriUtils.create(result, sortUriParams.direction, sortUriParams.query);
      }

      model.update({
        currentUri: result
      });
    });
  }
}

var showUnplayablePref;
var updateUnavailablePrefOn = [];

function addAndWatchUnplayable(model) {
  var uri = model.get('origin').uri;
  var type = URI.fromString(uri).type;

  if (type !== URI.Type.PLAYLIST) {
    model.update({ showUnplayable: true });
    return;
  }

  updateUnavailablePrefOn.push(model);
  if (showUnplayablePref != null) {
    model.update({ showUnplayable: showUnplayablePref });
    return;
  }

  showUnplayableTracks.subscribe(function (error, showUnplayable) {
    // Cache this globally as we will never cancel this subscribe here.
    // The same setting is valid for all models.
    if (error) {
      console.error(error);
      showUnplayable = false; // Should default to hide unplayable.
    }

    showUnplayablePref = showUnplayable;
    for (var i = 0; i < updateUnavailablePrefOn.length; i++) {
      updateUnavailablePrefOn[i].update({ showUnplayable: showUnplayable });
    }
  });
}

function addAndWatchSortQuery(model) {
  var uri = model.get('origin').uri;

  var clientStorage = live(CLIENT_STORAGE);
  var key = SORT_VARIANT_KEY + uri;
  if (clientStorage.get('implemented')) {
    updateSortParams(model, uri, key);
    clientStorage.on('update', function (changed) {
      if (changed.hasOwnProperty(key)) {
        updateSortParams(model, uri, key);
      }
    });
  } else {
    // There is no clientStorage. Update the model with defaults.
    var update = getDefaultQueryParams(uri);
    model.update(update);
  }
}

function updateSortParams(model, uri, key) {
  var clientStorage = live(CLIENT_STORAGE);

  clientStorage.get(key, function (error, variant) {
    // Respond with the sort variant if it's a valid sort URI
    var sortParams = variant && sortUriUtils.parse(variant);
    if (!error && sortParams) {
      // Check for legacy sort URIs and convert them by publishing
      // the updated version on client-storage
      var convertedFromLegacy = legacySortUris.legacyQueries[sortParams.query];

      if (convertedFromLegacy != null && convertedFromLegacy !== sortParams.query) {
        // Fix the legacy query on storage
        var fixedUri = sortUriUtils.create(uri, sortParams.direction, convertedFromLegacy);
        var publish = {};
        publish[key] = fixedUri;
        clientStorage.publish(publish);
        // This will trigger another update which will then set the sort params.
        return;
      }

      model.update({
        sortQuery: sortParams.query,
        sortDirection: sortParams.direction, // this is 'asc' or 'desc'
        sortUri: variant
      });
    } else if (variant === uri) {
      // This was unsorted.
      model.update({
        sortQuery: null,
        sortDirection: null,
        sortUri: null
      });
    } else {
      // There was nothing valid in store. Update the model with defaults.
      var update = getDefaultQueryParams(uri);
      model.update(update);
    }
  });
}

function getDefaultQueryParams(uri) {
  var sortQuery = null;
  var sortDirection = null;
  var sortUri = null;

  var isLocalFiles = uri === 'spotify:internal:local-files';
  if (isLocalFiles) {
    // Local files should be sorted by trackname by default
    sortQuery = 'track(name)';
    sortDirection = 'asc';
    sortUri = sortUriUtils.create(uri, sortDirection, sortQuery);
  }

  return {
    sortQuery: sortQuery,
    sortDirection: sortDirection,
    sortUri: sortUri
  };
}

function addAndWatchFilterString(model) {
  var uri = model.get('origin').uri; // The variant object itself doesn't have a uri, this is the one for the list it's about
  var sessionStorage = live(SESSION_STORAGE);
  var key = STRING_FILTER_KEY + uri;

  if (sessionStorage.get('implemented')) {
    updateFilterString(model, uri, key);
    sessionStorage.on('update', function (changed) {
      if (changed.hasOwnProperty(key)) {
        updateFilterString(model, uri, key);
      }
    });
  } else {
    model.update({ 'filterString': '' });
  }
};

function updateFilterString(model, uri, key) {
  var sessionStorage = live(SESSION_STORAGE);

  sessionStorage.get(key, function (error, value) {
    model.update({ 'filterString': value || '' });
  }, live.ASAP);
}

function getOriginUri(uri) {
  var sorted = sortUriUtils.parse(uri);
  if (sorted) uri = sorted.originUri;

  var filtered = filterUriUtils.parse(uri);
  if (filtered) uri = filtered.originUri;

  return uri;
}

function updateRegisteredStatus(status) {
  registered = status;
  live('spotify:list-variant').update({ implemented: status });
}

var regExp = exports.matches = /^spotify:/;
var registered;
exports.register = function () {
  if (registered) return;

  live.subscribe(regExp, 'wait', onWait);
  updateRegisteredStatus(true);
};

exports.unregister = function () {
  if (!registered) return;

  updateUnavailablePrefOn = [];
  showUnplayablePref = null;

  live.unsubscribe(regExp, 'wait', onWait);
  updateRegisteredStatus(false);
};

},{"../spotify-live":212,"../spotify-live-filter-uri":160,"../spotify-live-sort-uri":210,"./sorting/legacy-sort-uris":190,"./util/unplayable-tracks-playlist-setting.js":209,"mout/array/contains":323,"spotify-liburi":398}],178:[function(require,module,exports){
(function (global){
/**
 * @module spotify-live-models/local-files
 */
'use strict';

var contains = require('mout/array/contains');

var live = require('../spotify-live');
var listOperations = require('spotify-live-list-operations');
var liburi = require('spotify-liburi');
var Range = require('../spotify-range2');
var cosmos = require('./util/cosmos');

var regExp = /^spotify:internal:local-files$/;

function onWait(model, properties) {
  if (contains(properties, 'allows')) getAllows(model);
  if (contains(properties, 'rows')) getRows(model);
}

function getAllows(model) {
  model.update({
    allows: {
      insertTracks: false,
      removeTracks: false
    }
  });
}

function createRows(data) {
  var rows = new Array(data.length);

  for (var i = 0, l = data.length; i < l; i++) {
    var track = data[i];

    setLocalProperty(track);

    // We want timestamp in milliseconds, but the client gives it in seconds.
    var dateAdded = track.dateAdded * 1000;

    var row = {
      uri: getRowUri(track.uri),
      track: track,
      dateAdded: dateAdded
    };

    rows[i] = row;

    delete track.dateAdded;
    delete track.addedBy;
  }

  return rows;
}

function setLocalProperty(track) {
  if (track.album && track.album.uri) {
    var albumType = liburi.from(track.album.uri).type;
    track.album.local = albumType === liburi.Type.LOCAL_ALBUM;
  }
  if (track.artists) {
    for (var i = 0, l = track.artists.length; i < l; i++) {
      var artist = track.artists[i];
      if (artist.uri) {
        var artistType = liburi.from(artist.uri).type;
        artist.local = artistType === liburi.Type.LOCAL_ARTIST;
      }
    }
  }
}

function getRows(model) {
  cosmos.get({ url: 'sp://local-files/v1/tracks' }, function (error, response) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }

    model.update({
      rows: createRows(response.body)
    });

    cosmos.subscribe({ url: 'sp://local-files/v1/changes' }, function (error, response) {
      if (error) {
        if (global.console) console.error(error);
        return;
      }

      onChange(model, response.body);
    });
  });
}

function onChange(model, event) {
  switch (event.type) {
    case 'removed':
      onTracksRemoved(model, event.data);break;
    case 'added':
      onTracksAdded(model, event.data);break;
    case 'moved':
      onTracksMoved(model, event.data);break;
    case 'changed':
      onMetadataChanged(model, event.data);break;
  }
}

function onMetadataChanged(model, data) {

  // The positions we get could in some cases be for multiple ranges.
  //
  // We need to remove each range individually, so that we can re-add
  // the same range with updated data right after removing the range.
  // The reason we can't just update rows with new data is that the
  // metadata might cause the row to get a new URI (since local files
  // contain the metadata in the URI).

  var ranges = Range.fromIndices(data.positions);

  var startOfRangeInChangeset = 0;

  for (var rangeIndex = 0, range; range = ranges[rangeIndex]; rangeIndex++) {
    var indices = range.toIndices();
    var rangeLength = range.length;
    var tracks = new Array(indices.length);

    for (var i = 0; i < rangeLength; i++) {
      tracks[i] = data.tracks[startOfRangeInChangeset + i];
    }

    // Remove range and re-add it with new data
    var removeOperations = listOperations.getRemoveOperations(indices);
    model.get('rows').update(removeOperations);
    addTracksToList(model, tracks, indices[0]);

    startOfRangeInChangeset += rangeLength;
  }
}

function onTracksMoved(model, data) {
  var moveOperations = listOperations.getMoveOperations(data.positions, data.position);
  model.get('rows').update(moveOperations);
}

function onTracksRemoved(model, data) {
  var removeOperations = listOperations.getRemoveOperations(data.positions);
  model.get('rows').update(removeOperations);
}

function onTracksAdded(model, data) {
  addTracksToList(model, data.tracks, data.position);
}

function addTracksToList(model, tracks, index) {
  var rows = createRows(tracks);

  var insertOperations = listOperations.getInsertOperations(rows, index);
  model.get('rows').update(insertOperations);
}

var idCounter = 1000;
function getRowUri(trackUri) {
  return trackUri.replace('spotify:', 'spotify:row:' + (++idCounter).toString(36) + ':');
}

var registered = false;

exports.register = function () {
  if (registered) return;
  registered = true;
  live.subscribe(regExp, 'wait', onWait);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;
  live.unsubscribe(regExp, 'wait', onWait);
};

exports.matches = regExp;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-live":212,"../spotify-range2":251,"./util/cosmos":208,"mout/array/contains":323,"spotify-liburi":398,"spotify-live-list-operations":399}],179:[function(require,module,exports){
'use strict';

var cosmos = require('../util/cosmos');

var ARTIST_CONTEXT_URL = 'hm://artistplaycontext/';

function getContext(contextUri, options, opt_callback) {

  var url = contextUri.split(':').join('/');
  var resolverUrl = ARTIST_CONTEXT_URL + url + '/km';
  var postObject = { url: resolverUrl };

  cosmos.get(postObject, opt_callback);
}

module.exports = {
  getContext: getContext
};

},{"../util/cosmos":208}],180:[function(require,module,exports){
(function (global){
/**
 * @module spotify-live-models/player/control
 * @private
 */
'use strict';

var shuffleMode = require('../../spotify-shuffle-mode');
var cosmosPlayer = require('./cosmos-player');
var playerApi = require('./player-api');
var playlistResolver = require('./playlist-resolver');
var artistResolver = require('./artist-resolver');

var dataUtils = require('./data');

var cosmos = require('../util/cosmos');

/**
 * Check AB test if it should use new artist context resolver.
 *
 * @param {Function=} callback Callback function.
 **/
function shouldUseArtistContextPlayerResolver(callback) {
  var ARTIST_CONTEXT_TEST = 'Rollout_short_artist_context_desktop';
  cosmos.post({
    url: 'sp://abba/v1/flags',
    body: { flags: [ARTIST_CONTEXT_TEST] }
  }, function (_, response) {
    var flags = response && response.body && response.body.flags || [];
    var featureFlagCell = flags[0] && flags[0].featureName === ARTIST_CONTEXT_TEST && flags[0].cell;

    callback(featureFlagCell === 'Rollout');
  });
}

/**
 * Request to play a list of track URIs.
 *
 * @param {Array.<string>} trackUris Array of track URIs.
 * @param {?Array.<string>} opt_ids Array of one id per track. Not needed when the context never needs to be updated.
 * @param {Object} playOptions An object with play options.
 * @param {Function=} opt_callback Callback function.
 */
function playTrackUris(trackUris, opt_ids, playOptions, opt_callback) {
  playerApi.play(trackUris, opt_ids, playOptions, opt_callback);
}

/**
 * Request to play a context through the cosmos track resolver.
 *
 * @param {string} contextUri Context URI.
 * @param {Object} playOptions An object with play options.
 * @param {Function=} opt_callback Optional callback function.
 */
function playFromResolver(contextUri, playOptions, opt_callback) {
  playerApi.playFromResolver(contextUri, playOptions, opt_callback);
}

/**
 * Play a context directly, only supported on context player
 *
 * @param {Object} context Context object that CP can deal with.
 * @param {Object} playOptions An object with play options.
 * @param {Function=} opt_callback Optional callback function.
 */
function playContext(context, playOptions, opt_callback) {
  playerApi.playContext(context, playOptions, opt_callback);
}

/**
 * Request to play a context through the playlist resolver.
 *
 * @param {string} contextUri Context URI.
 * @param {Object} playOptions An object with play options.
 * @param {Function=} opt_callback Optional callback function.
 */
function playFromPlaylistResolver(contextUri, playOptions, opt_callback) {
  // For playlist playback we don't need to support ranges, so we'll
  // always just pick the first.
  var skipToIndex = {};

  // Todo: This should be cleaned up, we don't need a list of uids because we
  // never need ranges now. We do that stuff using pages.
  if (playOptions.uids) {
    skipToIndex.track_uid = playOptions.uids[0];
  } else if (playOptions.uid) {
    skipToIndex.track_uid = playOptions.uid;
  }

  // Todo: This should be cleaned up, we don't need a list of uids because we
  // never need ranges now. We do that stuff using pages.
  if (playOptions.uris) {
    skipToIndex.track_uri = playOptions.uris[0];
  } else if (playOptions.trackUri) {
    skipToIndex.track_uri = playOptions.trackUri;
  }

  var preparePlayOptions = {};
  if (Object.keys(skipToIndex).length) {
    preparePlayOptions.skip_to_index = skipToIndex;
  }
  if (shuffleMode.isEnabled()) {
    preparePlayOptions.player_options_override = {
      shuffling_context: true
    };
  }

  var playOrigin = {
    view_uri: playOptions.context,

    // fills in source_start & source_end
    // example values: browse, playlist-owned-by-self-non-collaborative
    feature_identifier: playOptions.source,

    // fills in referer
    // example values: spotify:app:browse
    referrer_identifier: playOptions.contextPlayerReferrer,

    // fills in referrer version
    feature_version: playOptions.referrerVersion
  };

  var options = {
    prepare_play_options: preparePlayOptions,
    play_origin: playOrigin
  };

  playlistResolver.play(contextUri, options, opt_callback);
}

/**
 * Request to play a single track.
 *
 * @param {string} uri The track URI.
 * @param {Object} playOptions An object with play options.
 * @param {Function=} opt_callback Optional callback function.
 */
function playTrack(uri, playOptions, opt_callback) {
  playOptions.context = uri;
  playOptions.track = uri;
  playOptions.index = 0;
  playTrackUris([uri], null, playOptions, opt_callback);
}

/**
 * Request to play tracks found in the list of rows.
 *
 * @param {LiveList} rows A live list of rows with tracks.
 * @param {Object} playOptions An object with play options.
 * @param {Function=} opt_callback Optional callback function.
 */
function playRows(rows, playOptions, opt_callback) {
  var index = playOptions.index;
  var range = playOptions.range;

  if (index === null && range) {
    dataUtils.getFirstPlayableRow(rows, range, function (error, index) {
      if (error && opt_callback) return opt_callback(error);
      if (error) {
        if (global.console) console.error(error);
        return;
      }

      var trackUris = dataUtils.getTracksFromRows(rows);
      playOptions.index = index;

      playTrackUris(trackUris, rows.keys, playOptions, opt_callback);
    });
  } else {
    var trackUris = dataUtils.getTracksFromRows(rows);
    playTrackUris(trackUris, rows.keys, playOptions, opt_callback);
  }
}

/**
 * Request to play artist context.
 *
 * @param {string} contextUri Context URI.
 * @param {Function=} opt_callback Optional callback function.
 */
function playFromArtist(uri, playOptions, opt_callback) {
  shouldUseArtistContextPlayerResolver(function (playFromArtistResolver) {
    if (playFromArtistResolver) {
      artistResolver.getContext(uri, playOptions, function (error, data) {
        if (error && opt_callback) return opt_callback(error);
        if (error) {
          if (global.console) console.error(error);
          return;
        }

        var contextObject = data.body;
        playContext(contextObject, playOptions, opt_callback);
      });
    } else {
      // If artist resolver is not enabled yet use regular resolver
      playFromResolver(uri, playOptions, opt_callback);
    }
  });
}

/**
 * Request to update the player with tracks from the provided rows list.
 * This will update the player silently without interrupting playback.
 *
 * @param {LiveList} rows A live list of rows with tracks.
 * @param {Object} playOptions An object with play options.
 * @param {Function=} opt_callback Optional callback function.
 */
function updateWithRows(rows, playOptions, opt_callback) {

  var tracks = dataUtils.getTracksFromRows(rows);

  // Context Player matches on UIDs so let's not provide index
  delete playOptions.index;
  playerApi.update(tracks, rows.keys, playOptions, opt_callback);
}

/**
 * Request to update the player with tracks from the cosmos track resolver.
 * This will update the player silently without interrupting playback.
 *
 * @param {Object} playOptions An object with play options.
 * @param {Function=} opt_callback Optional callback function.
 */
function updateWithResolver(playOptions, opt_callback) {

  /*
    Todo:
    When currently playing from tracklist, keys need to be passed on to the new playlist and folder resolver
  */

  cosmosPlayer.update(playOptions, null, opt_callback);
}

/**
 * Request to pause the playback.
 *
 * @param {Function=} opt_callback Optional callback function.
 */
function pause(opt_callback) {
  playerApi.pause(opt_callback);
}

/**
 * Request to resume the playback.
 *
 * @param {Function=} opt_callback Optional callback function.
 */
function resume(opt_callback) {
  playerApi.resume(opt_callback);
}

/**
 * Request to skip to the previous track.
 *
 * @param {Function=} opt_callback Optional callback function.
 */
function skipPrev(opt_callback) {
  cosmosPlayer.skipPrev(opt_callback);
}

/**
 * Request to skip to the next track.
 *
 * @param {Function=} opt_callback Optional callback function.
 */
function skipNext(opt_callback) {
  cosmosPlayer.skipNext(opt_callback);
}

exports.playTrack = playTrack;
exports.playRows = playRows;
exports.playFromResolver = playFromResolver;
exports.playContext = playContext;
exports.playFromArtist = playFromArtist;
exports.updateWithRows = updateWithRows;
exports.updateWithResolver = updateWithResolver;
exports.pause = pause;
exports.resume = resume;
exports.skipPrev = skipPrev;
exports.skipNext = skipNext;
exports.playFromPlaylistResolver = playFromPlaylistResolver;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../spotify-shuffle-mode":252,"../util/cosmos":208,"./artist-resolver":179,"./cosmos-player":181,"./data":182,"./player-api":184,"./playlist-resolver":185}],181:[function(require,module,exports){
/**
 * @module spotify-live-models/player/cosmos-player
 * @private
 */
'use strict';

var cosmos = require('../util/cosmos');

var PLAYER_URI = 'sp://player/v2/main';
var TRACK_RESOLVER_URI = 'hm://track-resolver/v1?uri=';

var deepFillIn = require('mout/object/deepFillIn');
var isStationUri = require('../station').isStationUri;

var ACTIONS = {
  PLAY: 'play',
  PAUSE: 'pause',
  RESUME: 'resume',
  UPDATE: 'update',
  SKIP_PREV: 'skip_prev',
  SKIP_NEXT: 'skip_next'
};

/**
 * Request to play a list of URIs or a resolvable context URI.
 *
 * @param {Object} options Object with options and data of what to play.
 * @param {?Array} opt_trackUris List of track URIs to play.
 * @param {Function=} opt_callback Callback function.
 */
function play(options, opt_trackUris, opt_callback) {
  if (opt_trackUris) options.tracks = opt_trackUris;
  var state = createCosmosState(options.context, options);

  state.action = ACTIONS.PLAY;

  postPlayerState(state, opt_callback);
}

/**
 * Request to pause the playback.
 *
 * @param {Function=} opt_callback Optional callback function.
 */
function pause(opt_callback) {
  cosmos.post({ url: PLAYER_URI, body: { action: ACTIONS.PAUSE } }, opt_callback);
}

/**
 * Request to resume the playback.
 *
 * @param {Function=} opt_callback Optional callback function.
 */
function resume(opt_callback) {
  cosmos.post({ url: PLAYER_URI, body: { action: ACTIONS.RESUME } }, opt_callback);
}

/**
 * Request to skip playback back.
 *
 * @param {Function=} opt_callback Optional callback function.
 */
function skipPrev(opt_callback) {
  cosmos.post({ url: PLAYER_URI, body: { action: ACTIONS.SKIP_PREV } }, opt_callback);
}

/**
 * Request to skip playback forward.
 *
 * @param {Function=} opt_callback Optional callback function.
 */
function skipNext(opt_callback) {
  cosmos.post({ url: PLAYER_URI, body: { action: ACTIONS.SKIP_NEXT } }, opt_callback);
}

/**
 * Request to update the player with the new state. This will not interupt
 * playback if the context is the same.
 *
 * @param {Object} state State object for the cosmos player.
 * @param {?Array} opt_trackUris List of track URIs to play.
 * @param {Function=} opt_callback Optional callback function.
 */
function update(options, opt_trackUris, opt_callback) {
  if (opt_trackUris) options.tracks = opt_trackUris;
  var state = createCosmosState(options.context, options);

  state.action = ACTIONS.UPDATE;

  // Up the index by one, since the comsos player expects the next track when updating to a different context.
  state.index++;

  // If the new index is past the end of the list, make it the last index of
  // the list. This will make it work for the case where the list only contains
  // a single track. For lists containing more tracks, this will make the player
  // continue playing the current track as a lone track (without any context)
  // and then pick up the right context with the right highlight and all after
  // that track has played.
  if (state.tracks && state.tracks.length <= state.index) {
    state.index = state.tracks.length - 1;
  }

  postPlayerState(state, opt_callback);
}

/**
 * Post the state object to the cosmos player.
 *
 * @param {Object} state State object for the cosmos player.
 * @param {Function=} opt_callback Optional callback function.
 */
function postPlayerState(state, opt_callback) {
  if (state.context) {
    cosmos.sanitizeURL(state.context, function (error, uri) {
      if (error) return opt_callback(error);
      state.context = uri;

      if (!state.tracks) {
        if (/^spotify:user:[^:]+:(playlist:)/.test(uri)) state.next_page_url = uri;else state.next_page_url = TRACK_RESOLVER_URI + encodeURI(uri);

        // Set tracks to an empty array since cosmos player on core js expects it.
        // REMOVE ME! 2014-10-24, see KM-3914.
        state.tracks = [];
      }

      cosmos.post({ url: PLAYER_URI, body: state }, opt_callback);
    });
  } else {
    cosmos.post({ url: PLAYER_URI, body: state }, opt_callback);
  }
}

/**
 * Request to get the current state of the cosmos player.
 *
 * @param {Function} callback Callback function.
 */
function getState(callback) {
  cosmos.get({ url: PLAYER_URI }, function (error, response) {
    if (error) return callback(error);
    callback(null, response.body);
  });
}

/**
 * Request to get the current state of the cosmos player whenever the player
 * changes.
 *
 * @param {Function} callback Callback function.
 *
 * @return {Object} An object with a method to unsubscribe.
 */
function subscribe(callback) {
  var subscription = cosmos.subscribe({ url: PLAYER_URI }, function (error, response) {
    if (error) return callback(error);
    callback(null, response.body);
  });

  return {
    unsubscribe: function unsubscribe() {
      if (!subscription) return;
      subscription.cancel();
      subscription = null;
    }
  };
}

/**
 * Create a state object for the cosmos player.
 *
 * @param {string} contextUri  Context URI.
 * @param {Object} playOptions An object with play options.
 *
 * @return {Object} An object with state in a format that the cosmos player understands.
 */
function createCosmosState(contextUri, playOptions) {

  var isStationContext = isStationUri(contextUri);
  var defaultState = {
    context: null,
    index: null,
    track: null,
    options: {
      can_repeat: true,
      can_shuffle: !isStationContext,
      can_skip_prev: !isStationContext,
      can_skip_next: true,
      can_seek: true,
      use_dmca_rules: false,
      repeat: false,
      repeat_track: false,
      shuffle_context: false
    },
    play_origin: {
      source: 'unknown',
      reason: 'unknown',
      referrer: 'unknown',
      referrer_version: 'unknown',
      referrer_vendor: 'unknown'
    }
  };

  var state = {
    context: contextUri,
    play_origin: {
      source: playOptions.source,
      reason: playOptions.reason,
      referrer: playOptions.referrer,
      referrer_version: playOptions.referrerVersion
    }
  };

  if ('tracks' in playOptions) state.tracks = playOptions.tracks;
  if ('index' in playOptions) state.index = playOptions.index;
  if ('track' in playOptions) state.track = playOptions.track;

  deepFillIn(state, defaultState);

  return state;
}

exports.play = play;
exports.pause = pause;
exports.resume = resume;
exports.skipPrev = skipPrev;
exports.skipNext = skipNext;
exports.update = update;
exports.getState = getState;
exports.subscribe = subscribe;

},{"../station":197,"../util/cosmos":208,"mout/object/deepFillIn":354}],182:[function(require,module,exports){
/**
 * @module spotify-live-models/player/data
 * @private
 */
'use strict';

var live = require('../../spotify-live');
var Range = require('../../spotify-range2');

var playerApi = require('./player-api');

/**
 * Default values for play options.
 */
var PLAY_OPTIONS_DEFAULTS = {
  page: null,
  uid: null,
  trackUri: null,
  index: null,
  source: 'unknown',
  reason: 'unknown'
};

/**
 * Get the first playable row from range in a list of rows.
 *
 * @param {LiveList} rows A live list of rows.
 * @param {Range} range A range object.
 * @param {Function} callback A callback where the second argument is the
 *     index of the first playable row. If no playable track is found, the
 *     index will be the first index in the range.
 */
function getFirstPlayableRow(rows, range, callback) {
  var index = range.start;

  isRowPlayable(rows.get(index), function playableCallback(error, playable) {
    if (playable) return callback(null, index);
    if (index === range.end - 1) return callback(null, range.start);

    isRowPlayable(rows.get(++index), playableCallback);
  });
}

/**
 * Check if the row is playable.
 *
 * @param {LiveObject?} row A row live object. If this is falsy, the callback
 *     is returned with false immediately.
 * @param {Function} callback A callback where the second argument is the
 *     boolean flag for playable. The callback may run synchronously or
 *     asynchronously.
 */
function isRowPlayable(row, callback) {
  if (!row) return callback(null, false);

  row.query('track(playable)', function (error, data) {
    if (error) return callback(error);
    callback(null, data.track.playable);
  }, live.ASAP);
}

/**
 * Get options for play actions based on a data object and other state
 * like referrer set on the player or application object.
 *
 * @param {Object} data A data object.
 * @param {Function} callback A callback, where the second argument is a data
 *     object with the options.
 */
function getPlayOptions(data, callback) {
  getReferrer(function (error, viewUri, baseUri) {
    if (error) return callback(error);

    Object.keys(PLAY_OPTIONS_DEFAULTS).forEach(function (key) {
      if (data[key] === undefined) {
        data[key] = PLAY_OPTIONS_DEFAULTS[key];
      }
    });

    if (data.range) {
      data.range = new Range(data.range[0], data.range[1]);
    }

    data.referrer = viewUri;
    data.contextPlayerReferrer = baseUri;
    data.referrerVersion = getReferrerVersion();

    callback(null, data);
  });
}

/**
 * Get a list of track URIs from a live list of rows.
 *
 * @param {LiveList} rows A live list of rows.
 *
 * @return {Array.<string>} Array of track URIs. If a row is not set in the list,
 *     or if the row doesn't have a track object with a URI, an 'undefined' value
 *     will be put in that position in the output array.
 */
function getTracksFromRows(rows) {
  return rows.map(function (row) {
    var track = row && row.get('track');
    return track && track.uri;
  });
}

/**
 * Get the latest player state, in the format of the player live model.
 *
 * @param {Function} callback Callback function.
 */
function getPlayerState(callback) {
  playerApi.getState(callback);
}

/**
 * Subscribe to the cosmos player to get the latest player state,
 * in the format of the player live model.
 *
 * @param {Function} callback Callback function.
 * @return {Object} An object with a method to unsubscribe.
 */
function subscribeForPlayerState(callback) {
  return playerApi.subscribe(callback);
}

/**
 * Get the referrer for the player. This is usually the path back to the app in
 * the state where the playback started. It can be set by the user in the `referrer`
 * property of the player live object. If nothing is set there, it will generate
 * the referrer by combining the app URI with the app arguments.
 *
 * @param {Function} callback A callback where the second argument is the referrer.
 */
function getReferrer(callback) {
  // 'referrer' corresponds to fullURI below
  var referrer = live('spotify:player').get('referrer');
  var referrerBaseUri = live('spotify:player').get('referrerBaseUri');
  if (referrer) {
    if (!referrerBaseUri) {
      console.warn('referrer field is set on the player model (' + referrer + '), but referrerBaseUri isn\'t');
    }
    return callback(null, referrer, referrerBaseUri || '');
  }

  live('spotify:application').get('appURI', 'arguments', function (error, uri, args) {
    if (error) return callback(error);
    var fullUri = args ? uri + ':' + args : uri;
    callback(null, fullUri, uri);
  });
}

/**
 * Get the referrer version. This is usually the version of the app. It can be set
 * by the user in the `version` property of the application live object. If nothing
 * is set there, it will use the default version '0.0.0'.
 *
 * @return {string} The version string.
 */
function getReferrerVersion() {
  return live('spotify:application').get('version') || '0.0.0';
}

exports.getReferrer = getReferrer;
exports.getReferrerVersion = getReferrerVersion;
exports.getFirstPlayableRow = getFirstPlayableRow;
exports.isRowPlayable = isRowPlayable;
exports.getPlayOptions = getPlayOptions;
exports.getTracksFromRows = getTracksFromRows;
exports.getPlayerState = getPlayerState;
exports.subscribeForPlayerState = subscribeForPlayerState;

},{"../../spotify-live":212,"../../spotify-range2":251,"./player-api":184}],183:[function(require,module,exports){
(function (global){
/**
 * @module spotify-live-models/player
 */
'use strict';

var live = require('../../spotify-live');
var shuffleMode = require('../../spotify-shuffle-mode');
var URI = require('spotify-liburi');
var cosmos = require('spotify-cosmos-api');

var playerApi = require('./player-api');
var playbackControl = require('./control');
var dataUtils = require('./data');
var updatesUtils = require('./updates');
var sortUriUtils = require('../../spotify-live-sort-uri');
var filterUriUtils = require('../../spotify-live-filter-uri');
var createStationPlayContext = require('../station/create-play-context');
var createStationPlayOptions = require('../station/create-play-options');
var isStationUri = require('../station').isStationUri;

var TYPE_TRACK = 'track';
var TYPE_TRACK_RESOLVER = 'track-resolver';
var TYPE_ROWS = 'rows';
var TYPE_CP_RESOLVER_PLAYLIST = 'context-player-resolver-playlist';
var TYPE_CP_CONTEXT = 'context-player-context';
var TYPE_CONTEXT_OBJECT = 'context-object';
var TYPE_STATION_CONTEXT = 'context-station-context';
var TYPE_CP_ARTIST_CONTEXT = 'context-player-artist';
var TYPE_CONTEXT_EPISODE = 'context-episode';
var VARIANT_KEY = 'list-variant-';
var lastPlayRequestId = 0;

// This data store will keep context objects keyed by context URI. The values
// are context objects in the format of spotify-player Context:
// https://ghe.spotify.net/spotify-sdk/spotify-player/blob/master/lib/v2/types.js#L164
var contextDataStore = {};

/**
 * Handler for when properties are requested from the model.
 *
 * @param {LiveObject} model The player live object.
 */
function onWait(model) {
  updateState(model);
}

/**
 * Handler for when the model needs to be updated by polling the player.
 *
 * @param {LiveObject} model The player live object.
 */
function onSync(model) {
  updateState(model);
}

/**
 * Handler for when the real player is updated.
 *
 * @param {Error?} error An error object, or null.
 * @param {Object} data Data object in the format of this live model.
 */
function onPlayerStateUpdate(error, data) {
  if (error) {
    if (global.console) console.error(error);
    return;
  }
  var model = live('spotify:player');
  if (model.get('pending')) return;
  model.update(data);
}

/**
 * Handler for when the model receives the 'update' event.
 *
 * @param {LiveObject} model The player live object.
 */
function onUpdate(model) {
  var index = model.get('index') && model.get('index').get('track');
  if (index != null) {
    updatesUtils.setPlayingIndex(index);
  }

  updatesUtils.clean(model);
}

/**
 * Handler for when the model receives the 'play' event.
 *
 * @param {LiveObject} model The player live object.
 * @param {Object} event The event object with data about what to play.
 *     Can contain the following properties:
 *       `context` (string, context URI)
 *       `index` (number, index within context to play)
 *       `uid` (string, uid within context to play)
 *       `page` (number, index for the context player page)
 *       `range` (array of two values, start and end index)
 *       `uids` (array of uids representing an index or a range)
 *       `uris` (array of uris connected to the uids)
 *       `source` (string)
 *       `reason` (string)
 */
function onPlay(model, event) {
  var context = event.context;
  if (!context) return;

  // The `index` property might be `null`, which should mean that no specific
  // index should be played.
  if (typeof event.index !== 'number') {
    delete event.index;
  }

  // [SHUFFLE] If we are in shuffle mode and we get a request for a specific
  // track, refuse to play.
  if (shuffleMode.isEnabled()) {
    if (event.hasOwnProperty('index') || event.hasOwnProperty('uid')) {
      cosmos.resolver.post({
        url: 'sp://messages/v1/container/user-message',
        body: {
          description: 'Track cannot be played because "shuffle mode" is enabled',
          id: 'shuffle-unplayable-track'
        }
      });
      return;
    }
  }

  var playRequestId = ++lastPlayRequestId;

  // Update the model optimistically
  model.update(playerApi.addContext({
    isPlaying: true,
    isPaused: false,
    index: event.index === undefined ? null : { page: 0, track: event.index },
    track: event.trackUri === undefined ? null : { uri: event.trackUri },
    contextUpdatedCrossFrame: false
  }, context));

  // Get options for the play action based on event data and other state
  // Todo: getPlayOptions creates options that fit the cosmos/v1 implementation.
  // We could probably do this a bit later from cosmos-player.js
  dataUtils.getPlayOptions(event, function (error, options) {
    if (error || !options.context) return updateState(model); // Revert state

    // Canonical contexts can have sorted and/or filtered state that needs
    // to be respected client-wide. We therefore query for the correct variant
    // to be played.
    // For spotify:internal uris on the other hand, we don't look for variants.
    // This would also be the case for contexts that already represent variants.
    // Please see docs for details.
    if (/^spotify:internal:/.test(options.context)) {
      playWithOptions(model, playRequestId, options);
      return;
    }

    if (live('spotify:list-variant').get('implemented')) {
      live(options.context).query('listVariant(currentUri, sortUri)', function (error, data) {
        if (error) return updateState(model); // Revert state

        // Abort if a new play request has happened since this request started
        if (lastPlayRequestId !== playRequestId) {
          return;
        }

        options.context = data.listVariant.currentUri;

        playWithOptions(model, playRequestId, options);
      });
    } else {
      playWithOptions(model, playRequestId, options);
    }
  });
}

/**
 * Handler for when the model receives the 'pause' event.
 *
 * @param {LiveObject} model The player live object.
 */
function onPause(model) {
  if (model.get('isPlaying') === false || model.get('isPaused') === true) {
    return;
  }

  model.update({ isPaused: true });

  playbackControl.pause(function (error) {
    if (error) return model.update({ isPaused: false });
  });
}

/**
 * Handler for when the model receives the 'resume' event.
 *
 * @param {LiveObject} model The player live object.
 */
function onResume(model) {
  if (model.get('isPlaying') === true && model.get('isPaused') === false) {
    return;
  }

  model.update({ isPaused: false });

  playbackControl.resume(function (error) {
    if (error) return model.update({ isPaused: true });
  });
}

/**
 * Handler for when the model receives the 'skip-previous' event.
 *
 * @param {LiveObject} model The player live object.
 */
function onSkipPrev() {
  // Skip prev often starts playback, but not when you're on the first track.
  // Therefor no optimistic update of 'playing' here.
  playbackControl.skipPrev();
}

/**
 * Handler for when the model receives the 'skip-next' event.
 *
 * @param {LiveObject} model The player live object.
 */
function onSkipNext() {
  // Skip next often starts playback, but not when you're on the last track.
  // Therefor no optimistic update of 'playing' here.
  playbackControl.skipNext();
}

/**
 * Handler for when the model receives the 'update-context' event.
 *
 * @param {LiveObject} model The player live object.
 * @param {Object} event An event object with a `context` property (string).
 */
function onUpdateContext(model, event) {
  var contextUri = event.context;
  if (!contextUri) return;

  var context = live(contextUri);
  var playRequestId = ++lastPlayRequestId;

  var currentIndex = model.get('index') && model.get('index').get('track');
  var currentContext = model.get('variant');

  // Update player model optimistically with context and no index.
  // We can't know the index yet, so we must set it to nothing to
  // not get wrong highlights.
  model.update(playerApi.addContext({
    index: null,
    pending: true,
    contextUpdatedCrossFrame: false
  }, contextUri));

  // We need the rows list to be able to get the index and play the list.
  live(contextUri).get('rows', function (error, rowsList) {
    if (error) {
      model.update({ pending: false });
      if (global.console) console.error(error);
      return;
    }

    var options = { context: contextUri };
    dataUtils.getPlayOptions(options, function (error, options) {

      // Abort if a new play request has happened since this request started
      if (lastPlayRequestId !== playRequestId) {
        return;
      }

      // Store which row is currently playing, so that we can get the index
      // of the playing row in another list.
      updatesUtils.setPlayingIndex(currentIndex, currentContext.get('rows'));

      // Find the index of the currently playing track in new list, to do an
      // optimistic update. This is not optional, since the actual player only appends
      // the next context and will not send an update until the next skip.
      // (If it does, because of play/pause for example, it will still report the old
      // list that we're not showing in the UI)

      // At the same time, find the index that we will use to actually update the playback
      var updateIndices = updatesUtils.getPlayingAndUpdateIndicesInList(rowsList);
      options.index = updateIndices.update;
      if (updateIndices.playing != null) model.update({ index: { page: 0, track: updateIndices.playing } });

      if (model.get('playOrigin') && model.get('playOrigin').get('referrerIdentifier') !== options.referrer) {
        model.update({ contextUpdatedCrossFrame: true });
      }

      playbackControl.updateWithRows(rowsList, options, function (error) {
        model.update({ pending: false });
        if (error) return updateState(model); // Revert state
      });

      updatesUtils.listen(rowsList, options, function (options) {
        playbackControl.updateWithRows(rowsList, options, function (error) {
          if (error) return updateState(model); // Revert state
        });
      });
    });
  });
}

/**
 * Request to start playback based on passed options.
 * If the request fails, it will revert the player model to the latest
 * state.
 *
 * @param {LiveObject} model The player live object.
 * @param {string} playRequestId The ID for this request.
 * @param {Object} options Object with options and data of what to play.
 */
function playWithOptions(model, playRequestId, options) {
  var contextUri = options.context;
  var resolverType = getPlaybackResolverType(contextUri);

  if (resolverType === TYPE_TRACK) {
    playbackControl.playTrack(contextUri, options, function (error) {
      if (error) return updateState(model); // Revert state
    });
  } else if (resolverType === TYPE_TRACK_RESOLVER) {
      playbackControl.playFromResolver(contextUri, options, function (error) {
        if (error) return updateState(model); // Revert state
      });
    } else if (resolverType === TYPE_ROWS) {
        var isSortedList = sortUriUtils.isValid(contextUri);

        // If it's a sorted list that is played by rows, we want to request all the track
        // URIs of the sorted list and then play that list of tracks. We will wait for all
        // tracks to be fetched and sorted, to allow clicking play on a media object in
        // Browse for example and have it play the stored sorted variant of the playlist.
        if (isSortedList) {
          getSortedRows(contextUri, function (error, rowsList) {
            if (error) return updateState(model); // Revert state

            // Abort if a new play request has happened since this request started
            if (lastPlayRequestId !== playRequestId) {
              return;
            }

            playRows(model, rowsList, options);
          });

          // Play any other context from the rows list
        } else {
            live(contextUri).query('rows(track(uri))', function (err) {
              if (!err && lastPlayRequestId === playRequestId) {
                playRows(model, live(contextUri).get('rows'), options);
              }
            });
          }
      } else if (resolverType === TYPE_CP_RESOLVER_PLAYLIST) {
        playbackControl.playFromPlaylistResolver(contextUri, options, function (error) {
          if (error) return updateState(model); // Revert state
        });
      } else if (resolverType === TYPE_CONTEXT_OBJECT) {
          var context = contextDataStore[contextUri];
          playbackControl.playContext(context, options, function (error) {
            if (error) return updateState(model); // Revert state
          });
        } else if (resolverType === TYPE_CP_CONTEXT) {

            var context = {
              url: 'context://' + contextUri,
              entity_uri: contextUri
            };

            playbackControl.playContext(context, options, function (error) {
              if (error) return updateState(model); // Revert state
            });
          } else if (resolverType === TYPE_STATION_CONTEXT) {
              var station = live(contextUri);
              station.query('rows', function (err) {
                if (!err) {
                  playbackControl.playContext(createStationPlayContext(station), createStationPlayOptions(station, options), function (error) {
                    if (error) return updateState(model); // Revert state
                  });
                }
              });
            } else if (resolverType === TYPE_CP_ARTIST_CONTEXT) {
                playbackControl.playFromArtist(contextUri, options, function (error) {
                  if (error) return updateState(model); // Revert state
                });
              } else if (resolverType === TYPE_CONTEXT_EPISODE) {
                  var episodeQueryTimeout = 3000;
                  live(contextUri).query('episode(name, manifestId, show(name))', function (error, data) {
                    if (error) return updateState(model); // Revert state

                    var episode = data.episode;
                    var context = {
                      'uri': contextUri,
                      'pages': [{
                        'tracks': {
                          'uri': contextUri,
                          'metadata': {
                            'title': episode.name,
                            'album_title': episode.show.name,
                            'media.type': 'video',
                            'media.manifest_id': episode.manifestId
                          }
                        }
                      }],
                      'restrictions': {
                        'disallow_skipping_prev_reasons': ['disallow-video'],
                        'disallow_skipping_next_reasons': ['disallow-video'],
                        'disallow_toggling_repeat_context_reasons': ['disallow-video'],
                        'disallow_toggling_repeat_track_reasons': ['disallow-video'],
                        'disallow_toggling_shuffle_reasons': ['disallow-video']
                      }
                    };

                    if (!options.player_options_override) {
                      options.player_options_override = {};
                    }
                    // Avoid repeating context when playing episode
                    // This might be removed in future when we have proper shows support
                    options.player_options_override.repeating_context = false;
                    options.player_options_override.repeating_track = false;

                    playbackControl.playContext(context, options, function (error) {
                      if (error) return updateState(model); // Revert state
                    });
                  }, episodeQueryTimeout);
                }
}

/**
 * Request to start playback based on passed rows list and options.
 * If the request fails, it will revert the player model to the latest
 * state.
 *
 * @param {LiveObject} model The player live object.
 * @param {LiveList} rowsList The rows live list.
 * @param {Object} options Object with options and data of what to play.
 */
function playRows(model, rowsList, options) {
  playbackControl.playRows(rowsList, options, function (error) {
    if (error) return updateState(model); // Revert state

    updatesUtils.listen(rowsList, options, function (options) {
      playbackControl.updateWithRows(rowsList, options, function (error) {
        if (error) return updateState(model); // Revert state
      });
    });
  });
}

/**
 * Get the type of playback resolver to use for a certain context URI.
 *
 * @param {string} contextUri Context URI.
 *
 * @return {string} A resolver type. One of 'track-resolver', 'rows' or 'track'.
 */
function getPlaybackResolverType(contextUri) {
  var contextType = URI.from(contextUri).type;

  var isTrack = contextType === URI.Type.TRACK;
  var isPlaylist = contextType === URI.Type.PLAYLIST;
  var isPlaylistFolder = contextType === URI.Type.FOLDER;
  var isArtist = contextType === URI.Type.ARTIST;
  var isSortedList = sortUriUtils.isValid(contextUri);
  var isFilteredList = filterUriUtils.isValid(contextUri);
  var isStation = isStationUri(contextUri);
  var isEpisode = contextType === URI.Type.EPISODE;

  if (isTrack) return TYPE_TRACK;

  if (isPlaylist) {
    return TYPE_CP_RESOLVER_PLAYLIST;
  }

  if (isPlaylistFolder) {
    return TYPE_CP_CONTEXT;
  }

  if (isStation) return TYPE_STATION_CONTEXT;

  var originContextType, originUri;
  if (isSortedList) {
    originUri = sortUriUtils.parse(contextUri).originUri;

    // If the sorted URI is in fact a filtered URI, the origin URI that _that_ is based on
    // needs to be taken into account when judging the originContextType.
    if (filterUriUtils.isValid(originUri)) originUri = filterUriUtils.parse(originUri).originUri;

    originContextType = URI.from(originUri).type;

    if (originContextType === URI.Type.PLAYLIST) {
      return TYPE_CP_RESOLVER_PLAYLIST;
    }

    return TYPE_ROWS;
  }

  if (isFilteredList) {
    // If the sorted URI is in fact a filtered URI, the origin URI that _that_ is based on
    // needs to be taken into account when judging the originContextType.
    originUri = filterUriUtils.parse(contextUri).originUri;
    originContextType = URI.from(originUri).type;

    if (originContextType === URI.Type.PLAYLIST) {
      return TYPE_CP_RESOLVER_PLAYLIST;
    }

    return TYPE_ROWS;
  }

  var contextData = contextDataStore[contextUri];
  if (contextData) {
    return TYPE_CONTEXT_OBJECT;
  }

  // If it's a different URI, check if we have rows
  var rowsList = live(contextUri).get('rows');
  if (rowsList && rowsList.length) {
    return TYPE_ROWS;
  }

  // If it's an artist context but context object or rows were not defined
  if (isArtist) {
    return TYPE_CP_ARTIST_CONTEXT;
  }

  if (isEpisode) {
    return TYPE_CONTEXT_EPISODE;
  }

  // If no rows are available, final hope is on the track resolver
  return TYPE_TRACK_RESOLVER;
}

/**
 * Get the stored variant of the list. For example, if a user has sorted a
 * playlist, that is stored in the client, so playing the playlist from another
 * place should play the stored sorted variant.
 *
 * @param {string} listUri The normal list URI.
 * @param {Function} callback Callback function where second argument is the
 *     URI of the variant to play. This could be the original list URI.
 */
function getStoredSortUri(listUri, callback) {
  live('spotify:client').query('containerFeatures(clientStorage)', function (error, data) {
    if (error) return callback(null, listUri);

    var defaultUri = listUri;

    if (data.containerFeatures.clientStorage) {
      var key = VARIANT_KEY + listUri;
      var clientStorage = live('spotify:client-storage');

      // Check whether the client storage live model has been registered.
      // This is so that we can check this without making this a
      // breaking change. Would be great with a future live API to see
      // if someone has implemented a specific model.
      if (clientStorage.get('implemented')) {
        clientStorage.get(key, function (error, variant) {
          if (error) return callback(null, defaultUri);

          // Respond with the sort variant if it's a valid sort URI
          if (variant && sortUriUtils.isValid(variant) || variant === listUri) {
            return callback(null, variant);
          }

          // Fall back to the regular playlist URI if it's not valid
          callback(null, defaultUri);
        });
      } else {

        // Fall back to the regular playlist URI if client storage is not implemented
        callback(null, defaultUri);
      }
    } else {
      callback(null, defaultUri);
    }
  });
}

/**
 * Get the live list for the rows of the sorted URI.
 *
 * @param {string} sortUri The URI of the sorted list.
 * @param {Function} callback Callback function where second argument is the
 *     sorted live list.
 */
function getSortedRows(sortUri, callback) {
  var playlistUri = sortUriUtils.getOriginUri(sortUri);

  // Get the rows list for the regular playlist.
  // We could have queried for the track of every row, but by not querying we
  // avoid the conversions from live objects to plain objects.
  live(playlistUri).get('rows', function (error, rows) {
    if (error) return callback(error);

    // Get the live models for all rows.
    rows.get(0, rows.length, function (error) {
      if (error) return callback(error);

      // When we know we have the rows, we can safely sort the list
      live(sortUri).get('rows', function (error, rowsList) {
        if (error) return callback(error);

        // Finally return the sorted rows list
        callback(null, rowsList);
      });
    });
  });
}

/**
 * Update the player model with the current data of the cosmos player model.
 *
 * @param {LiveObject} model The player live object.
 */
function updateState(model) {
  dataUtils.getPlayerState(function (error, data) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }
    model.update(data);
  });
}

var regExp = exports.matches = /^spotify:player$/;
var registered;
var playerSubscription;

exports.register = function () {
  if (registered) return;
  registered = true;

  live.subscribe(regExp, 'play', onPlay);
  live.subscribe(regExp, 'pause', onPause);
  live.subscribe(regExp, 'resume', onResume);
  live.subscribe(regExp, 'skip-previous', onSkipPrev);
  live.subscribe(regExp, 'skip-next', onSkipNext);
  live.subscribe(regExp, 'update-context', onUpdateContext);
  live.subscribe(regExp, 'update', onUpdate);
  live.subscribe(regExp, 'wait', onWait);
  live.subscribe(regExp, 'sync-position', onSync);

  playerSubscription = dataUtils.subscribeForPlayerState(onPlayerStateUpdate);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  live.unsubscribe(regExp, 'play', onPlay);
  live.unsubscribe(regExp, 'pause', onPause);
  live.unsubscribe(regExp, 'resume', onResume);
  live.unsubscribe(regExp, 'skip-previous', onSkipPrev);
  live.unsubscribe(regExp, 'skip-next', onSkipNext);
  live.unsubscribe(regExp, 'update-context', onUpdateContext);
  live.unsubscribe(regExp, 'update', onUpdate);
  live.unsubscribe(regExp, 'wait', onWait);
  live.unsubscribe(regExp, 'sync-position', onSync);

  playerSubscription.unsubscribe();
  playerSubscription = null;
};

exports.setContextData = function (contextUri, contextData) {
  contextDataStore[contextUri] = contextData;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../spotify-live":212,"../../spotify-live-filter-uri":160,"../../spotify-live-sort-uri":210,"../../spotify-shuffle-mode":252,"../station":197,"../station/create-play-context":198,"../station/create-play-options":199,"./control":180,"./data":182,"./player-api":184,"./updates":186,"spotify-cosmos-api":388,"spotify-liburi":398}],184:[function(require,module,exports){
(function (global){
/**
 * @module spotify-live-models/player/player-api
 * @private
 */
'use strict';

var dataUtils = require('./data');
var cosmosUtil = require('../util/cosmos');

var live = require('../../spotify-live');
var sortUriUtils = require('../../spotify-live-sort-uri');
var filterUriUtils = require('../../spotify-live-filter-uri');

var PlayerApi = require('spotify-player/lib/v2');
var cosmos = require('spotify-cosmos-api');
var shuffleMode = require('../../spotify-shuffle-mode');

var TRACK_RESOLVER_URI = 'hm://track-resolver/v2?uri=';

var player;

function getPlayer(callback) {

  if (player) {
    callback(player);
    return;
  }

  // One of a fixed list of features, since this is used for logging. It should
  // be the readable name of the feature, for example "radio", "album", "playlist"
  // and it should be the same for a given feature across platforms.
  // The list is probably this:
  // https://ghe.spotify.net/datainfra/log-parser/blob/master/spotify/log_parser/messages_specs.py#L29
  var featureIdentifier;

  // The version of the feature itself
  var featureVersion;

  var appManifest = global.__spotify && global.__spotify.app_manifest;
  if (appManifest) {
    featureVersion = appManifest.BundleVersion || null;
    featureIdentifier = appManifest.BundleIdentifier || null;
  }

  // Hard coded overwrites for apps where we needed to choose a new
  // BundleIdentifier for compat reasons
  // Todo: This is incomplete and would better be fixed by letting features
  // provide values specifically for this. See KM-6973.
  var overwrites = {
    'playlist-desktop': 'playlist'
  };

  if (featureIdentifier && overwrites[featureIdentifier]) featureIdentifier = overwrites[featureIdentifier];

  // The uri of the view that's supposed to show the context where the track is
  // playing, including arguments. That's called referrer in terms of the
  // player live model.
  dataUtils.getReferrer(function (error, viewUri, baseUri) {
    if (error && console) {
      console.error('The player API could not be initialized due to a missing referrer!', error);
      return;
    }

    var options = baseUri ? { referrerIdentifier: baseUri } : null;

    player = new PlayerApi.Player(cosmos.resolver, viewUri, featureIdentifier, featureVersion, options);
    callback(player);

    // The viewUri on this player instance can't ever change, so since we cache
    // it we have to destroy it when arguments change.
    live('spotify:application').on('update', function (data) {
      if ('arguments' in data) {
        player = null;
      }
    });
  });
}

function play(trackUris, opt_rowIds, playOptions, opt_callback) {
  getPlayer(function (player) {
    var tracks = new Array(trackUris.length);
    for (var i = 0; i < trackUris.length; i++) {
      var trackUri = trackUris[i];

      var track = { uri: trackUri };

      // [SHUFFLE]
      // To make the Shuffle rules work correctly, we need to pass album URI
      // and artist URI along with each track.
      if (shuffleMode.isEnabled()) {
        var album = live(trackUri).get('album');
        var artists = live(trackUri).get('artists');
        var albumUri = album && album.uri;
        var artistUri = artists && artists.get(0) && artists.get(0).uri;

        if (albumUri) {
          track.album_uri = albumUri;
        }

        if (artistUri) {
          track.artist_uri = artistUri;
        }
      }

      if (opt_rowIds) {
        track.uid = '' + opt_rowIds[i];
      }

      tracks[i] = track;
    }

    var context = {
      pages: [{
        tracks: tracks
      }],
      metadata: {
        'zelda.context_uri': playOptions.context
      },
      entity_uri: getOriginUri(playOptions.context)
    };

    var options = {};
    if (typeof playOptions.index === 'number') {
      options.skip_to_index = {
        page: 0,
        track: playOptions.index
      };
    }

    if (shuffleMode.isEnabled()) {
      options.player_options_override = {
        'shuffling_context': true
      };
    }

    player.play(context, options, opt_callback);
  });
}

function playContext(context, playOptions, opt_callback) {
  if (shuffleMode.isEnabled()) {
    playOptions.player_options_override = {
      'shuffling_context': true
    };
  }

  if (playOptions.uid || playOptions.uri || playOptions.page) {
    playOptions.skip_to = {};
    if (playOptions.uid) {
      playOptions.skip_to.track_uid = playOptions.uid;
    } else if (playOptions.uri) {
      playOptions.skip_to.track_uri = playOptions.uri;
    }

    // Together with UID send page_index property, so Connect can
    // figure out where to look for a track that needs to
    // be played. (Connect doesn't support UIDs at the moment).
    if (playOptions.page) {
      playOptions.skip_to.page_index = playOptions.page;
    }
  }

  getPlayer(function (player) {
    player.play(context, playOptions || {}, opt_callback);
  });
}

function update(trackUris, opt_rowIds, playOptions, opt_callback) {
  getPlayer(function (player) {

    var length = trackUris.length;
    var tracks = new Array(length);

    // Todo: When currently playing from the new playlist and folder resolver,
    // uids provided by the core resolver need to be used.

    for (var i = 0; i < length; i++) {

      tracks[i] = {
        uri: trackUris[i]
      };
      if (opt_rowIds) tracks[i].uid = '' + opt_rowIds[i];
    }

    var context = {
      pages: [{
        tracks: tracks
      }],
      metadata: {
        'zelda.context_uri': playOptions.context
      },
      entity_uri: getOriginUri(playOptions.context)
    };

    player.update(context, opt_callback);
  });
}

function playFromResolver(contextUri, playOptions, opt_callback) {
  getPlayer(function (player) {
    cosmosUtil.sanitizeURL(contextUri, function (error, uri) {
      if (error) {
        if (opt_callback) opt_callback(error);
        return;
      }

      var context = {
        entity_uri: uri
      };

      var options = null;
      if (typeof playOptions.index === 'number') {
        options = {
          skip_to_index: {
            page: 0,
            track: playOptions.index
          }
        };
      } else if (playOptions.trackUri) {
        options = {
          skip_to_index: {
            track_uri: playOptions.trackUri
          }
        };
      }

      context.pages = [{ page_url: TRACK_RESOLVER_URI + encodeURI(uri) }];

      player.play(context, options, opt_callback);
    });
  });
}

var cancelSubscribe;

function subscribe(callback, options) {
  cancelSubscribe = false;
  options = options || {};

  var subscription;
  getPlayer(function (player) {
    if (cancelSubscribe) return;
    subscription = player.subscribe(function (error, response) {
      if (error) {
        return callback(error);
      }
      callback(null, addContext(response.getJSONBody()));
    }, options);
  });

  return {
    unsubscribe: function unsubscribe() {
      cancelSubscribe = true;
      if (!subscription) return;
      subscription.cancel();
      subscription = null;
    }
  };
}

function getState(callback) {
  getPlayer(function (player) {
    player.getState(function (error, response) {
      if (error) {
        callback(error, null);
      } else {
        callback(null, addContext(response.getJSONBody()));
      }
    });
  });
}

function pause(opt_callback) {
  getPlayer(function (player) {
    player.pause(opt_callback);
  });
}

function resume(opt_callback) {
  getPlayer(function (player) {
    player.resume(opt_callback);
  });
}

function clear() {
  player = null;
}

/**
 * Adds the context to a given player state.
 *
 * @param {Object} data Input data in the format of the cosmos player live model (v2).
 * @param {string?} opt_uri Optional URI to be used in first place.
 * @return {Object} Data object.
 */
function addContext(data, opt_uri) {
  var uri = opt_uri || // We provide the URI of the context.
  data.context_metadata['zelda.context_uri'] || // Best case scenario.
  data.context_uri || // No special context, use the standard one.
  data.track && data.track.uri || // If a track is present, use it.
  null; // Nothing found; there's nothing being played.

  var context = getOriginUri(uri);

  // Avoid writing it into the context. People should always use the context object.
  delete data.context_uri;

  if (uri) {
    data.variant = { uri: uri };
    data.context = { uri: context };
  } else {
    data.variant = null;
    data.context = null;
  }

  // Track and index are flagged as "optional", meaning that when the player is stopped
  // will not be returned. Because of the way "live" works (waiting for properties until
  // they're set), it could happen that we wait forever for "track" and "index". For
  // aoviding this, we set them both to "null".
  data.track = data.track || null;
  data.index = data.index || null;

  if (data.track) {
    data.uid = data.track.uid;
    delete data.track.uid;
  } else {
    data.uid = null;
  }

  return removeUnderscores(data);
}

/**
 * Returns the original URI from a given filtered & sorted URI. For example, given
 * this URL:
 *
 * spotify:internal:sortlist:desc:track(name):internal:filterlist:playable%20eq%20true:user:myuser:playlist:7h5o3lf1ithsxec0wgjznj
 *
 * This method would return:
 *
 * spotify:user:myuser:playlist:7h5o3lf1ithsxec0wgjznj
 *
 * @param {string} uri An internal URI format with sort and/or query parts.
 * @return {string} The original URI.
 */
function getOriginUri(uri) {
  if (!uri) {
    return uri;
  }

  var sorted = sortUriUtils.parse(uri);
  if (sorted) uri = sorted.originUri;

  var filtered = filterUriUtils.parse(uri);
  if (filtered) uri = filtered.originUri;

  return uri;
}

/**
 * Transforms C++ syntax for variable names and keys (underscore_names) to the JS format
 * (camelCase).
 */
function removeUnderscores(data) {
  var transformedKey;

  for (var key in data) {
    if (data.hasOwnProperty(key)) {
      transformedKey = key.replace(/_(.)/g, function (str, chr) {
        return chr.toUpperCase();
      });

      if (data[key] instanceof Object) {
        data[transformedKey] = removeUnderscores(data[key]);
      } else {
        data[transformedKey] = data[key];
      }

      if (transformedKey !== key) {
        delete data[key];
      }
    }
  }

  return data;
}

exports.play = play;
exports.playFromResolver = playFromResolver;
exports.playContext = playContext;
exports.pause = pause;
exports.resume = resume;
exports.update = update;
exports.subscribe = subscribe;
exports.getState = getState;
exports.clear = clear;
exports.addContext = addContext;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../spotify-live":212,"../../spotify-live-filter-uri":160,"../../spotify-live-sort-uri":210,"../../spotify-shuffle-mode":252,"../util/cosmos":208,"./data":182,"spotify-cosmos-api":388,"spotify-player/lib/v2":400}],185:[function(require,module,exports){
'use strict';

var cosmos = require('../util/cosmos');

var sortUriUtils = require('../../spotify-live-sort-uri');
var filterUriUtils = require('../../spotify-live-filter-uri');
var coreSortParams = require('../../spotify-core-sort-params');

var PLAYLIST_RESOLVER = 'sp://core-playlist/v1/playlist/';

// Todo: This is playlist-desktop/src/core-datasource/parse-uri.js
// but it's much easier to make it common when we OneRepo™.
function parseURI(uri) {
  var parsedSortUri = sortUriUtils.parse(uri);
  if (parsedSortUri) uri = parsedSortUri.originUri;
  var parsedFilterUri = filterUriUtils.parse(uri);
  if (parsedFilterUri) uri = parsedFilterUri.originUri;
  return {
    uri: uri,
    sort: parsedSortUri,
    filter: parsedFilterUri
  };
}

function play(contextUri, options, opt_callback) {

  var parsed = parseURI(contextUri);

  var query = [];
  if (parsed.sort) {
    var direction = parsed.sort.direction === 'desc' ? 'DESC' : 'ASC';
    query.push('sort=' + encodeURIComponent(coreSortParams(parsed.sort.query, direction)));
  }

  var filters = [];
  if (parsed.filter) {
    var filtersFromQuery = parsed.filter.query.split(',').map(function (filter) {
      return encodeURIComponent(filter);
    });
    filters.push.apply(filters, filtersFromQuery);
  }
  if (filters.length) {
    query.push('filter=' + filters.join(','));
  }

  // Include a contextUri that is then reflected as the context in the player state
  query.push('uri=' + encodeURIComponent(contextUri));

  var queryString = '';
  if (query.length) {
    queryString = '?' + query.join('&');
  }

  var url = encodeURIComponent(parsed.uri);
  var resolverUrl = PLAYLIST_RESOLVER + url + '/play' + queryString;
  var postObject = { url: resolverUrl };
  if (options) postObject.body = options;

  cosmos.post(postObject, opt_callback);
}

module.exports = {
  play: play
};

},{"../../spotify-core-sort-params":39,"../../spotify-live-filter-uri":160,"../../spotify-live-sort-uri":210,"../util/cosmos":208}],186:[function(require,module,exports){
/**
 * @module spotify-live-models/player/updates
 * @private
 */
'use strict';

var lastRowsList;
var lastRowsListUri;
var lastRowsListHandler;
var lastRowsListReferrer;
var playerRowKey;
var playerKeys;

/**
 * Listen for updates on a rows list and update the player when
 * changes happen.
 *
 * @param {LiveList} rowsList A live list of rows.
 * @param {Object} options Object with options and data of what to play.
 * @param {Function} handler A handler function that gets called whenever
 *     the list is updated. Gets called with one argument: an options object.
 */
function listen(rowsList, options, handler) {
  if (lastRowsList) {
    removeRowsListener();
  }

  lastRowsList = rowsList;
  lastRowsListUri = options.context;
  lastRowsListReferrer = options.contextPlayerReferrer;

  lastRowsListHandler = function lastRowsListHandler() {
    // Todo: Only add this for TPM.
    options.index = getPlayingAndUpdateIndicesInList(rowsList).update;
    handler(options);
  };

  rowsList.on('update', lastRowsListHandler);
}

/**
 * Check if the last added rows listener is still valid for the current
 * player state, and clean up the update handler if it's not valid.
 *
 * @param {LiveObject} model The player live object.
 */
function clean(model) {
  if (!lastRowsListHandler) return;

  var context = model.get('variant');

  // Remove listener if the player context is no longer the same
  if ((context && context.uri) !== lastRowsListUri) {
    removeRowsListener();

    // Remove listener if the player referrer is no longer the same
  } else {
      var origin = model.get('playOrigin');
      var playerReferrer = origin && origin.get('referrerIdentifier');

      if (playerReferrer !== lastRowsListReferrer && !model.get('contextUpdatedCrossFrame')) {
        removeRowsListener();
      }
    }
}

/**
 * Save which item is currently playing.
 *
 * @param {number} index The index for the playing row.
 */
function setPlayingIndex(index, optRowsList) {
  if (!lastRowsList && !optRowsList) {
    return;
  }

  // If the index is out of bounds (e.g. is -1 because the track is not found),
  // then just keep the old playerRowKey.
  if (index < 0) {
    return;
  }

  var list = optRowsList || lastRowsList;

  playerRowKey = list.keys[index] || null;
  playerKeys = list.keys.slice();
}

/**
 * Remove the saved rows listener data.
 */
function removeRowsListener() {
  if (lastRowsList) {
    lastRowsList.off('update', lastRowsListHandler);
  }

  lastRowsList = null;
  lastRowsListUri = '';
  lastRowsListHandler = null;
  lastRowsListReferrer = '';
}

/**
 * Get the index of the playing row in the provided list.
 *
 * @param {LiveList} rowsList A live list of rows.
 *
 * @return {number} The index of the playing row, or -1 if not found.
 */
function getPlayingAndUpdateIndicesInList(rowsList) {
  if (!playerRowKey) return { update: -1, playing: -1 };

  // Find the currently playing row in the new list
  var playingIndexInNewList = rowsList.keys.indexOf(playerRowKey);
  var updateIndex = playingIndexInNewList;

  // If the playing row was not found in the new list, loop through the row
  // keys of the list that the player is currently playing from, and try to
  // find the next row key that exist both in the currently playing list and
  // the new list.
  if (playingIndexInNewList === -1) {
    var indexInPlayerList = playerKeys.indexOf(playerRowKey);
    for (var i = indexInPlayerList, l = playerKeys.length; i < l; i++) {
      updateIndex = rowsList.keys.indexOf(playerKeys[i]);
      if (updateIndex > -1) {

        // Index must be -1 since we've moved down several rows. The cosmos
        // player wants the index of the next row, so before passing it to
        // cosmos, the index will be incremented again.
        updateIndex--;

        break;
      }
    }
  }

  return {
    update: updateIndex,
    playing: playingIndexInNewList
  };
}

/**
 * Check if the player is currently playing from a rows list.
 *
 * @param {string} opt_uri Context URI. If passed, it checks for that specific URI.
 *
 * @return {boolean} True if it is playing from a rows list, false otherwise.
 */
function isPlayingFromRowsContext(opt_uri) {
  if (opt_uri) return lastRowsListUri === opt_uri;

  return !!lastRowsList;
}

exports.setPlayingIndex = setPlayingIndex;
exports.listen = listen;
exports.clean = clean;
exports.getPlayingAndUpdateIndicesInList = getPlayingAndUpdateIndicesInList;
exports.isPlayingFromRowsContext = isPlayingFromRowsContext;

},{}],187:[function(require,module,exports){
(function (global){
/**
 * @module spotify-live-models/playlist
 */
'use strict';

var contains = require('mout/array/contains');
var mixIn = require('mout/object/mixIn');
var intersection = require('mout/array/intersection');
var interpolate = require('interpolate');

var live = require('../spotify-live');
var liburi = require('spotify-liburi');

var cosmos = require('./util/cosmos');
var bridgeRequest = require('./util/bridge').request;
var debug = require('debug')('spotify-live-models:playlist');

var CLIENT = 'spotify:client';
var BACKOFF = 100;

var OFFLINE_STATUS = {
  NO: 'no',
  WAITING: 'waiting',
  DOWNLOADING: 'downloading',
  YES: 'yes'
};

var endpoints = {
  broadcast: 'sp://messages/v1/playliststate',
  'core-playlist': 'sp://core-playlist/v1/playlist'
};

function onBroadcast(error, response) {
  if (error) {
    if (global.console) console.error(error);
    return;
  }

  live(response.body.uri).update(response.body);
}

var offlineSubscriptions = {};

// This bridge call is only available in the C++ bridge and is used for
// updating subscribed/following state for the playlist.
function bridgeWaitAny(model) {
  bridgeRequest('playlist_event_wait_any', [model.uri], function (error, event) {
    // Bridge (tested in Zelda) has a bug [1] where the callbacks for
    // playlist_event_wait_any are mixed up, so that the response is
    // for a different playlist than the one that was requested.
    // By updating the live model for the URI in the event, and then
    // listen again for that model, we will update the correct models.
    // This should be removed when the bug is fixed. However, nothing
    // will break if it's still there.
    //
    // [1] https://jira.spotify.net/browse/KM-1241
    var eventModel = event && event.data.uri ? live(event.data.uri) : model;
    if (error) {
      setTimeout(function () {
        bridgeWaitAny(eventModel);
      }, BACKOFF);
      if (global.console) console.error(error);
      return;
    }

    if (event.type === 'change') {
      event.data.isFollowing = event.data.subscribed;
      event.data.added = event.data.subscribed;
      eventModel.update(event.data);
    }

    bridgeWaitAny(eventModel);
  });
}

function bridgeWait(model) {
  bridgeRequest('playlist_event_wait', [model.uri], function (error, event) {
    if (error) {
      // Hotfix 2014-10-20: We are matching temporary playlists with this model, and we're not sure
      // what the implications are if we wouldn't. For now we give up when we see a 'invalid-uri'
      // message
      if (error.name !== 'invalid-uri') {
        setTimeout(function () {
          bridgeWait(model);
        }, BACKOFF);
      }
      if (global.console) console.error(error);
      return;
    }

    // The only thing we need to care about here is 'change', other types like
    // 'insert', 'remove', 'move' aren't dealt with via bridge anymore.
    if (event.type === 'change') {
      model.update(event.data);
    }

    bridgeWait(model);
  });
}

function updateMetadata(model, needsImage) {
  bridgeRequest('playlist_metadata', [model.uri], function (error, payload) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }

    model.update(payload);

    // If the payload does not contain any images
    // we need to make a separate bridge request
    if (needsImage && !payload.images) {
      updateImage(model);
    }
  });
}

function updateImage(model) {
  bridgeRequest('playlist_profile', [model.uri], function (error, payload) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }
    if (!payload.image) payload.image = '';
    if (!payload.images) payload.images = [];
    model.update(payload);
  });
}

function updatePopularity(model) {
  bridgeRequest('playlist_popularity', [model.uri], function (error, payload) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }
    model.update(payload);
  });
}

function updateAnnotatedData(model) {
  var uriObject = liburi.from(model.uri);
  if (!uriObject || !uriObject.username || !uriObject.id) {
    debug('invalid uri for annotated data: %o', model.uri);
    model.update({ annotatedImage: null });
    return;
  }

  var encodedUsername = encodeURIComponent(uriObject.username);
  var playlistId = liburi.hexToId(uriObject.id);

  var url = interpolate('hm://playlist-annotate/v1/annotation/user/{username}/playlist/{id}', {
    username: encodedUsername,
    id: playlistId
  });

  cosmos.get({ url: url + '?format=json&bust=' + Date.now() }, function (error, response) {
    if (error) {
      model.update({
        annotatedImage: null
      });
      return;
    }

    var body = response.body;
    model.update({
      annotatedImage: body && body.picture || null
    });
  });
}

function onWait(model, properties) {
  var needsShouldBeOffline = contains(properties, 'shouldBeOffline');
  var needsOfflineStatus = contains(properties, 'offlineStatus');
  var needsOfflineProgress = contains(properties, 'offlineProgress');
  var needsPlayable = contains(properties, 'playable');
  var needsPopularity;
  var needsImage;
  var needsMetadata;
  var needsAnnotatedData;
  var needsFormatListType = contains(properties, 'formatListType');

  var metaFields = ['collaborative', 'subscribed', 'published', 'name', 'owner', 'description', 'allows'];

  properties.forEach(function (key) {
    if (key === 'popularity') needsPopularity = true;
    if (key === 'image' || key === 'images') {
      needsImage = true;
    }
    if (key === 'annotatedImage') {
      needsAnnotatedData = true;
    }
    if (!needsMetadata && contains(metaFields, key)) needsMetadata = true;
  });

  if (needsMetadata) updateMetadata(model, needsImage);else if (needsImage) updateImage(model);

  if (needsAnnotatedData) updateAnnotatedData(model);

  if (needsPopularity) updatePopularity(model);

  if (needsShouldBeOffline || needsOfflineProgress || needsOfflineStatus) updateOffline(model);

  if (needsPlayable) updateAndSubscribePlayable(model);

  if (needsFormatListType) updateFormatListType(model);
}

function onInit(model) {
  bridgeWait(model);
  if (global._getSpotifyModule) {
    bridgeWaitAny(model);
  }
}

function onPublish(model, properties) {
  // Only shouldBeOffline is handled here
  if (!properties.hasOwnProperty('shouldBeOffline')) {
    return;
  }

  live(CLIENT).query('session(capabilities(offlineSync))', function (error, data) {
    if (error && global.console) console.error(error);
    if (error || !data.session.capabilities.offlineSync) {
      sendCantOfflineMessage();
    } else {
      var shouldBeOfflineValue;

      if ('shouldBeOffline' in properties) shouldBeOfflineValue = !!properties.shouldBeOffline;

      if (shouldBeOfflineValue !== undefined) {
        // optimistic update, this gets reverted somewhere else
        updateModelWithOffline(model, { offline_availability: shouldBeOfflineValue ? 'yes' : 'no' });
        publishShouldBeOffline(model, shouldBeOfflineValue);
      }
    }
  }, live.ASAP);
}

function onUpdate(model, data) {
  if ('offlineStatus' in data) {
    var shouldBeOffline = model.get('shouldBeOffline');
    var isDownloading = data.offlineStatus === OFFLINE_STATUS.DOWNLOADING;
    var shouldSubscribe = shouldBeOffline && isDownloading;

    if (shouldSubscribe) {
      subscribeToOfflineProgress(model);
    } else {
      unsubscribeToOfflineProgress(model);
    }
  }
}

function updateOffline(model) {
  cosmos.subscribe({ url: 'sp://offline/v1/resources?uri=' + model.uri }, function (error, response) {

    if (!error) {
      var resource = response.body.resources;
      updateModelWithOffline(model, resource);
    } else {
      // Status -104 means 'No endpoint resolver that could handle the request was found'.
      // If that's the case, we try the old bridge offline messages, and if that's not supported,
      // we treat it like the client doesn't support offline.
      if (error.response && error.response.getStatusCode() === -104) {

        // Desktop detection using the C++ bridge function
        if (global._getSpotifyModule) {
          bridgeRequest('offline_query_state', [model.uri], function (error, data) {
            if (error) {
              if (global.console) console.error(error);
              return;
            }
            updateModelWithOffline(model, { offline_availability: data.enabled ? 'yes' : 'no' });
          });

          // Client doesn't support offline, so set the offline status to 'no'
        } else {
            updateModelWithOffline(model, { offline_availability: 'no' });
          }
      } else {
        if (global.console) console.error(error);
        return;
      }
    }
  });
}

function updateModelWithOffline(model, resource) {
  var shouldBeOffline = false;
  var progress;

  switch (resource.offline_availability) {
    case OFFLINE_STATUS.WAITING:
      shouldBeOffline = true;
      progress = 0;
      break;
    case OFFLINE_STATUS.DOWNLOADING:
      shouldBeOffline = true;
      break;
    case OFFLINE_STATUS.YES:
      shouldBeOffline = true;
      progress = 1;
      break;
    case OFFLINE_STATUS.NO:
      progress = 0;
      break;
  }

  // Updating this one will cause the 'update' event to start listening for
  // progress changes and update offlineProgress.
  model.update({
    shouldBeOffline: shouldBeOffline,
    offlineStatus: resource.offline_availability
  });

  if (progress !== undefined) {
    model.update({
      offlineProgress: progress
    });
  }
}

function updateAndSubscribePlayable(model) {
  // Todo: It would be nice to take the users cache state into account,
  // a ticket for that: KM-8283. 'playable' would then change meaning from
  // 'according to track metadata' to 'according to track metadata and cache
  // state when offline', but that can be seen as a progressive enhancement.
  var playableRows = endpoints['core-playlist'] + '/' + encodeURIComponent(model.uri) + '/metadata?&filter=playable%20eq%20true';
  cosmos.subscribe({
    url: playableRows,
    body: {
      policy: {
        length: true
      }
    }
  }, function (error, response) {
    if (!error) {
      model.update({ playable: !!response.body.metadata.length });
    } else {
      console.error(error);
    }
  });
}

function updateFormatListType(model) {
  var url = 'sp://core-playlist/v1/playlist/' + encodeURIComponent(model.uri) + '/metadata';

  cosmos.get({ url: url }, function (error, response) {
    var formatListType = 'playlist';
    if (!error && response.body && response.body.metadata && response.body.metadata.formatListType) {
      formatListType = response.body.metadata.formatListType;
    }
    model.update({
      formatListType: formatListType
    });
  });
}

function subscribeToOfflineProgress(model) {
  var subscription = offlineSubscriptions[model.uri];
  if (subscription) {
    return;
  }
  offlineSubscriptions[model.uri] = cosmos.subscribe({ url: 'sp://offline/v1/progress?uri=' + model.uri }, function (error, response) {

    if (!error) {
      var progress = response.body.progress;
      model.update({ offlineProgress: progress.percent_complete / 100 || 0 });

      // unsubscribe to offline progress messages when the download is complete
      // (sometimes after a complete download we receive a progress event of 0)
      if (progress.percent_complete === 100) {
        unsubscribeToOfflineProgress(model);
      }
    } else {
      // Status -104 means 'No endpoint resolver that could handle the request was found'.
      // If that's the case, we try the old bridge offline messages, and if that's not supported,
      // we treat it like the client doesn't support offline.
      if (error.response && error.response.getStatusCode() === -104) {

        // Desktop detection using the C++ bridge function
        if (global._getSpotifyModule) {
          bridgeRequest('offline_query_state', [model.uri], function (error, data) {
            if (error) {
              if (global.console) console.error(error);
              return;
            }
            model.update({ offlineProgress: data.enabled ? 1 : 0 });
          });

          // Client doesn't support offline, so set the offline status to 'no'
        } else {
            model.update({ offlineProgress: 0 });
          }
      } else {
        if (global.console) console.error(error);
        return;
      }
    }
  });
}

function unsubscribeToOfflineProgress(model) {
  var subscription = offlineSubscriptions[model.uri];
  if (!subscription) {
    return;
  }

  subscription.cancel();
  delete offlineSubscriptions[model.uri];
}

function publishShouldBeOffline(model, enabled) {
  var method = enabled ? 'post' : 'delete';
  cosmos[method]({ url: 'sp://offline/v1/resources?uri=' + model.uri }, function (error, response) {

    if (error) {
      // Status -104 means 'No endpoint resolver that could handle the request was found'.
      // If that's the case, we try the old bridge offline messages, and if that's not supported,
      // we treat it like the client doesn't support offline.
      if (error.response && error.response.getStatusCode() === -104) {

        // Desktop detection using the C++ bridge function
        if (global._getSpotifyModule) {
          var message = enabled ? 'offline_enable_sync' : 'offline_disable_sync';
          bridgeRequest(message, [model.uri], function (error, data) {

            // Revert the state if it failed
            if (error) {
              updateModelWithOffline(model, {
                offline_availability: enabled ? 'no' : 'yes'
              });
            }
          });

          // Client doesn't support offline, so set the offline status to 'no'
        } else {
            updateModelWithOffline(model, {
              offline_availability: enabled ? 'no' : 'yes'
            });
          }
      } else {
        updateModelWithOffline(model, {
          offline_availability: enabled ? 'no' : 'yes'
        });
      }
    }
  });
}

function sendCantOfflineMessage() {
  cosmos.post({
    url: 'sp://messages/v1/container/user-message',
    body: {
      id: 'cant-offline-playlists'
    }
  });
}

var regExp = exports.matches = /^spotify:user:(.*):playlist|^spotify:internal:temp_playlist:|^spotify:temp-playlist:/;
var broadcastSubscription;
var registered;
exports.register = function () {
  if (registered) return;
  registered = true;

  live.subscribe(regExp, 'wait', onWait);
  live.subscribe(regExp, 'init', onInit);
  live.subscribe(regExp, 'publish', onPublish);
  live.subscribe(regExp, 'update', onUpdate);

  broadcastSubscription = cosmos.subscribe({ url: endpoints.broadcast }, onBroadcast);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  live.unsubscribe(regExp, 'wait', onWait);
  live.unsubscribe(regExp, 'init', onInit);
  live.unsubscribe(regExp, 'publish', onPublish);
  live.unsubscribe(regExp, 'update', onUpdate);

  broadcastSubscription.cancel();
  broadcastSubscription = null;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-live":212,"./util/bridge":206,"./util/cosmos":208,"debug":287,"interpolate":321,"mout/array/contains":323,"mout/array/intersection":332,"mout/object/mixIn":364,"spotify-liburi":398}],188:[function(require,module,exports){
(function (global){
/**
 * @module spotify-live-models/session-storage
 */
'use strict';

var forOwn = require('mout/object/forOwn');
var combine = require('mout/array/combine');
var remove = require('mout/array/remove');
var contains = require('mout/array/contains');

var URI = 'spotify:session-storage';
var live = require('../spotify-live');
var cosmos = require('./util/cosmos');
var endpoints = {
  broadcast: 'sp://messages/v1/session-storage'
};

var waiting = [];

function onInit(model) {
  // Set a flag for showing that the model has been implemented and
  // registered. This is so that we can check this in player without
  // making a breaking change.
  model.update({ implemented: true });
}

function onWait(model, properties) {
  // Ask the top frame to broadcast the properties.
  // Values will be null when they weren't stored.
  waiting = combine(waiting, properties);
  global.top.postMessage({
    type: 'session_storage',
    name: 'broadcast_session_storage',
    data: properties
  }, '*');
}

function onPublish(model, properties) {
  // Tell the top frame to persist and broadcast
  global.top.postMessage({
    type: 'session_storage',
    name: 'set_session_storage',
    data: properties
  }, '*');

  // Optimistic update
  model.update(properties);
}

function onBroadcast(error, event) {
  var update = {};
  var model = live(URI);

  forOwn(event.body, function (value, key) {

    // Update model if this instance of storage knows that the model waits for it
    var isWaiting = contains(waiting, key);

    // Or if the model has a potentially outdated value in the live cache
    var hasKey = model.get(key) !== undefined;

    if (isWaiting || hasKey) update[key] = value;
    if (isWaiting) remove(waiting, key);
  });
  model.update(update);
}

var broadcastSubscription;
var regExp = exports.matches = new RegExp('^' + URI + '$');
var registered;

exports.register = function () {
  if (registered) return;
  registered = true;

  live.subscribe(regExp, 'init', onInit);
  live.subscribe(regExp, 'wait', onWait);
  live.subscribe(regExp, 'publish', onPublish);
  broadcastSubscription = cosmos.subscribe({ url: endpoints.broadcast }, onBroadcast);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  live.unsubscribe(regExp, 'init', onInit);
  live.unsubscribe(regExp, 'wait', onWait);
  live.unsubscribe(regExp, 'publish', onPublish);

  if (broadcastSubscription) {
    broadcastSubscription.cancel();
    broadcastSubscription = null;
  }
  waiting.length = 0;
};

exports._endpoints = endpoints;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-live":212,"./util/cosmos":208,"mout/array/combine":322,"mout/array/contains":323,"mout/array/remove":334,"mout/object/forOwn":360}],189:[function(require,module,exports){
"use strict";

/**
 * This module splits up a list into many chunks.
 *
 * @module spotify-live-models/sorting/chunker
 * @private
 */

/**
 * Splits up an array of data into smaller chunks.
 *
 * @param {Array} list The array to be split up.
 * @param {number=} opt_size Optional size of each chunk.
 *
 * @return {Array} Array of chunks, where each chunk is an array of data.
 */
module.exports = function (list, opt_size) {

  function split(array, segments) {
    segments = segments || 2;
    var results = [];
    if (array == null) {
      return results;
    }

    var minLength = Math.floor(array.length / segments);
    var remainder = array.length % segments;
    var i = 0;
    var len = array.length;
    var segmentIndex = 0;
    var segmentLength;

    while (i < len) {
      segmentLength = minLength;
      if (segmentIndex < remainder) {
        segmentLength++;
      }

      results.push(array.slice(i, i + segmentLength));

      segmentIndex++;
      i += segmentLength;
    }

    return results;
  }

  var size = opt_size || 50;
  var chunkCount = Math.ceil(list.length / size);
  var chunks = split(list, chunkCount);

  return chunks;
};

},{}],190:[function(require,module,exports){
/**
 * This file contains transformations from legacy sort queries to new sort
 * queries. We need this because when a user sorts by a certain column, we store
 * the full URI for that list and the sort query is part of the URI. Whenever
 * we change the sort query of a column, we will break sorting for users who
 * have a stored sort state with the old query. That's why we need to maintain
 * this conversion from old to new to make the right list load for all users.
 *
 * When to remove a conversion needs to be weighed case by case I guess. If a
 * user sorts by a certain column and doesn't launch the client for three months
 * and we change the query during that time, it's expected to still work for
 * that user when logging in the next time.
 *
 * History of this file is in the play-desktop app,
 * https://ghe.spotify.net/zelda/client-zelda-js/blob/master/apps/playlist-desktop/src/legacy-sort-uris.js
 */
'use strict';

exports.legacyQueries = {
  // Change date: 2015-03-16
  'track(album(name))': 'track(album(name),disc,number)',
  // Change date: 2015-03-16
  'track(artists(name))': 'track(artists[0:1](name),album(name),disc,number)',
  // Change date: 2015-03-17, value changed 2015-07-14 because we introduced the conversion below.
  'track(addedBy)': 'addedBy(name)',
  // Change date: 2015-07-14
  'track(addedBy(name))': 'addedBy(name)',
  // Change date: 2015-06-26
  'timeSinceAdded': 'timeSinceAdded,track(album(name),disc,number)'
};

},{}],191:[function(require,module,exports){
'use strict';

/**
 * This module helps posting chunked data to/from a worker.
 *
 * @module spotify-live-models/sorting/poster
 * @private
 */

/**
 * Posts data from/to a worker.
 *
 * @param {Object} worker A web worker.
 * @param {Array} chunks Array of split up data.
 * @param {number} index Index of the current chunk to post. Initiate the
 *     poster with 0, and it posts all data sequentially until all data
 *     is posted.
 * @param {string} id An ID for the full payload.
 */
module.exports = function poster(worker, chunks, index, id) {
  'use strict';

  var data = {
    items: chunks[index],
    id: id
  };

  if (index === chunks.length - 1) {
    data.last = true;
  }

  worker.postMessage(data);

  if (!data.last) {
    poster(worker, chunks, index + 1, id);
  }
};

},{}],192:[function(require,module,exports){
(function (global){
'use strict';

/**
 * This module sorts an array of data in the best possible way.
 * If Web Workers are supported, it will spawn new workers and
 * sort on different threads to speed it up.
 *
 * @module spotify-live-models/sorting/sort
 * @private
 */

var chunker = require('./chunker');
var poster = require('./poster');
var sorter = require('./sorter');
var sortWorker = require('./sortworker');
var defer = require('prime/defer');

var workerFile;
var workers = {};
var callbacks = {};
var waitingForReset = {};

// A generated ID will be stored here for each sorted list. Whenever a sorted
// list is asked to resort, a new ID will be generated and set here for that
// list. That allows us to cancel a previous sort if a newer one has started
// before the old one finished.
var idCounter = 0;
var lastIds = {};

/**
 * The local sorter that sorts on the main thread.
 *
 * @param {string} sortUri URI of the sorted list.
 * @param {Array.<Object>} items Array of items to sort. Each item is
 *     an object with the properties `data` and `key`. The `data`
 *     property is an array of values to sort on. The `key` property
 *     is a string for the row ID.
 * @param {Function} callback Async callback where the data is the array of
 *     sorted items.
*/
function localSorter(sortUri, items, callback) {
  items = sorter(items);

  // Saving the callback as the latest callback for this sorted list
  // will allow us to only respond with the latest sorted values (if
  // multiple sort calls were made at the same time).
  callbacks[sortUri] = callback;

  // Make the callback async
  defer(function () {

    // Only allow the latest callback to run
    if (callback === callbacks[sortUri]) {
      delete callbacks[sortUri];

      callback(null, items);
    }
  });
}

/**
 * The Web Worker sorter.
 *
 * @param {string} sortUri URI of the sorted list.
 * @param {Array.<Object>} items Array of items to sort. Each item is
 *     an object with the properties `data` and `key`. The `data`
 *     property is an array of values to sort on. The `key` property
 *     is a string for the row ID.
 * @param {Function} callback Async callback where the data is the array of
 *     sorted items.
 */
function workerSorter(sortUri, items, callback) {
  var worker = workers[sortUri];

  // If we already have a worker for this sorted list, reset that worker
  // and tell it to sort the new data. By saving the callback we make sure
  // that the original worker event handler will run the latest callback
  // when the sorting is done.
  if (worker) {
    callbacks[sortUri] = callback;
    waitingForReset[sortUri] = (waitingForReset[sortUri] || 0) + 1;
    var id = (++idCounter).toString(36);
    lastIds[sortUri] = id;
    worker.postMessage({ reset: true, newId: id });
    sendItemsToWorker(items, worker, id);
    return;
  }

  worker = new Worker(workerFile);
  workers[sortUri] = worker;
  callbacks[sortUri] = callback;

  var id = (++idCounter).toString(36);
  lastIds[sortUri] = id;
  sendItemsToWorker(items, worker, id);

  var result = { items: [] };

  worker.addEventListener('message', function (event) {
    onWorkerMessage(event, result, sortUri);
  }, false);
}

/**
 * Event handler for receiving a message from a worker.
 * This will handle collecting all chunks of data and post it to the latest
 * callback when all chunks have been received.
 *
 * @param {Event} event An event object from the worker 'message' event.
 * @param {Object} result An object with a property `items` for the sorted items.
 * @param {string} sortUri The sort URI for the current sort.
 */
function onWorkerMessage(event, result, sortUri) {

  // When the main thread tells the worker to reset, the worker will respond with
  // a message to reset the array of already sorted items.
  if (event.data.reset) {
    waitingForReset[sortUri]--;
    result.items.length = 0;
    return;
  }

  // Skip messages that don't belong to the latest sort
  if (event.data.id !== lastIds[sortUri]) {
    return;
  }

  // If we are still waiting for reset messages, don't continue to add more items
  // to the list of sorted items.
  if (waitingForReset[sortUri]) {
    return;
  }

  // If we are not waiting for any resets, just save the chunk of sorted items.
  result.items = result.items.concat(event.data.items);

  // When all data has been passed over from the worker, kill the worker and run
  // the latest registered callback for this sorted list.
  if (event.data.last) {
    workers[sortUri].terminate();

    var callback = callbacks[sortUri];
    delete callbacks[sortUri];
    delete workers[sortUri];

    callback(null, result.items);
  }
}

/**
 * Create the Web Worker file path.
 * Since the worker can't share objects with the main thead, we can't share
 * dependencies. To solve this, we convert the dependencies to strings and pass
 * them as arguments to the worker file.
 * To circumvent the need of a separate file for the worker, we make the worker
 * itself and the passed dependencies a single string and make a blob out of it.
 * From the blob we can get a URL that we can pass to the worker constructor.
 *
 * @return {string} Blob URL that can be passed to the worker.
 */
function createWorkerFile() {
  var workerStr = sortWorker.toString();
  var sortStr = sorter.toString();
  var chunkerStr = chunker.toString();
  var posterStr = poster.toString();
  var argsStr = [sortStr, chunkerStr, posterStr].join(', ');
  var stringWorker = '(' + workerStr + ')(' + argsStr + ')';

  var blob = new Blob([stringWorker], { type: 'text/javascript' });
  var url = URL.createObjectURL(blob);

  return url;
}

/**
 * Send the provided items to the provided worker. It will do this by splitting
 * the items into chunks and sending the chunks.
 *
 * @param {Array} items An array of items.
 * @param {Worker} worker A worker instance.
 * @param {string} id The ID for the payload.
 */
function sendItemsToWorker(data, worker, id) {
  var chunks = chunker(data);
  poster(worker, chunks, 0, id);
}

/**
 * Get the sort function to use.
 * If Web Workers are supported, it will use that, otherwise it will use the
 * default sorter on the main thread.
 * Having the code in a function allows for testing where worker support can
 * be removed and added while running the tests.
 *
 * @return {Function} The sorter function.
 */
function getSorter() {
  if (global.Worker && global.Blob && global.URL) {
    if (!workerFile) {
      workerFile = createWorkerFile();
    }
    return workerSorter;
  } else {
    return localSorter;
  }
}

/**
 * Sort the data using the best supported method.
 *
 * @param {string} sortUri URI of the sorted list.
 * @param {Array.<Object>} items Array of items to sort. Each item is
 *     an object with the properties `data` and `key`. The `data`
 *     property is an array of values to sort on. The `key` property
 *     is a string for the row ID.
 * @param {Function} callback Async callback where the data is the array of
 *     sorted items.
 */
module.exports = function (sortUri, items, callback) {
  var sort = getSorter();
  sort(sortUri, items, callback);
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./chunker":189,"./poster":191,"./sorter":193,"./sortworker":194,"prime/defer":373}],193:[function(require,module,exports){
'use strict';

/**
 * This module sorts an array of data.
 *
 * @module spotify-live-models/sorting/sorter
 * @private
 */

/**
 * Sorts an array of data. Supports multiple levels of values
 * (if two items are the same, it tests the values in the next level).
 *
 * @param {Array.<Object>} data Array of items to sort. Each item is
 *     an object with the properties `data` and `key`. The `data`
 *     property is an array of values to sort on. The `key` property
 *     is a string for the row ID.
 *
 * @return {Array.<Object>} A new array of the same objects that were
 *     passed in, but sorted.
 */
module.exports = function (data) {
  'use strict';

  data.sort(function (a, b) {

    var length = a.data.length;

    for (var i = 0; i < length; i++) {
      var aValue = a.data[i];
      var bValue = b.data[i];

      var aNumber = parseInt(aValue, 10);
      var bNumber = parseInt(bValue, 10);

      var aStartsWithNumber = !isNaN(aNumber);
      var bStartsWithNumber = !isNaN(bNumber);

      if (aStartsWithNumber && bStartsWithNumber) {
        if (aNumber < bNumber) return -1;
        if (aNumber > bNumber) return 1;
      } else if (aStartsWithNumber) {
        return -1;
      } else if (bStartsWithNumber) {
        return 1;
      }

      if (aValue.localeCompare) {
        var value = aValue.localeCompare(bValue);
        if (value !== 0) return value;
      } else {
        if (aValue < bValue) return -1;
        if (aValue > bValue) return 1;
      }
    }
  });

  return data;
};

},{}],194:[function(require,module,exports){
'use strict';

/**
 * This is the Web Worker file that sorts the data and passes it back again.
 * The file cannot be passed directly to new Worker(), as it needs some
 * dependencies. These dependencies are required before creating the worker,
 * and then serialized together with this file into a single blob, which is
 * used to create the worker.
 *
 * @module spotify-live-models/sorting/sortworker
 * @private
 */

/**
 * Sort worker.
 *
 * @param {Function} sort Function that sorts an array of data based on a
 *     property.
 * @param {Function} chunk Function that splits up data into chunks.
 * @param {Function} post Function that posts chunks of data back to main
 *     thread.
 * @param {Object} opt_worker Optional worker instance (mainly for testability).
 */
module.exports = function (sort, chunk, post, opt_worker) {
  'use strict';

  var worker = opt_worker || self;

  var itemsToSort = [];
  var id = null;

  worker.addEventListener('message', function (event) {

    // When the main thread tells the worker to reset, the worker will respond with
    // a message to reset the array of already sorted items.
    if (event.data.reset) {
      itemsToSort.length = 0;
      id = event.data.newId;
      worker.postMessage({ reset: true, newId: id });
      return;
    }

    // Only set the stored id for the first message
    if (id === null) {
      id = event.data.id;
    }

    // If the event id does not match the stored id, don't do anything.
    // This allows a sort to be aborted in the middle.
    if (id !== event.data.id) {
      return;
    }

    itemsToSort = itemsToSort.concat(event.data.items);

    if (event.data.last) {
      var sortedItems = sort(itemsToSort);
      var chunks = chunk(sortedItems);
      post(worker, chunks, 0, id);
    }
  }, false);
};

},{}],195:[function(require,module,exports){
'use strict';

/**
 * Get the row values used for sorting.
 *
 * @module spotify-live-models/sorting/values
 * @private
 */

/**
 * Get the values from the row based on the passed mask.
 * String values will be sanitized (lowercase, removing articles like 'the' etc).
 * The values can then be used for sorting.
 *
 * @param {Object} mask A mask object from the query parser.
 * @param {Object} row Row data object.
 *
 * @return {Array>} Array of values to sort on.
 *
 * @example
 * var parse = require('../../spotify-live/util/parser');
 * var mask = parse('track(name), track(artists(name))').mask;
 * var row = {track: {name: 'Track', artists: [{name: 'Artist'}]}};
 * var values = getValues(mask, row);
 * console.log(values);
 * // ['track', 'artist']
 */
function getValues(mask, row) {
  var result = [];
  mask.forEach(function (m) {
    var k = m.key;
    var value = row[k];

    // If the value is an array, we will concatenate all the
    // values with a comma in between, so that sorting takes
    // all values into account. An example is sorting tracks
    // based on 'artists(name)', where there can be many
    // artists for a track. We will in that case concatenate
    // all artists with comma in between and use a string with
    // all the artists when we compare in the sort function.
    if (Array.isArray(value)) {
      if (m.mask) {
        var values = [];
        for (var i = 0, l = value.length; i < l; i++) {
          values = values.concat(getValues(m.mask, value[i]));
        }
        result.push(values.join(', '));
      } else {
        result.push(value.join(', '));
      }
    } else {
      if (m.mask) result.push.apply(result, getValues(m.mask, value));else result.push(value);
    }
  });

  result = sanitizeStrings(result);

  return result;
}

/**
 * Sanitize string values. This includes trimming whitespace, converting
 * the string to lower case and removing common articles like 'the'.
 *
 * @param {Array} values Array of values.
 *
 * @return {Array} A new array of sanitized values.
 */
function sanitizeStrings(values) {
  var numberRe = /\b[0-9]+\b/g;
  var pad = '000000';

  return values.map(function (value) {
    if (typeof value !== 'string') return value;

    value = value.toLowerCase();

    // Remove the first article
    var articles = ['the ', '(the) '];
    for (var i = 0, article; article = articles[i]; i++) {
      if (value.indexOf(article) === 0) {
        value = value.replace(article, '');
        break;
      }
    }

    // Zero-pad numbers for natural numeric sorting (i.e. 2 before 10)
    value = value.replace(numberRe, function (match) {
      if (match.length >= pad.length) return match;
      return pad.substr(0, pad.length - match.length) + match;
    });

    return value.trim();
  });
}

module.exports = getValues;

},{}],196:[function(require,module,exports){
(function (global){
/**
 * @module spotify-live-models/sortlist
 */
'use strict';

var live = require('../spotify-live');
var mixIn = require('mout/object/mixIn');

var Range = require('../spotify-range2');
var diff = require('../spotify-live/util/diff');
var parse = require('../spotify-live/util/parser');
var sortUriUtils = require('../spotify-live-sort-uri');
var listOperations = require('spotify-live-list-operations');

var sort = require('./sorting/sort');
var getValues = require('./sorting/values');

// A generated ID will be stored here for each sorted list. Whenever a sorted
// list is asked to resort, a new ID will be generated and set here for that
// list. That allows us to cancel a previous sort if a newer one has started
// before the old one finished.
var idCounter = 0;
var lastIds = {};

/**
 * Event handler for the live 'init' event on sorted models. Keeps sorted model
 * and tracking model in sync (properties, not rows).
 *
 * This will set up an update listener for the tracking model, so that any
 * changes to the tracking model are also applied to the sort model.
 *
 * This also sets up a publish listener for the sorted model, so that anything
 * that is published on the sorted model gets published on the tracking model,
 * which can then update backend with the data and then update the tracking
 * model with the correct data, which will then trickle back down to the
 * sorted model.
 *
 * @param {LiveObject} sortModel The sorted live model.
 */
function onInit(sortModel) {
  var trackingModel = getTrackingModel(sortModel.uri);

  lastIds[sortModel.uri] = (++idCounter).toString(36);

  // Update the sorted model when any property on the tracking model changes (except rows)
  trackingModel.on('update', function (properties) {
    var updateObject = mixIn({}, properties);
    delete updateObject.rows;
    sortModel.update(updateObject);
  });

  // Update the tracking model when any property on the sort model changes (except rows)
  sortModel.on('publish', function (properties) {
    var updateObject = mixIn({}, properties);
    delete updateObject.rows;
    trackingModel.publish(updateObject);
  });
}

/**
 * Event handler for the live 'wait' event on sorted models.
 * This will fetch any requested property from the tracking model, or if
 * rows are requested, it will perform a sort of the rows from the tracking
 * model.
 *
 * It will also listen for changes. If a change is published on the sorted list,
 * it will be republished on the tracking list. When the tracking list is updated
 * with the new data (maybe after a save on the backend), the sorted list will be
 * updated and resorted if needed.
 *
 * @param {LiveObject} sortModel The sorted live model.
 * @param {Array} properties Array of properties that the model is waiting for.
 */
function onWait(sortModel, properties) {
  var trackingModel = getTrackingModel(sortModel.uri);

  properties.forEach(function (key) {

    // Requesting rows will create a live list of rows, perform sorting,
    // fill the list with the sorted items and also start to listen for changes.
    if (key === 'rows') {
      setRowsProperty(sortModel, trackingModel);

      // Requesting any other property than rows will just get that property from
      // the tracking model.
    } else {
        trackingModel.get(key, function (error, value) {
          if (error) {
            if (global.console) console.error(error);
            return;
          }
          var obj = {};
          obj[key] = value;
          sortModel.update(obj);
        });
      }
  });
}

/**
 * Set the `rows` property on the sort model. It will create a new live list
 * and perform sorting based on the rows of the tracking model. It will also
 * set up listeners for any changes to the lists to automatically keep
 * everything in sync.
 *
 * @param {LiveObject} sortModel The live object for the sorted list.
 * @param {LiveObject} trackingModel The live object for the list the sorted
 *     list is tracking.
 */
function setRowsProperty(sortModel, trackingModel) {
  var sortParams = sortUriUtils.parse(sortModel.uri);
  var direction = sortParams.direction;
  var query = sortParams.query;

  // Start the first sort
  performRowSorting(trackingModel, sortModel, query, direction);

  // Whenever a publish call happens on the sorted list, publish it to the
  // tracking list.
  sortModel.get('rows', function (error, sortList) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }
    sortList.on('publish', function (operations) {
      var trackingList = trackingModel.get('rows');
      if (!trackingList) return;
      syncRows(trackingList, operations, 'publish');
    });
  });

  // We need to get the rows list of the tracking model to be able to know the
  // length of the list, so that we can create the rows list for the sorted list.
  trackingModel.get('rows', function (error, trackingList) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }

    // Listen for updates on the tracking list and apply the changes (and
    // maybe resort if needed) on the sorted list.
    trackingList.on('update', function (operations) {
      var sortList = sortModel.get('rows');
      if (!sortList) return;
      var mustSort = syncRows(sortList, operations, 'update');
      if (mustSort) performRowSorting(trackingModel, sortModel, query, direction);
    });
  });
}

/**
 * Get the tracking model for a sort URI.
 * For an ascending sort URI, the tracking model would be the original list.
 * For a descending sort URI, the tracking model would be the ascending sort list.
 *
 * @param {string} sortUri The sort URI.
 *
 * @return {LiveObject} The live object for the tracking model.
 */
function getTrackingModel(sortUri) {
  var parsed = sortUriUtils.parse(sortUri);
  var direction = parsed.direction;
  var originUri = parsed.originUri;
  var query = parsed.query;

  // We can use the sorting from the ascending list when requesting the
  // descending list, by just depending on the ascending list. Asking for
  // data from the ascending list will make that list ask for the data
  // from the original list and then sort it, and then the descending list
  // will reverse that.
  if (direction === 'desc') {
    return live(sortUriUtils.create(originUri, 'asc', query));
  } else {
    return live(originUri);
  }
}

/**
 * Get data that is needed for performing a sort.
 *
 * @param {Array.<Object>} rows Array of objects of metadata about the rows.
 * @param {Object} mask A mask object from the query parser.
 * @param {LiveList} trackingList The live list for the list the sorted
 *     list is tracking.
 *
 * @return {Array.<Object>} A new array of items used for sorting. Each item is
 *     an object with the properties `data` and `key`. The `data`
 *     property is an array of values to sort on. The `key` property
 *     is a string for the row ID.
 *
 * @example
 * {
 *   data: ['Name of Song', 'Whatever', 100, 0],
 *   key: '0'
 * }
 */
function getSortData(rows, mask, trackingList) {
  return rows.map(function (row, i) {
    var array = getValues(mask, row);
    array.push(i);
    return { data: array, key: trackingList.keys[i] };
  });
}

/**
 * Perform sorting of all rows in a list.
 *
 * @param {LiveObject} trackingModel The model that the sort model is tracking.
 *     For ascending lists, this is the original model. For descending lists,
 *     this is the ascending sort model.
 * @param {LiveObject} sortModel The model to perform the sort on.
 * @param {string} sortQuery The sort query (live compatible query).
 * @param {string} sortDirection The sort direction ('asc' or 'desc').
 */
function performRowSorting(trackingModel, sortModel, sortQuery, sortDirection) {
  lastIds[sortModel.uri] = (++idCounter).toString(36);
  var sortId = lastIds[sortModel.uri];

  // Querying the rows of the tracking model might perform a sort. An example is when
  // getting the sort for a descending list, it will query the rows from the ascending
  // list, which will in turn query the rows from the original list and then perform a
  // sort. When the ascending sort is done, the query will be done and the descending
  // list can just use the ascending list and reverse it.
  trackingModel.get('rows', function (error, rows) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }

    // Create a list of loaded rows. This allows partial loading of a list,
    // and the sorted version will only contain the loaded rows.
    var rowsToSort = [];
    var keys = [];
    for (var i = 0, l = rows.length; i < l; i++) {
      if (rows.get(i)) {
        rowsToSort.push(rows.get(i));
        keys.push(rows.keys[i]);
      }
    }

    // Empty lists won't sort anyway, so quit here, but empty the sorted list
    // to make it up to date.
    if (rowsToSort.length === 0) {
      var sortList = sortModel.get('rows');
      if (sortList) {
        sortList.update([{
          type: 'remove',
          index: 0,
          length: sortList.length
        }]);
      } else {
        sortModel.update({ rows: [] });
      }
      return;
    }

    var partialTrackingList = live([]);

    partialTrackingList.update([{
      type: 'insert',
      index: 0,
      values: rowsToSort,
      keys: keys
    }]);

    // Now we have a list containing only the loaded rows
    partialTrackingList.query(sortQuery, function (error, rows) {
      if (error) {
        if (global.console) console.error(error);
        return;
      }

      // If direction is descending, the tracking model is ascending. Simply reverse that.
      if (sortDirection === 'desc') {
        updateListWithReversedData(sortModel, partialTrackingList);

        // For an ascending sort, perform a real sort.
      } else {

          var mask = parse(sortQuery).mask;
          var sortData = getSortData(rows, mask, partialTrackingList);

          sort(sortModel.uri, sortData, function (error, sortedData) {
            if (error) {
              if (global.console) console.error(error);
              return;
            }
            if (lastIds[sortModel.uri] !== sortId) return;
            updateListWithSortedData(sortModel, partialTrackingList, sortedData);
          });
        }
    });
  });
}

/**
 * Update the sorted live list with the right data after a sort.
 *
 * @param {LiveObject} sortModel The live object for the sorted list.
 * @param {LiveList} trackingList The live list for the list the sorted
 *     list is tracking.
 * @param {Array.<Object>} sortedItems Array of sorted items. Each item is
 *     an object with a property `key`, which is a string for the row ID.
 */
function updateListWithSortedData(sortModel, trackingList, sortedItems) {
  var sortList = sortModel.get('rows');

  // Copy the rows from the list that the sorted list is tracking,
  // if the sorted list has no tracks yet. Only for the first time.
  if (!sortList) {
    sortList = new live.List();
    sortModel.update({ rows: sortList });
  }

  var length = sortedItems.length;
  var keys = new Array(length);
  var values = new Array(length);

  for (var i = 0, l = sortedItems.length; i < l; i++) {
    keys[i] = sortedItems[i].key;
    values[i] = trackingList.valueOf(keys[i]);
  }

  sortList.update([{
    type: 'remove',
    index: 0,
    length: sortList.length
  }, {
    type: 'insert',
    index: 0,
    keys: keys,
    values: values
  }]);
}

/**
 * Update the sorted live list with the data of the list it is tracking,
 * but reversed.
 *
 * @param {LiveObject} sortModel The live object for the sorted list.
 * @param {LiveList} trackingList The live list for the list the sorted
 *     list is tracking.
 */
function updateListWithReversedData(sortModel, trackingList) {
  var sortList = sortModel.get('rows');

  if (!sortList) {
    sortList = new live.List();
    sortModel.update({ rows: sortList });
  }

  sortList.update([{
    type: 'remove',
    index: 0,
    length: sortList.length
  }, {
    type: 'insert',
    index: 0,
    length: trackingList.length,
    values: trackingList.values.slice().reverse(),
    keys: trackingList.keys.slice().reverse()
  }]);
}

/**
 * Converting the passed in operations to be relative to the list that was
 * passed in. Passing operations for a sorted list can convert the operations
 * to be used for the original list. This also updates (or publishes) the list
 * with the converted operations.
 *
 * @param {LiveList} rows The list to sync operations to.
 * @param {Array.<Object>} operations Array of operation objects.
 * @param {string} mode The mode for updates. 'update' or 'publish'.
 *
 * @return {boolean} True if a resort must happen after applying the operations.
 */
function syncRows(rows, operations, mode) {
  var mustSort = false;

  operations.forEach(function (operation) {
    var newOperations = [];

    switch (operation.type) {

      // If rows are removed from the tracking list, we can "simply" remove
      // the same rows from the sorted model.
      case 'remove':
        newOperations = convertRemoveOperationForList(rows, operation);
        break;

      // If rows are inserted in the tracking list, we must add the rows to
      // the sorted list and resort. Where we insert doesn't matter as we will
      // perform a new sort anyway.
      case 'insert':
        newOperations = [{
          type: 'insert', index: 0,
          values: operation.values, keys: operation.keys
        }];
        mustSort = true;
        break;

      // If rows are moved in the tracking list, we don't need to perform any
      // new moves directly, but we will need to perform a resort, as sorting
      // uses stable sort (falls back on index in original list if compared
      // values are the same).
      case 'move':
        mustSort = true;
        break;
    }

    if (mode === 'publish') {
      rows.publish(newOperations);
    } else if (mode === 'update') {
      rows.update(newOperations);
    }
  });

  return mustSort;
}

/**
 * Convert a remove operation from one list to an operation that can
 * be used in another list. An example is when we have an operation that
 * happened in the original list, we need to convert that to operations
 * that can be applied to the sorted list.
 *
 * @param {LiveList} list The live list to create the operations for.
 * @param {Object} operation The input 'remove' operation.
 *
 * @return {Array.<Object>} Array of remove operation objects.
 */
function convertRemoveOperationForList(list, operation) {
  var indices = [];
  var operationKeys = operation.keys;

  list.keys.forEach(function (key, i) {
    if (operationKeys.indexOf(key) > -1) indices.push(i);
  });

  return listOperations.getRemoveOperations(indices);
}

var regExp = exports.matches = /^spotify:internal:sortlist:(asc|desc):([^:]*):(.*)$/;

var registered = false;
exports.register = function () {
  if (registered) return;
  registered = true;

  live.subscribe(regExp, 'init', onInit);
  live.subscribe(regExp, 'wait', onWait);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  live.unsubscribe(regExp, 'init', onInit);
  live.unsubscribe(regExp, 'wait', onWait);
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-live":212,"../spotify-live-sort-uri":210,"../spotify-live/util/diff":213,"../spotify-live/util/parser":215,"../spotify-range2":251,"./sorting/sort":192,"./sorting/values":195,"mout/object/mixIn":364,"spotify-live-list-operations":399}],197:[function(require,module,exports){
'use strict';

/**
 * @module spotify-live-models/station
 */

var live = require('../spotify-live');

// Utilities
var trackToRow = require('./station/track-to-row');
var contains = require('mout/array/contains');
var spotifyURI = require('spotify-liburi');
var messageProxy = require('./station/station-message-proxy.js');
var thumbActions = require('./station/thumb-actions');

var appUri; // The app where this live model is being used.

var URI = exports.URI = 'spotify:station:';
var regExp = exports.matches = new RegExp('^' + URI + '(' + '((artist:|album:|track:)[a-zA-Z0-9]{22})' + '|' + '(user:[^:]+:' + '(playlist:[a-zA-Z0-9]{22}|top:tracks|toplist))' + '|' + '(user:[^:]+:cluster:[a-zA-Z0-9]{22})' + '|' + '(genre:[a-zA-Z0-9]*)' + ')');
exports.isStationUri = regExp.test.bind(regExp);

var DEFAULT_FETCH_COUNT = 15;

// Station Types
var PLAYLIST = 'playlist';
var TRACK = 'track';
var ALBUM = 'album';
var ARTIST = 'artist';
var GENRE = 'genre';
var CLUSTER = 'cluster';
var UNKNOWN = 'unknown';

var registered = false;
var queryReplySubscription;
var metadataUpdateSubscription;

var trackingRows = []; // A list of stations that need row updates.
var trackingMetadata = []; // A list of stations that need metadata updates.

/**
 * Get the station's base seed from the live model uri
 * @param {Object} model
 * @return {String}
 */
function getBaseSeedFromUri(model) {
  var seed = model.uri.replace(/^spotify:station:/, 'spotify:');
  return decodeURIComponent(seed);
}

/**
 * Get the station type
 * @param {String} seed
 * @return {String}
 */
function getType(seed) {
  var uri = spotifyURI.from(seed);
  if (!uri) {
    return UNKNOWN;
  }
  var contextType = uri.type;
  if (contextType === spotifyURI.Type.PLAYLIST) {
    return PLAYLIST;
  } else if (contextType === spotifyURI.Type.ARTIST) {
    return ARTIST;
  } else if (contextType === spotifyURI.Type.ALBUM) {
    return ALBUM;
  } else if (contextType === spotifyURI.Type.TRACK) {
    return TRACK;
  } else if (seed.indexOf('spotify:genre:') === 0) {
    return GENRE;
  } else if (seed.indexOf(':cluster:') > 0) {
    return CLUSTER;
  } else {
    return UNKNOWN;
  }
}

/**
 * Thumb up a track
 * @param {Object} model
 * @param {String} trackUID
 */
function onThumbUp(model, trackUri) {
  messageProxy.thumb({
    'stationUri': model.get('uri'),
    'trackUri': trackUri,
    'thumb': thumbActions.UP
  });
}

/**
 * Thumb down a track
 * @param {Object} model
 * @param {String} trackUID
 */
function onThumbDown(model, trackUri) {
  messageProxy.thumb({
    'stationUri': model.get('uri'),
    'trackUri': trackUri,
    'thumb': thumbActions.DOWN
  });
}

/**
 * Post a request for data from the container (station-manager in zlink).
 * @param {Object} model
 * @param {Array} properties
 * @param {Boolean} needsRows
 * @param {Integer} fetchCount
 */
function requestStationData(model, properties, needsRows, fetchCount) {
  var count = needsRows ? fetchCount || model.get('fetchCount') : false;
  messageProxy.request({
    'appUri': appUri,
    'stationUri': model.get('uri'),
    'metadata': properties,
    'trackCount': count
  });
}

/**
 * Get the appURI to compare against the referrerIdentifier from the player
 */
function getAppUri() {
  live('spotify:application').query('appURI', function (error, data) {
    if (!error) {
      appUri = data.appURI;
    }
  });
}

/**
 * Callback for rows wait event.
 * @param {Object} model
 * @param {Array} ranges
 */
function onRowsWait(model, ranges) {
  if (ranges && ranges.length > 0) {
    var fetchCount = 0;
    var largestTrack = 0;
    ranges.forEach(function (a) {
      if (a.end > largestTrack) {
        largestTrack = a.end;
      }
    });
    fetchCount = largestTrack - model.get('rows').length;
    requestStationData(model, [], true, fetchCount);
  }
}

/**
 * Subscriber for request reply messages
 * @param {Object} opts
 */
function onRequestReply(opts) {
  var sentAppUri = opts.appUri;
  var stationUri = opts.stationUri;
  var station = opts.station;
  if (sentAppUri === appUri) {
    if (station.hasOwnProperty('tracks')) {
      if (trackingRows.indexOf(stationUri) !== -1) {
        var timeStamp = new Date().getTime();
        station.rows = station.tracks.map(trackToRow.bind(null, timeStamp));
      }
      // Never keep a tracks object in the station (needs to be rows).
      delete station.tracks;
    }
    live(stationUri).update(station);
  }
}

/**
 * Subscriber for updateMetadata messages
 * @param {Object} opts
 */
function onUpdateMetadata(opts) {
  var stationUri = opts.stationUri;
  var metadata = opts.metadata;
  if (trackingMetadata.indexOf(stationUri) === -1) {
    return;
  }
  if (metadata.hasOwnProperty('tracks')) {
    if (trackingRows.indexOf(stationUri) !== -1) {
      var timeStamp = new Date().getTime();
      metadata.rows = metadata.tracks.map(trackToRow.bind(null, timeStamp));
    }
    // Never keep a tracks object in the station (needs to be rows).
    delete metadata.tracks;
  }
  live(stationUri).update(metadata);
}

/**
 * When the model intializes
 * @param {Object} model
 */
function onInit(model) {
  var baseSeed = getBaseSeedFromUri(model);
  if (!baseSeed) {
    return;
  }
  model.update({
    baseSeed: baseSeed,
    type: getType(baseSeed),
    added: false, // set this by default
    fetchCount: DEFAULT_FETCH_COUNT
  });
  model.on('update', function onModelUpdate(properties) {
    if (properties.hasOwnProperty('rows')) {
      model.get('rows').on('wait', onRowsWait.bind(null, model));
      model.off('update', onModelUpdate);
    }
  });
  trackingMetadata.push(model.get('uri'));
}

/**
 * Model publish listener
 * @param {Object} model station
 * @param {Object} properties
 */
function onPublish(model, properties) {
  if (properties.hasOwnProperty('added')) {
    var added = properties.added;
    if (typeof added === 'boolean') {
      model.update({ added: added });
      messageProxy.add({
        'stationUri': model.get('uri'),
        'add': added
      });
    } else {
      console.error('Added can only be a boolean');
    }
  }
}

/**
 * Unset props listener
 * @param {Object} model station
 * @param {Object} properties
 */
function onWait(model, properties) {
  var rowsIndex = -1;
  var needsMetadata;
  var metaFields = ['name', 'subtitle', 'relatedArtists', 'image', 'nextPageUrl'];

  properties.forEach(function (key, index) {
    if (key === 'rows') {
      rowsIndex = index;
    }
    if (!needsMetadata && contains(metaFields, key)) {
      needsMetadata = true;
    }
  });

  if (rowsIndex !== -1) {
    trackingRows.push(model.get('uri'));
    properties.splice(rowsIndex, 1);
    requestStationData(model, properties, true);
  } else if (needsMetadata) {
    requestStationData(model, properties);
  }
}

exports.register = function (stationMessageProxy) {
  if (registered) {
    return;
  }
  registered = true;

  // used only for testing
  if (stationMessageProxy) {
    messageProxy = stationMessageProxy;
  }

  live.subscribe(regExp, 'wait', onWait);
  live.subscribe(regExp, 'init', onInit);
  live.subscribe(regExp, 'thumb-up', onThumbUp);
  live.subscribe(regExp, 'thumb-down', onThumbDown);
  live.subscribe(regExp, 'publish', onPublish);
  queryReplySubscription = messageProxy.subscribeTo_requestReply(onRequestReply);
  metadataUpdateSubscription = messageProxy.subscribeTo_updateMetadata(onUpdateMetadata);
  getAppUri();
};

exports.unregister = function () {
  if (!registered) {
    return;
  }
  registered = false;

  live.unsubscribe(regExp, 'wait', onWait);
  live.unsubscribe(regExp, 'init', onInit);
  live.unsubscribe(regExp, 'thumb-up', onThumbUp);
  live.unsubscribe(regExp, 'thumb-down', onThumbDown);
  live.unsubscribe(regExp, 'publish', onPublish);
  queryReplySubscription.cancel();
  metadataUpdateSubscription.cancel();
  trackingRows = [];
  trackingMetadata = [];
};

},{"../spotify-live":212,"./station/station-message-proxy.js":201,"./station/thumb-actions":202,"./station/track-to-row":203,"mout/array/contains":323,"spotify-liburi":398}],198:[function(require,module,exports){
'use strict';

var rowToPlayerTrack = require('./row-to-player-track');

var PLAYER_RESTRICTIONS = {
  'disallow_toggling_repeat_context_reasons': ['disallow-radio'],
  'disallow_toggling_repeat_track_reasons': ['disallow-radio'],
  'disallow_toggling_shuffle_reasons': ['disallow-radio']
};

/**
 * Create an array of tracks formatted for the context player
 * @param {Object} model
 * @return {Array} tracks array
 */
function createPlayerTracks(model) {
  var rows = model.get('rows');
  if (!rows) {
    return [];
  }
  return rows.values.map(rowToPlayerTrack);
}

/**
 * Construct a context object for context-player
 * @param {Object} model station live model
 * @return {Object} context
 */
module.exports = function createPlayContext(model) {
  return {
    'entity_uri': model.get('uri'),
    'pages': [{
      'tracks': createPlayerTracks(model),
      'next_page_url': model.get('nextPageUrl')
    }],
    'metadata': {
      'context_description': model.get('name')
    },
    'restrictions': PLAYER_RESTRICTIONS
  };
};

},{"./row-to-player-track":200}],199:[function(require,module,exports){
'use strict';

var PLAYER_OPTIONS = {
  'shuffling_context': false,
  'repeating_context': false,
  'repeating_track': false
};

/**
 * This is neccesary because you dont get pages back from the context-player.
 * So if you want to resume a station with a set of rows (not pages)
 * you have to know the index of the last played row,
 * which you can get by comparing currentTrackUid with the row's Uid.
 * @param {Object} model station live model
 * @return {Int} index
 */
function getLastIndex(model) {
  var rows = model.get('rows');
  var currentTrackUid = model.get('currentTrackUid');

  if (!rows || !currentTrackUid) {
    return 0;
  }

  var currentIndex;

  var foundRow = rows.values.some(function (row, index) {
    if (row.get('uid') === currentTrackUid) {
      currentIndex = index;
      return true;
    }
  });

  return foundRow ? currentIndex : 0;
};

/**
 * Creates the context-player options for a station context
 * @param {Object} model station model
 * @param {Object} options optional
 * @return {Object} playOptions
 */
module.exports = function createPlayOptions(model, options) {
  if (options && (options.index || options.index === 0)) {
    var trackIndex = options.index;
  } else {
    var trackIndex = getLastIndex(model);
  }
  var playOptions = {
    'skip_to_index': {
      'page': 0,
      'track': trackIndex
    },
    'player_options_override': PLAYER_OPTIONS
  };
  if (options && options.uid) {
    playOptions.uid = options.uid;
  }
  return playOptions;
};

},{}],200:[function(require,module,exports){
'use strict';

/**
 * Converts a station row into a track for the context-player
 * @param {Object} row station row
 * @return {Object} track
 */

module.exports = function rowToPlayerTrack(row) {
  return {
    'uid': row.get('uid'),
    'uri': row.get('track').get('uri'),
    'album_uri': row.get('track').get('albumUri'),
    'artist_uri': row.get('track').get('artistUri'),
    'metadata': {
      'image_url': row.get('track').get('image'),
      'radio.thumb': row.get('thumb')
    }
  };
};

},{}],201:[function(require,module,exports){
'use strict';

/**
 * Station Message Proxy
 * This module is used to standarize the I/O of station messages
 * posted and subscribed by apps with stations. Mainly used to manage
 * the communication between apps and the station-manager in zlink.
 * For example: posting to the request message endpoint, certain object keys
 * are required, and when you add a subscriber
 * to that request endpoint, that function receives the same key/values.
 *
 * In the app:
 * stationMessageProxy.request({
 *  'appUri': 'spotfiy:app:stations',
 *  'stationUri': 'spotify:station:genre:rock',
 *  'metadata': true,
 *  'rowCount': 15
 * });
 *
 * In station-manager:
 * stationMessageProxy.subscribeTo_request(function(obj){
 *  obj.appUri // 'spotfiy:app:stations'
 *  obj.stationUri // 'spotify:station:genre:rock',
 *  obj.metadata // true
 *  obj.rowCount // 15
 * });
 */

var bridge = require('../../spotify-bridge-request');

// Message Uris
var baseUri = 'sp://messages/v1/station/';
var URIS = {
  ADD: baseUri + 'add',
  CREATE: baseUri + 'create',
  THUMB: baseUri + 'thumb',
  REQUEST: baseUri + 'request',
  REQUEST_REPLY: baseUri + 'request/reply',
  UPDATE_METADATA: baseUri + 'update/metadata',
  UPDATE_LAST_PLAYED: baseUri + 'update/lastPlayed',
  REQUEST_ALL: baseUri + 'request-all',
  REQUEST_ALL_REPLY: baseUri + 'request-all/reply',
  REQUEST_SAVED: baseUri + 'request-saved',
  REQUEST_SAVED_REPLY: baseUri + 'request-saved/reply'
};

// Module's Name
var NAME = 'station-message-proxy';

// Message Body Keys (the only valid keys that these proxy methods accept)
var KEY_APP_URI = 'appUri';
var KEY_STATION_URI = 'stationUri';
var KEY_METADATA = 'metadata';
var KEY_TRACK_COUNT = 'trackCount';
var KEY_STATION = 'station';
var KEY_ADD = 'add';
var KEY_THUMB = 'thumb';
var KEY_TRACK_URI = 'trackUri';
var KEY_SAVED_STATIONS = 'saved_stations';
var KEY_USER_STATIONS = 'user_stations';
var KEY_GENRE_STATIONS = 'genre_stations';
var KEY_RECOMMENDED_STATIONS = 'recommended_stations';
var KEY_CLUSTER_STATIONS = 'cluster_stations';
var KEY_CLUSTER_FORMAT_NAME = 'cluster_format_name';

/**
 * A hasmap of all the available methods you can call and 'subscribeTo'
 * and their required object keys.
 */
var API_METHODS = {
  'add': {
    'requiredKeys': [KEY_STATION_URI, KEY_ADD],
    'uri': URIS.ADD
  },
  'request': {
    'requiredKeys': [KEY_APP_URI, KEY_STATION_URI, KEY_METADATA, KEY_TRACK_COUNT],
    'uri': URIS.REQUEST
  },
  'requestReply': {
    'requiredKeys': [KEY_APP_URI, KEY_STATION_URI, KEY_STATION],
    'uri': URIS.REQUEST_REPLY
  },
  'updateMetadata': {
    'requiredKeys': [KEY_STATION_URI, KEY_METADATA],
    'uri': URIS.UPDATE_METADATA
  },
  'updateLastPlayed': {
    'requiredKeys': [KEY_STATION_URI],
    'uri': URIS.UPDATE_LAST_PLAYED
  },
  'thumb': {
    'requiredKeys': [KEY_STATION_URI, KEY_TRACK_URI, KEY_THUMB],
    'uri': URIS.THUMB
  },
  'requestAll': {
    'requiredKeys': [],
    'uri': URIS.REQUEST_ALL
  },
  'requestAllReply': {
    'requiredKeys': [KEY_CLUSTER_FORMAT_NAME, KEY_CLUSTER_STATIONS, KEY_USER_STATIONS, KEY_RECOMMENDED_STATIONS, KEY_GENRE_STATIONS],
    'uri': URIS.REQUEST_ALL_REPLY
  },
  'requestSaved': {
    'requiredKeys': [],
    'uri': URIS.REQUEST_SAVED
  },
  'requestSavedReply': {
    'requiredKeys': [KEY_SAVED_STATIONS],
    'uri': URIS.REQUEST_SAVED_REPLY
  }
};

function _cosmosError(fnName, error) {
  if (error) {
    console.error(NAME + ':' + fnName + ': ' + error);
  }
}

function _createSubscribeWrapper(fnName, subscriber) {
  return function wrapper(error, response) {
    if (error || !response || !response.body) {
      console.error(NAME + ':' + fnName + ' ', error);
      return;
    }
    var body;
    try {
      body = JSON.parse(response.body);
    } catch (e) {
      console.error(NAME + ':' + fnName + ': ' + e);
      return;
    }
    subscriber(body);
  };
}

function _subscribe(fnName, uri, subscriber) {
  if (typeof subscriber !== 'function') {
    throw new Error(NAME + ':' + fnName + ' needs a function.');
  }
  return bridge.cosmos({ method: 'SUB', uri: uri }, _createSubscribeWrapper('subscribeTo' + fnName, subscriber));
}

function _post(fnName, uri, requiredKeys, opts) {
  var body = {};
  requiredKeys.forEach(function (key) {
    if (!opts.hasOwnProperty(key)) {
      throw new Error(NAME + ':' + fnName + ':request missing keys: ' + requiredKeys);
    }
    body[key] = opts[key];
  });

  bridge.cosmos({ method: 'POST', uri: uri, body: JSON.stringify(body) }, _cosmosError.bind(null, 'request'));
}

var API = {};

Object.keys(API_METHODS).forEach(function (method) {
  API[method] = _post.bind(null, method, API_METHODS[method].uri, API_METHODS[method].requiredKeys);

  API['subscribeTo_' + method] = _subscribe.bind(null, method, API_METHODS[method].uri);
});

// Only for unit tests - do not use these directly
API.URIS = URIS;

module.exports = API;

},{"../../spotify-bridge-request":38}],202:[function(require,module,exports){
'use strict';

module.exports = {
  UP: 'ups',
  DOWN: 'downs'
};

},{}],203:[function(require,module,exports){
'use strict';

/**
 * Convert track objects coming from station-manager into a row.
 * @param {Object} track
 * @return {Object} row
 */

module.exports = function trackToRow(timeStamp, track, index) {
  var metadata = track.metadata || {};
  var artistUri = track.artist_uri || metadata.artist_uri;
  var albumUri = track.album_uri || metadata.album_uri;
  var uid = track.uid;

  if (!track.uid) {
    var id = track.uri.replace('spotify:track:', '');
    uid = timeStamp + id + index;
  }

  return {
    uid: uid,
    uri: uid,
    thumb: metadata['radio.thumb'] || '',
    track: {
      uri: track.uri,
      name: metadata.title,
      image: metadata.image_url,
      artistUri: artistUri,
      albumUri: albumUri,
      artists: [{ name: metadata.artist_name, uri: artistUri }],
      album: { name: metadata.album_title, uri: albumUri }
    }
  };
};

},{}],204:[function(require,module,exports){
(function (global){
/**
 * @module spotify-live-models/track
 */
'use strict';

var live = require('../spotify-live');
var liburi = require('spotify-liburi');
var intersection = require('mout/array/intersection');
var contains = require('mout/array/contains');
var bridge = require('./util/bridge').request;
var cosmos = require('./util/cosmos');
var util = require('./util/common');

var BACKOFF = 100;
var localFilesRequest = null;

var metaFields = ['album', 'artists', 'availability', 'disc', 'duration', 'explicit', 'image', 'local', 'name', 'number', 'placeholder', 'playable', 'popularity', 'linkedTrack'];

function onWait(model, properties) {
  // Set the 'unavailable' property based on the 'playable' property
  if (contains(properties, 'unavailable')) {
    model.get('playable', function (error, playable) {
      if (error) {
        if (global.console) console.error(error);
        return;
      }
      model.update({ unavailable: !playable });
    });
  }

  var hasMetadata = !!intersection(properties, metaFields).length;

  if (hasMetadata) updateMetadata(model);

  var needsShouldBeOffline = contains(properties, 'shouldBeOffline');
  var needsOfflineProgress = contains(properties, 'offlineProgress');
  if (needsShouldBeOffline || needsOfflineProgress) {
    updateOffline(model);
  }
}

function updateMetadata(model) {
  bridge('track_metadata', [model.uri], function (error, payload) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }
    util.setLocalProperties(payload);
    payload.image = largestImage(payload);

    // The linkedTrack is not available everywhere, so do fallback
    if (payload.linkedTrack) {
      payload.linkedTrack = { uri: payload.linkedTrack };
    } else {
      payload.linkedTrack = null;
    }

    model.update(payload);
  });
}

function largestImage(trackMetadata) {
  var imageURI = trackMetadata.image;
  var largestSize;

  if (trackMetadata.images) {
    for (var i = 0; i < trackMetadata.images.length; i++) {
      var currentImage = trackMetadata.images[i];
      if (!largestSize || currentImage[0] > largestSize) {
        largestSize = currentImage[0];
        imageURI = currentImage[1];
      }
    }
  }

  return imageURI;
}

function updateOffline(model) {

  // Local tracks are available offline if they are playable
  if (liburi.fromString(model.uri).type === liburi.Type.LOCAL) {
    model.get('playable', function (error, playable) {
      if (error) {
        if (global.console) console.error(error);
        return;
      }
      model.update({
        shouldBeOffline: playable,
        offlineProgress: playable ? 1 : 0
      });
    });
    return;
  }

  cosmos.subscribe({ url: 'sp://offline/v1/resources?uri=' + model.uri }, function (error, response) {

    if (!error) {
      var resource = response.body.resources;
      updateModelWithOfflineData(model, resource);
    } else {
      // Status -104 (or 404 in web player) means 'No endpoint resolver that could handle the request was found'.
      // If that's the case, we handle it like the client doesn't support offline.
      var statusCode = error.response && error.response.getStatusCode();
      if (statusCode === -104 || statusCode === 404) {
        updateModelWithOfflineData(model, { offline_availability: 'no' });
      } else {
        if (global.console) console.error(error);
        return;
      }
    }
  });
}

function updateModelWithOfflineData(model, resource) {
  var shouldBeOffline = false;
  var offlineProgress = 0;

  switch (resource.offline_availability) {
    case 'waiting':
      shouldBeOffline = true;offlineProgress = 0;break;
    case 'downloading':
      shouldBeOffline = true;offlineProgress = 0.5;break;
    case 'yes':
      shouldBeOffline = true;offlineProgress = 1;break;
  }

  model.update({
    shouldBeOffline: shouldBeOffline,
    offlineProgress: offlineProgress
  });
}

function waitForLocalFilesChange() {
  localFilesRequest = cosmos.subscribe({ url: 'sp://local-files/v1/changes' }, function (error, response) {
    if (!registered) return;

    if (error) {
      // Status -104 (or 404 in web player) means 'No endpoint resolver that could handle the request was found'.
      // If that's the case, we bail out and don't do anything.
      var statusCode = error.response && error.response.getStatusCode();
      if (statusCode === -104 || statusCode === 404) {
        return;
      }
      if (global.console) console.error(error);
      return;
    }

    var event = response.body;
    var data = event.data;
    var type = event.type;
    var isAdded = type === 'added';
    var isRemoved = type === 'removed';

    if (isAdded || isRemoved) {
      data.tracks.forEach(function (track) {
        live(track.uri).update({
          shouldBeOffline: isAdded,
          offlineProgress: isAdded ? 1 : 0,
          playable: isAdded
        });
      });
    }
  });
}

function waitForTrackChange() {
  bridge('track_event_wait_any', [], function (error, event) {
    if (!registered) return;

    if (error) {
      setTimeout(function () {
        waitForTrackChange();
      }, BACKOFF);
      if (global.console) console.error(error);
      return;
    }

    waitForTrackChange();

    if (event.type === 'change') {
      if (event.data.playable !== undefined) {
        event.data.unavailable = !event.data.playable;
      }
      live(event.data.uri).update(event.data);
    }
  });
}

var regExp = exports.matches = /^spotify:track:|^spotify:local:[^:]*:[^:]*:[^:]*:\d*$/;
var registered;
exports.register = function () {
  if (registered) return;
  registered = true;

  live.subscribe(regExp, 'wait', onWait);

  waitForLocalFilesChange();

  // Only desktop has support for track relinking
  if (!!global._getSpotifyModule) waitForTrackChange();
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  live.unsubscribe(regExp, 'wait', onWait);

  if (localFilesRequest) {
    localFilesRequest.cancel();
    localFilesRequest = null;
  }
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-live":212,"./util/bridge":206,"./util/common":207,"./util/cosmos":208,"mout/array/contains":323,"mout/array/intersection":332,"spotify-liburi":398}],205:[function(require,module,exports){
(function (global){
/**
 * @module spotify-live-models/user
 */
'use strict';

var live = require('../spotify-live');
var liburi = require('spotify-liburi');
var contains = require('mout/array/contains');
var intersection = require('mout/array/intersection');
var bridge = require('./util/bridge').request;

function updateMetadata(model) {
  bridge('user_metadata', [model.uri], function (error, payload) {
    if (error && global.console) console.error(error);

    if (!payload) payload = {};

    payload.username = payload.username || liburi.from(model.uri).username;
    payload.name = payload.name || payload.username;
    payload.image = payload.image || '';
    payload.images = payload.images || [];

    if (payload.subscribed == null) {
      payload.subscribed = false;
    }

    if (payload.currentUser == null) {
      live('spotify:client').query('currentUser(uri)', function (error, data) {
        if (error) {
          if (global.console) console.error(error);
          return;
        }
        model.update({ currentUser: model.uri === data.currentUser.uri });
      });
    }

    model.update(payload);
  });
}

function updateArtist(model) {
  bridge('user_associated_artist', [model.uri], function (error, payload) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }
    var artist = payload.artist ? { uri: payload.artist } : null;
    model.update({ artist: artist });
  });
}

function onWait(model, properties) {
  var hasArtist = contains(properties, 'artist');
  var metaFields = ['currentUser', 'name', 'username', 'image', 'images', 'subscribed'];
  var hasMetadata = !!intersection(properties, metaFields).length;

  if (hasMetadata) updateMetadata(model);
  if (hasArtist) updateArtist(model);
}

var regExp = exports.matches = /^spotify:user:[^:]+$/;
var registered;
exports.register = function () {
  if (registered) return;
  registered = true;

  live.subscribe(regExp, 'wait', onWait);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  live.unsubscribe(regExp, 'wait', onWait);
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-live":212,"./util/bridge":206,"mout/array/contains":323,"mout/array/intersection":332,"spotify-liburi":398}],206:[function(require,module,exports){
/**
 * @module spotify-live-models/util/bridge
 * @private
 */

'use strict';

var bridge = require('../../spotify-bridge-request');

module.exports = {
  request: bridge.request
};

},{"../../spotify-bridge-request":38}],207:[function(require,module,exports){
'use strict';

var liburi = require('spotify-liburi');

function setLocalProperties(track) {
  if (track.album && track.album.uri) {
    var albumType = liburi.from(track.album.uri).type;
    track.album.local = albumType === liburi.Type.LOCAL_ALBUM;
  }
  if (track.artists) {
    for (var i = 0, l = track.artists.length; i < l; i++) {
      var artist = track.artists[i];
      if (artist.uri) {
        var artistType = liburi.from(artist.uri).type;
        artist.local = artistType === liburi.Type.LOCAL_ARTIST;
      }
    }
  }
}

/**
 * Export public interface
 */
module.exports = {
  setLocalProperties: setLocalProperties
};

},{"spotify-liburi":398}],208:[function(require,module,exports){
(function (global){
/**
 * @module spotify-live-models/util/cosmos
 * @private
 */

'use strict';

var cosmos = require('spotify-cosmos-api');

function DELETE(options, opt_callback) {
  options.method = exports.cosmos.Action.DELETE;
  return request(options, opt_callback);
}

function GET(options, opt_callback) {
  options.method = exports.cosmos.Action.GET;
  return request(options, opt_callback);
}

function SUB(options, opt_callback) {
  options.method = exports.cosmos.Action.SUB;
  return request(options, opt_callback);
}

function POST(options, opt_callback) {
  options.method = exports.cosmos.Action.POST;
  return request(options, opt_callback);
}

function PUT(options, opt_callback) {
  options.method = exports.cosmos.Action.PUT;
  return request(options, opt_callback);
}

function HEAD(options, opt_callback) {
  options.method = exports.cosmos.Action.HEAD;
  return request(options, opt_callback);
}

function request(options, opt_callback) {
  var method = options.method;
  delete options.method;

  var subscription, canceled;

  sanitizeURL(options.url, function (error, url) {
    if (error) return opt_callback && opt_callback(error);

    // if you cancel before the userName is replaced.
    if (canceled) return;

    var request = new exports.cosmos.Request(method || exports.cosmos.Action.GET, url, options.headers, options.body);
    subscription = exports.cosmos.resolver.resolve(request, function (error, response) {
      if (!opt_callback) return;
      if (error) return opt_callback(error);
      try {
        opt_callback(null, {
          body: JSON.parse(response.getBody() || '{}'),
          headers: response.getHeaders(),
          status: response.getStatusCode()
        });
      } catch (parseError) {
        parseError.response = response;
        opt_callback(parseError);
      }
    });
  });

  return {
    cancel: function cancel() {
      if (subscription && subscription.cancel) {
        // we already subscribed, cancel it.
        subscription.cancel();
        subscription = null;
      } else if (!canceled) {
        // not subscribed yet, don't even subscribe.
        canceled = true;
      }
      return null;
    }
  };
}

function sanitizeURL(url, callback) {
  if (url.indexOf('@') > -1) {
    callback(null, url.replace('@', encodeURIComponent(global.__spotify.username)));
  } else {
    callback(null, url);
  }
}

exports.request = request;
exports.get = GET;
exports.post = POST;
exports.subscribe = SUB;
exports.delete = DELETE;
exports.put = PUT;
exports.head = HEAD;
exports.cosmos = cosmos;

exports.sanitizeURL = sanitizeURL;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"spotify-cosmos-api":388}],209:[function(require,module,exports){
'use strict';

var Preferences = require('../../spotify-preferences');

var preferences = null;
var showUnplayableTracks = null;

var isInitialized = false;
var initCallbacks = [];

/**
 * Initialize the module and start listening for preference updates.
 */

function init(callback) {

  initCallbacks.push(callback);
  if (initCallbacks.length > 1) {
    // We already kicked of the subscription
    return;
  }

  subscribe(function (error, value) {
    if (!error) {
      showUnplayableTracks = !!value;
    }
    isInitialized = true;

    var cb;
    while (cb = initCallbacks.pop()) {
      cb(showUnplayableTracks);
    }
  });
}

/**
 * Subscribe for changes of the 'Show Unplayable Tracks' preference.
 *
 * @param {Function} callback Callback function that gets called for
 *                            each change.
 *
 * @return {Object} An object with a `cancel` method.
 */
function subscribe(callback) {
  var preferences = new Preferences('ui');

  return preferences.subscribe('show_unplayable_tracks', function (error, value) {
    if (error) return callback(error);
    callback(null, !!value);
  });
}

exports.subscribe = subscribe;

},{"../../spotify-preferences":250}],210:[function(require,module,exports){
'use strict';

var base = 'spotify:internal:sortlist';
var regExp = /^spotify:internal:sortlist:(asc|desc):([^:]*):(.*)$/;

/**
 * Create a URI representing a sorted variant of a list.
 *
 * @param {string} originUri The original list URI.
 * @param {string} direction The direction of the sorted list ('asc' or 'desc').
 * @param {string} query The query string (compatible with spotify-live). Sorting
 *     implementations might not look at all values. The list of produced values
 *     from the query will be tried in order from left to right. If two items have
 *     the same value, it will look at the next produced value from this query.
 *     Any spaces in the query will be removed.
 *
 * @return {string} URI of the sorted variant of the list. The URI will have
 *     the query string URL encoded.
 */
exports.create = function (originUri, direction, query) {
  originUri = originUri.replace(/^spotify:/, '');

  query = encodeURIComponent(query);
  query = query.replace(/%20/g, '');

  return [base, direction, query, originUri].join(':');
};

/**
 * Get the direction of the sorted list.
 *
 * @param {string} sortUri The URI of the sorted list.
 *
 * @return {string} The direction of the sort ('asc' or 'desc'). If URI is
 *     invalid, this returns an empty string.
 */
exports.getDirection = function (sortUri) {
  var matches = sortUri.match(regExp);
  if (!matches) return '';

  return matches[1];
};

/**
 * Get the query string from a sort URI.
 *
 * @param {string} sortUri The URI of the sorted list.
 *
 * @return {string} The query string, URL decoded. If URI is
 *     invalid, this returns an empty string.
 */
exports.getQuery = function (sortUri) {
  var matches = sortUri.match(regExp);
  if (!matches) return '';

  return decodeURIComponent(matches[2]);
};

/**
 * Get the URI of the original list.
 *
 * @param {string} sortUri The URI of the sorted list.
 *
 * @return {string} The URI of the original list. If the sort URI is invalid,
 *     this returns an empty string.
 */
exports.getOriginUri = function (sortUri) {
  var matches = sortUri.match(regExp);
  if (!matches) return '';

  return 'spotify:' + matches[3];
};

/**
 * Parse and return all parts of the sort URI.
 *
 * @param {string} sortUri The URI of the sorted list.
 *
 * @return {Object?} An object with properties `direction`, `query` and `originUri`,
 *     or null if the URI is not valid.
 */
exports.parse = function (sortUri) {
  var matches = sortUri.match(regExp);
  if (!matches) return null;

  return {
    direction: matches[1],
    query: decodeURIComponent(matches[2]),
    originUri: 'spotify:' + matches[3]
  };
};

/**
 * Test if the provided URI is a valid sort URI.
 *
 * @param {string} sortUri The URI of the sorted list.
 *
 * @return {boolean} True if it's valid, false otherwise.
 */
exports.isValid = function (sortUri) {
  return regExp.test(sortUri);
};

/**
 * The regular expression that matches sort URIs.
 */
exports.regExp = regExp;

},{}],211:[function(require,module,exports){
'use strict';

var sortUriUtils = require('../spotify-live-sort-uri');
var filterUriUtils = require('../spotify-live-filter-uri');

/**
 * Create a URI representing a wrapped variant of a list.
 *
 * @param {object} opts The options.
 * @param {string} opts.originUri The origin uri.
 * @param {object?} opts.filter The filter, if any
 * @param {object?} opts.sort The sorting, if any
 *
 * @return {string} URI of the wrapped variant of the list.
 */
exports.create = function (opts) {
  var uri = opts.originUri;
  if (opts.filter) {
    uri = filterUriUtils.create(uri, opts.filter.query);
  }
  if (opts.sort) {
    uri = sortUriUtils.create(uri, opts.sort.direction, opts.sort.query);
  }
  return uri;
};

/**
 * Get the URI of the original list.
 *
 * @param {string} sortUri The URI of the wrapped list.
 *
 * @return {string} The URI of the original list. If the wrapped URI is invalid,
 *     this returns an empty string.
 */
exports.getOriginUri = function (wrappedUri) {
  var parsed = exports.parse(wrappedUri);
  return parsed && parsed.originUri || '';
};

/**
 * Parse and return all parts of the wrapped URI.
 *
 * @param {string} wrappedUri The URI of the wrapped list.
 *
 * @return {object} An object with properties `originUri`, `sort` and `filter`.
 */
exports.parse = function (wrappedUri) {
  var sort = sortUriUtils.parse(wrappedUri);
  var filter = filterUriUtils.parse(sort && sort.originUri || wrappedUri);
  if (!(sort || filter)) return null;

  return {
    originUri: filter && filter.originUri || sort && sort.originUri,
    sort: sort,
    filter: filter
  };
};

/**
 * Test if the provided URI is a valid wrapped URI.
 *
 * @param {string} wrappedUri The URI of the wrapped list.
 *
 * @return {boolean} True if it's valid, false otherwise.
 */
exports.isValid = function (wrappedUri) {
  return !!exports.parse(wrappedUri);
};

},{"../spotify-live-filter-uri":160,"../spotify-live-sort-uri":210}],212:[function(require,module,exports){
(function (global){
/**
 * @module live
 */'use strict';

// prime

var prime = require('prime');
var defer = require('prime/defer');
var Emitter = require('prime/emitter');

// mout
var isPlainObject = require('mout/lang/isPlainObject');
var isArray = require('mout/lang/isArray');
var isRegExp = require('mout/lang/isRegExp');
var isNumber = function isNumber(n) {
  return typeof n === 'number';
};
var isString = function isString(s) {
  return typeof s === 'string';
};

var escapeRegExp = require('mout/string/escapeRegExp');

var _difference = require('mout/array/difference');
var filter = require('mout/array/filter');
var combine = require('mout/array/combine');
var map = require('mout/array/map');

var deepMixIn = require('mout/object/deepMixIn');
var pick = require('mout/object/pick');
var keys = require('mout/object/keys');

// finally
var flow = require('finally');

// util
var OrderedSet = require('./util/ordered-set');
var Range = require('../spotify-range2');
var parse = require('./util/parser');
var throttle = require('./util/throttle');

// methods

var isLiveList = function isLiveList(item) {
  return item instanceof LiveList;
};

var isLiveObject = function isLiveObject(item) {
  return item instanceof LiveObject;
};

// Simple, stupid and fast.
// Shallow, not checking hasOwnProperty.
var simpleClone = function simpleClone(object) {
  var clone = {};
  for (var key in object) {
    clone[key] = object[key];
  }
  return clone;
};

var difference = function difference(a, b) {
  return a.length === 0 ? [] : _difference.apply(this, arguments);
};

var values = function values(object, keys) {
  var values = [];
  var key;
  for (var i = 0, len = keys.length; i < len; i++) {
    key = keys[i];
    if (key in object) values.push(object[key]);else values.length++;
  }
  return values;
};

// subtract ranges2 from ranges1
var rdifference = function rdifference(ranges1, ranges2) {
  if (!ranges1.length) return [];

  var resultingRanges = [];

  for (var i = 0, len = ranges1.length; i < len; i++) {
    var range = ranges1[i];
    resultingRanges = resultingRanges.concat(range.subtract(ranges2));
  }

  // Make sure we don't have overlapping ranges
  resultingRanges = new Range(0, 0).merge(resultingRanges);

  // Remove any empty ranges
  resultingRanges = filter(resultingRanges, function (range) {
    return !!range.length;
  });

  return resultingRanges;
};

// merge ranges1 into ranges2
var rcombine = function rcombine(ranges1, ranges2) {
  for (var i = 0, len = ranges1.length; i < len; i++) {
    var range = ranges1[i];
    ranges2 = range.merge(ranges2);
  }
  return ranges2;
};

// util
var IDX = 0;

var slice_ = Array.prototype.slice;

var transform = function transform(item, method) {

  if (isPlainObject(item)) {
    // plain objects need to be liveified
    if ('operations' in item) return new LiveList().update(item.operations);
    return live(item.uri)._update(item, method);
  }

  if (isArray(item)) {
    // arrays need to be liveified
    return new LiveList()._update([{
      type: 'insert',
      index: 0,
      length: item.length,
      values: item
    }], method);
  }
  return item;
};

// Creates a callback with a timeout.
function createTimedCallback(callback, timeout) {
  var called;
  var timeoutId = setTimeout(function () {
    called = true;
    callback(new Error('Timeout Expired: ' + timeout + ' milliseconds'));
  }, timeout);
  return function () {
    if (!called) {
      clearTimeout(timeoutId);
      callback.apply(this, arguments);
    }
  };
};

var LiveList = prime( /** @lends LiveList.prototype */{

  mixin: Emitter,

  /**
   * A representation of an array which may be observed for changes
   * @constructs
   * @mixes Emitter
   * @param {Number} [length] - A number representing the length of the liveList.
   */
  constructor: function LiveList(length) {
    this._data = new OrderedSet(length);
    this._mergeThrottled = throttle(this._merge, this);
    this._waiting = [];

    var self = this;
    var lastWait = '';

    if (live.debug) setInterval(function () {
      var thisWait = self._waiting.toString();
      if (lastWait === thisWait) return;
      lastWait = thisWait;

      if (self._waiting.length) {
        console.warn(self, 'waiting for', self._waiting);
      } else {
        console.warn(self, 'all done');
      }
    }, 2000);
  },

  get index() {
    return this._data.index;
  },

  get length() {
    return this._data.length;
  },

  get keys() {
    return this._data.keys;
  },

  get values() {
    return this._data.values;
  },

  indexOf: function indexOf(key) {
    return this._data.indexOf(key);
  },

  indexOfMany: function indexOfMany(keys) {
    return this._data.indexOfMany(keys);
  },

  valueOf: function valueOf(key) {
    return this._data.valueOf(key);
  },

  hasKey: function hasKey(key) {
    return this._data.hasKey(key);
  },

  forEach: function forEach(fn, ctx) {
    this._data.forEach(fn, ctx);
    return this;
  },

  map: function map(fn, ctx) {
    return this._data.map(fn, ctx);
  },

  _merge: function _merge() {
    var data = this._data; // actual data
    var publish = this._publish; // new items on top of a copy of data || null
    var before = this._before; // an old copy of data || null

    if (publish) {
      delete this._publish;
      if (this._listeners && this._listeners.publish) {
        var publishDiff = data.diff(publish);
        if (publishDiff.length) this.emit('publish', publishDiff, EMIT_SYNC);
      }
    } else if (before) {
      delete this._before;
      if (this._listeners && this._listeners.update) {
        var updateDiff = before.diff(data);
        if (updateDiff.length) this.emit('update', updateDiff, EMIT_SYNC);
      }
    }
    return this;
  },

  _update: function _update(operations, method) {

    var branch;
    if (method === PUBLISH) {
      // it was receiving, cannot publish.
      if (this._before) return this;
      branch = this._publish || (this._publish = this._data.clone());
    } else if (method === UPDATE) {
      // it was publishing, delete it.
      if (this._publish) delete this._publish;
      if (!this._before) this._before = this._data.clone();
      branch = this._data;
    }

    var op;
    for (var opIndex = 0, opLen = operations.length; opIndex < opLen; opIndex++) {
      op = operations[opIndex];
      switch (op.type) {
        case 'length':
          branch.length = op.length;break;
        case 'sort':
          branch.sort(op.compareFunction);break;
        case 'move':
          branch.move(op.from, op.to, op.length);break;
        case 'remove':
          branch.remove(op.index, op.length);break;
        case 'insert':
          var values = [];
          var keys = op.keys || [];
          for (var i = 0, len = op.values.length; i < len; i++) {
            if (!op.keys || !op.keys[i]) keys[i] = (IDX++).toString(36);
            values[i] = transform(op.values[i], method);
          }
          branch.insert(op.index, keys, values);
          break;
      }
    }

    if (method === UPDATE) this._waiting = rdifference(this._waiting, this.index);

    this._mergeThrottled();
    return this;
  },

  publish: function publish(operations) {
    return this._update(operations, PUBLISH);
  },

  update: function update(operations) {
    return this._update(operations, UPDATE);
  },

  /**
   * Serialize the data in this list into a plain object.
   *
   * @param {number=} limit Optional limit parameter. Controls how many levels
   *     deep to serialize.
   *
   * @return {Array} The data array.
   */
  serialize: function serialize(limit) {
    if (limit === 0) return [];

    var array = [];
    var nextLimit = limit === undefined ? undefined : limit - 1;

    for (var i = 0; i < this.length; i++) {
      var value = this.values[i];
      var serializedValue = value;
      if (value && value.serialize) {
        serializedValue = value.serialize(nextLimit);
      }
      array.push(serializedValue);
    }

    return array;
  },

  _getDataFromMask: function _getDataFromMask(mask) {
    var items = [];

    if (mask.length > 0) {
      // The provided mask to a list is the mask for each list item, so we need
      // to loop through all the items and get the data from each item based on
      // the mask.
      for (var i = 0, l = this.length; i < l; i++) {
        var item = this.get(i);
        var parsedItem;
        var isObjectOrList = item && item._getDataFromMask;
        if (isObjectOrList) {
          parsedItem = item._getDataFromMask(mask);
        }
        items.push(parsedItem);
      }
    }

    return items;
  },

  _query: function _query(selector, callback, mode) {
    var self = this;

    var query = function query() {
      queryList(self, selector, function (error, data, wasSync) {
        if (error) return callback(error);

        if (!wasSync) {
          self._query(selector, callback, mode);
        } else {
          callback(null, data);
        }
      });
    };

    if (mode === ASYNC) defer(query);else query();
  },

  /**
   * Query properties in this list.
   * This can be called in two different ways: with a callback or without. When
   * calling it with a callback, it will wait for any missing data and always
   * return the data you queried for. When calling it without a callback, it
   * will return an array structure with only the data that was found in the
   * object at the moment. It will not kick off any events for waiting for
   * properties.
   *
   * @param {String} selector - The query selector. Only selectors without
   *     filters are supported when not providing a callback.
   * @param {Array} params - The query replace parameters.
   * @param {LiveList~queryCallback} callback - The callback that handles the response.
   * @param {Object} [mode] live.SYNC: Force sync, 2: live.ASAP: Don't force async
   * @param {Number} timeout - optional timeout in milliseconds
   *
   * @return {LiveList|Array} If no callback is passed it returns an array with
   *                             the data matching the query, that was found at
   *                             the moment in the list.
   *                             If a callback is passed it returns the instance.
   */
  query: function query(selector, params, callback, mode, timeout) {
    /**
     * @callback LiveList~queryCallback
     * @param {Error|Null} error - An error that you can throw, or null.
     * @param {Array} [data] - The response as an array.
     */
    if (typeof params === 'function') {
      // shift for empty params
      timeout = mode;
      mode = callback;
      callback = params;
      params = [];
    }

    if (!callback) {
      return this._getDataFromMask(parse(selector, params).mask);
    }

    if (!mode) {
      mode = ASYNC;
    } else if (isNumber(mode)) {
      // shift once again
      timeout = mode;
      mode = ASYNC;
    }

    if (timeout) {
      callback = createTimedCallback(callback, timeout);
    }

    this._query(parse(selector, params), callback, mode);
    return this;
  },

  _wait: function _wait(ranges) {
    if (!this._required) {
      // if _required is set, it was deferred already
      this._required = [];
      defer(function () {
        var missingFromIndex = this.missing(this._required);
        var missingFromWaiting = rdifference(missingFromIndex, this._waiting);
        this._waiting = rcombine(this._waiting, missingFromWaiting);
        delete this._required;
        if (missingFromWaiting.length) this.emit('wait', missingFromWaiting, EMIT_SYNC);
      }, this);
    }
    this._required = rcombine(this._required, ranges);
  },

  missing: function missing(ranges) {
    return rdifference(ranges, this.index);
  },

  // the raw, unbeautified get
  // this can callback sync or async
  _get: function _get(ranges, callback) {
    if (this.missing(ranges).length) {
      // has missing stuff (no matter what)
      this._wait(ranges);

      var check = function check() {
        var needed = this.missing(ranges);
        if (!needed.length) {
          this.off('update', check);
          callback.call(this);
        }
      };

      this.on('update', check);
    } else {
      // the callback is called with 'true' when syncronous.
      callback.call(this, null, true);
    }
  },

  /**
   * Checks if the range has been set with values in the list.
   *
   * @param {number} fromIndex The index to start from.
   * @param {number=} toIndex Optional index to stop at (non-inclusive). If no
   *     toIndex is specified, it will default to the index after fromIndex, to
   *     check for the single item at fromIndex.
   *
   * @return {Boolean} True if the range has been set.
   */
  has: function has(fromIndex, toIndex) {
    var hasToIndex = toIndex !== undefined;
    if (!hasToIndex) toIndex = fromIndex + 1;

    var range = new Range(fromIndex, toIndex);

    return range.contained(this.index);
  },

  /**
   * Gets items from the list between the specified indices.
   * @param {Number} what - The index to start from.
   * @param {Number} [toIndex=fromIndex + 1] - The index to stop at (non-inclusive).
   * @param {LiveList~getCallback} [callback] - Optional callback function. If no toIndex
   *     is specified, the callback can be placed as the second argument.
   * @param {Object} [mode] live.SYNC: Force sync, 2: live.ASAP: Don't force async
   * @param {Number} timeout - optional timeout in milliseconds
   * @return {LiveList|Array} If no callback is specified, returns the requested items in an array.
   *                          If a callback is specified, the method returns the instance.
   */
  get: function get(fromIndex, toIndex) {
    /**
     * @callback LiveList~getCallback
     * @param {Error|Null} error - An error that you can throw, or null.
     * @param {Array|*} [data] - The response as an array.
     *                           If toIndex is not specified a single item on the list is passed.
     */

    // fast, get one
    if (arguments.length === 1) {
      if (isNumber(fromIndex)) return this.values[fromIndex];
      if (isString(fromIndex)) return this.valueOf(fromIndex);
    }

    var self = this;

    var args = slice_.call(arguments);
    var callback, mode, requested;

    for (var i = 0, len = args.length; i < len; i++) {
      var arg = args[i];
      if (typeof arg === 'function') {
        var split = args.splice(i, 3);
        len = args.length;
        callback = split[0];
        if (split[1]) {
          if (split[1] === SYNC || split[1] === ASYNC || split[1] === ASAP) {
            mode = split[1];
          } else {
            // assume this arg is a timeout
            mode = ASYNC;
            callback = createTimedCallback(callback, split[1]);
            break;
          }
          // is there a timeout ?
          if (split[2] && mode !== SYNC) {
            callback = createTimedCallback(callback, split[2]);
          }
        } else {
          mode = ASYNC;
        }
        break;
      }
    }

    var asArray = false;
    var asSingleValue = false;

    if (fromIndex instanceof Range) {
      // one range
      requested = args;
      asArray = !callback && requested.length > 1;
    } else if (isArray(fromIndex)) {
      // array of ranges
      asArray = true;
      requested = fromIndex;
    } else {
      // numbers ?
      var hasToIndex = !isNaN(toIndex);
      if (!hasToIndex) toIndex = fromIndex + 1;
      asSingleValue = !hasToIndex;
      requested = [new Range(fromIndex, toIndex)];
    }

    var result = function result() {
      return map(requested, function (range) {
        return self.values.slice(range.start, range.end);
      });
    };

    var done = function done() {
      if (asArray) callback.call(self, null, result());else if (asSingleValue) callback.call(self, null, self.values[fromIndex]);else callback.apply(self, [null].concat(result()));
    };

    if (!callback) {
      if (asArray) return result();
      return result()[0];
    } else if (mode === SYNC) {
      done();
    } else {
      if (mode === ASYNC && !this.missing(requested).length) {
        // it has all the data but needs to be ASYNC
        defer(function () {
          this._get(requested, done);
        }, this);
      } else {
        this._get(requested, done);
      }
    }
    return this;
  }

});

var LiveObject = prime( /** @lends LiveObject.prototype */{

  mixin: Emitter,

  /**
   * A representation of an object which may be observed for changes
   * @constructs
   * @mixes Emitter
   */
  constructor: function LiveObject(_uri) {
    this.uri = _uri;
    this._data = { uri: _uri };
    this._mergeThrottled = throttle(this._merge, this);
    this.index = [];
    this._waiting = [];
    this.emit('init', EMIT_SYNC);

    var self = this;
    var lastWait = '';

    if (live.debug) setInterval(function () {
      var thisWait = self._waiting.toString();
      if (lastWait === thisWait) return;
      lastWait = thisWait;

      if (self._waiting.length) {
        console.warn(self, self._waiting);
      } else {
        console.warn(self, 'all done');
      }
    }, 2000);
  },

  emit: function emit() {
    var uri = this.uri;
    if (uri) {
      var keys = emitters.keys;
      var values = emitters.values;
      var key;
      var args;

      for (var i = 0, len = keys.length; i < len; i++) {
        key = keys[i];
        if (uri.match(key)) {
          if (!args) {
            args = new Array(arguments.length);
            for (var j = 0; j < arguments.length; ++j) {
              args[j] = arguments[j];
            }
            args.splice(1, 0, this);
          }
          var emitter = values[i];
          emitter.emit.apply(emitter, args);
        }
      }
    }

    Emitter.prototype.emit.apply(this, arguments);
  },

  _merge: function _merge() {
    var data = this._data; // the data
    var before = this._before; // an old copy of data
    var publish = this._publish; // published data
    var value;
    var key;

    // published changes
    if (publish) {
      delete this._publish;

      // emit change events if the object has a uri that can be subscribed too,
      // or the object in itself has listeners
      if (this.uri || this._listeners && this._listeners.publish) {
        var publishEvent = {};

        for (key in publish) {
          value = publish[key];
          if (data[key] !== value) publishEvent[key] = value;
        }

        if (Object.keys(publishEvent).length) {
          this.emit('publish', publishEvent, EMIT_SYNC);
        }
      }
    }

    // if there are changes
    if (before) {
      delete this._before;

      var updateEvent = {};

      // emit change events if the object has a uri that can be subscribed too,
      // or the object in itself has listeners
      if (this.uri || this._listeners && this._listeners.update) {
        // check changed and added keys
        for (key in data) {
          value = data[key];
          // there was no key, or value is different
          if (!(key in before) || before[key] !== value) updateEvent[key] = value;
        }

        // check deleted keys
        for (key in before) {
          value = before[key];
          // there is no key so it was deleted
          if (!(key in data)) updateEvent[key] = undefined;
        }

        if (Object.keys(updateEvent).length) {
          this.emit('update', updateEvent, EMIT_SYNC);
        }
      }
    }

    return this;
  },

  _update: function _update(object, method) {
    var branch;

    if (method === PUBLISH) {
      branch = this._publish || (this._publish = simpleClone(this._data));
    } else if (method === UPDATE) {
      if (!this._before) this._before = simpleClone(this._data);
      branch = this._data;
    }

    var value;
    for (var key in object) {
      value = object[key];
      var previous = !(key in branch) ? undefined : branch[key];

      if (isLiveList(previous)) {
        // updating lists with an array will keep the reference but replace every item.
        if (isArray(value)) {

          previous._update([{
            type: 'remove',
            index: 0,
            length: previous.length
          }, {
            type: 'insert',
            index: 0,
            values: value
          }], method);
          continue;
        } else if (isPlainObject(value) && 'operations' in value) {
          previous._update(value.operations, method);
          continue;
        }
      }

      if (method === UPDATE && value === undefined) delete branch[key];else branch[key] = transform(value, method);
    }

    if (method === UPDATE) {
      this.index = keys(branch);
      this._waiting = difference(this._waiting, this.index);
    }

    this._mergeThrottled();
    return this;
  },

  delete: function _delete(key) {
    var object = {};
    object[key] = undefined;
    return this.update(object);
  },

  update: function update(object) {
    return this._update(object, UPDATE);
  },

  publish: function publish(object) {
    return this._update(object, PUBLISH);
  },

  /**
   * Serialize the data in this object into a plain object.
   *
   * @param {number=} limit Optional limit parameter. Controls how many levels
   *     deep to serialize.
   *
   * @return {Object} The data object.
   */
  serialize: function serialize(limit) {
    if (limit === 0) return {};

    var object = {};
    var data = this._data;
    var nextLimit = limit === undefined ? undefined : limit - 1;

    for (var key in data) {
      var value = data[key];
      if (value === undefined) continue;
      var serializedValue = value;
      if (value && value.serialize) {
        serializedValue = value.serialize(nextLimit);
      }
      object[key] = serializedValue;
    }

    return object;
  },

  _getDataFromMask: function _getDataFromMask(mask) {
    var data = {};

    for (var i = 0, l = mask.length; i < l; i++) {
      var thisMask = mask[i];
      var nextMask = thisMask.mask;
      var key = thisMask.key;

      var realValue = this.get(key);
      var value = realValue;

      // Set the value to an empty object or array, and then it will be filled
      // in with the found data in the next step.
      if (isLiveObject(realValue)) value = {};
      if (isLiveList(realValue)) value = [];

      if (nextMask) {
        if (isLiveObject(realValue)) {
          var innerData = realValue._getDataFromMask(nextMask);
          deepMixIn(value, innerData);
        } else if (isLiveList(realValue)) {
          value = realValue._getDataFromMask(nextMask);
        }
      }

      data[key] = value;
    }

    return data;
  },

  _query: function _query(selector, callback, mode) {
    var self = this;

    var query = function query() {
      queryObject(self, selector, function (error, data, wasSync) {
        if (error) return callback.call(this, error);

        if (!wasSync) {
          self._query(selector, callback, mode);
        } else {
          callback.call(this, null, data);
        }
      });
    };

    if (mode === ASYNC) defer(query);else query();
  },

  /**
   * Query properties in this object.
   * This can be called in two different ways: with a callback or without. When
   * calling it with a callback, it will wait for any missing properties and
   * always return the data you queried for. When calling it without a callback,
   * it will return an object structure with only the data that was found in the
   * object at the moment. It will not kick off any events for waiting for
   * properties.
   *
   * @param {String} selector - The query selector. Only selectors without
   *     filters are supported when not providing a callback.
   * @param {Array} params - The query replace parameters. Optional.
   * @param {LiveObject~queryCallback} callback - The callback function.
   * @param {Object} [mode] live.SYNC: Force sync, 2: live.ASAP: Don't force async
   * @param {Number} timeout - optional timeout in milliseconds
   *
   * @return {LiveObject|Object} If no callback is passed it returns an object
   *                             with the data matching the query, that was found
   *                             at the moment in the object.
   *                             If a callback is passed it returns the instance.
   */
  query: function query(selector, params, callback, mode, timeout) {
    /**
     * @callback LiveObject~queryCallback
     * @param {Error|Null} error - An error that you can throw, or null.
     * @param {LiveObject} [data] - The response as a plain object.
     */
    if (typeof params === 'function') {
      // shift for empty params
      timeout = mode;
      mode = callback;
      callback = params;
      params = [];
    }

    if (!callback) {
      return this._getDataFromMask(parse(selector, params).mask);
    }

    if (!mode) {
      mode = ASYNC;
    } else if (isNumber(mode)) {
      // shift once again
      timeout = mode;
      mode = ASYNC;
    }

    if (timeout) {
      callback = createTimedCallback(callback, timeout);
    }

    this._query(parse(selector, params), callback, mode);
    return this;
  },

  _wait: function _wait(keys) {
    if (!this._required) {
      // if _required is set, it was deferred already
      this._required = [];
      defer(function () {
        var missingFromIndex = this.missing(this._required);
        var missingFromWaiting = difference(missingFromIndex, this._waiting);
        this._waiting = combine(this._waiting, missingFromWaiting);
        delete this._required;
        if (missingFromWaiting.length) this.emit('wait', missingFromWaiting, EMIT_SYNC);
      }, this);
    }
    this._required = combine(this._required, keys);
  },

  missing: function missing(keys) {
    return difference(keys, this.index);
  },

  /**
   * Checks if the key has been set in the object.
   *
   * @param {string} key The name of the key.
   *
   * @return {Boolean} True if the key has been set.
   */
  has: function has(key) {
    return this.index.indexOf(key) > -1;
  },

  // the raw, unbeautified get
  // this can callback sync or async
  _get: function _get(keys, callback) {
    if (this.missing(keys).length) {
      this._wait(keys);

      var check = function check() {
        var needed = this.missing(keys);
        if (!needed.length) {
          this.off('update', check);
          callback.call(this);
        }
      };
      this.on('update', check);
    } else {
      // the callback is called with 'true' when syncronous.
      callback.call(this, null, true);
    }
  },

  /**
   * Gets values from the object.
   * @param {...String|Array} keys - An array of strings as arguments.
   * @param {LiveObject~getCallback} [callback] - Optional callback function.
   * @param {Object} [mode] live.SYNC: Force sync, 2: live.ASAP: Don't force async
   * @param {Number} timeout - optional timeout in milliseconds
   * @return {LiveObject|Array|*} If no callback is passed and keys is either an array or multiple arguments
   *                             returns the values in an array.
   *                             If no callback is passed and keys is a single parameter it
   *                             returns the requested value (any type).
   *                             If a callback is passed it returns the instance.
   */
  get: function get(key) {
    /**
     * @callback LiveObject~getCallback
     * @param {Error|Null} error - An error that you can throw, or null.
     * @param {Array|...*} [data] - If keys are requested as arguments (any #)
     *                              it will return many results as arguments.
     *                              If keys are requested as an array (any #), it will return data as an array
     * @param {Number} [mode] 1: FORCE SYNC, 2: DON'T FORCE ASYNC
     */

    // fast, get one
    var data = this._data;
    if (arguments.length === 1 && isString(key)) return data[key];

    var self = this;

    var args = slice_.call(arguments);
    var callback, mode, keys;

    for (var i = 0, len = args.length; i < len; i++) {
      var arg = args[i];
      if (typeof arg === 'function') {
        var split = args.splice(i, 3);
        len = args.length;
        callback = split[0];
        if (split[1]) {
          if (split[1] === SYNC || split[1] === ASYNC || split[1] === ASAP) {
            mode = split[1];
          } else {
            // assume this arg is a timeout
            mode = ASYNC;
            callback = createTimedCallback(callback, split[1]);
            break;
          }
          // is there a timeout ?
          if (split[2] && mode !== SYNC) {
            callback = createTimedCallback(callback, split[2]);
          }
        } else {
          mode = ASYNC;
        }
        break;
      }
    }

    var asArray = false;

    if (isArray(key)) {
      keys = key;
      asArray = true;
    } else {
      keys = args;
    }

    var done = function done() {
      var vals = values(data, keys);
      if (asArray) {
        callback.call(self, null, vals);
      } else {
        vals.unshift(null); // unshift no error
        callback.apply(self, vals);
      }
    };

    if (!callback) {
      return values(data, keys);
    } else if (mode === SYNC) {
      done();
    } else {
      if (mode === ASYNC && !this.missing(keys).length) {
        // it has all the data but needs to be ASYNC
        defer(function () {
          self._get(keys, done);
        });
      } else {
        this._get(keys, done);
      }
    }

    return this;
  }

});

var queryAny = function queryAny(object, selector, callback) {
  if (isPlainObject(object) || isLiveObject(object)) return queryObject(object, selector, callback);else if (isArray(object) || isLiveList(object)) return queryList(object, selector, callback);else return callback(null, object, true);
};

var queryObject = function queryObject(object, selector, callback) {
  var data = {};
  var isSync = true;

  if (!selector) callback(null, data, isSync);

  var keys = map(selector.mask, 'key');

  var done = function done(values) {
    flow().parallel(values, function (objectValue, i) {
      var control = this;
      queryAny(objectValue, selector.mask[i], function (error, dataValue, wasSync) {
        if (error) return control.break(error);
        if (!wasSync) isSync = false;
        if (data[keys[i]]) deepMixIn(data[keys[i]], dataValue);else data[keys[i]] = dataValue;
        control.done();
      });
    }).finally(function (error) {
      callback(error, data, isSync);
    });
  };

  if (isLiveObject(object)) {
    object._get(keys, function (error, wasSync) {
      if (error) return callback(error);
      if (!wasSync) isSync = false;
      var values = map(keys, function (key) {
        return object._data[key];
      });
      done(values);
    });
  } else {
    var values = pick(object, keys);
    done(values);
  }
};

var satisfies = function satisfies(value, op, right) {
  if (!op) return !!value;
  if (isRegExp(right)) return right.test(value);

  if (op === '=') return value === right;
  if (op === '!=') return value !== right;

  if (isNumber(right)) {
    if (op === '>') return value > right;
    if (op === '>=') return value >= right;
    if (op === '<') return value < right;
    if (op === '<=') return value <= right;
  }

  if (isString(right)) {
    var escapedRight = escapeRegExp(right);
    // starts with
    if (op === '^=') return new RegExp('^' + escapedRight).test(value);
    // ends with
    if (op === '$=') return new RegExp(escapedRight + '$').test(value);
    // contains separated by space e.g. 'list of things to look for' ~= 'list'
    if (op === '~=') return new RegExp('(^|\\s)' + escapedRight + '(\\s|$)').test(value);
    // contains separated by - e.g. 'list-of-things-to-look-for' ~= 'things'
    if (op === '|=') return new RegExp('^' + escapedRight + '(-|$)').test(value);
    // contains e.g. 'listofthingstolookfor' ~= 'look'
    if (op === ' *=') return value.toString().indexOf(right) !== -1;
  }

  return false;
};

var filterArray = function filterArray(array, left, op, right, callback) {
  var isSync = true;

  var filtered = [];

  flow().parallel(array, function (item, i) {
    var ctrl = this;

    if (isLiveObject(item)) {
      item._get([left], function (error, wasSync) {
        if (error) return ctrl.break(error);
        if (!wasSync) isSync = false;
        var value = item._data[left];
        if (satisfies(value, op, right)) filtered[i] = item;
        ctrl.done();
      });
    } else if (isPlainObject(item)) {
      if (satisfies(item[left], op, right)) filtered[i] = item;
      ctrl.done();
    } else {
      // filter objects only
      ctrl.done();
    }
  }).finally(function (error) {
    if (error) return callback(error);
    var clean = [];
    for (var i = 0; i < filtered.length; i++) {
      if (i in filtered) clean.push(filtered[i]);
    }callback(null, clean, isSync);
  });
};

// default filter that filters the whole list.
var defaultFilters = [[{
  left: 0,
  op: ':'
}]];

var queryList = function queryList(list, selector, callback) {
  var isSync = true;
  // if there are no filters we need to query the full length
  if (!selector.filters) selector.filters = defaultFilters;

  // single filter.
  // must be sequential.
  flow().sequential(selector.filters, function (conditions) {
    var sequential = this;

    var ref = [];

    // list of conditions in a single filter.
    // can be parallel.
    flow().parallel(conditions, function (condition) {
      var parallel = this;

      var left = condition.left;
      var right = condition.right;
      var op = condition.op;

      if ('left' in condition && !('right' in condition) && isNumber(left)) {
        if (!op) right = left + 1;else if (op === ':') right = list.length;
        op = ':';
      }

      if ('right' in condition && !('left' in condition) && isNumber(right) && op === ':') {
        left = 0;
      }

      // filter by range.
      if (isNumber(left) && isNumber(right) && op === ':') {
        // if the list is an array it means it has already been filtered.
        if (isArray(list)) {
          var filtered = slice_.call(list, left, right);
          ref = ref.concat(filtered);
          parallel.done();
        } else {
          list._get([new Range(left, right)], function (error, wasSync) {
            if (error) return parallel.break(error);

            for (var i = left; i < right; i++) {
              ref.push(list.values[i]);
            }if (!wasSync) isSync = false;
            parallel.done();
          });
        }
      } else {

        var done = function done(array) {
          filterArray(array, left, op, right, function (error, filtered, wasSync) {
            if (error) return parallel.break(error);

            if (!wasSync) isSync = false;
            ref = ref.concat(filtered);
            parallel.done();
          });
        };

        if (isArray(list)) {
          done(list);
        } else {
          // the list is not an array, never been filtered.
          // assume full length.
          // call a function that filters an array once you arraify it.
          list._get([new Range(0, list.length)], function (error, wasSync) {
            if (error) return parallel.break(error);

            var array = [];
            for (var i = 0; i < list.length; i++) {
              array.push(list.values[i]);
            }if (!wasSync) isSync = false;
            done(array);
          });
        }
      }

      // parallel finished
    }).finally(function (error) {
      if (error) return sequential.break(error);
      list = ref;
      sequential.continue();
    });

    // sequential finished
  }).finally(function (error) {
    if (error) return callback(error);

    var data = [];

    // final parallel
    flow().parallel(list, function (item, i) {
      var control = this;
      queryAny(item, selector, function (err, res, wasSync) {
        if (!wasSync) isSync = false;
        if (data[i]) deepMixIn(data[i], res);else data[i] = res;
        control.done(err);
      });
    }).finally(function (err) {
      callback(err, data, isSync);
    });
  });
};

var cache = {};

/**
 * Create a new instance of a object, based on an unique identifier.
 * @function
 * @static
 * @param {String|LiveObject} item - An object with an uri property, or an uri as a string.
 * @return {LiveObject|LiveList} An instance of LiveObject or LiveList.
 */
var live = function live(item) {
  if (isArray(item)) {
    return new LiveList().update([{
      type: 'insert',
      index: 0,
      length: item.length,
      values: item
    }]);
  } else if (isNumber(item)) {
    return new LiveList(item);
  } else if (isString(item)) {
    return cache[item] || (cache[item] = new LiveObject(item));
  } else if (isPlainObject(item)) {
    return live(item.uri).update(item);
  } else if (isLiveList(item) || isLiveObject(item)) {
    return item;
  }

  return new LiveObject();
};

// Allow localStorage.debug to also control live.debug.
if (global.localStorage && global.localStorage.debug && (global.localStorage.debug.indexOf('spotify-live') > -1 || global.localStorage.debug.indexOf('*') > -1)) {
  live.debug = true;
}

var emitters = {
  keys: [],
  values: []
};

/**
 * Subscribe to the specific event of objects matching the pattern.
 * @function
 * @static
 * @param {RegExp} match - Regular expression for matching uris.
 * @param {String} name - The name of the event to listen for.
 * @param {Function} handle - The event handle.
 * @return {Function} The live function.
 */
live.subscribe = function (match, name, handle) {
  if (match.matches) match = match.matches;

  var string = match.toString();

  var keys = emitters.keys;
  var values = emitters.values;

  var emitter;
  for (var i = 0, len = keys.length; i < len; i++) {
    var key = keys[i];
    if (key.toString() === string) {
      emitter = values[i];
      if (emitter) break;
    }
  }

  if (!emitter) {
    keys.push(match);
    values.push(emitter = new Emitter());
  }

  emitter.on(name, handle);

  return this;
};

/**
 * Unsubscribe to the specific event of objects matching the pattern.
 * @function
 * @static
 * @param {RegExp} match - Regular expression for matching uris.
 * @param {String} name - The name of the event to unsubscribe from.
 * @param {Function} handle - The event handle.
 * @return {Function} The live function.
 */
live.unsubscribe = function (match, name, handle) {
  if (match.matches) match = match.matches;

  var string = match.toString();

  var keys = emitters.keys;
  var values = emitters.values;

  var emitter;
  for (var i = 0, len = keys.length; i < len; i++) {
    var key = keys[i];
    if (key.toString() === string) {
      emitter = values[i];
      if (emitter) break;
    }
  }

  if (emitter) emitter.off(name, handle);

  return this;
};

/**
 * Delete a model from the live cache.
 *
 * @param {string} uri A uri.
 *
 * @return {Function} The live function.
 */
live.delete = function (uri) {
  delete cache[uri];
  return this;
};

/**
 * Purge the entire cache.
 *
 * @return {Function} The live function.
 */
live.purge = function () {
  cache = {};
  return this;
};

/**
 * Check if live has an object for the URI in the cache.
 *
 * @param {string} uri A uri.
 *
 * @return {Boolean} True if the object is in the cache.
 */
live.has = function (uri) {
  return !!cache[uri];
};

var EMIT_SYNC = live.EMIT_SYNC = Emitter.EMIT_SYNC;

var ASYNC = live.ASYNC = 'ASYNC';
var SYNC = live.SYNC = 'SYNC';
var ASAP = live.ASAP = 'ASAP';

var PUBLISH = 3;
var UPDATE = 4;

/**
 * @static
 * @see LiveObject
 */
live.Object = LiveObject;

/**
 * @static
 * @see LiveList
 */
live.List = LiveList;

module.exports = live;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-range2":251,"./util/ordered-set":214,"./util/parser":215,"./util/throttle":216,"finally":290,"mout/array/combine":322,"mout/array/difference":324,"mout/array/filter":327,"mout/array/map":333,"mout/lang/isArray":346,"mout/lang/isPlainObject":350,"mout/lang/isRegExp":351,"mout/object/deepMixIn":356,"mout/object/keys":362,"mout/object/pick":365,"mout/string/escapeRegExp":367,"prime":375,"prime/defer":373,"prime/emitter":374}],213:[function(require,module,exports){
/**
 * @module spotify-live/diff
 */
'use strict';

// Original code from: https://github.com/codeparty/arraydiff
// License: MIT
// This has been forked to allow for optimizations and patching operations.

// Based on some rough benchmarking, this algorithm is about O(n^2) worst case,
// and it can compute diffs on random arrays of length 1024 in about 34ms,
// though just a few changes on an array of length 1024 takes about 0.5ms

var splice_ = Array.prototype.splice;
var slice_ = Array.prototype.slice;

var annotate = function annotate(before, after) {
  // Find all items in both the before and after array, and represent them
  // as moves. Many of these "moves" may end up being discarded in the last
  // pass if they are from an index to the same index, but we don't know this
  // up front, since we haven't yet offset the indices.
  //
  // Also keep a map of all the indicies accounted for in the before and after
  // arrays. These maps are used next to create insert and remove diffs.
  var beforeLength = before.length;
  var afterLength = after.length;
  var moves = [];
  var beforeMarked = {};
  var afterMarked = {};
  for (var beforeIndex = 0; beforeIndex < beforeLength; beforeIndex++) {
    var beforeItem = before[beforeIndex];
    for (var afterIndex = 0; afterIndex < afterLength; afterIndex++) {
      if (afterMarked[afterIndex]) continue;
      if (beforeItem !== after[afterIndex]) continue;
      var from = beforeIndex;
      var to = afterIndex;
      var length = 0;
      do {
        beforeMarked[beforeIndex++] = afterMarked[afterIndex++] = true;
        length++;
      } while (beforeIndex < beforeLength && afterIndex < afterLength && before[beforeIndex] === after[afterIndex] && !afterMarked[afterIndex]);
      var moveDiff = {
        type: 'move',
        from: from,
        to: to,
        length: length
      };
      moves.push(moveDiff);
      beforeIndex--;
      break;
    }
  }

  // Create a remove for all of the items in the before array that were
  // not marked as being matched in the after array as well
  var removes = [];
  for (beforeIndex = 0; beforeIndex < beforeLength;) {
    if (beforeMarked[beforeIndex]) {
      beforeIndex++;
      continue;
    }
    var index = beforeIndex;
    var length = 0;
    while (beforeIndex < beforeLength && !beforeMarked[beforeIndex++]) {
      length++;
    }
    var removeDiff = {
      type: 'remove',
      index: index,
      length: length,
      values: slice_.call(before, index, index + length)
    };
    removes.push(removeDiff);
  }

  // Create an insert for all of the items in the after array that were
  // not marked as being matched in the before array as well
  var inserts = [];
  for (afterIndex = 0; afterIndex < afterLength;) {
    if (afterMarked[afterIndex]) {
      afterIndex++;
      continue;
    }
    var index = afterIndex;
    var length = 0;
    while (afterIndex < afterLength && !afterMarked[afterIndex++]) {
      length++;
    }
    var values = slice_.call(after, index, index + length);
    inserts.push({ type: 'insert', index: index, length: length, values: values });
  }

  return [removes, moves, inserts];
};

var offset = function offset(removes, moves, inserts) {

  var insertsLength = inserts.length;
  var removesLength = removes.length;
  var movesLength = moves.length;
  var i, j;

  // Offset subsequent removes and moves by removes
  var count = 0;
  for (i = 0; i < removesLength; i++) {
    var remove = removes[i];
    remove.index -= count;
    count += remove.length;
    for (j = 0; j < movesLength; j++) {
      var move = moves[j];
      if (move.from >= remove.index) move.from -= remove.length;
    }
  }

  // Offset moves by inserts
  for (i = insertsLength; i--;) {
    var insert = inserts[i];
    var length = insert.length;
    for (j = movesLength; j--;) {
      var move = moves[j];
      if (move.to >= insert.index) move.to -= length;
    }
  }

  // Offset the to of moves by later moves
  for (i = movesLength; i-- > 1;) {
    var move = moves[i];
    if (move.to === move.from) continue;
    for (j = i; j--;) {
      var earlier = moves[j];
      if (earlier.to >= move.to) earlier.to -= move.length;
      if (earlier.to >= move.from) earlier.to += move.length;
    }
  }

  // Only output moves that end up having an effect after offsetting
  var outputMoves = [];

  // Offset the from of moves by earlier moves
  for (i = 0; i < movesLength; i++) {
    var move = moves[i];
    if (move.to === move.from) continue;
    outputMoves.push(move);
    for (j = i + 1; j < movesLength; j++) {
      var later = moves[j];
      if (later.from >= move.from) later.from -= move.length;
      if (later.from >= move.to) later.from += move.length;
    }
  }

  // try to reduce the number of move events
  reduceMoves(outputMoves);

  return removes.concat(outputMoves, inserts);
};

var reduceMoves = function reduceMoves(moves) {
  for (var i = 0; i < moves.length; i++) {

    // if we detect a move operation of a lots of items to a near position, we
    // can swap it by a move operation of less items to a farther position
    // (which is going to be much more performant).
    //
    // Example:
    // [1, 2, 3, 4, 5, 6, 7] => [2, 3, 4, 5, 6, 7, 1]
    // We could move [2, 3, 4, 5, 6, 7] one position ahead, but it's better to
    // move [1] six positions behind.
    if (moves[i].length > Math.abs(moves[i].to - moves[i].from)) {
      var from = moves[i].from;
      var to = moves[i].to;
      var length = moves[i].length;

      moves[i].length = Math.abs(moves[i].to - moves[i].from);
      moves[i].from = to;
      moves[i].to = to + length;
    }
  }
};

var insert = function insert(array, index, values) {
  for (var i = 0; i < values.length; i++) {
    if (i in values) {
      var idx = index + i;
      if (array.length < idx) array.length = idx;
      array.splice(idx, 0, values[i]);
    }
  }
  return values;
};

var remove = function remove(array, index, length) {
  return splice_.call(array, index, length);
};

var move = function move(array, from, to, length) {
  var moved = remove(array, from, length);
  insert(array, to, moved);
  return moved;
};

var patch = function patch(array, operations) {
  for (var i = 0; i < operations.length; i++) {
    var operation = operations[i];
    switch (operation.type) {
      case 'move':
        move(array, operation.from, operation.to, operation.length);break;
      case 'remove':
        remove(array, operation.index, operation.length);break;
      case 'insert':
        insert(array, operation.index, operation.values);break;
    }
  }
  return array;
};

var diff = function diff(before, after) {
  var operations = annotate(before, after);
  return offset.apply(this, operations);
};

diff.annotate = annotate;
diff.offset = offset;

diff.remove = remove;
diff.insert = insert;
diff.move = move;
diff.patch = patch;

module.exports = diff;

},{}],214:[function(require,module,exports){
/**
 * @module spotify-live/util/ordered-set
 * @private
 */
'use strict';

// prime

var prime = require('prime');

// mout
var forEach = require('mout/array/forEach');

var Range = require('../../spotify-range2');
var _diff = require('./diff');

var OrderedSet = prime({

  constructor: function constructor(length) {
    if (!length) length = 0;
    this.index = [];
    this.keys = new Array(length);
    this.values = new Array(length);
    this.objectStorage = {};
  },

  get length() {
    return this.keys.length;
  },

  set length(value) {
    this.keys.length = value;
    this.values.length = value;
  },

  forEach: function forEach(fn, ctx) {
    var index = this.index;
    main: for (var k = 0; k < index.length; k++) {
      var range = index[k];
      for (var i = range.start; i < range.end; i++) {
        if (fn.call(ctx, this.values[i], i, this.keys[i], this) === false) break main;
      }
    }
    return this;
  },

  map: function map(fn, ctx) {
    var values = new Array(this.length);
    this.forEach(function (value, index, key) {
      values[index] = fn.call(ctx, value, index, key, this);
    }, this);
    return values;
  },

  copy: function copy(set) {
    this.index = set.index.slice();
    this.keys = set.keys.slice();
    this.values = set.values.slice();
    var length = this.keys.length;
    this.objectStorage = {};
    for (var i = 0; i < length; i++) {
      this.objectStorage[this.keys[i]] = this.values[i];
    }
    return this;
  },

  clone: function clone() {
    return new OrderedSet().copy(this);
  },

  indexOf: function indexOf(key) {
    var index = -1;
    this.forEach(function (v, i, k) {
      if (key === k) {
        index = i;
        return false;
      }
    });
    return index;
  },

  indexOfMany: function indexOfMany(keys) {
    var indexedKeys = {};
    var found = 0;
    var output = [];

    // create a hash with the keys that are going to be searched, so we can
    // access them really fast later
    for (var i = 0; i < keys.length; i++) {
      indexedKeys[keys[i]] = -1;
    }

    this.forEach(function (v, i, k) {
      // If the element one that is being searched, add its position
      // to the output array
      if (k in indexedKeys) {
        indexedKeys[k] = i;
        found++;

        // when we have found all the search keys, we do not need to iterate
        // any more
        if (found >= keys.length) {
          return false;
        }
      }
    });

    for (i = 0; i < keys.length; i++) {
      output[i] = indexedKeys[keys[i]];
    }

    return output;
  },

  valueOf: function valueOf(key) {
    return this.objectStorage[key] || null;
  },

  hasKey: function hasKey(key) {
    return this.objectStorage.hasOwnProperty(key);
  },

  sort: function sort(fn) {
    var keys = this.keys;
    var values = this.values;
    var operations = _diff(values.slice(), values.sort(fn));

    forEach(operations, function (op) {
      // unless something is broken, a sort only produces moves.
      _diff.move(keys, op.from, op.to, op.length);
    });

    return this;
  },

  move: function move(from, to, length) {
    if (from > this.length) return [];
    if (from + length > this.length) length = from - this.length;
    if (to > this.length) to = this.length;
    if (from === to) return [];

    _diff.move(this.keys, from, to, length);
    _diff.move(this.values, from, to, length);

    return this;
  },

  insert: function insert(index, keys, values) {
    if (keys.length !== values.length) throw new Error('length mismatch');

    var range = new Range(index, index + keys.length);
    this.index = range.insert(this.index);

    _diff.insert(this.keys, index, keys);
    _diff.insert(this.values, index, values);

    for (var i = 0, length = keys.length; i < length; i++) {
      this.objectStorage[keys[i]] = values[i];
    }

    return this;
  },

  remove: function remove(index, length) {
    if (index >= this.length) return [];
    if (index + length > this.length) length = this.length;
    var range = new Range(index, index + length);
    this.index = range.extract(this.index);

    for (var i = 0; i < length; i++) {
      delete this.objectStorage[this.keys[i + index]];
    }
    _diff.remove(this.keys, index, length);
    _diff.remove(this.values, index, length);

    return this;
  },

  diff: function diff(target) {
    var operations = _diff.annotate(this.keys, target.keys);

    forEach(operations[0], function (op) {
      // remove
      op.keys = op.values;
      op.values = this.values.slice(op.index, op.index + op.length);
    }, this);

    forEach(operations[1], function (op) {
      // move
      op.keys = op.values;
      op.values = this.values.slice(op.from, op.from + op.length);
    }, this);

    forEach(operations[2], function (op) {
      // insert
      op.keys = op.values;
      op.values = target.values.slice(op.index, op.index + op.length);
    });

    return _diff.offset.apply(_diff, operations);
  },

  patch: function patch(operations) {
    forEach(operations, function (op) {
      switch (op.type) {
        case 'move':
          this.move(op.from, op.to, op.length);break;
        case 'remove':
          this.remove(op.index, op.length);break;
        case 'insert':
          this.insert(op.index, op.keys, op.values);break;
      }
    }, this);
    return this;
  }

});

module.exports = OrderedSet;

},{"../../spotify-range2":251,"./diff":213,"mout/array/forEach":330,"prime":375}],215:[function(require,module,exports){
/**
 * @module spotify-live/util/parser
 */
'use strict';

var normalize = function normalize(value) {
  if (value !== '' && !isNaN(value)) return +value;else if (value === 'true') return true;else if (value === 'false') return false;else if (value === 'null') return null;else if (value === 'undefined') return undefined;
  return value;
};

function escapeForRegExp(str) {
  return str.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
};

var COMMA = ',';
var BMASK = '(';
var EMASK = ')';
var BFILTER = '[';
var EFILTER = ']';
var EQUALS = '=';
var WHITESPACE = '\\s';

var operators = ['=', '!=', '>=', '<=', '>', '<', '^=', '$=', '~=', '|=', '*='];

var keyBlacklist = COMMA + BMASK + EMASK + escapeForRegExp(BFILTER) + escapeForRegExp(EFILTER) + EQUALS + WHITESPACE;
var keyBlacklistCharacterClass = '[^' + keyBlacklist + ']';

var KEY_CHARACTER_REG_EXP = new RegExp(keyBlacklistCharacterClass);
var EXACT_KEY_REG_EXP = new RegExp('^' + keyBlacklistCharacterClass + '+$');

var OPERATORS_REG_EXP = new RegExp(operators.map(escapeForRegExp).join('|'));
var REPLACE_REG_EXP = /\$([\d]+)/;
var RANGE_FILTER_REG_EXP = /^(\d*):(\d*)$/;

var parse = function parse(string, params) {
  if (!params) params = [];

  var selector = { mask: [] };
  var history = [selector];

  var key = '';
  var filter;

  var filterStr = '';
  var left = '';
  var right = '';
  var op = '';

  for (var i = 0; i < string.length + 1; i++) {
    var c = string.charAt(i);

    if (filter) {
      // parse the filter
      filterStr = filterStr.trim();
      if (c === COMMA || c === EFILTER) {
        var matches;
        if (matches = filterStr.match(RANGE_FILTER_REG_EXP)) {
          left = matches[1];
          op = ':';
          right = matches[2];
        } else if (matches = filterStr.match(OPERATORS_REG_EXP)) {
          left = filterStr.substring(0, matches.index);
          op = matches[0];
          right = filterStr.substring(matches.index + op.length);
        } else if (matches = filterStr.match(EXACT_KEY_REG_EXP)) {
          left = matches[0];
        } else {
          throw new SyntaxError('syntax error: `' + filterStr + '` contains characters not valid in a filter');
        }

        filterStr = '';

        var condition = {};

        if (left) {
          var leftMatch = left.match(REPLACE_REG_EXP);
          left = leftMatch ? params[+leftMatch[1]] : normalize(left);
          condition.left = left;
        }

        if (op) condition.op = op;

        if (right) {
          var rightMatch = right.match(REPLACE_REG_EXP);
          right = rightMatch ? params[+rightMatch[1]] : normalize(right);
          condition.right = right;
        }

        if ('left' in condition || 'right' in condition) filter.push(condition);

        right = '';
        left = '';
        op = '';

        if (c === EFILTER) {
          if (filter.length) {
            var filters = selector.filters || (selector.filters = []);
            filters.push(filter);
          }

          filter = null;
        }
        continue;
      }

      filterStr += c;
    } else {
      // parse the key

      if (c && KEY_CHARACTER_REG_EXP.test(c)) {
        // key
        key += c;
      } else if (key && (!c || c === COMMA || c === BMASK || c === BFILTER || c === EMASK)) {
        // end key
        // end word is "a!" or "b(a!)" or "a!,c" or "a!(" or "a!["
        var keyMatch = key.match(REPLACE_REG_EXP);
        // begin a new selector
        history[0].mask.push(selector = { key: keyMatch ? params[+keyMatch[1]] : normalize(key) });
        key = '';
      } else if (c && key) {
        throw new SyntaxError('syntax error: `' + c + '` is not a valid character in a key');
      }

      if (c === BMASK) {
        selector.mask = [];
        history.unshift(selector);
      } else if (c === EMASK) {
        history.shift();
      }

      if (c === BFILTER) {
        filter = [];
      }
    }
  }

  if (history.length !== 1) throw new SyntaxError('syntax error');

  return history[0];
};

/** exports */
module.exports = parse;

},{}],216:[function(require,module,exports){
/**
 * @module spotify-live/util/throttle
 * @private
 */
'use strict';

var defer = require('prime/defer');
var isInteger = function isInteger(n) {
  return typeof n === 'number' && n % 1 === 0;
};

var slice = Array.prototype.slice;

var _throttle = function _throttle(fn, method, context) {
  var queued, args, cancel;

  return function () {
    args = arguments;
    if (!queued) {
      queued = true;
      cancel = method(function (time) {
        queued = false;
        fn.apply(context, slice.call(args).concat(time));
      });
    }
    return cancel;
  };
};

var throttle = function throttle(callback, argument, context) {
  if (isInteger(argument)) return throttle.timeout(callback, argument, context);else return throttle.immediate(callback, argument);
};

throttle.timeout = function (callback, ms, context) {
  return _throttle(callback, function (run) {
    return defer.timeout(run, ms, context);
  }, context);
};

throttle.frame = function (callback, context) {
  return _throttle(callback, function (run) {
    return defer.frame(run, context);
  }, context);
};

throttle.immediate = function (callback, context) {
  return _throttle(callback, function (run) {
    return defer.immediate(run, context);
  }, context);
};

module.exports = throttle;

},{"prime/defer":373}],217:[function(require,module,exports){
(function (global){
'use strict';

var bridge = require('../spotify-bridge-request');
var namespace;
var async = require('async');
var libUri = require('spotify-liburi');

var SEPARATOR = ':';

function getNamespace(callback) {
  if (namespace) {
    callback(null, namespace);
    return;
  }

  async.parallel([function getAppId(callback) {
    bridge.request('application_query', [], function (error, payload) {
      if (error) {
        callback(error);
        return;
      }
      var app = libUri.fromString(payload.uri);
      if (!app || !app.id) {
        callback(new error('App URI could not be parsed'));
        return;
      }

      callback(null, app.id);
    });
  }, function getUsername(callback) {
    if (global.__spotify && global.__spotify.username) {
      callback(null, global.__spotify.username);
      return;
    }

    bridge.request('user_metadata', ['spotify:user:@'], function (error, payload) {
      callback(error, payload && payload.username);
    });
  }], function (error, results) {
    if (!error) {
      var appId = results[0];
      var userId = encodeURIComponent(results[1]);
      namespace = appId + SEPARATOR + userId + SEPARATOR;
    }
    callback(error, namespace);
  });
}

function set(key, value, callback) {
  getNamespace(function (error, namespace) {
    if (error) {
      if (callback) callback(error);
      return;
    }

    global.localStorage.setItem(namespace + key, value);
    if (callback) callback();
  });
}

function get(key, callback) {
  getNamespace(function (error, namespace) {
    if (error) {
      if (callback) callback(error);
      return;
    }

    callback(null, global.localStorage.getItem(namespace + key));
  });
}

function remove(key, callback) {
  getNamespace(function (error, namespace) {
    if (error) {
      if (callback) callback(error);
      return;
    }

    global.localStorage.removeItem(namespace + key);
    if (callback) callback(null);
  });
}

function clear(callback) {
  if (!namespace) {
    if (callback) callback(null);
    return;
  }

  var keys = Object.keys(global.localStorage);
  for (var i = 0, key; key = keys[i]; i++) {
    if (key.indexOf(namespace) === 0) {
      delete global.localStorage[key];
    }
  }

  if (callback) callback(null);
}

function _setNamespace(value) {
  namespace = value;
}

var storage = {
  set: set,
  get: get,
  remove: remove,
  clear: clear,
  _setNamespace: _setNamespace
};

module.exports = storage;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-bridge-request":38,"async":280,"spotify-liburi":398}],218:[function(require,module,exports){
'use strict';

var languages = require('./languages.json');

function lookup(language, to) {
  var lang = languages[language];
  if (lang[to]) {
    return lang[to];
  } else {
    return language;
  }
}

module.exports = lookup;
module.exports.all = function () {
  return Object.keys(languages);
};

},{"./languages.json":219}],219:[function(require,module,exports){
module.exports={
  "de": {
    "smartling": "de-DE"
  },
  "el": {
    "smartling": "el-GR"
  },
  "en": {
    "smartling": "en-GB"
  },
  "es": {
    "numeral": "es-ES",
    "smartling": "es-ES"
  },
  "es-419": {
    "moment": "es",
    "numeral": "es-ES",
    "smartling": "es-LA"
  },
  "fi": {
    "smartling": "fi-FI"
  },
  "fr": {
    "smartling": "fr-FR"
  },
  "fr-CA": {
    "smartling": "fr-CA",
    "moment": "fr-ca"
  },
  "hu": {
    "smartling": "hu-HU"
  },
  "id": {
    "smartling": "id-ID"
  },
  "it": {
    "smartling": "it-IT"
  },
  "ja": {
    "smartling": "ja-JP"
  },
  "nl": {
    "numeral": "nl-nl",
    "smartling": "nl-NL"
  },
  "pl": {
    "smartling": "pl-PL"
  },
  "pt-BR": {
    "moment": "pt-br",
    "numeral": "pt-br",
    "smartling": "pt-BR"
  },
  "sv": {
    "smartling": "sv-SE"
  },
  "tr": {
    "smartling": "tr-TR"
  },
  "zh-Hant": {
    "moment": "zh-tw",
    "smartling": "zh-TW"
  },
  "zsm": {
    "moment": "ms-my",
    "smartling": "ms-MY"
  }
}
},{}],220:[function(require,module,exports){
'use strict';

var schemer = require('./schemer');
var cosmos = require('spotify-cosmos-api');
var debug = require('debug');

var id = 0;

module.exports = function log(schema, data) {
  /*eslint-disable camelcase */
  var body = schemer(schema, Object.assign({}, {
    message_name: schema.name,
    message_version: schema.schema_version
  }, data));

  // Logging cosmos endpoint requires all values to be strings.
  body.fields = body.fields.map(function (f) {
    if (typeof f === 'string') return f;
    if (f == null) return '';
    return JSON.stringify(f);
  });

  var qualifiedName = schema.name + schema.schema_version;
  /*eslint-enable camelcase */

  var messageDebug = debug('spotify-logger:' + qualifiedName);
  var requestId = ++id;

  messageDebug('REQ %s#%s %s', qualifiedName, requestId, JSON.stringify(body));

  cosmos.resolver.post({
    url: 'sp://logging/v1/log',
    body: body
  }, function (error, response) {
    if (error) return console.error(error, body);
    messageDebug('RES %s#%s %d', qualifiedName, requestId, response.getStatusCode());
  });
};

},{"./schemer":221,"debug":287,"spotify-cosmos-api":388}],221:[function(require,module,exports){
'use strict';

var validation = require('../vendor/avro-trunk/lang/js/lib/validator');
var debug = require('debug')(require('../package.json').name + ':');

module.exports = function (schema, data) {

  debug(schema.name);

  var name = data.message_name;
  var version = data.message_version;
  var copy = Object.assign({}, data);

  if (version !== schema.schema_version) throw new Error('' + 'Invalid message version: received Message with message_version ' + version + ' but the Schema requires version ' + schema.schema_version);

  // Create positional array of field values as required by cosmos and
  // log-parser, and also create an avro Field for each value to allow
  // validation.
  var fields = schema.fields.map(function (f) {
    var type = f.type;
    var value = copy[f.name];

    // If field is a union, attempt to infer the type by grabbing the first
    // non-null type from the schema.
    if (Array.isArray(f.type)) {
      copy[f.name] = {};
      var firstNoneNullType = type.filter(function (t) {
        return t !== 'null';
      })[0];
      copy[f.name][firstNoneNullType] = value;
      debug('union `%s` (%s) : `%s`', f.name, firstNoneNullType, value);
    } else {
      copy[f.name] = value;
      debug('field `%s` : `%s`', f.name, value);
    }
    return value === undefined ? f.default : value;
  })
  // remove name, version
  .slice(2);

  validation.Validator.validate(schema, copy);

  return {
    message: name,
    version: version,
    fields: fields
  };
};

module.exports.Validator = validation.Validator;
module.exports.ProtocolValidator = validation.ProtocolValidator;

},{"../package.json":225,"../vendor/avro-trunk/lang/js/lib/validator":229,"debug":287}],222:[function(require,module,exports){
'use strict';

var schema = require('../schemas/ClientEvent3.json');
var log = require('../lib/log');

module.exports = {
  schema: schema,
  log: log.bind(null, schema)
};

},{"../lib/log":220,"../schemas/ClientEvent3.json":226}],223:[function(require,module,exports){
'use strict';

var schema = require('../schemas/UIInteraction4.json');
var log = require('../lib/log');

module.exports = {
  schema: schema,
  log: log.bind(null, schema)
};

},{"../lib/log":220,"../schemas/UIInteraction4.json":227}],224:[function(require,module,exports){
'use strict';

var schema = require('../schemas/UserDragAndDropInteraction1.json');
var log = require('../lib/log');

module.exports = {
  schema: schema,
  log: log.bind(null, schema)
};

},{"../lib/log":220,"../schemas/UserDragAndDropInteraction1.json":228}],225:[function(require,module,exports){
module.exports={
  "name": "spotify-logger",
  "version": "1.0.0",
  "description": "Generate / consume log-parser schemas in JS",
  "bin": {
    "spotify-logger-schemas-generator": "bin/schemas-generator",
    "spotify-logger-messages-generator": "bin/messages-generator"
  },
  "main": "lib/log.js",
  "dependencies": {},
  "devDependencies": {},
  "scripts": {
    "dev": "echo App scripts have been removed. Please see docs/app-development.md for more information. && exit 1",
    "prod": "echo App scripts have been removed. Please see docs/app-development.md for more information. && exit 1",
    "spa": "echo App scripts have been removed. Please see docs/app-development.md for more information. && exit 1",
    "enable": "echo App scripts have been removed. Please see docs/app-development.md for more information. && exit 1"
  },
  "author": "Drew Petersen <drewp@spotify.com>",
  "license": "UNLICENSED",
  "private": true
}
},{}],226:[function(require,module,exports){
module.exports={
  "type": "record",
  "name": "ClientEvent",
  "namespace": "com.spotify.Message",
  "doc": "A generic client event primarily used by Stitch Apps",
  "fields": [
    {
      "name": "message_name",
      "type": "string"
    },
    {
      "name": "message_version",
      "type": "int"
    },
    {
      "name": "source",
      "type": [
        "null",
        "string"
      ],
      "doc": "Source which generated the event, will mostly be set to the App-ID",
      "default": null
    },
    {
      "name": "context",
      "type": [
        "null",
        "string"
      ],
      "doc": "Optional context within the app",
      "default": null
    },
    {
      "name": "event",
      "type": [
        "null",
        "string"
      ],
      "doc": "Event name",
      "default": null
    },
    {
      "name": "event_version",
      "type": [
        "null",
        "string"
      ],
      "doc": "Optional event version, can be used as a version or sub-type",
      "default": null
    },
    {
      "name": "test_version",
      "type": [
        "null",
        "string"
      ],
      "doc": "Optional test case if A/B testing",
      "default": null
    },
    {
      "name": "source_version",
      "type": [
        "null",
        "string"
      ],
      "doc": "The version of the app",
      "default": null
    },
    {
      "name": "source_vendor",
      "type": [
        "null",
        "string"
      ],
      "doc": "The app vendor",
      "default": null
    },
    {
      "name": "json_data",
      "type": [
        "null",
        "string"
      ],
      "doc": "Additional JSON data specific to the event being sent",
      "default": null
    }
  ],
  "schema_version": 3
}
},{}],227:[function(require,module,exports){
module.exports={
  "type": "record",
  "name": "UIInteraction",
  "namespace": "com.spotify.Message",
  "doc": "A UI interaction log",
  "fields": [
    {
      "name": "message_name",
      "type": "string"
    },
    {
      "name": "message_version",
      "type": "int"
    },
    {
      "name": "request_id",
      "type": [
        "null",
        "string"
      ],
      "doc": "Request ID from Spaces Log",
      "default": null
    },
    {
      "name": "feature_id",
      "type": [
        "null",
        "string"
      ],
      "doc": "Uri of the feature page (e.g., Music, Start Page, etc.)",
      "default": null
    },
    {
      "name": "section_id",
      "type": [
        "null",
        "string"
      ],
      "doc": "Section or block of the page (e.g., Early Morning)",
      "default": null
    },
    {
      "name": "block_index",
      "type": [
        "null",
        "int"
      ],
      "doc": "Index of block on page",
      "default": null
    },
    {
      "name": "item_index",
      "type": [
        "null",
        "int"
      ],
      "doc": "Index of item in block",
      "default": null
    },
    {
      "name": "target_uri",
      "type": [
        "null",
        "string"
      ],
      "doc": "Destination of interaction",
      "default": null
    },
    {
      "name": "interaction_type",
      "type": [
        "null",
        "string"
      ],
      "doc": "Type of interaction (e.g., hit, swipe, hold, hover, etc.)",
      "default": null
    },
    {
      "name": "user_intent",
      "type": [
        "null",
        "string"
      ],
      "doc": "Grouping of interactions based on user intent (e.g., play, navigate-forward, navigate-back)",
      "default": null
    },
    {
      "name": "timestamp",
      "type": [
        "null",
        "double"
      ],
      "doc": "Unix timestamp of event",
      "default": null
    }
  ],
  "schema_version": 4
}
},{}],228:[function(require,module,exports){
module.exports={
  "type": "record",
  "name": "UserDragAndDropInteraction",
  "namespace": "com.spotify.Message",
  "doc": "Logged whenever a user drags and drops (currently desktop only) an item in the client. Only completed drag and drops are logged and not canceled/failed ones.",
  "fields": [
    {
      "name": "message_name",
      "type": "string"
    },
    {
      "name": "message_version",
      "type": "int"
    },
    {
      "name": "item_type",
      "type": [
        "null",
        "string"
      ],
      "doc": "Type of item, eg \"track\".",
      "default": null
    },
    {
      "name": "item_uri",
      "type": [
        "null",
        "string"
      ],
      "doc": "Uri of item that was dropped and only the first if multiple.",
      "default": null
    },
    {
      "name": "number_items",
      "type": [
        "null",
        "long"
      ],
      "doc": "Number of items dropped.",
      "default": null
    },
    {
      "name": "source_view_uri",
      "type": [
        "null",
        "string"
      ],
      "doc": "View uri from where the drag started, eg \"spotify:app:playlist-desktop\".",
      "default": null
    },
    {
      "name": "source_uri",
      "type": [
        "null",
        "string"
      ],
      "doc": "Uri of the context from where the drag started, eg: \"spotify:user:spotify:playlist:1m6DKwKNM1YLcm3OX6RzJg\".",
      "default": null
    },
    {
      "name": "source_index",
      "type": [
        "null",
        "long"
      ],
      "doc": "Index of the item from where the drag started.",
      "default": null
    },
    {
      "name": "source_component",
      "type": [
        "null",
        "string"
      ],
      "doc": "Id of the component from where the drag started, eg: \"header/title\" if the user dragged a playlist via the playlist title in the header.",
      "default": null
    },
    {
      "name": "target_view_uri",
      "type": [
        "null",
        "string"
      ],
      "doc": "View uri where the drop ended, eg \"spotify:app:zlink\".",
      "default": null
    },
    {
      "name": "target_uri",
      "type": [
        "null",
        "string"
      ],
      "doc": "Uri of the context where the drop ended, \"spotify:user:spotify:rootlist\".",
      "default": null
    },
    {
      "name": "target_index",
      "type": [
        "null",
        "long"
      ],
      "doc": "Index where dropped.",
      "default": null
    },
    {
      "name": "target_component",
      "type": [
        "null",
        "string"
      ],
      "doc": "Id of the component where the drop ended, eg: \"player/queue\" if dropped on the Queue button in the player component.",
      "default": null
    },
    {
      "name": "ms_duration",
      "type": [
        "null",
        "long"
      ],
      "doc": "The duration in milliseconds from the start of the drag until the end of the drop.",
      "default": null
    }
  ],
  "schema_version": 1
}
},{}],229:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

// Licensed to the Apache Software Foundation (ASF) under one or more
// contributor license agreements.  See the NOTICE file distributed with
// this work for additional information regarding copyright ownership.
// The ASF licenses this file to You under the Apache License, Version 2.0
// (the "License"); you may not use this file except in compliance with
// the License.  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

if (typeof require !== 'undefined') {
  var _ = require("underscore");
}

var AvroSpec = {
  PrimitiveTypes: ['null', 'boolean', 'int', 'long', 'float', 'double', 'bytes', 'string'],
  ComplexTypes: ['record', 'enum', 'array', 'map', 'union', 'fixed']
};
AvroSpec.Types = AvroSpec.PrimitiveTypes.concat(AvroSpec.ComplexTypes);

var InvalidSchemaError = function InvalidSchemaError(msg) {
  return new Error('InvalidSchemaError: ' + msg);
};
var InvalidProtocolError = function InvalidProtocolError(msg) {
  return new Error('InvalidProtocolError: ' + msg);
};
var ValidationError = function ValidationError(msg) {
  return new Error('ValidationError: ' + msg);
};
var ProtocolValidationError = function ProtocolValidationError(msg) {
  return new Error('ProtocolValidationError: ' + msg);
};

function Record(name, namespace, fields) {
  function validateArgs(name, namespace, fields) {
    if (!_.isString(name)) {
      throw new InvalidSchemaError('Record name must be string');
    }

    if (!_.isNull(namespace) && !_.isUndefined(namespace) && !_.isString(namespace)) {
      throw new InvalidSchemaError('Record namespace must be string or null');
    }

    if (!_.isArray(fields)) {
      throw new InvalidSchemaError('Record name must be string');
    }
  }

  validateArgs(name, namespace, fields);

  this.name = name;
  this.namespace = namespace;
  this.fields = fields;
}

function makeFullyQualifiedTypeName(schema, namespace) {
  var typeName = null;
  if (_.isString(schema)) {
    typeName = schema;
  } else if (_.isObject(schema)) {
    if (_.isString(schema.namespace)) {
      namespace = schema.namespace;
    }
    if (_.isString(schema.name)) {
      typeName = schema.name;
    } else if (_.isString(schema.type)) {
      typeName = schema.type;
    }
    /** BEGIN CHANGE BY drewp **/
    else if (_.has(schema, 'valueSchema') && _.isString(schema.valueSchema.type)) {
        typeName = makeFullyQualifiedTypeName(schema.valueSchema, namespace);
      }
    /** END CHANGE BY drewp **/
  } else {
      throw new InvalidSchemaError('unable to determine fully qualified type name from schema ' + JSON.stringify(schema) + ' in namespace ' + namespace);
    }

  if (!_.isString(typeName)) {
    throw new InvalidSchemaError('unable to determine type name from schema ' + JSON.stringify(schema) + ' in namespace ' + namespace);
  }

  if (typeName.indexOf('.') !== -1) {
    return typeName;
  } else if (_.contains(AvroSpec.PrimitiveTypes, typeName)) {
    return typeName;
  } else if (_.isString(namespace)) {
    return namespace + '.' + typeName;
  } else {
    return typeName;
  }
}

function Union(typeSchemas, namespace) {
  this.branchNames = function () {
    return _.map(typeSchemas, function (typeSchema) {
      return makeFullyQualifiedTypeName(typeSchema, namespace);
    });
  };

  function validateArgs(typeSchemas) {
    if (!_.isArray(typeSchemas) || _.isEmpty(typeSchemas)) {
      throw new InvalidSchemaError('Union must have at least 1 branch');
    }
  }

  validateArgs(typeSchemas);

  this.typeSchemas = typeSchemas;
  this.namespace = namespace;
}

function Enum(symbols) {

  function validateArgs(symbols) {
    if (!_.isArray(symbols)) {
      throw new InvalidSchemaError('Enum must have array of symbols, got ' + JSON.stringify(symbols));
    }
    if (!_.all(symbols, function (symbol) {
      return _.isString(symbol);
    })) {
      throw new InvalidSchemaError('Enum symbols must be strings, got ' + JSON.stringify(symbols));
    }
  }

  validateArgs(symbols);

  this.symbols = symbols;
}

function AvroArray(itemSchema) {

  function validateArgs(itemSchema) {
    if (_.isNull(itemSchema) || _.isUndefined(itemSchema)) {
      throw new InvalidSchemaError('Array "items" schema should not be null or undefined');
    }
  }

  validateArgs(itemSchema);

  this.itemSchema = itemSchema;
}

function Map(valueSchema) {
  function validateArgs(valueSchema) {
    if (_.isNull(valueSchema) || _.isUndefined(valueSchema)) {
      throw new InvalidSchemaError('Map "values" schema should not be null or undefined');
    }
  }

  validateArgs(valueSchema);

  this.valueSchema = valueSchema;
}

function Field(name, schema) {
  function validateArgs(name, schema) {
    if (!_.isString(name)) {
      throw new InvalidSchemaError('Field name must be string');
    }
  }

  this.name = name;
  this.schema = schema;
}

function Primitive(type) {
  function validateArgs(type) {
    if (!_.isString(type)) {
      throw new InvalidSchemaError('Primitive type name must be a string');
    }

    if (!_.contains(AvroSpec.PrimitiveTypes, type)) {
      throw new InvalidSchemaError('Primitive type must be one of: ' + JSON.stringify(AvroSpec.PrimitiveTypes) + '; got ' + type);
    }
  }

  validateArgs(type);

  this.type = type;
}

function Validator(schema, namespace, namedTypes) {
  this.validate = function (obj) {
    return _validate(this.schema, obj);
  };

  var _validate = function _validate(schema, obj) {
    if (schema instanceof Record) {
      return _validateRecord(schema, obj);
    } else if (schema instanceof Union) {
      return _validateUnion(schema, obj);
    } else if (schema instanceof Enum) {
      return _validateEnum(schema, obj);
    } else if (schema instanceof AvroArray) {
      return _validateArray(schema, obj);
    } else if (schema instanceof Map) {
      return _validateMap(schema, obj);
    } else if (schema instanceof Primitive) {
      return _validatePrimitive(schema, obj);
    } else {
      throw new InvalidSchemaError('validation not yet implemented: ' + JSON.stringify(schema));
    }
  };

  var _validateRecord = function _validateRecord(schema, obj) {
    if (!_.isObject(obj) || _.isArray(obj)) {
      throw new ValidationError('Expected record Javascript type to be non-array object, got ' + JSON.stringify(obj));
    }

    var schemaFieldNames = _.pluck(schema.fields, 'name').sort();
    var objFieldNames = _.keys(obj).sort();
    if (!_.isEqual(schemaFieldNames, objFieldNames)) {
      throw new ValidationError('Expected record fields ' + JSON.stringify(schemaFieldNames) + '; got ' + JSON.stringify(objFieldNames));
    }

    return _.all(schema.fields, function (field) {
      return _validate(field.schema, obj[field.name]);
    });
  };

  var _validateUnion = function _validateUnion(schema, obj) {
    if (_.isObject(obj)) {
      if (_.isArray(obj)) {
        throw new ValidationError('Expected union Javascript type to be non-array object (or null), got ' + JSON.stringify(obj));
      } else if (_.size(obj) !== 1) {
        throw new ValidationError('Expected union Javascript object to be object with exactly 1 key (or null), got ' + JSON.stringify(obj));
      } else {
        var unionBranch = _.keys(obj)[0];
        if (unionBranch === "") {
          throw new ValidationError('Expected union Javascript object to contain non-empty string branch, got ' + JSON.stringify(obj));
        }
        if (_.contains(schema.branchNames(), unionBranch)) {
          return true;
        } else {
          throw new ValidationError('Expected union branch to be one of ' + JSON.stringify(schema.branchNames()) + '; got ' + JSON.stringify(unionBranch));
        }
      }
    } else if (_.isNull(obj)) {
      if (_.contains(schema.branchNames(), 'null')) {
        return true;
      } else {
        throw new ValidationError('Expected union branch to be one of ' + JSON.stringify(schema.branchNames()) + '; got ' + JSON.stringify(obj));
      }
    } else {
      throw new ValidationError('Expected union Javascript object to be non-array object of size 1 or null, got ' + JSON.stringify(obj));
    }
  };

  var _validateEnum = function _validateEnum(schema, obj) {
    if (_.isString(obj)) {
      if (_.contains(schema.symbols, obj)) {
        return true;
      } else {
        throw new ValidationError('Expected enum value to be one of ' + JSON.stringify(schema.symbols) + '; got ' + JSON.stringify(obj));
      }
    } else {
      throw new ValidationError('Expected enum Javascript object to be string, got ' + JSON.stringify(obj));
    }
  };

  var _validateArray = function _validateArray(schema, obj) {
    if (_.isArray(obj)) {
      return _.all(obj, function (member) {
        return _validate(schema.itemSchema, member);
      });
    } else {
      throw new ValidationError('Expected array Javascript object to be array, got ' + JSON.stringify(obj));
    }
  };

  var _validateMap = function _validateMap(schema, obj) {
    if (_.isObject(obj) && !_.isArray(obj)) {
      return _.all(obj, function (value) {
        return _validate(schema.valueSchema, value);
      });
    } else if (_.isArray(obj)) {
      throw new ValidationError('Expected map Javascript object to be non-array object, got array ' + JSON.stringify(obj));
    } else {
      throw new ValidationError('Expected map Javascript object to be non-array object, got ' + JSON.stringify(obj));
    }
  };

  var _validatePrimitive = function _validatePrimitive(schema, obj) {
    switch (schema.type) {
      case 'null':
        if (_.isNull(obj) || _.isUndefined(obj)) {
          return true;
        } else {
          throw new ValidationError('Expected Javascript null or undefined for Avro null, got ' + JSON.stringify(obj));
        }
        break;
      case 'boolean':
        if (_.isBoolean(obj)) {
          return true;
        } else {
          throw new ValidationError('Expected Javascript boolean for Avro boolean, got ' + JSON.stringify(obj));
        }
        break;
      case 'int':
        if (_.isNumber(obj) && Math.floor(obj) === obj && Math.abs(obj) <= Math.pow(2, 31)) {
          return true;
        } else {
          throw new ValidationError('Expected Javascript int32 number for Avro int, got ' + JSON.stringify(obj));
        }
        break;
      case 'long':
        if (_.isNumber(obj) && Math.floor(obj) === obj && Math.abs(obj) <= Math.pow(2, 63)) {
          return true;
        } else {
          throw new ValidationError('Expected Javascript int64 number for Avro long, got ' + JSON.stringify(obj));
        }
        break;
      case 'float':
        if (_.isNumber(obj)) {
          // TODO: handle NaN?
          return true;
        } else {
          throw new ValidationError('Expected Javascript float number for Avro float, got ' + JSON.stringify(obj));
        }
        break;
      case 'double':
        if (_.isNumber(obj)) {
          // TODO: handle NaN?
          return true;
        } else {
          throw new ValidationError('Expected Javascript double number for Avro double, got ' + JSON.stringify(obj));
        }
        break;
      case 'bytes':
        throw new InvalidSchemaError('not yet implemented: ' + schema.type);
      case 'string':
        if (_.isString(obj)) {
          // TODO: handle NaN?
          return true;
        } else {
          throw new ValidationError('Expected Javascript string for Avro string, got ' + JSON.stringify(obj));
        }
        break;
      default:
        throw new InvalidSchemaError('unrecognized primitive type: ' + schema.type);
    }
  };

  // TODO: namespace handling is rudimentary. multiple namespaces within a certain nested schema definition
  // are probably buggy.
  var _namedTypes = namedTypes || {};
  var _saveNamedType = function _saveNamedType(fullyQualifiedTypeName, schema) {
    if (_.has(_namedTypes, fullyQualifiedTypeName)) {
      if (!_.isEqual(_namedTypes[fullyQualifiedTypeName], schema)) {
        throw new InvalidSchemaError('conflicting definitions for type ' + fullyQualifiedTypeName + ': ' + JSON.stringify(_namedTypes[fullyQualifiedTypeName]) + ' and ' + JSON.stringify(schema));
      }
    } else {
      _namedTypes[fullyQualifiedTypeName] = schema;
    }
  };

  var _lookupTypeByFullyQualifiedName = function _lookupTypeByFullyQualifiedName(fullyQualifiedTypeName) {
    if (_.has(_namedTypes, fullyQualifiedTypeName)) {
      return _namedTypes[fullyQualifiedTypeName];
    } else {
      return null;
    }
  };

  var _parseNamedType = function _parseNamedType(schema, namespace) {
    if (_.contains(AvroSpec.PrimitiveTypes, schema)) {
      return new Primitive(schema);
    } else if (!_.isNull(_lookupTypeByFullyQualifiedName(makeFullyQualifiedTypeName(schema, namespace)))) {
      return _lookupTypeByFullyQualifiedName(makeFullyQualifiedTypeName(schema, namespace));
    } else {
      throw new InvalidSchemaError('unknown type name: ' + JSON.stringify(schema) + '; known type names are ' + JSON.stringify(_.keys(_namedTypes)));
    }
  };

  var _parseSchema = function _parseSchema(schema, parentSchema, namespace) {
    if (_.isNull(schema) || _.isUndefined(schema)) {
      throw new InvalidSchemaError('schema is null, in parentSchema: ' + JSON.stringify(parentSchema));
    } else if (_.isString(schema)) {
      return _parseNamedType(schema, namespace);
    } else if (_.isObject(schema) && !_.isArray(schema)) {
      if (schema.type === 'record') {
        var newRecord = new Record(schema.name, schema.namespace, _.map(schema.fields, function (field) {
          return new Field(field.name, _parseSchema(field.type, schema, schema.namespace || namespace));
        }));
        _saveNamedType(makeFullyQualifiedTypeName(schema, namespace), newRecord);
        return newRecord;
      } else if (schema.type === 'enum') {
        if (_.has(schema, 'symbols')) {
          var newEnum = new Enum(schema.symbols);
          _saveNamedType(makeFullyQualifiedTypeName(schema, namespace), newEnum);
          return newEnum;
        } else {
          throw new InvalidSchemaError('enum must specify symbols, got ' + JSON.stringify(schema));
        }
      } else if (schema.type === 'array') {
        if (_.has(schema, 'items')) {
          return new AvroArray(_parseSchema(schema.items, schema, namespace));
        } else {
          throw new InvalidSchemaError('array must specify "items" schema, got ' + JSON.stringify(schema));
        }
      } else if (schema.type === 'map') {
        if (_.has(schema, 'values')) {
          return new Map(_parseSchema(schema.values, schema, namespace));
        } else {
          throw new InvalidSchemaError('map must specify "values" schema, got ' + JSON.stringify(schema));
        }
      } else if (_.has(schema, 'type') && _.contains(AvroSpec.PrimitiveTypes, schema.type)) {
        return _parseNamedType(schema.type, namespace);
      } else {
        throw new InvalidSchemaError('not yet implemented: ' + schema.type);
      }
    } else if (_.isArray(schema)) {
      if (_.isEmpty(schema)) {
        throw new InvalidSchemaError('unions must have at least 1 branch');
      }
      var branchTypes = _.map(schema, function (branchType) {
        return _parseSchema(branchType, schema, namespace);
      });
      return new Union(branchTypes, namespace);
    } else {
      throw new InvalidSchemaError('unexpected Javascript type for schema: ' + (typeof schema === 'undefined' ? 'undefined' : _typeof(schema)));
    }
  };

  this.rawSchema = schema;
  this.schema = _parseSchema(schema, null, namespace);
}

Validator.validate = function (schema, obj) {
  return new Validator(schema).validate(obj);
};

function ProtocolValidator(protocol) {
  this.validate = function (typeName, obj) {
    var fullyQualifiedTypeName = makeFullyQualifiedTypeName(typeName, protocol.namespace);
    if (!_.has(_typeSchemaValidators, fullyQualifiedTypeName)) {
      throw new ProtocolValidationError('Protocol does not contain definition for type ' + JSON.stringify(fullyQualifiedTypeName) + ' (fully qualified from input "' + typeName + '"); known types are ' + JSON.stringify(_.keys(_typeSchemaValidators)));
    }
    return _typeSchemaValidators[fullyQualifiedTypeName].validate(obj);
  };

  var _typeSchemaValidators = {};
  var _initSchemaValidators = function _initSchemaValidators(protocol) {
    var namedTypes = {};
    if (!_.has(protocol, 'protocol') || !_.isString(protocol.protocol)) {
      throw new InvalidProtocolError('Protocol must contain a "protocol" attribute with a string value');
    }
    if (_.isArray(protocol.types)) {
      _.each(protocol.types, function (typeSchema) {
        var schemaValidator = new Validator(typeSchema, protocol.namespace, namedTypes);
        var fullyQualifiedTypeName = makeFullyQualifiedTypeName(typeSchema, protocol.namespace);
        _typeSchemaValidators[fullyQualifiedTypeName] = schemaValidator;
      });
    }
  };

  _initSchemaValidators(protocol);
}

ProtocolValidator.validate = function (protocol, typeName, obj) {
  return new ProtocolValidator(protocol).validate(typeName, obj);
};

if (typeof exports !== 'undefined') {
  exports['Validator'] = Validator;
  exports['ProtocolValidator'] = ProtocolValidator;
}

},{"underscore":419}],230:[function(require,module,exports){
'use strict';

/**
 * Object representing state of an app.
 *
 * @param {String} uri Spotify URI of app.
 * @constructor
 */

function AppState(uri) {
  /**
   * Spotify URI.
   *
   * @type {String}
   */
  this._uri = undefined;

  /**
   * String identifying what requested a state.
   *
   * @type {String}
   */
  this._referrer = undefined;

  if (uri !== undefined) {
    this.setURI(uri);
  }
}

/**
 * Create new instance of AppState based on JSON string.
 *
 * @param {String} json Serialized representation of AppState object.
 * @return {AppState} Instance of AppState.
 */
AppState.unserialize = function (json) {
  var s = JSON.parse(json);
  var a = new AppState();
  a.setURI(s.uri);
  a.setReferrer(s.referrer);
  return a;
};

/**
 * Test if another object is considered equal to this.
 *
 * @param {AppState} state AppState instance to compare.
 */
AppState.prototype.equals = function (state) {
  return typeof this._uri === 'string' && state instanceof AppState && this._uri === state._uri && this._referrer === state._referrer;
};

/**
 * Get App identifier.
 *
 * @return {String} Id of app contained in URI.
 */
AppState.prototype.getAppId = function () {
  var uri = this.getURI();
  var parts = uri.split(':');
  if (parts.length < 3) {
    return undefined;
  }
  if (parts[1] !== 'app') {
    return undefined;
  }
  if (parts[2] === '') {
    return undefined;
  }
  return parts[2];
};

/**
 * Get Referrer value.
 *
 * @return {String} Referrer value as string.
 */
AppState.prototype.getReferrer = function () {
  return this._referrer;
};

/**
 * Get URI value.
 *
 * @return {String} URI as string.
 */
AppState.prototype.getURI = function () {
  if (this._uri === undefined) {
    throw new Error('URI not set');
  }
  return this._uri;
};

/**
 * Create serialized representation of this instance.
 *
 * @return {String} Serialized representation of AppState object.
 */
AppState.prototype.serialize = function () {
  return JSON.stringify({
    uri: this.getURI(),
    referrer: this.getReferrer()
  });
};

/**
 * Set Referrer value.
 *
 * @param {String} referrer Referrer string.
 */
AppState.prototype.setReferrer = function (referrer) {
  this._referrer = referrer;
};

/**
 * Set URI value.
 *
 * @param {String} uri Spotify URI for app.
 */
AppState.prototype.setURI = function (uri) {
  if (typeof uri !== 'string') {
    throw new TypeError('URI must be string');
  }
  this._uri = uri;
};

module.exports = AppState;

},{}],231:[function(require,module,exports){
'use strict';

module.exports = {
  AppState: require('./app-state'),
  Navigator: require('./navigator')
};

},{"./app-state":230,"./navigator":232}],232:[function(require,module,exports){
(function (global){
'use strict';

var inherit = require('spotify-inheritance/inherit');
var EventEmitter = require('spotify-eventemitter');
var AppState = require('./app-state');
var _global = global.top || global;

/**
 * Class containing methods for navigating.
 *
 * @constructor
 */
function Navigator() {
  EventEmitter.call(this);

  /**
   * Locally bound handler function for message event on global.
   *
   * @type {Function}
   */
  this._messageHandler = this._messageHandler.bind(this);
}

inherit(Navigator, EventEmitter);

/**
 * Maps constants to string values of known events.
 */
Navigator.EVENTS = {
  OPEN_STATE: 'navigation_open_state'
};

/**
 * Identify posted message and trigger relevant callbacks
 * based on the message contents.
 *
 * @param {Object} message Message object caused by postMessage.
 */
Navigator.prototype._messageHandler = function (message) {
  if (!message.data.type) {
    return;
  }
  var name = message.data.type;
  if (name === Navigator.EVENTS.OPEN_STATE) {
    var appState = AppState.unserialize(message.data.state);
    this.emitSync(name, { state: appState });
  }
};

/**
 * Start listening to messages.
 */
Navigator.prototype.attachListener = function () {
  _global.addEventListener('message', this._messageHandler);
};

/**
 * Stop listening to messages.
 */
Navigator.prototype.detachListener = function () {
  _global.removeEventListener('message', this._messageHandler);
};

/**
 * Send an open request message.
 *
 * @param {AppState} state AppState instance to base open action on.
 */
Navigator.prototype.requestOpenState = function (state) {
  _global.postMessage({
    type: Navigator.EVENTS.OPEN_STATE,
    state: state.serialize()
  }, '*');
};

module.exports = Navigator;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./app-state":230,"spotify-eventemitter":394,"spotify-inheritance/inherit":397}],233:[function(require,module,exports){
'use strict';

module.exports = function (numeral) {
  return {
    delimiters: {
      thousands: ',',
      decimal: '.'
    },
    abbreviations: {
      thousand: 'k',
      million: 'm',
      billion: 'b',
      trillion: 't'
    },
    ordinal: function ordinal(number) {
      var b = number % 10;
      return ~ ~(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
    },
    currency: {
      symbol: '$'
    }
  };
};

},{}],234:[function(require,module,exports){
'use strict';

var numeral = require('./numeraljs/numeral');
var locales = require('../spotify-locales');

module.exports = function (currentLanguage) {

  // We need to explicitly require all languages listed in spotify-locales
  // so that Quickstart can access them at runtime
  // (dynamic paths can't be cached).
  var languages = {
    'de': require('./numeraljs/languages/de'),
    // Custom en.js file
    'en': require('./en')(numeral),
    // es-419 falls back to es-es in Numeral.js
    'es-ES': require('./numeraljs/languages/es-ES'),
    'fi': require('./numeraljs/languages/fi'),
    'fr': require('./numeraljs/languages/fr'),
    'fr-CA': require('./numeraljs/languages/fr-CA'),
    'hu': require('./numeraljs/languages/hu'),
    'id': require('./numeraljs/languages/id'),
    'it': require('./numeraljs/languages/it'),
    'ja': require('./numeraljs/languages/ja'),
    'nl-nl': require('./numeraljs/languages/nl-nl'),
    'pl': require('./numeraljs/languages/pl'),
    'pt-br': require('./numeraljs/languages/pt-br'),
    'sv': require('./numeraljs/languages/sv'),
    'tr': require('./numeraljs/languages/tr')
  };

  var numeralLocale = locales(currentLanguage, 'numeral');
  if (!languages[numeralLocale]) {
    numeralLocale = 'en';
  }
  numeral.language(numeralLocale, languages[numeralLocale]);
  numeral.language(numeralLocale);

  return numeral;
};

},{"../spotify-locales":218,"./en":233,"./numeraljs/languages/de":235,"./numeraljs/languages/es-ES":236,"./numeraljs/languages/fi":237,"./numeraljs/languages/fr":239,"./numeraljs/languages/fr-CA":238,"./numeraljs/languages/hu":240,"./numeraljs/languages/id":241,"./numeraljs/languages/it":242,"./numeraljs/languages/ja":243,"./numeraljs/languages/nl-nl":244,"./numeraljs/languages/pl":245,"./numeraljs/languages/pt-br":246,"./numeraljs/languages/sv":247,"./numeraljs/languages/tr":248,"./numeraljs/numeral":249}],235:[function(require,module,exports){
'use strict';

/*!
 * numeral.js language configuration
 * language : German (de) – generally useful in Germany, Austria, Luxembourg, Belgium
 * author : Marco Krage : https://github.com/sinky
 */
(function () {
    var language = {
        delimiters: {
            thousands: '.',
            decimal: ','
        },
        abbreviations: {
            thousand: 'k',
            million: 'm',
            billion: 'b',
            trillion: 't'
        },
        ordinal: function ordinal(number) {
            return '.';
        },
        currency: {
            symbol: '€'
        }
    };

    // Node
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = language;
    }
})();

},{}],236:[function(require,module,exports){
'use strict';

/*!
 * numeral.js language configuration
 * language : spanish Spain
 * author : Hernan Garcia : https://github.com/hgarcia
 */
(function () {
    var language = {
        delimiters: {
            thousands: '.',
            decimal: ','
        },
        abbreviations: {
            thousand: 'k',
            million: 'mm',
            billion: 'b',
            trillion: 't'
        },
        ordinal: function ordinal(number) {
            var b = number % 10;
            return b === 1 || b === 3 ? 'er' : b === 2 ? 'do' : b === 7 || b === 0 ? 'mo' : b === 8 ? 'vo' : b === 9 ? 'no' : 'to';
        },
        currency: {
            symbol: '€'
        }
    };

    // Node
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = language;
    }
})();

},{}],237:[function(require,module,exports){
'use strict';

/*!
 * numeral.js language configuration
 * language : Finnish
 * author : Sami Saada : https://github.com/samitheberber
 */
(function () {
    var language = {
        delimiters: {
            thousands: ' ',
            decimal: ','
        },
        abbreviations: {
            thousand: 'k',
            million: 'M',
            billion: 'G',
            trillion: 'T'
        },
        ordinal: function ordinal(number) {
            return '.';
        },
        currency: {
            symbol: '€'
        }
    };

    // Node
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = language;
    }
})();

},{}],238:[function(require,module,exports){
'use strict';

/*!
 * numeral.js language configuration
 * language : french (Canada) (fr-CA)
 * author : Léo Renaud-Allaire : https://github.com/renaudleo
 */
(function () {
    var language = {
        delimiters: {
            thousands: ' ',
            decimal: ','
        },
        abbreviations: {
            thousand: 'k',
            million: 'M',
            billion: 'G',
            trillion: 'T'
        },
        ordinal: function ordinal(number) {
            return number === 1 ? 'er' : 'e';
        },
        currency: {
            symbol: '$'
        }
    };

    // Node
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = language;
    }
})();

},{}],239:[function(require,module,exports){
'use strict';

/*!
 * numeral.js language configuration
 * language : french (fr)
 * author : Adam Draper : https://github.com/adamwdraper
 */
(function () {
    var language = {
        delimiters: {
            thousands: ' ',
            decimal: ','
        },
        abbreviations: {
            thousand: 'k',
            million: 'm',
            billion: 'b',
            trillion: 't'
        },
        ordinal: function ordinal(number) {
            return number === 1 ? 'er' : 'e';
        },
        currency: {
            symbol: '€'
        }
    };

    // Node
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = language;
    }
})();

},{}],240:[function(require,module,exports){
'use strict';

/*!
 * numeral.js language configuration
 * language : Hungarian (hu)
 * author : Peter Bakondy : https://github.com/pbakondy
 */
(function () {
    var language = {
        delimiters: {
            thousands: ' ',
            decimal: ','
        },
        abbreviations: {
            thousand: 'E', // ezer
            million: 'M', // millió
            billion: 'Mrd', // milliárd
            trillion: 'T' // trillió
        },
        ordinal: function ordinal(number) {
            return '.';
        },
        currency: {
            symbol: ' Ft'
        }
    };

    // Node
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = language;
    }
})();

},{}],241:[function(require,module,exports){
'use strict';

/*!
 * numeral.js language configuration
 * language : Indonesian (id)
 */
(function () {
    var language = {
        delimiters: {
            thousands: ',',
            decimal: '.'
        },
        abbreviations: {
            thousand: 'ribu',
            million: 'juta',
            billion: 'miliar',
            trillion: 'triliun'
        },
        ordinal: function ordinal(number) {
            // According to Spotify's internal Indonesian specialist,
            // there is no ordinal symbol in Indonesian (like st, nd, th, º, ª),
            // they just use the word (equivalent to writing: first, second,
            // third, instead of 1st, 2nd, 3rd). And as we don't have such
            // capability to translate all numbers to words, this function
            // returns an empty string and wherever there's a ordinal, it will
            // just show up as the cardinal number.
            return '';
        },
        currency: {
            symbol: 'Rp'
        }
    };

    // Node
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = language;
    }
})();

},{}],242:[function(require,module,exports){
'use strict';

/*!
 * numeral.js language configuration
 * language : italian Italy (it)
 * author : Giacomo Trombi : http://cinquepunti.it
 */
(function () {
    var language = {
        delimiters: {
            thousands: '.',
            decimal: ','
        },
        abbreviations: {
            thousand: 'mila',
            million: 'mil',
            billion: 'b',
            trillion: 't'
        },
        ordinal: function ordinal(number) {
            return 'º';
        },
        currency: {
            symbol: '€'
        }
    };

    // Node
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = language;
    }
})();

},{}],243:[function(require,module,exports){
'use strict';

/*!
 * numeral.js language configuration
 * language : japanese
 * author : teppeis : https://github.com/teppeis
 */
(function () {
    var language = {
        delimiters: {
            thousands: ',',
            decimal: '.'
        },
        abbreviations: {
            thousand: '千',
            million: '百万',
            billion: '十億',
            trillion: '兆'
        },
        ordinal: function ordinal(number) {
            return '.';
        },
        currency: {
            symbol: '¥'
        }
    };

    // Node
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = language;
    }
})();

},{}],244:[function(require,module,exports){
'use strict';

/*!
 * numeral.js language configuration
 * language : netherlands-dutch (nl-nl)
 * author : Dave Clayton : https://github.com/davedx
 */
(function () {
    var language = {
        delimiters: {
            thousands: '.',
            decimal: ','
        },
        abbreviations: {
            thousand: 'k',
            million: 'mln',
            billion: 'mrd',
            trillion: 'bln'
        },
        ordinal: function ordinal(number) {
            var remainder = number % 100;
            return number !== 0 && remainder <= 1 || remainder === 8 || remainder >= 20 ? 'ste' : 'de';
        },
        currency: {
            symbol: '€ '
        }
    };

    // Node
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = language;
    }
})();

},{}],245:[function(require,module,exports){
'use strict';

/*!
 * numeral.js language configuration
 * language : polish (pl)
 * author : Dominik Bulaj : https://github.com/dominikbulaj
 */
(function () {
    var language = {
        delimiters: {
            thousands: ' ',
            decimal: ','
        },
        abbreviations: {
            thousand: 'tys.',
            million: 'mln',
            billion: 'mld',
            trillion: 'bln'
        },
        ordinal: function ordinal(number) {
            return '.';
        },
        currency: {
            symbol: 'PLN'
        }
    };

    // Node
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = language;
    }
})();

},{}],246:[function(require,module,exports){
'use strict';

/*!
 * numeral.js language configuration
 * language : portuguese brazil (pt-br)
 * author : Ramiro Varandas Jr : https://github.com/ramirovjr
 */
(function () {
    var language = {
        delimiters: {
            thousands: '.',
            decimal: ','
        },
        abbreviations: {
            thousand: 'mil',
            million: 'milhões',
            billion: 'b',
            trillion: 't'
        },
        ordinal: function ordinal(number) {
            return 'º';
        },
        currency: {
            symbol: 'R$'
        }
    };

    // Node
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = language;
    }
})();

},{}],247:[function(require,module,exports){
'use strict';

/*!
 * numeral.js language configuration
 * language : swedish
 * author :
 */
(function () {
    var language = {
        delimiters: {
            thousands: ' ',
            decimal: ','
        },
        abbreviations: {
            thousand: 't',
            million: 'mn',
            billion: 'md',
            trillion: 'bn'
        },
        ordinal: function ordinal(number) {
            return '.';
        },
        currency: {
            symbol: 'SEK'
        }
    };

    // Node
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = language;
    }
})();

},{}],248:[function(require,module,exports){
'use strict';

/*!
 * numeral.js language configuration
 * language : turkish (tr)
 * author : Ecmel Ercan : https://github.com/ecmel, Erhan Gundogan : https://github.com/erhangundogan, Burak Yiğit Kaya: https://github.com/BYK
 */
(function () {
    var suffixes = {
        1: '\'inci',
        5: '\'inci',
        8: '\'inci',
        70: '\'inci',
        80: '\'inci',

        2: '\'nci',
        7: '\'nci',
        20: '\'nci',
        50: '\'nci',

        3: '\'üncü',
        4: '\'üncü',
        100: '\'üncü',

        6: '\'ncı',

        9: '\'uncu',
        10: '\'uncu',
        30: '\'uncu',

        60: '\'ıncı',
        90: '\'ıncı'
    },
        language = {
        delimiters: {
            thousands: '.',
            decimal: ','
        },
        abbreviations: {
            thousand: 'bin',
            million: 'milyon',
            billion: 'milyar',
            trillion: 'trilyon'
        },
        ordinal: function ordinal(number) {
            if (number === 0) {
                // special case for zero
                return '\'ıncı';
            }

            var a = number % 10,
                b = number % 100 - a,
                c = number >= 100 ? 100 : null;

            return suffixes[a] || suffixes[b] || suffixes[c];
        },
        currency: {
            symbol: '₺'
        }
    };

    // Node
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = language;
    }
})();

},{}],249:[function(require,module,exports){
'use strict';

/*!
 * numeral.js
 * version : 1.5.3
 * author : Adam Draper
 * license : MIT
 * http://adamwdraper.github.com/Numeral-js/
 */

(function () {

    /************************************
        Constants
    ************************************/

    var _numeral,
        VERSION = '1.5.3',

    // internal storage for language config files
    languages = {},
        currentLanguage = 'en',
        zeroFormat = null,
        defaultFormat = '0,0',

    // check for nodeJS
    hasModule = typeof module !== 'undefined' && module.exports;

    /************************************
        Constructors
    ************************************/

    // Numeral prototype object
    function Numeral(number) {
        this._value = number;
    }

    /**
     * Implementation of toFixed() that treats floats more like decimals
     *
     * Fixes binary rounding issues (eg. (0.615).toFixed(2) === '0.61') that present
     * problems for accounting- and finance-related software.
     */
    function toFixed(value, precision, roundingFunction, optionals) {
        var power = Math.pow(10, precision),
            optionalsRegExp,
            output;

        //roundingFunction = (roundingFunction !== undefined ? roundingFunction : Math.round);
        // Multiply up by precision, round accurately, then divide and use native toFixed():
        output = (roundingFunction(value * power) / power).toFixed(precision);

        if (optionals) {
            optionalsRegExp = new RegExp('0{1,' + optionals + '}$');
            output = output.replace(optionalsRegExp, '');
        }

        return output;
    }

    /************************************
        Formatting
    ************************************/

    // determine what type of formatting we need to do
    function formatNumeral(n, format, roundingFunction) {
        var output;

        // figure out what kind of format we are dealing with
        if (format.indexOf('$') > -1) {
            // currency!!!!!
            output = formatCurrency(n, format, roundingFunction);
        } else if (format.indexOf('%') > -1) {
            // percentage
            output = formatPercentage(n, format, roundingFunction);
        } else if (format.indexOf(':') > -1) {
            // time
            output = formatTime(n, format);
        } else {
            // plain ol' numbers or bytes
            output = formatNumber(n._value, format, roundingFunction);
        }

        // return string
        return output;
    }

    // revert to number
    function unformatNumeral(n, string) {
        var stringOriginal = string,
            thousandRegExp,
            millionRegExp,
            billionRegExp,
            trillionRegExp,
            suffixes = ['KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'],
            bytesMultiplier = false,
            power;

        if (string.indexOf(':') > -1) {
            n._value = unformatTime(string);
        } else {
            if (string === zeroFormat) {
                n._value = 0;
            } else {
                if (languages[currentLanguage].delimiters.decimal !== '.') {
                    string = string.replace(/\./g, '').replace(languages[currentLanguage].delimiters.decimal, '.');
                }

                // see if abbreviations are there so that we can multiply to the correct number
                thousandRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.thousand + '(?:\\)|(\\' + languages[currentLanguage].currency.symbol + ')?(?:\\))?)?$');
                millionRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.million + '(?:\\)|(\\' + languages[currentLanguage].currency.symbol + ')?(?:\\))?)?$');
                billionRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.billion + '(?:\\)|(\\' + languages[currentLanguage].currency.symbol + ')?(?:\\))?)?$');
                trillionRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.trillion + '(?:\\)|(\\' + languages[currentLanguage].currency.symbol + ')?(?:\\))?)?$');

                // see if bytes are there so that we can multiply to the correct number
                for (power = 0; power <= suffixes.length; power++) {
                    bytesMultiplier = string.indexOf(suffixes[power]) > -1 ? Math.pow(1024, power + 1) : false;

                    if (bytesMultiplier) {
                        break;
                    }
                }

                // do some math to create our number
                n._value = (bytesMultiplier ? bytesMultiplier : 1) * (stringOriginal.match(thousandRegExp) ? Math.pow(10, 3) : 1) * (stringOriginal.match(millionRegExp) ? Math.pow(10, 6) : 1) * (stringOriginal.match(billionRegExp) ? Math.pow(10, 9) : 1) * (stringOriginal.match(trillionRegExp) ? Math.pow(10, 12) : 1) * (string.indexOf('%') > -1 ? 0.01 : 1) * ((string.split('-').length + Math.min(string.split('(').length - 1, string.split(')').length - 1)) % 2 ? 1 : -1) * Number(string.replace(/[^0-9\.]+/g, ''));

                // round if we are talking about bytes
                n._value = bytesMultiplier ? Math.ceil(n._value) : n._value;
            }
        }
        return n._value;
    }

    function formatCurrency(n, format, roundingFunction) {
        var symbolIndex = format.indexOf('$'),
            openParenIndex = format.indexOf('('),
            minusSignIndex = format.indexOf('-'),
            space = '',
            spliceIndex,
            output;

        // check for space before or after currency
        if (format.indexOf(' $') > -1) {
            space = ' ';
            format = format.replace(' $', '');
        } else if (format.indexOf('$ ') > -1) {
            space = ' ';
            format = format.replace('$ ', '');
        } else {
            format = format.replace('$', '');
        }

        // format the number
        output = formatNumber(n._value, format, roundingFunction);

        // position the symbol
        if (symbolIndex <= 1) {
            if (output.indexOf('(') > -1 || output.indexOf('-') > -1) {
                output = output.split('');
                spliceIndex = 1;
                if (symbolIndex < openParenIndex || symbolIndex < minusSignIndex) {
                    // the symbol appears before the "(" or "-"
                    spliceIndex = 0;
                }
                output.splice(spliceIndex, 0, languages[currentLanguage].currency.symbol + space);
                output = output.join('');
            } else {
                output = languages[currentLanguage].currency.symbol + space + output;
            }
        } else {
            if (output.indexOf(')') > -1) {
                output = output.split('');
                output.splice(-1, 0, space + languages[currentLanguage].currency.symbol);
                output = output.join('');
            } else {
                output = output + space + languages[currentLanguage].currency.symbol;
            }
        }

        return output;
    }

    function formatPercentage(n, format, roundingFunction) {
        var space = '',
            output,
            value = n._value * 100;

        // check for space before %
        if (format.indexOf(' %') > -1) {
            space = ' ';
            format = format.replace(' %', '');
        } else {
            format = format.replace('%', '');
        }

        output = formatNumber(value, format, roundingFunction);

        if (output.indexOf(')') > -1) {
            output = output.split('');
            output.splice(-1, 0, space + '%');
            output = output.join('');
        } else {
            output = output + space + '%';
        }

        return output;
    }

    function formatTime(n) {
        var hours = Math.floor(n._value / 60 / 60),
            minutes = Math.floor((n._value - hours * 60 * 60) / 60),
            seconds = Math.round(n._value - hours * 60 * 60 - minutes * 60);
        return hours + ':' + (minutes < 10 ? '0' + minutes : minutes) + ':' + (seconds < 10 ? '0' + seconds : seconds);
    }

    function unformatTime(string) {
        var timeArray = string.split(':'),
            seconds = 0;
        // turn hours and minutes into seconds and add them all up
        if (timeArray.length === 3) {
            // hours
            seconds = seconds + Number(timeArray[0]) * 60 * 60;
            // minutes
            seconds = seconds + Number(timeArray[1]) * 60;
            // seconds
            seconds = seconds + Number(timeArray[2]);
        } else if (timeArray.length === 2) {
            // minutes
            seconds = seconds + Number(timeArray[0]) * 60;
            // seconds
            seconds = seconds + Number(timeArray[1]);
        }
        return Number(seconds);
    }

    function formatNumber(value, format, roundingFunction) {
        var negP = false,
            signed = false,
            optDec = false,
            abbr = '',
            abbrK = false,
            // force abbreviation to thousands
        abbrM = false,
            // force abbreviation to millions
        abbrB = false,
            // force abbreviation to billions
        abbrT = false,
            // force abbreviation to trillions
        abbrForce = false,
            // force abbreviation
        bytes = '',
            ord = '',
            abs = Math.abs(value),
            suffixes = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'],
            min,
            max,
            power,
            w,
            precision,
            thousands,
            d = '',
            neg = false;

        // check if number is zero and a custom zero format has been set
        if (value === 0 && zeroFormat !== null) {
            return zeroFormat;
        } else {
            // see if we should use parentheses for negative number or if we should prefix with a sign
            // if both are present we default to parentheses
            if (format.indexOf('(') > -1) {
                negP = true;
                format = format.slice(1, -1);
            } else if (format.indexOf('+') > -1) {
                signed = true;
                format = format.replace(/\+/g, '');
            }

            // see if abbreviation is wanted
            if (format.indexOf('a') > -1) {
                // check if abbreviation is specified
                abbrK = format.indexOf('aK') >= 0;
                abbrM = format.indexOf('aM') >= 0;
                abbrB = format.indexOf('aB') >= 0;
                abbrT = format.indexOf('aT') >= 0;
                abbrForce = abbrK || abbrM || abbrB || abbrT;

                // check for space before abbreviation
                if (format.indexOf(' a') > -1) {
                    abbr = ' ';
                    format = format.replace(' a', '');
                } else {
                    format = format.replace('a', '');
                }

                if (abs >= Math.pow(10, 12) && !abbrForce || abbrT) {
                    // trillion
                    abbr = abbr + languages[currentLanguage].abbreviations.trillion;
                    value = value / Math.pow(10, 12);
                } else if (abs < Math.pow(10, 12) && abs >= Math.pow(10, 9) && !abbrForce || abbrB) {
                    // billion
                    abbr = abbr + languages[currentLanguage].abbreviations.billion;
                    value = value / Math.pow(10, 9);
                } else if (abs < Math.pow(10, 9) && abs >= Math.pow(10, 6) && !abbrForce || abbrM) {
                    // million
                    abbr = abbr + languages[currentLanguage].abbreviations.million;
                    value = value / Math.pow(10, 6);
                } else if (abs < Math.pow(10, 6) && abs >= Math.pow(10, 3) && !abbrForce || abbrK) {
                    // thousand
                    abbr = abbr + languages[currentLanguage].abbreviations.thousand;
                    value = value / Math.pow(10, 3);
                }
            }

            // see if we are formatting bytes
            if (format.indexOf('b') > -1) {
                // check for space before
                if (format.indexOf(' b') > -1) {
                    bytes = ' ';
                    format = format.replace(' b', '');
                } else {
                    format = format.replace('b', '');
                }

                for (power = 0; power <= suffixes.length; power++) {
                    min = Math.pow(1024, power);
                    max = Math.pow(1024, power + 1);

                    if (value >= min && value < max) {
                        bytes = bytes + suffixes[power];
                        if (min > 0) {
                            value = value / min;
                        }
                        break;
                    }
                }
            }

            // see if ordinal is wanted
            if (format.indexOf('o') > -1) {
                // check for space before
                if (format.indexOf(' o') > -1) {
                    ord = ' ';
                    format = format.replace(' o', '');
                } else {
                    format = format.replace('o', '');
                }

                ord = ord + languages[currentLanguage].ordinal(value);
            }

            if (format.indexOf('[.]') > -1) {
                optDec = true;
                format = format.replace('[.]', '.');
            }

            w = value.toString().split('.')[0];
            precision = format.split('.')[1];
            thousands = format.indexOf(',');

            if (precision) {
                if (precision.indexOf('[') > -1) {
                    precision = precision.replace(']', '');
                    precision = precision.split('[');
                    d = toFixed(value, precision[0].length + precision[1].length, roundingFunction, precision[1].length);
                } else {
                    d = toFixed(value, precision.length, roundingFunction);
                }

                w = d.split('.')[0];

                if (d.split('.')[1].length) {
                    d = languages[currentLanguage].delimiters.decimal + d.split('.')[1];
                } else {
                    d = '';
                }

                if (optDec && Number(d.slice(1)) === 0) {
                    d = '';
                }
            } else {
                w = toFixed(value, null, roundingFunction);
            }

            // format number
            if (w.indexOf('-') > -1) {
                w = w.slice(1);
                neg = true;
            }

            if (thousands > -1) {
                w = w.toString().replace(/(\d)(?=(\d{3})+(?!\d))/g, '$1' + languages[currentLanguage].delimiters.thousands);
            }

            if (format.indexOf('.') === 0) {
                w = '';
            }

            return (negP && neg ? '(' : '') + (!negP && neg ? '-' : '') + (!neg && signed ? '+' : '') + w + d + (ord ? ord : '') + (abbr ? abbr : '') + (bytes ? bytes : '') + (negP && neg ? ')' : '');
        }
    }

    /************************************
        Top Level Functions
    ************************************/

    _numeral = function numeral(input) {
        if (_numeral.isNumeral(input)) {
            input = input.value();
        } else if (input === 0 || typeof input === 'undefined') {
            input = 0;
        } else if (!Number(input)) {
            input = _numeral.fn.unformat(input);
        }

        return new Numeral(Number(input));
    };

    // version number
    _numeral.version = VERSION;

    // compare numeral object
    _numeral.isNumeral = function (obj) {
        return obj instanceof Numeral;
    };

    // This function will load languages and then set the global language.  If
    // no arguments are passed in, it will simply return the current global
    // language key.
    _numeral.language = function (key, values) {
        if (!key) {
            return currentLanguage;
        }

        if (key && !values) {
            if (!languages[key]) {
                throw new Error('Unknown language : ' + key);
            }
            currentLanguage = key;
        }

        if (values || !languages[key]) {
            loadLanguage(key, values);
        }

        return _numeral;
    };

    // This function provides access to the loaded language data.  If
    // no arguments are passed in, it will simply return the current
    // global language object.
    _numeral.languageData = function (key) {
        if (!key) {
            return languages[currentLanguage];
        }

        if (!languages[key]) {
            throw new Error('Unknown language : ' + key);
        }

        return languages[key];
    };

    _numeral.language('en', {
        delimiters: {
            thousands: ',',
            decimal: '.'
        },
        abbreviations: {
            thousand: 'k',
            million: 'm',
            billion: 'b',
            trillion: 't'
        },
        ordinal: function ordinal(number) {
            var b = number % 10;
            return ~ ~(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
        },
        currency: {
            symbol: '$'
        }
    });

    _numeral.zeroFormat = function (format) {
        zeroFormat = typeof format === 'string' ? format : null;
    };

    _numeral.defaultFormat = function (format) {
        defaultFormat = typeof format === 'string' ? format : '0.0';
    };

    /************************************
        Helpers
    ************************************/

    function loadLanguage(key, values) {
        languages[key] = values;
    }

    /************************************
        Floating-point helpers
    ************************************/

    // The floating-point helper functions and implementation
    // borrows heavily from sinful.js: http://guipn.github.io/sinful.js/

    /**
     * Array.prototype.reduce for browsers that don't support it
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce#Compatibility
     */
    if ('function' !== typeof Array.prototype.reduce) {
        Array.prototype.reduce = function (callback, opt_initialValue) {
            'use strict';

            if (null === this || 'undefined' === typeof this) {
                // At the moment all modern browsers, that support strict mode, have
                // native implementation of Array.prototype.reduce. For instance, IE8
                // does not support strict mode, so this check is actually useless.
                throw new TypeError('Array.prototype.reduce called on null or undefined');
            }

            if ('function' !== typeof callback) {
                throw new TypeError(callback + ' is not a function');
            }

            var index,
                value,
                length = this.length >>> 0,
                isValueSet = false;

            if (1 < arguments.length) {
                value = opt_initialValue;
                isValueSet = true;
            }

            for (index = 0; length > index; ++index) {
                if (this.hasOwnProperty(index)) {
                    if (isValueSet) {
                        value = callback(value, this[index], index, this);
                    } else {
                        value = this[index];
                        isValueSet = true;
                    }
                }
            }

            if (!isValueSet) {
                throw new TypeError('Reduce of empty array with no initial value');
            }

            return value;
        };
    }

    /**
     * Computes the multiplier necessary to make x >= 1,
     * effectively eliminating miscalculations caused by
     * finite precision.
     */
    function multiplier(x) {
        var parts = x.toString().split('.');
        if (parts.length < 2) {
            return 1;
        }
        return Math.pow(10, parts[1].length);
    }

    /**
     * Given a variable number of arguments, returns the maximum
     * multiplier that must be used to normalize an operation involving
     * all of them.
     */
    function correctionFactor() {
        var args = Array.prototype.slice.call(arguments);
        return args.reduce(function (prev, next) {
            var mp = multiplier(prev),
                mn = multiplier(next);
            return mp > mn ? mp : mn;
        }, -Infinity);
    }

    /************************************
        Numeral Prototype
    ************************************/

    _numeral.fn = Numeral.prototype = {

        clone: function clone() {
            return _numeral(this);
        },

        format: function format(inputString, roundingFunction) {
            return formatNumeral(this, inputString ? inputString : defaultFormat, roundingFunction !== undefined ? roundingFunction : Math.round);
        },

        unformat: function unformat(inputString) {
            if (Object.prototype.toString.call(inputString) === '[object Number]') {
                return inputString;
            }
            return unformatNumeral(this, inputString ? inputString : defaultFormat);
        },

        value: function value() {
            return this._value;
        },

        valueOf: function valueOf() {
            return this._value;
        },

        set: function set(value) {
            this._value = Number(value);
            return this;
        },

        add: function add(value) {
            var corrFactor = correctionFactor.call(null, this._value, value);
            function cback(accum, curr, currI, O) {
                return accum + corrFactor * curr;
            }
            this._value = [this._value, value].reduce(cback, 0) / corrFactor;
            return this;
        },

        subtract: function subtract(value) {
            var corrFactor = correctionFactor.call(null, this._value, value);
            function cback(accum, curr, currI, O) {
                return accum - corrFactor * curr;
            }
            this._value = [value].reduce(cback, this._value * corrFactor) / corrFactor;
            return this;
        },

        multiply: function multiply(value) {
            function cback(accum, curr, currI, O) {
                var corrFactor = correctionFactor(accum, curr);
                return accum * corrFactor * (curr * corrFactor) / (corrFactor * corrFactor);
            }
            this._value = [this._value, value].reduce(cback, 1);
            return this;
        },

        divide: function divide(value) {
            function cback(accum, curr, currI, O) {
                var corrFactor = correctionFactor(accum, curr);
                return accum * corrFactor / (curr * corrFactor);
            }
            this._value = [this._value, value].reduce(cback);
            return this;
        },

        difference: function difference(value) {
            return Math.abs(_numeral(this._value).subtract(value).value());
        }

    };

    /************************************
        Exposing Numeral
    ************************************/

    module.exports = _numeral;
}).call(undefined);

},{}],250:[function(require,module,exports){

'use strict';

/**
 * Module dependencies
 */

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var extend = require('extend'),
    bridge = require('../spotify-bridge-request'),
    batch = require('spotify-batch');

/**
 * Bridge methods
 */

var PREF_ALL = 'preferences_all';
var PREF_GET = 'preferences_get';
var PREF_SET = 'preferences_set';
var PREF_SUB = 'preferences_event_wait';

/**
 * Converts a string with dot notation into
 * a nested object where the last key is
 * set to value
 *
 *  eg: f('foo.bar', 123) = {foo: {bar: 123}}
 *
 * @api private
 * @param {String} string
 * @param {Mixed} value
 * @param {String} delimiter - optional
 */

function TransformStringIntoObjectAndSetValue(string, value, delimiter) {
  var object = {};
  string.split(delimiter || '.').reduce(function (o, c, i, a) {
    if (i < a.length - 1) {
      o[c] = {};
    } else {
      o[c] = value;
    }

    return o[c];
  }, object);

  return object;
}

/**
 * Converts an object with nest objects into a flat object
 *
 *  eg: f({foo: {bar: 123}}) = {'foo.bar': 123}
 *
 * @api private
 * @param {String} string
 * @param {String} delimiter - optional
 */

function TransformObjectIntoFlatObject(object, delimiter) {
  var flattened = {};
  delimiter = delimiter || '.';
  function traverse(o, key) {
    var tmp = null;
    for (var p in o) {
      if ('object' == _typeof(o[p])) {
        key = key ? [key, p].join(delimiter) : p;
        traverse(o[p], key);
      } else {
        tmp = key ? [key, p].join(delimiter) : p;
        flattened[tmp] = o[p];
      }
    }
  }

  traverse(object);
  return flattened;
}

/**
 * Normalizes data from bridge responses
 *
 * @api private
 * @param {String} key
 * @param {Object} data
 * @param {Boolean} preserve - optional (Default: false)
 */

function NormalizeData(key, data, preserve) {
  var out = {};
  var regex = '*' == key ? null : RegExp('^' + key);
  var targets = null;

  if ('object' != (typeof data === 'undefined' ? 'undefined' : _typeof(data))) {
    return data;
  }

  targets = Object.keys(data).map(function (key) {
    if (null == regex || regex.test(key)) {
      return [key, data[key]];
    }
  }).filter(Boolean).reduce(function (t, c) {
    t[c[0]] = c[1];
    return t;
  }, {});

  Object.keys(targets).forEach(function (key) {
    // extend output object with transformed properties
    extend(true, out, TransformStringIntoObjectAndSetValue(key, targets[key]));
  });

  if ('*' == key || true === preserve) {
    return out;
  } else {
    return key.split('.').reduce(function (o, k) {
      return o[k];
    }, out);
  }
}

/**
 * Subscribes to a key.
 *
 * @api private
 * @param {Function} rpc The RPC to use.
 * @param {String} key The key (including path).
 * @param {*} lastValue The last value of the key (used for comparing).
 * @param {Function} fn Subscribe handler.
 * @param {Object=} sub Subscription object, optional.
 */

function SubscribeToKey(rpc, key, lastValue, fn, sub) {
  sub = sub || {
    isCancelled: false,
    cancel: function cancel() {
      this.isCancelled = true;
    }
  };

  rpc(PREF_SUB, [], function (err, res) {
    if (sub.isCancelled) return;

    var didValueChange = false;

    if (res) {
      var value = NormalizeData(key, res);
      if (value !== lastValue) {
        lastValue = value;
        didValueChange = true;
      }
    }

    // Resubscribe since one subscription is only for one response
    SubscribeToKey(rpc, key, lastValue, fn, sub);

    if (didValueChange) {
      fn(null, lastValue);
    }
  });

  return sub;
}

/**
 * `Preferences' constructor
 *
 * @api public
 * @param {String} path - optional (Default: '*')
 * @param {Function} rpc - optional
 */

module.exports = Preferences;
function Preferences(path, rpc) {
  if (!(this instanceof Preferences)) {
    return new Preferences(path, rpc);
  }

  this.path = path || '*';
  this.rpc = rpc || bridge.request.bind(bridge);
}

/**
 * Retrieves all preferences at path.
 * If path is '*' then all preferences
 * are retrieved.
 *
 * @api public
 * @param {Function} fn
 */

Preferences.prototype.all = function (fn) {
  var self = this;
  var path = this.path;

  this.rpc(PREF_ALL, [], function (err, res) {
    if (err) {
      return fn(err);
    } else if ('*' == path) {
      fn(null, res);
    } else {
      fn(null, NormalizeData(path, res, true));
    }
  });

  return this;
};

/**
 * Sets a preference at key at path
 * with value
 *
 * @api public
 * @param {String} key
 * @param {Mixed} value
 * @param {Function} fn
 */

Preferences.prototype.set = function (key, value, fn) {
  var self = this;
  var path = this.path;
  var tmp = null;
  var map = null;
  var jobs = null;

  // handle batch jobs to extend bridge preferences
  if ('object' == (typeof key === 'undefined' ? 'undefined' : _typeof(key))) {
    fn = value;

    map = TransformObjectIntoFlatObject(key);
    jobs = batch().concurrency(1);
    Object.keys(map).forEach(function (k) {
      jobs.push(function (next) {
        self.set(k, map[k], next);
      });
    });

    jobs.run(fn);
  } else {
    key = '*' == path ? key : [path, key].join('.');
    this.rpc(PREF_SET, [key, value], fn);
  }
  return this;
};

/**
 * Sets a preference bitflag at path, based on the inputs.
 *
 * @api public
 * @param {String} key
 * @param {Array} flagBoolPairs
 * @param {Function} fn
 */

Preferences.prototype.setAtomicFlags = function (key, flagBoolPairs, fn) {
  var self = this;

  self.get(key, function (err, value) {
    if (err) return fn(err);

    flagBoolPairs.forEach(function (pair) {
      var flag = pair[0];
      var bool = pair[1];
      if (bool === undefined || bool === null) return;
      if (bool) value |= flag;else value &= ~flag;
    });

    self.set(key, value, fn);
  });
};

/**
 * Gets a preference at key at path
 *
 * @api public
 * @param {String} key
 * @param {Function} fn
 */

Preferences.prototype.get = function (key, fn) {
  var self = this;
  key = '*' == this.path ? key : [this.path, key].join('.');

  // try to get property first
  this.rpc(PREF_GET, [key], function (err, res) {
    var value = res ? NormalizeData(key, res) : null;
    if (null == value) {
      self.rpc(PREF_ALL, [], function (err, res) {
        if (err) {
          return fn(err);
        } else {
          fn(null, NormalizeData(key, res));
        }
      });
    } else {
      fn(null, NormalizeData(key, res));
    }
  });
  return this;
};

/**
 * Subscribes to a preference at key at path
 *
 * @api public
 * @param {String} key
 * @param {Function} fn
 */

Preferences.prototype.subscribe = function (key, fn) {
  var self = this;
  var sub = null;
  var cancelled = false;

  // Get initial value and then subscribe for changes
  this.get(key, function (err, res) {
    if (cancelled) return;
    var keyWithPath = '*' == self.path ? key : [self.path, key].join('.');
    sub = SubscribeToKey(self.rpc, keyWithPath, res, fn);

    // Respond to the GET (initial value for SUB)
    fn(err, res);
  });

  return {
    cancel: function cancel() {
      cancelled = true;
      if (sub) {
        sub.cancel();
      }
    }
  };
};

},{"../spotify-bridge-request":38,"extend":289,"spotify-batch":382}],251:[function(require,module,exports){
/**
 * @module spotify-range2
 */
'use strict';

var prime = require('prime');

var map = require('mout/array/map');

var push_ = Array.prototype.push;
var slice_ = Array.prototype.slice;

var Range = prime( /** @lends Range.prototype */{

  /**
   * The representation of a range
   * @constructs
   * @param {Number} start The start of the range.
   * @param {Number} end The end of the range.
   */
  constructor: function Range(start, end) {
    this.update(start, end);
  },

  /** Update a range. */
  update: function update(start, end) {
    if (start !== null) this.start = start;
    if (end !== null) this.end = end;
    if (this.start === null || this.end === null) throw new Error('invalid range');
    if (this.start > this.end) throw new Error('invalid range');
    this.length = this.end - this.start;
    return this;
  },

  /** Copy a range. */
  copy: function copy() {
    return new Range(this.start, this.end);
  },

  /** Range is above range. */
  above: function above(range) {
    if (!range) return false;
    return this.start >= range.end;
  },

  /** Range is below range. */
  below: function below(range) {
    if (!range) return false;
    return this.end <= range.start;
  },

  adjacent: function adjacent(range) {
    if (!range) return false;
    return this.end === range.start || this.start === range.end;
  },

  /** Range intersects range. */
  intersects: function intersects(range) {
    if (!range) return false;
    return !this.above(range) && !this.below(range);
  },

  /** Range contains range. */
  contains: function contains(range) {
    if (!range) return false;
    return this.start <= range.start && this.end >= range.end;
  },

  /** Range is contained by ranges. */
  contained: function contained(range) {
    var ranges;
    if (range instanceof Range) ranges = arguments;else ranges = range;
    if (!ranges) return false;

    for (var i = 0; ranges[i] !== undefined; i++) {
      var r = ranges[i];
      if (r.start <= this.start && r.end >= this.end) {
        return true;
      }
    }
    return false;
  },

  /** Range fits two ranges. */
  fits: function fits(prev, next) {
    if (!prev && !next) return true;
    if (!prev) return this.end <= next.start;
    if (!next) return this.start >= prev.end;
    return this.start >= prev.end && this.end <= next.start;
  },

  // get the section of this range contained between two ranges
  // [0, 20] » [0, 8], [16, 20] » [8, 16]

  /** portion of a range between two ranges. */
  between: function between(prev, next) {
    if (!prev && !next) return this.copy();
    if (!prev) return this.start >= next.start ? null : new Range(this.start, Math.min(this.end, next.start));
    if (!next) return this.end <= prev.end ? null : new Range(Math.max(prev.end, this.start), this.end);

    return this.end > prev.end && this.start < next.start ? new Range(Math.max(prev.end, this.start), Math.min(next.start, this.end)) : null;
  },

  // [0, 8] » [0, 2], [4, 5] = [0, 2], [4, 5]
  // [3, 6] » [5, 7] = [5, 6]
  // [6, 9] » [5, 7] = [6, 7]

  /** intersection of a range with many ranges */
  intersection: function intersection(range) {
    var intersected = [];
    var ranges;
    if (range instanceof Range) ranges = arguments;else ranges = range;
    for (var k = 0; k < ranges.length; k++) {
      var r = ranges[k];
      if (this.below(r)) break;

      if (r.intersects(this)) intersected.push(new Range(Math.max(this.start, r.start), Math.min(this.end, r.end)));
    }
    return intersected;
  },

  // subtract ranges from this range
  // [0, 8] » [0, 2], [4, 5] = [2, 4], [5, 8]

  /** subtract many ranges from the range. */
  subtract: function subtract(range) {
    var subtracted = [];
    var ranges;
    if (range instanceof Range) ranges = arguments;else ranges = range;
    for (var k = -1; k < ranges.length; k++) {
      var prev = ranges[k];
      var next = ranges[k + 1];
      var between = this.between(prev, next);
      if (between) subtracted.push(between);
    }
    return subtracted;
  },

  // extract this range from ranges
  // [0, 8] » [0, 2], [5, 8] = []
  // [8, 20] » [0, 2], [5, 8] = [0, 2], [5, 8]
  // [0, 10] » [5, 10], [15, 20] = [5, 10]
  // [10, 20] » [5, 80], [90, 100] = [5, 70] [80, 90]
  // [10, 20] » [0, 10], [20, 30] = [0, 20]

  /** extract the range from many ranges. */
  extract: function extract(range) {
    var ranges = range instanceof Range ? slice_.call(arguments) : range.slice();

    for (var k = 0; k < ranges.length; k++) {
      var prev = ranges[k - 1];
      var next = ranges[k];

      var newRange = null;

      if (this.below(next)) {
        newRange = new Range(next.start - this.length, next.end - this.length);
      } else if (this.intersects(next)) {
        var subtracted = next.subtract(this);
        if (subtracted.length === 2) {
          // is contained
          newRange = new Range(subtracted[0].start, subtracted[1].end - this.length);
        } else if (subtracted.length === 1) {
          if (next.end > this.end) {
            // second segment kept
            newRange = new Range(subtracted[0].start - this.length, subtracted[0].end - this.length);
          } else if (this.start > next.start) {
            // first segment kept
            newRange = new Range(subtracted[0].start, subtracted[0].end);
          }
        } else {
          // gets eaten
          ranges.splice(k--, 1); // decrease k
        }
      } else {
          ranges.splice(k, 1, next.copy());
        }

      if (newRange) {
        if (prev && prev.end === newRange.start) {
          // touches previous
          ranges.splice(k-- - 1, 2, new Range(prev.start, newRange.end)); // decrease k due to splicing
        } else {
            ranges.splice(k, 1, newRange);
          }
      }
    }

    return ranges;
  },

  // [2,3] » [0,1], [2,3] = [0,1], [2,4]
  // [1,2] » [0,6] = [0,7]
  // [0,1] » [0,1], [5,6] = [0,2], [6,7]
  // [4,6] » [0,1], [5,6] = [0,1], [4,6], [7,8]

  // TODO: this can be slightly better. merging can be done in one loop.

  /** insert the range in many ranges. */
  insert: function insert(range) {
    var ranges = range instanceof Range ? slice_.call(arguments) : range.slice();

    for (var k = 0; k < ranges.length; k++) {
      var next = ranges[k];

      if (this.start >= next.end) {
        ranges.splice(k, 1, next.copy());
      } else if (this.start > next.start && this.start < next.end) {
        ranges.splice(k, 1, new Range(next.start, this.start), new Range(this.start, next.end));
      } else {
        ranges.splice(k, 1, new Range(next.start + this.length, next.end + this.length));
      }
    }

    return this.merge(ranges);
  },

  // merge this range in ranges
  // [0, 8] » [0, 2], [5, 8] = [0, 8]
  // [8, 20] » [0, 2], [5, 8] = [0, 2], [5, 20]
  // [0, 10] » [5, 10], [15, 20] = [0, 10], [15, 20]

  /** merge many ranges to the range. */
  merge: function merge(range) {
    var ranges;
    if (range instanceof Range) ranges = arguments;else ranges = range;

    ranges = map(ranges, function (r) {
      return r.copy();
    });

    if (!ranges.length) return [this.copy()];

    var k;
    var l;

    for (k = -1, l = ranges.length; k < l; k++) {
      var prev = ranges[k];
      var next = ranges[k + 1];
      var between = this.between(prev, next);

      if (between) {
        if (!prev && next) {
          if (between.end === next.start) {
            next.update(between.start, next.end);
          } else {
            k++; // increase k since we had a push
            ranges.unshift(between);
          }
        } else if (prev && next) {
          if (prev.end === between.start && between.end === next.start) {
            prev.update(prev.start, next.end);
            ranges.splice(k-- + 1, 1); // remove the next, decrease k since we had a splice
          } else if (prev.end === between.start) {
              prev.update(prev.start, between.end);
            } else if (between.end === next.start) {
              next.update(between.start, next.end);
            } else {
              ranges.splice(k + 1, 0, between);
            }
        } else if (prev && !next) {
          if (prev.end === between.start) {
            prev.update(prev.start, between.end);
          } else {
            k++; // increase k since we had a push
            ranges.push(between);
          }
        }
      }
    }

    return ranges;
  },

  /** Remove range from many ranges
      - The range(s) you pass is what you remove from */
  remove: function remove(range) {
    var ranges;
    if (range instanceof Range) ranges = arguments;else ranges = range;
    var result = [];
    for (var i = 0; i < ranges.length; i++) {
      var remaining = ranges[i].subtract(this);
      if (remaining.length) push_.apply(result, remaining);
    }
    return result;
  },

  /** Range to an array of indices */
  toIndices: function toIndices() {
    var indices = [];
    for (var i = this.start; i < this.end; i++) {
      indices.push(i);
    }return indices;
  },

  /** Range to a string */
  toString: function toString() {
    return [this.start, this.end] + '';
  }

});

/**
 * Range from a string
 * @memberof Range
 * @static
 * @param {String} string - The string.
 * @return {Range} The range.
 */
Range.fromString = function (string) {
  var parts = string.split(',');
  return new Range(+parts[0], +parts[1]);
};

/**
 * Ranges from an array of indices
 * @memberof Range
 * @static
 * @param {Array} indices - An array of indices.
 * @return {Array} An array of Ranges.
 */
Range.fromIndices = function (indices) {
  indices.sort(function (a, b) {
    return a > b ? 1 : -1;
  });

  var ranges = [];
  var rstart;
  var rend;

  for (var i = 0; i < indices.length; i++) {
    rstart = indices[i];
    rend = rstart;
    while (indices[i + 1] - indices[i] === 1) {
      rend = indices[i + 1]; // increment the index if the numbers sequential
      i++;
    }
    ranges.push(new Range(rstart, rend + 1));
  }

  return ranges;
};

/**
 * A function that returns a range.
 * @function
 * @see Range
 * @param {Number} start The start of the range.
 * @param {Number} end The end of the range.
 */
module.exports = Range;

},{"mout/array/map":333,"prime":375}],252:[function(require,module,exports){
(function (global){
'use strict';

module.exports = {
  ENABLED: '1',
  DISABLED: '0',
  TEST_NAME: 'ab-desktop-shuffle',
  isEnabled: function isEnabled() {
    return global.__spotify && global.__spotify.product_state && global.__spotify.product_state[this.TEST_NAME] === this.ENABLED || false;
  }

};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],253:[function(require,module,exports){
'use strict';

function Translations() {
  this._data = {};

  // ensure that the context of the get method is always this object
  this.get = this.get.bind(this);
}

/**
 * Default implementation if the
 * locale is not loaded
 */
Translations.prototype.injectData = function (data) {
  this._data = data;
};

/**
 * Get a translation
 */
Translations.prototype.get = function (key, var_args) {
  var format = this._data.hasOwnProperty(key) ? this._data[key] : key;
  var args = arguments;

  return format.replace(/\{(\d+?)\}/g, function (str, num) {
    var value = args[+num + 1];

    // Do not change by a ||. A value of an empty string would make it fail.
    return typeof value !== 'undefined' ? value : str;
  });
};

/**
 * Gets the raw translations data
 * @return {Object} Locale object
 */
Translations.prototype.getData = function () {
  return this._data;
};

/**
 * Creates a translations instance with the specified data
 *
 * @param {Object} data Translations object
 * @return {Translations}
 */
Translations.createWithData = function (data) {
  var translations = new Translations();
  translations.injectData(data);
  return translations;
};

module.exports = Translations;

},{}],254:[function(require,module,exports){
module.exports = {
  "buttonText": "Neuen Radiosender erstellen",
  "tracks": "Songs",
  "albums": "Alben",
  "artists": "Künstler",
  "playlists": "Playlists",
  "inputPlaceholder": "Suchen"
};
},{}],255:[function(require,module,exports){
module.exports = {
  "buttonText": "Δημιουργία νέου σταθμού",
  "tracks": "Τραγούδια",
  "albums": "Άλμπουμ",
  "artists": "Καλλιτέχνες",
  "playlists": "Λίστες",
  "inputPlaceholder": "Αναζήτηση"
};
},{}],256:[function(require,module,exports){
module.exports = {
  "buttonText": "Create New Station",
  "tracks": "Songs",
  "albums": "Albums",
  "artists": "Artists",
  "playlists": "Playlists",
  "inputPlaceholder": "Search"
};
},{}],257:[function(require,module,exports){
module.exports = {
  "buttonText": "Crear nueva estación",
  "tracks": "Canciones",
  "albums": "Álbumes",
  "artists": "Artistas",
  "playlists": "Playlists",
  "inputPlaceholder": "Buscar"
};
},{}],258:[function(require,module,exports){
module.exports = {
  "buttonText": "Crear nueva emisora",
  "tracks": "Canciones",
  "albums": "Álbumes",
  "artists": "Artistas",
  "playlists": "Playlists",
  "inputPlaceholder": "Buscar"
};
},{}],259:[function(require,module,exports){
module.exports = {
  "buttonText": "Luo uusi asema",
  "tracks": "Kappaleet",
  "albums": "Albumit",
  "artists": "Artistit",
  "playlists": "Soittolistat",
  "inputPlaceholder": "Hae"
};
},{}],260:[function(require,module,exports){
module.exports = {
  "buttonText": "Créer une station de radio",
  "tracks": "Titres",
  "albums": "Albums",
  "artists": "Artistes",
  "playlists": "Playlists",
  "inputPlaceholder": "Rechercher"
};
},{}],261:[function(require,module,exports){
module.exports = {
  "buttonText": "Créer une nouvelle radio",
  "tracks": "Titres",
  "albums": "Albums",
  "artists": "Artistes",
  "playlists": "Playlists",
  "inputPlaceholder": "Recherche"
};
},{}],262:[function(require,module,exports){
module.exports = {
  "buttonText": "Új rádió",
  "tracks": "Dalok",
  "albums": "Albumok",
  "artists": "Előadók",
  "playlists": "Lejátszási listák",
  "inputPlaceholder": "Keresés"
};
},{}],263:[function(require,module,exports){
module.exports = {
  "buttonText": "Buat Stasiun Radio Baru",
  "tracks": "Lagu",
  "albums": "Album",
  "artists": "Artis",
  "playlists": "Playlist",
  "inputPlaceholder": "Cari"
};
},{}],264:[function(require,module,exports){
'use strict';

var Translations = require('../../spotify-translations');
var glueLocales = require('../../spotify-glue-cat/strings');

var locales = {
  'de': require('./de.lang'),
  'el': require('./el.lang'),
  'en': require('./en.lang'),
  'es': require('./es.lang'),
  'es-419': require('./es-419.lang'),
  'fi': require('./fi.lang'),
  'fr': require('./fr.lang'),
  'fr-CA': require('./fr-CA.lang'),
  'hu': require('./hu.lang'),
  'id': require('./id.lang'),
  'it': require('./it.lang'),
  'ja': require('./ja.lang'),
  'nl': require('./nl.lang'),
  'pl': require('./pl.lang'),
  'pt-BR': require('./pt-BR.lang'),
  'sv': require('./sv.lang'),
  'tr': require('./tr.lang'),
  'zh-Hant': require('./zh-Hant.lang'),
  'zsm': require('./zsm.lang')
};

var i18n = new Translations();

function getClientLocale() {
  return window.__spotify && window.__spotify.locale || 'en';
}

function setLocale(locale) {
  if (locale === 'auto') {
    locale = getClientLocale();
  }
  i18n.injectData(locales[locale] || {});
}

setLocale('auto');

exports.locale = getClientLocale;
exports.locales = locales;
exports.setLocale = setLocale;
exports.get = i18n.get.bind(i18n);

exports.glueStrings = function () {
  return glueLocales[getClientLocale()];
};

exports.appStrings = function () {
  return locales[getClientLocale()];
};

},{"../../spotify-glue-cat/strings":134,"../../spotify-translations":253,"./de.lang":254,"./el.lang":255,"./en.lang":256,"./es-419.lang":257,"./es.lang":258,"./fi.lang":259,"./fr-CA.lang":260,"./fr.lang":261,"./hu.lang":262,"./id.lang":263,"./it.lang":265,"./ja.lang":266,"./nl.lang":267,"./pl.lang":268,"./pt-BR.lang":269,"./sv.lang":270,"./tr.lang":271,"./zh-Hant.lang":272,"./zsm.lang":273}],265:[function(require,module,exports){
module.exports = {
  "buttonText": "Crea una nuova stazione",
  "tracks": "Brani",
  "albums": "Album",
  "artists": "Artisti",
  "playlists": "Playlist",
  "inputPlaceholder": "Cerca"
};
},{}],266:[function(require,module,exports){
module.exports = {
  "buttonText": "ステーションを新規作成",
  "tracks": "ソング",
  "albums": "アルバム",
  "artists": "アーティスト",
  "playlists": "プレイリスト",
  "inputPlaceholder": "検索"
};
},{}],267:[function(require,module,exports){
module.exports = {
  "buttonText": "Creëer een nieuw station",
  "tracks": "Nummers",
  "albums": "Albums",
  "artists": "Artiesten",
  "playlists": "Afspeellijsten",
  "inputPlaceholder": "Zoeken"
};
},{}],268:[function(require,module,exports){
module.exports = {
  "buttonText": "Utwórz nową stację",
  "tracks": "Utwory",
  "albums": "Albumy",
  "artists": "Wykonawcy",
  "playlists": "Playlisty",
  "inputPlaceholder": "Szukaj"
};
},{}],269:[function(require,module,exports){
module.exports = {
  "buttonText": "Criar nova estação",
  "tracks": "Músicas",
  "albums": "Álbuns",
  "artists": "Artistas",
  "playlists": "Playlists",
  "inputPlaceholder": "Buscar"
};
},{}],270:[function(require,module,exports){
module.exports = {
  "buttonText": "Skapa en ny station",
  "tracks": "Låtar",
  "albums": "Album",
  "artists": "Artister",
  "playlists": "Spellistor",
  "inputPlaceholder": "Sök"
};
},{}],271:[function(require,module,exports){
module.exports = {
  "buttonText": "Yeni İstasyon Oluştur",
  "tracks": "Şarkılar",
  "albums": "Albümler",
  "artists": "Sanatçılar",
  "playlists": "Çalma Listeleri",
  "inputPlaceholder": "Ara"
};
},{}],272:[function(require,module,exports){
module.exports = {
  "buttonText": "建立新電台",
  "tracks": "歌曲",
  "albums": "專輯",
  "artists": "藝人",
  "playlists": "播放列表",
  "inputPlaceholder": "搜尋"
};
},{}],273:[function(require,module,exports){
module.exports = {
  "buttonText": "Cipta Stesen Baharu",
  "tracks": "Lagu",
  "albums": "Album",
  "artists": "Artis",
  "playlists": "Senarai Main",
  "inputPlaceholder": "Cari"
};
},{}],274:[function(require,module,exports){
'use strict';

var live = require('../spotify-live');
require('../spotify-live-models/client').register();

var handlebars = require('../spotify-handlebars');
var helpers = require('../spotify-handlebars/helpers');
var bridge = require('../spotify-bridge-request');

var i18n = require('./i18n/index');
var glueStrings = i18n.glueStrings();
var appStrings = i18n.appStrings();

helpers.loc.register(glueStrings);
helpers.loc.register(appStrings);
handlebars.register(helpers);

var StationCreatorButton = require('./src/station-creator-button');
var StationCreatorBox = require('./src/station-creator-box');

var creatorTemplate = require('./templates/station-creator-box.hbs');
var resultsTemplate = require('./templates/results.hbs');
var buttonTemplate = require('./templates/station-creator-button.hbs');

function StationCreatorWidget() {
  this.stationCreatorBox = new StationCreatorBox(creatorTemplate, resultsTemplate, appStrings, bridge);
  this.stationCreatorButton = new StationCreatorButton(buttonTemplate, appStrings, this.stationCreatorBox);
  this._getSessionData();
};

StationCreatorWidget.prototype._getSessionData = function () {
  live('spotify:client').query('session(country, catalogue, language)', function (error, data) {
    if (!error) {
      this.stationCreatorBox.setSessionData(data.session);
    }
  }.bind(this), 1000);
};

StationCreatorWidget.prototype.addButtonToElement = function (element) {
  if (!element) {
    throw new Error('StationCreatorWidget:addButtonToElement missing param.');
  }
  element.appendChild(this.stationCreatorButton.el);
};

module.exports = new StationCreatorWidget();

},{"../spotify-bridge-request":38,"../spotify-handlebars":156,"../spotify-handlebars/helpers":147,"../spotify-live":212,"../spotify-live-models/client":174,"./i18n/index":264,"./src/station-creator-box":275,"./src/station-creator-button":276,"./templates/results.hbs":277,"./templates/station-creator-box.hbs":278,"./templates/station-creator-button.hbs":279}],275:[function(require,module,exports){
(function (global){
'use strict';

var MODIFIERS = 'media-object-small media-object-horizontal media-object-link';
var CATEGORIES = ['tracks', 'artists', 'albums', 'playlists'];

var OVERLAY_CLASS = 'station-creator-overlay';
var BOX_CLASS = 'station-creator-box';
var SEARCH_URL = 'hm://searchview/km/v2/suggest/';

function StationCreatorBox(boxTemplate, resultsTemplate, strings, bridge) {
  if (arguments.length < 4) {
    throw new Error('StationCreatorBox missing params');
  }
  this.boxTemplate = boxTemplate;
  this.resultsTemplate = resultsTemplate;
  this.strings = strings;
  this.bridge = bridge;

  // Default Session Data
  this.sessionData = {
    country: 'US',
    catalogue: 'all',
    language: 'en',
    username: global.__spotify.username
  };
  this._createSearchURLParams();

  this._createBoxContainerEl = document.createElement('div');
  this._createBoxContainerEl.className = 'station-creator-widget';
  this._createBoxContainerEl.innerHTML = this.boxTemplate(this.strings);

  document.body.appendChild(this._createBoxContainerEl);

  this._overlayEl = this._createBoxContainerEl.querySelector('.' + OVERLAY_CLASS);
  this._boxEl = this._createBoxContainerEl.querySelector('.' + BOX_CLASS);
  this._inputEl = this._createBoxContainerEl.querySelector('.input-field');
  this._clearInputEl = this._createBoxContainerEl.querySelector('.clear-input');
  this._resultsEl = this._createBoxContainerEl.querySelector('.results-container');

  this._inputKeyUpDebounce = {};

  this._addEventListeners();
}

StationCreatorBox.prototype.setSessionData = function (data) {
  this.sessionData.country = data.country;
  this.sessionData.catalogue = data.catalogue;
  this.sessionData.language = data.language;
  this._createSearchURLParams();
};

StationCreatorBox.prototype.show = function () {
  this._overlayEl.className = OVERLAY_CLASS + ' active';
  this._boxEl.className = BOX_CLASS + ' active';
};

StationCreatorBox.prototype.focusInput = function () {
  this._inputEl.focus();
};

StationCreatorBox.prototype._hide = function () {
  this._overlayEl.className = OVERLAY_CLASS;
  this._boxEl.className = BOX_CLASS;
};

StationCreatorBox.prototype._addEventListeners = function () {
  this._inputEl.addEventListener('keyup', this._onInputKeyUp.bind(this));
  this._clearInputEl.addEventListener('click', this._onClearInputClick.bind(this));
  this._overlayEl.addEventListener('click', this._onOverlayClick.bind(this));
  this._resultsEl.addEventListener('click', this._onResultsClick.bind(this));
};

StationCreatorBox.prototype._onInputKeyUp = function (event) {
  clearTimeout(this._inputKeyUpDebounce);
  this._inputKeyUpDebounce = setTimeout(this._handleInputKeyUp.bind(this, event), 200);
};

StationCreatorBox.prototype._createSearchURLParams = function () {
  this.searchParams = ['?country=', this.sessionData.country, '&catalogue=', this.sessionData.catalogue, '&username=', this.sessionData.username, '&locale=', this.sessionData.language, '&genres-limit=0'].join('');
};

StationCreatorBox.prototype._handleInputKeyUp = function () {
  if (this._inputEl.value) {
    var opts = {
      method: 'GET',
      uri: SEARCH_URL + this._inputEl.value + this.searchParams
    };
    this.bridge.cosmosJSON(opts, this._onSuggestComplete.bind(this));
  } else {
    this._resultsEl.innerHTML = '';
  }
};

StationCreatorBox.prototype._hitsToMediaObjects = function (hits) {
  return hits.map(function (hit) {
    hit.modifiers = MODIFIERS;
    hit.imageUrl = hit.image;
    hit.hasSubtitle = !!hit.artists;
    hit.stationUri = hit.uri.replace('spotify:', 'spotify:station:');
    return hit;
  });
};

StationCreatorBox.prototype._createCategory = function (results, category) {
  return {
    category: { type: category, name: this.strings[category] },
    hits: results[category] ? this._hitsToMediaObjects(results[category].hits.slice(0, 3)) : []
  };
};

StationCreatorBox.prototype._createTopResult = function (results) {
  if (!(results[results.topHit] && results[results.topHit].hits.length)) {
    return [];
  }
  return [{
    category: { type: 'top-results', name: this.strings['top-results'] },
    hits: this._hitsToMediaObjects(results[results.topHit].hits.slice(0, 1))
  }];
};

StationCreatorBox.prototype._parseResults = function (results) {
  return this._createTopResult(results).concat(results.sortedCategory.filter(function (cat) {
    return CATEGORIES.indexOf(cat) !== -1;
  }).map(this._createCategory.bind(this, results)));
};

StationCreatorBox.prototype._onSuggestComplete = function (error, results) {
  if (error) {
    console.warn('StationCreatorBox: suggestion error.');
    return;
  }
  this._resultsEl.innerHTML = this.resultsTemplate({
    categories: this._parseResults(results)
  });
};

StationCreatorBox.prototype._onClearInputClick = function () {
  this._inputEl.value = '';
  this._inputEl.focus();
  this._resultsEl.innerHTML = '';
};

StationCreatorBox.prototype._onOverlayClick = function () {
  this._hide();
};

StationCreatorBox.prototype._onResultsClick = function (e) {
  if (e.target && e.target.href) {
    this._hide();
  }
};

module.exports = StationCreatorBox;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],276:[function(require,module,exports){
'use strict';

function StationCreatorButton(template, strings, stationCreatorBox) {
  if (!template || !strings || !stationCreatorBox) {
    throw new Error('StationCreatorButton missing params');
  }
  this.stationCreatorBox = stationCreatorBox;
  this.el = document.createElement('div');
  this.el.className = 'station-creator-button-container';
  this.el.innerHTML = template(strings);

  this.el.addEventListener('click', this._onClick.bind(this));
};

StationCreatorButton.prototype._onClick = function () {
  this.stationCreatorBox.show();
  this.stationCreatorBox.focusInput();
};

module.exports = StationCreatorButton;

},{}],277:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
var partial$0 = require('../../spotify-glue-cat/templates/v1/media-object.hbs');
HandlebarsCompiler.registerPartial('../../spotify-glue-cat/templates/v1/media-object.hbs', partial$0);
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); partials = this.merge(partials, Handlebars.partials); data = data || {};
  var buffer = "", stack1, helper, options, self=this, functionType="function", blockHelperMissing=helpers.blockHelperMissing, escapeExpression=this.escapeExpression;

function program1(depth0,data) {
  
  var buffer = "", stack1, helper, options;
  buffer += "\n<div class=\"result-category "
    + escapeExpression(((stack1 = ((stack1 = (depth0 && depth0.category)),stack1 == null || stack1 === false ? stack1 : stack1.type)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\">\n  <p class=\"category-header\">"
    + escapeExpression(((stack1 = ((stack1 = (depth0 && depth0.category)),stack1 == null || stack1 === false ? stack1 : stack1.name)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "</p>\n  <div class=\"results\">\n    <ul class=\"list-group list-unstyled\">\n      ";
  options={hash:{},inverse:self.noop,fn:self.program(2, program2, data),data:data}
  if (helper = helpers.hits) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.hits); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.hits) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.noop,fn:self.program(2, program2, data),data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    </ul>\n  </div>\n</div>\n";
  return buffer;
  }
function program2(depth0,data) {
  
  var buffer = "", stack1, helper, options;
  buffer += "\n        <li class=\"selectable ";
  options={hash:{},inverse:self.noop,fn:self.program(3, program3, data),data:data}
  if (helper = helpers.hasSubtitle) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.hasSubtitle); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.hasSubtitle) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.noop,fn:self.program(3, program3, data),data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\" data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\">\n          <a data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" href=\"";
  if (helper = helpers.stationUri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.stationUri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-drag-text=\"";
  if (helper = helpers.name) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.name); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" draggable=\"true\">\n            ";
  stack1 = self.invokePartial(partials['../../spotify-glue-cat/templates/v1/media-object.hbs'], '../../spotify-glue-cat/templates/v1/media-object.hbs', depth0, helpers, partials, data);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n          </a>\n        </li>\n      ";
  return buffer;
  }
function program3(depth0,data) {
  
  
  return "multiline";
  }

  options={hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data}
  if (helper = helpers.categories) { stack1 = helper.call(depth0, options); }
  else { helper = (depth0 && depth0.categories); stack1 = typeof helper === functionType ? helper.call(depth0, options) : helper; }
  if (!helpers.categories) { stack1 = blockHelperMissing.call(depth0, stack1, {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data}); }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n";
  return buffer;
  });

},{"../../spotify-glue-cat/templates/v1/media-object.hbs":138,"hbsfy/runtime":320}],278:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, functionType="function", escapeExpression=this.escapeExpression;


  buffer += "<div class=\"station-creator-overlay\"></div>\n<div class=\"station-creator-box\">\n  <div class=\"input-container\">\n    <i class=\"spoticon-search-16\"></i>\n    <input\n      type=\"text\"\n      class=\"input-field\"\n      data-ta=\"search-input\"\n      placeholder=\"";
  if (helper = helpers.inputPlaceholder) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.inputPlaceholder); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" />\n    <i class=\"spoticon-x-16 clear-input\"></i>\n  </div>\n  <div class=\"results-container\"></div>\n</div>\n";
  return buffer;
  });

},{"hbsfy/runtime":320}],279:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, functionType="function", escapeExpression=this.escapeExpression;


  buffer += "<button\n  type=\"button\"\n  class=\"button button-with-stroke radio-play\"\n  data-log-data='{ \"target_uri\": \"none\", \"name\": \"";
  if (helper = helpers.buttonText) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.buttonText); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" }'\n  data-log-click=\"New Station Button\"\n  data-ta=\"create-new-station-button\">\n    <span>";
  if (helper = helpers.buttonText) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.buttonText); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</span>\n</button>\n";
  return buffer;
  });

},{"hbsfy/runtime":320}],280:[function(require,module,exports){
(function (process,global){
/*!
 * async
 * https://github.com/caolan/async
 *
 * Copyright 2010-2014 Caolan McMahon
 * Released under the MIT license
 */
(function () {

    var async = {};
    function noop() {}
    function identity(v) {
        return v;
    }
    function toBool(v) {
        return !!v;
    }
    function notId(v) {
        return !v;
    }

    // global on the server, window in the browser
    var previous_async;

    // Establish the root object, `window` (`self`) in the browser, `global`
    // on the server, or `this` in some virtual machines. We use `self`
    // instead of `window` for `WebWorker` support.
    var root = typeof self === 'object' && self.self === self && self ||
            typeof global === 'object' && global.global === global && global ||
            this;

    if (root != null) {
        previous_async = root.async;
    }

    async.noConflict = function () {
        root.async = previous_async;
        return async;
    };

    function only_once(fn) {
        return function() {
            if (fn === null) throw new Error("Callback was already called.");
            fn.apply(this, arguments);
            fn = null;
        };
    }

    function _once(fn) {
        return function() {
            if (fn === null) return;
            fn.apply(this, arguments);
            fn = null;
        };
    }

    //// cross-browser compatiblity functions ////

    var _toString = Object.prototype.toString;

    var _isArray = Array.isArray || function (obj) {
        return _toString.call(obj) === '[object Array]';
    };

    // Ported from underscore.js isObject
    var _isObject = function(obj) {
        var type = typeof obj;
        return type === 'function' || type === 'object' && !!obj;
    };

    function _isArrayLike(arr) {
        return _isArray(arr) || (
            // has a positive integer length property
            typeof arr.length === "number" &&
            arr.length >= 0 &&
            arr.length % 1 === 0
        );
    }

    function _arrayEach(arr, iterator) {
        var index = -1,
            length = arr.length;

        while (++index < length) {
            iterator(arr[index], index, arr);
        }
    }

    function _map(arr, iterator) {
        var index = -1,
            length = arr.length,
            result = Array(length);

        while (++index < length) {
            result[index] = iterator(arr[index], index, arr);
        }
        return result;
    }

    function _range(count) {
        return _map(Array(count), function (v, i) { return i; });
    }

    function _reduce(arr, iterator, memo) {
        _arrayEach(arr, function (x, i, a) {
            memo = iterator(memo, x, i, a);
        });
        return memo;
    }

    function _forEachOf(object, iterator) {
        _arrayEach(_keys(object), function (key) {
            iterator(object[key], key);
        });
    }

    function _indexOf(arr, item) {
        for (var i = 0; i < arr.length; i++) {
            if (arr[i] === item) return i;
        }
        return -1;
    }

    var _keys = Object.keys || function (obj) {
        var keys = [];
        for (var k in obj) {
            if (obj.hasOwnProperty(k)) {
                keys.push(k);
            }
        }
        return keys;
    };

    function _keyIterator(coll) {
        var i = -1;
        var len;
        var keys;
        if (_isArrayLike(coll)) {
            len = coll.length;
            return function next() {
                i++;
                return i < len ? i : null;
            };
        } else {
            keys = _keys(coll);
            len = keys.length;
            return function next() {
                i++;
                return i < len ? keys[i] : null;
            };
        }
    }

    // Similar to ES6's rest param (http://ariya.ofilabs.com/2013/03/es6-and-rest-parameter.html)
    // This accumulates the arguments passed into an array, after a given index.
    // From underscore.js (https://github.com/jashkenas/underscore/pull/2140).
    function _restParam(func, startIndex) {
        startIndex = startIndex == null ? func.length - 1 : +startIndex;
        return function() {
            var length = Math.max(arguments.length - startIndex, 0);
            var rest = Array(length);
            for (var index = 0; index < length; index++) {
                rest[index] = arguments[index + startIndex];
            }
            switch (startIndex) {
                case 0: return func.call(this, rest);
                case 1: return func.call(this, arguments[0], rest);
            }
            // Currently unused but handle cases outside of the switch statement:
            // var args = Array(startIndex + 1);
            // for (index = 0; index < startIndex; index++) {
            //     args[index] = arguments[index];
            // }
            // args[startIndex] = rest;
            // return func.apply(this, args);
        };
    }

    function _withoutIndex(iterator) {
        return function (value, index, callback) {
            return iterator(value, callback);
        };
    }

    //// exported async module functions ////

    //// nextTick implementation with browser-compatible fallback ////

    // capture the global reference to guard against fakeTimer mocks
    var _setImmediate = typeof setImmediate === 'function' && setImmediate;

    var _delay = _setImmediate ? function(fn) {
        // not a direct alias for IE10 compatibility
        _setImmediate(fn);
    } : function(fn) {
        setTimeout(fn, 0);
    };

    if (typeof process === 'object' && typeof process.nextTick === 'function') {
        async.nextTick = process.nextTick;
    } else {
        async.nextTick = _delay;
    }
    async.setImmediate = _setImmediate ? _delay : async.nextTick;


    async.forEach =
    async.each = function (arr, iterator, callback) {
        return async.eachOf(arr, _withoutIndex(iterator), callback);
    };

    async.forEachSeries =
    async.eachSeries = function (arr, iterator, callback) {
        return async.eachOfSeries(arr, _withoutIndex(iterator), callback);
    };


    async.forEachLimit =
    async.eachLimit = function (arr, limit, iterator, callback) {
        return _eachOfLimit(limit)(arr, _withoutIndex(iterator), callback);
    };

    async.forEachOf =
    async.eachOf = function (object, iterator, callback) {
        callback = _once(callback || noop);
        object = object || [];

        var iter = _keyIterator(object);
        var key, completed = 0;

        while ((key = iter()) != null) {
            completed += 1;
            iterator(object[key], key, only_once(done));
        }

        if (completed === 0) callback(null);

        function done(err) {
            completed--;
            if (err) {
                callback(err);
            }
            // Check key is null in case iterator isn't exhausted
            // and done resolved synchronously.
            else if (key === null && completed <= 0) {
                callback(null);
            }
        }
    };

    async.forEachOfSeries =
    async.eachOfSeries = function (obj, iterator, callback) {
        callback = _once(callback || noop);
        obj = obj || [];
        var nextKey = _keyIterator(obj);
        var key = nextKey();
        function iterate() {
            var sync = true;
            if (key === null) {
                return callback(null);
            }
            iterator(obj[key], key, only_once(function (err) {
                if (err) {
                    callback(err);
                }
                else {
                    key = nextKey();
                    if (key === null) {
                        return callback(null);
                    } else {
                        if (sync) {
                            async.setImmediate(iterate);
                        } else {
                            iterate();
                        }
                    }
                }
            }));
            sync = false;
        }
        iterate();
    };



    async.forEachOfLimit =
    async.eachOfLimit = function (obj, limit, iterator, callback) {
        _eachOfLimit(limit)(obj, iterator, callback);
    };

    function _eachOfLimit(limit) {

        return function (obj, iterator, callback) {
            callback = _once(callback || noop);
            obj = obj || [];
            var nextKey = _keyIterator(obj);
            if (limit <= 0) {
                return callback(null);
            }
            var done = false;
            var running = 0;
            var errored = false;

            (function replenish () {
                if (done && running <= 0) {
                    return callback(null);
                }

                while (running < limit && !errored) {
                    var key = nextKey();
                    if (key === null) {
                        done = true;
                        if (running <= 0) {
                            callback(null);
                        }
                        return;
                    }
                    running += 1;
                    iterator(obj[key], key, only_once(function (err) {
                        running -= 1;
                        if (err) {
                            callback(err);
                            errored = true;
                        }
                        else {
                            replenish();
                        }
                    }));
                }
            })();
        };
    }


    function doParallel(fn) {
        return function (obj, iterator, callback) {
            return fn(async.eachOf, obj, iterator, callback);
        };
    }
    function doParallelLimit(fn) {
        return function (obj, limit, iterator, callback) {
            return fn(_eachOfLimit(limit), obj, iterator, callback);
        };
    }
    function doSeries(fn) {
        return function (obj, iterator, callback) {
            return fn(async.eachOfSeries, obj, iterator, callback);
        };
    }

    function _asyncMap(eachfn, arr, iterator, callback) {
        callback = _once(callback || noop);
        arr = arr || [];
        var results = _isArrayLike(arr) ? [] : {};
        eachfn(arr, function (value, index, callback) {
            iterator(value, function (err, v) {
                results[index] = v;
                callback(err);
            });
        }, function (err) {
            callback(err, results);
        });
    }

    async.map = doParallel(_asyncMap);
    async.mapSeries = doSeries(_asyncMap);
    async.mapLimit = doParallelLimit(_asyncMap);

    // reduce only has a series version, as doing reduce in parallel won't
    // work in many situations.
    async.inject =
    async.foldl =
    async.reduce = function (arr, memo, iterator, callback) {
        async.eachOfSeries(arr, function (x, i, callback) {
            iterator(memo, x, function (err, v) {
                memo = v;
                callback(err);
            });
        }, function (err) {
            callback(err, memo);
        });
    };

    async.foldr =
    async.reduceRight = function (arr, memo, iterator, callback) {
        var reversed = _map(arr, identity).reverse();
        async.reduce(reversed, memo, iterator, callback);
    };

    async.transform = function (arr, memo, iterator, callback) {
        if (arguments.length === 3) {
            callback = iterator;
            iterator = memo;
            memo = _isArray(arr) ? [] : {};
        }

        async.eachOf(arr, function(v, k, cb) {
            iterator(memo, v, k, cb);
        }, function(err) {
            callback(err, memo);
        });
    };

    function _filter(eachfn, arr, iterator, callback) {
        var results = [];
        eachfn(arr, function (x, index, callback) {
            iterator(x, function (v) {
                if (v) {
                    results.push({index: index, value: x});
                }
                callback();
            });
        }, function () {
            callback(_map(results.sort(function (a, b) {
                return a.index - b.index;
            }), function (x) {
                return x.value;
            }));
        });
    }

    async.select =
    async.filter = doParallel(_filter);

    async.selectLimit =
    async.filterLimit = doParallelLimit(_filter);

    async.selectSeries =
    async.filterSeries = doSeries(_filter);

    function _reject(eachfn, arr, iterator, callback) {
        _filter(eachfn, arr, function(value, cb) {
            iterator(value, function(v) {
                cb(!v);
            });
        }, callback);
    }
    async.reject = doParallel(_reject);
    async.rejectLimit = doParallelLimit(_reject);
    async.rejectSeries = doSeries(_reject);

    function _createTester(eachfn, check, getResult) {
        return function(arr, limit, iterator, cb) {
            function done() {
                if (cb) cb(getResult(false, void 0));
            }
            function iteratee(x, _, callback) {
                if (!cb) return callback();
                iterator(x, function (v) {
                    if (cb && check(v)) {
                        cb(getResult(true, x));
                        cb = iterator = false;
                    }
                    callback();
                });
            }
            if (arguments.length > 3) {
                eachfn(arr, limit, iteratee, done);
            } else {
                cb = iterator;
                iterator = limit;
                eachfn(arr, iteratee, done);
            }
        };
    }

    async.any =
    async.some = _createTester(async.eachOf, toBool, identity);

    async.someLimit = _createTester(async.eachOfLimit, toBool, identity);

    async.all =
    async.every = _createTester(async.eachOf, notId, notId);

    async.everyLimit = _createTester(async.eachOfLimit, notId, notId);

    function _findGetResult(v, x) {
        return x;
    }
    async.detect = _createTester(async.eachOf, identity, _findGetResult);
    async.detectSeries = _createTester(async.eachOfSeries, identity, _findGetResult);
    async.detectLimit = _createTester(async.eachOfLimit, identity, _findGetResult);

    async.sortBy = function (arr, iterator, callback) {
        async.map(arr, function (x, callback) {
            iterator(x, function (err, criteria) {
                if (err) {
                    callback(err);
                }
                else {
                    callback(null, {value: x, criteria: criteria});
                }
            });
        }, function (err, results) {
            if (err) {
                return callback(err);
            }
            else {
                callback(null, _map(results.sort(comparator), function (x) {
                    return x.value;
                }));
            }

        });

        function comparator(left, right) {
            var a = left.criteria, b = right.criteria;
            return a < b ? -1 : a > b ? 1 : 0;
        }
    };

    async.auto = function (tasks, concurrency, callback) {
        if (typeof arguments[1] === 'function') {
            // concurrency is optional, shift the args.
            callback = concurrency;
            concurrency = null;
        }
        callback = _once(callback || noop);
        var keys = _keys(tasks);
        var remainingTasks = keys.length;
        if (!remainingTasks) {
            return callback(null);
        }
        if (!concurrency) {
            concurrency = remainingTasks;
        }

        var results = {};
        var runningTasks = 0;

        var hasError = false;

        var listeners = [];
        function addListener(fn) {
            listeners.unshift(fn);
        }
        function removeListener(fn) {
            var idx = _indexOf(listeners, fn);
            if (idx >= 0) listeners.splice(idx, 1);
        }
        function taskComplete() {
            remainingTasks--;
            _arrayEach(listeners.slice(0), function (fn) {
                fn();
            });
        }

        addListener(function () {
            if (!remainingTasks) {
                callback(null, results);
            }
        });

        _arrayEach(keys, function (k) {
            if (hasError) return;
            var task = _isArray(tasks[k]) ? tasks[k]: [tasks[k]];
            var taskCallback = _restParam(function(err, args) {
                runningTasks--;
                if (args.length <= 1) {
                    args = args[0];
                }
                if (err) {
                    var safeResults = {};
                    _forEachOf(results, function(val, rkey) {
                        safeResults[rkey] = val;
                    });
                    safeResults[k] = args;
                    hasError = true;

                    callback(err, safeResults);
                }
                else {
                    results[k] = args;
                    async.setImmediate(taskComplete);
                }
            });
            var requires = task.slice(0, task.length - 1);
            // prevent dead-locks
            var len = requires.length;
            var dep;
            while (len--) {
                if (!(dep = tasks[requires[len]])) {
                    throw new Error('Has nonexistent dependency in ' + requires.join(', '));
                }
                if (_isArray(dep) && _indexOf(dep, k) >= 0) {
                    throw new Error('Has cyclic dependencies');
                }
            }
            function ready() {
                return runningTasks < concurrency && _reduce(requires, function (a, x) {
                    return (a && results.hasOwnProperty(x));
                }, true) && !results.hasOwnProperty(k);
            }
            if (ready()) {
                runningTasks++;
                task[task.length - 1](taskCallback, results);
            }
            else {
                addListener(listener);
            }
            function listener() {
                if (ready()) {
                    runningTasks++;
                    removeListener(listener);
                    task[task.length - 1](taskCallback, results);
                }
            }
        });
    };



    async.retry = function(times, task, callback) {
        var DEFAULT_TIMES = 5;
        var DEFAULT_INTERVAL = 0;

        var attempts = [];

        var opts = {
            times: DEFAULT_TIMES,
            interval: DEFAULT_INTERVAL
        };

        function parseTimes(acc, t){
            if(typeof t === 'number'){
                acc.times = parseInt(t, 10) || DEFAULT_TIMES;
            } else if(typeof t === 'object'){
                acc.times = parseInt(t.times, 10) || DEFAULT_TIMES;
                acc.interval = parseInt(t.interval, 10) || DEFAULT_INTERVAL;
            } else {
                throw new Error('Unsupported argument type for \'times\': ' + typeof t);
            }
        }

        var length = arguments.length;
        if (length < 1 || length > 3) {
            throw new Error('Invalid arguments - must be either (task), (task, callback), (times, task) or (times, task, callback)');
        } else if (length <= 2 && typeof times === 'function') {
            callback = task;
            task = times;
        }
        if (typeof times !== 'function') {
            parseTimes(opts, times);
        }
        opts.callback = callback;
        opts.task = task;

        function wrappedTask(wrappedCallback, wrappedResults) {
            function retryAttempt(task, finalAttempt) {
                return function(seriesCallback) {
                    task(function(err, result){
                        seriesCallback(!err || finalAttempt, {err: err, result: result});
                    }, wrappedResults);
                };
            }

            function retryInterval(interval){
                return function(seriesCallback){
                    setTimeout(function(){
                        seriesCallback(null);
                    }, interval);
                };
            }

            while (opts.times) {

                var finalAttempt = !(opts.times-=1);
                attempts.push(retryAttempt(opts.task, finalAttempt));
                if(!finalAttempt && opts.interval > 0){
                    attempts.push(retryInterval(opts.interval));
                }
            }

            async.series(attempts, function(done, data){
                data = data[data.length - 1];
                (wrappedCallback || opts.callback)(data.err, data.result);
            });
        }

        // If a callback is passed, run this as a controll flow
        return opts.callback ? wrappedTask() : wrappedTask;
    };

    async.waterfall = function (tasks, callback) {
        callback = _once(callback || noop);
        if (!_isArray(tasks)) {
            var err = new Error('First argument to waterfall must be an array of functions');
            return callback(err);
        }
        if (!tasks.length) {
            return callback();
        }
        function wrapIterator(iterator) {
            return _restParam(function (err, args) {
                if (err) {
                    callback.apply(null, [err].concat(args));
                }
                else {
                    var next = iterator.next();
                    if (next) {
                        args.push(wrapIterator(next));
                    }
                    else {
                        args.push(callback);
                    }
                    ensureAsync(iterator).apply(null, args);
                }
            });
        }
        wrapIterator(async.iterator(tasks))();
    };

    function _parallel(eachfn, tasks, callback) {
        callback = callback || noop;
        var results = _isArrayLike(tasks) ? [] : {};

        eachfn(tasks, function (task, key, callback) {
            task(_restParam(function (err, args) {
                if (args.length <= 1) {
                    args = args[0];
                }
                results[key] = args;
                callback(err);
            }));
        }, function (err) {
            callback(err, results);
        });
    }

    async.parallel = function (tasks, callback) {
        _parallel(async.eachOf, tasks, callback);
    };

    async.parallelLimit = function(tasks, limit, callback) {
        _parallel(_eachOfLimit(limit), tasks, callback);
    };

    async.series = function(tasks, callback) {
        _parallel(async.eachOfSeries, tasks, callback);
    };

    async.iterator = function (tasks) {
        function makeCallback(index) {
            function fn() {
                if (tasks.length) {
                    tasks[index].apply(null, arguments);
                }
                return fn.next();
            }
            fn.next = function () {
                return (index < tasks.length - 1) ? makeCallback(index + 1): null;
            };
            return fn;
        }
        return makeCallback(0);
    };

    async.apply = _restParam(function (fn, args) {
        return _restParam(function (callArgs) {
            return fn.apply(
                null, args.concat(callArgs)
            );
        });
    });

    function _concat(eachfn, arr, fn, callback) {
        var result = [];
        eachfn(arr, function (x, index, cb) {
            fn(x, function (err, y) {
                result = result.concat(y || []);
                cb(err);
            });
        }, function (err) {
            callback(err, result);
        });
    }
    async.concat = doParallel(_concat);
    async.concatSeries = doSeries(_concat);

    async.whilst = function (test, iterator, callback) {
        callback = callback || noop;
        if (test()) {
            var next = _restParam(function(err, args) {
                if (err) {
                    callback(err);
                } else if (test.apply(this, args)) {
                    iterator(next);
                } else {
                    callback.apply(null, [null].concat(args));
                }
            });
            iterator(next);
        } else {
            callback(null);
        }
    };

    async.doWhilst = function (iterator, test, callback) {
        var calls = 0;
        return async.whilst(function() {
            return ++calls <= 1 || test.apply(this, arguments);
        }, iterator, callback);
    };

    async.until = function (test, iterator, callback) {
        return async.whilst(function() {
            return !test.apply(this, arguments);
        }, iterator, callback);
    };

    async.doUntil = function (iterator, test, callback) {
        return async.doWhilst(iterator, function() {
            return !test.apply(this, arguments);
        }, callback);
    };

    async.during = function (test, iterator, callback) {
        callback = callback || noop;

        var next = _restParam(function(err, args) {
            if (err) {
                callback(err);
            } else {
                args.push(check);
                test.apply(this, args);
            }
        });

        var check = function(err, truth) {
            if (err) {
                callback(err);
            } else if (truth) {
                iterator(next);
            } else {
                callback(null);
            }
        };

        test(check);
    };

    async.doDuring = function (iterator, test, callback) {
        var calls = 0;
        async.during(function(next) {
            if (calls++ < 1) {
                next(null, true);
            } else {
                test.apply(this, arguments);
            }
        }, iterator, callback);
    };

    function _queue(worker, concurrency, payload) {
        if (concurrency == null) {
            concurrency = 1;
        }
        else if(concurrency === 0) {
            throw new Error('Concurrency must not be zero');
        }
        function _insert(q, data, pos, callback) {
            if (callback != null && typeof callback !== "function") {
                throw new Error("task callback must be a function");
            }
            q.started = true;
            if (!_isArray(data)) {
                data = [data];
            }
            if(data.length === 0 && q.idle()) {
                // call drain immediately if there are no tasks
                return async.setImmediate(function() {
                    q.drain();
                });
            }
            _arrayEach(data, function(task) {
                var item = {
                    data: task,
                    callback: callback || noop
                };

                if (pos) {
                    q.tasks.unshift(item);
                } else {
                    q.tasks.push(item);
                }

                if (q.tasks.length === q.concurrency) {
                    q.saturated();
                }
            });
            async.setImmediate(q.process);
        }
        function _next(q, tasks) {
            return function(){
                workers -= 1;

                var removed = false;
                var args = arguments;
                _arrayEach(tasks, function (task) {
                    _arrayEach(workersList, function (worker, index) {
                        if (worker === task && !removed) {
                            workersList.splice(index, 1);
                            removed = true;
                        }
                    });

                    task.callback.apply(task, args);
                });
                if (q.tasks.length + workers === 0) {
                    q.drain();
                }
                q.process();
            };
        }

        var workers = 0;
        var workersList = [];
        var q = {
            tasks: [],
            concurrency: concurrency,
            payload: payload,
            saturated: noop,
            empty: noop,
            drain: noop,
            started: false,
            paused: false,
            push: function (data, callback) {
                _insert(q, data, false, callback);
            },
            kill: function () {
                q.drain = noop;
                q.tasks = [];
            },
            unshift: function (data, callback) {
                _insert(q, data, true, callback);
            },
            process: function () {
                while(!q.paused && workers < q.concurrency && q.tasks.length){

                    var tasks = q.payload ?
                        q.tasks.splice(0, q.payload) :
                        q.tasks.splice(0, q.tasks.length);

                    var data = _map(tasks, function (task) {
                        return task.data;
                    });

                    if (q.tasks.length === 0) {
                        q.empty();
                    }
                    workers += 1;
                    workersList.push(tasks[0]);
                    var cb = only_once(_next(q, tasks));
                    worker(data, cb);
                }
            },
            length: function () {
                return q.tasks.length;
            },
            running: function () {
                return workers;
            },
            workersList: function () {
                return workersList;
            },
            idle: function() {
                return q.tasks.length + workers === 0;
            },
            pause: function () {
                q.paused = true;
            },
            resume: function () {
                if (q.paused === false) { return; }
                q.paused = false;
                var resumeCount = Math.min(q.concurrency, q.tasks.length);
                // Need to call q.process once per concurrent
                // worker to preserve full concurrency after pause
                for (var w = 1; w <= resumeCount; w++) {
                    async.setImmediate(q.process);
                }
            }
        };
        return q;
    }

    async.queue = function (worker, concurrency) {
        var q = _queue(function (items, cb) {
            worker(items[0], cb);
        }, concurrency, 1);

        return q;
    };

    async.priorityQueue = function (worker, concurrency) {

        function _compareTasks(a, b){
            return a.priority - b.priority;
        }

        function _binarySearch(sequence, item, compare) {
            var beg = -1,
                end = sequence.length - 1;
            while (beg < end) {
                var mid = beg + ((end - beg + 1) >>> 1);
                if (compare(item, sequence[mid]) >= 0) {
                    beg = mid;
                } else {
                    end = mid - 1;
                }
            }
            return beg;
        }

        function _insert(q, data, priority, callback) {
            if (callback != null && typeof callback !== "function") {
                throw new Error("task callback must be a function");
            }
            q.started = true;
            if (!_isArray(data)) {
                data = [data];
            }
            if(data.length === 0) {
                // call drain immediately if there are no tasks
                return async.setImmediate(function() {
                    q.drain();
                });
            }
            _arrayEach(data, function(task) {
                var item = {
                    data: task,
                    priority: priority,
                    callback: typeof callback === 'function' ? callback : noop
                };

                q.tasks.splice(_binarySearch(q.tasks, item, _compareTasks) + 1, 0, item);

                if (q.tasks.length === q.concurrency) {
                    q.saturated();
                }
                async.setImmediate(q.process);
            });
        }

        // Start with a normal queue
        var q = async.queue(worker, concurrency);

        // Override push to accept second parameter representing priority
        q.push = function (data, priority, callback) {
            _insert(q, data, priority, callback);
        };

        // Remove unshift function
        delete q.unshift;

        return q;
    };

    async.cargo = function (worker, payload) {
        return _queue(worker, 1, payload);
    };

    function _console_fn(name) {
        return _restParam(function (fn, args) {
            fn.apply(null, args.concat([_restParam(function (err, args) {
                if (typeof console === 'object') {
                    if (err) {
                        if (console.error) {
                            console.error(err);
                        }
                    }
                    else if (console[name]) {
                        _arrayEach(args, function (x) {
                            console[name](x);
                        });
                    }
                }
            })]));
        });
    }
    async.log = _console_fn('log');
    async.dir = _console_fn('dir');
    /*async.info = _console_fn('info');
    async.warn = _console_fn('warn');
    async.error = _console_fn('error');*/

    async.memoize = function (fn, hasher) {
        var memo = {};
        var queues = {};
        var has = Object.prototype.hasOwnProperty;
        hasher = hasher || identity;
        var memoized = _restParam(function memoized(args) {
            var callback = args.pop();
            var key = hasher.apply(null, args);
            if (has.call(memo, key)) {   
                async.setImmediate(function () {
                    callback.apply(null, memo[key]);
                });
            }
            else if (has.call(queues, key)) {
                queues[key].push(callback);
            }
            else {
                queues[key] = [callback];
                fn.apply(null, args.concat([_restParam(function (args) {
                    memo[key] = args;
                    var q = queues[key];
                    delete queues[key];
                    for (var i = 0, l = q.length; i < l; i++) {
                        q[i].apply(null, args);
                    }
                })]));
            }
        });
        memoized.memo = memo;
        memoized.unmemoized = fn;
        return memoized;
    };

    async.unmemoize = function (fn) {
        return function () {
            return (fn.unmemoized || fn).apply(null, arguments);
        };
    };

    function _times(mapper) {
        return function (count, iterator, callback) {
            mapper(_range(count), iterator, callback);
        };
    }

    async.times = _times(async.map);
    async.timesSeries = _times(async.mapSeries);
    async.timesLimit = function (count, limit, iterator, callback) {
        return async.mapLimit(_range(count), limit, iterator, callback);
    };

    async.seq = function (/* functions... */) {
        var fns = arguments;
        return _restParam(function (args) {
            var that = this;

            var callback = args[args.length - 1];
            if (typeof callback == 'function') {
                args.pop();
            } else {
                callback = noop;
            }

            async.reduce(fns, args, function (newargs, fn, cb) {
                fn.apply(that, newargs.concat([_restParam(function (err, nextargs) {
                    cb(err, nextargs);
                })]));
            },
            function (err, results) {
                callback.apply(that, [err].concat(results));
            });
        });
    };

    async.compose = function (/* functions... */) {
        return async.seq.apply(null, Array.prototype.reverse.call(arguments));
    };


    function _applyEach(eachfn) {
        return _restParam(function(fns, args) {
            var go = _restParam(function(args) {
                var that = this;
                var callback = args.pop();
                return eachfn(fns, function (fn, _, cb) {
                    fn.apply(that, args.concat([cb]));
                },
                callback);
            });
            if (args.length) {
                return go.apply(this, args);
            }
            else {
                return go;
            }
        });
    }

    async.applyEach = _applyEach(async.eachOf);
    async.applyEachSeries = _applyEach(async.eachOfSeries);


    async.forever = function (fn, callback) {
        var done = only_once(callback || noop);
        var task = ensureAsync(fn);
        function next(err) {
            if (err) {
                return done(err);
            }
            task(next);
        }
        next();
    };

    function ensureAsync(fn) {
        return _restParam(function (args) {
            var callback = args.pop();
            args.push(function () {
                var innerArgs = arguments;
                if (sync) {
                    async.setImmediate(function () {
                        callback.apply(null, innerArgs);
                    });
                } else {
                    callback.apply(null, innerArgs);
                }
            });
            var sync = true;
            fn.apply(this, args);
            sync = false;
        });
    }

    async.ensureAsync = ensureAsync;

    async.constant = _restParam(function(values) {
        var args = [null].concat(values);
        return function (callback) {
            return callback.apply(this, args);
        };
    });

    async.wrapSync =
    async.asyncify = function asyncify(func) {
        return _restParam(function (args) {
            var callback = args.pop();
            var result;
            try {
                result = func.apply(this, args);
            } catch (e) {
                return callback(e);
            }
            // if result is Promise object
            if (_isObject(result) && typeof result.then === "function") {
                result.then(function(value) {
                    callback(null, value);
                })["catch"](function(err) {
                    callback(err.message ? err : new Error(err));
                });
            } else {
                callback(null, result);
            }
        });
    };

    // Node.js
    if (typeof module === 'object' && module.exports) {
        module.exports = async;
    }
    // AMD / RequireJS
    else if (typeof define === 'function' && define.amd) {
        define([], function () {
            return async;
        });
    }
    // included directly via <script> tag
    else {
        root.async = async;
    }

}());

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"_process":377}],281:[function(require,module,exports){
/**
 * BezierEasing - use bezier curve for transition easing function
 * by Gaëtan Renaudeau 2014 - 2015 – MIT License
 *
 * Credits: is based on Firefox's nsSMILKeySpline.cpp
 * Usage:
 * var spline = BezierEasing([ 0.25, 0.1, 0.25, 1.0 ])
 * spline.get(x) => returns the easing value | x must be in [0, 1] range
 *
 */

// These values are established by empiricism with tests (tradeoff: performance VS precision)
var NEWTON_ITERATIONS = 4;
var NEWTON_MIN_SLOPE = 0.001;
var SUBDIVISION_PRECISION = 0.0000001;
var SUBDIVISION_MAX_ITERATIONS = 10;

var kSplineTableSize = 11;
var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);

var float32ArraySupported = typeof Float32Array === "function";

function A (aA1, aA2) { return 1.0 - 3.0 * aA2 + 3.0 * aA1; }
function B (aA1, aA2) { return 3.0 * aA2 - 6.0 * aA1; }
function C (aA1)      { return 3.0 * aA1; }

// Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.
function calcBezier (aT, aA1, aA2) {
  return ((A(aA1, aA2)*aT + B(aA1, aA2))*aT + C(aA1))*aT;
}

// Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.
function getSlope (aT, aA1, aA2) {
  return 3.0 * A(aA1, aA2)*aT*aT + 2.0 * B(aA1, aA2) * aT + C(aA1);
}

function binarySubdivide (aX, aA, aB, mX1, mX2) {
  var currentX, currentT, i = 0;
  do {
    currentT = aA + (aB - aA) / 2.0;
    currentX = calcBezier(currentT, mX1, mX2) - aX;
    if (currentX > 0.0) {
      aB = currentT;
    } else {
      aA = currentT;
    }
  } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);
  return currentT;
}

function newtonRaphsonIterate (aX, aGuessT, mX1, mX2) {
  for (var i = 0; i < NEWTON_ITERATIONS; ++i) {
    var currentSlope = getSlope(aGuessT, mX1, mX2);
    if (currentSlope === 0.0) return aGuessT;
    var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
    aGuessT -= currentX / currentSlope;
  }
  return aGuessT;
}

/**
 * points is an array of [ mX1, mY1, mX2, mY2 ]
 */
function BezierEasing (points, b, c, d) {
  if (arguments.length === 4) {
    return new BezierEasing([ points, b, c, d ]);
  }
  if (!(this instanceof BezierEasing)) return new BezierEasing(points);

  if (!points || points.length !== 4) {
    throw new Error("BezierEasing: points must contains 4 values");
  }
  for (var i=0; i<4; ++i) {
    if (typeof points[i] !== "number" || isNaN(points[i]) || !isFinite(points[i])) {
      throw new Error("BezierEasing: points should be integers.");
    }
  }
  if (points[0] < 0 || points[0] > 1 || points[2] < 0 || points[2] > 1) {
    throw new Error("BezierEasing x values must be in [0, 1] range.");
  }

  this._str = "BezierEasing("+points+")";
  this._css = "cubic-bezier("+points+")";
  this._p = points;
  this._mSampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);
  this._precomputed = false;

  this.get = this.get.bind(this);
}

BezierEasing.prototype = {

  get: function (x) {
    var mX1 = this._p[0],
      mY1 = this._p[1],
      mX2 = this._p[2],
      mY2 = this._p[3];
    if (!this._precomputed) this._precompute();
    if (mX1 === mY1 && mX2 === mY2) return x; // linear
    // Because JavaScript number are imprecise, we should guarantee the extremes are right.
    if (x === 0) return 0;
    if (x === 1) return 1;
    return calcBezier(this._getTForX(x), mY1, mY2);
  },

  getPoints: function() {
    return this._p;
  },

  toString: function () {
    return this._str;
  },

  toCSS: function () {
    return this._css;
  },

  // Private part

  _precompute: function () {
    var mX1 = this._p[0],
      mY1 = this._p[1],
      mX2 = this._p[2],
      mY2 = this._p[3];
    this._precomputed = true;
    if (mX1 !== mY1 || mX2 !== mY2)
      this._calcSampleValues();
  },

  _calcSampleValues: function () {
    var mX1 = this._p[0],
      mX2 = this._p[2];
    for (var i = 0; i < kSplineTableSize; ++i) {
      this._mSampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
    }
  },

  /**
   * getTForX chose the fastest heuristic to determine the percentage value precisely from a given X projection.
   */
  _getTForX: function (aX) {
    var mX1 = this._p[0],
      mX2 = this._p[2],
      mSampleValues = this._mSampleValues;

    var intervalStart = 0.0;
    var currentSample = 1;
    var lastSample = kSplineTableSize - 1;

    for (; currentSample !== lastSample && mSampleValues[currentSample] <= aX; ++currentSample) {
      intervalStart += kSampleStepSize;
    }
    --currentSample;

    // Interpolate to provide an initial guess for t
    var dist = (aX - mSampleValues[currentSample]) / (mSampleValues[currentSample+1] - mSampleValues[currentSample]);
    var guessForT = intervalStart + dist * kSampleStepSize;

    var initialSlope = getSlope(guessForT, mX1, mX2);
    if (initialSlope >= NEWTON_MIN_SLOPE) {
      return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
    } else if (initialSlope === 0.0) {
      return guessForT;
    } else {
      return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
    }
  }
};

// CSS mapping
BezierEasing.css = {
  "ease":        BezierEasing.ease      = BezierEasing(0.25, 0.1, 0.25, 1.0),
  "linear":      BezierEasing.linear    = BezierEasing(0.00, 0.0, 1.00, 1.0),
  "ease-in":     BezierEasing.easeIn    = BezierEasing(0.42, 0.0, 1.00, 1.0),
  "ease-out":    BezierEasing.easeOut   = BezierEasing(0.00, 0.0, 0.58, 1.0),
  "ease-in-out": BezierEasing.easeInOut = BezierEasing(0.42, 0.0, 0.58, 1.0)
};

module.exports = BezierEasing;

},{}],282:[function(require,module,exports){
'use strict';

exports.message = require('./src/message');
exports.request = require('./src/request');
exports.response = require('./src/response');
exports.playerstate = require('./src/player_state');

},{"./src/message":283,"./src/player_state":284,"./src/request":285,"./src/response":286}],283:[function(require,module,exports){
/**
 * A set of Message headers.
 *
 * @name exports.Headers
 * @typedef {Object.<string, string>}
 */
exports.Headers;

/**
 * A body of a Request-Response.
 *
 * @name exports.Body
 * @typedef {*}
 */
exports.Body;

/**
 * A serialized Message object.
 *
 * @name Spotify.Cosmos.SerializedMessage
 * @typedef {{
 *   uri: Spotify.Cosmos.URI,
 *   headers: Spotify.Cosmos.Headers,
 *   body: Spotify.Cosmos.Body
 * }}
 */
exports.SerializedMessage;

/**
 * Encapsulates a message.
 *
 * A message is an entity that has a URI, headers and a body.
 *
 * @constructs Spotify.Cosmos.Message
 * @param {Spotify.Cosmos.URI} uri The URI of the message
 * @param {Spotify.Cosmos.Headers=} opt_headers The optional headers of the
 *     message.
 * @param {Spotify.Cosmos.Body=} opt_body The optional body of the message.
 */
function Message(uri, opt_headers, opt_body) {
  if (uri == null)
    throw new TypeError('Invalid `uri` argument for Message.');

  /**
   * The URI of the Message.
   *
   * @type {Spotify.Cosmos.URI}
   * @protected
   */
  this._uri = uri;

  /**
   * The headers of the Message.
   *
   * @type {Spotify.Cosmos.Headers}
   * @protected
   */
  this._headers = {};

  /**
   * The body of the Message.
   *
   * @type {Spotify.Cosmos.Body}
   * @protected
   */
  this._body = this._encodeBody(opt_body || '');

  if (opt_headers) this._setHeaders(opt_headers);
}
exports.Message = Message;

/**
 * Creates a new Message from a SerializedMessage object.
 *
 * @param {Spotify.Cosmos.SerializedMessage} object The serialized request.
 * @return {Spotify.Cosmos.Message|null} The new Message object or null.
 */
Message.fromObject = function(object) {
  return (object && object.uri) ?
    new Message(
        object.uri,
        object.headers,
        object.body
    ) : null;
};

/**
 * Encodes a message body to a string.
 *
 * @param {*} body The value for the body.
 * @return {string} The body encoded as a string.
 */
Message.prototype._encodeBody = function(body) {
  if (typeof body != 'string') {
    body = JSON.stringify(body);
  }
  return body;
};

/**
 * Returns the URI of the message.
 *
 * @return {Spotify.Cosmos.URI} The URI of the message.
 */
Message.prototype.getURI = function() {
  return this._uri;
};

/**
 * Returns the mimetype of the message.
 *
 * @return {Spotify.Cosmos.MimeType} The mimetype of the message.
 */
Message.prototype.getMimeType = function() {
  return this._headers['accept'];
};

/**
 * Returns the value of a message's headers.
 *
 * @param {string} name The name of the header.
 * @return {string|null} The header value or null if the header wasn't set.
 */
Message.prototype.getHeader = function(name) {
  return this._headers[name.toLowerCase()] || null;
};

/**
 * Returns the headers of the message.
 *
 * @return {Spotify.Cosmos.Headers} The headers of the message.
 */
Message.prototype.getHeaders = function() {
  var _headers = this._headers;
  var headers = {};
  for (var name in _headers) {
    if (!_headers.hasOwnProperty(name)) continue;
    headers[name] = _headers[name];
  }
  return headers;
};

/**
 * Sets a bunch of headers to the message's headers.
 *
 * @param {Spotify.Cosmos.Headers} headers The headers to set to the message.
 * @protected
 */
Message.prototype._setHeaders = function(headers) {
  var _headers = this._headers;
  for (var name in headers) {
    if (!headers.hasOwnProperty(name)) continue;
    _headers[name.toLowerCase()] = headers[name];
  }
  return this;
};

/**
 * Returns the body of the message.
 *
 * @return {Spotify.Cosmos.Body} The body of the message.
 */
Message.prototype.getBody = function() {
  return this._body;
};

/**
 * Returns the body as a JSON object.
 *
 * @return {Object|null} The body of the message parsed as a JSON value. Can
 *     be null if the body is not a proper JSON string.
 */
Message.prototype.getJSONBody = function() {
  try {
    return JSON.parse(this._body);
  } catch(e) {
    return null;
  }
};

/**
 * Creates a new Message instance with data copied from the current instance.
 *
 * @param {Spotify.Cosmos.Headers=} opt_headers The optional headers of the
 *     message.
 * @param {Spotify.Cosmos.Body=} opt_body The optional body of the message.
 */
Message.prototype.copy = function(opt_headers, opt_body) {
  return new Message(
      this._uri,
      this._copyHeaders(opt_headers),
      typeof opt_body != 'undefined' ? opt_body : this._body
  );
};

/**
 * Copies the headers of the message.
 *
 * @param {Spotify.Cosmos.Headers=} opt_headers The optional headers of the
 *     message.
 * @return {Spotify.Cosmos.Headers} The headers of the message.
 */
Message.prototype._copyHeaders = function(opt_headers) {
  var headers;
  if (opt_headers) {
    var _headers = this._headers;
    var name;
    headers = {};
    for (name in _headers) {
      if (!_headers.hasOwnProperty(name)) continue;
      headers[name] = _headers[name];
    }
    for (name in opt_headers) {
      if (!opt_headers.hasOwnProperty(name)) continue;
      headers[name.toLowerCase()] = opt_headers[name];
    }
  } else {
    headers = this._headers;
  }
  return headers;
};

/**
 * Serializes the message into a plain object.
 *
 * @return {Spotify.Cosmos.SerializedMessage} The serialized object.
 */
Message.prototype.serialize = function() {
  return this.toJSON();
};

/**
 * Returns a JSON-object representation of the message.
 *
 * @return {Object} The JSON representation of the message.
 */
Message.prototype.toJSON = function() {
  return {
    uri: this._uri,
    headers: this._headers,
    body: this._body
  };
};

},{}],284:[function(require,module,exports){
var inherit = require('spotify-inheritance').inherit;

/**
 * PlayerState is used for two distinct purposes: Pushing new state to the
 * player (this is done when you request to play a completely new context with
 * 'play' method) and retrieving player state updates.
 *
 * Changing properties on PlayerState objects will not change the state of
 * the player unless you pass it to the 'play' method.
 *
 * @param {Object} stateData the data for the playerState.
 */
function PlayerState(stateData) {
  Serializable.call(this, [
    'action',
    'context',
    'tracks',
    'index',
    'playing',
    'loading',
    'track',
    'position',
    'duration',
    'volume',
    'options',
    'play_origin',
    'next_page_url',
    'prev_page_url'
  ]);

  stateData = stateData || {};
  /**
   * What kind of the action player should perform.
   * It's set directly before sending the request.
   * @type {String}
   */
  this.action = stateData.action;

  /**
   * Spotify uri describing the context that
   * will be played e.g playlist, album or artist.
   * Example: spotify:artist:4XaUmUGjidSklcDHxv3XWf,
   * spotify:user:daftpunkofficial:playlist:5nrg0D90OlFyveVfrQD0zE,
   * spotify:album:2nXJkqkS1tIKIyhBcFMmwz
   *
   * @type {String}
   */
  this.context = stateData.context;

  /**
   * The list of tracks uris to play in the given context.
   * Example: [
   *    spotify:track:0bXpmJyHHYPk6QBFj25bYF,
   *    spotify:track:6DXFVsLcEvOTSrkG9G1Cb1,
   *    spotify:track:6rxEjkoar48SssZePbtb2x
   * ]
   *
   * @type {Array.<String>}
   */
  this.tracks = stateData.tracks;

  /**
   * Which element on the this.tracks list should
   * be played.
   *
   * @type {Number}
   */
  this.index = stateData.index;

  /**
   * Is the player currently playing
   */
  this.playing = stateData.playing;
  this.loading = stateData.loading;

  /**
   * Current track URI
   * @type {String}
   */
  this.track = stateData.track;


  this.position = stateData.position;

  this.volume = stateData.volume;

  /**
   * Current track duration in miliseconds?
   * @type {Number}
   */
  this.duration = stateData.duration;

  /**
   * See PlayOptions description
   * @type {cosmos-bindings-js/scripts/player_state~PlayOptions}
   */
  this.options = new PlayOptions(stateData.options);

  /**
   * See PlayOrigin description
   * @type {cosmos-bindings-js/scripts/player_state~PlayOrigin}
   */
  this.play_origin = new PlayOrigin(stateData.play_origin);

  /**
   * Before the list of tracks that are to be played ends, a request will be sent
   * to this URL, which is supposed to return a list of tracks. That list of
   * tracks will then be appended to the list of tracks in the context.
   *
   * The response payload of the next_page_url should look like this:
   *
   * {
   *   "tracks": [
   *     { "track": "spotify:track:$TRACK-ID1", "context": "spotify:album:$ALBUM-ID1" },
   *     { "track": "spotify:track:$TRACK-ID2", "context": "spotify:album:$ALBUM-ID1" },
   *     { "track": "spotify:track:$TRACK-ID3", "context": "spotify:album:$ALBUM-ID1" },
   *   ],
   *   "next_page_url": "...", // Optional
   *   "prev_page_url": "..." // Optional
   * }
   *
   * May be null, which is the same as a URL that would return an empty list
   * of tracks (but with null, no network request is made).
   */
  this.next_page_url = stateData.next_page_url;

  /**
   * Like `next_page_url`, but for going backwards in the context.
   */
  this.prev_page_url = stateData.prev_page_url;
}
inherit(PlayerState, Serializable);

/**
 * Ovverides prototype method.
 * Converts play options and origin to
 * serializable to make sure only correct data
 * is returned.
 * @return {Object} Data associated with player state.
 */
PlayerState.prototype.serialize = function() {
  if (this.options && !(this.options instanceof PlayOptions)) {
    this.options = new PlayOptions(this.options);
  }

  if (this.play_origin && !(this.play_origin instanceof PlayOrigin)) {
    this.play_origin = new PlayOrigin(this.play_origin);
  }

  return this.constructor.prototype.serialize.call(this);
};

/**
 * Possible player actions.
 */
PlayerState.ACTIONS = {
  UNKNOWN: 'unknown',
  PLAY: 'play',
  UPDATE: 'update',
  STOP: 'stop',
  RESUME: 'resume',
  PAUSE: 'pause',
  SKIP_PREV: 'skip_prev',
  SKIP_NEXT: 'skip_next'
};

function PlayOrigin(data) {
  Serializable.call(this, [
    'source',
    'source_context',
    'reason',
    'referrer',
    'referrer_version',
    'referrer_vendor'
  ]);

  data = data || {};

  /**
   * What kind of playlist did we play from?
   *
   * The default value of this property is "unknown". Must have a value.
   *
   * Valid values include 'album', 'artist', 'extlink', 'playlist', 'playqueue',
   * 'radio', 'search', 'unknown'.
   *
   * For an up to date list of valid values, see `PLAY_SOURCES` in
   * https://git.spotify.net/cgit.cgi/log-parser.git/tree/spotify/log_parser/messages_specs.py
   */
  this.source = data.source || 'unknown';

  /**
   * The uri of the view that initiated the playback.
   */
  this.source_context = data.source_context || 'unknown';

  /**
   * Why was the song started?
   *
   * The default value of this property is "unknown". Must have a value.
   *
   * A list of valid values that might be used by features:
   *
   * unknown    = Client doesn't know
   * clickrow   = A row in the song list was clicked/opened
   * playbtn    = The play button was pressed
   * urlopen    = A Url was opened
   *
   * For a complete and up to date list of valid values, see `PLAY_REASONS` in
   * https://git.spotify.net/cgit.cgi/log-parser.git/tree/spotify/log_parser/messages_specs.py
   */
  this.reason = data.reason || 'unknown';

  /**
   * Either a remote site or a spotify app which initiated the request.
   *
   * NOTE: This normally should be a readonly property and not be set
   * explicitly in the PlayerState as the Player will overwrite it when sending the request.
   */
  this.referrer = data.referrer || 'unknown';

  /**
   * The version of the referrer, where applicable. It usually makes sense to
   * set this value to the version of the JS app version, for instance "0.7.5".
   *
   * NOTE: This normally should be a readonly property and not be set
   * explicitly in the PlayerState as the Player will overwrite it when sending the request.
   */
  this.referrer_version = data.referrer_version || 'unknown';

  /**
   * The vendor of the referrer, where applicable.
   * For example com.soundrop, com.spotify.
   *
   * NOTE: This normally should be a readonly property and not be set
   * explicitly in the PlayerState as the Player will overwrite it when sending the request.
   */
  this.referrer_vendor = data.referrer_vendor || 'unknown';
}
inherit(PlayOrigin, Serializable);

/**
 * What kind of options user has
 * with the player. By default
 * all 'can_*' properties are set to true.
 * You might want to restrict some of them
 * in the special cases like ads (no skipping)
 * or radio no skipping prev.
 * @constructor
 * @param {Object} options The options data.
 */
function PlayOptions(options) {
  Serializable.call(this, [
    'repeat',
    'shuffle',
    'can_repeat',
    'can_shuffle',
    'can_skip_prev',
    'can_skip_next',
    'can_seek',
    'use_dmca_rules'
  ]);
  options = options || {};

  /**
   * True if repeat (repeat all, not single track repeat) is (or is to be) enabled.
   *
   * Default value is false
   */
  this.repeat = options.repeat !== undefined ? options.repeat : false;

  /**
   * True if shuffle is (or is to be) enabled.
   *
   * Default value is false
   */
  this.shuffle = options.shuffle !== undefined ? options.shuffle : false;

  /**
   * True if this context can be repeated. This would be false for instance in the
   * case of radio.
   *
   * Default value is true.
   */
  this.can_repeat = options.can_repeat !== undefined ? options.can_repeat : true;

  /**
   * True if this context can be shuffled. This would be false for instance in the
   * case of radio.
   *
   * Default value is true.
   */
  this.can_shuffle = options.can_shuffle !== undefined ? options.can_shuffle : true;

  /**
   * True if the user is (or should be) allowed to skip to the previous track.
   *
   * Default value is true.
   */
  this.can_skip_prev = options.can_skip_prev !== undefined ? options.can_skip_prev : true;

  /**
   * True if the user is (or should be) allowed to skip to the next track.
   *
   * Default value is true.
   */
  this.can_skip_next = options.can_skip_next !== undefined ? options.can_skip_next : true;

  /**
   * True if the user is (or should be) allowed to seek to a certain time in the
   * currently playing track.
   *
   * Default value is true.
   */
  this.can_seek = options.can_seek !== undefined ? options.can_seek : true;

  /**
   * True if the track player should automatically apply DMCA rules when playing.
   * DMCA rules should be enabled for users that have free radio in the US, and
   * controls how many tracks the user are allowed to skip etc.
   *
   * Default value is false.
   */
  this.use_dmca_rules = options.use_dmca_rules !== undefined ? options.use_dmca_rules : false;
}
inherit(PlayOptions, Serializable);

/**
 * The object accepting only defined properties.
 * To make sure only valid properties are passed
 * always use 'serialize()' when object value needed.
 * @constructor
 * @param {Array.<string>} allowedProps The list of the properties
 * that are supported for the object.
 */
function Serializable(allowedProps) {
  this._props = allowedProps || [];
}

/**
 * The JSON representation of the object.
 * @return {Object} Data associated with current player state.
 */
Serializable.prototype.serialize = function() {
  var data = {};
  var prop;

  for (var i = 0, l = this._props.length; i < l; i++) {
    prop = this._props[i];
    if (this[prop] !== undefined) {
      if (this[prop] instanceof Serializable) {
        data[prop] = this[prop].serialize();
      } else {
        data[prop] = this[prop];
      }
    }
  }

  return data;
};

exports.PlayerState = PlayerState;

},{"spotify-inheritance":396}],285:[function(require,module,exports){
var inherit = require('spotify-inheritance').inherit;

var Message = require('./message').Message;

/**
 * Request actions.
 *
 * @name exports.Action
 * @enum {string}
 */
exports.Action = {
  DELETE: 'DELETE',
  GET: 'GET',
  HEAD: 'HEAD',
  POST: 'POST',
  PUT: 'PUT',
  SUB: 'SUB',
  PATCH: 'PATCH'
};

/**
 * A serialized Request object.
 *
 * @name Spotify.Cosmos.SerializedRequest
 * @typedef {{
 *   uri: Spotify.Cosmos.URI,
 *   headers: Spotify.Cosmos.Headers,
 *   body: Spotify.Cosmos.Body
 * }}
 */
exports.SerializedRequest;

/**
 * Encapsulates a request to the handlers.
 *
 * Instances of this class are "immutable" and should not be changed.
 *
 * @constructs Spotify.Cosmos.Request
 * @extends Spotify.Cosmos.Message
 * @param {Spotify.Cosmos.Action} action The action of the request.
 * @param {Spotify.Cosmos.URI} uri The URI of the request
 * @param {Spotify.Cosmos.Headers=} opt_headers The optional headers of the
 *     request.
 * @param {Spotify.Cosmos.Body=} opt_body The optional body of the request.
 */
function Request(action, uri, opt_headers, opt_body) {
  if (!(this instanceof Request))
    return new Request(action, uri, opt_headers, opt_body);
  if (!action)
    throw new TypeError('Invalid `action` argument for Request.');
  Message.call(this, uri, opt_headers, opt_body);

  /**
   * The action of the request.
   *
   * @type {Spotify.Cosmos.Action}
   * @protected
   */
  this._action = action;
}
inherit(Request, Message);
exports.Request = Request;

/**
 * Creates a new Request from a SerializedRequest object.
 *
 * @param {Spotify.Cosmos.SerializedRequest} object The serialized request.
 * @return {Spotify.Cosmos.Request|null} The new Request object or null.
 */
Request.fromObject = function(object) {
  return (object && object.action && object.uri) ?
    new Request(
        object.action,
        object.uri,
        object.headers,
        object.body
    ) : null;
};

/**
 * Returns the action of the request.
 *
 * @return {Spotify.Cosmos.Action} The action of the request.
 */
Request.prototype.getAction = function() {
  return this._action;
};

/**
 * @inheritDoc
 */
Request.prototype.copy = function(opt_headers, opt_body) {
  return new Request(
      this._action,
      this._uri,
      this._copyHeaders(opt_headers),
      typeof opt_body != 'undefined' ? opt_body : this._body
  );
};

/**
 * @inheritDoc
 */
Request.prototype.toJSON = function() {
  return {
    action: this._action,
    uri: this._uri,
    headers: this._headers,
    body: this._body
  };
};



},{"./message":283,"spotify-inheritance":396}],286:[function(require,module,exports){
var inherit = require('spotify-inheritance').inherit;

var Message = require('./message').Message;

/**
 * Statuscode.
 * The statuses with negative numbers are reserved for
 * errors that originate within the cosmos library.
 *
 * @name exports.StatusCode
 * @enum {number}
 */
exports.StatusCode = {
  OK: 200,
  CREATED: 201,
  ACCEPTED: 202,
  BAD_REQUEST: 400,
  UNAUTHORIZED: 401,
  FORBIDDEN: 403,
  NOT_FOUND: 404,
  METHOD_NOT_ALLOWED: 405,
  TIMED_OUT: 408,
  CONFLICT: 409,
  GONE: 410,
  INTERNAL_SERVER_ERROR: 500,
  NOT_IMPLEMENTED: 501,
  BAD_GATEWAY: 502,
  SERVICE_UNAVAILABLE: 503,

  /** Something went wrong, but the exact reason is not known. */
  ERROR_UNKNOWN: -100,

  /** A resource allocation required to complete the request failed. */
  ERROR_ALLOCATION_FAILED: -101,

  /** The body could not be decoded because it does
   not conform to the encoding header field. */
  ERROR_INVALID_ENCODING: -102,

  /** The router detected an infinite loop while processing the request. */
  ERROR_INFINITE_LOOP: -103,

  /** No endpoint resolver that could handle the request was found. */
  ERROR_RESOLVER_NOT_FOUND: -104
};

/**
 * A serialized Response object.
 *
 * @name Spotify.Cosmos.SerializedResponse
 * @typedef {{
 *   uri: Spotify.Cosmos.URI,
 *   status: Spotify.Cosmos.StatusCode,
 *   headers: Spotify.Cosmos.Headers,
 *   body: Spotify.Cosmos.Body
 * }}
 */
exports.SerializedResponse;

/**
 * Encapsulates a response from the handlers.
 *
 * @constructs Spotify.Cosmos.Response
 * @extends Spotify.Cosmos.Message
 * @param {Spotify.Cosmos.URI} uri The URI of the response
 * @param {Spotify.Cosmos.StatusCode} status The status of the response.
 * @param {Spotify.Cosmos.Headers=} opt_headers The optional headers of the
 *     response.
 * @param {Spotify.Cosmos.Body=} opt_body The optional body of the response.
 */
function Response(uri, status, opt_headers, opt_body) {
  if (!(this instanceof Response))
    return new Response(uri, status, opt_headers, opt_body, opt_requestURI);
  if (typeof status == 'undefined' || status == null)
    throw new TypeError('Invalid `status` argument for Response.');

  Message.call(this, uri, opt_headers, opt_body);

  /**
   * The Status of the Response.
   *
   * @type {Spotify.Cosmos.StatusCode}
   * @protected
   */
  this._status = status;
}
inherit(Response, Message);
exports.Response = Response;

/**
 * Creates a new Response from a SerializedResponse object.
 *
 * @param {Spotify.Cosmos.SerializedResponse} object The serialized response.
 * @return {Spotify.Cosmos.Response|null} The new Response object or null.
 */
Response.fromObject = function(object) {
  return (object && object.uri && object.status) ?
    new Response(
        object.uri,
        object.status,
        object.headers,
        object.body
    ) : null;
};

/**
 * @inheritDoc
 */
Response.prototype.getMimeType = function() {
  return this._headers['content-type'];
};

/**
 * Returns the status code of the Response.
 *
 * @return {Spotify.Cosmos.StatusCode} The status code of the response.
 */
Response.prototype.getStatusCode = function() {
  return this._status;
};

/**
 * @inheritDoc
 */
Response.prototype.copy = function(opt_headers, opt_body) {
  return new Response(
      this._uri,
      this._status,
      this._copyHeaders(opt_headers),
      typeof opt_body != 'undefined' ? opt_body : this._body
  );
};

/**
 * @inheritDoc
 */
Response.prototype.toJSON = function() {
  return {
    uri: this._uri,
    status: this._status,
    headers: this._headers,
    body: this._body
  };
};


},{"./message":283,"spotify-inheritance":396}],287:[function(require,module,exports){

/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = require('./debug');
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // is webkit? http://stackoverflow.com/a/16459606/376773
  return ('WebkitAppearance' in document.documentElement.style) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (window.console && (console.firebug || (console.exception && console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  return JSON.stringify(v);
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs() {
  var args = arguments;
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return args;

  var c = 'color: ' + this.color;
  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
  return args;
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}
  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage(){
  try {
    return window.localStorage;
  } catch (e) {}
}

},{"./debug":288}],288:[function(require,module,exports){

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = debug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = require('ms');

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lowercased letter, i.e. "n".
 */

exports.formatters = {};

/**
 * Previously assigned color.
 */

var prevColor = 0;

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 *
 * @return {Number}
 * @api private
 */

function selectColor() {
  return exports.colors[prevColor++ % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function debug(namespace) {

  // define the `disabled` version
  function disabled() {
  }
  disabled.enabled = false;

  // define the `enabled` version
  function enabled() {

    var self = enabled;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // add the `color` if not set
    if (null == self.useColors) self.useColors = exports.useColors();
    if (null == self.color && self.useColors) self.color = selectColor();

    var args = Array.prototype.slice.call(arguments);

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %o
      args = ['%o'].concat(args);
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    if ('function' === typeof exports.formatArgs) {
      args = exports.formatArgs.apply(self, args);
    }
    var logFn = enabled.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }
  enabled.enabled = true;

  var fn = exports.enabled(namespace) ? enabled : disabled;

  fn.namespace = namespace;

  return fn;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  var split = (namespaces || '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

},{"ms":372}],289:[function(require,module,exports){
var hasOwn = Object.prototype.hasOwnProperty;
var toStr = Object.prototype.toString;
var undefined;

var isArray = function isArray(arr) {
	if (typeof Array.isArray === 'function') {
		return Array.isArray(arr);
	}

	return toStr.call(arr) === '[object Array]';
};

var isPlainObject = function isPlainObject(obj) {
	'use strict';
	if (!obj || toStr.call(obj) !== '[object Object]') {
		return false;
	}

	var has_own_constructor = hasOwn.call(obj, 'constructor');
	var has_is_property_of_method = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');
	// Not own constructor property must be Object
	if (obj.constructor && !has_own_constructor && !has_is_property_of_method) {
		return false;
	}

	// Own properties are enumerated firstly, so to speed up,
	// if last one is own, then all properties are own.
	var key;
	for (key in obj) {}

	return key === undefined || hasOwn.call(obj, key);
};

module.exports = function extend() {
	'use strict';
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[0],
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if (typeof target === 'boolean') {
		deep = target;
		target = arguments[1] || {};
		// skip the boolean and the target
		i = 2;
	} else if ((typeof target !== 'object' && typeof target !== 'function') || target == null) {
		target = {};
	}

	for (; i < length; ++i) {
		options = arguments[i];
		// Only deal with non-null/undefined values
		if (options != null) {
			// Extend the base object
			for (name in options) {
				src = target[name];
				copy = options[name];

				// Prevent never-ending loop
				if (target === copy) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {
					if (copyIsArray) {
						copyIsArray = false;
						clone = src && isArray(src) ? src : [];
					} else {
						clone = src && isPlainObject(src) ? src : {};
					}

					// Never move original objects, clone them
					target[name] = extend(deep, clone, copy);

				// Don't bring in undefined values
				} else if (copy !== undefined) {
					target[name] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};


},{}],290:[function(require,module,exports){
/*
Finally
*/'use strict';

var prime = require('prime');

var kindOf = require('mout/lang/kindOf');
var map = require('mout/array/map');
var slice = require('mout/array/slice');
var forEach = require('mout/array/forEach');
var reduce = require('mout/array/reduce');

var each = require('mout/collection/forEach');
var cmap = require('mout/collection/map');

var push_ = Array.prototype.push;

/* create the flow */
var Flow = prime({

  /* options */
  constructor: function Flow() {
    this._seq = [];
  },

  /* add steps to the flow */
  then: function() {
    this._push(this._callbacks(arguments));
    return this;
  },

  _parallel: function(parallel, args) {
    var self = this;
    return function() {
      var control = new Controller(self, self._index++);
      self._controls.push(control);
      parallel.apply(control, args ? args.concat(slice(arguments)) : arguments);
    };
  },

  _push: function(parallels, args) {
    if (!parallels.length) return;
    this._seq.push(map(parallels, function(parallel) {
      return this._parallel(parallel, args);
    }, this));
  },

  _callbacks: function(callbacks) {
    return reduce(callbacks, function(a, b) {
      if (kindOf(b) === 'Array') push_.apply(a, b);
      else a.push(b);
      return a;
    }, []);
  },

  /* will make a sequential entry for each entry in the object */
  sequential: function(object) {
    var callbacks = this._callbacks(slice(arguments, 1));
    each(object, function(value, key) {
      this._push(callbacks, [value, key]);
    }, this);
    return this;
  },

  /* will make a single sequential entry with one parallel for each entry in the object */
  parallel: function(object, parallel) {
    var parallels = cmap(object, function(value, key) {
      return this._parallel(parallel, [value, key]);
    }, this);
    if (parallels.length) this._seq.push(parallels);
    return this;
  },

  /* assign last step and execute the flow */
  finally: function() {
    this.then.apply(this, arguments);
    this._continue.call(this);
    return this;
  },

  /* execute the flow with arguments to the first step */
  run: function() {
    this._continue.apply(this, arguments);
    return this;
  },

  // private

  _break: function() {
    this._seq.splice(0, this._seq.length - 1);
    this._continue.apply(this, arguments);
  },

  _spread: function(error, args) {
    var seq = this._next();
    if (!seq || !(seq = seq[0])) return;
    if (!args || !args.length) args = [undefined];
    this._length = args.length;
    forEach(args, function(arg) {
      seq(error, arg);
    });
  },

  _continue: function() {
    var seq = this._next();
    if (!seq) return;
    this._length = seq.length;
    var args = arguments;
    forEach(seq, function(parallel) {
      parallel.apply(null, args);
    });
  },

  _next: function() {
    var seq = this._seq.shift();
    if (!seq) return;

    if (this._controls) forEach(this._controls, function(control) { // kill old controls
      control._kill();
    });

    // reset variables

    this._arguments = [];
    this._errors = [];
    this._controls = [];
    this._index = 0;

    return seq;
  },

  _done: function(index, error, data) {
    this._arguments[index] = data;
    if (error) this._errors.push(error);
    if (!--this._length) {
      var errors = null;
      if (this._errors.length === 1) errors = this._errors[0];
      else if (this._errors.length) errors = new Error(map(this._errors, function(e) {
        return e.message;
      }).join('\n'));
      this._continue.apply(this, [errors].concat(this._arguments));
    }
    else this._controls[index]._kill();
  }

});

/* control the flow */
var Controller = function Controller(flow, index) {

  var dead;

  this._kill = function() {
    dead = true;
  };

  /* break the flow */
  this.break = function() {
    if (!dead) flow._break.apply(flow, arguments);
  };

  /* step in the next sequential */
  this.continue = function() {
    if (!dead) flow._continue.apply(flow, arguments);
  };

  /* spread results to the next sequential */
  this.spread = function(error, args) {
    if (!dead) flow._spread(error, args);
  };

  /* set the the current parallel in the sequential as complete */
  var done = this.done = function(error, data) {
    if (!dead) flow._done.call(flow, index, error, data);
  };

};

/* public interface */
module.exports = function() {
  var flow = new Flow();
  flow.then.apply(flow, arguments);
  return flow;
};

},{"mout/array/forEach":291,"mout/array/map":292,"mout/array/reduce":293,"mout/array/slice":294,"mout/collection/forEach":295,"mout/collection/map":297,"mout/lang/kindOf":305,"prime":312}],291:[function(require,module,exports){


    /**
     * Array forEach
     */
    function forEach(arr, callback, thisObj) {
        if (arr == null) {
            return;
        }
        var i = -1,
            len = arr.length;
        while (++i < len) {
            // we iterate over sparse items since there is no way to make it
            // work properly on IE 7-8. see #64
            if ( callback.call(thisObj, arr[i], i, arr) === false ) {
                break;
            }
        }
    }

    module.exports = forEach;



},{}],292:[function(require,module,exports){
var makeIterator = require('../function/makeIterator_');

    /**
     * Array map
     */
    function map(arr, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        var results = [];
        if (arr == null){
            return results;
        }

        var i = -1, len = arr.length;
        while (++i < len) {
            results[i] = callback(arr[i], i, arr);
        }

        return results;
    }

     module.exports = map;


},{"../function/makeIterator_":299}],293:[function(require,module,exports){


    /**
     * Array reduce
     */
    function reduce(arr, fn, initVal) {
        // check for args.length since initVal might be "undefined" see #gh-57
        var hasInit = arguments.length > 2,
            result = initVal;

        if (arr == null || !arr.length) {
            if (!hasInit) {
                throw new Error('reduce of empty array with no initial value');
            } else {
                return initVal;
            }
        }

        var i = -1, len = arr.length;
        while (++i < len) {
            if (!hasInit) {
                result = arr[i];
                hasInit = true;
            } else {
                result = fn(result, arr[i], i, arr);
            }
        }

        return result;
    }

    module.exports = reduce;


},{}],294:[function(require,module,exports){


    /**
     * Create slice of source array or array-like object
     */
    function slice(arr, start, end){
        var len = arr.length;

        if (start == null) {
            start = 0;
        } else if (start < 0) {
            start = Math.max(len + start, 0);
        } else {
            start = Math.min(start, len);
        }

        if (end == null) {
            end = len;
        } else if (end < 0) {
            end = Math.max(len + end, 0);
        } else {
            end = Math.min(end, len);
        }

        var result = [];
        while (start < end) {
            result.push(arr[start++]);
        }

        return result;
    }

    module.exports = slice;



},{}],295:[function(require,module,exports){
var make = require('./make_');
var arrForEach = require('../array/forEach');
var objForEach = require('../object/forOwn');

    /**
     */
    module.exports = make(arrForEach, objForEach);



},{"../array/forEach":291,"../object/forOwn":308,"./make_":296}],296:[function(require,module,exports){
var slice = require('../array/slice');

    /**
     * internal method used to create other collection modules.
     */
    function makeCollectionMethod(arrMethod, objMethod, defaultReturn) {
        return function(){
            var args = slice(arguments);
            if (args[0] == null) {
                return defaultReturn;
            }
            // array-like is treated as array
            return (typeof args[0].length === 'number')? arrMethod.apply(null, args) : objMethod.apply(null, args);
        };
    }

    module.exports = makeCollectionMethod;



},{"../array/slice":294}],297:[function(require,module,exports){
var isObject = require('../lang/isObject');
var values = require('../object/values');
var arrMap = require('../array/map');
var makeIterator = require('../function/makeIterator_');

    /**
     * Map collection values, returns Array.
     */
    function map(list, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        // list.length to check array-like object, if not array-like
        // we simply map all the object values
        if( isObject(list) && list.length == null ){
            list = values(list);
        }
        return arrMap(list, function (val, key, list) {
            return callback(val, key, list);
        });
    }

    module.exports = map;



},{"../array/map":292,"../function/makeIterator_":299,"../lang/isObject":304,"../object/values":311}],298:[function(require,module,exports){


    /**
     * Returns the first argument provided to it.
     */
    function identity(val){
        return val;
    }

    module.exports = identity;



},{}],299:[function(require,module,exports){
var identity = require('./identity');
var prop = require('./prop');
var deepMatches = require('../object/deepMatches');

    /**
     * Converts argument into a valid iterator.
     * Used internally on most array/object/collection methods that receives a
     * callback/iterator providing a shortcut syntax.
     */
    function makeIterator(src, thisObj){
        if (src == null) {
            return identity;
        }
        switch(typeof src) {
            case 'function':
                // function is the first to improve perf (most common case)
                // also avoid using `Function#call` if not needed, which boosts
                // perf a lot in some cases
                return (typeof thisObj !== 'undefined')? function(val, i, arr){
                    return src.call(thisObj, val, i, arr);
                } : src;
            case 'object':
                return function(val){
                    return deepMatches(val, src);
                };
            case 'string':
            case 'number':
                return prop(src);
        }
    }

    module.exports = makeIterator;



},{"../object/deepMatches":306,"./identity":298,"./prop":300}],300:[function(require,module,exports){


    /**
     * Returns a function that gets a property of the passed object
     */
    function prop(name){
        return function(obj){
            return obj[name];
        };
    }

    module.exports = prop;



},{}],301:[function(require,module,exports){
var mixIn = require('../object/mixIn');

    /**
     * Create Object using prototypal inheritance and setting custom properties.
     * - Mix between Douglas Crockford Prototypal Inheritance <http://javascript.crockford.com/prototypal.html> and the EcmaScript 5 `Object.create()` method.
     * @param {object} parent    Parent Object.
     * @param {object} [props] Object properties.
     * @return {object} Created object.
     */
    function createObject(parent, props){
        function F(){}
        F.prototype = parent;
        return mixIn(new F(), props);

    }
    module.exports = createObject;



},{"../object/mixIn":310}],302:[function(require,module,exports){
var isKind = require('./isKind');
    /**
     */
    var isArray = Array.isArray || function (val) {
        return isKind(val, 'Array');
    };
    module.exports = isArray;


},{"./isKind":303}],303:[function(require,module,exports){
var kindOf = require('./kindOf');
    /**
     * Check if value is from a specific "kind".
     */
    function isKind(val, kind){
        return kindOf(val) === kind;
    }
    module.exports = isKind;


},{"./kindOf":305}],304:[function(require,module,exports){
var isKind = require('./isKind');
    /**
     */
    function isObject(val) {
        return isKind(val, 'Object');
    }
    module.exports = isObject;


},{"./isKind":303}],305:[function(require,module,exports){


    var _rKind = /^\[object (.*)\]$/,
        _toString = Object.prototype.toString,
        UNDEF;

    /**
     * Gets the "kind" of value. (e.g. "String", "Number", etc)
     */
    function kindOf(val) {
        if (val === null) {
            return 'Null';
        } else if (val === UNDEF) {
            return 'Undefined';
        } else {
            return _rKind.exec( _toString.call(val) )[1];
        }
    }
    module.exports = kindOf;


},{}],306:[function(require,module,exports){
var forOwn = require('./forOwn');
var isArray = require('../lang/isArray');

    function containsMatch(array, pattern) {
        var i = -1, length = array.length;
        while (++i < length) {
            if (deepMatches(array[i], pattern)) {
                return true;
            }
        }

        return false;
    }

    function matchArray(target, pattern) {
        var i = -1, patternLength = pattern.length;
        while (++i < patternLength) {
            if (!containsMatch(target, pattern[i])) {
                return false;
            }
        }

        return true;
    }

    function matchObject(target, pattern) {
        var result = true;
        forOwn(pattern, function(val, key) {
            if (!deepMatches(target[key], val)) {
                // Return false to break out of forOwn early
                return (result = false);
            }
        });

        return result;
    }

    /**
     * Recursively check if the objects match.
     */
    function deepMatches(target, pattern){
        if (target && typeof target === 'object') {
            if (isArray(target) && isArray(pattern)) {
                return matchArray(target, pattern);
            } else {
                return matchObject(target, pattern);
            }
        } else {
            return target === pattern;
        }
    }

    module.exports = deepMatches;



},{"../lang/isArray":302,"./forOwn":308}],307:[function(require,module,exports){
var hasOwn = require('./hasOwn');

    var _hasDontEnumBug,
        _dontEnums;

    function checkDontEnum(){
        _dontEnums = [
                'toString',
                'toLocaleString',
                'valueOf',
                'hasOwnProperty',
                'isPrototypeOf',
                'propertyIsEnumerable',
                'constructor'
            ];

        _hasDontEnumBug = true;

        for (var key in {'toString': null}) {
            _hasDontEnumBug = false;
        }
    }

    /**
     * Similar to Array/forEach but works over object properties and fixes Don't
     * Enum bug on IE.
     * based on: http://whattheheadsaid.com/2010/10/a-safer-object-keys-compatibility-implementation
     */
    function forIn(obj, fn, thisObj){
        var key, i = 0;
        // no need to check if argument is a real object that way we can use
        // it for arrays, functions, date, etc.

        //post-pone check till needed
        if (_hasDontEnumBug == null) checkDontEnum();

        for (key in obj) {
            if (exec(fn, obj, key, thisObj) === false) {
                break;
            }
        }


        if (_hasDontEnumBug) {
            var ctor = obj.constructor,
                isProto = !!ctor && obj === ctor.prototype;

            while (key = _dontEnums[i++]) {
                // For constructor, if it is a prototype object the constructor
                // is always non-enumerable unless defined otherwise (and
                // enumerated above).  For non-prototype objects, it will have
                // to be defined on this object, since it cannot be defined on
                // any prototype objects.
                //
                // For other [[DontEnum]] properties, check if the value is
                // different than Object prototype value.
                if (
                    (key !== 'constructor' ||
                        (!isProto && hasOwn(obj, key))) &&
                    obj[key] !== Object.prototype[key]
                ) {
                    if (exec(fn, obj, key, thisObj) === false) {
                        break;
                    }
                }
            }
        }
    }

    function exec(fn, obj, key, thisObj){
        return fn.call(thisObj, obj[key], key, obj);
    }

    module.exports = forIn;



},{"./hasOwn":309}],308:[function(require,module,exports){
var hasOwn = require('./hasOwn');
var forIn = require('./forIn');

    /**
     * Similar to Array/forEach but works over object properties and fixes Don't
     * Enum bug on IE.
     * based on: http://whattheheadsaid.com/2010/10/a-safer-object-keys-compatibility-implementation
     */
    function forOwn(obj, fn, thisObj){
        forIn(obj, function(val, key){
            if (hasOwn(obj, key)) {
                return fn.call(thisObj, obj[key], key, obj);
            }
        });
    }

    module.exports = forOwn;



},{"./forIn":307,"./hasOwn":309}],309:[function(require,module,exports){


    /**
     * Safer Object.hasOwnProperty
     */
     function hasOwn(obj, prop){
         return Object.prototype.hasOwnProperty.call(obj, prop);
     }

     module.exports = hasOwn;



},{}],310:[function(require,module,exports){
var forOwn = require('./forOwn');

    /**
    * Combine properties from all the objects into first one.
    * - This method affects target object in place, if you want to create a new Object pass an empty object as first param.
    * @param {object} target    Target Object
    * @param {...object} objects    Objects to be combined (0...n objects).
    * @return {object} Target Object.
    */
    function mixIn(target, objects){
        var i = 0,
            n = arguments.length,
            obj;
        while(++i < n){
            obj = arguments[i];
            if (obj != null) {
                forOwn(obj, copyProp, target);
            }
        }
        return target;
    }

    function copyProp(val, key){
        this[key] = val;
    }

    module.exports = mixIn;


},{"./forOwn":308}],311:[function(require,module,exports){
var forOwn = require('./forOwn');

    /**
     * Get object values
     */
    function values(obj) {
        var vals = [];
        forOwn(obj, function(val, key){
            vals.push(val);
        });
        return vals;
    }

    module.exports = values;



},{"./forOwn":308}],312:[function(require,module,exports){
/*
prime
 - prototypal inheritance
*/"use strict"

var hasOwn = require("mout/object/hasOwn"),
    mixIn  = require("mout/object/mixIn"),
    create = require("mout/lang/createObject"),
    kindOf = require("mout/lang/kindOf")

var hasDescriptors = true

try {
    Object.defineProperty({}, "~", {})
    Object.getOwnPropertyDescriptor({}, "~")
} catch (e){
    hasDescriptors = false
}

// we only need to be able to implement "toString" and "valueOf" in IE < 9
var hasEnumBug = !({valueOf: 0}).propertyIsEnumerable("valueOf"),
    buggy      = ["toString", "valueOf"]

var verbs = /^constructor|inherits|mixin$/

var implement = function(proto){
    var prototype = this.prototype

    for (var key in proto){
        if (key.match(verbs)) continue
        if (hasDescriptors){
            var descriptor = Object.getOwnPropertyDescriptor(proto, key)
            if (descriptor){
                Object.defineProperty(prototype, key, descriptor)
                continue
            }
        }
        prototype[key] = proto[key]
    }

    if (hasEnumBug) for (var i = 0; (key = buggy[i]); i++){
        var value = proto[key]
        if (value !== Object.prototype[key]) prototype[key] = value
    }

    return this
}

var prime = function(proto){

    if (kindOf(proto) === "Function") proto = {constructor: proto}

    var superprime = proto.inherits

    // if our nice proto object has no own constructor property
    // then we proceed using a ghosting constructor that all it does is
    // call the parent's constructor if it has a superprime, else an empty constructor
    // proto.constructor becomes the effective constructor
    var constructor = (hasOwn(proto, "constructor")) ? proto.constructor : (superprime) ? function(){
        return superprime.apply(this, arguments)
    } : function(){}

    if (superprime){

        mixIn(constructor, superprime)

        var superproto = superprime.prototype
        // inherit from superprime
        var cproto = constructor.prototype = create(superproto)

        // setting constructor.parent to superprime.prototype
        // because it's the shortest possible absolute reference
        constructor.parent = superproto
        cproto.constructor = constructor
    }

    if (!constructor.implement) constructor.implement = implement

    var mixins = proto.mixin
    if (mixins){
        if (kindOf(mixins) !== "Array") mixins = [mixins]
        for (var i = 0; i < mixins.length; i++) constructor.implement(create(mixins[i].prototype))
    }

    // implement proto and return constructor
    return constructor.implement(proto)

}

module.exports = prime

},{"mout/lang/createObject":301,"mout/lang/kindOf":305,"mout/object/hasOwn":309,"mout/object/mixIn":310}],313:[function(require,module,exports){
"use strict";
/*globals Handlebars: true */
var base = require("./handlebars/base");

// Each of these augment the Handlebars object. No need to setup here.
// (This is done to easily share code between commonjs and browse envs)
var SafeString = require("./handlebars/safe-string")["default"];
var Exception = require("./handlebars/exception")["default"];
var Utils = require("./handlebars/utils");
var runtime = require("./handlebars/runtime");

// For compatibility and usage outside of module systems, make the Handlebars object a namespace
var create = function() {
  var hb = new base.HandlebarsEnvironment();

  Utils.extend(hb, base);
  hb.SafeString = SafeString;
  hb.Exception = Exception;
  hb.Utils = Utils;

  hb.VM = runtime;
  hb.template = function(spec) {
    return runtime.template(spec, hb);
  };

  return hb;
};

var Handlebars = create();
Handlebars.create = create;

exports["default"] = Handlebars;
},{"./handlebars/base":314,"./handlebars/exception":315,"./handlebars/runtime":316,"./handlebars/safe-string":317,"./handlebars/utils":318}],314:[function(require,module,exports){
"use strict";
var Utils = require("./utils");
var Exception = require("./exception")["default"];

var VERSION = "1.3.0";
exports.VERSION = VERSION;var COMPILER_REVISION = 4;
exports.COMPILER_REVISION = COMPILER_REVISION;
var REVISION_CHANGES = {
  1: '<= 1.0.rc.2', // 1.0.rc.2 is actually rev2 but doesn't report it
  2: '== 1.0.0-rc.3',
  3: '== 1.0.0-rc.4',
  4: '>= 1.0.0'
};
exports.REVISION_CHANGES = REVISION_CHANGES;
var isArray = Utils.isArray,
    isFunction = Utils.isFunction,
    toString = Utils.toString,
    objectType = '[object Object]';

function HandlebarsEnvironment(helpers, partials) {
  this.helpers = helpers || {};
  this.partials = partials || {};

  registerDefaultHelpers(this);
}

exports.HandlebarsEnvironment = HandlebarsEnvironment;HandlebarsEnvironment.prototype = {
  constructor: HandlebarsEnvironment,

  logger: logger,
  log: log,

  registerHelper: function(name, fn, inverse) {
    if (toString.call(name) === objectType) {
      if (inverse || fn) { throw new Exception('Arg not supported with multiple helpers'); }
      Utils.extend(this.helpers, name);
    } else {
      if (inverse) { fn.not = inverse; }
      this.helpers[name] = fn;
    }
  },

  registerPartial: function(name, str) {
    if (toString.call(name) === objectType) {
      Utils.extend(this.partials,  name);
    } else {
      this.partials[name] = str;
    }
  }
};

function registerDefaultHelpers(instance) {
  instance.registerHelper('helperMissing', function(arg) {
    if(arguments.length === 2) {
      return undefined;
    } else {
      throw new Exception("Missing helper: '" + arg + "'");
    }
  });

  instance.registerHelper('blockHelperMissing', function(context, options) {
    var inverse = options.inverse || function() {}, fn = options.fn;

    if (isFunction(context)) { context = context.call(this); }

    if(context === true) {
      return fn(this);
    } else if(context === false || context == null) {
      return inverse(this);
    } else if (isArray(context)) {
      if(context.length > 0) {
        return instance.helpers.each(context, options);
      } else {
        return inverse(this);
      }
    } else {
      return fn(context);
    }
  });

  instance.registerHelper('each', function(context, options) {
    var fn = options.fn, inverse = options.inverse;
    var i = 0, ret = "", data;

    if (isFunction(context)) { context = context.call(this); }

    if (options.data) {
      data = createFrame(options.data);
    }

    if(context && typeof context === 'object') {
      if (isArray(context)) {
        for(var j = context.length; i<j; i++) {
          if (data) {
            data.index = i;
            data.first = (i === 0);
            data.last  = (i === (context.length-1));
          }
          ret = ret + fn(context[i], { data: data });
        }
      } else {
        for(var key in context) {
          if(context.hasOwnProperty(key)) {
            if(data) { 
              data.key = key; 
              data.index = i;
              data.first = (i === 0);
            }
            ret = ret + fn(context[key], {data: data});
            i++;
          }
        }
      }
    }

    if(i === 0){
      ret = inverse(this);
    }

    return ret;
  });

  instance.registerHelper('if', function(conditional, options) {
    if (isFunction(conditional)) { conditional = conditional.call(this); }

    // Default behavior is to render the positive path if the value is truthy and not empty.
    // The `includeZero` option may be set to treat the condtional as purely not empty based on the
    // behavior of isEmpty. Effectively this determines if 0 is handled by the positive path or negative.
    if ((!options.hash.includeZero && !conditional) || Utils.isEmpty(conditional)) {
      return options.inverse(this);
    } else {
      return options.fn(this);
    }
  });

  instance.registerHelper('unless', function(conditional, options) {
    return instance.helpers['if'].call(this, conditional, {fn: options.inverse, inverse: options.fn, hash: options.hash});
  });

  instance.registerHelper('with', function(context, options) {
    if (isFunction(context)) { context = context.call(this); }

    if (!Utils.isEmpty(context)) return options.fn(context);
  });

  instance.registerHelper('log', function(context, options) {
    var level = options.data && options.data.level != null ? parseInt(options.data.level, 10) : 1;
    instance.log(level, context);
  });
}

var logger = {
  methodMap: { 0: 'debug', 1: 'info', 2: 'warn', 3: 'error' },

  // State enum
  DEBUG: 0,
  INFO: 1,
  WARN: 2,
  ERROR: 3,
  level: 3,

  // can be overridden in the host environment
  log: function(level, obj) {
    if (logger.level <= level) {
      var method = logger.methodMap[level];
      if (typeof console !== 'undefined' && console[method]) {
        console[method].call(console, obj);
      }
    }
  }
};
exports.logger = logger;
function log(level, obj) { logger.log(level, obj); }

exports.log = log;var createFrame = function(object) {
  var obj = {};
  Utils.extend(obj, object);
  return obj;
};
exports.createFrame = createFrame;
},{"./exception":315,"./utils":318}],315:[function(require,module,exports){
"use strict";

var errorProps = ['description', 'fileName', 'lineNumber', 'message', 'name', 'number', 'stack'];

function Exception(message, node) {
  var line;
  if (node && node.firstLine) {
    line = node.firstLine;

    message += ' - ' + line + ':' + node.firstColumn;
  }

  var tmp = Error.prototype.constructor.call(this, message);

  // Unfortunately errors are not enumerable in Chrome (at least), so `for prop in tmp` doesn't work.
  for (var idx = 0; idx < errorProps.length; idx++) {
    this[errorProps[idx]] = tmp[errorProps[idx]];
  }

  if (line) {
    this.lineNumber = line;
    this.column = node.firstColumn;
  }
}

Exception.prototype = new Error();

exports["default"] = Exception;
},{}],316:[function(require,module,exports){
"use strict";
var Utils = require("./utils");
var Exception = require("./exception")["default"];
var COMPILER_REVISION = require("./base").COMPILER_REVISION;
var REVISION_CHANGES = require("./base").REVISION_CHANGES;

function checkRevision(compilerInfo) {
  var compilerRevision = compilerInfo && compilerInfo[0] || 1,
      currentRevision = COMPILER_REVISION;

  if (compilerRevision !== currentRevision) {
    if (compilerRevision < currentRevision) {
      var runtimeVersions = REVISION_CHANGES[currentRevision],
          compilerVersions = REVISION_CHANGES[compilerRevision];
      throw new Exception("Template was precompiled with an older version of Handlebars than the current runtime. "+
            "Please update your precompiler to a newer version ("+runtimeVersions+") or downgrade your runtime to an older version ("+compilerVersions+").");
    } else {
      // Use the embedded version info since the runtime doesn't know about this revision yet
      throw new Exception("Template was precompiled with a newer version of Handlebars than the current runtime. "+
            "Please update your runtime to a newer version ("+compilerInfo[1]+").");
    }
  }
}

exports.checkRevision = checkRevision;// TODO: Remove this line and break up compilePartial

function template(templateSpec, env) {
  if (!env) {
    throw new Exception("No environment passed to template");
  }

  // Note: Using env.VM references rather than local var references throughout this section to allow
  // for external users to override these as psuedo-supported APIs.
  var invokePartialWrapper = function(partial, name, context, helpers, partials, data) {
    var result = env.VM.invokePartial.apply(this, arguments);
    if (result != null) { return result; }

    if (env.compile) {
      var options = { helpers: helpers, partials: partials, data: data };
      partials[name] = env.compile(partial, { data: data !== undefined }, env);
      return partials[name](context, options);
    } else {
      throw new Exception("The partial " + name + " could not be compiled when running in runtime-only mode");
    }
  };

  // Just add water
  var container = {
    escapeExpression: Utils.escapeExpression,
    invokePartial: invokePartialWrapper,
    programs: [],
    program: function(i, fn, data) {
      var programWrapper = this.programs[i];
      if(data) {
        programWrapper = program(i, fn, data);
      } else if (!programWrapper) {
        programWrapper = this.programs[i] = program(i, fn);
      }
      return programWrapper;
    },
    merge: function(param, common) {
      var ret = param || common;

      if (param && common && (param !== common)) {
        ret = {};
        Utils.extend(ret, common);
        Utils.extend(ret, param);
      }
      return ret;
    },
    programWithDepth: env.VM.programWithDepth,
    noop: env.VM.noop,
    compilerInfo: null
  };

  return function(context, options) {
    options = options || {};
    var namespace = options.partial ? options : env,
        helpers,
        partials;

    if (!options.partial) {
      helpers = options.helpers;
      partials = options.partials;
    }
    var result = templateSpec.call(
          container,
          namespace, context,
          helpers,
          partials,
          options.data);

    if (!options.partial) {
      env.VM.checkRevision(container.compilerInfo);
    }

    return result;
  };
}

exports.template = template;function programWithDepth(i, fn, data /*, $depth */) {
  var args = Array.prototype.slice.call(arguments, 3);

  var prog = function(context, options) {
    options = options || {};

    return fn.apply(this, [context, options.data || data].concat(args));
  };
  prog.program = i;
  prog.depth = args.length;
  return prog;
}

exports.programWithDepth = programWithDepth;function program(i, fn, data) {
  var prog = function(context, options) {
    options = options || {};

    return fn(context, options.data || data);
  };
  prog.program = i;
  prog.depth = 0;
  return prog;
}

exports.program = program;function invokePartial(partial, name, context, helpers, partials, data) {
  var options = { partial: true, helpers: helpers, partials: partials, data: data };

  if(partial === undefined) {
    throw new Exception("The partial " + name + " could not be found");
  } else if(partial instanceof Function) {
    return partial(context, options);
  }
}

exports.invokePartial = invokePartial;function noop() { return ""; }

exports.noop = noop;
},{"./base":314,"./exception":315,"./utils":318}],317:[function(require,module,exports){
"use strict";
// Build out our basic SafeString type
function SafeString(string) {
  this.string = string;
}

SafeString.prototype.toString = function() {
  return "" + this.string;
};

exports["default"] = SafeString;
},{}],318:[function(require,module,exports){
"use strict";
/*jshint -W004 */
var SafeString = require("./safe-string")["default"];

var escape = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#x27;",
  "`": "&#x60;"
};

var badChars = /[&<>"'`]/g;
var possible = /[&<>"'`]/;

function escapeChar(chr) {
  return escape[chr] || "&amp;";
}

function extend(obj, value) {
  for(var key in value) {
    if(Object.prototype.hasOwnProperty.call(value, key)) {
      obj[key] = value[key];
    }
  }
}

exports.extend = extend;var toString = Object.prototype.toString;
exports.toString = toString;
// Sourced from lodash
// https://github.com/bestiejs/lodash/blob/master/LICENSE.txt
var isFunction = function(value) {
  return typeof value === 'function';
};
// fallback for older versions of Chrome and Safari
if (isFunction(/x/)) {
  isFunction = function(value) {
    return typeof value === 'function' && toString.call(value) === '[object Function]';
  };
}
var isFunction;
exports.isFunction = isFunction;
var isArray = Array.isArray || function(value) {
  return (value && typeof value === 'object') ? toString.call(value) === '[object Array]' : false;
};
exports.isArray = isArray;

function escapeExpression(string) {
  // don't escape SafeStrings, since they're already safe
  if (string instanceof SafeString) {
    return string.toString();
  } else if (!string && string !== 0) {
    return "";
  }

  // Force a string conversion as this will be done by the append regardless and
  // the regex test will do this transparently behind the scenes, causing issues if
  // an object's to string has escaped characters in it.
  string = "" + string;

  if(!possible.test(string)) { return string; }
  return string.replace(badChars, escapeChar);
}

exports.escapeExpression = escapeExpression;function isEmpty(value) {
  if (!value && value !== 0) {
    return true;
  } else if (isArray(value) && value.length === 0) {
    return true;
  } else {
    return false;
  }
}

exports.isEmpty = isEmpty;
},{"./safe-string":317}],319:[function(require,module,exports){
// Create a simple path alias to allow browserify to resolve
// the runtime on a supported path.
module.exports = require('./dist/cjs/handlebars.runtime');

},{"./dist/cjs/handlebars.runtime":313}],320:[function(require,module,exports){
module.exports = require("handlebars/runtime")["default"];

},{"handlebars/runtime":319}],321:[function(require,module,exports){

/**
 port of http://www.bbc.co.uk/glow/docs/1.7/api/glow.lang.shtml #interpolate
  Modified to be stand-alone and offer support for delimters of random length
  @description Replaces placeholders in a string with data from an object

  @param {String} template The string containing {placeholders}
  @param {Object} data Object containing the data to be merged in to the template
    The object can contain nested data objects and arrays, with nested object properties and array elements are accessed using dot notation. eg foo.bar or foo.0.
    The data labels in the object cannot contain characters used in the template delimiters, so if the data must be allowed to contain the default { and } delimiters, the delimters must be changed using the option below.
  @param {Object} opts Options object
    @param {String} [opts.delimiter="{}"] Alternative label delimiter(s) for the template. Needs to be symmetric, i.e. '{{}}', '<%%>'

  @returns {String}
 */

function interpolate (template, data, opts) {
  var regex,
      lDel,
      rDel,
      delLen,
      lDelLen,
      delimiter,
      // For escaping strings to go in regex
      regexEscape = /([$\^\\\/()|?+*\[\]{}.\-])/g;

  opts = opts || {};

  delimiter = opts.delimiter || '{}';
  delLen = delimiter.length;
  lDelLen = Math.ceil(delLen / 2);
  // escape delimiters for regex
  lDel = delimiter.substr(0, lDelLen).replace(regexEscape, "\\$1");
  rDel = delimiter.substr(lDelLen, delLen).replace(regexEscape, "\\$1") || lDel;

  // construct the new regex
  regex = new RegExp(lDel + "[^" + lDel + rDel + "]+" + rDel, "g");

  return template.replace(regex, function (placeholder) {
    var key = placeholder.slice(lDelLen, -lDelLen),
        keyParts = key.split("."),
        val,
        i = 0,
        len = keyParts.length;

    if (key in data) {
      // need to be backwards compatible with "flattened" data.
      val = data[key];
    }
    else {
      // look up the chain
      val = data;
      for (; i < len; i++) {
        if (keyParts[i] in val) {
          val = val[ keyParts[i] ];
        } else {
          return placeholder;
        }
      }
    }
    return val;
  });
}

module.exports = interpolate;

},{}],322:[function(require,module,exports){
var indexOf = require('./indexOf');

    /**
     * Combines an array with all the items of another.
     * Does not allow duplicates and is case and type sensitive.
     */
    function combine(arr1, arr2) {
        if (arr2 == null) {
            return arr1;
        }

        var i = -1, len = arr2.length;
        while (++i < len) {
            if (indexOf(arr1, arr2[i]) === -1) {
                arr1.push(arr2[i]);
            }
        }

        return arr1;
    }
    module.exports = combine;


},{"./indexOf":331}],323:[function(require,module,exports){
var indexOf = require('./indexOf');

    /**
     * If array contains values.
     */
    function contains(arr, val) {
        return indexOf(arr, val) !== -1;
    }
    module.exports = contains;


},{"./indexOf":331}],324:[function(require,module,exports){
var unique = require('./unique');
var filter = require('./filter');
var some = require('./some');
var contains = require('./contains');
var slice = require('./slice');


    /**
     * Return a new Array with elements that aren't present in the other Arrays.
     */
    function difference(arr) {
        var arrs = slice(arguments, 1),
            result = filter(unique(arr), function(needle){
                return !some(arrs, function(haystack){
                    return contains(haystack, needle);
                });
            });
        return result;
    }

    module.exports = difference;



},{"./contains":323,"./filter":327,"./slice":335,"./some":336,"./unique":337}],325:[function(require,module,exports){
var is = require('../lang/is');
var isArray = require('../lang/isArray');
var every = require('./every');

    /**
     * Compares if both arrays have the same elements
     */
    function equals(a, b, callback){
        callback = callback || is;

        if (!isArray(a) || !isArray(b)) {
            return callback(a, b);
        }

        if (a.length !== b.length) {
            return false;
        }

        return every(a, makeCompare(callback), b);
    }

    function makeCompare(callback) {
        return function(value, i) {
            return i in this && callback(value, this[i]);
        };
    }

    module.exports = equals;



},{"../lang/is":345,"../lang/isArray":346,"./every":326}],326:[function(require,module,exports){
var makeIterator = require('../function/makeIterator_');

    /**
     * Array every
     */
    function every(arr, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        var result = true;
        if (arr == null) {
            return result;
        }

        var i = -1, len = arr.length;
        while (++i < len) {
            // we iterate over sparse items since there is no way to make it
            // work properly on IE 7-8. see #64
            if (!callback(arr[i], i, arr) ) {
                result = false;
                break;
            }
        }

        return result;
    }

    module.exports = every;


},{"../function/makeIterator_":339}],327:[function(require,module,exports){
var makeIterator = require('../function/makeIterator_');

    /**
     * Array filter
     */
    function filter(arr, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        var results = [];
        if (arr == null) {
            return results;
        }

        var i = -1, len = arr.length, value;
        while (++i < len) {
            value = arr[i];
            if (callback(value, i, arr)) {
                results.push(value);
            }
        }

        return results;
    }

    module.exports = filter;



},{"../function/makeIterator_":339}],328:[function(require,module,exports){
var findIndex = require('./findIndex');

    /**
     * Returns first item that matches criteria
     */
    function find(arr, iterator, thisObj){
        var idx = findIndex(arr, iterator, thisObj);
        return idx >= 0? arr[idx] : void(0);
    }

    module.exports = find;



},{"./findIndex":329}],329:[function(require,module,exports){
var makeIterator = require('../function/makeIterator_');

    /**
     * Returns the index of the first item that matches criteria
     */
    function findIndex(arr, iterator, thisObj){
        iterator = makeIterator(iterator, thisObj);
        if (arr == null) {
            return -1;
        }

        var i = -1, len = arr.length;
        while (++i < len) {
            if (iterator(arr[i], i, arr)) {
                return i;
            }
        }

        return -1;
    }

    module.exports = findIndex;


},{"../function/makeIterator_":339}],330:[function(require,module,exports){
arguments[4][291][0].apply(exports,arguments)
},{"dup":291}],331:[function(require,module,exports){


    /**
     * Array.indexOf
     */
    function indexOf(arr, item, fromIndex) {
        fromIndex = fromIndex || 0;
        if (arr == null) {
            return -1;
        }

        var len = arr.length,
            i = fromIndex < 0 ? len + fromIndex : fromIndex;
        while (i < len) {
            // we iterate over sparse items since there is no way to make it
            // work properly on IE 7-8. see #64
            if (arr[i] === item) {
                return i;
            }

            i++;
        }

        return -1;
    }

    module.exports = indexOf;


},{}],332:[function(require,module,exports){
var unique = require('./unique');
var filter = require('./filter');
var every = require('./every');
var contains = require('./contains');
var slice = require('./slice');


    /**
     * Return a new Array with elements common to all Arrays.
     * - based on underscore.js implementation
     */
    function intersection(arr) {
        var arrs = slice(arguments, 1),
            result = filter(unique(arr), function(needle){
                return every(arrs, function(haystack){
                    return contains(haystack, needle);
                });
            });
        return result;
    }

    module.exports = intersection;



},{"./contains":323,"./every":326,"./filter":327,"./slice":335,"./unique":337}],333:[function(require,module,exports){
arguments[4][292][0].apply(exports,arguments)
},{"../function/makeIterator_":339,"dup":292}],334:[function(require,module,exports){
var indexOf = require('./indexOf');

    /**
     * Remove a single item from the array.
     * (it won't remove duplicates, just a single item)
     */
    function remove(arr, item){
        var idx = indexOf(arr, item);
        if (idx !== -1) arr.splice(idx, 1);
    }

    module.exports = remove;


},{"./indexOf":331}],335:[function(require,module,exports){
arguments[4][294][0].apply(exports,arguments)
},{"dup":294}],336:[function(require,module,exports){
var makeIterator = require('../function/makeIterator_');

    /**
     * Array some
     */
    function some(arr, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        var result = false;
        if (arr == null) {
            return result;
        }

        var i = -1, len = arr.length;
        while (++i < len) {
            // we iterate over sparse items since there is no way to make it
            // work properly on IE 7-8. see #64
            if ( callback(arr[i], i, arr) ) {
                result = true;
                break;
            }
        }

        return result;
    }

    module.exports = some;


},{"../function/makeIterator_":339}],337:[function(require,module,exports){
var filter = require('./filter');

    /**
     * @return {array} Array of unique items
     */
    function unique(arr, compare){
        compare = compare || isEqual;
        return filter(arr, function(item, i, arr){
            var n = arr.length;
            while (++i < n) {
                if ( compare(item, arr[i]) ) {
                    return false;
                }
            }
            return true;
        });
    }

    function isEqual(a, b){
        return a === b;
    }

    module.exports = unique;



},{"./filter":327}],338:[function(require,module,exports){
arguments[4][298][0].apply(exports,arguments)
},{"dup":298}],339:[function(require,module,exports){
arguments[4][299][0].apply(exports,arguments)
},{"../object/deepMatches":355,"./identity":338,"./prop":340,"dup":299}],340:[function(require,module,exports){
arguments[4][300][0].apply(exports,arguments)
},{"dup":300}],341:[function(require,module,exports){
var kindOf = require('./kindOf');
var isPlainObject = require('./isPlainObject');
var mixIn = require('../object/mixIn');

    /**
     * Clone native types.
     */
    function clone(val){
        switch (kindOf(val)) {
            case 'Object':
                return cloneObject(val);
            case 'Array':
                return cloneArray(val);
            case 'RegExp':
                return cloneRegExp(val);
            case 'Date':
                return cloneDate(val);
            default:
                return val;
        }
    }

    function cloneObject(source) {
        if (isPlainObject(source)) {
            return mixIn({}, source);
        } else {
            return source;
        }
    }

    function cloneRegExp(r) {
        var flags = '';
        flags += r.multiline ? 'm' : '';
        flags += r.global ? 'g' : '';
        flags += r.ignoreCase ? 'i' : '';
        return new RegExp(r.source, flags);
    }

    function cloneDate(date) {
        return new Date(+date);
    }

    function cloneArray(arr) {
        return arr.slice();
    }

    module.exports = clone;



},{"../object/mixIn":364,"./isPlainObject":350,"./kindOf":352}],342:[function(require,module,exports){
arguments[4][301][0].apply(exports,arguments)
},{"../object/mixIn":364,"dup":301}],343:[function(require,module,exports){
var clone = require('./clone');
var forOwn = require('../object/forOwn');
var kindOf = require('./kindOf');
var isPlainObject = require('./isPlainObject');

    /**
     * Recursively clone native types.
     */
    function deepClone(val, instanceClone) {
        switch ( kindOf(val) ) {
            case 'Object':
                return cloneObject(val, instanceClone);
            case 'Array':
                return cloneArray(val, instanceClone);
            default:
                return clone(val);
        }
    }

    function cloneObject(source, instanceClone) {
        if (isPlainObject(source)) {
            var out = {};
            forOwn(source, function(val, key) {
                this[key] = deepClone(val, instanceClone);
            }, out);
            return out;
        } else if (instanceClone) {
            return instanceClone(source);
        } else {
            return source;
        }
    }

    function cloneArray(arr, instanceClone) {
        var out = [],
            i = -1,
            n = arr.length,
            val;
        while (++i < n) {
            out[i] = deepClone(arr[i], instanceClone);
        }
        return out;
    }

    module.exports = deepClone;




},{"../object/forOwn":360,"./clone":341,"./isPlainObject":350,"./kindOf":352}],344:[function(require,module,exports){
var is = require('./is');
var isObject = require('./isObject');
var isArray = require('./isArray');
var objEquals = require('../object/equals');
var arrEquals = require('../array/equals');

    /**
     * Recursively checks for same properties and values.
     */
    function deepEquals(a, b, callback){
        callback = callback || is;

        var bothObjects = isObject(a) && isObject(b);
        var bothArrays = !bothObjects && isArray(a) && isArray(b);

        if (!bothObjects && !bothArrays) {
            return callback(a, b);
        }

        function compare(a, b){
            return deepEquals(a, b, callback);
        }

        var method = bothObjects ? objEquals : arrEquals;
        return method(a, b, compare);
    }

    module.exports = deepEquals;



},{"../array/equals":325,"../object/equals":357,"./is":345,"./isArray":346,"./isObject":349}],345:[function(require,module,exports){


    /**
     * Check if both arguments are egal.
     */
    function is(x, y){
        // implementation borrowed from harmony:egal spec
        if (x === y) {
          // 0 === -0, but they are not identical
          return x !== 0 || 1 / x === 1 / y;
        }

        // NaN !== NaN, but they are identical.
        // NaNs are the only non-reflexive value, i.e., if x !== x,
        // then x is a NaN.
        // isNaN is broken: it converts its argument to number, so
        // isNaN("foo") => true
        return x !== x && y !== y;
    }

    module.exports = is;



},{}],346:[function(require,module,exports){
arguments[4][302][0].apply(exports,arguments)
},{"./isKind":347,"dup":302}],347:[function(require,module,exports){
arguments[4][303][0].apply(exports,arguments)
},{"./kindOf":352,"dup":303}],348:[function(require,module,exports){
var isKind = require('./isKind');
    /**
     */
    function isNumber(val) {
        return isKind(val, 'Number');
    }
    module.exports = isNumber;


},{"./isKind":347}],349:[function(require,module,exports){
arguments[4][304][0].apply(exports,arguments)
},{"./isKind":347,"dup":304}],350:[function(require,module,exports){


    /**
     * Checks if the value is created by the `Object` constructor.
     */
    function isPlainObject(value) {
        return (!!value && typeof value === 'object' &&
            value.constructor === Object);
    }

    module.exports = isPlainObject;



},{}],351:[function(require,module,exports){
var isKind = require('./isKind');
    /**
     */
    function isRegExp(val) {
        return isKind(val, 'RegExp');
    }
    module.exports = isRegExp;


},{"./isKind":347}],352:[function(require,module,exports){
arguments[4][305][0].apply(exports,arguments)
},{"dup":305}],353:[function(require,module,exports){


    /**
     * Typecast a value to a String, using an empty string value for null or
     * undefined.
     */
    function toString(val){
        return val == null ? '' : val.toString();
    }

    module.exports = toString;



},{}],354:[function(require,module,exports){
var forOwn = require('./forOwn');
var isPlainObject = require('../lang/isPlainObject');

    /**
     * Deeply copy missing properties in the target from the defaults.
     */
    function deepFillIn(target, defaults){
        var i = 0,
            n = arguments.length,
            obj;

        while(++i < n) {
            obj = arguments[i];
            if (obj) {
                // jshint loopfunc: true
                forOwn(obj, function(newValue, key) {
                    var curValue = target[key];
                    if (curValue == null) {
                        target[key] = newValue;
                    } else if (isPlainObject(curValue) &&
                               isPlainObject(newValue)) {
                        deepFillIn(curValue, newValue);
                    }
                });
            }
        }

        return target;
    }

    module.exports = deepFillIn;



},{"../lang/isPlainObject":350,"./forOwn":360}],355:[function(require,module,exports){
arguments[4][306][0].apply(exports,arguments)
},{"../lang/isArray":346,"./forOwn":360,"dup":306}],356:[function(require,module,exports){
var forOwn = require('./forOwn');
var isPlainObject = require('../lang/isPlainObject');

    /**
     * Mixes objects into the target object, recursively mixing existing child
     * objects.
     */
    function deepMixIn(target, objects) {
        var i = 0,
            n = arguments.length,
            obj;

        while(++i < n){
            obj = arguments[i];
            if (obj) {
                forOwn(obj, copyProp, target);
            }
        }

        return target;
    }

    function copyProp(val, key) {
        var existing = this[key];
        if (isPlainObject(val) && isPlainObject(existing)) {
            deepMixIn(existing, val);
        } else {
            this[key] = val;
        }
    }

    module.exports = deepMixIn;



},{"../lang/isPlainObject":350,"./forOwn":360}],357:[function(require,module,exports){
var hasOwn = require('./hasOwn');
var every = require('./every');
var isObject = require('../lang/isObject');
var is = require('../lang/is');

    // Makes a function to compare the object values from the specified compare
    // operation callback.
    function makeCompare(callback) {
        return function(value, key) {
            return hasOwn(this, key) && callback(value, this[key]);
        };
    }

    function checkProperties(value, key) {
        return hasOwn(this, key);
    }

    /**
     * Checks if two objects have the same keys and values.
     */
    function equals(a, b, callback) {
        callback = callback || is;

        if (!isObject(a) || !isObject(b)) {
            return callback(a, b);
        }

        return (every(a, makeCompare(callback), b) &&
                every(b, checkProperties, a));
    }

    module.exports = equals;


},{"../lang/is":345,"../lang/isObject":349,"./every":358,"./hasOwn":361}],358:[function(require,module,exports){
var forOwn = require('./forOwn');
var makeIterator = require('../function/makeIterator_');

    /**
     * Object every
     */
    function every(obj, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        var result = true;
        forOwn(obj, function(val, key) {
            // we consider any falsy values as "false" on purpose so shorthand
            // syntax can be used to check property existence
            if (!callback(val, key, obj)) {
                result = false;
                return false; // break
            }
        });
        return result;
    }

    module.exports = every;



},{"../function/makeIterator_":339,"./forOwn":360}],359:[function(require,module,exports){
arguments[4][307][0].apply(exports,arguments)
},{"./hasOwn":361,"dup":307}],360:[function(require,module,exports){
arguments[4][308][0].apply(exports,arguments)
},{"./forIn":359,"./hasOwn":361,"dup":308}],361:[function(require,module,exports){
arguments[4][309][0].apply(exports,arguments)
},{"dup":309}],362:[function(require,module,exports){
var forOwn = require('./forOwn');

    /**
     * Get object keys
     */
     var keys = Object.keys || function (obj) {
            var keys = [];
            forOwn(obj, function(val, key){
                keys.push(key);
            });
            return keys;
        };

    module.exports = keys;



},{"./forOwn":360}],363:[function(require,module,exports){
var hasOwn = require('./hasOwn');
var deepClone = require('../lang/deepClone');
var isObject = require('../lang/isObject');

    /**
     * Deep merge objects.
     */
    function merge() {
        var i = 1,
            key, val, obj, target;

        // make sure we don't modify source element and it's properties
        // objects are passed by reference
        target = deepClone( arguments[0] );

        while (obj = arguments[i++]) {
            for (key in obj) {
                if ( ! hasOwn(obj, key) ) {
                    continue;
                }

                val = obj[key];

                if ( isObject(val) && isObject(target[key]) ){
                    // inception, deep merge objects
                    target[key] = merge(target[key], val);
                } else {
                    // make sure arrays, regexp, date, objects are cloned
                    target[key] = deepClone(val);
                }

            }
        }

        return target;
    }

    module.exports = merge;



},{"../lang/deepClone":343,"../lang/isObject":349,"./hasOwn":361}],364:[function(require,module,exports){
arguments[4][310][0].apply(exports,arguments)
},{"./forOwn":360,"dup":310}],365:[function(require,module,exports){
var slice = require('../array/slice');

    /**
     * Return a copy of the object, filtered to only have values for the whitelisted keys.
     */
    function pick(obj, var_keys){
        var keys = typeof arguments[1] !== 'string'? arguments[1] : slice(arguments, 1),
            out = {},
            i = 0, key;
        while (key = keys[i++]) {
            out[key] = obj[key];
        }
        return out;
    }

    module.exports = pick;



},{"../array/slice":335}],366:[function(require,module,exports){

    /**
     * Contains all Unicode white-spaces. Taken from
     * http://en.wikipedia.org/wiki/Whitespace_character.
     */
    module.exports = [
        ' ', '\n', '\r', '\t', '\f', '\v', '\u00A0', '\u1680', '\u180E',
        '\u2000', '\u2001', '\u2002', '\u2003', '\u2004', '\u2005', '\u2006',
        '\u2007', '\u2008', '\u2009', '\u200A', '\u2028', '\u2029', '\u202F',
        '\u205F', '\u3000'
    ];


},{}],367:[function(require,module,exports){
var toString = require('../lang/toString');

    /**
     * Escape RegExp string chars.
     */
    function escapeRegExp(str) {
        return toString(str).replace(/\W/g,'\\$&');
    }

    module.exports = escapeRegExp;



},{"../lang/toString":353}],368:[function(require,module,exports){
var toString = require('../lang/toString');
var WHITE_SPACES = require('./WHITE_SPACES');
    /**
     * Remove chars from beginning of string.
     */
    function ltrim(str, chars) {
        str = toString(str);
        chars = chars || WHITE_SPACES;

        var start = 0,
            len = str.length,
            charLen = chars.length,
            found = true,
            i, c;

        while (found && start < len) {
            found = false;
            i = -1;
            c = str.charAt(start);

            while (++i < charLen) {
                if (c === chars[i]) {
                    found = true;
                    start++;
                    break;
                }
            }
        }

        return (start >= len) ? '' : str.substr(start, len);
    }

    module.exports = ltrim;


},{"../lang/toString":353,"./WHITE_SPACES":366}],369:[function(require,module,exports){
var toString = require('../lang/toString');
var WHITE_SPACES = require('./WHITE_SPACES');
    /**
     * Remove chars from end of string.
     */
    function rtrim(str, chars) {
        str = toString(str);
        chars = chars || WHITE_SPACES;

        var end = str.length - 1,
            charLen = chars.length,
            found = true,
            i, c;

        while (found && end >= 0) {
            found = false;
            i = -1;
            c = str.charAt(end);

            while (++i < charLen) {
                if (c === chars[i]) {
                    found = true;
                    end--;
                    break;
                }
            }
        }

        return (end >= 0) ? str.substring(0, end + 1) : '';
    }

    module.exports = rtrim;


},{"../lang/toString":353,"./WHITE_SPACES":366}],370:[function(require,module,exports){
var toString = require('../lang/toString');
var WHITE_SPACES = require('./WHITE_SPACES');
var ltrim = require('./ltrim');
var rtrim = require('./rtrim');
    /**
     * Remove white-spaces from beginning and end of string.
     */
    function trim(str, chars) {
        str = toString(str);
        chars = chars || WHITE_SPACES;
        return ltrim(rtrim(str, chars), chars);
    }

    module.exports = trim;


},{"../lang/toString":353,"./WHITE_SPACES":366,"./ltrim":368,"./rtrim":369}],371:[function(require,module,exports){


    /**
     * Get current time in miliseconds
     */
    function now(){
        // yes, we defer the work to another function to allow mocking it
        // during the tests
        return now.get();
    }

    now.get = (typeof Date.now === 'function')? Date.now : function(){
        return +(new Date());
    };

    module.exports = now;



},{}],372:[function(require,module,exports){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} options
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options){
  options = options || {};
  if ('string' == typeof val) return parse(val);
  return options.long
    ? long(val)
    : short(val);
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = '' + str;
  if (str.length > 10000) return;
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
  if (!match) return;
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function short(ms) {
  if (ms >= d) return Math.round(ms / d) + 'd';
  if (ms >= h) return Math.round(ms / h) + 'h';
  if (ms >= m) return Math.round(ms / m) + 'm';
  if (ms >= s) return Math.round(ms / s) + 's';
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function long(ms) {
  return plural(ms, d, 'day')
    || plural(ms, h, 'hour')
    || plural(ms, m, 'minute')
    || plural(ms, s, 'second')
    || ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) return;
  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
  return Math.ceil(ms / n) + ' ' + name + 's';
}

},{}],373:[function(require,module,exports){
(function (process,global){
/*
defer
*/"use strict"

var kindOf  = require("mout/lang/kindOf"),
    now     = require("mout/time/now"),
    forEach = require("mout/array/forEach"),
    indexOf = require("mout/array/indexOf")

var callbacks = {
    timeout: {},
    frame: [],
    immediate: []
}

var push = function(collection, callback, context, defer){

    var iterator = function(){
        iterate(collection)
    }

    if (!collection.length) defer(iterator)

    var entry = {
        callback: callback,
        context: context
    }

    collection.push(entry)

    return function(){
        var io = indexOf(collection, entry)
        if (io > -1) collection.splice(io, 1)
    }
}

var iterate = function(collection){
    var time = now()

    forEach(collection.splice(0), function(entry) {
        entry.callback.call(entry.context, time)
    })
}

var defer = function(callback, argument, context){
    return (kindOf(argument) === "Number") ? defer.timeout(callback, argument, context) : defer.immediate(callback, argument)
}

if (global.process && process.nextTick){

    defer.immediate = function(callback, context){
        return push(callbacks.immediate, callback, context, process.nextTick)
    }

} else if (global.setImmediate){

    defer.immediate = function(callback, context){
        return push(callbacks.immediate, callback, context, setImmediate)
    }

} else if (global.postMessage && global.addEventListener){

    addEventListener("message", function(event){
        if (event.source === global && event.data === "@deferred"){
            event.stopPropagation()
            iterate(callbacks.immediate)
        }
    }, true)

    defer.immediate = function(callback, context){
        return push(callbacks.immediate, callback, context, function(){
            postMessage("@deferred", "*")
        })
    }

} else {

    defer.immediate = function(callback, context){
        return push(callbacks.immediate, callback, context, function(iterator){
            setTimeout(iterator, 0)
        })
    }

}

var requestAnimationFrame = global.requestAnimationFrame ||
    global.webkitRequestAnimationFrame ||
    global.mozRequestAnimationFrame ||
    global.oRequestAnimationFrame ||
    global.msRequestAnimationFrame ||
    function(callback) {
        setTimeout(callback, 1e3 / 60)
    }

defer.frame = function(callback, context){
    return push(callbacks.frame, callback, context, requestAnimationFrame)
}

var clear

defer.timeout = function(callback, ms, context){
    var ct = callbacks.timeout

    if (!clear) clear = defer.immediate(function(){
        clear = null
        callbacks.timeout = {}
    })

    return push(ct[ms] || (ct[ms] = []), callback, context, function(iterator){
        setTimeout(iterator, ms)
    })
}

module.exports = defer

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"_process":377,"mout/array/forEach":330,"mout/array/indexOf":331,"mout/lang/kindOf":352,"mout/time/now":371}],374:[function(require,module,exports){
/*
Emitter
*/"use strict"

var indexOf = require("mout/array/indexOf"),
    forEach = require("mout/array/forEach")

var prime = require("./index"),
    defer = require("./defer")

var slice = Array.prototype.slice;

var Emitter = prime({

    constructor: function(stoppable){
        this._stoppable = stoppable
    },

    on: function(event, fn){
        var listeners = this._listeners || (this._listeners = {}),
            events = listeners[event] || (listeners[event] = [])

        if (indexOf(events, fn) === -1) events.push(fn)

        return this
    },

    off: function(event, fn){
        var listeners = this._listeners, events
        if (listeners && (events = listeners[event])){

            var io = indexOf(events, fn)
            if (io > -1) events.splice(io, 1)
            if (!events.length) delete listeners[event];
            for (var l in listeners) return this
            delete this._listeners
        }
        return this
    },

    emit: function(event){
        var self = this,
            args = slice.call(arguments, 1)

        var emit = function(){
            var listeners = self._listeners, events
            if (listeners && (events = listeners[event])){
                forEach(events.slice(0), function(event){
                    var result = event.apply(self, args)
                    if (self._stoppable) return result
                })
            }
        }

        if (args[args.length - 1] === Emitter.EMIT_SYNC){
            args.pop()
            emit()
        } else {
            defer(emit)
        }

        return this
    }

})

Emitter.EMIT_SYNC = {}

module.exports = Emitter

},{"./defer":373,"./index":375,"mout/array/forEach":330,"mout/array/indexOf":331}],375:[function(require,module,exports){
arguments[4][312][0].apply(exports,arguments)
},{"dup":312,"mout/lang/createObject":342,"mout/lang/kindOf":352,"mout/object/hasOwn":361,"mout/object/mixIn":364}],376:[function(require,module,exports){
/*
Map
*/"use strict"

var indexOf = require("mout/array/indexOf")

var prime = require("./index")

var Map = prime({

    constructor: function Map(){
        this.length = 0
        this._values = []
        this._keys = []
    },

    set: function(key, value){
        var index = indexOf(this._keys, key)

        if (index === -1){
            this._keys.push(key)
            this._values.push(value)
            this.length++
        } else {
            this._values[index] = value
        }

        return this
    },

    get: function(key){
        var index = indexOf(this._keys, key)
        return (index === -1) ? null : this._values[index]
    },

    count: function(){
        return this.length
    },

    forEach: function(method, context){
        for (var i = 0, l = this.length; i < l; i++){
            if (method.call(context, this._values[i], this._keys[i], this) === false) break
        }
        return this
    },

    map: function(method, context){
        var results = new Map
        this.forEach(function(value, key){
            results.set(key, method.call(context, value, key, this))
        }, this)
        return results
    },

    filter: function(method, context){
        var results = new Map
        this.forEach(function(value, key){
            if (method.call(context, value, key, this)) results.set(key, value)
        }, this)
        return results
    },

    every: function(method, context){
        var every = true
        this.forEach(function(value, key){
            if (!method.call(context, value, key, this)) return (every = false)
        }, this)
        return every
    },

    some: function(method, context){
        var some = false
        this.forEach(function(value, key){
            if (method.call(context, value, key, this)) return !(some = true)
        }, this)
        return some
    },

    indexOf: function(value){
        var index = indexOf(this._values, value)
        return (index > -1) ? this._keys[index] : null
    },

    remove: function(value){
        var index = indexOf(this._values, value)

        if (index !== -1){
            this._values.splice(index, 1)
            this.length--
            return this._keys.splice(index, 1)[0]
        }

        return null
    },

    unset: function(key){
        var index = indexOf(this._keys, key)

        if (index !== -1){
            this._keys.splice(index, 1)
            this.length--
            return this._values.splice(index, 1)[0]
        }

        return null
    },

    keys: function(){
        return this._keys.slice()
    },

    values: function(){
        return this._values.slice()
    }

})

var map = function(){
    return new Map
}

map.prototype = Map.prototype

module.exports = map

},{"./index":375,"mout/array/indexOf":331}],377:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],378:[function(require,module,exports){
//  Ramda v0.17.1
//  https://github.com/ramda/ramda
//  (c) 2013-2015 Scott Sauyet, Michael Hurley, and David Chambers
//  Ramda may be freely distributed under the MIT license.

;(function() {

  'use strict';

  /**
     * A special placeholder value used to specify "gaps" within curried functions,
     * allowing partial application of any combination of arguments,
     * regardless of their positions.
     *
     * If `g` is a curried ternary function and `_` is `R.__`, the following are equivalent:
     *
     *   - `g(1, 2, 3)`
     *   - `g(_, 2, 3)(1)`
     *   - `g(_, _, 3)(1)(2)`
     *   - `g(_, _, 3)(1, 2)`
     *   - `g(_, 2, _)(1, 3)`
     *   - `g(_, 2)(1)(3)`
     *   - `g(_, 2)(1, 3)`
     *   - `g(_, 2)(_, 3)(1)`
     *
     * @constant
     * @memberOf R
     * @category Function
     * @example
     *
     *      var greet = R.replace('{name}', R.__, 'Hello, {name}!');
     *      greet('Alice'); //=> 'Hello, Alice!'
     */
    var __ = { '@@functional/placeholder': true };

    // jshint unused:vars
    var _arity = function _arity(n, fn) {
        // jshint unused:vars
        switch (n) {
        case 0:
            return function () {
                return fn.apply(this, arguments);
            };
        case 1:
            return function (a0) {
                return fn.apply(this, arguments);
            };
        case 2:
            return function (a0, a1) {
                return fn.apply(this, arguments);
            };
        case 3:
            return function (a0, a1, a2) {
                return fn.apply(this, arguments);
            };
        case 4:
            return function (a0, a1, a2, a3) {
                return fn.apply(this, arguments);
            };
        case 5:
            return function (a0, a1, a2, a3, a4) {
                return fn.apply(this, arguments);
            };
        case 6:
            return function (a0, a1, a2, a3, a4, a5) {
                return fn.apply(this, arguments);
            };
        case 7:
            return function (a0, a1, a2, a3, a4, a5, a6) {
                return fn.apply(this, arguments);
            };
        case 8:
            return function (a0, a1, a2, a3, a4, a5, a6, a7) {
                return fn.apply(this, arguments);
            };
        case 9:
            return function (a0, a1, a2, a3, a4, a5, a6, a7, a8) {
                return fn.apply(this, arguments);
            };
        case 10:
            return function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
                return fn.apply(this, arguments);
            };
        default:
            throw new Error('First argument to _arity must be a non-negative integer no greater than ten');
        }
    };

    var _cloneRegExp = function _cloneRegExp(pattern) {
        return new RegExp(pattern.source, (pattern.global ? 'g' : '') + (pattern.ignoreCase ? 'i' : '') + (pattern.multiline ? 'm' : '') + (pattern.sticky ? 'y' : '') + (pattern.unicode ? 'u' : ''));
    };

    var _complement = function _complement(f) {
        return function () {
            return !f.apply(this, arguments);
        };
    };

    /**
     * Private `concat` function to merge two array-like objects.
     *
     * @private
     * @param {Array|Arguments} [set1=[]] An array-like object.
     * @param {Array|Arguments} [set2=[]] An array-like object.
     * @return {Array} A new, merged array.
     * @example
     *
     *      _concat([4, 5, 6], [1, 2, 3]); //=> [4, 5, 6, 1, 2, 3]
     */
    var _concat = function _concat(set1, set2) {
        set1 = set1 || [];
        set2 = set2 || [];
        var idx;
        var len1 = set1.length;
        var len2 = set2.length;
        var result = [];
        idx = 0;
        while (idx < len1) {
            result[result.length] = set1[idx];
            idx += 1;
        }
        idx = 0;
        while (idx < len2) {
            result[result.length] = set2[idx];
            idx += 1;
        }
        return result;
    };

    var _containsWith = function _containsWith(pred, x, list) {
        var idx = 0, len = list.length;
        while (idx < len) {
            if (pred(x, list[idx])) {
                return true;
            }
            idx += 1;
        }
        return false;
    };

    /**
     * Optimized internal two-arity curry function.
     *
     * @private
     * @category Function
     * @param {Function} fn The function to curry.
     * @return {Function} The curried function.
     */
    var _curry1 = function _curry1(fn) {
        return function f1(a) {
            if (arguments.length === 0) {
                return f1;
            } else if (a != null && a['@@functional/placeholder'] === true) {
                return f1;
            } else {
                return fn.apply(this, arguments);
            }
        };
    };

    /**
     * Optimized internal two-arity curry function.
     *
     * @private
     * @category Function
     * @param {Function} fn The function to curry.
     * @return {Function} The curried function.
     */
    var _curry2 = function _curry2(fn) {
        return function f2(a, b) {
            var n = arguments.length;
            if (n === 0) {
                return f2;
            } else if (n === 1 && a != null && a['@@functional/placeholder'] === true) {
                return f2;
            } else if (n === 1) {
                return _curry1(function (b) {
                    return fn(a, b);
                });
            } else if (n === 2 && a != null && a['@@functional/placeholder'] === true && b != null && b['@@functional/placeholder'] === true) {
                return f2;
            } else if (n === 2 && a != null && a['@@functional/placeholder'] === true) {
                return _curry1(function (a) {
                    return fn(a, b);
                });
            } else if (n === 2 && b != null && b['@@functional/placeholder'] === true) {
                return _curry1(function (b) {
                    return fn(a, b);
                });
            } else {
                return fn(a, b);
            }
        };
    };

    /**
     * Optimized internal three-arity curry function.
     *
     * @private
     * @category Function
     * @param {Function} fn The function to curry.
     * @return {Function} The curried function.
     */
    var _curry3 = function _curry3(fn) {
        return function f3(a, b, c) {
            var n = arguments.length;
            if (n === 0) {
                return f3;
            } else if (n === 1 && a != null && a['@@functional/placeholder'] === true) {
                return f3;
            } else if (n === 1) {
                return _curry2(function (b, c) {
                    return fn(a, b, c);
                });
            } else if (n === 2 && a != null && a['@@functional/placeholder'] === true && b != null && b['@@functional/placeholder'] === true) {
                return f3;
            } else if (n === 2 && a != null && a['@@functional/placeholder'] === true) {
                return _curry2(function (a, c) {
                    return fn(a, b, c);
                });
            } else if (n === 2 && b != null && b['@@functional/placeholder'] === true) {
                return _curry2(function (b, c) {
                    return fn(a, b, c);
                });
            } else if (n === 2) {
                return _curry1(function (c) {
                    return fn(a, b, c);
                });
            } else if (n === 3 && a != null && a['@@functional/placeholder'] === true && b != null && b['@@functional/placeholder'] === true && c != null && c['@@functional/placeholder'] === true) {
                return f3;
            } else if (n === 3 && a != null && a['@@functional/placeholder'] === true && b != null && b['@@functional/placeholder'] === true) {
                return _curry2(function (a, b) {
                    return fn(a, b, c);
                });
            } else if (n === 3 && a != null && a['@@functional/placeholder'] === true && c != null && c['@@functional/placeholder'] === true) {
                return _curry2(function (a, c) {
                    return fn(a, b, c);
                });
            } else if (n === 3 && b != null && b['@@functional/placeholder'] === true && c != null && c['@@functional/placeholder'] === true) {
                return _curry2(function (b, c) {
                    return fn(a, b, c);
                });
            } else if (n === 3 && a != null && a['@@functional/placeholder'] === true) {
                return _curry1(function (a) {
                    return fn(a, b, c);
                });
            } else if (n === 3 && b != null && b['@@functional/placeholder'] === true) {
                return _curry1(function (b) {
                    return fn(a, b, c);
                });
            } else if (n === 3 && c != null && c['@@functional/placeholder'] === true) {
                return _curry1(function (c) {
                    return fn(a, b, c);
                });
            } else {
                return fn(a, b, c);
            }
        };
    };

    /**
     * Internal curryN function.
     *
     * @private
     * @category Function
     * @param {Number} length The arity of the curried function.
     * @return {array} An array of arguments received thus far.
     * @param {Function} fn The function to curry.
     */
    var _curryN = function _curryN(length, received, fn) {
        return function () {
            var combined = [];
            var argsIdx = 0;
            var left = length;
            var combinedIdx = 0;
            while (combinedIdx < received.length || argsIdx < arguments.length) {
                var result;
                if (combinedIdx < received.length && (received[combinedIdx] == null || received[combinedIdx]['@@functional/placeholder'] !== true || argsIdx >= arguments.length)) {
                    result = received[combinedIdx];
                } else {
                    result = arguments[argsIdx];
                    argsIdx += 1;
                }
                combined[combinedIdx] = result;
                if (result == null || result['@@functional/placeholder'] !== true) {
                    left -= 1;
                }
                combinedIdx += 1;
            }
            return left <= 0 ? fn.apply(this, combined) : _arity(left, _curryN(length, combined, fn));
        };
    };

    var _filter = function _filter(fn, list) {
        var idx = 0, len = list.length, result = [];
        while (idx < len) {
            if (fn(list[idx])) {
                result[result.length] = list[idx];
            }
            idx += 1;
        }
        return result;
    };

    var _forceReduced = function _forceReduced(x) {
        return {
            '@@transducer/value': x,
            '@@transducer/reduced': true
        };
    };

    /**
     * @private
     * @param {Function} fn The strategy for extracting function names from an object
     * @return {Function} A function that takes an object and returns an array of function names.
     */
    var _functionsWith = function _functionsWith(fn) {
        return function (obj) {
            return _filter(function (key) {
                return typeof obj[key] === 'function';
            }, fn(obj));
        };
    };

    var _has = function _has(prop, obj) {
        return Object.prototype.hasOwnProperty.call(obj, prop);
    };

    var _identity = function _identity(x) {
        return x;
    };

    /**
     * Tests whether or not an object is an array.
     *
     * @private
     * @param {*} val The object to test.
     * @return {Boolean} `true` if `val` is an array, `false` otherwise.
     * @example
     *
     *      _isArray([]); //=> true
     *      _isArray(null); //=> false
     *      _isArray({}); //=> false
     */
    var _isArray = Array.isArray || function _isArray(val) {
        return val != null && val.length >= 0 && Object.prototype.toString.call(val) === '[object Array]';
    };

    /**
     * Determine if the passed argument is an integer.
     *
     * @private
     * @param {*} n
     * @category Type
     * @return {Boolean}
     */
    var _isInteger = Number.isInteger || function _isInteger(n) {
        return n << 0 === n;
    };

    var _isNumber = function _isNumber(x) {
        return Object.prototype.toString.call(x) === '[object Number]';
    };

    var _isString = function _isString(x) {
        return Object.prototype.toString.call(x) === '[object String]';
    };

    var _isTransformer = function _isTransformer(obj) {
        return typeof obj['@@transducer/step'] === 'function';
    };

    var _map = function _map(fn, list) {
        var idx = 0, len = list.length, result = Array(len);
        while (idx < len) {
            result[idx] = fn(list[idx]);
            idx += 1;
        }
        return result;
    };

    var _pipe = function _pipe(f, g) {
        return function () {
            return g.call(this, f.apply(this, arguments));
        };
    };

    var _pipeP = function _pipeP(f, g) {
        return function () {
            var ctx = this;
            return f.apply(ctx, arguments).then(function (x) {
                return g.call(ctx, x);
            });
        };
    };

    var _quote = function _quote(s) {
        return '"' + s.replace(/"/g, '\\"') + '"';
    };

    var _reduced = function _reduced(x) {
        return x && x['@@transducer/reduced'] ? x : {
            '@@transducer/value': x,
            '@@transducer/reduced': true
        };
    };

    /**
     * An optimized, private array `slice` implementation.
     *
     * @private
     * @param {Arguments|Array} args The array or arguments object to consider.
     * @param {Number} [from=0] The array index to slice from, inclusive.
     * @param {Number} [to=args.length] The array index to slice to, exclusive.
     * @return {Array} A new, sliced array.
     * @example
     *
     *      _slice([1, 2, 3, 4, 5], 1, 3); //=> [2, 3]
     *
     *      var firstThreeArgs = function(a, b, c, d) {
     *        return _slice(arguments, 0, 3);
     *      };
     *      firstThreeArgs(1, 2, 3, 4); //=> [1, 2, 3]
     */
    var _slice = function _slice(args, from, to) {
        switch (arguments.length) {
        case 1:
            return _slice(args, 0, args.length);
        case 2:
            return _slice(args, from, args.length);
        default:
            var list = [];
            var idx = 0;
            var len = Math.max(0, Math.min(args.length, to) - from);
            while (idx < len) {
                list[idx] = args[from + idx];
                idx += 1;
            }
            return list;
        }
    };

    /**
     * Polyfill from <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString>.
     */
    var _toISOString = function () {
        var pad = function pad(n) {
            return (n < 10 ? '0' : '') + n;
        };
        return typeof Date.prototype.toISOString === 'function' ? function _toISOString(d) {
            return d.toISOString();
        } : function _toISOString(d) {
            return d.getUTCFullYear() + '-' + pad(d.getUTCMonth() + 1) + '-' + pad(d.getUTCDate()) + 'T' + pad(d.getUTCHours()) + ':' + pad(d.getUTCMinutes()) + ':' + pad(d.getUTCSeconds()) + '.' + (d.getUTCMilliseconds() / 1000).toFixed(3).slice(2, 5) + 'Z';
        };
    }();

    var _xdropRepeatsWith = function () {
        function XDropRepeatsWith(pred, xf) {
            this.xf = xf;
            this.pred = pred;
            this.lastValue = undefined;
            this.seenFirstValue = false;
        }
        XDropRepeatsWith.prototype['@@transducer/init'] = function () {
            return this.xf['@@transducer/init']();
        };
        XDropRepeatsWith.prototype['@@transducer/result'] = function (result) {
            return this.xf['@@transducer/result'](result);
        };
        XDropRepeatsWith.prototype['@@transducer/step'] = function (result, input) {
            var sameAsLast = false;
            if (!this.seenFirstValue) {
                this.seenFirstValue = true;
            } else if (this.pred(this.lastValue, input)) {
                sameAsLast = true;
            }
            this.lastValue = input;
            return sameAsLast ? result : this.xf['@@transducer/step'](result, input);
        };
        return _curry2(function _xdropRepeatsWith(pred, xf) {
            return new XDropRepeatsWith(pred, xf);
        });
    }();

    var _xfBase = {
        init: function () {
            return this.xf['@@transducer/init']();
        },
        result: function (result) {
            return this.xf['@@transducer/result'](result);
        }
    };

    var _xfilter = function () {
        function XFilter(f, xf) {
            this.xf = xf;
            this.f = f;
        }
        XFilter.prototype['@@transducer/init'] = _xfBase.init;
        XFilter.prototype['@@transducer/result'] = _xfBase.result;
        XFilter.prototype['@@transducer/step'] = function (result, input) {
            return this.f(input) ? this.xf['@@transducer/step'](result, input) : result;
        };
        return _curry2(function _xfilter(f, xf) {
            return new XFilter(f, xf);
        });
    }();

    var _xfind = function () {
        function XFind(f, xf) {
            this.xf = xf;
            this.f = f;
            this.found = false;
        }
        XFind.prototype['@@transducer/init'] = _xfBase.init;
        XFind.prototype['@@transducer/result'] = function (result) {
            if (!this.found) {
                result = this.xf['@@transducer/step'](result, void 0);
            }
            return this.xf['@@transducer/result'](result);
        };
        XFind.prototype['@@transducer/step'] = function (result, input) {
            if (this.f(input)) {
                this.found = true;
                result = _reduced(this.xf['@@transducer/step'](result, input));
            }
            return result;
        };
        return _curry2(function _xfind(f, xf) {
            return new XFind(f, xf);
        });
    }();

    var _xfindIndex = function () {
        function XFindIndex(f, xf) {
            this.xf = xf;
            this.f = f;
            this.idx = -1;
            this.found = false;
        }
        XFindIndex.prototype['@@transducer/init'] = _xfBase.init;
        XFindIndex.prototype['@@transducer/result'] = function (result) {
            if (!this.found) {
                result = this.xf['@@transducer/step'](result, -1);
            }
            return this.xf['@@transducer/result'](result);
        };
        XFindIndex.prototype['@@transducer/step'] = function (result, input) {
            this.idx += 1;
            if (this.f(input)) {
                this.found = true;
                result = _reduced(this.xf['@@transducer/step'](result, this.idx));
            }
            return result;
        };
        return _curry2(function _xfindIndex(f, xf) {
            return new XFindIndex(f, xf);
        });
    }();

    var _xfindLast = function () {
        function XFindLast(f, xf) {
            this.xf = xf;
            this.f = f;
        }
        XFindLast.prototype['@@transducer/init'] = _xfBase.init;
        XFindLast.prototype['@@transducer/result'] = function (result) {
            return this.xf['@@transducer/result'](this.xf['@@transducer/step'](result, this.last));
        };
        XFindLast.prototype['@@transducer/step'] = function (result, input) {
            if (this.f(input)) {
                this.last = input;
            }
            return result;
        };
        return _curry2(function _xfindLast(f, xf) {
            return new XFindLast(f, xf);
        });
    }();

    var _xfindLastIndex = function () {
        function XFindLastIndex(f, xf) {
            this.xf = xf;
            this.f = f;
            this.idx = -1;
            this.lastIdx = -1;
        }
        XFindLastIndex.prototype['@@transducer/init'] = _xfBase.init;
        XFindLastIndex.prototype['@@transducer/result'] = function (result) {
            return this.xf['@@transducer/result'](this.xf['@@transducer/step'](result, this.lastIdx));
        };
        XFindLastIndex.prototype['@@transducer/step'] = function (result, input) {
            this.idx += 1;
            if (this.f(input)) {
                this.lastIdx = this.idx;
            }
            return result;
        };
        return _curry2(function _xfindLastIndex(f, xf) {
            return new XFindLastIndex(f, xf);
        });
    }();

    var _xmap = function () {
        function XMap(f, xf) {
            this.xf = xf;
            this.f = f;
        }
        XMap.prototype['@@transducer/init'] = _xfBase.init;
        XMap.prototype['@@transducer/result'] = _xfBase.result;
        XMap.prototype['@@transducer/step'] = function (result, input) {
            return this.xf['@@transducer/step'](result, this.f(input));
        };
        return _curry2(function _xmap(f, xf) {
            return new XMap(f, xf);
        });
    }();

    var _xtake = function () {
        function XTake(n, xf) {
            this.xf = xf;
            this.n = n;
        }
        XTake.prototype['@@transducer/init'] = _xfBase.init;
        XTake.prototype['@@transducer/result'] = _xfBase.result;
        XTake.prototype['@@transducer/step'] = function (result, input) {
            if (this.n === 0) {
                return _reduced(result);
            } else {
                this.n -= 1;
                return this.xf['@@transducer/step'](result, input);
            }
        };
        return _curry2(function _xtake(n, xf) {
            return new XTake(n, xf);
        });
    }();

    var _xtakeWhile = function () {
        function XTakeWhile(f, xf) {
            this.xf = xf;
            this.f = f;
        }
        XTakeWhile.prototype['@@transducer/init'] = _xfBase.init;
        XTakeWhile.prototype['@@transducer/result'] = _xfBase.result;
        XTakeWhile.prototype['@@transducer/step'] = function (result, input) {
            return this.f(input) ? this.xf['@@transducer/step'](result, input) : _reduced(result);
        };
        return _curry2(function _xtakeWhile(f, xf) {
            return new XTakeWhile(f, xf);
        });
    }();

    var _xwrap = function () {
        function XWrap(fn) {
            this.f = fn;
        }
        XWrap.prototype['@@transducer/init'] = function () {
            throw new Error('init not implemented on XWrap');
        };
        XWrap.prototype['@@transducer/result'] = function (acc) {
            return acc;
        };
        XWrap.prototype['@@transducer/step'] = function (acc, x) {
            return this.f(acc, x);
        };
        return function _xwrap(fn) {
            return new XWrap(fn);
        };
    }();

    /**
     * Adds two numbers. Equivalent to `a + b` but curried.
     *
     * @func
     * @memberOf R
     * @category Math
     * @sig Number -> Number -> Number
     * @param {Number} a
     * @param {Number} b
     * @return {Number}
     * @see R.subtract
     * @example
     *
     *      R.add(2, 3);       //=>  5
     *      R.add(7)(10);      //=> 17
     */
    var add = _curry2(function add(a, b) {
        return a + b;
    });

    /**
     * Applies a function to the value at the given index of an array,
     * returning a new copy of the array with the element at the given
     * index replaced with the result of the function application.
     * @see R.update
     *
     * @func
     * @memberOf R
     * @category List
     * @sig (a -> a) -> Number -> [a] -> [a]
     * @param {Function} fn The function to apply.
     * @param {Number} idx The index.
     * @param {Array|Arguments} list An array-like object whose value
     *        at the supplied index will be replaced.
     * @return {Array} A copy of the supplied array-like object with
     *         the element at index `idx` replaced with the value
     *         returned by applying `fn` to the existing element.
     * @example
     *
     *      R.adjust(R.add(10), 1, [0, 1, 2]);     //=> [0, 11, 2]
     *      R.adjust(R.add(10))(1)([0, 1, 2]);     //=> [0, 11, 2]
     */
    var adjust = _curry3(function adjust(fn, idx, list) {
        if (idx >= list.length || idx < -list.length) {
            return list;
        }
        var start = idx < 0 ? list.length : 0;
        var _idx = start + idx;
        var _list = _concat(list);
        _list[_idx] = fn(list[_idx]);
        return _list;
    });

    /**
     * Returns a function that always returns the given value. Note that for
     * non-primitives the value returned is a reference to the original value.
     *
     * This function is known as `const`, `constant`, or `K` (for K combinator)
     * in other languages and libraries.
     *
     * @func
     * @memberOf R
     * @category Function
     * @sig a -> (* -> a)
     * @param {*} val The value to wrap in a function
     * @return {Function} A Function :: * -> val.
     * @example
     *
     *      var t = R.always('Tee');
     *      t(); //=> 'Tee'
     */
    var always = _curry1(function always(val) {
        return function () {
            return val;
        };
    });

    /**
     * Returns a new list, composed of n-tuples of consecutive elements
     * If `n` is greater than the length of the list, an empty list is returned.
     *
     * @func
     * @memberOf R
     * @category List
     * @sig Number -> [a] -> [[a]]
     * @param {Number} n The size of the tuples to create
     * @param {Array} list The list to split into `n`-tuples
     * @return {Array} The new list.
     * @example
     *
     *      R.aperture(2, [1, 2, 3, 4, 5]); //=> [[1, 2], [2, 3], [3, 4], [4, 5]]
     *      R.aperture(3, [1, 2, 3, 4, 5]); //=> [[1, 2, 3], [2, 3, 4], [3, 4, 5]]
     *      R.aperture(7, [1, 2, 3, 4, 5]); //=> []
     */
    var aperture = _curry2(function aperture(n, list) {
        var idx = 0;
        var limit = list.length - (n - 1);
        var acc = new Array(limit >= 0 ? limit : 0);
        while (idx < limit) {
            acc[idx] = _slice(list, idx, idx + n);
            idx += 1;
        }
        return acc;
    });

    /**
     * Returns a new list containing the contents of the given list, followed by the given
     * element.
     *
     * @func
     * @memberOf R
     * @category List
     * @sig a -> [a] -> [a]
     * @param {*} el The element to add to the end of the new list.
     * @param {Array} list The list whose contents will be added to the beginning of the output
     *        list.
     * @return {Array} A new list containing the contents of the old list followed by `el`.
     * @see R.prepend
     * @example
     *
     *      R.append('tests', ['write', 'more']); //=> ['write', 'more', 'tests']
     *      R.append('tests', []); //=> ['tests']
     *      R.append(['tests'], ['write', 'more']); //=> ['write', 'more', ['tests']]
     */
    var append = _curry2(function append(el, list) {
        return _concat(list, [el]);
    });

    /**
     * Applies function `fn` to the argument list `args`. This is useful for
     * creating a fixed-arity function from a variadic function. `fn` should
     * be a bound function if context is significant.
     *
     * @func
     * @memberOf R
     * @category Function
     * @sig (*... -> a) -> [*] -> a
     * @param {Function} fn
     * @param {Array} args
     * @return {*}
     * @see R.call, R.unapply
     * @example
     *
     *      var nums = [1, 2, 3, -99, 42, 6, 7];
     *      R.apply(Math.max, nums); //=> 42
     */
    var apply = _curry2(function apply(fn, args) {
        return fn.apply(this, args);
    });

    /**
     * Makes a shallow clone of an object, setting or overriding the specified
     * property with the given value.  Note that this copies and flattens
     * prototype properties onto the new object as well.  All non-primitive
     * properties are copied by reference.
     *
     * @func
     * @memberOf R
     * @category Object
     * @sig String -> a -> {k: v} -> {k: v}
     * @param {String} prop the property name to set
     * @param {*} val the new value
     * @param {Object} obj the object to clone
     * @return {Object} a new object similar to the original except for the specified property.
     * @see R.dissoc
     * @example
     *
     *      R.assoc('c', 3, {a: 1, b: 2}); //=> {a: 1, b: 2, c: 3}
     */
    var assoc = _curry3(function assoc(prop, val, obj) {
        var result = {};
        for (var p in obj) {
            result[p] = obj[p];
        }
        result[prop] = val;
        return result;
    });

    /**
     * Makes a shallow clone of an object, setting or overriding the nodes
     * required to create the given path, and placing the specific value at the
     * tail end of that path.  Note that this copies and flattens prototype
     * properties onto the new object as well.  All non-primitive properties
     * are copied by reference.
     *
     * @func
     * @memberOf R
     * @category Object
     * @sig [String] -> a -> {k: v} -> {k: v}
     * @param {Array} path the path to set
     * @param {*} val the new value
     * @param {Object} obj the object to clone
     * @return {Object} a new object similar to the original except along the specified path.
     * @see R.dissocPath
     * @example
     *
     *      R.assocPath(['a', 'b', 'c'], 42, {a: {b: {c: 0}}}); //=> {a: {b: {c: 42}}}
     */
    var assocPath = _curry3(function assocPath(path, val, obj) {
        switch (path.length) {
        case 0:
            return obj;
        case 1:
            return assoc(path[0], val, obj);
        default:
            return assoc(path[0], assocPath(_slice(path, 1), val, Object(obj[path[0]])), obj);
        }
    });

    /**
     * Creates a function that is bound to a context.
     * Note: `R.bind` does not provide the additional argument-binding capabilities of
     * [Function.prototype.bind](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).
     *
     * @func
     * @memberOf R
     * @category Function
     * @category Object
     * @see R.partial
     * @sig (* -> *) -> {*} -> (* -> *)
     * @param {Function} fn The function to bind to context
     * @param {Object} thisObj The context to bind `fn` to
     * @return {Function} A function that will execute in the context of `thisObj`.
     */
    var bind = _curry2(function bind(fn, thisObj) {
        return _arity(fn.length, function () {
            return fn.apply(thisObj, arguments);
        });
    });

    /**
     * A function wrapping calls to the two functions in an `&&` operation, returning the result of the first
     * function if it is false-y and the result of the second function otherwise.  Note that this is
     * short-circuited, meaning that the second function will not be invoked if the first returns a false-y
     * value.
     *
     * @func
     * @memberOf R
     * @category Logic
     * @sig (*... -> Boolean) -> (*... -> Boolean) -> (*... -> Boolean)
     * @param {Function} f a predicate
     * @param {Function} g another predicate
     * @return {Function} a function that applies its arguments to `f` and `g` and `&&`s their outputs together.
     * @see R.and
     * @example
     *
     *      var gt10 = function(x) { return x > 10; };
     *      var even = function(x) { return x % 2 === 0 };
     *      var f = R.both(gt10, even);
     *      f(100); //=> true
     *      f(101); //=> false
     */
    var both = _curry2(function both(f, g) {
        return function _both() {
            return f.apply(this, arguments) && g.apply(this, arguments);
        };
    });

    /**
     * Makes a comparator function out of a function that reports whether the first element is less than the second.
     *
     * @func
     * @memberOf R
     * @category Function
     * @sig (a, b -> Boolean) -> (a, b -> Number)
     * @param {Function} pred A predicate function of arity two.
     * @return {Function} A Function :: a -> b -> Int that returns `-1` if a < b, `1` if b < a, otherwise `0`.
     * @example
     *
     *      var cmp = R.comparator(function(a, b) {
     *        return a.age < b.age;
     *      });
     *      var people = [
     *        // ...
     *      ];
     *      R.sort(cmp, people);
     */
    var comparator = _curry1(function comparator(pred) {
        return function (a, b) {
            return pred(a, b) ? -1 : pred(b, a) ? 1 : 0;
        };
    });

    /**
     * Takes a function `f` and returns a function `g` such that:
     *
     *   - applying `g` to zero or more arguments will give __true__ if applying
     *     the same arguments to `f` gives a logical __false__ value; and
     *
     *   - applying `g` to zero or more arguments will give __false__ if applying
     *     the same arguments to `f` gives a logical __true__ value.
     *
     * @func
     * @memberOf R
     * @category Logic
     * @sig (*... -> *) -> (*... -> Boolean)
     * @param {Function} f
     * @return {Function}
     * @see R.not
     * @example
     *
     *      var isEven = function(n) { return n % 2 === 0; };
     *      var isOdd = R.complement(isEven);
     *      isOdd(21); //=> true
     *      isOdd(42); //=> false
     */
    var complement = _curry1(_complement);

    /**
     * Returns a function, `fn`, which encapsulates if/else-if/else logic.
     * `R.cond` takes a list of [predicate, transform] pairs. All of the
     * arguments to `fn` are applied to each of the predicates in turn
     * until one returns a "truthy" value, at which point `fn` returns the
     * result of applying its arguments to the corresponding transformer.
     * If none of the predicates matches, `fn` returns undefined.
     *
     * @func
     * @memberOf R
     * @category Logic
     * @sig [[(*... -> Boolean),(*... -> *)]] -> (*... -> *)
     * @param {Array} pairs
     * @return {Function}
     * @example
     *
     *      var fn = R.cond([
     *        [R.equals(0),   R.always('water freezes at 0°C')],
     *        [R.equals(100), R.always('water boils at 100°C')],
     *        [R.T,           function(temp) { return 'nothing special happens at ' + temp + '°C'; }]
     *      ]);
     *      fn(0); //=> 'water freezes at 0°C'
     *      fn(50); //=> 'nothing special happens at 50°C'
     *      fn(100); //=> 'water boils at 100°C'
     */
    var cond = _curry1(function cond(pairs) {
        return function () {
            var idx = 0;
            while (idx < pairs.length) {
                if (pairs[idx][0].apply(this, arguments)) {
                    return pairs[idx][1].apply(this, arguments);
                }
                idx += 1;
            }
        };
    });

    /**
     * Returns `true` if the `x` is found in the `list`, using `pred` as an
     * equality predicate for `x`.
     *
     * @func
     * @memberOf R
     * @category List
     * @sig (a, a -> Boolean) -> a -> [a] -> Boolean
     * @param {Function} pred A predicate used to test whether two items are equal.
     * @param {*} x The item to find
     * @param {Array} list The list to iterate over
     * @return {Boolean} `true` if `x` is in `list`, else `false`.
     * @example
     *
     *      var xs = [{x: 12}, {x: 11}, {x: 10}];
     *      R.containsWith(function(a, b) { return a.x === b.x; }, {x: 10}, xs); //=> true
     *      R.containsWith(function(a, b) { return a.x === b.x; }, {x: 1}, xs); //=> false
     */
    var containsWith = _curry3(_containsWith);

    /**
     * Counts the elements of a list according to how many match each value
     * of a key generated by the supplied function. Returns an object
     * mapping the keys produced by `fn` to the number of occurrences in
     * the list. Note that all keys are coerced to strings because of how
     * JavaScript objects work.
     *
     * @func
     * @memberOf R
     * @category Relation
     * @sig (a -> String) -> [a] -> {*}
     * @param {Function} fn The function used to map values to keys.
     * @param {Array} list The list to count elements from.
     * @return {Object} An object mapping keys to number of occurrences in the list.
     * @example
     *
     *      var numbers = [1.0, 1.1, 1.2, 2.0, 3.0, 2.2];
     *      var letters = R.split('', 'abcABCaaaBBc');
     *      R.countBy(Math.floor)(numbers);    //=> {'1': 3, '2': 2, '3': 1}
     *      R.countBy(R.toLower)(letters);   //=> {'a': 5, 'b': 4, 'c': 3}
     */
    var countBy = _curry2(function countBy(fn, list) {
        var counts = {};
        var len = list.length;
        var idx = 0;
        while (idx < len) {
            var key = fn(list[idx]);
            counts[key] = (_has(key, counts) ? counts[key] : 0) + 1;
            idx += 1;
        }
        return counts;
    });

    /**
     * Creates an object containing a single key:value pair.
     *
     * @func
     * @memberOf R
     * @category Object
     * @sig String -> a -> {String:a}
     * @param {String} key
     * @param {*} val
     * @return {Object}
     * @example
     *
     *      var matchPhrases = R.compose(
     *        R.createMapEntry('must'),
     *        R.map(R.createMapEntry('match_phrase'))
     *      );
     *      matchPhrases(['foo', 'bar', 'baz']); //=> {must: [{match_phrase: 'foo'}, {match_phrase: 'bar'}, {match_phrase: 'baz'}]}
     */
    var createMapEntry = _curry2(function createMapEntry(key, val) {
        var obj = {};
        obj[key] = val;
        return obj;
    });

    /**
     * Returns a curried equivalent of the provided function, with the
     * specified arity. The curried function has two unusual capabilities.
     * First, its arguments needn't be provided one at a time. If `g` is
     * `R.curryN(3, f)`, the following are equivalent:
     *
     *   - `g(1)(2)(3)`
     *   - `g(1)(2, 3)`
     *   - `g(1, 2)(3)`
     *   - `g(1, 2, 3)`
     *
     * Secondly, the special placeholder value `R.__` may be used to specify
     * "gaps", allowing partial application of any combination of arguments,
     * regardless of their positions. If `g` is as above and `_` is `R.__`,
     * the following are equivalent:
     *
     *   - `g(1, 2, 3)`
     *   - `g(_, 2, 3)(1)`
     *   - `g(_, _, 3)(1)(2)`
     *   - `g(_, _, 3)(1, 2)`
     *   - `g(_, 2)(1)(3)`
     *   - `g(_, 2)(1, 3)`
     *   - `g(_, 2)(_, 3)(1)`
     *
     * @func
     * @memberOf R
     * @category Function
     * @sig Number -> (* -> a) -> (* -> a)
     * @param {Number} length The arity for the returned function.
     * @param {Function} fn The function to curry.
     * @return {Function} A new, curried function.
     * @see R.curry
     * @example
     *
     *      var addFourNumbers = function() {
     *        return R.sum([].slice.call(arguments, 0, 4));
     *      };
     *
     *      var curriedAddFourNumbers = R.curryN(4, addFourNumbers);
     *      var f = curriedAddFourNumbers(1, 2);
     *      var g = f(3);
     *      g(4); //=> 10
     */
    var curryN = _curry2(function curryN(length, fn) {
        if (length === 1) {
            return _curry1(fn);
        }
        return _arity(length, _curryN(length, [], fn));
    });

    /**
     * Decrements its argument.
     *
     * @func
     * @memberOf R
     * @category Math
     * @sig Number -> Number
     * @param {Number} n
     * @return {Number}
     * @see R.inc
     * @example
     *
     *      R.dec(42); //=> 41
     */
    var dec = add(-1);

    /**
     * Returns the second argument if it is not null or undefined. If it is null
     * or undefined, the first (default) argument is returned.
     *
     * @func
     * @memberOf R
     * @category Logic
     * @sig a -> b -> a | b
     * @param {a} val The default value.
     * @param {b} val The value to return if it is not null or undefined
     * @return {*} The the second value or the default value
     * @example
     *
     *      var defaultTo42 = defaultTo(42);
     *
     *      defaultTo42(null);  //=> 42
     *      defaultTo42(undefined);  //=> 42
     *      defaultTo42('Ramda');  //=> 'Ramda'
     */
    var defaultTo = _curry2(function defaultTo(d, v) {
        return v == null ? d : v;
    });

    /**
     * Finds the set (i.e. no duplicates) of all elements in the first list not contained in the second list.
     * Duplication is determined according to the value returned by applying the supplied predicate to two list
     * elements.
     *
     * @func
     * @memberOf R
     * @category Relation
     * @sig (a,a -> Boolean) -> [a] -> [a] -> [a]
     * @param {Function} pred A predicate used to test whether two items are equal.
     * @param {Array} list1 The first list.
     * @param {Array} list2 The second list.
     * @see R.difference
     * @return {Array} The elements in `list1` that are not in `list2`.
     * @example
     *
     *      function cmp(x, y) { return x.a === y.a; }
     *      var l1 = [{a: 1}, {a: 2}, {a: 3}];
     *      var l2 = [{a: 3}, {a: 4}];
     *      R.differenceWith(cmp, l1, l2); //=> [{a: 1}, {a: 2}]
     */
    var differenceWith = _curry3(function differenceWith(pred, first, second) {
        var out = [];
        var idx = 0;
        var firstLen = first.length;
        var containsPred = containsWith(pred);
        while (idx < firstLen) {
            if (!containsPred(first[idx], second) && !containsPred(first[idx], out)) {
                out[out.length] = first[idx];
            }
            idx += 1;
        }
        return out;
    });

    /**
     * Returns a new object that does not contain a `prop` property.
     *
     * @func
     * @memberOf R
     * @category Object
     * @sig String -> {k: v} -> {k: v}
     * @param {String} prop the name of the property to dissociate
     * @param {Object} obj the object to clone
     * @return {Object} a new object similar to the original but without the specified property
     * @see R.assoc
     * @example
     *
     *      R.dissoc('b', {a: 1, b: 2, c: 3}); //=> {a: 1, c: 3}
     */
    var dissoc = _curry2(function dissoc(prop, obj) {
        var result = {};
        for (var p in obj) {
            if (p !== prop) {
                result[p] = obj[p];
            }
        }
        return result;
    });

    /**
     * Makes a shallow clone of an object, omitting the property at the
     * given path. Note that this copies and flattens prototype properties
     * onto the new object as well.  All non-primitive properties are copied
     * by reference.
     *
     * @func
     * @memberOf R
     * @category Object
     * @sig [String] -> {k: v} -> {k: v}
     * @param {Array} path the path to set
     * @param {Object} obj the object to clone
     * @return {Object} a new object without the property at path
     * @see R.assocPath
     * @example
     *
     *      R.dissocPath(['a', 'b', 'c'], {a: {b: {c: 42}}}); //=> {a: {b: {}}}
     */
    var dissocPath = _curry2(function dissocPath(path, obj) {
        switch (path.length) {
        case 0:
            return obj;
        case 1:
            return dissoc(path[0], obj);
        default:
            var head = path[0];
            var tail = _slice(path, 1);
            return obj[head] == null ? obj : assoc(head, dissocPath(tail, obj[head]), obj);
        }
    });

    /**
     * Divides two numbers. Equivalent to `a / b`.
     *
     * @func
     * @memberOf R
     * @category Math
     * @sig Number -> Number -> Number
     * @param {Number} a The first value.
     * @param {Number} b The second value.
     * @return {Number} The result of `a / b`.
     * @see R.multiply
     * @example
     *
     *      R.divide(71, 100); //=> 0.71
     *
     *      var half = R.divide(R.__, 2);
     *      half(42); //=> 21
     *
     *      var reciprocal = R.divide(1);
     *      reciprocal(4);   //=> 0.25
     */
    var divide = _curry2(function divide(a, b) {
        return a / b;
    });

    /**
     * Returns a new list containing all but last the`n` elements of a given list,
     * passing each value from the right to the supplied predicate function, skipping
     * elements while the predicate function returns `true`. The predicate function
     * is passed one argument: (value)*.
     *
     * @func
     * @memberOf R
     * @category List
     * @sig (a -> Boolean) -> [a] -> [a]
     * @param {Function} fn The function called per iteration.
     * @param {Array} list The collection to iterate over.
     * @return {Array} A new array.
     * @see R.takeLastWhile
     * @example
     *
     *      var lteThree = function(x) {
     *        return x <= 3;
     *      };
     *
     *      R.dropLastWhile(lteThree, [1, 2, 3, 4, 3, 2, 1]); //=> [1, 2]
     */
    var dropLastWhile = _curry2(function dropLastWhile(pred, list) {
        var idx = list.length - 1;
        while (idx >= 0 && pred(list[idx])) {
            idx -= 1;
        }
        return _slice(list, 0, idx + 1);
    });

    /**
     * A function wrapping calls to the two functions in an `||` operation, returning the result of the first
     * function if it is truth-y and the result of the second function otherwise.  Note that this is
     * short-circuited, meaning that the second function will not be invoked if the first returns a truth-y
     * value.
     *
     * @func
     * @memberOf R
     * @category Logic
     * @sig (*... -> Boolean) -> (*... -> Boolean) -> (*... -> Boolean)
     * @param {Function} f a predicate
     * @param {Function} g another predicate
     * @return {Function} a function that applies its arguments to `f` and `g` and `||`s their outputs together.
     * @see R.or
     * @example
     *
     *      var gt10 = function(x) { return x > 10; };
     *      var even = function(x) { return x % 2 === 0 };
     *      var f = R.either(gt10, even);
     *      f(101); //=> true
     *      f(8); //=> true
     */
    var either = _curry2(function either(f, g) {
        return function _either() {
            return f.apply(this, arguments) || g.apply(this, arguments);
        };
    });

    /**
     * Returns the empty value of its argument's type. Ramda defines the empty
     * value of Array (`[]`), Object (`{}`), and String (`''`). Other types are
     * supported if they define `<Type>.empty` and/or `<Type>.prototype.empty`.
     *
     * @func
     * @memberOf R
     * @category Function
     * @sig a -> a
     * @param {*} x
     * @return {*}
     * @example
     *
     *      R.empty(Just(42));      //=> Nothing()
     *      R.empty([1, 2, 3]);     //=> []
     *      R.empty('unicorns');    //=> ''
     *      R.empty({x: 1, y: 2});  //=> {}
     */
    var empty = _curry1(function empty(x) {
        if (x != null && typeof x.empty === 'function') {
            return x.empty();
        } else if (x != null && typeof x.constructor != null && typeof x.constructor.empty === 'function') {
            return x.constructor.empty();
        } else {
            switch (Object.prototype.toString.call(x)) {
            case '[object Array]':
                return [];
            case '[object Object]':
                return {};
            case '[object String]':
                return '';
            }
        }
    });

    /**
     * Creates a new object by recursively evolving a shallow copy of `object`, according to the
     * `transformation` functions. All non-primitive properties are copied by reference.
     *
     * A `tranformation` function will not be invoked if its corresponding key does not exist in
     * the evolved object.
     *
     * @func
     * @memberOf R
     * @category Object
     * @sig {k: (v -> v)} -> {k: v} -> {k: v}
     * @param {Object} transformations The object specifying transformation functions to apply
     *        to the object.
     * @param {Object} object The object to be transformed.
     * @return {Object} The transformed object.
     * @example
     *
     *      var tomato  = {firstName: '  Tomato ', data: {elapsed: 100, remaining: 1400}, id:123};
     *      var transformations = {
     *        firstName: R.trim,
     *        lastName: R.trim, // Will not get invoked.
     *        data: {elapsed: R.add(1), remaining: R.add(-1)}
     *      };
     *      R.evolve(transformations, tomato); //=> {firstName: 'Tomato', data: {elapsed: 101, remaining: 1399}, id:123}
     */
    var evolve = _curry2(function evolve(transformations, object) {
        var transformation, key, type, result = {};
        for (key in object) {
            transformation = transformations[key];
            type = typeof transformation;
            result[key] = type === 'function' ? transformation(object[key]) : type === 'object' ? evolve(transformations[key], object[key]) : object[key];
        }
        return result;
    });

    /**
     * Creates a new object out of a list key-value pairs.
     *
     * @func
     * @memberOf R
     * @category List
     * @sig [[k,v]] -> {k: v}
     * @param {Array} pairs An array of two-element arrays that will be the keys and values of the output object.
     * @return {Object} The object made by pairing up `keys` and `values`.
     * @see R.toPairs
     * @example
     *
     *      R.fromPairs([['a', 1], ['b', 2],  ['c', 3]]); //=> {a: 1, b: 2, c: 3}
     */
    var fromPairs = _curry1(function fromPairs(pairs) {
        var idx = 0, len = pairs.length, out = {};
        while (idx < len) {
            if (_isArray(pairs[idx]) && pairs[idx].length) {
                out[pairs[idx][0]] = pairs[idx][1];
            }
            idx += 1;
        }
        return out;
    });

    /**
     * Returns `true` if the first argument is greater than the second;
     * `false` otherwise.
     *
     * @func
     * @memberOf R
     * @category Relation
     * @sig Ord a => a -> a -> Boolean
     * @param {*} a
     * @param {*} b
     * @return {Boolean}
     * @see R.lt
     * @example
     *
     *      R.gt(2, 1); //=> true
     *      R.gt(2, 2); //=> false
     *      R.gt(2, 3); //=> false
     *      R.gt('a', 'z'); //=> false
     *      R.gt('z', 'a'); //=> true
     */
    var gt = _curry2(function gt(a, b) {
        return a > b;
    });

    /**
     * Returns `true` if the first argument is greater than or equal to the second;
     * `false` otherwise.
     *
     * @func
     * @memberOf R
     * @category Relation
     * @sig Ord a => a -> a -> Boolean
     * @param {Number} a
     * @param {Number} b
     * @return {Boolean}
     * @see R.lte
     * @example
     *
     *      R.gte(2, 1); //=> true
     *      R.gte(2, 2); //=> true
     *      R.gte(2, 3); //=> false
     *      R.gte('a', 'z'); //=> false
     *      R.gte('z', 'a'); //=> true
     */
    var gte = _curry2(function gte(a, b) {
        return a >= b;
    });

    /**
     * Returns whether or not an object has an own property with
     * the specified name
     *
     * @func
     * @memberOf R
     * @category Object
     * @sig s -> {s: x} -> Boolean
     * @param {String} prop The name of the property to check for.
     * @param {Object} obj The object to query.
     * @return {Boolean} Whether the property exists.
     * @example
     *
     *      var hasName = R.has('name');
     *      hasName({name: 'alice'});   //=> true
     *      hasName({name: 'bob'});     //=> true
     *      hasName({});                //=> false
     *
     *      var point = {x: 0, y: 0};
     *      var pointHas = R.has(R.__, point);
     *      pointHas('x');  //=> true
     *      pointHas('y');  //=> true
     *      pointHas('z');  //=> false
     */
    var has = _curry2(_has);

    /**
     * Returns whether or not an object or its prototype chain has
     * a property with the specified name
     *
     * @func
     * @memberOf R
     * @category Object
     * @sig s -> {s: x} -> Boolean
     * @param {String} prop The name of the property to check for.
     * @param {Object} obj The object to query.
     * @return {Boolean} Whether the property exists.
     * @example
     *
     *      function Rectangle(width, height) {
     *        this.width = width;
     *        this.height = height;
     *      }
     *      Rectangle.prototype.area = function() {
     *        return this.width * this.height;
     *      };
     *
     *      var square = new Rectangle(2, 2);
     *      R.hasIn('width', square);  //=> true
     *      R.hasIn('area', square);  //=> true
     */
    var hasIn = _curry2(function hasIn(prop, obj) {
        return prop in obj;
    });

    /**
     * Returns true if its arguments are identical, false otherwise. Values are
     * identical if they reference the same memory. `NaN` is identical to `NaN`;
     * `0` and `-0` are not identical.
     *
     * @func
     * @memberOf R
     * @category Relation
     * @sig a -> a -> Boolean
     * @param {*} a
     * @param {*} b
     * @return {Boolean}
     * @example
     *
     *      var o = {};
     *      R.identical(o, o); //=> true
     *      R.identical(1, 1); //=> true
     *      R.identical(1, '1'); //=> false
     *      R.identical([], []); //=> false
     *      R.identical(0, -0); //=> false
     *      R.identical(NaN, NaN); //=> true
     */
    // SameValue algorithm
    // Steps 1-5, 7-10
    // Steps 6.b-6.e: +0 != -0
    // Step 6.a: NaN == NaN
    var identical = _curry2(function identical(a, b) {
        // SameValue algorithm
        if (a === b) {
            // Steps 1-5, 7-10
            // Steps 6.b-6.e: +0 != -0
            return a !== 0 || 1 / a === 1 / b;
        } else {
            // Step 6.a: NaN == NaN
            return a !== a && b !== b;
        }
    });

    /**
     * A function that does nothing but return the parameter supplied to it. Good as a default
     * or placeholder function.
     *
     * @func
     * @memberOf R
     * @category Function
     * @sig a -> a
     * @param {*} x The value to return.
     * @return {*} The input value, `x`.
     * @example
     *
     *      R.identity(1); //=> 1
     *
     *      var obj = {};
     *      R.identity(obj) === obj; //=> true
     */
    var identity = _curry1(_identity);

    /**
     * Creates a function that will process either the `onTrue` or the `onFalse` function depending
     * upon the result of the `condition` predicate.
     *
     * @func
     * @memberOf R
     * @category Logic
     * @sig (*... -> Boolean) -> (*... -> *) -> (*... -> *) -> (*... -> *)
     * @param {Function} condition A predicate function
     * @param {Function} onTrue A function to invoke when the `condition` evaluates to a truthy value.
     * @param {Function} onFalse A function to invoke when the `condition` evaluates to a falsy value.
     * @return {Function} A new unary function that will process either the `onTrue` or the `onFalse`
     *                    function depending upon the result of the `condition` predicate.
     * @example
     *
     *      // Flatten all arrays in the list but leave other values alone.
     *      var flattenArrays = R.map(R.ifElse(Array.isArray, R.flatten, R.identity));
     *
     *      flattenArrays([[0], [[10], [8]], 1234, {}]); //=> [[0], [10, 8], 1234, {}]
     *      flattenArrays([[[10], 123], [8, [10]], "hello"]); //=> [[10, 123], [8, 10], "hello"]
     */
    var ifElse = _curry3(function ifElse(condition, onTrue, onFalse) {
        return curryN(Math.max(condition.length, onTrue.length, onFalse.length), function _ifElse() {
            return condition.apply(this, arguments) ? onTrue.apply(this, arguments) : onFalse.apply(this, arguments);
        });
    });

    /**
     * Increments its argument.
     *
     * @func
     * @memberOf R
     * @category Math
     * @sig Number -> Number
     * @param {Number} n
     * @return {Number}
     * @see R.dec
     * @example
     *
     *      R.inc(42); //=> 43
     */
    var inc = add(1);

    /**
     * Inserts the supplied element into the list, at index `index`.  _Note
     * that this is not destructive_: it returns a copy of the list with the changes.
     * <small>No lists have been harmed in the application of this function.</small>
     *
     * @func
     * @memberOf R
     * @category List
     * @sig Number -> a -> [a] -> [a]
     * @param {Number} index The position to insert the element
     * @param {*} elt The element to insert into the Array
     * @param {Array} list The list to insert into
     * @return {Array} A new Array with `elt` inserted at `index`.
     * @example
     *
     *      R.insert(2, 'x', [1,2,3,4]); //=> [1,2,'x',3,4]
     */
    var insert = _curry3(function insert(idx, elt, list) {
        idx = idx < list.length && idx >= 0 ? idx : list.length;
        var result = _slice(list);
        result.splice(idx, 0, elt);
        return result;
    });

    /**
     * Inserts the sub-list into the list, at index `index`.  _Note  that this
     * is not destructive_: it returns a copy of the list with the changes.
     * <small>No lists have been harmed in the application of this function.</small>
     *
     * @func
     * @memberOf R
     * @category List
     * @sig Number -> [a] -> [a] -> [a]
     * @param {Number} index The position to insert the sub-list
     * @param {Array} elts The sub-list to insert into the Array
     * @param {Array} list The list to insert the sub-list into
     * @return {Array} A new Array with `elts` inserted starting at `index`.
     * @example
     *
     *      R.insertAll(2, ['x','y','z'], [1,2,3,4]); //=> [1,2,'x','y','z',3,4]
     */
    var insertAll = _curry3(function insertAll(idx, elts, list) {
        idx = idx < list.length && idx >= 0 ? idx : list.length;
        return _concat(_concat(_slice(list, 0, idx), elts), _slice(list, idx));
    });

    /**
     * See if an object (`val`) is an instance of the supplied constructor.
     * This function will check up the inheritance chain, if any.
     *
     * @func
     * @memberOf R
     * @category Type
     * @sig (* -> {*}) -> a -> Boolean
     * @param {Object} ctor A constructor
     * @param {*} val The value to test
     * @return {Boolean}
     * @example
     *
     *      R.is(Object, {}); //=> true
     *      R.is(Number, 1); //=> true
     *      R.is(Object, 1); //=> false
     *      R.is(String, 's'); //=> true
     *      R.is(String, new String('')); //=> true
     *      R.is(Object, new String('')); //=> true
     *      R.is(Object, 's'); //=> false
     *      R.is(Number, {}); //=> false
     */
    var is = _curry2(function is(Ctor, val) {
        return val != null && val.constructor === Ctor || val instanceof Ctor;
    });

    /**
     * Tests whether or not an object is similar to an array.
     *
     * @func
     * @memberOf R
     * @category Type
     * @category List
     * @sig * -> Boolean
     * @param {*} x The object to test.
     * @return {Boolean} `true` if `x` has a numeric length property and extreme indices defined; `false` otherwise.
     * @example
     *
     *      R.isArrayLike([]); //=> true
     *      R.isArrayLike(true); //=> false
     *      R.isArrayLike({}); //=> false
     *      R.isArrayLike({length: 10}); //=> false
     *      R.isArrayLike({0: 'zero', 9: 'nine', length: 10}); //=> true
     */
    var isArrayLike = _curry1(function isArrayLike(x) {
        if (_isArray(x)) {
            return true;
        }
        if (!x) {
            return false;
        }
        if (typeof x !== 'object') {
            return false;
        }
        if (x instanceof String) {
            return false;
        }
        if (x.nodeType === 1) {
            return !!x.length;
        }
        if (x.length === 0) {
            return true;
        }
        if (x.length > 0) {
            return x.hasOwnProperty(0) && x.hasOwnProperty(x.length - 1);
        }
        return false;
    });

    /**
     * Reports whether the list has zero elements.
     *
     * @func
     * @memberOf R
     * @category Logic
     * @sig [a] -> Boolean
     * @param {Array} list
     * @return {Boolean}
     * @example
     *
     *      R.isEmpty([1, 2, 3]);   //=> false
     *      R.isEmpty([]);          //=> true
     *      R.isEmpty('');          //=> true
     *      R.isEmpty(null);        //=> false
     *      R.isEmpty(R.keys({}));  //=> true
     *      R.isEmpty({});          //=> false ({} does not have a length property)
     *      R.isEmpty({length: 0}); //=> true
     */
    var isEmpty = _curry1(function isEmpty(list) {
        return Object(list).length === 0;
    });

    /**
     * Checks if the input value is `null` or `undefined`.
     *
     * @func
     * @memberOf R
     * @category Type
     * @sig * -> Boolean
     * @param {*} x The value to test.
     * @return {Boolean} `true` if `x` is `undefined` or `null`, otherwise `false`.
     * @example
     *
     *      R.isNil(null); //=> true
     *      R.isNil(undefined); //=> true
     *      R.isNil(0); //=> false
     *      R.isNil([]); //=> false
     */
    var isNil = _curry1(function isNil(x) {
        return x == null;
    });

    /**
     * Returns a list containing the names of all the enumerable own
     * properties of the supplied object.
     * Note that the order of the output array is not guaranteed to be
     * consistent across different JS platforms.
     *
     * @func
     * @memberOf R
     * @category Object
     * @sig {k: v} -> [k]
     * @param {Object} obj The object to extract properties from
     * @return {Array} An array of the object's own properties.
     * @example
     *
     *      R.keys({a: 1, b: 2, c: 3}); //=> ['a', 'b', 'c']
     */
    // cover IE < 9 keys issues
    var keys = function () {
        // cover IE < 9 keys issues
        var hasEnumBug = !{ toString: null }.propertyIsEnumerable('toString');
        var nonEnumerableProps = [
            'constructor',
            'valueOf',
            'isPrototypeOf',
            'toString',
            'propertyIsEnumerable',
            'hasOwnProperty',
            'toLocaleString'
        ];
        var contains = function contains(list, item) {
            var idx = 0;
            while (idx < list.length) {
                if (list[idx] === item) {
                    return true;
                }
                idx += 1;
            }
            return false;
        };
        return typeof Object.keys === 'function' ? _curry1(function keys(obj) {
            return Object(obj) !== obj ? [] : Object.keys(obj);
        }) : _curry1(function keys(obj) {
            if (Object(obj) !== obj) {
                return [];
            }
            var prop, ks = [], nIdx;
            for (prop in obj) {
                if (_has(prop, obj)) {
                    ks[ks.length] = prop;
                }
            }
            if (hasEnumBug) {
                nIdx = nonEnumerableProps.length - 1;
                while (nIdx >= 0) {
                    prop = nonEnumerableProps[nIdx];
                    if (_has(prop, obj) && !contains(ks, prop)) {
                        ks[ks.length] = prop;
                    }
                    nIdx -= 1;
                }
            }
            return ks;
        });
    }();

    /**
     * Returns a list containing the names of all the
     * properties of the supplied object, including prototype properties.
     * Note that the order of the output array is not guaranteed to be
     * consistent across different JS platforms.
     *
     * @func
     * @memberOf R
     * @category Object
     * @sig {k: v} -> [k]
     * @param {Object} obj The object to extract properties from
     * @return {Array} An array of the object's own and prototype properties.
     * @example
     *
     *      var F = function() { this.x = 'X'; };
     *      F.prototype.y = 'Y';
     *      var f = new F();
     *      R.keysIn(f); //=> ['x', 'y']
     */
    var keysIn = _curry1(function keysIn(obj) {
        var prop, ks = [];
        for (prop in obj) {
            ks[ks.length] = prop;
        }
        return ks;
    });

    /**
     * Returns the number of elements in the array by returning `list.length`.
     *
     * @func
     * @memberOf R
     * @category List
     * @sig [a] -> Number
     * @param {Array} list The array to inspect.
     * @return {Number} The length of the array.
     * @example
     *
     *      R.length([]); //=> 0
     *      R.length([1, 2, 3]); //=> 3
     */
    var length = _curry1(function length(list) {
        return list != null && is(Number, list.length) ? list.length : NaN;
    });

    /**
     * Returns `true` if the first argument is less than the second;
     * `false` otherwise.
     *
     * @func
     * @memberOf R
     * @category Relation
     * @sig Ord a => a -> a -> Boolean
     * @param {*} a
     * @param {*} b
     * @return {Boolean}
     * @see R.gt
     * @example
     *
     *      R.lt(2, 1); //=> false
     *      R.lt(2, 2); //=> false
     *      R.lt(2, 3); //=> true
     *      R.lt('a', 'z'); //=> true
     *      R.lt('z', 'a'); //=> false
     */
    var lt = _curry2(function lt(a, b) {
        return a < b;
    });

    /**
     * Returns `true` if the first argument is less than or equal to the second;
     * `false` otherwise.
     *
     * @func
     * @memberOf R
     * @category Relation
     * @sig Ord a => a -> a -> Boolean
     * @param {Number} a
     * @param {Number} b
     * @return {Boolean}
     * @see R.gte
     * @example
     *
     *      R.lte(2, 1); //=> false
     *      R.lte(2, 2); //=> true
     *      R.lte(2, 3); //=> true
     *      R.lte('a', 'z'); //=> true
     *      R.lte('z', 'a'); //=> false
     */
    var lte = _curry2(function lte(a, b) {
        return a <= b;
    });

    /**
     * The mapAccum function behaves like a combination of map and reduce; it applies a
     * function to each element of a list, passing an accumulating parameter from left to
     * right, and returning a final value of this accumulator together with the new list.
     *
     * The iterator function receives two arguments, *acc* and *value*, and should return
     * a tuple *[acc, value]*.
     *
     * @func
     * @memberOf R
     * @category List
     * @sig (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
     * @param {Function} fn The function to be called on every element of the input `list`.
     * @param {*} acc The accumulator value.
     * @param {Array} list The list to iterate over.
     * @return {*} The final, accumulated value.
     * @example
     *
     *      var digits = ['1', '2', '3', '4'];
     *      var append = function(a, b) {
     *        return [a + b, a + b];
     *      }
     *
     *      R.mapAccum(append, 0, digits); //=> ['01234', ['01', '012', '0123', '01234']]
     */
    var mapAccum = _curry3(function mapAccum(fn, acc, list) {
        var idx = 0, len = list.length, result = [], tuple = [acc];
        while (idx < len) {
            tuple = fn(tuple[0], list[idx]);
            result[idx] = tuple[1];
            idx += 1;
        }
        return [
            tuple[0],
            result
        ];
    });

    /**
     * The mapAccumRight function behaves like a combination of map and reduce; it applies a
     * function to each element of a list, passing an accumulating parameter from right
     * to left, and returning a final value of this accumulator together with the new list.
     *
     * Similar to `mapAccum`, except moves through the input list from the right to the
     * left.
     *
     * The iterator function receives two arguments, *acc* and *value*, and should return
     * a tuple *[acc, value]*.
     *
     * @func
     * @memberOf R
     * @category List
     * @sig (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
     * @param {Function} fn The function to be called on every element of the input `list`.
     * @param {*} acc The accumulator value.
     * @param {Array} list The list to iterate over.
     * @return {*} The final, accumulated value.
     * @example
     *
     *      var digits = ['1', '2', '3', '4'];
     *      var append = function(a, b) {
     *        return [a + b, a + b];
     *      }
     *
     *      R.mapAccumRight(append, 0, digits); //=> ['04321', ['04321', '0432', '043', '04']]
     */
    var mapAccumRight = _curry3(function mapAccumRight(fn, acc, list) {
        var idx = list.length - 1, result = [], tuple = [acc];
        while (idx >= 0) {
            tuple = fn(tuple[0], list[idx]);
            result[idx] = tuple[1];
            idx -= 1;
        }
        return [
            tuple[0],
            result
        ];
    });

    /**
     * Tests a regular expression against a String. Note that this function
     * will return an empty array when there are no matches. This differs
     * from [`String.prototype.match`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/match)
     * which returns `null` when there are no matches.
     *
     * @func
     * @memberOf R
     * @see R.test
     * @category String
     * @sig RegExp -> String -> [String | Undefined]
     * @param {RegExp} rx A regular expression.
     * @param {String} str The string to match against
     * @return {Array} The list of matches or empty array.
     * @example
     *
     *      R.match(/([a-z]a)/g, 'bananas'); //=> ['ba', 'na', 'na']
     *      R.match(/a/, 'b'); //=> []
     *      R.match(/a/, null); //=> TypeError: null does not have a method named "match"
     */
    var match = _curry2(function match(rx, str) {
        return str.match(rx) || [];
    });

    /**
     * mathMod behaves like the modulo operator should mathematically, unlike the `%`
     * operator (and by extension, R.modulo). So while "-17 % 5" is -2,
     * mathMod(-17, 5) is 3. mathMod requires Integer arguments, and returns NaN
     * when the modulus is zero or negative.
     *
     * @func
     * @memberOf R
     * @category Math
     * @sig Number -> Number -> Number
     * @param {Number} m The dividend.
     * @param {Number} p the modulus.
     * @return {Number} The result of `b mod a`.
     * @example
     *
     *      R.mathMod(-17, 5);  //=> 3
     *      R.mathMod(17, 5);   //=> 2
     *      R.mathMod(17, -5);  //=> NaN
     *      R.mathMod(17, 0);   //=> NaN
     *      R.mathMod(17.2, 5); //=> NaN
     *      R.mathMod(17, 5.3); //=> NaN
     *
     *      var clock = R.mathMod(R.__, 12);
     *      clock(15); //=> 3
     *      clock(24); //=> 0
     *
     *      var seventeenMod = R.mathMod(17);
     *      seventeenMod(3);  //=> 2
     *      seventeenMod(4);  //=> 1
     *      seventeenMod(10); //=> 7
     */
    var mathMod = _curry2(function mathMod(m, p) {
        if (!_isInteger(m)) {
            return NaN;
        }
        if (!_isInteger(p) || p < 1) {
            return NaN;
        }
        return (m % p + p) % p;
    });

    /**
     * Returns the larger of its two arguments.
     *
     * @func
     * @memberOf R
     * @category Relation
     * @sig Ord a => a -> a -> a
     * @param {*} a
     * @param {*} b
     * @return {*}
     * @see R.maxBy, R.min
     * @example
     *
     *      R.max(789, 123); //=> 789
     *      R.max('a', 'b'); //=> 'b'
     */
    var max = _curry2(function max(a, b) {
        return b > a ? b : a;
    });

    /**
     * Takes a function and two values, and returns whichever value produces
     * the larger result when passed to the provided function.
     *
     * @func
     * @memberOf R
     * @category Relation
     * @sig Ord b => (a -> b) -> a -> a -> a
     * @param {Function} f
     * @param {*} a
     * @param {*} b
     * @return {*}
     * @see R.max, R.minBy
     * @example
     *
     *      R.maxBy(function(n) { return n * n; }, -3, 2); //=> -3
     */
    var maxBy = _curry3(function maxBy(f, a, b) {
        return f(b) > f(a) ? b : a;
    });

    /**
     * Create a new object with the own properties of `a`
     * merged with the own properties of object `b`.
     *
     * @func
     * @memberOf R
     * @category Object
     * @sig {k: v} -> {k: v} -> {k: v}
     * @param {Object} a
     * @param {Object} b
     * @return {Object}
     * @example
     *
     *      R.merge({ 'name': 'fred', 'age': 10 }, { 'age': 40 });
     *      //=> { 'name': 'fred', 'age': 40 }
     *
     *      var resetToDefault = R.merge(R.__, {x: 0});
     *      resetToDefault({x: 5, y: 2}); //=> {x: 0, y: 2}
     */
    var merge = _curry2(function merge(a, b) {
        var result = {};
        var ks = keys(a);
        var idx = 0;
        while (idx < ks.length) {
            result[ks[idx]] = a[ks[idx]];
            idx += 1;
        }
        ks = keys(b);
        idx = 0;
        while (idx < ks.length) {
            result[ks[idx]] = b[ks[idx]];
            idx += 1;
        }
        return result;
    });

    /**
     * Returns the smaller of its two arguments.
     *
     * @func
     * @memberOf R
     * @category Relation
     * @sig Ord a => a -> a -> a
     * @param {*} a
     * @param {*} b
     * @return {*}
     * @see R.minBy, R.max
     * @example
     *
     *      R.min(789, 123); //=> 123
     *      R.min('a', 'b'); //=> 'a'
     */
    var min = _curry2(function min(a, b) {
        return b < a ? b : a;
    });

    /**
     * Takes a function and two values, and returns whichever value produces
     * the smaller result when passed to the provided function.
     *
     * @func
     * @memberOf R
     * @category Relation
     * @sig Ord b => (a -> b) -> a -> a -> a
     * @param {Function} f
     * @param {*} a
     * @param {*} b
     * @return {*}
     * @see R.min, R.maxBy
     * @example
     *
     *      R.minBy(function(n) { return n * n; }, -3, 2); //=> 2
     */
    var minBy = _curry3(function minBy(f, a, b) {
        return f(b) < f(a) ? b : a;
    });

    /**
     * Divides the second parameter by the first and returns the remainder.
     * Note that this functions preserves the JavaScript-style behavior for
     * modulo. For mathematical modulo see `mathMod`
     *
     * @func
     * @memberOf R
     * @category Math
     * @sig Number -> Number -> Number
     * @param {Number} a The value to the divide.
     * @param {Number} b The pseudo-modulus
     * @return {Number} The result of `b % a`.
     * @see R.mathMod
     * @example
     *
     *      R.modulo(17, 3); //=> 2
     *      // JS behavior:
     *      R.modulo(-17, 3); //=> -2
     *      R.modulo(17, -3); //=> 2
     *
     *      var isOdd = R.modulo(R.__, 2);
     *      isOdd(42); //=> 0
     *      isOdd(21); //=> 1
     */
    var modulo = _curry2(function modulo(a, b) {
        return a % b;
    });

    /**
     * Multiplies two numbers. Equivalent to `a * b` but curried.
     *
     * @func
     * @memberOf R
     * @category Math
     * @sig Number -> Number -> Number
     * @param {Number} a The first value.
     * @param {Number} b The second value.
     * @return {Number} The result of `a * b`.
     * @see R.divide
     * @example
     *
     *      var double = R.multiply(2);
     *      var triple = R.multiply(3);
     *      double(3);       //=>  6
     *      triple(4);       //=> 12
     *      R.multiply(2, 5);  //=> 10
     */
    var multiply = _curry2(function multiply(a, b) {
        return a * b;
    });

    /**
     * Wraps a function of any arity (including nullary) in a function that accepts exactly `n`
     * parameters. Any extraneous parameters will not be passed to the supplied function.
     *
     * @func
     * @memberOf R
     * @category Function
     * @sig Number -> (* -> a) -> (* -> a)
     * @param {Number} n The desired arity of the new function.
     * @param {Function} fn The function to wrap.
     * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of
     *         arity `n`.
     * @example
     *
     *      var takesTwoArgs = function(a, b) {
     *        return [a, b];
     *      };
     *      takesTwoArgs.length; //=> 2
     *      takesTwoArgs(1, 2); //=> [1, 2]
     *
     *      var takesOneArg = R.nAry(1, takesTwoArgs);
     *      takesOneArg.length; //=> 1
     *      // Only `n` arguments are passed to the wrapped function
     *      takesOneArg(1, 2); //=> [1, undefined]
     */
    var nAry = _curry2(function nAry(n, fn) {
        switch (n) {
        case 0:
            return function () {
                return fn.call(this);
            };
        case 1:
            return function (a0) {
                return fn.call(this, a0);
            };
        case 2:
            return function (a0, a1) {
                return fn.call(this, a0, a1);
            };
        case 3:
            return function (a0, a1, a2) {
                return fn.call(this, a0, a1, a2);
            };
        case 4:
            return function (a0, a1, a2, a3) {
                return fn.call(this, a0, a1, a2, a3);
            };
        case 5:
            return function (a0, a1, a2, a3, a4) {
                return fn.call(this, a0, a1, a2, a3, a4);
            };
        case 6:
            return function (a0, a1, a2, a3, a4, a5) {
                return fn.call(this, a0, a1, a2, a3, a4, a5);
            };
        case 7:
            return function (a0, a1, a2, a3, a4, a5, a6) {
                return fn.call(this, a0, a1, a2, a3, a4, a5, a6);
            };
        case 8:
            return function (a0, a1, a2, a3, a4, a5, a6, a7) {
                return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7);
            };
        case 9:
            return function (a0, a1, a2, a3, a4, a5, a6, a7, a8) {
                return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7, a8);
            };
        case 10:
            return function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
                return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
            };
        default:
            throw new Error('First argument to nAry must be a non-negative integer no greater than ten');
        }
    });

    /**
     * Negates its argument.
     *
     * @func
     * @memberOf R
     * @category Math
     * @sig Number -> Number
     * @param {Number} n
     * @return {Number}
     * @example
     *
     *      R.negate(42); //=> -42
     */
    var negate = _curry1(function negate(n) {
        return -n;
    });

    /**
     * A function that returns the `!` of its argument. It will return `true` when
     * passed false-y value, and `false` when passed a truth-y one.
     *
     * @func
     * @memberOf R
     * @category Logic
     * @sig * -> Boolean
     * @param {*} a any value
     * @return {Boolean} the logical inverse of passed argument.
     * @see R.complement
     * @example
     *
     *      R.not(true); //=> false
     *      R.not(false); //=> true
     *      R.not(0); => true
     *      R.not(1); => false
     */
    var not = _curry1(function not(a) {
        return !a;
    });

    /**
     * Returns the nth element of the given list or string.
     * If n is negative the element at index length + n is returned.
     *
     * @func
     * @memberOf R
     * @category List
     * @sig Number -> [a] -> a | Undefined
     * @sig Number -> String -> String
     * @param {Number} offset
     * @param {*} list
     * @return {*}
     * @example
     *
     *      var list = ['foo', 'bar', 'baz', 'quux'];
     *      R.nth(1, list); //=> 'bar'
     *      R.nth(-1, list); //=> 'quux'
     *      R.nth(-99, list); //=> undefined
     *
     *      R.nth('abc', 2); //=> 'c'
     *      R.nth('abc', 3); //=> ''
     */
    var nth = _curry2(function nth(offset, list) {
        var idx = offset < 0 ? list.length + offset : offset;
        return _isString(list) ? list.charAt(idx) : list[idx];
    });

    /**
     * Returns a function which returns its nth argument.
     *
     * @func
     * @memberOf R
     * @category Function
     * @sig Number -> *... -> *
     * @param {Number} n
     * @return {Function}
     * @example
     *
     *      R.nthArg(1)('a', 'b', 'c'); //=> 'b'
     *      R.nthArg(-1)('a', 'b', 'c'); //=> 'c'
     */
    var nthArg = _curry1(function nthArg(n) {
        return function () {
            return nth(n, arguments);
        };
    });

    /**
     * Returns the nth character of the given string.
     *
     * @func
     * @memberOf R
     * @category String
     * @sig Number -> String -> String
     * @param {Number} n
     * @param {String} str
     * @return {String}
     * @deprecated since v0.16.0
     * @example
     *
     *      R.nthChar(2, 'Ramda'); //=> 'm'
     *      R.nthChar(-2, 'Ramda'); //=> 'd'
     */
    var nthChar = _curry2(function nthChar(n, str) {
        return str.charAt(n < 0 ? str.length + n : n);
    });

    /**
     * Returns the character code of the nth character of the given string.
     *
     * @func
     * @memberOf R
     * @category String
     * @sig Number -> String -> Number
     * @param {Number} n
     * @param {String} str
     * @return {Number}
     * @deprecated since v0.16.0
     * @example
     *
     *      R.nthCharCode(2, 'Ramda'); //=> 'm'.charCodeAt(0)
     *      R.nthCharCode(-2, 'Ramda'); //=> 'd'.charCodeAt(0)
     */
    var nthCharCode = _curry2(function nthCharCode(n, str) {
        return str.charCodeAt(n < 0 ? str.length + n : n);
    });

    /**
     * Returns a singleton array containing the value provided.
     *
     * Note this `of` is different from the ES6 `of`; See
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/of
     *
     * @func
     * @memberOf R
     * @category Function
     * @sig a -> [a]
     * @param {*} x any value
     * @return {Array} An array wrapping `x`.
     * @example
     *
     *      R.of(null); //=> [null]
     *      R.of([42]); //=> [[42]]
     */
    var of = _curry1(function of(x) {
        return [x];
    });

    /**
     * Accepts a function `fn` and returns a function that guards invocation of `fn` such that
     * `fn` can only ever be called once, no matter how many times the returned function is
     * invoked.
     *
     * @func
     * @memberOf R
     * @category Function
     * @sig (a... -> b) -> (a... -> b)
     * @param {Function} fn The function to wrap in a call-only-once wrapper.
     * @return {Function} The wrapped function.
     * @example
     *
     *      var addOneOnce = R.once(function(x){ return x + 1; });
     *      addOneOnce(10); //=> 11
     *      addOneOnce(addOneOnce(50)); //=> 11
     */
    var once = _curry1(function once(fn) {
        var called = false, result;
        return function () {
            if (called) {
                return result;
            }
            called = true;
            result = fn.apply(this, arguments);
            return result;
        };
    });

    /**
     * Returns the result of "setting" the portion of the given data structure
     * focused by the given lens to the given value.
     *
     * @func
     * @memberOf R
     * @category Object
     * @typedef Lens s a = Functor f => (a -> f a) -> s -> f s
     * @sig Lens s a -> (a -> a) -> s -> s
     * @param {Lens} lens
     * @param {*} v
     * @param {*} x
     * @return {*}
     * @see R.prop, R.lensIndex, R.lensProp
     * @example
     *
     *      var headLens = R.lensIndex(0);
     *
     *      R.over(headLens, R.toUpper, ['foo', 'bar', 'baz']); //=> ['FOO', 'bar', 'baz']
     */
    var over = function () {
        var Identity = function (x) {
            return {
                value: x,
                map: function (f) {
                    return Identity(f(x));
                }
            };
        };
        return _curry3(function over(lens, f, x) {
            return lens(function (y) {
                return Identity(f(y));
            })(x).value;
        });
    }();

    /**
     * Retrieve the value at a given path.
     *
     * @func
     * @memberOf R
     * @category Object
     * @sig [String] -> {k: v} -> v | Undefined
     * @param {Array} path The path to use.
     * @return {*} The data at `path`.
     * @example
     *
     *      R.path(['a', 'b'], {a: {b: 2}}); //=> 2
     *      R.path(['a', 'b'], {c: {b: 2}}); //=> undefined
     */
    var path = _curry2(function path(paths, obj) {
        if (obj == null) {
            return;
        } else {
            var val = obj;
            for (var idx = 0, len = paths.length; idx < len && val != null; idx += 1) {
                val = val[paths[idx]];
            }
            return val;
        }
    });

    /**
     * Returns a partial copy of an object containing only the keys specified.  If the key does not exist, the
     * property is ignored.
     *
     * @func
     * @memberOf R
     * @category Object
     * @sig [k] -> {k: v} -> {k: v}
     * @param {Array} names an array of String property names to copy onto a new object
     * @param {Object} obj The object to copy from
     * @return {Object} A new object with only properties from `names` on it.
     * @see R.omit
     * @example
     *
     *      R.pick(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, d: 4}
     *      R.pick(['a', 'e', 'f'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1}
     */
    var pick = _curry2(function pick(names, obj) {
        var result = {};
        var idx = 0;
        while (idx < names.length) {
            if (names[idx] in obj) {
                result[names[idx]] = obj[names[idx]];
            }
            idx += 1;
        }
        return result;
    });

    /**
     * Similar to `pick` except that this one includes a `key: undefined` pair for properties that don't exist.
     *
     * @func
     * @memberOf R
     * @category Object
     * @sig [k] -> {k: v} -> {k: v}
     * @param {Array} names an array of String property names to copy onto a new object
     * @param {Object} obj The object to copy from
     * @return {Object} A new object with only properties from `names` on it.
     * @see R.pick
     * @example
     *
     *      R.pickAll(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, d: 4}
     *      R.pickAll(['a', 'e', 'f'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, e: undefined, f: undefined}
     */
    var pickAll = _curry2(function pickAll(names, obj) {
        var result = {};
        var idx = 0;
        var len = names.length;
        while (idx < len) {
            var name = names[idx];
            result[name] = obj[name];
            idx += 1;
        }
        return result;
    });

    /**
     * Returns a partial copy of an object containing only the keys that
     * satisfy the supplied predicate.
     *
     * @func
     * @memberOf R
     * @category Object
     * @sig (v, k -> Boolean) -> {k: v} -> {k: v}
     * @param {Function} pred A predicate to determine whether or not a key
     *        should be included on the output object.
     * @param {Object} obj The object to copy from
     * @return {Object} A new object with only properties that satisfy `pred`
     *         on it.
     * @see R.pick
     * @example
     *
     *      var isUpperCase = function(val, key) { return key.toUpperCase() === key; }
     *      R.pickBy(isUpperCase, {a: 1, b: 2, A: 3, B: 4}); //=> {A: 3, B: 4}
     */
    var pickBy = _curry2(function pickBy(test, obj) {
        var result = {};
        for (var prop in obj) {
            if (test(obj[prop], prop, obj)) {
                result[prop] = obj[prop];
            }
        }
        return result;
    });

    /**
     * Returns a new list with the given element at the front, followed by the contents of the
     * list.
     *
     * @func
     * @memberOf R
     * @category List
     * @sig a -> [a] -> [a]
     * @param {*} el The item to add to the head of the output list.
     * @param {Array} list The array to add to the tail of the output list.
     * @return {Array} A new array.
     * @see R.append
     * @example
     *
     *      R.prepend('fee', ['fi', 'fo', 'fum']); //=> ['fee', 'fi', 'fo', 'fum']
     */
    var prepend = _curry2(function prepend(el, list) {
        return _concat([el], list);
    });

    /**
     * Returns a function that when supplied an object returns the indicated property of that object, if it exists.
     *
     * @func
     * @memberOf R
     * @category Object
     * @sig s -> {s: a} -> a | Undefined
     * @param {String} p The property name
     * @param {Object} obj The object to query
     * @return {*} The value at `obj.p`.
     * @example
     *
     *      R.prop('x', {x: 100}); //=> 100
     *      R.prop('x', {}); //=> undefined
     */
    var prop = _curry2(function prop(p, obj) {
        return obj[p];
    });

    /**
     * If the given, non-null object has an own property with the specified name,
     * returns the value of that property.
     * Otherwise returns the provided default value.
     *
     * @func
     * @memberOf R
     * @category Object
     * @sig a -> String -> Object -> a
     * @param {*} val The default value.
     * @param {String} p The name of the property to return.
     * @param {Object} obj The object to query.
     * @return {*} The value of given property of the supplied object or the default value.
     * @example
     *
     *      var alice = {
     *        name: 'ALICE',
     *        age: 101
     *      };
     *      var favorite = R.prop('favoriteLibrary');
     *      var favoriteWithDefault = R.propOr('Ramda', 'favoriteLibrary');
     *
     *      favorite(alice);  //=> undefined
     *      favoriteWithDefault(alice);  //=> 'Ramda'
     */
    var propOr = _curry3(function propOr(val, p, obj) {
        return obj != null && _has(p, obj) ? obj[p] : val;
    });

    /**
     * Returns `true` if the specified object property satisfies the given
     * predicate; `false` otherwise.
     *
     * @func
     * @memberOf R
     * @category Logic
     * @sig (a -> Boolean) -> String -> {String: a} -> Boolean
     * @param {Function} pred
     * @param {String} name
     * @param {*} obj
     * @return {Boolean}
     * @see R.propEq
     * @see R.propIs
     * @example
     *
     *      R.propSatisfies(x => x > 0, 'x', {x: 1, y: 2}); //=> true
     */
    var propSatisfies = _curry3(function propSatisfies(pred, name, obj) {
        return pred(obj[name]);
    });

    /**
     * Acts as multiple `prop`: array of keys in, array of values out. Preserves order.
     *
     * @func
     * @memberOf R
     * @category Object
     * @sig [k] -> {k: v} -> [v]
     * @param {Array} ps The property names to fetch
     * @param {Object} obj The object to query
     * @return {Array} The corresponding values or partially applied function.
     * @example
     *
     *      R.props(['x', 'y'], {x: 1, y: 2}); //=> [1, 2]
     *      R.props(['c', 'a', 'b'], {b: 2, a: 1}); //=> [undefined, 1, 2]
     *
     *      var fullName = R.compose(R.join(' '), R.props(['first', 'last']));
     *      fullName({last: 'Bullet-Tooth', age: 33, first: 'Tony'}); //=> 'Tony Bullet-Tooth'
     */
    var props = _curry2(function props(ps, obj) {
        var len = ps.length;
        var out = [];
        var idx = 0;
        while (idx < len) {
            out[idx] = obj[ps[idx]];
            idx += 1;
        }
        return out;
    });

    /**
     * Returns a list of numbers from `from` (inclusive) to `to`
     * (exclusive).
     *
     * @func
     * @memberOf R
     * @category List
     * @sig Number -> Number -> [Number]
     * @param {Number} from The first number in the list.
     * @param {Number} to One more than the last number in the list.
     * @return {Array} The list of numbers in tthe set `[a, b)`.
     * @example
     *
     *      R.range(1, 5);    //=> [1, 2, 3, 4]
     *      R.range(50, 53);  //=> [50, 51, 52]
     */
    var range = _curry2(function range(from, to) {
        if (!(_isNumber(from) && _isNumber(to))) {
            throw new TypeError('Both arguments to range must be numbers');
        }
        var result = [];
        var n = from;
        while (n < to) {
            result.push(n);
            n += 1;
        }
        return result;
    });

    /**
     * Returns a single item by iterating through the list, successively calling the iterator
     * function and passing it an accumulator value and the current value from the array, and
     * then passing the result to the next call.
     *
     * Similar to `reduce`, except moves through the input list from the right to the left.
     *
     * The iterator function receives two values: *(acc, value)*
     *
     * Note: `R.reduceRight` does not skip deleted or unassigned indices (sparse arrays), unlike
     * the native `Array.prototype.reduce` method. For more details on this behavior, see:
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight#Description
     *
     * @func
     * @memberOf R
     * @category List
     * @sig (a,b -> a) -> a -> [b] -> a
     * @param {Function} fn The iterator function. Receives two values, the accumulator and the
     *        current element from the array.
     * @param {*} acc The accumulator value.
     * @param {Array} list The list to iterate over.
     * @return {*} The final, accumulated value.
     * @example
     *
     *      var pairs = [ ['a', 1], ['b', 2], ['c', 3] ];
     *      var flattenPairs = function(acc, pair) {
     *        return acc.concat(pair);
     *      };
     *
     *      R.reduceRight(flattenPairs, [], pairs); //=> [ 'c', 3, 'b', 2, 'a', 1 ]
     */
    var reduceRight = _curry3(function reduceRight(fn, acc, list) {
        var idx = list.length - 1;
        while (idx >= 0) {
            acc = fn(acc, list[idx]);
            idx -= 1;
        }
        return acc;
    });

    /**
     * Returns a value wrapped to indicate that it is the final value of the
     * reduce and transduce functions.  The returned value
     * should be considered a black box: the internal structure is not
     * guaranteed to be stable.
     *
     * Note: this optimization is unavailable to functions not explicitly listed
     * above.  For instance, it is not currently supported by reduceIndexed,
     * reduceRight, or reduceRightIndexed.
     *
     * @func
     * @memberOf R
     * @category List
     * @see R.reduce, R.transduce
     * @sig a -> *
     * @param {*} x The final value of the reduce.
     * @return {*} The wrapped value.
     * @example
     *
     *      R.reduce(
     *        R.pipe(R.add, R.ifElse(R.lte(10), R.reduced, R.identity)),
     *        0,
     *        [1, 2, 3, 4, 5]) // 10
     */
    var reduced = _curry1(_reduced);

    /**
     * Removes the sub-list of `list` starting at index `start` and containing
     * `count` elements.  _Note that this is not destructive_: it returns a
     * copy of the list with the changes.
     * <small>No lists have been harmed in the application of this function.</small>
     *
     * @func
     * @memberOf R
     * @category List
     * @sig Number -> Number -> [a] -> [a]
     * @param {Number} start The position to start removing elements
     * @param {Number} count The number of elements to remove
     * @param {Array} list The list to remove from
     * @return {Array} A new Array with `count` elements from `start` removed.
     * @example
     *
     *      R.remove(2, 3, [1,2,3,4,5,6,7,8]); //=> [1,2,6,7,8]
     */
    var remove = _curry3(function remove(start, count, list) {
        return _concat(_slice(list, 0, Math.min(start, list.length)), _slice(list, Math.min(list.length, start + count)));
    });

    /**
     * Replace a substring or regex match in a string with a replacement.
     *
     * @func
     * @memberOf R
     * @category String
     * @sig RegExp|String -> String -> String -> String
     * @param {RegExp|String} pattern A regular expression or a substring to match.
     * @param {String} replacement The string to replace the matches with.
     * @param {String} str The String to do the search and replacement in.
     * @return {String} The result.
     * @example
     *
     *      R.replace('foo', 'bar', 'foo foo foo'); //=> 'bar foo foo'
     *      R.replace(/foo/, 'bar', 'foo foo foo'); //=> 'bar foo foo'
     *
     *      // Use the "g" (global) flag to replace all occurrences:
     *      R.replace(/foo/g, 'bar', 'foo foo foo'); //=> 'bar bar bar'
     */
    var replace = _curry3(function replace(regex, replacement, str) {
        return str.replace(regex, replacement);
    });

    /**
     * Returns a new list with the same elements as the original list, just
     * in the reverse order.
     *
     * @func
     * @memberOf R
     * @category List
     * @sig [a] -> [a]
     * @param {Array} list The list to reverse.
     * @return {Array} A copy of the list in reverse order.
     * @example
     *
     *      R.reverse([1, 2, 3]);  //=> [3, 2, 1]
     *      R.reverse([1, 2]);     //=> [2, 1]
     *      R.reverse([1]);        //=> [1]
     *      R.reverse([]);         //=> []
     */
    var reverse = _curry1(function reverse(list) {
        return _slice(list).reverse();
    });

    /**
     * Scan is similar to reduce, but returns a list of successively reduced values from the left
     *
     * @func
     * @memberOf R
     * @category List
     * @sig (a,b -> a) -> a -> [b] -> [a]
     * @param {Function} fn The iterator function. Receives two values, the accumulator and the
     *        current element from the array
     * @param {*} acc The accumulator value.
     * @param {Array} list The list to iterate over.
     * @return {Array} A list of all intermediately reduced values.
     * @example
     *
     *      var numbers = [1, 2, 3, 4];
     *      var factorials = R.scan(R.multiply, 1, numbers); //=> [1, 1, 2, 6, 24]
     */
    var scan = _curry3(function scan(fn, acc, list) {
        var idx = 0, len = list.length, result = [acc];
        while (idx < len) {
            acc = fn(acc, list[idx]);
            result[idx + 1] = acc;
            idx += 1;
        }
        return result;
    });

    /**
     * Returns the result of "setting" the portion of the given data structure
     * focused by the given lens to the given value.
     *
     * @func
     * @memberOf R
     * @category Object
     * @typedef Lens s a = Functor f => (a -> f a) -> s -> f s
     * @sig Lens s a -> a -> s -> s
     * @param {Lens} lens
     * @param {*} v
     * @param {*} x
     * @return {*}
     * @see R.prop, R.lensIndex, R.lensProp
     * @example
     *
     *      var xLens = R.lensProp('x');
     *
     *      R.set(xLens, 4, {x: 1, y: 2});  //=> {x: 4, y: 2}
     *      R.set(xLens, 8, {x: 1, y: 2});  //=> {x: 8, y: 2}
     */
    var set = _curry3(function set(lens, v, x) {
        return over(lens, always(v), x);
    });

    /**
     * Returns a copy of the list, sorted according to the comparator function, which should accept two values at a
     * time and return a negative number if the first value is smaller, a positive number if it's larger, and zero
     * if they are equal.  Please note that this is a **copy** of the list.  It does not modify the original.
     *
     * @func
     * @memberOf R
     * @category List
     * @sig (a,a -> Number) -> [a] -> [a]
     * @param {Function} comparator A sorting function :: a -> b -> Int
     * @param {Array} list The list to sort
     * @return {Array} a new array with its elements sorted by the comparator function.
     * @example
     *
     *      var diff = function(a, b) { return a - b; };
     *      R.sort(diff, [4,2,7,5]); //=> [2, 4, 5, 7]
     */
    var sort = _curry2(function sort(comparator, list) {
        return _slice(list).sort(comparator);
    });

    /**
     * Sorts the list according to the supplied function.
     *
     * @func
     * @memberOf R
     * @category Relation
     * @sig Ord b => (a -> b) -> [a] -> [a]
     * @param {Function} fn
     * @param {Array} list The list to sort.
     * @return {Array} A new list sorted by the keys generated by `fn`.
     * @example
     *
     *      var sortByFirstItem = R.sortBy(prop(0));
     *      var sortByNameCaseInsensitive = R.sortBy(R.compose(R.toLower, R.prop('name')));
     *      var pairs = [[-1, 1], [-2, 2], [-3, 3]];
     *      sortByFirstItem(pairs); //=> [[-3, 3], [-2, 2], [-1, 1]]
     *      var alice = {
     *        name: 'ALICE',
     *        age: 101
     *      };
     *      var bob = {
     *        name: 'Bob',
     *        age: -10
     *      };
     *      var clara = {
     *        name: 'clara',
     *        age: 314.159
     *      };
     *      var people = [clara, bob, alice];
     *      sortByNameCaseInsensitive(people); //=> [alice, bob, clara]
     */
    var sortBy = _curry2(function sortBy(fn, list) {
        return _slice(list).sort(function (a, b) {
            var aa = fn(a);
            var bb = fn(b);
            return aa < bb ? -1 : aa > bb ? 1 : 0;
        });
    });

    /**
     * Subtracts two numbers. Equivalent to `a - b` but curried.
     *
     * @func
     * @memberOf R
     * @category Math
     * @sig Number -> Number -> Number
     * @param {Number} a The first value.
     * @param {Number} b The second value.
     * @return {Number} The result of `a - b`.
     * @see R.add
     * @example
     *
     *      R.subtract(10, 8); //=> 2
     *
     *      var minus5 = R.subtract(R.__, 5);
     *      minus5(17); //=> 12
     *
     *      var complementaryAngle = R.subtract(90);
     *      complementaryAngle(30); //=> 60
     *      complementaryAngle(72); //=> 18
     */
    var subtract = _curry2(function subtract(a, b) {
        return a - b;
    });

    /**
     * Returns a new list containing the last `n` elements of a given list, passing each value
     * to the supplied predicate function, and terminating when the predicate function returns
     * `false`. Excludes the element that caused the predicate function to fail. The predicate
     * function is passed one argument: *(value)*.
     *
     * @func
     * @memberOf R
     * @category List
     * @sig (a -> Boolean) -> [a] -> [a]
     * @param {Function} fn The function called per iteration.
     * @param {Array} list The collection to iterate over.
     * @return {Array} A new array.
     * @see R.dropLastWhile
     * @example
     *
     *      var isNotOne = function(x) {
     *        return !(x === 1);
     *      };
     *
     *      R.takeLastWhile(isNotOne, [1, 2, 3, 4]); //=> [2, 3, 4]
     */
    var takeLastWhile = _curry2(function takeLastWhile(fn, list) {
        var idx = list.length - 1;
        while (idx >= 0 && fn(list[idx])) {
            idx -= 1;
        }
        return _slice(list, idx + 1, Infinity);
    });

    /**
     * Runs the given function with the supplied object, then returns the object.
     *
     * @func
     * @memberOf R
     * @category Function
     * @sig (a -> *) -> a -> a
     * @param {Function} fn The function to call with `x`. The return value of `fn` will be thrown away.
     * @param {*} x
     * @return {*} `x`.
     * @example
     *
     *      var sayX = function(x) { console.log('x is ' + x); };
     *      R.tap(sayX, 100); //=> 100
     *      //-> 'x is 100'
     */
    var tap = _curry2(function tap(fn, x) {
        fn(x);
        return x;
    });

    /**
     * Determines whether a given string matches a given regular expression.
     *
     * @func
     * @memberOf R
     * @see R.match
     * @category String
     * @sig RegExp -> String -> Boolean
     * @param {RegExp} pattern
     * @param {String} str
     * @return {Boolean}
     * @example
     *
     *      R.test(/^x/, 'xyz'); //=> true
     *      R.test(/^y/, 'xyz'); //=> false
     */
    var test = _curry2(function test(pattern, str) {
        return _cloneRegExp(pattern).test(str);
    });

    /**
     * Calls an input function `n` times, returning an array containing the results of those
     * function calls.
     *
     * `fn` is passed one argument: The current value of `n`, which begins at `0` and is
     * gradually incremented to `n - 1`.
     *
     * @func
     * @memberOf R
     * @category List
     * @sig (i -> a) -> i -> [a]
     * @param {Function} fn The function to invoke. Passed one argument, the current value of `n`.
     * @param {Number} n A value between `0` and `n - 1`. Increments after each function call.
     * @return {Array} An array containing the return values of all calls to `fn`.
     * @example
     *
     *      R.times(R.identity, 5); //=> [0, 1, 2, 3, 4]
     */
    var times = _curry2(function times(fn, n) {
        var len = Number(n);
        var list = new Array(len);
        var idx = 0;
        while (idx < len) {
            list[idx] = fn(idx);
            idx += 1;
        }
        return list;
    });

    /**
     * Converts an object into an array of key, value arrays.
     * Only the object's own properties are used.
     * Note that the order of the output array is not guaranteed to be
     * consistent across different JS platforms.
     *
     * @func
     * @memberOf R
     * @category Object
     * @sig {String: *} -> [[String,*]]
     * @param {Object} obj The object to extract from
     * @return {Array} An array of key, value arrays from the object's own properties.
     * @see R.fromPairs
     * @example
     *
     *      R.toPairs({a: 1, b: 2, c: 3}); //=> [['a', 1], ['b', 2], ['c', 3]]
     */
    var toPairs = _curry1(function toPairs(obj) {
        var pairs = [];
        for (var prop in obj) {
            if (_has(prop, obj)) {
                pairs[pairs.length] = [
                    prop,
                    obj[prop]
                ];
            }
        }
        return pairs;
    });

    /**
     * Converts an object into an array of key, value arrays.
     * The object's own properties and prototype properties are used.
     * Note that the order of the output array is not guaranteed to be
     * consistent across different JS platforms.
     *
     * @func
     * @memberOf R
     * @category Object
     * @sig {String: *} -> [[String,*]]
     * @param {Object} obj The object to extract from
     * @return {Array} An array of key, value arrays from the object's own
     *         and prototype properties.
     * @example
     *
     *      var F = function() { this.x = 'X'; };
     *      F.prototype.y = 'Y';
     *      var f = new F();
     *      R.toPairsIn(f); //=> [['x','X'], ['y','Y']]
     */
    var toPairsIn = _curry1(function toPairsIn(obj) {
        var pairs = [];
        for (var prop in obj) {
            pairs[pairs.length] = [
                prop,
                obj[prop]
            ];
        }
        return pairs;
    });

    /**
     * Removes (strips) whitespace from both ends of the string.
     *
     * @func
     * @memberOf R
     * @category String
     * @sig String -> String
     * @param {String} str The string to trim.
     * @return {String} Trimmed version of `str`.
     * @example
     *
     *      R.trim('   xyz  '); //=> 'xyz'
     *      R.map(R.trim, R.split(',', 'x, y, z')); //=> ['x', 'y', 'z']
     */
    var trim = function () {
        var ws = '\t\n\x0B\f\r \xA0\u1680\u180E\u2000\u2001\u2002\u2003' + '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028' + '\u2029\uFEFF';
        var zeroWidth = '\u200B';
        var hasProtoTrim = typeof String.prototype.trim === 'function';
        if (!hasProtoTrim || (ws.trim() || !zeroWidth.trim())) {
            return _curry1(function trim(str) {
                var beginRx = new RegExp('^[' + ws + '][' + ws + ']*');
                var endRx = new RegExp('[' + ws + '][' + ws + ']*$');
                return str.replace(beginRx, '').replace(endRx, '');
            });
        } else {
            return _curry1(function trim(str) {
                return str.trim();
            });
        }
    }();

    /**
     * Gives a single-word string description of the (native) type of a value, returning such
     * answers as 'Object', 'Number', 'Array', or 'Null'.  Does not attempt to distinguish user
     * Object types any further, reporting them all as 'Object'.
     *
     * @func
     * @memberOf R
     * @category Type
     * @sig (* -> {*}) -> String
     * @param {*} val The value to test
     * @return {String}
     * @example
     *
     *      R.type({}); //=> "Object"
     *      R.type(1); //=> "Number"
     *      R.type(false); //=> "Boolean"
     *      R.type('s'); //=> "String"
     *      R.type(null); //=> "Null"
     *      R.type([]); //=> "Array"
     *      R.type(/[A-z]/); //=> "RegExp"
     */
    var type = _curry1(function type(val) {
        return val === null ? 'Null' : val === undefined ? 'Undefined' : Object.prototype.toString.call(val).slice(8, -1);
    });

    /**
     * Takes a function `fn`, which takes a single array argument, and returns
     * a function which:
     *
     *   - takes any number of positional arguments;
     *   - passes these arguments to `fn` as an array; and
     *   - returns the result.
     *
     * In other words, R.unapply derives a variadic function from a function
     * which takes an array. R.unapply is the inverse of R.apply.
     *
     * @func
     * @memberOf R
     * @category Function
     * @sig ([*...] -> a) -> (*... -> a)
     * @param {Function} fn
     * @return {Function}
     * @see R.apply
     * @example
     *
     *      R.unapply(JSON.stringify)(1, 2, 3); //=> '[1,2,3]'
     */
    var unapply = _curry1(function unapply(fn) {
        return function () {
            return fn(_slice(arguments));
        };
    });

    /**
     * Wraps a function of any arity (including nullary) in a function that accepts exactly 1
     * parameter. Any extraneous parameters will not be passed to the supplied function.
     *
     * @func
     * @memberOf R
     * @category Function
     * @sig (* -> b) -> (a -> b)
     * @param {Function} fn The function to wrap.
     * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of
     *         arity 1.
     * @example
     *
     *      var takesTwoArgs = function(a, b) {
     *        return [a, b];
     *      };
     *      takesTwoArgs.length; //=> 2
     *      takesTwoArgs(1, 2); //=> [1, 2]
     *
     *      var takesOneArg = R.unary(takesTwoArgs);
     *      takesOneArg.length; //=> 1
     *      // Only 1 argument is passed to the wrapped function
     *      takesOneArg(1, 2); //=> [1, undefined]
     */
    var unary = _curry1(function unary(fn) {
        return nAry(1, fn);
    });

    /**
     * Returns a function of arity `n` from a (manually) curried function.
     *
     * @func
     * @memberOf R
     * @category Function
     * @sig Number -> (a -> b) -> (a -> c)
     * @param {Number} length The arity for the returned function.
     * @param {Function} fn The function to uncurry.
     * @return {Function} A new function.
     * @see R.curry
     * @example
     *
     *      var addFour = function(a) {
     *        return function(b) {
     *          return function(c) {
     *            return function(d) {
     *              return a + b + c + d;
     *            };
     *          };
     *        };
     *      };
     *
     *      var uncurriedAddFour = R.uncurryN(4, addFour);
     *      curriedAddFour(1, 2, 3, 4); //=> 10
     */
    var uncurryN = _curry2(function uncurryN(depth, fn) {
        return curryN(depth, function () {
            var currentDepth = 1;
            var value = fn;
            var idx = 0;
            var endIdx;
            while (currentDepth <= depth && typeof value === 'function') {
                endIdx = currentDepth === depth ? arguments.length : idx + value.length;
                value = value.apply(this, _slice(arguments, idx, endIdx));
                currentDepth += 1;
                idx = endIdx;
            }
            return value;
        });
    });

    /**
     * Builds a list from a seed value. Accepts an iterator function, which returns either false
     * to stop iteration or an array of length 2 containing the value to add to the resulting
     * list and the seed to be used in the next call to the iterator function.
     *
     * The iterator function receives one argument: *(seed)*.
     *
     * @func
     * @memberOf R
     * @category List
     * @sig (a -> [b]) -> * -> [b]
     * @param {Function} fn The iterator function. receives one argument, `seed`, and returns
     *        either false to quit iteration or an array of length two to proceed. The element
     *        at index 0 of this array will be added to the resulting array, and the element
     *        at index 1 will be passed to the next call to `fn`.
     * @param {*} seed The seed value.
     * @return {Array} The final list.
     * @example
     *
     *      var f = function(n) { return n > 50 ? false : [-n, n + 10] };
     *      R.unfold(f, 10); //=> [-10, -20, -30, -40, -50]
     */
    var unfold = _curry2(function unfold(fn, seed) {
        var pair = fn(seed);
        var result = [];
        while (pair && pair.length) {
            result[result.length] = pair[0];
            pair = fn(pair[1]);
        }
        return result;
    });

    /**
     * Returns a new list containing only one copy of each element in the original list, based
     * upon the value returned by applying the supplied predicate to two list elements. Prefers
     * the first item if two items compare equal based on the predicate.
     *
     * @func
     * @memberOf R
     * @category List
     * @sig (a, a -> Boolean) -> [a] -> [a]
     * @param {Function} pred A predicate used to test whether two items are equal.
     * @param {Array} list The array to consider.
     * @return {Array} The list of unique items.
     * @example
     *
     *      var strEq = function(a, b) { return String(a) === String(b); };
     *      R.uniqWith(strEq)([1, '1', 2, 1]); //=> [1, 2]
     *      R.uniqWith(strEq)([{}, {}]);       //=> [{}]
     *      R.uniqWith(strEq)([1, '1', 1]);    //=> [1]
     *      R.uniqWith(strEq)(['1', 1, 1]);    //=> ['1']
     */
    var uniqWith = _curry2(function uniqWith(pred, list) {
        var idx = 0, len = list.length;
        var result = [], item;
        while (idx < len) {
            item = list[idx];
            if (!_containsWith(pred, item, result)) {
                result[result.length] = item;
            }
            idx += 1;
        }
        return result;
    });

    /**
     * Returns a new copy of the array with the element at the
     * provided index replaced with the given value.
     * @see R.adjust
     *
     * @func
     * @memberOf R
     * @category List
     * @sig Number -> a -> [a] -> [a]
     * @param {Number} idx The index to update.
     * @param {*} x The value to exist at the given index of the returned array.
     * @param {Array|Arguments} list The source array-like object to be updated.
     * @return {Array} A copy of `list` with the value at index `idx` replaced with `x`.
     * @example
     *
     *      R.update(1, 11, [0, 1, 2]);     //=> [0, 11, 2]
     *      R.update(1)(11)([0, 1, 2]);     //=> [0, 11, 2]
     */
    var update = _curry3(function update(idx, x, list) {
        return adjust(always(x), idx, list);
    });

    /**
     * Returns a list of all the enumerable own properties of the supplied object.
     * Note that the order of the output array is not guaranteed across
     * different JS platforms.
     *
     * @func
     * @memberOf R
     * @category Object
     * @sig {k: v} -> [v]
     * @param {Object} obj The object to extract values from
     * @return {Array} An array of the values of the object's own properties.
     * @example
     *
     *      R.values({a: 1, b: 2, c: 3}); //=> [1, 2, 3]
     */
    var values = _curry1(function values(obj) {
        var props = keys(obj);
        var len = props.length;
        var vals = [];
        var idx = 0;
        while (idx < len) {
            vals[idx] = obj[props[idx]];
            idx += 1;
        }
        return vals;
    });

    /**
     * Returns a list of all the properties, including prototype properties,
     * of the supplied object.
     * Note that the order of the output array is not guaranteed to be
     * consistent across different JS platforms.
     *
     * @func
     * @memberOf R
     * @category Object
     * @sig {k: v} -> [v]
     * @param {Object} obj The object to extract values from
     * @return {Array} An array of the values of the object's own and prototype properties.
     * @example
     *
     *      var F = function() { this.x = 'X'; };
     *      F.prototype.y = 'Y';
     *      var f = new F();
     *      R.valuesIn(f); //=> ['X', 'Y']
     */
    var valuesIn = _curry1(function valuesIn(obj) {
        var prop, vs = [];
        for (prop in obj) {
            vs[vs.length] = obj[prop];
        }
        return vs;
    });

    /**
     * Returns a "view" of the given data structure, determined by the given lens.
     * The lens's focus determines which portion of the data structure is visible.
     *
     * @func
     * @memberOf R
     * @category Object
     * @typedef Lens s a = Functor f => (a -> f a) -> s -> f s
     * @sig Lens s a -> s -> a
     * @param {Lens} lens
     * @param {*} x
     * @return {*}
     * @see R.prop, R.lensIndex, R.lensProp
     * @example
     *
     *      var xLens = R.lensProp('x');
     *
     *      R.view(xLens, {x: 1, y: 2});  //=> 1
     *      R.view(xLens, {x: 4, y: 2});  //=> 4
     */
    var view = function () {
        var Const = function (x) {
            return {
                value: x,
                map: function () {
                    return this;
                }
            };
        };
        return _curry2(function view(lens, x) {
            return lens(Const)(x).value;
        });
    }();

    /**
     * Takes a spec object and a test object; returns true if the test satisfies
     * the spec. Each of the spec's own properties must be a predicate function.
     * Each predicate is applied to the value of the corresponding property of
     * the test object. `where` returns true if all the predicates return true,
     * false otherwise.
     *
     * `where` is well suited to declaratively expressing constraints for other
     * functions such as `filter` and `find`.
     *
     * @func
     * @memberOf R
     * @category Object
     * @sig {String: (* -> Boolean)} -> {String: *} -> Boolean
     * @param {Object} spec
     * @param {Object} testObj
     * @return {Boolean}
     * @example
     *
     *      // pred :: Object -> Boolean
     *      var pred = R.where({
     *        a: R.equals('foo'),
     *        b: R.complement(R.equals('bar')),
     *        x: R.gt(_, 10),
     *        y: R.lt(_, 20)
     *      });
     *
     *      pred({a: 'foo', b: 'xxx', x: 11, y: 19}); //=> true
     *      pred({a: 'xxx', b: 'xxx', x: 11, y: 19}); //=> false
     *      pred({a: 'foo', b: 'bar', x: 11, y: 19}); //=> false
     *      pred({a: 'foo', b: 'xxx', x: 10, y: 19}); //=> false
     *      pred({a: 'foo', b: 'xxx', x: 11, y: 20}); //=> false
     */
    var where = _curry2(function where(spec, testObj) {
        for (var prop in spec) {
            if (_has(prop, spec) && !spec[prop](testObj[prop])) {
                return false;
            }
        }
        return true;
    });

    /**
     * Wrap a function inside another to allow you to make adjustments to the parameters, or do
     * other processing either before the internal function is called or with its results.
     *
     * @func
     * @memberOf R
     * @category Function
     * @sig (a... -> b) -> ((a... -> b) -> a... -> c) -> (a... -> c)
     * @param {Function} fn The function to wrap.
     * @param {Function} wrapper The wrapper function.
     * @return {Function} The wrapped function.
     * @example
     *
     *      var greet = function(name) {return 'Hello ' + name;};
     *
     *      var shoutedGreet = R.wrap(greet, function(gr, name) {
     *        return gr(name).toUpperCase();
     *      });
     *      shoutedGreet("Kathy"); //=> "HELLO KATHY"
     *
     *      var shortenedGreet = R.wrap(greet, function(gr, name) {
     *        return gr(name.substring(0, 3));
     *      });
     *      shortenedGreet("Robert"); //=> "Hello Rob"
     */
    var wrap = _curry2(function wrap(fn, wrapper) {
        return curryN(fn.length, function () {
            return wrapper.apply(this, _concat([fn], arguments));
        });
    });

    /**
     * Creates a new list out of the two supplied by creating each possible
     * pair from the lists.
     *
     * @func
     * @memberOf R
     * @category List
     * @sig [a] -> [b] -> [[a,b]]
     * @param {Array} as The first list.
     * @param {Array} bs The second list.
     * @return {Array} The list made by combining each possible pair from
     *         `as` and `bs` into pairs (`[a, b]`).
     * @example
     *
     *      R.xprod([1, 2], ['a', 'b']); //=> [[1, 'a'], [1, 'b'], [2, 'a'], [2, 'b']]
     */
    // = xprodWith(prepend); (takes about 3 times as long...)
    var xprod = _curry2(function xprod(a, b) {
        // = xprodWith(prepend); (takes about 3 times as long...)
        var idx = 0;
        var ilen = a.length;
        var j;
        var jlen = b.length;
        var result = [];
        while (idx < ilen) {
            j = 0;
            while (j < jlen) {
                result[result.length] = [
                    a[idx],
                    b[j]
                ];
                j += 1;
            }
            idx += 1;
        }
        return result;
    });

    /**
     * Creates a new list out of the two supplied by pairing up
     * equally-positioned items from both lists.  The returned list is
     * truncated to the length of the shorter of the two input lists.
     * Note: `zip` is equivalent to `zipWith(function(a, b) { return [a, b] })`.
     *
     * @func
     * @memberOf R
     * @category List
     * @sig [a] -> [b] -> [[a,b]]
     * @param {Array} list1 The first array to consider.
     * @param {Array} list2 The second array to consider.
     * @return {Array} The list made by pairing up same-indexed elements of `list1` and `list2`.
     * @example
     *
     *      R.zip([1, 2, 3], ['a', 'b', 'c']); //=> [[1, 'a'], [2, 'b'], [3, 'c']]
     */
    var zip = _curry2(function zip(a, b) {
        var rv = [];
        var idx = 0;
        var len = Math.min(a.length, b.length);
        while (idx < len) {
            rv[idx] = [
                a[idx],
                b[idx]
            ];
            idx += 1;
        }
        return rv;
    });

    /**
     * Creates a new object out of a list of keys and a list of values.
     *
     * @func
     * @memberOf R
     * @category List
     * @sig [String] -> [*] -> {String: *}
     * @param {Array} keys The array that will be properties on the output object.
     * @param {Array} values The list of values on the output object.
     * @return {Object} The object made by pairing up same-indexed elements of `keys` and `values`.
     * @example
     *
     *      R.zipObj(['a', 'b', 'c'], [1, 2, 3]); //=> {a: 1, b: 2, c: 3}
     */
    var zipObj = _curry2(function zipObj(keys, values) {
        var idx = 0, len = keys.length, out = {};
        while (idx < len) {
            out[keys[idx]] = values[idx];
            idx += 1;
        }
        return out;
    });

    /**
     * Creates a new list out of the two supplied by applying the function to
     * each equally-positioned pair in the lists. The returned list is
     * truncated to the length of the shorter of the two input lists.
     *
     * @function
     * @memberOf R
     * @category List
     * @sig (a,b -> c) -> [a] -> [b] -> [c]
     * @param {Function} fn The function used to combine the two elements into one value.
     * @param {Array} list1 The first array to consider.
     * @param {Array} list2 The second array to consider.
     * @return {Array} The list made by combining same-indexed elements of `list1` and `list2`
     *         using `fn`.
     * @example
     *
     *      var f = function(x, y) {
     *        // ...
     *      };
     *      R.zipWith(f, [1, 2, 3], ['a', 'b', 'c']);
     *      //=> [f(1, 'a'), f(2, 'b'), f(3, 'c')]
     */
    var zipWith = _curry3(function zipWith(fn, a, b) {
        var rv = [], idx = 0, len = Math.min(a.length, b.length);
        while (idx < len) {
            rv[idx] = fn(a[idx], b[idx]);
            idx += 1;
        }
        return rv;
    });

    /**
     * A function that always returns `false`. Any passed in parameters are ignored.
     *
     * @func
     * @memberOf R
     * @category Function
     * @sig * -> false
     * @return {Boolean} false
     * @see R.always, R.T
     * @example
     *
     *      R.F(); //=> false
     */
    var F = always(false);

    /**
     * A function that always returns `true`. Any passed in parameters are ignored.
     *
     * @func
     * @memberOf R
     * @category Function
     * @sig * -> true
     * @return {Boolean} `true`.
     * @see R.always, R.F
     * @example
     *
     *      R.T(); //=> true
     */
    var T = always(true);

    /**
     * Similar to hasMethod, this checks whether a function has a [methodname]
     * function. If it isn't an array it will execute that function otherwise it will
     * default to the ramda implementation.
     *
     * @private
     * @param {Function} fn ramda implemtation
     * @param {String} methodname property to check for a custom implementation
     * @return {Object} Whatever the return value of the method is.
     */
    var _checkForMethod = function _checkForMethod(methodname, fn) {
        return function () {
            var length = arguments.length;
            if (length === 0) {
                return fn();
            }
            var obj = arguments[length - 1];
            return _isArray(obj) || typeof obj[methodname] !== 'function' ? fn.apply(this, arguments) : obj[methodname].apply(obj, _slice(arguments, 0, length - 1));
        };
    };

    /**
     * Copies an object.
     *
     * @private
     * @param {*} value The value to be copied
     * @param {Array} refFrom Array containing the source references
     * @param {Array} refTo Array containing the copied source references
     * @return {*} The copied value.
     */
    var _clone = function _clone(value, refFrom, refTo) {
        var copy = function copy(copiedValue) {
            var len = refFrom.length;
            var idx = 0;
            while (idx < len) {
                if (value === refFrom[idx]) {
                    return refTo[idx];
                }
                idx += 1;
            }
            refFrom[idx + 1] = value;
            refTo[idx + 1] = copiedValue;
            for (var key in value) {
                copiedValue[key] = _clone(value[key], refFrom, refTo);
            }
            return copiedValue;
        };
        switch (type(value)) {
        case 'Object':
            return copy({});
        case 'Array':
            return copy([]);
        case 'Date':
            return new Date(value);
        case 'RegExp':
            return _cloneRegExp(value);
        default:
            return value;
        }
    };

    var _createPartialApplicator = function _createPartialApplicator(concat) {
        return function (fn) {
            var args = _slice(arguments, 1);
            return _arity(Math.max(0, fn.length - args.length), function () {
                return fn.apply(this, concat(args, arguments));
            });
        };
    };

    /**
     * Returns a function that dispatches with different strategies based on the
     * object in list position (last argument). If it is an array, executes [fn].
     * Otherwise, if it has a  function with [methodname], it will execute that
     * function (functor case). Otherwise, if it is a transformer, uses transducer
     * [xf] to return a new transformer (transducer case). Otherwise, it will
     * default to executing [fn].
     *
     * @private
     * @param {String} methodname property to check for a custom implementation
     * @param {Function} xf transducer to initialize if object is transformer
     * @param {Function} fn default ramda implementation
     * @return {Function} A function that dispatches on object in list position
     */
    var _dispatchable = function _dispatchable(methodname, xf, fn) {
        return function () {
            var length = arguments.length;
            if (length === 0) {
                return fn();
            }
            var obj = arguments[length - 1];
            if (!_isArray(obj)) {
                var args = _slice(arguments, 0, length - 1);
                if (typeof obj[methodname] === 'function') {
                    return obj[methodname].apply(obj, args);
                }
                if (_isTransformer(obj)) {
                    var transducer = xf.apply(null, args);
                    return transducer(obj);
                }
            }
            return fn.apply(this, arguments);
        };
    };

    // The algorithm used to handle cyclic structures is
    // inspired by underscore's isEqual
    // RegExp equality algorithm: http://stackoverflow.com/a/10776635
    var _equals = function _equals(a, b, stackA, stackB) {
        var typeA = type(a);
        if (typeA !== type(b)) {
            return false;
        }
        if (typeA === 'Boolean' || typeA === 'Number' || typeA === 'String') {
            return typeof a === 'object' ? typeof b === 'object' && identical(a.valueOf(), b.valueOf()) : identical(a, b);
        }
        if (identical(a, b)) {
            return true;
        }
        if (typeA === 'RegExp') {
            // RegExp equality algorithm: http://stackoverflow.com/a/10776635
            return a.source === b.source && a.global === b.global && a.ignoreCase === b.ignoreCase && a.multiline === b.multiline && a.sticky === b.sticky && a.unicode === b.unicode;
        }
        if (Object(a) === a) {
            if (typeA === 'Date' && a.getTime() !== b.getTime()) {
                return false;
            }
            var keysA = keys(a);
            if (keysA.length !== keys(b).length) {
                return false;
            }
            var idx = stackA.length - 1;
            while (idx >= 0) {
                if (stackA[idx] === a) {
                    return stackB[idx] === b;
                }
                idx -= 1;
            }
            stackA[stackA.length] = a;
            stackB[stackB.length] = b;
            idx = keysA.length - 1;
            while (idx >= 0) {
                var key = keysA[idx];
                if (!_has(key, b) || !_equals(b[key], a[key], stackA, stackB)) {
                    return false;
                }
                idx -= 1;
            }
            stackA.pop();
            stackB.pop();
            return true;
        }
        return false;
    };

    /**
     * Private function that determines whether or not a provided object has a given method.
     * Does not ignore methods stored on the object's prototype chain. Used for dynamically
     * dispatching Ramda methods to non-Array objects.
     *
     * @private
     * @param {String} methodName The name of the method to check for.
     * @param {Object} obj The object to test.
     * @return {Boolean} `true` has a given method, `false` otherwise.
     * @example
     *
     *      var person = { name: 'John' };
     *      person.shout = function() { alert(this.name); };
     *
     *      _hasMethod('shout', person); //=> true
     *      _hasMethod('foo', person); //=> false
     */
    var _hasMethod = function _hasMethod(methodName, obj) {
        return obj != null && !_isArray(obj) && typeof obj[methodName] === 'function';
    };

    /**
     * `_makeFlat` is a helper function that returns a one-level or fully recursive function
     * based on the flag passed in.
     *
     * @private
     */
    var _makeFlat = function _makeFlat(recursive) {
        return function flatt(list) {
            var value, result = [], idx = 0, j, ilen = list.length, jlen;
            while (idx < ilen) {
                if (isArrayLike(list[idx])) {
                    value = recursive ? flatt(list[idx]) : list[idx];
                    j = 0;
                    jlen = value.length;
                    while (j < jlen) {
                        result[result.length] = value[j];
                        j += 1;
                    }
                } else {
                    result[result.length] = list[idx];
                }
                idx += 1;
            }
            return result;
        };
    };

    var _reduce = function () {
        function _arrayReduce(xf, acc, list) {
            var idx = 0, len = list.length;
            while (idx < len) {
                acc = xf['@@transducer/step'](acc, list[idx]);
                if (acc && acc['@@transducer/reduced']) {
                    acc = acc['@@transducer/value'];
                    break;
                }
                idx += 1;
            }
            return xf['@@transducer/result'](acc);
        }
        function _iterableReduce(xf, acc, iter) {
            var step = iter.next();
            while (!step.done) {
                acc = xf['@@transducer/step'](acc, step.value);
                if (acc && acc['@@transducer/reduced']) {
                    acc = acc['@@transducer/value'];
                    break;
                }
                step = iter.next();
            }
            return xf['@@transducer/result'](acc);
        }
        function _methodReduce(xf, acc, obj) {
            return xf['@@transducer/result'](obj.reduce(bind(xf['@@transducer/step'], xf), acc));
        }
        var symIterator = typeof Symbol !== 'undefined' ? Symbol.iterator : '@@iterator';
        return function _reduce(fn, acc, list) {
            if (typeof fn === 'function') {
                fn = _xwrap(fn);
            }
            if (isArrayLike(list)) {
                return _arrayReduce(fn, acc, list);
            }
            if (typeof list.reduce === 'function') {
                return _methodReduce(fn, acc, list);
            }
            if (list[symIterator] != null) {
                return _iterableReduce(fn, acc, list[symIterator]());
            }
            if (typeof list.next === 'function') {
                return _iterableReduce(fn, acc, list);
            }
            throw new TypeError('reduce: list must be array or iterable');
        };
    }();

    var _stepCat = function () {
        var _stepCatArray = {
            '@@transducer/init': Array,
            '@@transducer/step': function (xs, x) {
                return _concat(xs, [x]);
            },
            '@@transducer/result': _identity
        };
        var _stepCatString = {
            '@@transducer/init': String,
            '@@transducer/step': function (a, b) {
                return a + b;
            },
            '@@transducer/result': _identity
        };
        var _stepCatObject = {
            '@@transducer/init': Object,
            '@@transducer/step': function (result, input) {
                return merge(result, isArrayLike(input) ? createMapEntry(input[0], input[1]) : input);
            },
            '@@transducer/result': _identity
        };
        return function _stepCat(obj) {
            if (_isTransformer(obj)) {
                return obj;
            }
            if (isArrayLike(obj)) {
                return _stepCatArray;
            }
            if (typeof obj === 'string') {
                return _stepCatString;
            }
            if (typeof obj === 'object') {
                return _stepCatObject;
            }
            throw new Error('Cannot create transformer for ' + obj);
        };
    }();

    var _xall = function () {
        function XAll(f, xf) {
            this.xf = xf;
            this.f = f;
            this.all = true;
        }
        XAll.prototype['@@transducer/init'] = _xfBase.init;
        XAll.prototype['@@transducer/result'] = function (result) {
            if (this.all) {
                result = this.xf['@@transducer/step'](result, true);
            }
            return this.xf['@@transducer/result'](result);
        };
        XAll.prototype['@@transducer/step'] = function (result, input) {
            if (!this.f(input)) {
                this.all = false;
                result = _reduced(this.xf['@@transducer/step'](result, false));
            }
            return result;
        };
        return _curry2(function _xall(f, xf) {
            return new XAll(f, xf);
        });
    }();

    var _xany = function () {
        function XAny(f, xf) {
            this.xf = xf;
            this.f = f;
            this.any = false;
        }
        XAny.prototype['@@transducer/init'] = _xfBase.init;
        XAny.prototype['@@transducer/result'] = function (result) {
            if (!this.any) {
                result = this.xf['@@transducer/step'](result, false);
            }
            return this.xf['@@transducer/result'](result);
        };
        XAny.prototype['@@transducer/step'] = function (result, input) {
            if (this.f(input)) {
                this.any = true;
                result = _reduced(this.xf['@@transducer/step'](result, true));
            }
            return result;
        };
        return _curry2(function _xany(f, xf) {
            return new XAny(f, xf);
        });
    }();

    var _xdrop = function () {
        function XDrop(n, xf) {
            this.xf = xf;
            this.n = n;
        }
        XDrop.prototype['@@transducer/init'] = _xfBase.init;
        XDrop.prototype['@@transducer/result'] = _xfBase.result;
        XDrop.prototype['@@transducer/step'] = function (result, input) {
            if (this.n > 0) {
                this.n -= 1;
                return result;
            }
            return this.xf['@@transducer/step'](result, input);
        };
        return _curry2(function _xdrop(n, xf) {
            return new XDrop(n, xf);
        });
    }();

    var _xdropWhile = function () {
        function XDropWhile(f, xf) {
            this.xf = xf;
            this.f = f;
        }
        XDropWhile.prototype['@@transducer/init'] = _xfBase.init;
        XDropWhile.prototype['@@transducer/result'] = _xfBase.result;
        XDropWhile.prototype['@@transducer/step'] = function (result, input) {
            if (this.f) {
                if (this.f(input)) {
                    return result;
                }
                this.f = null;
            }
            return this.xf['@@transducer/step'](result, input);
        };
        return _curry2(function _xdropWhile(f, xf) {
            return new XDropWhile(f, xf);
        });
    }();

    var _xgroupBy = function () {
        function XGroupBy(f, xf) {
            this.xf = xf;
            this.f = f;
            this.inputs = {};
        }
        XGroupBy.prototype['@@transducer/init'] = _xfBase.init;
        XGroupBy.prototype['@@transducer/result'] = function (result) {
            var key;
            for (key in this.inputs) {
                if (_has(key, this.inputs)) {
                    result = this.xf['@@transducer/step'](result, this.inputs[key]);
                    if (result['@@transducer/reduced']) {
                        result = result['@@transducer/value'];
                        break;
                    }
                }
            }
            return this.xf['@@transducer/result'](result);
        };
        XGroupBy.prototype['@@transducer/step'] = function (result, input) {
            var key = this.f(input);
            this.inputs[key] = this.inputs[key] || [
                key,
                []
            ];
            this.inputs[key][1] = append(input, this.inputs[key][1]);
            return result;
        };
        return _curry2(function _xgroupBy(f, xf) {
            return new XGroupBy(f, xf);
        });
    }();

    /**
     * Creates a new list iteration function from an existing one by adding two new parameters
     * to its callback function: the current index, and the entire list.
     *
     * This would turn, for instance, Ramda's simple `map` function into one that more closely
     * resembles `Array.prototype.map`.  Note that this will only work for functions in which
     * the iteration callback function is the first parameter, and where the list is the last
     * parameter.  (This latter might be unimportant if the list parameter is not used.)
     *
     * @func
     * @memberOf R
     * @category Function
     * @category List
     * @sig ((a ... -> b) ... -> [a] -> *) -> (a ..., Int, [a] -> b) ... -> [a] -> *)
     * @param {Function} fn A list iteration function that does not pass index or list to its callback
     * @return {Function} An altered list iteration function that passes (item, index, list) to its callback
     * @example
     *
     *      var mapIndexed = R.addIndex(R.map);
     *      mapIndexed(function(val, idx) {return idx + '-' + val;}, ['f', 'o', 'o', 'b', 'a', 'r']);
     *      //=> ['0-f', '1-o', '2-o', '3-b', '4-a', '5-r']
     */
    var addIndex = _curry1(function addIndex(fn) {
        return curryN(fn.length, function () {
            var idx = 0;
            var origFn = arguments[0];
            var list = arguments[arguments.length - 1];
            var args = _slice(arguments);
            args[0] = function () {
                var result = origFn.apply(this, _concat(arguments, [
                    idx,
                    list
                ]));
                idx += 1;
                return result;
            };
            return fn.apply(this, args);
        });
    });

    /**
     * Returns `true` if all elements of the list match the predicate, `false` if there are any
     * that don't.
     *
     * Acts as a transducer if a transformer is given in list position.
     * @see R.transduce
     *
     * @func
     * @memberOf R
     * @category List
     * @sig (a -> Boolean) -> [a] -> Boolean
     * @param {Function} fn The predicate function.
     * @param {Array} list The array to consider.
     * @return {Boolean} `true` if the predicate is satisfied by every element, `false`
     *         otherwise.
     * @see R.any, R.none
     * @example
     *
     *      var lessThan2 = R.flip(R.lt)(2);
     *      var lessThan3 = R.flip(R.lt)(3);
     *      R.all(lessThan2)([1, 2]); //=> false
     *      R.all(lessThan3)([1, 2]); //=> true
     */
    var all = _curry2(_dispatchable('all', _xall, function all(fn, list) {
        var idx = 0;
        while (idx < list.length) {
            if (!fn(list[idx])) {
                return false;
            }
            idx += 1;
        }
        return true;
    }));

    /**
     * A function that returns the first argument if it's falsy otherwise the second
     * argument. Note that this is NOT short-circuited, meaning that if expressions
     * are passed they are both evaluated.
     *
     * Dispatches to the `and` method of the first argument if applicable.
     *
     * @func
     * @memberOf R
     * @category Logic
     * @sig * -> * -> *
     * @param {*} a any value
     * @param {*} b any other value
     * @return {*} the first argument if falsy otherwise the second argument.
     * @see R.both
     * @example
     *
     *      R.and(false, true); //=> false
     *      R.and(0, []); //=> 0
     *      R.and(null, ''); => null
     */
    var and = _curry2(function and(a, b) {
        return _hasMethod('and', a) ? a.and(b) : a && b;
    });

    /**
     * Returns `true` if at least one of elements of the list match the predicate, `false`
     * otherwise.
     *
     * Acts as a transducer if a transformer is given in list position.
     * @see R.transduce
     *
     * @func
     * @memberOf R
     * @category List
     * @sig (a -> Boolean) -> [a] -> Boolean
     * @param {Function} fn The predicate function.
     * @param {Array} list The array to consider.
     * @return {Boolean} `true` if the predicate is satisfied by at least one element, `false`
     *         otherwise.
     * @see R.all, R.none
     * @example
     *
     *      var lessThan0 = R.flip(R.lt)(0);
     *      var lessThan2 = R.flip(R.lt)(2);
     *      R.any(lessThan0)([1, 2]); //=> false
     *      R.any(lessThan2)([1, 2]); //=> true
     */
    var any = _curry2(_dispatchable('any', _xany, function any(fn, list) {
        var idx = 0;
        while (idx < list.length) {
            if (fn(list[idx])) {
                return true;
            }
            idx += 1;
        }
        return false;
    }));

    /**
     * Wraps a function of any arity (including nullary) in a function that accepts exactly 2
     * parameters. Any extraneous parameters will not be passed to the supplied function.
     *
     * @func
     * @memberOf R
     * @category Function
     * @sig (* -> c) -> (a, b -> c)
     * @param {Function} fn The function to wrap.
     * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of
     *         arity 2.
     * @example
     *
     *      var takesThreeArgs = function(a, b, c) {
     *        return [a, b, c];
     *      };
     *      takesThreeArgs.length; //=> 3
     *      takesThreeArgs(1, 2, 3); //=> [1, 2, 3]
     *
     *      var takesTwoArgs = R.binary(takesThreeArgs);
     *      takesTwoArgs.length; //=> 2
     *      // Only 2 arguments are passed to the wrapped function
     *      takesTwoArgs(1, 2, 3); //=> [1, 2, undefined]
     */
    var binary = _curry1(function binary(fn) {
        return nAry(2, fn);
    });

    /**
     * Creates a deep copy of the value which may contain (nested) `Array`s and
     * `Object`s, `Number`s, `String`s, `Boolean`s and `Date`s. `Function`s are
     * not copied, but assigned by their reference.
     *
     * @func
     * @memberOf R
     * @category Object
     * @sig {*} -> {*}
     * @param {*} value The object or array to clone
     * @return {*} A new object or array.
     * @example
     *
     *      var objects = [{}, {}, {}];
     *      var objectsClone = R.clone(objects);
     *      objects[0] === objectsClone[0]; //=> false
     */
    var clone = _curry1(function clone(value) {
        return _clone(value, [], []);
    });

    /**
     * Returns a new list consisting of the elements of the first list followed by the elements
     * of the second.
     *
     * @func
     * @memberOf R
     * @category List
     * @sig [a] -> [a] -> [a]
     * @param {Array} list1 The first list to merge.
     * @param {Array} list2 The second set to merge.
     * @return {Array} A new array consisting of the contents of `list1` followed by the
     *         contents of `list2`. If, instead of an Array for `list1`, you pass an
     *         object with a `concat` method on it, `concat` will call `list1.concat`
     *         and pass it the value of `list2`.
     *
     * @example
     *
     *      R.concat([], []); //=> []
     *      R.concat([4, 5, 6], [1, 2, 3]); //=> [4, 5, 6, 1, 2, 3]
     *      R.concat('ABC', 'DEF'); // 'ABCDEF'
     */
    var concat = _curry2(function concat(set1, set2) {
        if (_isArray(set2)) {
            return _concat(set1, set2);
        } else if (_hasMethod('concat', set1)) {
            return set1.concat(set2);
        } else {
            throw new TypeError('can\'t concat ' + typeof set1);
        }
    });

    /**
     * Returns a curried equivalent of the provided function. The curried
     * function has two unusual capabilities. First, its arguments needn't
     * be provided one at a time. If `f` is a ternary function and `g` is
     * `R.curry(f)`, the following are equivalent:
     *
     *   - `g(1)(2)(3)`
     *   - `g(1)(2, 3)`
     *   - `g(1, 2)(3)`
     *   - `g(1, 2, 3)`
     *
     * Secondly, the special placeholder value `R.__` may be used to specify
     * "gaps", allowing partial application of any combination of arguments,
     * regardless of their positions. If `g` is as above and `_` is `R.__`,
     * the following are equivalent:
     *
     *   - `g(1, 2, 3)`
     *   - `g(_, 2, 3)(1)`
     *   - `g(_, _, 3)(1)(2)`
     *   - `g(_, _, 3)(1, 2)`
     *   - `g(_, 2)(1)(3)`
     *   - `g(_, 2)(1, 3)`
     *   - `g(_, 2)(_, 3)(1)`
     *
     * @func
     * @memberOf R
     * @category Function
     * @sig (* -> a) -> (* -> a)
     * @param {Function} fn The function to curry.
     * @return {Function} A new, curried function.
     * @see R.curryN
     * @example
     *
     *      var addFourNumbers = function(a, b, c, d) {
     *        return a + b + c + d;
     *      };
     *
     *      var curriedAddFourNumbers = R.curry(addFourNumbers);
     *      var f = curriedAddFourNumbers(1, 2);
     *      var g = f(3);
     *      g(4); //=> 10
     */
    var curry = _curry1(function curry(fn) {
        return curryN(fn.length, fn);
    });

    /**
     * Returns a new list containing the last `n` elements of a given list, passing each value
     * to the supplied predicate function, skipping elements while the predicate function returns
     * `true`. The predicate function is passed one argument: *(value)*.
     *
     * Acts as a transducer if a transformer is given in list position.
     * @see R.transduce
     *
     * @func
     * @memberOf R
     * @category List
     * @sig (a -> Boolean) -> [a] -> [a]
     * @param {Function} fn The function called per iteration.
     * @param {Array} list The collection to iterate over.
     * @return {Array} A new array.
     * @see R.takeWhile
     * @example
     *
     *      var lteTwo = function(x) {
     *        return x <= 2;
     *      };
     *
     *      R.dropWhile(lteTwo, [1, 2, 3, 4, 3, 2, 1]); //=> [3, 4, 3, 2, 1]
     */
    var dropWhile = _curry2(_dispatchable('dropWhile', _xdropWhile, function dropWhile(pred, list) {
        var idx = 0, len = list.length;
        while (idx < len && pred(list[idx])) {
            idx += 1;
        }
        return _slice(list, idx);
    }));

    /**
     * Returns `true` if its arguments are equivalent, `false` otherwise.
     * Dispatches to an `equals` method if present. Handles cyclical data
     * structures.
     *
     * @func
     * @memberOf R
     * @category Relation
     * @sig a -> b -> Boolean
     * @param {*} a
     * @param {*} b
     * @return {Boolean}
     * @example
     *
     *      R.equals(1, 1); //=> true
     *      R.equals(1, '1'); //=> false
     *      R.equals([1, 2, 3], [1, 2, 3]); //=> true
     *
     *      var a = {}; a.v = a;
     *      var b = {}; b.v = b;
     *      R.equals(a, b); //=> true
     */
    var equals = _curry2(function equals(a, b) {
        return _hasMethod('equals', a) ? a.equals(b) : _hasMethod('equals', b) ? b.equals(a) : _equals(a, b, [], []);
    });

    /**
     * Returns a new list containing only those items that match a given predicate function.
     * The predicate function is passed one argument: *(value)*.
     *
     * Note that `R.filter` does not skip deleted or unassigned indices, unlike the native
     * `Array.prototype.filter` method. For more details on this behavior, see:
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter#Description
     *
     * Acts as a transducer if a transformer is given in list position.
     * @see R.transduce
     *
     * @func
     * @memberOf R
     * @category List
     * @sig (a -> Boolean) -> [a] -> [a]
     * @param {Function} fn The function called per iteration.
     * @param {Array} list The collection to iterate over.
     * @return {Array} The new filtered array.
     * @see R.reject
     * @example
     *
     *      var isEven = function(n) {
     *        return n % 2 === 0;
     *      };
     *      R.filter(isEven, [1, 2, 3, 4]); //=> [2, 4]
     */
    var filter = _curry2(_dispatchable('filter', _xfilter, _filter));

    /**
     * Returns the first element of the list which matches the predicate, or `undefined` if no
     * element matches.
     *
     * Acts as a transducer if a transformer is given in list position.
     * @see R.transduce
     *
     * @func
     * @memberOf R
     * @category List
     * @sig (a -> Boolean) -> [a] -> a | undefined
     * @param {Function} fn The predicate function used to determine if the element is the
     *        desired one.
     * @param {Array} list The array to consider.
     * @return {Object} The element found, or `undefined`.
     * @example
     *
     *      var xs = [{a: 1}, {a: 2}, {a: 3}];
     *      R.find(R.propEq('a', 2))(xs); //=> {a: 2}
     *      R.find(R.propEq('a', 4))(xs); //=> undefined
     */
    var find = _curry2(_dispatchable('find', _xfind, function find(fn, list) {
        var idx = 0;
        var len = list.length;
        while (idx < len) {
            if (fn(list[idx])) {
                return list[idx];
            }
            idx += 1;
        }
    }));

    /**
     * Returns the index of the first element of the list which matches the predicate, or `-1`
     * if no element matches.
     *
     * Acts as a transducer if a transformer is given in list position.
     * @see R.transduce
     *
     * @func
     * @memberOf R
     * @category List
     * @sig (a -> Boolean) -> [a] -> Number
     * @param {Function} fn The predicate function used to determine if the element is the
     * desired one.
     * @param {Array} list The array to consider.
     * @return {Number} The index of the element found, or `-1`.
     * @example
     *
     *      var xs = [{a: 1}, {a: 2}, {a: 3}];
     *      R.findIndex(R.propEq('a', 2))(xs); //=> 1
     *      R.findIndex(R.propEq('a', 4))(xs); //=> -1
     */
    var findIndex = _curry2(_dispatchable('findIndex', _xfindIndex, function findIndex(fn, list) {
        var idx = 0;
        var len = list.length;
        while (idx < len) {
            if (fn(list[idx])) {
                return idx;
            }
            idx += 1;
        }
        return -1;
    }));

    /**
     * Returns the last element of the list which matches the predicate, or `undefined` if no
     * element matches.
     *
     * Acts as a transducer if a transformer is given in list position.
     * @see R.transduce
     *
     * @func
     * @memberOf R
     * @category List
     * @sig (a -> Boolean) -> [a] -> a | undefined
     * @param {Function} fn The predicate function used to determine if the element is the
     * desired one.
     * @param {Array} list The array to consider.
     * @return {Object} The element found, or `undefined`.
     * @example
     *
     *      var xs = [{a: 1, b: 0}, {a:1, b: 1}];
     *      R.findLast(R.propEq('a', 1))(xs); //=> {a: 1, b: 1}
     *      R.findLast(R.propEq('a', 4))(xs); //=> undefined
     */
    var findLast = _curry2(_dispatchable('findLast', _xfindLast, function findLast(fn, list) {
        var idx = list.length - 1;
        while (idx >= 0) {
            if (fn(list[idx])) {
                return list[idx];
            }
            idx -= 1;
        }
    }));

    /**
     * Returns the index of the last element of the list which matches the predicate, or
     * `-1` if no element matches.
     *
     * Acts as a transducer if a transformer is given in list position.
     * @see R.transduce
     *
     * @func
     * @memberOf R
     * @category List
     * @sig (a -> Boolean) -> [a] -> Number
     * @param {Function} fn The predicate function used to determine if the element is the
     * desired one.
     * @param {Array} list The array to consider.
     * @return {Number} The index of the element found, or `-1`.
     * @example
     *
     *      var xs = [{a: 1, b: 0}, {a:1, b: 1}];
     *      R.findLastIndex(R.propEq('a', 1))(xs); //=> 1
     *      R.findLastIndex(R.propEq('a', 4))(xs); //=> -1
     */
    var findLastIndex = _curry2(_dispatchable('findLastIndex', _xfindLastIndex, function findLastIndex(fn, list) {
        var idx = list.length - 1;
        while (idx >= 0) {
            if (fn(list[idx])) {
                return idx;
            }
            idx -= 1;
        }
        return -1;
    }));

    /**
     * Returns a new list by pulling every item out of it (and all its sub-arrays) and putting
     * them in a new array, depth-first.
     *
     * @func
     * @memberOf R
     * @category List
     * @sig [a] -> [b]
     * @param {Array} list The array to consider.
     * @return {Array} The flattened list.
     * @see R.unnest
     * @example
     *
     *      R.flatten([1, 2, [3, 4], 5, [6, [7, 8, [9, [10, 11], 12]]]]);
     *      //=> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
     */
    var flatten = _curry1(_makeFlat(true));

    /**
     * Returns a new function much like the supplied one, except that the first two arguments'
     * order is reversed.
     *
     * @func
     * @memberOf R
     * @category Function
     * @sig (a -> b -> c -> ... -> z) -> (b -> a -> c -> ... -> z)
     * @param {Function} fn The function to invoke with its first two parameters reversed.
     * @return {*} The result of invoking `fn` with its first two parameters' order reversed.
     * @example
     *
     *      var mergeThree = function(a, b, c) {
     *        return ([]).concat(a, b, c);
     *      };
     *
     *      mergeThree(1, 2, 3); //=> [1, 2, 3]
     *
     *      R.flip(mergeThree)(1, 2, 3); //=> [2, 1, 3]
     */
    var flip = _curry1(function flip(fn) {
        return curry(function (a, b) {
            var args = _slice(arguments);
            args[0] = b;
            args[1] = a;
            return fn.apply(this, args);
        });
    });

    /**
     * Iterate over an input `list`, calling a provided function `fn` for each element in the
     * list.
     *
     * `fn` receives one argument: *(value)*.
     *
     * Note: `R.forEach` does not skip deleted or unassigned indices (sparse arrays), unlike
     * the native `Array.prototype.forEach` method. For more details on this behavior, see:
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach#Description
     *
     * Also note that, unlike `Array.prototype.forEach`, Ramda's `forEach` returns the original
     * array. In some libraries this function is named `each`.
     *
     * @func
     * @memberOf R
     * @category List
     * @sig (a -> *) -> [a] -> [a]
     * @param {Function} fn The function to invoke. Receives one argument, `value`.
     * @param {Array} list The list to iterate over.
     * @return {Array} The original list.
     * @example
     *
     *      var printXPlusFive = function(x) { console.log(x + 5); };
     *      R.forEach(printXPlusFive, [1, 2, 3]); //=> [1, 2, 3]
     *      //-> 6
     *      //-> 7
     *      //-> 8
     */
    var forEach = _curry2(_checkForMethod('forEach', function forEach(fn, list) {
        var len = list.length;
        var idx = 0;
        while (idx < len) {
            fn(list[idx]);
            idx += 1;
        }
        return list;
    }));

    /**
     * Returns a list of function names of object's own functions
     *
     * @func
     * @memberOf R
     * @category Object
     * @sig {*} -> [String]
     * @param {Object} obj The objects with functions in it
     * @return {Array} A list of the object's own properties that map to functions.
     * @example
     *
     *      R.functions(R); // returns list of ramda's own function names
     *
     *      var F = function() { this.x = function(){}; this.y = 1; }
     *      F.prototype.z = function() {};
     *      F.prototype.a = 100;
     *      R.functions(new F()); //=> ["x"]
     */
    var functions = _curry1(_functionsWith(keys));

    /**
     * Returns a list of function names of object's own and prototype functions
     *
     * @func
     * @memberOf R
     * @category Object
     * @sig {*} -> [String]
     * @param {Object} obj The objects with functions in it
     * @return {Array} A list of the object's own properties and prototype
     *         properties that map to functions.
     * @example
     *
     *      R.functionsIn(R); // returns list of ramda's own and prototype function names
     *
     *      var F = function() { this.x = function(){}; this.y = 1; }
     *      F.prototype.z = function() {};
     *      F.prototype.a = 100;
     *      R.functionsIn(new F()); //=> ["x", "z"]
     */
    var functionsIn = _curry1(_functionsWith(keysIn));

    /**
     * Splits a list into sub-lists stored in an object, based on the result of calling a String-returning function
     * on each element, and grouping the results according to values returned.
     *
     * Acts as a transducer if a transformer is given in list position.
     * @see R.transduce
     *
     * @func
     * @memberOf R
     * @category List
     * @sig (a -> String) -> [a] -> {String: [a]}
     * @param {Function} fn Function :: a -> String
     * @param {Array} list The array to group
     * @return {Object} An object with the output of `fn` for keys, mapped to arrays of elements
     *         that produced that key when passed to `fn`.
     * @example
     *
     *      var byGrade = R.groupBy(function(student) {
     *        var score = student.score;
     *        return score < 65 ? 'F' :
     *               score < 70 ? 'D' :
     *               score < 80 ? 'C' :
     *               score < 90 ? 'B' : 'A';
     *      });
     *      var students = [{name: 'Abby', score: 84},
     *                      {name: 'Eddy', score: 58},
     *                      // ...
     *                      {name: 'Jack', score: 69}];
     *      byGrade(students);
     *      // {
     *      //   'A': [{name: 'Dianne', score: 99}],
     *      //   'B': [{name: 'Abby', score: 84}]
     *      //   // ...,
     *      //   'F': [{name: 'Eddy', score: 58}]
     *      // }
     */
    var groupBy = _curry2(_dispatchable('groupBy', _xgroupBy, function groupBy(fn, list) {
        return _reduce(function (acc, elt) {
            var key = fn(elt);
            acc[key] = append(elt, acc[key] || (acc[key] = []));
            return acc;
        }, {}, list);
    }));

    /**
     * Returns the first element of the given list or string. In some libraries
     * this function is named `first`.
     *
     * @func
     * @memberOf R
     * @category List
     * @see R.tail, R.init, R.last
     * @sig [a] -> a | Undefined
     * @sig String -> String
     * @param {*} list
     * @return {*}
     * @example
     *
     *      R.head(['fi', 'fo', 'fum']); //=> 'fi'
     *      R.head([]); //=> undefined
     *
     *      R.head('abc'); //=> 'a'
     *      R.head(''); //=> ''
     */
    var head = nth(0);

    /**
     * Combines two lists into a set (i.e. no duplicates) composed of those
     * elements common to both lists.  Duplication is determined according
     * to the value returned by applying the supplied predicate to two list
     * elements.
     *
     * @func
     * @memberOf R
     * @category Relation
     * @sig (a,a -> Boolean) -> [a] -> [a] -> [a]
     * @param {Function} pred A predicate function that determines whether
     *        the two supplied elements are equal.
     * @param {Array} list1 One list of items to compare
     * @param {Array} list2 A second list of items to compare
     * @see R.intersection
     * @return {Array} A new list containing those elements common to both lists.
     * @example
     *
     *      var buffaloSpringfield = [
     *        {id: 824, name: 'Richie Furay'},
     *        {id: 956, name: 'Dewey Martin'},
     *        {id: 313, name: 'Bruce Palmer'},
     *        {id: 456, name: 'Stephen Stills'},
     *        {id: 177, name: 'Neil Young'}
     *      ];
     *      var csny = [
     *        {id: 204, name: 'David Crosby'},
     *        {id: 456, name: 'Stephen Stills'},
     *        {id: 539, name: 'Graham Nash'},
     *        {id: 177, name: 'Neil Young'}
     *      ];
     *
     *      var sameId = function(o1, o2) {return o1.id === o2.id;};
     *
     *      R.intersectionWith(sameId, buffaloSpringfield, csny);
     *      //=> [{id: 456, name: 'Stephen Stills'}, {id: 177, name: 'Neil Young'}]
     */
    var intersectionWith = _curry3(function intersectionWith(pred, list1, list2) {
        var results = [], idx = 0;
        while (idx < list1.length) {
            if (_containsWith(pred, list1[idx], list2)) {
                results[results.length] = list1[idx];
            }
            idx += 1;
        }
        return uniqWith(pred, results);
    });

    /**
     * Creates a new list with the separator interposed between elements.
     *
     * @func
     * @memberOf R
     * @category List
     * @sig a -> [a] -> [a]
     * @param {*} separator The element to add to the list.
     * @param {Array} list The list to be interposed.
     * @return {Array} The new list.
     * @example
     *
     *      R.intersperse('n', ['ba', 'a', 'a']); //=> ['ba', 'n', 'a', 'n', 'a']
     */
    var intersperse = _curry2(_checkForMethod('intersperse', function intersperse(separator, list) {
        var out = [];
        var idx = 0;
        var length = list.length;
        while (idx < length) {
            if (idx === length - 1) {
                out.push(list[idx]);
            } else {
                out.push(list[idx], separator);
            }
            idx += 1;
        }
        return out;
    }));

    /**
     * Transforms the items of the list with the transducer and appends the transformed items to
     * the accumulator using an appropriate iterator function based on the accumulator type.
     *
     * The accumulator can be an array, string, object or a transformer. Iterated items will
     * be appended to arrays and concatenated to strings. Objects will be merged directly or 2-item
     * arrays will be merged as key, value pairs.
     *
     * The accumulator can also be a transformer object that provides a 2-arity reducing iterator
     * function, step, 0-arity initial value function, init, and 1-arity result extraction function
     * result. The step function is used as the iterator function in reduce. The result function is
     * used to convert the final accumulator into the return type and in most cases is R.identity.
     * The init function is used to provide the initial accumulator.
     *
     * The iteration is performed with R.reduce after initializing the transducer.
     *
     * @func
     * @memberOf R
     * @category List
     * @sig a -> (b -> b) -> [c] -> a
     * @param {*} acc The initial accumulator value.
     * @param {Function} xf The transducer function. Receives a transformer and returns a transformer.
     * @param {Array} list The list to iterate over.
     * @return {*} The final, accumulated value.
     * @example
     *
     *      var numbers = [1, 2, 3, 4];
     *      var transducer = R.compose(R.map(R.add(1)), R.take(2));
     *
     *      R.into([], transducer, numbers); //=> [2, 3]
     *
     *      var intoArray = R.into([]);
     *      intoArray(transducer, numbers); //=> [2, 3]
     */
    var into = _curry3(function into(acc, xf, list) {
        return _isTransformer(acc) ? _reduce(xf(acc), acc['@@transducer/init'](), list) : _reduce(xf(_stepCat(acc)), acc, list);
    });

    /**
     * Same as R.invertObj, however this accounts for objects
     * with duplicate values by putting the values into an
     * array.
     *
     * @func
     * @memberOf R
     * @category Object
     * @sig {s: x} -> {x: [ s, ... ]}
     * @param {Object} obj The object or array to invert
     * @return {Object} out A new object with keys
     * in an array.
     * @example
     *
     *      var raceResultsByFirstName = {
     *        first: 'alice',
     *        second: 'jake',
     *        third: 'alice',
     *      };
     *      R.invert(raceResultsByFirstName);
     *      //=> { 'alice': ['first', 'third'], 'jake':['second'] }
     */
    var invert = _curry1(function invert(obj) {
        var props = keys(obj);
        var len = props.length;
        var idx = 0;
        var out = {};
        while (idx < len) {
            var key = props[idx];
            var val = obj[key];
            var list = _has(val, out) ? out[val] : out[val] = [];
            list[list.length] = key;
            idx += 1;
        }
        return out;
    });

    /**
     * Returns a new object with the keys of the given object
     * as values, and the values of the given object as keys.
     *
     * @func
     * @memberOf R
     * @category Object
     * @sig {s: x} -> {x: s}
     * @param {Object} obj The object or array to invert
     * @return {Object} out A new object
     * @example
     *
     *      var raceResults = {
     *        first: 'alice',
     *        second: 'jake'
     *      };
     *      R.invertObj(raceResults);
     *      //=> { 'alice': 'first', 'jake':'second' }
     *
     *      // Alternatively:
     *      var raceResults = ['alice', 'jake'];
     *      R.invertObj(raceResults);
     *      //=> { 'alice': '0', 'jake':'1' }
     */
    var invertObj = _curry1(function invertObj(obj) {
        var props = keys(obj);
        var len = props.length;
        var idx = 0;
        var out = {};
        while (idx < len) {
            var key = props[idx];
            out[obj[key]] = key;
            idx += 1;
        }
        return out;
    });

    /**
     * Returns the last element of the given list or string.
     *
     * @func
     * @memberOf R
     * @category List
     * @see R.init, R.head, R.tail
     * @sig [a] -> a | Undefined
     * @sig String -> String
     * @param {*} list
     * @return {*}
     * @example
     *
     *      R.last(['fi', 'fo', 'fum']); //=> 'fum'
     *      R.last([]); //=> undefined
     *
     *      R.last('abc'); //=> 'c'
     *      R.last(''); //=> ''
     */
    var last = nth(-1);

    /**
     * Returns the position of the last occurrence of an item in
     * an array, or -1 if the item is not included in the array.
     * `R.equals` is used to determine equality.
     *
     * @func
     * @memberOf R
     * @category List
     * @sig a -> [a] -> Number
     * @param {*} target The item to find.
     * @param {Array} xs The array to search in.
     * @return {Number} the index of the target, or -1 if the target is not found.
     * @see R.indexOf
     * @example
     *
     *      R.lastIndexOf(3, [-1,3,3,0,1,2,3,4]); //=> 6
     *      R.lastIndexOf(10, [1,2,3,4]); //=> -1
     */
    var lastIndexOf = _curry2(function lastIndexOf(target, xs) {
        if (_hasMethod('lastIndexOf', xs)) {
            return xs.lastIndexOf(target);
        } else {
            var idx = xs.length - 1;
            while (idx >= 0) {
                if (equals(xs[idx], target)) {
                    return idx;
                }
                idx -= 1;
            }
            return -1;
        }
    });

    /**
     * Returns a new list, constructed by applying the supplied function to every element of the
     * supplied list.
     *
     * Note: `R.map` does not skip deleted or unassigned indices (sparse arrays), unlike the
     * native `Array.prototype.map` method. For more details on this behavior, see:
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map#Description
     *
     * Acts as a transducer if a transformer is given in list position.
     * @see R.transduce
     *
     * @func
     * @memberOf R
     * @category List
     * @sig (a -> b) -> [a] -> [b]
     * @param {Function} fn The function to be called on every element of the input `list`.
     * @param {Array} list The list to be iterated over.
     * @return {Array} The new list.
     * @example
     *
     *      var double = function(x) {
     *        return x * 2;
     *      };
     *
     *      R.map(double, [1, 2, 3]); //=> [2, 4, 6]
     */
    var map = _curry2(_dispatchable('map', _xmap, _map));

    /**
     * Map, but for objects. Creates an object with the same keys as `obj` and values
     * generated by running each property of `obj` through `fn`. `fn` is passed one argument:
     * *(value)*.
     *
     * @func
     * @memberOf R
     * @category Object
     * @sig (v -> v) -> {k: v} -> {k: v}
     * @param {Function} fn A function called for each property in `obj`. Its return value will
     * become a new property on the return object.
     * @param {Object} obj The object to iterate over.
     * @return {Object} A new object with the same keys as `obj` and values that are the result
     *         of running each property through `fn`.
     * @example
     *
     *      var values = { x: 1, y: 2, z: 3 };
     *      var double = function(num) {
     *        return num * 2;
     *      };
     *
     *      R.mapObj(double, values); //=> { x: 2, y: 4, z: 6 }
     */
    var mapObj = _curry2(function mapObj(fn, obj) {
        return _reduce(function (acc, key) {
            acc[key] = fn(obj[key]);
            return acc;
        }, {}, keys(obj));
    });

    /**
     * Like `mapObj`, but but passes additional arguments to the predicate function. The
     * predicate function is passed three arguments: *(value, key, obj)*.
     *
     * @func
     * @memberOf R
     * @category Object
     * @sig (v, k, {k: v} -> v) -> {k: v} -> {k: v}
     * @param {Function} fn A function called for each property in `obj`. Its return value will
     *        become a new property on the return object.
     * @param {Object} obj The object to iterate over.
     * @return {Object} A new object with the same keys as `obj` and values that are the result
     *         of running each property through `fn`.
     * @example
     *
     *      var values = { x: 1, y: 2, z: 3 };
     *      var prependKeyAndDouble = function(num, key, obj) {
     *        return key + (num * 2);
     *      };
     *
     *      R.mapObjIndexed(prependKeyAndDouble, values); //=> { x: 'x2', y: 'y4', z: 'z6' }
     */
    var mapObjIndexed = _curry2(function mapObjIndexed(fn, obj) {
        return _reduce(function (acc, key) {
            acc[key] = fn(obj[key], key, obj);
            return acc;
        }, {}, keys(obj));
    });

    /**
     * Returns `true` if no elements of the list match the predicate,
     * `false` otherwise.
     *
     * @func
     * @memberOf R
     * @category List
     * @sig (a -> Boolean) -> [a] -> Boolean
     * @param {Function} fn The predicate function.
     * @param {Array} list The array to consider.
     * @return {Boolean} `true` if the predicate is not satisfied by every element, `false` otherwise.
     * @see R.all, R.any
     * @example
     *
     *      R.none(R.isNaN, [1, 2, 3]); //=> true
     *      R.none(R.isNaN, [1, 2, 3, NaN]); //=> false
     */
    var none = _curry2(_complement(_dispatchable('any', _xany, any)));

    /**
     * A function that returns the first truthy of two arguments otherwise the
     * last argument. Note that this is NOT short-circuited, meaning that if
     * expressions are passed they are both evaluated.
     *
     * Dispatches to the `or` method of the first argument if applicable.
     *
     * @func
     * @memberOf R
     * @category Logic
     * @sig * -> * -> *
     * @param {*} a any value
     * @param {*} b any other value
     * @return {*} the first truthy argument, otherwise the last argument.
     * @see R.either
     * @example
     *
     *      R.or(false, true); //=> true
     *      R.or(0, []); //=> []
     *      R.or(null, ''); => ''
     */
    var or = _curry2(function or(a, b) {
        return _hasMethod('or', a) ? a.or(b) : a || b;
    });

    /**
     * Accepts as its arguments a function and any number of values and returns a function that,
     * when invoked, calls the original function with all of the values prepended to the
     * original function's arguments list. In some libraries this function is named `applyLeft`.
     *
     * @func
     * @memberOf R
     * @category Function
     * @sig (a -> b -> ... -> i -> j -> ... -> m -> n) -> a -> b-> ... -> i -> (j -> ... -> m -> n)
     * @param {Function} fn The function to invoke.
     * @param {...*} [args] Arguments to prepend to `fn` when the returned function is invoked.
     * @return {Function} A new function wrapping `fn`. When invoked, it will call `fn`
     *         with `args` prepended to `fn`'s arguments list.
     * @example
     *
     *      var multiply = function(a, b) { return a * b; };
     *      var double = R.partial(multiply, 2);
     *      double(2); //=> 4
     *
     *      var greet = function(salutation, title, firstName, lastName) {
     *        return salutation + ', ' + title + ' ' + firstName + ' ' + lastName + '!';
     *      };
     *      var sayHello = R.partial(greet, 'Hello');
     *      var sayHelloToMs = R.partial(sayHello, 'Ms.');
     *      sayHelloToMs('Jane', 'Jones'); //=> 'Hello, Ms. Jane Jones!'
     */
    var partial = curry(_createPartialApplicator(_concat));

    /**
     * Accepts as its arguments a function and any number of values and returns a function that,
     * when invoked, calls the original function with all of the values appended to the original
     * function's arguments list.
     *
     * Note that `partialRight` is the opposite of `partial`: `partialRight` fills `fn`'s arguments
     * from the right to the left.  In some libraries this function is named `applyRight`.
     *
     * @func
     * @memberOf R
     * @category Function
     * @sig (a -> b-> ... -> i -> j -> ... -> m -> n) -> j -> ... -> m -> n -> (a -> b-> ... -> i)
     * @param {Function} fn The function to invoke.
     * @param {...*} [args] Arguments to append to `fn` when the returned function is invoked.
     * @return {Function} A new function wrapping `fn`. When invoked, it will call `fn` with
     *         `args` appended to `fn`'s arguments list.
     * @example
     *
     *      var greet = function(salutation, title, firstName, lastName) {
     *        return salutation + ', ' + title + ' ' + firstName + ' ' + lastName + '!';
     *      };
     *      var greetMsJaneJones = R.partialRight(greet, 'Ms.', 'Jane', 'Jones');
     *
     *      greetMsJaneJones('Hello'); //=> 'Hello, Ms. Jane Jones!'
     */
    var partialRight = curry(_createPartialApplicator(flip(_concat)));

    /**
     * Takes a predicate and a list and returns the pair of lists of
     * elements which do and do not satisfy the predicate, respectively.
     *
     * @func
     * @memberOf R
     * @category List
     * @sig (a -> Boolean) -> [a] -> [[a],[a]]
     * @param {Function} pred A predicate to determine which array the element belongs to.
     * @param {Array} list The array to partition.
     * @return {Array} A nested array, containing first an array of elements that satisfied the predicate,
     *         and second an array of elements that did not satisfy.
     * @example
     *
     *      R.partition(R.contains('s'), ['sss', 'ttt', 'foo', 'bars']);
     *      //=> [ [ 'sss', 'bars' ],  [ 'ttt', 'foo' ] ]
     */
    var partition = _curry2(function partition(pred, list) {
        return _reduce(function (acc, elt) {
            var xs = acc[pred(elt) ? 0 : 1];
            xs[xs.length] = elt;
            return acc;
        }, [
            [],
            []
        ], list);
    });

    /**
     * Determines whether a nested path on an object has a specific value,
     * in `R.equals` terms. Most likely used to filter a list.
     *
     * @func
     * @memberOf R
     * @category Relation
     * @sig [String] -> * -> {String: *} -> Boolean
     * @param {Array} path The path of the nested property to use
     * @param {*} val The value to compare the nested property with
     * @param {Object} obj The object to check the nested property in
     * @return {Boolean} `true` if the value equals the nested object property,
     *         `false` otherwise.
     * @example
     *
     *      var user1 = { address: { zipCode: 90210 } };
     *      var user2 = { address: { zipCode: 55555 } };
     *      var user3 = { name: 'Bob' };
     *      var users = [ user1, user2, user3 ];
     *      var isFamous = R.pathEq(['address', 'zipCode'], 90210);
     *      R.filter(isFamous, users); //=> [ user1 ]
     */
    var pathEq = _curry3(function pathEq(_path, val, obj) {
        return equals(path(_path, obj), val);
    });

    /**
     * Returns a new list by plucking the same named property off all objects in the list supplied.
     *
     * @func
     * @memberOf R
     * @category List
     * @sig k -> [{k: v}] -> [v]
     * @param {Number|String} key The key name to pluck off of each object.
     * @param {Array} list The array to consider.
     * @return {Array} The list of values for the given key.
     * @example
     *
     *      R.pluck('a')([{a: 1}, {a: 2}]); //=> [1, 2]
     *      R.pluck(0)([[1, 2], [3, 4]]);   //=> [1, 3]
     */
    var pluck = _curry2(function pluck(p, list) {
        return map(prop(p), list);
    });

    /**
     * Returns `true` if the specified object property is equal, in `R.equals`
     * terms, to the given value; `false` otherwise.
     *
     * @func
     * @memberOf R
     * @category Relation
     * @sig String -> a -> Object -> Boolean
     * @param {String} name
     * @param {*} val
     * @param {*} obj
     * @return {Boolean}
     * @see R.equals, R.propSatisfies
     * @example
     *
     *      var abby = {name: 'Abby', age: 7, hair: 'blond'};
     *      var fred = {name: 'Fred', age: 12, hair: 'brown'};
     *      var rusty = {name: 'Rusty', age: 10, hair: 'brown'};
     *      var alois = {name: 'Alois', age: 15, disposition: 'surly'};
     *      var kids = [abby, fred, rusty, alois];
     *      var hasBrownHair = R.propEq('hair', 'brown');
     *      R.filter(hasBrownHair, kids); //=> [fred, rusty]
     */
    var propEq = _curry3(function propEq(name, val, obj) {
        return propSatisfies(equals(val), name, obj);
    });

    /**
     * Returns `true` if the specified object property is of the given type;
     * `false` otherwise.
     *
     * @func
     * @memberOf R
     * @category Type
     * @sig Type -> String -> Object -> Boolean
     * @param {Function} type
     * @param {String} name
     * @param {*} obj
     * @return {Boolean}
     * @see R.is
     * @see R.propSatisfies
     * @example
     *
     *      R.propIs(Number, 'x', {x: 1, y: 2});  //=> true
     *      R.propIs(Number, 'x', {x: 'foo'});    //=> false
     *      R.propIs(Number, 'x', {});            //=> false
     */
    var propIs = _curry3(function propIs(type, name, obj) {
        return propSatisfies(is(type), name, obj);
    });

    /**
     * Returns a single item by iterating through the list, successively calling the iterator
     * function and passing it an accumulator value and the current value from the array, and
     * then passing the result to the next call.
     *
     * The iterator function receives two values: *(acc, value)*.  It may use `R.reduced` to
     * shortcut the iteration.
     *
     * Note: `R.reduce` does not skip deleted or unassigned indices (sparse arrays), unlike
     * the native `Array.prototype.reduce` method. For more details on this behavior, see:
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce#Description
     * @see R.reduced
     *
     * @func
     * @memberOf R
     * @category List
     * @sig (a,b -> a) -> a -> [b] -> a
     * @param {Function} fn The iterator function. Receives two values, the accumulator and the
     *        current element from the array.
     * @param {*} acc The accumulator value.
     * @param {Array} list The list to iterate over.
     * @return {*} The final, accumulated value.
     * @example
     *
     *      var numbers = [1, 2, 3];
     *      var add = function(a, b) {
     *        return a + b;
     *      };
     *
     *      R.reduce(add, 10, numbers); //=> 16
     */
    var reduce = _curry3(_reduce);

    /**
     * Similar to `filter`, except that it keeps only values for which the given predicate
     * function returns falsy. The predicate function is passed one argument: *(value)*.
     *
     * Acts as a transducer if a transformer is given in list position.
     * @see R.transduce
     *
     * @func
     * @memberOf R
     * @category List
     * @sig (a -> Boolean) -> [a] -> [a]
     * @param {Function} fn The function called per iteration.
     * @param {Array} list The collection to iterate over.
     * @return {Array} The new filtered array.
     * @see R.filter
     * @example
     *
     *      var isOdd = function(n) {
     *        return n % 2 === 1;
     *      };
     *      R.reject(isOdd, [1, 2, 3, 4]); //=> [2, 4]
     */
    var reject = _curry2(function reject(fn, list) {
        return filter(_complement(fn), list);
    });

    /**
     * Returns a fixed list of size `n` containing a specified identical value.
     *
     * @func
     * @memberOf R
     * @category List
     * @sig a -> n -> [a]
     * @param {*} value The value to repeat.
     * @param {Number} n The desired size of the output list.
     * @return {Array} A new array containing `n` `value`s.
     * @example
     *
     *      R.repeat('hi', 5); //=> ['hi', 'hi', 'hi', 'hi', 'hi']
     *
     *      var obj = {};
     *      var repeatedObjs = R.repeat(obj, 5); //=> [{}, {}, {}, {}, {}]
     *      repeatedObjs[0] === repeatedObjs[1]; //=> true
     */
    var repeat = _curry2(function repeat(value, n) {
        return times(always(value), n);
    });

    /**
     * Returns the elements of the given list or string (or object with a `slice`
     * method) from `fromIndex` (inclusive) to `toIndex` (exclusive).
     *
     * @func
     * @memberOf R
     * @category List
     * @sig Number -> Number -> [a] -> [a]
     * @sig Number -> Number -> String -> String
     * @param {Number} fromIndex The start index (inclusive).
     * @param {Number} toIndex The end index (exclusive).
     * @param {*} list
     * @return {*}
     * @example
     *
     *      R.slice(1, 3, ['a', 'b', 'c', 'd']);        //=> ['b', 'c']
     *      R.slice(1, Infinity, ['a', 'b', 'c', 'd']); //=> ['b', 'c', 'd']
     *      R.slice(0, -1, ['a', 'b', 'c', 'd']);       //=> ['a', 'b', 'c']
     *      R.slice(-3, -1, ['a', 'b', 'c', 'd']);      //=> ['b', 'c']
     *      R.slice(0, 3, 'ramda');                     //=> 'ram'
     */
    var slice = _curry3(_checkForMethod('slice', function slice(fromIndex, toIndex, list) {
        return Array.prototype.slice.call(list, fromIndex, toIndex);
    }));

    /**
     * Splits a collection into slices of the specified length.
     *
     * @func
     * @memberOf R
     * @category List
     * @sig Number -> [a] -> [[a]]
     * @sig Number -> String -> [String]
     * @param {Number} n
     * @param {Array} list
     * @return {Array}
     * @example
     *
     *      R.splitEvery(3, [1, 2, 3, 4, 5, 6, 7]); //=> [[1, 2, 3], [4, 5, 6], [7]]
     *      R.splitEvery(3, 'foobarbaz'); //=> ['foo', 'bar', 'baz']
     */
    var splitEvery = _curry2(function splitEvery(n, list) {
        if (n <= 0) {
            throw new Error('First argument to splitEvery must be a positive integer');
        }
        var result = [];
        var idx = 0;
        while (idx < list.length) {
            result.push(slice(idx, idx += n, list));
        }
        return result;
    });

    /**
     * Adds together all the elements of a list.
     *
     * @func
     * @memberOf R
     * @category Math
     * @sig [Number] -> Number
     * @param {Array} list An array of numbers
     * @return {Number} The sum of all the numbers in the list.
     * @see R.reduce
     * @example
     *
     *      R.sum([2,4,6,8,100,1]); //=> 121
     */
    var sum = reduce(add, 0);

    /**
     * Returns all but the first element of the given list or string (or object
     * with a `tail` method).
     *
     * @func
     * @memberOf R
     * @category List
     * @see R.head, R.init, R.last
     * @sig [a] -> [a]
     * @sig String -> String
     * @param {*} list
     * @return {*}
     * @example
     *
     *      R.tail([1, 2, 3]);  //=> [2, 3]
     *      R.tail([1, 2]);     //=> [2]
     *      R.tail([1]);        //=> []
     *      R.tail([]);         //=> []
     *
     *      R.tail('abc');  //=> 'bc'
     *      R.tail('ab');   //=> 'b'
     *      R.tail('a');    //=> ''
     *      R.tail('');     //=> ''
     */
    var tail = _checkForMethod('tail', slice(1, Infinity));

    /**
     * Returns the first `n` elements of the given list, string, or
     * transducer/transformer (or object with a `take` method).
     *
     * @func
     * @memberOf R
     * @category List
     * @sig Number -> [a] -> [a]
     * @sig Number -> String -> String
     * @param {Number} n
     * @param {*} list
     * @return {*}
     * @see R.drop
     * @example
     *
     *      R.take(1, ['foo', 'bar', 'baz']); //=> ['foo']
     *      R.take(2, ['foo', 'bar', 'baz']); //=> ['foo', 'bar']
     *      R.take(3, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
     *      R.take(4, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
     *      R.take(3, 'ramda');               //=> 'ram'
     *
     *      var personnel = [
     *        'Dave Brubeck',
     *        'Paul Desmond',
     *        'Eugene Wright',
     *        'Joe Morello',
     *        'Gerry Mulligan',
     *        'Bob Bates',
     *        'Joe Dodge',
     *        'Ron Crotty'
     *      ];
     *
     *      var takeFive = R.take(5);
     *      takeFive(personnel);
     *      //=> ['Dave Brubeck', 'Paul Desmond', 'Eugene Wright', 'Joe Morello', 'Gerry Mulligan']
     */
    var take = _curry2(_dispatchable('take', _xtake, function take(n, xs) {
        return slice(0, n < 0 ? Infinity : n, xs);
    }));

    /**
     * Returns a new list containing the first `n` elements of a given list, passing each value
     * to the supplied predicate function, and terminating when the predicate function returns
     * `false`. Excludes the element that caused the predicate function to fail. The predicate
     * function is passed one argument: *(value)*.
     *
     * Acts as a transducer if a transformer is given in list position.
     * @see R.transduce
     *
     * @func
     * @memberOf R
     * @category List
     * @sig (a -> Boolean) -> [a] -> [a]
     * @param {Function} fn The function called per iteration.
     * @param {Array} list The collection to iterate over.
     * @return {Array} A new array.
     * @see R.dropWhile
     * @example
     *
     *      var isNotFour = function(x) {
     *        return !(x === 4);
     *      };
     *
     *      R.takeWhile(isNotFour, [1, 2, 3, 4]); //=> [1, 2, 3]
     */
    var takeWhile = _curry2(_dispatchable('takeWhile', _xtakeWhile, function takeWhile(fn, list) {
        var idx = 0, len = list.length;
        while (idx < len && fn(list[idx])) {
            idx += 1;
        }
        return _slice(list, 0, idx);
    }));

    /**
     * Initializes a transducer using supplied iterator function. Returns a single item by
     * iterating through the list, successively calling the transformed iterator function and
     * passing it an accumulator value and the current value from the array, and then passing
     * the result to the next call.
     *
     * The iterator function receives two values: *(acc, value)*. It will be wrapped as a
     * transformer to initialize the transducer. A transformer can be passed directly in place
     * of an iterator function.  In both cases, iteration may be stopped early with the
     * `R.reduced` function.
     *
     * A transducer is a function that accepts a transformer and returns a transformer and can
     * be composed directly.
     *
     * A transformer is an an object that provides a 2-arity reducing iterator function, step,
     * 0-arity initial value function, init, and 1-arity result extraction function, result.
     * The step function is used as the iterator function in reduce. The result function is used
     * to convert the final accumulator into the return type and in most cases is R.identity.
     * The init function can be used to provide an initial accumulator, but is ignored by transduce.
     *
     * The iteration is performed with R.reduce after initializing the transducer.
     *
     * @func
     * @memberOf R
     * @category List
     * @see R.reduce, R.reduced, R.into
     * @sig (c -> c) -> (a,b -> a) -> a -> [b] -> a
     * @param {Function} xf The transducer function. Receives a transformer and returns a transformer.
     * @param {Function} fn The iterator function. Receives two values, the accumulator and the
     *        current element from the array. Wrapped as transformer, if necessary, and used to
     *        initialize the transducer
     * @param {*} acc The initial accumulator value.
     * @param {Array} list The list to iterate over.
     * @return {*} The final, accumulated value.
     * @example
     *
     *      var numbers = [1, 2, 3, 4];
     *      var transducer = R.compose(R.map(R.add(1)), R.take(2));
     *
     *      R.transduce(transducer, R.flip(R.append), [], numbers); //=> [2, 3]
     */
    var transduce = curryN(4, function transduce(xf, fn, acc, list) {
        return _reduce(xf(typeof fn === 'function' ? _xwrap(fn) : fn), acc, list);
    });

    /**
     * Combines two lists into a set (i.e. no duplicates) composed of the elements of each list.  Duplication is
     * determined according to the value returned by applying the supplied predicate to two list elements.
     *
     * @func
     * @memberOf R
     * @category Relation
     * @sig (a,a -> Boolean) -> [a] -> [a] -> [a]
     * @param {Function} pred A predicate used to test whether two items are equal.
     * @param {Array} list1 The first list.
     * @param {Array} list2 The second list.
     * @return {Array} The first and second lists concatenated, with
     *         duplicates removed.
     * @see R.union
     * @example
     *
     *      function cmp(x, y) { return x.a === y.a; }
     *      var l1 = [{a: 1}, {a: 2}];
     *      var l2 = [{a: 1}, {a: 4}];
     *      R.unionWith(cmp, l1, l2); //=> [{a: 1}, {a: 2}, {a: 4}]
     */
    var unionWith = _curry3(function unionWith(pred, list1, list2) {
        return uniqWith(pred, _concat(list1, list2));
    });

    /**
     * Returns a new list containing only one copy of each element in the original list.
     * `R.equals` is used to determine equality.
     *
     * @func
     * @memberOf R
     * @category List
     * @sig [a] -> [a]
     * @param {Array} list The array to consider.
     * @return {Array} The list of unique items.
     * @example
     *
     *      R.uniq([1, 1, 2, 1]); //=> [1, 2]
     *      R.uniq([1, '1']);     //=> [1, '1']
     *      R.uniq([[42], [42]]); //=> [[42]]
     */
    var uniq = uniqWith(equals);

    /**
     * Returns a new list by pulling every item at the first level of nesting out, and putting
     * them in a new array.
     *
     * @func
     * @memberOf R
     * @category List
     * @sig [a] -> [b]
     * @param {Array} list The array to consider.
     * @return {Array} The flattened list.
     * @see R.flatten
     * @example
     *
     *      R.unnest([1, [2], [[3]]]); //=> [1, 2, [3]]
     *      R.unnest([[1, 2], [3, 4], [5, 6]]); //=> [1, 2, 3, 4, 5, 6]
     */
    var unnest = _curry1(_makeFlat(false));

    /**
     * Accepts a function `fn` and any number of transformer functions and returns a new
     * function. When the new function is invoked, it calls the function `fn` with parameters
     * consisting of the result of calling each supplied handler on successive arguments to the
     * new function.
     *
     * If more arguments are passed to the returned function than transformer functions, those
     * arguments are passed directly to `fn` as additional parameters. If you expect additional
     * arguments that don't need to be transformed, although you can ignore them, it's best to
     * pass an identity function so that the new function reports the correct arity.
     *
     * @func
     * @memberOf R
     * @category Function
     * @sig (x1 -> x2 -> ... -> z) -> ((a -> x1), (b -> x2), ...) -> (a -> b -> ... -> z)
     * @param {Function} fn The function to wrap.
     * @param {...Function} transformers A variable number of transformer functions
     * @return {Function} The wrapped function.
     * @example
     *
     *      var double = function(y) { return y * 2; };
     *      var square = function(x) { return x * x; };
     *      var add = function(a, b) { return a + b; };
     *      // Adds any number of arguments together
     *      var addAll = function() {
     *        return R.reduce(add, 0, arguments);
     *      };
     *
     *      // Basic example
     *      var addDoubleAndSquare = R.useWith(addAll, double, square);
     *
     *      //≅ addAll(double(10), square(5));
     *      addDoubleAndSquare(10, 5); //=> 45
     *
     *      // Example of passing more arguments than transformers
     *      //≅ addAll(double(10), square(5), 100);
     *      addDoubleAndSquare(10, 5, 100); //=> 145
     *
     *      // If there are extra _expected_ arguments that don't need to be transformed, although
     *      // you can ignore them, it might be best to pass in the identity function so that the new
     *      // function correctly reports arity.
     *      var addDoubleAndSquareWithExtraParams = R.useWith(addAll, double, square, R.identity);
     *      // addDoubleAndSquareWithExtraParams.length //=> 3
     *      //≅ addAll(double(10), square(5), R.identity(100));
     *      addDoubleAndSquare(10, 5, 100); //=> 145
     */
    /*, transformers */
    var useWith = curry(function useWith(fn) {
        var transformers = _slice(arguments, 1);
        var tlen = transformers.length;
        return curry(_arity(tlen, function () {
            var args = [], idx = 0;
            while (idx < tlen) {
                args[idx] = transformers[idx](arguments[idx]);
                idx += 1;
            }
            return fn.apply(this, args.concat(_slice(arguments, tlen)));
        }));
    });

    /**
     * Takes a spec object and a test object; returns true if the test satisfies
     * the spec, false otherwise. An object satisfies the spec if, for each of the
     * spec's own properties, accessing that property of the object gives the same
     * value (in `R.equals` terms) as accessing that property of the spec.
     *
     * `whereEq` is a specialization of [`where`](#where).
     *
     * @func
     * @memberOf R
     * @category Object
     * @sig {String: *} -> {String: *} -> Boolean
     * @param {Object} spec
     * @param {Object} testObj
     * @return {Boolean}
     * @see R.where
     * @example
     *
     *      // pred :: Object -> Boolean
     *      var pred = R.whereEq({a: 1, b: 2});
     *
     *      pred({a: 1});              //=> false
     *      pred({a: 1, b: 2});        //=> true
     *      pred({a: 1, b: 2, c: 3});  //=> true
     *      pred({a: 1, b: 1});        //=> false
     */
    var whereEq = _curry2(function whereEq(spec, testObj) {
        return where(mapObj(equals, spec), testObj);
    });

    var _flatCat = function () {
        var preservingReduced = function (xf) {
            return {
                '@@transducer/init': _xfBase.init,
                '@@transducer/result': function (result) {
                    return xf['@@transducer/result'](result);
                },
                '@@transducer/step': function (result, input) {
                    var ret = xf['@@transducer/step'](result, input);
                    return ret['@@transducer/reduced'] ? _forceReduced(ret) : ret;
                }
            };
        };
        return function _xcat(xf) {
            var rxf = preservingReduced(xf);
            return {
                '@@transducer/init': _xfBase.init,
                '@@transducer/result': function (result) {
                    return rxf['@@transducer/result'](result);
                },
                '@@transducer/step': function (result, input) {
                    return !isArrayLike(input) ? _reduce(rxf, result, [input]) : _reduce(rxf, result, input);
                }
            };
        };
    }();

    var _indexOf = function _indexOf(list, item, from) {
        var idx = from;
        while (idx < list.length) {
            if (equals(list[idx], item)) {
                return idx;
            }
            idx += 1;
        }
        return -1;
    };

    /**
     * Create a predicate wrapper which will call a pick function (all/any) for each predicate
     *
     * @private
     * @see R.all
     * @see R.any
     */
    // Call function immediately if given arguments
    // Return a function which will call the predicates with the provided arguments
    var _predicateWrap = function _predicateWrap(predPicker) {
        return function (preds) {
            var predIterator = function () {
                var args = arguments;
                return predPicker(function (predicate) {
                    return predicate.apply(null, args);
                }, preds);
            };
            return arguments.length > 1 ? // Call function immediately if given arguments
            predIterator.apply(null, _slice(arguments, 1)) : // Return a function which will call the predicates with the provided arguments
            _arity(Math.max.apply(Math, pluck('length', preds)), predIterator);
        };
    };

    var _xchain = _curry2(function _xchain(f, xf) {
        return map(f, _flatCat(xf));
    });

    /**
     * Given a list of predicates, returns a new predicate that will be true exactly when all of them are.
     *
     * @func
     * @memberOf R
     * @category Logic
     * @sig [(*... -> Boolean)] -> (*... -> Boolean)
     * @param {Array} list An array of predicate functions
     * @param {*} optional Any arguments to pass into the predicates
     * @return {Function} a function that applies its arguments to each of
     *         the predicates, returning `true` if all are satisfied.
     * @see R.anyPass
     * @example
     *
     *      var gt10 = function(x) { return x > 10; };
     *      var even = function(x) { return x % 2 === 0};
     *      var f = R.allPass([gt10, even]);
     *      f(11); //=> false
     *      f(12); //=> true
     */
    var allPass = _curry1(_predicateWrap(all));

    /**
     * Given a list of predicates returns a new predicate that will be true exactly when any one of them is.
     *
     * @func
     * @memberOf R
     * @category Logic
     * @sig [(*... -> Boolean)] -> (*... -> Boolean)
     * @param {Array} list An array of predicate functions
     * @param {*} optional Any arguments to pass into the predicates
     * @return {Function} A function that applies its arguments to each of the predicates, returning
     *         `true` if all are satisfied.
     * @see R.allPass
     * @example
     *
     *      var gt10 = function(x) { return x > 10; };
     *      var even = function(x) { return x % 2 === 0};
     *      var f = R.anyPass([gt10, even]);
     *      f(11); //=> true
     *      f(8); //=> true
     *      f(9); //=> false
     */
    var anyPass = _curry1(_predicateWrap(any));

    /**
     * ap applies a list of functions to a list of values.
     *
     * @func
     * @memberOf R
     * @category Function
     * @sig [f] -> [a] -> [f a]
     * @param {Array} fns An array of functions
     * @param {Array} vs An array of values
     * @return {Array} An array of results of applying each of `fns` to all of `vs` in turn.
     * @example
     *
     *      R.ap([R.multiply(2), R.add(3)], [1,2,3]); //=> [2, 4, 6, 4, 5, 6]
     */
    var ap = _curry2(function ap(fns, vs) {
        return _hasMethod('ap', fns) ? fns.ap(vs) : _reduce(function (acc, fn) {
            return _concat(acc, map(fn, vs));
        }, [], fns);
    });

    /**
     * Returns the result of calling its first argument with the remaining
     * arguments. This is occasionally useful as a converging function for
     * `R.converge`: the left branch can produce a function while the right
     * branch produces a value to be passed to that function as an argument.
     *
     * @func
     * @memberOf R
     * @category Function
     * @sig (*... -> a),*... -> a
     * @param {Function} fn The function to apply to the remaining arguments.
     * @param {...*} args Any number of positional arguments.
     * @return {*}
     * @see R.apply
     * @example
     *
     *      var indentN = R.pipe(R.times(R.always(' ')),
     *                           R.join(''),
     *                           R.replace(/^(?!$)/gm));
     *
     *      var format = R.converge(R.call,
     *                              R.pipe(R.prop('indent'), indentN),
     *                              R.prop('value'));
     *
     *      format({indent: 2, value: 'foo\nbar\nbaz\n'}); //=> '  foo\n  bar\n  baz\n'
     */
    var call = curry(function call(fn) {
        return fn.apply(this, _slice(arguments, 1));
    });

    /**
     * `chain` maps a function over a list and concatenates the results.
     * This implementation is compatible with the
     * Fantasy-land Chain spec, and will work with types that implement that spec.
     * `chain` is also known as `flatMap` in some libraries
     *
     * @func
     * @memberOf R
     * @category List
     * @sig (a -> [b]) -> [a] -> [b]
     * @param {Function} fn
     * @param {Array} list
     * @return {Array}
     * @example
     *
     *      var duplicate = function(n) {
     *        return [n, n];
     *      };
     *      R.chain(duplicate, [1, 2, 3]); //=> [1, 1, 2, 2, 3, 3]
     */
    var chain = _curry2(_dispatchable('chain', _xchain, function chain(fn, list) {
        return unnest(map(fn, list));
    }));

    /**
     * Turns a list of Functors into a Functor of a list, applying
     * a mapping function to the elements of the list along the way.
     *
     * @func
     * @memberOf R
     * @category List
     * @see R.commute
     * @sig Functor f => (f a -> f b) -> (x -> f x) -> [f a] -> f [b]
     * @param {Function} fn The transformation function
     * @param {Function} of A function that returns the data type to return
     * @param {Array} list An array of functors of the same type
     * @return {*}
     * @example
     *
     *      R.commuteMap(R.map(R.add(10)), R.of, [[1], [2, 3]]);   //=> [[11, 12], [11, 13]]
     *      R.commuteMap(R.map(R.add(10)), R.of, [[1, 2], [3]]);   //=> [[11, 13], [12, 13]]
     *      R.commuteMap(R.map(R.add(10)), R.of, [[1], [2], [3]]); //=> [[11, 12, 13]]
     *      R.commuteMap(R.map(R.add(10)), Maybe.of, [Just(1), Just(2), Just(3)]);   //=> Just([11, 12, 13])
     *      R.commuteMap(R.map(R.add(10)), Maybe.of, [Just(1), Just(2), Nothing()]); //=> Nothing()
     */
    var commuteMap = _curry3(function commuteMap(fn, of, list) {
        function consF(acc, ftor) {
            return ap(map(append, fn(ftor)), acc);
        }
        return _reduce(consF, of([]), list);
    });

    /**
     * Wraps a constructor function inside a curried function that can be called with the same
     * arguments and returns the same type. The arity of the function returned is specified
     * to allow using variadic constructor functions.
     *
     * @func
     * @memberOf R
     * @category Function
     * @sig Number -> (* -> {*}) -> (* -> {*})
     * @param {Number} n The arity of the constructor function.
     * @param {Function} Fn The constructor function to wrap.
     * @return {Function} A wrapped, curried constructor function.
     * @example
     *
     *      // Variadic constructor function
     *      var Widget = function() {
     *        this.children = Array.prototype.slice.call(arguments);
     *        // ...
     *      };
     *      Widget.prototype = {
     *        // ...
     *      };
     *      var allConfigs = [
     *        // ...
     *      ];
     *      R.map(R.constructN(1, Widget), allConfigs); // a list of Widgets
     */
    var constructN = _curry2(function constructN(n, Fn) {
        if (n > 10) {
            throw new Error('Constructor with greater than ten arguments');
        }
        if (n === 0) {
            return function () {
                return new Fn();
            };
        }
        return curry(nAry(n, function ($0, $1, $2, $3, $4, $5, $6, $7, $8, $9) {
            switch (arguments.length) {
            case 1:
                return new Fn($0);
            case 2:
                return new Fn($0, $1);
            case 3:
                return new Fn($0, $1, $2);
            case 4:
                return new Fn($0, $1, $2, $3);
            case 5:
                return new Fn($0, $1, $2, $3, $4);
            case 6:
                return new Fn($0, $1, $2, $3, $4, $5);
            case 7:
                return new Fn($0, $1, $2, $3, $4, $5, $6);
            case 8:
                return new Fn($0, $1, $2, $3, $4, $5, $6, $7);
            case 9:
                return new Fn($0, $1, $2, $3, $4, $5, $6, $7, $8);
            case 10:
                return new Fn($0, $1, $2, $3, $4, $5, $6, $7, $8, $9);
            }
        }));
    });

    /**
     * Accepts at least three functions and returns a new function. When invoked, this new
     * function will invoke the first function, `after`, passing as its arguments the
     * results of invoking the subsequent functions with whatever arguments are passed to
     * the new function.
     *
     * @func
     * @memberOf R
     * @category Function
     * @sig (x1 -> x2 -> ... -> z) -> ((a -> b -> ... -> x1), (a -> b -> ... -> x2), ...) -> (a -> b -> ... -> z)
     * @param {Function} after A function. `after` will be invoked with the return values of
     *        `fn1` and `fn2` as its arguments.
     * @param {...Function} functions A variable number of functions.
     * @return {Function} A new function.
     * @example
     *
     *      var add = function(a, b) { return a + b; };
     *      var multiply = function(a, b) { return a * b; };
     *      var subtract = function(a, b) { return a - b; };
     *
     *      //≅ multiply( add(1, 2), subtract(1, 2) );
     *      R.converge(multiply, add, subtract)(1, 2); //=> -3
     *
     *      var add3 = function(a, b, c) { return a + b + c; };
     *      R.converge(add3, multiply, add, subtract)(1, 2); //=> 4
     */
    var converge = curryN(3, function converge(after) {
        var fns = _slice(arguments, 1);
        return curryN(Math.max.apply(Math, pluck('length', fns)), function () {
            var args = arguments;
            var context = this;
            return after.apply(context, _map(function (fn) {
                return fn.apply(context, args);
            }, fns));
        });
    });

    /**
     * Returns all but the first `n` elements of the given list, string, or
     * transducer/transformer (or object with a `drop` method).
     *
     * @func
     * @memberOf R
     * @category List
     * @see R.transduce
     * @sig Number -> [a] -> [a]
     * @sig Number -> String -> String
     * @param {Number} n
     * @param {*} list
     * @return {*}
     * @see R.take
     * @example
     *
     *      R.drop(1, ['foo', 'bar', 'baz']); //=> ['bar', 'baz']
     *      R.drop(2, ['foo', 'bar', 'baz']); //=> ['baz']
     *      R.drop(3, ['foo', 'bar', 'baz']); //=> []
     *      R.drop(4, ['foo', 'bar', 'baz']); //=> []
     *      R.drop(3, 'ramda');               //=> 'da'
     */
    var drop = _curry2(_dispatchable('drop', _xdrop, function drop(n, xs) {
        return slice(Math.max(0, n), Infinity, xs);
    }));

    /**
     * Returns a list containing all but the last `n` elements of the given `list`.
     *
     * @func
     * @memberOf R
     * @category List
     * @sig Number -> [a] -> [a]
     * @sig Number -> String -> String
     * @param {Number} n The number of elements of `xs` to skip.
     * @param {Array} xs The collection to consider.
     * @return {Array}
     * @see R.takeLast
     * @example
     *
     *      R.dropLast(1, ['foo', 'bar', 'baz']); //=> ['foo', 'bar']
     *      R.dropLast(2, ['foo', 'bar', 'baz']); //=> ['foo']
     *      R.dropLast(3, ['foo', 'bar', 'baz']); //=> []
     *      R.dropLast(4, ['foo', 'bar', 'baz']); //=> []
     *      R.dropLast(3, 'ramda');               //=> 'ra'
     */
    var dropLast = _curry2(function dropLast(n, xs) {
        return take(n < xs.length ? xs.length - n : 0, xs);
    });

    /**
     * Returns a new list without any consecutively repeating elements. Equality is
     * determined by applying the supplied predicate two consecutive elements.
     * The first element in a series of equal element is the one being preserved.
     *
     * Acts as a transducer if a transformer is given in list position.
     * @see R.transduce
     *
     * @func
     * @memberOf R
     * @category List
     * @sig (a, a -> Boolean) -> [a] -> [a]
     * @param {Function} pred A predicate used to test whether two items are equal.
     * @param {Array} list The array to consider.
     * @return {Array} `list` without repeating elements.
     * @example
     *
     *      function lengthEq(x, y) { return Math.abs(x) === Math.abs(y); };
     *      var l = [1, -1, 1, 3, 4, -4, -4, -5, 5, 3, 3];
     *      R.dropRepeatsWith(lengthEq, l); //=> [1, 3, 4, -5, 3]
     */
    var dropRepeatsWith = _curry2(_dispatchable('dropRepeatsWith', _xdropRepeatsWith, function dropRepeatsWith(pred, list) {
        var result = [];
        var idx = 1;
        var len = list.length;
        if (len !== 0) {
            result[0] = list[0];
            while (idx < len) {
                if (!pred(last(result), list[idx])) {
                    result[result.length] = list[idx];
                }
                idx += 1;
            }
        }
        return result;
    }));

    /**
     * Reports whether two objects have the same value, in `R.equals` terms,
     * for the specified property. Useful as a curried predicate.
     *
     * @func
     * @memberOf R
     * @category Object
     * @sig k -> {k: v} -> {k: v} -> Boolean
     * @param {String} prop The name of the property to compare
     * @param {Object} obj1
     * @param {Object} obj2
     * @return {Boolean}
     *
     * @example
     *
     *      var o1 = { a: 1, b: 2, c: 3, d: 4 };
     *      var o2 = { a: 10, b: 20, c: 3, d: 40 };
     *      R.eqProps('a', o1, o2); //=> false
     *      R.eqProps('c', o1, o2); //=> true
     */
    var eqProps = _curry3(function eqProps(prop, obj1, obj2) {
        return equals(obj1[prop], obj2[prop]);
    });

    /**
     * Returns the position of the first occurrence of an item in an array,
     * or -1 if the item is not included in the array. `R.equals` is used to
     * determine equality.
     *
     * @func
     * @memberOf R
     * @category List
     * @sig a -> [a] -> Number
     * @param {*} target The item to find.
     * @param {Array} xs The array to search in.
     * @return {Number} the index of the target, or -1 if the target is not found.
     * @see R.lastIndexOf
     * @example
     *
     *      R.indexOf(3, [1,2,3,4]); //=> 2
     *      R.indexOf(10, [1,2,3,4]); //=> -1
     */
    var indexOf = _curry2(function indexOf(target, xs) {
        return _hasMethod('indexOf', xs) ? xs.indexOf(target) : _indexOf(xs, target, 0);
    });

    /**
     * Returns all but the last element of the given list or string.
     *
     * @func
     * @memberOf R
     * @category List
     * @see R.last, R.head, R.tail
     * @sig [a] -> [a]
     * @sig String -> String
     * @param {*} list
     * @return {*}
     * @example
     *
     *      R.init([1, 2, 3]);  //=> [1, 2]
     *      R.init([1, 2]);     //=> [1]
     *      R.init([1]);        //=> []
     *      R.init([]);         //=> []
     *
     *      R.init('abc');  //=> 'ab'
     *      R.init('ab');   //=> 'a'
     *      R.init('a');    //=> ''
     *      R.init('');     //=> ''
     */
    var init = slice(0, -1);

    /**
     * Returns `true` if all elements are unique, in `R.equals` terms,
     * otherwise `false`.
     *
     * @func
     * @memberOf R
     * @category List
     * @sig [a] -> Boolean
     * @param {Array} list The array to consider.
     * @return {Boolean} `true` if all elements are unique, else `false`.
     * @example
     *
     *      R.isSet(['1', 1]); //=> true
     *      R.isSet([1, 1]);   //=> false
     *      R.isSet([[42], [42]]); //=> false
     */
    var isSet = _curry1(function isSet(list) {
        var len = list.length;
        var idx = 0;
        while (idx < len) {
            if (_indexOf(list, list[idx], idx + 1) >= 0) {
                return false;
            }
            idx += 1;
        }
        return true;
    });

    /**
     * Returns a lens for the given getter and setter functions. The getter "gets"
     * the value of the focus; the setter "sets" the value of the focus. The setter
     * should not mutate the data structure.
     *
     * @func
     * @memberOf R
     * @category Object
     * @typedef Lens s a = Functor f => (a -> f a) -> s -> f s
     * @sig (s -> a) -> ((a, s) -> s) -> Lens s a
     * @param {Function} getter
     * @param {Function} setter
     * @return {Lens}
     * @see R.view, R.set, R.over, R.lensIndex, R.lensProp
     * @example
     *
     *      var xLens = R.lens(R.prop('x'), R.assoc('x'));
     *
     *      R.view(xLens, {x: 1, y: 2});            //=> 1
     *      R.set(xLens, 4, {x: 1, y: 2});          //=> {x: 4, y: 2}
     *      R.over(xLens, R.negate, {x: 1, y: 2});  //=> {x: -1, y: 2}
     */
    var lens = _curry2(function lens(getter, setter) {
        return function (f) {
            return function (s) {
                return map(function (v) {
                    return setter(v, s);
                }, f(getter(s)));
            };
        };
    });

    /**
     * Returns a lens whose focus is the specified index.
     *
     * @func
     * @memberOf R
     * @category Object
     * @typedef Lens s a = Functor f => (a -> f a) -> s -> f s
     * @sig Number -> Lens s a
     * @param {Number} n
     * @return {Lens}
     * @see R.view, R.set, R.over
     * @example
     *
     *      var headLens = R.lensIndex(0);
     *
     *      R.view(headLens, ['a', 'b', 'c']);            //=> 'a'
     *      R.set(headLens, 'x', ['a', 'b', 'c']);        //=> ['x', 'b', 'c']
     *      R.over(headLens, R.toUpper, ['a', 'b', 'c']); //=> ['A', 'b', 'c']
     */
    var lensIndex = _curry1(function lensIndex(n) {
        return lens(nth(n), update(n));
    });

    /**
     * Returns a lens whose focus is the specified property.
     *
     * @func
     * @memberOf R
     * @category Object
     * @typedef Lens s a = Functor f => (a -> f a) -> s -> f s
     * @sig String -> Lens s a
     * @param {String} k
     * @return {Lens}
     * @see R.view, R.set, R.over
     * @example
     *
     *      var xLens = R.lensProp('x');
     *
     *      R.view(xLens, {x: 1, y: 2});            //=> 1
     *      R.set(xLens, 4, {x: 1, y: 2});          //=> {x: 4, y: 2}
     *      R.over(xLens, R.negate, {x: 1, y: 2});  //=> {x: -1, y: 2}
     */
    var lensProp = _curry1(function lensProp(k) {
        return lens(prop(k), assoc(k));
    });

    /**
     * "lifts" a function to be the specified arity, so that it may "map over" that many
     * lists (or other Functors).
     *
     * @func
     * @memberOf R
     * @see R.lift
     * @category Function
     * @sig Number -> (*... -> *) -> ([*]... -> [*])
     * @param {Function} fn The function to lift into higher context
     * @return {Function} The function `fn` applicable to mappable objects.
     * @example
     *
     *      var madd3 = R.liftN(3, R.curryN(3, function() {
     *        return R.reduce(R.add, 0, arguments);
     *      }));
     *      madd3([1,2,3], [1,2,3], [1]); //=> [3, 4, 5, 4, 5, 6, 5, 6, 7]
     */
    var liftN = _curry2(function liftN(arity, fn) {
        var lifted = curryN(arity, fn);
        return curryN(arity, function () {
            return _reduce(ap, map(lifted, arguments[0]), _slice(arguments, 1));
        });
    });

    /**
     * Returns the mean of the given list of numbers.
     *
     * @func
     * @memberOf R
     * @category Math
     * @sig [Number] -> Number
     * @param {Array} list
     * @return {Number}
     * @example
     *
     *      R.mean([2, 7, 9]); //=> 6
     *      R.mean([]); //=> NaN
     */
    var mean = _curry1(function mean(list) {
        return sum(list) / list.length;
    });

    /**
     * Returns the median of the given list of numbers.
     *
     * @func
     * @memberOf R
     * @category Math
     * @sig [Number] -> Number
     * @param {Array} list
     * @return {Number}
     * @example
     *
     *      R.median([2, 9, 7]); //=> 7
     *      R.median([7, 2, 10, 9]); //=> 8
     *      R.median([]); //=> NaN
     */
    var median = _curry1(function median(list) {
        var len = list.length;
        if (len === 0) {
            return NaN;
        }
        var width = 2 - len % 2;
        var idx = (len - width) / 2;
        return mean(_slice(list).sort(function (a, b) {
            return a < b ? -1 : a > b ? 1 : 0;
        }).slice(idx, idx + width));
    });

    /**
     * Merges a list of objects together into one object.
     *
     * @func
     * @memberOf R
     * @category List
     * @sig [{k: v}] -> {k: v}
     * @param {Array} list An array of objects
     * @return {Object} A merged object.
     * @see R.reduce
     * @example
     *
     *      R.mergeAll([{foo:1},{bar:2},{baz:3}]); //=> {foo:1,bar:2,baz:3}
     *      R.mergeAll([{foo:1},{foo:2},{bar:2}]); //=> {foo:2,bar:2}
     */
    var mergeAll = _curry1(function mergeAll(list) {
        return reduce(merge, {}, list);
    });

    /**
     * Performs left-to-right function composition. The leftmost function may have
     * any arity; the remaining functions must be unary.
     *
     * In some libraries this function is named `sequence`.
     *
     * @func
     * @memberOf R
     * @category Function
     * @sig (((a, b, ..., n) -> o), (o -> p), ..., (x -> y), (y -> z)) -> (a -> b -> ... -> n -> z)
     * @param {...Function} functions
     * @return {Function}
     * @see R.compose
     * @example
     *
     *      var f = R.pipe(Math.pow, R.negate, R.inc);
     *
     *      f(3, 4); // -(3^4) + 1
     */
    var pipe = function pipe() {
        if (arguments.length === 0) {
            throw new Error('pipe requires at least one argument');
        }
        return curryN(arguments[0].length, reduce(_pipe, arguments[0], tail(arguments)));
    };

    /**
     * Performs left-to-right composition of one or more Promise-returning
     * functions. The leftmost function may have any arity; the remaining
     * functions must be unary.
     *
     * @func
     * @memberOf R
     * @category Function
     * @sig ((a -> Promise b), (b -> Promise c), ..., (y -> Promise z)) -> (a -> Promise z)
     * @param {...Function} functions
     * @return {Function}
     * @see R.composeP
     * @example
     *
     *      //  followersForUser :: String -> Promise [User]
     *      var followersForUser = R.pipeP(db.getUserById, db.getFollowers);
     */
    var pipeP = function pipeP() {
        if (arguments.length === 0) {
            throw new Error('pipeP requires at least one argument');
        }
        return curryN(arguments[0].length, reduce(_pipeP, arguments[0], tail(arguments)));
    };

    /**
     * Multiplies together all the elements of a list.
     *
     * @func
     * @memberOf R
     * @category Math
     * @sig [Number] -> Number
     * @param {Array} list An array of numbers
     * @return {Number} The product of all the numbers in the list.
     * @see R.reduce
     * @example
     *
     *      R.product([2,4,6,8,100,1]); //=> 38400
     */
    var product = reduce(multiply, 1);

    /**
     * Reasonable analog to SQL `select` statement.
     *
     * @func
     * @memberOf R
     * @category Object
     * @category Relation
     * @sig [k] -> [{k: v}] -> [{k: v}]
     * @param {Array} props The property names to project
     * @param {Array} objs The objects to query
     * @return {Array} An array of objects with just the `props` properties.
     * @example
     *
     *      var abby = {name: 'Abby', age: 7, hair: 'blond', grade: 2};
     *      var fred = {name: 'Fred', age: 12, hair: 'brown', grade: 7};
     *      var kids = [abby, fred];
     *      R.project(['name', 'grade'], kids); //=> [{name: 'Abby', grade: 2}, {name: 'Fred', grade: 7}]
     */
    // passing `identity` gives correct arity
    var project = useWith(_map, pickAll, identity);

    /**
     * Returns a new list containing the last `n` elements of the given list.
     * If `n > list.length`, returns a list of `list.length` elements.
     *
     * @func
     * @memberOf R
     * @category List
     * @sig Number -> [a] -> [a]
     * @sig Number -> String -> String
     * @param {Number} n The number of elements to return.
     * @param {Array} xs The collection to consider.
     * @return {Array}
     * @see R.dropLast
     * @example
     *
     *      R.takeLast(1, ['foo', 'bar', 'baz']); //=> ['baz']
     *      R.takeLast(2, ['foo', 'bar', 'baz']); //=> ['for', 'baz']
     *      R.takeLast(3, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
     *      R.takeLast(4, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
     *      R.takeLast(3, 'ramda');               //=> 'mda'
     */
    var takeLast = _curry2(function takeLast(n, xs) {
        return drop(n >= 0 ? xs.length - n : 0, xs);
    });

    var _contains = function _contains(a, list) {
        return _indexOf(list, a, 0) >= 0;
    };

    //  mapPairs :: (Object, [String]) -> [String]
    // Function, RegExp, user-defined types
    var _toString = function _toString(x, seen) {
        var recur = function recur(y) {
            var xs = seen.concat([x]);
            return _contains(y, xs) ? '<Circular>' : _toString(y, xs);
        };
        //  mapPairs :: (Object, [String]) -> [String]
        var mapPairs = function (obj, keys) {
            return _map(function (k) {
                return _quote(k) + ': ' + recur(obj[k]);
            }, keys.slice().sort());
        };
        switch (Object.prototype.toString.call(x)) {
        case '[object Arguments]':
            return '(function() { return arguments; }(' + _map(recur, x).join(', ') + '))';
        case '[object Array]':
            return '[' + _map(recur, x).concat(mapPairs(x, reject(test(/^\d+$/), keys(x)))).join(', ') + ']';
        case '[object Boolean]':
            return typeof x === 'object' ? 'new Boolean(' + recur(x.valueOf()) + ')' : x.toString();
        case '[object Date]':
            return 'new Date(' + _quote(_toISOString(x)) + ')';
        case '[object Null]':
            return 'null';
        case '[object Number]':
            return typeof x === 'object' ? 'new Number(' + recur(x.valueOf()) + ')' : 1 / x === -Infinity ? '-0' : x.toString(10);
        case '[object String]':
            return typeof x === 'object' ? 'new String(' + recur(x.valueOf()) + ')' : _quote(x);
        case '[object Undefined]':
            return 'undefined';
        default:
            return typeof x.constructor === 'function' && x.constructor.name !== 'Object' && typeof x.toString === 'function' && x.toString() !== '[object Object]' ? x.toString() : // Function, RegExp, user-defined types
            '{' + mapPairs(x, keys(x)).join(', ') + '}';
        }
    };

    /**
     * Turns a list of Functors into a Functor of a list.
     *
     * @func
     * @memberOf R
     * @category List
     * @see R.commuteMap
     * @sig Functor f => (x -> f x) -> [f a] -> f [a]
     * @param {Function} of A function that returns the data type to return
     * @param {Array} list An array of functors of the same type
     * @return {*}
     * @example
     *
     *      R.commute(R.of, [[1], [2, 3]]);   //=> [[1, 2], [1, 3]]
     *      R.commute(R.of, [[1, 2], [3]]);   //=> [[1, 3], [2, 3]]
     *      R.commute(R.of, [[1], [2], [3]]); //=> [[1, 2, 3]]
     *      R.commute(Maybe.of, [Just(1), Just(2), Just(3)]);   //=> Just([1, 2, 3])
     *      R.commute(Maybe.of, [Just(1), Just(2), Nothing()]); //=> Nothing()
     */
    var commute = commuteMap(identity);

    /**
     * Performs right-to-left function composition. The rightmost function may have
     * any arity; the remaining functions must be unary.
     *
     * @func
     * @memberOf R
     * @category Function
     * @sig ((y -> z), (x -> y), ..., (o -> p), ((a, b, ..., n) -> o)) -> (a -> b -> ... -> n -> z)
     * @param {...Function} functions
     * @return {Function}
     * @see R.pipe
     * @example
     *
     *      var f = R.compose(R.inc, R.negate, Math.pow);
     *
     *      f(3, 4); // -(3^4) + 1
     */
    var compose = function compose() {
        if (arguments.length === 0) {
            throw new Error('compose requires at least one argument');
        }
        return pipe.apply(this, reverse(arguments));
    };

    /**
     * Returns the right-to-left Kleisli composition of the provided functions,
     * each of which must return a value of a type supported by [`chain`](#chain).
     *
     * `R.composeK(h, g, f)` is equivalent to `R.compose(R.chain(h), R.chain(g), R.chain(f))`.
     *
     * @func
     * @memberOf R
     * @category Function
     * @see R.pipeK
     * @sig Chain m => ((y -> m z), (x -> m y), ..., (a -> m b)) -> (m a -> m z)
     * @param {...Function}
     * @return {Function}
     * @example
     *
     *      //  parseJson :: String -> Maybe *
     *      //  get :: String -> Object -> Maybe *
     *
     *      //  getStateCode :: Maybe String -> Maybe String
     *      var getStateCode = R.composeK(
     *        R.compose(Maybe.of, R.toUpper),
     *        get('state'),
     *        get('address'),
     *        get('user'),
     *        parseJson
     *      );
     *
     *      getStateCode(Maybe.of('{"user":{"address":{"state":"ny"}}}'));
     *      //=> Just('NY')
     *      getStateCode(Maybe.of('[Invalid JSON]'));
     *      //=> Nothing()
     */
    var composeK = function composeK() {
        return arguments.length === 0 ? identity : compose.apply(this, map(chain, arguments));
    };

    /**
     * Performs right-to-left composition of one or more Promise-returning
     * functions. The rightmost function may have any arity; the remaining
     * functions must be unary.
     *
     * @func
     * @memberOf R
     * @category Function
     * @sig ((y -> Promise z), (x -> Promise y), ..., (a -> Promise b)) -> (a -> Promise z)
     * @param {...Function} functions
     * @return {Function}
     * @see R.pipeP
     * @example
     *
     *      //  followersForUser :: String -> Promise [User]
     *      var followersForUser = R.composeP(db.getFollowers, db.getUserById);
     */
    var composeP = function composeP() {
        if (arguments.length === 0) {
            throw new Error('composeP requires at least one argument');
        }
        return pipeP.apply(this, reverse(arguments));
    };

    /**
     * Wraps a constructor function inside a curried function that can be called with the same
     * arguments and returns the same type.
     *
     * @func
     * @memberOf R
     * @category Function
     * @sig (* -> {*}) -> (* -> {*})
     * @param {Function} Fn The constructor function to wrap.
     * @return {Function} A wrapped, curried constructor function.
     * @example
     *
     *      // Constructor function
     *      var Widget = function(config) {
     *        // ...
     *      };
     *      Widget.prototype = {
     *        // ...
     *      };
     *      var allConfigs = [
     *        // ...
     *      ];
     *      R.map(R.construct(Widget), allConfigs); // a list of Widgets
     */
    var construct = _curry1(function construct(Fn) {
        return constructN(Fn.length, Fn);
    });

    /**
     * Returns `true` if the specified value is equal, in `R.equals` terms,
     * to at least one element of the given list; `false` otherwise.
     *
     * @func
     * @memberOf R
     * @category List
     * @sig a -> [a] -> Boolean
     * @param {Object} a The item to compare against.
     * @param {Array} list The array to consider.
     * @return {Boolean} `true` if the item is in the list, `false` otherwise.
     *
     * @example
     *
     *      R.contains(3, [1, 2, 3]); //=> true
     *      R.contains(4, [1, 2, 3]); //=> false
     *      R.contains([42], [[42]]); //=> true
     */
    var contains = _curry2(_contains);

    /**
     * Finds the set (i.e. no duplicates) of all elements in the first list not contained in the second list.
     *
     * @func
     * @memberOf R
     * @category Relation
     * @sig [a] -> [a] -> [a]
     * @param {Array} list1 The first list.
     * @param {Array} list2 The second list.
     * @return {Array} The elements in `list1` that are not in `list2`.
     * @see R.differenceWith
     * @example
     *
     *      R.difference([1,2,3,4], [7,6,5,4,3]); //=> [1,2]
     *      R.difference([7,6,5,4,3], [1,2,3,4]); //=> [7,6,5]
     */
    var difference = _curry2(function difference(first, second) {
        var out = [];
        var idx = 0;
        var firstLen = first.length;
        while (idx < firstLen) {
            if (!_contains(first[idx], second) && !_contains(first[idx], out)) {
                out[out.length] = first[idx];
            }
            idx += 1;
        }
        return out;
    });

    /**
     * Returns a new list without any consecutively repeating elements.
     * `R.equals` is used to determine equality.
     *
     * Acts as a transducer if a transformer is given in list position.
     * @see R.transduce
     *
     * @func
     * @memberOf R
     * @category List
     * @sig [a] -> [a]
     * @param {Array} list The array to consider.
     * @return {Array} `list` without repeating elements.
     * @example
     *
     *     R.dropRepeats([1, 1, 1, 2, 3, 4, 4, 2, 2]); //=> [1, 2, 3, 4, 2]
     */
    var dropRepeats = _curry1(_dispatchable('dropRepeats', _xdropRepeatsWith(equals), dropRepeatsWith(equals)));

    /**
     * Combines two lists into a set (i.e. no duplicates) composed of those elements common to both lists.
     *
     * @func
     * @memberOf R
     * @category Relation
     * @sig [a] -> [a] -> [a]
     * @param {Array} list1 The first list.
     * @param {Array} list2 The second list.
     * @see R.intersectionWith
     * @return {Array} The list of elements found in both `list1` and `list2`.
     * @example
     *
     *      R.intersection([1,2,3,4], [7,6,5,4,3]); //=> [4, 3]
     */
    var intersection = _curry2(function intersection(list1, list2) {
        return uniq(_filter(flip(_contains)(list1), list2));
    });

    /**
     * "lifts" a function of arity > 1 so that it may "map over" an Array or
     * other Functor.
     *
     * @func
     * @memberOf R
     * @see R.liftN
     * @category Function
     * @sig (*... -> *) -> ([*]... -> [*])
     * @param {Function} fn The function to lift into higher context
     * @return {Function} The function `fn` applicable to mappable objects.
     * @example
     *
     *      var madd3 = R.lift(R.curry(function(a, b, c) {
     *        return a + b + c;
     *      }));
     *      madd3([1,2,3], [1,2,3], [1]); //=> [3, 4, 5, 4, 5, 6, 5, 6, 7]
     *
     *      var madd5 = R.lift(R.curry(function(a, b, c, d, e) {
     *        return a + b + c + d + e;
     *      }));
     *      madd5([1,2], [3], [4, 5], [6], [7, 8]); //=> [21, 22, 22, 23, 22, 23, 23, 24]
     */
    var lift = _curry1(function lift(fn) {
        return liftN(fn.length, fn);
    });

    /**
     * Returns a partial copy of an object omitting the keys specified.
     *
     * @func
     * @memberOf R
     * @category Object
     * @sig [String] -> {String: *} -> {String: *}
     * @param {Array} names an array of String property names to omit from the new object
     * @param {Object} obj The object to copy from
     * @return {Object} A new object with properties from `names` not on it.
     * @see R.pick
     * @example
     *
     *      R.omit(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, c: 3}
     */
    var omit = _curry2(function omit(names, obj) {
        var result = {};
        for (var prop in obj) {
            if (!_contains(prop, names)) {
                result[prop] = obj[prop];
            }
        }
        return result;
    });

    /**
     * Returns the left-to-right Kleisli composition of the provided functions,
     * each of which must return a value of a type supported by [`chain`](#chain).
     *
     * `R.pipeK(f, g, h)` is equivalent to `R.pipe(R.chain(f), R.chain(g), R.chain(h))`.
     *
     * @func
     * @memberOf R
     * @category Function
     * @see R.composeK
     * @sig Chain m => ((a -> m b), (b -> m c), ..., (y -> m z)) -> (m a -> m z)
     * @param {...Function}
     * @return {Function}
     * @example
     *
     *      //  parseJson :: String -> Maybe *
     *      //  get :: String -> Object -> Maybe *
     *
     *      //  getStateCode :: Maybe String -> Maybe String
     *      var getStateCode = R.pipeK(
     *        parseJson,
     *        get('user'),
     *        get('address'),
     *        get('state'),
     *        R.compose(Maybe.of, R.toUpper)
     *      );
     *
     *      getStateCode(Maybe.of('{"user":{"address":{"state":"ny"}}}'));
     *      //=> Just('NY')
     *      getStateCode(Maybe.of('[Invalid JSON]'));
     *      //=> Nothing()
     */
    var pipeK = function pipeK() {
        return composeK.apply(this, reverse(arguments));
    };

    /**
     * Returns the string representation of the given value. `eval`'ing the output
     * should result in a value equivalent to the input value. Many of the built-in
     * `toString` methods do not satisfy this requirement.
     *
     * If the given value is an `[object Object]` with a `toString` method other
     * than `Object.prototype.toString`, this method is invoked with no arguments
     * to produce the return value. This means user-defined constructor functions
     * can provide a suitable `toString` method. For example:
     *
     *     function Point(x, y) {
     *       this.x = x;
     *       this.y = y;
     *     }
     *
     *     Point.prototype.toString = function() {
     *       return 'new Point(' + this.x + ', ' + this.y + ')';
     *     };
     *
     *     R.toString(new Point(1, 2)); //=> 'new Point(1, 2)'
     *
     * @func
     * @memberOf R
     * @category String
     * @sig * -> String
     * @param {*} val
     * @return {String}
     * @example
     *
     *      R.toString(42); //=> '42'
     *      R.toString('abc'); //=> '"abc"'
     *      R.toString([1, 2, 3]); //=> '[1, 2, 3]'
     *      R.toString({foo: 1, bar: 2, baz: 3}); //=> '{"bar": 2, "baz": 3, "foo": 1}'
     *      R.toString(new Date('2001-02-03T04:05:06Z')); //=> 'new Date("2001-02-03T04:05:06.000Z")'
     */
    var toString = _curry1(function toString(val) {
        return _toString(val, []);
    });

    /**
     * Combines two lists into a set (i.e. no duplicates) composed of the
     * elements of each list.
     *
     * @func
     * @memberOf R
     * @category Relation
     * @sig [a] -> [a] -> [a]
     * @param {Array} as The first list.
     * @param {Array} bs The second list.
     * @return {Array} The first and second lists concatenated, with
     *         duplicates removed.
     * @example
     *
     *      R.union([1, 2, 3], [2, 3, 4]); //=> [1, 2, 3, 4]
     */
    var union = _curry2(compose(uniq, _concat));

    /**
     * Returns a new list containing only one copy of each element in the
     * original list, based upon the value returned by applying the supplied
     * function to each list element. Prefers the first item if the supplied
     * function produces the same value on two items. `R.equals` is used for
     * comparison.
     *
     * @func
     * @memberOf R
     * @category List
     * @sig (a -> b) -> [a] -> [a]
     * @param {Function} fn A function used to produce a value to use during comparisons.
     * @param {Array} list The array to consider.
     * @return {Array} The list of unique items.
     * @example
     *
     *      R.uniqBy(Math.abs, [-1, -5, 2, 10, 1, 2]); //=> [-1, -5, 2, 10]
     */
    var uniqBy = _curry2(function uniqBy(fn, list) {
        var idx = 0, applied = [], result = [], appliedItem, item;
        while (idx < list.length) {
            item = list[idx];
            appliedItem = fn(item);
            if (!_contains(appliedItem, applied)) {
                result.push(item);
                applied.push(appliedItem);
            }
            idx += 1;
        }
        return result;
    });

    /**
     * Turns a named method with a specified arity into a function
     * that can be called directly supplied with arguments and a target object.
     *
     * The returned function is curried and accepts `arity + 1` parameters where
     * the final parameter is the target object.
     *
     * @func
     * @memberOf R
     * @category Function
     * @sig Number -> String -> (a -> b -> ... -> n -> Object -> *)
     * @param {Number} arity Number of arguments the returned function should take
     *        before the target object.
     * @param {Function} method Name of the method to call.
     * @return {Function} A new curried function.
     * @example
     *
     *      var sliceFrom = R.invoker(1, 'slice');
     *      sliceFrom(6, 'abcdefghijklm'); //=> 'ghijklm'
     *      var sliceFrom6 = R.invoker(2, 'slice')(6);
     *      sliceFrom6(8, 'abcdefghijklm'); //=> 'gh'
     */
    var invoker = _curry2(function invoker(arity, method) {
        return curryN(arity + 1, function () {
            var target = arguments[arity];
            if (target != null && is(Function, target[method])) {
                return target[method].apply(target, _slice(arguments, 0, arity));
            }
            throw new TypeError(toString(target) + ' does not have a method named "' + method + '"');
        });
    });

    /**
     * Returns a string made by inserting the `separator` between each
     * element and concatenating all the elements into a single string.
     *
     * @func
     * @memberOf R
     * @category List
     * @sig String -> [a] -> String
     * @param {Number|String} separator The string used to separate the elements.
     * @param {Array} xs The elements to join into a string.
     * @return {String} str The string made by concatenating `xs` with `separator`.
     * @see R.split
     * @example
     *
     *      var spacer = R.join(' ');
     *      spacer(['a', 2, 3.4]);   //=> 'a 2 3.4'
     *      R.join('|', [1, 2, 3]);    //=> '1|2|3'
     */
    var join = invoker(1, 'join');

    /**
     * Creates a new function that, when invoked, caches the result of calling `fn` for a given
     * argument set and returns the result. Subsequent calls to the memoized `fn` with the same
     * argument set will not result in an additional call to `fn`; instead, the cached result
     * for that set of arguments will be returned.
     *
     * @func
     * @memberOf R
     * @category Function
     * @sig (*... -> a) -> (*... -> a)
     * @param {Function} fn The function to memoize.
     * @return {Function} Memoized version of `fn`.
     * @example
     *
     *      var count = 0;
     *      var factorial = R.memoize(function(n) {
     *        count += 1;
     *        return R.product(R.range(1, n + 1));
     *      });
     *      factorial(5); //=> 120
     *      factorial(5); //=> 120
     *      factorial(5); //=> 120
     *      count; //=> 1
     */
    var memoize = _curry1(function memoize(fn) {
        var cache = {};
        return function () {
            var key = toString(arguments);
            if (!_has(key, cache)) {
                cache[key] = fn.apply(this, arguments);
            }
            return cache[key];
        };
    });

    /**
     * Splits a string into an array of strings based on the given
     * separator.
     *
     * @func
     * @memberOf R
     * @category String
     * @sig String -> String -> [String]
     * @param {String} sep The separator string.
     * @param {String} str The string to separate into an array.
     * @return {Array} The array of strings from `str` separated by `str`.
     * @see R.join
     * @example
     *
     *      var pathComponents = R.split('/');
     *      R.tail(pathComponents('/usr/local/bin/node')); //=> ['usr', 'local', 'bin', 'node']
     *
     *      R.split('.', 'a.b.c.xyz.d'); //=> ['a', 'b', 'c', 'xyz', 'd']
     */
    var split = invoker(1, 'split');

    /**
     * The lower case version of a string.
     *
     * @func
     * @memberOf R
     * @category String
     * @sig String -> String
     * @param {String} str The string to lower case.
     * @return {String} The lower case version of `str`.
     * @see R.toUpper
     * @example
     *
     *      R.toLower('XYZ'); //=> 'xyz'
     */
    var toLower = invoker(0, 'toLowerCase');

    /**
     * The upper case version of a string.
     *
     * @func
     * @memberOf R
     * @category String
     * @sig String -> String
     * @param {String} str The string to upper case.
     * @return {String} The upper case version of `str`.
     * @see R.toLower
     * @example
     *
     *      R.toUpper('abc'); //=> 'ABC'
     */
    var toUpper = invoker(0, 'toUpperCase');

    var R = {
        F: F,
        T: T,
        __: __,
        add: add,
        addIndex: addIndex,
        adjust: adjust,
        all: all,
        allPass: allPass,
        always: always,
        and: and,
        any: any,
        anyPass: anyPass,
        ap: ap,
        aperture: aperture,
        append: append,
        apply: apply,
        assoc: assoc,
        assocPath: assocPath,
        binary: binary,
        bind: bind,
        both: both,
        call: call,
        chain: chain,
        clone: clone,
        commute: commute,
        commuteMap: commuteMap,
        comparator: comparator,
        complement: complement,
        compose: compose,
        composeK: composeK,
        composeP: composeP,
        concat: concat,
        cond: cond,
        construct: construct,
        constructN: constructN,
        contains: contains,
        containsWith: containsWith,
        converge: converge,
        countBy: countBy,
        createMapEntry: createMapEntry,
        curry: curry,
        curryN: curryN,
        dec: dec,
        defaultTo: defaultTo,
        difference: difference,
        differenceWith: differenceWith,
        dissoc: dissoc,
        dissocPath: dissocPath,
        divide: divide,
        drop: drop,
        dropLast: dropLast,
        dropLastWhile: dropLastWhile,
        dropRepeats: dropRepeats,
        dropRepeatsWith: dropRepeatsWith,
        dropWhile: dropWhile,
        either: either,
        empty: empty,
        eqProps: eqProps,
        equals: equals,
        evolve: evolve,
        filter: filter,
        find: find,
        findIndex: findIndex,
        findLast: findLast,
        findLastIndex: findLastIndex,
        flatten: flatten,
        flip: flip,
        forEach: forEach,
        fromPairs: fromPairs,
        functions: functions,
        functionsIn: functionsIn,
        groupBy: groupBy,
        gt: gt,
        gte: gte,
        has: has,
        hasIn: hasIn,
        head: head,
        identical: identical,
        identity: identity,
        ifElse: ifElse,
        inc: inc,
        indexOf: indexOf,
        init: init,
        insert: insert,
        insertAll: insertAll,
        intersection: intersection,
        intersectionWith: intersectionWith,
        intersperse: intersperse,
        into: into,
        invert: invert,
        invertObj: invertObj,
        invoker: invoker,
        is: is,
        isArrayLike: isArrayLike,
        isEmpty: isEmpty,
        isNil: isNil,
        isSet: isSet,
        join: join,
        keys: keys,
        keysIn: keysIn,
        last: last,
        lastIndexOf: lastIndexOf,
        length: length,
        lens: lens,
        lensIndex: lensIndex,
        lensProp: lensProp,
        lift: lift,
        liftN: liftN,
        lt: lt,
        lte: lte,
        map: map,
        mapAccum: mapAccum,
        mapAccumRight: mapAccumRight,
        mapObj: mapObj,
        mapObjIndexed: mapObjIndexed,
        match: match,
        mathMod: mathMod,
        max: max,
        maxBy: maxBy,
        mean: mean,
        median: median,
        memoize: memoize,
        merge: merge,
        mergeAll: mergeAll,
        min: min,
        minBy: minBy,
        modulo: modulo,
        multiply: multiply,
        nAry: nAry,
        negate: negate,
        none: none,
        not: not,
        nth: nth,
        nthArg: nthArg,
        nthChar: nthChar,
        nthCharCode: nthCharCode,
        of: of,
        omit: omit,
        once: once,
        or: or,
        over: over,
        partial: partial,
        partialRight: partialRight,
        partition: partition,
        path: path,
        pathEq: pathEq,
        pick: pick,
        pickAll: pickAll,
        pickBy: pickBy,
        pipe: pipe,
        pipeK: pipeK,
        pipeP: pipeP,
        pluck: pluck,
        prepend: prepend,
        product: product,
        project: project,
        prop: prop,
        propEq: propEq,
        propIs: propIs,
        propOr: propOr,
        propSatisfies: propSatisfies,
        props: props,
        range: range,
        reduce: reduce,
        reduceRight: reduceRight,
        reduced: reduced,
        reject: reject,
        remove: remove,
        repeat: repeat,
        replace: replace,
        reverse: reverse,
        scan: scan,
        set: set,
        slice: slice,
        sort: sort,
        sortBy: sortBy,
        split: split,
        splitEvery: splitEvery,
        subtract: subtract,
        sum: sum,
        tail: tail,
        take: take,
        takeLast: takeLast,
        takeLastWhile: takeLastWhile,
        takeWhile: takeWhile,
        tap: tap,
        test: test,
        times: times,
        toLower: toLower,
        toPairs: toPairs,
        toPairsIn: toPairsIn,
        toString: toString,
        toUpper: toUpper,
        transduce: transduce,
        trim: trim,
        type: type,
        unapply: unapply,
        unary: unary,
        uncurryN: uncurryN,
        unfold: unfold,
        union: union,
        unionWith: unionWith,
        uniq: uniq,
        uniqBy: uniqBy,
        uniqWith: uniqWith,
        unnest: unnest,
        update: update,
        useWith: useWith,
        values: values,
        valuesIn: valuesIn,
        view: view,
        where: where,
        whereEq: whereEq,
        wrap: wrap,
        xprod: xprod,
        zip: zip,
        zipObj: zipObj,
        zipWith: zipWith
    };

  /* TEST_ENTRY_POINT */

  if (typeof exports === 'object') {
    module.exports = R;
  } else if (typeof define === 'function' && define.amd) {
    define(function() { return R; });
  } else {
    this.R = R;
  }

}.call(this));

},{}],379:[function(require,module,exports){
/*
Slick Finder
*/"use strict"

// Notable changes from Slick.Finder 1.0.x

// faster bottom -> up expression matching
// prefers mental sanity over *obsessive compulsive* milliseconds savings
// uses prototypes instead of objects
// tries to use matchesSelector smartly, whenever available
// can populate objects as well as arrays
// lots of stuff is broken or not implemented

var parse = require("./parser")

// utilities

var index = 0,
    counter = document.__counter = (parseInt(document.__counter || -1, 36) + 1).toString(36),
    key = "uid:" + counter

var uniqueID = function(n, xml){
    if (n === window) return "window"
    if (n === document) return "document"
    if (n === document.documentElement) return "html"

    if (xml) {
        var uid = n.getAttribute(key)
        if (!uid) {
            uid = (index++).toString(36)
            n.setAttribute(key, uid)
        }
        return uid
    } else {
        return n[key] || (n[key] = (index++).toString(36))
    }
}

var uniqueIDXML = function(n) {
    return uniqueID(n, true)
}

var isArray = Array.isArray || function(object){
    return Object.prototype.toString.call(object) === "[object Array]"
}

// tests

var uniqueIndex = 0;

var HAS = {

    GET_ELEMENT_BY_ID: function(test, id){
        id = "slick_" + (uniqueIndex++);
        // checks if the document has getElementById, and it works
        test.innerHTML = '<a id="' + id + '"></a>'
        return !!this.getElementById(id)
    },

    QUERY_SELECTOR: function(test){
        // this supposedly fixes a webkit bug with matchesSelector / querySelector & nth-child
        test.innerHTML = '_<style>:nth-child(2){}</style>'

        // checks if the document has querySelectorAll, and it works
        test.innerHTML = '<a class="MiX"></a>'

        return test.querySelectorAll('.MiX').length === 1
    },

    EXPANDOS: function(test, id){
        id = "slick_" + (uniqueIndex++);
        // checks if the document has elements that support expandos
        test._custom_property_ = id
        return test._custom_property_ === id
    },

    // TODO: use this ?

    // CHECKED_QUERY_SELECTOR: function(test){
    //
    //     // checks if the document supports the checked query selector
    //     test.innerHTML = '<select><option selected="selected">a</option></select>'
    //     return test.querySelectorAll(':checked').length === 1
    // },

    // TODO: use this ?

    // EMPTY_ATTRIBUTE_QUERY_SELECTOR: function(test){
    //
    //     // checks if the document supports the empty attribute query selector
    //     test.innerHTML = '<a class=""></a>'
    //     return test.querySelectorAll('[class*=""]').length === 1
    // },

    MATCHES_SELECTOR: function(test){

        test.className = "MiX"

        // checks if the document has matchesSelector, and we can use it.

        var matches = test.matchesSelector || test.mozMatchesSelector || test.webkitMatchesSelector

        // if matchesSelector trows errors on incorrect syntax we can use it
        if (matches) try {
            matches.call(test, ':slick')
        } catch(e){
            // just as a safety precaution, also test if it works on mixedcase (like querySelectorAll)
            return matches.call(test, ".MiX") ? matches : false
        }

        return false
    },

    GET_ELEMENTS_BY_CLASS_NAME: function(test){
        test.innerHTML = '<a class="f"></a><a class="b"></a>'
        if (test.getElementsByClassName('b').length !== 1) return false

        test.firstChild.className = 'b'
        if (test.getElementsByClassName('b').length !== 2) return false

        // Opera 9.6 getElementsByClassName doesnt detects the class if its not the first one
        test.innerHTML = '<a class="a"></a><a class="f b a"></a>'
        if (test.getElementsByClassName('a').length !== 2) return false

        // tests passed
        return true
    },

    // no need to know

    // GET_ELEMENT_BY_ID_NOT_NAME: function(test, id){
    //     test.innerHTML = '<a name="'+ id +'"></a><b id="'+ id +'"></b>'
    //     return this.getElementById(id) !== test.firstChild
    // },

    // this is always checked for and fixed

    // STAR_GET_ELEMENTS_BY_TAG_NAME: function(test){
    //
    //     // IE returns comment nodes for getElementsByTagName('*') for some documents
    //     test.appendChild(this.createComment(''))
    //     if (test.getElementsByTagName('*').length > 0) return false
    //
    //     // IE returns closed nodes (EG:"</foo>") for getElementsByTagName('*') for some documents
    //     test.innerHTML = 'foo</foo>'
    //     if (test.getElementsByTagName('*').length) return false
    //
    //     // tests passed
    //     return true
    // },

    // this is always checked for and fixed

    // STAR_QUERY_SELECTOR: function(test){
    //
    //     // returns closed nodes (EG:"</foo>") for querySelector('*') for some documents
    //     test.innerHTML = 'foo</foo>'
    //     return !!(test.querySelectorAll('*').length)
    // },

    GET_ATTRIBUTE: function(test){
        // tests for working getAttribute implementation
        var shout = "fus ro dah"
        test.innerHTML = '<a class="' + shout + '"></a>'
        return test.firstChild.getAttribute('class') === shout
    }

}

// Finder

var Finder = function Finder(document){

    this.document        = document
    var root = this.root = document.documentElement
    this.tested          = {}

    // uniqueID

    this.uniqueID = this.has("EXPANDOS") ? uniqueID : uniqueIDXML

    // getAttribute

    this.getAttribute = (this.has("GET_ATTRIBUTE")) ? function(node, name){

        return node.getAttribute(name)

    } : function(node, name){

        node = node.getAttributeNode(name)
        return (node && node.specified) ? node.value : null

    }

    // hasAttribute

    this.hasAttribute = (root.hasAttribute) ? function(node, attribute){

        return node.hasAttribute(attribute)

    } : function(node, attribute) {

        node = node.getAttributeNode(attribute)
        return !!(node && node.specified)

    }

    // contains

    this.contains = (document.contains && root.contains) ? function(context, node){

        return context.contains(node)

    } : (root.compareDocumentPosition) ? function(context, node){

        return context === node || !!(context.compareDocumentPosition(node) & 16)

    } : function(context, node){

        do {
            if (node === context) return true
        } while ((node = node.parentNode))

        return false
    }

    // sort
    // credits to Sizzle (http://sizzlejs.com/)

    this.sorter = (root.compareDocumentPosition) ? function(a, b){

        if (!a.compareDocumentPosition || !b.compareDocumentPosition) return 0
        return a.compareDocumentPosition(b) & 4 ? -1 : a === b ? 0 : 1

    } : ('sourceIndex' in root) ? function(a, b){

        if (!a.sourceIndex || !b.sourceIndex) return 0
        return a.sourceIndex - b.sourceIndex

    } : (document.createRange) ? function(a, b){

        if (!a.ownerDocument || !b.ownerDocument) return 0
        var aRange = a.ownerDocument.createRange(),
            bRange = b.ownerDocument.createRange()

        aRange.setStart(a, 0)
        aRange.setEnd(a, 0)
        bRange.setStart(b, 0)
        bRange.setEnd(b, 0)
        return aRange.compareBoundaryPoints(Range.START_TO_END, bRange)

    } : null

    this.failed = {}

    var nativeMatches = this.has("MATCHES_SELECTOR")

    if (nativeMatches) this.matchesSelector = function(node, expression){

        if (this.failed[expression]) return null

        try {
            return nativeMatches.call(node, expression)
        } catch(e){
            if (slick.debug) console.warn("matchesSelector failed on " + expression)
            this.failed[expression] = true
            return null
        }

    }

    if (this.has("QUERY_SELECTOR")){

        this.querySelectorAll = function(node, expression){

            if (this.failed[expression]) return true

            var result, _id, _expression, _combinator, _node


            // non-document rooted QSA
            // credits to Andrew Dupont

            if (node !== this.document){

                _combinator = expression[0].combinator

                _id         = node.getAttribute("id")
                _expression = expression

                if (!_id){
                    _node = node
                    _id = "__slick__"
                    _node.setAttribute("id", _id)
                }

                expression = "#" + _id + " " + _expression


                // these combinators need a parentNode due to how querySelectorAll works, which is:
                // finding all the elements that match the given selector
                // then filtering by the ones that have the specified element as an ancestor
                if (_combinator.indexOf("~") > -1 || _combinator.indexOf("+") > -1){

                    node = node.parentNode
                    if (!node) result = true
                    // if node has no parentNode, we return "true" as if it failed, without polluting the failed cache

                }

            }

            if (!result) try {
                result = node.querySelectorAll(expression.toString())
            } catch(e){
                if (slick.debug) console.warn("querySelectorAll failed on " + (_expression || expression))
                result = this.failed[_expression || expression] = true
            }

            if (_node) _node.removeAttribute("id")

            return result

        }

    }

}

Finder.prototype.has = function(FEATURE){

    var tested        = this.tested,
        testedFEATURE = tested[FEATURE]

    if (testedFEATURE != null) return testedFEATURE

    var root     = this.root,
        document = this.document,
        testNode = document.createElement("div")

    testNode.setAttribute("style", "display: none;")

    root.appendChild(testNode)

    var TEST = HAS[FEATURE], result = false

    if (TEST) try {
        result = TEST.call(document, testNode)
    } catch(e){}

    if (slick.debug && !result) console.warn("document has no " + FEATURE)

    root.removeChild(testNode)

    return tested[FEATURE] = result

}

var combinators = {

    " ": function(node, part, push){

        var item, items

        var noId = !part.id, noTag = !part.tag, noClass = !part.classes

        if (part.id && node.getElementById && this.has("GET_ELEMENT_BY_ID")){
            item = node.getElementById(part.id)

            // return only if id is found, else keep checking
            // might be a tad slower on non-existing ids, but less insane

            if (item && item.getAttribute('id') === part.id){
                items = [item]
                noId = true
                // if tag is star, no need to check it in match()
                if (part.tag === "*") noTag = true
            }
        }

        if (!items){

            if (part.classes && node.getElementsByClassName && this.has("GET_ELEMENTS_BY_CLASS_NAME")){
                items = node.getElementsByClassName(part.classList)
                noClass = true
                // if tag is star, no need to check it in match()
                if (part.tag === "*") noTag = true
            } else {
                items = node.getElementsByTagName(part.tag)
                // if tag is star, need to check it in match because it could select junk, boho
                if (part.tag !== "*") noTag = true
            }

            if (!items || !items.length) return false

        }

        for (var i = 0; item = items[i++];)
            if ((noTag && noId && noClass && !part.attributes && !part.pseudos) || this.match(item, part, noTag, noId, noClass))
                push(item)

        return true

    },

    ">": function(node, part, push){ // direct children
        if ((node = node.firstChild)) do {
            if (node.nodeType == 1 && this.match(node, part)) push(node)
        } while ((node = node.nextSibling))
    },

    "+": function(node, part, push){ // next sibling
        while ((node = node.nextSibling)) if (node.nodeType == 1){
            if (this.match(node, part)) push(node)
            break
        }
    },

    "^": function(node, part, push){ // first child
        node = node.firstChild
        if (node){
            if (node.nodeType === 1){
                if (this.match(node, part)) push(node)
            } else {
                combinators['+'].call(this, node, part, push)
            }
        }
    },

    "~": function(node, part, push){ // next siblings
        while ((node = node.nextSibling)){
            if (node.nodeType === 1 && this.match(node, part)) push(node)
        }
    },

    "++": function(node, part, push){ // next sibling and previous sibling
        combinators['+'].call(this, node, part, push)
        combinators['!+'].call(this, node, part, push)
    },

    "~~": function(node, part, push){ // next siblings and previous siblings
        combinators['~'].call(this, node, part, push)
        combinators['!~'].call(this, node, part, push)
    },

    "!": function(node, part, push){ // all parent nodes up to document
        while ((node = node.parentNode)) if (node !== this.document && this.match(node, part)) push(node)
    },

    "!>": function(node, part, push){ // direct parent (one level)
        node = node.parentNode
        if (node !== this.document && this.match(node, part)) push(node)
    },

    "!+": function(node, part, push){ // previous sibling
        while ((node = node.previousSibling)) if (node.nodeType == 1){
            if (this.match(node, part)) push(node)
            break
        }
    },

    "!^": function(node, part, push){ // last child
        node = node.lastChild
        if (node){
            if (node.nodeType == 1){
                if (this.match(node, part)) push(node)
            } else {
                combinators['!+'].call(this, node, part, push)
            }
        }
    },

    "!~": function(node, part, push){ // previous siblings
        while ((node = node.previousSibling)){
            if (node.nodeType === 1 && this.match(node, part)) push(node)
        }
    }

}

Finder.prototype.search = function(context, expression, found){

    if (!context) context = this.document
    else if (!context.nodeType && context.document) context = context.document

    var expressions = parse(expression)

    // no expressions were parsed. todo: is this really necessary?
    if (!expressions || !expressions.length) throw new Error("invalid expression")

    if (!found) found = []

    var uniques, push = isArray(found) ? function(node){
        found[found.length] = node
    } : function(node){
        found[found.length++] = node
    }

    // if there is more than one expression we need to check for duplicates when we push to found
    // this simply saves the old push and wraps it around an uid dupe check.
    if (expressions.length > 1){
        uniques = {}
        var plush = push
        push = function(node){
            var uid = uniqueID(node)
            if (!uniques[uid]){
                uniques[uid] = true
                plush(node)
            }
        }
    }

    // walker

    var node, nodes, part

    main: for (var i = 0; expression = expressions[i++];){

        // querySelector

        // TODO: more functional tests

        // if there is querySelectorAll (and the expression does not fail) use it.
        if (!slick.noQSA && this.querySelectorAll){

            nodes = this.querySelectorAll(context, expression)
            if (nodes !== true){
                if (nodes && nodes.length) for (var j = 0; node = nodes[j++];) if (node.nodeName > '@'){
                    push(node)
                }
                continue main
            }
        }

        // if there is only one part in the expression we don't need to check each part for duplicates.
        // todo: this might be too naive. while solid, there can be expression sequences that do not
        // produce duplicates. "body div" for instance, can never give you each div more than once.
        // "body div a" on the other hand might.
        if (expression.length === 1){

            part = expression[0]
            combinators[part.combinator].call(this, context, part, push)

        } else {

            var cs = [context], c, f, u, p = function(node){
                var uid = uniqueID(node)
                if (!u[uid]){
                    u[uid] = true
                    f[f.length] = node
                }
            }

            // loop the expression parts
            for (var j = 0; part = expression[j++];){
                f = []; u = {}
                // loop the contexts
                for (var k = 0; c = cs[k++];) combinators[part.combinator].call(this, c, part, p)
                // nothing was found, the expression failed, continue to the next expression.
                if (!f.length) continue main
                cs = f // set the contexts for future parts (if any)
            }

            if (i === 0) found = f // first expression. directly set found.
            else for (var l = 0; l < f.length; l++) push(f[l]) // any other expression needs to push to found.
        }

    }

    if (uniques && found && found.length > 1) this.sort(found)

    return found

}

Finder.prototype.sort = function(nodes){
    return this.sorter ? Array.prototype.sort.call(nodes, this.sorter) : nodes
}

// TODO: most of these pseudo selectors include <html> and qsa doesnt. fixme.

var pseudos = {


    // TODO: returns different results than qsa empty.

    'empty': function(){
        return !(this && this.nodeType === 1) && !(this.innerText || this.textContent || '').length
    },

    'not': function(expression){
        return !slick.matches(this, expression)
    },

    'contains': function(text){
        return (this.innerText || this.textContent || '').indexOf(text) > -1
    },

    'first-child': function(){
        var node = this
        while ((node = node.previousSibling)) if (node.nodeType == 1) return false
        return true
    },

    'last-child': function(){
        var node = this
        while ((node = node.nextSibling)) if (node.nodeType == 1) return false
        return true
    },

    'only-child': function(){
        var prev = this
        while ((prev = prev.previousSibling)) if (prev.nodeType == 1) return false

        var next = this
        while ((next = next.nextSibling)) if (next.nodeType == 1) return false

        return true
    },

    'first-of-type': function(){
        var node = this, nodeName = node.nodeName
        while ((node = node.previousSibling)) if (node.nodeName == nodeName) return false
        return true
    },

    'last-of-type': function(){
        var node = this, nodeName = node.nodeName
        while ((node = node.nextSibling)) if (node.nodeName == nodeName) return false
        return true
    },

    'only-of-type': function(){
        var prev = this, nodeName = this.nodeName
        while ((prev = prev.previousSibling)) if (prev.nodeName == nodeName) return false
        var next = this
        while ((next = next.nextSibling)) if (next.nodeName == nodeName) return false
        return true
    },

    'enabled': function(){
        return !this.disabled
    },

    'disabled': function(){
        return this.disabled
    },

    'checked': function(){
        return this.checked || this.selected
    },

    'selected': function(){
        return this.selected
    },

    'focus': function(){
        var doc = this.ownerDocument
        return doc.activeElement === this && (this.href || this.type || slick.hasAttribute(this, 'tabindex'))
    },

    'root': function(){
        return (this === this.ownerDocument.documentElement)
    }

}

Finder.prototype.match = function(node, bit, noTag, noId, noClass){

    // TODO: more functional tests ?

    if (!slick.noQSA && this.matchesSelector){
        var matches = this.matchesSelector(node, bit)
        if (matches !== null) return matches
    }

    // normal matching

    if (!noTag && bit.tag){

        var nodeName = node.nodeName.toLowerCase()
        if (bit.tag === "*"){
            if (nodeName < "@") return false
        } else if (nodeName != bit.tag){
            return false
        }

    }

    if (!noId && bit.id && node.getAttribute('id') !== bit.id) return false

    var i, part

    if (!noClass && bit.classes){

        var className = this.getAttribute(node, "class")
        if (!className) return false

        for (part in bit.classes) if (!RegExp('(^|\\s)' + bit.classes[part] + '(\\s|$)').test(className)) return false
    }

    var name, value

    if (bit.attributes) for (i = 0; part = bit.attributes[i++];){

        var operator  = part.operator,
            escaped   = part.escapedValue

        name  = part.name
        value = part.value

        if (!operator){

            if (!this.hasAttribute(node, name)) return false

        } else {

            var actual = this.getAttribute(node, name)
            if (actual == null) return false

            switch (operator){
                case '^=' : if (!RegExp(      '^' + escaped            ).test(actual)) return false; break
                case '$=' : if (!RegExp(            escaped + '$'      ).test(actual)) return false; break
                case '~=' : if (!RegExp('(^|\\s)' + escaped + '(\\s|$)').test(actual)) return false; break
                case '|=' : if (!RegExp(      '^' + escaped + '(-|$)'  ).test(actual)) return false; break

                case '='  : if (actual !== value) return false; break
                case '*=' : if (actual.indexOf(value) === -1) return false; break
                default   : return false
            }

        }
    }

    if (bit.pseudos) for (i = 0; part = bit.pseudos[i++];){

        name  = part.name
        value = part.value

        if (pseudos[name]) return pseudos[name].call(node, value)

        if (value != null){
            if (this.getAttribute(node, name) !== value) return false
        } else {
            if (!this.hasAttribute(node, name)) return false
        }

    }

    return true

}

Finder.prototype.matches = function(node, expression){

    var expressions = parse(expression)

    if (expressions.length === 1 && expressions[0].length === 1){ // simplest match
        return this.match(node, expressions[0][0])
    }

    // TODO: more functional tests ?

    if (!slick.noQSA && this.matchesSelector){
        var matches = this.matchesSelector(node, expressions)
        if (matches !== null) return matches
    }

    var nodes = this.search(this.document, expression, {length: 0})

    for (var i = 0, res; res = nodes[i++];) if (node === res) return true
    return false

}

var finders = {}

var finder = function(context){
    var doc = context || document
    if (doc.ownerDocument) doc = doc.ownerDocument
    else if (doc.document) doc = doc.document

    if (doc.nodeType !== 9) throw new TypeError("invalid document")

    var uid = uniqueID(doc)
    return finders[uid] || (finders[uid] = new Finder(doc))
}

// ... API ...

var slick = function(expression, context){
    return slick.search(expression, context)
}

slick.search = function(expression, context, found){
    return finder(context).search(context, expression, found)
}

slick.find = function(expression, context){
    return finder(context).search(context, expression)[0] || null
}

slick.getAttribute = function(node, name){
    return finder(node).getAttribute(node, name)
}

slick.hasAttribute = function(node, name){
    return finder(node).hasAttribute(node, name)
}

slick.contains = function(context, node){
    return finder(context).contains(context, node)
}

slick.matches = function(node, expression){
    return finder(node).matches(node, expression)
}

slick.sort = function(nodes){
    if (nodes && nodes.length > 1) finder(nodes[0]).sort(nodes)
    return nodes
}

slick.parse = parse;

// slick.debug = true
// slick.noQSA  = true

module.exports = slick

},{"./parser":381}],380:[function(require,module,exports){
(function (global){
/*
slick
*/"use strict"

module.exports = "document" in global ? require("./finder") : { parse: require("./parser") }

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./finder":379,"./parser":381}],381:[function(require,module,exports){
/*
Slick Parser
 - originally created by the almighty Thomas Aylott <@subtlegradient> (http://subtlegradient.com)
*/"use strict"

// Notable changes from Slick.Parser 1.0.x

// The parser now uses 2 classes: Expressions and Expression
// `new Expressions` produces an array-like object containing a list of Expression objects
// - Expressions::toString() produces a cleaned up expressions string
// `new Expression` produces an array-like object
// - Expression::toString() produces a cleaned up expression string
// The only exposed method is parse, which produces a (cached) `new Expressions` instance
// parsed.raw is no longer present, use .toString()
// parsed.expression is now useless, just use the indices
// parsed.reverse() has been removed for now, due to its apparent uselessness
// Other changes in the Expressions object:
// - classNames are now unique, and save both escaped and unescaped values
// - attributes now save both escaped and unescaped values
// - pseudos now save both escaped and unescaped values

var escapeRe   = /([-.*+?^${}()|[\]\/\\])/g,
    unescapeRe = /\\/g

var escape = function(string){
    // XRegExp v2.0.0-beta-3
    // « https://github.com/slevithan/XRegExp/blob/master/src/xregexp.js
    return (string + "").replace(escapeRe, '\\$1')
}

var unescape = function(string){
    return (string + "").replace(unescapeRe, '')
}

var slickRe = RegExp(
/*
#!/usr/bin/env ruby
puts "\t\t" + DATA.read.gsub(/\(\?x\)|\s+#.*$|\s+|\\$|\\n/,'')
__END__
    "(?x)^(?:\
      \\s* ( , ) \\s*               # Separator          \n\
    | \\s* ( <combinator>+ ) \\s*   # Combinator         \n\
    |      ( \\s+ )                 # CombinatorChildren \n\
    |      ( <unicode>+ | \\* )     # Tag                \n\
    | \\#  ( <unicode>+       )     # ID                 \n\
    | \\.  ( <unicode>+       )     # ClassName          \n\
    |                               # Attribute          \n\
    \\[  \
        \\s* (<unicode1>+)  (?:  \
            \\s* ([*^$!~|]?=)  (?:  \
                \\s* (?:\
                    ([\"']?)(.*?)\\9 \
                )\
            )  \
        )?  \\s*  \
    \\](?!\\]) \n\
    |   :+ ( <unicode>+ )(?:\
    \\( (?:\
        (?:([\"'])([^\\12]*)\\12)|((?:\\([^)]+\\)|[^()]*)+)\
    ) \\)\
    )?\
    )"
*/
"^(?:\\s*(,)\\s*|\\s*(<combinator>+)\\s*|(\\s+)|(<unicode>+|\\*)|\\#(<unicode>+)|\\.(<unicode>+)|\\[\\s*(<unicode1>+)(?:\\s*([*^$!~|]?=)(?:\\s*(?:([\"']?)(.*?)\\9)))?\\s*\\](?!\\])|(:+)(<unicode>+)(?:\\((?:(?:([\"'])([^\\13]*)\\13)|((?:\\([^)]+\\)|[^()]*)+))\\))?)"
    .replace(/<combinator>/, '[' + escape(">+~`!@$%^&={}\\;</") + ']')
    .replace(/<unicode>/g, '(?:[\\w\\u00a1-\\uFFFF-]|\\\\[^\\s0-9a-f])')
    .replace(/<unicode1>/g, '(?:[:\\w\\u00a1-\\uFFFF-]|\\\\[^\\s0-9a-f])')
)

// Part

var Part = function Part(combinator){
    this.combinator = combinator || " "
    this.tag = "*"
}

Part.prototype.toString = function(){

    if (!this.raw){

        var xpr = "", k, part

        xpr += this.tag || "*"
        if (this.id) xpr += "#" + this.id
        if (this.classes) xpr += "." + this.classList.join(".")
        if (this.attributes) for (k = 0; part = this.attributes[k++];){
            xpr += "[" + part.name + (part.operator ? part.operator + '"' + part.value + '"' : '') + "]"
        }
        if (this.pseudos) for (k = 0; part = this.pseudos[k++];){
            xpr += ":" + part.name
            if (part.value) xpr += "(" + part.value + ")"
        }

        this.raw = xpr

    }

    return this.raw
}

// Expression

var Expression = function Expression(){
    this.length = 0
}

Expression.prototype.toString = function(){

    if (!this.raw){

        var xpr = ""

        for (var j = 0, bit; bit = this[j++];){
            if (j !== 1) xpr += " "
            if (bit.combinator !== " ") xpr += bit.combinator + " "
            xpr += bit
        }

        this.raw = xpr

    }

    return this.raw
}

var replacer = function(
    rawMatch,

    separator,
    combinator,
    combinatorChildren,

    tagName,
    id,
    className,

    attributeKey,
    attributeOperator,
    attributeQuote,
    attributeValue,

    pseudoMarker,
    pseudoClass,
    pseudoQuote,
    pseudoClassQuotedValue,
    pseudoClassValue
){

    var expression, current

    if (separator || !this.length){
        expression = this[this.length++] = new Expression
        if (separator) return ''
    }

    if (!expression) expression = this[this.length - 1]

    if (combinator || combinatorChildren || !expression.length){
        current = expression[expression.length++] = new Part(combinator)
    }

    if (!current) current = expression[expression.length - 1]

    if (tagName){

        current.tag = unescape(tagName)

    } else if (id){

        current.id = unescape(id)

    } else if (className){

        var unescaped = unescape(className)

        var classes = current.classes || (current.classes = {})
        if (!classes[unescaped]){
            classes[unescaped] = escape(className)
            var classList = current.classList || (current.classList = [])
            classList.push(unescaped)
            classList.sort()
        }

    } else if (pseudoClass){

        pseudoClassValue = pseudoClassValue || pseudoClassQuotedValue

        ;(current.pseudos || (current.pseudos = [])).push({
            type         : pseudoMarker.length == 1 ? 'class' : 'element',
            name         : unescape(pseudoClass),
            escapedName  : escape(pseudoClass),
            value        : pseudoClassValue ? unescape(pseudoClassValue) : null,
            escapedValue : pseudoClassValue ? escape(pseudoClassValue) : null
        })

    } else if (attributeKey){

        attributeValue = attributeValue ? escape(attributeValue) : null

        ;(current.attributes || (current.attributes = [])).push({
            operator     : attributeOperator,
            name         : unescape(attributeKey),
            escapedName  : escape(attributeKey),
            value        : attributeValue ? unescape(attributeValue) : null,
            escapedValue : attributeValue ? escape(attributeValue) : null
        })

    }

    return ''

}

// Expressions

var Expressions = function Expressions(expression){
    this.length = 0

    var self = this

    var original = expression, replaced

    while (expression){
        replaced = expression.replace(slickRe, function(){
            return replacer.apply(self, arguments)
        })
        if (replaced === expression) throw new Error(original + ' is an invalid expression')
        expression = replaced
    }
}

Expressions.prototype.toString = function(){
    if (!this.raw){
        var expressions = []
        for (var i = 0, expression; expression = this[i++];) expressions.push(expression)
        this.raw = expressions.join(", ")
    }

    return this.raw
}

var cache = {}

var parse = function(expression){
    if (expression == null) return null
    expression = ('' + expression).replace(/^\s+|\s+$/g, '')
    return cache[expression] || (cache[expression] = new Expressions(expression))
}

module.exports = parse

},{}],382:[function(require,module,exports){

/**
 * `Batch' constructor
 *
 * @api public
 * @param {Number} max - optional (Default: Infinity)
 */

module.exports = Batch;
function Batch (max) {
  if (!(this instanceof Batch)) {
    return new Batch(max);
  }

  var self = this;

  this.m = 0; // max
  this.c = 0; // concurrency
  this.jobs = [];

  this.concurrency(Infinity);
  this.max(max);

  Object.defineProperty(this, 'length', {
    get: function () {
      return self.jobs.length;
    }
  });
}

/**
 * Set batch concurrency
 *
 * @api public
 * @param {Number} n
 */

Batch.prototype.concurrency = function (n) {
  if (n > 0) {
    this.c = n;
  }
  return this;
};

/**
 * Set max job limit
 *
 * @api publc
 * @param {Number} n
 */

Batch.prototype.max = function (n) {
  this.m = 'number' == typeof n && n > 0 ? n : Infinity;
  return this;
};

/**
 * Push job onto queue
 *
 * @api publc
 * @param {Function} fn
 */

Batch.prototype.push = function (fn) {
  if ('function' != typeof fn) {
    throw new TypeError("expecting a function");
  } else if (this.length < this.m) {
    this.jobs.push(fn);
  }
  return this;
};

/**
 * Shift job off of queue
 *
 * @api public
 */

Batch.prototype.shift = function () {
  return this.jobs.shift();
};

/**
 * Dequeues all queued jobs
 *
 * @api public
 * @param {Function} done - optional
 */

Batch.prototype.run = function (done) {
  done = 'function' == typeof done ? done : Function();
  var self = this;
  var c = this.c;
  var i = 0;

  // empty queue
  if (0 == this.length) {
    return done(null);
  }

  function dequeue  () {
    var job = null;
    if (0 == self.length) {
      return false;
    }

    job = self.shift();

    if ('function' != typeof job) {
      return;
    }

    try { job(next); }
    catch (err) {
      done(err)
      return false;
    }

    function next (err) {
      if (err) {
        done(err);
      } else if (self.length) {
        dequeue();
      } else {
        done();
      }
    }
  }

  while (i++ < c) {
    if (false === dequeue()) {
      break;
    }
  }

  return this;
};

},{}],383:[function(require,module,exports){
/*jslint node: true */

'use strict';

var ClientRequest = require('./request').ClientRequest;

/**
 * An autoincremented id that is used to distinguish Resolver instances.
 *
 * @type {number}
 * @private
 */
var resolverUID = 0;

/**
 * A resolver takes a request for a resources and sends it through the
 * transport.
 *
 * @constructs Resolver
 */
function Resolver() {
  if (!(this instanceof Resolver))
    return new Resolver();

  /**
   * The resolver's id.
   *
   * @type {number}
   * @protected
   */
  this._id = resolverUID++;

  /**
   * An incrementing ID used for tracking requests.
   *
   * @type {number}
   * @protected
   */
  this._requestID = 0;

  /**
   * Storage for the sent request handlers waiting for a response.
   *
   * @type {Object.<string, function>}
   * @protected
   */
  this._handlers = {};
}
exports.Resolver = Resolver;

/**
 * Adds a handler to the internal storage.
 *
 * @param {number} requestID The identifier for the request.
 * @param {ClientRequest} handler The handler for the request.
 * @protected
 */
Resolver.prototype._addHandler = function(requestID, handler) {
  this._handlers[requestID] = handler;
  return this;
};

/**
 * Removes a handler from the internal storage.
 *
 * @param {number} requestID The identifier for the request.
 * @protected
 */
Resolver.prototype._removeHandler = function(requestID) {
  this._handlers[requestID] = null;
  return this;
};

/**
 * Sends a request through the transport.
 *
 * Subclasses of this class need to implement this method.
 *
 * @param {number} requestID The id of the request.
 * @param {Object} data The payload data for the request.
 * @protected
 */
Resolver.prototype._sendRequest = function(requestID, data) {
  throw new Error('Resolver _sendRequest not implemented.');
};

/**
 * Handles a response from the transport.
 *
 * @param {Object} response The response from the transport.
 * @protected
 */
Resolver.prototype._handleResponse = function(response) {
  throw new Error('Resolver _handleResponse not implemented.');
};

/**
 * Dispatches a request handler with some data.
 *
 * @param {number} requestID The request handler to dispatch.
 * @param {Object} data The response data to send back.
 * @protected
 */
Resolver.prototype._dispatchResponse = function(requestID, requestType, data) {
  var handler = this._handlers[requestID];
  if (!handler) return;
  handler._handleResponse(requestType, data);
};

/**
 * Resolves a request (represented by the data) through the transport.
 *
 * @param {Object} data The data representing the request.
 * @param {function} onsuccess The success handler for the request.
 * @param {function} onerror The error handler for the request.
 */
Resolver.prototype._resolve = function(data, onsuccess, onerror) {
  if (!data || !onsuccess || !onerror ||
      typeof onsuccess != 'function' || typeof onerror != 'function')
    throw new TypeError('Invalid argument length for `resolve`.');

  var requestID = ++this._requestID;
  var request = new ClientRequest(this, requestID, data, onsuccess, onerror);

  this._addHandler(requestID, request);

  request.onClose = this._removeHandler.bind(this);
  request.open();

  return request;
};

/**
 * Resolves a single request (represented by the data) through the transport.
 *
 * @param {Object} data The data representing the request.
 * @param {function} onsuccess The success handler for the request.
 * @param {function} onerror The error handler for the request.
 */
Resolver.prototype.resolve = function(data, onsuccess, onerror) {
  throw new Error('Resolver resolve not implemented.');
};

/**
 * Resolves a subscription request (represented by the data) through the transport.
 *
 * @param {Object} data The data representing the request.
 * @param {function} onsuccess The success handler for the request.
 * @param {function} onerror The error handler for the request.
 */
Resolver.prototype.subscribe = function(data, onsuccess, onerror) {
  throw new Error('Resolver subscribe not implemented.');
};

},{"./request":387}],384:[function(require,module,exports){
(function (global){
/*jslint node: true */

'use strict';

var defer = require('spotify-deferred');
var Resolver = require('./bootstrap').Resolver;

/**
 * A mock resolver for a nodejs environment.
 *
 * This resolver uses regular callbacks as a transport.
 *
 * @constructs Cosmos.MockResolver
 * @extends Cosmos.Resolver
 */
function MockResolver() {
  if (!(this instanceof MockResolver))
    return new MockResolver();
  Resolver.call(this);

  // rebind the _handleResponse method so that we can reuse it for both
  // addEventListener and removeEventListener
  this._handleResponse = this._handleResponse.bind(this);

  /**
   * The identifier for request messages.
   *
   * @type {string}
   * @protected
   */
  this._requestMessageType = 'cosmos-request';

  /**
   * The identifier for response messages.
   *
   * @type {string}
   * @protected
   */
  this._responseMessageType = 'cosmos-response';

  /**
   * Prefix for the requests ids to prevent clashes
   * with bridge requests in webplayer
   *
   * @type {string}
   * @private
   */
  this._requestIdPrefix = 'cosmos_';

  this._handlersMap = {};

  // attach the handler
  this.attach();
}
MockResolver.prototype = new Resolver();
MockResolver.prototype.constructor = MockResolver;
exports.MockResolver = MockResolver;

/**
 * @inheritDoc
 */
MockResolver.prototype._sendRequest = function(requestName, requestID, data) {
  var self = this;

  var message = {
    type: this._requestMessageType,
    resolver: this._id,
    id: this._requestIdPrefix + requestID,
    name: requestName,
    payload: data.serialize ? data.serialize() : data
  };

  if (!this._handlersMap[data._action]) {
    return;
  }

  if (!this._handlersMap[data._action][data._uri]) {
    return;
  }

  this._handlersMap[data._action][data._uri](data, function (status, resp) {
    message.payload = {
      body: typeof resp !== 'undefined' ? resp : status,
      uri: data._uri,
      status: typeof resp !== 'undefined' ? status : 200
    };
    message.type = self._responseMessageType;

    var response = {
      data: message
    };
    self._handleResponse(response);
  });
};

/**
 * @inheritDoc
 */
MockResolver.prototype._handleResponse = function(response) {
  var data = response.data;
  if (typeof data == 'string') {
    try {
      data = JSON.parse(response.data);
    } catch (e) {
      return;
    }
  }
  if (data.type != this._responseMessageType ||
      data.resolver != this._id ||
      !data.payload) return;
  var id = data.id || '';
  var requestID = parseInt(id.replace(this._requestIdPrefix, ''), 10);
  var requestName = data.name || '';
  if (!requestID || !requestName) return;
  this._dispatchResponse(requestID, requestName, data.payload);
};

/**
 * Attaches the resolver so that it could process calls from the window object.
 */
MockResolver.prototype.attach = function() {
  var win = global.window;
  if (win) {
    win._cosmosRequest = this.resolve.bind(this);
  }
};

/**
 * Detaches the resolver so that it doesn't process calls from the window object.
 */
MockResolver.prototype.detach = function() {
  var win = global.window;
  if (win) {
    delete win._cosmosRequest;
  }
};

/**
 * Specific method for the mock resolver to add request handlers
 *
 * @param {string}   method       Type of method (GET, POST, PUT, SUB)
 * @param {string}   uri          Request to handle
 * @param {Function} fn           Function that handles the request
 */
MockResolver.prototype.addHandler = function(method, uri, fn) {
  if (!this._handlersMap[method]) {
    this._handlersMap[method] = {};
  }

  this._handlersMap[method][uri] = fn;
};

/**
 * Specific method for the mock resolver to remove a specific request handler
 *
 * @param {string}   method       Type of method (GET, POST, PUT, SUB)
 * @param {string}   uri          Request to handle
 */
MockResolver.prototype.removeHandler = function(method, uri) {
  if (!this._handlersMap[method]) {
    return;
  }

  if (this._handlersMap[method][uri]) {
    delete this._handlersMap[method][uri];
  }
};

/**
 * Specific method for the mock resolver to remove all handlers
 */
MockResolver.prototype.clearHandlers = function() {
  this._handlersMap = {};
};

/**
 * Resolves a single request (represented by the data) through the transport.
 * Single requests need to be closed immediately after the response is
 * received.
 *
 * @param {Object} data The data representing the request.
 * @param {function} onsuccess The success handler for the request.
 * @param {function} onerror The error handler for the request.
 */
MockResolver.prototype.resolve = function(data, onsuccess, onerror) {
  function onResult(callback, response) {
    defer(callback.bind(this, response));
    request.close();
  }

  var request = this._resolve(data, onResult.bind(this, onsuccess), onResult.bind(this, onerror));
  return request;
};

/**
 * Resolves a  subscription request (represented by the data) through the transport.
 * Subscriptions stay open until they're explicitly closed.
 * Every time the request returns some data pull for next
 * batch is sent.
 *
 * @param {Object} data The data representing the request.
 * @param {function} onsuccess The success handler for the request.
 * @param {function} onerror The error handler for the request.
 */
MockResolver.prototype.subscribe = function(data, onsuccess, onerror) {
  return this._resolve(data, onsuccess, onerror);
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./bootstrap":383,"spotify-deferred":390}],385:[function(require,module,exports){
(function (global){
/*jslint node: true */

'use strict';

var SpotifyApi = global.SpotifyApi;
var useApiRequest = !!(SpotifyApi && SpotifyApi.api &&
    typeof SpotifyApi.api.request === 'function');

var Resolver = require('./bootstrap').Resolver;
var defer = require('spotify-deferred');

/**
 * A resolver for a native environment.
 *
 * This resolver uses the Stitch bridge as a transport
 *
 * @constructs Cosmos.NativeResolver
 * @extends Cosmos.Resolver
 * @param {Object} spBridge Spotify CPP/JS bridge
 */
function NativeResolver(spBridge) {
  if (!(this instanceof NativeResolver))
    return new NativeResolver();
  if (!spBridge) {
    throw new TypeError('Missing `spBridge` parameter');
  }
  Resolver.call(this);

  this._bridge = spBridge;

  this._deferredFlush = false;
}
NativeResolver.prototype = new Resolver();
NativeResolver.prototype.constructor = NativeResolver;
exports.NativeResolver = NativeResolver;

/**
 * Prepare bridge flush.
 * TODO: Move to the separate module
 */
NativeResolver.prototype._prepareCoreFlush = function() {
  if (!this._deferredFlush) {
    this._deferredFlush = true;
    this._defer(this, this._flushRequests);
  }
};

/**
 * Flush bridge requests.
 * TODO: Move to the separate module
 */
NativeResolver.prototype._flushRequests = function() {
  this._deferredFlush = false;
  var flushMsg = JSON.stringify({ name: 'core_flush', args: []});
  this._sendBridgeRequest(flushMsg, {
    onSuccess: function() {},
    onFailure: function() {}
  });
};

/**
 * Defer the function call.
 * TODO: Move to the separate module
 */
NativeResolver.prototype._defer = function(context, callback) {
  defer(callback.bind(context));
};

/**
 * If SpotifyApi is loaded, use api requests to send messages to bridge
 * TODO: Use proxy that will handle Cosmos/Stitch calls for the resolver.
 */
NativeResolver.prototype._sendRequest = function(requestName, requestId, data) {
  var self = this;
  data = (data.serialize ? data.serialize() : data);

  var args = [requestId, data];
  var caller = { self: this, id: requestId, type: requestName };

  if (useApiRequest) {
    this._sendApiRequest(requestName, args, caller, this._handleResponse, this._handleError);
  } else {
    this._sendCosmosRequest(requestName, args, caller, this._handleResponse, this._handleError);
  }
};


/**
 * Talk to bridge directly from Cosmos
 * TODO: Move to the separate module
 */
NativeResolver.prototype._sendCosmosRequest = function(requestName, args, caller, onSuccess, onError) {
  var message = JSON.stringify({
    name: requestName,
    args: args
  });

  this._sendBridgeRequest(message, {
    onSuccess: function(data) {
      onSuccess.call(caller, JSON.parse(data));
    },
    onFailure: function(data) {
      data = JSON.parse(data);
      onError.call(caller, data);
    }
  });

  this._prepareCoreFlush();
};

/**
 * Send message to the bridge
 * @param {string} message The message to send to the bridge.
 * @param {Object.<string, function>} callbackMap The `onSuccess`
 * and `onFailure` functions to be executed after request is completed.
 * TODO: Use proxy that will handle Cosmos/Stitch calls for the resolver.
 */
NativeResolver.prototype._sendBridgeRequest = function(message, callbackMap) {
  this._bridge.executeRequest(message, callbackMap || {});
};

/**
 * Use old API to send messages to the bridge.
 * TODO: Move to the separate module
 */
NativeResolver.prototype._sendApiRequest = function(requestName, args, caller, onSuccess, onError) {
  SpotifyApi.api.request(
      requestName,
      args,
      caller,
      onSuccess,
      onError
  );
};

/**
 * Handles successful responses from the bridge
 * @param {Object} data The response data.
 */
NativeResolver.prototype._handleResponse = function(data) {
  this.self._dispatchResponse(this.id, this.type, data.responses && data.responses[0] || data);
};

/**
 * Handles failed responses from the bridge
 * @param {Object} error The error data.
 */
NativeResolver.prototype._handleError = function(error) {
  this.self._dispatchResponse(this.id, this.type, error);
};

/**
 * Resolves a single request (represented by the data) through the transport.
 * Single requests need to be closed immediately after the response is
 * received.
 *
 * @param {Object} data The data representing the request.
 * @param {function} onsuccess The success handler for the request.
 * @param {function} onerror The error handler for the request.
 */
NativeResolver.prototype.resolve = function(data, onsuccess, onerror) {
  function onResult(callback, response) {
    this._defer(this, callback.bind(this, response));
    request.close();
  }

  var request = this._resolve(data, onResult.bind(this, onsuccess), onResult.bind(this, onerror));
  return request;
};

/**
 * Resolves a  subscription request (represented by the data) through the transport.
 * Subscriptions stay open until they're explicitly closed.
 * Every time the request returns some data pull for next
 * batch is sent.
 *
 * @param {Object} data The data representing the request.
 * @param {function} onsuccess The success handler for the request.
 * @param {function} onerror The error handler for the request.
 */
NativeResolver.prototype.subscribe = function(data, onsuccess, onerror) {
  function onResult(callback, response) {
    callback.call(this, response);
    request.pull();
  }

  var request = this._resolve(data, onResult.bind(this, onsuccess), onResult.bind(this, onerror));
  return request;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./bootstrap":383,"spotify-deferred":390}],386:[function(require,module,exports){
(function (global){
/*jslint node: true */

'use strict';

var defer = require('spotify-deferred');
var Resolver = require('./bootstrap').Resolver;

/**
 * A resolver for a web-based environment.
 *
 * This resolver uses postMessage as a transport.
 *
 * @constructs Cosmos.WebResolver
 * @extends Cosmos.Resolver
 * @type {string=} opt_target The optional target for the postMessage calls.
 */
function WebResolver(opt_target) {
  if (!(this instanceof WebResolver))
    return new WebResolver(opt_target);
  Resolver.call(this);

  /**
   * The target for postMessage calls.
   *
   * @type {string}
   * @protected
   */
  this._target = opt_target || '*';

  // rebind the _handleResponse method so that we can reuse it for both
  // addEventListener and removeEventListener
  this._handleResponse = this._handleResponse.bind(this);

  /**
   * The identifier for request messages.
   *
   * @type {string}
   * @protected
   */
  this._requestMessageType = 'cosmos-request';

  /**
   * The identifier for response messages.
   *
   * @type {string}
   * @protected
   */
  this._responseMessageType = 'cosmos-response';

  /**
   * Prefix for the requests ids to prevent clashes
   * with bridge requests in webplayer
   *
   * @type {string}
   * @private
   */
  this._requestIdPrefix = 'cosmos_';

  // attach the handler
  this.attach();
}
WebResolver.prototype = new Resolver();
WebResolver.prototype.constructor = WebResolver;
exports.WebResolver = WebResolver;

/**
 * @inheritDoc
 */
WebResolver.prototype._sendRequest = function(requestName, requestID, data) {
  var top = global.window.top;

  var message = {
    type: this._requestMessageType,
    resolver: this._id,
    id: this._requestIdPrefix + requestID,
    name: requestName,
    payload: data.serialize ? data.serialize() : data
  };
  top.postMessage(JSON.stringify(message), this._target);
};

/**
 * @inheritDoc
 */
WebResolver.prototype._handleResponse = function(response) {
  var data = response.data;
  if (typeof data == 'string') {
    try {
      data = JSON.parse(response.data);
    } catch (e) {
      return;
    }
  }
  if (data.type != this._responseMessageType ||
      data.resolver != this._id ||
      !data.payload) return;
  var id = data.id || '';
  var requestID = parseInt(id.replace(this._requestIdPrefix, ''), 10);
  var requestName = data.name || '';
  if (!requestID || !requestName) return;
  this._dispatchResponse(requestID, requestName, data.payload);
};

/**
 * Attaches the resolver so that it could process postMessage calls.
 */
WebResolver.prototype.attach = function() {
  var win = global.window;
  if (win.addEvent && !win.addEventListener) {
    win.addEvent('onmessage', this._handleResponse);
  } else {
    win.addEventListener('message', this._handleResponse, false);
  }
};

/**
 * Detaches the resolver so that it doesn't process postMessage calls.
 */
WebResolver.prototype.detach = function() {
  var win = global.window;
  if (win.removeEvent && !win.removeEventListener) {
    win.removeEvent('onmessage', this._handleResponse);
  } else {
    win.removeEventListener('message', this._handleResponse, false);
  }
};

/**
 * Resolves a single request (represented by the data) through the transport.
 * Single requests need to be closed immediately after the response is
 * received.
 *
 * @param {Object} data The data representing the request.
 * @param {function} onsuccess The success handler for the request.
 * @param {function} onerror The error handler for the request.
 */
WebResolver.prototype.resolve = function(data, onsuccess, onerror) {
  function onResult(callback, response) {
    defer(callback.bind(this, response));
    request.close();
  }

  var request = this._resolve(data, onResult.bind(this, onsuccess), onResult.bind(this, onerror));
  return request;
};

/**
 * Resolves a  subscription request (represented by the data) through the transport.
 * Subscriptions stay open until they're explicitly closed.
 * Every time the request returns some data pull for next
 * batch is sent.
 *
 * @param {Object} data The data representing the request.
 * @param {function} onsuccess The success handler for the request.
 * @param {function} onerror The error handler for the request.
 */
WebResolver.prototype.subscribe = function(data, onsuccess, onerror) {
  return this._resolve(data, onsuccess, onerror);
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./bootstrap":383,"spotify-deferred":390}],387:[function(require,module,exports){
/*jslint node: true */

'use strict';

var defer = require('spotify-deferred');

/**
 * The representation of the connection to the client.
 * With introduction of Cosmos subscription the model of making
 * client requests changed.
 * Each Cosmos requests now needs to be explicitly cancelled to
 * close the connection.
 * Simple requests that only send or retrieve data (e.g POST and GET)
 * need to send 'cosmos_request_cancel' message immediately after the response
 * is received.
 * Subscription requests need to send a 'cosmos_request_pull' message every time
 * they receive data. The consumer of the subscription needs to cancel the subscription
 * when no more data should be sent from the provider.
 */
function ClientRequest(resolver, requestId, data, onsuccess, onerror) {

  /**
   * Request identifier.
   * @type {number}
   */
  this._requestId = requestId;

  /**
   * Either web or native request resolver.
   * @type {Cosmos.Resolver}
   */
  this._resolver = resolver;

  /**
   * Data that should be passed with every request.
   * @type {*}
   */
  this._requestData = data;

  /**
   * Triggered on success
   * @type {function}
   */
  this._successCallback = onsuccess;

  /**
   * Triggered on error
   * @type {function}
   */
  this._errorCallback = onerror;

  /**
   * Current state of the request.
   * @type {ClientRequest.status}
   */
  this._status = ClientRequest.status.INITIALIZED;
}
exports.ClientRequest = ClientRequest;

/**
 * Possible state of the ClientRequest instance.
 */
ClientRequest.status = {
  INITIALIZED: 'INITIALIZED',
  CLOSED: 'CLOSED',
  OPEN: 'OPEN'
};

/**
 * Possible desktop bridge messages.
 */
ClientRequest.messages = {
  OPEN: 'cosmos_request_create',
  PULL: 'cosmos_request_pull',
  CLOSE: 'cosmos_request_cancel'
};

/**
 * Opens the connection with the client.
 */
ClientRequest.prototype.open = function() {
  if (this._status === ClientRequest.status.INITIALIZED) {
    this._status = ClientRequest.status.OPEN;
    this._sendRequest(ClientRequest.messages.OPEN, this._requestData);
  }
};

/**
 * Send pull request for the open connection.
 * For subscriptions pull should resolve to a
 * piece of data.
 */
ClientRequest.prototype.pull = function() {
  if (this._status === ClientRequest.status.OPEN) {
    this._sendRequest(ClientRequest.messages.PULL, this._requestData);
  }
  return this._status;
};

/**
 * Closes the connection with the client.
 */
ClientRequest.prototype.close = function() {
  if (this._status === ClientRequest.status.OPEN) {
    this._status = ClientRequest.status.CLOSE;
    this._sendRequest(ClientRequest.messages.CLOSE);
  }
};

ClientRequest.prototype.onClose = function() {};

/**
 * Sends the request to the platform specific resolver
 * @param {string} requestName The message type. One of the {ClientRequest.messages}.
 * @param {object?} data The data to send with the request.
 */
ClientRequest.prototype._sendRequest = function(requestName, data) {
  this._resolver._sendRequest(requestName, this._requestId, data || {});
};

/**
 * Handles the response for the given request
 * @param {String} requestName The message type. One of the {ClientRequest.messages}.
 * @param {Object} data The response data.
 */
ClientRequest.prototype._handleResponse = function(requestName, data) {
  var self = this;
  var status = data && data.status;
  var callback;

  if (requestName === ClientRequest.messages.CLOSE) {
    this._successCallback = null;
    this._errorCallback = null;
    this._requestData = null;
    this.onClose(this._requestId);
    return;
  }

  callback = this._successCallback;
  callback = typeof callback === 'function' ? callback : function() {};
  defer(callback.bind(this, data));
};

},{"spotify-deferred":390}],388:[function(require,module,exports){
(function (global){
'use strict';

var window = global.window || {};
var process = global.process;

var common = require('cosmos-common-js');
var Resolver = require('./scripts/resolver').Resolver;

var SPResolver = null;
var spResolver = null;

var hasNativeBridge = window._getSpotifyModule &&
    typeof window._getSpotifyModule === 'function' &&
    window._getSpotifyModule('bridge');

var nodeRegex = /(node)|(grunt)|(iojs)(\.exe)*$/;
var isNodeJs = process && process.title && nodeRegex.test(process.argv[0]);

if (!isNodeJs) {
  if (hasNativeBridge) {
    SPResolver = require('./env/bootstrap.native.js').NativeResolver;
    spResolver = new SPResolver(hasNativeBridge);
  } else {
    SPResolver = require('./env/bootstrap.web.js').WebResolver;
    spResolver = new SPResolver();
  }
} else {
  SPResolver = require('./env/bootstrap.mock.js').MockResolver;
  spResolver = new SPResolver();

  exports.mockResolver = {
    addHandler: spResolver.addHandler.bind(spResolver),
    removeHandler: spResolver.removeHandler.bind(spResolver),
    clearHandlers: spResolver.clearHandlers.bind(spResolver)
  };
}

exports.Resolver = Resolver;
exports.Action = common.request.Action;
exports.Request = common.request.Request;
exports.Response = common.response.Response;
exports.resolver = spResolver ? new Resolver(spResolver) : null;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./env/bootstrap.mock.js":384,"./env/bootstrap.native.js":385,"./env/bootstrap.web.js":386,"./scripts/resolver":391,"cosmos-common-js":282}],389:[function(require,module,exports){
/**
 * @file
 * Unified window messaging facility.
 *
 * This module exports two functions to the Spotify
 * namespace which allows other subsystems to handle
 * particular types of messages sent through the native
 * window.postMessage method.
 *
 * @see Spotify.addMessageHandler
 * @see Spotify.removeMessageHandler
 */
'use strict';

var POST_ROUTER_ID = 'post-router-msg-' + new Date().getTime();

var hasStructuredClone = false;

var setImmediate = setImmediate ? setImmediate : setTimeout;

var CURRENT_WINDOW_ORIGIN = undefined;

if (typeof window !== 'undefined') {
  CURRENT_WINDOW_ORIGIN = (window.location.origin ||
      window.location.protocol + '//' + window.location.hostname);

  // Hacky solution to make it work for the webplayer.
  if (!window.__forceNoStructuredClone) {
    // Check if the platform has support for structured cloning.
    //
    // In platforms where this is supported, sending a postMessage with an
    // object that contains a function will throw an error, as it is not
    // cloneable.
    try {
      window.postMessage({
        toString: function() {
          return "clone-test";
        }
      }, CURRENT_WINDOW_ORIGIN);
      hasStructuredClone = false;
    } catch(e) {
      hasStructuredClone = true;
    }
  }
}

/**
 * Storage for message handlers.
 *
 * @type {Object.<string, Spotify.Shell.MessageHandler>}
 * @private
 */
var handlers = {};


/**
 * Variable to check if the window is already listening to postMessage events
 *
 * @type {bool}
 * @private
 */
var isListening = false;


function handleImmediateMessage(data) {
  var handler = handlers[data.type];
  if (!handler) return;
  handler.fn.call(this, data);
}


/**
 * Main event handler for the window message event.
 *
 * @param {Event} event The message event object.
 * @private
 */
function handlePostMessage(event) {
  var data = event.data;
  if (!hasStructuredClone) {
    if (typeof data == 'string') {
      try {
        data = JSON.parse(data);
      } catch (e) {
        return;
      }
    } else {
      // We only expect strings.
      return;
    }
  }
  if (event.origin == CURRENT_WINDOW_ORIGIN) {
    data = data[POST_ROUTER_ID];
    if (!data) {
      // Not our data, return immediately.
      return;
    }
  }
  var handler = handlers[data.type];
  if (!handler || handler.origin != '*' && event.origin !== handler.origin) {
    return;
  }
  handler.fn.call(this, data, event);
}

/**
 * Attaches the handlePostMessage function to PostMessage events
 *
 * @private
 */
var startListening = function() {
  if (window.attachEvent && !window.addEventListener) {
    // IE8 and Below
    window.attachEvent('onmessage', handlePostMessage);
  } else if (window.attachEvent && window.addEventListener) {
    // IE9
    window.addEventListener('message', handlePostMessage, false);
  } else if (window.addEventListener) {
    // Everyone else
    window.addEventListener('message', handlePostMessage, false);
  }
};


/**
 * Adds a message handler for a particular message type.
 *
 * The message handler function will be invoked when the window receives
 * a message marked as a particular type, receiving an argument. The
 * argument will be the data payload of the event decoded from JSON.
 *
 * @param {string} type The type of the message to handle.
 * @param {function} fn The handler function.
 * @param {string} origin needed
 * @throws {Error} Thrown if the message type being handled already has
 *     a handler function.
 */
var addMessageHandler = function(type, fn, origin) {
  if (typeof window !== 'undefined' && !isListening) {
    startListening();
    isListening = true;
  }

  if (!origin) {
    origin = CURRENT_WINDOW_ORIGIN;
  }

  if (handlers[type]) {
    throw new Error('Rehandling of message "' + type + '" not allowed.');
  }
  handlers[type] = {
    fn: fn,
    origin: origin
  };
  return;
};


/**
 * Removes a message handler for a particular message type.
 *
 * @param {string} type The type of the message to remove.
 * @param {Spotify.Shell.MessageHandler} fn The handler function.
 * @return {boolean} True if the handler function was succesfully removed.
 */
var removeMessageHandler = function(type, fn) {
  if (handlers[type] && (!fn || handlers[type].fn === fn)) {
    handlers[type] = null;
    return true;
  }
  return false;
};


/**
 * Sends a message to the event handler
 *
 * @param {string} type The type of the message to remove.
 * @param {Object} data JSON object to pass to the handler
 */
var sendMessage = function(type, data, destWindow, origin) {
  data = data || {};
  data.type = type;

  if (typeof window === 'undefined') {
    return setImmediate(handleImmediateMessage.bind(null, data));
  }

  destWindow = destWindow || window;

  if (!origin) {
    origin = CURRENT_WINDOW_ORIGIN;
  }

  destWindow.postMessage(JSON.stringify(data), origin);
};

var sendLocalMessage = function(type, data) {
  data = data || {};
  data.type = type;

  if (typeof window === 'undefined') {
    return setImmediate(handleImmediateMessage.bind(null, data));
  }

  // Wrap the data in a custom object to quickly identify the message.
  var wrapper = {};
  wrapper[POST_ROUTER_ID] = data;

  window.postMessage(hasStructuredClone ?
                     wrapper :
                     JSON.stringify(wrapper), CURRENT_WINDOW_ORIGIN);
};


/**
 * Export public interface
 */
module.exports = {
  addMessageHandler: addMessageHandler,
  removeMessageHandler: removeMessageHandler,
  sendMessage: sendMessage,
  sendLocalMessage: sendLocalMessage,
  WINDOW_ORIGIN: CURRENT_WINDOW_ORIGIN
};

},{}],390:[function(require,module,exports){
/**
 * @file
 * Introduces a function called "defer" that allows functions to be
 * executed in the next available tick.
 *
 * Unlike "setTimeout", "defer" executes the function at the nearest
 * possible time without clamping.
 *
 * @see Spotify.defer
 */
'use strict';

var PostRouter = require('spotify-postrouter');


/**
 * Storage for deferred functions to be executed.
 *
 * @type {Array.<function()>}
 * @private
 */
var deferred = [];


/**
 * A bound version of the postMessage routine used to trigger deferred
 * execution.
 *
 * @type {function()}
 * @private
 */
var send = function () {
  PostRouter.sendLocalMessage('execute_deferreds');
};


/**
 * Executes the deferred functions when the window
 * receives an 'execute_deferreds' message.
 *
 * @private
 */
function executeDeferreds() {
  var fns = deferred.splice(0);
  if (!fns.length) return;
  for (var i = 0, l = fns.length; i < l; i++) {
    try {
      fns[i]();
    } finally {
      // Do nothing.
      null;
    }
  }
}

PostRouter.addMessageHandler('execute_deferreds', executeDeferreds);


/**
 * Executes the function applied at the nearest possible time without
 * clamping.
 *
 * @param {function()} fn The function to execute.
 */
var defer = function(fn) {
  var trigger = !deferred.length;
  deferred.push(fn);
  if (trigger) send();
};


/**
 * Export public interface
 */
module.exports = defer;

},{"spotify-postrouter":389}],391:[function(require,module,exports){
var common = require('cosmos-common-js');

var Request = common.request.Request;
var Action = common.request.Action;
var Response = common.response.Response;

/**
 * Checks whether a status is successful.
 *
 * We define a successful status to be something within the 200 to 299 range.
 *
 * @param {number} status The status to check.
 */
function _isSuccessStatus(status) {
  // This constitutes a successfull status.
  return (status >= 200 && status <= 299);
};


function Resolver(spResolver) {
  if (!spResolver || typeof spResolver.resolve !== 'function') {
    throw TypeError('Incorrect resolver argument');
  }

  this._resolver = spResolver;
}

/**
 * The basic, generic method of sending the requests.
 *
 * For params description:
 * @borrows Resolver#_resolve as Resolver#resolve
 */
Resolver.prototype.resolve = function(request, callback) {
  return this._resolve(request, callback);
};

/**
 * Convenience method for doing GET requests.
 * resolver.get('sp://player') is an equivalent of
 * resolver.resolve(new Request('GET', 'sp://player')).
 *
 * @param {string|Object.<string, object>} options If is a string
 * will be parsed as url. If more data is needed, object notation
 * should be used.
 *  param options.url {string} The url of the request.
 *  param options.body {object=} The request body.
 *  param options.headers {object=} The request headers.
 * @param {function(error=, object?)} callback The function
 * executed after the request has been completed.
 *
 * @return {RequestHandler} The cancellable request handler.
 */
Resolver.prototype.get = function(options, callback) {
  return this._resolveFromParams(Action.GET, options, callback);
};

/**
 * Convenience method for doing POST requests.
 * resolver.post('sp://player') is an equivalent of
 * resolver.resolve(new Request('POST', 'sp://player'))
 *
 * @see Resolver#get for params description and returned value.
 */
Resolver.prototype.post = function(options, callback) {
  return this._resolveFromParams(Action.POST, options, callback);
};

/**
 * Convenience method for doing SUB requests.
 * resolver.subscribe('sp://player') is an equivalent of
 * resolver.resolve(new Request('SUB', 'sp://player'))
 *
 * @see Resolver#get for params description and returned value.
 */
Resolver.prototype.subscribe = function(options, callback) {
  return this._resolveFromParams(Action.SUB, options, callback);
};

/**
 * Convenience method for doing PUT requests.
 * resolver.put('sp://ads/v1/settings/session') is an equivalent of
 * resolver.resolve(new Request('PUT', 'sp://ads/v1/settings/session'))
 *
 * @see Resolver#get for params description and returned value.
 */
Resolver.prototype.put = function(options, callback) {
  return this._resolveFromParams(Action.PUT, options, callback);
};

/**
 * Convenience method for doing PATCH requests.
 * resolver.patch('sp://ads/v1/settings/session') is an equivalent of
 * resolver.resolve(new Request('PATCH', 'sp://ads/v1/settings/session'))
 *
 * @see Resolver#get for params description and returned value.
 */
Resolver.prototype.patch = function(options, callback) {
  return this._resolveFromParams(Action.PATCH, options, callback);
};

/**
 * Convenience method for doing DELETE requests.
 * resolver.delete('sp://player') is an equivalent of
 * resolver.resolve(new Request('DELETE', 'sp://player'))
 *
 * @see Resolver#get for params description and returned value.
 */
Resolver.prototype.delete = function(options, callback) {
  return this._resolveFromParams(Action.DELETE, options, callback);
};

/**
 * @private
 * Sends the request to the platform specific request resolver.
 * If the request action is 'SUB' it will send subscribe request
 * In any other case it will send simple resolve request.
 *
 * @param {Cosmos.Request} request A request object.
 * @param {function(error=, object?)} callback The function
 * executed after the request has been completed.
 *
 * @return {RequestHandler} The cancellable request handler.
 */
Resolver.prototype._resolve = function(request, callback) {
  if (!callback || typeof callback !== 'function') {
    callback = function() {};
  }

  var requestHandler;

  function onSuccess(serverResponse) {
    if (!requestHandler._request) {
      return;
    }

    var response = Response.fromObject(serverResponse);
    if (!response) {
      var error = new Error(
        'Failed to parse response: ' + JSON.stringify(serverResponse));
      return callback(error);
    }

    if (_isSuccessStatus(response.getStatusCode())) {
      return callback(null, response);
    } else {
      // Extract just the initial part of the request uri. It's good to have something
      // but it is also good to avoid having everything, since that can hurt dashboards
      // that group error messages.
      var requestEndpoint = request.toJSON().uri.match(/[^\:]*(\:\/\/)?[^\/]*/)[0];
      var errorMessage = (
        response.getHeader("error") ||
        "Request to " + requestEndpoint + " failed with status code " + response.getStatusCode());
      var error = new Error(errorMessage);
      error.response = response;
      return callback(error, response);
    }
  }

  function onError(serverResponse) {
    return callback(serverResponse instanceof Error ?
      serverResponse :
      new Error('Request failed: ' + JSON.stringify(serverResponse)));
  }

  var resolveFn = request.getAction() === Action.SUB ?
      this._resolver.subscribe : this._resolver.resolve;

  var clientRequest = resolveFn.call(this._resolver, request, onSuccess, onError);

  requestHandler = new RequestHandler(clientRequest);
  return requestHandler;
};

/**
 * @private
 * Creates Request object from supplied params.
 * @param {string} method Request method. One of the Request.Action.
 * @param {string|Object.<string, object>} options If is a string
 * will be parsed as url. If more data is needed, object notation
 * should be used.
 *  param options.url {string} The url of the request.
 *  param options.body {object=} The request body.
 *  param options.headers {object=} The request headers.
 * @param {function(error=, object?)} callback The function
 * executed after the request has been completed.
 *
 * @return {RequestHandler} The cancellable request handler.
 */
Resolver.prototype._resolveFromParams = function(method, options, callback) {
  options = options || {};

  var url = typeof options === 'string' ? options : options.url;
  var headers = options.headers;
  var body = options.body;

  var request = new Request(method, url, headers, body);

  return this._resolve(request, callback);
};

/**
 * The object that wraps the clientRequest
 * in a very simple interface.
 * Separates the implementation of the ClientRequest
 * from the request handler returned by Cosmos API.
 *
 * @param {Cosmos.ClientRequest} request The object
 * representing the newly opened request to the client.
 * Usually a request will be a subscription that
 * needs a close handler.
 */
function RequestHandler(request) {
  if (!request || typeof request.close !== 'function')
    throw new TypeError('Invalid `request` argument.');

  this._request = request;
}

/**
 * Closes the request and removes the object.
 */
RequestHandler.prototype.cancel = function() {
  if (this._request) {
    this._request.close();
    this._request = null;
  }
};

exports.Resolver = Resolver;

},{"cosmos-common-js":282}],392:[function(require,module,exports){
'use strict';

/**
 * The Base62 Converter
 *
 * @class Base62
 * @constructor
 *
 */

var digits = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
var invHexDigits = {};
var invDigits = {};

for (var i = 0; i < digits.length; ++i) { invDigits[digits[i]] = i; }
for (var i = 0; i < 16; ++i) { invHexDigits['0123456789abcdef'[i]] = i; }
for (var i = 0; i < 16; ++i) { invHexDigits['0123456789ABCDEF'[i]] = i; }

/**
 * lhs *= rhs
 * @private
 */
function mul(lhs, rhs, base) {
  var rest = 0;
  for (var i = 0; i < lhs.length; ++i) {
    var tmp = lhs[i] * rhs + rest;
    lhs[i] = tmp % base;
    rest = ~~(tmp / base);
  }
  while (rest) {
    lhs.push(rest % base);
    rest = ~~(rest / base);
  }
}

/**
 * acc += lhs * rhs
 * @private
 */
function madd(acc, lhs, rhs, base) {
  var rest = 0;
  for (var i = 0; i < lhs.length; ++i) {
    var tmp = ~~acc[i] + lhs[i] * rhs + rest;
    acc[i] = tmp % base;
    rest = ~~(tmp / base);
  }
  while (rest) {
    var tmp = ~~acc[i] + rest;
    acc[i] = tmp % base;
    rest = ~~(tmp / base);
    ++i;
  }
}

/**
 * Change base
 * @private
 */
function convert(data, fromBase, toBase) {
  var r = [0];
  var b = [1];
  for (var i = 0; i < data.length; ++i) {
    madd(r, b, data[i], toBase);
    mul(b, fromBase, toBase);
  }
  return r;
}

/**
 * Decode to
 * @private
 */
function mapr(data, mapping) {
  for (var i = 0, r = []; i < data.length; ++i) { r.push(mapping[data[i]]); }
  return r.reverse();
}

/**
 * Pad with 0s
 * @private
 */
function pad(data, length) {
  while (data.length < length) { data.push(0); }
  return data;
}

module.exports = {

  /**
   * Converts from array of bytes to base62 encoded string.
   *
   * @public
   * @name Spotify.Utils.Base62#fromBytes
   * @function
   * @param {Array.<number>} data Array of byte numbers.
   * @param {?number} length Do zeropadding until at least this length.
   * @return {string} Base62 encoded string.
  **/
  fromBytes: function(data, length) {
    var r = convert(data.slice(0).reverse(), 256, 62);
    return mapr(pad(r, length), digits).join('');
  },

  /**
   * Converts from base62 encoded string to array of bytes
   *
   * @public
   * @name Spotify.Utils.Base62#toBytes
   * @function
   * @param {string} str Base62 encoded string.
   * @param {?number} length Do zeropadding until at least this length.
   * @return {Array.<number>} Array of byte numbers.
  **/
  toBytes: function(str, length) {
    var r = convert(mapr(str, invDigits), 62, 256);
    return pad(r, length).reverse();
  },

  /**
   * Converts from base62 encoded string to hex encoded string
   *
   * @public
   * @name Spotify.Utils.Base62#toHex
   * @function
   * @param {string} str Base62 encoded string.
   * @param {?number} length Do zeropadding until at least this length.
   * @return {string} Hex encoded string.
  **/
  toHex: function(str, length) {
    var r = convert(mapr(str, invDigits), 62, 16);
    return mapr(pad(r, length), digits).join('');
  },

  /**
   * Converts from hex encoded strign to base62 encoded string
   *
   * @public
   * @name Spotify.Utils.Base62#fromHex
   * @function
   * @param {string} str Hex encoded string.
   * @param {?number} length Do zeropadding until at least this length.
   * @return {string} Base62 encoded string.
  **/
  fromHex: function(str, length) {
    var r = convert(mapr(str, invHexDigits), 16, 62);
    return mapr(pad(r, length), digits).join('');
  }

};

},{}],393:[function(require,module,exports){
(function() {
  /**
   * @file
   * Introduces a function called "defer" that allows functions to be
   * executed in the next available tick.
   *
   * Unlike "setTimeout", "defer" executes the function at the nearest
   * possible time without clamping.
   *
   * @see Spotify.defer
   */
  'use strict';

  var hasWindow = typeof window != 'undefined';
  var hasDefineProperty = typeof Object.defineProperty == 'function';

  if (hasWindow && window.__modDefFn) {
    // If deferred has been attached to the global scope
    module.exports = window.__modDefFn;
    return;
  }

  /**
   * Storage for deferred functions to be executed.
   *
   * @type {Array.<function()>}
   * @private
   */
  var deferred = [];


  /**
   * A bound version of the postMessage routine used to trigger deferred
   * execution.
   *
   * @type {function()}
   * @private
   */
  var send;
  var origin;

  if (hasWindow && window.postMessage) {
    origin = (window.location.origin ||
          window.location.protocol + '//' + window.location.hostname);
    send = window.postMessage.bind(window, '@execute_deferreds', origin);
    if (!window.__hasDeferredHandler) {
      if (hasDefineProperty) {
        Object.defineProperty(window, '__hasDeferredHandler', {value: 1});
      } else {
        window.__hasDeferredHandler = 1;
      }
      var handler = function(e) {
        if (e.origin != origin && e.data != '@execute_deferreds') {
          return;
        }
        executeDeferreds();
      };
      if (window.addEventListener) {
        window.addEventListener('message', handler);
      } else {
        window.attachEvent('onmessage', handler);
      }
    }
  } else if (typeof setImmediate != 'undefined') {
    send = setImmediate.bind(null, executeDeferreds);
  } else {
    send = setTimeout.bind(null, executeDeferreds, 10);
  }


  /**
   * Executes the deferred functions when the window
   * receives an 'execute_deferreds' message.
   *
   * @private
   */
  function executeDeferreds() {
    var fns = deferred.splice(0);
    if (!fns.length) return;
    for (var i = 0, l = fns.length; i < l; i++) {
      try {
        fns[i]();
      } finally {
        // Do nothing.
        null;
      }
    }
  }


  /**
   * Executes the function applied at the nearest possible time without
   * clamping.
   *
   * @param {function()} fn The function to execute.
   */
  var defer = function(fn) {
    var trigger = !deferred.length;
    deferred.push(fn);
    if (trigger) send();
  };

  if (hasWindow && !window.__modDefFn) {
    if (hasDefineProperty) {
      Object.defineProperty(window, '__modDefFn', {value: defer});
    } else {
      window.__modDefFn = defer;
    }
  }

  /**
   * Export public interface
   */
  module.exports = defer;

})();

},{}],394:[function(require,module,exports){
/**
 * @module spotify-eventemitter
 */
'use strict';

/**
 * @private
 */
var _defer = require('spotify-deferred');

/**
 * The event handlers.
 *
 * @typedef {Array.<function>}
 * @private
 */
var EventHandlers;

/**
 * Represents an Event.
 *
 * **NOTE**: The Event class is an internal class: you cannot instantiate it
 * directly. Instead, you should use the provided
 * {@link module:spotify-eventemitter.createEvent} function.
 *
 * @constructor
 * @param {string} type The type name of the event object.
 * @param {Object} props An object that will be added as properties of the
 *     event object.
 * @see {@link module:spotify-eventemitter.createEvent}
 */
function Event(type, props) {
  /**
   * The type of the event.
   *
   * @type {string}
   */
  this.type = type;

  /**
   * A flag for whether preventDefault was called.
   *
   * @type {boolean}
   * @private
   */
  this._prevented = false;

  /**
   * A flag for whether stopPropagation was called
   *
   * @type {boolean}
   * @private
   */
  this._stopped = false;

  /**
   * A flag for whether stopImmediatePropagation was called.
   *
   * @type {boolean}
   * @private
   */
  this._immediateStopped = false;

  if (props) {
    for (var key in props) {
      if (key == 'type') {
        continue;
      }
      this[key] = props[key];
    }
  }
}

/**
 * Prevents the default operation for the event.
 */
Event.prototype.preventDefault = function() {
  this._prevented = true;
};

/**
 * Returns whether preventDefault was called on the event.
 *
 * @return {boolean} True if preventDefault was called, false otherwise.
 */
Event.prototype.isDefaultPrevented = function() {
  return this._prevented;
};

/**
 * Stops the propagation of the event.
 */
Event.prototype.stopPropagation = function() {
  this._stopped = true;
};

/**
 * Returns whether stopPropagation was called on the event.
 *
 * @return {boolean} True if stopPropagation was called, false otherwise.
 */
Event.prototype.isPropagationStopped = function() {
  return this._stopped;
};

/**
 * Stops the immediate propagation of the event.
 *
 * Handlers added after any event handler calling this method will not receive
 * the event.
 */
Event.prototype.stopImmediatePropagation = function() {
  this._immediateStopped = true;
};

/**
 * Returns whether stopImmediatePropagation was called on the event.
 *
 * @return {boolean} True if stopImmediatePropagation was called, false
 *     otherwise.
 */
Event.prototype.isImmediatePropagationStopped = function() {
  return this._immediateStopped;
};

/**
 * An EventEmitter is an object that can be listened to for events.
 *
 * Instances of this class are not usually used directly; instead, a class that
 * needs EventEmitter functionality would inherit from the EventEmitter class
 * so that it's instances can use events.
 *
 * @constructor
 * @alias module:spotify-eventemitter
 *
 * @example <caption>Direct usage</caption>
 * var EventEmitter = require('spotify-eventemitter');
 * var emitter = new EventEmitter();
 * emitter.addListener('someEvent', function() {
 *     console.log('someEvent fired!');
 * });
 * emitter.emit('someEvent');
 * @example <caption>Inheritance</caption>
 * var EventEmitter = require('spotify-eventemitter');
 * var inherit = require('spotify-inherit/inherit');
 *
 * function MyClass() {
 *   EventEmitter.call(this);
 * }
 * inherit(MyClass, EventEmitter);
 *
 * var instance = new MyClass();
 * instance.addListener('someEvent', function() {
 *     console.log('someEvent fired!');
 * });
 * instance.emit('someEvent');
 */
function EventEmitter() {
  /**
   * A map of event names to event handlers.
   *
   * @type {Object.<string, module:spotify-eventemitter~EventHandlers>}
   * @private
   */
  this._listenerMap;
}

/**
 * Creates a new Event object.
 *
 * @param {string} type The type name of the event.
 * @param {Object=} opt_params An object containing properties for the new event
 *     object.
 * @return {module:spotify-eventemitter~Event} The new event object.
 */
EventEmitter.createEvent = function(type, opt_params) {
  return new Event(type, opt_params);
};

/**
 * Adds an event listener to the emitter.
 *
 * This method is idempotent: calling it multiple times using the same type
 * and listener arguments will only set the listener once. This behaviour is
 * done to prevent accidental additions of the same event listener.
 *
 * @param {string} type The type of event to listen to.
 * @param {function} listener A function to be called when the emitter fires
 *     the event specified in the type.
 * @return {module:spotify-eventemitter} The event emitter.
 */
EventEmitter.prototype.addListener = function(type, listener) {
  var _listenerMap = this._listenerMap || (this._listenerMap = {});
  var listeners = _listenerMap[type] || (_listenerMap[type] = []);
  if (listeners.indexOf(listener) != -1) {
    // Handler already added, return quickly.
    return this;
  }
  listeners.push(listener);
  return this;
};

/**
 * Adds multiple event listeners to the emitter.
 *
 * @param {Object.<string, function>} eventListeners An object, the keys of
 *     which correspond to the name of events to listen to, and the value of
 *     each of these keys should be a function that would be added as the
 *     listener for that event.
 * @return {module:spotify-eventemitter} The event emitter.
 */
EventEmitter.prototype.addListeners = function(eventListeners) {
  for (var type in eventListeners) {
    this.addListener(type, eventListeners[type]);
  }
  return this;
};

/**
 * Adds a "once" event listener to the emitter, which will be removed right
 * after it has been fired.
 *
 * In order to achieve the "once" behaviour, the listener argument passed to
 * this method is wrapped in a function, which is then returned by the method.
 *
 * Because of this wrapping, this method is not idempotent: calling it multiple
 * times with the same type and listener arguments will result to multiple
 * event listeners attached.
 *
 * @param {string} type The type of event to listen to.
 * @param {function} listener A function to be called when the emitter fires
 *     the event specified in the type and then automatically removed.
 * @return {function} The function used to wrap the listener function argument.
 *     This function can be used as an argument to removeEvent.
 */
EventEmitter.prototype.addOnceListener = function(type, listener) {
  var wrapper = function() {
    this.removeListener(type, wrapper);
    return listener.apply(this, arguments);
  };
  this.addListener(type, wrapper);
  return wrapper;
};

/**
 * Removes an event listener from the emitter.
 *
 * @param {string} type The type of event to remove.
 * @param {function} listener The listener function to remove. This must be a
 *     function that was added previously using addEvent.
 * @return {module:spotify-eventemitter} The event emitter.
 */
EventEmitter.prototype.removeListener = function(type, listener) {
  var _listenerMap = this._listenerMap;
  var listeners = _listenerMap && _listenerMap[type];
  if (!listeners) {
    return this;
  }
  var index = listeners.indexOf(listener);
  if (index == -1) {
    return this;
  }
  listeners.splice(index, 1);
  if (!listeners.length) {
    _listenerMap[type] = null;
  }
  return this;
};

/**
 * Removes all event listeners from the emitter for a particular type.
 *
 * @param {string} type The event type to remove.
 * @return {module:spotify-eventemitter} The event emitter.
 */
EventEmitter.prototype.removeAllListeners = function(type) {
  var _listenerMap = this._listenerMap;
  if (!_listenerMap) {
    return this;
  }
  _listenerMap[type] = null;
  return this;
};

/**
 * Removes multiple event listeners from the emitter.
 *
 * @param {Object.<string, function>} eventListeners An object, the keys of
 *     which correspond to the name of events to listen to, and the value of
 *     each of these keys should be a function that would be added as the
 *     listener for that event.
 * @return {module:spotify-eventemitter} The event emitter.
 */
EventEmitter.prototype.removeListeners = function(eventListeners) {
  for (var type in eventListeners) {
    this.removeListener(type, eventListeners[type]);
  }
  return this;
};

/**
 * Creates and emits an event on the emitter.
 *
 * This method invokes all the added event listeners of the `type` provided in
 * the order they were added, passing in a new Event object created using the
 * provided `type` and `opt_params` arguments.
 *
 * This method emits events asynchronously: the listeners are not called until
 * the next run loop.
 *
 * @param {string} type The type name of the event to emit.
 * @param {Object=} opt_params An object containing parameters for the Event
 *     object.
 * @return {module:spotify-eventemitter~Event} The Event object that was
 *     created.
 */
EventEmitter.prototype.emit = function(type, opt_params) {
  var event = new Event(type, opt_params);
  _defer(function() {
    this.emitEventSync(event);
  }.bind(this));
  return event;
};

/**
 * Emits an event on the emitter.
 *
 * This method invokes all the added event listeners of the `type` of the 
 * `event` provided in the order they were added, passing in the `event` as an
 * argument.
 *
 * This method emits events asynchronously: the listeners are not called until
 * the next run loop.
 *
 * @param {module:spotify-eventemitter~Event} event The Event object.
 * @return {module:spotify-eventemitter~Event} The Event object that was passed.
 */
EventEmitter.prototype.emitEvent = function(event) {
  _defer(function() {
    this.emitEventSync(event);
  }.bind(this));
  return event;
};

/**
 * Creates and synchronously emits an event on the emitter.
 *
 * This method invokes all the added event listeners of the `type` provided in
 * the order they were added, passing in a new Event object created using the
 * provided `type` and `opt_params` arguments.
 *
 * @param {string} type The type name of event to emit.
 * @param {Object=} opt_params An object containing parameters for the event
 *     object.
 * @return {module:spotify-eventemitter~Event} The Event object that was
 *     created.
 */
EventEmitter.prototype.emitSync = function(type, opt_params) {
  var event = new Event(type, opt_params);
  this.emitEventSync(event);
  return event;
};

/**
 * Synchronously emits an event on the emitter.
 *
 * This method invokes all the added event listeners of the `type` of the
 * `event` provided in the order they were added, passing in the `event` as an
 * argument.
 *
 * @param {module:spotify-eventemitter~Event} event The Event object.
 * @return {module:spotify-eventemitter~Event} The Event object that was passed.
 */
EventEmitter.prototype.emitEventSync = function(event) {
  var type = event.type;
  var _listenerMap = this._listenerMap;
  var listeners = _listenerMap && _listenerMap[type];
  if (!listeners || !listeners.length) {
    return event;
  }
  listeners = listeners.slice(0);
  for (var i = 0, l = listeners.length; i < l; i++) {
    listeners[i].call(this, event);
    if (event.isImmediatePropagationStopped()) {
      break;
    }
  }
  return event;
};

// DEPRECATED METHODS:

/**
 * Adds an event listener to the emitter.
 *
 * **NOTE**: This method has been deprecated in favor of
 * {@link module:spotify-eventemitter#addListener}.
 *
 * This method is idempotent: calling it multiple times using the same type
 * and listener arguments will only set the listener once. This behaviour is
 * done to prevent accidental additions of the same event listener.
 *
 * @deprecated since v2.0.0.
 * @param {string} type The type of event to listen to.
 * @param {function} listener A function to be called when the emitter fires
 *     the event specified in the type.
 * @return {module:spotify-eventemitter} The event emitter.
 * @see {@link module:spotify-eventemitter#addListener}
 */
EventEmitter.prototype.addEvent = function(type, listener) {
  return this.addListener(type, listener);
};

/**
 * Adds multiple event listeners to the emitter.
 *
 * **NOTE**: This method has been deprecated in favor of
 * {@link module:spotify-eventemitter#addListeners}.
 *
 * @deprecated since v2.0.0.
 * @param {Object.<string, function>} eventListeners An object, the keys of
 *     which correspond to the name of events to listen to, and the value of
 *     each of these keys should be a function that would be added as the
 *     listener for that event.
 * @return {module:spotify-eventemitter} The event emitter.
 * @see {@link module:spotify-eventemitter#addListeners}
 */
EventEmitter.prototype.addEvents = function(eventListeners) {
  return this.addListeners(eventListeners);
};

/**
 * Adds a "once" event listener to the emitter, which will be removed right
 * after it has been fired.
 *
 * **NOTE**: This method has been deprecated in favor of
 * {@link module:spotify-eventemitter#addOnceListener}.
 *
 * In order to achieve the "once" behaviour, the listener argument passed to
 * this method is wrapped in a function, which is then returned by the method.
 *
 * Because of this wrapping, this method is not idempotent: calling it multiple
 * times with the same type and listener arguments will result to multiple
 * event listeners attached.
 *
 * @deprecated since v2.0.0.
 * @param {string} type The type of event to listen to.
 * @param {function} listener A function to be called when the emitter fires
 *     the event specified in the type and then automatically removed.
 * @return {function} The function used to wrap the listener function argument.
 *     This function can be used as an argument to removeEvent.
 * @see {@link module:spotify-eventemitter#addOnceListener}
 */
EventEmitter.prototype.addOnceEvent = function(type, listener) {
  return this.addOnceListener(type, listener);
};

/**
 * Removes an event listener from the emitter.
 *
 * **NOTE**: This method has been deprecated in favor of
 * {@link module:spotify-eventemitter#removeListener}.
 *
 * @deprecated since v2.0.0.
 * @param {string} type The type of event to remove.
 * @param {function} listener The listener function to remove. This must be a
 *     function that was added previously using addEvent.
 * @return {module:spotify-eventemitter} The event emitter.
 * @see {@link module:spotify-eventemitter#removeListener}
 */
EventEmitter.prototype.removeEvent = function(type, listener) {
  return this.removeListener(type, listener);
};

/**
 * Removes multiple event listeners from the emitter.
 *
 * **NOTE**: This method has been deprecated in favor of
 * {@link module:spotify-eventemitter#removeListeners}.
 *
 * @deprecated since v2.0.0.
 * @param {Object.<string, function>} events An object, the keys of which
 *     correspond to the name of events to remove, and the value of each of
 *     these keys should be a function that would be removed as a listener.
 * @return {module:spotify-eventemitter} The event emitter.
 * @see {@link module:spotify-eventemitter#removeListeners}
 */
EventEmitter.prototype.removeEvents = function(eventListeners) {
  return this.removeListeners(eventListeners);
};

/**
 * Fires an event on the emitter, optionally passing arguments to the listeners.
 *
 * **NOTE**: This method has been deprecated in favor of
 * {@link module:spotify-eventemitter#emit}.
 *
 * This method fire events asynchronously: the listeners are not called until
 * the next run loop. A third boolean parameter can be passed to change this
 * behaviour.
 *
 * @deprecated since v2.0.0.
 * @param {string} type The type of event to fire.
 * @param {Array.<*>=} opt_args A set of objects that would be passed to the
 *     event listeners as arguments.
 * @param {boolean=} opt_priority Passing true will fire the event synchronously.
 * @return {module:spotify-eventemitter} The event emitter.
 * @see {@link module:spotify-eventemitter#emit}
 */
EventEmitter.prototype.fireEvent = function(type, opt_args, opt_priority) {
  if (opt_priority) {
    this.fireEventSync(type, opt_args);
  } else {
    var self = this;
    _defer(function() { self.fireEventSync(type, opt_args); });
  }
  return this;
};

/**
 * Fires an event on the emitter synchronously, optionally passing arguments to
 * the listeners.
 *
 * **NOTE**: This method has been deprecated in favor of
 * {@link module:spotify-eventemitter#emitSync}.
 *
 * @deprecated since v2.0.0.
 * @param {string} type The type of event to fire.
 * @param {Array.<*>=} opt_args A set of objects that would be passed to the
 *     event listeners as arguments.
 * @return {module:spotify-eventemitter} The event emitter.
 * @see {@link module:spotify-eventemitter#emitSync}
 */
EventEmitter.prototype.fireEventSync = function(type, opt_args) {
  var self = this;
  var events = this._listenerMap && this._listenerMap[type];
  if (!events || !events.length) return this;
  events = events.slice(0);
  var i, l;
  if (!opt_args) {
    for (i = 0, l = events.length; i < l; i++) {
      events[i].call(self);
    }
  } else {
    if (!Array.isArray(opt_args)) {
      opt_args = [opt_args];
    }
    for (i = 0, l = events.length; i < l; i++) {
      events[i].apply(self, opt_args);
    }
  }
  return this;
};

/**
 * Adds an event listener to the emitter.
 *
 * **NOTE**: This method has been deprecated in favor of
 * {@link module:spotify-eventemitter#addListener}.
 *
 * This method is idempotent: calling it multiple times using the same type
 * and listener arguments will only set the listener once. This behaviour is
 * done to prevent accidental additions of the same event listener.
 *
 * @deprecated since v2.0.0.
 * @param {string} type The type of event to listen to.
 * @param {function} listener A function to be called when the emitter fires
 *     the event specified in the type.
 * @return {module:spotify-eventemitter} The event emitter.
 * @see {@link module:spotify-eventemitter#addListener}
 */
EventEmitter.prototype.on = function(type, listener) {
  return this.addEvent(type, listener);
};

/**
 * Adds a "once" event listener to the emitter, which will be removed right
 * after it has been fired.
 *
 * **NOTE**: This method has been deprecated in favor of
 * {@link module:spotify-eventemitter#addOnceListener}.
 *
 * In order to achieve the "once" behaviour, the listener argument passed to
 * this method is wrapped in a function, which is then returned by the method.
 *
 * Because of this wrapping, this method is not idempotent: calling it multiple
 * times with the same type and listener arguments will result to multiple
 * event listeners attached.
 *
 * @deprecated since v2.0.0.
 * @param {string} type The type of event to listen to.
 * @param {function} listener A function to be called when the emitter fires
 *     the event specified in the type and then automatically removed.
 * @return {function} The function used to wrap the listener function argument.
 *     This function can be used as an argument to removeEvent.
 * @see {@link module:spotify-eventemitter#addOnceListener}
 */
EventEmitter.prototype.once = function(type, listener) {
  return this.addOnceEvent(type, listener);
};

/**
 * Removes an event listener or all event listeners from the emitter.
 *
 * **NOTE**: This method has been deprecated in favor of
 * {@link module:spotify-eventemitter#removeListener}.
 *
 * @deprecated since v2.0.0.
 * @param {string} type The type of event to remove.
 * @param {function=} opt_listener The listener function to remove. This must be
 *     a function that was added previously using addEvent. If this parameter is
 *     not given, all event listeners of the corresponding `type` argument will
 *     be removed.
 * @return {module:spotify-eventemitter} The event emitter.
 * @see {@link module:spotify-eventemitter#removeListener}
 * @see {@link module:spotify-eventemitter#removeListeners}
 */
EventEmitter.prototype.off = function(type, opt_listener) {
  if (typeof opt_listener === 'function') {
    return this.removeEvent(type, opt_listener);
  }
  // if no listener set, remove all the listeners from the event
  this._listenerMap[type] = null;
  return this;
};

/**
 * Exporting
 */
module.exports = EventEmitter;

},{"spotify-deferred":393}],395:[function(require,module,exports){
'use strict';

/**
 * Function to add properties to an object
 * @param {Object} obj The input object
 * @param {Object} args The objects which are going to be injected
 * @return {Object} The extended object
 */
var extend = function(obj, args) {
  var source;

  for (var i = 1; i < arguments.length; i++) {
    source = arguments[i];
    if (source) {
      for (var prop in source) {
        if (source.hasOwnProperty(prop)) {
          obj[prop] = source[prop];
        }
      }
    }
  }
  return obj;
};


/**
 * Export public interface
 */
module.exports = extend;

},{}],396:[function(require,module,exports){
'use strict';

module.exports = {
  inherit: require('./inherit'),
  extend: require('./extend')
};

},{"./extend":395,"./inherit":397}],397:[function(require,module,exports){
'use strict';

/**
 * Makes a class inherit from a superclass' prototype indirectly.
 *
 * @param {Spotify.ClassLike} Sub The class that will inherit.
 * @param {Spotify.ClassLike} Super The class to inherit from.
 */
var inherit = function(Sub, Super) {
  var superProto = Super.prototype;
  function Superclass() {}
  Superclass.prototype = Sub._super = superProto;
  Superclass.prototype.constructor = Super;
  Sub.prototype = new Superclass();
};


/**
 * Export public interface
 */
module.exports = inherit;

},{}],398:[function(require,module,exports){
'use strict';

/**
 * @private
 */
var Base62 = require('spotify-crypto/src/base62');

/**
 * The URI prefix for URIs.
 *
 * @const
 * @private
 */
var URI_PREFIX = 'spotify:';

/**
 * The URL prefix for Play.
 *
 * @const
 * @private
 */
var PLAY_HTTP_PREFIX = 'http://play.spotify.com/';

/**
 * The HTTPS URL prefix for Play.
 *
 * @const
 * @private
 */
var PLAY_HTTPS_PREFIX = 'https://play.spotify.com/';

/**
 * The URL prefix for Open.
 *
 * @const
 * @private
 */
var OPEN_HTTP_PREFIX = 'http://open.spotify.com/';

/**
 * The HTTPS URL prefix for Open.
 *
 * @const
 * @private
 */
var OPEN_HTTPS_PREFIX = 'https://open.spotify.com/';

var ERROR_INVALID = new TypeError('Invalid Spotify URI!');
var ERROR_NOT_IMPLEMENTED = new TypeError('Not implemented!');


/**
 * The format for the URI to parse.
 *
 * @enum {number}
 * @private
 */
var Format = {
  URI: 0,
  URL: 1
};

/**
 * Represents the result of a URI splitting operation.
 *
 * @typedef {{
 *    format: Format,
 *    components: Array.<string>
 * }}
 * @see _splitIntoComponents
 * @private
 */
var SplittedURI;

/**
 * Split an string URI or HTTP/HTTPS URL into components, skipping the prefix.
 *
 * @param {string} str A string URI to split.
 * @return {SplittedURI} The parsed URI.
 * @private
 */
var _splitIntoComponents = function(str) {
  var components;
  var format;
  var anchor;

  var hashSplit = str.split('#');

  if (hashSplit.length > 1) {
    // first token
    str = hashSplit.shift();
    // last token
    anchor = hashSplit.pop();
  }

  if (str.indexOf(URI_PREFIX) === 0) {
    components = str.slice(URI_PREFIX.length).split(':');
    format = Format.URI;
  } else {
    // For HTTP URLs, ignore any query string argument
    str = str.split('?')[0];

    if (str.indexOf(PLAY_HTTP_PREFIX) === 0) {
      components = str.slice(PLAY_HTTP_PREFIX.length).split('/');
    } else if (str.indexOf(PLAY_HTTPS_PREFIX) === 0) {
      components = str.slice(PLAY_HTTPS_PREFIX.length).split('/');
    } else if (str.indexOf(OPEN_HTTP_PREFIX) === 0) {
      components = str.slice(OPEN_HTTP_PREFIX.length).split('/');
    } else if (str.indexOf(OPEN_HTTPS_PREFIX) === 0) {
      components = str.slice(OPEN_HTTPS_PREFIX.length).split('/');
    } else {
      throw ERROR_INVALID;
    }
    format = Format.URL;
  }

  if (anchor) {
    components.push(anchor);
  }

  return {
    format: format,
    components: components
  };
};

/**
 * Encodes a component according to a format.
 *
 * @param {string} component A component string.
 * @param {Format} format A format.
 * @return {string} An encoded component string.
 * @private
 */
var _encodeComponent = function(component, format) {
  component = encodeURIComponent(component);
  if (format === Format.URI) {
    component = component.replace(/%20/g, '+');
  }

  // encode characters that are not encoded by default by encodeURIComponent
  // but that the Spotify URI spec encodes: !'*()
  component = component.replace(/[!'()]/g, escape);
  component = component.replace(/\*/g, '%2A');

  return component;
};

/**
 * Decodes a component according to a format.
 *
 * @param {string} component An encoded component string.
 * @param {Format} format A format.
 * @return {string} An decoded component string.
 * @private
 */
var _decodeComponent = function(component, format) {
  var part = format == Format.URI ? component.replace(/\+/g, '%20') : component;
  return decodeURIComponent(part);
};

/**
 * Returns the components of a URI as an array.
 *
 * @param {URI} uri A uri.
 * @param {Format} format The output format.
 * @return {Array.<string>} An array of uri components.
 * @private
 */
var _getComponents = function(uri, format) {
  var base62;
  if (uri.id) {
    base62 = uri._base62Id;
  }

  var components;
  var i;
  var len;
  switch (uri.type) {
    case URI.Type.ALBUM:
      components = [URI.Type.ALBUM, base62];
      if (uri.disc) {
        components.push(uri.disc);
      }
      return components;
    case URI.Type.AD:
      return [URI.Type.AD, uri._base62Id];
    case URI.Type.ARTIST:
      return [URI.Type.ARTIST, base62];
    case URI.Type.ARTIST_TOPLIST:
      return [URI.Type.ARTIST, base62, URI.Type.TOP, uri.toplist];
    case URI.Type.SEARCH:
      return [URI.Type.SEARCH, _encodeComponent(uri.query, format)];
    case URI.Type.TRACK:
      if (uri.anchor) {
        base62 += '#' + uri.anchor;
      }
      return [URI.Type.TRACK, base62];
    case URI.Type.TRACKSET:
      var trackIds = [];
      for (i = 0, len = uri.tracks.length; i < len; i++) {
        trackIds.push(uri.tracks[i]._base62Id);
      }
      trackIds = [trackIds.join(',')];
      // Index can be 0 sometimes (required for trackset)
      if (uri.index !== null) {
        trackIds.push('#', uri.index);
      }
      return [URI.Type.TRACKSET, _encodeComponent(uri.name)].concat(trackIds);
    case URI.Type.FACEBOOK:
      return [URI.Type.USER, URI.Type.FACEBOOK, uri.uid];
    case URI.Type.AUDIO_FILE:
      return [URI.Type.AUDIO_FILE, uri.extension, uri._base62Id];
    case URI.Type.FOLDER:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.FOLDER, uri._base62Id];
    case URI.Type.FOLLOWERS:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.FOLLOWERS];
    case URI.Type.FOLLOWING:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.FOLLOWING];
    case URI.Type.PLAYLIST:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.PLAYLIST, base62];
    case URI.Type.STARRED:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.STARRED];
    case URI.Type.TEMP_PLAYLIST:
      return [URI.Type.TEMP_PLAYLIST, uri.origin, uri.data];
    case URI.Type.CONTEXT_GROUP:
      return [URI.Type.CONTEXT_GROUP, uri.origin, uri.name];
    case URI.Type.USER_TOPLIST:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.TOP, uri.toplist];
    // Legacy Toplist
    case URI.Type.USER_TOP_TRACKS:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.TOPLIST];
    case URI.Type.TOPLIST:
      return [URI.Type.TOP, uri.toplist].concat(uri.global ? [URI.Type.GLOBAL] : ['country', uri.country]);
    case URI.Type.INBOX:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.INBOX];
    case URI.Type.ROOTLIST:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.ROOTLIST];
    case URI.Type.PUBLISHED_ROOTLIST:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.PUBLISHED_ROOTLIST];
    case URI.Type.COLLECTION_TRACK_LIST:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.COLLECTION_TRACK_LIST, base62];
    case URI.Type.PROFILE:
      if (uri.args && uri.args.length > 0)
        return [URI.Type.USER, _encodeComponent(uri.username, format)].concat(uri.args);
      return [URI.Type.USER, _encodeComponent(uri.username, format)];
    case URI.Type.LOCAL_ARTIST:
      return [URI.Type.LOCAL, _encodeComponent(uri.artist, format)];
    case URI.Type.LOCAL_ALBUM:
      return [URI.Type.LOCAL, _encodeComponent(uri.artist, format), _encodeComponent(uri.album, format)];
    case URI.Type.LOCAL:
      return [URI.Type.LOCAL,
        _encodeComponent(uri.artist, format),
        _encodeComponent(uri.album, format),
        _encodeComponent(uri.track, format),
        uri.duration];
    case URI.Type.LIBRARY:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.LIBRARY].concat(uri.category ? [uri.category] : []);
    case URI.Type.IMAGE:
      return [URI.Type.IMAGE, uri._base62Id];
    case URI.Type.MOSAIC:
      components = uri.ids.slice(0);
      components.unshift(URI.Type.MOSAIC);
      return components;
    case URI.Type.RADIO:
      return [URI.Type.RADIO, uri.args];
    case URI.Type.SPECIAL:
      components = [URI.Type.SPECIAL];
      var args = uri.args || [];
      for (i = 0, len = args.length; i < len; ++i)
        components.push(_encodeComponent(args[i], format));
      return components;
    case URI.Type.STATION:
      components = [URI.Type.STATION];
      var args = uri.args || [];
      for (i = 0, len = args.length; i < len; i++) {
        components.push(_encodeComponent(args[i], format));
      }
      return components;
    case URI.Type.APPLICATION:
      components = [URI.Type.APP, uri._base62Id];
      var args = uri.args || [];
      for (i = 0, len = args.length; i < len; ++i)
        components.push(_encodeComponent(args[i], format));
      return components;
    case URI.Type.COLLECTION_ALBUM:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.COLLECTION, URI.Type.ALBUM, base62];
    case URI.Type.COLLECTION_MISSING_ALBUM:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.COLLECTION, URI.Type.ALBUM, base62, 'missing'];
    case URI.Type.COLLECTION_ARTIST:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.COLLECTION, URI.Type.ARTIST, base62];
    case URI.Type.COLLECTION:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.COLLECTION].concat(uri.category ? [uri.category] : []);
    case URI.Type.EPISODE:
      return [URI.Type.EPISODE, base62];
    default:
      throw ERROR_INVALID;
  }
};

/**
 * Parses the components of a URI into a real URI object.
 *
 * @param {Array.<string>} components The components of the URI as a string
 *     array.
 * @param {Format} format The format of the source string.
 * @return {URI} The URI object.
 * @private
 */
var _parseFromComponents = function(components, format) {
  var _current = 0;

  var _getNextComponent = function() {
    return components[_current++];
  };

  var _getIdComponent = function() {
    var component = _getNextComponent();

    if (component.length > 22) {
      throw new Error('Invalid ID');
    }
    return component;
  };

  var _getRemainingComponents = function() {
    return components.slice(_current);
  };

  var _getRemainingString = function() {
    var separator = (format == Format.URI) ? ':' : '/';
    return components.slice(_current).join(separator);
  };

  var part = _getNextComponent();
  var id;
  var i;
  var len;

  switch (part) {
    case URI.Type.ALBUM:
      return URI.albumURI(_getIdComponent(), parseInt(_getNextComponent(), 10));
    case URI.Type.AD:
      return URI.adURI(_getNextComponent());
    case URI.Type.ARTIST:
      id = _getIdComponent();
      if (_getNextComponent() == URI.Type.TOP) {
        return URI.artistToplistURI(id, _getNextComponent());
      } else {
        return URI.artistURI(id);
      }
    case URI.Type.AUDIO_FILE:
      return URI.audioFileURI(_getNextComponent(), _getNextComponent());
    case URI.Type.TEMP_PLAYLIST:
      return URI.temporaryPlaylistURI(_getNextComponent(), _getRemainingString());
    case URI.Type.SEARCH:
      return URI.searchURI(_decodeComponent(_getRemainingString(), format));
    case URI.Type.TRACK:
      return URI.trackURI(_getIdComponent(), _getNextComponent());
    case URI.Type.TRACKSET:
      var name = _decodeComponent(_getNextComponent());
      var tracksArray = _getNextComponent();
      var hashSign = _getNextComponent();
      var index = parseInt(_getNextComponent(), 10);
      // Sanity check: %23 is URL code for "#"
      if (hashSign !== '%23' || isNaN(index)) {
        index = null;
      }
      var tracksetTracks = [];
      if (tracksArray) {
        tracksArray = _decodeComponent(tracksArray).split(',');
        for (i = 0, len = tracksArray.length; i < len; i++) {
          var trackId = tracksArray[i];
          tracksetTracks.push(URI.trackURI(trackId));
        }
      }
      return URI.tracksetURI(tracksetTracks, name, index);
    case URI.Type.CONTEXT_GROUP:
      return URI.contextGroupURI(_getNextComponent(), _getNextComponent());
    case URI.Type.TOP:
      var type = _getNextComponent();
      if (_getNextComponent() == URI.Type.GLOBAL) {
        return URI.toplistURI(type, null, true);
      } else {
        return URI.toplistURI(type, _getNextComponent(), false);
      }
    case URI.Type.USER:
      var username = _decodeComponent(_getNextComponent(), format);
      var text = _getNextComponent();
      if (username == URI.Type.FACEBOOK && text != null) {
        return URI.facebookURI(parseInt(text, 10));
      } else if (text != null) {
        switch (text) {
          case URI.Type.PLAYLIST:
            return URI.playlistURI(username, _getIdComponent());
          case URI.Type.FOLDER:
            return URI.folderURI(username, _getIdComponent());
          case URI.Type.COLLECTION_TRACK_LIST:
            return URI.collectionTrackList(username, _getIdComponent());
          case URI.Type.COLLECTION:
            var collectionItemType = _getNextComponent();
            switch (collectionItemType) {
              case URI.Type.ALBUM:
                id = _getIdComponent();
                if (_getNextComponent() === 'missing') {
                  return URI.collectionMissingAlbumURI(username, id);
                } else {
                  return URI.collectionAlbumURI(username, id);
                }
              case URI.Type.ARTIST:
                return URI.collectionArtistURI(username, _getIdComponent());
              default:
                return URI.collectionURI(username, collectionItemType);
            }
          case URI.Type.STARRED:
            return URI.starredURI(username);
          case URI.Type.FOLLOWERS:
            return URI.followersURI(username);
          case URI.Type.FOLLOWING:
            return URI.followingURI(username);
          case URI.Type.TOP:
            return URI.userToplistURI(username, _getNextComponent());
          case URI.Type.INBOX:
            return URI.inboxURI(username);
          case URI.Type.ROOTLIST:
            return URI.rootlistURI(username);
          case URI.Type.PUBLISHED_ROOTLIST:
            return URI.publishedRootlistURI(username);
          case URI.Type.TOPLIST:
            // legacy toplist
            return URI.userTopTracksURI(username);
          case URI.Type.LIBRARY:
            return URI.libraryURI(username, _getNextComponent());
        }
      }
      var rem = _getRemainingComponents();
      if (text != null && rem.length > 0) {
        return URI.profileURI(username, [text].concat(rem));
      } else if (text != null) {
        return URI.profileURI(username, [text]);
      } else {
        return URI.profileURI(username);
      }
    case URI.Type.LOCAL:
      var artistNameComponent = _getNextComponent();
      var artistName = artistNameComponent && _decodeComponent(artistNameComponent, format);
      var albumNameComponent = _getNextComponent();
      var albumName = albumNameComponent && _decodeComponent(albumNameComponent, format);
      var trackNameComponent = _getNextComponent();
      var trackName = trackNameComponent && _decodeComponent(trackNameComponent, format);
      var durationComponent = _getNextComponent();
      var duration = parseInt(durationComponent, 10);
      if (trackNameComponent !== undefined) {
        return URI.localURI(artistName, albumName, trackName, duration);
      } else if (albumNameComponent !== undefined) {
        return URI.localAlbumURI(artistName, albumName);
      } else {
        return URI.localArtistURI(artistName);
      }
    case URI.Type.IMAGE:
      return URI.imageURI(_getIdComponent());
    case URI.Type.MOSAIC:
      return URI.mosaicURI(components.slice(_current));
    case URI.Type.RADIO:
      return URI.radioURI(_getRemainingString());
    case URI.Type.SPECIAL:
      var args = _getRemainingComponents();
      for (i = 0, len = args.length; i < len; ++i)
        args[i] = _decodeComponent(args[i], format);
      return URI.specialURI(args);
    case URI.Type.STATION:
      return URI.stationURI(_getRemainingComponents());
    case URI.Type.EPISODE:
      return URI.episodeURI(_getIdComponent());
    default:
      if (part === URI.Type.APP) {
        id = _getNextComponent();
      } else {
        id = part;
      }
      var args = _getRemainingComponents();
      for (i = 0, len = args.length; i < len; ++i)
        args[i] = _decodeComponent(args[i], format);
      return URI.applicationURI(id, args);
  }

  throw ERROR_INVALID;
};

/**
 * A class holding information about a uri.
 *
 * @constructor
 * @param {URI.Type} type The uri type.
 * @param {Object} props The uri properties.
 */
function URI(type, props) {
  /**
   * The uri type.
   *
   * @type {string}
   */
  this.type = type;

  // Merge properties into URI object.
  for (var prop in props) {
    if (typeof props[prop] == 'function') {
      continue;
    }
    this[prop] = props[prop];
  }
}

// Lazy convert the id to hexadecimal only when requested
Object.defineProperty(URI.prototype, 'id', {
  get: function() {
    if (!this._hexId) {
      this._hexId = this._base62Id ? URI.idToHex(this._base62Id) : undefined;
    }
    return this._hexId;
  },
  set: function(id) {
    this._base62Id = id ? URI.hexToId(id) : undefined;
    this._hexId = undefined;
  },
  enumerable: true,
  configurable: true
});

/**
 * Creates an application URI object from the current URI object.
 *
 * If the current URI object is already an application type, a copy is made.
 *
 * @return {URI} The current URI as an application URI.
 */
URI.prototype.toAppType = function() {
  if (this.type == URI.Type.APPLICATION) {
    return URI.applicationURI(this.id, this.args);
  } else {
    var components = _getComponents(this, Format.URL);
    var id = components.shift();
    var len = components.length;
    if (len) {
      while (len--) {
        components[len] = _decodeComponent(components[len], Format.URL);
      }
    }
    if (this.type == URI.Type.RADIO) {
      components = components.shift().split(':');
    }
    var result = URI.applicationURI(id, components);
    return result;
  }
};

/**
 * Creates a URI object from an application URI object.
 *
 * If the current URI object is not an application type, a copy is made.
 *
 * @return {URI} The current URI as a real typed URI.
 */
URI.prototype.toRealType = function() {
  if (this.type == URI.Type.APPLICATION) {
    return _parseFromComponents([this.id].concat(this.args), Format.URI);
  } else {
    return new URI(null, this);
  }
};

/**
 * Returns the URI representation of this URI.
 *
 * @return {String} The URI representation of this uri.
 */
URI.prototype.toURI = function() {
  return URI_PREFIX + _getComponents(this, Format.URI).join(':');
};

/**
 * Returns the String representation of this URI.
 *
 * @return {String} The URI representation of this uri.
 * @see {URI#toURI}
 */
URI.prototype.toString = function() {
  return this.toURI();
};

/**
 * Get the URL path of this uri.
 *
 * @param {boolean} opt_leadingSlash True if a leading slash should be prepended.
 * @return {String} The path of this uri.
 */
URI.prototype.toURLPath = function(opt_leadingSlash) {
  var components = _getComponents(this, Format.URL);
  if (components[0] === URI.Type.APP) {
    components.shift();
  }

  // Some URIs are allowed to have empty components. It should be investigated
  // whether we need to strip empty components at all from any URIs. For now,
  // we check specifically for tracksets and local tracks and strip empty
  // components for all other URIs.
  //
  // For tracksets, it's permissible to have a path that looks like
  // 'trackset//trackURI' because the identifier parameter for a trackset can
  // be blank. For local tracks, some metadata can be missing, like missing
  // album name would be 'spotify:local:artist::track:duration'.
  var isTrackset = components[0] === URI.Type.TRACKSET;
  var isLocalTrack = components[0] === URI.Type.LOCAL;
  var shouldStripEmptyComponents = !isTrackset && !isLocalTrack;

  if (shouldStripEmptyComponents) {
    var _temp = [];
    for (var i = 0, l = components.length; i < l; i++) {
      var component = components[i];
      if (!!component) {
        _temp.push(component);
      }
    }
    components = _temp;
  }
  var path = components.join('/');
  return opt_leadingSlash ? '/' + path : path;
};

/**
 * Returns the Play URL string for the uri.
 *
 * @return {string} The Play URL string for the uri.
 */
URI.prototype.toPlayURL = function() {
    return PLAY_HTTPS_PREFIX + this.toURLPath();
};

/**
 * Returns the URL string for the uri.
 *
 * @return {string} The URL string for the uri.
 * @see {URL#toPlayURL}
 */
URI.prototype.toURL = function() {
  return this.toPlayURL();
};

/**
 * Returns the Open URL string for the uri.
 *
 * @return {string} The Open URL string for the uri.
 */
URI.prototype.toOpenURL = function() {
  return OPEN_HTTPS_PREFIX + this.toURLPath();
};

/**
 * Returns the Play HTTPS URL string for the uri.
 *
 * @return {string} The Play HTTPS URL string for the uri.
 */
URI.prototype.toSecurePlayURL = function() {
    return this.toPlayURL();
};

/**
 * Returns the HTTPS URL string for the uri.
 *
 * @return {string} The HTTPS URL string for the uri.
 * @see {URL#toSecurePlayURL}
 */
URI.prototype.toSecureURL = function() {
  return this.toPlayURL();
};

/**
 * Returns the Open HTTPS URL string for the uri.
 *
 * @return {string} The Open HTTPS URL string for the uri.
 */
URI.prototype.toSecureOpenURL = function() {
  return this.toOpenURL();
};

/**
 * Returns the id of the uri as a bytestring.
 *
 * @return {Array} The id of the uri as a bytestring.
 */
URI.prototype.idToByteString = function() {
  var data = Base62.toBytes(this._base62Id);
  data = data.map(function(i) {
    return String.fromCharCode(i);
  }).join('');
  while (data.length < 16) {
    data = String.fromCharCode(0) + data;
  }
  return data;
};

/**
 * The various URI Types.
 *
 * Note that some of the types in this enum are not real URI types, but are
 * actually URI particles. They are marked so.
 *
 * @enum {string}
 */
URI.Type = {
  EMPTY: 'empty',
  ALBUM: 'album',
  AD: 'ad',
  /** URI particle; not an actual URI. */
  APP: 'app',
  APPLICATION: 'application',
  ARTIST: 'artist',
  ARTIST_TOPLIST: 'artist-toplist',
  AUDIO_FILE: 'audiofile',
  COLLECTION: 'collection',
  COLLECTION_ALBUM: 'collection-album',
  COLLECTION_MISSING_ALBUM: 'collection-missing-album',
  COLLECTION_ARTIST: 'collection-artist',
  CONTEXT_GROUP: 'context-group',
  EPISODE: 'episode',
  /** URI particle; not an actual URI. */
  FACEBOOK: 'facebook',
  FOLDER: 'folder',
  FOLLOWERS: 'followers',
  FOLLOWING: 'following',
  /** URI particle; not an actual URI. */
  GLOBAL: 'global',
  IMAGE: 'image',
  INBOX: 'inbox',
  LOCAL_ARTIST: 'local-artist',
  LOCAL_ALBUM: 'local-album',
  LOCAL: 'local',
  LIBRARY: 'library',
  MOSAIC: 'mosaic',
  PLAYLIST: 'playlist',
  PROFILE: 'profile',
  PUBLISHED_ROOTLIST: 'published-rootlist',
  RADIO: 'radio',
  ROOTLIST: 'rootlist',
  COLLECTION_TRACK_LIST: 'collectiontracklist',
  SEARCH: 'search',
  SPECIAL: 'special',
  STARRED: 'starred',
  STATION: 'station',
  TEMP_PLAYLIST: 'temp-playlist',
  /** URI particle; not an actual URI. */
  TOP: 'top',
  TOPLIST: 'toplist',
  TRACK: 'track',
  TRACKSET: 'trackset',
  /** URI particle; not an actual URI. */
  USER: 'user',
  USER_TOPLIST: 'user-toplist',
  USER_TOP_TRACKS: 'user-top-tracks',
  /** Deprecated contant. Please use USER_TOP_TRACKS. */
  USET_TOP_TRACKS: 'user-top-tracks'
};

/**
 * Creates a new URI object from a parsed string argument.
 *
 * @param {string} str The string that will be parsed into a URI object.
 * @throws TypeError If the string argument is not a valid URI, a TypeError will
 *     be thrown.
 * @return {URI} The parsed URI object.
 */
URI.fromString = function(str) {
  var splitted = _splitIntoComponents(str);
  return _parseFromComponents(splitted.components, splitted.format);
};

/**
 * Parses a given object into a URI instance.
 *
 * Unlike URI.fromString, this function could receive any kind of value. If
 * the value is already a URI instance, it is simply returned.
 * Otherwise the value will be stringified before parsing.
 *
 * This function also does not throw an error like URI.fromString, but
 * instead simply returns null if it can't parse the value.
 *
 * @param {*} value The value to parse.
 * @return {URI?} The corresponding URI instance, or null if the
 *     passed value is not a valid value.
 */
URI.from = function(value) {
  try {
    if (value instanceof URI) {
      return value;
    }
    if (typeof value == 'object' && value.type) {
      return new URI(null, value);
    }
    return URI.fromString(value.toString());
  } catch(e) {
    return null;
  }
};

/**
 * Creates a new URI from a bytestring.
 *
 * @param {URI.Type} type The type of the URI.
 * @param {ByteString} idByteString The ID of the URI as a bytestring.
 * @param {Object} opt_args Optional arguments to the URI constructor.
 * @return {URI} The URI object created.
 */
URI.fromByteString = function(type, idByteString, opt_args) {
  var bytes = [];
  for (var i = 0; i < idByteString.length; i++) {
    bytes.push(idByteString.charCodeAt(i));
  }
  var id = Base62.fromBytes(bytes, 22);
  var args = opt_args || {};
  args.id = id;
  return new URI(type, args);
};

/**
 * Clones a given SpotifyURI instance.
 *
 * @param {URI} uri The uri to clone.
 * @return {URI?} An instance of URI.
 */
URI.clone = function(uri) {
  if (!(uri instanceof URI)) {
    return null;
  }
  return new URI(null, uri);
};

/**
 * @deprecated
 */
URI.getCanonical = function(username) {
  return this.getCanonical(username);
};

/**
 * Returns the canonical representation of a username.
 *
 * @param {string} username The username to encode.
 * @return {string} The encoded canonical representation of the username.
 */
URI.getCanonicalUsername = function(username) {
  return _encodeComponent(username, Format.URI);
};

/**
 * Returns the non-canonical representation of a username.
 *
 * @param {string} username The username to encode.
 * @return {string} The unencoded canonical representation of the username.
 */
URI.getDisplayUsername = function(username) {
  return _decodeComponent(username, Format.URI);
};

/**
 * Returns the hex representation of a Base62 encoded id.
 *
 * @param {string} id The base62 encoded id.
 * @return {string} The hex representation of the base62 id.
 */
URI.idToHex = function(id) {
  if (id.length == 22) {
    return Base62.toHex(id, 32);
  }
  return id;
};

/**
 * Returns the base62 representation of a hex encoded id.
 *
 * @param {string} hex The hex encoded id.
 * @return {string} The base62 representation of the id.
 */
URI.hexToId = function(hex) {
  if (hex.length == 32) {
    return Base62.fromHex(hex, 22);
  }
  return hex;
};

/**
 * Creates a new empty URI.
 *
 * @return {URI} The empty URI.
 */
URI.emptyURI = function() {
  return new URI(URI.Type.EMPTY, {});
};

/**
 * Creates a new 'album' type URI.
 *
 * @param {string} id The id of the album.
 * @param {number} disc The disc number of the album.
 * @return {URI} The album URI.
 */
URI.albumURI = function(id, disc) {
  return new URI(URI.Type.ALBUM, {id: id, disc: disc});
};

/**
 * Creates a new 'ad' type URI.
 *
 * @param {string} id The id of the ad.
 * @return {URI} The ad URI.
 */
URI.adURI = function(id) {
  return new URI(URI.Type.AD, {id: id});
};

/**
 * Creates a new 'audiofile' type URI.
 *
 * @param {string} extension The extension of the audiofile.
 * @param {string} id The id of the extension.
 * @return {URI} The audiofile URI.
 */
URI.audioFileURI = function(extension, id) {
  return new URI(URI.Type.AUDIO_FILE, {id: id, extension: extension});
};

/**
 * Creates a new 'artist' type URI.
 *
 * @param {string} id The id of the artist.
 * @return {URI} The artist URI.
 */
URI.artistURI = function(id) {
  return new URI(URI.Type.ARTIST, {id: id});
};

/**
 * Creates a new 'artist-toplist' type URI.
 *
 * @param {string} id The id of the artist.
 * @param {string} toplist The toplist type.
 * @return {URI} The artist-toplist URI.
 */
URI.artistToplistURI = function(id, toplist) {
  return new URI(URI.Type.ARTIST_TOPLIST, {id: id, toplist: toplist});
};

/**
 * Creates a new 'search' type URI.
 *
 * @param {string} query The unencoded search query.
 * @return {URI} The search URI
 */
URI.searchURI = function(query) {
  return new URI(URI.Type.SEARCH, {query: query});
};

/**
 * Creates a new 'track' type URI.
 *
 * @param {string} id The id of the track.
 * @param {string} anchor The point in the track formatted as mm:ss
 * @return {URI} The track URI.
 */
URI.trackURI = function(id, anchor) {
  return new URI(URI.Type.TRACK, {id: id, anchor: anchor});
};

/**
 * Creates a new 'trackset' type URI.
 *
 * @param {Array.<URI>} tracks An array of 'track' type URIs.
 * @param {string} name The name of the trackset.
 * @param {number} index The index in the trackset.
 * @return {URI} The trackset URI.
 */
URI.tracksetURI = function(tracks, name, index) {
  return new URI(URI.Type.TRACKSET, {
    tracks: tracks,
    name: name || '',
    index: isNaN(index) ? null : index
  });
};

/**
 * Creates a new 'facebook' type URI.
 *
 * @param {string} uid The user id.
 * @return {URI} The facebook URI.
 */
URI.facebookURI = function(uid) {
  return new URI(URI.Type.FACEBOOK, {uid: uid});
};

/**
 * Creates a new 'followers' type URI.
 *
 * @param {string} username The non-canonical username.
 * @return {URI} The followers URI.
 */
URI.followersURI = function(username) {
  return new URI(URI.Type.FOLLOWERS, {username: username});
};

/**
 * Creates a new 'following' type URI.
 *
 * @param {string} username The non-canonical username.
 * @return {URI} The following URI.
 */
URI.followingURI = function(username) {
  return new URI(URI.Type.FOLLOWING, {username: username});
};

/**
 * Creates a new 'playlist' type URI.
 *
 * @param {string} username The non-canonical username of the playlist owner.
 * @param {string} id The id of the playlist.
 * @return {URI} The playlist URI.
 */
URI.playlistURI = function(username, id) {
  return new URI(URI.Type.PLAYLIST, {username: username, id: id});
};

/**
 * Creates a new 'folder' type URI.
 *
 * @param {string} username The non-canonical username of the folder owner.
 * @param {string} id The id of the folder.
 * @return {URI} The folder URI.
 */
URI.folderURI = function(username, id) {
  return new URI(URI.Type.FOLDER, {username: username, id: id});
};

/**
 * Creates a new 'collectiontracklist' type URI.
 *
 * @param {string} username The non-canonical username of the collection owner.
 * @param {string} id The id of the tracklist.
 * @return {URI} The collectiontracklist URI.
 */
URI.collectionTrackList = function(username, id) {
  return new URI(URI.Type.COLLECTION_TRACK_LIST, {username: username, id: id});
};

/**
 * Creates a new 'starred' type URI.
 *
 * @param {string} username The non-canonical username of the starred list owner.
 * @return {URI} The starred URI.
 */
URI.starredURI = function(username) {
  return new URI(URI.Type.STARRED, {username: username});
};

/**
 * Creates a new 'user-toplist' type URI.
 *
 * @param {string} username The non-canonical username of the toplist owner.
 * @param {string} toplist The toplist type.
 * @return {URI} The user-toplist URI.
 */
URI.userToplistURI = function(username, toplist) {
  return new URI(URI.Type.USER_TOPLIST, {username: username, toplist: toplist});
};

/**
 * Creates a new 'user-top-tracks' type URI.
 *
 * @deprecated
 * @param {string} username The non-canonical username of the toplist owner.
 * @return {URI} The user-top-tracks URI.
 */
URI.userTopTracksURI = function(username) {
  return new URI(URI.Type.USER_TOP_TRACKS, {username: username});
};

/**
 * Creates a new 'toplist' type URI.
 *
 * @param {string} toplist The toplist type.
 * @param {string} country The country code for the toplist.
 * @param {boolean} global True if this is a global rather than a country list.
 * @return {URI} The toplist URI.
 */
URI.toplistURI = function(toplist, country, global) {
  return new URI(URI.Type.TOPLIST, {toplist: toplist, country: country, global: !!global});
};

/**
 * Creates a new 'inbox' type URI.
 *
 * @param {string} username The non-canonical username of the inbox owner.
 * @return {URI} The inbox URI.
 */
URI.inboxURI = function(username) {
  return new URI(URI.Type.INBOX, {username: username});
};

/**
 * Creates a new 'rootlist' type URI.
 *
 * @param {string} username The non-canonical username of the rootlist owner.
 * @return {URI} The rootlist URI.
 */
URI.rootlistURI = function(username) {
  return new URI(URI.Type.ROOTLIST, {username: username});
};

/**
 * Creates a new 'published-rootlist' type URI.
 *
 * @param {string} username The non-canonical username of the published-rootlist owner.
 * @return {URI} The published-rootlist URI.
 */
URI.publishedRootlistURI = function(username) {
  return new URI(URI.Type.PUBLISHED_ROOTLIST, {username: username});
};

/**
 * Creates a new 'local-artist' type URI.
 *
 * @param {string} artist The artist name.
 * @return {URI} The local-artist URI.
 */
URI.localArtistURI = function(artist) {
  return new URI(URI.Type.LOCAL_ARTIST, {artist: artist});
};

/**
 * Creates a new 'local-album' type URI.
 *
 * @param {string} artist The artist name.
 * @param {string} album The album name.
 * @return {URI} The local-album URI.
 */
URI.localAlbumURI = function(artist, album) {
  return new URI(URI.Type.LOCAL_ALBUM, {artist: artist, album: album});
};

/**
 * Creates a new 'local' type URI.
 *
 * @param {string} artist The artist name.
 * @param {string} album The album name.
 * @param {string} track The track name.
 * @param {number} duration The track duration in ms.
 * @return {URI} The local URI.
 */
URI.localURI = function(artist, album, track, duration) {
  return new URI(URI.Type.LOCAL, {
    artist: artist,
    album: album,
    track: track,
    duration: duration
  });
};

/**
 * Creates a new 'library' type URI.
 *
 * @param {string} username The non-canonical username of the rootlist owner.
 * @param {string} category The category of the library.
 * @return {URI} The library URI.
 */
URI.libraryURI = function(username, category) {
  return new URI(URI.Type.LIBRARY, {username: username, category: category});
};

/**
 * Creates a new 'collection' type URI.
 *
 * @param {string} username The non-canonical username of the rootlist owner.
 * @param {string} category The category of the collection.
 * @return {URI} The collection URI.
 */
URI.collectionURI = function(username, category) {
  return new URI(URI.Type.COLLECTION, {username: username, category: category});
};

/**
 * Creates a new 'temp-playlist' type URI.
 *
 * @param {string} origin The origin of the temporary playlist.
 * @param {string} data Additional data for the playlist.
 * @return {URI} The temp-playlist URI.
 */
URI.temporaryPlaylistURI = function(origin, data) {
  return new URI(URI.Type.TEMP_PLAYLIST, {origin: origin, data: data});
};

/**
 * Creates a new 'context-group' type URI.
 *
 * @deprecated
 * @param {string} origin The origin of the temporary playlist.
 * @param {string} name The name of the context group.
 * @return {URI} The context-group URI.
 */
URI.contextGroupURI = function(origin, name) {
  return new URI(URI.Type.CONTEXT_GROUP, {origin: origin, name: name});
};

/**
 * Creates a new 'profile' type URI.
 *
 * @param {string} username The non-canonical username of the rootlist owner.
 * @param {Array.<string>} args A list of arguments.
 * @return {URI} The profile URI.
 */
URI.profileURI = function(username, args) {
  return new URI(URI.Type.PROFILE, {username: username, args: args});
};

/**
 * Creates a new 'image' type URI.
 *
 * @param {string} id The id of the image.
 * @return {URI} The image URI.
 */
URI.imageURI = function(id) {
  return new URI(URI.Type.IMAGE, {id: id});
};

/**
 * Creates a new 'mosaic' type URI.
 *
 * @param {Array.<string>} ids The ids of the mosaic immages.
 * @return {URI} The mosaic URI.
 */
URI.mosaicURI = function(ids) {
  return new URI(URI.Type.MOSAIC, {ids: ids});
};

/**
 * Creates a new 'radio' type URI.
 *
 * @param {string} args The radio seed arguments.
 * @return {URI} The radio URI.
 */
URI.radioURI = function(args) {
  args = typeof args === 'undefined' ? '' : args;
  return new URI(URI.Type.RADIO, {args: args});
};

/**
 * Creates a new 'special' type URI.
 *
 * @param {Array.<string>} args An array containing the other arguments.
 * @return {URI} The special URI.
 */
URI.specialURI = function(args) {
  args = typeof args === 'undefined' ? [] : args;
  return new URI(URI.Type.SPECIAL, {args: args});
};

/**
 * Creates a new 'station' type URI.
 *
 * @param {Array.<string>} args An array of arguments for the station.
 * @return {URI} The station URI.
 */
URI.stationURI = function(args) {
  args = typeof args === 'undefined' ? [] : args;
  return new URI(URI.Type.STATION, {args: args});
};

/**
 * Creates a new 'application' type URI.
 *
 * @param {string} id The id of the application.
 * @param {Array.<string>} args An array containing the arguments to the app.
 * @return {URI} The application URI.
 */
URI.applicationURI = function(id, args) {
  args = typeof args === 'undefined' ? [] : args;
  return new URI(URI.Type.APPLICATION, {id: id, args: args});
};

/**
 * Creates a new 'collection-album' type URI.
 *
 * @param {string} username The non-canonical username of the rootlist owner.
 * @param {string} id The id of the album.
 * @return {URI} The collection-album URI.
 */
URI.collectionAlbumURI = function(username, id) {
  return new URI(URI.Type.COLLECTION_ALBUM, {username: username, id: id});
};

/**
 * Creates a new 'collection-album-missing' type URI.
 *
 * @param {string} username The non-canonical username of the rootlist owner.
 * @param {string} id The id of the album.
 * @return {URI} The collection-album-missing URI.
 */
URI.collectionMissingAlbumURI = function(username, id) {
  return new URI(URI.Type.COLLECTION_MISSING_ALBUM, {username: username, id: id});
};

/**
 * Creates a new 'collection-artist' type URI.
 *
 * @param {string} username The non-canonical username of the rootlist owner.
 * @param {string} id The id of the artist.
 * @return {URI} The collection-artist URI.
 */
URI.collectionArtistURI = function(username, id) {
  return new URI(URI.Type.COLLECTION_ARTIST, {username: username, id: id});
};

/**
 * Creates a new 'episode' type URI.
 *
 * @param {string} id The id of the episode.
 * @return {URI} The episode URI.
 */
URI.episodeURI = function(id) {
  return new URI(URI.Type.EPISODE, {id: id});
};

/**
 * Export public interface
 */
module.exports = URI;

},{"spotify-crypto/src/base62":392}],399:[function(require,module,exports){
'use strict';

var Range = require('spotify-range2');

/**
 * Get the needed operations for inserting items at a specific index.
 *
 * @param {Array} items Array of items to insert.
 * @param {number} index Index to insert the items at, relative to the list
 *     before the operations.
 *
 * @return {Array.<Object>} Array of operation objects.
 */
function getInsertOperations(items, index) {
  return [{type: 'insert', index: index, values: items}];
}

/**
 * Get the needed operations for removing items from the specified indices.
 *
 * @param {Array.<number>} indices Array of indices relative to the list before
 *     the operations.
 *
 * @return {Array.<Object>} Array of operation objects.
 */
function getRemoveOperations(indices) {
  var ranges = Range.fromIndices(indices);

  var removed = 0;
  var operations = [];

  for (var r = 0, range; (range = ranges[r]); r++) {
    operations.push({type: 'remove', index: range.start - removed, length: range.length});
    removed += range.length;
  }

  return operations;
}

/**
 * Get the needed operations for moving items from a set of indices to a
 * target index.
 *
 * @param {Array.<number>} fromIndices Array of indices relative to the list
 *     before the operations.
 * @param {number} toIndex Index to move the items to, relative to the list
 *     before the operations.
 *
 * @return {Array.<Object>} Array of operation objects.
 */
function getMoveOperations(fromIndices, toIndex) {

  // We're going through one range at a time, and when a range is moved down,
  // we need to decrease the start of the next range to account for the
  // range we moved down (since each operation is based on the result of
  // the previous operation).
  var movedAbove = 0;

  // The maximum index starts at the index we want to move to.
  // When operations are created to move ranges, this maximum index
  // is increased to always point to the bottom index of the moved
  // items. If five items are moved from far down up to the 'to' index,
  // the new maxIndex will be toIndex + 5.
  var maxIndex = toIndex;

  var ranges = Range.fromIndices(fromIndices);
  var r, range;
  var toRange;

  // Find any range that intersects with the 'to' index. Referred below as
  // the 'to' range. This range can't be split, so we need to move items to
  // positions above or below this range if it exists.
  for (r = 0; (range = ranges[r]); r++) {
    if (range.start <= toIndex && range.end >= toIndex) {
      toRange = range;
      break;
    }
  }

  var operations = [];

  for (r = 0; (range = ranges[r]); r++) {
    var length = range.length;
    var to;
    var from = range.start - movedAbove;

    // If the 'to' index is inside a range
    if (toRange) {

      // Range is above the 'to' range, so move it to right above that range.
      if (range.end < toRange.start) {
        from = range.start - movedAbove;
        to = toRange.start - length;
        movedAbove += length;

      // Range is the 'to' range, which means it will not move anywhere.
      } else if (range === toRange) {
        maxIndex = Math.max(maxIndex, range.end);
        continue;

      // Range is below the 'to' range, so move it to the maximum index
      // we've reached so far.
      } else {
        from = range.start;
        to = maxIndex;
        maxIndex = Math.max(maxIndex, to + length);
      }

    // If the 'to' index is not inside a range
    } else {

      // Range is above the 'to' index, so move it to right above the maximum index.
      if (range.end < toIndex) {
        from = range.start - movedAbove;
        to = maxIndex - length;
        movedAbove += length;

      // Range is below the 'to' index, so move it to the maximum index we've
      // reached so far.
      } else {
        from = range.start;
        to = maxIndex;
        maxIndex = Math.max(maxIndex, to + length);
      }
    }

    operations.push({type: 'move', from: from, length: length, to: to});
  }

  return operations;
}

exports.getInsertOperations = getInsertOperations;
exports.getRemoveOperations = getRemoveOperations;
exports.getMoveOperations = getMoveOperations;

},{"spotify-range2":404}],400:[function(require,module,exports){
var player = require("./player");
var types = require("./types");
var play = require("./play");

exports.Play = play.Play;
exports.Player = player.Player;
exports.PlayerContext = types.Context;
exports.PlayOptions = types.PlayOptions;
exports.PlayerRestrictions = types.Restrictions;
exports.PlayerSuppressions = types.Suppressions;
exports.PlayerTrack = types.Track;
exports.PlayerContextPage = types.ContextPage;
exports.IndexPath = types.IndexPath;

},{"./play":401,"./player":402,"./types":403}],401:[function(require,module,exports){
var cosmos = require('spotify-cosmos-api');
var nodefn = require('when/node');

/**
 * Play is exposed as Player.Play. It represents a prepared playback action.
 * Play objects are obtained from the preparePlay method on the Player; the
 * constructor is not a public API.
 *
 * Instantiating a Play object does not make a Cosmos request, the caller is
 * expected to make that call and pass in a promise of the result in the
 * createSessionPromise parameter.
 *
 * @param {Cosmos.resolver} resolver The resolver to send requests to.
 * @param {Promise} createSessionPromise A promise of a Cosmos.Response for
 *     the call to sp://player/v2/xyz/session.
 * @param {Player} player The player that initiated the call.
 * @param {function()=Number} getTime Clock. Should usually return
 *     new Date().getTime()
 * @param {module:spotify-player/types.Context} The context that was passed
 *     to the preparePlay call.
 * @param {Cosmos.PlayOptions=} opt_options The options that were passed to
 *     the preparePlay call.
 */
function Play(resolver, createSessionPromise, player, getTime, context, opt_options) {
  if (!(this instanceof Play)) {
    return new Play(resolver, createSessionPromise, player, getTime, context, opt_options);
  }

  if (!resolver || !createSessionPromise || !player || !getTime || !context) {
    throw new TypeError('Missing parameters for Play');
  }

  /**
   * @type {Cosmos.resolver}
   */
  this._resolver = resolver;

  /**
   * @type {Promise}
   */
  this._createSessionPromise = createSessionPromise;

  /**
   * @type {Player}
   */
  this._player = player;

  /**
   * @type {function()=Number}
   */
  this._getTime = getTime;

  /**
   * @type {module:spotify-player/types.Context}
   */
  this._context = context;

  /**
   * @type {Cosmos.PlayOptions=}
   */
  this._opt_options = opt_options;
}

/**
 * @return Promise of the session URL
 */
Play.prototype._sessionUrl = function() {
  return this._createSessionPromise.then(function(response) {
    return response.getJSONBody().session;
  });
};

Play.prototype._createPlayRequest = function(sessionUrl) {
  var body = {
    logging_params: {
      command_initiated_time: this._getTime()
    }
  };
  return new cosmos.Request(cosmos.Action.POST, sessionUrl + '/play', null, body);
};

Play.prototype._createUpdateRequest = function(sessionUrl, body) {
  body.logging_params = {
    command_initiated_time: this._getTime()
  };
  return new cosmos.Request(cosmos.Action.POST, sessionUrl + '/update', null, body);
};

/**
 * Perform the playback action that this handle represents.
 *
 * It is legal to call play more than once, but the playback action is only
 * prefetched the first time. If subsequent preparation is required, a new
 * Play object should be obtained.
 */
Play.prototype.play = function(opt_callback) {
  opt_callback = opt_callback || function() {};

  var self = this;
  if (this._createSessionPromise) {
    this._sessionUrl()
      .then(function(sessionUrl) {
        return nodefn.call(
          self._resolver.resolve.bind(self._resolver), self._createPlayRequest(sessionUrl));
      })
      .done(function() {
          opt_callback(null);
        }, function(error) {
          if (error.response && error.response.getStatusCode() === 404) {
            // The session has been invalidated. Try again without prefetching.
            self._createSessionPromise = null;
            self.play(opt_callback);
          } else {
            var wrappedError = new Error('Failed to prepare playback session: ' + error.message);
            wrappedError.cause = function() { return error; };
            opt_callback(wrappedError);
          }
        });
  } else {
    this._player.play(this._context, this._opt_options, opt_callback);
  }
};

Play.prototype._update = function(body, opt_callback) {
  opt_callback = opt_callback || function() {};

  var self = this;
  if (!this._createSessionPromise) {
    return opt_callback(new Error('Cannot update invalidated Play'));
  }

  this._sessionUrl()
    .then(function(sessionUrl) {
      return nodefn.call(
        self._resolver.resolve.bind(self._resolver), self._createUpdateRequest(sessionUrl, body));
    })
    .done(function() {
        opt_callback(null);
      }, function(error) {
        var wrappedError = new Error('Failed to update playback session: ' + error.message);
        wrappedError.cause = function() { return error; };
        opt_callback(wrappedError);
      });
};

Play.prototype.updateContext = function(context, opt_callback) {
  this._update({ context: context }, opt_callback);
};

Play.prototype.updatePage = function(page, opt_callback) {
  this._update({ page: page }, opt_callback);
};

Play.prototype.updateTrack = function(track, opt_callback) {
  this._update({ track: track }, opt_callback);
};

Play.prototype.updateViewUri = function(view_uri, opt_callback) {
  this._update({ view_uri: view_uri }, opt_callback);
};

/**
 * Invalidate the handle. This will cause any ongoing prefetching work to be
 * cancelled. It is good if any holder of a handle calls this method as soon
 * as it knows that it is not interested in its play action anymore.
 *
 * It is illegal to call play after this has been called. Invalidating an
 * invalidated Play is a no-op.
 */
Play.prototype.invalidate = function(opt_callback) {
  if (!this._createSessionPromise) {
    // Already invalidated
    return;
  }

  opt_callback = opt_callback || function() {};

  var self = this;
  this._sessionUrl().done(function(sessionUrl) {
    var request = new cosmos.Request(
      cosmos.Action.DELETE, sessionUrl, null, null);
    self._resolver.resolve(request, function() {
      opt_callback(null);
    });
  }, function() {
    // Ignore errors
    opt_callback(null);
  });

  this._createSessionPromise = null;
};

exports.Play = Play;

},{"spotify-cosmos-api":388,"when/node":438}],402:[function(require,module,exports){
var cosmos = require('spotify-cosmos-api');
var nodefn = require('when/node');
var play = require('./play');

var PLAYER_URI = 'sp://player/v2/';
var DEFAULT_PLAYER_ID = 'main';

/**
 * The object decribing the context for the playback
 * Can be used to pass viewUri or externalReferrer specific
 * for the play action.
 *
 * @typedef {Object} ContextConfig
 * @property {Cosmos.PlayerContext} context The context to play
 * @property {string=} opt_viewId Optional. Set to override the default viewUri
 * @property {string=} opt_externalReferrer Optional. Set to indicate that
 *      the playback is owne by external website/app.
 */

/**
 * Player is the main entry point to control music playback with cosmos.
 *
 * Player in itself isn't what deals with playback; it is merely an object
 * that controls playback and provides ability to observe the player state.
 * There can be more than one Player object at the same time, and they
 * will sync up as one would expect.
 *
 * In practice there will be at least one Player object per feature that
 * wants to control playback. The feature can choose to create one per view
 * or have only one object, it doesn't really matter.
 *
 * @param {Cosmos.resolver} resolver The resolver to send requests to.
 * @param {String} viewUri The uri of the view that owns the playback.
 * @param {String} featureIdentifier The identifier of the feature that started
 *     playback. This is arguably the most important field of this class. It is
 *     used for logging messages, in particular EndSong and EndVideo. (In EndSong,
 *     it ends up in source_start / source_end.) It should be a short human
 *     readable name of the feature, for example "radio", "album", "playlist".
 *     Ideally, it should be the same for a given feature across platforms.
 *
 *     Each feature should have only one string constant that it passes in here.
 *     You must not pass lots of distinct values here; for instance do not send
 *     something that contains the username or artist identifier.
 * @param {String} featureVersion The version of the feature. It often makes sense to set
 *     this value to the version of the spm package, for instance "0.7.5".
 * @param {{playerId: string}} opt_options The additional parameters for the player.
 *  param {string} options.playerId Can be used to override the id of the player
 *      which will result in a different endpoint for the player requests.
 */
function Player(resolver, viewUri, featureIdentifier, featureVersion, opt_options) {
  if (!(this instanceof Player)) {
    return new Player(resolver, viewUri, featureIdentifier, featureVersion);
  }

  if (!resolver || !viewUri || !featureIdentifier || !featureVersion) {
    throw new TypeError('Missing parameters for Player');
  }

  this._getTime = opt_options && opt_options.getTime || function() {
    return new Date().getTime();
  };

  /**
   * @type {string}
   */
  this._id = opt_options && opt_options.playerId || DEFAULT_PLAYER_ID;

  /**
   * @type {string}
   */
  this._referrerIdentifier = opt_options && opt_options.referrerIdentifier;

  /**
   * @type {Cosmos.resolver}
   */
  this._resolver = resolver;

  /**
   * @type {string}
   */
  this._viewUri = viewUri;

  /**
   * @type {string}
   */
  this._featureId = featureIdentifier;

  /**
   * @type {string}
   */
  this._featureVersion = featureVersion;
}

/**
 * The actions that can be understood by the PlayerResolver
 * in Cosmos Router.
 */
Player.Actions = {
  PLAY: 'play',
  SESSION: 'session',
  STOP: 'stop',
  UPDATE: 'update',
  PAUSE: 'pause',
  RESUME: 'resume',
  SKIP_NEXT: 'skip_next',
  SKIP_PREV: 'skip_prev',
  SHUFFLE: 'set_shuffling_context',
  REPEAT_CONTEXT: 'set_repeating_context',
  REPEAT_TRACK: 'set_repeating_track',
  SEEK_TO: 'seek_to'
};

/**
 * Private helper method for play and preparePlay
 */
Player.prototype._playOrPrepare = function(action, context, opt_options, opt_callback) {
  if (!context)
    throw new TypeError('Invalid `context` object');

  // Allow to not send the opt_options
  if (opt_options instanceof Function && !opt_callback) {
    opt_callback = opt_options;
    opt_options = null;
  }

  var params = {};
  params.context = context;
  params.play_origin = this._makePlayOrigin();
  params.options = opt_options;

  return this._sendRequestWithParams(action, params, opt_callback);
};

/**
 * Plays the given context.
 * Since both options and callback are optional this method can
 * take from 1 to 3 arguments. if callback is specified, it has to be
 * the last argument:
 *
 *    player.play(myContext);
 *    player.play(myContext, myPlayOptions);
 *    player.play(myContext, function myCallback() {});
 *    player.play(myContext, myPlayOptions, function myCallback() {});
 *
 * @param {module:spotify-player/types.Context} context The context to play.
 * @param {Cosmos.PlayOptions=} opt_options Optional play options.
 * @param {function(Error, Cosmos.Response?)=} opt_callback Optional
 *    callback that will be executed after player request is resolved.
 *
 *    NOTE: The reponse in the callback only has information about the
 *    request itself (i.e. if it was resolved correctly). If you want to have
 *    information about currently playing context you should subscribe to
 *    player events or fetch the current state using. getContext.
 *
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.play = function(context, opt_options, opt_callback) {
  return this._playOrPrepare(Player.Actions.PLAY, context, opt_options, opt_callback);
};

/**
 * This method is like play, but it doesn't actually initiate playback, it
 * merely expresses intent that the user is rather likely going to do a play
 * action like this soon.
 *
 * @return {Player.Play} A handle that is used for actually performing the
 *     playback action. When the object will no longer be used, the user is
 *     responsible for calling invalidate on it, otherwise it will keep
 *     holding resources. As long as this object is not invalidated, the
 *     playback system will take that as a hint that it should try to prepare
 *     playback like this.
 */
Player.prototype.preparePlay = function(context, opt_options) {
  var sessionPromise = nodefn.call(
    this._playOrPrepare.bind(this), Player.Actions.SESSION, context, opt_options);

  return new play.Play(this._resolver, sessionPromise, this, this._getTime, context, opt_options);
};

/**
 * Stop the playback and clear the context.
 *
 * @param {function=} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.stop = function(opt_callback) {
  return this._sendRequestWithAction(Player.Actions.STOP, opt_callback);
};

/**
 * Update the current context.
 *
 * @see https://short.spotify.net/0I for more detailed information on the
 *    implementation.
 *
 * @param {module:spotify-player/types.Context} context The context to update to.
 * @param {function=} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.update = function(context, opt_callback) {
  if (!context)
    throw new TypeError('Invalid `context` object');

  var params = { context: context };
  return this._sendRequestWithParams(Player.Actions.UPDATE, params, opt_callback);
};

/**
 * Resume the playback.
 *
 * @param {function=} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.resume = function(opt_callback) {
  return this._sendRequestWithAction(Player.Actions.RESUME, opt_callback);
};

/**
 * Pause the playback.
 *
 * @param {function=} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.pause = function(opt_callback) {
  return this._sendRequestWithAction(Player.Actions.PAUSE, opt_callback);
};

/**
 * Skip to the previous song.
 *
 * @param {Object=} opt_skip_options The object with the skip options
 *    like allow_seeking
 * @param {function=} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.skipToPrevTrack = function(opt_skip_options, opt_callback) {
  if (arguments.length === 1) {
    // In order to keep backwards compatibility we still need to support
    // passing just the callback as the first parameter
    if (typeof opt_skip_options === 'function') {
      opt_callback = opt_skip_options;
      opt_skip_options = null;
    }
  }
  var params = {};
  if (opt_skip_options) {
    params.options = opt_skip_options;
  }
  return this._sendRequestWithParams(Player.Actions.SKIP_PREV, params, opt_callback);
};

/**
 * Skip to the next song.
 *
 * @param {function=} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.skipToNextTrack = function(opt_callback) {
  return this._sendRequestWithAction(Player.Actions.SKIP_NEXT, opt_callback);
};

/**
 * Skip backwards until it gets to the specified track. This method never skips
 * to the beginning of the current track. For that, use seekTo.
 *
 * @discussion If the reverse runs out of tracks or skipping becomes disallowed
 *    for some other reason, this method will give up when it can no longer
 *    continue. This means that calling this for MFT users will almost
 *    certainly be a bad idea.
 *
 *    The intended purpose of this method is to make it possible to implement
 *    a view of the current future/reverse and allow the user to skip in it.
 *
 *    This method will look at the track URI and the track's UID (if present)
 *    to determine when it has reached its goal.
 *
 * @param {Object} track The track object, as it was provided from the
 *    player state reverse.
 * @param {function=} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.skipToSpecificPrevTrack = function(track, opt_callback) {
  return this._sendRequestWithParams(Player.Actions.SKIP_PREV, { track: track }, opt_callback);
};

/**
 * Skip forwards until it gets to the specified track.
 *
 * @discussion See discussion for -skipToPreviousTrack:
 *
 * @param {Object} track The track object, as it was provided from the
 *    player state reverse.
 * @param {function=} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.skipToSpecificNextTrack = function(track, opt_callback) {
  return this._sendRequestWithParams(Player.Actions.SKIP_NEXT, { track: track }, opt_callback);
};

/**
 * Deprecated alias for skipToPrevTrack
 */
Player.prototype.skipToPrev = Player.prototype.skipToPrevTrack;

/**
 * Deprecated alias for skipToNextTrack
 */
Player.prototype.skipToNext = Player.prototype.skipToNextTrack;

/**
 * Set the shuffle flag
 *
 * @param {boolean} isShuffling The value of the flag to set.
 * @param {function=} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.setShufflingContext = function(isShuffling, opt_callback) {
  return this._sendRequestWithParam(Player.Actions.SHUFFLE, isShuffling, opt_callback);
};

/**
 * Repeat the whole context
 *
 * @param {boolean} isRepeating The value of the flag to set.
 * @param {function=} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.setRepeatingContext = function(isRepeating, opt_callback) {
  return this._sendRequestWithParam(Player.Actions.REPEAT_CONTEXT, isRepeating, opt_callback);
};

/**
 * Repeat the single track
 *
 * @param {boolean} isRepeating The value of the flag to set.
 * @param {function=} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.setRepeatingTrack = function(isRepeating, opt_callback) {
  return this._sendRequestWithParam(Player.Actions.REPEAT_TRACK, isRepeating, opt_callback);
};

/**
 * Set the seek position. It should be set in seconds.
 *
 * @param {boolean} positionInMs Position to seek to in miliseconds.
 * @param {function=} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.seekTo = function(positionInMs, opt_callback) {
  return this._sendRequestWithParam(Player.Actions.SEEK_TO, positionInMs, opt_callback);
};

/**
 * Gets the current player state as an opaque string that can later be used to restore the
 * current state.
 *
 * @param {function(Error, Cosmos.Response=)} callback The function
 *    that will be called when the snapshot is available.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.save = function(callback) {
  var requestUri = this.getPlayerEndpointUri() + '/snapshot';
  var request = new cosmos.Request(cosmos.Action.GET, requestUri);
  return this._resolver.resolve(request, callback);
};

/**
 * Restores a state string that was previously saved by save().
 *
 * @param {string} state The state to restore.
 * @param {function(Error, Cosmos.Response=)} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.restore = function(state, opt_callback) {
  var requestUri = this.getPlayerEndpointUri() + '/snapshot';
  var request = new cosmos.Request(cosmos.Action.PUT, requestUri, null, state);
  return this._resolver.resolve(request, opt_callback);
};

/**
 * Gets the current player queue as an string that can later be modified to replace
 * the current queue.
 *
 * @param {function(Error, Cosmos.Response=)} callback The function
 *    that will be called when the queue is available.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */

Player.prototype.getQueue = function(callback) {
  var requestUri = this.getPlayerEndpointUri() + '/queue';
  var request = new cosmos.Request(cosmos.Action.GET, requestUri);
  return this._resolver.resolve(request, callback);
};

/**
 * Replace the player queue. The state will not replace the current one of the player if
 * the revision does not match the current revision of the player. This happens when
 * the player queue was changed elsewhere by the time it was received until it was set.
 * A response-status of 409 will inform about this situation.
 *
 * @param {string} state The queue-state to replace with.
 * @param {function(Error, Cosmos.Response=)} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.setQueue = function(state, opt_callback) {
  var requestUri = this.getPlayerEndpointUri() + '/queue';
  var request = new cosmos.Request(cosmos.Action.PUT, requestUri, null, state);
  return this._resolver.resolve(request, opt_callback);
};

/**
 * Subscribe to queue changes. There will be an initial callback when subscribing.
 */
Player.prototype.subscribeToQueue = function(callback) {
  var request = new cosmos.Request(cosmos.Action.SUB, this.getPlayerEndpointUri() + '/queue');
  return this._resolver.resolve(request, callback);
};

/**
 * Get the current player state.
 *
 * @param {function(Error, Cosmos.Response=)} callback The function
 *    that will be called when the state is available.
 * @param {Object=} opt_params The additional parameters for the request.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.getState = function(callback, opt_params) {
  var request = new cosmos.Request(
    cosmos.Action.GET, this.getPlayerEndpointUriWithParams(opt_params));
  return this._resolver.resolve(request, callback);
};

/**
 * Subscribe to the player events
 *
 * @param {function(Error, Cosmos.Response=)} callback The function
 *    that will be called every time the event occurs.
 * @param {Object=} opt_params The additional parameters for the request.
 * @return {RequestHandle} The subscription handle.
 *
 *    This object can be used to cancel the subscription
 *    by calling 'cancel()' on it:
 *
 *    var sub = player.subscribe(function(err, response) { });
 *    sub.cancel();
 */
Player.prototype.subscribe = function(callback, opt_params) {
  var request = new cosmos.Request(
    cosmos.Action.SUB, this.getPlayerEndpointUriWithParams(opt_params));
  return this._resolver.resolve(request, callback);
};

/**
 * Subscribe to player error events
 */
Player.prototype.onError = function(callback) {
  var request = new cosmos.Request(cosmos.Action.SUB, this.getPlayerEndpointUri() + '/error');
  return this._resolver.resolve(request, callback);
};

Player.prototype._makePlayOrigin = function() {
  return {
    view_uri: this._viewUri,
    feature_identifier: this._featureId,
    feature_version: this._featureVersion,
    referrer_identifier: this._referrerIdentifier
  };
};

Player.prototype.getPlayerEndpointUri = function() {
  return PLAYER_URI + this._id;
};

Player.prototype.getPlayerEndpointUriWithParams = function(params) {
  params = params || {};

  var paramsArray = Object.keys(params).reduce(function(arr, key) {
    arr.push(key + '=' + encodeURIComponent(params[key]));
    return arr;
  }, []);

  if (paramsArray.length > 0) {
    return this.getPlayerEndpointUri() + '?' + paramsArray.join('&');
  } else {
    return this.getPlayerEndpointUri();
  }
};

/**
 * @private
 * Sends context-less request.
 *
 * @param {string} action The action to perform on the player.
 * @param {function=} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype._sendRequestWithAction = function(action, opt_callback) {
  return this._sendRequestWithParams(action, null, opt_callback);
};

/**
 * @private
 * Sends the request that only expects the single value in the body.
 *
 * @param {string} action The action to perform on the player.
 * @param {*} paramValue The value to send to the player.
 * @param {function=} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype._sendRequestWithParam = function(action, paramValue, opt_callback) {
  var params = {
    value: paramValue
  };
  return this._sendRequestWithParams(action, params, opt_callback);
};

/**
 * @private
 * Sends request with context and optional options.
 *
 * @param {string} action The action to perform on the player.
 * @param {Object?} params The context to play.
 * @param {function=} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype._sendRequestWithParams = function(action, params, opt_callback) {
  var requestUri = this.getPlayerEndpointUri() + '/' + action;
  var body = params || {};
  body.logging_params = {
    command_initiated_time: this._getTime()
  };
  var request = new cosmos.Request(
    cosmos.Action.POST, requestUri, null, body);
  return this._resolver.resolve(request, opt_callback);
};

exports.Player = Player;

},{"./play":401,"spotify-cosmos-api":388,"when/node":438}],403:[function(require,module,exports){
/**
 * A PlayerTrack represents a single track in a context.
 *
 * @typedef {Object}
 * @property {String} uri
 *    The URI of the track. This will be one of the Spotify URIs, such as
 *    spotify:track:GID or spotify:local:DATA.
 * @property {String} album_uri
 *    The URI of the album that the track appears on. This property must always
 *    be set if the track URI is set. This is a requirement so that functions
 *    like MFT rules and biased shuffle can operate without having to fetch
 *    additional metadata for each track.
 * @property {String} artist_uri
 *    The URI of the main artist of the track. This property must always be set
 *    if the track URI is set. This is a requirement so that functions like MFT
 *    rules and biased shuffle can operate without having to fetch additional
 *    metadata for each track.
 * @property {Object} metadata
 *    A map with custom metadata for the track. This map can hold anything that
 *    the feature decides to put in it. Features should be prepared that the
 *    metadata can disappear and be able to work around that situation.
 *    The metadata is passed around and persisted, so it will usually stick
 *    around, but there are certain situations where the data is lost because of
 *    transferring the track over legacy protocols, to Connect enabled speakers
 *    and back.
 */
exports.Track;

/**
 * PlayerRestrictions is used to encapsulate limitations of a player or a
 * context. The caller can specify that restrictions should apply when playing a
 * given context (see PlayerContext.restrictions), and a player can notify that
 * restrictions (see PlayState.restrictions).
 *
 * @typedef {Object}
 * @property {Array.<String>} disallow_skipping_prev_reasons
 *    The reasons why skipping to the previous track should be / is disallowed.
 * @property {Array.<String>} disallow_skipping_next_reasons
 *    The reasons why skipping to the next track should be / is disallowed.
 * @property {Array.<String>} disallow_peeking_prev_reasons
 *    The reasons why peeking at the previous track should be / is disallowed.
 * @property {Array.<String>} disallow_peeking_next_reasons
 *    The reasons why peeking at the next track should be / is disallowed.
 * @property {Array.<String>} disallow_skipping_to_reasons
 *    The reasons why skipping to a specific track should be / is disallowed.
 * @property {Array.<String>} disallow_pausing_reasons
 *    The reasons why pausing playback should be / is disallowed.
 * @property {Array.<String>} disallow_resuming_reasons
 *    The reasons why resuming playback should be / is disallowed.
 * @property {Array.<String>} disallow_toggling_repeat_context_reasons
 *    The reasons why toggling repeat context should be / is disallowed.
 * @property {Array.<String>} disallow_toggling_repeat_track_reasons
 *    The reasons why toggling repeat track should be / is disallowed.
 * @property {Array.<String>} disallow_toggling_shuffle_reasons
 *    The reasons why toggling shuffle should be / is disallowed.
 * @property {Array.<String>} disallow_seeking_reasons
 *    The reasons why seeking within a track should be / is disallowed.
 * @property {Array.<String>} disallow_muting_reasons
 *    The reasons why muting audio should be / is disallowed.
 */
exports.Restrictions;

/**
 * PlayerSuppressions are used to disable certain player rules while playing a
 * context. The caller can specify that suppressions should apply when playing a
 * context (see PlayerOptions.suppressions), and a player can notify those
 * suppressions (see PlayState.suppressions).
 *
 * @typedef {Object}
 * @property {Array.<String>} providers
 *    The provider identifiers of the rules that should be disabled.
 */
exports.Suppressions;

/**
 * An object representing the index of the track to play within a context.
 * In the simplest case there is only one page thus its index should be 0.
 *
 * @typedef {Object}
 * @property {Number} page The index of the page to find the track in.
 * @property {Number} track The index of the track in the page.
 */
exports.IndexPath;

/**
 * This structure holds options that should be applied to the player: they are
 * either specified at a global or per-context level. When they are specified
 * globally, finishing the current context or starting to play a new context
 * does not change the player options: specifying them at a context-level means
 * that the previous global setting will be restored when the player is asked to
 * play another context.
 *
 * @typedef {Object}
 * @property {Boolean} shuffling_context
 *    Specifies if the player should shuffle the context or not.
 * @property {Boolean} repeating_context
 *    Specifies if the player should repeat the context or not.
 * @property {Boolean} repeating_track
 *    Specifies if the player should repeat the current track or not.
 */
exports.PlayerOptions;

/**
 * Options for a specific playback request. This object can specify for instance
 * which track to play within the given context, where to seek within the track
 * etc.
 *
 * @typedef {Object}
 * @property {module:spotify-player/types.IndexPath} skip_to_index
 *    The index in the context to start playing from. It is possible to specify
 *    a page that is not yet loaded, in which case the page will be downloaded
 *    before playback starts. The context player state will indicate that the
 *    playback is delayed because of loading the page.
 * @property {Number} seek_to
 *    The number of milliseconds to seek into the track when starting to
 *    play it.
 * @property {Boolean} initially_paused
 *    When this property is set, the context player will load the context but
 *    will not start playing audio for the first track. The is_paused property
 *    is set in the context player state to indicate that playback is paused. To
 *    start playing the track, call the `resume` method on the context player.
 * @property {module:spotify-player/types.PlayerOptions} player_options_override
 *    Use this to temporarily override the player options for this play request
 *    only. This can for instance be used to implement shuffle play buttons that
 *    enable shuffling but only for this particular context.
 */
exports.PlayOptions;

/**
 * Allows the list of tracks that will be played to be split up into chunks.
 * Pages may loaded or unloaded: an unloaded page will be loaded by the player
 * when it needs more tracks to play.
 *
 * @typedef {Object}
 * @property {String} page_url
 *     The URL of this page. If this property is set to a valid URL, it will be
 *     used to fetch the tracks of the page. The URL must be something that is
 *     supported by the context page loader in use, e.g., Hermes endpoints or
 *     Spotify playlist URIs. In the latter case, the context page loader will
 *     trigger the loaded signal each time the underlying playlist changes. If
 *     the tracks for the (static) context page are already provided in the
 *     tracks property, the page is considered loaded and the URL can be left
 *     empty.
 * @property {String} next_page_url
 *     The URL of the next context page. When the context page is stored in a
 *     context, the next page URL will be used to automatically append new pages
 *     at the end of the pages (or the fallback page) array. The new page
 *     will have its page URL set according to the next page URL of the last
 *     page in the context. The context page loaded will be used at some point
 *     to fetch the tracks for the new page. When the new page is fetched from
 *     the backend, it can also have the next page URL set, and yet another page
 *     is added to the context.
 * @property {Array<module:spotify-player/types.Track>} tracks
 *     An optional array with the tracks of this context page. When the context
 *     page is not loaded, the property is not initialized, and a context page
 *     loader will be used to fetch a loaded version of the page. In a loaded
 *     page this property will be set to an array of tracks. Note that the array
 *     can be empty, which means that the page does not have any tracks. This is
 *     not the same as a page that is not loaded, which may or may not have
 *     tracks.
 */
exports.ContextPage;

/**
 * Describes a set of tracks to be played.
 *
 * @typedef {Object}
 * @property {String} entity_uri
 *    An optional Spotify URI that represents what this entire context contains.
 *    For established entities like playlist, album, artist, this should be their
 *    respective URIs. This can be used for inter-feature playback status
 *    indication.
 *
 *    For instance, when the search page starts to play an artist, it should
 *    provide the artist URI in this field. The playback status indication for
 *    that artist in the search result list should be set if the current context
 *    entity URI matches the artist URI. On the artist page, the artist play
 *    button should also look at the entity URI for playback indication.
 * @property {Object} metadata
 *    A map with custom metadata for the track. This map can hold anything that
 *    the feature decides to put in it. Features should be prepared that the
 *    metadata can disappear and be able to work around that situation.
 *    The metadata is passed around and persisted, so it will usually stick
 *    around, but there are certain situations where the data is lost because of
 *    transferring the track over legacy protocols, to Connect enabled speakers
 *    and back.
 * @property {Array<module:spotify-player/types.ContextPage>} pages
 *    An array of context pages that contain the tracks that should be played
 *    for this context. The context pages may or may not be loaded when passing
 *    the context to the player for playback. Note that if the last context page
 *    has a next page URL, at some point a new context page will be added to the
 *    end of the array, for that page URL. This will happen when playback is
 *    nearing the end of the available context pages.
 * @property {Array<module:spotify-player/types.ContextPage>} fallback_pages
 *    A vector of context pages that contain the tracks that should be used as a
 *    fallback if some rule does not allow the tracks in the future to be
 *    played.  An example of this is the MFT rules, which has a number of
 *    restrictions of how many times a track and album can be played during a
 *    given time period.  Another example is the DMCA rules that is used for the
 *    radio feature. When a fallback track is picked from the fallback pages, it
 *    must be removed from the page, so that it is not used again later. The
 *    fallback track can be provided by the feature that starts playback or
 *    they will be populated by the player if they are needed and none are
 *    provided.
 * @property {module:spotify-player/types.Restricitions} restrictions
 *    The restrictons that should be applied to the player when playing tracks
 *    from the context, e.g., whether the user is allowed to skip backward and
 *    forward in the context or enable shuffling and repeating. Note that the
 *    actual restrictions of the player at any given moment is decided not only
 *    by the context restrictions but also by the rules that are applied, e.g.,
 *    the MFT rules will always disable skipping backward, and will disable
 *    skipping forward as well when the user has reached the maximum number of
 *    skips allowed per time period.
 */
exports.Context;

},{}],404:[function(require,module,exports){
/**
 * @module spotify-range2
 */'use strict';

var prime = require('prime');

var map = require('mout/array/map');

var push_ = Array.prototype.push;
var slice_ = Array.prototype.slice;

var Range = prime(/** @lends Range.prototype */{

  /**
   * The representation of a range
   * @constructs
   * @param {Number} start The start of the range.
   * @param {Number} end The end of the range.
   */
  constructor: function Range(start, end) {
    this.update(start, end);
  },

  /** Update a range. */
  update: function(start, end) {
    if (start != null) this.start = start;
    if (end != null) this.end = end;
    if (this.start == null || this.end == null) throw new Error('invalid range');
    if (this.start > this.end) throw new Error('invalid range');
    this.length = this.end - this.start;
    return this;
  },

  /** Copy a range. */
  copy: function() {
    return new Range(this.start, this.end);
  },

  /** Range is above range. */
  above: function(range) {
    if (!range) return false;
    return this.start >= range.end;
  },

  /** Range is below range. */
  below: function(range) {
    if (!range) return false;
    return this.end <= range.start;
  },

  adjacent: function(range) {
    if (!range) return false;
    return this.end === range.start || this.start === range.end;
  },

  /** Range intersects range. */
  intersects: function(range) {
    if (!range) return false;
    return !this.above(range) && !this.below(range);
  },

  /** Range contains range. */
  contains: function(range) {
    if (!range) return false;
    return (this.start <= range.start && this.end >= range.end);
  },

  /** Range is contained by ranges. */
  contained: function(range) {
    var ranges;
    if (range instanceof Range) ranges = arguments;
    else ranges = range;
    if (!ranges) return false;

    for (var i = 0; (range = ranges[i]); i++) {
      if (range.start <= this.start && range.end >= this.end)
        return true;
    }
    return false;
  },

  /** Range fits two ranges. */
  fits: function(prev, next) {
    if (!prev && !next) return true;
    if (!prev) return this.end <= next.start;
    if (!next) return this.start >= prev.end;
    return this.start >= prev.end && this.end <= next.start;
  },

  // get the section of this range contained between two ranges
  // [0, 20] » [0, 8], [16, 20] » [8, 16]

  /** portion of a range between two ranges. */
  between: function(prev, next) {
    if (!prev && !next) return this.copy();
    if (!prev) return this.start >= next.start ? null : new Range(this.start, Math.min(this.end, next.start));
    if (!next) return this.end <= prev.end ? null : new Range(Math.max(prev.end, this.start), this.end);

    return this.end > prev.end && this.start < next.start ?
        new Range(Math.max(prev.end, this.start), Math.min(next.start, this.end)) :
        null;
  },

  // [0, 8] » [0, 2], [4, 5] = [0, 2], [4, 5]
  // [3, 6] » [5, 7] = [5, 6]
  // [6, 9] » [5, 7] = [6, 7]

  /** intersection of a range with many ranges */
  intersection: function(range) {
    var intersected = [], ranges;
    if (range instanceof Range) ranges = arguments;
    else ranges = range;
    for (var k = 0; k < ranges.length; k++) {
      var r = ranges[k];
      if (this.below(r)) break;

      if (r.intersects(this)) intersected.push(new Range(Math.max(this.start, r.start), Math.min(this.end, r.end)));
    }
    return intersected;
  },

  // subtract ranges from this range
  // [0, 8] » [0, 2], [4, 5] = [2, 4], [5, 8]

  /** subtract many ranges from the range. */
  subtract: function(range) {
    var subtracted = [], ranges;
    if (range instanceof Range) ranges = arguments;
    else ranges = range;
    for (var k = -1; k < ranges.length; k++) {
      var prev = ranges[k];
      var next = ranges[k + 1];
      var between = this.between(prev, next);
      if (between) subtracted.push(between);
    }
    return subtracted;
  },

  // extract this range from ranges
  // [0, 8] » [0, 2], [5, 8] = []
  // [8, 20] » [0, 2], [5, 8] = [0, 2], [5, 8]
  // [0, 10] » [5, 10], [15, 20] = [5, 10]
  // [10, 20] » [5, 80], [90, 100] = [5, 70] [80, 90]
  // [10, 20] » [0, 10], [20, 30] = [0, 20]

  /** extract the range from many ranges. */
  extract: function(range) {
    var ranges = (range instanceof Range) ? slice_.call(arguments) : range.slice();

    for (var k = 0; k < ranges.length; k++) {
      var prev = ranges[k - 1];
      var next = ranges[k];

      var newRange = null;

      if (this.below(next)) {
        newRange = new Range(next.start - this.length, next.end - this.length);
      } else if (this.intersects(next)) {
        var subtracted = next.subtract(this);
        if (subtracted.length === 2) { // is contained
          newRange = new Range(subtracted[0].start, subtracted[1].end - this.length);
        } else if (subtracted.length === 1) {
          if (next.end > this.end) { // second segment kept
            newRange = new Range(subtracted[0].start - this.length, subtracted[0].end - this.length);
          } else if (this.start > next.start) { // first segment kept
            newRange = new Range(subtracted[0].start, subtracted[0].end);
          }
        } else { // gets eaten
          ranges.splice(k--, 1); // decrease k
        }
      } else {
        ranges.splice(k, 1, next.copy());
      }

      if (newRange) {
        if (prev && prev.end === newRange.start) { // touches previous
          ranges.splice(k-- - 1, 2, new Range(prev.start, newRange.end)); // decrease k due to splicing
        } else {
          ranges.splice(k, 1, newRange);
        }
      }

    }

    return ranges;
  },

  // [2,3] » [0,1], [2,3] = [0,1], [2,4]
  // [1,2] » [0,6] = [0,7]
  // [0,1] » [0,1], [5,6] = [0,2], [6,7]
  // [4,6] » [0,1], [5,6] = [0,1], [4,6], [7,8]

  // TODO: this can be slightly better. merging can be done in one loop.

  /** insert the range in many ranges. */
  insert: function(range) {
    var ranges = (range instanceof Range) ? slice_.call(arguments) : range.slice();

    for (var k = 0; k < ranges.length; k++) {
      var next = ranges[k];

      if (this.start >= next.end) {

        ranges.splice(k, 1, next.copy());

      } else if (this.start > next.start && this.start < next.end) {

        ranges.splice(k, 1, new Range(next.start, this.start), new Range(this.start, next.end));

      } else {

        ranges.splice(k, 1, new Range(next.start + this.length, next.end + this.length));

      }

    }

    return this.merge(ranges);

  },

  // merge this range in ranges
  // [0, 8] » [0, 2], [5, 8] = [0, 8]
  // [8, 20] » [0, 2], [5, 8] = [0, 2], [5, 20]
  // [0, 10] » [5, 10], [15, 20] = [0, 10], [15, 20]

  /** merge many ranges to the range. */
  merge: function(range) {
    var ranges;
    if (range instanceof Range) ranges = arguments;
    else ranges = range;

    ranges = map(ranges, function(r) {
      return r.copy();
    });

    if (!ranges.length) return [this.copy()];

    for (var k = -1, l = ranges.length; k < l; k++) {

      var prev = ranges[k];
      var next = ranges[k + 1];
      var between = this.between(prev, next);

      if (between) {

        if (!prev && next) {

          if (between.end === next.start) {
            next.update(between.start, next.end);
          } else {
            k++; // increase k since we had a push
            ranges.unshift(between);
          }

        } else if (prev && next) {

          if (prev.end === between.start && between.end === next.start) {
            prev.update(prev.start, next.end);
            ranges.splice(k-- + 1, 1); // remove the next, decrease k since we had a splice
          } else if (prev.end === between.start) {
            prev.update(prev.start, between.end);
          } else if (between.end === next.start) {
            next.update(between.start, next.end);
          } else {
            ranges.splice(k + 1, 0, between);
          }

        } else if (prev && !next) {

          if (prev.end === between.start) {
            prev.update(prev.start, between.end);
          } else {
            k++; // increase k since we had a push
            ranges.push(between);
          }
        }

      }

    }

    return ranges;
  },

  /** Remove range from many ranges
      - The range(s) you pass is what you remove from */
  remove: function(range) {
    var ranges;
    if (range instanceof Range) ranges = arguments;
    else ranges = range;
    var result = [];
    for (var i = 0; i < ranges.length; i++) {
      var remaining = ranges[i].subtract(this);
      if (remaining.length) push_.apply(result, remaining);
    }
    return result;
  },

  /** Range to an array of indices */
  toIndices: function() {
    var indices = [];
    for (var i = this.start; i < this.end; i++) indices.push(i);
    return indices;
  },

  /** Range to a string */
  toString: function() {
    return [this.start, this.end] + '';
  }

});

/**
 * Range from a string
 * @memberof Range
 * @static
 * @param {String} string - The string.
 * @return {Range} The range.
 */
Range.fromString = function(string) {
  var parts = string.split(',');
  return new Range(+parts[0], +parts[1]);
};

/**
 * Ranges from an array of indices
 * @memberof Range
 * @static
 * @param {Array} indices - An array of indices.
 * @return {Array} An array of Ranges.
 */
Range.fromIndices = function(indices) {
  indices.sort(function(a, b) {
    return a > b ? 1 : -1;
  });

  var ranges = [], rstart, rend;

  for (var i = 0; i < indices.length; i++) {
    rstart = indices[i];
    rend = rstart;
    while (indices[i + 1] - indices[i] === 1) {
      rend = indices[i + 1]; // increment the index if the numbers sequential
      i++;
    }
    ranges.push(new Range(rstart, rend + 1));
  }

  return ranges;
};

/**
 * A function that returns a range.
 * @function
 * @see Range
 * @param {Number} start The start of the range.
 * @param {Number} end The end of the range.
 */
module.exports = Range;

},{"mout/array/map":405,"prime":418}],405:[function(require,module,exports){
arguments[4][292][0].apply(exports,arguments)
},{"../function/makeIterator_":407,"dup":292}],406:[function(require,module,exports){
arguments[4][298][0].apply(exports,arguments)
},{"dup":298}],407:[function(require,module,exports){
arguments[4][299][0].apply(exports,arguments)
},{"../object/deepMatches":413,"./identity":406,"./prop":408,"dup":299}],408:[function(require,module,exports){
arguments[4][300][0].apply(exports,arguments)
},{"dup":300}],409:[function(require,module,exports){
arguments[4][301][0].apply(exports,arguments)
},{"../object/mixIn":417,"dup":301}],410:[function(require,module,exports){
arguments[4][302][0].apply(exports,arguments)
},{"./isKind":411,"dup":302}],411:[function(require,module,exports){
arguments[4][303][0].apply(exports,arguments)
},{"./kindOf":412,"dup":303}],412:[function(require,module,exports){
arguments[4][305][0].apply(exports,arguments)
},{"dup":305}],413:[function(require,module,exports){
arguments[4][306][0].apply(exports,arguments)
},{"../lang/isArray":410,"./forOwn":415,"dup":306}],414:[function(require,module,exports){
arguments[4][307][0].apply(exports,arguments)
},{"./hasOwn":416,"dup":307}],415:[function(require,module,exports){
arguments[4][308][0].apply(exports,arguments)
},{"./forIn":414,"./hasOwn":416,"dup":308}],416:[function(require,module,exports){
arguments[4][309][0].apply(exports,arguments)
},{"dup":309}],417:[function(require,module,exports){
arguments[4][310][0].apply(exports,arguments)
},{"./forOwn":415,"dup":310}],418:[function(require,module,exports){
arguments[4][312][0].apply(exports,arguments)
},{"dup":312,"mout/lang/createObject":409,"mout/lang/kindOf":412,"mout/object/hasOwn":416,"mout/object/mixIn":417}],419:[function(require,module,exports){
//     Underscore.js 1.8.3
//     http://underscorejs.org
//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `exports` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var
    push             = ArrayProto.push,
    slice            = ArrayProto.slice,
    toString         = ObjProto.toString,
    hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind,
    nativeCreate       = Object.create;

  // Naked function reference for surrogate-prototype-swapping.
  var Ctor = function(){};

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.8.3';

  // Internal function that returns an efficient (for current engines) version
  // of the passed-in callback, to be repeatedly applied in other Underscore
  // functions.
  var optimizeCb = function(func, context, argCount) {
    if (context === void 0) return func;
    switch (argCount == null ? 3 : argCount) {
      case 1: return function(value) {
        return func.call(context, value);
      };
      case 2: return function(value, other) {
        return func.call(context, value, other);
      };
      case 3: return function(value, index, collection) {
        return func.call(context, value, index, collection);
      };
      case 4: return function(accumulator, value, index, collection) {
        return func.call(context, accumulator, value, index, collection);
      };
    }
    return function() {
      return func.apply(context, arguments);
    };
  };

  // A mostly-internal function to generate callbacks that can be applied
  // to each element in a collection, returning the desired result — either
  // identity, an arbitrary callback, a property matcher, or a property accessor.
  var cb = function(value, context, argCount) {
    if (value == null) return _.identity;
    if (_.isFunction(value)) return optimizeCb(value, context, argCount);
    if (_.isObject(value)) return _.matcher(value);
    return _.property(value);
  };
  _.iteratee = function(value, context) {
    return cb(value, context, Infinity);
  };

  // An internal function for creating assigner functions.
  var createAssigner = function(keysFunc, undefinedOnly) {
    return function(obj) {
      var length = arguments.length;
      if (length < 2 || obj == null) return obj;
      for (var index = 1; index < length; index++) {
        var source = arguments[index],
            keys = keysFunc(source),
            l = keys.length;
        for (var i = 0; i < l; i++) {
          var key = keys[i];
          if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];
        }
      }
      return obj;
    };
  };

  // An internal function for creating a new object that inherits from another.
  var baseCreate = function(prototype) {
    if (!_.isObject(prototype)) return {};
    if (nativeCreate) return nativeCreate(prototype);
    Ctor.prototype = prototype;
    var result = new Ctor;
    Ctor.prototype = null;
    return result;
  };

  var property = function(key) {
    return function(obj) {
      return obj == null ? void 0 : obj[key];
    };
  };

  // Helper for collection methods to determine whether a collection
  // should be iterated as an array or as an object
  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
  var getLength = property('length');
  var isArrayLike = function(collection) {
    var length = getLength(collection);
    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
  };

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles raw objects in addition to array-likes. Treats all
  // sparse array-likes as if they were dense.
  _.each = _.forEach = function(obj, iteratee, context) {
    iteratee = optimizeCb(iteratee, context);
    var i, length;
    if (isArrayLike(obj)) {
      for (i = 0, length = obj.length; i < length; i++) {
        iteratee(obj[i], i, obj);
      }
    } else {
      var keys = _.keys(obj);
      for (i = 0, length = keys.length; i < length; i++) {
        iteratee(obj[keys[i]], keys[i], obj);
      }
    }
    return obj;
  };

  // Return the results of applying the iteratee to each element.
  _.map = _.collect = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length,
        results = Array(length);
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      results[index] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
  };

  // Create a reducing function iterating left or right.
  function createReduce(dir) {
    // Optimized iterator function as using arguments.length
    // in the main function will deoptimize the, see #1991.
    function iterator(obj, iteratee, memo, keys, index, length) {
      for (; index >= 0 && index < length; index += dir) {
        var currentKey = keys ? keys[index] : index;
        memo = iteratee(memo, obj[currentKey], currentKey, obj);
      }
      return memo;
    }

    return function(obj, iteratee, memo, context) {
      iteratee = optimizeCb(iteratee, context, 4);
      var keys = !isArrayLike(obj) && _.keys(obj),
          length = (keys || obj).length,
          index = dir > 0 ? 0 : length - 1;
      // Determine the initial value if none is provided.
      if (arguments.length < 3) {
        memo = obj[keys ? keys[index] : index];
        index += dir;
      }
      return iterator(obj, iteratee, memo, keys, index, length);
    };
  }

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`.
  _.reduce = _.foldl = _.inject = createReduce(1);

  // The right-associative version of reduce, also known as `foldr`.
  _.reduceRight = _.foldr = createReduce(-1);

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, predicate, context) {
    var key;
    if (isArrayLike(obj)) {
      key = _.findIndex(obj, predicate, context);
    } else {
      key = _.findKey(obj, predicate, context);
    }
    if (key !== void 0 && key !== -1) return obj[key];
  };

  // Return all the elements that pass a truth test.
  // Aliased as `select`.
  _.filter = _.select = function(obj, predicate, context) {
    var results = [];
    predicate = cb(predicate, context);
    _.each(obj, function(value, index, list) {
      if (predicate(value, index, list)) results.push(value);
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, predicate, context) {
    return _.filter(obj, _.negate(cb(predicate)), context);
  };

  // Determine whether all of the elements match a truth test.
  // Aliased as `all`.
  _.every = _.all = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (!predicate(obj[currentKey], currentKey, obj)) return false;
    }
    return true;
  };

  // Determine if at least one element in the object matches a truth test.
  // Aliased as `any`.
  _.some = _.any = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (predicate(obj[currentKey], currentKey, obj)) return true;
    }
    return false;
  };

  // Determine if the array or object contains a given item (using `===`).
  // Aliased as `includes` and `include`.
  _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {
    if (!isArrayLike(obj)) obj = _.values(obj);
    if (typeof fromIndex != 'number' || guard) fromIndex = 0;
    return _.indexOf(obj, item, fromIndex) >= 0;
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function(value) {
      var func = isFunc ? method : value[method];
      return func == null ? func : func.apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, _.property(key));
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs) {
    return _.filter(obj, _.matcher(attrs));
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.find(obj, _.matcher(attrs));
  };

  // Return the maximum element (or element-based computation).
  _.max = function(obj, iteratee, context) {
    var result = -Infinity, lastComputed = -Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value > result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iteratee, context) {
    var result = Infinity, lastComputed = Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value < result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed < lastComputed || computed === Infinity && result === Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Shuffle a collection, using the modern version of the
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
  _.shuffle = function(obj) {
    var set = isArrayLike(obj) ? obj : _.values(obj);
    var length = set.length;
    var shuffled = Array(length);
    for (var index = 0, rand; index < length; index++) {
      rand = _.random(0, index);
      if (rand !== index) shuffled[index] = shuffled[rand];
      shuffled[rand] = set[index];
    }
    return shuffled;
  };

  // Sample **n** random values from a collection.
  // If **n** is not specified, returns a single random element.
  // The internal `guard` argument allows it to work with `map`.
  _.sample = function(obj, n, guard) {
    if (n == null || guard) {
      if (!isArrayLike(obj)) obj = _.values(obj);
      return obj[_.random(obj.length - 1)];
    }
    return _.shuffle(obj).slice(0, Math.max(0, n));
  };

  // Sort the object's values by a criterion produced by an iteratee.
  _.sortBy = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value: value,
        index: index,
        criteria: iteratee(value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index - right.index;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(behavior) {
    return function(obj, iteratee, context) {
      var result = {};
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index) {
        var key = iteratee(value, index, obj);
        behavior(result, value, key);
      });
      return result;
    };
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key].push(value); else result[key] = [value];
  });

  // Indexes the object's values by a criterion, similar to `groupBy`, but for
  // when you know that your index values will be unique.
  _.indexBy = group(function(result, value, key) {
    result[key] = value;
  });

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key]++; else result[key] = 1;
  });

  // Safely create a real, live array from anything iterable.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (isArrayLike(obj)) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return isArrayLike(obj) ? obj.length : _.keys(obj).length;
  };

  // Split a collection into two arrays: one whose elements all satisfy the given
  // predicate, and one whose elements all do not satisfy the predicate.
  _.partition = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var pass = [], fail = [];
    _.each(obj, function(value, key, obj) {
      (predicate(value, key, obj) ? pass : fail).push(value);
    });
    return [pass, fail];
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[0];
    return _.initial(array, array.length - n);
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array.
  _.last = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[array.length - 1];
    return _.rest(array, Math.max(0, array.length - n));
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, n == null || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, _.identity);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, strict, startIndex) {
    var output = [], idx = 0;
    for (var i = startIndex || 0, length = getLength(input); i < length; i++) {
      var value = input[i];
      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
        //flatten current level of array or arguments object
        if (!shallow) value = flatten(value, shallow, strict);
        var j = 0, len = value.length;
        output.length += len;
        while (j < len) {
          output[idx++] = value[j++];
        }
      } else if (!strict) {
        output[idx++] = value;
      }
    }
    return output;
  };

  // Flatten out an array, either recursively (by default), or just one level.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, false);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iteratee, context) {
    if (!_.isBoolean(isSorted)) {
      context = iteratee;
      iteratee = isSorted;
      isSorted = false;
    }
    if (iteratee != null) iteratee = cb(iteratee, context);
    var result = [];
    var seen = [];
    for (var i = 0, length = getLength(array); i < length; i++) {
      var value = array[i],
          computed = iteratee ? iteratee(value, i, array) : value;
      if (isSorted) {
        if (!i || seen !== computed) result.push(value);
        seen = computed;
      } else if (iteratee) {
        if (!_.contains(seen, computed)) {
          seen.push(computed);
          result.push(value);
        }
      } else if (!_.contains(result, value)) {
        result.push(value);
      }
    }
    return result;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(flatten(arguments, true, true));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    var result = [];
    var argsLength = arguments.length;
    for (var i = 0, length = getLength(array); i < length; i++) {
      var item = array[i];
      if (_.contains(result, item)) continue;
      for (var j = 1; j < argsLength; j++) {
        if (!_.contains(arguments[j], item)) break;
      }
      if (j === argsLength) result.push(item);
    }
    return result;
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = flatten(arguments, true, true, 1);
    return _.filter(array, function(value){
      return !_.contains(rest, value);
    });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    return _.unzip(arguments);
  };

  // Complement of _.zip. Unzip accepts an array of arrays and groups
  // each array's elements on shared indices
  _.unzip = function(array) {
    var length = array && _.max(array, getLength).length || 0;
    var result = Array(length);

    for (var index = 0; index < length; index++) {
      result[index] = _.pluck(array, index);
    }
    return result;
  };

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values.
  _.object = function(list, values) {
    var result = {};
    for (var i = 0, length = getLength(list); i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // Generator function to create the findIndex and findLastIndex functions
  function createPredicateIndexFinder(dir) {
    return function(array, predicate, context) {
      predicate = cb(predicate, context);
      var length = getLength(array);
      var index = dir > 0 ? 0 : length - 1;
      for (; index >= 0 && index < length; index += dir) {
        if (predicate(array[index], index, array)) return index;
      }
      return -1;
    };
  }

  // Returns the first index on an array-like that passes a predicate test
  _.findIndex = createPredicateIndexFinder(1);
  _.findLastIndex = createPredicateIndexFinder(-1);

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iteratee, context) {
    iteratee = cb(iteratee, context, 1);
    var value = iteratee(obj);
    var low = 0, high = getLength(array);
    while (low < high) {
      var mid = Math.floor((low + high) / 2);
      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
    }
    return low;
  };

  // Generator function to create the indexOf and lastIndexOf functions
  function createIndexFinder(dir, predicateFind, sortedIndex) {
    return function(array, item, idx) {
      var i = 0, length = getLength(array);
      if (typeof idx == 'number') {
        if (dir > 0) {
            i = idx >= 0 ? idx : Math.max(idx + length, i);
        } else {
            length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
        }
      } else if (sortedIndex && idx && length) {
        idx = sortedIndex(array, item);
        return array[idx] === item ? idx : -1;
      }
      if (item !== item) {
        idx = predicateFind(slice.call(array, i, length), _.isNaN);
        return idx >= 0 ? idx + i : -1;
      }
      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
        if (array[idx] === item) return idx;
      }
      return -1;
    };
  }

  // Return the position of the first occurrence of an item in an array,
  // or -1 if the item is not included in the array.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (stop == null) {
      stop = start || 0;
      start = 0;
    }
    step = step || 1;

    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var range = Array(length);

    for (var idx = 0; idx < length; idx++, start += step) {
      range[idx] = start;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Determines whether to execute a function as a constructor
  // or a normal function with the provided arguments
  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
    var self = baseCreate(sourceFunc.prototype);
    var result = sourceFunc.apply(self, args);
    if (_.isObject(result)) return result;
    return self;
  };

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = function(func, context) {
    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
    var args = slice.call(arguments, 2);
    var bound = function() {
      return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));
    };
    return bound;
  };

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context. _ acts
  // as a placeholder, allowing any combination of arguments to be pre-filled.
  _.partial = function(func) {
    var boundArgs = slice.call(arguments, 1);
    var bound = function() {
      var position = 0, length = boundArgs.length;
      var args = Array(length);
      for (var i = 0; i < length; i++) {
        args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];
      }
      while (position < arguments.length) args.push(arguments[position++]);
      return executeBound(func, bound, this, this, args);
    };
    return bound;
  };

  // Bind a number of an object's methods to that object. Remaining arguments
  // are the method names to be bound. Useful for ensuring that all callbacks
  // defined on an object belong to it.
  _.bindAll = function(obj) {
    var i, length = arguments.length, key;
    if (length <= 1) throw new Error('bindAll must be passed function names');
    for (i = 1; i < length; i++) {
      key = arguments[i];
      obj[key] = _.bind(obj[key], obj);
    }
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memoize = function(key) {
      var cache = memoize.cache;
      var address = '' + (hasher ? hasher.apply(this, arguments) : key);
      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);
      return cache[address];
    };
    memoize.cache = {};
    return memoize;
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){
      return func.apply(null, args);
    }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = _.partial(_.delay, _, 1);

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  _.throttle = function(func, wait, options) {
    var context, args, result;
    var timeout = null;
    var previous = 0;
    if (!options) options = {};
    var later = function() {
      previous = options.leading === false ? 0 : _.now();
      timeout = null;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    };
    return function() {
      var now = _.now();
      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0 || remaining > wait) {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }
        previous = now;
        result = func.apply(context, args);
        if (!timeout) context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, args, context, timestamp, result;

    var later = function() {
      var last = _.now() - timestamp;

      if (last < wait && last >= 0) {
        timeout = setTimeout(later, wait - last);
      } else {
        timeout = null;
        if (!immediate) {
          result = func.apply(context, args);
          if (!timeout) context = args = null;
        }
      }
    };

    return function() {
      context = this;
      args = arguments;
      timestamp = _.now();
      var callNow = immediate && !timeout;
      if (!timeout) timeout = setTimeout(later, wait);
      if (callNow) {
        result = func.apply(context, args);
        context = args = null;
      }

      return result;
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return _.partial(wrapper, func);
  };

  // Returns a negated version of the passed-in predicate.
  _.negate = function(predicate) {
    return function() {
      return !predicate.apply(this, arguments);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var args = arguments;
    var start = args.length - 1;
    return function() {
      var i = start;
      var result = args[start].apply(this, arguments);
      while (i--) result = args[i].call(this, result);
      return result;
    };
  };

  // Returns a function that will only be executed on and after the Nth call.
  _.after = function(times, func) {
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Returns a function that will only be executed up to (but not including) the Nth call.
  _.before = function(times, func) {
    var memo;
    return function() {
      if (--times > 0) {
        memo = func.apply(this, arguments);
      }
      if (times <= 1) func = null;
      return memo;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = _.partial(_.before, 2);

  // Object Functions
  // ----------------

  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
                      'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

  function collectNonEnumProps(obj, keys) {
    var nonEnumIdx = nonEnumerableProps.length;
    var constructor = obj.constructor;
    var proto = (_.isFunction(constructor) && constructor.prototype) || ObjProto;

    // Constructor is a special case.
    var prop = 'constructor';
    if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);

    while (nonEnumIdx--) {
      prop = nonEnumerableProps[nonEnumIdx];
      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
        keys.push(prop);
      }
    }
  }

  // Retrieve the names of an object's own properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = function(obj) {
    if (!_.isObject(obj)) return [];
    if (nativeKeys) return nativeKeys(obj);
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve all the property names of an object.
  _.allKeys = function(obj) {
    if (!_.isObject(obj)) return [];
    var keys = [];
    for (var key in obj) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };

  // Returns the results of applying the iteratee to each element of the object
  // In contrast to _.map it returns an object
  _.mapObject = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys =  _.keys(obj),
          length = keys.length,
          results = {},
          currentKey;
      for (var index = 0; index < length; index++) {
        currentKey = keys[index];
        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
      }
      return results;
  };

  // Convert an object into a list of `[key, value]` pairs.
  _.pairs = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [keys[i], obj[keys[i]]];
    }
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = createAssigner(_.allKeys);

  // Assigns a given object with all the own properties in the passed-in object(s)
  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
  _.extendOwn = _.assign = createAssigner(_.keys);

  // Returns the first key on an object that passes a predicate test
  _.findKey = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = _.keys(obj), key;
    for (var i = 0, length = keys.length; i < length; i++) {
      key = keys[i];
      if (predicate(obj[key], key, obj)) return key;
    }
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(object, oiteratee, context) {
    var result = {}, obj = object, iteratee, keys;
    if (obj == null) return result;
    if (_.isFunction(oiteratee)) {
      keys = _.allKeys(obj);
      iteratee = optimizeCb(oiteratee, context);
    } else {
      keys = flatten(arguments, false, false, 1);
      iteratee = function(value, key, obj) { return key in obj; };
      obj = Object(obj);
    }
    for (var i = 0, length = keys.length; i < length; i++) {
      var key = keys[i];
      var value = obj[key];
      if (iteratee(value, key, obj)) result[key] = value;
    }
    return result;
  };

   // Return a copy of the object without the blacklisted properties.
  _.omit = function(obj, iteratee, context) {
    if (_.isFunction(iteratee)) {
      iteratee = _.negate(iteratee);
    } else {
      var keys = _.map(flatten(arguments, false, false, 1), String);
      iteratee = function(value, key) {
        return !_.contains(keys, key);
      };
    }
    return _.pick(obj, iteratee, context);
  };

  // Fill in a given object with default properties.
  _.defaults = createAssigner(_.allKeys, true);

  // Creates an object that inherits from the given prototype object.
  // If additional properties are provided then they will be added to the
  // created object.
  _.create = function(prototype, props) {
    var result = baseCreate(prototype);
    if (props) _.extendOwn(result, props);
    return result;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Returns whether an object has a given set of `key:value` pairs.
  _.isMatch = function(object, attrs) {
    var keys = _.keys(attrs), length = keys.length;
    if (object == null) return !length;
    var obj = Object(object);
    for (var i = 0; i < length; i++) {
      var key = keys[i];
      if (attrs[key] !== obj[key] || !(key in obj)) return false;
    }
    return true;
  };


  // Internal recursive comparison function for `isEqual`.
  var eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a === 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className !== toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
      case '[object RegExp]':
      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return '' + a === '' + b;
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive.
        // Object(NaN) is equivalent to NaN
        if (+a !== +a) return +b !== +b;
        // An `egal` comparison is performed for other numeric values.
        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a === +b;
    }

    var areArrays = className === '[object Array]';
    if (!areArrays) {
      if (typeof a != 'object' || typeof b != 'object') return false;

      // Objects with different constructors are not equivalent, but `Object`s or `Array`s
      // from different frames are.
      var aCtor = a.constructor, bCtor = b.constructor;
      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
                               _.isFunction(bCtor) && bCtor instanceof bCtor)
                          && ('constructor' in a && 'constructor' in b)) {
        return false;
      }
    }
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

    // Initializing stack of traversed objects.
    // It's done here since we only need them for objects and arrays comparison.
    aStack = aStack || [];
    bStack = bStack || [];
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] === a) return bStack[length] === b;
    }

    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);

    // Recursively compare objects and arrays.
    if (areArrays) {
      // Compare array lengths to determine if a deep comparison is necessary.
      length = a.length;
      if (length !== b.length) return false;
      // Deep compare the contents, ignoring non-numeric properties.
      while (length--) {
        if (!eq(a[length], b[length], aStack, bStack)) return false;
      }
    } else {
      // Deep compare objects.
      var keys = _.keys(a), key;
      length = keys.length;
      // Ensure that both objects contain the same number of properties before comparing deep equality.
      if (_.keys(b).length !== length) return false;
      while (length--) {
        // Deep compare each member
        key = keys[length];
        if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return true;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
    return _.keys(obj).length === 0;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) === '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    var type = typeof obj;
    return type === 'function' || type === 'object' && !!obj;
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.
  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) === '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE < 9), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return _.has(obj, 'callee');
    };
  }

  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
  // IE 11 (#1621), and in Safari 8 (#1929).
  if (typeof /./ != 'function' && typeof Int8Array != 'object') {
    _.isFunction = function(obj) {
      return typeof obj == 'function' || false;
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
  _.isNaN = function(obj) {
    return _.isNumber(obj) && obj !== +obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, key) {
    return obj != null && hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iteratees.
  _.identity = function(value) {
    return value;
  };

  // Predicate-generating functions. Often useful outside of Underscore.
  _.constant = function(value) {
    return function() {
      return value;
    };
  };

  _.noop = function(){};

  _.property = property;

  // Generates a function for a given object that returns a given property.
  _.propertyOf = function(obj) {
    return obj == null ? function(){} : function(key) {
      return obj[key];
    };
  };

  // Returns a predicate for checking whether an object has a given set of
  // `key:value` pairs.
  _.matcher = _.matches = function(attrs) {
    attrs = _.extendOwn({}, attrs);
    return function(obj) {
      return _.isMatch(obj, attrs);
    };
  };

  // Run a function **n** times.
  _.times = function(n, iteratee, context) {
    var accum = Array(Math.max(0, n));
    iteratee = optimizeCb(iteratee, context, 1);
    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // A (possibly faster) way to get the current timestamp as an integer.
  _.now = Date.now || function() {
    return new Date().getTime();
  };

   // List of HTML entities for escaping.
  var escapeMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#x27;',
    '`': '&#x60;'
  };
  var unescapeMap = _.invert(escapeMap);

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  var createEscaper = function(map) {
    var escaper = function(match) {
      return map[match];
    };
    // Regexes for identifying a key that needs to be escaped
    var source = '(?:' + _.keys(map).join('|') + ')';
    var testRegexp = RegExp(source);
    var replaceRegexp = RegExp(source, 'g');
    return function(string) {
      string = string == null ? '' : '' + string;
      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
    };
  };
  _.escape = createEscaper(escapeMap);
  _.unescape = createEscaper(unescapeMap);

  // If the value of the named `property` is a function then invoke it with the
  // `object` as context; otherwise, return it.
  _.result = function(object, property, fallback) {
    var value = object == null ? void 0 : object[property];
    if (value === void 0) {
      value = fallback;
    }
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'":      "'",
    '\\':     '\\',
    '\r':     'r',
    '\n':     'n',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escaper = /\\|'|\r|\n|\u2028|\u2029/g;

  var escapeChar = function(match) {
    return '\\' + escapes[match];
  };

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  // NB: `oldSettings` only exists for backwards compatibility.
  _.template = function(text, settings, oldSettings) {
    if (!settings && oldSettings) settings = oldSettings;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset).replace(escaper, escapeChar);
      index = offset + match.length;

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      } else if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      } else if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }

      // Adobe VMs need the match returned to produce the correct offest.
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + 'return __p;\n';

    try {
      var render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled source as a convenience for precompilation.
    var argument = settings.variable || 'obj';
    template.source = 'function(' + argument + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function. Start chaining a wrapped Underscore object.
  _.chain = function(obj) {
    var instance = _(obj);
    instance._chain = true;
    return instance;
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var result = function(instance, obj) {
    return instance._chain ? _(obj).chain() : obj;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    _.each(_.functions(obj), function(name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result(this, func.apply(_, args));
      };
    });
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
      return result(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  _.each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return result(this, method.apply(this._wrapped, arguments));
    };
  });

  // Extracts the result from a wrapped and chained object.
  _.prototype.value = function() {
    return this._wrapped;
  };

  // Provide unwrapping proxy for some methods used in engine operations
  // such as arithmetic and JSON stringification.
  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;

  _.prototype.toString = function() {
    return '' + this._wrapped;
  };

  // AMD registration happens at the end for compatibility with AMD loaders
  // that may not enforce next-turn semantics on modules. Even though general
  // practice for AMD registration is to be anonymous, underscore registers
  // as a named module because, like jQuery, it is a base library that is
  // popular enough to be bundled in a third party lib, but not be part of
  // an AMD load request. Those cases could generate an error when an
  // anonymous define() is called outside of a loader request.
  if (typeof define === 'function' && define.amd) {
    define('underscore', [], function() {
      return _;
    });
  }
}.call(this));

},{}],420:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function (require) {

	var makePromise = require('./makePromise');
	var Scheduler = require('./Scheduler');
	var async = require('./env').asap;

	return makePromise({
		scheduler: new Scheduler(async)
	});

});
})(typeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); });

},{"./Scheduler":421,"./env":433,"./makePromise":436}],421:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	// Credit to Twisol (https://github.com/Twisol) for suggesting
	// this type of extensible queue + trampoline approach for next-tick conflation.

	/**
	 * Async task scheduler
	 * @param {function} async function to schedule a single async function
	 * @constructor
	 */
	function Scheduler(async) {
		this._async = async;
		this._running = false;

		this._queue = this;
		this._queueLen = 0;
		this._afterQueue = {};
		this._afterQueueLen = 0;

		var self = this;
		this.drain = function() {
			self._drain();
		};
	}

	/**
	 * Enqueue a task
	 * @param {{ run:function }} task
	 */
	Scheduler.prototype.enqueue = function(task) {
		this._queue[this._queueLen++] = task;
		this.run();
	};

	/**
	 * Enqueue a task to run after the main task queue
	 * @param {{ run:function }} task
	 */
	Scheduler.prototype.afterQueue = function(task) {
		this._afterQueue[this._afterQueueLen++] = task;
		this.run();
	};

	Scheduler.prototype.run = function() {
		if (!this._running) {
			this._running = true;
			this._async(this.drain);
		}
	};

	/**
	 * Drain the handler queue entirely, and then the after queue
	 */
	Scheduler.prototype._drain = function() {
		var i = 0;
		for (; i < this._queueLen; ++i) {
			this._queue[i].run();
			this._queue[i] = void 0;
		}

		this._queueLen = 0;
		this._running = false;

		for (i = 0; i < this._afterQueueLen; ++i) {
			this._afterQueue[i].run();
			this._afterQueue[i] = void 0;
		}

		this._afterQueueLen = 0;
	};

	return Scheduler;

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));

},{}],422:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	/**
	 * Custom error type for promises rejected by promise.timeout
	 * @param {string} message
	 * @constructor
	 */
	function TimeoutError (message) {
		Error.call(this);
		this.message = message;
		this.name = TimeoutError.name;
		if (typeof Error.captureStackTrace === 'function') {
			Error.captureStackTrace(this, TimeoutError);
		}
	}

	TimeoutError.prototype = Object.create(Error.prototype);
	TimeoutError.prototype.constructor = TimeoutError;

	return TimeoutError;
});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));
},{}],423:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	makeApply.tryCatchResolve = tryCatchResolve;

	return makeApply;

	function makeApply(Promise, call) {
		if(arguments.length < 2) {
			call = tryCatchResolve;
		}

		return apply;

		function apply(f, thisArg, args) {
			var p = Promise._defer();
			var l = args.length;
			var params = new Array(l);
			callAndResolve({ f:f, thisArg:thisArg, args:args, params:params, i:l-1, call:call }, p._handler);

			return p;
		}

		function callAndResolve(c, h) {
			if(c.i < 0) {
				return call(c.f, c.thisArg, c.params, h);
			}

			var handler = Promise._handler(c.args[c.i]);
			handler.fold(callAndResolveNext, c, void 0, h);
		}

		function callAndResolveNext(c, x, h) {
			c.params[c.i] = x;
			c.i -= 1;
			callAndResolve(c, h);
		}
	}

	function tryCatchResolve(f, thisArg, args, resolver) {
		try {
			resolver.resolve(f.apply(thisArg, args));
		} catch(e) {
			resolver.reject(e);
		}
	}

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));



},{}],424:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function(require) {

	var state = require('../state');
	var applier = require('../apply');

	return function array(Promise) {

		var applyFold = applier(Promise);
		var toPromise = Promise.resolve;
		var all = Promise.all;

		var ar = Array.prototype.reduce;
		var arr = Array.prototype.reduceRight;
		var slice = Array.prototype.slice;

		// Additional array combinators

		Promise.any = any;
		Promise.some = some;
		Promise.settle = settle;

		Promise.map = map;
		Promise.filter = filter;
		Promise.reduce = reduce;
		Promise.reduceRight = reduceRight;

		/**
		 * When this promise fulfills with an array, do
		 * onFulfilled.apply(void 0, array)
		 * @param {function} onFulfilled function to apply
		 * @returns {Promise} promise for the result of applying onFulfilled
		 */
		Promise.prototype.spread = function(onFulfilled) {
			return this.then(all).then(function(array) {
				return onFulfilled.apply(this, array);
			});
		};

		return Promise;

		/**
		 * One-winner competitive race.
		 * Return a promise that will fulfill when one of the promises
		 * in the input array fulfills, or will reject when all promises
		 * have rejected.
		 * @param {array} promises
		 * @returns {Promise} promise for the first fulfilled value
		 */
		function any(promises) {
			var p = Promise._defer();
			var resolver = p._handler;
			var l = promises.length>>>0;

			var pending = l;
			var errors = [];

			for (var h, x, i = 0; i < l; ++i) {
				x = promises[i];
				if(x === void 0 && !(i in promises)) {
					--pending;
					continue;
				}

				h = Promise._handler(x);
				if(h.state() > 0) {
					resolver.become(h);
					Promise._visitRemaining(promises, i, h);
					break;
				} else {
					h.visit(resolver, handleFulfill, handleReject);
				}
			}

			if(pending === 0) {
				resolver.reject(new RangeError('any(): array must not be empty'));
			}

			return p;

			function handleFulfill(x) {
				/*jshint validthis:true*/
				errors = null;
				this.resolve(x); // this === resolver
			}

			function handleReject(e) {
				/*jshint validthis:true*/
				if(this.resolved) { // this === resolver
					return;
				}

				errors.push(e);
				if(--pending === 0) {
					this.reject(errors);
				}
			}
		}

		/**
		 * N-winner competitive race
		 * Return a promise that will fulfill when n input promises have
		 * fulfilled, or will reject when it becomes impossible for n
		 * input promises to fulfill (ie when promises.length - n + 1
		 * have rejected)
		 * @param {array} promises
		 * @param {number} n
		 * @returns {Promise} promise for the earliest n fulfillment values
		 *
		 * @deprecated
		 */
		function some(promises, n) {
			/*jshint maxcomplexity:7*/
			var p = Promise._defer();
			var resolver = p._handler;

			var results = [];
			var errors = [];

			var l = promises.length>>>0;
			var nFulfill = 0;
			var nReject;
			var x, i; // reused in both for() loops

			// First pass: count actual array items
			for(i=0; i<l; ++i) {
				x = promises[i];
				if(x === void 0 && !(i in promises)) {
					continue;
				}
				++nFulfill;
			}

			// Compute actual goals
			n = Math.max(n, 0);
			nReject = (nFulfill - n + 1);
			nFulfill = Math.min(n, nFulfill);

			if(n > nFulfill) {
				resolver.reject(new RangeError('some(): array must contain at least '
				+ n + ' item(s), but had ' + nFulfill));
			} else if(nFulfill === 0) {
				resolver.resolve(results);
			}

			// Second pass: observe each array item, make progress toward goals
			for(i=0; i<l; ++i) {
				x = promises[i];
				if(x === void 0 && !(i in promises)) {
					continue;
				}

				Promise._handler(x).visit(resolver, fulfill, reject, resolver.notify);
			}

			return p;

			function fulfill(x) {
				/*jshint validthis:true*/
				if(this.resolved) { // this === resolver
					return;
				}

				results.push(x);
				if(--nFulfill === 0) {
					errors = null;
					this.resolve(results);
				}
			}

			function reject(e) {
				/*jshint validthis:true*/
				if(this.resolved) { // this === resolver
					return;
				}

				errors.push(e);
				if(--nReject === 0) {
					results = null;
					this.reject(errors);
				}
			}
		}

		/**
		 * Apply f to the value of each promise in a list of promises
		 * and return a new list containing the results.
		 * @param {array} promises
		 * @param {function(x:*, index:Number):*} f mapping function
		 * @returns {Promise}
		 */
		function map(promises, f) {
			return Promise._traverse(f, promises);
		}

		/**
		 * Filter the provided array of promises using the provided predicate.  Input may
		 * contain promises and values
		 * @param {Array} promises array of promises and values
		 * @param {function(x:*, index:Number):boolean} predicate filtering predicate.
		 *  Must return truthy (or promise for truthy) for items to retain.
		 * @returns {Promise} promise that will fulfill with an array containing all items
		 *  for which predicate returned truthy.
		 */
		function filter(promises, predicate) {
			var a = slice.call(promises);
			return Promise._traverse(predicate, a).then(function(keep) {
				return filterSync(a, keep);
			});
		}

		function filterSync(promises, keep) {
			// Safe because we know all promises have fulfilled if we've made it this far
			var l = keep.length;
			var filtered = new Array(l);
			for(var i=0, j=0; i<l; ++i) {
				if(keep[i]) {
					filtered[j++] = Promise._handler(promises[i]).value;
				}
			}
			filtered.length = j;
			return filtered;

		}

		/**
		 * Return a promise that will always fulfill with an array containing
		 * the outcome states of all input promises.  The returned promise
		 * will never reject.
		 * @param {Array} promises
		 * @returns {Promise} promise for array of settled state descriptors
		 */
		function settle(promises) {
			return all(promises.map(settleOne));
		}

		function settleOne(p) {
			var h = Promise._handler(p);
			if(h.state() === 0) {
				return toPromise(p).then(state.fulfilled, state.rejected);
			}

			h._unreport();
			return state.inspect(h);
		}

		/**
		 * Traditional reduce function, similar to `Array.prototype.reduce()`, but
		 * input may contain promises and/or values, and reduceFunc
		 * may return either a value or a promise, *and* initialValue may
		 * be a promise for the starting value.
		 * @param {Array|Promise} promises array or promise for an array of anything,
		 *      may contain a mix of promises and values.
		 * @param {function(accumulated:*, x:*, index:Number):*} f reduce function
		 * @returns {Promise} that will resolve to the final reduced value
		 */
		function reduce(promises, f /*, initialValue */) {
			return arguments.length > 2 ? ar.call(promises, liftCombine(f), arguments[2])
					: ar.call(promises, liftCombine(f));
		}

		/**
		 * Traditional reduce function, similar to `Array.prototype.reduceRight()`, but
		 * input may contain promises and/or values, and reduceFunc
		 * may return either a value or a promise, *and* initialValue may
		 * be a promise for the starting value.
		 * @param {Array|Promise} promises array or promise for an array of anything,
		 *      may contain a mix of promises and values.
		 * @param {function(accumulated:*, x:*, index:Number):*} f reduce function
		 * @returns {Promise} that will resolve to the final reduced value
		 */
		function reduceRight(promises, f /*, initialValue */) {
			return arguments.length > 2 ? arr.call(promises, liftCombine(f), arguments[2])
					: arr.call(promises, liftCombine(f));
		}

		function liftCombine(f) {
			return function(z, x, i) {
				return applyFold(f, void 0, [z,x,i]);
			};
		}
	};

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));

},{"../apply":423,"../state":437}],425:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	return function flow(Promise) {

		var resolve = Promise.resolve;
		var reject = Promise.reject;
		var origCatch = Promise.prototype['catch'];

		/**
		 * Handle the ultimate fulfillment value or rejection reason, and assume
		 * responsibility for all errors.  If an error propagates out of result
		 * or handleFatalError, it will be rethrown to the host, resulting in a
		 * loud stack track on most platforms and a crash on some.
		 * @param {function?} onResult
		 * @param {function?} onError
		 * @returns {undefined}
		 */
		Promise.prototype.done = function(onResult, onError) {
			this._handler.visit(this._handler.receiver, onResult, onError);
		};

		/**
		 * Add Error-type and predicate matching to catch.  Examples:
		 * promise.catch(TypeError, handleTypeError)
		 *   .catch(predicate, handleMatchedErrors)
		 *   .catch(handleRemainingErrors)
		 * @param onRejected
		 * @returns {*}
		 */
		Promise.prototype['catch'] = Promise.prototype.otherwise = function(onRejected) {
			if (arguments.length < 2) {
				return origCatch.call(this, onRejected);
			}

			if(typeof onRejected !== 'function') {
				return this.ensure(rejectInvalidPredicate);
			}

			return origCatch.call(this, createCatchFilter(arguments[1], onRejected));
		};

		/**
		 * Wraps the provided catch handler, so that it will only be called
		 * if the predicate evaluates truthy
		 * @param {?function} handler
		 * @param {function} predicate
		 * @returns {function} conditional catch handler
		 */
		function createCatchFilter(handler, predicate) {
			return function(e) {
				return evaluatePredicate(e, predicate)
					? handler.call(this, e)
					: reject(e);
			};
		}

		/**
		 * Ensures that onFulfilledOrRejected will be called regardless of whether
		 * this promise is fulfilled or rejected.  onFulfilledOrRejected WILL NOT
		 * receive the promises' value or reason.  Any returned value will be disregarded.
		 * onFulfilledOrRejected may throw or return a rejected promise to signal
		 * an additional error.
		 * @param {function} handler handler to be called regardless of
		 *  fulfillment or rejection
		 * @returns {Promise}
		 */
		Promise.prototype['finally'] = Promise.prototype.ensure = function(handler) {
			if(typeof handler !== 'function') {
				return this;
			}

			return this.then(function(x) {
				return runSideEffect(handler, this, identity, x);
			}, function(e) {
				return runSideEffect(handler, this, reject, e);
			});
		};

		function runSideEffect (handler, thisArg, propagate, value) {
			var result = handler.call(thisArg);
			return maybeThenable(result)
				? propagateValue(result, propagate, value)
				: propagate(value);
		}

		function propagateValue (result, propagate, x) {
			return resolve(result).then(function () {
				return propagate(x);
			});
		}

		/**
		 * Recover from a failure by returning a defaultValue.  If defaultValue
		 * is a promise, it's fulfillment value will be used.  If defaultValue is
		 * a promise that rejects, the returned promise will reject with the
		 * same reason.
		 * @param {*} defaultValue
		 * @returns {Promise} new promise
		 */
		Promise.prototype['else'] = Promise.prototype.orElse = function(defaultValue) {
			return this.then(void 0, function() {
				return defaultValue;
			});
		};

		/**
		 * Shortcut for .then(function() { return value; })
		 * @param  {*} value
		 * @return {Promise} a promise that:
		 *  - is fulfilled if value is not a promise, or
		 *  - if value is a promise, will fulfill with its value, or reject
		 *    with its reason.
		 */
		Promise.prototype['yield'] = function(value) {
			return this.then(function() {
				return value;
			});
		};

		/**
		 * Runs a side effect when this promise fulfills, without changing the
		 * fulfillment value.
		 * @param {function} onFulfilledSideEffect
		 * @returns {Promise}
		 */
		Promise.prototype.tap = function(onFulfilledSideEffect) {
			return this.then(onFulfilledSideEffect)['yield'](this);
		};

		return Promise;
	};

	function rejectInvalidPredicate() {
		throw new TypeError('catch predicate must be a function');
	}

	function evaluatePredicate(e, predicate) {
		return isError(predicate) ? e instanceof predicate : predicate(e);
	}

	function isError(predicate) {
		return predicate === Error
			|| (predicate != null && predicate.prototype instanceof Error);
	}

	function maybeThenable(x) {
		return (typeof x === 'object' || typeof x === 'function') && x !== null;
	}

	function identity(x) {
		return x;
	}

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));

},{}],426:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */
/** @author Jeff Escalante */

(function(define) { 'use strict';
define(function() {

	return function fold(Promise) {

		Promise.prototype.fold = function(f, z) {
			var promise = this._beget();

			this._handler.fold(function(z, x, to) {
				Promise._handler(z).fold(function(x, z, to) {
					to.resolve(f.call(this, z, x));
				}, x, this, to);
			}, z, promise._handler.receiver, promise._handler);

			return promise;
		};

		return Promise;
	};

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));

},{}],427:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function(require) {

	var inspect = require('../state').inspect;

	return function inspection(Promise) {

		Promise.prototype.inspect = function() {
			return inspect(Promise._handler(this));
		};

		return Promise;
	};

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));

},{"../state":437}],428:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	return function generate(Promise) {

		var resolve = Promise.resolve;

		Promise.iterate = iterate;
		Promise.unfold = unfold;

		return Promise;

		/**
		 * @deprecated Use github.com/cujojs/most streams and most.iterate
		 * Generate a (potentially infinite) stream of promised values:
		 * x, f(x), f(f(x)), etc. until condition(x) returns true
		 * @param {function} f function to generate a new x from the previous x
		 * @param {function} condition function that, given the current x, returns
		 *  truthy when the iterate should stop
		 * @param {function} handler function to handle the value produced by f
		 * @param {*|Promise} x starting value, may be a promise
		 * @return {Promise} the result of the last call to f before
		 *  condition returns true
		 */
		function iterate(f, condition, handler, x) {
			return unfold(function(x) {
				return [x, f(x)];
			}, condition, handler, x);
		}

		/**
		 * @deprecated Use github.com/cujojs/most streams and most.unfold
		 * Generate a (potentially infinite) stream of promised values
		 * by applying handler(generator(seed)) iteratively until
		 * condition(seed) returns true.
		 * @param {function} unspool function that generates a [value, newSeed]
		 *  given a seed.
		 * @param {function} condition function that, given the current seed, returns
		 *  truthy when the unfold should stop
		 * @param {function} handler function to handle the value produced by unspool
		 * @param x {*|Promise} starting value, may be a promise
		 * @return {Promise} the result of the last value produced by unspool before
		 *  condition returns true
		 */
		function unfold(unspool, condition, handler, x) {
			return resolve(x).then(function(seed) {
				return resolve(condition(seed)).then(function(done) {
					return done ? seed : resolve(unspool(seed)).spread(next);
				});
			});

			function next(item, newSeed) {
				return resolve(handler(item)).then(function() {
					return unfold(unspool, condition, handler, newSeed);
				});
			}
		}
	};

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));

},{}],429:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	return function progress(Promise) {

		/**
		 * @deprecated
		 * Register a progress handler for this promise
		 * @param {function} onProgress
		 * @returns {Promise}
		 */
		Promise.prototype.progress = function(onProgress) {
			return this.then(void 0, void 0, onProgress);
		};

		return Promise;
	};

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));

},{}],430:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function(require) {

	var env = require('../env');
	var TimeoutError = require('../TimeoutError');

	function setTimeout(f, ms, x, y) {
		return env.setTimer(function() {
			f(x, y, ms);
		}, ms);
	}

	return function timed(Promise) {
		/**
		 * Return a new promise whose fulfillment value is revealed only
		 * after ms milliseconds
		 * @param {number} ms milliseconds
		 * @returns {Promise}
		 */
		Promise.prototype.delay = function(ms) {
			var p = this._beget();
			this._handler.fold(handleDelay, ms, void 0, p._handler);
			return p;
		};

		function handleDelay(ms, x, h) {
			setTimeout(resolveDelay, ms, x, h);
		}

		function resolveDelay(x, h) {
			h.resolve(x);
		}

		/**
		 * Return a new promise that rejects after ms milliseconds unless
		 * this promise fulfills earlier, in which case the returned promise
		 * fulfills with the same value.
		 * @param {number} ms milliseconds
		 * @param {Error|*=} reason optional rejection reason to use, defaults
		 *   to a TimeoutError if not provided
		 * @returns {Promise}
		 */
		Promise.prototype.timeout = function(ms, reason) {
			var p = this._beget();
			var h = p._handler;

			var t = setTimeout(onTimeout, ms, reason, p._handler);

			this._handler.visit(h,
				function onFulfill(x) {
					env.clearTimer(t);
					this.resolve(x); // this = h
				},
				function onReject(x) {
					env.clearTimer(t);
					this.reject(x); // this = h
				},
				h.notify);

			return p;
		};

		function onTimeout(reason, h, ms) {
			var e = typeof reason === 'undefined'
				? new TimeoutError('timed out after ' + ms + 'ms')
				: reason;
			h.reject(e);
		}

		return Promise;
	};

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));

},{"../TimeoutError":422,"../env":433}],431:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function(require) {

	var setTimer = require('../env').setTimer;
	var format = require('../format');

	return function unhandledRejection(Promise) {

		var logError = noop;
		var logInfo = noop;
		var localConsole;

		if(typeof console !== 'undefined') {
			// Alias console to prevent things like uglify's drop_console option from
			// removing console.log/error. Unhandled rejections fall into the same
			// category as uncaught exceptions, and build tools shouldn't silence them.
			localConsole = console;
			logError = typeof localConsole.error !== 'undefined'
				? function (e) { localConsole.error(e); }
				: function (e) { localConsole.log(e); };

			logInfo = typeof localConsole.info !== 'undefined'
				? function (e) { localConsole.info(e); }
				: function (e) { localConsole.log(e); };
		}

		Promise.onPotentiallyUnhandledRejection = function(rejection) {
			enqueue(report, rejection);
		};

		Promise.onPotentiallyUnhandledRejectionHandled = function(rejection) {
			enqueue(unreport, rejection);
		};

		Promise.onFatalRejection = function(rejection) {
			enqueue(throwit, rejection.value);
		};

		var tasks = [];
		var reported = [];
		var running = null;

		function report(r) {
			if(!r.handled) {
				reported.push(r);
				logError('Potentially unhandled rejection [' + r.id + '] ' + format.formatError(r.value));
			}
		}

		function unreport(r) {
			var i = reported.indexOf(r);
			if(i >= 0) {
				reported.splice(i, 1);
				logInfo('Handled previous rejection [' + r.id + '] ' + format.formatObject(r.value));
			}
		}

		function enqueue(f, x) {
			tasks.push(f, x);
			if(running === null) {
				running = setTimer(flush, 0);
			}
		}

		function flush() {
			running = null;
			while(tasks.length > 0) {
				tasks.shift()(tasks.shift());
			}
		}

		return Promise;
	};

	function throwit(e) {
		throw e;
	}

	function noop() {}

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));

},{"../env":433,"../format":434}],432:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	return function addWith(Promise) {
		/**
		 * Returns a promise whose handlers will be called with `this` set to
		 * the supplied receiver.  Subsequent promises derived from the
		 * returned promise will also have their handlers called with receiver
		 * as `this`. Calling `with` with undefined or no arguments will return
		 * a promise whose handlers will again be called in the usual Promises/A+
		 * way (no `this`) thus safely undoing any previous `with` in the
		 * promise chain.
		 *
		 * WARNING: Promises returned from `with`/`withThis` are NOT Promises/A+
		 * compliant, specifically violating 2.2.5 (http://promisesaplus.com/#point-41)
		 *
		 * @param {object} receiver `this` value for all handlers attached to
		 *  the returned promise.
		 * @returns {Promise}
		 */
		Promise.prototype['with'] = Promise.prototype.withThis = function(receiver) {
			var p = this._beget();
			var child = p._handler;
			child.receiver = receiver;
			this._handler.chain(child, receiver);
			return p;
		};

		return Promise;
	};

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));


},{}],433:[function(require,module,exports){
(function (process){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

/*global process,document,setTimeout,clearTimeout,MutationObserver,WebKitMutationObserver*/
(function(define) { 'use strict';
define(function(require) {
	/*jshint maxcomplexity:6*/

	// Sniff "best" async scheduling option
	// Prefer process.nextTick or MutationObserver, then check for
	// setTimeout, and finally vertx, since its the only env that doesn't
	// have setTimeout

	var MutationObs;
	var capturedSetTimeout = typeof setTimeout !== 'undefined' && setTimeout;

	// Default env
	var setTimer = function(f, ms) { return setTimeout(f, ms); };
	var clearTimer = function(t) { return clearTimeout(t); };
	var asap = function (f) { return capturedSetTimeout(f, 0); };

	// Detect specific env
	if (isNode()) { // Node
		asap = function (f) { return process.nextTick(f); };

	} else if (MutationObs = hasMutationObserver()) { // Modern browser
		asap = initMutationObserver(MutationObs);

	} else if (!capturedSetTimeout) { // vert.x
		var vertxRequire = require;
		var vertx = vertxRequire('vertx');
		setTimer = function (f, ms) { return vertx.setTimer(ms, f); };
		clearTimer = vertx.cancelTimer;
		asap = vertx.runOnLoop || vertx.runOnContext;
	}

	return {
		setTimer: setTimer,
		clearTimer: clearTimer,
		asap: asap
	};

	function isNode () {
		return typeof process !== 'undefined' &&
			Object.prototype.toString.call(process) === '[object process]';
	}

	function hasMutationObserver () {
		return (typeof MutationObserver === 'function' && MutationObserver) ||
			(typeof WebKitMutationObserver === 'function' && WebKitMutationObserver);
	}

	function initMutationObserver(MutationObserver) {
		var scheduled;
		var node = document.createTextNode('');
		var o = new MutationObserver(run);
		o.observe(node, { characterData: true });

		function run() {
			var f = scheduled;
			scheduled = void 0;
			f();
		}

		var i = 0;
		return function (f) {
			scheduled = f;
			node.data = (i ^= 1);
		};
	}
});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));

}).call(this,require('_process'))
},{"_process":377}],434:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	return {
		formatError: formatError,
		formatObject: formatObject,
		tryStringify: tryStringify
	};

	/**
	 * Format an error into a string.  If e is an Error and has a stack property,
	 * it's returned.  Otherwise, e is formatted using formatObject, with a
	 * warning added about e not being a proper Error.
	 * @param {*} e
	 * @returns {String} formatted string, suitable for output to developers
	 */
	function formatError(e) {
		var s = typeof e === 'object' && e !== null && (e.stack || e.message) ? e.stack || e.message : formatObject(e);
		return e instanceof Error ? s : s + ' (WARNING: non-Error used)';
	}

	/**
	 * Format an object, detecting "plain" objects and running them through
	 * JSON.stringify if possible.
	 * @param {Object} o
	 * @returns {string}
	 */
	function formatObject(o) {
		var s = String(o);
		if(s === '[object Object]' && typeof JSON !== 'undefined') {
			s = tryStringify(o, s);
		}
		return s;
	}

	/**
	 * Try to return the result of JSON.stringify(x).  If that fails, return
	 * defaultValue
	 * @param {*} x
	 * @param {*} defaultValue
	 * @returns {String|*} JSON.stringify(x) or defaultValue
	 */
	function tryStringify(x, defaultValue) {
		try {
			return JSON.stringify(x);
		} catch(e) {
			return defaultValue;
		}
	}

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));

},{}],435:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	return function liftAll(liftOne, combine, dst, src) {
		if(typeof combine === 'undefined') {
			combine = defaultCombine;
		}

		return Object.keys(src).reduce(function(dst, key) {
			var f = src[key];
			return typeof f === 'function' ? combine(dst, liftOne(f), key) : dst;
		}, typeof dst === 'undefined' ? defaultDst(src) : dst);
	};

	function defaultCombine(o, f, k) {
		o[k] = f;
		return o;
	}

	function defaultDst(src) {
		return typeof src === 'function' ? src.bind() : Object.create(src);
	}
});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));

},{}],436:[function(require,module,exports){
(function (process){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	return function makePromise(environment) {

		var tasks = environment.scheduler;
		var emitRejection = initEmitRejection();

		var objectCreate = Object.create ||
			function(proto) {
				function Child() {}
				Child.prototype = proto;
				return new Child();
			};

		/**
		 * Create a promise whose fate is determined by resolver
		 * @constructor
		 * @returns {Promise} promise
		 * @name Promise
		 */
		function Promise(resolver, handler) {
			this._handler = resolver === Handler ? handler : init(resolver);
		}

		/**
		 * Run the supplied resolver
		 * @param resolver
		 * @returns {Pending}
		 */
		function init(resolver) {
			var handler = new Pending();

			try {
				resolver(promiseResolve, promiseReject, promiseNotify);
			} catch (e) {
				promiseReject(e);
			}

			return handler;

			/**
			 * Transition from pre-resolution state to post-resolution state, notifying
			 * all listeners of the ultimate fulfillment or rejection
			 * @param {*} x resolution value
			 */
			function promiseResolve (x) {
				handler.resolve(x);
			}
			/**
			 * Reject this promise with reason, which will be used verbatim
			 * @param {Error|*} reason rejection reason, strongly suggested
			 *   to be an Error type
			 */
			function promiseReject (reason) {
				handler.reject(reason);
			}

			/**
			 * @deprecated
			 * Issue a progress event, notifying all progress listeners
			 * @param {*} x progress event payload to pass to all listeners
			 */
			function promiseNotify (x) {
				handler.notify(x);
			}
		}

		// Creation

		Promise.resolve = resolve;
		Promise.reject = reject;
		Promise.never = never;

		Promise._defer = defer;
		Promise._handler = getHandler;

		/**
		 * Returns a trusted promise. If x is already a trusted promise, it is
		 * returned, otherwise returns a new trusted Promise which follows x.
		 * @param  {*} x
		 * @return {Promise} promise
		 */
		function resolve(x) {
			return isPromise(x) ? x
				: new Promise(Handler, new Async(getHandler(x)));
		}

		/**
		 * Return a reject promise with x as its reason (x is used verbatim)
		 * @param {*} x
		 * @returns {Promise} rejected promise
		 */
		function reject(x) {
			return new Promise(Handler, new Async(new Rejected(x)));
		}

		/**
		 * Return a promise that remains pending forever
		 * @returns {Promise} forever-pending promise.
		 */
		function never() {
			return foreverPendingPromise; // Should be frozen
		}

		/**
		 * Creates an internal {promise, resolver} pair
		 * @private
		 * @returns {Promise}
		 */
		function defer() {
			return new Promise(Handler, new Pending());
		}

		// Transformation and flow control

		/**
		 * Transform this promise's fulfillment value, returning a new Promise
		 * for the transformed result.  If the promise cannot be fulfilled, onRejected
		 * is called with the reason.  onProgress *may* be called with updates toward
		 * this promise's fulfillment.
		 * @param {function=} onFulfilled fulfillment handler
		 * @param {function=} onRejected rejection handler
		 * @param {function=} onProgress @deprecated progress handler
		 * @return {Promise} new promise
		 */
		Promise.prototype.then = function(onFulfilled, onRejected, onProgress) {
			var parent = this._handler;
			var state = parent.join().state();

			if ((typeof onFulfilled !== 'function' && state > 0) ||
				(typeof onRejected !== 'function' && state < 0)) {
				// Short circuit: value will not change, simply share handler
				return new this.constructor(Handler, parent);
			}

			var p = this._beget();
			var child = p._handler;

			parent.chain(child, parent.receiver, onFulfilled, onRejected, onProgress);

			return p;
		};

		/**
		 * If this promise cannot be fulfilled due to an error, call onRejected to
		 * handle the error. Shortcut for .then(undefined, onRejected)
		 * @param {function?} onRejected
		 * @return {Promise}
		 */
		Promise.prototype['catch'] = function(onRejected) {
			return this.then(void 0, onRejected);
		};

		/**
		 * Creates a new, pending promise of the same type as this promise
		 * @private
		 * @returns {Promise}
		 */
		Promise.prototype._beget = function() {
			return begetFrom(this._handler, this.constructor);
		};

		function begetFrom(parent, Promise) {
			var child = new Pending(parent.receiver, parent.join().context);
			return new Promise(Handler, child);
		}

		// Array combinators

		Promise.all = all;
		Promise.race = race;
		Promise._traverse = traverse;

		/**
		 * Return a promise that will fulfill when all promises in the
		 * input array have fulfilled, or will reject when one of the
		 * promises rejects.
		 * @param {array} promises array of promises
		 * @returns {Promise} promise for array of fulfillment values
		 */
		function all(promises) {
			return traverseWith(snd, null, promises);
		}

		/**
		 * Array<Promise<X>> -> Promise<Array<f(X)>>
		 * @private
		 * @param {function} f function to apply to each promise's value
		 * @param {Array} promises array of promises
		 * @returns {Promise} promise for transformed values
		 */
		function traverse(f, promises) {
			return traverseWith(tryCatch2, f, promises);
		}

		function traverseWith(tryMap, f, promises) {
			var handler = typeof f === 'function' ? mapAt : settleAt;

			var resolver = new Pending();
			var pending = promises.length >>> 0;
			var results = new Array(pending);

			for (var i = 0, x; i < promises.length && !resolver.resolved; ++i) {
				x = promises[i];

				if (x === void 0 && !(i in promises)) {
					--pending;
					continue;
				}

				traverseAt(promises, handler, i, x, resolver);
			}

			if(pending === 0) {
				resolver.become(new Fulfilled(results));
			}

			return new Promise(Handler, resolver);

			function mapAt(i, x, resolver) {
				if(!resolver.resolved) {
					traverseAt(promises, settleAt, i, tryMap(f, x, i), resolver);
				}
			}

			function settleAt(i, x, resolver) {
				results[i] = x;
				if(--pending === 0) {
					resolver.become(new Fulfilled(results));
				}
			}
		}

		function traverseAt(promises, handler, i, x, resolver) {
			if (maybeThenable(x)) {
				var h = getHandlerMaybeThenable(x);
				var s = h.state();

				if (s === 0) {
					h.fold(handler, i, void 0, resolver);
				} else if (s > 0) {
					handler(i, h.value, resolver);
				} else {
					resolver.become(h);
					visitRemaining(promises, i+1, h);
				}
			} else {
				handler(i, x, resolver);
			}
		}

		Promise._visitRemaining = visitRemaining;
		function visitRemaining(promises, start, handler) {
			for(var i=start; i<promises.length; ++i) {
				markAsHandled(getHandler(promises[i]), handler);
			}
		}

		function markAsHandled(h, handler) {
			if(h === handler) {
				return;
			}

			var s = h.state();
			if(s === 0) {
				h.visit(h, void 0, h._unreport);
			} else if(s < 0) {
				h._unreport();
			}
		}

		/**
		 * Fulfill-reject competitive race. Return a promise that will settle
		 * to the same state as the earliest input promise to settle.
		 *
		 * WARNING: The ES6 Promise spec requires that race()ing an empty array
		 * must return a promise that is pending forever.  This implementation
		 * returns a singleton forever-pending promise, the same singleton that is
		 * returned by Promise.never(), thus can be checked with ===
		 *
		 * @param {array} promises array of promises to race
		 * @returns {Promise} if input is non-empty, a promise that will settle
		 * to the same outcome as the earliest input promise to settle. if empty
		 * is empty, returns a promise that will never settle.
		 */
		function race(promises) {
			if(typeof promises !== 'object' || promises === null) {
				return reject(new TypeError('non-iterable passed to race()'));
			}

			// Sigh, race([]) is untestable unless we return *something*
			// that is recognizable without calling .then() on it.
			return promises.length === 0 ? never()
				 : promises.length === 1 ? resolve(promises[0])
				 : runRace(promises);
		}

		function runRace(promises) {
			var resolver = new Pending();
			var i, x, h;
			for(i=0; i<promises.length; ++i) {
				x = promises[i];
				if (x === void 0 && !(i in promises)) {
					continue;
				}

				h = getHandler(x);
				if(h.state() !== 0) {
					resolver.become(h);
					visitRemaining(promises, i+1, h);
					break;
				} else {
					h.visit(resolver, resolver.resolve, resolver.reject);
				}
			}
			return new Promise(Handler, resolver);
		}

		// Promise internals
		// Below this, everything is @private

		/**
		 * Get an appropriate handler for x, without checking for cycles
		 * @param {*} x
		 * @returns {object} handler
		 */
		function getHandler(x) {
			if(isPromise(x)) {
				return x._handler.join();
			}
			return maybeThenable(x) ? getHandlerUntrusted(x) : new Fulfilled(x);
		}

		/**
		 * Get a handler for thenable x.
		 * NOTE: You must only call this if maybeThenable(x) == true
		 * @param {object|function|Promise} x
		 * @returns {object} handler
		 */
		function getHandlerMaybeThenable(x) {
			return isPromise(x) ? x._handler.join() : getHandlerUntrusted(x);
		}

		/**
		 * Get a handler for potentially untrusted thenable x
		 * @param {*} x
		 * @returns {object} handler
		 */
		function getHandlerUntrusted(x) {
			try {
				var untrustedThen = x.then;
				return typeof untrustedThen === 'function'
					? new Thenable(untrustedThen, x)
					: new Fulfilled(x);
			} catch(e) {
				return new Rejected(e);
			}
		}

		/**
		 * Handler for a promise that is pending forever
		 * @constructor
		 */
		function Handler() {}

		Handler.prototype.when
			= Handler.prototype.become
			= Handler.prototype.notify // deprecated
			= Handler.prototype.fail
			= Handler.prototype._unreport
			= Handler.prototype._report
			= noop;

		Handler.prototype._state = 0;

		Handler.prototype.state = function() {
			return this._state;
		};

		/**
		 * Recursively collapse handler chain to find the handler
		 * nearest to the fully resolved value.
		 * @returns {object} handler nearest the fully resolved value
		 */
		Handler.prototype.join = function() {
			var h = this;
			while(h.handler !== void 0) {
				h = h.handler;
			}
			return h;
		};

		Handler.prototype.chain = function(to, receiver, fulfilled, rejected, progress) {
			this.when({
				resolver: to,
				receiver: receiver,
				fulfilled: fulfilled,
				rejected: rejected,
				progress: progress
			});
		};

		Handler.prototype.visit = function(receiver, fulfilled, rejected, progress) {
			this.chain(failIfRejected, receiver, fulfilled, rejected, progress);
		};

		Handler.prototype.fold = function(f, z, c, to) {
			this.when(new Fold(f, z, c, to));
		};

		/**
		 * Handler that invokes fail() on any handler it becomes
		 * @constructor
		 */
		function FailIfRejected() {}

		inherit(Handler, FailIfRejected);

		FailIfRejected.prototype.become = function(h) {
			h.fail();
		};

		var failIfRejected = new FailIfRejected();

		/**
		 * Handler that manages a queue of consumers waiting on a pending promise
		 * @constructor
		 */
		function Pending(receiver, inheritedContext) {
			Promise.createContext(this, inheritedContext);

			this.consumers = void 0;
			this.receiver = receiver;
			this.handler = void 0;
			this.resolved = false;
		}

		inherit(Handler, Pending);

		Pending.prototype._state = 0;

		Pending.prototype.resolve = function(x) {
			this.become(getHandler(x));
		};

		Pending.prototype.reject = function(x) {
			if(this.resolved) {
				return;
			}

			this.become(new Rejected(x));
		};

		Pending.prototype.join = function() {
			if (!this.resolved) {
				return this;
			}

			var h = this;

			while (h.handler !== void 0) {
				h = h.handler;
				if (h === this) {
					return this.handler = cycle();
				}
			}

			return h;
		};

		Pending.prototype.run = function() {
			var q = this.consumers;
			var handler = this.handler;
			this.handler = this.handler.join();
			this.consumers = void 0;

			for (var i = 0; i < q.length; ++i) {
				handler.when(q[i]);
			}
		};

		Pending.prototype.become = function(handler) {
			if(this.resolved) {
				return;
			}

			this.resolved = true;
			this.handler = handler;
			if(this.consumers !== void 0) {
				tasks.enqueue(this);
			}

			if(this.context !== void 0) {
				handler._report(this.context);
			}
		};

		Pending.prototype.when = function(continuation) {
			if(this.resolved) {
				tasks.enqueue(new ContinuationTask(continuation, this.handler));
			} else {
				if(this.consumers === void 0) {
					this.consumers = [continuation];
				} else {
					this.consumers.push(continuation);
				}
			}
		};

		/**
		 * @deprecated
		 */
		Pending.prototype.notify = function(x) {
			if(!this.resolved) {
				tasks.enqueue(new ProgressTask(x, this));
			}
		};

		Pending.prototype.fail = function(context) {
			var c = typeof context === 'undefined' ? this.context : context;
			this.resolved && this.handler.join().fail(c);
		};

		Pending.prototype._report = function(context) {
			this.resolved && this.handler.join()._report(context);
		};

		Pending.prototype._unreport = function() {
			this.resolved && this.handler.join()._unreport();
		};

		/**
		 * Wrap another handler and force it into a future stack
		 * @param {object} handler
		 * @constructor
		 */
		function Async(handler) {
			this.handler = handler;
		}

		inherit(Handler, Async);

		Async.prototype.when = function(continuation) {
			tasks.enqueue(new ContinuationTask(continuation, this));
		};

		Async.prototype._report = function(context) {
			this.join()._report(context);
		};

		Async.prototype._unreport = function() {
			this.join()._unreport();
		};

		/**
		 * Handler that wraps an untrusted thenable and assimilates it in a future stack
		 * @param {function} then
		 * @param {{then: function}} thenable
		 * @constructor
		 */
		function Thenable(then, thenable) {
			Pending.call(this);
			tasks.enqueue(new AssimilateTask(then, thenable, this));
		}

		inherit(Pending, Thenable);

		/**
		 * Handler for a fulfilled promise
		 * @param {*} x fulfillment value
		 * @constructor
		 */
		function Fulfilled(x) {
			Promise.createContext(this);
			this.value = x;
		}

		inherit(Handler, Fulfilled);

		Fulfilled.prototype._state = 1;

		Fulfilled.prototype.fold = function(f, z, c, to) {
			runContinuation3(f, z, this, c, to);
		};

		Fulfilled.prototype.when = function(cont) {
			runContinuation1(cont.fulfilled, this, cont.receiver, cont.resolver);
		};

		var errorId = 0;

		/**
		 * Handler for a rejected promise
		 * @param {*} x rejection reason
		 * @constructor
		 */
		function Rejected(x) {
			Promise.createContext(this);

			this.id = ++errorId;
			this.value = x;
			this.handled = false;
			this.reported = false;

			this._report();
		}

		inherit(Handler, Rejected);

		Rejected.prototype._state = -1;

		Rejected.prototype.fold = function(f, z, c, to) {
			to.become(this);
		};

		Rejected.prototype.when = function(cont) {
			if(typeof cont.rejected === 'function') {
				this._unreport();
			}
			runContinuation1(cont.rejected, this, cont.receiver, cont.resolver);
		};

		Rejected.prototype._report = function(context) {
			tasks.afterQueue(new ReportTask(this, context));
		};

		Rejected.prototype._unreport = function() {
			if(this.handled) {
				return;
			}
			this.handled = true;
			tasks.afterQueue(new UnreportTask(this));
		};

		Rejected.prototype.fail = function(context) {
			this.reported = true;
			emitRejection('unhandledRejection', this);
			Promise.onFatalRejection(this, context === void 0 ? this.context : context);
		};

		function ReportTask(rejection, context) {
			this.rejection = rejection;
			this.context = context;
		}

		ReportTask.prototype.run = function() {
			if(!this.rejection.handled && !this.rejection.reported) {
				this.rejection.reported = true;
				emitRejection('unhandledRejection', this.rejection) ||
					Promise.onPotentiallyUnhandledRejection(this.rejection, this.context);
			}
		};

		function UnreportTask(rejection) {
			this.rejection = rejection;
		}

		UnreportTask.prototype.run = function() {
			if(this.rejection.reported) {
				emitRejection('rejectionHandled', this.rejection) ||
					Promise.onPotentiallyUnhandledRejectionHandled(this.rejection);
			}
		};

		// Unhandled rejection hooks
		// By default, everything is a noop

		Promise.createContext
			= Promise.enterContext
			= Promise.exitContext
			= Promise.onPotentiallyUnhandledRejection
			= Promise.onPotentiallyUnhandledRejectionHandled
			= Promise.onFatalRejection
			= noop;

		// Errors and singletons

		var foreverPendingHandler = new Handler();
		var foreverPendingPromise = new Promise(Handler, foreverPendingHandler);

		function cycle() {
			return new Rejected(new TypeError('Promise cycle'));
		}

		// Task runners

		/**
		 * Run a single consumer
		 * @constructor
		 */
		function ContinuationTask(continuation, handler) {
			this.continuation = continuation;
			this.handler = handler;
		}

		ContinuationTask.prototype.run = function() {
			this.handler.join().when(this.continuation);
		};

		/**
		 * Run a queue of progress handlers
		 * @constructor
		 */
		function ProgressTask(value, handler) {
			this.handler = handler;
			this.value = value;
		}

		ProgressTask.prototype.run = function() {
			var q = this.handler.consumers;
			if(q === void 0) {
				return;
			}

			for (var c, i = 0; i < q.length; ++i) {
				c = q[i];
				runNotify(c.progress, this.value, this.handler, c.receiver, c.resolver);
			}
		};

		/**
		 * Assimilate a thenable, sending it's value to resolver
		 * @param {function} then
		 * @param {object|function} thenable
		 * @param {object} resolver
		 * @constructor
		 */
		function AssimilateTask(then, thenable, resolver) {
			this._then = then;
			this.thenable = thenable;
			this.resolver = resolver;
		}

		AssimilateTask.prototype.run = function() {
			var h = this.resolver;
			tryAssimilate(this._then, this.thenable, _resolve, _reject, _notify);

			function _resolve(x) { h.resolve(x); }
			function _reject(x)  { h.reject(x); }
			function _notify(x)  { h.notify(x); }
		};

		function tryAssimilate(then, thenable, resolve, reject, notify) {
			try {
				then.call(thenable, resolve, reject, notify);
			} catch (e) {
				reject(e);
			}
		}

		/**
		 * Fold a handler value with z
		 * @constructor
		 */
		function Fold(f, z, c, to) {
			this.f = f; this.z = z; this.c = c; this.to = to;
			this.resolver = failIfRejected;
			this.receiver = this;
		}

		Fold.prototype.fulfilled = function(x) {
			this.f.call(this.c, this.z, x, this.to);
		};

		Fold.prototype.rejected = function(x) {
			this.to.reject(x);
		};

		Fold.prototype.progress = function(x) {
			this.to.notify(x);
		};

		// Other helpers

		/**
		 * @param {*} x
		 * @returns {boolean} true iff x is a trusted Promise
		 */
		function isPromise(x) {
			return x instanceof Promise;
		}

		/**
		 * Test just enough to rule out primitives, in order to take faster
		 * paths in some code
		 * @param {*} x
		 * @returns {boolean} false iff x is guaranteed *not* to be a thenable
		 */
		function maybeThenable(x) {
			return (typeof x === 'object' || typeof x === 'function') && x !== null;
		}

		function runContinuation1(f, h, receiver, next) {
			if(typeof f !== 'function') {
				return next.become(h);
			}

			Promise.enterContext(h);
			tryCatchReject(f, h.value, receiver, next);
			Promise.exitContext();
		}

		function runContinuation3(f, x, h, receiver, next) {
			if(typeof f !== 'function') {
				return next.become(h);
			}

			Promise.enterContext(h);
			tryCatchReject3(f, x, h.value, receiver, next);
			Promise.exitContext();
		}

		/**
		 * @deprecated
		 */
		function runNotify(f, x, h, receiver, next) {
			if(typeof f !== 'function') {
				return next.notify(x);
			}

			Promise.enterContext(h);
			tryCatchReturn(f, x, receiver, next);
			Promise.exitContext();
		}

		function tryCatch2(f, a, b) {
			try {
				return f(a, b);
			} catch(e) {
				return reject(e);
			}
		}

		/**
		 * Return f.call(thisArg, x), or if it throws return a rejected promise for
		 * the thrown exception
		 */
		function tryCatchReject(f, x, thisArg, next) {
			try {
				next.become(getHandler(f.call(thisArg, x)));
			} catch(e) {
				next.become(new Rejected(e));
			}
		}

		/**
		 * Same as above, but includes the extra argument parameter.
		 */
		function tryCatchReject3(f, x, y, thisArg, next) {
			try {
				f.call(thisArg, x, y, next);
			} catch(e) {
				next.become(new Rejected(e));
			}
		}

		/**
		 * @deprecated
		 * Return f.call(thisArg, x), or if it throws, *return* the exception
		 */
		function tryCatchReturn(f, x, thisArg, next) {
			try {
				next.notify(f.call(thisArg, x));
			} catch(e) {
				next.notify(e);
			}
		}

		function inherit(Parent, Child) {
			Child.prototype = objectCreate(Parent.prototype);
			Child.prototype.constructor = Child;
		}

		function snd(x, y) {
			return y;
		}

		function noop() {}

		function initEmitRejection() {
			/*global process, self, CustomEvent*/
			if(typeof process !== 'undefined' && process !== null
				&& typeof process.emit === 'function') {
				// Returning falsy here means to call the default
				// onPotentiallyUnhandledRejection API.  This is safe even in
				// browserify since process.emit always returns falsy in browserify:
				// https://github.com/defunctzombie/node-process/blob/master/browser.js#L40-L46
				return function(type, rejection) {
					return type === 'unhandledRejection'
						? process.emit(type, rejection.value, rejection)
						: process.emit(type, rejection);
				};
			} else if(typeof self !== 'undefined' && typeof CustomEvent === 'function') {
				return (function(noop, self, CustomEvent) {
					var hasCustomEvent = false;
					try {
						var ev = new CustomEvent('unhandledRejection');
						hasCustomEvent = ev instanceof CustomEvent;
					} catch (e) {}

					return !hasCustomEvent ? noop : function(type, rejection) {
						var ev = new CustomEvent(type, {
							detail: {
								reason: rejection.value,
								key: rejection
							},
							bubbles: false,
							cancelable: true
						});

						return !self.dispatchEvent(ev);
					};
				}(noop, self, CustomEvent));
			}

			return noop;
		}

		return Promise;
	};
});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));

}).call(this,require('_process'))
},{"_process":377}],437:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	return {
		pending: toPendingState,
		fulfilled: toFulfilledState,
		rejected: toRejectedState,
		inspect: inspect
	};

	function toPendingState() {
		return { state: 'pending' };
	}

	function toRejectedState(e) {
		return { state: 'rejected', reason: e };
	}

	function toFulfilledState(x) {
		return { state: 'fulfilled', value: x };
	}

	function inspect(handler) {
		var state = handler.state();
		return state === 0 ? toPendingState()
			 : state > 0   ? toFulfilledState(handler.value)
			               : toRejectedState(handler.value);
	}

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));

},{}],438:[function(require,module,exports){
/** @license MIT License (c) copyright 2013 original author or authors */

/**
 * Collection of helpers for interfacing with node-style asynchronous functions
 * using promises.
 *
 * @author Brian Cavalier
 * @contributor Renato Zannon
 */

(function(define) {
define(function(require) {

	var when = require('./when');
	var _liftAll = require('./lib/liftAll');
	var setTimer = require('./lib/env').setTimer;
	var slice = Array.prototype.slice;

	var _apply = require('./lib/apply')(when.Promise, dispatch);

	return {
		lift: lift,
		liftAll: liftAll,
		apply: apply,
		call: call,
		createCallback: createCallback,
		bindCallback: bindCallback,
		liftCallback: liftCallback
	};

	/**
	 * Takes a node-style async function and calls it immediately (with an optional
	 * array of arguments or promises for arguments). It returns a promise whose
	 * resolution depends on whether the async functions calls its callback with the
	 * conventional error argument or not.
	 *
	 * With this it becomes possible to leverage existing APIs while still reaping
	 * the benefits of promises.
	 *
	 * @example
	 *    function onlySmallNumbers(n, callback) {
	 *		if(n < 10) {
	 *			callback(null, n + 10);
	 *		} else {
	 *			callback(new Error("Calculation failed"));
	 *		}
	 *	}
	 *
	 *    var nodefn = require("when/node/function");
	 *
	 *    // Logs '15'
	 *    nodefn.apply(onlySmallNumbers, [5]).then(console.log, console.error);
	 *
	 *    // Logs 'Calculation failed'
	 *    nodefn.apply(onlySmallNumbers, [15]).then(console.log, console.error);
	 *
	 * @param {function} f node-style function that will be called
	 * @param {Array} [args] array of arguments to func
	 * @returns {Promise} promise for the value func passes to its callback
	 */
	function apply(f, args) {
		return _apply(f, this, args || []);
	}

	function dispatch(f, thisArg, args, h) {
		var cb = createCallback(h);
		try {
			switch(args.length) {
				case 2: f.call(thisArg, args[0], args[1], cb); break;
				case 1: f.call(thisArg, args[0], cb); break;
				case 0: f.call(thisArg, cb); break;
				default:
					args.push(cb);
					f.apply(thisArg, args);
			}
		} catch(e) {
			h.reject(e);
		}
	}

	/**
	 * Has the same behavior that {@link apply} has, with the difference that the
	 * arguments to the function are provided individually, while {@link apply} accepts
	 * a single array.
	 *
	 * @example
	 *    function sumSmallNumbers(x, y, callback) {
	 *		var result = x + y;
	 *		if(result < 10) {
	 *			callback(null, result);
	 *		} else {
	 *			callback(new Error("Calculation failed"));
	 *		}
	 *	}
	 *
	 *    // Logs '5'
	 *    nodefn.call(sumSmallNumbers, 2, 3).then(console.log, console.error);
	 *
	 *    // Logs 'Calculation failed'
	 *    nodefn.call(sumSmallNumbers, 5, 10).then(console.log, console.error);
	 *
	 * @param {function} f node-style function that will be called
	 * @param {...*} [args] arguments that will be forwarded to the function
	 * @returns {Promise} promise for the value func passes to its callback
	 */
	function call(f /*, args... */) {
		return _apply(f, this, slice.call(arguments, 1));
	}

	/**
	 * Takes a node-style function and returns new function that wraps the
	 * original and, instead of taking a callback, returns a promise. Also, it
	 * knows how to handle promises given as arguments, waiting for their
	 * resolution before executing.
	 *
	 * Upon execution, the orginal function is executed as well. If it passes
	 * a truthy value as the first argument to the callback, it will be
	 * interpreted as an error condition, and the promise will be rejected
	 * with it. Otherwise, the call is considered a resolution, and the promise
	 * is resolved with the callback's second argument.
	 *
	 * @example
	 *    var fs = require("fs"), nodefn = require("when/node/function");
	 *
	 *    var promiseRead = nodefn.lift(fs.readFile);
	 *
	 *    // The promise is resolved with the contents of the file if everything
	 *    // goes ok
	 *    promiseRead('exists.txt').then(console.log, console.error);
	 *
	 *    // And will be rejected if something doesn't work out
	 *    // (e.g. the files does not exist)
	 *    promiseRead('doesnt_exist.txt').then(console.log, console.error);
	 *
	 *
	 * @param {Function} f node-style function to be lifted
	 * @param {...*} [args] arguments to be prepended for the new function @deprecated
	 * @returns {Function} a promise-returning function
	 */
	function lift(f /*, args... */) {
		var args1 = arguments.length > 1 ? slice.call(arguments, 1) : [];
		return function() {
			// TODO: Simplify once partialing has been removed
			var l = args1.length;
			var al = arguments.length;
			var args = new Array(al + l);
			var i;
			for(i=0; i<l; ++i) {
				args[i] = args1[i];
			}
			for(i=0; i<al; ++i) {
				args[i+l] = arguments[i];
			}
			return _apply(f, this, args);
		};
	}

	/**
	 * Lift all the functions/methods on src
	 * @param {object|function} src source whose functions will be lifted
	 * @param {function?} combine optional function for customizing the lifting
	 *  process. It is passed dst, the lifted function, and the property name of
	 *  the original function on src.
	 * @param {(object|function)?} dst option destination host onto which to place lifted
	 *  functions. If not provided, liftAll returns a new object.
	 * @returns {*} If dst is provided, returns dst with lifted functions as
	 *  properties.  If dst not provided, returns a new object with lifted functions.
	 */
	function liftAll(src, combine, dst) {
		return _liftAll(lift, combine, dst, src);
	}

	/**
	 * Takes an object that responds to the resolver interface, and returns
	 * a function that will resolve or reject it depending on how it is called.
	 *
	 * @example
	 *	function callbackTakingFunction(callback) {
	 *		if(somethingWrongHappened) {
	 *			callback(error);
	 *		} else {
	 *			callback(null, interestingValue);
	 *		}
	 *	}
	 *
	 *	var when = require('when'), nodefn = require('when/node/function');
	 *
	 *	var deferred = when.defer();
	 *	callbackTakingFunction(nodefn.createCallback(deferred.resolver));
	 *
	 *	deferred.promise.then(function(interestingValue) {
	 *		// Use interestingValue
	 *	});
	 *
	 * @param {Resolver} resolver that will be 'attached' to the callback
	 * @returns {Function} a node-style callback function
	 */
	function createCallback(resolver) {
		return function(err, value) {
			if(err) {
				resolver.reject(err);
			} else if(arguments.length > 2) {
				resolver.resolve(slice.call(arguments, 1));
			} else {
				resolver.resolve(value);
			}
		};
	}

	/**
	 * Attaches a node-style callback to a promise, ensuring the callback is
	 * called for either fulfillment or rejection. Returns a promise with the same
	 * state as the passed-in promise.
	 *
	 * @example
	 *	var deferred = when.defer();
	 *
	 *	function callback(err, value) {
	 *		// Handle err or use value
	 *	}
	 *
	 *	bindCallback(deferred.promise, callback);
	 *
	 *	deferred.resolve('interesting value');
	 *
	 * @param {Promise} promise The promise to be attached to.
	 * @param {Function} callback The node-style callback to attach.
	 * @returns {Promise} A promise with the same state as the passed-in promise.
	 */
	function bindCallback(promise, callback) {
		promise = when(promise);

		if (callback) {
			promise.then(success, wrapped);
		}

		return promise;

		function success(value) {
			wrapped(null, value);
		}

		function wrapped(err, value) {
			setTimer(function () {
				callback(err, value);
			}, 0);
		}
	}

	/**
	 * Takes a node-style callback and returns new function that accepts a
	 * promise, calling the original callback when the promise is either
	 * fulfilled or rejected with the appropriate arguments.
	 *
	 * @example
	 *	var deferred = when.defer();
	 *
	 *	function callback(err, value) {
	 *		// Handle err or use value
	 *	}
	 *
	 *	var wrapped = liftCallback(callback);
	 *
	 *	// `wrapped` can now be passed around at will
	 *	wrapped(deferred.promise);
	 *
	 *	deferred.resolve('interesting value');
	 *
	 * @param {Function} callback The node-style callback to wrap.
	 * @returns {Function} The lifted, promise-accepting function.
	 */
	function liftCallback(callback) {
		return function(promise) {
			return bindCallback(promise, callback);
		};
	}
});

})(typeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); });




},{"./lib/apply":423,"./lib/env":433,"./lib/liftAll":435,"./when":439}],439:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */

/**
 * Promises/A+ and when() implementation
 * when is part of the cujoJS family of libraries (http://cujojs.com/)
 * @author Brian Cavalier
 * @author John Hann
 */
(function(define) { 'use strict';
define(function (require) {

	var timed = require('./lib/decorators/timed');
	var array = require('./lib/decorators/array');
	var flow = require('./lib/decorators/flow');
	var fold = require('./lib/decorators/fold');
	var inspect = require('./lib/decorators/inspect');
	var generate = require('./lib/decorators/iterate');
	var progress = require('./lib/decorators/progress');
	var withThis = require('./lib/decorators/with');
	var unhandledRejection = require('./lib/decorators/unhandledRejection');
	var TimeoutError = require('./lib/TimeoutError');

	var Promise = [array, flow, fold, generate, progress,
		inspect, withThis, timed, unhandledRejection]
		.reduce(function(Promise, feature) {
			return feature(Promise);
		}, require('./lib/Promise'));

	var apply = require('./lib/apply')(Promise);

	// Public API

	when.promise     = promise;              // Create a pending promise
	when.resolve     = Promise.resolve;      // Create a resolved promise
	when.reject      = Promise.reject;       // Create a rejected promise

	when.lift        = lift;                 // lift a function to return promises
	when['try']      = attempt;              // call a function and return a promise
	when.attempt     = attempt;              // alias for when.try

	when.iterate     = Promise.iterate;      // DEPRECATED (use cujojs/most streams) Generate a stream of promises
	when.unfold      = Promise.unfold;       // DEPRECATED (use cujojs/most streams) Generate a stream of promises

	when.join        = join;                 // Join 2 or more promises

	when.all         = all;                  // Resolve a list of promises
	when.settle      = settle;               // Settle a list of promises

	when.any         = lift(Promise.any);    // One-winner race
	when.some        = lift(Promise.some);   // Multi-winner race
	when.race        = lift(Promise.race);   // First-to-settle race

	when.map         = map;                  // Array.map() for promises
	when.filter      = filter;               // Array.filter() for promises
	when.reduce      = lift(Promise.reduce);       // Array.reduce() for promises
	when.reduceRight = lift(Promise.reduceRight);  // Array.reduceRight() for promises

	when.isPromiseLike = isPromiseLike;      // Is something promise-like, aka thenable

	when.Promise     = Promise;              // Promise constructor
	when.defer       = defer;                // Create a {promise, resolve, reject} tuple

	// Error types

	when.TimeoutError = TimeoutError;

	/**
	 * Get a trusted promise for x, or by transforming x with onFulfilled
	 *
	 * @param {*} x
	 * @param {function?} onFulfilled callback to be called when x is
	 *   successfully fulfilled.  If promiseOrValue is an immediate value, callback
	 *   will be invoked immediately.
	 * @param {function?} onRejected callback to be called when x is
	 *   rejected.
	 * @param {function?} onProgress callback to be called when progress updates
	 *   are issued for x. @deprecated
	 * @returns {Promise} a new promise that will fulfill with the return
	 *   value of callback or errback or the completion value of promiseOrValue if
	 *   callback and/or errback is not supplied.
	 */
	function when(x, onFulfilled, onRejected, onProgress) {
		var p = Promise.resolve(x);
		if (arguments.length < 2) {
			return p;
		}

		return p.then(onFulfilled, onRejected, onProgress);
	}

	/**
	 * Creates a new promise whose fate is determined by resolver.
	 * @param {function} resolver function(resolve, reject, notify)
	 * @returns {Promise} promise whose fate is determine by resolver
	 */
	function promise(resolver) {
		return new Promise(resolver);
	}

	/**
	 * Lift the supplied function, creating a version of f that returns
	 * promises, and accepts promises as arguments.
	 * @param {function} f
	 * @returns {Function} version of f that returns promises
	 */
	function lift(f) {
		return function() {
			for(var i=0, l=arguments.length, a=new Array(l); i<l; ++i) {
				a[i] = arguments[i];
			}
			return apply(f, this, a);
		};
	}

	/**
	 * Call f in a future turn, with the supplied args, and return a promise
	 * for the result.
	 * @param {function} f
	 * @returns {Promise}
	 */
	function attempt(f /*, args... */) {
		/*jshint validthis:true */
		for(var i=0, l=arguments.length-1, a=new Array(l); i<l; ++i) {
			a[i] = arguments[i+1];
		}
		return apply(f, this, a);
	}

	/**
	 * Creates a {promise, resolver} pair, either or both of which
	 * may be given out safely to consumers.
	 * @return {{promise: Promise, resolve: function, reject: function, notify: function}}
	 */
	function defer() {
		return new Deferred();
	}

	function Deferred() {
		var p = Promise._defer();

		function resolve(x) { p._handler.resolve(x); }
		function reject(x) { p._handler.reject(x); }
		function notify(x) { p._handler.notify(x); }

		this.promise = p;
		this.resolve = resolve;
		this.reject = reject;
		this.notify = notify;
		this.resolver = { resolve: resolve, reject: reject, notify: notify };
	}

	/**
	 * Determines if x is promise-like, i.e. a thenable object
	 * NOTE: Will return true for *any thenable object*, and isn't truly
	 * safe, since it may attempt to access the `then` property of x (i.e.
	 *  clever/malicious getters may do weird things)
	 * @param {*} x anything
	 * @returns {boolean} true if x is promise-like
	 */
	function isPromiseLike(x) {
		return x && typeof x.then === 'function';
	}

	/**
	 * Return a promise that will resolve only once all the supplied arguments
	 * have resolved. The resolution value of the returned promise will be an array
	 * containing the resolution values of each of the arguments.
	 * @param {...*} arguments may be a mix of promises and values
	 * @returns {Promise}
	 */
	function join(/* ...promises */) {
		return Promise.all(arguments);
	}

	/**
	 * Return a promise that will fulfill once all input promises have
	 * fulfilled, or reject when any one input promise rejects.
	 * @param {array|Promise} promises array (or promise for an array) of promises
	 * @returns {Promise}
	 */
	function all(promises) {
		return when(promises, Promise.all);
	}

	/**
	 * Return a promise that will always fulfill with an array containing
	 * the outcome states of all input promises.  The returned promise
	 * will only reject if `promises` itself is a rejected promise.
	 * @param {array|Promise} promises array (or promise for an array) of promises
	 * @returns {Promise} promise for array of settled state descriptors
	 */
	function settle(promises) {
		return when(promises, Promise.settle);
	}

	/**
	 * Promise-aware array map function, similar to `Array.prototype.map()`,
	 * but input array may contain promises or values.
	 * @param {Array|Promise} promises array of anything, may contain promises and values
	 * @param {function(x:*, index:Number):*} mapFunc map function which may
	 *  return a promise or value
	 * @returns {Promise} promise that will fulfill with an array of mapped values
	 *  or reject if any input promise rejects.
	 */
	function map(promises, mapFunc) {
		return when(promises, function(promises) {
			return Promise.map(promises, mapFunc);
		});
	}

	/**
	 * Filter the provided array of promises using the provided predicate.  Input may
	 * contain promises and values
	 * @param {Array|Promise} promises array of promises and values
	 * @param {function(x:*, index:Number):boolean} predicate filtering predicate.
	 *  Must return truthy (or promise for truthy) for items to retain.
	 * @returns {Promise} promise that will fulfill with an array containing all items
	 *  for which predicate returned truthy.
	 */
	function filter(promises, predicate) {
		return when(promises, function(promises) {
			return Promise.filter(promises, predicate);
		});
	}

	return when;
});
})(typeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); });

},{"./lib/Promise":420,"./lib/TimeoutError":422,"./lib/apply":423,"./lib/decorators/array":424,"./lib/decorators/flow":425,"./lib/decorators/fold":426,"./lib/decorators/inspect":427,"./lib/decorators/iterate":428,"./lib/decorators/progress":429,"./lib/decorators/timed":430,"./lib/decorators/unhandledRejection":431,"./lib/decorators/with":432}],440:[function(require,module,exports){
/* eslint-disable no-unused-vars */
'use strict';

var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

module.exports = Object.assign || function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (Object.getOwnPropertySymbols) {
			symbols = Object.getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};

},{}]},{},[36]);
