// SpotifyPlus variables
var devModeEnabled = true;
var lyricsAppEnabled = false;

(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
module.exports = {
  "browse.app_name": "Browse",
  "latest-releases.app_name": "Aktuelle Neuerscheinungen",
  "discover.app_name": "Entdecken",
  "activity.app_name": "Aktivitäten",
  "radio.app_name": "Radio",
  "settings.app_name": "Einstellungen",
  "messages.app_name": "Nachrichten",
  "profile.app_name": "Profil",
  "notifications_center.app_name": "Benachrichtigungen",
  "concerts.app_name": "Konzerte",
  "profile.private_session": "Private Session",
  "profile.upgrade": "Upgrade",
  "profile.upgrade_account": "Upgrade für Dein Konto holen",
  "profile.upgrade_tooltip": "Auf Spotify Premium upgraden",
  "profile.account": "Konto",
  "profile.logout": "Abmelden",
  "profile.enabled": "Aktiviert",
  "profile.menu_label": "Menü",
  "profile.switch": "Benutzer wechseln",
  "profile.new_user": "Zu 'Neuer Benutzer' wechseln",
  "your_music.app_name": "Deine Musik",
  "your_music.songs": "Songs",
  "your_music.artists": "Künstler",
  "your_music.albums": "Alben",
  "your_music.stations": "Sender",
  "your_music.local_files": "Lokale Dateien",
  "sidebar.title_main": "Hauptmenü",
  "sidebar.title_playlists": "Playlists",
  "new_playlist.input_placeholder": "Neue Playlist",
  "new_playlist.button": "Neue Playlist",
  "accessibilitylinks.skip_to_content_label": "Zum Hauptinhalt springen",
  "accessibilitylinks.skip_to_player_label": "Zur Player-Steuerung springen",
  "playlist.by": "von {0}",
  "playlist.loading": "Wird geladen ...",
  "playlist.newfolder": "Neuer Ordner",
  "playlist.delete_message": "Möchtest du diese Playlist wirklich löschen?",
  "playlist.unfollow_message": "Möchtest du dieser Playlist wirklich nicht mehr folgen?",
  "playlistfolder.delete_message": "Möchtest Du diesen Ordner und alle darin enthaltenen Playlists wirklich löschen?",
  "playlist.delete_confirm": "Löschen",
  "playlist.unfollow_confirm": "Nicht mehr folgen",
  "playlist.delete_cancel": "Abbrechen",
  "playlist.duplicates_dialog_title": "Doppelte Songs",
  "playlist.duplicates_dialog_title_single": "Doppelter Song",
  "playlist.duplicates_dialog_body": "Einige dieser Songs befinden sich bereits in Deiner Playlist.",
  "playlist.duplicates_dialog_body_single": "Dieser Song ist bereits in Deiner Playlist.",
  "playlist.duplicates_dialog_button_add": "Alle hinzufügen",
  "playlist.duplicates_dialog_button_add_single": "Trotzdem hinzufügen",
  "playlist.duplicates_dialog_button_skip_duplicates": "Doppelte Songs überspringen",
  "playlist.duplicates_dialog_button_skip_single": "Doppelten Song überspringen",
  "playlist.annotate_form.new_playlist_name": "Neue Playlist",
  "playlist.annotate_form.create_title": "Playlist erstellen",
  "playlist.annotate_form.create": "Erstellen",
  "playlist.annotate_form.cancel": "Abbrechen",
  "playlist.annotate_form.edit_title": "Playlist-Details bearbeiten",
  "playlist.annotate_form.save": "Speichern",
  "playlist.annotate_form.name_field_label": "Name",
  "playlist.annotate_form.name_field_placeholder": "Name der Playlist",
  "playlist.annotate_form.image_field_label": "Bild",
  "playlist.annotate_form.image_pick_button_label": "Bild wählen",
  "playlist.annotate_form.image_replace_button_label": "Bild ersetzen",
  "playlist.annotate_form.image_remove_button_label": "Bild entfernen",
  "playlist.annotate_form.image_file_size_exceeded": "Das Bild ist zu groß. Maximale Größe: 4 MB",
  "playlist.annotate_form.image_file_upload_failed": "Das Bild konnte nicht geladen werden. Versuche es bitte erneut.",
  "playlist.annotate_form.annotate_failed": "Die Beschreibung und das Bild konnten nicht aktualisiert werden. Versuche es bitte erneut.",
  "playlist.annotate_form.close-error-bar": "Ausblenden",
  "playlist.annotate_form.description_field_label": "Beschreibung",
  "playlist.annotate_form.description_field_placeholder": "Gib Deiner Playlist eine griffige Beschreibung.",
  "playlist.annotate_form.permission_message": "Wenn Du fortfährst, gewährst Du Spotify Zugriff auf das von Dir hochgeladene Bild. Bitte vergewissere Dich, dass Du das Recht hast, das Bild hochzuladen. Wir nutzen Dein Bild ausschließlich als Cover für Deine Playlist.",
  "playlist.annotate_form.insert_link_button_label": "Link einsetzen",
  "playlist.annotate_form.insert_link.link_field_label": "Verbinden mit",
  "playlist.annotate_form.insert_link.change_button_label": "Ändern",
  "playlist.annotate_form.insert_link.remove_button_label": "Entfernen",
  "playlist.annotate_form.insert_link.done_button_label": "Fertig",
  "playlist.annotate_form.drop_to_set_image_label": "Loslassen, um das Bild einzufügen",
  "playlist.annotate_form.drop_not_allowed_label": "Nicht unterstütztes Format",
  "playlist.annotate_form.error.file_not_valid_jpg": "Diese Datei ist – trotz des Dateinamens – keine gültige JPG-Datei.",
  "playlist.annotate_form.error.name_required": "Du musst Deiner Playlist einen Namen geben.",
  "playlist.annotate_form.error.selection_required_to_insert_link": "Du musst den Text auswählen, den Du als Link nutzen möchtest.",
  "playlist.annotate_form.error.html_not_allowed": "Du scheinst HTML verwenden zu wollen, was leider nicht möglich ist.",
  "playlist.annotate_form.error.submit": "Änderungen an der Playlist konnten nicht gespeichert werden. Versuch es später erneut.",
  "playlist.annotate_form.error.image_too_small": "Das Bild ist zu klein. Mindestgröße: {0} x {1}",
  "playlist.annotate_form.warning.client_offline": "Keine Internetverbindung gefunden. Änderungen an der Beschreibung und dem Bild können nicht gespeichert werden.",
  "playlist.annotate_form.warning.no_line_breaks_in_description": "Sorry, Zeilenumbrüche werden in der Beschreibung nicht unterstützt.",
  "playlist.annotate_form.warning.unsaved_changes": "Möchtest Du Deine Änderungen speichern?",
  "navigation.label": "Navigation",
  "navigation.back_button_label": "Zurück",
  "navigation.forward_button_label": "Weiter",
  "search.input_placeholder": "Suchen",
  "player.label": "Player-Steuerung",
  "player.shuffle_mode_label": "Shuffle",
  "player.repeat_mode_label": "Wiederholen",
  "player.queue": "Warteschlange",
  "player.volume_button_label": "Lautstärke",
  "player.spotify_connect": "Spotify Connect",
  "player.connect_button_label": "Mit einem Gerät verbinden",
  "player.lyrics_label": "Songtexte",
  "player.play_button_label": "Play",
  "player.pause_button_label": "Pause",
  "player.previous_button_label": "Zurück",
  "player.next_button_label": "Weiter",
  "player.offline_label": "Offline",
  "player.thumb_up_label": "Daumen hoch",
  "player.thumb_down_label": "Daumen runter",
  "playererror.default": "Beim Abspielen des ausgewählten Songs ist ein Problem aufgetreten.",
  "playererror.track_not_available": "Dieser Song ist nicht verfügbar.",
  "nowplaying.label": "Aktueller Titel",
  "nowplaying.go_to_context": "Zu aktuellem Titel wechseln",
  "nowplaying.save_your_music": "In \"Deine Musik\" speichern",
  "nowplaying.remove_your_music": "Aus \"Deine Musik\" entfernen",
  "nowplaying.playing_suggested_track": "Vorgeschlagener Song wird zurzeit abgespielt.",
  "connect.connect_text": "Mit einem Gerät verbinden",
  "connect.device_connecting": "Verbinden...",
  "connect.device_incompatible": "Inkompatibel",
  "connect.device_premium_only": "Nur Premium Nutzer",
  "connect.device_sleeping": "Gerät ist im Schlafmodus.",
  "connect.device_tech_cast": "Google Cast",
  "connect.device_tech_connect": "Spotify Connect",
  "connect.device_this_computer": "Dieser Computer",
  "connect.device_unavailable_for_playback": "Zurzeit nicht verfügbar",
  "connect.device_unknown": "Unbekanntes Gerät",
  "connect.device_unsupported_uri": "Kann zurzeit nicht abgespielt werden.",
  "connect.devices_available": "Verfügbare Geräte",
  "connect.dismiss": "Abbrechen",
  "connect.help1": "Mit Connect kannst du Spotify auf deinen Geräten abspielen und bedienen.",
  "connect.help2": "Starte Spotify auf einem anderen Gerät. Dann wird es hier angezeigt.",
  "connect.help_hint": "Was ist Connect?",
  "connect.offline": "Nicht verfügbar",
  "connect.offline_reason_computer": "Spotify ist auf diesem Gerät nicht aktiv.",
  "connect.offline_reason_generic": "Spotify ist auf diesem Gerät nicht aktiv.",
  "connect.offline_reason_phone": "Handy gesperrt oder Spotify nicht im Vordergrund",
  "connect.offline_reason_gameconsole": "In den Aktivierungseinstellungen der Spotify PlayStation App kannst Du einrichten, dass die PlayStation aus dem Stand-by-Modus wieder aktiviert wird.",
  "connect.offline_text1": "Geh online, um dieses Feature zu verwenden.",
  "connect.offline_title": "Du bist offline!",
  "connect.playingon": "Du hörst auf:",
  "connect.popup_title": "Geräte",
  "connect.remoteplayback": "Du hörst auf {0}",
  "connect.show_more": "Mehr anzeigen",
  "connect.upgrade": "Upgrade",
  "connect.upsell": "Connect ist ein Premium-Feature, mit dem du Spotify auf deinen Geräten abspielen und bedienen kannst. ",
  "contextmenu.new-playlist": "Neue Playlist",
  "contextmenu.add-to-playlist": "Zu Playlist hinzufügen",
  "contextmenu.owner-playlist": "von {0}",
  "contextmenu.copy-uri": "Spotify URI kopieren",
  "contextmenu.copy-artist-url": "Künstlerlink kopieren",
  "contextmenu.copy-album-url": "Albumlink kopieren",
  "contextmenu.copy-track-url": "Songlink kopieren",
  "contextmenu.copy-playlist-url": "Playlistlink kopieren",
  "contextmenu.copy-profile-url": "Profillink kopieren",
  "contextmenu.copy-station-url": "Sender-Link kopieren",
  "contextmenu.copy-chart-url": "Chartlink kopieren",
  "contextmenu.copy-url": "Link kopieren",
  "contextmenu.copy-embed": "Code zum Einbetten kopieren",
  "contextmenu.collaborative": "Gemeinsame Playlist",
  "contextmenu.save": "In \"Deine Musik\" speichern",
  "contextmenu.remove": "Aus \"Deine Musik\" entfernen",
  "contextmenu.delete-playlist": "Löschen",
  "contextmenu.follow": "Folgen",
  "contextmenu.unfollow": "Nicht mehr folgen",
  "contextmenu.publish": "Veröffentlichen",
  "contextmenu.unpublish": "Geheim halten",
  "contextmenu.playlist.loading": "Wird geladen ...",
  "contextmenu.play": "Play",
  "contextmenu.add-to-queue": "In Warteschlange",
  "contextmenu.station": "Zum Radio",
  "contextmenu.station-album": "Gehe zu Album-Radio",
  "contextmenu.station-artist": "Gehe zu Künstler-Radio",
  "contextmenu.station-playlist": "Gehe zu Playlist-Radio",
  "contextmenu.station-track": "Gehe zu Song-Radio",
  "contextmenu.station-chart": "Zum Chart-Radio",
  "contextmenu.remove-from-playlist": "Aus dieser Playlist entfernen",
  "contextmenu.remove-from-queue": "Aus Warteliste entfernen",
  "contextmenu.rename-folder": "Umbenennen",
  "contextmenu.rename-playlist": "Umbenennen",
  "contextmenu.edit-playlist": "Details bearbeiten",
  "contextmenu.report-playlist": "Melden",
  "contextmenu.report-asset": "Melden",
  "contextmenu.share": "Teilen...",
  "contextmenu.share-lyrics": "Songtext teilen",
  "contextmenu.create-folder": "Ordner anlegen",
  "contextmenu.create-playlist": "Playlist erstellen",
  "contextmenu.open-localfile-folder": "Enthaltenen Ordner öffnen",
  "contextmenu.open-localfile-folder-mac": "In Finder anzeigen",
  "contextmenu.offline": "Offline verfügbar",
  "contextmenu.goto-artist": "Künstler ansehen",
  "contextmenu.goto-album": "Zum Album gehen",
  "usermessage.default-message": "Ein Fehler ist aufgetreten.",
  "usermessage.update-ready": "Hallo. Wir haben eine neue Version von Spotify für Dich. <a href=\"#\" data-action=\"{0}\">Jetzt neu starten</a> und die neue Version nutzen.",
  "usermessage.update-ready-simple": "Hallo. Wir haben eine neue Version von Spotify für Dich. Jetzt neu starten und die neue Version nutzen.",
  "usermessage.play-token-lost": "Spotify wurde angehalten, da dein Konto woanders verwendet wird.",
  "usermessage.playback-paused-inactive": "Der Computer war lange Zeit inaktiv. Klick auf &quot;Wiedergabe&quot;, um weiter Musik zu hören! Abonniere <a href=\"#\" data-action=\"{0}\">Spotify Premium</a> für ununterbrochenen Musikgenuss.",
  "usermessage.not-available-offline": "Keine Internetverbindung gefunden. Spotify verbindet sich automatisch neu, wenn eine Internetverbindung gefunden wird (Fehlercode: 4).",
  "usermessage.track-not-available-in-region": "Dieser Song ist momentan in {0} nicht verfügbar. Wenn sich die Datei auf Deinem Computer befindet, kannst Du sie importieren.",
  "usermessage.track-not-available-in-region-generic": "Dieser Song ist momentan in Deinem Land nicht verfügbar. Wenn sich die Datei auf Deinem Computer befindet, kannst Du sie importieren.",
  "usermessage.track-not-available": "Dieser Song ist nicht verfügbar. Wenn sich die Datei auf Deinem Computer befindet, kannst Du sie importieren.",
  "usermessage.track-not-available-forced-offline": "Bitte <a href=\"#\" data-action=\"goOnline\">deaktiviere den Offline-Modus</a> und versuch es erneut.",
  "usermessage.track-exclusive-premium": "Dieser Song steht ausschließlich Benutzern von <a href=\"#\" data-action=\"{0}\">Spotify Premium</a> zur Verfügung.",
  "usermessage.track-banned-by-artist": "Der Künstler/das Label hat sich entschlossen, diesen Song nicht zur Verfügung zu stellen. Wenn sich die Datei auf Deinem Computer befindet, kannst Du sie importieren.",
  "usermessage.local-track-no-file": "Dieser Song wurde als lokale Datei hinzugefügt. Wenn sich die Datei auf Deinem Computer befindet, kannst Du sie importieren.",
  "usermessage.local-track-file-not-found": "Dieser Song kann nicht abgespielt werden, weil die Datei nicht gefunden wurde. Importiere sie erneut.",
  "usermessage.local-track-bad-format": "Das Dateiformat ist nicht bekannt.Weitere Informationen findest Du <a href=\"#\" data-action=\"{0}\">hier</a>.",
  "usermessage.capping-reached": "Dein Zeitlimit von {0} Stunden ist aufgebraucht. <a href=\"#\" data-action=\"{1}\">Hol Dir ein Upgrade auf Premium</a> und Du hörst ohne Einschränkungen.",
  "usermessage.local-track-drm-protected": "Dieser Song kann nicht abgespielt werden, weil die Datei DRM-geschützt ist.",
  "usermessage.offline-disk-cache": "Download von Offline-Songs fehlgeschlagen. Ist die Festplatte vielleicht voll?",
  "usermessage.offline-sync-expired": "Die Offline-Songs sind abgelaufen. Du musst Dich bei Spotify anmelden, um sie wieder zu aktivieren.",
  "usermessage.offline-sync-failed": "Download von einigen Offline-Songs fehlgeschlagen.",
  "usermessage.offline-too-many-tracks": "Zu viele Songs für den Offline-Modus ausgewählt.",
  "usermessage.offline-license-server-error": "Ein Problem mit dem Spotify-Server ist aufgetreten.",
  "usermessage.offline-license-lost": "Offline-Zugriff für diesen Computer/dieses Gerät wurde widerrufen.",
  "usermessage.offline-not-allowed": "Offline-Modus ist nur mit <a href=\"#\" data-action=\"{0}\">Spotify Premium</a> möglich.",
  "usermessage.language-changed": "Du musst <a href=\"#\" data-action=\"{0}\">Spotify neu starten</a>, damit die Änderung wirksam wird.",
  "usermessage.proxysettings-changed": "Du musst <a href=\"#\" data-action=\"{0}\">Spotify neu starten</a>, damit die Änderung wirksam wird.",
  "usermessage.language-changed-simple": "Du musst Spotify neu starten, damit die Änderung wirksam wird.",
  "usermessage.proxysettings-changed-simple": "Du musst Spotify neu starten, damit die Änderung wirksam wird.",
  "usermessage.cache-changed": "Du musst <a href=\"#\" data-action=\"{0}\">Spotify neu starten</a>, damit die Änderung wirksam wird.",
  "usermessage.cache-changed-simple": "Du musst Spotify neu starten, damit die Änderung wirksam wird.",
  "usermessage.feature-changed": "Du musst <a href=\"#\" data-action=\"{0}\">Spotify neu starten</a>, damit die Änderung wirksam wird.",
  "usermessage.first-autostart": "Spotify wurde automatisch in verkleinerter Darstellung geöffnet. Wenn Du möchtest, kannst Du <a href=\"#\" data-action=\"{0}\">Spotify ohne verkleinerte Darstellung öffnen</a> oder <a href=\"#\" data-action=\"{1}\">Spotify beim Start</a> gar nicht öffnen.",
  "usermessage.cant-play-track": "Aktueller Song kann nicht abgespielt werden.",
  "usermessage.cant-skip-ads": "Der ausgewählte Song wird nach der Werbung abgespielt.",
  "usermessage.cant-offline-playlists": "Offline-Modus ist nur mit Spotify Premium möglich. <a href=\"#\" data-action=\"{0}\">Hol Dir Premium</a>.",
  "usermessage.cant-set-high-quality-streaming": "Diese Funktion ist nur in Premium verfügbar. <a href=\"#\" data-action=\"{0}\">Hol Dir Premium</a>.",
  "usermessage.payment-state-creditcard-funds": "Aufgrund eines Problems mit Deiner Zahlung konnten wir Dein Abonnement nicht verlängern. Stelle bitte sicher, dass Dein Konto ausreichend gedeckt ist oder <a href=\"#\" data-action=\"{0}\">aktualisiere Deine Zahlungsdetails</a>.",
  "usermessage.payment-state-creditcard-refused": "Aufgrund eines Problems mit Deiner Zahlung konnten wir Dein Abonnement nicht verlängern. Wenn Du Dein Abonnement weiterführen möchtest, <a href=\"#\" data-action=\"{0}\">aktualisiere Deine Zahlungsdetails</a>.",
  "usermessage.payment-state-paypal-refused": "Aufgrund eines Problems mit Deiner Zahlung konnten wir Dein Abonnement nicht verlängern. Wenn Du Dein Abonnement weiterführen möchtest, <a href=\"#\" data-action=\"{0}\">aktualisiere Deine Zahlungsdetails</a>.",
  "usermessage.payment-state-creditcard-expiry": "Die Zahlungskarte, die Du zurzeit nutzt, läuft in wenigen Tagen ab. Wenn Du Dein Abonnement weiterführen möchtest, <a href=\"#\" data-action=\"{0}\">aktualisiere Deine Zahlungsdetails</a>",
  "usermessage.payment-state-prepaid-expiry": "Dein im Voraus bezahltes Abonnement läuft bald ab. Keine Sorge, Du kannst <a href=\"#\" data-action=\"{0}\">Premium hier abonnieren</a>.",
  "usermessage.payment-state-churn-payment": "Wir konnten leider keine Zahlung für Dich einziehen und mussten daher Dein Abonnement kündigen. Keine Sorge, Du kannst <a href=\"#\" data-action=\"{0}\">Dein Abonnement hier erneuern</a>.",
  "usermessage.payment-state-churn-partner": "Dein Abonnement mit einem unserer Partner ist gerade ausgelaufen. Du nutzt daher jetzt Spotify Free. Keine Sorge, Du kannst <a href=\"#\" data-action=\"{0}\">Premium hier wieder abonnieren</a>.",
  "usermessage.opt-in-trial": "Wir hoffen, Du genießt Dein kostenloses Probeabo! Wenn Du Premium auch danach noch nutzen möchtest, <a href=\"#\" data-action=\"{0}\">abonniere heute</a>.",
  "usermessage.opt-in-trial-expired": "Dein kostenloses Probeabo ist ausgelaufen. Du nutzt daher jetzt Spotify Free. Keine Sorge, Du kannst <a href=\"#\" data-action=\"{0}\">Premium hier wieder abonnieren</a>.",
  "usermessage.hardware-acceleration-changed": "Du musst <a href=\"#\" data-action=\"{0}\">Spotify neu starten</a>, damit die Änderung wirksam wird.",
  "usermessage.hardware-acceleration-changed-simple": "Du musst Spotify neu starten, damit die Änderung wirksam wird.",
  "usermessage.some-local-tracks-not-saved": "Einige der ausgewählten Songs wurden nicht in 'Deine Musik' gespeichert. Lokale Dateien werden nicht von 'Deine Musik' unterstützt.",
  "usermessage.illegal-playlist-name-entered": "Der eingegebene Name für die Playlist ist ungültig.",
  "usermessage.playlist-save-failed-unknown": "Aufgrund eines unbekannten Fehlers konnte die Playlist nicht gespeichert werden.",
  "usermessage.social-error-permissions": "Klick <a href=\"#\" data-action=\"{0}\">hier</a>, um Deine Aktivitäten auf Facebook zu teilen.",
  "usermessage.shuffle-unplayable-track": "<a href=\"#\" data-action=\"{0}\">Hol Dir ein Upgrade auf Premium</a>, um jeden Song jederzeit zu spielen.",
  "usermessage.shuffle-ran-out-of-skips": "Du kannst (in dieser Stunde) keine Titel mehr überspringen. <a href=\"#\" data-action=\"{0}\">Hol Dir ein Upgrade auf Premium</a>, um so häufig zu überspringen, wie Du möchtest.",
  "usermessage.playlist-limit-exceeded": "Diese Playlist ist am Ende ihrer Kapazität und wir sind schwer beeindruckt. Fang eine neue Playlist an und sammle weiter.",
  "usermessage.collection-limit-exceeded": "Gratuliere, Du hast eine großartige Sammlung. In 'Deine Musik' ist leider kein Platz mehr. Wenn Du neue Songs speichern möchtest, musst Du erst ein paar alte Titel löschen.",
  "usermessage.deprecating-os-version": "Achtung! Dein Betriebssystem wird ab einer der kommenden Versionen nicht mehr unterstützt. Klicke <a href=\"#\" data-action=\"{0}\">hier</a> für weitere Informationen.",
  "usermessage.image-upload-propagation": "Dein Bild wurde hochgeladen. Es kann bis zu 24 Stunden dauern, bis es überall zu sehen ist.",
  "usermessage.approaching-capping-limit": "Du kannst noch weniger als eine Stunde kostenlos Musik hören. Hör jeden Monat 15 Stunden kostenlos Musik oder <a href=\"#\" data-action=\"{0}\">führe das Upgrade auf Premium aus</a>, um unbegrenzt Musik hören zu können. <a href=\"#\" data-action=\"{1}\">Weitere Infos</a>",
  "usermessage.half-capping-limit-passed": "Du hast die Hälfte Deines monatlichen Zeitkontingents verbraucht. Hör jeden Monat 15 Stunden kostenlos Musik oder <a href=\"#\" data-action=\"{0}\">führe das Upgrade auf Premium aus</a>, um unbegrenzt Musik hören zu können. <a href=\"#\" data-action=\"{1}\">Weitere Infos</a>",
  "usermessage.video-georestricted": "Wir können dieses Video nicht an Deinem aktuellen Standort abspielen.",
  "usermessage.video-unsupported-client-version": "Führe das Upgrade von Spotify aus, um dieses Video anzusehen.",
  "usermessage.video-unsupported-platform-version": "Dieses Video kann mit Deiner Betriebssystemversion nicht abgespielt werden.",
  "usermessage.video-country-restricted": "Wir können dieses Video nicht an Deinem aktuellen Standort abspielen.",
  "usermessage.video-unavailable": "Dieses Video ist nicht verfügbar. Anderes Video ansehen?",
  "usermessage.video-catalogue-restricted": "Dieses Video kann leider nicht abgespielt werden.",
  "usermessage.video-playback-error": "Dieses Video kann leider nicht abgespielt werden.",
  "about.title_label": "Über Spotify",
  "about.close_button_label": "Schließen",
  "offline-progress-msg": "Offline-Synchronisierung von {0} von {1} Songs",
  "tos.updated_terms": "Aktualisierte Nutzungsbedingungen",
  "tos.modal_title": "Spotify Nutzungsbedingungen",
  "tos.tos_text": "<p>Wir haben unsere <a href=\"{0}\">Nutzungsbedingungen</a> und unsere <a href=\"{1}\">Datenschutzrichtlinie</a> überarbeitet.</p><p>Indem Du Spotify weiterhin nutzt, akzeptierst Du diese aktualisierten Bedingungen. Nimm Dir daher einige Minuten Zeit, um sie zu lesen.</p>",
  "tos.not_now_tos_text": "<p>Wir haben unsere <a href=\"{0}\">Nutzungsbedingungen</a> und <a href=\"{1}\">Datenschutzrichtlinie</a> überarbeitet.</p><p>Indem Du auf 'Annehmen' klickst, akzeptierst Du die Aktualisierungen (und die beschriebene Verarbeitung Deiner Daten). Nimm Dir daher bitte einige Minuten Zeit, um sie zu lesen.</p>",
  "tos.tos_text2": "<p>Wenn Du Spotify nicht mehr nutzen möchtest, kannst Du Dein Abonnement über Deine Spotify Abonnementseite kündigen.</p>",
  "tos.not_now_text": "<p>Du kannst Spotify noch {0} Tage nutzen, ohne die aktualisierten Nutzungsbedingungen und Datenschutzrichtlinien zu akzeptieren. Ab diesem Zeitpunkt ist es für die weitere Nutzung von Spotify erforderlich, dass Du die neuen Nutzungsbedingungen akzeptierst. Solange Du Dein Abonnement nicht beendest, erhältst Du weiterhin entsprechend Deines normalen Abrechnungszyklus eine monatliche Rechnung. Wenn Du nicht weiter für Spotify zahlen möchtest, kannst Du Dein Abonnement jederzeit über Deine Abonnementseite von Spotify beenden.</p>",
  "tos.not_now_last_day_text": "<p>Du kannst Spotify noch 1 Tag nutzen, ohne die aktualisierten Nutzungsbedingungen und Datenschutzrichtlinie zu akzeptieren. Wenn Du die neuen Bedingungen bis dahin nicht akzeptiert hast, wirst Du Spotify nicht mehr nutzen können. Solltest Du Dein Abonnement nicht kündigen, wird Dir nach wie vor – Deinem regulären Rechnungszeitraum entsprechend – der monatliche Betrag abgezogen. Wenn Du nicht möchtest, dass Spotify Deine Zahlungsmethode weiterhin belastet, kannst Du Spotify jederzeit über Deine Spotify Abonnementseite kündigen.</p>",
  "tos.not_now_text_germany": "<p>Wir haben unsere <a href=\"{0}\">Nutzungsbedingungen</a> und unsere <a href=\"{1}\">Datenschutzrichtlinie überarbeitet.</a>Wir benötigen Deine Zustimmung dazu, dass die Spotify GmbH Deine Vertragsbeziehung an Spotify AB, Birger Jarlsgatan 61, 113 56 Stockholm, Schweden überträgt.</p><p>Du kannst den Spotify-Dienst bis zum {2} über die bestehende Vertragsbeziehung weiter nutzen. Nach diesem Datum musst Du zur weiteren Nutzung des Spotify-Dienstes den neuen Nutzungsbedingungen sowie den Datenschutzrichtlinien zustimmen. Durch Deinen Klick auf &quot;Annehmen&quot; stimmst du</p><p>a) der Übertragung deiner Vertragsbeziehung von der Spotify GmbH an Spotify AB zu, und akzeptierst <br />b) die Aktualisierung der Nutzungsbedingungen, sowie <br />c) die Sammlung, Verarbeitung und Nutzung Deiner personenbezogenen Daten entsprechend der Abschnitt 4, 5 und 7 der Datenschutzrichtlinie.</p>",
  "tos.not_now_text2_germany": "<p>Du kannst Spotify bis zum {0} weiter nutzen, ohne die aktualisierten Nutzungsbedingungen und die Datenschutzrichtlinie zu akzeptieren. Ab diesem Datum musst Du die neuen Bedingungen akzeptieren, um Spotify weiter nutzen zu können. Wenn Du Premium Benutzer bist, wird Dir dieser Dienst auch weiterhin monatlich entsprechend Deines normalen Abrechnungszeitraums in Rechnung gestellt, bis Du Dein Abonnement kündigst. Wenn Du Spotify nicht mehr bezahlen möchtest, kannst Du Dein Abonnement jederzeit über Deine Spotify Abonnementseite beenden.</p>",
  "tos.not_now_expired_text_germany": "<p>Wir haben unsere <a href=\"{0}\">Nutzungsbedingungen</a> und unsere <a href=\"{1}\">Datenschutzrichtlinie</a>überarbeitet.</p><p>Die Spotify GmbH beabsichtigt, Deine Vertragsbeziehung an Spotify AB, Birger Jarlsgatan 61, 113 56 Stockholm, Schweden zu übertragen.</p><p>Um den Spotify-Dienst weiter nutzen zu können, musst Du den neuen Nutzungsbedingungen sowie den Datenschutzrichtlinien zustimmen. Durch Deinen Klick auf &quot;Annehmen&quot; stimmst du</p><p>a) der Übertragung deiner Vertragsbeziehung von der Spotify GmbH an Spotify AB zu, und akzeptierst <br />b) die Aktualisierung der Nutzungsbedingungen, sowie <br/>c) die Sammlung, Verarbeitung und Nutzung Deiner personenbezogenen Daten entsprechend der Abschnitt 4, 5 und 7 der Datenschutzrichtlinie.</p>",
  "tos.back_button_label": "Zurück",
  "tos.ok_button_label": "OK",
  "tos.agree_button_label": "Akzeptieren",
  "tos.cancel_button_label": "Ablehnen",
  "tos.not_now_button_label": "Nicht jetzt",
  "licenses.modal_title": "Drittanbieter-Lizenzen",
  "licenses.close_button_label": "Schließen",
  "feedback.beta_title": "Betaversion",
  "feedback.beta_text": "Was magst Du und was nicht? Sag es uns.",
  "market.ad": "Andorra",
  "market.ar": "Argentinien",
  "market.at": "Österreich",
  "market.au": "Australien",
  "market.be": "Belgien",
  "market.bg": "Bulgarien",
  "market.bo": "Bolivien",
  "market.br": "Brasilien",
  "market.ca": "Kanada",
  "market.ch": "Schweiz",
  "market.cl": "Chile",
  "market.co": "Kolumbien",
  "market.cr": "Costa Rica",
  "market.cy": "Zypern",
  "market.cz": "Tschechische Republik",
  "market.de": "Deutschland",
  "market.dk": "Dänemark",
  "market.do": "Dominikanische Republik",
  "market.ec": "Ecuador",
  "market.ee": "Estland",
  "market.es": "Spanien",
  "market.fi": "Finnland",
  "market.fr": "Frankreich",
  "market.gr": "Griechenland",
  "market.gt": "Guatemala",
  "market.hk": "Hongkong",
  "market.hn": "Honduras",
  "market.hu": "Ungarn",
  "market.ie": "Irland",
  "market.is": "Island",
  "market.it": "Italien",
  "market.jp": "Japan",
  "market.li": "Liechtenstein",
  "market.lt": "Litauen",
  "market.lu": "Luxemburg",
  "market.lv": "Lettland",
  "market.mc": "Monaco",
  "market.mt": "Malta",
  "market.mx": "Mexiko",
  "market.my": "Malaysia",
  "market.ni": "Nicaragua",
  "market.nl": "Niederlande",
  "market.no": "Norwegen",
  "market.nz": "Neuseeland",
  "market.pa": "Panama",
  "market.pe": "Peru",
  "market.ph": "Philippinen",
  "market.pl": "Polen",
  "market.pt": "Portugal",
  "market.py": "Paraguay",
  "market.se": "Schweden",
  "market.sg": "Singapur",
  "market.sk": "Slowakei",
  "market.sv": "El Salvador",
  "market.tr": "Türkei",
  "market.tw": "Taiwan",
  "market.uk": "Großbritannien",
  "market.us": "USA",
  "market.uy": "Uruguay",
  "market.za": "Südafrika",
  "sTitle": "Teile deine Ansichten und hilf uns dabei, den besten Musik-Service der Welt zu schaffen!",
  "sQ1Question": "Wie wahrscheinlich ist es, dass du Spotify einem Freund oder Kollegen empfiehlst?",
  "sQ1Negative": "Sehr unwahrscheinlich",
  "sQ1Positive": "Sehr wahrscheinlich",
  "sQ2Question": "Warum denkst du so?",
  "sQ3Question": "Im Großen und Ganzen, wie zufrieden bist du mit Spotify?",
  "sQ3Negative": "Sehr unzufrieden",
  "sQ3Positive": "Sehr zufrieden",
  "sSubmit": "Umfrage abschließen",
  "sThanks": "Danke für deine Hilfe. Wir wissen es zu schätzen, dass du dir Zeit genommen hast.",
  "sTeam": "Dein Spotify Team",
  "sClose": "Schließen",
  "cls.highlight": "Premium wurde pausiert",
  "cls.title": "Deine letzte Zahlung hat nicht geklappt.",
  "cls.desc": "Höre weiterhin mit Premium, indem Du eine neue Zahlungsmethode hinzufügst. Es dauert nur einen Moment.",
  "cls.updatePayment": "Zahlung aktualisieren",
  "cls.cancelSubscription": "Du kannst auch ein Downgrade auf Spotify Free ausführen,<br>indem Du <a class=\"cancel-sub\" href=\"#cancel\">Dein Premium Abonnement stornierst</a>.",
  "capping.upsell-title": "Du hast Dein Kontingent an kostenlosem Musikgenuss aufgebraucht.",
  "capping.upsell-message": "Du kannst jeden Monat 15 Stunden kostenlos Musik hören.<br />Mit dem Upgrade auf Premium kannst Du unbegrenzt Musik ohne Werbeunterbrechungen hören.",
  "capping.upsell-button-label": "Auf Spotify Premium upgraden",
  "capping.defaultRefillMessage": "Schon bald kannst Du länger kostenlos Musik hören.",
  "capping.refillMessage": "Nach einer Umstellung innerhalb der nächsten {0} Tage kannst Du länger kostenlos Musik hören.",
  "capping.welcome-title": "Willkommen bei Spotify.",
  "capping.welcome-message": "Du kannst jeden Monat 15 Stunden kostenlos Musik hören.<br> <a data-action={0}>Mit dem Upgrade auf Premium kannst Du</a> unbegrenzt Musik ohne Werbeunterbrechungen hören.",
  "capping.welcome-message-button-label": "Los geht's",
  "yourArtistsTooltipTitle": "Deine Künstler verwalten",
  "yourArtistsTooltipText": "Du kannst das Bild eines Künstlerprofils auf Spotify nun ganz einfach bearbeiten.",
  "yourArtists": "Deine Künstler"
};
},{}],2:[function(require,module,exports){
module.exports = {
  "browse.app_name": "Περιήγηση",
  "latest-releases.app_name": "Τελευταίες κυκλοφορίες",
  "discover.app_name": "Ανακάλυψε",
  "activity.app_name": "Δραστηριότητα",
  "radio.app_name": "Ραδιόφωνο",
  "settings.app_name": "Ρυθμίσεις",
  "messages.app_name": "Μηνύματα",
  "profile.app_name": "Προφίλ",
  "notifications_center.app_name": "Ειδοποιήσεις",
  "concerts.app_name": "Συναυλίες",
  "profile.private_session": "Ιδιωτική περίοδος σύνδεσης",
  "profile.upgrade": "Αναβάθμιση",
  "profile.upgrade_account": "Αναβάθμιση του λογαριασμού σου",
  "profile.upgrade_tooltip": "Αναβάθμιση σε Premium",
  "profile.account": "Λογαριασμός",
  "profile.logout": "Αποσύνδεση",
  "profile.enabled": "Eνεργοποιήθηκε",
  "profile.menu_label": "Μενού",
  "profile.switch": "Αλλαγή χρήστη",
  "profile.new_user": "Αλλαγή σε νέο χρήστη",
  "your_music.app_name": "Η Μουσική σου",
  "your_music.songs": "Τραγούδια",
  "your_music.artists": "Καλλιτέχνες",
  "your_music.albums": "Άλμπουμ",
  "your_music.stations": "Σταθμοί",
  "your_music.local_files": "Τοπικά αρχεία",
  "sidebar.title_main": "ΤΑ ΒΑΣΙΚΑ",
  "sidebar.title_playlists": "Λίστες",
  "new_playlist.input_placeholder": "Νέα λίστα",
  "new_playlist.button": "Νέα λίστα",
  "accessibilitylinks.skip_to_content_label": "Παράλειψη και μετάβαση προς το βασικό περιεχόμενο",
  "accessibilitylinks.skip_to_player_label": "Παράλειψη και μετάβαση προς τα στοιχεία ελέγχου του συστήματος αναπαραγωγής",
  "playlist.by": "από {0}",
  "playlist.loading": "Φόρτωση...",
  "playlist.newfolder": "Νέος φάκελος",
  "playlist.delete_message": "Θέλεις πραγματικά να διαγράψεις αυτή τη λίστα;",
  "playlist.unfollow_message": "Θέλεις πραγματικά να σταματήσεις να ακολουθείς αυτή τη λίστα;",
  "playlistfolder.delete_message": "Θέλεις πραγματικά να διαγράψεις αυτό τον φάκελο και όλες τις λίστες που περιέχει;",
  "playlist.delete_confirm": "Διαγραφή",
  "playlist.unfollow_confirm": "Άρση ακολούθησης",
  "playlist.delete_cancel": "Ακύρωση",
  "playlist.duplicates_dialog_title": "Διπλά τραγούδια",
  "playlist.duplicates_dialog_title_single": "Διπλό τραγούδι",
  "playlist.duplicates_dialog_body": "Κάποια από αυτά τα τραγούδια υπάρχουν ήδη στη λίστα σου.",
  "playlist.duplicates_dialog_body_single": "Αυτό το τραγούδι υπάρχει ήδη στη λίστα σου.",
  "playlist.duplicates_dialog_button_add": "Προσθήκη όλων",
  "playlist.duplicates_dialog_button_add_single": "Να γίνει η προσθήκη",
  "playlist.duplicates_dialog_button_skip_duplicates": "Παράλειψη διπλών",
  "playlist.duplicates_dialog_button_skip_single": "Παράλειψη διπλού",
  "playlist.annotate_form.new_playlist_name": "Νέα λίστα",
  "playlist.annotate_form.create_title": "Δημιουργία λίστας",
  "playlist.annotate_form.create": "Δημιουργία",
  "playlist.annotate_form.cancel": "Ακύρωση",
  "playlist.annotate_form.edit_title": "Επεξεργασία στοιχείων λίστας",
  "playlist.annotate_form.save": "Αποθήκευση",
  "playlist.annotate_form.name_field_label": "Όνομα",
  "playlist.annotate_form.name_field_placeholder": "Όνομα λίστας",
  "playlist.annotate_form.image_field_label": "Εικόνα",
  "playlist.annotate_form.image_pick_button_label": "Επιλογή εικόνας",
  "playlist.annotate_form.image_replace_button_label": "Αντικατάσταση εικόνας",
  "playlist.annotate_form.image_remove_button_label": "Αφαίρεση εικόνας",
  "playlist.annotate_form.image_file_size_exceeded": "Υπερβολικά μεγάλο μέγεθος εικόνας, μέγιστο επιτρεπτό: 4 MB.",
  "playlist.annotate_form.image_file_upload_failed": "Αδυναμία αποστολής εικόνας, δοκίμασε ξανά.",
  "playlist.annotate_form.annotate_failed": "Αδυναμία ενημέρωσης περιγραφής και εικόνας, δοκίμασε ξανά.",
  "playlist.annotate_form.close-error-bar": "Απόκρυψη",
  "playlist.annotate_form.description_field_label": "Περιγραφή",
  "playlist.annotate_form.description_field_placeholder": "Δώσε μια «πιασάρικη» περιγραφή στη λίστα σου.",
  "playlist.annotate_form.permission_message": "Εάν συνεχίσεις, δίνεις τη συγκατάθεσή σου για να έχει το Spotify πρόσβαση στην εικόνα που επιλέγεις να ανεβάσεις. Βεβαιώσου ότι έχεις δικαίωμα να ανεβάσεις την εικόνα. Θα χρησιμοποιήσουμε την εικόνα σου μόνο ως εξώφυλλο σε playlist.",
  "playlist.annotate_form.insert_link_button_label": "Εισαγωγή συνδέσμου",
  "playlist.annotate_form.insert_link.link_field_label": "Σύνδεσμος προς",
  "playlist.annotate_form.insert_link.change_button_label": "Αλλαγή",
  "playlist.annotate_form.insert_link.remove_button_label": "Αφαίρεση",
  "playlist.annotate_form.insert_link.done_button_label": "Τέλος",
  "playlist.annotate_form.drop_to_set_image_label": "Απόθεση για ορισμό εικόνας",
  "playlist.annotate_form.drop_not_allowed_label": "Μορφή που δεν υποστηρίζεται",
  "playlist.annotate_form.error.file_not_valid_jpg": "Αυτό το αρχείο στην πραγματικότητα δεν είναι έγκυρο αρχείο JPG, παρότι το όνομά του δείχνει το αντίθετο.",
  "playlist.annotate_form.error.name_required": "Πρέπει να δώσεις ένα όνομα στη λίστα σου.",
  "playlist.annotate_form.error.selection_required_to_insert_link": "Πρέπει να επιλέξεις το κείμενο που θέλεις να μετατρέψεις σε σύνδεσμο.",
  "playlist.annotate_form.error.html_not_allowed": "Φαίνεται ότι προσπαθείς να χρησιμοποιήσεις το HTML, όμως αυτό δεν είναι δυνατόν.",
  "playlist.annotate_form.error.submit": "Δεν ήταν δυνατή η αποθήκευση των αλλαγών στις λίστες. Δοκίμασε ξανά.",
  "playlist.annotate_form.error.image_too_small": "Αυτή η εικόνα είναι πολύ μικρή. Πρέπει να είναι τουλάχιστον {0}x{1}.",
  "playlist.annotate_form.warning.client_offline": "Δεν βρέθηκε σύνδεση στο διαδίκτυο. Οι αλλαγές στην περιγραφή και την εικόνα δεν θα αποθηκευτούν.",
  "playlist.annotate_form.warning.no_line_breaks_in_description": "Δυστυχώς, οι αλλαγές γραμμής δεν υποστηρίζονται στην περιγραφή.",
  "playlist.annotate_form.warning.unsaved_changes": "Θέλεις να αποθηκεύσεις τις αλλαγές σου;",
  "navigation.label": "Πλοήγηση",
  "navigation.back_button_label": "Μετάβαση προς τα πίσω",
  "navigation.forward_button_label": "Μετάβαση προς τα εμπρός",
  "search.input_placeholder": "Αναζήτηση",
  "player.label": "Στοιχεία ελέγχου προγράμματος αναπαραγωγής",
  "player.shuffle_mode_label": "Τυχαία σειρά",
  "player.repeat_mode_label": "Επανάληψη",
  "player.queue": "Ουρά",
  "player.volume_button_label": "Ένταση ήχου",
  "player.spotify_connect": "Spotify Connect",
  "player.connect_button_label": "Σύνδεση σε συσκευή",
  "player.lyrics_label": "Στίχοι",
  "player.play_button_label": "Αναπαραγωγή",
  "player.pause_button_label": "Παύση",
  "player.previous_button_label": "Προηγούμενο",
  "player.next_button_label": "Επόμενο",
  "player.offline_label": "Εκτός σύνδεσης",
  "player.thumb_up_label": "Επιδοκιμασία",
  "player.thumb_down_label": "Αποδοκιμασία",
  "playererror.default": "Προέκυψε πρόβλημα κατά την προσπάθεια αναπαραγωγής του επιλεγμένου τραγουδιού",
  "playererror.track_not_available": "Αυτό το τραγούδι δεν είναι διαθέσιμο",
  "nowplaying.label": "Τώρα ακούς",
  "nowplaying.go_to_context": "Μετάβαση στο Τι παίζει",
  "nowplaying.save_your_music": "Αποθήκευση στη Mουσική σου",
  "nowplaying.remove_your_music": "Αφαίρεση από τη Mουσική σου",
  "nowplaying.playing_suggested_track": "Αναπαραγωγή προτεινόμενου τραγουδιού",
  "connect.connect_text": "Σύνδεση σε συσκευή",
  "connect.device_connecting": "Σύνδεση…",
  "connect.device_incompatible": "Μη συμβατή",
  "connect.device_premium_only": "Μόνο για χρήστες Premium",
  "connect.device_sleeping": "Η συσκευή «κοιμάται»",
  "connect.device_tech_cast": "Μετάδοση Google",
  "connect.device_tech_connect": "Spotify Connect",
  "connect.device_this_computer": "Αυτόν τον υπολογιστή",
  "connect.device_unavailable_for_playback": "Δεν είναι διαθέσιμο για ακρόαση σε",
  "connect.device_unknown": "Άγνωστη συσκευή",
  "connect.device_unsupported_uri": "Δεν είναι δυνατή αυτή η αναπαραγωγή τώρα",
  "connect.devices_available": "Διαθέσιμες συσκευές",
  "connect.dismiss": "Απόρριψη",
  "connect.help1": "Το Connect σου επιτρέπει να ακούς μουσική και να ελέγχεις το Spotify στις συσκευές σου.",
  "connect.help2": "Εκκίνησε το Spotify σε άλλη συσκευή και θα εμφανιστεί εδώ ως διά μαγείας.",
  "connect.help_hint": "Τι είναι το Connect;",
  "connect.offline": "Μη διαθέσιμο",
  "connect.offline_reason_computer": "Το Spotify δεν είναι ενεργό σε αυτή τη συσκευή.",
  "connect.offline_reason_generic": "Το Spotify δεν είναι ενεργό σε αυτή τη συσκευή.",
  "connect.offline_reason_phone": "Το τηλέφωνο είναι κλειδωμένο ή το Spotify δεν είναι στο προσκήνιο.",
  "connect.offline_reason_gameconsole": "Χρησιμοποίησε τις ρυθμίσεις ενεργοποίησης της εφαρμογής Spotify PlayStation, ώστε να είναι δυνατή η έξοδος του PlayStation από την κατάσταση αναμονής.",
  "connect.offline_text1": "Για να χρησιμοποιήσεις αυτή τη δυνατότητα, πρέπει να συνδεθείς στο διαδίκτυο.",
  "connect.offline_title": "Είσαι εκτός σύνδεσης!",
  "connect.playingon": "Ακούς από:",
  "connect.popup_title": "Συσκευές",
  "connect.remoteplayback": "Ακούς από: {0}",
  "connect.show_more": "Εμφάνιση περισσότερων",
  "connect.upgrade": "Αναβάθμιση",
  "connect.upsell": "Το Connect είναι μια δυνατότητα του Premium που σου επιτρέπει να ακούς μουσική και να ελέγχεις το Spotify στις συσκευές σου.",
  "contextmenu.new-playlist": "Νέα λίστα",
  "contextmenu.add-to-playlist": "Προσθήκη στη λίστα",
  "contextmenu.owner-playlist": "από {0}",
  "contextmenu.copy-uri": "Αντιγραφή URI Spotify",
  "contextmenu.copy-artist-url": "Αντιγραφή συνδέσμου καλλιτέχνη",
  "contextmenu.copy-album-url": "Αντιγραφή συνδέσμου άλμπουμ",
  "contextmenu.copy-track-url": "Αντιγραφή συνδέσμου τραγουδιού",
  "contextmenu.copy-playlist-url": "Αντιγραφή συνδέσμου λίστας",
  "contextmenu.copy-profile-url": "Αντιγραφή συνδέσμου προφίλ",
  "contextmenu.copy-station-url": "Αντιγραφή συνδέσμου σταθμού",
  "contextmenu.copy-chart-url": "Αντιγραφή συνδέσμου chart",
  "contextmenu.copy-url": "Αντιγραφή συνδέσμου",
  "contextmenu.copy-embed": "Αντιγραφή κώδικα ενσωμάτωσης",
  "contextmenu.collaborative": "Συλλογική λίστα",
  "contextmenu.save": "Αποθήκευση στη Mουσική σου",
  "contextmenu.remove": "Αφαίρεση από τη Mουσική σου",
  "contextmenu.delete-playlist": "Διαγραφή",
  "contextmenu.follow": "Ακολούθησε",
  "contextmenu.unfollow": "Άρση ακολούθησης",
  "contextmenu.publish": "Να γίνει δημόσιο",
  "contextmenu.unpublish": "Να γίνει μυστικό",
  "contextmenu.playlist.loading": "Φόρτωση...",
  "contextmenu.play": "Αναπαραγωγή",
  "contextmenu.add-to-queue": "Προσθήκη στην ουρά",
  "contextmenu.station": "Μετάβαση στο Ραδιόφωνο",
  "contextmenu.station-album": "Μετάβαση στο Ραδιόφωνο άλμπουμ",
  "contextmenu.station-artist": "Μετάβαση στο Ραδιόφωνο καλλιτέχνη",
  "contextmenu.station-playlist": "Μετάβαση στο Ραδιόφωνο λίστας",
  "contextmenu.station-track": "Μετάβαση στο Ραδιόφωνο τραγουδιών",
  "contextmenu.station-chart": "Μετάβαση στο ράδιο chart ",
  "contextmenu.remove-from-playlist": "Αφαίρεση από αυτή τη λίστα",
  "contextmenu.remove-from-queue": "Αφαίρεση από την ουρά",
  "contextmenu.rename-folder": "Μετονομασία",
  "contextmenu.rename-playlist": "Μετονομασία",
  "contextmenu.edit-playlist": "Επεξεργασία στοιχείων",
  "contextmenu.report-playlist": "Αναφορά",
  "contextmenu.report-asset": "Αναφορά",
  "contextmenu.share": "Κοινοποίηση...",
  "contextmenu.share-lyrics": "Κοινοποίηση στίχων",
  "contextmenu.create-folder": "Δημιουργία φακέλου",
  "contextmenu.create-playlist": "Δημιουργία λίστας",
  "contextmenu.open-localfile-folder": "Άνοιγμα φακέλου που το περιέχει",
  "contextmenu.open-localfile-folder-mac": "Αποκάλυψη στην Εύρεση",
  "contextmenu.offline": "Διαθέσιμο εκτός σύνδεσης",
  "contextmenu.goto-artist": "Μετάβαση στον καλλιτέχνη",
  "contextmenu.goto-album": "Μετάβαση στο άλμπουμ",
  "usermessage.default-message": "Προέκυψε σφάλμα",
  "usermessage.update-ready": "Γεια χαρά. Έχουμε ετοιμάσει μια νέα έκδοση του Spotify για σένα. <a href=\"#\" data-action=\"{0}\">Κάνε επανεκκίνηση τώρα</a> για να γίνει δική σου.",
  "usermessage.update-ready-simple": "Γεια χαρά. Έχουμε ετοιμάσει μια νέα έκδοση του Spotify για σένα. Κάνε επανεκκίνηση τώρα για να γίνει δική σου.",
  "usermessage.play-token-lost": "Το Spotify σταμάτησε γιατί ο λογαριασμός σου χρησιμοποιείται κάπου αλλού.",
  "usermessage.playback-paused-inactive": "Ο υπολογιστής σου ήταν ανενεργός για μεγάλο χρονικό διάστημα. Πάτησε «play» για να συνεχίσεις την ακρόαση! Για μουσική χωρίς διακοπές, γίνε συνδρομητής του <a href=\"#\" data-action=\"{0}\">Spotify Premium</a>.",
  "usermessage.not-available-offline": "Δεν ανιχνεύθηκε σύνδεση στο διαδίκτυο. Το Spotify θα προσπαθήσει αυτόματα να επανασυνδεθεί όταν ανιχνεύσει μια σύνδεση στο διαδίκτυο (κωδικός σφάλματος: 4)",
  "usermessage.track-not-available-in-region": "Αυτό το τραγουδι δεν είναι διαθέσιμο στο {0} αυτή τη στιγμή. Αν έχεις το αρχείο στον υπολογιστή σου, μπορείς να το εισαγάγεις.",
  "usermessage.track-not-available-in-region-generic": "Αυτό το τραγούδι δεν είναι διαθέσιμο στη χώρα σου αυτή τη στιγμή. Αν έχεις το αρχείο στον υπολογιστή σου, μπορείς να το εισαγάγεις.",
  "usermessage.track-not-available": "Αυτό το τραγούδι δεν είναι διαθέσιμο. Αν έχεις το αρχείο στον υπολογιστή σου, μπορείς να το εισαγάγεις.",
  "usermessage.track-not-available-forced-offline": "Απενεργοποίησε <a href=\"#\" data-action=\"goOnline\">τη λειτουργία εκτός σύνδεσης</a> και δοκίμασε ξανά.",
  "usermessage.track-exclusive-premium": "Αυτό το τραγούδι διατίθεται αποκλειστικά σε χρήστες του <a href=\"#\" data-action=\"{0}\">Spotify Premium</a> .",
  "usermessage.track-banned-by-artist": "Ο καλλιτέχνης/η εταιρεία επέλεξαν να σταματήσουν τη διάθεση αυτού του τραγουδιού. Αν έχεις το αρχείο στον υπολογιστή σου, μπορείς να το εισαγάγεις.",
  "usermessage.local-track-no-file": "Αυτό το τραγούδι προστέθηκε ως τοπικό αρχείο. Αν έχεις το αρχείο στον υπολογιστή σου, μπορείς να το εισαγάγεις.",
  "usermessage.local-track-file-not-found": "Δεν είναι δυνατή η αναπαραγωγή αυτού του τραγουδιού, επειδή δεν βρέθηκε το αρχείο. Κάνε ξανά εισαγωγή του αρχείου.",
  "usermessage.local-track-bad-format": "Άγνωστη μορφή αρχείου. Κάνε κλικ <a href=\"#\" data-action=\"{0}\">εδώ</a> για πληροφορίες.",
  "usermessage.capping-reached": "Έχεις υπερβεί το χρονικό όριό σου για {0} ώρα/ώρες. <a href=\"#\" data-action=\"{1}\">Αναβάθμισε σε Spotify Premium</a> για να ακούς μουσική χωρίς περιορισμούς.",
  "usermessage.local-track-drm-protected": "Δεν είναι δυνατή η αναπαραγωγή αυτού του τραγουδιού, επειδή το αρχείο προστατεύεται από τη διαχείριση ψηφιακών δικαιωμάτων (DRM). ",
  "usermessage.offline-disk-cache": "Η λήψη τραγουδιών εκτός σύνδεσης απέτυχε. Μήπως ο δίσκος είναι πλήρης;",
  "usermessage.offline-sync-expired": "Τα τραγούδια εκτός σύνδεσης έχουν λήξει. Πρέπει να συνδεθείς στο Spotify για να τα ενεργοποιήσεις ξανά.",
  "usermessage.offline-sync-failed": "Η λήψη ορισμένων τραγουδιών εκτός σύνδεσης απέτυχε.",
  "usermessage.offline-too-many-tracks": "Έχουν επιλεγεί πάρα πολλά τραγούδια για τη λειτουργία εκτός σύνδεσης.",
  "usermessage.offline-license-server-error": "Παρουσιάστηκε πρόβλημα με το διακομιστή του Spotify.",
  "usermessage.offline-license-lost": "Η πρόσβαση εκτός σύνδεσης για αυτόν τον υπολογιστή/για αυτή τη συσκευή έχει ανακληθεί.",
  "usermessage.offline-not-allowed": "Η λειτουργία εκτός σύνδεσης αποτελεί αποκλειστική δυνατότητα του <a href=\"#\" data-action=\"{0}\">Spotify Premium</a> .",
  "usermessage.language-changed": "Πρέπει να κάνεις <a href=\"#\" data-action=\"{0}\">επανεκκίνηση του Spotify</a> για να εφαρμοστεί η αλλαγή",
  "usermessage.proxysettings-changed": "Πρέπει να κάνεις <a href=\"#\" data-action=\"{0}\">επανεκκίνηση του Spotify</a> για να εφαρμοστεί η αλλαγή",
  "usermessage.language-changed-simple": "Πρέπει να επανεκκινήσεις το Spotify για να εφαρμοστεί η αλλαγή",
  "usermessage.proxysettings-changed-simple": "Πρέπει να επανεκκινήσεις το Spotify για να εφαρμοστεί η αλλαγή",
  "usermessage.cache-changed": "Πρέπει να κάνεις <a href=\"#\" data-action=\"{0}\">επανεκκίνηση του Spotify</a> για να εφαρμοστεί η αλλαγή",
  "usermessage.cache-changed-simple": "Πρέπει να επανεκκινήσεις το Spotify για να εφαρμοστεί η αλλαγή",
  "usermessage.feature-changed": "Πρέπει να κάνεις <a href=\"#\" data-action=\"{0}\">επανεκκίνηση του Spotify</a> για να εφαρμοστεί η αλλαγή",
  "usermessage.first-autostart": "Το Spotify άνοιξε αυτόματα, αλλά ελαχιστοποιήθηκε. Εάν θέλεις, μπορείς να <a href=\"#\" data-action=\"{0}\">ανοίγεις αυτόματα το Spotify χωρίς να ελαχιστοποιείται το παράθυρο</a> ή <a href=\"#\" data-action=\"{1}\">να επιλέξεις να μην ανοίγει το Spotify καθόλου</a> κατά την έναρξη.",
  "usermessage.cant-play-track": "Δεν είναι δυνατή η αναπαραγωγή του τρέχοντος τραγουδιού.",
  "usermessage.cant-skip-ads": "Το επιλεγμένο τραγούδι θα ακουστεί μετά τη διαφήμιση",
  "usermessage.cant-offline-playlists": "Η λειτουργία εκτός σύνδεσης αποτελεί αποκλειστική δυνατότητα του Premium. <a href=\"#\" data-action=\"{0}\">Απόκτησε το Premium</a>.",
  "usermessage.cant-set-high-quality-streaming": "Αυτή είναι μια αποκλειστική δυνατότητα του Premium. <a href=\"#\" data-action=\"{0}\">Απόκτησε το Premium</a>.",
  "usermessage.payment-state-creditcard-funds": "Δεν καταφέραμε να ανανεώσουμε τη συνδρομή σου λόγω κάποιου προβλήματος στην πληρωμή. Βεβαιώσου ότι ο λογαριασμός σου έχει το απαιτούμενο ποσό ή <a href=\"#\" data-action=\"{0}\">ενημέρωσε τα στοιχεία πληρωμής σου</a>.",
  "usermessage.payment-state-creditcard-refused": "Δεν καταφέραμε να ανανεώσουμε τη συνδρομή σου λόγω κάποιου προβλήματος στην πληρωμή. Για να διατηρήσεις τη συνδρομή σου, <a href=\"#\" data-action=\"{0}\">ενημέρωσε τα στοιχεία πληρωμής σου</a>.",
  "usermessage.payment-state-paypal-refused": "Δεν καταφέραμε να ανανεώσουμε τη συνδρομή σου λόγω κάποιου προβλήματος στην πληρωμή. Για να διατηρήσεις τη συνδρομή σου, <a href=\"#\" data-action=\"{0}\">ενημέρωσε τα στοιχεία πληρωμής σου</a>.",
  "usermessage.payment-state-creditcard-expiry": "Η κάρτα πληρωμής που χρησιμοποιείς λήγει σε λίγες μέρες. Για να διατηρήσεις τη συνδρομή σου, <a href=\"#\" data-action=\"{0}\">ενημέρωσε τα στοιχεία πληρωμής σου</a>.",
  "usermessage.payment-state-prepaid-expiry": "Η προπληρωμένη συνδρομή σου πρόκειται να λήξει. Μην ανησυχείς, όμως. <a href=\"#\" data-action=\"{0}\">Πάτα εδώ για εγγραφή στο Premium</a>.",
  "usermessage.payment-state-churn-payment": "Δυστυχώς, δεν καταφέραμε να εισπράξουμε την πληρωμή σου, και αναγκαστήκαμε να ακυρώσουμε τη συνδρομή σου. Μην ανησυχείς, όμως. <a href=\"#\" data-action=\"{0}\">Πάτα εδώ για ανανέωση της συνδρομής σου</a>.",
  "usermessage.payment-state-churn-partner": "Η συνδρομή σου σε κάποιον από τους συνεργάτες μας μόλις έληξε, επομένως χρησιμοποιείς τώρα πια το Spotify Free. Μην ανησυχείς, όμως. Υπάρχει λύση. <a href=\"#\" data-action=\"{0}\">Πάτα εδώ για επιστροφή στο Premium</a>.",
  "usermessage.opt-in-trial": "Ελπίζουμε να απολαμβάνεις τη δωρεάν δοκιμή σου! Για να μη χάσεις το Premium όταν λήξει η δοκιμή, <a href=\"#\" data-action=\"{0}\">κάνε εγγραφή ως συνδρομητής σήμερα</a>.",
  "usermessage.opt-in-trial-expired": "Η δωρεάν δοκιμή σου έληξε, επομένως χρησιμοποιείς τώρα πια το Spotify Free. Μην ανησυχείς, όμως. Υπάρχει λύση. <a href=\"#\" data-action=\"{0}\">Πάτα εδώ για επιστροφή στο Premium</a>.",
  "usermessage.hardware-acceleration-changed": "Πρέπει να κάνεις <a href=\"#\" data-action=\"{0}\">επανεκκίνηση του Spotify</a> για να εφαρμοστεί η αλλαγή",
  "usermessage.hardware-acceleration-changed-simple": "Πρέπει να επανεκκινήσεις το Spotify για να εφαρμοστεί η αλλαγή",
  "usermessage.some-local-tracks-not-saved": "Ορισμένα από τα επιλεγμένα τραγούδια δεν αποθηκεύτηκαν στη Μουσική σου. Τα τοπικά αρχεία δεν υποστηρίζονται από την ενότητα η Μουσική σου.",
  "usermessage.illegal-playlist-name-entered": "Το όνομα λίστας που πληκτρολόγησες δεν είναι έγκυρο.",
  "usermessage.playlist-save-failed-unknown": "Δεν ήταν δυνατή η αποθήκευση της λίστας λόγω άγνωστου σφάλματος.",
  "usermessage.social-error-permissions": "Κάνε κλικ <a href=\"#\" data-action=\"{0}\">εδώ</a> για να μπορείς να κοινοποιείς τις μουσικές σου δραστηριότητες στο Facebook.",
  "usermessage.shuffle-unplayable-track": "<a href=\"#\" data-action=\"{0}\">Κάνε αναβάθμιση στο Premium </a> για να ακούς όποιο τραγούδι θέλεις, όποτε θέλεις.",
  "usermessage.shuffle-ran-out-of-skips": "Σου τελείωσαν οι παραλείψεις (για αυτή την ώρα). <a href=\"#\" data-action=\"{0}\">Κάνε αναβάθμιση στο Premium</a> για να κάνεις παραλείψεις όσο συχνά θέλεις.",
  "usermessage.playlist-limit-exceeded": "Αυτή η λίστα έχει γεμίσει όσο δεν παίρνει. Εντυπωσιακό! Ξεκίνησε μια καινούργια λίστα για να συνεχίσεις να συλλέγεις μουσική.",
  "usermessage.collection-limit-exceeded": "Επική συλλογή. Εύγε. Η Μουσική σου, όμως, έφτασε στα όριά της. Για να αποθηκεύσεις περισσότερη μουσική, θα χρειαστεί να αφαιρέσεις κάποια τραγούδια.",
  "usermessage.deprecating-os-version": "Την προσοχή σου! Σε μια από τις επόμενες εκδόσεις, θα σταματήσουμε να παρέχουμε υποστήριξη για το λειτουργικό σύστημα που χρησιμοποιείς. Κάνε κλικ <a href=\"#\" data-action=\"{0}\">εδώ</a> για περισσότερες πληροφορίες.",
  "usermessage.image-upload-propagation": "Επιτυχία! (Μπορεί να χρειαστούν έως και 24 ώρες για τη μετάδοση των εικόνων)",
  "usermessage.approaching-capping-limit": "Σου απομένει λιγότερο από 1 ώρα δωρεάν ακρόασης. Απόλαυσε 15 ώρες δωρεάν ακρόασης κάθε μήνα ή <a href=\"#\" data-action=\"{0}\">κάνε αναβάθμιση στο Premium</a> για να ακούς μουσική απεριόριστα. <a href=\"#\" data-action=\"{1}\">Μάθε περισσότερα</a>.",
  "usermessage.half-capping-limit-passed": "Έχεις χρησιμοποιήσει τον μισό από το μηνιαίο χρόνο σου. Απόλαυσε 15 ώρες δωρεάν ακρόασης κάθε μήνα ή <a href=\"#\" data-action=\"{0}\">κάνε αναβάθμιση στο Premium</a> για να ακούς μουσική απεριόριστα. <a href=\"#\" data-action=\"{1}\">Μάθε περισσότερα</a>.",
  "usermessage.video-georestricted": "Δεν είναι δυνατή η αναπαραγωγή αυτού του βίντεο στην τοποθεσία που βρίσκεσαι αυτή τη στιγμή.",
  "usermessage.video-unsupported-client-version": "Κάνε αναβάθμιση στο Spotify για να μπορέσεις να δεις αυτό το βίντεο.",
  "usermessage.video-unsupported-platform-version": "Δεν είναι δυνατή η αναπαραγωγή αυτού του βίντεο με την έκδοση λειτουργικού συστήματος που χρησιμοποιείς.",
  "usermessage.video-country-restricted": "Δεν είναι δυνατή η αναπαραγωγή αυτού του βίντεο στην τοποθεσία που βρίσκεσαι αυτή τη στιγμή.",
  "usermessage.video-unavailable": "Αυτό το βίντεο δεν είναι διαθέσιμο. Θες να δοκιμάσεις ένα άλλο;",
  "usermessage.video-catalogue-restricted": "Δυστυχώς, δεν είναι δυνατή η αναπαραγωγή αυτού του βίντεο.",
  "usermessage.video-playback-error": "Δυστυχώς, δεν είναι δυνατή η αναπαραγωγή αυτού του βίντεο.",
  "about.title_label": "Σχετικά με το Spotify",
  "about.close_button_label": "Κλείσιμο",
  "offline-progress-msg": "Συγχρονισμός εκτός σύνδεσης: {0} από {1} τραγούδια",
  "tos.updated_terms": "Ενημερωμένοι όροι",
  "tos.modal_title": "Όροι και Προϋποθέσεις Χρήσης του Spotify",
  "tos.tos_text": "<p>Έχουμε αναθεωρήσει τους <a href=\"{0}\">Όρους και προϋποθέσεις χρήσης</a> και την <a href=\"{1}\">Πολιτική Απορρήτου</a> της εταιρείας μας.</p><p>Εάν συνεχίσεις να χρησιμοποιείς το Spotify, αποδέχεσαι αυτούς τους ενημερωμένους όρους, γι' αυτό αφιέρωσε λίγα λεπτά για να τους διαβάσεις και να τους καταλάβεις.</p>",
  "tos.not_now_tos_text": "<p>Έχουμε αναθεωρήσει τους <a href=\"{0}\">Όρους και Προϋποθέσεις Χρήσης</a> και την <a href=\"{1}\">Πολιτική Απορρήτου</a> της εταιρείας μας.</p><p>Εάν κάνεις κλικ στο «Αποδοχή», συμφωνείς με αυτές τις ενημερώσεις (και την επεξεργασία των δεδομένων σου που περιγράφεται), γι' αυτό αφιέρωσε λίγα λεπτά για να τις διαβάσεις και να τις καταλάβεις.</p>",
  "tos.tos_text2": "<p>Εάν δεν θέλεις πλέον να χρησιμοποιείς το Spotify, μπορείς να ακυρώσεις τη συνδρομή σου μεταβαίνοντας στη σελίδα συνδρομής σου στο Spotify.</p>",
  "tos.not_now_text": "<p>Μπορείς να συνεχίσεις να χρησιμοποιείς το Spotify για {0} ημέρες χωρίς να αποδεχθείς τους ενημερωμένους Όρους και Προϋποθέσεις και την Πολιτική Απορρήτου. Τη συγκεκριμένη ημερομηνία, θα πρέπει να αποδεχθείς τους νέους όρους προκειμένου να συνεχίσεις να χρησιμοποιείς το Spotify. Εάν δεν ακυρώσεις τη συνδρομή σου, θα συνεχίσεις να χρεώνεσαι μηνιαίως σύμφωνα με τον τακτικό κύκλο χρέωσής σου. Εάν δεν θέλεις να χρεωθείς ξανά από τη Spotify, μπορείς να ακυρώσεις τη συνδρομή σου ανά πάσα στιγμή μεταβαίνοντας στη σελίδα συνδρομής σου στο Spotify.</p>",
  "tos.not_now_last_day_text": "<p>Μπορείς να συνεχίσεις να χρησιμοποιείς το Spotify για 1 ημέρα χωρίς να αποδεχθείς τους ενημερωμένους Όρους και Προϋποθέσεις και την Πολιτική Απορρήτου. Εάν δεν αποδεχθείς τους νέους όρους μέχρι εκείνη τη στιγμή, δεν θα μπορείς πλέον να χρησιμοποιείς το Spotify. Εάν δεν ακυρώσεις τη συνδρομή σου, θα συνεχίσεις να χρεώνεσαι μηνιαίως σύμφωνα με τον τακτικό κύκλο χρέωσής σου. Εάν δεν θέλεις να χρεωθείς ξανά από τη Spotify, μπορείς να ακυρώσεις τη συνδρομή σου ανά πάσα στιγμή μεταβαίνοντας στη σελίδα συνδρομής σου στο Spotify.</p>",
  "tos.not_now_text_germany": "<p>Αναθεωρήσαμε τις ενότητες <a href=\"{0}\">Όροι και προϋποθέσεις χρήσης</a> και <a href=\"{1}\">Πολιτική απορρήτου</a>. Έχε υπ' όψιν ότι, με τη συγκατάθεσή σου, η Spotify GmbH προτίθεται να μεταβιβάσει το συμβόλαιό σου στην Spotify AB, Birger Jarlsgatan 61, 113 56 Στοκχόλμη, Σουηδία.</p><p>Μπορείς να συνεχίσεις να χρησιμοποιείς την υπηρεσία Spotify βάσει του υφιστάμενου συμβολαίου έως τις {2}. Μετά από αυτή την ημερομηνία, προκειμένου να μπορείς να συνεχίσεις να χρησιμοποιείς την υπηρεσία Spotify, θα πρέπει να αποδεχτείς τους νέους Όρους και προϋποθέσεις και την Πολιτική απορρήτου. Κάνοντας κλικ στο «Αποδοχή», δίνεις τη συγκατάθεσή σου για τα εξής:</p><p>α) τη μεταβίβαση του συμβολαίου σου από τη Spotify GmbH στη Spotify AB,<br />β) τις ενημερώσεις των Όρων και προϋποθέσεων χρήσης, και <br />γ) τη συλλογή, επεξεργασία και χρήση των προσωπικών σου δεδομένων, όπως περιγράφονται στις Ενότητες 4, 5, και 7 της Πολιτικής απορρήτου.</p>",
  "tos.not_now_text2_germany": "<p>Μπορείς να συνεχίσεις να χρησιμοποιείς το Spotify μέχρι τις {0} χωρίς να αποδεχθείς τους ενημερωμένους Όρους και προϋποθέσεις και την Πολιτική απορρήτου. Τη συγκεκριμένη ημερομηνία, θα πρέπει να αποδεχθείς τους νέους όρους προκειμένου να συνεχίσεις να χρησιμοποιείς το Spotify. Εάν είσαι χρήστης Premium, θα συνεχίσεις να χρεώνεσαι σε μηνιαία βάση σύμφωνα με τον τακτικό κύκλο χρέωσής σου, εκτός εάν θέλεις να ακυρώσεις τη συνδρομή σου. Εάν δεν θέλεις να χρεωθείς ξανά από τη Spotify, μπορείς να ακυρώσεις τη συνδρομή σου ανά πάσα στιγμή μεταβαίνοντας στη σελίδα συνδρομής σου στο Spotify.</p>",
  "tos.not_now_expired_text_germany": "<p>Αναθεωρήσαμε τις ενότητες <a href=\"{0}\">Όροι και προϋποθέσεις χρήσης</a> και <a href=\"{1}\">Πολιτική απορρήτου</a>.</p><p>Έχε υπ' όψιν ότι, με τη συγκατάθεσή σου, η Spotify GmbH προτίθεται να μεταβιβάσει το συμβόλαιό σου στην Spotify AB, Birger Jarlsgatan 61, 113 56 Στοκχόλμη, Σουηδία.</p><p>Προκειμένου να συνεχίσεις να χρησιμοποιείς την υπηρεσία Spotify, πρέπει να αποδεχτείς τους νέους Όρους και προϋποθέσεις και την Πολιτική απορρήτου. Κάνοντας κλικ στο «Αποδοχή», δίνεις τη συγκατάθεσή σου για τα εξής:</p><p>α) τη μεταβίβαση του συμβολαίου σου από τη Spotify GmbH στη Spotify AB,<br />β) τις ενημερώσεις των Όρων και προϋποθέσεων χρήσης, και <br />γ) τη συλλογή, επεξεργασία και χρήση των προσωπικών σου δεδομένων, όπως περιγράφονται στις Ενότητες 4, 5, και 7 της Πολιτικής απορρήτου.</p>",
  "tos.back_button_label": "Πίσω",
  "tos.ok_button_label": "Εντάξει",
  "tos.agree_button_label": "Αποδοχή",
  "tos.cancel_button_label": "Απόρριψη",
  "tos.not_now_button_label": "Όχι τώρα",
  "licenses.modal_title": "Άδειες τρίτων",
  "licenses.close_button_label": "Κλείσιμο",
  "feedback.beta_title": "Έκδοση beta",
  "feedback.beta_text": "Υπάρχει κάτι που λατρεύεις ή που βρίσκεις ενοχλητικό; Πες το μας.",
  "market.ad": "Ανδόρρα",
  "market.ar": "Αργεντινή",
  "market.at": "Αυστρία",
  "market.au": "Αυστραλία",
  "market.be": "Βέλγιο",
  "market.bg": "Βουλγαρία",
  "market.bo": "Βολιβία",
  "market.br": "Βραζιλία",
  "market.ca": "Καναδάς",
  "market.ch": "Ελβετία",
  "market.cl": "Χιλή",
  "market.co": "Κολομβία",
  "market.cr": "Κόστα Ρίκα",
  "market.cy": "Κύπρος",
  "market.cz": "Δημοκρατία της Τσεχίας",
  "market.de": "Γερμανία",
  "market.dk": "Δανία",
  "market.do": "Δομινικανή Δημοκρατία",
  "market.ec": "Εκουαδόρ",
  "market.ee": "Εσθονία",
  "market.es": "Ισπανία",
  "market.fi": "Φινλανδία",
  "market.fr": "Γαλλία",
  "market.gr": "Ελλάδα",
  "market.gt": "Γουατεμάλα",
  "market.hk": "Χονγκ Κονγκ",
  "market.hn": "Ονδούρα",
  "market.hu": "Ουγγαρία",
  "market.ie": "Ιρλανδία",
  "market.is": "Ισλανδία",
  "market.it": "Ιταλία",
  "market.jp": "Ιαπωνία",
  "market.li": "Λιχτενστάιν",
  "market.lt": "Λιθουανία",
  "market.lu": "Λουξεμβούργο",
  "market.lv": "Λετονία",
  "market.mc": "Μονακό",
  "market.mt": "Μάλτα",
  "market.mx": "Μεξικό",
  "market.my": "Μαλαισία",
  "market.ni": "Νικαράγουα",
  "market.nl": "Ολλανδία",
  "market.no": "Νορβηγία",
  "market.nz": "Νέα Ζηλανδία",
  "market.pa": "Παναμάς",
  "market.pe": "Περού",
  "market.ph": "Φιλιππίνες",
  "market.pl": "Πολωνία",
  "market.pt": "Πορτογαλία",
  "market.py": "Παραγουάη",
  "market.se": "Σουηδία",
  "market.sg": "Σιγκαπούρη",
  "market.sk": "Σλοβακία",
  "market.sv": "Ελ Σαλβαδόρ",
  "market.tr": "Τουρκία",
  "market.tw": "Ταϊβάν",
  "market.uk": "Ηνωμένο Βασίλειο",
  "market.us": "Ηνωμένες Πολιτείες",
  "market.uy": "Ουρουγουάη",
  "market.za": "Νότια Αφρική",
  "sTitle": "Μοιράσου τις σκέψεις σου και βοήθησέ μας να δημιουργήσουμε την καλύτερη υπηρεσία μουσικής στον κόσμο!",
  "sQ1Question": "Πόσο πιθανό είναι να προτείνεις το Spotify σε ένα φίλο ή συνάδελφο;",
  "sQ1Negative": "Καθόλου πιθανό",
  "sQ1Positive": "Εξαιρετικά πιθανό",
  "sQ2Question": "Γιατί έχεις αυτή την άποψη;",
  "sQ3Question": "Συνολικά, πόσο ικανοποιημένος είσαι με το Spotify;",
  "sQ3Negative": "Πολύ δυσαρεστημένος",
  "sQ3Positive": "Πολύ ικανοποιημένος",
  "sSubmit": "Υποβολή έρευνας",
  "sThanks": "Ευχαριστούμε πολύ για τη βοήθειά σου, και για το χρόνο που διέθεσες.",
  "sTeam": "Η ομάδα του Spotify",
  "sClose": "Κλείσιμο",
  "cls.highlight": "Το Premium διακόπηκε",
  "cls.title": "Η τελευταία πληρωμή σου δεν έγινε σωστά.",
  "cls.desc": "Συνέχισε να ακούς μουσική με το Premium, προσθέτοντας μια νέα μέθοδο πληρωμής. Θα σου πάρει μόνο μια στιγμή.",
  "cls.updatePayment": "Ενημέρωση πληρωμής",
  "cls.cancelSubscription": "Μπορείς επίσης να επιλέξεις υποβάθμιση στο Spotify Free,<br> <a class=\"cancel-sub\" href=\"#cancel\">ακυρώνοντας τη συνδρομή σου στο Premium</a>.",
  "capping.upsell-title": "Έφτασες στο όριο της δωρεάν ακρόασής σου.",
  "capping.upsell-message": "Έχεις 15 ώρες δωρεάν ακρόασης κάθε μήνα.<br />Κάνε αναβάθμιση στο Premium για να μπορείς να ακούς μουσική απεριόριστα χωρίς διαφημίσεις.",
  "capping.upsell-button-label": "Αναβάθμιση σε Premium",
  "capping.defaultRefillMessage": "Ο χρόνος δωρεάν ακρόασής σου θα αναπληρωθεί ξανά σύντομα.",
  "capping.refillMessage": "Ο χρόνος δωρεάν ακρόασής σου θα συμπληρωθεί ξανά μέσα στις επόμενες {0} ημέρες.",
  "capping.welcome-title": "Καλωσόρισες στο Spotify.",
  "capping.welcome-message": "Απόλαυσε 15 ώρες δωρεάν ακρόασης κάθε μήνα.<br /> <a data-action={0}>Κάνε αναβάθμιση στο Premium</a> για να ακούς μουσική απεριόριστα χωρίς διαφημίσεις.",
  "capping.welcome-message-button-label": "Ξεκίνα",
  "yourArtistsTooltipTitle": "Διαχειρίσου τους καλλιτέχνες σου",
  "yourArtistsTooltipText": "Τώρα μπορείς εύκολα να επεξεργαστείς την εικόνα του προφίλ καλλιτέχνη σου στο Spotify.",
  "yourArtists": "Οι καλλιτέχνες σου"
};
},{}],3:[function(require,module,exports){
module.exports = {
  "browse.app_name": "Browse",
  "latest-releases.app_name": "Latest Releases",
  "discover.app_name": "Discover",
  "activity.app_name": "Activity",
  "radio.app_name": "Radio",
  "settings.app_name": "Settings",
  "messages.app_name": "Messages",
  "profile.app_name": "Profile",
  "notifications_center.app_name": "Notifications",
  "concerts.app_name": "Concerts",
  "profile.private_session": "Private Session",
  "profile.upgrade": "Upgrade",
  "profile.upgrade_account": "Upgrade Your Account",
  "profile.upgrade_tooltip": "Upgrade to Premium",
  "profile.account": "Account",
  "profile.logout": "Log Out",
  "profile.enabled": "Enabled",
  "profile.menu_label": "Menu",
  "profile.switch": "Switch User",
  "profile.new_user": "Switch to New User",
  "your_music.app_name": "Your Music",
  "your_music.songs": "Songs",
  "your_music.artists": "Artists",
  "your_music.albums": "Albums",
  "your_music.stations": "Stations",
  "your_music.local_files": "Local Files",
  "sidebar.title_main": "Main",
  "sidebar.title_playlists": "Playlists",
  "new_playlist.input_placeholder": "New Playlist",
  "new_playlist.button": "New Playlist",
  "accessibilitylinks.skip_to_content_label": "Skip to main content",
  "accessibilitylinks.skip_to_player_label": "Skip to player controls",
  "playlist.by": "by {0}",
  "playlist.loading": "Loading...",
  "playlist.newfolder": "New Folder",
  "playlist.delete_message": "Do you really want to delete this playlist?",
  "playlist.unfollow_message": "Do you really want to stop following this playlist?",
  "playlistfolder.delete_message": "Do you really want to delete this folder and all playlists inside?",
  "playlist.delete_confirm": "Delete",
  "playlist.unfollow_confirm": "Unfollow",
  "playlist.delete_cancel": "Cancel",
  "playlist.duplicates_dialog_title": "Duplicate songs",
  "playlist.duplicates_dialog_title_single": "Duplicate song",
  "playlist.duplicates_dialog_body": "Some of these songs are already in your playlist.",
  "playlist.duplicates_dialog_body_single": "This song is already in your playlist.",
  "playlist.duplicates_dialog_button_add": "Add all",
  "playlist.duplicates_dialog_button_add_single": "Add anyway",
  "playlist.duplicates_dialog_button_skip_duplicates": "Skip duplicates",
  "playlist.duplicates_dialog_button_skip_single": "Skip duplicate",
  "playlist.annotate_form.new_playlist_name": "New Playlist",
  "playlist.annotate_form.create_title": "Create Playlist",
  "playlist.annotate_form.create": "Create",
  "playlist.annotate_form.cancel": "Cancel",
  "playlist.annotate_form.edit_title": "Edit Playlist Details",
  "playlist.annotate_form.save": "Save",
  "playlist.annotate_form.name_field_label": "Name",
  "playlist.annotate_form.name_field_placeholder": "Playlist name",
  "playlist.annotate_form.image_field_label": "Image",
  "playlist.annotate_form.image_pick_button_label": "Choose image",
  "playlist.annotate_form.image_replace_button_label": "Replace image",
  "playlist.annotate_form.image_remove_button_label": "Remove image",
  "playlist.annotate_form.image_file_size_exceeded": "Image size too big, maximum: 4MB.",
  "playlist.annotate_form.image_file_upload_failed": "Failed to upload image, please try again.",
  "playlist.annotate_form.annotate_failed": "Failed to update description and image, please try again.",
  "playlist.annotate_form.close-error-bar": "Hide",
  "playlist.annotate_form.description_field_label": "Description",
  "playlist.annotate_form.description_field_placeholder": "Give your playlist a catchy description.",
  "playlist.annotate_form.permission_message": "By proceeding, you agree to give Spotify access to the image you choose to upload. Please make sure you have the right to upload the image. We'll only use your image for playlist cover art.",
  "playlist.annotate_form.insert_link_button_label": "Insert link",
  "playlist.annotate_form.insert_link.link_field_label": "Link to",
  "playlist.annotate_form.insert_link.change_button_label": "Change",
  "playlist.annotate_form.insert_link.remove_button_label": "Remove",
  "playlist.annotate_form.insert_link.done_button_label": "Done",
  "playlist.annotate_form.drop_to_set_image_label": "Drop to set image",
  "playlist.annotate_form.drop_not_allowed_label": "Unsupported format",
  "playlist.annotate_form.error.file_not_valid_jpg": "That file is not actually a valid JPG file, despite its file name.",
  "playlist.annotate_form.error.name_required": "You must give your playlist a name.",
  "playlist.annotate_form.error.selection_required_to_insert_link": "You must select the text you'd like to turn into a link.",
  "playlist.annotate_form.error.html_not_allowed": "It looks like you're trying to use HTML, which isn't possible.",
  "playlist.annotate_form.error.submit": "Failed to save playlist changes. Please try again.",
  "playlist.annotate_form.error.image_too_small": "That image is too small. It must be at least {0}x{1}.",
  "playlist.annotate_form.warning.client_offline": "No internet connection found. Changes to description and image will not be saved.",
  "playlist.annotate_form.warning.no_line_breaks_in_description": "Sorry, but line breaks aren't supported in the description.",
  "playlist.annotate_form.warning.unsaved_changes": "Don't you want to save your changes?",
  "navigation.label": "Navigation",
  "navigation.back_button_label": "Go back",
  "navigation.forward_button_label": "Go forward",
  "search.input_placeholder": "Search",
  "player.label": "Player controls",
  "player.shuffle_mode_label": "Shuffle",
  "player.repeat_mode_label": "Repeat",
  "player.queue": "Queue",
  "player.volume_button_label": "Volume",
  "player.spotify_connect": "Spotify Connect",
  "player.connect_button_label": "Connect to a device",
  "player.lyrics_label": "Lyrics",
  "player.play_button_label": "Play",
  "player.pause_button_label": "Pause",
  "player.previous_button_label": "Previous",
  "player.next_button_label": "Next",
  "player.offline_label": "Offline",
  "player.thumb_up_label": "Thumb Up",
  "player.thumb_down_label": "Thumb Down",
  "playererror.default": "There was a problem when trying to play the selected song",
  "playererror.track_not_available": "This song is not available",
  "nowplaying.label": "Now playing",
  "nowplaying.go_to_context": "Go to what's playing",
  "nowplaying.save_your_music": "Save to Your Music",
  "nowplaying.remove_your_music": "Remove from Your Music",
  "nowplaying.playing_suggested_track": "Currently Playing Suggested Song",

  "connect.connect_text": "Connect to a device",
  "connect.device_connecting": "Connecting…",
  "connect.device_incompatible": "Incompatible",
  "connect.device_premium_only": "Premium users only",
  "connect.device_sleeping": "Device is sleeping",
  "connect.device_tech_cast": "Google Cast",
  "connect.device_tech_connect": "Spotify Connect",
  "connect.device_this_computer": "This Computer",
  "connect.device_unavailable_for_playback": "Unavailable for listening on",
  "connect.device_unknown": "Unknown device",
  "connect.device_unsupported_uri": "Can't play this right now",
  "connect.devices_available": "Devices Available",
  "connect.dismiss": "Dismiss",
  "connect.help1": "Connect lets you play and control Spotify on your devices.",
  "connect.help2": "Start Spotify on another device and it will magically appear here.",
  "connect.help_hint": "What is Connect?",
  "connect.offline": "Not available",
  "connect.offline_reason_computer": "Spotify is not active on this device.",
  "connect.offline_reason_generic": "Spotify is not active on this device.",
  "connect.offline_reason_phone": "Phone locked or Spotify not in the foreground.",
  "connect.offline_reason_gameconsole": "Use the power-on settings in Spotify PlayStation Application to enable waking the PlayStation from standby mode.",
  "connect.offline_text1": "You need to go online in order to use this feature.",
  "connect.offline_title": "You're offline!",
  "connect.playingon": "Listening On",
  "connect.popup_title": "Devices",
  "connect.remoteplayback": "You are listening on {0}",
  "connect.show_more": "Show More",
  "connect.upgrade": "Upgrade",
  "connect.upsell": "Connect is a Premium feature that lets you play and control Spotify on your devices.",

  "contextmenu.new-playlist": "New Playlist",
  "contextmenu.add-to-playlist": "Add to Playlist",
  "contextmenu.owner-playlist": "by {0}",
  "contextmenu.copy-uri": "Copy Spotify URI",
  "contextmenu.copy-artist-url": "Copy Artist Link",
  "contextmenu.copy-album-url": "Copy Album Link",
  "contextmenu.copy-track-url": "Copy Song Link",
  "contextmenu.copy-playlist-url": "Copy Playlist Link",
  "contextmenu.copy-profile-url": "Copy Profile Link",
  "contextmenu.copy-station-url": "Copy Station Link",
  "contextmenu.copy-chart-url": "Copy Chart Link",
  "contextmenu.copy-url": "Copy Link",
  "contextmenu.copy-embed": "Copy Embed Code",
  "contextmenu.collaborative": "Collaborative Playlist",
  "contextmenu.save": "Save to Your Music",
  "contextmenu.remove": "Remove from Your Music",
  "contextmenu.delete-playlist": "Delete",
  "contextmenu.follow": "Follow",
  "contextmenu.unfollow": "Unfollow",
  "contextmenu.publish": "Make Public",
  "contextmenu.unpublish": "Make Secret",
  "contextmenu.playlist.loading": "Loading...",
  "contextmenu.play": "Play",
  "contextmenu.add-to-queue": "Add to Queue",
  "contextmenu.station": "Go to Radio",
  "contextmenu.station-album": "Go to Album Radio",
  "contextmenu.station-artist": "Go to Artist Radio",
  "contextmenu.station-playlist": "Go to Playlist Radio",
  "contextmenu.station-track": "Go to Song Radio",
  "contextmenu.station-chart": "Go to Chart Radio",
  "contextmenu.remove-from-playlist": "Remove from this Playlist",
  "contextmenu.remove-from-queue": "Remove from Queue",
  "contextmenu.rename-folder": "Rename",
  "contextmenu.rename-playlist": "Rename",
  "contextmenu.edit-playlist": "Edit details",
  "contextmenu.report-playlist": "Report",
  "contextmenu.report-asset": "Report",
  "contextmenu.share": "Share...",
  "contextmenu.share-lyrics": "Share Lyrics",
  "contextmenu.create-folder": "Create Folder",
  "contextmenu.create-playlist": "Create Playlist",
  "contextmenu.open-localfile-folder": "Open Containing Folder",
  "contextmenu.open-localfile-folder-mac": "Reveal in Finder",
  "contextmenu.offline": "Available Offline",
  "contextmenu.goto-artist": "Go to Artist",
  "contextmenu.goto-album": "Go to Album",
  "usermessage.default-message": "An error has occurred",
  "usermessage.update-ready": "Hello. We've got a new version of Spotify ready for you. <a href=\"#\" data-action=\"{0}\">Restart now</a> to make it yours.",
  "usermessage.update-ready-simple": "Hello. We've got a new version of Spotify ready for you. Restart now to make it yours.",
  "usermessage.play-token-lost": "Spotify has been paused because your account is being used somewhere else.",
  "usermessage.playback-paused-inactive": "Your computer has been inactive for a long period of time, press play to continue listening! For uninterrupted music, subscribe to <a href=\"#\" data-action=\"{0}\">Spotify Premium</a>.",
  "usermessage.not-available-offline": "No internet connection detected. Spotify will automatically try to reconnect when it detects an internet connection (error code:4)",
  "usermessage.track-not-available-in-region": "This song is currently not available in {0}. If you have the file on your computer you can import it.",
  "usermessage.track-not-available-in-region-generic": "This song is currently not available in your country. If you have the file on your computer you can import it.",
  "usermessage.track-not-available": "This song is not available. If you have the file on your computer you can import it.",
  "usermessage.track-not-available-forced-offline": "Please <a href=\"#\" data-action=\"goOnline\">turn off offline mode</a> and try again.",
  "usermessage.track-exclusive-premium": "This song is exclusive to <a href=\"#\" data-action=\"{0}\">Spotify Premium</a> users.",
  "usermessage.track-banned-by-artist": "The artist/label has chosen to make this song unavailable. If you have the file on your computer you can import it.",
  "usermessage.local-track-no-file": "This song was added as a local file. If you have the file on your computer you can import it.",
  "usermessage.local-track-file-not-found": "This song can't be played because the file could not be found. Please import it again.",
  "usermessage.local-track-bad-format": "File is an unknown format. Click <a href=\"#\" data-action=\"{0}\">here</a> for information.",
  "usermessage.capping-reached": "You've exceeded your {0} hour time limit. <a href=\"#\" data-action=\"{1}\">Upgrade to Spotify Premium</a> to listen without restrictions.",
  "usermessage.local-track-drm-protected": "This song can't be played because the file is protected by digital rights management (DRM).",
  "usermessage.offline-disk-cache": "Downloading of offline songs failed. Maybe the disk is full?",
  "usermessage.offline-sync-expired": "The offline songs have expired. You need to login to Spotify to re-activate them.",
  "usermessage.offline-sync-failed": "Downloading of some offline songs failed.",
  "usermessage.offline-too-many-tracks": "Too many songs selected for offline mode.",
  "usermessage.offline-license-server-error": "There was a problem with the Spotify server.",
  "usermessage.offline-license-lost": "Offline access for this computer/device has been withdrawn.",
  "usermessage.offline-not-allowed": "Offline mode is a <a href=\"#\" data-action=\"{0}\">Spotify Premium</a> exclusive feature.",
  "usermessage.language-changed": "You need to <a href=\"#\" data-action=\"{0}\">restart Spotify</a> for the change to take effect",
  "usermessage.proxysettings-changed": "You need to <a href=\"#\" data-action=\"{0}\">restart Spotify</a> for the change to take effect",
  "usermessage.language-changed-simple": "You need to restart Spotify for the change to take effect",
  "usermessage.proxysettings-changed-simple": "You need to restart Spotify for the change to take effect",
  "usermessage.cache-changed": "You need to <a href=\"#\" data-action=\"{0}\">restart Spotify</a> for the change to take effect",
  "usermessage.cache-changed-simple": "You need to restart Spotify for the change to take effect",
  "usermessage.feature-changed": "You need to <a href=\"#\" data-action=\"{0}\">restart Spotify</a> for the change to take effect",
  "usermessage.first-autostart": "Spotify has opened automatically, but minimized. If you prefer you can <a href=\"#\" data-action=\"{0}\">open Spotify automatically without it being minimized</a> or <a href=\"#\" data-action=\"{1}\">not open Spotify on start up</a> at all.",
  "usermessage.cant-play-track": "Can't play the current song.",
  "usermessage.cant-skip-ads": "The selected song will be played after the ad",
  "usermessage.cant-offline-playlists": "Offline mode is a Premium exclusive feature. <a href=\"#\" data-action=\"{0}\">Get Premium</a>.",
  "usermessage.cant-set-high-quality-streaming": "This is a Premium exclusive feature. <a href=\"#\" data-action=\"{0}\">Get Premium</a>.",
  "usermessage.payment-state-creditcard-funds": "We've been unable to renew your subscription because of a payment problem. Please make sure you have funds in your account or <a href=\"#\" data-action=\"{0}\">update your payment details</a>.",
  "usermessage.payment-state-creditcard-refused": "We've been unable to renew your subscription because of a payment problem. To keep your subscription, please <a href=\"#\" data-action=\"{0}\">update your payment details</a>.",
  "usermessage.payment-state-paypal-refused": "We've been unable to renew your subscription because of a payment problem. To keep your subscription, please <a href=\"#\" data-action=\"{0}\">update your payment details</a>.",
  "usermessage.payment-state-creditcard-expiry": "The payment card you're currently using expires in a few days. To keep your subscription, please <a href=\"#\" data-action=\"{0}\">update your payment details</a>.",
  "usermessage.payment-state-prepaid-expiry": "Your pre-paid subscription is about to expire. Don't worry, you can <a href=\"#\" data-action=\"{0}\">subscribe to Premium here</a>.",
  "usermessage.payment-state-churn-payment": "Unfortunately we couldn't take payment from you, so we had to cancel your subscription. Don't worry, you can <a href=\"#\" data-action=\"{0}\">renew your subscription here</a>.",
  "usermessage.payment-state-churn-partner": "Your subscription with one of our partners has just ended, so you are now using Spotify Free. Don't worry, you can <a href=\"#\" data-action=\"{0}\">get back to Premium here</a>.",
  "usermessage.opt-in-trial": "We hope you are enjoying your free trial! To keep from losing Premium when it ends, <a href=\"#\" data-action=\"{0}\">subscribe today</a>.",
  "usermessage.opt-in-trial-expired": "Your free trial has ended, so you are now using Spotify Free. Don't worry, you can <a href=\"#\" data-action=\"{0}\">get back to Premium here</a>.",
  "usermessage.hardware-acceleration-changed": "You need to <a href=\"#\" data-action=\"{0}\">restart Spotify</a> for the change to take effect",
  "usermessage.hardware-acceleration-changed-simple": "You need to restart Spotify for the change to take effect",
  "usermessage.some-local-tracks-not-saved": "Some of the selected songs were not saved to Your Music. Local files are not supported by Your Music.",
  "usermessage.illegal-playlist-name-entered": "The playlist name entered was invalid.",
  "usermessage.playlist-save-failed-unknown": "The playlist could not be saved due to an unknown error.",
  "usermessage.social-error-permissions": "Click <a href=\"#\" data-action=\"{0}\">here</a> to allow your music activity to be shared on Facebook.",
  "usermessage.shuffle-unplayable-track": "<a href=\"#\" data-action=\"{0}\">Upgrade to Premium</a> to play any song, any time.",
  "usermessage.shuffle-ran-out-of-skips": "You've run out of skips (for this hour). <a href=\"#\" data-action=\"{0}\">Upgrade to Premium</a> to skip as often as you like.",
  "usermessage.playlist-limit-exceeded": "You’ve filled this playlist to the max. Impressive. Start a new one now to keep collecting.",
  "usermessage.collection-limit-exceeded": "Epic collection, friend. Your Music is all filled up. To save more, you’ll need to remove some songs.",
  "usermessage.deprecating-os-version": "Heads up! We're ending support for your operating system in an upcoming release. Click <a href=\"#\" data-action=\"{0}\">here</a> for more information.",
  "usermessage.image-upload-propagation": "Success! (Images can take up to 24 hours to propagate)",
  "usermessage.approaching-capping-limit": "You have less than 1 hour of free listening remaining. Enjoy 15 hours of free listening each month or <a href=\"#\" data-action=\"{0}\">upgrade to Premium</a> for unlimited listening. <a href=\"#\" data-action=\"{1}\">Learn more</a>.",
  "usermessage.half-capping-limit-passed": "You have used half of your monthly limit. Enjoy 15 hours of free listening each month or <a href=\"#\" data-action=\"{0}\">upgrade to Premium</a> for unlimited listening. <a href=\"#\" data-action=\"{1}\">Learn more</a>.",
  "usermessage.video-georestricted": "We’re not able to play this video in your current location.",
  "usermessage.video-unsupported-client-version": "Please upgrade Spotify to play this video.",
  "usermessage.video-unsupported-platform-version": "This video cannot be played on your operating system version.",
  "usermessage.video-country-restricted": "We’re not able to play this video in your current location.",
  "usermessage.video-unavailable": "This video is unavailable. Try another?",
  "usermessage.video-catalogue-restricted": "Sorry, we’re not able to play this video.",
  "usermessage.video-playback-error": "Sorry, we’re not able to play this video.",
  "about.title_label": "About Spotify",
  "about.close_button_label": "Close",
  "offline-progress-msg": "Offline syncing {0} of {1} songs",
  "tos.updated_terms": "Updated terms",
  "tos.modal_title": "Spotify Terms and Conditions of Use",
  "tos.tos_text": "<p>We have revised our <a href=\"{0}\">Terms and Conditions of Use</a> and <a href=\"{1}\">Privacy Policy</a>.</p><p>By continuing to use Spotify, you accept these updated terms, so please take a few minutes to read and understand them.</p>",
  "tos.not_now_tos_text": "<p>We have revised our <a href=\"{0}\">Terms and Conditions of Use</a> and <a href=\"{1}\">Privacy Policy</a>.</p><p>By clicking \"Accept\", you agree to these updates (and the processing of your data as described), so please take a few minutes to read and understand them.</p>",
  "tos.tos_text2": "<p>If you no longer wish to use Spotify, you may cancel your subscription by visiting your Spotify subscription page.</p>",
  "tos.not_now_text": "<p>You may continue to use Spotify for {0} days without accepting the updated Terms and Conditions and Privacy Policy. At that time, you will be required to accept the new terms in order to continue using Spotify. Unless you cancel your subscription, you will continue to be billed monthly on your regular billing cycle. If you do not wish to be charged by Spotify again, you may cancel your subscription at any time by visiting your Spotify subscription page.</p>",
  "tos.not_now_last_day_text": "<p>You may continue to use Spotify for 1 day without accepting the updated Terms and Conditions and Privacy Policy. If you do not accept the new terms by that time, you will no longer be able to use Spotify. Unless you cancel your subscription, you will continue to be billed monthly on your regular billing cycle. If you do not wish to be charged by Spotify again, you may cancel your subscription at any time by visiting your Spotify subscription page.</p>",
  "tos.not_now_text_germany": "<p>We have revised our <a href=\"{0}\">Terms and Conditions of Use</a> and our <a href=\"{1}\">Privacy Policy</a>. Please note that, with your consent, Spotify GmbH intends to transfer your contract to Spotify AB, Birger Jarlsgatan 61, 113 56 Stockholm, Sweden.</p><p>You may continue to use the Spotify service under the existing contract until {2}. After that date, in order to continue using the Spotify service, you will have to accept the new Terms and Conditions and Privacy Policy. By clicking \"Accept\", you consent to</p><p>a) the transfer of your contract from Spotify GmbH to Spotify AB,<br />b) the updates of the Terms and Conditions of Use, and<br />c) the collecting, processing and use of your personal data as described in Sections 4, 5, and 7 of the Privacy Policy.</p>",
  "tos.not_now_text2_germany": "<p>You may continue to use Spotify until {0} without accepting the updated Terms and Conditions and Privacy Policy. At that time, you will be required to accept the new terms in order to continue using Spotify. If you are a Premium user, you will continue to be billed monthly on your regular billing cycle unless you cancel your subscription. If you do not wish to be charged by Spotify again, you may cancel your subscription at any time by visiting your Spotify subscription page.</p>",
  "tos.not_now_expired_text_germany": "<p>We have revised our <a href=\"{0}\">Terms and Conditions of Use</a> and our <a href=\"{1}\">Privacy Policy</a>.</p><p>Please note that, with your consent, Spotify GmbH intends to transfer your contract to Spotify AB, Birger Jarlsgatan 61, 113 56 Stockholm, Sweden.</p><p>In order to continue using the Spotify service, you must accept the new Terms and Conditions and Privacy Policy. By clicking \"Accept\", you consent to</p><p>a) the transfer of your contract from Spotify GmbH to Spotify AB,<br />b) the updates of the Terms and Conditions of Use, and<br/>c) the collecting, processing and use of your personal data as described in Sections 4, 5, and 7 of the Privacy Policy.</p>",
  "tos.back_button_label": "Back",
  "tos.ok_button_label": "OK",
  "tos.agree_button_label": "Accept",
  "tos.cancel_button_label": "Decline",
  "tos.not_now_button_label": "Not now",
  "licenses.modal_title": "Third-party licenses",
  "licenses.close_button_label": "Close",
  "feedback.beta_title": "Beta Version",
  "feedback.beta_text": "Hate or love something? Let us know.",
  "market.ad": "Andorra",
  "market.ar": "Argentina",
  "market.at": "Austria",
  "market.au": "Australia",
  "market.be": "Belgium",
  "market.bg": "Bulgaria",
  "market.bo": "Bolivia",
  "market.br": "Brazil",
  "market.ca": "Canada",
  "market.ch": "Switzerland",
  "market.cl": "Chile",
  "market.co": "Colombia",
  "market.cr": "Costa Rica",
  "market.cy": "Cyprus",
  "market.cz": "Czech Republic",
  "market.de": "Germany",
  "market.dk": "Denmark",
  "market.do": "Dominican Republic",
  "market.ec": "Ecuador",
  "market.ee": "Estonia",
  "market.es": "Spain",
  "market.fi": "Finland",
  "market.fr": "France",
  "market.gr": "Greece",
  "market.gt": "Guatemala",
  "market.hk": "Hong Kong",
  "market.hn": "Honduras",
  "market.hu": "Hungary",
  "market.ie": "Ireland",
  "market.is": "Iceland",
  "market.it": "Italy",
  "market.jp": "Japan",
  "market.li": "Liechtenstein",
  "market.lt": "Lithuania",
  "market.lu": "Luxembourg",
  "market.lv": "Latvia",
  "market.mc": "Monaco",
  "market.mt": "Malta",
  "market.mx": "Mexico",
  "market.my": "Malaysia",
  "market.ni": "Nicaragua",
  "market.nl": "Netherlands",
  "market.no": "Norway",
  "market.nz": "New Zealand",
  "market.pa": "Panama",
  "market.pe": "Peru",
  "market.ph": "Philippines",
  "market.pl": "Poland",
  "market.pt": "Portugal",
  "market.py": "Paraguay",
  "market.se": "Sweden",
  "market.sg": "Singapore",
  "market.sk": "Slovakia",
  "market.sv": "El Salvador",
  "market.tr": "Turkey",
  "market.tw": "Taiwan",
  "market.uk": "United Kingdom",
  "market.us": "United States",
  "market.uy": "Uruguay",
  "market.za": "South Africa",
  "sTitle": "Share your thoughts and help us build the world's greatest music service!",
  "sQ1Question": "How likely is it that you’d recommend Spotify to a friend or colleague?",
  "sQ1Negative": "Not at all likely",
  "sQ1Positive": "Extremely likely",
  "sQ2Question": "Why do you feel that way?",
  "sQ3Question": "Overall, how satisfied are you with Spotify?",
  "sQ3Negative": "Very dissatisfied",
  "sQ3Positive": "Very satisfied",
  "sSubmit": "Submit survey",
  "sThanks": "Thanks very much for your help. We appreciate your time.",
  "sTeam": "The Spotify Team",
  "sClose": "Close",
  "cls.highlight": "Premium paused",
  "cls.title": "Your last payment didn't work.",
  "cls.desc": "Continue listening with Premium by adding a new payment method. It only takes a moment.",
  "cls.updatePayment": "Update payment",
  "cls.cancelSubscription": "You can also downgrade to Spotify Free,<br>by <a class=\"cancel-sub\" href=\"#cancel\">cancelling your Premium subscription</a>.",

  "capping.upsell-title": "You've reached your free listening limit.",
  "capping.upsell-message": "You get 15 hours of free listening each month.<br />Upgrade to Premium to get unlimited listening without ads.",
  "capping.upsell-button-label": "Upgrade to Premium",
  "capping.defaultRefillMessage": "Your free listening will be topped up soon.",
  "capping.refillMessage": "Your free listening will be topped up within the next {0} days.",
  "capping.welcome-title": "Welcome to Spotify.",
  "capping.welcome-message": "Enjoy 15 hours of free listening each month.<br> <a data-action={0}>Upgrade to Premium</a> for unlimited listening without ads.",
  "capping.welcome-message-button-label": "Get Started",
  "yourArtistsTooltipTitle": "Manage your artists",
  "yourArtistsTooltipText": "You can now easily edit your artist profile image on Spotify.",
  "yourArtists": "Your Artists"
}
;
},{}],4:[function(require,module,exports){
module.exports = {
  "browse.app_name": "Explorar",
  "latest-releases.app_name": "Últimos lanzamientos",
  "discover.app_name": "Descubre",
  "activity.app_name": "Actividad",
  "radio.app_name": "Radio",
  "settings.app_name": "Preferencias",
  "messages.app_name": "Mensajes",
  "profile.app_name": "Perfil",
  "notifications_center.app_name": "Notificaciones",
  "concerts.app_name": "Conciertos",
  "profile.private_session": "Sesión Privada",
  "profile.upgrade": "Suscríbete",
  "profile.upgrade_account": "Mejora tu cuenta",
  "profile.upgrade_tooltip": "Sube de categoría a Premium",
  "profile.account": "Cuenta",
  "profile.logout": "Cerrar sesión",
  "profile.enabled": "Habilitado",
  "profile.menu_label": "Menú",
  "profile.switch": "Cambiar usuario",
  "profile.new_user": "Cambiar a nuevo usuario",
  "your_music.app_name": "Tu Música",
  "your_music.songs": "Canciones",
  "your_music.artists": "Artistas",
  "your_music.albums": "Álbumes",
  "your_music.stations": "Estaciones",
  "your_music.local_files": "Archivos Locales",
  "sidebar.title_main": "Principal",
  "sidebar.title_playlists": "Playlists",
  "new_playlist.input_placeholder": "Nueva playlist",
  "new_playlist.button": "Nueva playlist",
  "accessibilitylinks.skip_to_content_label": "Saltar a contenido principal",
  "accessibilitylinks.skip_to_player_label": "Saltar a los controles del reproductor",
  "playlist.by": "de {0}",
  "playlist.loading": "Cargando...",
  "playlist.newfolder": "Nueva carpeta",
  "playlist.delete_message": "¿De verdad quieres eliminar esta playlist?",
  "playlist.unfollow_message": "¿De verdad quieres dejar de seguir esta playlist? ",
  "playlistfolder.delete_message": "¿De verdad quieres eliminar esta carpeta y todas las playlists que contiene?",
  "playlist.delete_confirm": "Eliminar",
  "playlist.unfollow_confirm": "Dejar de seguir",
  "playlist.delete_cancel": "Cancelar",
  "playlist.duplicates_dialog_title": "Canciones duplicadas",
  "playlist.duplicates_dialog_title_single": "Canción duplicada",
  "playlist.duplicates_dialog_body": "Algunas de estas canciones ya están en tu playlist.",
  "playlist.duplicates_dialog_body_single": "Esta canción ya está en tu playlist.",
  "playlist.duplicates_dialog_button_add": "Agregar todas",
  "playlist.duplicates_dialog_button_add_single": "Agregar de todas formas",
  "playlist.duplicates_dialog_button_skip_duplicates": "Saltar duplicadas",
  "playlist.duplicates_dialog_button_skip_single": "Saltar duplicada",
  "playlist.annotate_form.new_playlist_name": "Nueva playlist",
  "playlist.annotate_form.create_title": "Crear playlist",
  "playlist.annotate_form.create": "Crear",
  "playlist.annotate_form.cancel": "Cancelar",
  "playlist.annotate_form.edit_title": "Editar detalles de la playlist",
  "playlist.annotate_form.save": "Guardar",
  "playlist.annotate_form.name_field_label": "Nombre",
  "playlist.annotate_form.name_field_placeholder": "Nombre de la playlist",
  "playlist.annotate_form.image_field_label": "Imagen",
  "playlist.annotate_form.image_pick_button_label": "Elegir imagen",
  "playlist.annotate_form.image_replace_button_label": "Reemplazar imagen",
  "playlist.annotate_form.image_remove_button_label": "Eliminar imagen",
  "playlist.annotate_form.image_file_size_exceeded": "La imagen es demasiado grande; el tamaño máximo es de 4 MB.",
  "playlist.annotate_form.image_file_upload_failed": "No se cargó la imagen; inténtalo de nuevo.",
  "playlist.annotate_form.annotate_failed": "No se actualizó la descripción ni la imagen; inténtalo de nuevo.",
  "playlist.annotate_form.close-error-bar": "Ocultar",
  "playlist.annotate_form.description_field_label": "Descripción",
  "playlist.annotate_form.description_field_placeholder": "Ponle una descripción ingeniosa a tu playlist.",
  "playlist.annotate_form.permission_message": "Al proceder, aceptas que Spotify tenga acceso a la imagen que tú elijas cargar. Asegúrate de que tienes los derechos para cargar la imagen. Solo usaremos tu imagen para la portada de una playlist.",
  "playlist.annotate_form.insert_link_button_label": "Insertar enlace",
  "playlist.annotate_form.insert_link.link_field_label": "Enlazar a",
  "playlist.annotate_form.insert_link.change_button_label": "Cambiar",
  "playlist.annotate_form.insert_link.remove_button_label": "Eliminar",
  "playlist.annotate_form.insert_link.done_button_label": "Listo",
  "playlist.annotate_form.drop_to_set_image_label": "Suelta para establecer la imagen",
  "playlist.annotate_form.drop_not_allowed_label": "Formato no compatible",
  "playlist.annotate_form.error.file_not_valid_jpg": "Ese archivo, a pesar de su nombre, no es un archivo JPG válido.",
  "playlist.annotate_form.error.name_required": "Es necesario que le pongas un nombre a tu playlist.",
  "playlist.annotate_form.error.selection_required_to_insert_link": "Es necesario que selecciones el texto que deseas convertir en un enlace.",
  "playlist.annotate_form.error.html_not_allowed": "Parece que estás tratando de usar HTML, lo cual no es posible.",
  "playlist.annotate_form.error.submit": "No se pudieron guardar los cambios realizados a la playlist. Inténtalo de nuevo.",
  "playlist.annotate_form.error.image_too_small": "Esa imagen es demasiado pequeña. Debe ser al menos de {0}x{1}.",
  "playlist.annotate_form.warning.client_offline": "No se encontró una conexión a Internet. No se guardarán los cambios realizados a la descripción y la imagen.",
  "playlist.annotate_form.warning.no_line_breaks_in_description": "Lo sentimos, pero no se pueden incluir saltos de línea en la descripción.",
  "playlist.annotate_form.warning.unsaved_changes": "¿No quieres guardar tus cambios?",
  "navigation.label": "Navegación",
  "navigation.back_button_label": "Volver",
  "navigation.forward_button_label": "Avanzar",
  "search.input_placeholder": "Buscar",
  "player.label": "Controles del reproductor",
  "player.shuffle_mode_label": "Aleatoria",
  "player.repeat_mode_label": "Repetir",
  "player.queue": "Agregar a la fila",
  "player.volume_button_label": "Volumen",
  "player.spotify_connect": "Spotify Connect",
  "player.connect_button_label": "Conectar a un dispositivo",
  "player.lyrics_label": "Letras",
  "player.play_button_label": "Reproducir",
  "player.pause_button_label": "Pausa",
  "player.previous_button_label": "Anterior",
  "player.next_button_label": "Siguiente",
  "player.offline_label": "Modo offline",
  "player.thumb_up_label": "Pulgar arriba",
  "player.thumb_down_label": "Pulgar abajo",
  "playererror.default": "Hubo un problema al tratar de reproducir la canción seleccionada",
  "playererror.track_not_available": "Esta canción no está disponible",
  "nowplaying.label": "Estás escuchando",
  "nowplaying.go_to_context": "Ir a lo que estás escuchando",
  "nowplaying.save_your_music": "Guardar en Tu Música",
  "nowplaying.remove_your_music": "Eliminar de Tu Música",
  "nowplaying.playing_suggested_track": "Reproduciendo actualmente la canción sugerida",
  "connect.connect_text": "Conectar a un dispositivo",
  "connect.device_connecting": "Conectando…",
  "connect.device_incompatible": "Incompatible",
  "connect.device_premium_only": "Solo para usuarios Premium",
  "connect.device_sleeping": "Dispositivo en modo suspensión",
  "connect.device_tech_cast": "Google Cast",
  "connect.device_tech_connect": "Spotify Connect",
  "connect.device_this_computer": "Esta computadora",
  "connect.device_unavailable_for_playback": "No está disponible para la reproducción",
  "connect.device_unknown": "Dispositivo desconocido",
  "connect.device_unsupported_uri": "No se puede reproducir esto ahora",
  "connect.devices_available": "Dispositivos disponibles",
  "connect.dismiss": "Cerrar",
  "connect.help1": "Connect te permite jugar y controlar Spotify en tus dispositivos.",
  "connect.help2": "Inicia Spotify en otro dispositivo y aparecerá aquí por arte de magia.",
  "connect.help_hint": "¿Qué es Connect?",
  "connect.offline": "No disponible",
  "connect.offline_reason_computer": "Spotify no está activo en este dispositivo.",
  "connect.offline_reason_generic": "Spotify no está activo en este dispositivo.",
  "connect.offline_reason_phone": "El teléfono está bloqueado o Spotify no está en primer plano.",
  "connect.offline_reason_gameconsole": "Utiliza la configuración de encendido en la aplicación de Spotify para PlayStation para permitir el encendido de la PlayStation cuando está en modo de reposo.",
  "connect.offline_text1": "Necesitas conectarte a Internet para usar esta función.",
  "connect.offline_title": "Estás desconectado.",
  "connect.playingon": "Escuchando en",
  "connect.popup_title": "Dispositivos",
  "connect.remoteplayback": "Estás escuchando en {0}",
  "connect.show_more": "Mostrar más",
  "connect.upgrade": "Suscríbete",
  "connect.upsell": "Connect es una característica Premium que te permite reproducir y controlar Spotify en todos tus dispositivos.",
  "contextmenu.new-playlist": "Nueva playlist",
  "contextmenu.add-to-playlist": "Agregar a playlist",
  "contextmenu.owner-playlist": "de {0}",
  "contextmenu.copy-uri": "Copiar URI de Spotify",
  "contextmenu.copy-artist-url": "Copiar enlace del artista",
  "contextmenu.copy-album-url": "Copiar enlace del álbum",
  "contextmenu.copy-track-url": "Copiar enlace de la canción",
  "contextmenu.copy-playlist-url": "Copiar enlace de la playlist",
  "contextmenu.copy-profile-url": "Copiar enlace del perfil",
  "contextmenu.copy-station-url": "Copiar enlace de estación",
  "contextmenu.copy-chart-url": "Copiar enlace de la lista de éxitos",
  "contextmenu.copy-url": "Copiar enlace",
  "contextmenu.copy-embed": "Copiar código de incrustación",
  "contextmenu.collaborative": "Playlist colaborativa",
  "contextmenu.save": "Guardar en Tu Música",
  "contextmenu.remove": "Eliminar de Tu Música",
  "contextmenu.delete-playlist": "Eliminar",
  "contextmenu.follow": "Seguir",
  "contextmenu.unfollow": "Dejar de seguir",
  "contextmenu.publish": "Hacer pública",
  "contextmenu.unpublish": "Hacer privada",
  "contextmenu.playlist.loading": "Cargando...",
  "contextmenu.play": "Reproducir",
  "contextmenu.add-to-queue": "Añadir a la cola",
  "contextmenu.station": "Ir a radio",
  "contextmenu.station-album": "Ir a radio de álbum",
  "contextmenu.station-artist": "Ir a radio de artista",
  "contextmenu.station-playlist": "Ir a radio de playlist",
  "contextmenu.station-track": "Ir a radio de canción",
  "contextmenu.station-chart": "Ir a la radio de lista",
  "contextmenu.remove-from-playlist": "Eliminar de esta playlist",
  "contextmenu.remove-from-queue": "Eliminar de la cola de reproducción",
  "contextmenu.rename-folder": "Cambiar nombre",
  "contextmenu.rename-playlist": "Cambiar nombre",
  "contextmenu.edit-playlist": "Editar detalles",
  "contextmenu.report-playlist": "Reportar",
  "contextmenu.report-asset": "Reportar",
  "contextmenu.share": "Compartir...",
  "contextmenu.share-lyrics": "Compartir letras",
  "contextmenu.create-folder": "Crear carpeta",
  "contextmenu.create-playlist": "Crear playlist",
  "contextmenu.open-localfile-folder": "Abrir carpeta contenedora",
  "contextmenu.open-localfile-folder-mac": "Mostrar en Finder",
  "contextmenu.offline": "Disponible Offline",
  "contextmenu.goto-artist": "Ir al artista",
  "contextmenu.goto-album": "Dirígete a Álbum",
  "usermessage.default-message": "Ha ocurrido un error",
  "usermessage.update-ready": "¡Hola! Ya tenemos lista una nueva versión de Spotify para ti. <a href=\"#\" data-action=\"{0}\">Reinicia ahora</a> para que sea tuya.",
  "usermessage.update-ready-simple": "¡Hola! Ya tenemos lista una nueva versión de Spotify para ti. Reinicia ahora para que sea tuya.",
  "usermessage.play-token-lost": "Spotify ha pausado la música debido a que se está reproduciendo en otro dispositivo.",
  "usermessage.playback-paused-inactive": "Tu computadora ha estado inactiva por mucho tiempo. Haz clic en Reproducir para seguir escuchando. Si quieres música sin interrupciones, solo tienes que suscribirte a <a href=\"#\" data-action=\"{0}\">Spotify Premium</a>.",
  "usermessage.not-available-offline": "No se ha detectado ninguna conexión a Internet. Spotify intentará volver a conectarse automáticamente cuando detecte una conexión a Internet (código de error:4)",
  "usermessage.track-not-available-in-region": "Actualmente, esta canción no está disponible en {0}. Si tienes el archivo en tu computadora, puedes importarlo.",
  "usermessage.track-not-available-in-region-generic": "Actualmente, esta canción no está disponible en tu país. Si tienes el archivo en tu computadora, puedes importarlo.",
  "usermessage.track-not-available": "Esta canción no está disponible. Si tienes el archivo en tu computadora, puedes importarlo.",
  "usermessage.track-not-available-forced-offline": "Primero <a href=\"#\" data-action=\"goOnline\">desactiva el modo offline</a> y luego inténtalo de nuevo.",
  "usermessage.track-exclusive-premium": "Esta canción es exclusiva para usuarios de <a href=\"#\" data-action=\"{0}\">Spotify Premium</a> .",
  "usermessage.track-banned-by-artist": "El artista o la compañía discográfica han decidido que esta canción no esté disponible. Si tienes el archivo en tu computadora, puedes importarlo.",
  "usermessage.local-track-no-file": "Se ha agregado esta canción como archivo local. Si tienes el archivo en tu computadora, puedes importarlo.",
  "usermessage.local-track-file-not-found": "No se puede reproducir esta canción porque no se ha podido encontrar el archivo. Vuelve a importarla.",
  "usermessage.local-track-bad-format": "El archivo tiene un formato desconocido. Haz clic <a href=\"#\" data-action=\"{0}\">aquí</a> para obtener más información.",
  "usermessage.capping-reached": "Has excedido tu límite de tiempo de {0} horas. <a href=\"#\" data-action=\"{1}\">Sube de categoría a Spotify Premium</a> para escuchar sin restricciones.",
  "usermessage.local-track-drm-protected": "No se puede reproducir esta canción porque está protegida por derechos digitales (DRM).",
  "usermessage.offline-disk-cache": "Ha ocurrido un error al descargar canciones disponibles sin conexión. Es posible que tu disco esté lleno.",
  "usermessage.offline-sync-expired": "Las canciones disponibles sin conexión han expirado. Debes iniciar sesión en Spotify para reactivarlas.",
  "usermessage.offline-sync-failed": "Ha ocurrido un error al descargar algunas canciones disponibles sin conexión.",
  "usermessage.offline-too-many-tracks": "Se han elegido demasiadas canciones para escuchar en modo offline.",
  "usermessage.offline-license-server-error": "Hubo un problema con el servidor de Spotify.",
  "usermessage.offline-license-lost": "Se ha retirado el acceso sin conexión para esta computadora o dispositivo.",
  "usermessage.offline-not-allowed": "El Modo Offline solo está disponible para los suscriptores a <a href=\"#\" data-action=\"{0}\">Spotify Premium</a> .",
  "usermessage.language-changed": "Tienes que <a href=\"#\" data-action=\"{0}\">reiniciar Spotify</a> para que se apliquen los cambios",
  "usermessage.proxysettings-changed": "Tienes que <a href=\"#\" data-action=\"{0}\">reiniciar Spotify</a> para que se apliquen los cambios",
  "usermessage.language-changed-simple": "Debes reiniciar Spotify para que los cambios se apliquen",
  "usermessage.proxysettings-changed-simple": "Debes reiniciar Spotify para que los cambios se apliquen",
  "usermessage.cache-changed": "Tienes que <a href=\"#\" data-action=\"{0}\">reiniciar Spotify</a> para que se apliquen los cambios",
  "usermessage.cache-changed-simple": "Debes reiniciar Spotify para que los cambios se apliquen",
  "usermessage.feature-changed": "Tienes que <a href=\"#\" data-action=\"{0}\">reiniciar Spotify</a> para que se apliquen los cambios",
  "usermessage.first-autostart": "Spotify se ha abierto automáticamente, pero minimizado. Si prefieres, puedes establecer que Spotify <a href=\"#\" data-action=\"{0}\">se abra automáticamente sin minimizarse</a> o <a href=\"#\" data-action=\"{1}\">que no se abra para nada al inicio</a>.",
  "usermessage.cant-play-track": "No es posible reproducir la canción actual.",
  "usermessage.cant-skip-ads": "La canción seleccionada se reproducirá después del anuncio",
  "usermessage.cant-offline-playlists": "El Modo Offline es una función exclusiva de Premium. <a href=\"#\" data-action=\"{0}\">Obtén Premium</a>.",
  "usermessage.cant-set-high-quality-streaming": "Esta es una función exclusiva de Premium. <a href=\"#\" data-action=\"{0}\">Obtén Premium</a>.",
  "usermessage.payment-state-creditcard-funds": "No hemos podido renovar tu suscripción debido a un problema con el pago. Asegúrate de que tengas fondos en tu cuenta o <a href=\"#\" data-action=\"{0}\">actualiza tus datos de pago</a>.",
  "usermessage.payment-state-creditcard-refused": "No hemos podido renovar tu suscripción debido a un problema con el pago. Para conservar tu suscripción, <a href=\"#\" data-action=\"{0}\">actualiza tus datos de pago</a>.",
  "usermessage.payment-state-paypal-refused": "No hemos podido renovar tu suscripción debido a un problema con el pago. Para conservar tu suscripción, <a href=\"#\" data-action=\"{0}\">actualiza tus datos de pago</a>.",
  "usermessage.payment-state-creditcard-expiry": "La tarjeta de pago que estás usando actualmente vence en unos días. Para conservar tu suscripción, <a href=\"#\" data-action=\"{0}\">actualiza tus datos de pago</a>.",
  "usermessage.payment-state-prepaid-expiry": "Tu suscripción prepagada está a punto de vencer. ¡No te preocupes! Puedes <a href=\"#\" data-action=\"{0}\">suscribirte a Premium aquí</a>.",
  "usermessage.payment-state-churn-payment": "Lamentablemente, no pudimos obtener tu pago, de modo que tuvimos que cancelar tu suscripción. ¡No te preocupes! Puedes <a href=\"#\" data-action=\"{0}\">renovar tu suscripción aquí</a>.",
  "usermessage.payment-state-churn-partner": "Acaba de terminar tu suscripción con uno de nuestros socios, así que ahora estás usando Spotify Gratis. ¡No te preocupes! Puedes <a href=\"#\" data-action=\"{0}\">volver a Premium aquí</a>.",
  "usermessage.opt-in-trial": "¡Esperamos que estés disfrutando tu prueba gratuita! Para que no pierdas Premium cuando termine, <a href=\"#\" data-action=\"{0}\">suscríbete hoy</a>.",
  "usermessage.opt-in-trial-expired": "Tu prueba gratuita ha terminado, así que ahora estás usando Spotify Gratis. ¡No te preocupes! Puedes <a href=\"#\" data-action=\"{0}\">volver a Premium aquí</a>.",
  "usermessage.hardware-acceleration-changed": "Tienes que <a href=\"#\" data-action=\"{0}\">reiniciar Spotify</a> para que se apliquen los cambios",
  "usermessage.hardware-acceleration-changed-simple": "Debes reiniciar Spotify para que los cambios se apliquen",
  "usermessage.some-local-tracks-not-saved": "Algunas de las canciones seleccionadas no se guardaron en Tu Música. Tu Música no admite archivos locales.",
  "usermessage.illegal-playlist-name-entered": "El nombre de playlist que ingresaste no es válido.",
  "usermessage.playlist-save-failed-unknown": "La playlist no se pudo guardar debido a un error desconocido.",
  "usermessage.social-error-permissions": "Haz clic <a href=\"#\" data-action=\"{0}\">aquí</a> para permitir que tu actividad musical se comparta en Facebook.",
  "usermessage.shuffle-unplayable-track": "<a href=\"#\" data-action=\"{0}\">Mejora tu cuenta a Premium</a> para reproducir la canción que quieras, cuando quieras.",
  "usermessage.shuffle-ran-out-of-skips": "Te has quedado sin saltos (para esta hora). <a href=\"#\" data-action=\"{0}\">Mejora tu cuenta a Premium</a> para saltarte canciones tantas veces como quieras.",
  "usermessage.playlist-limit-exceeded": "Has llenado esta playlist al máximo. Impresionante. Empieza una nueva ahora para seguir coleccionando.",
  "usermessage.collection-limit-exceeded": "Tienes una colección épica, mi amigo, pero Tu Música ya está completamente llena. Para guardar más, tendrás que eliminar algunas canciones.",
  "usermessage.deprecating-os-version": "¡Aviso importante! La versión de Spotify que se lanzará próximamente ya no será compatible con tu sistema operativo. Haz clic <a href=\"#\" data-action=\"{0}\">aquí</a> para más información.",
  "usermessage.image-upload-propagation": "¡Operación exitosa! (Las imágenes pueden demorar hasta 24 horas en propagarse)",
  "usermessage.approaching-capping-limit": "Tienes menos de 1 hora para seguir escuchando gratis. Disfruta de 15 horas de música gratis cada mes o <a href=\"#\" data-action=\"{0}\">suscríbete a Premium</a> para escuchar sin límites. <a href=\"#\" data-action=\"{1}\">Más información</a>.",
  "usermessage.half-capping-limit-passed": "Has utilizado la mitad de tu límite mensual. Disfruta de 15 horas de música gratis cada mes o <a href=\"#\" data-action=\"{0}\">suscríbete a Premium</a> para escuchar sin límites. <a href=\"#\" data-action=\"{1}\">Más información</a>.",
  "usermessage.video-georestricted": "No podemos reproducir este video en tu ubicación actual.",
  "usermessage.video-unsupported-client-version": "Actualiza Spotify para reproducir este video.",
  "usermessage.video-unsupported-platform-version": "Este video no se puede reproducir en tu versión de sistema operativo.",
  "usermessage.video-country-restricted": "No podemos reproducir este video en tu ubicación actual.",
  "usermessage.video-unavailable": "Este video no está disponible. ¿Probamos con otro?",
  "usermessage.video-catalogue-restricted": "Lo sentimos, pero no podemos reproducir este video.",
  "usermessage.video-playback-error": "Lo sentimos, pero no podemos reproducir este video.",
  "about.title_label": "Acerca de Spotify",
  "about.close_button_label": "Cerrar",
  "offline-progress-msg": "Sincronizando en modo offline {0} de {1} canciones",
  "tos.updated_terms": "Términos actualizados",
  "tos.modal_title": "Términos y condiciones de uso de Spotify",
  "tos.tos_text": "<p>Hemos revisado nuestros <a href=\"{0}\">Términos y condiciones de uso</a> y nuestra <a href=\"{1}\">Política de privacidad</a>. </p><p>Al seguir haciendo uso de Spotify, estás aceptando estos términos actualizados. Por lo tanto, te pedimos que te tomes unos minutos para leerlos y comprenderlos.</p>",
  "tos.not_now_tos_text": "<p>Hemos revisado nuestros <a href=\"{0}\">Términos y condiciones de uso</a> y nuestra <a href=\"{1}\">Política de privacidad</a>. </p><p>Al hacer clic en &quot;Aceptar&quot;, estás aceptando estas actualizaciones (y el procesamiento de tus datos de la forma descrita). Por lo tanto, te pedimos que te tomes unos minutos para leerlos y comprenderlos.</p>",
  "tos.tos_text2": "<p>Si ya no deseas usar Spotify, puedes cancelar tu suscripción visitando tu página de suscripción en Spotify.</p>",
  "tos.not_now_text": "<p>Podrás seguir usando Spotify durante {0} días sin aceptar los Términos y condiciones y la Política de privacidad actualizados. Cuando venza este plazo, estarás obligado a aceptar los nuevos términos para que puedas seguir usando Spotify. A menos que canceles tu suscripción, se te seguirá cobrando mensualmente de acuerdo con tu ciclo de facturación normal. Si ya no deseas que Spotify te vuelva a hacer un cargo, puedes cancelar tu suscripción en cualquier momento. Para hacerlo, visita tu página de suscripción en Spotify.</p>",
  "tos.not_now_last_day_text": "<p>Puedes seguir usando Spotify durante 1 día sin aceptar los Términos y condiciones y la Política de privacidad actualizados. Si no aceptas estos nuevos términos para cuando haya terminado este plazo, ya no podrás usar Spotify. A menos que canceles tu suscripción, se te seguirá haciendo un cargo mensual conforme a tu ciclo de facturación normal. Si no deseas que Spotify te vuelva a hacer un cargo, puedes cancelar tu suscripción en cualquier momento, visitando tu página de suscripción en Spotify.</p>",
  "tos.not_now_text_germany": "<p>Hemos revisado nuestros <a href=\"{0}\">Términos y condiciones de uso</a> y nuestra <a href=\"{1}\">Política de privacidad</a>. Es importante que tengas en cuenta que, con tu consentimiento, Spotify GmbH pretende transferirle tu contrato a Spotify AB, Birger Jarlsgatan 61, 113 56 Estocolmo, Suecia.</p><p>Podrás seguir usando el servicio de Spotify conforme al contrato existente hasta el {2}. Después de esa fecha, para que puedas seguir usando el servicio de Spotify, tendrás que aceptar los nuevos Términos y condiciones y la nueva Política de privacidad. Al hacer clic en &quot;Aceptar&quot;, estás otorgando tu consentimiento para</p><p>a) la transferencia de tu contrato de Spotify GmbH a Spotify AB,<br />b) las actualizaciones que se le han hecho a los Términos y condiciones de uso, y<br />c) la recopilación, procesamiento y uso de tus datos personales de la forma descrita en las secciones 4, 5 y 7 de la Política de privacidad.</p>",
  "tos.not_now_text2_germany": "<p>Podrás seguir usando Spotify hasta el {0} sin aceptar los Términos y condiciones y la Política de privacidad actualizados. Cuando venza este plazo, estarás obligado a aceptar los nuevos términos para que puedas seguir usando Spotify. Si eres un usuario Premium, se te seguirá cobrando mensualmente de acuerdo con tu ciclo de facturación normal a menos que canceles tu suscripción. Si ya no deseas que Spotify te vuelva a hacer un cargo, puedes cancelar tu suscripción en cualquier momento. Para hacerlo, visita tu página de suscripción en Spotify.</p>",
  "tos.not_now_expired_text_germany": "<p>Hemos revisado nuestros <a href=\"{0}\">Términos y condiciones de uso</a> y nuestra <a href=\"{1}\">Política de privacidad</a>.</p><p>Es importante que tengas en cuenta que, con tu consentimiento, Spotify GmbH pretende transferirle tu contrato a Spotify AB, Birger Jarlsgatan 61, 113 56 Estocolmo, Suecia.</p><p>Para que puedas seguir usando el servicio de Spotify, tendrás que aceptar los nuevos Términos y condiciones y la nueva Política de privacidad. Al hacer clic en &quot;Aceptar&quot;, estás otorgando tu consentimiento para</p><p>a) la transferencia de tu contrato de Spotify GmbH a Spotify AB,<br />b) las actualizaciones que se le han hecho a los Términos y condiciones de uso, y<br />c) la recopilación, procesamiento y uso de tus datos personales de la forma descrita en las secciones 4, 5 y 7 de la Política de privacidad.</p>",
  "tos.back_button_label": "Atrás",
  "tos.ok_button_label": "OK",
  "tos.agree_button_label": "Aceptar",
  "tos.cancel_button_label": "No aceptar",
  "tos.not_now_button_label": "Ahora no",
  "licenses.modal_title": "Licencias de terceros",
  "licenses.close_button_label": "Cerrar",
  "feedback.beta_title": "Versión beta",
  "feedback.beta_text": "¿Hay algo que te encanta o que odias? Háznoslo saber.",
  "market.ad": "Andorra",
  "market.ar": "Argentina",
  "market.at": "Austria",
  "market.au": "Australia",
  "market.be": "Bélgica",
  "market.bg": "Bulgaria",
  "market.bo": "Bolivia",
  "market.br": "Brasil",
  "market.ca": "Canadá",
  "market.ch": "Suiza",
  "market.cl": "Chile",
  "market.co": "Colombia",
  "market.cr": "Costa Rica",
  "market.cy": "Chipre",
  "market.cz": "República Checa",
  "market.de": "Alemania",
  "market.dk": "Dinamarca",
  "market.do": "República Dominicana",
  "market.ec": "Ecuador",
  "market.ee": "Estonia",
  "market.es": "España",
  "market.fi": "Finlandia",
  "market.fr": "Francia",
  "market.gr": "Grecia",
  "market.gt": "Guatemala",
  "market.hk": "Hong Kong",
  "market.hn": "Honduras",
  "market.hu": "Hungría",
  "market.ie": "Irlanda",
  "market.is": "Islandia",
  "market.it": "Italia",
  "market.jp": "Japón",
  "market.li": "Liechtenstein",
  "market.lt": "Lituania",
  "market.lu": "Luxemburgo",
  "market.lv": "Letonia",
  "market.mc": "Mónaco",
  "market.mt": "Malta",
  "market.mx": "México",
  "market.my": "Malasia",
  "market.ni": "Nicaragua",
  "market.nl": "Países Bajos",
  "market.no": "Noruega",
  "market.nz": "Nueva Zelanda",
  "market.pa": "Panamá",
  "market.pe": "Perú",
  "market.ph": "Filipinas",
  "market.pl": "Polonia",
  "market.pt": "Portugal",
  "market.py": "Paraguay",
  "market.se": "Suecia",
  "market.sg": "Singapur",
  "market.sk": "Eslovaquia",
  "market.sv": "El Salvador",
  "market.tr": "Turquía",
  "market.tw": "Taiwán",
  "market.uk": "Reino Unido",
  "market.us": "Estados Unidos",
  "market.uy": "Uruguay",
  "market.za": "Sudáfrica",
  "sTitle": "Comparte tus ideas y ayúdanos a construir el mejor servicio de música del mundo",
  "sQ1Question": "¿Recomendarías Spotify a tus amigos?",
  "sQ1Negative": "Nada probable",
  "sQ1Positive": "Muy probable",
  "sQ2Question": "¿Por qué te sientes así?",
  "sQ3Question": "En general, ¿qué tan satisfecho estás con Spotify?",
  "sQ3Negative": "Muy insatisfecho",
  "sQ3Positive": "Muy satisfecho",
  "sSubmit": "Enviar encuesta",
  "sThanks": "Muchas gracias por tu colaboración. Valoramos el tiempo que nos has dedicado.",
  "sTeam": "El equipo Spotify",
  "sClose": "Cerrar",
  "cls.highlight": "Premium en pausa",
  "cls.title": "Tu último pago no pasó.",
  "cls.desc": "Agrega un nuevo método de pago para seguir escuchando con Premium. Solo te llevará un momento.",
  "cls.updatePayment": "Actualizar pago",
  "cls.cancelSubscription": "También puedes bajar de categoría a Spotify Gratis<br> <a class=\"cancel-sub\" href=\"#cancel\">cancelando tu suscripción a Premium</a>.",
  "capping.upsell-title": "Has alcanzado el límite de tiempo mensual gratuito.",
  "capping.upsell-message": "Tienes 15 horas para escuchar gratis cada mes.<br>Suscríbete a Premium para escuchar sin anuncios.",
  "capping.upsell-button-label": "Sube de categoría a Premium",
  "capping.defaultRefillMessage": "Tu período para escuchar música gratis volverá a comenzar en breve.",
  "capping.refillMessage": "Tu período para escuchar música gratis volverá a comenzar dentro de {0} días.",
  "capping.welcome-title": "Bienvenido a Spotify.",
  "capping.welcome-message": "Disfruta de 15 horas para escuchar gratis cada mes.<br> <a data-action={0}>Suscríbete a Premium</a> para escuchar sin anuncios.",
  "capping.welcome-message-button-label": "Empezar",
  "yourArtistsTooltipTitle": "Administra tus artistas",
  "yourArtistsTooltipText": "Ahora puedes editar fácilmente la imagen del perfil del artista en Spotify.",
  "yourArtists": "Tus artistas"
};
},{}],5:[function(require,module,exports){
module.exports = {
  "browse.app_name": "Explorar",
  "latest-releases.app_name": "Últimos lanzamientos",
  "discover.app_name": "Descubrir",
  "activity.app_name": "Actividad",
  "radio.app_name": "Radio",
  "settings.app_name": "Preferencias",
  "messages.app_name": "Mensajes",
  "profile.app_name": "Perfil",
  "notifications_center.app_name": "Notificaciones",
  "concerts.app_name": "Conciertos",
  "profile.private_session": "Sesión Privada",
  "profile.upgrade": "Suscríbete",
  "profile.upgrade_account": "Mejora tu cuenta",
  "profile.upgrade_tooltip": "Sube a Premium",
  "profile.account": "Cuenta",
  "profile.logout": "Cerrar sesión",
  "profile.enabled": "Activada",
  "profile.menu_label": "Menú",
  "profile.switch": "Cambiar de usuario",
  "profile.new_user": "Cambiar a nuevo usuario",
  "your_music.app_name": "Tu música",
  "your_music.songs": "Canciones",
  "your_music.artists": "Artistas",
  "your_music.albums": "Álbumes",
  "your_music.stations": "Emisoras",
  "your_music.local_files": "Archivos Locales",
  "sidebar.title_main": "Principal",
  "sidebar.title_playlists": "Playlists",
  "new_playlist.input_placeholder": "Nueva Lista",
  "new_playlist.button": "Nueva Lista",
  "accessibilitylinks.skip_to_content_label": "Saltar al contenido principal",
  "accessibilitylinks.skip_to_player_label": "Saltar a los controles del reproductor",
  "playlist.by": "de {0}",
  "playlist.loading": "Cargando...",
  "playlist.newfolder": "Nueva carpeta",
  "playlist.delete_message": "¿Seguro que quieres eliminar esta playlist?",
  "playlist.unfollow_message": "¿Seguro que quieres dejar de seguir esta playlist?",
  "playlistfolder.delete_message": "¿Seguro que quieres eliminar esta carpeta y todas las playlists que contiene?",
  "playlist.delete_confirm": "Eliminar",
  "playlist.unfollow_confirm": "Dejar de seguir",
  "playlist.delete_cancel": "Cancelar",
  "playlist.duplicates_dialog_title": "Canciones duplicadas",
  "playlist.duplicates_dialog_title_single": "Canción duplicada",
  "playlist.duplicates_dialog_body": "Algunas de estas canciones ya están en tu playlist.",
  "playlist.duplicates_dialog_body_single": "Esta canción ya está en tu playlist.",
  "playlist.duplicates_dialog_button_add": "Añadir todas",
  "playlist.duplicates_dialog_button_add_single": "Añadir de todas formas",
  "playlist.duplicates_dialog_button_skip_duplicates": "Saltar duplicadas",
  "playlist.duplicates_dialog_button_skip_single": "Saltar duplicada",
  "playlist.annotate_form.new_playlist_name": "Nueva Lista",
  "playlist.annotate_form.create_title": "Crear playlist",
  "playlist.annotate_form.create": "Crear",
  "playlist.annotate_form.cancel": "Cancelar",
  "playlist.annotate_form.edit_title": "Editar datos de la playlist",
  "playlist.annotate_form.save": "Guardar",
  "playlist.annotate_form.name_field_label": "Nombre",
  "playlist.annotate_form.name_field_placeholder": "Nombre de la playlist",
  "playlist.annotate_form.image_field_label": "Imagen",
  "playlist.annotate_form.image_pick_button_label": "Elegir imagen",
  "playlist.annotate_form.image_replace_button_label": "Cambiar imagen",
  "playlist.annotate_form.image_remove_button_label": "Eliminar imagen",
  "playlist.annotate_form.image_file_size_exceeded": "Imagen demasiado grande. Máximo: 4MB.",
  "playlist.annotate_form.image_file_upload_failed": "No se ha logrado subir la imagen. Por favor, inténtalo de nuevo.",
  "playlist.annotate_form.annotate_failed": "No se ha logrado actualizar la descripción ni la imagen. Por favor, inténtalo de nuevo.",
  "playlist.annotate_form.close-error-bar": "Ocultar",
  "playlist.annotate_form.description_field_label": "Descripción",
  "playlist.annotate_form.description_field_placeholder": "Ponle a tu playlist una descripción pegadiza.",
  "playlist.annotate_form.permission_message": "Al continuar, aceptas darle a Spotify acceso a la imagen que decidas subir. Te rogamos que te asegures de estar autorizado/a a subir esta imagen. Solo usaremos la imagen como portada de playlist.",
  "playlist.annotate_form.insert_link_button_label": "Insertar enlace",
  "playlist.annotate_form.insert_link.link_field_label": "Enlazar a",
  "playlist.annotate_form.insert_link.change_button_label": "Cambiar",
  "playlist.annotate_form.insert_link.remove_button_label": "Retirar",
  "playlist.annotate_form.insert_link.done_button_label": "Listo",
  "playlist.annotate_form.drop_to_set_image_label": "Arrastra la imagen y suéltala aquí",
  "playlist.annotate_form.drop_not_allowed_label": "Formato no compatible",
  "playlist.annotate_form.error.file_not_valid_jpg": "Ese archivo realmente no es un archivo JPG válido, pese al nombre.",
  "playlist.annotate_form.error.name_required": "Es necesario ponerle nombre a la playlist.",
  "playlist.annotate_form.error.selection_required_to_insert_link": "Es necesario seleccionar el texto que quieras convertir en un enlace.",
  "playlist.annotate_form.error.html_not_allowed": "Parece que estás intentando usar HTML, cosa que no es posible.",
  "playlist.annotate_form.error.submit": "No se han logrado guardar los cambios de la playlist. Por favor, inténtalo de nuevo.",
  "playlist.annotate_form.error.image_too_small": "Esa imagen es demasiado pequeña. Tiene que tener al menos {0}x{1}.",
  "playlist.annotate_form.warning.client_offline": "No se ha encontrado ninguna conexión a Internet. Los cambios en la descripción y la imagen no serán guardados.",
  "playlist.annotate_form.warning.no_line_breaks_in_description": "Lo sentimos, pero no es posible poner saltos de línea en la descripción.",
  "playlist.annotate_form.warning.unsaved_changes": "¿No quieres guardar tus cambios?",
  "navigation.label": "Navegación",
  "navigation.back_button_label": "Volver",
  "navigation.forward_button_label": "Avanzar",
  "search.input_placeholder": "Buscar",
  "player.label": "Controles del reproductor",
  "player.shuffle_mode_label": "Aleatoria",
  "player.repeat_mode_label": "Repetir",
  "player.queue": "Cola",
  "player.volume_button_label": "Volumen",
  "player.spotify_connect": "Spotify Connect",
  "player.connect_button_label": "Conectar a un dispositivo",
  "player.lyrics_label": "Letras",
  "player.play_button_label": "Reproducir",
  "player.pause_button_label": "Pausar",
  "player.previous_button_label": "Anterior",
  "player.next_button_label": "Siguiente",
  "player.offline_label": "Sin conexión",
  "player.thumb_up_label": "Me gusta",
  "player.thumb_down_label": "No me gusta",
  "playererror.default": "Ha habido un problema al intentar reproducir la canción seleccionada",
  "playererror.track_not_available": "Esta canción no está disponible",
  "nowplaying.label": "Sonando",
  "nowplaying.go_to_context": "Ir a lo que está sonando",
  "nowplaying.save_your_music": "Guardar en Tu música",
  "nowplaying.remove_your_music": "Eliminar de Tu música",
  "nowplaying.playing_suggested_track": "Actualmente reproduciendo canción sugerida",
  "connect.connect_text": "Conectar a un dispositivo",
  "connect.device_connecting": "Conectando…",
  "connect.device_incompatible": "Incompatible",
  "connect.device_premium_only": "Solo usuarios Premium",
  "connect.device_sleeping": "El dispositivo está en stand-by",
  "connect.device_tech_cast": "Google Cast",
  "connect.device_tech_connect": "Spotify Connect",
  "connect.device_this_computer": "Este ordenador",
  "connect.device_unavailable_for_playback": "No disponible para escuchar",
  "connect.device_unknown": "Dispositivo desconocido",
  "connect.device_unsupported_uri": "No es posible reproducir esto en este momento",
  "connect.devices_available": "Dispositivos disponibles",
  "connect.dismiss": "Cerrar",
  "connect.help1": "Connect te permite reproducir y controlar Spotify en tus dispositivos.",
  "connect.help2": "Arranca Spotify en otro dispositivo y por arte de magia aparecerá aquí.",
  "connect.help_hint": "¿Qué es Connect?",
  "connect.offline": "No disponible",
  "connect.offline_reason_computer": "Spotify no está activo en este dispositivo.",
  "connect.offline_reason_generic": "Spotify no está activo en este dispositivo.",
  "connect.offline_reason_phone": "El teléfono está bloqueado o Spotify no está en primer plano.",
  "connect.offline_reason_gameconsole": "Utiliza los ajustes de encendido de la app de Spotify para PlayStation para configurar la salida del modo de reposo de la PlayStation.",
  "connect.offline_text1": "Es necesario conectarte a Internet para poder usar esta función.",
  "connect.offline_title": "¡Estás sin conexión!",
  "connect.playingon": "Escuchando en",
  "connect.popup_title": "Dispositivos",
  "connect.remoteplayback": "Estás escuchando en {0}",
  "connect.show_more": "Mostrar más",
  "connect.upgrade": "Suscríbete",
  "connect.upsell": "Connect es una función Premium que te permite reproducir y controlar Spotify en tus dispositivos. ",
  "contextmenu.new-playlist": "Nueva Lista",
  "contextmenu.add-to-playlist": "Añadir a playlist",
  "contextmenu.owner-playlist": "de {0}",
  "contextmenu.copy-uri": "Copiar URI de Spotify",
  "contextmenu.copy-artist-url": "Copiar enlace del artista",
  "contextmenu.copy-album-url": "Copiar enlace del álbum",
  "contextmenu.copy-track-url": "Copiar enlace de la canción",
  "contextmenu.copy-playlist-url": "Copiar enlace de la playlist",
  "contextmenu.copy-profile-url": "Copiar enlace del perfil",
  "contextmenu.copy-station-url": "Copiar enlace de la emisora",
  "contextmenu.copy-chart-url": "Copiar enlace de la lista",
  "contextmenu.copy-url": "Copiar enlace",
  "contextmenu.copy-embed": "Copiar código",
  "contextmenu.collaborative": "Playlist colaborativa",
  "contextmenu.save": "Guardar en Tu música",
  "contextmenu.remove": "Eliminar de Tu música",
  "contextmenu.delete-playlist": "Eliminar",
  "contextmenu.follow": "Seguir",
  "contextmenu.unfollow": "Dejar de seguir",
  "contextmenu.publish": "Hacer pública",
  "contextmenu.unpublish": "Hacer secreta",
  "contextmenu.playlist.loading": "Cargando...",
  "contextmenu.play": "Reproducir",
  "contextmenu.add-to-queue": "Añadir a la cola",
  "contextmenu.station": "Ir a la Radio",
  "contextmenu.station-album": "Ir a radio del álbum",
  "contextmenu.station-artist": "Ir a radio del artista",
  "contextmenu.station-playlist": "Ir a radio de la playlist",
  "contextmenu.station-track": "Ir a radio de la canción",
  "contextmenu.station-chart": "Ir a radio de la lista",
  "contextmenu.remove-from-playlist": "Eliminar de esta playlist",
  "contextmenu.remove-from-queue": "Retirar de la cola",
  "contextmenu.rename-folder": "Cambiar nombre",
  "contextmenu.rename-playlist": "Cambiar nombre",
  "contextmenu.edit-playlist": "Editar datos",
  "contextmenu.report-playlist": "Denunciar",
  "contextmenu.report-asset": "Denunciar",
  "contextmenu.share": "Compartir...",
  "contextmenu.share-lyrics": "Compartir letra",
  "contextmenu.create-folder": "Crear carpeta",
  "contextmenu.create-playlist": "Crear playlist",
  "contextmenu.open-localfile-folder": "Abrir carpeta contenedora",
  "contextmenu.open-localfile-folder-mac": "Mostrar en Finder",
  "contextmenu.offline": "Disponible Offline",
  "contextmenu.goto-artist": "Ir al artista",
  "contextmenu.goto-album": "Ir al álbum",
  "usermessage.default-message": "Se ha producido un error",
  "usermessage.update-ready": "¡Hola! Tenemos una nueva versión de Spotify lista para ti. <a href=\"#\" data-action=\"{0}\">Reinicia</a> para hacerte con ella.",
  "usermessage.update-ready-simple": "¡Hola! Tenemos una nueva versión de Spotify lista para ti. Reinicia para hacerte con ella.",
  "usermessage.play-token-lost": "Spotify ha pausado la música debido a que se está reproduciendo en otro dispositivo.",
  "usermessage.playback-paused-inactive": "Tu ordenador ha estado inactivo mucho tiempo. Haz click en Reproducir para seguir escuchando. Si quieres música sin interrupciones, no tienes más que suscribirte a <a href=\"#\" data-action=\"{0}\">Spotify Premium</a>.",
  "usermessage.not-available-offline": "No se ha detectado ninguna conexión a Internet. Spotify intentará volver a conectarse automáticamente cuando detecte una conexión a Internet (código de error: 4)",
  "usermessage.track-not-available-in-region": "Esta canción no está disponible actualmente en {0}. Si tienes el archivo en el ordenador puedes importarlo.",
  "usermessage.track-not-available-in-region-generic": "Esta canción no está disponible actualmente en tu país. Si tienes el archivo en el ordenador puedes importarlo.",
  "usermessage.track-not-available": "Esta canción no está disponible. Si tienes el archivo en el ordenador puedes importarlo.",
  "usermessage.track-not-available-forced-offline": "<a href=\"#\" data-action=\"goOnline\">Desactiva el modo sin conexión</a> y prueba de nuevo.",
  "usermessage.track-exclusive-premium": "Esta canción está exclusivamente disponible para usuarios de <a href=\"#\" data-action=\"{0}\">Spotify Premium</a>.",
  "usermessage.track-banned-by-artist": "El artista o la compañía discográfica han decidido que esta canción no esté disponible. Si tienes el archivo en el ordenador puedes importarlo.",
  "usermessage.local-track-no-file": "Esta canción se ha añadido como archivo local. Si tienes el archivo en el ordenador puedes importarlo.",
  "usermessage.local-track-file-not-found": "No se puede reproducir esta canción porque no se ha podido encontrar el archivo. Por favor, vuelve a importarla.",
  "usermessage.local-track-bad-format": "El archivo tiene un formato desconocido. Haz click <a href=\"#\" data-action=\"{0}\">aquí</a> para ver más información.",
  "usermessage.capping-reached": "Has superado tu límite de {0} horas. <a href=\"#\" data-action=\"{1}\">Mejora tu cuenta con Spotify Premium</a> para disfrutar de la música sin restricciones.",
  "usermessage.local-track-drm-protected": "Esta canción no puede reproducirse porque el archivo está protegido por tecnología de gestión de derechos digitales (DRM).",
  "usermessage.offline-disk-cache": "Se ha producido un error al descargar canciones para modo sin conexión. Puede que tu disco esté lleno.",
  "usermessage.offline-sync-expired": "Las canciones en modo sin conexión han caducado. Es necesario conectarte a Spotify para volver a activarlas.",
  "usermessage.offline-sync-failed": "No se ha conseguido descargar para modo sin conexión algunas canciones.",
  "usermessage.offline-too-many-tracks": "Se han seleccionado demasiadas canciones para modo sin conexión.",
  "usermessage.offline-license-server-error": "Ha habido un problema con el servidor de Spotify.",
  "usermessage.offline-license-lost": "Se ha retirado el acceso al modo sin conexión en este ordenador/dispositivo.",
  "usermessage.offline-not-allowed": "El modo sin conexión es una función exclusiva de <a href=\"#\" data-action=\"{0}\">Spotify Premium</a>.",
  "usermessage.language-changed": "Es necesario <a href=\"#\" data-action=\"{0}\">reiniciar Spotify</a> para que el cambio surta efecto",
  "usermessage.proxysettings-changed": "Es necesario <a href=\"#\" data-action=\"{0}\">reiniciar Spotify</a> para que el cambio surta efecto",
  "usermessage.language-changed-simple": "Es necesario reiniciar Spotify para que el cambio surta efecto",
  "usermessage.proxysettings-changed-simple": "Es necesario reiniciar Spotify para que el cambio surta efecto",
  "usermessage.cache-changed": "Es necesario <a href=\"#\" data-action=\"{0}\">reiniciar Spotify</a> para que el cambio surta efecto",
  "usermessage.cache-changed-simple": "Es necesario reiniciar Spotify para que el cambio surta efecto",
  "usermessage.feature-changed": "Es necesario <a href=\"#\" data-action=\"{0}\">reiniciar Spotify</a> para que el cambio surta efecto",
  "usermessage.first-autostart": "Spotify se ha abierto automáticamente, pero minimizado. Si lo prefieres, puedes hacer que <a href=\"#\" data-action=\"{0}\">se abra automáticamente sin que esté minimizado</a> o que <a href=\"#\" data-action=\"{1}\">no se abra automáticamente al iniciar</a>.",
  "usermessage.cant-play-track": "No es posible reproducir la canción actual.",
  "usermessage.cant-skip-ads": "La canción seleccionada se reproducirá después del anuncio",
  "usermessage.cant-offline-playlists": "El modo sin conexión es una función exclusiva de Premium. <a href=\"#\" data-action=\"{0}\">Conseguir Premium</a>.",
  "usermessage.cant-set-high-quality-streaming": "Esta es una función exclusiva de Premium. <a href=\"#\" data-action=\"{0}\">Conseguir Premium</a>.",
  "usermessage.payment-state-creditcard-funds": "No hemos podido renovar tu suscripción por un problema en el pago. Por favor, comprueba que tengas fondos en tu cuenta o <a href=\"#\" data-action=\"{0}\">actualiza tus datos de pago</a>.",
  "usermessage.payment-state-creditcard-refused": "No hemos podido renovar tu suscripción por un problema en el pago. Si quieres mantener tu suscripción, te rogamos que <a href=\"#\" data-action=\"{0}\">actualices tus datos de pago</a>.",
  "usermessage.payment-state-paypal-refused": "No hemos podido renovar tu suscripción por un problema en el pago. Si quieres mantener tu suscripción, te rogamos que <a href=\"#\" data-action=\"{0}\">actualices tus datos de pago</a>.",
  "usermessage.payment-state-creditcard-expiry": "La tarjeta de pago que estás usando actualmente caduca dentro de unos días. Si quieres mantener tu suscripción, te rogamos que <a href=\"#\" data-action=\"{0}\">actualices tus datos de pago</a>.",
  "usermessage.payment-state-prepaid-expiry": "Tu suscripción prepago está a punto de caducar. Pero no te preocupes, puedes <a href=\"#\" data-action=\"{0}\">suscribirte a Premium aquí</a>.",
  "usermessage.payment-state-churn-payment": "Por desgracia, no hemos podido cobrar tu pago, por lo que hemos tenido que cancelar tu suscripción. Pero no te preocupes, puedes <a href=\"#\" data-action=\"{0}\">renovar tu suscripción aquí</a>.",
  "usermessage.payment-state-churn-partner": "Tu suscripción a través de uno de nuestros socios acaba de terminarse, por lo que ahora tienes Spotify Free. Pero no te preocupes, puedes <a href=\"#\" data-action=\"{0}\">volver a Premium aquí</a>.",
  "usermessage.opt-in-trial": "Esperamos que estés disfrutando con tu prueba gratuita. Para no quedarte sin Premium cuando se acabe, <a href=\"#\" data-action=\"{0}\">suscríbete hoy mismo</a>.",
  "usermessage.opt-in-trial-expired": "Tu prueba gratuita se ha terminado, por lo que ahora tienes Spotify Free. Pero no te preocupes, puedes <a href=\"#\" data-action=\"{0}\">volver a Premium aquí</a>.",
  "usermessage.hardware-acceleration-changed": "Es necesario <a href=\"#\" data-action=\"{0}\">reiniciar Spotify</a> para que el cambio surta efecto",
  "usermessage.hardware-acceleration-changed-simple": "Es necesario reiniciar Spotify para que el cambio surta efecto",
  "usermessage.some-local-tracks-not-saved": "Algunas de las canciones seleccionadas no se han guardado en Tu música. No es posible guardar en Tu música archivos locales.",
  "usermessage.illegal-playlist-name-entered": "El nombre de playlist introducido no es válido.",
  "usermessage.playlist-save-failed-unknown": "No se ha podido guardar la playlist por un error desconocido.",
  "usermessage.social-error-permissions": "Haz click <a href=\"#\" data-action=\"{0}\">aquí</a> para permitir que tu actividad musical se comparta en Facebook.",
  "usermessage.shuffle-unplayable-track": "<a href=\"#\" data-action=\"{0}\">Sube a Premium</a> para escuchar la canción que quieras a la carta.",
  "usermessage.shuffle-ran-out-of-skips": "Ya no quedan más saltos de canción (por esta hora). <a href=\"#\" data-action=\"{0}\">Sube a Premium</a> para saltar todas las veces que quieras.",
  "usermessage.playlist-limit-exceeded": "Has llenado esta playlist hasta el máximo. Estamos impresionados. Para seguir coleccionando, abre una nueva.",
  "usermessage.collection-limit-exceeded": "¡Menuda colección tienes! El espacio de Tu música está lleno. Si quieres guardar más, tendrás que retirar alguna canción.",
  "usermessage.deprecating-os-version": "¡Notificación importante! A partir de una actualización próxima, no habrá más actualizaciones para tu sistema operativo. Haz click <a href=\"#\" data-action=\"{0}\">aquí</a> si quieres más información.",
  "usermessage.image-upload-propagation": "¡Hecho! Nota: las imágenes pueden tardar hasta 24 horas en aparecer.",
  "usermessage.approaching-capping-limit": "Te queda menos de 1 hora de música gratis. Puedes disfrutar de 15 horas de servicio gratuito cada mes o <a href=\"#\" data-action=\"{0}\">subir a Premium</a> para escuchar música sin límites. <a href=\"#\" data-action=\"{1}\">Saber más</a>.",
  "usermessage.half-capping-limit-passed": "Has consumido la mitad de tu límite mensual. Puedes disfrutar de 15 horas de servicio gratuito cada mes o <a href=\"#\" data-action=\"{0}\">subir a Premium</a> para escuchar música sin límites. <a href=\"#\" data-action=\"{1}\">Saber más</a>.",
  "usermessage.video-georestricted": "No nos es posible reproducir este vídeo en tu ubicación actual.",
  "usermessage.video-unsupported-client-version": "Es necesario cambiar a Premium para reproducir este vídeo.",
  "usermessage.video-unsupported-platform-version": "Este vídeo no puede reproducirse con la versión que tienes de tu sistema operativo.",
  "usermessage.video-country-restricted": "No nos es posible reproducir este vídeo en tu ubicación actual.",
  "usermessage.video-unavailable": "Este vídeo no está disponible. ¿Quieres probar con otro?",
  "usermessage.video-catalogue-restricted": "Lo sentimos, pero no nos es posible reproducir este vídeo.",
  "usermessage.video-playback-error": "Lo sentimos, pero no nos es posible reproducir este vídeo.",
  "about.title_label": "Acerca de Spotify",
  "about.close_button_label": "Cerrar",
  "offline-progress-msg": "Sincronizando para modo sin conexión {0} canciones de {1}",
  "tos.updated_terms": "Actualización de las condiciones",
  "tos.modal_title": "Términos y Condiciones de Uso de Spotify",
  "tos.tos_text": "<p>Hemos revisado nuestros <a href=\"{0}\">Términos y Condiciones de Uso</a> y nuestra <a href=\"{1}\">Política de Privacidad</a>.</p><p>Al continuar usando Spotify, aceptas estas actualizaciones, por lo que te rogamos que dediques unos minutos a leerlas y comprenderlas.</p>",
  "tos.not_now_tos_text": "<p>Hemos revisado nuestros <a href=\"{0}\">Términos y Condiciones de Uso</a> y nuestra <a href=\"{1}\">Política de Privacidad</a>.</p><p>Al hacer click en &quot;Aceptar&quot;, aceptas estas actualizaciones (y el procesamiento de tus datos que en ellas se describe), por lo que te rogamos que dediques unos minutos a leerlas y comprenderlas.</p>",
  "tos.tos_text2": "<p>Si no quieres seguir usando Spotify, puedes cancelar tu suscripción entrando en tu página de suscripción de Spotify.</p>",
  "tos.not_now_text": "<p>Puedes continuar usando Spotify durante {0} días sin aceptar los Términos y Condiciones y la Política de Privacidad actualizados. Al llegar a ese momento, tendrás que aceptar las nuevas condiciones para poder seguir usando Spotify. A menos que canceles tu suscripción, se te seguirá facturando cada mes conforme a tu ciclo de facturación normal. Si no quieres que Spotify te cobre, puedes cancelar tu suscripción cuando quieras entrando en tu página de suscripción de Spotify.</p>",
  "tos.not_now_last_day_text": "<p>Puedes continuar usando Spotify durante 1 día sin aceptar los Términos y Condiciones y Política de Privacidad actualizados. Si para cuando termine este plazo no has aceptado las nuevas condiciones, dejarás de poder usar Spotify. Salvo que canceles tu suscripción, se te continuará facturando cada mes en tu ciclo de facturación normal. Si no quieres que Spotify te cobre, puedes cancelar tu suscripción cuando quieras entrando en tu página de suscripción de Spotify.</p>",
  "tos.not_now_text_germany": "<p>Hemos revisado nuestros <a href=\"{0}\">Términos y Condiciones de Uso</a> y nuestra <a href=\"{1}\">Política de Privacidad</a>. Ten en cuenta que, con tu consentimiento, Spotify GmbH tiene previsto transferir tu contrato a Spotify AB, Birger Jarlsgatan 61, 113 56 Estocolmo, Suecia.</p><p>Puedes continuar usando el servicio de Spotify bajo el contrato actual hasta el {2}. Tras esta fecha, para poder continuar usando el servicio de Spotify, tendrás que aceptar los nuevos Términos y Condiciones y Política de Privacidad. Al hacer click en “Aceptar”, das tu consentimiento a</p><p>a) la transferencia de tu contrato de Spotify GmbH a Spotify AB,<br />b) las actualizaciones de los Términos y Condiciones de Uso y<br />c) la recopilación, procesamiento y uso de tus datos personales tal y como se describe en las secciones 4, 5 y 7 de la Política de Privacidad.</p>",
  "tos.not_now_text2_germany": "<p>Puedes continuar usando Spotify hasta el {0} sin aceptar los Términos y Condiciones y la Política de Privacidad actualizados. Al llegar a ese momento, tendrás que aceptar las nuevas condiciones para poder seguir usando Spotify. Si eres usuario Premium, se te continuará facturando cada mes conforme a tu ciclo de facturación normal, a menos que canceles tu suscripción. Si no quieres que Spotify te cobre, puedes cancelar tu suscripción cuando quieras entrando en tu página de suscripción de Spotify.</p>",
  "tos.not_now_expired_text_germany": "<p>Hemos revisado nuestros <a href=\"{0}\">Términos y Condiciones de Uso</a> y nuestra <a href=\"{1}\">Política de Privacidad</a>.</p><p>Ten en cuenta que, con tu consentimiento, Spotify GmbH tiene previsto transferir tu contrato a Spotify AB, Birger Jarlsgatan 61, 113 56 Estocolmo, Suecia.</p><p>Para poder continuar usando el servicio de Spotify, tienes que aceptar los nuevos Términos y Condiciones y Política de Privacidad. Al hacer click en “Aceptar”, das tu consentimiento a</p><p>a) la transferencia de tu contrato de Spotify GmbH a Spotify AB,<br />b) las actualizaciones de los Términos y Condiciones de Uso y<br />c) la recopilación, procesamiento y uso de tus datos personales tal y como se describe en las secciones 4, 5 y 7 de la Política de Privacidad.</p>",
  "tos.back_button_label": "Atrás",
  "tos.ok_button_label": "OK",
  "tos.agree_button_label": "Aceptar",
  "tos.cancel_button_label": "No aceptar",
  "tos.not_now_button_label": "Ahora no",
  "licenses.modal_title": "Licencias de terceros",
  "licenses.close_button_label": "Cerrar",
  "feedback.beta_title": "Versión Beta",
  "feedback.beta_text": "¿Hay algo que te encante o que odies? ¡No dudes en decírnoslo!",
  "market.ad": "Andorra",
  "market.ar": "Argentina",
  "market.at": "Austria",
  "market.au": "Australia",
  "market.be": "Bélgica",
  "market.bg": "Bulgaria",
  "market.bo": "Bolivia",
  "market.br": "Brasil",
  "market.ca": "Canadá",
  "market.ch": "Suiza",
  "market.cl": "Chile",
  "market.co": "Colombia",
  "market.cr": "Costa Rica",
  "market.cy": "Chipre",
  "market.cz": "República Checa",
  "market.de": "Alemania",
  "market.dk": "Dinamarca",
  "market.do": "República Dominicana",
  "market.ec": "Ecuador",
  "market.ee": "Estonia",
  "market.es": "España",
  "market.fi": "Finlandia",
  "market.fr": "Francia",
  "market.gr": "Grecia",
  "market.gt": "Guatemala",
  "market.hk": "Hong Kong",
  "market.hn": "Honduras",
  "market.hu": "Hungría",
  "market.ie": "Irlanda",
  "market.is": "Islandia",
  "market.it": "Italia",
  "market.jp": "Japón",
  "market.li": "Liechtenstein",
  "market.lt": "Lituania",
  "market.lu": "Luxemburgo",
  "market.lv": "Letonia",
  "market.mc": "Mónaco",
  "market.mt": "Malta",
  "market.mx": "México",
  "market.my": "Malasia",
  "market.ni": "Nicaragua",
  "market.nl": "Países Bajos",
  "market.no": "Noruega",
  "market.nz": "Nueva Zelanda",
  "market.pa": "Panamá",
  "market.pe": "Perú",
  "market.ph": "Filipinas",
  "market.pl": "Polonia",
  "market.pt": "Portugal",
  "market.py": "Paraguay",
  "market.se": "Suecia",
  "market.sg": "Singapur",
  "market.sk": "Eslovaquia",
  "market.sv": "El Salvador",
  "market.tr": "Turquía",
  "market.tw": "Taiwán",
  "market.uk": "Reino Unido",
  "market.us": "Estados Unidos",
  "market.uy": "Uruguay",
  "market.za": "Sudáfrica",
  "sTitle": "¡Comparte tus opiniones y ayúdanos a desarrollar el servicio de música más grande del mundo!",
  "sQ1Question": "¿Qué probabilidad hay de que recomiendes Spotify a un amigo o compañero?",
  "sQ1Negative": "Ninguna",
  "sQ1Positive": "Muy alta",
  "sQ2Question": "¿Por qué opinas así?",
  "sQ3Question": "En general, ¿cuál es tu nivel de satisfacción con Spotify?",
  "sQ3Negative": "Muy poca satisfacción",
  "sQ3Positive": "Mucha satisfacción",
  "sSubmit": "Enviar encuesta.",
  "sThanks": "Tu ayuda es muy importante para nosotros. Muchas gracias por el tiempo que nos has dedicado.",
  "sTeam": "El equipo Spotify",
  "sClose": "Cerrar",
  "cls.highlight": "Premium en pausa",
  "cls.title": "Tu último pago no funcionó.",
  "cls.desc": "Continúa disfrutando de la música con Premium añadiendo una nueva forma de pago. Solo te llevará un momento.",
  "cls.updatePayment": "Actualizar pago",
  "cls.cancelSubscription": "También puedes bajar de categoría a Spotify Free,<br> <a class=\"cancel-sub\" href=\"#cancel\">cancelando tu suscripción Premium</a>.",
  "capping.upsell-title": "Has llegado a tu límite de servicio gratuito.",
  "capping.upsell-message": "Cada mes tienes 15 horas de servicio gratis.<br />Sube a Premium para disfrutar de música sin límites y sin anuncios.",
  "capping.upsell-button-label": "Sube a Premium",
  "capping.defaultRefillMessage": "Tu tiempo de servicio gratuito será recargado pronto.",
  "capping.refillMessage": "Tu tiempo de servicio gratuito será recargado dentro de los próximos {0} días.",
  "capping.welcome-title": "Bienvenido a Spotify.",
  "capping.welcome-message": "Cada mes puedes disfrutar de 15 horas de servicio gratis.<br /> <a data-action={0}>Sube a Premium</a> para tener música sin límites y sin anuncios.",
  "capping.welcome-message-button-label": "Empezar",
  "yourArtistsTooltipTitle": "Administrar tus artistas",
  "yourArtistsTooltipText": "Ahora puedes editar fácilmente tu imagen de perfil de artista en Spotify.",
  "yourArtists": "Tus artistas"
};
},{}],6:[function(require,module,exports){
module.exports = {
  "browse.app_name": "Browse",
  "latest-releases.app_name": "Uusimmat julkaisut",
  "discover.app_name": "Discover",
  "activity.app_name": "Tapahtumat",
  "radio.app_name": "Radio",
  "settings.app_name": "Asetukset",
  "messages.app_name": "Viestit",
  "profile.app_name": "Profiili",
  "notifications_center.app_name": "Ilmoitukset",
  "concerts.app_name": "Konsertit",
  "profile.private_session": "Yksityinen istunto",
  "profile.upgrade": "Päivitä",
  "profile.upgrade_account": "Päivitä tilisi",
  "profile.upgrade_tooltip": "Päivitä tilaus Premiumiksi",
  "profile.account": "Tili",
  "profile.logout": "Kirjaudu ulos",
  "profile.enabled": "Käytössä",
  "profile.menu_label": "Valikko",
  "profile.switch": "Vaihda käyttäjä",
  "profile.new_user": "Vaihda käyttäjäksi uusi käyttäjä",
  "your_music.app_name": "Oma musiikki",
  "your_music.songs": "Kappaleet",
  "your_music.artists": "Artistit",
  "your_music.albums": "Albumit",
  "your_music.stations": "Asemat",
  "your_music.local_files": "Paikalliset tiedostot",
  "sidebar.title_main": "Päävalikko",
  "sidebar.title_playlists": "Soittolistat",
  "new_playlist.input_placeholder": "Uusi soittolista",
  "new_playlist.button": "Uusi soittolista",
  "accessibilitylinks.skip_to_content_label": "Siirry pääsisältöön",
  "accessibilitylinks.skip_to_player_label": "Siirry soittimen ohjaimiin",
  "playlist.by": "- {0}",
  "playlist.loading": "Ladataan...",
  "playlist.newfolder": "Uusi kansio",
  "playlist.delete_message": "Haluatko varmasti poistaa tämän soittolistan?",
  "playlist.unfollow_message": "Haluatko varmasti lopettaa tämän soittolistan seuraamisen?",
  "playlistfolder.delete_message": "Haluatko varmasti poistaa tämän kansion ja kaikki sen sisältämät soittolistat?",
  "playlist.delete_confirm": "Poista",
  "playlist.unfollow_confirm": "Lopeta seuraaminen",
  "playlist.delete_cancel": "Peruuta",
  "playlist.duplicates_dialog_title": "Kappaleiden kaksoiskappaleet",
  "playlist.duplicates_dialog_title_single": "Kappaleen kaksoiskappale",
  "playlist.duplicates_dialog_body": "Jotkin näistä kappaleista ovat jo soittolistassasi.",
  "playlist.duplicates_dialog_body_single": "Tämä kappale on jo soittolistassasi.",
  "playlist.duplicates_dialog_button_add": "Lisää kaikki",
  "playlist.duplicates_dialog_button_add_single": "Lisää silti",
  "playlist.duplicates_dialog_button_skip_duplicates": "Ohita kaksoiskappaleet",
  "playlist.duplicates_dialog_button_skip_single": "Ohita kaksoiskappale",
  "playlist.annotate_form.new_playlist_name": "Uusi soittolista",
  "playlist.annotate_form.create_title": "Luo soittolista",
  "playlist.annotate_form.create": "Luo",
  "playlist.annotate_form.cancel": "Peruuta",
  "playlist.annotate_form.edit_title": "Muokkaa soittolistan tietoja",
  "playlist.annotate_form.save": "Tallenna",
  "playlist.annotate_form.name_field_label": "Nimi",
  "playlist.annotate_form.name_field_placeholder": "Soittolistan nimi",
  "playlist.annotate_form.image_field_label": "Kuva",
  "playlist.annotate_form.image_pick_button_label": "Valitse kuva",
  "playlist.annotate_form.image_replace_button_label": "Vaihda kuva",
  "playlist.annotate_form.image_remove_button_label": "Poista kuva",
  "playlist.annotate_form.image_file_size_exceeded": "Kuva on liian suuri. Enimmäiskoko on 4 Mt.",
  "playlist.annotate_form.image_file_upload_failed": "Kuvan lataaminen epäonnistui. Yritä uudelleen.",
  "playlist.annotate_form.annotate_failed": "Kuvauksen ja kuvan päivittäminen epäonnistui. Yritä uudelleen.",
  "playlist.annotate_form.close-error-bar": "Piilota",
  "playlist.annotate_form.description_field_label": "Kuvaus",
  "playlist.annotate_form.description_field_placeholder": "Anna soittolistallesi tarttuva kuvaus.",
  "playlist.annotate_form.permission_message": "Jatkamalla annat Spotifylle pääsyn lataamaasi kuvaan. Varmista, että sinulla on oikeus kuvan lataamiseen. Käytämme kuvaa ainoastaan soittolistan kansikuvana.",
  "playlist.annotate_form.insert_link_button_label": "Lisää linkki",
  "playlist.annotate_form.insert_link.link_field_label": "Linkki kohteeseen",
  "playlist.annotate_form.insert_link.change_button_label": "Muuta",
  "playlist.annotate_form.insert_link.remove_button_label": "Poista",
  "playlist.annotate_form.insert_link.done_button_label": "Valmis",
  "playlist.annotate_form.drop_to_set_image_label": "Aseta kuva pudottamalla",
  "playlist.annotate_form.drop_not_allowed_label": "Muoto ei ole tuettu",
  "playlist.annotate_form.error.file_not_valid_jpg": "Nimestään huolimatta tiedosto ei ole kelvollinen JPG-tiedosto.",
  "playlist.annotate_form.error.name_required": "Anna soittolistalle nimi.",
  "playlist.annotate_form.error.selection_required_to_insert_link": "Valitse teksti, josta haluat tehdä linkin.",
  "playlist.annotate_form.error.html_not_allowed": "Näyttää siltä, että yrität käyttää HTML:ää, mikä ei ole mahdollista.",
  "playlist.annotate_form.error.submit": "Soittolistan muutosten tallentaminen epäonnistui. Yritä uudelleen.",
  "playlist.annotate_form.error.image_too_small": "Kuva on liian pieni. Sen täytyy olla vähintään {0} x {1},",
  "playlist.annotate_form.warning.client_offline": "Internetyhteyttä ei ole. Kuvaukseen ja kuvaan tehdyt muutokset eivät tallennu.",
  "playlist.annotate_form.warning.no_line_breaks_in_description": "Valitettavasti kuvauksessa ei voi käyttää rivinvaihtoja.",
  "playlist.annotate_form.warning.unsaved_changes": "Etkö halua tallentaa tekemiäsi muutoksia?",
  "navigation.label": "Siirtyminen",
  "navigation.back_button_label": "Siirry taaksepäin",
  "navigation.forward_button_label": "Siirry eteenpäin",
  "search.input_placeholder": "Hae",
  "player.label": "Soittimen ohjaimet",
  "player.shuffle_mode_label": "Satunnaistoisto",
  "player.repeat_mode_label": "Toista uudelleen",
  "player.queue": "Näytä jono",
  "player.volume_button_label": "Äänenvoimakkuus",
  "player.spotify_connect": "Spotify Connect",
  "player.connect_button_label": "Liitä laitteeseen",
  "player.lyrics_label": "Sanat",
  "player.play_button_label": "Toista",
  "player.pause_button_label": "Tauko",
  "player.previous_button_label": "Edellinen",
  "player.next_button_label": "Seuraava",
  "player.offline_label": "Offline",
  "player.thumb_up_label": "Yläpeukku",
  "player.thumb_down_label": "Alapeukku",
  "playererror.default": "Ilmeni ongelma yritettäessä toistaa valittua kappaletta",
  "playererror.track_not_available": "Tämä kappale ei ole saatavana",
  "nowplaying.label": "Nyt soi",
  "nowplaying.go_to_context": "Siirry nyt soitettavaan",
  "nowplaying.save_your_music": "Tallenna Omaan musiikkiin",
  "nowplaying.remove_your_music": "Poista Omasta musiikista",
  "nowplaying.playing_suggested_track": "Nyt soi ehdotettu kappale",
  "connect.connect_text": "Liitä laitteeseen",
  "connect.device_connecting": "Yhdistetään…",
  "connect.device_incompatible": "Ei yhteensopiva",
  "connect.device_premium_only": "Vain Premium-käyttäjät",
  "connect.device_sleeping": "Laite on horrostilassa",
  "connect.device_tech_cast": "Google Cast",
  "connect.device_tech_connect": "Spotify Connect",
  "connect.device_this_computer": "Tämä tietokone",
  "connect.device_unavailable_for_playback": "Ei voi kuunnella laitteella",
  "connect.device_unknown": "Tuntematon laite",
  "connect.device_unsupported_uri": "Tätä ei voi toistaa juuri nyt",
  "connect.devices_available": "Käytettävissä olevat laitteet",
  "connect.dismiss": "Hylkää",
  "connect.help1": "Connect-toiminnon avulla voit käyttää ja ohjata Spotifyta laitteissasi.",
  "connect.help2": "Kun käynnistät Spotifyn toisessa laitteessa, se tulee näkyviin tähän.",
  "connect.help_hint": "Mikä Connect on?",
  "connect.offline": "Ei käytettävissä",
  "connect.offline_reason_computer": "Spotify ei ole käytössä tässä laitteessa.",
  "connect.offline_reason_generic": "Spotify ei ole käytössä tässä laitteessa.",
  "connect.offline_reason_phone": "Puhelin on lukittu, tai Spotify ei ole etualalla.",
  "connect.offline_reason_gameconsole": "Jos haluat ottaa käyttöön PlayStationin käynnistämisen valmiustilasta, muuta Spotifyn PlayStation-sovelluksen virta-asetuksia.",
  "connect.offline_text1": "Jotta voit käyttää tätä ominaisuutta, sinun on siirryttävä online-tilaan.",
  "connect.offline_title": "Olet offline-tilassa!",
  "connect.playingon": "Kuunnellaan laitteella",
  "connect.popup_title": "Laitteet",
  "connect.remoteplayback": "Kuuntelet laitteella {0}",
  "connect.show_more": "Näytä lisää",
  "connect.upgrade": "Päivitä",
  "connect.upsell": "Connect on Premium-version ominaisuus, jonka avulla voit käyttää ja ohjata Spotifyta laitteissasi.",
  "contextmenu.new-playlist": "Uusi soittolista",
  "contextmenu.add-to-playlist": "Lisää soittolistaan",
  "contextmenu.owner-playlist": "- {0}",
  "contextmenu.copy-uri": "Kopioi Spotify-URI",
  "contextmenu.copy-artist-url": "Kopioi artistin linkki",
  "contextmenu.copy-album-url": "Kopioi albumin linkki",
  "contextmenu.copy-track-url": "Kopioi kappalelinkki",
  "contextmenu.copy-playlist-url": "Kopioi soittolistan linkki",
  "contextmenu.copy-profile-url": "Kopioi profiilin linkki",
  "contextmenu.copy-station-url": "Kopioi aseman linkki",
  "contextmenu.copy-chart-url": "Kopioi listan linkki",
  "contextmenu.copy-url": "Kopioi linkki",
  "contextmenu.copy-embed": "Kopioi upotettava koodi",
  "contextmenu.collaborative": "Yhteissoittolista",
  "contextmenu.save": "Tallenna Omaan musiikkiin",
  "contextmenu.remove": "Poista Omasta musiikista",
  "contextmenu.delete-playlist": "Poista",
  "contextmenu.follow": "Seuraa",
  "contextmenu.unfollow": "Lopeta seuraaminen",
  "contextmenu.publish": "Määritä julkiseksi",
  "contextmenu.unpublish": "Määritä salaiseksi",
  "contextmenu.playlist.loading": "Ladataan...",
  "contextmenu.play": "Toista",
  "contextmenu.add-to-queue": "Lisää jonoon",
  "contextmenu.station": "Siirry radioon",
  "contextmenu.station-album": "Siirry albumiradioon",
  "contextmenu.station-artist": "Siirry artistiradioon",
  "contextmenu.station-playlist": "Siirry soittolistaradioon",
  "contextmenu.station-track": "Siirry kappaleradioon",
  "contextmenu.station-chart": "Siirry listaradioon",
  "contextmenu.remove-from-playlist": "Poista tästä soittolistasta",
  "contextmenu.remove-from-queue": "Poista jonosta",
  "contextmenu.rename-folder": "Nimeä uudelleen",
  "contextmenu.rename-playlist": "Nimeä uudelleen",
  "contextmenu.edit-playlist": "Muokkaa tietoja",
  "contextmenu.report-playlist": "Ilmoita",
  "contextmenu.report-asset": "Ilmoita",
  "contextmenu.share": "Jaa...",
  "contextmenu.share-lyrics": "Jaa sanat",
  "contextmenu.create-folder": "Luo kansio",
  "contextmenu.create-playlist": "Luo soittolista",
  "contextmenu.open-localfile-folder": "Avaa sijaintikansio",
  "contextmenu.open-localfile-folder-mac": "Näytä hakutoiminnossa",
  "contextmenu.offline": "Käytettävissä offline-tilassa",
  "contextmenu.goto-artist": "Siirry artistiin",
  "contextmenu.goto-album": "Siirry albumiin",
  "usermessage.default-message": "Tapahtui virhe",
  "usermessage.update-ready": "Hei. Meillä on uusi Spotify-versio valmiina sinua varten. <a href=\"#\" data-action=\"{0}\">Käynnistä sovellus uudelleen</a>, niin saat uuden version käyttöösi.",
  "usermessage.update-ready-simple": "Hei. Meillä on uusi Spotify-versio valmiina sinua varten. Käynnistä sovellus uudelleen, niin saat uuden version käyttöösi.",
  "usermessage.play-token-lost": "Spotify on pysäytetty, koska tilisi on käytössä jossain muualla.",
  "usermessage.playback-paused-inactive": "Tietokoneesi on ollut kauan toimettomana. Jatka kuuntelua valitsemalla Soita. Jos haluat kuunnella musiikkia keskeytyksittä, tilaa <a href=\"#\" data-action=\"{0}\">Spotify Premium</a>.",
  "usermessage.not-available-offline": "Ei internetyhteyttä. Spotify yrittää muodostaa yhteyden uudelleen automaattisesti, kun internetyhteys on havaittu (virhekoodi: 4).",
  "usermessage.track-not-available-in-region": "Tämä kappale ei toistaiseksi ole saatavana sijainnissa {0}. Jos tiedosto on tietokoneessasi, voit tuoda sen.",
  "usermessage.track-not-available-in-region-generic": "Tämä kappale ei tällä hetkellä ole saatavana maassasi. Jos tiedosto on tietokoneessasi, voit tuoda sen.",
  "usermessage.track-not-available": "Tämä kappale ei ole saatavana. Jos tiedosto on tietokoneessasi, voit tuoda sen.",
  "usermessage.track-not-available-forced-offline": "<a href=\"#\" data-action=\"goOnline\">Poistu offline-tilasta</a> ja yritä uudelleen.",
  "usermessage.track-exclusive-premium": "Tämä kappale on vain <a href=\"#\" data-action=\"{0}\">Spotify Premium</a> -käyttäjien käytettävissä.",
  "usermessage.track-banned-by-artist": "Artisti tai levy-yhtiö ei salli tämän kappaleen käyttöä. Jos tiedosto on tietokoneessasi, voit tuoda sen.",
  "usermessage.local-track-no-file": "Kappale lisättiin paikallisena tiedostona. Jos tiedosto on tietokoneessasi, voit tuoda sen.",
  "usermessage.local-track-file-not-found": "Kappaletta ei voi soittaa, koska tiedostoa ei löydy. Tuo tiedosto uudelleen.",
  "usermessage.local-track-bad-format": "Tuntematon tiedostomuoto. Saat lisätietoja napsauttamalla <a href=\"#\" data-action=\"{0}\">tätä</a>.",
  "usermessage.capping-reached": "Olet ylittänyt {0} tunnin aikarajan. <a href=\"#\" data-action=\"{1}\">Päivitä tilaus Spotify Premium -tasolle,</a> jotta voit kuunnella ilman rajoituksia.",
  "usermessage.local-track-drm-protected": "Kappaletta ei voi soittaa, koska tiedosto on DRM-suojattu.",
  "usermessage.offline-disk-cache": "Offline-kappaleiden lataus epäonnistui. Onko kiintolevysi täynnä?",
  "usermessage.offline-sync-expired": "Offline-kappaleet ovat vanhentuneet. Kirjaudu Spotifyhin ja aktivoi ne uudelleen.",
  "usermessage.offline-sync-failed": "Joidenkin offline-kappaleiden lataus epäonnistui.",
  "usermessage.offline-too-many-tracks": "Olet valinnut liian monta kappaletta soitettaviksi offline-tilassa.",
  "usermessage.offline-license-server-error": "Spotify-palvelimessa ilmeni ongelma.",
  "usermessage.offline-license-lost": "Tämän tietokoneen tai laitteen offline-käyttö on peruutettu.",
  "usermessage.offline-not-allowed": "Musiikin toistaminen offline-tilassa on <a href=\"#\" data-action=\"{0}\">Spotify Premium</a> -tilaukseen sisältyvä palvelu.",
  "usermessage.language-changed": "<a href=\"#\" data-action=\"{0}\">Käynnistä Spotify uudelleen</a>, jotta muutokset tulevat voimaan.",
  "usermessage.proxysettings-changed": "<a href=\"#\" data-action=\"{0}\">Käynnistä Spotify uudelleen</a>, jotta muutokset tulevat voimaan.",
  "usermessage.language-changed-simple": "Käynnistä Spotify uudelleen, jotta muutokset tulevat voimaan.",
  "usermessage.proxysettings-changed-simple": "Käynnistä Spotify uudelleen, jotta muutokset tulevat voimaan.",
  "usermessage.cache-changed": "<a href=\"#\" data-action=\"{0}\">Käynnistä Spotify uudelleen</a>, jotta muutokset tulevat voimaan.",
  "usermessage.cache-changed-simple": "Käynnistä Spotify uudelleen, jotta muutokset tulevat voimaan.",
  "usermessage.feature-changed": "<a href=\"#\" data-action=\"{0}\">Käynnistä Spotify uudelleen</a>, jotta muutokset tulevat voimaan.",
  "usermessage.first-autostart": "Spotify avautui automaattisesti, mutta se on pienennetty. Voit halutessasi <a href=\"#\" data-action=\"{0}\">määrittää Spotifyn avautumaan automaattisesti ilman pienennystä</a> tai <a href=\"#\" data-action=\"{1}\">määrittää, ettei Spotify avaudu käynnistyksen yhteydessä</a> lainkaan.",
  "usermessage.cant-play-track": "Nykyistä kappaletta ei voi toistaa.",
  "usermessage.cant-skip-ads": "Valittu kappale soitetaan mainoksen jälkeen",
  "usermessage.cant-offline-playlists": "Musiikin toistaminen offline-tilassa on Premium-tilaukseen sisältyvä palvelu. <a href=\"#\" data-action=\"{0}\">Hanki Premium</a>.",
  "usermessage.cant-set-high-quality-streaming": "Tämä on Premium-version ominaisuus. <a href=\"#\" data-action=\"{0}\">Hanki Premium</a>.",
  "usermessage.payment-state-creditcard-funds": "Emme pystyneet uusimaan tilaustasi maksuongelman vuoksi. Varmista, että tililläsi on katetta, tai <a href=\"#\" data-action=\"{0}\">päivitä maksutietosi</a>.",
  "usermessage.payment-state-creditcard-refused": "Emme pystyneet uusimaan tilaustasi maksuongelman vuoksi. Jotta tilauksesi pysyy voimassa, <a href=\"#\" data-action=\"{0}\">päivitä maksutietosi</a>.",
  "usermessage.payment-state-paypal-refused": "Emme pystyneet uusimaan tilaustasi maksuongelman vuoksi. Jotta tilauksesi pysyy voimassa, <a href=\"#\" data-action=\"{0}\">päivitä maksutietosi</a>.",
  "usermessage.payment-state-creditcard-expiry": "Käyttämäsi maksukortti vanhenee muutaman päivän kuluttua. Jotta tilauksesi pysyy voimassa, <a href=\"#\" data-action=\"{0}\">päivitä maksutietosi</a>.",
  "usermessage.payment-state-prepaid-expiry": "Prepaid-tilauksesi on vanhenemassa. Mutta ei hätää, voit <a href=\"#\" data-action=\"{0}\">tilata Premiumin täällä</a>.",
  "usermessage.payment-state-churn-payment": "Valitettavasti emme voineet periä sinulta maksua, joten meidän täytyi peruuttaa tilauksesi. Mutta ei hätää, voit <a href=\"#\" data-action=\"{0}\">uusia tilauksesi täällä</a>.",
  "usermessage.payment-state-churn-partner": "Kumppanimme kautta tekemäsi tilaus on juuri päättynyt, joten käytössäsi on nyt Spotify Free. Mutta ei hätää, voit <a href=\"#\" data-action=\"{0}\">palata Premiumiin täällä</a>.",
  "usermessage.opt-in-trial": "Toivottavasti nautit ilmaisesta kokeilujaksostasi! Jotta et menetä Premiumia jakson päätyttyä, <a href=\"#\" data-action=\"{0}\">tilaa se tänään</a>.",
  "usermessage.opt-in-trial-expired": "Ilmainen kokeilujaksosi on päättynyt, joten käytössäsi on nyt Spotify Free. Mutta ei hätää, voit <a href=\"#\" data-action=\"{0}\">palata Premiumiin täällä</a>.",
  "usermessage.hardware-acceleration-changed": "<a href=\"#\" data-action=\"{0}\">Käynnistä Spotify uudelleen</a>, jotta muutokset tulevat voimaan.",
  "usermessage.hardware-acceleration-changed-simple": "Käynnistä Spotify uudelleen, jotta muutokset tulevat voimaan.",
  "usermessage.some-local-tracks-not-saved": "Kaikkia valittuja kappaleita ei tallennettu Omaan musiikkiin. Omaan musiikkiin ei voi tallentaa paikallisia tiedostoja.",
  "usermessage.illegal-playlist-name-entered": "Antamasi soittolistan nimi ei kelpaa.",
  "usermessage.playlist-save-failed-unknown": "Soittolistan tallentaminen ei onnistunut tuntemattoman virheen vuoksi.",
  "usermessage.social-error-permissions": "Napsauta <a href=\"#\" data-action=\"{0}\">tätä</a>, jos haluat jakaa musiikkitapahtumasi Facebookissa.",
  "usermessage.shuffle-unplayable-track": "<a href=\"#\" data-action=\"{0}\">Päivitä Premiumiin</a> ja kuuntele mikä tahansa kappale silloin kuin haluat.",
  "usermessage.shuffle-ran-out-of-skips": "Olet käyttänyt kaikki ohituksesi (tämän tunnin osalta). <a href=\"#\" data-action=\"{0}\">Päivitä Premiumiin</a>, niin voit ohittaa niin monta kappaletta kuin haluat.",
  "usermessage.playlist-limit-exceeded": "Olet täyttänyt tälle soittolistalle varatun tilan kokonaan. Vaikuttavaa. Jatka keräilyä aloittamalla uusi lista.",
  "usermessage.collection-limit-exceeded": "Aika jykevä kokoelma sinulla. Oma musiikki on ihan täynnä. Jos haluat tallentaa lisää, sinun täytyy ensin poistaa joitakin kappaleita.",
  "usermessage.deprecating-os-version": "Huomio! Lopetamme käyttöjärjestelmäsi tukemisen seuraavasta sovellusversiosta alkaen. Saat lisätietoja <a href=\"#\" data-action=\"{0}\">täältä</a> .",
  "usermessage.image-upload-propagation": "Onnistui! (Kuvien käyttöönotto voi kestää jopa 24 tuntia.)",
  "usermessage.approaching-capping-limit": "Ilmaista kuunteluaikaa on jäljellä alle tunti. Voit kuunnella ilmaiseksi 15 tuntia kuukaudessa tai <a href=\"#\" data-action=\"{0}\">päivittää Premium-versioon,</a> jolloin voit kuunnella ilman rajoituksia. <a href=\"#\" data-action=\"{1}\">Lue lisää</a>.",
  "usermessage.half-capping-limit-passed": "Olet käyttänyt puolet kuukausittaisesta kuunteluajastasi. Voit kuunnella ilmaiseksi 15 tuntia kuukaudessa tai <a href=\"#\" data-action=\"{0}\">päivittää Premium-versioon,</a> jolloin voit kuunnella ilman rajoituksia. <a href=\"#\" data-action=\"{1}\">Lue lisää</a>.",
  "usermessage.video-georestricted": "Emme pysty toistamaan tätä videota nykyisessä sijainnissasi.",
  "usermessage.video-unsupported-client-version": "Päivitä Spotify, jotta voit katsoa tämän videon.",
  "usermessage.video-unsupported-platform-version": "Tätä videota ei voi toistaa käyttöjärjestelmäversiollasi.",
  "usermessage.video-country-restricted": "Emme pysty toistamaan tätä videota nykyisessä sijainnissasi.",
  "usermessage.video-unavailable": "Tämä video ei ole saatavilla. Haluako kokeilla jotain muuta?",
  "usermessage.video-catalogue-restricted": "Valitettavasti emme pysty toistamaan tätä videota.",
  "usermessage.video-playback-error": "Valitettavasti emme pysty toistamaan tätä videota.",
  "about.title_label": "Tietoja Spotifysta",
  "about.close_button_label": "Sulje",
  "offline-progress-msg": "Offline-synkronointi meneillään: {0}/{1} kappaletta",
  "tos.updated_terms": "Päivitetyt käyttöehdot",
  "tos.modal_title": "Spotifyn käyttöehdot",
  "tos.tos_text": "<p>Olemme päivittäneet palvelun <a href=\"{0}\">käyttöehdot</a> ja <a href=\"{1}\">ja tietosuojaperiaatteen</a>.</p><p>Jatkamalla Spotifyn käyttöä hyväksyt nämä päivitetyt ehdot, joten lue ne ensin huolellisesti.</p>",
  "tos.not_now_tos_text": "<p>Olemme päivittäneet palvelun <a href=\"{0}\">käyttöehdot</a> ja <a href=\"{1}\">tietosuojaperiaatteen</a>.</p><p>Valitsemalla Hyväksy hyväksyt nämä päivitetyt ehdot (ja tietojen käsittelyn niissä kuvatulla tavalla), joten lue ne ensin huolellisesti.</p>",
  "tos.tos_text2": "<p>Jos et enää halua käyttää Spotifyta, voit peruuttaa tilauksesi Spotifyn tilaussivulla.</p>",
  "tos.not_now_text": "<p>Voit jatkaa Spotifyn käyttöä {0} päivän ajan hyväksymättä päivitettyjä käyttöehtoja ja tietosuojaperiaatetta. Sen jälkeen sinun täytyy hyväksyä uudet käyttöehdot, jotta voit jatkaa Spotifyn käyttöä. Ellet peruuta tilaustasi, sinua veloitetaan jatkossakin kuukausittain tavalliseen tapaan. Jos et halua, että sinua veloitetaan, voit peruuttaa tilauksen milloin vain Spotifyn tilaussivulla.</p>",
  "tos.not_now_last_day_text": "<p>Voit jatkaa Spotifyn käyttöä 1 päivän ajan hyväksymättä päivitettyjä käyttöehtoja ja tietosuojaperiaatetta. Jos et hyväksy uusia ehtoja siihen mennessä, et enää voi käyttää Spotifyta. Ellet peruuta tilaustasi, sinua veloitetaan jatkossakin kuukausittain tavalliseen tapaan. Jos et halua, että sinua veloitetaan, voit peruuttaa tilauksen milloin vain Spotifyn tilaussivulla.</p>",
  "tos.not_now_text_germany": "<p>Olemme päivittäneet <a href=\"{0}\">käyttöehtomme</a> ja <a href=\"{1}\">tietosuojaperiaatteemme</a>. Huomaa, että Spotify GmbH aikoo suostumuksellasi siirtää sopimuksesi Spotify AB:lle, Birger Jarlsgatan 61, 11356 Stockholm, Sweden.</p><p>Voit jatkaa Spotify-palvelun käyttöä nykyisen sopimuksen mukaisesti {2} saakka. Sen jälkeen sinun täytyy hyväksyä uudet käyttöehdot ja tietosuojaperiaate, jotta voit jatkaa palvelun käyttöä. Valitsemalla Hyväksy-vaihtoehdon hyväksyt</p><p>a) sopimuksesi siirron Spotify GmbH:lta Spotify AB:lle,<br />b) päivitetyt käyttöehdot ja<br />c) henkilökohtaisten tietojesi keräämisen, käsittelyn ja käytön tietosuojaperiaatteen osissa 4, 5 ja 7 kuvatulla tavalla.</p>",
  "tos.not_now_text2_germany": "<p>Voit jatkaa Spotifyn käyttöä {0} asti hyväksymättä päivitettyjä käyttöehtoja ja tietosuojaperiaatetta. Jos haluat jatkaa Spotifyn käyttöä sen jälkeen, sinun täytyy hyväksyä uudet ehdot. Jos olet Premium-tilaaja, sinua laskutetaan jatkossakin kuukausittain tavalliseen tapaan, kunnes peruutat tilauksesi. Jos et halua Spotifyn laskuttavan sinua, voit peruuttaa tilauksesi milloin tahansa Spotify-tilaussivullasi.</p>",
  "tos.not_now_expired_text_germany": "<p>Olemme päivittäneet <a href=\"{0}\">käyttöehtomme</a> ja <a href=\"{1}\">tietosuojaperiaatteemme</a>.</p><p>Huomaa, että Spotify GmbH aikoo suostumuksellasi siirtää sopimuksesi Spotify AB:lle, Birger Jarlsgatan 61, 11356 Stockholm, Sweden.</p><p>Jotta voit jatkaa Spotify-palvelun käyttöä, sinun täytyy hyväksyä uudet käyttöehdot ja tietosuojaperiaate. Valitsemalla Hyväksy-vaihtoehdon hyväksyt</p><p>a) sopimuksesi siirron Spotify GmbH:lta Spotify AB:lle,<br />b) päivitetyt käyttöehdot ja<br />c) henkilökohtaisten tietojesi keräämisen, käsittelyn ja käytön tietosuojaperiaatteen osissa 4, 5 ja 7 kuvatulla tavalla.</p>",
  "tos.back_button_label": "Takaisin",
  "tos.ok_button_label": "OK",
  "tos.agree_button_label": "Hyväksyn",
  "tos.cancel_button_label": "En hyväksy",
  "tos.not_now_button_label": "Ei nyt",
  "licenses.modal_title": "Kolmannen osapuolen lisenssit",
  "licenses.close_button_label": "Sulje",
  "feedback.beta_title": "Beetaversio",
  "feedback.beta_text": "Onko jotain, mistä pidät tai mitä inhoat? Kerro meille.",
  "market.ad": "Andorra",
  "market.ar": "Argentiina",
  "market.at": "Itävalta",
  "market.au": "Australia",
  "market.be": "Belgia",
  "market.bg": "Bulgaria",
  "market.bo": "Bolivia",
  "market.br": "Brasilia",
  "market.ca": "Kanada",
  "market.ch": "Sveitsi",
  "market.cl": "Chile",
  "market.co": "Kolumbia",
  "market.cr": "Costa Rica",
  "market.cy": "Kypros",
  "market.cz": "Tšekin tasavalta",
  "market.de": "Saksa",
  "market.dk": "Tanska",
  "market.do": "Dominikaaninen tasavalta",
  "market.ec": "Ecuador",
  "market.ee": "Viro",
  "market.es": "Espanja",
  "market.fi": "Suomi",
  "market.fr": "Ranska",
  "market.gr": "Kreikka",
  "market.gt": "Guatemala",
  "market.hk": "Hongkong",
  "market.hn": "Honduras",
  "market.hu": "Unkari",
  "market.ie": "Irlanti",
  "market.is": "Islanti",
  "market.it": "Italia",
  "market.jp": "Japani",
  "market.li": "Liechtenstein",
  "market.lt": "Liettua",
  "market.lu": "Luxemburg",
  "market.lv": "Latvia",
  "market.mc": "Monaco",
  "market.mt": "Malta",
  "market.mx": "Meksiko",
  "market.my": "Malesia",
  "market.ni": "Nicaragua",
  "market.nl": "Alankomaat",
  "market.no": "Norja",
  "market.nz": "Uusi-Seelanti",
  "market.pa": "Panama",
  "market.pe": "Peru",
  "market.ph": "Filippiinit",
  "market.pl": "Puola",
  "market.pt": "Portugali",
  "market.py": "Paraguay",
  "market.se": "Ruotsi",
  "market.sg": "Singapore",
  "market.sk": "Slovakia",
  "market.sv": "El Salvador",
  "market.tr": "Turkki",
  "market.tw": "Taiwan",
  "market.uk": "Iso-Britannia",
  "market.us": "Yhdysvallat",
  "market.uy": "Uruguay",
  "market.za": "Etelä-Afrikka",
  "sTitle": "Jaa mielipiteesi ja auta meitä rakentamaan maailman paras musiikkipalvelu!",
  "sQ1Question": "Suosittelisiko Spotifyta ystävälle tai työkaverille?",
  "sQ1Negative": "Todennäköisesti en",
  "sQ1Positive": "Todennäköisesti kyllä",
  "sQ2Question": "Miksi näin?",
  "sQ3Question": "Miten tyytyväinen olet Spotifyhin yleisesti ottaen?",
  "sQ3Negative": "Hyvin tyytymätön",
  "sQ3Positive": "Hyvin tyytyväinen",
  "sSubmit": "Lähetä vastaukset",
  "sThanks": "Kiitos vastauksistasi. Niistä on meille paljon apua.",
  "sTeam": "Spotify-tiimi",
  "sClose": "Sulje",
  "cls.highlight": "Premium asetettu tauolle",
  "cls.title": "Viimeinen maksusi ei toiminut.",
  "cls.desc": "Jatka Premiumin kuuntelua lisäämällä uusi maksutapa. Siihen menee vain pari minuuttia.",
  "cls.updatePayment": "Päivitä maksu",
  "cls.cancelSubscription": "Voit myös laskea tilauksesi Spotify Free -tasolle<br> <a class=\"cancel-sub\" href=\"#cancel\">peruuttamalla Premium-tilauksesi</a>.",
  "capping.upsell-title": "Olet saavuttanut ilmaisen kuunteluajan rajan.",
  "capping.upsell-message": "Saat 15 tuntia ilmaista kuunteluaikaa kuukaudessa.<br>Voit kuunnella ilman rajoituksia ja mainoksia päivittämällä Premium-versioon.",
  "capping.upsell-button-label": "Päivitä tilaus Premiumiksi",
  "capping.defaultRefillMessage": "Ilmainen kuunteluaikasi on pian taas käytettävissä.",
  "capping.refillMessage": "Ilmainen kuunteluaikasi on taas käytettävissä viimeistään {0} päivän kuluttua.",
  "capping.welcome-title": "Tervetuloa Spotifyhin.",
  "capping.welcome-message": "Saat 15 tuntia ilmaista kuunteluaikaa kuukaudessa.<br> <a data-action={0}>Päivitä tilauksesi Premium-versioon</a>, niin voit kuunnella ilman mainoksia rajoituksetta.",
  "capping.welcome-message-button-label": "Aloita",
  "yourArtistsTooltipTitle": "Hallitse omia artisteja",
  "yourArtistsTooltipText": "Voit nyt muokata artistiprofiilin kuvaa helposti Spotifyssa.",
  "yourArtists": "Omat artistit"
};
},{}],7:[function(require,module,exports){
module.exports = {
  "browse.app_name": "Parcourir",
  "latest-releases.app_name": "Nouveautés",
  "discover.app_name": "Découvrir",
  "activity.app_name": "Activité",
  "radio.app_name": "Radio",
  "settings.app_name": "Préférences",
  "messages.app_name": "Messages",
  "profile.app_name": "Profil",
  "notifications_center.app_name": "Notifications",
  "concerts.app_name": "Concerts",
  "profile.private_session": "Écoute privée",
  "profile.upgrade": "Abonnez-vous",
  "profile.upgrade_account": "Abonnez-vous",
  "profile.upgrade_tooltip": "Abonnez-vous au Premium",
  "profile.account": "Compte",
  "profile.logout": "Déconnexion",
  "profile.enabled": "Activé",
  "profile.menu_label": "Menu",
  "profile.switch": "Changer d'utilisateur",
  "profile.new_user": "Passer à un nouvel utilisateur",
  "your_music.app_name": "Ma musique",
  "your_music.songs": "Titres",
  "your_music.artists": "Artistes",
  "your_music.albums": "Albums",
  "your_music.stations": "Stations",
  "your_music.local_files": "Fichiers locaux",
  "sidebar.title_main": "Principal",
  "sidebar.title_playlists": "Playlists",
  "new_playlist.input_placeholder": "Nouvelle playlist",
  "new_playlist.button": "Nouvelle playlist",
  "accessibilitylinks.skip_to_content_label": "Passer au contenu principal",
  "accessibilitylinks.skip_to_player_label": "Passer aux commandes de lecture",
  "playlist.by": "de {0}",
  "playlist.loading": "Chargement...",
  "playlist.newfolder": "Nouveau dossier",
  "playlist.delete_message": "Voulez-vous vraiment supprimer cette liste de lecture?",
  "playlist.unfollow_message": "Voulez-vous vraiment cesser de suivre cette liste de lecture?",
  "playlistfolder.delete_message": "Voulez-vous vraiment supprimer ce dossier et toutes les listes de lecture qu'il contient?",
  "playlist.delete_confirm": "Supprimer",
  "playlist.unfollow_confirm": "Ne plus suivre",
  "playlist.delete_cancel": "Annuler",
  "playlist.duplicates_dialog_title": "Chansons en double",
  "playlist.duplicates_dialog_title_single": "Chanson en double",
  "playlist.duplicates_dialog_body": "Votre playlist contient déjà certains de ces titres.",
  "playlist.duplicates_dialog_body_single": "Votre liste de lecture contient déjà cette chanson. ",
  "playlist.duplicates_dialog_button_add": "Ajouter tout",
  "playlist.duplicates_dialog_button_add_single": "Ajouter quand même",
  "playlist.duplicates_dialog_button_skip_duplicates": "Sauter les chansons en double",
  "playlist.duplicates_dialog_button_skip_single": "Sauter la chanson en double",
  "playlist.annotate_form.new_playlist_name": "Nouvelle playlist",
  "playlist.annotate_form.create_title": "Créer une liste de lecture",
  "playlist.annotate_form.create": "Créer",
  "playlist.annotate_form.cancel": "Annuler",
  "playlist.annotate_form.edit_title": "Modifier les détails de la liste de lecture",
  "playlist.annotate_form.save": "Sauvegarder",
  "playlist.annotate_form.name_field_label": "Nom",
  "playlist.annotate_form.name_field_placeholder": "Nom de la liste de lecture",
  "playlist.annotate_form.image_field_label": "Image",
  "playlist.annotate_form.image_pick_button_label": "Choisir une image",
  "playlist.annotate_form.image_replace_button_label": "Remplacer l'image",
  "playlist.annotate_form.image_remove_button_label": "Retirer l'image",
  "playlist.annotate_form.image_file_size_exceeded": "La taille de l'image est trop grande; la limite est de 4 Mo",
  "playlist.annotate_form.image_file_upload_failed": "Le téléversement de l'image a échoué, veuillez réessayer.",
  "playlist.annotate_form.annotate_failed": "La mise à jour de la description et de l'image a échoué, veuillez réessayer.",
  "playlist.annotate_form.close-error-bar": "Masquer",
  "playlist.annotate_form.description_field_label": "Description",
  "playlist.annotate_form.description_field_placeholder": "Donnez à votre liste de lecture une description accrocheuse.",
  "playlist.annotate_form.permission_message": "En continuant, tu acceptes d'accorder à Spotify l'accès à l'image que tu souhaites téléverser. Vérifie que tu as le droit de téléverser l'image. Nous utiliserons ton image pour la pochette de la liste de lecture.",
  "playlist.annotate_form.insert_link_button_label": "Insérer le lien",
  "playlist.annotate_form.insert_link.link_field_label": "Lien vers",
  "playlist.annotate_form.insert_link.change_button_label": "Modifier",
  "playlist.annotate_form.insert_link.remove_button_label": "Supprimer",
  "playlist.annotate_form.insert_link.done_button_label": "Terminé",
  "playlist.annotate_form.drop_to_set_image_label": "Déposer pour régler l'image",
  "playlist.annotate_form.drop_not_allowed_label": "Format incompatible",
  "playlist.annotate_form.error.file_not_valid_jpg": "Malgré son nom, ce fichier n'est pas réellement un fichier PDF valide.",
  "playlist.annotate_form.error.name_required": "Vous devez donner un nom à la liste de lecture.",
  "playlist.annotate_form.error.selection_required_to_insert_link": "Vous devez sélectionner le texte que vous souhaitez convertir en hyperlien.",
  "playlist.annotate_form.error.html_not_allowed": "Il semble que vous tentez d'utiliser HTML, ce qui n'est pas possible.",
  "playlist.annotate_form.error.submit": "Impossible d'enregistrer les modifications de la liste de lecture. Veuillez réessayer.",
  "playlist.annotate_form.error.image_too_small": "Cette image est trop petite. Elle doit faire au moins {0} x {1}.",
  "playlist.annotate_form.warning.client_offline": "Connexion à Internet introuvable. Les modifications de description et d'image ne seront pas enregistrées.",
  "playlist.annotate_form.warning.no_line_breaks_in_description": "Désolé! Impossible d'ajouter des sauts de ligne dans la description.",
  "playlist.annotate_form.warning.unsaved_changes": "Ne voulez-vous pas enregistrer vos changements?",
  "navigation.label": "Navigation",
  "navigation.back_button_label": "Reculer",
  "navigation.forward_button_label": "Avancer",
  "search.input_placeholder": "Rechercher",
  "player.label": "Commandes de lecture",
  "player.shuffle_mode_label": "Aléatoire",
  "player.repeat_mode_label": "Répéter",
  "player.queue": "Mettre en file d'attente",
  "player.volume_button_label": "Volume",
  "player.spotify_connect": "Spotify Connect",
  "player.connect_button_label": "Se connecter à un appareil",
  "player.lyrics_label": "Paroles",
  "player.play_button_label": "Lecture",
  "player.pause_button_label": "Pause",
  "player.previous_button_label": "Précédent",
  "player.next_button_label": "Suivant",
  "player.offline_label": "Hors ligne",
  "player.thumb_up_label": "J'aime",
  "player.thumb_down_label": "Je n'aime pas",
  "playererror.default": "Un problème est survenu lors de la lecture de la chanson sélectionnée",
  "playererror.track_not_available": "Cette chanson n'est pas disponible.",
  "nowplaying.label": "En cours de lecture",
  "nowplaying.go_to_context": "Aller à la lecture en cours",
  "nowplaying.save_your_music": "Enregistrer dans Votre musique",
  "nowplaying.remove_your_music": "Supprimer de Votre musique",
  "nowplaying.playing_suggested_track": "Chanson suggérée en cours de lecture",
  "connect.connect_text": "Se connecter à un appareil",
  "connect.device_connecting": "Connexion...",
  "connect.device_incompatible": "Incompatible",
  "connect.device_premium_only": "Utilisateurs de Premium seulement",
  "connect.device_sleeping": "L'appareil est en veille",
  "connect.device_tech_cast": "Google Cast",
  "connect.device_tech_connect": "Spotify Connect",
  "connect.device_this_computer": "Cet ordinateur",
  "connect.device_unavailable_for_playback": "Écoute non disponible sur",
  "connect.device_unknown": "Appareil inconnu",
  "connect.device_unsupported_uri": "Impossible de lire ceci",
  "connect.devices_available": "Appareils disponibles",
  "connect.dismiss": "Ignorer",
  "connect.help1": "Spotify Connect vous permet d'utiliser Spotify sur tous vos appareils.\n\n",
  "connect.help2": "Lancez Spotify sur un autre appareil et il apparaîtra ici comme par magie.",
  "connect.help_hint": "Qu'est-ce que Spotify Connect?",
  "connect.offline": "Non disponible",
  "connect.offline_reason_computer": "Spotify n'est pas actif sur cet appareil.",
  "connect.offline_reason_generic": "Spotify n'est pas actif sur cet appareil.",
  "connect.offline_reason_phone": "Le téléphone est verrouillé ou Spotify ne se trouve pas à l'avant-plan.",
  "connect.offline_reason_gameconsole": "Utiliser les paramètres de mise sous tension dans l'application Spotify PlayStation afin d'activer la fonction de réveil de la PlayStation à partir du mode de veille.",
  "connect.offline_text1": "Vous devez vous connecter pour pouvoir utiliser cette fonctionnalité.",
  "connect.offline_title": "Vous êtes hors ligne!",
  "connect.playingon": "Écoute sur",
  "connect.popup_title": "Appareils",
  "connect.remoteplayback": "Vous écoutez Spotify sur {0}",
  "connect.show_more": "Afficher plus",
  "connect.upgrade": "Abonnez-vous",
  "connect.upsell": "Spotify Connect est une fonctionnalité du service Premium qui vous permet d'utiliser Spotify sur vos appareils.",
  "contextmenu.new-playlist": "Nouvelle playlist",
  "contextmenu.add-to-playlist": "Ajouter à la playlist",
  "contextmenu.owner-playlist": "de {0}",
  "contextmenu.copy-uri": "Copier l'URL de Spotify",
  "contextmenu.copy-artist-url": "Copier le lien de l'artiste",
  "contextmenu.copy-album-url": "Copier le lien de l'album",
  "contextmenu.copy-track-url": "Copier le lien vers la chanson",
  "contextmenu.copy-playlist-url": "Copier le lien de la liste de lecture",
  "contextmenu.copy-profile-url": "Copier le lien du profil",
  "contextmenu.copy-station-url": "Copier le lien vers la station",
  "contextmenu.copy-chart-url": "Copier le lien vers le palmarès",
  "contextmenu.copy-url": "Copier le lien",
  "contextmenu.copy-embed": "Copier le code intégré",
  "contextmenu.collaborative": "Liste de lecture collaborative",
  "contextmenu.save": "Enregistrer dans Votre musique",
  "contextmenu.remove": "Supprimer de Votre musique",
  "contextmenu.delete-playlist": "Supprimer",
  "contextmenu.follow": "Suivre",
  "contextmenu.unfollow": "Ne plus suivre",
  "contextmenu.publish": "Publier",
  "contextmenu.unpublish": "Cacher",
  "contextmenu.playlist.loading": "Chargement...",
  "contextmenu.play": "Lecture",
  "contextmenu.add-to-queue": "Mettre dans la file d'attente",
  "contextmenu.station": "Aller à la Radio",
  "contextmenu.station-album": "Aller à la radio liée à l'album",
  "contextmenu.station-artist": "Aller à la radio liée à l'artiste",
  "contextmenu.station-playlist": "Aller à la radio liée à la liste de lecture",
  "contextmenu.station-track": "Aller à la radio liée à la chanson",
  "contextmenu.station-chart": "Aller à la Radio des palmarès",
  "contextmenu.remove-from-playlist": "Supprimer de cette liste de lecture",
  "contextmenu.remove-from-queue": "Supprimer de la file d'attente",
  "contextmenu.rename-folder": "Renommer",
  "contextmenu.rename-playlist": "Renommer",
  "contextmenu.edit-playlist": "Modifier les détails",
  "contextmenu.report-playlist": "Signaler",
  "contextmenu.report-asset": "Signaler",
  "contextmenu.share": "Partager...",
  "contextmenu.share-lyrics": "Partager les paroles",
  "contextmenu.create-folder": "Créer un dossier",
  "contextmenu.create-playlist": "Créer une liste de lecture",
  "contextmenu.open-localfile-folder": "Ouvrir le dossier contenant le fichier",
  "contextmenu.open-localfile-folder-mac": "Afficher dans Finder",
  "contextmenu.offline": "Disponible hors connexion",
  "contextmenu.goto-artist": "Voir l'artiste",
  "contextmenu.goto-album": "Voir l'album",
  "usermessage.default-message": "Une erreur s'est produite",
  "usermessage.update-ready": "Bonjour. Une nouvelle version de Spotify est maintenant disponible. <a href=\"#\" data-action=\"{0}\">Redémarrez maintenant</a> pour l'obtenir.",
  "usermessage.update-ready-simple": "Bonjour. Une nouvelle version de Spotify est maintenant disponible. Redémarrez maintenant pour l'obtenir.",
  "usermessage.play-token-lost": "Spotify a été mis en pause parce que votre compte est utilisé sur un autre appareil.",
  "usermessage.playback-paused-inactive": "Votre ordinateur est inactif depuis un certain temps. Appuyez sur le bouton de lecture pour poursuivre votre écoute! Abonnez-vous à <a href=\"#\" data-action=\"{0}\">Spotify Premium</a>pour profiter de musique sans interruption.",
  "usermessage.not-available-offline": "Aucune connexion à Internet détectée. Spotify tentera automatiquement de se reconnecter lorsqu'il détectera un accès à Internet (code d'erreur : 4)",
  "usermessage.track-not-available-in-region": "Cette chanson n'est pas disponible pour l'instant dans ce pays  :  {0}. Si vous possédez le fichier sur votre ordinateur, vous pouvez l'importer.",
  "usermessage.track-not-available-in-region-generic": "Cette chanson n'est pas disponible pour l'instant dans votre pays. Si vous possédez le fichier sur votre ordinateur, vous pouvez l'importer.",
  "usermessage.track-not-available": "Cette chanson n'est pas disponible. Si vous possédez le fichier sur votre ordinateur, vous pouvez l'importer.",
  "usermessage.track-not-available-forced-offline": "Veuillez <a href=\"#\" data-action=\"goOnline\">désactiver le mode hors ligne</a>, puis réessayer.",
  "usermessage.track-exclusive-premium": "Cette piste est offerte exclusivement aux utilisateurs du service <a href=\"#\" data-action=\"{0}\">Spotify Premium</a> .",
  "usermessage.track-banned-by-artist": "L'artiste ou la maison de disque a décidé d'interrompre la distribution de cette chanson. Si vous possédez le fichier sur votre ordinateur, vous pouvez l'importer.",
  "usermessage.local-track-no-file": "Cette chanson a été ajoutée en tant que fichier local. Si vous possédez le fichier sur votre ordinateur, vous pouvez l'importer.",
  "usermessage.local-track-file-not-found": "Cette chanson ne peut pas être lue, car le fichier est introuvable. Veuillez l'importer de nouveau.",
  "usermessage.local-track-bad-format": "Le format du fichier est inconnu. Cliquez <a href=\"#\" data-action=\"{0}\">ici</a> pour obtenir des renseignements supplémentaires.",
  "usermessage.capping-reached": "Vous avez atteint {0} heures d'écoute. <a href=\"#\" data-action=\"{1}\">Passez à Spotify Premium</a> pour écouter de la musique sans aucune restriction.",
  "usermessage.local-track-drm-protected": "Impossible de lire cette chanson, car le fichier est protégé par des technologies de gestion des droits numériques (GDN).",
  "usermessage.offline-disk-cache": "Le téléchargement des chansons hors ligne a échoué. Vérifiez si le disque est plein.",
  "usermessage.offline-sync-expired": "Les chansons hors ligne ont expiré. Connectez-vous à Spotify pour les réactiver.",
  "usermessage.offline-sync-failed": "Le téléchargement de certaines chansons hors ligne a échoué.",
  "usermessage.offline-too-many-tracks": "Trop de chansons ont été sélectionnées pour le mode hors ligne.",
  "usermessage.offline-license-server-error": "Un problème du serveur Spotify est survenu.",
  "usermessage.offline-license-lost": "L'accès hors ligne n'est plus actif pour cet ordinateur ou cet appareil.",
  "usermessage.offline-not-allowed": "Le mode hors ligne est une fonctionnalité exclusive de <a href=\"#\" data-action=\"{0}\">Spotify Premium</a>.",
  "usermessage.language-changed": "Vous devez <a href=\"#\" data-action=\"{0}\">redémarrer Spotify</a> pour que vos modifications soient prises en compte",
  "usermessage.proxysettings-changed": "Vous devez <a href=\"#\" data-action=\"{0}\">redémarrer Spotify</a> pour que vos modifications soient prises en compte",
  "usermessage.language-changed-simple": "Vous devez redémarrer Spotify pour que vos modifications soient prises en compte.",
  "usermessage.proxysettings-changed-simple": "Vous devez redémarrer Spotify pour que vos modifications soient prises en compte.",
  "usermessage.cache-changed": "Vous devez <a href=\"#\" data-action=\"{0}\">redémarrer Spotify</a> pour que vos modifications soient prises en compte",
  "usermessage.cache-changed-simple": "Vous devez redémarrer Spotify pour que vos modifications soient prises en compte.",
  "usermessage.feature-changed": "Vous devez <a href=\"#\" data-action=\"{0}\">redémarrer Spotify</a> pour que vos modifications soient prises en compte",
  "usermessage.first-autostart": "Spotify s'est ouvert automatiquement, mais dans une fenêtre réduite. Vous pouvez modifier vos réglages de manière à ce que Spotify <a href=\"#\" data-action=\"{0}\">s'ouvre automatiquement dans une fenêtre agrandie</a> ou <a href=\"#\" data-action=\"{1}\">ne s'ouvre pas</a> du tout.",
  "usermessage.cant-play-track": "Impossible de lire la chanson sélectionnée.",
  "usermessage.cant-skip-ads": "La chanson sélectionnée commencera après la publicité",
  "usermessage.cant-offline-playlists": "Le mode hors ligne est une fonctionnalité exclusive de Premium. <a href=\"#\" data-action=\"{0}\">S'abonner à Premium</a>.",
  "usermessage.cant-set-high-quality-streaming": "Cette fonctionnalité est réservée aux abonnés Premium. <a href=\"#\" data-action=\"{0}\">S'abonner à Premium</a>.",
  "usermessage.payment-state-creditcard-funds": "Il nous est impossible de renouveler votre abonnement en raison d'un problème de paiement. Veuillez vous assurer d'avoir les fonds nécessaires dans votre compte ou <a href=\"#\" data-action=\"{0}\">mettez à jour vos informations de paiement</a>.",
  "usermessage.payment-state-creditcard-refused": "Il nous est impossible de renouveler votre abonnement en raison d'un problème de paiement. Pour conserver votre abonnement, veuillez <a href=\"#\" data-action=\"{0}\">mettre à jour vos informations de paiement</a>.",
  "usermessage.payment-state-paypal-refused": "Il nous est impossible de renouveler votre abonnement en raison d'un problème de paiement. Pour conserver votre abonnement, veuillez <a href=\"#\" data-action=\"{0}\">mettre à jour vos informations de paiement</a>.",
  "usermessage.payment-state-creditcard-expiry": "La carte de paiement que vous utilisez actuellement expire dans quelques jours. Pour conserver votre abonnement, veuillez <a href=\"#\" data-action=\"{0}\">mettre à jour vos informations de paiement</a>.",
  "usermessage.payment-state-prepaid-expiry": "Votre abonnement prépayé touche à sa fin. Ne vous inquiétez pas, vous pouvez vous <a href=\"#\" data-action=\"{0}\">abonner à Premium ici</a>.",
  "usermessage.payment-state-churn-payment": "Malheureusement, nous n'avons pas pu prélever votre paiement et nous avons dû mettre fin à votre abonnement. Ne vous inquiétez pas, vous pouvez <a href=\"#\" data-action=\"{0}\">renouveler votre abonnement ici</a>.",
  "usermessage.payment-state-churn-partner": "Votre abonnement avec un de nos partenaires vient de prendre fin et vous utilisez dorénavant Spotify Free. Ne vous inquiétez pas, vous pouvez <a href=\"#\" data-action=\"{0}\">revenir à Premium ici</a>.",
  "usermessage.opt-in-trial": "Nous espérons que vous profitez de votre essai gratuit! Pour éviter de perdre votre abonnement à Premium lorsqu'il prend fin, <a href=\"#\" data-action=\"{0}\">abonnez-vous aujourd'hui</a>.",
  "usermessage.opt-in-trial-expired": "Votre essai gratuit a pris fin et vous utilisez désormais Spotify Free. Ne vous inquiétez pas, vous pouvez <a href=\"#\" data-action=\"{0}\">revenir à Premium ici</a>.",
  "usermessage.hardware-acceleration-changed": "Vous devez <a href=\"#\" data-action=\"{0}\">redémarrer Spotify</a> pour que vos modifications soient prises en compte",
  "usermessage.hardware-acceleration-changed-simple": "Vous devez redémarrer Spotify pour que vos modifications soient prises en compte.",
  "usermessage.some-local-tracks-not-saved": "Certaines des chansons sélectionnées n'ont pas été enregistrées dans Votre musique. Les fichiers locaux ne sont pas pris en charge par Votre musique.",
  "usermessage.illegal-playlist-name-entered": "Le nom de la liste de lecture entré n'est pas valide.",
  "usermessage.playlist-save-failed-unknown": "La liste de lecture n'a pas pas été enregistrée en raison d'une erreur inconnue.",
  "usermessage.social-error-permissions": "Cliquez <a href=\"#\" data-action=\"{0}\">ici</a> pour partager votre musique sur Facebook.",
  "usermessage.shuffle-unplayable-track": "<a href=\"#\" data-action=\"{0}\">Passez à Premium</a> et écoutez les chansons de votre choix à tout moment.",
  "usermessage.shuffle-ran-out-of-skips": "Vous ne pouvez plus sauter de pistes (pour l'heure en cours). <a href=\"#\" data-action=\"{0}\">Passez à Premium</a> et sautez autant de pistes que vous le souhaitez.",
  "usermessage.playlist-limit-exceeded": "Vous avez rempli cette liste de lecture à pleine capacité. Impressionnant! Commencez-en une nouvelle dès maintenant pour continuer à collectionner.",
  "usermessage.collection-limit-exceeded": "Impressionnante collection! Ma musique est à pleine capacité. Pour sauvegarder plus de titre, vous devez supprimer des chansons.",
  "usermessage.deprecating-os-version": "Avis à tous! Nous mettrons prochainement fin aux mises à jour pour votre système d'exploitation. Cliquez <a href=\"#\" data-action=\"{0}\">ici</a> pour en savoir plus.",
  "usermessage.image-upload-propagation": "Bien joué! (La propagation des images peut prendre jusqu'à 24 heures)",
  "usermessage.approaching-capping-limit": "Il vous reste moins d'une heure d'écoute gratuite. Profitez chaque mois de 15 heures d'écoute gratuite ou <a href=\"#\" data-action=\"{0}\">abonnez-vous à Spotify Premium </a> pour enlever cette limite. <a href=\"#\" data-action=\"{1}\">En savoir plus</a>.",
  "usermessage.half-capping-limit-passed": "Vous avez utilisé la moitié de votre limite mensuelle. Profitez chaque mois de 15 heures d'écoute gratuite ou <a href=\"#\" data-action=\"{0}\">abonnez-vous à Spotify Premium </a> pour enlever cette limite. <a href=\"#\" data-action=\"{1}\">En savoir plus</a>.",
  "usermessage.video-georestricted": "Impossible de lancer cette vidéo à votre emplacement actuel.",
  "usermessage.video-unsupported-client-version": "Veuillez mettre à niveau votre application Spotify pour lire cette vidéo.",
  "usermessage.video-unsupported-platform-version": "Cette vidéo ne peut être lue sur la version actuelle de votre système d'exploitation.",
  "usermessage.video-country-restricted": "Impossible de lancer cette vidéo à votre emplacement actuel.",
  "usermessage.video-unavailable": "Cette vidéo n'est pas disponible. Essaye une autre vidéo?",
  "usermessage.video-catalogue-restricted": "Désolés, il nous est impossible de lancer cette vidéo.",
  "usermessage.video-playback-error": "Désolés, il nous est impossible de lancer cette vidéo.",
  "about.title_label": "À propos de Spotify",
  "about.close_button_label": "Fermer",
  "offline-progress-msg": "Synchronisation hors ligne de la chanson {0}  de {1}",
  "tos.updated_terms": "Conditions mises à jour",
  "tos.modal_title": "Modalités d'utilisation de Spotify",
  "tos.tos_text": "<p>Nous avons modifié nos <a href=\"{0}\">conditions d'utilisation</a> et notre <a href=\"{1}\">politique de confidentialité.</a>.</p><p>En continuant d'utiliser Spotify, vous acceptez ces modifications. Veuillez prendre le temps de lire les modifications et de les comprendre. </p>",
  "tos.not_now_tos_text": "<p>Nous avons modifié nos <a href=\"{0}\">conditions d'utilisation</a> et notre <a href=\"{1}\">politique de confidentialité</a>.</p><p>En cliquant sur « Accepter », vous acceptez ces mises à jour (et le traitement des données qu'elles décrivent). Veuillez donc prendre quelques minutes pour les lire et les comprendre. </p>",
  "tos.tos_text2": "<p>Si vous ne voulez plus utiliser Spotify, vous pouvez annuler votre abonnement à partir de votre page d'abonnement Spotify.</p>",
  "tos.not_now_text": "<p>Vous pourrez continuer d'utiliser Spotify pendant {0} jours sans accepter les conditions d'utilisation et la politique de confidentialité mises à jour. Après cette date, vous serez obligé d'accepter les nouvelles conditions pour continuer à utiliser Spotify. Vous continuerez de payer vos frais mensuels selon votre cycle de facturation normal, sauf si vous décidez d'annuler votre abonnement. Si vous ne voulez plus payer pour utiliser Spotify, vous pouvez annuler votre abonnement à tout moment à partir de votre page d'abonnement Spotify.</p>",
  "tos.not_now_last_day_text": "<p>Vous pourrez continuer d'utiliser Spotify pendant 1 jour sans accepter les mises à jour des conditions d'utilisation et de la politique de confidentialité. Si vous n'avez toujours pas accepté les nouvelles conditions après ce délai, vous ne pourez plus utiliser Spotify. À moins d'annuler votre abonnement, vous continuerez d'être facturé chaque mois. Si vous ne voulez plus payer pour utiliser Spotify, vous pouvez annuler votre abonnement à tout moment à partir de votre page d'abonnement Spotify.</p>",
  "tos.not_now_text_germany": "<p>Nous avons modifié nos <a href=\"{0}\">conditions d'utilisation</a> et notre <a href=\"{1}\">politique de confidentialité</a>. Veuillez noter que, avec votre consentement, Spotify GmbH prévoit transférer votre contrat à Spotify AB, Birger Jarlsgatan 61, 113 56 Stockholm, Sweden.</p><p>Vous pouvez continuer à utiliser le service Spotify dans le cadre du contrat en vigueur jusqu'au {2}. Après cette date, pour continuer à utiliser le service Spotify, vous devrez accepter les nouvelles conditions d'utilisation et la nouvelle politique de confidentialité. En cliquant sur « Accepter », vous autorisez</p><p>a) le transfert de votre contrat depuis Spotify GmbH vers Spotify AB,<br />b) les mises à jour des conditions d'utilisation et<br />c) la collecte, le traitement et l'utilisation de vos données personnelles selon les articles 4, 5 et 7 de la politique de confidentialité.</p>",
  "tos.not_now_text2_germany": "<p>Vous pouvez continuer d'utiliser Spotify jusqu'au {0} sans accepter les conditions d'utilisation et la politique de confidentialité mises à jour. À cette date, vous devrez accepter les nouvelles conditions et la nouvelle politique si vous voulez continuer à utiliser Spotify. Si vous êtes un utilisateur Premium, le service vous sera facturé mensuellement selon votre cycle de facturation habituel, à moins que vous n'annuliez votre abonnement. Si vous ne voulez plus que Spotify vous facture ses services, vous pouvez résilier votre abonnement en tout temps sur votre page d'abonnement Spotify.</p>",
  "tos.not_now_expired_text_germany": "<p>Nous avons modifié nos <a href=\"{0}\">conditions d'utilisation</a> et notre <a href=\"{1}\">politique de confidentialité</a>.</p><p>Veuillez noter que, avec votre consentement, Spotify GmbH prévoit transférer votre contrat à Spotify AB, Birger Jarlsgatan 61, 113 56 Stockholm, Suède.</p><p>Pour continuer à utiliser le service Spotify, vous devrez accepter les nouvelles conditions d'utilisation et la nouvelle politique de confidentialité. En cliquant sur « Accepter », vous autorisez</p><p>a) le transfert de votre contrat depuis Spotify GmbH vers Spotify AB,<br />b) les mises à jour des conditions d'utilisation et<br/>c) la collecte, le traitement et l'utilisation de vos données personnelles selon les articles 4, 5 et 7 de la politique de confidentialité.</p>",
  "tos.back_button_label": "Retour",
  "tos.ok_button_label": "OK",
  "tos.agree_button_label": "Accepter",
  "tos.cancel_button_label": "Refuser",
  "tos.not_now_button_label": "Pas maintenant",
  "licenses.modal_title": "Licences de tiers",
  "licenses.close_button_label": "Fermer",
  "feedback.beta_title": "Version bêta",
  "feedback.beta_text": "Vous adorez ou détestez quelque chose? Dites-nous le.",
  "market.ad": "Andorre",
  "market.ar": "Argentine",
  "market.at": "Autriche",
  "market.au": "Australie",
  "market.be": "Belgique",
  "market.bg": "Bulgarie",
  "market.bo": "Bolivie",
  "market.br": "Brésil",
  "market.ca": "Canada",
  "market.ch": "Suisse",
  "market.cl": "Chili",
  "market.co": "Colombie",
  "market.cr": "Costa Rica",
  "market.cy": "Chypre",
  "market.cz": "République tchèque",
  "market.de": "Allemagne",
  "market.dk": "Danemark",
  "market.do": "République dominicaine",
  "market.ec": "Équateur",
  "market.ee": "Estonie",
  "market.es": "Espagne",
  "market.fi": "Finlande",
  "market.fr": "France",
  "market.gr": "Grèce",
  "market.gt": "Guatemala",
  "market.hk": "Hong Kong",
  "market.hn": "Honduras",
  "market.hu": "Hongrie",
  "market.ie": "Irlande",
  "market.is": "Islande",
  "market.it": "Italie",
  "market.jp": "Japon",
  "market.li": "Liechtenstein",
  "market.lt": "Lituanie",
  "market.lu": "Luxembourg",
  "market.lv": "Lettonie",
  "market.mc": "Monaco",
  "market.mt": "Malte",
  "market.mx": "Mexique",
  "market.my": "Malaisie",
  "market.ni": "Nicaragua",
  "market.nl": "Pays-Bas",
  "market.no": "Norvège",
  "market.nz": "Nouvelle-Zélande",
  "market.pa": "Panama",
  "market.pe": "Pérou",
  "market.ph": "Philippines",
  "market.pl": "Pologne",
  "market.pt": "Portugal",
  "market.py": "Paraguay",
  "market.se": "Suède",
  "market.sg": "Singapour",
  "market.sk": "Slovaquie",
  "market.sv": "Salvador",
  "market.tr": "Turquie",
  "market.tw": "Taïwan",
  "market.uk": "Royaume-Uni",
  "market.us": "États-Unis",
  "market.uy": "Uruguay",
  "market.za": "Afrique du Sud",
  "sTitle": "Donnez-nous votre avis et aidez-nous à créer le meilleur service de musique au monde!",
  "sQ1Question": "Quelle est la probabilité que vous recommandiez Spotify à un ami ou à un collègue?",
  "sQ1Negative": "Très peu probable",
  "sQ1Positive": "Très probable",
  "sQ2Question": "Pour quelles raisons?",
  "sQ3Question": "Dans l'ensemble, quel est votre degré de satisfaction concernant Spotify?",
  "sQ3Negative": "Très insatisfait",
  "sQ3Positive": "Très satisfait",
  "sSubmit": "Soumettre le sondage",
  "sThanks": "Merci beaucoup pour votre aide  et pour votre disponibilité.",
  "sTeam": "L'équipe Spotify",
  "sClose": "Fermer",
  "cls.highlight": "Abonnement Premium suspendu",
  "cls.title": "Votre dernier paiement n'a pas été effectué.",
  "cls.desc": "Pour continuer d'écouter votre musique au moyen de Premium, ajoutez un nouveau mode de paiement. Ça ne prendra que quelques minutes.",
  "cls.updatePayment": "Mettre à jour le mode de paiement",
  "cls.cancelSubscription": "Vous pouvez également revenir à Spotify Free,<br>en <a class=\"cancel-sub\" href=\"#cancel\">annulant votre abonnement à Premium</a>.",
  "capping.upsell-title": "Vous avez atteint votre limite d'écoute gratuite.",
  "capping.upsell-message": "Vous obtenez chaque mois de 15 heures d'écoute gratuite.<br />Abonnez-vous à Spotify Premium pour écouter en illimité et sans publicité.",
  "capping.upsell-button-label": "Abonnez-vous au Premium",
  "capping.defaultRefillMessage": "Votre écoute gratuite atteindra bientôt sa limite.",
  "capping.refillMessage": "Votre écoute gratuite atteindra sa limite dans les {0} prochaines journées.",
  "capping.welcome-title": "Bienvenue à Spotify.",
  "capping.welcome-message": "Vous obtenez chaque mois de 15 heures d'écoute gratuite.<br /> <a data-action={0}>Abonnez-vous à Spotify Premium</a> pour écouter en illimité et sans publicité.",
  "capping.welcome-message-button-label": "Commencer",
  "yourArtistsTooltipTitle": "Gérer vos artistes",
  "yourArtistsTooltipText": "Vous pouvez à présent modifier facilement l'image de profil de votre artiste sur Spotify.",
  "yourArtists": "Vos artistes"
};
},{}],8:[function(require,module,exports){
module.exports = {
  "browse.app_name": "Parcourir",
  "latest-releases.app_name": "Dernières sorties",
  "discover.app_name": "Découvertes",
  "activity.app_name": "Activité",
  "radio.app_name": "Radio",
  "settings.app_name": "Préférences",
  "messages.app_name": "Messages",
  "profile.app_name": "Profil",
  "notifications_center.app_name": "Notifications",
  "concerts.app_name": "Concerts",
  "profile.private_session": "Session d'écoute privée",
  "profile.upgrade": "Abonnez-vous",
  "profile.upgrade_account": "Abonnez-vous",
  "profile.upgrade_tooltip": "Abonnez-vous à Spotify Premium",
  "profile.account": "Compte",
  "profile.logout": "Déconnexion",
  "profile.enabled": "Activé",
  "profile.menu_label": "Menu",
  "profile.switch": "Changer d'utilisateur",
  "profile.new_user": "Basculer sur Nouvel utilisateur",
  "your_music.app_name": "Ma musique",
  "your_music.songs": "Titres",
  "your_music.artists": "Artistes",
  "your_music.albums": "Albums",
  "your_music.stations": "Radios",
  "your_music.local_files": "Fichiers locaux",
  "sidebar.title_main": "Principal",
  "sidebar.title_playlists": "Playlists",
  "new_playlist.input_placeholder": "Créer une playlist",
  "new_playlist.button": "Créer une playlist",
  "accessibilitylinks.skip_to_content_label": "Passer au contenu principal",
  "accessibilitylinks.skip_to_player_label": "Passer aux contrôles du lecteur",
  "playlist.by": "de {0}",
  "playlist.loading": "Chargement en cours...",
  "playlist.newfolder": "Nouveau dossier",
  "playlist.delete_message": "Voulez-vous vraiment supprimer cette playlist ?",
  "playlist.unfollow_message": "Voulez-vous vraiment vous désabonner de cette playlist ?",
  "playlistfolder.delete_message": "Voulez-vous vraiment supprimer ce dossier et toutes ses playlists ?",
  "playlist.delete_confirm": "Supprimer",
  "playlist.unfollow_confirm": "Se désabonner",
  "playlist.delete_cancel": "Annuler",
  "playlist.duplicates_dialog_title": "Titres en double",
  "playlist.duplicates_dialog_title_single": "Titre en double",
  "playlist.duplicates_dialog_body": "Votre playlist contient déjà certains de ces titres.",
  "playlist.duplicates_dialog_body_single": "Votre playlist contient déjà ce titre.",
  "playlist.duplicates_dialog_button_add": "Ajouter tout",
  "playlist.duplicates_dialog_button_add_single": "Ajouter quand même",
  "playlist.duplicates_dialog_button_skip_duplicates": "Passer les doublons",
  "playlist.duplicates_dialog_button_skip_single": "Passer le doublon",
  "playlist.annotate_form.new_playlist_name": "Créer une playlist",
  "playlist.annotate_form.create_title": "Créer une playlist",
  "playlist.annotate_form.create": "Créer",
  "playlist.annotate_form.cancel": "Annuler",
  "playlist.annotate_form.edit_title": "Édition les détails de la playlist",
  "playlist.annotate_form.save": "Sauvegarder",
  "playlist.annotate_form.name_field_label": "Nom",
  "playlist.annotate_form.name_field_placeholder": "Nom de la playlist",
  "playlist.annotate_form.image_field_label": "Image",
  "playlist.annotate_form.image_pick_button_label": "Choisir l'image",
  "playlist.annotate_form.image_replace_button_label": "Remplacer l'image",
  "playlist.annotate_form.image_remove_button_label": "Supprimer l'image",
  "playlist.annotate_form.image_file_size_exceeded": "Image trop grande, taille maximale : 4 Mo.",
  "playlist.annotate_form.image_file_upload_failed": "Échec du chargement de l'image. Merci de réessayer plus tard.",
  "playlist.annotate_form.annotate_failed": "Échec du chargement de la mise à jour de la description et de l'image. Merci de réessayer.",
  "playlist.annotate_form.close-error-bar": "Retour",
  "playlist.annotate_form.description_field_label": "Description",
  "playlist.annotate_form.description_field_placeholder": "Associez à votre playlist une description percutante.",
  "playlist.annotate_form.permission_message": "En continuant, vous acceptez que Spotify accède à l'image que vous avez choisie de télécharger. Vérifiez que vous avez le droit de télécharger l'image. Nous l'utiliserons uniquement pour la pochette de votre playlist.",
  "playlist.annotate_form.insert_link_button_label": "Insérer un lien",
  "playlist.annotate_form.insert_link.link_field_label": "Lien vers",
  "playlist.annotate_form.insert_link.change_button_label": "Édition",
  "playlist.annotate_form.insert_link.remove_button_label": "Supprimer",
  "playlist.annotate_form.insert_link.done_button_label": "Terminé",
  "playlist.annotate_form.drop_to_set_image_label": "Déposer pour définir l'image",
  "playlist.annotate_form.drop_not_allowed_label": "Format non accepté",
  "playlist.annotate_form.error.file_not_valid_jpg": "Malgré son nom, ce fichier n'est pas un fichier JPG valide.",
  "playlist.annotate_form.error.name_required": "Vous devez donner un nom à votre playlist.",
  "playlist.annotate_form.error.selection_required_to_insert_link": "Vous devez sélectionner le texte que vous souhaitez transformer en lien.",
  "playlist.annotate_form.error.html_not_allowed": "Vous semblez vouloir utiliser HTML, ce qui n'est pas possible.",
  "playlist.annotate_form.error.submit": "Impossible de sauvegarder les modifications apportées aux playlists. Merci de réessayer plus tard.",
  "playlist.annotate_form.error.image_too_small": "Cette image est trop petite. Elle doit faire au moins {0} x {1}.",
  "playlist.annotate_form.warning.client_offline": "Aucune connexion Internet détectée. Les modifications apportées à la description et à l'image ne seront pas sauvegardées.",
  "playlist.annotate_form.warning.no_line_breaks_in_description": "Désolé, mais les renvois à la ligne ne sont pas acceptée dans la description.",
  "playlist.annotate_form.warning.unsaved_changes": "Êtes-vous sûr de ne pas vouloir enregistrer vos modifications ?",
  "navigation.label": "Navigation",
  "navigation.back_button_label": "Reculer",
  "navigation.forward_button_label": "Avancer",
  "search.input_placeholder": "Recherche",
  "player.label": "Contrôles du lecteur",
  "player.shuffle_mode_label": "Aléatoire",
  "player.repeat_mode_label": "Répéter",
  "player.queue": "File d'attente",
  "player.volume_button_label": "Volume",
  "player.spotify_connect": "Spotify Connect",
  "player.connect_button_label": "Se connecter à un appareil",
  "player.lyrics_label": "Paroles",
  "player.play_button_label": "Lire",
  "player.pause_button_label": "Pause",
  "player.previous_button_label": "Précédent",
  "player.next_button_label": "Continuer",
  "player.offline_label": "Hors connexion",
  "player.thumb_up_label": "J'aime",
  "player.thumb_down_label": "Je n'aime pas",
  "playererror.default": "Un problème est survenu lors de la lecture de la chanson sélectionnée.",
  "playererror.track_not_available": "Ce titre n'est pas disponible.",
  "nowplaying.label": "À l'écoute",
  "nowplaying.go_to_context": "Accéder à la lecture en cours",
  "nowplaying.save_your_music": "Sauvegarder dans Ma musique",
  "nowplaying.remove_your_music": "Supprimer de Ma musique",
  "nowplaying.playing_suggested_track": "En cours de lecture de Suggestion de titre",
  "connect.connect_text": "Se connecter à un appareil",
  "connect.device_connecting": "Connexion...",
  "connect.device_incompatible": "Incompatible",
  "connect.device_premium_only": "Réservé aux abonnés à Spotify Premium",
  "connect.device_sleeping": "Appareil en mode veille",
  "connect.device_tech_cast": "Google Cast",
  "connect.device_tech_connect": "Spotify Connect",
  "connect.device_this_computer": "Cet ordinateur",
  "connect.device_unavailable_for_playback": "Impossible d'écouter sur",
  "connect.device_unknown": "Appareil inconnu",
  "connect.device_unsupported_uri": "Lecture impossible pour l'instant",
  "connect.devices_available": "Appareils disponibles",
  "connect.dismiss": "Ignorer",
  "connect.help1": "Spotify Connect vous permet d'utiliser et de contrôler Spotify sur tous vos appareils.",
  "connect.help2": "Démarrez Spotify sur un autre appareil et il apparaîtra ici comme par magie.",
  "connect.help_hint": "Qu'est-ce que Spotify Connect ?",
  "connect.offline": "Non disponible",
  "connect.offline_reason_computer": "Spotify n'est pas actif sur cet appareil.",
  "connect.offline_reason_generic": "Spotify n'est pas actif sur cet appareil.",
  "connect.offline_reason_phone": "Téléphone verrouillé ou Spotify n'est pas placé au premier plan.",
  "connect.offline_reason_gameconsole": "Utilisez les paramètres de démarrage de l'appli Spotify sur PlayStation pour allumer votre console à partir du mode veille.",
  "connect.offline_text1": "Vous devez être connecté pour utiliser cette fonctionnalité.",
  "connect.offline_title": "Vous êtes hors connexion.",
  "connect.playingon": "Écoute sur",
  "connect.popup_title": "Appareils",
  "connect.remoteplayback": "Vous écoutez sur {0}.",
  "connect.show_more": "Afficher plus",
  "connect.upgrade": "Abonnez-vous",
  "connect.upsell": "Spotify Connect est une option Premium qui vous permet d'utiliser et de contrôler Spotify sur vos appareils. ",
  "contextmenu.new-playlist": "Créer une playlist",
  "contextmenu.add-to-playlist": "Ajouter à la playlist",
  "contextmenu.owner-playlist": "de {0}",
  "contextmenu.copy-uri": "Copier l'URI Spotify",
  "contextmenu.copy-artist-url": "Copier le lien vers l'artiste",
  "contextmenu.copy-album-url": "Copier le lien vers l'album",
  "contextmenu.copy-track-url": "Copier le lien vers la chanson",
  "contextmenu.copy-playlist-url": "Copier le lien vers la playlist",
  "contextmenu.copy-profile-url": "Copier le lien vers le profil",
  "contextmenu.copy-station-url": "Copier le lien de la radio",
  "contextmenu.copy-chart-url": "Copier le lien du classement",
  "contextmenu.copy-url": "Copier le lien",
  "contextmenu.copy-embed": "Copier le code embed",
  "contextmenu.collaborative": "Playlist collaborative",
  "contextmenu.save": "Sauvegarder dans Ma musique",
  "contextmenu.remove": "Supprimer de Ma musique",
  "contextmenu.delete-playlist": "Supprimer",
  "contextmenu.follow": "S'abonner",
  "contextmenu.unfollow": "Se désabonner",
  "contextmenu.publish": "Publier",
  "contextmenu.unpublish": "Cacher",
  "contextmenu.playlist.loading": "Chargement en cours...",
  "contextmenu.play": "Lire",
  "contextmenu.add-to-queue": "Mettre dans la file d'attente",
  "contextmenu.station": "Aller à la Radio",
  "contextmenu.station-album": "Radio liée à l'album",
  "contextmenu.station-artist": "Radio liée à l'artiste",
  "contextmenu.station-playlist": "Radio liée à la playlist",
  "contextmenu.station-track": "Radio liée au titre",
  "contextmenu.station-chart": "Accéder à la radio Tops",
  "contextmenu.remove-from-playlist": "Supprimer de la playlist",
  "contextmenu.remove-from-queue": "Supprimer de la file d'attente",
  "contextmenu.rename-folder": "Renommer",
  "contextmenu.rename-playlist": "Renommer",
  "contextmenu.edit-playlist": "Édition les détails",
  "contextmenu.report-playlist": "Signaler",
  "contextmenu.report-asset": "Signaler",
  "contextmenu.share": "Partager...",
  "contextmenu.share-lyrics": "Partager les paroles",
  "contextmenu.create-folder": "Créer un dossier",
  "contextmenu.create-playlist": "Créer une playlist",
  "contextmenu.open-localfile-folder": "Ouvrir le dossier contenant le fichier",
  "contextmenu.open-localfile-folder-mac": "Afficher dans Finder",
  "contextmenu.offline": "Disponible hors connexion",
  "contextmenu.goto-artist": "Voir l'artiste",
  "contextmenu.goto-album": "Voir l'album",
  "usermessage.default-message": "Une erreur s'est produite.",
  "usermessage.update-ready": "Bonjour ! Une nouvelle version de Spotify est disponible. <a href=\"#\" data-action=\"{0}\">Redémarrez dès maintenant</a> pour en profiter.",
  "usermessage.update-ready-simple": "Bonjour ! Une nouvelle version de Spotify est disponible. Redémarrez dès maintenant pour en profiter.",
  "usermessage.play-token-lost": "Spotify a été mis en pause parce que votre compte est utilisé sur un autre appareil.",
  "usermessage.playback-paused-inactive": "Votre ordinateur est inactif depuis un certain temps, merci de cliquer sur Lecture pour reprendre l'écoute ! Pour de la musique sans interruption, abonnez-vous à <a href=\"#\" data-action=\"{0}\">Spotify Premium</a>.",
  "usermessage.not-available-offline": "Aucune connexion Internet détectée. Spotify essaiera automatiquement de se reconnecter lorsqu'une connexion Internet sera détectée (erreur : 4).",
  "usermessage.track-not-available-in-region": "Cette chanson n'est pas disponible ici actuellement ({0}). Si le fichier se trouve sur votre ordinateur, vous pouvez l'importer.",
  "usermessage.track-not-available-in-region-generic": "Cette chanson n'est actuellement pas disponible dans votre pays. Si le fichier se trouve sur votre ordinateur, vous pouvez l'importer.",
  "usermessage.track-not-available": "Cette chanson n'est pas disponible. Si vous possédez le fichier sur votre ordinateur, vous pouvez l'importer.",
  "usermessage.track-not-available-forced-offline": "Merci de <a href=\"#\" data-action=\"goOnline\">désactiver le mode hors connexion</a>, avant de réessayer.",
  "usermessage.track-exclusive-premium": "Cette chanson est réservée en exclusivité aux utilisateurs de <a href=\"#\" data-action=\"{0}\">Spotify Premium</a> .",
  "usermessage.track-banned-by-artist": "L'artiste/le label a choisi de rendre cette chanson non disponible. Si vous possédez le fichier sur votre ordinateur, vous pouvez l'importer.",
  "usermessage.local-track-no-file": "Cette chanson a été ajoutée comme fichier local. Si vous possédez le fichier sur votre ordinateur, vous pouvez l'importer.",
  "usermessage.local-track-file-not-found": "Impossible d'écouter cette chanson, car le fichier est introuvable. Merci de le réimporter.",
  "usermessage.local-track-bad-format": "Le format de ce fichier est inconnu. Pour plus d'informations, cliquez <a href=\"#\" data-action=\"{0}\">ici</a> .",
  "usermessage.capping-reached": "Vous avez atteint votre quota de {0} heures d'écoute. <a href=\"#\" data-action=\"{1}\">Passez à Spotify Premium</a> pour écouter à l'infini.",
  "usermessage.local-track-drm-protected": "Impossible d'écouter cette chanson, car le fichier est protégé par un système de gestion des droits numériques (DRM).",
  "usermessage.offline-disk-cache": "Échec de la synchronisation des chansons hors connexion. Le disque est peut-être plein.",
  "usermessage.offline-sync-expired": "Les chansons synchronisées hors connexion ont expiré. Vous devez vous connecter à Spotify pour les réactiver.",
  "usermessage.offline-sync-failed": "Échec de la synchronisation des chansons hors connexion.",
  "usermessage.offline-too-many-tracks": "Il y a trop de chansons sélectionnées pour le mode hors connexion.",
  "usermessage.offline-license-server-error": "Un problème est survenu sur le serveur Spotify.",
  "usermessage.offline-license-lost": "L'accès hors connexion n'est plus actif pour cet ordinateur/appareil.",
  "usermessage.offline-not-allowed": "Le mode hors connexion est une exclusivité <a href=\"#\" data-action=\"{0}\">Spotify Premium</a> .",
  "usermessage.language-changed": "Vous devez <a href=\"#\" data-action=\"{0}\">redémarrer Spotify</a> pour que les modifications soient prises en compte.",
  "usermessage.proxysettings-changed": "Vous devez <a href=\"#\" data-action=\"{0}\">redémarrer Spotify</a> pour que les modifications soient prises en compte.",
  "usermessage.language-changed-simple": "Vous devez redémarrer Spotify pour que vos modifications soient prises en compte.",
  "usermessage.proxysettings-changed-simple": "Vous devez redémarrer Spotify pour que vos modifications soient prises en compte.",
  "usermessage.cache-changed": "Vous devez <a href=\"#\" data-action=\"{0}\">redémarrer Spotify</a> pour que les modifications soient prises en compte.",
  "usermessage.cache-changed-simple": "Vous devez redémarrer Spotify pour que vos modifications soient prises en compte.",
  "usermessage.feature-changed": "Vous devez <a href=\"#\" data-action=\"{0}\">redémarrer Spotify</a> pour que les modifications soient prises en compte.",
  "usermessage.first-autostart": "Spotify s'est ouvert automatiquement, mais est minimisé. Si vous préférez, vous pouvez <a href=\"#\" data-action=\"{0}\">ouvrir Spotify automatiquement sans que l'appli soit minimisée </a> ou <a href=\"#\" data-action=\"{1}\">ne pas l'ouvrir du tout au démarrage </a>.",
  "usermessage.cant-play-track": "Impossible de lire la chanson sélectionnée.",
  "usermessage.cant-skip-ads": "La chanson sélectionnée commencera après l'interruption.",
  "usermessage.cant-offline-playlists": "Le mode hors connexion est une exclusivité Spotify Premium. <a href=\"#\" data-action=\"{0}\">Abonnez-vous à Spotify Premium</a>.",
  "usermessage.cant-set-high-quality-streaming": "Fonctionnalité réservée aux abonnés Spotify Premium. <a href=\"#\" data-action=\"{0}\">Abonnez-vous à Spotify Premium</a>.",
  "usermessage.payment-state-creditcard-funds": "En raison d'un problème de paiement, nous n'avons pas pu renouveler votre abonnement. Vérifiez que votre compte est bien approvisionné ou <a href=\"#\" data-action=\"{0}\">mettez à jour vos informations de paiement</a>.",
  "usermessage.payment-state-creditcard-refused": "En raison d'un problème de paiement, nous n'avons pas pu renouveler votre abonnement. Pour conserver votre abonnement, <a href=\"#\" data-action=\"{0}\">mettez à jour vos informations de paiement</a>.",
  "usermessage.payment-state-paypal-refused": "En raison d'un problème de paiement, nous n'avons pas pu renouveler votre abonnement. Pour conserver votre abonnement, <a href=\"#\" data-action=\"{0}\">mettez à jour vos informations de paiement</a>.",
  "usermessage.payment-state-creditcard-expiry": "La carte de paiement que vous utilisez actuellement expire dans quelques jours. Pour conserver votre abonnement, <a href=\"#\" data-action=\"{0}\">mettez à jour vos informations de paiement</a>.",
  "usermessage.payment-state-prepaid-expiry": "Votre abonnement prépayé arrive bientôt à expiration. Pas d'inquiétude, vous pouvez <a href=\"#\" data-action=\"{0}\">vous abonner à Spotify Premium ici</a>.",
  "usermessage.payment-state-churn-payment": "Impossible de débiter votre compte. Nous avons malheureusement dû annuler votre abonnement. Pas d'inquiétude, vous pouvez <a href=\"#\" data-action=\"{0}\">renouveler votre abonnement ici</a>.",
  "usermessage.payment-state-churn-partner": "L'abonnement que vous avez souscrit avec l'un de nos partenaires vient d'arriver à expiration, vous utilisez donc maintenant Spotify Free. Pas d'inquiétude, vous pouvez <a href=\"#\" data-action=\"{0}\">retrouver Spotify Premium ici</a>.",
  "usermessage.opt-in-trial": "Nous espérons que vous appréciez notre essai gratuit ! Pour éviter de perdre Spotify Premium à la fin de l'essai, <a href=\"#\" data-action=\"{0}\">abonnez-vous dès maintenant</a>.",
  "usermessage.opt-in-trial-expired": "Votre offre d'essai est terminée. Vous utilisez maintenant Spotify Free. Pas d'inquiétude, vous pouvez <a href=\"#\" data-action=\"{0}\">retrouver Spotify Premium ici</a>.",
  "usermessage.hardware-acceleration-changed": "Vous devez <a href=\"#\" data-action=\"{0}\">redémarrer Spotify</a> pour que les modifications soient prises en compte.",
  "usermessage.hardware-acceleration-changed-simple": "Vous devez redémarrer Spotify pour que vos modifications soient prises en compte.",
  "usermessage.some-local-tracks-not-saved": "Certaines des chansons sélectionnées n'ont pas été sauvegardées dans Ma musique. Les fichiers locaux ne sont pas pris en charge par Ma musique.",
  "usermessage.illegal-playlist-name-entered": "Le nom de playlist que vous avez saisi n'est pas valide.",
  "usermessage.playlist-save-failed-unknown": "En raison d'un erreur inconnue, il n'est pas possible de sauvegarder la playlist.",
  "usermessage.social-error-permissions": "<a href=\"#\" data-action=\"{0}\">Cliquez ici</a> pour autoriser le partage de votre activité musicale sur Facebook.",
  "usermessage.shuffle-unplayable-track": "<a href=\"#\" data-action=\"{0}\">Passez à Spotify Premium pour</a> écouter les titres de votre choix à tout moment.",
  "usermessage.shuffle-ran-out-of-skips": "Vous ne pouvez plus passer de titres (pendant une heure). <a href=\"#\" data-action=\"{0}\">Abonnez-vous à Spotify Premium pour</a> en passer autant de fois que vous le souhaitez.",
  "usermessage.playlist-limit-exceeded": "Cette playlist est déjà remplie au maximum. Beau travail ! Démarrez-en une autre dès maintenant pour continuer à enrichir votre collection.",
  "usermessage.collection-limit-exceeded": "Wahou ! Quelle collection ! Il n'y a plus de place dans votre dossier Ma musique. Pour sauvegarder d'autres titres, vous devez en supprimer quelques-uns.",
  "usermessage.deprecating-os-version": "Votre attention s'il vous plaît ! Nous ne prendrons plus en charge votre système d'exploitation dans notre prochaine mise à jour. Pour plus d'informations, <a href=\"#\" data-action=\"{0}\">cliquez ici</a>.",
  "usermessage.image-upload-propagation": "Bien joué ! (La propagation des images peut nécessiter jusqu'à 24 heures)",
  "usermessage.approaching-capping-limit": "Il ne vous reste plus qu'une heure d'écoute gratuite. Profitez de 15 heures d'écoute gratuite par mois ou <a href=\"#\" data-action=\"{0}\">abonnez-vous à Spotify Premium</a> pour un accès illimité à la musique. <a href=\"#\" data-action=\"{1}\">En savoir plus</a>.",
  "usermessage.half-capping-limit-passed": "Vous avez atteint la moitié de votre quota mensuel. Profitez de 15 heures d'écoute gratuite par mois ou <a href=\"#\" data-action=\"{0}\">abonnez-vous à Spotify Premium</a> pour un accès illimité à la musique. <a href=\"#\" data-action=\"{1}\">En savoir plus</a>.",
  "usermessage.video-georestricted": "Impossible de lire cette vidéo à votre emplacement actuel.",
  "usermessage.video-unsupported-client-version": "Veuillez mettre à jour Spotify pour lire cette vidéo.",
  "usermessage.video-unsupported-platform-version": "La version de votre système d'exploitation ne permet pas de lire cette vidéo.",
  "usermessage.video-country-restricted": "Impossible de lire cette vidéo à votre emplacement actuel.",
  "usermessage.video-unavailable": "Cette vidéo n'est pas disponible. En tester une autre ?",
  "usermessage.video-catalogue-restricted": "Désolé, impossible de lire cette vidéo.",
  "usermessage.video-playback-error": "Désolé, impossible de lire cette vidéo.",
  "about.title_label": "À propos de Spotify",
  "about.close_button_label": "Fermer",
  "offline-progress-msg": "{0} sur {1} en cours de synchro hors connexion",
  "tos.updated_terms": "Mise à jour des Conditions d'utilisation",
  "tos.modal_title": "Conditions d'utilisation de Spotify",
  "tos.tos_text": "<p>Nous avons revu nos <a href=\"{0}\">Conditions générales d'utilisation</a> et notre <a href=\"{1}\">Politique de confidentialité</a>.</p><p>En continuant à utiliser Spotify, vous acceptez ces mises à jour. Merci de prendre quelques minutes pour bien les lire et les comprendre.</p>",
  "tos.not_now_tos_text": "<p>Nous avons revu nos <a href=\"{0}\">Conditions générales d'utilisation</a> et notre <a href=\"{1}\">Politique de confidentialité</a>.</p><p>En cliquant sur « Accepter », vous acceptez ces modifications (et le traitement de vos données comme indiqué). Merci de prendre quelques minutes pour les lire et bien les comprendre.</p>",
  "tos.tos_text2": "<p>Si vous ne souhaitez plus utiliser Spotify, vous pouvez annuler votre abonnement en vous rendant sur la page de gestion de votre abonnement sur Spotify.</p>",
  "tos.not_now_text": "<p>Vous pouvez continuer à utiliser Spotify pendant{0} jours sans accepter les nouvelles Conditions d'utilisation et Politique de confidentialité. Passé ce délai, vous devrez accepter les nouvelles conditions pour continuer à utiliser Spotify. À moins d'annuler votre abonnement, vous serez débité chaque mois conformément à votre cycle de facturation standard. Si vous ne voulez plus être débité par Spotify, vous pouvez annuler votre abonnement à tout moment sur votre page Abonnement.</p>",
  "tos.not_now_last_day_text": "<p>Vous pouvez continuer à utiliser Spotify pendant 1 jour sans accepter les modifications des Conditions générales de vente et de la Politique de confidentialité. Si vous n'acceptez pas les nouvelles conditions d'ici là, vous ne pourrez plus utiliser Spotify. Si vous n'annulez pas votre abonnement, il continuera de vous être facturé chaque mois conformément à votre cycle de facturation régulier. Si vous ne souhaitez plus que Spotify vous facture, vous pouvez annuler votre abonnement à tout moment sur la page de gestion de votre abonnement Spotify.</p>",
  "tos.not_now_text_germany": "<p>Nous avons mis à jour nos <a href=\"{0}\">Conditions d'utilisation</a> et notre <a href=\"{1}\">Politique de confidentialité</a>. Merci de noter qu'avec votre accord, Spotify GmbH souhaite transférer votre contrat vers Spotify AB, Birger Jarlsgatan 61, 113 56 Stockholm, Suède.</p><p>Vous pouvez continuer à utiliser le service Spotify dans le cadre du contrat existant jusqu'au {2}. Après cette date, si vous souhaitez continuer à utiliser le service Spotify, vous devez accepter les nouvelles Conditions d'utilisation et Politique de confidentialité. En cliquant sur « Accepter », vous acceptez</p><p>a) le transfert de votre contrat de Spotify GmbH vers Spotify AB,<br />b) les mises à jour des Conditions d'utilisation et<br />c) la collecte, le traitement et l'utilisation de vos données personnelles comme décrit dans les sections 4, 5 et 7 de la Politique de confidentialité.</p>",
  "tos.not_now_text2_germany": "<p>Vous pouvez continuer à utiliser Spotify jusqu'au {0}  sans accepter les Conditions d'utilisation et la Politique de confidentialité mises à jour. Passée cette date, vous devrez accepter les nouvelles conditions pour continuer à utiliser Spotify. Si vous êtes utilisateur de Spotify Premium, vous continuerez à être débité chaque mois selon votre cycle de facturation standard sauf si vous annulez votre abonnement. Si vous ne voulez plus être débité par Spotify, vous pouvez annuler votre abonnement à tout moment sur votre page Abonnement.</p>",
  "tos.not_now_expired_text_germany": "<p>Nous avons mis à jour nos <a href=\"{0}\">Conditions d'utilisation</a> et notre <a href=\"{1}\">Politique de confidentialité</a>.</p><p>Merci de noter qu'avec votre accord, Spotify GmbH souhaite transférer votre contrat vers Spotify AB, Birger Jarlsgatan 61, 113 56 Stockholm, Suède. </p><p>Pour continuer à utiliser le service Spotify, vous devez accepter les nouvelles Conditions d'utilisation et Politique de confidentialité. En cliquant sur « Accepter », vous acceptez</p><p>a) le transfert de votre contrat de Spotify GmbH vers Spotify AB, <br/>b) les mises à jour des Conditions d'utilisation et <br/>c) la collecte, le traitement et l'utilisation de vos données personnelles comme décrit dans les sections  4, 5 et 7 de la Politique de confidentialité.</p>",
  "tos.back_button_label": "Retour",
  "tos.ok_button_label": "OK",
  "tos.agree_button_label": "Confirmer",
  "tos.cancel_button_label": "Refuser",
  "tos.not_now_button_label": "Pas maintenant",
  "licenses.modal_title": "Licences tierces",
  "licenses.close_button_label": "Fermer",
  "feedback.beta_title": "Version bêta",
  "feedback.beta_text": "Vous aimez un peu, beaucoup, passionnément ou pas du tout ? Dites-le nous.",
  "market.ad": "Andorre",
  "market.ar": "Argentine",
  "market.at": "Autriche",
  "market.au": "Australie",
  "market.be": "Belgique",
  "market.bg": "Bulgarie",
  "market.bo": "Bolivie",
  "market.br": "Brésil",
  "market.ca": "Canada",
  "market.ch": "Suisse",
  "market.cl": "Chili",
  "market.co": "Colombie",
  "market.cr": "Costa Rica",
  "market.cy": "Chypre",
  "market.cz": "République tchèque",
  "market.de": "Allemagne",
  "market.dk": "Danemark",
  "market.do": "République dominicaine",
  "market.ec": "Équateur",
  "market.ee": "Estonie",
  "market.es": "Espagne",
  "market.fi": "Finlande",
  "market.fr": "France",
  "market.gr": "Grèce",
  "market.gt": "Guatemala",
  "market.hk": "Hong-Kong",
  "market.hn": "Honduras",
  "market.hu": "Hongrie",
  "market.ie": "Irlande",
  "market.is": "Islande",
  "market.it": "Italie",
  "market.jp": "Japon",
  "market.li": "Liechtenstein",
  "market.lt": "Lituanie",
  "market.lu": "Luxembourg",
  "market.lv": "Lettonie",
  "market.mc": "Monaco",
  "market.mt": "Malte",
  "market.mx": "Mexique",
  "market.my": "Malaisie",
  "market.ni": "Nicaragua",
  "market.nl": "Pays-Bas",
  "market.no": "Norvège",
  "market.nz": "Nouvelle-Zélande",
  "market.pa": "Panama",
  "market.pe": "Pérou",
  "market.ph": "Philippines",
  "market.pl": "Pologne",
  "market.pt": "Portugal",
  "market.py": "Paraguay",
  "market.se": "Suède",
  "market.sg": "Singapour",
  "market.sk": "Slovaquie",
  "market.sv": "Salvador",
  "market.tr": "Turquie",
  "market.tw": "Taiwan",
  "market.uk": "Royaume-Uni",
  "market.us": "États-Unis",
  "market.uy": "Uruguay",
  "market.za": "Afrique du Sud",
  "sTitle": "Donnez-nous votre avis et aidez-nous à créer le meilleur service de musique au monde !",
  "sQ1Question": "Quelle est la probabilité que vous recommandiez Spotify à un ami ou collègue ?",
  "sQ1Negative": "Très peu probable",
  "sQ1Positive": "Très probable",
  "sQ2Question": "Pour quelle raison ?",
  "sQ3Question": "Dans l'ensemble, êtes-vous satisfait de Spotify ?",
  "sQ3Negative": "Très insatisfait",
  "sQ3Positive": "Très satisfait",
  "sSubmit": "Envoyer les réponses",
  "sThanks": "Merci beaucoup de votre aide et du temps que vous nous avez consacré.",
  "sTeam": "L'équipe Spotify",
  "sClose": "Fermer",
  "cls.highlight": "Spotify Premium est en veille",
  "cls.title": "Votre dernier paiement n'est pas passé.",
  "cls.desc": "Continuez à écouter de la musique avec Spotify Premium en ajoutant un nouveau mode de paiement. Cela ne prendra que quelques minutes.",
  "cls.updatePayment": "Mettre à jour les données de paiement",
  "cls.cancelSubscription": "Vous pouvez également repasser à Spotify Free <br>en <a class=\"cancel-sub\" href=\"#cancel\">annulant votre abonnement à Spotify Premium</a>.",
  "capping.upsell-title": "Vous avez atteint votre limite d'écoute gratuite.",
  "capping.upsell-message": "Vous obtenez 15 heures d'écoute gratuite chaque mois.<br />Abonnez-vous à Spotify Premium pour écouter en illimité sans publicité.",
  "capping.upsell-button-label": "Abonnez-vous à Spotify Premium",
  "capping.defaultRefillMessage": "Vous atteindrez bientôt votre plafond d'écoute gratuite.",
  "capping.refillMessage": "Vous atteindrez votre plafond d'écoute gratuite dans les {0} prochains jours.",
  "capping.welcome-title": "Bienvenue sur Spotify.",
  "capping.welcome-message": "Profitez de 15 heures d'écoute gratuite chaque mois.<br> <a data-action={0}>Passez à Spotify Premium</a> pour une écoute illimitée, sans le moindre spot publicitaire.",
  "capping.welcome-message-button-label": "Commencer",
  "yourArtistsTooltipTitle": "Gérer vos artistes",
  "yourArtistsTooltipText": "À présent, vous pouvez modifier très facilement l'image de profil de votre artiste sur Spotify.",
  "yourArtists": "Vos artistes"
};
},{}],9:[function(require,module,exports){
module.exports = {
  "browse.app_name": "Böngészés",
  "latest-releases.app_name": "Új kiadványok",
  "discover.app_name": "Felfedezés",
  "activity.app_name": "Események",
  "radio.app_name": "Rádió",
  "settings.app_name": "Beállítások",
  "messages.app_name": "Üzenetek",
  "profile.app_name": "Profil",
  "notifications_center.app_name": "Értesítések",
  "concerts.app_name": "Koncertek",
  "profile.private_session": "Privát zenehallgatás",
  "profile.upgrade": "Csomagváltás",
  "profile.upgrade_account": "Csomagváltás",
  "profile.upgrade_tooltip": "Váltás Premiumra",
  "profile.account": "Fiók",
  "profile.logout": "Kijelentkezés",
  "profile.enabled": "Engedélyezett",
  "profile.menu_label": "Menü",
  "profile.switch": "Felhasználóváltás",
  "profile.new_user": "Váltás új felhasználóra",
  "your_music.app_name": "Zenéid",
  "your_music.songs": "Dalok",
  "your_music.artists": "Előadók",
  "your_music.albums": "Albumok",
  "your_music.stations": "Rádiók",
  "your_music.local_files": "Helyi fájlok",
  "sidebar.title_main": "Főmenü",
  "sidebar.title_playlists": "Lejátszási listák",
  "new_playlist.input_placeholder": "Új lejátszási lista",
  "new_playlist.button": "Új lejátszási lista",
  "accessibilitylinks.skip_to_content_label": "Tovább a fő tartalomra",
  "accessibilitylinks.skip_to_player_label": "Tovább a vezérlőpulthoz",
  "playlist.by": "{0} összeállításában",
  "playlist.loading": "Betöltés...",
  "playlist.newfolder": "Új mappa",
  "playlist.delete_message": "Tényleg törlöd ezt a lejátszási listát?",
  "playlist.unfollow_message": "Tényleg nem érdekel már ez a lejátszási lista?",
  "playlistfolder.delete_message": "Törlöd ezt a mappát a benne lévő lejátszási listákkal?",
  "playlist.delete_confirm": "Törlés",
  "playlist.unfollow_confirm": "Nem követem",
  "playlist.delete_cancel": "Mégse",
  "playlist.duplicates_dialog_title": "Ismétlődő számok",
  "playlist.duplicates_dialog_title_single": "Ismétlődő szám",
  "playlist.duplicates_dialog_body": "Ezek közül néhány szám már a lejátszási listádon van.",
  "playlist.duplicates_dialog_body_single": "Ez a szám már a lejátszási listádon van.",
  "playlist.duplicates_dialog_button_add": "Összes felvétele",
  "playlist.duplicates_dialog_button_add_single": "Felvétel",
  "playlist.duplicates_dialog_button_skip_duplicates": "Ismétlődések nélkül",
  "playlist.duplicates_dialog_button_skip_single": "Ismétlődések nélkül",
  "playlist.annotate_form.new_playlist_name": "Új lejátszási lista",
  "playlist.annotate_form.create_title": "Lejátszási lista létrehozása",
  "playlist.annotate_form.create": "Létrehozás",
  "playlist.annotate_form.cancel": "Mégse",
  "playlist.annotate_form.edit_title": "Lejátszási lista adatainak szerkesztése",
  "playlist.annotate_form.save": "Mentés",
  "playlist.annotate_form.name_field_label": "Név",
  "playlist.annotate_form.name_field_placeholder": "Lejátszási lista neve",
  "playlist.annotate_form.image_field_label": "Kép",
  "playlist.annotate_form.image_pick_button_label": "Kép választása",
  "playlist.annotate_form.image_replace_button_label": "Kép cseréje",
  "playlist.annotate_form.image_remove_button_label": "Kép törlése",
  "playlist.annotate_form.image_file_size_exceeded": "A kép mérete meghaladja a 4 MB-os felső határt.",
  "playlist.annotate_form.image_file_upload_failed": "Nem sikerült feltölteni a képet. Próbálkozz újra.",
  "playlist.annotate_form.annotate_failed": "Nem sikerült frissíteni az ismertetőt és a képet. Próbálkozz újra.",
  "playlist.annotate_form.close-error-bar": "Elrejtés",
  "playlist.annotate_form.description_field_label": "Ismertető",
  "playlist.annotate_form.description_field_placeholder": "Érdemes egy ütős kedvcsinálót írnod a lejátszási listádhoz.",
  "playlist.annotate_form.permission_message": "A továbblépéssel engedélyt adsz a Spotifynak az általad feltöltésre választott kép elérésére. Győződj meg arról, hogy rendelkezel a kép feltöltéséhez szükséges jogosultsággal. A képet kizárólag a műsorlistád borítójaként fogjuk felhasználni.",
  "playlist.annotate_form.insert_link_button_label": "Link beszúrása",
  "playlist.annotate_form.insert_link.link_field_label": "Linkelt oldal",
  "playlist.annotate_form.insert_link.change_button_label": "Módosítás",
  "playlist.annotate_form.insert_link.remove_button_label": "Eltávolítás",
  "playlist.annotate_form.insert_link.done_button_label": "Kész",
  "playlist.annotate_form.drop_to_set_image_label": "Húzd ide a kívánt képet",
  "playlist.annotate_form.drop_not_allowed_label": "Nem támogatott formátum",
  "playlist.annotate_form.error.file_not_valid_jpg": "Ez a fájl a neve ellenére valójában nem JPG-képet tartalmaz.",
  "playlist.annotate_form.error.name_required": "Adj nevet a lejátszási listának.",
  "playlist.annotate_form.error.selection_required_to_insert_link": "Jelöld ki a linkké alakítandó szöveget.",
  "playlist.annotate_form.error.html_not_allowed": "Lehet, hogy HTML-fájllal próbálkoztál, ezt viszont nem támogatja a rendszer.",
  "playlist.annotate_form.error.submit": "Nem sikerült menteni a lejátszási lista módosításait. Próbálkozz újra.",
  "playlist.annotate_form.error.image_too_small": "A képméret túl kicsi. Legalább {0} x {1} képpontos képet kell választani.",
  "playlist.annotate_form.warning.client_offline": "Nincs internetkapcsolat. Nem lehet menteni az ismertetőt és a képet.",
  "playlist.annotate_form.warning.no_line_breaks_in_description": "Az ismertető csak egy bekezdésből állhat.",
  "playlist.annotate_form.warning.unsaved_changes": "Nem szeretnéd menteni a módosításokat?",
  "navigation.label": "Navigáció",
  "navigation.back_button_label": "Vissza",
  "navigation.forward_button_label": "Előre",
  "search.input_placeholder": "Keresés",
  "player.label": "Vezérlőpult",
  "player.shuffle_mode_label": "Véletlen sorrend",
  "player.repeat_mode_label": "Ismétlés",
  "player.queue": "Műsor",
  "player.volume_button_label": "Hangerő",
  "player.spotify_connect": "Spotify Connect",
  "player.connect_button_label": "Csatlakozás másik készülékhez",
  "player.lyrics_label": "Dalszöveg",
  "player.play_button_label": "Lejátszás",
  "player.pause_button_label": "Szünet",
  "player.previous_button_label": "Előző",
  "player.next_button_label": "Következő",
  "player.offline_label": "Offline",
  "player.thumb_up_label": "Tetszik",
  "player.thumb_down_label": "Nem tetszik",
  "playererror.default": "Nem tudtuk elindítani a választott számot",
  "playererror.track_not_available": "Ez a szám nem érhető el",
  "nowplaying.label": "Műsoron",
  "nowplaying.go_to_context": "Mi szól most?",
  "nowplaying.save_your_music": "Mentés a Zenéid közé",
  "nowplaying.remove_your_music": "Törlés a Zenéid közül",
  "nowplaying.playing_suggested_track": "Éppen egy ajánlott számot hallgatsz",
  "connect.connect_text": "Csatlakozás másik készülékhez",
  "connect.device_connecting": "Kapcsolódás…",
  "connect.device_incompatible": "Nem kompatibilis",
  "connect.device_premium_only": "Csak Premium-előfizetőknek",
  "connect.device_sleeping": "A készülék alvó üzemmódban van",
  "connect.device_tech_cast": "Google Cast",
  "connect.device_tech_connect": "Spotify Connect",
  "connect.device_this_computer": "Ez a gép",
  "connect.device_unavailable_for_playback": "Nem játszható le ezen:",
  "connect.device_unknown": "Ismeretlen eszköz",
  "connect.device_unsupported_uri": "Ez a tartalom nem játszható le ezen a lejátszón",
  "connect.devices_available": "Más készülékek is elérhetők",
  "connect.dismiss": "Nem fontos",
  "connect.help1": "A Connect lehetővé teszi a zenelejátszást és a Spotify vezérlését az eszközeiden.",
  "connect.help2": "Ha elindítod a Spotifyt egy másik készüléken, varázslatos módon itt is meg fog jelenni.",
  "connect.help_hint": "Mire való a Connect?",
  "connect.offline": "Nem érhető el",
  "connect.offline_reason_computer": "Ezen a készüléken nem aktív a Spotify.",
  "connect.offline_reason_generic": "Ezen a készüléken nem aktív a Spotify.",
  "connect.offline_reason_phone": "A telefon zárolva van, vagy nincs előtérben a Spotify.",
  "connect.offline_reason_gameconsole": "A Spotify PlayStation alkalmazás bekapcsolási beállításaival engedélyezhető a PlayStation automatikus bekapcsolása készenléti állapotból.",
  "connect.offline_text1": "A funkció használatához csatlakoznod kell az internethez.",
  "connect.offline_title": "Offline módban vagy",
  "connect.playingon": "Lejátszó:",
  "connect.popup_title": "Készülékek",
  "connect.remoteplayback": "Lejátszó: {0}",
  "connect.show_more": "Tovább",
  "connect.upgrade": "Csomagváltás",
  "connect.upsell": "A Connect a Premium verzió funkciója, és lehetővé teszi, hogy különböző eszközökön futtasd és vezéreld a Spotifyt.",
  "contextmenu.new-playlist": "Új lejátszási lista",
  "contextmenu.add-to-playlist": "Hozzáadás a lejátszási listához",
  "contextmenu.owner-playlist": "{0} összeállításában",
  "contextmenu.copy-uri": "Spotifyos URI másolása",
  "contextmenu.copy-artist-url": "Előadó linkjének másolása",
  "contextmenu.copy-album-url": "Album linkjének másolása",
  "contextmenu.copy-track-url": "Szám linkjének másolása",
  "contextmenu.copy-playlist-url": "Lejátszási lista linkjének másolása",
  "contextmenu.copy-profile-url": "Profil linkjének másolása",
  "contextmenu.copy-station-url": "Rádió linkjének másolása",
  "contextmenu.copy-chart-url": "Toplista hivatkozásának másolása",
  "contextmenu.copy-url": "Link másolása",
  "contextmenu.copy-embed": "Beágyazási kód másolása",
  "contextmenu.collaborative": "Közös lejátszási lista",
  "contextmenu.save": "Mentés a Zenéid közé",
  "contextmenu.remove": "Törlés a Zenéid közül",
  "contextmenu.delete-playlist": "Törlés",
  "contextmenu.follow": "Követés",
  "contextmenu.unfollow": "Nem követem",
  "contextmenu.publish": "Legyen nyilvános",
  "contextmenu.unpublish": "Legyen titkos",
  "contextmenu.playlist.loading": "Betöltés...",
  "contextmenu.play": "Lejátszás",
  "contextmenu.add-to-queue": "Műsorra tűzés",
  "contextmenu.station": "Ugrás a rádióra",
  "contextmenu.station-album": "Albumrádió oldala",
  "contextmenu.station-artist": "Előadói rádió oldala",
  "contextmenu.station-playlist": "Lejátszási listás rádió oldala",
  "contextmenu.station-track": "Zeneszámos rádió oldala",
  "contextmenu.station-chart": "Toplistarádió megnyitása",
  "contextmenu.remove-from-playlist": "Törlés ebből a lejátszási listából",
  "contextmenu.remove-from-queue": "Törlés a műsorból",
  "contextmenu.rename-folder": "Átnevezés",
  "contextmenu.rename-playlist": "Átnevezés",
  "contextmenu.edit-playlist": "Adatok szerkesztése",
  "contextmenu.report-playlist": "Jelentés",
  "contextmenu.report-asset": "Jelentés",
  "contextmenu.share": "Megosztás...",
  "contextmenu.share-lyrics": "Dalszöveg megosztása",
  "contextmenu.create-folder": "Új mappa",
  "contextmenu.create-playlist": "Lejátszási lista létrehozása",
  "contextmenu.open-localfile-folder": "Mappa megnyitása",
  "contextmenu.open-localfile-folder-mac": "Megjelenítés a Finderben",
  "contextmenu.offline": "Offline is elérhető",
  "contextmenu.goto-artist": "Előadó oldala",
  "contextmenu.goto-album": "Album oldala",
  "usermessage.default-message": "Hiba történt",
  "usermessage.update-ready": "Szia! Új Spotify-verzió vár rád! Csak <a href=\"#\" data-action=\"{0}\">újra kell indítanod az alkalmazást</a>.",
  "usermessage.update-ready-simple": "Üdv! Új Spotify-verzió vár rád! Csak újra kell indítanod az alkalmazást.",
  "usermessage.play-token-lost": "A Spotifyban szünetel a lejátszás, mert a fiókod máshol is használatban van.",
  "usermessage.playback-paused-inactive": "Hosszabb ideje nem nyúltál a géphez. Ha még mindig zenét hallgatsz, kattints a Lejátszás gombra. A szünet nélküli zenehallgatáshoz <a href=\"#\" data-action=\"{0}\">Spotify Premium</a> előfizetést kell vásárolnod.",
  "usermessage.not-available-offline": "Nem észlelhető internetkapcsolat. A Spotify megpróbál automatikusan újracsatlakozni, amint internetkapcsolatot észlel (4-es hiba).",
  "usermessage.track-not-available-in-region": "Ez a szám jelenleg nem érhető el {0} térségéből. Ha azonban a fájl megvan a gépeden, akkor importálhatod.",
  "usermessage.track-not-available-in-region-generic": "Ez a szám jelenleg nem érhető el a lakóhelyed szerinti országban. Ha azonban a fájl megvan a gépeden, akkor importálhatod.",
  "usermessage.track-not-available": "Ez a szám nem érhető el. Ha azonban a fájl megvan a gépeden, akkor importálhatod.",
  "usermessage.track-not-available-forced-offline": "<a href=\"#\" data-action=\"goOnline\">Kapcsold ki az offline üzemmódot</a>, és próbálkozz újra.",
  "usermessage.track-exclusive-premium": "Ezt a számot csak <a href=\"#\" data-action=\"{0}\">Spotify Premium-előfizetők</a> hallgathatják meg.",
  "usermessage.track-banned-by-artist": "Az előadó/kiadó visszavonta ezt a számot a gyűjteményünkből. Ha azonban a fájl megvan a gépeden, akkor importálhatod.",
  "usermessage.local-track-no-file": "Ezt a számot helyi fájlként vetted fel. Ha azonban a fájl megvan a gépeden, akkor importálhatod.",
  "usermessage.local-track-file-not-found": "Nem tudtuk lejátszani ezt a számot, mert nincs meg a fájl. Importáld újra.",
  "usermessage.local-track-bad-format": "A fájl formátuma ismeretlen. A részletekről <a href=\"#\" data-action=\"{0}\">ezen az oldalon</a> tájékozódhatsz.",
  "usermessage.capping-reached": "Letelt a(z) {0} órás időkereted. A korlátozásoktól mentes zenehallgatáshoz <a href=\"#\" data-action=\"{1}\">átválthatsz Spotify Premium csomagunkra</a>.",
  "usermessage.local-track-drm-protected": "Ezt a számot nem lehet lejátszani, mert digitális jogvédelmi technológia (DRM) védi.",
  "usermessage.offline-disk-cache": "Nem minden számot sikerült letölteni offline lejátszásra. Lehet, hogy megtelt a lemez?",
  "usermessage.offline-sync-expired": "Lejárt az offline számok érvényessége. Az újraaktiválásukhoz jelentkezz be a Spotifyba.",
  "usermessage.offline-sync-failed": "Nem minden számot sikerült letölteni offline lejátszásra.",
  "usermessage.offline-too-many-tracks": "Túl sok számot választottál offline lejátszásra.",
  "usermessage.offline-license-server-error": "Műszaki hiba lépett fel a Spotify kiszolgálóján.",
  "usermessage.offline-license-lost": "Visszavonták a számítógép vagy a készülék offline lejátszási engedélyét.",
  "usermessage.offline-not-allowed": "Az offline lejátszási funkciót csak <a href=\"#\" data-action=\"{0}\">Spotify Premium-előfizetőink</a> használhatják.",
  "usermessage.language-changed": "A módosítások életbe léptetéséhez <a href=\"#\" data-action=\"{0}\">újra kell indítani a Spotifyt</a>",
  "usermessage.proxysettings-changed": "A módosítások életbe léptetéséhez <a href=\"#\" data-action=\"{0}\">újra kell indítani a Spotifyt</a>",
  "usermessage.language-changed-simple": "A módosítások életbe lépéséhez újra kell indítani a Spotifyt",
  "usermessage.proxysettings-changed-simple": "A módosítások életbe lépéséhez újra kell indítani a Spotifyt",
  "usermessage.cache-changed": "A módosítások életbe léptetéséhez <a href=\"#\" data-action=\"{0}\">újra kell indítani a Spotifyt</a>",
  "usermessage.cache-changed-simple": "A módosítások életbe lépéséhez újra kell indítani a Spotifyt",
  "usermessage.feature-changed": "A módosítások életbe léptetéséhez <a href=\"#\" data-action=\"{0}\">újra kell indítani a Spotifyt</a>",
  "usermessage.first-autostart": "A Spotify automatikusan megnyílt, de kis méretű maradt. Arra is lehetőség van, hogy <a href=\"#\" data-action=\"{0}\">a Spotify automatikusan normál méretben nyíljon meg</a> a rendszer indításakor, illetve azt is beállíthatod, hogy <a href=\"#\" data-action=\"{1}\">a Spotify ne induljon el automatikusan</a> a rendszerrel együtt.",
  "usermessage.cant-play-track": "Nem tudjuk lejátszani ezt a számot.",
  "usermessage.cant-skip-ads": "A választott számot a reklám után hallgathatod meg.",
  "usermessage.cant-offline-playlists": "Az offline lejátszási funkciót csak Spotify Premium-előfizetőink használhatják. <a href=\"#\" data-action=\"{0}\">Válts te is Premiumra</a>.",
  "usermessage.cant-set-high-quality-streaming": "Ez a funkció csak a Premium verzióban érhető el. <a href=\"#\" data-action=\"{0}\">Válts te is Premiumra</a>.",
  "usermessage.payment-state-creditcard-funds": "Egy fizetési probléma miatt nem sikerült meghosszabbítanunk előfizetésedet. Ellenőrizd fizetőeszközöd egyenlegét, és ha szükséges, <a href=\"#\" data-action=\"{0}\">módosítsd a fizetési adataidat</a>.",
  "usermessage.payment-state-creditcard-refused": "Egy fizetési probléma miatt nem sikerült meghosszabbítanunk előfizetésedet. Előfizetésed folytatásához <a href=\"#\" data-action=\"{0}\">módosítsd a fizetési adataidat</a>.",
  "usermessage.payment-state-paypal-refused": "Egy fizetési probléma miatt nem sikerült meghosszabbítanunk előfizetésedet. Előfizetésed folytatásához <a href=\"#\" data-action=\"{0}\">módosítsd a fizetési adataidat</a>.",
  "usermessage.payment-state-creditcard-expiry": "A jelenleg használt bankkártyád néhány napon belül lejár. Előfizetésed folytatásához <a href=\"#\" data-action=\"{0}\">módosítsd a fizetési adataidat</a>.",
  "usermessage.payment-state-prepaid-expiry": "Előre fizetett (feltöltős) előfizetésed hamarosan lejár. Aggodalomra azonban semmi ok, hiszen <a href=\"#\" data-action=\"{0}\">előfizethetsz a Premium csomagra</a>.",
  "usermessage.payment-state-churn-payment": "Sajnos nem sikerült levonnunk az előfizetési díjat, ezért meg kellett szüntetnünk az előfizetésedet. Aggodalomra azonban semmi ok, mert még <a href=\"#\" data-action=\"{0}\">meghosszabbíthatod</a>.",
  "usermessage.payment-state-churn-partner": "Partnerünkön keresztül kapott előfizetésed megszűnt, ezért a Spotify ingyenes csomagjának felhasználójává váltál. Aggodalomra azonban semmi ok, mert magad is <a href=\"#\" data-action=\"{0}\">előfizethetsz a Premium csomagra</a>.",
  "usermessage.opt-in-trial": "Reméljük, sok örömöt szerez az ingyenes próbaidőszak. Ha nem szeretnéd elveszíteni a Premium-funkciókat a próbaidőszak végén, célszerű már most <a href=\"#\" data-action=\"{0}\">előfizetést vásárolnod</a>.",
  "usermessage.opt-in-trial-expired": "Véget ért az ingyenes próbaidőszak, ezért a Spotify ingyenes csomagjának felhasználójává váltál. Aggodalomra azonban semmi ok, mert <a href=\"#\" data-action=\"{0}\">előfizethetsz a Premium csomagra</a>.",
  "usermessage.hardware-acceleration-changed": "A módosítások életbe léptetéséhez <a href=\"#\" data-action=\"{0}\">újra kell indítani a Spotifyt</a>",
  "usermessage.hardware-acceleration-changed-simple": "A módosítások életbe lépéséhez újra kell indítani a Spotifyt",
  "usermessage.some-local-tracks-not-saved": "Nem minden számot tudtunk a zenéd közé menteni, mert ez a gyűjtemény nem tartalmazhat helyi fájlokat.",
  "usermessage.illegal-playlist-name-entered": "Érvénytelen nevet adtál a lejátszási listának.",
  "usermessage.playlist-save-failed-unknown": "Ismeretlen hiba miatt nem sikerült menteni a lejátszási listát.",
  "usermessage.social-error-permissions": "Ha szeretnéd megosztani a zenehallgatással kapcsolatos történéseket a Facebookon, <a href=\"#\" data-action=\"{0}\">kattints ide</a> .",
  "usermessage.shuffle-unplayable-track": "<a href=\"#\" data-action=\"{0}\">Premium csomagra váltva</a> bármikor bármit meghallgathatsz.",
  "usermessage.shuffle-ran-out-of-skips": "Ebben az órában nem ugorhatsz át több számot. <a href=\"#\" data-action=\"{0}\">Premium csomagra váltva</a> viszont annyit ugrasz át, amennyit csak akarsz.",
  "usermessage.playlist-limit-exceeded": "Hát ezt a lejátszási listát rendesen kimaxoltad. Lenyűgöző! A többi számhoz viszont új lejátszási listát kell létrehoznod.",
  "usermessage.collection-limit-exceeded": "Ez bődületes mennyiség, jó barát! :) Sajnos nincs ennyi hely a Zenéim gyűjteményedben. Előbb törölnöd kell néhány számot vagy albumot a gyűjteményedből.",
  "usermessage.deprecating-os-version": "Figyelem, figyelem! Hamarosan megszüntetjük az általad használt operációs rendszer támogatását. A részletekről <a href=\"#\" data-action=\"{0}\">ezen az oldalon</a> tájékozódhatsz.",
  "usermessage.image-upload-propagation": "Hurrá, kész! (A képek véglegesítése akár 24 óráig is eltarthat)",
  "usermessage.approaching-capping-limit": "Kevesebb mint 1 óra ingyenes zenehallgatásod maradt. Élvezd az ingyenes zenehallgatást havi 15 órán át, vagy <a href=\"#\" data-action=\"{0}\">válts Premiumra</a> a korlátlan zenehallgatáshoz. <a href=\"#\" data-action=\"{1}\">Részletek</a>.",
  "usermessage.half-capping-limit-passed": "Elérted a havi időkereted felét. Élvezd az ingyenes zenehallgatást havi 15 órán át, vagy <a href=\"#\" data-action=\"{0}\">válts Premiumra</a> a korlátlan zenehallgatáshoz. <a href=\"#\" data-action=\"{1}\">Részletek</a>.",
  "usermessage.video-georestricted": "A tartózkodási helyeden nem tudjuk lejátszani ezt a videót.",
  "usermessage.video-unsupported-client-version": "A videó lejátszásához Spotify-előfizetőnek kell lenned.",
  "usermessage.video-unsupported-platform-version": "Ezen az operációsrendszer-verzión nem lehet lejátszani a videót.",
  "usermessage.video-country-restricted": "A tartózkodási helyeden nem tudjuk lejátszani ezt a videót.",
  "usermessage.video-unavailable": "Ez a videó nem érhető el. Próbálkozol másikkal?",
  "usermessage.video-catalogue-restricted": "Sajnos nem tudjuk lejátszani ezt a videót.",
  "usermessage.video-playback-error": "Sajnos nem tudjuk lejátszani ezt a videót.",
  "about.title_label": "A Spotify névjegye",
  "about.close_button_label": "Bezárás",
  "offline-progress-msg": "Offline szinkronizálás: {0}/{1} szám",
  "tos.updated_terms": "Módosított feltételek",
  "tos.modal_title": "A Spotify általános szerződési és használati feltételei",
  "tos.tos_text": "<p>Módosítottuk <a href=\"{0}\">általános szerződési feltételeinket</a> és <a href=\"{1}\">adatvédelmi szabályzatunkat</a>.</p><p>Mivel a Spotify további használatával kijelented, hogy elfogadod a szerződést és a szabályzatot, érdemes rászánni néhány percet, hogy átfusd, és megismerd a tartalmukat.</p>",
  "tos.not_now_tos_text": "<p>Módosítottuk <a href=\"{0}\">általános szerződési feltételeinket</a> és <a href=\"{1}\">adatvédelmi szabályzatunkat</a>.</p><p>Az Elfogadom gombra kattintva kijelented, hogy megismerted és elfogadtad a szerződést és a szabályzatot – az adatfeldolgozási rendelkezéseket is beleértve –, ezért érdemes rászánnod néhány percet, hogy átfusd és megismerd a tartalmukat.</p>",
  "tos.tos_text2": "<p>Ha már nem szeretnéd használni a Spotifyt, előfizetésedet a Spotify-előfizetésed oldalán bármikor megszüntetheted.</p>",
  "tos.not_now_text": "<p>Még {0} napig használhatod a Spotifyt a módosított ÁSZF és a szintén módosított adatvédelmi szabályzat elfogadása nélkül. Ha azonban ezalatt nem fogadod el a szerződést és a szabályzatot, utána nem fogod tudni használni a Spotifyt. Ha ebben az esetben nem mondod le előfizetésedet, továbbra is rendszeresen fizetned kell a havi díjat. Ezt elkerülheted, ha lemondod előfizetésedet a Spotify-előfizetésed oldalán.</p>",
  "tos.not_now_last_day_text": "<p>A Spotifyt még 1 napig használhatod a módosított ÁSZF és a szintén módosított adatvédelmi szabályzat elfogadása nélkül. Ha viszont ezalatt az idő alatt nem fogadod el a szerződést és a szabályzatot, a határidő lejárta után nem fogod tudni tovább használni a Spotifyt. Ha ebben az esetben nem mondod le előfizetésedet, továbbra is rendszeresen fizetned kell a havidíjat. Ezt elkerülheted, ha lemondod előfizetésedet a Spotify-előfizetésed oldalán.</p>",
  "tos.not_now_text_germany": "<p>Módosítottuk <a href=\"{0}\">általános szerződési feltételeinket</a> és <a href=\"{1}\">adatvédelmi szabályzatunkat</a>. Fontos, hogy hozzájárulásod birtokában a Spotify GmbH továbbítani kívánja a szerződésedet a Spotify AB (címe: Svédország, 113 56 Stockholm, Birger Jarlsgatan 61.) részére.</p><p>Az itt olvasható szerződési feltételek mellett {2} napjáig használhatod a Spotify szolgáltatásait. Ezt követően csak az új ÁSZF és az új adatvédelmi szabályzat elfogadásával folytathatod szolgáltatásaink igénybevételét. Az Elfogadom gombra kattintva</p><p>a) hozzájárulsz ahhoz, hogy szerződésed átkerüljön a Spotify GmbH-tól a Spotify AB-hez,<br />b) elfogadod az általános szerződési feltételeket, továbbá<br />c) elfogadod személyes adataid gyűjtésének, feldolgozásának és felhasználásának az adatvédelmi szabályzat 4., 5. és 7. szakaszában ismertetett módját.</p>",
  "tos.not_now_text2_germany": "<p>Még {0} napig használhatod a Spotifyt a módosított általános szerződési feltételek és a szintén módosított adatvédelmi szabályzat elfogadása nélkül. Ezt követően a Spotify további használatához el kell fogadnod az új feltételeket. Ha Premium-felhasználó vagy, továbbra is havonta, a szokott napon kell megfizetned a szolgáltatás díját, amíg le nem mondod az előfizetésedet. Ha a továbbiakban nem szeretnél fizetni a Spotifyért, előfizetésedet bármikor lemondhatod az előfizetésed oldalán.</p>",
  "tos.not_now_expired_text_germany": "<p>Módosítottuk <a href=\"{0}\">általános szerződési feltételeinket</a> és <a href=\"{1}\">adatvédelmi szabályzatunkat</a>.</p><p>Fontos, hogy hozzájárulásod birtokában a Spotify GmbH továbbítani kívánja a szerződésedet a Spotify AB (címe: Svédország, 113 56 Stockholm, Birger Jarlsgatan 61.) részére.</p><p>A Spotify szolgáltatásainak további igénybevételéhez el kell fogadnod az új általános szerződési feltételeket és az új adatvédelmi szabályzatot. Az Elfogadom gombra kattintva</p><p>a) hozzájárulsz, hogy szerződésed átkerüljön a Spotify GmbH-tól a Spotify AB-hez, <br/>) elfogadod az általános szerződési feltételeket, továbbá <br/> c) elfogadod személyes adataid gyűjtésének, feldolgozásának és felhasználásának az adatvédelmi szabályzat 4., 5. és 7. szakaszában ismertetett módját.</p>",
  "tos.back_button_label": "Vissza",
  "tos.ok_button_label": "OK",
  "tos.agree_button_label": "Elfogadom",
  "tos.cancel_button_label": "Elutasítom",
  "tos.not_now_button_label": "Majd máskor",
  "licenses.modal_title": "Külső felek licencei",
  "licenses.close_button_label": "Bezárás",
  "feedback.beta_title": "Bétaverzió",
  "feedback.beta_text": "Nagyon bírsz/utálsz valamit? Mondd el nekünk!",
  "market.ad": "Andorra",
  "market.ar": "Argentína",
  "market.at": "Ausztria",
  "market.au": "Ausztrália",
  "market.be": "Belgium",
  "market.bg": "Bulgária",
  "market.bo": "Bolívia",
  "market.br": "Brazília",
  "market.ca": "Kanada",
  "market.ch": "Svájc",
  "market.cl": "Chile",
  "market.co": "Kolumbia",
  "market.cr": "Costa Rica",
  "market.cy": "Ciprus",
  "market.cz": "Csehország",
  "market.de": "Németország",
  "market.dk": "Dánia",
  "market.do": "Dominikai Köztársaság",
  "market.ec": "Ecuador",
  "market.ee": "Észtország",
  "market.es": "Spanyolország",
  "market.fi": "Finnország",
  "market.fr": "Franciaország",
  "market.gr": "Görögország",
  "market.gt": "Guatemala",
  "market.hk": "Hongkong",
  "market.hn": "Honduras",
  "market.hu": "Magyarország",
  "market.ie": "Írország",
  "market.is": "Izland",
  "market.it": "Olaszország",
  "market.jp": "Japán",
  "market.li": "Liechtenstein",
  "market.lt": "Litvánia",
  "market.lu": "Luxemburg",
  "market.lv": "Lettország",
  "market.mc": "Monaco",
  "market.mt": "Málta",
  "market.mx": "Mexikó",
  "market.my": "Malajzia",
  "market.ni": "Nicaragua",
  "market.nl": "Hollandia",
  "market.no": "Norvégia",
  "market.nz": "Új-Zéland",
  "market.pa": "Panama",
  "market.pe": "Peru",
  "market.ph": "Fülöp-szigetek",
  "market.pl": "Lengyelország",
  "market.pt": "Portugália",
  "market.py": "Paraguay",
  "market.se": "Svédország",
  "market.sg": "Szingapúr",
  "market.sk": "Szlovákia",
  "market.sv": "Salvador",
  "market.tr": "Törökország",
  "market.tw": "Tajvan",
  "market.uk": "Egyesült Királyság",
  "market.us": "Amerikai Egyesült Államok",
  "market.uy": "Uruguay",
  "market.za": "Dél-Afrika",
  "sTitle": "Oszd meg gondolataidat, és segíts létrehozni a világ legnagyszerűbb zeneszolgáltatását!",
  "sQ1Question": "Mennyire valószínű, hogy ajánlani fogod a Spotifyt az ismerőseidnek vagy munkatársaidnak?",
  "sQ1Negative": "Egyáltalán nem valószínű",
  "sQ1Positive": "Nagyon valószínű",
  "sQ2Question": "Miért érzed így?",
  "sQ3Question": "Összességében mennyire vagy elégedett a Spotify szolgáltatással?",
  "sQ3Negative": "Nagyon elégedetlen",
  "sQ3Positive": "Nagyon elégedett",
  "sSubmit": "Felmérés beküldése",
  "sThanks": "Nagyon köszönjük a segítségedet és a kitöltéssel töltött idődet.",
  "sTeam": "A Spotify-csapat",
  "sClose": "Bezárás",
  "cls.highlight": "Premium-előfizetés felfüggesztve",
  "cls.title": "Nem sikerült rendezni az utolsó díjat.",
  "cls.desc": "Új fizetési adatok beállításával továbbra is Premium-előfizető maradhatsz. És csak néhány perc az egész.",
  "cls.updatePayment": "Fizetési adatok módosítása",
  "cls.cancelSubscription": "A Spotify ingyenes (Free) verziójára is áttérhetsz,<br>ha <a class=\"cancel-sub\" href=\"#cancel\">megszünteted Premium-előfizetésedet</a>.",
  "capping.upsell-title": "Elérted az ingyenes havi zenehallgatási korlátot.",
  "capping.upsell-message": "Havonta 15 órán keresztül hallgathatod ingyen a zenét.<br />Válts Premiumra a korlátlan és reklámok nélküli zenehallgatáshoz.",
  "capping.upsell-button-label": "Váltás Premiumra",
  "capping.defaultRefillMessage": "Hamarosan újraindul az ingyenes zenehallgatási időszakod.",
  "capping.refillMessage": "Az ingyenes zenehallgatási időszakod {0} nap múlva újraindul.",
  "capping.welcome-title": "Üdvözöl a Spotify!",
  "capping.welcome-message": "Havonta 15 órán keresztül hallgathatod ingyen a zenét.<br /> <a data-action={0}>Válts Premiumra</a> a reklámok nélküli korlátlan zenehallgatáshoz.",
  "capping.welcome-message-button-label": "Kezdés",
  "yourArtistsTooltipTitle": "Előadóid kezelése",
  "yourArtistsTooltipText": "Előadói profilképedet könnyedén szerkesztheted a Spotifyon.",
  "yourArtists": "Saját előadók"
};
},{}],10:[function(require,module,exports){
module.exports = {
  "browse.app_name": "Browse",
  "latest-releases.app_name": "Rilis Terbaru",
  "discover.app_name": "Temukan",
  "activity.app_name": "Aktivitas",
  "radio.app_name": "Radio",
  "settings.app_name": "Pengaturan",
  "messages.app_name": "Pesan",
  "profile.app_name": "Profil",
  "notifications_center.app_name": "Pemberitahuan",
  "concerts.app_name": "Konser",
  "profile.private_session": "Sesi Pribadi",
  "profile.upgrade": "Upgrade",
  "profile.upgrade_account": "Upgrade Akun Kamu",
  "profile.upgrade_tooltip": "Upgrade ke Premium",
  "profile.account": "Akun Kamu",
  "profile.logout": "Keluar",
  "profile.enabled": "Diaktifkan",
  "profile.menu_label": "Menu",
  "profile.switch": "Ganti Pengguna",
  "profile.new_user": "Ganti ke Pengguna Baru",
  "your_music.app_name": "Musik Kamu",
  "your_music.songs": "Lagu",
  "your_music.artists": "Artis",
  "your_music.albums": "Album",
  "your_music.stations": "Stasiun Radio",
  "your_music.local_files": "File Lokal",
  "sidebar.title_main": "Utama",
  "sidebar.title_playlists": "Playlist",
  "new_playlist.input_placeholder": "Playlist Baru",
  "new_playlist.button": "Playlist Baru",
  "accessibilitylinks.skip_to_content_label": "Lewati ke konten utama",
  "accessibilitylinks.skip_to_player_label": "Lewati ke kontrol pemutar",
  "playlist.by": "menurut {0}",
  "playlist.loading": "Memuat...",
  "playlist.newfolder": "Folder Baru",
  "playlist.delete_message": "Yakin ingin menghapus playlist ini?",
  "playlist.unfollow_message": "Yakin ingin berhenti mengikuti playlist ini?",
  "playlistfolder.delete_message": "Kamu yakin ingin menghapus folder ini dan semua playlist di dalamnya?",
  "playlist.delete_confirm": "Hapus",
  "playlist.unfollow_confirm": "Berhenti mengikuti",
  "playlist.delete_cancel": "Batalkan",
  "playlist.duplicates_dialog_title": "Duplikat lagu",
  "playlist.duplicates_dialog_title_single": "Duplikat lagu",
  "playlist.duplicates_dialog_body": "Beberapa lagu ini sudah ada dalam playlist kamu.",
  "playlist.duplicates_dialog_body_single": "Lagu ini sudah ada dalam playlist kamu.",
  "playlist.duplicates_dialog_button_add": "Muat semua",
  "playlist.duplicates_dialog_button_add_single": "Muat saja",
  "playlist.duplicates_dialog_button_skip_duplicates": "Lewati duplikat",
  "playlist.duplicates_dialog_button_skip_single": "Lewati duplikat",
  "playlist.annotate_form.new_playlist_name": "Playlist Baru",
  "playlist.annotate_form.create_title": "Buat Playlist",
  "playlist.annotate_form.create": "Buat",
  "playlist.annotate_form.cancel": "Batalkan",
  "playlist.annotate_form.edit_title": "Edit Detail Playlist",
  "playlist.annotate_form.save": "Simpan",
  "playlist.annotate_form.name_field_label": "Nama",
  "playlist.annotate_form.name_field_placeholder": "Nama playlist",
  "playlist.annotate_form.image_field_label": "Gambar",
  "playlist.annotate_form.image_pick_button_label": "Pilih gambar",
  "playlist.annotate_form.image_replace_button_label": "Ganti gambar",
  "playlist.annotate_form.image_remove_button_label": "Hapus gambar",
  "playlist.annotate_form.image_file_size_exceeded": "Ukuran gambar terlalu besar, maksimal: 4MB.",
  "playlist.annotate_form.image_file_upload_failed": "Gagal mengunggah gambar, coba lagi.",
  "playlist.annotate_form.annotate_failed": "Gagal memperbarui deskripsi dan gambar, coba lagi.",
  "playlist.annotate_form.close-error-bar": "Sembunyikan",
  "playlist.annotate_form.description_field_label": "Deskripsi",
  "playlist.annotate_form.description_field_placeholder": "Beri playlist kamu deskripsi yang menarik.",
  "playlist.annotate_form.permission_message": "Dengan melanjutkan, kamu setuju untuk memberi Spotify akses ke gambar yang dipilih untuk diupload. Harap pastikan kamu memiliki hak untuk mengupload gambar itu. Kami hanya akan menggunakan gambarmu untuk seni sampul playlist.",
  "playlist.annotate_form.insert_link_button_label": "Sisipkan tautan",
  "playlist.annotate_form.insert_link.link_field_label": "Tautan ke",
  "playlist.annotate_form.insert_link.change_button_label": "Ubah",
  "playlist.annotate_form.insert_link.remove_button_label": "Hapus",
  "playlist.annotate_form.insert_link.done_button_label": "Selesai",
  "playlist.annotate_form.drop_to_set_image_label": "Lepaskan untuk mengatur gambar",
  "playlist.annotate_form.drop_not_allowed_label": "Format tidak didukung",
  "playlist.annotate_form.error.file_not_valid_jpg": "File tersebut bukan file JPG yang valid, tidak sesuai dengan namanya.",
  "playlist.annotate_form.error.name_required": "Kamu harus memberi nama playlist.",
  "playlist.annotate_form.error.selection_required_to_insert_link": "Kamu harus memilih teks yang akan diubah menjadi tautan.",
  "playlist.annotate_form.error.html_not_allowed": "Sepertinya kamu ingin menggunakan HTML, yang tidak mungkin dilakukan.",
  "playlist.annotate_form.error.submit": "Gagal menyimpan perubahan playlist. Coba lagi.",
  "playlist.annotate_form.error.image_too_small": "Gambar tersebut terlalu kecil. Ukurannya minimal {0}x{1}.",
  "playlist.annotate_form.warning.client_offline": "Koneksi internet tidak ditemukan. Perubahan pada deskripsi dan gambar tidak akan tersimpan.",
  "playlist.annotate_form.warning.no_line_breaks_in_description": "Maaf, tetapi ganti baris tidak didukung dalam deskripsi.",
  "playlist.annotate_form.warning.unsaved_changes": "Kamu tidak ingin menyimpan perubahan?",
  "navigation.label": "Navigasi",
  "navigation.back_button_label": "Kembali",
  "navigation.forward_button_label": "Maju",
  "search.input_placeholder": "Cari",
  "player.label": "Kontrol pemutar",
  "player.shuffle_mode_label": "Acak",
  "player.repeat_mode_label": "Repeat",
  "player.queue": "Antrean",
  "player.volume_button_label": "Volume",
  "player.spotify_connect": "Spotify Connect",
  "player.connect_button_label": "Hubungkan ke perangkat",
  "player.lyrics_label": "Lirik",
  "player.play_button_label": "Play",
  "player.pause_button_label": "Jeda",
  "player.previous_button_label": "Sebelumnya",
  "player.next_button_label": "Berikutnya",
  "player.offline_label": "Offline",
  "player.thumb_up_label": "Jempol Naik",
  "player.thumb_down_label": "Jempol Turun",
  "playererror.default": "Terjadi masalah saat mencoba memainkan lagu yang dipilih",
  "playererror.track_not_available": "Lagu ini tidak tersedia",
  "nowplaying.label": "Sekarang memutar",
  "nowplaying.go_to_context": "Ke yang sedang diputar",
  "nowplaying.save_your_music": "Simpan ke Musik Kamu",
  "nowplaying.remove_your_music": "Hapus dari Musik Kamu",
  "nowplaying.playing_suggested_track": "Sedang Memutar Lagu Yang Disarankan",
  "connect.connect_text": "Hubungkan ke perangkat",
  "connect.device_connecting": "Menghubung...",
  "connect.device_incompatible": "Tidak kompatibel",
  "connect.device_premium_only": "Hanya pengguna Premium",
  "connect.device_sleeping": "Perangkat dalam mode tidur",
  "connect.device_tech_cast": "Google Cast",
  "connect.device_tech_connect": "Spotify Connect",
  "connect.device_this_computer": "Komputer Ini",
  "connect.device_unavailable_for_playback": "Tidak tersedia untuk mendengarkan di",
  "connect.device_unknown": "Perangkat tidak diketahui",
  "connect.device_unsupported_uri": "Tidak dapat memainkannya saat ini",
  "connect.devices_available": "Perangkat Tersedia",
  "connect.dismiss": "Tutup",
  "connect.help1": "Connect memungkinkan kamu memainkan dan mengontrol Spotify di perangkatmu.",
  "connect.help2": "Mulai Spotify di perangkat lain dan Spotify secara ajaib akan muncul di sini.",
  "connect.help_hint": "Apakah Connect itu?",
  "connect.offline": "Tidak tersedia",
  "connect.offline_reason_computer": "Spotify tidak aktif di perangkat ini.",
  "connect.offline_reason_generic": "Spotify tidak aktif di perangkat ini.",
  "connect.offline_reason_phone": "Ponsel terkunci atau Spotify tidak di latar depan.",
  "connect.offline_reason_gameconsole": "Gunakan pengaturan daya di Aplikasi Spotify PlayStation untuk memungkinkan kamu menghidupkan PlayStation dari mode siaga.",
  "connect.offline_text1": "Kamu harus online untuk menggunakan fitur ini.",
  "connect.offline_title": "Kamu sedang offline!",
  "connect.playingon": "Mendengarkan Di",
  "connect.popup_title": "Perangkat",
  "connect.remoteplayback": "Kamu mendengarkan di {0}",
  "connect.show_more": "Tampilkan Lainnya",
  "connect.upgrade": "Upgrade",
  "connect.upsell": "Connect merupakan fitur Premium yang memungkinkan kamu memainkan dan mengontrol Spotify di perangkatmu.",
  "contextmenu.new-playlist": "Playlist Baru",
  "contextmenu.add-to-playlist": "Tambah ke Playlist",
  "contextmenu.owner-playlist": "menurut {0}",
  "contextmenu.copy-uri": "Copy URI Spotify",
  "contextmenu.copy-artist-url": "Salin Tautan Artis",
  "contextmenu.copy-album-url": "Salin Tautan Album",
  "contextmenu.copy-track-url": "Salin Tautan Lagu",
  "contextmenu.copy-playlist-url": "Salin Tautan Playlist",
  "contextmenu.copy-profile-url": "Salin Tautan Profil",
  "contextmenu.copy-station-url": "Copy Tautan Stasiun Radio",
  "contextmenu.copy-chart-url": "Salin Tautan Tangga Lagu",
  "contextmenu.copy-url": "Salin Tautan",
  "contextmenu.copy-embed": "Copy Kode Tertanam",
  "contextmenu.collaborative": "Playlist Kolaboratif",
  "contextmenu.save": "Simpan ke Musik Kamu",
  "contextmenu.remove": "Hapus dari Musik Kamu",
  "contextmenu.delete-playlist": "Hapus",
  "contextmenu.follow": "Ikuti",
  "contextmenu.unfollow": "Berhenti mengikuti",
  "contextmenu.publish": "Jadikan Publik",
  "contextmenu.unpublish": "Jadikan Rahasia",
  "contextmenu.playlist.loading": "Memuat...",
  "contextmenu.play": "Play",
  "contextmenu.add-to-queue": "Tambahkan ke Antrean",
  "contextmenu.station": "Ke Radio",
  "contextmenu.station-album": "Ke Album Radio",
  "contextmenu.station-artist": "Ke Radio Artis",
  "contextmenu.station-playlist": "Ke Playlist Radio",
  "contextmenu.station-track": "Ke Radio Lagu",
  "contextmenu.station-chart": "Ke Radio Tangga Lagu",
  "contextmenu.remove-from-playlist": "Hapus dari Playlist ini",
  "contextmenu.remove-from-queue": "Hapus dari Antrean",
  "contextmenu.rename-folder": "Ganti nama",
  "contextmenu.rename-playlist": "Ganti nama",
  "contextmenu.edit-playlist": "Edit detail",
  "contextmenu.report-playlist": "Laporkan",
  "contextmenu.report-asset": "Laporkan",
  "contextmenu.share": "Bagikan...",
  "contextmenu.share-lyrics": "Bagikan Lirik",
  "contextmenu.create-folder": "Buat Folder",
  "contextmenu.create-playlist": "Buat Playlist",
  "contextmenu.open-localfile-folder": "Buka Folder yang Memuat",
  "contextmenu.open-localfile-folder-mac": "Buka di Pencari",
  "contextmenu.offline": "Tersedia Offline",
  "contextmenu.goto-artist": "Ke Artis",
  "contextmenu.goto-album": "Ke Album",
  "usermessage.default-message": "Terjadi kesalahan",
  "usermessage.update-ready": "Halo. Kami telah menyiapkan versi baru Spotify untukmu. <a href=\"#\" data-action=\"{0}\">Mulai ulang sekarang</a> untuk memilikinya.",
  "usermessage.update-ready-simple": "Halo. Kami telah menyiapkan versi baru Spotify untukmu. Mulai ulang sekarang untuk memilikinya.",
  "usermessage.play-token-lost": "Spotify telah dijeda karena akun kamu sedang digunakan di tempat lain.",
  "usermessage.playback-paused-inactive": "Komputer tidak aktif dalam waktu lama, tekan play untuk terus mendengarkan! Untuk musik tanpa henti, kamu harus berlangganan <a href=\"#\" data-action=\"{0}\">Spotify Premium</a>.",
  "usermessage.not-available-offline": "Tidak ada koneksi internet yang terdeteksi. Spotify akan mencoba menghubungkan kembali secara otomatis bila mendeteksi koneksi internet (kode kesalahan:4)",
  "usermessage.track-not-available-in-region": "Saat ini lagu ini tidak tersedia di {0}. Jika file ada di komputer, kamu dapat mengimpornya.",
  "usermessage.track-not-available-in-region-generic": "Saat ini lagu ini tidak tersedia di negaramu. Jika file ada di komputer, kamu dapat mengimpornya.",
  "usermessage.track-not-available": "Lagu ini tidak tersedia. Jika file ada di komputer, kamu dapat mengimpornya.",
  "usermessage.track-not-available-forced-offline": "Harap <a href=\"#\" data-action=\"goOnline\">nonaktifkan mode offline</a> dan coba lagi.",
  "usermessage.track-exclusive-premium": "Lagu ini eksklusif untuk pengguna <a href=\"#\" data-action=\"{0}\">Spotify Premium</a> .",
  "usermessage.track-banned-by-artist": "Artis/label telah memilih untuk membuat lagu ini tidak tersedia. Jika file ada di komputer, kamu dapat mengimpornya.",
  "usermessage.local-track-no-file": "Lagu ini ditambahkan sebagai file lokal. Jika file ada di komputer, kamu dapat mengimpornya.",
  "usermessage.local-track-file-not-found": "Lagu ini tidak dapat dimainkan karena file tidak dapat ditemukan. Coba impor lagi.",
  "usermessage.local-track-bad-format": "Format file tidak diketahui. Klik <a href=\"#\" data-action=\"{0}\">di sini</a> untuk informasi.",
  "usermessage.capping-reached": "Kamu telah melebihi batas waktu {0} jam. <a href=\"#\" data-action=\"{1}\">Upgrade ke Spotify Premium</a> untuk mendengarkan tanpa batasan.",
  "usermessage.local-track-drm-protected": "Lagu ini tidak dapat dimainkan karena file diproteksi dengan manajemen hak digital (DRM).",
  "usermessage.offline-disk-cache": "Gagal men-download lagu offline. Mungkin disk penuh?",
  "usermessage.offline-sync-expired": "Lagu offline telah kedaluwarsa. Kamu harus masuk ke Spotify untuk mengaktifkan ulang.",
  "usermessage.offline-sync-failed": "Gagal men-download beberapa lagu offline.",
  "usermessage.offline-too-many-tracks": "Terlalu banyak lagu yang dipilih untuk mode offline.",
  "usermessage.offline-license-server-error": "Terjadi masalah dengan server Spotify.",
  "usermessage.offline-license-lost": "Akses offline untuk komputer/perangkat ini telah dibatalkan.",
  "usermessage.offline-not-allowed": "Mode offline adalah <a href=\"#\" data-action=\"{0}\">fitur eksklusif</a> Spotify Premium.",
  "usermessage.language-changed": "Kamu harus <a href=\"#\" data-action=\"{0}\">memulai ulang Spotify</a> untuk memberlakukan perubahan",
  "usermessage.proxysettings-changed": "Kamu harus <a href=\"#\" data-action=\"{0}\">memulai ulang Spotify</a> untuk memberlakukan perubahan",
  "usermessage.language-changed-simple": "Untuk melihat perubahan, kamu harus memulai ulang Spotify",
  "usermessage.proxysettings-changed-simple": "Untuk melihat perubahan, kamu harus memulai ulang Spotify",
  "usermessage.cache-changed": "Kamu harus <a href=\"#\" data-action=\"{0}\">memulai ulang Spotify</a> untuk memberlakukan perubahan",
  "usermessage.cache-changed-simple": "Untuk melihat perubahan, kamu harus memulai ulang Spotify",
  "usermessage.feature-changed": "Kamu harus <a href=\"#\" data-action=\"{0}\">memulai ulang Spotify</a> untuk memberlakukan perubahan",
  "usermessage.first-autostart": "Spotify telah dibuka secara otomatis, tetapi diminimalkan. Jika diinginkan kamu dapat <a href=\"#\" data-action=\"{0}\">membuka Spotify secara otomatis tanpa diminimalkan</a> atau <a href=\"#\" data-action=\"{1}\">tidak membuka Spotify sama sekali</a> saat dihidupkan.",
  "usermessage.cant-play-track": "Tidak dapat memainkan lagu saat ini.",
  "usermessage.cant-skip-ads": "Lagu yang dipilih akan dimainkan setelah iklan.",
  "usermessage.cant-offline-playlists": "Mode offline adalah fitur eksklusif Premium. <a href=\"#\" data-action=\"{0}\">Dapatkan Premium</a>.",
  "usermessage.cant-set-high-quality-streaming": "Ini adalah fitur eksklusif Premium. <a href=\"#\" data-action=\"{0}\">Dapatkan Premium</a>.",
  "usermessage.payment-state-creditcard-funds": "Kami tidak dapat memperpanjang langgananmu karena masalah pembayaran. Pastikan ada dana di rekeningmu atau <a href=\"#\" data-action=\"{0}\">perbarui detail pembayaran</a>.",
  "usermessage.payment-state-creditcard-refused": "Kami tidak dapat memperpanjang langgananmu karena masalah pembayaran. Untuk terus berlangganan, <a href=\"#\" data-action=\"{0}\">perbarui detail pembayaranmu</a>.",
  "usermessage.payment-state-paypal-refused": "Kami tidak dapat memperpanjang langgananmu karena masalah pembayaran. Untuk terus berlangganan, <a href=\"#\" data-action=\"{0}\">perbarui detail pembayaranmu</a>.",
  "usermessage.payment-state-creditcard-expiry": "Kartu pembayaran yang kamu gunakan akan kedaluwarsa dalam beberapa hari. Untuk terus berlangganan, <a href=\"#\" data-action=\"{0}\">perbarui detail pembayaranmu</a>.",
  "usermessage.payment-state-prepaid-expiry": "Langganan prabayarmu akan segera berakhir. Jangan khawatir, kamu dapat <a href=\"#\" data-action=\"{0}\">berlangganan Premium di sini</a>.",
  "usermessage.payment-state-churn-payment": "Sayangnya kami tidak dapat menerima pembayaranmu, sehingga langgananmu harus dibatalkan. Jangan khawatir, kamu dapat <a href=\"#\" data-action=\"{0}\">memperpanjang langgananmu di sini</a>.",
  "usermessage.payment-state-churn-partner": "Langgananmu dengan salah satu mitra kami telah berakhir, sekarang kamu menggunakan Spotify Free. Jangan khawatir, kamu dapat <a href=\"#\" data-action=\"{0}\">kembali ke Premium di sini</a>.",
  "usermessage.opt-in-trial": "Kami harap kamu menikmati uji coba gratis! Agar tidak kehilangan Premium saat uji coba berakhir, <a href=\"#\" data-action=\"{0}\">berlangganan hari ini</a>.",
  "usermessage.opt-in-trial-expired": "Uji coba gratismu telah berakhir, kamu sekarang menggunakan Spotify Free. Jangan khawatir, kamu dapat <a href=\"#\" data-action=\"{0}\">kembali ke Premium di sini</a>.",
  "usermessage.hardware-acceleration-changed": "Kamu harus <a href=\"#\" data-action=\"{0}\">memulai ulang Spotify</a> untuk memberlakukan perubahan",
  "usermessage.hardware-acceleration-changed-simple": "Untuk melihat perubahan, kamu harus memulai ulang Spotify",
  "usermessage.some-local-tracks-not-saved": "Beberapa lagu yang dipilih tidak disimpan ke Musik Kamu. File lokal tidak didukung oleh Musik Kamu.",
  "usermessage.illegal-playlist-name-entered": "Nama playlist yang dimasukkan tidak valid.",
  "usermessage.playlist-save-failed-unknown": "Nama playlist tidak dapat disimpan karena kesalahan yang tidak diketahui.",
  "usermessage.social-error-permissions": "Klik <a href=\"#\" data-action=\"{0}\">di sini</a> agar dapat membagikan aktivitas musik kamu di Facebook.",
  "usermessage.shuffle-unplayable-track": "Upgrade ke<a href=\"#\" data-action=\"{0}\">Premium</a>untuk memutar lagu apa saja, kapan saja.",
  "usermessage.shuffle-ran-out-of-skips": "Kamu tidak lagi dapat melewati (dalam satu jam). Upgrade<a href=\"#\" data-action=\"{0}\">ke Premium</a> untuk melewati sesering yang diinginkan.",
  "usermessage.playlist-limit-exceeded": "Kamu telah mengisi penuh playlist ini. Bagus. Mulai yang baru untuk terus mengoleksi.",
  "usermessage.collection-limit-exceeded": "Koleksi keren, teman. Musik Kamu telah terisi penuh. Untuk menyimpan lebih banyak, kamu harus menghapus beberapa lagu.",
  "usermessage.deprecating-os-version": "Perhatian! Kami akan mengakhiri dukungan untuk sistem operasimu dalam rilis mendatang. Klik <a href=\"#\" data-action=\"{0}\">di sini</a> untuk informasi lebih lanjut.",
  "usermessage.image-upload-propagation": "Berhasil! (Gambar membutuhkan hingga 24 jam untuk tersebar)",
  "usermessage.approaching-capping-limit": "Waktumu tersisa kurang dari 1 jam untuk mendengarkan gratis. Nikmati 15 jam mendengarkan gratis setiap bulannya atau <a href=\"#\" data-action=\"{0}\">upgrade ke Premium</a> untuk mendengarkan tanpa batas. <a href=\"#\" data-action=\"{1}\">Pelajari lebih lanjut</a>.",
  "usermessage.half-capping-limit-passed": "Kamu telah menghabiskan separuh batas bulananmu. Nikmati 15 jam mendengarkan gratis setiap bulannya atau <a href=\"#\" data-action=\"{0}\">upgrade ke Premium</a> untuk mendengarkan tanpa batas. <a href=\"#\" data-action=\"{1}\">Pelajari lebih lanjut</a>.",
  "usermessage.video-georestricted": "Kami tidak dapat memutar video ini di lokasimu saat ini.",
  "usermessage.video-unsupported-client-version": "Upgrade Spotify untuk memutar video ini.",
  "usermessage.video-unsupported-platform-version": "Video ini tidak dapat diputar di versi sistem operasi kamu.",
  "usermessage.video-country-restricted": "Kami tidak dapat memutar video ini di lokasimu saat ini.",
  "usermessage.video-unavailable": "Video ini tidak tersedia. Coba yang lain?",
  "usermessage.video-catalogue-restricted": "Maaf, kami tidak dapat memutar video ini.",
  "usermessage.video-playback-error": "Maaf, kami tidak dapat memutar video ini.",
  "about.title_label": "Tentang Spotify",
  "about.close_button_label": "Tutup",
  "offline-progress-msg": "Menyinkronkan offline {0} dari {1} lagu",
  "tos.updated_terms": "Persyaratan yang diperbarui",
  "tos.modal_title": "Syarat dan Ketentuan Penggunaan Spotify",
  "tos.tos_text": "<p>Kami telah merevisi <a href=\"{0}\">Syarat dan Ketentuan</a> dan <a href=\"{1}\">Kebijakan Privasi</a> kami.</p><p>Dengan terus menggunakan Spotify, berarti Anda menyetujui syarat yang diperbarui ini, luangkan waktu sejenak untuk membaca dan memahaminya.</p>",
  "tos.not_now_tos_text": "<p>Kami telah merevisi <a href=\"{0}\">Syarat dan Ketentuan Penggunaan</a> dan <a href=\"{1}\">Kebijakan Privasi</a> kami.</p><p>Dengan mengeklik &quot;Setuju&quot;, berarti Anda menyetujui pembaruan ini (dan pemrosesan data Anda seperti diuraikan), luangkan waktu sejenak untuk membaca dan memahaminya.</p>",
  "tos.tos_text2": "<p>Jika kamu tidak lagi ingin menggunakan Spotify, batalkan langgananmu dengan mengunjungi halaman langganan Spotify.</p>",
  "tos.not_now_text": "<p>Anda dapat terus menggunakan Spotify selama {0} hari tanpa menyetujui Persyaratan dan Ketentuan dan Kebijakan Privasi yang diperbarui. Pada saat itu, Anda harus menyetujui persyaratan baru untuk tetap menggunakan Spotify. Kecuali Anda membatalkan langganan, Anda akan tetap ditagih setiap bulan pada siklus penagihan biasa. Jika Anda tidak ingin lagi ditagih oleh Spotify, batalkan langganan Anda dengan mengunjungi halaman langganan Spotify.</p>",
  "tos.not_now_last_day_text": "<p>Anda dapat terus menggunakan Spotify selama 1{0}hari tanpa menyetujui Persyaratan dan Ketentuan dan Kebijakan Privasi yang diperbarui. Jika pada saat itu Anda tidak menyetujui persyaratan baru, Anda tidak lagi dapat menggunakan Spotify. Kecuali Anda membatalkan langganan, Anda akan tetap ditagih setiap bulan pada siklus pembayaran berkala. Jika Anda tidak ingin lagi ditagih oleh Spotify, batalkan langganan Anda kapan saja dengan mengunjungi halaman langganan Spotify.</p>",
  "tos.not_now_text_germany": "<p>Kami telah merevisi <a href=\"{0}\">Syarat dan Ketentuan</a> dan <a href=\"{1}\">Kebijakan Privasi</a> kami. Perhatikan bahwa, atas persetujuan Anda, Spotify GmbH ingin mentransfer kontrak Anda ke Spotify AB, Birger Jarlsgatan 61, 113 56 Stockholm, Swedia.</p><p>Anda dapat terus menggunakan layanan Spotify berdasarkan kontrak yang ada sampai {2}. Setelah tanggal tersebut, untuk terus menggunakan layanan Spotify, Anda harus menyetujui Syarat dan Ketentuan dan Kebijakan Privasi baru. Dengan mengeklik &quot;Setuju&quot;, berarti Anda menyetujui</p><p>a) transfer kontrak Anda dari Spotify GmbH ke Spotify AB,<br />b) pembaruan Syarat dan Ketentuan, dan<br />c) pengumpulan, pemrosesan, dan penggunaan data pribadi Anda seperti diuraikan di Bagian 4, 5, dan 7 dalam Kebijakan Privasi.</p>",
  "tos.not_now_text2_germany": "<p>Anda dapat terus menggunakan Spotify sampai {0} tanpa menyetujui Persyaratan dan Ketentuan dan Kebijakan Privasi yang diperbarui. Pada saat itu, Anda harus menerima persyaratan baru untuk terus menggunakan Spotify. Jika Anda pengguna Premium, Anda akan tetap ditagih setiap bulan pada siklus penagihan biasa kecuali Anda membatalkan langganan. Jika Anda tidak ingin lagi ditagih oleh Spotify, batalkan langganan Anda kapan saja dengan mengunjungi halaman langganan Spotify.</p>",
  "tos.not_now_expired_text_germany": "<p>Kami telah merevisi <a href=\"{0}\">Syarat dan Ketentuan</a> dan <a href=\"{1}\">Kebijakan Privasi</a> kami.</p><p>Perhatikan bahwa, atas persetujuan Anda, Spotify GmbH ingin mentransfer kontrak Anda ke Spotify AB, Birger Jarlsgatan 61, 113 56 Stockholm, Swedia.</p><p>Untuk terus menggunakan layanan Spotify, Anda harus menyetujui Syarat dan Ketentuan dan Kebijakan Privasi baru. Dengan mengeklik &quot;Setuju&quot;, berarti Anda menyetujui</p><p>a) transfer kontrak Anda dari Spotify GmbH ke Spotify AB,<br />b) pembaruan Syarat dan Ketentuan, dan<br/>c) pengumpulan, pemrosesan, dan penggunaan data pribadi Anda seperti diuraikan di Bagian 4, 5, dan 7 dalam Kebijakan Privasi.</p>",
  "tos.back_button_label": "Kembali",
  "tos.ok_button_label": "OKE",
  "tos.agree_button_label": "Setuju",
  "tos.cancel_button_label": "Tolak",
  "tos.not_now_button_label": "Nanti",
  "licenses.modal_title": "Lisensi pihak ketiga",
  "licenses.close_button_label": "Tutup",
  "feedback.beta_title": "Versi Beta",
  "feedback.beta_text": "Ada yang kamu benci atau sukai? Beri tahu kami.",
  "market.ad": "Andorra",
  "market.ar": "Argentina",
  "market.at": "Austria",
  "market.au": "Australia",
  "market.be": "Belgia",
  "market.bg": "Bulgaria",
  "market.bo": "Bolivia",
  "market.br": "Brasil",
  "market.ca": "Kanada",
  "market.ch": "Swiss",
  "market.cl": "Chile",
  "market.co": "Kolombia",
  "market.cr": "Kosta Rika",
  "market.cy": "Siprus",
  "market.cz": "Republik Ceko",
  "market.de": "Jerman",
  "market.dk": "Denmark",
  "market.do": "Republik Dominika",
  "market.ec": "Ekuador",
  "market.ee": "Estonia",
  "market.es": "Spanyol",
  "market.fi": "Finlandia",
  "market.fr": "Prancis",
  "market.gr": "Yunani",
  "market.gt": "Guatemala",
  "market.hk": "Hong Kong",
  "market.hn": "Honduras",
  "market.hu": "Hongaria",
  "market.ie": "Irlandia",
  "market.is": "Islandia",
  "market.it": "Italia",
  "market.jp": "Jepang",
  "market.li": "Liechtenstein",
  "market.lt": "Lithuania",
  "market.lu": "Luksemburg",
  "market.lv": "Latvia",
  "market.mc": "Monako",
  "market.mt": "Malta",
  "market.mx": "Meksiko",
  "market.my": "Malaysia",
  "market.ni": "Nikaragua",
  "market.nl": "Belanda",
  "market.no": "Norwegia",
  "market.nz": "Selandia Baru",
  "market.pa": "Panama",
  "market.pe": "Peru",
  "market.ph": "Filipina",
  "market.pl": "Polandia",
  "market.pt": "Portugal",
  "market.py": "Paraguay",
  "market.se": "Swedia",
  "market.sg": "Singapura",
  "market.sk": "Slovakia",
  "market.sv": "El Salvador",
  "market.tr": "Turki",
  "market.tw": "Taiwan",
  "market.uk": "Inggris",
  "market.us": "Amerika Serikat",
  "market.uy": "Uruguay",
  "market.za": "Afrika Selatan",
  "sTitle": "Sampaikan pendapatmu dan bantu kami menyediakan layanan musik terbaik di dunia!",
  "sQ1Question": "Seberapa mungkin kamu akan menyarankan Spotify kepada teman atau kolega?",
  "sQ1Negative": "Sama sekali tidak mungkin",
  "sQ1Positive": "Sangat mungkin",
  "sQ2Question": "Mengapa kamu merasa begitu?",
  "sQ3Question": "Secara keseluruhan, seberapa puaskah kamu dengan layanan Spotify?",
  "sQ3Negative": "Sangat tidak puas",
  "sQ3Positive": "Sangat puas",
  "sSubmit": "Serahkan survei",
  "sThanks": "Terima kasih banyak atas bantuanmu. Kami menghargai waktu yang telah kamu luangkan.",
  "sTeam": "Tim Spotify",
  "sClose": "Tutup",
  "cls.highlight": "Premium dihentikan sementara",
  "cls.title": "Pembayaran terakhirmu tidak berhasil.",
  "cls.desc": "Terus mendengarkan Premium dengan menambahkan metode pembayaran baru. Hanya membutuhkan waktu sejenak.",
  "cls.updatePayment": "Perbarui pembayaran",
  "cls.cancelSubscription": "Kamu juga dapat menurunkan ke Spotify Free,<br>dengan <a class=\"cancel-sub\" href=\"#cancel\">membatalkan langganan Premium</a>.",
  "capping.upsell-title": "Kamu telah mencapai batas mendengarkan musik gratis.",
  "capping.upsell-message": "Kamu mendapatkan 15 jam mendengarkan musik gratis setiap bulan.<br>Upgrade ke Premium untuk mendengarkan tanpa batas dan bebas iklan.",
  "capping.upsell-button-label": "Upgrade ke Premium",
  "capping.defaultRefillMessage": "Periode akun gratismu untuk mendengarkan musik akan segera dimulai kembali.",
  "capping.refillMessage": "Akun gratismu untuk mendengarkan musik akan dimulai kmbali dalam {0} hari mendatang.",
  "capping.welcome-title": "Selamat Datang di Spotify.",
  "capping.welcome-message": "Nikmati mendengarkan musik gratis 15 jam setiap bulan.<br> <a data-action={0}>Upgrade ke Premium untuk mendengarkan tanpa batas dan bebas iklan.</a>",
  "capping.welcome-message-button-label": "Memulai",
  "yourArtistsTooltipTitle": "Kelola artis kamu",
  "yourArtistsTooltipText": "Sekarang kamu bisa dengan mudah mengedit gambar profil artis kamu di Spotify.",
  "yourArtists": "Artis Kamu"
};
},{}],11:[function(require,module,exports){
'use strict';

// This file will likely become a generated file in the future. Please
// avoid adding extra APIs or exports here.

var i18n = require('../../../libs/spotify-i18n')({
  'de': require('./de.lang'),
  'el': require('./el.lang'),
  'en': require('./en.lang'),
  'es': require('./es.lang'),
  'es-419': require('./es-419.lang'),
  'fi': require('./fi.lang'),
  'fr': require('./fr.lang'),
  'fr-CA': require('./fr-CA.lang'),
  'hu': require('./hu.lang'),
  'id': require('./id.lang'),
  'it': require('./it.lang'),
  'ja': require('./ja.lang'),
  'nl': require('./nl.lang'),
  'pl': require('./pl.lang'),
  'pt-BR': require('./pt-BR.lang'),
  'sv': require('./sv.lang'),
  'tr': require('./tr.lang'),
  'zh-Hant': require('./zh-Hant.lang'),
  'zsm': require('./zsm.lang')
});

module.exports = i18n;

},{"../../../libs/spotify-i18n":370,"./de.lang":1,"./el.lang":2,"./en.lang":3,"./es-419.lang":4,"./es.lang":5,"./fi.lang":6,"./fr-CA.lang":7,"./fr.lang":8,"./hu.lang":9,"./id.lang":10,"./it.lang":12,"./ja.lang":13,"./nl.lang":14,"./pl.lang":15,"./pt-BR.lang":16,"./sv.lang":17,"./tr.lang":18,"./zh-Hant.lang":19,"./zsm.lang":20}],12:[function(require,module,exports){
module.exports = {
  "browse.app_name": "Naviga",
  "latest-releases.app_name": "Nuove uscite",
  "discover.app_name": "Scopri",
  "activity.app_name": "Attività",
  "radio.app_name": "Radio",
  "settings.app_name": "Impostazioni",
  "messages.app_name": "Messaggi",
  "profile.app_name": "Profilo",
  "notifications_center.app_name": "Notifiche",
  "concerts.app_name": "Concerti",
  "profile.private_session": "Sessione privata",
  "profile.upgrade": "Upgrade",
  "profile.upgrade_account": "Effettua l'upgrade del tuo account",
  "profile.upgrade_tooltip": "Passa a Premium",
  "profile.account": "Account",
  "profile.logout": "Esegui il log out",
  "profile.enabled": "Abilitato",
  "profile.menu_label": "Menu",
  "profile.switch": "Cambia utente",
  "profile.new_user": "Passa al nuovo utente",
  "your_music.app_name": "La tua musica",
  "your_music.songs": "Brani",
  "your_music.artists": "Artisti",
  "your_music.albums": "Album",
  "your_music.stations": "Stazioni",
  "your_music.local_files": "File locali",
  "sidebar.title_main": "Principale",
  "sidebar.title_playlists": "Playlist",
  "new_playlist.input_placeholder": "Nuova playlist",
  "new_playlist.button": "Nuova playlist",
  "accessibilitylinks.skip_to_content_label": "Passa al contenuto principale",
  "accessibilitylinks.skip_to_player_label": "Passa ai controlli player",
  "playlist.by": "di {0}",
  "playlist.loading": "Caricamento in corso...",
  "playlist.newfolder": "Nuova cartella",
  "playlist.delete_message": "Vuoi veramente eliminare questa playlist?",
  "playlist.unfollow_message": "Vuoi veramente smettere di seguire questa playlist?",
  "playlistfolder.delete_message": "Vuoi veramente eliminare questa cartella e tutte le playlist al suo interno?",
  "playlist.delete_confirm": "Elimina",
  "playlist.unfollow_confirm": "Non seguire più",
  "playlist.delete_cancel": "Annulla",
  "playlist.duplicates_dialog_title": "Brani duplicati",
  "playlist.duplicates_dialog_title_single": "Brano duplicato",
  "playlist.duplicates_dialog_body": "Alcuni di questi brani sono già presenti nella playlist.",
  "playlist.duplicates_dialog_body_single": "Questo brano è già presente nella playlist.",
  "playlist.duplicates_dialog_button_add": "Aggiungi tutti",
  "playlist.duplicates_dialog_button_add_single": "Aggiungi comunque",
  "playlist.duplicates_dialog_button_skip_duplicates": "Salta i duplicati",
  "playlist.duplicates_dialog_button_skip_single": "Salta il duplicato",
  "playlist.annotate_form.new_playlist_name": "Nuova playlist",
  "playlist.annotate_form.create_title": "Crea playlist",
  "playlist.annotate_form.create": "Crea",
  "playlist.annotate_form.cancel": "Annulla",
  "playlist.annotate_form.edit_title": "Modifica dettagli playlist",
  "playlist.annotate_form.save": "Salva",
  "playlist.annotate_form.name_field_label": "Nome",
  "playlist.annotate_form.name_field_placeholder": "Nome playlist",
  "playlist.annotate_form.image_field_label": "Immagine",
  "playlist.annotate_form.image_pick_button_label": "Scegli immagine",
  "playlist.annotate_form.image_replace_button_label": "Sostituisci immagine",
  "playlist.annotate_form.image_remove_button_label": "Rimuovi immagine",
  "playlist.annotate_form.image_file_size_exceeded": "Immagine troppo grande, dimensioni massime: 4 MB",
  "playlist.annotate_form.image_file_upload_failed": "Impossibile caricare l'immagine, riprova.",
  "playlist.annotate_form.annotate_failed": "Impossibile aggiornare la descrizione e l'immagine, riprova.",
  "playlist.annotate_form.close-error-bar": "Nascondi",
  "playlist.annotate_form.description_field_label": "Descrizione",
  "playlist.annotate_form.description_field_placeholder": "Dai alla tua playlist una descrizione che attiri l'attenzione.",
  "playlist.annotate_form.permission_message": "Continuando, accetti di fornire a Spotify l'accesso all'immagine che scegli di caricare. Verifica di disporre dei diritti per caricarla. L'immagine verrà utilizzata solo come copertina della playlist.",
  "playlist.annotate_form.insert_link_button_label": "Inserisci collegamento",
  "playlist.annotate_form.insert_link.link_field_label": "Collega a",
  "playlist.annotate_form.insert_link.change_button_label": "Modifica",
  "playlist.annotate_form.insert_link.remove_button_label": "Rimuovi",
  "playlist.annotate_form.insert_link.done_button_label": "Fatto",
  "playlist.annotate_form.drop_to_set_image_label": "Trascina per impostare l'immagine",
  "playlist.annotate_form.drop_not_allowed_label": "Formato non supportato",
  "playlist.annotate_form.error.file_not_valid_jpg": "Il file non è un file JPG valido, nonostante il nome.",
  "playlist.annotate_form.error.name_required": "Devi assegnare un nome alla playlist.",
  "playlist.annotate_form.error.selection_required_to_insert_link": "Devi selezionare un testo da trasformare in collegamento.",
  "playlist.annotate_form.error.html_not_allowed": "Stai provando a usare il codice HTML ma non è possibile.",
  "playlist.annotate_form.error.submit": "Impossibile salvare le modifiche alla playlist. Riprova.",
  "playlist.annotate_form.error.image_too_small": "Questa immagine è troppo piccola. Deve essere almeno {0}x{1}.",
  "playlist.annotate_form.warning.client_offline": "Nessuna connessione a Internet rilevata. Le modifiche alla descrizione e all'immagine non saranno salvate.",
  "playlist.annotate_form.warning.no_line_breaks_in_description": "Le interruzioni di riga non sono supportate nelle descrizione.",
  "playlist.annotate_form.warning.unsaved_changes": "Vuoi salvare le modifiche?",
  "navigation.label": "Navigazione",
  "navigation.back_button_label": "Torna indietro",
  "navigation.forward_button_label": "Vai avanti",
  "search.input_placeholder": "Cerca",
  "player.label": "Controlli Player",
  "player.shuffle_mode_label": "Shuffle",
  "player.repeat_mode_label": "Ripeti",
  "player.queue": "Coda",
  "player.volume_button_label": "Volume",
  "player.spotify_connect": "Spotify Connect",
  "player.connect_button_label": "Connetti a un dispositivo",
  "player.lyrics_label": "Testo",
  "player.play_button_label": "Play",
  "player.pause_button_label": "Pausa",
  "player.previous_button_label": "Precedente",
  "player.next_button_label": "Avanti",
  "player.offline_label": "Offline",
  "player.thumb_up_label": "Thumb Up",
  "player.thumb_down_label": "Thumb Down",
  "playererror.default": "Si è verificato un errore durante la riproduzione del brano selezionato",
  "playererror.track_not_available": "Questo brano non è disponibile",
  "nowplaying.label": "Ora in riproduzione",
  "nowplaying.go_to_context": "Vai al brano in riproduzione",
  "nowplaying.save_your_music": "Salva in La tua musica",
  "nowplaying.remove_your_music": "Elimina da La tua musica",
  "nowplaying.playing_suggested_track": "Riproduzione in corso del brano suggerito",
  "connect.connect_text": "Connetti a un dispositivo",
  "connect.device_connecting": "Connessione in corso…",
  "connect.device_incompatible": "Incompatibile",
  "connect.device_premium_only": "Solo utenti Premium",
  "connect.device_sleeping": "Il dispositivo è inattivo",
  "connect.device_tech_cast": "Google Cast",
  "connect.device_tech_connect": "Spotify Connect",
  "connect.device_this_computer": "Questo computer",
  "connect.device_unavailable_for_playback": "Non disponibile per l'ascolto",
  "connect.device_unknown": "Dispositivo sconosciuto",
  "connect.device_unsupported_uri": "Non è possibile riprodurre questo contenuto",
  "connect.devices_available": "Dispositivi disponibili",
  "connect.dismiss": "Ignora",
  "connect.help1": "Connect ti permette di riprodurre brani e controllare Spotify sui tuoi dispositivi. ",
  "connect.help2": "Avvia Spotify su un altro dispositivo e apparirà magicamente qui.",
  "connect.help_hint": "Che cos'è Connect?",
  "connect.offline": "Non disponibile",
  "connect.offline_reason_computer": "Spotify non è attivo su questo dispositivo.",
  "connect.offline_reason_generic": "Spotify non è attivo su questo dispositivo.",
  "connect.offline_reason_phone": "Lo smartphone è bloccato o Spotify non è in primo piano.",
  "connect.offline_reason_gameconsole": "Puoi abilitare la riattivazione della console dalla modalità di sospensione nelle impostazioni di Spotify per Playstation.",
  "connect.offline_text1": "Devi essere online per usare questa funzionalità.",
  "connect.offline_title": "Sei offline",
  "connect.playingon": "In ascolto su",
  "connect.popup_title": "Dispositivi",
  "connect.remoteplayback": "State ascoltando su {0}",
  "connect.show_more": "Mostra altri",
  "connect.upgrade": "Upgrade",
  "connect.upsell": "Connect è una funzione Premium che ti permette di riprodurre brani e controllare Spotify su tutti i tuoi dispositivi. ",
  "contextmenu.new-playlist": "Nuova playlist",
  "contextmenu.add-to-playlist": "Aggiungi alla playlist",
  "contextmenu.owner-playlist": "di {0}",
  "contextmenu.copy-uri": "Copia URI Spotify",
  "contextmenu.copy-artist-url": "Copia link Artista",
  "contextmenu.copy-album-url": "Copia link Album",
  "contextmenu.copy-track-url": "Copia link brano",
  "contextmenu.copy-playlist-url": "Copia link Playlist",
  "contextmenu.copy-profile-url": "Copia link Profilo",
  "contextmenu.copy-station-url": "Copia link Stazione",
  "contextmenu.copy-chart-url": "Copia link classifica",
  "contextmenu.copy-url": "Copia link",
  "contextmenu.copy-embed": "Copia codice di incorporamento ",
  "contextmenu.collaborative": "Playlist collaborativa",
  "contextmenu.save": "Salva in La tua musica",
  "contextmenu.remove": "Elimina da La tua musica",
  "contextmenu.delete-playlist": "Elimina",
  "contextmenu.follow": "Segui",
  "contextmenu.unfollow": "Non seguire più",
  "contextmenu.publish": "Rendi pubblica",
  "contextmenu.unpublish": "Rendi segreta",
  "contextmenu.playlist.loading": "Caricamento in corso...",
  "contextmenu.play": "Play",
  "contextmenu.add-to-queue": "Aggiungi alla coda",
  "contextmenu.station": "Vai a Radio",
  "contextmenu.station-album": "Vai a Radio dall'album",
  "contextmenu.station-artist": "Vai a Radio dall'artista",
  "contextmenu.station-playlist": "Vai a Radio dalla playlist",
  "contextmenu.station-track": "Vai a Radio dal brano",
  "contextmenu.station-chart": "Vai a radio delle classifica",
  "contextmenu.remove-from-playlist": "Rimuovi da questa playlist",
  "contextmenu.remove-from-queue": "Rimuovi dalla coda",
  "contextmenu.rename-folder": "Rinomina",
  "contextmenu.rename-playlist": "Rinomina",
  "contextmenu.edit-playlist": "Modifica dettagli",
  "contextmenu.report-playlist": "Segnala",
  "contextmenu.report-asset": "Segnala",
  "contextmenu.share": "Condividi...",
  "contextmenu.share-lyrics": "Condividi testo",
  "contextmenu.create-folder": "Crea cartella",
  "contextmenu.create-playlist": "Crea playlist",
  "contextmenu.open-localfile-folder": "Apri cartella contenente",
  "contextmenu.open-localfile-folder-mac": "Rivela nello strumento di ricerca",
  "contextmenu.offline": "Disponibile offline",
  "contextmenu.goto-artist": "Passa ad Artista",
  "contextmenu.goto-album": "Vai all'album",
  "usermessage.default-message": "Si è verificato un errore",
  "usermessage.update-ready": "Ciao. Abbiamo una nuova versione di Spotify pronta per te. <a href=\"#\" data-action=\"{0}\">Riavvia ora</a> per scaricarla.",
  "usermessage.update-ready-simple": "Ciao. Abbiamo una nuova versione di Spotify pronta per te. Riavvia ora per scaricarla.",
  "usermessage.play-token-lost": "Spotify è stato sospeso poiché il tuo account è già utilizzato in un altro luogo.",
  "usermessage.playback-paused-inactive": "Il tuo computer è rimasto inattivo per un lungo periodo di tempo; premi Play per continuare con il tuo ascolto. Per ascoltare musica ininterrottamente, abbonati a <a href=\"#\" data-action=\"{0}\">Spotify Premium</a>.",
  "usermessage.not-available-offline": "Nessuna connessione a Internet rilevata. Spotify prova automaticamente a riconnettersi quando rileva una connessione a Internet (codice di errore: 4)",
  "usermessage.track-not-available-in-region": "Questo brano attualmente non è disponibile in {0}. Se il file si trova sul computer, puoi importarlo.",
  "usermessage.track-not-available-in-region-generic": "Questo brano attualmente non è disponibile nel tuo paese. Se il file si trova sul computer, puoi importarlo.",
  "usermessage.track-not-available": "Questo brano non è disponibile. Se il file si trova sul computer, puoi importarlo.",
  "usermessage.track-not-available-forced-offline": "Per cortesia, <a href=\"#\" data-action=\"goOnline\">disattiva la modalità offline</a> e riprova.",
  "usermessage.track-exclusive-premium": "Questo brano è in esclusiva per gli utenti <a href=\"#\" data-action=\"{0}\">Spotify Premium</a>",
  "usermessage.track-banned-by-artist": "L'artista/l'etichetta ha deciso di non rendere questo brano disponibile. Se il file si trova sul computer, puoi importarlo.",
  "usermessage.local-track-no-file": "Questo brano è stato aggiunto come file locale. Se il file si trova sul computer, puoi importarlo.",
  "usermessage.local-track-file-not-found": "Impossibile riprodurre questo brano poiché il file non è stato trovato. Importalo di nuovo.",
  "usermessage.local-track-bad-format": "File in un formato sconosciuto. Fai clic <a href=\"#\" data-action=\"{0}\">qui</a> per ulteriori informazioni.",
  "usermessage.capping-reached": "Hai superato il limite di tempo di {0} ore. <a href=\"#\" data-action=\"{1}\">Effettua l'upgrade a Spotify Premium</a> per ascoltare senza limitazioni.",
  "usermessage.local-track-drm-protected": "Questo brano non è riproducibile in quanto il file è protetto da DRM (gestione dei diritti digitali).",
  "usermessage.offline-disk-cache": "Download dei brani offline non riuscito. Forse il disco è pieno?",
  "usermessage.offline-sync-expired": "I brani offline sono scaduti. Devi accedere a Spotify per riattivarli.",
  "usermessage.offline-sync-failed": "Download di alcuni brani offline non riuscito.",
  "usermessage.offline-too-many-tracks": "Troppi brani selezionati per la modalità offline.",
  "usermessage.offline-license-server-error": "Si è verificato un problema con il server Spotify.",
  "usermessage.offline-license-lost": "L'accesso offline per questo computer/dispositivo è stato annullato.",
  "usermessage.offline-not-allowed": "La modalità offline è una funzione esclusiva di <a href=\"#\" data-action=\"{0}\">Spotify Premium</a> .",
  "usermessage.language-changed": "È necessario <a href=\"#\" data-action=\"{0}\">riavviare Spotify</a> perché le modifiche abbiano effetto",
  "usermessage.proxysettings-changed": "È necessario <a href=\"#\" data-action=\"{0}\">riavviare Spotify</a> perché le modifiche abbiano effetto",
  "usermessage.language-changed-simple": "Affinché le modifiche abbiano effetto, devi riavviare Spotify",
  "usermessage.proxysettings-changed-simple": "Affinché le modifiche abbiano effetto, devi riavviare Spotify",
  "usermessage.cache-changed": "È necessario <a href=\"#\" data-action=\"{0}\">riavviare Spotify</a> perché le modifiche abbiano effetto",
  "usermessage.cache-changed-simple": "Affinché le modifiche abbiano effetto, devi riavviare Spotify",
  "usermessage.feature-changed": "È necessario <a href=\"#\" data-action=\"{0}\">riavviare Spotify</a> perché le modifiche abbiano effetto",
  "usermessage.first-autostart": "Spotify si è aperto automaticamente, ma come icona. Se preferisci puoi <a href=\"#\" data-action=\"{0}\">aprire Spotify automaticamente ma non come icona</a> oppure <a href=\"#\" data-action=\"{1}\">puoi decidere di non aprire Spotify</a> all'avvio.",
  "usermessage.cant-play-track": "Impossibile riprodurre il brano corrente.",
  "usermessage.cant-skip-ads": "Il brano selezionato verrà riprodotto dopo la pubblicità",
  "usermessage.cant-offline-playlists": "La modalità offline è una funzione esclusiva di Premium. <a href=\"#\" data-action=\"{0}\">Passa a Premium.</a>",
  "usermessage.cant-set-high-quality-streaming": "Questa è una funzione esclusiva di Premium. <a href=\"#\" data-action=\"{0}\">Scegli Premium</a>.",
  "usermessage.payment-state-creditcard-funds": "Non abbiamo potuto rinnovare il tuo abbonamento per un problema relativo al pagamento. Assicurati di avere fondi sufficienti sul tuo conto o <a href=\"#\" data-action=\"{0}\">aggiorna i tuoi dettagli di pagamento</a>.",
  "usermessage.payment-state-creditcard-refused": "Non abbiamo potuto rinnovare il tuo abbonamento per un problema relativo al pagamento. Per evitare che il tuo abbonamento venga annullato, <a href=\"#\" data-action=\"{0}\">aggiorna i tuoi dettagli di pagamento</a>.",
  "usermessage.payment-state-paypal-refused": "Non abbiamo potuto rinnovare il tuo abbonamento per un problema relativo al pagamento. Per evitare che il tuo abbonamento venga annullato, <a href=\"#\" data-action=\"{0}\">aggiorna i tuoi dettagli di pagamento</a>.",
  "usermessage.payment-state-creditcard-expiry": "La carta di credito che utilizzi per il pagamento scadrà fra qualche giorno. Per evitare che il tuo abbonamento venga annullato, <a href=\"#\" data-action=\"{0}\">aggiorna i tuoi dettagli di pagamento</a>.",
  "usermessage.payment-state-prepaid-expiry": "Il tuo abbonamento prepagato sta per scadere. Non preoccuparti, puoi <a href=\"#\" data-action=\"{0}\">iscriverti a Premium qui</a>.",
  "usermessage.payment-state-churn-payment": "Purtroppo non siamo riusciti a ricevere il tuo pagamento, per cui siamo stati costretti ad annullare il tuo abbonamento. Non preoccuparti, puoi <a href=\"#\" data-action=\"{0}\">rinnovare il tuo abbonamento qui</a>.",
  "usermessage.payment-state-churn-partner": "Il tuo abbonamento con uno dei nostri partner è appena terminato, per cui al momento stai usando Spotify Free. Non preoccuparti, puoi <a href=\"#\" data-action=\"{0}\">tornare a Premium qui</a>.",
  "usermessage.opt-in-trial": "Ci auguriamo che la prova gratuita ti piaccia! Per evitare di perdere Premium alla fine della prova, <a href=\"#\" data-action=\"{0}\">iscriviti oggi stesso</a>.",
  "usermessage.opt-in-trial-expired": "La tua prova gratuita è terminata, per cui al momento stai usando Spotify Free. Non preoccuparti, puoi <a href=\"#\" data-action=\"{0}\">tornare a Premium qui</a>.",
  "usermessage.hardware-acceleration-changed": "È necessario <a href=\"#\" data-action=\"{0}\">riavviare Spotify</a> perché le modifiche abbiano effetto",
  "usermessage.hardware-acceleration-changed-simple": "Affinché le modifiche abbiano effetto, devi riavviare Spotify",
  "usermessage.some-local-tracks-not-saved": "Alcuni dei brani selezionati non sono stati salvati in La tua musica. I file locali non sono supportati da La tua musica.",
  "usermessage.illegal-playlist-name-entered": "Il nome della playlist immesso non è valido.",
  "usermessage.playlist-save-failed-unknown": "La playlist non è stata salvata a causa di un errore sconosciuto.",
  "usermessage.social-error-permissions": "Clicca <a href=\"#\" data-action=\"{0}\">qui</a> per condividere su Facebook le tue attività relative alla musica.",
  "usermessage.shuffle-unplayable-track": "<a href=\"#\" data-action=\"{0}\">Passa a Premium</a> per ascoltare qualsiasi brano, in qualsiasi momento.",
  "usermessage.shuffle-ran-out-of-skips": "Possibilità di saltare i brani esaurita (per questa ora). <a href=\"#\" data-action=\"{0}\">Passa a Premium</a> per saltare tutti i brani che vuoi.",
  "usermessage.playlist-limit-exceeded": "Hai riempito questa playlist. Impressionante. Creane una nuova per continuare ad aggiungere contenuti.",
  "usermessage.collection-limit-exceeded": "Grande raccolta, amico. La tua musica non ha più spazio. Per salvare altro, dovrai eliminare dei brani.",
  "usermessage.deprecating-os-version": "Annuncio. Termineremo il supporto per la tua versione del sistema operativo in uno dei prossimi rilasci. Clicca <a href=\"#\" data-action=\"{0}\">qui</a> per ulteriori informazioni.",
  "usermessage.image-upload-propagation": "Operazione terminata (la propagazione delle immagini potrebbe richiedere fino a 24 ore)",
  "usermessage.approaching-capping-limit": "Ti resta meno di un'ora di ascolto gratuito. Approfitta di 15 ore di ascolto gratuito ogni mese oppure <a href=\"#\" data-action=\"{0}\">effettua l'upgrade a Premium</a> per non avere più alcun limite. <a href=\"#\" data-action=\"{1}\">Ulteriori informazioni</a>.",
  "usermessage.half-capping-limit-passed": "Hai raggiunto metà del limite di utilizzo mensile. Approfitta di 15 ore di ascolto gratuito ogni mese oppure <a href=\"#\" data-action=\"{0}\">effettua l'upgrade a Premium</a> per non avere più alcun limite. <a href=\"#\" data-action=\"{1}\">Ulteriori informazioni</a>.",
  "usermessage.video-georestricted": "Non è possibile riprodurre il video nella posizione attuale.",
  "usermessage.video-unsupported-client-version": "Aggiorna Spotify per riprodurre il video.",
  "usermessage.video-unsupported-platform-version": "Non è possibile riprodurre questo video con la tua versione di sistema operativo.",
  "usermessage.video-country-restricted": "Non è possibile riprodurre il video nella posizione attuale.",
  "usermessage.video-unavailable": "Video non disponibile. Vuoi provare con un altro?",
  "usermessage.video-catalogue-restricted": "Spiacenti ma non è possibile riprodurre questo video.",
  "usermessage.video-playback-error": "Spiacenti ma non è possibile riprodurre questo video.",
  "about.title_label": "Informazioni su Spotify",
  "about.close_button_label": "Chiudi",
  "offline-progress-msg": "Sincronizzazione offline di {0} brani su {1}",
  "tos.updated_terms": "Termini aggiornati",
  "tos.modal_title": "Termini e condizioni d'uso di Spotify",
  "tos.tos_text": "<p>Abbiamo aggiornato i <a href=\"{0}\">Termini e condizioni d'uso</a> e <a href=\"{1}\">l'Informativa sulla privacy</a>.</p><p>Continuando a usare Spotify, confermi di accettare questi aggiornamenti, che ti consigliamo di leggere con attenzione.</p>",
  "tos.not_now_tos_text": "<p>Abbiamo aggiornato i <a href=\"{0}\">Termini e condizioni d'uso</a> e <a href=\"{1}\">l'Informativa sulla privacy</a>. </p><p>Cliccando su &quot;Accetto&quot;, confermi di accettare questi aggiornamenti (e che i tuoi dati siano utilizzato come descritto) che ti consigliamo di leggere con attenzione.</p>",
  "tos.tos_text2": "<p>Se non desideri più usare Spotify, puoi annullare l'abbonamento sulla tua pagina Spotify. </p>",
  "tos.not_now_text": "<p>Puoi continuare a usare Spotify per {0} giorni senza accettare l'aggiornamento dei Termini, condizioni e dell'Informativa sulla privacy. Scaduto tale termine, dovrai accettare i nuovi termini per continuare a usare Spotify. A meno che tu non decida di annullare il tuo abbonamento, continuerai a ricevere le fatture mensili secondo il tuo ciclo di fatturazione regolare. Se desideri che Spotify smetta di addebitarti altri costi, puoi annullare l'abbonamento visitando la tua pagina dell'abbonamento a Spotify.</p>",
  "tos.not_now_last_day_text": "<p>Puoi continuare a usare Spotify per 1 giorno senza accettare l'aggiornamento di Termini, condizioni e Informativa sulla privacy. Se, entro tale termine, non accetti le nuove condizioni, non potrai più usare Spotify. A meno che tu non decida di annullare il tuo abbonamento, continuerai a ricevere le fatture mensili secondo il tuo ciclo di fatturazione. Se desideri che Spotify smetta di addebitarti altri costi, puoi annullare l'abbonamento sulla tua pagina Spotify.</p>",
  "tos.not_now_text_germany": "<p>Abbiamo aggiornato i nostri <a href=\"{0}\">Termini e condizioni d'uso</a> e la nostra <a href=\"{1}\">Informativa sulla privacy </a>. Nota:Spotify GmbH intende trasferire, con il tuo consenso, il tuo contratto a Spotify AB, Birger Jarlsgatan 61, 113 56 Stoccolma, Svezia.</p><p>Puoi continuare a usare il servizio Spotify secondo i termini del contratto in vigore fino al {2}. Dopo tale data, per continuare a usare il servizio Spotify dovrai accettare i Termini e condizioni e l'Informativa sulla privacy aggiornati. Cliccando su &quot;Accetto&quot;, accetti quanto segue:</p><p>a) il trasferimento del tuo contratto da Spotify GmbH a Spotify AB,<br />b) gli aggiornamenti ai Termini e condizioni d'uso e<br />c) la raccolta, l'elaborazione e l'uso dei tuoi dati personali secondo le modalità descritte nelle Sezioni 4, 5 e 7 dell'Informativa sulla privacy.</p>",
  "tos.not_now_text2_germany": "<p>Puoi continuare a usare Spotify fino al {0} senza accettare l'aggiornamento dei Termini e condizioni e dell'Informativa sulla privacy. Scaduto tale termine, dovrai accettare i nuovi termini per continuare a usare Spotify. A meno che tu non decida di annullare il tuo abbonamento, se sei un utente Premium continuerai a ricevere le fatture mensili secondo il tuo ciclo di fatturazione regolare. Se desideri che Spotify smetta di addebitarti altri costi, puoi annullare l'abbonamento in qualsiasi momento visitando la pagina del tuo abbonamento a Spotify.</p>",
  "tos.not_now_expired_text_germany": "<p>Abbiamo aggiornato i nostri <a href=\"{0}\">Termini e condizioni d'uso</a> e la nostra <a href=\"{1}\">Informativa sulla privacy</a>.</p><p>Nota: Spotify GmbH intende trasferire, con il tuo consenso, il tuo contratto a Spotify AB, Birger Jarlsgatan 61, 113 56 Stoccolma, Svezia.</p><p>Per continuare a usare il servizio Spotify dovrai accettare i Termini e condizioni e l'Informativa sulla privacy aggiornati. Cliccando su &quot;Accetto&quot;, accetti quanto segue:</p><p>a) il trasferimento del tuo contratto da Spotify GmbH a Spotify AB,<br /> b) gli aggiornamenti ai Termini e condizioni d'uso e<br/> c) la raccolta, l'elaborazione e l'uso dei tuoi dati personali secondo le modalità descritte nelle Sezioni 4, 5 e 7 dell'Informativa sulla privacy.</p>",
  "tos.back_button_label": "Indietro",
  "tos.ok_button_label": "OK",
  "tos.agree_button_label": "Accetta",
  "tos.cancel_button_label": "Rifiuta",
  "tos.not_now_button_label": "Non ora",
  "licenses.modal_title": "Licenze di terze parti",
  "licenses.close_button_label": "Chiudi",
  "feedback.beta_title": "Versione beta",
  "feedback.beta_text": "Cosa ti piace e cosa non ti piace? Faccelo sapere.",
  "market.ad": "Andorra",
  "market.ar": "Argentina",
  "market.at": "Austria",
  "market.au": "Australia",
  "market.be": "Belgio",
  "market.bg": "Bulgaria",
  "market.bo": "Bolivia",
  "market.br": "Brasile",
  "market.ca": "Canada",
  "market.ch": "Svizzera",
  "market.cl": "Cile",
  "market.co": "Colombia",
  "market.cr": "Costa Rica",
  "market.cy": "Cipro",
  "market.cz": "Repubblica Ceca",
  "market.de": "Germania",
  "market.dk": "Danimarca",
  "market.do": "Repubblica Dominicana",
  "market.ec": "Ecuador",
  "market.ee": "Estonia",
  "market.es": "Spagna",
  "market.fi": "Finlandia",
  "market.fr": "Francia",
  "market.gr": "Grecia",
  "market.gt": "Guatemala",
  "market.hk": "Hong Kong",
  "market.hn": "Honduras",
  "market.hu": "Ungheria",
  "market.ie": "Irlanda",
  "market.is": "Islanda",
  "market.it": "Italia",
  "market.jp": "Giappone",
  "market.li": "Liechtenstein",
  "market.lt": "Lituania",
  "market.lu": "Lussemburgo",
  "market.lv": "Lettonia",
  "market.mc": "Monaco",
  "market.mt": "Malta",
  "market.mx": "Messico",
  "market.my": "Malesia",
  "market.ni": "Nicaragua",
  "market.nl": "Paesi Bassi",
  "market.no": "Norvegia",
  "market.nz": "Nuova Zelanda",
  "market.pa": "Panama",
  "market.pe": "Perù",
  "market.ph": "Filippine",
  "market.pl": "Polonia",
  "market.pt": "Portogallo",
  "market.py": "Paraguay",
  "market.se": "Svezia",
  "market.sg": "Singapore",
  "market.sk": "Slovacchia",
  "market.sv": "El Salvador",
  "market.tr": "Turchia",
  "market.tw": "Taiwan",
  "market.uk": "Regno Unito",
  "market.us": "Stati Uniti",
  "market.uy": "Uruguay",
  "market.za": "Sudafrica",
  "sTitle": "Condividi le tue opinioni e aiutaci a creare il miglior servizio musicale del mondo!",
  "sQ1Question": "Consiglieresti Spotify a un amico o un collega?",
  "sQ1Negative": "Molto improbabile",
  "sQ1Positive": "Estremamente probabile",
  "sQ2Question": "Spiega il motivo",
  "sQ3Question": "In generale, in che misura puoi dirti soddisfatto di Spotify?",
  "sQ3Negative": "Molto insoddisfatto",
  "sQ3Positive": "Molto soddisfatto",
  "sSubmit": "Invia sondaggio",
  "sThanks": "Grazie per il tuo aiuto e per il tempo che ci hai dedicato.",
  "sTeam": "Il Team Spotify",
  "sClose": "Chiudi",
  "cls.highlight": "Premium in pausa",
  "cls.title": "Il tuo ultimo pagamento non è andato a buon fine.",
  "cls.desc": "Continua ad ascoltare con Premium aggiungendo un nuovo metodo di pagamento. Ci vorrà solo qualche momento.",
  "cls.updatePayment": "Aggiorna il pagamento",
  "cls.cancelSubscription": "Puoi effettuare il downgrade a Spotify Free<br> <a class=\"cancel-sub\" href=\"#cancel\">annullando il tuo abbonamento Premium</a>.",
  "capping.upsell-title": "Hai raggiunto il limite di ascolto gratuito mensile.",
  "capping.upsell-message": "Ogni mese hai 15 ore di ascolto gratuito.<br />Effettua l'upgrade alla versione Premium per ascoltare musica senza alcun limite né pubblicità.",
  "capping.upsell-button-label": "Passa a Premium",
  "capping.defaultRefillMessage": "Il periodo di ascolto gratuito verrà presto riattivato.",
  "capping.refillMessage": "Il periodo di ascolto gratuito verrà riattivato entro i prossimi {0} giorni.",
  "capping.welcome-title": "Ti diamo il benvenuto su Spotify.",
  "capping.welcome-message": "Approfitta di 15 ore di ascolto gratuito ogni mese.<br />  <a data-action={0}>Effettua l'upgrade alla versione Premium</a> per ascoltare musica senza alcun limite né pubblicità.",
  "capping.welcome-message-button-label": "Per iniziare",
  "yourArtistsTooltipTitle": "Gestisci i tuoi artisti",
  "yourArtistsTooltipText": "Puoi modificare l'immagine del profilo artista di Spotify qualsiasi momento.",
  "yourArtists": "I miei artisti"
};
},{}],13:[function(require,module,exports){
module.exports = {
  "browse.app_name": "Start",
  "latest-releases.app_name": "最新リリース",
  "discover.app_name": "ディスカバー",
  "activity.app_name": "アクティビティ",
  "radio.app_name": "Radio",
  "settings.app_name": "設定",
  "messages.app_name": "メッセージ",
  "profile.app_name": "プロフィール",
  "notifications_center.app_name": "通知",
  "concerts.app_name": "コンサート",
  "profile.private_session": "プライベートセッション",
  "profile.upgrade": "アップグレードする",
  "profile.upgrade_account": "アカウントをアップグレードする",
  "profile.upgrade_tooltip": "プレミアムにアップグレードする",
  "profile.account": "アカウント",
  "profile.logout": "ログアウト",
  "profile.enabled": "有効",
  "profile.menu_label": "メニュー",
  "profile.switch": "ユーザーの切り替え",
  "profile.new_user": "新しいユーザーに切り替える",
  "your_music.app_name": "My Music",
  "your_music.songs": "ソング",
  "your_music.artists": "アーティスト",
  "your_music.albums": "アルバム",
  "your_music.stations": "ステーション",
  "your_music.local_files": "ローカルファイル",
  "sidebar.title_main": "メイン",
  "sidebar.title_playlists": "プレイリスト",
  "new_playlist.input_placeholder": "新規プレイリスト",
  "new_playlist.button": "新規プレイリスト",
  "accessibilitylinks.skip_to_content_label": "メインコンテンツにスキップ",
  "accessibilitylinks.skip_to_player_label": "プレーヤーコントロールにスキップ",
  "playlist.by": "/{0}",
  "playlist.loading": "ロードしています...",
  "playlist.newfolder": "新しいフォルダ",
  "playlist.delete_message": "本当にこのプレイリストを削除しますか?",
  "playlist.unfollow_message": "本当にこのプレイリストのフォローをやめますか?",
  "playlistfolder.delete_message": "本当にこのフォルダとこのフォルダ内のすべてのプレイリストを削除しますか?",
  "playlist.delete_confirm": "削除",
  "playlist.unfollow_confirm": "フォローをやめる",
  "playlist.delete_cancel": "キャンセル",
  "playlist.duplicates_dialog_title": "曲が重複しています",
  "playlist.duplicates_dialog_title_single": "曲が重複しています",
  "playlist.duplicates_dialog_body": "これらの曲の一部は既にプレイリストに追加されています。",
  "playlist.duplicates_dialog_body_single": "この曲は既にプレイリストに追加されています。",
  "playlist.duplicates_dialog_button_add": "すべて追加",
  "playlist.duplicates_dialog_button_add_single": "追加",
  "playlist.duplicates_dialog_button_skip_duplicates": "重複をスキップ",
  "playlist.duplicates_dialog_button_skip_single": "重複をスキップ",
  "playlist.annotate_form.new_playlist_name": "新規プレイリスト",
  "playlist.annotate_form.create_title": "プレイリストを作成",
  "playlist.annotate_form.create": "作成",
  "playlist.annotate_form.cancel": "キャンセル",
  "playlist.annotate_form.edit_title": "プレイリストの詳細の編集",
  "playlist.annotate_form.save": "保存",
  "playlist.annotate_form.name_field_label": "名前",
  "playlist.annotate_form.name_field_placeholder": "プレイリストの名前",
  "playlist.annotate_form.image_field_label": "画像",
  "playlist.annotate_form.image_pick_button_label": "画像を選択",
  "playlist.annotate_form.image_replace_button_label": "画像を変更",
  "playlist.annotate_form.image_remove_button_label": "画像を削除",
  "playlist.annotate_form.image_file_size_exceeded": "画像が大きすぎます。画像の最大サイズは4 MBです。",
  "playlist.annotate_form.image_file_upload_failed": "画像のアップロードに失敗しました。再試行してください。",
  "playlist.annotate_form.annotate_failed": "説明と画像の更新に失敗しました。再試行してください。",
  "playlist.annotate_form.close-error-bar": "非表示",
  "playlist.annotate_form.description_field_label": "説明",
  "playlist.annotate_form.description_field_placeholder": "プレイリストに説明を設定してください。",
  "playlist.annotate_form.permission_message": "By proceeding, you agree to give Spotify access to the image you choose to upload. Please make sure you have the right to upload the image. We'll only use your image for playlist cover art.",
  "playlist.annotate_form.insert_link_button_label": "リンクの挿入",
  "playlist.annotate_form.insert_link.link_field_label": "リンク先",
  "playlist.annotate_form.insert_link.change_button_label": "変更",
  "playlist.annotate_form.insert_link.remove_button_label": "削除",
  "playlist.annotate_form.insert_link.done_button_label": "完了",
  "playlist.annotate_form.drop_to_set_image_label": "ドロップして画像を設定",
  "playlist.annotate_form.drop_not_allowed_label": "サポートされていない形式",
  "playlist.annotate_form.error.file_not_valid_jpg": "このファイルは有効なJPGファイルではありません。",
  "playlist.annotate_form.error.name_required": "プレイリストに名前を付ける必要があります。",
  "playlist.annotate_form.error.selection_required_to_insert_link": "リンク化するテキストを選択する必要があります。",
  "playlist.annotate_form.error.html_not_allowed": "HTMLを使用することはできません。",
  "playlist.annotate_form.error.submit": "プレイリストの変更を保存できませんでした。再試行してください。",
  "playlist.annotate_form.error.image_too_small": "画像サイズが小さすぎます。サイズは{0}x{1}以上である必要があります。",
  "playlist.annotate_form.warning.client_offline": "インターネット接続が見つかりません。説明と画像に対する変更は保存されません。",
  "playlist.annotate_form.warning.no_line_breaks_in_description": "説明内での改行の使用はサポートされていません。",
  "playlist.annotate_form.warning.unsaved_changes": "変更を保存しますか?",
  "navigation.label": "ナビゲーション",
  "navigation.back_button_label": "戻る",
  "navigation.forward_button_label": "進む",
  "search.input_placeholder": "検索",
  "player.label": "プレーヤーコントロール",
  "player.shuffle_mode_label": "シャッフル",
  "player.repeat_mode_label": "繰り返し",
  "player.queue": "次に聴く曲リスト",
  "player.volume_button_label": "音量",
  "player.spotify_connect": "Spotify Connect",
  "player.connect_button_label": "デバイスに接続",
  "player.lyrics_label": "歌詞",
  "player.play_button_label": "再生",
  "player.pause_button_label": "一時停止",
  "player.previous_button_label": "前へ",
  "player.next_button_label": "次へ",
  "player.offline_label": "オフライン",
  "player.thumb_up_label": "高く評価します",
  "player.thumb_down_label": "低く評価します",
  "playererror.default": "選択した曲を再生しようとしたときに問題が発生しました",
  "playererror.track_not_available": "この曲は利用できません",
  "nowplaying.label": "再生中",
  "nowplaying.go_to_context": "再生中の曲に移動",
  "nowplaying.save_your_music": "My Musicに保存",
  "nowplaying.remove_your_music": "My Musicから削除",
  "nowplaying.playing_suggested_track": "おすすめの曲を現在再生中",
  "connect.connect_text": "デバイスに接続",
  "connect.device_connecting": "接続しています…",
  "connect.device_incompatible": "互換性なし",
  "connect.device_premium_only": "プレミアムユーザー限定",
  "connect.device_sleeping": "デバイスはスリープ状態です",
  "connect.device_tech_cast": "Google Cast",
  "connect.device_tech_connect": "Spotify Connect",
  "connect.device_this_computer": "このコンピューター",
  "connect.device_unavailable_for_playback": "再生に利用できません",
  "connect.device_unknown": "不明なデバイス",
  "connect.device_unsupported_uri": "現在、これは再生できません",
  "connect.devices_available": "利用可能なデバイス",
  "connect.dismiss": "閉じる",
  "connect.help1": "Connectを使用すると、ユーザーのデバイス上でSpotifyの再生や管理ができます。",
  "connect.help2": "別のデバイスでSpotifyを起動すると、ここに魔法のように表示されます。",
  "connect.help_hint": "Connectとは",
  "connect.offline": "利用不可",
  "connect.offline_reason_computer": "Spotifyがこのデバイス上でアクティブになっていません。",
  "connect.offline_reason_generic": "Spotifyがこのデバイス上でアクティブになっていません。",
  "connect.offline_reason_phone": "携帯電話がロックされているか、Spotifyがフォアグラウンドになっていません。",
  "connect.offline_reason_gameconsole": "スタンバイモードからPlayStationを有効にするには、Spotify PlayStation アプリケーションのパワーオン設定を使用します。",
  "connect.offline_text1": "この機能を使用するには、オンラインにする必要があります。",
  "connect.offline_title": "オフラインです。",
  "connect.playingon": "再生中のデバイス",
  "connect.popup_title": "デバイス",
  "connect.remoteplayback": "{0}で再生中です",
  "connect.show_more": "さらに表示",
  "connect.upgrade": "アップグレードする",
  "connect.upsell": "Connectは、ユーザーのデバイス上でSpotifyの再生や管理を行うことができるプレミアムの機能です。",
  "contextmenu.new-playlist": "新規プレイリスト",
  "contextmenu.add-to-playlist": "プレイリストに追加",
  "contextmenu.owner-playlist": "/{0}",
  "contextmenu.copy-uri": "Spotify URIをコピー",
  "contextmenu.copy-artist-url": "アーティストリンクのコピー",
  "contextmenu.copy-album-url": "アルバムリンクのコピー",
  "contextmenu.copy-track-url": "曲のリンクをコピー",
  "contextmenu.copy-playlist-url": "プレイリストリンクのコピー",
  "contextmenu.copy-profile-url": "プロフィールリンクのコピー",
  "contextmenu.copy-station-url": "ステーションのリンクをコピー",
  "contextmenu.copy-chart-url": "チャートのリンクをコピー",
  "contextmenu.copy-url": "リンクのコピー",
  "contextmenu.copy-embed": "埋め込みコードをコピー",
  "contextmenu.collaborative": "コラボプレイリスト",
  "contextmenu.save": "My Musicに保存",
  "contextmenu.remove": "My Musicから削除",
  "contextmenu.delete-playlist": "削除",
  "contextmenu.follow": "フォロー",
  "contextmenu.unfollow": "フォローをやめる",
  "contextmenu.publish": "公開する",
  "contextmenu.unpublish": "非公開にする",
  "contextmenu.playlist.loading": "ロードしています...",
  "contextmenu.play": "再生",
  "contextmenu.add-to-queue": "[次に聴く]に追加",
  "contextmenu.station": "Radioに移動",
  "contextmenu.station-album": "アルバムRadioに移動",
  "contextmenu.station-artist": "アーティストRadioに移動",
  "contextmenu.station-playlist": "プレイリストRadioに移動",
  "contextmenu.station-track": "曲Radioに移動",
  "contextmenu.station-chart": "チャートRadioに移動",
  "contextmenu.remove-from-playlist": "このプレイリストから削除",
  "contextmenu.remove-from-queue": "[次に聴く]から削除",
  "contextmenu.rename-folder": "名前を変更",
  "contextmenu.rename-playlist": "名前を変更",
  "contextmenu.edit-playlist": "詳細の編集",
  "contextmenu.report-playlist": "報告",
  "contextmenu.report-asset": "報告",
  "contextmenu.share": "シェア...",
  "contextmenu.share-lyrics": "歌詞を共有",
  "contextmenu.create-folder": "フォルダを作成",
  "contextmenu.create-playlist": "プレイリストを作成",
  "contextmenu.open-localfile-folder": "含まれるフォルダを開く",
  "contextmenu.open-localfile-folder-mac": "ファインダーで表示",
  "contextmenu.offline": "オフラインで利用可",
  "contextmenu.goto-artist": "アーティストに移動",
  "contextmenu.goto-album": "アルバムに移動",
  "usermessage.default-message": "エラーが発生しました",
  "usermessage.update-ready": "こんにちは。Spotifyの新しいバージョンの準備ができました。<a href=\"#\" data-action=\"{0}\">今すぐ再起動する</a>ことで、新バージョンを入手できます。",
  "usermessage.update-ready-simple": "こんにちは。Spotifyの新しいバージョンの準備ができました。今すぐ再起動することで、新バージョンを入手できます。",
  "usermessage.play-token-lost": "アカウントが別の場所で使用されているため、Spotifyは一時停止しました。",
  "usermessage.playback-paused-inactive": "お使いのコンピュータは操作のない状態がしばらく続いていたため、引き続き聴くには[再生]を押してください。中断されることなく音楽を再生するには、<a href=\"#\" data-action=\"{0}\">Spotify Premium</a>を購読してください。",
  "usermessage.not-available-offline": "インターネット接続が見つかりません。インターネット接続を検出すると、Spotifyは自動的に再接続しようとします (エラーコード: 4)",
  "usermessage.track-not-available-in-region": "現在、この曲は{0}では利用できません。コンピュータ上にこのファイルがある場合、インポートすることができます。",
  "usermessage.track-not-available-in-region-generic": "現在、この曲はお住まいの国ではご利用いただけません。コンピュータ上にこのファイルがある場合、インポートすることができます。",
  "usermessage.track-not-available": "この曲は利用できません。コンピュータ上にこのファイルがある場合、インポートすることができます。",
  "usermessage.track-not-available-forced-offline": "<a href=\"#\" data-action=\"goOnline\">オフラインモードをオフ</a>にしてから再試行してください。",
  "usermessage.track-exclusive-premium": "この曲は<a href=\"#\" data-action=\"{0}\">Spotify Premium</a>のユーザのみが利用できます。",
  "usermessage.track-banned-by-artist": "アーティストまたはレーベルの決定により、この曲は再生できません。コンピュータ上にこのファイルがある場合、インポートすることができます。",
  "usermessage.local-track-no-file": "この曲はローカルファイルに追加されました。コンピュータ上にこのファイルがある場合、インポートすることができます。",
  "usermessage.local-track-file-not-found": "ファイルが見つからないため、この曲を再生できません。再度インポートしてください。",
  "usermessage.local-track-bad-format": "ファイル形式が不明です。詳細については<a href=\"#\" data-action=\"{0}\">こちら</a>をクリックしてください。",
  "usermessage.capping-reached": "{0}時間の制限時間を超過しました。制限なしに音楽を聴くには、<a href=\"#\" data-action=\"{1}\">Spotify Premiumにアップグレード </a>してください。",
  "usermessage.local-track-drm-protected": "ファイルがデジタル著作権管理(DRM)で保護されているため、この曲を再生できません。",
  "usermessage.offline-disk-cache": "オフライン曲のダウンロードに失敗しました。ハードディスクに空き容量がない可能性があります。",
  "usermessage.offline-sync-expired": "オフライン曲の有効期限が切れました。再度有効にするにはSpotifyにログインしてください。",
  "usermessage.offline-sync-failed": "一部のオフライン曲のダウンロードに失敗しました。",
  "usermessage.offline-too-many-tracks": "オフラインモード用に選択した曲が多すぎます。",
  "usermessage.offline-license-server-error": "Spotifyサーバに問題が発生しました。",
  "usermessage.offline-license-lost": "このコンピュータまたはデバイスでのオフラインアクセスが拒否されました。",
  "usermessage.offline-not-allowed": "オフラインモードは、<a href=\"#\" data-action=\"{0}\">Spotify Premium</a>のみの機能です。",
  "usermessage.language-changed": "変更を適用するには<a href=\"#\" data-action=\"{0}\">Spotifyを再起動</a>する必要があります",
  "usermessage.proxysettings-changed": "変更を適用するには<a href=\"#\" data-action=\"{0}\">Spotifyを再起動</a>する必要があります",
  "usermessage.language-changed-simple": "変更を適用するにはSpotifyを再起動する必要があります",
  "usermessage.proxysettings-changed-simple": "変更を適用するにはSpotifyを再起動する必要があります",
  "usermessage.cache-changed": "変更を適用するには<a href=\"#\" data-action=\"{0}\">Spotifyを再起動</a>する必要があります",
  "usermessage.cache-changed-simple": "変更を適用するにはSpotifyを再起動する必要があります",
  "usermessage.feature-changed": "変更を適用するには<a href=\"#\" data-action=\"{0}\">Spotifyを再起動</a>する必要があります",
  "usermessage.first-autostart": "Spotifyは自動的に開かれましたが、最小化されています。必要に応じて、<a href=\"#\" data-action=\"{0}\">最小化せずにSpotifyを自動で開く</a>ように設定することも、<a href=\"#\" data-action=\"{1}\">起動時にSpotifyを開かない</a>ように設定することもできます。",
  "usermessage.cant-play-track": "現在の曲を再生できません。",
  "usermessage.cant-skip-ads": "選択した曲は広告の後に再生されます",
  "usermessage.cant-offline-playlists": "オフラインモードは、プレミアムのみの機能です。<a href=\"#\" data-action=\"{0}\">プレミアムにアップグレード</a>してください。",
  "usermessage.cant-set-high-quality-streaming": "これはプレミアムのみの機能です。<a href=\"#\" data-action=\"{0}\">プレミアムにアップグレード</a>してください。",
  "usermessage.payment-state-creditcard-funds": "お支払いに問題が生じたため、お客様の購読を更新することができません。口座の残高をご確認いただくか、<a href=\"#\" data-action=\"{0}\">支払情報の詳細を更新</a>してください。",
  "usermessage.payment-state-creditcard-refused": "お支払いに問題が生じたため、お客様の購読を更新することができません。購読を続けるには、<a href=\"#\" data-action=\"{0}\">支払情報の詳細を更新</a>してください。",
  "usermessage.payment-state-paypal-refused": "お支払いに問題が生じたため、お客様の購読を更新することができません。購読を続けるには、<a href=\"#\" data-action=\"{0}\">支払情報の詳細を更新</a>してください。",
  "usermessage.payment-state-creditcard-expiry": "あと数日で現在お使いの支払いカードの有効期限が切れます。購読を続けるには、<a href=\"#\" data-action=\"{0}\">支払情報の詳細を更新</a>してください。",
  "usermessage.payment-state-prepaid-expiry": "プリペイド型の購読の有効期限が迫っています。ご安心ください。<a href=\"#\" data-action=\"{0}\">ここからプレミアムを購読</a>することができます。",
  "usermessage.payment-state-churn-payment": "お客様からお支払いを受けられませんでしたので、やむを得ず購読をキャンセルいたしました。ご安心ください。<a href=\"#\" data-action=\"{0}\">ここから購読を更新</a>することができます。",
  "usermessage.payment-state-churn-partner": "Spotifyのパートナー企業を利用した購読が終了いたしましたので、これよりSpotify無料版をご利用いただくこととなります。ご安心ください。<a href=\"#\" data-action=\"{0}\">ここからプレミアムを再講読</a>することができます。",
  "usermessage.opt-in-trial": "無料トライアルをお楽しみいただけておりますでしょうか。お試し期間終了後もプレミアムの購読を続けるには、<a href=\"#\" data-action=\"{0}\">本日購読</a>してください。",
  "usermessage.opt-in-trial-expired": "無料トライアルが終了したため、これよりSpotify無料版をご利用いただくこととなります。ご安心ください。<a href=\"#\" data-action=\"{0}\">ここからプレミアムを購読</a>することができます。",
  "usermessage.hardware-acceleration-changed": "変更を適用するには<a href=\"#\" data-action=\"{0}\">Spotifyを再起動</a>する必要があります",
  "usermessage.hardware-acceleration-changed-simple": "変更を適用するにはSpotifyを再起動する必要があります",
  "usermessage.some-local-tracks-not-saved": "選択した曲の一部が[My Music]に保存されませんでした。[My Music]ではローカルファイルはサポートされていません。",
  "usermessage.illegal-playlist-name-entered": "入力されたプレイリスト名が無効です。",
  "usermessage.playlist-save-failed-unknown": "原因不明のエラーによりプレイリストを保存できませんでした。",
  "usermessage.social-error-permissions": "My MusicのアクティビティをFacebookで共有することを許可するには、<a href=\"#\" data-action=\"{0}\">ここ</a>をクリックしてください。",
  "usermessage.shuffle-unplayable-track": "<a href=\"#\" data-action=\"{0}\">プレミアムにアップグレード</a>すると、好きな曲を好きなときに聴くことができます。",
  "usermessage.shuffle-ran-out-of-skips": "この時間内のスキップを使い切りました。<a href=\"#\" data-action=\"{0}\">プレミアムにアップグレード</a>すると、好きなだけスキップすることができます。",
  "usermessage.playlist-limit-exceeded": "このプレイリストは保存容量の上限に達しました。コレクションを続けるには、今すぐ新しいプレイリストを開始してください。",
  "usermessage.collection-limit-exceeded": "コレクションがいっぱいです。[My Music]に空き領域がありません。曲をいくつか削除して空き領域を増やしてから、保存してください。",
  "usermessage.deprecating-os-version": "注意: 次期リリースでは、ご利用のオペレーティングシステムのサポートを終了します。詳細については<a href=\"#\" data-action=\"{0}\">こちら</a>をクリックしてください。",
  "usermessage.image-upload-propagation": "成功しました！（画像が反映されるまで最大24時間かかることがあります）",
  "usermessage.approaching-capping-limit": "利用可能時間は残り1時間をきりました。毎月15時間無料で楽しむか<a href=\"#\" data-action=\"{0}\">プレミアムにアップグレードして</a>時間無制限で音楽を楽しむこともできます。<a href=\"#\" data-action=\"{1}\"> もっと詳しく知ろう </a>。",
  "usermessage.half-capping-limit-passed": "月の上限時間の半分に達しました。毎月15時間無料で楽しむか<a href=\"#\" data-action=\"{0}\">プレミアムにアップグレードして</a>時間無制限で音楽を楽しむこともできます。<a href=\"#\" data-action=\"{1}\"> もっと詳しく知ろう </a>。",
  "usermessage.video-georestricted": "お住まいの地域では、このビデオを再生することはできません。",
  "usermessage.video-unsupported-client-version": "このビデオを再生するには、Spotifyをアップグレードしてください。",
  "usermessage.video-unsupported-platform-version": "お使いのOSバージョンでは、このビデオを再生できません。",
  "usermessage.video-country-restricted": "お住まいの地域では、このビデオを再生することはできません。",
  "usermessage.video-unavailable": "このビデオは視聴できません。他のビデオを試しますか？",
  "usermessage.video-catalogue-restricted": "申し訳ありません。このビデオを再生できません。",
  "usermessage.video-playback-error": "申し訳ありません。このビデオを再生できません。",
  "about.title_label": "Spotifyについて",
  "about.close_button_label": "閉じる",
  "offline-progress-msg": "{1}個中{0}個の曲をオフライン同期しています",
  "tos.updated_terms": "最新の条件",
  "tos.modal_title": "Spotifyの利用条件",
  "tos.tos_text": "<p>Spotifyの<a href=\"{0}\">利用条件</a>および<a href=\"{1}\">プライバシーポリシー</a>を改訂いたしました。</p><p>Spotifyの利用を継続することで、改訂後の条件を承諾したものとみなされますので、改訂後の条件をよくご確認ください。</p>",
  "tos.not_now_tos_text": "<p>Spotifyの<a href=\"{0}\">利用条件</a>および<a href=\"{1}\">プライバシーポリシー</a>を改訂いたしました。</p><p>[承諾する]をクリックすることで、改訂後の条件(および記載されている個人データの取り扱い)に承諾したものとみなされますので、改訂後の条件をよくご確認ください。</p>",
  "tos.tos_text2": "<p>Spotifyの利用を継続しない場合は、Spotifyの購読ページにアクセスして購読をキャンセルすることができます。</p>",
  "tos.not_now_text": "<p>{0}日間は、改訂後の利用条件およびプライバシーポリシーを承諾せずにSpotifyの利用を継続できます。 この期間後も引き続きSpotifyを利用する場合は、改訂後の条件を承諾する必要があります。 購読をキャンセルするまで引き続き、通常の請求サイクルに基づいて毎月料金が請求されます。 今後、Spotifyから料金請求が行われないようにするには、Spotifyの購読ページにアクセスして購読をキャンセルします。キャンセルはいつでもできます。</p>",
  "tos.not_now_last_day_text": "<p>1日間は、改訂後の利用条件およびプライバシーポリシーに承諾せずにSpotifyの利用を継続することができます。この期間内に改定後の条件に承諾しない場合、Spotifyの利用を継続することはできません。購読をキャンセルしない限り、引き続き通常の請求サイクルに基づいて毎月利用料金が請求されます。今後Spotifyによる料金請求が行われないようにするには、Spotifyの購読ページにアクセスしていつでも購読をキャンセルすることができます。</p>",
  "tos.not_now_text_germany": "<p>Spotifyの<a href=\"{0}\">利用条件</a>および<a href=\"{1}\">プライバシーポリシー</a>を改訂いたしました。改訂後の条件を承諾することにより、Spotify GmbHがSpotify AB(Birger Jarlsgatan 61, 113 56 Stockholm, Sweden)にお客様の契約内容を転送することを承諾したものとみなされますのでご注意ください。</p><p>{2}まで、改訂前の条件のままSpotifyサービスを引き続き利用できます。この期限後も継続してSpotifyサービスを利用するためには、改訂後の利用条件およびプライバシーポリシーを承諾する必要があります。[承諾する]をクリックすることで、以下の事項に承諾したものとみなされます。<br/></p><p>a)お客様の契約内容をSpotify GmbHからSpotify ABに転送すること。<br />b)改訂後の利用条件。<br />c)プライバシーポリシーの第4条、第5条、および第7条に記載された個人データの取り扱い方法。</p>",
  "tos.not_now_text2_germany": "<p>{0}までは、改訂後の利用条件およびプライバシーポリシーを承諾せずにSpotifyの利用を継続できます。この期限後も引き続きSpotifyを利用する場合は、改訂後の条件を承諾する必要があります。プレミアムユーザーの場合、購読をキャンセルするまで引き続き、通常の請求サイクルに基づいて毎月料金が請求されます。今後、Spotifyから料金請求が行われないようにするには、Spotifyの購読ページにアクセスして購読をキャンセルします。キャンセルはいつでもできます。</p>",
  "tos.not_now_expired_text_germany": "<p>Spotifyの<a href=\"{0}\">利用条件</a>および<a href=\"{1}\">プライバシーポリシー</a>を改訂いたしました。</p><p>改訂後の条件を承諾することにより、Spotify GmbHがSpotify AB(Birger Jarlsgatan 61, 113 56 Stockholm, Sweden)にお客様の契約内容を転送することを承諾したものとみなされますのでご注意ください。</p><p>継続してSpotifyサービスを利用するためには、改訂後の利用条件およびプライバシーポリシーを承諾する必要があります。[承諾する]をクリックすることで、以下の事項に承諾したものとみなされます。</p><p>a)お客様の契約内容をSpotify GmbHからSpotify ABに転送すること。<br />  b)改訂後の利用条件。 <br/> c)プライバシーポリシーの第4条、第5条、および第7条に記載された個人データの取り扱い方法。</p>",
  "tos.back_button_label": "戻る",
  "tos.ok_button_label": "OK",
  "tos.agree_button_label": "承諾する",
  "tos.cancel_button_label": "承諾しない",
  "tos.not_now_button_label": "後で",
  "licenses.modal_title": "サードパーティライセンス",
  "licenses.close_button_label": "閉じる",
  "feedback.beta_title": "ベータ版",
  "feedback.beta_text": "好きなものと嫌いなものを教えてください。",
  "market.ad": "アンドラ",
  "market.ar": "アルゼンチン",
  "market.at": "オーストリア",
  "market.au": "オーストラリア",
  "market.be": "ベルギー",
  "market.bg": "ブルガリア",
  "market.bo": "ボリビア",
  "market.br": "ブラジル",
  "market.ca": "カナダ",
  "market.ch": "スイス",
  "market.cl": "チリ",
  "market.co": "コロンビア",
  "market.cr": "コスタリカ",
  "market.cy": "キプロス",
  "market.cz": "チェコ共和国",
  "market.de": "ドイツ",
  "market.dk": "デンマーク",
  "market.do": "ドミニカ共和国",
  "market.ec": "エクアドル",
  "market.ee": "エストニア",
  "market.es": "スペイン",
  "market.fi": "フィンランド",
  "market.fr": "フランス",
  "market.gr": "ギリシャ",
  "market.gt": "グアテマラ",
  "market.hk": "香港",
  "market.hn": "ホンジュラス",
  "market.hu": "ハンガリー",
  "market.ie": "アイルランド",
  "market.is": "アイスランド",
  "market.it": "イタリア",
  "market.jp": "日本",
  "market.li": "リヒテンシュタイン",
  "market.lt": "リトアニア",
  "market.lu": "ルクセンブルク",
  "market.lv": "ラトビア",
  "market.mc": "モナコ",
  "market.mt": "マルタ",
  "market.mx": "メキシコ",
  "market.my": "マレーシア",
  "market.ni": "ニカラグア",
  "market.nl": "オランダ",
  "market.no": "ノルウェー",
  "market.nz": "ニュージーランド",
  "market.pa": "パナマ",
  "market.pe": "ペルー",
  "market.ph": "フィリピン",
  "market.pl": "ポーランド",
  "market.pt": "ポルトガル",
  "market.py": "パラグアイ",
  "market.se": "スウェーデン",
  "market.sg": "シンガポール",
  "market.sk": "スロバキア",
  "market.sv": "エルサルバドル",
  "market.tr": "トルコ",
  "market.tw": "台湾",
  "market.uk": "イギリス",
  "market.us": "アメリカ合衆国",
  "market.uy": "ウルグアイ",
  "market.za": "南アフリカ",
  "sTitle": "世界最大の音楽サービスの向上のため、ご意見をお聞かせください!",
  "sQ1Question": "友達や同僚にSpotifyを薦めたいと思いますか?",
  "sQ1Negative": "まったく薦めたくない",
  "sQ1Positive": "強く薦めたい",
  "sQ2Question": "そう思う理由は何ですか?",
  "sQ3Question": "Spotifyの全体的な満足度を教えてください。",
  "sQ3Negative": "とても不満",
  "sQ3Positive": "とても満足",
  "sSubmit": "アンケートを提出",
  "sThanks": "ご協力ありがとうございました。",
  "sTeam": "Spotifyチーム",
  "sClose": "閉じる",
  "cls.highlight": "プレミアムのご利用の一時停止",
  "cls.title": "前回のお支払いを処理できませんでした。",
  "cls.desc": "プレミアムの購読を継続する場合は、新しいお支払い方法を追加してください。この手続きには少しだけ時間がかかります。",
  "cls.updatePayment": "支払い情報の更新",
  "cls.cancelSubscription": "<a class=\"cancel-sub\" href=\"#cancel\">プレミアムの購読をキャンセルする</a>ことで<br> Spotify無料版にダウングレードすることもできます。",
  "capping.upsell-title": "無料利用時間の上限時間に達しました",
  "capping.upsell-message": "毎月15時間無料で音楽を楽しめます<br>プレミアムにアップグレードすると、無制限に音楽が聴け、お知らせも表示されません",
  "capping.upsell-button-label": "プレミアムにアップグレードする",
  "capping.defaultRefillMessage": "まもなく無料視聴可能期間が補充されます。",
  "capping.refillMessage": "無料視聴可能期間は、{0} 日以内に追加されます。",
  "capping.welcome-title": "Spotifyへようこそ。",
  "capping.welcome-message": "毎月15時間の無料視聴をお楽しみください。<br><a data-action={0}>Premiumにアップグレードして</a>広告ナシ＆無制限でミュージックを楽しみましょう。",
  "capping.welcome-message-button-label": "開始する",
  "yourArtistsTooltipTitle": "アーティストを管理",
  "yourArtistsTooltipText": "Spotifyでのアーティストプロフィール画像はいつでも編集可能です。",
  "yourArtists": "自分のアーティスト"
};
},{}],14:[function(require,module,exports){
module.exports = {
  "browse.app_name": "Bladeren",
  "latest-releases.app_name": "Nieuwste releases",
  "discover.app_name": "Ontdekken",
  "activity.app_name": "Activiteiten",
  "radio.app_name": "Radio",
  "settings.app_name": "Instellingen",
  "messages.app_name": "Berichten",
  "profile.app_name": "Profiel",
  "notifications_center.app_name": "Meldingen",
  "concerts.app_name": "Concerten",
  "profile.private_session": "Privé-sessie",
  "profile.upgrade": "Upgrade",
  "profile.upgrade_account": "Je account upgraden",
  "profile.upgrade_tooltip": "Upgrade naar Premium",
  "profile.account": "Account",
  "profile.logout": "Uitloggen",
  "profile.enabled": "Ingeschakeld",
  "profile.menu_label": "Menu",
  "profile.switch": "Overschakelen naar andere gebruiker",
  "profile.new_user": "Overschakelen naar nieuwe gebruiker",
  "your_music.app_name": "Jouw muziek",
  "your_music.songs": "Nummers",
  "your_music.artists": "Artiesten",
  "your_music.albums": "Albums",
  "your_music.stations": "Zenders",
  "your_music.local_files": "Lokale bestanden",
  "sidebar.title_main": "Hoofdvenster",
  "sidebar.title_playlists": "Afspeellijsten",
  "new_playlist.input_placeholder": "Nieuwe afspeellijst",
  "new_playlist.button": "Nieuwe afspeellijst",
  "accessibilitylinks.skip_to_content_label": "Verdergaan naar belangrijkste content",
  "accessibilitylinks.skip_to_player_label": "Verdergaan naar besturingselementen",
  "playlist.by": "van {0}",
  "playlist.loading": "Laden...",
  "playlist.newfolder": "Nieuwe map",
  "playlist.delete_message": "Wil je deze afspeellijst echt verwijderen?",
  "playlist.unfollow_message": "Wil je deze afspeellijst echt niet meer volgen?",
  "playlistfolder.delete_message": "Weet je zeker dat je deze map en alle afspeellijsten in de map wilt verwijderen?",
  "playlist.delete_confirm": "Verwijderen",
  "playlist.unfollow_confirm": "Niet meer volgen",
  "playlist.delete_cancel": "Annuleren",
  "playlist.duplicates_dialog_title": "Dubbele nummers",
  "playlist.duplicates_dialog_title_single": "Dubbel nummer",
  "playlist.duplicates_dialog_body": "Sommige van deze nummers staan al in je afspeellijst.",
  "playlist.duplicates_dialog_body_single": "Dit nummer staat al in je afspeellijst.",
  "playlist.duplicates_dialog_button_add": "Alles toevoegen",
  "playlist.duplicates_dialog_button_add_single": "Toch toevoegen",
  "playlist.duplicates_dialog_button_skip_duplicates": "Dubbele nummers overslaan",
  "playlist.duplicates_dialog_button_skip_single": "Dubbel nummer overslaan",
  "playlist.annotate_form.new_playlist_name": "Nieuwe afspeellijst",
  "playlist.annotate_form.create_title": "Afspeellijst maken",
  "playlist.annotate_form.create": "Aanmaken",
  "playlist.annotate_form.cancel": "Annuleren",
  "playlist.annotate_form.edit_title": "Afspeellijstgegevens bewerken",
  "playlist.annotate_form.save": "Opslaan",
  "playlist.annotate_form.name_field_label": "Naam",
  "playlist.annotate_form.name_field_placeholder": "Naam afspeellijst",
  "playlist.annotate_form.image_field_label": "Afbeelding",
  "playlist.annotate_form.image_pick_button_label": "Afbeelding kiezen",
  "playlist.annotate_form.image_replace_button_label": "Afbeelding vervangen",
  "playlist.annotate_form.image_remove_button_label": "Afbeelding verwijderen",
  "playlist.annotate_form.image_file_size_exceeded": "Afbeelding is te groot. Maximale grootte: 4 MB.",
  "playlist.annotate_form.image_file_upload_failed": "Kon de afbeelding niet uploaden. Probeer het opnieuw.",
  "playlist.annotate_form.annotate_failed": "Kon de beschrijving en afbeelding niet bijwerken. Probeer het opnieuw.",
  "playlist.annotate_form.close-error-bar": "Verbergen",
  "playlist.annotate_form.description_field_label": "Beschrijving",
  "playlist.annotate_form.description_field_placeholder": "Geef je afspeellijst een leuke beschrijving.",
  "playlist.annotate_form.permission_message": "Als je doorgaat, geef je Spotify toegang tot de afbeelding die je hebt geüpload. Zorg dat je het recht hebt om de afbeelding te uploaden. We gebruiken je afbeelding uitsluitend als cover art voor jouw afspeellijsten.",
  "playlist.annotate_form.insert_link_button_label": "Link invoegen",
  "playlist.annotate_form.insert_link.link_field_label": "Koppeling naar",
  "playlist.annotate_form.insert_link.change_button_label": "Wijzigen",
  "playlist.annotate_form.insert_link.remove_button_label": "Verwijderen",
  "playlist.annotate_form.insert_link.done_button_label": "Klaar",
  "playlist.annotate_form.drop_to_set_image_label": "Laat los om de afbeelding te plaatsen",
  "playlist.annotate_form.drop_not_allowed_label": "Niet-ondersteund formaat",
  "playlist.annotate_form.error.file_not_valid_jpg": "Dat bestand is eigenlijk geen geldig jpg-bestand, al zegt de bestandsnaam van wel.",
  "playlist.annotate_form.error.name_required": "Geef je afspeellijst een naam.",
  "playlist.annotate_form.error.selection_required_to_insert_link": "Selecteer de tekst die je in een link wilt veranderen.",
  "playlist.annotate_form.error.html_not_allowed": "Het ziet er naar uit dat je html probeert te gebruiken. Dat is helaas niet mogelijk.",
  "playlist.annotate_form.error.submit": "Kon de wijzigingen in de afspeellijst niet opslaan. Probeer het later opnieuw.",
  "playlist.annotate_form.error.image_too_small": "Die afbeelding is te klein. De afbeelding moet ten minste {0}x{1} zijn. ",
  "playlist.annotate_form.warning.client_offline": "Geen internetverbinding gevonden. Wijziginen in de beschrijving en de afbeelding worden niet opgeslagen.",
  "playlist.annotate_form.warning.no_line_breaks_in_description": "Helaas worden regeleindes niet ondersteund in de beschrijving.",
  "playlist.annotate_form.warning.unsaved_changes": "Wil je je wijzigingen niet opslaan?",
  "navigation.label": "Navigatie",
  "navigation.back_button_label": "Terug",
  "navigation.forward_button_label": "Vooruit",
  "search.input_placeholder": "Zoeken",
  "player.label": "Besturingselementen",
  "player.shuffle_mode_label": "Shuffle",
  "player.repeat_mode_label": "Herhalen",
  "player.queue": "Wachtrij",
  "player.volume_button_label": "Volume",
  "player.spotify_connect": "Spotify Connect",
  "player.connect_button_label": "Verbinding maken met een apparaat",
  "player.lyrics_label": "Songteksten",
  "player.play_button_label": "Afspelen",
  "player.pause_button_label": "Pauze",
  "player.previous_button_label": "Vorige",
  "player.next_button_label": "Volgende",
  "player.offline_label": "Offline",
  "player.thumb_up_label": "Duim omhoog",
  "player.thumb_down_label": "Duim omlaag",
  "playererror.default": "Er is een probleem opgetreden bij het afspelen van het geselecteerde nummer",
  "playererror.track_not_available": "Dit nummer is niet beschikbaar",
  "nowplaying.label": "Wordt nu afgespeeld",
  "nowplaying.go_to_context": "Ga naar Wat wordt er afgespeeld",
  "nowplaying.save_your_music": "Opslaan in Jouw Muziek",
  "nowplaying.remove_your_music": "Verwijderen uit Jouw Muziek",
  "nowplaying.playing_suggested_track": "Voorgesteld nummer wordt momenteel afgespeeld",
  "connect.connect_text": "Verbinding maken met een apparaat",
  "connect.device_connecting": "Verbinden...",
  "connect.device_incompatible": "Niet compatibel",
  "connect.device_premium_only": "Alleen Premium-gebruikers",
  "connect.device_sleeping": "Apparaat staat in slaapstand",
  "connect.device_tech_cast": "Google Cast",
  "connect.device_tech_connect": "Spotify Connect",
  "connect.device_this_computer": "Deze computer",
  "connect.device_unavailable_for_playback": "Niet beschikbaar om op te luisteren",
  "connect.device_unknown": "Onbekend apparaat",
  "connect.device_unsupported_uri": "Kan dit nu niet afspelen",
  "connect.devices_available": "Beschikbare apparaten",
  "connect.dismiss": "Annuleren",
  "connect.help1": "Met Connect kun je Spotify op je apparaten afspelen en bedienen.",
  "connect.help2": "Start Spotify op een ander apparaat en zie Spotify hier verschijnen.",
  "connect.help_hint": "Wat is Connect?",
  "connect.offline": "Niet beschikbaar",
  "connect.offline_reason_computer": "Spotify is niet actief op dit apparaat.",
  "connect.offline_reason_generic": "Spotify is niet actief op dit apparaat.",
  "connect.offline_reason_phone": "Telefoon vergrendeld of Spotify niet op voorgrond",
  "connect.offline_reason_gameconsole": "Gebruik de instellingen voor aanzetten in de Spotify PlayStation-app om de PlayStation aan te zetten vanuit standby-modus.",
  "connect.offline_text1": "Je moet online gaan om deze functie te kunnen gebruiken.",
  "connect.offline_title": "Je bent offline!",
  "connect.playingon": "Muziek wordt afgespeeld op",
  "connect.popup_title": "Apparaten",
  "connect.remoteplayback": "Je muziek wordt afgespeeld op {0}",
  "connect.show_more": "Meer weergeven",
  "connect.upgrade": "Upgrade",
  "connect.upsell": "Connect is een Premium-functie waarmee je Spotify op je apparaten kunt afspelen en bedienen. ",
  "contextmenu.new-playlist": "Nieuwe afspeellijst",
  "contextmenu.add-to-playlist": "Aan afspeellijst toevoegen",
  "contextmenu.owner-playlist": "van {0}",
  "contextmenu.copy-uri": "Spotify-URL kopiëren",
  "contextmenu.copy-artist-url": "Link naar artiest kopiëren",
  "contextmenu.copy-album-url": "Link naar album kopiëren",
  "contextmenu.copy-track-url": "Link van nummer kopiëren",
  "contextmenu.copy-playlist-url": "Link naar afspeellijst kopiëren",
  "contextmenu.copy-profile-url": "Link naar profiel kopiëren",
  "contextmenu.copy-station-url": "Link naar zender kopiëren",
  "contextmenu.copy-chart-url": "Link van hitlijst kopiëren",
  "contextmenu.copy-url": "Link kopiëren",
  "contextmenu.copy-embed": "Embed-code kopiëren",
  "contextmenu.collaborative": "Gezamenlijke afspeellijst",
  "contextmenu.save": "Opslaan in Jouw Muziek",
  "contextmenu.remove": "Verwijderen uit Jouw Muziek",
  "contextmenu.delete-playlist": "Verwijderen",
  "contextmenu.follow": "Volgen",
  "contextmenu.unfollow": "Niet meer volgen",
  "contextmenu.publish": "Openbaar maken",
  "contextmenu.unpublish": "Privé maken",
  "contextmenu.playlist.loading": "Laden...",
  "contextmenu.play": "Afspelen",
  "contextmenu.add-to-queue": "In wachtrij zetten",
  "contextmenu.station": "Ga naar Radio",
  "contextmenu.station-album": "Ga naar Albumradio",
  "contextmenu.station-artist": "Ga naar Artiestenradio",
  "contextmenu.station-playlist": "Ga naar Afspeellijstenradio",
  "contextmenu.station-track": "Ga naar Nummerradio",
  "contextmenu.station-chart": "Ga naar Hitlijstradio",
  "contextmenu.remove-from-playlist": "Uit deze afspeellijst verwijderen",
  "contextmenu.remove-from-queue": "Uit wachtrij verwijderen",
  "contextmenu.rename-folder": "Naam wijzigen",
  "contextmenu.rename-playlist": "Naam wijzigen",
  "contextmenu.edit-playlist": "Gegevens bewerken",
  "contextmenu.report-playlist": "Melding maken",
  "contextmenu.report-asset": "Melding maken",
  "contextmenu.share": "Delen...",
  "contextmenu.share-lyrics": "Songtekst delen",
  "contextmenu.create-folder": "Map aanmaken",
  "contextmenu.create-playlist": "Afspeellijst maken",
  "contextmenu.open-localfile-folder": "Desbetreffende map openen",
  "contextmenu.open-localfile-folder-mac": "Weergeven in Finder",
  "contextmenu.offline": "Offline beschikbaar",
  "contextmenu.goto-artist": "Artiest bekijken",
  "contextmenu.goto-album": "Ga naar album",
  "usermessage.default-message": "Er is een fout opgetreden",
  "usermessage.update-ready": "Hallo! Er staat een nieuwe versie van Spotify voor je klaar. <a href=\"#\" data-action=\"{0}\">Start het nu opnieuw op</a> en profiteer meteen van deze nieuwe versie.",
  "usermessage.update-ready-simple": "Hallo! Er staat een nieuwe versie van Spotify voor je klaar. Start het nu opnieuw op en profiteer meteen van deze nieuwe versie.",
  "usermessage.play-token-lost": "Spotify is gepauzeerd omdat je account ergens anders wordt gebruikt.",
  "usermessage.playback-paused-inactive": "Je hebt je computer lange tijd niet gebruikt. Klik op Afspelen om verder te gaan met luisteren! Neem een abonnement op<a href=\"#\" data-action=\"{0}\">Spotify Premium</a>voor ononderbroken muziek.",
  "usermessage.not-available-offline": "Er is geen internetverbinding gedetecteerd. Er wordt automatisch opnieuw verbinding gemaakt wanneer er weer verbinding met internet is (foutcode: 4).",
  "usermessage.track-not-available-in-region": "Dit nummer is momenteel niet beschikbaar in {0}. Als het bestand op je computer staat, kun je het importeren.",
  "usermessage.track-not-available-in-region-generic": "Dit nummer is momenteel niet beschikbaar in jouw land. Als het bestand op je computer staat, kun je het importeren.",
  "usermessage.track-not-available": "Dit nummer is niet beschikbaar. Als het bestand op je computer staat, kun je het importeren.",
  "usermessage.track-not-available-forced-offline": "Zet <a href=\"#\" data-action=\"goOnline\">offline modus</a> uit en probeer het opnieuw.",
  "usermessage.track-exclusive-premium": "Dit nummer kan alleen worden afgespeeld door <a href=\"#\" data-action=\"{0}\">Spotify Premium-gebruikers</a> .",
  "usermessage.track-banned-by-artist": "De artiest of het platenlabel heeft ervoor gekozen dit nummer niet meer beschikbaar te stellen. Als het bestand op je computer staat, kun je het importeren.",
  "usermessage.local-track-no-file": "Dit nummer is als lokaal bestand toegevoegd. Als het bestand op je computer staat, kun je het importeren.",
  "usermessage.local-track-file-not-found": "Dit nummer kan niet worden afgespeeld omdat het bestand niet kan worden gevonden. Importeer het bestand opnieuw.",
  "usermessage.local-track-bad-format": "Het bestandsformaat is onbekend. Klik <a href=\"#\" data-action=\"{0}\">hier</a> voor meer informatie.",
  "usermessage.capping-reached": "Je hebt je tijdslimiet van {0} uur bereikt. <a href=\"#\" data-action=\"{1}\">Upgrade naar Spotify Premium</a> om zonder beperkingen te luisteren.",
  "usermessage.local-track-drm-protected": "Dit nummer kan niet worden afgespeeld omdat het wordt beschermd door DRM (digital rights management).",
  "usermessage.offline-disk-cache": "Offline nummers konden niet worden gedownload. Misschien is de schijf vol?",
  "usermessage.offline-sync-expired": "De offline nummers zijn verlopen. Je moet inloggen op Spotify om ze weer te activeren.",
  "usermessage.offline-sync-failed": "Sommige offline nummers konden niet worden gedownload.",
  "usermessage.offline-too-many-tracks": "Er zijn te veel nummers geselecteerd voor de offline modus.",
  "usermessage.offline-license-server-error": "Er is een probleem met de Spotify-server.",
  "usermessage.offline-license-lost": "De offline toegang is uitgeschakeld voor deze computer of dit apparaat.",
  "usermessage.offline-not-allowed": "De offline modus is een exclusieve functie van <a href=\"#\" data-action=\"{0}\">Spotify Premium.</a>  ",
  "usermessage.language-changed": "Je moet <a href=\"#\" data-action=\"{0}\">Spotify opnieuw starten</a> voordat de wijziging wordt doorgevoerd",
  "usermessage.proxysettings-changed": "Je moet <a href=\"#\" data-action=\"{0}\">Spotify opnieuw starten</a> voordat de wijziging wordt doorgevoerd",
  "usermessage.language-changed-simple": "Je moet Spotify opnieuw starten om de wijziging door te voeren",
  "usermessage.proxysettings-changed-simple": "Je moet Spotify opnieuw starten om de wijziging door te voeren",
  "usermessage.cache-changed": "Je moet <a href=\"#\" data-action=\"{0}\">Spotify opnieuw starten</a> voordat de wijziging wordt doorgevoerd",
  "usermessage.cache-changed-simple": "Je moet Spotify opnieuw starten om de wijziging door te voeren",
  "usermessage.feature-changed": "Je moet <a href=\"#\" data-action=\"{0}\">Spotify opnieuw starten</a> voordat de wijziging wordt doorgevoerd",
  "usermessage.first-autostart": "Spotify is automatisch geopend in een kleiner scherm. Als je wilt, kun je <a href=\"#\" data-action=\"{0}\">Spotify automatisch openen zonder dat het geminimaliseerd wordt</a> of <a href=\"#\" data-action=\"{1}\">Spotify helemaal niet openen</a> bij het opstarten.",
  "usermessage.cant-play-track": "Het huidige nummer kan niet worden afgespeeld.",
  "usermessage.cant-skip-ads": "Het geselecteerde nummer wordt na de advertentie afgespeeld.",
  "usermessage.cant-offline-playlists": "De offline modus is een exclusieve functie van Premium. <a href=\"#\" data-action=\"{0}\">Upgrade naar Premium</a>.",
  "usermessage.cant-set-high-quality-streaming": "Dit is een exclusieve functie van Premium. <a href=\"#\" data-action=\"{0}\">Upgrade naar Premium</a>.",
  "usermessage.payment-state-creditcard-funds": "We kunnen je abonnement niet verlengen vanwege een probleem met de betaling. Zorg ervoor dat er voldoende saldo op je rekening staat of <a href=\"#\" data-action=\"{0}\">werk je betalingsgegevens bij</a>.",
  "usermessage.payment-state-creditcard-refused": "We kunnen je abonnement niet verlengen vanwege een probleem met de betaling. Om je abonnement te behouden, moet je <a href=\"#\" data-action=\"{0}\">je betalingsgegevens bijwerken</a>.",
  "usermessage.payment-state-paypal-refused": "We kunnen je abonnement niet verlengen vanwege een probleem met de betaling. Om je abonnement te behouden, moet je <a href=\"#\" data-action=\"{0}\">je betalingsgegevens bijwerken</a>.",
  "usermessage.payment-state-creditcard-expiry": "De betaalkaart die je op dit moment gebruikt, vervalt over een paar dagen. Om je abonnement te behouden, moet je <a href=\"#\" data-action=\"{0}\">je betalingsgegevens bijwerken</a>.",
  "usermessage.payment-state-prepaid-expiry": "Je prepaidabonnement verloopt bijna. Geen zorgen, je kunt je <a href=\"#\" data-action=\"{0}\">hier op Premium abonneren</a>.",
  "usermessage.payment-state-churn-payment": "Helaas konden we geen betaling van je innen, dus we moeten je abonnement opzeggen. Geen zorgen je kunt <a href=\"#\" data-action=\"{0}\">je abonnement hier verlengen</a>.",
  "usermessage.payment-state-churn-partner": "Je abonnement bij een van onze partners is onlangs afgelopen, dus je gebruikt nu de gratis versie van Spotify. Geen zorgen, je kunt <a href=\"#\" data-action=\"{0}\">hier teruggaan naar Premium</a>.",
  "usermessage.opt-in-trial": "We hopen dat je veel plezier hebt met je gratis proefabonnement! Wil je Premium niet na je proefabonnement kwijtraken? <a href=\"#\" data-action=\"{0}\">Abonneer je dan vandaag nog</a>!",
  "usermessage.opt-in-trial-expired": "Je gratis proefabonnement is afgelopen, dus je gebruikt nu de gratis versie van Spotify. Geen zorgen, je kunt <a href=\"#\" data-action=\"{0}\">hier teruggaan naar Premium</a>.",
  "usermessage.hardware-acceleration-changed": "Je moet <a href=\"#\" data-action=\"{0}\">Spotify opnieuw starten</a> voordat de wijziging wordt doorgevoerd",
  "usermessage.hardware-acceleration-changed-simple": "Je moet Spotify opnieuw starten om de wijziging door te voeren",
  "usermessage.some-local-tracks-not-saved": "Sommige geselecteerde nummers zijn niet in Jouw muziek opgeslagen. Lokale bestanden worden niet ondersteund door Jouw muziek.",
  "usermessage.illegal-playlist-name-entered": "De naam van de ingevoerde afspeellijst is ongeldig.",
  "usermessage.playlist-save-failed-unknown": "De afspeellijst kon door een onbekende fout niet worden opgeslagen.",
  "usermessage.social-error-permissions": "Klik <a href=\"#\" data-action=\"{0}\">hier</a> om je muziekactiviteit te delen op Facebook.",
  "usermessage.shuffle-unplayable-track": "<a href=\"#\" data-action=\"{0}\">Upgrade naar Premium</a> om elk nummer op elk moment af te spelen.",
  "usermessage.shuffle-ran-out-of-skips": "Je kunt (dit uur) geen nummers meer overslaan. <a href=\"#\" data-action=\"{0}\">Upgrade naar Premium</a> om zo veel nummers over te slaan als je wilt.",
  "usermessage.playlist-limit-exceeded": "Deze afspeellijst zit helemaal vol. Dat doe je goed! Begin een nieuwe afspeellijst om nummers te blijven verzamelen.",
  "usermessage.collection-limit-exceeded": "Wauw, indrukwekkende collectie! Jouw muziek zit helemaal vol. Als je meer wilt opslaan, moet je een aantal nummers verwijderen.",
  "usermessage.deprecating-os-version": "Let op! Jouw besturingssysteem wordt binnenkort niet meer door ons ondersteund. Klik <a href=\"#\" data-action=\"{0}\">hier</a> voor meer informatie.",
  "usermessage.image-upload-propagation": "Gelukt! (Het kan tot 24 uur duren voordat afbeeldingen voor iedereen zichtbaar zijn)",
  "usermessage.approaching-capping-limit": "Je hebt minder dan 1 uur gratis luisteren over. Geniet van 15 uur gratis luisteren per maand of <a href=\"#\" data-action=\"{0}\">upgrade naar Premium</a> voor onbeperkt luisteren. <a href=\"#\" data-action=\"{1}\">Meer info</a>.",
  "usermessage.half-capping-limit-passed": "Je hebt de helft van je maandelijkse limiet gebruikt. Geniet van 15 uur gratis luisteren per maand of <a href=\"#\" data-action=\"{0}\">upgrade naar Premium</a> voor onbeperkt luisteren. <a href=\"#\" data-action=\"{1}\">Meer info</a>.",
  "usermessage.video-georestricted": "Deze video kan niet worden afgespeeld op je huidige locatie.",
  "usermessage.video-unsupported-client-version": "Upgrade Spotify om deze video te bekijken.",
  "usermessage.video-unsupported-platform-version": "Deze video kan niet met jouw versie van je besturingssysteem worden afgespeeld.",
  "usermessage.video-country-restricted": "Deze video kan niet worden afgespeeld op je huidige locatie.",
  "usermessage.video-unavailable": "Deze video is niet beschikbaar. Een andere proberen?",
  "usermessage.video-catalogue-restricted": "We kunnen deze video niet afspelen.",
  "usermessage.video-playback-error": "We kunnen deze video niet afspelen.",
  "about.title_label": "Over Spotify",
  "about.close_button_label": "Sluiten",
  "offline-progress-msg": "Offline {0} van {1} nummers synchroniseren",
  "tos.updated_terms": "Bijgewerkte voorwaarden",
  "tos.modal_title": "Gebruiksvoorwaarden van Spotify",
  "tos.tos_text": "<p>Wij hebben onze <a href=\"{0}\">Gebruikersvoorwaarden</a> en ons <a href=\"{1}\">Privacybeleid</a> gewijzigd.</p><p>Door Spotify te blijven gebruiken, accepteer je de wijzigingen. Neem dus een paar minuten de tijd om het beleid door te lezen.</p>",
  "tos.not_now_tos_text": "<p>Wij hebben onze <a href=\"{0}\">Gebruikersvoorwaarden</a> en ons <a href=\"{1}\">Privacybeleid</a> gewijzigd.</p><p>Door te klikken op &quot;Accepteren&quot;, ga je akkoord met de wijzigingen (en het verwerken van je gegevens zoals erin staat aangegeven). Neem dus een paar minuten de tijd om het beleid door te lezen.</p>",
  "tos.tos_text2": "<p>Als je niet langer gebruikt wilt maken van Spotify, kun je je abonnement opzeggen door naar je Spotify-abonnementspagina te gaan.</p>",
  "tos.not_now_text": "<p>Je kunt Spotify nog {0} dagen blijven gebruiken zonder de gewijzigde Gebruikersvoorwaarden en het gewijzigde Privacybeleid te accepteren. Na die datum ben je verplicht de nieuwe voorwaarden te accepteren om Spotify te kunnen blijven gebruiken. Tenzij je je abonnement opzegt, worden er dan nog maandelijks kosten in rekening gebracht op de reguliere momenten. Als je niet langer wilt dat Spotify kosten in rekening brengt, kun je je abonnement op ieder moment opzeggen door naar je Spotify-abonnementspagina te gaan.</p>",
  "tos.not_now_last_day_text": "<p>Je kunt Spotify nog 1 dag gebruiken zonder de bijgewerkte Gebruikersvoorwaarden en Privacybeleid te accepteren. Als je de nieuwe voorwaarden voor die tijd niet accepteert, kun je niet langer gebruik maken van Spotify. Tenzij je je abonnement opzegt, word je nog wel maandelijks gefactureerd zoals gewoonlijk. Als je niet meer door Spotify gefactureerd wilt worden, kun je je abonnement op ieder moment opzeggen via je Spotify-abonnementspagina.</p>",
  "tos.not_now_text_germany": "<p>Wij hebben onze <a href=\"{0}\">Gebruikersvoorwaarden</a> en ons <a href=\"{1}\">Privacybeleid</a> gewijzigd. Let er op dat, met jouw toestemming, Spotify GmbH jouw contract zal overdragen aan Spotify AB, Birger Jarlsgatan 61, 113 56 Stockholm, Zweden.</p><p>Je kunt Spotify nog blijven gebruiken onder het huidige contract tot {2}. Na deze datum moet je de gewijzigde Gebruikersvoorwaarden en het gewijzige Privacybeleid accepteren als je gebruik wilt blijven maken van Spotify. Door op 'Accepteren' te klikken, stem je in met</p><p>a) het verplaatsen van jouw contract van SPotify GmbH naar Spotify AB, <br/>b) de gewijzigde Gebruikersvoorwaarden en <br/>c) het verzamelen, verwerken en gebruiken van je persoonlijke gegevens zoals omschreven in secties 4, 5 en 7 van het Privacybeleid.</p>",
  "tos.not_now_text2_germany": "<p>Je kunt Spotify nog tot {0} gebruiken zonder de bijgewerkte Gebruikersvoorwaarden en Privacybeleid te accepteren. Op dat moment is het accepteren van de nieuwe voorwaarden vereist om Spotify te kunnen blijven gebruiken. Als je een Premium-gebruiker bent, ontvang je maandelijks een rekening op een vast moment tenzij je je abonnement opzegt. Als je niet langer voor Spotify wilt betalen, kun je je abonnement op ieder moment opzeggen door naar de Spotify-abonnementspagina te gaan.</p>",
  "tos.not_now_expired_text_germany": "<p>Wij hebben onze <a href=\"{0}\">Gebruikersvoorwaarden</a> en ons <a href=\"{1}\">Privacybeleid gewijzigd</a>.</p><p>Let er op dat, met jouw toestemming, Spotify GmbH jouw contract zal overdragen aan Spotify AB, Birger Jarlsgatan 61, 113 56 Stockholm, Zweden.</p><p> Als je van Spotify gebruik wilt blijven maken, moet je de gewijzigde Gebruikersvoorwaarden en het gewijzige Privacybeleid accepteren. Door op 'Accepteren' te klikken, stem je in met</p><p>a) het verplaatsen van jouw contract van SPotify GmbH naar Spotify AB, <br/>b) de gewijzigde Gebruikersvoorwaarden en <br/>c) het verzamelen, verwerken en gebruiken van je persoonlijke gegevens zoals omschreven in secties 4, 5 en 7 van het Privacybeleid.</p>",
  "tos.back_button_label": "Terug",
  "tos.ok_button_label": "OK",
  "tos.agree_button_label": "Accepteren",
  "tos.cancel_button_label": "Weigeren",
  "tos.not_now_button_label": "Nu niet",
  "licenses.modal_title": "Licenties van derden",
  "licenses.close_button_label": "Sluiten",
  "feedback.beta_title": "Bètaversie",
  "feedback.beta_text": "Vind je iets leuk of vervelend? Laat het ons weten.",
  "market.ad": "Andorra",
  "market.ar": "Argentinië",
  "market.at": "Oostenrijk",
  "market.au": "Australië",
  "market.be": "België",
  "market.bg": "Bulgarije",
  "market.bo": "Bolivia",
  "market.br": "Brazilië",
  "market.ca": "Canada",
  "market.ch": "Zwitserland",
  "market.cl": "Chili",
  "market.co": "Colombia",
  "market.cr": "Costa Rica",
  "market.cy": "Cyprus",
  "market.cz": "Tsjechië",
  "market.de": "Duitsland",
  "market.dk": "Denemarken",
  "market.do": "Dominicaanse Republiek",
  "market.ec": "Ecuador",
  "market.ee": "Estland",
  "market.es": "Spanje",
  "market.fi": "Finland",
  "market.fr": "Frankrijk",
  "market.gr": "Griekenland",
  "market.gt": "Guatemala",
  "market.hk": "Hongkong",
  "market.hn": "Honduras",
  "market.hu": "Hongarije",
  "market.ie": "Ierland",
  "market.is": "IJsland",
  "market.it": "Italië",
  "market.jp": "Japan",
  "market.li": "Liechtenstein",
  "market.lt": "Litouwen",
  "market.lu": "Luxemburg",
  "market.lv": "Letland",
  "market.mc": "Monaco",
  "market.mt": "Malta",
  "market.mx": "Mexico",
  "market.my": "Maleisië",
  "market.ni": "Nicaragua",
  "market.nl": "Nederland",
  "market.no": "Noorwegen",
  "market.nz": "Nieuw-Zeeland",
  "market.pa": "Panama",
  "market.pe": "Peru",
  "market.ph": "Filipijnen",
  "market.pl": "Polen",
  "market.pt": "Portugal",
  "market.py": "Paraguay",
  "market.se": "Zweden",
  "market.sg": "Singapore",
  "market.sk": "Slowakije",
  "market.sv": "El Salvador",
  "market.tr": "Turkije",
  "market.tw": "Taiwan",
  "market.uk": "Verenigd Koninkrijk",
  "market.us": "Verenigde Staten",
  "market.uy": "Uruguay",
  "market.za": "Zuid-Afrika",
  "sTitle": "Geef je mening en help ons met het bouwen van de beste muziekservice van de wereld!",
  "sQ1Question": "Hoe waarschijnlijk is het dat je Spotify zou aanbevelen aan een vriend of collega?",
  "sQ1Negative": "Helemaal niet waarschijnlijk",
  "sQ1Positive": "Zeer waarschijnlijk",
  "sQ2Question": "Waarom voel je dit zo?",
  "sQ3Question": "Hoe tevreden ben je over het algemeen met Spotify?",
  "sQ3Negative": "Zeer ontevreden",
  "sQ3Positive": "Zeer tevreden",
  "sSubmit": "Onderzoek indienen",
  "sThanks": "Hartelijk dank voor je hulp. We waarderen je bijdrage.",
  "sTeam": "Het Spotify Team",
  "sClose": "Sluiten",
  "cls.highlight": "Premium gepauzeerd",
  "cls.title": "Je laatste betaling is niet gelukt.",
  "cls.desc": "Blijf luisteren met Premium door een nieuwe betaalmethode toe te voegen. Het duurt niet lang.",
  "cls.updatePayment": "Betaling bijwerken",
  "cls.cancelSubscription": "Je kunt ook downgraden naar Spotify Free<br>door <a class=\"cancel-sub\" href=\"#cancel\">je Premium-abonnement op te zeggen</a>.",
  "capping.upsell-title": "Je hebt je limiet voor gratis luisteren bereikt.",
  "capping.upsell-message": "Je krijgt 15 uur gratis luisteren per maand.<br>Upgrade naar Premium om onbeperkt te luisteren zonder advertenties.",
  "capping.upsell-button-label": "Upgrade naar Premium",
  "capping.defaultRefillMessage": "Je kunt binnenkort weer gratis luisteren.",
  "capping.refillMessage": "Je kunt over {0} dagen weer gratis luisteren.",
  "capping.welcome-title": "Welkom bij Spotify.",
  "capping.welcome-message": "Luister elke maand 15 uur gratis.<br> <a data-action={0}>Upgrade naar Premium</a> voor onbeperkt luisteren zonder advertenties.",
  "capping.welcome-message-button-label": "Beginnen",
  "yourArtistsTooltipTitle": "Beheer je artiesten",
  "yourArtistsTooltipText": "Je kunt nu eenvoudig de profielfoto van je artiest beheren op Spotify.",
  "yourArtists": "Jouw artiesten"
};
},{}],15:[function(require,module,exports){
module.exports = {
  "browse.app_name": "Przeglądaj",
  "latest-releases.app_name": "Najnowsze wydania",
  "discover.app_name": "Odkryj muzykę",
  "activity.app_name": "Aktywność",
  "radio.app_name": "Radio",
  "settings.app_name": "Ustawienia",
  "messages.app_name": "Wiadomości",
  "profile.app_name": "Profil",
  "notifications_center.app_name": "Powiadomienia",
  "concerts.app_name": "Koncerty",
  "profile.private_session": "Sesja prywatna",
  "profile.upgrade": "Przejdź na wyższą wersję",
  "profile.upgrade_account": "Przejdź na wyższą wersję",
  "profile.upgrade_tooltip": "Przejdź na wersję Premium",
  "profile.account": "Konto",
  "profile.logout": "Wyloguj się",
  "profile.enabled": "Włączono",
  "profile.menu_label": "Menu",
  "profile.switch": "Przełącz użytkownika",
  "profile.new_user": "Przełącz na nowego użytkownika",
  "your_music.app_name": "Twoja muzyka",
  "your_music.songs": "Utwory",
  "your_music.artists": "Wykonawcy",
  "your_music.albums": "Albumy",
  "your_music.stations": "Stacje",
  "your_music.local_files": "Lokalne pliki",
  "sidebar.title_main": "Główny",
  "sidebar.title_playlists": "Playlisty",
  "new_playlist.input_placeholder": "Nowa playlista",
  "new_playlist.button": "Nowa playlista",
  "accessibilitylinks.skip_to_content_label": "Przejdź do głównej zawartości",
  "accessibilitylinks.skip_to_player_label": "Przejdź do sterowania odtwarzaczem",
  "playlist.by": "użytkownika {0}",
  "playlist.loading": "Ładowanie...",
  "playlist.newfolder": "Nowy folder",
  "playlist.delete_message": "Na pewno chcesz usunąć tę playlistę?",
  "playlist.unfollow_message": "Czy na pewno chcesz zrezygnować z obserwowania tej playlisty?",
  "playlistfolder.delete_message": "Na pewno chcesz usunąć ten folder i wszystkie znajdujące się w nim playlisty?",
  "playlist.delete_confirm": "Usuń",
  "playlist.unfollow_confirm": "Przestań obserwować",
  "playlist.delete_cancel": "Anuluj",
  "playlist.duplicates_dialog_title": "Powiel utwory",
  "playlist.duplicates_dialog_title_single": "Powiel utwór",
  "playlist.duplicates_dialog_body": "Niektóre z tych utworów znajdują się już na Twojej playliście.",
  "playlist.duplicates_dialog_body_single": "Ten utwór znajduje się już na Twojej playliście.",
  "playlist.duplicates_dialog_button_add": "Dodaj wszystkie",
  "playlist.duplicates_dialog_button_add_single": "Dodaj mimo wszystko",
  "playlist.duplicates_dialog_button_skip_duplicates": "Pomiń powielone",
  "playlist.duplicates_dialog_button_skip_single": "Pomiń powielony",
  "playlist.annotate_form.new_playlist_name": "Nowa playlista",
  "playlist.annotate_form.create_title": "Utwórz playlistę",
  "playlist.annotate_form.create": "Utwórz",
  "playlist.annotate_form.cancel": "Anuluj",
  "playlist.annotate_form.edit_title": "Zmień szczegóły playlisty",
  "playlist.annotate_form.save": "Zapisz",
  "playlist.annotate_form.name_field_label": "Nazwa",
  "playlist.annotate_form.name_field_placeholder": "Nazwa playlisty",
  "playlist.annotate_form.image_field_label": "Obraz",
  "playlist.annotate_form.image_pick_button_label": "Wybierz obraz",
  "playlist.annotate_form.image_replace_button_label": "Zmień obraz",
  "playlist.annotate_form.image_remove_button_label": "Usuń obraz",
  "playlist.annotate_form.image_file_size_exceeded": "Obraz jest za duży. Może mieć maksymalnie 4 MB.",
  "playlist.annotate_form.image_file_upload_failed": "Nie udało się załadować obrazu. Spróbuj ponownie.",
  "playlist.annotate_form.annotate_failed": "Nie udało się zaktualizować opisu i obrazu. Spróbuj ponownie.",
  "playlist.annotate_form.close-error-bar": "Ukryj",
  "playlist.annotate_form.description_field_label": "Opis",
  "playlist.annotate_form.description_field_placeholder": "Nadaj swojej playliście chwytliwą nazwę.",
  "playlist.annotate_form.permission_message": "Kontynuowanie oznacza, że wyrażasz zgodę na uzyskiwanie przez Spotify dostępu do przesłanego przez Ciebie obrazu. Upewnij się, że masz prawo do przesłania obrazu. Twój obraz będzie używany tylko jako okładka playlisty.",
  "playlist.annotate_form.insert_link_button_label": "Wstaw łącze",
  "playlist.annotate_form.insert_link.link_field_label": "Łącze do",
  "playlist.annotate_form.insert_link.change_button_label": "Zmień",
  "playlist.annotate_form.insert_link.remove_button_label": "Usuń",
  "playlist.annotate_form.insert_link.done_button_label": "Gotowe",
  "playlist.annotate_form.drop_to_set_image_label": "Upuść, aby ustawić obraz",
  "playlist.annotate_form.drop_not_allowed_label": "Nieobsługiwany format",
  "playlist.annotate_form.error.file_not_valid_jpg": "Mimo że nazwa tego pliku wskazuje inaczej, nie jest on w obsługiwanym formacie JPG.",
  "playlist.annotate_form.error.name_required": "Musisz nadać nazwę swojej playliście.",
  "playlist.annotate_form.error.selection_required_to_insert_link": "Musisz zaznaczyć tekst, który ma stać się łączem.",
  "playlist.annotate_form.error.html_not_allowed": "Wygląda na to, że chcesz użyć pliku w nieobsługiwanym formacie HTML.",
  "playlist.annotate_form.error.submit": "Nie można zapisać zmian w playliście. Spróbuj ponownie.",
  "playlist.annotate_form.error.image_too_small": "Ten obraz jest za mały. Minimalne wymiary to {0} x {1}.",
  "playlist.annotate_form.warning.client_offline": "Brak połączenia z Internetem. Nowy obraz i zmiany w opisie nie zostaną zachowane.",
  "playlist.annotate_form.warning.no_line_breaks_in_description": "Opis nie może zawierać podziałów wierszy.",
  "playlist.annotate_form.warning.unsaved_changes": "Czy chcesz zapisać wprowadzone zmiany?",
  "navigation.label": "Nawigacja",
  "navigation.back_button_label": "Wstecz",
  "navigation.forward_button_label": "Dalej",
  "search.input_placeholder": "Szukaj",
  "player.label": "Sterowanie odtwarzaczem",
  "player.shuffle_mode_label": "Odtwarzanie losowe",
  "player.repeat_mode_label": "Powtórz",
  "player.queue": "Kolejka",
  "player.volume_button_label": "Głośność",
  "player.spotify_connect": "Spotify Connect",
  "player.connect_button_label": "Podłącz do urządzenia",
  "player.lyrics_label": "Teksty",
  "player.play_button_label": "Odtwórz",
  "player.pause_button_label": "Pauza",
  "player.previous_button_label": "Poprzedni",
  "player.next_button_label": "Dalej",
  "player.offline_label": "Offline",
  "player.thumb_up_label": "Kciuk w górę",
  "player.thumb_down_label": "Kciuk w dół",
  "playererror.default": "Pojawił się problem podczas próby odtworzenia wybranego utworu",
  "playererror.track_not_available": "Ten utwór jest niedostępny",
  "nowplaying.label": "Aktualnie odtwarzane",
  "nowplaying.go_to_context": "Przejdź do aktualnie odtwarzanych",
  "nowplaying.save_your_music": "Zapisz w kolekcji Twoja muzyka",
  "nowplaying.remove_your_music": "Usuń z kolekcji Twoja muzyka",
  "nowplaying.playing_suggested_track": "Obecnie odtwarzany sugerowany utwór",
  "connect.connect_text": "Podłącz do urządzenia",
  "connect.device_connecting": "Łączenie…",
  "connect.device_incompatible": "Niekompatybilne",
  "connect.device_premium_only": "Wyłącznie dla użytkowników Premium",
  "connect.device_sleeping": "Urządzenie w stanie uśpienia",
  "connect.device_tech_cast": "Google Cast",
  "connect.device_tech_connect": "Spotify Connect",
  "connect.device_this_computer": "Ten komputer",
  "connect.device_unavailable_for_playback": "Nie można odtwarzać na urządzeniu",
  "connect.device_unknown": "Nieznane urządzenie",
  "connect.device_unsupported_uri": "Nie można w tym momencie włączyć odtwarzania",
  "connect.devices_available": "Dostępne urządzenia",
  "connect.dismiss": "Odrzuć",
  "connect.help1": "Connect umożliwia odtwarzanie i obsługę Spotify na Twoich urządzeniach.",
  "connect.help2": "Uruchom Spotify na innym urządzeniu, a ono w magiczny sposób pojawi się tutaj.",
  "connect.help_hint": "Co to jest Connect?",
  "connect.offline": "Niedostępne",
  "connect.offline_reason_computer": "Spotify jest nieaktywny na tym urządzeniu.",
  "connect.offline_reason_generic": "Spotify jest nieaktywny na tym urządzeniu.",
  "connect.offline_reason_phone": "Telefon jest zablokowany lub Spotify nie jest na pierwszym planie.",
  "connect.offline_reason_gameconsole": "Użyj ustawień włączania zasilania w aplikacji Spotify dla konsoli PlayStation, aby włączyć wybudzanie konsoli z trybu gotowości.",
  "connect.offline_text1": "Aby korzystać z tej funkcji, przejdź do trybu online.",
  "connect.offline_title": "Jesteś w trybie offline!",
  "connect.playingon": "Słuchasz na urządzeniu",
  "connect.popup_title": "Urządzenia",
  "connect.remoteplayback": "Słuchasz na urządzeniu {0}",
  "connect.show_more": "Pokaż więcej",
  "connect.upgrade": "Przejdź na wyższą wersję",
  "connect.upsell": "Connect działa w wersji Premium i umożliwia odtwarzanie utworów oraz obsługę Spotify na wszystkich urządzeniach",
  "contextmenu.new-playlist": "Nowa playlista",
  "contextmenu.add-to-playlist": "Dodaj do playlisty",
  "contextmenu.owner-playlist": "użytkownika {0}",
  "contextmenu.copy-uri": "Skopiuj identyfikator URI Spotify",
  "contextmenu.copy-artist-url": "Skopiuj łącze do wykonawcy",
  "contextmenu.copy-album-url": "Skopiuj łącze do albumu",
  "contextmenu.copy-track-url": "Skopiuj łącze do utworu",
  "contextmenu.copy-playlist-url": "Skopiuj łącze do playlisty",
  "contextmenu.copy-profile-url": "Skopiuj łącze do profilu",
  "contextmenu.copy-station-url": "Skopiuj łącze do stacji",
  "contextmenu.copy-chart-url": "Skopiuj łącze do listy przebojów",
  "contextmenu.copy-url": "Skopiuj łącze",
  "contextmenu.copy-embed": "Kopiuj osadzony kod",
  "contextmenu.collaborative": "Współtworzona playlista",
  "contextmenu.save": "Zapisz w kolekcji Twoja muzyka",
  "contextmenu.remove": "Usuń z kolekcji Twoja muzyka",
  "contextmenu.delete-playlist": "Usuń",
  "contextmenu.follow": "Obserwuj",
  "contextmenu.unfollow": "Przestań obserwować",
  "contextmenu.publish": "Upublicznij",
  "contextmenu.unpublish": "Utajnij",
  "contextmenu.playlist.loading": "Ładowanie...",
  "contextmenu.play": "Odtwórz",
  "contextmenu.add-to-queue": "Dodaj do kolejki",
  "contextmenu.station": "Przejdź do radia",
  "contextmenu.station-album": "Włącz radio albumu",
  "contextmenu.station-artist": "Włącz radio wykonawcy",
  "contextmenu.station-playlist": "Włącz radio playlisty",
  "contextmenu.station-track": "Włącz radio utworu",
  "contextmenu.station-chart": "Przejdź do radia listy przebojów",
  "contextmenu.remove-from-playlist": "Usuń z tej playlisty",
  "contextmenu.remove-from-queue": "Usuń z kolejki",
  "contextmenu.rename-folder": "Zmień nazwę",
  "contextmenu.rename-playlist": "Zmień nazwę",
  "contextmenu.edit-playlist": "Zmień szczegóły",
  "contextmenu.report-playlist": "Zgłoś",
  "contextmenu.report-asset": "Zgłoś",
  "contextmenu.share": "Udostępnij...",
  "contextmenu.share-lyrics": "Udostępnij teksty",
  "contextmenu.create-folder": "Utwórz folder",
  "contextmenu.create-playlist": "Utwórz playlistę",
  "contextmenu.open-localfile-folder": "Otwórz folder zawierający",
  "contextmenu.open-localfile-folder-mac": "Pokaż w Finderze",
  "contextmenu.offline": "Dostępne w trybie offline",
  "contextmenu.goto-artist": "Przejdź do wykonawcy",
  "contextmenu.goto-album": "Przejdź do albumu",
  "usermessage.default-message": "Wystąpił błąd",
  "usermessage.update-ready": "Witaj, Nowa wersja Spotify jest już gotowa. <a href=\"#\" data-action=\"{0}\">Uruchom aplikację ponownie</a>, aby z niej skorzystać.",
  "usermessage.update-ready-simple": "Witaj, Nowa wersja Spotify jest już gotowa. Uruchom aplikację ponownie, aby z niej skorzystać.",
  "usermessage.play-token-lost": "Spotify zostało wstrzymane, ponieważ Twoje konto używane jest gdzieś indziej.",
  "usermessage.playback-paused-inactive": "Twój komputer był nieaktywny przez dłuższy czas. Naciśnij przycisk odtwarzania, aby kontynuować słuchanie. Aby mieć nieprzerwany dostęp do muzyki, zaskubskrybuj <a href=\"#\" data-action=\"{0}\">Spotify Premium</a>.",
  "usermessage.not-available-offline": "Nie wykryto połączenia z Internetem. Spotify spróbuje połączyć się automatycznie, gdy zostanie wykryte połączenie z Internetem (kod błędu:4)",
  "usermessage.track-not-available-in-region": "Ten utwór jest obecnie niedostępny w {0}. Jeśli masz plik na komputerze, możesz go zaimportować.",
  "usermessage.track-not-available-in-region-generic": "Ten utwór jest obecnie niedostępny w Twoim kraju. Jeśli masz plik na komputerze, możesz go zaimportować.",
  "usermessage.track-not-available": "Ten utwór jest niedostępny Jeśli masz plik na komputerze, możesz go zaimportować.",
  "usermessage.track-not-available-forced-offline": "Wyłącz <a href=\"#\" data-action=\"goOnline\">tryb offline</a> i spróbuj ponownie.",
  "usermessage.track-exclusive-premium": "Ten utwór jest dostępny wyłącznie dla użytkowników <a href=\"#\" data-action=\"{0}\">Spotify Premium</a> .",
  "usermessage.track-banned-by-artist": "Wykonawca/wydawca nie udostępnia tego utworu. Jeśli masz plik na komputerze, możesz go zaimportować.",
  "usermessage.local-track-no-file": "Ten utwór został dodany jako plik lokalny. Jeśli masz plik na komputerze, możesz go zaimportować.",
  "usermessage.local-track-file-not-found": "Nie można odtworzyć tego utworu, ponieważ nie można znaleźć pliku. Zaimportuj go ponownie.",
  "usermessage.local-track-bad-format": "Plik ma nieznany format. Kliknij <a href=\"#\" data-action=\"{0}\">tutaj</a>, aby uzyskać informacje.",
  "usermessage.capping-reached": "Limit {0} godz. został przekroczony. <a href=\"#\" data-action=\"{1}\">Przejdź na Spotify Premium,</a> aby słuchać muzyki bez ograniczeń.",
  "usermessage.local-track-drm-protected": "Nie można odtworzyć tego utworu, ponieważ plik jest zabezpieczony systemem Digital Rights Management (DRM, pol. zarządzania prawami do treści cyfrowych).",
  "usermessage.offline-disk-cache": "Pobieranie utworów w trybie offline nie powiodło się. Może dysk jest pełny?",
  "usermessage.offline-sync-expired": "Utwory offline są nieaktualne. Musisz zalogować się w Spotify, aby je ponownie aktywować.",
  "usermessage.offline-sync-failed": "Pobieranie niektórych utworów offline nie powiodło się.",
  "usermessage.offline-too-many-tracks": "Wybrano za dużo utworów dla trybu offline.",
  "usermessage.offline-license-server-error": "Wystąpił problem z serwerem Spotify.",
  "usermessage.offline-license-lost": "Dostęp offline dla tego komputera/urządzenia został anulowany.",
  "usermessage.offline-not-allowed": "Tryb offline to funkcja dostępna wyłącznie w wersji <a href=\"#\" data-action=\"{0}\">Spotify Premium</a>.",
  "usermessage.language-changed": "Musisz <a href=\"#\" data-action=\"{0}\">ponownie uruchomić aplikację Spotify</a>,​ aby zmiana została uwzględniona",
  "usermessage.proxysettings-changed": "Musisz <a href=\"#\" data-action=\"{0}\">ponownie uruchomić aplikację Spotify</a>,​ aby zmiana została uwzględniona",
  "usermessage.language-changed-simple": "Musisz ponownie uruchomić Spotify,​ aby zmiana została uwzględniona",
  "usermessage.proxysettings-changed-simple": "Musisz ponownie uruchomić Spotify,​ aby zmiana została uwzględniona",
  "usermessage.cache-changed": "Musisz <a href=\"#\" data-action=\"{0}\">ponownie uruchomić aplikację Spotify</a>,​ aby zmiana została uwzględniona",
  "usermessage.cache-changed-simple": "Musisz ponownie uruchomić Spotify,​ aby zmiana została uwzględniona",
  "usermessage.feature-changed": "Musisz <a href=\"#\" data-action=\"{0}\">ponownie uruchomić aplikację Spotify</a>,​ aby zmiana została uwzględniona",
  "usermessage.first-autostart": "Aplikacja Spotify uruchomiła się automatycznie, ale w formie zminimalizowanej. Jeśli chcesz, to <a href=\"#\" data-action=\"{0}\">aplikacja Spotify może otwierać się automatycznie, ale nie w formie zminimalizowanej.</a>Może też <a href=\"#\" data-action=\"{1}\">nie otwierać się podczas uruchamiania systemu</a>.",
  "usermessage.cant-play-track": "Nie można odtworzyć bieżącego utworu.",
  "usermessage.cant-skip-ads": "Wybrany utwór będzie odtwarzany po reklamie",
  "usermessage.cant-offline-playlists": "Tryb offline to funkcja dostępna wyłącznie w wersji Premium. <a href=\"#\" data-action=\"{0}\">Załóż konto Premium</a>.",
  "usermessage.cant-set-high-quality-streaming": "Jest to funkcja dostępna wyłącznie w wersji Premium. <a href=\"#\" data-action=\"{0}\">Załóż konto Premium</a>.",
  "usermessage.payment-state-creditcard-funds": "Nie można odnowić subskrypcji — wystąpił problem z płatnością. Upewnij się, że posiadasz odpowiednie środki na koncie lub <a href=\"#\" data-action=\"{0}\">uaktualnij szczegóły dotyczące formy płatności</a>.",
  "usermessage.payment-state-creditcard-refused": "Nie można odnowić subskrypcji — wystąpił problem z płatnością. Aby odnowić subskrypcję, <a href=\"#\" data-action=\"{0}\">uaktualnij szczegóły dotyczące formy płatności</a>.",
  "usermessage.payment-state-paypal-refused": "Nie można odnowić subskrypcji — wystąpił problem z płatnością. Aby odnowić subskrypcję, <a href=\"#\" data-action=\"{0}\">uaktualnij szczegóły dotyczące formy płatności</a>.",
  "usermessage.payment-state-creditcard-expiry": "Twoja karta płatnicza za kilka dni utraci ważność. Aby zachować subskrypcję, <a href=\"#\" data-action=\"{0}\">uaktualnij szczegóły dotyczące formy płatności</a>.",
  "usermessage.payment-state-prepaid-expiry": "Twoja opłacona subskrypcja pre-paid niedługo wygaśnie. Bez obaw. Tutaj możesz przejść na <a href=\"#\" data-action=\"{0}\">wersję Premium</a>.",
  "usermessage.payment-state-churn-payment": "Wystąpił błąd podczas pobierania należności. Twoja subskrypcja została anulowana. Bez obaw. Tutaj możesz <a href=\"#\" data-action=\"{0}\">odnowić subskrypcję</a>.",
  "usermessage.payment-state-churn-partner": "Twoja subskrypcja u jednego z naszych partnerów wygasła. Korzystasz teraz z bezpłatnej wersji Spotify. Bez obaw. Tutaj możesz ponownie <a href=\"#\" data-action=\"{0}\">przejść na wersję Premium</a>.",
  "usermessage.opt-in-trial": "Mamy nadzieję, że podoba Ci się bezpłatny okres próbny. Aby uniknąć utraty dostępu do wersji Premium po jego zakończeniu, <a href=\"#\" data-action=\"{0}\">wykup subskrypcję już dzisiaj</a>.",
  "usermessage.opt-in-trial-expired": "Bezpłatny okres próbny dobiegł końca. Korzystasz teraz z bezpłatnej wersji Spotify. Bez obaw. Tutaj możesz ponownie <a href=\"#\" data-action=\"{0}\">przejść na wersję Premium</a>.",
  "usermessage.hardware-acceleration-changed": "Musisz <a href=\"#\" data-action=\"{0}\">ponownie uruchomić aplikację Spotify</a>,​ aby zmiana została uwzględniona",
  "usermessage.hardware-acceleration-changed-simple": "Musisz ponownie uruchomić Spotify,​ aby zmiana została uwzględniona",
  "usermessage.some-local-tracks-not-saved": "Niektóre z wybranych utworów nie zostały zapisane w kolekcji Twoja muzyka. Pliki lokalne nie są obsługiwane przez kolekcję Twoja muzyka.",
  "usermessage.illegal-playlist-name-entered": "Wprowadzona nazwa playlisty jest nieprawidłowa.",
  "usermessage.playlist-save-failed-unknown": "Wystąpił nieznany błąd i playlista nie została zapisana.",
  "usermessage.social-error-permissions": "Kliknij <a href=\"#\" data-action=\"{0}\">tutaj</a>, jeśli chcesz, żeby Twoja aktywność była widoczna na Facebooku.",
  "usermessage.shuffle-unplayable-track": "<a href=\"#\" data-action=\"{0}\">Przejdź na wersję Premium</a> , aby odtwarzać dowolne utwory, kiedy tylko masz na to ochotę.",
  "usermessage.shuffle-ran-out-of-skips": "Liczba pominięć (w tej godzinie) została wyczerpana. <a href=\"#\" data-action=\"{0}\">Przejdź na wersję Premium</a> , aby pomijać utwory bez ograniczeń.",
  "usermessage.playlist-limit-exceeded": "Ta playlista jest już zapełniona. Imponujące! Utwórz nową playlistę, by zapisać kolejne utwory.",
  "usermessage.collection-limit-exceeded": "Niesamowita kolekcja, przyjacielu. Kolekcja Twoja Muzyka jest już zapełniona. Aby zapisać w niej kolejne utwory, musisz coś usunąć.",
  "usermessage.deprecating-os-version": "Ostrzeżenie! Wsparcie dla Twojego systemu operacyjnego zakończy się wraz z nadchodzącym wydaniem. Kliknij <a href=\"#\" data-action=\"{0}\">tutaj</a> , aby uzyskać więcej informacji.",
  "usermessage.image-upload-propagation": "Udało się! (Propagacja obrazów może zająć do 24 godzin)",
  "usermessage.approaching-capping-limit": "Pozostała Ci mniej niż 1 godzina bezpłatnego słuchania. Ciesz się muzyką bezpłatnie przez 15 godzin miesięcznie lub <a href=\"#\" data-action=\"{0}\">przejdź na wersję Premium</a>, aby słuchać bez ograniczeń. <a href=\"#\" data-action=\"{1}\">Dowiedz się więcej</a>.",
  "usermessage.half-capping-limit-passed": "Wykorzystano ponad połowę miesięcznego limitu. Ciesz się muzyką bezpłatnie przez 15 godzin miesięcznie lub <a href=\"#\" data-action=\"{0}\">przejdź na wersję Premium</a>, aby słuchać bez ograniczeń. <a href=\"#\" data-action=\"{1}\">Dowiedz się więcej</a>.",
  "usermessage.video-georestricted": "Odtwarzanie tego filmu w Twojej lokalizacji jest niedostępne.",
  "usermessage.video-unsupported-client-version": "Zaktualizuj Spotify, aby odtworzyć ten film.",
  "usermessage.video-unsupported-platform-version": "Odtworzenie tego filmu w używanej wersji systemu operacyjnego jest niemożliwe.",
  "usermessage.video-country-restricted": "Odtwarzanie tego filmu w Twojej lokalizacji jest niedostępne.",
  "usermessage.video-unavailable": "Ten film jest niedostępny. Chcesz wypróbować inny?",
  "usermessage.video-catalogue-restricted": "Niestety nie można odtworzyć tego filmu.",
  "usermessage.video-playback-error": "Niestety nie można odtworzyć tego filmu.",
  "about.title_label": "O Spotify",
  "about.close_button_label": "Zakończ",
  "offline-progress-msg": "Synchronizacja offline utworów: {0} z {1}",
  "tos.updated_terms": "Uaktualnione Warunki",
  "tos.modal_title": "Warunki korzystania ze Spotify",
  "tos.tos_text": "<p>Zaktualizowaliśmy <a href=\"{0}\">Warunki korzystania ze Spotify</a> oraz <a href=\"{1}\">Politykę prywatności</a>.</p><p>Korzystając dalej z serwisu Spotify, oświadczasz, że je akceptujesz. Poświęć zatem chwilę, by się z nimi zapoznać.</p>",
  "tos.not_now_tos_text": "<p>Zaktualizowaliśmy postanowienia <a href=\"{0}\">Warunków korzystania ze Spotify</a> oraz <a href=\"{1}\">Polityki prywatności</a>.</p><p>Zapoznaj się z nimi. Klikając przycisk „Akceptuję”, oświadczasz, że są Ci one znane, rozumiesz je i akceptujesz, a także że zgadzasz się na opisane w tych postanowieniach przetwarzanie swoich danych.</p>",
  "tos.tos_text2": "<p>Jeśli chcesz zrezygnować z usługi Spotify, możesz to zrobić na swojej stronie subskrypcji Spotify.</p>",
  "tos.not_now_text": "<p>W przypadku braku akceptacji uaktualnionych postanowień Warunków korzystania z serwisu oraz Polityki prywatności serwis Spotify będzie aktywny przez {0} dni. Po tym czasie korzystanie z serwisu będzie możliwe tylko po zaakceptowaniu zaktualizowanych postanowień. W przypadku braku rezygnacji z subskrypcji miesięczna opłata za korzystanie z usługi będzie nadal regularnie naliczana. Aby uniknąć opłat, należy zrezygnować z subskrypcji. Można to zrobić w dowolnym momencie na stronie subskrypcji użytkownika.</p>",
  "tos.not_now_last_day_text": "<p>W przypadku braku akceptacji uaktualnionych postanowień Warunków korzystania ze Spotify oraz Polityki prywatności usługa Spotify będzie aktywna jeszcze przez 1 dzień. Po tym czasie korzystanie z niej będzie niemożliwe. W przypadku braku rezygnacji z subskrypcji miesięczna opłata za korzystanie z usługi będzie nadal regularnie naliczana. Aby uniknąć opłat, należy zrezygnować z subskrypcji. Można to zrobić w dowolnym momencie na stronie subskrypcji użytkownika.</p>",
  "tos.not_now_text_germany": "<p>Zaktualizowaliśmy <a href=\"{0}\">Warunki korzystania ze Spotify</a> oraz naszą <a href=\"{1}\">Politykę prywatności</a>. Twoja zgoda oznacza, że Twoja umowa ze Spotify GmbH zostanie przejęta przez Spotify AB z siedzibą pod adresem ul. Birger Jarlsgatan 61, 113 56 Sztokholm, Szwecja.</p><p>Możesz dalej korzystać ze Spotify na podstawie bieżącej umowy do {2}. Po tym czasie zaakceptowanie nowych Warunków korzystania ze Spotify i Polityki prywatności będzie konieczne w celu dalszego korzystania z serwisu. Klikając przycisk „Akceptuję”:</p><p>a) wyrażasz zgodę na przeniesienie Twojej umowy ze Spotify GmbH do Spotify AB,<br />b) akceptujesz zaktualizowane Warunki korzystania ze Spotify,<br />c) wyrażasz zgodę na przechowywanie, przetwarzanie i wykorzystywanie danych osobowych zgodnie z zasadami określonymi w Rozdziale 4, 5 i 7 Polityki prywatności.</p>",
  "tos.not_now_text2_germany": "<p>Możesz nadal korzystać z serwisu Spotify do {0} bez konieczności akceptowania uaktualnionych Warunków korzystania i Polityki prywatności. Po tym czasie zaakceptowanie nowych zasad będzie konieczne w celu dalszego korzystania z serwisu Spotify. Jeśli jesteś użytkownikiem Premium, opłata miesięczna za korzystanie z serwisu będzie nadal naliczana cyklicznie, dopóki nie zrezygnujesz z subskrypcji. Jeśli nie chcesz dalej ponosić kosztów korzystania z serwisu Spotify, zrezygnuj z subskrypcji w dowolnym momencie. Możesz to zrobić na stronie subskrypcji.</p>",
  "tos.not_now_expired_text_germany": "<p>Zaktualizowaliśmy <a href=\"{0}\">Warunki korzystania ze Spotify</a> oraz naszą <a href=\"{1}\">Politykę prywatności</a>.</p><p>Twoja zgoda oznacza, że Twoja umowa ze Spotify GmbH zostanie przejęta przez Spotify AB z siedzibą pod adresem ul. Birger Jarlsgatan 61, 113 56 Sztokholm, Szwecja.</p><p>Aby dalej korzystać z serwisu Spotify, zaakceptuj nowe Warunki korzystania ze Spotify i Politykę prywatności. Klikając przycisk „Akceptuję”:</p><p>a) wyrażasz zgodę na przeniesienie Twojej umowy ze Spotify GmbH do Spotify AB,<br />b) akceptujesz aktualne Warunki korzystania ze Spotify,<br/>c) wyrażasz zgodę na przechowywanie, przetwarzanie i wykorzystywanie danych osobowych zgodnie z zasadami określonymi w Rozdziale 4, 5 i 7 Polityki prywatności.</p>",
  "tos.back_button_label": "Powrót",
  "tos.ok_button_label": "OK",
  "tos.agree_button_label": "Akceptuj",
  "tos.cancel_button_label": "Zrezygnuj",
  "tos.not_now_button_label": "Nie teraz",
  "licenses.modal_title": "Licencje na oprogramowanie stron trzecich",
  "licenses.close_button_label": "Zakończ",
  "feedback.beta_title": "Wersja beta",
  "feedback.beta_text": "Lubisz coś lub nie znosisz? Poinformuj nas o tym.",
  "market.ad": "Andora",
  "market.ar": "Argentyna",
  "market.at": "Austria",
  "market.au": "Australia",
  "market.be": "Belgia",
  "market.bg": "Bułgaria",
  "market.bo": "Boliwia",
  "market.br": "Brazylia",
  "market.ca": "Kanada",
  "market.ch": "Szwajcaria",
  "market.cl": "Chile",
  "market.co": "Kolumbia",
  "market.cr": "Kostaryka",
  "market.cy": "Cypr",
  "market.cz": "Czechy",
  "market.de": "Niemcy",
  "market.dk": "Dania",
  "market.do": "Dominikana",
  "market.ec": "Ekwador",
  "market.ee": "Estonia",
  "market.es": "Hiszpania",
  "market.fi": "Finlandia",
  "market.fr": "Francja",
  "market.gr": "Grecja",
  "market.gt": "Gwatemala",
  "market.hk": "Hongkong",
  "market.hn": "Honduras",
  "market.hu": "Węgry",
  "market.ie": "Irlandia",
  "market.is": "Islandia",
  "market.it": "Włochy",
  "market.jp": "Japonia",
  "market.li": "Liechtenstein",
  "market.lt": "Litwa",
  "market.lu": "Luksemburg",
  "market.lv": "Łotwa",
  "market.mc": "Monako",
  "market.mt": "Malta",
  "market.mx": "Meksyk",
  "market.my": "Malezja",
  "market.ni": "Nikaragua",
  "market.nl": "Holandia",
  "market.no": "Norwegia",
  "market.nz": "Nowa Zelandia",
  "market.pa": "Panama",
  "market.pe": "Peru",
  "market.ph": "Filipiny",
  "market.pl": "Polska",
  "market.pt": "Portugalia",
  "market.py": "Paragwaj",
  "market.se": "Szwecja",
  "market.sg": "Singapur",
  "market.sk": "Słowacja",
  "market.sv": "Salwador",
  "market.tr": "Turcja",
  "market.tw": "Tajwan",
  "market.uk": "Wielka Brytania",
  "market.us": "Stany Zjednoczone",
  "market.uy": "Urugwaj",
  "market.za": "Republika Południowej Afryki",
  "sTitle": "Podziel się swoją opinią i pomóż nam tworzyć największy na świecie serwis muzyczny!",
  "sQ1Question": "Jakie jest prawdopodobieństwo, że polecisz Spotify znajomym?",
  "sQ1Negative": "Nie polecę",
  "sQ1Positive": "Oczywiście, że polecę",
  "sQ2Question": "Jak uzasadnisz swoją decyzję?",
  "sQ3Question": "Jak oceniasz swój poziom zadowolenia z serwisu Spotify?",
  "sQ3Negative": "Serwis jest bardzo niezadowalający",
  "sQ3Positive": "Serwis jest wysoce zadowalający",
  "sSubmit": "Prześlij ankietę",
  "sThanks": "Dziękujemy za pomoc i poświęcony czas.",
  "sTeam": "Zespół Spotify",
  "sClose": "Zakończ",
  "cls.highlight": "Wstrzymano subskrypcję Premium",
  "cls.title": "Twoja ostatnia płatność nie dotarła.",
  "cls.desc": "Przedłuż subskrypcję Premium — po prostu wybierz nową metodę płatności. To zajmie tylko chwilę.",
  "cls.updatePayment": "Uaktualnij informacje o płatności",
  "cls.cancelSubscription": "Możesz także przejść na wersję darmową Spotify,<br> <a class=\"cancel-sub\" href=\"#cancel\">rezygnując z subskrypcji Premium</a>.",
  "capping.upsell-title": "Osiągnięto limit bezpłatnego słuchania muzyki.",
  "capping.upsell-message": "Co miesiąc możesz słuchać bezpłatnie muzyki przez 15 godzin.<br />Przejdź na wersję Premium, aby słuchać muzyki bez ograniczeń i bez reklam.",
  "capping.upsell-button-label": "Przejdź na wersję Premium",
  "capping.defaultRefillMessage": "Okres bezpłatnego słuchania zostanie niedługo przedłużony.",
  "capping.refillMessage": "Okres bezpłatnego słuchania zostanie przedłużony w ciągu następnych {0} dni.",
  "capping.welcome-title": "Witamy w Spotify.",
  "capping.welcome-message": "Korzystaj z 15 godzin darmowego słuchania w każdym miesiącu.<br> <a data-action={0}>Przejdź na wersję Premium,</a>  aby słuchać bez ograniczeń i reklam.",
  "capping.welcome-message-button-label": "Rozpocznij",
  "yourArtistsTooltipTitle": "Zarządzaj swoimi wykonawcami",
  "yourArtistsTooltipText": "Teraz możesz z łatwością edytować zdjęcie profilowe wykonawcy w Spotify.",
  "yourArtists": "Twoi wykonawcy"
};
},{}],16:[function(require,module,exports){
module.exports = {
  "browse.app_name": "Navegar",
  "latest-releases.app_name": "Últimos lançamentos",
  "discover.app_name": "Descobrir",
  "activity.app_name": "Atividade",
  "radio.app_name": "Rádio",
  "settings.app_name": "Preferências",
  "messages.app_name": "Mensagens",
  "profile.app_name": "Perfil",
  "notifications_center.app_name": "Notificações",
  "concerts.app_name": "Ao vivo",
  "profile.private_session": "Sessão privada",
  "profile.upgrade": "Fazer upgrade",
  "profile.upgrade_account": "Fazer upgrade de sua conta",
  "profile.upgrade_tooltip": "Fazer upgrade para o Premium",
  "profile.account": "Conta",
  "profile.logout": "Sair",
  "profile.enabled": "Ativado",
  "profile.menu_label": "Menu",
  "profile.switch": "Alternar usuário",
  "profile.new_user": "Alternar para novo usuário",
  "your_music.app_name": "Suas Músicas",
  "your_music.songs": "Músicas",
  "your_music.artists": "Artistas",
  "your_music.albums": "Álbuns",
  "your_music.stations": "Estações",
  "your_music.local_files": "Arquivos locais",
  "sidebar.title_main": "Principal",
  "sidebar.title_playlists": "Playlists",
  "new_playlist.input_placeholder": "Nova playlist",
  "new_playlist.button": "Nova playlist",
  "accessibilitylinks.skip_to_content_label": "Pular para o conteúdo principal",
  "accessibilitylinks.skip_to_player_label": "Pular para os controles do player",
  "playlist.by": "de {0}",
  "playlist.loading": "Carregando...",
  "playlist.newfolder": "Nova pasta",
  "playlist.delete_message": "Quer mesmo apagar esta playlist?",
  "playlist.unfollow_message": "Quer mesmo deixar de seguir esta playlist?",
  "playlistfolder.delete_message": "Você quer mesmo apagar esta pasta e todas as playlists que ela contém?",
  "playlist.delete_confirm": "Apagar",
  "playlist.unfollow_confirm": "Deixar de seguir",
  "playlist.delete_cancel": "Cancelar",
  "playlist.duplicates_dialog_title": "Músicas duplicadas",
  "playlist.duplicates_dialog_title_single": "Música duplicada",
  "playlist.duplicates_dialog_body": "Algumas dessas músicas já estão na sua playlist.",
  "playlist.duplicates_dialog_body_single": "Esta música já está na sua playlist.",
  "playlist.duplicates_dialog_button_add": "Adicionar todas",
  "playlist.duplicates_dialog_button_add_single": "Adicionar assim mesmo",
  "playlist.duplicates_dialog_button_skip_duplicates": "Pular duplicadas",
  "playlist.duplicates_dialog_button_skip_single": "Pular duplicada",
  "playlist.annotate_form.new_playlist_name": "Nova playlist",
  "playlist.annotate_form.create_title": "Criar playlist",
  "playlist.annotate_form.create": "Criar",
  "playlist.annotate_form.cancel": "Cancelar",
  "playlist.annotate_form.edit_title": "Editar playlist",
  "playlist.annotate_form.save": "Salvar",
  "playlist.annotate_form.name_field_label": "Nome",
  "playlist.annotate_form.name_field_placeholder": "Nome da playlist",
  "playlist.annotate_form.image_field_label": "Imagem",
  "playlist.annotate_form.image_pick_button_label": "Escolher imagem",
  "playlist.annotate_form.image_replace_button_label": "Substituir imagem",
  "playlist.annotate_form.image_remove_button_label": "Remover imagem",
  "playlist.annotate_form.image_file_size_exceeded": "Imagem muito grande; máximo: 4 MB.",
  "playlist.annotate_form.image_file_upload_failed": "Falha ao carregar a imagem. Tente de novo.",
  "playlist.annotate_form.annotate_failed": "Falha ao atualizar a descrição e a imagem. Tente de novo.",
  "playlist.annotate_form.close-error-bar": "Ocultar",
  "playlist.annotate_form.description_field_label": "Descrição",
  "playlist.annotate_form.description_field_placeholder": "Faça uma descrição sugestiva da sua playlist.",
  "playlist.annotate_form.permission_message": "Ao continuar, você autoriza o Spotify a acessar a imagem de que você fizer upload. Certifique-se de que você tem o direito de fazer upload da imagem. Só vamos usar sua imagem como arte da capa de uma playlist.",
  "playlist.annotate_form.insert_link_button_label": "Inserir link",
  "playlist.annotate_form.insert_link.link_field_label": "Vincular a",
  "playlist.annotate_form.insert_link.change_button_label": "Alterar",
  "playlist.annotate_form.insert_link.remove_button_label": "Remover",
  "playlist.annotate_form.insert_link.done_button_label": "Pronto",
  "playlist.annotate_form.drop_to_set_image_label": "Solte para definir a imagem",
  "playlist.annotate_form.drop_not_allowed_label": "Formato incompatível",
  "playlist.annotate_form.error.file_not_valid_jpg": "O arquivo não é realmente um arquivo JPG válido, apesar do nome.",
  "playlist.annotate_form.error.name_required": "Você precisa dar um nome à sua playlist.",
  "playlist.annotate_form.error.selection_required_to_insert_link": "Você precisa selecionar o texto que quer incluir em um link.",
  "playlist.annotate_form.error.html_not_allowed": "Parece que você está tentando usar HTML, mas isso não é possível.",
  "playlist.annotate_form.error.submit": "Não foi possível salvar as mudanças na playlist. Tente de novo.",
  "playlist.annotate_form.error.image_too_small": "Esta imagem é muito pequena. Ela deve ter no mínimo {0}x{1}.",
  "playlist.annotate_form.warning.client_offline": "Sem conexão com a Internet. As mudanças na descrição e na imagem não serão salvas.",
  "playlist.annotate_form.warning.no_line_breaks_in_description": "Desculpe, mas a descrição não permite quebras de linha.",
  "playlist.annotate_form.warning.unsaved_changes": "Você não quer salvar suas alterações?",
  "navigation.label": "Navegação",
  "navigation.back_button_label": "Voltar",
  "navigation.forward_button_label": "Avançar",
  "search.input_placeholder": "Buscar",
  "player.label": "Controles do player",
  "player.shuffle_mode_label": "Ordem aleatória",
  "player.repeat_mode_label": "Repetir",
  "player.queue": "Lista de reprodução",
  "player.volume_button_label": "Volume",
  "player.spotify_connect": "Spotify Connect",
  "player.connect_button_label": "Conectar a um dispositivo",
  "player.lyrics_label": "Letra",
  "player.play_button_label": "Play",
  "player.pause_button_label": "Pause",
  "player.previous_button_label": "Anterior",
  "player.next_button_label": "Próxima",
  "player.offline_label": "Offline",
  "player.thumb_up_label": "Curtir",
  "player.thumb_down_label": "Deixar de curtir",
  "playererror.default": "Houve um problema ao tentar tocar a música selecionada",
  "playererror.track_not_available": "Esta música não está disponível",
  "nowplaying.label": "Tocando agora",
  "nowplaying.go_to_context": "Vá para o que está tocando",
  "nowplaying.save_your_music": "Salvar em Suas músicas",
  "nowplaying.remove_your_music": "Remover de Suas músicas",
  "nowplaying.playing_suggested_track": "Tocando agora a música sugerida",
  "connect.connect_text": "Conectar a um dispositivo",
  "connect.device_connecting": "Conectando…",
  "connect.device_incompatible": "Incompatível",
  "connect.device_premium_only": "Apenas para usuários Premium",
  "connect.device_sleeping": "Dispositivo em suspensão",
  "connect.device_tech_cast": "Google Cast",
  "connect.device_tech_connect": "Spotify Connect",
  "connect.device_this_computer": "Este computador",
  "connect.device_unavailable_for_playback": "Indisponível para tocar em",
  "connect.device_unknown": "Dispositivo desconhecido",
  "connect.device_unsupported_uri": "Não é possível reproduzir agora",
  "connect.devices_available": "Dispositivos disponíveis",
  "connect.dismiss": "Descartar",
  "connect.help1": "Com o recurso Connect, você pode tocar e controlar o Spotify nos seus dispositivos.",
  "connect.help2": "Abra o Spotify em outro dispositivo e, num passe de mágica, ele vai aparecer aqui.",
  "connect.help_hint": "O que é o recurso Connect?",
  "connect.offline": "Não disponível",
  "connect.offline_reason_computer": "O Spotify não está ativo neste dispositivo.",
  "connect.offline_reason_generic": "O Spotify não está ativo neste dispositivo.",
  "connect.offline_reason_phone": "O telefone está bloqueado ou o Spotify não está em primeiro plano.",
  "connect.offline_reason_gameconsole": "Edite as configurações do aplicativo do Spotify no PlayStation para permitir que o PlayStation seja ligado a partir do modo de repouso.",
  "connect.offline_text1": "Você precisa ficar online para usar este recurso.",
  "connect.offline_title": "Você está offline!",
  "connect.playingon": "Ouvindo no",
  "connect.popup_title": "Dispositivos",
  "connect.remoteplayback": "Você está ouvindo em {0}",
  "connect.show_more": "Mostrar mais",
  "connect.upgrade": "Fazer upgrade",
  "connect.upsell": "O Connect é um recurso do Premium que permite tocar e controlar o Spotify nos seus dispositivos.",
  "contextmenu.new-playlist": "Nova playlist",
  "contextmenu.add-to-playlist": "Adicionar à playlist",
  "contextmenu.owner-playlist": "de {0}",
  "contextmenu.copy-uri": "Copiar URI do Spotify",
  "contextmenu.copy-artist-url": "Copiar link do artista",
  "contextmenu.copy-album-url": "Copiar link do álbum",
  "contextmenu.copy-track-url": "Copiar link da música",
  "contextmenu.copy-playlist-url": "Copiar link da playlist",
  "contextmenu.copy-profile-url": "Copiar link do perfil",
  "contextmenu.copy-station-url": "Copiar link da estação",
  "contextmenu.copy-chart-url": "Copiar link da parada",
  "contextmenu.copy-url": "Copiar link",
  "contextmenu.copy-embed": "Copiar código para incorporar",
  "contextmenu.collaborative": "Playlist colaborativa",
  "contextmenu.save": "Salvar em Suas músicas",
  "contextmenu.remove": "Remover de Suas músicas",
  "contextmenu.delete-playlist": "Apagar",
  "contextmenu.follow": "Seguir",
  "contextmenu.unfollow": "Deixar de seguir",
  "contextmenu.publish": "Tornar pública",
  "contextmenu.unpublish": "Tornar secreta",
  "contextmenu.playlist.loading": "Carregando...",
  "contextmenu.play": "Play",
  "contextmenu.add-to-queue": "Adicionar à fila",
  "contextmenu.station": "Ir para Rádio",
  "contextmenu.station-album": "Ir para a rádio do álbum",
  "contextmenu.station-artist": "Ir para a rádio do artista",
  "contextmenu.station-playlist": "Ir para a rádio da playlist",
  "contextmenu.station-track": "Ir para a rádio da música",
  "contextmenu.station-chart": "Ir para a rádio da parada",
  "contextmenu.remove-from-playlist": "Remover desta playlist",
  "contextmenu.remove-from-queue": "Tirar da fila",
  "contextmenu.rename-folder": "Renomear",
  "contextmenu.rename-playlist": "Renomear",
  "contextmenu.edit-playlist": "Editar detalhes",
  "contextmenu.report-playlist": "Denunciar",
  "contextmenu.report-asset": "Denunciar",
  "contextmenu.share": "Compartilhar...",
  "contextmenu.share-lyrics": "Compartilhar letra",
  "contextmenu.create-folder": "Criar pasta",
  "contextmenu.create-playlist": "Criar playlist",
  "contextmenu.open-localfile-folder": "Abrir pasta recipiente",
  "contextmenu.open-localfile-folder-mac": "Mostrar no localizador",
  "contextmenu.offline": "Disponível offline",
  "contextmenu.goto-artist": "Ir para artista",
  "contextmenu.goto-album": "Ir para álbum",
  "usermessage.default-message": "Ocorreu um erro",
  "usermessage.update-ready": "Olá. Temos agora uma nova versão do Spotify para você. <a href=\"#\" data-action=\"{0}\">Reinicie agora</a> para usá-la.",
  "usermessage.update-ready-simple": "Olá. Temos agora uma nova versão do Spotify para você. Reinicie agora para usá-la.",
  "usermessage.play-token-lost": "O Spotify foi pausado porque sua conta está sendo usada em outro lugar.",
  "usermessage.playback-paused-inactive": "Seu computador ficou inativo por muito tempo, pressione Play para continuar ouvindo! Para que a música não seja interrompida, assine o <a href=\"#\" data-action=\"{0}\">Spotify Premium</a>.",
  "usermessage.not-available-offline": "Sem conexão com a Internet. O Spotify vai tentar se reconectar automaticamente quando detectar uma conexão com a Internet (código de erro 4).",
  "usermessage.track-not-available-in-region": "No momento, esta música não está disponível em {0}. Se você tiver o arquivo no computador, é possível importá-lo.",
  "usermessage.track-not-available-in-region-generic": "No momento, esta música não está disponível em seu país. Se você tiver o arquivo no computador, é possível importá-lo.",
  "usermessage.track-not-available": "Esta música não está disponível. Se você tiver o arquivo no computador, é possível importá-lo.",
  "usermessage.track-not-available-forced-offline": "Desligue <a href=\"#\" data-action=\"goOnline\">o modo offline</a> e tente novamente.",
  "usermessage.track-exclusive-premium": "Esta música é exclusiva para usuários do <a href=\"#\" data-action=\"{0}\">Spotify Premium</a>.",
  "usermessage.track-banned-by-artist": "O artista/selo não quis disponibilizar esta música. Se você tiver o arquivo no computador, é possível importá-lo.",
  "usermessage.local-track-no-file": "Esta música foi adicionada como um arquivo local. Se você tiver o arquivo no computador, é possível importá-lo.",
  "usermessage.local-track-file-not-found": "Esta música não pode ser tocada porque não foi possível encontrar o arquivo. Importe-o novamente.",
  "usermessage.local-track-bad-format": "O arquivo está em um formato desconhecido. Clique <a href=\"#\" data-action=\"{0}\">aqui</a> para saber mais.",
  "usermessage.capping-reached": "Você passou do seu limite de tempo de {0} horas. <a href=\"#\" data-action=\"{1}\">Faça upgrade para o Spotify Premium</a> para ouvir sem restrições.",
  "usermessage.local-track-drm-protected": "Esta música não pode ser tocada porque o arquivo é protegido pela gestão de direitos digitais (GDD).",
  "usermessage.offline-disk-cache": "Falha no download de músicas offline. Será que o disco está cheio?",
  "usermessage.offline-sync-expired": "As músicas offline expiraram. Você precisa entrar no Spotify para reativá-las.",
  "usermessage.offline-sync-failed": "Falha no download de algumas músicas offline.",
  "usermessage.offline-too-many-tracks": "Há músicas demais selecionadas para o modo offline.",
  "usermessage.offline-license-server-error": "Ocorreu um problema com o servidor do Spotify.",
  "usermessage.offline-license-lost": "O acesso offline a este computador/dispositivo foi removido.",
  "usermessage.offline-not-allowed": "O modo offline é um recurso exclusivo do <a href=\"#\" data-action=\"{0}\">Spotify Premium</a> .",
  "usermessage.language-changed": "Você precisa <a href=\"#\" data-action=\"{0}\">reiniciar o Spotify</a> para a mudança valer",
  "usermessage.proxysettings-changed": "Você precisa <a href=\"#\" data-action=\"{0}\">reiniciar o Spotify</a> para a mudança valer",
  "usermessage.language-changed-simple": "Você precisa reiniciar o Spotify para a mudança valer",
  "usermessage.proxysettings-changed-simple": "Você precisa reiniciar o Spotify para a mudança valer",
  "usermessage.cache-changed": "Você precisa <a href=\"#\" data-action=\"{0}\">reiniciar o Spotify</a> para a mudança valer",
  "usermessage.cache-changed-simple": "Você precisa reiniciar o Spotify para a mudança valer",
  "usermessage.feature-changed": "Você precisa <a href=\"#\" data-action=\"{0}\">reiniciar o Spotify</a> para a mudança valer",
  "usermessage.first-autostart": "O Spotify foi aberto automaticamente, mas minimizado. Se quiser, você pode <a href=\"#\" data-action=\"{0}\">abrir o Spotify automaticamente sem minimizá-lo</a> ou <a href=\"#\" data-action=\"{1}\">não abrir o Spotify ao ligar o computador</a>.",
  "usermessage.cant-play-track": "Não é possível tocar a música atual.",
  "usermessage.cant-skip-ads": "A música selecionada será tocada depois da propaganda",
  "usermessage.cant-offline-playlists": "O modo offline é um recurso exclusivo do Premium. <a href=\"#\" data-action=\"{0}\">Assinar Premium</a>.",
  "usermessage.cant-set-high-quality-streaming": "Esse é um recurso exclusivo do Premium. <a href=\"#\" data-action=\"{0}\">Assinar Premium</a>.",
  "usermessage.payment-state-creditcard-funds": "Não conseguimos renovar sua assinatura por causa de um problema com o pagamento. Confira se você tem saldo na sua conta ou <a href=\"#\" data-action=\"{0}\">atualize seus dados de pagamento</a>.",
  "usermessage.payment-state-creditcard-refused": "Não conseguimos renovar sua assinatura por causa de um problema com o pagamento. Para manter sua assinatura, <a href=\"#\" data-action=\"{0}\">atualize seus dados de pagamento</a>.",
  "usermessage.payment-state-paypal-refused": "Não conseguimos renovar sua assinatura por causa de um problema com o pagamento. Para manter sua assinatura, <a href=\"#\" data-action=\"{0}\">atualize seus dados de pagamento</a>.",
  "usermessage.payment-state-creditcard-expiry": "O cartão que você está usando para o pagamento vai expirar em alguns dias. Para manter sua assinatura, <a href=\"#\" data-action=\"{0}\">atualize seus dados de pagamento</a>.",
  "usermessage.payment-state-prepaid-expiry": "Sua assinatura pré-paga vai expirar. Não se preocupe, você pode <a href=\"#\" data-action=\"{0}\">assinar o Premium aqui</a>.",
  "usermessage.payment-state-churn-payment": "Uma pena, não conseguimos receber seu pagamento, por isso tivemos de cancelar sua assinatura. Mas não se preocupe, você pode <a href=\"#\" data-action=\"{0}\">renovar sua assinatura aqui</a>.",
  "usermessage.payment-state-churn-partner": "Sua assinatura de um de nossos parceiros acabou de terminar. Por isso, você está usando o Spotify Free. Mas não se preocupe, você pode <a href=\"#\" data-action=\"{0}\">voltar para o Premium aqui</a>.",
  "usermessage.opt-in-trial": "Tomara que você tenha curtido o teste grátis! Para não ficar sem o Premium quando ele terminar, <a href=\"#\" data-action=\"{0}\">assine agora mesmo</a>.",
  "usermessage.opt-in-trial-expired": "Seu teste grátis acabou, então você está usando o Spotify Free. Mas não se preocupe, você pode <a href=\"#\" data-action=\"{0}\">voltar para o Premium aqui</a>.",
  "usermessage.hardware-acceleration-changed": "Você precisa <a href=\"#\" data-action=\"{0}\">reiniciar o Spotify</a> para a mudança valer",
  "usermessage.hardware-acceleration-changed-simple": "Você precisa reiniciar o Spotify para a mudança valer",
  "usermessage.some-local-tracks-not-saved": "Algumas músicas selecionadas não foram salvas em Suas músicas. A área Suas músicas não é compatível com arquivos locais.",
  "usermessage.illegal-playlist-name-entered": "O nome da playlist inserido é inválido.",
  "usermessage.playlist-save-failed-unknown": "Não foi possível salvar a playlist por causa de um erro desconhecido.",
  "usermessage.social-error-permissions": "Clique <a href=\"#\" data-action=\"{0}\">aqui</a> para permitir o compartilhamento de suas atividades musicais no Facebook.",
  "usermessage.shuffle-unplayable-track": "<a href=\"#\" data-action=\"{0}\">Faça upgrade para o Premium</a> para tocar a música que quiser, quando quiser.",
  "usermessage.shuffle-ran-out-of-skips": "Você não pode mais pular (durante esta hora). <a href=\"#\" data-action=\"{0}\">Faça upgrade para o Premium</a> para pular quantas músicas quiser.",
  "usermessage.playlist-limit-exceeded": "Você preencheu esta playlist até o limite. Incrível. Comece uma nova para continuar sua coleção.",
  "usermessage.collection-limit-exceeded": "Sua coleção é magnífica. Não há mais espaço em Suas Músicas. Para salvar mais, você terá de remover algumas músicas.",
  "usermessage.deprecating-os-version": "Atenção! A próxima versão do nosso aplicativo não será compatível com o seu sistema operativo. Clique <a href=\"#\" data-action=\"{0}\">aqui</a> para saber mais.",
  "usermessage.image-upload-propagation": "Sucesso! (As imagens podem levar até 24 horas para se propagar)",
  "usermessage.approaching-capping-limit": "Falta menos de 1 hora para o seu período de música grátis acabar. Aproveite 15 horas de música gratuita por mês ou <a href=\"#\" data-action=\"{0}\">faça upgrade para o Premium</a> para ouvir música ilimitada. <a href=\"#\" data-action=\"{1}\">Saiba mais</a>.",
  "usermessage.half-capping-limit-passed": "Você já usou metade do seu limite de tempo mensal. Aproveite 15 horas de música gratuita por mês ou <a href=\"#\" data-action=\"{0}\">faça upgrade para o Premium</a> para ouvir música ilimitada. <a href=\"#\" data-action=\"{1}\">Saiba mais</a>.",
  "usermessage.video-georestricted": "Não é possível reproduzir este vídeo na sua localização atual.",
  "usermessage.video-unsupported-client-version": "Faça upgrade do Spotify para reproduzir este vídeo.",
  "usermessage.video-unsupported-platform-version": "Não é possível reproduzir este vídeo na versão do seu sistema operacional.",
  "usermessage.video-country-restricted": "Não é possível reproduzir este vídeo na sua localização atual.",
  "usermessage.video-unavailable": "Este vídeo não está disponível. Quer tentar outro?",
  "usermessage.video-catalogue-restricted": "Desculpe, não é possível reproduzir este vídeo.",
  "usermessage.video-playback-error": "Desculpe, não é possível reproduzir este vídeo.",
  "about.title_label": "Sobre o Spotify",
  "about.close_button_label": "Fechar",
  "offline-progress-msg": "Sincronizando {0} de {1} músicas offline",
  "tos.updated_terms": "Condições atualizadas",
  "tos.modal_title": "Termos e condições de uso do Spotify",
  "tos.tos_text": "<p>Nós alteramos nossos <a href=\"{0}\">Termos e condições de uso</a> e nossa <a href=\"{1}\">Política de privacidade</a>. </p><p>Ao continuar usando o Spotify, você aceita essas novas condições. Por isso, dedique um tempo à sua leitura e compreensão.</p>",
  "tos.not_now_tos_text": "<p>Nós alteramos nossos <a href=\"{0}\">Termos e condições de uso </a> e  <a href=\"{1}\">nossa Política de privacidade</a>.</p><p>Ao clicar em &quot;Aceitar&quot;, você concorda com essas atualizações (e o processamento de seus dados conforme descrito). Por isso, dedique um tempo à sua leitura e compreensão. </p>",
  "tos.tos_text2": "<p>Se você não quer mais usar o Spotify, pode cancelar sua assinatura acessando sua página de assinatura do Spotify.</p>",
  "tos.not_now_text": "<p>Você pode continuar usando o Spotify por {0} dias sem aceitar os Termos e condições e a Política de privacidade atualizados. Nesse momento, você deverá aceitar as novas condições para continuar usando o Spotify. A não ser que você cancele sua assinatura, continuará sendo cobrado mensalmente dentro do ciclo de cobrança regular. Se não quiser mais ser cobrado pelo Spotify, poderá cancelar sua assinatura a qualquer momento acessando sua página de assinatura do Spotify.</p>",
  "tos.not_now_last_day_text": "<p>Você pode continuar usando o Spotify por 1 dia sem aceitar os Termos e condições e a Política de privacidade atualizados. Se até lá você não aceitar as novas condições, não poderá mais usar o Spotify. A não ser que você cancele sua assinatura, continuará sendo cobrado mensalmente dentro do ciclo de cobrança regular. Se não quiser mais ser cobrado pelo Spotify, poderá cancelar sua assinatura a qualquer momento acessando sua página de assinatura do Spotify.</p>",
  "tos.not_now_text_germany": "<p>Nós alteramos nossos <a href=\"{0}\">Termos e condições de uso</a> e nossa <a href=\"{1}\">Política de privacidade</a>. Observe que, com o seu consentimento, a Spotify GmbH pretende transferir seu contrato para a Spotify AB, Birger Jarlsgatan 61, 113 56 Estocolmo, Suécia.</p><p>Você pode continuar usando o serviço do Spotify sob o contrato existente até {2}. Depois disso, para continuar usando o serviço do Spotify, você deverá aceitar os novos Termos e condições e a nova Política de privacidade. Ao clicar em &quot;Aceitar&quot;, você concorda com</p><p>a) a transferência de seu contrato da Spotify GmbH para a Spotify AB,<br />b) as atualizações dos Termos e condições de uso e<br />c) a coleta, processamento e uso de seus dados pessoais conforme descrito nas Seções 4, 5 e 7 da Política de privacidade.</p>",
  "tos.not_now_text2_germany": "<p>Você pode continuar usando o Spotify até {0} sem aceitar os novos Termos e condições e a nova Política de privacidade. Nessa data, será necessário aceitar as novas condições para continuar usando o Spotify. Se você é usuário Premium, continuará sendo cobrado mensalmente na data do ciclo de cobrança regular, a menos que cancele sua assinatura. Se não quiser mais ser cobrado pelo Spotify, cancele sua assinatura a qualquer momento na sua página de assinatura do Spotify.</p>",
  "tos.not_now_expired_text_germany": "<p>Nós alteramos nossos <a href=\"{0}\">Termos e condições de uso</a> e nossa <a href=\"{1}\">Política de privacidade</a>.</p><p>Observe que, com o seu consentimento, a Spotify GmbH pretende transferir seu contrato para a Spotify AB, Birger Jarlsgatan 61, 113 56 Estocolmo, Suécia.</p><p>Para continuar usando o serviço do Spotify, você deverá aceitar os novos Termos e condições e a nova Política de privacidade. Ao clicar em &quot;Aceitar&quot;, você concorda com</p><p>a) a transferência de seu contrato da Spotify GmbH para a Spotify AB,<br />b) as atualizações dos Termos e condições de uso e<br />c) a coleta, processamento e uso de seus dados pessoais conforme descrito nas Seções 4, 5 e 7 da Política de privacidade.</p>",
  "tos.back_button_label": "Voltar",
  "tos.ok_button_label": "OK",
  "tos.agree_button_label": "Aceitar",
  "tos.cancel_button_label": "Recusar",
  "tos.not_now_button_label": "Agora não",
  "licenses.modal_title": "Licenças de terceiros",
  "licenses.close_button_label": "Fechar",
  "feedback.beta_title": "Versão beta",
  "feedback.beta_text": "O que você ama ou odeia? Conta pra gente!",
  "market.ad": "Andorra",
  "market.ar": "Argentina",
  "market.at": "Áustria",
  "market.au": "Austrália",
  "market.be": "Bélgica",
  "market.bg": "Bulgária",
  "market.bo": "Bolívia",
  "market.br": "Brasil",
  "market.ca": "Canadá",
  "market.ch": "Suíça",
  "market.cl": "Chile",
  "market.co": "Colômbia",
  "market.cr": "Costa Rica",
  "market.cy": "Chipre",
  "market.cz": "República Tcheca",
  "market.de": "Alemanha",
  "market.dk": "Dinamarca",
  "market.do": "República Dominicana",
  "market.ec": "Equador",
  "market.ee": "Estônia",
  "market.es": "Espanha",
  "market.fi": "Finlândia",
  "market.fr": "França",
  "market.gr": "Grécia",
  "market.gt": "Guatemala",
  "market.hk": "Hong Kong",
  "market.hn": "Honduras",
  "market.hu": "Hungria",
  "market.ie": "Irlanda",
  "market.is": "Islândia",
  "market.it": "Itália",
  "market.jp": "Japão",
  "market.li": "Liechtenstein",
  "market.lt": "Lituânia",
  "market.lu": "Luxemburgo",
  "market.lv": "Letônia",
  "market.mc": "Mônaco",
  "market.mt": "Malta",
  "market.mx": "México",
  "market.my": "Malásia",
  "market.ni": "Nicarágua",
  "market.nl": "Países Baixos",
  "market.no": "Noruega",
  "market.nz": "Nova Zelândia",
  "market.pa": "Panamá",
  "market.pe": "Peru",
  "market.ph": "Filipinas",
  "market.pl": "Polônia",
  "market.pt": "Portugal",
  "market.py": "Paraguai",
  "market.se": "Suécia",
  "market.sg": "Cingapura",
  "market.sk": "Eslováquia",
  "market.sv": "El Salvador",
  "market.tr": "Turquia",
  "market.tw": "Taiwan",
  "market.uk": "Reino Unido",
  "market.us": "Estados Unidos",
  "market.uy": "Uruguai",
  "market.za": "África do Sul",
  "sTitle": "Compartilhe o que você pensa e nos ajude a criar o maior serviço de música do mundo!",
  "sQ1Question": "Qual é a probabilidade de você recomendar o Spotify para um amigo ou colega?",
  "sQ1Negative": "Nada provável",
  "sQ1Positive": "Extremamente provável",
  "sQ2Question": "Por que você acha isso?",
  "sQ3Question": "No geral, qual é seu nível de satisfação com o Spotify?",
  "sQ3Negative": "Muito insatisfeito",
  "sQ3Positive": "Muito satisfeito",
  "sSubmit": "Enviar pesquisa",
  "sThanks": "Muito obrigado por sua ajuda. Nós apreciamos o tempo que você gastou.",
  "sTeam": "A equipe Spotify",
  "sClose": "Fechar",
  "cls.highlight": "Premium pausado",
  "cls.title": "Seu último pagamento não foi processado.",
  "cls.desc": "Para continuar ouvindo com o Premium, adicione uma nova forma de pagamento. Leva apenas alguns instantes.",
  "cls.updatePayment": "Atualizar pagamento",
  "cls.cancelSubscription": "Você também pode voltar para o Free<br> <a class=\"cancel-sub\" href=\"#cancel\">cancelando a assinatura Premium.</a>",
  "capping.upsell-title": "Você chegou ao seu limite de reproduções gratuitas.",
  "capping.upsell-message": "Você tem 15 horas de música gratuita por mês.<br />Faça upgrade para o Premium para ouvir música ilimitada sem anúncios.",
  "capping.upsell-button-label": "Fazer upgrade para o Premium",
  "capping.defaultRefillMessage": "Seu período de música gratuita vai recomeçar em breve.",
  "capping.refillMessage": "Seu período de música gratuita vai recomeçar nos próximos {0} dias.",
  "capping.welcome-title": "Bem-vindo ao Spotify.",
  "capping.welcome-message": "Aproveite 15 horas de música gratuita por mês.<br> <a data-action={0}>Faça upgrade para o Premium</a> para ouvir música ilimitada sem anúncios.",
  "capping.welcome-message-button-label": "Começar",
  "yourArtistsTooltipTitle": "Gerencie seus artistas",
  "yourArtistsTooltipText": "Agora ficou fácil editar sua imagem de perfil de artista no Spotify.",
  "yourArtists": "Seus artistas"
};
},{}],17:[function(require,module,exports){
module.exports = {
  "browse.app_name": "Start",
  "latest-releases.app_name": "Senaste releaser",
  "discover.app_name": "Upptäck",
  "activity.app_name": "Aktivitet",
  "radio.app_name": "Radio",
  "settings.app_name": "Inställningar",
  "messages.app_name": "Meddelanden",
  "profile.app_name": "Profil",
  "notifications_center.app_name": "Notifieringar",
  "concerts.app_name": "Konserter",
  "profile.private_session": "Dölj aktivitet",
  "profile.upgrade": "Uppgradera",
  "profile.upgrade_account": "Uppgradera ditt konto",
  "profile.upgrade_tooltip": "Uppgradera till Premium",
  "profile.account": "Konto",
  "profile.logout": "Logga ut",
  "profile.enabled": "Aktiverat",
  "profile.menu_label": "Meny",
  "profile.switch": "Växla användare",
  "profile.new_user": "Växla till ny användare",
  "your_music.app_name": "Din Musik",
  "your_music.songs": "Låtar",
  "your_music.artists": "Artister",
  "your_music.albums": "Album",
  "your_music.stations": "Stationer",
  "your_music.local_files": "Lokala filer",
  "sidebar.title_main": "Huvudmeny",
  "sidebar.title_playlists": "Spellistor",
  "new_playlist.input_placeholder": "Ny spellista",
  "new_playlist.button": "Ny spellista",
  "accessibilitylinks.skip_to_content_label": "Hoppa till huvudinnehållet",
  "accessibilitylinks.skip_to_player_label": "Hoppa till spelarkontrollerna",
  "playlist.by": "av {0}",
  "playlist.loading": "Läser in …",
  "playlist.newfolder": "Ny mapp",
  "playlist.delete_message": "Vill du ta bort den här spellistan?",
  "playlist.unfollow_message": "Vill du sluta följa den här spellistan?",
  "playlistfolder.delete_message": "Vill du ta bort den här mappen och alla spellistor den innehåller?",
  "playlist.delete_confirm": "Ta bort",
  "playlist.unfollow_confirm": "Sluta följa",
  "playlist.delete_cancel": "Avbryt",
  "playlist.duplicates_dialog_title": "Dubblettlåtar",
  "playlist.duplicates_dialog_title_single": "Dubblettlåt",
  "playlist.duplicates_dialog_body": "Några av dessa låtar finns redan i din spellista.",
  "playlist.duplicates_dialog_body_single": "Det här låten finns redan i din spellista.",
  "playlist.duplicates_dialog_button_add": "Lägg till alla",
  "playlist.duplicates_dialog_button_add_single": "Lägg till ändå",
  "playlist.duplicates_dialog_button_skip_duplicates": "Hoppa över dubbletter",
  "playlist.duplicates_dialog_button_skip_single": "Hoppa över dubblett",
  "playlist.annotate_form.new_playlist_name": "Ny spellista",
  "playlist.annotate_form.create_title": "Skapa spellista",
  "playlist.annotate_form.create": "Skapa",
  "playlist.annotate_form.cancel": "Avbryt",
  "playlist.annotate_form.edit_title": "Redigera informationen om spellistan",
  "playlist.annotate_form.save": "Spara",
  "playlist.annotate_form.name_field_label": "Namn",
  "playlist.annotate_form.name_field_placeholder": "Spellistenamn",
  "playlist.annotate_form.image_field_label": "Bild",
  "playlist.annotate_form.image_pick_button_label": "Välj bild",
  "playlist.annotate_form.image_replace_button_label": "Byt ut bilden",
  "playlist.annotate_form.image_remove_button_label": "Ta bort bilden",
  "playlist.annotate_form.image_file_size_exceeded": "Bilden är för stor. Största tillåtna storlek: 4 MB.",
  "playlist.annotate_form.image_file_upload_failed": "Det gick inte att ladda upp bilden. Försök igen.",
  "playlist.annotate_form.annotate_failed": "Det gick inte att uppdatera beskrivningen och bilden. Försök igen.",
  "playlist.annotate_form.close-error-bar": "Dölj",
  "playlist.annotate_form.description_field_label": "Beskrivning",
  "playlist.annotate_form.description_field_placeholder": "Ge spellistan en passande beskrivning.",
  "playlist.annotate_form.permission_message": "Genom att fortsätta samtycker du till att Spotify får åtkomst till den bild du laddar upp. Kontrollera att du har rätt att ladda upp bilden. Vi kommer endast att använda din bild som albumomslag för en spellista.",
  "playlist.annotate_form.insert_link_button_label": "Infoga länk",
  "playlist.annotate_form.insert_link.link_field_label": "Länka till",
  "playlist.annotate_form.insert_link.change_button_label": "Ändra",
  "playlist.annotate_form.insert_link.remove_button_label": "Ta bort",
  "playlist.annotate_form.insert_link.done_button_label": "Klart",
  "playlist.annotate_form.drop_to_set_image_label": "Släpp för att använda bilden",
  "playlist.annotate_form.drop_not_allowed_label": "Formatet stöds inte",
  "playlist.annotate_form.error.file_not_valid_jpg": "Filen är inte en giltig JPG-fil, trots filnamnet.",
  "playlist.annotate_form.error.name_required": "Du måste ge spellistan ett namn.",
  "playlist.annotate_form.error.selection_required_to_insert_link": "Du måste markera texten som du vill göra till en länk.",
  "playlist.annotate_form.error.html_not_allowed": "Det verkar som att du försöker använda HTML, vilket inte är möjligt.",
  "playlist.annotate_form.error.submit": "Det gick inte att spara ändringarna av spellistan. Försök igen.",
  "playlist.annotate_form.error.image_too_small": "Bilden är för liten. Den måste vara minst {0} × {1}.",
  "playlist.annotate_form.warning.client_offline": "Ingen internetanslutning hittades. Ändringar av beskrivningen och bilden sparas inte.",
  "playlist.annotate_form.warning.no_line_breaks_in_description": "Det får inte finnas radbrytningar i beskrivningen.",
  "playlist.annotate_form.warning.unsaved_changes": "Vill du inte spara ändringarna?",
  "navigation.label": "Navigering",
  "navigation.back_button_label": "Gå tillbaka",
  "navigation.forward_button_label": "Gå framåt",
  "search.input_placeholder": "Sök",
  "player.label": "Spelarkontroller",
  "player.shuffle_mode_label": "Shuffle",
  "player.repeat_mode_label": "Repetera",
  "player.queue": "Kö",
  "player.volume_button_label": "Volym",
  "player.spotify_connect": "Spotify Connect",
  "player.connect_button_label": "Anslut till en enhet",
  "player.lyrics_label": "Låttexter",
  "player.play_button_label": "Spela upp",
  "player.pause_button_label": "Pausa",
  "player.previous_button_label": "Föregående",
  "player.next_button_label": "Nästa",
  "player.offline_label": "Offline",
  "player.thumb_up_label": "Tumme upp",
  "player.thumb_down_label": "Tumme ned",
  "playererror.default": "Det gick inte att spela upp den valda låten",
  "playererror.track_not_available": "Låten är inte tillgänglig",
  "nowplaying.label": "Nu spelas",
  "nowplaying.go_to_context": "Gå till det som spelas nu",
  "nowplaying.save_your_music": "Spara i Din Musik",
  "nowplaying.remove_your_music": "Ta bort från Din Musik",
  "nowplaying.playing_suggested_track": "Just nu spelas en föreslagen låt",
  "connect.connect_text": "Anslut till en enhet",
  "connect.device_connecting": "Ansluter …",
  "connect.device_incompatible": "Inkompatibel",
  "connect.device_premium_only": "Endast för Premium-användare",
  "connect.device_sleeping": "Enheten är i viloläge",
  "connect.device_tech_cast": "Google Cast",
  "connect.device_tech_connect": "Spotify Connect",
  "connect.device_this_computer": "Den här datorn",
  "connect.device_unavailable_for_playback": "Inte tillgänglig för uppspelning",
  "connect.device_unknown": "Okänd enhet",
  "connect.device_unsupported_uri": "Kan inte spela upp detta just nu",
  "connect.devices_available": "Tillgängliga enheter",
  "connect.dismiss": "Stäng",
  "connect.help1": "Med Connect kan du spela upp musik och hantera Spotify på dina enheter.",
  "connect.help2": "Starta Spotify på en annan enhet så visas den automatiskt här.",
  "connect.help_hint": "Vad är Connect?",
  "connect.offline": "Inte tillgänglig",
  "connect.offline_reason_computer": "Spotify är inte aktivt på den här enheten.",
  "connect.offline_reason_generic": "Spotify är inte aktivt på den här enheten.",
  "connect.offline_reason_phone": "Telefonen är låst eller Spotify är inte i förgrunden.",
  "connect.offline_reason_gameconsole": "Använd ström på-inställningen i Spotify PlayStation-appen för att kunna starta PlayStation från viloläge.",
  "connect.offline_text1": "Du måste koppla upp dig om du ska kunna använda den här funktionen.",
  "connect.offline_title": "Du är offline!",
  "connect.playingon": "Lyssnar på",
  "connect.popup_title": "Enheter",
  "connect.remoteplayback": "Du lyssnar på {0}",
  "connect.show_more": "Visa mer",
  "connect.upgrade": "Uppgradera",
  "connect.upsell": "Connect är en Premium-funktion som du kan använda när du vill spela upp musik och hantera Spotify på dina enheter. ",
  "contextmenu.new-playlist": "Ny spellista",
  "contextmenu.add-to-playlist": "Lägg till i spellista",
  "contextmenu.owner-playlist": "av {0}",
  "contextmenu.copy-uri": "Kopiera Spotify URI",
  "contextmenu.copy-artist-url": "Kopiera artistlänken",
  "contextmenu.copy-album-url": "Kopiera albumlänken",
  "contextmenu.copy-track-url": "Kopiera låtlänken",
  "contextmenu.copy-playlist-url": "Kopiera spellistelänken",
  "contextmenu.copy-profile-url": "Kopiera profillänken",
  "contextmenu.copy-station-url": "Kopiera stationslänk",
  "contextmenu.copy-chart-url": "Kopiera topplistelänk",
  "contextmenu.copy-url": "Kopiera länken",
  "contextmenu.copy-embed": "Kopiera inbäddningskod",
  "contextmenu.collaborative": "Gemensam spellista",
  "contextmenu.save": "Spara i Din Musik",
  "contextmenu.remove": "Ta bort från Din Musik",
  "contextmenu.delete-playlist": "Ta bort",
  "contextmenu.follow": "Följ",
  "contextmenu.unfollow": "Sluta följa",
  "contextmenu.publish": "Gör offentlig",
  "contextmenu.unpublish": "Gör hemlig",
  "contextmenu.playlist.loading": "Läser in …",
  "contextmenu.play": "Spela upp",
  "contextmenu.add-to-queue": "Lägg till i kön",
  "contextmenu.station": "Gå till Radio",
  "contextmenu.station-album": "Gå till albumradio",
  "contextmenu.station-artist": "Gå till artistradio",
  "contextmenu.station-playlist": "Gå till spellisteradio",
  "contextmenu.station-track": "Gå till låtradio",
  "contextmenu.station-chart": "Gå till topplisteradio",
  "contextmenu.remove-from-playlist": "Ta bort från den här spellistan",
  "contextmenu.remove-from-queue": "Ta bort från kön",
  "contextmenu.rename-folder": "Byt namn",
  "contextmenu.rename-playlist": "Byt namn",
  "contextmenu.edit-playlist": "Redigera information",
  "contextmenu.report-playlist": "Rapportera",
  "contextmenu.report-asset": "Rapportera",
  "contextmenu.share": "Dela …",
  "contextmenu.share-lyrics": "Dela låttexter",
  "contextmenu.create-folder": "Skapa mapp",
  "contextmenu.create-playlist": "Skapa spellista",
  "contextmenu.open-localfile-folder": "Öppna källmappen",
  "contextmenu.open-localfile-folder-mac": "Visa i Finder",
  "contextmenu.offline": "Tillgänglig offline",
  "contextmenu.goto-artist": "Gå till artisten",
  "contextmenu.goto-album": "Gå till albumet",
  "usermessage.default-message": "Det uppstod ett fel",
  "usermessage.update-ready": "Hej! Vi har en ny Spotify-version som väntar på dig. <a href=\"#\" data-action=\"{0}\">Starta om nu</a> om du vill installera den.",
  "usermessage.update-ready-simple": "Hej! Vi har en ny Spotify-version som väntar på dig. Starta om nu om du vill installera den.",
  "usermessage.play-token-lost": "Spotify har pausats eftersom ditt konto används någon annanstans.",
  "usermessage.playback-paused-inactive": "Datorn har varit inaktiv en lång stund. Tryck på Spela upp om du vill fortsätta att lyssna! Om du vill slippa avbrott i musiken kan du prenumerera på <a href=\"#\" data-action=\"{0}\">Spotify Premium</a>.",
  "usermessage.not-available-offline": "Ingen internetanslutning hittades. Spotify försöker automatiskt att ansluta igen när en internetanslutning upptäcks (felkod: 4).",
  "usermessage.track-not-available-in-region": "Den här låten är inte tillgänglig i {0} för närvarande. Om filen finns på datorn kan du importera den.",
  "usermessage.track-not-available-in-region-generic": "Låten finns inte i ditt land för närvarande. Om filen finns på datorn kan du importera den.",
  "usermessage.track-not-available": "Låten är inte tillgänglig. Om filen finns på datorn kan du importera den.",
  "usermessage.track-not-available-forced-offline": "<a href=\"#\" data-action=\"goOnline\">Stäng av offlineläget</a> och försök igen.",
  "usermessage.track-exclusive-premium": "Den här låten är bara tillgänglig för <a href=\"#\" data-action=\"{0}\">Spotify Premium</a> -användare.",
  "usermessage.track-banned-by-artist": "Artisten/skivbolaget har valt att inte göra den här låten tillgänglig. Om filen finns på datorn kan du importera den.",
  "usermessage.local-track-no-file": "Den här låten lades till som en lokal fil. Om filen finns på datorn kan du importera den.",
  "usermessage.local-track-file-not-found": "Det går inte att spela upp den här låten eftersom det inte gick att hitta filen. Importera den igen.",
  "usermessage.local-track-bad-format": "Filen har okänt format. Klicka <a href=\"#\" data-action=\"{0}\">här</a> om du vill ha mer information.",
  "usermessage.capping-reached": "Du har överskridit tidsgränsen på {0} timmar. <a href=\"#\" data-action=\"{1}\">Uppgradera till Spotify Premium</a> om du vill lyssna utan begränsningar.",
  "usermessage.local-track-drm-protected": "Det går inte att spela upp den här låten eftersom filen skyddas med DRM (Digital Rights Management).",
  "usermessage.offline-disk-cache": "Det gick inte att hämta offlinelåtarna. Disken kanske är full?",
  "usermessage.offline-sync-expired": "Offlinelåtarna är ogiltiga. Du måste logga in i Spotify om du vill aktivera dem igen.",
  "usermessage.offline-sync-failed": "Det gick inte att hämta vissa offlinelåtar.",
  "usermessage.offline-too-many-tracks": "För många låtar har valts för offlineläge.",
  "usermessage.offline-license-server-error": "Det har uppstått ett problem med Spotify-servern.",
  "usermessage.offline-license-lost": "Den här datorn eller enheten har inte längre offlineåtkomst.",
  "usermessage.offline-not-allowed": "Offlineläge är en funktion som bara är tillgänglig i <a href=\"#\" data-action=\"{0}\">Spotify Premium</a> .",
  "usermessage.language-changed": "Du måste <a href=\"#\" data-action=\"{0}\">starta om Spotify</a> innan ändringarna börjar gälla",
  "usermessage.proxysettings-changed": "Du måste <a href=\"#\" data-action=\"{0}\">starta om Spotify</a> innan ändringarna börjar gälla",
  "usermessage.language-changed-simple": "Du måste starta om Spotify innan ändringarna börjar gälla",
  "usermessage.proxysettings-changed-simple": "Du måste starta om Spotify innan ändringarna börjar gälla",
  "usermessage.cache-changed": "Du måste <a href=\"#\" data-action=\"{0}\">starta om Spotify</a> innan ändringarna börjar gälla",
  "usermessage.cache-changed-simple": "Du måste starta om Spotify innan ändringarna börjar gälla",
  "usermessage.feature-changed": "Du måste <a href=\"#\" data-action=\"{0}\">starta om Spotify</a> innan ändringarna börjar gälla",
  "usermessage.first-autostart": "Spotify har öppnats automatiskt, men minimerat. Du kan även välja att <a href=\"#\" data-action=\"{0}\">öppna Spotify automatiskt utan att det är minimerat</a> eller att <a href=\"#\" data-action=\"{1}\">inte öppna Spotify alls</a> vid start.",
  "usermessage.cant-play-track": "Det går inte att spela upp den aktuella låten.",
  "usermessage.cant-skip-ads": "Den valda låten spelas upp efter annonsen",
  "usermessage.cant-offline-playlists": "Offlineläge är en funktion som bara är tillgänglig i Premium. <a href=\"#\" data-action=\"{0}\">Skaffa Premium</a>.",
  "usermessage.cant-set-high-quality-streaming": "Det här är en funktion som bara är tillgänglig i Premium. <a href=\"#\" data-action=\"{0}\">Uppgradera till Premium</a>.",
  "usermessage.payment-state-creditcard-funds": "Vi har inte kunnat förnya din prenumeration på grund av ett betalningsproblem. Kontrollera att du har tillräckligt med pengar på kontot eller <a href=\"#\" data-action=\"{0}\">uppdatera din betalningsinformation</a>.",
  "usermessage.payment-state-creditcard-refused": "Vi har inte kunnat förnya din prenumeration på grund av ett betalningsproblem. Om du vill behålla din prenumeration måste du <a href=\"#\" data-action=\"{0}\">uppdatera din betalningsinformation.</a>.",
  "usermessage.payment-state-paypal-refused": "Vi har inte kunnat förnya din prenumeration på grund av ett betalningsproblem. Om du vill behålla din prenumeration måste du <a href=\"#\" data-action=\"{0}\">uppdatera din betalningsinformation.</a>.",
  "usermessage.payment-state-creditcard-expiry": "Det betalkort du använder för närvarande går ut om några dagar. Om du vill behålla din prenumeration måste du <a href=\"#\" data-action=\"{0}\">uppdatera din betalningsinformation</a>.",
  "usermessage.payment-state-prepaid-expiry": "Din förbetalda prenumeration håller på att ta slut. Oroa dig inte, du kan <a href=\"#\" data-action=\"{0}\">prenumerera på Premium här</a>.",
  "usermessage.payment-state-churn-payment": "Tyvärr kunde vi inte ta emot någon betalning från dig. Därför har vi varit tvungna att avsluta din prenumeration. Oroa dig inte, du kan <a href=\"#\" data-action=\"{0}\">förnya din prenumeration här</a>.",
  "usermessage.payment-state-churn-partner": "Din prenumeration med en av våra partner har precis gått ut, så nu använder du Spotify Free. Oroa dig inte, du kan <a href=\"#\" data-action=\"{0}\">gå tillbaka till Premium här</a>.",
  "usermessage.opt-in-trial": "Vi hoppas att du är nöjd med din kostnadsfria testperiod! Undvik att förlora Premium när testperioden är slut genom att <a href=\"#\" data-action=\"{0}\">prenumerera i dag</a>.",
  "usermessage.opt-in-trial-expired": "Din testperiod är slut, så nu använder du Spotify Free. Oroa dig inte, du kan <a href=\"#\" data-action=\"{0}\">gå tillbaka till Premium här</a>.",
  "usermessage.hardware-acceleration-changed": "Du måste <a href=\"#\" data-action=\"{0}\">starta om Spotify</a> innan ändringarna börjar gälla",
  "usermessage.hardware-acceleration-changed-simple": "Du måste starta om Spotify innan ändringarna börjar gälla",
  "usermessage.some-local-tracks-not-saved": "Några av de valda låtarna sparades inte i Din musik. Lokala filer kan inte läggas till i Din musik.",
  "usermessage.illegal-playlist-name-entered": "Det angivna namnet på spellistan var ogiltigt.",
  "usermessage.playlist-save-failed-unknown": "Spellistan kunde inte sparas på grund av ett okänt fel.",
  "usermessage.social-error-permissions": "Klicka <a href=\"#\" data-action=\"{0}\">här</a> om du vill dela din musikaktivitet på Facebook.",
  "usermessage.shuffle-unplayable-track": "<a href=\"#\" data-action=\"{0}\">Uppgradera till Premium</a> och lyssna på valfri låt, när du vill.",
  "usermessage.shuffle-ran-out-of-skips": "Du har slut på låtbyten (den här timmen). <a href=\"#\" data-action=\"{0}\">Uppgradera till Premium</a> och byt låt så ofta du vill.",
  "usermessage.playlist-limit-exceeded": "Du har fyllt den här spellistan till maxgränsen. Imponerande! Skapa en ny spellista och fortsätt samla.",
  "usermessage.collection-limit-exceeded": "Episk samling, hörru. Det är fullt i Din musik. Om du vill spara mer måste du ta bort några låtar.",
  "usermessage.deprecating-os-version": "Viktigt meddelande! Vi upphör med stödet för ditt operativsystem i vår nästa version. Klicka <a href=\"#\" data-action=\"{0}\">här</a> om du vill ha mer information.",
  "usermessage.image-upload-propagation": "Hurra! (Det kan ta upp till 24 timmar att sprida bilder)",
  "usermessage.approaching-capping-limit": "Du har mindre än en timme kvar att lyssna gratis. Få 15 timmars gratis lyssning varje månad eller <a href=\"#\" data-action=\"{0}\">uppgradera till Premium</a> för att lyssna obegränsat. <a href=\"#\" data-action=\"{1}\">Läs mer</a>. ",
  "usermessage.half-capping-limit-passed": "Du har använt hälften av din gratismängd den här månaden. Få 15 timmars gratis lyssning varje månad eller <a href=\"#\" data-action=\"{0}\">uppgradera till Premium</a> för att lyssna obegränsat. <a href=\"#\" data-action=\"{1}\">Läs mer</a>. ",
  "usermessage.video-georestricted": "Vi kan inte spela upp den här videon på den plats du befinner dig just nu.",
  "usermessage.video-unsupported-client-version": "Uppgradera Spotify om du vill spela upp den här videon.",
  "usermessage.video-unsupported-platform-version": "Den här videon kan inte spelas upp i din operativsystemsversion.",
  "usermessage.video-country-restricted": "Vi kan inte spela upp den här videon på den plats du befinner dig just nu.",
  "usermessage.video-unavailable": "Videon är inte tillgänglig. Vill du testa med en annan?",
  "usermessage.video-catalogue-restricted": "Tyvärr kan vi inte spela upp den här videon.",
  "usermessage.video-playback-error": "Tyvärr kan vi inte spela upp den här videon.",
  "about.title_label": "Om Spotify",
  "about.close_button_label": "Stäng",
  "offline-progress-msg": "Synkar {0} av {1} låtar offline",
  "tos.updated_terms": "Uppdaterade villkor",
  "tos.modal_title": "Användarvillkor",
  "tos.tos_text": "<p>Vi har uppdaterat våra <a href=\"{0}\">användarvillkor</a> och <a href=\"{1}\">vår sekretesspolicy</a>.</p><p>Genom att fortsätta använda Spotify godkänner du de här ändrade villkoren. Läs igenom dem noggrant så att du är införstådd med dem.</p>",
  "tos.not_now_tos_text": "<p>Vi har uppdaterat våra <a href=\"{0}\">användarvillkor</a> och vår <a href=\"{1}\">sekretesspolicy</a>.</p><p>Genom att klicka på Godkänn godkänner du ändringarna (och hanteringen av dina data så som den beskrivs). Läs igenom villkoren noggrant så att du är införstådd med dem.</p>",
  "tos.tos_text2": "<p>Om du inte vill fortsätta använda Spotify kan du avsluta prenumerationen på din prenumerationssida för Spotify.</p>",
  "tos.not_now_text": "<p>Du får fortsätta använda Spotify i {0} dagar utan att godkänna de uppdaterade användarvillkoren och den uppdaterade sekretesspolicyn. Efter det måste du acceptera de nya villkoren om du vill fortsätta använda Spotify. Om du inte avslutar din prenumeration fortsätter du att faktureras enligt din vanliga faktureringscykel. Om du inte vill debiteras av Spotify igen kan du avsluta din prenumeration när du vill på Spotifys prenumerationssida.</p>",
  "tos.not_now_last_day_text": "<p>Du kan fortsätta använda Spotify i 1 dag utan att godkänna de uppdaterade användarvillkoren och den uppdaterade sekretesspolicyn. Om du inte godkänner de nya villkoren efter den dagen kan du inte längre använda Spotify. Om du inte avslutar din prenumeration fortsätter du att faktureras månadsvis enligt din vanliga betalningscykel. Om du inte vill debiteras av Spotify igen kan du avsluta prenumerationen när som helst på din prenumerationssida för Spotify.</p>",
  "tos.not_now_text_germany": "<p>Vi har reviderat våra <a href=\"{0}\">användarvillkor</a> och vår <a href=\"{1}\">sekretesspolicy</a>. Observera att Spotify GmbH med ditt tillstånd avser att överföra ditt avtal till Spotify AB, Birger Jarlsgatan 61, 113 56 Stockholm.</p><p>Du får fortsätta använda Spotify-tjänsten under det befintliga avtalet till och med {2}. Om du vill fortsätta använda Spotify-tjänsten efter det datumet måste du godkänna de nya användarvillkoren och den nya sekretesspolicyn. Genom att klicka på Godkänn accepterar du</p><p>a) att ditt avtal överförs från Spotify GmbH till Spotify AB,<br />b) de uppdaterade användarvillkoren och<br />c) att din personliga information samlas in, behandlas och används enligt beskrivningen i avsnitt 4, 5 och 7 i sekretesspolicyn.</p>",
  "tos.not_now_text2_germany": "<p>Du kan fortsätta använda Spotify till och med {0} utan att godkänna de uppdaterade användarvillkoren och den uppdaterade sekretesspolicyn. Sedan måste du acceptera de nya villkoren om du vill fortsätta använda Spotify. Om du är Premium-användare och inte avslutar din prenumeration fortsätter du att faktureras enligt din vanliga faktureringscykel. Om du inte vill debiteras av Spotify igen kan du avsluta din prenumeration när du vill på Spotifys prenumerationssida.</p>",
  "tos.not_now_expired_text_germany": "<p>Vi har reviderat våra <a href=\"{0}\">användarvillkor</a> och vår <a href=\"{1}\">sekretesspolicy</a>.</p><p>Observera att Spotify GmbH med ditt tillstånd avser att överföra ditt avtal till Spotify AB, Birger Jarlsgatan 61, 113 56 Stockholm.</p><p>Om du vill fortsätta använda Spotify-tjänsten måste du godkänna de nya användarvillkoren och den nya sekretesspolicyn. Genom att klicka på Godkänn accepterar du</p><p>a) att ditt avtal överförs från Spotify GmbH till Spotify AB,<br />b) de uppdaterade användarvillkoren och<br />c) att din personliga information samlas in, behandlas och används enligt beskrivningen i avsnitt 4, 5 och 7 i sekretesspolicyn.</p>",
  "tos.back_button_label": "Bakåt",
  "tos.ok_button_label": "OK",
  "tos.agree_button_label": "Godkänn",
  "tos.cancel_button_label": "Godkänn inte",
  "tos.not_now_button_label": "Inte nu",
  "licenses.modal_title": "Tredjepartslicenser",
  "licenses.close_button_label": "Stäng",
  "feedback.beta_title": "Betaversion",
  "feedback.beta_text": "Vad tycker du? Vi vill gärna veta.",
  "market.ad": "Andorra",
  "market.ar": "Argentina",
  "market.at": "Österrike",
  "market.au": "Australien",
  "market.be": "Belgien",
  "market.bg": "Bulgarien",
  "market.bo": "Bolivia",
  "market.br": "Brasilien",
  "market.ca": "Kanada",
  "market.ch": "Schweiz",
  "market.cl": "Chile",
  "market.co": "Colombia",
  "market.cr": "Costa Rica",
  "market.cy": "Cypern",
  "market.cz": "Tjeckien",
  "market.de": "Tyskland",
  "market.dk": "Danmark",
  "market.do": "Dominikanska republiken",
  "market.ec": "Ecuador",
  "market.ee": "Estland",
  "market.es": "Spanien",
  "market.fi": "Finland",
  "market.fr": "Frankrike",
  "market.gr": "Grekland",
  "market.gt": "Guatemala",
  "market.hk": "Hongkong",
  "market.hn": "Honduras",
  "market.hu": "Ungern",
  "market.ie": "Irland",
  "market.is": "Island",
  "market.it": "Italien",
  "market.jp": "Japan",
  "market.li": "Liechtenstein",
  "market.lt": "Litauen",
  "market.lu": "Luxemburg",
  "market.lv": "Lettland",
  "market.mc": "Monaco",
  "market.mt": "Malta",
  "market.mx": "Mexiko",
  "market.my": "Malaysia",
  "market.ni": "Nicaragua",
  "market.nl": "Nederländerna",
  "market.no": "Norge",
  "market.nz": "Nya Zeeland",
  "market.pa": "Panama",
  "market.pe": "Peru",
  "market.ph": "Filippinerna",
  "market.pl": "Polen",
  "market.pt": "Portugal",
  "market.py": "Paraguay",
  "market.se": "Sverige",
  "market.sg": "Singapore",
  "market.sk": "Slovakien",
  "market.sv": "El Salvador",
  "market.tr": "Turkiet",
  "market.tw": "Taiwan",
  "market.uk": "Storbritannien",
  "market.us": "USA",
  "market.uy": "Uruguay",
  "market.za": "Sydafrika",
  "sTitle": "Säg din mening och hjälp oss utveckla världens bästa musiktjänst!",
  "sQ1Question": "Hur troligt är det att du rekommenderar Spotify för en vän eller kollega?",
  "sQ1Negative": "Inte troligt",
  "sQ1Positive": "Väldigt troligt",
  "sQ2Question": "Varför?",
  "sQ3Question": "Hur nöjd är du med Spotify?",
  "sQ3Negative": "Väldigt missnöjd",
  "sQ3Positive": "Väldigt nöjd",
  "sSubmit": "Skicka enkäten",
  "sThanks": "Tack för din hjälp och tid!",
  "sTeam": "Spotify-teamet",
  "sClose": "Stäng",
  "cls.highlight": "Premium har pausats",
  "cls.title": "Din senaste betalning fungerade inte.",
  "cls.desc": "Fortsätt lyssna med Premium genom att lägga till en ny betalningsmetod. Det tar bara ett ögonblick.",
  "cls.updatePayment": "Uppdatera betalningen",
  "cls.cancelSubscription": "Du kan också nedgradera till Spotify Free<br>genom att <a class=\"cancel-sub\" href=\"#cancel\">avsluta din Premium-prenumeration</a>.",
  "capping.upsell-title": "Du har nått gränsen för att lyssna gratis.",
  "capping.upsell-message": "Du får 15 timmars gratis lyssning varje månad.<br />Uppgradera till Premium så kan du lyssna obegränsat utan reklam.",
  "capping.upsell-button-label": "Uppgradera till Premium",
  "capping.defaultRefillMessage": "Din gratisperiod kommer att fyllas på inom kort.",
  "capping.refillMessage": "Din gratisperiod kommer att fyllas på inom {0} dagar.",
  "capping.welcome-title": "Välkommen till Spotify.",
  "capping.welcome-message": "Du får 15 timmars gratis lyssning varje månad.<br /> <a data-action={0}>Uppgradera till Premium</a> så kan du lyssna obegränsat utan reklam.",
  "capping.welcome-message-button-label": "Kom igång",
  "yourArtistsTooltipTitle": "Hantera dina artister",
  "yourArtistsTooltipText": "Du kan nu enkelt redigera din artistprofilbild på Spotify.",
  "yourArtists": "Dina artister"
};
},{}],18:[function(require,module,exports){
module.exports = {
  "browse.app_name": "Gözat",
  "latest-releases.app_name": "En Son Çıkanlar",
  "discover.app_name": "Keşfet",
  "activity.app_name": "Hareket",
  "radio.app_name": "Radyo",
  "settings.app_name": "Ayarlar",
  "messages.app_name": "Mesajlar",
  "profile.app_name": "Profil",
  "notifications_center.app_name": "Bildirimler",
  "concerts.app_name": "Konserler",
  "profile.private_session": "Gizli Oturum",
  "profile.upgrade": "Yükselt",
  "profile.upgrade_account": "Hesabını Yükselt",
  "profile.upgrade_tooltip": "Premium'a Yükselt",
  "profile.account": "Hesap",
  "profile.logout": "Oturumu Kapat",
  "profile.enabled": "Etkin",
  "profile.menu_label": "Menü",
  "profile.switch": "Kullanıcı Değiştir",
  "profile.new_user": "Yeni Kullanıcıya Geç",
  "your_music.app_name": "Müziklerin",
  "your_music.songs": "Şarkılar",
  "your_music.artists": "Sanatçılar",
  "your_music.albums": "Albümler",
  "your_music.stations": "İstasyonlar",
  "your_music.local_files": "Yerel Dosyalar",
  "sidebar.title_main": "Giriş",
  "sidebar.title_playlists": "Çalma Listeleri",
  "new_playlist.input_placeholder": "Yeni Çalma Listesi",
  "new_playlist.button": "Yeni Çalma Listesi",
  "accessibilitylinks.skip_to_content_label": "Ana içeriğe geç",
  "accessibilitylinks.skip_to_player_label": "Çalar denetimlerine geç",
  "playlist.by": "- {0}",
  "playlist.loading": "Yükleniyor...",
  "playlist.newfolder": "Yeni Klasör",
  "playlist.delete_message": "Bu çalma listesini silmek istiyor musun?",
  "playlist.unfollow_message": "Bu çalma listesini takip etmeyi bırakmak istiyor musun?",
  "playlistfolder.delete_message": "Bu klasörü ve içindeki tüm çalma listelerini silmek istiyor musun?",
  "playlist.delete_confirm": "Sil",
  "playlist.unfollow_confirm": "Takip Etmeyi Bırak",
  "playlist.delete_cancel": "İptal",
  "playlist.duplicates_dialog_title": "Yinelenen şarkılar",
  "playlist.duplicates_dialog_title_single": "Yinelenen şarkı",
  "playlist.duplicates_dialog_body": "Bu şarkılardan bazıları zaten çalma listende.",
  "playlist.duplicates_dialog_body_single": "Bu şarkı zaten çalma listende.",
  "playlist.duplicates_dialog_button_add": "Tümünü ekle",
  "playlist.duplicates_dialog_button_add_single": "Yine de ekle",
  "playlist.duplicates_dialog_button_skip_duplicates": "Yinelemeleri atla",
  "playlist.duplicates_dialog_button_skip_single": "Yinelemeyi atla",
  "playlist.annotate_form.new_playlist_name": "Yeni Çalma Listesi",
  "playlist.annotate_form.create_title": "Çalma Listesi Oluştur",
  "playlist.annotate_form.create": "Oluştur",
  "playlist.annotate_form.cancel": "İptal",
  "playlist.annotate_form.edit_title": "Çalma Listesi Ayrıntılarını Düzenle",
  "playlist.annotate_form.save": "Kaydet",
  "playlist.annotate_form.name_field_label": "Adı",
  "playlist.annotate_form.name_field_placeholder": "Çalma listesi adı",
  "playlist.annotate_form.image_field_label": "Görüntü",
  "playlist.annotate_form.image_pick_button_label": "Görüntü seç",
  "playlist.annotate_form.image_replace_button_label": "Görüntüyü değiştir",
  "playlist.annotate_form.image_remove_button_label": "Görüntüyü kaldır",
  "playlist.annotate_form.image_file_size_exceeded": "Görüntü boyutu çok büyük, maksimum: 4 MB.",
  "playlist.annotate_form.image_file_upload_failed": "Görüntü yüklenemedi, lütfen yeniden dene.",
  "playlist.annotate_form.annotate_failed": "Açıklama ve görüntü güncellenemedi, lütfen yeniden dene.",
  "playlist.annotate_form.close-error-bar": "Gizle",
  "playlist.annotate_form.description_field_label": "Açıklama",
  "playlist.annotate_form.description_field_placeholder": "Çalma listene dikkat çekici bir açıklama ekle.",
  "playlist.annotate_form.permission_message": "Devam ederek Spotify'ın, yüklemeyi tercih ettiğin görüntüye erişmesini kabul etmiş oluyorsun. Lütfen görüntüyü yüklemek için gerekli haklara sahip olduğundan emin ol. Görüntüyü sadece çalma listesi kapak resmi olarak kullanacağız.",
  "playlist.annotate_form.insert_link_button_label": "Bağlantı ekle",
  "playlist.annotate_form.insert_link.link_field_label": "Bağlantı",
  "playlist.annotate_form.insert_link.change_button_label": "Değiştir",
  "playlist.annotate_form.insert_link.remove_button_label": "Çıkar",
  "playlist.annotate_form.insert_link.done_button_label": "Bitti",
  "playlist.annotate_form.drop_to_set_image_label": "Görüntüyü belirlemek için bırak",
  "playlist.annotate_form.drop_not_allowed_label": "Desteklenmeyen biçim",
  "playlist.annotate_form.error.file_not_valid_jpg": "Dosya adına rağmen, bu dosya geçerli bir JPG dosyası değil.",
  "playlist.annotate_form.error.name_required": "Çalma listene ad vermen gerekir.",
  "playlist.annotate_form.error.selection_required_to_insert_link": "Bağlantıya dönüştürmek istediğin metni seçmen gerekir.",
  "playlist.annotate_form.error.html_not_allowed": "HTML kullanmaya çalışıyorsun ama bu mümkün değil.",
  "playlist.annotate_form.error.submit": "Çalma listesi değişiklikleri kaydedilemedi. Lütfen tekrar dene.",
  "playlist.annotate_form.error.image_too_small": "Görsel çok küçük.  En az {0}x{1} boyutunda olmalı.",
  "playlist.annotate_form.warning.client_offline": "İnternet bağlantısı bulunamadı. Açıklamada ve resimde yapılan değişiklikler kaydedilmeyecek.",
  "playlist.annotate_form.warning.no_line_breaks_in_description": "Üzgünüz, ancak açıklamada yeni satıra geçmek desteklenmiyor.",
  "playlist.annotate_form.warning.unsaved_changes": "Değişikliklerini kaydetmek istiyor musun?",
  "navigation.label": "Gezinme",
  "navigation.back_button_label": "Geri git",
  "navigation.forward_button_label": "İlerle",
  "search.input_placeholder": "Ara",
  "player.label": "Oyuncu denetimleri",
  "player.shuffle_mode_label": "Karışık Çal",
  "player.repeat_mode_label": "Tekrarla",
  "player.queue": "Sıraya Ekle",
  "player.volume_button_label": "Ses seviyesi",
  "player.spotify_connect": "Spotify Connect",
  "player.connect_button_label": "Bir cihaza bağlan",
  "player.lyrics_label": "Şarkı sözleri",
  "player.play_button_label": "Çal",
  "player.pause_button_label": "Duraklat",
  "player.previous_button_label": "Önceki",
  "player.next_button_label": "Sonraki",
  "player.offline_label": "Çevrimdışı",
  "player.thumb_up_label": "Beğendim",
  "player.thumb_down_label": "Beğenmedim",
  "playererror.default": "Seçtiğin şarkı çalmaya çalışılırken sorun yaşandı",
  "playererror.track_not_available": "Bu şarkı kullanılamıyor",
  "nowplaying.label": "Şimdi çalan",
  "nowplaying.go_to_context": "Çalanlara git",
  "nowplaying.save_your_music": "Müziklerin'e kaydet",
  "nowplaying.remove_your_music": "Müziklerin'den çıkar",
  "nowplaying.playing_suggested_track": "Şu Anda Önerilen Şarkı Çalınıyor",
  "connect.connect_text": "Bir cihaza bağlan",
  "connect.device_connecting": "Bağlanıyor…",
  "connect.device_incompatible": "Uyumsuz",
  "connect.device_premium_only": "Yalnızca Premium kullanıcıları",
  "connect.device_sleeping": "Cihaz uyku modunda",
  "connect.device_tech_cast": "Google Cast",
  "connect.device_tech_connect": "Spotify Connect",
  "connect.device_this_computer": "Bu Bilgisayar",
  "connect.device_unavailable_for_playback": "Şu cihazda dinlenemez:",
  "connect.device_unknown": "Bilinmeyen cihaz",
  "connect.device_unsupported_uri": "Bu parça şu anda çalınamıyor",
  "connect.devices_available": "Kullanılabilir Cihazlar",
  "connect.dismiss": "Kapat",
  "connect.help1": "Connect sayesinde cihazlarında müzik dinleyebilir ve Spotify'ı kontrol edebilirsin.",
  "connect.help2": "Spotify'ı başka bir cihazda başlat, mucizevi bir şekilde burada görünsün.",
  "connect.help_hint": "Connect nedir?",
  "connect.offline": "Kullanılamıyor",
  "connect.offline_reason_computer": "Spotify bu cihazda etkin değil.",
  "connect.offline_reason_generic": "Spotify bu cihazda etkin değil.",
  "connect.offline_reason_phone": "Telefon kilitli veya Spotify arka planda açık değil.",
  "connect.offline_reason_gameconsole": "PlayStation'ın bekleme modundan çıkmasını sağlamak için Spotify PlayStation Uygulamasında bulunan güç ayarlarını kullan.",
  "connect.offline_text1": "Bu özelliği kullanmak için çevrimiçi olman gerekiyor.",
  "connect.offline_title": "Çevrimdışısın!",
  "connect.playingon": "Dinlediğin Cihaz",
  "connect.popup_title": "Cihazlar",
  "connect.remoteplayback": "{0} cihazında dinliyorsun.",
  "connect.show_more": "Daha Fazla Göster",
  "connect.upgrade": "Yükselt",
  "connect.upsell": "Connect, cihazlarında müzik dinlemene ve Spotify'ı kontrol etmene olanak tanıyan bir Premium özelliğidir.",
  "contextmenu.new-playlist": "Yeni Çalma Listesi",
  "contextmenu.add-to-playlist": "Çalma Listesine Ekle",
  "contextmenu.owner-playlist": "- {0}",
  "contextmenu.copy-uri": "Spotify URI'sini Kopyala",
  "contextmenu.copy-artist-url": "Sanatçı Bağlantısını Kopyala",
  "contextmenu.copy-album-url": "Albüm Bağlantısını Kopyala",
  "contextmenu.copy-track-url": "Şarkı Bağlantısını Kopyala",
  "contextmenu.copy-playlist-url": "Çalma Listesi Bağlantısını Kopyala",
  "contextmenu.copy-profile-url": "Profil Bağlantısını Kopyala",
  "contextmenu.copy-station-url": "İstasyon Bağlantısını Kopyala",
  "contextmenu.copy-chart-url": "Liste Bağlantısını Kopyala",
  "contextmenu.copy-url": "Bağlantıyı Kopyala",
  "contextmenu.copy-embed": "Kodu Kopyalayıp Yerleştir",
  "contextmenu.collaborative": "Ortak Çalma Listesi",
  "contextmenu.save": "Müziklerin'e kaydet",
  "contextmenu.remove": "Müziklerin'den çıkar",
  "contextmenu.delete-playlist": "Sil",
  "contextmenu.follow": "Takip Et",
  "contextmenu.unfollow": "Takip Etmeyi Bırak",
  "contextmenu.publish": "Herkese Açık Yap",
  "contextmenu.unpublish": "Gizli Yap",
  "contextmenu.playlist.loading": "Yükleniyor...",
  "contextmenu.play": "Çal",
  "contextmenu.add-to-queue": "Sıraya Ekle",
  "contextmenu.station": "Radyo'ya Git",
  "contextmenu.station-album": "Albüm Radyosuna git",
  "contextmenu.station-artist": "Sanatçı Radyosuna git",
  "contextmenu.station-playlist": "Çalma Listesi Radyosuna git",
  "contextmenu.station-track": "Şarkı Radyosuna git",
  "contextmenu.station-chart": "Liste Radyosuna Git",
  "contextmenu.remove-from-playlist": "Bu Çalma Listesinden çıkar",
  "contextmenu.remove-from-queue": "Sıradan çıkar",
  "contextmenu.rename-folder": "Yeniden adlandır",
  "contextmenu.rename-playlist": "Yeniden adlandır",
  "contextmenu.edit-playlist": "Ayrıntıları düzenle",
  "contextmenu.report-playlist": "Bildir",
  "contextmenu.report-asset": "Bildir",
  "contextmenu.share": "Paylaş...",
  "contextmenu.share-lyrics": "Şarkı Sözü Paylaş",
  "contextmenu.create-folder": "Klasör Oluştur",
  "contextmenu.create-playlist": "Çalma Listesi Oluştur",
  "contextmenu.open-localfile-folder": "İçeren Klasörü Aç",
  "contextmenu.open-localfile-folder-mac": "Finder ile göster",
  "contextmenu.offline": "Çevrimdışı Kullanılabilir",
  "contextmenu.goto-artist": "Sanatçıya git",
  "contextmenu.goto-album": "Albüme git",
  "usermessage.default-message": "Bir hata oluştu",
  "usermessage.update-ready": "Merhaba. Spotify'ın yeni bir sürümü senin için hazır. <a href=\"#\" data-action=\"{0}\">Şimdi yeniden başlat</a>, senin olsun.",
  "usermessage.update-ready-simple": "Merhaba. Spotify'ın yeni bir sürümü senin için hazır. Şimdi yeniden başlat, senin olsun.",
  "usermessage.play-token-lost": "Hesabın başka bir yerde kullanıldığı için Spotify durduruldu.",
  "usermessage.playback-paused-inactive": "Bilgisayarın uzun süredir kullanılmıyor, dinlemeye devam etmek için çal düğmesine bas! Kesintisiz müzik için  <a href=\"#\" data-action=\"{0}\">Spotify Premium</a>'a üye ol.",
  "usermessage.not-available-offline": "İnternet bağlantısı bulunamadı. Spotify İnternet bağlantısı algıladığında otomatik olarak tekrar bağlanmayı deneyecek (hata kodu: 4)",
  "usermessage.track-not-available-in-region": "Bu şarkı {0} bölgesinde kullanılamıyor. Dosya bilgisayarında varsa aktarabilirsin.",
  "usermessage.track-not-available-in-region-generic": "Bu şarkı şu anda bulunduğun ülkede kullanılamıyor. Dosya bilgisayarında varsa aktarabilirsin.",
  "usermessage.track-not-available": "Bu şarkı kullanılamıyor. Dosya bilgisayarında varsa aktarabilirsin.",
  "usermessage.track-not-available-forced-offline": "Lütfen <a href=\"#\" data-action=\"goOnline\">çevrimdışı modunu kapat</a> ve tekrar dene.",
  "usermessage.track-exclusive-premium": "Bu şarkı yalnızca <a href=\"#\" data-action=\"{0}\">Spotify Premium</a> kullanıcıları tarafından kullanılabilir.",
  "usermessage.track-banned-by-artist": "Sanatçı/plak şirketi bu şarkının yayınlanmamasını istedi. Dosya bilgisayarında varsa aktarabilirsin.",
  "usermessage.local-track-no-file": "Bu şarkı yerel dosya olarak eklendi. Dosya bilgisayarında varsa aktarabilirsin.",
  "usermessage.local-track-file-not-found": "Dosya bulunamadığı için bu şarkı çalınamıyor. Lütfen tekrar aktar.",
  "usermessage.local-track-bad-format": "Dosya biçimi desteklenmiyor.  Bilgi için <a href=\"#\" data-action=\"{0}\"> buraya</a> tıkla.",
  "usermessage.capping-reached": "{0} saatlik zaman sınırlamasını geçmiş durumdasınız. Kısıtlamalar olmadan dinlemek için hesabınızı  <a href=\"#\" data-action=\"{1}\">Spotify Premium'a yükseltin</a> .",
  "usermessage.local-track-drm-protected": "Bu şarkı dijital hak yönetimi (DRM) ile korunduğu için çalınamıyor.",
  "usermessage.offline-disk-cache": "Çevrimdışı şarkılar indirilemedi. Disk dolu olabilir mi?",
  "usermessage.offline-sync-expired": "Çevrimdışı şarkıların süresi doldu. Şarkıları yeniden etkinleştirmek için Spotify'da oturum açman gerekiyor.",
  "usermessage.offline-sync-failed": "Çevrimdışı şarkılardan bazıları indirilemedi.",
  "usermessage.offline-too-many-tracks": "Çevrimdışı modu için çok fazla şarkı seçildi.",
  "usermessage.offline-license-server-error": "Spotify sunucusu ile ilgili bir sorun var.",
  "usermessage.offline-license-lost": "Bu bilgisayar/cihaz için çevrimdışı erişim izni geri çekilmiştir.",
  "usermessage.offline-not-allowed": "Çevrimdışı modu <a href=\"#\" data-action=\"{0}\">Spotify Premium</a> özelliğidir.",
  "usermessage.language-changed": "Değişikliğin etkin olması için  <a href=\"#\" data-action=\"{0}\">Spotify'ı tekrar başlatmalısın</a>",
  "usermessage.proxysettings-changed": "Değişikliğin etkin olması için  <a href=\"#\" data-action=\"{0}\">Spotify'ı tekrar başlatmalısın</a>",
  "usermessage.language-changed-simple": "Değişikliğin etkin olması için Spotify'ı tekrar başlatmalısın",
  "usermessage.proxysettings-changed-simple": "Değişikliğin etkin olması için Spotify'ı tekrar başlatmalısın",
  "usermessage.cache-changed": "Değişikliğin etkin olması için  <a href=\"#\" data-action=\"{0}\">Spotify'ı tekrar başlatmalısın</a>",
  "usermessage.cache-changed-simple": "Değişikliğin etkin olması için Spotify'ı tekrar başlatmalısın",
  "usermessage.feature-changed": "Değişikliğin etkin olması için  <a href=\"#\" data-action=\"{0}\">Spotify'ı tekrar başlatmalısın</a>",
  "usermessage.first-autostart": "Spotify otomatik olarak açıldı ama pencere konumuna küçültüldü. İstersen <a href=\"#\" data-action=\"{0}\">Spotify'ı küçültülmeden otomatik olarak açabilirsin</a> veya <a href=\"#\" data-action=\"{1}\">Spotify'ın başlangıçta açılmamasını</a> seçebilirsin.",
  "usermessage.cant-play-track": "Geçerli şarkı çalınamıyor.",
  "usermessage.cant-skip-ads": "Seçilen şarkı reklamdan sonra çalınacak",
  "usermessage.cant-offline-playlists": "Çevrimdışı modu Premium özelliğidir. <a href=\"#\" data-action=\"{0}\">Premium'u edin</a>.",
  "usermessage.cant-set-high-quality-streaming": "Bu özellik Premium'a özeldir. <a href=\"#\" data-action=\"{0}\">Premium'u edin</a>.",
  "usermessage.payment-state-creditcard-funds": "Bir ödeme sorunu nedeniyle üyeliğini yenileyemedik. Lütfen hesabında yeterli para olduğundan emin ol veya <a href=\"#\" data-action=\"{0}\">ödeme bilgilerini güncelle</a>.",
  "usermessage.payment-state-creditcard-refused": "Bir ödeme sorunu nedeniyle üyeliğini yenileyemedik. Üyeliğini devam ettirmek için lütfen <a href=\"#\" data-action=\"{0}\">ödeme bilgilerini güncelle</a>.",
  "usermessage.payment-state-paypal-refused": "Bir ödeme sorunu nedeniyle üyeliğini yenileyemedik. Üyeliğini devam ettirmek için lütfen <a href=\"#\" data-action=\"{0}\">ödeme bilgilerini güncelle</a>.",
  "usermessage.payment-state-creditcard-expiry": "Şu anda kullandığın ödeme kartı bir kaç gün içinde sona erecek. Üyeliğini devam ettirmek için lütfen <a href=\"#\" data-action=\"{0}\">ödeme bilgilerini güncelle</a>.",
  "usermessage.payment-state-prepaid-expiry": "Ön ödemeli üyeliğinin tarihi dolmak üzere. Endişelenme <a href=\"#\" data-action=\"{0}\">buradan Premium'a üye olabilirsin</a>.",
  "usermessage.payment-state-churn-payment": "Maalesef senden ödeme alamadık, o yüzden üyeliğini iptal etmek sorunda kaldık. Endişelenme, <a href=\"#\" data-action=\"{0}\">üyeliğini buradan yenileyebilirsin</a>.",
  "usermessage.payment-state-churn-partner": "Ortaklarımızdan biriyle olan üyeliğin sona erdi, şimdi Spotify Free kullanıyorsun. Endişelenme <a href=\"#\" data-action=\"{0}\">buradan Premium'a geri dönebilirsin</a>.",
  "usermessage.opt-in-trial": "Ücretsiz denemenin tadını çıkardığın umuyoruz! Premium sona erdiğinde üyeliğini kaybetmemek için <a href=\"#\" data-action=\"{0}\">bugün üye ol</a>.",
  "usermessage.opt-in-trial-expired": "Ücretsiz denemen sona erdi, şimdi Spotify Free kullanıyorsun. Endişelenme <a href=\"#\" data-action=\"{0}\">buradan Premium'a geri dönebilirsin</a>.",
  "usermessage.hardware-acceleration-changed": "Değişikliğin etkin olması için  <a href=\"#\" data-action=\"{0}\">Spotify'ı tekrar başlatmalısın</a>",
  "usermessage.hardware-acceleration-changed-simple": "Değişikliğin etkin olması için Spotify'ı tekrar başlatmalısın",
  "usermessage.some-local-tracks-not-saved": "Seçilen şarkıların bazıları Müziklerin'e kaydedilmedi. Yerel dosyalar Müziklerin tarafından desteklenmiyor.",
  "usermessage.illegal-playlist-name-entered": "Çalma listesi adı geçerli değil.",
  "usermessage.playlist-save-failed-unknown": "Çalma listesi bilinmeyen bir hata nedeniyle kaydedilemedi.",
  "usermessage.social-error-permissions": "Tüm müzik etkinliklerinin Facebook'ta paylaşılmasına izin vermek için <a href=\"#\" data-action=\"{0}\">buraya</a> tıkla.",
  "usermessage.shuffle-unplayable-track": "İstediğin şarkıyı istediğin zaman çalmak için <a href=\"#\" data-action=\"{0}\">Premium'a yükselt</a>.",
  "usermessage.shuffle-ran-out-of-skips": "Atlama hakların tükendi (bu saat için). İstediğin sıklıkta parça atlamak için <a href=\"#\" data-action=\"{0}\">Premium'a yükselt</a>.",
  "usermessage.playlist-limit-exceeded": "Bu çalma listesini izin verilen en yüksek sayıda doldurdun. Etkileyici. Parça toplamaya devam etmek için hemen yeni bir liste başlat.",
  "usermessage.collection-limit-exceeded": "Parça toplamada tarih yazdın. Müziklerin sonuna kadar doldu. Başka parçalar kaydedebilmek için bazı şarkıları silmen gerekecek.",
  "usermessage.deprecating-os-version": "Dikkat! Gelecek sürümlerimizden birinde kullandığın işletim sistemine ilişkin desteğimizi sonlandıracağız. Daha fazla bilgi için <a href=\"#\" data-action=\"{0}\">buraya</a> tıkla.",
  "usermessage.image-upload-propagation": "Başarılı! (Resimlerin yayılması 24 saate kadar sürebilir)",
  "usermessage.approaching-capping-limit": "1 saatten daha az ücretsiz dinleme hakkın kaldı. Her ay 15 saat ücretsiz müzik dinlemenin tadını çıkart veya <a href=\"#\" data-action=\"{0}\">Premium'a yükselterek</a> sınırsız müzik dinle. <a href=\"#\" data-action=\"{1}\">Daha fazla bilgi al</a>.",
  "usermessage.half-capping-limit-passed": "Aylık limitinin yarısını kullandın. Her ay 15 saat ücretsiz müzik dinlemenin tadını çıkart veya <a href=\"#\" data-action=\"{0}\">Premium'a yükselterek</a> sınırsız müzik dinle. <a href=\"#\" data-action=\"{1}\">Daha fazla bilgi al</a>.",
  "usermessage.video-georestricted": "Şu anda bulunduğun yerde bu videoyu oynatamıyoruz.",
  "usermessage.video-unsupported-client-version": "Bu videoyu oynatmak için lütfen Spotify'ı yükselt.",
  "usermessage.video-unsupported-platform-version": "Bu video senin işletim sistemi sürümünde oynatılamaz.",
  "usermessage.video-country-restricted": "Şu anda bulunduğun yerde bu videoyu oynatamıyoruz.",
  "usermessage.video-unavailable": "Bu video kullanılamaz. Başka bir tane denemek ister misin?",
  "usermessage.video-catalogue-restricted": "Üzgünüz, bu videoyu oynatamıyoruz.",
  "usermessage.video-playback-error": "Üzgünüz, bu videoyu oynatamıyoruz.",
  "about.title_label": "Spotify Hakkında",
  "about.close_button_label": "Kapat",
  "offline-progress-msg": "{0} / {1} şarkı çevrimdışı eşitleniyor",
  "tos.updated_terms": "Güncellenen şartlar",
  "tos.modal_title": "Spotify Kullanım Şart ve Koşulları",
  "tos.tos_text": "<p><a href=\"{0}\">Kullanım Şart ve Koşullarımızı</a> ve <a href=\"{1}\">Gizlilik Politikamızı</a> revize ettik.</p><p>Spotify'ı kullanmaya devam ederek bu güncellenmiş şartları kabul etmiş olursun, bu nedenle bunları okuyup anlamak için lütfen birkaç dakikanı ayır.</p>",
  "tos.not_now_tos_text": "<p><a href=\"{0}\">Kullanım Şart ve Koşullarımızı</a> ve <a href=\"{1}\">Gizlilik Politikamızı </a> revize ettik.</p><p>&quot;Kabul et&quot;e tıklayarak bu güncellemeleri (ve verilerinin açıklandığı şekilde işlenmesini) kabul etmiş olacağın için, bunları okumak ve anlamak amacıyla lütfen birkaç dakikanı ayır.</p>",
  "tos.tos_text2": "<p>Artık Spotify'ı kullanmak istemiyorsan Spotify üyelik sayfanı ziyaret ederek üyeliğini iptal edebilirsin.</p>",
  "tos.not_now_text": "<p>Güncellenen Şartlar ve Koşullar'ı ve Gizlilik Politikası'nı kabul etmeden Spotify'ı {0} gün daha kullanmaya devam edebilirsin. O tarihte, Spotify'ı kullanmaya devam etmek için yeni şartları kabul etmen zorunlu hale gelecektir. Üyeliğini iptal etmemen durumunda, normal faturalandırma döngüne göre aylık olarak faturalandırılmaya devam edeceksin. Spotify'a tekrar ödeme yapmak istemiyorsan, istediğin zaman Spotify üyelik sayfana giderek üyeliğini iptal edebilirsin.</p>",
  "tos.not_now_last_day_text": "<p>Güncellenen Şartlar ve Koşullar ile Gizlilik Politikasını kabul etmeden 1 gün boyunca Spotify'ı kullanmaya devam edebilirsin. Bu süre içinde yeni şartları kabul etmezsen artık Spotify'ı kullanamazsın. Üyeliğini iptal etmediğin sürece düzenli fatura döngünde fatura almaya devam edeceksin. Spotify'ın yeniden senden ücret almasını istemiyorsan istediğin zaman Spotify üyelik sayfanı ziyaret ederek üyeliğini iptal edebilirsin.</p>",
  "tos.not_now_text_germany": "<p><a href=\"{0}\">Kullanım Şart ve Koşullarımızı</a> ve <a href=\"{1}\">Gizlilik Politikamızı</a> revize ettik. Spotify GmbH, senin onayınla sözleşmeni Birger Jarlsgatan 61, 113 56 Stockholm, İsveç adresindeki Spotify AB'ye aktarmak istiyor.</p><p>Spotify hizmetini şu anki koşullarla {2} tarihine kadar kullanmaya devam edebilirsin. Bu tarihten sonra, Spotify hizmetini kullanmaya devam edebilmek için yeni Şartlar ve Koşulları ve Gizlilik Politikasını kabul etmen gerekir. &quot;Kabul ediyorum&quot;u tıklayarak,</p><p>a) sözleşmenin Spotify GmbH'den Spotify AB'ye aktarılmasını,<br />b) Kullanım Şartları ve Koşullarında yapılan güncellemeleri ve<br />c) kişisel verilerinin Gizlilik Politikasının 4, 5 ve 7. bölümlerinde açıklandığı şekilde toplanmasını, işlenmesini ve kullanılmasını onaylamış olursun.</p>",
  "tos.not_now_text2_germany": "<p>Güncellenen Şartlar ve Koşullar'ı ve Gizlilik Politikası'nı kabul etmeden Spotify'ı {0} tarihine kadar kullanmaya devam edebilirsin. Bu tarihte, Spotify'ı kullanmaya devam etmek için yeni şartları kabul etmen zorunlu hale gelecektir. Premium kullanıcısıysan, üyeliğini iptal etmemen durumunda normal faturalandırma döngüne göre aylık olarak faturalandırılmaya devam edeceksin. Spotify'a tekrar ödeme yapmak istemiyorsan, istediğin zaman Spotify üyelik sayfana giderek üyeliğini iptal edebilirsin.</p>",
  "tos.not_now_expired_text_germany": "<p><a href=\"{0}\">Kullanım Şart ve Koşullarımızı</a> ve <a href=\"{1}\">Gizlilik Politikamızı</a> revize ettik.</p><p>Spotify GmbH, senin onayınla sözleşmeni Birger Jarlsgatan 61, 113 56 Stockholm, İsveç adresindeki Spotify AB'ye aktarmak istiyor.</p><p>Spotify hizmetini kullanmaya devam edebilmek için yeni Şartlar ve Koşullar ile Gizlilik Politikasını kabul etmen gerekir. &quot;Kabul ediyorum&quot;u tıklayarak,</p><p>a) sözleşmenin Spotify GmbH'den Spotify AB'ye aktarılmasını,<br />b) Kullanım Şartları ve Koşullarında yapılan güncellemeleri ve<br/>c) kişisel verilerinin Gizlilik Politikasının 4, 5 ve 7. bölümlerinde açıklandığı şekilde toplanmasını, işlenmesini ve kullanılmasını onaylamış olursun.</p>",
  "tos.back_button_label": "Geri",
  "tos.ok_button_label": "Tamam",
  "tos.agree_button_label": "Kabul Et",
  "tos.cancel_button_label": "Reddet",
  "tos.not_now_button_label": "Şimdi değil",
  "licenses.modal_title": "Üçüncü taraf lisanslar",
  "licenses.close_button_label": "Kapat",
  "feedback.beta_title": "Beta Sürümü",
  "feedback.beta_text": "Bir şeyi çok sevdin veya nefret mi ettin? Bize söyle.",
  "market.ad": "Andorra",
  "market.ar": "Arjantin",
  "market.at": "Avusturya",
  "market.au": "Avustralya",
  "market.be": "Belçika",
  "market.bg": "Bulgaristan",
  "market.bo": "Bolivya",
  "market.br": "Brezilya",
  "market.ca": "Kanada",
  "market.ch": "İsviçre",
  "market.cl": "Şili",
  "market.co": "Kolombiya",
  "market.cr": "Kosta Rika",
  "market.cy": "Kıbrıs",
  "market.cz": "Çek Cumhuriyeti",
  "market.de": "Almanya",
  "market.dk": "Danimarka",
  "market.do": "Dominik Cumhuriyeti",
  "market.ec": "Ekvador",
  "market.ee": "Estonya",
  "market.es": "İspanya",
  "market.fi": "Finlandiya",
  "market.fr": "Fransa",
  "market.gr": "Yunanistan",
  "market.gt": "Guatemala",
  "market.hk": "Hong Kong",
  "market.hn": "Honduras",
  "market.hu": "Macaristan",
  "market.ie": "İrlanda",
  "market.is": "İzlanda",
  "market.it": "İtalya",
  "market.jp": "Japonya",
  "market.li": "Lihtenştayn",
  "market.lt": "Litvanya",
  "market.lu": "Lüksemburg",
  "market.lv": "Letonya",
  "market.mc": "Monako",
  "market.mt": "Malta",
  "market.mx": "Meksika",
  "market.my": "Malezya",
  "market.ni": "Nikaragua",
  "market.nl": "Hollanda",
  "market.no": "Norveç",
  "market.nz": "Yeni Zelanda",
  "market.pa": "Panama",
  "market.pe": "Peru",
  "market.ph": "Filipinler",
  "market.pl": "Polonya",
  "market.pt": "Portekiz",
  "market.py": "Paraguay",
  "market.se": "İsveç",
  "market.sg": "Singapur",
  "market.sk": "Slovakya",
  "market.sv": "El Salvador",
  "market.tr": "Türkiye",
  "market.tw": "Tayvan",
  "market.uk": "Birleşik Krallık",
  "market.us": "Amerika Birleşik Devletleri",
  "market.uy": "Uruguay",
  "market.za": "Güney Afrika",
  "sTitle": "Düşüncelerini paylaş ve dünyanın en harika müzik hizmetini geliştirmemize yardımcı ol!",
  "sQ1Question": "Spotify'ı bir arkadaşına veya iş arkadaşına önerme olasılığın nedir?",
  "sQ1Negative": "Pek olası değil",
  "sQ1Positive": "Son derece olası",
  "sQ2Question": "Neden böyle düşünüyorsun?",
  "sQ3Question": "Spotify ile ilgili genel olarak memnun musun?",
  "sQ3Negative": "Hiç memnun değilim",
  "sQ3Positive": "Çok memnunum",
  "sSubmit": "Anketi ilet",
  "sThanks": "Yardımcı olduğun için teşekkür ederiz. Zaman ayırman bizi çok mutlu etti.",
  "sTeam": "Spotify Ekibi",
  "sClose": "Kapat",
  "cls.highlight": "Premium duraklatıldı",
  "cls.title": "Son ödemen alınamadı.",
  "cls.desc": "Yeni bir ödeme yöntemi ekleyerek Premium ile dinlemeye devam et. Bu işlem yalnızca birkaç saniye sürer.",
  "cls.updatePayment": "Ödemeyi güncelle",
  "cls.cancelSubscription": "Ayrıca, <a class=\"cancel-sub\" href=\"#cancel\">Premium üyeliğini iptal ederek</a><br>Spotify Free sürümüne de dönebilirsin.",
  "capping.upsell-title": "Ücretsiz dinleme sınırına ulaştın.",
  "capping.upsell-message": "Her ay 15 saat ücretsiz müzik dinleme hakkın olur<br />Reklamlar olmadan sınırsız müzik dinlemek için Premium'a yükselt.",
  "capping.upsell-button-label": "Premium'a Yükselt",
  "capping.defaultRefillMessage": "Ücretsiz dinleme hakkın yakında yenilenecek.",
  "capping.refillMessage": "Ücretsiz dinleme hakkın {0} gün içinde yenilenecek.",
  "capping.welcome-title": "Spotify'a Hoşgeldin.",
  "capping.welcome-message": "Her ay 15 saat ücretsiz müzik dinlemenin keyfini çıkar.<br> Reklam olmadan sınırsız müzik dinlemek için<a data-action={0}>Premium'a Yükselt.</a>",
  "capping.welcome-message-button-label": "Başla",
  "yourArtistsTooltipTitle": "Sanatçılarını yönet",
  "yourArtistsTooltipText": "Şimdi, Spotify'da sanatçı profil resmini kolayca düzenleyebilirsin.",
  "yourArtists": "Sanatçıların"
};
},{}],19:[function(require,module,exports){
module.exports = {
  "browse.app_name": "瀏覽",
  "latest-releases.app_name": "最新發行",
  "discover.app_name": "發掘更多",
  "activity.app_name": "個人動態",
  "radio.app_name": "電台",
  "settings.app_name": "設定",
  "messages.app_name": "訊息",
  "profile.app_name": "個人檔案",
  "notifications_center.app_name": "通知",
  "concerts.app_name": "演唱會",
  "profile.private_session": "私人工作階段",
  "profile.upgrade": "升級",
  "profile.upgrade_account": "升級帳戶",
  "profile.upgrade_tooltip": "升級為 Premium",
  "profile.account": "帳戶",
  "profile.logout": "登出",
  "profile.enabled": "已啟用",
  "profile.menu_label": "選單",
  "profile.switch": "切換使用者",
  "profile.new_user": "切換為新使用者",
  "your_music.app_name": " 你的音樂",
  "your_music.songs": "歌曲",
  "your_music.artists": "藝人",
  "your_music.albums": "專輯",
  "your_music.stations": "電台",
  "your_music.local_files": "本機檔案",
  "sidebar.title_main": "主要",
  "sidebar.title_playlists": "播放列表",
  "new_playlist.input_placeholder": "新播放列表",
  "new_playlist.button": "新播放列表",
  "accessibilitylinks.skip_to_content_label": "略過至主內容",
  "accessibilitylinks.skip_to_player_label": "略過至播放器控制",
  "playlist.by": "- {0}",
  "playlist.loading": "載入中…",
  "playlist.newfolder": "新資料夾",
  "playlist.delete_message": "確定要刪除此播放清單嗎？",
  "playlist.unfollow_message": "確定要停止關注這個播放清單嗎？",
  "playlistfolder.delete_message": "是否確定要刪除此資料夾及其中的所有播放清單？",
  "playlist.delete_confirm": "刪除",
  "playlist.unfollow_confirm": "取消關注",
  "playlist.delete_cancel": "取消",
  "playlist.duplicates_dialog_title": "重複的歌曲",
  "playlist.duplicates_dialog_title_single": "重複的歌曲",
  "playlist.duplicates_dialog_body": "這些歌曲中已有部分在你的播放清單中。",
  "playlist.duplicates_dialog_body_single": "這首歌曲已在你的播放清單中。",
  "playlist.duplicates_dialog_button_add": "新增全部",
  "playlist.duplicates_dialog_button_add_single": "仍要新增",
  "playlist.duplicates_dialog_button_skip_duplicates": "略過重複的內容",
  "playlist.duplicates_dialog_button_skip_single": "略過重複的內容",
  "playlist.annotate_form.new_playlist_name": "新播放列表",
  "playlist.annotate_form.create_title": "建立播放清單",
  "playlist.annotate_form.create": "建立",
  "playlist.annotate_form.cancel": "取消",
  "playlist.annotate_form.edit_title": "編輯播放清單詳細資料",
  "playlist.annotate_form.save": "儲存",
  "playlist.annotate_form.name_field_label": "名稱",
  "playlist.annotate_form.name_field_placeholder": "播放清單名稱",
  "playlist.annotate_form.image_field_label": "影像",
  "playlist.annotate_form.image_pick_button_label": "選擇影像",
  "playlist.annotate_form.image_replace_button_label": "更換影像",
  "playlist.annotate_form.image_remove_button_label": "移除影像",
  "playlist.annotate_form.image_file_size_exceeded": "影像尺寸過大，最大上限：4MB。",
  "playlist.annotate_form.image_file_upload_failed": "影像上傳失敗，請再試一次。",
  "playlist.annotate_form.annotate_failed": "說明及影像更新失敗，請再試一次。",
  "playlist.annotate_form.close-error-bar": "隱藏",
  "playlist.annotate_form.description_field_label": "說明",
  "playlist.annotate_form.description_field_placeholder": "為你的播放清單加上吸引人的說明。",
  "playlist.annotate_form.permission_message": "執行此動作，即表示你允許 Spotify 存取你選擇上傳的影像。請確定你有權上傳影像。影像只會用在播放清單封面。",
  "playlist.annotate_form.insert_link_button_label": "插入連結",
  "playlist.annotate_form.insert_link.link_field_label": "連結至",
  "playlist.annotate_form.insert_link.change_button_label": "變更",
  "playlist.annotate_form.insert_link.remove_button_label": "移除",
  "playlist.annotate_form.insert_link.done_button_label": "完成",
  "playlist.annotate_form.drop_to_set_image_label": "拖放以設置影像",
  "playlist.annotate_form.drop_not_allowed_label": "不支援的格式",
  "playlist.annotate_form.error.file_not_valid_jpg": "檔名雖然看似正確，但該檔案並不是有效的 JPG 檔。",
  "playlist.annotate_form.error.name_required": "你必須為你的播放清單命名。",
  "playlist.annotate_form.error.selection_required_to_insert_link": "你必須選擇你想要使其變成連結的文字內容。",
  "playlist.annotate_form.error.html_not_allowed": "你似乎想要使用 HTML，請注意不能使用此語法。",
  "playlist.annotate_form.error.submit": "儲存播放清單變更失敗，請再試一次。",
  "playlist.annotate_form.error.image_too_small": "影像過小。影像大小必須至少為 {0}x{1}。",
  "playlist.annotate_form.warning.client_offline": "找不到網際網路連線。說明和影像的變更將不會儲存。",
  "playlist.annotate_form.warning.no_line_breaks_in_description": "很抱歉，此說明並不支援換行符號。",
  "playlist.annotate_form.warning.unsaved_changes": "確定不儲存變更嗎？",
  "navigation.label": "導航",
  "navigation.back_button_label": "返回",
  "navigation.forward_button_label": "下一頁",
  "search.input_placeholder": "搜尋",
  "player.label": "播放器控制",
  "player.shuffle_mode_label": "隨機播放",
  "player.repeat_mode_label": "重覆播放",
  "player.queue": "佇列",
  "player.volume_button_label": "音量",
  "player.spotify_connect": "Spotify Connect",
  "player.connect_button_label": "連接至裝置",
  "player.lyrics_label": "歌詞",
  "player.play_button_label": "播放",
  "player.pause_button_label": "暫停",
  "player.previous_button_label": "上一步",
  "player.next_button_label": "下一步",
  "player.offline_label": "離線",
  "player.thumb_up_label": "喜歡",
  "player.thumb_down_label": "不喜歡",
  "playererror.default": "試圖播放所選歌曲時發生錯誤。",
  "playererror.track_not_available": "無法播放這首歌曲",
  "nowplaying.label": "現正播放",
  "nowplaying.go_to_context": "前往「正在播放」",
  "nowplaying.save_your_music": "儲存至你的音樂",
  "nowplaying.remove_your_music": "從你的音樂中移除",
  "nowplaying.playing_suggested_track": "現正播放推薦歌曲",
  "connect.connect_text": "連接至裝置",
  "connect.device_connecting": "連線中…",
  "connect.device_incompatible": "不相容",
  "connect.device_premium_only": "僅限 Premium 使用者",
  "connect.device_sleeping": "裝置睡眠中",
  "connect.device_tech_cast": "Google Cast",
  "connect.device_tech_connect": "Spotify Connect",
  "connect.device_this_computer": "這部電腦",
  "connect.device_unavailable_for_playback": "無法從以下裝置收聽",
  "connect.device_unknown": "未知的裝置",
  "connect.device_unsupported_uri": "目前無法播放此內容",
  "connect.devices_available": "可用的裝置",
  "connect.dismiss": "忽略",
  "connect.help1": "Connect 可讓你在裝置上播放及控制 Spotify。",
  "connect.help2": "在其他裝置上開啟 Spotify，它會神奇地出現在這裡。",
  "connect.help_hint": "什麼是 Connect？",
  "connect.offline": "無法使用",
  "connect.offline_reason_computer": "Spotify 沒有在這部裝置上啟用。",
  "connect.offline_reason_generic": "Spotify 沒有在這部裝置上啟用。",
  "connect.offline_reason_phone": "手機已鎖定，或 Spotify 已退至背景中。",
  "connect.offline_reason_gameconsole": "用 Spotify PlayStation 應用程式的啟動設定，即可將 PlayStation 從待命模式喚醒。",
  "connect.offline_text1": "你需要連線以使用這個功能。",
  "connect.offline_title": "你目前為離線狀態。",
  "connect.playingon": "播放自",
  "connect.popup_title": "裝置",
  "connect.remoteplayback": "播放自：{0}",
  "connect.show_more": "顯示更多",
  "connect.upgrade": "升級",
  "connect.upsell": "Connect 是一項 Premium 功能，可讓你在裝置上播放及控制 Spotify。",
  "contextmenu.new-playlist": "新播放列表",
  "contextmenu.add-to-playlist": "新增至播放列表",
  "contextmenu.owner-playlist": "- {0}",
  "contextmenu.copy-uri": "複製 Spotify URI",
  "contextmenu.copy-artist-url": "複製藝人連結",
  "contextmenu.copy-album-url": "複製專輯連結",
  "contextmenu.copy-track-url": "複製歌曲連結",
  "contextmenu.copy-playlist-url": "複製播放清單連結",
  "contextmenu.copy-profile-url": "複製個人檔案連結",
  "contextmenu.copy-station-url": "複製電台連結",
  "contextmenu.copy-chart-url": "複製排行榜連結",
  "contextmenu.copy-url": "複製連結",
  "contextmenu.copy-embed": "複製內嵌程式碼",
  "contextmenu.collaborative": "協作播放清單",
  "contextmenu.save": "儲存至你的音樂",
  "contextmenu.remove": "從你的音樂中移除",
  "contextmenu.delete-playlist": "刪除",
  "contextmenu.follow": "關注",
  "contextmenu.unfollow": "取消關注",
  "contextmenu.publish": "設為公開",
  "contextmenu.unpublish": "設為私密",
  "contextmenu.playlist.loading": "載入中…",
  "contextmenu.play": "播放",
  "contextmenu.add-to-queue": "加入至播放隊列",
  "contextmenu.station": "前往電台",
  "contextmenu.station-album": "前往專輯電台",
  "contextmenu.station-artist": "前往藝人電台",
  "contextmenu.station-playlist": "前往播放清單電台",
  "contextmenu.station-track": "前往歌曲電台",
  "contextmenu.station-chart": "前往排行榜電台",
  "contextmenu.remove-from-playlist": "從此播放清單中移除",
  "contextmenu.remove-from-queue": "從佇列中移除",
  "contextmenu.rename-folder": "重新命名",
  "contextmenu.rename-playlist": "重新命名",
  "contextmenu.edit-playlist": "編輯詳細資料",
  "contextmenu.report-playlist": "回報",
  "contextmenu.report-asset": "回報",
  "contextmenu.share": "分享...",
  "contextmenu.share-lyrics": "分享歌詞",
  "contextmenu.create-folder": "建立資料夾",
  "contextmenu.create-playlist": "建立播放清單",
  "contextmenu.open-localfile-folder": "開啟子資料夾",
  "contextmenu.open-localfile-folder-mac": "在搜尋器中顯示",
  "contextmenu.offline": "離線時可用",
  "contextmenu.goto-artist": "前往歌手",
  "contextmenu.goto-album": "前往專輯",
  "usermessage.default-message": "發生錯誤",
  "usermessage.update-ready": "你好！我們已經為你準備好了最新版本的 Spotify。<a href=\"#\" data-action=\"{0}\">重新開啟</a>即可完成更新。",
  "usermessage.update-ready-simple": "你好！我們已經為你準備好了最新版本的 Spotify。重新開啟即可完成更新。",
  "usermessage.play-token-lost": "您的帳戶正在其他地方使用，Spotify 已暫停。",
  "usermessage.playback-paused-inactive": "你的電腦已閒置時間過久，請按下播放繼續收聽！想無間斷欣賞音樂，請立即訂閱 <a href=\"#\" data-action=\"{0}\">Spotify Premium</a>。",
  "usermessage.not-available-offline": "偵測不到網際網路連線。找到網路連線後，Spotify 會自動重新連線 (錯誤代碼：4)",
  "usermessage.track-not-available-in-region": "目前無法在 {0} 收聽這首歌曲。如果電腦裡有該檔案，可將歌曲匯入。",
  "usermessage.track-not-available-in-region-generic": "你居住的國家/地區目前無法收聽這首歌曲。如果電腦裡有該檔案，可將歌曲匯入。",
  "usermessage.track-not-available": "無法播放這首歌曲。如果電腦裡有該檔案，可將歌曲匯入。",
  "usermessage.track-not-available-forced-offline": "請<a href=\"#\" data-action=\"goOnline\">關閉離線模式</a>然後再試一次。",
  "usermessage.track-exclusive-premium": "此歌曲為 <a href=\"#\" data-action=\"{0}\">Spotify Premium</a> 使用者獨家提供。",
  "usermessage.track-banned-by-artist": "此藝人/唱片公司關閉了這首歌曲的播放功能。如果電腦裡有該檔案，可將歌曲匯入。",
  "usermessage.local-track-no-file": "此歌曲被新增為本機檔案。如果電腦裡有該檔案，可將歌曲匯入。",
  "usermessage.local-track-file-not-found": "找不到檔案，無法播放這首歌曲。請重新匯入。",
  "usermessage.local-track-bad-format": "檔案格式不明，按一下<a href=\"#\" data-action=\"{0}\">這裡</a>了解更多資訊。",
  "usermessage.capping-reached": "你已經超過 {0} 小時的時間限制。<a href=\"#\" data-action=\"{1}\">升級為 Spotify Premium 會員</a>即可享受沒有限制的音樂聆賞體驗。",
  "usermessage.local-track-drm-protected": "由於檔案受數位版權管理 (DRM) 保護，因此不得播放這首歌曲。",
  "usermessage.offline-disk-cache": "下載離線歌曲失敗，請檢查硬碟空間是否已滿。",
  "usermessage.offline-sync-expired": "離線歌曲已經過期。請登入 Spotify 帳戶重新啟動。",
  "usermessage.offline-sync-failed": "部分離線歌曲下載失敗。",
  "usermessage.offline-too-many-tracks": "選取的歌曲超過離線模式所設上限。",
  "usermessage.offline-license-server-error": "Spotify 伺服器發生錯誤。",
  "usermessage.offline-license-lost": "這台電腦/裝置的離線存取已被取消。",
  "usermessage.offline-not-allowed": "離線模式是 <a href=\"#\" data-action=\"{0}\">Spotify Premium</a> 的獨家功能。",
  "usermessage.language-changed": "你必須<a href=\"#\" data-action=\"{0}\">重新開啟 Spotify </a>才能讓變更生效。",
  "usermessage.proxysettings-changed": "你必須<a href=\"#\" data-action=\"{0}\">重新開啟 Spotify </a>才能讓變更生效。",
  "usermessage.language-changed-simple": "你必須重新開啟 Spotify 才能讓變更生效。",
  "usermessage.proxysettings-changed-simple": "你必須重新開啟 Spotify 才能讓變更生效。",
  "usermessage.cache-changed": "你必須<a href=\"#\" data-action=\"{0}\">重新開啟 Spotify </a>才能讓變更生效。",
  "usermessage.cache-changed-simple": "你必須重新開啟 Spotify 才能讓變更生效。",
  "usermessage.feature-changed": "你必須<a href=\"#\" data-action=\"{0}\">重新開啟 Spotify </a>才能讓變更生效。",
  "usermessage.first-autostart": "Spotify 已自動開啟但最小化。你可以選擇<a href=\"#\" data-action=\"{0}\">自動開啟 Spotify 但不要最小化</a>，或完全<a href=\"#\" data-action=\"{1}\">不要在開始時開啟 Spotify</a>。",
  "usermessage.cant-play-track": "無法播放目前歌曲 。",
  "usermessage.cant-skip-ads": "所選的歌曲將在廣告後播放",
  "usermessage.cant-offline-playlists": "離線模式是 Spotify Premium 的獨家功能。<a href=\"#\" data-action=\"{0}\">成為 Premium 會員</a>。",
  "usermessage.cant-set-high-quality-streaming": "此為 Spotify Premium 的獨家功能。<a href=\"#\" data-action=\"{0}\">成為 Premium 會員</a>。",
  "usermessage.payment-state-creditcard-funds": "由於付款方面的問題，導致你的訂閱項目無法續訂。請確認你的帳戶中有足夠金額，或 <a href=\"#\" data-action=\"{0}\">更新你的付款資料</a>。",
  "usermessage.payment-state-creditcard-refused": "由於付款方面的問題，導致你的訂閱項目無法續訂。若要保有你的訂閱項目，請<a href=\"#\" data-action=\"{0}\">更新你的付款資料</a>。",
  "usermessage.payment-state-paypal-refused": "由於付款方面的問題，導致你的訂閱項目無法續訂。若要保有你的訂閱項目，請<a href=\"#\" data-action=\"{0}\">更新你的付款資料</a>。",
  "usermessage.payment-state-creditcard-expiry": "你目前用以付款的信用卡將於數日內到期。若要保有你的訂閱項目，請<a href=\"#\" data-action=\"{0}\">更新你的付款資料</a>。",
  "usermessage.payment-state-prepaid-expiry": "你預先付費的訂閱項目即將到期。別擔心，你可以<a href=\"#\" data-action=\"{0}\">在此訂閱 Premium</a>。",
  "usermessage.payment-state-churn-payment": "很抱歉，由於我們無法取得你的付款，因此必須取消你的訂閱項目。別擔心，你可以<a href=\"#\" data-action=\"{0}\">在此續訂你的訂閱項目</a>。",
  "usermessage.payment-state-churn-partner": "你對 Spotify 合作夥伴的訂閱項目已經結束，因此，你目前使用的是 Spotify 免費版。別擔心，你可以<a href=\"#\" data-action=\"{0}\">在此重新訂閱 Premium</a>。",
  "usermessage.opt-in-trial": "希望你可以盡情享受免費試用！不過，若你想在免費試用期結束後保有 Premium 會員資格，<a href=\"#\" data-action=\"{0}\">請立即訂閱</a>。",
  "usermessage.opt-in-trial-expired": "你的免費試用期已經結束，你目前所使用的是 Spotify 免費版。別擔心，你可以<a href=\"#\" data-action=\"{0}\">在此重新訂閱 Premium</a>。",
  "usermessage.hardware-acceleration-changed": "你必須<a href=\"#\" data-action=\"{0}\">重新開啟 Spotify </a>才能讓變更生效。",
  "usermessage.hardware-acceleration-changed-simple": "你必須重新開啟 Spotify 才能讓變更生效。",
  "usermessage.some-local-tracks-not-saved": "你所選擇的某些歌曲並未儲存至「你的音樂」。「你的音樂」無法支援本機檔案。",
  "usermessage.illegal-playlist-name-entered": "所輸入的播放清單名稱無效。",
  "usermessage.playlist-save-failed-unknown": "發生未知的錯誤，因此無法儲存播放清單。",
  "usermessage.social-error-permissions": "按一下<a href=\"#\" data-action=\"{0}\">此處</a>將你的音樂活動分享於 Facebook 上。",
  "usermessage.shuffle-unplayable-track": "<a href=\"#\" data-action=\"{0}\">升級為 Premium</a> 即可讓你隨時隨地播放任何歌曲。",
  "usermessage.shuffle-ran-out-of-skips": "你已達到切換歌曲上限（這一小時之內）。<a href=\"#\" data-action=\"{0}\">升級為 Premium</a> 即可不限次數切換歌曲。",
  "usermessage.playlist-limit-exceeded": "您的播放清單歌曲數量已滿。真驚人。新建一個播放清單，開始收集更多歌曲吧。",
  "usermessage.collection-limit-exceeded": "這是一套經典的合輯。「你的音樂」已經裝滿音樂了。若要儲存更多音樂，您需要移除一些歌曲。",
  "usermessage.deprecating-os-version": "請注意！我們將從下個版本起，停止支援你所使用的作業系統。請按一下<a href=\"#\" data-action=\"{0}\">這裡</a>了解更多資訊。",
  "usermessage.image-upload-propagation": "成功！（圖像最多可能需要 24 小時來更新完成）",
  "usermessage.approaching-capping-limit": "你只剩不到 1 小時可以免費收聽。你可以選擇每個月免費收聽 15 小時，或是<a href=\"#\" data-action=\"{0}\">升級成 Premium</a> 不限時數收聽音樂。<a href=\"#\" data-action=\"{1}\">進一步瞭解</a>。",
  "usermessage.half-capping-limit-passed": "你已經用了每月上限的一半。你可以選擇每個月免費收聽 15 小時，或是<a href=\"#\" data-action=\"{0}\">升級成 Premium</a> 不限時數收聽音樂。<a href=\"#\" data-action=\"{1}\">進一步瞭解</a>。",
  "usermessage.video-georestricted": "我們無法在你目前的位置播放此影片。",
  "usermessage.video-unsupported-client-version": "若要播放此影片，請升級 Spotify。",
  "usermessage.video-unsupported-platform-version": "這段影片無法在你的作業系統版本播放。",
  "usermessage.video-country-restricted": "我們無法在你目前的位置播放此影片。",
  "usermessage.video-unavailable": "無法播放這部影片。改播其它影片好嗎？",
  "usermessage.video-catalogue-restricted": "抱歉，我們無法播放此影片。",
  "usermessage.video-playback-error": "抱歉，我們無法播放此影片。",
  "about.title_label": "關於 Spotify",
  "about.close_button_label": "關閉",
  "offline-progress-msg": "離線同步第 {0} 首歌曲（共 {1} 首）",
  "tos.updated_terms": "更新條款",
  "tos.modal_title": "Spotify 使用條款及條件",
  "tos.tos_text": "<p>Spotify 已修訂了我們的《<a href=\"{0}\">使用條款與條件</a>》及《<a href=\"{1}\">隱私權政策</a>》 。 </p><p>繼續使用 Spotify，即表示你同意此等更新條款，因此，請花幾分鐘的時間詳閱並瞭解各項內容。</p>",
  "tos.not_now_tos_text": "<p>Spotify 已修訂了《<a href=\"{0}\">使用條款與條件</a>》及《<a href=\"{1}\">隱私權政策</a>》 。 </p><p>按下「接受」即表示你同意此等更新內容 (以及同意你的個人資訊依所述進行處理)，因此，請花幾分鐘的時間詳閱並瞭解各項內容。</p>",
  "tos.tos_text2": "<p>如果不希望繼續使用 Spotify，你可以前往你的 Spotify 訂閱頁面取消訂閱。</p>",
  "tos.not_now_text": "<p>如果不接受新的《條款與條件》及《隱私權政策》，你可以繼續使用 Spotify {0} 天。期限屆滿之後，我們將會要求你接受新的條款，以繼續使用 Spotify。除非你取消訂閱，否則我們每個月將會繼續依據你的帳單週期向你收取費用。如果不想要 Spotify 再向你收取費用，你可以隨時前往 Spotify 訂閱頁面取消你的訂閱。</p>",
  "tos.not_now_last_day_text": "<p>你可以在不接受已更新之《條款與條件》及《隱私權政策》的情況下繼續使用 Spotify 1 天。如果在期限前仍不接受新條款，你將無法繼續使用 Spotify。除非你取消訂閱，否則我們仍將按正常結算週期每月向你收取費用。如果不希望 Spotify 再向你收費，你可以隨時前往你的 Spotify 訂閱頁面取消訂閱。</p>",
  "tos.not_now_text_germany": "<p>我們已修訂了<a href=\"{0}\">《使用條款與條件》</a>及<a href=\"{1}\">《隱私權政策》</a>。請注意，在你的同意之下，Spotify GmbH 公司擬將你的合約轉移至 Spotify AB 公司（Birger Jarlsgatan 61, 113 56 瑞典斯德哥爾摩）。</p><p>你可以根據現有的合約繼續使用 Spotify 服務，直至 {2}。於該日期之後，為能繼續使用 Spotify 服務，你將必須接受新的《使用條款與條件》及《隱私權政策》。點選「接受」，即表示你同意：</p><p>a) 將你的合約從 Spotify GmbH 公司轉移至 Spotify AB 公司；<br />b) 《使用條款與條件》的更新內容；及 <br />c) 《隱私權政策》第 4、5 及 7 條款中所載明之個人資料之收集、處理與使用的各項規定。</p>",
  "tos.not_now_text2_germany": "<p>如果不接受新的《條款與條件》及《隱私權政策》，你可以繼續使用 Spotify 至 {0}。屆時，我們將會要求你接受新的條款，以繼續使用 Spotify。如果你是 Premium 會員，則除非你取消訂閱，否則我們每個月將會繼續依據你的帳單週期向你收取費用。如果不想要 Spotify 再向你收取費用，你可以隨時前往 Spotify 訂閱頁面取消你的訂閱。</p>",
  "tos.not_now_expired_text_germany": "<p>我們已修訂了<a href=\"{0}\">《使用條款與條件》</a>及<a href=\"{1}\">《隱私權政策》</a>。</p><p>請注意，在你的同意之下，Spotify GmbH 公司擬將你的合約轉移至 Spotify AB 公司（Birger Jarlsgatan 61, 113 56 瑞典斯德哥爾摩）。</p><p>為能繼續使用 Spotify 服務，你將必須接受新的《使用條款與條件》及《隱私權政策》。點選「接受」，即表示你同意：</p><p>a) 將你的合約從 Spotify GmbH 公司轉移至 Spotify AB 公司；<br />b) 《使用條款與條件》的更新內容；及 <br />c) 《隱私權政策》第 4、5 及 7 條款中所載明之個人資料之收集、處理與使用的各項規定。</p>",
  "tos.back_button_label": "返回",
  "tos.ok_button_label": "確定",
  "tos.agree_button_label": "接受",
  "tos.cancel_button_label": "拒絕",
  "tos.not_now_button_label": "現在不要",
  "licenses.modal_title": "第三方授權",
  "licenses.close_button_label": "關閉",
  "feedback.beta_title": "試用版",
  "feedback.beta_text": "討厭或喜愛什麼嗎？請告訴我們。",
  "market.ad": "安道爾",
  "market.ar": "阿根廷",
  "market.at": "奧地利",
  "market.au": "澳洲",
  "market.be": "比利時",
  "market.bg": "保加利亞",
  "market.bo": "玻利維亞",
  "market.br": "巴西",
  "market.ca": "加拿大",
  "market.ch": "瑞士",
  "market.cl": "智利",
  "market.co": "哥倫比亞",
  "market.cr": "哥斯大黎加",
  "market.cy": "賽普勒斯",
  "market.cz": "捷克共和國",
  "market.de": "德國",
  "market.dk": "丹麥",
  "market.do": "多明尼加共和國",
  "market.ec": "厄瓜多",
  "market.ee": "愛沙尼亞",
  "market.es": "西班牙",
  "market.fi": "芬蘭",
  "market.fr": "法國",
  "market.gr": "希臘",
  "market.gt": "瓜地馬拉",
  "market.hk": "香港",
  "market.hn": "宏都拉斯",
  "market.hu": "匈牙利",
  "market.ie": "愛爾蘭",
  "market.is": "冰島",
  "market.it": "義大利",
  "market.jp": "日本",
  "market.li": "列支敦斯登",
  "market.lt": "立陶宛",
  "market.lu": "盧森堡",
  "market.lv": "拉脫維亞",
  "market.mc": "摩納哥",
  "market.mt": "馬爾他",
  "market.mx": "墨西哥",
  "market.my": "馬來西亞",
  "market.ni": "尼加拉瓜",
  "market.nl": "荷蘭",
  "market.no": "挪威",
  "market.nz": "紐西蘭",
  "market.pa": "巴拿馬",
  "market.pe": "秘魯",
  "market.ph": "菲律賓",
  "market.pl": "波蘭",
  "market.pt": "葡萄牙",
  "market.py": "巴拉圭",
  "market.se": "瑞典",
  "market.sg": "新加坡",
  "market.sk": "斯洛伐克",
  "market.sv": "薩爾瓦多",
  "market.tr": "土耳其",
  "market.tw": "台灣",
  "market.uk": "英國",
  "market.us": "美國",
  "market.uy": "烏拉圭",
  "market.za": "南非",
  "sTitle": "分享你的感想，並幫助我們打造全球最大的音樂服務！",
  "sQ1Question": "你會推薦 Spotify 給好友或同事嗎？",
  "sQ1Negative": "完全不會",
  "sQ1Positive": "很有可能",
  "sQ2Question": "為什麼選擇推薦或不推薦？",
  "sQ3Question": "你對 Spotify 整體的滿意程度有多高？",
  "sQ3Negative": "非常不滿意",
  "sQ3Positive": "非常滿意",
  "sSubmit": "送出問卷",
  "sThanks": "感謝你抽空協助我們。",
  "sTeam": "Spotify 團隊",
  "sClose": "關閉",
  "cls.highlight": "Premium 已暫停",
  "cls.title": "你的上一次付款沒有成功。",
  "cls.desc": "若要繼續使用 Premium 會員資格享受音樂，請新增新的付款方式。這項程序很快就能完成。",
  "cls.updatePayment": "更新付款",
  "cls.cancelSubscription": "你也可以降級至 Spotify 免費版，<br>方法是<a class=\"cancel-sub\" href=\"#cancel\">取消你的 Premium 訂閱</a>。",
  "capping.upsell-title": "你已經用完免費收聽時數了。",
  "capping.upsell-message": "你每個月有 15 小時的免費收聽時間。<br />升級成 Premium，即可不限時數收聽音樂，而且不會有廣告出現。",
  "capping.upsell-button-label": "升級為 Premium",
  "capping.defaultRefillMessage": "你的免費收聽時間不久即將重新補滿。",
  "capping.refillMessage": "你的免費收聽時間將在 {0} 天內重新補滿。",
  "capping.welcome-title": "歡迎使用 Spotify。",
  "capping.welcome-message": "享受每個月 15 小時的免費收聽時間。<br /><a data-action={0}>升級成 Premium，即可不限時數收聽音樂，</a>而且不會有廣告出現。",
  "capping.welcome-message-button-label": "準備開始",
  "yourArtistsTooltipTitle": "管理藝人",
  "yourArtistsTooltipText": "現在你可以在 Spotify 輕輕鬆鬆編輯藝人個人檔案影像。",
  "yourArtists": "你的藝人"
};
},{}],20:[function(require,module,exports){
module.exports = {
  "browse.app_name": "Layari",
  "latest-releases.app_name": "Keluaran Baru",
  "discover.app_name": "Temui",
  "activity.app_name": "Aktiviti",
  "radio.app_name": "Radio",
  "settings.app_name": "Tetapan",
  "messages.app_name": "Mesej",
  "profile.app_name": "Profil",
  "notifications_center.app_name": "Pemberitahuan",
  "concerts.app_name": "Konsert",
  "profile.private_session": "Sesi Peribadi",
  "profile.upgrade": "Naik taraf",
  "profile.upgrade_account": "Naik Taraf Akaun Anda",
  "profile.upgrade_tooltip": "Naik Taraf kepada Premium",
  "profile.account": "Akaun",
  "profile.logout": "Log Keluar",
  "profile.enabled": "Dayakan",
  "profile.menu_label": "Menu",
  "profile.switch": "Tukar Pengguna",
  "profile.new_user": "Tukar kepada Pengguna Baharu",
  "your_music.app_name": "Muzik Anda",
  "your_music.songs": "Lagu",
  "your_music.artists": "Artis",
  "your_music.albums": "Album",
  "your_music.stations": "Stesen",
  "your_music.local_files": "Fail Tempatan",
  "sidebar.title_main": "Utama",
  "sidebar.title_playlists": "Senarai Main",
  "new_playlist.input_placeholder": "Playlist Main Baru",
  "new_playlist.button": "Playlist Main Baru",
  "accessibilitylinks.skip_to_content_label": "Langkau ke kandungan utama",
  "accessibilitylinks.skip_to_player_label": "Langkau ke kawalan pemain",
  "playlist.by": "oleh {0}",
  "playlist.loading": "Memuat...",
  "playlist.newfolder": "Folder Baharu",
  "playlist.delete_message": "Anda pasti ingin memadam playlist ini?",
  "playlist.unfollow_message": "Adakah anda pasti ingin berhenti ikuti playlist ini?",
  "playlistfolder.delete_message": "Adakah anda benar-benar mahu memadamkan folder ini dan semua senarai main di dalamnya?",
  "playlist.delete_confirm": "Padam",
  "playlist.unfollow_confirm": "Nyahikut",
  "playlist.delete_cancel": "Batal",
  "playlist.duplicates_dialog_title": "Duplikasi lagu",
  "playlist.duplicates_dialog_title_single": "Duplikasi lagu",
  "playlist.duplicates_dialog_body": "Sesetengah lagu ini telah wujud dalam playlist anda.",
  "playlist.duplicates_dialog_body_single": "Lagu ini telah wujud dalam playlist anda.",
  "playlist.duplicates_dialog_button_add": "Tambah semua",
  "playlist.duplicates_dialog_button_add_single": "Tambah juga",
  "playlist.duplicates_dialog_button_skip_duplicates": "Langkau duplikasi",
  "playlist.duplicates_dialog_button_skip_single": "Langkau duplikasi",
  "playlist.annotate_form.new_playlist_name": "Playlist Main Baru",
  "playlist.annotate_form.create_title": "Cipta Senarai Main",
  "playlist.annotate_form.create": "Cipta",
  "playlist.annotate_form.cancel": "Batal",
  "playlist.annotate_form.edit_title": "Sunting Butiran Senarai Main",
  "playlist.annotate_form.save": "Simpan",
  "playlist.annotate_form.name_field_label": "Nama",
  "playlist.annotate_form.name_field_placeholder": "Nama senarai main",
  "playlist.annotate_form.image_field_label": "Imej",
  "playlist.annotate_form.image_pick_button_label": "Pilih imej",
  "playlist.annotate_form.image_replace_button_label": "Ganti imej",
  "playlist.annotate_form.image_remove_button_label": "Keluarkan imej",
  "playlist.annotate_form.image_file_size_exceeded": "Saiz imej terlalu besar. maksimum :4MB.",
  "playlist.annotate_form.image_file_upload_failed": "Gagal untuk memuatkan imej, sila cuba lagi.",
  "playlist.annotate_form.annotate_failed": "Gagal untuk mengemas kini penerangan dan imej, sila cuba lagi.",
  "playlist.annotate_form.close-error-bar": "Sembunyikan",
  "playlist.annotate_form.description_field_label": "Penerangan",
  "playlist.annotate_form.description_field_placeholder": "Beri senarai main anda penerangan yang menarik.",
  "playlist.annotate_form.permission_message": "By proceeding, you agree to give Spotify access to the image you choose to upload. Please make sure you have the right to upload the image. We'll only use your image for playlist cover art.",
  "playlist.annotate_form.insert_link_button_label": "Masukkan pautan",
  "playlist.annotate_form.insert_link.link_field_label": "Pautan ke",
  "playlist.annotate_form.insert_link.change_button_label": "Tukar",
  "playlist.annotate_form.insert_link.remove_button_label": "Keluarkan",
  "playlist.annotate_form.insert_link.done_button_label": "Selesai",
  "playlist.annotate_form.drop_to_set_image_label": "Lepaskan untuk menetapkan imej",
  "playlist.annotate_form.drop_not_allowed_label": "Format tidak disokong",
  "playlist.annotate_form.error.file_not_valid_jpg": "Fail Itu sebenarnya bukan fail JPG yang sah, walaupun nama failnya demikian.",
  "playlist.annotate_form.error.name_required": "Anda harus memberikan senarai main anda nama.",
  "playlist.annotate_form.error.selection_required_to_insert_link": "Anda harus memilih teks yang anda ingin tukar menjadi pautan.",
  "playlist.annotate_form.error.html_not_allowed": "Kelihatan seperti anda mencuba untuk menggunakan HTML, yang tidak mungkin dapat dibuat.",
  "playlist.annotate_form.error.submit": "Gagal menyimpan perubahan senarai main. Sila cuba lagi.",
  "playlist.annotate_form.error.image_too_small": "Imej itu terlalu kecil. Ia harus minimal {0}x{1}.",
  "playlist.annotate_form.warning.client_offline": "Tiada sambungan internet ditemui. Perubahan pada penerangan dan imej tidak akan disimpan.",
  "playlist.annotate_form.warning.no_line_breaks_in_description": "Maaf, tetapi pemisah baris tidak disokong dalam penerangan.",
  "playlist.annotate_form.warning.unsaved_changes": "Adakah anda ingin menyimpan perubahan anda?",
  "navigation.label": "Navigasi",
  "navigation.back_button_label": "Kembali",
  "navigation.forward_button_label": "Ke hadapan",
  "search.input_placeholder": "Cari",
  "player.label": "Kawalan pemain",
  "player.shuffle_mode_label": "Rombak",
  "player.repeat_mode_label": "Ulang",
  "player.queue": "Baris gilir",
  "player.volume_button_label": "Kelantangan",
  "player.spotify_connect": "Spotify Connect",
  "player.connect_button_label": "Sambung ke peranti",
  "player.lyrics_label": "Lirik",
  "player.play_button_label": "Main",
  "player.pause_button_label": "Jeda",
  "player.previous_button_label": "Sebelumnya",
  "player.next_button_label": "Seterusnya",
  "player.offline_label": "Luar talian",
  "player.thumb_up_label": "Bagus",
  "player.thumb_down_label": "Tidak Bagus",
  "playererror.default": "Terdapat masalah semasa cuba memainkan lagu yang dipilih",
  "playererror.track_not_available": "Lagu ini tidak tersedia",
  "nowplaying.label": "Kini dimainkan",
  "nowplaying.go_to_context": "Pergi ke apa yang dimainkan",
  "nowplaying.save_your_music": "Simpan ke Muzik Anda",
  "nowplaying.remove_your_music": "Keluarkan daripada Muzik Anda",
  "nowplaying.playing_suggested_track": "Sedang Memainkan Lagu yang Dicadangkan",
  "connect.connect_text": "Sambung ke peranti",
  "connect.device_connecting": "Menyambung…",
  "connect.device_incompatible": "Tidak serasi",
  "connect.device_premium_only": "Pengguna Premium sahaja",
  "connect.device_sleeping": "Peranti sedang tidur",
  "connect.device_tech_cast": "Google Cast",
  "connect.device_tech_connect": "Spotify Connect",
  "connect.device_this_computer": "Komputer ini",
  "connect.device_unavailable_for_playback": "Tidak tersedia untuk mendengar pada",
  "connect.device_unknown": "Peranti tidak diketahui",
  "connect.device_unsupported_uri": "Tidak dapat memainkan ini sekarang",
  "connect.devices_available": "Peranti Tersedia",
  "connect.dismiss": "Ketepikan",
  "connect.help1": "Connect membolehkan anda memainkan dan mengawal Spotify di peranti anda.",
  "connect.help2": "Mulakan Spotify pada peranti lain dan secara ajaib ia akan muncul di sini.",
  "connect.help_hint": "Apa itu Connect?",
  "connect.offline": "Tidak tersedia",
  "connect.offline_reason_computer": "Spotify tidak aktif pada peranti ini.",
  "connect.offline_reason_generic": "Spotify tidak aktif pada peranti ini.",
  "connect.offline_reason_phone": "Telefon berkunci atau Spotify tiada di latar depan.",
  "connect.offline_reason_gameconsole": "Gunakan tetapan pasang kuasa dalam Aplikasi Spotify PlayStation untuk membolehkan PlayStation bangun daripada mod tunggu sedia.",
  "connect.offline_text1": "Anda perlu pergi online untuk menggunakan ciri ini.",
  "connect.offline_title": "Anda di luar talian!",
  "connect.playingon": "Mendengar Pada",
  "connect.popup_title": "Peranti",
  "connect.remoteplayback": "Anda sedang mendengar pada {0}",
  "connect.show_more": "Tunjukkan Lagi",
  "connect.upgrade": "Naik taraf",
  "connect.upsell": "Connect adalah ciri premium yang membolehkan anda memainkan dan mengawal Spotify di peranti anda.",
  "contextmenu.new-playlist": "Playlist Main Baru",
  "contextmenu.add-to-playlist": "Tambah Senarai Main",
  "contextmenu.owner-playlist": "oleh {0}",
  "contextmenu.copy-uri": "Salin URI Spotify",
  "contextmenu.copy-artist-url": "Salin Artis Pautan",
  "contextmenu.copy-album-url": "Salin Pautan Album",
  "contextmenu.copy-track-url": "Salin Pautan Lagu",
  "contextmenu.copy-playlist-url": "Salinan Senarai Main Pautan",
  "contextmenu.copy-profile-url": "Salin Pautan Profil",
  "contextmenu.copy-station-url": "Salin Pautan Stesen",
  "contextmenu.copy-chart-url": "Salin Pautan Carta",
  "contextmenu.copy-url": "Salin Pautan",
  "contextmenu.copy-embed": "Salin Kod Benam",
  "contextmenu.collaborative": "Senarai Main Usaha Sama",
  "contextmenu.save": "Simpan ke Muzik Anda",
  "contextmenu.remove": "Keluarkan daripada Muzik Anda",
  "contextmenu.delete-playlist": "Padam",
  "contextmenu.follow": "Ikut",
  "contextmenu.unfollow": "Nyahikut",
  "contextmenu.publish": "Jadikan Awam",
  "contextmenu.unpublish": "Jadikan Rahsia",
  "contextmenu.playlist.loading": "Memuat...",
  "contextmenu.play": "Main",
  "contextmenu.add-to-queue": "Tambah ke Baris Gilir",
  "contextmenu.station": "Pergi ke Radio",
  "contextmenu.station-album": "Pergi ke Radio Album",
  "contextmenu.station-artist": "Pergi ke Radio Artis",
  "contextmenu.station-playlist": "Pergi ke Radio Senarai Main",
  "contextmenu.station-track": "Pergi ke Radio Lagu",
  "contextmenu.station-chart": "Pergi ke Radio Carta",
  "contextmenu.remove-from-playlist": "Keluarkan daripada Senarai Main ini",
  "contextmenu.remove-from-queue": "Keluarkan daripada Baris Gilir",
  "contextmenu.rename-folder": "Namakan semula",
  "contextmenu.rename-playlist": "Namakan semula",
  "contextmenu.edit-playlist": "Sunting butiran",
  "contextmenu.report-playlist": "Laporan",
  "contextmenu.report-asset": "Laporan",
  "contextmenu.share": "Kongsi...",
  "contextmenu.share-lyrics": "Kongsi Lirik",
  "contextmenu.create-folder": "Cipta Folder",
  "contextmenu.create-playlist": "Cipta Senarai Main",
  "contextmenu.open-localfile-folder": "Buka Folder yang Mengandungi",
  "contextmenu.open-localfile-folder-mac": "Dedahkan di Pencari",
  "contextmenu.offline": "Tersedia Luar Talian",
  "contextmenu.goto-artist": "Pergi ke Artis",
  "contextmenu.goto-album": "Pergi ke Album",
  "usermessage.default-message": "Ralat telah berlaku",
  "usermessage.update-ready": "Helo. Kami mempunyai versi baru Spotify sedia untuk anda. <a href=\"#\" data-action=\"{0}\">Mulakan semula sekarang</a> untuk menjadikannya milik anda.",
  "usermessage.update-ready-simple": "Helo. Kami mempunyai versi baru Spotify sedia untuk anda. Mulakan semula sekarang untuk menjadikannya milik anda.",
  "usermessage.play-token-lost": "Spotify berhenti sebentar kerana akaun anda sedang digunakan di tempat lain.",
  "usermessage.playback-paused-inactive": "Komputer anda telah tidak aktif untuk tempoh yang lama, tekan main untuk terus mendengar! Untuk muzik tanpa gangguan, langgan <a href=\"#\" data-action=\"{0}\">Spotify Premium</a>.",
  "usermessage.not-available-offline": "Tiada sambungan internet dikesan. Spotify akan cuba menyambung semula secara automatik apabila ia mengesan sambungan internet (kod ralat:4)",
  "usermessage.track-not-available-in-region": "Lagu ini tidak tersedia dalam {0} pada masa ini. Jika anda mempunyai fail tersebut pada komputer anda, anda boleh mengimportnya.",
  "usermessage.track-not-available-in-region-generic": "Lagu ini tidak tersedia di negara anda pada masa ini di negara anda. Jika anda mempunyai fail tersebut pada komputer anda, anda boleh mengimportnya.",
  "usermessage.track-not-available": "Lagu ini tidak tersedia. Jika anda mempunyai fail tersebut pada komputer anda, anda boleh mengimportnya.",
  "usermessage.track-not-available-forced-offline": "Sila <a href=\"#\" data-action=\"goOnline\">matikan mod luar talian</a> dan cuba lagi.",
  "usermessage.track-exclusive-premium": "Lagu ini adalah eksklusif untuk pengguna <a href=\"#\" data-action=\"{0}\">Spotify Premium</a> .",
  "usermessage.track-banned-by-artist": "Artis/label telah memilih untuk menjadikan lagu ini tidak tersedia. Jika anda mempunyai fail tersebut pada komputer anda, anda boleh mengimportnya.",
  "usermessage.local-track-no-file": "Lagu ini telah ditambah sebagai fail setempat. Jika anda mempunyai fail tersebut pada komputer anda, anda boleh mengimportnya.",
  "usermessage.local-track-file-not-found": "Lagu ini tidak dapat dimainkan kerana fail tidak ditemui. Sila import lagu ini sekali lagi.",
  "usermessage.local-track-bad-format": "Fail dalam format tidak diketahui. Klik <a href=\"#\" data-action=\"{0}\">di sini</a> untuk mendapatkan maklumat.",
  "usermessage.capping-reached": "Anda telah melebihi had masa {0} jam anda. <a href=\"#\" data-action=\"{1}\">Naik taraf kepada Spotify Premium</a> untuk mendengar tanpa sekatan.",
  "usermessage.local-track-drm-protected": "Lagu ini tidak dapat dimainkan kerana fail dilindungi oleh pengurusan hak digital (DRM).",
  "usermessage.offline-disk-cache": "Gagal memuat turun lagu luar talian. Mungkin cakera telah penuh?",
  "usermessage.offline-sync-expired": "Lagu luar talian telah tamat tempoh. Anda perlu melog masuk ke Spotify untuk mengaktifkannya semula.",
  "usermessage.offline-sync-failed": "Gagal memuat turun beberapa lagu luar talian.",
  "usermessage.offline-too-many-tracks": "Terlalu banyak lagu dipilih untuk mod luar talian.",
  "usermessage.offline-license-server-error": "Terdapat masalah dengan pelayan Spotify.",
  "usermessage.offline-license-lost": "Akses luar talian untuk komputer/peranti ini telah ditarik balik.",
  "usermessage.offline-not-allowed": "Mod luar talian adalah ciri eksklusif <a href=\"#\" data-action=\"{0}\">Spotify Premium</a> .",
  "usermessage.language-changed": "Anda perlu <a href=\"#\" data-action=\"{0}\">mulakan semula Spotify</a> bagi mengaktifkan perubahan",
  "usermessage.proxysettings-changed": "Anda perlu <a href=\"#\" data-action=\"{0}\">mulakan semula Spotify</a> bagi mengaktifkan perubahan",
  "usermessage.language-changed-simple": "Anda perlu mulakan semula Spotify bagi mengaktifkan perubahan",
  "usermessage.proxysettings-changed-simple": "Anda perlu mulakan semula Spotify bagi mengaktifkan perubahan",
  "usermessage.cache-changed": "Anda perlu <a href=\"#\" data-action=\"{0}\">mulakan semula Spotify</a> bagi mengaktifkan perubahan",
  "usermessage.cache-changed-simple": "Anda perlu mulakan semula Spotify bagi mengaktifkan perubahan",
  "usermessage.feature-changed": "Anda perlu <a href=\"#\" data-action=\"{0}\">mulakan semula Spotify</a> bagi mengaktifkan perubahan",
  "usermessage.first-autostart": "Spotify telah terbuka secara automatik, tapi diminimakan. Jika anda lebih suka anda boleh <a href=\"#\" data-action=\"{0}\">buka Spotify secara automatik tanpa meminimakannya</a> atau <a href=\"#\" data-action=\"{1}\">sama sekali tidak membuka Spotify pada</a> permulaan.",
  "usermessage.cant-play-track": "Tidak dapat memainkan lagu semasa.",
  "usermessage.cant-skip-ads": "Lagu yang dipilih akan dimainkan selepas iklan",
  "usermessage.cant-offline-playlists": "Mod luar talian ialah ciri eksklusif Premium . <a href=\"#\" data-action=\"{0}\">Dapatkan Premium</a>.",
  "usermessage.cant-set-high-quality-streaming": "Ini adalah ciri eksklusif Premium. <a href=\"#\" data-action=\"{0}\">Dapatkan Premium</a>.",
  "usermessage.payment-state-creditcard-funds": "Kami tidak dapat memperbaharui langganan anda kerana masalah pembayaran. Sila pastikan anda mempunyai dana dalam akaun anda atau <a href=\"#\" data-action=\"{0}\">mengemas kini butiran pembayaran anda </a>.",
  "usermessage.payment-state-creditcard-refused": "Kami tidak dapat memperbaharui langganan anda kerana masalah pembayaran. Untuk mengekalkan langganan anda, sila <a href=\"#\" data-action=\"{0}\">kemas kini butiran bayaran anda</a>.",
  "usermessage.payment-state-paypal-refused": "Kami tidak dapat memperbaharui langganan anda kerana masalah pembayaran. Untuk mengekalkan langganan anda, sila <a href=\"#\" data-action=\"{0}\">kemas kini butiran bayaran anda</a>.",
  "usermessage.payment-state-creditcard-expiry": "Kad pembayaran yang kini anda gunakan luput dalam beberapa hari. Untuk mengekalkan langganan anda, sila <a href=\"#\" data-action=\"{0}\">kemas kini butiran bayaran anda </a>.",
  "usermessage.payment-state-prepaid-expiry": "Langganan pra-bayar anda akan luput. Jangan risau, anda boleh <a href=\"#\" data-action=\"{0}\">melanggan Premium di sini</a>.",
  "usermessage.payment-state-churn-payment": "Malangnya kami tidak boleh mengambil pembayaran daripada anda, jadi kami harus membatalkan langganan anda. Jangan risau, anda boleh <a href=\"#\" data-action=\"{0}\">memperbaharui langganan anda di sini</a>.",
  "usermessage.payment-state-churn-partner": "Langganan anda dengan salah satu rakan kami baru sahaja berakhir, jadi anda kini menggunakan Spotify Percuma. Jangan risau, anda boleh <a href=\"#\" data-action=\"{0}\">kembali ke Premium di sini</a>.",
  "usermessage.opt-in-trial": "Kami berharap anda menikmati percubaan percuma anda! Untuk mengelakkan kehilangan Premium apabila ia berakhir, <a href=\"#\" data-action=\"{0}\">langgani hari ini</a>.",
  "usermessage.opt-in-trial-expired": "Percubaan percuma anda telah tamat, jadi anda kini menggunakan Spotify percuma. Jangan risau, anda boleh <a href=\"#\" data-action=\"{0}\">kembali ke Premium di sini</a>.",
  "usermessage.hardware-acceleration-changed": "Anda perlu <a href=\"#\" data-action=\"{0}\">mulakan semula Spotify</a> bagi mengaktifkan perubahan",
  "usermessage.hardware-acceleration-changed-simple": "Anda perlu mulakan semula Spotify bagi mengaktifkan perubahan",
  "usermessage.some-local-tracks-not-saved": "Sesetengah lagu yang dipilih tidak disimpan ke Muzik Anda. Fail setempat tidak disokong oleh Muzik Anda.",
  "usermessage.illegal-playlist-name-entered": "Nama senarai main dimasukan tidak sah.",
  "usermessage.playlist-save-failed-unknown": "Senarai main tidak boleh disimpan akibat ralat yang tidak diketahui.",
  "usermessage.social-error-permissions": "Klik <a href=\"#\" data-action=\"{0}\">di sini</a> untuk membenarkan aktiviti muzik anda dikongsi di Facebook.",
  "usermessage.shuffle-unplayable-track": "<a href=\"#\" data-action=\"{0}\">Tingkatkan kepada Premium</a> untuk memainkan mana-mana lagu, bila-bila masa.",
  "usermessage.shuffle-ran-out-of-skips": "Anda telah kehabisan langkauan (untuk jam ini). <a href=\"#\" data-action=\"{0}\">Tingkatkan kepada Premium</a> untuk melangkau seberapa kerap yang anda mahu.",
  "usermessage.playlist-limit-exceeded": "Anda telah memenuhkan senarai main ini sehingga tahap maksimum. Hebat. Mulakan senarai main baharu untuk terus mengumpulkan.",
  "usermessage.collection-limit-exceeded": "Koleksi yang hebat, kawan. Muzik Anda sudah penuh. Untuk terus menyimpan, anda perlu mengeluarkan beberapa lagu.",
  "usermessage.deprecating-os-version": "Sila ambil perhatian! Kami akan menamatkan sokongan terhadap sistem pengendalian anda dalam keluaran yang akan datang. Klik <a href=\"#\" data-action=\"{0}\">di sini</a> untuk mendapatkan maklumat lanjut.",
  "usermessage.image-upload-propagation": "Berjaya! (Imej boleh mengambil sehingga 24 jam untuk merambat)",
  "usermessage.approaching-capping-limit": "Anda mempunyai kurang daripada 1 jam baki pendengaran percuma. Nikmati 15 jam percuma untuk mendengar setiap bulan atau <a href=\"#\" data-action=\"{0}\">naik taraf kepada Premium</a> untuk mendengar tanpa had. <a href=\"#\" data-action=\"{1}\">Ketahui lebih lanjut</a>.",
  "usermessage.half-capping-limit-passed": "Anda telah menggunakan separuh daripada had bulanan anda. Nikmati 15 jam percuma untuk mendengar setiap bulan atau <a href=\"#\" data-action=\"{0}\">naik taraf kepada Premium</a> untuk mendengar tanpa had. <a href=\"#\" data-action=\"{1}\">Ketahui lebih lanjut</a>.",
  "usermessage.video-georestricted": "Kami tidak dapat memainkan video ini di lokasi semasa anda.",
  "usermessage.video-unsupported-client-version": "Sila naik taraf Spotify untuk memainkan video ini.",
  "usermessage.video-unsupported-platform-version": "Video ini tidak boleh dimainkan pada versi sistem pengendalian anda.",
  "usermessage.video-country-restricted": "Kami tidak dapat memainkan video ini di lokasi semasa anda.",
  "usermessage.video-unavailable": "Video ini tidak tersedia. Cuba yang lain?",
  "usermessage.video-catalogue-restricted": "Maaf, kami tidak dapat memainkan video ini.",
  "usermessage.video-playback-error": "Maaf, kami tidak dapat memainkan video ini.",
  "about.title_label": "Tentang Spotify",
  "about.close_button_label": "Tutup",
  "offline-progress-msg": "Penyegerakan luar talian {0} bagi {1} lagu",
  "tos.updated_terms": "Terma Dikemaskini",
  "tos.modal_title": "Terma dan Syarat Penggunaan Spotify",
  "tos.tos_text": "<p>Kami telah menyemak semula <a href=\"{0}\">Terma dan Syarat Penggunaan</a> dan <a href=\"{1}\">Dasar Privasi</a> kami.</p><p>Dengan mengklik &quot;Terima&quot;, anda menerima dan bersetuju dengan kemas kini ini, jadi sila mengambil masa beberapa minit untuk membaca dan memahaminya.</p>",
  "tos.not_now_tos_text": "<p>Kami telah menyemak semula <a href=\"{0}\">Terma dan Syarat Penggunaan</a> dan <a href=\"{1}\">Dasar Privasi</a> kami.</p><p>Dengan mengklik &quot;Terima&quot;, anda bersetuju dengan kemas kini ini (dan pemprosesan data anda seperti yang diterangkan), jadi sila luangkan masa beberapa minit untuk membaca dan memahaminya.</p>",
  "tos.tos_text2": "<p>Jika anda tidak lagi mahu menggunakan Spotify, anda boleh membatalkan langganan anda dengan melawat halaman langganan Spotify anda.</p>",
  "tos.not_now_text": "<p>Anda boleh terus menggunakan Spotify selama {0} hari tanpa menerima Terma dan Syarat serta Dasar Privasi yang telah dikemas kini. Apabila cukup tempoh tersebut, anda perlu menerima terma baharu agar dapat terus menggunakan Spotify. Anda akan terus dibilkan setiap bulan mengikut kitaran pengebilan biasa anda, melainkan anda membatalkan langganan anda. Jika anda tidak ingin dikenakan caj oleh Spotify lagi, anda boleh membatalkan langganan anda pada bila-bila masa dengan melawat halaman langganan Spotify anda.</p>",
  "tos.not_now_last_day_text": "<p>Anda boleh terus menggunakan Spotify untuk 1 hari tanpa menerima Terma dan Syarat dan Dasar Privasi yang dikemas kini. Jika anda tidak menerima terma-terma baharu pada masa itu, anda tidak akan dapat menggunakan Spotify. Melainkan anda membatalkan langganan anda, anda akan terus dikenakan caj bulanan pada kitaran bil tetap anda. Jika anda tidak mahu dicaj melalui Spotify lagi, anda boleh membatalkan langganan anda pada bila-bila masa dengan melawat halaman langganan Spotify anda.</p>",
  "tos.not_now_text_germany": "<p>Kami telah menyemak semula <a href=\"{0}\">Terma dan Syarat Penggunaan</a> dan <a href=\"{1}\">Dasar Privasi kami</a>. Sila ambil perhatian bahawa, dengan kebenaran anda, Spotify GmbH bercadang untuk memindahkan kontrak anda kepada Spotify AB, Birger Jarlsgatan 61, 113 56 Stockholm, Sweden.</p><p>Anda boleh terus menggunakan perkhidmatan Spotify di bawah kontrak sedia ada sehingga {2}. Selepas tarikh itu, untuk terus menggunakan perkhidmatan Spotify, anda perlu menerima Terma dan Syarat dan Dasar Privasi baharu. Dengan mengklik &quot;Terima&quot;, anda bersetuju dengan </p><p>a) pemindahan kontrak anda dari Spotify GmbH kepada Spotify AB,<br />b) kemas kini daripada Terma dan Syarat Penggunaan, dan<br />c) pengumpulan, pemprosesan dan penggunaan data peribadi anda seperti yang dinyatakan dalam Seksyen 4, 5, dan 7 Dasar Privasi.</p>",
  "tos.not_now_text2_germany": "<p>Anda boleh terus menggunakan Spotify sehingga {0} tanpa menerima Terma dan Syarat dan Dasar Privasi yang dikemas kini. Pada masa itu, anda akan diminta untuk menerima syarat baru untuk terus menggunakan Spotify. Jika anda pengguna Premium, anda akan terus dikenakan caj bulanan kitaran pengebilan biasa anda melainkan jika anda membatalkan langganan. Jika anda tidak ingin dicaj oleh Spotify lagi, anda boleh membatalkan langganan anda pada bila-bila masa dengan melawati halaman langganan Spotify anda.</p>",
  "tos.not_now_expired_text_germany": "<p>Kami telah menyemak semula <a href=\"{0}\">Terma dan Syarat Penggunaan</a> dan <a href=\"{1}\">Dasar Privasi kami</a>.</p><p>Sila ambil perhatian bahawa, dengan kebenaran anda, Spotify GmbH bercadang untuk memindahkan kontrak anda kepada Spotify AB, Birger Jarlsgatan 61, 113 56 Stockholm, Sweden.</p><p>Untuk terus menggunakan perkhidmatan Spotify, anda perlu menerima Terma dan Syarat dan Dasar Privasi baharu. Dengan mengklik &quot;Terima&quot;, anda bersetuju dengan </p><p>a) pemindahan kontrak anda dari Spotify GmbH kepada Spotify AB,<br />b) kemas kini daripada Terma dan Syarat Penggunaan, dan<br/>c) pengumpulan, pemprosesan dan penggunaan data peribadi anda seperti yang dinyatakan dalam Seksyen 4, 5, dan 7 Dasar Privasi.</p>",
  "tos.back_button_label": "Kembali",
  "tos.ok_button_label": "OK",
  "tos.agree_button_label": "Terima",
  "tos.cancel_button_label": "Tolak",
  "tos.not_now_button_label": "Bukan sekarang",
  "licenses.modal_title": "Lesen pihak ketiga",
  "licenses.close_button_label": "Tutup",
  "feedback.beta_title": "Versi Beta",
  "feedback.beta_text": "Benci atau suka sesuatu? Beritahu kami.",
  "market.ad": "Andorra",
  "market.ar": "Argentina",
  "market.at": "Austria",
  "market.au": "Australia",
  "market.be": "Belgium",
  "market.bg": "Bulgaria",
  "market.bo": "Bolivia",
  "market.br": "Brazil",
  "market.ca": "Kanada",
  "market.ch": "Switzerland",
  "market.cl": "Chile",
  "market.co": "Colombia",
  "market.cr": "Costa Rica",
  "market.cy": "Cyprus",
  "market.cz": "Republik Czech",
  "market.de": "Jerman",
  "market.dk": "Denmark",
  "market.do": "Republik Dominican",
  "market.ec": "Ecuador",
  "market.ee": "Estonia",
  "market.es": "Sepanyol",
  "market.fi": "Finland",
  "market.fr": "Perancis",
  "market.gr": "Greece",
  "market.gt": "Guatemala",
  "market.hk": "Hong Kong",
  "market.hn": "Honduras",
  "market.hu": "Hungary",
  "market.ie": "Ireland",
  "market.is": "Iceland",
  "market.it": "Itali",
  "market.jp": "Jepun",
  "market.li": "Liechtenstein",
  "market.lt": "Lithuania",
  "market.lu": "Luxembourg",
  "market.lv": "Latvia",
  "market.mc": "Monaco",
  "market.mt": "Malta",
  "market.mx": "Mexico",
  "market.my": "Malaysia",
  "market.ni": "Nicaragua",
  "market.nl": "Belanda",
  "market.no": "Norway",
  "market.nz": "New Zealand",
  "market.pa": "Panama",
  "market.pe": "Peru",
  "market.ph": "Filipina",
  "market.pl": "Poland",
  "market.pt": "Portugal",
  "market.py": "Paraguay",
  "market.se": "Sweden",
  "market.sg": "Singapura",
  "market.sk": "Slovakia",
  "market.sv": "El Salvador",
  "market.tr": "Turki",
  "market.tw": "Taiwan",
  "market.uk": "United Kingdom",
  "market.us": "Amerika Syarikat",
  "market.uy": "Uruguay",
  "market.za": "Afrika Selatan",
  "sTitle": "Kongsi pandangan anda dan bantu kami membina perkhidmatan muzik yang terbesar di dunia!",
  "sQ1Question": "Apakah kemungkinan anda akan mencadangkan Spotify kepada rakan atau rakan sekerja?",
  "sQ1Negative": "Mungkin tidak sama sekali",
  "sQ1Positive": "Sangat berkemungkinan",
  "sQ2Question": "Mengapa anda rasa begitu?",
  "sQ3Question": "Secara keseluruhan, sejauh manakah anda berpuas hati dengan Spotify?",
  "sQ3Negative": "Sangat tidak berpuas hati",
  "sQ3Positive": "Sangat berpuas hati",
  "sSubmit": "Serahkan kaji selidik",
  "sThanks": "Terima kasih banyak atas bantuan anda. Kami amat menghargai masa anda.",
  "sTeam": "Pasukan Spotify",
  "sClose": "Tutup",
  "cls.highlight": "Premium dijeda",
  "cls.title": "Pembayaran terakhir anda tidak berjaya.",
  "cls.desc": "Teruskan mendengar menerusi Premium dengan menambahkan kaedah pembayaran baharu. Proses ini tidak memakan masa.",
  "cls.updatePayment": "Kemas kini pembayaran",
  "cls.cancelSubscription": "Anda juga boleh menurun taraf kepada Spotify Free,<br>dengan <a class=\"cancel-sub\" href=\"#cancel\">membatalkan langganan Premium anda</a>.",
  "capping.upsell-title": "Anda sudah mencapai had pendengaran percuma.",
  "capping.upsell-message": "Anda mendapat 15 jam percuma untuk mendengar setiap bulan.<br />Naik taraf kepada Premium untuk mendapatkan pendengaran tanpa had dan tanpa iklan.",
  "capping.upsell-button-label": "Naik Taraf kepada Premium",
  "capping.defaultRefillMessage": "Pendengaran percuma anda akan ditambah tidak lama lagi.",
  "capping.refillMessage": "Pendengaran percuma anda akan ditambah dalam {0} hari berikutnya.",
  "capping.welcome-title": "Selamat Datang ke Spotify.",
  "capping.welcome-message": "Nikmati 15 jam pendengaran percuma setiap bulan.<br /> <a data-action={0}>Naik taraf kepada Premium</a> untuk pendengaran tanpa had dan tanpa iklan.",
  "capping.welcome-message-button-label": "Mulakan",
  "yourArtistsTooltipTitle": "Urus artis anda",
  "yourArtistsTooltipText": "Anda kini boleh mengedit dengan mudah imej profil artis anda di Spotify.",
  "yourArtists": "Artis Anda"
};
},{}],21:[function(require,module,exports){
module.exports={
  "name": "zlink",
  "version": "0.7.0",
  "description": "The UI for the Zelda client",
  "repository": {
    "type": "git",
    "url": "https://ghe.spotify.net/link/zlink"
  },
  "publishConfig": {
    "registry": "http://npm-registry.spotify.net"
  },
  "main": "scripts/index.js",
  "private": true,
  "license": "UNLICENSED"
}

},{}],22:[function(require,module,exports){
'use strict';

var Keyboard = require('./keyboard');
var cosmos = require('spotify-cosmos-api');

var STREAMTIME_URI = 'sp://ads/v1/testing/playtime';

/**
 * Apps that should NOT display leaderboard ads.
 *
 * @type {Array}
 */
var LEADERBOARD_BLACKLIST = ['browse', 'discover', 'concerts'];

var AdsUtils = AdsUtils || {};

AdsUtils.addToLeaderboardBlacklist = function (uri) {
  if (LEADERBOARD_BLACKLIST.indexOf(uri) === -1) {
    LEADERBOARD_BLACKLIST.push(uri);
    AdsUtils._leaderboardUriRegex = generateBlacklistRegex();
  }
};

/**
 * Static method (not attached to prototype)
 * Determines if the app does not need to have leaderboard ad. Only a few apps
 * don't need to have this type of ad. (E.g. browse, and sponsored playlist)
 *
 * @param {String} uri
 * @return {Boolean}
 */
AdsUtils.isBlacklistedForLeaderboard = function (uri) {
  return AdsUtils._leaderboardUriRegex.test(uri);
};

AdsUtils.registerKeyboardShortcuts = function () {
  // SHIFT F5 adds 20 minutes to stream time
  Keyboard.registerShortcut({
    key: Keyboard.KEYS.F5,
    shift: true
  }, function (e) {
    e.preventDefault();

    console.log('[AdsUtils] add streamtime key pressed');

    cosmos.resolver.post({
      url: STREAMTIME_URI,
      body: {
        value: 900
      }
    });
  });
};

/*
 * Private static variable to cache the Regex compilation
 */
AdsUtils._leaderboardUriRegex = generateBlacklistRegex();

function generateBlacklistRegex() {
  return new RegExp(LEADERBOARD_BLACKLIST.join('|'));
}

module.exports = AdsUtils;

},{"./keyboard":83,"spotify-cosmos-api":694}],23:[function(require,module,exports){
'use strict';

var eventDispatcher = require('../../../libs/spotify-event-dispatcher');
var Event = require('./event');
var Cache = require('./lrucache');
var URIHelper = require('./urihelper');
var Player = require('./models/player');
var App = require('./app');

/**
 * Handles the currently opened applications and allows opening/closing
 * apps
 *
 * @param {DOMElement} Element where apps are inserted
 */
var AppHandler = function AppHandler(container) {
  this._container = container;

  this._currentAppName = null;
  this._playbackOrigin = null;

  this._appsCache = new Cache(10, this._cleanupContainer.bind(this), 60000, 30000);

  var self = this;
  eventDispatcher.addEventListener(Event.TYPES.APP_NOTIFY_LOADED, function (e) {
    self._onAppReady(e.source.frameElement, e.source.frameElement.src);
  });

  var player = Player.getPlayer();
  // Listen to player events and update the playback origin
  // in order to keep the app alive
  var updatePlayerState = function updatePlayerState(err, response) {
    if (!err) {
      var data = response.getJSONBody();
      try {
        var appName = data && data.play_origin && data.play_origin.referrer_identifier && URIHelper.appName(data.play_origin.referrer_identifier);
        if (appName) {
          self._updatePlaybackOrigin(appName);
        }
      } catch (e) {
        return;
      }
    }
  };

  player.getState(updatePlayerState);
  player.subscribe(updatePlayerState);
};

/**
 * Opens an application
 *
 * @param  {string}   uri The application URI
 * @param  {Function} callback called when the app has been correctly opened
 * @return {App} The container that has the application
 */
AppHandler.prototype.openApp = function (appState, callback) {
  var _this = this;

  var appName = URIHelper.appName(appState.getURI());
  var currentApp = this._appsCache.get(this._currentAppName);
  var isDifferentApp = appName !== this._currentAppName;
  if (currentApp && isDifferentApp) {
    currentApp.deactivate();
  }

  // Check if the app is in the cache
  var app = this._appsCache.get(appName);

  var callbackAndNotify = function callbackAndNotify(app) {
    if (callback) callback(app);
    eventDispatcher.dispatchEvent(new Event(Event.TYPES.VIEW_LOADED, {
      loaded: _this._listLoadedViews()
    }));
  };

  if (!app) {
    app = this._initApp(appState, callbackAndNotify);
  } else {
    app.setOnReadyCallback(callbackAndNotify);

    var isNewArguments = app.getURI() !== appState.getURI();

    app.setState(appState);

    // Navigating to another app (that is already running) should delay the
    // ready state for a short amount of time to let the app receive the
    // active state and get ready to be shown. This is not to let the app
    // finish loading, just to let it clear any old state if needed.
    if (isDifferentApp) {
      app.sendActiveMessage(true);

      // If the timer value is changed at some point, remember to change it
      // in the share view as well, since we deal with share separately.
      setTimeout(function () {
        app.ready();
      }, 50);

      // Navigating to the same app with new arguments should set the app
      // as ready immediately.
    } else if (isNewArguments) {
        app.ready();
      }
  }

  this._updateCurrentAppName(app.getName());
  app.activate();

  return app;
};

/**
 * Close an already opened application
 * @param  {string} uri
 */
AppHandler.prototype.closeApp = function (uri) {
  this._appsCache.remove(URIHelper.appName(uri));
};

/**
 * Update the current visible app and sets the proper 'keep' value
 * for the cache
 *
 * @param {String} appName
 */
AppHandler.prototype._updateCurrentAppName = function (appName) {
  if (appName !== this._currentAppName) {
    if (this._currentAppName) {
      this._appsCache.keep(this._currentAppName,
      // Just keep it if it's originating playback
      this._currentAppName === this._playbackOrigin);
    }

    this._currentAppName = appName;
    this._appsCache.keep(this._currentAppName, true);
  }
};

AppHandler.prototype.getCurrentAppName = function () {
  return this._currentAppName;
};

/**
 * Update the playback origin and sets the proper 'keep' value for the
 * cache
 *
 * @param {String} newOrigin The name of the app that triggered playback
 */
AppHandler.prototype._updatePlaybackOrigin = function (newOrigin) {
  if (this._playbackOrigin !== newOrigin) {
    if (this._playbackOrigin) {
      // The playback origin changed, remove the 'keep' flag from the previous
      // origin, unless it's the visible app
      this._appsCache.keep(this._playbackOrigin, this._playbackOrigin === this._currentAppName);
    }
    this._playbackOrigin = newOrigin;
    this._appsCache.keep(this._playbackOrigin, true);
  }
};

AppHandler.prototype.getPlaybackOrigin = function () {
  return this._playbackOrigin;
};

AppHandler.prototype._onAppReady = function (container, uri) {
  var appName = URIHelper.appName(uri);
  var app = this._appsCache.get(appName);

  if (!app || app.getContainer() !== container || app.getName() !== this._currentAppName || app.isReady()) {
    return;
  }

  app.ready();
};

AppHandler.prototype._initApp = function (appState, callback) {
  var app = new App(callback);
  app.init(appState);

  this._container.appendChild(app.getContainer());
  this._appsCache.set(app.getName(), app, true);

  // Set app as ready after 500ms
  // (for apps that don't send notify_loaded event)
  // TODO: This should be removed when all apps follow the guidelines
  setTimeout(function () {
    if (!app.isReady()) {
      app.ready();
    }
  }, 500);

  return app;
};

AppHandler.prototype._cleanupContainer = function (appName, app) {
  app.cleanup();

  var container = app.getContainer();
  this._container.removeChild(container);

  eventDispatcher.dispatchEvent(new Event(Event.TYPES.VIEW_UNLOADED, {
    unloaded: app.getURI(),
    loaded: this._listLoadedViews()
  }));
};

AppHandler.prototype._listLoadedViews = function () {
  var iframes = document.getElementsByTagName('iframe');
  // Make the NodeList behave like an Array for mapping the items
  return Array.prototype.map.call(iframes, function (iframe) {
    return iframe.src;
  });
};

/**
 * Export public interface
 */
module.exports = AppHandler;

},{"../../../libs/spotify-event-dispatcher":264,"./app":24,"./event":77,"./lrucache":96,"./models/player":101,"./urihelper":117}],24:[function(require,module,exports){
'use strict';

var Keyboard = require('./keyboard');
var routeValidator = require('./routevalidator');
var liburi = require('spotify-liburi');
var activityMonitor = require('./components/activity_monitor');

var App = function App(callback) {
  this._ready = false;
  this._readyCallback = callback;
  this._active = false;
  this._state = null;
  this._uri = null;

  this._iframeLoaded = this._iframeLoaded.bind(this);
};

App.prototype.init = function (appState) {
  this._initIframe(appState);
  routeValidator.decrementForUri(appState.getURI());
};

App.prototype._initIframe = function (appState) {
  this._iframe = document.createElement('iframe');
  this._iframe.addEventListener('load', this._iframeLoaded);
  this.setState(appState);
  this._iframe.setAttribute('id', 'app-' + this.getName());
  if (typeof window !== 'undefined' && window.localStorage) {
    this._iframe.setAttribute('data-debug', window.localStorage.getItem('debug'));
  }
};

App.prototype._iframeLoaded = function () {
  // This is a hack to make sure the window is fully loaded before
  // setting up keyboard events and removing the iframe event listener.
  // The iframe load event appears to trigger twice after the source is
  // correctly set- once when the body is empty, and again after it has
  // been fully loaded.
  // This is the same trick we do for modals in scripts/views/modal.
  if (this._iframe.contentWindow.document.body.innerHTML) {
    activityMonitor.enableForWindow(this._iframe.contentWindow);
    this._iframe.removeEventListener('load', this._iframeLoaded);
    Keyboard.setupWithWindow(this._iframe.contentWindow);
    this._sendStateMessage(this._state);
  }
};

App.prototype.getState = function () {
  return this._state;
};

App.prototype.setState = function (appState) {
  var newURI = liburi.from(appState.getURI());

  if (!newURI || newURI.type !== liburi.Type.APPLICATION) {
    return;
  }

  var oldURI = this._uri;
  if (oldURI && oldURI.toString() === newURI.toString()) {
    return;
  }

  if (oldURI && oldURI.id !== newURI.id) {
    // Sanity check to make sure one app iframe is not reused by different
    // apps.
    throw new Error('Can\'t change app name');
  }

  this._ready = false;
  this._uri = newURI;
  this._state = appState;

  var src = this._uri.toString();
  if (src !== this._iframe.src) {
    routeValidator.incrementForUri(this._uri.toString());
    this._iframe.src = src;
  }

  // Navigating to the same app with new arguments should set the new URI
  // as well as sending the new arguments to the app.
  this._sendArgumentsMessage(this._uri.args);
  this._sendStateMessage(appState);
};

App.prototype.getURI = function () {
  return this._uri.toString();
};

App.prototype.getContainer = function () {
  return this._iframe;
};

App.prototype.isReady = function () {
  return this._ready;
};

App.prototype.ready = function () {
  if (this._readyCallback) {
    var self = this;
    // Defer the callback for later to make sure the
    // callback is called async.
    setTimeout(function () {
      self._readyCallback(self);
    }, 0);
  }
  this._ready = true;
};

App.prototype.cleanup = function () {};

App.prototype.getName = function () {
  return this._uri.id;
};

App.prototype.setOnReadyCallback = function (callback) {
  this._readyCallback = callback;
};

App.prototype.deactivate = function () {
  this._active = false;
  activityMonitor.disableForWindow(this._iframe.contentWindow);
};

App.prototype.activate = function () {
  this._active = true;
};

App.prototype.sendActiveMessage = function (value) {
  this._sendMessage({
    name: 'set_active',
    active: value
  });
};

/**
 * Send a message to app.
 *
 * @param {Object} data Key/Value map.
 */
App.prototype._sendMessage = function (data) {
  var contentWindow = this.getContainer().contentWindow;
  if (contentWindow && contentWindow.postMessage) {
    contentWindow.postMessage(data, '*');
  }
};

/**
 * Send a message to the app to notify it about new arguments.
 *
 * @param {Array.<string>} value Array of string arguments. Each argument
 *     should be un-encoded.
 */
App.prototype._sendArgumentsMessage = function (value) {
  this._sendMessage({
    name: 'set_arguments',
    arguments: value
  });
};

/**
 * Send a message to the app to notify it about new state.
 *
 * @type {AppState} state Instance of AppState.
 */
App.prototype._sendStateMessage = function (state) {
  this._sendMessage({
    name: 'set_state',
    state: state.serialize()
  });
};

module.exports = App;

},{"./components/activity_monitor":29,"./keyboard":83,"./routevalidator":114,"spotify-liburi":707}],25:[function(require,module,exports){
'use strict';

var Cosmos = require('spotify-cosmos-api');
var eventDispatcher = require('../../../libs/spotify-event-dispatcher');
var Event = require('./event');

/**
 * Listens for player events and propagates AD_AUDIO_STARTED/FINISHED events
 * when an audio ad has started or finished.
 *
 * @constructor
 */
function AudioAdListener() {
  this._previousAudioAdIsPlaying = false;
  this._onCosmosEvent = this._onCosmosEvent.bind(this);
}

/**
 * Start listening for player events
 */
AudioAdListener.prototype.start = function () {
  Cosmos.resolver.subscribe('sp://player/v2/main', this._onCosmosEvent);
};

/**
 * Stop listening for player events
 */
AudioAdListener.prototype.stop = function () {
  Cosmos.resolver.unsubscribe('sp://player/v2/main', this._onCosmosEvent);
};

/**
 * Callback for cosmos player events.
 *
 * @param {Object} error The error, if any.
 * @param {Object} e The cosmos event triggered.
 * @return {void}
 */
AudioAdListener.prototype._onCosmosEvent = function (error, e) {
  if (error) {
    return;
  }
  var response = e.getJSONBody();

  if (response.track && response.track.metadata) {
    this._update(response.track.metadata.is_advertisement === 'true');
  }
};

/**
 * Update the state. Triggers the AD_AUDIO_STARTED and AD_AUDIO_FINISHED
 * events if the state has changed.
 *
 * @private
 * @param {Boolean} audioAdIsPlaying Are we currently playing an audio ad?
 * @return {void}
 */
AudioAdListener.prototype._update = function (audioAdIsPlaying) {
  if (audioAdIsPlaying !== this._previousAudioAdIsPlaying) {
    var type = audioAdIsPlaying ? Event.TYPES.AD_AUDIO_STARTED : Event.TYPES.AD_AUDIO_FINISHED;
    eventDispatcher.dispatchEvent(new Event(type, {}));
  }
  this._previousAudioAdIsPlaying = audioAdIsPlaying;
};

module.exports = AudioAdListener;

},{"../../../libs/spotify-event-dispatcher":264,"./event":77,"spotify-cosmos-api":694}],26:[function(require,module,exports){
(function (global){
'use strict';

var eventDispatcher = require('../../../libs/spotify-event-dispatcher');
var bridgeRequest = require('../../../libs/spotify-bridge-request').request;
var Event = require('./event');

/**
 * Wrapper for the bridge
 */
function Bridge() {
  // Listen for post messages from apps
  window.addEventListener('message', this._onPostMessage.bind(this));
}

if (!global._getSpotifyModule && global.addEventListener) {
  var uid = 1;
  var callbacks = {};

  global.addEventListener('message', function (e) {
    var data = e.data;
    if (typeof data === 'string') {
      try {
        data = JSON.parse(data);
      } catch (e) {
        return this;
      }
    }

    var callback = callbacks[data.id];
    if (!callback) {
      return this;
    }
    callback[data.id] = null;
    if (data.success && callback.success) {
      callback.success.call(callback.caller, data.payload);
    } else if (!data.success && callback.failed) {
      callback.failed.call(callback.caller, data.payload);
    }
  });

  var appVendor = 'com.spotify';
  var appVersion = '0.0.0';
  var manifest = global.manifest;

  if (manifest) {
    appVendor = manifest.VendorIdentifier || appVendor;
    appVersion = manifest.BundleVersion || appVersion;
  }

  Bridge.prototype.request = function (method, args, context, callback, errback) {
    var top = global.top;
    if (top === global) {
      return this;
    }

    var data = {
      type: 'bridge_request',
      id: 'zlink_' + uid++,
      name: method,
      args: args || [],
      appVendor: appVendor,
      appVersion: appVersion
    };

    top.postMessage(JSON.stringify(data), '*');
    if (!callback && !errback) {
      return this;
    }
    callbacks[data.id] = {
      success: callback,
      failed: errback,
      caller: context
    };
    if (method !== 'core_flush') {
      this.request('core_flush');
    }
  };
} else {
  /**
   * Proxy the request method
   */
  Bridge.prototype.request = function (method, args, context, callback, errback) {
    var message = JSON.stringify({
      name: method,
      args: args || []
    });

    var wrap = function wrap(callback) {
      // Deserialize the event and call the callback in the
      // desired context
      return function (e) {
        if (!callback) return;
        e = JSON.parse(e);
        if (context) {
          callback.call(context, e);
        } else {
          callback(e);
        }
      };
    };

    var bridge = window._getSpotifyModule('bridge');

    return bridge.executeRequest(message, {
      onSuccess: wrap(callback),
      onFailure: wrap(errback)
    });
  };
}

/**
 * Listen for post messages being sent from core/bridge
 *
 * @todo Fix tests so we can use global window or something...
 */
Bridge.prototype._onPostMessage = function (e) {
  if (e.data === 'api-delay') {
    return; // Skip these
  }

  var message = {};

  try {
    message = typeof e.data === 'string' ? JSON.parse(e.data) : e.data;
  } catch (err) {
    // if the message is a non JSON string, do not handle it
    return;
  }

  if (message.type) {
    if (message.args) {
      message.data = message.data || {};
      message.data.args = message.args;
    }
    var extra = {
      origin: 'bridge'
    };

    if (message.context) {
      extra.context = message.context;
    }
    var evt = new Event(message.type, message.data, extra);
    evt.source = e.source;
    eventDispatcher.dispatchEvent(evt);
  }
};

/**
 * Proxy the request method
 */
Bridge.request = bridgeRequest;

module.exports = Bridge;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../../libs/spotify-bridge-request":253,"../../../libs/spotify-event-dispatcher":264,"./event":77}],27:[function(require,module,exports){
'use strict';

var cosmos = require('spotify-cosmos-api');
var localSettings = require('./models/localsettings');
var logger = require('./logging/client-event-logger');
var eventDispatcher = require('../../../libs/spotify-event-dispatcher');
var Event = require('./event');
var abbaSubscriber = require('./utils/abba-subscriber.js');

/**
 * Listens for player events and propagates AD_AUDIO_STARTED/FINISHED events
 * when an audio ad has started or finished.
 *
 * @constructor
 */
function CappingManagerListener() {
  this._onCosmosEvent = this._onCosmosEvent.bind(this);
  this.lastPlayingRemainingTime = localSettings.get('cappingPlaytimeRemainingSec');
  this.showWelcomeMessage = true;
  this._cappingExplainedABGroup = false;
  this.logger = logger;
}

CappingManagerListener.prototype.CAPPING_MANAGER_RESOLVER_URI = 'sp://capping/v1/updates';

/**
 * Start listening for capping manager events
 */
CappingManagerListener.prototype.start = function () {
  cosmos.resolver.subscribe(this.CAPPING_MANAGER_RESOLVER_URI, this._onCosmosEvent);
};

/**
 * Callback for cosmos capping manager events.
 *
 * @param {Object} error The error, if any.
 * @param {Object} event Response from c.
 */
CappingManagerListener.prototype._onCosmosEvent = function (error, event) {
  if (error) {
    return;
  }
  var response = event.getJSONBody();
  this.data = response;

  if (!response.capped) {
    return false;
  }

  if (localSettings.get('cappingPlaytimeRemainingSec') && response.playtime_remaining_sec > localSettings.get('cappingPlaytimeRemainingSec')) {
    // playtime_remaining_sec is higher than last saved value which means that playtime was refilled
    this._cappingRefilled();
  }

  this._showCappingWelcomeMessage();

  if (response.playtime_remaining_sec < response.next_refill_amount_sec / 2 && response.playtime_remaining_sec > 60 * 60) {
    this._showHalfLimitMessage();
  }

  if (response.playtime_remaining_sec < 60 * 60 && response.playtime_remaining_sec > 0) {
    this._showMessageIfNotSeen('cappingLimitNotificationSeen', 'approaching-capping-limit');
  }

  localSettings.set('cappingPlaytimeRemainingSec', response.playtime_remaining_sec);
  this.lastPlayingRemainingTime = response.playtime_remaining_sec;
  this.nextRefillInSec = response.next_refill_in_sec;
  this.lastUpdate = Date.now();
};

/**
 * Get the AB group for zi-capping-explained test and store it locally
 */
CappingManagerListener.prototype._getAbTestGroup = function (callback) {
  if (this._cappingExplainedABGroup !== false) {
    callback();
    return;
  }

  abbaSubscriber('zi-capping-explained', function (cellName) {
    this._cappingExplainedABGroup = cellName || 'Control';
    this._noCappingExplaination = cellName !== 'A';
    callback();
  }.bind(this));
};

/**
 * Handle showing capping explained welcome message
 */
CappingManagerListener.prototype._showCappingWelcomeMessage = function () {
  if (!!localSettings.get('cappingWelcomeMessageSeen') || this._noCappingExplaination) return;

  this._getAbTestGroup(function () {
    if (this._cappingExplainedABGroup === 'A') {
      eventDispatcher.dispatchEvent(new Event(Event.TYPES.CAPPING_OPEN_WELCOME_MESSAGE, {}));
      localSettings.set('cappingWelcomeMessageSeen', 'true');
    }
  }.bind(this));
};

/**
 * Handle showing half the limit passed notification if not seen yet
 */
CappingManagerListener.prototype._showHalfLimitMessage = function () {
  if (!!localSettings.get('cappingHalfLimitNotificationSeen') || this._noCappingExplaination) return;

  this._getAbTestGroup(function () {
    if (this._cappingExplainedABGroup === 'A') {
      this._showMessageIfNotSeen('cappingHalfLimitNotificationSeen', 'half-capping-limit-passed');
    }
  }.bind(this));
};

/**
 * Handle showing blue messagebar notification if not seen yet
 */
CappingManagerListener.prototype._showMessageIfNotSeen = function (flagName, messageKey) {
  if (!!localSettings.get(flagName)) return;

  cosmos.resolver.post({
    url: 'sp://messages/v1/container/user-message',
    body: { id: messageKey }
  });

  this.logger.log({
    event: 'user:impression',
    event_version: messageKey + '-messagebar'
  });
  localSettings.set(flagName, 'true');
};

/**
 * Reset settings when the capping gets refilled
 */
CappingManagerListener.prototype._cappingRefilled = function () {
  localSettings.delete('cappingLimitNotificationSeen');
  localSettings.delete('cappingHalfLimitNotificationSeen');
};

/**
 * Estimate next refill based on information from capping manager
 * and last update.
 */
CappingManagerListener.prototype.getNextRefillTimeInDays = function () {
  // If we don't have refill information return false
  if (Number.isNaN(this.nextRefillInSec)) return false;

  // We need to calculate how many seconds passed since we got
  // last refill information to estimate next refill time
  var now = Date.now();
  var diffInSec = (now - this.lastUpdate) / 1000;
  var nextRefillInSec = this.nextRefillInSec - diffInSec;

  // Calculate days from seconds and round them up
  var nextRefillInDays = Math.ceil(nextRefillInSec / 60 / 60 / 24);

  return nextRefillInDays > 0 ? nextRefillInDays : false;
};

/**
 * Reset capping manager
 */
CappingManagerListener.prototype.reset = function () {
  localSettings.delete('cappingPlaytimeRemainingSec');
  localSettings.delete('cappingLimitNotificationSeen');
  localSettings.delete('cappingHalfLimitNotificationSeen');
  localSettings.delete('cappingWelcomeMessageSeen');

  this.showWelcomeMessage = true;
  this._cappingExplainedABGroup = false;
};

/**
 * Get capping manager data
 */
CappingManagerListener.prototype.getData = function () {
  return {
    capped: this.data.capped,
    cappingData: this.data,
    cappingABGroup: this._cappingExplainedABGroup,
    cappingLimitNotificationSeen: localSettings.get('cappingLimitNotificationSeen'),
    cappingHalfLimitNotificationSeen: localSettings.get('cappingHalfLimitNotificationSeen'),
    cappingWelcomeMessageSeen: localSettings.get('cappingWelcomeMessageSeen')
  };
};

module.exports = new CappingManagerListener();

},{"../../../libs/spotify-event-dispatcher":264,"./event":77,"./logging/client-event-logger":93,"./models/localsettings":100,"./utils/abba-subscriber.js":121,"spotify-cosmos-api":694}],28:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _spotifyEventDispatcher = require('../../../libs/spotify-event-dispatcher');

var _spotifyEventDispatcher2 = _interopRequireDefault(_spotifyEventDispatcher);

var _event = require('./event');

var _event2 = _interopRequireDefault(_event);

var _player = require('./models/player');

var _player2 = _interopRequireDefault(_player);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var ClientState = function () {
  function ClientState() {
    _classCallCheck(this, ClientState);

    this._initialized = false;
    this._state = {
      loadedViews: [],
      playbackState: {},
      navigationHistory: [],
      clientVersion: window.__spotify && window.__spotify.client_version,
      startTime: null
    };
    this._playerSubscription = null;

    this.onNavigationHistoryChange = this.onNavigationHistoryChange.bind(this);
    this.onLoadedViewsChange = this.onLoadedViewsChange.bind(this);
    this.onPlayerStateUpdate = this.onPlayerStateUpdate.bind(this);
  }

  _createClass(ClientState, [{
    key: 'init',
    value: function init() {
      if (this._initialized) {
        throw new Error('ClientState has already been initialized');
      }
      _spotifyEventDispatcher2.default.addEventListener(_event2.default.TYPES.NAVIGATION_HISTORY_CHANGE, this.onNavigationHistoryChange);

      _spotifyEventDispatcher2.default.addEventListener(_event2.default.TYPES.VIEW_LOADED, this.onLoadedViewsChange);

      _spotifyEventDispatcher2.default.addEventListener(_event2.default.TYPES.VIEW_UNLOADED, this.onLoadedViewsChange);

      var player = _player2.default.getPlayer();
      this._playerSubscription = player.subscribe(this.onPlayerStateUpdate);

      this._state.startTime = Date.now();
      this._initialized = true;
    }
  }, {
    key: 'reset',
    value: function reset() {
      if (!this._initialized) {
        throw new Error('ClientState has not been initialized');
      }

      _spotifyEventDispatcher2.default.removeEventListener(_event2.default.TYPES.NAVIGATION_HISTORY_CHANGE, this.onNavigationHistoryChange);

      _spotifyEventDispatcher2.default.removeEventListener(_event2.default.TYPES.VIEW_LOADED, this.onLoadedViewsChange);

      _spotifyEventDispatcher2.default.removeEventListener(_event2.default.TYPES.VIEW_UNLOADED, this.onLoadedViewsChange);

      this._playerSubscription.cancel();
      this._playerSubscription = null;

      this._initialized = false;
      this._state.startTime = null;
    }
  }, {
    key: 'onNavigationHistoryChange',
    value: function onNavigationHistoryChange(event) {
      this._state.navigationHistory = event.params.history;
    }
  }, {
    key: 'onLoadedViewsChange',
    value: function onLoadedViewsChange(event) {
      this._state.loadedViews = event.params.loaded;
    }
  }, {
    key: 'onPlayerStateUpdate',
    value: function onPlayerStateUpdate(error, playbackState) {
      this._state.playbackState = playbackState.getJSONBody();
    }
  }, {
    key: 'getState',
    value: function getState() {
      if (!this._initialized) {
        throw new Error('ClientState has not been initialized');
      }
      return Object.assign({}, this._state, { uptime: Date.now() - this._state.startTime });
    }
  }, {
    key: 'isInitialized',
    get: function get() {
      return this._initialized;
    }
  }]);

  return ClientState;
}();

// Singleton


exports.default = new ClientState();

},{"../../../libs/spotify-event-dispatcher":264,"./event":77,"./models/player":101}],29:[function(require,module,exports){
'use strict';

var UUID = require('uuid-js');

/**
 * [callbacks data structure for callbacks and associated timeout]
 * @type {Object}
 */
var callbacks = {};

var onActivity = function onActivity() {
  for (var callback in callbacks) {
    if (!callbacks.hasOwnProperty(callback)) continue;

    clearTimeout(callbacks[callback].timeout);

    callbacks[callback].timeout = setTimeout(callbacks[callback].callback, callbacks[callback].ms);
  }
};

module.exports = {
  /**
   * [enableForWindow enables the activity monitor on a given window]
   * @param  {[Node]} w window object from iframe or main chrome
   */
  enableForWindow: function enableForWindow(w) {
    w.addEventListener('mousemove', onActivity, true);
    w.addEventListener('keydown', onActivity, true);
  },
  /**
   * [disableForWindow disables the activity monitor on a given window]
   * @param  {[Node]} w window object from iframe or main chrome
   */
  disableForWindow: function disableForWindow(w) {
    w.removeEventListener('mousemove', onActivity);
    w.removeEventListener('keydown', onActivity);
  },
  /**
   * [registerCallback define an activity monitor]
   * @param  {[Number]}   ms milliseconds of inactivity required
   * @param  {Function} cb callback to trigger on inactivity
   */
  registerCallback: function registerCallback(ms, cb) {
    var uuid = UUID.create();

    callbacks[uuid.toString()] = {
      timeout: null,
      ms: ms,
      callback: cb
    };

    return uuid.toString();
  },

  removeCallback: function removeCallback(uuid) {
    if (callbacks.hasOwnProperty(uuid)) {
      clearTimeout(callbacks[uuid].timeout);
      delete callbacks[uuid];
    }
  }
};

},{"uuid-js":737}],30:[function(require,module,exports){
'use strict';

function CircularLoader(type, canvas, width, height, initialProgress) {
  this._type = type;
  this._canvas = canvas;
  this._ctx = canvas.getContext('2d');

  this._pixelRatio = window.devicePixelRatio || 1;

  this._canvas.width = width * this._pixelRatio;
  this._canvas.height = height * this._pixelRatio;
  this._canvas.style.width = width;
  this._canvas.style.height = width;

  this._progress = initialProgress || 0;
  this._paintFrame(initialProgress || 0);
}

CircularLoader.prototype.setProgress = function (value) {
  this._paint(value);
};

CircularLoader.prototype.onComplete = function (fn) {
  this._onCompleteFn = fn;
};

CircularLoader.prototype._paintFrame = function (value) {
  var x = this._canvas.width / 2;
  var y = this._canvas.height / 2;
  var startAngle = -(Math.PI / 2);
  var endAngle = startAngle + value / 100 * Math.PI * 2;
  var lineWidth;
  var radius;

  this._ctx.clearRect(0, 0, this._canvas.width, this._canvas.height);

  if (this._type === 'circle') {
    lineWidth = 2 * this._pixelRatio;
    radius = this._canvas.width / 2 - lineWidth / 2;

    // Stroke
    this._ctx.beginPath();
    this._ctx.arc(x, y, radius, startAngle, endAngle, false);
    this._ctx.lineWidth = lineWidth;
    this._ctx.strokeStyle = '#1DB854'; // @color-green
    this._ctx.stroke();
  } else if (this._type === 'pie') {
    radius = this._canvas.width / 2;

    // Background
    this._ctx.beginPath();
    this._ctx.arc(x, y, radius, 0, Math.PI * 2, false);
    this._ctx.fillStyle = '#404040'; // @color-decorative
    this._ctx.fill();

    // Pie fill
    this._ctx.beginPath();
    this._ctx.moveTo(x, y);
    this._ctx.arc(x, y, radius, startAngle, endAngle, false);
    this._ctx.fillStyle = '#1DB854'; // @color-green
    this._ctx.fill();
  }
};

CircularLoader.prototype._paint = function (value) {
  if (!value) {
    return;
  }

  var currentValue = this._progress;
  this._progress = value;

  if (this._next) {
    return;
  }

  if (this._progress < currentValue) {
    this._paintFrame(this._progress);
    return;
  }

  // delay in ms
  var delay = 100;

  var paint = function () {
    this._paintFrame(currentValue);

    var increment = (this._progress - currentValue) / 100 * (delay * 60 / 1000);
    currentValue += Math.max(increment, 1);
    if (currentValue < this._progress) {
      this._next = window.requestAnimationFrame(paint);
      return;
    } else if (this._progress >= 100 && this._onCompleteFn) {
      this._onCompleteFn();
    }
    this._next = null;
  }.bind(this);

  paint();
};

module.exports = CircularLoader;

},{}],31:[function(require,module,exports){
'use strict';

var _ = require('../../i18n').get;

var _spoticon = function _spoticon(name, size) {
  return 'spoticon-' + name + '-' + (size || '16');
};

var techMessage = {
  'cast_video': _('connect.device_tech_cast'),
  'cast_audio': _('connect.device_tech_cast'),
  'local': _('connect.device_this_computer')
};

var stateMessages = {
  // Connecting, play pending
  connecting: _('connect.device_connecting'),

  // Incompatible protocol version
  incompatible: _('connect.device_incompatible'),

  // Unavailable for playback
  unavailable: _('connect.device_unavailable_for_playback'),

  // Premium account required
  premium_required: _('connect.device_premium_only'),

  // Unsupported content
  unsupported_uri: _('connect.device_unsupported_uri'),

  // Device is sleeping (PS4 only)
  sleeping: _('connect.device_sleeping'),

  // Unknown state
  unknown: _('connect.device_unknown'),

  // Not authorized to wake up
  not_authorized: _('connect.device_unavailable_for_playback')

  // Unused states
  // 'logged_in' : // Logged in
  // 'not_logged_in' : // Not logged in
  // 'not_installed': _('connect.not_installed') // Not installed (PS4 only)
};

function ConnectDevice(device) {
  this.id = device.identifier;
  this.type = device.type;
  this.name = device.name;

  this.attached = device.is_attached;
  this.active = device.is_active;
  this.zeroconf = device.is_zeroconf;
  this.webapp = device.is_webapp;
  this.connect = device.is_connect;
  this.can_play = device.can_play;
  this.state = device.state;
  this.not_available = !!stateMessages[device.state];

  if (device.supports_volume !== undefined) {
    // We can not control volume on cast devices,
    // since no Cast SDK on zelda.
    this.supports_volume = device.supports_volume && !this.isCast();
  } else {
    // Fallback until client-core changes are included
    this.supports_volume = this.can_play && this.type !== 'smartphone' && this.type !== 'tablet' && !this.isCast();
  }
}

ConnectDevice.prototype.subtitle = function () {
  if (this.active) {
    return _('connect.playingon');
  }
  return this.name;
};

ConnectDevice.prototype.title = function () {
  if (this.active) return this.name;
  return stateMessages[this.state] || techMessage[this.type] || _('connect.device_tech_connect');
};

ConnectDevice.prototype.isCast = function () {
  return this.type === 'cast_audio' || this.type === 'cast_video';
};

ConnectDevice.prototype.icon = function () {
  return this.isCast() ? _spoticon('chromecast-connected') : _spoticon('spotify-connect');
};

ConnectDevice.prototype.image = function () {
  var name;
  switch (this.type) {
    case 'computer':
    case 'local':
      name = 'device-computer';
      break;
    case 'smartphone':
      name = 'device-mobile';
      break;
    case 'tablet':
      name = 'device-tablet';
      break;
    case 'game_console':
      name = 'games-console';
      break;
    case 'automobile':
      name = 'device-car';
      break;
    case 'tv':
    case 'cast_video':
      name = 'device-tv';
      break;
    case 'audiodongle':
    case 'cast_audio':
    case 'speaker':
    case 'unknown':
    case 'avr':
    case 'stb':
    default:
      name = 'device-speaker';
  }
  return _spoticon(name, 32);
};

ConnectDevice.prototype.offlineReason = function () {
  switch (this.type) {
    case 'computer':
    case 'local':
      return _('connect.offline_reason_computer');
    case 'smartphone':
      return _('connect.offline_reason_phone');
    case 'game_console':
      return this.state === 'not_authorized' ? _('connect.offline_reason_gameconsole') : _('connect.offline_reason_generic');
    default:
      return _('connect.offline_reason_generic');
  }
};

ConnectDevice.prototype.isPremiumOnly = function () {
  return this.state === 'premium_required';
};

ConnectDevice.prototype.deviceState = function (parent) {
  var clz = [];

  if (!this.id) {
    clz.push('device-self');
  }

  if (this.not_available || parent.adIsPlaying()) {
    clz.push('not-available');
  } else {
    clz.push('selectable');
  }

  if (this.active) {
    clz.push('active');
  }

  if (this.state) {
    clz.push(this.state.replace(/_/, '-'));
  }

  clz.push('device-type-' + (this.type || 'unknown').replace(/_/, '-'));
  clz.push('device-tech-' + (this.isCast() ? 'cast' : 'connect'));

  return clz.join(' ');
};

ConnectDevice.prototype.tooltip = function () {
  return this.not_available ? this.offlineReason() : '';
};

module.exports = ConnectDevice;

},{"../../i18n":11}],32:[function(require,module,exports){
'use strict';

var ko = require('knockout');
var session = require('../models/session');
var _ = require('../../i18n').get;
var eventDispatcher = require('../../../../libs/spotify-event-dispatcher');
var cosmos = require('spotify-cosmos-api');
var UIInteraction4 = require('../../../../libs/spotify-logger/messages/UIInteraction4');
var RateLimiter = require('../../../../libs/spotify-rate-limiter');
var scrollBarEvents = require('../../../../libs/spotify-events/scrollbar');
var Event = require('../event');
var keyboard = require('../keyboard');
var glue = require('../../../../libs/spotify-glue-cat');

/**
 * View model to manage the connect device and volume popup
 */
function ConnectPopup(connectHelper) {
  eventDispatcher.addEventListener(Event.TYPES.CONNECTION_STATE_CHANGE, this._handleConnectionStateChange.bind(this));

  var self = this;
  this.connectHelper = connectHelper;
  this.offlineVisible = ko.observable(true);
  this.visible = ko.observable(false);
  this.devices = ko.observableArray([]);
  this.upsell = ko.observable(false);
  this.teaser = ko.observable(false);
  this.premium = ko.observable(false);
  this.adIsPlaying = ko.observable(false);

  this.focused = ko.observable();
  this.headerVisible = ko.pureComputed(function () {
    return self.visible() && !self.offlineVisible() && !self.upsellVisible();
  });
  this.devicesVisible = ko.pureComputed(function () {
    return self.visible() && !self.offlineVisible() && self.devices().length > 1;
  });
  this.upsellVisible = ko.pureComputed(function () {
    return self.visible() && !self.offlineVisible() && self.upsell();
  });
  this.helpVisible = ko.pureComputed(function () {
    return self.visible() && !self.offlineVisible() && self.devices().length === 1;
  });
  this.devicesAvailableVisible = ko.pureComputed(function () {
    return !self.adIsPlaying() && self.devices().length > 1;
  });

  this.isShowingHelp = true;

  // Text
  this.title = _('connect.popup_title');
  this.connectToDeviceText = _('connect.connect_text');
  this.upsellText = _('connect.upsell');
  this.helpText1 = _('connect.help1');
  this.helpText2 = _('connect.help2');
  this.connectOfflineTitle = _('connect.offline_title');
  this.connectOfflineText1 = _('connect.offline_text1');
  this.showMoreLabel = _('connect.show_more');
  this.upgradeLabel = _('connect.upgrade');
  this.dismissLabel = _('connect.dismiss');
  this.helpHintText = _('connect.help_hint');

  // Allow one log transaction per second
  this._logRateLimiter = new RateLimiter(1);
  this._modalBackground = null;

  var connectPickerId = glue.getVersion() === 1 ? 'connect-picker' : 'connect-picker-glue2';

  this._element = document.getElementById(connectPickerId);

  eventDispatcher.addEventListener(Event.TYPES.SPCONNECT_DEVICE_STATE, function (e) {
    self.devices(e.params.devices);
    self.devices.sort(ConnectPopup.compareDevices);

    // When there's no playback happening in any device, no device is active
    // and the focus should be in this one
    self.focused(0);
    self.devices().forEach(function (device, index) {
      if (device.active) {
        self.focused(index);
      }
    });
  });
  eventDispatcher.addEventListener(Event.TYPES.AD_AUDIO_STARTED, this._adStarted.bind(this));
  eventDispatcher.addEventListener(Event.TYPES.AD_AUDIO_FINISHED, this._adFinished.bind(this));
  eventDispatcher.addEventListener(Event.TYPES.AD_VIDEO_STARTED, this._adStarted.bind(this));
  eventDispatcher.addEventListener(Event.TYPES.AD_VIDEO_FINISHED, this._adFinished.bind(this));
  eventDispatcher.addEventListener(Event.TYPES.PLAYER_VOLUME, this._volumeChanged.bind(this));

  this._registerKeyboardShortcuts();
  this._registerMessageSubscriber();
  this.selectDevice = this.selectDevice.bind(this);

  // Update scroll bars when visibility is toggled
  this.devicesVisible.subscribe(function () {
    setTimeout(function () {
      scrollBarEvents.update();
    }, 0);
  });

  // Update scroll bars when device list is changing
  this.devices.subscribe(function () {
    setTimeout(function () {
      scrollBarEvents.update();
    }, 0);
  });
}

ConnectPopup.prototype.isPlayingRemotely = function () {
  return this.devices().filter(function (dev) {
    return dev.type !== 'local' && dev.active;
  }).length > 0;
};

ConnectPopup.prototype.currentDevice = function () {
  return this.devices().filter(function (dev) {
    return dev.type !== 'local' && dev.active;
  })[0] || {};
};

ConnectPopup.prototype.currentDeviceTechIcon = function () {
  var active = this.devices().find(function (dev) {
    return dev.active;
  });
  return [active ? active.icon() : 'spoticon-spotify-connect-16'];
};

ConnectPopup.prototype._adStarted = function () {
  this.adIsPlaying(true);
  if (this.visible()) this.hide();
};

ConnectPopup.prototype._adFinished = function () {
  this.adIsPlaying(false);
};

ConnectPopup.prototype._volumeChanged = function () {
  if (this.isPlayingRemotely()) {
    this._logUIInteraction4('seek', 'connect-volume-changed');
  }
};

ConnectPopup.prototype._popoverId = 'connectpopup';

/**
 * Helper method to log player UIInteraction4 messages.
 */
ConnectPopup.prototype._logUIInteraction4 = function (interactionType, userIntent) {
  if (this._logRateLimiter.acquire()) {
    UIInteraction4.log({
      'feature_id': 'zlink',
      'section_id': 'player',
      'interaction_type': interactionType,
      'user_intent': userIntent
    });
  }
};

/**
 * Register internal message subscribers
 */
ConnectPopup.prototype._registerMessageSubscriber = function () {
  var self = this;

  var endpoint = 'sp://messages/v1/container/connect/popup';
  cosmos.resolver.subscribe(endpoint, function (error, resp) {
    if (error) throw error;
    var data = resp.getJSONBody();
    var source = data.source || 'unknown';

    // Not specified -> Toggle picker
    if (!data.open && !data.hide) {
      var show = !self.visible();
      data.open = show;
      data.hide = !show;
    }

    if (data.open) {
      self.show();
      self._logUIInteraction4(source, 'show-connect-device-list');
    }
    if (data.hide) {
      self.hide();
      self._logUIInteraction4(source, 'hide-connect-device-list');
    }
  });
};

ConnectPopup.prototype._registerKeyboardShortcuts = function () {
  var self = this;

  // Close the menu when pressing ESC
  keyboard.registerImportantShortcut(keyboard.KEYS.ESCAPE, function (e) {
    if (self.visible()) {
      e.preventDefault();
      self.hide();
    }
  });

  // Focus on the device above when pressing the UP arrow
  keyboard.registerIsolatedShortcut(keyboard.KEYS.ARROW_UP, this._element, function (e) {
    if (self.visible()) {
      e.preventDefault();
      (function _selectPrevious(currPosition) {
        currPosition = isFinite(currPosition) ? currPosition : self.focused();
        var newFocus = currPosition - 1;
        var devices = self.devices();
        if (newFocus < 0) {
          // Circular selection
          newFocus = devices.length - 1;
        }
        var deviceCanBeSelected = !devices[newFocus].not_available;

        if (deviceCanBeSelected) {
          self.focused(newFocus);
        } else {
          // If the element above is not available, go to the one above that
          // recursively
          _selectPrevious(newFocus);
        }
      })();
    }
  });

  // Focus on the device below when pressing the DOWN arrow
  keyboard.registerIsolatedShortcut(keyboard.KEYS.ARROW_DOWN, this._element, function (e) {
    if (self.visible()) {
      e.preventDefault();
      (function _selectNext(currPosition) {
        currPosition = isFinite(currPosition) ? currPosition : self.focused();
        var devices = self.devices();
        var length = devices.length;
        var newFocus = (currPosition + 1) % length;
        var deviceCanBeSelected = !devices[newFocus].not_available;

        if (deviceCanBeSelected) {
          self.focused(newFocus);
        } else {
          // If the device cannot be selected, jump to the next, recursively
          _selectNext(newFocus);
        }
      })();
    }
  });

  keyboard.registerIsolatedShortcut(keyboard.KEYS.ENTER, this._element, function (e) {
    if (self.visible()) {
      e.preventDefault();
      // Select the device focused when pressing enter
      self.selectDevice(self.devices()[self.focused()]);
    }
  });
};

ConnectPopup.prototype._handleConnectionStateChange = function (e) {
  this.offlineVisible(e.params.status !== 'online');
};

ConnectPopup.prototype.showHelp = function () {
  this.openExternalPage('https://www.spotify.com/connect');
};

ConnectPopup.prototype._isDescendantElement = function (element1, element2) {
  if (element1 === element2) {
    return true;
  }
  if (element1 === document.body) {
    return false;
  }

  return this._isDescendantElement(element1.parentElement, element2);
};

// renders a transparent div to listen to clicks outside the window
ConnectPopup.prototype._renderModalBackground = function () {
  var glueVersion = glue.getVersion();
  var connectContainerId = glueVersion === 1 ? 'connect-container' : 'connect-container-glue2';
  var connectId = glueVersion === 1 ? 'connect' : 'connect-glue2';
  var modalBackgroundId = glueVersion === 1 ? 'connect-container-background' : 'connect-container-background-glue2';

  this._connectContainer = document.getElementById(connectContainerId);
  this._connecticon = document.getElementById(connectId);
  this._modalBackground = document.createElement('div');
  this._modalBackground.id = modalBackgroundId;
  this._modalBackgroundClickEvent = function (evt) {
    if (this.visible() && !this._isDescendantElement(evt.target, this._connecticon) && !this._isDescendantElement(evt.target, this._connectContainer)) {
      this.hide();
    }
  }.bind(this);
  document.body.addEventListener('click', this._modalBackgroundClickEvent, false);

  document.body.insertBefore(this._modalBackground, document.body.firstChild);
};

ConnectPopup.prototype._destroyModalBackground = function () {
  document.body.removeEventListener('click', this._modalBackgroundClickEvent);
  document.body.removeChild(this._modalBackground);
  this._modalBackground = null;
};

ConnectPopup.prototype.show = function () {
  this.connectHelper.scan();
  this._renderModalBackground();
  this.visible(true);

  this._activeElement = document.activeElement;
  this._element.focus();

  eventDispatcher.dispatchEvent(new Event(Event.TYPES.POPOVER_OPENED, { id: this._popoverId }));
};

ConnectPopup.prototype.hide = function () {
  this.visible(false);
  this._destroyModalBackground();

  if (this._activeElement) {
    this._activeElement.focus();
    this._activeElement = null;
  }

  eventDispatcher.dispatchEvent(new Event(Event.TYPES.POPOVER_CLOSED, { id: this._popoverId }));
};

ConnectPopup.prototype.openExternalPage = function (url) {
  session.getOAuthToken(url, function (err, token) {
    if (!err) {
      window.open(url + '?' + token);
    }
  });
};

ConnectPopup.prototype.onShowMore = function () {
  this.openExternalPage('https://www.spotify.com/connect');
};

ConnectPopup.prototype.onUpgrade = function () {
  // Todo: This should use an oauth token
  this.openExternalPage('https://www.spotify.com/upgrade');
};

ConnectPopup.prototype.selectDevice = function (device) {
  if (device.not_available) {
    return;
  }
  this.connectHelper.transferPlayback(device.id);
  this.hide();
};

ConnectPopup.compareDevices = function (a, b) {
  if (a.type === 'local') return -1;
  if (b.type === 'local') return 1;

  return (a.name || '').toLowerCase().localeCompare((b.name || '').toLowerCase());
};

module.exports = ConnectPopup;

},{"../../../../libs/spotify-event-dispatcher":264,"../../../../libs/spotify-events/scrollbar":298,"../../../../libs/spotify-glue-cat":348,"../../../../libs/spotify-logger/messages/UIInteraction4":452,"../../../../libs/spotify-rate-limiter":490,"../../i18n":11,"../event":77,"../keyboard":83,"../models/session":107,"knockout":567,"spotify-cosmos-api":694}],33:[function(require,module,exports){
'use strict';

var inherit = require('spotify-inheritance/inherit');
var BaseAction = require('./base');

var _ = require('../../../../i18n').get;
var liburi = require('spotify-liburi');
var Tree = require('spotify-tree');

var isFolder = function isFolder(playlist) {
  return liburi.from(playlist.uri).type === liburi.Type.FOLDER;
};

var getId = function getId(playlist) {
  // remove the :end marker in the folder-end rows
  // to match against the folder start rows
  return playlist.uri.replace(/\:end$/, '');
};

var AddToPlaylist = function AddToPlaylist() {
  BaseAction.apply(this, arguments);
};
inherit(AddToPlaylist, BaseAction);

AddToPlaylist.prototype.buildItem = function (uris, extra) {
  this._uris = uris;
  this._appUri = extra && extra.appURI || null;
  this._playlistNames = {};

  if (uris[0].type === liburi.Type.TRACK || uris[0].type === liburi.Type.LOCAL || uris[0].type === liburi.Type.ALBUM && uris.length <= 1) {
    this._playlistsTree = Tree.fromArray(this._adaptor.getUserPlaylists(), isFolder, getId);

    this._contextMenu.addItem({
      id: 'add-to-playlist',
      text: _('contextmenu.add-to-playlist'),
      filter: true,
      items: this._buildPlaylists()
    });

    this._fetch(this._playlistsTree);

    if (uris[0].type === liburi.Type.ALBUM) {
      this.disableIfClientOffline('add-to-playlist');
    }
  }
};

AddToPlaylist.prototype._buildPlaylists = function () {
  var items = [{
    text: _('contextmenu.new-playlist'),
    fn: this._chooseNameAndCreatePlaylist.bind(this)
  }, {}];

  return items.concat(this._buildFolder(this._playlistsTree));
};

AddToPlaylist.prototype._buildFolder = function (folder) {
  return folder.items.map(this._mapTree.bind(this));
};

AddToPlaylist.prototype._mapTree = function (playlist) {
  var output = {
    id: playlist.uri,
    text: _('contextmenu.playlist.loading')
  };

  if (isFolder(playlist) && playlist.items) {
    // Build a folder
    output.items = this._buildFolder(playlist);
  }
  return output;
};

AddToPlaylist.prototype._mapData = function (data) {
  var output = {};

  if (isFolder(data)) {
    // Build a folder
    output = {
      text: data.name,
      filter: true
    };
  } else {
    // Build a playlist
    var name = data.name;

    if (data.owner && !data.owner.currentUser) {
      var ownerName = data.owner.name || data.owner.username;
      name += ' (' + _('contextmenu.owner-playlist', ownerName) + ')';
    }

    output = {
      text: name,
      fn: this._addToPlaylist.bind(this, data.uri),
      disabled: !(data.allows && data.allows.insertTracks)
    };
  }
  return output;
};

AddToPlaylist.prototype._setPlaylistData = function (parents, data) {
  parents = ['add-to-playlist'].concat(parents);

  var item = this._mapData(data);
  if (item) {
    this._contextMenu.updateItem(parents, item);
  }
};

AddToPlaylist.prototype._fetch = function (folder) {
  var self = this;

  folder.items.forEach(function (playlist) {
    self._adaptor.getPlaylistMetadata(playlist.uri, function (err, data) {
      if (!err) {
        var parents = playlist.parents.map(function (parent) {
          return parent.uri;
        });

        self._setPlaylistData(parents.concat(data.uri), data);
        self._playlistNames[data.name] = true;

        if (isFolder(playlist)) {
          self._fetch(playlist);
        } else if (!data.allows.insertTracks) {
          self._contextMenu.removeItem(['add-to-playlist'].concat(parents, data.uri));
        }
      }
    });
  });
};

AddToPlaylist.prototype._addToPlaylist = function (playlistUri) {
  var self = this;

  this._adaptor.addStuffToPlaylist(playlistUri, self._uris, function () {
    self._logAddToPlaylist({ playlistUri: playlistUri, isNew: false });
    self._contextMenu.hide();
  });
};

AddToPlaylist.prototype._logAddToPlaylist = function (options) {
  var indexedItem = this._playlistsTree.getIndexedItem(options.playlistUri);

  var isInFolder = indexedItem && indexedItem.parent && indexedItem.parent.parent !== null;

  var playlistIndex = indexedItem && indexedItem.parent && indexedItem.parent.items.indexOf(indexedItem);

  if (typeof playlistIndex !== 'number' || playlistIndex < 0) {
    playlistIndex = null;
  }

  var numberOfVisibleItems = indexedItem && indexedItem.parent && indexedItem.parent.size || null;

  this._adaptor.logAddToPlaylist({
    playlistUri: options.playlistUri,
    uris: this._uris,
    appUri: this._appUri,
    isNew: options.isNew,
    isInFolder: isInFolder,
    playlistIndex: playlistIndex,
    numberOfVisibleItems: numberOfVisibleItems
  });
};

AddToPlaylist.prototype._chooseNameAndCreatePlaylist = function () {
  var self = this;

  this._adaptor.getNewPlaylistName(this._uris, function (err, name) {
    if (err) {
      return;
    }

    name = self._findAvailableName(name);

    self._adaptor.createNewPlaylist(name, function (err, playlistUri) {
      if (err) {
        return;
      }

      self._adaptor.addStuffToPlaylist(playlistUri, self._uris, function () {
        self._logAddToPlaylist({ playlistUri: playlistUri, isNew: true });
        self._contextMenu.hide();
      });
    });
  });
};

AddToPlaylist.prototype._isNameTaken = function (name) {
  return !!this._playlistNames[name];
};

AddToPlaylist.prototype._findAvailableName = function (baseName) {
  var name = baseName;
  var num = 2;

  while (this._isNameTaken(name)) {
    name = baseName + ' ' + num;
    num++;
  }
  return name;
};

/**
 * Export public interface
 */
module.exports = AddToPlaylist;

},{"../../../../i18n":11,"./base":34,"spotify-inheritance/inherit":706,"spotify-liburi":707,"spotify-tree":733}],34:[function(require,module,exports){
'use strict';

var BaseAction = function BaseAction(adaptor, contextMenu, abba, bridge) {
  this._adaptor = adaptor;
  this._contextMenu = contextMenu;
  this._abba = abba;
  this._bridge = bridge;
};

BaseAction.prototype.buildItem = function () {
  // base method
};

/**
 * Disables the provided itemId inside the contextMenu,
 * if the client is reported as offline
 */
BaseAction.prototype.disableIfClientOffline = function (itemId) {
  var self = this;

  this._adaptor.isClientOnline(function (err, online) {
    if (err || !online) {
      self._contextMenu.updateItem(itemId, { disabled: true });
    }
  });
};

/**
 * Export public interface
 */
module.exports = BaseAction;

},{}],35:[function(require,module,exports){
'use strict';

var inherit = require('spotify-inheritance/inherit');
var BaseAction = require('./base');

var _ = require('../../../../i18n').get;
var liburi = require('spotify-liburi');

var Clipboard = function Clipboard() {
  BaseAction.apply(this, arguments);
};
inherit(Clipboard, BaseAction);

Clipboard.prototype.buildItem = function (uris) {
  if (uris[0].type === liburi.Type.FOLDER || uris[0].type === liburi.Type.LOCAL) {
    return;
  }

  this._uris = uris;

  var linkText;
  switch (uris[0].type) {
    case liburi.Type.ARTIST:
      linkText = 'copy-artist-url';
      break;
    case liburi.Type.ALBUM:
      linkText = 'copy-album-url';
      break;
    case liburi.Type.TRACK:
      linkText = 'copy-track-url';
      break;
    case liburi.Type.PLAYLIST:
      linkText = 'copy-playlist-url';
      break;
    case liburi.Type.PROFILE:
      linkText = 'copy-profile-url';
      break;
    case liburi.Type.STATION:
      linkText = 'copy-station-url';
      break;
    default:
      linkText = 'copy-url';
  }

  this._contextMenu.addItem({
    id: 'copy-url',
    text: _('contextmenu.' + linkText),
    fn: this._copy.bind(this, false)
  });

  this._contextMenu.addItem({
    id: 'copy-uri',
    text: _('contextmenu.copy-uri'),
    fn: this._copy.bind(this, true)
  });

  // Spotify Play Button valid entities
  if (uris.length === 1 && uris[0].type === liburi.Type.ARTIST || uris[0].type === liburi.Type.ALBUM || uris[0].type === liburi.Type.TRACK || uris[0].type === liburi.Type.PLAYLIST || uris[0].type === liburi.Type.STATION) {
    this._contextMenu.addItem({
      id: 'copy-embed',
      text: _('contextmenu.copy-embed'),
      fn: this._copyEmbed.bind(this)
    });
  }

  this._adaptor.getFormatListType(uris[0], function (error, data) {
    if (data.formatListType === 'chart') {
      this._contextMenu.updateItem(['copy-url'], {
        text: _('contextmenu.copy-chart-url')
      });
    }
  }.bind(this));
};

Clipboard.prototype._copy = function (isUri) {
  var self = this;

  var text = this._uris.map(function (el) {
    return isUri ? el.toURI() : el.toOpenURL();
  }).join('\n');

  this._adaptor.saveToClipboard(text, function (err) {
    if (!err) {
      self._contextMenu.hide();
    }
  });
};

Clipboard.prototype._copyEmbed = function () {
  var self = this;
  var uri = this._uris[0];
  // XXX(montag):
  // The URI to embed.spotify.com cannot be double-encoded.
  // For example, the following (username iamkjellström) doesn't work:
  // https://embed.spotify.com/?uri=
  // spotify%3Auser%3Aiamkjellstr%25C3%25B6m%3Aplaylist%3A0UxbgJZ131jo6zNjwFsfMY
  // This should probably be considered a bug in embed.spotify.com.
  var encodedUri = encodeURIComponent(decodeURIComponent(uri.toURI()));

  var text = '<iframe src="https://embed.spotify.com/?uri=' + encodedUri + '" width="300" height="380" frameborder="0" allowtransparency="true">' + '</iframe>';

  this._adaptor.saveToClipboard(text, function (err) {
    if (!err) {
      self._contextMenu.hide();
    }
  });
};

/**
 * Export public interface
 */
module.exports = Clipboard;

},{"../../../../i18n":11,"./base":34,"spotify-inheritance/inherit":706,"spotify-liburi":707}],36:[function(require,module,exports){
'use strict';

var inherit = require('spotify-inheritance/inherit');
var BaseAction = require('./base');

var _ = require('../../../../i18n').get;
var liburi = require('spotify-liburi');

var Collaborative = function Collaborative() {
  BaseAction.apply(this, arguments);
};
inherit(Collaborative, BaseAction);

Collaborative.prototype.buildItem = function (uris) {
  var self = this;

  if (uris.length > 1 || uris[0].type !== liburi.Type.PLAYLIST) {
    return;
  }

  this._uri = uris[0];

  if (!this._adaptor.isPlaylistInRootlist(this._uri)) {
    return;
  }

  this._contextMenu.addItem({
    id: 'collaborative',
    text: _('contextmenu.collaborative'),
    disabled: this._adaptor.getUsername() !== this._uri.username,
    value: false
  });

  this._adaptor.getCollaborativeStatus(this._uri, function (err, data) {
    if (err) {
      return;
    }

    self._contextMenu.updateItem('collaborative', {
      value: data.collaborative,
      fn: self._setCollaborative.bind(self, !data.collaborative)
    });
  });

  this._adaptor.getFormatListType(this._uri, function (error, data) {
    if (error) return;
    if (data.formatListType === 'chart') {
      this._contextMenu.removeItem(['collaborative']);
    }
  }.bind(this));
};

Collaborative.prototype._setCollaborative = function (collaborative) {
  var self = this;

  this._adaptor.setPlaylistCollaborative(this._uri, collaborative, function () {
    self._contextMenu.hide();
  });
};

/**
 * Export public interface
 */
module.exports = Collaborative;

},{"../../../../i18n":11,"./base":34,"spotify-inheritance/inherit":706,"spotify-liburi":707}],37:[function(require,module,exports){
'use strict';

var inherit = require('spotify-inheritance/inherit');
var BaseAction = require('./base');

var _ = require('../../../../i18n').get;
var liburi = require('spotify-liburi');

var Collection = function Collection() {
  BaseAction.apply(this, arguments);
};
inherit(Collection, BaseAction);

Collection.prototype.buildItem = function (uris) {
  if (uris[0].type !== liburi.Type.TRACK && uris[0].type !== liburi.Type.ALBUM) {
    return;
  }
  this._uris = uris;

  this._contextMenu.addItem({
    id: 'collection',
    disabled: true,
    text: _('contextmenu.save')
  });

  this._fetch();
};

Collection.prototype._fetch = function () {
  var self = this;

  this._adaptor.areAllItemsInCollection(this._uris, function (err, value) {
    if (err || !value) {
      self._enableSave();
    } else {
      self._enableRemove();
    }

    if (self._uris[0].type === liburi.Type.ALBUM) {
      self.disableIfClientOffline('collection');
    }
  });
};

Collection.prototype._enableRemove = function () {
  this._contextMenu.updateItem('collection', {
    disabled: false,
    text: _('contextmenu.remove'),
    fn: this._remove.bind(this)
  });
};

Collection.prototype._enableSave = function () {
  this._contextMenu.updateItem('collection', {
    disabled: false,
    fn: this._save.bind(this)
  });
};

Collection.prototype._save = function () {
  var self = this;

  this._adaptor.saveItemsToCollection(this._uris, function (err) {
    if (!err) {
      self._contextMenu.hide();
    }
  });
};

Collection.prototype._remove = function () {
  var self = this;

  this._adaptor.removeItemsFromCollection(this._uris, function (err) {
    if (!err) {
      self._contextMenu.hide();
    }
  });
};

/**
 * Export public interface
 */
module.exports = Collection;

},{"../../../../i18n":11,"./base":34,"spotify-inheritance/inherit":706,"spotify-liburi":707}],38:[function(require,module,exports){
'use strict';

var inherit = require('spotify-inheritance/inherit');
var BaseAction = require('./base');

var _ = require('../../../../i18n').get;
var liburi = require('spotify-liburi');

var CreateFolder = function CreateFolder() {
  BaseAction.apply(this, arguments);
};
inherit(CreateFolder, BaseAction);

CreateFolder.prototype.buildItem = function (uris, extra) {
  if (uris.length > 1 || !extra.contexts) {
    return;
  }

  this._uri = uris[0];

  if (!extra.contexts || !extra.contexts[0] || extra.contexts[0].uri !== 'spotify:internal:sidebar') {
    return;
  }

  if (!this._adaptor.isPlaylistInRootlist(this._uri)) {
    return;
  }

  if (this._uri.type !== liburi.Type.PLAYLIST && this._uri.type !== liburi.Type.FOLDER) {
    return;
  }

  if (!this._customCreate) {
    return;
  }

  this._contextMenu.addItem({
    id: 'create-folder',
    text: _('contextmenu.create-folder'),
    disabled: false,
    fn: this._create.bind(this)
  });
};

CreateFolder.prototype.setAction = function (fn) {
  this._customCreate = fn;
};

CreateFolder.prototype._create = function () {
  this._customCreate(this._uri.toString());
  this._contextMenu.hide();
};

/**
 * Export public interface
 */
module.exports = CreateFolder;

},{"../../../../i18n":11,"./base":34,"spotify-inheritance/inherit":706,"spotify-liburi":707}],39:[function(require,module,exports){
'use strict';

var inherit = require('spotify-inheritance/inherit');
var BaseAction = require('./base');

var _ = require('../../../../i18n').get;
var liburi = require('spotify-liburi');

var CreatePlaylist = function CreatePlaylist() {
  BaseAction.apply(this, arguments);
};
inherit(CreatePlaylist, BaseAction);

CreatePlaylist.prototype.buildItem = function (uris, extra) {
  if (uris.length > 1 || !extra.contexts) {
    return;
  }

  this._uri = uris[0];

  if (!extra.contexts || !extra.contexts[0] || extra.contexts[0].uri !== 'spotify:internal:sidebar') {
    return;
  }

  if (!this._adaptor.isPlaylistInRootlist(this._uri)) {
    return;
  }

  if (this._uri.type !== liburi.Type.PLAYLIST && this._uri.type !== liburi.Type.FOLDER) {
    return;
  }

  if (!this._customCreate) {
    return;
  }

  this._contextMenu.addItem({
    id: 'create-playlist',
    text: _('contextmenu.create-playlist'),
    disabled: false,
    fn: this._create.bind(this)
  });
};

CreatePlaylist.prototype.setAction = function (fn) {
  this._customCreate = fn;
};

CreatePlaylist.prototype._create = function () {
  this._customCreate(this._uri.toString());
  this._contextMenu.hide();
};

/**
 * Export public interface
 */
module.exports = CreatePlaylist;

},{"../../../../i18n":11,"./base":34,"spotify-inheritance/inherit":706,"spotify-liburi":707}],40:[function(require,module,exports){
'use strict';

var inherit = require('spotify-inheritance/inherit');
var BaseAction = require('./base');

var _ = require('../../../../i18n').get;
var liburi = require('spotify-liburi');

var DeletePlaylist = function DeletePlaylist() {
  BaseAction.apply(this, arguments);
};
inherit(DeletePlaylist, BaseAction);

DeletePlaylist.prototype.buildItem = function (uris) {
  if (uris.length > 1) {
    return;
  }

  this._uri = uris[0];

  if (this._uri.type !== liburi.Type.PLAYLIST && this._uri.type !== liburi.Type.FOLDER || this._uri.username !== this._adaptor.getUsername()) {
    return;
  }

  if (!this._customRemove) {
    // only show the option if there is a custom remove action
    return;
  }

  if (!this._adaptor.isPlaylistInRootlist(this._uri)) {
    return;
  }

  this._contextMenu.addItem({
    id: 'delete-playlist',
    text: _('contextmenu.delete-playlist'),
    fn: this._deletePlaylist.bind(this)
  });
};

DeletePlaylist.prototype.setAction = function (fn) {
  this._customRemove = fn;
};

DeletePlaylist.prototype._deletePlaylist = function () {
  this._contextMenu.hide();
  this._customRemove(this._uri.toString());
};

/**
 * Export public interface
 */
module.exports = DeletePlaylist;

},{"../../../../i18n":11,"./base":34,"spotify-inheritance/inherit":706,"spotify-liburi":707}],41:[function(require,module,exports){
'use strict';

var inherit = require('spotify-inheritance/inherit');
var BaseAction = require('./base');

var _ = require('../../../../i18n').get;
var liburi = require('spotify-liburi');

var EditPlaylist = function EditPlaylist() {
  BaseAction.apply(this, arguments);
};
inherit(EditPlaylist, BaseAction);

EditPlaylist.prototype.buildItem = function (uris) {
  if (uris.length > 1) {
    return;
  }

  this._uri = uris[0];

  if (this._uri.type !== liburi.Type.PLAYLIST || this._uri.username !== this._adaptor.getUsername() || !this._adaptor.hasEditPlaylistAction()) {
    return;
  }

  if (!this._customEdit) {
    return;
  }

  if (!this._adaptor.isPlaylistInRootlist(this._uri)) {
    return;
  }

  this._contextMenu.addItem({});

  this._contextMenu.addItem({
    id: 'edit-playlist',
    text: _('contextmenu.edit-playlist'),
    disabled: false,
    fn: this._edit.bind(this)
  });
};

EditPlaylist.prototype.setAction = function (fn) {
  this._customEdit = fn;
};

EditPlaylist.prototype._edit = function () {
  this._contextMenu.hide();
  this._customEdit(this._uri.toString());
};

/**
 * Export public interface
 */
module.exports = EditPlaylist;

},{"../../../../i18n":11,"./base":34,"spotify-inheritance/inherit":706,"spotify-liburi":707}],42:[function(require,module,exports){
'use strict';

var inherit = require('spotify-inheritance/inherit');
var BaseAction = require('./base');

var _ = require('../../../../i18n').get;
var liburi = require('spotify-liburi');

var Follow = function Follow() {
  BaseAction.apply(this, arguments);
};
inherit(Follow, BaseAction);

Follow.prototype.buildItem = function (uris, extra) {
  if (uris.length > 1) {
    return;
  }

  if (uris[0].type !== liburi.Type.PLAYLIST && uris[0].type !== liburi.Type.PROFILE && uris[0].type !== liburi.Type.ARTIST && uris[0].type !== liburi.Type.STATION) {
    return;
  }

  // cluster stations cannot be followed
  if (uris[0].type === liburi.Type.STATION && uris[0].args.length > 2 && uris[0].args[2] === 'cluster') {
    return;
  }

  this._userUri = liburi.profileURI(this._adaptor.getUsername()).toString();
  this._uri = uris[0];

  if (this._uri.username === this._adaptor.getUsername()) {
    return;
  }

  this._context = extra.contexts && extra.contexts[0] ? extra.contexts[0].uri : null;

  this._contextMenu.addItem({
    id: 'follow',
    disabled: true,
    text: _('contextmenu.follow')
  });

  switch (this._uri.type) {
    case liburi.Type.ARTIST:
    case liburi.Type.PROFILE:
      this._fetchArtist();
      break;

    case liburi.Type.PLAYLIST:
      this._fetchPlaylist();
      break;

    case liburi.Type.STATION:
      this._fetchStation();
      break;
    default:
    // noop
  }
};

Follow.prototype.setUnfollowAction = function (fn) {
  this._customUnfollow = fn;
};

Follow.prototype._fetchArtist = function () {
  var self = this;

  this._adaptor.isFollowingArtist(this._uri, function (err, isFollowing) {
    if (err) {
      return;
    }

    self._contextMenu.updateItem('follow', {
      disabled: false,
      text: isFollowing ? _('contextmenu.unfollow') : _('contextmenu.follow'),
      fn: self._followArtist.bind(self, !isFollowing)
    });
  });
};

Follow.prototype._fetchPlaylist = function () {
  var subscribed = this._adaptor.isPlaylistInRootlist(this._uri);

  this._contextMenu.updateItem('follow', {
    disabled: false,
    text: subscribed ? _('contextmenu.unfollow') : _('contextmenu.follow'),
    fn: this._followPlaylist.bind(this, !subscribed)
  });
};

Follow.prototype._fetchStation = function () {
  var self = this;

  this._adaptor.isFollowingStation(this._uri, function (err, isFollowing) {
    if (err) {
      return;
    }

    self._contextMenu.updateItem('follow', {
      disabled: false,
      text: isFollowing ? _('contextmenu.unfollow') : _('contextmenu.follow'),
      fn: self._followStation.bind(self, !isFollowing)
    });
  });
};

Follow.prototype._followArtist = function (follow) {
  var self = this;

  this._adaptor.followArtist(this._uri, follow, function () {
    self._contextMenu.hide();
  });
};

Follow.prototype._followPlaylist = function (follow) {
  var self = this;

  if (!follow && this._context === 'spotify:internal:sidebar' && this._customUnfollow) {
    this._customUnfollow(this._uri.toString());
    this._contextMenu.hide();
    return;
  }

  this._adaptor.followPlaylist(this._uri, follow, function () {
    self._contextMenu.hide();
  });
};

Follow.prototype._followStation = function (follow) {
  var self = this;

  this._adaptor.followStation(this._uri, follow, function () {
    self._contextMenu.hide();
  });
};

/**
 * Export public interface
 */
module.exports = Follow;

},{"../../../../i18n":11,"./base":34,"spotify-inheritance/inherit":706,"spotify-liburi":707}],43:[function(require,module,exports){
'use strict';

var inherit = require('spotify-inheritance/inherit');
var BaseAction = require('./base');

var _ = require('../../../../i18n').get;
var liburi = require('spotify-liburi');
var live = require('../../../../../../libs/spotify-live');

var GoTo = function GoTo() {
  BaseAction.apply(this, arguments);
};
inherit(GoTo, BaseAction);

GoTo.prototype.buildItem = function (uris, extra) {
  if (uris.length > 1) {
    return;
  }

  if (uris[0].type !== liburi.Type.TRACK && uris[0].type !== liburi.Type.LOCAL && uris[0].type !== liburi.Type.ALBUM && uris[0].type !== liburi.Type.STATION) {
    return;
  }

  var shouldShowAlbum = true;
  var shouldShowArtist = true;

  if (uris[0].type === liburi.Type.ALBUM) {
    shouldShowAlbum = false;
  }

  // Convert station uri to seed uri.  Show contextmenu item for album
  // and artist seeds.
  if (uris[0].type === liburi.Type.STATION) {
    var seedUri = liburi.fromString('spotify:' + uris[0].args.join(':'));
    switch (seedUri.type) {
      case liburi.Type.ALBUM:
        uris = [seedUri];
        shouldShowArtist = false;
        break;
      case liburi.Type.ARTIST:
        uris = [seedUri];
        shouldShowAlbum = false;
        break;
      default:
        return;
    }
  }

  // There is no easy way to determine the exact URI from where the contextmenu
  // has been opened, so we don't show the option when we are in any album page
  // or artist page (looks like no tracks from other albums are shown in the
  // album page and no tracks from other artists are shown in the artist page).
  if (extra.appURI === 'spotify:app:album') {
    shouldShowAlbum = false;
  }

  if (extra.appURI === 'spotify:app:artist') {
    shouldShowArtist = false;
  }

  // Only show the separator if both options are available
  if (shouldShowAlbum && shouldShowArtist) {
    this._contextMenu.addItem({});
  }

  if (shouldShowArtist) {
    this.buildArtistItem(uris, extra);
  }

  if (shouldShowAlbum) {
    this.buildAlbumItem(uris, extra);
  }
};

GoTo.prototype.buildArtistItem = function (uris, extra) {
  var self = this;

  this._contextMenu.addItem({
    id: 'goto-artist',
    text: _('contextmenu.goto-artist'),
    disabled: true
  });

  // Enable contextmenu item if station app
  if (extra && extra.appURI && extra.appURI === 'spotify:app:station') {
    this._contextMenu.updateItem('goto-artist', {
      disabled: false,
      fn: self._open.bind(self, uris[0].toString())
    });
    return;
  }

  live(uris[0].toString()).query('artists(uri)', function (err, data) {
    if (err) {
      return;
    }

    var artistUri = data.artists[0] && data.artists[0].uri;

    // Only enable the contextmenu option if the artist is correct (no local)
    if (artistUri && liburi.from(artistUri).type === liburi.Type.ARTIST) {
      self._contextMenu.updateItem('goto-artist', {
        disabled: false,
        fn: self._open.bind(self, artistUri)
      });
    }
  }, live.ASAP);
};

GoTo.prototype.buildAlbumItem = function (uris, extra) {
  var self = this;

  this._contextMenu.addItem({
    id: 'goto-album',
    text: _('contextmenu.goto-album'),
    disabled: true
  });

  // Enable contextmenu item if station app
  if (extra && extra.appURI && extra.appURI === 'spotify:app:station') {
    this._contextMenu.updateItem('goto-album', {
      disabled: false,
      fn: self._open.bind(self, uris[0].toString())
    });
    return;
  }

  live(uris[0].toString()).query('album(uri)', function (err, data) {
    if (err) {
      return;
    }

    var albumUri = data.album && data.album.uri;

    // Only enable the contextmenu option if the album is correct (no local)
    if (albumUri && liburi.from(albumUri).type === liburi.Type.ALBUM) {
      self._contextMenu.updateItem('goto-album', {
        disabled: false,
        fn: self._open.bind(self, albumUri)
      });
    }
  }, live.ASAP);
};

GoTo.prototype._open = function (uri) {
  this._adaptor.openApp(uri);
  this._contextMenu.hide();
};

/**
 * Export public interface
 */
module.exports = GoTo;

},{"../../../../../../libs/spotify-live":439,"../../../../i18n":11,"./base":34,"spotify-inheritance/inherit":706,"spotify-liburi":707}],44:[function(require,module,exports){
'use strict';

var AddToPlaylist = require('./add-to-playlist');
var Radio = require('./radio');
var Follow = require('./follow');
var Publish = require('./publish');
var Queue = require('./queue');
var RemoveFromPlaylist = require('./remove-from-playlist');
var Share = require('./share');
var RenameFolder = require('./rename-folder');
var RenamePlaylist = require('./rename-playlist');
var EditPlaylist = require('./edit-playlist');
var ReportPlaylist = require('./report-playlist');
var RefreshPlaylist = require('./refresh-playlist');
var ReportAsset = require('./report-asset');
var Collection = require('./collection');
var Clipboard = require('./clipboard');
var Collaborative = require('./collaborative');
var DeletePlaylist = require('./delete-playlist');
var RemoveFromQueue = require('./remove-from-queue');
var CreatePlaylist = require('./create-playlist');
var CreateFolder = require('./create-folder');
var OpenLocalfileFolder = require('./open-localfile-folder');
var Offline = require('./offline');
var GoTo = require('./goto');
var abba = require('../../../../../../libs/spotify-abba-mini');
var bridge = require('../../../../../../libs/spotify-bridge-request');

/**
 * Export public interface
 */
module.exports = function (adaptor, contextmenu) {
  return {
    radio: new Radio(adaptor, contextmenu, abba),
    addToPlaylist: new AddToPlaylist(adaptor, contextmenu),
    follow: new Follow(adaptor, contextmenu),
    publish: new Publish(adaptor, contextmenu),
    queue: new Queue(adaptor, contextmenu),
    removeFromPlaylist: new RemoveFromPlaylist(adaptor, contextmenu),
    share: new Share(adaptor, contextmenu),
    renameFolder: new RenameFolder(adaptor, contextmenu),
    renamePlaylist: new RenamePlaylist(adaptor, contextmenu),
    editPlaylist: new EditPlaylist(adaptor, contextmenu),
    reportPlaylist: new ReportPlaylist(adaptor, contextmenu),
    refreshPlaylist: new RefreshPlaylist(adaptor, contextmenu, abba),
    reportAsset: new ReportAsset(adaptor, contextmenu, abba, bridge),
    collection: new Collection(adaptor, contextmenu),
    clipboard: new Clipboard(adaptor, contextmenu),
    collaborative: new Collaborative(adaptor, contextmenu),
    deletePlaylist: new DeletePlaylist(adaptor, contextmenu),
    removeFromQueue: new RemoveFromQueue(adaptor, contextmenu),
    createFolder: new CreateFolder(adaptor, contextmenu),
    createPlaylist: new CreatePlaylist(adaptor, contextmenu),
    openLocalFileFolder: new OpenLocalfileFolder(adaptor, contextmenu),
    offline: new Offline(adaptor, contextmenu),
    goto: new GoTo(adaptor, contextmenu)
  };
};

},{"../../../../../../libs/spotify-abba-mini":181,"../../../../../../libs/spotify-bridge-request":253,"./add-to-playlist":33,"./clipboard":35,"./collaborative":36,"./collection":37,"./create-folder":38,"./create-playlist":39,"./delete-playlist":40,"./edit-playlist":41,"./follow":42,"./goto":43,"./offline":45,"./open-localfile-folder":46,"./publish":47,"./queue":48,"./radio":49,"./refresh-playlist":50,"./remove-from-playlist":51,"./remove-from-queue":52,"./rename-folder":53,"./rename-playlist":54,"./report-asset":55,"./report-playlist":56,"./share":57}],45:[function(require,module,exports){
'use strict';

var inherit = require('spotify-inheritance/inherit');
var BaseAction = require('./base');

var _ = require('../../../../i18n').get;
var liburi = require('spotify-liburi');

var Offline = function Offline() {
  BaseAction.apply(this, arguments);
};
inherit(Offline, BaseAction);

Offline.prototype.buildItem = function (uris) {
  if (uris.length > 1 || uris[0].type !== liburi.Type.PLAYLIST) {
    return;
  }

  this._uri = uris[0];

  if (!this._adaptor.isPlaylistInRootlist(this._uri)) {
    return;
  }

  this._contextMenu.addItem({
    id: 'offline',
    text: _('contextmenu.offline'),
    value: false,
    disabled: true
  });

  this._fetch();
};

Offline.prototype.setAction = function (fn) {
  this._customAction = fn;
};

Offline.prototype._fetch = function () {
  var self = this;

  this._adaptor.isPlaylistOffline(this._uri, function (err, isOffline) {
    if (!err) {
      self._contextMenu.updateItem('offline', {
        disabled: false,
        value: isOffline,
        fn: self._toggleOfflineOrUpsell.bind(self, !isOffline)
      });
    }
  });
};

Offline.prototype._toggleOfflineOrUpsell = function (offline) {
  var self = this;

  this._adaptor.canOfflineSync(function (err, value) {
    if (err || !value) {
      return self._adaptor.sendUserMessage('cant-offline-playlists');
    }

    if (self._customAction) {
      self._customAction(self._uri.toString(), offline);
      return self._contextMenu.hide();
    }

    self._adaptor.offlineSync(self._uri, offline, function (err) {
      if (!err) {
        self._contextMenu.hide();
      }
    });
  });
  this._contextMenu.hide();
};

/**
 * Export public interface
 */
module.exports = Offline;

},{"../../../../i18n":11,"./base":34,"spotify-inheritance/inherit":706,"spotify-liburi":707}],46:[function(require,module,exports){
'use strict';

var inherit = require('spotify-inheritance/inherit');
var BaseAction = require('./base');

var _ = require('../../../../i18n').get;
var liburi = require('spotify-liburi');

var OpenLocalfileFolder = function OpenLocalfileFolder() {
  BaseAction.apply(this, arguments);
};
inherit(OpenLocalfileFolder, BaseAction);

OpenLocalfileFolder.prototype.buildItem = function (uris) {
  if (uris.length > 1 || uris[0].type !== liburi.Type.LOCAL) {
    return;
  }

  if (!this._adaptor.canHaveLocalFiles()) {
    return;
  }

  this._uri = uris[0];

  var text = 'open-localfile-folder';

  if (this._adaptor.isOSX()) {
    text += '-mac';
  }

  this._contextMenu.addItem({
    id: 'open-localfile-folder',
    text: _('contextmenu.' + text),
    disabled: false,
    fn: this._open.bind(this)
  });

  this._fetch();
};

OpenLocalfileFolder.prototype._fetch = function () {
  var self = this;

  this._adaptor.canOpenLocalFile(this._uri, function (err, value) {
    self._contextMenu.updateItem('open-localfile-folder', {
      disabled: err || !value
    });
  });
};

OpenLocalfileFolder.prototype._open = function () {
  var self = this;

  this._adaptor.openLocalFile(this._uri, function (err) {
    if (err) {
      self._contextMenu.hide();
    }
  });
};

/**
 * Export public interface
 */
module.exports = OpenLocalfileFolder;

},{"../../../../i18n":11,"./base":34,"spotify-inheritance/inherit":706,"spotify-liburi":707}],47:[function(require,module,exports){
'use strict';

var inherit = require('spotify-inheritance/inherit');
var BaseAction = require('./base');

var _ = require('../../../../i18n').get;
var liburi = require('spotify-liburi');

var Publish = function Publish() {
  BaseAction.apply(this, arguments);
};
inherit(Publish, BaseAction);

Publish.prototype.buildItem = function (uris) {
  if (uris.length > 1 || uris[0].type !== liburi.Type.PLAYLIST) {
    return;
  }
  this._uri = uris[0];

  var subscribed = this._adaptor.isPlaylistInRootlist(this._uri);

  if (!subscribed) {
    return;
  }

  this._contextMenu.addItem({
    id: 'publish',
    disabled: true,
    text: _('contextmenu.publish')
  });

  this._fetch();
};

Publish.prototype._fetch = function () {
  var self = this;

  this._adaptor.getCollaborativeStatus(this._uri, function (err, data) {
    if (err) {
      return self._contextMenu.removeItem('publish');
    }

    if (data.collaborative) {
      self._contextMenu.updateItem('publish', { disabled: true });
    } else {
      self._contextMenu.updateItem('publish', {
        disabled: false,
        text: _('contextmenu.' + (data.published ? 'unpublish' : 'publish')),
        fn: self._publish.bind(self, !data.published)
      });
    }
  });
};

Publish.prototype._publish = function (publish) {
  var self = this;

  this._adaptor.setPlaylistPublished(this._uri, publish, function (err) {
    if (!err) {
      self._contextMenu.hide();
    }
  });
};

/**
 * Export public interface
 */
module.exports = Publish;

},{"../../../../i18n":11,"./base":34,"spotify-inheritance/inherit":706,"spotify-liburi":707}],48:[function(require,module,exports){
'use strict';

var inherit = require('spotify-inheritance/inherit');
var BaseAction = require('./base');

var _ = require('../../../../i18n').get;
var liburi = require('spotify-liburi');

var Queue = function Queue() {
  BaseAction.apply(this, arguments);
};
inherit(Queue, BaseAction);

Queue.prototype.buildItem = function (uris) {
  this._uris = uris;

  if (uris[0].type !== liburi.Type.LOCAL && uris[0].type !== liburi.Type.TRACK && uris[0].type !== liburi.Type.ALBUM) {
    return;
  }

  this._contextMenu.addItem({
    id: 'queue',
    text: _('contextmenu.add-to-queue'),
    disabled: false,
    fn: this._queue.bind(this)
  });

  if (uris[0].type === liburi.Type.TRACK || uris[0].type === liburi.Type.LOCAL) {
    this._checkTracksAvailability(uris);
  }

  if (uris[0].type === liburi.Type.ALBUM) {
    this.disableIfClientOffline('queue');
  }
};

Queue.prototype._checkTracksAvailability = function (uris) {
  var self = this;

  this._adaptor.isAnyTrackPlayable(uris, function (err, value) {
    if (!err && !value) {
      self._contextMenu.updateItem('queue', {
        disabled: true
      });
    }
  });
};

Queue.prototype._queue = function () {
  var self = this;

  if (this._uris[0].type === liburi.Type.ALBUM) {
    this._adaptor.getAlbumTracks(this._uris[0], function (err, tracks) {
      if (!err) {
        self._adaptor.queueTracks(tracks, function () {
          self._contextMenu.hide();
        });
      }
    });
  } else {
    this._adaptor.queueTracks(this._uris, function () {
      self._contextMenu.hide();
    });
  }
};

/**
 * Export public interface
 */
module.exports = Queue;

},{"../../../../i18n":11,"./base":34,"spotify-inheritance/inherit":706,"spotify-liburi":707}],49:[function(require,module,exports){
'use strict';

var inherit = require('spotify-inheritance/inherit');
var BaseAction = require('./base');

var _ = require('../../../../i18n').get;
var liburi = require('spotify-liburi');

var Radio = function Radio() {
  BaseAction.apply(this, arguments);

  // ABBA requests don't really hang or error,
  // so don't turn 'buildItem' into an async method
  // and just use the default value if this abba call hasn't returned.
  this.hideRadioEnabled = false;
  this._abba('new-markets-hide-radio', function (err, cell) {
    if (err || cell !== 'Enabled') return;
    this.hideRadioEnabled = true;
  }.bind(this));
};
inherit(Radio, BaseAction);

Radio.prototype.buildItem = function (uris) {
  var self = this;

  if (this.hideRadioEnabled) {
    return;
  }

  if (uris.length > 1 || uris[0].type === liburi.Type.LOCAL || uris[0].type === liburi.Type.PROFILE || uris[0].type === liburi.Type.FOLDER || uris[0].type === liburi.Type.STATION) {
    return;
  }

  var label;
  switch (uris[0].type) {
    case liburi.Type.ALBUM:
      label = _('contextmenu.station-album');
      break;
    case liburi.Type.ARTIST:
      label = _('contextmenu.station-artist');
      break;
    case liburi.Type.PLAYLIST:
      label = _('contextmenu.station-playlist');
      break;
    case liburi.Type.TRACK:
      label = _('contextmenu.station-track');
      break;
    default:
      label = _('contextmenu.station');
      break;
  }

  var uri = uris[0].toString().replace('spotify:', 'spotify:station:');

  this._contextMenu.addItem({
    id: 'radio',
    text: label,
    disabled: false,
    fn: this._openRadio.bind(this, uri)
  });

  // if the track is not playable, disable radio
  if (uris[0].type === liburi.Type.TRACK) {
    this._adaptor.isAnyTrackPlayable([uris[0]], function (err, value) {
      if (!err && !value) {
        self._contextMenu.updateItem('radio', {
          disabled: true
        });
      }
    });
  }

  this.disableIfClientOffline('radio');

  this._adaptor.getFormatListType(uris[0], function (error, data) {
    if (data.formatListType === 'chart') {
      this._contextMenu.updateItem(['radio'], {
        text: _('contextmenu.station-chart')
      });
    }
  }.bind(this));
};

Radio.prototype._openRadio = function (uri) {
  this._adaptor.openApp(uri);
  this._contextMenu.hide();
};

/**
 * Export public interface
 */
module.exports = Radio;

},{"../../../../i18n":11,"./base":34,"spotify-inheritance/inherit":706,"spotify-liburi":707}],50:[function(require,module,exports){
'use strict';

var inherit = require('spotify-inheritance/inherit');
var BaseAction = require('./base');

var liburi = require('spotify-liburi');

var RefreshPlaylist = function RefreshPlaylist() {
  BaseAction.apply(this, arguments);

  // Disable the context menu item used to create refreshed playlist while we're
  // experimenting with the big button in the header.
  this.showRefreshPlaylist = false;
};
inherit(RefreshPlaylist, BaseAction);

RefreshPlaylist.prototype.buildItem = function (uris) {
  var uri = uris[0];
  if (uri.type !== liburi.Type.PLAYLIST || !this.showRefreshPlaylist) {
    return;
  }

  this._contextMenu.addItem({
    id: 'refresh-playlist',
    // TODO(jaco): Should be localised, but since the name is still very much up
    // in the air and this will only go out to employees, we don't want to send
    // it off for translation yet since it will likely change a couple of times
    // before we're happy with it.
    text: 'Create Similar Playlist',
    disabled: false,
    fn: this._refreshPlaylist.bind(this, uri)
  });

  this.disableIfClientOffline('refresh-playlist');
};

RefreshPlaylist.prototype._refreshPlaylist = function (playlistUri) {
  var self = this;
  self._adaptor.createRefreshedPlaylist(playlistUri, function (error, newPlaylistUri) {
    if (error) {
      console.error(error);
    } else if (newPlaylistUri) {
      self._adaptor.openApp(newPlaylistUri);
    }
    self._contextMenu.hide();
  });
};

/**
 * Export public interface
 */
module.exports = RefreshPlaylist;

},{"./base":34,"spotify-inheritance/inherit":706,"spotify-liburi":707}],51:[function(require,module,exports){
'use strict';

var inherit = require('spotify-inheritance/inherit');
var BaseAction = require('./base');

var _ = require('../../../../i18n').get;
var liburi = require('spotify-liburi');

var RemoveFromPlaylist = function RemoveFromPlaylist() {
  BaseAction.apply(this, arguments);
};
inherit(RemoveFromPlaylist, BaseAction);

RemoveFromPlaylist.prototype.buildItem = function (uris, extra) {
  this._uris = uris;

  if (this._uris[0].type !== liburi.Type.TRACK && this._uris[0].type !== liburi.Type.LOCAL) {
    return;
  }

  // disable action when selecting none or multiple contexts
  if (!extra.contexts || extra.contexts.length !== 1) {
    return;
  }

  // disable action when selecting multiple tracks with the old calls
  if (this._uris.length > 1 && !extra.contexts[0].indices) {
    return;
  }

  var context = extra.contexts[0].origin || extra.contexts[0];
  if (!context.uri) {
    return;
  }

  this._indices = context.indices || [context.primaryIndex];
  this._rowIds = context.keys;
  this._context = liburi.from(context.uri);

  // disable action when not in a playlist context
  if (this._context.type !== liburi.Type.PLAYLIST) {
    return;
  }

  // Make a guess based on if it's my own playlist.
  // Wrong when it's not mine but collaborative.
  var isOwnPlaylist = this._adaptor.getUsername() === this._context.username;

  this._contextMenu.addItem({
    id: 'remove-from-playlist',
    text: _('contextmenu.remove-from-playlist'),
    disabled: !isOwnPlaylist,
    fn: this._remove.bind(this)
  });

  this._fetch();

  this._adaptor.getFormatListType(this._context, function (error, data) {
    if (error) return;
    if (data.formatListType === 'chart') {
      this._contextMenu.removeItem(['remove-from-playlist']);
    }
  }.bind(this));
};

RemoveFromPlaylist.prototype._fetch = function () {
  var self = this;

  this._adaptor.canRemoveTracks(this._context, function (err, canRemove) {
    self._contextMenu.updateItem('remove-from-playlist', {
      disabled: !err && !canRemove
    });
  });
};

RemoveFromPlaylist.prototype._remove = function () {
  var self = this;

  this._adaptor.removeTracksFromPlaylist(this._context, this._rowIds, this._indices, function (err) {
    if (!err) {
      self._contextMenu.hide();
    }
  });
};

/**
 * Export public interface
 */
module.exports = RemoveFromPlaylist;

},{"../../../../i18n":11,"./base":34,"spotify-inheritance/inherit":706,"spotify-liburi":707}],52:[function(require,module,exports){
'use strict';

var inherit = require('spotify-inheritance/inherit');
var BaseAction = require('./base');

var _ = require('../../../../i18n').get;
var liburi = require('spotify-liburi');

var Queue = function Queue() {
  BaseAction.apply(this, arguments);
};
inherit(Queue, BaseAction);

Queue.prototype.buildItem = function (uris, extra) {
  this._uris = uris;

  if (this._uris[0].type !== liburi.Type.TRACK && this._uris[0].type !== liburi.Type.LOCAL) {
    return;
  }

  if (!extra.contexts || extra.contexts.length !== 1) {
    // disable action when selecting none or multiple contexts
    return;
  }

  if (this._uris.length > 1 && !extra.contexts[0].indices) {
    // disable action when selecting multiple tracks with the old calls
    return;
  }

  var context = extra.contexts[0].origin || extra.contexts[0];

  if (context.uri !== 'spotify:internal:queue') {
    return;
  }

  this._indices = context.indices || [context.primaryIndex];

  this._contextMenu.addItem({
    id: 'remove-from-queue',
    text: _('contextmenu.remove-from-queue'),
    fn: this._unqueue.bind(this)
  });
};

Queue.prototype._unqueue = function () {
  var self = this;

  this._adaptor.removeTracksFromQueue(this._indices, function () {
    self._contextMenu.hide();
  });
};

/**
 * Export public interface
 */
module.exports = Queue;

},{"../../../../i18n":11,"./base":34,"spotify-inheritance/inherit":706,"spotify-liburi":707}],53:[function(require,module,exports){
'use strict';

var inherit = require('spotify-inheritance/inherit');
var BaseAction = require('./base');

var _ = require('../../../../i18n').get;
var liburi = require('spotify-liburi');

var RenameFolder = function RenameFolder() {
  BaseAction.apply(this, arguments);
};
inherit(RenameFolder, BaseAction);

RenameFolder.prototype.buildItem = function (uris) {
  if (uris.length > 1) {
    return;
  }

  this._uri = uris[0];

  if (this._uri.type !== liburi.Type.FOLDER || !this._customRename) {
    return;
  }

  this._contextMenu.addItem({});

  this._contextMenu.addItem({
    id: 'rename-folder',
    text: _('contextmenu.rename-folder'),
    disabled: false,
    fn: this._rename.bind(this)
  });
};

RenameFolder.prototype.setAction = function (fn) {
  this._customRename = fn;
};

RenameFolder.prototype._rename = function () {
  this._customRename(this._uri.toString());
  this._contextMenu.hide();
};

/**
 * Export public interface
 */
module.exports = RenameFolder;

},{"../../../../i18n":11,"./base":34,"spotify-inheritance/inherit":706,"spotify-liburi":707}],54:[function(require,module,exports){
'use strict';

var inherit = require('spotify-inheritance/inherit');
var BaseAction = require('./base');

var _ = require('../../../../i18n').get;
var liburi = require('spotify-liburi');

var RenamePlaylist = function RenamePlaylist() {
  BaseAction.apply(this, arguments);
};
inherit(RenamePlaylist, BaseAction);

RenamePlaylist.prototype.buildItem = function (uris) {
  if (uris.length > 1) {
    return;
  }

  this._uri = uris[0];

  if (this._uri.type !== liburi.Type.PLAYLIST || this._uri.username !== this._adaptor.getUsername() || !this._adaptor.hasRenamePlaylistAction()) {
    return;
  }

  if (!this._customRename) {
    return;
  }

  if (!this._adaptor.isPlaylistInRootlist(this._uri)) {
    return;
  }

  this._contextMenu.addItem({});

  this._contextMenu.addItem({
    id: 'rename-playlist',
    text: _('contextmenu.rename-playlist'),
    disabled: false,
    fn: this._rename.bind(this)
  });
};

RenamePlaylist.prototype.setAction = function (fn) {
  this._customRename = fn;
};

RenamePlaylist.prototype._rename = function () {
  this._customRename(this._uri.toString());
  this._contextMenu.hide();
};

/**
 * Export public interface
 */
module.exports = RenamePlaylist;

},{"../../../../i18n":11,"./base":34,"spotify-inheritance/inherit":706,"spotify-liburi":707}],55:[function(require,module,exports){
'use strict';

var inherit = require('spotify-inheritance/inherit');
var BaseAction = require('./base');

var _ = require('../../../../i18n').get;
var liburi = require('spotify-liburi');

var ReportAsset = function ReportAsset() {
  BaseAction.apply(this, arguments);
};
inherit(ReportAsset, BaseAction);

ReportAsset.prototype.buildItem = function (uris) {
  var self = this;

  // This option is hidden behind a feature flag
  if (!this._adaptor.canUserReport()) {
    return;
  }

  // We don't support reporting multiple items
  if (uris.length !== 1) {
    return;
  }

  this._uri = uris[0];

  // If does not make sense to report own assets
  if (this._uri.username === this._adaptor.getUsername()) {
    return;
  }

  if (this._uri.type === liburi.Type.ARTIST) {
    this._contextMenu.addItem({
      id: 'report-asset',
      text: _('contextmenu.report-asset'),
      disabled: false,
      fn: this._report.bind(this)
    });
    return;
  }
  if (this._uri.type === liburi.Type.PROFILE) {
    // Not all user profiles can be reported, so
    // we first add a disabled context menu item
    // and enable it if backend says reporting is enabled.
    this._contextMenu.addItem({
      id: 'report-asset',
      text: _('contextmenu.report-asset'),
      disabled: true,
      fn: this._report.bind(this)
    });

    this._bridge.cosmosJSON({
      method: 'GET',
      uri: 'hm://user-profile-view/v2/desktop/profile/' + encodeURIComponent(this._uri.username) + '/volatile'
    }, function (error, result) {
      if (!error && result.report_abuse_enabled) {
        self._contextMenu.updateItem('report-asset', {
          disabled: false
        });
      }
    });
  }
};

ReportAsset.prototype._report = function () {
  var self = this;

  this._adaptor.getAbuseReportUrl(this._uri, function (error, url) {
    if (error) {
      return self._contextMenu.hide();
    }

    window.open(url);
    self._contextMenu.hide();
  });
};

/**
 * Export public interface
 */
module.exports = ReportAsset;

},{"../../../../i18n":11,"./base":34,"spotify-inheritance/inherit":706,"spotify-liburi":707}],56:[function(require,module,exports){
'use strict';

var inherit = require('spotify-inheritance/inherit');
var BaseAction = require('./base');

var _ = require('../../../../i18n').get;
var liburi = require('spotify-liburi');

var ReportPlaylist = function ReportPlaylist() {
  BaseAction.apply(this, arguments);
};
inherit(ReportPlaylist, BaseAction);

ReportPlaylist.prototype.buildItem = function (uris) {
  // This option is hidden behind a feature flag
  if (!this._adaptor.canUserReport()) {
    return;
  }

  if (uris.length !== 1) {
    return;
  }

  this._uri = uris[0];

  if (this._uri.type !== liburi.Type.PLAYLIST) {
    return;
  }

  if (this._uri.username === this._adaptor.getUsername()) {
    return;
  }

  this._contextMenu.addItem({
    id: 'report-playlist',
    text: _('contextmenu.report-playlist'),
    disabled: true,
    fn: this._report.bind(this)
  });

  var self = this;

  this._adaptor.isPlaylistAbuseReportingEnabled(this._uri, function (err, enabled) {
    if (err) {
      console.error(err);
      enabled = false;
    }

    if (enabled) {
      self._contextMenu.updateItem('report-playlist', {
        disabled: false
      });
    }
  });

  this._adaptor.getFormatListType(this._uri, function (error, data) {
    if (error) return;
    if (data.formatListType === 'chart') {
      this._contextMenu.removeItem(['report-playlist']);
    }
  }.bind(this));
};

ReportPlaylist.prototype._report = function () {
  var self = this;

  this._adaptor.getAbuseReportUrl(this._uri, function (error, url) {
    if (error) {
      return self._contextMenu.hide();
    }

    window.open(url);
    self._contextMenu.hide();
  });
};

/**
 * Export public interface
 */
module.exports = ReportPlaylist;

},{"../../../../i18n":11,"./base":34,"spotify-inheritance/inherit":706,"spotify-liburi":707}],57:[function(require,module,exports){
'use strict';

var inherit = require('spotify-inheritance/inherit');
var BaseAction = require('./base');

var _ = require('../../../../i18n').get;
var liburi = require('spotify-liburi');

var Share = function Share() {
  BaseAction.apply(this, arguments);
};
inherit(Share, BaseAction);

Share.prototype.buildItem = function (uris) {
  if (uris.length > 1 || uris[0].type === liburi.Type.FOLDER || uris[0].type === liburi.Type.LOCAL || uris[0].type === liburi.Type.PROFILE || uris[0].type === liburi.Type.STATION) {
    return;
  }

  var uri = 'spotify:app:share:' + encodeURIComponent(uris[0]);

  this._contextMenu.addItem({
    id: 'share',
    text: _('contextmenu.share'),
    fn: this._openShare.bind(this, uri)
  });

  // if the client is offline, disable share
  this.disableIfClientOffline('share');
};

Share.prototype._openShare = function (uri) {
  this._adaptor.openApp(uri);
  this._contextMenu.hide();
};

Share.prototype._shareLyrics = function () {
  if (this._shareLyricsAction && this._track) {
    this._shareLyricsAction(this._track.toString());
  }
  this._contextMenu.hide();
};

/**
 * Export public interface
 */
module.exports = Share;

},{"../../../../i18n":11,"./base":34,"spotify-inheritance/inherit":706,"spotify-liburi":707}],58:[function(require,module,exports){
'use strict';

var live = require('../../../../../libs/spotify-live');
var liburi = require('spotify-liburi');
var logger = require('../../logging/client-event-logger');
var UIInteraction4 = require('../../../../../libs/spotify-logger/messages/UIInteraction4');
var getPlaylistNameFor = require('../../../../../libs/spotify-live-get-playlist-name-for-items');
var queueModel = require('../../models/queue');
var playlistAnnotateTest = require('../../../../../libs/spotify-playlist-annotate-test');
var PlaylistActions = require('../../../../../libs/spotify-playlist-actions').PlaylistActions;
var session = require('../../models/session.js');
var Event = require('../../event');
var eventDispatcher = require('../../../../../libs/spotify-event-dispatcher');

var URL_BASE;

if (typeof __spotify !== 'undefined') {
  URL_BASE = window.__spotify.product_state['ugc-abuse-report-url'];
} else {
  URL_BASE = null;
}

var Adaptor = function Adaptor(bridge, cosmos) {
  this._bridge = bridge;
  this._cosmos = cosmos;
  this._userPlaylists = [];
  this._currentCbsCounter = 0;
  this._playlistActions = new PlaylistActions(live, bridge, cosmos);
};

Adaptor.prototype._cb = function (cb) {
  var self = this;

  var cbCounter = this._currentCbsCounter;

  return function () {
    // if the callback was defined before discardPendingRequests() has been
    // called, do not call it
    if (!cb || cbCounter !== self._currentCbsCounter) {
      return;
    }

    cb.apply(null, arguments);
  };
};

Adaptor.prototype.discardPendingRequests = function () {
  this._currentCbsCounter++;
};

Adaptor.prototype.logUserHit = function (data) {
  logger.log({
    event: 'user:hit',
    context: data.context,
    event_version: data.event_version,
    json_data: data
  });
};

Adaptor.prototype.setUserPlaylists = function (playlists) {
  this._userPlaylists = playlists;
};

Adaptor.prototype.getUserPlaylists = function () {
  return this._userPlaylists;
};

Adaptor.prototype.getUsername = function () {
  return window.__spotify.username;
};

Adaptor.prototype.saveToClipboard = function (text, cb) {
  var request = new this._cosmos.Request('PUT', 'sp://desktop/v1/clipboard', {}, text);
  this._cosmos.resolver.resolve(request, this._cb(cb));
};

Adaptor.prototype.isUserEmployee = function () {
  return window.__spotify && window.__spotify.product_state && window.__spotify.product_state.employee === '1';
};

Adaptor.prototype.getCollaborativeStatus = function (uri, cb) {
  this._playlistActions.getCollaborativeStatus(uri, this._cb(cb));
};

Adaptor.prototype.getPlaylistMetadata = function (uri, cb) {
  cb = this._cb(cb);

  var query = 'uri, name, allows(insertTracks), ' + 'owner(name, username, currentUser)';

  // Query data synchronously to make it faster, but still do it in the next
  // tick to not block the rendering of the context menu.
  setTimeout(function () {
    var data = live(uri.toString()).query(query);
    cb(null, data);
  }, 0);
};

Adaptor.prototype.getFormatListType = function (uri, cb) {
  cb = this._cb(cb);

  var query = 'formatListType';

  live(uri.toString()).query(query, function (err, data) {
    cb(err, data);
  });
};

Adaptor.prototype.setPlaylistCollaborative = function (uri, collaborative, cb) {
  cb = this._cb(cb);
  this._playlistActions.setPlaylistCollaborative(uri, collaborative, cb);
};

Adaptor.prototype.setPlaylistPublished = function (uri, publish, cb) {
  this._playlistActions.setPlaylistPublished(uri, publish, this._cb(cb));
};

Adaptor.prototype.areAllItemsInCollection = function (uris, cb) {
  var i = 0;
  cb = this._cb(cb);

  var checkItem = function checkItem(err, isInCollection) {
    if (err) {
      return cb(err);
    }
    if (!isInCollection) {
      return cb(null, false);
    }

    i++;
    if (i < uris.length) {
      live(uris[i].toString()).get('added', checkItem);
    } else {
      cb(null, true);
    }
  };

  live(uris[i].toString()).get('added', checkItem, live.ASAP);
};

Adaptor.prototype.saveItemsToCollection = function (uris, cb) {
  var triedSavingLocalTrack = false;
  cb = this._cb(cb);

  uris.forEach(function (uri) {
    if (uri.type === liburi.Type.LOCAL) {
      triedSavingLocalTrack = true;
    } else {
      live(uri.toString()).publish({
        added: true
      });
    }
  });

  if (triedSavingLocalTrack) {
    this._cosmos.resolver.post({
      url: 'sp://messages/v1/container/user-message',
      body: { id: 'some-local-tracks-not-saved' }
    });
  }
  cb();
};

Adaptor.prototype.removeItemsFromCollection = function (uris, cb) {
  cb = this._cb(cb);

  uris.forEach(function (uri) {
    live(uri.toString()).publish({
      added: false
    });
  });
  cb();
};

Adaptor.prototype.isFollowingArtist = function (uri, cb) {
  var userUri = liburi.profileURI(this.getUsername()).toString();
  cb = this._cb(cb);

  // Social graph v2 expects decoded uris (i.e. spotify:user:someone!
  // rather than spotify:user:someone%21). `this.getUsername()` returns a
  // uri-encoded user name.
  var request = {
    url: 'hm://socialgraph/v2/is_following?format=json',
    body: {
      source_uri: decodeURIComponent(userUri),
      target_uris: [decodeURIComponent(uri.toString())]
    }
  };
  this._cosmos.resolver.get(request, function (error, resp) {
    if (error) {
      return cb(error);
    }

    var isFollowing = JSON.parse(resp.getBody())[0].is_following;
    cb(null, isFollowing);
  });
};

Adaptor.prototype.isPlaylistInRootlist = function (uri) {
  uri = uri.toString();

  for (var i = 0; i < this._userPlaylists.length; i++) {
    if (this._userPlaylists[i].uri === uri) {
      return true;
    }
  }
  return false;
};

Adaptor.prototype.isFollowingStation = function (uri, cb) {
  cb = this._cb(cb);

  var query = 'name, added';

  live(uri.toString()).query(query, function (err, data) {
    cb(err, data.added);
  }, live.ASAP);
};

Adaptor.prototype.followPlaylist = function (uri, follow, cb) {
  var self = this;
  cb = this._cb(cb);

  if (follow) {
    this._cosmos.resolver.post({
      url: 'sp://core-playlist/v1/rootlist',
      body: {
        operation: 'add',
        uris: [uri.toString()],
        before: 'start'
      }
    }, function (error) {
      if (!error) {
        self._broadcastFollow(uri.toString(), follow);
      }
      cb(error);
    });
  } else {
    // Removing using Core needs the `rowId`, which we don't necessarily have,
    // so stick with old bridge message for now. It's only adding that needs to
    // be done using Core to fix KM-8804.
    this._bridge('library_unsubscribe', ['spotify:user:@', uri.toString()], function (error) {
      if (!error) {
        self._broadcastFollow(uri.toString(), follow);
      }
      cb(error);
    });
  }
};

Adaptor.prototype.followArtist = function (uri, follow, cb) {
  var self = this;
  cb = this._cb(cb);

  var data = {
    'source_uri': liburi.profileURI(this.getUsername()).toString(),
    'target_uris': [decodeURIComponent(uri.toString())]
  };

  var request = new this._cosmos.Request(follow ? 'POST' : 'DELETE', 'hm://socialgraph/v2/following?format=json', null, data);
  this._cosmos.resolver.resolve(request, function (err) {
    if (!err) {
      self._broadcastFollow(uri.toString(), follow);
    }
    cb(err);
  });
};

Adaptor.prototype.followStation = function (uri, follow, cb) {
  cb = this._cb(cb);

  var data = {
    added: follow
  };

  live(uri.toString()).publish(data);
  cb();
};

Adaptor.prototype._broadcastFollow = function (uri, isFollowing) {
  var request = {
    url: 'sp://messages/v1/followstate',
    body: {
      uri: uri.toString(),
      isFollowing: isFollowing
    }
  };
  this._cosmos.resolver.post(request, function () {});
};

Adaptor.prototype.isPlaylistOffline = function (uri, cb) {
  this._playlistActions.isPlaylistOffline(uri, this._cb(cb));
};

Adaptor.prototype.canOfflineSync = function (cb) {
  cb = this._cb(cb);

  live('spotify:client').query('session(capabilities(offlineSync))', function (err, data) {
    if (err) {
      return cb(err);
    }

    cb(null, !!data.session.capabilities.offlineSync);
  }, live.ASAP);
};

Adaptor.prototype.offlineSync = function (uri, offline, cb) {
  var method = offline ? 'offline_enable_sync' : 'offline_disable_sync';

  this._bridge(method, [uri.toString()], this._cb(cb));
};

Adaptor.prototype.sendUserMessage = function (id) {
  this._cosmos.resolver.post({
    url: 'sp://messages/v1/container/user-message',
    body: {
      id: id
    }
  });
};

Adaptor.prototype.canHaveLocalFiles = function () {
  return window.__spotify && window.__spotify.product_state && +window.__spotify.product_state['local-files'] === 1;
};

Adaptor.prototype.isOSX = function () {
  return window.navigator.userAgent.indexOf('Macintosh') > -1;
};

Adaptor.prototype.canOpenLocalFile = function (uri, cb) {
  cb = this._cb(cb);

  var request = new this._cosmos.Request('GET', 'sp://local-files/v1/can_open_track_location', {}, uri.toString());

  this._cosmos.resolver.resolve(request, function (err, response) {
    if (err) {
      return cb(err);
    }
    cb(null, response.getJSONBody().success);
  });
};

Adaptor.prototype.openLocalFile = function (uri, cb) {
  var request = new this._cosmos.Request('POST', 'sp://local-files/v1/open_track_location', {}, uri.toString());
  this._cosmos.resolver.resolve(request, this._cb(cb));
};

Adaptor.prototype.isClientOnline = function (cb) {
  cb = this._cb(cb);

  live('spotify:client').query('session(online)', function (err, data) {
    if (err) {
      return cb(err);
    }
    cb(null, data.session.online);
  }, live.ASAP);
};

Adaptor.prototype.isAnyTrackPlayable = function (uris, cb) {
  var i = 0;
  var self = this;
  cb = this._cb(cb);

  var onResponse = function onResponse(err, resp) {
    if (!err && resp.playable) {
      // we've found a playable track! our search is finished!
      return cb(null, true);
    }

    i++;
    if (i < uris.length) {
      // the track is not playable, keep looking for a playable track
      self._bridge('track_metadata', [uris[i].toString()], onResponse);
    } else {
      cb(null, false);
    }
  };

  this._bridge('track_metadata', [uris[i].toString()], onResponse);
};

Adaptor.prototype.getAlbumTracks = function (uri, cb) {
  cb = this._cb(cb);

  var args = [uri.toString(), 0, -1];

  return this._bridge('album_tracks_snapshot', args, function (err, resp) {
    if (err) {
      return cb(err);
    }
    cb(null, resp.array);
  });
};

Adaptor.prototype.queueTracks = function (uris, cb) {
  queueModel.addTracksToQueue(uris, cb);
};

Adaptor.prototype.openApp = function (uri) {
  var event = new Event(Event.TYPES.NAVIGATION_OPEN_URI, uri);
  eventDispatcher.dispatchEvent(event);
};

Adaptor.prototype.canRemoveTracks = function (playlistUri, cb) {
  cb = this._cb(cb);

  playlistUri = playlistUri.toString();

  live(playlistUri).query('allows(removeTracks)', function (err, data) {
    if (err) {
      return cb(err);
    }
    cb(null, data.allows.removeTracks);
  }, live.ASAP);
};

Adaptor.prototype.removeTracksFromPlaylist = function (playlistUri, rowIds, indices, cb) {
  this._cosmos.resolver.post({
    url: 'sp://core-playlist/v1/playlist/' + encodeURIComponent(playlistUri),
    body: {
      operation: 'remove',
      rows: rowIds
    }
  }, cb);
};

Adaptor.prototype.removeTracksFromQueue = function (indices, cb) {
  queueModel.removeTracksFromQueue(indices, cb);
};

Adaptor.prototype.canUserReport = function () {
  return typeof window !== 'undefined' && window.__spotify && window.__spotify.product_state && window.__spotify.product_state['ugc-abuse-report'] === '1';
};

Adaptor.prototype.isPlaylistAbuseReportingEnabled = function (uri, cb) {
  var encodedUsername = encodeURIComponent(uri.username);
  var playlistId = liburi.hexToId(uri.id);
  cb = this._cb(cb);

  var hmUri = ['hm://playlist-annotate/v1/annotation/user', encodedUsername, 'playlist', playlistId].join('/') + '?format=json';

  this._cosmos.resolver.get(hmUri, function (error, response) {
    // Don't consider 404 an error
    // It is used to indicate the playlist is non-annotated
    if (error && (!response || response.getStatusCode() !== 404)) {
      return cb(error);
    }

    if (response.getStatusCode() === 200) {
      cb(null, response.getJSONBody().is_abuse_reporting_enabled);
    } else {
      cb(null, false);
    }
  });
};

Adaptor.prototype.getAbuseReportUrl = function (uri, cb) {
  var url = URL_BASE.replace('{uri}', uri);

  session.getOAuthToken(url, function (error, token) {
    if (error) {
      cb(error);
    } else {
      cb(null, url + '&' + decodeURIComponent(token));
    }
  });
};

Adaptor.prototype.createNewPlaylist = function (name, cb) {
  this._playlistActions.createNewPlaylist(name, this._cb(cb));
};

Adaptor.prototype.logAddToPlaylist = function (data) {
  this._playlistActions.logAddToPlaylist(data);
};

Adaptor.prototype.addTracksToPlaylist = function (uri, tracks, cb) {
  this._playlistActions.addTracksToPlaylist(uri, tracks, cb);
};

Adaptor.prototype.addAlbumToPlaylist = function (playlistUri, albumUri, cb) {
  this._playlistActions.addAlbumToPlaylist(playlistUri, albumUri, this._cb(cb));
};

Adaptor.prototype.addStuffToPlaylist = function (playlistUri, uris, cb) {
  this._playlistActions.addStuffToPlaylist(playlistUri, uris, this._cb(cb));
};

Adaptor.prototype.getNewPlaylistName = function (uris, cb) {
  getPlaylistNameFor.items(uris, this._cb(cb));
};

Adaptor.prototype.hasRenamePlaylistAction = function () {
  return playlistAnnotateTest.hasContextMenuRenameAction();
};

Adaptor.prototype.hasEditPlaylistAction = function () {
  return playlistAnnotateTest.hasContextMenuEditAction();
};

Adaptor.prototype.createRefreshedPlaylist = function (playlistUri, cb) {
  this._playlistActions.createRefreshedPlaylist(playlistUri, function (error, newPlaylistUri) {
    UIInteraction4.log({
      feature_id: window.__spotify.app_uri,
      interaction_type: 'hit',
      section_id: 'context-menu',
      timestamp: Date.now(),
      user_intent: 'freshen-playlist',
      target_uri: newPlaylistUri
    });
    cb(error, newPlaylistUri);
  });
};

/**
 * Export public interface
 */
module.exports = Adaptor;

},{"../../../../../libs/spotify-event-dispatcher":264,"../../../../../libs/spotify-live":439,"../../../../../libs/spotify-live-get-playlist-name-for-items":392,"../../../../../libs/spotify-logger/messages/UIInteraction4":452,"../../../../../libs/spotify-playlist-actions":483,"../../../../../libs/spotify-playlist-annotate-test":485,"../../event":77,"../../logging/client-event-logger":93,"../../models/queue":104,"../../models/session.js":107,"spotify-liburi":707}],59:[function(require,module,exports){
'use strict';

var cosmos = require('spotify-cosmos-api');
var bridge = require('../../../../../libs/spotify-bridge-request');
var shuffleMode = require('../../../../../libs/spotify-shuffle-mode');

var ContextMenu = require('../../../../../libs/contextmenu');
var liburi = require('spotify-liburi');
var EventEmitter = require('spotify-eventemitter');
var inherit = require('spotify-inheritance/inherit');

var actions = require('./actions');
var Adaptor = require('./adaptor');

// Require and register some live-models
require('./live-models');

var CLICK_CHANNEL = 'sp://messages/v1/context_menu_click';
var STATE_CHANNEL = 'sp://messages/v1/context_menu_state';
/**
 * Context menu constructor
 **/
var ContextMenuApp = function ContextMenuApp(options) {
  EventEmitter.call(this);

  options = options || {};

  this._contextmenu = new ContextMenu(options);
  this._adaptor = new Adaptor(bridge.request, cosmos);

  ContextMenu.injectCSS();

  this._actions = actions(this._adaptor, this._contextmenu);
  this._appURI = null;

  this._contextmenu.addListener('click', this.postContextMenuClick.bind(this));

  this._contextmenu.addListener('hide', this.postContextMenuHide.bind(this));
};
inherit(ContextMenuApp, EventEmitter);

ContextMenuApp.prototype.postContextMenuClick = function (body) {
  cosmos.resolver.post({ url: CLICK_CHANNEL, body: body }, function () {});
  var itemType = this._uris && this._uris[0] && this._uris[0].type || null;
  var itemUri = this._uris && this._uris[0] && this._uris[0].toURI() || null;
  var numberItems = this._uris && this._uris.length || null;
  this._adaptor.logUserHit({
    name: body.id,
    target_uri: this._appURI,
    event_version: 'contextmenu-action',
    item_type: itemType,
    item_uri: itemUri,
    number_items: numberItems,
    context: this._contextURI
  });
};

ContextMenuApp.prototype.postContextMenuHide = function () {
  cosmos.resolver.post({
    url: STATE_CHANNEL,
    body: { state: 'hide' } }, function () {});
  this.emit('hide');
};

ContextMenuApp.prototype.setUserPlaylists = function (playlists) {
  this._adaptor.setUserPlaylists(playlists);
};

ContextMenuApp.prototype.setRenamePlaylistAction = function (fn) {
  this._actions.renamePlaylist.setAction(fn);
};

ContextMenuApp.prototype.setRenameFolderAction = function (fn) {
  this._actions.renameFolder.setAction(fn);
};

ContextMenuApp.prototype.setEditPlaylistAction = function (fn) {
  this._actions.editPlaylist.setAction(fn);
};

ContextMenuApp.prototype.setCreateFolderAction = function (fn) {
  this._actions.createFolder.setAction(fn);
};

ContextMenuApp.prototype.setCreatePlaylistAction = function (fn) {
  this._actions.createPlaylist.setAction(fn);
};

ContextMenuApp.prototype.setRemovePlaylistAction = function (fn) {
  this._actions.deletePlaylist.setAction(fn);
  this._actions.follow.setUnfollowAction(fn);
};

ContextMenuApp.prototype.setOfflineAction = function (fn) {
  this._actions.offline.setAction(fn);
};

/**
 * Shows the context menu
 *
 * @param Object data object with all the needed stuff
 **/
ContextMenuApp.prototype.show = function (data) {
  this._appURI = data.appURI;
  this._contextURI = data.contexts && data.contexts[0] && data.contexts[0].uri || null;
  this._contextmenu.clearItems();
  var uris = this._uris = data.uris.map(liburi.from);

  switch (uris[0].type) {
    case liburi.Type.TRACK:
    case liburi.Type.ALBUM:
    case liburi.Type.ARTIST:
    case liburi.Type.PLAYLIST:
    case liburi.Type.FOLDER:
    case liburi.Type.PROFILE:
    case liburi.Type.LOCAL:
    case liburi.Type.STATION:
      break;
    default:
      return;
  }

  // discard old requests from the adaptor
  this._adaptor.discardPendingRequests();

  this._populate(uris, data);

  // Remove duplicate separators
  this._contextmenu.dedupeSeps();

  this._contextmenu.show({
    x: data.x,
    y: data.y
  });
};

ContextMenuApp.prototype._populate = function (uris, data) {
  if (!shuffleMode.isEnabled()) {
    this._actions.queue.buildItem(uris, data);
  }
  this._actions.radio.buildItem(uris, data);

  this._actions.goto.buildItem(uris, data);

  this._contextmenu.addItem({});

  this._actions.collection.buildItem(uris, data);
  this._actions.addToPlaylist.buildItem(uris, data);

  this._contextmenu.addItem({});

  this._actions.share.buildItem(uris, data);
  this._actions.clipboard.buildItem(uris, data);

  this._contextmenu.addItem({});

  this._actions.collaborative.buildItem(uris, data);
  this._actions.publish.buildItem(uris, data);

  this._actions.renameFolder.buildItem(uris, data);
  this._actions.renamePlaylist.buildItem(uris, data);
  this._actions.editPlaylist.buildItem(uris, data);
  this._actions.reportPlaylist.buildItem(uris, data);
  this._actions.refreshPlaylist.buildItem(uris, data);
  this._actions.deletePlaylist.buildItem(uris, data);

  this._actions.follow.buildItem(uris, data);
  this._actions.removeFromPlaylist.buildItem(uris, data);
  this._actions.removeFromQueue.buildItem(uris, data);
  this._actions.reportAsset.buildItem(uris, data);

  this._contextmenu.addItem({});

  this._actions.createPlaylist.buildItem(uris, data);
  this._actions.createFolder.buildItem(uris, data);
  this._actions.openLocalFileFolder.buildItem(uris, data);

  this._actions.offline.buildItem(uris, data);
};

/**
 * Export public interface
 */
module.exports = ContextMenuApp;

},{"../../../../../libs/contextmenu":179,"../../../../../libs/spotify-bridge-request":253,"../../../../../libs/spotify-shuffle-mode":491,"./actions":44,"./adaptor":58,"./live-models":60,"spotify-cosmos-api":694,"spotify-eventemitter":700,"spotify-inheritance/inherit":706,"spotify-liburi":707}],60:[function(require,module,exports){
'use strict';

require('../../../../../libs/spotify-live-models/client').register();
require('../../../../../libs/spotify-live-models/playlist').register();
require('../../../../../libs/spotify-live-models/track').register();
require('../../../../../libs/spotify-live-models/album').register();
require('../../../../../libs/spotify-live-models/artist').register();
require('../../../../../libs/spotify-live-models/station').register();

require('../../../../../libs/spotify-live-models/add/track').register();
require('../../../../../libs/spotify-live-models/add/album').register();

},{"../../../../../libs/spotify-live-models/add/album":393,"../../../../../libs/spotify-live-models/add/track":398,"../../../../../libs/spotify-live-models/album":399,"../../../../../libs/spotify-live-models/artist":401,"../../../../../libs/spotify-live-models/client":403,"../../../../../libs/spotify-live-models/playlist":414,"../../../../../libs/spotify-live-models/station":424,"../../../../../libs/spotify-live-models/track":431}],61:[function(require,module,exports){
'use strict';

var ko = require('knockout');
var _ = require('../../i18n').get;
var live = require('../../../../libs/spotify-live');
var util = require('../live-models/util');
var keyboard = require('../keyboard');
var eventDispatcher = require('../../../../libs/spotify-event-dispatcher');
var Event = require('../event');
var uriHelper = require('../urihelper');
var liburi = require('spotify-liburi');
var cosmos = require('spotify-cosmos-api');

function DeletePlaylistDialog() {}

DeletePlaylistDialog.prototype.setup = function () {
  this._container = document.getElementById('delete-playlist');
  this._element = this._container.querySelector('.dropdown-menu');
  this._activeElement = null;

  this.confirmText = ko.observable('');
  this.cancelBtn = _('playlist.delete_cancel');
  this.confirmBtn = ko.observable('');

  var self = this;
  keyboard.registerIsolatedShortcut(keyboard.KEYS.ESCAPE, this._element, function (e) {
    if (self._isVisible()) {
      e.preventDefault();
      self.hide();
    }
  });

  keyboard.registerIsolatedShortcut(keyboard.KEYS.ENTER, this._element, function (e) {
    if (self._isVisible()) {
      e.preventDefault();
      self.confirm();
    }
  });

  ko.applyBindings(this, this.getContainer());
};

DeletePlaylistDialog.prototype.clickContainer = function (model, evt) {
  if (evt.target === this._container) {
    this.hide();
  }
};

DeletePlaylistDialog.prototype.confirm = function () {
  var uri = this._uri;
  var playlist;

  var list = live('spotify:rootlist').get('rows');
  if (list) {
    // Find the index of the playlist in the rootlist
    var index = -1;
    for (var i = 0, l = list.length; i < l; i++) {
      var row = list.get(i);
      playlist = row && row.get('playlist');

      if (playlist && playlist.uri === uri) {
        index = i;
        break;
      }
    }

    if (index > -1) {
      // Publish the removal so that the rootlist model will remove the playlist
      list.publish([{ type: 'remove', index: index, length: 1 }]);

      var request = {
        url: 'sp://messages/v1/followstate',
        body: {
          uri: uri,
          isFollowing: false
        }
      };
      cosmos.resolver.post(request, function () {});

      var appUri;
      var uriObject = liburi.from(uri);

      if (uriObject.type === liburi.Type.FOLDER) {
        appUri = uriHelper.folderCanonicalURI(uri);
      } else if (playlist.get('formatListType') === 'chart') {
        appUri = uriHelper.chartCanonicalURI(uri);
      } else {
        appUri = uriHelper.playlistCanonicalURI(uri);
      }

      eventDispatcher.dispatchEvent(new Event(Event.TYPES.NAVIGATION_HISTORY_REMOVE, appUri));

      // Defer the hiding of the dialog to the next tick to let all event
      // handlers run first. Not deferring this caused playback to happen, since
      // we start playback on the press of Enter on a sidebar item if the
      // sidebar has focus (which it has after we've hidden this dialog).
      var self = this;
      setTimeout(function () {
        self.hide();
      }, 0);
    }
  }
};

DeletePlaylistDialog.prototype._popoverId = 'deleteplaylist';

DeletePlaylistDialog.prototype.show = function (uri, notConfirmation) {
  var self = this;

  this._uri = uri;

  if (notConfirmation) {
    return this.confirm();
  }

  var model = live(uri);
  model.query('owner(currentUser)', function (err, data) {
    if (err) {
      return;
    }

    var parent = document.getElementById('menu-wrapper');
    var selector = '.item[data-uri="' + uri + '"]';
    var playlistElem = parent.querySelector(selector);

    if (!playlistElem) {
      return;
    }

    var uriObject = liburi.from(uri);
    var isFolder = !!(uriObject && uriObject.type === liburi.Type.FOLDER);

    // Calculate where to show the confirmation dialog
    // (it should be next to the playlist)
    var playlistPos = playlistElem.getBoundingClientRect();
    var parentPos = parent.getBoundingClientRect();

    var top = playlistPos.top + playlistPos.height / 2;
    var left = parentPos.width;

    var text = _('playlist.unfollow_message');
    var confirmButtonLabel = _('playlist.unfollow_confirm');
    if (isFolder) {
      text = _('playlistfolder.delete_message');
      confirmButtonLabel = _('playlist.delete_confirm');
    } else if (data.owner.currentUser) {
      text = _('playlist.delete_message');
      confirmButtonLabel = _('playlist.delete_confirm');
    }

    self.confirmText(text);
    self.confirmBtn(confirmButtonLabel);

    self._container.style.visibility = 'hidden';
    self._container.style.display = 'block';

    self._element.style.left = left + 'px';
    var height = self._element.getBoundingClientRect().height;
    self._element.style.top = top - height / 2 + 'px';

    self._container.style.visibility = 'visible';

    self._activeElement = document.activeElement;
    self._element.focus();

    eventDispatcher.dispatchEvent(new Event(Event.TYPES.POPOVER_OPENED, { id: self._popoverId }));
  });
};

DeletePlaylistDialog.prototype.getContainer = function () {
  return this._container;
};

DeletePlaylistDialog.prototype.hide = function () {
  this._container.style.display = 'none';

  if (this._activeElement) {
    this._activeElement.focus();
    this._activeElement = null;
  }

  eventDispatcher.dispatchEvent(new Event(Event.TYPES.POPOVER_CLOSED, { id: this._popoverId }));

  // remove the deleting property from the live model row
  live(util.getRowUri(this._uri)).update({
    deleting: false
  });
};

DeletePlaylistDialog.prototype._isVisible = function () {
  return this._container.style.display === 'block' && this._container.style.visibility === 'visible';
};

module.exports = new DeletePlaylistDialog();

},{"../../../../libs/spotify-event-dispatcher":264,"../../../../libs/spotify-live":439,"../../i18n":11,"../event":77,"../keyboard":83,"../live-models/util":91,"../urihelper":117,"knockout":567,"spotify-cosmos-api":694,"spotify-liburi":707}],62:[function(require,module,exports){
'use strict';

var liburi = require('spotify-liburi');

function deletePlaylist(cosmos, live, world, uri) {
  world.scrollToRowElementOfPlaylist(uri);

  var isHidden = live(uri).get('hidden');
  if (isHidden) return;

  var isFolder = liburi.from(uri) && liburi.from(uri).type === liburi.Type.FOLDER;
  if (isFolder) {
    world.triggerDeletePlaylistDialog(uri);
    return;
  }

  var metadataEndpointURI = 'sp://core-playlist/v1/playlist/' + encodeURIComponent(uri) + '/metadata';

  cosmos.resolver.get({
    url: metadataEndpointURI,
    body: {
      policy: {
        length: true
      }
    }
  }, function (error, result) {
    if (error) {
      console.warn(error);
      return;
    }
    var body = result.getJSONBody();
    var skipConfirmationDialog = body.metadata.length === 0;

    world.triggerDeletePlaylistDialog(uri, skipConfirmationDialog);
  });
}

module.exports = deletePlaylist;

},{"spotify-liburi":707}],63:[function(require,module,exports){
'use strict';

var _ = require('../../i18n');
var Cosmos = require('spotify-cosmos-api');

/**
 * View model to manage the connect device and volume popup
 *
 * @param {string} elementId The ID of the element.
 */
function GlobalOfflineProgress(elementId) {
  this._element = document.getElementById(elementId);

  this._syncing = false;
}

/**
 * Start listening for events
 */
GlobalOfflineProgress.prototype.start = function () {
  Cosmos.resolver.get('sp://offline/v1/progress/total', this._onOfflineSync.bind(this));

  if (typeof this._listener === 'undefined') {
    this._listener = Cosmos.resolver.subscribe('sp://offline/v1/progress/total', this._onOfflineSync.bind(this));
  }
};

/**
 * Stop listening for events
 */
GlobalOfflineProgress.prototype.stop = function () {
  if (typeof this._listener !== 'undefined') {
    Cosmos.resolver.unsubscribe('sp://offline/v1/progress/total', this._listener);
  }
};

GlobalOfflineProgress.prototype._onOfflineSync = function (err, response) {
  if (err) {
    return;
  }
  response = response.getJSONBody().progress;

  if (response.syncing) {
    if (!this._syncing) {
      this._element.style.display = 'block';
      this._syncing = true;
    }

    var currentTrack = response.synced_tracks + 1;
    var totalTracks = response.synced_tracks + response.queued_tracks;

    var msg = _.get('offline-progress-msg', currentTrack, totalTracks);

    this._element.querySelector('span').textContent = msg;
    this._element.querySelector('p').style.width = response.percent_complete + '%';
  } else if (this._syncing) {
    this._syncing = false;
    this._element.style.display = 'none';
  }
};

module.exports = GlobalOfflineProgress;

},{"../../i18n":11,"spotify-cosmos-api":694}],64:[function(require,module,exports){
'use strict';

var ko = require('knockout');

/**
 * Navigation bar menu item
 */
function MenuItem(title, href, params) {
  params = params || {};

  this.title = ko.observable(title);
  this.href = ko.observable(href);
  this.icon = ko.observable(params.icon || href.split(':').pop());
  this.iconClass = ko.pureComputed(function () {
    return 'spoticon-' + this.icon() + '-32';
  }, this);

  this.template = params.template || 'menu-item';
  this.id = null;
  if (params.menuItemId) {
    this.id = 'menu-item-' + params.menuItemId;
  }

  if (params.activeRegexp) {
    this._activeRegexp = params.activeRegexp instanceof RegExp ? params.activeRegexp : new RegExp(params.activeRegexp);
  } else {
    this._activeRegexp = new RegExp('^' + this.href());
  }

  this.dropTargetTypes = (params.dropTargetTypes || []).join('|');
  // Hack to avoid KM-4760:
  // Dropping a playlist on Radio moves around the rootlist
  this.noListTarget = params.noListTarget ? '' : null;

  this.uri = params.uri;
  this.visible = ko.observable(true);
  this.contextAttribute = params.isContext ? '' : null;
  this.hasContextAttribute = !!params.isContext;
}

MenuItem.prototype.isActive = function (currentURI) {
  return this._activeRegexp.test(currentURI);
};

module.exports = MenuItem;

},{"knockout":567}],65:[function(require,module,exports){
'use strict';

var util = require('../live-models/util');
var session = require('../models/session');
var playlistAnnotateTest = require('../../../../libs/spotify-playlist-annotate-test');
var NEW_FOLDER_URI = require('../live-models/uris').NEW_FOLDER_URI;

/**
 * Get the CSS class name for a rootlist playlist row object.
 *
 * @param {Object} row Data for a row of a playlist in the rootlist.
 * @param {string} currentClassName The current `className` of the row element.
 *
 * @return {string} The new `className` value for the row.
 */
function getCSSClass(row, currentClassName) {
  var descriptor = {};

  descriptor.item = true;
  descriptor.hidden = !!row.hidden;
  descriptor.active = !!row.active;
  descriptor.folder = !!(row.folderStart || row.uri === NEW_FOLDER_URI);
  descriptor['new-folder'] = row.uri === NEW_FOLDER_URI;
  descriptor.expanded = !!(descriptor.folder && row.expanded);
  descriptor.playlist = !!(!descriptor.folder && row.uri);

  var playlist = row.playlist || {};

  var offlineStatus = playlist.offlineStatus;
  descriptor.offline = offlineStatus === 'yes' || offlineStatus === 'downloading' || offlineStatus === 'waiting';
  descriptor.complete = offlineStatus === 'yes';
  descriptor.syncing = offlineStatus === 'downloading';
  descriptor.waiting = offlineStatus === 'waiting';

  var owner = playlist.owner;
  var ownerUri = owner && owner.uri;
  descriptor.followed = !!(ownerUri && ownerUri !== session.getUserUri());

  descriptor.renaming = !!(row.renaming && (!playlist || !util.annotateHandlesEdit(playlist.uri)));

  descriptor['annotate-hint'] = playlistAnnotateTest.hasSidebarRenameFieldHintButton();

  return convertDescriptorToClassName(descriptor, currentClassName);
}

/**
 * Convert a descriptor object to a class name string, while also taking the
 * current class name into account. Class names that are specified in the
 * descriptor always takes precedence. Class names that are only in the current
 * class name are kept.
 *
 * @param {Object} descriptor Object where keys are class names and values are
 *     true if the class name should be there and false if it should not be in
 *     the final class name string.
 * @param {string} currentClassName The current class name string.
 *
 * @return {string} The new class name string.
 *
 * @private
 */
function convertDescriptorToClassName(descriptor, currentClassName) {
  var currentClasses = currentClassName ? currentClassName.split(' ') : [];

  for (var key in descriptor) {
    if (descriptor.hasOwnProperty(key)) {
      var enabled = descriptor[key];
      var index = currentClasses.indexOf(key);

      // Remove class name if descriptor says false for that class name and it's
      // found in the current class name string.
      if (!enabled) {
        if (index !== -1) currentClasses.splice(index, 1);

        // Add the class name if descriptor says true for that class name and it's
        // not found in the current class name string.
      } else {
          if (index === -1) currentClasses.push(key);
        }
    }
  }

  return currentClasses.join(' ');
}

module.exports = getCSSClass;

},{"../../../../libs/spotify-playlist-annotate-test":485,"../live-models/uris":90,"../live-models/util":91,"../models/session":107}],66:[function(require,module,exports){
'use strict';

var uris = require('../live-models/uris');

/**
 * Get the icon for a rootlist playlist row object.
 *
 * @param {Object} row Data for a row of a playlist in the rootlist.
 *
 * @return {string} The icon name for the row.
 */
function getIcon(row) {
  var playlist = row.playlist;
  var offlineStatus = playlist && playlist.offlineStatus;

  if (row.folderStart || row.uri === uris.NEW_FOLDER_URI) {
    return 'chart-down';
  }

  if (offlineStatus === 'waiting' || offlineStatus === 'downloading') {
    return 'offline-sync';
  }

  if (row.playlist && row.playlist.collaborative) {
    return 'collaborative-playlist';
  }

  return 'playlist';
}

module.exports = getIcon;

},{"../live-models/uris":90}],67:[function(require,module,exports){
'use strict';

var live = require('../../../../libs/spotify-live');
var events = require('../../../../libs/spotify-events');
var glue = require('../../../../libs/spotify-glue-cat');
var playerEvents = require('../../../../libs/spotify-events/player');
var eventsCenter = require('../../../../libs/spotify-events/center');
var $ = require('../../../../libs/spotify-elements');
var playlistRowTemplate = require('../../templates/sidebar/playlist.hbs');
var hbs = require('../../../../libs/spotify-handlebars');
var helpers = require('../../../../libs/spotify-handlebars/helpers');
var CircularLoader = require('./circular-loader');
var Keyboard = require('../keyboard');
var defer = require('spotify-deferred');
var deletePlaylistDialogComponent = require('../components/delete-playlist-dialog');
var isFocusable = require('../utils/focusable');
var cosmos = require('spotify-cosmos-api');
var UIInteraction4 = require('../../../../libs/spotify-logger/messages/UIInteraction4');

var eventDispatcher = require('../../../../libs/spotify-event-dispatcher');
var Event = require('../event');
var rootlistModel = require('../models/rootlist');
var getCSSClass = require('./playlists-css-class');
var getIcon = require('./playlists-icon');

var util = require('../live-models/util');
var _ = require('../../i18n').get;

var ROW_REGEXP = require('../live-models/uris').ROW_REGEXP;
var PLAYLIST_REGEXP = require('../live-models/uris').PLAYLIST_REGEXP;
var FOLDER_REGEXP = require('../live-models/uris').FOLDER_REGEXP;
var USER_REGEXP = require('../live-models/uris').USER_REGEXP;
var NEW_FOLDER_URI = require('../live-models/uris').NEW_FOLDER_URI;
var NEW_PLAYLIST_URI = require('../live-models/uris').NEW_PLAYLIST_URI;

var RETRY_TIME = 150;

// pixels from the top/bottom where to display a renamed/deleted playlist
// that is not visible due to the sidebar scroll position
var OFFSET_SCROLL_POSITION = 200;

// Minimal time between a click for activating playlist
// and a click for renaming it
var RENAME_CLICK_TIMEOUT = 100;

// Default double-click interval, in the case effective value
// (__spotify.double_click_interval) is missing
var DEFAULT_DOUBLECLICK_INTERVAL = 500;

hbs.register(helpers);

var offlineLoaders = {};
var inputBeingMoved = null;

var renderRow = function renderRow(rowUri, element) {
  var data = rootlistModel.getMetadataForRow(rowUri);
  renderPlaylistWithData(data, element);
};

var deletePlaylist = require('./delete-playlist').bind(null, cosmos, live, {
  scrollToRowElementOfPlaylist: function scrollToRowElementOfPlaylist(uri) {
    var $row = $('#menu-wrapper .item[data-uri="' + uri + '"]');
    if ($row) {
      scrollSidebarToElement($row[0]);
    }
  },
  triggerDeletePlaylistDialog: function triggerDeletePlaylistDialog(uri, skipConfirmation) {
    deletePlaylistDialogComponent.show(uri, skipConfirmation);
  }
});

var renderPlaylistWithData = function renderPlaylistWithData(data, element) {
  if (!element.parentNode) {
    return;
  }

  // Don't render anything for rows that should never be visible
  if (data.folderEnd || !data.uri) {
    element.className = 'hidden';
    return;
  }

  var itemUri = util.getRealUri(data.uri);

  var activeRow = live('spotify:rootlist').get('activeRow');
  var activeRowUri = activeRow && activeRow.uri;
  data.active = activeRowUri === data.uri;
  data.icon = getIcon(data);

  element.className = getCSSClass(data, element.className);
  replacePlaySource(element, data);

  if (element.classList.contains('renaming')) {
    element.removeAttribute('draggable');
  } else {
    element.setAttribute('draggable', 'true');
  }

  if (data.playlist) {
    // Playlist gets its name from the data, or 'Loading...' if
    // we don't have the name yet.
    if (!data.playlist.name) {
      if (data.uri === NEW_FOLDER_URI) {
        data.playlist.name = _('playlist.newfolder');
      } else if (data.uri === NEW_PLAYLIST_URI) {
        data.playlist.name = _('new_playlist.input_placeholder');
      } else {
        data.playlist.name = _('playlist.loading');
      }
    }
  }

  // Replace row URI with playlist URI for template
  if (data.playlist && data.playlist.uri) {
    data.uri = data.playlist.uri;
  }

  data.isGlue2 = glue.getVersion() === 2;

  element.innerHTML = playlistRowTemplate(data);

  var mimeTypes;
  var playlist = data.playlist;
  if (playlist && playlist.allows && playlist.allows.insertTracks) {
    mimeTypes = 'text/x-spotify-tracks|text/x-spotify-albums';
    element.firstChild.setAttribute('data-drop-target', mimeTypes);
  }
  if (util.isFolder(itemUri)) {
    mimeTypes = ['text/x-spotify-playlists', 'text/x-spotify-folders', 'text/x-spotify-albums', 'text/x-spotify-tracks'].join('|');
    element.firstChild.setAttribute('data-drop-target', mimeTypes);
  }

  delete offlineLoaders[itemUri];
  renderOfflineProgressIfApplicable(data.playlist, updateProgressCanvas.bind(null, element));

  defer(function () {
    if (data.renaming && !util.annotateHandlesEdit(itemUri)) {
      selectEditText(element);
    }
  });
};

var updateDataIndex = function updateDataIndex(parent) {
  var rows = parent.children;
  for (var i = 0, l = rows.length; i < l; i++) {
    rows[i].setAttribute('data-index', i.toString());
  }
};

var replacePlaySource = function replacePlaySource(element, data) {
  var source = 'playlist';

  var playlist = data.playlist;

  if (playlist) {
    var hasCollaborative = 'collaborative' in playlist;
    var hasOwner = playlist.owner && 'currentUser' in playlist.owner;

    if (hasCollaborative && hasOwner) {
      var sourceParts = ['playlist', 'owned', 'by'];
      sourceParts.push(playlist.owner.currentUser ? 'self' : 'other');
      sourceParts.push(playlist.collaborative ? 'collaborative' : 'non-collaborative');
      source = sourceParts.join('-');
    }
  }

  element.setAttribute('data-play-source', source);
};

var selectEditText = function selectEditText(element) {
  defer(function () {
    var editElement = element.querySelector('.edit');
    if (editElement) {
      editElement.select();
      editElement.focus();

      scrollSidebarToElement(editElement);
    }
  });
};

var scrollSidebarToActiveInput = function scrollSidebarToActiveInput() {
  if (document.activeElement.tagName.toLowerCase() === 'input') {
    var sidebar = document.getElementById('view-navigation-bar');
    if (sidebar.contains(document.activeElement)) {
      scrollSidebarToElement(document.activeElement);
    }
  }
};

var scrollSidebarToElement = function scrollSidebarToElement(element) {
  var sidebar = document.getElementById('view-navigation-bar');

  var elementPos = element.getBoundingClientRect();
  var containerPos = sidebar.getBoundingClientRect();

  var offset = Math.min(OFFSET_SCROLL_POSITION, (containerPos.height - elementPos.height) / 2);

  // we scroll the sidebar to show the playlist at 200px from the top or the
  // bottom (depeding if it was above or below fold).
  // If the sidebar height is smaller than 400px, we vertically center the
  // playlist
  var position = elementPos.top - containerPos.top;
  if (position < 0) {
    sidebar.scrollTop += position - offset;
  } else {
    position = position + elementPos.height - containerPos.height;

    if (position > 0) {
      sidebar.scrollTop += position + offset;
    }
  }
};

var updateProgressCanvas = function updateProgressCanvas(element, uri, value) {
  if (offlineLoaders[uri]) {
    offlineLoaders[uri].setProgress(value * 100);
  } else {
    var type = glue.getVersion() === 2 ? 'pie' : 'circle';
    var size = glue.getVersion() === 2 ? 16 : 26;
    var canvas = element.querySelector('canvas');
    offlineLoaders[uri] = new CircularLoader(type, canvas, size, size, value * 100);
  }
};

var removePlaylists = function removePlaylists(operation, parent) {
  var length = operation.length;
  if (length === 0) return;

  var position = operation.index;

  for (var i = 0; i < length; i++) {
    var element = parent.children[position];
    if (element) {
      parent.removeChild(element);
    }
  }

  updateDataIndex(parent);
  scrollSidebarToActiveInput();
};

var insertPlaylists = function insertPlaylists(operation, parent) {
  var playlists = operation.values;
  if (playlists.length === 0) return;

  var start = operation.index;
  var end = start + playlists.length;

  var rows = rootlistModel.getRowsForRange(start, end);
  insertAndRenderRows(rows, parent, start);
};

var movePlaylists = function movePlaylists(operation, parent) {
  var length = operation.length;
  if (length === 0) return;

  var from = operation.from;
  var elements = [];

  for (var i = 0; i < length; i++) {
    var element = parent.children[from];
    if (element) {
      var input = element.querySelector('input[type=text]');
      if (input && input === document.activeElement) {
        inputBeingMoved = input;
      }
      parent.removeChild(element);
      elements.push(element);
    }
  }

  var elementAfterTo = parent.children[operation.to];

  elements.forEach(function (element) {
    parent.insertBefore(element, elementAfterTo);
  });

  if (inputBeingMoved) {
    inputBeingMoved.focus();
    inputBeingMoved = null;
  }

  updateDataIndex(parent);
  scrollSidebarToActiveInput();
};

var insertAndRenderRows = function insertAndRenderRows(rows, parent, position) {
  for (var i = 0, l = rows.length; i < l; i++) {
    var nextNode = parent.children[position + i];
    var element = document.createElement('li');
    element.setAttribute('data-list-item', '');
    element.setAttribute('draggable', 'true');

    parent.insertBefore(element, nextNode || null);

    var row = rows[i];
    var uri;

    if (row) {
      uri = util.getRealUri(row.uri);

      element.classList.add('item');
      element.dataset.uri = uri;
      element.dataset.contextmenu = '';
      element.setAttribute('data-sidebar-item', uri);

      if (util.isPlaylist(uri)) {
        element.dataset.context = '';
      }

      renderPlaylistWithData(row, element);
    }
  }

  updateDataIndex(parent);
  scrollSidebarToActiveInput();

  playerEvents.update();
};

var init = function init() {
  rootlistModel.setup();
  deletePlaylistDialogComponent.setup();

  // See mousedown handler for what these do
  var clickToRenameTimeout = 0;
  var countAsRenameClick = false;

  var systemDoubleClickInterval = window.__spotify.double_click_interval || DEFAULT_DOUBLECLICK_INTERVAL;
  var renameClickDelay = systemDoubleClickInterval + RENAME_CLICK_TIMEOUT;

  $('#menu-playlists').delegate('click', '.item.folder .menu-accessory', function (evt, elem) {
    evt.preventDefault();

    var node = elem.parent().parent();

    var rowUri = util.getRowUri(node.data('uri'));

    live(rowUri).publish({
      expanded: !live(rowUri).get('expanded')
    });
  });

  $('#menu-playlists').delegate('mousedown', '.annotate-hint-button', function (evt, elem) {
    evt.preventDefault();

    var node = elem.parent('[data-uri]');
    var uri = node.data('uri');

    cosmos.resolver.post({
      url: 'sp://messages/v1/open-annotate-form',
      body: {
        uri: uri,
        name: node.search('input.edit').value()
      }
    });

    elem[0].focus();
  });

  $('#menu-wrapper').delegate('dblclick', '.item.playlist, .item.folder', function (evt, elem) {
    evt.preventDefault();

    var target = $(evt.target);
    // It's necessary to specify the icon classname to be sure that
    // the target element is the folder arrow. If the icon classname
    // changes, it needs to be changed here also.
    var isFolderArrow = target && target.matches('.menu-accessory') && target.parent('.item.folder');
    var isInputField = target && target.matches('input');
    if (isFolderArrow || isInputField) return;

    var data = {
      context: elem.data('uri'),
      reason: 'clickside'
    };

    var playSourceNode;
    if (elem.matches('[data-play-source]')) {
      playSourceNode = elem;
    } else {
      playSourceNode = elem.parent('[data-play-source]');
    }

    if (playSourceNode) {
      data.source = playSourceNode.data('play-source');
    }

    live('spotify:player').emit('play', data);
  });

  function deleteActiveRow(e) {
    if (e) {
      e.preventDefault();
    }
    // Delete active playlist or folder
    var activeRow = live('spotify:rootlist').get('activeRow');
    if (activeRow) {
      activeRow.update({
        deleting: true
      });
    }
  }

  var sidebar = document.getElementById('view-navigation-bar');

  Keyboard.registerIsolatedShortcut(Keyboard.KEYS.BACKSPACE, sidebar, deleteActiveRow);
  Keyboard.registerIsolatedShortcut(Keyboard.KEYS.DELETE, sidebar, deleteActiveRow);

  eventDispatcher.addEventListener(Event.TYPES.CONTROL_MESSAGE_DELETE, function () {
    if (sidebar.contains(document.activeElement)) {
      deleteActiveRow();
    }
  });

  eventDispatcher.addEventListener(Event.TYPES.CONTROL_MESSAGE_NEW_PLAYLIST, function () {
    console.log('RenameTriggerLogging: New playlist control-message', new Date());
    UIInteraction4.log({
      feature_id: live('spotify:application').get('appURI') || 'unknown',
      interaction_type: 'hit',
      section_id: 'system-menu',
      timestamp: Date.now(),
      user_intent: 'create-playlist'
    });
    util.createRootlistItem(NEW_PLAYLIST_URI, { belowActiveRow: true });
  });

  eventDispatcher.addEventListener(Event.TYPES.CONTROL_MESSAGE_NEW_FOLDER, function () {
    UIInteraction4.log({
      feature_id: live('spotify:application').get('appURI') || 'unknown',
      interaction_type: 'hit',
      section_id: 'system-menu',
      timestamp: Date.now(),
      user_intent: 'create-folder'
    });
    util.createRootlistItem(NEW_FOLDER_URI, { belowActiveRow: true });
  });

  eventDispatcher.addEventListener(Event.TYPES.CONTROL_MESSAGE_UNDO, function (e) {
    var regex = /^spotify:user:.+:rootlist/;
    if (!regex.test(e.params.link)) {
      eventDispatcher.dispatchEvent(new Event(Event.TYPES.NAVIGATION_OPEN_URI, e.params.link));
    }
  });

  Keyboard.registerIsolatedShortcut(Keyboard.KEYS.ENTER, sidebar, function (e) {
    e.preventDefault();
    var activeRow = live('spotify:rootlist').get('activeRow');
    if (activeRow) {
      live('spotify:player').emit('play', {
        context: util.getRealUri(activeRow.uri),
        reason: 'clickside'
      });
    }
  });

  $('#menu-wrapper').delegate('click', '.item.playlist:not(.active), .item.folder:not(.active)', function (evt, elem) {
    var uri = elem.data('uri');

    if (evt.target.matches('.menu-accessory') && elem.matches('.folder')) {
      return;
    }

    if (uri) {
      eventDispatcher.dispatchEvent(new Event(Event.TYPES.NAVIGATION_OPEN_URI, uri));
    }
  });

  // A click on an active element should only start the rename timeout if
  // the element or it's next focusable parent already has focus.
  // On the click event the focus has already changed, but since the click
  // event will be preceded by a mousedown, countAsRenameClick is set here:
  $('#menu-playlists').delegate('mousedown', '.item.active:not(.followed):not(.renaming) .title', function (evt, elem) {
    countAsRenameClick = false;
    if (!document.activeElement) {
      return;
    }

    var testFocusable = elem[0];
    var closestFocusable;
    if (isFocusable(testFocusable)) {
      closestFocusable = testFocusable;
    }

    while (!closestFocusable && testFocusable.parentNode) {
      testFocusable = testFocusable.parentNode;
      if (isFocusable(testFocusable)) {
        closestFocusable = testFocusable;
      }
    }

    countAsRenameClick = closestFocusable === document.activeElement;
  });

  $('#menu-playlists').delegate('click', '.item.active:not(.followed):not(.renaming) .title', function (evt, elem) {
    clearTimeout(clickToRenameTimeout);
    clickToRenameTimeout = null;

    if (countAsRenameClick) {
      console.log('RenameTriggerLogging: Slow click timeout start', new Date());
      clickToRenameTimeout = setTimeout(function () {
        var uri = elem.parent('.item').data('uri');
        if (uri) {
          console.log('RenameTriggerLogging: Slow click effective', new Date());
          live(util.getRowUri(uri)).update({ renaming: true });
        }
      }, renameClickDelay);
    }
  });

  // On dblclick we need to cancel the next timeout which the 'click' handler
  // started on the second click.
  $('#menu-playlists').delegate('dblclick', '.item.active:not(.followed):not(.renaming) .title', function () {
    clearTimeout(clickToRenameTimeout);
    clickToRenameTimeout = null;
  });

  // Cancel the clickToRenameTimeout also on mousedown anywhere else
  document.body.addEventListener('mousedown', function () {
    if (clickToRenameTimeout) {
      clearTimeout(clickToRenameTimeout);
      clickToRenameTimeout = null;
    }
  });

  $('#menu-wrapper').delegate('click', '.item.playlist button', function (evt) {
    evt.preventDefault();
    live('spotify:player').emit('pause');
  });

  $('#menu-playlists').delegate('keydown', '.edit', function (evt, elem) {
    var uri = elem.parent().parent().data('uri');
    var rowUri = util.getRowUri(uri);

    if (!uri || !rowUri || !live(rowUri).get('renaming')) {
      return;
    }

    if (evt.keyCode === Keyboard.KEYS.ENTER && elem.value()) {
      live(uri).publish({
        name: elem.value()
      });
    }

    if (evt.keyCode === Keyboard.KEYS.ENTER || evt.keyCode === Keyboard.KEYS.ESCAPE) {
      live(rowUri).update({
        renaming: false
      });
    }
  });

  $('#menu-playlists').delegate('focusout', '.edit', function (evt, elem) {
    if (elem[0] === inputBeingMoved) {
      return;
    }

    var isOpeningAnnotateForm = evt.relatedTarget && $(evt.relatedTarget).matches('.annotate-hint-button');

    var uri = elem.parent().parent().data('uri');
    var rowUri = util.getRowUri(uri);
    var changed;

    if (!uri || !rowUri || !live(rowUri).get('renaming')) {
      return;
    }

    var name = elem.value();
    var prevName = live(uri).get('name');

    var defaultPlaylistText = _('new_playlist.input_placeholder');
    var defaultFolderText = _('playlist.newfolder');

    if (rowUri === NEW_PLAYLIST_URI && name === defaultPlaylistText) {
      changed = false;
    } else if (rowUri === NEW_FOLDER_URI && name === defaultFolderText) {
      changed = false;
    } else {
      changed = name !== prevName;
    }

    // If losing focus due to opening annotate form, don't create playlist.
    if (changed && !isOpeningAnnotateForm) {
      live(uri).publish({
        name: name
      });
    }
    live(rowUri).update({ 'renaming': false });
  });
  playerEvents.update();

  // Subscribe to row updates after we have fetched the initial rows (so that
  // we don't get updates for the initial rows).
  var model = live('spotify:rootlist');
  model.get('loaded', 'rows', function (error, loaded, rowsList) {
    if (loaded && rowsList) {
      live.subscribe(ROW_REGEXP, 'update', function (playlistLiveModel, props) {
        if (/:end$/.test(playlistLiveModel.uri)) {
          return;
        }

        var rowUri = playlistLiveModel.uri;
        var uri = util.getRealUri(rowUri);
        var rowElement = $('#menu-wrapper .item[data-uri="' + uri + '"]');
        var menuAccessory;
        var firstChild;

        if (!rowElement) return;

        if ('icon' in props) {
          // change one of the classes of the menu-accesory element, which looks
          // like: spoticon-{{icon}}-16
          menuAccessory = rowElement[0].querySelector('.menu-accessory');
          menuAccessory.className = menuAccessory.className.replace(/spoticon-([a-z0-9\-]+)-16/i, 'spoticon-' + props.icon + '-16');
        }

        if ('depth' in props) {
          // change the class of the main div of the row, which looks like
          // indent-{{depth}}
          firstChild = rowElement[0].firstElementChild;
          if (firstChild) {
            firstChild.className = firstChild.className.replace(/indent-([0-9]+)/i, 'indent-' + Math.min(props.depth, 5));
          }
        }

        var shouldRender = false;
        if ('hidden' in props) shouldRender = true;
        if ('active' in props) shouldRender = true;
        if ('renaming' in props) shouldRender = true;

        if (shouldRender) {
          renderRow(rowUri, rowElement[0]);
        } else {
          // We need to toggle this class manually, without a full re-render,
          // as the change of this class name will trigger an animation of the
          // folder arrow.
          if ('expanded' in props) {
            rowElement.toggleClass('expanded', props.expanded);
          }
        }

        if (props.hidden === false) {
          if (playlistLiveModel.get('renaming') && !util.annotateHandlesEdit(uri)) {
            // if we are just showing an element which is being renamed,
            // focus the cursor on it
            selectEditText(rowElement[0]);
          }

          if (playlistLiveModel.get('deleting')) {
            // if we are just showing an element in deleting state,
            // active the deleting state (scroll to row, show confirmation box)
            deletePlaylist(uri);
          }
        }

        if ('deleting' in props && props.deleting) {
          deletePlaylist(uri);
        }
      });

      live.subscribe(FOLDER_REGEXP, 'update', function (model, props) {
        var uri = model.get('uri');
        var rowUri = util.getRowUri(uri);
        if (!rowUri) return;

        var elem = $('#menu-wrapper .item[data-uri="' + uri + '"]');

        if (!elem) {
          return;
        }

        if ('name' in props) {
          renderRow(rowUri, elem[0]);
        }
      });

      live.subscribe(PLAYLIST_REGEXP, 'update', function (model, props) {
        var uri = model.uri;

        var elem = $('#menu-wrapper .item[data-uri="' + uri + '"]');

        if (!elem) {
          return;
        }

        if ('offlineProgress' in props && props.offlineProgress) {
          updateProgressCanvas(elem[0], uri, props.offlineProgress);
        }

        var shouldRender = false;
        if ('name' in props && props.name) shouldRender = true;
        if ('owner' in props) shouldRender = true;
        if ('allows' in props) shouldRender = true;
        if ('collaborative' in props) shouldRender = true;
        if ('shouldBeOffline' in props) shouldRender = true;
        if ('offlineStatus' in props) shouldRender = true;

        var rowUri = util.getRowUri(uri);
        if (!rowUri) return;

        if (shouldRender) {
          renderRow(rowUri, elem[0]);
        }
      });

      live.subscribe(USER_REGEXP, 'update', function (model, props) {
        if ('name' in props && props.name) {
          var uri = model.uri;
          var nodes = $('#menu-playlists .item[data-uri^="' + uri + ':"]');
          if (!nodes) return;

          for (var i = 0, l = nodes.length; i < l; i++) {
            var node = nodes[i];
            var playlistUri = node.getAttribute('data-uri');
            var rowUri = util.getRowUri(playlistUri);

            if (rowUri) {
              renderRow(rowUri, node);
            }
          }
        }
      });
    }
  });

  eventsCenter.on('dragover-long', function (event) {
    var uri = event.node.parentNode.getAttribute('data-uri');
    if (!uri) return;
    if (util.isFolder(uri)) {
      var rowUri = util.getRowUri(uri);
      var row = live(rowUri);
      if (!row.get('expanded')) {
        row.publish({ expanded: true });
      }
    } else if (util.isPlaylist(uri)) {
      eventDispatcher.dispatchEvent(new Event(Event.TYPES.NAVIGATION_OPEN_URI, uri));
    }
  });

  eventsCenter.on('drop', function (event) {
    var uri = event.node.getAttribute('data-uri');
    if (!uri) return;
    if (util.isFolder(uri)) {
      var rowUri = util.getRowUri(uri);
      var row = live(rowUri);
      if (!row.get('expanded')) {
        row.publish({ expanded: true });
      }
    }
  });

  var listOfPlaylists = document.getElementById('menu-playlists');
  listOfPlaylists.setAttribute('data-list', '');
  listOfPlaylists.setAttribute('data-uri', 'spotify:rootlist');
  var mimeTypes = 'text/x-spotify-playlists|text/x-spotify-folders';
  listOfPlaylists.setAttribute('data-drop-target', mimeTypes);

  subscribeToRootlistRows();
};

function subscribeToRootlistRows() {
  var parent = document.getElementById('menu-playlists');

  rootlistModel.getRows(function (err, rows) {
    if (err) {
      setTimeout(subscribeToRootlistRows, RETRY_TIME);
      return;
    }

    if (!parent) {
      console.warn('no element with id #menu-playlists found. ' + 'Cannot update sidebar');
      return;
    }

    insertAndRenderRows(rows, parent, 0);

    events.update(parent);
  });

  var model = live('spotify:rootlist');
  model.get('loaded', 'rows', function (error, loaded, rowsList) {
    if (loaded && rowsList) {
      rowsList.on('update', function (operations) {
        operations.forEach(function (operation) {
          switch (operation.type) {
            case 'remove':
              removePlaylists(operation, parent);
              break;
            case 'insert':
              insertPlaylists(operation, parent);
              break;
            case 'move':
              movePlaylists(operation, parent);
              break;
            default:
            // noop
          }
        });
      });
    }
  });
}

function renderOfflineProgressIfApplicable(playlist, renderOfflineProgress) {
  var isOffliningAndHasProgress = playlist && typeof playlist.offlineProgress === 'number' && playlist.offlineProgress > 0 && playlist.offlineProgress < 1;

  if (isOffliningAndHasProgress) {
    renderOfflineProgress(playlist.uri, playlist.offlineProgress);
  }
}

/**
 * Export public interface
 */
module.exports = {
  init: init,
  // Expose methods for testing
  _renderOfflineProgressIfApplicable: renderOfflineProgressIfApplicable
};

},{"../../../../libs/spotify-elements":259,"../../../../libs/spotify-event-dispatcher":264,"../../../../libs/spotify-events":281,"../../../../libs/spotify-events/center":268,"../../../../libs/spotify-events/player":288,"../../../../libs/spotify-glue-cat":348,"../../../../libs/spotify-handlebars":367,"../../../../libs/spotify-handlebars/helpers":358,"../../../../libs/spotify-live":439,"../../../../libs/spotify-logger/messages/UIInteraction4":452,"../../i18n":11,"../../templates/sidebar/playlist.hbs":177,"../components/delete-playlist-dialog":61,"../event":77,"../keyboard":83,"../live-models/uris":90,"../live-models/util":91,"../models/rootlist":105,"../utils/focusable":123,"./circular-loader":30,"./delete-playlist":62,"./playlists-css-class":65,"./playlists-icon":66,"spotify-cosmos-api":694,"spotify-deferred":699}],68:[function(require,module,exports){
'use strict';

var ko = require('knockout');
var eventDispatcher = require('../../../../libs/spotify-event-dispatcher');
var Event = require('../event');

/**
 * View model for the progress bar
 */
function ProgressBar(id, element) {
  this.id = id;
  this.element = element || document.getElementById(id);
  this.visible = ko.observable(true);
  this.enabled = ko.observable(true);
  this.progress = ko.observable(0);
  this.remaining = ko.pureComputed(function () {
    return Math.max(1 - this.progress(), 0) * 100 + '%';
  }, this);
  this.dragging = false;
  this.thumb = new Thumb(this);

  this.onMouseDown = this.onMouseDown.bind(this);
  this.onMouseWheel = this.onMouseWheel.bind(this);
}

ProgressBar.prototype.left = function () {
  return this.element.offsetLeft + this.element.parentNode.offsetLeft;
};

ProgressBar.prototype.width = function () {
  return this.element.offsetWidth;
};

/**
 * Callback for when the progress bar is being clicked
 *
 * @param {ViewModel} model The view model that triggered the event.
 * @param {MouseEvent} e The event triggered.
 */
ProgressBar.prototype.onMouseDown = function (model, e) {
  if (!this.enabled()) return;
  this.thumb.onDragStart(e);
};

/**
 * Callback for when the mouse wheel is being used
 *
 * @param {ViewModel} model The view model that triggered the event.
 * @param {WheelEvent} e The event triggered.
 */
ProgressBar.prototype.onMouseWheel = function (model, e) {
  if (!this.enabled()) return;
  e.preventDefault();
  var delta = Math.max(-120, Math.min(120, e.wheelDelta)) / 1200;
  var progress = Math.max(0, Math.min(1, this.progress() + delta));
  this.progress(progress);
  eventDispatcher.dispatchEvent(new Event(Event.TYPES.UI_DRAG_END, {
    progressBarId: this.id,
    progress: progress
  }));
};

/**
 * THUMB
 */
function Thumb(progressbar) {
  this.progressbar = progressbar;
  this.active = ko.observable(false);

  // Bind event listeners to correct context
  this.onDragStart = this.onDragStart.bind(this);
  this.onDrag = this.onDrag.bind(this);
  this.onDragEnd = this.onDragEnd.bind(this);
}

Thumb.prototype._isMouseLeftClick = function (evt) {
  var leftClick = false;

  if ('buttons' in evt) {
    leftClick = evt.buttons === 1;
  } else if ('which' in evt) {
    leftClick = evt.which === 1;
  } else if ('button' in evt) {
    leftClick = evt.button === 1;
  }

  return leftClick;
};

/**
 * Callback for when the thumb has started to be dragged.
 *
 * @param {ViewModel?} model Optional view model that triggered the event.
 * @param {MouseEvent} e The event triggered.
 */
Thumb.prototype.onDragStart = function (model, e) {
  if (arguments.length === 1) e = model;
  if (!this.progressbar.enabled() || !this._isMouseLeftClick(e) && e.type !== 'touchstart') return;

  e.preventDefault();
  this.progressbar.dragging = true;
  this.active(true);
  window.addEventListener('mouseup', this.onDragEnd);
  window.addEventListener('mousemove', this.onDrag);
  window.addEventListener('touchend', this.onDragEnd);
  window.addEventListener('touchmove', this.onDrag);
  this.onDrag(e);
};

Thumb.prototype.position = function () {
  return this.progressbar.progress() * this.progressbar.width() + this.progressbar.left();
};

Thumb.prototype.onDrag = function (e) {
  if (!this.progressbar.enabled()) return;
  e.preventDefault();

  var progress;
  var x;
  if (e.type === 'touchmove' || e.type === 'touchstart') {
    x = Math.round(e.changedTouches[0].pageX);
  } else {
    x = e.pageX;
  }

  if (x < this.progressbar.left()) {
    progress = 0;
  } else if (x > this.progressbar.left() + this.progressbar.width()) {
    progress = 1;
  } else {
    progress = (x - this.progressbar.left()) / this.progressbar.width();
  }
  this.progressbar.progress(progress);
  eventDispatcher.dispatchEvent(new Event(Event.TYPES.UI_DRAG, {
    progressBarId: this.progressbar.id,
    progress: progress
  }));
};

Thumb.prototype.onDragEnd = function (e) {
  if (!this.progressbar.enabled()) return;
  e.preventDefault();
  this.active(false);
  this.progressbar.dragging = false;
  eventDispatcher.dispatchEvent(new Event(Event.TYPES.UI_DRAG_END, {
    progressBarId: this.progressbar.id,
    progress: this.progressbar.progress()
  }));

  window.removeEventListener('mouseup', this.onDragEnd);
  window.removeEventListener('mousemove', this.onDrag);
  window.removeEventListener('touchend', this.onDragEnd);
  window.removeEventListener('touchmove', this.onDrag);
};

module.exports = ProgressBar;

},{"../../../../libs/spotify-event-dispatcher":264,"../event":77,"knockout":567}],69:[function(require,module,exports){
'use strict';

var ko = require('knockout');
var _ = require('../../i18n').get;
var eventDispatcher = require('../../../../libs/spotify-event-dispatcher');
var EventTypes = require('../event').TYPES;

/**
 * View model that listens for connectHelper changes and
 * shows/hides the remote playback bar in the bottom of the player
 */
function RemotePlaybackBar() {
  var self = this;
  this.message = ko.observable('');
  this.visible = ko.observable(false);
  this.rightMargin = ko.observable(0);

  this.updateArrowAlign = function () {
    var icon = document.getElementById('devices-icon');
    var bar = document.getElementById('remote-playback-bar');
    // = bar total lenght - icon position - start offset left - icon radius
    var rightMargin = bar.clientWidth - icon.offsetLeft - 190 - 24;
    self.rightMargin(rightMargin + 'px');
  };

  this.visible.subscribe(function (visible) {
    if (visible) {
      document.body.classList.add(RemotePlaybackBar.ACTIVE_CSS_CLASS);
    } else {
      document.body.classList.remove(RemotePlaybackBar.ACTIVE_CSS_CLASS);
    }
  });

  eventDispatcher.addEventListener(EventTypes.SPCONNECT_DEVICE_STATE, function (e) {
    var devices = e.params.devices;
    var local = true;
    var deviceName;

    for (var i = 0; i < devices.length; i++) {
      var device = devices[i];
      if (device.active) {
        if (device.id !== '') {
          deviceName = device.name;
          local = false;
        }
      }
    }
    self.visible(!local);
    self.message(local ? '' : _('connect.remoteplayback', deviceName));
    self.updateArrowAlign();
  });
}

/**
 * Class applied to the body element when visible.
 *
 * @type {String}
 */
RemotePlaybackBar.ACTIVE_CSS_CLASS = 'remotebar';

module.exports = RemotePlaybackBar;

},{"../../../../libs/spotify-event-dispatcher":264,"../../i18n":11,"../event":77,"knockout":567}],70:[function(require,module,exports){
(function (global){
'use strict';

var R = require('ramda');
var VideoTakeoverAd = require('../../../../libs/spotify-ad-formats').VideoTakeoverAd;

// cosmos endpoints
var URL_VOLUME = 'sp://playback/v1/volume';
var URL_SUBSCRIBE = 'sp://videoplayer/v1/commands';
var URL_ADVANCE = 'sp://videoplayer/v1/advance';
var URL_STATE = 'sp://videoplayer/v1/state';
var URL_ERROR = 'sp://videoplayer/v1/error';

var TEMPLATE_MANIFEST_URL = 'video-manifest-url';
var STREAMING_TYPE = 'dash+webm';

// state
var _isAd = false;
var _videoManager = null; // the video manager instance
var _webgateManager = null; // the webgate token manager instance
var _cosmos = null; // the active cosmos instance
var _videoSub = null; // the video subscription
var _volumeSub = null; // the volume subscription
var _lastVolume = 1; // the last volume seen
var _subscribedToCP = false; // whether cosmos was subscribed to
var _handlers = null; // the registered command handlers
var _playerID = null; // the current player ID
var _lastPlayerState = null; // the last-received player state
var _videoTrack = null; // the current video track
var _viewModel = null; // the view model owning the video surfaces

// helper for safely navigating json
function dig() {
  var args = Array.prototype.slice.call(arguments);
  var obj = args.shift();
  var arg = args.shift();
  while (obj && arg) {
    obj = obj[arg];
    arg = args.shift();
  }
  return obj;
}

function vlog() {
  // console.log.apply(console, arguments);
}

function manifestUrlForSourceID(sourceID) {
  return global.__spotify.product_state[TEMPLATE_MANIFEST_URL].replace(/\{type\}/i, STREAMING_TYPE).replace(/\{source_id\}/i, encodeURIComponent(sourceID));
}

function backendErrorToContextPlayerError(err) {
  if (!err || !err.responseText && !err.httpStatus) {
    return null;
  }

  if (err.httpStatus === 401) {
    return { type: 'video_playback_error' };
  }

  var response;
  try {
    response = JSON.parse(err.responseText);
  } catch (e) {
    // nop
  }

  switch (response.reason) {
    case 'GEO_RESTRICTED':
      return { type: 'video_georestricted' };
    case 'UNSUPPORTED_CLIENT_VERSION':
      return { type: 'video_unsupported_client_version' };
    case 'UNSUPPORTED_PLATFORM_VERSION':
      return { type: 'video_unsupported_platform_version' };
    case 'COUNTRY_RESTRICTED':
      return { type: 'video_country_restricted' };
    case 'UNAVAILABLE':
      return { type: 'video_unavailable' };
    case 'CATALOGUE_RESTRICTED':
      return { type: 'video_catalogue_restricted' };
    default:
      return { type: 'unknown' };
  }
}

// Public API

var VCM = {};

VCM.setup = function (viewModel, cosmos, videoMgr, webgateMgr) {
  _videoManager = videoMgr || require('../../../../libs/spotify-video-manager');
  _webgateManager = webgateMgr || require('./webgate-token-manager');
  _viewModel = viewModel;

  // don't setup with same cosmos instance
  cosmos = cosmos || require('spotify-cosmos-api');
  if (_subscribedToCP && _cosmos === cosmos) {
    return;
  }

  // clean up
  VCM.teardown();
  _cosmos = cosmos;

  // map message types to handler functions
  if (!_handlers) {
    _handlers = {
      'subscribed': VCM._didSubscribe,
      'start': VCM._start,
      'stop': VCM._stop,
      'pause': VCM._pause,
      'resume': VCM._resume,
      'seek_to': VCM._seekTo,
      'prefetch_tracks': VCM._prefetchTracks
    };
  }

  // subscribe to CP events
  _videoSub = _cosmos.resolver.subscribe(URL_SUBSCRIBE, function (err, res) {
    if (err) {
      vlog('VCM Error:', err);
    } else {
      var payload = res.getJSONBody() || {};
      var type = payload.type;
      var handler = _handlers[type];
      if (handler) {
        vlog('VCM: Received Command', payload); // TODO(dflems): remove me
        handler(payload);
      } else {
        vlog('VCM Error: Unknown Message Type: ' + type);
      }
    }
  });

  // subscribe to volume events
  _volumeSub = _cosmos.resolver.subscribe(URL_VOLUME, function (err, res) {
    var data = res && res.getJSONBody();
    if (R.type(data.volume) === 'Number') {
      VCM._volumeChanged(data.volume);
    }
  });
};

VCM.teardown = function () {
  // increment the subscription index so the previous handler will unsubscribe
  if (_cosmos) {
    _cosmos = null;
  }
  if (_videoSub) {
    _videoSub.cancel();
  }
  if (_volumeSub) {
    _volumeSub.cancel();
  }
  _subscribedToCP = false;
};

// Handlers

VCM._start = function (payload) {
  VCM._unloadCurrentVideo(payload.start_reason);

  _webgateManager.promise().then(function () /* mgr */{
    VCM._startAuthenticated(payload);
  }).catch(function (e) {
    vlog('ERROR: ' + e);
  });
};

VCM._startAuthenticated = function (payload) {
  // validate that track is a video
  var track = dig(payload, 'track', 'track');
  if (dig(track, 'metadata', 'media.type') !== 'video') {
    VCM._postTrackUnplayable('not-a-video');
    return;
  }

  _isAd = payload.track.track.provider === 'ad';

  // validate that track has playable content
  var sourceURL = null;
  var sourceID = dig(track, 'metadata', 'media.manifest_id');
  var videoType = null;
  if (sourceID) {
    sourceURL = manifestUrlForSourceID(sourceID);
    videoType = 'dash';
  } else if (_isAd) {
    try {
      var adVideos = JSON.parse(track.metadata['media.manifest']);
      sourceURL = VideoTakeoverAd.getPreferredVideo(adVideos);
    } catch (e) {
      sourceURL = dig(track, 'metadata', 'media.manifest', 'url');
    }
  } else {
    sourceURL = dig(track, 'metadata', 'media.manifest', 'url');
  }
  if (!sourceURL) {
    VCM._postTrackUnplayable('no-source-url');
    return;
  }

  // get ready to play
  var position = (payload.seek_to || 0) / 1000.0;
  var startPaused = payload.initially_paused || false;
  _videoTrack = payload.track;
  var startFullwindow = !startPaused;

  // create video node
  var node = document.createElement('video');

  // create the video
  vlog('VCM: Playing ' + sourceURL);
  _playerID = _videoManager.createVideo(node, {
    'volume': _lastVolume,
    'position': position,
    'startPaused': startPaused,
    'url': sourceURL,
    'type': videoType,
    'networkCallback': _webgateManager.shakaNetworkCallback,
    'fileId': sourceID,
    'playbackID': dig(_videoTrack, ['playback_id'], ''),
    'track_uri': dig(_videoTrack, ['track'], ['uri'], ''),
    'provider': dig(_videoTrack, ['provider'], ''),
    'playOrigin': dig(_videoTrack, ['play_origin'], ''),
    'startReason': payload.start_reason || 'unknown',
    'videoTrackerFactory': _videoManager.createEndVideoTracker
  });

  _videoManager.subscribe(_playerID, VCM._playerStateChanged);

  if (_isAd) {
    var currentPlayerId = _playerID;
    VideoTakeoverAd.playBetamaxVideo({
      adId: _videoTrack.track.metadata.ad_id,
      videoEl: node,
      onDestroyed: function onDestroyed() {
        if (currentPlayerId === _playerID) VCM._trackDidFinish();
      }
    });
  } else {
    _viewModel.attachVideoElement(node, startFullwindow);
  }
};

VCM._stop = function () {
  VCM._unloadCurrentVideo('endplay');
};

VCM._pause = function () {
  if (_playerID) {
    _videoManager.pause(_playerID);
  }
};

VCM._resume = function () {
  if (_playerID) {
    _videoManager.play(_playerID);
  }
};

VCM._seekTo = function (payload) {
  if (_playerID) {
    var posMS = payload.position || 0;
    _videoManager.seekTo(_playerID, posMS / 1000.0);
  }
};

VCM._prefetchTracks = function () /* payload */{
  // TODO: do track prefetch
};

VCM._didSubscribe = function () {
  _subscribedToCP = true;
  vlog('VCM: Subscribed to ContextPlayer events');
};

// Helpers

VCM._volumeChanged = function (vol) {
  _lastVolume = vol;
  if (_playerID) {
    _videoManager.setPlayerVolume(_playerID, vol);
  }
};

VCM._playerStateChanged = function (err, prevState, newState) {
  var videoError = backendErrorToContextPlayerError(err);
  if (videoError) {
    VCM._postMessageToEndpoint(URL_ERROR, videoError, null);
  }

  var hasDuration = (dig(newState, 'duration') || -1) > 0;
  var hasCurrentTime = (dig(newState, 'currentTime') || -1) >= 0;
  if (!newState || !hasDuration || !hasCurrentTime) {
    // Ignore (initial) new states where duration and current position is
    // undefined
    return;
  }

  // pick fields and compare against last state
  var changeFields = R.pick(['isPlaying', 'isPaused', 'isBuffering', 'isEnded', 'isError', 'isSeeking', 'duration'], newState);
  if (R.equals(changeFields, _lastPlayerState)) {
    return;
  }
  _lastPlayerState = changeFields;

  // post state update
  VCM._postStateUpdate(newState);

  if (newState.isEnded && !_isAd) {
    VCM._trackDidFinish();
  }
};

VCM._postStateUpdate = function (state) {
  if (!_videoTrack) {
    return;
  }

  var playbackID = dig(_videoTrack, 'playback_id') || '';
  var isPlaying = dig(state, 'isPlaying') || false;
  var isPaused = dig(state, 'isPaused');
  var isBuffering = dig(state, 'isBuffering') || false;

  var toSend = {
    'playback_id': playbackID,
    'is_paused': isPaused,
    'is_buffering': isBuffering,
    'timestamp': new Date().getTime(), // ms
    'playback_speed': isPlaying ? 1 : 0
  };

  var duration = dig(state, 'duration') || -1;
  if (duration > 0) {
    toSend.duration = Math.floor(duration * 1000);
  }

  var position = dig(state, 'currentTime') || -1;
  if (position > -1) {
    toSend.position_as_of_timestamp = Math.floor(position * 1000);
  }

  VCM._postMessageToEndpoint(URL_STATE, toSend, null);
};

VCM._advance = function (payload) {
  VCM._unloadCurrentVideo(payload.reason);
  VCM._postMessageToEndpoint(URL_ADVANCE, payload, null);
};

VCM._postTrackUnplayable = function (reason) {
  var payload = { 'reason': 'unplayable' };
  if (reason) {
    payload.unplayable_reason = reason;
  }
  VCM._advance(payload);
};

VCM._trackDidFinish = function () {
  VCM._advance({ 'reason': 'finished' });
};

VCM._postMessageToEndpoint = function (endpoint, message, cb) {
  var request = new _cosmos.Request('POST', endpoint, {}, message);
  _cosmos.resolver.resolve(request, cb);
};

VCM._unloadCurrentVideo = function (reason) {
  _videoTrack = null;
  _lastPlayerState = null;
  if (_playerID) {
    _videoManager.unsubscribe(_playerID, VCM._playerStateChanged);
    _videoManager.destroy(_playerID, true, reason);
    _playerID = null;
  }
  _viewModel.detachVideoElement();
};

// Export
module.exports = VCM;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../../../libs/spotify-ad-formats":203,"../../../../libs/spotify-video-manager":493,"./webgate-token-manager":71,"ramda":683,"spotify-cosmos-api":694}],71:[function(require,module,exports){
'use strict';

var cosmos = require('spotify-cosmos-api');

var KEYMASTER_URL = 'hm://keymaster/token/authenticated?' + ['client_id=65b708073fc0480ea92a077233ca87bd', 'scope=playlist-read'].join('&');

var currentPromise = null;
var currentToken = null;
var currentTokenType = null;
var expiresAt = 0;

var MGR = {};

MGR.getAuthorizationHeader = function () {
  MGR.expireIfNecessary();
  if (currentToken && currentTokenType) {
    return currentTokenType + ' ' + currentToken;
  }
  return null;
};

MGR.promise = function () {
  MGR.expireIfNecessary();
  if (!currentPromise) {
    var request = new cosmos.Request('GET', KEYMASTER_URL, {});
    var reqTime = new Date().getTime();

    currentPromise = new Promise(function (resolve, reject) {
      cosmos.resolver.resolve(request, function (err, res) {
        if (err) {
          reject(err);
          return;
        }
        var body = res.getJSONBody() || {};
        if (body.accessToken && body.expiresIn && body.tokenType) {
          currentToken = body.accessToken;
          currentTokenType = body.tokenType;
          expiresAt = reqTime + body.expiresIn * 1000;
          resolve(MGR);
        } else {
          reject('missing token info');
        }
      });
    });
  }
  return currentPromise;
};

MGR.expireIfNecessary = function () {
  if (!currentToken || expiresAt <= new Date().getTime()) {
    MGR.reset();
  }
};

MGR.reset = function () {
  currentPromise = null;
  currentToken = null;
  currentTokenType = null;
  expiresAt = 0;
};

MGR.isWebgateURL = function (url) {
  return url && url.startsWith('https://spclient.wg.spotify.com');
};

MGR.shakaNetworkCallback = function (url, headers) {
  if (MGR.isWebgateURL(url)) {
    var auth = MGR.getAuthorizationHeader();
    if (auth) {
      headers.Authorization = auth;
    }
  }
  return url;
};

// for testing purposes
MGR.setCosmos = function (aCosmos) {
  cosmos = aCosmos;
};

module.exports = MGR;

},{"spotify-cosmos-api":694}],72:[function(require,module,exports){
'use strict';

var eventDispatcher = require('../../../libs/spotify-event-dispatcher');
var ConnectDevice = require('./components/connect_device');
var Event = require('./event');
var Gaia = require('spotify-gaia');
var Cosmos = require('spotify-cosmos-api');
var i18n = require('./../i18n').get;

function ConnectHelper() {
  this._currentDevicesList = [];
}

ConnectHelper.prototype.setup = function () {
  this.cosmos = Cosmos;
  this.gaia = new Gaia.v1.Gaia(this.cosmos.resolver, 'gaia');
  this.defaultOnError = function (error, response) {
    if (error) {
      console.log(response);
    }
  };

  var self = this;
  this.gaia.subscribe(function (error, msg) {
    var response = msg.getJSONBody();
    if (response) {
      self._populateDevicesList(response);
    }
  });

  // Discover all devices
  this.scan();
};

ConnectHelper.prototype.scan = function () {
  this.gaia.discover('all', this.defaultOnError);
};

/**
 * Creates the list of devices detected
 * The order of the list goes from the most recent detected one
 * to the least recent one
 * @param  {Object} response The response including the devices
 */
ConnectHelper.prototype._populateDevicesList = function (response) {
  var self = this;
  var detectedDevices = response.devices || [];

  var shown = detectedDevices.filter(function (device) {
    var state = device.state || '';
    if (state === 'incompatible') {
      return false;
    }
    if (state === 'unsupported_uri') {
      return false;
    }
    return true;
  });

  var activeDevice = shown.find(function (dev) {
    return dev.is_active;
  });

  if (activeDevice) {
    self.gaia.attach(activeDevice.identifier, self.defaultOnError);
  }

  // Add local device first
  shown.unshift({
    'identifier': '',
    'type': 'local',
    'name': i18n('connect.device_this_computer'),
    'is_active': response.is_active || !activeDevice,
    'is_running': response.is_running,
    'is_online': true,
    'is_zeroconf': false,
    'can_play': true,
    'supports_volume': true
  });

  var devices = shown.map(function (dev) {
    return new ConnectDevice(dev);
  });

  // Something changed in the devices list, trigger an event
  if (JSON.stringify(this._currentDevicesList) !== JSON.stringify(devices)) {
    this._currentDevicesList = devices;
    eventDispatcher.dispatchEvent(new Event(Event.TYPES.SPCONNECT_DEVICE_STATE, { devices: devices }));
  }
};

ConnectHelper.prototype.transferPlayback = function (deviceid) {
  if (deviceid) {
    this.gaia.transferPlayback(deviceid, this.defaultOnError);
  } else {
    this.gaia.pullPlayback(this.defaultOnError);
  }
};

ConnectHelper.prototype.isActiveDeviceVolumeCapable = function () {
  var active = this._currentDevicesList.find(function (device) {
    return device.active;
  });
  if (active) {
    return active.supports_volume;
  }
  return true;
};

module.exports = ConnectHelper;

},{"../../../libs/spotify-event-dispatcher":264,"./../i18n":11,"./components/connect_device":31,"./event":77,"spotify-cosmos-api":694,"spotify-gaia":701}],73:[function(require,module,exports){
'use strict';

var CosmosMessagesHandler = require('./cosmosmessageshandler');
var Event = require('./event');
var utils = require('./utils');

/**
 * Handles cosmos messages coming from the
 * sp://offline/v1/connection endpoint
 * to monitor connection state and triggers ConnectionStateChangeEvent
 * when such state change: online <-> offline
 *
 * @property {number} offlineTimeout Number of milliseconds to wait until
 *     completely trust the given connection status and show error messages.
 */
function ConnectionMonitor() {
  CosmosMessagesHandler.apply(this, arguments);

  this.offlineTimeout = 15000;
}

utils.inherit(ConnectionMonitor, CosmosMessagesHandler);

ConnectionMonitor.prototype.setup = function () {
  this.init('sp://offline/v1/connection');
};

ConnectionMonitor.prototype.buildEvent = function (msg) {
  var connection = msg.getJSONBody().connection;
  return new Event(Event.TYPES.CONNECTION_STATE_CHANGE, connection);
};

ConnectionMonitor.prototype.setForceOffline = function (value) {
  this.put({
    connection: {
      force_offline: value
    }
  });
};

module.exports = new ConnectionMonitor();

},{"./cosmosmessageshandler":75,"./event":77,"./utils":120}],74:[function(require,module,exports){
'use strict';

var CosmosMessagesHandler = require('./cosmosmessageshandler');
var Event = require('./event');
var utils = require('./utils');

/**
 * Handles cosmos messages coming from the
 * sp://messages/v1/container/control endpoint
 * and triggers a ControlMessageEvent when such messages are
 * received
 */

function ControlMessagesHandler() {
  CosmosMessagesHandler.apply(this, arguments);
}

utils.inherit(ControlMessagesHandler, CosmosMessagesHandler);

ControlMessagesHandler.prototype.setup = function () {
  this.init('sp://messages/v1/container/control');
};

ControlMessagesHandler.prototype.buildEvent = function (msg) {
  var e = msg.getJSONBody();
  return new Event(e.type, e.data);
};

module.exports = new ControlMessagesHandler();

},{"./cosmosmessageshandler":75,"./event":77,"./utils":120}],75:[function(require,module,exports){
'use strict';

var cosmos = require('spotify-cosmos-api');
var eventDispatcher = require('../../../libs/spotify-event-dispatcher');

function CosmosMessagesHandler() {}

CosmosMessagesHandler.prototype.init = function (endpoint) {
  this._endpoint = endpoint;
  var self = this;
  cosmos.resolver.subscribe(endpoint, function (err, msg) {
    if (!err) {
      eventDispatcher.dispatchEvent(self.buildEvent(msg));
    }
  });
};

/**
 * Different cosmos endpoints have different message formats,
 * so the way this message should be transformed into an event
 * is up to the listener
 */
CosmosMessagesHandler.prototype.buildEvent = function () {
  // JS doesn't have abstract methods, deal with it
  throw new Error('THIS SHOULD BE IMPLEMENTED BY THE SUBCLASS');
};

CosmosMessagesHandler.prototype.send = function (body) {
  cosmos.resolver.post({
    url: this._endpoint,
    body: body
  });
};

CosmosMessagesHandler.prototype.put = function (body) {
  cosmos.resolver._resolveFromParams(cosmos.Action.PUT, {
    url: this._endpoint,
    body: body
  });
};

module.exports = CosmosMessagesHandler;

},{"../../../libs/spotify-event-dispatcher":264,"spotify-cosmos-api":694}],76:[function(require,module,exports){
'use strict';

var cosmos = require('spotify-cosmos-api');

module.exports = {
  DEPRECATION_FLAG: 'client-deprecated',

  DEPRECATION_COUNT: 'client-deprecated-count',

  DEPRECATED: '2',

  setup: function setup(localSettings) {
    this._localSettings = localSettings;
    this._check();
  },

  _check: function _check() {
    var count = +this._localSettings.get(this.DEPRECATION_COUNT);

    if (count < 2) {
      this._request();
      this._localSettings.set(this.DEPRECATION_COUNT, count + 1);
    }
  },

  _request: function _request() {
    var flag = this.DEPRECATION_FLAG;

    if (window.__spotify && window.__spotify.product_state && window.__spotify.product_state[flag] === this.DEPRECATED) {
      cosmos.resolver.post({
        url: 'sp://messages/v1/container/user-message',
        body: {
          'id': 'deprecating-os-version'
        }
      }, function () {
        // Fire and forget.
      });
    }
  }
};

},{"spotify-cosmos-api":694}],77:[function(require,module,exports){
/**
 * @param {String} type The event type.
 * @param {Object} params Parameters to send with the event.
 * @param {Object} extra Extra stuff to send.
 */
'use strict';

var Event = function Event(type, params, extra) {
  if (!type) {
    throw new Error('An event type needs to be specified');
  }
  /**
   * The event type
   *
   * @type {String}
   */
  this.type = type;

  /**
   * Parameters
   *
   * @type {Object}
   */
  this.params = typeof params === 'undefined' ? {} : params;

  /**
   * Extra stuff to send
   *
   * @type {Object}
   */
  this.extra = extra || {};
};

Event.TYPES = {
  // App notifications
  APP_NOTIFY_LOADED: 'notify_loaded',

  // Connection state notifications
  CONNECTION_STATE_CHANGE: 'connection-state-change',
  CONNECTION_OFFLINE_ERROR: 'offline-error',

  // Window events
  WINDOW_ENTER_FULLSCREEN: 'enter_fullscreen',
  WINDOW_LEAVE_FULLSCREEN: 'leave_fullscreen',

  // Spotify Connect
  SPCONNECT_DEVICE_STATE: 'connectdevice',

  // Social / Facebook
  SOCIAL_ERROR: 'socialerror',

  // Navigation
  NAVIGATION_OPEN_URI: 'open_uri',
  NAVIGATION_LOGOUT: 'logout',
  NAVIGATION_HISTORY_BACK: 'browse_backward',
  NAVIGATION_HISTORY_CHANGE: 'historychange',
  NAVIGATION_HISTORY_FORWARD: 'browse_forward',
  NAVIGATION_HISTORY_GO: 'history_go',
  NAVIGATION_HISTORY_REMOVE: 'history_remove',
  NAVIGATION_STATE_CHANGE: 'statechange',
  NAVIGATION_SHOW_SHARE: 'show_share',
  NAVIGATION_SHOW_ABOUT: 'show_about',
  NAVIGATION_SHOW_FEEDBACK: 'show_feedback',
  NAVIGATION_SHOW_PREFERENCES: 'show_preferences',
  NAVIGATION_SHOW_HELP: 'show_help',
  NAVIGATION_SHOW_COMMUNITY: 'show_community',
  NAVIGATION_SHOW_ACCOUNT: 'show_account',
  NAVIGATION_SHOW_LICENSES: 'show_licenses',
  NAVIGATION_SHOW_LICENSING_INFORMATION: 'show_licensing_information',
  NAVIGATION_SHOW_SCTA_INFORMATION: 'show_scta_information',
  NAVIGATION_SHOW_SEARCH: 'show_search',
  NAVIGATION_SHOW_FULL_SCREEN_MODAL: 'show_full_screen_modal',
  NAVIGATION_SHOW_FIND_FRIENDS: 'show_find_friends',
  NAVIGATION_SHOW_NPS_SURVEY: 'show_nps_survey',
  NAVIGATION_REFRESH_VIEWS: 'refresh-view',
  NAVIGATION_UPGRADE: 'upgrade_premium',

  // Views
  VIEW_LOADED: 'view_loaded',
  VIEW_UNLOADED: 'view_unloaded',

  // Context menu
  CONTEXT_CLIENT_SHOW_UI: 'client_show_context_ui',
  CONTEXT_SHOW_UI: 'show_context_ui',

  // Messages
  MESSAGE_NOTIFICATION: 'notification_message',
  MESSAGE_USER: 'user-message',

  // Player
  PLAYER_EVENT: 'player_event',
  PLAYER_PROGRESS: 'progress',
  PLAYER_SYNC_PROGRESS: 'sync_progress',
  PLAYER_VOLUME: 'volume',
  PLAYER_SEEK: 'seek',
  PLAYER_SHUFFLE: 'set_shuffle',
  PLAYER_REPEAT: 'set_repeat',
  PLAYER_PAUSE: 'pause',
  PLAYER_RESUME: 'resume',
  PLAYER_NEXT: 'skip_to_next',
  PLAYER_PREV: 'skip_to_prev',

  // Ads
  AD_AUDIO_STARTED: 'ad:audio:started',
  AD_AUDIO_FINISHED: 'ad:audio:finished',
  AD_BILLBOARD_STARTED: 'ad:billboard:started',
  AD_BILLBOARD_FINISHED: 'ad:billboard:finished',
  AD_BILLBOARD_DISCARDED: 'ad:billboard:discarded',
  AD_BILLBOARD_VISIBLE: 'ad:billboard:visible',
  AD_BILLBOARD_HIDDEN: 'ad:billboard:hidden',
  AD_BILLBOARD_FOCUS_RECEIVED: 'ad:billboard:focusreceived',
  AD_BILLBOARD_MINIMIZED: 'ad:billboard:minimized',
  AD_VIDEO_STARTED: 'ad:video:started',
  AD_VIDEO_FINISHED: 'ad:video:finished',
  AD_LEADERBOARD_PLACEMENT: 'ad:leaderboard:placement',
  DEBUG_SET_BILLBOARD_TIMEOUT: 'debug:ad:set:billboard_timeout',
  AD_SPONSORSHIP_ACTIVE: 'ad:sponsorship:active',

  AD_CLICK_VIDEO_STARTED: 'ad:clickvideo:started',
  AD_CLICK_VIDEO_ENDED: 'ad:clickvideo:ended',

  AD_LEADERBOARD_ERROR: 'ad:leaderboard:error',

  // UI
  UI_DRAG: 'drag',
  UI_DRAG_END: 'dragend',

  // Application
  APPLICATION_FOCUS_LOST: 'application:focus:lost',
  APPLICATION_FOCUS_GAINED: 'application:focus:gained',
  APPLICATION_INACTIVE: 'application:inactive',

  // Popovers
  POPOVER_OPENED: 'popover:opened',
  POPOVER_CLOSED: 'popover:closed',
  SHOW_YOUR_ARTISTS_TOOLTIP: 'show_your_artists_tooltip',

  // Layout events
  LAYOUT_SIDEBAR_RESIZED: 'layout:sidebar:resized',

  // Playlist control messages
  CONTROL_MESSAGE_DELETE: 'delete',
  CONTROL_MESSAGE_NEW_PLAYLIST: 'create_new_playlist',
  CONTROL_MESSAGE_NEW_FOLDER: 'create_new_folder',
  CONTROL_MESSAGE_UNDO: 'undo_action',

  // Stations
  THUMB_UP: 'thumb-up',
  THUMB_DOWN: 'thumb-down',

  // CAPPING  MESSAGES
  CAPPING_OPEN_UPSELL_MESSAGE: 'capping:open:upsellmessage',
  CAPPING_OPEN_WELCOME_MESSAGE: 'capping:open:welcomemessage'
};

module.exports = Event;

},{}],78:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var eventDispatcher = require('../../../libs/spotify-event-dispatcher');
var Event = require('./event');

var DETECT_CHANGE_INTERVAL_MS = 1000;

/**
 * Dispatches APPLICATION_FOCUS_GAINED and APPLICATION_FOCUS_LOST events when
 * the application gains/looses focus.
 *
 * @constructor
 */
function FocusDetector() {
  this._hadFocus = undefined;
  this._detectChange = this._detectChange.bind(this);
}

/**
 * Start checking for focus changes
 */
FocusDetector.prototype.start = function () {
  this._interval = setInterval(this._detectChange, DETECT_CHANGE_INTERVAL_MS);
};

/**
 * Stop checking for focus changes
 */
FocusDetector.prototype.stop = function () {
  if (_typeof(this._interval) !== undefined) {
    clearInterval(this._interval);
    this._interval = undefined;
  }
};

/**
 * Determine if the application is in focus.
 *
 * @public
 * @return {Boolean}
 */
FocusDetector.prototype.hasFocus = function () {
  return document.hasFocus();
};

/**
 * Detect if the state has changed.
 *
 * @private
 */
FocusDetector.prototype._detectChange = function () {
  var hasFocus = this.hasFocus();
  if (hasFocus !== this._hadFocus) {
    var type = hasFocus ? Event.TYPES.APPLICATION_FOCUS_GAINED : Event.TYPES.APPLICATION_FOCUS_LOST;
    eventDispatcher.dispatchEvent(new Event(type));
  }
  this._hadFocus = hasFocus;
};

module.exports = FocusDetector;

},{"../../../libs/spotify-event-dispatcher":264,"./event":77}],79:[function(require,module,exports){
'use strict';

// The sync bitrate was not changed with the play bitrate. Fixerupper. (KM-6995)

exports.init = function (Preferences) {
  var audioPrefs = new Preferences('audio');

  // See spotify/bitrate/cpp/include/spotify/bitrate/bitrate_types.h
  // in client-core.
  var BIT_RATE_EXTREME = 4;
  var PLAY_BITRATE = 'play_bitrate_enumeration';
  var SYNC_BITRATE = 'sync_bitrate_enumeration';

  audioPrefs.all(function (error, result) {
    if (error) throw error;

    if (result && result.audio && PLAY_BITRATE in result.audio) {
      // We only check the BIT_RATE_EXTREME  case here, since that's the only
      // mismatch that should happen. Checking all possible cases gets
      // complicated.
      if (result.audio[PLAY_BITRATE] === BIT_RATE_EXTREME && result.audio[SYNC_BITRATE] !== BIT_RATE_EXTREME) {
        audioPrefs.set(SYNC_BITRATE, BIT_RATE_EXTREME, function (error) {
          if (error) throw error;
        });
      }
    }
  });
};

},{}],80:[function(require,module,exports){
'use strict';

var $ = require('../../../libs/spotify-elements');
var eventDispatcher = require('../../../libs/spotify-event-dispatcher');
var EventTypes = require('./event').TYPES;
var controlMessagesHandler = require('./controlmessageshandler');
var glue = require('../../../libs/spotify-glue-cat');

var glueVersion = glue.getVersion();

/**
 * Handles generic things in the header, like double clicks and positioning
 * of elements in relation to OS controls and fullscreen mode.
 */
function Header() {
  this.inFullscreen = false;
  this.initialInlineControls = false;
  this.inlineControls = false;

  this._headerElement = null;
}

/**
 * Set up event handlers and update UI state.
 */
Header.prototype.setup = function () {
  if (glueVersion === 2) {
    this._headerElement = document.getElementById('header');
  } else {
    this._headerElement = document.getElementById('header-glue1');

    if (window.__spotify.os && window.__spotify.os.inline_window_controls) {
      this.initialInlineControls = true;
      this.inlineControls = true;
    }

    this._updateHeader();

    eventDispatcher.addEventListener(EventTypes.WINDOW_ENTER_FULLSCREEN, this._onEnterFullscreen.bind(this));

    eventDispatcher.addEventListener(EventTypes.WINDOW_LEAVE_FULLSCREEN, this._onLeaveFullscreen.bind(this));
  }

  this._headerElement.addEventListener('dblclick', this._onDoubleClick.bind(this), false);
};

/**
 * Update the header to adjust for the current mode.
 */
Header.prototype._updateHeader = function () {
  var header = $(this._headerElement);
  header.toggleClass('header-fullscreen', this.inFullscreen);
  header.toggleClass('header-inline-controls', this.inlineControls);
};

/**
 * Handler for entering fullscreen mode.
 */
Header.prototype._onEnterFullscreen = function () {
  this.inFullscreen = true;
  if (this.initialInlineControls) {
    this.inlineControls = false;
  }
  this._updateHeader();
};

/**
 * Handler for leaving fullscreen mode.
 */
Header.prototype._onLeaveFullscreen = function () {
  this.inFullscreen = false;
  if (this.initialInlineControls) {
    this.inlineControls = true;
  }
  this._updateHeader();
};

/**
 * Handler for double clicks in the header.
 *
 * @param {MouseEvent} event A mouse event object.
 */
Header.prototype._onDoubleClick = function (event) {
  // Check if the event target is inside a header item. Double clicks in header
  // items are ignored.
  var node = event.target;
  while (node) {
    if (node.hasAttribute('data-header-item')) {
      return;
    }
    node = node.parentElement;
  }

  controlMessagesHandler.send({ type: 'header_double_click' });
};

module.exports = new Header();

},{"../../../libs/spotify-elements":259,"../../../libs/spotify-event-dispatcher":264,"../../../libs/spotify-glue-cat":348,"./controlmessageshandler":74,"./event":77}],81:[function(require,module,exports){
(function (global){
'use strict';

var eventDispatcher = require('../../../libs/spotify-event-dispatcher');
var Event = require('./event');
var localSettings = require('./models/localsettings');
var AppState = require('../../../libs/spotify-navigation/app-state');

var hasWebContainer = global.__spotify && global.__spotify.platform === 'web';

/**
 * Keep track of URIs opened
 *
 * @constructor
 */
function History() {
  /**
   * List of URIs opened
   *
   * @type {Array}
   */
  this._history = [];

  /**
   * Pointer to where we're currently at in _history
   *
   * @type {Number}
   */
  this._position = -1;
}

History.prototype.LAST_ACTIVE_APP_KEY = 'activeApp';

/**
 * Push a new state on to the stack
 *
 * @type {AppState} state AppState object.
 */
History.prototype.push = function (state) {
  if (!state.equals(this._history[this._position])) {
    // If not in the last position, remove everything after the current state
    if (this._position !== this._history.length - 1) {
      this._history = this._history.splice(0, this._position + 1);
    }

    this._history.push(state);
    this._position = this._history.length - 1;
    if (hasWebContainer) {
      global.__spotify.exec('history:change', 'push', this._history[this._position]);
    }
    this._onChanged();
  }
};

/**
 * Replace the state at the current position if it matches the context.
 * Else, place it after the current position and move forward to it.
 *
 * @type {AppState} state AppState object.
 * @type {String} context The context to match.
 */
History.prototype.replace = function (state, context) {
  if (state.equals(this._history[this._position])) {
    return;
  }

  // Match the app with or without arguments
  var contextExpression = new RegExp('^' + context + '(:|$)');
  var replaceCurrent = this._history[this._position] && !!this._history[this._position].getURI().match(contextExpression);

  if (replaceCurrent) {
    this._history.splice(this._position, 1, state);
    if (hasWebContainer) {
      global.__spotify.exec('history:change', 'replace', this._history[this._position]);
    }
    this._onChanged();
  } else {
    this.push(state);
  }
};

/**
 * Return the state currently pointed at.
 *
 * @return {AppState|Null} Current AppState or Null if empty.
 */
History.prototype.getCurrentState = function () {
  return this._history[this._position] || null;
};

/**
 * Wraps the localStorage to retrieve the last state of the client.
 *
 * @return {AppState|Null} Stored AppState or Null if none stored.
 */
History.prototype.getLastState = function () {
  var savedState = localSettings.get(this.LAST_ACTIVE_APP_KEY);
  var appState;

  if (!savedState) {
    return null;
  }

  try {
    appState = AppState.unserialize(savedState);
  } catch (e) {
    // Assume URI (from before we used AppState).
    appState = new AppState(savedState);
  }
  return appState;
};

/**
 * Wraps the localStorage to store the last state of the client.
 *
 * @type {AppState} state AppState object.
 */
History.prototype.setLastState = function (appState) {
  localSettings.set(this.LAST_ACTIVE_APP_KEY, appState.serialize());
};

/**
 * Remove a URI from history and move pointer backwards.
 *
 * This method does not use AppState because it is used
 * when a resource (like playlist) has been removed and therefore
 * other variables making up the state is irrelevant.
 *
 * @type {String} uri URI to match start of URI with.
 */
History.prototype.removeUri = function (uri) {
  var historyCopy = [];
  var pos = this._position;
  for (var i = 0, l = this._history.length; i !== l; ++i) {
    if (this._history[i].getURI().indexOf(uri) !== 0) {
      historyCopy.push(this._history[i]);
    } else if (pos >= i) {
      --this._position;
    }
  }
  this._history = historyCopy;

  if (hasWebContainer) {
    global.__spotify.exec('history:change', 'remove', this._history[this._position]);
  }
};

/**
 * Checks if it can go forward in history
 * @return Boolean
 */
History.prototype.canGoForward = function () {
  return this._position < this._history.length - 1;
};

/**
 * Go forward one step
 *
 * @throws {Error} If it can't go forward in history
 * @return {String} Next URI from the stack.
 */
History.prototype.forward = function () {
  return this.go(this._position + 1);
};

/**
 * Checks if it can go back in history
 * @return Boolean
 */
History.prototype.canGoBack = function () {
  return this._position >= 1;
};

/**
 * Go back one step
 *
 * @throws {Error} If it can't go back in history
 * @return {String} Previous URI from the stack.
 */
History.prototype.back = function () {
  return this.go(this._position - 1);
};

/**
 * Navigates to a particular position in the history.
 *
 * @param {number} position The position to navigate to.
 * @return {String?} The corresponding URI in that position in the stack.
 */
History.prototype.go = function (position) {
  if (!this._history[position]) {
    throw new Error('Invalid history state');
  }
  this._position = position;
  this._onChanged();
  return this._history[this._position];
};

/**
 * Called when history state has changed
 */
History.prototype._onChanged = function () {
  var back = !!this._history[this._position - 1];
  var forward = !!this._history[this._position + 1];
  eventDispatcher.dispatchEvent(new Event(Event.TYPES.NAVIGATION_HISTORY_CHANGE, {
    back: back,
    forward: forward,
    history: this._history.map(function (app) {
      return app.getURI();
    })
  }));
  this.setLastState(this._history[this._position]);
};

module.exports = History;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../../libs/spotify-event-dispatcher":264,"../../../libs/spotify-navigation/app-state":462,"./event":77,"./models/localsettings":100}],82:[function(require,module,exports){
(function (global){
'use strict';

// Moving forward, new code should be written in ES6

var _clientstate = require('./clientstate');

var _clientstate2 = _interopRequireDefault(_clientstate);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var glue = require('../../../libs/spotify-glue-cat');
var glueVersion = glue.getVersion();

var live = require('../../../libs/spotify-live');

// Fetches the current user data in order to continue loading the app
var Session = require('./models/session');
Session.setup(window.__spotify);

// Live models
require('./live-models');

var Bridge = require('./bridge');
var HistoryManager = require('./history');
var ViewManager = require('./viewmanager');
var Router = require('./router');
var Keyboard = require('./keyboard');
var PlaylistModel = require('./models/playlist');
var QueueModel = require('./models/queue');
var LocalSettings = require('./models/localsettings');
var GlobalOfflineProgress = require('./components/global-offline-progress');
var clientStorage = require('./models/client-storage');
var sessionStorage = require('./models/session-storage');
var FocusDetector = require('./focus-detector');
var FocusLogger = require('./logging/focus-logger');
var AdsFocusTracker = require('./logging/ads-focus-tracker');
var PlayerFocusBounceHandler = require('./player-focus-bounce-handler');
var AdsUtils = require('./ads-utils');
var AudioAdListener = require('./audio-ad-listener');
var OpenUriAutoPlay = require('./open-uri-auto-play-handler');
var activityMonitor = require('./components/activity_monitor');
var VideoTakeoverAd = require('../../../libs/spotify-ad-formats').VideoTakeoverAd;
var ChurnedLockedState = require('./views/churned-locked-state');
var ClientEvent3 = require('../../../libs/spotify-logger/messages/ClientEvent3');

_clientstate2.default.init();

require('./preferences-logger').init();

// Context menu
var ContextActions = require('./views/contextactions');
ContextActions.setup();

var strings = require('../i18n');
var glueStrings = strings.glueStrings();
var appStrings = strings.appStrings();

// Register handlebars helpers
var hbs = require('../../../libs/spotify-handlebars');
var helpers = require('../../../libs/spotify-handlebars/helpers');
hbs.register(helpers);
helpers.loc.register(glueStrings);
helpers.loc.register(appStrings);
helpers.numeral.setLocale(strings.locale());

// Monitor connection status
var ConnectionMonitor = require('./connectionmonitor');
ConnectionMonitor.setup();

// Cosmos message handlers
var ControlMessagesHandler = require('./controlmessageshandler');
ControlMessagesHandler.setup();

var UserMessagesHandler = require('./usermessageshandler');
UserMessagesHandler.setup();

var SocialErrorHandler = require('./socialerrorhandler');
SocialErrorHandler.setup();

var OfflineErrorHandler = require('./offlineerrorhandler');
OfflineErrorHandler.setup();

var Header = require('./header');
Header.setup();

// Fix the sync bitrate if it's out of sync with the play bitrate setting.
require('./handle-sync-bitrate-out-of-sync').init(require('../../../libs/spotify-preferences'));

var events = require('../../../libs/spotify-events');
events.attach();
events.update();
var navigationListener = require('./navigation-listener');
navigationListener.attach();

// View Models
var VMAccessibilityLinks = require('./views/accessibilitylinks');
var VMBillboardAd = require('./views/billboard-ad');
var VMBrowserNavigation = require('./views/browsernavigation');
var VMBuddyList = require('./views/buddylist');
var VMCappingFullScreenMessage = require('./views/capping-full-screen-message');
var VMContent = require('./views/content');
var VMMessageBar = require('./views/messagebar');
var VMLeaderboardAd = require('./views/leaderboard-ad');
var VMModal = require('./views/modal');
var VMNavigationBar = require('./views/navigationbar');
var VMOfflineIndicator = require('./views/offline-indicator');
var VMNewPlaylist = require('./views/newplaylist');
var VMNotifications = require('./views/notifications');
var VMNowPlaying = require('./views/nowplaying');
var VMProfileMenu = require('./views/profilemenu');
var VMNavbarOverflow = require('./views/navbar-overflow');
var VMPlayer = require('./views/player');
var VMResize = require('./views/resize');
var VMSearch = require('./views/search.js');
var VMShare = require('./views/share');
var VMUpgradeButton = require('./views/upgradebutton');
var VMVideo = require('./views/video');
var VMYourArtistsTooltip = require('./views/your-artists-tooltip');
var shouldHaveAds = Session.getProductState('ads') === '1';

// Application focus state components
if (shouldHaveAds) {
  new FocusDetector().start();
  new FocusLogger().start();
  new AdsFocusTracker().start();
}

// Application activity logger
activityMonitor.enableForWindow(window);

// Common global components
var bridge = new Bridge();
LocalSettings.setup();
var historyManager = new HistoryManager();
var viewManager = new ViewManager();
var router = new Router(bridge, historyManager);

var openUriAutoPlay = new OpenUriAutoPlay(bridge, live('spotify:player'));
openUriAutoPlay.start();

var globalOfflineProgress = new GlobalOfflineProgress('offline-global-progress' + (glueVersion === 2 ? '' : '-glue1'));
globalOfflineProgress.start();

var playerFocusBounceHandler = new PlayerFocusBounceHandler();
playerFocusBounceHandler.start();

var churnedLockedState = new ChurnedLockedState(window);
churnedLockedState.start();

// Deprecation notice
var DeprecationNotice = require('./deprecation-notice');
DeprecationNotice.setup(LocalSettings);

// Models
PlaylistModel.setup(bridge);
QueueModel.setup(bridge);
Keyboard.setupWithWindow(window);
clientStorage.setup();
sessionStorage.setup();

// Station Manager
var playerHelper = require('./models/player');
var storage = require('../../../libs/spotify-local-storage');
var stationMessageProxy = require('../../../libs/spotify-live-models/station/station-message-proxy');
var stationManager = require('./station-manager');

stationManager.setup(playerHelper.getPlayer(), storage, stationMessageProxy, window.__spotify.locale);

// Views
viewManager.register(glueVersion === 2 ? 'accessibility-links' : 'accessibility-links-glue1', new VMAccessibilityLinks());
viewManager.register(glueVersion === 2 ? 'browser-navigation' : 'browser-navigation-glue1', new VMBrowserNavigation(router, historyManager));
viewManager.register('content', new VMContent());
var navigationBarView = new VMNavigationBar(router);
viewManager.register('navigation-bar', navigationBarView);
viewManager.register('new-playlist', new VMNewPlaylist(navigationBarView));

var nowPlaying = new VMNowPlaying();
viewManager.register('now-playing', nowPlaying);

viewManager.register('notifications', new VMNotifications());

viewManager.register(glueVersion === 2 ? 'player-glue2' : 'player', new VMPlayer(bridge, router, nowPlaying, historyManager));

if (glueVersion === 2) {
  viewManager.register('offline-indicator', new VMOfflineIndicator());
}
viewManager.register(glueVersion === 2 ? 'profile-menu' : 'profile-menu-glue1', new VMProfileMenu());
viewManager.register('navbar-overflow', new VMNavbarOverflow());
viewManager.register('resize-nav', new VMResize('menu-wrapper', 'view-now-playing', 'sidebarWidth'));
viewManager.register(glueVersion === 2 ? 'search' : 'search-glue1', new VMSearch());
viewManager.register('share', new VMShare(bridge));
viewManager.register('message-bar', new VMMessageBar(bridge, churnedLockedState));
viewManager.register('modal', new VMModal(bridge));
viewManager.register('buddy-list', new VMBuddyList());
var ViewModelVideo = new VMVideo();
viewManager.register(glueVersion === 2 ? 'upgrade-button' : 'upgrade-button-glue1', new VMUpgradeButton());
viewManager.register('video', ViewModelVideo);

viewManager.register('your-artists-tooltip', new VMYourArtistsTooltip(Session));

// Set up video context manager
var VideoContextManager = require('./components/video-context-manager');
VideoContextManager.setup(ViewModelVideo);

// Conditionally enable ads
if (shouldHaveAds) {
  viewManager.register('leaderboard-ad', new VMLeaderboardAd(Session));
  viewManager.register('billboard-ad', new VMBillboardAd());

  if (Session.getProductState('ad-formats-video-takeover') === '1') {
    VideoTakeoverAd.appendMaxTo(document.getElementById('view-video-ad')).appendMinTo(document.getElementById('large-cover-container')).enable();
  }
}

// initialize capping listener
var cappingManagerListener = require('./capping-manager-listener');
cappingManagerListener.start();
viewManager.register('capping-full-screen-message', new VMCappingFullScreenMessage());

// Always enable the Filter menu item regardless of ABBA flag (native code
// already looks at the ABBA flag and doesn't even create the menu item for
// the control group).
require('spotify-cosmos-api').resolver.post({
  url: 'sp://messages/v1/container/control',
  body: {
    type: 'update_menu_state',
    enable_filter_item: true
  }
}, function (error) {
  if (error && global.console) {
    console.error(error);
  }
});

var isTouchDevice = 'ontouchstart' in window || navigator && navigator.msMaxTouchPoints > 0;
ClientEvent3.log({
  source: 'spotify:app:zlink',
  event_version: 'has_touch',
  event: 'user:impression',
  json_data: {
    has_touch: isTouchDevice
  }
});

ClientEvent3.log({
  source: 'spotify:app:zlink',
  event_version: 'client-viewport',
  event: 'user:impression',
  json_data: {
    width: window.innerWidth,
    height: window.innerHeight,
    devicePixelRatio: window.devicePixelRatio || 1,
    buddyListWidth: parseInt(LocalSettings.get('buddyListWidth'), 10) || null,
    sidebarWidth: parseInt(LocalSettings.get('sidebarWidth'), 10) || null,
    isPlayerExpanded: LocalSettings.get('coverSize') === 'l'
  }
});

// initialize ad utilities keyboard shortcuts
AdsUtils.registerKeyboardShortcuts();

// initialize ad utilities keyboard shortcuts
var audioAdListener = new AudioAdListener();
audioAdListener.start();

// Hide loading throbber when all the bindings are applied
document.getElementById('loading').style.opacity = '0';
setTimeout(function () {
  document.getElementById('loading').style.display = 'none';
}, 1500);
router.init(); // Open initial URI

events.update();

// Send signal to the native side indicating that the app is ready
ControlMessagesHandler.send({ type: 'ready' });

if (global.__spotify && global.__spotify.developer_mode) {
  window.getCappingInfo = cappingManagerListener.getData.bind(cappingManagerListener);
}

var memoryReporter = require('./memory-reporter');
memoryReporter();

require('../../../libs/spotify-expose-dev-mode-debug-globals/abba').init();
require('../../../libs/spotify-expose-dev-mode-debug-globals/bridge').init();
require('../../../libs/spotify-expose-dev-mode-debug-globals/live').init();
require('../../../libs/spotify-expose-dev-mode-debug-globals/cosmos').init();

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../../libs/spotify-ad-formats":203,"../../../libs/spotify-events":281,"../../../libs/spotify-expose-dev-mode-debug-globals/abba":324,"../../../libs/spotify-expose-dev-mode-debug-globals/bridge":325,"../../../libs/spotify-expose-dev-mode-debug-globals/cosmos":326,"../../../libs/spotify-expose-dev-mode-debug-globals/live":328,"../../../libs/spotify-glue-cat":348,"../../../libs/spotify-handlebars":367,"../../../libs/spotify-handlebars/helpers":358,"../../../libs/spotify-live":439,"../../../libs/spotify-live-models/station/station-message-proxy":428,"../../../libs/spotify-local-storage":444,"../../../libs/spotify-logger/messages/ClientEvent3":451,"../../../libs/spotify-preferences":486,"../i18n":11,"./ads-utils":22,"./audio-ad-listener":25,"./bridge":26,"./capping-manager-listener":27,"./clientstate":28,"./components/activity_monitor":29,"./components/global-offline-progress":63,"./components/video-context-manager":70,"./connectionmonitor":73,"./controlmessageshandler":74,"./deprecation-notice":76,"./focus-detector":78,"./handle-sync-bitrate-out-of-sync":79,"./header":80,"./history":81,"./keyboard":83,"./live-models":84,"./logging/ads-focus-tracker":92,"./logging/focus-logger":94,"./memory-reporter":97,"./models/client-storage":99,"./models/localsettings":100,"./models/player":101,"./models/playlist":103,"./models/queue":104,"./models/session":107,"./models/session-storage":106,"./navigation-listener":108,"./offlineerrorhandler":109,"./open-uri-auto-play-handler":110,"./player-focus-bounce-handler":111,"./preferences-logger":112,"./router":113,"./socialerrorhandler":115,"./station-manager":116,"./usermessageshandler":119,"./viewmanager":126,"./views/accessibilitylinks":127,"./views/billboard-ad":128,"./views/browsernavigation":129,"./views/buddylist":130,"./views/capping-full-screen-message":131,"./views/churned-locked-state":132,"./views/content":133,"./views/contextactions":134,"./views/leaderboard-ad":135,"./views/messagebar":136,"./views/modal":137,"./views/navbar-overflow":155,"./views/navigationbar":156,"./views/newplaylist":157,"./views/notifications":158,"./views/nowplaying":159,"./views/offline-indicator":160,"./views/player":161,"./views/profilemenu":168,"./views/resize":169,"./views/search.js":170,"./views/share":171,"./views/upgradebutton":172,"./views/video":173,"./views/your-artists-tooltip":174,"spotify-cosmos-api":694}],83:[function(require,module,exports){
'use strict';

var eventDispatcher = require('../../../libs/spotify-event-dispatcher');
var EventTypes = require('./event').TYPES;
var cosmos = require('spotify-cosmos-api');

/**
 * Handles keypresses in the chrome/apps
 *
 * Singleton
 */
function Keyboard() {
  this.shortcuts = {};
  this.isolatedShortcuts = {};
  this.importantShortcuts = {};
  this.ignoredShortcuts = {};

  this._isPopoverOpen = false;

  var self = this;
  eventDispatcher.addEventListener(EventTypes.POPOVER_OPENED, function () {
    self._isPopoverOpen = true;
  });
  eventDispatcher.addEventListener(EventTypes.POPOVER_CLOSED, function () {
    self._isPopoverOpen = false;
  });

  this._setupCosmosIgnoreListener();
}

/**
 * Reset state.
 * Used for testing.
 */
Keyboard.prototype._reset = function () {
  this.shortcuts = {};
  this.isolatedShortcuts = {};
  this.importantShortcuts = {};
  this._isPopoverOpen = false;
  this._setupCosmosIgnoreListener();
};

Keyboard.prototype._setupCosmosIgnoreListener = function () {
  if (cosmos.resolver && cosmos.resolver.subscribe) {
    if (this._cosmosIgnoreListener) this._cosmosIgnoreListener.cancel();
    this._cosmosIgnoreListener = cosmos.resolver.subscribe('sp://messages/v1/ignoreshortcuts', function (error, response) {
      if (error) return console.error(error);
      var body = response.getJSONBody();
      (body && body.shortcuts || []).forEach(function (shortcut) {
        var serializedDescription = this.serializeKeyDescription(shortcut);

        if (body.action === 'ignore') {
          this.ignoredShortcuts[serializedDescription] = 1;
        } else if (body.action === 'unignore') {
          delete this.ignoredShortcuts[serializedDescription];
        }
      }.bind(this));
    }.bind(this));
  }
};

/**
 *  Map key codes to common keys
 *
 * @type {Object}
 */
Keyboard.prototype.KEYS = {
  'BACKSPACE': 8,
  'TAB': 9,
  'ENTER': 13,
  'SHIFT': 16,
  'CTRL': 17,
  'ALT': 18,
  'PAUSE/BREAK': 19,
  'CAPS': 20,
  'ESCAPE': 27,
  'SPACE': 32,
  'PAGE_UP': 33,
  'PAGE_DOWN': 34,
  'END': 35,
  'HOME': 36,
  'ARROW_LEFT': 37,
  'ARROW_UP': 38,
  'ARROW_RIGHT': 39,
  'ARROW_DOWN': 40,
  'INSERT': 45,
  'DELETE': 46,
  'A': 65,
  'B': 66,
  'C': 67,
  'D': 68,
  'E': 69,
  'F': 70,
  'G': 71,
  'H': 72,
  'I': 73,
  'J': 74,
  'K': 75,
  'L': 76,
  'M': 77,
  'N': 78,
  'O': 79,
  'P': 80,
  'Q': 81,
  'R': 82,
  'S': 83,
  'T': 84,
  'U': 85,
  'V': 86,
  'W': 87,
  'X': 88,
  'Y': 89,
  'Z': 90,
  'WINDOW_LEFT': 91,
  'WINDOW_RIGHT': 92,
  'SELECT': 93,
  'NUMPAD_0': 96,
  'NUMPAD_1': 97,
  'NUMPAD_2': 98,
  'NUMPAD_3': 99,
  'NUMPAD_4': 100,
  'NUMPAD_5': 101,
  'NUMPAD_6': 102,
  'NUMPAD_7': 103,
  'NUMPAD_8': 104,
  'NUMPAD_9': 105,
  'MULTIPLY': 106,
  'ADD': 107,
  'SUBTRACT': 109,
  'DECIMAL_POINT': 110,
  'DIVIDE': 111,
  'F1': 112,
  'F2': 113,
  'F3': 114,
  'F4': 115,
  'F5': 116,
  'F6': 117,
  'F7': 118,
  'F8': 119,
  'F9': 120,
  'F10': 121,
  'F11': 122,
  'F12': 123,
  'NUM_LOCK': 144,
  'SCROLL_LOCK': 145,
  ';': 186,
  '=': 187,
  ',': 188,
  '-': 189,
  '/': 191,
  '`': 192,
  '[': 219,
  '\\': 220,
  ']': 221,
  '"': 222
};

/**
 * Setup the keydown listener on a given window.
 * @param {Window} window The window on which to listen for keydown events.
 */
Keyboard.prototype.setupWithWindow = function (window) {
  window.addEventListener('keydown', this._eventDispatcher.bind(this), true);
  return this;
};

Keyboard.prototype.serializeKeyDescription = function (e) {
  if (isFinite(e)) {
    e = { keyCode: e };
  }

  if (!e.keyCode && !e.key) {
    throw new Error('No key has been specified');
  }

  return [e.keyCode || e.key,
  // CMD and CTRL are considered the same
  e.metaKey || e.meta || e.ctrlKey || e.ctrl ? 1 : 0, e.altKey || e.alt ? 1 : 0, e.shiftKey || e.shift ? 1 : 0].join('.');
};

var ignoredElements = ['input', 'textarea', 'select', '[role=checkbox]', '[role=input]'];

Keyboard.prototype._isIgnoredElement = function (e) {
  return !!ignoredElements.filter(function (ignoredRule) {
    return e.matches(ignoredRule);
  }).length;
};

/**
 * Ignore keyboard events inside forms, buttons or links
 * letting the default browser behavior prevail
 */
Keyboard.prototype._shouldIgnoreEvent = function (e) {
  // If the event is triggered from inside an app
  // e.originalTarget will be set
  var target = e.originalTarget || e.target;
  var n = target;
  // Goes up in the tree checking if any of the parents in in the blacklist
  while (n) {
    if (this._isIgnoredElement(n)) {
      return true;
    }
    n = n.parentElement;
  }
  return false;
};

Keyboard.prototype._eventDispatcher = function (e) {
  var serializedDescription = this.serializeKeyDescription(e);
  if (this.ignoredShortcuts[serializedDescription]) return;

  // Important shortcuts are always triggered.
  var importantShortcuts = this.importantShortcuts[serializedDescription];
  if (importantShortcuts) {
    this._runShortcutHandlers(importantShortcuts, e);
  }

  // Possibly ignore normal and isolated shortcuts.
  if (this._shouldIgnoreEvent(e)) {
    return;
  }

  var shortcuts = this.shortcuts[serializedDescription];
  var isolatedShortcuts = this.isolatedShortcuts[serializedDescription];

  if (shortcuts && !this._isPopoverOpen) {
    this._runShortcutHandlers(shortcuts, e);
  }

  if (isolatedShortcuts) {
    this._runShortcutHandlers(isolatedShortcuts, e);
  }
};

Keyboard.prototype._runShortcutHandlers = function (handlers, event) {
  for (var i = 0; i < handlers.length; i++) {
    var handlerData = handlers[i];
    var element = handlerData.element;
    if (!element || element.contains(document.activeElement)) {
      handlerData.handler(event);
    }
  }
};

Keyboard.prototype._registerShortcut = function (shortcuts, keyDescription, callback, element) {
  var serializedDescription = this.serializeKeyDescription(keyDescription);

  if (!shortcuts[serializedDescription]) {
    shortcuts[serializedDescription] = [];
  }

  shortcuts[serializedDescription].push({ handler: callback, element: element });
};

Keyboard.prototype.registerShortcut = function (keyDescription, callback) {
  this._registerShortcut(this.shortcuts, keyDescription, callback);
};

Keyboard.prototype.registerIsolatedShortcut = function (keyDescription, element, callback) {
  this._registerShortcut(this.isolatedShortcuts, keyDescription, callback, element);
};

Keyboard.prototype.registerImportantShortcut = function (keyDescription, callback) {
  this._registerShortcut(this.importantShortcuts, keyDescription, callback);
};

module.exports = new Keyboard();

},{"../../../libs/spotify-event-dispatcher":264,"./event":77,"spotify-cosmos-api":694}],84:[function(require,module,exports){
'use strict';

require('../../../libs/spotify-live-models/client').register();
require('../../../libs/spotify-live-models/application').register();
require('../../../libs/spotify-live-models/player').register();
require('../../../libs/spotify-live-models/client-storage').register();
require('../../../libs/spotify-live-models/session-storage').register();
require('../../../libs/spotify-live-models/list-variant').register();
require('../../../libs/spotify-live-models/add/track').register();
require('../../../libs/spotify-live-models/add/album').register();
require('../../../libs/spotify-live-models/add/artist').register();
require('../../../libs/spotify-live-models/add/playlist').register();

var live = require('../../../libs/spotify-live');
var pkg = require('../package.json');
live('spotify:application').update({ version: pkg.version });

require('../../../libs/spotify-live-models/user').register();
require('../../../libs/spotify-live-models/track').register();
require('../../../libs/spotify-live-models/album').register();
require('../../../libs/spotify-live-models/artist').register();
require('../../../libs/spotify-live-models/station').register();
require('../../../libs/spotify-live-models/playlist').register();
require('../../../libs/spotify-live-models/sortlist').register();
require('../../../libs/spotify-live-models/local-files').register();
require('./live-models/playlist').register();
require('./live-models/folder').register();
require('./live-models/new-folder').register();
require('./live-models/new-playlist').register();
require('./live-models/playlist-annotate').register();

},{"../../../libs/spotify-live":439,"../../../libs/spotify-live-models/add/album":393,"../../../libs/spotify-live-models/add/artist":394,"../../../libs/spotify-live-models/add/playlist":396,"../../../libs/spotify-live-models/add/track":398,"../../../libs/spotify-live-models/album":399,"../../../libs/spotify-live-models/application":400,"../../../libs/spotify-live-models/artist":401,"../../../libs/spotify-live-models/client":403,"../../../libs/spotify-live-models/client-storage":402,"../../../libs/spotify-live-models/list-variant":404,"../../../libs/spotify-live-models/local-files":405,"../../../libs/spotify-live-models/player":410,"../../../libs/spotify-live-models/playlist":414,"../../../libs/spotify-live-models/session-storage":415,"../../../libs/spotify-live-models/sortlist":423,"../../../libs/spotify-live-models/station":424,"../../../libs/spotify-live-models/track":431,"../../../libs/spotify-live-models/user":432,"../package.json":21,"./live-models/folder":85,"./live-models/new-folder":86,"./live-models/new-playlist":87,"./live-models/playlist":89,"./live-models/playlist-annotate":88}],85:[function(require,module,exports){
'use strict';

var live = require('../../../../libs/spotify-live');
var bridge = require('../../scripts/bridge');
var LocalSettings = require('../models/localsettings');
var util = require('./util');

function publishName(model, name) {
  bridge.request('playlist_folder_set_name', [model.uri, name], function (err) {
    if (!err) {
      model.update({
        name: name
      });

      live(util.getRowUri(model.uri)).update({
        renaming: false
      });
    }
  });
}

function publishExpanded(model, expanded) {
  var expandedFolders = JSON.parse(LocalSettings.get('navigationbar.expanded_folders')) || [];

  var uri = util.getRealUri(model.uri);

  var index = expandedFolders.indexOf(uri);

  if (expanded) {
    if (index === -1) {
      expandedFolders.push(uri);
    }
  } else {
    if (index !== -1) {
      expandedFolders.splice(index, 1);
    }
  }
  LocalSettings.set('navigationbar.expanded_folders', JSON.stringify(expandedFolders));

  model.update({
    expanded: expanded
  });
}

function onPublish(model, properties) {
  if ('name' in properties) {
    publishName(model, properties.name);
  }
}

function onRowPublish(model, properties) {
  if ('expanded' in properties) {
    publishExpanded(model, properties.expanded);
  }
}

var rowRegExp = require('./uris').ROW_FOLDER_REGEXP;
var regExp = require('./uris').FOLDER_REGEXP;

exports.register = function () {
  live.subscribe(regExp, 'publish', onPublish);
  live.subscribe(rowRegExp, 'publish', onRowPublish);
};

exports.unregister = function () {
  live.unsubscribe(regExp, 'publish', onPublish);
  live.unsubscribe(rowRegExp, 'publish', onRowPublish);
};

},{"../../../../libs/spotify-live":439,"../../scripts/bridge":26,"../models/localsettings":100,"./uris":90,"./util":91}],86:[function(require,module,exports){
'use strict';

var live = require('../../../../libs/spotify-live');
var bridge = require('../../scripts/bridge');
var util = require('./util');

function onPublish(model, properties) {
  if ('name' in properties) {
    var rowUri = util.getRowUri(model.uri);

    util.getPosition(rowUri, function (err, position) {
      if (err) {
        return;
      }

      util.calcBackendPosition([position], function (err, positions) {
        if (err) {
          return;
        }

        var position = positions[0];

        bridge.request('playlist_folder_insert', [properties.name, position], function () {
          live(rowUri).update({
            renaming: false
          });
        });
      });
    });
  }
}

function onUpdate(model, properties) {
  if ('renaming' in properties && !properties.renaming) {
    var realModel = live(util.getRealUri(model.uri));
    realModel.delete('name');

    // remove the new folder indicator from the rootlist
    // when the property renaming becomes false
    util.getPosition(model.uri, function (err, position) {
      if (err || position === -1) {
        return;
      }

      // delete the depth of the row so next time it's opened it's calculated
      // again
      model.delete('depth');

      live('spotify:rootlist').get('rows').update([{
        type: 'remove',
        index: position,
        length: 1
      }]);
    });
  }
}

var rowRegExp = require('./uris').NEW_ROW_FOLDER_REGEXP;
var regExp = require('./uris').NEW_FOLDER_REGEXP;

exports.register = function () {
  live.subscribe(regExp, 'publish', onPublish);
  live.subscribe(rowRegExp, 'update', onUpdate);
};

exports.unregister = function () {
  live.unsubscribe(regExp, 'publish', onPublish);
  live.unsubscribe(rowRegExp, 'update', onUpdate);
};

},{"../../../../libs/spotify-live":439,"../../scripts/bridge":26,"./uris":90,"./util":91}],87:[function(require,module,exports){
'use strict';

var live = require('../../../../libs/spotify-live');
var bridge = require('../../scripts/bridge');
var util = require('./util');
var cosmos = require('spotify-cosmos-api');
var isString = require('mout/lang/isString');

var NEW_PLAYLIST_URI = require('./uris').NEW_PLAYLIST_URI;

function onPublish(model, properties) {
  if ('name' in properties) {
    var rowUri = util.getRowUri(model.uri);

    util.getPosition(rowUri, function (err, position) {
      if (err) {
        return;
      }

      util.calcBackendPosition([position], function (err, positions) {
        if (err) {
          return;
        }

        var position = positions[0];

        bridge.request('playlist_create', [properties.name, position], function (err) {
          if (err) {
            var isNameIllegalError = isString(err.message) && err.message.indexOf('Illegal playlist name.') > -1;
            var errorMessageId = isNameIllegalError ? 'illegal-playlist-name-entered' : 'playlist-save-failed-unknown';
            cosmos.resolver.post({
              url: 'sp://messages/v1/container/user-message',
              body: { id: errorMessageId }
            });
          }

          live(rowUri).update({
            renaming: false
          });
        });
      });
    });
  }
}

function onUpdate(model, properties) {
  if ('renaming' in properties && !properties.renaming) {
    var realModel = live(util.getRealUri(model.uri));
    realModel.delete('name');

    // remove the new playlist form from the rootlist
    // when the property renaming becomes false
    util.getPosition(NEW_PLAYLIST_URI, function (err, position) {
      if (err || position === -1) {
        return;
      }

      // delete the depth of the row so next time it's opened it's calculated
      // again
      model.delete('depth');

      live('spotify:rootlist').get('rows').update([{
        type: 'remove',
        index: position,
        length: 1
      }]);
    });
  }
}

var rowRegExp = require('./uris').NEW_ROW_PLAYLIST_REGEXP;
var regExp = require('./uris').NEW_PLAYLIST_REGEXP;

exports.register = function () {
  live.subscribe(regExp, 'publish', onPublish);
  live.subscribe(rowRegExp, 'update', onUpdate);
};

exports.unregister = function () {
  live.unsubscribe(regExp, 'publish', onPublish);
  live.unsubscribe(rowRegExp, 'update', onUpdate);
};

},{"../../../../libs/spotify-live":439,"../../scripts/bridge":26,"./uris":90,"./util":91,"mout/lang/isString":654,"spotify-cosmos-api":694}],88:[function(require,module,exports){
'use strict';

var live = require('../../../../libs/spotify-live');
var util = require('./util');
var PlaylistAnnotate = require('../models/playlist-annotate');

var ROW_REGEXP = require('./uris').ROW_REGEXP;

function onRowUpdate(model, props) {
  var uri = util.getRealUri(model.uri);
  if (props.renaming && util.annotateHandlesEdit(uri)) {
    PlaylistAnnotate.showUI(uri);
  }
}

exports.register = function () {
  live.subscribe(ROW_REGEXP, 'update', onRowUpdate);
};

exports.unregister = function () {
  live.unsubscribe(ROW_REGEXP, 'update', onRowUpdate);
};

},{"../../../../libs/spotify-live":439,"../models/playlist-annotate":102,"./uris":90,"./util":91}],89:[function(require,module,exports){
'use strict';

var live = require('../../../../libs/spotify-live');
var bridge = require('../../scripts/bridge');
var isString = require('mout/lang/isString');
var util = require('./util');
var cosmos = require('spotify-cosmos-api');

function publishName(model, name) {
  bridge.request('playlist_set_name', [model.uri, name], function (err, response) {
    if (err) {
      var isNameIllegalError = isString(err.message) && err.message.indexOf('Illegal playlist name.') > -1;
      var errorMessageId = isNameIllegalError ? 'illegal-playlist-name-entered' : 'playlist-save-failed-unknown';
      cosmos.resolver.post({
        url: 'sp://messages/v1/container/user-message',
        body: { id: errorMessageId }
      });
    } else {
      if (response.name) {
        model.update({
          name: response.name
        });
      }
    }

    live(util.getRowUri(model.uri)).update({
      renaming: false
    });
  });
}

function onPublish(model, properties) {
  if ('name' in properties) {
    publishName(model, properties.name);
  }
}

var regExp = require('./uris').PLAYLIST_REGEXP;

exports.register = function () {
  live.subscribe(regExp, 'publish', onPublish);
};

exports.unregister = function () {
  live.unsubscribe(regExp, 'publish', onPublish);
};

},{"../../../../libs/spotify-live":439,"../../scripts/bridge":26,"./uris":90,"./util":91,"mout/lang/isString":654,"spotify-cosmos-api":694}],90:[function(require,module,exports){
'use strict';

/**
 * Export public interface
 */

module.exports = {
  NEW_PLAYLIST_URI: 'spotify:row:new:user:@:new-playlist',
  NEW_PLAYLIST_REGEXP: /^spotify:user:@:new-playlist$/,
  NEW_ROW_PLAYLIST_REGEXP: /^spotify:row:new:user:@:new-playlist$/,

  NEW_FOLDER_URI: 'spotify:row:new:user:@:new-folder',
  NEW_FOLDER_REGEXP: /^spotify:user:@:new-folder$/,
  NEW_ROW_FOLDER_REGEXP: /^spotify:row:new:user:@:new-folder$/,

  ROW_FOLDER_REGEXP: /^spotify:row:[^:]+:user:(.*):folder/,

  FOLDER_REGEXP: /^spotify:user:(.*):folder:[^:]+$/,
  FOLDER_END_REGEXP: /^spotify:user:(.*):folder:[^:]+:end$/,
  PLAYLIST_REGEXP: require('../../../../libs/spotify-live-models/playlist').matches,
  USER_REGEXP: /^spotify:user:[^:]+$/,

  ROW_REGEXP: /^spotify:row:[^:]+:user:/
};

},{"../../../../libs/spotify-live-models/playlist":414}],91:[function(require,module,exports){
'use strict';

var live = require('../../../../libs/spotify-live');
var liburi = require('spotify-liburi');

var findIndex = require('mout/array/findIndex');
var playlistAnnotateTest = require('../../../../libs/spotify-playlist-annotate-test');

var NEW_FOLDER_URI = require('./uris').NEW_FOLDER_URI;
var NEW_PLAYLIST_URI = require('./uris').NEW_PLAYLIST_URI;

function getRowUri(uri) {
  if (/^spotify:user:@:new-(playlist|folder)$/.test(uri)) {
    return uri.replace(/^spotify:/, 'spotify:row:new:');
  }

  var rowUriMap = live('spotify:rootlist').get('rowUriMap');

  return rowUriMap && rowUriMap.get(uri) || '';
}

function getRealUri(uri) {
  return uri.replace(/^spotify:row:[^:]+:/, 'spotify:');
}

function isPlaylist(uri) {
  uri = liburi.from(uri);

  if (!uri) {
    return false;
  }
  return uri.type === liburi.Type.PLAYLIST;
}

function isFolder(uri) {
  uri = liburi.from(uri);

  if (!uri) {
    return false;
  }
  return uri.type === liburi.Type.FOLDER;
}

function getPosition(uri, callback) {
  live('spotify:rootlist').query('rows(uri)', function (err, resp) {
    if (err) {
      return callback(err);
    }

    var position = findIndex(resp.rows, { uri: uri });

    callback(null, position);
  });
}

function getPositionSync(rowUri) {
  var list = live('spotify:rootlist').get('rows');

  var position = -1;

  for (var i = 0, l = list.length; i < l; i++) {
    var row = list.get(i);
    if (row && row.uri === rowUri) {
      position = i;
      break;
    }
  }

  return position;
}

function calcOffset(input, positive, callback) {
  getPosition(NEW_FOLDER_URI, function (err, folderPosition) {
    if (err) {
      return callback(err);
    }

    getPosition(NEW_PLAYLIST_URI, function (err, playlistPosition) {
      if (err) {
        return callback(err);
      }

      var output = [];

      for (var i = 0; i < input.length; i++) {
        output[i] = parseInt(input[i], 10);

        if (playlistPosition > -1 && output[i] > playlistPosition) {
          output[i] = positive ? output[i] + 1 : output[i] - 1;
        }

        if (folderPosition > -1 && output[i] > folderPosition) {
          output[i] = positive ? output[i] + 1 : output[i] - 1;
        }
      }

      callback(null, output);
    });
  });
}

function calcOffsetSync(input, positive) {
  var folderPosition = getPositionSync(NEW_FOLDER_URI);
  var playlistPosition = getPositionSync(NEW_PLAYLIST_URI);
  var output = [];

  for (var i = 0; i < input.length; i++) {
    output[i] = parseInt(input[i], 10);

    if (playlistPosition > -1 && output[i] > playlistPosition) {
      output[i] = positive ? output[i] + 1 : output[i] - 1;
    }

    if (folderPosition > -1 && output[i] > folderPosition) {
      output[i] = positive ? output[i] + 1 : output[i] - 1;
    }
  }

  return output;
}

function calcLocalPosition(input, callback) {
  return calcOffset(input, true, callback);
}

function calcLocalPositionSync(input) {
  return calcOffsetSync(input, true);
}

function calcBackendPosition(input, callback) {
  return calcOffset(input, false, callback);
}

/**
 * return an array with the parent folder uris of a specific row
 *
 * @param  {string} uri Row URI
 * @param  {Function} callback the callback to use when the data is ready
 */
function getRowParents(uri, callback) {
  var query = 'rows(uri, folderStart, folderEnd)';

  live('spotify:rootlist').query(query, function (err, data) {
    if (err) {
      return callback(err);
    }

    var position = findIndex(data.rows, { uri: uri });
    var expandedTree = [];

    for (var i = 0; i < position; i++) {
      if (data.rows[i].folderStart) {
        expandedTree.push(data.rows[i].uri);
      }
      if (data.rows[i].folderEnd) {
        expandedTree.pop();
      }
    }
    callback(null, expandedTree);
  });
}

function annotateHandlesEdit(uri) {
  var isNewPlaylist = getRowUri(uri) === NEW_PLAYLIST_URI;

  uri = liburi.from(uri);

  if (!uri) {
    return false;
  }

  var isEnabled = playlistAnnotateTest.isEnabled();
  var isPlaylist = uri.type === liburi.Type.PLAYLIST;
  var shouldShowAnnotate = playlistAnnotateTest.shouldShowAnnotateWhenCreating();

  return isEnabled && (isPlaylist || isNewPlaylist) && shouldShowAnnotate;
}

function createBelowRow(rowUri, belowRowUri) {
  var position = getPositionSync(belowRowUri) + 1;
  createRootlistItemByUriAndPosition(rowUri, position);

  // If the row is a folder, expand it.
  if (isFolder(getRealUri(belowRowUri))) {
    live(belowRowUri).publish({ expanded: true });
  }
}

function createRootlistItem(rowUri, options) {
  if (getPositionSync(rowUri) > -1) {
    return;
  }

  if (options && options.belowActiveRow) {
    var activeRow = live('spotify:rootlist').get('activeRow');
    if (activeRow) {
      createBelowRow(rowUri, activeRow.uri);
    } else {
      createRootlistItemByUriAndPosition(rowUri, 0);
    }
  } else if (options && options.belowRow) {
    createBelowRow(rowUri, options.belowRow);
  } else {
    createRootlistItemByUriAndPosition(rowUri, 0);
  }
}

function createRootlistItemByUriAndPosition(rowUri, position) {
  var uri = getRealUri(rowUri);

  if (annotateHandlesEdit(uri)) {
    require('../models/playlist-annotate').showUI(uri, position);
  } else {
    var list = live('spotify:rootlist').get('rows');
    var currentRow = list.get(position);
    var currentDepth = currentRow ? currentRow.get('depth') : 0;
    var isFolderEnd = currentRow && currentRow.get('folderEnd');
    var depth = currentDepth + (isFolderEnd ? 1 : 0);
    list.update([{
      type: 'insert',
      index: position,
      values: [{
        uri: rowUri,
        renaming: true,
        hidden: false,
        depth: depth,
        playlist: {
          uri: uri
        }
      }]
    }]);
  }
}

/**
 * Export public interface
 */
module.exports = {
  getRowUri: getRowUri,
  getRealUri: getRealUri,
  isFolder: isFolder,
  getPosition: getPosition,
  getPositionSync: getPositionSync,
  isPlaylist: isPlaylist,
  calcLocalPosition: calcLocalPosition,
  calcLocalPositionSync: calcLocalPositionSync,
  calcBackendPosition: calcBackendPosition,
  getRowParents: getRowParents,
  annotateHandlesEdit: annotateHandlesEdit,
  createRootlistItem: createRootlistItem
};

},{"../../../../libs/spotify-live":439,"../../../../libs/spotify-playlist-annotate-test":485,"../models/playlist-annotate":102,"./uris":90,"mout/array/findIndex":631,"spotify-liburi":707}],92:[function(require,module,exports){
'use strict';

var Cosmos = require('spotify-cosmos-api');
var eventDispatcher = require('../../../../libs/spotify-event-dispatcher');
var EventType = require('../event').TYPES;

/**
 * Responsible for patching DFP targeting when the application has
 * lost/gained focus.
 *
 * @constructor
 */
function AdsFocusTracker() {
  // bind the methods so they can be used in event listeners
  this._onFocusLost = this._onFocusLost.bind(this);
  this._onFocusGained = this._onFocusGained.bind(this);
}

/**
 * Start listening for focus events
 */
AdsFocusTracker.prototype.start = function () {
  eventDispatcher.addEventListener(EventType.APPLICATION_FOCUS_LOST, this._onFocusLost);
  eventDispatcher.addEventListener(EventType.APPLICATION_FOCUS_GAINED, this._onFocusGained);
};

/**
 * Stop listening for focus events
 */
AdsFocusTracker.prototype.stop = function () {
  eventDispatcher.removeEventListener(EventType.APPLICATION_FOCUS_LOST, this._onFocusLost);
  eventDispatcher.removeEventListener(EventType.APPLICATION_FOCUS_GAINED, this._onFocusGained);
};

/**
 * Event listener for when the application has lost focus.
 *
 * @private
 */
AdsFocusTracker.prototype._onFocusLost = function () {
  this._putTargeting('focus', 'false');
};

/**
 * Event listener for when the application has gained focus.
 *
 * @private
 */
AdsFocusTracker.prototype._onFocusGained = function () {
  this._putTargeting('focus', 'true');
};

/**
 * Makes a cosmos PUT request to AdsCore
 * @param  {String} key   key to put targeting
 * @param  {Object} value value of key
 * @return {undefined}
 */
AdsFocusTracker.prototype._putTargeting = function (key, value) {
  var putTargetingRequest = new Cosmos.Request('PUT', 'sp://ads/v1/targeting/' + key, { 'Content-Type': 'application/json' }, {
    value: value
  });

  Cosmos.resolver.resolve(putTargetingRequest, function (err, res) {
    if (err) console.error('[Ads] Failed to put targeting', err, res);
  });
};

module.exports = AdsFocusTracker;

},{"../../../../libs/spotify-event-dispatcher":264,"../event":77,"spotify-cosmos-api":694}],93:[function(require,module,exports){
'use strict';

var ClientEvent3 = require('../../../../libs/spotify-logger/messages/ClientEvent3');
var objectAssign = require('../../../../vendor/object-assign');
var pkg = require('../../package.json');

var defaultData = {
  source: pkg.name,
  source_vendor: 'com.spotify'
};

function log(data) {
  var logData = objectAssign({}, defaultData, data);
  ClientEvent3.log(logData);
}

module.exports = { log: log };

},{"../../../../libs/spotify-logger/messages/ClientEvent3":451,"../../../../vendor/object-assign":758,"../../package.json":21}],94:[function(require,module,exports){
'use strict';

var Cosmos = require('spotify-cosmos-api');
var logger = require('./client-event-logger');
var eventDispatcher = require('../../../../libs/spotify-event-dispatcher');
var EventType = require('../event').TYPES;

var LOG_TYPE_FOCUS_LOST = 'ui_backgrounded';
var LOG_TYPE_FOCUS_GAINED = 'ui_foregrounded';

/**
 * Responsible for logging to the backend when the application has
 * lost/gained focus.
 *
 * @constructor
 */
function FocusLogger() {
  this._currentTrack = null;
  this._isPlayingAd = false;

  // bind the methods so they can be used in event listeners
  this._onPlayerEvent = this._onPlayerEvent.bind(this);
  this._onFocusLost = this._onFocusLost.bind(this);
  this._onFocusGained = this._onFocusGained.bind(this);
}

/**
 * Start listening for focus events
 */
FocusLogger.prototype.start = function () {
  if (typeof this._cosmosSubscription === 'undefined') {
    this._cosmosSubscription = Cosmos.resolver.subscribe('sp://player/v2/main', this._onPlayerEvent);
  }
  eventDispatcher.addEventListener(EventType.APPLICATION_FOCUS_LOST, this._onFocusLost);
  eventDispatcher.addEventListener(EventType.APPLICATION_FOCUS_GAINED, this._onFocusGained);
};

/**
 * Stop listening for focus events
 */
FocusLogger.prototype.stop = function () {
  if (typeof this._cosmosSubscription !== 'undefined') {
    Cosmos.resolver.unsubscribe('sp://player/v2/main', this._cosmosSubscription);
    this._cosmosSubscription = undefined;
  }
  eventDispatcher.removeEventListener(EventType.APPLICATION_FOCUS_LOST, this._onFocusLost);
  eventDispatcher.removeEventListener(EventType.APPLICATION_FOCUS_GAINED, this._onFocusGained);
};

/**
 * Send a log message to the backend with current state.
 *
 * @param {String} type The type of event to send.
 * @private
 */
FocusLogger.prototype._log = function (type) {
  // The default fallback to zlink here is kinda weird...
  var context = this._currentTrack || 'spotify:app:zlink';
  logger.log({
    'event': 'user:hit',
    'event_version': type,
    'json_data': {
      'is_ad': this._isPlayingAd,
      'track_context': context,
      'name': 'spotify:main',
      'target_uri': context
    }
  });
};

/**
 * Event listener for player events.
 *
 * @private
 */
FocusLogger.prototype._onPlayerEvent = function (error, response) {
  if (error) {
    return;
  }
  var body = response.getJSONBody();
  this._isPlayingAd = body && body.track && body.track.metadata && body.track.metadata.is_advertisement === 'true';
  this._currentTrack = body && body.track && body.track.uri ? body.track.uri : null;
};

/**
 * Event listener for when the application has lost focus.
 *
 * @private
 */
FocusLogger.prototype._onFocusLost = function () {
  this._log(LOG_TYPE_FOCUS_LOST);
};

/**
 * Event listener for when the application has gained focus.
 *
 * @private
 */
FocusLogger.prototype._onFocusGained = function () {
  this._log(LOG_TYPE_FOCUS_GAINED);
};

module.exports = FocusLogger;

},{"../../../../libs/spotify-event-dispatcher":264,"../event":77,"./client-event-logger":93,"spotify-cosmos-api":694}],95:[function(require,module,exports){
'use strict';

var ClientEvent3 = require('../../../../libs/spotify-logger/messages/ClientEvent3');
var objectAssign = require('../../../../vendor/object-assign');
var pkg = require('../../package.json');

var defaultData = {
  source: pkg.name,
  context: 'playlist_annotate_form',
  source_vendor: 'com.spotify'
};

function log(data) {
  var logData = objectAssign({}, defaultData, data);
  ClientEvent3.log(logData);
}

var logger = { log: log };

// Expose window.performance for timing purposes
if (typeof window !== 'undefined' && window.performance) {
  logger.performance = window.performance;
} else {
  // Else mock/fall back to date timing
  logger.performance = { now: function now() {
      return new Date();
    } };
}

module.exports = logger;

},{"../../../../libs/spotify-logger/messages/ClientEvent3":451,"../../../../vendor/object-assign":758,"../../package.json":21}],96:[function(require,module,exports){
'use strict';

/**
 * In memory cache with LRU and TTL support
 *
 * @param {int} maxItems the max number of items to keep
 * @param {Function} removeFn the function to call when an item is removed
 * @param {int} cleanupTtl the maximum TTL for each item
 * @param {int|null} cleanupIntervalTime if set to any value, interval to
 *                   automatically clean old items
 */

var LruCache = function LruCache(maxItems, removeFn, cleanupTtl, cleanupIntervalTime) {
  /**
   * Max cache size.
   *
   * If number of cached iframes exceeds this number then iframes
   * will be dropped using the first in first out principal.
   *
   * @type {Number}
   */
  this._maxSize = maxItems || 10;

  /**
   * The time to kill idle apps (in ms)
   */
  this._ttl = cleanupTtl || 60000;

  /**
   * Function to call when an item is removed
   */
  this._removeFn = removeFn;

  /**
   * The time to kill idle apps (in ms)
   */
  this._cleanupIntervalTime = cleanupIntervalTime;

  /**
   * A list of the cached items
   *
   * @type {Object}
   */
  this._items = {};

  /**
   * A counter of how many iframes are currently cached
   */
  this._size = 0;

  if (this._cleanupIntervalTime) {
    this.enableCleanup();
  }
};

/**
 * Get an item from the cache
 *
 * @param {String} id item id
 * @return {Element?} The cached item.
 */
LruCache.prototype.get = function (id) {
  var item = this._items[id];
  if (item) {
    item.lastAccess = Date.now();
    return item.data;
  }
  return null;
};

/**
 * Store an item in the cache
 *
 * @param {String} id the item id
 * @param {Object} the data to store
 * @param {bool?} If true, always keep this item in cache
 */
LruCache.prototype.set = function (id, data, keep) {
  if (!this._items[id]) {
    this._size++;
    this._items[id] = {
      data: data,
      lastAccess: Date.now(),
      keep: !!keep
    };
  }

  while (this._size > this._maxSize) {
    this._lru();
  }
};

/**
 * Removes the item with the given id
 *
 * @param {String} id Item id
 *
 * @return {bool} True if an item has been removed
 */
LruCache.prototype.remove = function (id) {
  if (!id || !this._items[id]) {
    return false;
  }

  if (this._removeFn) {
    this._removeFn(id, this._items[id].data);
  }

  delete this._items[id];
  this._size--;
  return true;
};

/**
 * Make an item not-cleanable (or cleanable)
 * @param  {string} id Item id
 * @param  {bool} keep if true, it will be not-cleanable
 */
LruCache.prototype.keep = function (id, keep) {
  var item = this._items[id];
  if (item) {
    item.lastAccess = Date.now();
    item.keep = !!keep;
  }
};

/**
 * Creates an interval to run the cleanup rountine every {interval} miliseconds
 */
LruCache.prototype.enableCleanup = function () {
  if (!this._cleanupIntervalTime) {
    return;
  }
  this._cleanupInterval = window.setInterval(this.cleanup.bind(this), this._cleanupIntervalTime);
};

/**
 * Disable the cleanup interval
 */
LruCache.prototype.disableCleanup = function () {
  window.clearTimeout(this._cleanupInterval);
};

/**
 * Kills all apps that are idle for more than the given time
 */
LruCache.prototype.cleanup = function () {
  var now = Date.now();
  var self = this;

  var ids = Object.keys(this._items).filter(function (id) {
    var item = self._items[id];
    return !item.keep && now - item.lastAccess > self._ttl;
  });

  ids.forEach(this.remove.bind(this));
};

/**
 * Returns a dictionary with all items in the cache
 */
LruCache.prototype.getItems = function () {
  var items = {};
  var keys = Object.keys(this._items);
  for (var i = 0; i < keys.length; i++) {
    var k = keys[i];
    items[k] = this._items[k].data;
  }

  return items;
};

/**
 * Performs a LRU cache policy and removes the least recently
 * used item.
 *
 * @returns {bool} a boolean flag indicating if an item was removed.
 */
LruCache.prototype._lru = function () {
  var disposableItems = Object.keys(this._items).filter(function (id) {
    return !this._items[id].keep;
  }.bind(this));

  var oldestItem = disposableItems[0];

  for (var i = 1; i < disposableItems.length; i++) {
    var currItem = disposableItems[i];
    if (this._items[currItem].lastAccess < this._items[oldestItem].lastAccess) {
      oldestItem = currItem;
    }
  }
  return this.remove(oldestItem);
};

module.exports = LruCache;

},{}],97:[function(require,module,exports){
'use strict';

var debug = require('debug');
var abba = require('../../../libs/spotify-abba-mini');
var ClientEvent3 = require('../../../libs/spotify-logger/messages/ClientEvent3');

var dbg = debug('zlink:memory-reporter');

// 22 minutes. webkit / chrome only update memory values approximately
// every 20 minutes to prevent side-channel attacks. The values are also
// quantized, but still useful.
// https://bugs.webkit.org/attachment.cgi?id=154876&action=prettypatch
var REPORTING_INTERVAL = 22 * 60 * 1000;

module.exports = function () {
  if (typeof window === 'undefined' || !window.performance || !window.performance.memory || !window.performance.timing) {
    dbg('aborting, required environment not found');
    return;
  }

  dbg('using interval %d', REPORTING_INTERVAL);

  var ref = 0;

  // https://abtesting.spotify.net/features/1030
  // This should only be enabled for a small subset of users, as the
  // log event data will be substantial.

  abba.subscribe('km-memory-reporting', function (err, cell) {
    dbg('abba cell %s', cell);

    // Always clear on an abba change.
    if (ref) {
      clearInterval(ref);
    }

    if (cell !== 'Enabled') {
      return;
    }

    ref = setInterval(function () {
      // A specific log message would be preferred, but it's still so much work
      // to create a new message and get it registered in the APs.

      var _window$performance = window.performance;
      var memory = _window$performance.memory;
      var timing = _window$performance.timing;


      ClientEvent3.log({
        source: 'spotify:app:zlink',
        event_version: 'memory-report',
        event: 'user:impression',
        json_data: {
          runningTime: Date.now() - timing.navigationStart,
          jsHeapSizeLimit: memory.jsHeapSizeLimit,
          totalJSHeapSize: memory.totalJSHeapSize,
          usedJSHeapSize: memory.usedJSHeapSize
        }
      });
    }, REPORTING_INTERVAL);
  });
};

},{"../../../libs/spotify-abba-mini":181,"../../../libs/spotify-logger/messages/ClientEvent3":451,"debug":526}],98:[function(require,module,exports){
'use strict';

module.exports = {
  TRACKS: 'text/x-spotify-tracks',
  ALBUMS: 'text/x-spotify-albums',
  ARTISTS: 'text/x-spotify-artists',
  PLAYLISTS: 'text/x-spotify-playlists',
  STATIONS: 'text/x-spotify-stations'
};

},{}],99:[function(require,module,exports){
(function (global){
'use strict';

// This is listeners for messages that apps can send to read or write state
// in localStorage. The equivalent app code is live-models/client-storage.

var async = require('async');

var cosmos = require('spotify-cosmos-api');
var storage = require('../../../../libs/spotify-local-storage');

var registered;

var endpoints = {
  broadcast: 'sp://messages/v1/client-storage'
};

function onMessage(event) {
  var i;
  var key;
  var value;

  switch (event.data.name) {
    case 'set_client_storage':
      var keys = Object.keys(event.data.data);
      for (i = 0; i < keys.length; i++) {
        key = keys[i];
        value = event.data.data[key];

        if (value === undefined) {
          storage.remove(key);
        } else {
          storage.set(key, value);
        }
      }
      cosmos.resolver.post({ url: endpoints.broadcast, body: event.data.data });
      break;

    case 'broadcast_client_storage':
      // Read requested keys from localStorage and broadcast them
      var tasks = {};
      var getFromStorage = function getFromStorage(key, callback) {
        // Asynchronously fetch the value from local storage
        // and call the callback provided by the async library
        // to signal when it's done
        storage.get(key, function (error, value) {
          callback(error, value || null);
        });
      };

      for (i = 0; event.data.data[i]; i++) {
        key = event.data.data[i];
        tasks[key] = getFromStorage.bind(null, key);
      }

      async.parallel(tasks, function (err, body) {
        if (!err) {
          // When all 'gets' have returned, broadcast the result
          cosmos.resolver.post({ url: endpoints.broadcast, body: body });
        }
      });
      break;

    default:
    // noop
  }
}

exports.setup = function () {
  if (registered) return;
  global.window.addEventListener('message', onMessage);
  registered = true;
};

exports.unsetup = function () {
  if (!registered) return;
  global.window.removeEventListener(onMessage);
  registered = false;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../../../libs/spotify-local-storage":444,"async":502,"spotify-cosmos-api":694}],100:[function(require,module,exports){
'use strict';

var Session = require('./session');

/**
 * Entity responsible for storing and retrieving
 * user specific settings from local storage
 */
var LocalSettings = function LocalSettings() {};

LocalSettings.prototype.setup = function (username, localStorage) {
  this._username = username || Session.getUsername();
  this._localStorage = localStorage || window.localStorage;
};

/**
 * Returns a namespaced key
 *
 * @param {String}
 * @return {String}
 */
LocalSettings.prototype._key = function (keyName) {
  return this._username + ':' + keyName;
};

/**
 * Returns the item from localStorage with the
 * key for the current user
 */
LocalSettings.prototype.get = function (key) {
  return this._localStorage.getItem(this._key(key));
};

/**
 * Stores the item in localStorage with the
 * key for the current user
 */
LocalSettings.prototype.set = function (key, value) {
  return this._localStorage.setItem(this._key(key), value);
};

/**
 * Removes the item associated with the key for the current user
 */
LocalSettings.prototype.delete = function (key) {
  return this._localStorage.removeItem(this._key(key));
};

module.exports = new LocalSettings();

},{"./session":107}],101:[function(require,module,exports){
'use strict';

var Player = require('spotify-player').Player;
var cosmos = require('spotify-cosmos-api');

function PlayerHelper() {}

PlayerHelper.prototype._player = null;

/**
 * @return Player
 */
PlayerHelper.prototype.getPlayer = function () {
  if (!this._player) {
    var appVersion = "window.__spotify.client_version";
    this._player = new Player(cosmos.resolver, 'spotify:app:zlink', 'zlink', appVersion);
  }
  return this._player;
};

module.exports = new PlayerHelper();

},{"spotify-cosmos-api":694,"spotify-player":710}],102:[function(require,module,exports){
(function (global){
'use strict';

var cosmos = require('spotify-cosmos-api');
var bridge = require('../bridge');
var liburi = require('spotify-liburi');
var interpolate = require('interpolate');

var util = require('../live-models/util');
var NEW_PLAYLIST_URI = require('../live-models/uris').NEW_PLAYLIST_URI;
var ANNOTATE_URL_TEMPLATE = 'hm://playlist-annotate/v1/annotation/user/{username}/playlist/{id}' + '?format=json';

var logger = require('../logging/playlist-annotate-logger');

var endpoints = {
  openForm: 'sp://messages/v1/open-annotate-form'
};

function PlaylistAnnotate() {
  this._subscribeOpenForm();
}

PlaylistAnnotate.prototype._subscribeOpenForm = function () {
  cosmos.resolver.subscribe({ url: endpoints.openForm }, function (err, response) {
    if (err) {
      if (global.console) {
        global.console.error(err);
      }
      return;
    }

    var body = response.getJSONBody();
    if (body && body.uri) {
      this.showUI(body.uri, body.position, body.name, body.focus);
    }
  }.bind(this));
};

PlaylistAnnotate.prototype.submit = function (playlistUri, dataPromise, callback) {
  var self = this;
  dataPromise.then(function (data) {
    var uri = playlistUri;
    var rowUri = util.getRowUri(uri);
    var isNewPlaylist = rowUri === NEW_PLAYLIST_URI || uri === NEW_PLAYLIST_URI;
    var changedName = 'name' in data;
    var changedAnnotation = 'description' in data || 'image_uri' in data;

    var promise;
    if (isNewPlaylist) {
      var position = data.createPlaylistAtPosition;
      promise = self._createPlaylistWithName(data.name, position);
    } else if (changedName) {
      promise = self._setPlaylistName(playlistUri, data.name);
    } else {
      promise = new Promise(function (resolve) {
        resolve({
          uri: playlistUri
        });
      });
    }

    if (changedAnnotation) {
      var annotation = {};
      if ('description' in data) annotation.description = data.description;
      if ('image_uri' in data) annotation.image_uri = data.image_uri;

      promise = promise.then(function (result) {
        return self._updateAnnotation(result.uri, annotation);
      });
    }

    promise.then(function (result) {
      callback(null, result);
    }, function (error) {
      callback(error);
    });
  });
};

/**
 * Updates a playlist annotation.
 *
 * @param String playlistUri The playlist uri
 * @param String annotation The annotations to update
 * @returns Promise A promise
 */
PlaylistAnnotate.prototype._updateAnnotation = function (playlistUri, annotation) {
  return new Promise(function (resolve, reject) {
    var uriObject = liburi.from(playlistUri);
    if (!uriObject || uriObject.type !== liburi.Type.PLAYLIST) {
      reject(new Error('Invalid playlist passed: ' + playlistUri));
      return;
    }

    var encodedUsername = encodeURIComponent(uriObject.username);
    var playlistId = liburi.hexToId(uriObject.id);

    var url = interpolate(ANNOTATE_URL_TEMPLATE, {
      username: encodedUsername,
      id: playlistId
    });

    var preUpdate = logger.performance.now();
    var request = new cosmos.Request('PATCH', url, null, annotation);
    cosmos.resolver.resolve(request, function (error) {
      var updateTime = logger.performance.now() - preUpdate;
      logger.log({
        event: 'info:default',
        event_version: 'playlist_annotate_update',
        json_data: {
          'annotate_upload_time': updateTime,
          'annotation_request_error': !!error
        }
      });

      if (error) {
        reject(error);
      } else {
        resolve({
          uri: playlistUri
        });
      }
    });
  });
};

PlaylistAnnotate.prototype._createPlaylistWithName = function (name, position) {
  return new Promise(function (resolve, reject) {
    bridge.request('playlist_create', [name, position || 0], function (error, result) {
      if (error) {
        reject(error);
      } else {
        resolve(result);
      }
    });
  });
};

PlaylistAnnotate.prototype._setPlaylistName = function (playlistUri, name) {
  return new Promise(function (resolve, reject) {
    bridge.request('playlist_set_name', [playlistUri, name], function (error) {
      if (error) {
        reject(error);
      } else {
        resolve({ uri: playlistUri });
      }
    });
  });
};

PlaylistAnnotate.prototype.showUI = function (uri, createPlaylistAtPosition, name, focus) {
  if (!uri || !this._onShowCallback) return;
  var rowUri = util.getRowUri(uri);
  var isNewPlaylist = rowUri === NEW_PLAYLIST_URI || uri === NEW_PLAYLIST_URI;
  var action = isNewPlaylist ? 'create' : 'edit';

  this._onShowCallback(uri, action, createPlaylistAtPosition, name, focus);
};

PlaylistAnnotate.prototype.setOnShowCallback = function (callback) {
  this._onShowCallback = callback;
};

module.exports = new PlaylistAnnotate();

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../bridge":26,"../live-models/uris":90,"../live-models/util":91,"../logging/playlist-annotate-logger":95,"interpolate":565,"spotify-cosmos-api":694,"spotify-liburi":707}],103:[function(require,module,exports){
'use strict';

var async = require('async');
var Tree = require('spotify-tree');
var liburi = require('spotify-liburi');

var cosmos = require('spotify-cosmos-api');
var playlistActionsImpl = require('../../../../libs/spotify-playlist-actions/playlist-actions');

/**
 *
 * Model for the playlist bridge calls
 */
function Playlist() {}

/**
 * Setup the playlist model
 *
 * @param {Bridge} bridge the bridge to be used
 */
Playlist.prototype.setup = function (bridge) {
  this._bridge = bridge;
  return this;
};

// Todo: Looks unused
/**
 * Fetches playlist data from the API
 *
 * @param {Function} callback function to be called in case of success
 * @param {Function} errback function to be called in case of error
 * @param {boolean} folderHierarchy
 *
 * @return PlaylistFolder
 */
Playlist.prototype.fetchAll = function (callback, errback, folderHierarchy) {
  this._bridge.request('library_playlists_snapshot', ['spotify:user:@'], this, function (playlists) {
    if (playlists.length && playlists.metadata.length === 0) {
      // re-fetch the playlists if the metadata array is empty
      this.fetchAll(callback, errback, folderHierarchy);
    }

    for (var i = 0; i < playlists.length; i++) {
      var uri = playlists.array[i];
      var metadata = playlists.metadata[i] || {};
      metadata.uri = uri;
    }

    var isPlaylist = function isPlaylist(item) {
      var uri = liburi.from(item.uri);
      return uri && uri.type === liburi.Type.PLAYLIST;
    };

    var isFolder = function isFolder(item) {
      var uri = liburi.from(item.uri);
      return uri && uri.type === liburi.Type.FOLDER;
    };

    var root;
    if (!folderHierarchy) {
      root = {
        items: playlists.metadata.filter(isPlaylist)
      };
    } else {
      root = Tree.fromArray(playlists.metadata, isFolder, function (playlist) {
        return playlist.uri;
      });
      root.folder = true;
      root.uri = '';
      root.name = '';
    }

    callback(root);
  }, errback);
};

Playlist.prototype.createPlaylist = function (playlistName, callback, errback) {
  this._bridge.request('playlist_create', [playlistName], this, callback, errback);
};

Playlist.prototype.createPlaylistAtPosition = function (playlistName, position, callback, errback) {
  this._bridge.request('playlist_create', [playlistName, position], this, callback, errback);
};

Playlist.prototype.createFolder = function (name, position, callback, errback) {
  this._bridge.request('playlist_folder_insert', [name, position], this, callback, errback);
};

/**
 * Removes a playlist
 *
 * @param {string} uri The URI of the playlist to remove.
 * @param {function} callback function to call
 */
Playlist.prototype.remove = function (uri, callback) {
  callback = callback || function () {};

  var method = 'library_unsubscribe';
  var args = ['spotify:user:@', uri];
  var parsed = liburi.from(uri);

  if (parsed && parsed.type === liburi.Type.FOLDER) {
    method = 'playlist_folder_remove';
    args = [uri];
  }

  this._bridge.request(method, args, this, callback);
};

/**
 * Load track URIs from an album URI.
 *
 * @param {string} albumURI The URI of the album.
 * @param {Function} callback A node style callback: function(error, data)
 */
Playlist.prototype.loadTracksFromAlbum = function (albumURI, callback) {
  this._bridge.request('album_tracks_snapshot', [albumURI, 0, -1, true], this, function (data) {
    callback(null, data.array);
  }, function (data) {
    var error = new Error(data.message);
    error.name = data.error;
    callback(error);
  });
};

/**
 * Load track URIs from an playlist URI.
 *
 * @param {string} playlistURI The URI of the playlist.
 * @param {Function} callback A node style callback: function(error, data)
 */
Playlist.prototype.loadTracksFromPlaylist = function (playlistURI, callback) {
  this._bridge.request('playlist_tracks_snapshot', [playlistURI, 0, -1, true], this, function (data) {
    callback(null, data.array);
  }, function (data) {
    var error = new Error(data.message);
    error.name = data.error;
    callback(error);
  });
};

/**
 * Load the URIs of all tracks from all the passed albums.
 *
 * @param {Array.<string>} uris Array of album URIs.
 * @param {Function} callback A node style callback: function(error, tracks)
 */
Playlist.prototype.loadTracksFromAlbums = function (uris, callback) {
  var self = this;

  // Load all tracks from all albums in parallel
  async.parallel(uris.map(function (uri) {
    return function (aggregatorFn) {
      self.loadTracksFromAlbum(uri, aggregatorFn);
    };
  }), function (error, trackSets) {
    if (error) return callback(error);

    // Collect all tracks in order in a single array
    var tracks = [];
    for (var i = 0, l = trackSets.length; i < l; i++) {
      tracks = tracks.concat(trackSets[i]);
    }
    callback(null, tracks);
  });
};

/**
 * Load the URIs of all tracks from all the passed playlists.
 *
 * @param {Array.<string>} uris Array of playlist URIs.
 * @param {Function} callback A node style callback: function(error, tracks)
 */
Playlist.prototype.loadTracksFromPlaylists = function (uris, callback) {
  var self = this;

  // Load all tracks from all albums in parallel
  async.parallel(uris.map(function (uri) {
    return function (aggregatorFn) {
      self.loadTracksFromPlaylist(uri, aggregatorFn);
    };
  }), function (error, trackSets) {
    if (error) return callback(error);

    // Collect all tracks in order in a single array
    var tracks = [];
    for (var i = 0, l = trackSets.length; i < l; i++) {
      tracks = tracks.concat(trackSets[i]);
    }

    callback(null, tracks);
  });
};

/**
 * Add all tracks from all the passed albums to the specified playlist.
 *
 * @param {string} playlistURI The URI of the playlist to add to.
 * @param {Array.<string>} albumURIs Array of album URIs.
 * @param {Function=} callback Function to be called in case of success.
 * @param {Function=} errback Function to be called in case of error.
 */
Playlist.prototype.addAlbums = function (playlistURI, albumURIs, callback, errback) {
  var self = this;

  callback = callback || function () {};
  errback = errback || function () {};

  this.loadTracksFromAlbums(albumURIs, function (error, tracks) {
    if (error) return errback(error);
    self.addTracks(playlistURI, tracks, callback, errback);
  });
};

/**
 * Add all tracks from all the passed playlists to the specified playlist.
 *
 * @param {string} playlistURI The URI of the playlist to add to.
 * @param {Array.<string>} playlistURIs Array of playlist URIs.
 * @param {Function=} callback Function to be called in case of success.
 * @param {Function=} errback Function to be called in case of error.
 */
Playlist.prototype.addPlaylists = function (playlistURI, playlistURIs, callback, errback) {
  var self = this;

  callback = callback || function () {};
  errback = errback || function () {};

  this.loadTracksFromPlaylists(playlistURIs, function (error, tracks) {
    if (error) return errback(error);
    self.addTracks(playlistURI, tracks, callback, errback);
  });
};

/**
 * Add the passed tracks to the specified playlist.
 *
 * @param {string} playlistURI The URI ofthe playlist to add to.
 * @param {Array.<string>} trackURIs Array of track URIs.
 * @param {Function=} callback Function to be called in case of success.
 * @param {Function=} errback Function to be called in case of error.
 */
Playlist.prototype.addTracks = function (playlistURI, trackURIs, callback, errback) {
  callback = callback || function () {};
  errback = errback || function (error) {
    console.error(error);
  };

  playlistActionsImpl.addTracksToPlaylist(cosmos, playlistURI, trackURIs, function (error) {
    if (error) {
      errback(error);
    } else {
      callback();
    }
  });
};

module.exports = new Playlist();

},{"../../../../libs/spotify-playlist-actions/playlist-actions":484,"async":502,"spotify-cosmos-api":694,"spotify-liburi":707,"spotify-tree":733}],104:[function(require,module,exports){
'use strict';

var cosmos = require('spotify-cosmos-api');
var Player = require('spotify-player').Player;
var rangeUtil = require('../../../../libs/spotify-range2');

function queuedTrackFromUri(uri) {
  // Handle both URI objects and URI strings.
  return {
    uri: uri.toURI ? uri.toURI() : uri,
    metadata: {
      is_queued: true
    }
  };
}

function isTrackManuallyQueued(track) {
  return track.metadata && track.metadata.is_queued === 'true';
}

function mutateQueue(player, mutator, callback) {
  if (!callback) {
    callback = function callback() {};
  }

  var onError = function onError(error) {
    console.error(error);
    callback(error);
  };

  player.getQueue(function (error, response) {
    if (error) {
      onError(error);
    } else {
      var before = response.getJSONBody();
      var after = JSON.stringify(mutator(before));
      player.setQueue(after, function (error) {
        if (error) {
          onError(error);
        } else {
          callback();
        }
      });
    }
  });
}

/**
 *
 * Model for the queue bridge calls
 */
function Queue() {}

/**
 * Setup the queue model
 *
 * @param {Bridge} bridge the bridge to be used
 */
Queue.prototype.setup = function (bridge) {
  this._bridge = bridge;
  this._player = new Player(cosmos.resolver, 'spotify:internal:queue', 'queue', '1.0.0');

  return this;
};

/**
 * Add an array of tracks to the queue
 *
 * @param {array} uris for the tracks to add
 * @param {Function=} callback
 */
Queue.prototype.addTracksToQueue = function (uris, callback) {
  mutateQueue(this._player, function (queue) {
    // Split up next and context into two arrays.
    var upNext = queue.next_tracks.filter(isTrackManuallyQueued);
    var context = queue.next_tracks.filter(function (track) {
      return !isTrackManuallyQueued(track);
    });

    // Create array of new tracks from URIs.
    var newTracks = uris.map(queuedTrackFromUri);

    // Concatenate up next, new tracks and context.
    queue.next_tracks = upNext.concat(newTracks, context);

    return queue;
  }, callback);
};

/**
 * Remove tracks from the queue
 *
 * @param {array} indices for the tracks to remove
 * @param {Function=} callback
 */
Queue.prototype.removeTracksFromQueue = function (indices, callback) {
  mutateQueue(this._player, function (queue) {
    // Split up next and context into two arrays.
    var upNext = queue.next_tracks.filter(isTrackManuallyQueued);
    var context = queue.next_tracks.filter(function (track) {
      return !isTrackManuallyQueued(track);
    });

    // Splice out tracks to remove from up next.
    var ranges = rangeUtil.fromIndices(indices);
    for (var i = ranges.length - 1; i >= 0; i--) {
      upNext.splice(ranges[i].start, ranges[i].length);
    }

    // Concatenate up next and context again.
    queue.next_tracks = upNext.concat(context);

    return queue;
  }, callback);
};

/**
 * Add a context to the queue
 *
 * @param {string} uri The context URI
 * @param {string} contextType The context type. Can be "playlist" or "album"
 * @param {Function=} callback successfull callback
 */
Queue.prototype.addContextToQueue = function (uri, contextType, callback) {
  var self = this;
  var requestName = contextType + '_tracks_snapshot';

  this._bridge.request(requestName, [uri, 0, -1], this, function (response) {
    self.addTracksToQueue(response.array, callback);
  });
};

module.exports = new Queue();

},{"../../../../libs/spotify-range2":489,"spotify-cosmos-api":694,"spotify-player":710}],105:[function(require,module,exports){
(function (global){
'use strict';

var cosmos = require('spotify-cosmos-api');
var live = require('../../../../libs/spotify-live');
var diff = require('../../../../libs/spotify-live/util/diff');
var liburi = require('spotify-liburi');
var objectDiffer = require('../utils/live-object-differ');
var findIndex = require('mout/array/findIndex');
var merge = require('mout/object/merge');

var localSettings = require('./localsettings');
var session = require('./session');

var NEW_PLAYLIST_URI = require('../live-models/uris').NEW_PLAYLIST_URI;
var NEW_FOLDER_URI = require('../live-models/uris').NEW_FOLDER_URI;
var ROW_FOLDER_REGEXP = require('../live-models/uris').ROW_FOLDER_REGEXP;
var ROW_REGEXP = require('../live-models/uris').ROW_REGEXP;

var ENDPOINT = 'sp://core-playlist/v1/rootlist';
var LIST_POLICY = {
  playlist: {
    rowId: true,
    link: true,
    name: true,
    collaborative: true,
    allows: {
      insert: true,
      remove: true
    },
    owner: {
      link: true,
      name: true,
      username: true
    }
  },
  folder: {
    rowId: true,
    id: true,
    name: true,
    rows: true
  }
};
var ROW_QUERY = 'uri, rowId, depth, hidden, folderId, folderStart, folderEnd' + ', renaming, deleting, active, expanded, playlist(uri, name' + ', allows(insertTracks, removeTracks), offlineStatus, shouldBeOffline' + ', offlineProgress, collaborative, added, owner(uri, name, username' + ', currentUser))';

var rootlistState = {
  hasData: false,
  subscribing: false,
  pendingCallbacks: [],
  lastRowIds: [],
  currentUserName: ''
};

function Rootlist() {}

Rootlist.prototype.setup = function () {
  if (this._isSetUp) {
    return;
  }
  this._isSetUp = true;

  var self = this;
  var model = live('spotify:rootlist');

  // By setting a `loaded` property on the model, it's easier to use the rows
  // list initially. Just asking for `rows` via a live get will run the callback
  // before we've seen an update event for the actual rows list getting its
  // contents, meaning that you can't listen for list changes in the callback
  // for `rows`, you must wait another tick. By updating a `loaded` property,
  // the update event for that will run in the next tick.
  model.get('rows', function (error, rowsList) {
    if (error) return;

    var checkList = function checkList() {
      var index = rowsList.index;
      if (index && index.length === 1 && index[0].length === rowsList.length) {
        // Defer another tick so that we're sure that the list is loaded and the
        // events have fired.
        setTimeout(function () {
          model.update({ loaded: true });
        }, 0);

        // Check again in next tick if not loaded yet
      } else {
          setTimeout(checkList, 0);
        }
    };
    checkList();
  });

  model.get('loaded', 'rows', function (error, loaded, rowsList) {
    if (loaded && rowsList) {
      rowsList.on('publish', function (operations) {
        self._onRowsPublish(model, rowsList, operations);
      });

      rowsList.on('update', function () {
        self._onRowsUpdate(model, rowsList);
      });

      self._liveSubscribeRow = function (model, data) {
        self._onRowUpdate(model, data);
      };
      live.subscribe(ROW_REGEXP, 'update', self._liveSubscribeRow);

      self._liveSubscribeFolderRow = function (model, data) {
        self._onFolderRowUpdate(model, data);
      };
      live.subscribe(ROW_FOLDER_REGEXP, 'update', self._liveSubscribeFolderRow);
    }
  });

  this._subscribeForOfflineStatus();
};

Rootlist.prototype.unsetup = function () {
  this._isSetUp = false;

  if (this._liveSubscribeRow) {
    live.unsubscribe(ROW_REGEXP, 'update', this._liveSubscribeRow);
    this._liveSubscribeRow = false;
  }

  if (this._liveSubscribeFolderRow) {
    live.unsubscribe(ROW_FOLDER_REGEXP, 'update', this._liveSubscribeFolderRow);
    this._liveSubscribeFolderRow = false;
  }

  rootlistState = {
    hasData: false,
    subscribing: false,
    pendingCallbacks: [],
    lastRowIds: []
  };
};

Rootlist.prototype.getRows = function (callback) {
  var self = this;

  if (rootlistState.hasData) {
    var data = live('spotify:rootlist').query('rows(' + ROW_QUERY + ')');
    setTimeout(function () {
      callback(null, data && data.rows);
    }, 0);
    return;
  }

  rootlistState.pendingCallbacks.push(callback);

  if (!rootlistState.subscribing) {
    rootlistState.subscribing = true;

    this._subscribeToList(function (error, rows) {
      if (error) {
        if (global.console) console.error(error);
        self._callPendingCallbacks(error);
        return;
      }

      var liveRowsData = self._convertManyRowsToLiveFormat(rows);
      self._updateHiddenStates(liveRowsData);

      if (rootlistState.pendingCallbacks.length > 0) {
        var callbackData = merge({}, { rows: liveRowsData }).rows;
        self._callPendingCallbacks(null, callbackData);
        self._setInitialLiveData(liveRowsData);
        rootlistState.hasData = true;
      } else {
        self._updateLiveData(rows);

        var model = live('spotify:rootlist');
        var currentData = model.query('rows(' + ROW_QUERY + ')');
        var currentRows = currentData.rows.filter(function (row) {
          if (row.uri === NEW_PLAYLIST_URI || row.uri === NEW_FOLDER_URI) {
            return false;
          }
          return true;
        });

        var before = currentRows;
        var after = liveRowsData;

        if (before.length === after.length) {
          var diff = objectDiffer.listIterator(before, after, function (a, b) {
            return objectDiffer.diff(a, b);
          });

          model.get('loaded', function (error, loaded) {
            if (loaded) live(diff);
          }, live.ASAP);
        } else if (global.console) {
          var msg = 'Rootlist data diffing: Length mismatch (before: ' + before.length + ', after: ' + after.length + ')';
          console.error(new Error(msg));
        }
      }
    });
  }
};

Rootlist.prototype.getRowsForRange = function (start, end) {
  var list = live('spotify:rootlist').get('rows');
  if (!list) return [];

  var rows = [];
  for (var i = start; i < end; i++) {
    var row = list.get(i);
    rows.push(row && row.query(ROW_QUERY));
  }

  return rows;
};

Rootlist.prototype.getMetadataForRow = function (rowUri) {
  return live(rowUri).query(ROW_QUERY);
};

Rootlist.prototype._subscribeToList = function (handler) {
  var self = this;
  var lastResponseString = '';

  var sub = cosmos.resolver.subscribe({
    url: ENDPOINT,
    body: {
      policy: LIST_POLICY
    }
  }, function (error, response) {
    if (error) {
      return handler(error);
    }

    // We might receive responses that are the same as the last response, so in
    // these cases we can just cancel early since that won't result in any
    // difference. This can happen for example when playlists are synced with
    // the backend on initial load (core has cached data for a playlist that
    // hasn't changed, gets fresh data from backend, doesn't validate it and
    // sends an update to JS).
    if (response.getBody() === lastResponseString) {
      return;
    }
    lastResponseString = response.getBody();

    var body = response.getJSONBody();
    var rows = body && body.rows;

    if (rows) {
      handler(null, self._flatten(rows));
    } else {
      handler(new Error('RootlistError: Bad data'));
    }
  });

  return {
    cancel: function cancel() {
      if (sub) {
        sub.cancel();
        sub = null;
      }
    }
  };
};

Rootlist.prototype._flatten = function (rows, startDepth) {
  var self = this;

  startDepth = startDepth || 0;

  var flattenedRows = [];

  rows.forEach(function (row) {
    flattenedRows.push(row);

    row.rowId = row.rowId.toString();
    row.depth = startDepth;

    if (row.rows) {
      row.type = 'folder';

      flattenedRows = flattenedRows.concat(self._flatten(row.rows, startDepth + 1));

      var folderEndItem = Object.create(row);
      folderEndItem.type = 'folder-end';
      folderEndItem.rowId = row.rowId + '-end';
      flattenedRows.push(folderEndItem);
    } else {
      row.type = 'playlist';
    }
  });

  return flattenedRows;
};

Rootlist.prototype._getExpandedFolders = function () {
  return JSON.parse(localSettings.get('navigationbar.expanded_folders')) || [];
};

Rootlist.prototype._convertManyRowsToLiveFormat = function (rows) {
  var self = this;
  var expandedFolders = self._getExpandedFolders();
  return rows.map(function (row) {
    return self._convertRowToLiveFormat(row, expandedFolders);
  });
};

Rootlist.prototype._convertRowToLiveFormat = function (row, expandedFolders) {
  var currentUsername = session.getUsername();
  var uri = row.link;

  var expanded = false;
  if (row.type === 'folder' || row.type === 'folder-end') {
    var folderUri = liburi.folderURI(currentUsername, row.id).toURI();
    expanded = expandedFolders.indexOf(folderUri) > -1;

    uri = folderUri;

    if (row.type === 'folder-end') {
      uri += ':end';
    }
  }

  var owner = null;
  if (row.owner) {
    var isCurrentUser = row.owner.username === currentUsername;
    if (isCurrentUser) {
      rootlistState.currentUserName = row.owner.name;
    }
    owner = {
      uri: row.owner.link,
      name: row.owner.name,
      username: row.owner.username,
      currentUser: isCurrentUser
    };
  } else if (row.type === 'folder' || row.type === 'folder-end') {
    owner = {
      uri: liburi.profileURI(currentUsername).toURI(),
      name: rootlistState.currentUserName || currentUsername,
      username: currentUsername,
      currentUser: true
    };
  }

  var rowId = row.rowId;
  var rowUri = uri && uri.replace(/^spotify:/, 'spotify:row:' + rowId + ':');

  var activeRow = live('spotify:rootlist').get('activeRow');
  var activeRowUri = activeRow && activeRow.uri;
  var active = activeRowUri === rowUri;

  var liveRowData = {
    uri: rowUri,
    rowId: rowId,
    depth: row.depth,
    hidden: row.type === 'folder-end',
    folderId: row.id || '',
    folderStart: row.type === 'folder',
    folderEnd: row.type === 'folder-end',
    renaming: false,
    deleting: false,
    active: active,
    expanded: expanded,
    playlist: {
      uri: uri,
      name: row.name,
      allows: {
        insertTracks: row.allows ? row.allows.insert : true,
        removeTracks: row.allows ? row.allows.remove : true
      },
      offlineStatus: live(uri).get('offlineStatus') || 'no',
      shouldBeOffline: live(uri).get('shouldBeOffline') || false,
      offlineProgress: live(uri).get('offlineProgress') || 0,
      collaborative: !!row.collaborative,
      added: true,
      owner: owner
    }
  };

  return liveRowData;
};

Rootlist.prototype._callPendingCallbacks = function (error, data) {
  rootlistState.pendingCallbacks.forEach(function (callback) {
    callback(error, data);
  });
  rootlistState.pendingCallbacks.length = 0;
};

Rootlist.prototype._updateHiddenStates = function (list) {
  var isLiveList = list instanceof live.List;

  var expandedFolders = this._getExpandedFolders();

  var expandedTree = [true];
  var depth = 0;

  for (var i = 0, l = list.length; i < l; i++) {
    var row = isLiveList ? list.get(i) : list[i];
    var rowHidden = isLiveList ? row.get('hidden') : row.hidden;
    var rowDepth = isLiveList ? row.get('depth') : row.depth;
    var isFolderStart = isLiveList ? row.get('folderStart') : row.folderStart;
    var isFolderEnd = isLiveList ? row.get('folderEnd') : row.folderEnd;
    var isTreeExpanded = expandedTree[expandedTree.length - 1];
    var hidden = !isTreeExpanded;

    if (isFolderEnd) {
      depth--;
      expandedTree.pop();
    }

    // Update the hidden property only if it actually changed, and the row is
    // either not a folder end marker, or if it is, if the new value is to hide
    // it (since end markers should always be hidden).
    if (hidden !== rowHidden && (!isFolderEnd || hidden)) {
      if (isLiveList) {
        row.update({ hidden: hidden });
      } else {
        row.hidden = hidden;
      }
    }

    if (depth !== rowDepth) {
      if (isLiveList) {
        row.update({ depth: depth });
      } else {
        row.depth = depth;
      }
    }

    if (isFolderStart) {
      depth++;

      var playlist = isLiveList ? row.get('playlist') : row.playlist;
      var folderUri = playlist.uri;
      var isFolderExpanded = expandedFolders.indexOf(folderUri) > -1;
      expandedTree.push(isTreeExpanded && isFolderExpanded);
    }
  }
};

Rootlist.prototype._getRowUriMap = function (list) {
  var rowUriMap = {};
  list.forEach(function (row) {
    var playlistUri = row.get('playlist') && row.get('playlist').uri;
    if (!rowUriMap.hasOwnProperty(playlistUri)) {
      rowUriMap[playlistUri] = row.uri;
    }
  });
  return rowUriMap;
};

Rootlist.prototype._setInitialLiveData = function (liveRowsData) {
  var model = live('spotify:rootlist');
  var list = live(liveRowsData);
  var rowUriMap = this._getRowUriMap(list);

  model.update({ rows: list, rowUriMap: rowUriMap });

  this._onRowsUpdate(model, list);
};

Rootlist.prototype._updateLiveData = function (rows) {
  var self = this;
  var list = live('spotify:rootlist').get('rows');
  if (!list) return;

  var expandedFolders = this._getExpandedFolders();
  var lastRowIds = rootlistState.lastRowIds;
  var rowIds = rows.map(function (row) {
    return row.rowId;
  });

  var indexOfCreateNew = lastRowIds.indexOf('create-new-row');
  if (indexOfCreateNew > -1) {
    var parentId = this._getParentRowId(indexOfCreateNew, lastRowIds);
    var indexOfParentInNewList = rowIds.indexOf(parentId);
    var rowIdAboveInOldList = lastRowIds[indexOfCreateNew - 1] || '';
    var indexAboveInNewList = this._getIndexOfRowIdInParent(rowIdAboveInOldList, indexOfParentInNewList, rows, rowIds);
    rowIds.splice(indexAboveInNewList + 1, 0, 'create-new-row');
  }

  var operations = diff(lastRowIds, rowIds).map(function (operation) {
    if (operation.type === 'insert') {
      // The values of these insert operations are actually the rowIds,
      // which we want to use as keys, and then overwrite the values
      // array with proper row objects.
      operation.keys = operation.values;

      operation.values = operation.values.map(function (rowId) {
        var row = rows[rowIds.indexOf(rowId)];
        return self._convertRowToLiveFormat(row, expandedFolders);
      });
    }
    return operation;
  });

  if (operations.length > 0) {
    list.update(operations);

    var rowUriMap = this._getRowUriMap(list);
    live('spotify:rootlist').update({ rowUriMap: rowUriMap });

    rootlistState.lastRowIds = rowIds;

    this._updateHiddenStates(list);
  }
};

Rootlist.prototype._getParentRowId = function (index, rowIds) {
  var list = live('spotify:rootlist').get('rows');

  var openFolders = 0;

  for (var i = index - 1; i >= 0; i--) {
    var row = list.get(i);
    if (row) {
      if (row.get('folderEnd')) {
        openFolders++;
      }

      if (row.get('folderStart')) {
        if (openFolders === 0) {
          return rowIds[i];
        }
        openFolders--;
      }
    }
  }

  return 'root';
};

Rootlist.prototype._getIndexOfRowIdInParent = function (rowId, parentIndex, rows, rowIds) {
  if (rowIds[parentIndex] === rowId) {
    return parentIndex;
  }

  var openFolders = 0;

  for (var i = parentIndex + 1; i < rows.length; i++) {
    var row = rows[i];
    if (row) {
      if (rowIds[i] === rowId) {
        return i;
      }

      if (row.folderEnd) {
        if (openFolders === 0) {
          return -1;
        }
        openFolders--;
      }

      if (row.folderStart) {
        openFolders++;
      }
    }
  }

  return -1;
};

Rootlist.prototype._postModification = function (modification) {
  cosmos.resolver.post({
    url: ENDPOINT,
    body: modification
  }, function (error) {
    if (error && global.console) {
      console.error(error);
    }
  });
};

Rootlist.prototype._onRowsUpdate = function (model, rows) {
  rootlistState.lastRowIds = rows.map(function (row) {
    if (row.uri === NEW_PLAYLIST_URI || row.uri === NEW_FOLDER_URI) {
      return 'create-new-row';
    }

    return row.get('rowId');
  });
};

Rootlist.prototype._onRowsPublish = function (model, rows, operations) {
  var self = this;

  operations.forEach(function (operation) {
    switch (operation.type) {
      case 'insert':
        self._insert(model, operation);
        break;

      case 'remove':
        self._remove(model, operation);
        break;

      case 'move':
        self._move(model, operation);
        break;

      default:
      // noop
    }
  });
};

Rootlist.prototype._insert = function (model, operation) {
  var list = model.get('rows');
  var uris = operation.values.map(function (row) {
    return row && row.get('playlist') && row.get('playlist').uri;
  });

  var afterRow = list.get(operation.index - 1);
  var afterRowId = afterRow && afterRow.get('rowId');

  var modification = {
    operation: 'add',
    uris: uris
  };

  if (operation.index === 0) {
    modification.before = 'start';
  } else if (afterRowId) {
    modification.after = afterRowId;
  }

  this._postModification(modification);
};

Rootlist.prototype._remove = function (model, operation) {
  var list = model.get('rows');
  var rowIds = new Array(operation.length);

  var start = operation.index;
  var end = start + operation.length;
  for (var i = start, n = 0; i < end; i++, n++) {
    var row = list.get(i);
    rowIds[n] = row && row.get('rowId') || '';
  }

  this._postModification({
    operation: 'remove',
    rows: rowIds,

    // If the row IDs are for folders, we want to remove the contents of the
    // folders as well. Having this extra property for removal of single
    // playlists is OK.
    contents: true
  });
};

Rootlist.prototype._move = function (model, operation) {
  var list = model.get('rows');
  var rowIds = [];

  operation = this._getConvertedMoveOperation(list, operation);

  var start = operation.from;
  var end = operation.from + operation.length;
  var skipFolderCount = 0;
  for (var i = start; i < end; i++) {
    var row = list.get(i);
    if (row) {
      if (skipFolderCount === 0 && !row.get('folderEnd')) {
        rowIds.push(row.get('rowId'));
      }

      if (row.get('folderStart')) {
        skipFolderCount++;
      }

      if (row.get('folderEnd')) {
        skipFolderCount--;
      }
    }
  }

  var toIndex = this._offsetToIndex(operation);

  var afterRow = list.get(toIndex - 1);
  var afterRowId = afterRow && afterRow.get('rowId');

  // Folder end markers don't have any valid row IDs from core, so we can't use
  // them as references. So if we're trying to move something to after a folder
  // end marker, move it to before the next row. We also do this if we for some
  // reason don't have the ID for the previous row.
  var beforeRowId;
  if (!afterRow || afterRow.get('folderEnd')) {
    afterRowId = null;
    var beforeRow = list.get(toIndex);
    beforeRowId = beforeRow && beforeRow.get('rowId');
  }

  var modification = {
    operation: 'move',
    rows: rowIds
  };

  if (toIndex === 0) {
    modification.before = 'start';
  } else if (afterRowId) {
    modification.after = afterRowId;
  } else if (beforeRowId) {
    modification.before = beforeRowId;
  }

  this._postModification(modification);
};

Rootlist.prototype._getConvertedMoveOperation = function (list, operation) {
  var from = operation.from;
  var length = operation.length;
  var to = operation.to;
  var row1;
  var row2;

  var newOperation = operation;

  if (to > from) {
    row1 = list.get(from + length);
    row2 = list.get(to + length - 1);
    if (row1 && row1.get('folderStart') && row2 && row2.get('folderEnd')) {
      newOperation = {
        type: 'move',
        from: from + length,
        length: to - from,
        to: from
      };
    }
  } else {
    row1 = list.get(to);
    row2 = list.get(from - 1);
    if (row1 && row1.get('folderStart') && row2 && row2.get('folderEnd')) {
      newOperation = {
        type: 'move',
        from: to,
        length: from - to,
        to: length + to
      };
    }
  }

  // Handle moving of a folder start or end marker. This operation can be
  // generated when:
  // - Moving a playlist from right after a start marker to right before
  // - Moving a playlist from right before an end marker to right after
  // Since we can't reference the end marker in Core, we need to flip the
  // operation to move the playlist instead. Or if it is a folder that should
  // be moved, move the folder with its contents.
  if (newOperation === operation && operation.length === 1) {
    row1 = list.get(from);
    if (row1) {
      // Generic flip of from/to
      if (row1.get('folderStart') || row1.get('folderEnd')) {
        newOperation = {
          type: 'move',
          from: to,
          length: 1,
          to: from
        };
      }

      // If moving a folder start marker and the flipped operation would move
      // an end marker, include the contents + markers.
      if (row1.get('folderStart')) {
        row2 = list.get(to + length - 1);
        if (row2 && row2.get('folderEnd')) {
          newOperation.from = from + 1;
          newOperation.length = to + length - 1 - from;
        }

        // If moving a folder end marker and the flipped operation would move a
        // start marker, include the contents + markers and change where it's
        // moved to.
      } else if (row1.get('folderEnd')) {
          row2 = list.get(to);
          if (row2 && row2.get('folderStart')) {
            newOperation.length = from - to;
            newOperation.to = to + 1;
          }
        }
    }
  }

  return newOperation;
};

/**
 * The core resolver wants the 'to' index in a move operation to be relative to
 * the list before the operation, but the live operation gave us a 'to' index
 * relative to the list after removing the rows that are to be moved. That
 * means we need to offset the 'to' index by the amount of rows that are before
 * the 'to' index the live operation gives us. As a move operation can only
 * move a single range at once, this means that if the 'to' index is larger than
 * the 'from' index (moving down in the list), we need to offset the index by
 * the amount of items being moved in this operation.
 */
Rootlist.prototype._offsetToIndex = function (operation) {
  if (operation.to > operation.from) {
    return operation.to + operation.length;
  }

  return operation.to;
};

Rootlist.prototype._onRowUpdate = function (model, props) {
  if ('renaming' in props && props.renaming) {
    if (model.get('hidden')) {
      this._expandRowParents(model.uri);
    }
  }

  if ('deleting' in props && props.deleting) {
    if (model.get('hidden')) {
      this._expandRowParents(model.uri);
    }
  }

  if ('active' in props && props.active) {
    if (model.get('hidden')) {
      this._expandRowParents(model.uri);
    }
  }
};

Rootlist.prototype._onFolderRowUpdate = function (model, data) {
  if ('expanded' in data) {
    this._updateHiddenInsideFolder(model.uri, data.expanded);
  }
};

Rootlist.prototype._expandRowParents = function (rowUri) {
  var folderRowUris = [];

  var list = live('spotify:rootlist').get('rows');
  if (!list) return;

  for (var i = 0, l = list.length; i < l; i++) {
    var row = list.get(i);
    if (!row) continue;
    if (row.get('folderStart')) {
      folderRowUris.push(row.uri);
    }
    if (row.get('folderEnd')) {
      folderRowUris.pop();
    }
    if (row.uri === rowUri) {
      break;
    }
  }

  // expand all the parent folders of the row
  folderRowUris.forEach(function (rowUri) {
    live(rowUri).publish({
      expanded: true
    });
  });
};

Rootlist.prototype._updateHiddenInsideFolder = function (rowUri, expanded) {
  var query = 'rows(uri, hidden, folderStart, folderEnd, expanded)';
  var data = live('spotify:rootlist').query(query);

  var thisFolder = data.rows[findIndex(data.rows, { uri: rowUri })];
  if (thisFolder && thisFolder.hidden) return;

  var startUri = rowUri;
  var endUri = startUri.replace(/:row:([^:]+)/, ':row:$1-end') + ':end';
  var start = findIndex(data.rows, { uri: startUri }) + 1;
  var end = findIndex(data.rows, { uri: endUri });

  // expandedTree contains all the parents of the current item
  // in the iteration
  var expandedTree = [true];

  for (var i = start; i < end; i++) {
    var row = data.rows[i];

    if (!expanded) {
      // if we are collapsing a folder, all the items inside it should be
      // hidden
      live(row.uri).update({ hidden: true });
    } else {
      // if we are expanding a folder, for each item we have to check if
      // its parent folder is expanded
      live(row.uri).update({
        hidden: row.folderEnd || !expandedTree[expandedTree.length - 1]
      });

      if (row.folderEnd) {
        expandedTree.pop();
      } else if (row.folderStart) {
        // A folder is shown only if it is expanded
        // and its parent is also expanded
        expandedTree.push(expandedTree[expandedTree.length - 1] && row.expanded);
      }
    }
  }
};

/**
 * This will start subscribing for changes of offline resources.
 *
 * We could have used the playlist live model to do this for us, but we do this
 * instead to be in control of when we perform which operations. By having a
 * global subscriber for all resources, we can efficiently know the status for
 * all playlists even before we have the rootlist loaded, which makes it easy to
 * mix in the offline data into the initial rootlist payload. If this request
 * takes longer than the rootlist request, the rootlist request will use default
 * values for its response. When the data from the initial offline request comes
 * it will update the rootlist data and send a new response. Same for following
 * updates from the offline resolver.
 */
Rootlist.prototype._subscribeForOfflineStatus = function () {
  var url = 'sp://offline/v1/resources';
  cosmos.resolver.subscribe({ url: url }, function (error, response) {
    if (!error) {
      var body = response.getJSONBody();
      var resources = body && body.resources;
      if (resources) {
        for (var i = 0, l = resources.length; i < l; i++) {
          var resource = resources[i];
          var status = resource.offline_availability;

          // Update the live object for the playlist with the new status. The
          // logic in spotify-live-models/playlist will subscribe for progress
          // and update that when needed.
          var playlist = live(resource.uri);
          if (status !== playlist.get('offlineStatus')) {
            var shouldBeOffline = false;
            if (['waiting', 'downloading', 'yes'].indexOf(status) > -1) {
              shouldBeOffline = true;
            }
            var data = {
              offlineStatus: status,
              shouldBeOffline: shouldBeOffline
            };
            if (status === 'yes') data.offlineProgress = 1;
            if (status === 'no') data.offlineProgress = 0;
            playlist.update(data);
          }
        }
      }
    }
  });
};

module.exports = new Rootlist();

// For testing
module.exports._ROW_QUERY = ROW_QUERY;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../../../libs/spotify-live":439,"../../../../libs/spotify-live/util/diff":440,"../live-models/uris":90,"../utils/live-object-differ":124,"./localsettings":100,"./session":107,"mout/array/findIndex":631,"mout/object/merge":666,"spotify-cosmos-api":694,"spotify-liburi":707}],106:[function(require,module,exports){
(function (global){
'use strict';

// This is listeners for messages that apps can send to read or write state
// in sessionStorage. The equivalent app code is live-models/session-storage.

var cosmos = require('spotify-cosmos-api');
var storage = global.sessionStorage;

var registered;

var endpoints = {
  broadcast: 'sp://messages/v1/session-storage'
};

function onMessage(event) {
  var i;
  var key;
  var value;

  switch (event.data.name) {
    case 'set_session_storage':
      var keys = Object.keys(event.data.data);
      for (i = 0; i < keys.length; i++) {
        key = keys[i];
        value = event.data.data[key];

        if (value === undefined) {
          storage.removeItem(key);
        } else {
          storage.setItem(key, value);
        }
      }
      cosmos.resolver.post({ url: endpoints.broadcast, body: event.data.data });
      break;

    case 'broadcast_session_storage':
      // Read requested keys from sessionStorage and broadcast them
      var response = {};
      for (i = 0; event.data.data[i]; i++) {
        key = event.data.data[i];
        response[key] = storage.getItem(key);
      }

      cosmos.resolver.post({ url: endpoints.broadcast, body: response });
      break;

    default:
    // noop
  }
}

function onUnload() {
  // This handles clearing sessionStorage on logout.
  sessionStorage.clear();
}

exports.setup = function () {
  if (registered) return;
  global.window.addEventListener('message', onMessage);
  global.window.addEventListener('unload', onUnload);
  registered = true;
};

exports.unsetup = function () {
  if (!registered) return;
  global.window.removeEventListener(onMessage);
  global.window.removeEventListener('unload', onUnload);
  registered = false;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"spotify-cosmos-api":694}],107:[function(require,module,exports){
'use strict';

var bridgeRequest = require('../../../../libs/spotify-bridge-request').request;
var liburi = require('spotify-liburi');
var cosmos = require('spotify-cosmos-api');
var abba = require('../../../../libs/spotify-abba-mini');

function Session() {
  this._sessionData = {};
}

Session.prototype.setup = function (sessionData) {
  this._sessionData = sessionData || window.__spotify || {};

  var username = this._sessionData.username;
  if (username) {
    this._sessionData.userUri = liburi.profileURI(username).toURI();
  }
};

Session.prototype.getUsername = function () {
  return this._sessionData.username;
};

Session.prototype.getUserUri = function () {
  return this._sessionData.userUri;
};

Session.prototype.get = function (key) {
  return this._sessionData[key];
};

Session.prototype.getProductState = function (key) {
  if (key && this._sessionData.product_state) {
    return this._sessionData.product_state[key];
  }
  return this._sessionData.product_state;
};

Session.prototype.isDeveloper = function () {
  return devModeEnabled;
};

Session.prototype.isPremium = function () {
  return this.getProductState('type') === 'premium';
};

Session.prototype.getArtistAsync = function (callback) {
  // add abba flag for rendering this
  abba.subscribe('your-artists-sidebar', function (err, cell) {
    if (cell !== 'Rollout') {
      return callback();
    }
    cosmos.resolver.get('hm://artist-identity-view/v0/authorized', function (error, response) {
      if (response) {
        var statusCode = response.getStatusCode();
        var data = response.getJSONBody();
        if (statusCode === 200 && data) {
          this._sessionData.artistData = data;
        }
      }
      return callback(this._sessionData.artistData);
    }.bind(this));
  }.bind(this));
};

/**
 * Get OAuth Token
 *
 * @param url The url that needs a token
 * @param {Function} callback Callback to invoke with token as parameter.
 */
Session.prototype.getOAuthToken = function (url, callback) {
  var timeout = 300;
  var done = false;

  bridgeRequest('client_get_web_token', [url], function (error, response) {
    if (!done) {
      done = true;
      callback(error, response && response.token);
    }
  });

  setTimeout(function () {
    if (!done) {
      done = true;
      callback(new Error('No response from bridge'));
    }
  }, timeout);
};

module.exports = new Session();

},{"../../../../libs/spotify-abba-mini":181,"../../../../libs/spotify-bridge-request":253,"spotify-cosmos-api":694,"spotify-liburi":707}],108:[function(require,module,exports){
/*
 * Event handler that converts navigation messages to navigation zlink events.
 */
'use strict';

var eventDispatcher = require('../../../libs/spotify-event-dispatcher');
var Navigator = require('../../../libs/spotify-navigation/navigator');
var Event = require('./event');

var nav = new Navigator();
nav.attachListener();

function eventHandler(originalEvent) {
  var appState = originalEvent.state;
  var event = new Event(Event.TYPES.NAVIGATION_OPEN_URI, appState.getURI(), {
    referrer: appState.getReferrer()
  });
  eventDispatcher.dispatchEvent(event);
}

var isAttached = false;

exports.attach = function attach() {
  if (isAttached) {
    return;
  }
  isAttached = true;
  nav.addListener(Navigator.EVENTS.OPEN_STATE, eventHandler);
};

exports.detach = function detach() {
  if (!isAttached) {
    return;
  }
  isAttached = false;
  nav.removeListener(Navigator.EVENTS.OPEN_STATE, eventHandler);
};

exports.update = function () {};

},{"../../../libs/spotify-event-dispatcher":264,"../../../libs/spotify-navigation/navigator":464,"./event":77}],109:[function(require,module,exports){
'use strict';

var CosmosMessagesHandler = require('./cosmosmessageshandler');
var Event = require('./event');
var utils = require('./utils');

/**
 * Handles cosmos messages coming from the
 * sp://offline/v1/error endpoint
 * and triggers a OfflineErrorEvent when such messages are
 * received
 */
function OfflineErrorHandler() {
  CosmosMessagesHandler.apply(this, arguments);
}

utils.inherit(OfflineErrorHandler, CosmosMessagesHandler);

OfflineErrorHandler.prototype.setup = function () {
  this.init('sp://offline/v1/error');
};

OfflineErrorHandler.prototype.buildEvent = function (msg) {
  var error;
  if (msg && msg.getJSONBody) {
    error = msg.getJSONBody().error;
  } else {
    error = { code: msg };
  }

  return new Event(Event.TYPES.CONNECTION_OFFLINE_ERROR, error);
};

module.exports = new OfflineErrorHandler();

},{"./cosmosmessageshandler":75,"./event":77,"./utils":120}],110:[function(require,module,exports){
'use strict';

var live = require('../../../libs/spotify-live');
var eventDispatcher = require('../../../libs/spotify-event-dispatcher');
var events = require('./event').TYPES;
var uriHelper = require('./urihelper');

var AUTO_PLAY_REGEX = /^http[s]?:\/\/open\.spotify\.com\/.+autoplay=true/;

/**
 * Handles auto playing of links to open.spotify.com that contains
 * ?autoplay=true
 *
 * @constructor
 * @param {Object} bridge Bridge instance to use.
 * @param {Object} player The player instance to use.
 */
function OpenUriAutoPlayHandler(bridge, player) {
  this._bridge = bridge;
  this._player = player;
}

/**
 * Start listening for navigation events
 */
OpenUriAutoPlayHandler.prototype.start = function () {
  if (typeof this._listener === 'undefined') {
    this._listener = eventDispatcher.addEventListener(events.NAVIGATION_OPEN_URI, this._onUriOpened.bind(this));
  }
};

/**
 * Stop listening for navigation events
 */
OpenUriAutoPlayHandler.prototype.stop = function () {
  if (typeof this._listener !== 'undefined') {
    eventDispatcher.removeEventListener(events.NAVIGATION_OPEN_URI, this._listener);
    this._listener = undefined;
  }
};

/**
 * Callback for when a uri has been opened.
 *
 * @param {Event} e The event triggered.
 */
OpenUriAutoPlayHandler.prototype._onUriOpened = function (e) {
  if (AUTO_PLAY_REGEX.test(e.params)) {
    this._play(uriHelper.toURI(e.params));
  }
};

/**
 * Helper function to query for track metadata.
 *
 * @param {String} uri The track uri.
 * @return {Promise} Resolved with the track data.
 */
OpenUriAutoPlayHandler.prototype._queryTrack = function (uri) {
  return new Promise(function (resolve, reject) {
    live(uri).query('disc, number, album(discs(rows), uri)', function (error, track) {
      if (error) {
        reject(error);
      } else {
        resolve(track);
      }
    });
  });
};

/**
 * Start playback for a given spotify uri.
 *
 * @param {String} uri The spotify uri to play.
 */
OpenUriAutoPlayHandler.prototype._play = function (uri) {
  if (uri.indexOf('spotify:track:') === 0) {
    this._playTrack(uri);
  } else {
    this._playContext(uri);
  }
};

/**
 * Play a track.
 *
 * Looks up the correct track position within the album and plays the track
 * from the album context.
 *
 * @param {String} uri The track uri.
 */
OpenUriAutoPlayHandler.prototype._playTrack = function (uri) {
  var _this = this;
  this._queryTrack(uri).then(function (track) {
    var indexWithinDisc = track.number - 1;
    var discsBefore = track.album.discs.slice(0, track.disc - 1);
    var numTracksBeforeDisc = discsBefore.reduce(function (count, disc) {
      return count + disc.rows.length;
    }, 0);
    var index = numTracksBeforeDisc + indexWithinDisc;
    _this._playContext(track.album.uri, index);
  }).catch(function (error) {
    throw error;
  });
};

/**
 * Play a context, optionally given an index within the context.
 *
 * If index is not provided the player will default to playing the first track
 * in the context, given shuffle is not enabled.
 *
 * @param {String} context The context, for example 'spotify:artist:foo'.
 * @param {Number?} index Index of the track to play in the context, optional.
 */
OpenUriAutoPlayHandler.prototype._playContext = function (context, index) {
  var data = {
    context: context
  };
  if (typeof index !== 'undefined') {
    data.index = index;
  }
  this._player.emit('play', data);
};

module.exports = OpenUriAutoPlayHandler;

},{"../../../libs/spotify-event-dispatcher":264,"../../../libs/spotify-live":439,"./event":77,"./urihelper":117}],111:[function(require,module,exports){
'use strict';

/**
 * Make player elements optionally bounce focus back to whatever element had it
 * before the user clicked in the player view.
 */

var $ = require('../../../libs/spotify-elements');
var glue = require('../../../libs/spotify-glue-cat');

var playerViewId = glue.getVersion() === 1 ? 'view-player' : 'view-player-glue2';

function PlayerFocusBounceHandler() {
  this._updateLastActiveElement = this._updateLastActiveElement.bind(this);
  this._handleBlur = this._handleBlur.bind(this);
  this._handleMouseUp = this._handleMouseUp.bind(this);
}

PlayerFocusBounceHandler.prototype.start = function () {
  window.addEventListener('blur', this._handleBlur, true);
  window.addEventListener('focus', this._updateLastActiveElement, true);

  $('#' + playerViewId).on('mouseup', this._handleMouseUp);
};

PlayerFocusBounceHandler.prototype.stop = function () {
  window.removeEventListener('blur', this._handleBlur, true);
  window.removeEventListener('focus', this._updateLastActiveElement, true);

  $('#' + playerViewId).off('mouseup', this._handleMouseUp);
};

PlayerFocusBounceHandler.prototype._handleBlur = function (event) {
  // Only update `document.activeElement` if window is being blurred, as all
  // other changes are tracked by the `focus` handler.
  if (event.target === window) {
    this._updateLastActiveElement(event);
  }
};

PlayerFocusBounceHandler.prototype._handleMouseUp = function () {
  if (this.lastActiveElement) {
    this.lastActiveElement.focus();
  }
};

PlayerFocusBounceHandler.prototype._updateLastActiveElement = function () {
  var isValid = document.activeElement && !document.activeElement.hasAttribute('data-non-active-element') && document.activeElement !== document.body;

  if (isValid) {
    this.lastActiveElement = document.activeElement;
  }
};

module.exports = PlayerFocusBounceHandler;

},{"../../../libs/spotify-elements":259,"../../../libs/spotify-glue-cat":348}],112:[function(require,module,exports){
'use strict';

var bridge = require('../../../libs/spotify-bridge-request');
var ClientEvent3 = require('../../../libs/spotify-logger/messages/ClientEvent3');

exports.init = function () {
  // These are the only preferences we're interested in
  var preferencesToLog = ['ui.show_friend_feed', 'ui.show_unplayable_tracks'];

  bridge.request('preferences_all', [], function (error, preferences) {
    var data = {};
    preferencesToLog.forEach(function (preferenceToLog) {
      data[preferenceToLog] = preferences[preferenceToLog];
    });

    // Log initial values of tracked preferences
    ClientEvent3.log({
      source: 'spotify:app:zlink',
      event_version: 'preferences',
      event: 'user:impression',
      json_data: data
    });

    var onPreferencesWait = function onPreferencesWait(error, changedPreferences) {
      if (error) {
        console.error(error);
        return setTimeout(sub, 1000);
      }

      var isAnyPreferenceChanged = preferencesToLog.some(function (preferenceToLog) {
        return preferences[preferenceToLog] !== changedPreferences[preferenceToLog];
      });

      if (isAnyPreferenceChanged) {
        var data = {};
        preferencesToLog.forEach(function (preferenceToLog) {
          if (preferences[preferenceToLog] !== changedPreferences[preferenceToLog]) {
            data[preferenceToLog] = changedPreferences[preferenceToLog];
          }
        });

        // Log whenever a tracked value changes
        ClientEvent3.log({
          source: 'spotify:app:zlink',
          event_version: 'preferences-change',
          event: 'user:hit',
          json_data: data
        });
        preferences = changedPreferences;
      }
      sub();
    };

    var sub = bridge.request.bind(null, 'preferences_event_wait', [], onPreferencesWait);
    sub();
  });
};

},{"../../../libs/spotify-bridge-request":253,"../../../libs/spotify-logger/messages/ClientEvent3":451}],113:[function(require,module,exports){
'use strict';

var eventDispatcher = require('../../../libs/spotify-event-dispatcher');
var liburi = require('spotify-liburi');
var shuffleMode = require('../../../libs/spotify-shuffle-mode');
var Event = require('./event');
var uriHelper = require('./urihelper');
var routeValidator = require('./routevalidator');
var session = require('./models/session');
var Cosmos = require('spotify-cosmos-api');
var live = require('../../../libs/spotify-live');
var Player = require('./models/player');
var sortUri = require('../../../libs/spotify-live-sort-uri');
var abbaSubscriber = require('./utils/abba-subscriber');
var pageLogger = require('../../../libs/spotify-page-logger');
var AppState = require('../../../libs/spotify-navigation/app-state');

var OFFLINE_TIMEOUT = require('./connectionmonitor').offlineTimeout;

/**
 * Router used to map Spotify URIs to functions to execute.
 *
 * @param {Bridge} The bridge to use.
 * @param {History} The history manager to use.
 * @constructor
 */
function Router(bridge, history) {
  /**
   * The bridge to use.
   *
   * @type {Bridge}
   */
  this._bridge = bridge;

  /**
   * The history manager to use.
   *
   * @type {History}
   */
  this._history = history;

  /**
   * URIs blacklisted from being saved in the history stack
   *
   * @type {Array}
   */
  this._historyBlacklist = [/spotify:(app:)?share/, /spotify:(app:)?feedback/, /spotify:(app:)?about/];

  /**
   * Determines whether discover should be redirected to browse or not.
   *
   * @type {Boolean}
   */
  this._redirectDiscoverToBrowse = false;

  /**
   * Determines whether charts as formats should be render as chart app.
   *
   * @type {Boolean}
   */
  this._hasChartV2Support = false;

  /**
   * Initialization functionality
   */
  this.lastOpenAppState = null;

  eventDispatcher.addEventListener(Event.TYPES.NAVIGATION_OPEN_URI, this._onOpenURI.bind(this));

  eventDispatcher.addEventListener(Event.TYPES.NAVIGATION_LOGOUT, this._logout.bind(this));

  eventDispatcher.addEventListener(Event.TYPES.NAVIGATION_SHOW_PREFERENCES, this.route.bind(this, new AppState('spotify:app:settings')));

  eventDispatcher.addEventListener(Event.TYPES.NAVIGATION_SHOW_LICENSING_INFORMATION, this._onOpenExternalSpotifyURL.bind(this, 'https://www.spotify.com/int/legal/licensing-info/'));

  eventDispatcher.addEventListener(Event.TYPES.NAVIGATION_SHOW_SCTA_INFORMATION, this._onOpenExternalSpotifyURL.bind(this, 'https://www.spotify.com/int/legal/specified-commercial-transactions'));

  eventDispatcher.addEventListener(Event.TYPES.NAVIGATION_SHOW_HELP, this._onOpenExternalSpotifyURL.bind(this, 'https://www.spotify.com/help'));

  eventDispatcher.addEventListener(Event.TYPES.NAVIGATION_SHOW_COMMUNITY, this._onOpenExternalSpotifyURL.bind(this, 'https://www.spotify.com/lithium/accept'));

  eventDispatcher.addEventListener(Event.TYPES.NAVIGATION_SHOW_ACCOUNT, this._onOpenExternalSpotifyURL.bind(this, 'https://www.spotify.com/redirect/account-page'));

  eventDispatcher.addEventListener(Event.TYPES.NAVIGATION_UPGRADE, this._onOpenExternalSpotifyURL.bind(this, 'https://www.spotify.com/redirect/upgrade-product'));
}

/**
 * The uri to be open when the client is initiated
 */
Router.DEFAULT_INITIAL_URI = 'spotify:app:browse';

/**
 * Maps the name of the app with the name of the method that has to be called
 * for logging the page view.
 */
Router.PAGE_LOGGER_MAP = {
  'album': 'album',
  'artist': 'artist',
  'browse': 'browse',
  'charts': 'charts',
  'collection': 'collection',
  'collection-songs': 'collectionSongs',
  'collection-albums': 'collectionAlbums',
  'collection-album': 'collectionAlbumsAlbum',
  'collection-artists': 'collectionArtists',
  'collection-artist': 'collectionArtistsArtist',
  'inbox': 'messages',
  'playlist-desktop': 'playlist',
  'profile': 'profile',
  'radio': 'radio',
  'radio-hub': 'radio',
  'search': 'search',
  'station': 'radioStation',
  'stations': 'collectionRadio'
};

/**
 * Logs the user out, clears the user cache and redirects to the login screen
 **/
Router.prototype._logout = function () {
  this._bridge.request('logout');
};

/**
 * Callback used when an open_uri message is received
 * @param Event e
 */
Router.prototype._onOpenURI = function (e) {
  if (!e.params) {
    return;
  }

  var uri = e.params;
  var extra = e.extra || {};
  if (!extra.origin) {
    extra.origin = 'navigation';
  }
  if (!extra.toggle) {
    extra.toggle = false;
  }

  var appState = new AppState(uri);

  if (extra.context) {
    this.replaceHistoryState(appState, extra.context, extra.origin);
  } else if (extra.toggle) {
    this.toggle(appState);
  } else {
    this.route(appState, true, extra.origin);
  }
};

/**
 * Open an external Spotify URL, which requires an OAuth token.
 * @param {String} url - The URL to be opened.
 * @param {String} e - (optional) Tracking params to be appended
 */
Router.prototype._onOpenExternalSpotifyURL = function (url, e) {
  session.getOAuthToken(url, function (err, token) {
    if (err) {
      return;
    }

    if (e.params.tracking) {
      window.open(url + '?' + e.params.tracking + '&' + token);
    } else {
      window.open(url + '?' + token);
    }
  });
};

/**
 * Subscribe to ABBA updates for the hubs-embed-discover-app test
 */
Router.prototype._subscribeToEmbedDiscoverApp = function () {
  abbaSubscriber('hubs-embed-discover-app', function (cell) {
    this._redirectDiscoverToBrowse = cell === 'Embedded';
  }.bind(this));
};

/**
 * Route a requested URI
 *
 * @param {String} regex String to match for callback.
 * @param {Boolean?} save Push to history? Defaults to yes.
 * @param {String} source The source of the request, 'bridge' or 'navigation'.
 *     Defaults to 'navigation'.
 */
Router.prototype.route = function (appState, save, source) {
  if (appState instanceof AppState === false) {
    throw new TypeError('AppState object expected');
  }

  if (typeof save === 'undefined') {
    save = true;
  }
  if (typeof source === 'undefined') {
    source = 'navigation';
  }

  // If the uri looks like an HTTP link, try to parse it as a Spotify URI.
  var uri = appState.getURI();
  if (/^https?:\/\//.test(uri)) {
    try {
      uri = uriHelper.toURI(uri);
      appState.setURI(uri);
    } catch (e) {
      // If as Spotify URI failed, open as regular URL.

      // An empty string for NowPlaying.TrackURI results in
      // the URI being set to window.location.href
      // so this detects blank URIs and prevents
      // a blank window opening
      if (uri === window.location.href) {
        return;
      }

      window.open(uri);
      return;
    }
  }

  var self = this;
  this._processRequest(appState, function (appState) {
    var uri = appState.getURI();

    if (!routeValidator.validate(uri, source)) {
      return;
    }

    var appId = appState.getAppId();
    if (!appId) {
      return;
    }

    // Exit old view.
    pageLogger[self._pageLoggerView || 'unknown'](pageLogger.TYPE_EXIT, self.lastOpenAppState && self.lastOpenAppState.getURI() || null);

    // Cache new view.
    self._pageLoggerView = Router.PAGE_LOGGER_MAP[appId];

    // Enter new view.
    pageLogger[self._pageLoggerView || 'unknown'](pageLogger.TYPE_ENTER, uri);

    if (!self.isHistoryBlackListed(uri)) {
      self.lastOpenAppState = appState;

      if (save) {
        self._history.push(appState);
      }
    }
    eventDispatcher.dispatchEvent(new Event(Event.TYPES.NAVIGATION_STATE_CHANGE, {
      uri: uri,
      state: appState
    }));
  });
};

/**
 * Toggles navigation to the provided app URI. If the app is not the current
 * opened one, it will navigate to it. Otherwise, it will navigate back
 * until a different app is loaded.
 *
 * @param {String} uri Spotify app URI.
 */
Router.prototype.toggle = function (appState) {
  var currentApp = this.lastOpenAppState.getAppId();
  var toggledApp = appState.getAppId();

  if (currentApp && toggledApp && currentApp === toggledApp) {
    // Navigate back until a different app is found using recursion.
    this.toggle(this._history.back());
  } else {
    this.route(appState);
  }
};

/**
 * Route to a requested URI while replacing the specified uri in history
 *
 * @param {String} uri Spotify uri.
 * @param {String} context The context to match.
 * @param {String} source The source of the request, 'bridge' or 'navigation'.
 */
Router.prototype.replaceHistoryState = function (appState, context, source) {
  try {
    appState.setURI(uriHelper.toURI(appState.getURI()));
  } catch (e) {
    // Unable to convert HTTP URL to spotify URI
    return;
  }

  var self = this;
  this._processRequest(appState, function (appState) {
    var uri = appState.getURI();
    if (!routeValidator.validate(uri, source)) {
      return;
    }

    // Don't allow non-app URIs to be routed. Check with regexp instead of
    // liburi, since liburi defaults the type to application.
    if (!appState.getAppId()) {
      return;
    }

    if (!self.isHistoryBlackListed(uri)) {
      self._history.replace(appState, context);
    }
    eventDispatcher.dispatchEvent(new Event(Event.TYPES.NAVIGATION_STATE_CHANGE, {
      uri: uri,
      state: appState
    }));
  });
};

var ignoreBlacklistedUri = function ignoreBlacklistedUri(uri) {
  console.log('Ignoring blacklisted URI:', uri);
};

// How to process different URIs
var uriHandling = [
// Block inception behaviour - Blacklisted URIs
[/^spotify:app:zlink$/, ignoreBlacklistedUri], [/^spotify:app:zlogin$/, ignoreBlacklistedUri],

// Convert playlist uri to it's canonical URI
[/^spotify:user:([^:]+):(playlist:(.+))$/, function (appState, matches, callback) {
  if (this._hasChartV2Support) {
    this._fetchFormatListType(appState.getURI(), function (formatType) {
      if (formatType === 'chart') {
        appState.setURI(uriHelper.chartCanonicalURI(appState.getURI()));
      } else {
        appState.setURI(uriHelper.playlistCanonicalURI(appState.getURI()));
      }
      callback(appState);
    });
  } else {
    appState.setURI(uriHelper.playlistCanonicalURI(appState.getURI()));
    callback(appState);
  }
}],

// Redirect special/promotional uris to hub
[/^spotify:(special:(.+))$/, function (appState, matches, callback) {
  appState.setURI('spotify:app:hub:' + matches[1]);
  callback(appState);
}],

// Redirect charts to browse
[/^spotify:app:charts$/, function (appState, matches, callback) {
  appState.setURI('spotify:app:browse:charts');
  callback(appState);
}],

// Maybe redirect discover to browse
[/^spotify:app:discover$/, function (appState, matches, callback) {
  if (this._redirectDiscoverToBrowse) {
    appState.setURI('spotify:app:browse:discover');
  }
  callback(appState);
}],

// Convert folder uri to it's folder view app URI
[/^spotify:user:([^:]+):folder:(.+)$/, function (appState, matches, callback) {
  appState.setURI(uriHelper.folderCanonicalURI(appState.getURI()));
  callback(appState);
}],

// Convert collection links to collection sub-apps links
[/^spotify:user:([^:]+):collection:(.+):(.+)$/, function (appState, matches, callback) {
  appState.setURI('spotify:app:collection-' + matches[2] + ':' + matches[3]);
  callback(appState);
}],

// Convert users collection to collection
[/^spotify:user:([^:]+):collection:?(.*)$/, function (appState, matches, callback) {
  if (!matches[2] || matches[2] === 'songs') {
    appState.setURI('spotify:app:collection-songs');
  } else if (matches[2] === 'stations') {
    appState.setURI('spotify:app:stations');
  } else {
    appState.setURI('spotify:app:collection:' + matches[2]);
  }
  callback(appState);
}],

// Convert user URIs to open on profile app
[/^spotify:user:([^:]+)$/, function (appState, matches, callback) {
  appState.setURI('spotify:app:profile:' + matches[1]);
  callback(appState);
}],

// Convert internal localfiles URI to the app URI
// TODO: This should be done properly as written in
// https://ghe.spotify.net/zelda/playlist-desktop/pull/52
[/^spotify:internal:local-files$/, function (appState, matches, callback) {
  appState.setURI('spotify:app:playlist-desktop:local-files');
  callback(appState);
}],

// Convert track to album with track appended
[/^(spotify:track:([^#]+))(#([0-9]+:[0-9]+))?/, function (appState, matches, callback) {
  this._processTrackRequest(appState, matches, callback);
}], [sortUri.regExp, function (appState, matches, callback) {
  var uri = sortUri.getOriginUri(appState.getURI());
  if (uri) {
    appState.setURI(uriHelper.playlistCanonicalURI(uri));
    callback(appState);
  }
}],

// Open about in a popup
[/^spotify:app:share/, function (appState) {
  eventDispatcher.dispatchEvent(new Event(Event.TYPES.NAVIGATION_SHOW_SHARE, appState.getURI()));
}], [/^spotify:app:about$/, function () {
  eventDispatcher.dispatchEvent(new Event(Event.TYPES.NAVIGATION_SHOW_ABOUT));
}], [/^spotify:app:feedback$/, function () {
  eventDispatcher.dispatchEvent(new Event(Event.TYPES.NAVIGATION_SHOW_FEEDBACK));
}], [/^spotify:app:full-screen-modal:(.*)$/, function (appState) {
  eventDispatcher.dispatchEvent(new Event(Event.TYPES.NAVIGATION_SHOW_FULL_SCREEN_MODAL, appState.getURI()));
}], [/^spotify:app:follow$/, function () {
  console.warn('The \'follow\' app no longer exists. ' + 'Please change all links to \'findfriends\'.');
  eventDispatcher.dispatchEvent(new Event(Event.TYPES.NAVIGATION_SHOW_FIND_FRIENDS));
}], [/^spotify:app:licenses$/, function () {
  eventDispatcher.dispatchEvent(new Event(Event.TYPES.NAVIGATION_SHOW_LICENSES));
}], [/^spotify:ad:(.+)$/, function (appState, matches, callback) {
  this._processAdRequest(appState, matches, callback);
}], [/^spotify:app:radio$/, function (appState, matches, callback) {
  appState.setURI('spotify:app:radio-hub');
  callback(appState);
}], [/^spotify:radio:(.+)$/, function (appState, matches, callback) {
  // No args, like 'spotify:radio', come through as '0'.
  if (!matches[1] || matches[1] === '0') {
    appState.setURI('spotify:app:radio-hub');
  } else {
    appState.setURI('spotify:app:station:' + matches[1]);
  }
  callback(appState);
}]];

['artist', 'album', 'station', 'search'].forEach(function (app) {
  uriHandling.push([new RegExp('^spotify:' + app + ':(.+)$'), function (appState, matches, callback) {
    appState.setURI('spotify:app:' + app + ':' + matches[1]);
    callback(appState);
  }]);
});

/**
 * Do additional processing to spotify URIs if needed
 *
 * @param {String} uri The URI to process.
 * @param {Function} callback Callback to execute with rewritten URI.
 */
Router.prototype._processRequest = function (appState, callback) {
  var matches;
  var uri = appState.getURI();

  for (var i = 0; i < uriHandling.length; i++) {
    var regex = uriHandling[i][0];
    var handlingFunction = uriHandling[i][1];
    matches = regex.exec(uri);
    if (matches) {
      return handlingFunction.call(this, appState, matches, callback);
    }
  }

  return callback(appState);
};

/**
 * Processes URIs such as spotify:ad:<gid> to check whether we are displaying
 * and ad page or previewing an ad.
 *
 * @param  {String} uri The URI to process.
 * @param  {Array} matches Array with the parts of a Spotify URI.
 * @param  {Function} callback Callback to execute with rewritten URI.
 */
Router.prototype._processAdRequest = function (appState, matches, callback) {
  var username = session.getUsername();
  var resolver = Cosmos.resolver;
  var base62Id = matches[1];
  var hexId = liburi.idToHex(base62Id);

  resolver.get('hm://asp/v1/adpage?username=' + username + '&ip=127.0.0.1&gid=' + hexId, function (err, res) {
    if (err || !res || res.getStatusCode() !== 200) {
      var previewRequest = new Cosmos.Request('POST', 'sp://ads/v1/preview/' + hexId, null, {});
      resolver.resolve(previewRequest, function () {});
    } else {
      appState.setURI('spotify:app:ad:' + hexId);
      callback(appState);
    }
  });
};

/**
 * When the user tries to open a track URI the router should redirect
 * the view to the album view that contains that track and if nothing
 * is being played, initialize the playback of the track.
 *
 * It should also seek to the specified timestamp, if it is passed.
 */
Router.prototype._processTrackRequest = function (appState, matches, callback) {
  var trackURI = matches[1];
  var trackId = matches[2];
  var timestamp = matches[4];
  var uri = appState.getURI();
  var self = this;
  live(trackURI).query('album(uri)', function (err, data) {
    if (err) {
      console.error('Failed to get track metadata for track', uri, err);
      callback(uri);
      return;
    }
    var albumURI = data.album.uri;

    appState.setURI(albumURI + ':' + trackId);

    // Load Album view with the track selected
    self._processRequest(appState, callback);

    // [SHUFFLE] Don't auto play opened track
    if (shuffleMode.isEnabled()) {
      return;
    }

    // If a timestamp is specified, start playing the track
    if (timestamp) {
      // Fetch album tracks in order to create a context
      // to be passed to the player api.
      //
      // We use the player api instead of using live for playback
      // due to the fact that live-models use cosmos player v1 and it
      // doesn't support seeking.
      live(albumURI).query('rows(track(uri))', function (err, data) {
        if (err) return;

        // Build the context to pass to the player api
        var tracks = data.rows.map(function (row) {
          return { uri: row.track.uri };
        });
        var context = {
          'entity_uri': albumURI,
          'pages': [{
            'tracks': tracks
          }]
        };
        var options = {
          'skip_to': {
            'track_uri': trackURI
          }
        };
        var player = Player.getPlayer();

        player.play(context, options, function (err) {
          if (err) return;

          // Seek to the timestamp
          var timestampComponents = timestamp.split(':');
          var seconds = parseInt(timestampComponents[1] || 0, 10);
          var minutes = parseInt(timestampComponents[0] || 0, 10);
          var timestampInMs = (minutes * 60 + seconds) * 1000;
          player.seekTo(timestampInMs);
        });
      });
    }
  });
};

/**
 * Check if given URI is blacklisted from being saved in the history stack.
 *
 * @param {String} uri The Spotify URI to check.
 * @return {Boolean} Blacklisted or not.
 */
Router.prototype.isHistoryBlackListed = function (uri) {
  for (var i = 0; i < this._historyBlacklist.length; i++) {
    if (this._historyBlacklist[i].test(uri)) {
      return true;
    }
  }
  return false;
};

/**
 * Load the initial view. Should only be called if no other view
 * has been loaded yet.
 */
Router.prototype.loadInitialView = function () {
  var appState;
  if (session.isDeveloper()) {
    appState = this._history.getLastState();
  }
  if (!appState) {
    appState = new AppState(Router.DEFAULT_INITIAL_URI);
  }
  this.route(appState);
};

/**
 * Handler for when the connection state changes.
 *
 * @param {ConnectionStateChangeEvent} e A change event.
 */
Router.prototype._handleConnectionStateChange = function (e) {
  if (e.params.status === 'online') {
    this.onFirstOnline();
  }
};

/**
 * Called when you go online the first time.
 * This will load the initial view if nothing has been loaded before.
 */
Router.prototype.onFirstOnline = function () {
  eventDispatcher.removeEventListener(Event.TYPES.CONNECTION_STATE_CHANGE, this._handleConnectionStateChangeBound);
  clearTimeout(this._connectionTimer);

  this._fetchInitialRoutingFlags(function () {
    this._subscribeToEmbedDiscoverApp();

    if (!this.lastOpenAppState) {
      this.loadInitialView();
    }
  }.bind(this));
};

Router.prototype._fetchInitialRoutingFlags = function (callback) {
  abbaSubscriber.fetchFlags(['hubs-embed-discover-app', 'ab-charts-v2'], function (cells) {
    this._redirectDiscoverToBrowse = cells['hubs-embed-discover-app'] === 'Embedded';
    this._hasChartV2Support = cells['ab-charts-v2'] === 'Enabled';
    callback();
  }.bind(this));
};

Router.prototype._fetchFormatListType = function (uri, callback) {
  live(uri).query('formatListType', function (error, data) {
    if (error) {
      callback('playlist');
      return;
    }

    callback(data.formatListType ? data.formatListType : 'playlist');
  });
};

/**
 * Initialize the router loading the last saved state, or the default initial
 * URI if none is saved.
 * We must first check connection status, to delay loading of the initial view
 * until connection has been established.
 */
Router.prototype.init = function () {
  this._handleConnectionStateChangeBound = this._handleConnectionStateChange.bind(this);
  eventDispatcher.addEventListener(Event.TYPES.CONNECTION_STATE_CHANGE, this._handleConnectionStateChangeBound);

  var self = this;
  this._connectionTimer = setTimeout(function () {
    self.onFirstOnline();
  }, OFFLINE_TIMEOUT);
};

module.exports = Router;

},{"../../../libs/spotify-event-dispatcher":264,"../../../libs/spotify-live":439,"../../../libs/spotify-live-sort-uri":437,"../../../libs/spotify-navigation/app-state":462,"../../../libs/spotify-page-logger":482,"../../../libs/spotify-shuffle-mode":491,"./connectionmonitor":73,"./event":77,"./models/player":101,"./models/session":107,"./routevalidator":114,"./urihelper":117,"./utils/abba-subscriber":121,"spotify-cosmos-api":694,"spotify-liburi":707}],114:[function(require,module,exports){
/**
 * The purpose of the route validator is to keep track of URIs opened in iframes
 * and validate whether opening a URI later should be allowed.
 *
 * The problem we aim to avoid is navigating to a URI as a response to setting
 * an iframe to that URI. This can happen because when the iframe src is set, we
 * will get a bridge event that tells us to open a URI. The same event can be
 * triggered by clicking a link though, in which case we want to allow
 * navigation.
 *
 * The solution to this is basically to keep a count of navigations per URI and
 * decrement the counter when the response for setting the iframe src is
 * received. If the counter is more than 0 and bridge tells us to open a URI,
 * it's most likely the response, so we decrement the counter and stop
 * navigation to that URI. This can produce false negatives if the user clicked
 * a link to a URI in between opening that URI before and receiving the response
 * for it. As this is not that likely to happen, it's okay.
 *
 * The situation is roughly this:
 *
 * 1. App is requested, so an iframe is created and the right URI is set as the
 *    iframe src. When the iframe src is set, the count for the URI is
 *    incremented here.
 * 2. Right after creating the app, the count is decremented, as we won't
 *    receive any response from bridge that the iframe src changed when it was
 *    set for the first time.
 * 3. Navigating to the same app with other arguments will increment the counter
 *    for that URI (with the new arguments).
 * 4. Since the iframe existed and just changed src, bridge will send an
 *    open_uri event down to zlink.
 * 5. The router handles the open_uri event, processes the URI and then checks
 *    with the route validator if the route is valid. The route is always valid
 *    unless the route request originates from bridge and the counter for the
 *    URI is more than 0.
 * 6. Since the request in this example came from bridge (step 4) and the
 *    counter is at 1, the counter is decremented to 0 and the route is deemed
 *    invalid.
 * 7. Since the route is invalid, nothing more happens. If the route would have
 *    been valid, the process starts over at step 3.
 *
 * The full flow for the following user actions is listed below:
 * - Go to spotify:app:foo
 * - Go to spotify:app:foo:bar
 * - Go to spotify:app:foo:baz
 * - Go to spotify:app:foo:bar
 *
 *  1. Navigate to spotify:app:foo
 *  2. Fully route spotify:app:foo
 *  3. Increment count for spotify:app:foo
 *     count: 1
 *  4. App spotify:app:foo created
 *  5. Decrement count for spotify:app:foo
 *     count: 0
 *  6. Navigate to spotify:app:foo:bar
 *  7. Fully route spotify:app:foo:bar
 *     count: 0
 *     bridge: false
 *  8. Increment spotify:app:foo:bar
 *     count: 1
 *  9. Navigate to spotify:app:foo:baz
 * 10. Fully route spotify:app:foo:baz
 *     count: 0
 *     bridge: false
 * 11. Increment spotify:app:foo:baz
 *     count: 1
 * 12. Navigate to spotify:app:foo:bar
 * 13. Fully route spotify:app:foo:baz
 *     count: 1
 *     bridge: false
 * 14. Increment spotify:app:foo:bar
 *     count: 2
 * 15. Bridge response for spotify:app:foo:bar
 * 16. Stop routing spotify:app:foo:bar
 *     count: 2
 *     bridge: true
 * 17. Decrement spotify:app:foo:bar
 *     count: 1
 * 18. Bridge response for spotify:app:foo:baz
 * 19. Stop routing spotify:app:foo:baz
 *     count: 1
 *     bridge: true
 * 20. Decrement spotify:app:foo:baz
 *     count: 0
 * 21. Bridge response for spotify:app:foo:bar
 * 22. Stop routing spotify:app:foo:bar
 *     count: 1
 *     bridge: true
 * 23. Decrement spotify:app:foo:bar
 *     count: 0
 */
'use strict';

var countPerURI = {};

var routeValidator = {

  /**
   * Increment the counter for the specified URI.
   *
   * @param {string} uri Spotify URI.
   */
  incrementForUri: function incrementForUri(uri) {
    if (!(uri in countPerURI)) {
      countPerURI[uri] = 0;
    }

    countPerURI[uri]++;
  },

  /**
   * Decrement the counter for the specified URI.
   * @param {string} uri Spotify URI.
   */
  decrementForUri: function decrementForUri(uri) {
    if (uri in countPerURI) {
      countPerURI[uri]--;
      if (countPerURI[uri] === 0) {
        delete countPerURI[uri];
      }
    }
  },

  /**
   * Get the current count for the specified URI.
   *
   * @param {string} uri Spotify URI.
   *
   * @return {number} The current count for the URI.
   */
  getCountForUri: function getCountForUri(uri) {
    return countPerURI[uri] || 0;
  },

  /**
   * Check whether routing to the specified URI with the specified source should
   * be allowed, based on the counter.
   *
   * @param {string} uri Spotify URI.
   * @param {string} source The source of the route, 'bridge' or 'navigation'.
   *
   * @return {boolean} True if the route is valid.
   */
  validate: function validate(uri, source) {
    if (source === 'bridge' && this.getCountForUri(uri) > 0) {
      this.decrementForUri(uri);
      return false;
    }

    return true;
  },

  /**
   * Reset all counts. Useful for tests.
   */
  reset: function reset() {
    countPerURI = {};
  }

};

module.exports = routeValidator;

},{}],115:[function(require,module,exports){
'use strict';

var CosmosMessagesHandler = require('./cosmosmessageshandler');
var Event = require('./event');
var utils = require('./utils');

function SocialErrorHandler() {
  CosmosMessagesHandler.apply(this, arguments);
}

utils.inherit(SocialErrorHandler, CosmosMessagesHandler);

SocialErrorHandler.prototype.setup = function () {
  this.init('sp://facebook/v1/errors');
};

SocialErrorHandler.prototype.buildEvent = function (msg) {
  return new Event(Event.TYPES.SOCIAL_ERROR, msg.getJSONBody());
};

module.exports = new SocialErrorHandler();

},{"./cosmosmessageshandler":75,"./event":77,"./utils":120}],116:[function(require,module,exports){
'use strict';

/**
 * The manager for all station states throughout the desktop client.
 * - Listens to context-player updates
 * - Writes to and reads from local storage to maintain an 8 hour station cache
 * - Posts update messages to the container for app/station model consumption.
 * - Calls out to radio-apollo for station data and station updates.
 * More Info: libs/spotify-live-models/docs/station.md
 */

var cosmosPromise = require('./utils/cosmos-promise');
var eventDispatcher = require('../../../libs/spotify-event-dispatcher');
var Event = require('./event');
var playerUtils = require('./utils/player-utils');
var isStationUri = require('../../../libs/spotify-live-models/station').isStationUri;
var thumbActions = require('../../../libs/spotify-live-models/station/thumb-actions');

var END_POINT_BASE = 'hm://radio-apollo/';
var END_POINT_VERSION = 'v3';
var END_POINT = END_POINT_BASE + END_POINT_VERSION + '/';
var END_POINT_ALL = END_POINT + 'all';
var END_POINT_TRACKS = END_POINT + 'tracks';
var END_POINT_STATIONS = END_POINT + 'stations';
var END_POINT_SAVED = END_POINT + 'saved-station';

var NEXT_PAGE_URL_LENGTH = 40; // the amount of track ids in the next page url
var DEFAULT_COUNT = 15;
var saltRegex = /salt=[0-9]+/g;

var PLAYER_SUBSCRIBE_OPTIONS = {
  // Define visible window of 14 reverse and future tracks
  // Context-Player will fetch more to fill requested future tracks
  // But Context-Player currently returns 10 reverse tracks maximum
  'reverse_cap': 14,
  'future_cap': 14
};

var PLAYER_RESTRICTIONS = {
  'disallow_toggling_repeat_context_reasons': ['disallow-radio'],
  'disallow_toggling_repeat_track_reasons': ['disallow-radio'],
  'disallow_toggling_shuffle_reasons': ['disallow-radio']
};

var LOCAL_STORAGE_KEY = 'stations';
var EXPIRATION_TIME = 8 * 60 * 60 * 1000; // 8 hours in milliseconds
var ALL_REQUEST_EXPIRATION = 30 * 1000; // 30 seconds

var STATION_SETS = ['genre_stations', 'recommended_stations', 'user_stations', 'cluster_stations', 'saved_stations'];

function StationManager() {
  this.onPlayerUpdateDebounce = {};
  // A hash-map/dictonary of all station objects by station uri.
  this.stations = {};
  this.allProps = {};
}

StationManager.prototype.setup = function (player, localStorage, stationMessageProxy, locale) {
  if (!player || !localStorage || !stationMessageProxy) {
    throw new Error('StationManager:setup missing params');
  }
  this.player = player;
  this.storage = localStorage;
  this.messageProxy = stationMessageProxy;

  this.currentlyPlayingStation = '';
  this._lastGetAll = 0;
  this.queueThumbDown = false;
  this.locale = locale || 'en';

  this.getStoredStations();

  // Station Sets
  STATION_SETS.forEach(function (set) {
    this[set] = [];
  }.bind(this));
  this.getAll();

  // Subscribers and Event Listeners
  this.player.subscribe(this.onPlayerUpdate.bind(this), PLAYER_SUBSCRIBE_OPTIONS);
  this.messageProxy.subscribeTo_request(this.onRequest.bind(this));
  this.messageProxy.subscribeTo_add(this.onAdd.bind(this));
  this.messageProxy.subscribeTo_thumb(this.onThumb.bind(this));
  this.messageProxy.subscribeTo_requestSaved(this.onRequestSaved.bind(this));
  this.messageProxy.subscribeTo_requestAll(this.onRequestAll.bind(this));

  eventDispatcher.addEventListener(Event.TYPES.THUMB_UP, this.onPlayerThumbUp.bind(this));
  eventDispatcher.addEventListener(Event.TYPES.THUMB_DOWN, this.onPlayerThumbDown.bind(this));
};

// Utility Methods

StationManager.prototype.logError = function (error) {
  console.log(error.message);
};

/**
 * Gets the base seed from a station uri
 * @param {String} stationUri
 * @return {String}
 */
StationManager.prototype.getSeedFromUri = function (stationUri) {
  return stationUri.replace(/^spotify:station:/, 'spotify:');
};

/**
 * Converts a uri (track, artist, album, genre, playlist) into a station uri
 * @param {String} uri
 * @return {String}
 */
StationManager.prototype.getUriFromSeed = function (uri) {
  return uri.replace(/^spotify:/, 'spotify:station:');
};

/**
 * Get the salt param and value from a url
 * @param {String} url
 * @return {String}
 */
StationManager.prototype.getSaltFromUrl = function (url) {
  var match = saltRegex.exec(url);
  return match ? match[0] : 'salt=0';
};

/**
 * Build the nextPageUrl for a station used by the context-player
 * and radio-apollo.
 * @param {String} stationUri
 */
StationManager.prototype.buildNextPageUrl = function (stationUri) {
  var tracks = this.stations[stationUri].tracks;
  var sentTracksAmount = Math.min(tracks.length, NEXT_PAGE_URL_LENGTH);
  var start = tracks.length - sentTracksAmount;

  var nextPageUrl = [END_POINT_TRACKS, '/', stationUri, '?', this.getSaltFromUrl(this.stations[stationUri].nextPageUrl), '&prev_tracks='].join('');

  tracks.slice(start, tracks.length).forEach(function (track) {
    nextPageUrl += track.uri.replace('spotify:track:', '') + ',';
  });

  this.stations[stationUri].nextPageUrl = nextPageUrl;
};

/**
 * Create a relatedArtist objet
 * @param {Object} artist
 * @return {Object}
 */
StationManager.prototype.parseRelatedArtist = function (artist) {
  return { uri: artist.artistUri, name: artist.artistName };
};

/**
 * Adds tracks from the backend to a station's tracks
 * @param {String} stationUri
 * @param {Object} body
 */
StationManager.prototype.parseStationTracks = function (stationUri, body) {
  var station = this.stations[stationUri];
  station.tracks = station.tracks.concat(body.tracks);
  station.nextPageUrl = body.next_page_url;
};

/**
 * Only replaces the station prop if there is a newValue
 * @param {String} uri - stationUri
 * @param {String} prop
 * @param {String} newValue
 */
StationManager.prototype.replacePropIfExists = function (uri, prop, newValue) {
  if (this.stations[uri][prop]) {
    if (newValue) this.stations[uri][prop] = newValue;
  } else {
    this.stations[uri][prop] = newValue || '';
  }
};

/**
 * Parse station data from the backend and add it to this.stations
 * @param {String} stationUri
 * @param {Object} station
 * @param {Boolean} saved - optional
 */
StationManager.prototype.parseStationData = function (stationUri, station, saved) {
  if (!this.stations[stationUri]) {
    this.stations[stationUri] = {};
  }

  this.stations[stationUri].uri = stationUri;

  // Station live model requires name and image fields.
  this.replacePropIfExists(stationUri, 'name', station.title);
  this.replacePropIfExists(stationUri, 'image', station.imageUri);

  this.stations[stationUri].subtitle = {
    name: station.subtitle || null,
    uri: station.subtitleUri || null
  };
  if (station.hasOwnProperty('explicitSave')) {
    this.stations[stationUri].added = station.explicitSave;
  }
  if (saved) {
    this.stations[stationUri].added = saved;
  }

  if (station.related_artists) {
    this.stations[stationUri].relatedArtists = station.related_artists.map(this.parseRelatedArtist);
  }

  // If this station already has tracks then we are probably mirroring
  // the playState so don't replace what we have with these new tracks.
  if (!this.stations[stationUri].tracks && station.tracks) {
    this.stations[stationUri].tracks = station.tracks;
    this.stations[stationUri].nextPageUrl = station.next_page_url;
  }
};

/**
 * Remove tracks that were thumbed down
 * @param {String} stationUri
 * @param {String} trackUri
 */
StationManager.prototype.removeTracks = function (stationUri, trackUri) {
  this.stations[stationUri].tracks = this.stations[stationUri].tracks.filter(function (track) {
    return track.uri !== trackUri;
  });
};

/**
 * Thumb up tracks in a station's tracks
 * @param {String} stationUri
 * @param {String} trackUri
 */
StationManager.prototype.thumbUpTracks = function (stationUri, trackUri) {
  this.stations[stationUri].tracks.forEach(function (track) {
    if (track.uri === trackUri) {
      track.metadata['radio.thumb'] = 'up';
    }
  });
};

/**
 * Update the stations tracks with thumb data and then update the context-player
 * if this station is currently playing.
 * @param {String} stationUri
 * @param {String} trackUri
 * @param {String} thumbMethod
 */
StationManager.prototype.updateTracksWithThumb = function (stationUri, trackUri, thumbMethod) {
  if (thumbMethod === thumbActions.DOWN) {
    this.removeTracks(stationUri, trackUri);
  } else {
    this.thumbUpTracks(stationUri, trackUri);
  }

  this.messageProxy.updateMetadata({
    'stationUri': stationUri,
    'metadata': { tracks: this.stations[stationUri].tracks }
  });
};

/**
 * Get the current player state and update the context if the entity_uri
 * matches the passed stationUri. Also skipToNextTrack if thumb down.
 * @param {String} stationUri
 * @param {String} thumbMethod
 */
StationManager.prototype.updateContext = function (stationUri, trackUri, thumbMethod) {
  this.player.getState(function (error, response) {
    if (error || !response) {
      return;
    }

    var entityUri = response.getJSONBody().entity_uri;

    if (!isStationUri(entityUri) || entityUri !== stationUri) {
      // Even if the station is not currently playing,
      // update the station's tracks with thumb data.
      this.updateTracksWithThumb(stationUri, trackUri, thumbMethod);
      return;
    }

    // Skip to next track before updating tracks to avoid player sync issues.
    if (thumbMethod === thumbActions.DOWN) {
      // Wait till skip completes to prevent UI flickering
      // as song skips post updateMetadata messages to station apps.
      this.player.skipToNextTrack(function (error) {
        if (error) return;
        // Wait for the player update to come in then adjust the context.
        // This is to allow the context player to fetch more tracks if needed.
        this.queueThumbDown = { trackUri: trackUri, stationUri: stationUri };
      }.bind(this));
    } else {
      this.updateTracksWithThumb(stationUri, trackUri, thumbMethod);
      this.player.update(this.createPlayContext(stationUri));
    }
  }.bind(this));
};

/**
 * Create a station play context for the context-player
 * @param {String} stationUri
 * @return {Object} play-context
 */
StationManager.prototype.createPlayContext = function (stationUri) {
  return {
    'entity_uri': stationUri,
    'pages': [{
      'tracks': this.stations[stationUri].tracks,
      'next_page_url': this.stations[stationUri].nextPageUrl
    }],
    'restrictions': PLAYER_RESTRICTIONS
  };
};

/**
 * Check if we need to re-request all the stations
 */
StationManager.prototype.refreshAll = function () {
  if (new Date().getTime() - this._lastGetAll > ALL_REQUEST_EXPIRATION) {
    this.getAll();
  }
};

/**
 * Removes queued tracks from the future tracks array.
 * Since queued tracks can only exist at the beginning of the array,
 * return the array starting from the first non-queued track onward.
 * @param {Array} tracks
 * @return {Array} tracks that weren't queued
 */
StationManager.prototype.removeQueuedTracks = function (tracks) {
  var nonQueueIndex;
  tracks.some(function (track, index) {
    if (playerUtils.isTrackFromQueue(track)) {
      return false;
    }
    nonQueueIndex = index;
    return true;
  });
  return tracks.slice(nonQueueIndex, tracks.length);
};

// LocalStorage Methods

/**
 * Remove old stations.
 * @param {Object} stations hash-map/dictionary
 * @return {Object} stations hash-map/dictionary
 */
StationManager.prototype.removeExpiredStations = function (stations) {
  var cleanedStations = {};
  var currentTime = new Date().getTime();
  Object.keys(stations).forEach(function (uri) {
    if (currentTime - stations[uri].timestamp < EXPIRATION_TIME) {
      cleanedStations[uri] = stations[uri];
    }
  });
  return cleanedStations;
};

/**
 * Get stations from local storage
 */
StationManager.prototype.getStoredStations = function () {
  this.storage.get(LOCAL_STORAGE_KEY, function (error, value) {
    if (!error && value) {
      try {
        this.stations = this.removeExpiredStations(JSON.parse(value));
      } catch (e) {
        console.error('StationManager:getStoredStations:parse error ', e);
      }
    }
  }.bind(this));
};

/**
 * Updates stations in local storage.
 * @param {String} stationUri
 */
StationManager.prototype.updateLocalStorage = function () {
  var stationsToStore = {};
  Object.keys(this.stations).forEach(function (key) {
    var station = this.stations[key];
    if (station.timestamp) {
      stationsToStore[key] = station;
    }
  }.bind(this));
  this.storage.set(LOCAL_STORAGE_KEY, JSON.stringify(stationsToStore), function (error) {
    if (error) {
      console.error('StationManager:updateStoredStations:error ', error);
    }
  });
};

// Subscriber/Listener Handlers

/**
 * Debounce updates from the context-player to cut down on cycles.
 * @param {String} error
 * @param {Object} response
 */
StationManager.prototype.onPlayerUpdate = function (error, response) {
  if (!error && response) {
    clearTimeout(this.onPlayerUpdateDebounce);
    this.onPlayerUpdateDebounce = setTimeout(this.handlePlayerUpdate.bind(this, response), 50);
  }
};

/**
 * Handle the debounced player update
 * @param {Object} response
 */
StationManager.prototype.handlePlayerUpdate = function (response) {
  var body = response.getJSONBody();
  var stationUri = body.entity_uri;

  if (!isStationUri(stationUri)) {
    return;
  }

  var future = body.future || [];
  var reverse = body.reverse || [];
  var currentTrack = body.track;

  if (future.length < 1 && reverse.length < 1 || !currentTrack) {
    // something is wrong
    return;
  }

  if (playerUtils.isTrackAd(currentTrack) || playerUtils.isTrackFromQueue(currentTrack)) {
    return;
  }

  var currentTrackUpdate;
  var tracksUpdate;
  var currentTrackUid = currentTrack.uid;
  var station = this.stations[stationUri];

  if (!station) {
    this.stations[stationUri] = {};
    station = this.stations[stationUri];
  }

  this.createStation(stationUri);

  var tracks = station.tracks;
  var snapShot = reverse.concat([currentTrack], this.removeQueuedTracks(future));

  // Check to see if we need to update the tracks
  if (!tracks || tracks.length !== snapShot.length) {
    station.tracks = snapShot;
    tracksUpdate = true;
  } else {
    var notEqual = tracks.some(function (track, index) {
      // Changing this to URI instead of UID to support connect plays
      // because UIDs are dropped from track data during connect.
      // We should change this back when UID support is available.
      return track.uri !== snapShot[index].uri;
    });

    if (notEqual) {
      station.tracks = snapShot;
      tracksUpdate = true;
    }
  }

  if (currentTrackUid && station.currentTrackUid !== currentTrackUid) {
    currentTrackUpdate = true;
    this.stations[stationUri].currentTrackUid = currentTrackUid;
  }

  var metadata = {};

  if (tracksUpdate) {
    this.buildNextPageUrl(stationUri);
    metadata.tracks = station.tracks;
    metadata.nextPageUrl = this.stations[stationUri].nextPageUrl;
  }

  if (currentTrackUpdate) {
    metadata.currentTrackUid = currentTrackUid;
  }

  // We are going to update the tracks and context
  // so no need to send an additional metadata update below.
  if (this.queueThumbDown) {
    this.updateTracksWithThumb(this.queueThumbDown.stationUri, this.queueThumbDown.trackUri, thumbActions.DOWN);
    this.player.update(this.createPlayContext(stationUri));
    this.queueThumbDown = false;
    return;
  }

  if (currentTrackUpdate || tracksUpdate) {
    this.stations[stationUri].timestamp = new Date().getTime();
    this.updateLocalStorage();
    this.messageProxy.updateMetadata({
      'stationUri': stationUri,
      'metadata': metadata
    });
  }
};

/**
 * Subscriber to the onRequest post message
 * @param {Object} opts
 */
StationManager.prototype.onRequest = function (opts) {
  var stationUri = opts.stationUri;
  var metadata = opts.metadata || [];
  var trackCount = opts.trackCount;

  var needsData;

  if (!this.stations[stationUri] || trackCount && !this.stations[stationUri].tracks) {
    needsData = true;
  } else {
    needsData = metadata.some(function (key) {
      return !this.stations[stationUri][key];
    }.bind(this));
  }

  // Needs the full set of data from the backend
  if (needsData) {
    this.getStationData(stationUri, trackCount).then(function (data) {
      this.parseStationData(stationUri, JSON.parse(data.body));
      this.sendStationData(stationUri, opts.appUri);
    }.bind(this)).catch(this.logError.bind(this));

    // Just needs tracks for the station from the backend
  } else if (trackCount && trackCount > this.stations[stationUri].tracks.length) {
      this.getStationTracks(stationUri, trackCount - this.stations[stationUri].tracks.length).then(function (data) {
        this.parseStationTracks(stationUri, JSON.parse(data.body));
        this.messageProxy.updateMetadata({
          'stationUri': stationUri,
          'metadata': {
            tracks: this.stations[stationUri].tracks,
            nextPageUrl: this.stations[stationUri].nextPageUrl
          }
        });
        this.sendStationData(stationUri, opts.appUri);
      }.bind(this)).catch(this.logError.bind(this));

      // We have all the data requested already. No backend request needed.
    } else {
        this.sendStationData(stationUri, opts.appUri);
      }
};

/**
 * Subscriber to the requestSaved post message
 */
StationManager.prototype.onRequestSaved = function () {
  this.refreshAll();
  // Send something regardless of backend error.
  this.getAllPromise.then(this.sendSavedStations.bind(this), this.sendSavedStations.bind(this));
};

/**
 * Subscriber to the requestAll post message
 */
StationManager.prototype.onRequestAll = function () {
  this.refreshAll();
  // Send something regardless of backend error.
  this.getAllPromise.then(this.sendAllStations.bind(this), this.sendAllStations.bind(this));
};

/**
 * Subscriber to the onAdd post message
 * @param {Object} opts
 */
StationManager.prototype.onAdd = function (opts) {
  this.handleAdd(opts.stationUri, opts.add);
};

/**
 * Subscriber to the onThumb post message
 * @param {Object} opts
 */
StationManager.prototype.onThumb = function (opts) {
  var station = this.stations[opts.stationUri];
  if (!station || !station.tracks) {
    return;
  }
  this.updateContext(opts.stationUri, opts.trackUri, opts.thumb);
  this.postThumb(opts.stationUri, opts.trackUri, opts.thumb);
};

/**
 * Event Listener for THUMB_UP event from the player-ui.
 * @param {Object} obj
 */
StationManager.prototype.onPlayerThumbUp = function (obj) {
  this.onThumb({
    stationUri: obj.params.entityUri,
    trackUri: obj.params.trackUri,
    thumb: thumbActions.UP
  });
};

/**
 * Event Listener for THUMB_DOWN event from the player-ui.
 * @param {Object} obj
 */
StationManager.prototype.onPlayerThumbDown = function (obj) {
  this.onThumb({
    stationUri: obj.params.entityUri,
    trackUri: obj.params.trackUri,
    thumb: thumbActions.DOWN
  });
};

// Post Data Methods

/**
 * Post a requestSavedReply with only 'saved_stations'
 */
StationManager.prototype.sendSavedStations = function () {
  // Send the message even if we have 0 saved_stations;
  this.messageProxy.requestSavedReply({
    'saved_stations': this.saved_stations.map(function (uri) {
      return this.stations[uri];
    }.bind(this))
  });
};

/**
 * Post a requestAllReply with all sets but 'saved_stations'
 */
StationManager.prototype.sendAllStations = function () {
  var allBody = {};
  STATION_SETS.forEach(function (set) {
    if (set !== 'saved_stations') {
      allBody[set] = this[set].map(function (stationUri) {
        return this.stations[stationUri];
      }.bind(this));
    }
  }.bind(this));
  allBody.cluster_format_name = this.allProps.cluster_format_name;
  this.messageProxy.requestAllReply(allBody);
};

/**
 * Post a request reply with station data
 * @param {String} stationUri
 * @param {String} appUri
 */
StationManager.prototype.sendStationData = function (stationUri, appUri) {
  this.messageProxy.requestReply({
    'appUri': appUri,
    'stationUri': stationUri,
    'station': this.stations[stationUri]
  });
};

// Radio Apollo Requests

/**
 * Request station data from the radio backend
 * @param {String} uri stationUri
 * @param {Integer} count
 */
StationManager.prototype.getStationData = function (uri, count) {
  count = count || DEFAULT_COUNT;
  return cosmosPromise({
    method: 'GET',
    uri: END_POINT_STATIONS + '/' + this.getSeedFromUri(uri) + '?count=' + count
  });
};

/**
 * Create a station on the backend if it doesnt match currentlyPlayingStation.
 * This is acting as a replacement for the touch endpoint
 * so the backend knows the last played station.
 * @param {String} stationUri
 */
StationManager.prototype.createStation = function (stationUri) {
  if (this.currentlyPlayingStation === stationUri) {
    return;
  }

  this.currentlyPlayingStation = stationUri;
  this.messageProxy.updateLastPlayed({ 'stationUri': stationUri });

  cosmosPromise({
    method: 'POST',
    uri: END_POINT_STATIONS + '?count=0&send_station=false',
    body: JSON.stringify({ seeds: [this.getSeedFromUri(stationUri)] })
  }).catch(function (error) {
    console.error('createStation', error.message);
    this.currentlyPlayingStation = '';
  }.bind(this));
};

/**
 * Get more station tracks from the backend
 * @param {String} stationUri
 * @param {Integer} count
 */
StationManager.prototype.getStationTracks = function (stationUri, count) {
  return cosmosPromise({
    method: 'GET',
    uri: this.stations[stationUri].nextPageUrl + '&count=' + count
  });
};

/**
 * Post a follow update to the radio backend.
 * @param {String} stationUri
 * @param {Boolean} follow
 */
StationManager.prototype.handleAdd = function (stationUri, follow) {
  cosmosPromise({
    method: follow ? 'PUT' : 'DELETE',
    uri: END_POINT_SAVED,
    body: JSON.stringify({ seedUri: this.getSeedFromUri(stationUri) })
  }).then(function () {
    if (follow) {
      this.saved_stations.unshift(stationUri);
    } else {
      var index = this.saved_stations.indexOf(stationUri);
      if (index !== -1) {
        this.saved_stations.splice(index, 1);
      }
    }

    this.stations[stationUri].added = follow;

    this.messageProxy.updateMetadata({
      'stationUri': stationUri,
      'metadata': { added: follow }
    });
  }.bind(this)).catch(function (error) {
    console.error(error.message);
    this.stations[stationUri].added = !follow;
    this.messageProxy.updateMetadata({
      'stationUri': stationUri,
      'metadata': { added: !follow }
    });
  }.bind(this));
};

/**
 * Post thumb data to the backend
 * @param {String} stationUri
 * @param {String} trackUri
 * @param {String} thumbMethod
 */
StationManager.prototype.postThumb = function (stationUri, trackUri, thumbMethod) {
  // Even if this fails lets maintain the same UI experience after thumbing.
  cosmosPromise({
    method: 'POST',
    uri: END_POINT_STATIONS + '/' + stationUri + '/' + thumbMethod + '/' + trackUri.replace('spotify:track:', '') + '?count=0',
    body: this.stations[stationUri].nextPageUrl
  }).catch(this.logError.bind(this)); // Todo: show a blue error bar
};

/**
 * Add each station from the 'getAll' request to the stations obj
 * @param {String} set
 * @param {Array} stations
 */
StationManager.prototype.addAllCallStations = function (set, stations) {
  // clear the current sets
  this[set] = [];
  stations.forEach(function (station) {
    var stationUri = this.getUriFromSeed(station.seeds ? station.seeds[0] : station.uri);
    if (set === 'cluster_stations') {
      station.subtitle = station.description;
    }
    this.parseStationData(stationUri, station, set === 'saved_stations');
    this[set].push(stationUri);
  }.bind(this));
};

/**
 * Get all the station sets from the backend
 */
StationManager.prototype.getAll = function () {
  this._lastGetAll = new Date().getTime();
  this.getAllPromise = cosmosPromise({
    method: 'GET',
    uri: END_POINT_ALL + '?count_tracks=0&language=' + this.locale
  }).then(function (response) {
    var body = JSON.parse(response.body);
    STATION_SETS.forEach(function (set) {
      if (body[set]) {
        this.addAllCallStations(set, body[set]);
      }
    }.bind(this));
    this.allProps.cluster_format_name = body.cluster_format_name || '';
  }.bind(this)).catch(this.logError.bind(this));
};

module.exports = new StationManager();

},{"../../../libs/spotify-event-dispatcher":264,"../../../libs/spotify-live-models/station":424,"../../../libs/spotify-live-models/station/thumb-actions":429,"./event":77,"./utils/cosmos-promise":122,"./utils/player-utils":125}],117:[function(require,module,exports){
'use strict';

var liburi = require('spotify-liburi');

function URIHelper() {}

/**
 * Convert a Spotify App URI to a regular Spotify URI.
 *
 * For example:
 *
 * spotify:app:artist:foo => spotify:artist:foo
 * spotify:artist:foo => spotify:artist:foo
 *
 * @param {String} uri The Spotify App URI to convert.
 * @return {String} The URI.
 */
URIHelper.prototype.toURI = function (uri) {
  var parsed = liburi.from(uri);

  if (!parsed) {
    throw new Error('Unable to convert ' + uri + ' to a Spotify App URI');
  }

  return parsed.toString();
};

/**
 * Converts playlist URIs to canonical format
 * spotify:user:{{USERNAME}}:playlist:{{PLAYLIST_ID}} becomes:
 * spotify:app:playlist-desktop:{{USERNAME}}:{{PLAYLIST_ID}}
 */
URIHelper.prototype.playlistCanonicalURI = function (playlistURI) {
  var uri = liburi.from(playlistURI);

  var isPlaylist = uri.type === liburi.Type.PLAYLIST;
  var isValid = isPlaylist;

  if (!isValid || !uri.username || isPlaylist && !uri.id) {
    throw new Error('Invalid playlist URI: ' + playlistURI);
  }

  var args = [uri.username, uri.id && liburi.hexToId(uri.id)];

  var app = liburi.applicationURI('playlist-desktop', args);
  return app.toString();
};

/**
 * Converts formats lists URIs to canonical format for chart
 * spotify:user:{{USERNAME}}:playlist:{{LIST_ID}} becomes:
 * spotify:app:chart:{{USERNAME}}:{{LIST_ID}}
 */
URIHelper.prototype.chartCanonicalURI = function (playlistURI) {
  var uri = liburi.from(playlistURI);

  var isList = uri.type === liburi.Type.PLAYLIST;
  var isValid = isList;

  if (!isValid || !uri.username || isList && !uri.id) {
    throw new Error('Invalid playlist URI: ' + playlistURI);
  }

  var args = [uri.username, uri.id && liburi.hexToId(uri.id)];

  var app = liburi.applicationURI('chart', args);
  return app.toString();
};

/**
 * Converts folder URIs to canonical format
 * spotify:user:{{USERNAME}}:folder:{{FOLDER_ID}} becomes:
 * spotify:app:folder:{{USERNAME}}:{{FOLDER_ID}}
 */
URIHelper.prototype.folderCanonicalURI = function (folderURI) {
  var uri = liburi.from(folderURI);

  var isFolder = uri.type === liburi.Type.FOLDER;

  if (!isFolder || !uri.username || !uri.id) {
    throw new Error('Invalid folder URI: ' + folderURI);
  }

  return liburi.applicationURI('playlist-folder', [uri.username, uri.id]).toString();
};

/**
 * Returns the real uri of a playlist based on its routing uri
 * (spotify:app:playlist-desktop:user:xxx)
 *
 * @param  {string} playlistURI routing uri of the playlist
 * @return {string}             real playlist uri
 */
URIHelper.prototype.realPlaylistURI = function (playlistURI) {
  var parsed = liburi.from(playlistURI);

  if (!parsed || parsed.type !== liburi.Type.APPLICATION) {
    throw new Error('Invalid playlist or folder app URI: ' + playlistURI);
  }

  if (parsed.id === 'playlist-desktop' && parsed.args.length === 2) {
    return liburi.playlistURI(parsed.args[0], parsed.args[1]).toString();
  }

  if (parsed.id === 'chart' && parsed.args.length === 2) {
    return liburi.playlistURI(parsed.args[0], parsed.args[1]).toString();
  }

  if (parsed.id === 'playlist-folder') {
    return liburi.folderURI(parsed.args[0], parsed.args[1]).toString();
  }

  throw new Error('Invalid playlist or folder app URI: ' + playlistURI);
};

/**
 * @return {string}
 */
URIHelper.prototype.appName = function (uri) {
  var parsed = liburi.from(uri);

  if (!parsed || parsed.type !== liburi.Type.APPLICATION) {
    return null;
  }

  return parsed.id;
};

module.exports = new URIHelper();

},{"spotify-liburi":707}],118:[function(require,module,exports){
module.exports={
  "messageBar": {
    "upgradeToPremium": "https://www.spotify.com/purchase/product/premium/?utm_source=spotify&utm_medium=product-KM&utm_campaign=notification-bar",
    "supportedFormats": "https://support.spotify.com/learn-more/faq/#!/article/Supported-file-types",
    "churnPartner": "https://www.spotify.com/purchase/product/premium/?utm_source=spotify&utm_medium=product-KM&utm_campaign=churn_partner",
    "churnPayment": "https://www.spotify.com/purchase/product/premium/?utm_source=spotify&utm_medium=product-KM&utm_campaign=churn_payment",
    "creditCardExpiry": "https://www.spotify.com/payment/change/?utm_source=spotify&utm_medium=product-KM&utm_campaign=card_exp_warning",
    "creditCardFunds": "https://www.spotify.com/payment/change/?utm_source=spotify&utm_medium=product-KM&utm_campaign=paymentfailure_lof",
    "creditCardRefused": "https://www.spotify.com/payment/change/?utm_source=spotify&utm_medium=product-KM&utm_campaign=paymentfailure_refused",
    "paypalRefused": "https://www.spotify.com/payment/change/?utm_source=spotify&utm_medium=product-KM&utm_campaign=paymentfailure_paypal",
    "prepaidExpiry": "https://www.spotify.com/purchase/product/premium/?utm_source=spotify&utm_medium=product-KM&utm_campaign=prepaid_exp_warning",
    "optInTrial": "https://www.spotify.com/purchase/product/premium/?utm_source=spotify&utm_medium=product-KM&utm_campaign=optin_trial",
    "optInTrialExpired": "https://www.spotify.com/purchase/product/premium/?utm_source=spotify&utm_medium=product-KM&utm_campaign=exp_optin_trial",
    "cantOfflinePlaylists": "https://www.spotify.com/purchase/product/premium/?utm_source=spotify&utm_medium=product-KM&utm_campaign=offline-trigger",
    "cantSetHighQualityStreaming": "https://www.spotify.com/purchase/product/premium/?utm_source=spotify&utm_medium=product-KM&utm_campaign=highqualitysound-trigger",
    "deprecatedOs": "https://support.spotify.com/learn-more/faq/#!/article/spotify-system-requirements/",
    "cappingExplained": "https://support.spotify.com/article/playback-restrictions"
  }
}

},{}],119:[function(require,module,exports){
'use strict';

var CosmosMessagesHandler = require('./cosmosmessageshandler');
var Event = require('./event');
var utils = require('./utils');

/**
 * Handles cosmos messages coming from the
 * sp://messages/v1/container/user-message endpoint
 * and triggers a UserMessageEvent when such messages are
 * received
 */
function UserMessagesHandler() {
  CosmosMessagesHandler.apply(this, arguments);
}

utils.inherit(UserMessagesHandler, CosmosMessagesHandler);

UserMessagesHandler.prototype.setup = function () {
  this.init('sp://messages/v1/container/user-message');
};

UserMessagesHandler.prototype.buildEvent = function (msg) {
  var body;
  if (msg && msg.getJSONBody) {
    body = msg.getJSONBody();
  } else {
    body = { id: msg };
  }
  return new Event(Event.TYPES.MESSAGE_USER, body);
};

module.exports = new UserMessagesHandler();

},{"./cosmosmessageshandler":75,"./event":77,"./utils":120}],120:[function(require,module,exports){
'use strict';

/**
 * Utility functions
 *
 * @constructor
 */

function Utils() {}

/**
 * Makes a class inherit from a superclass' prototype indirectly.
 *
 * @param {Function} Sub The class that will inherit.
 * @param {Function} Super The class to inherit from.
 */
Utils.prototype.inherit = function (Sub, Super) {
  function Temp() {}
  Temp.prototype = Super.prototype;
  Sub.prototype = new Temp();
  Sub.prototype.constructor = Sub;
};

module.exports = new Utils();

},{}],121:[function(require,module,exports){
'use strict';

var Cosmos = require('spotify-cosmos-api');

module.exports = function (flag, subscriber) {
  var data = {
    url: 'sp://abba/v1/flags',
    body: { flags: [flag] }
  };
  Cosmos.resolver.subscribe(data, function (err) {
    if (err) return;
    Cosmos.resolver.post(data, function (err, res) {
      if (err || !res.getJSONBody()) return;
      subscriber(res.getJSONBody().flags[0].cell);
    });
  });
};

module.exports.fetchFlags = function (flags, callback) {
  var data = {
    url: 'sp://abba/v1/flags',
    body: { flags: flags }
  };

  Cosmos.resolver.post(data, function (err, res) {
    if (err || !res.getJSONBody()) {
      callback({});
      return;
    }

    var cells = res.getJSONBody().flags.reduce(function (acc, flag) {
      acc[flag.featureName] = flag.cell;
      return acc;
    }, {});

    callback(cells);
  });
};

},{"spotify-cosmos-api":694}],122:[function(require,module,exports){
'use strict';

var bridge = require('../../../../libs/spotify-bridge-request');

module.exports = function (opts) {
  return new Promise(function (resolve, reject) {
    bridge.cosmos(opts, function (err, body) {
      if (err) {
        reject(err);
      } else if (body.status !== 200) {
        reject(new Error('Cosmos Request Error. Status: ' + body.status));
      } else {
        resolve(body);
      }
    });
  });
};

},{"../../../../libs/spotify-bridge-request":253}],123:[function(require,module,exports){
'use strict';

// There's no full spec for what's focusable, it's pretty much
// up to the browser. Just do some basic testing, inspired by
// https://github.com/jquery/jquery-ui/blob/master/ui/core.js#L133
// but skipping the visible and <map> parts.

module.exports = function focusable(node) {
  var nodeName = node.nodeName.toLowerCase();

  var trueWhenEnabled = /^(input|select|textarea|button|object)$/;
  if (trueWhenEnabled.test(nodeName)) {
    return !node.disabled;
  }

  var hasTabIndex = node.getAttribute('tabindex');
  if (hasTabIndex) {
    return true;
  }

  var isAnchor = nodeName === 'a';
  if (isAnchor) {
    return !!node.href;
  }

  return false;
};

},{}],124:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var merge = require('mout/object/merge');

/**
 * Diff two objects.
 *
 * @param {Object} before The old object.
 * @param {Object} after The new object.
 * @param {string=} optParentUri Parent URI. Used if current level is missing a
 *     URI.
 * @param {string=} optParentProperty Parent property. Used if current level is
 *     missing a URI.
 *
 * @return {Array.<Object>} Array of objects with only the differing data (and
 *     the URI).
 */
function diff(before, after, optParentUri, optParentProperty) {
  var result = [];

  var uri = before.uri;
  var parentUri = uri ? null : optParentUri;
  var parentProperty = parentUri ? optParentProperty : null;

  var diffData;
  var tempDiffData;

  for (var prop in before) {
    if (prop === 'uri' || prop === 'rowId') continue;

    if (before.hasOwnProperty(prop)) {
      var valueBefore = before[prop];
      var valueAfter = after[prop];

      var isBeforeArray = Array.isArray(valueBefore);
      var isAfterArray = Array.isArray(valueAfter);
      var areBothArrays = isBeforeArray && isAfterArray;

      var isBeforeObject = valueBefore && (typeof valueBefore === 'undefined' ? 'undefined' : _typeof(valueBefore)) === 'object';
      var isAfterObject = valueAfter && (typeof valueAfter === 'undefined' ? 'undefined' : _typeof(valueAfter)) === 'object';
      var areBothObjects = isBeforeObject && isAfterObject;

      var subResult;

      // Both values are arrays, so we need to diff the contents of these arrays
      // to know if something in there changed. If any value in the array
      // changed, the whole array is swapped out for the new one.
      if (areBothArrays) {
        subResult = [];
        for (var i = 0, l = valueBefore.length; i < l; i++) {
          var a = valueBefore[i];
          var b = valueAfter[i];
          var isAObject = a && (typeof a === 'undefined' ? 'undefined' : _typeof(a)) === 'object';
          var isBObject = b && (typeof b === 'undefined' ? 'undefined' : _typeof(b)) === 'object';
          var subSubResult;
          if (isAObject && isBObject && a.uri === b.uri) {
            subSubResult = diff(a, b, uri, prop);
            if (subSubResult.length > 0) {
              if (a.uri) {
                subResult.push.apply(subResult, subSubResult);
              } else {
                subResult.length = 0;
                subSubResult = { uri: uri };
                subSubResult[prop] = valueAfter;
                subResult.push(subSubResult);
              }
            }
          } else if (a !== b) {
            subResult.length = 0;
            subSubResult = { uri: uri };
            subSubResult[prop] = valueAfter;
            subResult.push(subSubResult);
            break;
          }
        }
        if (subResult.length > 0) {
          // Fold the sub-result into the result array to preserve a flat list
          result.push.apply(result, subResult);
        }

        // Both values are objects, so we might need to diff the contents of these
        // objects to know if something in there changed, but only if the URI is
        // the same.
      } else if (areBothObjects && valueBefore.uri === valueAfter.uri) {
          subResult = diff(valueBefore, valueAfter, uri, prop);
          if (subResult.length > 0) {
            // Only use the sub-result if we actually have a URI in the old
            // object. We need to perform the diff to know if anything changed,
            // but we only need the actual result if there is a URI present,
            // otherwise we pick the full new value.
            if (valueBefore.uri) {
              // Fold the sub-result into the result array to preserve a flat list
              result.push.apply(result, subResult);
            } else {
              if (!tempDiffData) tempDiffData = {};
              tempDiffData[prop] = valueAfter;
            }
          }

          // If the value changed in any way (primitive to primitive, primitive to
          // object or object to primitive), we use the full new value.
        } else if (valueAfter !== valueBefore) {
            if (!tempDiffData) tempDiffData = {};
            tempDiffData[prop] = valueAfter;
          }
    }
  }

  // To support the case of sub-results that don't have a URI, a parent URI and
  // property can be passed to the diff function. We will then create a wrapper
  // object to put in the result, so that each result object has a URI.
  if (tempDiffData) {
    if (parentProperty) {
      diffData = { uri: parentUri };
      if (uri) tempDiffData.uri = uri;
      diffData[parentProperty] = tempDiffData;

      // If no parent property was passed, just use the result from this diff run
      // directly as the result object.
    } else {
        diffData = tempDiffData;
        if (uri) diffData.uri = uri;
      }
  }

  // We only have a diff result object if anything changed.
  if (diffData) {
    result.push(diffData);
  }

  return result;
}

/**
 * Iterate through the provided lists and collect a flat list of diff result
 * objects.
 * @param  {Array} before  The old list.
 * @param  {Array} after   The new list.
 * @param  {Function} handler A handler function that should return an array of
 *     diff result objects. Called for each iteration with three arguments:
 *     (1) 'before': The old object at the current iteration.
 *     (2) 'after': The new object at the current iteration.
 *     (3) 'index': The index of the current iteration.
 *
 * @return {Array.<Object>} Flattend array of objects returned from the result
 *     array in the handler function.
 */
function listIterator(before, after, handler) {
  var map = Object.create(null);
  var uri;

  for (var a = 0, al = before.length; a < al; a++) {
    var subResult = handler(before[a], after[a], a);
    if (subResult.length > 0) {
      for (var b = 0, bl = subResult.length; b < bl; b++) {
        uri = subResult[b].uri;
        if (uri && !map[uri]) map[uri] = {};
        map[uri] = merge(map[uri], subResult[b]);
      }
    }
  }

  return Object.keys(map).map(function (uri) {
    return map[uri];
  });
}

exports.diff = diff;
exports.listIterator = listIterator;

},{"mout/object/merge":666}],125:[function(require,module,exports){
'use strict';

/**
 * Check if the track is an ad
 * @param {Object} track
 * @return {Boolean}
 */

function isTrackAd(track) {
  return track.provider === 'ad' || track.uri.indexOf('spotify:ad:') === 0;
}

/**
 * Is a track from the queue
 * @param {Object} track
 * @return {Boolean}
 */
function isTrackFromQueue(track) {
  return track.provider === 'queue';
}

module.exports = {
  isTrackAd: isTrackAd,
  isTrackFromQueue: isTrackFromQueue
};

},{}],126:[function(require,module,exports){
'use strict';

// Dependencies

var ko = require('knockout');

/**
 * The main application
 *
 * @constructor
 */
function ViewManager(doc) {
  /**
   * Internal reference to window.document or possible mock object
   */
  this._document = doc || window.document;

  /**
   * View models registered, keyed by element id to bind to
   *
   * @private
   * @type {Object}
   */
  this._views = {};
}

/**
 * Register and set up a new view
 *
 * @param {String} id The id to register by.
 * @param {Function} instance The instance to register.
 * @return {[type]} [description]
 */
ViewManager.prototype.register = function (id, instance) {
  var element = this._document.getElementById('view-' + id);
  ko.applyBindings(instance, element);
  instance.setup(element);
  this._views[id] = instance;
  return instance;
};

/**
 * Get a view instance by id
 *
 * @return {Object} The view instance, or null if not found.
 */
ViewManager.prototype.getViewById = function (id) {
  if (typeof this._views[id] === 'undefined') {
    return null;
  }
  return this._views[id];
};

module.exports = ViewManager;

},{"knockout":567}],127:[function(require,module,exports){
'use strict';

var _ = require('../../i18n').get;
var glue = require('../../../../libs/spotify-glue-cat');

/**
 * View Model for the accessibility links area
 *
 *
 * @constructor
 */
function AccessibilityLinks() {}

AccessibilityLinks.prototype.SKIP_TO_CONTENT_LABEL = _('accessibilitylinks.skip_to_content_label');
AccessibilityLinks.prototype.SKIP_TO_PLAYER_LABEL = _('accessibilitylinks.skip_to_player_label');

/**
 * Skip to content
 */
AccessibilityLinks.prototype.skipToContent = function () {
  document.getElementById('content-anchor').focus();
  // do not prevent default action.
  return true;
};

/**
 * Skip to player
 */
AccessibilityLinks.prototype.skipToPlayer = function () {
  document.getElementById('player-anchor').focus();
  var playerAnchorId = glue.getVersion() === 1 ? 'player-anchor' : 'player-anchor-glue2';
  document.getElementById(playerAnchorId).focus();
  // do not prevent default action.
  return true;
};

/**
 * Setup functionality
 *
 * @return {AccessibilityLinks} The instance.
 */
AccessibilityLinks.prototype.setup = function () {
  return this;
};

module.exports = AccessibilityLinks;

},{"../../../../libs/spotify-glue-cat":348,"../../i18n":11}],128:[function(require,module,exports){
(function (global){
'use strict';

var ads = global.UNIT_TEST ? require('../../tests/support/mocks/mock_ad_formats') : require('../../../../libs/spotify-ad-formats');

var EventTypes = require('../event').TYPES;
var eventDispatcher = require('../../../../libs/spotify-event-dispatcher');
var localSettings = require('../models/localsettings');
var ResizeNav = require('./resize');
var activityMonitor = require('../components/activity_monitor');
var logger = require('../logging/client-event-logger');

/**
 * Constructor.
 */
function BillboardAd() {
  this.ACTIVE_CLASS = 'billboard-active';
  this.billboardContainer = document.getElementById('view-billboard-ad');
  this.mainContainer = document.getElementById('main-container');
  this.ad = ads.BillboardAd;
  this.hasReceivedFocus = false;
  this.activityTimerUUID = null;
  this._navbarWidth = false;
  this._isFullscreenAd = false;
}

/**
 * Setup the billboard ad format.
 *
 * @Return Promise resolving when setup is complete
 */
BillboardAd.prototype.setup = function () {
  this._navbarWidth = localSettings.get(ResizeNav.SIDEBAR_WIDTH_SETTING);
  if (this._navbarWidth) {
    this._updateOffsetLeft(this._navbarWidth);
  }

  eventDispatcher.addEventListener(EventTypes.AD_BILLBOARD_VISIBLE, function (e) {
    this._isFullscreenAd = e.params.isFullscreenAd;
    if (this.hasReceivedFocus) {
      this._onShowBillboard();
    }
  }.bind(this));

  eventDispatcher.addEventListener(EventTypes.AD_BILLBOARD_HIDDEN, function () {
    this._onHideBillboard();
  }.bind(this));

  eventDispatcher.addEventListener(EventTypes.AD_BILLBOARD_MINIMIZED, function () {
    this._onMinimizeBillboard();
  }.bind(this));

  eventDispatcher.addEventListener(EventTypes.AD_BILLBOARD_FOCUS_RECEIVED, function (e) {
    this.hasReceivedFocus = true;
    this._isFullscreenAd = e.params.isFullscreenAd;
    if (!e.params.isDummyAd) {
      this._onShowBillboard();
    }
  }.bind(this));

  eventDispatcher.addEventListener(EventTypes.AD_BILLBOARD_DISCARDED, function () {
    this.hasReceivedFocus = false;
  }.bind(this));

  eventDispatcher.addEventListener(EventTypes.LAYOUT_SIDEBAR_RESIZED, function (e) {
    this._navbarWidth = e.params.width;
    this._updateOffsetLeft(e.params.width);
  }.bind(this));

  eventDispatcher.addEventListener(EventTypes.DEBUG_SET_BILLBOARD_TIMEOUT, function (e) {
    this.setupActivityMonitor(e.params.timeout);
  }.bind(this));

  this.ad.init({ element: this.billboardContainer });
  this.ad.enable();
  return this.updateActivityMonitor();
};

/**
 * Initiates callback for activity monitoring
 * @param  {Number} ms milliseconds for activity monitor timeout
 */
BillboardAd.prototype.setupActivityMonitor = function (ms) {
  var ad = this.ad;

  if (this.activityTimerUUID) {
    activityMonitor.removeCallback(this.activityTimerUUID);
  }

  this.activityTimerUUID = activityMonitor.registerCallback(ms, function () {
    if (ad.isEnabled() && !ad.pageIsBlackListed()) {
      // Trigger billboard
      ad.setApplicationInactive();
    }
    // Log ui_inactive client event
    logger.log({
      'event': 'user:hit',
      'event_version': 'ui_inactive',
      'json_data': {
        'name': 'spotify:main',
        'target_uri': 'spotify:app:zlink'
      }
    });
    this.updateActivityMonitor();
  }.bind(this));
};

/**
 * Get the current value for billboard inactivity timeout, and (re)setup the
 * ActivityMonitor to trigger the billboard.
 */
BillboardAd.prototype.updateActivityMonitor = function () {
  return this.ad.getFocusTimeoutMs().then(this.setupActivityMonitor.bind(this));
};

/**
 * Remove style attribute for billboard ad when active
 * and add active class
 * KM-10304
 */
BillboardAd.prototype._onShowBillboard = function () {
  this.mainContainer.classList.add(this.ACTIVE_CLASS);
  if (this._isFullscreenAd) {
    this.billboardContainer.removeAttribute('style');
  }
};

/**
 * Remove active class
 */
BillboardAd.prototype._onHideBillboard = function () {
  this.mainContainer.classList.remove(this.ACTIVE_CLASS);
};

/**
 * Re-update the left offset when the billboard is minimized.
 */
BillboardAd.prototype._onMinimizeBillboard = function () {
  if (this._navbarWidth) {
    this._updateOffsetLeft(this._navbarWidth);
  }
};

/**
 * Update the left offset position of the container.
 *
 * @param {String} offset The new offset to apply.
 */
BillboardAd.prototype._updateOffsetLeft = function (offset) {
  this.billboardContainer.style.left = offset;
};

// Export stuff
module.exports = BillboardAd;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../../../libs/spotify-ad-formats":203,"../../../../libs/spotify-event-dispatcher":264,"../../tests/support/mocks/mock_ad_formats":178,"../components/activity_monitor":29,"../event":77,"../logging/client-event-logger":93,"../models/localsettings":100,"./resize":169}],129:[function(require,module,exports){
'use strict';

var ko = require('knockout');
var eventDispatcher = require('../../../../libs/spotify-event-dispatcher');
var EventTypes = require('../event').TYPES;
var Keyboard = require('../keyboard');
var session = require('../models/session');
var _ = require('../../i18n').get;

/**
 * View Model for the BrowserNavigation area.
 *
 * @param {Router} router The router to use.
 * @param {History} history The history manager to use.
 * @constructor
 */
function BrowserNavigation(router, history) {
  /**
   * The router to use
   *
   * @type {Router}
   */
  this._router = router;

  /**
   * The history manager to use
   *
   * @type {History}
   */
  this._history = history;

  // Observables
  this.canGoBack = ko.observable(false);
  this.canGoForward = ko.observable(false);
}

BrowserNavigation.prototype.BACK_BUTTON_LABEL = _('navigation.back_button_label');
BrowserNavigation.prototype.FORWARD_BUTTON_LABEL = _('navigation.forward_button_label');

/**
 * Setup functionality
 *
 * @return {BrowserNavigation} The instance.
 */
BrowserNavigation.prototype.setup = function () {
  var self = this;
  eventDispatcher.addEventListener(EventTypes.NAVIGATION_HISTORY_CHANGE, function (e) {
    self.canGoBack(e.params.back);
    self.canGoForward(e.params.forward);
  });
  eventDispatcher.addEventListener(EventTypes.NAVIGATION_HISTORY_BACK, function () {
    self.goBack(self, null);
  });
  eventDispatcher.addEventListener(EventTypes.NAVIGATION_HISTORY_FORWARD, function () {
    self.goForward(self, null);
  });
  eventDispatcher.addEventListener(EventTypes.NAVIGATION_HISTORY_GO, function (e) {
    self.go(e.params.position);
  });

  eventDispatcher.addEventListener(EventTypes.NAVIGATION_HISTORY_REMOVE, function (e) {
    self.removeUri(e.params);
  });

  this._registerKeyboardShortcuts();

  return this;
};

BrowserNavigation.prototype._registerKeyboardShortcuts = function () {
  if (session.isDeveloper()) {
    Keyboard.registerShortcut(Keyboard.KEYS.F5, function () {
      window.location.reload();
    });

    Keyboard.registerShortcut({
      key: Keyboard.KEYS.R,
      shift: true,
      ctrl: true
    }, function () {
      window.location.reload();
    });
  }

  var self = this;

  // BROWSE BACK
  var back = function back(e) {
    e.preventDefault();
    self.goBack();
  };

  Keyboard.registerShortcut({
    key: Keyboard.KEYS.ARROW_LEFT,
    ctrl: true,
    alt: true
  }, back);

  Keyboard.registerShortcut({
    key: Keyboard.KEYS.ARROW_LEFT,
    alt: true
  }, back);

  Keyboard.registerShortcut({
    key: Keyboard.KEYS['['],
    ctrl: true
  }, back);

  // BROWSE FORWARD
  var forward = function forward(e) {
    e.preventDefault();
    self.goForward();
  };

  Keyboard.registerShortcut({
    key: Keyboard.KEYS.ARROW_RIGHT,
    ctrl: true,
    alt: true
  }, forward);

  Keyboard.registerShortcut({
    key: Keyboard.KEYS.ARROW_RIGHT,
    alt: true
  }, forward);

  Keyboard.registerShortcut({
    key: Keyboard.KEYS[']'],
    ctrl: true
  }, forward);
};

/**
 * Remove uri from the browser history.
 * If state was affected, route to new position.
 *
 * @param {string} uri URI to remove.
 */
BrowserNavigation.prototype.removeUri = function (uri) {
  var currentState = this._history.getCurrentState();
  this._history.removeUri(uri);
  var newState = this._history.getCurrentState();
  if (!currentState.equals(newState)) {
    this._router.route(newState, false);
  }
};

/**
 * Go back to previous page
 *
 * @param {BrowserNavigation} model The instance of the model.
 * @param {Event} e The event that's been triggered.
 */
BrowserNavigation.prototype.goBack = function (model, e) {
  if (!this._history.canGoBack()) return;
  if (arguments.length === 1) e = model;
  if (e) e.preventDefault();
  var previous = this._history.back();
  if (previous) {
    this._router.route(previous, false);
  }
};

/**
 * Go forward to next page, previously navigated back
 *
 * @param {BrowserNavigation} model The instance of the model.
 * @param {Event} e The event that's been triggered.
 */
BrowserNavigation.prototype.goForward = function (model, e) {
  if (!this._history.canGoForward()) return;
  if (arguments.length === 1) e = model;
  if (e) e.preventDefault();
  var next = this._history.forward();
  if (next) {
    this._router.route(next, false);
  }
};

/**
 * Navigate to a particular position in history.
 *
 * @param {number} position The position to navigate to.
 */
BrowserNavigation.prototype.go = function (position) {
  var next = this._history.go(position);
  if (next) {
    this._router.route(next, false);
  }
};

module.exports = BrowserNavigation;

},{"../../../../libs/spotify-event-dispatcher":264,"../../i18n":11,"../event":77,"../keyboard":83,"../models/session":107,"knockout":567}],130:[function(require,module,exports){
(function (global){
'use strict';

var ko = require('knockout');
var Keyboard = require('../keyboard');
var bridgeRequest = require('../../../../libs/spotify-bridge-request').request;
var eventDispatcher = require('../../../../libs/spotify-event-dispatcher');
var EventTypes = require('../event').TYPES;
var VMResize = require('./resize');
var activityMonitor = require('../components/activity_monitor');

function BuddyList() {
  this.isVisible = ko.observable(false);
  this.buddyListUri = 'spotify:app:buddy-list';
  this.domEl = document.getElementById('view-buddy-list');
  this.resize = new VMResize('view-buddy-list', null, 'buddyListWidth');
  this.resize.setup();

  if (global.__spotify && global.__spotify.exec) {
    global.__spotify.exec('frame:register', this.buddyListUri, document.querySelector('#iframe-buddy-list'));
    this.buddyListUri = global.__spotify.exec('translate:uri', this.buddyListUri);
  }
}

BuddyList.prototype.setup = function () {
  var self = this;
  var iframe = document.getElementById('iframe-buddy-list');

  // Cannot use knockout bindings. Using DOM manipulation instead as
  // #main-container is out of the scope of the BuddyList KO model.
  this.isVisible.subscribe(function (visible) {
    var mainContainer = document.getElementById('content-wrapper');

    if (visible) {
      mainContainer.classList.remove('hide-buddy-list');
    } else {
      mainContainer.classList.add('hide-buddy-list');
    }
  });

  var onIFrameLoaded = function onIFrameLoaded() {
    activityMonitor.enableForWindow(iframe.contentWindow);
    Keyboard.setupWithWindow(iframe.contentWindow);
  };

  var updateFromPreferences = function updateFromPreferences(error, response) {
    iframe.addEventListener('load', onIFrameLoaded);

    if (response && 'ui.show_friend_feed' in response) {
      self.isVisible(response['ui.show_friend_feed']);
    } else {
      self.isVisible(true);
    }

    bridgeRequest('preferences_event_wait', [], updateFromPreferences);
  };

  bridgeRequest('preferences_get', ['ui.show_friend_feed'], updateFromPreferences);

  eventDispatcher.addEventListener(EventTypes.AD_VIDEO_STARTED, function () {
    self.domEl.className += ' hide';
  });

  eventDispatcher.addEventListener(EventTypes.AD_VIDEO_FINISHED, function () {
    self.domEl.className = self.domEl.className.replace(/(?:^|\s)hide(?!\S)/g, '');
  });
};

module.exports = BuddyList;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../../../libs/spotify-bridge-request":253,"../../../../libs/spotify-event-dispatcher":264,"../components/activity_monitor":29,"../event":77,"../keyboard":83,"./resize":169,"knockout":567}],131:[function(require,module,exports){
'use strict';

var ko = require('knockout');
var eventDispatcher = require('../../../../libs/spotify-event-dispatcher');
var Event = require('../event');
var localSettings = require('../models/localsettings');
var session = require('../models/session');
var logger = require('../logging/client-event-logger');
var _ = require('../../i18n').get;

/**
 * View Model for the capping upsell message
 *
 * @constructor
 * @todo Add logging (maybe)
 */
function CappingFullScreenMessage() {
  this._domElement = document.getElementById('view-capping-full-screen-message');
  this._closeBtn = this._domElement.querySelector('.cum-close-btn');
  this.logger = logger;

  this.cappingManagerListener = require('../capping-manager-listener');

  this.currentContext = false;
  this.showCappingMessage = ko.observable(false);
  this.cappingMessageTitle = ko.observable('');
  this.cappingMessageText = ko.observable('');
  this.cappingButtonLabel = ko.observable('');
  this.cappingTopInformation = ko.observable('');

  this._documentClicked = this._documentClicked.bind(this);
  this._elementClicked = this._elementClicked.bind(this);

  return this;
}

/**
 * Setup functionality
 *
 * @return {CappingFullScreenMessage} The instance.
 */
CappingFullScreenMessage.prototype.setup = function () {
  var _this = this;

  var storedSidebarWidth = localSettings.get('sidebarWidth');
  if (storedSidebarWidth) {
    this._updateOffsetLeft(storedSidebarWidth);
  }

  eventDispatcher.addEventListener(Event.TYPES.LAYOUT_SIDEBAR_RESIZED, function (e) {
    _this._updateOffsetLeft(e.params.width);
  });

  eventDispatcher.addEventListener(Event.TYPES.CAPPING_OPEN_UPSELL_MESSAGE, this._showUpsellMessage.bind(this));

  eventDispatcher.addEventListener(Event.TYPES.CAPPING_OPEN_WELCOME_MESSAGE, this._showWelcomeMessage.bind(this));

  eventDispatcher.addEventListener(Event.TYPES.AD_BILLBOARD_VISIBLE, this._hide.bind(this));

  return this;
};

/**
 * Show upsell message
 */
CappingFullScreenMessage.prototype._showUpsellMessage = function () {
  this.cappingMessageTitle(_('capping.upsell-title'));
  this.cappingMessageText(_('capping.upsell-message'));
  this.cappingButtonLabel(_('capping.upsell-button-label'));

  var nextRefill = this.cappingManagerListener.getNextRefillTimeInDays();
  if (nextRefill !== false) {
    this.cappingTopInformation(_('capping.refillMessage', nextRefill));
  } else {
    this.cappingTopInformation(_('capping.defaultRefillMessage'));
  }

  this._domElement.classList.remove('hidden');
  this.showCappingMessage(true);
  this.currentContext = 'capping-upsell-message';

  this._addClickEvents(true);

  this.logger.log({
    event: 'user:impression',
    event_version: this.currentContext
  });
};

/**
 * Show upsell message
 */
CappingFullScreenMessage.prototype._showWelcomeMessage = function () {
  this.cappingMessageTitle(_('capping.welcome-title'));
  this.cappingMessageText(_('capping.welcome-message', 'upgrade'));
  this.cappingButtonLabel(_('capping.welcome-message-button-label'));
  this.cappingTopInformation('');

  this._domElement.classList.remove('hidden');
  this.showCappingMessage(true);
  this.currentContext = 'capping-welcome-message';

  this._addClickEvents();

  this.logger.log({
    event: 'user:impression',
    event_version: this.currentContext
  });
};

CappingFullScreenMessage.prototype._addClickEvents = function () {
  document.addEventListener('click', this._documentClicked);
  this._domElement.addEventListener('click', this._elementClicked);
};

CappingFullScreenMessage.prototype._removeClickEvents = function () {
  document.removeEventListener('click', this._documentClicked);
  this._domElement.removeEventListener('click', this._elementClicked);
};

CappingFullScreenMessage.prototype._documentClicked = function () {
  if (!this.showCappingMessage()) {
    return;
  }
  this._hide();

  this.logger.log({
    event: 'user:hit',
    event_version: 'out-of-upsell-message',
    context: this.currentContext,
    json_data: {
      target_uri: '',
      name: 'Hide'
    }
  });
};

CappingFullScreenMessage.prototype._elementClicked = function () {
  event.stopPropagation();

  var element = event.target;

  if (element && element.dataset.action) {
    if (element.dataset.action === 'upgrade') {
      this.openProductUpgradePage();
    }
  }
};

/**
 * Hides the message
 */
CappingFullScreenMessage.prototype._hide = function () {
  this.currentContext = false;
  this._domElement.classList.add('hidden');
  this.showCappingMessage(false);

  this._removeClickEvents(false);
};

/**
 * Hides the message - method for ko bindings
 */
CappingFullScreenMessage.prototype.hideMessage = function () {
  this._hide();

  this.logger.log({
    event: 'user:hit',
    event_version: 'hide-button',
    context: this.currentContext,
    json_data: {
      target_uri: '',
      name: 'Hide'
    }
  });
};

/**
 * Update the left offset position of the container.
 *
 * @param {String} offset The new offset to apply.
 */
CappingFullScreenMessage.prototype._updateOffsetLeft = function (offset) {
  this._domElement.style.left = offset;
};

/**
 * Get a link to the upgrade page, open it in browser
 */
CappingFullScreenMessage.prototype.openProductUpgradePage = function () {
  var baseParams = {
    'utm_source': 'spotify',
    'utm_medium': 'product-KM',
    'utm_campaign': 'user-menu-upgrade'
  };

  var query = [];
  Object.keys(baseParams).forEach(function (k) {
    query.push(k + '=' + baseParams[k]);
  });

  var url = 'https://www.spotify.com/redirect/upgrade-product?' + query.join('&');
  session.getOAuthToken(url, function (error, token) {
    url += error ? '' : '&' + token;
    if (window) window.open(url);
  });

  this.logger.log({
    event: 'user:hit',
    event_version: 'upgrade-button',
    context: this.currentContext,
    json_data: {
      target_uri: url,
      name: 'Upgrade to Premium'
    }
  });
};

/**
 * Trigger an action for the main button
 */
CappingFullScreenMessage.prototype.onClickMainAction = function () {
  if (this.currentContext === 'capping-upsell-message') {
    this.openProductUpgradePage();
  } else if (this.currentContext === 'capping-welcome-message') {
    this._hide();
  }
};

module.exports = CappingFullScreenMessage;

},{"../../../../libs/spotify-event-dispatcher":264,"../../i18n":11,"../capping-manager-listener":27,"../event":77,"../logging/client-event-logger":93,"../models/localsettings":100,"../models/session":107,"knockout":567}],132:[function(require,module,exports){
'use strict';

var ChurnedLockedState = function ChurnedLockedState(win) {
  this._win = win;
  this._doc = win.document;

  this._baseUrl = 'https://www.spotify.com';
  this._containerId = 'churned-locked-state';
  this._flowCompletionExpires = 24 * 60 * 60 * 1000; // 24 hours
  this._dialogPadding = 100;

  this._playerListener = null;
  this._container = null;
  this._overlayContainer = null;
  this._cancelButton = null;
  this._updateButton = null;
  this._isViewBuilt = false;
  this._isPlayingFromLocalDevice = false;
  this._countryCode = null;
  this._storage = null;
  this._logger = null;
  this._abTest = null;
};

ChurnedLockedState.prototype._setupStorage = function () {
  var live = require('../../../../libs/spotify-live');
  this._storage = live('spotify:client-storage');
};

ChurnedLockedState.prototype._setupLogger = function () {
  this._logger = require('../logging/client-event-logger');
};

ChurnedLockedState.prototype._setupAbTest = function () {
  this._abTest = require('../../../../libs/spotify-abba-mini');
};

ChurnedLockedState.prototype._logImpression = function () {
  this._logger.log({
    event: 'user:impression',
    event_version: 'cls.zelda.impression'
  });
};

ChurnedLockedState.prototype._logClickedFlow = function (url) {
  this._logger.log({
    event: 'user:hit',
    event_version: 'cls.zelda.webflow.clicked',
    json_data: {
      'target_uri': url
    }
  });
};

ChurnedLockedState.prototype._logCompletedWebFlow = function (url) {
  this._logger.log({
    event: 'info:default',
    event_version: 'cls.zelda.webflow.completed',
    json_data: {
      'target_uri': url
    }
  });
};

ChurnedLockedState.prototype._logNotCompletedWebFlow = function (url) {
  this._logger.log({
    event: 'info:default',
    event_version: 'cls.zelda.webflow.notCompleted',
    json_data: {
      'target_uri': url
    }
  });
};

ChurnedLockedState.prototype._renderTemplate = function (data) {
  var template = require('../../templates/modals/churned-locked-state.hbs');
  return template(data);
};

ChurnedLockedState.prototype._getCopy = function () {
  var _ = require('../../i18n').get;
  return {
    highlight: _('cls.highlight'),
    title: _('cls.title'),
    desc: _('cls.desc'),
    updatePayment: _('cls.updatePayment'),
    cancelSubscription: _('cls.cancelSubscription')
  };
};

ChurnedLockedState.prototype._buildView = function () {
  if (this._isViewBuilt) return;

  this._container = this._doc.createElement('div');
  this._container.id = this._containerId;
  this._container.innerHTML = this._renderTemplate(this._getCopy());
  this._doc.getElementById('main-container').appendChild(this._container);

  this._overlayContainer = this._doc.querySelector('.overlay');

  this._cancelButton = this._overlayContainer.querySelector('.cancel-sub');
  this._cancelButton.addEventListener('click', this._loadCancellation.bind(this));

  this._updateButton = this._overlayContainer.querySelector('.update-payment');
  this._updateButton.addEventListener('click', this._loadUpdatePaymentDetails.bind(this));

  this._isViewBuilt = true;
};

ChurnedLockedState.prototype._show = function () {
  if (!this._container) return;
  this._container.style.display = 'block';
  this._logImpression();
};

ChurnedLockedState.prototype._hide = function () {
  if (!this._container) return;
  this._container.style.display = 'none';
};

ChurnedLockedState.prototype._observeDeviceToggle = function () {
  var eventDispatcher = require('../../../../libs/spotify-event-dispatcher');
  var EventTypes = require('../event').TYPES;
  var self = this;

  eventDispatcher.addEventListener(EventTypes.SPCONNECT_DEVICE_STATE, function (event) {
    if (!event.params.devices) return;

    for (var i = 0; i < event.params.devices.length; i++) {
      var device = event.params.devices[i];
      if (device.active && !device.id) {
        self._isPlayingFromLocalDevice = true;
        return;
      }
    }

    self._isPlayingFromLocalDevice = false;
  });
};

ChurnedLockedState.prototype._disablePlayback = function () {
  var player = require('../models/player').getPlayer();
  var self = this;

  this._playerListener = player.subscribe(function (err, response) {
    var data = response.getJSONBody();

    if (self._isPlayingFromLocalDevice && data.is_playing && !data.is_paused) {
      player.pause();
    }
  });
};

ChurnedLockedState.prototype._enablePlayback = function () {
  if (!this._playerListener) return;
  this._playerListener.cancel();
};

ChurnedLockedState.prototype._getWebflowDialogSize = function () {
  var paddedWidth = this._win.outerWidth - this._dialogPadding;
  var paddedHeight = this._win.outerHeight - this._dialogPadding;
  var minWidth = 800;
  var minHeight = 600;

  if (paddedWidth <= minWidth || paddedHeight <= minHeight) {
    return { width: minWidth, height: minHeight };
  }

  return { width: paddedWidth, height: paddedHeight };
};

ChurnedLockedState.prototype._loadWebFlow = function (urlPath) {
  var session = require('../models/session');
  var baseUrl = this._baseUrl + '/' + this._countryCode;
  var url = baseUrl + urlPath;
  var closeUrl = baseUrl + '/mobile/close';
  var self = this;

  this._logClickedFlow(url);

  session.getOAuthToken(url, function (err, token) {
    if (err || !token) return;

    url += (url.indexOf('?') !== -1 ? '&' : '?') + token;

    var dialogSize = self._getWebflowDialogSize();
    var dialogOptions = {
      url: 'sp://oauth/v1/flow',
      body: {
        'url': url,
        'close_url': closeUrl,
        'window': {
          'width': dialogSize.width,
          'height': dialogSize.height
        }
      }
    };

    var client = require('spotify-cosmos-api').resolver;
    client.post(dialogOptions, self._webFlowCallback.bind(self));
  });
};

ChurnedLockedState.prototype._webFlowCallback = function (err, response) {
  if (err) return;
  var result = response.getJSONBody();

  if (!result.complete || result.url.indexOf('cls_unlocked') === -1) {
    this._logNotCompletedWebFlow();
    return;
  }

  this._saveFlowCompletionTimestamp();
  this._disable();
  this._logCompletedWebFlow();
};

ChurnedLockedState.prototype._loadCancellation = function () {
  this._loadWebFlow('/redirect/generic/?' + 'redirect_key=android_churn_locked_state_cancel_subscription');
};

ChurnedLockedState.prototype._loadUpdatePaymentDetails = function () {
  this._loadWebFlow('/redirect/generic/?' + 'redirect_key=android_churn_locked_state_update_payment');
};

ChurnedLockedState.prototype.checkAbTest = function (callback) {
  this._abTest('rollout-churn-lock-state', function (err, group) {
    if (err) return;

    var isOnAbTest = typeof group !== 'undefined' && Boolean(group) && group === 'Enabled';

    callback(isOnAbTest);
  });
};

ChurnedLockedState.prototype._checkEligibility = function (callback) {
  var client = require('spotify-cosmos-api').resolver;
  var self = this;

  client.subscribe('sp://product-state/v1/values', function (err, response) {
    if (err) return;
    var flags = response.getJSONBody();

    self.checkAbTest(function (isOnAbTest) {
      self._countryCode = typeof flags.country_code !== 'undefined' ? flags.country_code.toLowerCase() : self._countryCode || 'us';

      var isLocked = typeof flags['payments-locked-state'] !== 'undefined' && Number(flags['payments-locked-state']);

      callback(isLocked && isOnAbTest);
    });
  });
};

ChurnedLockedState.prototype._saveFlowCompletionTimestamp = function () {
  this._storage.publish({ 'flowCompletedAt': Date.now() });
};

ChurnedLockedState.prototype._shouldWaitToEnable = function (callback) {
  var self = this;

  this._storage.get('flowCompletedAt', function (err, flowCompletedAt) {
    var shouldWaitToEnable = err || flowCompletedAt && Date.now() - flowCompletedAt < self._flowCompletionExpires;

    callback(shouldWaitToEnable);
  });
};

ChurnedLockedState.prototype._enable = function () {
  var self = this;

  this._shouldWaitToEnable(function (shouldWaitToEnable) {
    if (shouldWaitToEnable) return;

    self._buildView();
    self._show();
    self._disablePlayback();
  });
};

ChurnedLockedState.prototype._disable = function () {
  this._hide();
  this._enablePlayback();
};

ChurnedLockedState.prototype.start = function () {
  var self = this;

  this._setupStorage();
  this._setupLogger();
  this._setupAbTest();
  this._observeDeviceToggle();

  this._checkEligibility(function (isEligible) {
    isEligible ? self._enable() : self._disable();
  });
};

module.exports = ChurnedLockedState;

},{"../../../../libs/spotify-abba-mini":181,"../../../../libs/spotify-event-dispatcher":264,"../../../../libs/spotify-live":439,"../../i18n":11,"../../templates/modals/churned-locked-state.hbs":175,"../event":77,"../logging/client-event-logger":93,"../models/player":101,"../models/session":107,"spotify-cosmos-api":694}],133:[function(require,module,exports){
'use strict';

var ko = require('knockout');
var AppHandler = require('../app-handler');
var eventsCenter = require('../../../../libs/spotify-events/center');
var controlMessagesHandler = require('../controlmessageshandler');
var eventDispatcher = require('../../../../libs/spotify-event-dispatcher');
var EventTypes = require('../event').TYPES;

/**
 * View model for the content area
 *
 * @constructor
 */
function Content(doc) {
  /**
   * A reference to the global document object
   * that can be mocked by passing the mock object to
   * the constructor
   *
   */
  this._document = doc || window.document;

  /**
   * The active app, if any.
   *
   * @type {Element}
   */
  this._active = null;

  /**
   * The last requested URI.
   *
   * @type {string}
   */
  this._lastRequestedURI = null;

  /**
   * The last visible URI.
   *
   * @type {string}
   */
  this._lastVisibleURI = null;

  /**
   * Application Handler
   *
   * @type {AppHandler}
   */
  this._appHandler = new AppHandler(this._document.getElementById('view-content'));

  /**
   * Are we currently in the process of loading an app?
   *
   * @type {Boolean}
   */
  this.loading = ko.observable(false);

  /**
   * Don't display the throbber immediately, so default to false.
   * It will be set to true after a short timeout if nothing has
   * been loaded since start.
   *
   * @type {Boolean}
   */
  this.displayThrobber = ko.observable(false);

  this.disablePointerEvents = ko.observable(false);
}

/**
 * Setup functionality
 *
 * @return {Content} The instance.
 */
Content.prototype.setup = function () {
  eventDispatcher.addEventListener(EventTypes.NAVIGATION_STATE_CHANGE, this._onNavChange.bind(this));

  eventsCenter.on('scroll-thumb-drag-start', function (event) {
    if (event.id === 'app-sidebar') {
      this.disablePointerEvents(true);
    }
  }.bind(this));

  eventsCenter.on('scroll-thumb-drag-end', function (event) {
    if (event.id === 'app-sidebar') {
      this.disablePointerEvents(false);
    }
  }.bind(this));

  // Show a throbber if nothing has been loaded after 2 seconds
  var self = this;
  setTimeout(function () {
    if (!self.loading() && !self._active) {
      self.loading(true);
      self.displayThrobber(true);
    }
  }, 2000);
};

/**
 * Open a Spotify URI and display it in the main content area.
 *
 * @param {String} uri The Spotify URI to open.
 */
Content.prototype.openApp = function (appState) {
  var self = this;

  this._lastRequestedURI = appState.getURI();

  if (this._active) {
    if (appState.equals(this._active.getState())) {
      return;
    }
    this._sendViewMessage('close', this._active);
  }

  var app = this._appHandler.openApp(appState, function (app) {
    // Prevent transitioning to an app that is not the last requested app.
    // As opening the app is async, there might have been a new request made
    // before this callback is called, and the second request might have been
    // completed before the first one. If we don't do this check, we might end
    // up transitioning back to an old app.
    if (self._lastRequestedURI !== appState.getURI()) {
      return;
    }

    self._lastRequestedURI = null;

    var oldApp = self._active;

    self._sendViewMessage('open', app);

    self._transitionTo(app);

    self.loading(false);
    self.displayThrobber(false);

    if (oldApp && oldApp.getName() !== app.getName()) {
      oldApp.sendActiveMessage(false);
    }
  });

  this._updateAriaLabel(app);

  return app;
};

Content.prototype._onNavChange = function (evt) {
  this.openApp(evt.params.state);
};

/**
 * Transition to given app
 *
 * @param {Element} app The App to transition to.
 */
Content.prototype._transitionTo = function (app) {
  if (this._active) {
    this._active.getContainer().classList.remove('active');
  }
  this._active = app;
  this._active.getContainer().classList.add('active');
};

Content.prototype._sendViewMessage = function (type, app) {
  var data = {
    type: type === 'open' ? 'view_opened' : 'view_closed',
    uri: app.getURI(),
    version: '',
    vendor: ''
  };

  var iframe = app.getContainer();
  var manifest = iframe.contentWindow && iframe.contentWindow.__spotify && iframe.contentWindow.__spotify.app_manifest;
  if (manifest) {
    data.version = manifest.BundleVersion;
    data.vendor = manifest.VendorIdentifier;
  }

  // Log that the view was opened/closed
  controlMessagesHandler.send(data);
};

/**
 * Read title from iframe and update the aria-label on its
 * container accordingly. The iframe container element is
 * equipped with `role="main"`, and this aria-label will give
 * screen readers additional information about the content inside
 * the iframe.
 *
 * Landmarks in VoiceOver are not updated when role elements are
 * dynamically added and removed. Putting the role and aria-label
 * on the parent element is a workaround for this Chromium
 * (or possibly VoiceOver) bug.
 *
 * The bug has been filed here:
 * https://code.google.com/p/chromium/issues/detail?id=402869
 *
 * @parm {App} app The app to extract the title from.
 */
Content.prototype._updateAriaLabel = function (app) {
  var iframe = app.getContainer();
  var title = iframe.contentDocument && iframe.contentDocument.title;
  iframe.parentNode.setAttribute('aria-label', title || '');
};

/**
 * URI of the active iframe
 */
Object.defineProperty(Content.prototype, 'activeApp', {
  get: function get() {
    return this._active && this._active.getURI();
  }
});

module.exports = Content;

},{"../../../../libs/spotify-event-dispatcher":264,"../../../../libs/spotify-events/center":268,"../app-handler":23,"../controlmessageshandler":74,"../event":77,"knockout":567}],134:[function(require,module,exports){
'use strict';

var ContextMenu = require('../components/contextmenu');
var Event = require('../event');
var live = require('../../../../libs/spotify-live');
var rootlistModel = require('../models/rootlist');
var playlistAnnotateModel = require('../models/playlist-annotate');
var util = require('../live-models/util');
var eventDispatcher = require('../../../../libs/spotify-event-dispatcher');
var NEW_FOLDER_URI = require('../live-models/uris').NEW_FOLDER_URI;
var NEW_PLAYLIST_URI = require('../live-models/uris').NEW_PLAYLIST_URI;
var UIInteraction4 = require('../../../../libs/spotify-logger/messages/UIInteraction4');

/**
 * Model for the context actions popup.
 *
 * @constructor
 */
function ContextActions() {}

/**
 * Setup functionality
 *
 * Adds event listener to right click
 */
ContextActions.prototype.setup = function () {
  var self = this;

  rootlistModel.setup();

  this._contextMenu = new ContextMenu();

  this._contextMenu.addListener('hide', function () {
    // Put focus back to the iframe that originated the context menu once it's
    // closed. Also make the iframe the active element in zlink.
    if (self._originIframe) {
      self._originIframe.focus();
      self._originIframe = null;
    }

    eventDispatcher.dispatchEvent(new Event(Event.TYPES.POPOVER_CLOSED, { id: self._popoverId }));
  });

  this._contextMenu.setRenamePlaylistAction(function (playlistURI) {
    console.log('RenameTriggerLogging: Context menu to rename', new Date());
    live(util.getRowUri(playlistURI)).update({
      renaming: true
    });
  });

  this._contextMenu.setRenameFolderAction(function (playlistURI) {
    live(util.getRowUri(playlistURI)).update({
      renaming: true
    });
  });

  this._contextMenu.setEditPlaylistAction(function (playlistURI) {
    playlistAnnotateModel.showUI(playlistURI);
  });

  this._contextMenu.setCreateFolderAction(function (uri) {
    UIInteraction4.log({
      feature_id: live('spotify:application').get('appURI') || 'unknown',
      interaction_type: 'hit',
      section_id: 'context-menu',
      timestamp: Date.now(),
      user_intent: 'create-folder'
    });
    util.createRootlistItem(NEW_FOLDER_URI, {
      belowRow: util.getRowUri(uri)
    });
  });

  this._contextMenu.setCreatePlaylistAction(function (uri) {
    console.log('RenameTriggerLogging: Context menu create playlist', new Date());
    UIInteraction4.log({
      feature_id: live('spotify:application').get('appURI') || 'unknown',
      interaction_type: 'hit',
      section_id: 'context-menu',
      timestamp: Date.now(),
      user_intent: 'create-playlist'
    });
    util.createRootlistItem(NEW_PLAYLIST_URI, {
      belowRow: util.getRowUri(uri)
    });
  });

  this._contextMenu.setRemovePlaylistAction(function (uri) {
    live(util.getRowUri(uri)).update({
      deleting: true
    });
  });

  // Listen for right click events
  eventDispatcher.addEventListener(Event.TYPES.CONTEXT_SHOW_UI, function (evt) {
    this._display({
      x: evt.params.left,
      y: evt.params.top,
      uris: evt.params.items,
      contexts: [{
        uri: evt.params.itemContext,
        primaryIndex: evt.params.itemIndex,
        indices: null
      }]
    }, evt.source.window);
  }.bind(this));

  eventDispatcher.addEventListener(Event.TYPES.CONTEXT_CLIENT_SHOW_UI, function (evt) {
    // Hack to inject the desired context when the right click event
    // comes from the sidebar
    if (evt.source.window === window) {
      evt.params.contexts = [{
        uri: 'spotify:internal:sidebar'
      }];
    }

    this._display(evt.params, evt.source.window);
  }.bind(this));

  return this;
};

ContextActions.prototype._popoverId = 'contextmenu';

/**
 * Display the context menu
 */
ContextActions.prototype._display = function (data, originWindow) {
  var self = this;

  // This will be null if zlink was the source.
  this._originIframe = originWindow.frameElement;

  var offsetX = 0;
  var offsetY = 0;

  // If the event comes from an iframe, handle the event position as relative
  // to the position of the iframe (and all parents).
  var win = originWindow;
  while (win.frameElement) {
    var bounds = win.frameElement.getBoundingClientRect();
    offsetX += bounds.left;
    offsetY += bounds.top;
    win = win.parent;
  }

  data.x = data.x + offsetX;
  data.y = data.y + offsetY;

  rootlistModel.getRows(function (error, rows) {
    if (error) {
      return console.log('Error fetching playlists', error);
    }

    var playlists = rows.map(function (row) {
      return {
        uri: row.playlist.uri
      };
    });

    self._contextMenu.setUserPlaylists(playlists);
    self._contextMenu.show(data);

    // Focus zlink window so we can capture keys (like esc)
    // The window focus is to move it to the top frame.
    // The body focus is to move it to the outermost element (otherwise
    // another element like the sidebar might get focus).
    window.focus();
    document.body.focus();

    eventDispatcher.dispatchEvent(new Event(Event.TYPES.POPOVER_OPENED, { id: self._popoverId }));
  });
};

module.exports = new ContextActions();

},{"../../../../libs/spotify-event-dispatcher":264,"../../../../libs/spotify-live":439,"../../../../libs/spotify-logger/messages/UIInteraction4":452,"../components/contextmenu":59,"../event":77,"../live-models/uris":90,"../live-models/util":91,"../models/playlist-annotate":102,"../models/rootlist":105}],135:[function(require,module,exports){
(function (global){
'use strict';

var formats = global.UNIT_TEST ? require('../../tests/support/mocks/mock_ad_formats') : require('../../../../libs/spotify-ad-formats');
var AdsUtils = require('../ads-utils.js');
var EventTypes = require('../event').TYPES;
var eventDispatcher = require('../../../../libs/spotify-event-dispatcher');

var abba = require('../../../../libs/spotify-abba-mini');

var window = global.window || {};

var DEFAULT_LEADERBOARD_VERSION = 'v1';

/**
 * View model for the leaderboard ad, shown at the bottom of the screen
 * on pages where it's whitelisted.
 *
 * @constructor
 */
function LeaderboardAd() {
  this._domElement = document.getElementById('view-leaderboard-ad');
  this._isInFocus = false;
  this._isEnabled = false;
  this._isRefreshing = false;
  this._currentUri = '';
  this._audioAdPlaying = false;
  this._videoAdPlaying = false;
  this._billboardAdActive = false;
  this._stateUpdateDelay = 500; // ms
}

/**
 * Setup functionality. Based on activation/disactivation of a spotlet we
 * enable/disable an ad.
 *
 * @public
 */
LeaderboardAd.prototype.setup = function () {
  var _this = this;

  return new Promise(function (resolve) {
    _this._abbaLeaderboardVersion().then(function (version) {
      if (version === 'v3') {
        _this._leaderboard = new formats.LeaderboardAdV3(_this._domElement);
      } else if (version === 'v2') {
        _this._leaderboard = new formats.LeaderboardAdV2('zlink', _this._domElement);
      } else {
        _this._leaderboard = formats.LeaderboardAdV1.create(_this._domElement);
      }
      _this.addEventListeners();
      _this._updateState();

      resolve();
    }).catch(function (e) {
      console.error('LeaderboardAd::setup error', e);
      eventDispatcher.dispatchEvent({
        type: EventTypes.AD_LEADERBOARD_ERROR,
        params: {
          context: 'setup',
          error: e
        }
      });
    });
  });
};

LeaderboardAd.prototype._abbaLeaderboardVersion = function () {
  return new Promise(function (resolve) {
    // https://abtesting.spotify.net/#/features/712
    abba('ad_leaderboard_version', function (err, cell) {
      if (!cell) {
        cell = DEFAULT_LEADERBOARD_VERSION;
      }
      resolve(cell);
    });
  });
};

LeaderboardAd.prototype.addEventListeners = function () {
  var _this = this;

  eventDispatcher.addEventListener(EventTypes.AD_VIDEO_STARTED, function () {
    _this._videoAdPlaying = true;
    _this._onStateChanged();
  });

  eventDispatcher.addEventListener(EventTypes.AD_VIDEO_FINISHED, function () {
    _this._videoAdPlaying = false;
    _this._onStateChanged();
  });

  eventDispatcher.addEventListener(EventTypes.AD_BILLBOARD_STARTED, function (e) {
    if (!e.params.isDummyAd) {
      _this._billboardAdActive = true;
      _this._onStateChanged();
    }
  });

  eventDispatcher.addEventListener(EventTypes.AD_BILLBOARD_DISCARDED, function () {
    _this._billboardAdActive = false;
    _this._onStateChanged();
  });

  eventDispatcher.addEventListener(EventTypes.NAVIGATION_STATE_CHANGE, function (e) {
    _this._currentUri = e.params.uri;
    _this._onStateChanged();
  });

  eventDispatcher.addEventListener(EventTypes.APPLICATION_FOCUS_LOST, function () {
    _this._isInFocus = false;
    _this._onStateChanged();
  });

  eventDispatcher.addEventListener(EventTypes.APPLICATION_FOCUS_GAINED, function () {
    _this._isInFocus = true;
    _this._onStateChanged();
  });

  eventDispatcher.addEventListener(EventTypes.AD_LEADERBOARD_PLACEMENT, function (e) {
    if (e.params.isEmpty) {
      _this._leaderboard.removeContent();
    }
  });

  eventDispatcher.addEventListener(EventTypes.AD_AUDIO_STARTED, function () {
    _this._audioAdPlaying = true;
    _this._onStateChanged();
  });

  eventDispatcher.addEventListener(EventTypes.AD_AUDIO_FINISHED, function () {
    _this._audioAdPlaying = false;
    _this._onStateChanged();
  });

  window.addEventListener('message', function (e) {
    if (e.origin === 'http://playlist-desktop.app.spotify.com' && e.data.type === EventTypes.AD_SPONSORSHIP_ACTIVE) {
      AdsUtils.addToLeaderboardBlacklist(_this._currentUri);
      _this._onStateChanged();
    }
  });
};

/**
 * Enable the leaderboard ad format, will also start refreshing ads.
 *
 * @private
 */
LeaderboardAd.prototype._enable = function () {
  if (this._isEnabled) return;
  this._leaderboard.enable();
  this._isEnabled = true;
  this._isRefreshing = true;
};

/**
 * Disable the leaderboard ad format (won't take up any space on the page).
 *
 * @private
 */
LeaderboardAd.prototype._disable = function () {
  if (!this._isEnabled) return;
  this._leaderboard.disable();
  this._isEnabled = false;
  this._isRefreshing = false;
};

/**
 * Enable refreshing ads, if possible.
 *
 * @private
 */
LeaderboardAd.prototype._enableRefresh = function () {
  if (this._isRefreshing || !this._isEnabled) return;
  this._leaderboard.enableRefresh();
  this._isRefreshing = true;
};

/**
 * Disable refreshing ads, if possible and not already disabled.
 *
 * @private
 */
LeaderboardAd.prototype._disableRefresh = function () {
  if (!this._isRefreshing || !this._isEnabled) return;
  this._leaderboard.disableRefresh();
  this._isRefreshing = false;
};

/**
 * Update the state of the leaderboard.
 *
 * @private
 */
LeaderboardAd.prototype._updateState = function () {
  if (AdsUtils.isBlacklistedForLeaderboard(this._currentUri) || this._audioAdPlaying || this._videoAdPlaying || this._billboardAdActive) {
    this._disable();
  } else if (this._isInFocus) {
    this._enable();
  }

  if (this._isInFocus) {
    this._enableRefresh();
  } else {
    this._disableRefresh();
  }
};

/**
 * Should be called whenever the state has changed and we need to determine
 * the new state of the leaderboard ads.
 *
 * Sometimes there's gonna be multiple events triggering the state to change
 * fired almost at the same time, for example when a video ad ends and an
 * audio ad starts. Therefore we need to delay the state update for some time
 * to gather the full new state.
 *
 * @private
 */
LeaderboardAd.prototype._onStateChanged = function () {
  clearTimeout(this._updateStateTimer);
  var _this = this;
  this._updateStateTimer = setTimeout(function () {
    _this._updateState();
  }, this._stateUpdateDelay);
};

module.exports = LeaderboardAd;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../../../libs/spotify-abba-mini":181,"../../../../libs/spotify-ad-formats":203,"../../../../libs/spotify-event-dispatcher":264,"../../tests/support/mocks/mock_ad_formats":178,"../ads-utils.js":22,"../event":77}],136:[function(require,module,exports){
(function (global){
'use strict';

var ko = require('knockout');
var _ = require('../../i18n').get;
var Event = require('../event');
var session = require('../models/session');
var eventDispatcher = require('../../../../libs/spotify-event-dispatcher');
var connectionMonitor = require('../connectionmonitor');
var controlMessagesHandler = require('../controlmessageshandler');
var live = require('../../../../libs/spotify-live');
var urls = require('../urls.json');
var cosmos = require('spotify-cosmos-api');
var Preferences = require('../../../../libs/spotify-preferences');
var Player = require('../models/player');
var abbaSubscriber = require('../utils/abba-subscriber.js');

var OFFLINE_TIMEOUT = connectionMonitor.offlineTimeout;

/**
 * Messages should be translated
 */
var ERROR_BASE_ID = 100000;

var ERROR_PLAY_TOKEN_LOST_ID = ERROR_BASE_ID + 1;
var ERROR_PLAY_TOKEN_LOST_MESSAGE = 'play-token-lost';

var DEFAULT_PLAYBACK_STUCK_ID = ERROR_BASE_ID + 2;
var DEFAULT_PLAYBACK_STUCK_MESSAGE = 'cant-play-track';

var ERROR_FORCED_OFFLINE_MODE_ID = ERROR_BASE_ID + 3;
var ERROR_FORCED_OFFLINE_MODE_MESSAGE = 'track-not-available-forced-offline';

var ERROR_REGION_RESTRICTED_ID = 1001;
var ERROR_REGION_RESTRICTED_MESSAGE = 'track-not-available-in-region';

var DEFAULT_PLAYER_ERROR_ID = 1002;
var DEFAULT_PLAYER_ERROR_MESSAGE = 'track-not-available';

var ERROR_PREMIUM_RESTRICTED_ID = 1003;
var ERROR_PREMIUM_RESTRICTED_MESSAGE = 'track-exclusive-premium';

var ERROR_CANT_SKIP_ADS_ID = 31;
var ERROR_CANT_SKIP_ADS_MESSAGE = 'cant-skip-ads';

var ERROR_CAPPING_REACHED_ID = 1010;
var ERROR_CAPPING_REACHED_MESSAGE = 'capping-reached';

var ERROR_VIDEO_GEO_RESTRICTED_ID = 1004;
var ERROR_VIDEO_GEO_RESTRICTED_MESSAGE = 'video-georestricted';

var ERROR_VIDEO_UNSUPPORTED_CLIENT_VERSION_ID = 1005;
var ERROR_VIDEO_UNSUPPORTED_CLIENT_VERSION_MESSAGE = 'video-unsupported-client-version';

var ERROR_VIDEO_UNSUPPORTED_PLATFORM_VERSION_ID = 1006;
var ERROR_VIDEO_UNSUPPORTED_PLATFORM_VERSION_MESSAGE = 'video-unsupported-platform-version';

var ERROR_VIDEO_COUNTRY_RESTRICTED_ID = 1007;
var ERROR_VIDEO_COUNTRY_RESTRICTED_MESSAGE = 'video-country-restricted';

var ERROR_VIDEO_UNAVAILABLE_ID = 1008;
var ERROR_VIDEO_UNAVAILABLE_MESSAGE = 'video-unavailable';

var ERROR_VIDEO_CATALOGUE_RESTRICTED_ID = 1009;
var ERROR_VIDEO_CATALOGUE_RESTRICTED_MESSAGE = 'video-catalogue-restricted';

var ERROR_VIDEO_PLAYBACK_ERROR_ID = 1010;
var ERROR_VIDEO_PLAYBACK_ERROR_MESSAGE = 'video-playback-error';

var ERROR_MESSAGES = {
  // Player errors
  1000: DEFAULT_PLAYER_ERROR_MESSAGE,
  1001: 'track-not-available-in-region',
  1002: 'track-not-available',
  1003: 'track-exclusive-premium',
  1004: 'track-banned-by-artist',
  1005: 'local-track-no-file',
  1006: 'local-track-file-not-found',
  1007: 'local-track-bad-format',
  1009: DEFAULT_PLAYER_ERROR_MESSAGE,
  1010: 'capping-reached',
  1011: 'local-track-drm-protected',
  1012: DEFAULT_PLAYER_ERROR_MESSAGE,
  1013: DEFAULT_PLAYER_ERROR_MESSAGE,
  1014: DEFAULT_PLAYER_ERROR_MESSAGE,
  1015: DEFAULT_PLAYER_ERROR_MESSAGE,

  // Offline errors
  8: 'offline-disk-cache',
  14: 'offline-sync-expired',
  15: 'offline-sync-failed',
  19: 'offline-too-many-tracks',
  21: 'offline-license-server-error',
  22: 'offline-license-lost',
  23: 'offline-not-allowed',

  // Ad errors
  31: ERROR_CANT_SKIP_ADS_MESSAGE
};

var PAYMENT_STATE_ERRORS = [{
  regExp: /^creditcard_funds;/,
  id: 'payment-state-creditcard-funds',
  limit: 24 * 60 * 60 * 1000 // Show at most once in 24 hours.
}, {
  regExp: /^creditcard_refused;/,
  id: 'payment-state-creditcard-refused',
  limit: 24 * 60 * 60 * 1000
}, {
  regExp: /^paypal_refused;/,
  id: 'payment-state-paypal-refused',
  limit: 24 * 60 * 60 * 1000
}, {
  regExp: /^creditcard_expiry/,
  id: 'payment-state-creditcard-expiry'
}, {
  regExp: /^prepaid_expiry/,
  id: 'payment-state-prepaid-expiry'
}, {
  regExp: /^churn_payment/,
  id: 'payment-state-churn-payment'
}, {
  regExp: /^churn_partner/,
  id: 'payment-state-churn-partner'
}, {
  regExp: /^opt-in-trial;/,
  id: 'opt-in-trial'
}, {
  regExp: /^expired-opt-in-trial;/,
  id: 'opt-in-trial-expired',
  limit: 14 * 24 * 60 * 60 * 1000 // Show at most once in 14 days.
}];

var openExternalPage = function openExternalPage(url) {
  return function (e) {
    e.preventDefault();
    this._openExternalPage(url);
  };
};

var ACTIONS = {
  restart: function restart(e) {
    e.preventDefault();
    controlMessagesHandler.send({ type: 'restart' });
  },
  upgradeToPremium: openExternalPage(urls.messageBar.upgradeToPremium),
  supportedFormats: openExternalPage(urls.messageBar.supportedFormats),
  creditCardFunds: openExternalPage(urls.messageBar.creditCardFunds),
  creditCardRefused: openExternalPage(urls.messageBar.creditCardRefused),
  creditCardExpiry: openExternalPage(urls.messageBar.creditCardExpiry),
  paypalRefused: openExternalPage(urls.messageBar.paypalRefused),
  prepaidExpiry: openExternalPage(urls.messageBar.prepaidExpiry),
  churnPayment: openExternalPage(urls.messageBar.churnPayment),
  churnPartner: openExternalPage(urls.messageBar.churnPartner),
  optInTrial: openExternalPage(urls.messageBar.optInTrial),
  optInTrialExpired: openExternalPage(urls.messageBar.optInTrialExpired),
  cantOfflinePlaylists: openExternalPage(urls.messageBar.cantOfflinePlaylists),
  cantSetHighQualityStreaming: openExternalPage(urls.messageBar.cantSetHighQualityStreaming),
  cappingExplained: openExternalPage(urls.messageBar.cappingExplained),

  deprecatingOsVersion: function deprecatingOsVersion(e) {
    e.preventDefault();
    window.open(urls.messageBar.deprecatedOs);
  },

  enableAutoStart: function enableAutoStart(e) {
    e.preventDefault();
    this._changeAutoStartSetting('normal');
  },
  disableAutoStart: function disableAutoStart(e) {
    e.preventDefault();
    this._changeAutoStartSetting('off');
  },

  goOnline: function goOnline(e) {
    e.preventDefault();
    connectionMonitor.setForceOffline(false);
  },

  requestFacebookPublishPermissions: function requestFacebookPublishPermissions(e) {
    e.preventDefault();
    var messageBar = this;
    cosmos.resolver.post({
      url: 'sp://facebook/v1/permissions',
      body: { permissions: 'publish_actions' }
    }, function () {
      messageBar.unstack('social-error-permissions');
    });
  }
};

/**
 * View model to manage the top message bar
 *
 * @param {Bridge} bridge The bridge that will trigger events.
 */
function MessageBar(bridge, churnedLockedState) {
  this._bridge = bridge;
  this._churnedLockedState = churnedLockedState;

  this.message = ko.observable();
  this.visible = ko.observable(false);
  this._goingOffline = null;
  this._messageStack = [];
  this._genericNotAvailableMessage = true;
  this._isForcedOffline = false;
  this._showClientUpdateMessages = true;
  this._hasSupressedClientUpdateMessage = false;

  abbaSubscriber('show-client-update-messages', function (cellName) {
    this._showClientUpdateMessages = cellName !== 'No';

    if (this._showClientUpdateMessages && this._hasSupressedClientUpdateMessage) {
      this._hasSupressedClientUpdateMessage = false;
      this._handleUserMessage({ 'params': { 'id': 'update-ready' } });
    }
  }.bind(this));
}

/**
 * Css class added to the body when message bar is active.
 *
 * @static
 * @type {String}
 */
MessageBar.ACTIVE_CSS_CLASS = 'messagebar';

MessageBar.prototype.setup = function () {
  eventDispatcher.addEventListener(Event.TYPES.MESSAGE_NOTIFICATION, this._handleNotificationMessage.bind(this));

  eventDispatcher.addEventListener(Event.TYPES.PLAYER_EVENT, this._handleLegacyPlayerEvent.bind(this));

  eventDispatcher.addEventListener(Event.TYPES.MESSAGE_USER, this._handleUserMessage.bind(this));

  eventDispatcher.addEventListener(Event.TYPES.CONNECTION_OFFLINE_ERROR, this._handleOfflineError.bind(this));

  eventDispatcher.addEventListener(Event.TYPES.CONNECTION_STATE_CHANGE, this._handleConnectionStateChange.bind(this));

  eventDispatcher.addEventListener(Event.TYPES.SOCIAL_ERROR, this._handleSocialError.bind(this));

  this.visible.subscribe(function (visible) {
    if (visible) {
      document.body.classList.add(MessageBar.ACTIVE_CSS_CLASS);
    } else {
      document.body.classList.remove(MessageBar.ACTIVE_CSS_CLASS);
    }
  });

  var self = this;
  live('spotify:client').get('session', function (error, session) {
    if (error) {
      if (console.error) console.error(error);
      return;
    }
    session.on('update', function (properties) {
      if ('paymentState' in properties) {
        self._checkPaymentState();
      }
    });
  });
  this._checkPaymentState();

  this._checkFirstAutoStart();

  // TODO Remove this. It's useful for development in order to trigger msgs:
  // On the Console:
  // cosmos.resolver.post({ url: 'sp://messages/v1/container/user-message',
  // body: {  description: '',  id: 'update-ready' }}, function () {});
  // window.cosmos = require('spotify-cosmos-api');

  var prefs = new Preferences('ps');
  prefs.get('country_code', function (err, countryCode) {
    if (err) return;
    var token = 'market.' + countryCode.toLowerCase();
    var countryString = _(token);

    // Only change the message replacement code if the country has a translation
    if (countryString !== token) {
      this._genericNotAvailableMessage = false;
      this._messageReplacements['track-not-available-in-region'] = [countryString];
    }
  }.bind(this));

  prefs.get('capping-bar-threshold', function (err, cappingBarThreshold) {
    if (err) return;
    var streamCapMins = parseInt(cappingBarThreshold, 10);
    if (!isNaN(streamCapMins)) {
      var streamingCapHours = Math.floor(streamCapMins / 60);
      this._messageReplacements['capping-reached'][0] = '' + streamingCapHours;
    }
  }.bind(this));

  var player = Player.getPlayer();
  player.onError(function (error, response) {
    var parsedResponse = response.getJSONBody();
    self._stackPlayerError(parsedResponse.error, parsedResponse.track_uri, parsedResponse.reasons);
  });

  player.subscribe(function (error, response) {
    var parsedResponse = response.getJSONBody();
    var isAdvertisement = parsedResponse.track && parsedResponse.track.metadata && parsedResponse.track.metadata.is_advertisement === 'true';
    if (parsedResponse.is_playing && !parsedResponse.is_paused && !isAdvertisement) {
      self._unstackPlayerError();
    }
  });

  return this;
};

/**
 * String replacements for certain ids. This all actions right now.
 */
MessageBar.prototype._messageReplacements = {
  'update-ready': ['restart'],
  'playback-paused-inactive': ['upgradeToPremium'],
  'track-exclusive-premium': ['upgradeToPremium'],
  'shuffle-unplayable-track': ['upgradeToPremium'],
  'shuffle-ran-out-of-skips': ['upgradeToPremium'],
  'offline-not-allowed': ['upgradeToPremium'],
  'local-track-bad-format': ['supportedFormats'],
  'capping-reached': [0, 'upgradeToPremium'],
  'language-changed': ['restart'],
  'proxysettings-changed': ['restart'],
  'cache-changed': ['restart'],
  'feature-changed': ['restart'],
  'first-autostart': ['enableAutoStart', 'disableAutoStart'],
  'payment-state-creditcard-funds': ['creditCardFunds'],
  'payment-state-creditcard-refused': ['creditCardRefused'],
  'payment-state-creditcard-expiry': ['creditCardExpiry'],
  'payment-state-paypal-refused': ['paypalRefused'],
  'payment-state-prepaid-expiry': ['prepaidExpiry'],
  'payment-state-churn-payment': ['churnPayment'],
  'payment-state-churn-partner': ['churnPartner'],
  'opt-in-trial': ['optInTrial'],
  'opt-in-trial-expired': ['optInTrialExpired'],
  'cant-offline-playlists': ['cantOfflinePlaylists'],
  'cant-set-high-quality-streaming': ['cantSetHighQualityStreaming'],
  'hardware-acceleration-changed': ['restart'],
  'social-error-permissions': ['requestFacebookPublishPermissions'],
  'deprecating-os-version': ['deprecatingOsVersion'],
  'approaching-capping-limit': ['upgradeToPremium', 'cappingExplained'],
  'half-capping-limit-passed': ['upgradeToPremium', 'cappingExplained']
};

MessageBar.prototype._setPreference = function (key, value, callback) {
  this._bridge.request('preferences_set', [key, value], this, callback);
};

MessageBar.prototype._checkFirstAutoStart = function () {
  var self = this;
  if (session.get('first_autostart')) {
    setTimeout(function () {
      eventDispatcher.dispatchEvent(new Event(Event.TYPES.MESSAGE_USER, { id: 'first-autostart' }));
      self._setPreference('app.autostart-banner-seen', true);
    }, 0);
  }
};

MessageBar.prototype._changeAutoStartSetting = function (mode) {
  var self = this;
  this._setPreference('app.autostart-mode', mode, function () {
    self.visible(false);
  });
};

/**
 * Convert a player event error code into a user message so
 * we can unify the way we handle messages.
 */
MessageBar.prototype._stackPlayerError = function (error, uri, reasons) {
  var errorIdToUse;
  var errorNumberToUse;

  var reasonList = reasons ? reasons.split(',') : [];
  var hasReason = function hasReason(reason) {
    return reasonList.indexOf(reason) > -1;
  };

  if (error && error === 'play_token_lost') {
    // Play token lost.
    errorIdToUse = ERROR_PLAY_TOKEN_LOST_MESSAGE;
    errorNumberToUse = ERROR_PLAY_TOKEN_LOST_ID;
  } else if (error && error === 'playback_stuck') {
    // Playback stuck.
    errorIdToUse = DEFAULT_PLAYBACK_STUCK_MESSAGE;
    errorNumberToUse = DEFAULT_PLAYBACK_STUCK_ID;
  } else if (error && error === 'one_track_unplayable_auto_stopped') {
    if (hasReason('not_available_in_current_region')) {
      // Region restricted.
      errorIdToUse = ERROR_REGION_RESTRICTED_MESSAGE;
      errorNumberToUse = ERROR_REGION_RESTRICTED_ID;
    } else if (hasReason('not_available_in_non_premium')) {
      // Premium restricted.
      errorIdToUse = ERROR_PREMIUM_RESTRICTED_MESSAGE;
      errorNumberToUse = ERROR_PREMIUM_RESTRICTED_ID;
    } else if (hasReason('not_available_offline') && this._isForcedOffline) {
      // User is in force-offline mode, track not offline synced
      errorIdToUse = ERROR_FORCED_OFFLINE_MODE_MESSAGE;
      errorNumberToUse = ERROR_FORCED_OFFLINE_MODE_ID;
    } else if (hasReason('user_capping_reached')) {
      // User has reached capping limit
      errorIdToUse = ERROR_CAPPING_REACHED_MESSAGE;
      errorNumberToUse = ERROR_CAPPING_REACHED_ID;
    } else {
      // Can't play for whatever other reason.
      errorIdToUse = DEFAULT_PLAYER_ERROR_MESSAGE;
      errorNumberToUse = DEFAULT_PLAYER_ERROR_ID;
    }
  } else if (error && error === 'all_tracks_unplayable_auto_stopped') {
    if (hasReason('not_available_offline') && this._isForcedOffline) {
      // User is in force-offline mode, no tracks offline synced
      errorIdToUse = ERROR_FORCED_OFFLINE_MODE_MESSAGE;
      errorNumberToUse = ERROR_FORCED_OFFLINE_MODE_ID;
    } else if (hasReason('user_capping_reached')) {
      // User has reached capping limit
      errorIdToUse = ERROR_CAPPING_REACHED_MESSAGE;
      errorNumberToUse = ERROR_CAPPING_REACHED_ID;
    }
  } else if (error && error === 'one_track_unplayable' && hasReason('user_capping_reached')) {
    // User has reached capping limit
    errorIdToUse = ERROR_CAPPING_REACHED_MESSAGE;
    errorNumberToUse = ERROR_CAPPING_REACHED_ID;
  } else if (error && error === 'interrupt_playback_restricted' || error === 'play_restricted' && hasReason('ad_disallow')) {
    // As of today, this can only be triggered when attempted
    // to play a track when an ad is currently playing. If this ever
    // changes, this code needs to be updated to check in particular
    // that this is ad related.
    errorIdToUse = ERROR_CANT_SKIP_ADS_MESSAGE;
    errorNumberToUse = ERROR_CANT_SKIP_ADS_ID;
  } else if (error && error === 'video_georestricted') {
    errorIdToUse = ERROR_VIDEO_GEO_RESTRICTED_MESSAGE;
    errorNumberToUse = ERROR_VIDEO_GEO_RESTRICTED_ID;
  } else if (error && error === 'video_unsupported_client_version') {
    errorIdToUse = ERROR_VIDEO_UNSUPPORTED_CLIENT_VERSION_MESSAGE;
    errorNumberToUse = ERROR_VIDEO_UNSUPPORTED_CLIENT_VERSION_ID;
  } else if (error && error === 'video_unsupported_platform_version') {
    errorIdToUse = ERROR_VIDEO_UNSUPPORTED_PLATFORM_VERSION_MESSAGE;
    errorNumberToUse = ERROR_VIDEO_UNSUPPORTED_PLATFORM_VERSION_ID;
  } else if (error && error === 'video_country_restricted') {
    errorIdToUse = ERROR_VIDEO_COUNTRY_RESTRICTED_MESSAGE;
    errorNumberToUse = ERROR_VIDEO_COUNTRY_RESTRICTED_ID;
  } else if (error && error === 'video_unavailable') {
    errorIdToUse = ERROR_VIDEO_UNAVAILABLE_MESSAGE;
    errorNumberToUse = ERROR_VIDEO_UNAVAILABLE_ID;
  } else if (error && error === 'video_catalogue_restricted') {
    errorIdToUse = ERROR_VIDEO_CATALOGUE_RESTRICTED_MESSAGE;
    errorNumberToUse = ERROR_VIDEO_CATALOGUE_RESTRICTED_ID;
  } else if (error && error === 'video_playback_error') {
    errorIdToUse = ERROR_VIDEO_PLAYBACK_ERROR_MESSAGE;
    errorNumberToUse = ERROR_VIDEO_PLAYBACK_ERROR_ID;
  } else {
    // Don't show any error.
    return;
  }

  if (!errorIdToUse) {
    console.warn('Unhandled player error', arguments);
    return;
  }

  // If another player error is already stacked,
  // make sure we unstack it first.
  if (this._lastPlayerError) {
    this._unstackPlayerError();
  }

  // Fire the error.
  eventDispatcher.dispatchEvent(new Event(Event.TYPES.MESSAGE_USER, {
    track: uri,
    id: errorIdToUse
  }));
  this._lastPlayerError = {
    track: uri,
    messageId: errorIdToUse,
    messageNumber: errorNumberToUse
  };
};

/**
 * Unstacking player errors to hide the error message.
 */
MessageBar.prototype._unstackPlayerError = function () {
  if (this._lastPlayerError) {
    this.unstack(this._lastPlayerError.messageNumber);
    this._lastPlayerError = null;
  }
};

/**
 * Convert a legacy player event error code into a user message so
 * we can unify the way we handle messages
 */
MessageBar.prototype._handleLegacyPlayerEvent = function (e) {
  var trackUri = e.params.track ? e.params.track.uri : null;

  if (e.params.error_code) {
    this._lastPlayerError = {
      track: trackUri,
      messageId: ERROR_MESSAGES[e.params.error_code]
    };

    eventDispatcher.dispatchEvent(new Event(Event.TYPES.MESSAGE_USER, {
      id: this._lastPlayerError.messageId
    }));
  } else if (this._lastPlayerError && trackUri !== this._lastPlayerError.track) {
    this.unstack(this._lastPlayerError.messageId);
    this._lastPlayerError = null;
  }
};

/**
 * Convert offline error messages into user messages to make the handling
 * transparent
 */
MessageBar.prototype._handleOfflineError = function (e) {
  if (e.params && e.params.code) {
    eventDispatcher.dispatchEvent(new Event(Event.TYPES.MESSAGE_USER, {
      id: ERROR_MESSAGES[e.params.code]
    }));
  }
};

MessageBar.prototype._handleNotificationMessage = function (e) {
  if (e.params.message) {
    this.message(e.params.message);
    this.visible(true);
  }
};

MessageBar.prototype._handleConnectionStateChange = function (e) {
  this._isForcedOffline = e.params.status === 'forced_offline';
  if (e.params.status === 'reconnecting' || e.params.status === 'offline') {
    // if there was a previous offline message, do not do anything
    if (this._goingOffline) {
      return;
    }

    this._goingOffline = setTimeout(function () {
      eventDispatcher.dispatchEvent(new Event(Event.TYPES.MESSAGE_USER, {
        id: 'not-available-offline'
      }));
    }, OFFLINE_TIMEOUT);
  } else {
    // 'online' or 'forced_offline'
    // if there was a previous offline message, cancel it
    if (this._goingOffline) {
      clearTimeout(this._goingOffline);
      this._goingOffline = null;
    }
    this.unstack('not-available-offline');
  }

  if (e.params.status === 'online') {
    this.unstack('track-not-available-forced-offline');
  }
};

MessageBar.prototype._handleSocialError = function (e) {
  if (e.params && e.params.error && e.params.error_description === 'publish_actions') {
    eventDispatcher.dispatchEvent(new Event(Event.TYPES.MESSAGE_USER, {
      id: 'social-error-permissions'
    }));
  }
};

MessageBar.prototype._checkPaymentState = function () {
  var self = this;

  live('spotify:client').query('session(paymentState)', function (error, data) {
    if (error) {
      if (console) console.error(error);
      return;
    }

    var paymentState = data.session.paymentState;
    if (paymentState) {
      var stateDescription = PAYMENT_STATE_ERRORS.filter(function (description) {
        return description.regExp.test(paymentState);
      })[0];
      var id = stateDescription && stateDescription.id;
      // The payment state messages are not critical, we shouldn't fall
      // back to a generic error message. Clarified that with the payments team.
      if (id) {
        var dispatchEvent = true;

        // Don't show certain types more often than limit (in ms)
        var limit = stateDescription.limit;
        var storageKey = 'last-shown-message-' + id;
        if (limit && global.localStorage) {
          var lastShown = +global.localStorage[storageKey];
          if (!isNaN(lastShown)) {
            var timeSince = Date.now() - lastShown;
            if (limit > timeSince) {
              dispatchEvent = false;
            }
          }
        }

        if (dispatchEvent) {
          eventDispatcher.dispatchEvent(new Event(Event.TYPES.MESSAGE_USER, {
            id: id
          }));
          if (limit) {
            global.localStorage[storageKey] = Date.now();
          }
        }
      }
    } else {
      // If payment state is the empty string, unstack existing payment
      // messages and clear the limit of when it can be shown again.
      PAYMENT_STATE_ERRORS.forEach(function (stateDescription) {
        var id = stateDescription.id;
        var limit = stateDescription.limit;
        if (limit) {
          var storageKey = 'last-shown-message-' + id;
          delete global.localStorage[storageKey];
        }

        self.unstack(id);
      });
    }
  });
};

MessageBar.prototype._lastMessage = function () {
  return this._messageStack.length && this._messageStack[this._messageStack.length - 1];
};

/**
 * The stack is not really strict with the LIFO principle,
 * so there can be cases where a message in the middle should be removed
 * due to multiple reasons, so that's why we don't have just "pop"
 * but this whole unstack logic
 */
MessageBar.prototype.unstack = function (optMessageId) {
  var reorganizeStack = false;

  if (!optMessageId || optMessageId === this) {
    // Without a message ID, or when unstack is called from an UI
    // interaction via knockout (i.e. optMessageId === this)
    // remove the topmost message
    this._messageStack.pop();
  } else {
    // With a message ID set, remove all occurences of the message
    var messageId = optMessageId;
    for (var i = 0; i < this._messageStack.length; i++) {
      if (this._messageStack[i] === messageId ||
      // Sometimes we usse ids, sometime we use messages in the stack
      // TODO: Refactor to always use just the ID
      this._messageStack[i] === ERROR_MESSAGES[messageId]) {
        // set as null to mark for deletion
        this._messageStack[i] = null;
        // it can happen that this message was between two identical errors
        // and we don't want repeated messages stacked sequentialy, so
        // a cleanup is necessary
        reorganizeStack = true;
      }
    }
  }

  if (reorganizeStack) {
    this._cleanupMessageStack();
  }
  this._update();
};

MessageBar.prototype._cleanupMessageStack = function () {
  var oldStack = this._messageStack;
  this._messageStack = [];
  var lastStackedMsg = null;
  while (oldStack.length) {
    var message = oldStack.pop();
    if (message && message !== lastStackedMsg) {
      this._messageStack.push(message);
      lastStackedMsg = message;
    }
  }
};

MessageBar.prototype._showUserMessage = function (messageId) {
  this._messageStack.push(messageId);
  this._update();

  // play-token-lost comes as a user message but as it stops playback
  // we can treat it as a player error to remove the message when
  // playback is resumed
  if (messageId === 'play-token-lost') {
    this._lastPlayerError = { messageId: 'play-token-lost' };
    return;
  }
};

MessageBar.prototype._handleUserMessage = function (evt) {
  var messageId = evt.params.id;

  // No messageId = nothing to show and also avoid that two
  // identical messages are stacked sequentially
  if (!messageId || messageId === this._lastMessage()) {
    return;
  }

  if (messageId === 'update-ready' && !this._showClientUpdateMessages) {
    // No UPDATE for you?
    this._hasSupressedClientUpdateMessage = true;
  } else if (messageId === ERROR_CAPPING_REACHED_MESSAGE) {
    eventDispatcher.dispatchEvent(new Event(Event.TYPES.CAPPING_OPEN_UPSELL_MESSAGE, evt));
  } else if (messageId === 'payment-state-churn-payment') {
    // Avoid churn message, if eligible for CLS feature test
    this._churnedLockedState.checkAbTest(function (isOnAbTest) {
      if (!isOnAbTest) this._showUserMessage(messageId);
    }.bind(this));
  } else {
    this._showUserMessage(messageId);
  }
};

MessageBar.prototype._update = function () {
  // Special casing for messages to only contain
  // 'restart' link when it's supported by the platform.
  var client = live('spotify:client');
  client.query('containerFeatures(clientRestarts)', function (err, data) {
    if (err) {
      return;
    }

    var messageId = this._messageStack[this._messageStack.length - 1];
    if (!messageId) {
      this.visible(false);
      return;
    }

    // Filter the message replacements looking for the message types that have
    // a call to action to restart the client
    var restartMessageIds = Object.keys(this._messageReplacements).filter(function (key) {
      return this._messageReplacements[key].indexOf('restart') !== -1;
    }, this);

    if (!data.containerFeatures.clientRestarts && restartMessageIds.indexOf(messageId) > -1) {
      messageId += '-simple';
    }

    // Show generic message if there is no translation for the user market
    if (messageId === 'track-not-available-in-region' && this._genericNotAvailableMessage) {
      messageId += '-generic';
    }

    // Handle the replacements in messageReplacements
    var token = 'usermessage.' + messageId;

    // we need to clone the array to not modify the original array every
    // time we receive a message
    var params = (this._messageReplacements[messageId] || []).slice(0);
    params.unshift(token);

    // This is necessary for translation tokens with multiple params
    var translatedMessage = _.apply(_, params);

    // Falls back to the default message if there's no translation for this id
    this.message(translatedMessage !== token ? translatedMessage : _('usermessage.default-message'));

    var messageActions = document.querySelectorAll('#message-text > a');

    // Dummy function for invalid actions
    var invalidAction = function invalidAction(e) {
      if (console) console.error('Invalid action', e);
    };

    // Adds an event listener to every <a data-action=...>
    // where the value of data-action has already been replaced
    // in the translation process above
    for (var i = 0; i < messageActions.length; i++) {
      var actionElement = messageActions[i];
      var action = actionElement.dataset.action;
      actionElement.addEventListener('click', (action && ACTIONS[action] || invalidAction).bind(this));
    }
    this.visible(true);
  }.bind(this), live.ASAP);
};

MessageBar.prototype._openExternalPage = function (url) {
  session.getOAuthToken(url, function (err, token) {
    if (!err && token) {
      url += (url.indexOf('?') !== -1 ? '&' : '?') + token;
    }
    window.open(url);
  });
};

module.exports = MessageBar;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../../../libs/spotify-event-dispatcher":264,"../../../../libs/spotify-live":439,"../../../../libs/spotify-preferences":486,"../../i18n":11,"../connectionmonitor":73,"../controlmessageshandler":74,"../event":77,"../models/player":101,"../models/session":107,"../urls.json":118,"../utils/abba-subscriber.js":121,"knockout":567,"spotify-cosmos-api":694}],137:[function(require,module,exports){
'use strict';

var $ = require('../../../../libs/spotify-elements');
var ko = require('knockout');
var keyboard = require('../keyboard');
var eventDispatcher = require('../../../../libs/spotify-event-dispatcher');
var Event = require('../event');

/**
 * Load different types of modal behavior,
 * following a Strategy-ish pattern
 */
var modalStrategies = [require('./modals/tos'), require('./modals/licenses'), require('./modals/about'), require('./modals/feedback'), require('./modals/findfriends'), require('./modals/avoid-duplicates'), require('./modals/playlist-annotate'), require('./modals/full-screen-modal'), require('./modals/nps-survey')];

function Modal(bridge) {
  this.backdropClasses = ko.observable('');
  this.modalAnimationClasses = ko.observable('');
  this.modalTypeClass = ko.observable('');
  this.modalClasses = ko.pureComputed(function () {
    return (this.modalTypeClass() + ' ' + this.modalAnimationClasses()).trim();
  }, this);
  this.modalContentHeight = ko.observable();
  this.modalContentStyle = ko.computed(function () {
    return {
      height: this.modalContentHeight() ? this.modalContentHeight() + 'px' : null
    };
  }, this);
  this.title = ko.observable('');
  this.okButtonLabel = ko.observable('');
  this.cancelButtonLabel = ko.observable('');
  this._bridge = bridge;
  this.okVisible = ko.observable(false);
  this.cancelVisible = ko.observable(false);
  this.footerVisible = ko.pureComputed(function () {
    return this.okVisible() || this.cancelVisible();
  }, this);
  this.okFocused = ko.observable(false);
  this._visibleStrategy = null;
}

Modal.prototype._popoverId = 'modal';

Modal.prototype.setup = function () {
  this._content = document.getElementById('modal-content');
  for (var i = 0; i < modalStrategies.length; i++) {
    var strategy = new modalStrategies[i]();
    strategy.setup(this, this._bridge);
  }

  var self = this;
  keyboard.registerImportantShortcut(keyboard.KEYS.ESCAPE, function (event) {
    if (self.visible) {
      event.preventDefault();
      self.onEscape();
    }
  });

  keyboard.registerImportantShortcut(keyboard.KEYS.ENTER, function (event) {
    var blacklistedSelectors = ['textarea', '[role=input]'].join(',');

    if ($(event.target).matches(blacklistedSelectors) || $(event.target).parent(blacklistedSelectors)) {
      return;
    }

    if (self.visible) {
      event.preventDefault();
      if (self.okVisible()) {
        self.onOk();
      } else {
        self.onCancel();
      }
    }
  });
};

Modal.prototype._fadeIn = function () {
  this.modalAnimationClasses('fade');
  document.body.classList.add('modal-open');
  var self = this;
  setTimeout(function () {
    self.modalAnimationClasses('fade in');
    if (self.okVisible() && self._visibleStrategy && self._visibleStrategy.AUTOFOCUS_OK_BUTTON) {
      self.okFocused(true);
    }
  }, 10);
  this.backdropClasses('fade in');
  this.visible = true;
};

var noop = function noop() {};

Modal.prototype.display = function (modalStrategy) {
  // Don't do anything if there's a modal being displayed
  // that cannot be substituted or if the current strategy is the one
  // already being displayed
  if (this._visibleStrategy && this._visibleStrategy.HIGH_PRIORITY || this.visible && this._visibleStrategy === modalStrategy) {
    return;
  }

  this.render(modalStrategy);
  this._fadeIn();
  if (modalStrategy.onShow) {
    // Notify the strategy that it's visible in case it needs any
    // initialization routine
    modalStrategy.onShow();
  }

  eventDispatcher.dispatchEvent(new Event(Event.TYPES.POPOVER_OPENED, { id: this._popoverId }));
};

Modal.prototype.render = function (modalStrategy) {
  var content;
  if (modalStrategy.URL) {
    content = this._createIframe(modalStrategy.URL);
  } else if (modalStrategy.MESSAGE) {
    content = this._createDomNode(modalStrategy.MESSAGE);
  } else {
    content = modalStrategy.CONTENT;
  }
  this.setContent(content);
  this.modalTypeClass(modalStrategy.MODAL_CLASS || 'iframe-modal');
  this.modalContentHeight(modalStrategy.HEIGHT || null);
  this.title(modalStrategy.MODAL_TITLE);

  var buttons = modalStrategy.BUTTONS || {};

  this.okVisible(!!buttons.OK);
  if (this.okVisible()) {
    this._onOkCallback = modalStrategy.onOk.bind(modalStrategy);
    this.okButtonLabel(modalStrategy.OK_BUTTON_LABEL);
  } else {
    // button won't be visible, but cleanup anyway
    this._onOkCallback = noop;
    this.okButtonLabel('');
  }

  this.cancelVisible(!!buttons.CANCEL);
  if (this.cancelVisible()) {
    this._onCancelCallback = modalStrategy.onCancel.bind(modalStrategy);
    this.cancelButtonLabel(modalStrategy.CANCEL_BUTTON_LABEL);
  } else {
    this._onCancelCallback = noop;
    this.cancelButtonLabel('');
  }

  this._visibleStrategy = modalStrategy;
};

Modal.prototype.hide = function () {
  if (this._visibleStrategy.onHide) {
    // In case the view perform any cleanup routine when it's disabled
    if (this._visibleStrategy.onHide() === false) return;
  }
  this._fadeOut();
  this._visibleStrategy = null;

  eventDispatcher.dispatchEvent(new Event(Event.TYPES.POPOVER_CLOSED, { id: this._popoverId }));
};

Modal.prototype.onOk = function () {
  this._onOkCallback(this.hide.bind(this));
};

Modal.prototype.onCancel = function () {
  this._onCancelCallback(this.hide.bind(this));
};

Modal.prototype.onClickBackdrop = function () {
  if (this._visibleStrategy.CAN_HIDE_BY_CLICKING_BACKGROUND === false) return;
  this.hide();
};

Modal.prototype.onEscape = function () {
  if (this._visibleStrategy.CAN_HIDE_BY_PRESSING_ESCAPE === false) return;
  this.hide();
};

Modal.prototype._createIframe = function (url) {
  var iframe = document.createElement('iframe');
  iframe.setAttribute('allowTransparency', 'true');

  iframe.src = url;
  iframe.addEventListener('load', function onLoad() {
    // This is a hack to make sure the window is fully loaded before
    // setting up keyboard events and removing the iframe event listener.
    // The iframe load event appears to trigger twice after the source is
    // correctly set- once when the body is empty, and again after it has
    // been fully loaded.
    if (iframe.contentWindow.document.body.innerHTML) {
      iframe.removeEventListener('load', onLoad);
      keyboard.setupWithWindow(iframe.contentWindow);
    }
  });

  return iframe;
};

Modal.prototype._createDomNode = function (htmlString, wrapperTag) {
  var element = document.createElement(wrapperTag || 'div');
  element.innerHTML = htmlString;
  return element;
};

Modal.prototype.setHTML = function (htmlString) {
  this.setContent(this._createDomNode(htmlString));
};

Modal.prototype.getContent = function () {
  return this._content;
};

Modal.prototype.setContent = function (contentNode) {
  while (this._content.firstChild) {
    // cleanup
    this._content.removeChild(this._content.firstChild);
  }

  if (contentNode) {
    this._content.appendChild(contentNode);
  }
};

Modal.prototype._fadeOut = function () {
  this.modalAnimationClasses('fade');
  this.backdropClasses('fade');
  document.body.classList.remove('modal-open');
  var self = this;
  var iframe = this._content.querySelector('iframe');
  setTimeout(function () {
    self.modalAnimationClasses('');
    self.backdropClasses('');
    // Unload any app that might be loaded, so that the next time it loads
    // you are assured to get a "fresh start".
    if (iframe) {
      iframe.src = 'about:blank';
    }
    // reset active element so the keyboard events work
    if (document.activeElement) {
      document.activeElement.blur();
    }
  }, 300);
  this.visible = false;
};

Modal.prototype.stopPropagation = function (event, mouseEvent) {
  if (mouseEvent.target.tagName.toLowerCase() === 'input') {
    return true;
  }

  return mouseEvent.stopPropagation();
};

module.exports = Modal;

},{"../../../../libs/spotify-elements":259,"../../../../libs/spotify-event-dispatcher":264,"../event":77,"../keyboard":83,"./modals/about":138,"./modals/avoid-duplicates":139,"./modals/feedback":140,"./modals/findfriends":141,"./modals/full-screen-modal":142,"./modals/licenses":143,"./modals/nps-survey":144,"./modals/playlist-annotate":148,"./modals/tos":154,"knockout":567}],138:[function(require,module,exports){
'use strict';

var EventTypes = require('../../event').TYPES;
var eventDispatcher = require('../../../../../libs/spotify-event-dispatcher');
var _ = require('../../../i18n').get;

function About() {
  this.visible = false;
  this.modal = null;
  this._onShowCallback = this._onShowCallback.bind(this);
}

About.prototype.MODAL_TITLE = _('about.title_label');
About.prototype.OK_BUTTON_LABEL = _('about.close_button_label');
About.prototype.URL = 'spotify:app:about';
About.prototype.BUTTONS = {
  OK: true
};
About.prototype.HIGH_PRIORITY = false;
About.prototype.AUTOFOCUS_OK_BUTTON = true;

About.prototype.setup = function (modal) {
  eventDispatcher.addEventListener(EventTypes.NAVIGATION_SHOW_ABOUT, function () {
    modal.display(this);
  }.bind(this));
  this.modal = modal;
};

About.prototype._onShowCallback = function () {
  this.modal.onOk();
};

About.prototype.onShow = function () {
  eventDispatcher.addEventListener(EventTypes.NAVIGATION_STATE_CHANGE, this._onShowCallback);
};

About.prototype.onHide = function () {
  // no need to keep listening if the modal is hidden
  eventDispatcher.removeEventListener(EventTypes.NAVIGATION_STATE_CHANGE, this._onShowCallback);
};

About.prototype.onOk = function (callback) {
  callback();
};

module.exports = About;

},{"../../../../../libs/spotify-event-dispatcher":264,"../../../i18n":11,"../../event":77}],139:[function(require,module,exports){
'use strict';

var cosmos = require('spotify-cosmos-api');
var _ = require('../../../i18n').get;
var ClientEvent3 = require('../../../../../libs/spotify-logger/messages/ClientEvent3');

var ACTIONS = {
  ADD_ALL: 'add_all',
  ADD_UNIQUE: 'add_unique',
  CANCEL: 'cancel'
};

var ENDPOINT = 'sp://messages/v1/avoidduplicates';

function AvoidDuplicates() {}

AvoidDuplicates.prototype.MODAL_CLASS = 'avoid-duplicates';
AvoidDuplicates.prototype.BUTTONS = {
  OK: true,
  CANCEL: true
};
AvoidDuplicates.prototype.HIGH_PRIORITY = false;
AvoidDuplicates.prototype.AUTOFOCUS_OK_BUTTON = true;

AvoidDuplicates.prototype.setup = function (modal) {
  cosmos.resolver.subscribe(ENDPOINT, function (error, response) {
    var body = response.getJSONBody();
    if (body.action !== 'confirm') {
      return;
    }
    this.data = body;

    if (this.data.numItems === 1) {
      this.MODAL_TITLE = _('playlist.duplicates_dialog_title_single');
      this.MESSAGE = _('playlist.duplicates_dialog_body_single');
      this.OK_BUTTON_LABEL = _('playlist.duplicates_dialog_button_skip_single');
      this.CANCEL_BUTTON_LABEL = _('playlist.duplicates_dialog_button_add_single');

      this.OK_ACTION = ACTIONS.CANCEL;
      this.CANCEL_ACTION = ACTIONS.ADD_ALL;
    } else {
      this.MODAL_TITLE = _('playlist.duplicates_dialog_title');
      this.MESSAGE = _('playlist.duplicates_dialog_body');
      this.OK_BUTTON_LABEL = _('playlist.duplicates_dialog_button_skip_duplicates');
      this.CANCEL_BUTTON_LABEL = _('playlist.duplicates_dialog_button_add');

      this.OK_ACTION = ACTIONS.ADD_UNIQUE;
      this.CANCEL_ACTION = ACTIONS.ADD_ALL;
    }

    modal.display(this);
  }.bind(this));
};

AvoidDuplicates.prototype.onOk = function (callback) {
  this._hasTakenAction = true;
  this.action = this.OK_ACTION;

  cosmos.resolver.post({
    url: ENDPOINT,
    body: {
      action: this.action
    }
  }, callback);
};

AvoidDuplicates.prototype.onCancel = function (callback) {
  this._hasTakenAction = true;
  this.action = this.CANCEL_ACTION;

  cosmos.resolver.post({
    url: ENDPOINT,
    body: {
      action: this.action
    }
  }, callback);
};

AvoidDuplicates.prototype.onShow = function () {
  this._hasTakenAction = false;
};

AvoidDuplicates.prototype.onHide = function () {
  if (!this._hasTakenAction) {
    this._hasTakenAction = true;
    this.action = ACTIONS.CANCEL;
    cosmos.resolver.post({
      url: ENDPOINT,
      body: {
        action: this.action
      }
    });
  }

  ClientEvent3.log({
    source: this.data.source,
    event_version: 'avoid-duplicates',
    event: 'user:hit',
    json_data: {
      action: this.action,
      playlist_uri: this.data.playlistUri,
      num_items: this.data.numItems,
      num_duplicates: this.data.numDuplicates
    }
  });
};

module.exports = AvoidDuplicates;

},{"../../../../../libs/spotify-logger/messages/ClientEvent3":451,"../../../i18n":11,"spotify-cosmos-api":694}],140:[function(require,module,exports){
'use strict';

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _clientstate = require('../../clientstate');

var _clientstate2 = _interopRequireDefault(_clientstate);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var cosmos = require('spotify-cosmos-api');
var EventTypes = require('../../event').TYPES;
var eventDispatcher = require('../../../../../libs/spotify-event-dispatcher');
var ClientEvent3 = require('../../../../../libs/spotify-logger/messages/ClientEvent3');

var Feedback = function () {
  function Feedback() {
    _classCallCheck(this, Feedback);

    this.visible = false;
    this.modal = null;
    this._onShowCallback = this._onShowCallback.bind(this);
    this._cosmosSubscription = null;
  }

  _createClass(Feedback, [{
    key: 'setup',
    value: function setup(modal) {
      var _this = this;

      eventDispatcher.addEventListener(EventTypes.NAVIGATION_SHOW_FEEDBACK, function () {
        modal.display(_this);
      });
      this.modal = modal;
    }
  }, {
    key: 'onOk',
    value: function onOk(callback) {
      callback();
    }
  }, {
    key: 'onShow',
    value: function onShow() {
      eventDispatcher.addEventListener(EventTypes.NAVIGATION_STATE_CHANGE, this._onShowCallback);
      this._cosmosSubscription = cosmos.resolver.subscribe({
        url: 'sp://messages/v1/container/control'
      }, this._onCosmosEvent.bind(this));
    }
  }, {
    key: 'onHide',
    value: function onHide() {
      eventDispatcher.removeEventListener(EventTypes.NAVIGATION_STATE_CHANGE, this._onShowCallback);
      this._cosmosSubscription.cancel();
    }
  }, {
    key: '_onCosmosEvent',
    value: function _onCosmosEvent(error, response) {
      var message = response.getJSONBody();
      switch (message.type) {

        case 'close_modal':
          this.modal.hide();
          break;

        case 'send_feedback':
          ClientEvent3.log({
            json_data: JSON.stringify({
              userDescription: message.userDescription,
              clientState: _clientstate2.default.getState()
            }),
            event: 'user:interaction',
            context: 'feedback/submit',
            event_version: 'click',
            source: 'spotify:app:feedback',
            source_version: window.__spotify.client_version,
            source_vendor: 'com.spotify'
          });
          break;

        default:
          break;

      }
    }
  }, {
    key: '_onShowCallback',
    value: function _onShowCallback() {
      this.modal.onOk();
    }
  }]);

  return Feedback;
}();

Feedback.prototype.MODAL_TITLE = 'Feedback';
Feedback.prototype.URL = 'spotify:app:feedback';
Feedback.prototype.BUTTONS = {};
Feedback.prototype.HIGH_PRIORITY = false;

module.exports = Feedback;

},{"../../../../../libs/spotify-event-dispatcher":264,"../../../../../libs/spotify-logger/messages/ClientEvent3":451,"../../clientstate":28,"../../event":77,"spotify-cosmos-api":694}],141:[function(require,module,exports){
'use strict';

var EventTypes = require('../../event').TYPES;
var eventDispatcher = require('../../../../../libs/spotify-event-dispatcher');
var cosmos = require('spotify-cosmos-api');

function FindFriends() {
  this.visible = false;
  this.modal = null;
  this._onShowCallback = this._onShowCallback.bind(this);
}

FindFriends.prototype.URL = 'spotify:app:findfriends';
FindFriends.prototype.HEIGHT = 450;
FindFriends.prototype.BUTTONS = {
  OK: false
};
FindFriends.prototype.HIGH_PRIORITY = false;
FindFriends.prototype.AUTOFOCUS_OK_BUTTON = true;

FindFriends.prototype.setup = function (modal) {
  eventDispatcher.addEventListener(EventTypes.NAVIGATION_SHOW_FIND_FRIENDS, function () {
    modal.display(this);
  }.bind(this));
  this.subscription = cosmos.resolver.subscribe('sp://messages/v1/findfriends', function (err, res) {
    if (!err && res.getJSONBody().type === 'request-close') {
      modal.hide();
    }
  });
  this.modal = modal;
};

FindFriends.prototype._onShowCallback = function () {
  this.modal.hide();
};

FindFriends.prototype.onShow = function () {
  eventDispatcher.addEventListener(EventTypes.NAVIGATION_STATE_CHANGE, this._onShowCallback);
};

FindFriends.prototype.onHide = function () {
  // no need to keep listening if the modal is hidden
  eventDispatcher.removeEventListener(EventTypes.NAVIGATION_STATE_CHANGE, this._onShowCallback);
};

module.exports = FindFriends;

},{"../../../../../libs/spotify-event-dispatcher":264,"../../event":77,"spotify-cosmos-api":694}],142:[function(require,module,exports){
'use strict';

var EventTypes = require('../../event').TYPES;
var eventDispatcher = require('../../../../../libs/spotify-event-dispatcher');
var cosmos = require('spotify-cosmos-api');
var bridgeRequest = require('../../../../../libs/spotify-bridge-request').request;

function FullScreenModal() {
  this.visible = false;
  this.modal = null;
}

FullScreenModal.prototype.BUTTONS = {
  OK: false
};
FullScreenModal.prototype.HIGH_PRIORITY = false;
FullScreenModal.prototype.AUTOFOCUS_OK_BUTTON = true;
FullScreenModal.prototype.VIEW_MODAL_CLASSES = 'modal-transparent';
FullScreenModal.prototype.VIEW_MAX_CONTENT_WIDTH = 1330;

FullScreenModal.prototype.setup = function (modal) {
  eventDispatcher.addEventListener(EventTypes.NAVIGATION_SHOW_FULL_SCREEN_MODAL, function (e) {
    this.viewModal = document.getElementById('view-modal');
    this.viewModal.classList.add(this.VIEW_MODAL_CLASSES);

    this.URL = e.params;
    this.MODAL_CLASS = 'iframe-modal full-screen-modal-container';

    this.modal.display(this);

    this.iframe = document.getElementById('modal-content').querySelector('iframe');
    this.iframe.onload = this._onFrameLoadCallback.bind(this);
    this.iframe.contentWindow.focus();

    this.subscription = cosmos.resolver.subscribe('sp://messages/v1/full-screen-modal', function (err, res) {
      if (!err && res.getJSONBody().type === 'request-close') {
        this.modal.hide();
      }
    }.bind(this));
  }.bind(this));

  this.modal = modal;
};

FullScreenModal.prototype._onFrameLoadCallback = function () {
  var _self = this;

  // We only want to bind our listener once. <iframe> calls the `onload`
  // handler twice, once on creation, and once on load of our app.
  if (this._resizeHandler) return this._resizeHandler();

  this._resizeHandler = this._onResizeCallback.bind(this);

  eventDispatcher.addEventListener(EventTypes.LAYOUT_SIDEBAR_RESIZED, this._resizeHandler);

  var bridgeRequestResizeProxy = function bridgeRequestResizeProxy() {
    if (!_self._resizeHandler) return;

    bridgeRequest('preferences_event_wait', [], function () {
      if (!_self._resizeHandler) return;

      bridgeRequestResizeProxy();
      _self._resizeHandler();
    });
  };

  bridgeRequestResizeProxy();
  this._resizeHandler();
};

FullScreenModal.prototype._onResizeCallback = function () {
  var origin = this.iframe.contentWindow.location.origin;

  var appHeader = document.getElementById('header-glue1');
  var appMenu = document.getElementById('menu-wrapper');
  var playerBar = document.getElementById('view-player');
  var buddyList = document.getElementById('view-buddy-list');
  var contentArea = document.getElementById('view-content');

  var message = {
    offsetTop: appHeader.getBoundingClientRect().height,
    offsetLeft: appMenu.getBoundingClientRect().width,
    offsetBottom: playerBar.getBoundingClientRect().height,
    offsetRight: buddyList.getBoundingClientRect().width,
    width: Math.min(contentArea.getBoundingClientRect().width, this.VIEW_MAX_CONTENT_WIDTH)
  };

  this.iframe.contentWindow.postMessage(message, origin);
};

FullScreenModal.prototype.onHide = function () {
  this.subscription.cancel();
  this.viewModal.classList.remove(this.VIEW_MODAL_CLASSES);
  this.iframe.onload = null;

  // Unbind our listeners so we don't keep firing events after this modal
  // is closed.
  eventDispatcher.removeEventListener(EventTypes.LAYOUT_SIDEBAR_RESIZED, this._resizeHandler);
  this._resizeHandler = null;
};

module.exports = FullScreenModal;

},{"../../../../../libs/spotify-bridge-request":253,"../../../../../libs/spotify-event-dispatcher":264,"../../event":77,"spotify-cosmos-api":694}],143:[function(require,module,exports){
'use strict';

var EventTypes = require('../../event').TYPES;
var eventDispatcher = require('../../../../../libs/spotify-event-dispatcher');
var _ = require('../../../i18n').get;

function Licenses() {}

Licenses.prototype.MODAL_CLASS = 'iframe-modal licenses-modal';
Licenses.prototype.MODAL_TITLE = _('licenses.modal_title');
Licenses.prototype.OK_BUTTON_LABEL = _('licenses.close_button_label');
Licenses.prototype.URL = 'spotify:app:licenses';
Licenses.prototype.BUTTONS = {
  OK: true
};
Licenses.prototype.HIGH_PRIORITY = false;
Licenses.prototype.AUTOFOCUS_OK_BUTTON = true;

Licenses.prototype.setup = function (modal) {
  eventDispatcher.addEventListener(EventTypes.NAVIGATION_SHOW_LICENSES, function () {
    modal.display(this);
  }.bind(this));
};

Licenses.prototype.onOk = function (callback) {
  callback();
};

module.exports = Licenses;

},{"../../../../../libs/spotify-event-dispatcher":264,"../../../i18n":11,"../../event":77}],144:[function(require,module,exports){
'use strict';

var ClientEvent3 = require('../../../../../libs/spotify-logger/messages/ClientEvent3');
var eventDispatcher = require('../../../../../libs/spotify-event-dispatcher');
var Event = require('../../event');
var i18n = require('../../../i18n').get;
var live = require('../../../../../libs/spotify-live');
var localSettings = require('../../models/localsettings');
var pkg = require('../../../package.json');
var template = require('../../../templates/modals/nps-survey.hbs');
var types = require('bfs-km-types');

var ENABLED_GROUPS = 300;
var ENABLED_GROUPS_COUNTRIES = ['US', 'DE', 'GB', 'ES', 'SE', 'NL', 'MX'];
var LOCAL_SETTINGS_KEY = 'hide_survey';
var SHOW_AFTER_MS = 1000 * 60;

function NPSSurvey() {
  this.country = '';
  this.modal = null;
  this.testGroups = [0, 0];
}

NPSSurvey.prototype.AUTOFOCUS_OK_BUTTON = false;
NPSSurvey.prototype.BUTTONS = { 'CANCEL': true, 'OK': true };
NPSSurvey.prototype.CAN_HIDE_BY_CLICKING_BACKGROUND = true;
NPSSurvey.prototype.CAN_HIDE_BY_PRESSING_ESCAPE = true;
NPSSurvey.prototype.CANCEL_BUTTON_LABEL = i18n('sClose');
NPSSurvey.prototype.HIGH_PRIORITY = false;
NPSSurvey.prototype.MODAL_CLASS = 'nps-survey';
NPSSurvey.prototype.OK_BUTTON_LABEL = i18n('sSubmit');

Object.defineProperty(NPSSurvey.prototype, 'CONTENT', {
  'get': function get() {
    var element = document.createElement('div');
    element.innerHTML = template([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]);
    return element;
  }
});

/**
 * A method that extracts the form responses from the DOM. The returned object
 * will have the three keys 'q1', 'q2' and 'q3' set to the answers of the three
 * questions, respectively. Questions that haven't been answered will be set to
 * null.
 */
NPSSurvey.prototype.getFormResponses = function () {
  var q1;
  var q2;
  var q3;
  var root;
  var node;

  q1 = null;
  q2 = null;
  q3 = null;

  root = document.querySelector('.' + NPSSurvey.prototype.MODAL_CLASS);

  if (root !== null) {
    node = root.querySelector('input[name="recommend"]:checked');

    if (node !== null) {
      q1 = parseInt(node.value, 10);
    }

    node = root.querySelector('textarea[name="why"]');

    if (node !== null) {
      q2 = node.value;
    }

    node = root.querySelector('input[name="satisfied"]:checked');

    if (node !== null) {
      q3 = parseInt(node.value, 10);
    }
  }

  return {
    'q1': q1,
    'q2': q2,
    'q3': q3
  };
};

/**
 * A method that makes a log data object to send together with the log message.
 */
NPSSurvey.prototype.makeLogData = function () {
  var formResponses;

  formResponses = this.getFormResponses();

  return {
    'surveyTestGroup': this.testGroups[0],
    'q1': formResponses.q1,
    'q2': formResponses.q2,
    'q3': formResponses.q3
  };
};

/**
 * A method that checks if the survey should be shown and shows the survey for
 * eligble users.
 */
NPSSurvey.prototype.maybeShowSurvey = function () {
  if (this.shouldShowSurvey()) {
    this.modal.display(this);
  }
};

/**
 * A callback that is triggered when the user presses the cancel button.
 *
 * @param {Function} hideCallback
 */
NPSSurvey.prototype.onCancel = function (hideCallback) {
  ClientEvent3.log({
    context: 'Survey',
    event: 'User closed survey before submitting form',
    source: 'spotify:app:zlink',
    source_version: pkg.version,
    source_vendor: 'com.spotify',
    json_data: this.makeLogData()
  });

  hideCallback();
};

/**
 * A callback that is triggered when the modal hides itself.
 */
NPSSurvey.prototype.onHide = function () {
  localSettings.set(LOCAL_SETTINGS_KEY, 'true');
};

/**
 * A callback that is triggered when the user presses the ok button.
 *
 * @param {Function} hideCallback
 */
NPSSurvey.prototype.onOk = function (hideCallback) {
  var data;

  data = this.makeLogData();

  if (data.q1 !== null && data.q2 !== null && data.q3 !== null) {
    ClientEvent3.log({
      context: 'Survey',
      event: 'User submitted survey form',
      source: 'spotify:app:zlink',
      source_version: pkg.version,
      source_vendor: 'com.spotify',
      json_data: data
    });

    hideCallback();
  }
};

/**
 * A callback that is triggered when the modal receives a session response.
 */
NPSSurvey.prototype.onSession = function (error, response) {
  if (types.conforms(response, { 'session': { 'country': '' } })) {
    this.country = response.session.country;
  }
};

/**
 * A callback that is triggered when the modal shows itself.
 */
NPSSurvey.prototype.onShow = function () {
  ClientEvent3.log({
    context: 'Survey',
    event: 'User viewed survey',
    source: 'spotify:app:zlink',
    source_version: pkg.version,
    source_vendor: 'com.spotify',
    json_data: this.makeLogData()
  });
};

/**
 * A callback that is triggered when the modal receives a bridge response.
 */
NPSSurvey.prototype.onTestGroup1 = function (response) {
  if (types.conforms(response, { 'testGroup': 0 })) {
    this.testGroups[0] = response.testGroup;
  }
};

/**
 * A callback that is triggered when the modal receives a bridge response.
 */
NPSSurvey.prototype.onTestGroup2 = function (response) {
  if (types.conforms(response, { 'testGroup': 0 })) {
    this.testGroups[1] = response.testGroup;
  }
};

/**
 * A method that is used by zlink to initialize the modal.
 *
 * @param {Modal} modal
 * @param {Bridge} bridge
 */
NPSSurvey.prototype.setup = function (modal, bridge) {
  var type;
  var onTestGroup1;
  var onTestGroup2;
  var onSession;
  var maybeShowSurvey;

  this.modal = modal;

  type = Event.TYPES.NAVIGATION_SHOW_NPS_SURVEY;

  eventDispatcher.addEventListener(type, function () {
    modal.display(this);
  }.bind(this));

  onTestGroup1 = NPSSurvey.prototype.onTestGroup1;
  onTestGroup2 = NPSSurvey.prototype.onTestGroup2;

  bridge.request('session_test_group', ['NPS-Survey-1'], this, onTestGroup1);
  bridge.request('session_test_group', ['NPS-Survey-2'], this, onTestGroup2);

  onSession = NPSSurvey.prototype.onSession;

  live('spotify:client').query('session(country)', onSession.bind(this));

  maybeShowSurvey = NPSSurvey.prototype.maybeShowSurvey;

  setTimeout(maybeShowSurvey.bind(this), SHOW_AFTER_MS);
};

/**
 * A method that determines whether the survey should shown for the current
 * user.
 */
NPSSurvey.prototype.shouldShowSurvey = function () {
  var msStart;
  var msNow;
  var daysSinceStart;
  var i;

  if (localSettings.get(LOCAL_SETTINGS_KEY) === 'true') {
    return false;
  }

  if (ENABLED_GROUPS_COUNTRIES.indexOf(this.country) !== -1) {
    if (this.testGroups[1] > ENABLED_GROUPS) {
      return false;
    }
  }

  msStart = new Date(2012, 0, 1).getTime();
  msNow = new Date().getTime();

  daysSinceStart = Math.round((msNow - msStart) / 1000 / 60 / 60 / 24);

  for (i = 0; i < 7; i++) {
    if (this.testGroups[0] === (daysSinceStart - i) % 1000) {
      return true;
    }
  }

  return false;
};

module.exports = NPSSurvey;

},{"../../../../../libs/spotify-event-dispatcher":264,"../../../../../libs/spotify-live":439,"../../../../../libs/spotify-logger/messages/ClientEvent3":451,"../../../i18n":11,"../../../package.json":21,"../../../templates/modals/nps-survey.hbs":176,"../../event":77,"../../models/localsettings":100,"bfs-km-types":514}],145:[function(require,module,exports){
// FIXME: copy-pasted from https://github.com/component/file-picker since they
// use component :-(

'use strict';

/**
 * Expose `FilePicker`
 */

module.exports = FilePicker;

/**
 * Input template
 */

var form = document.createElement('form');
form.innerHTML = '<input type="file" ' + 'style="top: -1000px; position: absolute" aria-hidden="true">';
document.body.appendChild(form);
var input = form.childNodes[0];

/**
 * Already bound
 */

var bound = false;

/**
 * Opens a file picker dialog.
 *
 * @param {Object} options (optional)
 * @param {Function} fn callback function
 * @api public
 */

function FilePicker(opts, fn) {
  if (typeof opts === 'function') {
    fn = opts;
    opts = {};
  }
  opts = opts || {};

  // multiple files support
  input.multiple = !!opts.multiple;

  // directory support
  input.webkitdirectory = input.mozdirectory = input.directory = !!opts.directory;

  // accepted file types support
  if (opts.accept === null || opts.accept === undefined) {
    delete input.accept;
  } else if (opts.accept.join) {
    // got an array
    input.accept = opts.accept.join(',');
  } else if (opts.accept) {
    // got a regular string
    input.accept = opts.accept;
  }

  // listen to change event (unbind old one if already listening)
  if (bound) input.removeEventListener('change', bound, false);
  input.addEventListener('change', onchange, false);
  bound = onchange;

  function onchange(e) {
    fn(input.files, e, input);
    input.removeEventListener('change', bound, false);
    bound = false;
  }

  // reset the form
  form.reset();

  // trigger input dialog
  input.click();
}

},{}],146:[function(require,module,exports){
'use strict';

module.exports = function getDataUriFromFile(file, callback) {
  var reader = new FileReader();
  reader.onload = function (fileEvent) {
    callback(fileEvent.target.result);
  };
  reader.readAsDataURL(file);
};

},{}],147:[function(require,module,exports){
'use strict';

module.exports = function getImageSizeFromFile(file, callback) {
  var img = new Image();
  img.onload = function () {
    callback(null, {
      width: img.width,
      height: img.height
    });
    URL.revokeObjectURL(img.src);
  };
  img.onerror = function (error) {
    URL.revokeObjectURL(img.src);
    callback(error);
  };
  img.src = URL.createObjectURL(file);
};

},{}],148:[function(require,module,exports){
(function (global){
'use strict';

var cosmos = require('spotify-cosmos-api');
var delegate = require('dom-delegate');
var escapeHTML = require('escape-html');
var live = require('../../../../../../libs/spotify-live');
var mixIn = require('mout/object/mixIn');
var Quill = require('quill');
var contains = require('mout/array/contains');
var playlistAnnotateTest = require('../../../../../../libs/spotify-playlist-annotate-test');
var logger = require('../../../logging/playlist-annotate-logger');

var _ = require('../../../../i18n').get;
var filePicker = require('./file-picker');
var getDataUriFromFile = require('./get-data-uri-from-file');
var getImageSizeFromFile = require('./get-image-size-from-file');
var mainTemplate = require('./templates/main.hbs');
var Model = require('../../../models/playlist-annotate');
var quillLinkTooltipTemplate = require('./templates/quill-link-tooltip.hbs');
var uploadImage = require('./upload-image');
var util = require('../../../live-models/util');
var isFileJpg = require('./is-file-jpg');

Quill.registerModule('auto-link', require('./quill-auto-link-module'));

var LOG_IMAGE_PREFIX = 'playlist_annotate_image';

var CREATE_ACTION = 'create';
var EDIT_ACTION = 'edit';
var NEW_PLAYLIST_NAME = _('playlist.annotate_form.new_playlist_name');

var NEWLINE_REG_EXP = /[\b\f\n\r\t\v\0]/gi;

var NAME_MAX_LENGTH = 100;
var DESCRIPTION_MAX_LENGTH = 300;
var MAX_FILE_SIZE = 4 * 1024 * 1024; // 4 Mb

var MIN_IMAGE_WIDTH = 300;
var MIN_IMAGE_HEIGHT = 300;

var ALLOWED_IMAGE_TYPES = ['image/jpeg'];

var IMAGE_TOO_SMALL_ERROR = _('playlist.annotate_form.error.image_too_small', MIN_IMAGE_WIDTH, MIN_IMAGE_HEIGHT);
var UNSUPPORTED_FORMAT_ERROR = _('playlist.annotate_form.drop_not_allowed_label');
var FILE_SIZE_EXCEEDED_ERROR = _('playlist.annotate_form.image_file_size_exceeded');
var FILE_NOT_VALID_JPG_ERROR = _('playlist.annotate_form.error.file_not_valid_jpg');

var FILE_VALIDATION_ERRORS = [IMAGE_TOO_SMALL_ERROR, UNSUPPORTED_FORMAT_ERROR, FILE_SIZE_EXCEEDED_ERROR, FILE_NOT_VALID_JPG_ERROR];

var OK_BUTTON_GLOBAL_SELECTOR = '.playlist-annotate button.button.button-green';
var MODAL_CLASS = 'playlist-annotate';
var MODAL_SELECTOR = '.' + MODAL_CLASS;

function PlaylistAnnotate() {}

PlaylistAnnotate.prototype.MODAL_CLASS = MODAL_CLASS;
PlaylistAnnotate.prototype.BUTTONS = {
  OK: true,
  CANCEL: true
};
PlaylistAnnotate.prototype.HIGH_PRIORITY = false;

PlaylistAnnotate.prototype.setup = function (modal) {
  this.initDragDrop(document);
  Model.setOnShowCallback(this.init.bind(this, modal));

  this.markupAllowed = playlistAnnotateTest.isMarkupAllowed();
};

PlaylistAnnotate.prototype.init = function (modal, uri, action, position, name, focus) {
  this._lastActiveElement = document.activeElement;

  this.modal = modal;
  this.uri = uri;
  this.action = action;
  this.createPlaylistAtPosition = position;
  this.name = name;
  this.focus = focus;

  // CONTENT is part of the "interface" that the zlink modal view
  // knows how to render
  this.CONTENT = document.createElement('div');

  this.delegate = delegate(this.CONTENT);
  this.delegate.on('click', '.remove-image-button', this._removeImage.bind(this));
  this.delegate.on('click', '.image-wrapper:not(.has-image)', this._chooseImageFile.bind(this, this._addImage.bind(this), LOG_IMAGE_PREFIX + '_upload'));
  this.delegate.on('click', '.image-wrapper.has-image', this._chooseImageFile.bind(this, this._addImage.bind(this), LOG_IMAGE_PREFIX + '_replace'));
  this.delegate.on('click', '.error-message-wrapper', this._hideErrorMessage.bind(this));
  this.delegate.on('keydown', '.description-field-wrapper', this._handleDescriptionKeydown.bind(this));
  this.delegate.on('paste', '.description-field-wrapper', this._handleDescriptionNewlines.bind(this));

  this.delegate.on('click', '.ql-link', this._onQuillLinkInsertClick.bind(this));

  // Follow online state
  var handleOnlineState = this._handleOnlineState.bind(this);
  live('spotify:client').get('session').on('update', function (properties) {
    if ('online' in properties) handleOnlineState(properties.online);
  });

  // FIXME(jaco): reuse nicely
  this.load(this.render.bind(this));
};

PlaylistAnnotate.prototype._handleOnlineState = function (isOnline) {
  var msg = _('playlist.annotate_form.warning.client_offline');
  if (isOnline && msg === this._currentErrorMessage) {
    // Hide offline warning if it is being displayed
    this._hideErrorMessage();
  } else if (!isOnline) {
    this._setErrorMessage(msg, 'warning');
  }
};

PlaylistAnnotate.prototype._handleDescriptionNewlines = function (event) {
  // Disregard paste events inside link tooltip to avoid KM-7338.
  if (event.target.matches('.ql-link-tooltip input')) return;

  setTimeout(function () {
    if (this.markupAllowed) {
      var selection = this.editor.getSelection();
      var contents = this.editor.getContents();
      contents.ops.forEach(function (op) {
        if (op.insert) {
          if (this._hasNewlines(op.insert)) {
            if (this._hasNewlines(op.insert.trim())) {
              // Don't display errors on leading/trailing
              // newlines as the editor often produces these
              // by itself.
              this._showDescriptionLineBreaksError();
            }

            op.insert = this._stripNewlines(op.insert);
          }
        }
      }.bind(this));
      this.editor.setContents(contents);
      this.editor.setSelection(selection);
    } else {
      // Save selection
      var start = this.editor.node.selectionStart;
      var end = this.editor.node.selectionEnd;

      var text = this.editor.getText();
      if (this._hasNewlines(text)) {
        if (this._hasNewlines(text.trim())) {
          // Don't display errors on leading/trailing
          // newlines as the editor often produces these
          // by itself.
          this._showDescriptionLineBreaksError();
        }

        var newText = this._stripNewlines(text);
        this.editor.setText(newText);
        // Restore selection
        this.editor.node.setSelectionRange(start, end);
      }
    }
  }.bind(this), 0);
};

PlaylistAnnotate.prototype.initDragDrop = function (root) {
  var delegateRoot = delegate(root);

  delegateRoot.on('dragover', MODAL_SELECTOR, this._handleDragOver.bind(this));

  delegateRoot.on('drop', MODAL_SELECTOR, this._handleDrop.bind(this));

  delegateRoot.on('dragleave', MODAL_SELECTOR, this._handleDragLeave.bind(this));
};

PlaylistAnnotate.prototype._handleDrop = function (e) {
  e.stopPropagation();
  e.preventDefault();
  var el = document.querySelector(MODAL_SELECTOR);

  this.logHit({
    'event_version': LOG_IMAGE_PREFIX + '_drop'
  });

  el.classList.remove('drag', 'drag-valid', 'drag-invalid');

  var file = e.dataTransfer.files[0];
  try {
    this._addImage(file);
  } catch (e) {
    console.warn('Unable to upload file', e);
  }

  return false;
};

PlaylistAnnotate.prototype._handleDragOver = function (e) {
  e.stopPropagation();
  e.preventDefault();
  var el = document.querySelector(MODAL_SELECTOR);
  el.classList.add('drag');

  if (this._validateImageType(e.dataTransfer.items[0])) {
    e.dataTransfer.dropEffect = 'copy';
    el.classList.add('drag-valid');
    el.classList.remove('drag-invalid');
  } else {
    e.dataTransfer.dropEffect = 'none';
    el.classList.remove('drag-valid');
    el.classList.add('drag-invalid');
  }
};

PlaylistAnnotate.prototype._handleDragLeave = function (e) {
  e.stopPropagation();
  e.preventDefault();
  var el = document.querySelector(MODAL_SELECTOR);
  el.classList.remove('drag', 'drag-valid');
};

PlaylistAnnotate.prototype._validateImageType = function (item) {
  return item && contains(ALLOWED_IMAGE_TYPES, item.type);
};

PlaylistAnnotate.prototype._validateImage = function (file, callback) {
  if (!file) return callback(new Error('file missing'));

  if (!this._validateImageType(file)) {
    callback(new Error(UNSUPPORTED_FORMAT_ERROR));
  } else if (file.size > MAX_FILE_SIZE) {
    callback(new Error(_(FILE_SIZE_EXCEEDED_ERROR)));
  } else {
    isFileJpg(file, function (isJpg) {
      if (isJpg) {
        getImageSizeFromFile(file, function (error, size) {
          logger.log({
            'event': 'info:default',
            'event_version': 'playlist_annotate_image_upload',
            'json_data': {
              'image_original_width': size.width,
              'image_original_height': size.height
            }
          });

          if (error) return callback(error);

          if (size.width < MIN_IMAGE_WIDTH || size.height < MIN_IMAGE_HEIGHT) {
            callback(new Error(IMAGE_TOO_SMALL_ERROR));
          } else {
            callback();
          }
        });
      } else {
        callback(new Error(_(FILE_NOT_VALID_JPG_ERROR)));
      }
    });
  }
};

PlaylistAnnotate.prototype._hideValidationErrors = function () {
  if (contains(FILE_VALIDATION_ERRORS, this._currentErrorMessage)) {
    this._hideErrorMessage();
  }
};

PlaylistAnnotate.prototype._onQuillLinkInsertClick = function () {
  var errorMessage = _('playlist.annotate_form.error.selection_required_to_insert_link');
  var range = this.editor.getSelection();
  if (!range || range.start === range.end) {
    this._setErrorMessage(errorMessage, 'warning');
  } else if (this._currentErrorMessage === errorMessage) {
    this._hideErrorMessage();
  }
};

PlaylistAnnotate.prototype.load = function (callback) {
  var data = {
    markupAllowed: this.markupAllowed,
    hasVisibleFormPermissionMessage: playlistAnnotateTest.hasVisibleFormPermissionMessage(),
    NAME_MAX_LENGTH: NAME_MAX_LENGTH,
    DESCRIPTION_MAX_LENGTH: DESCRIPTION_MAX_LENGTH
  };
  if (this.action === EDIT_ACTION) {
    live(this.uri).query('uri, name, image, description, annotatedImage', function (error, _data) {
      mixIn(data, _data, {
        imageUrl: _data.image,
        name: this.name || _data.name
      });
      callback(data);
    }.bind(this), live.ASAP);
  } else if (this.action === CREATE_ACTION) {
    callback(mixIn(data, {
      name: this.name || NEW_PLAYLIST_NAME,
      description: ''
    }));
  }
};

PlaylistAnnotate.prototype.render = function (data) {
  this.data = data;
  this.isSaved = false;

  logger.log({
    event: 'user:impression',
    json_data: {
      targetType: 'spotify:annotate_playlist'
    }
  });

  if (this.action === CREATE_ACTION) {
    this.MODAL_TITLE = _('playlist.annotate_form.create_title');
    this.OK_BUTTON_LABEL = _('playlist.annotate_form.create');
    this.CANCEL_BUTTON_LABEL = _('playlist.annotate_form.cancel');
  } else if (this.action === EDIT_ACTION) {
    this.MODAL_TITLE = _('playlist.annotate_form.edit_title');
    this.OK_BUTTON_LABEL = _('playlist.annotate_form.save');
    this.CANCEL_BUTTON_LABEL = _('playlist.annotate_form.cancel');
  }

  this.CONTENT.innerHTML = mainTemplate(data);

  this.modal.display(this);

  this.form = this.CONTENT.querySelector('#create-or-edit-playlist-form');
  this.form.addEventListener('submit', function (event) {
    event.preventDefault();
    this.submit();
  }.bind(this));

  this.nameCharCounter = this.form.querySelector('.name-field-char-counter');
  this.nameField = this.form.querySelector('.name-field');
  this.nameField.addEventListener('input', this._updateNameFieldCharCounter.bind(this));
  this._updateNameFieldCharCounter();

  if (data.markupAllowed) {
    this.editor = this._createEditorWithMarkupAllowed();
  } else {
    this.editor = this._createEditor();
  }

  this.descriptionCharCounter = this.form.querySelector('.description-field-char-counter');
  this.editor.on('text-change', this._updateDescriptionFieldCharCounter.bind(this));
  this._updateDescriptionFieldCharCounter();
  live('spotify:client').query('session(online)', function (error, data) {
    if (error) throw error;
    this._handleOnlineState(data.session.online);
  }.bind(this));

  this.editor.on('text-change', function warnHTMLDisallowed() {
    var errorMessage = _('playlist.annotate_form.error.html_not_allowed');
    if (/<[abi]/g.test(this.editor.getText())) {
      this._setErrorMessage(errorMessage, 'warning');
    } else if (this._currentErrorMessage === errorMessage) {
      this._hideErrorMessage();
    }
  }.bind(this));

  if (this.focus === 'description') {
    this._focusAndSelectDescriptionField();
  } else {
    this._focusAndSelectNameField();
  }
};

PlaylistAnnotate.prototype.submit = function () {
  var name = this.nameField.value.trim();
  var description = this.editor.getDescription().trim();

  if (!name) {
    this._setErrorMessage(_('playlist.annotate_form.error.name_required'));
    this.nameField.focus();
    return;
  }

  var isNewPlaylist = this.action === CREATE_ACTION;

  var data = {};
  if (name !== this.data.name || isNewPlaylist) {
    data.name = name;
  }
  // If the user is not allowed to use markup, we must escape the description
  // before comparing with the one which comes escaped from the backend.
  var compareDescription = this.markupAllowed ? description : escapeHTML(description);
  if (compareDescription !== this.data.description) {
    data.description = description;
  }

  data.createPlaylistAtPosition = this.createPlaylistAtPosition;

  // Prevent multiple submits
  if (this.isSubmitting()) return;
  this.setIsSubmitting(true);

  live('spotify:client').query('session(online)', function (err, result) {
    if (err) {
      if (global.console) {
        console.error(err);
      }

      var msg = _('playlist.annotate_form.error.submit');
      this._setErrorMessage(msg);
      this.setIsSubmitting(false);
      return;
    }

    var action = this.action;
    var imageReady = this.imageReady;

    // Don't try to save description or image when offline. We've already
    // warned that we can't.
    var isOnline = result.session.online;
    if (!isOnline) {
      delete data.description;
      imageReady = null;
    }
    var changedAny = 'name' in data || 'description' in data || !!imageReady;
    var changedName = 'name' in data;
    var hasSomethingToSave = isOnline && changedAny || changedName || isNewPlaylist;

    if (!hasSomethingToSave) {
      // Nothing saveable, so just hide.
      this.modal.hide();
      return;
    }

    var dataReady;
    if (isOnline) {
      dataReady = new Promise(function (resolve, reject) {
        if (imageReady) {
          imageReady.then(function (image) {
            data.image_uri = image.uri;
            data.image = image.dataString;
            resolve(data);
          }, function (error) {
            reject(error);
          });
        } else {
          resolve(data);
        }
      });
    } else {
      dataReady = new Promise(function (resolve) {
        resolve({
          name: data.name,
          createPlaylistAtPosition: data.createPlaylistAtPosition
        });
      });
    }

    Model.submit(this.uri, dataReady, this._handleSubmitResponse.bind(this, action, data));

    dataReady.then(function (changes) {
      var withImage = 'image_uri' in changes;
      var withDescription = 'description' in changes;

      this.logHit({
        'event_version': 'save',
        'something_changed': withImage || withDescription,
        'new_playlist': this.action === CREATE_ACTION,
        'with_image': withImage,
        'remove_image': changes.image_uri === '',
        'with_description': withDescription
      });
    }.bind(this), function () {
      this.setIsSubmitting(false);
    }.bind(this));
  }.bind(this), live.ASAP);
};

PlaylistAnnotate.prototype.isSubmitting = function () {
  return !!this._isSubmitting;
};

PlaylistAnnotate.prototype.setIsSubmitting = function (value) {
  this._isSubmitting = value;

  var btn = document.querySelector(OK_BUTTON_GLOBAL_SELECTOR);
  if (this._isSubmitting) {
    btn.setAttribute('disabled', 'disabled');
  } else {
    btn.removeAttribute('disabled');
  }
};

PlaylistAnnotate.prototype._createEditor = function () {
  var editor = {
    getText: function () {
      return this.form.querySelector('.description-field').value;
    }.bind(this),
    setText: function (string) {
      this.form.querySelector('.description-field').value = string;
    }.bind(this),
    getDescription: function () {
      return this.form.querySelector('.description-field').value;
    }.bind(this),
    on: function (name, callback) {
      if (name !== 'text-change') {
        throw new Error('Unsupported event: ' + name);
      }
      var descriptionEl = this.form.querySelector('.description-field');
      descriptionEl.addEventListener('input', function () {
        callback.call(editor);
      });
    }.bind(this),
    node: this.form.querySelector('.description-field'),
    focusAndSelectText: function focusAndSelectText() {
      editor.node.focus();
      editor.node.select();
    }
  };

  return editor;
};

PlaylistAnnotate.prototype._createEditorWithMarkupAllowed = function () {
  var editor = new Quill('#editor', {
    formats: ['link'],
    modules: {
      'toolbar': { container: '#toolbar' },
      'link-tooltip': {
        template: quillLinkTooltipTemplate()
      },
      'auto-link': true
    },
    theme: 'snow'
  });

  editor.getDescription = function () {
    return editor.getHTML().replace(/<\/?div>/g, '').replace(/<br\/?>/g, '').replace(/&nbsp;/g, ' ').replace(/\s+/g, ' ');
  };

  var descriptionFieldWrapper = this.form.querySelector('.description-field-wrapper');

  var handlePlaceholder = function handlePlaceholder() {
    if (editor.getDescription().trim().length) {
      descriptionFieldWrapper.classList.remove('show-placeholder');
    } else {
      descriptionFieldWrapper.classList.add('show-placeholder');
    }
  };

  editor.on('text-change', handlePlaceholder);
  handlePlaceholder();

  // This is somewhat hacky, but as the original tooltip module is written in
  // CoffeeScript and bundled with Quill, we resort to this.
  //
  // Going forward, we'll have to fork the `link-tooltip` module to make it
  // more Spotify-friendly, both regarding looks and behaviour.
  editor.getModule('link-tooltip')._normalizeURL = function (url) {
    if (!/^(https?:\/\/|mailto:|spotify:)/.test(url)) {
      url = 'http://' + url;
    }
    return url;
  };

  editor.focusAndSelectText = function () {
    editor.setSelection(0, editor.getLength());
  };

  editor.root.classList.add('form-control');
  return editor;
};

PlaylistAnnotate.prototype._handleSubmitResponse = function (action, data, err, results) {
  this.setIsSubmitting(false);
  if (err) {
    var msg = _('playlist.annotate_form.annotate_failed');
    this._setErrorMessage(msg);
    return console.error(err);
  }

  if (action === CREATE_ACTION) {
    this.uri = results.uri;
  }

  data.uri = this.uri;
  data.annotatedImage = data.image;

  if (data.description && !this.markupAllowed) {
    // This is the description being sent to playlist-desktop for immediate
    // display, so it must be escaped. The real escaping still takes place on
    // the server, so this is just to get instant feedback in this client.
    data.description = escapeHTML(data.description);
  }

  cosmos.resolver.post({
    url: 'sp://messages/v1/playliststate',
    body: data
  });

  this.isSaved = true;
  this.modal.hide();
};

PlaylistAnnotate.prototype._handleDescriptionKeydown = function (e) {
  // Enter key was pressed down
  if (e.which === 13) {
    e.preventDefault();
    e.stopPropagation();

    this._showDescriptionLineBreaksError();
  }
};

PlaylistAnnotate.prototype._showDescriptionLineBreaksError = function () {
  var errorMessage = _('playlist.annotate_form.warning.no_line_breaks_in_description');
  this._setErrorMessage(errorMessage, 'warning');
};

PlaylistAnnotate.prototype._focusAndSelectNameField = function () {
  var input = this.CONTENT.querySelector('#create-or-edit-playlist-name');
  input.focus();
  input.select();
};

PlaylistAnnotate.prototype._focusAndSelectDescriptionField = function () {
  this.editor.focusAndSelectText();
};

PlaylistAnnotate.prototype._updateNameFieldCharCounter = function () {
  this.nameCharCounter.textContent = this.nameField.value.length + ' / ' + NAME_MAX_LENGTH;
};

PlaylistAnnotate.prototype._updateDescriptionFieldCharCounter = function (delta, source) {
  var textLength = this.editor.getText().replace(NEWLINE_REG_EXP, '').length;

  if (source === 'user' && textLength >= DESCRIPTION_MAX_LENGTH) {
    delta.ops = [{
      retain: DESCRIPTION_MAX_LENGTH
    }];
    this.editor.setContents(delta);
    textLength = this.editor.getText().trim().replace(NEWLINE_REG_EXP, '').length;
  }

  this.descriptionCharCounter.textContent = textLength + ' / ' + DESCRIPTION_MAX_LENGTH;
};

PlaylistAnnotate.prototype._chooseImageFile = function (callback, userIntention, event) {
  if (event.defaultPrevented) return;

  this.logHit({
    'event_version': userIntention
  });

  filePicker({ accept: ['image/jpeg'] }, function (files) {
    callback(files[0]);
  });
};

PlaylistAnnotate.prototype._addImage = function (file) {
  this._validateImage(file, function (error) {
    if (error) {
      return this._setErrorMessage(error.message);
    }

    this._hideValidationErrors();

    this.file = file;

    this._resetImageProgress();
    var updateImageProgress = this._updateImageProgress.bind(this);

    getDataUriFromFile(file, function (dataUri) {
      this.CONTENT.querySelector('.image-wrapper').classList.add('has-image');
      this.CONTENT.querySelector('.media-object').classList.remove('show-placeholder');
      this.CONTENT.querySelector('.mo-image').style.backgroundImage = 'url(' + dataUri + ')';

      this.imageReady = new Promise(function (resolve, reject) {
        uploadImage(file, updateImageProgress, function (err, imageId) {
          if (err) {
            console.error(err);
            reject(err);
          } else {
            resolve({
              uri: 'spotify:userimage:' + imageId,
              dataString: dataUri
            });
          }
        });
      });

      var uploadErrorMessage = _('playlist.annotate_form.image_file_upload_failed');
      this.imageReady.then(function () {
        if (this._currentErrorMessage === uploadErrorMessage) {
          this._hideErrorMessage();
        }
      }.bind(this));

      // Handle error in upload
      this.imageReady.catch(function () {
        this._setErrorMessage(uploadErrorMessage);

        // Reset the imageReady property so that submission
        // will not end up waiting for this to finish.
        this.imageReady = null;

        // Reset image visuals.
        this._resetImageProgress();
        if (this.data.imageUrl) {
          this.CONTENT.querySelector('.mo-image').style.backgroundImage = 'url(' + this.data.imageUrl + ')';
        } else {
          this.CONTENT.querySelector('.media-object').classList.add('show-placeholder');
        }
        if (!this.data.annotatedImage) {
          this.CONTENT.querySelector('.image-wrapper').classList.remove('has-image');
        }
      }.bind(this));
    }.bind(this));
  }.bind(this));
};

PlaylistAnnotate.prototype._setErrorMessage = function (message, level) {
  if (!level) level = 'error';

  this._currentErrorMessage = message;
  var el = this.CONTENT.querySelector('#error-message-bar');
  var wrapper = this.CONTENT.querySelector('.error-message-wrapper');
  el.innerHTML = message;
  wrapper.classList.remove('has-error', 'has-warning');
  wrapper.classList.add('has-' + level);
};

PlaylistAnnotate.prototype._hideErrorMessage = function () {
  var el = this.CONTENT.querySelector('#error-message-bar');
  var wrapper = this.CONTENT.querySelector('.error-message-wrapper');
  el.innerHTML = '';
  wrapper.classList.remove('has-error', 'has-warning');
};

PlaylistAnnotate.prototype._updateImageProgress = function (e) {
  var progress = e.loaded / e.total * 100;
  var progressBar = this.CONTENT.querySelector('.image-upload-progress-bar');
  progressBar.style.width = progress + '%';
};

PlaylistAnnotate.prototype._resetImageProgress = function () {
  var progressBar = this.CONTENT.querySelector('.image-upload-progress-bar');

  progressBar.classList.add('no-transition');
  progressBar.style.width = '';
  setTimeout(function () {
    progressBar.classList.remove('no-transition');
  }, 0);
};

PlaylistAnnotate.prototype._removeImage = function (event) {
  // Prevent Chose image delegate
  event.preventDefault();

  this.logHit({
    'event_version': LOG_IMAGE_PREFIX + '_remove'
  });

  this.file = null;
  this.CONTENT.querySelector('.image-wrapper').classList.remove('has-image');
  this.CONTENT.querySelector('.media-object').classList.add('show-placeholder');
  this.CONTENT.querySelector('.mo-image').style.backgroundImage = 'none';
  this._resetImageProgress();

  this.imageReady = new Promise(function (resolve) {
    resolve({ uri: '', dataString: '' });
  });
};

/**
 * Strips all newline characters from a string.
 * Characters gotten from https://mathiasbynens.be/notes/javascript-escapes
 */
PlaylistAnnotate.prototype._stripNewlines = function (string) {
  return (string || '').replace(NEWLINE_REG_EXP, ' ');
};

PlaylistAnnotate.prototype._hasNewlines = function (string) {
  return NEWLINE_REG_EXP.test(string);
};

PlaylistAnnotate.prototype.onOk = function () {
  this.submit();
};

PlaylistAnnotate.prototype.onCancel = function (callback) {
  this.logHit({
    'event_version': 'cancel'
  });
  callback();
};

PlaylistAnnotate.prototype.checkUnsavedChanges = function () {
  var hasImageChanged = !!this.imageReady;
  var hasNameChanged = this.nameField.value.trim() !== this.data.name;

  var description = this.editor.getDescription().trim();
  if (!this.markupAllowed) {
    description = escapeHTML(description);
    // The backend uses base16 based escape sequences, while the front-end uses
    // base10. Normalise these to not consider a simple difference in encoding
    // an unsaved change.
    description = description.replace(/&#39/, '&#x27');
  }
  var hasDescriptionChanged = description !== this.data.description.trim();

  return hasImageChanged || hasNameChanged || hasDescriptionChanged;
};

PlaylistAnnotate.prototype.onHide = function () {
  // If there are unsaved changes, warn user and prevent modal from hiding
  // until they dismiss it again.
  var warningMessageUnsavedChanges = _('playlist.annotate_form.warning.unsaved_changes');
  if (this.isSaved === false && this.checkUnsavedChanges() && this._currentErrorMessage !== warningMessageUnsavedChanges) {
    this._setErrorMessage(warningMessageUnsavedChanges, 'warning');
    return false;
  }

  // This lets the rest of zlink know that we're not editing the name
  // of this playlist anymore. Not doing this will make zlink trigger
  // the cosmos subscription in .setup again when navigating away from
  // this playlist in the rootlist.
  var rowUri = util.getRowUri(this.uri);
  live(rowUri).update({ renaming: false });

  this.delegate.destroy();
  this.imageReady = null;
  this.setIsSubmitting(false);
  this._currentErrorMessage = null;

  if (this._lastActiveElement && this._lastActiveElement.focus) {
    this._lastActiveElement.focus();
  }
};

PlaylistAnnotate.prototype.logHit = function (options) {
  var jsonData = mixIn(options, { target_uri: this.url });
  return logger.log({
    'event': 'user:hit',
    'event_version': options.event_version,
    'json_data': jsonData
  });
};

module.exports = PlaylistAnnotate;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../../../../../libs/spotify-live":439,"../../../../../../libs/spotify-playlist-annotate-test":485,"../../../../i18n":11,"../../../live-models/util":91,"../../../logging/playlist-annotate-logger":95,"../../../models/playlist-annotate":102,"./file-picker":145,"./get-data-uri-from-file":146,"./get-image-size-from-file":147,"./is-file-jpg":149,"./quill-auto-link-module":150,"./templates/main.hbs":151,"./templates/quill-link-tooltip.hbs":152,"./upload-image":153,"dom-delegate":529,"escape-html":530,"mout/array/contains":625,"mout/object/mixIn":667,"quill":682,"spotify-cosmos-api":694}],149:[function(require,module,exports){
'use strict';

var isJpg = require('is-jpg');

module.exports = function isFileJpg(file, callback) {
  var reader = new FileReader();
  reader.onload = function (fileEvent) {
    callback(isJpg(new Uint8Array(fileEvent.target.result)));
  };
  reader.readAsArrayBuffer(file);
};

},{"is-jpg":566}],150:[function(require,module,exports){
'use strict';

var formatLink = function formatLink(link) {
  return (/^https?:\/\//.test(link) ? link : 'http://' + link).replace(/[.!;,\-_]*$/, '');
};

var rLink = /(?:^|\b)(["'])?(?:(?:(?:\w)+:)?\/\/)?(?:\S+(?::\S*)?@)?(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])(?:\.(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])){3}|(?:localhost)|(?:(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)(?:\.(?:[a-z\u00a1-\uffff0-9]-*)*[a-z\u00a1-\uffff0-9]+)*(?:\.(?:xn--[a-z0-9\-]{1,59}|com|org|edu|gov|uk|net|ca|de|jp|fr|au|us|ru|ch|it|nl|se|no|es|mil|fi|cn|br|be|at|info|pl|dk|cz|cl|hu|nz|il|ie|za|tw|kr|mx|gr|ar|hk|in|pt|sg|tr|sk|ro|tv|lv|biz+)))(?::\d{2,5})?(?:\/[^\s]*)?\1/gi; // eslint ignore:line
var rLinkTag = /<a\s+[^>]*href=(['"])([^'"]+)\1[^>]*>([^<]+)<\s*\/a\s*>/i;

module.exports = function (quill) {
  // A lighter version of the npm module url-regex, which isn't quickstartable
  // due to a bug in quickstart :-(

  /* eslint-disable no-cond-assign */
  quill.on('text-change', function handleAutoLinking(changedDelt, source) {
    if (source !== 'user') return;

    var delta = quill.getContents();
    var op;
    var prev;
    var str;
    var matches;
    var link;
    var content;
    var start;
    var end;
    var newOps;
    var range;

    for (var i = 0; i < delta.ops.length; i++) {
      op = delta.ops[i];
      rLink.lastIndex = 0;
      rLinkTag.lastIndex = 0;
      if (op.insert && op.insert.trim() && (prev = delta.ops[i - 1]) && prev.attributes && prev.attributes.link && (str = prev.insert + op.insert.replace(/\s*$/, '')) && (matches = rLink.exec(str)) && matches[0] !== prev.insert && matches.index === 0) {
        // Appending to a link
        link = matches[0];
        end = link.length;
        newOps = [];

        prev.insert = link;
        prev.attributes.link = formatLink(link);

        if (str.length !== link.length) {
          newOps.push({
            insert: str.substring(end)
          });
        }

        delta.ops.splice.apply(delta.ops, [i, 1].concat(newOps));
        range = quill.getSelection();
        quill.setContents(delta);
        if (range) {
          quill.setSelection(range);
        }
        break;
      } else if (rLink.lastIndex = 0, op.insert && !(op.attributes && op.attributes.link) && (matches = rLink.exec(op.insert))) {
        // Found a new link
        link = matches[0];
        content = link;
        start = matches.index;
        end = start + link.length;

        // Found a whole <a> tag to replace
        if (matches = rLinkTag.exec(op.insert)) {
          link = matches[2];
          content = matches[3];
          start = matches.index;
          end = start + matches[0].length;
        }

        newOps = [];

        if (start !== 0) {
          newOps.push({
            insert: op.insert.substring(0, start)
          });
        }

        newOps.push({
          insert: content,
          attributes: {
            link: formatLink(link)
          }
        });

        if (end !== op.insert.length) {
          newOps.push({
            insert: op.insert.substring(end)
          });
        }

        delta.ops.splice.apply(delta.ops, [i, 1].concat(newOps));
        range = quill.getSelection();
        quill.setContents(delta);
        if (range) {
          quill.setSelection(range);
        }
        break;
      }
    }
  });

  /* eslint-enable no-cond-assign */
};

},{}],151:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, options, functionType="function", escapeExpression=this.escapeExpression, self=this, helperMissing=helpers.helperMissing;

function program1(depth0,data) {


  return "has-image";
  }

function program3(depth0,data) {

  var buffer = "";
  return buffer;
  }

function program5(depth0,data) {


  return "show-placeholder";
  }

function program7(depth0,data) {

  var buffer = "", stack1, helper;
  buffer += "style=\"background-image: url(";
  if (helper = helpers.imageUrl) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.imageUrl); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + ")\"";
  return buffer;
  }

function program9(depth0,data) {

  var buffer = "", stack1, helper, options;
  buffer += "\n        <div class=\"description-field-wrapper inverted-text has-editor ";
  stack1 = helpers['if'].call(depth0, ((stack1 = (depth0 && depth0.description)),stack1 == null || stack1 === false ? stack1 : stack1.length), {hash:{},inverse:self.program(5, program5, data),fn:self.program(3, program3, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\">\n          <div id=\"editor\" role=\"input\">\n            <div>";
  if (helper = helpers.description) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.description); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "</div>\n          </div>\n          <span class=\"placeholder\">"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "playlist.annotate_form.description_field_placeholder", options) : helperMissing.call(depth0, "loc", "playlist.annotate_form.description_field_placeholder", options)))
    + "</span>\n          <div id=\"toolbar\" class=\"toolbar ql-toolbar ql-snow\">\n            <span class=\"ql-format-group\">\n              <span class=\"ql-format-button ql-link\">"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "playlist.annotate_form.insert_link_button_label", options) : helperMissing.call(depth0, "loc", "playlist.annotate_form.insert_link_button_label", options)))
    + "</span>\n            </span>\n          </div>\n        </div>\n        ";
  return buffer;
  }

function program11(depth0,data) {

  var buffer = "", stack1, helper, options;
  buffer += "\n        <textarea class=\"form-control description-field-wrapper description-field\" id=\"create-or-edit-playlist-description\" name=\"description\" maxlength=\"";
  if (helper = helpers.DESCRIPTION_MAX_LENGTH) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.DESCRIPTION_MAX_LENGTH); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" placeholder=\""
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "playlist.annotate_form.description_field_placeholder", options) : helperMissing.call(depth0, "loc", "playlist.annotate_form.description_field_placeholder", options)))
    + "\">";
  if (helper = helpers.description) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.description); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "</textarea>\n        ";
  return buffer;
  }

function program13(depth0,data) {

  var buffer = "", helper, options;
  buffer += "\n  <div class=\"row permission-message\">\n    <div class=\"col-sm-12\">\n      <span>"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "playlist.annotate_form.permission_message", options) : helperMissing.call(depth0, "loc", "playlist.annotate_form.permission_message", options)))
    + "</span>\n    </div>\n  </div>\n  ";
  return buffer;
  }

  buffer += "<form role=\"form\" id=\"create-or-edit-playlist-form\">\n  <div class=\"form-group\">\n    <label for=\"create-or-edit-playlist-name\">"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "playlist.annotate_form.name_field_label", options) : helperMissing.call(depth0, "loc", "playlist.annotate_form.name_field_label", options)))
    + "</label>\n    <div class=\"name-field-wrapper\">\n      <input type=\"text\" class=\"form-control name-field\" id=\"create-or-edit-playlist-name\" placeholder=\""
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "playlist.annotate_form.name_field_placeholder", options) : helperMissing.call(depth0, "loc", "playlist.annotate_form.name_field_placeholder", options)))
    + "\" name=\"name\" maxlength=\"";
  if (helper = helpers.NAME_MAX_LENGTH) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.NAME_MAX_LENGTH); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" value=\"";
  if (helper = helpers.name) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.name); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\">\n      <span class=\"name-field-char-counter badge\"></span>\n    </div>\n  </div>\n\n  <div class=\"row\">\n    <div class=\"form-group col-sm-4 col-md-4 col-lg-4\">\n      <label>"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "playlist.annotate_form.image_field_label", options) : helperMissing.call(depth0, "loc", "playlist.annotate_form.image_field_label", options)))
    + "</label>\n\n\n      <div class=\"image-wrapper ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.annotatedImage), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\">\n        <div class=\"media-object media-object-playlist media-object-simple media-object-link ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.imageUrl), {hash:{},inverse:self.program(5, program5, data),fn:self.program(3, program3, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\">\n          <div class=\"mo-wrapper\">\n            <div class=\"mo-image-wrapper\">\n              <svg class=\"mo-placeholder\" viewBox=\"0 0 10 10\" preserveAspectRatio=\"xMidYMid meet\">\n                <text class=\"playlist-placeholder\" x=\"5\" y=\"9.8\">&#xf135;</text>\n              </svg>\n              <div class=\"mo-image\" ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.imageUrl), {hash:{},inverse:self.noop,fn:self.program(7, program7, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "></div>\n            </div>\n            <div class=\"controls\">\n              <button type=\"button\" class=\"button button-with-stroke choose-image-button\">\n                "
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "playlist.annotate_form.image_pick_button_label", options) : helperMissing.call(depth0, "loc", "playlist.annotate_form.image_pick_button_label", options)))
    + "\n              </button>\n\n              <button type=\"button\" class=\"button button-with-stroke remove-image-button\">\n                "
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "playlist.annotate_form.image_remove_button_label", options) : helperMissing.call(depth0, "loc", "playlist.annotate_form.image_remove_button_label", options)))
    + "\n              </button>\n              <button type=\"button\" class=\"button button-with-stroke replace-image-button\">\n                "
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "playlist.annotate_form.image_replace_button_label", options) : helperMissing.call(depth0, "loc", "playlist.annotate_form.image_replace_button_label", options)))
    + "\n              </button>\n            </div>\n          </div>\n        </div>\n\n        <div class=\"image-upload-progress-bar\"></div>\n      </div>\n\n    </div>\n    <div class=\"form-group col-sm-8 col-md-8 col-lg-8\">\n      <label for=\"description\">"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "playlist.annotate_form.description_field_label", options) : helperMissing.call(depth0, "loc", "playlist.annotate_form.description_field_label", options)))
    + "</label>\n        ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.markupAllowed), {hash:{},inverse:self.program(11, program11, data),fn:self.program(9, program9, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n        <span class=\"description-field-char-counter badge\"></span>\n    </div>\n  </div>\n\n  <div class=\"row\">\n    <div class=\"col-sm-12 error-message-wrapper\">\n      <span class=\"spoticon-warning-16\"></span>\n      <span id=\"error-message-bar\" data-close=\""
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "playlist.annotate_form.close-error-bar", options) : helperMissing.call(depth0, "loc", "playlist.annotate_form.close-error-bar", options)))
    + "\"></span>\n    </div>\n  </div>\n\n  ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.hasVisibleFormPermissionMessage), {hash:{},inverse:self.noop,fn:self.program(13, program13, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n  <div class=\"dropzone-wrapper\">\n    <div class=\"dropzone-message button\">"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "playlist.annotate_form.drop_to_set_image_label", options) : helperMissing.call(depth0, "loc", "playlist.annotate_form.drop_to_set_image_label", options)))
    + "</div>\n    <div class=\"dropzone-error-message button\">"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "playlist.annotate_form.drop_not_allowed_label", options) : helperMissing.call(depth0, "loc", "playlist.annotate_form.drop_not_allowed_label", options)))
    + "</div>\n  </div>\n\n  <input type=\"submit\" tabindex=\"-1\" aria-hidden=\"true\" />\n\n</form>\n";
  return buffer;
  });

},{"hbsfy/runtime":563}],152:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", helper, options, helperMissing=helpers.helperMissing, escapeExpression=this.escapeExpression;


  buffer += "<span class=\"title\">"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "playlist.annotate_form.insert_link.link_field_label", options) : helperMissing.call(depth0, "loc", "playlist.annotate_form.insert_link.link_field_label", options)))
    + ":&nbsp;</span>\n<a href=\"#\" class=\"url\" target=\"_blank\" href=\"about:blank\"></a>\n<input class=\"input\" type=\"text\">\n<span>&nbsp;&#45;&nbsp;</span>\n<a href=\"javascript:;\" class=\"change\">"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "playlist.annotate_form.insert_link.change_button_label", options) : helperMissing.call(depth0, "loc", "playlist.annotate_form.insert_link.change_button_label", options)))
    + "</a>\n<a href=\"javascript:;\" class=\"remove\">"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "playlist.annotate_form.insert_link.remove_button_label", options) : helperMissing.call(depth0, "loc", "playlist.annotate_form.insert_link.remove_button_label", options)))
    + "</a>\n<a href=\"javascript:;\" class=\"done\">"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "playlist.annotate_form.insert_link.done_button_label", options) : helperMissing.call(depth0, "loc", "playlist.annotate_form.insert_link.done_button_label", options)))
    + "</a>\n";
  return buffer;
  });

},{"hbsfy/runtime":563}],153:[function(require,module,exports){
'use strict';

var cosmos = require('spotify-cosmos-api');
var logger = require('../../../logging/playlist-annotate-logger');

var CLIENT_ID = 'aeff20adc2ed43fabcb4186cf13148a4';
var ENDPOINT = 'https://image-upload.spotify.com/v3/playlist';

module.exports = function uploadImage(file, progressCallback, callback) {
  var tokenTime = -1;
  var uploadTime = -1;

  var finish = function finish(error, result) {
    logger.log({
      'event': 'info:default',
      'event_version': 'playlist_annotate_image_upload_data',
      'json_data': {
        'token_fetch_time': tokenTime,
        'image_upload_time': uploadTime,
        'token_request_error': tokenTime === -1,
        'image_upload_request_error': !!error
      }
    });

    callback(error, result);
  };

  var preToken = logger.performance.now();
  getToken(function (error, token) {
    if (error) return finish(error);

    tokenTime = logger.performance.now() - preToken;

    var xhr = new XMLHttpRequest();
    xhr.upload.addEventListener('progress', progressCallback, false);

    var preUpload = logger.performance.now();
    xhr.onreadystatechange = function () {
      if (xhr.readyState === 4) {
        uploadTime = logger.performance.now() - preUpload;

        if (xhr.status === 202) {
          var response = xhr.response;
          try {
            var jsonResponse = JSON.parse(response);
            if (jsonResponse.status === 'ok') {
              finish(null, jsonResponse.id);
            } else {
              finish({
                error: {
                  message: 'Unexpected response status',
                  detail: jsonResponse.status
                }
              });
            }
          } catch (exception) {
            finish({
              error: {
                message: 'Could not parse JSON response',
                detail: exception
              }
            });
          }
        } else {
          // manage error
          finish({
            error: {
              message: 'Unexpected response status',
              detail: xhr.status
            }
          });
        }
      }
    };

    xhr.open('POST', ENDPOINT, true);
    xhr.setRequestHeader('Content-Type', 'image/jpeg');
    xhr.setRequestHeader('Authorization', 'Bearer ' + token);
    xhr.send(file);
  });
};

function getToken(callback) {
  var uri = 'hm://keymaster/token/authenticated?scope=ugc-image-upload&' + 'alt=json&client_id=' + encodeURIComponent(CLIENT_ID);

  cosmos.resolver.get(uri, function (error, response) {
    if (error) return callback(error);

    callback(null, response.getJSONBody().accessToken);
  });
}

},{"../../../logging/playlist-annotate-logger":95,"spotify-cosmos-api":694}],154:[function(require,module,exports){
'use strict';

var async = require('async');
var session = require('../../models/session');
var controlMessagesHandler = require('../../controlmessageshandler');
var cosmos = require('spotify-cosmos-api');
var localSettings = require('../../models/localsettings');
var _ = require('../../../i18n').get;
var ClientEvent3 = require('../../../../../libs/spotify-logger/messages/ClientEvent3');

var LOGGER_SOURCE = 'terms_and_cond';

function TermsOfService() {
  this._acceptedLicenses = [];
  this._pendingLicenses = [];
  this._message = FIRST_MESSAGE;
  this._serverTime = 0;
  this._gracePeriodExpireTimestamp = 0;
  this._fetchedAsyncData = false;
}

TermsOfService.prototype.MODAL_TITLE = _('tos.updated_terms');
TermsOfService.prototype.MODAL_CLASS = 'default';
TermsOfService.prototype.HIGH_PRIORITY = true;
TermsOfService.prototype.AUTOFOCUS_OK_BUTTON = true;
TermsOfService.prototype.CAN_HIDE_BY_CLICKING_BACKGROUND = false;
TermsOfService.prototype.CAN_HIDE_BY_PRESSING_ESCAPE = false;
TermsOfService.prototype.EULA_URL = 'https://www.spotify.com/legal/end-user-agreement/';
TermsOfService.prototype.PRIVACY_URL = 'https://www.spotify.com/legal/privacy-policy/';

// Product state keys
var ACCEPTED_LICENSES_KEY = 'accepted_licenses';
var LICENSES_KEY = 'license-agreements';
var WANTED_LICENSES_KEY = 'wanted-licenses';
var LICENSE_GRACE_PERIOD_KEY = 'license-acceptance-grace-days';

var DAY = 24 * 60 * 60; // hours * mins * sec

var KEYSTORE_EXPIRE_DATE_KEY = 'expiration-time';

// Constants to identify which message should be displayed
// as in the case of the Not Now flow a second message can be displayed
// in the same modal
var FIRST_MESSAGE = 0;
var SECOND_MESSAGE = 1;

// Dynamic properties
Object.defineProperty(TermsOfService.prototype, 'OK_BUTTON_LABEL', {
  get: function get() {
    return _(this._message === FIRST_MESSAGE ? 'tos.agree_button_label' : 'tos.ok_button_label');
  }
});

Object.defineProperty(TermsOfService.prototype, 'CANCEL_BUTTON_LABEL', {
  get: function get() {
    var translationToken;
    if (this._canPostponeAcceptance()) {
      translationToken = this._message === FIRST_MESSAGE ? 'tos.not_now_button_label' : 'tos.back_button_label';
    } else {
      translationToken = 'tos.cancel_button_label';
    }

    return _(translationToken);
  }
});

Object.defineProperty(TermsOfService.prototype, 'CONTENT', {
  get: function get() {
    if (!this._fetchedAsyncData) {
      throw new Error('Data has not been fetched');
    }
    var contentNode = document.createElement('div');
    contentNode.innerHTML = this._canPostponeAcceptance() ? this._notNowContent() : _('tos.tos_text', this._versionedURL(this.EULA_URL), this._versionedURL(this.PRIVACY_URL));
    return contentNode;
  }
});

Object.defineProperty(TermsOfService.prototype, 'BUTTONS', {
  get: function get() {
    if (!this._fetchedAsyncData) {
      throw new Error('Data has not been fetched');
    }
    return {
      OK: true,
      // The cancel button is visible as a NOT NOW if the user can still
      // postpone the acceptance in the first message. But for German users
      // it's also displayed in the second message and can be used to take the
      // user back to the first message
      CANCEL: this._canPostponeAcceptance() && !this._gracePeriodExpired() && (this._message === FIRST_MESSAGE || this._isGermanUser())
    };
  }
});

TermsOfService.prototype.setup = function (modal, bridge) {
  this._bridge = bridge;
  this._modal = modal;

  var i;

  // There can be cases when by this point of the execution the license
  // agreements in product state are not updated since the last session
  // and the user might have already accepted the terms but they are still
  // not there.
  //
  // In order to circumvent that, we're also storing in localStorage when
  // the user accepts it and here we merge both localStorage and product
  // state data to make sure we have it all.
  var licenseAgreementsString = session.getProductState(LICENSES_KEY);
  this._acceptedLicenses = licenseAgreementsString ? licenseAgreementsString.split(',') : [];

  // Check if everything in localStorage is already in product state, if it is
  // we can remove it from localStorage
  var localStorageAcceptedLicenses = localSettings.get(ACCEPTED_LICENSES_KEY);
  if (localStorageAcceptedLicenses) {
    var localLicenses = localStorageAcceptedLicenses.split(',');
    var isSynced = true;

    // This is quadratic (indexOf = O(n)), and quadratic is usually bad.
    // But both arrays are really small (possibly just 1 or 2 elements each),
    // so get over it ;)
    for (i = 0; i < localLicenses.length; i++) {
      if (this._acceptedLicenses.indexOf(localLicenses[i]) === -1) {
        isSynced = false;
        this._acceptedLicenses.push(localLicenses[i]);
      }
    }

    if (isSynced) {
      // There's no point in keeping this info in local storage, since
      // the local copy of product state seems to be updated
      localSettings.delete(ACCEPTED_LICENSES_KEY);
    }
  }

  var wantedLicensesString = session.getProductState(WANTED_LICENSES_KEY);
  var wantedLicenses = wantedLicensesString ? wantedLicensesString.split(',') : [];

  for (i = 0; i < wantedLicenses.length; i++) {
    if (this._acceptedLicenses.indexOf(wantedLicenses[i]) === -1) {
      this._pendingLicenses.push(wantedLicenses[i]);
    }
  }

  if (this._pendingLicenses.length > 0) {
    // Fetch all the needed data (async) before calling the display method
    // to avoid callback hell and inconsistencies, as some fields like the
    // popup content cannot be changed after it's visible
    var self = this;
    this._fetchAllAsyncData(function () {
      // send a client event that informs that the user viewed the license
      ClientEvent3.log({
        event: 'alert:presented',
        source: LOGGER_SOURCE
      });
      self._modal.display(self);
    });
  }
};

TermsOfService.prototype.onOk = function (callback) {
  if (this._message === SECOND_MESSAGE) {
    // In case of the second message, just hide the modal
    this._modal.hide();
    return;
  }

  // send a client event that informs that the user accepted the license
  ClientEvent3.log({
    event: 'alert:accept:tap',
    source: LOGGER_SOURCE
  });

  this._acceptedLicenses = this._acceptedLicenses.concat(this._pendingLicenses);
  var acceptedLicensesString = this._acceptedLicenses.join(',');
  // If the call is successful, we want to save a local copy of the licenses
  // to handle possible inconsistencies on the native side for the next offline
  // login, when product state will probably not be updated.
  //
  // This should be fixed by native, making sure that product state settings
  // cache is invalidated locally when we write to it
  var self = this;
  var callbackWrapper = function callbackWrapper() {
    localSettings.set(ACCEPTED_LICENSES_KEY, acceptedLicensesString);
    self._cleanupGracePeriodExpireTimestamp();
    if (callback) {
      callback();
    }
  };
  this._bridge.request('preferences_set', ['ps.' + LICENSES_KEY, acceptedLicensesString], this, callbackWrapper, function (err) {
    console.error('Error accepting T&C', err);
  });
};

TermsOfService.prototype.onCancel = function () {
  if (this._canPostponeAcceptance()) {
    if (this._message === FIRST_MESSAGE) {
      // User pressed the "Not now" button
      this._setGracePeriodExpireTimestamp();

      // send a client event that informs that the user clicked on not now
      ClientEvent3.log({
        event: 'alert:notnow:tap',
        source: LOGGER_SOURCE
      });

      // Display text about the 30 days for the "Not now" action
      this._message = SECOND_MESSAGE;
    } else {
      // The cancel Button in the second message triggers the action to go back
      // to the first message
      this._message = FIRST_MESSAGE;
    }
    this._modal.render(this);
  } else {
    // The free user doesn't agree with the terms, therefore cannot use
    // the service
    controlMessagesHandler.send({ type: 'shutdown' });
  }
};

/**
 * Server timestamp when it was fetched
 */
TermsOfService.prototype._currentServerTime = function () {
  // This will of course get stale, but it shouldn't be a big issue
  // and will make things simpler and avoid callback hell
  return this._serverTime;
};

/**
 * Get the current timestamp from the Access point
 */
TermsOfService.prototype._fetchServerTime = function (callback) {
  var self = this;
  cosmos.resolver.get('sp://desktop/v1/server_time', function (err, data) {
    var currentServerTime;
    if (!err) {
      currentServerTime = data.getJSONBody().server_time;
    }

    if (!currentServerTime) {
      // Request failed or server time returned 0;
      currentServerTime = Math.round(Date.now() / 1000);
    }
    self._serverTime = currentServerTime;
    callback(err, currentServerTime);
  });
};

TermsOfService.prototype._generateExpireTimestamp = function () {
  return this._currentServerTime() + this._gracePeriodDurationInSeconds();
};

/**
 * Store the grace period expire date in the keystore
 */
TermsOfService.prototype._setGracePeriodExpireTimestamp = function () {
  if (!this._fetchedAsyncData) {
    throw new Error('Data has not been fetched');
  }
  // Don't store a new date if there's already one there
  if (this._getGracePeriodExpireTimestamp()) return;

  var body = {};
  body[KEYSTORE_EXPIRE_DATE_KEY] = this._generateExpireTimestamp();

  var req = new cosmos.Request(cosmos.Action.PUT, this._keystoreServiceURI(), {}, body);

  cosmos.resolver.resolve(req, function (err) {
    if (err) {
      console.error('Couldn\'t save the expire timestamp');
    }
  });
};

/**
 * Remove the stored timestamp
 */
TermsOfService.prototype._cleanupGracePeriodExpireTimestamp = function () {
  if (!this._fetchedAsyncData) {
    throw new Error('Data has not been fetched');
  }

  var body = {};
  body[KEYSTORE_EXPIRE_DATE_KEY] = 0;

  var req = new cosmos.Request(cosmos.Action.PUT, this._keystoreServiceURI(), {}, body);

  cosmos.resolver.resolve(req, function (err) {
    if (err) {
      console.error('Couldn\'t save the expire timestamp');
    }
  });
};

/**
 * Fetches the expire timestamp from the keystore
 */
TermsOfService.prototype._getGracePeriodExpireTimestamp = function () {
  if (!this._fetchedAsyncData) {
    throw new Error('Data has not been fetched');
  }
  return this._gracePeriodExpireTimestamp;
};

TermsOfService.prototype._fetchGracePeriodExpireTimestamp = function (callback) {
  var self = this;
  cosmos.resolver.get(this._keystoreServiceURI(), function (err, response) {
    self._gracePeriodExpireTimestamp = 0;
    if (!err) {
      var data = response.getJSONBody() || {};
      self._gracePeriodExpireTimestamp = parseInt(data[KEYSTORE_EXPIRE_DATE_KEY] || 0, 10);
    }
    callback(null, self._gracePeriodExpireTimestamp);
  });
};

TermsOfService.prototype._gracePeriodDurationInSeconds = function () {
  return session.getProductState(LICENSE_GRACE_PERIOD_KEY) * DAY;
};

TermsOfService.prototype._keystoreServiceURI = function () {
  return 'hm://tac/user/' + session.getUsername() + '/columns';
};

TermsOfService.prototype._fetchAllAsyncData = function (callback) {
  var self = this;
  async.parallel([this._fetchServerTime.bind(this), this._fetchGracePeriodExpireTimestamp.bind(this)], function (err) {
    self._fetchedAsyncData = !err;
    callback(err);
  });
};

TermsOfService.prototype._isGermanUser = function () {
  return session.getProductState('country_code') === 'DE';
};

TermsOfService.prototype._canPostponeAcceptance = function () {
  return session.isPremium() || this._isGermanUser();
};

/**
 * Returns if the user has clicked the "Not now" button and 30 days has passed
 * @return boolean
 */
TermsOfService.prototype._gracePeriodExpired = function () {
  return this._daysRemaining() <= 0;
};

/**
 * Calculate the number of remaining days in the grace period
 */
TermsOfService.prototype._daysRemaining = function () {
  if (!this._fetchedAsyncData) {
    throw new Error('Data has not been fetched');
  }
  var now = this._currentServerTime();
  var expire = this._getGracePeriodExpireTimestamp();
  var remainingSecs;
  if (expire) {
    remainingSecs = expire - now;
  } else {
    remainingSecs = this._gracePeriodDurationInSeconds();
  }
  return Math.ceil(remainingSecs / DAY);
};

TermsOfService.prototype._notNowContent = function () {
  return this._isGermanUser() ? this._germanContent() : this._internationalContent();
};

TermsOfService.prototype._germanContent = function () {
  var text;
  if (this._gracePeriodExpired()) {
    text = _('tos.not_now_expired_text_germany', this._versionedURL(this.EULA_URL), this._versionedURL(this.PRIVACY_URL)) + _('tos.tos_text2');
  } else {
    var options = {
      weekday: 'long',
      year: 'numeric',
      month: 'long',
      day: 'numeric'
    };

    var expireInMillisecs = (this._getGracePeriodExpireTimestamp() || this._generateExpireTimestamp()) * 1000;

    var formattedDate = new Date(expireInMillisecs).toLocaleDateString(session.get('locale'), options);

    if (this._message === FIRST_MESSAGE) {
      text = _('tos.not_now_text_germany', this._versionedURL(this.EULA_URL), this._versionedURL(this.PRIVACY_URL), formattedDate);
    } else {
      text = _('tos.not_now_text2_germany', formattedDate, this._versionedURL(this.EULA_URL), this._versionedURL(this.PRIVACY_URL));
    }
  }
  return text;
};

TermsOfService.prototype._internationalContent = function () {
  var text;
  if (this._message === SECOND_MESSAGE) {
    if (this._daysRemaining() === 1) {
      // Singular
      text = _('tos.not_now_last_day_text');
    } else {
      text = _('tos.not_now_text', this._daysRemaining());
    }
  } else {
    text = _('tos.not_now_tos_text', this._versionedURL(this.EULA_URL), this._versionedURL(this.PRIVACY_URL)) + (this._gracePeriodExpired() ? _('tos.tos_text2') : '');
  }

  return text;
};

TermsOfService.prototype._versionedURL = function (baseUrl) {
  var separator = baseUrl.indexOf('?') === -1 ? '?' : '&';
  return baseUrl + (this._pendingLicenses.length > 0 ? separator + 'version=' + this._pendingLicenses[0] : '');
};

module.exports = TermsOfService;

},{"../../../../../libs/spotify-logger/messages/ClientEvent3":451,"../../../i18n":11,"../../controlmessageshandler":74,"../../models/localsettings":100,"../../models/session":107,"async":502,"spotify-cosmos-api":694}],155:[function(require,module,exports){
(function (global){
'use strict';

var eventDispatcher = require('../../../../libs/spotify-event-dispatcher');
var keyboard = require('../keyboard');
var Event = require('../event');
var center = require('../../../../libs/spotify-events/center');
var itemTemplate = require('../../../../libs/spotify-glue-cat/templates/v1/navbar-overflow-item.hbs');

/**
 * Navbar overflow menu for the app to request via postMessage
 *
 * @constructor
 */
function NavbarOverflow() {
  var self = this;

  this.sourceWindow = null;
  this.menuItems = null;
  this.container = null;
  this.menu = null;

  keyboard.registerImportantShortcut(keyboard.KEYS.ESCAPE, function (e) {
    if (self.container) {
      e.preventDefault();
      self.hide();
    }
  });
}

/**
 * Setup functionality
 *
 * @return {NavbarOverflow} The instance.
 */
NavbarOverflow.prototype.setup = function () {
  var self = this;

  global.window.addEventListener('message', this.onMessage.bind(this));
  eventDispatcher.addEventListener(Event.TYPES.NAVIGATION_OPEN_URI, function () {
    self.hide();
  });
  center.on('menu-activate-item', this.onCenterEvent.bind(this));

  this.container = document.querySelector('#view-navbar-overflow');
  this.menu = this.container && this.container.querySelector('[data-menu]');
  return this;
};

NavbarOverflow.prototype._NavbarOverflowPopoverId = 'navbar-overflow';

NavbarOverflow.prototype.onMessage = function (event) {
  if (!event || !event.data || !event.data.type) {
    return;
  }

  if (event.data.type === 'hide-navbar-overflow') {
    this.hide();
  } else if (event.data.type === 'show-navbar-overflow') {
    this.sourceWindow = event.source;
    var items = event.data.items;
    var template = items.reduce(function (prev, item) {
      if (item.active) {
        item.className = 'active';
      }

      return prev + itemTemplate(item);
    }, '');

    // If the event comes from an iframe, handle the event position as relative
    // to the position of the iframe (and all parents).
    var offsetX = 0;
    var offsetY = 0;
    var frameWalk = this.sourceWindow;
    while (frameWalk.frameElement) {
      var bounds = frameWalk.frameElement.getBoundingClientRect();
      offsetX += bounds.left;
      offsetY += bounds.top;
      frameWalk = frameWalk.parent;
    }

    var right = event.data.right + offsetX;
    var top = event.data.top + offsetY;

    var positionFromRight = document.documentElement.offsetWidth - right;

    this.menu.style.position = 'absolute';
    this.menu.style.right = positionFromRight + 'px';
    this.menu.style.top = top + 'px';
    this.menu.innerHTML = template;
    this.container.style.display = 'block';
    this.menu.focus();

    eventDispatcher.dispatchEvent(new Event(Event.TYPES.POPOVER_OPENED, { id: this._NavbarOverflowPopoverId }));
  }
};

NavbarOverflow.prototype.onCenterEvent = function (event) {
  if (!event.menu || event.menu.id !== 'navbar-overflow' || !event.item || !event.item.element) {
    return;
  }

  var itemId = event.item.element.getAttribute('data-navbar-item-id');

  if (itemId && this.sourceWindow) {
    this.sourceWindow.postMessage({
      name: 'navbar-overflow-click',
      itemId: itemId
    }, '*');
  }

  this.hide();
};

NavbarOverflow.prototype.onClickBackdrop = function () {
  this.hide();
};

NavbarOverflow.prototype.hide = function () {
  if (this.sourceWindow) {
    this.sourceWindow.postMessage({
      name: 'hide-navbar-overflow'
    }, '*');
  }

  if (this.container) {
    this.container.style.display = 'none';

    eventDispatcher.dispatchEvent(new Event(Event.TYPES.POPOVER_CLOSED, { id: this._NavbarOverflowPopoverId }));
  }
};

module.exports = NavbarOverflow;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../../../libs/spotify-event-dispatcher":264,"../../../../libs/spotify-events/center":268,"../../../../libs/spotify-glue-cat/templates/v1/navbar-overflow-item.hbs":352,"../event":77,"../keyboard":83}],156:[function(require,module,exports){
'use strict';

var ko = require('knockout');
var $ = require('../../../../libs/spotify-elements');
var center = require('../../../../libs/spotify-events/center');
var glue = require('../../../../libs/spotify-glue-cat');
var Event = require('../event');
var PlaylistModel = require('../models/playlist');
var Keyboard = require('../keyboard');
var MenuItem = require('../components/menuitem');
var DROP_MIME_TYPES = require('../mimetypes');
var _ = require('../../i18n').get;
var eventDispatcher = require('../../../../libs/spotify-event-dispatcher');
var NewPlaylistVM = require('./newplaylist');
var Playlists = require('../components/playlists');
var URIHelper = require('../urihelper');
var util = require('../live-models/util');
var live = require('../../../../libs/spotify-live');
var session = require('../models/session');
var liburi = require('spotify-liburi');

var getPlaylistNameForItems = require('../../../../libs/spotify-live-get-playlist-name-for-items');

var abba = require('../../../../libs/spotify-abba-mini');
var UIInteraction4 = require('../../../../libs/spotify-logger/messages/UIInteraction4');
var ensuredMessage = require('../../../../libs/spotify-ensured-cosmos-message');

/**
 * View Model for the navigation area.
 *
 * @param {Router} router The router to use.
 * @constructor
 */
function NavigationBar(router) {
  /**
   * The router to use
   *
   * @type {Router}
   */
  this._router = router;

  this._newPlaylistVM = new NewPlaylistVM(this);
  this.createPlaylist = this.createPlaylist.bind(this);

  this.sections = ko.observableArray();
  this.playing = ko.observable();
  this.active = ko.observable();

  this.isGlue2 = glue.getVersion() === 2;
  this.scrollAreaId = this.isGlue2 ? 'app-sidebar' : false;
  this.showTopBorder = ko.observable(false);
  this.topBorderPosition = ko.observable('0px');

  this.playlists = {
    id: 'menu-playlists',
    label: _('sidebar.title_playlists'),
    items: ko.observableArray([])
  };

  this._activePlaylist = null;
  this._currentlyPlaying = null;
  this._waitingForItemSwitch = false;
}

NavigationBar.prototype.NAVIGATION_LABEL = _('navigation.label');

/**
 * Setup functionality
 *
 * @return {NavigationBar} The instance.
 */
NavigationBar.prototype.setup = function () {
  this._initEventListeners();
  this._initAppsSection();
  this._initCollectionSection();
  this._initPlaylists();
  this._registerKeyboardNavigation();

  Playlists.init();

  return this;
};

NavigationBar.prototype._initEventListeners = function () {
  this._element = document.getElementById('view-navigation-bar');

  // Handle drop targets
  center.on('drop', this.onDrop.bind(this));

  var self = this;
  $('#view-navigation-bar').delegate('dblclick', '#menu-item-collection-local-files', function (evt) {
    evt.preventDefault();
    self._onLocalFilesDoubleClick();
  });

  $('#view-navigation-bar').delegate('dblclick', '#menu-item-collection-tracks', function (evt) {
    evt.preventDefault();
    self._onYourMusicSongsDoubleClick();
  });

  $('#view-navigation-bar').delegate('click', ['#menu-item-collection-local-files button', '#menu-item-collection-tracks button'].join(','), function (evt) {
    evt.preventDefault();
    live('spotify:player').emit('pause');
  });

  eventDispatcher.addEventListener(Event.TYPES.NAVIGATION_STATE_CHANGE, this.onStateChange.bind(this));
};

/**
 * Adds the buttons to the main apps
 */
NavigationBar.prototype._initAppsSection = function () {
  var apps = ko.observableArray([new MenuItem(_('browse.app_name'), 'spotify:app:browse', {
    activeRegexp: /spotify:app:(browse|genre|discover|charts|concerts|hub)/
  })]);

  if (session.getProductState('ab-remove-activity') !== '1') {
    apps.push(new MenuItem(_('activity.app_name'), 'spotify:app:social-feed', { icon: 'follow' }));
  }

  abba.subscribe('new-markets-hide-radio', function (err, cell) {
    if (err || cell !== 'Enabled') {
      var radioAppUri = 'spotify:app:radio-hub';
      var radioMenuItem = new MenuItem(_('radio.app_name'), radioAppUri, {
        dropTargetTypes: [DROP_MIME_TYPES.TRACKS, DROP_MIME_TYPES.ALBUMS, DROP_MIME_TYPES.ARTISTS, DROP_MIME_TYPES.PLAYLISTS],
        icon: 'radio',
        menuItemId: 'radio',
        noListTarget: true
      });
      var spliceNumber = apps()[2] && apps()[2].title() === _('radio.app_name') ? 1 : 0;
      apps.splice(2, spliceNumber, radioMenuItem);
    }

    // adding artists section here so position and order is guaranteed
    this._initYourArtistsSection();
  }.bind(this));

  this.sections.push({
    id: 'menu-apps',
    label: _('sidebar.title_main'),
    items: apps
  });
};

NavigationBar.prototype._initYourArtistsSection = function () {
  session.getArtistAsync(function (artistData) {
    if (!artistData || !artistData.results || !artistData.results.length) return;

    this.sections.splice(1, 0, {
      id: 'menu-your-artists',
      label: _('yourArtists'),
      items: ko.observableArray(createMenuItems())
    });

    function createMenuItems() {
      return artistData.results.map(function (data) {
        var uri = liburi.from(data.uri);

        var base62 = liburi.hexToId(uri.id);
        return new MenuItem(data.name, data.uri, {
          template: {
            name: 'menu-item',
            afterRender: function afterRender(menuItems) {
              var node = menuItems[0].parentNode;
              var boundingRect = node.getBoundingClientRect();
              eventDispatcher.dispatchEvent(new Event(Event.TYPES.SHOW_YOUR_ARTISTS_TOOLTIP, {
                top: boundingRect.top + boundingRect.height / 2,
                left: boundingRect.right
              }));
              UIInteraction4.log({
                feature_id: live('spotify:application').get('appURI') || 'unknown',
                section_id: 'sidebar',
                interaction_type: 'click',
                user_intent: 'click-your-artist',
                timestamp: Date.now(),
                target_uri: data.uri
              });
            }
          },
          icon: 'artist',
          uri: data.uri,
          activeRegexp: new RegExp('^spotify:(app:artist|artist):' + base62)
        });
      });
    }
  }.bind(this));
};

/**
 * Adds the buttons to My Music if the user has the feature enabled
 */
NavigationBar.prototype._initCollectionSection = function () {
  var username = session.getUsername();
  var songsUri = liburi.collectionURI(username).toURI();
  var yourMusicApps = ko.observableArray([new MenuItem(_('your_music.songs'), 'spotify:app:collection-songs', {
    icon: 'track',
    menuItemId: 'collection-tracks',
    noListTarget: true,
    isContext: true,
    uri: songsUri,
    dropTargetTypes: [DROP_MIME_TYPES.TRACKS]
  }), new MenuItem(_('your_music.albums'), 'spotify:app:collection:albums', {
    icon: 'album-contained',
    menuItemId: 'collection-albums',
    dropTargetTypes: [DROP_MIME_TYPES.ALBUMS],
    activeRegexp: /^spotify:app:(collection:albums|collection-album)/
  }), new MenuItem(_('your_music.artists'), 'spotify:app:collection:artists', {
    icon: 'artist',
    menuItemId: 'collection-artists',
    dropTargetTypes: [DROP_MIME_TYPES.ARTISTS],
    activeRegexp: /^spotify:app:(collection:artists|collection-artist)/
  })]);

  if (session.get('platform') === 'desktop') {
    // ZoW users don't get local files
    yourMusicApps.push(new MenuItem(_('your_music.local_files'), 'spotify:app:playlist-desktop:local-files', {
      icon: 'localfile',
      menuItemId: 'collection-local-files',
      uri: 'spotify:internal:local-files',
      isContext: true
    }));
  }

  abba.subscribe('ab-latest-releases', function (err, cell) {
    if (err) return;

    if (cell === 'latest-releases') {
      yourMusicApps.push(new MenuItem(_('latest-releases.app_name'), 'spotify:app:latest-releases', { icon: 'released' }));
    } else {
      var lastIndex = yourMusicApps().length - 1;
      var hasLatestReleases = yourMusicApps()[lastIndex].href() === 'spotify:app:latest-releases';
      if (hasLatestReleases) {
        yourMusicApps.splice(lastIndex, 1);
      }
    }
  });

  abba.subscribe('new-markets-hide-radio', function (err, cell) {
    var item4 = yourMusicApps()[3];
    var stationsTitle = _('your_music.stations');
    if (err || cell !== 'Enabled') {
      if (item4 && item4.title() === stationsTitle) return;
      yourMusicApps.splice(3, 0, new MenuItem(stationsTitle, 'spotify:app:stations', {
        icon: 'radio',
        menuItemId: 'stations',
        dropTargetTypes: [DROP_MIME_TYPES.STATIONS],
        noListTarget: true
      }));
    } else {
      if (item4 && item4.title() === stationsTitle) {
        yourMusicApps.splice(3, 1);
      }
    }
  });

  this.sections.push({
    id: 'menu-your-music',
    label: _('your_music.app_name'),
    items: yourMusicApps
  });
};

/**
 * Fetch the playlists and populates the menu
 */
NavigationBar.prototype._initPlaylists = function () {
  this.sections.push(this.playlists);
};

NavigationBar.prototype._onLocalFilesDoubleClick = function () {
  ensuredMessage.send('local-files-play');
};

NavigationBar.prototype._onYourMusicSongsDoubleClick = function () {
  ensuredMessage.send('your-music-songs-play');
};

/**
 * Register handlers for keyboard navigation within the navigation bar.
 * This inclues arrow keys up and down, but also left and right for expanding
 * and contracting playlist folders.
 */
NavigationBar.prototype._registerKeyboardNavigation = function () {
  var self = this;

  Keyboard.registerIsolatedShortcut({
    key: Keyboard.KEYS.ARROW_UP
  }, this._element, function (e) {
    e.preventDefault();
    self._moveActiveSelection('up');
  });

  Keyboard.registerIsolatedShortcut({
    key: Keyboard.KEYS.ARROW_DOWN
  }, this._element, function (e) {
    e.preventDefault();
    self._moveActiveSelection('down');
  });

  Keyboard.registerIsolatedShortcut({
    key: Keyboard.KEYS.ARROW_LEFT
  }, this._element, function (e) {
    e.preventDefault();
    self._handleFolderExpansion('left');
  });

  Keyboard.registerIsolatedShortcut({
    key: Keyboard.KEYS.ARROW_RIGHT
  }, this._element, function (e) {
    e.preventDefault();
    self._handleFolderExpansion('right');
  });

  document.addEventListener('keyup', this._onKeyUp.bind(this), false);
};

/**
 * Run the handler function only if zlink has focus.
 *
 * @param {Function} handler The handler function.
 */
NavigationBar.prototype._checkFocus = function (handler) {
  var tagName = document.activeElement.tagName.toLowerCase();
  var isAppFocused = tagName === 'iframe';
  if (isAppFocused) return;

  handler();
};

/**
 * Get the index of the currently active navigation item inside the passed
 * array.
 *
 * @param {Array.<HTMLElement>} items Array of DOM nodes for menu items.
 *
 * @return {number} The index, or -1 if not found.
 */
NavigationBar.prototype._getActiveElementIndex = function (items) {
  var uri = this.active();
  var playlistUri;
  try {
    playlistUri = URIHelper.realPlaylistURI(uri);
  } catch (error) {
    playlistUri = uri;
  }

  if (!playlistUri) return -1;

  var activeItemElement = $('[data-sidebar-item="' + playlistUri + '"]');

  if (activeItemElement) {
    activeItemElement = activeItemElement[0];

    for (var i = 0, l = items.length; i < l; i++) {
      if (items[i] === activeItemElement) {
        return i;
      }
    }
  }

  return -1;
};

/**
 * Move the active selection up or down to the next item.
 *
 * @param {string} direction The direction, 'up' or 'down'.
 */
NavigationBar.prototype._moveActiveSelection = function (direction) {
  var items = $('[data-sidebar-item]');
  if (!items) return;

  var activeIndex = this._getActiveElementIndex(items);
  if (activeIndex === -1) return;

  var item;
  var newIndex = activeIndex;
  while (!item && newIndex >= 0 && newIndex < items.length) {
    newIndex = newIndex + (direction === 'up' ? -1 : 1);
    item = items[newIndex];

    // Step further if the item is hidden (folder end marker or hidden content
    // inside a folder).
    if (item && item.getBoundingClientRect().height === 0) {
      item = null;
    }
  }
  if (!item) return;

  var uri = item.getAttribute('data-sidebar-item');
  if (!uri) return;

  this.setActiveItem(uri, item);
  this._waitingForItemSwitch = true;
};

/**
 * Move the active selection up to the next parent folder.
 */
NavigationBar.prototype._moveActiveSelectionToParent = function () {
  var items = $('[data-sidebar-item]');
  if (!items) return;

  var activeIndex = this._getActiveElementIndex(items);
  if (activeIndex === -1) return;

  var folders = 0;

  var item;
  var newIndex = activeIndex;
  var uri;
  var uriObject;
  while (!item && newIndex >= 0 && newIndex < items.length) {
    item = items[--newIndex];

    if (item) {
      uri = item.getAttribute('data-sidebar-item');
      uriObject = liburi.from(uri);
      if (uriObject && uriObject.type === liburi.Type.FOLDER) {
        if (/:end$/.test(uri)) {
          folders++;
        } else if (folders === 0) {
          break;
        } else {
          folders--;
        }
      }
      uri = null;
      item = null;
    }
  }

  if (!uri) return;

  this.setActiveItem(uri, item);
  this._waitingForItemSwitch = true;
};

/**
 * Move the active selection up to the next parent folder.
 */
NavigationBar.prototype._moveActiveSelectionToFirstChild = function () {
  var items = $('[data-sidebar-item]');
  if (!items) return;

  var activeIndex = this._getActiveElementIndex(items);
  if (activeIndex === -1) return;

  var currentItem = items[activeIndex];
  var currentUri = currentItem.getAttribute('data-sidebar-item');
  var uriObject = liburi.from(currentUri);

  if (uriObject.type !== liburi.Type.FOLDER) {
    return;
  }

  var newItem = items[activeIndex + 1];
  var newUri;
  if (newItem) {
    newUri = newItem.getAttribute('data-sidebar-item');

    if (/:end$/.test(newUri)) {
      // Empty folder
      return;
    }
  }

  if (!newUri) return;

  this.setActiveItem(newUri, newItem);
  this._waitingForItemSwitch = true;
  this._openActiveItem();
};

/**
 * Open the currently active menu item in the main view.
 */
NavigationBar.prototype._openActiveItem = function () {
  var activeUri = this.active();

  eventDispatcher.dispatchEvent(new Event(Event.TYPES.NAVIGATION_OPEN_URI, activeUri));
};

/**
 * Request to open the currently active menu item in the main view.
 * This is throttled, so it will not open it immediately, but 10 requests to
 * open the active item in a short amount of time will open just one item, which
 * is the active item after a timeout.
 */
NavigationBar.prototype._openActiveItemThrottled = function () {
  clearTimeout(this._openTimeout);
  var self = this;
  this._openTimeout = setTimeout(function () {
    self._openActiveItem();
  }, 100);
};

/**
 * Handle the expansion or contraction of folders based on a direction of the
 * arrow keys. If the current item is a contracted folder or a playlist, 'left'
 * will move the selection to the parent folder. If the current item is an
 * expanded folder, 'left' will contract the folder. If it is a contracted
 * folder, 'right' will expand the folder.
 *
 * @param {string} direction The direction, 'left' or 'right'.
 */
NavigationBar.prototype._handleFolderExpansion = function (direction) {
  var uri = this.active();
  var playlistUri;
  try {
    playlistUri = URIHelper.realPlaylistURI(uri);
  } catch (error) {
    playlistUri = uri;
  }
  if (!playlistUri) return;

  var isFolder = liburi.fromString(playlistUri).type === liburi.Type.FOLDER;

  if (isFolder) {
    var row = live(util.getRowUri(playlistUri));
    var expanded = row.get('expanded');
    var newValue = direction === 'right';
    if (expanded !== newValue) {
      row.publish({ expanded: newValue });
      return;
    }
  }

  if (direction === 'left') {
    this._moveActiveSelectionToParent();
  }
  if (direction === 'right') {
    this._moveActiveSelectionToFirstChild();
  }
};

/**
 * Handle when any key is released.
 * This will open the currently active item if we haven't done so yet. We are
 * delaying opening of active items until the key is released, to not load tons
 * of apps and slowing things down while keeping the arrow key pressed down.
 *
 * @param {KeyboardEvent} event A keyboard event object.
 */
NavigationBar.prototype._onKeyUp = function (event) {
  // Only handle the event if the currently focused element is inside the
  // navigation bar.
  if (this._element.contains(document.activeElement)) {
    var key = event.keyCode;
    var isUp = key === Keyboard.KEYS.ARROW_UP;
    var isDown = key === Keyboard.KEYS.ARROW_DOWN;
    var isLeft = key === Keyboard.KEYS.ARROW_LEFT;

    if ((isUp || isDown || isLeft) && this._waitingForItemSwitch) {
      this._waitingForItemSwitch = false;
      this._openActiveItemThrottled();
    }
  }
};

/**
 * Updates the state of the menu every time the state of the app
 * changes, to avoid inconsistencies when there's navigation between apps
 * withouth using the menu
 */
NavigationBar.prototype.onStateChange = function (e) {
  var uri = e.params.uri;

  if (this._router.isHistoryBlackListed(uri)) {
    return;
  }

  // We wish to navigate (scroll) to the soon-to-be active item
  // as long as we're able to find it in the DOM. So we try with playlists
  // and fall back to app URIs
  try {
    uri = URIHelper.realPlaylistURI(uri);
  } catch (e) {
    uri = uri;
  }
  var item = document.querySelector('[data-sidebar-item="' + uri + '"]');

  this.setActiveItem(uri, item);
};

/**
 * Set the active item in model state, which will trigger visual updates in the
 * navigation bar. This does NOT navigate the main view to the item.
 *
 * @param {string} uri The URI of the item.
 * @param {HTMLElement=} node Optional DOM node for the item. If provided, the
 *     node will be scrolled into view.
 */
NavigationBar.prototype.setActiveItem = function (uri, node) {
  if (typeof uri !== 'string') return;

  var self = this;

  this.active(uri);

  live(this._activePlaylist).update({
    active: false
  });

  live('spotify:rootlist').update({ activeRow: null });

  var entityUri = uri;

  var isPlaylistApp = URIHelper.appName(uri) === 'playlist-desktop';
  var isFolderApp = URIHelper.appName(uri) === 'playlist-folder';
  var isChartApp = URIHelper.appName(uri) === 'chart';

  if (isPlaylistApp || isFolderApp || isChartApp) {
    try {
      entityUri = URIHelper.realPlaylistURI(uri);
    } catch (err) {
      // Do nothing. It's using the initial uri
    }
  }

  if (entityUri) {
    var setPlaylistAsActive = function setPlaylistAsActive(uri) {
      var rowUri = util.getRowUri(uri);

      if (rowUri) {
        live('spotify:rootlist').update({
          activeRow: { uri: rowUri }
        });

        live(rowUri).update({
          active: true
        });

        self._activePlaylist = rowUri;
        return true;
      }

      live('spotify:rootlist').update({ activeRow: null });

      return false;
    };

    var didSet = setPlaylistAsActive(entityUri);

    if (!didSet) {
      var frozenActivePlaylist = this._activePlaylist;
      live('spotify:rootlist').get('loaded', function (error, loaded) {
        if (loaded && frozenActivePlaylist === self._activePlaylist) {
          setPlaylistAsActive(entityUri);
        }
      });
    }
  }

  // Scroll the item node into view if not in view already
  if (node) {
    var rowUriModel = live(util.getRowUri(uri));

    if (rowUriModel && rowUriModel.get('hidden')) {
      // Now we need to wait for update the folders to expand
      // up to the point where our playlist is visible
      // Otherwise the scrolling won't be able to find it
      // Note that the rootlist live-model will handle the folder
      // expansions for us.
      rowUriModel.on('update', function waitForUnhide(changes) {
        if (!('hidden' in changes)) return;
        rowUriModel.off('update', waitForUnhide);

        self._scrollToNode(node);
      });
    } else {
      // If it is not hidden, we can just scroll
      this._scrollToNode(node);
    }
  }
};

NavigationBar.prototype._scrollToNode = function (node) {
  var sidebar = document.getElementById('view-navigation-bar');
  if (sidebar) {
    var sidebarTop = sidebar.getBoundingClientRect().top;
    var sidebarHeight = sidebar.offsetHeight;
    var nodeTop = node.getBoundingClientRect().top - sidebarTop;
    var nodeBottom = nodeTop + node.offsetHeight;
    if (nodeTop <= 0 || nodeBottom >= sidebarHeight) {
      node.scrollIntoView(nodeTop <= 0);
    }
  }
};

/**
 * Handle drop targets.
 *
 * @param {Object} event Event object.
 */
NavigationBar.prototype.onDrop = function (event) {
  var uriNode = event.node.closest('[data-uri]');
  var uri = uriNode && uriNode.getAttribute('data-uri');
  var uriType;
  if (uri) {
    var uriObject = liburi.fromString(uri);
    if (uriObject) {
      uriType = uriObject.type;
    }
  }

  var isFolder = uriType === liburi.Type.FOLDER;
  var isPlaylist = uriType === liburi.Type.PLAYLIST;

  var node = event.node;
  while (node && !node.id && node.parentNode) {
    node = node.parentNode;
  }

  var isRadio = node.id === 'menu-item-radio';
  var isCollection = ['menu-item-collection-tracks', 'menu-item-collection-albums', 'menu-item-collection-artists', 'menu-item-stations'].indexOf(node.id) !== -1;
  var isNewPlaylist = node.id === 'view-new-playlist';

  if (isNewPlaylist) {
    this.onDropNewPlaylist(event);
  } else if (isRadio) {
    this.onDropRadio(event);
  } else if (isPlaylist) {
    this.onDropPlaylist(event);
  } else if (isFolder) {
    this.onDropFolder(event);
  } else if (isCollection) {
    this.onDropCollection(event);
  }
};

NavigationBar.prototype.logDropIntent = function (intent) {
  UIInteraction4.log({
    feature_id: live('spotify:application').get('appURI') || 'unknown',
    section_id: 'sidebar',
    interaction_type: 'drop',
    user_intent: intent,
    timestamp: Date.now()
  });
};

/**
 * Handle playlist drop targets.
 *
 * @param {Object} event Event object.
 */
NavigationBar.prototype.onDropPlaylist = function (event) {
  var playlistURI = event.node.closest('[data-uri]').getAttribute('data-uri');
  var albumURIs;
  var trackURIs;

  if (DROP_MIME_TYPES.ALBUMS in event.data) {
    albumURIs = event.data[DROP_MIME_TYPES.ALBUMS];
    PlaylistModel.addAlbums(playlistURI, albumURIs);
    this.logDropIntent('add-albums-to-playlist');
  }

  if (DROP_MIME_TYPES.TRACKS in event.data) {
    trackURIs = event.data[DROP_MIME_TYPES.TRACKS];
    PlaylistModel.addTracks(playlistURI, trackURIs);
    this.logDropIntent('add-tracks-to-playlist');
  }
};

/**
 * Handle folder drop targets.
 *
 * @param {Object} event Event object.
 */
NavigationBar.prototype.onDropFolder = function (event) {
  var folderIndex = +event.node.closest('[data-index]').getAttribute('data-index');
  var index = folderIndex + 1;

  if (DROP_MIME_TYPES.ALBUMS in event.data) {
    var albumURIs = event.data[DROP_MIME_TYPES.ALBUMS];
    this.addAlbumsToNewPlaylist(albumURIs, index);
    this.logDropIntent('add-albums-to-folder');
  }

  if (DROP_MIME_TYPES.TRACKS in event.data) {
    var trackURIs = event.data[DROP_MIME_TYPES.TRACKS];
    this.addTracksToNewPlaylist(trackURIs, index);
    this.logDropIntent('add-tracks-to-folder');
  }
};

/**
 * Handle 'New Playlist' drop target.
 *
 * @param {Object} event Event object.
 */
NavigationBar.prototype.onDropNewPlaylist = function (event) {
  if (DROP_MIME_TYPES.ALBUMS in event.data) {
    var albumURIs = event.data[DROP_MIME_TYPES.ALBUMS];
    this.addAlbumsToNewPlaylist(albumURIs);
    this.logDropIntent('create-albums-playlist');
  }

  if (DROP_MIME_TYPES.TRACKS in event.data) {
    var trackURIs = event.data[DROP_MIME_TYPES.TRACKS];
    this.addTracksToNewPlaylist(trackURIs);
    this.logDropIntent('create-tracks-playlist');
  }

  if (DROP_MIME_TYPES.PLAYLISTS in event.data) {
    var playlistURIs = event.data[DROP_MIME_TYPES.PLAYLISTS];
    this.addPlaylistsToNewPlaylist(playlistURIs);
    this.logDropIntent('create-playlists-playlist');
  }
};

/**
 * Handle collection drop targets.
 *
 * @param {Object} event Event object.
 */
NavigationBar.prototype.onDropCollection = function (event) {
  var uris = [].concat(event.data[DROP_MIME_TYPES.TRACKS] || []).concat(event.data[DROP_MIME_TYPES.ALBUMS] || []).concat(event.data[DROP_MIME_TYPES.ARTISTS] || []).concat(event.data[DROP_MIME_TYPES.STATIONS] || []);

  uris.forEach(function (uri) {
    live(uri).publish({ added: true });
  });

  if (event.data[DROP_MIME_TYPES.TRACKS]) {
    this.logDropIntent('add-tracks-to-collection');
  }
  if (event.data[DROP_MIME_TYPES.ALBUMS]) {
    this.logDropIntent('add-albums-to-collection');
  }
  if (event.data[DROP_MIME_TYPES.ARTISTS]) {
    this.logDropIntent('follow-artists');
  }
  if (event.data[DROP_MIME_TYPES.STATIONS]) {
    this.logDropIntent('follow-stations');
  }
};

/**
 * Add albums to a new playlist, optionally at a certain position in the
 * rootlist.
 *
 * @param {Array.<string>} albumURIs Array of album URIs.
 * @param {number=} index Optional index in the rootlist to put the
 *     playlist.
 */
NavigationBar.prototype.addAlbumsToNewPlaylist = function (albumURIs, index) {
  if (!albumURIs || albumURIs.length === 0) return;

  var onPlaylistCreated = function onPlaylistCreated(data) {
    PlaylistModel.addAlbums(data.uri, albumURIs);
  };

  getPlaylistNameForItems.album(albumURIs[0], function (err, name) {
    if (err) throw err;
    if (typeof index === 'number') {
      PlaylistModel.createPlaylistAtPosition(name, index, onPlaylistCreated);
    } else {
      PlaylistModel.createPlaylist(name, onPlaylistCreated);
    }
  });
};

/**
 * Add tracks to a new playlist, optionally at a certain position in the
 * rootlist.
 *
 * @param {Array.<string>} trackURIs Array of track URIs.
 * @param {number=} index Optional index in the rootlist to put the
 *     playlist.
 */
NavigationBar.prototype.addTracksToNewPlaylist = function (trackURIs, index) {
  if (!trackURIs || trackURIs.length === 0) return;

  var onPlaylistCreated = function onPlaylistCreated(data) {
    PlaylistModel.addTracks(data.uri, trackURIs);
  };

  var onNameFetch = function onNameFetch(error, name) {
    if (error) throw error;

    if (typeof index === 'number') {
      PlaylistModel.createPlaylistAtPosition(name, index, onPlaylistCreated);
    } else {
      PlaylistModel.createPlaylist(name, onPlaylistCreated);
    }
  };

  getPlaylistNameForItems.tracks(trackURIs, onNameFetch);
};

/**
 * Add playlists to a new playlist, optionally at a certain position in the
 * rootlist. This reads all the tracks from all the playlists and puts them
 * in a new playlist.
 *
 * @param {Array.<string>} playlistURIs Array of playlist URIs.
 * @param {number=} index Optional index in the rootlist to put the
 *     playlist.
 */
NavigationBar.prototype.addPlaylistsToNewPlaylist = function (playlistURIs, index) {
  if (!playlistURIs || playlistURIs.length === 0) return;

  var onPlaylistCreated = function onPlaylistCreated(data) {
    PlaylistModel.addPlaylists(data.uri, playlistURIs);
  };

  getPlaylistNameForItems.playlist(playlistURIs[0], function (err, name) {
    if (err) throw err;
    if (typeof index === 'number') {
      PlaylistModel.createPlaylistAtPosition(name, index, onPlaylistCreated);
    } else {
      PlaylistModel.createPlaylist(name, onPlaylistCreated);
    }
  });
};

/**
 * Handle 'Radio' drop target.
 *
 * @param {Object} event Event object.
 */
NavigationBar.prototype.onDropRadio = function (event) {
  var radioURI = 'spotify:station';
  var logPrefix = 'open';
  var args;

  var tracks = event.data[DROP_MIME_TYPES.TRACKS];
  var albums = event.data[DROP_MIME_TYPES.ALBUMS];
  var artists = event.data[DROP_MIME_TYPES.ARTISTS];
  var playlists = event.data[DROP_MIME_TYPES.PLAYLISTS];

  if (tracks && tracks[0]) {
    args = tracks[0];
    this.logDropIntent(logPrefix + '-track-radio');
  } else if (albums && albums[0]) {
    args = albums[0];
    this.logDropIntent(logPrefix + '-album-radio');
  } else if (artists && artists[0]) {
    args = artists[0];
    this.logDropIntent(logPrefix + '-artist-radio');
  } else if (playlists && playlists[0]) {
    args = playlists[0];
    this.logDropIntent(logPrefix + '-playlist-radio');
  }

  if (args) {
    this._router.route(radioURI + ':' + args.replace(/^spotify:/, ''));
  }
};

NavigationBar.prototype.createPlaylist = function () {
  this._newPlaylistVM.createPlaylist();
};

NavigationBar.prototype.onScroll = function (navbar, event) {
  if (glue.getVersion() === 2) {
    var scrollTop = event.target.scrollTop;
    this.showTopBorder(scrollTop > 0);
    this.topBorderPosition(scrollTop + 'px');
  }
};

module.exports = NavigationBar;

},{"../../../../libs/spotify-abba-mini":181,"../../../../libs/spotify-elements":259,"../../../../libs/spotify-ensured-cosmos-message":263,"../../../../libs/spotify-event-dispatcher":264,"../../../../libs/spotify-events/center":268,"../../../../libs/spotify-glue-cat":348,"../../../../libs/spotify-live":439,"../../../../libs/spotify-live-get-playlist-name-for-items":392,"../../../../libs/spotify-logger/messages/UIInteraction4":452,"../../i18n":11,"../components/menuitem":64,"../components/playlists":67,"../event":77,"../keyboard":83,"../live-models/util":91,"../mimetypes":98,"../models/playlist":103,"../models/session":107,"../urihelper":117,"./newplaylist":157,"knockout":567,"spotify-liburi":707}],157:[function(require,module,exports){
'use strict';

var _ = require('../../i18n').get;
var NEW_PLAYLIST_URI = require('../live-models/uris').NEW_PLAYLIST_URI;
var util = require('../live-models/util');
var UIInteraction4 = require('../../../../libs/spotify-logger/messages/UIInteraction4');
var glue = require('../../../../libs/spotify-glue-cat');

function NewPlaylist(navigationBar) {
  this._navigationBar = navigationBar;
  this.isGlue2 = glue.getVersion() === 2;
}

NewPlaylist.prototype.NEW_PLAYLIST_BUTTON_LABEL = _('new_playlist.button');

NewPlaylist.prototype.setup = function () {};

NewPlaylist.prototype.createPlaylist = function () {
  UIInteraction4.log({
    'feature_id': 'zlink',
    'section_id': 'sidebar',
    'interaction_type': 'click',
    'user_intent': 'create-playlist'
  });

  console.log('RenameTriggerLogging: New playlist button', new Date());
  util.createRootlistItem(NEW_PLAYLIST_URI);
};

module.exports = NewPlaylist;

},{"../../../../libs/spotify-glue-cat":348,"../../../../libs/spotify-logger/messages/UIInteraction4":452,"../../i18n":11,"../live-models/uris":90,"../live-models/util":91}],158:[function(require,module,exports){
(function (global){
'use strict';

var ko = require('knockout');
var session = require('../models/session');
var keyboard = require('../keyboard');
var Event = require('../event');
var _ = require('../../i18n').get;
var eventDispatcher = require('../../../../libs/spotify-event-dispatcher');
var cosmos = require('spotify-cosmos-api');
var glue = require('../../../../libs/spotify-glue-cat');
var abbaSubscriber = require('../utils/abba-subscriber');

var glueVersion = glue.getVersion();

var NOTIFICATIONS_POPOVER_ID = 'notifications';

/**
 * View Model for the notifications area.
 *
 * @constructor
 */
function Notifications() {
  var self = this;

  this._activeElement = null;
  this._notificationsMenu = document.getElementById('notifications-menu');

  this.spotifyUsername = session.getUsername();
  this.notificationCenterUri = ko.observable('');
  this.notificationMenuVisible = ko.observable(false);
  this.notificationsVisible = ko.observable(false);

  // Let the notifications app know when it's being opened/closed.
  this.notificationMenuVisible.subscribe(function (value) {
    cosmos.resolver.post({
      url: 'sp://messages/v1/notification-center',
      body: {
        type: value ? 'on-open' : 'on-close'
      }
    }, function (err) {
      if (err) {
        console.log('Error posting to messages/v1/notification-center', err);
      }
    });
  });

  // These control badges on top of the various icons.
  this.notificationsCounter = ko.observable(0);
  this.unreadMessagesCounter = ko.observable(0);

  // Keeps track of what badge number to show on the app icon.
  this.iconBadgeCounter = ko.pureComputed(function () {
    var counter = 0;
    if (this.notificationsVisible()) {
      counter += this.notificationsCounter();
    }
    counter += this.unreadMessagesCounter();
    return counter;
  }, this);

  // Update app icon with correct count when it changes.
  this.iconBadgeCounter.subscribe(function (count) {
    var request = new cosmos.Request('PUT', 'sp://desktop/v1/notification_count', null, { count: count });
    cosmos.resolver.resolve(request, function (err) {
      if (err) {
        console.log('Failed to update icon badge', err);
      }
    });
  });

  keyboard.registerImportantShortcut(keyboard.KEYS.ESCAPE, function (e) {
    if (self.notificationMenuVisible()) {
      e.preventDefault();
      self.hideNotificationsMenu();
    }
  });

  this._handleBackgroundClick = this.handleBackgroundClick.bind(this);

  // Subscribe to Abba
  abbaSubscriber('disable-inclient-notifs', function (cell) {
    this.notificationsVisible(cell !== 'Disabled');
  }.bind(this));
}

// Button labels
Notifications.prototype.NOTIFICATIONS_LABEL = _('notifications_center.app_name');
Notifications.prototype.MESSAGES_LABEL = _('messages.app_name');

/**
 * Setup functionality
 *
 * @return {Notifications} The instance.
 */
Notifications.prototype.setup = function () {
  var self = this;

  if (glueVersion !== 2) {
    this._setupNotificationsBadge();
    this._setupMessagesBadge(this.spotifyUsername);

    var notificationCenterUri = 'spotify:app:notification-center';
    if (global.__spotify && global.__spotify.platform === 'web') {
      global.__spotify.exec('frame:register', notificationCenterUri, document.querySelector('#app-notification-center'));
      notificationCenterUri = global.__spotify.exec('translate:uri', notificationCenterUri);
    }

    // Ensure the app is loaded _after_ we begin listening for badge updates,
    // otherwise there is the potential to miss the initial message from the
    // app.
    this.notificationCenterUri(notificationCenterUri);

    eventDispatcher.addEventListener(Event.TYPES.NAVIGATION_OPEN_URI, function () {
      self.hideNotificationsMenu();
    });
  }

  return this;
};

/**
 * Initialize the notifications badge
 */
Notifications.prototype._setupNotificationsBadge = function () {
  var self = this;

  this.notificationsCounter(0);

  var uri = 'sp://messages/v1/notification-center';

  // Note: keep in mind this will receive all messages, even messages POSTed
  // from within zlink -> notification-center.
  cosmos.resolver.subscribe(uri, function (err, res) {
    if (err) {
      console.log('Failed to subscribe to notifications-center events', err);
      return;
    }

    var message = res.getJSONBody();
    if (!message) {
      return;
    }

    // This is a message originally accepted from legacy desktop. The app is
    // currently responsible for keeping track of the count.
    if (message.type === 'set-unread-count' && 'data' in message) {
      self.notificationsCounter(message.data);
    }
  });
};

/**
 * Initialize the messages badge
 */
Notifications.prototype._setupMessagesBadge = function (username) {
  var self = this;

  this.unreadMessagesCounter(0);

  function refreshMessagesBadge() {
    var options = {
      url: 'hm://messaging/threads',
      headers: { 'Accept': 'application/json' }
    };
    cosmos.resolver.get(options, function (err, res) {
      if (err) {
        console.log('Failed to get unread messages count', err);
      } else {
        var data = res.getJSONBody();
        if (!data) {
          return;
        }
        self.unreadMessagesCounter(data.unread);
      }
    });
  }

  cosmos.resolver.subscribe('hm://messaging/user/' + encodeURIComponent(username), refreshMessagesBadge);

  refreshMessagesBadge();
};

Notifications.prototype.handleBackgroundClick = function () {
  this.hideNotificationsMenu();
};

Notifications.prototype.toggleNotificationsMenu = function () {
  if (this.notificationMenuVisible()) {
    this.hideNotificationsMenu();
  } else {
    this.showNotificationsMenu();
  }
};

Notifications.prototype.showNotificationsMenu = function () {
  this.notificationMenuVisible(true);

  this._activeElement = document.activeElement;
  this._notificationsMenu.focus();

  var dropdownBackground = document.getElementById('dropdown-background');
  if (dropdownBackground) {
    dropdownBackground.classList.add('visible');
    dropdownBackground.addEventListener('click', this._handleBackgroundClick, false);
  }

  eventDispatcher.dispatchEvent(new Event(Event.TYPES.POPOVER_OPENED, { id: NOTIFICATIONS_POPOVER_ID }));
};

Notifications.prototype.hideNotificationsMenu = function () {
  // The if is an optimization and the code inside it is harmless
  // if executed with the already hidden menu, but we want to avoid
  // unecessary events from being triggered and handled.
  if (this.notificationMenuVisible()) {
    this.notificationMenuVisible(false);

    if (this._activeElement) {
      this._activeElement.focus();
      this._activeElement = null;
    }

    var dropdownBackground = document.getElementById('dropdown-background');
    if (dropdownBackground) {
      dropdownBackground.classList.remove('visible');
      dropdownBackground.removeEventListener('click', this._handleBackgroundClick, false);
    }

    eventDispatcher.dispatchEvent(new Event(Event.TYPES.POPOVER_CLOSED, { id: NOTIFICATIONS_POPOVER_ID }));
  }
};

/**
 * Open the Messages app
 */
Notifications.prototype.openMessagesApp = function () {
  var event = new Event(Event.TYPES.NAVIGATION_OPEN_URI, 'spotify:app:messages', { toggle: true });
  eventDispatcher.dispatchEvent(event);
};

module.exports = Notifications;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../../../libs/spotify-event-dispatcher":264,"../../../../libs/spotify-glue-cat":348,"../../i18n":11,"../event":77,"../keyboard":83,"../models/session":107,"../utils/abba-subscriber":121,"knockout":567,"spotify-cosmos-api":694}],159:[function(require,module,exports){
'use strict';

var ko = require('knockout');
var eventDispatcher = require('../../../../libs/spotify-event-dispatcher');
var events = require('../../../../libs/spotify-events');
var Event = require('../event');
var LocalSettings = require('../models/localsettings');
var liburi = require('spotify-liburi');
var wrappedUriUtils = require('../../../../libs/spotify-live-wrapped-uri');
var _ = require('../../i18n').get;
var live = require('../../../../libs/spotify-live');
var Player = require('../models/player');
var URI = require('spotify-liburi');
var ensuredMessage = require('../../../../libs/spotify-ensured-cosmos-message');
var UIInteraction4 = require('../../../../libs/spotify-logger/messages/UIInteraction4');
var AudioCompanionAd = require('../../../../libs/spotify-ad-formats').AudioCompanionAd;
var VideoTakeoverAd = require('../../../../libs/spotify-ad-formats').VideoTakeoverAd;
var glue = require('../../../../libs/spotify-glue-cat');

/**
 * View Model for the now playing area.
 *
 * @constructor
 */
function NowPlaying() {
  this._player = Player.getPlayer();

  // Observables
  this.name = ko.observable('');
  this.imageURI = ko.observable('');

  this.trackURI = ko.observable('');
  this.relinkedTrackURI = ko.observable('');
  this.active = ko.pureComputed(function () {
    // If there's no track, the Now Playing view should be disabled
    return !!this.trackURI();
  }, this);
  this.referrerURI = ko.observable('');
  this.artists = ko.observableArray([]);
  this.trackScrollable = ko.observable(false);
  this.transitioning = ko.observable(false);
  this.artistScrollable = ko.observable(false);
  this.isAd = ko.observable(false);
  this.isVideoAd = ko.observable(false);
  this.videoAdId = ko.observable(false);
  this.scrollResetters = [];
  this.adType = ko.pureComputed(function () {
    if (this.isVideoAd()) {
      return 'video';
    }

    if (this.isAd() && !this.isVideoAd()) {
      return 'audio';
    }

    return '';
  }, this);

  this.imageURICSS = ko.pureComputed(function () {
    return this.imageURI() ? 'url(\'' + this.imageURI() + '\')' : 'none';
  }, this);

  // [SHUFFLE]
  this.suggestedTrackVisible = ko.observable(false);
  this.suggestedTrackPosLeft = ko.observable('0px');
  this.suggestedTrackText = _('nowplaying.playing_suggested_track');

  this.displayLargeCoverSize = ko.observable();
  this._restoreSavedCoverSize();
  this._changedCoverSizeForAds = false;
  this._lastTrackURI = null;
  this._largeCoverImage = null;
  this._videoContainer = null;
  this._placeholderOnVideo = null;
  this._removeCoverArtTimer = null;
}

NowPlaying.prototype.NOW_PLAYING_LABEL = _('nowplaying.label');
NowPlaying.prototype.GO_TO_CONTEXT = _('nowplaying.go_to_context');
NowPlaying.prototype.SAVE_YOUR_MUSIC = _('nowplaying.save_your_music');
NowPlaying.prototype.REMOVE_YOUR_MUSIC = _('nowplaying.remove_your_music');

NowPlaying.prototype.COVER_SIZE_SETTING = 'coverSize';
NowPlaying.prototype.COVER_SIZE_SETTING_LARGE = 'l';
NowPlaying.prototype.COVER_SIZE_SETTING_SMALL = 's';

NowPlaying.prototype.SEEN_SUGGESTED_TRACKS_SETTING = 'seen-suggested-tracks';
NowPlaying.prototype.SEEN_SUGGESTED_TRACKS_MAXCOUNT = 10;

NowPlaying.prototype.SCROLL_SPEED = 25 / 1000; // pixels per ms
NowPlaying.prototype.SCROLL_PADDING = 10; // padding-right on .inner-text-span

/**
 * Helper method to log now playing UIInteraction4 messages.
 */
NowPlaying.prototype._logUIInteraction4 = function (interactionType, userIntent, targetUri) {
  var logData = {
    'feature_id': 'zlink',
    'section_id': 'now-playing',
    'interaction_type': interactionType,
    'user_intent': userIntent
  };
  if (targetUri !== undefined) {
    logData.target_uri = targetUri;
  }
  UIInteraction4.log(logData);
};

NowPlaying.prototype.toggleViewMode = function (model, e) {
  e.preventDefault();
  e.stopPropagation();

  var userIntent = this.displayLargeCoverSize() ? 'show-small-cover-art' : 'show-large-cover-art';

  this.displayLargeCoverSize(!this.displayLargeCoverSize());
  this.transitioning(true);

  LocalSettings.set(this.COVER_SIZE_SETTING, this.displayLargeCoverSize() ? this.COVER_SIZE_SETTING_LARGE : this.COVER_SIZE_SETTING_SMALL);

  this._logUIInteraction4('click', userIntent);
};

NowPlaying.prototype.onTransitionEnd = function (model, e) {
  // Ignore transition events from .toggle-cover-size or any other children
  if (e.currentTarget !== e.target) {
    return;
  }
  this.transitioning(false);
};

NowPlaying.prototype._restoreSavedCoverSize = function () {
  var savedCoverSize = LocalSettings.get(this.COVER_SIZE_SETTING);
  this.displayLargeCoverSize(savedCoverSize === this.COVER_SIZE_SETTING_LARGE);
};

/**
 * Setup functionality
 *
 * @return {NowPlaying} The instance.
 */
NowPlaying.prototype.setup = function (element) {
  var self = this;

  // Act on player events
  this._player.subscribe(this._updateFromPlayerStateChange.bind(this));

  VideoTakeoverAd.subscribe(function (eventName) {
    switch (eventName) {
      case VideoTakeoverAd.EVENTS.ACTIVE:
        active();
        break;
      case VideoTakeoverAd.EVENTS.INACTIVE:
        inactive();
        break;
      default:
      // noop
    }

    function active() {
      var data = VideoTakeoverAd.nowPlaying();

      self.isAd(true);
      self.isVideoAd(true);
      self.suggestedTrackVisible(false);

      if (!self.displayLargeCoverSize()) {
        self.displayLargeCoverSize(true);
        self._changedCoverSizeForAds = true;
      }

      self.videoAdId(data.id);
      self.name(data.title);

      self.trackURI(data.clickUrl);
      self.referrerURI(data.clickUrl);
      self.imageURI(data.companionAd.url);

      self._updateArtists([{
        name: data.advertiser,
        uri: data.clickUrl
      }]);

      events.update(self.element);
    }

    function inactive() {
      self._restoreSavedCoverSize();
      self.isAd(false);
      self.isVideoAd(false);
    }
  });

  eventDispatcher.addEventListener(Event.TYPES.AD_CLICK_VIDEO_STARTED, this._onClickVideoStarted.bind(this));

  eventDispatcher.addEventListener(Event.TYPES.AD_CLICK_VIDEO_ENDED, this._onClickVideoEnded.bind(this));

  eventDispatcher.addEventListener(Event.TYPES.LAYOUT_SIDEBAR_RESIZED, this._onSidebarResized.bind(this));

  this._largeCoverImage = document.getElementById('large-cover-image');

  this._videoContainer = document.getElementById('sidebar-video-container');

  this.element = element;

  AudioCompanionAd.init({
    element: document.getElementById('view-now-playing')
  });

  return this;
};

/**
 * Callback for when artist/track name gets hovered
 *
 * @param {NowPlaying} model The model used.
 * @param {MouseEvent} e The event triggered.
 */
NowPlaying.prototype.onTextMouseOver = function (model, e) {
  var target;
  if (e.target.nodeName.toLowerCase() === 'a') {
    target = e.target.parentNode.parentNode.parentNode; // The p tag
  }
  if (!target) {
    return; // Not a valid target
  }
  if (target.nodeName.toLowerCase() !== 'p') {
    return; // Child element hovered
  }
  var text = target.children[0];

  if (target.offsetWidth > text.offsetWidth - this.SCROLL_PADDING) {
    return; // No need to scroll
  }

  target.mouseHover = true;
  this.startScrolling(target);
};

NowPlaying.prototype.onTextMouseOut = function (model, e) {
  var target;
  if (e.target.nodeName.toLowerCase() === 'a') {
    target = e.target.parentNode.parentNode.parentNode; // The p tag
  }
  if (!target) {
    return; // Not a valid target
  }
  if (target.nodeName.toLowerCase() !== 'p') {
    return; // Child element hovered
  }

  target.mouseHover = false;
};

/**
 * Start scrolling
 *
 * @param {Element} e DOM element to start scrolling
 */
NowPlaying.prototype.startScrolling = function (e) {
  var self = this;
  if (!e.isScrolling) {
    e.classList.add('scrolling');
    var offsetWidth = e.children[0].offsetWidth;
    var duration = offsetWidth / this.SCROLL_SPEED;

    if (glue.getVersion() === 1) {
      e.style.transition = 'text-indent ' + duration + 'ms linear';
      e.style.textIndent = '-' + offsetWidth + 'px';
    } else {
      e.style.transition = 'margin-left ' + duration + 'ms linear';
      e.style.marginLeft = offsetWidth * -1 + 'px';
    }
    e.isScrolling = true;

    var reset;
    var resetScrolling = function resetScrolling() {
      self.stopScrolling.call(self, e);
      clearTimeout(reset);
      if (e.mouseHover) {
        self.startScrolling.call(self, e);
      }
    };

    reset = setTimeout(resetScrolling, duration);
    this.scrollResetters.push(resetScrolling);
  }
};

/**
 * Stop scrolling
 *
 * @param {Element} e Scrolling DOM element to stop
 */
NowPlaying.prototype.stopScrolling = function (e) {
  e.classList.remove('scrolling');
  e.style.transition = '';

  if (glue.getVersion() === 1) {
    e.style.textIndent = '0';
  } else {
    e.style.marginLeft = '0';
  }
  e.isScrolling = false;
};

/**
 * Update observables based on data gotten from player endpoint state updates.
 */
NowPlaying.prototype._updateFromPlayerStateChange = function (error, response) {
  var self = this;
  if (error) return;

  if (self._removeCoverArtTimer) {
    window.clearTimeout(self._removeCoverArtTimer);
    self._removeCoverArtTimer = null;
  }

  var data = response.getJSONBody();

  // Fixes a bug where player_events are still fired
  // when requesting a new track while a video ad
  // is playing (cover art shouldn't be changed in this case)
  if (this.isVideoAd()) {
    return;
  }

  if (!data.track) {
    // We may get updates with is_playing set to true, but no actual playing
    // track. This means that we're loading more tracks and are likely to send
    // another update soon. Delay setting track to null to reduce flicker.
    if (data.is_playing) {
      self._removeCoverArtTimer = setTimeout(function () {
        self._removeCoverArtTimer = null;
        if (!self.isVideoAd()) {
          // Could have been triggered between two ads
          self.trackURI(null);
        }
      }, 5000);
    } else {
      self.trackURI(null);
    }
    return;
  }

  var trackChanged = this.trackURI() !== data.track.uri;

  if (trackChanged) {
    this.relinkedTrackURI(null);

    // If playing song changed, reset scrolling texts
    //
    // Calling a scroll resetter may result in
    // new resetters being pushed to the array.
    // This is why nResetters is extracted before iterating,
    // and the array is spliced instead of being cleared.
    var nResetters = this.scrollResetters.length;
    for (var i = 0; i < nResetters; i++) {
      this.scrollResetters[i]();
    }
    this.scrollResetters.splice(0, nResetters);
  }

  // Metadata can be lazy loaded and therefore may not be there
  // when the player state update happens, so wee need to update
  // the UI regardless.
  //
  // Except for the artist names, since the metadata doesn't contain all
  // artists, we rely on live-models to keep it updated and that just needs to
  // be performed when track changes.
  var metadata = data.track.metadata;

  this.imageURI(metadata.image_xlarge_url);
  this.name(metadata.title || '');

  var isAd = metadata.is_advertisement === 'true';
  var isVideo = metadata['media.type'] === 'video';

  var originURI = data.play_origin && data.play_origin.view_uri || '';

  var contextURI = data.entity_uri || '';
  var trackProvider = data.track && data.track.provider;
  this.trackScrollable(this.name().length > 20);
  this.isAd(isAd);

  if (isVideo) {
    this.displayLargeCoverSize(true);
  }
  this._videoContainer.style.display = !isAd && isVideo ? 'block' : 'none';

  if (isAd) {
    this.trackURI(metadata.click_url);
    this.referrerURI(metadata.click_url);
    this._updateArtists([{
      name: metadata.advertiser,
      uri: metadata.click_url
    }]);

    AudioCompanionAd.setAdId(metadata.ad_id).enable();

    if (!this.displayLargeCoverSize()) {
      this.displayLargeCoverSize(true);
      this._changedCoverSizeForAds = true;
    }
  } else {
    AudioCompanionAd.disable();

    this.trackURI(data.track.uri);
    this.referrerURI(this.getReferrerLink(contextURI, originURI, trackProvider));
    if (trackChanged) {
      this._updateArtists([{
        name: metadata.artist_name,
        uri: metadata.artist_uri
      }]);
      // As stated above, the player just returns the main artist and we need
      // to fetch all of them in case of tracks with multiple artists.
      //
      // As live-models doesn't depend on the metadata returned on the player
      // state update, this just needs to be executed when the track changes

      // Prevent races
      if (!this._artistsQuery) {
        this._artistsQuery = 0;
      }
      var artistsQuery = ++this._artistsQuery;

      live(data.track.uri).query('artists(uri, name)', function (error, data) {
        if (error) return;
        if (artistsQuery !== self._artistsQuery) return;

        self._updateArtists(data.artists);
      }, live.ASAP);
    }

    if (this._changedCoverSizeForAds) {
      this._changedCoverSizeForAds = false;
      this._restoreSavedCoverSize();
    }
  }

  this._lastTrackURI = data.track.uri;

  this._updateSuggestedTrackIndicator();

  var isSuggestedTrack = metadata['mft.injection_source'] === 'fallback';
  if (isSuggestedTrack) {
    var hasSeenEnough = this._updateSeenSuggestedTrackIndicator();
    this.suggestedTrackVisible(!hasSeenEnough);
  } else {
    this.suggestedTrackVisible(false);
  }

  events.update(this.element);

  // Now we updated the complete player UI, we still don't know is if we are
  // playing a relinked track. The now playing view is actually supposed to
  // show the track that is available to the user, but as that data isn't
  // available from isn't available from the player API directly right now,
  // PLAYERS-1506 is the ticket about adding it.

  // Too keep updating speedy, we actually do another potentially async step
  // here, and as the data structure is completeley different in live vs. what
  // we got from the player API earlier, there will be some duplication of code.

  // Prevent races
  if (!this._relinkQuery) {
    this._relinkQuery = 0;
  }
  var query = ++this._relinkQuery;

  live(data.track.uri).query('linkedTrack(uri)', function (error, data) {
    if (error || !data.linkedTrack) {
      return;
    }
    if (query !== self._relinkQuery) {
      return;
    }

    self.relinkedTrackURI(data.linkedTrack.uri);
    events.update(self.element);
  }, live.ASAP);
};

NowPlaying.prototype._updateSuggestedTrackIndicator = function () {
  var trackElement = document.getElementById('nowplaying-track-link');
  var trackContainerElement = document.getElementById('nowplaying-track-link-container');

  var trackRect = trackElement.getBoundingClientRect();
  var trackContainerRect = trackContainerElement.getBoundingClientRect();

  var arrowMargin = 10;
  var maxLeft = trackContainerRect.right + arrowMargin;
  var left = arrowMargin + parseInt(trackRect.right, 10);
  if (left > maxLeft || trackContainerElement.isScrolling) {
    left = maxLeft;
  }

  this.suggestedTrackPosLeft(left + 'px');
};

NowPlaying.prototype._updateSeenSuggestedTrackIndicator = function () {
  if (this.isAd()) {
    return false;
  }

  var settingsKey = this.SEEN_SUGGESTED_TRACKS_SETTING;
  var seenTracks = JSON.parse(LocalSettings.get(settingsKey) || '[]');

  if (seenTracks.indexOf(this.trackURI()) === -1) {
    seenTracks.push(this.trackURI());
    LocalSettings.set(settingsKey, JSON.stringify(seenTracks));
  }

  return seenTracks.length > this.SEEN_SUGGESTED_TRACKS_MAXCOUNT;
};

NowPlaying.prototype._updateArtists = function (artists) {
  var names = [];
  for (var i = 0; i < artists.length; i++) {
    names.push(artists[i].name);
    if (artists.length > 1 && i < artists.length - 1) {
      artists[i].name += ', ';
    }
  }
  this.artists(artists);
  this.artistScrollable(names.join('').length > 20);
};

/**
 * Get the referrer link to use for clicking the now playing cover art.
 * This contains some terrible hacks with hard coded URIs to map custom contexts
 * to an app, for cases where the referrer can't be trusted.
 *
 * @param {string} contextURI  The context URI.
 * @param {string} referrerURI The referrer URI.
 *
 * @return {string} The referrer link to use.
 */
NowPlaying.prototype.getReferrerLink = function (contextURI, referrerURI, trackProvider) {
  if (trackProvider === 'queue') {
    return 'spotify:app:zlink-queue';
  }

  // Unwrap wrapped URIs and try all parsing based on that
  if (wrappedUriUtils.isValid(contextURI)) {
    var originUri = wrappedUriUtils.getOriginUri(contextURI);
    return this.getReferrerLink(originUri, referrerURI);
  }

  var uriObject = liburi.from(contextURI);
  var type = uriObject && uriObject.type;

  // Regular playlists
  if (type === liburi.Type.PLAYLIST) {
    return contextURI;
  }

  // Playlist Folders
  if (type === liburi.Type.FOLDER) {
    return contextURI;
  }

  // Albums and artists
  if (type === liburi.Type.ALBUM || type === liburi.Type.ARTIST) {
    return contextURI;
  }

  // Tracks will use the track URI, but is routed to the album app
  if (type === liburi.Type.TRACK) {
    return contextURI;
  }

  // Your Music Songs
  if (type === liburi.Type.COLLECTION) {
    return contextURI;
  }

  // Your Music Album
  if (type === liburi.Type.COLLECTION_ALBUM) {
    return contextURI;
  }

  // Your Music Artist
  if (type === liburi.Type.COLLECTION_ARTIST) {
    return contextURI;
  }

  // Station
  if (type === liburi.Type.STATION) {
    return contextURI;
  }

  // Local Files
  if (contextURI === 'spotify:internal:local-files') {
    return 'spotify:app:playlist-desktop:local-files';
  }

  // Chart
  if (contextURI.indexOf('spotify:app:chart:') === 0) {
    return contextURI;
  }

  // Any other context will use the referrer from the player state
  if (referrerURI) {
    return referrerURI;
  }

  // Fall back to the queue when nothing else can be found
  return 'spotify:app:zlink-queue';
};

/**
 * Callback for when a link has been clicked
 *
 * @param {Player} model The model.
 * @param {MouseEvent} e The event being triggered.
 */
NowPlaying.prototype.onLinkClicked = function (model, e) {
  var href;
  var element = e.target;
  // Go upwards in the DOM tree looking for the closest href
  while (!href && element !== document.body) {
    href = element.href;
    element = element.parentNode;
  }

  if (!href) return false;

  VideoTakeoverAd.logClick(href);

  var uriObj = URI.from(href);
  if (uriObj) {
    var uriType = uriObj.type;
    var isChartApp = uriObj.type === 'application' && uriObj.id === 'chart';
    if (uriType === URI.Type.COLLECTION || uriType === URI.Type.PLAYLIST || isChartApp) {
      live('spotify:player').query('variant(uri), index(track)', function (error, data) {
        if (error) throw error;
        ensuredMessage.send('highlight-context-index', {
          uri: data.variant.uri,
          index: data.index && data.index.track
        });
      });
    }
  }

  if (uriObj) {
    if (uriObj.type === URI.Type.TRACK) {
      this._logUIInteraction4('click', 'go-to-context', href);
    } else if (uriObj.type === URI.Type.ALBUM) {
      this._logUIInteraction4('click', 'go-to-album', href);
    } else if (uriObj.type === URI.Type.ARTIST) {
      this._logUIInteraction4('click', 'go-to-artist', href);
    }
  }

  return true;
};

/**
 * To keep the cover art in the square format we need to set the figure
 * height to be the same as the width, and it can change when the sidebar
 * is resized
 */
NowPlaying.prototype._onSidebarResized = function (evt) {
  this._largeCoverImage.style.height = evt.params.width;

  this._updateSuggestedTrackIndicator();
};

/**
 * Callback for when click video ad starts playing.
 * Should overlay NPV with a "Music Paused" div
 *
 * @return {void}
 */
NowPlaying.prototype._onClickVideoStarted = function () {
  this.element.classList.add('music-paused');

  this.isAd(true);
  this.isVideoAd(true);
  this.suggestedTrackVisible(false);
};

NowPlaying.prototype._onClickVideoEnded = function () {
  this.element.classList.remove('music-paused');

  this.isAd(false);
  this.isVideoAd(false);
};

NowPlaying.prototype.hideSuggestedTrackIndicator = function () {
  this.suggestedTrackVisible(false);
};

module.exports = NowPlaying;

},{"../../../../libs/spotify-ad-formats":203,"../../../../libs/spotify-ensured-cosmos-message":263,"../../../../libs/spotify-event-dispatcher":264,"../../../../libs/spotify-events":281,"../../../../libs/spotify-glue-cat":348,"../../../../libs/spotify-live":439,"../../../../libs/spotify-live-wrapped-uri":438,"../../../../libs/spotify-logger/messages/UIInteraction4":452,"../../i18n":11,"../event":77,"../models/localsettings":100,"../models/player":101,"knockout":567,"spotify-liburi":707}],160:[function(require,module,exports){
'use strict';

var _ = require('../../i18n').get;

/**
 * View Model for the offline indicator.
 *
 * @constructor
 */
function OfflineIndicator() {}
OfflineIndicator.prototype.OFFLINE_LABEL = _('player.offline_label');

/**
 * Setup functionality
 *
 * @return {OfflineIndicator} The instance.
 */
OfflineIndicator.prototype.setup = function () {
  return this;
};

module.exports = OfflineIndicator;

},{"../../i18n":11}],161:[function(require,module,exports){
'use strict';

var eventDispatcher = require('../../../../libs/spotify-event-dispatcher');
var Event = require('../event');
var PlayerUI = require('./player/player-ui');
var VideoPlayer = require('./player/video-ads-player');
var MusicPlayer = require('./player/music-player');
var SPVideoManager = require('../../../../libs/spotify-video-manager');

/**
 * View Model for the player area.
 *
 * @param {Bridge} bridge The bridge to use.
 * @param {Router}
 * @constructor
 */
function Player(bridge, router, nowPlaying, history) {
  /**
   * Currently active player
   */
  this._activePlayer = null;

  /**
   * Player controls and other ui elements
   */
  this.ui = new PlayerUI(nowPlaying, history);

  /**
   * Main player responsible for playing music
   */
  this._musicPlayer = new MusicPlayer(this.ui, bridge);

  /**
   * Used when a video ad is playing
   */
  this._videoPlayer = new VideoPlayer(this.ui);

  this._onVideoManagerChange = this._onVideoManagerChange.bind(this);
}

/**
 * Setup functionality
 *
 * @return {Player} The instance.
 */
Player.prototype.setup = function () {
  // Act on player events
  this._setActivePlayer(this._musicPlayer);

  // Query initial state
  this._sync();

  this.ui.setup();

  eventDispatcher.addEventListener(Event.TYPES.PLAYER_PROGRESS, this._setCallback(this._setProgress));
  eventDispatcher.addEventListener(Event.TYPES.PLAYER_SYNC_PROGRESS, this._setCallback(this._sync));
  eventDispatcher.addEventListener(Event.TYPES.PLAYER_VOLUME, this._setCallback(this._setVolume));
  eventDispatcher.addEventListener(Event.TYPES.PLAYER_SEEK, this._setCallback(this._seek));
  eventDispatcher.addEventListener(Event.TYPES.PLAYER_SHUFFLE, this._setCallback(this._setShuffle));
  eventDispatcher.addEventListener(Event.TYPES.PLAYER_REPEAT, this._setCallback(this._setRepeat));
  eventDispatcher.addEventListener(Event.TYPES.PLAYER_PAUSE, this._setCallback(this._pause));
  eventDispatcher.addEventListener(Event.TYPES.PLAYER_RESUME, this._setCallback(this._resume));
  eventDispatcher.addEventListener(Event.TYPES.PLAYER_NEXT, this._setCallback(this._skipToNext));
  eventDispatcher.addEventListener(Event.TYPES.PLAYER_PREV, this._setCallback(this._skipToPrevious));

  // Video manager state changes
  SPVideoManager.subscribe(undefined, this._onVideoManagerChange);

  return this;
};

Player.prototype._onVideoManagerChange = function (err, previous, current) {
  if (err) {
    this._setActivePlayer(this._musicPlayer);
    return;
  }

  // if isPlaying has changed
  if (previous.isPlaying !== current.isPlaying) {
    // Video was playing and now it's not
    if (current.isPlaying) {
      this._musicWasPlaying = this.ui.playing();
      this._pause();
      this._setActivePlayer(this._videoPlayer);
    } else {
      this._setActivePlayer(this._musicPlayer);
      if (this._musicWasPlaying) {
        this._resume();
      }
    }
  }
};

Player.prototype._setCallback = function (cb) {
  return function (evt) {
    cb.call(this, evt && evt.params);
  }.bind(this);
};

Player.prototype._setActivePlayer = function (player) {
  if (this._activePlayer) {
    this._activePlayer.detach();
  }
  this._activePlayer = player;
  this._activePlayer.attach();
};

/**
 * Sync the player with the player state
 */
Player.prototype._sync = function () {
  var self = this;
  this._activePlayer.getState(function (state) {
    self._activePlayer.updateView(state);
    // Broadcasts the change in player state so other view components don't
    // need to perform the same query
    eventDispatcher.dispatchEvent(new Event(Event.TYPES.PLAYER_EVENT, state));
  });
};

/**
 * Set the progress on the active player
 */
Player.prototype._setProgress = function () {
  this._activePlayer.updateProgress();
};

/**
 * Seek to a position in the song
 *
 * @param {Number} position The position to seek to.
 */
Player.prototype._seek = function (position) {
  this._activePlayer.seek(position);
};

/**
 * Set the volume on the active player
 *
 * @param {Number} volume The volume from 0 (muted) to 1 (100%)
 */
Player.prototype._setVolume = function (volume) {
  this._activePlayer.setVolume(volume);
};

/**
 * Callback function for when skip to previous has been clicked.
 */
Player.prototype._skipToPrevious = function () {
  this._activePlayer.skipToPrevious();
};

/**
 * Callback function for when skip to next has been clicked.
 */
Player.prototype._skipToNext = function () {
  this._activePlayer.skipToNext();
};

/**
 * Callback function for when pause button has been clicked.
 */
Player.prototype._pause = function () {
  this._activePlayer.pause();
};

/**
 * Callback function for when play button has been clicked.
 */
Player.prototype._resume = function () {
  this._activePlayer.resume();
};

/**
 * Callback function for when shuffle button has been clicked.
 */
Player.prototype._setShuffle = function (shouldShuffle) {
  this._musicPlayer.setShuffle(shouldShuffle);
};

/**
 * Callback function for when repeat button has been clicked.
 */
Player.prototype._setRepeat = function (shouldRepeat) {
  this._musicPlayer.setRepeat(shouldRepeat);
};

Player.prototype._onVideoAdStarted = function (evtData) {
  console.log('[PLAYER] video ad started', evtData);
  this._setActivePlayer(this._videoPlayer);

  this._videoPlayer.updateView(evtData);
};

Player.prototype._onVideoAdFinished = function (evtData) {
  console.log('[PLAYER] video ad finished', evtData);
  this._setActivePlayer(this._musicPlayer);
};

module.exports = Player;

},{"../../../../libs/spotify-event-dispatcher":264,"../../../../libs/spotify-video-manager":493,"../event":77,"./player/music-player":164,"./player/player-ui":165,"./player/video-ads-player":167}],162:[function(require,module,exports){
'use strict';

/**
 * Base Player object. Defines the interface that is
 * used by the view to communicate with the player that
 * currently owns the controls.
 * @constructor
 */

function BasePlayer() {
  this._attached = false;
}

/**
 * Attach the player.
 * This is the place to bind to events
 * specific for the player.
 */
BasePlayer.prototype.attach = function () {
  this._attached = true;
};

/**
 * Detach the player.
 * Place to clean up.
 */
BasePlayer.prototype.detach = function () {
  this._attached = false;
};

/**
 * Fetch the current state of the player.
 *
 * @param {function(object)} callback The function
 *    to invoke after player state has been retrieved.
 */
/* eslint-disable no-unused-vars */
BasePlayer.prototype.getState = function (callback) {};
/* eslint-enable no-unused-vars */

/**
 * Upadate the view with given set of data.
 * The most common use is to synchronize view with the
 * current state of the player.
 * @param {object} data The data set to update the view with.
 */
/* eslint-disable no-unused-vars */
BasePlayer.prototype.updateView = function (data) {};
/* eslint-enable no-unused-vars */

/**
 * Triggered every progress of the streamed media is updated.
 * Used to update elapsed/remaining time and/or progress meters.
 */
BasePlayer.prototype.updateProgress = function () {};

BasePlayer.prototype.resume = function () {};
BasePlayer.prototype.pause = function () {};
BasePlayer.prototype.skipToNext = function () {};
BasePlayer.prototype.skipToPrevious = function () {};
BasePlayer.prototype.seek = function () {};

/* eslint-disable no-unused-vars */
BasePlayer.prototype.setShuffle = function (isShuffling) {};
/* eslint-enable no-unused-vars */

/* eslint-disable no-unused-vars */
BasePlayer.prototype.setRepeat = function (isRepeating) {};
/* eslint-enable no-unused-vars */

/* eslint-disable no-unused-vars */
BasePlayer.prototype.setVolume = function (volume) {};
/* eslint-enable no-unused-vars */

module.exports = BasePlayer;

},{}],163:[function(require,module,exports){
'use strict';

var ko = require('knockout');
var live = require('../../../../../libs/spotify-live');

function MiniPlayer() {
  this._trackURI = null;
  this.cover = ko.observable();
  this.coverCSS = ko.pureComputed(function () {
    return 'url(' + this.cover() + ')';
  }, this);
  this.artistImage = ko.observable();
  this.artistImageCss = ko.pureComputed(function () {
    return 'url(' + this.artistImage() + ')';
  }, this);
  this.trackName = ko.observable();
  this.trackArtists = ko.observable();
  this.artistURI = ko.observable();
  this.artistImage = ko.observable();
  this.artistImageCSS = ko.pureComputed(function () {
    return 'url(' + this.artistImage() + ')';
  }, this);

  this.isEnabled = ko.observable(false);
}

MiniPlayer.prototype.MAX_HEIGHT = 400;

MiniPlayer.prototype.setup = function () {
  var self = this;
  this.artistURI.subscribe(function (uri) {
    if (!uri) return;
    // This should fetch the header image for the artist and set it
    // as artistImage(), but in order to avoid DoSing Artist service
    // for now we won't do it until artist service is ready to handle
    // the load
    self.artistImage(self.cover());
  });

  window.addEventListener('resize', this._checkWindowSize.bind(this));
  this._checkWindowSize();
};

MiniPlayer.prototype._checkWindowSize = function () {
  this.isEnabled(window.innerHeight <= this.MAX_HEIGHT);
};

MiniPlayer.prototype.updatePlayerState = function (state) {
  var meta = state && state.track && state.track.metadata;
  this.trackName(meta && meta.title);
  this.cover(meta && meta.image_xlarge_url);
  this.artistURI(meta && meta.artist_uri);
  this.trackArtists(meta && meta.artist_name);

  var self = this;
  live(this._uri).query('artists(name)', function (error, data) {
    if (error) return;
    self.trackArtists(data.artists.map(function (artist) {
      return artist.name;
    }).join(', '));
  });
};

module.exports = MiniPlayer;

},{"../../../../../libs/spotify-live":439,"knockout":567}],164:[function(require,module,exports){
'use strict';

var utils = require('../../utils');
var BasePlayer = require('./base');
var Player = require('../../models/player');
var cosmos = require('spotify-cosmos-api');

function MusicPlayer(view, bridge) {
  BasePlayer.apply(this, view);

  this._bridge = bridge;
  this._view = view;

  this._attached = false;

  this._updatePlayerState = this._updatePlayerState.bind(this);
  this._onVolumeUpdate = this._onVolumeUpdate.bind(this);
  this._volumeSubscription = null;
  this._player = Player.getPlayer();
  this._playerSubscription = null;
  this._trackDuration = 0;
}
utils.inherit(MusicPlayer, BasePlayer);

MusicPlayer.prototype.attach = function () {
  if (!this._attached) {
    this._attached = true;
    this._playerSubscription = this._player.subscribe(this._updatePlayerState);

    this._volumeSubscription = cosmos.resolver.subscribe('sp://playback/v1/volume', this._onVolumeUpdate);
  }

  if (this._view.volume()) {
    this.setVolume(this._view.volume());
  }
};

MusicPlayer.prototype.detach = function () {
  if (this._playerSubscription) {
    this._playerSubscription.cancel();
  }
  if (this._volumeSubscription) {
    this._volumeSubscription.cancel();
  }

  this._attached = false;
};

MusicPlayer.prototype._updatePlayerState = function (error, data) {
  this._view.error = !!error;
  if (!error) {
    this.updateView(data.getJSONBody());
  }
};

/**
 * Sync the player with the player state in bridge
 */
MusicPlayer.prototype.sync = function () {
  if (this._attached) {
    this._player.getState(this._updatePlayerState);
  }
};

/**
 * Update observables based on data received from the cosmos player.
 *
 * @param {Object} data
 */
MusicPlayer.prototype.updateView = function (data) {
  if (!this._attached) return;
  this._view.updatePlayerState(data);
  this._trackDuration = data.duration;
};

MusicPlayer.prototype.pause = function () {
  this._player.pause();
};

MusicPlayer.prototype.resume = function () {
  this._player.resume();
};

MusicPlayer.prototype.skipToNext = function () {
  this._player.skipToNextTrack();
};

MusicPlayer.prototype.skipToPrevious = function () {
  // Depending on the current playback position in the track
  // the player can decide if it should go to the previous one
  // or seek to the beginning of the current one
  var options = {
    'allow_seeking': true
  };
  this._player.skipToPrevTrack(options);
};

/**
 * Set the repeat mode
 * 0 = No Repeat
 * 1 = Repeat context
 * 2 = Repeat track
 *
 * @param {Number} repeatMode
 */
MusicPlayer.prototype.setRepeat = function (repeatMode) {
  this._player.setRepeatingTrack(repeatMode === 2);
  /* On for both 1, 2 in order to continue repeating
     one after end of context. (KM-9088) */
  this._player.setRepeatingContext(repeatMode !== 0);
};

MusicPlayer.prototype.setShuffle = function (isShuffling) {
  this._player.setShufflingContext(isShuffling);
};

MusicPlayer.prototype.seek = function (position) {
  this._player.seekTo(Math.min(Math.max(position, 0), this._trackDuration));
};

MusicPlayer.prototype.setVolume = function (volume) {
  cosmos.resolver.resolve(new cosmos.Request(cosmos.Action.PUT, 'sp://playback/v1/volume', null, { volume: volume }));
};

MusicPlayer.prototype._onVolumeUpdate = function (error, response) {
  if (!error && !this._view.volumebar.dragging) {
    var data = response.getJSONBody();
    this._view.volume(data.volume);
    if (data.volume !== 0) {
      this._view.mute(false);
    }
  }
};

module.exports = MusicPlayer;

},{"../../models/player":101,"../../utils":120,"./base":162,"spotify-cosmos-api":694}],165:[function(require,module,exports){
(function (global){
'use strict';

var ko = require('knockout');
var center = require('../../../../../libs/spotify-events/center');
var addEvents = require('../../../../../libs/spotify-events/add');
var controlMessagesHandler = require('../../controlmessageshandler');
var eventDispatcher = require('../../../../../libs/spotify-event-dispatcher');
var shuffleMode = require('../../../../../libs/spotify-shuffle-mode');
var Event = require('../../event');
var OldProgressBar = require('../../components/progressbar');
var ProgressBar = require('../../../../../libs/spotify-progressbar');
var Keyboard = require('../../keyboard');
var MiniPlayer = require('./miniplayer');
var LocalSettings = require('../../models/localsettings');
var QueueModel = require('../../models/queue');
var ConnectHelper = require('../../connecthelper');
var RemotePlaybackBar = require('../../components/remoteplaybackbar');
var ConnectPopup = require('../../components/connectpopup');
var _ = require('../../../i18n').get;
var DROP_MIME_TYPES = require('../../mimetypes');
var UIInteraction4 = require('../../../../../libs/spotify-logger/messages/UIInteraction4');
var RateLimiter = require('../../../../../libs/spotify-rate-limiter');
var SWSaberBar = require('./sw-saber-bar');
var playerUtils = require('../../utils/player-utils');
var isStationUri = require('../../../../../libs/spotify-live-models/station').isStationUri;
var glue = require('../../../../../libs/spotify-glue-cat');

function PlayerUI(nowPlaying, history) {
  this.volumebarId = glue.getVersion() === 1 ? 'volumebar' : 'volumebar-glue2';

  this.volumebar = new OldProgressBar(this.volumebarId);

  // We need to override the left function for it to correctly calculate
  // volume on click/drag
  this.volumebar.left = function () {
    return this.element.getBoundingClientRect().left;
  };

  var self = this;
  // Make Now Playing available here so it can be used via "with" bindings in
  // knockout on the player UI.
  this.nowPlaying = nowPlaying;

  this._uri = '';
  this._entityUri = '';
  this.duration = ko.observable(0);
  this.error = false;
  this._unmutedVolume = 0;

  var progressBarElementId = glue.getVersion() === 1 ? 'progressbar' : 'progress-bar-glue2';

  this.progressbar = new ProgressBar(document.getElementById(progressBarElementId), this.duration());
  this.progressbar.disable();

  this.miniplayer = new MiniPlayer();

  this.desktopShuffleMode = shuffleMode.isEnabled();
  this.isNextMftDisallow = false;

  // Observables
  this.mute = ko.observable(false);
  this.volume = ko.observable(0);
  this.playing = ko.observable(false);
  this.actuallyPlaying = ko.observable(false);
  this.elapsed = ko.observable('');
  this.remaining = ko.observable('');
  this.remainingFormat = LocalSettings.get(this.CONFIG_REMAINING_TIME_FORMAT) || this.CONFIG_REMAINING_TIME_FORMAT_TOTAL;
  this.repeat = ko.observable(false);
  this.shuffle = ko.observable(false);
  this.showThumbs = ko.observable(false);
  this.trackThumbedDown = ko.observable(false);
  this.trackThumbedUp = ko.observable(false);
  this.thumbDownDisabled = ko.observable(false);
  this.thumbUpDisabled = ko.observable(false);
  // progressbarEnabled is used to be able to style an element outside
  // of the actual progress-bar (.progress-container).
  this.progressbarEnabled = ko.observable(false);
  this.connectIcon = ko.pureComputed(this._updateConnectIcon.bind(this));
  this.connectText = ko.pureComputed(this._updateConnectText.bind(this));
  this.connectTextStyle = ko.pureComputed(this._updateConnectTextStyle.bind(this));
  this.volumeIcon = ko.pureComputed(this._updateVolumeIcon.bind(this));
  this.repeatIcon = ko.pureComputed(function () {
    return self._repeatIcon(self.repeat());
  });
  this.previousEnabled = ko.observable(false);
  this.playEnabled = ko.observable(false);
  this.nextEnabled = ko.observable(false);
  this.shuffleEnabled = ko.observable(true);
  this.repeatEnabled = ko.observable(true);
  this.seekEnabled = ko.observable(false);
  this.online = ko.observable(true);
  this.connectPopup = null;
  this.queueEnabled = ko.observable(true);
  this.isDraggingProgressBar = ko.observable(false);

  this.queueDropMimetypes = ko.observable([DROP_MIME_TYPES.TRACKS, DROP_MIME_TYPES.ALBUMS].join('|'));

  var countryCode = global.__spotify && global.__spotify.product_state && global.__spotify.product_state.country_code;
  var isJapanCatalogueUser = countryCode === 'JP';
  this.lyricsEnabled = lyricsAppEnabled;

  var historyState = history.getLastState();
  this.queueVisible = ko.observable(PlayerUI.prototype.IS_QUEUE.test(historyState));
  this.lyricsVisible = ko.observable(PlayerUI.prototype.IS_LYRICS.test(historyState));

  // Handle drop targets
  center.on('drop', this.onDrop.bind(this));

  // button labels/tooltips
  this.playLabel = ko.pureComputed(function () {
    return this.playing() ? this.PAUSE_LABEL : this.PLAY_LABEL;
  }, this);
  this.previousLabel = ko.observable(this.PREV_LABEL);
  this.nextLabel = ko.observable(this.NEXT_LABEL);
  this.queueLabel = ko.observable(this.QUEUE_LABEL);
  this.shuffleLabel = ko.observable(this.SHUFFLE_LABEL);
  this.thumbUpLabel = ko.observable(this.THUMB_UP_LABEL);
  this.thumbDownLabel = ko.observable(this.THUMB_DOWN_LABEL);
  this.repeatLabel = ko.observable(this.REPEAT_LABEL);
  this.miniPlayerLabel = ko.pureComputed(function () {
    return self.miniplayer.isEnabled() ? self.RESTORE_PLAYER_WINDOW_LABEL : self.MINI_PLAYER_LABEL;
  });
  this.offlineLabel = ko.observable(this.OFFLINE_LABEL);
  this._initConnect();

  this.connectButtonEnabled = ko.observable(true);
  this.devicesAvailableVisible = this.connectPopup.devicesAvailableVisible;

  this.connectLabelOrEmpty = ko.pureComputed(function () {
    if (glue.getVersion() === 1) {
      return this.connectButtonEnabled() ? this.CONNECT_BUTTON_LABEL : '';
    }
    return this.CONNECT_BUTTON_LABEL;
  }, this);

  this.volume.subscribe(function (newVolume) {
    if (newVolume !== 0) {
      this._unmutedVolume = newVolume;
    }
    this.volumebar.progress(newVolume);
  }, this);

  this.actuallyPlaying.subscribe(function (value) {
    if (value) {
      this.progressbar.play();
    } else {
      this.progressbar.pause();
    }
  }, this);

  this.duration.subscribe(function (value) {
    this.progressbar.setMaxValue(value);
  }, this);

  this.progressbar.addListener('drag-start', function () {
    this.isDraggingProgressBar(true);
  }.bind(this));

  this.progressbar.addListener('drag-end', function () {
    this.isDraggingProgressBar(false);
  }.bind(this));

  // Allow one log transaction per second
  this._logRateLimiter = new RateLimiter(1);

  this.swEnabled = ko.observable(false);
  this.swSaberColor = ko.observable('');
  this.swSaberHilt = ko.observable('');
  this.swSaberBar = new SWSaberBar(function (enabled, color, hilt) {
    this.swEnabled(enabled);
    this.swSaberColor(color);
    this.swSaberHilt(hilt);
  }.bind(this), this._logUIInteraction4.bind(this));
  this.swToggleHilt = this.swSaberBar.toggleHilt;
}

PlayerUI.prototype.CONFIG_REMAINING_TIME_FORMAT = 'remainingTimeFormat';
PlayerUI.prototype.CONFIG_REMAINING_TIME_FORMAT_TOTAL = 'total';
PlayerUI.prototype.CONFIG_REMAINING_TIME_FORMAT_ETA = 'eta';
PlayerUI.prototype.QUEUE_URI = 'spotify:app:zlink-queue';
PlayerUI.prototype.IS_QUEUE = new RegExp('^' + PlayerUI.prototype.QUEUE_URI + '($|:)');
PlayerUI.prototype.LYRICS_URI = 'spotify:app:lyrics';
PlayerUI.prototype.IS_LYRICS = new RegExp('^(' + PlayerUI.prototype.LYRICS_URI + ')($|:)');

PlayerUI.prototype.PLAYER_LABEL = _('player.label');
PlayerUI.prototype.SHUFFLE_LABEL = _('player.shuffle_mode_label');
PlayerUI.prototype.REPEAT_LABEL = _('player.repeat_mode_label');
PlayerUI.prototype.QUEUE_LABEL = _('player.queue');
PlayerUI.prototype.PLAY_LABEL = _('player.play_button_label');
PlayerUI.prototype.PAUSE_LABEL = _('player.pause_button_label');
PlayerUI.prototype.PREV_LABEL = _('player.previous_button_label');
PlayerUI.prototype.NEXT_LABEL = _('player.next_button_label');
PlayerUI.prototype.OFFLINE_LABEL = _('player.offline_label');
PlayerUI.prototype.CONNECT_BUTTON_LABEL = _('player.connect_button_label');
PlayerUI.prototype.CONNECT_BUTTON_TEXT = _('connect.devices_available');
PlayerUI.prototype.VOLUME_BUTTON_LABEL = _('player.volume_button_label');
PlayerUI.prototype.LYRICS_LABEL = _('player.lyrics_label');
PlayerUI.prototype.MINI_PLAYER_LABEL = _('player.mini_player_label');
PlayerUI.prototype.THUMB_UP_LABEL = _('player.thumb_up_label');
PlayerUI.prototype.THUMB_DOWN_LABEL = _('player.thumb_down_label');
PlayerUI.prototype.RESTORE_PLAYER_WINDOW_LABEL = _('player.restore_player_window_label');

PlayerUI.prototype.NO_REPEAT = 0;
PlayerUI.prototype.REPEAT_ALL = 1;
PlayerUI.prototype.REPEAT_ONE = 2;

PlayerUI.prototype.VOLUME_STEP = 0.2;

/**
 * Setup functionality
 *
 * @return {PlayerUI} The instance.
 */
PlayerUI.prototype.setup = function () {
  var self = this;

  this.progressbar.addListener('update', this._onProgressBarUpdate.bind(this));

  this.progressbar.addListener('progress', this._onProgressBarProgress.bind(this));

  eventDispatcher.addEventListener(Event.TYPES.UI_DRAG, this._onProgressBarDrag.bind(this));

  eventDispatcher.addEventListener(Event.TYPES.UI_DRAG_END, this._onProgressBarDragEnd.bind(this));

  this._registerKeyboardShortcuts();

  eventDispatcher.addEventListener(Event.TYPES.NAVIGATION_STATE_CHANGE, function (e) {
    self.queueVisible(PlayerUI.prototype.IS_QUEUE.test(e.params.uri));
    self.lyricsVisible(PlayerUI.prototype.IS_LYRICS.test(e.params.uri));
  });

  eventDispatcher.addEventListener(Event.TYPES.CONNECTION_STATE_CHANGE, this._onConnectionStateChange.bind(this));

  eventDispatcher.addEventListener(Event.TYPES.AD_CLICK_VIDEO_STARTED, this._onClickVideoAdStart.bind(this));

  eventDispatcher.addEventListener(Event.TYPES.AD_CLICK_VIDEO_ENDED, this._onClickVideoAdEnd.bind(this));

  this.miniplayer.setup();

  var updateProgressBarState = function updateProgressBarState() {
    if (self.seekEnabled() && !self.miniplayer.isEnabled()) {
      self.enableProgressBar();
    } else {
      self.disableProgressBar();
    }
  };

  this.miniplayer.isEnabled.subscribe(updateProgressBarState);
  // This handle is never called for shuffle, because seekEnabled is false
  // initially. That's okay because the progress bar is disabled by default,
  // both on this.progressbar and this.progressbarEnabled(false).
  this.seekEnabled.subscribe(updateProgressBarState);

  return this;
};

/**
 * Adds video class to progress bar when video starts
 * to change color
 *
 * @return {void}
 */
PlayerUI.prototype._onClickVideoAdStart = function () {
  this.progressbar.getContainer().classList.add('video-ad');
};

/**
 * Removes video class to progress bar when video ends
 * to change color
 *
 * @return {void}
 */
PlayerUI.prototype._onClickVideoAdEnd = function () {
  this.progressbar.getContainer().classList.remove('video-ad');
};

/**
 * Helper method to log player UIInteraction4 messages.
 */
PlayerUI.prototype._logUIInteraction4 = function (interactionType, userIntent) {
  if (this._logRateLimiter.acquire()) {
    UIInteraction4.log({
      'feature_id': 'zlink',
      'section_id': 'player',
      'interaction_type': interactionType,
      'user_intent': userIntent
    });
  }
};

/**
 * Helper method to extract information from the player state restrictions
 */
PlayerUI.prototype._isAllowed = function (restrictions, key) {
  var restriction = restrictions['disallow_' + key + '_reasons'];
  return !restriction || restriction.length === 0;
};

PlayerUI.prototype.updatePlayerState = function (data) {
  if (!data) return;

  // Hide Queue & Lyrics for Desktop Shuffle Tier test
  if (this.desktopShuffleMode) {
    this.queueEnabled(false);
    this.lyricsEnabled(false);
  }

  if (data.track && data.track.uri !== this.uri) {
    this._uri = data.track.uri;
    this.playEnabled(true);
    this.miniplayer.updatePlayerState(data);
  }

  this.duration(data.duration || 0);

  var playOptions = data.options;
  var restrictions = data.restrictions;

  this._entityUri = data.entity_uri;

  // Update Repeat Button
  //
  // repeating_track track can be true when repeating_context is false
  // but they can also both be true. Both cases mean "repeat one".
  var repeat = 0;
  if (playOptions.repeating_context) {
    repeat = this.REPEAT_ALL;
  }
  if (playOptions.repeating_track) {
    repeat = this.REPEAT_ONE;
  }
  this.repeat(repeat);
  this.repeatEnabled(this._isAllowed(restrictions, 'toggling_repeat_context') || this._isAllowed(restrictions, 'toggling_repeat_track'));

  // Update Shuffle Button
  this.shuffleEnabled(this._isAllowed(restrictions, 'toggling_shuffle') || this.desktopShuffleMode);
  this.shuffle(playOptions.shuffling_context || this.desktopShuffleMode);

  var canSeek = data.track && this._isAllowed(restrictions, 'seeking');
  this.seekEnabled(canSeek);

  // Update skip buttons
  var canSkipPrev = this._isAllowed(restrictions, 'skipping_prev');
  this.previousEnabled(canSkipPrev || canSeek);

  var skipNextReasons = restrictions.disallow_skipping_next_reasons;
  this.isNextMftDisallow = !!(skipNextReasons && skipNextReasons.length === 1 && skipNextReasons[0] === 'mft_disallow');
  this.nextEnabled(this._isAllowed(restrictions, 'skipping_next') || this.isNextMftDisallow);

  var now = new Date().getTime();

  var playbackSpeed = parseFloat(data.playback_speed, 10) || 0;
  this.progressbar.setPlaybackSpeed(playbackSpeed);

  var progressedSinceStateMeasured = (now - (data.timestamp || now)) * (data.playback_speed || 0);

  var calculatedProgress = (data.position_as_of_timestamp || 0) + progressedSinceStateMeasured;
  var currentTrackProgress = Math.max(0, Math.min(data.duration || 0, calculatedProgress));
  this.progressbar.setValue(currentTrackProgress);

  this.playing(data.is_playing && !data.is_paused);

  this.actuallyPlaying(data.is_playing && !data.is_paused && !data.is_buffering);

  // Update "added" state
  var nowPlaying = document.querySelector('.now-playing-container');
  if (nowPlaying) {
    addEvents.update(nowPlaying);
  }

  // Show/Hide/Disable Thumbs
  if (isStationUri(data.entity_uri)) {
    this.showThumbs(true);
    var thumb = data.track && data.track.metadata ? data.track.metadata['radio.thumb'] : false;

    if (thumb === 'up') {
      this.trackThumbedUp(true);
      this.thumbDownDisabled(true);
    } else if (thumb === 'down') {
      this.trackThumbedDown(true);
      this.thumbUpDisabled(true);
    } else {
      if (!data.track || playerUtils.isTrackAd(data.track) || playerUtils.isTrackFromQueue(data.track)) {
        this.thumbDownDisabled(true);
        this.thumbUpDisabled(true);
      } else {
        this.thumbDownDisabled(false);
        this.thumbUpDisabled(false);
      }
      this.trackThumbedUp(false);
      this.trackThumbedDown(false);
    }
  } else {
    this.showThumbs(false);
  }
};

PlayerUI.prototype._onProgressBarProgress = function (evt) {
  this.updateProgressBarLabels(evt.value);
};

PlayerUI.prototype._onProgressBarUpdate = function (evt) {
  this.seek(evt.value);
  this._logUIInteraction4('drag', 'seek-to-position');
};

// This is called many times while dragging.
PlayerUI.prototype._onProgressBarDrag = function (e) {
  if (e.params.progressBarId === this.volumebarId) {
    this._updateVolume(e.params.progress);
  }
};

// This is called once dragging ends.
PlayerUI.prototype._onProgressBarDragEnd = function (e) {
  if (e.params.progressBarId === this.volumebarId) {
    this._updateVolume(e.params.progress);
    this._logUIInteraction4('drag', 'change-volume');
  }
};

PlayerUI.prototype._initConnect = function () {
  var connectHelper = new ConnectHelper();
  connectHelper.setup();

  var self = this;
  eventDispatcher.addEventListener(Event.TYPES.SPCONNECT_DEVICE_STATE, function () {
    if (connectHelper.isActiveDeviceVolumeCapable()) {
      self.enableVolumeBar();
    } else {
      self.disableVolumeBar();
    }
  });

  this.remotePlaybackBar = new RemotePlaybackBar();
  this.connectPopup = new ConnectPopup(connectHelper);
};

PlayerUI.prototype._registerKeyboardShortcuts = function () {
  var self = this;

  // Play/pause with SPACE
  Keyboard.registerShortcut(Keyboard.KEYS.SPACE, function (e) {
    e.preventDefault();

    var userIntent = self.playing() ? 'pause' : 'play';
    self._doTogglePlay();
    self._logUIInteraction4('keyboard-shortcut', userIntent);
  });

  // Prev track with ctrl+left
  Keyboard.registerShortcut({
    key: Keyboard.KEYS.ARROW_LEFT,
    ctrl: true
  }, function (e) {
    e.preventDefault();

    self._doSkipToPrevious();
    self._logUIInteraction4('keyboard-shortcut', 'skip-to-previous');
  });

  // Next track with ctrl+right
  Keyboard.registerShortcut({
    key: Keyboard.KEYS.ARROW_RIGHT,
    ctrl: true
  }, function (e) {
    e.preventDefault();

    self._doSkipToNext();
    self._logUIInteraction4('keyboard-shortcut', 'skip-to-next');
  });

  // Volume UP with ctrl+up
  Keyboard.registerShortcut({
    key: Keyboard.KEYS.ARROW_UP,
    ctrl: true
  }, function (e) {
    e.preventDefault();

    self.increaseVolume();
    self._logUIInteraction4('keyboard-shortcut', 'increase-volume');
  });

  // Volume DOWN with ctrl+down
  Keyboard.registerShortcut({
    key: Keyboard.KEYS.ARROW_DOWN,
    ctrl: true
  }, function (e) {
    e.preventDefault();

    self.decreaseVolume();
    self._logUIInteraction4('keyboard-shortcut', 'decrease-volume');
  });

  // Toggle MUTE with CTRL SHIFT DOWN
  Keyboard.registerShortcut({
    key: Keyboard.KEYS.ARROW_DOWN,
    ctrl: true,
    shift: true
  }, function (e) {
    e.preventDefault();

    var userIntent = this.mute() ? 'unmute' : 'mute';
    self._doToggleMute();
    self._logUIInteraction4('keyboard-shortcut', userIntent);
  });

  // Maximise volume with CTRL SHIFT UP
  Keyboard.registerShortcut({
    key: Keyboard.KEYS.ARROW_UP,
    ctrl: true,
    shift: true
  }, function (e) {
    e.preventDefault();

    self.maxVolume();
    self._logUIInteraction4('keyboard-shortcut', 'maximize-volume');
  });

  // Toodle devices with ctrl+d
  Keyboard.registerShortcut({
    key: Keyboard.KEYS.D,
    ctrl: true
  }, function (e) {
    e.preventDefault();

    var show = !self.connectPopup.visible();
    if (show) {
      self.connectPopup.show();
      self._logUIInteraction4('keyboard-shortcut', 'show-connect-device-list');
    } else {
      self.connectPopup.hide();
      self._logUIInteraction4('keyboard-shortcut', 'hide-connect-device-list');
    }
  });
};

// Facade methods to keep the progressbar control more encapsulated and
// reduce coupling from external objects
PlayerUI.prototype.enableProgressBar = function () {
  this.progressbar.enable();
  this.progressbarEnabled(true);
};

PlayerUI.prototype.disableProgressBar = function () {
  this.progressbar.disable();
  this.progressbarEnabled(false);
};

PlayerUI.prototype.enableVolumeBar = function () {
  this.volumebar.enabled(true);
};

PlayerUI.prototype.disableVolumeBar = function () {
  this.volumebar.enabled(false);
};

PlayerUI.prototype.toggleMiniPlayer = function () {
  controlMessagesHandler.send({ type: 'toggle_mini_player' });
};

/**
 * Toggle mute
 */
PlayerUI.prototype.toggleMute = function () {
  var userIntent = this.mute() ? 'unmute' : 'mute';
  this._doToggleMute();
  this._logUIInteraction4('click', userIntent);
};

PlayerUI.prototype._doToggleMute = function () {
  this.changeVolume(this._unmutedVolume, !this.mute());
};

PlayerUI.prototype.onClickAtConnectButton = function () {
  if (this.connectButtonEnabled()) {
    this.toggleConnectDeviceList();
  }
};

/**
 * Change the css class for the connect icon
 * according to the volume value
 */
PlayerUI.prototype._updateConnectIcon = function () {
  var iconClass = this.connectPopup.currentDeviceTechIcon();
  if (this.remotePlaybackBar.visible()) {
    if (glue.getVersion() === 1) {
      iconClass.push('remote');
    } else {
      iconClass.push('connect-active');
    }
  }
  return iconClass.join(' ');
};

PlayerUI.prototype._updateConnectText = function () {
  if (this.connectPopup.isPlayingRemotely()) {
    // Show device name if playing remotley
    return this.connectPopup.currentDevice().name;
  }
  return this.CONNECT_BUTTON_TEXT;
};

PlayerUI.prototype._updateConnectTextStyle = function () {
  var iconClass = [];
  if (this.remotePlaybackBar.visible()) {
    iconClass.push('remote');
  }
  return iconClass.join(' ');
};

/**
 * Change the css class for the volume icon
 * according to the volume value
 */
PlayerUI.prototype._updateVolumeIcon = function (volume) {
  var iconClass = [];
  if (volume === undefined) {
    volume = this.volume();
  }
  var volumeClass = 'spoticon-volume';
  if (volume === 0) {
    volumeClass += '-off';
  } else if (volume <= 1 / 3) {
    volumeClass += '-onewave';
  } else if (volume <= 2 / 3) {
    volumeClass += '-twowave';
  }
  volumeClass += '-16';
  iconClass.push(volumeClass);

  var isGlue2 = glue.getVersion() === 2;

  if (isGlue2 || !this.connectButtonEnabled()) {
    iconClass.push('button-no-hover');
  }
  return iconClass.join(' ');
};

/**
 * Change the css class for the repeat icon
 * according to the repeat mode
 */
PlayerUI.prototype._repeatIcon = function (repeat) {
  var iconClass = 'spoticon-repeat';
  // Repeat track can be either 2 or 3, since the bit
  // for repeat context doesn't matter
  if ((repeat & this.REPEAT_ONE) === this.REPEAT_ONE) {
    iconClass += 'once';
  }
  iconClass += '-16';
  if (repeat !== this.NO_REPEAT) {
    iconClass += ' active';
  }
  return iconClass;
};

/**
 * Seek to a position in the song
 *
 * @param {Number} position The position to seek to.
 */
PlayerUI.prototype.seek = function (position) {
  eventDispatcher.dispatchEvent(new Event(Event.TYPES.PLAYER_SEEK, position));
};

/**
 * Change the volume
 *
 * @param {Number} unmutedVolume The new volume, ignoring muting
 * @param {Boolean?} mute If the volume is muted, defaults to false
 */
PlayerUI.prototype.changeVolume = function (unmutedVolume, mute) {
  unmutedVolume = Math.min(1, Math.max(0, unmutedVolume));
  mute = mute || false;

  // real volume, also considering muting
  var volume = mute ? 0 : unmutedVolume;

  if (this.volume() !== volume) {
    eventDispatcher.dispatchEvent(new Event(Event.TYPES.PLAYER_VOLUME, volume));
    this.volume(volume);
    this._unmutedVolume = unmutedVolume;
    this.mute(mute);
  }
};

PlayerUI.prototype._updateVolume = function (volume) {
  this.changeVolume(Math.round(volume * 100) / 100);
};

PlayerUI.prototype.maxVolume = function () {
  this.changeVolume(1);
};

PlayerUI.prototype.increaseVolume = function () {
  this.changeVolume(this.volume() + this.VOLUME_STEP);
};

PlayerUI.prototype.decreaseVolume = function () {
  this.changeVolume(this.volume() - this.VOLUME_STEP);
};

/**
 * Callback function for when skip to previous has been clicked.
 */
PlayerUI.prototype.skipToPrevious = function () {
  this._doSkipToPrevious();
  this._logUIInteraction4('click', 'skip-to-previous');
};

PlayerUI.prototype._doSkipToPrevious = function () {
  eventDispatcher.dispatchEvent(new Event(Event.TYPES.PLAYER_PREV));
};

/**
 * Callback function for when skip to next has been clicked.
 */
PlayerUI.prototype.skipToNext = function () {
  if (this.isNextMftDisallow) {
    this._showShuffleRanOutOfSkipsUpsell();
    return;
  }

  this._doSkipToNext();
  this._logUIInteraction4('click', 'skip-to-next');
};

PlayerUI.prototype._doSkipToNext = function () {
  eventDispatcher.dispatchEvent(new Event(Event.TYPES.PLAYER_NEXT));
};

/**
 * Callback function for when play/pause has been clicked.
 */
PlayerUI.prototype.togglePlay = function () {
  var userIntent = this.playing() ? 'pause' : 'play';
  this._doTogglePlay();
  this._logUIInteraction4('click', userIntent);
};

PlayerUI.prototype._doTogglePlay = function () {
  var type = this.playing() ? Event.TYPES.PLAYER_PAUSE : Event.TYPES.PLAYER_RESUME;
  eventDispatcher.dispatchEvent(new Event(type));
};

/**
 * Callback function for when shuffle button has been clicked.
 *
 * @param {PlayerUI} model The instance of the model.
 * @param {Event} e The event that's been triggered.
 */
PlayerUI.prototype.toggleShuffle = function () {
  if (this.desktopShuffleMode) {
    this._showShuffleModeUpsell();
    return;
  }

  var shuffle = !this.shuffle();
  eventDispatcher.dispatchEvent(new Event(Event.TYPES.PLAYER_SHUFFLE, shuffle));
  this.shuffle(shuffle);
  this._logUIInteraction4('click', shuffle ? 'enable-shuffle' : 'disable-shuffle');
};

/**
 * Callback function for when repeat button has been clicked.
 *
 * @param {PlayerUI} model The instance of the model.
 * @param {Event} e The event that's been triggered.
 */
PlayerUI.prototype.toggleRepeat = function () {
  if (this.repeatEnabled()) {
    var repeat = (this.repeat() + 1) % 3;
    eventDispatcher.dispatchEvent(new Event(Event.TYPES.PLAYER_REPEAT, repeat));
    var userIntents = ['disable-repeat', 'enable-repeat', 'enable-repeat-one'];
    this._logUIInteraction4('click', userIntents[repeat]);
  }
};

/**
 * Click function for the thumbUp button
 */
PlayerUI.prototype.thumbUp = function () {
  if (this.trackThumbedUp()) return;
  eventDispatcher.dispatchEvent(new Event(Event.TYPES.THUMB_UP, {
    trackUri: this._uri,
    entityUri: this._entityUri
  }));
  this._logUIInteraction4('click', 'thumb-up');
};

/**
 * Click function for the thumbDown button
 */
PlayerUI.prototype.thumbDown = function () {
  if (this.trackThumbedDown()) return;
  eventDispatcher.dispatchEvent(new Event(Event.TYPES.THUMB_DOWN, {
    trackUri: this._uri,
    entityUri: this._entityUri
  }));
  this._logUIInteraction4('click', 'thumb-down');
};

/**
 * Update the two labels that are depending on the current progress.
 *
 * @param {Number?} position The position.
 * @param {Number?} duration The duration.
 */
PlayerUI.prototype.updateProgressBarLabels = function (position, duration) {
  if (position === undefined) position = this.progressbar.getRealValue();
  if (duration === undefined) duration = this.progressbar.getMaxValue();
  if (!position && !duration) {
    this.elapsed(null);
    this.remaining(null);
  } else {
    this.elapsed(this._formatTime(position));
    if (this.remainingFormat === this.CONFIG_REMAINING_TIME_FORMAT_TOTAL) {
      this.remaining(this._formatTime(duration));
    } else {
      this.remaining(this._formatTime(-(duration - position)));
    }
  }
};

/**
 * Toggles the mode the remaining time for the track is visualized.
 * It can be either the total time of the track or the remaining
 */
PlayerUI.prototype.toggleRemainingTimeFormat = function () {
  var userIntent;
  if (this.remainingFormat === this.CONFIG_REMAINING_TIME_FORMAT_TOTAL) {
    this.remainingFormat = this.CONFIG_REMAINING_TIME_FORMAT_ETA;
    userIntent = 'show-remaining-time';
  } else {
    this.remainingFormat = this.CONFIG_REMAINING_TIME_FORMAT_TOTAL;
    userIntent = 'show-total-time';
  }
  this.updateProgressBarLabels();
  LocalSettings.set(this.CONFIG_REMAINING_TIME_FORMAT, this.remainingFormat);
  this._logUIInteraction4('click', userIntent);
};

PlayerUI.prototype.openLyrics = function () {
  var event = new Event(Event.TYPES.NAVIGATION_OPEN_URI, this.LYRICS_URI, { toggle: true });
  eventDispatcher.dispatchEvent(event);
  this._logUIInteraction4('click', 'open-lyrics');
};

PlayerUI.prototype.openQueue = function () {
  var event = new Event(Event.TYPES.NAVIGATION_OPEN_URI, this.QUEUE_URI, { toggle: true });
  eventDispatcher.dispatchEvent(event);
  this._logUIInteraction4('click', 'open-queue');
};

/**
 * Handle when someone drops something on the player.
 * Plays the uri (or first uri in the list if multiple dropped).
 *
 * @param {PlayerUI} model This model.
 * @param {MouseEvent} e The event triggered.
 */
PlayerUI.prototype.onDrop = function (event) {
  var tracks = event.data[DROP_MIME_TYPES.TRACKS];
  var albums = event.data[DROP_MIME_TYPES.ALBUMS];

  if (event.node.id === 'queue') {
    this._enqueue(tracks, albums);
  }
};

PlayerUI.prototype._enqueue = function (tracks, albums) {
  if (tracks && tracks.length) {
    QueueModel.addTracksToQueue(tracks);
    this._logUIInteraction4('drop', 'queue-tracks');
  } else if (albums && albums.length) {
    QueueModel.addContextToQueue(albums[0], 'album');
    this._logUIInteraction4('drop', 'queue-album');
  }
};

/**
 * Helper function to transform a time in ms to a string looking like "0:04".
 *
 * @private
 * @param {Number} ms Time in milliseconds.
 * @return {String} The formatted string.
 */
PlayerUI.prototype._formatTime = function (ms) {
  var isNegative = ms < 0;
  var sec = Math.floor(Math.abs(ms) / 1000);
  var min = Math.floor(sec / 60);
  sec %= 60;
  if (sec < 10) {
    sec = '0' + sec;
  }
  if (isNegative) {
    min = '-' + min;
  }
  return [min, sec].join(':');
};

PlayerUI.prototype._onConnectionStateChange = function (e) {
  this.online(e.params.status === 'online');
};

/**
 * Toggles the connect and volume dialog
 */
PlayerUI.prototype.toggleConnectDeviceList = function () {
  if (!this.connectPopup.visible()) {
    this.connectPopup.show();
    this._logUIInteraction4('click', 'show-connect-device-list');
  } else {
    this.connectPopup.hide();
    this._logUIInteraction4('click', 'hide-connect-device-list');
  }
};

/**
  * Display blue upsell bar for not allowed plays in shuffle mode
  */
PlayerUI.prototype._showShuffleModeUpsell = function () {
  require('spotify-cosmos-api').resolver.post({
    url: 'sp://messages/v1/container/user-message',
    body: {
      description: 'Shuffle cannot be disabled because ' + '"shuffle mode" is enabled',
      id: 'shuffle-unplayable-track'
    }
  }, function () {});
};

/**
  * Display blue upsell bar for running out of skips in shuffle mode
  */
PlayerUI.prototype._showShuffleRanOutOfSkipsUpsell = function () {
  require('spotify-cosmos-api').resolver.post({
    url: 'sp://messages/v1/container/user-message',
    body: {
      description: 'Cannot skip anymore beecause "shuffle mode" is enabled',
      id: 'shuffle-ran-out-of-skips'
    }
  }, function () {});
};

module.exports = PlayerUI;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../../../../libs/spotify-event-dispatcher":264,"../../../../../libs/spotify-events/add":265,"../../../../../libs/spotify-events/center":268,"../../../../../libs/spotify-glue-cat":348,"../../../../../libs/spotify-live-models/station":424,"../../../../../libs/spotify-logger/messages/UIInteraction4":452,"../../../../../libs/spotify-progressbar":487,"../../../../../libs/spotify-rate-limiter":490,"../../../../../libs/spotify-shuffle-mode":491,"../../../i18n":11,"../../components/connectpopup":32,"../../components/progressbar":68,"../../components/remoteplaybackbar":69,"../../connecthelper":72,"../../controlmessageshandler":74,"../../event":77,"../../keyboard":83,"../../mimetypes":98,"../../models/localsettings":100,"../../models/queue":104,"../../utils/player-utils":125,"./miniplayer":163,"./sw-saber-bar":166,"knockout":567,"spotify-cosmos-api":694}],166:[function(require,module,exports){
'use strict';

var Player = require('../../models/player');
var spuri = require('spotify-liburi');
var wrappedUriUtils = require('../../../../../libs/spotify-live-wrapped-uri');
var abba = require('../../../../../libs/spotify-abba-mini');
var debug = require('debug')('sw-saber-bar');

var ALBUM_ID_WHITELIST = [
// The Force Awakens Soundtrack (Known Markets as of 2015-12-17)
'b48c87c5b9774f4da039fd1ea4078787', '6b0141996fe74dc1a56f22d7d61e0ab9', 'eaf8926e44f84cfdb01d4fbc1df16f7e', '3255b4cd003b4fe0a5b2418f03a758ba', 'c641ced6c4be48a1ae79831706382395', '9fb694faf78f48979fa581d77bf6337a', '6787821ecbbb459e81577ec168f1b184', '3a68cc0da479405382afb88b4feea7d7', 'df80719065844a869453ba3007871728', '6c51a6f8f5b742a7876291df14578eb0', 'f0cc025ff6ac4b6582aa14add681dfa2', '76923bd3c18c4e5787e1809426563866'];

function SWSaberBar(onStateChange, logUIInteraction4) {
  this.state = {
    enabled: false,
    currentPair: SWSaberBar.PAIRS[0],
    currentPairIndex: 0,
    contextOwnerMatchesAbba: false,
    cheatCodeOverride: false,
    featureEnabled: false,
    keycodes: []
  };

  this._logUIInteraction4 = logUIInteraction4;
  this._onKeyPress = this._onKeyPress.bind(this);
  this._onPlayerStateChange = this._onPlayerStateChange.bind(this);
  // This will be exposed, ensure `this` is always valid.
  this.toggleHilt = this.toggleHilt.bind(this);

  var player = Player.getPlayer();
  player.subscribe(this._onPlayerStateChange);
  window.addEventListener('keypress', this._onKeyPress);
  // Nothing else has a `destroy` or `unbind` method in player-ui, so not worth
  // keeping track of subscribe handle or unbinding keypresses.

  this.setState = function (state) {
    var old = this.state;
    this.state = Object.assign({}, old, state);

    // reduce
    this.state.enabled = this.state.featureEnabled && (this.state.cheatCodeOverride || this.state.contextOwnerMatchesAbba);

    onStateChange(this.state.enabled, this.state.currentPair.color, this.state.currentPair.hilt);
  };

  abba('sw-saber-progressbar', function (err, cell) {
    var enabled = !err && cell === 'Enabled';
    debug('featureEnabled?', enabled);
    this.setState({ featureEnabled: enabled });
  }.bind(this));
}

SWSaberBar.PAIRS = [{ color: 'blue', hilt: 'anakin' }, { color: 'green', hilt: 'luke' }, { color: 'red', hilt: 'vader' }];

SWSaberBar.prototype.toggleHilt = function () {
  var idx = this.state.currentPairIndex;
  var max = SWSaberBar.PAIRS.length - 1;
  var newIdx = idx === max ? 0 : idx + 1;
  var newPair = SWSaberBar.PAIRS[newIdx];
  this._logUIInteraction4('click', 'toggle-sw-hilt-' + newPair.hilt);
  this.setState({
    currentPair: newPair,
    currentPairIndex: newIdx
  });
};

// THX1138 in US `which` keys, concatenated
SWSaberBar.OVERRIDE_PHRASE = '84728849495156';

SWSaberBar.prototype._onKeyPress = function (e) {
  var max = SWSaberBar.OVERRIDE_PHRASE.length;
  var codes = this.state.keycodes;
  codes.push(e.which);

  while (codes.length > max) {
    codes.shift();
  }

  var overrideFound = codes.join('').indexOf(SWSaberBar.OVERRIDE_PHRASE) > -1;
  var cheatCodeOverride = this.state.cheatCodeOverride;

  debug('keycodes %o', codes);

  if (overrideFound) {
    codes.length = 0;
    cheatCodeOverride = !cheatCodeOverride;
    debug('cheatCodeOverride', cheatCodeOverride);
  }

  this.setState({
    codes: codes,
    cheatCodeOverride: cheatCodeOverride
  });
};

SWSaberBar.prototype._onPlayerStateChange = function (err, data) {
  if (err) {
    return this.setState({ contextOwnerMatchesAbba: false });
  }

  var body = data.getJSONBody();
  if (!body.context_uri) {
    return this.setState({ contextOwnerMatchesAbba: false });
  }

  var unwrapped = null;

  // The context could be wrapped, such as a filterlist.
  if (wrappedUriUtils.isValid(body.context_uri)) {
    unwrapped = wrappedUriUtils.parse(body.context_uri).originUri;
  } else {
    unwrapped = body.context_uri;
  }

  var uri = spuri.from(unwrapped);

  var isWhitelistedPlaylistOwner = uri && uri.type === spuri.Type.PLAYLIST && (uri.username === 'official_star_wars' || uri.username === 'team_kylo' || uri.username === 'team_rey');

  // Best of Star Wars by Spotify
  // spotify:user:spotify:playlist:09H7xj3DbNhS8gbJg0biU0
  var isBestOfStarWars = uri && uri.type === spuri.Type.PLAYLIST && uri.username === 'spotify' && uri.id === '05235c5db808b0dd07b88fa7046e0040';

  var isWhitelistedAlbum = uri && uri.type === spuri.Type.ALBUM && ALBUM_ID_WHITELIST.indexOf(uri.id) > -1;

  var matches = isWhitelistedAlbum || isWhitelistedPlaylistOwner || isBestOfStarWars;

  this.setState({
    contextOwnerMatchesAbba: matches
  });
};

module.exports = SWSaberBar;

},{"../../../../../libs/spotify-abba-mini":181,"../../../../../libs/spotify-live-wrapped-uri":438,"../../models/player":101,"debug":526,"spotify-liburi":707}],167:[function(require,module,exports){
'use strict';

var utils = require('../../utils');
var BasePlayer = require('./base');
var SPVideoManager = require('../../../../../libs/spotify-video-manager');
var cosmos = require('spotify-cosmos-api');

function noop() {}

function VideoPlayer(view) {
  BasePlayer.apply(this, arguments);
  this._attached = false;
  this._view = view;
  this._unsubscribeToVolume = noop;
  this._updateView = this._updateView.bind(this);
}

utils.inherit(VideoPlayer, BasePlayer);

VideoPlayer.prototype.attach = function () {
  if (this._attached) return;
  this._attached = true;
  this.setVolume(this._view.volume() || 0);
  SPVideoManager.subscribe(undefined, this._updateView);
  this._unsubscribeToVolume = this._subscribeToVolume().cancel;
  this._updateView();
};

VideoPlayer.prototype.detach = function () {
  if (!this._attached) return;
  this._attached = false;
  SPVideoManager.unsubscribe(undefined, this._updateView);
  this._unsubscribeToVolume();
};

VideoPlayer.prototype.updateView = function (playerState) {
  if (!this._attached) return;
  this._view.updatePlayerState(playerState);
};

VideoPlayer.prototype.resume = function () {
  SPVideoManager.getActiveVideo().play();
};

VideoPlayer.prototype.pause = function () {
  SPVideoManager.getActiveVideo().pause();
};

VideoPlayer.prototype.setVolume = function (volume) {
  this._setVolume(volume);
  cosmos.resolver.resolve(new cosmos.Request(cosmos.Action.PUT, 'sp://playback/v1/volume', null, { volume: volume }));
};

VideoPlayer.prototype._getPlayerState = function () {
  var video = SPVideoManager.getActiveVideo();

  return {
    duration: video.get('duration') * 1000,
    timestamp: Date.now(),
    options: {},
    playback_speed: 1,
    position_as_of_timestamp: video.get('currentTime') * 1000,
    is_playing: video.get('isPlaying'),
    is_paused: !video.get('isPlaying'),
    is_buffering: video.get('isBuffering'),
    restrictions: {
      disallow_toggling_repeat_context_reasons: true,
      disallow_toggling_repeat_track_reasons: true,
      disallow_toggling_shuffle_reasons: true,
      disallow_seeking_reasons: true,
      disallow_skipping_prev_reasons: true,
      disallow_skipping_next_reasons: true
    }
  };
};

VideoPlayer.prototype._updateView = function () {
  this.updateView(this._getPlayerState());
};

VideoPlayer.prototype._setVolume = function (volume) {
  SPVideoManager.setVolume(volume * 0.7);
};

VideoPlayer.prototype._subscribeToVolume = function () {
  return cosmos.resolver.subscribe('sp://playback/v1/volume', function (error, response) {
    if (!error) return;
    var volume = response.getJSONBody().volume;
    this._setVolume(volume);
    if (this._view.volumebar.dragging) return;
    this._view.volume(volume);
    if (volume !== 0) this._view.mute(false);
  }.bind(this));
};

module.exports = VideoPlayer;

},{"../../../../../libs/spotify-video-manager":493,"../../utils":120,"./base":162,"spotify-cosmos-api":694}],168:[function(require,module,exports){
'use strict';

var ko = require('knockout');
var session = require('../models/session');
var Event = require('../event');
var _ = require('../../i18n').get;
var live = require('../../../../libs/spotify-live');
var eventDispatcher = require('../../../../libs/spotify-event-dispatcher');
var eventsCenter = require('../../../../libs/spotify-events/center');
var bridge = require('../../../../libs/spotify-bridge-request');
var UIInteraction4 = require('../../../../libs/spotify-logger/messages/UIInteraction4');
var glue = require('../../../../libs/spotify-glue-cat');
var abba = require('../../../../libs/spotify-abba-mini');

var glueVersion = glue.getVersion();

var PROFILE_MENU_POPOVER_ID = 'profilemenu';

/**
 * View Model for the profile menu area.
 *
 * @constructor
 */
function ProfileMenu() {
  this._activeElement = null;

  this.spotifyUsername = session.getUsername();

  // Observables
  this.username = ko.observable(this.spotifyUsername);
  this.privateSession = ko.observable(false);
  this.avatar = ko.observable();
  this.menuVisible = ko.observable(false);
  this.avatarClass = ko.pureComputed(function () {
    var cssClass;
    if (this.privateSession() && glueVersion !== 2) {
      cssClass = 'spoticon-locked-16 incognito';
    } else if (!this.avatar()) {
      cssClass = 'spoticon-user-16';
    }
    return cssClass;
  }, this);
  this.avatarImage = ko.pureComputed(function () {
    var showAvatar = glueVersion === 2 || !this.privateSession();
    var image = 'none';
    if (showAvatar && this.avatar()) {
      image = 'url(' + this.avatar() + ')';
    }
    return image;
  }, this);
  this.displayUsername = ko.pureComputed(function () {
    var showName = glueVersion === 2 || !this.privateSession();
    return showName ? this.username() : this.PRIVATE_SESSION_LABEL;
  }, this);

  this.userList = ko.observableArray();
  this.userFullNameLookup = [];

  this.isOnFreeProduct = ko.observable(false);

  this.fastUserSwitching = ko.observable(false);

  this._handleBackgroundClick = this.handleBackgroundClick.bind(this);
}

// Button labels
ProfileMenu.prototype.SETTINGS_LABEL = _('settings.app_name');
ProfileMenu.prototype.PROFILE_LABEL = _('profile.app_name');
ProfileMenu.prototype.PRIVATE_SESSION_LABEL = _('profile.private_session');
ProfileMenu.prototype.LOGOUT_LABEL = _('profile.logout');
ProfileMenu.prototype.SWITCH_USER_LABEL = _('profile.switch');
ProfileMenu.prototype.NEW_USER_LABEL = _('profile.new_user');
ProfileMenu.prototype.ENABLED_LABEL = _('profile.enabled');
ProfileMenu.prototype.ACCOUNT_LABEL = _('profile.account');
ProfileMenu.prototype.MENU_LABEL = _('profile.menu_label');
ProfileMenu.prototype.UPGRADE_MENU_LABEL = _('profile.upgrade_account');

/**
 * Setup functionality
 *
 * @return {ProfileMenu} The instance.
 */
ProfileMenu.prototype.setup = function () {
  var self = this;

  var updateSessionProperties = function updateSessionProperties(properties) {
    if ('incognito' in properties) {
      self.privateSession(properties.incognito);
    }
    if ('product' in properties) {
      self.isOnFreeProduct(properties.product !== 'premium');
    }
  };

  var updateUserInfo = function updateUserInfo(user) {
    if (!!user.name) {
      self.username(user.name);
      localStorage.setItem(self.spotifyUsername, user.name);
    }
  };

  var updateImage = function updateImage(url) {
    self.avatar(url);
  };

  var client = live('spotify:client');
  client.query('currentUser(uri, name, username, image)', function (error, data) {
    if (error) throw error;
    updateUserInfo(data.currentUser);
    client.get('currentUser').on('update', updateUserInfo);
  });

  bridge.cosmosJSON({
    method: 'SUB',
    uri: 'sp://core-social/unstable/decorate',
    body: {
      items: [window.__spotify.username]
    }
  }, function (error, data) {
    if (error) throw error;
    updateImage(data.users[0].images.default);
  });

  client.query('session(incognito, product)', function (error, properties) {
    if (error) throw error;
    updateSessionProperties(properties.session);
    client.get('session').on('update', updateSessionProperties);
  });

  eventsCenter.on('menu-activate-item', function (event) {
    if (event.menu.id === 'profile-menu') {
      self._onMenuActivateItem(event);
    }
  });

  eventsCenter.on('menu-hide', function (event) {
    if (event.menu.id === 'profile-menu') {
      self.hideMenu();
    }
  });

  window.addEventListener('resize', function () {
    self.hideMenu();
  }, false);

  this.getLoggedInUsers();

  abba('fast-user-switching', function (err, cell) {
    if (cell === 'Visible') {
      localStorage.setItem('fast-user-switching', 'true');
      self.fastUserSwitching(true);
    } else if (cell === 'Remove') {
      // Removing the test artefacts
      localStorage.setItem('fast-user-switching', 'false');
    } else {
      // Control or family member
      var fastUserSWitchingStatus = localStorage.getItem('fast-user-switching');
      self.fastUserSwitching(fastUserSWitchingStatus === 'true');
    }
  });

  return this;
};

/**
 * Open the Settings app
 */
ProfileMenu.prototype.openSettingsApp = function () {
  var event = new Event(Event.TYPES.NAVIGATION_OPEN_URI, 'spotify:app:settings');
  eventDispatcher.dispatchEvent(event);
  this.hideMenu();
};

/**
 * Open the Profile app
 */
ProfileMenu.prototype.openProfile = function () {
  var uri = 'spotify:app:profile:' + encodeURIComponent(this.spotifyUsername);
  var event = new Event(Event.TYPES.NAVIGATION_OPEN_URI, uri);

  if (glueVersion === 2) {
    this.hideMenu();
  }

  eventDispatcher.dispatchEvent(event);
};

ProfileMenu.prototype.handleBackgroundClick = function () {
  this.hideMenu();
};

ProfileMenu.prototype.toggleMenu = function () {
  if (this.menuVisible()) {
    this.hideMenu();
  } else {
    this.showMenu();
  }
};

ProfileMenu.prototype.showMenu = function () {
  this.menuVisible(true);

  var profileMenu = null;
  if (glueVersion === 2) {
    profileMenu = document.getElementById('profile-menu');
  } else {
    profileMenu = document.getElementById('profile-menu-glue1');
  }

  if (profileMenu) {
    this._activeElement = document.activeElement;
    profileMenu.focus();
  }

  var dropdownBackground = document.getElementById('dropdown-background');
  if (dropdownBackground) {
    dropdownBackground.classList.add('visible');
    dropdownBackground.addEventListener('click', this._handleBackgroundClick, false);
  }

  eventDispatcher.dispatchEvent(new Event(Event.TYPES.POPOVER_OPENED, { id: PROFILE_MENU_POPOVER_ID }));
};

ProfileMenu.prototype.hideMenu = function () {
  if (this._activeElement) {
    this._activeElement.focus();
    this._activeElement = null;
  }

  var dropdownBackground = document.getElementById('dropdown-background');
  if (dropdownBackground) {
    dropdownBackground.classList.remove('visible');
    dropdownBackground.removeEventListener('click', this._handleBackgroundClick, false);
  }

  this.menuVisible(false);

  eventDispatcher.dispatchEvent(new Event(Event.TYPES.POPOVER_CLOSED, { id: PROFILE_MENU_POPOVER_ID }));
};

ProfileMenu.prototype.openAccount = function () {
  eventDispatcher.dispatchEvent(new Event(Event.TYPES.NAVIGATION_SHOW_ACCOUNT));
  this.hideMenu();
};

ProfileMenu.prototype.togglePrivateSession = function () {
  bridge.request('preferences_set', ['ui.incognito_mode', !this.privateSession()]);
  this.hideMenu();
};

ProfileMenu.prototype.logout = function () {
  eventDispatcher.dispatchEvent(new Event(Event.TYPES.NAVIGATION_LOGOUT));
  this.hideMenu(); // shouldn't really matter, but for consistency...
};

/**
 * Get a link to the upgrade page, open it in browser
 */
ProfileMenu.prototype.openProductUpgradePage = function () {
  var baseParams = {
    'utm_source': 'spotify',
    'utm_medium': 'product-KM',
    'utm_campaign': 'user-menu-upgrade'
  };

  var query = [];
  Object.keys(baseParams).forEach(function (k) {
    query.push(k + '=' + baseParams[k]);
  });

  var url = 'https://www.spotify.com/redirect/upgrade-product?' + query.join('&');
  session.getOAuthToken(url, function (error, token) {
    url += error ? '' : '&' + token;
    if (window) window.open(url);
  });
};

ProfileMenu.prototype.switchToUser = function (username) {
  bridge.request('autologin-with-username', [username]);

  this.hideMenu();

  UIInteraction4.log({
    'feature_id': 'zlink',
    'section_id': 'profilemenu',
    'interaction_type': 'click',
    'user_intent': 'switch-user'
  });
};

ProfileMenu.prototype.switchToNewUser = function () {
  bridge.request('logout-remember-credentials', []);

  this.hideMenu();

  UIInteraction4.log({
    'feature_id': 'zlink',
    'section_id': 'profilemenu',
    'interaction_type': 'click',
    'user_intent': 'switch-new-user'
  });
};

ProfileMenu.prototype.getFullNameFromUsername = function (username) {
  for (var i = 0; i < this.userFullNameLookup.length; i++) {
    var userDict = this.userFullNameLookup[i];
    if (userDict.username !== username) {
      continue;
    }

    return userDict.fullname;
  }

  return username;
};

ProfileMenu.prototype.getLoggedInUsers = function () {
  var self = this;

  bridge.request('get-logged-in-usernames', [], function (error, response) {
    if (error) {
      console.warn('Could not get list of ' + ' users with stored credentials.', error);
      return;
    }
    var usernamesList = response;
    for (var i = 0; i < usernamesList.length; i++) {
      var aUserName = usernamesList[i];

      var fullName = localStorage.getItem(aUserName);
      var nameToAdd = fullName || aUserName;

      self.userFullNameLookup.push({ 'username': aUserName,
        'fullname': nameToAdd });

      if (usernamesList[i] !== self.spotifyUsername) {
        self.userList.push(aUserName);
      }
    }
  });
};

/**
 * Called when a menu item is activated via keyboard ENTER.
 *
 * @param {Object} event An event object from spotify-events/menu.
 */
ProfileMenu.prototype._onMenuActivateItem = function (event) {
  switch (event.item.id) {
    case 'profile':
      this.openProfile();
      break;
    case 'private-session':
      this.togglePrivateSession();
      break;
    case 'account':
      this.openAccount();
      break;
    case 'upgrade-account':
      this.openProductUpgradePage();
      break;
    case 'settings':
      this.openSettingsApp();
      break;
    case 'switch-new-user':
      this.switchToNewUser();
      break;
    case 'switch-user':
      break;
    case 'log-out':
      this.logout();
      break;
    default:
      var action = event.item.id;
      var regex = /^switch-to-user:(.+)$/;
      var matches = regex.exec(action);
      if (matches) {
        var username = matches[1];
        if (username !== this.spotifyUsername) {
          this.switchToUser(username);
        }
      }
      break;
  }
};

module.exports = ProfileMenu;

},{"../../../../libs/spotify-abba-mini":181,"../../../../libs/spotify-bridge-request":253,"../../../../libs/spotify-event-dispatcher":264,"../../../../libs/spotify-events/center":268,"../../../../libs/spotify-glue-cat":348,"../../../../libs/spotify-live":439,"../../../../libs/spotify-logger/messages/UIInteraction4":452,"../../i18n":11,"../event":77,"../models/session":107,"knockout":567}],169:[function(require,module,exports){
'use strict';

var LocalSettings = require('../models/localsettings');
var Event = require('../event');
var eventDispatcher = require('../../../../libs/spotify-event-dispatcher');

function Resize(id, optSizeLimitElement, setting) {
  this.dragging = false;

  this.onDragStart = this.onDragStart.bind(this);
  this.onDrag = this.onDrag.bind(this);
  this.onDragEnd = this.onDragEnd.bind(this);
  this.onResize = this.onResize.bind(this);

  this._id = id;
  if (optSizeLimitElement) {
    this._sizeLimitElement = document.getElementById(optSizeLimitElement);
  }
  this._setting = setting;
}

Resize.prototype.setup = function () {
  window.addEventListener('resize', this.onResize);

  this._element = document.getElementById(this._id);
  this._resizeOverlay = document.getElementById('resize-overlay');

  this._minWidths = [];
  this._maxWidths = [];

  addSizeLimit(this._element, 'minWidth', this._minWidths);
  addSizeLimit(this._element, 'maxWidth', this._maxWidths);
  if (this._sizeLimitElement) {
    addSizeLimit(this._sizeLimitElement, 'minWidth', this._minWidths);
    addSizeLimit(this._sizeLimitElement, 'maxWidth', this._maxWidths);
  }

  var storedWidth = LocalSettings.get(this._setting);

  if (storedWidth) {
    // Some views that listen to this event might not have been
    // set up yet, so leave it to the next tick
    setTimeout(function () {
      var width = parseInt(storedWidth, 10);
      this.applyWidth(width + 'px');
    }.bind(this), 0);
  }
};

/**
 * Update the width of the container and trigger an event for whoever cares.
 *
 * @param {String} The new width.
 */
Resize.prototype.applyWidth = function (width) {
  this._element.style.width = width;

  // Inform about resizing the side bar specifically
  if (this._id === 'menu-wrapper') {
    eventDispatcher.dispatchEvent(new Event(Event.TYPES.LAYOUT_SIDEBAR_RESIZED, {
      width: width
    }));
  }
};

Resize.prototype.onDragStart = function (model, e) {
  e.preventDefault();
  this.dragging = true;
  this._resizeOverlay.style.display = 'block';
  // _resizerLeft is true when the element is resized from the left
  // side, so it's sticky on the right. Used for resizing the friend-feed.
  this._resizerLeft = /\s*resizer-left\s*/.test(e.target.className);

  window.addEventListener('mouseup', this.onDragEnd);
  window.addEventListener('mousemove', this.onDrag);
  window.addEventListener('touchend', this.onDragEnd);
  window.addEventListener('touchmove', this.onDrag);
};

Resize.prototype.onDrag = function (e) {
  if (!this.dragging) return;

  var offset = this._resizerLeft ? window.innerWidth : 0;
  var x = isTouch(e) ? e.touches[0].pageX : e.pageX;
  var value = this._resizerLeft ? offset - x : x;
  var limitWidthPx = this._getLimitedWidthPx(value);

  this._width = limitWidthPx;
  this.applyWidth(limitWidthPx);
};

/**
 * Limit the given width based on values in this._minWidths and this._maxWidths.
 *
 * @param {number|string} The width in pixels.
 *
 * @returns {string} the limited value ending on 'px'.
 */
Resize.prototype._getLimitedWidthPx = function (width) {
  width = parseInt(width, 10);

  var getValue = function getValue(descriptor) {
    return descriptor.isPercentage ? descriptor.value * window.innerWidth / 100 : descriptor.value;
  };

  var minWidthPxValues = this._minWidths.map(getValue);
  var maxWidthPxValues = this._maxWidths.map(getValue);

  var minWidth = Math.max.apply(null, minWidthPxValues);
  var maxWidth = Math.min.apply(null, maxWidthPxValues);

  return Math.max(Math.min(width, maxWidth), minWidth) + 'px';
};

Resize.prototype.onDragEnd = function (e) {
  e.preventDefault();
  this.dragging = false;
  this._resizeOverlay.style.display = 'none';
  window.removeEventListener('mouseup', this.onDragEnd);
  window.removeEventListener('mousemove', this.onDrag);
  window.removeEventListener('touchend', this.onDragEnd);
  window.removeEventListener('touchmove', this.onDrag);
  LocalSettings.set(this._setting, this._width);
};

Resize.prototype.onResize = function () {
  var width = this._width || LocalSettings.get(this._setting);
  if (width) {
    var limitWidthPx = this._getLimitedWidthPx(width);
    this.applyWidth(limitWidthPx);
  }
};

function isTouch(e) {
  return e.type === 'touchstart' || e.type === 'touchend' || e.type === 'touchmove';
}

function addSizeLimit(element, property, list) {
  var computedStyle = window.getComputedStyle(element);
  var value = computedStyle[property];
  var valueInt = parseInt(value, 10);
  if (valueInt) {
    list.push({
      value: valueInt,
      isPercentage: value.endsWith('%')
    });
  }
}

module.exports = Resize;

},{"../../../../libs/spotify-event-dispatcher":264,"../event":77,"../models/localsettings":100}],170:[function(require,module,exports){
(function (global){
'use strict';

var ko = require('knockout');
var cosmos = require('spotify-cosmos-api');
var Keyboard = require('../keyboard');
var glue = require('../../../../libs/spotify-glue-cat');
var _ = require('../../i18n').get;
var eventDispatcher = require('../../../../libs/spotify-event-dispatcher');
var Event = require('../event');

var glueVersion = glue.getVersion();

/**
 * View model for the Search Suggest field
 *
 * @constructor
 */
function Search() {
  // Observables
  this.query = ko.observable('');

  // search form and input element
  if (glueVersion === 2) {
    this._searchForm = document.querySelector('form#search');
    this._searchInput = document.getElementById('search-input');
  } else {
    this._searchForm = document.querySelector('form#search-glue1');
    this._searchInput = document.getElementById('search-input-glue1');
  }

  // Reference to the current active iframe in the main content view.
  // It's necessary to add/remove the click event handler to close suggest
  this._currentActiveIframe = null;

  this.suggestUri = 'spotify:app:suggest';

  if (global.__spotify && global.__spotify.platform === 'web') {
    var iframeId = glueVersion === 2 ? 'app-suggest' : 'app-suggest-glue1';
    global.__spotify.exec('frame:register', this.suggestUri, document.querySelector('#' + iframeId));
    this.suggestUri = global.__spotify.exec('translate:uri', this.suggestUri);
  }

  // Observables
  this.suggestVisible = ko.observable(false);
  this.suggestHeight = ko.observable('0px');
  this.suggestWidth = ko.observable('240px');

  this._suggestQuery('');

  this._openSuggest = this._openSuggest.bind(this);
  this._closeSuggestOnClick = this._closeSuggestOnClick.bind(this);
}

Search.prototype.SEARCH_INPUT_LABEL = _('search.input_placeholder');

Search.prototype.clear = function () {
  this.query('');
  this._searchInput.focus();
};

/**
 * Setup functionality
 *
 * @return {Search} The instance.
 */
Search.prototype.setup = function () {
  var self = this;

  cosmos.resolver.subscribe('sp://messages/v1/suggest', this._onCosmosMessage.bind(this));

  document.body.addEventListener('click', this._closeSuggestOnClick);

  this.query.subscribe(function (value) {
    self._suggestQuery(value);
    self._openSuggest();
  });

  this._searchForm.addEventListener('submit', function (evt) {
    evt.preventDefault();
  });

  this._searchInput.addEventListener('keydown', function (evt) {
    self._onKeyPress(evt.keyCode);
  });

  this._searchInput.addEventListener('focus', this._openSuggest);

  this._registerKeyboardShortcuts();

  eventDispatcher.addEventListener(Event.TYPES.NAVIGATION_SHOW_SEARCH, this._focusSearchField.bind(this));

  return this;
};

Search.prototype._closeSuggestOnClick = function (evt) {
  if (this.suggestVisible() && evt.target.parentElement !== this._searchForm) {
    this._closeSuggest();
    if (this._currentActiveIframe) {
      // Remove the listener from the current active iframe to avoid
      // duplicated handlers
      this._currentActiveIframe.removeEventListener('click', this._closeSuggestOnClick);
      this._currentActiveIframe = null;
    }
  }
};

Search.prototype._focusSearchField = function () {
  this._searchInput.focus();
  this._searchInput.select();
};

Search.prototype._registerKeyboardShortcuts = function () {
  var self = this;
  var focus = function focus(e) {
    e.preventDefault();
    self._focusSearchField();
  };

  // CTRL L or CTRL ALT F focus on the search field
  Keyboard.registerShortcut({
    key: Keyboard.KEYS.L,
    ctrl: true
  }, focus);

  Keyboard.registerShortcut({
    key: Keyboard.KEYS.F,
    ctrl: true,
    alt: true
  }, focus);
};

/**
 * Hide the suggest iframe after a delay
 *
 * @return {Search} The instance.
 */
Search.prototype._closeSuggest = function () {
  if (this.suggestVisible()) {
    document.body.classList.remove('modal-open');
    this.suggestVisible(false);
  }

  return this;
};

/**
 * Shows the suggest iframe and clears any delayed hide action
 *
 * @return {Search} The instance.
 */
Search.prototype._openSuggest = function () {
  if (!this.suggestVisible()) {
    document.body.classList.add('modal-open');
    this.suggestVisible(true);

    this._currentActiveIframe = document.querySelector('#view-content iframe.active');

    if (this._currentActiveIframe && this._currentActiveIframe.contentDocument) {
      this._currentActiveIframe.contentDocument.addEventListener('click', this._closeSuggestOnClick);
    }
  }
  return this;
};

/**
 * Sends a suggest query string to the suggest app
 *
 * @param {value} String the query string
 * @param {callback} Function optional callback
 */
Search.prototype._suggestQuery = function (value, callback) {
  this._sendCosmosMessage({
    'type': 'text',
    'text': value,
    'sender': 'desktop'
  }, callback);
};

/**
 * Sends a keyboard press event to the suggest app
 *
 * @param {value} String the query string
 * @param {callback} Function optional callback
 */
Search.prototype._onKeyPress = function (keyCode, callback) {
  var key;

  if (keyCode === Keyboard.KEYS.ARROW_UP) {
    key = 'UP';
  } else if (keyCode === Keyboard.KEYS.ARROW_DOWN) {
    key = 'DOWN';
  } else if (keyCode === Keyboard.KEYS.ENTER) {
    key = 'ENTER';
  } else if (keyCode === Keyboard.KEYS.ESCAPE) {
    if (this.query()) {
      this.query('');
    } else {
      this._searchInput.blur();
      this._closeSuggest();
    }
  }

  if (key) {
    this._sendCosmosMessage({
      'type': 'key',
      'key': key,
      'sender': 'desktop'
    }, callback);
  }
};

/**
 * Sends a cosmos message to the suggest
 *
 * @param {data} Object to send
 * @param {callback} Function optional callback
 */
Search.prototype._sendCosmosMessage = function (data, callback) {
  var request = new cosmos.Request('POST', 'sp://messages/v1/suggest', null, data);

  cosmos.resolver.resolve(request, callback || function () {});
};

/**
 * Event handler for received cosmos messages from the suggest app
 *
 * @param {err} possible error
 * @param {response} message data
 */
Search.prototype._onCosmosMessage = function (error, response) {
  if (error) {
    console.error('SubscriptionError', { data: JSON.stringify(error) });
    return;
  }

  try {
    var object = JSON.parse(response.getBody());

    if (object.sender !== 'suggest') {
      return;
    }
    if (object.type === 'set-height') {
      this.suggestHeight(object.height + 'px');
    } else if (object.type === 'resign-focus') {
      this._closeSuggest();
      this._searchInput.blur();
      window.focus();
    } else if (object.type === 'set-text') {
      this.query(decodeURIComponent(object.text));
    }
  } catch (ev) {
    console.error('incorrect cosmos message', {
      data: ev,
      body: response.getBody()
    });
  }
};

module.exports = Search;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../../../libs/spotify-event-dispatcher":264,"../../../../libs/spotify-glue-cat":348,"../../i18n":11,"../event":77,"../keyboard":83,"knockout":567,"spotify-cosmos-api":694}],171:[function(require,module,exports){
(function (global){
'use strict';

var ko = require('knockout');
var URI = require('spotify-liburi');
var eventDispatcher = require('../../../../libs/spotify-event-dispatcher');
var EventTypes = require('../event').TYPES;

var hasWebContainer = global.__spotify && global.__spotify.platform === 'web';

/**
 * View model for the Share popup
 *
 * @param {Bridge} bridge Bridge to use.
 * @param {document}
 * @constructor
 */
function Share(bridge, doc) {
  if (!doc) doc = window.document;

  /**
   * Bridge to use
   *
   * @type {Bridge}
   */
  this._bridge = bridge;

  /**
   * The IFrame element that shows the share app
   *
   * @type {Element}
   */
  this._iframe = doc.getElementById('view-share-iframe');

  if (hasWebContainer) {
    global.__spotify.exec('frame:register', 'spotify:app:share', this._iframe);
  }

  // Observables
  this.visible = ko.observable(false);
  this.uri = ko.observable('');
  this.iframeSrc = ko.observable('');
  this.height = ko.observable('0px');
  this.width = ko.observable('0px');

  this._active = false;
}

/**
 * Setup functionality
 *
 * @return {Share} The instance.
 */
Share.prototype.setup = function () {
  eventDispatcher.addEventListener('POPUP_SET_PREFERRED_SIZE', this._onPreferredSize.bind(this));

  eventDispatcher.addEventListener('POPUP_WINDOW_CLOSE', this._onWindowClose.bind(this));

  eventDispatcher.addEventListener(EventTypes.NAVIGATION_SHOW_SHARE, this._onWindowOpen.bind(this));

  return this;
};

/**
 * Open the app with a URI like
 * 'spotify:app:share:' + encodeURIComponent('spotify:artist:foo')
 */
Share.prototype.open = function (uri) {
  var previousUri = this.uri();
  var isNewArguments = uri !== previousUri;

  if (isNewArguments) {
    var uriObject = URI.fromString(uri) || {};
    this.uri(uri);
    if (hasWebContainer) {
      this.iframeSrc(global.__spotify.exec('translate:uri', uri));
      global.__spotify.exec('app:args', this._iframe, uriObject.args);
    } else {
      this.iframeSrc(uri);
    }
    this._sendArgumentsMessage(uriObject.args || []);
  }

  if (!this._active) {
    this._active = true;
    this._sendActiveMessage(true);

    // This needs to be inside the active check, to prevent errors
    // if the share is called to be opened twice rapidly.
    // There is a small delay in displaying the view, to let the
    // app prepare. This is the same delay we use for normal apps.
    if (!this.visible()) {
      var self = this;
      setTimeout(function () {
        self.visible(true);
      }, 50);
    }
  }
};

/**
 * Close the share popup
 */
Share.prototype.close = function () {
  if (this._active) {
    this._active = false;
    this._sendActiveMessage(false);
  }

  if (this.visible()) {
    this.visible(false);
  }
};

/**
 * Callback function for when the app wants to open itself
 *
 * @param {BridgeEvent} e The bridge event triggered
 */
Share.prototype._onWindowOpen = function (e) {
  this.open(e.params);
};

/**
 * Callback function for when the app wants to close itself
 *
 * @param {BridgeEvent} e The bridge event triggered
 */
Share.prototype._onWindowClose = function (e) {
  if (e.source !== this._iframe.contentWindow) {
    // Event not received from the context-actions app
    return;
  }
  this.close();
  // Restore focus to the main window so the
  // keyboard events are handled properly
  document.body.focus();
};

/**
 * Callback function for when the app wants to change size
 *
 * @param {BridgeEvent} e The bridge event triggered
 */
Share.prototype._onPreferredSize = function (e) {
  if (e.source !== this._iframe.contentWindow) {
    return; // Not the share app
  }
  this.width(e.params.width + 'px');
  this.height(e.params.height + 'px');
};

/**
 * Send a message to the share iframe to notify it about it being
 * activated.
 *
 * @param {boolean} value True for activating the iframe and false for
 *     deactivating.
 */
Share.prototype._sendActiveMessage = function (value) {
  var contentWindow = this._iframe.contentWindow;
  if (contentWindow && contentWindow.postMessage) {
    contentWindow.postMessage({
      name: 'set_active',
      active: value
    }, '*');
  }
};

/**
 * Send a message to the share iframe to notify it about new arguments.
 *
 * @param {Array.<string>} value Array of string arguments. Each argument
 *     should be un-encoded.
 */
Share.prototype._sendArgumentsMessage = function (value) {
  var contentWindow = this._iframe.contentWindow;
  if (contentWindow && contentWindow.postMessage) {
    contentWindow.postMessage({
      name: 'set_arguments',
      arguments: value
    }, '*');
  }
};

module.exports = Share;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../../../libs/spotify-event-dispatcher":264,"../event":77,"knockout":567,"spotify-liburi":707}],172:[function(require,module,exports){
'use strict';

var ko = require('knockout');
var session = require('../models/session');
var _ = require('../../i18n').get;
var live = require('../../../../libs/spotify-live');
var abba = require('../../../../libs/spotify-abba-mini');

/**
 * View Model for the upgrade button.
 *
 * @constructor
 */
function UpgradeButton() {
  var self = this;

  this._activeElement = null;

  // Observables
  this.isOnFreeProduct = ko.observable(false);

  var defaultButtonClassName = 'button button-small button-with-stroke';

  this.upgradeButtonClass = ko.observable(defaultButtonClassName);

  abba('ad_zelda_upgrade_button', function (err, cell) {
    switch (cell) {
      case 'blue_border':
        // The style and size of this button is custom and defined in CSS
        self.upgradeButtonClass('button blue-border');
        break;
      case 'blue_fill':
        self.upgradeButtonClass('button button-small button-blue');
        break;

      // Default is the same as white_text, and they are using the class names
      // that are already applied on the button, so no need to do anything more.
      case 'white_text':
      default:
        self.upgradeButtonClass(defaultButtonClassName);
    }
  });
}

// Button labels
UpgradeButton.prototype.UPGRADE_LABEL = _('profile.upgrade');
UpgradeButton.prototype.UPGRADE_TOOLTIP_TEXT = _('profile.upgrade_tooltip');

/**
 * Setup functionality
 *
 * @return {UpgradeButton} The instance.
 */
UpgradeButton.prototype.setup = function () {
  var self = this;

  var updateProduct = function updateProduct(properties) {
    if ('product' in properties) {
      self.isOnFreeProduct(properties.product !== 'premium');
    }
  };

  var client = live('spotify:client');
  client.query('session(product)', function (error, properties) {
    if (error) throw error;
    updateProduct(properties.session);
    client.get('session').on('update', updateProduct);
  });

  return this;
};

/**
 * Get a link to the upgrade page, open it in browser
 */
UpgradeButton.prototype.openProductUpgradePage = function () {
  var baseParams = {
    'utm_source': 'spotify',
    'utm_medium': 'product-KM',
    'utm_campaign': 'nav-upgrade'
  };

  var query = [];
  Object.keys(baseParams).forEach(function (k) {
    query.push(k + '=' + baseParams[k]);
  });

  var url = 'https://www.spotify.com/redirect/upgrade-product?' + query.join('&');
  session.getOAuthToken(url, function (error, token) {
    url += error ? '' : '&' + token;
    if (window) window.open(url);
  });
};

module.exports = UpgradeButton;

},{"../../../../libs/spotify-abba-mini":181,"../../../../libs/spotify-live":439,"../../i18n":11,"../models/session":107,"knockout":567}],173:[function(require,module,exports){
'use strict';

var videoCSSClass = 'video';
var videoFullsceenCSSClass = 'video-full-screen';

var eventDispatcher = require('../../../../libs/spotify-event-dispatcher');
var EventTypes = require('../event').TYPES;
var keyboard = require('../keyboard');

function Video() {
  this._attachedNode = null;
  this._fullwindowContainer = document.getElementById('view-video');
  this._sidebarContainer = document.getElementById('sidebar-video-container');
  this._currentContainer = null;

  this._fullwindowContainer.addEventListener('click', function () {
    this._transitionToNowPlaying();
  }.bind(this));
  this._sidebarContainer.addEventListener('click', function () {
    this._transitionToFullWindow();
  }.bind(this));

  keyboard.registerImportantShortcut(keyboard.KEYS.ESCAPE, this._onKeyboardEscape.bind(this));
}

Video.prototype._onKeyboardEscape = function () {
  this._transitionToNowPlaying();
};

Video.prototype._onNavigationStateChange = function () {
  this._transitionToNowPlaying();
};

/**
 * Setup the video.
 * @return {Video} The instance of the video content.
 */
Video.prototype.setup = function () {
  return this;
};

Video.prototype.attachVideoElement = function (node, fullwindow) {
  this.detachVideoElement();
  this._currentContainer = null;
  this._attachedNode = node;
  document.body.classList.add(videoCSSClass);
  if (fullwindow) {
    this._transitionToFullWindow();
  } else {
    this._transitionToNowPlaying();
  }
  this._addNavigationListener();
};

Video.prototype.detachVideoElement = function () {
  if (this._sidebarContainer.contains(this._attachedNode)) {
    this._sidebarContainer.removeChild(this._attachedNode);
  }
  if (this._fullwindowContainer.contains(this._attachedNode)) {
    this._fullwindowContainer.removeChild(this._attachedNode);
  }
  this._currentContainer = null;
  this._attachedNode = null;
  document.body.classList.remove(videoCSSClass, videoFullsceenCSSClass);
  this._removeNavigationListener();
};

Video.prototype.isFullWindow = function () {
  return this._attachedNode && this._currentContainer === this._fullwindowContainer;
};

Video.prototype._addNavigationListener = function () {
  this._removeNavigationListener();
  this._navigationListener = this._onNavigationStateChange.bind(this);
  eventDispatcher.addEventListener(EventTypes.NAVIGATION_STATE_CHANGE, this._navigationListener);
};

Video.prototype._removeNavigationListener = function () {
  if (this._navigationListener) {
    eventDispatcher.removeEventListener(EventTypes.NAVIGATION_STATE_CHANGE, this._navigationListener);
  }
};

Video.prototype._switchContainer = function (fromContainer, toContainer) {
  var isPaused = !!this._attachedNode.paused;
  if (fromContainer.contains(this._attachedNode)) {
    fromContainer.removeChild(this._attachedNode);
  }
  toContainer.appendChild(this._attachedNode);
  if (!isPaused) {
    this._attachedNode.play();
  }
};

Video.prototype._updateVideoFullscreenClassState = function () {
  document.body.classList.remove(videoFullsceenCSSClass);
  if (this._currentContainer === this._fullwindowContainer) {
    document.body.classList.add(videoFullsceenCSSClass);
  }
};

Video.prototype._transitionToNowPlaying = function () {
  if (!this._attachedNode || this._currentContainer === this._sidebarContainer) {
    return;
  }

  this._currentContainer = this._sidebarContainer;
  this._updateVideoFullscreenClassState();
  this._switchContainer(this._fullwindowContainer, this._sidebarContainer);
};

Video.prototype._transitionToFullWindow = function () {
  if (!this._attachedNode || this._currentContainer === this._fullwindowContainer) {
    return;
  }

  this._currentContainer = this._fullwindowContainer;
  this._updateVideoFullscreenClassState();
  this._switchContainer(this._sidebarContainer, this._fullwindowContainer);
};

module.exports = Video;

},{"../../../../libs/spotify-event-dispatcher":264,"../event":77,"../keyboard":83}],174:[function(require,module,exports){
'use strict';

var ko = require('knockout');
var keyboard = require('../keyboard');
var eventDispatcher = require('../../../../libs/spotify-event-dispatcher');
var Event = require('../event');
var LocalSettings = require('../models/localsettings');
var _ = require('../../i18n').get;
var logger = require('../logging/client-event-logger');

function YourArtistsTooltip() {
  this.title = ko.observable(_('yourArtistsTooltipTitle'));
  this.text = ko.observable(_('yourArtistsTooltipText'));
  this.visible = ko.observable(false);
  this.uri = ko.observable('');
  this.top = ko.observable('0px');
  this.left = ko.observable('0px');
  this.display = ko.observable('none');
  this._hide = this.hide.bind(this);
}

YourArtistsTooltip.prototype._registerKeyboardShortcuts = function () {
  // Close the popup when pressing ESC
  keyboard.registerImportantShortcut(keyboard.KEYS.ESCAPE, function (e) {
    if (this.visible()) {
      e.preventDefault();
      this.hide();
    }
  }.bind(this));
};

YourArtistsTooltip.prototype.hide = function () {
  this.visible(false);
  this.display('none');
  LocalSettings.set('hide_your_artists_tooltip', true);
  logger.log({
    'event': 'user:hit',
    'event_version': 'hide-your-artist-tooltip',
    'context': 'your-artist-tooltip',
    'json_data': {
      'targetUri': this.uri,
      'section': 'navigation'
    }
  });
  document.body.removeEventListener('click', this._hide, false);
};

YourArtistsTooltip.prototype.show = function () {
  var shouldHide = LocalSettings.get('hide_your_artists_tooltip');
  if (!shouldHide) {
    this.visible(true);
    this.display('block');
    document.body.addEventListener('click', this._hide, false);
    logger.log({
      'event': 'user:impression',
      'event_version': 'your-artist-tooltip',
      'context': 'your-artist-tooltip',
      'json_data': {
        'targetUri': this.uri,
        'section': 'navigation'
      }
    });
  }
};

YourArtistsTooltip.prototype.setup = function () {
  this._registerKeyboardShortcuts();

  eventDispatcher.addEventListener(Event.TYPES.SHOW_YOUR_ARTISTS_TOOLTIP, function (e) {
    var options = e.params;
    this.top(options.top + 'px');
    this.left(options.left + 'px');
    this.show();
  }.bind(this));

  eventDispatcher.addEventListener(Event.TYPES.LAYOUT_SIDEBAR_RESIZED, function (e) {
    var options = e.params;
    this.left(options.width);
  }.bind(this));
};

module.exports = YourArtistsTooltip;

},{"../../../../libs/spotify-event-dispatcher":264,"../../i18n":11,"../event":77,"../keyboard":83,"../logging/client-event-logger":93,"../models/localsettings":100,"knockout":567}],175:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, functionType="function", escapeExpression=this.escapeExpression;


  buffer += "<div class=\"message-highlight\">\n  ";
  if (helper = helpers.highlight) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.highlight); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\n</div>\n\n<div class=\"overlay\">\n  <div class=\"message\">\n    <h1 class=\"message-title\">\n      ";
  if (helper = helpers.title) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.title); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\n    </h1>\n\n    <p class=\"message-description\">\n      ";
  if (helper = helpers.desc) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.desc); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\n    </p>\n\n    <button class=\"update-payment button button-large button-white\">\n      ";
  if (helper = helpers.updatePayment) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.updatePayment); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\n    </button>\n\n    <span class=\"message-cancel-sub\">\n      ";
  if (helper = helpers.cancelSubscription) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.cancelSubscription); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    </span>\n  </div>\n</div>\n";
  return buffer;
  });

},{"hbsfy/runtime":563}],176:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, options, functionType="function", escapeExpression=this.escapeExpression, helperMissing=helpers.helperMissing, self=this;

function program1(depth0,data) {

  var buffer = "", stack1;
  buffer += "\n      <div class=\"popover-cell fit-11 text-center\">\n        <p>"
    + escapeExpression(((stack1 = (data == null || data === false ? data : data.index)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "</p>\n        <input name=\"recommend\" type=\"radio\" value=\""
    + escapeExpression(((stack1 = (data == null || data === false ? data : data.index)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\" />\n      </div>\n    ";
  return buffer;
  }

function program3(depth0,data) {

  var buffer = "", stack1;
  buffer += "\n      <div class=\"popover-cell fit-11 text-center\">\n        <p>"
    + escapeExpression(((stack1 = (data == null || data === false ? data : data.index)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "</p>\n        <input name=\"satisfied\" type=\"radio\" value=\""
    + escapeExpression(((stack1 = (data == null || data === false ? data : data.index)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\" />\n      </div>\n    ";
  return buffer;
  }

  buffer += "<div class=\"popover-grid\">\n  <div class=\"popover-cell fit-01\">\n    <div class=\"popover-cell fit-01\">\n      <h3>"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "sTitle", options) : helperMissing.call(depth0, "loc", "sTitle", options)))
    + "</h3>\n    </div>\n\n    <div class=\"popover-cell fit-01\">\n      <h5>1/3: "
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "sQ1Question", options) : helperMissing.call(depth0, "loc", "sQ1Question", options)))
    + "</h5>\n    </div>\n\n    ";
  stack1 = helpers.each.call(depth0, depth0, {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n    <div class=\"popover-cell fit-01\">\n      <div class=\"popover-cell fit-02\">\n        <p>"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "sQ1Negative", options) : helperMissing.call(depth0, "loc", "sQ1Negative", options)))
    + "</p>\n      </div>\n      <div class=\"popover-cell fit-02 text-right\">\n        <p>"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "sQ1Positive", options) : helperMissing.call(depth0, "loc", "sQ1Positive", options)))
    + "</p>\n      </div>\n    </div>\n\n    <div class=\"popover-cell fit-01\">\n      <h5>2/3: "
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "sQ2Question", options) : helperMissing.call(depth0, "loc", "sQ2Question", options)))
    + "</h5>\n    </div>\n\n    <div class=\"popover-cell fit-01\">\n      <div class=\"popover-cell fit-01\">\n        <textarea maxlength=\"400\" name=\"why\" rows=\"5\" style=\"width: 100%;\"></textarea>\n      </div>\n    </div>\n\n    <div class=\"popover-cell fit-01\">\n      <h5>3/3: "
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "sQ3Question", options) : helperMissing.call(depth0, "loc", "sQ3Question", options)))
    + "</h5>\n    </div>\n\n    ";
  stack1 = helpers.each.call(depth0, depth0, {hash:{},inverse:self.noop,fn:self.program(3, program3, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n    <div class=\"popover-cell fit-01\">\n      <div class=\"popover-cell fit-02\">\n        <p>"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "sQ3Negative", options) : helperMissing.call(depth0, "loc", "sQ3Negative", options)))
    + "</p>\n      </div>\n      <div class=\"popover-cell fit-02 text-right\">\n        <p>"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "sQ3Positive", options) : helperMissing.call(depth0, "loc", "sQ3Positive", options)))
    + "</p>\n      </div>\n    </div>\n\n    <div class=\"popover-cell fit-01\">\n      <h3>"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "sThanks", options) : helperMissing.call(depth0, "loc", "sThanks", options)))
    + "</h3>\n    </div>\n\n    <div class=\"popover-cell fit-01\">\n      <p>"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "sTeam", options) : helperMissing.call(depth0, "loc", "sTeam", options)))
    + "</p>\n    </div>\n  </div>\n</div>\n";
  return buffer;
  });

},{"hbsfy/runtime":563}],177:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, options, functionType="function", escapeExpression=this.escapeExpression, self=this, helperMissing=helpers.helperMissing;

function program1(depth0,data) {


  return "5";
  }

function program3(depth0,data) {

  var stack1, helper;
  if (helper = helpers.depth) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.depth); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  return escapeExpression(stack1);
  }

function program5(depth0,data) {

  var buffer = "", stack1;
  buffer += "\n      ";
  stack1 = helpers['if'].call(depth0, ((stack1 = (depth0 && depth0.playlist)),stack1 == null || stack1 === false ? stack1 : stack1.collaborative), {hash:{},inverse:self.noop,fn:self.program(6, program6, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    ";
  return buffer;
  }
function program6(depth0,data) {


  return "\n        <svg class=\"collaborative-icon\" xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 8 8\">\n          <path d=\"M4,0A4,4,0,1,0,8,4,4,4,0,0,0,4,0ZM4,6A2,2,0,1,1,6,4,2,2,0,0,1,4,6Z\">\n          </path>\n        </svg>\n      ";
  }

function program8(depth0,data) {

  var stack1, helper, options;
  return escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "playlist.by", ((stack1 = ((stack1 = (depth0 && depth0.playlist)),stack1 == null || stack1 === false ? stack1 : stack1.owner)),stack1 == null || stack1 === false ? stack1 : stack1.name), options) : helperMissing.call(depth0, "loc", "playlist.by", ((stack1 = ((stack1 = (depth0 && depth0.playlist)),stack1 == null || stack1 === false ? stack1 : stack1.owner)),stack1 == null || stack1 === false ? stack1 : stack1.name), options)));
  }

  buffer += "<div class=\"indent-";
  stack1 = (helper = helpers.compare || (depth0 && depth0.compare),options={hash:{
    'operator': (">")
  },inverse:self.program(3, program3, data),fn:self.program(1, program1, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.depth), 5, options) : helperMissing.call(depth0, "compare", (depth0 && depth0.depth), 5, options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\">\n\n  <button type=\"button\" class=\"playing-indicator button playing button-play button-icon-with-stroke\"></button>\n\n  <span class=\"menu-accessory playlist spoticon-";
  if (helper = helpers.icon) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.icon); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "-16\"></span>\n\n  <canvas class=\"offline-loader\" width=\"31\" height=\"31\"></canvas>\n\n  <input class=\"edit\" type=\"text\" name=\"title\" value=\""
    + escapeExpression(((stack1 = ((stack1 = (depth0 && depth0.playlist)),stack1 == null || stack1 === false ? stack1 : stack1.name)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\"/>\n  <span class=\"annotate-hint-button spoticon-camera-16\" tabindex=\"-1\"></span>\n\n  <span class=\"title\">\n    ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.isGlue2), {hash:{},inverse:self.noop,fn:self.program(5, program5, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n    "
    + escapeExpression(((stack1 = ((stack1 = (depth0 && depth0.playlist)),stack1 == null || stack1 === false ? stack1 : stack1.name)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\n    <span class=\"sub-title\">";
  stack1 = helpers['if'].call(depth0, ((stack1 = ((stack1 = (depth0 && depth0.playlist)),stack1 == null || stack1 === false ? stack1 : stack1.owner)),stack1 == null || stack1 === false ? stack1 : stack1.name), {hash:{},inverse:self.noop,fn:self.program(8, program8, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "</span>\n  </span>\n\n  <span aria-hidden=\"true\" class=\"offline-indicator spoticon-download-16\"></span>\n</div>\n";
  return buffer;
  });

},{"hbsfy/runtime":563}],178:[function(require,module,exports){
'use strict';

function VideoAdView() {}
VideoAdView.prototype.minimize = function () {};

function VideoAd() {
  this.view = new VideoAdView();
}
VideoAd.prototype.enable = function () {};
VideoAd.prototype.disable = function () {};

var LeaderboardAdV1 = {};
LeaderboardAdV1.create = function () {};

function LeaderboardAdV2() {}
LeaderboardAdV2.prototype.enable = function () {};
LeaderboardAdV2.prototype.disable = function () {};
LeaderboardAdV2.prototype._disableRefresh = function () {};

var BillboardAd = function BillboardAd() {};
BillboardAd.isEnabled = function () {};
BillboardAd.pageIsBlackListed = function () {};
BillboardAd.init = function () {};
BillboardAd.enable = function () {};
BillboardAd.setApplicationInactive = function () {};
BillboardAd.getFocusTimeoutMs = function () {
  return Promise.resolve(180000);
};

module.exports.VideoAd = VideoAd;
module.exports.LeaderboardAdV1 = LeaderboardAdV1;
module.exports.LeaderboardAdV2 = LeaderboardAdV2;
module.exports.LeaderboardAdV3 = LeaderboardAdV2;
module.exports.BillboardAd = BillboardAd;

},{}],179:[function(require,module,exports){
'use strict';

var EventEmitter = require('spotify-eventemitter');

var KEY_DOWN = 40;
var KEY_UP = 38;
var KEY_LEFT = 37;
var KEY_RIGHT = 39;
var KEY_ESCAPE = 27;
var KEY_ENTER = 13;

function ContextMenu(options) {
  options = options || {};
  this._container = options.container;

  // padding from the window borders when calculated maxium size of
  // the context menu
  this._offset = !isNaN(options.offset) ? options.offset : 10;
  this._rawItems = [];
  this._items = {};
  this._visible = false;
  this._filter = options.filter;
  this._dropdown = options.dropdown;
  this._active = false;
  this._currentItem = null;
  this._parent = options.parent;
  this._mode = 'mouse';

  this._id = options.id;
  if (typeof options.id !== 'number' && !options.id) {
    this._id = 'context-menu';
  }

  if (!this._container) {
    this._container = document.getElementById(this._id + '-container');

    if (!this._container) {
      this._container = document.createElement('div');
      this._container.setAttribute('id', this._id + '-container');
      this._container.classList.add('context-menu-container');
      this._container.style.display = 'none';
      document.body.appendChild(this._container);
    }
  }

  this._element = document.getElementById(this._id);

  this._handleKeyDown = this._handleKeyDown.bind(this);
  this._handleKeyNavigation = this._handleKeyNavigation.bind(this);
  this._handleFilter = this._handleFilter.bind(this);
  this._handleCloseFilter = this._handleCloseFilter.bind(this);
  this._handleMouseDown = this._handleMouseDown.bind(this);
  this._handleMouseMove = this._handleMouseMove.bind(this);

  if (!this._element) {
    this._element = document.createElement('div');

    this._element.setAttribute('class', 'context-menu');
    this._element.setAttribute('id', this._id);
    this._container.appendChild(this._element);

    this._element.addEventListener('click', this._handleClick.bind(this));
    this._element.addEventListener('mouseover', this._handlePotentialHover.bind(this));

    if (!this._parent) {
      this._container.addEventListener('mousemove', this._handleMouseMove);
      this._container.addEventListener('mousedown', this._handleMouseDown);
      this._container.addEventListener('touchstart', this._handleMouseDown);
    }
  }

  this._renderItems(options.items || []);
}

/**
 * Injects the default CSS styles into the document
 * @return undefined
 */
ContextMenu.injectCSS = function () {
  var styles = require('./style.css');

  var head = document.getElementsByTagName('head')[0],
      style = document.createElement('style');

  style.type = 'text/css';

  if (style.styleSheet) {
    style.styleSheet.cssText = styles;
  } else {
    style.appendChild(document.createTextNode(styles));
  }
  head.appendChild(style);
};

ContextMenu.prototype = Object.create(EventEmitter.prototype);

/**
 * Deletes completely the context menu and all its
 * associated DOM objects
 *
 * @return undefined
 */
ContextMenu.prototype.remove = function () {
  if (this._visible) {
    this.hide();
  }

  this._container.removeEventListener('mousemove', this._handleMouseMove);
  this._container.removeEventListener('mousedown', this._handleMouseDown);
  this._container.removeEventListener('touchstart', this._handleMouseDown);

  this._container.removeChild(this._element);

  this.clearItems();
};

/**
 * Hides the context menu but keeps its current items and
 * DOM objects
 *
 * @return undefined
 */
ContextMenu.prototype.hide = function (hideAll) {
  if (!this._parent || hideAll) {
    this._container.style.display = 'none';
    document.body.removeEventListener('keydown', this._handleKeyDown);
  } else {
    this._element.style.display = 'none';
    this._element.style.width = 'auto';
  }
  document.body.removeEventListener('keydown', this._handleKeyNavigation);

  if (this._filterElement) {
    this._filterElement.removeEventListener('keydown', this._handleCloseFilter);
    this._filterElement.removeEventListener('input', this._handleFilter);
  }

  this._hideSubMenus();
  this._visible = false;
  this._active = false;
  this._setCurrentItem(null);

  this.emit('hide');
};

/**
 * Shows the context menu in the specified position with
 * the specified items
 *
 * @param  {Object} position  (optional) contains {x, y} as position in pixels
 * @param  {Array} items      (optional) array of items that will be displayed
 *
 * @return undefined
 */
ContextMenu.prototype.show = function (position, items) {
  if (!this._parent) {
    document.body.addEventListener('keydown', this._handleKeyDown);
  }
  document.body.addEventListener('keydown', this._handleKeyNavigation);

  this._element.style.opacity = '0';
  this._element.style.display = 'inline-block';
  this._container.style.display = 'block';

  if (items) {
    this.clearItems();
    this._renderItems(items);
  }

  this._visible = true;

  this._reposition(position);

  if (this._isEmpty()) {
    this.hide();
  }

  if (this._filter) {
    this._filterElement = document.getElementById(this._localIdToDom() + '-filter');
    this._filterElement.addEventListener('keydown', this._handleCloseFilter);
    this._filterElement.addEventListener('input', this._handleFilter);
    this._filterElement.value = '';
    this._filterElement.focus();
    this._filterFn();
  }

  this._active = true;
  this.emit('show');
};

/**
 * Returns whether or not the context menu is visible
 *
 * @return {Boolean} current visibility
 */
ContextMenu.prototype.isVisible = function () {
  return this._visible;
};

/**
 * Check if an item exists in the contextmenu
 * @param  {string/Array} id  If it's an array, it looks for subitems based on the array
 *
 * @return bool
 */
ContextMenu.prototype.hasItem = function (id) {
  return !!this._getItem(id).item;
};

/**
 * Updates an item/subitem of the context menu
 * @param  {string/Array} id  If it's an array, it looks for subitems based on the array
 * @param  {Object} data      The new item data
 *
 * @return undefined
 */
ContextMenu.prototype.updateItem = function (id, data) {
  var item = this._getItem(id);
  var parent = item.parent;
  item = item.item;

  if (!item) {
    return;
  }

  var el = document.getElementById(parent._localIdToDom(item.id));
  if (el) {
    if (item.parent) {
      item.submenu.remove();
      item.submenu.off('click');
    }
    var tempElement = document.createElement('div');
    tempElement.innerHTML = parent._renderItem(item.id, data);
    el.parentNode.replaceChild(tempElement.firstChild, el);
  }
};

/**
 * Add several items to the context menu
 * @param {Array} items     The items to add
 * @param {Array} parents  Where to add the items. If null, add them to the first level
 *
 * @return undefined
 */
ContextMenu.prototype.addItems = function (items, parents) {
  var self = this;
  items.forEach(function (item) {
    self.addItem(item, parents);
  });
};

/**
 * Add an item to the context menu
 * @param {Object} item     The item to add
 * @param {Array} parents  Where to add the item. If null, add them to the first level
 *
 * @return undefined
 */
ContextMenu.prototype.addItem = function (data, parents) {
  var id;

  if (parents) {
    parents = parents.slice(0);
    id = parents.shift();
    if (id !== undefined && this._items[id] && this._items[id].submenu) {
      return this._items[id].submenu.addItem(data, parents);
    }
  } else {
    id = data.id;
  }

  var item = this._items[id];
  if (item) {
    this.updateItem(id, data);
  } else {
    this._element.innerHTML += this._renderItem(null, data);
  }

  if (this._visible) {
    this.show();
  }
};

/**
 * Removes an item/subitem from the context menu
 * @param  {string/Array} id  If it's an array, it looks for subitems based on the array
 *
 * @return undefined
 */
ContextMenu.prototype.removeItem = function (id) {
  var item = this._getItem(id);
  var parent = item.parent;
  item = item.item;

  if (!item) {
    return;
  }

  if (item.submenu) {
    item.submenu.remove();
    item.submenu.off('click');
  }

  var el = document.getElementById(parent._localIdToDom(item.id));
  if (el) {
    // Rendering the item with no data will cause some clean up
    parent._renderItem(item.id, undefined);

    el.parentNode.removeChild(el);
  }

  delete parent._items[item.id];

  if (parent._visible && parent._isEmpty()) {
    parent.hide();
  }
};

/**
 * Removes all the items from the array
 *
 * @return undefined
 */
ContextMenu.prototype.clearItems = function () {
  for (var i in this._items) {
    this.removeItem(i);
  }
};

/**
 * Removes unnecessary separators from the context menu. For example, separators
 * as the first items of the menu or at the end. Also separators that are together
 * will be unified
 *
 * @return undefined
 */
ContextMenu.prototype.dedupeSeps = function () {
  // remove additional separators in the beginning
  while (this._items[this._rawItems[0].id].separator) {
    this.removeItem(this._rawItems[0].id);
  }

  // remove additional separators at the end
  while (this._items[this._rawItems[this._rawItems.length - 1].id].separator) {
    this.removeItem(this._rawItems[this._rawItems.length - 1].id);
  }

  // remove additional separators in the middle
  var sep = false;
  for (var i = 0; i < this._rawItems.length; i++) {
    var item = this._items[this._rawItems[i].id];

    if (item.separator) {
      if (sep) {
        this.removeItem(item.id);
        i--; // compensate the previous removed item
      }
      sep = true;
    } else {
      sep = false;
    }
  }
};

ContextMenu.prototype._getItem = function (id) {
  var itemId;
  if (Array.isArray(id)) {
    id = id.slice(0);

    itemId = id.shift();
    if (id.length) {
      if (this._items[itemId] && this._items[itemId].submenu) {
        return this._items[itemId].submenu._getItem(id);
      } else {
        return {
          parent: this,
          item: null
        };
      }
    }
  } else {
    itemId = id;
  }

  if (!this._items[itemId]) {
    return {
      parent: this,
      item: null
    };
  }

  return {
    item: this._items[itemId],
    parent: this
  };
};

ContextMenu.prototype._isEmpty = function () {
  return !Object.keys(this._items).length;
};

ContextMenu.prototype._localIdToDom = function (id) {
  var out = [];

  var rootId;

  var parent = this;
  while (parent) {
    rootId = parent._id;
    parent = parent._parent;
  }

  var thisId = this._id.substring(rootId.length + 1);

  out.push(rootId);
  out.push('item');
  if (thisId) {
    out.push(thisId);
  }

  if (id !== undefined) {
    out.push(id);
  }

  return out.join('-');
};

ContextMenu.prototype._domIdToLocal = function (id) {
  var substr = this._id + '-item-';

  return id.substring(substr.length);
};

ContextMenu.prototype._parseItem = function (id, item) {

  var rawItem = this._rawItems.filter(function (el) {
    return el.id === id;
  })[0];
  if (!item) {
    if (rawItem) {
      var usedId = rawItem.id;
      this._rawItems.splice(this._rawItems.indexOf(rawItem), 1);
      delete this._items[usedId];
    }
    return;
  }

  // Update previous item
  if (rawItem) {
    for (var i in item) {
      rawItem[i] = item[i];
    }
    item = rawItem;
  } else {
    rawItem = item;
    id = this._getAvailableId();
    this._rawItems.push(rawItem);
  }

  rawItem.id = rawItem.id || id;
  var el = {
    classes: [],
    text: rawItem.text,
    secondaryText: rawItem.secondaryText,
    fn: rawItem.fn,
    id: rawItem.id
  };

  if (rawItem.items) {
    el.classes.push('parent');
    el.parent = true;

    // if the submenu has no items, set it as disabled by default
    if (rawItem.items.length === 0 && !('disabled' in rawItem)) {
      rawItem.disabled = true;
    }

    el.submenu = this._createSubMenu(rawItem.id, rawItem.items, !!rawItem.filter);
    el.submenu.on('click', this.emit.bind(this, 'click'));
  }

  if (rawItem.secondaryText) {
    el.classes.push('secondary');
  }

  if (rawItem.disabled) {
    el.disabled = true;
    el.classes.push('disabled');
  }

  if (rawItem.value !== undefined) {
    el.checkbox = true;
    el.value = rawItem.value;
    if (el.value) {
      el.classes.push('check');
    }
  }

  if (el.text === undefined) {
    el.separator = true;
    el.classes.push('sep');
    el.text = '';
  } else {
    el.classes.push('item');
  }

  this._items[rawItem.id] = el;
  return el;
};

ContextMenu.prototype._renderItems = function (items) {
  var self = this;
  var content = '';

  if (this._filter) {
    // add filtering stuff
    content += '<div class="filter-search">' + '<input type="text" id="' + this._localIdToDom() + '-filter"/>' + '</div>';
  }

  items.forEach(function (el) {
    content += self._renderItem(null, el);
  });

  this._element.innerHTML = content;
};

ContextMenu.prototype._renderItem = function (id, el) {
  var item = this._parseItem(id, el);
  if (!item) {
    return '';
  }

  var secondaryText = '';
  if (item.secondaryText) {
    secondaryText = '<span class="secondary">' + this._escapeHtml(item.secondaryText) + '</span>';
  }

  id = this._localIdToDom(item.id);
  return '<div class="' + item.classes.join(' ') + '" id="' + id + '">' + '<span class="text">' + this._escapeHtml(item.text) + '</span>' + secondaryText + '</div>';
};

ContextMenu.prototype._reposition = function (position) {
  if (position) {
    this._originalPosition = position;
  }

  if (!this._dropdown) {
    this._position = this._calcPosition(this._originalPosition || this._position);
  }

  if (this._position.h) {
    this._element.style.height = this._position.h + 'px';
    this._element.style.overflowY = 'scroll';
  }

  this._element.style.top = this._position.y + 'px';
  this._element.style.left = this._position.x + 'px';
  this._element.style.opacity = '1';
};

ContextMenu.prototype._setCurrentItem = function (position, increment) {
  var itemId;
  var el;
  var item;

  var finalPosition = null;

  if (position !== null) {
    position = Math.max(Math.min(parseInt(position, 10), this._rawItems.length - 1), 0);
    var currentPosition = position;

    // try to find an item to select that can be selectable
    if (increment) {
      while (true) {
        item = this._items[this._rawItems[currentPosition].id];
        el = document.getElementById(this._localIdToDom(this._rawItems[currentPosition].id));

        if (!item.separator && !item.disabled && !el.classList.contains('filtered')) {
          finalPosition = currentPosition;
          break;
        }

        currentPosition += increment;

        if (currentPosition >= this._rawItems.length || currentPosition < 0) {
          break;
        }
      }
    } else {
      finalPosition = position;
    }

    if (finalPosition === null || finalPosition === this._currentItem) {
      return;
    }

    itemId = this._rawItems[finalPosition].id;
    el = document.getElementById(this._localIdToDom(itemId));
    el.classList.add('hover');
  }

  if (this._currentItem !== null) {
    itemId = this._rawItems[this._currentItem].id;
    el = document.getElementById(this._localIdToDom(itemId));
    el.classList.remove('hover');
  }

  this._currentItem = finalPosition;
};

ContextMenu.prototype._getAvailableId = function () {
  var id = this._rawItems.length;

  while (this._items[id]) {
    id++;
  }
  return id;
};

ContextMenu.prototype._handleClick = function (evt) {
  var id = evt.target.getAttribute('id');
  if (!id) {
    return;
  }

  id = this._domIdToLocal(id);

  if (this._items[id] && this._items[id].fn && !this._items[id].disabled) {
    this._items[id].fn.call(this, id);
    this.emit('click', { id: id });
  }
};

ContextMenu.prototype._createSubMenu = function (id, items, filter) {
  if (this._id !== null) {
    id = this._id + '-' + id;
  }

  return new ContextMenu({
    filter: filter,
    items: items,
    container: this._container,
    parent: this,
    id: id
  });
};

ContextMenu.prototype._hideSubMenus = function () {
  for (var i in this._items) {
    if (this._items[i].submenu) {
      this._items[i].submenu.hide();
    }
  }
};

ContextMenu.prototype._scrollToItem = function (id) {
  var el = document.getElementById(this._localIdToDom(id));

  var position = el.offsetTop - el.parentNode.scrollTop;

  var minPosition = 0;
  var maxPosition = el.parentNode.offsetHeight - el.offsetHeight;

  if (position > maxPosition) {
    el.parentNode.scrollTop = el.offsetTop - maxPosition;
  }

  if (position < minPosition) {
    el.parentNode.scrollTop = el.offsetTop - minPosition;
  }
};

ContextMenu.prototype._handleHover = function (evt, id) {
  this._potentialHovers = [];
  this._hideSubMenus();

  if (!this._items[id]) {
    return;
  }

  if (this._items[id].submenu && !this._items[id].disabled) {
    var submenu = this._items[id].submenu;
    this._previousItem = id;

    var scrollOffset = evt.target.parentNode.scrollTop;

    var y = evt.target.offsetTop - scrollOffset + this._position.y - 5;
    var x = this._position.x + this._element.offsetWidth;

    if (this._filter) {
      this._filterElement.blur();
    }

    submenu.show({ x: x, y: y, offsetX: this._element.offsetWidth });
    this._active = false;
  } else {
    // Activate the current menu
    if (this._filter) {
      this._filterElement.focus();
    }
    this._active = true;
  }
};

ContextMenu.prototype._handleKeyDown = function (evt) {
  if (evt.keyCode === KEY_ESCAPE) {
    this.hide();
  }

  if (evt.keyCode === KEY_DOWN || evt.keyCode === KEY_UP) {
    this._mode = 'keyboard';
  }
};

ContextMenu.prototype._handleKeyNavigation = function (evt) {
  if (!this._active) {
    return;
  }

  switch (evt.keyCode) {
    case KEY_UP:
      return this._handleKeyNavigationUp(evt);
    case KEY_DOWN:
      return this._handleKeyNavigationDown(evt);
    case KEY_LEFT:
      return this._handleKeyNavigationLeft(evt);
    case KEY_RIGHT:
      return this._handleKeyNavigationRight(evt);
    case KEY_ENTER:
      return this._handleKeyNavigationEnter(evt);
  }
};

ContextMenu.prototype._handleKeyNavigationUp = function (evt) {
  evt.preventDefault();

  var position;
  if (this._currentItem === null) {
    position = this._rawItems.length;
  } else {
    position = parseInt(this._currentItem, 10);
  }

  this._setCurrentItem(position - 1, -1);

  if (this._currentItem !== null) {
    this._scrollToItem(this._rawItems[this._currentItem].id);
  }
};

ContextMenu.prototype._handleKeyNavigationDown = function (evt) {
  evt.preventDefault();

  var position;
  if (this._currentItem === null) {
    position = -1;
  } else {
    position = parseInt(this._currentItem, 10);
  }

  this._setCurrentItem(position + 1, 1);

  if (this._currentItem !== null) {
    this._scrollToItem(this._rawItems[this._currentItem].id);
  }
};

ContextMenu.prototype._handleKeyNavigationLeft = function (evt) {
  evt.preventDefault();

  if (this._parent) {
    this.hide();
    this._parent._active = true;
    if (this._parent._filter) {
      this._parent._filterElement.focus();
    }
  }
};

ContextMenu.prototype._handleKeyNavigationRight = function (evt) {
  if (this._currentItem === null) {
    return;
  }

  var item = this._items[this._rawItems[this._currentItem].id];

  if (item.submenu) {
    var element = document.getElementById(this._localIdToDom(this._rawItems[this._currentItem].id));

    if (element.classList.contains('filtered')) {
      return;
    }

    this._active = false;

    var scrollOffset = element.parentNode.scrollTop;

    var y = element.offsetTop - scrollOffset + this._position.y - 5;
    var x = this._position.x + this._element.offsetWidth;
    item.submenu.show({ x: x, y: y, offsetX: this._element.offsetWidth });
    item.submenu._setCurrentItem(0, 1);
  }

  evt.preventDefault();
};

ContextMenu.prototype._handleKeyNavigationEnter = function () {
  if (this._currentItem === null) {
    return;
  }

  var id = this._rawItems[this._currentItem].id;
  var item = this._items[id];

  var elem = document.getElementById(this._localIdToDom(id));

  if (item && item.fn && !item.disabled && !elem.classList.contains('filtered')) {
    item.fn.call(this, id);
  }

  elem.classList.add('active');

  setTimeout(function () {
    elem.classList.remove('active');
  }, 80);
};

ContextMenu.prototype._handleCloseFilter = function (evt) {
  // check for esc key pressed
  if (evt.keyCode === KEY_ESCAPE) {
    if (document.getElementById(this._localIdToDom() + '-filter').value) {
      document.getElementById(this._localIdToDom() + '-filter').value = '';
      evt.stopPropagation();
      this._filterFn();
    }
  }
};

ContextMenu.prototype._handleFilter = function (evt) {
  // check for esc key pressed
  if (evt.keyCode === KEY_ESCAPE) {
    document.getElementById(this._localIdToDom() + '-filter').value = '';
  }

  this._filterFn();
};

ContextMenu.prototype._filterFn = function () {
  var query = document.getElementById(this._localIdToDom() + '-filter').value;

  for (var i in this._items) {
    var el = document.getElementById(this._localIdToDom(i));
    var text = this._items[i].text;

    var pos = text.toLowerCase().indexOf(query.toLowerCase());
    if (pos === -1) {
      el.classList.add('filtered');
    } else {
      if (query) {
        var html = [this._escapeHtml(text.substring(0, pos)), '<span class="highlight">', this._escapeHtml(text.substring(pos, pos + query.length)), '</span>', this._escapeHtml(text.substring(pos + query.length))].join('');

        el.querySelector('.text').innerHTML = html;
      } else {
        el.querySelector('.text').innerHTML = this._escapeHtml(this._items[i].text);
      }
      el.classList.remove('filtered');
    }

    if (this._items[i].submenu) {
      this._items[i].submenu.hide();
    }
  }

  this._reposition();
};

ContextMenu.prototype._getPositionById = function (id) {
  for (var i in this._rawItems) {
    if (this._rawItems[i].id + '' === id) {
      return i;
    }
  }
  return null;
};

ContextMenu.prototype._calcPosition = function (position) {
  // clone the position object
  position = {
    x: position.x,
    y: position.y,
    offsetX: position.offsetX
  };

  this._element.style.height = 'auto';

  var elementH = this._element.offsetHeight;
  var elementW = this._element.offsetWidth;
  var containerH = this._container.offsetHeight;
  var containerW = this._container.offsetWidth;

  var offset = position.offsetX || 0;

  var availableSpaceRight = containerW - this._offset - position.x;
  var availableSpaceLeft = position.x - offset - this._offset;

  if (elementW < availableSpaceRight) {
    // default scenario, menu opens in the right
  } else if (elementW < availableSpaceLeft) {
      // the menu doesn't fit in the right
      position.x = position.x - elementW - offset;
    } else if (availableSpaceRight > availableSpaceLeft) {
      this._element.style.width = availableSpaceRight + 'px';
    } else {
      position.x = this._offset;
      this._element.style.width = availableSpaceLeft + 'px';
    }

  if (position.y + elementH > containerH - this._offset) {
    position.y = containerH - elementH - this._offset;
  }

  if (elementH > containerH - this._offset * 2 - this._offset) {
    position.y = this._offset;
    position.h = containerH - this._offset * 2 - this._offset;
  }

  return position;
};

ContextMenu.prototype._cancelPotentialHover = function () {
  if (this._potentialHovers && this._potentialHovers.length) {
    if (this._previousItem) {
      this._setCurrentItem(this._getPositionById(this._previousItem));
    }
    this._potentialHovers.forEach(window.clearTimeout);
  }
};

ContextMenu.prototype._handlePotentialHover = function (evt) {
  if (this._mode === 'keyboard') {
    // discard hover events when we are in keyboard mode
    // (when navigating with the keyboard, the menu can be scrolled and this can
    // cause hover events that we don't want to receive)
    return;
  }

  var id = evt.target.getAttribute('id');
  if (!id) {
    return;
  }
  id = this._domIdToLocal(id);

  this._setCurrentItem(this._getPositionById(id));

  if (this._parent) {
    this._parent._cancelPotentialHover();
  }

  if (!this._potentialHovers) {
    this._potentialHovers = [];
  }

  this._potentialHovers.push(setTimeout(this._handleHover.bind(this, evt, id), 100));
};

ContextMenu.prototype._handleMouseMove = function () {
  this._mode = 'mouse';
};

ContextMenu.prototype._handleMouseDown = function (evt) {
  if (evt.target === this._container) {
    evt.preventDefault();
    this.hide();
  }
};

ContextMenu.prototype._escapeHtml = function (str) {
  var div = document.createElement('div');
  div.appendChild(document.createTextNode(str));
  return div.innerHTML;
};

/**
 * Export public interface
 */
module.exports = ContextMenu;

},{"./style.css":180,"spotify-eventemitter":700}],180:[function(require,module,exports){
var css = "body {\n  margin: 0;\n  padding: 0;\n}\n\n.context-menu-container {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  top: 0;\n  left: 0;\n}\n\n.context-menu {\n  padding: 5px 0;\n  position: absolute;\n  display: none;\n  width: auto;\n  min-width: 160px;\n  max-width: 350px;\n  color: #c8c8c8;\n  background-color: #333;\n  box-shadow: 0 0 10px rgba(0, 0, 0, 0.8);\n}\n\n.context-menu .item {\n  padding: 4px 25px 4px 25px;\n  position: relative;\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n  cursor: default;\n  line-height: 18px;\n}\n\n.context-menu .sep {\n  display: block;\n  margin: 4px 0;\n  height: 1px;\n  background-color: #444;\n}\n\n.context-menu .item.disabled {\n  color: #666;\n}\n\n.context-menu .filter-search {\n  position: fixed;\n  left: 0;\n  right: 0;\n  height: 0px;\n  width: 0px;\n  opacity: 0;\n}\n\n.context-menu .filter-search input:focus {\n  outline: 0;\n}\n\n.context-menu .item.disabled.hover {\n  background-color: transparent;\n}\n\n.context-menu .item.check {\n  padding-left: 10px;\n}\n\n.context-menu .item.check:before {\n  content: '✓';\n  font-weight: @glue1-font-weight-bold;\n  display: inline-block;\n  width: 15px;\n}\n\n.context-menu .item span {\n  pointer-events: none;\n}\n\n.context-menu .item.secondary {\n  display: flex;\n  flex-direction: row;\n  justify-content: space-between;\n  padding-right: 10px;\n}\n\n.context-menu .item.secondary .text {\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n\n.context-menu .item.secondary .secondary {\n  margin-left: 20px;\n  letter-spacing: 1px;\n  flex-shrink: 0;\n}\n\n.context-menu .filtered {\n  display: none;\n}\n\n.context-menu .item .highlight {\n  background-color: #cfcf00;\n  color: #333;\n  padding: 0 3px;\n  border-radius: 2px;\n}\n\n.context-menu .item.parent:after {\n  content: ' ';\n  display: block;\n  position: absolute;\n  right: 10px;\n  top: 8px;\n  width: 0px;\n  height: 0px;\n  border-style: solid;\n  border-width: 4px 0 4px 6px;\n  border-color: transparent transparent transparent #666;\n}\n\n\n.context-menu .item.hover {\n  background-color: #444;\n  cursor: default;\n}\n\n.context-menu .item.active, .context-menu .item:active {\n  background-color: #777;\n}\n\n.context-menu .item:last-child {\n  border: 0;\n}\n"; (require("./../../node_modules/cssify"))(css); module.exports = css;
},{"./../../node_modules/cssify":525}],181:[function(require,module,exports){
(function (global){
'use strict';

var cosmos = require('spotify-cosmos-api');

var abba = function abba(flag, callback) {
  cosmos.resolver.post({
    url: 'sp://abba/v1/flags',
    body: {
      flags: [flag]
    }
  }, function (err, response) {
    if (global.__spotify.abba_overrides && flag in global.__spotify.abba_overrides) {
      callback(null, global.__spotify.abba_overrides[flag]);
      return;
    }

    if (err) {
      callback(err, null);
      return;
    }
    var body = response.getJSONBody();
    var flags = body && body.flags || [];
    var featureFlagCell = flags[0] && flags[0].featureName === flag && flags[0].cell;
    callback(null, featureFlagCell || null);
  });
};
module.exports = abba;
// Also expose as an easily stubbable property.
abba.get = abba;

abba.subscribe = function (flag, callback) {
  var oldValue;

  var update = function update(newValue) {
    // ABBA might pub even though the value we're after haven't actually
    // changed, so must make sure that the flag we're tracking actually
    // changed value.
    if (newValue !== oldValue) {
      oldValue = newValue;
      callback(null, newValue);
    }
  };

  var cosmosSubscription = cosmos.resolver.subscribe({
    url: 'sp://abba/v1/flags',
    body: {
      flags: [flag]
    }
  }, function (subscribeError) {
    if (subscribeError) {
      callback(subscribeError);
      return;
    }

    abba.get(flag, function (err, newValue) {
      if (err) {
        callback(err);
        return;
      }
      update(newValue);
    });
  });

  var subscription = {
    cancel: function cancel() {
      if (cosmosSubscription) cosmosSubscription.cancel();
      var index = abba._subscriptions[flag].indexOf(subscription);
      if (index !== -1) {
        abba._subscriptions[flag].splice(index, 1);
      }
      subscription = cosmosSubscription = null;
    },
    _update: update
  };

  if (!(flag in abba._subscriptions)) abba._subscriptions[flag] = [];
  abba._subscriptions[flag].push(subscription);

  return subscription;
};

abba._subscriptions = {};

abba.override = function (flag, value) {
  if (!('abba_overrides' in global.__spotify)) global.__spotify.abba_overrides = {};
  global.__spotify.abba_overrides[flag] = value;

  (abba._subscriptions[flag] || []).forEach(function (subscription) {
    subscription._update(value);
  });
  console.warn('[abba.override]', 'Keep in mind that this is not persistent and only updates existing `abba.subscribe`s and subsequent `abba.get`s');
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"spotify-cosmos-api":694}],182:[function(require,module,exports){
module.exports = {
  "HideAnnouncements": "Ankündigungen ausblenden",
  "Sponsored": "Gesponsert",
  "Advertisement": "Werbung",
  "Promoted": "Beworben",
  "PresentedBy": "Präsentiert von"
};
},{}],183:[function(require,module,exports){
module.exports = {
  "HideAnnouncements": "Απόκρυψη ανακοινώσεων",
  "Sponsored": "Χορηγία",
  "Advertisement": "Διαφήμιση",
  "Promoted": "Προώθηση",
  "PresentedBy": "Παρουσιάζεται από:"
};
},{}],184:[function(require,module,exports){
module.exports = {
  "HideAnnouncements": "Hide Announcements",
  "Sponsored": "Sponsored",
  "Advertisement": "Advertisement",
  "Promoted": "Promoted",
  "PresentedBy": "Presented By"
};
},{}],185:[function(require,module,exports){
module.exports = {
  "HideAnnouncements": "Ocultar Noticias",
  "Sponsored": "Patrocinado",
  "Advertisement": "Anuncio",
  "Promoted": "Promocionados",
  "PresentedBy": "Presentado por"
};
},{}],186:[function(require,module,exports){
module.exports = {
  "HideAnnouncements": "Ocultar mensajes",
  "Sponsored": "Patrocinado",
  "Advertisement": "Publicidad",
  "Promoted": "Promocionados",
  "PresentedBy": "Ofrecido por"
};
},{}],187:[function(require,module,exports){
module.exports = {
  "HideAnnouncements": "Piilota ilmoitukset",
  "Sponsored": "Sponsoroitu",
  "Advertisement": "Mainos",
  "Promoted": "Nostettu",
  "PresentedBy": "Listan tarjoaa"
};
},{}],188:[function(require,module,exports){
module.exports = {
  "HideAnnouncements": "Masquer les publicités",
  "Sponsored": "Commandité",
  "Advertisement": "Publicité",
  "Promoted": "Commanditée",
  "PresentedBy": "Présenté par"
};
},{}],189:[function(require,module,exports){
module.exports = {
  "HideAnnouncements": "Masquer",
  "Sponsored": "Sponsorisé",
  "Advertisement": "Publicité",
  "Promoted": "Sponsorisé",
  "PresentedBy": "Présenté(e) par"
};
},{}],190:[function(require,module,exports){
module.exports = {
  "HideAnnouncements": "Hírek elrejtése",
  "Sponsored": "Fizetett hirdetés",
  "Advertisement": "Reklám",
  "Promoted": "Szponzorált",
  "PresentedBy": "Szponzor:"
};
},{}],191:[function(require,module,exports){
module.exports = {
  "HideAnnouncements": "Sembunyikan Pemberitahuan",
  "Sponsored": "Disponsori",
  "Advertisement": "Iklan",
  "Promoted": "Dipromosikan",
  "PresentedBy": "Disajikan Oleh"
};
},{}],192:[function(require,module,exports){
(function (global){
'use strict';

var window = window || global;

var Translations = require('../../spotify-translations');
var glueLocales = require('../../spotify-glue-cat/strings');

var locales = {
  'de': require('../i18n/de.lang'),
  'el': require('../i18n/el.lang'),
  'en': require('../i18n/en.lang'),
  'es': require('../i18n/es.lang'),
  'es-419': require('../i18n/es-419.lang'),
  'fi': require('../i18n/fi.lang'),
  'fr': require('../i18n/fr.lang'),
  'fr-CA': require('../i18n/fr-CA.lang'),
  'hu': require('../i18n/hu.lang'),
  'id': require('../i18n/id.lang'),
  'it': require('../i18n/it.lang'),
  'ja': require('../i18n/ja.lang'),
  'nl': require('../i18n/nl.lang'),
  'pl': require('../i18n/pl.lang'),
  'pt-BR': require('../i18n/pt-BR.lang'),
  'sv': require('../i18n/sv.lang'),
  'tr': require('../i18n/tr.lang'),
  'zh-Hant': require('../i18n/zh-Hant.lang'),
  'zsm': require('../i18n/zsm.lang')
};

var i18n = new Translations();

function getClientLocale() {
  return window.__spotify && window.__spotify.locale || 'en';
}

function setLocale(locale) {
  if (locale === 'auto') {
    locale = getClientLocale();
  }

  var strings = locales[locale].strings || locales[locale];

  i18n.injectData(strings || {});
}

setLocale('auto');

exports.locale = getClientLocale;
exports.locales = locales;
exports.setLocale = setLocale;
exports.get = i18n.get.bind(i18n);

exports.glueStrings = function () {
  return glueLocales[getClientLocale()];
};

exports.appStrings = function () {
  return locales[getClientLocale()];
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../spotify-glue-cat/strings":351,"../../spotify-translations":492,"../i18n/de.lang":182,"../i18n/el.lang":183,"../i18n/en.lang":184,"../i18n/es-419.lang":185,"../i18n/es.lang":186,"../i18n/fi.lang":187,"../i18n/fr-CA.lang":188,"../i18n/fr.lang":189,"../i18n/hu.lang":190,"../i18n/id.lang":191,"../i18n/it.lang":193,"../i18n/ja.lang":194,"../i18n/nl.lang":195,"../i18n/pl.lang":196,"../i18n/pt-BR.lang":197,"../i18n/sv.lang":198,"../i18n/tr.lang":199,"../i18n/zh-Hant.lang":200,"../i18n/zsm.lang":201}],193:[function(require,module,exports){
module.exports = {
  "HideAnnouncements": "Nascondi annunci",
  "Sponsored": "Sponsorizzato",
  "Advertisement": "Pubblicità",
  "Promoted": "Promossi",
  "PresentedBy": "Presentato da"
};
},{}],194:[function(require,module,exports){
module.exports = {
  "HideAnnouncements": "お知らせを非表示にする",
  "Sponsored": "スポンサー付き",
  "Advertisement": "広告",
  "Promoted": "プロモーション済み",
  "PresentedBy": "提供元:"
};
},{}],195:[function(require,module,exports){
module.exports = {
  "HideAnnouncements": "Aankondigingen verbergen",
  "Sponsored": "Gesponsord",
  "Advertisement": "Advertentie",
  "Promoted": "Aangeboden",
  "PresentedBy": "Gepresenteerd door"
};
},{}],196:[function(require,module,exports){
module.exports = {
  "HideAnnouncements": "Ukryj ogłoszenia",
  "Sponsored": "Sponsorowane",
  "Advertisement": "Reklama",
  "Promoted": "Promowane",
  "PresentedBy": "Prezentuje"
};
},{}],197:[function(require,module,exports){
module.exports = {
  "HideAnnouncements": "Ocultar",
  "Sponsored": "Patrocinado",
  "Advertisement": "Propaganda",
  "Promoted": "Promocional",
  "PresentedBy": "Apresentadas por"
};
},{}],198:[function(require,module,exports){
module.exports = {
  "HideAnnouncements": "Dölj musikaviseringar",
  "Sponsored": "Sponsrad",
  "Advertisement": "Reklam",
  "Promoted": "Sponsrat",
  "PresentedBy": "Presenteras av"
};
},{}],199:[function(require,module,exports){
module.exports = {
  "HideAnnouncements": "Duyuruları Gizle",
  "Sponsored": "Sponsorlu",
  "Advertisement": "Reklam",
  "Promoted": "Tanıtılan",
  "PresentedBy": "Sunan"
};
},{}],200:[function(require,module,exports){
module.exports = {
  "HideAnnouncements": "隱藏公告",
  "Sponsored": "贊助",
  "Advertisement": "廣告",
  "Promoted": "已宣傳",
  "PresentedBy": "贊助商："
};
},{}],201:[function(require,module,exports){
module.exports = {
  "HideAnnouncements": "Sembunyikan Pengumuman",
  "Sponsored": "Tajaan",
  "Advertisement": "Iklan",
  "Promoted": "Dipromosikan",
  "PresentedBy": "Dipersembahkan Oleh"
};
},{}],202:[function(require,module,exports){
module.exports = '<svg width="150px" height="20px" viewBox="0 0 147 20" version="1.1" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" xmlns:sketch="http://www.bohemiancoding.com/sketch/ns">\n    <title>spotify spotlight svg 2</title>\n    <desc>Created with Sketch.</desc>\n    <defs></defs>\n    <g id="Page-1" stroke="none" stroke-width="1" fill="none" fill-rule="evenodd" sketch:type="MSPage">\n        <rect id="Rectangle-1" fill="#FFFFFF" sketch:type="MSShapeGroup" x="70" y="5" width="1" height="11"></rect>\n        <g id="Imported-Layers" sketch:type="MSLayerGroup">\n            <path d="M10.001005,0.0447 C4.48874372,0.0447 0.0198994975,4.491 0.0198994975,9.9758 C0.0198994975,15.461 4.48874372,19.9071 10.001005,19.9071 C15.5135678,19.9071 19.9821106,15.461 19.9821106,9.9758 C19.9821106,4.491 15.5135678,0.0447 10.001005,0.0447" id="Fill-1" fill="#84BD00" sketch:type="MSShapeGroup"></path>\n            <path d="M15.5438191,10.6003 C12.4630151,8.7165 7.95648241,8.1864 4.33135678,9.2809 C3.92060302,9.4054 3.68844221,9.8371 3.81246231,10.2466 C3.93748744,10.6553 4.3720603,10.8861 4.78361809,10.7624 C7.95698492,9.804 12.0471357,10.2792 14.7294472,11.9197 C15.0951759,12.1435 15.5740704,12.0292 15.799799,11.6648 C16.0247236,11.3012 15.9095477,10.8244 15.5438191,10.6003" id="Fill-2" fill="#000000" sketch:type="MSShapeGroup"></path>\n            <path d="M16.8580905,7.2513 C13.1541709,5.0637 7.29326633,4.858 3.76753769,5.9229 C3.27396985,6.072 2.9958794,6.5906 3.14532663,7.0816 C3.29477387,7.5724 3.81628141,7.8494 4.30954774,7.7005 C7.38090452,6.773 12.6878392,6.9478 15.9051256,8.8489 C16.3477387,9.111 16.9211055,8.9655 17.1842211,8.5241 C17.4472362,8.0834 17.3017085,7.5133 16.8580905,7.2513" id="Fill-3" fill="#000000" sketch:type="MSShapeGroup"></path>\n            <path d="M14.3720603,13.5178 C11.7413065,11.9182 8.4798995,11.546 4.67788945,12.4108 C4.34231156,12.4868 4.13326633,12.8189 4.21005025,13.152 C4.28633166,13.485 4.62,13.6938 4.95487437,13.6174 C8.42914573,12.8277 11.3792965,13.1496 13.7231156,14.575 C14.0160804,14.7533 14.3990955,14.6616 14.5784925,14.369 C14.7577889,14.0772 14.6654271,13.696 14.3720603,13.5178" id="Fill-4" fill="#000000" sketch:type="MSShapeGroup"></path>\n        </g>\n        <g id="Imported-Layers" sketch:type="MSLayerGroup" transform="translate(25.000000, 5.000000)" fill="#FFFFFF">\n            <path d="M3.80616092,4.19354545 C2.22942529,3.82181818 1.9485977,3.56090909 1.9485977,3.01281818 C1.9485977,2.49481818 2.44193103,2.14636364 3.17535632,2.14636364 C3.88643678,2.14636364 4.59135632,2.411 5.33057471,2.95590909 C5.35291954,2.97236364 5.38096552,2.979 5.40845977,2.97472727 C5.43604598,2.97063636 5.46050575,2.95563636 5.47668966,2.93309091 L6.24662069,1.86009091 C6.27816092,1.816 6.2696092,1.75509091 6.22694253,1.72127273 C5.34721839,1.02336364 4.3565977,0.684090909 3.19871264,0.684090909 C1.49627586,0.684090909 0.307126437,1.69418182 0.307126437,3.13936364 C0.307126437,4.68918182 1.33287356,5.23790909 3.10556322,5.66145455 C4.61443678,6.00509091 4.86905747,6.29290909 4.86905747,6.80754545 C4.86905747,7.37772727 4.3542069,7.73227273 3.52551724,7.73227273 C2.60514943,7.73227273 1.85443678,7.42572727 1.01462069,6.70672727 C0.99383908,6.689 0.965241379,6.68081818 0.938850575,6.68236364 C0.91108046,6.68463636 0.885701149,6.69736364 0.868045977,6.71836364 L0.0047816092,7.734 C-0.0314482759,7.77618182 -0.0268505747,7.83909091 0.0149885057,7.87563636 C0.992091954,8.738 2.19374713,9.19354545 3.49057471,9.19354545 C5.32514943,9.19354545 6.51062069,8.20254545 6.51062069,6.66863636 C6.51062069,5.37236364 5.72717241,4.65545455 3.80616092,4.19354545" id="Fill-1" sketch:type="MSShapeGroup"></path>\n            <path d="M10.6611494,2.65618182 C9.86593103,2.65618182 9.21370115,2.96581818 8.67586207,3.60027273 L8.67586207,2.88618182 C8.67586207,2.82981818 8.6296092,2.78390909 8.5725977,2.78390909 L7.16082759,2.78390909 C7.10381609,2.78390909 7.05765517,2.82981818 7.05765517,2.88618182 L7.05765517,10.8211818 C7.05765517,10.8775455 7.10381609,10.9234545 7.16082759,10.9234545 L8.5725977,10.9234545 C8.6296092,10.9234545 8.67586207,10.8775455 8.67586207,10.8211818 L8.67586207,8.31645455 C9.2137931,8.91336364 9.86611494,9.20490909 10.6611494,9.20490909 C12.1386667,9.20490909 13.6342989,8.08045455 13.6342989,5.93090909 C13.6342989,3.78090909 12.1386667,2.65618182 10.6611494,2.65618182 L10.6611494,2.65618182 Z M11.9928276,5.93090909 C11.9928276,7.02545455 11.3108046,7.78936364 10.3343448,7.78936364 C9.36891954,7.78936364 8.64064368,6.99072727 8.64064368,5.93090909 C8.64064368,4.87118182 9.36891954,4.07254545 10.3343448,4.07254545 C11.2950805,4.07254545 11.9928276,4.85390909 11.9928276,5.93090909 L11.9928276,5.93090909 Z" id="Fill-2" sketch:type="MSShapeGroup"></path>\n            <path d="M17.4683218,2.65618182 C15.5654253,2.65618182 14.0747586,4.10472727 14.0747586,5.95427273 C14.0747586,7.78372727 15.5552184,9.21709091 17.4449655,9.21709091 C19.3544828,9.21709091 20.8497471,7.77336364 20.8497471,5.93090909 C20.8497471,4.09454545 19.3647816,2.65618182 17.4683218,2.65618182 L17.4683218,2.65618182 Z M17.4683218,7.80081818 C16.4561839,7.80081818 15.6931494,6.99681818 15.6931494,5.93090909 C15.6931494,4.86054545 16.4297931,4.08372727 17.4449655,4.08372727 C18.4635402,4.08372727 19.2318161,4.88763636 19.2318161,5.95427273 C19.2318161,7.02445455 18.4901149,7.80081818 17.4683218,7.80081818 L17.4683218,7.80081818 Z" id="Fill-3" sketch:type="MSShapeGroup"></path>\n            <path d="M24.9131954,2.78390909 L23.3595402,2.78390909 L23.3595402,1.21345455 C23.3595402,1.15709091 23.3134713,1.11127273 23.2564598,1.11127273 L21.8447816,1.11127273 C21.7876782,1.11127273 21.7413333,1.15709091 21.7413333,1.21345455 L21.7413333,2.78390909 L21.0624368,2.78390909 C21.0056092,2.78390909 20.9595402,2.82981818 20.9595402,2.88618182 L20.9595402,4.08572727 C20.9595402,4.142 21.0056092,4.188 21.0624368,4.188 L21.7413333,4.188 L21.7413333,7.292 C21.7413333,8.54636364 22.3727816,9.18236364 23.6182989,9.18236364 C24.1246897,9.18236364 24.5448276,9.079 24.9407816,8.857 C24.9729655,8.83918182 24.9930115,8.80490909 24.9930115,8.76845455 L24.9930115,7.62618182 C24.9930115,7.59090909 24.9744368,7.55763636 24.944,7.53918182 C24.9131954,7.52009091 24.8749425,7.51909091 24.8434023,7.53454545 C24.5714023,7.66981818 24.3084138,7.73227273 24.0146207,7.73227273 C23.5616552,7.73227273 23.3595402,7.52890909 23.3595402,7.07327273 L23.3595402,4.188 L24.9131954,4.188 C24.9702069,4.188 25.0161839,4.142 25.0161839,4.08572727 L25.0161839,2.88618182 C25.0161839,2.82981818 24.9702069,2.78390909 24.9131954,2.78390909" id="Fill-4" sketch:type="MSShapeGroup"></path>\n            <path d="M30.326069,2.79 L30.326069,2.59709091 C30.326069,2.02963636 30.546023,1.77663636 31.0397241,1.77663636 C31.333977,1.77663636 31.5703908,1.83445455 31.8352184,1.92181818 C31.8677701,1.93190909 31.9018851,1.92681818 31.9283678,1.90754545 C31.9555862,1.88827273 31.9710345,1.85736364 31.9710345,1.82454545 L31.9710345,0.648363636 C31.9710345,0.603454545 31.9417011,0.563545455 31.898023,0.550363636 C31.6182989,0.468090909 31.2604138,0.383636364 30.7245057,0.383636364 C29.4204138,0.383636364 28.7312184,1.10963636 28.7312184,2.48236364 L28.7312184,2.77781818 L28.0529655,2.77781818 C27.996046,2.77781818 27.9493333,2.82363636 27.9493333,2.88 L27.9493333,4.08572727 C27.9493333,4.142 27.996046,4.188 28.0529655,4.188 L28.7312184,4.188 L28.7312184,8.97572727 C28.7312184,9.03209091 28.7771954,9.078 28.8341149,9.078 L30.245977,9.078 C30.3029885,9.078 30.3494253,9.03209091 30.3494253,8.97572727 L30.3494253,4.188 L31.6675862,4.188 L33.6868966,8.97454545 C33.4576552,9.47745455 33.2321839,9.57754545 32.9245057,9.57754545 C32.6757701,9.57754545 32.4137931,9.50409091 32.146023,9.35918182 C32.1207356,9.34554545 32.0909425,9.34318182 32.0637241,9.35154545 C32.0367816,9.361 32.014069,9.38072727 32.0026667,9.40672727 L31.5241379,10.4446364 C31.5013333,10.4936364 31.5208276,10.5512727 31.5686437,10.5766364 C32.0681379,10.8440909 32.5191724,10.9582727 33.0764138,10.9582727 C34.1188966,10.9582727 34.6951724,10.4781818 35.2031264,9.18663636 L37.6525057,2.92927273 C37.6648276,2.89781818 37.6611494,2.86227273 37.6415632,2.83436364 C37.6222529,2.80663636 37.5908966,2.79 37.5566897,2.79 L36.0868966,2.79 C36.0429425,2.79 36.0034943,2.81763636 35.9891494,2.85845455 L34.4834943,7.11027273 L32.8342989,2.85572727 C32.8192184,2.81609091 32.7806897,2.79 32.7378391,2.79 L30.326069,2.79" id="Fill-5" sketch:type="MSShapeGroup"></path>\n            <path d="M27.188046,2.78390909 L25.7761839,2.78390909 C25.7191724,2.78390909 25.6727356,2.82981818 25.6727356,2.88618182 L25.6727356,8.97572727 C25.6727356,9.03209091 25.7191724,9.078 25.7761839,9.078 L27.188046,9.078 C27.2449655,9.078 27.2914943,9.03209091 27.2914943,8.97572727 L27.2914943,2.88618182 C27.2914943,2.82981818 27.2449655,2.78390909 27.188046,2.78390909" id="Fill-6" sketch:type="MSShapeGroup"></path>\n            <path d="M26.4892874,0.0110909091 C25.930023,0.0110909091 25.4761379,0.458727273 25.4761379,1.01172727 C25.4761379,1.565 25.930023,2.01309091 26.4892874,2.01309091 C27.0483678,2.01309091 27.5017931,1.565 27.5017931,1.01172727 C27.5017931,0.458727273 27.0483678,0.0110909091 26.4892874,0.0110909091" id="Fill-7" sketch:type="MSShapeGroup"></path>\n            <path d="M38.8578391,4.74172727 C38.2991264,4.74172727 37.8642759,4.29809091 37.8642759,3.75936364 C37.8642759,3.22063636 38.3048276,2.77190909 38.8630805,2.77190909 C39.4217931,2.77190909 39.8565517,3.21554545 39.8565517,3.75372727 C39.8565517,4.29254545 39.4164598,4.74172727 38.8578391,4.74172727 L38.8578391,4.74172727 Z M38.8630805,2.86963636 C38.3542069,2.86963636 37.9690115,3.26954545 37.9690115,3.75936364 C37.9690115,4.24890909 38.3513563,4.64354545 38.8578391,4.64354545 C39.3666207,4.64354545 39.7521839,4.24381818 39.7521839,3.75372727 C39.7521839,3.26427273 39.3695632,2.86963636 38.8630805,2.86963636 L38.8630805,2.86963636 Z M39.0833103,3.85481818 L39.3644138,4.24381818 L39.1274483,4.24381818 L38.8744828,3.887 L38.6569195,3.887 L38.6569195,4.24381818 L38.4585747,4.24381818 L38.4585747,3.21272727 L38.9236782,3.21272727 C39.165977,3.21272727 39.3253333,3.33527273 39.3253333,3.54163636 C39.3253333,3.71063636 39.2265747,3.81390909 39.0833103,3.85481818 L39.0833103,3.85481818 Z M38.9156782,3.38963636 L38.6569195,3.38963636 L38.6569195,3.71572727 L38.9156782,3.71572727 C39.0447816,3.71572727 39.1218391,3.65327273 39.1218391,3.55254545 C39.1218391,3.44645455 39.0447816,3.38963636 38.9156782,3.38963636 L38.9156782,3.38963636 Z" id="Fill-8" sketch:type="MSShapeGroup"></path>\n        </g>\n        <path d="M79.9,13.12 C81.7,13.12 82.27,12.09 82.27,11.23 C82.27,8.74 78.27,9.68 78.27,7.97 C78.27,7.25 78.94,6.74 79.83,6.74 C80.58,6.74 81.26,7 81.74,7.58 L82.12,7.16 C81.6,6.57 80.86,6.22 79.86,6.22 C78.65,6.22 77.67,6.91 77.67,8 C77.67,10.33 81.67,9.31 81.67,11.27 C81.67,11.84 81.28,12.6 79.91,12.6 C78.96,12.6 78.26,12.13 77.83,11.63 L77.46,12.06 C77.97,12.68 78.8,13.12 79.9,13.12 L79.9,13.12 Z M86.51,13 L86.51,10.23 L88.44,10.23 C89.71,10.23 90.45,9.33 90.45,8.28 C90.45,7.23 89.72,6.33 88.44,6.33 L85.94,6.33 L85.94,13 L86.51,13 Z M88.38,9.71 L86.51,9.71 L86.51,6.85 L88.38,6.85 C89.26,6.85 89.85,7.44 89.85,8.28 C89.85,9.12 89.26,9.71 88.38,9.71 L88.38,9.71 Z M96.9399999,13.12 C98.8899999,13.12 100.18,11.62 100.18,9.67 C100.18,7.72 98.8899999,6.22 96.9399999,6.22 C94.9799999,6.22 93.6999999,7.72 93.6999999,9.67 C93.6999999,11.62 94.9799999,13.12 96.9399999,13.12 L96.9399999,13.12 Z M96.9399999,12.6 C95.3199999,12.6 94.2999999,11.35 94.2999999,9.67 C94.2999999,7.97 95.3199999,6.74 96.9399999,6.74 C98.5399999,6.74 99.5799999,7.97 99.5799999,9.67 C99.5799999,11.35 98.5399999,12.6 96.9399999,12.6 L96.9399999,12.6 Z M105.88,13 L105.88,6.85 L108.06,6.85 L108.06,6.33 L103.12,6.33 L103.12,6.85 L105.3,6.85 L105.3,13 L105.88,13 Z M115.34,13 L115.34,12.48 L112.11,12.48 L112.11,6.33 L111.54,6.33 L111.54,13 L115.34,13 Z M119.45,13 L119.45,6.33 L118.88,6.33 L118.88,13 L119.45,13 Z M126.54,13.13 C127.59,13.13 128.48,12.68 129.07,12.02 L129.07,9.69 L125.98,9.69 L125.98,10.2 L128.5,10.2 L128.5,11.8 C128.13,12.17 127.43,12.61 126.54,12.61 C124.97,12.61 123.76,11.39 123.76,9.67 C123.76,7.93 124.97,6.74 126.54,6.74 C127.39,6.74 128.15,7.11 128.62,7.67 L129.05,7.36 C128.44,6.66 127.64,6.22 126.54,6.22 C124.67,6.22 123.16,7.61 123.16,9.67 C123.16,11.73 124.67,13.13 126.54,13.13 L126.54,13.13 Z M138.2,13 L138.2,6.33 L137.62,6.33 L137.62,9.31 L133.39,9.31 L133.39,6.33 L132.82,6.33 L132.82,13 L133.39,13 L133.39,9.83 L137.62,9.83 L137.62,13 L138.2,13 Z M144.43,13 L144.43,6.85 L146.61,6.85 L146.61,6.33 L141.67,6.33 L141.67,6.85 L143.85,6.85 L143.85,13 L144.43,13 Z" id="SPOTLIGHT" fill="#FFFFFF" sketch:type="MSShapeGroup"></path>\n    </g>\n</svg>';
},{}],203:[function(require,module,exports){
'use strict';

module.exports = require('./src');

},{"./src":243}],204:[function(require,module,exports){
module.exports={
  "name": "spotify-ad-formats",
  "version": "8.4.1",
  "description": "Component to render ads in the Spotify desktop client and web player",
  "keywords": [
    "ads",
    "leaderboard",
    "hpto",
    "video",
    "companion",
    "billboard"
  ],
  "author": {
    "name": "CREAM team",
    "email": "cream@spotify.com"
  },
  "contributors": [
    "Brice Lin <blin@spotify.com>",
    "Jason Palmer <jpalmer@spotify.com>",
    "Jo Blake <jblake@spotify.com"
  ],
  "browserify": {
    "transform": [
      [
        "hbsfy",
        {
          "traverse": true
        }
      ],
      [
        "partialify",
        {
          "alsoAllow": "svg"
        }
      ]
    ]
  },
  "license": "UNLICENSED",
  "repository": {
    "type": "git",
    "url": "https://ghe.spotify.net/ads/spotify-ad-formats.git"
  },
  "scripts": {
    "dev": "echo App scripts have been removed. Please see docs/app-development.md for more information. && exit 1",
    "prod": "echo App scripts have been removed. Please see docs/app-development.md for more information. && exit 1",
    "spa": "echo App scripts have been removed. Please see docs/app-development.md for more information. && exit 1",
    "enable": "echo App scripts have been removed. Please see docs/app-development.md for more information. && exit 1"
  },
  "main": "./index.js",
  "bugs": {
    "url": "https://ghe.spotify.net/ads/spotify-ad-formats/issues"
  },
  "publishConfig": {
    "registry": "http://npm-registry.spotify.net"
  },
  "private": true
}
},{}],205:[function(require,module,exports){
'use strict';

var CosmosConnector = require('./cosmos-connector');
var cosmosConnector = new CosmosConnector();

var keys = {
  AD_FORMAT: 'ad_format',
  AD_ID: 'ad_id',
  AD_PLAYBACK_ID: 'ad_playback_id',
  APP_STARTUP_ID: 'app_startup_id',
  CONTEXT: 'context',
  CREATIVE_ID: 'creative_id',
  EVENT: 'event',
  EVENT_VERSION: 'event_version',
  IN_FOCUS: 'focus',
  JSONDATA: 'jsondata',
  LINE_ITEM_ID: 'lineitem_id',
  MS_FROM_START: 'ms_from_start',
  SLOT: 'slot',
  SOURCE: 'source',
  SOURCE_VERSION: 'source_version'
};

var defaults = {};
defaults[keys.AD_FORMAT] = '';
defaults[keys.AD_ID] = '';
defaults[keys.AD_PLAYBACK_ID] = '';
defaults[keys.APP_STARTUP_ID] = '';
defaults[keys.CREATIVE_ID] = '';
defaults[keys.CONTEXT] = '';
defaults[keys.EVENT] = '';
defaults[keys.EVENT_VERSION] = '';
defaults[keys.IN_FOCUS] = 'true';
defaults[keys.JSONDATA] = '';
defaults[keys.LINE_ITEM_ID] = '';
defaults[keys.MS_FROM_START] = '0';
defaults[keys.SLOT] = '';
defaults[keys.SOURCE] = '';
defaults[keys.SOURCE_VERSION] = '';

module.exports = {

  /**
   * Keys available to log.
   * @type {Object}
   */
  keys: keys,

  /**
   * Log an AdEvent message to the backend.
   *
   * Will use default values for keys not passed.
   *
   * Logged according to the spec found at https://ghe.spotify.net/datainfra/
   *   log-parser/blob/master/spotify/log_parser/messages_specs.py
   *
   * All values need to be passed to core as strings, otherwise they won't get
   * picked up correctly.
   *
   * @example
   *
   * var adLogger = require('../ad_logger.js');
   * var message = {};
   * message[adLogger.keys.EVENT] = 'event_errored';
   * message[adLogger.keys.AD_FORMAT] = 'banner';
   * message[adLogger.keys.LINE_ITEM_ID] = 'foo';
   * adLogger.log(message);
   *
   * @param {Object} message The data to log.
   * @return {Promise}
   */
  log: function log(message) {
    var fields = Object.assign({}, defaults, message);
    var body = {
      message: 'AdEvent',
      version: 4,
      fields: [// Order matters
      '' + fields[keys.AD_PLAYBACK_ID], '' + fields[keys.APP_STARTUP_ID], '' + fields[keys.AD_ID], '' + fields[keys.LINE_ITEM_ID], '' + fields[keys.CREATIVE_ID], '' + fields[keys.AD_FORMAT], '' + fields[keys.SOURCE], '' + fields[keys.CONTEXT], '' + fields[keys.EVENT], '' + fields[keys.EVENT_VERSION], '' + fields[keys.JSONDATA], '' + fields[keys.SOURCE_VERSION], '' + fields[keys.SLOT], '' + fields[keys.MS_FROM_START], '' + (window.top.document.hasFocus() ? '1' : '0')]
    };
    return cosmosConnector.logMessage(body);
  },

  logError: function logError(context, errorMessage) {
    var body = {
      message: 'AdError',
      version: 2,
      fields: [String(context), String(errorMessage),

      // As of version 2 of AdError, the remaining fields are
      // not relevant for display ads
      '', // http-error-code
      '', // request-url
      '', // companion-ad
      '' // tracking-event
      ]
    };
    console.error('AdError', context, errorMessage);
    return cosmosConnector.logMessage(body);
  }
};

},{"./cosmos-connector":208}],206:[function(require,module,exports){
'use strict';

var abba = require('../../spotify-abba-mini');
var FEATURE_FLAG = 'ad_quality_feedback_desktop';
var CosmosConnector = require('./cosmos-connector');
var cosmosConnector = new CosmosConnector();

function createMessage(creativeId) {
  return {
    message: 'AdFeedbackEvent',
    version: 1,
    fields: ['' + Date.now(), // timestamp
    '', // log_id
    '', // line_item_id
    '' + creativeId, // creative_id
    '' // displayed_ad_content
    ]
  };
}

function createButton() {
  var button = document.createElement('button');
  button.type = 'button';
  button.className = 'ad-feedback-button';
  return button;
}

function doOnce(fn) {
  var count = 0;

  return function () {
    if (count === 0) {
      count++;
      return fn.apply(this, arguments);
    }
  };
}

/**
 * Create an adFeedbackButton.
 * @param {Object} creativeId
 * @return {Object} adFeedbackButton
 * @return {Function} adFeedbackButton.appendTo
 * @example
 * AdFeedbackButton(creativeId).appendTo(parentNode);
 */
function AdFeedbackButton(creativeId) {
  var adFeedbackButton = {};
  var button = createButton();

  adFeedbackButton.appendTo = function (parentNode) {
    parentNode.appendChild(button);
  };

  adFeedbackButton._logMessage = doOnce(function (message) {
    cosmosConnector.logMessage(message);
  });

  function onClick(e) {
    e.preventDefault();
    e.stopPropagation();
    adFeedbackButton._logMessage(createMessage(creativeId));
    button.disabled = true;
  }

  button.addEventListener('click', onClick);

  return adFeedbackButton;
}

/**
 * Checks if user has feature flag to show adFeedbackButton
 *
 * @example
 * AdFeedbackButton
 * .checkFeatureFlag()
 * .then(function () {
 *   AdFeedbackButton(creativeId).appendTo(parentNode);
 * });
 *
 * @return {Promise} Rejects if not enabled
 */
AdFeedbackButton.checkFeatureFlag = function () {
  return new Promise(function (resolve, reject) {
    abba(FEATURE_FLAG, function (err, cell) {
      if (err || cell !== FEATURE_FLAG) {
        reject(err);
      } else {
        resolve();
      }
    });
  });
};

module.exports = AdFeedbackButton;

},{"../../spotify-abba-mini":181,"./cosmos-connector":208}],207:[function(require,module,exports){
'use strict';

var spotlightSvg = null;

/**
 * Singleton class definining the global configuration.
 * This is going to be injected by index.js and bootstrap.js (tests).
 *
 * @api public
 */
var config = {
  /**
   * Gets spotlight svg
   *
   * @return spotlight svg file
   */
  getSpotlightSvg: function getSpotlightSvg() {
    return spotlightSvg;
  },

  /**
   * @param {svg} svg - spotlight svg file
   */
  setSpotlightSvg: function setSpotlightSvg(svg) {
    spotlightSvg = svg;
  }
};

module.exports = config;

},{}],208:[function(require,module,exports){
'use strict';

var debug = require('debug')('saf:cosmos-connector');
var cosmos = require('spotify-cosmos-api');
var sessionId = Date.now();

/**
 * Resource URIs
 */

var AD_CONFIG_ENDPOINT = 'hm://ads/v1/config';
var AD_SLOT_ENDPOINT = 'hm://ads/v1/ads';
var LASERTAG_ENDPOINT = 'hm://lasertag/v1/adtag?alt=json';
var SLOT_URI = 'sp://ads/v1/adslots';
var FORMAT_URI = 'sp://ads/v1/formats/';
var TARGETING_URI = 'sp://ads/v1/targeting';
var STREAMTIME_URI = 'sp://ads/v1/testing/playtime';
var EVENT_URI = 'sp://ads/v1/ads/{adId}/event/{eventType}';
var SETTINGS_URI = 'sp://ads/v1/settings';
var PREVIEW_URI = 'hm://asp/v2/preview/{adId}';
var LOG_URI = 'sp://logging/v1/log';
var SPONSORED_URI = 'hm://sponsoredplaylist/v1/sponsored';
var ABBA_FLAG_URI = 'sp://abba/v1/flags';

var FORMATS = ['audio', 'video', 'banner'];

function getLocalTargeting() {
  return Promise.resolve({
    client_width: document.body.clientWidth,
    client_height: document.body.clientHeight
  });
}

/**
 * Interface for making cosmos requests in SAF context.
 *
 * Usage:
 *   var cosmosConnector = new CosmosConnector();
 *   cosmosConnector.getTargeting().then(function(){
 *     // do something
 *   })
 *
 * @api public
 * @return {void} Constructor
 */
function CosmosConnector() {
  this._cosmos = cosmos;
}

/**
 * Set Cosmos for testing purpose.
 *
 * @api public
 * @param {Object} c - cosmos
 */

CosmosConnector.prototype.setCosmos = function (c) {
  this._cosmos = c;
};

/**
 * Fetch targeting data from Ads Resolver via Cosmos.
 *
 * @api public
 * @return {Promise}
 */

CosmosConnector.prototype.getTargeting = function () {
  return new Promise(function (resolve, reject) {
    var req = new this._cosmos.Request('GET', TARGETING_URI, {});

    this._cosmos.resolver.resolve(req, function (err, res) {
      if (err) reject(new Error(err));else resolve(res.getJSONBody());
    });
  }.bind(this));
};

/**
 * Fetch targeting data from Hermes Resolver via Cosmos.
 *
 * @api public
 * @return {Promise}
 */

CosmosConnector.prototype.getTargetingFromLasertag = function () {
  var req = new this._cosmos.Request('GET', LASERTAG_ENDPOINT, {});

  return this._resolveJSON(req);
};

/**
 * Fetch ad slot config from Spotify Ad Service
 * @api public
 * @param {String} slot The slot id (e.g. leaderboard)
 * @return {Promise<Response>} where Response has the shape:
 *   {
 *      "config_ttl_ms": 300000,
 *      "request_when": {
 *         "focus_time_elapsed_ms": number
 *      },
 *      "iframe_sandboxed_attrs": arrayOf(string)
 *      "app_blacklist": arrayOf(string)   // blacklisted app ids
 *      "app_whitelist": arrayOf(string)   // whitelisted app ids
 *   }
 */
CosmosConnector.prototype.getAdSlotConfig = function (slot) {
  var req = new this._cosmos.Request('GET', AD_CONFIG_ENDPOINT, {});
  return this._resolveJSON(req).then(function (response) {
    return response[slot];
  });
};

/**
 * Fetch an ad from Spotify Ad Service
 * @api public
 * @param {String} slot The slot id (e.g. leaderboard)
 * @return {Promise<Response>} where Response has the shape:
 *   {
 *      "pod": {
 *        "leaderboard": [{
 *          "type": oneOf("text/html"),
 *          "html": string  // html to inject into the iframe
 *        }]
 *      }]
 *   }
 */
CosmosConnector.prototype.getAdForSlot = function (slot) {
  return getLocalTargeting().then(function (targeting) {
    debug('fetch ad for slot=%o, localTargeting=%o', slot, targeting);
    return new this._cosmos.Request('GET', AD_SLOT_ENDPOINT + '/' + slot, {}, {
      targeting: targeting,
      pod: {},
      session_id: sessionId
    });
  }.bind(this)).then(this._resolveJSON.bind(this)).then(function (res) {
    if (!res.pod) {
      throw new Error('pod-not-defined');
    }
    if (!res.pod[slot]) {
      throw new Error('slot-not-defined');
    }
    if (res.pod[slot].length === 0) {
      throw new Error('no-ads');
    }
    return res.pod[slot][0];
  });
};

/*
 * Fetch preview ad from ASP.
 *
 * @api public
 * @param {String} preview ad id (gid)
 * @return {Promise}
 */

CosmosConnector.prototype.getPreviewAd = function (adId) {
  var req = new this._cosmos.Request('GET', PREVIEW_URI.replace('{adId}', adId), {});

  return this._resolveJSON(req);
};

/**
 * Patch targeting by key to value.
 *
 * @api public
 * @param {String|Number} key
 * @param {Object} value
 * @return {Promise}
 */

CosmosConnector.prototype.patchTargeting = function (key, value) {
  return new Promise(function (resolve, reject) {
    var putTargetingRequest = new this._cosmos.Request('PUT', TARGETING_URI + '/' + key, { 'Content-Type': 'application/json' }, {
      value: value
    });

    this._cosmos.resolver.resolve(putTargetingRequest, function (err) {
      debug('patchTargeting key=%o val=%o req=%o err=%o', key, value, putTargetingRequest, err);
      if (err) reject(new Error(err));else resolve(true);
    });
  }.bind(this));
};

/**
 * Increment stream time to receive the next ad break (audio/video).
 *
 * @api public
 * @param {Number} increment in seconds
 * @return {Promise}
 */
CosmosConnector.prototype.increaseStreamTime = function (increment) {
  return new Promise(function (resolve, reject) {
    var streamTimeIncreaseRequest = new this._cosmos.Request('POST', STREAMTIME_URI, { 'Content-Type': 'application/json' }, {
      value: increment
    });

    this._cosmos.resolver.resolve(streamTimeIncreaseRequest, function (err) {
      debug('increaseStreamTime inc=%o err=%o', increment, err);
      if (err) reject(new Error(err));else resolve(true);
    });
  }.bind(this));
};

/**
 * Adds a new adslot to a spotlet by ad type
 *
 * @api public
 * @param {String} slotId - E.g. "stream"
 * @param {String} inventoryType - E.g. "video"
 * @return {Promise}
 */

CosmosConnector.prototype.addNewSlot = function (slotId, inventoryType) {
  return new Promise(function (resolve, reject) {
    var postSlotRequest = new this._cosmos.Request('POST', SLOT_URI, { 'Content-Type': 'application/json' }, { slot_id: slotId, inventory_types: [inventoryType] });

    this._cosmos.resolver.resolve(postSlotRequest, function (err) {
      debug('addNewSlot slotId=%o inventoryType=%o err=%o', slotId, inventoryType, err);
      if (err) reject('addNewSlot error: ', new Error(err));else resolve(SLOT_URI + '/' + slotId + '/' + inventoryType);
    });
  }.bind(this));
};

/**
 * Subscribe to an adslot at `uri'
 *
 * @api public
 * @param {String} slotUri - E.g "sp://ads/v1/adslots/stream/video"
 * @param {Function} callback
 * @return {void}
 */

CosmosConnector.prototype.subscribeToSlot = function (slotUri, callback) {
  var request = new this._cosmos.Request('SUB', slotUri, {});
  this._cosmos.resolver.resolve(request, function (err, res) {
    debug('slot updated uri=%o err=%o res=%o', slotUri, err, res);
    if (!err) callback(res.getJSONBody());
  });
};

/**
 * Subscribe to an adslot type. E.g "sp://ads/v1/adslots/preview"
 *
 * @api public
 * @param {String} slotType - E.g "preview"
 * @param {Function} callback
 * @return {Promise}
 */

CosmosConnector.prototype.subscribeToSlotType = function (slotType, callback) {
  var request = new this._cosmos.Request('SUB', SLOT_URI + '/' + slotType, {});
  this._cosmos.resolver.resolve(request, function (err, res) {
    debug('slot updated type=%o err=%o res=%o', slotType, err, res);
    if (!err) callback(res.getJSONBody());
  });
};

/**
 * Subscribe to a format.
 *
 * @api public
 * @param {String} formatType - E.g "banner"
 * @param {Function} callback
 * @return {Promise}
 */

CosmosConnector.prototype.subscribeToFormat = function (formatType, callback) {
  var request = new this._cosmos.Request('SUB', FORMAT_URI + formatType, {});
  this._cosmos.resolver.resolve(request, function (err, res) {
    if (!err) callback(res.getJSONBody());
  });
};

CosmosConnector.prototype.subscribeToAllFormats = function (callback) {
  FORMATS.map(function (format) {
    this.subscribeToFormat(format, function (ev) {
      callback(format, ev);
    });
  }.bind(this));
};

/**
 * POST ad event.
 *
 * @api public
 * @param {String} adId
 * @param {String} event
 * @param {Object} payload
 * @return {Promise}
 */

CosmosConnector.prototype.postEvent = function (adId, eventType, payload) {
  var eventURI = EVENT_URI.replace('{adId}', adId).replace('{eventType}', eventType);

  return new Promise(function (resolve, reject) {
    var postEventRequest = new this._cosmos.Request('POST', eventURI, {
      'Content-Type': 'application/json'
    }, payload || {});

    this._cosmos.resolver.resolve(postEventRequest, function (err, res) {
      debug('posted event type=%o adId=%o req=%o err=%o res=%o', eventType, adId, postEventRequest, err, res);
      if (err) reject(new Error(err));else resolve(res);
    });
  }.bind(this));
};

/**
 * POST to ad slot
 *
 * @api public
 * @param {String} slotId
 * @params {Object} payload
 * @return {Promise}
 */
CosmosConnector.prototype.postToSlot = function (slotId, payload) {
  var slotURI = SLOT_URI + '/' + slotId;
  return new Promise(function (resolve, reject) {
    var postSlotIdRequest = new this._cosmos.Request('POST', slotURI, {
      'Content-Type': 'application/json'
    }, payload || {});

    this._cosmos.resolver.resolve(postSlotIdRequest, function (err, res) {
      debug('posted to slot id=%o req=%o err=%o res=%o', slotId, postSlotIdRequest, err, res);
      if (err) reject(new Error(err));else resolve(res);
    });
  }.bind(this));
};

/**
 * Get a specific configuration for a given slot.
 *
 * @param {String} slot Name of the slot.
 * @param {String} key Name of the configuration.
 * @return {Promise} Promise that get's resolved with the result.
 */
CosmosConnector.prototype.getSlotConfiguration = function (slot, key) {
  return this.getSlotConfigurations(slot).then(function (response) {
    var result;
    response.getJSONBody().settings.forEach(function (setting) {
      if (setting.id === slot) {
        result = setting[key];
      }
    });
    return result;
  });
};

/**
 * Get the configuration for a given slot.
 *
 * @param {string} slot Name of the slot to get the configuration for.
 * @return {Promise}
 */

CosmosConnector.prototype.getSlotConfigurations = function (slot) {
  var method = 'GET';
  var uri = SETTINGS_URI + '/' + slot;
  var headers = { 'Content-Type': 'application/json' };
  var body = {};
  var request = new this._cosmos.Request(method, uri, headers, body);
  return this._resolve(request);
};

/**
 * Configure an ad slot.
 *
 * @api public
 * @param {string} slot Name of the slot to configure.
 * @param {string} key Name of the key to configure.
 * @param {string} value New value of the key.
 * @return {Promise}
 */

CosmosConnector.prototype.configureSlot = function (slot, key, value) {
  var method = 'PUT';
  var uri = SETTINGS_URI + '/' + slot + '/' + key;
  var headers = { 'Content-Type': 'application/json' };
  var body = { value: value };
  var request = new this._cosmos.Request(method, uri, headers, body);
  return this._resolve(request);
};

CosmosConnector.prototype.logMessage = function (body) {
  var method = 'POST';
  var headers = { 'Content-Type': 'application/json' };
  var request = new this._cosmos.Request(method, LOG_URI, headers, body);
  return this._resolve(request);
};

/**
 * Get list of sponsored uris from Sponsored Playlist service
 *
 * @api public
 * @return {Promise}
 */

CosmosConnector.prototype.getSponsoredUris = function () {
  var req = new this._cosmos.Request('GET', SPONSORED_URI, {});

  return this._resolveJSON(req);
};

/**
 * Get sponsorship ad from Sponsored Playlist service
 *
 * @api public
 * @param {String} uri - playlist uri
 * @return {Promise}
 */

CosmosConnector.prototype.getSponsorshipAd = function (uri) {
  var req = new this._cosmos.Request('GET', SPONSORED_URI + '/' + uri, {});

  return this._resolveJSON(req);
};

CosmosConnector.prototype.subToState = function (cb) {
  var req = new this._cosmos.Request('SUB', 'sp://ads/v1/state', {});

  this._cosmos.resolver.resolve(req, function (err, res) {
    debug('state update err=%o, res=%o', err, res);
    if (!err) cb(res.getJSONBody());
  });
};

CosmosConnector.prototype.getState = function () {
  var req = new this._cosmos.Request('GET', 'sp://ads/v1/state', {});

  return this._resolveJSON(req);
};

/**
 * Fetch feature flags from ABBA
 *
 * @api public
 * @param {Array} flags - array of flags to fetch
 * @return {Promise}
 */

CosmosConnector.prototype.getFeatureFlags = function (flags) {
  var req = new this._cosmos.Request('POST', ABBA_FLAG_URI, { 'Content-Type': 'application/json' }, { flags: flags });

  return this._resolveJSON(req);
};

/**
 * Resolve a Cosmos request.
 *
 * @api private
 * @param {Cosmos.Request} request Request to resolve.
 * @return {Promise}
 */

CosmosConnector.prototype._resolve = function (request) {
  return new Promise(function (resolve, reject) {
    this._cosmos.resolver.resolve(request, function (err, res) {
      debug('resolve req=%o, err=%o, res=%o', request, err, res);
      if (err) reject(new Error(err));else resolve(res);
    });
  }.bind(this));
};

/**
 * Resolve a cosmos request, and return the JSON result.
 *
 * NOTE: This won't work with SUB requests since the promise will only
 * execute once.
 *
 * @api private
 * @param {Cosmos.Request} request Request to resolve.
 * @return {Promise}
 */

CosmosConnector.prototype._resolveJSON = function (request) {
  return this._resolve(request).then(function (res) {
    return res.getJSONBody();
  });
};

module.exports = CosmosConnector;

},{"debug":526,"spotify-cosmos-api":694}],209:[function(require,module,exports){
'use strict';

var SVG_NAMESPACE = 'http://www.w3.org/2000/svg';

/**
 * Renders a pie chart like count down timer using SVG.
 *
 * Typical use case:
 *
 * var container = document.getElementById('animation-container');
 * var animation = new CountDownAnimation(container, 2000);
 * ...
 * animation.start(); // start the count down
 *
 * @param {Element} container - Container to render the count down in.
 * @param {Number} duration - Animation duration in ms.
 */
function CountDownAnimation(container, duration) {
  this._container = container;
  this._duration = duration;
  this._started = 0;
  this._remaining = 1.0;
  this._animate = this._animate.bind(this);
  this._setupDomNodes();
  this._draw(); // Render first frame
}

/**
 * Start the animation.
 *
 * @public
 */

CountDownAnimation.prototype.start = function () {
  this._started = new Date().getTime();
  this._animate();
};

/**
 * Create the dom nodes needed for the animation.
 *
 * @private
 */

CountDownAnimation.prototype._setupDomNodes = function () {
  this._svg = document.createElementNS(SVG_NAMESPACE, 'svg');
  this._svg.setAttribute('id', 'countdown');
  this._svg.setAttribute('width', '20');
  this._svg.setAttribute('height', '20');

  this._circle = document.createElementNS(SVG_NAMESPACE, 'circle');
  this._circle.setAttribute('cx', '10');
  this._circle.setAttribute('cy', '10');
  this._circle.setAttribute('r', '5');
  this._circle.setAttribute('fill', 'none');
  this._circle.setAttribute('stroke', '#dfe0e6');
  this._circle.setAttribute('stroke-width', '10');
  this._circle.setAttribute('stroke-dasharray', '0 31.4159 31.4159 0');
  this._circle.setAttribute('stroke-dashoffset', '0');
  this._circle.setAttribute('transform', 'rotate(-90 10 10)');

  this._svg.appendChild(this._circle);
  this._container.appendChild(this._svg);
};

/**
 * Draw the current state of the animation.
 *
 * @private
 */

CountDownAnimation.prototype._draw = function () {
  var offset = Math.max(this._remaining, 0) * Math.PI * 10;
  this._circle.setAttribute('stroke-dashoffset', offset);
};

/**
 * Start animating the count down timer.
 *
 * @private
 */

CountDownAnimation.prototype._animate = function () {
  var elapsed = new Date().getTime() - this._started;
  this._remaining = 1 - elapsed / this._duration;
  this._draw();
  if (this._remaining > 0) {
    requestAnimationFrame(this._animate);
  }
};

module.exports = CountDownAnimation;

},{}],210:[function(require,module,exports){
'use strict';

var eventDispatcher = require('../../spotify-event-dispatcher');
var CosmosConnector = require('./cosmos-connector');
var cosmosConnector = new CosmosConnector();
var debug = require('debug');
var debugLog = debug('saf:debug');

// Setup debug logging so that formatted objects will show up
// in the TA console log retrieved via the Selenium API.
if (localStorage && localStorage.getItem('ads.debug.setupTA')) {
  debug.useColors = function () {
    return false;
  };
  debug.formatters.o = JSON.stringify;
  subToFormats();
}

var eventTypes = require('./event-types');

var BillboardAd = require('./formats/billboard-ad');

/**
 * Overrides default cosmos connector instance
 *
 * @param {CosmosConnector} newCosmosConnectorInstance new instance
 */

function setCosmosConnector(newCosmosConnectorInstance) {
  cosmosConnector = newCosmosConnectorInstance;
}

/**
 * Overrides a targeting attribute for debugging purpose
 *
 * E.g.
 *   patchTargeting('aduserid', 1111);
 *
 * @api protected
 * @param {String} key targeting key.
 * @param {String} value targeting value.
 */

function patchTargeting(key, value) {
  return cosmosConnector.patchTargeting(key, value);
}

/**
 * Override an aduserid (ppid) for ads targeting and frequency capping
 */
function setAdUserId(value) {
  return patchTargeting('aduserid', value);
}

/**
 * Refreshes all active leaderboards
 */

function refreshLeaderboard() {
  eventDispatcher.dispatchEvent({
    'type': eventTypes.DEBUG_FORCE_REFRESH_LEADERBOARD,
    'params': {},
    'extra': {}
  });
}

/**
 * Refreshes all active hpto
 */

function refreshHPTO() {
  eventDispatcher.dispatchEvent({
    'type': eventTypes.DEBUG_FORCE_REFRESH_HPTO,
    'params': {},
    'extra': {}
  });
}

/**
 * Sets timeout for billboard
 */

function setBillboardTimeout(seconds) {
  eventDispatcher.dispatchEvent({
    'type': eventTypes.DEBUG_SET_BILLBOARD_TIMEOUT,
    'params': {
      timeout: seconds * 1000
    },
    'extra': {}
  });
}

/**
 * Sets timeout for billboard
 */

function triggerBillboard() {
  eventDispatcher.dispatchEvent({
    'type': eventTypes.DEBUG_FORCE_REFRESH_BILLBOARD,
    'params': {},
    'extra': {}
  });
}

/**
 * Increases user stream time
 */

function increaseStreamTime(seconds) {
  return cosmosConnector.increaseStreamTime(seconds);
}

/**
 * Retreive the ad server endpoint from core
 *
 * @param {string} slot The ad slot to get endpoint for
 * @return {Promise}
 */

function getAdServerEndpoint(slot) {
  return new Promise(function (resolve, reject) {
    var key = 'ad_server_endpoint';

    cosmosConnector.getSlotConfigurations(slot).then(function (res) {
      if (res.getStatusCode() === 200) {
        var endpoint = res.getJSONBody().settings[0][key];
        resolve(endpoint);
      } else {
        reject('Unable to get slot settings for slot ' + slot);
      }
    });
  });
}

/**
 * Tell core to request ads from ad mocker and not from DFP for a given ad slot.
 *
 * Endpoint should look like "http://foo.bar.net?foo=baz"
 *
 * @api public
 * @param {string} slot The ad slot to use ad mocker for.
 * @param {string} endpoint The endpoint to fetch ads from for the given slot.
 * @return {Promise}
 */

function overrideAdServerEndpoint(slot, endpoint) {
  return new Promise(function (resolve, reject) {
    var key = 'ad_server_endpoint';

    cosmosConnector.configureSlot(slot, key, endpoint).then(function (res) {
      if (res.getStatusCode() === 200) {
        resolve();
      } else {
        reject('Unable to set slot settings for slot ' + slot);
      }
    });
  });
}

/**
 * Tell core to request ads from ad mocker and not from DFP for a given ad slot.
 *
 * Endpoint should look like "http://foo.bar.net"
 *
 * @api public
 * @param {string} slot The ad slot to use ad mocker for.
 * @param {string} endpoint The endpoint to fetch ads from for the given slot.
 * @param {string} sessionId The test automation session id.
 * @return {Promise}
 */

function setAdServerEndpoint(slot, endpoint, sessionId) {
  return new Promise(function (resolve, reject) {
    var key = 'ad_server_endpoint';

    cosmosConnector.getSlotConfigurations(slot).then(function (resp) {
      if (resp.getStatusCode() === 200) {
        var updated = resp.getJSONBody().settings[0][key].replace('https://pubads.g.doubleclick.net', endpoint);
        updated += '&session_id=' + sessionId;

        cosmosConnector.configureSlot(slot, key, updated).then(function (res) {
          if (res.getStatusCode() === 200) {
            resolve();
          } else {
            reject('Unable to set slot settings for slot ' + slot);
          }
        });
      } else {
        reject('Unable to set slot settings for slot ' + slot);
      }
    });
  });
}

function getAdSlotConfigurations(slot, cb) {
  cosmosConnector.getSlotConfigurations(slot).then(function (res) {
    if (res.getStatusCode() === 200) {
      (cb || function (body) {
        debugLog('config for slot=%o, res=%o', slot, res);
      })(res.getJSONBody());
    } else {
      throw new Error("bad status code from slot config: " + resp.getStatusCode());
    }
  });
}

/**
 * Get the spotify ad format version
 *
 * @return {String}
 */

function getVersion() {
  return require('../package.json').version;
}

/**
 * Clear an ad slot in core
 *
 * @param {String} slot The name of the slot to clear.
 * @return {Promise}
 */

function clearSlot(slot) {
  return cosmosConnector.postToSlot(slot, {
    intent: 'clear'
  });
}

function configureSlot(slot, k, v) {
  return cosmosConnector.configureSlot(slot, k, v);
}

function subToState(cb) {
  return cosmosConnector.subToState(function (res) {
    if (cb) {
      cb(res);
    } else {
      debugLog('ads state updated: %o', res.state);
    }
  });
}

function subToFormats(cb) {
  return cosmosConnector.subscribeToAllFormats(function (fmt, ev) {
    (cb || function () {
      debugLog('event for format %o: %o', fmt, ev);
    })(fmt, ev);
  });
}

function getState(cb) {
  return cosmosConnector.getState().then(function (res) {
    if (cb) {
      cb(res);
    } else {
      debugLog('ads state: %o', res.state);
    }
  });
}

function setAdLeaderboardHtml(html) {
  eventDispatcher.dispatchEvent({
    'type': eventTypes.DEBUG_OVERRIDE_AD_LEADERBOARD_HTML,
    'params': {
      html: html
    },
    'extra': {}
  });
}

var receivedAdLeaderboardHtml = '';
eventDispatcher.addEventListener(eventTypes.DEBUG_RECEIVED_AD_LEADERBOARD_HTML, function (e) {
  receivedAdLeaderboardHtml = e.params.html;
});

function getReceivedAdLeaderboardHtml() {
  return receivedAdLeaderboardHtml;
}

module.exports = {
  setCosmosConnector: setCosmosConnector,
  patchTargeting: patchTargeting,
  refreshLeaderboard: refreshLeaderboard,
  refreshHPTO: refreshHPTO,
  setBillboardTimeout: setBillboardTimeout,
  triggerBillboard: triggerBillboard,
  increaseStreamTime: increaseStreamTime,
  getAdServerEndpoint: getAdServerEndpoint,
  overrideAdServerEndpoint: overrideAdServerEndpoint,
  setAdServerEndpoint: setAdServerEndpoint,
  getVersion: getVersion,
  clearSlot: clearSlot,
  subToState: subToState,
  subToFormats: subToFormats,
  getState: getState,
  configureSlot: configureSlot,
  debug: debug,
  BillboardAd: BillboardAd,
  setAdUserId: setAdUserId,
  setAdLeaderboardHtml: setAdLeaderboardHtml,
  getReceivedAdLeaderboardHtml: getReceivedAdLeaderboardHtml,
  getAdSlotConfigurations: getAdSlotConfigurations
};

},{"../../spotify-event-dispatcher":264,"../package.json":204,"./cosmos-connector":208,"./event-types":214,"./formats/billboard-ad":217,"debug":526}],211:[function(require,module,exports){
'use strict';

var utils = require('../utils');

/**
 * DFP Request Network ID
 */

var NETWORK_ID = 6465052;

var TEMPLATES = {
  gpt: require('./templates/gpt.hbs')
};

/*
 * Returns template based on name
 *
 * @param {String} name
 * @return {hbs}
 */
function template(name) {
  return TEMPLATES[name];
}

/**
 * Create dfp inventory unit from device/product data
 * @param {String} platform
 * @param {Boolean} isPremium
 * @return {String} inventory unit
 */
function inventoryUnit(platform, isPremium) {
  var unit = isPremium ? 'premium-' + platform : platform;

  return '/' + NETWORK_ID + '/' + unit;
}

function parseHptoHtml(iframeDoc) {
  var tplSpans = iframeDoc.body.getElementsByTagName('span');
  var jsonContent = null;
  var html = '';
  var templateName;

  for (var i = 0, len = tplSpans.length; i < len; i++) {
    templateName = tplSpans[i].getAttribute('data-template');

    if (templateName === 'hpto-json') {
      try {
        jsonContent = JSON.parse(tplSpans[i].innerHTML);
      } catch (e) {
        return null;
      }
    } else if (templateName === 'hpto-html') {
      html = tplSpans[i].innerHTML;
    }
  }

  if (!jsonContent) {
    return null;
  }

  jsonContent.hpto.html = html;

  return jsonContent;
}

/**
 * @param {Object} data
 * @param {String} data.inventoryType
 * @param {String} data.width
 * @param {String} data.height
 * @param {String} data.inventoryUnit
 * @param {String} data.targetingData
 * @param {String} data.ppid
 * @return {String} compiled html
 */
function renderGPT(data) {
  var dfpSlotId = data.inventoryType + '-' + new Date().getTime();
  return TEMPLATES.gpt({
    slotId: dfpSlotId,
    width: data.width,
    height: data.height,
    inventoryUnit: data.inventoryUnit,
    targetingParameters: data.targetingData,
    ppid: data.ppid
  });
}

function fetchHptoAd(domEl, targetingData) {
  return new Promise(function (resolve, reject) {
    var iframe = utils.createSandboxedIframe();
    iframe.style.display = 'none';

    domEl.appendChild(iframe);

    var iframeDoc = iframe.contentDocument;

    iframeDoc.open();
    iframeDoc.write(renderGPT(targetingData));
    iframeDoc.close();

    iframeDoc.addEventListener('placementReady', function () {
      var hptoData = parseHptoHtml(iframeDoc);
      iframe.parentNode.removeChild(iframe);
      resolve(hptoData);
    });

    iframeDoc.addEventListener('eventEmpty', function () {
      reject(new Error('[HPTO dfp] Returned empty event'));
    });
  });
}

module.exports = {
  NETWORK_ID: NETWORK_ID,
  template: template,
  inventoryUnit: inventoryUnit,
  renderGPT: renderGPT,
  parseHptoHtml: parseHptoHtml,
  fetchHptoAd: fetchHptoAd
};

},{"../utils":249,"./templates/gpt.hbs":212}],212:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, functionType="function", escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {

  var buffer = "", stack1;
  buffer += "\n          .setTargeting(\"";
  stack1 = ((stack1 = (data == null || data === false ? data : data.key)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\",\"";
  stack1 = (typeof depth0 === functionType ? depth0.apply(depth0) : depth0);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\")\n        ";
  return buffer;
  }

function program3(depth0,data) {

  var buffer = "", stack1;
  buffer += "\n              '";
  stack1 = ((stack1 = (data == null || data === false ? data : data.key)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "': '";
  stack1 = (typeof depth0 === functionType ? depth0.apply(depth0) : depth0);
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "',\n              ";
  return buffer;
  }

  buffer += "<html>\n  <head>\n    <script type=\"text/javascript\">\n      var googletag = googletag || {};\n      googletag.cmd = googletag.cmd || [];\n\n      (function() {\n        var useSSL = true;\n        var src = (useSSL ? 'https:' : 'http:') +\n                  '//www.googletagservices.com/tag/js/gpt.js';\n        document.write('<scr' + 'ipt src=\"' + src + '\"></scr' + 'ipt>');\n      })();\n\n      googletag.cmd.push(function() {\n        googletag.defineSlot('";
  if (helper = helpers.inventoryUnit) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.inventoryUnit); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "', [[";
  if (helper = helpers.width) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.width); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + ", ";
  if (helper = helpers.height) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.height); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "]],\n          '";
  if (helper = helpers.slotId) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.slotId); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "')\n          .addService(googletag.pubads().setPublisherProvidedId('";
  if (helper = helpers.ppid) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.ppid); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "'))\n\n        ";
  stack1 = helpers.each.call(depth0, (depth0 && depth0.targetingParameters), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += ";\n\n        googletag.pubads().addEventListener(\"slotRenderEnded\", function(event) {\n          var msg = event.isEmpty ? \"eventEmpty\" : \"placementReady\";\n\n          // Attach data to the window for parent impression logging\n          window.slotRenderEndedObj = {\n            creativeId: event.creativeId,\n            lineItemId: event.lineItemId,\n            slot: '";
  if (helper = helpers.slotId) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.slotId); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "',\n            targetingParams: {\n              ";
  stack1 = helpers.each.call(depth0, (depth0 && depth0.targetingParameters), {hash:{},inverse:self.noop,fn:self.program(3, program3, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n            }\n          };\n\n          var e = new CustomEvent(msg);\n          document.dispatchEvent(e);\n        });\n\n        googletag.pubads().set(\"page_url\", \"http://www.spotify.com\");\n\n        googletag.pubads().enableSingleRequest();\n        googletag.pubads().enableSyncRendering();\n        googletag.enableServices();\n      });\n    </script>\n  </head>\n  <body style=\"margin:0px\">\n    <div id=\"";
  if (helper = helpers.slotId) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.slotId); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" style=\"width: ";
  if (helper = helpers.width) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.width); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "px; height: ";
  if (helper = helpers.height) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.height); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "px\">\n      <script type=\"text/javascript\">\n        googletag.cmd.push(function() { googletag.display(\"";
  if (helper = helpers.slotId) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.slotId); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"); });\n      </script>\n    </div>\n  </body>\n</html>\n";
  return buffer;
  });

},{"hbsfy/runtime":563}],213:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.EventLogger = undefined;
exports.factory = factory;

var _debug2 = require('debug');

var _debug3 = _interopRequireDefault(_debug2);

var _cosmosConnector = require('./cosmos-connector');

var _cosmosConnector2 = _interopRequireDefault(_cosmosConnector);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function factory(_ref) {
  var cosmosConnector = _ref.cosmosConnector;
  var debug = _ref.debug;
  var Promise = _ref.Promise;

  function EventLogger(adId) {
    if (!adId) throw new Error('adId is required');

    var promise = Promise.resolve();

    this.logEvent = function (eventName, payload) {
      promise = promise.catch(function () {}).then(function () {
        return cosmosConnector.postEvent(adId, eventName, payload);
      }).then(function () {
        debug(adId, eventName, payload);
        return true;
      }).catch(function (err) {
        debug(adId, eventName, payload, err);
        throw err;
      });

      return promise;
    };
  }

  return EventLogger;
}

var EventLogger = exports.EventLogger = factory({
  cosmosConnector: new _cosmosConnector2.default(),
  debug: (0, _debug3.default)('saf:event-logger'),
  Promise: Promise
});

},{"./cosmos-connector":208,"debug":526}],214:[function(require,module,exports){
'use strict';

module.exports = {
  AD_AUDIO_STARTED: 'ad:audio:started',
  AD_AUDIO_FINISHED: 'ad:audio:finished',

  AD_VIDEO_STARTED: 'ad:video:started',
  AD_VIDEO_FINISHED: 'ad:video:finished',

  AD_BILLBOARD_STARTED: 'ad:billboard:started',
  AD_BILLBOARD_HIDDEN: 'ad:billboard:hidden',
  AD_BILLBOARD_VISIBLE: 'ad:billboard:visible',
  AD_BILLBOARD_FOCUS_RECEIVED: 'ad:billboard:focusreceived',
  AD_BILLBOARD_DISCARDED: 'ad:billboard:discarded',
  AD_BILLBOARD_FINISHED: 'ad:billboard:finished',
  AD_BILLBOARD_MINIMIZED: 'ad:billboard:minimized',

  AD_CLICK_VIDEO_STARTED: 'ad:clickvideo:started',
  AD_CLICK_VIDEO_ENDED: 'ad:clickvideo:ended',

  AD_HPTO_HIDDEN: 'ad:hpto:hidden',
  AD_HPTO_RENDERED: 'ad:hpto:rendered',

  AD_LEADERBOARD_ERROR: 'ad:leaderboard:error',
  AD_LEADERBOARD_PLACEMENT: 'ad:leaderboard:placement',
  AD_LEADERBOARD_USED_DEFAULT: 'ad:leaderboard:used:default',

  AD_PLAYER_STATE_EVENT: 'ad:player:event',

  AD_SPONSORSHIP_ACTIVE: 'ad:sponsorship:active',

  PLAYER_PAUSE: 'pause',
  PLAYER_RESUME: 'resume',

  NAVIGATION_OPEN_URI: 'open_uri',
  NAVIGATION_HISTORY_CHANGE: 'historychange',
  NAVIGATION_STATE_CHANGE: 'statechange',
  NAVIGATION_UPGRADE: 'upgrade_premium',

  UI_VISIBILITY: 'visibilitystatechanged', // Deprecated

  APPLICATION_FOCUS_LOST: 'application:focus:lost',
  APPLICATION_FOCUS_GAINED: 'application:focus:gained',

  DEBUG_FORCE_REFRESH_LEADERBOARD: 'debug:ad:force_refresh:leaderboard',
  DEBUG_FORCE_REFRESH_HPTO: 'debug:ad:force_refresh:hpto',
  DEBUG_SET_BILLBOARD_TIMEOUT: 'debug:ad:set:billboard_timeout',
  DEBUG_FORCE_REFRESH_BILLBOARD: 'debug:ad:force_refresh:billboard',
  DEBUG_OVERRIDE_AD_LEADERBOARD_HTML: 'debug:ad:override:leaderboard:html',
  DEBUG_RECEIVED_AD_LEADERBOARD_HTML: 'debug:received:ad:leaderboard:html'
};

},{}],215:[function(require,module,exports){
'use strict';

/**
 * Returns a key/value mapping of external tag url
 *
 * @api public
 * @returns {Object}
 */

module.exports = {
  comscore: 'http://b.scorecardresearch.com/p?c1=2&c2=15654041' + '&c7=http%3A%2F%2Fwww.spotify-desktop.com&cv=2.0&cj=1'
};

},{}],216:[function(require,module,exports){
'use strict';

var CosmosConnector = require('../cosmos-connector');
var EventEmitter = require('events').EventEmitter;

var cosmosConnector = new CosmosConnector();
var emitter = new EventEmitter();

// EVENTS
var ENABLED = 'ENABLED';
var DISABLED = 'DISABLED';
var ACTIVE = 'ACTIVE';
var INACTIVE = 'INACTIVE';

var adId = null;
var element = null;
var isActive = false;
var isEnabled = false;
var isInitialized = false;

/**
 * @module AudioCompanionAd
 */
var AudioCompanionAd = {};

/**
 * @param {Object} opts
 * @param {HTMLElement} opts.element
 * @return {AudioCompanionAd}
 */
AudioCompanionAd.init = function (opts) {
  if (isInitialized) throwErrorMsg('already initialized');
  element = opts && opts.element;
  isInitialized = true;
  return AudioCompanionAd;
};

/**
 * @param {String} id
 * @return {AudioCompanionAd}
 */
AudioCompanionAd.setAdId = function (id) {
  adId = id;
  return AudioCompanionAd;
};

/**
 * @return {AudioCompanionAd}
 */
AudioCompanionAd.enable = function () {
  if (!isEnabled) {
    element.addEventListener('click', onCompanionClick);
    emitter.emit(ENABLED);
  }

  return AudioCompanionAd;
};

/**
 * @return {AudioCompanionAd}
 */
AudioCompanionAd.disable = function () {
  if (isEnabled) {
    element.removeEventListener('click', onCompanionClick);
    emitter.emit(DISABLED);
  }

  return AudioCompanionAd;
};

/**
 * @return {AudioCompanionAd}
 */
AudioCompanionAd.on = function (eventName, callback) {
  emitter.on(eventName, callback);
  return AudioCompanionAd;
};

/**
 * @param {String} eventName
 * @return {AudioCompanionAd}
 */
AudioCompanionAd.off = function (eventName, callback) {
  emitter.removeListener(eventName, callback);
  return AudioCompanionAd;
};

/**
 * @return {Boolean} isEnabled
 */
AudioCompanionAd.isEnabled = function () {
  return isEnabled;
};

/**
 * @return {Boolean} isActive
 */
AudioCompanionAd.isActive = function () {
  return isActive;
};

AudioCompanionAd.EVENTS = {
  ENABLED: ENABLED,
  DISABLED: DISABLED,
  ACTIVE: ACTIVE,
  INACTIVE: INACTIVE
};

emitter.on(ENABLED, function () {
  isEnabled = true;
  emitter.emit(ACTIVE);
});

emitter.on(DISABLED, function () {
  isEnabled = false;
  emitter.emit(INACTIVE);
});

emitter.on(ACTIVE, function () {
  isActive = true;
});

emitter.on(INACTIVE, function () {
  isActive = false;
});

function throwErrorMsg(errMsg) {
  throw new Error('AudioCompanionAd: ' + errMsg);
}

function postEvent(eventName) {
  if (!adId) throwErrorMsg('adId not set');
  cosmosConnector.postEvent(adId, eventName).catch(function (err) {
    console.error(err);
  });
}

function onCompanionClick(e) {
  e.preventDefault();
  postEvent('clicked');
}

module.exports = AudioCompanionAd;

},{"../cosmos-connector":208,"events":531}],217:[function(require,module,exports){
'use strict';

var EventEmitter = require('events').EventEmitter;
var emitter = new EventEmitter();
var debug = require('debug')('saf:billboard-ad');

var abba = require('../../../../spotify-abba-mini');
var URI = require('spotify-liburi');
var eventDispatcher = require('../../../../spotify-event-dispatcher');
var events = require('../../event-types');

var CosmosConnector = require('../../cosmos-connector');
var cosmosConnector = new CosmosConnector();

var AudioCompanionAd = require('../audio-companion-ad');
var BillboardAdView = require('./view');
var FORMAT_EVENTS = require('../format-events');

var PREVIEW_SLOT_ID = 'preview';
var SLOT_ID = 'billboard';
var INVENTORY_TYPE = 'video';
var SLOT_URI = 'sp://ads/v1/adslots/' + SLOT_ID;

var BLACKLISTED_URIS = ['ad', 'browse', 'charts', 'discover', 'hub'];

var MINUTES_MS = 1000 * 60;
var DEFAULT_FOCUS_TIMEOUT_MS = 3 * MINUTES_MS;

var overrideTimeoutMs = null;
var view = null;
var timerSetupView = null;
var timerFetchRetry = null;
var pageIsBlackListed = false;

var clientState = {
  audioAdIsPlaying: false,
  videoAdIsPlaying: false,
  isActive: true,
  hasFocus: true
};

var containerEl = null;
var isInitialized = false;
var isActive = false;
var isEnabled = false;
var videoEnabled = false;

/**
 * @module BillboardAd
 */
var BillboardAd = {};
BillboardAd.EVENTS = FORMAT_EVENTS;

/**
 * @param {Object} opts
 * @param {HTMLElement} opts.element
 * @return {BillboardAd}
 */
BillboardAd.init = function (opts) {
  if (!isInitialized) {
    containerEl = opts && opts.element;
    isInitialized = true;
  }
  return BillboardAd;
};

/**
 * @return {BillboardAd}
 */
BillboardAd.enable = function () {
  if (!isInitialized) throw new Error('Not initialized yet');

  if (!isEnabled) {
    addListeners();

    cosmosConnector.subscribeToSlot(SLOT_URI, onCoreMessage);

    emitter.emit(BillboardAd.EVENTS.ENABLED);
    debug('enabled');
  }

  return BillboardAd;
};

/**
 * Disable the billboard component inside the container.
 * @return {BillboardAd}
 */
BillboardAd.disable = function () {
  if (isEnabled) {
    removeListeners();
    finish();

    emitter.emit(BillboardAd.EVENTS.DISABLED);
    debug('disabled');
  }

  return BillboardAd;
};

/**
 * @param  {String} eventName
 * @param  {Function} callback
 * @return {BillboardAd}
 */
BillboardAd.on = function (eventName, callback) {
  emitter.on(eventName, callback);
  return BillboardAd;
};

/**
 * @param  {String} eventName
 * @param  {Function} callback
 * @return {BillboardAd}
 */
BillboardAd.off = function (eventName, callback) {
  emitter.removeListener(eventName, callback);
  return BillboardAd;
};

/**
 * @return {Boolean} isEnabled
 */
BillboardAd.pageIsBlackListed = function () {
  return pageIsBlackListed;
};

/**
 * @return {Boolean} isEnabled
 */
BillboardAd.isEnabled = function () {
  return isEnabled;
};

/**
 * @return {Boolean} isEnabled
 */
BillboardAd.isActive = function () {
  return isActive;
};

/**
 * @private For testing only
 * @param {EventEmitter} _emitter
 * @return {void}
 */
BillboardAd._setEmitter = function (_emitter) {
  emitter = _emitter;
};

// TODO move responsibility to activitytracker
BillboardAd.setApplicationInactive = function () {
  clearTimeout(timerSetupView);

  if (view && view.activated) {
    return;
  }

  fetchFromDFPWhenPossible();

  clientState.isActive = false;
};

function getFocusTimeoutMs() {
  if (overrideTimeoutMs) {
    debug('use overrideTimeoutMs: %o', overrideTimeoutMs);
    return Promise.resolve(overrideTimeoutMs);
  }
  return cosmosConnector.getSlotConfiguration(SLOT_ID, 'display_time_interval').then(function (triggerAfterFocusLostS) {
    if (triggerAfterFocusLostS && triggerAfterFocusLostS > 0) {
      debug('using billboard slot config focus time (seconds): %o', triggerAfterFocusLostS);
      return triggerAfterFocusLostS * 1000;
    }
    throw new Error("triggerAfterFocusLostS is not a positive integer: " + triggerAfterFocusLostS);
  }).catch(function (err) {
    debug('error getting display time interval: %o', err);
    return DEFAULT_FOCUS_TIMEOUT_MS;
  });
}
BillboardAd.getFocusTimeoutMs = getFocusTimeoutMs;

emitter.on(BillboardAd.EVENTS.ENABLED, function () {
  isEnabled = true;
});

emitter.on(BillboardAd.EVENTS.DISABLED, function () {
  isEnabled = false;
});

emitter.on(BillboardAd.EVENTS.ACTIVE, function () {
  isActive = true;
});

emitter.on(BillboardAd.EVENTS.INACTIVE, function () {
  isActive = false;
});

/**
 * Initialize format with listeners / subscriptions
 * @return {Promise}
 */
function addListeners() {
  BillboardAdView.on('INACTIVE', function () {
    emitter.emit(BillboardAd.EVENTS.INACTIVE);
    debug('inactive');
  });

  AudioCompanionAd.on(AudioCompanionAd.EVENTS.ACTIVE, onAudioAdChange.bind(null, true));

  AudioCompanionAd.on(AudioCompanionAd.EVENTS.INACTIVE, onAudioAdChange.bind(null, false));

  eventDispatcher.addEventListener(events.AD_VIDEO_STARTED, onVideoAdChange.bind(null, true));

  eventDispatcher.addEventListener(events.AD_VIDEO_FINISHED, onVideoAdChange.bind(null, false));

  eventDispatcher.addEventListener(events.AD_BILLBOARD_FINISHED, onBillboardAdFinished);

  eventDispatcher.addEventListener(events.AD_BILLBOARD_FOCUS_RECEIVED, onBillboardAdFocused);

  eventDispatcher.addEventListener(events.DEBUG_SET_BILLBOARD_TIMEOUT, onBillboardSetOverrideTimeout);

  eventDispatcher.addEventListener(events.DEBUG_FORCE_REFRESH_BILLBOARD, fetchFromDFP);

  eventDispatcher.addEventListener(events.APPLICATION_FOCUS_LOST, onApplicationFocusLost);

  eventDispatcher.addEventListener(events.APPLICATION_FOCUS_GAINED, onApplicationFocusGained);

  eventDispatcher.addEventListener(events.NAVIGATION_STATE_CHANGE, onNavigationStateChanged);

  BillboardAd._abbaVideoFlag().then(function (isEnabled) {
    debug('abbaCheck: videoEnabled=%o', isEnabled);
    videoEnabled = isEnabled;
  });

  cosmosConnector.subscribeToSlotType(PREVIEW_SLOT_ID, function (data) {
    if (!data.ad.companion_ad) {
      return; // Preview for a leaderboard, just ignore
    }
    switch (data.event) {
      case 'available':
        cosmosConnector.postToSlot(PREVIEW_SLOT_ID, {
          intent: 'now' // This will trigger a "play" event
        });
        break;
      case 'play':
        debug('play: data=%o', data);
        BillboardAd._render(data);
        emitter.emit(BillboardAd.EVENTS.ACTIVE);
        break;
      default:
        throw new Error('Unknown core event from preview slot: ' + data.event);
    }
  });

  cosmosConnector.addNewSlot(SLOT_ID, INVENTORY_TYPE);

  return;
}

BillboardAd._abbaVideoFlag = function () {
  return new Promise(function (resolve) {
    abba('ad_video_billboard', function (err, cell) {
      resolve(cell === 'Enabled');
    });
  });
};

/**
 * @return {void}
 */
function removeListeners() {
  AudioCompanionAd.off(AudioCompanionAd.EVENTS.ACTIVE, onAudioAdChange.bind(null, true));

  AudioCompanionAd.off(AudioCompanionAd.EVENTS.INACTIVE, onAudioAdChange.bind(null, false));

  eventDispatcher.removeEventListener(events.AD_VIDEO_STARTED, onVideoAdChange.bind(null, true));

  eventDispatcher.removeEventListener(events.AD_VIDEO_FINISHED, onVideoAdChange.bind(null, false));

  eventDispatcher.removeEventListener(events.AD_BILLBOARD_FINISHED, onBillboardAdFinished);

  eventDispatcher.removeEventListener(events.AD_BILLBOARD_FOCUS_RECEIVED, onBillboardAdFocused);

  eventDispatcher.removeEventListener(events.DEBUG_SET_BILLBOARD_TIMEOUT, onBillboardSetOverrideTimeout);

  eventDispatcher.removeEventListener(events.DEBUG_FORCE_REFRESH_BILLBOARD, fetchFromDFP);

  eventDispatcher.removeEventListener(events.APPLICATION_FOCUS_LOST, onApplicationFocusLost);

  eventDispatcher.removeEventListener(events.APPLICATION_FOCUS_GAINED, onApplicationFocusGained);

  eventDispatcher.removeEventListener(events.NAVIGATION_STATE_CHANGE, onNavigationStateChanged);
};

/**
 * Callback for ad slot messages from ads core.
 * @private
 * @param  {data} data Event data.
 * @return {void}
 */
function onCoreMessage(data) {
  switch (data.event) {
    case 'available':
      debug('available & active', data);
      onAvailable(data);
      break;
    case 'play':
      debug('play: data=%o', data);
      onPlay(data);
      break;
    case 'discard':
      debug('discard: data=%o', data);
      onDiscard();
      break;
    default:
      throw '[Billboard] Unsupported event type: ' + data.event;
  }
}

function onAvailable(data) {
  var canRender = canShow() && (!clientState.hasFocus || !clientState.isActive);

  // TODO abba flag - remove after 100% rollout
  if (data.format === 'video' && !videoEnabled) {
    clearSlot().then(function () {
      setTimeout(fetchFromDFP, 10000);
    });
  } else if (canRender) {
    BillboardAd._render(data);
    emitter.emit(BillboardAd.EVENTS.ACTIVE);
    debug('active');
  } else {
    clearSlot();
  }
};

function onPlay() {
  view.play();
};

/**
 * Handles discard message from core
 * This happens on two occasions:
 *  1) When we fire an intent 'clear' message
 *  2) When click url expires, core sends a discard message
 * @private
 * @return {void}
 */
function onDiscard() {
  if (view) {
    var requestNewAd = !view.activated;

    view.destroy().then(function () {
      // Refetch because click url expired
      if (requestNewAd) {
        setTimeout(fetchFromDFP, 10000);
      }
    });

    view = null;
  }
}

/**
 * Render an ad retrieved from core
 * @param  {Object} ad The ad from core
 * @return {void}
 */
BillboardAd._render = function (data) {
  view = new BillboardAdView(containerEl, data);
  view.setup();
};

/**
 * Tell core to fetch a new ad from DFP
 * @private
 * @return {void}
 */
function fetchFromDFP() {
  debug('fetchFromDFP');
  cosmosConnector.postToSlot(SLOT_ID, { intent: 'fetch' }).catch(logError);
}

/**
 * Fetch a new billboard ad from DFP whenever one is allowed to show.
 * @private
 * @return {void}
 */
function fetchFromDFPWhenPossible() {
  clearTimeout(timerFetchRetry);
  if (canShow()) {
    fetchFromDFP();
  } else {
    debug('cannot show, retrying in 5s');
    timerFetchRetry = setTimeout(function () {
      fetchFromDFPWhenPossible();
    }, 5000);
  }
}

/* --------------- *
 * Event callbacks *
 * --------------- */

/**
 * Callback for when the navigation history has changed
 * (when user visits a new page in the client)
 * @param {Event} e - dispatcher event.
 */
function onNavigationStateChanged(e) {
  var uri = URI.from(e.params.uri);
  if (uri && BLACKLISTED_URIS.indexOf(uri.id) > -1) {
    pageIsBlackListed = true;
    finish();
  } else {
    pageIsBlackListed = false;
    minimize();
  }
}

/**
 * Callback for when the app has received focus
 */
function onApplicationFocusGained() {
  clientState.hasFocus = true;
  clearTimeout(timerFetchRetry);
  clearTimeout(timerSetupView);
  if (view) {
    if (canShow()) {
      view.onFocusReceived();
    } else {
      finish();
    }
  }
}

/**
 * Callback for when the app has lost focus.
 */
function onApplicationFocusLost() {
  debug('applicationFocusLost');
  if (view && view.activated) {
    debug('view already active');
    return;
  }

  clientState.hasFocus = false;
  clearTimeout(timerSetupView);
  getFocusTimeoutMs().then(function (timeoutMs) {
    debug('set fetch timeout (ms): %o', timeoutMs);
    timerSetupView = setTimeout(fetchFromDFPWhenPossible, timeoutMs);
  });
}

/**
 * @param  {Boolean} isPlaying
 * @return {void}
 */
function onAudioAdChange(isPlaying) {
  clientState.audioAdIsPlaying = isPlaying;
  updateOnClientChange();
}

/**
 * @param  {Boolean} isPlaying
 * @return {void}
 */
function onVideoAdChange(isPlaying) {
  clientState.videoAdIsPlaying = isPlaying;
  updateOnClientChange();
}

function updateOnClientChange() {
  if (!view) return; // No need to do anything

  if (canShow()) {
    // Ad break ended
    view.fadeIn();
  } else {
    // Ad break started
    if (view.isUserMaximized()) {
      finish(); // Prevent it from flashing between ads in an ad break
    } else {
        view.fadeOut();
      }
  }
}

/**
 * Set new timeout from devtools
 * @param  {Event} e - dispatcher event
 * @return {void}
 */
function onBillboardSetOverrideTimeout(e) {
  overrideTimeoutMs = e.params.timeout;
};

/**
 * Callback for when the billboard ad view has received focus.
 * @param {Event} e The event triggered.
 */
function onBillboardAdFocused() {
  clientState.isActive = true;
}

/**
 * Callback for when billboard is finished
 */
function onBillboardAdFinished() {
  view = null;
}

/* ---------------- *
 * Helper functions *
 * ---------------- */

function logError(err) {
  debug(err.message);
}

function clearSlot() {
  return cosmosConnector.postToSlot(SLOT_ID, { intent: 'clear' }).catch(logError);
};

function finish() {
  if (view) {
    view.finish();
  }
}

function minimize() {
  if (view) {
    view.minimize();
  }
}

function canShow() {
  return !clientState.audioAdIsPlaying && !clientState.videoAdIsPlaying && !pageIsBlackListed;
}

module.exports = BillboardAd;

},{"../../../../spotify-abba-mini":181,"../../../../spotify-event-dispatcher":264,"../../cosmos-connector":208,"../../event-types":214,"../audio-companion-ad":216,"../format-events":221,"./view":220,"debug":526,"events":531,"spotify-liburi":707}],218:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, functionType="function", escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {


  return "\n    <video autoplay muted loop></video>\n  ";
  }

function program3(depth0,data) {

  var buffer = "", stack1, helper;
  buffer += "\n    <img src=\"";
  if (helper = helpers.mediaSrc) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.mediaSrc); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"/>\n  ";
  return buffer;
  }

  buffer += "<div class=\"countdown\"></div>\n<button class=\"minimizer spoticon-x-24\"></button>\n<div class=\"footer\">\n  <a class=\"maximizer spoticon-chevron-up-16\"></a>\n  <a class=\"companion\" href=\"";
  if (helper = helpers.clickUrl) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.clickUrl); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\">\n    <img src=\"";
  if (helper = helpers.companionSrc) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.companionSrc); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" />\n  </a>\n</div>\n<a class=\"billboard\" href=\"";
  if (helper = helpers.clickUrl) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.clickUrl); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\">\n  <span class=\"disclaimer\">";
  if (helper = helpers.disclaimer) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.disclaimer); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</span>\n  ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.isVideo), {hash:{},inverse:self.program(3, program3, data),fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n</a>\n";
  return buffer;
  });

},{"hbsfy/runtime":563}],219:[function(require,module,exports){
'use strict';

var SPVideoManager = require('../../../../spotify-video-manager');
var EventLogger = require('../../event-logger').EventLogger;
var VastEvents = require('../../vast-events');
var BillboardAdVideo = {};

BillboardAdVideo.create = function (opts) {
  var _logEvent = new EventLogger(opts.adId).logEvent;
  var videoNode = opts.videoNode;
  var videoSrc = opts.videoSrc;
  var videoId = SPVideoManager.createVideo(videoNode, {
    'url': videoSrc,
    'type': opts.isDash ? 'dash' : null
  });

  var unsubscribeToVast = null;

  var video = {};

  function isActiveVideo() {
    var video = SPVideoManager.getVideo(videoId);
    var isActiveVideo = video === SPVideoManager.getActiveVideo();
    return video && isActiveVideo || false;
  }

  function deactivate() {
    if (isActiveVideo()) {
      unsubscribeToVast();
      SPVideoManager.clearActiveVideo();
    }
  }

  /**
   * @return {BillboardAdVideo} video
   */
  video.activate = function () {
    if (!isActiveVideo()) {
      SPVideoManager.setActiveVideo(videoId);
      unsubscribeToVast = VastEvents.subscribe(videoNode, _logEvent);
    }

    return video;
  };

  /**
   * @return {Promise} promise
   */
  video.restart = function () {
    return new Promise(function (resolve) {
      if (videoNode.currentTime === 0) {
        resolve();
        return;
      }

      function onSeeked() {
        videoNode.removeEventListener('seeked', onSeeked);
        resolve();
      }

      videoNode.addEventListener('seeked', onSeeked);
      videoNode.currentTime = 0;
    });
  };

  /**
   * @return {BillboardAdVideo} video
   */
  video.destroy = function () {
    deactivate();
    SPVideoManager.destroy(videoId);
    return video;
  };

  /**
   * @param  {Function} cb
   * @return {BillboardAdVideo} video
   */
  video.subscribe = function (cb) {
    SPVideoManager.subscribe(videoId, cb);
    return video;
  };

  return video;
};

module.exports = BillboardAdVideo;

},{"../../../../spotify-video-manager":493,"../../event-logger":213,"../../vast-events":250}],220:[function(require,module,exports){
(function (global){
'use strict';

var once = require('lodash/once');
var debug = require('debug')('saf:billboard-ad-view');

var i18n = require('../../../i18n');
var EventEmitter = require('events').EventEmitter;
var emitter = new EventEmitter();

var eventDispatcher = require('../../../../spotify-event-dispatcher');
var template = require('./template.hbs');
var CountDownAnimation = require('../../count-down-animation');
var CosmosConnector = require('../../cosmos-connector');
var cosmosConnector = new CosmosConnector();

var AUTO_MINIMIZE_AFTER_MS = 2000; // 2 seconds after focus received
var AUTO_TEAR_DOWN_AFTER_MS = 30000; // 30 seconds after focus received
var FADE_OUT_ANIMATION_LENGTH = 500;

var TEMPLATE_MANIFEST_URL = 'video-manifest-url';
var STREAMING_TYPE = 'dash+webm';

var eventTypes = require('../../event-types');
var BillboardAdVideo = require('./video');

// EVENTS
var VIEWED = 'viewed';
var CLICKED = 'clicked';
var EXPANDED = 'expanded';
var ENDED = 'ended';

function parseData(data) {
  var metaData = data.ad.metadata || {};
  var ret = {
    id: data.ad.id,
    isDash: false,
    isVideo: false,
    clickUrl: data.ad.click_url,
    mediaSrc: null,
    isValid: true,
    disclaimer: i18n.get('Sponsored'),
    accountUpgradeTracking: metaData.accountUpgradeTracking,
    accountUpgrade: metaData.accountUpgrade
  };

  switch (data.format) {
    case 'video':
      ret.isVideo = true;
      ret.companionSrc = data.ad.companion_ad.url;
      ret.mediaSrc = manifestUrlForSourceID(data.ad.metadata.videoPlaylistID);
      break;
    case 'banner':
      ret.companionSrc = data.ad.companion_ad.url;
      ret.mediaSrc = data.ad && data.ad.images && data.ad.images[0] && data.ad.images[0].url;
      break;
    case 'unknown':
      // its a dummy ad - used to measure billboard opportunity
      break;
    default:
      ret.isValid = false;
      break;
  }

  return ret;
}

function BillboardAdView(container, data) {
  var _this = this;

  // Properties
  this.container = container;
  this.activated = false;
  this.state = parseData(data);
  this.isDummyAd = !this.state.mediaSrc;

  // Timers
  this.timerAutoMinimize = null;
  this.timerAutoTearDown = null;

  // To keep track of first and second click on video overlay
  this.clicked = false;

  // Bind event listeners to correct context
  Object.keys(BillboardAdView.prototype).forEach(function (key) {
    if (typeof _this[key] === 'function') {
      _this[key] = _this[key].bind(_this);
    }
  });
}

/**
 * Setup method, renders the dom and adds event listeners.
 */
BillboardAdView.prototype.setup = function () {
  var billboard, companion, maximizer;

  this.container.classList.remove('minimized');

  if (!this.state.isValid) {
    this.finish();
    return;
  }

  if (this.isDummyAd) {
    // todo handle dummy ad better
    this.container.classList.add('dummy');
    debug('Dummy billboard ad rendered');
  } else {
    this.container.innerHTML = template(this.state);

    billboard = this.container.querySelector('.billboard');
    companion = this.container.querySelector('.companion');
    maximizer = this.container.querySelector('.maximizer');

    this.container.addEventListener('click', this._onContainerClicked);
    billboard.addEventListener('click', this._onBillboardClicked);
    companion.addEventListener('click', this._onCompanionClicked);
    maximizer.addEventListener('click', this._onMaximizerClicked);

    this.countdown = new CountDownAnimation(this.container.querySelector('.countdown'), 2000);

    if (this.state.isVideo) {
      this.container.classList.add('video');
      this._media = billboard.querySelector('video');
      this._video = BillboardAdVideo.create({
        adId: this.state.id,
        videoNode: this._media,
        videoSrc: this.state.mediaSrc,
        isDash: true
      });

      this._video.subscribe(function (err) {
        if (err) {
          debug(err);
          this.finish();
        }
      }.bind(this));

      this._media.addEventListener('canplay', once(this.fadeIn));
      this._media.addEventListener('error', this._onError);
    } else {
      this._media = billboard.querySelector('img');
      this._media.addEventListener('load', once(this.fadeIn));
      this._media.addEventListener('error', this._onError);
    }
  }

  window.addEventListener('mousemove', this._onWindowMouseMoved);
  this._dispatchEvent(eventTypes.AD_BILLBOARD_STARTED);
};

/**
 * Start the animations, should be called when the application receives
 * focus again.
 */
BillboardAdView.prototype.onFocusReceived = function () {
  var self = this;

  if (this.activated) return; // Prevent multiple starts

  this.activated = true;

  window.removeEventListener('mousemove', this._onWindowMouseMoved);

  this.timerAutoMinimize = setTimeout(self.minimize, AUTO_MINIMIZE_AFTER_MS);

  if (this.countdown) {
    this.countdown.start();
  }

  this._dispatchEvent(eventTypes.AD_BILLBOARD_FOCUS_RECEIVED);

  // Dummy ad impressions get tracked on intent 'now'
  if (!this.isDummyAd) {
    this.triggerViewed();
  }

  if (!this.state.isVideo) {
    this._postIntent('now');
  }
};

/**
 * Finish this billboard ad.
 * @return {Promise}
 */
BillboardAdView.prototype.finish = function () {
  // vast logger handles logging ended/skipped events
  if (!this.state.isVideo) this._logEvent(ENDED);

  return this.destroy().then(function () {
    this._dispatchEvent(eventTypes.AD_BILLBOARD_FINISHED);
    this._postIntent('clear');
  }.bind(this));
};

/**
 * @return {Promise}
 */
BillboardAdView.prototype.destroy = function () {
  return new Promise(function (resolve) {
    if (this._isDestroyed) {
      resolve();
      return;
    }
    this._isDestroyed = true;
    this._tearDown().then(resolve);
  }.bind(this));
};

BillboardAdView.prototype._postIntent = function (type) {
  switch (type) {
    case 'now':
    case 'clear':
      return cosmosConnector.postToSlot('billboard', { intent: type }).catch(function (e) {
        debug('error posting intent: ' + type, e);
      });
    default:
      throw new Error('intent not supported: ' + type);
  }
};

/**
 * Tear down this billboard ad view.
 * @return {Promise}
 */
BillboardAdView.prototype._tearDown = function () {
  return new Promise(function (resolve) {
    this.container.removeEventListener('click', this._onContainerClicked);
    window.removeEventListener('mousemove', this._onWindowMouseMoved);

    clearTimeout(this.timerAutoMinimize);
    clearTimeout(this.timerAutoTearDown);

    if (this.state.isVideo) {
      this._media.removeEventListener('ended', this.finish);
      this._media.removeEventListener('error', this._onError);
      this._video.destroy();
      this._dispatchEvent(eventTypes.AD_CLICK_VIDEO_ENDED);
    }

    this.fadeOut().then(function () {
      this.container.innerHTML = '';
      this.container.classList.remove('dummy');
      this.container.classList.remove('minimized');
      this.container.classList.remove('has-been-minimized');
      this.container.classList.remove('has-been-maximized');
      this.container.classList.remove('video');
      this._dispatchEvent(eventTypes.AD_BILLBOARD_DISCARDED);
      emitter.emit('INACTIVE');
      resolve();
    }.bind(this));
  }.bind(this));
};

/**
 * Fade the ad in
 * @return {Promise}
 */
BillboardAdView.prototype.fadeIn = function () {
  var self = this;
  debug('fadeIn');
  return new Promise(function (resolve) {
    var billboard = self.container.querySelector('.billboard');
    self.container.classList.add('visible');
    // Class added to expand the modal to take 100% of the client
    self.container.classList.add('modal-expanded');
    /*
    * @return {Boolean} Checks if is a skinny billboard in maximize or
    * minimize state
    */
    self.isSkinny = billboard.offsetWidth === 970 || self.container.classList.contains('skinny-overlay');
    // Checks if Overlay is a Skinny Overlay
    if (self.isSkinny) {
      // If is a Skinny Overlay then add skinny-overlay class
      self.container.classList.add('skinny-overlay');
    }
    setTimeout(function () {
      // El needs to be visible first in order to animate
      self.container.classList.add('ready'); // Triggers the fade
      setTimeout(function () {
        // Fade in animation takes 0.5 seconds
        self._dispatchEvent(eventTypes.AD_BILLBOARD_VISIBLE);
        resolve();
      }, FADE_OUT_ANIMATION_LENGTH);
    }, 100);
  });
};

/**
 * Fade the ad out
 * @return {Promise}
 */
BillboardAdView.prototype.fadeOut = function () {
  var self = this;
  debug('fadeOut');
  return new Promise(function (resolve) {
    self.container.classList.remove('ready'); // Triggers the fade

    setTimeout(function () {
      // Fade out animation takes 0.5 seconds
      self.container.classList.remove('visible'); // Hides it
      self.container.classList.remove('modal-expanded');
      self._dispatchEvent(eventTypes.AD_BILLBOARD_HIDDEN);
      resolve();
    }, FADE_OUT_ANIMATION_LENGTH);
  });
};

/**
 * Minimize this billboard ad view.
 */
BillboardAdView.prototype.minimize = function () {
  this._dispatchEvent(eventTypes.AD_BILLBOARD_MINIMIZED);
  if (this.state.isVideo && this.isUserMaximized()) {
    this.finish();
    return;
  }

  if (this.isSkinny) {
    this._ifImagePresent(function (img) {
      img.classList.add('blurred');
    });
  }

  this.container.classList.add('has-been-minimized');
  this.container.classList.add('minimized');
  this.container.classList.remove('modal-expanded');
  this.timerAutoTearDown = setTimeout(function () {
    this.finish();
  }.bind(this), AUTO_TEAR_DOWN_AFTER_MS);
};

/**
 * Maximize this billboard ad.
 */
BillboardAdView.prototype.maximize = function () {
  this._ifImagePresent(function (img) {
    img.classList.remove('blurred');
  });
  this.container.classList.add('has-been-maximized');
  this.container.classList.add('modal-expanded');
  this.container.classList.remove('minimized');
  clearTimeout(this.timerAutoTearDown);
  this.timerAutoTearDown = null;
  this._logEvent(EXPANDED);

  if (this.state.isVideo) {
    this._postIntent('now');
  }
};

BillboardAdView.prototype.play = function () {
  if (!this.state.isVideo) return;

  this._media.pause();
  this._video.restart().then(function () {
    this._video.activate();
    this._media.play();
    eventDispatcher.dispatchEvent({
      type: eventTypes.AD_CLICK_VIDEO_STARTED
    });
    this._media.addEventListener('ended', this.finish);
    this._media.loop = false;
  }.bind(this));
};

/**
 * Is the billboard in a state where it has been maximized by the user?
 * @return {Boolean}
 */
BillboardAdView.prototype.isUserMaximized = function () {
  return this.container.classList.contains('has-been-maximized') && !this.container.classList.contains('minimized');
};

BillboardAdView.prototype.triggerViewed = function () {
  this._logEvent(VIEWED);
  return this;
};

BillboardAdView.prototype._onError = function () {
  debug('Failed to load billboard ' + this.state.mediaSrc);
  this.finish();
};

BillboardAdView.prototype._dispatchEvent = function (type) {
  eventDispatcher.dispatchEvent({
    type: type,
    params: {
      id: this.state.id,
      isDummyAd: this.isDummyAd,
      isFullscreenAd: this.isSkinny
    },
    extra: {}
  });
};

BillboardAdView.prototype._logEvent = function (eventType) {
  var adId = this.state.id;

  cosmosConnector.postEvent(adId, eventType).catch(function (err) {
    debug('error logging event: ' + eventType, err);
  });
};

/**
 * Callback for when the mouse has been moved over the window,
 * used as a fallback to trigger the animations if the application focus
 * event hasn't been triggered properly.
 */
BillboardAdView.prototype._onWindowMouseMoved = function () {
  this.onFocusReceived();
};

/**
 * Event listener for when the maximizer icon has been clicked.
 * @param {Event} e The event triggered.
 */
BillboardAdView.prototype._onMaximizerClicked = function (e) {
  e.stopPropagation();
  this.maximize();
};

BillboardAdView.prototype._onBillboardOnClickOpenUrl = function () {
  if (this.state.accountUpgrade) {
    eventDispatcher.dispatchEvent({
      type: eventTypes.NAVIGATION_UPGRADE,
      params: {
        tracking: this.state.accountUpgradeTracking
      }
    });
  } else {
    window.open(this.state.clickUrl);
  }
};

BillboardAdView.prototype._onBillboardOnClickKeepMaximized = function () {
  clearTimeout(this.timerAutoMinimize);
  this.container.classList.add('has-been-maximized');
  this.play();
};

/**
 * Event listener for when the billboard has been clicked.
 * Clicks on the billboard when minimized should just maximize it.
 * @param {Event} e The event triggered.
 */
BillboardAdView.prototype._onBillboardClicked = function (e) {
  e.stopPropagation();
  e.preventDefault();

  // This was added to change the behavior of Video Overlay on initial click so
  // that when the user clicks on the ad before the timer stops the ad will then
  // restart and play. Then on the second click the user will be directed to
  // the advertiser's landing page.
  if (this.state.isVideo && !this.isMinimized() && !this.clicked) {
    this._onBillboardOnClickKeepMaximized();
    this.container.querySelector('.countdown').style.display = 'none';
    this.clicked = true;
  } else {
    this._onBillboardOnClickOpenUrl();
  }

  // Default behavior if not a Video ad
  if (this.container.classList.contains('minimized')) {
    e.preventDefault();
    this.maximize();
  } else {
    this._logEvent(CLICKED);
  }
};

/**
 * Is the billboard in a state where it has been minimized by the user?
 * @return {Boolean}
 */
BillboardAdView.prototype.isMinimized = function () {
  return this.container.classList.contains('has-been-minimized');
};

/**
 * Event listener for when the companion banner has been clicked.
 * @param {Event} e The event triggered.
 */
BillboardAdView.prototype._onCompanionClicked = function (e) {
  e.stopPropagation();
  this._logEvent(CLICKED);
};

/**
 * Event listener for when the container has been clicked.
 */
BillboardAdView.prototype._onContainerClicked = function () {
  if (this.container.classList.contains('has-been-maximized')) {
    this.finish();
  }
};

/**
 * If the billboard has an image element, execute the provided function
 * with the element provided as an argument.
 * @return {Boolean} true if image is present, false otherwise.
 */
BillboardAdView.prototype._ifImagePresent = function (callback) {
  var img = this.container.querySelector('.billboard').querySelector('img');
  if (img) {
    callback(img);
    return true;
  }
  return false;
};

BillboardAdView.on = function (eventName, callback) {
  emitter.on(eventName, callback);
};

function manifestUrlForSourceID(sourceID) {
  return global.__spotify.product_state[TEMPLATE_MANIFEST_URL].replace(/\{type\}/i, STREAMING_TYPE).replace(/\{source_id\}/i, encodeURIComponent(sourceID));
}

module.exports = BillboardAdView;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../../../spotify-event-dispatcher":264,"../../../i18n":192,"../../cosmos-connector":208,"../../count-down-animation":209,"../../event-types":214,"./template.hbs":218,"./video":219,"debug":526,"events":531,"lodash/once":618}],221:[function(require,module,exports){
'use strict';

module.exports = {
  ENABLED: 'ENABLED',
  DISABLED: 'DISABLED',
  ACTIVE: 'ACTIVE',
  INACTIVE: 'INACTIVE'
};

},{}],222:[function(require,module,exports){
'use strict';

var utils = require('../../utils');
var debug = require('debug')('saf:hpto-response');

function getKeyByValue(v, obj) {
  return Object.keys(obj).find(function (k) {
    return obj[k] === v;
  });
}

/**
 * Rename image banner mode field to 'image'
 * (Historically has been set to 'html')
 *
 * @api private
 * @param  {Object} data - response from dfp
 * @return {Object} normalized data
 */

function _renameImageBannerField(data) {
  var oldBannerKey = getKeyByValue('html', data);
  delete data[oldBannerKey];

  return Object.assign({}, data, {
    bannerMode: 'image'
  });
}

/**
 * Normalize native elem data
 *
 * @api private
 * @param  {Object} data - response from dfp
 * @return {Object} normalized data
 */

function _handleNativeEl(data) {
  var doc = document.implementation.createHTMLDocument('');
  doc.documentElement.innerHTML = data.html;
  var badge = '';
  var nativeElNode = doc.getElementById('native-elements');
  var oldBannerKey = getKeyByValue('html', data);
  var badges = ['data-is-spotlight', 'data-is-exclusive', 'data-is-sponsored'];

  badges.some(function (b) {
    if (nativeElNode.hasAttribute(b)) {
      badge = b;
    }
    return badge;
  });

  badge = badge.split('-').pop() || '';

  delete data[oldBannerKey];

  return Object.assign({}, data, {
    version: 2,
    badge: badge,
    bannerMode: 'native',
    blurb: nativeElNode.getAttribute('data-blurb'),
    targetUri: nativeElNode.getAttribute('data-uri'),
    playButtonUri: nativeElNode.getAttribute('data-track-override')
  });
}

/**
 * Wrapper around normalizing data coming from DFP.
 *
 * @api public
 * @param {Object} data
 */

function parseHptoResponse(data) {
  debug('parseHptoResponse data=%o', data);
  var parsed = null;

  var isNativeEl = data.html && data.html.search(/id=\"native\-elements\"/) !== -1;

  var isImageEl = !data.html && utils.getProp('banner mode', data) === 'html';

  if (isNativeEl) {
    parsed = _handleNativeEl(data);
  } else if (isImageEl) {
    parsed = _renameImageBannerField(data);
  }

  parsed = parsed || data;
  parsed.bannerMode = utils.getProp('banner mode', parsed);

  if (!parsed.bannerMode) {
    throw new TypeError('hpto data looks invalid');
  }

  debug('parseHptoResponse result=%o', parsed);
  return parsed;
}

module.exports = parseHptoResponse;

},{"../../utils":249,"debug":526}],223:[function(require,module,exports){
'use strict';

var curry = require('lodash/curry');
var EventEmitter = require('events').EventEmitter;
var debug = require('debug')('saf:hpto-ad');

var eventDispatcher = require('../../../../spotify-event-dispatcher');
var eventCenter = require('../../../../spotify-events/center');
var live = require('../../../../spotify-live');

var CosmosConnector = require('../../cosmos-connector');

var emitter = new EventEmitter();
var cosmosConnector = new CosmosConnector();

var eventTypes = require('../../event-types');
var utils = require('../../utils');
var session = require('../../session');
var settings = require('../../settings');
var targeter = require('../../targeter');
var adEventLogger = require('../../ad-event-logger');

var dfp = require('../../dfp');

var parseHptoRes = require('./hpto-response');

var VIEW_MAP = {
  'native': require('./views/native-hpto-view'),
  'html': require('./views/html-hpto-view'),
  'image': require('./views/image-hpto-view')
};

var fetchAd = curry(_fetchAd);
var addCreativeIdTo = curry(_addCreativeIdTo);

// EVENTS
var ENABLED = 'ENABLED';
var DISABLED = 'DISABLED';
var ACTIVE = 'ACTIVE';
var INACTIVE = 'INACTIVE';

var isActive = false;
var isEnabled = false;

var containerEl = document.createElement('div');
containerEl.id = 'hpto-container';

/**
 * @module HptoAd
 */
var HptoAd = {};

/**
 * @param  {HTMLElement} mountNode
 * @return {HptoAd}
 */
HptoAd.appendTo = function (mountNode) {
  mountNode.appendChild(containerEl);
  return HptoAd;
};

/**
 * @return {HptoAd}
 */
HptoAd.enable = function () {
  if (containerEl.parentNode === null) {
    throw new Error('Hpto hasn\'t been mounted yet');
  }

  if (!isEnabled) {
    eventDispatcher.addEventListener(eventTypes.DEBUG_FORCE_REFRESH_HPTO, handleForceRefresh);

    // returns true if is preview uri
    if (!subscribeToAppUpdates()) {
      var sessionData = session.get();

      settings.getHidePref(sessionData.platform, sessionData.isPremium).then(function (isHidden) {
        emitter.emit(ENABLED);

        if (!isHidden) {
          containerEl.classList.remove('hpto-closed');
          _render(sessionData, containerEl).then(emitter.emit.bind(emitter, ACTIVE));
        } else {
          eventCenter.emit(eventTypes.AD_HPTO_HIDDEN);
        }
      });
    }
  }

  return HptoAd;
};

/**
 * @return {HptoAd}
 */
HptoAd.disable = function () {
  if (isEnabled) {
    eventDispatcher.removeEventListener(eventTypes.DEBUG_FORCE_REFRESH_HPTO, handleForceRefresh);

    // workaround since we persist container now
    containerEl.style.backgroundImage = '';

    containerEl.innerHTML = '';
    emitter.emit(DISABLED);
  }

  return HptoAd;
};

/**
 * @param  {String} eventName
 * @param  {Function} callback
 * @return {HptoAd}
 */
HptoAd.on = function (eventName, callback) {
  emitter.on(eventName, callback);
  return HptoAd;
};

/**
 * @param  {String} eventName
 * @param  {Function} callback
 * @return {HptoAd}
 */
HptoAd.off = function (eventName, callback) {
  emitter.removeListener(eventName, callback);
  return HptoAd;
};

/**
 * @return {Boolean} isEnabled
 */
HptoAd.isEnabled = function () {
  return isEnabled;
};

/**
 * @return {Boolean} isEnabled
 */
HptoAd.isActive = function () {
  return isActive;
};

HptoAd.EVENTS = {
  ENABLED: ENABLED,
  DISABLED: DISABLED,
  ACTIVE: ACTIVE,
  INACTIVE: INACTIVE
};

emitter.on(ENABLED, function () {
  isEnabled = true;
});

emitter.on(DISABLED, function () {
  isEnabled = false;
  emitter.emit(INACTIVE);
});

emitter.on(ACTIVE, function () {
  isActive = true;
});

emitter.on(INACTIVE, function () {
  isActive = false;
});

/**
 * @private Exposed for testing
 * @param {Object} dfpData
 * @param {HTMLElement} domEl
 * @return {Promise}
 */
HptoAd._renderAd = function (domEl, isPremium, adData) {
  debug('renderAd isPremium=%o, adData=%o', isPremium, adData);
  var View = VIEW_MAP[adData.bannerMode];
  if (adData.accountUpgrade) {
    domEl.addEventListener('click', function (e) {
      e.preventDefault();
      e.stopPropagation();
      window.parent.postMessage({
        type: eventTypes.NAVIGATION_UPGRADE,
        data: { tracking: adData.accountUpgradeTracking }
      }, '*');
    });
  }
  return View.render({
    domEl: domEl,
    adData: adData,
    isPremium: isPremium
  });
};

/**
* @param  {Object} data
* @param  {String} data.platform
* @param  {Boolean} data.isPremium
* @param  {HTMLElement} domEl
* @return {Promise}
*/
function _render(data, domEl) {
  var inventoryUnit = dfp.inventoryUnit(data.platform, data.isPremium);

  return targeter.getTargeting(inventoryUnit).then(appendDefaultProps).then(fetchAd(domEl)).then(parseAdResponse).then(addCreativeIdTo(domEl)).then(HptoAd._renderAd.bind(null, domEl, data.isPremium)).catch(logError);
}

function handleForceRefresh() {
  HptoAd.disable();
  HptoAd.enable();
}

function subscribeToAppUpdates() {
  var app = live('spotify:application');
  var args = app.get('arguments');
  var isPreview = _isPreview(app.get('arguments'));
  app.on('update', onAppUpdate);
  // handle preview initial preview
  if (isPreview) handlePreviewUri(args);
  return isPreview;
}

function onAppUpdate(e) {
  if (e.hasOwnProperty('active')) handleBrowseNavChange(e.active);else if (_isPreview(e.arguments)) handlePreviewUri(e.arguments);
}

function _isPreview(args) {
  return !!(args && utils.parseGID(args));
}

/**
  * Decides when to render HPTO after clicking on a
  * different app or different tab
  * @private
  * @param {Boolean} active - if browse view is active or not
  */
function handleBrowseNavChange(active) {
  debug('handleBrowseNavChange active=%o', active);
  if (active) HptoAd.enable();else HptoAd.disable();
}

function handlePreviewUri(arg) {
  var gid = utils.parseGID(arg);

  HptoAd.disable();

  cosmosConnector.getPreviewAd(gid).then(function (res) {
    return res.ad;
  }).then(parseAdResponse).then(addCreativeIdTo(containerEl)).then(HptoAd._renderAd.bind(null, containerEl, false)).then(emitter.emit.bind(emitter, ENABLED)).then(emitter.emit.bind(emitter, ACTIVE)).catch(function (e) {
    debug('preview error: %o', e);
    console.error(e);
  });
}

/**
 * Append ad dimensions / inventory type
 * @param  {Object} data - session data
 * @param  {String} data.platform
 * @param  {Boolean} data.isPremium
 * @return {Object}
 */
function appendDefaultProps(data) {
  return Object.assign({}, data, {
    inventoryType: 'hpto',
    width: 1200,
    height: 270
  });
}

/**
 * Wrapper for fetching ad from ad server
 * @param {Object} targetingData
 * @param {HTMLElement} domEl
 */
function _fetchAd(domEl, targetingData) {
  debug('fetchAd targetingData=%o', targetingData);
  return dfp.fetchHptoAd(domEl, targetingData);
}

/**
 * @param  {Object} dfpData
 * @return {Promise}
 */
function parseAdResponse(dfpData) {
  var hptoData = dfpData.hpto ? dfpData.hpto : dfpData;
  return parseHptoRes(hptoData);
}

/**
 * @param  {HTMLElement} element
 * @param  {Object} data
 * @param  {String} data.creativeId
 * @return {void}
 */
function _addCreativeIdTo(element, data) {
  debug('add creativeId from data: %o', data);
  element.setAttribute('data-id', data.creativeId);
  return data;
}

function logError() {
  var message = {};
  message[adEventLogger.keys.EVENT] = 'event_errored';
  message[adEventLogger.keys.AD_FORMAT] = 'hpto';
  message[adEventLogger.keys.JSONDATA] = JSON.stringify({
    'dfp_returned_empty': true
  });
  debug('logError message=%o', message);
  return adEventLogger.log(message);
}

HptoAd.AD_HPTO_HIDDEN = eventTypes.AD_HPTO_HIDDEN;
HptoAd.AD_HPTO_RENDERED = eventTypes.AD_HPTO_RENDERED;

module.exports = HptoAd;

},{"../../../../spotify-event-dispatcher":264,"../../../../spotify-events/center":268,"../../../../spotify-live":439,"../../ad-event-logger":205,"../../cosmos-connector":208,"../../dfp":211,"../../event-types":214,"../../session":246,"../../settings":247,"../../targeter":248,"../../utils":249,"./hpto-response":222,"./views/html-hpto-view":227,"./views/image-hpto-view":228,"./views/native-hpto-view":229,"debug":526,"events":531,"lodash/curry":608}],224:[function(require,module,exports){
'use strict';

module.exports = {
  nativeEl: require('./native_element_ad_tpl.hbs'),
  sponsored: require('./sponsored_hpto_tpl.hbs')
};

},{"./native_element_ad_tpl.hbs":225,"./sponsored_hpto_tpl.hbs":226}],225:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, options, functionType="function", escapeExpression=this.escapeExpression, self=this, helperMissing=helpers.helperMissing;

function program1(depth0,data) {


  return "verified";
  }

function program3(depth0,data) {


  return "?action=browse";
  }

function program5(depth0,data) {

  var buffer = "", stack1;
  buffer += "\n                ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.imageUrl), {hash:{},inverse:self.noop,fn:self.program(6, program6, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n              ";
  return buffer;
  }
function program6(depth0,data) {

  var buffer = "", stack1, helper;
  buffer += "\n                  <div class=\"mo-image-background-color\">\n	      <div class=\"mo-image-background\" style=\"background-image: url(";
  if (helper = helpers.smallImageUri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.smallImageUri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + ")\"></div>\n                  </div>\n                ";
  return buffer;
  }

function program8(depth0,data) {

  var buffer = "", stack1, helper;
  buffer += "\n            <img src=\"";
  if (helper = helpers.sponsoredLogo) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.sponsoredLogo); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"/>\n            <p>Presents</p>\n          ";
  return buffer;
  }

function program10(depth0,data) {

  var buffer = "", stack1, helper;
  buffer += "\n        <div class=\"ne-attrib\">\n    <a href=\"";
  if (helper = helpers.attributionUri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.attributionUri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-uri=\"";
  if (helper = helpers.attributionUri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.attributionUri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"  id=\"ne-attrib-link\">";
  if (helper = helpers.attribution) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.attribution); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</a>\n        </div>\n        ";
  return buffer;
  }

function program12(depth0,data) {

  var buffer = "", helper, options;
  buffer += "\n              <div class=\"b-add-text\">"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Save", options) : helperMissing.call(depth0, "loc", "Save", options)))
    + "</div>\n              <div class=\"b-added-text b-alt-text\">"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Saved", options) : helperMissing.call(depth0, "loc", "Saved", options)))
    + "</div>\n              <div class=\"b-remove-text b-alt-text\">"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Remove", options) : helperMissing.call(depth0, "loc", "Remove", options)))
    + "</div>\n            ";
  return buffer;
  }

function program14(depth0,data) {

  var buffer = "", helper, options;
  buffer += "\n              <div class=\"b-add-text\">"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Follow", options) : helperMissing.call(depth0, "loc", "Follow", options)))
    + "</div>\n              <div class=\"b-added-text b-alt-text\">"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Following", options) : helperMissing.call(depth0, "loc", "Following", options)))
    + "</div>\n              <div class=\"b-remove-text b-alt-text\">"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Unfollow", options) : helperMissing.call(depth0, "loc", "Unfollow", options)))
    + "</div>\n            ";
  return buffer;
  }

  buffer += "<header class=\"header header-album ne-header\" data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-contextmenu>\n\n  <div class=\"ne-left-fade\"></div>\n\n  <section class=\"h-main-content container clearfix ne-container\">\n    <div class=\"ne-container-center\">\n      <div class=\"h-media\">\n        <div class=\"media-object media-object-simple media-object-link media-object-"
    + escapeExpression(((stack1 = (depth0 && depth0.type)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + " "
    + escapeExpression(((stack1 = (depth0 && depth0.type)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + " ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.isVerified), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\" data-context=\"\" data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-log-context=\"media-object\">\n          <div class=\"mo-image-wrapper\">\n            <a href=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1);
  stack1 = (helper = helpers.type || (depth0 && depth0.type),options={hash:{},inverse:self.noop,fn:self.program(3, program3, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.uri), "track", options) : helperMissing.call(depth0, "type", (depth0 && depth0.uri), "track", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\" data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" title=\"";
  if (helper = helpers.name) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.name); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-log-click=\"media-image\" id=\"ne-image-link\">\n              <svg class=\"mo-placeholder\" viewBox=\"0 0 10 10\" preserveAspectRatio=\"xMidYMid meet\">\n                <text class=\"playlist-placeholder\" x=\"5\" y=\"9.8\"></text>\n                <text class=\"album-placeholder\" x=\"5\" y=\"9.8\"></text>\n                <text class=\"artist-placeholder\" x=\"5\" y=\"9.8\"></text>\n                <text class=\"user-placeholder\" x=\"5\" y=\"9.8\"></text>\n              </svg>\n              ";
  stack1 = (helper = helpers.type || (depth0 && depth0.type),options={hash:{},inverse:self.noop,fn:self.program(5, program5, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.uri), "album", "playlist", "track", options) : helperMissing.call(depth0, "type", (depth0 && depth0.uri), "album", "playlist", "track", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n	<div class=\"mo-image\" style=\"background-image: url(";
  if (helper = helpers.smallImageUri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.smallImageUri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + ")\">\n                <span class=\"mo-verified\">\n                  <span class=\"spoticon-check-16\"></span>\n                </span>\n              </div>\n            </a>\n          </div>\n        </div>\n      </div>\n      <div class=\"h-data\">\n        <div class=\"h-label ";
  if (helper = helpers.badgeType) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.badgeType); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\">\n          ";
  if (helper = helpers.typeLabel) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.typeLabel); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n          ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.sponsoredLogo), {hash:{},inverse:self.noop,fn:self.program(8, program8, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n        </div>\n\n  <h1 class=\"h-title ne-title\" data-contextmenu>\n          <a href=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1);
  stack1 = (helper = helpers.type || (depth0 && depth0.type),options={hash:{},inverse:self.noop,fn:self.program(3, program3, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.uri), "track", options) : helperMissing.call(depth0, "type", (depth0 && depth0.uri), "track", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\" data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" id=\"ne-name-link\">\n            <span class=\"ne-underline\">";
  if (helper = helpers.name) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.name); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</span>\n          </a>\n        </h1>\n\n        ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.attribution), {hash:{},inverse:self.noop,fn:self.program(10, program10, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n        <div class=\"h-description\">\n          ";
  if (helper = helpers.blurb) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.blurb); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\n        </div>\n\n        <div class=\"h-controllers\" data-context data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\">\n    <button class=\"button button-green button-play\" data-context data-button=\"play\" id=\"ne-play-button\" data-uri=\"";
  if (helper = helpers.playBtnUri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.playBtnUri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\">\n            <div class=\"b-play-text\">"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Play", options) : helperMissing.call(depth0, "loc", "Play", options)))
    + "</div>\n            <div class=\"b-pause-text b-alt-text\">"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Pause", options) : helperMissing.call(depth0, "loc", "Pause", options)))
    + "</div>\n          </button>\n          <button class=\"button button-with-stroke button-add\" data-button=\"add\" data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" id=\"ne-save-button\">\n            ";
  stack1 = (helper = helpers.type || (depth0 && depth0.type),options={hash:{},inverse:self.noop,fn:self.program(12, program12, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.uri), "track", "album", options) : helperMissing.call(depth0, "type", (depth0 && depth0.uri), "track", "album", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n            ";
  stack1 = (helper = helpers.type || (depth0 && depth0.type),options={hash:{},inverse:self.noop,fn:self.program(14, program14, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.uri), "playlist", "user", "artist", options) : helperMissing.call(depth0, "type", (depth0 && depth0.uri), "playlist", "user", "artist", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n          </button>\n          <button class=\"button button-icon-with-stroke spoticon-more-16\" data-button=\"contextmenu\" data-tooltip=\"More\" id=\"ne-more-button\"></button>\n        </div>\n      </div>\n    </div>\n  </section>\n\n  <div class=\"ne-right-fade\"></div>\n  <div class=\"ne-bottom-fade\"></div>\n  <div class=\"ne-bg-image bg-centered blurred ne-"
    + escapeExpression(((stack1 = (depth0 && depth0.type)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\" style=\"background-image: url('";
  if (helper = helpers.backgroundImage) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.backgroundImage); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "');\"></div>\n</header>\n";
  return buffer;
  });

},{"hbsfy/runtime":563}],226:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, options, functionType="function", escapeExpression=this.escapeExpression, self=this, helperMissing=helpers.helperMissing;

function program1(depth0,data) {


  return "verified";
  }

function program3(depth0,data) {


  return "?action=browse";
  }

function program5(depth0,data) {

  var buffer = "", stack1;
  buffer += "\n                ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.imageUrl), {hash:{},inverse:self.noop,fn:self.program(6, program6, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n              ";
  return buffer;
  }
function program6(depth0,data) {

  var buffer = "", stack1, helper;
  buffer += "\n                  <div class=\"mo-image-background-color\">\n                    <div class=\"mo-image-background\" style=\"background-image: url(";
  if (helper = helpers.smallImageUri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.smallImageUri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + ")\"></div>\n                  </div>\n                ";
  return buffer;
  }

function program8(depth0,data) {

  var buffer = "", stack1, helper;
  buffer += "\n        <div class=\"ne-attrib\">\n          <a href=\"";
  if (helper = helpers.attributionUri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.attributionUri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-uri=\"";
  if (helper = helpers.attributionUri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.attributionUri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"  id=\"ne-attrib-link\">";
  if (helper = helpers.attribution) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.attribution); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</a>\n        </div>\n        ";
  return buffer;
  }

function program10(depth0,data) {

  var buffer = "", helper, options;
  buffer += "\n              <div class=\"b-add-text\">"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Save", options) : helperMissing.call(depth0, "loc", "Save", options)))
    + "</div>\n              <div class=\"b-added-text b-alt-text\">"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Saved", options) : helperMissing.call(depth0, "loc", "Saved", options)))
    + "</div>\n              <div class=\"b-remove-text b-alt-text\">"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Remove", options) : helperMissing.call(depth0, "loc", "Remove", options)))
    + "</div>\n            ";
  return buffer;
  }

function program12(depth0,data) {

  var buffer = "", helper, options;
  buffer += "\n              <div class=\"b-add-text\">"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Follow", options) : helperMissing.call(depth0, "loc", "Follow", options)))
    + "</div>\n              <div class=\"b-added-text b-alt-text\">"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Following", options) : helperMissing.call(depth0, "loc", "Following", options)))
    + "</div>\n              <div class=\"b-remove-text b-alt-text\">"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Unfollow", options) : helperMissing.call(depth0, "loc", "Unfollow", options)))
    + "</div>\n            ";
  return buffer;
  }

  buffer += "<header class=\"header-album\" data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-contextmenu>\n  <div class=\"ne-left-fade\" style=\"width:590px\"></div>\n\n  <section class=\"h-main-content container clearfix ne-container sponsored\" style=\"padding:16px\">\n    <div class=\"ne-container-center\" style=\"overflow:auto; margin:0\">\n      <div class=\"sponsorship\" style=\"overflow:auto;margin-bottom:48px\">\n        <div class=\"h-label\">\n          <p style=\"margin:0\">"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "PresentedBy", options) : helperMissing.call(depth0, "loc", "PresentedBy", options)))
    + "</p>\n          <img src=\"";
  if (helper = helpers.sponsoredLogo) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.sponsoredLogo); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" style=\"margin:4px 0;height:40px\"/>\n          <p style=\"text-transform:none;margin-top:2px\">";
  if (helper = helpers.logoBlurb) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.logoBlurb); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</p>\n        </div>\n      </div>\n      <div class=\"h-media\" style=\"width:172px\">\n        <div class=\"media-object media-object-simple media-object-link media-object-"
    + escapeExpression(((stack1 = (depth0 && depth0.type)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + " "
    + escapeExpression(((stack1 = (depth0 && depth0.type)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + " ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.isVerified), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\" data-context=\"\" data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-log-context=\"media-object\">\n          <div class=\"mo-image-wrapper\">\n            <a href=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1);
  stack1 = (helper = helpers.type || (depth0 && depth0.type),options={hash:{},inverse:self.noop,fn:self.program(3, program3, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.uri), "track", options) : helperMissing.call(depth0, "type", (depth0 && depth0.uri), "track", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\" data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" title=\"";
  if (helper = helpers.name) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.name); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-log-click=\"media-image\" id=\"ne-image-link\">\n              <svg class=\"mo-placeholder\" viewBox=\"0 0 10 10\" preserveAspectRatio=\"xMidYMid meet\">\n                <text class=\"playlist-placeholder\" x=\"5\" y=\"9.8\"></text>\n                <text class=\"album-placeholder\" x=\"5\" y=\"9.8\"></text>\n                <text class=\"artist-placeholder\" x=\"5\" y=\"9.8\"></text>\n                <text class=\"user-placeholder\" x=\"5\" y=\"9.8\"></text>\n              </svg>\n              ";
  stack1 = (helper = helpers.type || (depth0 && depth0.type),options={hash:{},inverse:self.noop,fn:self.program(5, program5, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.uri), "album", "playlist", "track", options) : helperMissing.call(depth0, "type", (depth0 && depth0.uri), "album", "playlist", "track", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n              <div class=\"mo-image\" style=\"background-image: url(";
  if (helper = helpers.smallImageUri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.smallImageUri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + ")\">\n                <span class=\"mo-verified\">\n                  <span class=\"spoticon-check-16\"></span>\n                </span>\n              </div>\n            </a>\n          </div>\n        </div>\n      </div>\n      <div class=\"h-data\">\n        <div class=\"h-label\">\n          ";
  if (helper = helpers.typeLabel) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.typeLabel); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n        </div>\n\n        <h1 class=\"h-title ne-title\" data-contextmenu>\n          <a href=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1);
  stack1 = (helper = helpers.type || (depth0 && depth0.type),options={hash:{},inverse:self.noop,fn:self.program(3, program3, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.uri), "track", options) : helperMissing.call(depth0, "type", (depth0 && depth0.uri), "track", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\" data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" id=\"ne-name-link\">\n            <span class=\"ne-underline\">";
  if (helper = helpers.name) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.name); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</span>\n          </a>\n        </h1>\n\n        ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.attribution), {hash:{},inverse:self.noop,fn:self.program(8, program8, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n\n        <div class=\"h-description\">\n          ";
  if (helper = helpers.blurb) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.blurb); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\n        </div>\n\n        <div class=\"h-controllers\" data-context data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" style=\"bottom:16px\">\n          <button class=\"button button-green button-play\" data-context data-button=\"play\" id=\"ne-play-button\" data-uri=\"";
  if (helper = helpers.playBtnUri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.playBtnUri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\">\n            <div class=\"b-play-text\">"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Play", options) : helperMissing.call(depth0, "loc", "Play", options)))
    + "</div>\n            <div class=\"b-pause-text b-alt-text\">"
    + escapeExpression((helper = helpers.loc || (depth0 && depth0.loc),options={hash:{},data:data},helper ? helper.call(depth0, "Pause", options) : helperMissing.call(depth0, "loc", "Pause", options)))
    + "</div>\n          </button>\n          <button class=\"button button-with-stroke button-add\" data-button=\"add\" data-uri=\"";
  if (helper = helpers.uri) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.uri); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" id=\"ne-save-button\">\n            ";
  stack1 = (helper = helpers.type || (depth0 && depth0.type),options={hash:{},inverse:self.noop,fn:self.program(10, program10, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.uri), "track", "album", options) : helperMissing.call(depth0, "type", (depth0 && depth0.uri), "track", "album", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n            ";
  stack1 = (helper = helpers.type || (depth0 && depth0.type),options={hash:{},inverse:self.noop,fn:self.program(12, program12, data),data:data},helper ? helper.call(depth0, (depth0 && depth0.uri), "playlist", "user", "artist", options) : helperMissing.call(depth0, "type", (depth0 && depth0.uri), "playlist", "user", "artist", options));
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n          </button>\n          <button class=\"button button-icon-with-stroke spoticon-more-16\" data-button=\"contextmenu\" data-tooltip=\"More\" id=\"ne-more-button\"></button>\n        </div>\n      </div>\n    </div>\n    <img class=\"sponsored-credits\" src=\"";
  if (helper = helpers.credits) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.credits); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\"/>\n  </section>\n\n  <div class=\"ne-bottom-fade\"></div>\n  <div class=\"ne-bg-image ne-"
    + escapeExpression(((stack1 = (depth0 && depth0.type)),typeof stack1 === functionType ? stack1.apply(depth0) : stack1))
    + "\" style=\"background-image: url('";
  if (helper = helpers.backgroundImage) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.backgroundImage); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "');\"></div>\n</header>\n";
  return buffer;
  });

},{"hbsfy/runtime":563}],227:[function(require,module,exports){
'use strict';

var curry = require('lodash/curry');

var eventCenter = require('../../../../../spotify-events/center');

var eventTypes = require('../../../event-types');
var utils = require('../../../utils');
var comscoreUrl = require('../../../external-tags').comscore;
var adEventLogger = require('../../../ad-event-logger');

var viewUtils = require('./view-utils');

// Curried functions
var appendBackgroundImage = curry(_appendBackgroundImage);
var fireThirdPartyImp = curry(viewUtils.fireThirdPartyImp);
var appendHideBtn = curry(viewUtils.appendHideBtn);

var HtmlHptoView = {};

/**
 * @param  {Object} opts
 * @param  {Object} opts.adData
 * @param  {String} opts.adData.backgroundImage
 * @param  {String} opts.adData.html
 * @param  {HTMLElement} opts.domEl
 * @param  {Boolean} opts.isPremium
 * @return {Promise}
 */
HtmlHptoView.render = function (opts) {
  var adData = opts.adData;
  var domEl = opts.domEl;
  var isPremium = opts.isPremium;

  // Throw if missing both bg image and html data
  if (!!adData.html === false && !utils.getProp('background image', adData)) {
    throw new Error('[Html HPTO] Missing image / html tag');
  }

  return Promise.resolve(appendAd(domEl, adData)).then(appendBackgroundImage(domEl)).then(fireThirdPartyImp(domEl)).then(logViewed).then(appendHideBtn(domEl, isPremium)).catch(function (e) {
    console.error(e.message);
  });
};

/**
 * @param  {HTMLElement} domEl
 * @param  {Object} data
 * @param  {String} data.html
 * @return {Object}
 */
function appendAd(domEl, data) {
  var iframe = utils.createInteractiveIframe(data.html);
  var bgUrl = utils.getProp('background url', data);

  domEl.classList.add('min-width');

  // Fire comscore pixel
  utils.appendTrackingPixel(comscoreUrl, domEl);

  if (bgUrl) {
    var anchorTag = document.createElement('a');
    anchorTag.href = bgUrl;

    anchorTag.addEventListener('click', function () {
      utils.appendTrackingPixel(data.click, domEl);
    });

    anchorTag.appendChild(iframe);
    domEl.appendChild(anchorTag);
  } else {
    domEl.appendChild(iframe);
  }

  eventCenter.emit(eventTypes.AD_HPTO_RENDERED);

  return data;
}

/**
 * Add background
 * @param  {HTMLElement} domEl
 * @param  {Object} data
 * @param  {String} data.backgroundImage
 * @return {Object}
 */
function _appendBackgroundImage(domEl, data) {
  var bgImg = utils.getProp('background image', data);
  var bgColor = utils.getProp('background color', data);

  if (bgImg) {
    domEl.style.backgroundImage = 'url(' + viewUtils.getImageLink(bgImg) + ')';
  }

  if (bgColor) {
    domEl.style.backgroundColor = (bgColor[0] === '#' ? '' : '#') + bgColor;
  }

  return data;
}

/**
 * @param  {Object} data
 * @param  {String} data.bannerMode
 * @param  {String} data.lineItemId
 * @param  {String} data.creativeId
 * @return {Object}
 */
function logViewed(data) {
  var message = {};
  message[adEventLogger.keys.EVENT] = 'event_viewed';
  message[adEventLogger.keys.AD_FORMAT] = 'hpto ' + data.bannerMode;
  message[adEventLogger.keys.LINE_ITEM_ID] = data.lineItemId;
  message[adEventLogger.keys.CREATIVE_ID] = data.creativeId;
  message[adEventLogger.keys.AD_ID] = data.creativeId;
  adEventLogger.log(message);
  return data;
}

module.exports = HtmlHptoView;

},{"../../../../../spotify-events/center":268,"../../../ad-event-logger":205,"../../../event-types":214,"../../../external-tags":215,"../../../utils":249,"./view-utils":230,"lodash/curry":608}],228:[function(require,module,exports){
'use strict';

var curry = require('lodash/curry');

var live = require('../../../../../spotify-live');
var URI = require('spotify-liburi');
var eventCenter = require('../../../../../spotify-events/center');

var adEventLogger = require('../../../ad-event-logger');
var eventTypes = require('../../../event-types');
var utils = require('../../../utils');

var viewUtils = require('./view-utils');

// Curried functions
var appendAd = curry(_appendAd);
var fireThirdPartyImp = curry(viewUtils.fireThirdPartyImp);
var appendHideBtn = curry(viewUtils.appendHideBtn);
var onAdClick = curry(_onAdClick);

var ImageHptoView = {};

/**
 * @param  {Object} opts
 * @param  {Object} opts.adData
 * @param  {String} opts.adData.backgroundImage
 * @param  {String} opts.adData.html
 * @param  {HTMLElement} opts.domEl
 * @param  {Boolean} opts.isPremium
 * @return {Promise}
 */
ImageHptoView.render = function (opts) {
  var adData = opts.adData;
  var domEl = opts.domEl;
  var isPremium = opts.isPremium;

  if (!utils.getProp('background image', adData)) {
    throw new Error('[Image HPTO] Missing background image');
  }

  return getAttributes(adData).then(appendAd(domEl)).then(fireThirdPartyImp(domEl)).then(logViewed).then(appendHideBtn(domEl, isPremium));
};

/**
 * @param  {Object} data
 * @return {Promise}
 */
function getAttributes(data) {
  return new Promise(function (resolve) {
    var props = {};
    props.bgImg = utils.getProp('background image', data);
    props.bgColor = utils.getProp('background color', data);
    props.url = utils.getProp('background url', data);
    props.clickThrough = props.url && props.url.replace(/&amp;/g, '&');

    resolve(Object.assign({}, props, data));
  });
}

/**
 * @param {String} data.creativeId
 * @param {String} data.bgImg
 * @param {String} data.clickThrough
 */
function _appendAd(domEl, data) {
  domEl.style.backgroundImage = 'url(' + viewUtils.getImageLink(data.bgImg) + ')';

  if (data.bgColor) {
    // Shouldn't know about parent - should find better approach
    domEl.parentNode.style.backgroundColor = (data.bgColor[0] === '#' ? '' : '#') + data.bgColor;
  }

  var image = document.createElement('a');
  image.classList.add('hpto-interactive');
  image.setAttribute('data-id', 'dfp-' + Date.now());

  domEl.appendChild(image);

  eventCenter.emit(eventTypes.AD_HPTO_RENDERED);

  setClickTracking(image, data);

  return data;
}

/**
 * @param  {HTMLElement} domEl
 * @param  {Object} data
 * @return {void}
 */
function setClickTracking(domEl, data) {
  domEl.addEventListener('click', onAdClick.bind(null, domEl, data));
}

/**
 * @param  {HTMLElement} domEl
 * @param  {Object} data
 * @param  {String} data.clickThrough
 * @param  {String} data.click
 */
function _onAdClick(domEl, data) {
  var url = data.clickThrough;

  utils.appendTrackingPixel(data.click, domEl);
  logClicked(data);

  if (/^http(s)?:\/\/(open|play)\.spotify\.com(.)*$/.test(url)) {
    var uri = URI.from(url);
    live('spotify:application').emit('replace-history-state', {
      uri: uri.toURI()
    });
  } else {
    window.open(url);
  }
}

/**
 * @param  {String} clickEvent
 * @param  {Object} data
 * @param  {String} data.bannerMode
 * @param  {String} data.lineItemId
 * @param  {String} data.creativeId
 * @return {void}
 */
function logClicked(data) {
  var message = {};
  message[adEventLogger.keys.EVENT] = 'event_clicked';
  message[adEventLogger.keys.AD_FORMAT] = 'hpto ' + data.bannerMode;
  message[adEventLogger.keys.LINE_ITEM_ID] = data.lineItemId;
  message[adEventLogger.keys.CREATIVE_ID] = data.creativeId;
  message[adEventLogger.keys.AD_ID] = data.creativeId;
  adEventLogger.log(message);
}

/**
 * @param  {Object} data
 * @param  {String} data.bannerMode
 * @param  {String} data.lineItemId
 * @param  {String} data.creativeId
 * @return {void}
 */
function logViewed(data) {
  var message = {};
  message[adEventLogger.keys.EVENT] = 'event_viewed';
  message[adEventLogger.keys.AD_FORMAT] = 'hpto ' + data.bannerMode;
  message[adEventLogger.keys.LINE_ITEM_ID] = data.lineItemId;
  message[adEventLogger.keys.CREATIVE_ID] = data.creativeId;
  message[adEventLogger.keys.AD_ID] = data.creativeId;

  adEventLogger.log(message);

  return data;
}

module.exports = ImageHptoView;

},{"../../../../../spotify-events/center":268,"../../../../../spotify-live":439,"../../../ad-event-logger":205,"../../../event-types":214,"../../../utils":249,"./view-utils":230,"lodash/curry":608,"spotify-liburi":707}],229:[function(require,module,exports){
'use strict';

var curry = require('lodash/curry');
var debug = require('debug')('saf:native-hpto-view');

var live = require('../../../../../spotify-live');
var eventCenter = require('../../../../../spotify-events/center');

var eventTypes = require('../../../event-types');
var adEventLogger = require('../../../ad-event-logger');
var utils = require('../../../utils');

var viewUtils = require('./view-utils');
var templates = require('../native-tpl');

var configuration = require('../../../configuration');

// Curried functions
var appendAd = curry(_appendAd);
var fireThirdPartyImp = curry(viewUtils.fireThirdPartyImp);
var onBtnClick = curry(_onBtnClick);
var appendHideBtn = curry(viewUtils.appendHideBtn);
var mergeProps = curry(_mergeProps);

var NativeHptoView = {};

/**
 * @param  {Object} opts
 * @param  {HTMLElement} opts.domEl
 * @param  {Object} opts.adData
 * @param  {String} opts.adData.targetUri
 * @param  {String} opts.adData.backgroundImage - sponsored playlist hpto only
 * @param  {String} opts.adData.badge
 * @param  {String} opts.adData.nativeHptoType
 * @param  {Boolean} opts.isPremium
 * @return {Promise}
 */
NativeHptoView.render = function (opts) {
  var adData = opts.adData;
  var domEl = opts.domEl;
  var isPremium = opts.isPremium;

  if (!utils.getProp('target uri', adData)) {
    throw new Error('[Native HPTO] Missing a target uri');
  }

  return getAttributes(adData).then(appendAd(domEl)).then(fireThirdPartyImp(domEl)).then(logViewed).then(appendHideBtn(domEl, isPremium)).catch(function (e) {
    // General render error
    debug(e);
    throw e;
  });
};

/**
 * @param  {Object} data
 * @return {Promise}
 */
function getAttributes(data) {
  var dfpProps = parseDfpProps(data);

  return NativeHptoView.getLiveProps(dfpProps.uri, dfpProps.type).then(mergeProps(dfpProps));
}

/**
 * @param  {Object} data
 * @param  {String} data.targetUri
 * @param  {String} data.backgroundImage
 * @param  {String} data.badge
 * @param  {String} data.blurb
 * @param  {String} data.nativeHptoType
 * @return {Object}
 */
function parseDfpProps(data) {
  var TYPE_LABELS = {
    'track': 'single',
    'album': 'album',
    'artist': 'artist',
    'playlist': 'playlist'
  };
  var props = {};

  props.uri = utils.getProp('target uri', data);
  props.playBtnUri = utils.getProp('play btn uri', data) || props.uri;
  props.type = utils.getType(props.uri);
  props.blurb = data.blurb;
  props.bgImage = utils.getProp('background image', data) || '';
  props.badgeType = data.badge.toLowerCase();
  props.typeLabel = typeLabel(props.badgeType) || TYPE_LABELS[props.type];

  return Object.assign({}, data, props);
}

function typeLabel(badge) {
  var label;

  switch (badge) {
    case 'exclusive':
      label = 'spotify exclusive';
      break;
    case 'spotlight':
      label = configuration.getSpotlightSvg();
      break;
  }

  return label;
}

/**
 * @param  {String} uri
 * @param  {String} uriType
 * @return {Promise}
 */
NativeHptoView.getLiveProps = function (uri, uriType) {
  var LIVE_QUERY_PARAMS = {
    'playlist': 'name, image, annotatedImage',
    'album': 'name, image, artists(name, uri)',
    'track': 'name, image, artists(uri)',
    'artist': 'name, image'
  };

  return new Promise(function (res, rej) {
    live(uri).query(LIVE_QUERY_PARAMS[uriType], function (err, data) {
      if (err) rej(err);

      for (var key in data) {
        if (!data[key]) {
          debug('Returned empty field for:', key);
        }
      }

      res(data);
    });
  });
};

function _mergeProps(dfpProps, liveProps) {
  var PLAYLIST_BG = 'http://i.scdn.co/image/03fa7db6aae8ffb4a936d0fe5a4f419199c313a9';
  var props = {};

  props.isVerified = !!(dfpProps.type === 'artist' && liveProps.name);
  props.name = liveProps.name;

  var preferredImage = liveProps.annotatedImage || liveProps.image;
  props.smallImageUri = preferredImage;
  props.backgroundImage = preferredImage;

  switch (dfpProps.type) {
    case 'track':
      props.attribution = liveProps.name;
      props.attributionUri = liveProps.artists[0].uri;
      break;
    case 'album':
      props.attribution = liveProps.artists[0].name;
      props.attributionUri = liveProps.artists[0].uri;
      break;
    case 'playlist':
      props.backgroundImage = dfpProps.bgImage || preferredImage || PLAYLIST_BG;
      break;
    default:
      console.error('Bad type: ' + dfpProps.type);
  }

  return Object.assign({}, dfpProps, props);
}

/**
 * @param  {HTMLElement} domEl
 * @param  {Object} data
 * @param  {String} data.nativeHptoType
 * @return {Object} data
 */
function _appendAd(domEl, data) {
  var tpl;

  switch (data.nativeHptoType) {
    case 'original':
      tpl = templates.nativeEl;
      break;
    case 'sponsored':
      tpl = templates.sponsored;
      break;
    default:
      throw new Error('Invalid hpto type: ' + data.nativeHptoType);
  }

  domEl.innerHTML = tpl(data);

  eventCenter.emit(eventTypes.AD_HPTO_RENDERED);

  setClickTracking(domEl, data);

  return data;
}

/**
 * @param {[type]} domEl [description]
 * @param {Object} data
 * @param {String} data.click
 */
function setClickTracking(domEl, data) {
  var playBtn = domEl.querySelector('#ne-play-button');
  var saveBtn = domEl.querySelector('#ne-save-button');
  var moreBtn = domEl.querySelector('#ne-more-button');
  var imageLink = domEl.querySelector('#ne-image-link');
  var nameLink = domEl.querySelector('#ne-name-link');
  var attribLink = domEl.querySelector('#ne-attrib-link');

  imageLink.addEventListener('click', onBtnClick('ne_image_link_clicked', data));

  nameLink.addEventListener('click', onBtnClick('ne_name_link_clicked', data));

  playBtn.addEventListener('click', function (e) {
    var btn = e.target.getAttribute('data-log-click').split('-')[0];
    onBtnClick('ne_' + btn + '_btn_clicked', data, e);
  });

  saveBtn.addEventListener('click', onBtnClick('ne_save_btn_clicked', data));

  moreBtn.addEventListener('click', onBtnClick('ne_more_btn_clicked', data));

  if (attribLink) {
    attribLink.addEventListener('click', onBtnClick('ne_attrib_link_clicked', data));
  }
}

/**
 * @param  {String} clickEvent
 * @param  {Object} data
 * @param  {String} data.click
 * @param  {MouseEvent} e
 * @return {void}
 */
function _onBtnClick(clickEvent, data, e) {
  utils.appendTrackingPixel(data.click, e.target);
  logClicked(clickEvent, data);
}

/**
 * @param  {String} clickEvent
 * @param  {Object} data
 * @param  {String} data.bannerMode
 * @param  {String} data.lineItemId
 * @param  {String} data.creativeId
 * @return {void}
 */
function logClicked(clickEvent, data) {
  var message = {};
  message[adEventLogger.keys.EVENT] = 'event_clicked';
  message[adEventLogger.keys.AD_FORMAT] = 'hpto ' + data.bannerMode;
  message[adEventLogger.keys.LINE_ITEM_ID] = data.lineItemId;
  message[adEventLogger.keys.CREATIVE_ID] = data.creativeId;
  message[adEventLogger.keys.AD_ID] = data.creativeId;
  message[adEventLogger.keys.JSONDATA] = JSON.stringify({ 'element_clicked': clickEvent });
  adEventLogger.log(message);

  debug('adEvent', clickEvent, data);
}

/**
 * @param  {Object} data
 * @param  {String} data.bannerMode
 * @param  {String} data.lineItemId
 * @param  {String} data.creativeId
 * @return {void}
 */
function logViewed(data) {
  var message = {};
  message[adEventLogger.keys.EVENT] = 'event_viewed';
  message[adEventLogger.keys.AD_FORMAT] = 'hpto ' + data.bannerMode;
  message[adEventLogger.keys.LINE_ITEM_ID] = data.lineItemId;
  message[adEventLogger.keys.CREATIVE_ID] = data.creativeId;
  message[adEventLogger.keys.AD_ID] = data.creativeId;

  adEventLogger.log(message);

  debug('adEvent log viewed');

  return data;
}

module.exports = NativeHptoView;

},{"../../../../../spotify-events/center":268,"../../../../../spotify-live":439,"../../../ad-event-logger":205,"../../../configuration":207,"../../../event-types":214,"../../../utils":249,"../native-tpl":224,"./view-utils":230,"debug":526,"lodash/curry":608}],230:[function(require,module,exports){
'use strict';

var eventCenter = require('../../../../../spotify-events/center');
var Preferences = require('../../../../../spotify-preferences');
var uiPref = new Preferences('ui');

var i18n = require('../../../../i18n');
var adEventLogger = require('../../../ad-event-logger');
var utils = require('../../../utils');
var AD_HPTO_HIDDEN = require('../../../event-types').AD_HPTO_HIDDEN;

var CDN_URL = 'http://d3rt1990lpmkn.cloudfront.net/unbranded/';

var viewUtils = {};

/**
 * @param {HTMLElement} domEl
 * @param {Object} data
 * @param {Object} data.trackingUrl
 * @return {Object} data
 */
viewUtils.fireThirdPartyImp = function (domEl, data) {
  var url = utils.getProp('tracking url', data);

  if (url) {
    utils.appendTrackingPixel(url, domEl);
  }

  return data;
};

/**
 * Returns a platform specific image URL
 * This returns a CDN URL when on web rather than the play.spotify.com URL
 * returned by .toSpotifyLink()
 *
 * @param  {String} param
 * @return {String}
 */
viewUtils.getImageLink = function (link) {
  if (/^[a-zA-Z0-9]{40}$/.test(link)) {
    link = 'spotify:image:' + link;
  } else if (!/^http(s)?:\/\/.*$/.test(link)) {
    link = CDN_URL + link;
  }

  return link;
};

/**
 * @param  {HTMLElement} domEl
 * @param  {Boolean} isPremium
 * @param  {Object} data
 * @param  {String} data.bannerMode
 * @param  {String} data.lineItemId
 * @param  {String} data.creativeId
 * @return {Object}
 */
viewUtils.appendHideBtn = function (domEl, isPremium, data) {
  // Don't show button for sponsored hptos
  if (!(utils.getProp('native hpto type', data) === 'sponsored')) {
    var hideBtn = createHideBtn(isPremium, data);

    if (isPremium) {
      hideBtn.addEventListener('click', onHideClick.bind(null, domEl, data));
    }

    domEl.appendChild(hideBtn);
  }

  return data;
};

/**
 * @param  {HTMLElement} domEl
 * @param  {Object} data
 * @param  {String} data.bannerMode
 * @param  {String} data.lineItemId
 * @param  {String} data.creativeId
 * @return {void}
 */
function onHideClick(domEl, data) {
  domEl.classList.add('hpto-closed');

  uiPref.set('hide_hpto', true);
  window.parent.sessionStorage['ui.hide_hpto'] = true;
  logCollapsed(data);

  eventCenter.emit(AD_HPTO_HIDDEN);
}

/**
 * @param  {Boolean} isPremium
 * @return {void}
 */
function createHideBtn(isPremium) {
  var hideBtn = document.createElement('span');
  hideBtn.classList.add('hpto-button');

  if (isPremium) {
    hideBtn.innerHTML = i18n.get('HideAnnouncements');
  } else {
    hideBtn.innerHTML = i18n.get('Sponsored');
    hideBtn.classList.add('no-hover');
  }

  return hideBtn;
};

/**
 * @param {Object} data
 * @param {String} data.bannerMode
 * @param {String} data.lineItemId
 * @param {String} data.creativeId
 */
function logCollapsed(data) {
  var message = {};
  message[adEventLogger.keys.EVENT] = 'event_collapsed';
  message[adEventLogger.keys.AD_FORMAT] = 'hpto ' + data.bannerMode;
  message[adEventLogger.keys.LINE_ITEM_ID] = data.lineItemId;
  message[adEventLogger.keys.CREATIVE_ID] = data.creativeId;
  message[adEventLogger.keys.AD_ID] = data.creativeId;

  adEventLogger.log(message);
}

module.exports = viewUtils;

},{"../../../../../spotify-events/center":268,"../../../../../spotify-preferences":486,"../../../../i18n":192,"../../../ad-event-logger":205,"../../../event-types":214,"../../../utils":249}],231:[function(require,module,exports){
'use strict';

exports.REFRESH_INTERVAL_KEY = 'leaderboard_refresh_interval';

exports.DEFAULT_REFRESH_INTERVAL_MS = 30000; // 30 seconds

exports.DEFAULT_CLOSE_LIFETIME_MS = 60 * 60 * 1000; // 1 hour

exports.DEFAULT_SANDBOX_PARAMS = ['allow-forms', 'allow-pointer-lock', 'allow-popups', 'allow-same-origin', 'allow-scripts'];

exports.LEADERBOARD_SLOT_ID = 'leaderboard';

},{}],232:[function(require,module,exports){
'use strict';

var constants = require('./CONSTANTS');

var eventTypes = require('../../event-types');

var debug = require('debug')('saf:leaderboard');

var slice = [].slice;

/**
 * Set the innerHTML property of the given node, and then locate and
 * execute all scripts in order, with the following caveats:
 *
 * 1. The scripts MUST be asynchronous
 * 2. The html MUST come from a first-party source, given the security concerns.
 *
 * @param {DOM} document DOM used to generate elements.
 * @param {Element} node Element which will have its innerHTML property set.
 * @param {String} html HTML content which may contain script tags.
 */
function setAndEvalTrustedHtml(doc, node, html) {
  node.innerHTML = html;
  var scripts = slice.apply(node.getElementsByTagName('script'));

  var srcs = scripts.filter(function (script) {
    return script.src;
  }).map(function (script) {
    return script.src;
  });

  srcs.forEach(function (src) {
    var newScript = doc.createElement('script');
    newScript.src = src;
    newScript.async = 1;
    node.appendChild(newScript);
  });

  var bodies = scripts.filter(function (script) {
    return !script.src;
  }).map(function (script) {
    return script.text;
  }).filter(function (text) {
    return text;
  });

  bodies.forEach(function (body) {
    var newScript = doc.createElement('script');
    newScript.text = body;
    node.appendChild(newScript);
  });
}

/**
 * Create an iframe with the given content and sandbox attributes
 *
 * @param {DOM} document
 * @param {String} html HTML to set as the content of the iframe.
 * @param {Array<String>} [sandboxParams] List of sandboxed parameters.
 *   A sensible secure default will be provided which will allow
 *   scripts and same origin, but not top navigation.
 *
 */
function iframeWithContent(document, html, sandboxParams) {
  sandboxParams = sandboxParams || constants.DEFAULT_SANDBOX_PARAMS;
  var iframe = document.createElement('iframe');
  iframe.sandbox = sandboxParams.join(' ');
  iframe.srcdoc = html;
  iframe.scrolling = 'no';
  return iframe;
}

/**
 * Render a leaderboard iframe in the provided container element.  The contents
 * of the container will be cleared, and standard styles/ids will be added to
 * the given iframe.
 * @param {DOM} document DOM object.
 * @param {Element} containerElement Element which will contain the leaderboard.
 * @param {Element} leaderboardElement Element with the rendered leaderboard
 *   contents.
 */
function renderLeaderboard(document, containerElement, leaderboardElement, width, height) {
  debug('renderLeaderboard', containerElement, leaderboardElement);
  containerElement.innerHTML = '';
  leaderboardElement.style.display = 'block';
  leaderboardElement.id = 'leaderboard-ad-element';
  if (width && height) {
    leaderboardElement.style.width = width + 'px';
    leaderboardElement.style.height = height + 'px';
    leaderboardElement.style.overflow = 'hidden';
  }
  var wrapper = document.createElement('div');
  wrapper.id = 'leaderboard-ad-wrapper';
  wrapper.appendChild(leaderboardElement);
  containerElement.appendChild(wrapper);
}

/**
 * Render a close button into the leaderboard container element.
 *
 * @param {DOM} doc The document object
 * @param {Element} containerElement The containing element for the leaderboard
 * @param {Function} onClose Event handler for when the close button is clicked
 * @param {Integer} [activeAfterMs] If provided, sets the "active" class on the
 *   close button after the given number of milliseconds.
 */
function renderCloseButton(doc, containerElement, onClose, activeAfterMs) {
  var closeContainer = doc.createElement('div');
  closeContainer.className = 'close-button-container';
  var button = doc.createElement('a');
  button.href = '#';
  if (activeAfterMs) {
    button.className = 'close';
    setTimeout(function () {
      button.className = 'close active';
    }, activeAfterMs);
  } else {
    button.className = 'close active';
  }
  button.setAttribute('aria-hidden', 'true');
  button.innerHTML = '&times;';
  button.addEventListener('click', onClose);
  closeContainer.appendChild(button);
  if (containerElement.firstChild) {
    containerElement.insertBefore(closeContainer, containerElement.firstChild);
  } else {
    containerElement.appendChild(closeContainer);
  }
}

/**
 * Subscribe to leaderboard preview requests delivered via cosmos, and render
 * into the provided DOM element.
 *
 * @param {CosmosConnector} cosmosConnector An instance of cosmos connector
 * @param {DOM} document Root document for generating elements
 * @param {Element} domElement Leaderboard DOM element for setting TA attributes
 * @param {Function} onPreview Executed after a preview has been injected.
 */
function subscribeToPreview(cosmosConnector, document, domElement, onPreview) {
  cosmosConnector.subscribeToFormat('banner', function (data) {
    if (data.ad.display && data.ad.display[0].width !== 728) {
      return;
    }
    var html = data.ad.display[0].media;
    var uri = data.ad.uri;
    var iframe = iframeWithContent(document, html);
    domElement.setAttribute('data-ta-preview-uri', uri);
    renderLeaderboard(document, domElement, iframe);
    onPreview();
  });
}

function logEvent(adEventLogger, eventType, jsonData, messageExtra) {
  var message = {};
  message[adEventLogger.keys.AD_FORMAT] = 'banner';
  message[adEventLogger.keys.SLOT] = constants.LEADERBOARD_SLOT_ID;
  message[adEventLogger.keys.EVENT] = eventType;
  if (jsonData) {
    message[adEventLogger.keys.JSONDATA] = JSON.stringify(jsonData);
  }
  if (messageExtra) {
    Object.assign(message, messageExtra);
  }
  return adEventLogger.log(message);
}

/**
 * Generates a handler for leaderboard messages generated by the code
 * injected into the leaderboard iframe.  These messages are expected to
 * have the following shape:
 * {
 *   data: {
 *     type: oneOf(
 *       'ads-leaderboard-failed',
 *       'ads-leaderboard-rendered',
 *       'ads-upgrade-account'
 *     ),
 *     data: {
 *       lineItemId: string,
 *       creativeId: string,
 *     },
 *     click: string,
 *   })
 * }
 *
 * @param {AdEventLogger} adEventLogger Used to log events in the backend.
 * @param {EventDispatcher} eventDispatcher Event dispatcher for UI rendering
 *   purposes.
 * @param {Element} domElement Container element of leaderboard, used to
 *   set attributes for TA systems tests.
 */
function leaderboardMessageHandler(adEventLogger, eventDispatcher, domElement) {
  var currentUuid = null;
  var onCleanup = null;

  var handler = function onLeaderboardMessage(e) {
    if (!e.data || !e.data.type) {
      return; // Not interested in the message
    }
    switch (e.data.type) {
      case 'ads-leaderboard-failed':
        debug('ads-leaderboard-failed: %o', e.data);

        eventDispatcher.dispatchEvent({
          type: eventTypes.AD_LEADERBOARD_PLACEMENT,
          params: {
            isEmpty: true
          }
        });

        logEvent(adEventLogger, 'event_errored', {
          dfp_returned_empty: true
        });
        break;

      case 'ads-leaderboard-rendered':
        debug('ads-leaderboard-rendered: %o', e.data);
        var messageExtra = {};
        messageExtra[adEventLogger.keys.LINE_ITEM_ID] = e.data.data.lineItemId;
        messageExtra[adEventLogger.keys.CREATIVE_ID] = e.data.data.creativeId;
        messageExtra[adEventLogger.keys.AD_ID] = e.data.data.creativeId;
        logEvent(adEventLogger, 'event_viewed', null, messageExtra).then(function (data) {
          debug('Banner impression logged!', data);
        });

        domElement.setAttribute('data-ta-rendered-at', new Date().getTime());
        domElement.setAttribute('data-ta-creative-id', e.data.data.creativeId);
        domElement.setAttribute('data-ta-line-item-id', e.data.data.lineItemId);

        eventDispatcher.dispatchEvent({
          type: eventTypes.AD_LEADERBOARD_PLACEMENT,
          params: {
            isEmpty: false
          }
        });
        break;

      case 'ads-upgrade-account':
        debug('ads-upgrade-account: %o', e.data);
        var match = e.data.click.match(/\?(.*)$/);
        var params = match && match[1] ? match[1] : '';
        eventDispatcher.dispatchEvent({
          type: eventTypes.NAVIGATION_UPGRADE,
          params: {
            tracking: params
          }
        });
        break;

      case 'spotify:ad:leaderboard:cleanup:done':
        onCleanup && onCleanup(e.data);
        break;

      case 'spotify:ad:leaderboard:init':
        // Note: we assume that there will only be one leaderboard initialized at
        // any given moment.  If this changes, we will want to keep track of all
        // initialized uuids and use the appropriate uuid on the cleanup routine.
        currentUuid = e.data.uuid;
        break;

      default:
        break;
    }
    if (e.data.type.match(/spotify:ad:leaderboard/)) {
      debug('Received leaderboard message: %o', e.data);
    }
  };

  handler.cleanup = function (leaderboardWindow, timeoutMs) {
    if (!currentUuid) {
      return Promise.resolve(true);
    }
    var cleanupDone = false;
    return Promise.race([new Promise(function (resolve) {
      onCleanup = function onCleanup(eventData) {
        if (eventData.uuid === currentUuid) {
          cleanupDone = true;
          resolve(true);
        }
      };
      debug('sending cleanup message to leaderboard with uuid: ' + currentUuid);
      leaderboardWindow.postMessage({
        uuid: currentUuid,
        type: 'spotify:ad:leaderboard:cleanup'
      }, '*');
    }), new Promise(function (resolve) {
      setTimeout(function () {
        if (currentUuid && !cleanupDone) {
          debug('warning: timed out on cleanup routine after ' + timeoutMs + 'ms');
        }
        resolve(true);
      }, timeoutMs);
    })]);
  };

  return handler;
}

module.exports = {
  iframeWithContent: iframeWithContent,
  renderLeaderboard: renderLeaderboard,
  renderCloseButton: renderCloseButton,
  setAndEvalTrustedHtml: setAndEvalTrustedHtml,
  subscribeToPreview: subscribeToPreview,
  leaderboardMessageHandler: leaderboardMessageHandler,
  logEvent: logEvent
};

},{"../../event-types":214,"./CONSTANTS":231,"debug":526}],233:[function(require,module,exports){
'use strict';

var eventDispatcher = require('../../../../spotify-event-dispatcher');
var eventTypes = require('../../event-types');

var CosmosConnector = require('../../cosmos-connector');
var cosmosConnector = new CosmosConnector();

var targeter = require('../../targeter');
var session = require('../../session');
var adEventLogger = require('../../ad-event-logger');
var adFeedbackButton = require('../../ad-feedback-button');
var utils = require('../../utils');

var LEADERBOARD_SLOT_ID = require('./CONSTANTS').LEADERBOARD_SLOT_ID;

var dfp = require('../../dfp');
var DEFAULT_LEADERBOARD_REFRESH_INTERVAL = 30000;

var LeaderboardAd = {};

LeaderboardAd.create = function (el) {
  var state = {
    INVENTORY_TYPE: 'banner',
    HEIGHT: 90,
    WIDTH: 728,
    el: el,
    timer: null,
    refreshInterval: DEFAULT_LEADERBOARD_REFRESH_INTERVAL,
    inventoryUnit: '',
    platform: session.get().platform
  };

  var instance = {};

  /**
   * Enable the leaderboard component inside the container.
   * @return {Promise}
   */
  instance.enable = function () {
    subscribeToPreviewUri(state.INVENTORY_TYPE, state.el);

    eventDispatcher.addEventListener(eventTypes.DEBUG_FORCE_REFRESH_LEADERBOARD, function () {
      instance.disable();
      instance.enable();
    });

    instance.enableRefresh();

    return instance._render();
  };

  /**
   * Disable the leaderboard component
   * @return void
   */
  instance.disable = function () {
    window.removeEventListener('message', handleHouseAdMessage);
    instance.removeContent();
    instance.disableRefresh();
  };

  /**
   * Clear container innerHTML
   * @return {void}
   */
  instance.removeContent = function () {
    state.el.innerHTML = '';
  };

  /**
   * Enable refreshing of leaderboard
   * @return {void}
   */
  instance.enableRefresh = function () {
    window.clearInterval(state.timer);
    state.timer = window.setInterval(instance._render, state.refreshInterval);
    console.log('scheduled timer', state.timer, 'for interval', state.refreshInterval);
  };

  /**
   * Disable refreshing of leaderboard
   * @return {void}
   */
  instance.disableRefresh = function () {
    if (state.timer) {
      window.clearInterval(state.timer);
      state.timer = null;
    }
  };

  /**
   * Test helper to check internal state of instance
   * @private
   * @param {String} key - key in state obj
   * @return {any}
   */
  instance._get = function (key) {
    return state[key];
  };

  /**
   * Test helper to check internal state of instance
   * @private
   * @param {String} value - value to set
   * @param {String} key - key in state obj
   * @return {void}
   */
  instance._set = function (value, key) {
    state[key] = value;
  };

  /**
   * Wrapper for getting targeting and rendering ad
   * @private (Exposed only for testing)
   * @return {Promise}
   */
  instance._render = function () {
    var inventoryUnit = dfp.inventoryUnit(state.platform, false);

    return targeter.getTargeting(inventoryUnit).then(updateRefreshInterval).then(appendTargetingData).then(function (data) {
      var iframe = utils.createSandboxedIframe();
      iframe.style.display = 'none';

      instance._renderView({
        i: iframe,
        gpt: dfp.renderGPT(data)
      });
    });
  };

  /**
   * @private (Exposed only for testing)
   * @param {Object} opt
   * @param {HTMLElement} opt.i - iframe
   * @param {String} opt.gpt - gpt string
   */
  instance._renderView = function (opt) {
    var iframe = opt.i;

    buildView(iframe, opt.gpt, state.el);

    var iframeDoc = iframe.contentDocument;

    iframeDoc.addEventListener('placementReady', function () {
      // Grab details about the line item, creative id, and slot
      var impressionData = iframe.contentWindow.slotRenderEndedObj;

      deleteOldLeaderboard(state.el);

      iframeDoc.body.style.overflow = 'hidden';
      iframe.style.display = 'block';

      logViewed(impressionData);

      attachAdFeedbackButton(impressionData, state.el);

      dispatchPlacementEvent(false);
    });

    iframeDoc.addEventListener('eventEmpty', function () {
      dispatchPlacementEvent(true);
      logError();
    });
  };

  function updateRefreshInterval(data) {
    var REFRESH_KEY = 'leaderboard_refresh_interval';
    var targetingInterval = data.targetingData[REFRESH_KEY];

    if (targetingInterval && state.refreshInterval !== targetingInterval) {
      state.refreshInterval = targetingInterval;
    }

    return data;
  }

  function appendTargetingData(data) {
    return Object.assign({}, data, {
      inventoryType: state.INVENTORY_TYPE,
      width: state.WIDTH,
      height: state.HEIGHT
    });
  }

  /**
   * Listen for post message from leaderboard creative template
   * and dispatch event to router for login token in order to be
   * autologged in on spotify website
   */
  window.addEventListener('message', handleHouseAdMessage, false);

  return instance;
};

/**
 * Listen for and render preview uris
 * @private
 * @return {void}
 */
function subscribeToPreviewUri(inventoryType, domEl) {
  cosmosConnector.subscribeToFormat(inventoryType, function (data) {
    // Only handle leaderboard previews
    if (data.ad.display && data.ad.display[0].width !== 728) return;

    var jsonAd, iframe;

    jsonAd = data.ad.display[0];
    iframe = utils.createSandboxedIframe();

    domEl.innerHTML = '';

    buildView(iframe, jsonAd.media, domEl);

    iframe.style.display = 'block';
  });
}

/**
 * Parse url params and dispatches event to router
 * @private
 * @return {void}
 */
function handleHouseAdMessage(e) {
  if (e.data && e.data.type === 'ads-upgrade-account') {
    var url = e.data.click;
    var params = url.match(/\?(.*)$/)[1];

    eventDispatcher.dispatchEvent({
      type: eventTypes.NAVIGATION_UPGRADE,
      params: { tracking: params }
    });
  }
}

function buildView(iframe, content, domEl) {
  var divWrapper, iframeDoc;

  iframe.id = 'leaderboard-ad-element';

  divWrapper = document.createElement('div');
  divWrapper.id = 'leaderboard-ad-wrapper';
  divWrapper.appendChild(iframe);
  domEl.appendChild(divWrapper);

  iframeDoc = iframe.contentDocument;
  iframeDoc.open();
  iframeDoc.write(content);
  iframeDoc.close();
};

/**
 * @private
 * @param {Object} props
 * @param {String} props.lineItemId
 * @param {String} props.creativeId
 */
function logViewed(props) {
  var message = {};
  message[adEventLogger.keys.AD_FORMAT] = 'banner';
  message[adEventLogger.keys.EVENT] = 'event_viewed';
  message[adEventLogger.keys.SLOT] = LEADERBOARD_SLOT_ID;
  message[adEventLogger.keys.LINE_ITEM_ID] = props.lineItemId;
  message[adEventLogger.keys.CREATIVE_ID] = props.creativeId;
  message[adEventLogger.keys.AD_ID] = props.creativeId;

  adEventLogger.log(message);
}

/**
 * @private
 */
function logError() {
  var message = {};
  message[adEventLogger.keys.AD_FORMAT] = 'banner';
  message[adEventLogger.keys.EVENT] = 'event_errored';
  message[adEventLogger.keys.SLOT] = LEADERBOARD_SLOT_ID;
  message[adEventLogger.keys.JSONDATA] = JSON.stringify({
    'dfp_returned_empty': true
  });
  adEventLogger.log(message);
}

function attachAdFeedbackButton(data, domEl) {
  adFeedbackButton.checkFeatureFlag().then(function () {
    adFeedbackButton(data.creativeId).appendTo(domEl);
  }).catch(function () {});
}

function dispatchPlacementEvent(isEmpty) {
  eventDispatcher.dispatchEvent({
    type: eventTypes.AD_LEADERBOARD_PLACEMENT,
    params: { isEmpty: isEmpty }
  });
}

/**
  * If there is more than 1 existing leaderboard wrapper div, delete older ones
  * @private
  * @return void
  */
function deleteOldLeaderboard(domEl) {
  var len;

  if (domEl.children.length > 1) {
    len = domEl.children.length - 1;

    for (len; len > 0; len--) {
      domEl.removeChild(domEl.children[0]);
    }
  }
}

module.exports = LeaderboardAd;

},{"../../../../spotify-event-dispatcher":264,"../../ad-event-logger":205,"../../ad-feedback-button":206,"../../cosmos-connector":208,"../../dfp":211,"../../event-types":214,"../../session":246,"../../targeter":248,"../../utils":249,"./CONSTANTS":231}],234:[function(require,module,exports){
'use strict';

var eventDispatcher = require('../../../../spotify-event-dispatcher');

var CosmosConnector = require('../../cosmos-connector');

var NETWORK_ID = require('../../dfp').NETWORK_ID;

var adEventLogger = require('../../ad-event-logger');

var constants = require('./CONSTANTS');
var leaderboardUtil = require('./util');

var REFRESH_INTERVAL_KEY = constants.REFRESH_INTERVAL_KEY;
var DEFAULT_REFRESH_INTERVAL = constants.DEFAULT_REFRESH_INTERVAL_MS;
var TEMPLATE_URL = 'http://d5ecgvacntsb3.cloudfront.net/gpt/leaderboard/v6.html';

/**
 * Version 2 of the leaderboard ad that loads the ads from a
 * separate domain to get the properly sandboxed.
 *
 * @api public
 * @param {String} spotletName Deprecated..
 * @param {Element} domElement
 */

function LeaderboardAdV2(spotletName, domElement) {
  this.domElement = domElement;
  this.cosmosConnector = new CosmosConnector();
  this.refreshInterval = DEFAULT_REFRESH_INTERVAL;
  this.refreshTimer = undefined;

  this.onLeaderboardMessage = leaderboardUtil.leaderboardMessageHandler(adEventLogger, eventDispatcher, domElement);

  this.renderNext = this.renderNext.bind(this);

  // Subscribe to preview events from core
  leaderboardUtil.subscribeToPreview(this.cosmosConnector, document, this.domElement, this.disableRefresh.bind(this));
}

/**
 * Enable the leaderboard component inside the container.
 *
 * @api public
 */
LeaderboardAdV2.prototype.enable = function () {
  window.addEventListener('message', this.onLeaderboardMessage);
  this.enableRefresh();
  this.renderNext();
};

/**
 * Disable the leaderboard component inside the container.
 *
 * @api public
 */

LeaderboardAdV2.prototype.disable = function () {
  window.removeEventListener('message', this.onLeaderboardMessage);
  this.disableRefresh();
  this.removeContent();
};

/**
 * Enabled refreshing the ad.
 *
 * @api public
 */

LeaderboardAdV2.prototype.enableRefresh = function () {
  this.disableRefresh();
  this.refreshTimer = window.setInterval(this.renderNext, this.refreshInterval);
};

/**
 * Disable refreshing the ad.
 *
 * @api public
 */
LeaderboardAdV2.prototype.disableRefresh = function () {
  window.clearInterval(this.refreshTimer);
};

/**
 * Clear the content.
 *
 * @api public
 */

LeaderboardAdV2.prototype.removeContent = function () {
  this.domElement.innerHTML = '';
};

/**
 * Fetch targeting parameters and render the iframe that loads gpt that
 * fetches and renders an ad.
 *
 * @api private
 * @return {Promise}
 */

LeaderboardAdV2.prototype.renderNext = function () {
  var self = this;
  return this.cosmosConnector.getTargeting().then(function (targeting) {
    // Refresh interval is sometimes passed as a targeting parameter
    if (targeting.hasOwnProperty(REFRESH_INTERVAL_KEY)) {
      self.refreshInterval = parseInt(targeting[REFRESH_INTERVAL_KEY], 10);
      delete targeting[REFRESH_INTERVAL_KEY];
    }

    // Parameters to pass to the iframe
    var parameters = {
      inventoryUnit: '/' + NETWORK_ID + '/html5_desktop',
      targeting: targeting
    };

    var sandboxParams = constants.DEFAULT_SANDBOX_PARAMS;

    var hash = encodeURIComponent(JSON.stringify(parameters));

    var iframe = document.createElement('iframe');
    iframe.src = TEMPLATE_URL + '#' + hash;
    iframe.sandbox = sandboxParams.join(' ');
    self.render(iframe);
  });
};

/**
 * Render an iframe with given src attribute.
 *
 * @api private
 * @param {Element} iframe The iframe that will render the ad.
 */

LeaderboardAdV2.prototype.render = function (iframe) {
  leaderboardUtil.renderLeaderboard(document, this.domElement, iframe);
};

module.exports = LeaderboardAdV2;

},{"../../../../spotify-event-dispatcher":264,"../../ad-event-logger":205,"../../cosmos-connector":208,"../../dfp":211,"./CONSTANTS":231,"./util":232}],235:[function(require,module,exports){
'use strict';

var eventDispatcher = require('../../../../spotify-event-dispatcher');

var CosmosConnector = require('../../cosmos-connector');
var adEventLogger = require('../../ad-event-logger');

var constants = require('./CONSTANTS');
var leaderboardUtil = require('./util');
var eventTypes = require('../../event-types');

var debug = require('debug')('saf:leaderboard');

var DEFAULT_AD_WIDTH = 728;
var DEFAULT_AD_HEIGHT = 90;

/**
 * Version 3 of the leaderboard ad, which makes hm://ads/ requests
 * to retrieve configuration details and display ads.
 */
function LeaderboardAdV3(domElement) {
  debug('init leaderboard v3');
  this.domElement = domElement;
  this.cosmosConnector = new CosmosConnector();
  this.refreshInterval = constants.DEFAULT_REFRESH_INTERVAL_MS;
  this.sandboxParams = constants.DEFAULT_SANDBOX_PARAMS;
  this.appBlacklist = null;
  this.appWhitelist = null;
  this.refreshTimer = undefined;
  this.closeLifetimeMs = constants.DEFAULT_CLOSE_LIFETIME_MS;

  this.onLeaderboardMessage = leaderboardUtil.leaderboardMessageHandler(adEventLogger, eventDispatcher, domElement);

  eventDispatcher.addEventListener(eventTypes.DEBUG_OVERRIDE_AD_LEADERBOARD_HTML, function (e) {
    this._overrideAdHtml = e.params.html;
  }.bind(this));
  eventDispatcher.addEventListener(eventTypes.DEBUG_FORCE_REFRESH_LEADERBOARD, function () {
    this.disable();
    this.enable();
  }.bind(this));

  this.renderNext.bound = this.renderNext.bind(this);

  // Subscribe to preview events from core
  leaderboardUtil.subscribeToPreview(this.cosmosConnector, document, this.domElement, this.disableRefresh.bind(this));

  // Used to defer enable() of leaderboard that is waiting to cleanup.
  this._cleanupGate = Promise.resolve(true);
}

/**
 * Enable the leaderboard component inside the container.
 *
 * @api public
 */
LeaderboardAdV3.prototype.enable = function () {
  if (this._disabling) {
    return Promise.reject(new Error('cannot enable while disabling leaderboard'));
  }
  if (this._closed) {
    return Promise.reject(new Error('cannot enable while leaderbard in a closed state'));
  }
  debug('enable leaderboard');
  this._enabled = true;
  return this._cleanupGate.then(function () {
    if (this._enabled) {
      window.addEventListener('message', this.onLeaderboardMessage);
      this.enableRefresh();
      return this.renderNext();
    }
  }.bind(this));
};

/**
 * Disable the leaderboard component inside the container.
 * @return Promise resolving when disabling is complete.
 * @api public
 */
LeaderboardAdV3.prototype.disable = function () {
  debug('disable leaderboard');
  this._enabled = false;
  this.disableRefresh();
  this._disabling = true;
  return this.removeContent().then(function () {
    this._disabling = false;
    window.removeEventListener('message', this.onLeaderboardMessage);
  }.bind(this));
};

/**
 * Enable refreshing the ad, for example, if the user is in focus.
 *
 * @api public
 */
LeaderboardAdV3.prototype.enableRefresh = function () {
  this.disableRefresh();
  debug('set refresh interval: ' + this.refreshInterval);
  this.refreshTimer = window.setInterval(this.renderNext.bound, this.refreshInterval);
};

/**
 * Disable refreshing the ad.
 *
 * @api public
 */
LeaderboardAdV3.prototype.disableRefresh = function () {
  window.clearInterval(this.refreshTimer);
};

LeaderboardAdV3.prototype.onClose = function () {
  this._closed = true;
  debug('closing for %o ms', this.closeLifetimeMs);
  setTimeout(function () {
    this._closed = false;
  }.bind(this), this.closeLifetimeMs);
  leaderboardUtil.logEvent(adEventLogger, 'event_closed', {
    closeLifetimeMs: this.closeLifetimeMs
  });
  return this.disable();
};

/**
 * Clear the content.
 *
 * @return Promise resolving when removing the content is complete.
 * @api public
 */
LeaderboardAdV3.prototype.removeContent = function () {
  debug('removeContent');
  return this.cleanup().then(function () {
    debug('clearInnerHTML');
    this.domElement.innerHTML = '';
  }.bind(this));
};

/**
 * Perform cleanup operations on a leaderboard which will be imminently removed.
 *
 * @return Promise resolving when cleanup operation is complete.  This may be immediately
 *   invoked on the job queue if the cleanup_timeout_ms value was never provided by
 *   the backend.
 */
LeaderboardAdV3.prototype.cleanup = function () {
  if (this._cleanup_timeout_ms) {
    this._cleanupGate = this.onLeaderboardMessage.cleanup(window, this._cleanup_timeout_ms);
  }
  return this._cleanupGate;
};

/**
 * Handle the config response from spotify-ad-service
 *
 * @api private
 */
LeaderboardAdV3.prototype.handleConfig = function (config) {
  if (config.request_when && config.request_when.focus_time_elapsed_ms) {
    this.refreshInterval = config.request_when.focus_time_elapsed_ms;
    this.enableRefresh();
  }
  if (config.iframe_sandboxed_attrs) {
    this.sandboxParams = config.iframe_sandboxed_attrs;
  }
  if (config.app_blacklist) {
    this.appBlacklist = config.app_blacklist;
  }
  if (config.app_whitelist) {
    this.appWhitelist = config.app_whitelist;
  }
  if (config.close_lifetime_ms) {
    var closeLifetimeMs = parseInt(config.close_lifetime_ms, 10);
    if (closeLifetimeMs) {
      this.closeLifetimeMs = closeLifetimeMs;
    }
  }
};

/**
 * Fetch targeting parameters and render the iframe that loads gpt that
 * fetches and renders an ad.
 *
 * @api private
 * @return {Promise}
 */
LeaderboardAdV3.prototype.renderNext = function () {
  var self = this;
  this._renderIter = this._renderIter || 0;
  var renderIter = ++this._renderIter;
  return this.cosmosConnector.getAdSlotConfig(constants.LEADERBOARD_SLOT_ID).then(function (config) {
    self.handleConfig(config);
    debug('received config', config);
  }).catch(function (e) {
    var mesg = e.message ? e.message : String(e);
    adEventLogger.logError('leaderboard:on:config', mesg);
    debug('renderNext:config error: ' + mesg);
  }).then(function () {
    return self.cosmosConnector.getAdForSlot(constants.LEADERBOARD_SLOT_ID);
  }).then(function (ad) {
    debug('received ad', ad);
    if (!self._enabled) {
      throw new Error('leaderboard-unit-disabled');
    }
    // If renderNext has been called again before the final render, discard
    // this ad as being expired.
    if (self._renderIter !== renderIter) {
      throw new Error('leaderboard-expired');
    }
    if (ad.cleanup_timeout_ms) {
      self._cleanup_timeout_ms = ad.cleanup_timeout_ms;
    }

    var adDisplay = ad.display.filter(function (display) {
      return display.mimetype === 'text/html';
    })[0];

    var metadata = ad.metadata || {};
    var closeableAfterMs = metadata.closeable_after_ms ? parseInt(metadata.closeable_after_ms, 10) : null;

    var html = adDisplay ? adDisplay.media_file : ad.html;
    var width = adDisplay ? adDisplay.width : DEFAULT_AD_WIDTH;
    var height = adDisplay ? adDisplay.height : DEFAULT_AD_HEIGHT;

    if (!html) {
      throw new Error("ad has no html");
    }

    if (ad.same_frame) {
      self.renderSameFrameAd(html, width, height, closeableAfterMs);
    } else {
      self.render(leaderboardUtil.iframeWithContent(document, self._overrideAdHtml || html, self.sandboxParams), width, height, closeableAfterMs);
    }

    eventDispatcher.dispatchEvent({
      type: eventTypes.DEBUG_RECEIVED_AD_LEADERBOARD_HTML,
      params: { html: ad.html },
      extra: {}
    });
  }).catch(function (e) {
    var mesg = e.message ? e.message : String(e);
    adEventLogger.logError('leaderboard:on:ad', mesg);
    debug('renderNext error: ' + mesg);
    throw e;
  });
};

/**
 * Render an ad in the top-level frame
 */
LeaderboardAdV3.prototype.renderSameFrameAd = function (html, width, height, closeableAfterMs) {
  this.cleanup().then(function () {
    var leaderboardDiv = document.createElement('div');
    this.render(leaderboardDiv, width, height, closeableAfterMs);
    leaderboardUtil.setAndEvalTrustedHtml(document, leaderboardDiv, this._overrideAdHtml || html);
  }.bind(this));
};

/**
 * Render an iframe with given src attribute.
 *
 * @api private
 * @param {Element} node The DOM element containing the leaderboard
 * @param {Integer} width The styled width of the generated ad element
 * @param {Integer} width The styled height of the generated ad element
 * @param {Integer} [closeableAfterMs] If set, will render a close button
 */
LeaderboardAdV3.prototype.render = function (node, width, height, closeableAfterMs) {
  debug('render');
  leaderboardUtil.renderLeaderboard(document, this.domElement, node, width, height);
  if (closeableAfterMs) {
    leaderboardUtil.renderCloseButton(document, this.domElement, this.onClose.bind(this), closeableAfterMs);
  }
};

module.exports = LeaderboardAdV3;

},{"../../../../spotify-event-dispatcher":264,"../../ad-event-logger":205,"../../cosmos-connector":208,"../../event-types":214,"./CONSTANTS":231,"./util":232,"debug":526}],236:[function(require,module,exports){
'use strict';

var debug = require('debug')('saf:sponsored-playlist');

var CosmosConnector = require('../../cosmos-connector');
var eventTypes = require('../../event-types');
var template = require('./logo-template.hbs');

var i18n = require('../../../i18n');

var cosmosConnector = new CosmosConnector();
var adEventLogger = require('../../ad-event-logger');
var utils = require('../../utils');

var SponsoredPlaylist = {};

/**
 * @private
 * @param {Object} props
 * @param {String} props.lineItemId
 * @param {String} props.creativeId
 */
function logClicked(props) {
  var message = {};
  message[adEventLogger.keys.AD_FORMAT] = 'sponsored playlist';
  message[adEventLogger.keys.EVENT] = 'event_clicked';
  message[adEventLogger.keys.LINE_ITEM_ID] = props.lineItemId;
  message[adEventLogger.keys.CREATIVE_ID] = props.creativeId;
  message[adEventLogger.keys.AD_ID] = props.creativeId;

  adEventLogger.log(message);
  debug('logClicked message=%o', message);
}

/**
 * @private
 * @param  {String} reason
 */
function logError(reason) {
  var message = {};
  message[adEventLogger.keys.AD_FORMAT] = 'sponsored playlist';
  message[adEventLogger.keys.EVENT] = 'event_errored';
  message[adEventLogger.keys.JSONDATA] = JSON.stringify({
    reason: reason
  });

  adEventLogger.log(message);
  debug('logError message=%o', message);
}

/**
 * @private
 * @param {Object} props
 * @param {String} props.lineItemId
 * @param {String} props.creativeId
 */
function logViewed(props) {
  var message = {};
  message[adEventLogger.keys.AD_FORMAT] = 'sponsored playlist';
  message[adEventLogger.keys.EVENT] = 'event_viewed';
  message[adEventLogger.keys.LINE_ITEM_ID] = props.lineItemId;
  message[adEventLogger.keys.CREATIVE_ID] = props.creativeId;
  message[adEventLogger.keys.AD_ID] = props.creativeId;

  adEventLogger.log(message);
  debug('logViewed message=%o', message);
}

/**
 * @private
 * @param {Object} props
 * @param {String} props.clickTracking
 * @param {String} props.clickThrough
 * @param {String} props.logoUrl
 * @param {String} props.impression
 * @param {String} props.thirdPartyImpression
 * @param {String} props.creativeId
 * @param {String} props.lineItemId
 * @return {HTMLElement} el
 */
function createLogoEl(props) {
  var el = document.createElement('div');

  el.className = 'sponsored-logo';

  el.innerHTML = template({
    clickSrc: props.clickThrough,
    logoSrc: props.logoUrl,
    impSrc: props.impression,
    thirdPartyImpSrc: props.thirdPartyImpression
  });

  el.addEventListener('click', function () {
    logClicked(props);
    utils.appendTrackingPixel(props.clickTracking, el);
    debug('Logo clicked');
  });

  return el;
}

/**
 * @private
 * @param {HTMLElement} container
 * @param {Object} props
 * @param {String} props.lineItemId
 * @param {String} props.creativeId
 * @param {String} props.clickTracking
 * @param {String} props.clickThrough
 * @param {String} props.label
 * @param {String} props.logoUrl
 * @param {String} props.impression
 * @param {String} props.thirdPartyImpression
 * @param {String} props.advertiserName
 * @return {Object} sponsoredPlaylist
 */
function create(_props) {
  var sponsoredPlaylist = {};
  var props = parseProps(_props);
  var logoEl = createLogoEl(props);
  var hasStarted = false;

  sponsoredPlaylist.appendLogoTo = function (el) {
    if (!hasStarted) {
      hideLeaderboard();
      logViewed(props);
      debug('active');
      logoEl.classList.add('fade-in');
    } else {
      logoEl.classList.remove('fade-in');
    }

    el.appendChild(logoEl);

    hasStarted = true;
    return sponsoredPlaylist;
  };

  sponsoredPlaylist.getLabel = function () {
    return props.label;
  };

  return sponsoredPlaylist;
};

/**
 * @param  {Object} opts
 * @param  {String} opts.uri
 * @return {Promise}
 */
SponsoredPlaylist.fetch = function (opts) {
  var uri = opts.uri;
  debug('fetch on uri=%o', uri);

  return cosmosConnector.getSponsoredUris().then(function (res) {
    debug('sponsored uri response=%o', res);
    if (!checkIfSponsored(uri, res.sponsorships)) {
      debug('Playlist not sponsored');
      return false;
    }

    return cosmosConnector.getSponsorshipAd(uri).then(create).catch(logError.bind(null, 'ad_failed_to_retrieve'));
  });
};

/**
 * @param  {Function} cb
 * @return {void}
 */
SponsoredPlaylist.subscribeToPreviewUri = function (cb) {
  cosmosConnector.subscribeToFormat('banner', function (data) {
    // Only handle leaderboard previews
    if (data.ad.display && data.ad.display[0].width !== 300) return;

    var regex = /\{(.|\s)+\}/;

    var adData = JSON.parse(data.ad.display[0].media.match(regex)[0]).sponsoredPlaylist;

    var sponsorship = create(Object.assign({}, adData, { logoUrl: adData.logo }));

    cb(sponsorship);
  });
};

/**
 * Check uri
 * @param  {String}   uri
 * @param  {Object[]} sponsorships
 * @return {Boolean}
 */
function checkIfSponsored(uri, sponsorships) {
  var time = Date.now() / 1000;

  return sponsorships.some(function (sponsorship) {
    var endTime = sponsorship.endTime || time + 1;

    return sponsorship.spotifyUri === uri && time >= sponsorship.startTime && time < endTime;
  });
}

function hideLeaderboard() {
  // todo revisit this
  debug('hideLeaderboard');
  window.parent.postMessage({ type: eventTypes.AD_SPONSORSHIP_ACTIVE }, 'http://zlink.app.spotify.com');
}

function parseProps(props) {
  return {
    lineItemId: props.lineItemId,
    creativeId: props.creativeId,
    clickTracking: props.clickTracking,
    clickThrough: props.clickThrough,
    logoUrl: props.logoUrl,
    impression: props.impression,
    thirdPartyImpression: props.thirdPartyImpression,
    advertiserName: props.advertiserName,
    label: [i18n.get('PresentedBy'), props.advertiserName].join(' ')
  };
}

module.exports = SponsoredPlaylist;

},{"../../../i18n":192,"../../ad-event-logger":205,"../../cosmos-connector":208,"../../event-types":214,"../../utils":249,"./logo-template.hbs":237,"debug":526}],237:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, functionType="function", escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {

  var buffer = "", stack1, helper;
  buffer += "\n  <img class=\"3p-imp-pixel\" style=\"display:none;width:1px;height:1px;\" src=\"";
  if (helper = helpers.thirdPartyImpSrc) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.thirdPartyImpSrc); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" />\n";
  return buffer;
  }

  buffer += "<a href=\"";
  if (helper = helpers.clickSrc) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.clickSrc); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\">\n  <img src=\"";
  if (helper = helpers.logoSrc) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.logoSrc); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" />\n</a>\n  <img class=\"imp-pixel\" style=\"display:none;width:1px;height:1px;\" src=\"";
  if (helper = helpers.impSrc) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.impSrc); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" />\n";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.thirdPartyImpSrc), {hash:{},inverse:self.noop,fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n";
  return buffer;
  });

},{"hbsfy/runtime":563}],238:[function(require,module,exports){
(function (global){
'use strict';

var debug = require('debug')('saf:video:view');
var SPVideoManager = require('../../../../spotify-video-manager');
var VastEvents = require('../../vast-events');
var EventLogger = require('../../event-logger').EventLogger;
var MoatLogger = require('../../moat-logger');
var videoUtils = require('../../video-utils');
var template = require('./template.hbs');
var EventEmitter = require('events').EventEmitter;

var STARTED = 'STARTED';
var DESTROYING = 'DESTROYING';
var DESTROYED = 'DESTROYED';

var BUFFERING_FAIL_TIMEOUT = 5000;
var FAILURE_BUFFER_TIMEOUT = 'video_error_buffer_timeout';
var FAILURE_NOT_IN_FOCUS = 'video_error_not_in_focus';
var FAILURE_GENERAL = 'video_error_general_error';

var maxContainer = null;
var minContainer = null;

var isBetamaxEnabled = global.__spotify && global.__spotify.product_state && global.__spotify.product_state['ad-betamax-video'] === '1';

debug('isBetamaxEnabled: %o', isBetamaxEnabled);
var isBetamaxFlatEnabled = global.__spotify && global.__spotify.product_state && global.__spotify.product_state['ad-betamax-flat-video'] === '1';

debug('isBetamaxFlatEnabled: %o', isBetamaxFlatEnabled);

var View = {
  create: function create(ad) {
    debug('create: %o', ad);
    var el = createEl();
    var videoContainerEl = getVideoContainerEl(el);
    var emitter = new EventEmitter();
    var EVENT = 'EVENT';
    var logEvent = new EventLogger(ad.id).logEvent;
    var videoSrc = null;
    var videoEl = null;
    var videoId = null;
    var fireOnStart = ad.metadata && ad.metadata.fireImpressionOnStart;
    var clickUrl = ad.click_url;
    var _nowPlaying = parseNowPlaying(ad);
    var isEnded = false;
    var isResizing = false;
    var _isBetamax2 = isBetamaxEnabled && (_isBetamax(ad) || isBetamaxFlatEnabled);
    var isStarted = false;
    var _isDestroyed = false;
    var destroyPromise = null;
    var ignoreVastEvents = false;
    var unsubscribeVast = null;
    var logMoatEvent = function logMoatEvent() {};

    var view = {
      nowPlaying: function nowPlaying() {
        return _nowPlaying;
      },

      isBetamax: function isBetamax() {
        return _isBetamax2;
      },

      isDestroyed: function isDestroyed() {
        return _isDestroyed;
      },

      start: function start() {
        debug('start: isStarted=%o err=%o', isStarted, videoEl.error);
        if (isStarted) return view;

        if (!hasFocus()) return view.fail(FAILURE_NOT_IN_FOCUS);
        if (videoEl.error) return view.fail();

        videoContainerEl.appendChild(videoEl);
        if (videoId) SPVideoManager.setActiveVideo(videoId);
        startListening();
        videoEl.play();
        maximize(true);
        isStarted = true;
        if (fireOnStart) logEvent('viewed');
        return view;
      },

      destroy: function destroy(silent) {
        debug('destroy');
        if (!destroyPromise) {
          emitter.emit(EVENT, DESTROYING);

          destroyPromise = new Promise(function (resolve) {
            if (isStarted) stopListening();
            if (el.parentNode) el.parentNode.removeChild(el);
            if (videoId) destroyVideoPlayer(videoId);
            resolve();
          }).then(function () {
            if (silent) return null;
            isEnded = isEnded || videoEl.currentTime === videoEl.duration;
            if (!isEnded) return logEvent('skipped');
            if (!fireOnStart) logEvent('viewed');
            return logEvent('ended');
          }).then(function () {
            _isDestroyed = true;
            emitter.emit(EVENT, DESTROYED);
            return view;
          });
        }

        return destroyPromise;
      },

      fail: function fail(reason) {
        debug('fail: reason=%o', reason);
        return logEvent('errored', {
          'event_version': reason || FAILURE_GENERAL
        }).then(function () {
          return view.destroy(true);
        });
      },

      minimize: function minimize(silent) {
        _minimize(silent);
        return view;
      },

      setVideoEl: function setVideoEl(_videoEl) {
        if (videoEl) throw new Error('videoEl already set');
        videoEl = _videoEl;
        return view;
      },

      logClick: function logClick() {
        logEvent('clicked');
        return view;
      },

      subscribe: function subscribe(callback) {
        emitter.on(EVENT, callback);
        return emitter.removeListener.bind(emitter, EVENT, callback);
      },

      EVENTS: {
        STARTED: STARTED,
        DESTROYING: DESTROYING,
        DESTROYED: DESTROYED
      }
    };

    if (!_isBetamax2) {
      videoSrc = getPreferredVideoUrl(ad.videos);
      videoEl = createVideoEl();
      videoId = createVideoPlayer(videoEl, videoSrc);
    }

    function startListening() {
      videoEl.addEventListener('ended', onEnded);
      videoEl.addEventListener('error', onError);
      el.addEventListener('click', onClick);
      if (videoId) SPVideoManager.subscribe(videoId, onVideoPlayerChange);

      if (ad.metadata['moat.enabled'] === 'true') {
        var ids = {
          level1: ad.metadata.advertiser_id,
          level2: ad.metadata.order_id,
          level3: ad.metadata.lineitem_id,
          level4: ad.metadata.creative_id
        };

        var moatIds;

        if (ad.metadata.dealId) {
          // SpotXChange ad
          moatIds = Object.assign({}, ids, {
            dealId: ad.metadata.dealId,
            domain: ad.metadata.domain,
            channelId: ad.metadata.channelId
          });
        } else if (ad.metadata.zMoatVF) {
          // Videology ad
          moatIds = Object.assign({}, ids, {
            zMoatCLUSTERID: ad.metadata.zMoatCLUSTERID,
            zMoatLOne: ad.metadata.zMoatLOne,
            zMoatLThree: ad.metadata.zMoatLThree,
            zMoatLTwo: ad.metadata.zMoatLTwo,
            zMoatSOne: ad.metadata.zMoatSOne,
            zMoatSTwo: ad.metadata.zMoatSTwo,
            zMoatVADID: ad.metadata.zMoatVADID,
            zMoatVCP: ad.metadata.zMoatVCP
          });
        } else {
          moatIds = ids;
        }

        logMoatEvent = MoatLogger.create({
          container: el,
          videoNode: videoEl,
          ids: moatIds
        });
      }

      unsubscribeVast = VastEvents.subscribe(videoEl, onVastEvent);
    }

    function stopListening() {
      videoEl.removeEventListener('ended', onEnded);
      videoEl.removeEventListener('error', onError);
      el.removeEventListener('click', onClick);
      if (videoId) SPVideoManager.unsubscribe(videoId, onVideoPlayerChange);
      if (unsubscribeVast) unsubscribeVast();
    }

    function onClick(e) {
      e.preventDefault();
      e.stopPropagation();

      if (e.target === videoEl) openUrl();else if (e.target.dataset.click === 'maximize') maximize();else if (e.target.dataset.click === 'minimize') _minimize();

      function openUrl() {
        logEvent('clicked');
        window.open(clickUrl);
      }
    }

    function onEnded() {
      isEnded = true;
      view.destroy();
    }

    function onError() {
      view.fail();
    }

    function onVastEvent(eventName) {
      var EVENTS = VastEvents.EVENTS;

      if (ignoreVastEvents) return;

      logMoatEvent(MoatLogger.EVENTS[eventName]);

      if (eventName === EVENTS.SKIPPED || eventName === EVENTS.ENDED) {
        logMoatEvent(MoatLogger.EVENTS.stopped);
      } else {
        // skipped and ended are logged later
        logEvent(eventName);
      }
    }

    function isMinimized() {
      return el.parentNode === minContainer;
    }

    function isMaximized() {
      return el.parentNode === maxContainer;
    }

    function _minimize(silent) {
      if (isResizing || isMinimized()) return;
      isResizing = true;

      el.classList.add('will-minimize');

      setTimeout(function () {
        el.classList.add('minimize');
        setTimeout(function () {
          moveTo(minContainer, function () {
            el.classList.remove('will-minimize', 'minimize');
            isResizing = false;
            if (!silent) logEvent('collapsed');
          });
        }, 300);
      }, 0);
    }

    function maximize(silent) {
      if (isResizing || isMaximized()) return;
      isResizing = true;

      el.classList.add('will-maximize');

      moveTo(maxContainer, function () {
        setTimeout(function () {
          el.classList.add('maximize');
          setTimeout(function () {
            el.classList.remove('will-maximize', 'maximize');
            isResizing = false;
            if (!silent) logEvent('expanded');
          }, 300);
        }, 0);
      });
    }

    function moveTo(parentEl, callback) {
      var wasPlaying = !videoEl.paused;
      ignoreVastEvents = true;
      parentEl.appendChild(el);

      if (!wasPlaying || !videoEl.paused) {
        done();
        return;
      }

      videoEl.addEventListener('play', function onPlay() {
        videoEl.removeEventListener('play', onPlay);
        done();
      });

      videoEl.play();

      function done() {
        ignoreVastEvents = false;
        if (callback) callback();
      }
    }

    function onVideoPlayerChange(err, p, c) {
      if (err) view.fail();
      // todo support betamax videos
      // todo refactor buffering logic
      if (c.isBuffering && c.timeBuffering >= BUFFERING_FAIL_TIMEOUT) {
        view.fail(FAILURE_BUFFER_TIMEOUT);
      }

      if (c.volume !== p.volume) {
        logMoatEvent(MoatLogger.EVENTS.volumechange);
      }
    }

    return view;
  },

  appendMaxTo: function appendMaxTo(parentEl) {
    if (!maxContainer) maxContainer = createDiv('saf-video-takeover-max');
    parentEl.appendChild(maxContainer);
    return View;
  },

  appendMinTo: function appendMinTo(parentEl) {
    if (!minContainer) minContainer = createDiv('saf-video-takeover-min');
    parentEl.appendChild(minContainer);
    return View;
  }
};

function createEl() {
  var el = createDiv('saf-video-takeover');
  el.innerHTML = template();
  return el;
}

function createDiv(className) {
  var div = createElement('div');
  div.className = className;
  return div;
}

function getVideoContainerEl(el) {
  return el.getElementsByClassName('saf-video-takeover-video')[0];
}

function createVideoEl() {
  var videoEl = createElement('video');
  videoEl.muted = true;
  videoEl.preload = 'auto';
  return videoEl;
}

function createVideoPlayer(videoEl, url) {
  var videoId = SPVideoManager.createVideo(videoEl, {
    url: url,
    isAd: true,
    volume: 0,
    startPaused: true
  });

  return videoId;
}

function destroyVideoPlayer(videoId) {
  var videoPlayer = SPVideoManager.getVideo(videoId);
  if (!videoPlayer) return;
  var activeVideoPlayer = SPVideoManager.getActiveVideo();
  if (videoPlayer === activeVideoPlayer) SPVideoManager.clearActiveVideo();
  SPVideoManager.destroy(videoId, true);
}

function getPreferredVideoUrl(videos) {
  var preferredVideo = videoUtils.getPreferredVideoMetadata(videos || []);
  return preferredVideo && preferredVideo.url;
}

function parseNowPlaying(ad) {
  var WIDTH = 300;
  var HEIGHT = 250;
  var mimeType = /^image\/(jpeg|png)$/;

  return {
    id: ad.id,
    title: ad.title,
    advertiser: ad.advertiser,
    clickUrl: ad.click_url,
    companionAd: getPreferredCompanionAd(ad)
  };

  function getPreferredCompanionAd() {
    var companionAd;
    var companionAds = ad.companion_ads;
    var l = companionAds && companionAds.length || 0;

    for (var i = 0; i < l; i++) {
      if (!companionAd && companionAds[i].url) {
        companionAd = companionAds[i];
      }

      if (isPreferred(companionAds[i])) {
        companionAd = companionAds[i];
        break;
      }
    }

    return {
      url: companionAd && companionAd.url,
      width: companionAd && companionAd.width,
      height: companionAd && companionAd.height
    };

    function isPreferred(props) {
      return props.width === WIDTH && props.height === HEIGHT && mimeType.test(props.mime_type);
    }
  }
}

function hasFocus() {
  return document.hasFocus();
}

function createElement(tagName) {
  return document.createElement(tagName);
}

function _isBetamax(ad) {
  var videos = ad && ad.videos || [];

  for (var i = 0; i < videos.length; i++) {
    if (videos[i].video_hex_id) return true;
  }

  return false;
}

module.exports = View;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../../../spotify-video-manager":493,"../../event-logger":213,"../../moat-logger":244,"../../vast-events":250,"../../video-utils":251,"./template.hbs":241,"debug":526,"events":531}],239:[function(require,module,exports){
'use strict';

var once = require('lodash/once');
var CosmosConnector = require('../../cosmos-connector');
var hasFocus = require('../../hasFocus').hasFocus;
var EventEmitter = require('events').EventEmitter;
var emitter = new EventEmitter();
var EVENT = 'EVENT';
var debug = require('debug')('saf:video-takeover:core');
var cosmosConnector = new CosmosConnector();
var initOnce = once(init);

function init() {
  cosmosConnector.addNewSlot('stream', 'video').then(function (placementUri) {
    return cosmosConnector.subscribeToSlot(placementUri, onCoreMessage);
  }).catch(debug);

  function onFocusChange(_hasFocus) {
    cosmosConnector.patchTargeting('adbreak', _hasFocus ? 'video,adscore' : 'adscore');
  }

  hasFocus.subscribe(onFocusChange);
  onFocusChange(hasFocus());

  function onCoreMessage(data) {
    debug('core message: ', data);
    emitter.emit(EVENT, data);
  }
}

var core = {
  subscribe: function subscribe(callback) {
    initOnce();
    emitter.on(EVENT, callback);
    return emitter.removeListener.bind(emitter, EVENT, callback);
  }
};

module.exports = core;

},{"../../cosmos-connector":208,"../../hasFocus":242,"debug":526,"events":531,"lodash/once":618}],240:[function(require,module,exports){
'use strict';

var once = require('lodash/once');
var debug = require('debug')('saf:video:index');

// todo remove eventDispatcher
var eventDispatcher = require('../../../../spotify-event-dispatcher');
var EventTypes = require('../../event-types');
var core = require('./core');
var View = require('./View');
var initOnce = once(init);

var EventEmitter = require('events').EventEmitter;
var emitter = new EventEmitter();
var EVENT = 'EVENT';
var views = {};
var currentView = null;

var ENABLED = 'ENABLED';
var DISABLED = 'DISABLED';
var ACTIVE = 'ACTIVE';
var INACTIVE = 'INACTIVE';

var _isEnabled = false;
var _isActive = false;

var VideoTakeoverAd = {
  appendMaxTo: function appendMaxTo(parentEl) {
    View.appendMaxTo(parentEl);
    return VideoTakeoverAd;
  },

  appendMinTo: function appendMinTo(parentEl) {
    View.appendMinTo(parentEl);
    return VideoTakeoverAd;
  },

  enable: function enable() {
    debug('enable');
    if (!_isEnabled) {
      initOnce();
      _isEnabled = true;
      emitter.emit(EVENT, ENABLED);
    }

    return VideoTakeoverAd;
  },

  disable: function disable() {
    debug('disable');
    if (_isEnabled) {
      if (currentView) currentView.destroy();
      _isEnabled = false;
      emitter.emit(EVENT, DISABLED);
    }

    return VideoTakeoverAd;
  },

  subscribe: function subscribe(callback) {
    emitter.on(EVENT, callback);
    return emitter.removeListener.bind(emitter, EVENT, callback);
  },

  playBetamaxVideo: function playBetamaxVideo(opts) {
    debug('playBetamaxVideo: %o', opts);
    var adId = opts.adId;
    var videoEl = opts.videoEl;
    var onDestroyed = opts.onDestroyed;
    var view = views[adId];

    var unsubscribe = view.subscribe(function (eventName) {
      if (eventName !== view.EVENTS.DESTROYED) return;
      unsubscribe();
      onDestroyed();
    });

    view.setVideoEl(videoEl);
    playView(view);

    return VideoTakeoverAd;
  },

  getPreferredVideo: function getPreferredVideo(videos) {
    var targetBitRate = 640;
    var mimeTypes = ['video/webm'];

    var preferredVideo = videos && videos.filter(function (video) {
      return mimeTypes.indexOf(video.mimeType) > -1;
    }).sort(function (a, b) {
      var x = Math.abs(a.bitrate - targetBitRate);
      var y = Math.abs(b.bitrate - targetBitRate);
      if (x > y) return 1;
      if (y < x) return -1;
      return 0;
    })[0];

    debug('preferred video selected: videos=%o, preferred=%o', videos, preferredVideo);
    return preferredVideo && preferredVideo.url;
  },

  nowPlaying: function nowPlaying() {
    return currentView && currentView.nowPlaying();
  },

  logClick: function logClick(clickUrl) {
    debug('logClick: %o', clickUrl);
    if (_isActive) currentView.logClick(clickUrl);
    return VideoTakeoverAd;
  },

  isEnabled: function isEnabled() {
    return _isEnabled;
  },

  isActive: function isActive() {
    return _isActive;
  },

  EVENTS: {
    ENABLED: ENABLED,
    DISABLED: DISABLED,
    ACTIVE: ACTIVE,
    INACTIVE: INACTIVE
  }
};

function init() {
  proxyEventsToEventDispatcher();
  core.subscribe(onCoreMessage);
  subscribeToNavChanges();

  function subscribeToNavChanges() {
    eventDispatcher.addEventListener(EventTypes.NAVIGATION_STATE_CHANGE, onNavigationChange);
  }

  // for backwards compatability
  function proxyEventsToEventDispatcher() {
    VideoTakeoverAd.subscribe(function (eventName) {
      if (eventName === ACTIVE) {
        eventDispatcher.dispatchEvent({
          type: EventTypes.AD_VIDEO_STARTED
        });
      } else if (eventName === INACTIVE) {
        eventDispatcher.dispatchEvent({
          type: EventTypes.AD_VIDEO_FINISHED
        });
      }
    });
  }
}

function onNavigationChange() {
  if (_isActive) currentView.minimize();
}

function onCoreMessage(data) {
  debug('onCoreMessage: %o', data);
  var view = views[data.ad.id];

  if (data.event === 'available' || data.event === 'play') {
    if (!view || view.isDestroyed()) {
      view = views[data.ad.id] = View.create(data.ad);
    }
  }

  if (data.event === 'play') {
    debug('play isEnabled=%o haveView=%o isBetamax=%o', _isEnabled, !!view, view.isBetamax());
    if (!_isEnabled) view.destroy();else if (!view.isBetamax()) playView(view);
  }

  if (data.event === 'discard') {
    if (view) view.destroy(true);
    views[data.ad.id] = null;
  }
}

function playView(view) {
  debug('playView view=%o', view);
  if (_isActive) currentView.destroy();

  var unsubscribe = view.subscribe(function (eventName) {
    if (eventName !== view.EVENTS.DESTROYING) return;
    unsubscribe();
    if (currentView === view) currentView = null;
    if (!_isActive) return;
    _isActive = false;
    emitter.emit(EVENT, INACTIVE);
  });

  currentView = view;

  _isActive = true;
  emitter.emit(EVENT, ACTIVE);
  view.start();
}

module.exports = VideoTakeoverAd;

},{"../../../../spotify-event-dispatcher":264,"../../event-types":214,"./View":238,"./core":239,"debug":526,"events":531,"lodash/once":618}],241:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};



  return "<div class=\"saf-video-takeover-video\" data-qa=\"saf-video-takeover-video\"></div>\n\n<button\n  type=\"button\"\n  class=\"saf-video-takeover-btn-min\"\n  data-qa=\"saf-video-takeover-btn-min\"\n  data-click=\"maximize\"\n>\n  <i class=\"spoticon-chevron-right-16\" data-click=\"maximize\"></i>\n</button>\n\n<button\n  type=\"button\"\n  class=\"saf-video-takeover-btn-max\"\n  data-qa=\"saf-video-takeover-btn-max\"\n  data-click=\"minimize\"\n>\n  <i class=\"spoticon-x-24\" data-click=\"minimize\"></i>\n</button>\n";
  });

},{"hbsfy/runtime":563}],242:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.hasFocus = undefined;
exports.factory = factory;

var _events = require('events');

var _once2 = require('lodash/once');

var _once3 = _interopRequireDefault(_once2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function factory(_ref) {
  var document = _ref.document;
  var setInterval = _ref.setInterval;
  var EventEmitter = _ref.EventEmitter;
  var once = _ref.once;

  var emitter = new EventEmitter();
  var EVENT = 'EVENT';
  var _hasFocus = void 0;

  var initOnce = once(function () {
    _hasFocus = document.hasFocus();

    setInterval(function () {
      var hadFocus = _hasFocus;
      _hasFocus = document.hasFocus();
      if (hadFocus !== _hasFocus) {
        emitter.emit(EVENT, _hasFocus);
      }
    }, 500);
  });

  function hasFocus() {
    initOnce();
    return _hasFocus;
  }

  hasFocus.subscribe = function (callback) {
    initOnce();
    emitter.on(EVENT, callback);
    return emitter.removeListener.bind(emitter, EVENT, callback);
  };

  return hasFocus;
}

var hasFocus = exports.hasFocus = factory({
  document: typeof document !== 'undefined' && document,
  setInterval: setInterval,
  EventEmitter: _events.EventEmitter,
  once: _once3.default
});

},{"events":531,"lodash/once":618}],243:[function(require,module,exports){
'use strict';

var config = require('./configuration');
var helpers = require('../../spotify-handlebars/helpers');

var i18n = require('../i18n');
var glueStrings = i18n.glueStrings();
var appStrings = i18n.appStrings();

// Temporary workaround while translation workflow gets worked out
glueStrings = glueStrings.strings || glueStrings;
appStrings = appStrings.strings || appStrings;

helpers.loc.register(glueStrings);
helpers.loc.register(appStrings);

// Inject configuration
config.setSpotlightSvg(require('../images/logo_spotlight.svg'));

// Public exports
window.Ads = require('./debugging-utils');

module.exports = {
  BillboardAd: require('./formats/billboard-ad'),
  LeaderboardAdV1: require('./formats/leaderboard-ad/v1'),
  LeaderboardAdV2: require('./formats/leaderboard-ad/v2'),
  LeaderboardAdV3: require('./formats/leaderboard-ad/v3'),
  HptoAd: require('./formats/hpto-ad'),
  VideoTakeoverAd: require('./formats/video-takeover-ad'),
  AudioCompanionAd: require('./formats/audio-companion-ad'),
  SponsoredPlaylistAd: require('./formats/sponsored-playlist-ad')
};

},{"../../spotify-handlebars/helpers":358,"../i18n":192,"../images/logo_spotlight.svg":202,"./configuration":207,"./debugging-utils":210,"./formats/audio-companion-ad":216,"./formats/billboard-ad":217,"./formats/hpto-ad":223,"./formats/leaderboard-ad/v1":233,"./formats/leaderboard-ad/v2":234,"./formats/leaderboard-ad/v3":235,"./formats/sponsored-playlist-ad":236,"./formats/video-takeover-ad":240}],244:[function(require,module,exports){
'use strict';

var abba = require('../../../spotify-abba-mini');
var _initMoat = require('./vendor-moat-init');
var VastEvents = require('../vast-events').EVENTS;
var debug = require('debug')('saf:moat');

var PARTNER_CODE = 'spotifynativeapp525794473702';

var moatLogger = {};

// maps various events to VPAID events
var events = {};
events[VastEvents.STARTED] = 'AdVideoStart';
events[VastEvents.FIRST_QUARTILE] = 'AdVideoFirstQuartile';
events[VastEvents.MIDPOINT] = 'AdVideoMidpoint';
events[VastEvents.THIRD_QUARTILE] = 'AdVideoThirdQuartile';
events[VastEvents.PAUSED] = 'AdPaused';
events[VastEvents.RESUMED] = 'AdPlaying';
events[VastEvents.ENDED] = 'AdVideoComplete';
events.stopped = 'AdStopped';
events.volumechange = 'AdVolumeChange';

moatLogger.EVENTS = events;

var abbaFlag = new Promise(function (resolve, reject) {
  abba('ads_desktop_moat_analytics', function (err, cell) {
    if (err) reject(err);
    if (cell === 'Enabled') resolve();
  });
});

/**
 * Wrapper around vendor code
 * @param {HTMLElement} container
 * @param {HTMLVideoElement} videoNode
 * @param {Object} ids
 * @return {Object} logMoatEvent
 */
moatLogger.create = function (opts) {
  var container = opts.container;
  var ids = opts.ids;
  var videoNode = opts.videoNode;

  var getMoat = new Promise(function (resolve) {
    if (videoNode.readyState >= videoNode.HAVE_METADATA) {
      resolveMoat();
      return;
    }

    videoNode.addEventListener('loadedmetadata', function onMetaData() {
      videoNode.removeEventListener(onMetaData);
      resolveMoat();
    });

    function resolveMoat() {
      var moat = _initMoat(container, ids, videoNode.duration, PARTNER_CODE);

      resolve(moat);
    }
  });

  return function logMoatEvent(eventType) {
    return abbaFlag.then(function () {
      return getMoat;
    }).then(function (moat) {
      var ev = {
        type: eventType,
        adVolume: videoNode.volume
      };

      debug(ev, ids);

      return moat.dispatchEvent(ev);
    }).catch(function (err) {
      debug(err);
      throw err;
    });
  };
};

module.exports = moatLogger;

},{"../../../spotify-abba-mini":181,"../vast-events":250,"./vendor-moat-init":245,"debug":526}],245:[function(require,module,exports){
'use strict';

/*
 * Vendor code - don't alter
 */

/*eslint-disable */

function initMoatTracking(container, ids, duration, partnerCode, url) {
  var protocol = 'https:',
      sub = protocol === 'https:' ? 'z' : 'js',
      script = document.createElement("script"),
      events = [],
      moatapi = {
    "adData": {
      "ids": ids,
      "duration": duration,
      "url": url
    },
    "dispatchEvent": function dispatchEvent(ev) {
      if (this.sendEvent) {
        if (events) {
          events.push(ev);
          ev = events;
          events = false;
        }
        this.sendEvent(ev);
      } else {
        events.push(ev);
      }
    }
  },
      moatApiName = "_moatApi" + Math.floor(Math.random() * 100000000);

  window[moatApiName] = moatapi;

  script.type = 'text/javascript';
  container && container.insertBefore(script, container.childNodes[0] || null);
  script.src = protocol + '//' + sub + '.moatads.com/' + partnerCode + '/moatvideo.js#' + moatApiName;

  return moatapi;
}
/*eslint-enable */

module.exports = initMoatTracking;

},{}],246:[function(require,module,exports){
'use strict';

var PLATFORMS = {
  desktop: 'html5_desktop'
};

var session = {};

session.get = function () {
  var platform = PLATFORMS[window.__spotify.platform];
  var isPremium = window.__spotify.product_state.ads === '0';

  return {
    platform: platform,
    isPremium: isPremium
  };
};

module.exports = session;

},{}],247:[function(require,module,exports){
'use strict';

var Preferences = require('../../spotify-preferences');
var uiPref = new Preferences('ui');

var settings = {};

settings.getHidePref = function (device, isPremium) {
	return new Promise(function (res, rej) {
		if (!isPremium) {
			res(false);
		} else {
			switch (device) {
				case 'html5_desktop':
					res(getZeldaPref());
					break;
				case 'web':
					res(getWebPref());
					break;
				default:
					rej(new Error('[HPTO] No valid device detected'));
			}
		}
	});
};

function getZeldaPref() {
	return new Promise(function (res, rej) {
		uiPref.get('hide_hpto', function (err, isHidden) {
			if (err) return rej(err);

			res(isHidden);
		});
	});
}

function getWebPref() {
	return new Promise(function (res, rej) {
		var hideState = false;

		switch (window.parent.localStorage['ui.hide_hpto']) {
			case 'true':
				hideState = true;
				break;
			case 'false':
				hideState = false;
				break;
			case undefined:
				// Set default hide hpto preference
				window.parent.localStorage['ui.hide_hpto'] = false;
				hideState = false;
				break;
			default:
				rej(new Error('[HPTO] Invalid hide state'));
		}

		res(hideState);
	});
}

module.exports = settings;

},{"../../spotify-preferences":486}],248:[function(require,module,exports){
'use strict';

var CosmosConnector = require('./cosmos-connector');
var cosmosConnector = new CosmosConnector();

var targeter = {};

/**
 * Get user targeting from lasertag
 * @param {String} inventoryUnit
 * @return {Promise}
 */
targeter.getTargeting = function (inventoryUnit) {
	function parseTargetData(data) {
		var obj = {};

		obj.ppid = data.ppid || data.aduserid;
		obj.inventoryUnit = inventoryUnit;
		obj.targetingData = data;

		return obj;
	}

	return cosmosConnector.getTargeting().then(parseTargetData);
};

module.exports = targeter;

},{"./cosmos-connector":208}],249:[function(require,module,exports){
'use strict';

var utils = {
  /**
   * Checks if various connected word strings exist in an object
   *
   * @param {String} prop - space separated words to be connected
   * @param {Object} obj - object to check prop in
   * @return {String}
   */

  getProp: function getProp(prop, obj) {
    prop = prop.trim().toLowerCase();
    var snakeCase = prop.replace(/\s+/g, '-');

    var camelCase = prop.replace(/\s+([a-z])/g, function (str, char) {
      return char.toUpperCase();
    });

    var paramCase = prop.replace(/\s+/g, '_');

    return obj[snakeCase] || obj[camelCase] || obj[paramCase];
  },

  /**
   * Returns type part of a URI
   *
   * @api public
   * @param {String} uri
   * @return {String} type
   */

  getType: function getType(uri) {
    var parts = uri.split(':');
    var type = null;

    if (parts[1] !== 'user') {
      type = parts[1];
    } else if (parts.length > 3 && parts.length <= 5 && parts[2] !== 'facebook') {
      type = 'playlist';
    }

    return type;
  },

  /**
   * Creates an HTML document from a
   * given HTML string
   *
   * @api public
   * @param {String} html
   */

  makeDocument: function makeDocument(html) {
    var doc = document.implementation.createHTMLDocument('');
    doc.documentElement.innerHTML = html;
    return doc;
  },

  appendTrackingPixel: function appendTrackingPixel(url, domEl) {
    var pixel = this.createTrackingPixel(url);
    domEl.appendChild(pixel);
  },

  /**
   * Creates a tracking pixel img
   *
   * @param {String} trackingUrl
   * @return {DOMElement} - img element
   */

  createTrackingPixel: function createTrackingPixel(trackingUrl) {
    var img = document.createElement('img');

    img.style.display = 'none';
    img.width = '1px';
    img.height = '1px';
    img.classList.add('pixel');

    // parse tracking url
    var dec = decodeURIComponent(trackingUrl.replace(/&amp;/g, '&'));
    img.src = decodeURIComponent(dec);

    return img;
  },

  /**
   * Creates an interactive iframe from given data
   * TODO: Deprecate after sandbox hpto rolls out 100%
   *
   * @api public
   * @param {String} html
   */

  createInteractiveIframe: function createInteractiveIframe(html) {
    var enc = encodeURIComponent(html);
    var iframe = document.createElement('iframe');
    iframe.className = 'hpto-interactive';
    iframe.src = 'data:text/html;charset=utf-8,' + enc;
    iframe.srcdoc = html;
    iframe.scrolling = 'no';
    iframe.marginWidth = 0;
    iframe.marginHeight = 0;
    iframe.hspace = 0;
    iframe.vspace = 0;
    return iframe;
  },

  createSandboxedIframe: function createSandboxedIframe() {
    var iframe = document.createElement('iframe');
    var sandboxParams = ['allow-forms', 'allow-pointer-lock', 'allow-popups', 'allow-same-origin', 'allow-scripts'];

    iframe.sandbox = sandboxParams.join(' ');
    return iframe;
  },

  createSandboxedHptoIframe: function createSandboxedHptoIframe(url) {
    var iframe = this.createSandboxedIframe();
    iframe.className = 'hpto-interactive';
    iframe.src = url;
    iframe.scrolling = 'no';
    iframe.marginWidth = 0;
    iframe.marginHeight = 0;
    iframe.hspace = 0;
    iframe.vspace = 0;
    return iframe;
  },

  /**
   * Sets data URL on a given element
   * from given data
   *
   * @api public
   * @param {Element} hptoElem
   * @param {Object} adData
   */
  setDataUrlOnElement: function setDataUrlOnElement(hptoElem, adData) {
    var bgUrl = utils.getProp('background url', adData);
    if (bgUrl) {
      bgUrl = bgUrl.replace(/&amp;/g, '&');
      hptoElem.setAttribute('data-url', bgUrl);
    }
  },

  /**
   * Delete array of nodes
   * @param  {Array} nodes - array of nodes to be deleted
   * @return {void}
   */
  deleteNodes: function deleteNodes(nodes) {
    var i, len, node, parent;

    if (nodes.length === 0) return;

    for (i = 0, len = nodes.length; i < len; i++) {
      node = nodes[i];
      parent = node.parentNode;

      parent.removeChild(node);
    }
  },

  /**
   * Parse spotify ad preview uri to get GID only
   * @param  {String} uri
   * @return {String}
   */
  parseGID: function parseGID(uri) {
    var parts = uri.split(':');
    if (parts.length >= 2 && parts[parts.length - 2] === 'ad') {
      return parts[parts.length - 1];
    }
  }
};

module.exports = utils;

},{}],250:[function(require,module,exports){
'use strict';

var throttle = require('lodash/throttle');
var once = require('lodash/once');

var STARTED = 'started';
var RESUMED = 'resumed';
var PAUSED = 'paused';
var MUTED = 'muted';
var UNMUTED = 'unmuted';
var FIRST_QUARTILE = 'first_quartile';
var MIDPOINT = 'midpoint';
var THIRD_QUARTILE = 'third_quartile';
var ENDED = 'ended';
var SKIPPED = 'skipped';

var VastEvents = {};

/**
 * @param {HTMLVideoElement} videoNode
 * @param {Function} callback
 */
VastEvents.subscribe = function (videoNode, callback) {
  var isStarted = false;
  var isEnded = false;
  var isMuted = videoNode.muted || videoNode.volume === 0;
  var emitFirstQuartile = once(emit.bind(null, FIRST_QUARTILE));
  var emitMidpoint = once(emit.bind(null, MIDPOINT));
  var emitThirdQuartile = once(emit.bind(null, THIRD_QUARTILE));
  var videoEvents = {};

  var unsubscribe = once(function () {
    isEnded = isEnded || videoNode.currentTime === videoNode.duration;
    removeListeners();
    emit(isEnded ? ENDED : SKIPPED);
  });

  function start() {
    isStarted = true;
    emit(STARTED);
  }

  function emit(eventName) {
    callback(eventName);
  }

  function addEventListener(name, listener) {
    videoEvents[name] = listener;
    videoNode.addEventListener(name, listener);
  }

  function removeListeners() {
    for (var x in videoEvents) {
      if (videoEvents.hasOwnProperty(x)) {
        videoNode.removeEventListener(x, videoEvents[x]);
      }
    }
  }

  if (!videoNode.paused) start();

  addEventListener('play', function () {
    if (!isStarted) {
      start();
      return;
    }

    emit(RESUMED);
  });

  addEventListener('pause', function (e) {
    // if paused on ended then do nothing
    if (e.target.currentTime === e.target.duration) return;
    emit(PAUSED);
  });

  addEventListener('ended', function () {
    isEnded = true;
    unsubscribe();
  });

  addEventListener('timeupdate', throttle(function (e) {
    var progress = e.target.currentTime / e.target.duration;
    if (progress >= 0.25) emitFirstQuartile();
    if (progress >= 0.50) emitMidpoint();
    if (progress >= 0.75) emitThirdQuartile();
  }, 500));

  addEventListener('volumechange', function (e) {
    var wasMuted = isMuted;
    isMuted = e.target.muted || e.target.volume === 0;
    if (wasMuted === isMuted) return;
    emit(isMuted ? MUTED : UNMUTED);
  });

  return unsubscribe;
};

VastEvents.EVENTS = {
  STARTED: STARTED,
  RESUMED: RESUMED,
  PAUSED: PAUSED,
  MUTED: MUTED,
  UNMUTED: UNMUTED,
  FIRST_QUARTILE: FIRST_QUARTILE,
  MIDPOINT: MIDPOINT,
  THIRD_QUARTILE: THIRD_QUARTILE,
  ENDED: ENDED,
  SKIPPED: SKIPPED
};

module.exports = VastEvents;

},{"lodash/once":618,"lodash/throttle":619}],251:[function(require,module,exports){
'use strict';

var VIDEO_MAX_WIDTH = 1280;
module.exports.VIDEO_MAX_WIDTH = VIDEO_MAX_WIDTH;

var VIDEO_PROGRAMMATIC_WIDTHS = [1024, 800, 640];
module.exports.VIDEO_PROGRAMMATIC_WIDTHS = VIDEO_PROGRAMMATIC_WIDTHS;

var VIDEO_PREFERRED_WIDTHS = [VIDEO_MAX_WIDTH].concat(VIDEO_PROGRAMMATIC_WIDTHS);
module.exports.VIDEO_PREFERRED_WIDTHS = VIDEO_PREFERRED_WIDTHS;

var SUPPORTED_VIDEO_FORMATS = ['video/webm'];
module.exports.SUPPORTED_VIDEO_FORMATS = SUPPORTED_VIDEO_FORMATS;

module.exports = {

  /**
   * Return video metadata based on preferred formats/widths
   *
   * @param {Object[]} - array of video metadata
   * @param {String[]} - array of preferred video formats
   * @param {String[]} - array of preferred video sizes
   * @return {Object} - preferred video metadata
   */

  getPreferredVideoMetadata: function getPreferredVideoMetadata(videos, formats, widths) {
    formats = formats || SUPPORTED_VIDEO_FORMATS;
    widths = widths || VIDEO_PREFERRED_WIDTHS;

    var maxPreferredWidth = Math.max.apply(null, widths);

    // Filter out unsupported mimetypes
    var supportedMimeType = function supportedMimeType(video) {
      return formats.indexOf(video.mime_type) > -1;
    };

    // Filter out widths larger than largest preferred width
    var preferredWidth = function preferredWidth(video) {
      return video.width <= maxPreferredWidth;
    };

    // Sort in descending width
    var descWidth = function descWidth(v1, v2) {
      return v2.width - v1.width;
    };

    // Return video with largest preferred width
    return videos.filter(supportedMimeType).filter(preferredWidth).sort(descWidth).shift();
  }
};

},{}],252:[function(require,module,exports){
'use strict';

// Base function that doesn't have any dependencies on it's own. Expects to get
// state (a plain, empty object) injected in addition to a bridge request
// function.
function cosmosRequest(state, bridge, opts, callback) {

  if (typeof opts.uri !== 'string') throw new Error('Expected uri to be string.');

  if (COSMOS_VERBS.indexOf(opts.method) === -1) throw new Error('Method must match valid verb in uppercase (GET, POST etc)');

  if (opts.body && typeof opts.body !== 'string') throw new Error('If body is provided it should be a string.');

  if (opts.headers && Object.prototype.toString.call(opts.headers) !== '[object Object]') throw new Error('Expected headers be a plain object.');

  var cosmosOptions = {
    action: opts.method,
    uri: opts.uri
  };
  if (opts.body) cosmosOptions.body = opts.body;
  if (opts.headers) cosmosOptions.headers = opts.headers;

  /* Cosmos requires each request to have a unique ID. Ideally, this would be
  uuids, but unfortunately, it is integers. This means that in apps that for
  some reason need to use spotify-cosmos-api, there would between the two
  counters if cosmosRequest started from 0. To make it safe for the two
  implemenations to co-exist if needed, we begin counting at
  significantly higher number: */
  state.requestIDCounter = state.requestIDCounter || TEN_PER_SECOND_FOR_A_YEAR;
  state.requestIDCounter++;

  var requestArguments = [state.requestIDCounter, cosmosOptions];

  var isCanceled = false;
  var stateRequestIDCounter = state.requestIDCounter;

  function cancelFunction() {
    isCanceled = true;
    bridge('cosmos_request_cancel', [stateRequestIDCounter]);
  }

  // run is a recursive function that does a bridge request and then keeps
  // pulling values after every response in the case of a subscription. In
  // case we are not subscribing, or the cancelFunction has been called,
  // run sends cosmos_request_cancel and terminates.
  function run(isFirst, requestIDCounter) {
    var messageName = isFirst ? 'cosmos_request_create' : 'cosmos_request_pull';
    bridge(messageName, requestArguments, function (error, responseString) {
      // The request to cancel may not have gotten to the bridge
      // before the original request got resolved,
      // so make sure not to continue if we detect it's been canceled.
      if (isCanceled) {
        return;
      }
      try {
        if (callback) {
          if (error) {
            callback(error);
          } else {
            callback(null, responseString);
          }
        }
      } finally {
        if (opts.method !== 'SUB') {
          // If the request was a non-SUB, tell core to clean up the request.
          // NOTE: Not sure if this is strictly necessary,
          // have not been to investigate in C++-land, so for now
          // we are just mimicing the behavior of spotify-cosmos-api.
          bridge('cosmos_request_cancel', [requestIDCounter]);
        } else if (!isCanceled) {
          // maybe canceled in above callback
          run(false, requestIDCounter);
        }
      }
    });
  }

  run(true, stateRequestIDCounter);

  return cancelFunction;
}

var TEN_PER_SECOND_FOR_A_YEAR = 10 * 60 * 60 * 24 * 365;

var COSMOS_VERBS = ['GET', 'HEAD', 'POST', 'PUT', 'SUB', 'PATCH', 'DELETE'];

module.exports = cosmosRequest;

},{}],253:[function(require,module,exports){
(function (global){
'use strict';

var debug = require('debug')('spotify-bridge-request');
var defer = require('spotify-deferred');

var cosmosBaseFunction = require('./cosmos');

// NOTE: Implicit global state.
var scheduledCoreFlush = false;
var cosmosState = null;

exports.cosmos = cosmos;
exports.cosmosJSON = cosmosJSON;
exports.request = request;
exports._request = _request;

function cosmos() {
  if (!cosmosState) cosmosState = {};

  var baseArguments = [cosmosState, request];
  var cancelFunction = cosmosBaseFunction.apply(null, baseArguments.concat(Array.prototype.slice.call(arguments)));
  return cancelFunction;
}

function _createCallbackWrapper(callback) {
  return function callbackWrapper(err, response) {
    if (!err) {
      var parsedResponse;
      try {
        parsedResponse = JSON.parse(response.body);
      } catch (e) {
        e.message = 'Failed to parse cosmos response: ' + e.message;
        callback(e);
        return;
      }
      callback(null, parsedResponse);
    } else {
      callback(err, response);
    }
  };
}

function cosmosJSON(opts, callback) {
  if (opts.body) {
    opts.body = JSON.stringify(opts.body);
  }
  var callbackWrapper = callback ? _createCallbackWrapper(callback) : null;
  var cancelFunction = cosmos(opts, callbackWrapper);
  return cancelFunction;
}

function request(name, opt_args, opt_callback) {
  var args = opt_args || [];
  var callback = getCallback(name, args, opt_callback);

  debug('req:' + name, args);

  exports._request(name, args, callback);

  if (name !== 'core_flush' && !scheduledCoreFlush) {
    scheduledCoreFlush = true;
    defer(flushCore);
  }

  return exports;
}

function _request(name, args, callback) {
  global._getSpotifyModule('bridge').executeRequest(JSON.stringify({
    name: name,
    args: args
  }), {
    onSuccess: getSuccessHandler(callback),
    onFailure: getFailureHandler(callback, name, args)
  });
}

function getCallback(name, args, opt_userCallback) {
  var userCallback = opt_userCallback || function () {};

  return function (error, data) {
    if (error) {
      if (error.name === 'timeout') {
        // Set the delay between 300ms and 400ms
        var delay = 300 + Math.floor(Math.random() * 100);

        debug('timeout', error.message);

        // Retry the request
        setTimeout(function () {
          request(name, args, userCallback);
        }, delay);
        return;
      }
    }

    debug('res:' + name, args, data);

    userCallback(error, data);
  };
}

function getSuccessHandler(requestCallback) {
  return function (data) {
    var parsed;

    debug('success', data);

    try {
      parsed = JSON.parse(data);
    } catch (error) {
      requestCallback(error);
    }

    if (parsed) {
      requestCallback(null, parsed);
    }
  };
}

function getFailureHandler(requestCallback, name, args) {
  return function (data) {
    var parsed;

    debug('failure', data);

    try {
      parsed = JSON.parse(data);
    } catch (error) {
      requestCallback(error);
    }

    if (parsed) {
      requestCallback(createError(name, args, parsed));
    }
  };
}

function createError(name, args, response) {
  var argsString = JSON.stringify(args);
  var debug = ' (bridge message: \'' + name + '\', args: ' + argsString + ')';
  var msg = response.message + debug;
  var error = new Error(msg);
  error.name = response.error;

  return error;
}

function flushCore() {
  scheduledCoreFlush = false;
  request('core_flush');
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./cosmos":252,"debug":526,"spotify-deferred":699}],254:[function(require,module,exports){
'use strict';

var parser = require('../spotify-live/util/parser');

var sortMap = {
  track: {
    _replace: '',
    artists: {
      _replace: 'artist'
    },
    disc: {
      _replace: 'discNumber'
    },
    number: {
      _replace: 'trackNumber'
    },
    duration: {
      _replace: 'length'
    }
  },
  timeSinceAdded: {
    _reverse: true,
    _replace: 'addTime'
  },
  addedBy: {
    _replace: '',
    name: {
      _replace: 'addedByDisplayName'
    }
  }
};

function reverse(direction) {
  return direction === 'ASC' ? 'DESC' : 'ASC';
}

function walk(query, mapping, opt_direction, incomingCollector) {
  var results = [];
  var collector = incomingCollector && incomingCollector.slice() || [];

  for (var item, i = 0; item = query.mask[i]; i++) {
    var itemCollector = collector.slice();

    if (item.key) {
      var hasReplace = mapping && mapping[item.key] && mapping[item.key]._replace != null;

      var value = hasReplace ? mapping[item.key]._replace : item.key;
      if (value !== '') {

        // Only add the direction if there's not another sub object
        if (!item.mask) {
          var doReverse = !!(mapping && mapping[item.key] && mapping[item.key]._reverse);
          if (opt_direction) {
            opt_direction = opt_direction.toUpperCase();
            var direction = doReverse ? reverse(opt_direction) : opt_direction;
            value += ' ' + direction;
          }
        }
        itemCollector.push(value);
      }
    }

    if (item.mask) {
      var subLookUp = walk(item, mapping[item.key], opt_direction, itemCollector);
      if (subLookUp.length) {
        results.push(subLookUp);
      }
    } else {
      if (itemCollector.length) {
        results.push(itemCollector.join('.'));
      }
    }
  }
  return results;
}

function getParams(query, opt_direction, opt_map) {
  var parsed = parser(query);
  if (!query) return null;

  var map = opt_map || sortMap;
  var result = walk(parsed, map, opt_direction);

  return result.join(',');
}

module.exports = getParams;

},{"../spotify-live/util/parser":442}],255:[function(require,module,exports){
/*
attributes
*/"use strict";

var $ = require("./base");

var trim = require("mout/string/trim"),
    forEach = require("mout/array/forEach"),
    filter = require("mout/array/filter"),
    indexOf = require("mout/array/indexOf");

// attributes

$.implement({

    setAttribute: function setAttribute(name, value) {
        return this.forEach(function (node) {
            node.setAttribute(name, value);
        });
    },

    getAttribute: function getAttribute(name) {
        var attr = this[0].getAttributeNode(name);
        return attr && attr.specified ? attr.value : null;
    },

    hasAttribute: function hasAttribute(name) {
        var node = this[0];
        if (node.hasAttribute) return node.hasAttribute(name);
        var attr = node.getAttributeNode(name);
        return !!(attr && attr.specified);
    },

    removeAttribute: function removeAttribute(name) {
        return this.forEach(function (node) {
            var attr = node.getAttributeNode(name);
            if (attr) node.removeAttributeNode(attr);
        });
    }

});

var accessors = {};

forEach(["type", "value", "name", "href", "title", "id"], function (name) {

    accessors[name] = function (value) {
        return value !== undefined ? this.forEach(function (node) {
            node[name] = value;
        }) : this[0][name];
    };
});

// booleans

forEach(["checked", "disabled", "selected"], function (name) {

    accessors[name] = function (value) {
        return value !== undefined ? this.forEach(function (node) {
            node[name] = !!value;
        }) : !!this[0][name];
    };
});

// className

var classes = function classes(className) {
    var classNames = trim(className).replace(/\s+/g, " ").split(" "),
        uniques = {};

    return filter(classNames, function (className) {
        if (className !== "" && !uniques[className]) return uniques[className] = className;
    }).sort();
};

accessors.className = function (className) {
    return className !== undefined ? this.forEach(function (node) {
        node.className = classes(className).join(" ");
    }) : classes(this[0].className).join(" ");
};

// attribute

$.implement({

    attribute: function attribute(name, value) {
        var accessor = accessors[name];
        if (accessor) return accessor.call(this, value);
        if (value != null) return this.setAttribute(name, value);
        if (value === null) return this.removeAttribute(name);
        if (value === undefined) return this.getAttribute(name);
    }

});

$.implement(accessors);

// shortcuts

$.implement({

    check: function check() {
        return this.checked(true);
    },

    uncheck: function uncheck() {
        return this.checked(false);
    },

    disable: function disable() {
        return this.disabled(true);
    },

    enable: function enable() {
        return this.disabled(false);
    },

    select: function select() {
        return this.selected(true);
    },

    deselect: function deselect() {
        return this.selected(false);
    }

});

// classNames, has / add / remove Class

$.implement({

    classNames: function classNames() {
        return classes(this[0].className);
    },

    hasClass: function hasClass(className) {
        return indexOf(this.classNames(), className) > -1;
    },

    addClass: function addClass(className) {
        return this.forEach(function (node) {
            var nodeClassName = node.className;
            var classNames = classes(nodeClassName + " " + className).join(" ");
            if (nodeClassName !== classNames) node.className = classNames;
        });
    },

    removeClass: function removeClass(className) {
        return this.forEach(function (node) {
            var classNames = classes(node.className);
            forEach(classes(className), function (className) {
                var index = indexOf(classNames, className);
                if (index > -1) classNames.splice(index, 1);
            });
            node.className = classNames.join(" ");
        });
    },

    toggleClass: function toggleClass(className, force) {
        var add = force !== undefined ? force : !this.hasClass(className);
        if (add) this.addClass(className);else this.removeClass(className);
        return !!add;
    }

});

// toString

$.prototype.toString = function () {
    var tag = this.tag(),
        id = this.id(),
        classes = this.classNames();

    var str = tag;
    if (id) str += '#' + id;
    if (classes.length) str += '.' + classes.join(".");
    return str;
};

var textProperty = document.createElement('div').textContent == null ? 'innerText' : 'textContent';

// tag, html, text, data

$.implement({

    tag: function tag() {
        return this[0].tagName.toLowerCase();
    },

    html: function html(_html) {
        return _html !== undefined ? this.forEach(function (node) {
            node.innerHTML = _html;
        }) : this[0].innerHTML;
    },

    text: function text(_text) {
        return _text !== undefined ? this.forEach(function (node) {
            node[textProperty] = _text;
        }) : this[0][textProperty];
    },

    data: function data(key, value) {
        switch (value) {
            case undefined:
                return this.getAttribute("data-" + key);
            case null:
                return this.removeAttribute("data-" + key);
            default:
                return this.setAttribute("data-" + key, value);
        }
    }

});

module.exports = $;

},{"./base":256,"mout/array/filter":629,"mout/array/forEach":632,"mout/array/indexOf":633,"mout/string/trim":673}],256:[function(require,module,exports){
/*
elements
*/"use strict";

var prime = require("prime");

var _forEach = require("mout/array/forEach"),
    _map = require("mout/array/map"),
    _filter = require("mout/array/filter"),
    _every = require("mout/array/every"),
    _some = require("mout/array/some");

// uniqueID

var index = 0,
    __dc = document.__counter,
    counter = document.__counter = (__dc ? parseInt(__dc, 36) + 1 : 0).toString(36),
    key = "uid:" + counter;

var uniqueID = function uniqueID(n) {
    if (n === window) return "window";
    if (n === document) return "document";
    if (n === document.documentElement) return "html";
    return n[key] || (n[key] = (index++).toString(36));
};

var instances = new WeakMap();

// elements prime

var $ = prime({ constructor: function $(n, context) {

        if (n == null) return this && this.constructor === $ ? new Elements() : null;

        var self, uid, instance;

        if (n.constructor !== Elements) {

            self = new Elements();

            if (typeof n === "string") {
                if (!self.search) return null;
                self[self.length++] = context || document;
                return self.search(n);
            }

            if (n.nodeType || n === window) {

                self[self.length++] = n;
            } else if (n.length) {

                // this could be an array, or any object with a length attribute,
                // including another instance of elements from another interface.

                var uniques = {};

                for (var i = 0, l = n.length; i < l; i++) {
                    // perform elements flattening
                    var nodes = $(n[i], context);
                    if (nodes && nodes.length) for (var j = 0, k = nodes.length; j < k; j++) {
                        var node = nodes[j];
                        uid = uniqueID(node);
                        if (!uniques[uid]) {
                            self[self.length++] = node;
                            uniques[uid] = true;
                        }
                    }
                }
            }
        } else {
            self = n;
        }

        if (!self.length) return null;

        // when length is 1 always use the same elements instance

        if (self.length === 1) {
            if (instance = instances.get(self[0])) {
                return instance;
            } else {
                instances.set(self[0], self);
            }
        }

        return self;
    } });

var Elements = prime({

    inherits: $,

    constructor: function Elements() {
        this.length = 0;
    },

    unlink: function unlink() {
        return this.map(function (node) {
            instances.delete(node);
            return node;
        });
    },

    // methods

    forEach: function forEach(method, context) {
        _forEach(this, method, context);
        return this;
    },

    map: function map(method, context) {
        return _map(this, method, context);
    },

    filter: function filter(method, context) {
        return _filter(this, method, context);
    },

    every: function every(method, context) {
        return _every(this, method, context);
    },

    some: function some(method, context) {
        return _some(this, method, context);
    }

});

module.exports = $;

},{"mout/array/every":628,"mout/array/filter":629,"mout/array/forEach":632,"mout/array/map":635,"mout/array/some":638,"prime":678}],257:[function(require,module,exports){
/*
delegation
*/"use strict";

var Map = require("prime/map");

var $ = require("./events");
require('./traversal');

$.implement({

    delegate: function delegate(event, selector, handle) {

        return this.forEach(function (node) {

            var self = $(node);

            var delegation = self._delegation || (self._delegation = {}),
                events = delegation[event] || (delegation[event] = {}),
                map = events[selector] || (events[selector] = new Map());

            if (map.get(handle)) return;

            var action = function action(e) {
                var target = $(e.target || e.srcElement),
                    match = target.matches(selector) ? target : target.parent(selector);

                var res;

                if (match) res = handle.call(self, e, match);

                return res;
            };

            map.set(handle, action);

            self.on(event, action);
        });
    },

    undelegate: function undelegate(event, selector, handle) {

        return this.forEach(function (node) {

            var self = $(node),
                delegation,
                events,
                map;

            if (!(delegation = self._delegation) || !(events = delegation[event]) || !(map = events[selector])) return;

            var action = map.get(handle);

            if (action) {
                self.off(event, action);
                map.remove(action);

                // if there are no more handles in a given selector, delete it
                if (!map.count()) delete events[selector];
                // var evc = evd = 0, x
                var e1 = true,
                    e2 = true,
                    x;
                for (x in events) {
                    e1 = false;
                    break;
                }
                // if no more selectors in a given event type, delete it
                if (e1) delete delegation[event];
                for (x in delegation) {
                    e2 = false;
                    break;
                }
                // if there are no more delegation events in the element, delete the _delegation object
                if (e2) delete self._delegation;
            }
        });
    }

});

module.exports = $;

},{"./events":258,"./traversal":261,"prime/map":679}],258:[function(require,module,exports){
/*
events
*/"use strict";

var Emitter = require("prime/emitter");

var $ = require("./base");

$.implement({

    on: function on(event, handle, useCapture) {

        return this.forEach(function (node) {
            var self = $(node);

            var internalEvent = event + (useCapture ? ":capture" : "");

            Emitter.prototype.on.call(self, internalEvent, handle);

            var domListeners = self._domListeners || (self._domListeners = {});
            if (!domListeners[internalEvent]) {
                var listener = function listener(e) {
                    Emitter.prototype.emit.call(self, internalEvent, e || window.event, Emitter.EMIT_SYNC);
                };
                node.addEventListener(event, listener, useCapture || false);
                domListeners[internalEvent] = listener;
            }
        });
    },

    off: function off(event, handle, useCapture) {

        return this.forEach(function (node) {

            var self = $(node);

            var internalEvent = event + (useCapture ? ":capture" : "");

            var domListeners = self._domListeners,
                domEvent,
                listeners = self._listeners,
                events;

            if (domListeners && (domEvent = domListeners[internalEvent]) && listeners && (events = listeners[internalEvent])) {

                Emitter.prototype.off.call(self, internalEvent, handle);

                if (!self._listeners || !self._listeners[event]) {
                    node.removeEventListener(event, domEvent, false);
                    delete domListeners[event];

                    for (var l in domListeners) {
                        return;
                    }delete self._domListeners;
                }
            }
        });
    },

    emit: function emit() {
        var args = arguments;
        return this.forEach(function (node) {
            Emitter.prototype.emit.apply($(node), args);
        });
    }

});

module.exports = $;

},{"./base":256,"prime/emitter":677}],259:[function(require,module,exports){
/*
elements
*/"use strict";

var $ = require("./base");
require("./attributes");
require("./events");
require("./insertion");
require("./traversal");
require("./delegation");

module.exports = $;

},{"./attributes":255,"./base":256,"./delegation":257,"./events":258,"./insertion":260,"./traversal":261}],260:[function(require,module,exports){
/*
insertion
*/"use strict";

var $ = require("./base");

// base insertion

$.implement({

    appendChild: function appendChild(child) {
        this[0].appendChild($(child)[0]);
        return this;
    },

    insertBefore: function insertBefore(child, ref) {
        this[0].insertBefore($(child)[0], $(ref)[0]);
        return this;
    },

    removeChild: function removeChild(child) {
        this[0].removeChild($(child)[0]);
        return this;
    },

    replaceChild: function replaceChild(child, ref) {
        this[0].replaceChild($(child)[0], $(ref)[0]);
        return this;
    }

});

// before, after, bottom, top

$.implement({

    before: function before(element) {
        element = $(element)[0];
        var parent = element.parentNode;
        if (parent) this.forEach(function (node) {
            parent.insertBefore(node, element);
        });
        return this;
    },

    after: function after(element) {
        element = $(element)[0];
        var parent = element.parentNode;
        if (parent) this.forEach(function (node) {
            parent.insertBefore(node, element.nextSibling);
        });
        return this;
    },

    bottom: function bottom(element) {
        element = $(element)[0];
        return this.forEach(function (node) {
            element.appendChild(node);
        });
    },

    top: function top(element) {
        element = $(element)[0];
        return this.forEach(function (node) {
            element.insertBefore(node, element.firstChild);
        });
    }

});

// insert, replace

$.implement({

    insert: $.prototype.bottom,

    remove: function remove() {
        return this.forEach(function (node) {
            var parent = node.parentNode;
            if (parent) parent.removeChild(node);
        });
    },

    replace: function replace(element) {
        element = $(element)[0];
        element.parentNode.replaceChild(this[0], element);
        return this;
    }

});

module.exports = $;

},{"./base":256}],261:[function(require,module,exports){
/*
traversal
*/"use strict";

var map = require("mout/array/map");

var slick = require("slick");

var $ = require("./base");

var gen = function gen(combinator, expression) {
    return map(slick.parse(expression || "*"), function (part) {
        return combinator + " " + part;
    }).join(", ");
};

var push_ = Array.prototype.push;

$.implement({

    search: function search(expression) {
        if (this.length === 1) return $(slick.search(expression, this[0], new $()));

        var buffer = [];
        for (var i = 0, node; node = this[i]; i++) {
            push_.apply(buffer, slick.search(expression, node));
        }buffer = $(buffer);
        return buffer && buffer.sort();
    },

    find: function find(expression) {
        if (this.length === 1) return $(slick.find(expression, this[0]));

        for (var i = 0, node; node = this[i]; i++) {
            var found = slick.find(expression, node);
            if (found) return $(found);
        }

        return null;
    },

    sort: function sort() {
        return slick.sort(this);
    },

    matches: function matches(expression) {
        return slick.matches(this[0], expression);
    },

    contains: function contains(node) {
        return slick.contains(this[0], node);
    },

    nextSiblings: function nextSiblings(expression) {
        return this.search(gen('~', expression));
    },

    nextSibling: function nextSibling(expression) {
        return this.find(gen('+', expression));
    },

    previousSiblings: function previousSiblings(expression) {
        return this.search(gen('!~', expression));
    },

    previousSibling: function previousSibling(expression) {
        return this.find(gen('!+', expression));
    },

    children: function children(expression) {
        return this.search(gen('>', expression));
    },

    firstChild: function firstChild(expression) {
        return this.find(gen('^', expression));
    },

    lastChild: function lastChild(expression) {
        return this.find(gen('!^', expression));
    },

    parent: function parent(expression) {
        var buffer = [];
        loop: for (var i = 0, node; node = this[i]; i++) {
            while ((node = node.parentNode) && node !== document) {
                if (!expression || slick.matches(node, expression)) {
                    buffer.push(node);
                    break loop;
                    break;
                }
            }
        }return $(buffer);
    },

    parents: function parents(expression) {
        var buffer = [];
        for (var i = 0, node; node = this[i]; i++) {
            while ((node = node.parentNode) && node !== document) {
                if (!expression || slick.matches(node, expression)) buffer.push(node);
            }
        }return $(buffer);
    }

});

module.exports = $;

},{"./base":256,"mout/array/map":635,"slick":686}],262:[function(require,module,exports){
/*
zen
*/"use strict";

var forEach = require("mout/array/forEach"),
    map = require("mout/array/map");

var parse = require("slick/parser");

var $ = require("./base");

module.exports = function (expression, doc) {

    return $(map(parse(expression), function (expression) {

        var previous, result;

        forEach(expression, function (part, i) {

            var node = (doc || document).createElement(part.tag);

            if (part.id) node.id = part.id;

            if (part.classList) node.className = part.classList.join(" ");

            if (part.attributes) forEach(part.attributes, function (attribute) {
                node.setAttribute(attribute.name, attribute.value || "");
            });

            if (part.pseudos) forEach(part.pseudos, function (pseudo) {
                var n = $(node),
                    method = n[pseudo.name];
                if (method) method.call(n, pseudo.value);
            });

            if (i === 0) {

                result = node;
            } else if (part.combinator === " ") {

                previous.appendChild(node);
            } else if (part.combinator === "+") {
                var parentNode = previous.parentNode;
                if (parentNode) parentNode.appendChild(node);
            }

            previous = node;
        });

        return result;
    }));
};

},{"./base":256,"mout/array/forEach":632,"mout/array/map":635,"slick/parser":687}],263:[function(require,module,exports){
'use strict';

var cosmos = require('spotify-cosmos-api');
var sub = cosmos.resolver.subscribe.bind(cosmos.resolver);
var post = cosmos.resolver.post.bind(cosmos.resolver);

var PREFIX = 'sp://messages/v1/ensured-';

var send = function send(channel, message) {
  var url = PREFIX + channel + '-payload';

  var readyListener = sub(PREFIX + channel + '-ready', function () {
    post({
      url: url,
      body: message
    });
  });

  var ackListener = sub(PREFIX + channel + '-ack', function () {
    readyListener.cancel();
    ackListener.cancel();
  });

  post({
    url: url,
    body: message
  });
};

var subscribe = function subscribe(channel, callback) {
  var handler = sub(PREFIX + channel + '-payload', function (error, response) {
    post(PREFIX + channel + '-ack');
    callback(error, response && response.getJSONBody());
  });
  post(PREFIX + channel + '-ready');

  return {
    cancel: handler.cancel.bind(handler)
  };
};

module.exports = {
  send: send,
  subscribe: subscribe
};

},{"spotify-cosmos-api":694}],264:[function(require,module,exports){
'use strict';

function EventDispatcher() {
  // In order to not have prototype nor constructor
  this._listeners = Object.create(null);
}

/**
 * Add an event listener.
 *
 * @param {String} type What type of event to listen to.
 * @param {Function} callback Callback function to execute when triggered.
 * @param {Number?} priority The priority(?).
 */
EventDispatcher.prototype.addEventListener = function (type, callback, priority) {
  if (!type || !callback) {
    throw new Error('Both event type and callback need to be defined');
  }

  priority = priority || 0;

  if (!this._listeners[type]) {
    this._listeners[type] = [];
  }

  var handlers = this._listeners[type];
  // Check if this callback is already registered
  if (handlers.every(function (h) {
    return h.callback !== callback;
  })) {
    var newHandler = {
      callback: callback,
      priority: priority
    };

    // Insert the handler in the right position
    var pos = 0;
    while (pos < handlers.length && handlers[pos].priority > newHandler.priority) {
      pos++;
    }
    handlers.splice(pos, 0, newHandler);
  }
};

/**
 * Remove an event listener.
 *
 * @param {String} type What type of event to stop listening to.
 * @param {Function} listener The listener to remove.
 */
EventDispatcher.prototype.removeEventListener = function (type, listener) {
  var handlers = this._listeners[type] || [];
  for (var i = 0; i < handlers.length; i++) {
    if (handlers[i].callback === listener) {
      handlers.splice(i, 1);
      return;
    }
  }
};

/**
 * Dispatch an event
 *
 * @param {Object} event The event to dispatch.
 */
EventDispatcher.prototype.dispatchEvent = function (event) {
  // Iterate on a copy of the array since an event callback might
  // unbind its listener, which would mutate the listeners array and make
  // the for loop act up.
  var handlers = this._listeners[event.type] ? this._listeners[event.type].slice() : [];
  for (var i = 0, len = handlers.length; i < len; i++) {
    var evt = handlers[i];
    evt.callback(event);
  }
};

EventDispatcher.prototype.reset = function () {
  this._listeners = Object.create(null);
};

module.exports = new EventDispatcher();

},{}],265:[function(require,module,exports){
'use strict';

var $ = require('../spotify-elements');
var forIn = require('mout/object/forIn');
var live = require('../spotify-live');
var center = require('./center');

var IS_ADDED_PROPERTY = 'added';
var FOLLOWERSCOUNT_PROPERTY = 'followersCount';
var FOLLOWINGCOUNT_PROPERTY = 'followingCount';
var BUTTON_SELECTOR = '[data-button=add]';
var JUSTCHANGED_CLASSNAME = 'just-changed';
var ADDED_CLASSNAME = 'added';

var dataPropertiesForAdd = [IS_ADDED_PROPERTY, FOLLOWERSCOUNT_PROPERTY, FOLLOWINGCOUNT_PROPERTY];

var changeHandlers = {};

function getAddedClass(node) {
  var addedClassNode = node[0].closest('data-class-added');
  return addedClassNode ? addedClassNode.getAttribute('data-class-added') : ADDED_CLASSNAME;
}

function getURIFromNode(node) {
  var stateNode = node[0].closest('[data-uri]');
  if (!stateNode) {
    return null;
  }
  return stateNode.getAttribute('data-uri');
}

var eventHandlers = {

  click: function click(event, node) {
    var stateNode = $(node[0].closest('[data-uri]'));
    if (!stateNode) return;

    var uri = stateNode.data('uri');
    if (!uri) return;

    var addedClass = getAddedClass(node);
    var shouldBeAdded = !stateNode.hasClass(addedClass);
    var data = {
      added: shouldBeAdded
    };

    node.addClass(JUSTCHANGED_CLASSNAME);

    // using capture=true to handle buttons with inner divs (used for changing button text)
    node.on('mouseout', function mouseoutHandler(event) {
      if (event.target !== node[0]) return;
      node.off('mouseout', mouseoutHandler);
      node.removeClass(JUSTCHANGED_CLASSNAME);
    }, true);

    // Publish will trigger the update event, which will then update the UI
    live(uri).publish(data);
  },

  changeHandler: function changeHandler(key, value, uri) {
    if (key === IS_ADDED_PROPERTY) {
      var numAffectedButtons = actions.setStateForURI(uri, value);
      if (numAffectedButtons === 0) {
        live(uri).off('update', changeHandlers[uri]);
        delete changeHandlers[uri];
      }
    }

    if (dataPropertiesForAdd.indexOf(key) > -1) {
      center.emit('add-data-change', { uri: uri, model: live(uri), key: key, value: value });
    }
  }

};

var actions = {

  setStateForURI: function setStateForURI(uri, isAdded) {
    var numAffectedButtons = 0;

    var nodes = $(document).search(BUTTON_SELECTOR);
    if (!nodes) return numAffectedButtons;

    for (var i = 0, l = nodes.length; i < l; i++) {
      var node = $(nodes[i]);
      var buttonURI = getURIFromNode(node);
      if (uri === buttonURI) {
        numAffectedButtons++;
        actions.setStateForButtonNode(node, isAdded);
      }
    }

    return numAffectedButtons;
  },

  setStateForButtonNode: function setStateForButtonNode(node, isAdded) {
    var stateNode = $(node[0].closest('[data-uri]'));
    if (!stateNode) return;

    var addedClass = getAddedClass(node);
    actions.setVisualState(isAdded, stateNode, node, addedClass);
  },

  setVisualState: function setVisualState(isAdded, node, button, className) {
    if (isAdded) {
      if (!node.hasClass(className)) node.addClass(className);
      var tooltipRemove = button.data('tooltip-remove');
      if (tooltipRemove) {
        button.setAttribute('data-tooltip', tooltipRemove);
        button.setAttribute('aria-label', tooltipRemove);
      }
      button.setAttribute('data-log-click', 'remove-button');
    } else {
      if (node.hasClass(className)) node.removeClass(className);
      var tooltipAdd = button.data('tooltip-add');
      if (tooltipAdd) {
        button.setAttribute('data-tooltip', tooltipAdd);
        button.setAttribute('aria-label', tooltipAdd);
      }
      button.setAttribute('data-log-click', 'add-button');
    }
  },

  addListenerForNode: function addListenerForNode(node) {
    var uri = getURIFromNode(node);

    // If we have already added a change handler for this URI,
    // we don't want to add another one, so we cancel early.
    // Before cancelling though, we should update button states
    // with the current state from the live model, since there
    // might be new buttons in the DOM.
    if (changeHandlers[uri]) {
      live(uri).get('added', function (error, isAdded) {
        if (error) throw error;
        actions.setStateForButtonNode(node, isAdded);
      });
      return;
    }

    changeHandlers[uri] = function (properties) {
      for (var key in properties) {
        var value = properties[key];
        eventHandlers.changeHandler(key, value, uri);
      };
    };

    var model = live(uri);

    // Get the initial state and update the button
    model.get('added', function (error, isAdded) {
      if (error) throw error;
      actions.setStateForButtonNode(node, isAdded);

      // When the initial state is known, we listen for updates
      // so we can update all buttons for this URI later.
      model.on('update', changeHandlers[uri]);
    });
  }

};

var handleScrollShow = function handleScrollShow(data) {
  update(data.pageNode, data.nodes);
};

// Export for testing
exports._classNames = {
  ADDED: ADDED_CLASSNAME,
  JUSTCHANGED: JUSTCHANGED_CLASSNAME
};

var isAttached = false;

exports.attach = function attach() {
  if (isAttached) return;
  isAttached = true;

  $(document).delegate('click', BUTTON_SELECTOR, eventHandlers.click);

  center.on('scroll-show-before', handleScrollShow);
};

exports.detach = function detach() {
  if (!isAttached) return;
  isAttached = false;

  $(document).undelegate('click', BUTTON_SELECTOR, eventHandlers.click);
  center.off('scroll-show-before', handleScrollShow);
};

var update = exports.update = function update(node, nodes) {
  if (!isAttached) return;

  // If the node passed in is a button node, just add listeners for that
  if (node && $(node).matches(BUTTON_SELECTOR)) {
    actions.addListenerForNode($(node));

    // Otherwise search all the children of the node (or the document
    // if node is not provided) for buttons.
  } else {

      var nodes = ($(nodes) || $(node) || $(document)).search(BUTTON_SELECTOR);
      if (!nodes) return;

      for (var i = 0, l = nodes.length; i < l; i++) {
        actions.addListenerForNode($(nodes[i]));
      }
    }
};

},{"../spotify-elements":259,"../spotify-live":439,"./center":268,"mout/object/forIn":662}],266:[function(require,module,exports){
'use strict';

var $ = require('../spotify-elements');
var Navigator = require('../spotify-navigation/navigator');
var AppState = require('../spotify-navigation/app-state');

var SELECTOR = 'a';

var nav = new Navigator();

var handleAnchorClick = function handleAnchorClick(event, node) {
  var anchor = node[0];
  var href = anchor.getAttribute('href');
  if (!href || href[0] === '#') {
    return;
  }

  event.preventDefault();

  var referrer = anchor.getAttribute('data-referrer-id') || document.body.getAttribute('data-referrer-id');

  var state = new AppState(href);

  if (referrer) {
    state.setReferrer(referrer);
  }

  nav.requestOpenState(state);
};

var isAttached = false;

exports.attach = function attach() {
  if (isAttached) {
    return;
  }
  isAttached = true;
  $(document).delegate('click', SELECTOR, handleAnchorClick);
};

exports.detach = function detach() {
  if (!isAttached) {
    return;
  }
  isAttached = false;
  $(document).undelegate('click', SELECTOR, handleAnchorClick);
};

exports.update = function () {};

},{"../spotify-elements":259,"../spotify-navigation/app-state":462,"../spotify-navigation/navigator":464}],267:[function(require,module,exports){
(function (global){
'use strict';

var $ = require('../spotify-elements');
var doc = $(document);
var win = $(window);

// Decides how many pixels allowed between two touchmoves to determine if it is a swipe
var SWIPE_SENSITIVITY = 1;
// Constant that sets the amount of pixels allowed to move without locking the horizontal scroll
var SCROLL_LOCK_LIMIT = 10;
// The divider used to calculate the swipe speed. A larger number will make a slower swipe
var SWIPE_LAG = 14;

var handleClickLeft = function handleClickLeft(event, node) {
  handleButtonClick(node, true);
};

var handleClickRight = function handleClickRight(event, node) {
  handleButtonClick(node, false);
};

var getCarouselInner = function getCarouselInner(node) {
  return node.search('[data-carousel-inner]');
};

var getCarouselObjectsWidth = function getCarouselObjectsWidth(carouselInner) {
  var mediaObjects = $(carouselInner).search('.media-object');
  if (!mediaObjects) {
    return;
  }
  var mediaObjectWidth = parseFloat(global.getComputedStyle(mediaObjects[0]).width);
  var carouselInnerWidth = parseFloat(global.getComputedStyle(carouselInner).width);
  var carouselTotalWidth = carouselInner.scrollWidth;

  return {
    mediaObjectWidth: mediaObjectWidth,
    carouselInnerWidth: carouselInnerWidth,
    carouselTotalWidth: carouselTotalWidth
  };
};

var calculateMinLeftPixels = function calculateMinLeftPixels(carouselInner) {
  var minLeft = 0;
  // Determine number of pages based on numbers per page and total number of objects
  var carouselObjectsWidth = getCarouselObjectsWidth(carouselInner);
  var objectsPerPage = Math.round(carouselObjectsWidth.carouselInnerWidth / carouselObjectsWidth.mediaObjectWidth);
  var totalNrOfObjects = Math.round(carouselObjectsWidth.carouselTotalWidth / carouselObjectsWidth.mediaObjectWidth);
  var nrOfPages = Math.ceil(totalNrOfObjects / objectsPerPage);
  minLeft = -(carouselObjectsWidth.carouselInnerWidth * (nrOfPages - 1));
  return minLeft;
};

var handleTouchStart = function handleTouchStart(event, node) {
  // Disable swiping the carousel if scrolling down/up the page
  var scrollBlocked = false;
  doc.on('scroll', handleScroll);
  function handleScroll(event) {
    if (!scrollBlocked) {
      doc.undelegate('touchmove', '[data-carousel]', handleTouchMove);
      doc.undelegate('touchend', '[data-carousel]', handleTouchEnd);
    } else {
      event.preventDefault();
    }
  }

  // Get carousel element
  var carouselInner = getCarouselInner(node);
  if (!carouselInner) {
    return;
  }
  carouselInner = carouselInner[0];
  var startX;
  var previousX;
  var deltaX;
  // minLeft is always a negative number or 0. This is the minimum LEFT position of the carousel.
  var minLeft = calculateMinLeftPixels(carouselInner);
  if (minLeft === 0) {
    return;
  }
  doc.delegate('touchmove', '[data-carousel]', handleTouchMove);
  doc.delegate('touchend', '[data-carousel]', handleTouchEnd);

  // Get start coordinates
  if (event.touches) {
    startX = event.touches[0].pageX;
    previousX = startX;
  }

  function handleTouchMove(event) {
    if (!carouselInner) {
      return;
    }
    addDragTransition();

    if (event.touches) {
      var x = event.touches[0].pageX;
      deltaX = previousX - x;
      // Get position of carousel
      var positionLeft = carouselPosition(carouselInner);
      positionLeft = getPositionInPixels(positionLeft, carouselInner);
      // Set adjusted position
      var adjust = positionLeft - deltaX;
      // Check that carousel position doesn't exceed limits
      adjust = checkLimitsPixels(adjust, minLeft);
      carouselInner.style.left = adjust + 'px';
      previousX = x;

      if (deltaX > SCROLL_LOCK_LIMIT) {
        scrollBlocked = true;
      }
      if (scrollBlocked) {
        event.preventDefault();
      }
    }
  };

  function handleTouchEnd(event) {
    doc.undelegate('touchmove', '[data-carousel]', handleTouchMove);
    doc.undelegate('touchend', '[data-carousel]', handleTouchEnd);
    doc.off('scroll', handleScroll);
    if (!carouselInner) {
      return;
    }
    // If considered as a swipe, swipe
    if (Math.abs(deltaX) > SWIPE_SENSITIVITY) {
      swipe(deltaX);
    }
    updateButtonsOnTouch(node);
  };

  /* Touch swipe functions */

  var swipe = function swipe(deltaX) {
    addSwipeTransition();
    // Get position of carousel
    var leftValue = carouselPosition(carouselInner);
    leftValue = getPositionInPixels(leftValue, carouselInner);

    var carouselObjectsWidth = getCarouselObjectsWidth(carouselInner);
    // Get width of one mediaobject to us as an interval in the calculation for setting the swipe speed
    var mediaObjectWidth = parseInt(carouselObjectsWidth.mediaObjectWidth);
    if (!mediaObjectWidth) {
      return;
    }
    // Calculate position to swipe to based on value of deltaX (e.g. swipe acceleration) and SWIPE_LAG
    // SWIPE_LAG can be changed to a lower/higher value to increase/decrease speed.
    var adjust = leftValue + mediaObjectWidth * (-deltaX / SWIPE_LAG);
    // Check that carousel position doesn't exceed limits
    adjust = checkLimitsPixels(adjust, minLeft);
    carouselInner.style.left = adjust + 'px';
  };

  var updateButtonsOnTouch = function updateButtonsOnTouch(node) {
    var carouselId = node.data('carousel');
    var positionLeft = carouselPosition(carouselInner);
    positionLeft = getPositionInPixels(positionLeft, carouselInner);
    var carouselRight = $('[data-carousel=' + carouselId + '][data-button=carousel-right]');
    var carouselLeft = $('[data-carousel=' + carouselId + '][data-button=carousel-left]');

    if (Math.round(positionLeft) <= Math.round(minLeft)) {
      carouselRight.setAttribute('disabled', 'disabled');
    } else {
      carouselRight.removeAttribute('disabled');
    }

    if (positionLeft >= 0) {
      carouselLeft.setAttribute('disabled', 'disabled');
    } else {
      carouselLeft.removeAttribute('disabled');
    }
  };

  var addSwipeTransition = function addSwipeTransition() {
    if (!carouselInner) {
      return;
    }
    // Add swipe transition and remove drag + click transition
    $(carouselInner).addClass('crsl-inner-swipe').removeClass('crsl-inner-drag');
  };

  var addDragTransition = function addDragTransition() {
    if (!carouselInner) {
      return;
    }
    // Add drag transition and remove swipe + click transition
    $(carouselInner).addClass('crsl-inner-drag').removeClass('crsl-inner-swipe');
  };
};

var resetTransitions = function resetTransitions(carouselInner) {
  if (!carouselInner) {
    return;
  }
  // Add click transition and remove drag + swipe transition
  $(carouselInner).removeClass('crsl-inner-drag').removeClass('crsl-inner-swipe');
};

var checkLimitsPixels = function checkLimitsPixels(adjust, minLeft) {
  adjust = Math.min(adjust, 0);
  adjust = Math.max(adjust, minLeft);
  return adjust;
};

var carouselPosition = function carouselPosition(carouselInner) {
  return carouselInner.style.left || '0';
};

var getPositionInPixels = function getPositionInPixels(positionLeft, carouselInner) {
  var isInPx = positionLeft.endsWith('px');
  positionLeft = parseFloat(positionLeft);
  // If current unit isn't px, change to px
  if (!isInPx) {
    var currentPage = Math.abs(positionLeft / 100);
    // var carouselInnerWidth = carouselInner.clientWidth;
    var carouselInnerWidth = getCarouselObjectsWidth(carouselInner).carouselInnerWidth;
    positionLeft = -carouselInnerWidth * currentPage;
  }
  return positionLeft;
};

var getNextPageInPercent = function getNextPageInPercent(positionLeft, carouselInner, isLeft) {
  var carouselInnerWidth = carouselInner.clientWidth;
  var minLeft = calculateMinLeftPixels(carouselInner);
  var isInPercent = positionLeft.endsWith('%');
  positionLeft = parseInt(positionLeft);
  // If current unit isn't %, change to %
  var nextPage;
  if (!isInPercent) {
    nextPage = Math.abs(positionLeft / carouselInnerWidth);
    // If position is to the end left and button is right
    if (positionLeft === 0 && !isLeft) {
      nextPage = -100;
    }
    // If position is to the end right and button is left
    else if (positionLeft === minLeft && isLeft) {
        nextPage = (nextPage - 1) * -100;
      } else {
        nextPage = isLeft ? Math.floor(nextPage) : Math.ceil(nextPage);
        nextPage = nextPage * -100;
      }
  }
  // If current unit already is in percent
  else {
      nextPage = isLeft ? positionLeft + 100 : positionLeft - 100;
    }
  return nextPage;
};

var handleButtonClick = function handleButtonClick(buttonNode, isLeft) {
  if (buttonNode.hasAttribute('disabled')) {
    return;
  }
  var carouselId = buttonNode.data('carousel');
  var carouselInner = $('[data-carousel=' + carouselId + '][data-carousel-main] [data-carousel-inner]')[0];
  var positionLeft = carouselPosition(carouselInner);

  var adjust;
  if (positionLeft) {
    // Get next page in %
    var nextPage = getNextPageInPercent(positionLeft, carouselInner, isLeft);
    adjust = nextPage;
  } else {
    adjust = isLeft ? 0 : -100;
  }
  // Reset transitions
  resetTransitions(carouselInner);
  carouselInner.style.left = adjust + '%';
  updateButtonStates(carouselId);
};

var updateButtonStates = function updateButtonStates(carouselId) {
  var carouselRight = $('[data-carousel=' + carouselId + '][data-button=carousel-right]');
  var carouselLeft = $('[data-carousel=' + carouselId + '][data-button=carousel-left]');
  var carousel = $('[data-carousel=' + carouselId + '][data-carousel-main]');
  var carouselInner = $(carousel).search('[data-carousel-inner]')[0];
  var leftAdjust = carouselInner.style.left ? parseInt(carouselInner.style.left) : 0;

  if (leftAdjust >= 0) {
    carouselLeft.setAttribute('disabled', 'disabled');
  } else {
    carouselLeft.removeAttribute('disabled');
  }

  if (carouselInner.clientWidth - leftAdjust / 100 * carouselInner.clientWidth + 10 > carouselInner.scrollWidth) {
    carouselRight.setAttribute('disabled', 'disabled');
  } else {
    carouselRight.removeAttribute('disabled');
  }
};

var updateAllButtons = function updateAllButtons(node) {
  node = $(node) || doc;
  var carousels = node.search('[data-carousel-main]');
  if (carousels) {
    carousels.forEach(function (carousel) {
      updateButtonStates($(carousel).data('carousel'));
    });
  }
};

var isAttached = false;

exports.update = function update(node) {
  if (!isAttached) return;

  updateAllButtons(node);
};

exports.attach = function () {
  if (isAttached) return;
  isAttached = true;

  doc.delegate('click', '[data-button=carousel-right]', handleClickRight);
  doc.delegate('click', '[data-button=carousel-left]', handleClickLeft);
  doc.delegate('touchstart', '[data-carousel][data-carousel-main]', handleTouchStart);

  win.on('resize', updateAllButtons);

  // Polyfill from: https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith
  if (!String.prototype.endsWith) {
    String.prototype.endsWith = function (searchString, position) {
      var subjectString = this.toString();
      if (position === undefined || position > subjectString.length) {
        position = subjectString.length;
      }
      position -= searchString.length;
      var lastIndex = subjectString.indexOf(searchString, position);
      return lastIndex !== -1 && lastIndex === position;
    };
  }
};

exports.detach = function () {
  if (!isAttached) return;
  isAttached = false;

  doc.undelegate('click', '[data-button=carousel-right]', handleClickRight);
  doc.undelegate('click', '[data-button=carousel-left]', handleClickLeft);
  doc.undelegate('touchstart', '[data-carousel][data-carousel-main]', handleTouchStart);

  win.off('resize', updateAllButtons);
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-elements":259}],268:[function(require,module,exports){
/*
Event Center
*/'use strict';

var Emitter = require('prime/emitter');

module.exports = new Emitter();

},{"prime/emitter":677}],269:[function(require,module,exports){
'use strict';

var $ = require('../spotify-elements');
var live = require('../spotify-live');
var selection = require('./selection');
var wrappedUriUtils = require('../spotify-live-wrapped-uri');
var cosmos = require('./util/cosmos');

var CONTEXTMENU = ['a[data-uri]', '[data-contextmenu]'].join(',');

var makeContextMenuData = function makeContextMenuData(selectionContexts, primaryIndex, uris, x, y) {
  var contexts = [];
  for (var i = 0, selectionContext; selectionContext = selectionContexts[i]; i++) {
    var keys = selectionContext.keys || [];
    var indices = selectionContext.indices || [];
    primaryIndex = primaryIndex || indices[0];
    primaryIndex = primaryIndex == null ? null : primaryIndex;

    var contextUri = selectionContext.uri;
    var liveList = live(contextUri).get('rows');

    var contextData = {
      uri: contextUri,
      keys: keys,
      indices: indices,
      primaryIndex: primaryIndex
    };

    var origin = selectionContext.origin;
    if (origin) {
      if (primaryIndex != null) {
        var wrappedList = live(contextUri).get('rows');
        var originList = live(origin.uri).get('rows');
        if (wrappedList && originList) {
          var key = wrappedList.keys[primaryIndex];
          origin.primaryIndex = originList.indexOf(key);
        }
      }
      contextData.origin = origin;
    }
    contexts.push(contextData);
  }
  return {
    contexts: contexts,
    x: x,
    y: y,
    uris: uris
  };
};

var handleContextMenuEvent = function handleContextMenuEvent(event, node) {
  event.preventDefault();
  event.stopPropagation();

  var x = event.clientX,
      y = event.clientY;

  if (node[0].tagName.toLowerCase() === 'a') {
    var uri = node.data('uri');
    if (uri) {
      showContextMenu({ uris: [uri], x: x, y: y });
    }
  } else {
    var contextNode = node.parent('[data-list]');
    var contextURI;
    if (contextNode) contextURI = contextNode.data('uri');

    var index = +node.data('index');

    var isSelected = false;
    var omitContext = false;
    var indices = selection.getIndicesPerList();

    if (contextNode) {
      isSelected = selection.isNodeSelected(node);
      // If the selection is shared between different lists, don't pass a contextURI.
      omitContext = indices.length > 1;
    }
    var uris = isSelected ? selection.getUris() : [node.data('uri')];
    showContextMenu(makeContextMenuData(indices, index, uris, x, y));
  }
};

var handleContextMenuButton = function handleContextMenuButton(event, node) {
  var parent;
  var uri = node.data('uri') || (parent = node.parent('[data-uri]')) && parent.data('uri');
  if (!uri) return;

  // The context menu can't know what to offer for a custom list.
  // In case of a sorted and/or filtered list, pass the origin list.
  uri = wrappedUriUtils.getOriginUri(uri) || uri;

  var contextURI = (parent = node.parent('[data-list][data-uri]')) && parent.data('uri');
  var contextIndex = (parent = node.parent('[data-index]')) && +parent.data('index');

  var contextMenuNode = $(node[0].closest('[data-button="contextmenu"]'));
  var relativeTo = contextMenuNode || parent || node;

  var rect = relativeTo[0].getBoundingClientRect();
  var x = rect.left + rect.width / 2;
  var y = rect.top + rect.height;

  // The coordinate must be within the app viewport
  if (y > window.innerHeight) y = window.innerHeight - 1;
  if (x > window.innerWidth) x = window.innerWidth - 1;

  var indices = contextIndex == null ? null : [contextIndex];
  contextIndex = contextIndex == null ? null : contextIndex;

  var context;
  if (contextURI) {
    context = { uri: contextURI };

    if (indices) {
      context.indices = indices;

      var liveList = live(contextURI).get('rows');
      context.keys = liveList ? indices.map(function (selectedIndex) {
        return liveList.keys[selectedIndex];
      }) : [];
    }

    // Add originList
    var origin = wrappedUriUtils.getOriginUri(contextURI);
    if (origin) {
      context.origin = { uri: origin };

      if (indices) {
        var wrappedList = live(contextURI).get('rows');
        var originList = live(origin).get('rows');
        if (wrappedList && originList) {
          var originIndices = indices.map(function (index) {
            var key = wrappedList.keys[index];
            return originList.indexOf(key);
          });
          var originKeys = indices.map(function (index) {
            return wrappedList.keys[index];
          });
          context.origin.indices = originIndices;
          context.origin.keys = originKeys;
        }
      }
    }
  }
  showContextMenu(makeContextMenuData([context], contextIndex, [uri], x, y));
  contextMenuNode.addClass('contextmenu-active');

  var cancel = cosmos.subscribe({ url: 'sp://messages/v1/context_menu_state' }, function (error, response) {
    if (!error && response.body.state === 'hide') {
      contextMenuNode.removeClass('contextmenu-active');
      cancel();
    }
  });
};

var showContextMenu = function showContextMenu(data) {
  var application = live('spotify:application');
  application.query('appURI', function (error, application_data) {
    if (!error) {
      data.appURI = application_data.appURI;
    }
    var client = live('spotify:client');
    client.emit('show-context-menu', data);
  });
};

var isAttached = false;

exports.attach = function attach() {
  if (isAttached) return;
  isAttached = true;

  $(document).delegate('contextmenu', CONTEXTMENU, handleContextMenuEvent);
  $(document).delegate('click', '[data-button=contextmenu]', handleContextMenuButton);
};

exports.detach = function detach() {
  if (!isAttached) return;
  isAttached = false;

  $(document).undelegate('contextmenu', CONTEXTMENU, handleContextMenuEvent);
  $(document).undelegate('click', '[data-button=contextmenu]', handleContextMenuButton);
};

exports.update = function () {};

},{"../spotify-elements":259,"../spotify-live":439,"../spotify-live-wrapped-uri":438,"./selection":304,"./util/cosmos":319}],270:[function(require,module,exports){
/**
 * @module spotify-events/dragndrop/custom/rootlist
 * @private
 */
'use strict';

var $ = require('../../../spotify-elements');

var liburi = require('spotify-liburi');
var live = require('../../../spotify-live');
var intersection = require('mout/array/intersection');

var hooks = require('../util/hooks');
var eventModel = require('../util/eventmodel');
var selection = require('../../selection');

var SELECTOR_LIST = '[data-list]';
var SELECTOR_LIST_ITEM = '[data-list-item]';
var SELECTOR_DRAGGABLE = 'a, [draggable]';
var ATTR_TARGET = 'data-drop-target';

var dragFolderElement = null;

/**
 * Handler for the dragstart event.
 *
 * @param {MouseEvent} event Event object for a dragstart event.
 * @param {HTMLElement} target The target element.
 */
function onDragStart(event, target) {
  dragFolderElement = null;

  var uris = selection.getUris();
  if (uris.length > 1) return;

  var uri = uris[0];
  var uriObject = uri && liburi.fromString(uri);
  if (!uriObject) return;

  // If dragging a folder, we need to temporarily save the folder DOM node,
  // so that while dragging over items we can check whether to show the drop
  // indicator. Dropping a folder inside itself should not be allowed.
  if (uriObject.type === liburi.Type.FOLDER) {
    var selectedNodes = selection.getNodes();
    for (var i = 0, l = selectedNodes.length; i < l; i++) {
      var node = selectedNodes[i];
      if (node.getAttribute('data-uri') === uri) {
        dragFolderElement = node;
        break;
      }
    }
  }
}

/**
 * Handler for ending a drag.
 *
 * @param {MouseEvent} event A dragend event object.
 * @param {HTMLElement} target DOM element for the drop target.
 */
function onDragEnd(event, target) {
  dragFolderElement = null;
}

/**
 * Hook handler for setting drag data.
 *
 * @param {MouseEvent} event Event object for a dragstart event.
 * @param {Array.<string>} uris Array of URIs being dragged.
 * @param {string=} opt_context Optional context URI.
 */
function onSetDragData(event, uris, opt_context) {
  if (opt_context !== 'spotify:rootlist') {
    var followedPlaylistCount = 0;
    for (var i = 0, l = uris.length; i < l; i++) {
      var uriObject = liburi.from(uris[i]);
      var type = uriObject && uriObject.type;
      if (type === liburi.Type.PLAYLIST) {
        var isFollowing = live(uris[i]).get('added');
        if (isFollowing) followedPlaylistCount++;
      } else {
        // If the item is not a playlist, it means we are dragging either only
        // items of another type, or playlists as well as other types.
        break;
      }
    }

    // Dropping only playlists that you are following in the rootlist should
    // not be allowed. If multiple playlists are dragged and some of them are
    // not being followed, dropping is allowed (and the receiver should handle
    // only inserting the new ones). To allow telling these cases apart while
    // not having access to drag data, we set a special MIME type that can be
    // checked later.
    if (followedPlaylistCount === uris.length) {
      event.dataTransfer.setData('text/x-spotify-only-followed-playlists', '');
    }
  }
}

/**
 * Hook handler for validating a list drop.
 *
 * @param {Object} result Result object. Setting the `valid` property will
 *     affect whether the drop is allowed.
 * @param {MouseEvent} event Some kind of drag and drop event.
 * @param {HTMLElement} list A DOM node marked up as a list.
 * @param {string} location The location of the cursor in relation to the list.
 *     This can be either 'inside' or 'below'. The value 'below' means that the
 *     cursor was below the last list found in the DOM.
 */
function onListDropValidation(result, event, list, location) {
  var contextUri = list.getAttribute('data-uri');
  if (contextUri === 'spotify:rootlist') {

    // Dropping only already followed playlists into the rootlist should not
    // be allowed, since you can only have playlists once in the rootlist.
    if (hasOnlyFollowedPlaylists(event)) {
      result.valid = false;
      return;
    }

    // Dropping a folder inside or right below itself should not be allowed
    if (isInsideDraggedFolder(event, location)) {
      result.valid = false;
      return;
    }

    // Dropping on the bottom half of a folder should not be allowed as a list
    // target, but will be a regular target for the folder instead. However, if
    // the dragged items match the list target, dropping should be handled by
    // list code instead of target code (dragover should still not validate as
    // we want the active drop target style and not the list indicator).
    if (isInFolderBottomHalf(event)) {
      if (event.type !== 'drop' || !isMatchingTarget(event, list)) {
        result.valid = false;
        return;
      }
    }
  }
}

/**
 * Hook handler for validating a target.
 *
 * @param {Object} result Result object. Setting the `valid` property will
 *     affect whether the drop is allowed.
 * @param {MouseEvent} event Some kind of drag and drop event.
 * @param {HTMLElement} target DOM node for target that matches MIME types.
 */
function onTargetValidation(result, event, target) {
  var list = target.closest(SELECTOR_LIST);
  if (list) {
    var contextUri = list.getAttribute('data-uri');
    if (contextUri === 'spotify:rootlist') {

      // Dropping only already followed playlists into the rootlist should not
      // be allowed, since you can only have playlists once in the rootlist.
      if (hasOnlyFollowedPlaylists(event)) {
        result.valid = false;
        return;
      }

      // Dropping valid rootlist items on the top half of a folder should not
      // be allowed as a regular target, but will be a list drop target instead.
      // For leave events, we need to validate the whole row as valid, so that
      // the target styling is removed correctly.
      if (event.type !== 'dragleave' && isMatchingTarget(event, list)) {
        var folderNode = getFolderNode(event);
        if (folderNode) {
          if (isBelowMiddleOfNode(event.clientY, folderNode)) {
            result.valid = true;
          } else {
            result.valid = false;
          }
          return;
        }
      }
    }
  }
}

/**
 * Hook handler for getting the indices being moved.
 *
 * @param {string} contextUri The context URI.
 * @param {LiveList} liveList Live list to be changed.
 * @param {Array.<number>} indices Array of indices in the list.
 */
function onGetMoveIndices(contextUri, liveList, indices) {
  if (contextUri === 'spotify:rootlist') {
    var firstIndex = indices[0];
    var firstRow = liveList.get(firstIndex);
    var firstItem = firstRow && firstRow.get('playlist');
    var firstUri = firstItem && firstItem.uri;
    var firstUriType = firstUri && liburi.fromString(firstUri).type;
    var isFolder = firstUriType === liburi.Type.FOLDER;

    if (isFolder) {

      // Add all indices for the folder contents and the end marker
      if (indices.length === 1) {
        var length = getFolderLength(liveList, firstUri, firstIndex);
        for (var i = 1; i <= length; i++) {
          indices.push(firstIndex + i);
        }
      }

      // Abort the move operation if it only contains moving a folder start
      // marker, since moving folders should always move the entire folder.
      // Aborting by returning zero indices.
      if (indices.length === 1) {
        indices.length = 0;
        return;
      }

      var lastRow = liveList.get(indices[indices.length - 1]);
      var lastItem = lastRow && lastRow.get('playlist');
      var lastUri = lastItem && lastItem.uri;

      // Abort the move operation if moving a folder and the last item to move
      // is not the end marker for the folder. Aborting by returning zero
      // indices.
      if (lastUri !== firstUri + ':end') {
        indices.length = 0;
        return;
      }
    }
  }
}

/**
 * Check if only dragging playlists that are being followed already.
 *
 * @param {MouseEvent} event Some kind of drag and drop event.
 *
 * @return {boolean} True if only followed playlists are being dragged.
 */
function hasOnlyFollowedPlaylists(event) {
  var types = event.dataTransfer.types;
  if (types.indexOf('text/x-spotify-only-followed-playlists') > -1) {
    return true;
  }

  return false;
}

/**
 * Check if dragging a folder into (or below) itself.
 *
 * @param {MouseEvent} event Some kind of drag and drop event.
 * @param {string} location The location of the cursor in relation to the list.
 *     This can be either 'inside' or 'below'. The value 'below' means that the
 *     cursor was below the last list found in the DOM.
 *
 * @return {boolean} True if dragging into the same folder being dragged.
 */
function isInsideDraggedFolder(event, location) {
  if (dragFolderElement) {
    var rowNode = location === 'below' ? getLastRowNode() : getRowNode(event);
    if (rowNode) {
      var targetIndex = +rowNode.getAttribute('data-index');
      if (location === 'inside') {
        if (!isBelowMiddleOfNode(event.clientY, rowNode)) {
          targetIndex--;
        }
      }
      if (isIndexInsideDraggedFolder(targetIndex)) {
        return true;
      }
    }
  }

  return false;
}

/**
 * Check if dragging onto the bottom half of a folder.
 *
 * @param {MouseEvent} event Some kind of drag and drop event.
 *
 * @return {boolean} True if dragging onto the bottom half.
 */
function isInFolderBottomHalf(event) {
  var folderNode = getFolderNode(event);
  if (folderNode) {
    return isBelowMiddleOfNode(event.clientY, folderNode);
  }
  return false;
}

/**
 * Check if the position is below the middle of the node.
 *
 * @param {number} y The Y position relative to the viewport.
 * @param {HTMLElement} node DOM node to check against.
 *
 * @return {boolean} True if the position is below.
 */
function isBelowMiddleOfNode(y, node) {
  var rect = node.getBoundingClientRect();
  return y >= rect.top + rect.height / 2;
}

/**
 * Check if the index is inside (or right below) the folder being dragged.
 *
 * @param {number} index Current target index.
 *
 * @return {boolean} True if the target index is inside the folder.
 */
function isIndexInsideDraggedFolder(index) {
  if (!dragFolderElement) return false;

  var liveList = live('spotify:rootlist').get('rows');
  if (!liveList) return false;

  var folderUri = dragFolderElement.getAttribute('data-uri');
  if (!folderUri) return false;

  var start = +dragFolderElement.getAttribute('data-index');
  var end = start + getFolderLength(liveList, folderUri, start);

  if (start > -1 && end > start && index >= start && index <= end) {
    return true;
  }

  return false;
}

/**
 * Check if the MIME types in the drag event matches the MIME types for the
 * specified drop target.
 *
 * @param {MouseEvent} event Some kind of drag and drop event.
 * @param {HTMLElement} node A DOM node.
 *
 * @return {boolean} True if the element matches the event.
 */
function isMatchingTarget(event, node) {
  var eventTypes = event.dataTransfer.types;
  var nodeTypes = node.getAttribute(ATTR_TARGET);

  if (nodeTypes) {
    var matching = intersection(nodeTypes.split('|'), eventTypes);
    if (matching.length > 0) return true;
  }

  return false;
}

/**
 * Get the folder row node from the event.
 *
 * @param {MouseEvent} event Some kind of drag and drop event.
 *
 * @return {HTMLElement?} DOM node for the folder, or null if not found.
 */
function getFolderNode(event) {
  var rowNode = getRowNode(event);
  if (rowNode) {
    var uri = rowNode.getAttribute('data-uri');
    var uriObject = liburi.from(uri);
    if (uriObject && uriObject.type === liburi.Type.FOLDER) {
      return rowNode;
    }
  }

  return null;
}

/**
 * Get the list row element from the event target.
 * If the event target itself isn't a list row, it will step out in the parent
 * tree until it finds a row.
 *
 * @param {MouseEvent} event Some kind of drag and drop event.
 *
 * @return {HTMLElement?} The list row element, or null if not found.
 */
function getRowNode(event) {
  return event.target.closest(SELECTOR_LIST_ITEM);
}

/**
 * Get the last list row from the last list in the DOM.
 *
 * @return {HTMLElement?} The list row element, or null if not found.
 */
function getLastRowNode() {
  var lists = $(SELECTOR_LIST);
  var lastList = lists && lists[lists.length - 1];
  if (lastList) {
    var listItems = $(lastList).search(SELECTOR_LIST_ITEM);
    var lastItem = listItems && listItems[listItems.length - 1];
    if (lastItem) return lastItem;
  }

  return null;
}

/**
 * Get the length of a folder, including the contents and end marker, but not
 * the start marker.
 *
 * @param {LiveList} liveList Live list for the rootlist.
 * @param {string} folderUri The folder URI.
 * @param {number} index The index where the folder start marker is.
 *
 * @return {number} The length of the folder.
 */
function getFolderLength(liveList, folderUri, index) {
  var rowAtIndex = liveList.get(index);
  var itemAtIndex = rowAtIndex && rowAtIndex.get('playlist');
  var uriAtIndex = itemAtIndex && itemAtIndex.uri;
  if (uriAtIndex !== folderUri) return 0;

  var folderEndUri = folderUri + ':end';
  var amount = 0;

  for (var i = index + 1, l = liveList.length; i < l; i++) {
    amount++;

    rowAtIndex = liveList.get(i);
    itemAtIndex = rowAtIndex && rowAtIndex.get('playlist');
    uriAtIndex = itemAtIndex && itemAtIndex.uri;
    if (uriAtIndex === folderEndUri) break;
  }

  return amount;
}

/**
 * Attach the module.
 */
function attach() {
  eventModel.delegate('dragstart', SELECTOR_DRAGGABLE, onDragStart);
  eventModel.delegate('dragend', 'body', onDragEnd);

  hooks.add('set-drag-data', onSetDragData);
  hooks.add('list-drop-validation', onListDropValidation);
  hooks.add('target-validation', onTargetValidation);
  hooks.add('get-move-indices', onGetMoveIndices);
}

/**
 * Detach the module.
 */
function detach() {
  eventModel.undelegate('dragstart', SELECTOR_DRAGGABLE, onDragStart);
  eventModel.undelegate('dragend', 'body', onDragEnd);

  hooks.remove('set-drag-data', onSetDragData);
  hooks.remove('list-drop-validation', onListDropValidation);
  hooks.remove('target-validation', onTargetValidation);
  hooks.remove('get-move-indices', onGetMoveIndices);
}

exports.attach = attach;
exports.detach = detach;

},{"../../../spotify-elements":259,"../../../spotify-live":439,"../../selection":304,"../util/eventmodel":277,"../util/hooks":278,"mout/array/intersection":634,"spotify-liburi":707}],271:[function(require,module,exports){
/**
 * @module spotify-events/dragndrop/custom/sortlist
 * @private
 */
'use strict';

var $ = require('../../../spotify-elements');
var liburi = require('spotify-liburi');
var sortUriUtils = require('../../../spotify-live-sort-uri');

var hooks = require('../util/hooks');
var eventModel = require('../util/eventmodel');
var selection = require('../../selection');

var SELECTOR_DRAGGABLE = 'a, [draggable]';
var SELECTOR_LIST = '[data-list]';

var dragSelectionState = null;

/**
 * Handler for the dragstart event.
 *
 * @param {MouseEvent} event Event object for a dragstart event.
 * @param {HTMLElement} target The target element.
 */
function onDragStart(event, target) {
  dragSelectionState = selection.getIndicesPerList();
}

/**
 * Handler for ending a drag.
 *
 * @param {MouseEvent} event A dragend event object.
 * @param {HTMLElement} target DOM element for the drop target.
 */
function onDragEnd(event, target) {
  dragSelectionState = null;
}

/**
 * Hook handler for validating a list drop.
 *
 * @param {Object} result Result object. Setting the `valid` property will
 *     affect whether the drop is allowed.
 * @param {MouseEvent} event Some kind of drag and drop event.
 * @param {HTMLElement} list A DOM node marked up as a list.
 * @param {string} location The location of the cursor in relation to the list.
 *     This can be either 'inside' or 'below'. The value 'below' means that the
 *     cursor was below the last list found in the DOM.
 */
function onListDropValidation(result, event, list, location) {
  var contextUri = list.getAttribute('data-uri');
  if (!contextUri) return;

  // Dropping in sorted lists should not allow specific drop positions,
  if (sortUriUtils.isValid(contextUri) && event.type !== 'drop') {
    result.valid = false;
  }
}

/**
 * Hook handler for validating a list target.
 *
 * @param {Object} result Result object. Setting the `valid` property will
 *     affect whether the drop is allowed.
 * @param {HTMLElement} list A DOM node marked up as a list.
 */
function onListTargetValidation(result, list) {
  var contextUri = list.getAttribute('data-uri');
  if (!contextUri) return;

  // Bail on all invalid uris
  if (!sortUriUtils.isValid(contextUri)) return;

  // We should support incoming drag and drops as well, like from the
  // now playing view for example
  if (!dragSelectionState) {
    result.valid = true;
    return;
  }

  // Dropping in sorted lists should be allowed as a regular target
  if (dragSelectionState.length === 1) {
    if (dragSelectionState[0].uri !== contextUri) {
      result.valid = true;
    }
  }
}

/**
 * Hook handler for checking if a list is a track list.
 *
 * @param {Object} result Result object. Setting the `valid` property will
 *     affect the result.
 * @param {LiveList} liveList The live list.
 * @param {string} contextUri The context URI.
 */
function onIsListOfTracks(result, liveList, contextUri) {
  if (sortUriUtils.isValid(contextUri)) {
    var originUri = sortUriUtils.getOriginUri(contextUri);
    if (originUri) {
      var uriObject = liburi.from(originUri);
      var type = uriObject && uriObject.type;
      if (type === liburi.Type.PLAYLIST) {
        result.valid = true;
      }
    }
  }
}

/**
 * Attach the module.
 */
function attach() {
  eventModel.delegate('dragstart', SELECTOR_DRAGGABLE, onDragStart);
  eventModel.delegate('dragend', 'body', onDragEnd);

  hooks.add('list-drop-validation', onListDropValidation);
  hooks.add('list-target-validation', onListTargetValidation);
  hooks.add('is-list-of-tracks', onIsListOfTracks);
}

/**
 * Detach the module.
 */
function detach() {
  eventModel.undelegate('dragstart', SELECTOR_DRAGGABLE, onDragStart);
  eventModel.undelegate('dragend', 'body', onDragEnd);

  hooks.remove('list-drop-validation', onListDropValidation);
  hooks.remove('list-target-validation', onListTargetValidation);
  hooks.remove('is-list-of-tracks', onIsListOfTracks);
}

exports.attach = attach;
exports.detach = detach;

},{"../../../spotify-elements":259,"../../../spotify-live-sort-uri":437,"../../selection":304,"../util/eventmodel":277,"../util/hooks":278,"spotify-liburi":707}],272:[function(require,module,exports){
(function (global){
/**
 * @module spotify-events/dragndrop/dragdata
 * @private
 */
'use strict';

var live = require('../../spotify-live');
var liburi = require('spotify-liburi');
var forOwn = require('mout/object/forOwn');

var selection = require('../selection');
var hooks = require('./util/hooks');
var eventModel = require('./util/eventmodel');
var itemText = require('./util/itemtext');
var getLogContext = require('../util/get-log-context');

var SELECTOR_DRAGGABLE = 'a, [draggable]';

/**
 * Handler for the dragstart event.
 *
 * @param {MouseEvent} event Event object for a dragstart event.
 * @param {HTMLElement} target The target element.
 */
function onDragStart(event, target) {
  var isSelected = selection.isNodeSelected(target);

  if (isSelected) {
    var uris = selection.getUris();
    if (uris.length > 0) {
      var state = selection.getIndicesPerList();
      var singleContext = state.length === 1;
      var context = singleContext ? state[0] && state[0].uri : null;
      if (context) {
        setEventData(event, uris, null, context, getLogContext(target));
      } else {
        setEventData(event, uris, null, null, getLogContext(target));
      }
    }
  } else {
    var uri = target.getAttribute('data-uri');
    if (!uri) {
      var uriObject = liburi.from(target.getAttribute('href'));
      uri = uriObject ? uriObject.toURI() : '';
    }
    var dragText = itemText.getForElement(target);

    if (uri) {
      setEventData(event, [uri], [dragText], null, getLogContext(target));
    }
  }
}

/**
 * Set drag data on the event.
 * This includes regular MIME types such as plain text and html, but also custom
 * Spotify MIME types that can be used to detect the dragged content while
 * dragging (you can't access data while dragging, so there is no other way
 * to detect what kind of items are being dragged).
 *
 * @param {MouseEvent} event Event object for a dragstart event.
 * @param {Array.<string>} uris Array of Spotify URIs.
 * @param {Array.<string>=} opt_dragTexts Optional drag texts for each URI.
 * @param {string=} opt_context Optional context URI.
 * @param {string=} opt_logContext Optional log context.
 */
function setEventData(event, uris, opt_dragTexts, opt_context, opt_logContext) {
  var urlsPerMimeType = getUrlsPerMimeType(uris);
  var urls = getUrlsForUris(uris);
  var urlList = urls.join('\n');
  var html = getLinkHTML(uris, urls, opt_dragTexts);

  // We set this before others because safari overrides any data that was set
  // before this particular mimetype was set.
  event.dataTransfer.setData('text/uri-list', urlList);

  for (var type in urlsPerMimeType) {
    var urlsForType = urlsPerMimeType[type];
    event.dataTransfer.setData(type, urlsForType.join('\n'));
  };

  event.dataTransfer.setData('text/plain', urlList);
  event.dataTransfer.setData('text/html', html);

  if (opt_context) {

    // Provide the context as drag data. This can be used in the drop event to
    // know where it came from.
    event.dataTransfer.setData('text/x-spotify-data-context', opt_context);
  }

  if (opt_logContext) {
    event.dataTransfer.setData('text/x-spotify-data-log-context', opt_logContext);
  }

  event.dataTransfer.setData('text/x-spotify-data-app-uri', global.__spotify && global.__spotify.app_uri || null);

  hooks.run('set-drag-data', event, uris, opt_context);
}

/**
 * Get URLs for the URIs organized by MIME type.
 *
 * @param  {Array.<string>} uris Array of Spotify URIs.
 *
 * @return {Object.<string, Array.<string>>} Object of arrays of URLs.
 */
function getUrlsPerMimeType(uris) {
  var urlsPerMimeType = {};
  for (var i = 0, l = uris.length; i < l; i++) {
    var uri = uris[i];
    var type = getMimeType(uri);
    var urlsForType = urlsPerMimeType[type] || (urlsPerMimeType[type] = []);
    urlsForType.push(getShareLink(uri));
  }
  return urlsPerMimeType;
}

/**
 * Get URLs for the URIs.
 *
 * @param {Array.<string>} uris Array of Spotify URIs.
 *
 * @return {Array.<string>} Array of share URLs.
 */
function getUrlsForUris(uris) {
  var urls = new Array(uris.length);
  for (var i = 0, l = uris.length; i < l; i++) {
    urls[i] = getShareLink(uris[i]);
  }
  return urls;
}

/**
 * Get a share URL from a Spotify URI.
 *
 * @param {string} uri A Spotify URI.
 *
 * @return {string} The share URL.
 */
function getShareLink(uri) {
  var uriObject = liburi.from(uri);
  return uriObject ? uriObject.toOpenURL() : uri;
}

/**
 * Get the custom Spotify MIME type for a URI.
 *
 * @param {string} uri A Spotify URI.
 *
 * @return {string} The MIME type.
 */
function getMimeType(uri) {
  var type = 'text/x-spotify-';

  var uriObject = liburi.from(uri);
  if (uriObject) {
    var uriType = uriObject.type;

    if (uriType === liburi.Type.TRACK || uriType === liburi.Type.LOCAL) {
      return type + 'tracks';
    }
    if (uriType === liburi.Type.ALBUM || uriType === liburi.Type.LOCAL_ALBUM) {
      return type + 'albums';
    }
    if (uriType === liburi.Type.ARTIST || uriType === liburi.Type.LOCAL_ARTIST) {
      return type + 'artists';
    }
    if (uriType === liburi.Type.USER || uriType === liburi.Type.PROFILE) {
      return type + 'users';
    }
    if (uriType === liburi.Type.PLAYLIST) {
      return type + 'playlists';
    }
    if (uriType === liburi.Type.FOLDER) {
      return type + 'folders';
    }
    if (uriType === liburi.Type.STATION) {
      return type + 'stations';
    }
  }

  return type + 'unknown';
}

/**
 * Get the HTML for links to the given URLs.
 *
 * @param {Array.<string>} uris Array of Spotify URIs.
 * @param {Array.<string>} urls Array of Spotify URLs used for sharing.
 * @param {Array.<string>=} opt_dragTexts Optional drag texts for each URI.
 *
 * @return {string} String of HTML.
 */
function getLinkHTML(uris, urls, opt_dragTexts) {
  var html = '';

  for (var i = 0, l = uris.length; i < l; i++) {
    var textFromArgs = opt_dragTexts && opt_dragTexts[i];
    var text = textFromArgs || itemText.getForUri(uris[i]);

    html += '<a href="' + urls[i] + '">' + text + '</a>';

    if (i < uris.length - 1) {
      html += '<br>';
    }
  }

  return html;
}

/**
 * Attach the module.
 */
function attach() {
  eventModel.delegate('dragstart', SELECTOR_DRAGGABLE, onDragStart);
}

/**
 * Detach the module.
 */
function detach() {
  eventModel.undelegate('dragstart', SELECTOR_DRAGGABLE, onDragStart);
}

exports.attach = attach;
exports.detach = detach;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../spotify-live":439,"../selection":304,"../util/get-log-context":321,"./util/eventmodel":277,"./util/hooks":278,"./util/itemtext":279,"mout/object/forOwn":663,"spotify-liburi":707}],273:[function(require,module,exports){
/**
 * @module spotify-events/dragndrop/dragimage
 * @private
 */
'use strict';

var live = require('../../spotify-live');
var liburi = require('spotify-liburi');
var defer = require('prime/defer');

var selection = require('../selection');
var eventModel = require('./util/eventmodel');
var itemText = require('./util/itemtext');

// TODO: Actually load localized strings.
// Problem now is that we need quickstart-spotify to load @loc paths, and that
// makes it harder to run unit tests.
var localizedStrings = require('../strings/en.json');

var SELECTOR_DRAGGABLE = 'a, [draggable]';
var DRAGIMAGE_POS_X = -10;
var DRAGIMAGE_POS_Y = -5;

var dragImageElement = null;
var dragImageShelter = null;

/**
 * Handler for the dragstart event.
 *
 * @param {MouseEvent} event Event object for a dragstart event.
 * @param {HTMLElement} target The target element.
 */
function onDragStart(event, target) {
  var isSelected = selection.isNodeSelected(target);

  var text = '';

  if (isSelected) {
    var uris = selection.getUris();
    if (uris.length === 1) {
      text = itemText.getForUri(uris[0]);
    } else {
      text = uris.length + ' ' + getLocalizedTypeFromUris(uris);
    }
  } else {
    text = itemText.getForElement(target);
  }

  var dragImage = getDragImage(text);

  event.dataTransfer.setDragImage(dragImage, DRAGIMAGE_POS_X, DRAGIMAGE_POS_Y);

  removeDragImage();
}

/**
 * Get the drag image element with the specified text set.
 *
 * @param {string} text The text to set.
 *
 * @return {HTMLElement} The drag image element.
 */
function getDragImage(text) {
  if (!dragImageElement) {
    dragImageElement = document.createElement('div');
    dragImageElement.className = 'dnd-image';
  }
  if (!dragImageShelter) {
    dragImageShelter = document.createElement('div');
    dragImageShelter.className = 'dnd-image-shelter';
  }

  dragImageElement.textContent = text;

  document.body.appendChild(dragImageElement);
  document.body.appendChild(dragImageShelter);

  return dragImageElement;
}

/**
 * Remove the drag image element and the shelter it hides behind.
 * This must be delayed a tick to let the native drag and drop handling
 * get the time to read the image.
 */
function removeDragImage() {
  defer(function () {
    if (dragImageElement && dragImageElement.parentNode) {
      dragImageElement.parentNode.removeChild(dragImageElement);
    }
    if (dragImageShelter && dragImageShelter.parentNode) {
      dragImageShelter.parentNode.removeChild(dragImageShelter);
    }
  });
}

/**
 * Get a localized type for a list of URIs.
 * This could be for example 'tracks', 'playlists' etc. Falls back to 'items'
 * if the URIs are of different type. As this is only called when we drag
 * multiple items, we don't need the singular form.
 *
 * @param {Array.<string>} uris Array of URIs.
 *
 * @return {string} The localized type.
 */
function getLocalizedTypeFromUris(uris) {
  var type = 'item';

  var uriObjectForFirst = liburi.from(uris[0]);
  var typeForFirst = uriObjectForFirst && uriObjectForFirst.type;

  if (typeForFirst) {
    type = typeForFirst;

    for (var i = 0, l = uris.length; i < l; i++) {
      var uriObject = liburi.from(uris[i]);
      if (!uriObject || uriObject.type !== typeForFirst) {
        type = 'item';
        break;
      }
    }
  }

  // User URIs are parsed with type 'profile' in liburi, but we want 'user'
  if (type === 'profile') {
    type = 'user';
  }

  var pluralType = type + 's';

  // Get the localized version of the plural type
  var localized = localizedStrings['drag_tooltip_many_' + pluralType];

  // If the type was not the generic 'items' type and no localization was found,
  // localize the generic type.
  if (!localized && pluralType !== 'items') {
    localized = localizedStrings['drag_tooltip_many_items'];
  }

  // Return the localized type, or if nothing is found, fall back to the type
  return localized || pluralType;
}

/**
 * Attach the module.
 */
function attach() {
  eventModel.delegate('dragstart', SELECTOR_DRAGGABLE, onDragStart);
}

/**
 * Detach the module.
 */
function detach() {
  eventModel.undelegate('dragstart', SELECTOR_DRAGGABLE, onDragStart);
}

exports.attach = attach;
exports.detach = detach;

},{"../../spotify-live":439,"../selection":304,"../strings/en.json":312,"./util/eventmodel":277,"./util/itemtext":279,"prime/defer":676,"spotify-liburi":707}],274:[function(require,module,exports){
/**
 * @module spotify-events/dragndrop
 */
'use strict';

var dragDataModule = require('./dragdata');
var dragImageModule = require('./dragimage');
var targetModule = require('./target');
var listModule = require('./list');

// Custom behaviors
var sortlistModule = require('./custom/sortlist');
var rootlistModule = require('./custom/rootlist');

/**
 * Attach the module.
 */
function attach() {
  dragDataModule.attach();
  dragImageModule.attach();
  targetModule.attach();
  listModule.attach();

  sortlistModule.attach();
  rootlistModule.attach();
}

/**
 * Detach the module.
 */
function detach() {
  dragDataModule.detach();
  dragImageModule.detach();
  targetModule.detach();
  listModule.detach();

  sortlistModule.detach();
  rootlistModule.detach();
}

exports.attach = attach;
exports.detach = detach;
exports.update = function () {};

},{"./custom/rootlist":270,"./custom/sortlist":271,"./dragdata":272,"./dragimage":273,"./list":275,"./target":276}],275:[function(require,module,exports){
/**
 * @module spotify-events/dragndrop/list
 * @private
 */
'use strict';

var $ = require('../../spotify-elements');
var intersection = require('mout/array/intersection');
var flow = require('finally');
var Range = require('../../spotify-range2');
var live = require('../../spotify-live');
var liburi = require('spotify-liburi');
var listOperations = require('spotify-live-list-operations');

var hooks = require('./util/hooks');
var eventModel = require('./util/eventmodel');
var selection = require('../selection');

var SELECTOR_DROP_TARGET = '[data-drop-target]';
var SELECTOR_LIST = '[data-list]';
var SELECTOR_LIST_ITEM = '[data-list-item]';
var SELECTOR_LIST_TARGET = SELECTOR_DROP_TARGET + ', body';
var SELECTOR_DRAGGABLE = 'a, [draggable]';
var ATTR_TARGET = 'data-drop-target';

var dropIndicator = null;
var draggedLinkContext = null;
var disabledLists = {};

/**
 * Handler for the dragstart event.
 *
 * @param {MouseEvent} event Event object for a dragstart event.
 * @param {HTMLElement} target The target element.
 */
function onDragStart(event, target) {
  draggedLinkContext = null;

  // clear the selectionState cache
  cachedSelectionState.clear();

  var matchingTarget = getMatchingTarget(event);
  if (matchingTarget) {
    var isInList = $(matchingTarget).matches(SELECTOR_LIST);
    if (isInList) {
      var uri = matchingTarget.getAttribute('data-uri');

      // Dragging a link from inside a list needs to store the list context,
      // since it is not allowed to drop a dragged link inside the same list.
      if (target.tagName.toLowerCase() === 'a') {
        draggedLinkContext = uri;
      }

      // Dragging is disallowed for lists where we're waiting for a list move
      // to finish. This is to prevent multiple moves to be called before the
      // response from the first comes back.
      if (disabledLists[uri]) {
        event.preventDefault();
        return;
      }

      var rowNode = getRowNode(event);
      if (rowNode) {
        var index = getTargetIndex(event.clientY, rowNode);
        if (index !== -1) {
          event.dataTransfer.setData('text/x-spotify-data-log-source-index', index);
        }
      }
    }
  }
}

/**
 * Handler for dragging over a drop target.
 *
 * @param {MouseEvent} event A dragover event object.
 * @param {HTMLElement} target DOM element for the drop target. This can be the
 *     body element even if it's not a drop target.
 */
function onDragOver(event, target) {
  var positionedListDrop = false;
  var rowNode = null;

  var isBody = target === document.body;
  var list = null;
  if (isBody) list = getListTargetFromBody(event);else list = getMatchingListTarget(event);

  // If we found a list from the event, we must validate if it's allowed to drop
  // in the list.
  if (list) {
    var location = isBody ? 'below' : 'inside';
    if (validateListDrop(event, list, location)) {
      if (isBody) {
        positionedListDrop = true;
      } else {
        rowNode = getRowNode(event);
        if (rowNode) {
          positionedListDrop = true;
        }
      }
    }
  }

  if (positionedListDrop) {
    event.preventDefault();

    if (isBody) showDropIndicatorBelowList(list);else if (rowNode) showDropIndicatorForRow(rowNode, event.clientY);
  } else {
    hideDropIndicator();

    var listHookResult = { valid: false };
    if (list) {
      hooks.run('list-target-validation', listHookResult, list);
    }

    // The list might be accepted as a drop target even if dropping in a
    // specific position was not accepted. In that case we need to prevent the
    // default action to tell the browser that we accept drops here.
    if (listHookResult.valid) {
      event.preventDefault();
    } else if (!isBody && list) {
      var targetHookResult = { valid: false };
      hooks.run('target-validation', targetHookResult, event, target);

      // If we know that dropping is not allowed here at all, we need to remove
      // the drop effect from the cursor. This is mainly since the handler in
      // targets.js has already handled the event and accepted it, which sets
      // the drop effect.
      if (!targetHookResult.valid) {
        event.dataTransfer.dropEffect = 'none';
      }
    }
  }
}

/**
 * Handler for dragging out from a drop target.
 *
 * @param {MouseEvent} event A dragleave event object.
 * @param {HTMLElement} target DOM element for the drop target.
 */
function onDragLeave(event, target) {
  hideDropIndicator();
}

/**
 * Handler for ending a drag.
 *
 * @param {MouseEvent} event A dragend event object.
 * @param {HTMLElement} target DOM element for the drop target.
 */
function onDragEnd(event, target) {
  hideDropIndicator();
  draggedLinkContext = null;
}

/**
 * Handler for dropping onto a drop target.
 *
 * @param {MouseEvent} event A drop event object.
 * @param {HTMLElement} target DOM element for the drop target.
 */
function onDrop(event, target) {
  hideDropIndicator();

  var isBody = target === document.body;
  var list = null;
  if (isBody) list = getListTargetFromBody(event);else list = getMatchingListTarget(event);

  if (list) {
    var location = isBody ? 'below' : 'inside';
    if (validateListDrop(event, list, location)) {
      var contextUri = list.getAttribute('data-uri');
      if (contextUri) {
        performListChangesForEvent(event, list, contextUri, location);
        event.handled = true;
      }
    }
  }
}

/**
 * Show the drop indicator below the provided list element.
 *
 * @param {HTMLElement} list A list element.
 */
function showDropIndicatorBelowList(list) {
  var listRect = list.getBoundingClientRect();
  showDropIndicator(listRect.left, listRect.bottom, listRect.width);
}

/**
 * Show the drop indicator above or below a list row.
 *
 * @param {HTMLElement} rowNode A list row element.
 * @param {number} cursorY The cursor Y position, relative to the viewport.
 */
function showDropIndicatorForRow(rowNode, cursorY) {
  var belowMiddle = isBelowMiddleOfNode(cursorY, rowNode);
  var rowRect = rowNode.getBoundingClientRect();
  var x = rowRect.left;
  var y = rowRect.top + (belowMiddle ? rowRect.height : 0);
  showDropIndicator(x, y, rowRect.width);
}

/**
 * Show the drop indicator line for the specified row and cursor position.
 * If the cursor position is below the middle of the row, the indicator will be
 * placed below the row, otherwise above the row.
 *
 * @param {number} x The X position relative to the viewport.
 * @param {number} y The Y position relative to the viewport.
 * @param {number} width The width of the indicator.
 */
function showDropIndicator(x, y, width) {

  // Don't use window.scroll X/Y because cross browser issues.
  // https://developer.mozilla.org/en-US/docs/Web/API/Window.scrollY
  var indicatorAbsX = window.pageXOffset + x;
  var indicatorAbsY = window.pageYOffset + y;
  var indicatorWidth = width;

  if (!dropIndicator) {
    dropIndicator = document.createElement('div');
    dropIndicator.className = 'tr-drag-indicator';
  }

  dropIndicator.style.left = indicatorAbsX + 'px';
  dropIndicator.style.width = indicatorWidth + 'px';
  dropIndicator.style.top = indicatorAbsY + 'px';

  if (!dropIndicator.parentNode) {
    document.body.appendChild(dropIndicator);
  }
}

/**
 * Hide the drop indicator.
 */
function hideDropIndicator() {
  if (dropIndicator && dropIndicator.parentNode) {
    dropIndicator.parentNode.removeChild(dropIndicator);
  }
}

/**
 * Perform the list changes that are needed from the drop event.
 *
 * @param {MouseEvent} event A drop event.
 * @param {HTMLElement} list The list DOM node.
 * @param {string} contextUri The context URI for the list.
 * @param {string} location The location of the cursor in relation to the list.
 *     This can be either 'inside' or 'below'. The value 'below' means that the
 *     cursor was below the last list found in the DOM.
 */
function performListChangesForEvent(event, list, contextUri, location) {
  var liveList = live(contextUri).get('rows');
  if (!liveList) return;

  var targetIndex = 0;

  if (location === 'below') {
    var lastRowNode = getLastRowFromLastList();

    // Dropping below a list without rows will use target index 0
    if (lastRowNode) {
      targetIndex = getTargetIndex(event.clientY, lastRowNode);
    }
  } else {
    var rowNode = getRowNode(event);
    if (!rowNode) return;
    targetIndex = getTargetIndex(event.clientY, rowNode);
  }

  var sourceContext = event.dataTransfer.getData('text/x-spotify-data-context');
  var isSameContext = sourceContext && sourceContext === contextUri;

  if (isSameContext) {
    performMoveChanges(contextUri, liveList, targetIndex);
  } else {
    performInsertChanges(event, list, contextUri, liveList, targetIndex);
  }
  event.data = {
    targetIndex: targetIndex
  };
}

/**
 * Move the selected items to a target index in the list.
 *
 * @param {string} contextUri The context URI of the list.
 * @param {LiveList} liveList The live list for the context.
 * @param {number} targetIndex The target index in the list.
 */
function performMoveChanges(contextUri, liveList, targetIndex) {
  var indices = getMoveIndices(contextUri, liveList);

  // Selection can be nothing. This can happen if you select a row, drag it
  // and before dropping, the row is removed by something else (on another
  // device perhaps). Dropping should in that case not perform any action.
  // Similarly, if dragging multiple rows and some of the rows are removed
  // while dragging, only the rows that are still in the list will be moved.
  if (indices.length === 0) return;

  var operations = listOperations.getMoveOperations(indices, targetIndex);

  // If the list changed while dragging, it might happen that we end up
  // dropping at the same index as we're dragging from, which would give
  // us no operations to perform.
  if (operations.length === 0) return;

  liveList.publish(operations);

  temporarilyDisableList(contextUri, liveList);
}

/**
 * Insert items from the event into the list at the target index.
 *
 * @param {MouseEvent} event A drop event.
 * @param {HTMLElement} list The list DOM node.
 * @param {string} contextUri The context URI for the list.
 * @param {LiveList} liveList The live list for the context.
 * @param {number} targetIndex The target index in the list.
 */
function performInsertChanges(event, list, contextUri, liveList, targetIndex) {
  getInsertValues(event, list, liveList, contextUri, function (error, values) {
    if (error) return;
    if (values.length === 0) return;

    var operations = [{ type: 'insert', index: targetIndex, values: values }];

    liveList.publish(operations);

    temporarilyDisableList(contextUri, liveList);
  });
}

/**
 * Check if dropping at the current position in a list is allowed.
 *
 * @param {MouseEvent} event Some kind of drag and drop event.
 * @param {HTMLElement} list A DOM node marked up as a list.
 * @param {string} location The location of the cursor in relation to the list.
 *     This can be either 'inside' or 'below'. The value 'below' means that the
 *     cursor was below the last list found in the DOM.
 *
 * @return {boolean} True if it's a valid drop position.
 */
function validateListDrop(event, list, location) {

  // All positions are valid if we're not dragging from a context in the first
  // place. If we do have a context though, we need to validate the position.
  var types = event.dataTransfer.types;
  var isDraggingFromContext = types.indexOf('text/x-spotify-data-context') > -1;
  if (isDraggingFromContext) {
    if (!validatePotentialOperations(event, list, location)) {
      return false;
    }
  }

  var uri = list.getAttribute('data-uri');
  if (uri && draggedLinkContext === uri) {
    return false;
  }

  var result = { valid: true };
  hooks.run('list-drop-validation', result, event, list, location);

  return !!result.valid;
}

/**
 * Simple wrapper to cache calls to selection.getIndicesPerList()
 *
 * @return {Object} The result of selection.getIndicesPerList()
 */
var cachedSelectionState = function () {
  var cache = {
    lastTime: 0,
    lastValue: null
  };
  var CACHE_TIMEOUT = 500;

  return {
    get: function get() {
      var now = Date.now();

      if (now - cache.lastTime > CACHE_TIMEOUT) {
        cache = {
          lastValue: selection.getIndicesPerList(),
          lastTime: now
        };
      }

      return cache.lastValue;
    },
    clear: function clear() {
      cache.lastTime = 0;
    }
  };
}();

/**
 * Check if dropping at the current event position would actually result in
 * operations that would change the list.
 *
 * @param {MouseEvent} event Some kind of drag and drop event.
 * @param {HTMLElement} list A DOM node marked up as a list.
 * @param {string} location The location of the cursor in relation to the list.
 *     This can be either 'inside' or 'below'. The value 'below' means that the
 *     cursor was below the last list found in the DOM.
 *
 * @return {boolean} True if it would result in a change.
 */
function validatePotentialOperations(event, list, location) {
  // get a cached version of the selectionState
  var selectionState = cachedSelectionState.get();

  // Dropping inside the only selected range inside the only container that
  // has a selection is not allowed, as that would result in no change.
  if (selectionState.length === 1) {

    // Dropping inside a different context is always fine
    var contextUri = list.getAttribute('data-uri');
    if (contextUri !== selectionState[0].uri) {
      return true;
    }

    var selectedRanges = Range.fromIndices(selectionState[0].indicesWithHidden);

    if (selectedRanges.length === 1) {
      var selectedRange = selectedRanges[0];

      // Include the next row in the selected range to handle holding on the
      // top part of the next row, which would be a no-op. The bottom part of
      // the previous row will be taken care of by the code below.
      selectedRange.update(selectedRange.start, selectedRange.end + 1);

      var rowNode = location === 'below' ? getLastRowFromLastList() : getRowNode(event);
      if (rowNode) {
        var targetIndex = getTargetIndex(event.clientY, rowNode);
        if (targetIndex > -1) {
          var targetRange = new Range(targetIndex, targetIndex + 1);

          // If the target index is inside the selected range, it's not allowed
          // to drop, as that would be a no-op.
          if (targetRange.contained(selectedRange)) {
            return false;
          }
        }
      }
    }
  }

  return true;
}

/**
 * Get the drop target element that is matching the event target and the drag
 * MIME types of the event. This will start with the event target and step
 * outwards in the DOM tree to find the first matching element.
 *
 * @param {MouseEvent} event Some kind of drag and drop event.
 *
 * @return {HTMLElement?} The element or null if not found.
 */
function getMatchingTarget(event) {
  var currentNode = event.target;

  while (currentNode) {
    if (isMatchingTarget(event, currentNode)) {
      return currentNode;
    }
    currentNode = currentNode.parentElement;
  }

  return null;
}

/**
 * Get the list element that is matching the event target and the drag MIME
 * types of the event. This will start with the event target and step outwards
 * in the DOM tree to find the first matching element.
 *
 * @param {MouseEvent} event Some kind of drag and drop event.
 *
 * @return {HTMLElement?} The list element or null if not found.
 */
function getMatchingListTarget(event) {
  var currentNode = event.target;

  while (currentNode) {
    var isList = $(currentNode).matches(SELECTOR_LIST);
    if (isList && isMatchingTarget(event, currentNode)) {
      return currentNode;
    }
    currentNode = currentNode.parentElement;
  }

  return null;
}

/**
 * Get a valid list target from the end of body.
 *
 * @param {MouseEvent} event Some kind of drag and drop event.
 *
 * @return {HTMLElement?} The list element or null if not found.
 */
function getListTargetFromBody(event) {
  var lastList = getLastListNode();
  if (lastList) {
    var sameParent = event.target.contains(lastList);
    if (sameParent && isMatchingTarget(event, lastList)) {
      if (isBelowNode(event.clientX, event.clientY, lastList)) {
        return lastList;
      }
    }
  }

  return null;
}

/**
 * Get the list row element from the event target.
 * If the event target itself isn't a list row, it will step out in the parent
 * tree until it finds a row.
 *
 * @param {MouseEvent} event Some kind of drag and drop event.
 *
 * @return {HTMLElement?} The list row element, or null if not found.
 */
function getRowNode(event) {
  return event.target.closest(SELECTOR_LIST_ITEM);
}

/**
 * Get the last list row from the last list in the DOM.
 *
 * @return {HTMLElement?} The list row element, or null if not found.
 */
function getLastRowFromLastList() {
  var lastList = getLastListNode();
  if (lastList) {
    var listItems = $(lastList).search(SELECTOR_LIST_ITEM);
    var lastItem = listItems && listItems[listItems.length - 1];
    if (lastItem) return lastItem;
  }

  return null;
}

/**
 * Get the last list in the DOM.
 *
 * @return {HTMLElement?} The list element, or null if not found.
 */
function getLastListNode() {
  var lists = $(SELECTOR_LIST);
  var lastList = lists && lists[lists.length - 1];
  return lastList || null;
}

/**
 * Get the target index based on a cursor position and the row that the cursor
 * is on.
 *
 * @param {number} y The Y position relative to the viewport.
 * @param {HTMLElement} rowNode The DOM node for the row.
 *
 * @return {number} The target index or -1 if not found.
 */
function getTargetIndex(y, rowNode) {
  var index = rowNode.getAttribute('data-index');

  if (index === null) {
    index = -1;
  } else {
    index = parseInt(index, 10);

    if (isNaN(index)) {
      index = -1;
    } else {
      // If cursor is in the bottom part of the row, dropping will place items
      // after the row, so we need to increment the index.
      if (isBelowMiddleOfNode(y, rowNode)) {
        index++;
      }
    }
  }

  return index;
}

/**
 * Get the indices of the rows to move.
 *
 * @param {string} contextUri The context URI.
 * @param {LiveList} liveList The live list to be changed.
 *
 * @return {Array.<number>} Array of indices.
 */
function getMoveIndices(contextUri, liveList) {
  // As we need the indices, we must use the current selection state,
  // since the list might have changed since the start of the drag.
  // We are only in this function if we are dragging in the same
  // context, so the current selection state will always be valid.
  var selectionState = selection.getIndicesPerList();
  if (selectionState.length !== 1) return [];

  var firstContainer = selectionState[0];
  var selectedIndices = firstContainer.indices;
  var indices = selectedIndices.slice();

  if (indices.length === 0) return [];

  hooks.run('get-move-indices', contextUri, liveList, indices);

  // The indices must be sorted for the utility that creates the list operations
  indices.sort(function (a, b) {
    return a - b;
  });

  return indices;
}

/**
 * Get the values to use for insertion in the list. This will get the event data
 * for the matching MIME types.
 *
 * @param {MouseEvent} event A drop event.
 * @param {HTMLElement} list The list DOM node.
 * @param {LiveList} liveList The live list for the context.
 * @param {string} contextUri The context URI for the list.
 * @param {Function} callback A callback function. The data argument will be an
 *     array of object values.
 */
function getInsertValues(event, list, liveList, contextUri, callback) {
  var eventTypes = event.dataTransfer.types;
  var listTypes = list.getAttribute(ATTR_TARGET);
  if (!listTypes) return callback(null, []);

  var matchingTypes = intersection(listTypes.split('|'), eventTypes);
  if (matchingTypes.length === 0) return callback(null, []);

  var data = getDataFromTypes(event, matchingTypes);

  var isTrackList = isListOfTracks(liveList, contextUri);

  getRowsFromData(data, isTrackList, function (error, rows) {
    if (error) return callback(error);

    callback(null, rows);
  });
}

/**
 * Get the event data associated with the provided MIME types.
 *
 * @param {MouseEvent} event Some kind of drag and drop event.
 * @param {Array.<string>} types Array of MIME types.
 *
 * @return {Object.<string, Array>} Object where key is MIME type and value is
 *     array of values (URIs).
 */
function getDataFromTypes(event, types) {
  var data = {};

  for (var i = 0, l = types.length; i < l; i++) {
    var type = types[i];
    var itemsInData = data[type] = [];

    // A MIME type that starts with text/x-spotify is always containing a list
    // of Open URLs separated by '\n'.
    var hasURIs = type.indexOf('text/x-spotify') === 0;

    var dataForType = event.dataTransfer.getData(type);
    var items = hasURIs ? dataForType.split('\n') : [dataForType];
    for (var n = 0, len = items.length; n < len; n++) {
      var item = items[n];
      if (hasURIs) {
        var uriObject = liburi.from(item);
        if (uriObject) {
          itemsInData.push(uriObject.toURI());
        }
      } else {
        itemsInData.push(item);
      }
    }
  }

  return data;
}

/**
 * Get list row data from the event data. This might expand items if the list
 * is a track list (dropping an album into a track list will expand the album
 * into its tracks and return track rows instead).
 *
 * @param {Object.<string, Array>} data Data from drop event.
 * @param {boolean} isTrackList True if the list is a track list.
 * @param {Function} callback A callback function. The data argument will be an
 *     array of object values.
 */
function getRowsFromData(data, isTrackList, callback) {
  var flowFunctions = [];

  if (data['text/x-spotify-tracks']) {
    flowFunctions.push(function () {
      this.done(null, getRowObjects('track', data['text/x-spotify-tracks']));
    });
  }

  if (data['text/x-spotify-albums']) {
    flowFunctions.push(function () {
      var albums = data['text/x-spotify-albums'];
      if (isTrackList) fetchListTrackRows(albums, this);else this.done(null, getRowObjects('album', albums));
    });
  }

  if (data['text/x-spotify-playlists']) {
    flowFunctions.push(function () {
      var playlists = data['text/x-spotify-playlists'];
      if (isTrackList) fetchListTrackRows(playlists, this);else this.done(null, getRowObjects('playlist', playlists));
    });
  }

  if (data['text/x-spotify-artists']) {
    flowFunctions.push(function () {
      this.done(null, getRowObjects('artist', data['text/x-spotify-artists']));
    });
  }

  if (data['text/x-spotify-users']) {
    flowFunctions.push(function () {
      this.done(null, getRowObjects('user', data['text/x-spotify-users']));
    });
  }

  flow(flowFunctions).finally(function (error) {
    if (error) return callback(error);

    var arrays = Array.prototype.slice.call(arguments, 1);
    var rows = [];
    rows = rows.concat.apply(rows, arrays);

    callback(null, rows);
  });
}

/**
 * Fetch the track rows from a set of list URIs. This is for the expansion of
 * for example an album into the tracks of the album.
 *
 * @param {Array.<string>} listUris Array of list URIs.
 * @param {Object} control Flow control object.
 */
function fetchListTrackRows(listUris, control) {
  flow().parallel(listUris, function (listUri) {
    var innerControl = this;
    live(listUri).query('rows(track(uri))', function (error, data) {
      if (error) return innerControl.done(null, []);
      var rows = data.rows.map(function (row) {
        return live(row);
      });
      innerControl.done(null, rows);
    }, live.ASAP);
  }).finally(function (error) {
    if (error) return control.done(null, []);
    var arrays = Array.prototype.slice.call(arguments, 1);
    var rows = [];
    rows = rows.concat.apply(rows, arrays);
    control.done(null, rows);
  });
}

/**
 * Fetch the live object for the row of an item.
 *
 * @param {string} itemType The type of an item (for example 'track').
 * @param {Array.<string>} uris Array of item URIs.
 *
 * @return {Array.<LiveObject>} Array of row live objects.
 */
function getRowObjects(itemType, uris) {
  return uris.map(function (uri) {
    var row = {};
    row[itemType] = { uri: uri };
    return live(row);
  });
}

/**
 * Check if the list is a track list.
 *
 * @param {LiveList} liveList The live list.
 * @param {string} contextUri The context URI for the list.
 *
 * @return {boolean} True if the list is a track list.
 */
function isListOfTracks(liveList, contextUri) {
  var uriObject = liburi.from(contextUri);
  var type = uriObject && uriObject.type;
  if (type === liburi.Type.PLAYLIST) return true;

  var result = { valid: false };
  hooks.run('is-list-of-tracks', result, liveList, contextUri);

  if (!result.valid) {
    var firstRow = liveList.get(0);
    var firstTrack = firstRow && firstRow.get('track');
    if (firstTrack) return true;
  }

  return !!result.valid;
}

/**
 * Check if the position is below the bottom edge of the node.
 *
 * @param {number} x The X position relative to the viewport.
 * @param {number} y The Y position relative to the viewport.
 * @param {HTMLElement} node DOM node to check against.
 *
 * @return {boolean} True if the position is below.
 */
function isBelowNode(x, y, node) {
  var rect = node.getBoundingClientRect();
  var below = y >= rect.bottom;
  var betweenX = x >= rect.left && x <= rect.right;
  return below && betweenX;
}

/**
 * Check if the position is below the middle of the node.
 *
 * @param {number} y The Y position relative to the viewport.
 * @param {HTMLElement} node DOM node to check against.
 *
 * @return {boolean} True if the position is below.
 */
function isBelowMiddleOfNode(y, node) {
  var rect = node.getBoundingClientRect();
  return y >= rect.top + rect.height / 2;
}

/**
 * Check if the MIME types in the drag event matches the MIME types for the
 * specified drop target.
 *
 * @param {MouseEvent} event Some kind of drag and drop event.
 * @param {HTMLElement} node A DOM node.
 *
 * @return {boolean} True if the element matches the event.
 */
function isMatchingTarget(event, node) {
  var eventTypes = event.dataTransfer.types;
  var nodeTypes = node.getAttribute(ATTR_TARGET);

  if (nodeTypes) {
    var matching = intersection(nodeTypes.split('|'), eventTypes);
    if (matching.length > 0) return true;
  }

  return false;
}

/**
 * Temporarily disable drag and dropping inside a list until the move or insert
 * is done. This is to prevent multiple operations to be called before the
 * response from the first comes back. We consider the operation done when we
 * receive the next update event, since it's very tricky to know when this
 * specific move is done. To prevent possible errors with being disabled
 * infinitely, we will enable it again after a certain timeout. This could
 * happen for example if the live list is switched out for a new list, in which
 * case we won't get the update event.
 *
 * @param {string} contextUri The context URI.
 * @param {LiveList} liveList The live list that was changed.
 */
function temporarilyDisableList(contextUri, liveList) {

  disabledLists[contextUri] = true;

  var timer;

  var handler = function handler(operations) {
    clearTimeout(timer);
    liveList.off('update', handler);

    // Wait slighly longer to allow the change to trickle down to DOM
    setTimeout(function () {
      delete disabledLists[contextUri];
    }, 100);
  };

  liveList.on('update', handler);

  timer = setTimeout(handler, 500);
}

/**
 * Attach the module.
 */
function attach() {
  eventModel.delegate('dragstart', SELECTOR_DRAGGABLE, onDragStart);
  eventModel.delegate('dragover', SELECTOR_LIST_TARGET, onDragOver);
  eventModel.delegate('dragleave', SELECTOR_LIST_TARGET, onDragLeave);
  eventModel.delegate('dragend', 'body', onDragEnd);
  eventModel.delegate('drop', SELECTOR_LIST_TARGET, onDrop);
}

/**
 * Detach the module.
 */
function detach() {
  eventModel.undelegate('dragstart', SELECTOR_DRAGGABLE, onDragStart);
  eventModel.undelegate('dragover', SELECTOR_LIST_TARGET, onDragOver);
  eventModel.undelegate('dragleave', SELECTOR_LIST_TARGET, onDragLeave);
  eventModel.undelegate('dragend', 'body', onDragEnd);
  eventModel.undelegate('drop', SELECTOR_LIST_TARGET, onDrop);
}

exports.attach = attach;
exports.detach = detach;

},{"../../spotify-elements":259,"../../spotify-live":439,"../../spotify-range2":489,"../selection":304,"./util/eventmodel":277,"./util/hooks":278,"finally":533,"mout/array/intersection":634,"spotify-liburi":707,"spotify-live-list-operations":708}],276:[function(require,module,exports){
(function (global){
/**
 * @module spotify-events/dragndrop/target
 * @private
 */
'use strict';

var $ = require('../../spotify-elements');
var liburi = require('spotify-liburi');
var defer = require('prime/defer');

var center = require('../center');
var eventModel = require('./util/eventmodel');
var hooks = require('./util/hooks');
var getLogContext = require('../util/get-log-context');
var UserDragAndDropInteraction1 = require('../../spotify-logger/messages/UserDragAndDropInteraction1');

var SELECTOR_DROP_TARGET = '[data-drop-target]';
var SELECTOR_DRAGGABLE = 'a, [draggable]';
var ATTR_TARGET = 'data-drop-target';
var ATTR_NO_CLASSNAME = 'data-drop-no-classname';
var CLASSNAME_ACTIVE = 'drop-target-active';

var longHoldTimerId = 0;
var longHoldTimerDuration = 1000;
var draggedElement = null;
var lastEnteredElement = null;

/**
 * Handler for starting to drag.
 *
 * @param {MouseEvent} event A dragstart event object.
 * @param {HTMLElement} node The draggable DOM element.
 */
function onDragStart(event, node) {
  draggedElement = node;
  lastEnteredElement = null;
}

/**
 * Handler for ending a drag.
 *
 * @param {MouseEvent} event A dragend event object.
 * @param {HTMLElement} target DOM element for the drop target.
 */
function onDragEnd(event, target) {
  draggedElement = null;
  lastEnteredElement = null;

  stopLongHoldTimer();
  removeAnyActiveClass();
}

/**
 * Handler for dragging into a drop target.
 *
 * @param {MouseEvent} event A dragenter event object.
 * @param {HTMLElement} target DOM element for the drop target.
 */
function onDragEnter(event, target) {
  if (validateTarget(event, target)) {
    setEnter(event, target);
  }
}

/**
 * Handler for dragging out from a drop target.
 *
 * @param {MouseEvent} event A dragleave event object.
 * @param {HTMLElement} target DOM element for the drop target.
 */
function onDragLeave(event, target) {
  if (validateTarget(event, target)) {
    setLeave(event, target);
  }
}

/**
 * Handler for dragging over a drop target.
 *
 * @param {MouseEvent} event A dragover event object.
 * @param {HTMLElement} target DOM element for the drop target.
 */
function onDragOver(event, target) {
  if (validateTarget(event, target)) {

    // Tell the event that we are accepting drops on this target
    event.preventDefault();

    // Since other code might have set the dropEffect to something else,
    // we need to override that, since we're now accepting drops
    event.dataTransfer.dropEffect = 'copy';

    setEnter(event, target);

    // If the target is not valid, remove any styling for active drop target
  } else {
      setLeave(event, target);
    }
}

/**
 * Handler for dropping on a drop target.
 *
 * @param {MouseEvent} event A drop event object.
 * @param {HTMLElement} target DOM element for the drop target.
 */
function onDrop(event, target) {
  stopLongHoldTimer();

  // Dropping should remove active target class name.
  // Dropping outside of a target doesn't need this, as the target is only
  // active when hovering it.
  removeAnyActiveClass();

  if (validateTarget(event, target)) {
    var types = getMimeTypesForTarget(event, target);
    var dropData = getDropData(event, types);
    var sourceUri = event.dataTransfer.getData('text/x-spotify-data-context') || null;
    var sourceLogContext = event.dataTransfer.getData('text/x-spotify-data-log-context') || null;
    var sourceAppUri = event.dataTransfer.getData('text/x-spotify-data-app-uri') || null;
    var sourceIndex = parseInt(event.dataTransfer.getData('text/x-spotify-data-log-source-index'), 0);
    if (isNaN(sourceIndex)) sourceIndex = null;

    var targetUriNode = target.closest('[data-uri]');
    var targetUri = targetUriNode && targetUriNode.getAttribute('data-uri') || null;
    var targetLogContext = getLogContext(target);
    var targetAppUri = global.__spotify && global.__spotify.app_uri || null;

    // Give any other delegates a chance to handle the drop, and if so pass
    // that info along in the event.
    defer(function () {
      center.emit('drop', {
        handled: event.handled,
        node: target,
        sourceUri: sourceUri,
        targetUri: targetUri,
        data: dropData
      });

      var firstItem = dropData[Object.keys(dropData)[0]][0];
      var itemType = liburi.from(firstItem).type;
      var numberOfItems = Object.keys(dropData).reduce(function (sum, key) {
        return sum + dropData[key].length;
      }, 0);
      var targetIndex = event.data && event.data.targetIndex || null;

      UserDragAndDropInteraction1.log({
        item_type: itemType,
        item_uri: firstItem,
        number_items: numberOfItems,
        source_view_uri: sourceAppUri,
        source_uri: sourceUri,
        source_index: sourceIndex,
        source_component: sourceLogContext,
        target_view_uri: targetAppUri,
        target_uri: targetUri,
        target_index: targetIndex,
        target_component: targetLogContext
      });
    });
  }

  // Prevent navigation on drop
  event.preventDefault();

  // Reset here since our multi-frame architecture means we're not guaranteed
  // to have gotten a dragstart event in this frame prior to dropping.
  lastEnteredElement = null;
}

/**
 * Set target to be entered, including setting style and sending event.
 *
 * @param {MouseEvent} event A dragenter event object.
 * @param {HTMLElement} target DOM element for the drop target.
 */
function setEnter(event, target) {
  if (target === lastEnteredElement) {
    return;
  }

  lastEnteredElement = target;

  if (!target.hasAttribute(ATTR_NO_CLASSNAME)) {
    $(target).addClass(CLASSNAME_ACTIVE);
  }

  var types = getMimeTypesForTarget(event, target);
  center.emit('dragenter', { node: target, types: types });

  startLongHoldTimer(target, types);
}

/**
 * Set target to be left, including removing style and sending event.
 *
 * @param {MouseEvent} event A dragleave event object.
 * @param {HTMLElement} target DOM element for the drop target.
 */
function setLeave(event, target) {
  if (target !== lastEnteredElement) {
    return;
  }

  lastEnteredElement = null;

  if (!target.hasAttribute(ATTR_NO_CLASSNAME)) {
    $(target).removeClass(CLASSNAME_ACTIVE);
  }

  var types = getMimeTypesForTarget(event, target);
  center.emit('dragleave', { node: target, types: types });

  stopLongHoldTimer();
}

/**
 * Check if the drop target matches the MIME types for the event.
 *
 * @param {MouseEvent} event Some kind of drag and drop event.
 * @param {HTMLElement} target DOM element for the drop target.
 *
 * @return {boolean} True if the target is valid.
 */
function validateTarget(event, target) {

  // The element being dragged is not accepted as a drop target
  if (target === draggedElement) {
    return false;
  }

  var types = getMimeTypesForTarget(event, target);

  if (types.length) {
    var result = { valid: true };
    hooks.run('target-validation', result, event, target);

    if (result.valid) {
      return true;
    }
  }

  return false;
}

/**
 * Get the data associated with the drop, grouped by MIME type.
 * If the data contained Spotify URLs, they will be converted to Spotify URIs.
 *
 * @param {MouseEvent} event Event object for a drop event.
 * @param {Array.<string>} types Array of MIME types.
 *
 * @return {Object.<string, Array.<string>>} Data object of arrays of item
 *     URIs, grouped by MIME type.
 */
function getDropData(event, types) {
  var data = {};

  for (var i = 0, l = types.length; i < l; i++) {
    var itemsInData = data[types[i]] = [];
    var dataForType = event.dataTransfer.getData(types[i]);
    var hasURIs = types[i].indexOf('text/x-spotify') === 0;
    var items = hasURIs ? dataForType.split('\n') : [dataForType];

    for (var n = 0, len = items.length; n < len; n++) {
      var item = items[n];
      if (hasURIs) {
        var uriObject = liburi.from(item);
        if (uriObject) item = uriObject.toURI();
      }
      if (item) itemsInData.push(item);
    }
  }

  var hasContextData = types.indexOf('text/x-spotify-data-context') > -1;
  if (hasContextData) {
    data['text/x-spotify-data-context'] = [event.dataTransfer.getData('text/x-spotify-data-context')];
  }

  return data;
}

/**
 * Start a timer for emitting an event for long-hold on a target.
 * If one is already started, it will use the previous timer and not restart it.
 *
 * @param {HTMLElement} target A DOM element for the drop target.
 * @param {Array.<string>} types Array of MIME types.
 */
function startLongHoldTimer(target, types) {

  // Don't start a new timer if we already have one running
  if (longHoldTimerId) return;

  longHoldTimerId = setTimeout(function () {
    center.emit('dragover-long', { node: target, types: types });
  }, longHoldTimerDuration);
}

/**
 * Stop any running timer for emitting an event for long-hold on a target.
 */
function stopLongHoldTimer() {
  clearTimeout(longHoldTimerId);

  // Reset the timer ID so we can know that there is no timer running
  longHoldTimerId = 0;
}

/**
 * Remove the active class name from any element that has it.
 */
function removeAnyActiveClass() {
  var active = $('.' + CLASSNAME_ACTIVE);
  if (active) {
    active.removeClass(CLASSNAME_ACTIVE);
  }
}

/**
 * Get the MIME types that are matching both the drag event and the target.
 *
 * @param {MouseEvent} event Any kind of drag and drop event.
 * @param {HTMLElement} target A DOM element.
 *
 * @return {Array.<string>} Array of MIME types.
 */
function getMimeTypesForTarget(event, target) {
  var mimeTypes = [];
  var dataTypes = event.dataTransfer.types;

  var targetTypes = target.getAttribute(ATTR_TARGET);
  if (targetTypes) {
    targetTypes = targetTypes.split('|');

    for (var i = 0, l = dataTypes.length; i < l; i++) {
      var type = dataTypes[i];
      if (targetTypes.indexOf(type) > -1) {
        mimeTypes.push(type);
      }
    }
  }

  return mimeTypes;
}

/**
 * Attach the module.
 */
function attach() {
  eventModel.delegate('dragstart', SELECTOR_DRAGGABLE, onDragStart);
  eventModel.delegate('dragenter', SELECTOR_DROP_TARGET, onDragEnter);
  eventModel.delegate('dragleave', SELECTOR_DROP_TARGET, onDragLeave);
  eventModel.delegate('dragover', SELECTOR_DROP_TARGET, onDragOver);
  eventModel.delegate('dragend', 'body', onDragEnd);
  eventModel.delegate('drop', SELECTOR_DROP_TARGET, onDrop);
}

/**
 * Detach the module.
 */
function detach() {
  eventModel.undelegate('dragstart', SELECTOR_DRAGGABLE, onDragStart);
  eventModel.undelegate('dragenter', SELECTOR_DROP_TARGET, onDragEnter);
  eventModel.undelegate('dragleave', SELECTOR_DROP_TARGET, onDragLeave);
  eventModel.undelegate('dragover', SELECTOR_DROP_TARGET, onDragOver);
  eventModel.undelegate('dragend', 'body', onDragEnd);
  eventModel.undelegate('drop', SELECTOR_DROP_TARGET, onDrop);
}

exports.attach = attach;
exports.detach = detach;

// Exporting for testing
var originalDuration = longHoldTimerDuration;
exports.setLongHoldDuration = function setLongHoldDuration(duration) {
  longHoldTimerDuration = duration;
};
exports.resetLongHoldDuration = function resetLongHoldDuration() {
  longHoldTimerDuration = originalDuration;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../spotify-elements":259,"../../spotify-logger/messages/UserDragAndDropInteraction1":453,"../center":268,"../util/get-log-context":321,"./util/eventmodel":277,"./util/hooks":278,"prime/defer":676,"spotify-liburi":707}],277:[function(require,module,exports){
/**
 * @module spotify-events/dragndrop/util/eventmodel
 * @private
 *
 * This module is made to be an abstraction of the event model for drag and
 * drop. It also exposes a delegation interface which allows you to only
 * listen for events for targets matching a certain selector.
 *
 * The need for this abstraction is to simplify the code listening to drag
 * and drop events.
 *
 * - The raw events we get from the browser are sometimes not that easy to
 *   work with. For example, when moving from one target to another, we get
 *   a dragenter event before the dragleave event, which can cause confusion.
 *   This abstraction flips that around, so that you always get the dragleave
 *   event before the dragenter event.
 *
 * - The raw events also trigger for children. For example, if moving the
 *   cursor from one element to one of its children, we get a dragenter event
 *   for the child element and a dragleave for the outer element. This makes
 *   it difficult to highlight drop targets based on dragenter/dragleave.
 *   This abstraction helps by making sure the handler is not called if moving
 *   to a child element inside an element that matches the selector. There
 *   is an exception though when moving to a child that is also matching a
 *   selector, the outer element is then left and the child is entered.
 *
 * @example
 * function onDragEnter(event, target) {
 *   event instanceof MouseEvent; // true
 *   target instanceof HTMLElement; // true
 *   target.matches('[data-drop-target]'); // true
 * }
 *
 * // Start listening
 * eventmodel.delegate('dragenter', '[data-drop-target]', onDragEnter);
 *
 * // Stop listening
 * eventmodel.undelegate('dragenter', '[data-drop-target]', onDragEnter);
 */
'use strict';

var $ = require('../../../spotify-elements');

var attached = {};
var delegations = {};
var movementHandlerCount = 0;

// State variables
var hasEntered = false;
var lastEnteredElement = null;
var lastEnterTarget = null;
var lastEnterEvent = null;
var wasLastEventEnter = false;

/**
 * Reset the temporary state variables used while dragging.
 */
function resetState() {
  hasEntered = false;
  lastEnteredElement = null;
  lastEnterTarget = null;
  lastEnterEvent = null;
  wasLastEventEnter = false;
}

/**
 * Generic handler for any event.
 * This function will look at the current delegations and run the handler
 * functions for the matching delegations.
 * Some events will be handled by calling a special handler, which in some cases
 * later will check for matching delegations.
 *
 * @param {Event} event Event object.
 */
function onEvent(event) {
  var handler = getPrimaryHandler(event.type);
  if (handler) {
    handler(event);
  } else {
    handleDelegationsForEvent(event);
  }
}

/**
 * Handler for a dragenter event.
 * Depending on state, this might save the event for later and call the
 * handler at a later point, to ensure that the dragenter event is sent
 * after the dragleave.
 *
 * @param {MouseEvent} event Event object for a dragenter event.
 */
function onPrimaryDragEnter(event) {
  wasLastEventEnter = true;

  if (hasEntered) {
    if (lastEnteredElement !== event.target) {
      lastEnterEvent = event;
    }
  } else {
    hasEntered = true;
    lastEnteredElement = event.target;
    handleDelegationsForEvent(event);
  }
}

/**
 * Handler for a dragleave event.
 * Depending on state, this might also trigger the handlers for a dragenter
 * event, if there was a saved event from before.
 *
 * @param {MouseEvent} event Event object for a dragleave event.
 */
function onPrimaryDragLeave(event) {
  wasLastEventEnter = false;
  lastEnteredElement = null;

  handleDelegationsForEvent(event);

  if (hasEntered) {
    if (lastEnterEvent) {
      lastEnteredElement = lastEnterEvent.target;
      handleDelegationsForEvent(lastEnterEvent);
      lastEnterEvent = null;
    } else {
      hasEntered = false;
    }
  }
}

/**
 * Handler for a drop event.
 * This is handled by a special handler only to reset some state.
 *
 * @param {MouseEvent} event Event object for a drop event.
 */
function onPrimaryDrop(event) {
  resetState();
  handleDelegationsForEvent(event);
}

/**
 * Handler for a dragend event.
 * This is handled by a special handler only to reset some state.
 *
 * @param {MouseEvent} event Event object for a drop event.
 */
function onPrimaryDragEnd(event) {
  resetState();
  handleDelegationsForEvent(event);
}

/**
 * Delegation handler for a dragenter event.
 * After matching against stored delegations, we need to do some final checking
 * before calling the user handler.
 *
 * @param {MouseEvent} event Event object for a dragenter event.
 * @param {HTMLElement} target A DOM element.
 * @param {Function} handler The user handler.
 * @param {string} selector A CSS selector string.
 */
function onDragEnter(event, target, handler, selector) {
  if (target !== lastEnterTarget) {
    lastEnterTarget = target;
    callUserHandler(event, target, handler);
  }
}

/**
 * Delegation handler for a dragleave event.
 * After matching against stored delegations, we need to do some final checking
 * before calling the user handler.
 *
 * @param {MouseEvent} event Event object for a dragleave event.
 * @param {HTMLElement} target A DOM element.
 * @param {Function} handler The user handler.
 * @param {string} selector A CSS selector string.
 */
function onDragLeave(event, target, handler, selector) {
  var shouldCallUserHandler = false;

  var lastElement = lastEnterEvent && lastEnterEvent.target;
  if (lastElement) {
    var isSameElement = target === lastElement;
    var isEnteringChild = !isSameElement && target.contains(lastElement);
    var isEnteringMatchingElement = $(lastElement).matches(selector);
    if (!isSameElement && (!isEnteringChild || isEnteringMatchingElement)) {
      shouldCallUserHandler = true;
    }
  }

  // Most often the sequence of events will be dragenter->dragenter->dragleave
  // when moving into one element and then into another element. But if the
  // sequence is just dragenter->dragleave, we should also call the user
  // handler. This would happen if there is no new entered element.
  if (!wasLastEventEnter) {
    shouldCallUserHandler = true;
  }

  if (shouldCallUserHandler) {
    lastEnterTarget = null;
    callUserHandler(event, target, handler);
  }
}

/**
 * Find matching delegations and call the handlers.
 *
 * @param {Event} event Event object.
 */
function handleDelegationsForEvent(event) {
  var type = event.type;
  var delegationData = delegations[type];

  if (delegationData && delegationData.length > 0) {

    delegationData.forEach(function (data) {
      var selector = data.selector;
      var matchingTarget = event.target.closest(selector);

      if (matchingTarget) {
        var handler = getHandler(type) || callUserHandler;
        handler(event, matchingTarget, data.handler, selector);
      }
    });
  }
}

/**
 * Call the user handler for a delegation.
 *
 * @param {Event} event Event object.
 * @param {HTMLElement} target A DOM element.
 * @param {Function} handler The user handler.
 * @param {string} selector A CSS selector string.
 */
function callUserHandler(event, target, handler, selector) {
  handler.call(exports, event, target);
}

/**
 * Get any handler that needs to be called for a raw event before looking
 * for any delegations.
 *
 * @param {string} type Event type.
 *
 * @return {Function?} The handler function or null if no special handler
 *     should be called.
 */
function getPrimaryHandler(type) {
  switch (type) {
    case 'dragenter':
      return onPrimaryDragEnter;
    case 'dragleave':
      return onPrimaryDragLeave;
    case 'dragend':
      return onPrimaryDragEnd;
    case 'drop':
      return onPrimaryDrop;
  }
  return null;
}

/**
 * Get any handler that needs to be called after matching delegations,
 * but before calling the user handler.
 *
 * @param {string} type Event type.
 *
 * @return {Function?} The handler function or null if no special handler
 *     should be called.
 */
function getHandler(type) {
  switch (type) {
    case 'dragenter':
      return onDragEnter;
    case 'dragleave':
      return onDragLeave;
  }
  return null;
}

/**
 * Check if the event type is one of the events that need special handling
 * for movement (enter/leave events).
 *
 * @param {string} type Event type.
 *
 * @return {boolean} True if the type is a movement type, false otherwise.
 */
function isMovementType(type) {
  switch (type) {
    case 'dragenter':
      return true;
    case 'dragleave':
      return true;
    case 'dragend':
      return true;
    case 'drop':
      return true;
  }
  return false;
}

/**
 * Attach a global event listener on document for the specified type.
 *
 * @param {string} type Event type.
 */
function attach(type) {
  if (attached[type]) return;
  attached[type] = true;
  document.addEventListener(type, onEvent, false);
}

/**
 * Detach a global event listener on document for the specified type.
 *
 * @param {string} type Event type.
 */
function detach(type) {
  if (!attached[type]) return;
  attached[type] = false;
  document.removeEventListener(type, onEvent, false);
}

/**
 * Start listening for an event via event delegation for the specified
 * selector.
 *
 * @example
 * var selector = '[data-drop-target]';
 * eventModel.delegate('dragenter', selector, function(event, target) {
 *   event instanceof MouseEvent; // true
 *   target instanceof HTMLElement; // true
 *   target.matches('[data-drop-target]'); // true
 * });
 */
function delegate(type, selector, handler) {
  if (isMovementType(type)) {
    movementHandlerCount++;
    if (movementHandlerCount === 1) {
      attach('dragenter');
      attach('dragleave');
      attach('dragend');
      attach('drop');
    }
  } else if (!attached[type]) {
    attach(type);
  }

  if (!delegations[type]) delegations[type] = [];

  delegations[type].push({ selector: selector, handler: handler });
}

/**
 * Stop listening for an event via event delegation for the specified
 * selector and handler.
 *
 * @example
 * eventModel.undelegate('dragenter', '[data-drop-target]', handler);
 */
function undelegate(type, selector, handler) {
  if (isMovementType(type)) {
    movementHandlerCount = Math.max(0, movementHandlerCount - 1);
    if (movementHandlerCount === 0) {
      detach('dragenter');
      detach('dragleave');
      detach('dragend');
      detach('drop');
    }
  }

  var delegationsForType = delegations[type];
  if (delegationsForType) {
    for (var i = 0, l = delegationsForType.length; i < l; i++) {
      var data = delegationsForType[i];
      if (data.selector === selector && data.handler === handler) {
        delegationsForType.splice(i, 1);
        break;
      }
    }

    if (!isMovementType && delegationsForType.length === 0) {
      detach(type);
    }
  }
}

exports.delegate = delegate;
exports.undelegate = undelegate;

},{"../../../spotify-elements":259}],278:[function(require,module,exports){
/**
 * Hooks
 *
 * Almost like an event emitter. You can add hooks for different ids, and when
 * a hook for an ID is run, the handlers are called.
 *
 * @module spotify-events/dragndrop/util/hooks
 * @private
 */
'use strict';

var hooks = {};

/**
 * Add a hook handler for a specific hook ID.
 *
 * @param {string} id The hook ID.
 * @param {function} handler The handler function. The hook sets the arguments.
 */
function add(id, handler) {
  if (!hooks[id]) hooks[id] = [];
  hooks[id].push(handler);
}

/**
 * Remove a hook handler for a specific hook ID.
 *
 * @param {string} id The hook ID.
 * @param {function} handler The handler function.
 */
function remove(id, handler) {
  if (hooks[id]) {
    var index = hooks[id].indexOf(handler);
    if (index > -1) {
      hooks[id].splice(index, 1);
    }
  }
}

/**
 * Run the hook handlers for a specific hook ID.
 *
 * @param {string} id The hook ID.
 * @param {...*} var_args Arguments to pass to the handlers.
 */
function run(id, var_args) {
  var handlers = hooks[id];
  if (handlers && handlers.length > 0) {
    var args = Array.prototype.slice.call(arguments, 1);
    for (var i = 0, l = handlers.length; i < l; i++) {
      handlers[i].apply(null, args);
    }
  }
}

exports.add = add;
exports.remove = remove;
exports.run = run;

},{}],279:[function(require,module,exports){
/**
 * @module spotify-events/dragndrop/util/itemtext
 * @private
 */
'use strict';

var live = require('../../../spotify-live');
var liburi = require('spotify-liburi');

/**
 * Get the text for a URI.
 *
 * @param {string} uri Any URI.
 *
 * @return {string} The text.
 */
function getForUri(uri) {
  var uriObject = liburi.from(uri);
  if (!uriObject) return '';

  var type = uriObject.type;

  if (type === liburi.Type.TRACK || type === liburi.Type.LOCAL) {
    return getForTrack(uri);
  } else if (type === liburi.Type.ARTIST || type === liburi.Type.LOCAL_ARTIST) {
    return getForArtist(uri);
  } else if (type === liburi.Type.ALBUM || type === liburi.Type.LOCAL_ALBUM) {
    return getForAlbum(uri);
  } else if (type === liburi.Type.PLAYLIST) {
    return getForPlaylist(uri);
  } else if (type === liburi.Type.USER || type === liburi.Type.PROFILE) {
    return getForUser(uri);
  } else if (type === liburi.Type.FOLDER) {
    return getForFolder(uri);
  } else if (type === liburi.Type.STATION) {
    return getForStation(uri);
  }

  return '';
}

/**
 * Get the text for a track URI.
 *
 * Examples:
 * Track Name – First Artist, Second Artist, Third Artist (and so on...)
 * Track Name
 *
 * @param {string} uri Track URI.
 *
 * @return {string} The text.
 */
function getForTrack(uri) {
  var object = live(uri);
  var itemName = object.get('name');
  if (!itemName) return '';

  var artists = object.get('artists');
  if (!artists || artists.length === 0) return itemName;

  var artistNames = artists.get(0, artists.length).map(function (artist) {
    return artist.get('name');
  }).join(', ');
  if (!artistNames) return itemName;

  return separateDragTextItems(itemName, artistNames);
}

/**
 * Get the text for an artist URI.
 *
 * Examples:
 * Artist Name
 *
 * @param {string} uri Artist URI.
 *
 * @return {string} The text.
 */
function getForArtist(uri) {
  return live(uri).get('name') || '';
}

/**
 * Get the text for an album URI.
 *
 * Examples:
 * Artist Name – Album Name
 * Album Name
 *
 * @param {string} uri Album URI.
 *
 * @return {string} The text.
 */
function getForAlbum(uri) {
  var object = live(uri);
  var itemName = object.get('name');
  if (!itemName) return '';

  var artists = object.get('artists');
  if (!artists || artists.length === 0) return itemName;

  var artistName = artists.get(0).get('name');
  if (!artistName) return itemName;

  return separateDragTextItems(artistName, itemName);
}

/**
 * Get the text for a playlist URI.
 *
 * Examples:
 * Playlist Name – Owner Name
 * Playlist Name – owner_username
 * Playlist Name
 *
 * @param {string} uri Playlist URI.
 *
 * @return {string} The text.
 */
function getForPlaylist(uri) {
  var object = live(uri);
  var itemName = object.get('name');
  if (!itemName) return '';

  var owner = object.get('owner');
  var ownerName = owner && (owner.get('name') || owner.get('username'));
  if (!ownerName) return itemName;

  return separateDragTextItems(itemName, ownerName);
}

/**
 * Get the text for a playlist URI.
 *
 * Examples:
 * User Name
 * username
 *
 * @param {string} uri Playlist URI.
 *
 * @return {string} The text.
 */
function getForUser(uri) {
  var object = live(uri);
  var itemName = object.get('name');
  if (itemName) return itemName;

  var uriObject = liburi.fromString(uri);
  var username = uriObject && uriObject.username;
  return username || '';
}

/**
 * Get the text for a folder URI.
 *
 * Examples:
 * Folder Name
 *
 * @param {string} uri Folder URI.
 *
 * @return {string} The text.
 */
function getForFolder(uri) {
  return live(uri).get('name');
}

/**
 * Get the text for a station URI.
 *
 * Examples:
 * Station Name
 *
 * @param {string} uri Station URI.
 *
 * @return {string} The text.
 */
function getForStation(uri) {
  return live(uri).get('name');
}

/**
 * Separate two strings by the special dash ('en dash', &#8211;) we use.
 *
 * @param {string} item1 First string.
 * @param {string} item2 Second string.
 *
 * @return {string} Final string.
 */
function separateDragTextItems(item1, item2) {
  return item1 + ' – ' + item2;
}

/**
 * Get the text for an element.
 *
 * @param {HTMLElement} target The target element being dragged.
 *
 * @return {string} The drag text.
 */
function getForElement(target) {
  var title = target.getAttribute('data-drag-text');
  if (title) return title;

  var uri = target.getAttribute('data-uri');
  if (uri) {
    title = getForUri(uri);
    if (title) return title;
  }

  title = target.getAttribute('title');
  if (title) return title;

  return target.textContent;
}

exports.getForUri = getForUri;
exports.getForElement = getForElement;

},{"../../../spotify-live":439,"spotify-liburi":707}],280:[function(require,module,exports){
'use strict';

var $ = require('../spotify-elements');
var live = require('../spotify-live');
var center = require('./center');
var stickyEvents = require('./sticky');
var cosmos = require('./util/cosmos');
var merge = require('mout/object/merge');
var deepEquals = require('mout/lang/deepEquals');
var getOriginUri = require('../spotify-live-wrapped-uri').getOriginUri;
var appUtil = require('./util/app');
var shuffleMode = require('../spotify-shuffle-mode');

var SCROLL_PADDING = 8;
var STRING_FILTER_KEY = 'list-filter-string-';
var SESSION_STORAGE = 'spotify:session-storage';

function update(node) {
  if (!isAttached) return;

  node = $(node) || $(document);
  var nodes = node.matches('[data-filter]') ? [node[0]] : node.search('[data-filter]');
  if (!nodes) return;
  nodes.forEach(function (node) {
    var uri = getURI(node);
    if (!uri) return;

    // When no state is initialized for the uri, initialize it and set the string from the DOM.
    // This is the case when the playlist app loaded a URI that globally has a filter string set.
    var hasState = states[uri];
    if (!hasState) {
      var inputElement = $(node).find('input[type=text]')[0];
      var value = inputElement.value;
      if (value) {
        updateState(uri, {
          activated: true,
          enteredString: value
        });
      }
    }

    handleStale(uri);
  });
}

function handleStale(uri) {
  render(uri);
  logUsage(uri);

  var state = getState(uri);
  var stateHasBeenEmitted = deepEquals(state, lastEmittedStates[uri]);
  if (!stateHasBeenEmitted) {
    lastEmittedStates[uri] = state;
    var value = state.activated ? state.enteredString : '';
    emitFilterRequest(uri, value);
    persistFilterOnSessionStorage(uri, value);
  }
}

function render(uri) {
  var $candidateContainers = $(document).search('[data-uri] [data-filter]');
  if (!$candidateContainers) return;

  var $matchingCandidates = $candidateContainers.filter(function (container) {
    return getURI(container) === uri;
  });
  $matchingCandidates.forEach(function (mainElement) {
    var state = getState(uri);
    var inputElement = $(mainElement).find('input[type=text]')[0];
    var wrapperElement = $(mainElement).find('.h-search-wrapper')[0];
    if (state.activated) {
      if (!$(wrapperElement).hasClass('focus')) {
        $(wrapperElement).addClass('focus');

        mainElement.setAttribute('data-sticky', '');
        stickyEvents.update();
      }

      // NOTE: Setting input.value makes the cursor jump
      // which is annoying when changing typos in the
      // search field. Only set value if text ACTUALLY
      // changes:
      if (inputElement.value !== state.enteredString) {
        inputElement.value = state.enteredString;
      }
    } else {
      inputElement.blur();
      if ($(wrapperElement).hasClass('focus')) {
        $(wrapperElement).removeClass('focus');

        mainElement.removeAttribute('data-sticky');
        stickyEvents.update();
      }
      inputElement.value = '';
    }
  });
}

function focusAndSelectInput(inputElement) {

  // Only focus and select the input text if doesn't have focus already.
  if (document.activeElement != inputElement) {
    inputElement.focus();
    inputElement.select();
  }
}

function scrollIntoView(inputElement) {
  var rect = inputElement.getBoundingClientRect();

  // [SHUFFLE]
  // If sticky header is displayed, let's compensate scroll position with header's height
  // (otherwise the focused filter input might end up under the sticky header)
  var stickyHeaderOffset = 0;
  if (shuffleMode.isEnabled()) {
    var stickyHeader = $('.h-sticky-header [data-sticky-active]');
    if (stickyHeader) {
      stickyHeaderOffset = stickyHeader[0].offsetHeight;
    }
  }

  // Only scroll if the input is out of view
  var filterFieldOffset = rect.top - SCROLL_PADDING - stickyHeaderOffset;
  if (filterFieldOffset < 0 || rect.bottom > window.innerHeight) {
    window.scrollTo(0, window.pageYOffset + filterFieldOffset);
  }
}

function logUsage(uri) {
  var state = getState(uri);
  if (state.enteredString && !getState(uri).usageLogged) {
    updateState(uri, { usageLogged: true });
    // Fields must be in the same order as in logparser
    // AND all fields MUST be present or logging wont happen
    // and will fail silently. https://ghe.spotify.net/datainfra/log-parser/blob/94e6a896efa5d781b0cac54f3dcf92c9c4ee3c73/spotify/log_parser/messages_specs.py#L777

    cosmos.post({
      url: 'sp://logging/v1/log',
      body: {
        'message': 'ClientEvent',
        'version': 3,
        'fields': [window.__spotify.app_uri, // source
        'spotify-events-filter', // context
        'user:typing', // event
        'input-field', // event-version
        '', // test-version
        '', // source-version
        '', // source-vendor
        '' // json-data
        ]
      }
    });
  }
}

function emitFilterRequest(uri, value) {
  center.emit('filter-request', uri, value);
}

function persistFilterOnSessionStorage(uri, value) {
  uri = getOriginUri(uri) || uri;

  var key = STRING_FILTER_KEY + uri;
  var publish = {};
  publish[key] = value;
  live(SESSION_STORAGE).publish(publish);
}

function handleCancelClick(e) {
  clear(getURI(e.target));
}

function handleInputInput(e) {
  updateState(getURI(e.target), { enteredString: e.target.value });
}

function handleInputKeyup(e) {
  var isEscape = e.keyCode === 27;
  if (isEscape) clear(getURI(e.target));
}

function handleInputFocus(e) {
  updateState(getURI(e.target), { activated: true });
}
function handleInputFocusOut(e) {
  var state = getState(getURI(e.target));
  if (state.enteredString === '') updateState(getURI(e.target), { activated: false });
}

function clear(uri) {
  updateState(uri, { activated: false, enteredString: '' });
}

function getState(uri) {
  return states[uri] || {
    activated: false,
    enteredString: ''
  };
}

function updateState(uri, update) {
  states[uri] = merge(getState(uri), update);
  handleStale(uri);
}

function getURI(element) {
  var uri = element.getAttribute('data-uri');
  if (!uri) {
    var parents = $(element).parents('[data-uri]');
    if (parents) uri = parents[0].getAttribute('data-uri');
  }
  uri = getOriginUri(uri) || uri;

  // We use the data-uri as a key for state, but the uri of the
  // container might change to the "sorted" versions of the
  // original uri. From a filter UX state standpoint, these are the
  // same, so we normalize it here.
  return uri || null;
}

var states;
var lastEmittedStates;

var isAttached = false;
var controlMessageSubscription;
var attach = function attach() {
  if (isAttached) return;
  isAttached = true;
  states = {};
  lastEmittedStates = {};
  controlMessageSubscription = cosmos.subscribe({
    url: 'sp://messages/v1/container/control'
  }, function (_, response) {
    if (!appUtil.isActive()) return;

    var isMessageOfTypeFind = response && response.body && response.body.type === 'filter';
    if (!isMessageOfTypeFind) return;
    $('[data-filter]').forEach(function (mainElement, i) {
      updateState(getURI(mainElement), {
        activated: true
      });

      var inputElement = $(mainElement).find('input[type=text]')[0];
      if (inputElement) {

        // Only scroll first filter into view.
        if (i === 0) {
          scrollIntoView(inputElement);
        }

        focusAndSelectInput(inputElement);
      }
    });
  });

  center.on('filter-reset', clear);

  $(document).delegate('click', '[data-filter] .h-search-close', handleCancelClick);
  $(document).delegate('click', '[data-filter-reset]', handleCancelClick);
  $(document).delegate('input', '[data-filter] input', handleInputInput);
  $(document).delegate('keyup', '[data-filter] input', handleInputKeyup);
  $(document).delegate('focusin', '[data-filter] input', handleInputFocus);
  $(document).delegate('focusout', '[data-filter] input', handleInputFocusOut);
};

var detach = function detach() {
  if (!isAttached) return;
  states = null;
  controlMessageSubscription.cancel();

  center.off('filter-reset', clear);

  $(document).undelegate('click', '[data-filter] .h-search-close', handleCancelClick);
  $(document).undelegate('click', '[data-filter-reset]', handleCancelClick);
  $(document).undelegate('input', '[data-filter] input', handleInputInput);
  $(document).undelegate('keyup', '[data-filter] input', handleInputKeyup);
  $(document).undelegate('focusin', '[data-filter] input', handleInputFocus);
  $(document).undelegate('focusout', '[data-filter] input', handleInputFocusOut);
  isAttached = false;
};

// Tells native container that the current app can handle filter
// commands. Enables filter commands in the native menu,
// along with corresponding keyboard shortcuts.
var broadcast = function broadcast(enabled) {
  if (enabled === undefined) throw new Error('broadcast requires enabled argument');
  cosmos.post({
    url: 'sp://messages/v1/container/control',
    body: {
      type: 'update_menu_state',
      enable_filter_item: enabled
    }
  });
};

module.exports = {
  attach: attach,
  detach: detach,
  update: update,
  broadcast: broadcast
};

},{"../spotify-elements":259,"../spotify-live":439,"../spotify-live-wrapped-uri":438,"../spotify-shuffle-mode":491,"./center":268,"./sticky":311,"./util/app":318,"./util/cosmos":319,"mout/lang/deepEquals":646,"mout/object/merge":666}],281:[function(require,module,exports){
'use strict';

var modules = [require('./anchor'), require('./player'), require('./dragndrop'), require('./add'), require('./selection'), require('./contextmenu'), require('./navbar'), require('./offline'), require('./sticky'), require('./filter'), require('./watch'), require('./tooltip'), require('./list'), require('./menu'), require('./scroll'), require('./carousel'), require('./scrollbar'), require('./slider'), require('./select'), require('./sort'), require('./shuffle'), require('./thumbs'), require('./touch-mediaobjects'), require('./list-quick-jump')];

var events = {};

var isAttached = false;

events.update = function update(node) {
  if (!isAttached) return;

  modules.forEach(function (module) {
    module.update(node);
  });
};

events.attach = function attach() {
  if (isAttached) return;
  isAttached = true;

  modules.forEach(function (module) {
    module.attach();
  });
};

events.detach = function detach() {
  if (!isAttached) return;
  isAttached = false;

  modules.forEach(function (module) {
    module.detach();
  });
};

module.exports = events;

},{"./add":265,"./anchor":266,"./carousel":267,"./contextmenu":269,"./dragndrop":274,"./filter":280,"./list":283,"./list-quick-jump":282,"./menu":284,"./navbar":285,"./offline":286,"./player":288,"./scroll":293,"./scrollbar":298,"./select":301,"./selection":304,"./shuffle":308,"./slider":309,"./sort":310,"./sticky":311,"./thumbs":313,"./tooltip":314,"./touch-mediaobjects":315,"./watch":323}],282:[function(require,module,exports){
(function (global){
'use strict';

var center = require('./center');
var cosmos = require('./util/cosmos');
var ClientEvent3 = require('../spotify-logger/messages/ClientEvent3');

var SPACE_KEYCODE = 32;
var BACKSPACE_KEYCODE = 8;
var DELETE_KEYCODE = 46;

exports.attach = function attach() {
  document.addEventListener('keypress', onKeyPress, false);
  document.addEventListener('keydown', onKeyDown, false);
};

exports.detach = function detach() {
  document.removeEventListener('keypress', onKeyPress, false);
  document.removeEventListener('keydown', onKeyDown, false);
};

exports.update = function () {};

var selector = ':not([data-sticky-active]) > [data-list-quick-jump]';
var SEARCH_STRING_CONCATENATION_TIMEOUT = 1000;

var searchStringsByUri = {};
var searchTimeoutsByUri = {};
var searchTimestampsByUri = {};

// onKeyPress is needed to read characters properly
function onKeyPress(event) {
  if (shouldEventBeIgnored(event)) return;
  processEvent(event);
}

// onKeyDown is needed to read <backspace>
function onKeyDown(event) {
  if (shouldEventBeIgnored(event)) return;

  var isBackspace = event.keyCode === BACKSPACE_KEYCODE;

  if (!isBackspace) return;
  processEvent(event);
}

function processEvent(event) {
  var isBackspace = event.keyCode === BACKSPACE_KEYCODE;

  var letter = event.keyCode === SPACE_KEYCODE ? ' ' : String.fromCharCode(event.keyCode).trim();
  if (!letter && !isBackspace) return;

  var listNode = getListNode(event.target);
  if (!listNode) return;

  var uri = getUri(listNode);
  if (!uri) return;

  // No need to do anything if there is no active search and user presses
  // BACKSPACE, since that would temporarily disable using SPACE for toggling
  // music, even though no quick-jump was actually made (KM-10204)
  if (isBackspace && !searchStringsByUri[uri]) return;

  if (!(uri in searchStringsByUri)) searchStringsByUri[uri] = '';

  if (isBackspace) {
    searchStringsByUri[uri] = searchStringsByUri[uri].slice(0, -1);
  } else if (letter) {
    searchStringsByUri[uri] += letter;
  }

  center.emit('list-quick-jump-request', uri, searchStringsByUri[uri] || null);

  if (searchTimeoutsByUri[uri]) clearTimeout(searchTimeoutsByUri[uri]);

  if (event.keyCode === SPACE_KEYCODE) {
    event.preventDefault(); // Prevent space from scrolling page
  }

  var shortcutsToIgnore = [{ keyCode: SPACE_KEYCODE }, { keyCode: BACKSPACE_KEYCODE }, { keyCode: DELETE_KEYCODE }];

  // Tell container to ignore <space>, <backspace> and <delete> shortcuts
  // until further notice
  cosmos.post({
    url: 'sp://messages/v1/ignoreshortcuts',
    body: {
      action: 'ignore',
      shortcuts: shortcutsToIgnore
    }
  });

  searchTimeoutsByUri[uri] = setTimeout(function () {
    // Tell container to stop ignoring <space>, <backspace> and <delete>
    // shortcuts
    cosmos.post({
      url: 'sp://messages/v1/ignoreshortcuts',
      body: {
        action: 'unignore',
        shortcuts: shortcutsToIgnore
      }
    });

    delete searchStringsByUri[uri];
    delete searchTimeoutsByUri[uri];
    delete searchTimestampsByUri[uri];
    center.emit('list-quick-jump-request', uri, null);
  }, SEARCH_STRING_CONCATENATION_TIMEOUT);

  if (searchStringsByUri[uri].length <= 20) {
    var timeSinceLastLetter = Date.now() - searchTimestampsByUri[uri] || null;
    ClientEvent3.log({
      source: global.__spotify && global.__spotify.app_uri || null,
      context: uri,
      event_version: 'list-quick-jump',
      event: 'user:type',
      json_data: {
        str: searchStringsByUri[uri],
        letter: letter,
        was_backspace: isBackspace,
        time_since_last_letter: timeSinceLastLetter
      }
    });
  }

  searchTimestampsByUri[uri] = Date.now();
}

function shouldEventBeIgnored(event) {
  return event.metaKey || event.ctrlKey || event.target.matches('input, textarea, [contenteditable]');
}

function getListNode(target) {
  var listNode = target.closest(selector);
  if (!listNode) {
    var listNodes = document.querySelectorAll(selector);
    var hasOnlyOneListNode = listNodes && listNodes.length === 1;

    if (hasOnlyOneListNode) {
      listNode = listNodes[0];
    }
  }
  return listNode;
}

function getUri(listNode) {
  var uriParent = listNode.closest('[data-uri]');
  return uriParent && uriParent.getAttribute('data-uri');
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-logger/messages/ClientEvent3":451,"./center":268,"./util/cosmos":319}],283:[function(require,module,exports){
(function (global){
'use strict';

var $ = require('../spotify-elements');
var live = require('../spotify-live');
var center = require('./center');
var selection = require('./selection');
var cosmos = require('./util/cosmos');
var appUtil = require('./util/app');

var ROW_SELECTOR = '[data-list-item]';
var UNAVAILABLE_CLASS_NAME = 'unavailable';
var OFFLINE_DOWNLOADED_CLASS_NAME = 'offline-downloaded';
var OFFLINE_DOWNLOADING_CLASS_NAME = 'offline-downloading';
var OFFLINE_WAITING_CLASS_NAME = 'offline-waiting';

var storedTrackURIsForUnplayable = {};
var storedTrackURIsForOffline = {};

function updatePlayabilityForRows(uri, playable) {
  var rows = $(document).search(ROW_SELECTOR + '[data-uri="' + uri + '"]');
  if (rows) {
    updatePlayabilityForElements(rows, playable);
  }
}

function updatePlayabilityForElements(elements, playable) {
  if (playable) {
    elements.removeClass(UNAVAILABLE_CLASS_NAME);
  } else {
    elements.addClass(UNAVAILABLE_CLASS_NAME);
  }
}

function updateOfflineForRows(uri, shouldBeOffline, offlineProgress) {
  var rows = $(document).search(ROW_SELECTOR + '[data-uri="' + uri + '"]');
  if (rows) {

    // This will take an elements object as the first argument, so it can contain multiple rows
    updateOfflineForElements(rows, shouldBeOffline, offlineProgress);
  }
}

function updateOfflineForElements(elements, shouldBeOffline, offlineProgress) {

  // The track is either already downloaded or will be soon
  if (shouldBeOffline) {

    // Download done
    if (offlineProgress === 1) {
      elements.addClass(OFFLINE_DOWNLOADED_CLASS_NAME);
      elements.removeClass(OFFLINE_DOWNLOADING_CLASS_NAME);
      elements.removeClass(OFFLINE_WAITING_CLASS_NAME);

      // Waiting to be downloaded
    } else if (offlineProgress === 0) {
        elements.addClass(OFFLINE_WAITING_CLASS_NAME);
        elements.removeClass(OFFLINE_DOWNLOADED_CLASS_NAME);
        elements.removeClass(OFFLINE_DOWNLOADING_CLASS_NAME);

        // Downloading at the moment
      } else {
          elements.addClass(OFFLINE_DOWNLOADING_CLASS_NAME);
          elements.removeClass(OFFLINE_DOWNLOADED_CLASS_NAME);
          elements.removeClass(OFFLINE_WAITING_CLASS_NAME);
        }

    // The track is not supposed to be downloaded offline
  } else {
      elements.removeClass(OFFLINE_DOWNLOADED_CLASS_NAME);
      elements.removeClass(OFFLINE_DOWNLOADING_CLASS_NAME);
      elements.removeClass(OFFLINE_WAITING_CLASS_NAME);
    }
}

function updateUnplayableRows(node, opt_rows) {
  var rows = opt_rows || ($(node) || $(document)).search(ROW_SELECTOR);
  if (rows) {
    rows.forEach(function (row) {
      var uri = $(row).data('uri');

      var model = live(uri);
      var playable = model.get('playable');

      if (playable !== undefined) {
        updatePlayabilityForElements($(row), playable);
      }

      if (uri in storedTrackURIsForUnplayable) return;
      storedTrackURIsForUnplayable[uri] = true;

      model.on('update', function (properties) {
        if ('playable' in properties) {
          updatePlayabilityForRows(uri, properties.playable);
        }
      });
    });
  }
}

function updateOfflineSyncing(node, opt_rows) {
  var rows = opt_rows || ($(node) || $(document)).search(ROW_SELECTOR);
  if (rows) {
    rows.forEach(function (row) {
      var uri = $(row).data('uri');
      var model = live(uri);

      // Try to query the data sync if possible (live.ASAP), to try to set the
      // class names before adding the rows to the DOM (by the scroller), to
      // avoid flickering.
      model.query('shouldBeOffline, offlineProgress', function (error, data) {
        if (error) throw error;
        updateOfflineForElements($(row), data.shouldBeOffline, data.offlineProgress);

        if (uri in storedTrackURIsForOffline) return;
        storedTrackURIsForOffline[uri] = true;

        model.on('update', function (properties) {
          if ('shouldBeOffline' in properties || 'offlineProgress' in properties) {
            updateOfflineForRows(uri, model.get('shouldBeOffline'), model.get('offlineProgress'));
          }
        });
      }, live.ASAP);
    });
  }
}

function handleKeyDown(event) {
  if (!event.target.closest(ROW_SELECTOR) || ignoredShortcuts[JSON.stringify({ keyCode: event.keyCode })]) return;

  var shouldRemove = false;
  var isWindows = /Win/.test(global.window.navigator.userAgent);

  var isBackspace = event.keyCode === 8;
  var isDelete = event.keyCode === 46;

  if (isWindows) {
    shouldRemove = isDelete;
  } else {
    shouldRemove = isBackspace || isDelete;
  }

  if (shouldRemove) {
    removeCurrentlySelectedListItems();
  }
}

function removeCurrentlySelectedListItems() {
  var lists = selection.getIndicesPerList();
  if (lists.length > 0) {
    var firstContainerIndex = null;
    var firstIndex = null;
    lists.forEach(function (list) {
      // Delete from origin list where applicable
      // TODO: We could just remove from the list directly, without going
      // through the origin list. Removing from a sorted list will pass
      // the change on to the origin list automatically.
      if (list.origin) {
        list = list.origin;
      }
      var model = live(list.uri);

      var indices = list.indices.sort(function (a, b) {
        return a - b;
      });

      model.query('allows(removeTracks)', function (error, data) {
        if (error) throw error;
        if (!data.allows.removeTracks) return;

        model.get('rows', function (error, liveList) {
          if (error) throw error;
          var operations = indices.map(function (index, indexInArray) {
            return { type: 'remove', index: index - indexInArray, length: 1 };
          });
          liveList.publish(operations);

          if (firstIndex === null) {
            firstIndex = indices[0];
            firstContainerIndex = list.containerIndex;
          }
        });
      });
    });
  }
}

function handleScrollShow(data) {
  updateUnplayableRows(data.container, data.nodes);
  updateOfflineSyncing(data.container, data.nodes);
}

// Exported for testing
exports._classNames = {
  UNAVAILABLE: UNAVAILABLE_CLASS_NAME,
  OFFLINE_WAITING: OFFLINE_WAITING_CLASS_NAME,
  OFFLINE_DOWNLOADING: OFFLINE_DOWNLOADING_CLASS_NAME,
  OFFLINE_DOWNLOADED: OFFLINE_DOWNLOADED_CLASS_NAME
};

var isAttached = false;

exports.update = function update(node) {
  if (!isAttached) return;

  updateUnplayableRows(node);
  updateOfflineSyncing(node);
};

var doc = $(document);
var deleteSubscription;
var ignoredShortcutsSubscription;
var ignoredShortcuts = {};
exports.attach = function () {
  if (isAttached) return;
  isAttached = true;

  doc.on('keydown', handleKeyDown);
  center.on('scroll-show-before', handleScrollShow);

  deleteSubscription = cosmos.subscribe({ url: 'sp://messages/v1/container/control' }, function (error, response) {
    if (error) throw error;
    var data = response.body;
    if (data && data.type === 'delete' && appUtil.isActiveAndFocused()) {
      removeCurrentlySelectedListItems();
    }
  });

  ignoredShortcutsSubscription = cosmos.subscribe({
    url: 'sp://messages/v1/ignoreshortcuts'
  }, function (error, response) {
    if (response.body.action === 'ignore') {
      response.body.shortcuts.forEach(function (shortcut) {
        ignoredShortcuts[JSON.stringify(shortcut)] = 1;
      });
    } else if (response.body.action === 'unignore') {
      response.body.shortcuts.forEach(function (shortcut) {
        delete ignoredShortcuts[JSON.stringify(shortcut)];
      });
    }
  });
};
exports.detach = function () {
  if (!isAttached) return;
  isAttached = false;

  doc.off('keydown', handleKeyDown);
  center.off('scroll-show-before', handleScrollShow);

  if (deleteSubscription) {
    deleteSubscription.cancel();
    deleteSubscription = null;
  }
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-elements":259,"../spotify-live":439,"./center":268,"./selection":304,"./util/app":318,"./util/cosmos":319}],284:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.attach = attach;
exports.detach = detach;
exports.update = update;

var _throttle = require('./util/throttle');

var _throttle2 = _interopRequireDefault(_throttle);

var _center = require('./center');

var _center2 = _interopRequireDefault(_center);

var _spotifyNavigation = require('../spotify-navigation');

var _spotifyNavigation2 = _interopRequireDefault(_spotifyNavigation);

var _appState = require('../spotify-navigation/app-state');

var _appState2 = _interopRequireDefault(_appState);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var SELECTOR_MENU = '[data-menu]';
var SELECTOR_MENU_ITEM = '[data-menu-item]';
var SELECTOR_MENU_ITEM_DISABLED = '[data-menu-item-disabled]';
var SELECTOR_MENU_ITEM_ENABLED = '[data-menu-item]:not([data-menu-item-disabled])';
var ATTRIBUTE_MENU = 'data-menu';
var ATTRIBUTE_MENU_ITEM = 'data-menu-item';
var CLASS_SUBMENU = '.dropdown-submenu';
var CLASS_MENU = '.dropdown-menu';

var navigator = new _spotifyNavigation2.default.Navigator();

var isAttached = false;

// The state will take the following shape (a nested structure that can be any
// number of levels deep):
// {
//   menu: { // null if root menu is not open
//     node: menuNode,
//     selectedNode: menuItemNode, // or null
//     menu: { // null if a sub menu is not open
//       node: subMenuNode,
//       selectedNode: subMenuItemNode, // or null,
//       menu: null, // null if a sub menu is not open
//       parent: <back-reference>, // a reference to the object one level up
//     },
//     parent: null, // always null for the root menu
//   }
// }
var state = {
  menu: null
};

/**
 * Handler for when an element gets focused.
 *
 * @param {FocusEvent} event A focus event.
 */
function onFocus(event) {
  var targetMenu = event.target.closest(SELECTOR_MENU);
  if (targetMenu && !state.menu) {
    state.menu = {
      node: targetMenu,
      selectedNode: null,
      menu: null,
      active: true,
      parent: null
    };

    targetMenu.addEventListener('mousemove', onMouseMoveThrottled);
    targetMenu.addEventListener('mouseleave', onMouseLeave);

    // We need to ensure that before triggering the "touchstart" event in the <LI> element
    // of the node, we emulate the mouse being moved over it. This way, the listeners are
    // attached and they will fire.
    // Note: this "mouseMove" call cannot be throttled, because the "touchstart" that will
    // trigger in the <LI> will happen before the throttler fires the event. Additionally,
    // there's no need to use the throttling logic for the touchstart event.
    targetMenu.addEventListener('touchstart', onMouseMove, true);
  }
}

/**
 * Handler for when an element loses focus.
 *
 * @param {FocusEvent} event A blur event.
 */
function onBlur(event) {
  var target = event.target;
  var relatedTarget = event.relatedTarget;


  if (state.menu && target === state.menu.node) {
    // A blur on the menu (target) can mean an element inside of it gains focus.
    // No need to reset then.
    if (!relatedTarget || !target.contains(relatedTarget)) {
      hideMenu();
    }
  }
}

/**
 * Handler for when a key is pressed.
 *
 * @param {KeyboardEvent} event A keyboard event.
 */
function onKeyDown(event) {
  // Only act on events when a menu is open
  if (!state.menu) {
    return;
  }

  var keyCode = event.keyCode;
  var isEnter = keyCode === 13;
  var isEscape = keyCode === 27;
  var isUp = keyCode === 38;
  var isDown = keyCode === 40;
  var isLeft = keyCode === 37;
  var isRight = keyCode === 39;

  if (isEnter) {
    // Look for links to follow inside the current menu item.
    var activeMenuState = getStateForActiveMenu();
    var selectedMenuItem = activeMenuState.selectedNode;
    var link = selectedMenuItem && selectedMenuItem.querySelector('a[href]');
    if (link) {
      navigator.requestOpenState(new _appState2.default(link.getAttribute('href')));
    }
    emitActivateItemEvent(selectedMenuItem);
    return;
  }

  if (isEscape) {
    hideMenu();
    return;
  }

  if (isUp || isDown) {
    var _activeMenuState = getStateForActiveMenu();
    if (_activeMenuState.node) {
      var newActiveMenuItem = isDown ? getMenuItemBelow(_activeMenuState) : getMenuItemAbove(_activeMenuState);

      if (newActiveMenuItem) {
        selectItemInMenu(_activeMenuState, _activeMenuState, newActiveMenuItem);
      }
    }
    return;
  }

  if (isRight) {
    var _activeMenuState2 = getStateForActiveMenu();
    if (_activeMenuState2.selectedNode) {
      if (_activeMenuState2.selectedNode.matches(CLASS_SUBMENU)) {

        // Open the sub menu if not open already (might have been opened by the
        // mouse cursor)
        if (!_activeMenuState2.menu) {
          openSubMenu(_activeMenuState2, _activeMenuState2.selectedNode);
        }

        // Select the first item in the sub menu
        var subMenuNode = _activeMenuState2.menu.node;
        var firstItemInSubMenu =
        // We'd like to get firstElementChild to avoid text nodes, but since
        // JSDom doesn't support that, fall back to firstChild for tests.
        subMenuNode.firstElementChild || subMenuNode.firstChild;
        selectItemInMenu(_activeMenuState2, _activeMenuState2.menu, firstItemInSubMenu);
      }
    }
    return;
  }

  if (isLeft) {
    var _activeMenuState3 = getStateForActiveMenu();
    if (_activeMenuState3.parent) {
      closeSubMenuOf(_activeMenuState3.parent);
    }
    return;
  }
}

/**
 * Handler for when the mouse is moved over a menu.
 * This is only attached for the current menu (if there is a current menu).
 *
 * @param {MouseEvent} event A mouse event.
 */
function onMouseMove(event) {
  var isMenu = event.target.matches(CLASS_MENU);
  if (isMenu) {
    return;
  }

  var targetItem = event.target.closest(SELECTOR_MENU_ITEM);
  if (!targetItem) {
    return;
  }

  var targetMenu = targetItem.closest(CLASS_MENU);
  var targetMenuState = getStateForMenu(targetMenu);
  var activeMenuState = getStateForActiveMenu();

  if (targetItem === activeMenuState.selectedNode) {
    return;
  }

  if (targetItem.matches(SELECTOR_MENU_ITEM_DISABLED)) {
    deselectItemInMenu(activeMenuState);
  } else {
    selectItemInMenu(activeMenuState, targetMenuState, targetItem);
    activeMenuState = getStateForActiveMenu();
  }

  // When hovering over an item that has a sub menu, open the sub menu if not
  // open already.
  if (targetItem.matches(CLASS_SUBMENU)) {
    if (!targetMenuState.menu) {
      openSubMenu(targetMenuState, targetItem);
    }

    // When hovering over a regular item and a sub menu is currently shown, close
    // the sub menu.
  } else if (activeMenuState.menu) {
      closeSubMenuOf(activeMenuState);
    }
}
var onMouseMoveThrottled = (0, _throttle2.default)(onMouseMove);

/**
 * Handler for when the mouse leaves a menu.
 * This is only attached for the current menu (if there is a current menu).
 *
 * @param {MouseEvent} event A mouse event.
 */
function onMouseLeave(event) {
  if (!event.relatedTarget || !event.relatedTarget.closest(SELECTOR_MENU)) {
    var activeMenuState = getStateForActiveMenu();
    deselectItemInMenu(activeMenuState);
    if (activeMenuState.menu) {
      closeSubMenuOf(activeMenuState);
    }
  }
}

/**
 * Handler for when the current menu item is clicked.
 * This is only attached for the current menu item (if there is one).
 *
 * @param {MouseEvent} event A mouse event.
 */
function onItemClick(event) {
  var targetMenu = event.target.closest(CLASS_MENU);
  var targetMenuState = getStateForMenu(targetMenu);
  var itemNode = targetMenuState.selectedNode;

  emitActivateItemEvent(itemNode);
}

/**
 * In order to prevent the simulated click event when using a touchscreen,
 * we prevent default so click won't trigger. That click event would otherwise
 * trigger a click on the layer beneath since the menu is closed after activating an item.
 *
 * @param {TouchEvent} event a Touch event.
 */
function onItemTouchStart(event) {
  event.preventDefault();
  onItemClick(event);
}

/**
 * Emit a center event to activate the current item.
 *
 * @param {HTMLElement} itemNode HTML element for the item.
 */
function emitActivateItemEvent(itemNode) {
  _center2.default.emit('menu-activate-item', {
    menu: {
      id: state.menu.node.getAttribute(ATTRIBUTE_MENU) || '',
      element: state.menu.node
    },
    item: {
      id: itemNode.getAttribute(ATTRIBUTE_MENU_ITEM) || '',
      element: itemNode
    }
  });
}

/**
 * Set the current menu item to a new item.
 *
 * @param {Object} activeMenuState Menu state object for the currently active
 *   menu.
 * @param {Object} targetMenuState Menu state object for the menu where the item
 *   that is to be selected is located.
 * @param {HTMLElement} itemNode An HTML element for the menu item.
 */
function selectItemInMenu(activeMenuState, targetMenuState, itemNode) {
  var isTargetSubMenu = activeMenuState.menu === targetMenuState;
  var isTargetParentMenu = isSecondContainedInFirst(targetMenuState, activeMenuState);

  // If the item is in a sub menu we only want to remove any item event
  // listeners. Removing visual selection should only happen when moving within
  // the same menu.
  if (isTargetSubMenu) {
    removeItemListeners(activeMenuState.selectedNode);
  } else {
    deselectItemInMenu(activeMenuState);
  }

  // Deselect the currently selected item in parent menu, if moving from sub
  // menu to the parent menu.
  if (isTargetParentMenu) {
    deselectItemInMenu(targetMenuState);
  }

  activeMenuState.active = false;

  if (targetMenuState.selectedNode !== itemNode) {
    itemNode.classList.add('selected');
    addItemListeners(itemNode);
    targetMenuState.selectedNode = itemNode;
  }

  targetMenuState.active = true;
}

/**
 * Deselect any selected item in the menu represented by the passed state.
 *
 * @param {Object} menuState The menu state object.
 */
function deselectItemInMenu(menuState) {
  if (menuState.selectedNode) {
    var itemNode = menuState.selectedNode;
    itemNode.classList.remove('selected');
    removeItemListeners(itemNode);
    menuState.selectedNode = null;
  }
}

/**
 * Add the click listeners from an item node.
 *
 * @param {HTMLElement} itemNode An HTML element for the menu item.
 */
function addItemListeners(itemNode) {
  itemNode.addEventListener('click', onItemClick);
  itemNode.addEventListener('touchstart', onItemTouchStart);
}

/**
 * Remove the click listeners from an item node.
 *
 * @param {HTMLElement} itemNode An HTML element for the menu item.
 */
function removeItemListeners(itemNode) {
  itemNode.removeEventListener('click', onItemClick);
  itemNode.removeEventListener('touchstart', onItemTouchStart);
}

/**
 * Open a sub menu for the provided menu state object and item node.
 *
 * @param {Object} menuState The menu state object for the parent menu.
 * @param {HTMLElement} itemNode An HTML element for the menu item.
 */
function openSubMenu(menuState, itemNode) {
  var menuNode = itemNode.querySelector(CLASS_MENU);
  if (menuNode) {
    menuState.menu = {
      parent: menuState,
      node: menuNode,
      selectedNode: null,
      menu: null,
      active: false
    };
    menuNode.classList.add('open');
  }
}

/**
 * Close all sub menus for the provided menu state object.
 *
 * @param {Object} menuState The menu state object for the parent menu.
 */
function closeSubMenuOf(menuState) {
  // Close deeper sub menus first
  if (menuState.menu.menu) {
    closeSubMenuOf(menuState.menu);
  }

  if (menuState.menu.active) {
    menuState.menu.active = false;
    menuState.active = true;
  }

  deselectItemInMenu(menuState.menu);
  menuState.menu.node.classList.remove('open');
  menuState.menu = null;
}

/**
 * Hide the current menu by broadcasting a message via center.
 * A listener can be added via center and the handler will then really hide it.
 *
 * @example
 * center.on('menu-hide', function(event) {
 *   if (event.menu.id === 'profile-menu') {
 *     hideProfileMenu();
 *   }
 * });
 */
function hideMenu() {
  if (state.menu) {
    var menuNode = state.menu.node;

    menuNode.removeEventListener('mousemove', onMouseMoveThrottled);
    menuNode.removeEventListener('mouseleave', onMouseLeave);
    menuNode.removeEventListener('touchstart', onMouseMove, true);

    // Remove any sub menus
    var menuState = state.menu;
    while (menuState) {
      deselectItemInMenu(menuState);
      menuState.node.classList.remove('open');
      menuState = menuState.menu;
    }

    delete state.menu;

    _center2.default.emit('menu-hide', {
      menu: {
        id: menuNode.getAttribute(ATTRIBUTE_MENU) || '',
        element: menuNode
      }
    });
  }
}

/**
 * Test if the second menu state object is contained in the second state object.
 *
 * @param {Object} first Menu state object.
 * @param {Object} second Menu state object.
 *
 * @return {Boolean}        True if it is.
 */
function isSecondContainedInFirst(first, second) {
  var statePart = first.menu;
  while (statePart && statePart !== second) {
    statePart = statePart.menu;
  }

  return !!statePart;
}

/**
 * Get the menu state object for the provided menu node. This assumes the node
 * is part of the state tree.
 *
 * @param {HTMLElement} menuNode The menu element.
 *
 * @return {Object} Menu state object.
 */
function getStateForMenu(menuNode) {
  var statePart = state.menu;
  while (statePart && statePart.node !== menuNode) {
    statePart = statePart.menu;
  }

  return statePart;
}

/**
 * Get the menu state object for the currently active menu.
 *
 * @return {Object} Menu state object.
 */
function getStateForActiveMenu() {
  var statePart = state.menu;
  while (statePart && !statePart.active) {
    statePart = statePart.menu;
  }

  return statePart;
}

/**
 * Find the menu item that is below the current one.
 * This will skip disabled menu items as well as any elements that are not
 * defined as menu items. If there is no menu item below the current one,
 * this will return null.
 *
 * @param {Object} activeMenuState Menu state object for the currently active
 *   menu.
 *
 * @return {HTMLElement?} The HTML element for the menu item, or null.
 */
function getMenuItemBelow(activeMenuState) {
  if (!activeMenuState.selectedNode) {
    return activeMenuState.node.querySelector(SELECTOR_MENU_ITEM_ENABLED);
  }

  var item = activeMenuState.selectedNode.nextElementSibling;
  while (item) {
    var isMenuItem = item.matches(SELECTOR_MENU_ITEM);
    var isDisabled = item.matches(SELECTOR_MENU_ITEM_DISABLED);
    if (isMenuItem && !isDisabled) {
      break;
    }
    item = item.nextElementSibling;
  }

  return item;
}

/**
 * Find the menu item that is above the current one.
 * This will skip disabled menu items as well as any elements that are not
 * defined as menu items. If there is no menu item above the current one,
 * this will return null.
 *
 * @param {Object} activeMenuState Menu state object for the currently active
 *   menu.
 *
 * @return {HTMLElement?} The HTML element for the menu item, or null.
 */
function getMenuItemAbove(activeMenuState) {
  if (!activeMenuState.selectedNode) {
    var results = activeMenuState.node.querySelectorAll(SELECTOR_MENU_ITEM_ENABLED);
    return results[results.length - 1] || null;
  }

  var item = activeMenuState.selectedNode.previousElementSibling;
  while (item) {
    var isMenuItem = item.matches(SELECTOR_MENU_ITEM);
    var isDisabled = item.matches(SELECTOR_MENU_ITEM_DISABLED);
    if (isMenuItem && !isDisabled) {
      break;
    }
    item = item.previousElementSibling;
  }

  return item;
}

/**
 * The spotify-events style attach function. Should be called once when DOM
 * is ready.
 */
function attach() {
  if (isAttached) return;
  isAttached = true;

  document.addEventListener('keydown', onKeyDown);

  // use capture to work around the non-bubbling events
  document.addEventListener('focus', onFocus, true);
  document.addEventListener('blur', onBlur, true);
}

/**
 * The spotify-events style detach function. Should be called when you no
 * longer need the events.
 */
function detach() {
  if (!isAttached) return;
  isAttached = false;

  state.menu = null;

  document.removeEventListener('keydown', onKeyDown);
  document.removeEventListener('focus', onFocus, true);
  document.removeEventListener('blur', onBlur, true);
}

/**
 * The spotify-events style update function. Should be called when DOM
 * changes.
 */
function update() {}

},{"../spotify-navigation":463,"../spotify-navigation/app-state":462,"./center":268,"./util/throttle":322}],285:[function(require,module,exports){
(function (global){
'use strict';

var $ = require('../spotify-elements');

var live = require('../spotify-live');
var center = require('./center');

var NAVBAR_ATTR_NAME = 'data-navbar';
var ITEM_ID_ATTR_NAME = 'data-navbar-item-id';
var ITEM_MATCHER_ATTR_NAME = 'data-navbar-item-matcher';
var VIEW_ID_ATTR_NAME = 'data-navbar-view-id';
var ACTIVE_ID_ATTR_NAME = 'data-navbar-active-id';
var HISTORY_POS_ATTR_NAME = 'data-navbar-history-position';
var CLASSNAME_ACTIVE = 'active';
var OVERFLOW_MENU_ID = 'navbar-overflow-menu';
var STICKY_WRAPPER_ATTR_NAME = 'data-sticky-fixed-wrapper';

var APPLICATION_MODEL_URI = 'spotify:application';

var isDesktop = !!global._getSpotifyModule;

var navbarOverflowItems;
var isShowingNavbarOverflow;
var shouldShowNavbarOverflow;

var getSelector = function getSelector(name, opt_operator, opt_matcher) {
  if (opt_operator && opt_matcher) return '[' + name + opt_operator + '"' + opt_matcher + '"' + ']';
  return '[' + name + ']';
};

var handleClick = function handleClick(event, tab) {
  var id = tab.getAttribute(ITEM_ID_ATTR_NAME);

  if (id === OVERFLOW_MENU_ID) {
    shouldShowNavbarOverflow = true;
    updateOverflowMenu();
    return;
  }

  activateItem(id);
  // Prevent any default click action (like link navigation)
  event.preventDefault();
};

var activateItem = function activateItem(id) {
  updateScrollPosition();

  var view = getView(id);
  var tabs = getTabsForId(id);

  // Set styles for navbar items and show/hide views
  setActive(id, tabs, view);
};

var onMessage = function onMessage(message) {
  if (message.data && message.data.name === 'navbar-overflow-click') {
    activateItem(message.data.itemId);
  }

  if (message.data && message.data.name === 'hide-navbar-overflow') {
    hideOverflow();
  }
};

var updateOverflowMenu = function updateOverflowMenu() {
  var moreMenuItem = document.querySelector('[data-navbar-item-id=navbar-overflow-menu]');
  if (!moreMenuItem) return;

  var canBeOpen = navbarOverflowItems && navbarOverflowItems.length;
  if (!canBeOpen) {
    shouldShowNavbarOverflow = false;
  }

  // There's no check for isShowingNavbarOverflow, the event is intentionally
  // resent on update, to support resizing.
  if (shouldShowNavbarOverflow) {
    isShowingNavbarOverflow = true;
    var descriptors = navbarOverflowItems.map(function (item) {
      var link = item.querySelector('a[href]');

      // The text is in the <a> element inside the item.
      return {
        name: item.firstElementChild && item.firstElementChild.textContent || '',
        id: item.getAttribute(ITEM_ID_ATTR_NAME),
        url: link && link.getAttribute('href'),
        active: item.classList.contains('active')
      };
    });

    var targetRect = moreMenuItem.getBoundingClientRect();
    global.top.postMessage({
      type: 'show-navbar-overflow',
      items: descriptors,
      right: targetRect.right,
      top: targetRect.bottom
    }, '*');
  }

  if (!shouldShowNavbarOverflow && isShowingNavbarOverflow) {
    isShowingNavbarOverflow = false;
    global.top.postMessage({
      type: 'hide-navbar-overflow'
    }, '*');
  }
};

var hideOverflow = function hideOverflow() {
  if (isShowingNavbarOverflow) {
    shouldShowNavbarOverflow = false;
    updateOverflowMenu();
  }
};

var getViews = function getViews() {
  var views = document.querySelectorAll(getSelector(VIEW_ID_ATTR_NAME));
  return Array.prototype.slice.call(views);
};

var getTabs = function getTabs() {
  var tabs = document.querySelectorAll(getSelector(ITEM_ID_ATTR_NAME));
  return Array.prototype.slice.call(tabs);
};

var getTabsForId = function getTabsForId(tabId) {
  if (!tabId) {
    return [];
  }
  // This is intentionally selecting on all of the document
  var tabs = document.querySelectorAll(getSelector(ITEM_ID_ATTR_NAME, '=', tabId));
  return Array.prototype.slice.call(tabs);
};

var getActiveTab = function getActiveTab() {
  var navbar = getNavbar();
  if (!navbar) return;
  var activeTabId = navbar.getAttribute(ACTIVE_ID_ATTR_NAME);
  var activeTabs = getTabsForId(activeTabId);
  return activeTabs[0];
};

var getView = function getView(id) {
  return document.querySelector(getSelector(VIEW_ID_ATTR_NAME, '=', id));
};

var getFirstTabId = function getFirstTabId() {
  var tab = document.querySelector(getSelector(ITEM_ID_ATTR_NAME));
  if (tab) {
    if (tab.getAttribute(ITEM_ID_ATTR_NAME) === OVERFLOW_MENU_ID) {
      return null;
    }
    return tab.getAttribute(ITEM_ID_ATTR_NAME);
  }
  return null;
};

var setActiveForMatchingId = function setActiveForMatchingId(ids) {
  // Off the list of passed ids, find the first one that matches a tab, then set
  // that one as active.
  var count = 0;
  var tabs;
  var id;
  while (count < ids.length && (!tabs || !tabs.length)) {
    if (ids[count]) {
      id = ids[count];
      tabs = getTabsForId(id);
    }
    count++;
  }
  var useID = id;

  if (!tabs || !tabs.length) {
    return;
  }
  var view = getView(useID);

  setActive(useID, tabs, view);
};

var setActive = function setActive(id, tabs, view) {
  var currentActiveTab = getActiveTab();
  var currentActiveId = currentActiveTab && currentActiveTab.getAttribute(ITEM_ID_ATTR_NAME);

  // Abort if the new tab is already active
  if (currentActiveId === id) return;

  setActiveTabs(id, tabs);
  setActiveView(id, view);

  center.emit('navbar-change', { id: id });
};

var setActiveTabs = function setActiveTabs(id, tabs) {
  var navbar = getNavbar();
  if (!navbar) return;

  navbar.setAttribute(ACTIVE_ID_ATTR_NAME, id);

  tabs.forEach(function (tab) {
    tab.classList.add(CLASSNAME_ACTIVE);
  });

  // Remove the active class name from all tabs except the ones that should be active
  var tabs = getTabs();
  if (tabs.length) {
    tabs.forEach(function (_tab) {
      if (_tab.getAttribute(ITEM_ID_ATTR_NAME) !== id) {
        _tab.classList.remove(CLASSNAME_ACTIVE);
      }
    });
  }
};

var setActiveView = function setActiveView(id, view) {
  if (!view) {
    return;
  }

  var views = getViews();

  // Hide all views except the one that should be active
  for (var i = 0, l = views.length; i < l; i++) {
    if (views[i] !== view[0]) {
      hide(views[i]);
    }
  }

  show(view);
};

var hide = function hide(element) {
  element.style.display = 'none';
};
var show = function show(element) {
  element.style.display = 'block';
};

var updateForNode = function updateForNode(node) {
  var navbar = getNavbar(node);
  if (!navbar) return;

  live(APPLICATION_MODEL_URI).query('appURI, arguments', function (error, data) {
    if (error) throw error;

    var uri = fixAppURI(data.appURI);
    var fullAppURI = uri;
    if (data.arguments) {
      fullAppURI += ':' + data.arguments;
    }
    var id = getIdFromMatchers(fullAppURI);

    if (id) {
      // This is only the case when matchers (ITEM_MATCHER_ATTR_NAME) are used in DOM.
      setActiveForMatchingId([id]);
    } else {
      // For cases where id is only to be matched from one argument, find the id to
      // highlight by looking at the argument at HISTORY_POS_ATTR_NAME.
      var argumentIndex = +navbar.getAttribute(HISTORY_POS_ATTR_NAME) || 0;
      var idAtArgumentIndex = data.arguments.split(':')[argumentIndex];

      // For cases where nothing matches, also pass the first tab ID. This is
      // how the first tab is highlighted by default.
      var firstTabId = getFirstTabId();

      setActiveForMatchingId([fullAppURI, idAtArgumentIndex, firstTabId]);
    }
  });
};

function updateForOverflow(node) {
  var navbar = getNavbar(node);
  if (!navbar) return;

  var itemSelector = '[data-navbar] > [data-navbar-item-id]:not(.overflow-menu-button)';
  var items = node.querySelectorAll(itemSelector);
  if (!items) return;

  items = Array.prototype.slice.call(items);

  var overflowMenuButton = navbar.querySelector('.overflow-menu-button');

  // If we have less than two items, only show the navbar and be done. We need
  // at least two items for messurement and chances are a "more" menu won't be
  // needed.
  if (items.length < 2) {
    navbar.style.visibility = 'visible';
    if (overflowMenuButton) overflowMenuButton.style.display = 'none';
    return;
  }

  var navbarWidth = getWidth(navbar);
  if (!navbarWidth) {
    // The navbar isn't rendered. Bail out.
    return;
  }

  // Reset to the initial rendering state to be able to measure items.
  if (overflowMenuButton) overflowMenuButton.style.display = 'inline';

  items.forEach(function (item, i) {
    item.style.display = 'block';
    item.classList.remove('last-visible');
  });

  var sizing = measureNavbar(items, overflowMenuButton);

  // If stuff doesn't completely fit, reduce the available space by the "more"
  // menu with, then calculate what needs to go in it.
  var availableSpace = navbarWidth;
  var firstOverflown = getFirstOverflownIndex(availableSpace, sizing.itemWidths);
  var needsMoreMenu = items.length !== firstOverflown;

  if (needsMoreMenu) {
    availableSpace -= sizing.overflowMenuButtonWidth;
    firstOverflown = getFirstOverflownIndex(availableSpace, sizing.itemWidths);
  }

  if (!navbarOverflowItems) {
    navbarOverflowItems = [];
  }
  navbarOverflowItems.length = 0;

  items.forEach(function (item, i) {
    var shouldBeInOverflow = i >= firstOverflown;
    if (shouldBeInOverflow) navbarOverflowItems.push(item);

    // If we don't draw an overflow menu, set the last-visible class on the
    // very last item so its margin-right is removed.
    var isLastInNotOverflown = !needsMoreMenu && i === items.length - 1;

    item.style.display = shouldBeInOverflow ? 'none' : 'block';
    item.classList.toggle('last-visible', isLastInNotOverflown);
  });

  if (overflowMenuButton) {
    overflowMenuButton.style.display = needsMoreMenu ? 'inline' : 'none';
  }

  // Update items and position, possibly close the menu
  updateOverflowMenu();
  navbar.style.visibility = 'visible';
}

function updateScrollPosition() {
  var scrollTop = window.pageYOffset;
  var stickyElements = Array.prototype.slice.call(document.querySelectorAll('[' + STICKY_WRAPPER_ATTR_NAME + ']'));

  if (stickyElements.length === 0) return;

  // Get the `top` value of a sticky element that is
  // in a fixed position (negative value)
  // and the closest to the top (smallest top value).
  var topTarget = stickyElements.reduce(function (res, el) {
    var top = el.getBoundingClientRect().top;
    return top < res ? top : res;
  }, 0);

  if (topTarget < 0) {
    // Add 1 px to have the sticky element in fixed position.
    window.scrollTo(0, topTarget + scrollTop + 1);
  }
}

function handleResize() {
  updateForOverflow(document.body);
}

function measureNavbar(items, overflowMenuButton) {
  // Find out what the margin per item is my messuring beween the first 2 items.
  var item1 = items[0];
  var item2 = items[1];

  var right1 = Math.floor(item1.getBoundingClientRect().right);
  var left2 = Math.floor(item2.getBoundingClientRect().left);
  var marginPerSide = (left2 - right1) / 2;

  var itemWidths = [];
  if (items) {
    itemWidths = items.map(function (item, i, all) {
      var marginLeft = i === 0 ? 0 : marginPerSide;
      var marginRight = i === all.length - 1 ? 0 : marginPerSide;
      return getWidth(item) + marginLeft + marginRight;
    });
  }

  // When the overflowMenuButton is showns, it's always at the end, so it has
  // no right margin.
  var overflowMenuButtonWidth = 0;
  if (overflowMenuButton) {
    overflowMenuButtonWidth = getWidth(overflowMenuButton) + marginPerSide;
  }

  return {
    itemWidths: itemWidths,
    overflowMenuButtonWidth: overflowMenuButtonWidth
  };
}

function getWidth(element) {
  return element && element.offsetWidth || 0;
}

function getFirstOverflownIndex(space, sizes) {
  var count = 0;
  var used = 0;
  while (sizes[count] !== undefined && used < space) {
    used += sizes[count];
    // This is actually expected to return up to .length of the sizes.
    // That will be the case when everything fits.
    count++;
  }
  if (used < space) return count;
  return count - 1;
}

// Hack to get around bridge bug (reported at WP-471) where WP reports
// the uri with the arguments as well.
var fixAppURI = function fixAppURI(uri) {
  return uri.split(':').slice(0, 3).join(':');
};

// Matchers allow you to tell a tab to be active for a pattern of the app arguments.
// If you define data-navbar-item-matcher="user:.*?:playlist:.*$" you tell the tab
// to be active when the arguments match that regexp.
var storedMatchers = {};
var getMatchers = function getMatchers(node) {
  var matchers = node.querySelectorAll(getSelector(ITEM_MATCHER_ATTR_NAME));
  if (!matchers.length) return;

  matchers = Array.prototype.slice.call(matchers);
  matchers.forEach(function (matcher) {
    var regexp = matcher.getAttribute(ITEM_MATCHER_ATTR_NAME);
    var id = matcher.getAttribute(ITEM_ID_ATTR_NAME);
    storedMatchers[regexp] = id;
  });
};

var getIdFromMatchers = function getIdFromMatchers(uri) {
  for (var regexp in storedMatchers) {
    if (storedMatchers.hasOwnProperty(regexp)) {
      var regexpObj = new RegExp(regexp);
      if (regexpObj.test(uri)) return storedMatchers[regexp];
    }
  }
  return null;
};

var getNavbar = function getNavbar(opt_node) {
  var node = opt_node || document.documentElement;
  var selector = getSelector(NAVBAR_ATTR_NAME);
  return node.matches(selector) ? node : node.querySelector(selector);
};

var onApplicationChange = function onApplicationChange(event) {
  if ('arguments' in event || 'active' in event) {
    updateForNode(document.documentElement);
  }
};

var isAttached = false;

exports.update = function update(node) {
  if (!isAttached) return;

  updateForNode(node || document.documentElement);
  getMatchers(node || document.documentElement);
  updateForOverflow(node || document.documentElement);
};

exports.attach = function attach() {
  if (isAttached) return;
  isAttached = true;

  $(document).delegate('click', getSelector(ITEM_ID_ATTR_NAME), handleClick);
  window.addEventListener('message', onMessage);
  live(APPLICATION_MODEL_URI).on('update', onApplicationChange);
  window.addEventListener('resize', handleResize);
  center.on('navbar-hide', hideOverflow);
};

exports.detach = function detach() {
  if (!isAttached) return;
  isAttached = false;

  navbarOverflowItems = null;
  isShowingNavbarOverflow = false;
  shouldShowNavbarOverflow = false;

  $(document).undelegate('click', getSelector(ITEM_ID_ATTR_NAME), handleClick);
  window.removeEventListener('message', onMessage);
  live(APPLICATION_MODEL_URI).off('update', onApplicationChange);
  window.removeEventListener('resize', handleResize);
  center.off('navbar-hide', hideOverflow);
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-elements":259,"../spotify-live":439,"./center":268}],286:[function(require,module,exports){
'use strict';

var $ = require('../spotify-elements');
var live = require('../spotify-live');

var sessionModel;

function onSessionUpdate(properties) {
  if ('online' in properties) {
    if (properties.online) {
      $(document.body).removeClass('offline');
    } else {
      $(document.body).addClass('offline');
    }
  }
}

function updateWithSessionValue() {
  live('spotify:client').query('session(online)', function (error, data) {
    if (error) throw error;
    onSessionUpdate({ online: data.session.online });
  });
}

var isAttached = false;

exports.update = function () {
  if (!isAttached) return;

  updateWithSessionValue();
};

exports.attach = function () {
  if (isAttached) return;
  isAttached = true;

  if (!sessionModel) {
    live('spotify:client').get('session', function (error, session) {
      if (error) throw error;
      sessionModel = session;
      sessionModel.on('update', onSessionUpdate);
    });
  }
};

exports.detach = function () {
  if (!isAttached) return;
  isAttached = false;

  if (sessionModel) {
    sessionModel.off('update', onSessionUpdate);
    sessionModel = null;
  }
};

},{"../spotify-elements":259,"../spotify-live":439}],287:[function(require,module,exports){
'use strict';

/**
 * @private
 */

// [SHUFFLE] Used only for showing the message bar when trying to play a track.
var shuffleMode = require('../../spotify-shuffle-mode');
var cosmos = require('spotify-cosmos-api');

var $ = require('../../spotify-elements');
var utils = require('./utils');

var SELECTOR_LIST_ROW = '[data-context] [data-list-item]';
var SELECTOR_PLAY_BUTTON = '[data-button=play]';
var SELECTOR_PLAY_CONTEXT_BUTTON = '[data-button=play-context]';

// This array will store event types for touch handling
var lastEventTypes = [];

// Methods that need implementation from another module.
// This is to support generic handling of user actions from within this module,
// but allow further checks and actions to be performed by another module. This
// allows multiple different implementations of starting playback for example.
var methods = {
  getPlayerVariantUri: utils.createEmptyMethod('getPlayerVariantUri'),
  handlePlayButton: utils.createEmptyMethod('handlePlayButton'),
  handlePlayFromRow: utils.createEmptyMethod('handlePlayFromRow')
};

/**
 * Handle the click of a play button.
 *
 * @param {MouseEvent} event An event object for a click event.
 * @param {Elements} button An element instance from the `elements` package.
 *
 * @private
 */
function handlePlayButtonClick(event, button) {
  var buttonNode = button[0];
  var buttonContextUri = utils.getUriFromButton(buttonNode);

  // We need an associated context URI for the button
  if (!buttonContextUri) {
    return;
  }

  // [SHUFFLE]: track buttons do not work.
  if (shuffleMode.isEnabled() && /^spotify:track:/.test(buttonContextUri)) {
    cosmos.resolver.post({
      url: 'sp://messages/v1/container/user-message',
      body: {
        description: 'Track cannot be played because "shuffle mode" is enabled',
        id: 'shuffle-unplayable-track'
      }
    }, function () {
      // We don't care about reply, if it fails we can't do pretty much anything
    });

    return;
  }

  var playerContextUri = methods.getPlayerVariantUri();
  var isPlayingContext = utils.compareContexts(playerContextUri, buttonContextUri);

  var source = utils.getAttributeValueFromNode(buttonNode, 'data-play-source');

  methods.handlePlayButton(buttonNode, {
    isPlayingContext: isPlayingContext,
    contextUri: buttonContextUri,
    source: source,
    reason: 'playbtn'
  });
}

/**
 * Handle the double click or tap of a list row to start playback.
 *
 * @param {Elements} row An element instance from the `elements` package.
 *
 * @private
 */
function handleListRow(row) {
  var contextNode = row.parent('[data-context]');
  if (contextNode) {
    var rowNode = row[0];
    var source = utils.getAttributeValueFromNode(rowNode, 'data-play-source');
    methods.handlePlayFromRow(rowNode, {
      contextUri: contextNode.data('uri'),
      source: source,
      reason: 'clickrow'
    });
  }
}

/**
 * Handle double clicking on a list row to start playback.
 *
 * @param {MouseEvent} event An event object for a double click.
 * @param {Elements} row An element instance from the `elements` package.
 *
 * @private
 */
function handleRowDoubleClick(event, row) {
  // Only play when not clicking on interactive elements such as buttons
  if (!utils.isInteractiveElement(event.target)) {
    handleListRow(row);
  }
}

/**
 * Handle a key press on a list row.
 * This will take care of starting playback when pressing Enter.
 *
 * @param {KeyboardEvent} event A keyboard event.
 * @param {Elements} row An element instance from the `elements` package.
 *
 * @private
 */
function handleRowKeyDown(event, row) {
  var isEnter = event.keyCode === 13;
  if (isEnter) {
    if (utils.isFormOrLinkElement(event.target)) {
      return;
    }

    event.preventDefault();
    event.stopPropagation();

    handleListRow(row);
  }
}

/**
 * Handle the 'contextmenu' event. This is only for touch handling.
 * This is needed since we use a custom context menu in Spotify, and the handler
 * for that calls `preventDefault` for the 'contextmenu' event, which means the
 * rest of the touch handling will go on as usual. So as we don't get the
 * 'touchcancel' event, we need to catch the 'contextmenu' event here to know
 * that we should not act on the following 'touchend' event.
 *
 * @param {MouseEvent} event A 'contextmenu' event.
 *
 * @private
 */
function handleContextMenu(event) {
  lastEventTypes.push(event.type);
}

/**
 * Handle the start of a touch. Used to detect a tap.
 *
 * @param {TouchEvent} event A touch event.
 *
 * @private
 */
function handleRowTouchStart(event) {
  lastEventTypes.push(event.type);
}

/**
 * Handle the move of a touch. Used to abort detection of a tap.
 *
 * @param {TouchEvent} event A touch event.
 *
 * @private
 */
function handleRowTouchMove(event) {
  lastEventTypes.push(event.type);
}

/**
 * Handle the end of a touch. Used to detect a tap and start playback of a row.
 *
 * @param {TouchEvent} event A touch event.
 * @param {Elements} row An element instance from the `elements` package.
 *
 * @private
 */
function handleRowTouchEnd(event, row) {
  // If this was a tap (only touchstart was triggered before this)
  if (lastEventTypes.length === 1 && lastEventTypes[0] === 'touchstart') {

    // Prevent the simulated mouse events (including click). This is to
    // avoid the simulated click event to click on the play button that
    // appears when selecting a row on touchstart.
    // See: https://jira.spotify.net/browse/KM-7983
    if (!utils.isInteractiveElement(event.target)) {
      event.preventDefault();

      // Tapping on a row should play it
      handleListRow(row);
    }
  }
  lastEventTypes = [];
}

/**
 * Attach the needed event listeners for the module.
 */
exports.attach = function () {
  var doc = $(document);

  doc.delegate('keydown', SELECTOR_LIST_ROW, handleRowKeyDown);
  doc.delegate('click', SELECTOR_PLAY_BUTTON, handlePlayButtonClick);
  doc.delegate('click', SELECTOR_PLAY_CONTEXT_BUTTON, handlePlayButtonClick);
  doc.delegate('dblclick', SELECTOR_LIST_ROW, handleRowDoubleClick);

  /* For touch handling */
  doc.delegate('touchstart', SELECTOR_LIST_ROW, handleRowTouchStart);
  doc.delegate('touchend', SELECTOR_LIST_ROW, handleRowTouchEnd);
  doc.delegate('touchmove', SELECTOR_LIST_ROW, handleRowTouchMove);
  doc.delegate('contextmenu', SELECTOR_LIST_ROW, handleContextMenu);
};

/**
 * Detach the event listeners for the module.
 */
exports.detach = function () {
  var doc = $(document);

  doc.undelegate('keydown', SELECTOR_LIST_ROW, handleRowKeyDown);
  doc.undelegate('click', SELECTOR_PLAY_BUTTON, handlePlayButtonClick);
  doc.undelegate('click', SELECTOR_PLAY_CONTEXT_BUTTON, handlePlayButtonClick);
  doc.undelegate('dblclick', SELECTOR_LIST_ROW, handleRowDoubleClick);

  /* For touch handling */
  doc.undelegate('touchstart', SELECTOR_LIST_ROW, handleRowTouchStart);
  doc.undelegate('touchend', SELECTOR_LIST_ROW, handleRowTouchEnd);
  doc.undelegate('touchmove', SELECTOR_LIST_ROW, handleRowTouchMove);
  doc.undelegate('contextmenu', SELECTOR_LIST_ROW, handleContextMenu);
};

/**
 * Set the external methods for this module to add implementations for starting
 * playback etc.
 *
 * @param {Object} methodDefinitions Object where keys are method names and
 *     values are functions.
 */
exports.setMethods = function (methodDefinitions) {
  for (var name in methodDefinitions) {
    if (methodDefinitions.hasOwnProperty(name)) {
      methods[name] = methodDefinitions[name];
    }
  }
};

},{"../../spotify-elements":259,"../../spotify-shuffle-mode":491,"./utils":290,"spotify-cosmos-api":694}],288:[function(require,module,exports){
'use strict';

var playerWithIndices = require('./withIndices');
var playerWithUids = require('./withUids');

var playerModule = playerWithIndices;

exports.setMode = function (type) {
  switch (type) {
    case 'indices':
      playerModule = playerWithIndices;
      break;
    case 'uids':
      playerModule = playerWithUids;
      break;
  }
};

exports.attach = function () {
  playerModule.attach();
};

exports.detach = function () {
  playerModule.detach();
};

exports.update = function (optNode) {
  playerModule.update(optNode);
};

},{"./withIndices":291,"./withUids":292}],289:[function(require,module,exports){
'use strict';

/**
 * @private
 */

var difference = require('mout/array/difference');
var $ = require('../../spotify-elements');
var live = require('../../spotify-live');

var center = require('../center');
var utils = require('./utils');

var CURRENT = 'current';
var PAUSED = 'paused';
var PLAYING = 'playing';

var LOG_PLAY_BUTTON = 'play-button';
var LOG_PAUSE_BUTTON = 'pause-button';

var SELECTOR_PLAY_BUTTON = '[data-button=play]';
var SELECTOR_PLAY_CONTEXT_BUTTON = '[data-button=play-context]';
var SELECTOR_ALL_PLAY_BUTTONS = SELECTOR_PLAY_BUTTON + ',' + SELECTOR_PLAY_CONTEXT_BUTTON;

// Methods that need implementation from another module.
// This is to support generic handling of DOM updates from within this module,
// but allow further checks and actions to be performed by another module. This
// allows multiple different implementations of highlighting playing objects.
var methods = {
  getPlayerVariantUri: utils.createEmptyMethod('getPlayerVariantUri'),
  getPlayerIsPlaying: utils.createEmptyMethod('getPlayerIsPlaying'),
  getPlayingNodes: utils.createEmptyMethod('getPlayingNodes'),

  // This should be a function that takes a function as the first argument. That
  // function argument should be called whenever the player state has changed.
  subscribeToPlayerChange: utils.createEmptyMethod('subscribeToPlayerChange')
};

var playableChangeHandlers = {};
var playerSubscription = null;

/**
 * Update states in the DOM based on current player state.
 *
 * @param {HTMLElement=} node An optional DOM node. If passed, only nodes inside
 *     of that node will be updated.
 */
function updateDOM(optNode) {
  var containerNode = optNode || document;

  updateButtonsBasedOnPlayable(containerNode);

  var playingNodes = getPlayingNodes(containerNode);
  var currentNodes = getCurrentNodes(containerNode);

  if (currentNodes) {
    var nodesForRemoval = currentNodes;
    if (playingNodes) {
      nodesForRemoval = difference(currentNodes, playingNodes);
    }
    nodesForRemoval.forEach(removePlayingStateFromNode);
  }

  if (playingNodes) {
    var nodesForAddition = playingNodes;
    if (currentNodes) {
      nodesForAddition = difference(playingNodes, currentNodes);
    }
    nodesForAddition.forEach(addPlayingStateToNode);

    var nodesForUpdate = difference(playingNodes, nodesForAddition);
    nodesForUpdate.forEach(updatePlayingStateForNode);
  }
}

/**
 * Update the playable status of all play buttons found inside the passed
 * container node.
 *
 * @param {HTMLElement} containerNode A DOM node to search for nodes inside.
 *
 * @private
 */
function updateButtonsBasedOnPlayable(containerNode) {
  // `[data-button=play]` buttons are used to play something specific *in* a
  // context (defining an index as a track number or uid/uri or range).
  // Those are currently not updated themselves, instead their rows are being
  // set to `.unavailable`.
  var buttons = $(containerNode).search('[data-button=play-context]');
  if (buttons) {
    buttons.forEach(updateButtonBasedOnPlayable);
  }
}

/**
 * Update the playable status of the passed button.
 *
 * @param {HTMLElement} button A button DOM node.
 *
 * @private
 */
function updateButtonBasedOnPlayable(button) {

  // Play buttons in list rows should not be handled, as the buttons are
  // hidden by CSS anyway for unplayable rows.
  if (!!$(button).parent('[data-list-item]')) {
    return;
  }

  var contextURI = utils.getUriFromButton(button);

  // Check if the context has a playable flag specified.
  var playableValue = live(contextURI).get('playable');
  var definesPlayable = playableValue != undefined;

  // If it does, update the `disabled` attribute based on it
  if (definesPlayable) {
    if (playableValue) {
      button.removeAttribute('disabled');
    } else {
      button.setAttribute('disabled', 'disabled');
    }

    if (!playableChangeHandlers[contextURI]) {
      playableChangeHandlers[contextURI] = function (changed) {
        if (!changed.hasOwnProperty('playable')) return;
        // Update all buttons currently in DOM when `playable` changes on a
        // context. Not worth adding logic to only pick out buttons pointing to
        // a specific URI.
        updateButtonsBasedOnPlayable(document.body);
      };
      live(contextURI).on('update', playableChangeHandlers[contextURI]);
    }
  }
}

/**
 * Get the nodes inside the passed container node that are currently marked as
 * playing.
 *
 * @param {HTMLElement} containerNode A DOM node to search for nodes inside.
 *
 * @return {?Elements} An element instance from the `elements` package, or null.
 *
 * @private
 */
function getCurrentNodes(containerNode) {
  return $(containerNode).search('[data-playback-active=true]');
}

/**
 * Get the nodes inside the passed container node that should be marked as
 * playing based on the current player state.
 *
 * @param {HTMLElement} containerNode A DOM node to search for nodes inside.
 *
 * @return {?Elements} An element instance from the `elements` package, or null.
 *
 * @private
 */
function getPlayingNodes(containerNode) {
  var variantUri = methods.getPlayerVariantUri();
  var selectors = utils.getContextSelectorsWithVariants(variantUri);

  var contextNodes = $(containerNode).search(selectors.join(', '));
  if (contextNodes) {
    contextNodes = Array.prototype.slice.call(contextNodes);
  } else {
    contextNodes = [];
  }

  // Pass it through the outside implementation, which might filter out
  // nodes from `contextNodes` and add more nodes to the match.
  return methods.getPlayingNodes(containerNode, contextNodes);
}

/**
 * Remove the playing state from the passed DOM node, as it's no longer playing.
 *
 * @param {HTMLElement} node The DOM node to remove state from.
 *
 * @private
 */
function removePlayingStateFromNode(node) {
  var className = [CURRENT, PAUSED, PLAYING].join(' ');
  node = $(node);
  node.removeClass(className).removeAttribute('data-playback-active');

  if (node.matches(SELECTOR_ALL_PLAY_BUTTONS)) {
    node.attribute('data-log-click', LOG_PLAY_BUTTON);
  }
}

/**
 * Add the playing state to the passed DOM node, as it's now playing.
 *
 * @param {HTMLElement} node The DOM node to add state to.
 *
 * @private
 */
function addPlayingStateToNode(node) {
  var isPlaying = methods.getPlayerIsPlaying();

  var classNames = [CURRENT, isPlaying ? PLAYING : PAUSED].join(' ');

  node = $(node);
  node.addClass(classNames).data('playback-active', true);

  if (node.matches(SELECTOR_ALL_PLAY_BUTTONS)) {
    node.attribute('data-log-click', isPlaying ? LOG_PAUSE_BUTTON : LOG_PLAY_BUTTON);
  }
}

/**
 * Update the playing state for the passed DOM node, as it's still representing
 * the currently playing context, but the player might switch between
 * playing/paused.
 *
 * @param {HTMLElement} node The DOM node to update state for.
 *
 * @private
 */
function updatePlayingStateForNode(node) {
  var isPlaying = methods.getPlayerIsPlaying();

  var currentClassName = isPlaying ? PAUSED : PLAYING;
  var newClassName = isPlaying ? PLAYING : PAUSED;
  var element = $(node);

  if (element.hasClass(currentClassName)) {
    element.removeClass(currentClassName);
  }

  if (!element.hasClass(newClassName)) {
    element.addClass(newClassName);
  }

  if (element.matches(SELECTOR_ALL_PLAY_BUTTONS)) {
    element.attribute('data-log-click', isPlaying ? LOG_PAUSE_BUTTON : LOG_PLAY_BUTTON);
  }
}

/**
 * Handle updating of DOM nodes when they have been added to the DOM by a scroll
 * agent.
 *
 * @param {Object} event Custom event object sent from the scroll agent. Should
 *     contain a `container` property pointing to the DOM node containing the
 *     rows.
 *
 * @private
 */
function handleScrollShowAfter(event) {
  var container = $(event.container);
  var contextNode = null;
  if (container.matches('[data-context]')) {
    contextNode = container;
  } else {
    contextNode = container.parent('[data-context]');
  }

  // We can't pass the context node itself as root because of how the playing
  // state queries are set up.
  var contextParent = contextNode && contextNode[0].parentElement || document;

  updateDOM(contextParent);
}

/**
 * Attach the needed event listeners for the module.
 */
exports.attach = function () {
  playerSubscription = methods.subscribeToPlayerChange(function () {
    updateDOM();
  });

  center.on('scroll-show-after', handleScrollShowAfter);
};

/**
 * Detach the needed event listeners for the module.
 */
exports.detach = function () {
  if (playerSubscription) {
    playerSubscription.cancel();
    playerSubscription = null;
  }

  for (var contextUri in playableChangeHandlers) {
    if (playableChangeHandlers.hasOwnProperty(contextUri)) {
      live(contextUri).off('update', playableChangeHandlers[contextUri]);
    }
  }
  playableChangeHandlers = {};

  center.off('scroll-show-after', handleScrollShowAfter);
};

/**
 * Update things in the DOM.
 */
exports.update = updateDOM;

/**
 * Set the external methods for this module to add implementations for methods
 * needed for highlighting playing objects.
 *
 * @param {Object} methodDefinitions Object where keys are method names and
 *     values are functions.
 */
exports.setMethods = function (methodDefinitions) {
  for (var name in methodDefinitions) {
    if (methodDefinitions.hasOwnProperty(name)) {
      methods[name] = methodDefinitions[name];
    }
  }
};

},{"../../spotify-elements":259,"../../spotify-live":439,"../center":268,"./utils":290,"mout/array/difference":626}],290:[function(require,module,exports){
(function (global){
'use strict';

/**
 * This module might be used by modules outside of spotify-events.
 * @public
 */

var liburi = require('spotify-liburi');
var $ = require('../../spotify-elements');

var getOriginUri = require('../../spotify-live-wrapped-uri').getOriginUri;

/**
 * Get the context URI from a button node or its parents.
 *
 * @param {HTMLElement} button A DOM node for a button.
 *
 * @return {string} The context URI or empty string if not found.
 */
function getUriFromButton(button) {
  var contextNode = button.closest('[data-context]');
  return contextNode && contextNode.getAttribute('data-uri') || '';
}

/**
 * Get the value for the passed attribute name, either from the passed node or
 * from any parent node.
 *
 * @param {HTMLElement} node The node to start searching from.
 * @param {string} attributeName The name of the attribute.
 *
 * @return {string} The value, or empty string if not found.
 */
function getAttributeValueFromNode(node, attributeName) {
  var selector = '[' + attributeName + ']';
  var attributeNode = node.closest(selector);
  return attributeNode && attributeNode.getAttribute(attributeName) || '';
}

/**
 * Check if the passed element is a form or link element.
 *
 * @param {HTMLElement} element A DOM node.
 *
 * @return {boolean} True if it is a form or link element.
 */
function isFormOrLinkElement(element) {
  var tagName = element.tagName.toLowerCase();
  var elements = ['input', 'textarea', 'button', 'select', 'optgroup', 'option', 'a'];
  return elements.indexOf(tagName) > -1;
}

/**
 * Check if the passed element is an interactive element (links, buttons).
 *
 * @param {HTMLElement}  element A DOM node.
 *
 * @return {boolean} True if the element is interactive.
 */
function isInteractiveElement(element) {
  var tagName = element.tagName.toLowerCase();
  return tagName === 'a' || tagName === 'button';
}

/**
 * Get a CSS selector string for a context.
 *
 * @param {string} operator A CSS selector operator ($= or similar).
 * @param {string} uri The context URI.
 *
 * @return {string} The CSS selector string.
 */
function getContextSelector(operator, uri) {
  return '[data-context][data-uri' + operator + uri + ']';
}

/**
 * Get an array of CSS selectors for searching for context nodes inside the DOM.
 *
 * @param {string} uri The context URI to search for. This should be the
 *     currently playing variant URI (for example, when playing a sorted
 *     playlist the sorted URI should be passed).
 *
 * @return {Array.<string>} Array of CSS selector strings.
 */
function getContextSelectors(uri) {
  var ENDSWITH = '$=';
  var SAME = '=';

  var selectors = [getContextSelector(SAME, uri)];

  var normalized = normalizeUri(uri);
  if (uri !== normalized) {
    selectors.push(getContextSelector(SAME, normalized));
  }

  return selectors;
}

/**
 * Get an array of CSS selectors for searching for context nodes inside the DOM.
 * This also includes any variant of the passed context URI. For example, if
 * passing a sorted playlist URI, it will return selectors for matching all
 * variations of that playlist URI, including the regular playlist URI, filtered
 * URI etc.
 *
 * @param {string} uri The context URI to search for. This can be either the
 *     origin URI, or any variant URI. The function will convert it to the
 *     origin URI automatically.
 *
 * @return {Array.<string>} Array of CSS selector strings.
 */
function getContextSelectorsWithVariants(uri) {
  var ENDSWITH = '$=';
  var SAME = '=';

  // Only add the ENDSWITH selectors. Those also match the original.
  // When it's a sorted and/or filtered list, just use the origin.
  var endsWith = getOriginUri(uri) || uri;
  var endsWithNormalized = normalizeUri(endsWith);

  var selectors = [getContextSelector(ENDSWITH, endsWith.replace(/^spotify:/, ':'))];

  if (endsWith !== endsWithNormalized) {
    selectors.push(getContextSelector(ENDSWITH, endsWithNormalized.replace(/^spotify:/, ':')));
  }

  return selectors;
}

/**
 * Check if two context URIs are representing the same context. This will take
 * care of normalizing the casing of URL encoding and filtered/sorted contexts.
 *
 * @param {string} context1 The first context.
 * @param {string} context2 The second context.
 *
 * @return {boolean} True if they represent the same context.
 */
function compareContexts(context1, context2) {
  if (!context1 || !context2) return false;

  context1 = normalizeUri(getOriginUri(context1) || context1);
  context2 = normalizeUri(getOriginUri(context2) || context2);

  return context1 === context2;
}

/**
 * A URI might contain URL encoded characters, and per spec the URL encoding can
 * be either in lowercase or uppercase (should be treated as same URL). If the
 * input URL has lowercase encoding, liburi will convert it into uppercase
 * encoding.
 *
 * @param {string} uri The URI to normalize.
 *
 * @return {string} The normalized URI.
 */
function normalizeUri(uri) {
  var uriObj = liburi.from(uri);
  var normalized = uriObj ? uriObj.toString() : uri;

  // Work around incorrect handling of `spotify:internal:...` URIs by liburi,
  // since it does not recognize `internal` URIs, and therefore uses the default
  // `app` type.
  normalized = normalized.replace(/^spotify:app:internal:/, 'spotify:internal:');

  // Work around the bad conversion of spaces in filtered list URIs. The URI
  // spec we use says that spaces should be encoded as `+`, but the `filterlist`
  // URI uses the regular `%20` encoding for spaces. Passing it through liburi
  // converts it to `+`, so we need to convert it back to `%20` again.
  normalized = normalized.replace(/:internal:filterlist:[^:]+/, function (match) {
    return match.replace(/\+/g, '%20');
  });

  return normalized;
}

/**
 * Create an empty method that will only log a warning when called.
 *
 * @param {string} methodName The name of the method to warn about.
 *
 * @return {Function} The function.
 */
function createEmptyMethod(methodName) {
  return function () {
    if (global.console) {
      console.warn('spotify-events/player: `' + methodName + '` is not implemented.');
    }
  };
}

exports.getUriFromButton = getUriFromButton;
exports.getAttributeValueFromNode = getAttributeValueFromNode;
exports.isFormOrLinkElement = isFormOrLinkElement;
exports.isInteractiveElement = isInteractiveElement;
exports.getContextSelector = getContextSelector;
exports.getContextSelectors = getContextSelectors;
exports.getContextSelectorsWithVariants = getContextSelectorsWithVariants;
exports.compareContexts = compareContexts;
exports.normalizeUri = normalizeUri;
exports.createEmptyMethod = createEmptyMethod;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../spotify-elements":259,"../../spotify-live-wrapped-uri":438,"spotify-liburi":707}],291:[function(require,module,exports){
'use strict';

/**
 * @private
 */

var live = require('../../spotify-live');
var Range = require('../../spotify-range2');
var $ = require('../../spotify-elements');
var find = require('mout/array/find');

var playerActions = require('./actions');
var playerUpdates = require('./updates');
var utils = require('./utils');

var isAttached = false;

exports.attach = function () {
  if (isAttached) return;
  isAttached = true;

  playerActions.setMethods({
    getPlayerVariantUri: getPlayerVariantUri,
    handlePlayButton: handlePlayButton,
    handlePlayFromRow: handlePlayFromRow
  });

  playerUpdates.setMethods({
    getPlayerVariantUri: getPlayerVariantUri,
    getPlayerIsPlaying: getPlayerIsPlaying,
    getPlayingNodes: getPlayingNodes,
    subscribeToPlayerChange: subscribeToPlayerChange
  });

  playerActions.attach();
  playerUpdates.attach();
};

exports.detach = function () {
  if (!isAttached) return;
  isAttached = false;

  playerActions.detach();
  playerUpdates.detach();
};

exports.update = function (optNode) {
  if (!isAttached) return;

  playerUpdates.update(optNode);
};

/**
 * Get the variant URI for the currently playing context. For example, if
 * playing a sorted playlist, this should return the sorted URI.
 *
 * @return {string} The context variant URI, or empty string if nothing is
 *     playing.
 */
function getPlayerVariantUri() {
  var variant = live('spotify:player').get('variant');
  return variant ? variant.uri : '';
}

/**
 * Get the index of the currently playing track within the playing context.
 *
 * @return {number} The index, or -1 if not found.
 */
function getPlayerIndex() {
  var indexObject = live('spotify:player').get('index');
  return indexObject ? indexObject.get('track') : -1;
}

/**
 * Get the URI of the currently playing track.
 *
 * @return {string} The track URI, or empty string if nothing is playing.
 */
function getPlayerTrackUri() {
  var track = live('spotify:player').get('track');
  return track && track.uri || '';
}

/**
 * Get the playing status of the player.
 *
 * @return {boolean} True if the player is currently playing audio.
 */
function getPlayerIsPlaying() {
  var isPlaying = live('spotify:player').get('isPlaying');
  var isPaused = live('spotify:player').get('isPaused');
  return isPlaying && !isPaused;
}

/**
 * Get whether the player is currently shuffling the context.
 *
 * @return {boolean} True if shuffling.
 */
function getPlayerIsShuffling() {
  var options = live('spotify:player').get('options');
  var shufflingContext = options && options.get('shufflingContext');
  return !!shufflingContext;
}

/**
 * Subscribe to player changes.
 *
 * @param {Function} handler A handler function. The data passed to this
 *     function is irrelevent, only the fact that something changed is needed.
 *
 * @return {Object} An object with a `cancel` method to cancel the subscription.
 */
function subscribeToPlayerChange(handler) {
  live('spotify:player').on('update', handler);
  var active = true;
  return {
    cancel: function cancel() {
      if (active) {
        live('spotify:player').off('update', handler);
        active = false;
      }
    }
  };
}

/**
 * Handle the click of a play button.
 * This function should decide what the action should be, and pause/resume
 * playback or start playback of a new context.
 *
 * @param {HTMLElement} buttonNode A button DOM node.
 * @param {Object} data Object of data about the action:
 *     isPlayingContext: (boolean) Whether the button looks to be representing
 *         the currently playing context.
 *     contextUri: (string) The context URI for the button.
 *     source: (string) The 'play source' value, for logging purposes.
 *     reason: (string) The 'play reason' value, for logging purposes.
 */
function handlePlayButton(buttonNode, data) {
  var button = $(buttonNode);
  var playerIndex = getPlayerIndex();
  var range;
  var newIndex;
  var uids;
  var uris;

  var dataRange = button.data('range');
  if (dataRange) {
    range = Range.fromString(dataRange);
    var list = live(data.contextUri).get('rows');
    if (list) {
      var indices = range.toIndices();
      uids = indices.map(function (index) {
        return list.keys[index];
      });
      uris = indices.map(function (index) {
        var track = list.get(index).get('track');
        return track.uri;
      });
    }
    newIndex = null;
  } else {
    var contextIndexNode = null;
    if (button.matches('[data-context-index]')) {
      contextIndexNode = button;
    } else {
      contextIndexNode = button.parent('[data-context-index]');
    }

    if (contextIndexNode) {
      newIndex = parseInt(contextIndexNode.data('context-index'), 10);
      var list = live(data.contextUri).get('rows');
      if (list) {
        uids = [list.keys[newIndex]];
        uris = [list.get(newIndex).get('track').uri];
      }
    } else {
      newIndex = null;
    }
  }

  var shouldPauseResume = false;

  if (data.isPlayingContext) {
    if (range) {
      // null or undefined
      if (playerIndex == null) {
        shouldPauseResume = false;
      } else {
        shouldPauseResume = range.contains(new Range(playerIndex, playerIndex + 1));
      }
    } else if (newIndex != null) {
      shouldPauseResume = newIndex === playerIndex;
    } else {
      shouldPauseResume = true;
    }
  }

  if (shouldPauseResume) {
    if (getPlayerIsPlaying()) {
      live('spotify:player').emit('pause');
    } else {
      live('spotify:player').emit('resume');
    }
  } else {
    var eventData = {
      context: data.contextUri,
      index: newIndex,
      source: data.source,
      reason: data.reason
    };

    if (range) {
      eventData.range = [range.start, range.end];
    }

    if (uids) {
      eventData.uids = uids;
    }

    if (uris) {
      eventData.uris = uris;
    }

    live('spotify:player').emit('play', eventData);
  }
}

/**
 * Handle playing a list row. This function should start playback of a context
 * starting from a specific row.
 *
 * @param {HTMLElement} rowNode A DOM node for a list row.
 * @param {Object} data Object of data about the action:
 *     contextUri: (string) The context URI for the list.
 *     source: (string) The 'play source' value, for logging purposes.
 *     reason: (string) The 'play reason' value, for logging purposes.
 */
function handlePlayFromRow(rowNode, data) {
  var index = parseInt(rowNode.getAttribute('data-context-index'), 10);
  if (isNaN(index)) {
    index = -1;
  }
  var uid = rowNode.getAttribute('data-uid') || '';
  var uri = rowNode.getAttribute('data-uri') || '';

  var eventData = {
    context: data.contextUri,
    index: index,
    source: data.source,
    reason: data.reason
  };

  if (uid) {
    eventData.uids = [uid];
  }

  if (uri) {
    eventData.uris = [uri];
  }

  live('spotify:player').emit('play', eventData);
}

/**
 * Get the nodes inside the passed container node that should be marked as
 * playing.
 *
 * @param {HTMLElement} containerNode The DOM node to search inside.
 * @param {Array.<HTMLElement>} contextNodes Array of DOM nodes that are already
 *     matched based on context URIs. These can be filtered if needed, but
 *     otherwise they should be included in the return value.
 *
 * @return {Array.<HTMLElement>} An array of DOM nodes.
 */
function getPlayingNodes(containerNode, contextNodes) {
  var playerIndex = getPlayerIndex();
  var playerTrackUri = getPlayerTrackUri();
  var variantUri = getPlayerVariantUri();

  // Remove any matched context nodes that have a range specified and where
  // the current player index does not match.
  var filteredContextNodes = filterRanges(playerIndex, contextNodes);

  var selectors = utils.getContextSelectors(variantUri);
  var selectorsWithVariants = utils.getContextSelectorsWithVariants(variantUri);

  var rowNodes = getContextNodesForRows(containerNode, selectors, playerIndex, playerTrackUri) || [];

  var rangeNodes = getContextNodesForRanges(containerNode, selectorsWithVariants, playerIndex) || [];

  var buttonNodes = [];
  if (contextNodes.length) {
    buttonNodes = $(contextNodes).search('[data-button=play-context]');
  }

  // Let `elements` remove any duplicate nodes
  var nodes = $([filteredContextNodes, rowNodes, rangeNodes, buttonNodes]);

  return nodes ? Array.prototype.slice.call(nodes) : [];
}

/**
 * Get the nodes inside the passed container node that match what's currently
 * playing and are list rows.
 *
 * @param {HTMLElement} containerNode The DOM node to search inside.
 * @param {Array.<string>} selectors Array of CSS selectors for matching the
 *     currently playing context.
 * @param {number} index The currently playing index.
 * @param {string} trackUri The URI of the currently playing track.
 *
 * @return {Array.<HTMLElement>} Array of DOM nodes.
 */
function getContextNodesForRows(containerNode, selectors, index, trackUri) {
  var isShuffling = getPlayerIsShuffling();

  // When playing from this client, we highlight the playing index if the
  // playing variant and the list variant are exactly the same.
  //
  // Removed support for connect as we can no longer detect a connect session: KM-9645.

  var useIndexSelector = !isShuffling;
  var useTrackSelector = !!trackUri;

  var selector = selectors.map(function (selector) {
    if (useIndexSelector || useTrackSelector) selector += ' ';
    if (useIndexSelector) selector += '[data-context-index=' + index + ']';
    if (useTrackSelector) selector += '[data-uri="' + trackUri + '"]';
    return selector;
  }).join(', ');

  var nodes = selector && $(containerNode).search(selector);
  if (nodes) {
    nodes = Array.prototype.slice.call(nodes);

    if (isShuffling) {
      // As the lax matching used in this case might yield duplicate rows in a
      // single list, we must filter out those.
      nodes = nodes.filter(function (row, i) {
        var listNode = $(row).parent('[data-list]');
        // If this row is not the first row to be highlighted in this list,
        // filter it out.
        return row === find(nodes, function (row) {
          return listNode === $(row).parent('[data-list]');
        });
      });
    }
  } else {
    nodes = [];
  }

  return nodes;
}

/**
 * Get the nodes inside the passed container node that match what's currently
 * playing and have a matching range specified.
 *
 * @param {HTMLElement} containerNode The DOM node to search inside.
 * @param {Array.<string>} selectors Array of CSS selectors for matching the
 *     currently playing context.
 * @param {number} index The currently playing index.
 *
 * @return {Array.<HTMLElement>} Array of DOM nodes.
 */
function getContextNodesForRanges(containerNode, selectors, index) {
  var rangeAttribute = '[data-range]';

  // It needs to search for all range elements somewhere inside an element
  // marked up as a context, as well as range elements that themselves are
  // contexts.
  selectors = selectors.map(function (selector) {
    var rangeInContextSelector = selector + ' ' + rangeAttribute;
    var rangedContextSelector = selector + rangeAttribute;
    var rangeSelector = rangeInContextSelector + ', ' + rangedContextSelector;
    return rangeSelector;
  });

  var rangeNodes = $(containerNode).search(selectors.join(', '));
  if (rangeNodes) {
    rangeNodes = Array.prototype.slice.call(rangeNodes);
  } else {
    rangeNodes = [];
  }

  return filterRanges(index, rangeNodes);
}

/**
 * Return a new array of nodes where nodes that specify a range that doesn't
 * match the currently playing index are removed.
 *
 * @param {number=} index The currently playing index. Can be undefined/null.
 * @param {Array.<HTMLElement>} nodes Array of DOM nodes.
 *
 * @return {Array.<HTMLElement>} Array of DOM nodes.
 */
function filterRanges(index, nodes) {
  var thisRange = index != null ? new Range(index, index + 1) : null;

  return nodes.filter(function (node) {
    node = $(node);
    var range = node.data('range');

    // Node without a range should always be active
    if (!range) return true;

    // If player has no index, but the node has a range, we can't be sure if
    // it's playing
    if (!thisRange) return false;

    range = Range.fromString(range);
    return range.contains(thisRange);
  });
}

},{"../../spotify-elements":259,"../../spotify-live":439,"../../spotify-range2":489,"./actions":287,"./updates":289,"./utils":290,"mout/array/find":630}],292:[function(require,module,exports){
'use strict';

var live = require('../../spotify-live');
var Range = require('../../spotify-range2');
var $ = require('../../spotify-elements');

var playerActions = require('./actions');
var playerUpdates = require('./updates');
var utils = require('./utils');

var isAttached = false;

exports.attach = function () {
  if (isAttached) return;
  isAttached = true;

  playerActions.setMethods({
    getPlayerVariantUri: getPlayerVariantUri,
    handlePlayButton: handlePlayButton,
    handlePlayFromRow: handlePlayFromRow
  });

  playerUpdates.setMethods({
    getPlayerVariantUri: getPlayerVariantUri,
    getPlayerIsPlaying: getPlayerIsPlaying,
    getPlayingNodes: getPlayingNodes,
    subscribeToPlayerChange: subscribeToPlayerChange
  });

  playerActions.attach();
  playerUpdates.attach();
};

exports.detach = function () {
  if (!isAttached) return;
  isAttached = false;

  playerActions.detach();
  playerUpdates.detach();
};

exports.update = function (optNode) {
  if (!isAttached) return;

  playerUpdates.update(optNode);
};

/**
 * Get the variant URI for the currently playing context. For example, if
 * playing a sorted playlist, this should return the sorted URI.
 *
 * @return {string} The context variant URI, or empty string if nothing is
 *     playing.
 */
function getPlayerVariantUri() {
  var variant = live('spotify:player').get('variant');
  return variant ? variant.uri : '';
}

/**
 * Get the index of the currently playing page.
 *
 * @return {number} The page index, or -1 if not found.
 */
function getPlayerPageIndex() {
  var indexObject = live('spotify:player').get('index');
  var pageIndex = indexObject && indexObject.get('page');
  var hasPageIndex = typeof pageIndex === 'number';
  return hasPageIndex ? pageIndex : -1;
}

/**
 * Get the UID of the currently playing track.
 *
 * @return {string} The UID, or empty string if not found.
 */
function getPlayerTrackUid() {
  return live('spotify:player').get('uid') || '';
}

/**
 * Get the uri of the currently playing track.
 *
 * @return {string} The uri, or empty string if not found.
 */
function getPlayerTrackUri() {
  var track = live('spotify:player').get('track');
  return track ? track.get('uri') || '' : '';
}

/**
 * Get the URI of the currently playing track.
 *
 * @return {string} The track URI, or empty string if nothing is playing.
 */
function getPlayerTrackUri() {
  var track = live('spotify:player').get('track');
  return track && track.uri || '';
}

/**
 * Get the playing status of the player.
 *
 * @return {boolean} True if the player is currently playing audio.
 */
function getPlayerIsPlaying() {
  var isPlaying = live('spotify:player').get('isPlaying');
  var isPaused = live('spotify:player').get('isPaused');
  return isPlaying && !isPaused;
}

/**
 * Get whether the playback was initiated from open.spotify.com
 *
 * This info is needed to be able to do a best-effort of highlighting rows when
 * playing from open.
 *
 * @return {boolean} True if playing from open.spotify.com.
 */
function getPlayerIsPlayingFromOpen() {
  var playOrigin = live('spotify:player').get('playOrigin');
  var externalReferrer = playOrigin && playOrigin.get('externalReferrer');

  return externalReferrer && externalReferrer.indexOf('https://open.spotify.com/') === 0;
}

/**
 * Subscribe to player changes.
 *
 * @param {Function} handler A handler function. The data passed to this
 *     function is irrelevent, only the fact that something changed is needed.
 *
 * @return {Object} An object with a `cancel` method to cancel the subscription.
 */
function subscribeToPlayerChange(handler) {
  live('spotify:player').on('update', handler);
  var active = true;
  return {
    cancel: function cancel() {
      if (active) {
        live('spotify:player').off('update', handler);
        active = false;
      }
    }
  };
}

/**
 * Handle the click of a play button.
 * This function should decide what the action should be, and pause/resume
 * playback or start playback of a new context.
 *
 * @param {HTMLElement} buttonNode A button DOM node.
 * @param {Object} data Object of data about the action:
 *     isPlayingContext: (boolean) Whether the button looks to be representing
 *         the currently playing context.
 *     contextUri: (string) The context URI for the button.
 *     source: (string) The 'play source' value, for logging purposes.
 *     reason: (string) The 'play reason' value, for logging purposes.
 */
function handlePlayButton(buttonNode, data) {
  var isPlaying = data.isPlayingContext;

  var button = $(buttonNode);

  var trackUid = utils.getAttributeValueFromNode(buttonNode, 'data-uid');
  var trackUri = utils.getAttributeValueFromNode(buttonNode, 'data-track-uri');
  var pageIndex = parseInt(utils.getAttributeValueFromNode(buttonNode, 'data-context-page'), 10);

  if (isPlaying) {
    isPlaying = verifyIsPlayingIndex(trackUid, trackUri, pageIndex);
  }

  if (isPlaying) {
    if (getPlayerIsPlaying()) {
      live('spotify:player').emit('pause');
    } else {
      live('spotify:player').emit('resume');
    }
  } else {

    var eventData = {
      context: data.contextUri,
      source: data.source,
      reason: data.reason
    };

    if (trackUid) {
      eventData.uid = trackUid;
    }

    if (trackUri) {
      eventData.trackUri = trackUri;
    }

    if (!isNaN(pageIndex)) {
      eventData.page = pageIndex;
    }

    live('spotify:player').emit('play', eventData);
  }
}

/**
 * Verify that a uid, uri or pageIndex is playing, or that just the context
 * is playing when none of that is set.
 * This is used when we already know that we're playing the context.
 *
 * @param {string} trackUid
 * @param {string} trackUri
 * @param {number} pageIndex
 *
 * @return {boolean} True if it's really playing
 */
function verifyIsPlayingIndex(trackUid, trackUri, pageIndex) {
  if (trackUid) {
    var playerTrackUid = getPlayerTrackUid();
    return playerTrackUid === trackUid;
  }

  if (trackUri) {
    var playerTrackUri = getPlayerTrackUri();
    return playerTrackUri === trackUri;
  }

  if (!isNaN(pageIndex)) {
    var playerPageIndex = getPlayerPageIndex();
    return playerPageIndex === pageIndex;
  }

  // No index given also means it's really playing.
  return true;
}

/**
 * Handle playing a list row. This function should start playback of a context
 * starting from a specific row.
 *
 * @param {HTMLElement} rowNode A DOM node for a list row.
 * @param {Object} data Object of data about the action:
 *     contextUri: (string) The context URI for the list.
 *     source: (string) The 'play source' value, for logging purposes.
 *     reason: (string) The 'play reason' value, for logging purposes.
 */
function handlePlayFromRow(rowNode, data) {
  var eventData = {
    context: data.contextUri,
    source: data.source,
    reason: data.reason
  };

  var uid = rowNode.getAttribute('data-uid');
  if (uid) {
    eventData.uid = uid;
  }

  var pageIndex = parseInt(utils.getAttributeValueFromNode(rowNode, 'data-context-page'), 10);
  if (!isNaN(pageIndex)) {
    eventData.page = pageIndex;
  }

  live('spotify:player').emit('play', eventData);
}

/**
 * Get the nodes inside the passed container node that should be marked as
 * playing.
 *
 * @param {HTMLElement} containerNode The DOM node to search inside.
 * @param {Array.<HTMLElement>} contextNodes Array of DOM nodes that are already
 *     matched based on context URIs. These can be filtered if needed, but
 *     otherwise they should be included in the return value.
 *
 * @return {Array.<HTMLElement>} An array of DOM nodes.
 */
function getPlayingNodes(containerNode, contextNodes) {
  var playerPageIndex = getPlayerPageIndex();
  var playerTrackUid = getPlayerTrackUid();
  var playerTrackUri = getPlayerTrackUri();
  var variantUri = getPlayerVariantUri();

  // Remove any matched context nodes that have a page specified and where
  // the current player page does not match.
  var filteredContextNodes = filterPages(playerPageIndex, contextNodes);

  var selectors = utils.getContextSelectors(variantUri);
  var rowNodes = getContextNodesForRows(containerNode, selectors, playerTrackUid, playerTrackUri) || [];

  var selectorsWithVariants = utils.getContextSelectorsWithVariants(variantUri);
  var pageNodes = getContextNodesForPages(containerNode, selectorsWithVariants, playerPageIndex) || [];

  var buttonNodes = [];
  if (contextNodes.length) {
    buttonNodes = $(contextNodes).search('[data-button=play-context]');
  }

  // Let `elements` remove any duplicate nodes
  var nodes = $([filteredContextNodes, rowNodes, pageNodes, buttonNodes]);

  return nodes ? Array.prototype.slice.call(nodes) : [];
}

/**
 * Get the nodes inside the passed container node that match what's currently
 * playing and are list rows.
 *
 * @param {HTMLElement} containerNode The DOM node to search inside.
 * @param {Array.<string>} selectors Array of CSS selectors for matching the
 *     currently playing context.
 * @param {string} trackUid The UID of the currently playing track.
 *
 * @return {Array.<HTMLElement>} Array of DOM nodes.
 */
function getContextNodesForRows(containerNode, selectors, trackUid, trackUri) {

  // When playing from this client, we highlight the playing UIDs.
  var useTrackSelector = getPlayerIsPlayingFromOpen();

  var selector = selectors.map(function (selector) {
    selector += ' ';
    if (useTrackSelector) selector += '[data-uri=' + trackUri + ']';
    if (!useTrackSelector) selector += '[data-uid=' + trackUid + ']';
    return selector;
  }).join(', ');

  var nodes = $(containerNode).search(selector);
  if (nodes) {
    nodes = Array.prototype.slice.call(nodes);

    if (useTrackSelector) {
      // Gets UID of the first node and find all the nodes
      // with the same UID
      var firstUid = $(nodes[0]).data('uid');
      nodes = nodes.filter(function (row, i) {
        return firstUid === $(row).data('uid');
      });
    }
  } else {
    nodes = [];
  }

  return nodes;
}

/**
 * Get the nodes inside the passed container node that match what's currently
 * playing and have a matching page specified.
 *
 * @param {HTMLElement} containerNode The DOM node to search inside.
 * @param {Array.<string>} selectors Array of CSS selectors for matching the
 *     currently playing context.
 * @param {number} playerPageIndex The currently playing page index.
 *
 * @return {Array.<HTMLElement>} Array of DOM nodes.
 */
function getContextNodesForPages(containerNode, selectors, playerPageIndex) {
  var pageAttribute = '[data-context-page]';

  // It needs to search for all range elements somewhere inside an element
  // marked up as a context, as well as range elements that themselves are
  // contexts.
  selectors = selectors.map(function (selector) {
    var pageInContextSelector = selector + ' ' + pageAttribute;
    var pagedContextSelector = selector + pageAttribute;
    var pageSelector = pageInContextSelector + ', ' + pagedContextSelector;
    return pageSelector;
  });

  var pageNodes = $(containerNode).search(selectors.join(', '));
  if (pageNodes) {
    pageNodes = Array.prototype.slice.call(pageNodes);
  } else {
    pageNodes = [];
  }

  return filterPages(playerPageIndex, pageNodes);
}

/**
 * Return a new array of nodes where nodes that specify a context page that
 * doesn't match the currently playing context page are removed.
 *
 * @param {number} playerPageIndex The currently playing page index.
 * @param {Array.<HTMLElement>} contextNodes Array of already matched nodes.
 *
 * @return {Array.<HTMLElement>} Array of filtered nodes.
 */
function filterPages(playerPageIndex, contextNodes) {
  return contextNodes.filter(function (node) {
    var nodePageIndex = parseInt(node.getAttribute('data-context-page'), 10);

    // Node without a page should always be active
    if (isNaN(nodePageIndex)) return true;

    // If player has no page, but the node has a page, we can't be sure if it's
    // playing.
    if (isNaN(playerPageIndex)) return false;

    // Node that matches the player page should be active
    return playerPageIndex === nodePageIndex;
  });
}

},{"../../spotify-elements":259,"../../spotify-live":439,"../../spotify-range2":489,"./actions":287,"./updates":289,"./utils":290}],293:[function(require,module,exports){
'use strict';

var Range = require('../spotify-range2');

var contains = require('mout/array/contains');

var $ = require('../spotify-elements');

var SYNC = require('prime/emitter').EMIT_SYNC;

var throttle = require('./util/throttle');
var ListManager = require('./util/ListManager.js');

var center = require('./center');

var doc = $(document);
var win = $(window);

var scrollContainers = [];
var listManagers = [];
var scrollHandlers = [];
var pendingScrollContainers = [];
var pendingHiddenIndices = [];
var cleanupHandlers = [];

var getBounds = function getBounds(view, container) {
  var dde = document.documentElement;

  if (view === window || view === document.body) view = dde;
  var viewTop = view === dde ? 0 : view.getBoundingClientRect().top;

  var viewHeight = view.clientHeight;
  var containerTop = container.getBoundingClientRect().top;
  var containerHeight = container.offsetHeight;

  var viewBox = {
    top: viewTop,
    height: viewHeight,
    bottom: viewTop + viewHeight
  };

  var containerBox = {
    top: containerTop,
    height: containerHeight,
    bottom: containerTop + containerHeight
  };

  return {
    view: viewBox,
    container: containerBox
  };
};

var getRange = function getRange(view, container, height, hotZone) {
  hotZone = hotZone || 0;
  var bounds = getBounds(view, container);
  var top = -(bounds.container.top - bounds.view.top);
  var startsAt = Math.floor((top - hotZone) / height);
  var endsAt = Math.ceil((top + bounds.view.height + hotZone) / height);
  if (startsAt < 0) startsAt = 0;
  if (endsAt <= startsAt) return false;
  return new Range(startsAt, endsAt);
};

var init = function init(view, container, length, height, tag) {
  var view0 = view[0];
  var container0 = container[0];

  container.addClass('scroll-container-enabled');

  var manager = new ListManager(container0, {
    height: height,
    length: length,
    tag: tag,
    debug: false,
    request: function request(range, callback) {
      center.emit('scroll-request', container0, range, callback, SYNC);
    }
  });
  listManagers.push(manager);

  // Update the manager with previously saved hidden indices.
  // This allows the scroller to take hidden indices into account even for the
  // first render.
  var pendingIndex = pendingScrollContainers.indexOf(container);
  if (pendingIndex > -1) {
    manager.reset(length, pendingHiddenIndices[pendingIndex]);
    pendingScrollContainers.splice(pendingIndex, 1);
    pendingHiddenIndices.splice(pendingIndex, 1);
  }

  manager.on('before-show', function (range, nodes) {
    center.emit('scroll-show-before', {
      pageNode: container,
      container: container,
      range: range,
      nodes: nodes
    }, SYNC);
  });

  manager.on('after-show', function (range, nodes) {
    center.emit('scroll-show-after', {
      pageNode: container,
      container: container,
      range: range,
      nodes: nodes
    }, SYNC);
  });

  manager.on('index-change', function (index) {
    center.emit('scroll-index-change', {
      pageNode: container,
      container: container,
      ranges: index
    }, SYNC);
  });

  var hasRequestedMore = false;

  var scroll = function scroll() {
    var bounds = getBounds(view0, container0);
    var show = getRange(view0, container0, height);

    if (show) {
      var padding = 2;
      show = new Range(show.start - padding, show.end + padding);
      manager.show(new Range(show.start, show.end));
    }

    // If the scroll position is close enough to the end, an event should be
    // emitted to allow for more content to be loaded. Not all lists will use this,
    // but some lists want to lazy load content by loading more when you reach the
    // bottom, and then they can listen for this event.
    if (!hasRequestedMore) {
      if (bounds.container.bottom < 2000) {
        hasRequestedMore = true;

        // Emit the event and also pass a callback to the event.
        // The receiver of this event should pass the new total length of the list
        // as the second argument to the callback.
        center.emit('scroll-request-more', container0, function (error, length) {
          if (error) throw error;
          hasRequestedMore = false;
          scrollReset(container0, length);
        });
      }
    }
  };

  scrollHandlers.push(scroll);

  scroll = container._scrollEvent = throttle(scroll);

  var scrollReset = function scrollReset(c, height, opt_hiddenIndices, opt_fromIndex) {
    if ($(c) === container) {
      var hasFromIndex = typeof opt_fromIndex === 'number';
      if (hasFromIndex && opt_fromIndex > 0) {
        manager.resetFrom(opt_fromIndex, height, opt_hiddenIndices);
      } else {
        manager.reset(height, opt_hiddenIndices);
      }
      scroll();
    }
  };

  center.on('scroll-reset', scrollReset);
  container._scrollResetEvent = scrollReset;

  var scrollToIndex = function scrollToIndex(c, index, opt_offsetScrollPosition) {
    if (view0 !== window) {
      throw new Error('Can\'t scroll to index if view is not `window`');
      return;
    }

    if ($(c) === container) {
      var bounds = getBounds(view0, container0);

      // Let's say we scroll the sidebar to show the playlist at 200px from
      // the top or the bottom (depending if it was above or below fold).
      // If the sidebar height is smaller than 400px, we vertically center the
      // playlist:
      var offset = Math.min(opt_offsetScrollPosition || 0, (bounds.view.height - manager.height) / 2);

      var indexTopRelativeToContainer = manager.height * index;
      var position = bounds.container.top + indexTopRelativeToContainer;

      var scrollY = position + window.pageYOffset;
      var stickyOffset = (doc.search('[data-sticky-active]') || []).map(function (sticky) {
        return sticky.offsetHeight;
      }).reduce(function (a, b) {
        return a + b;
      }, 0);

      if (position <= stickyOffset) {
        // item is above viewport
        scrollY -= offset + stickyOffset;
      } else if (position + manager.height > bounds.view.height) {
        // item is below viewport
        scrollY += offset + manager.height - bounds.view.height;
      } else {
        // item is in viewport
        return;
      }

      view0.scrollTo(0, scrollY);
    }
  };

  center.on('scroll-to-index', scrollToIndex);

  view.on('scroll', scroll);
  win.on('resize', scroll);
  scroll();

  cleanupHandlers.push(function () {
    center.off('scroll-reset', scrollReset);
    center.off('scroll-to-index', scrollToIndex);
    view.off('scroll', scroll);
    win.off('resize', scroll);

    container.removeClass('scroll-container-enabled');
  });
};

function onScrollSetHidden(data) {
  var hiddenIndices = data.indices;

  var container = $(data.itemContainer);
  var index = scrollContainers.indexOf(container);
  if (index > -1) {
    var manager = listManagers[index];
    if (manager) {
      manager.reset(manager.length, hiddenIndices);
    }
    var scrollHandler = scrollHandlers[index];
    if (scrollHandler) {
      scrollHandler();
    }
  } else {
    pendingScrollContainers.push(container);
    pendingHiddenIndices.push(hiddenIndices);
  }
}

var isAttached = false;

exports.update = function (node) {
  if (!isAttached) return;

  node = $(node) || doc;

  var scrollNodes = doc.search('[data-scroll-container]');

  var handlers = [];
  var managers = [];
  scrollContainers = scrollContainers.filter(function (container, index) {
    if (!contains(scrollNodes, container[0])) {
      container._view.off('scroll', container._scrollEvent);
      win.off('resize', container._scrollEvent);
      center.off('scroll-reset', container._scrollResetEvent);
      delete container._scrollEvent;
      delete container._scrollResetEvent;
      return false;
    }
    managers.push(listManagers[index]);
    handlers.push(scrollHandlers[index]);
    return true;
  });
  listManagers = managers;
  scrollHandlers = handlers;

  if (node !== doc) scrollNodes = node.search('[data-scroll-container]');

  if (scrollNodes) scrollNodes.forEach(function (node0) {
    var container = $(node0);

    if (container._scrollEvent || node0.children.length) return;

    scrollContainers.push(container);
    var view = container.parent('[data-scroll-view]') || win;
    container._view = view;

    var callback = function callback(error, children, length) {
      if (error) throw error;
      children = $(children);
      children.insert(container);

      var second = children[1];
      var height = second.offsetHeight;
      var tag = $(second).tag();
      children.remove();
      init(view, container, length, height, tag);
    };

    center.emit('scroll-request', container[0], new Range(0, 3), callback, SYNC);
  });
};

exports.attach = function () {
  if (isAttached) return;
  isAttached = true;

  center.on('scroll-set-hidden', onScrollSetHidden);
};

exports.detach = function () {
  if (!isAttached) return;
  isAttached = false;

  center.off('scroll-set-hidden', onScrollSetHidden);

  cleanupHandlers.forEach(function (cleanupHandler) {
    cleanupHandler();
  });
  cleanupHandlers = [];
};

},{"../spotify-elements":259,"../spotify-range2":489,"./center":268,"./util/ListManager.js":316,"./util/throttle":322,"mout/array/contains":625,"prime/emitter":677}],294:[function(require,module,exports){
'use strict';

/**
 * Module for handling clicks on the scroll bar track to scroll pages.
 *
 * @private
 */

var BezierEasing = require('bezier-easing');

var config = require('./config');

module.exports = {

  // Called from outside
  setHandler: function setHandler(eventName, scroller, handler) {
    if (eventName === 'clickEnd') {
      scroller._clickEndHandler = handler;
    }
  },

  scrollTo: function scrollTo(scroller, newPosition, useEasing, callback) {
    var startPosition = scroller.view.scrollTop;
    var positionDiff = newPosition - startPosition;

    var startTimestamp = Date.now();
    var totalTime = config.scrollToTransitionMs;

    if (!useEasing) {
      totalTime = config.scrollToLinearTransitionMs;
    }

    // Ease in/out quadratic
    var easing = new BezierEasing(0.455, 0.03, 0.515, 0.955);

    var tick = function tick() {
      var elapsedTime = Date.now() - startTimestamp;
      var totalPercentage = elapsedTime / totalTime;

      var currentPercentage = useEasing ? easing.get(totalPercentage) : totalPercentage;

      scroller.view.scrollTop = startPosition + positionDiff * currentPercentage;

      if (totalPercentage < 1) {
        // Must use setTimeout to not make it flicker. Setting scrollTop in
        // requestAnimationFrame will make it scroll and in the next frame allow
        // the scroll handlers to move elements, making it look very flickery.
        setTimeout(tick, config.frameMs);
      } else {
        scroller.view.scrollTop = startPosition + positionDiff;
        scroller.isClickScrollAnimating = false;
        if (callback) {
          callback();
        }
      }
    };

    scroller.isClickScrollAnimating = true;
    setTimeout(tick, config.frameMs);
  },

  holdClick: function holdClick(scroller) {
    var targetThumbEdge = scroller.clickTargetThumbTop;
    var newPosition = this.getNextScrollValue(scroller);
    var newThumbTop = newPosition / scroller.viewScrollHeight * scroller.viewHeight;
    var newThumbBottom = newThumbTop + scroller.thumbHeight;
    var direction = scroller.clickTargetDirection;

    var isValid = false;
    if (direction === 'up' && newThumbBottom > targetThumbEdge) {
      isValid = true;
    } else if (direction === 'down' && newThumbTop < targetThumbEdge) {
      isValid = true;
    }

    if (isValid) {
      var useEasing = false;

      this.scrollTo(scroller, newPosition, useEasing, function () {
        if (scroller.isClickScrolling) {
          this.holdClick(scroller);
        }
      }.bind(this));
    }
  },

  getNextScrollValue: function getNextScrollValue(scroller) {
    var change = scroller.viewHeight * config.clickScrollDistanceFactor;

    if (scroller.clickTargetDirection === 'up') {
      return scroller.view.scrollTop - change;
    }

    return scroller.view.scrollTop + change;
  },

  setMovementData: function setMovementData(scroller, clientY) {
    var trackTop = scroller.scrollBarTrack.getBoundingClientRect().top;
    var targetThumbEdge = clientY - trackTop;
    var direction = targetThumbEdge < scroller.thumbTop ? 'up' : 'down';

    scroller.clickTargetDirection = direction;
    scroller.clickTargetThumbTop = targetThumbEdge;
  },

  onClickHold: function onClickHold(scroller) {
    scroller.isClickScrolling = true;

    this.holdClick(scroller);
  },

  onMouseMove: function onMouseMove(scroller, event) {
    if (scroller.isMouseOver && event.target === scroller.scrollBarTrack) {
      this.setMovementData(scroller, event.clientY);

      if (scroller.isClickScrolling && !scroller.isClickScrollAnimating) {
        this.holdClick(scroller);
      }
    }
  },

  onMouseUp: function onMouseUp(scroller) {
    scroller.isClickScrolling = false;

    clearTimeout(scroller.clickHoldTimer);

    this.removeHandlers(scroller);

    if (scroller._clickEndHandler) {
      scroller._clickEndHandler();
    }
  },

  onTrackMouseDown: function onTrackMouseDown(scroller, event) {
    var isVisible = scroller.isVisible;
    var isPrimaryButton = event.button === 0;
    var isTargetTrack = event.target === scroller.scrollBarTrack;

    if (isVisible && isPrimaryButton && isTargetTrack) {
      var navigator = window.navigator;
      var isMac = navigator && navigator.userAgent.indexOf('Mac') > -1;
      var isWindows = navigator && navigator.userAgent.indexOf('Windows') > -1;

      if (isMac && event.altKey || isWindows && event.shiftKey) {
        var trackTop = scroller.scrollBarTrack.getBoundingClientRect().top;
        var targetThumbCenter = event.clientY - trackTop;
        var targetThumbTop = Math.max(0, Math.min(scroller.viewHeight - scroller.thumbHeight, targetThumbCenter - scroller.thumbHeight / 2));

        scroller.view.scrollTop = targetThumbTop / (scroller.viewHeight - scroller.thumbHeight) * (scroller.viewScrollHeight - scroller.viewHeight);
      } else {
        this.setMovementData(scroller, event.clientY);

        var targetPosition = this.getNextScrollValue(scroller);
        var useEasing = true;

        this.scrollTo(scroller, targetPosition, useEasing);

        this.addHandlers(scroller);

        scroller.clickHoldTimer = setTimeout(this.onClickHold.bind(this, scroller), config.scrollToTransitionMs + config.clickHoldDelayMs);
      }
    }
  },

  addHandlers: function addHandlers(scroller) {
    scroller._click_onMouseUp = this.onMouseUp.bind(this, scroller);
    scroller._click_onMouseMove = this.onMouseMove.bind(this, scroller);

    document.addEventListener('mouseup', scroller._click_onMouseUp, false);
    document.addEventListener('mousemove', scroller._click_onMouseMove, false);
  },

  removeHandlers: function removeHandlers(scroller) {
    document.removeEventListener('mouseup', scroller._click_onMouseUp, false);
    document.removeEventListener('mousemove', scroller._click_onMouseMove, false);
  },

  attach: function attach(scroller) {
    var onTrackMouseDown = this.onTrackMouseDown.bind(this, scroller);

    scroller.scrollBarTrack.addEventListener('mousedown', onTrackMouseDown, false);

    return function () {
      scroller.scrollBarTrack.removeEventListener('mousedown', onTrackMouseDown, false);
    };
  }

};

},{"./config":295,"bezier-easing":503}],295:[function(require,module,exports){
"use strict";

/**
 * Config with all timer values etc. Easy to have them all in one place, and it
 * also helps for testing, since the config can be used from there too.
 *
 * @private
 */

module.exports = {
  hideAfterMs: 750,
  showAfterMs: 500,

  // Sync with CSS transition duration
  hideTransitionMs: 500,

  expandDelayMs: 150,

  frameMs: 16,
  scrollToTransitionMs: 200,
  scrollToLinearTransitionMs: 120,
  clickHoldDelayMs: 500,
  clickScrollDistanceFactor: 0.95
};

},{}],296:[function(require,module,exports){
'use strict';

/**
 * Module for handling dragging the scroll bar thumb to scroll.
 *
 * @private
 */

module.exports = {

  // Called from outside
  setHandler: function setHandler(eventName, scroller, handler) {
    if (eventName === 'dragStart') {
      scroller._dragStartHandler = handler;
    } else if (eventName === 'dragEnd') {
      scroller._dragEndHandler = handler;
    }
  },

  onThumbMouseDown: function onThumbMouseDown(scroller, event) {
    if (event.button === 0 && scroller.isVisible) {
      scroller.isDragging = true;
      scroller.startDragMouseY = event.clientY;
      scroller.startDragThumbTop = scroller.thumbTop;

      this.addDragHandlers(scroller);

      if (scroller._dragStartHandler) {
        scroller._dragStartHandler();
      }
    }
  },

  onMouseUp: function onMouseUp(scroller, event) {
    if (scroller.isDragging) {
      scroller.isDragging = false;

      this.removeDragHandlers(scroller);

      if (scroller._dragEndHandler) {
        scroller._dragEndHandler();
      }
    }
  },

  onMouseMove: function onMouseMove(scroller, event) {
    var y = event.clientY;
    var startY = scroller.startDragMouseY;

    scroller.thumbTop = Math.max(0, Math.min(scroller.viewHeight - scroller.thumbHeight, scroller.startDragThumbTop + y - startY));

    scroller.view.scrollTop = scroller.thumbTop / (scroller.viewHeight - scroller.thumbHeight) * (scroller.viewScrollHeight - scroller.viewHeight);
  },

  addDragHandlers: function addDragHandlers(scroller) {
    scroller._drag_onMouseMove = this.onMouseMove.bind(this, scroller);
    scroller._drag_onMouseUp = this.onMouseUp.bind(this, scroller);

    document.addEventListener('mousemove', scroller._drag_onMouseMove, false);
    document.addEventListener('mouseup', scroller._drag_onMouseUp, false);
  },

  removeDragHandlers: function removeDragHandlers(scroller) {
    document.removeEventListener('mousemove', scroller._drag_onMouseMove, false);
    document.removeEventListener('mouseup', scroller._drag_onMouseUp, false);
  },

  attach: function attach(scroller) {
    var onThumbMouseDown = this.onThumbMouseDown.bind(this, scroller);

    scroller.scrollBarThumb.addEventListener('mousedown', onThumbMouseDown, false);

    return function () {
      scroller.scrollBarThumb.removeEventListener('mousedown', onThumbMouseDown, false);
    };
  }

};

},{}],297:[function(require,module,exports){
'use strict';

/**
 * Module for handling expanding the scroll bar width on hover.
 *
 * @private
 */

var config = require('./config');

module.exports = {

  expand: function expand(scroller) {
    clearTimeout(scroller.resetExpandedTimer);
    scroller.scrollBarTrack.classList.add('expanded');
  },

  collapse: function collapse(scroller) {
    scroller.scrollBarTrack.classList.remove('expanded');
  },

  // Called from outside
  onHide: function onHide(scroller) {
    if (!scroller.alwaysVisible) {
      clearTimeout(scroller.expandTimer);
      clearTimeout(scroller.resetExpandedTimer);

      scroller.resetExpandedTimer = setTimeout(this.collapse.bind(this, scroller), config.hideTransitionMs);
    }
  },

  onTrackMouseEnter: function onTrackMouseEnter(scroller, event) {
    if (event.target === scroller.scrollBarTrack) {
      if (scroller.isVisible) {
        clearTimeout(scroller.expandTimer);
        clearTimeout(scroller.resetExpandedTimer);
        scroller.expandTimer = setTimeout(function () {
          this.expand(scroller);
        }.bind(this), config.expandDelayMs);
      } else {
        this.expand(scroller);
      }
    }
  },

  onTrackMouseLeave: function onTrackMouseLeave(scroller, event) {
    if (event.target === scroller.scrollBarTrack) {
      if (scroller.isVisible) {
        clearTimeout(scroller.expandTimer);
      } else {
        this.collapse(scroller);
      }
    }
  },

  attach: function attach(scroller) {
    if (scroller.alwaysVisible) {
      this.expand(scroller);

      return function () {};
    } else {
      this.collapse(scroller);

      var onTrackMouseEnter = this.onTrackMouseEnter.bind(this, scroller);
      var onTrackMouseLeave = this.onTrackMouseLeave.bind(this, scroller);

      scroller.scrollBarTrack.addEventListener('mouseenter', onTrackMouseEnter, false);
      scroller.scrollBarTrack.addEventListener('mouseleave', onTrackMouseLeave, false);

      return function () {
        scroller.scrollBarTrack.removeEventListener('mouseenter', onTrackMouseEnter, false);
        scroller.scrollBarTrack.removeEventListener('mouseleave', onTrackMouseLeave, false);
      };
    }
  }

};

},{"./config":295}],298:[function(require,module,exports){
'use strict';

var glue = require('../../spotify-glue-cat');
var cosmos = require('spotify-cosmos-api');

var center = require('../center');
var drag = require('./drag');
var visibility = require('./visibility');
var position = require('./position');
var expansion = require('./expansion');
var click = require('./click');

var scrollers = [];
var scrollerStyle = null;

function Scroller(scrollView) {
  this.view = scrollView;
  this.setInitialState();
  this.addScrollBar();
  this.refresh();

  this.view.setAttribute('data-scroll-area-initialized', '');

  this._onResize = function () {
    this.refresh();
  }.bind(this);
  this._onScroll = function () {
    this.refreshScrollBar();
  }.bind(this);
  this._onThumbDragStart = function (event) {
    event.preventDefault();
    event.stopPropagation();
  };

  // Listen for the scroll event to update view size etc on scroll
  var scrollObject = this.isBody ? window : this.view;
  scrollObject.addEventListener('scroll', this._onScroll, false);

  // Listen for the window resize event, even for scroll areas that are not the
  // body scroll. Since we can't listen for resize events when elements resize,
  // we do a best effort of at least updating when the window resizes (which
  // might affect the size of the scroll area).
  window.addEventListener('resize', this._onResize, false);

  // Prevent dragndrop handling from spotify-events (it will be triggered
  // otherwise since we have to set the draggable attribute to not trigger
  // focus events).
  this.scrollBarThumb.addEventListener('dragstart', this._onThumbDragStart, true);

  this._detachVisibility = visibility.attach(this);
  this._detachPosition = position.attach(this);
  this._detachDrag = drag.attach(this);
  this._detachClick = click.attach(this);
  this._detachExpansion = expansion.attach(this);

  visibility.setHandler('show', this, function () {
    this.refresh();
  }.bind(this));

  visibility.setHandler('hide', this, function () {
    expansion.onHide(this);
  }.bind(this));

  // Events are sent when dragging to allow some use cases where you need to do
  // something while dragging. For example, when dragging the scroll bar in the
  // app sidebar and hovering over the main view, it will not trigger mousemove
  // events since the main view is an iframe. To counter that, zlink is
  // listening to these events and sets pointer-events on the content area.
  drag.setHandler('dragStart', this, function () {
    center.emit('scroll-thumb-drag-start', { id: this.viewId });
  }.bind(this));
  drag.setHandler('dragEnd', this, function () {
    visibility.onDragEnd(this);
    center.emit('scroll-thumb-drag-end', { id: this.viewId });
  }.bind(this));

  click.setHandler('clickEnd', this, function () {
    visibility.onClickEnd(this);
  }.bind(this));
}

Scroller.prototype.setInitialState = function () {
  var scrollerStyleToUse = scrollerStyle || window.__spotify.scroller_style;
  this.alwaysVisible = scrollerStyleToUse === 'always';

  this.scrollBarTrack = null;
  this.scrollBarThumb = null;

  this.isBody = this.view === document.body;
  this.viewId = this.view.getAttribute('data-scroll-area');
  this.viewHeight = 0;
  this.viewScrollHeight = 0;

  this.isVisible = false;
  this.isDragging = false;
  this.isMouseOver = false;
  this.isClickScrolling = false;
  this.isClickScrollAnimating = false;

  this.thumbTop = 0;
  this.thumbHeight = 0;

  this.clickTargetDirection = 'down';
  this.clickTargetThumbTop = 0;

  this.startDragMouseY = 0;
  this.startDragThumbTop = 0;

  this.hideTimer = 0;
  this.mouseOverShowTimer = 0;
};

Scroller.prototype.addScrollBar = function () {
  var track = document.createElement('div');
  var thumb = document.createElement('div');

  track.className = 'scrollbar-track';
  thumb.className = 'scrollbar-thumb';

  if (this.alwaysVisible) {
    track.className += ' always-visible';
  }

  // If the thumb is not set to draggable it will trigger focus events on
  // elements being dragged over. For example, dragging the thumb up to the
  // search input puts focus in the search input, which opens the suggest box.
  // Since we will find this element from the dragndrop module, we also need to
  // prevent any drag handling (find the drag listener further down).
  thumb.setAttribute('draggable', 'true');

  track.appendChild(thumb);
  this.view.appendChild(track);

  this.scrollBarTrack = track;
  this.scrollBarThumb = thumb;
};

Scroller.prototype.setViewSize = function () {
  // Hide the scroll bar while calculating sizes, so the scroll bar doesn't
  // interfere. This can happen if scrolled to the bottom of the scroll view and
  // the scroll height changes to be smaller. If the scroll bar is not hidden
  // while calculating the values here, the scrollHeight will not change, since
  // the scroll bar is taking up space.
  this.scrollBarTrack.style.display = 'none';

  if (this.isBody) {
    this.viewHeight = window.innerHeight || Infinity;
  } else {
    this.viewHeight = this.view.clientHeight || Infinity;
  }

  this.viewScrollHeight = this.view.scrollHeight;

  this.scrollBarTrack.style.display = 'block';
};

Scroller.prototype.setThumbSize = function () {
  var percentage = this.viewHeight / this.viewScrollHeight;
  this.thumbHeight = Math.max(40, this.viewHeight * percentage);
  this.scrollBarThumb.style.height = this.thumbHeight + 'px';
};

Scroller.prototype.setTrackPosition = function () {
  this.scrollBarTrack.style.transform = 'translate3d(0, ' + (this.view.scrollTop + 'px') + ', 0)';
};

Scroller.prototype.refresh = function () {
  this.refreshView();
  this.refreshScrollBar();
};

Scroller.prototype.refreshView = function () {
  this.setViewSize();
};

Scroller.prototype.refreshScrollBar = function () {
  this.setThumbSize();

  if (!this.isBody) {
    this.setTrackPosition();
  }
};

Scroller.prototype.update = function () {
  var oldViewHeight = this.viewHeight;
  var oldScrollHeight = this.viewScrollHeight;

  this.refresh();

  visibility.update(this);

  var newViewHeight = this.viewHeight;
  var newScrollHeight = this.viewScrollHeight;

  if (newViewHeight !== oldViewHeight || newScrollHeight !== oldScrollHeight) {
    visibility.highlight(this);
  }
};

Scroller.prototype.setScrollBarMode = function (mode) {
  this.alwaysVisible = mode === 'always';

  if (this.alwaysVisible) {
    this.scrollBarTrack.classList.add('always-visible');
  } else {
    this.scrollBarTrack.classList.remove('always-visible');
  }

  this._detachVisibility();
  this._detachPosition();
  this._detachDrag();
  this._detachClick();
  this._detachExpansion();

  this._detachVisibility = visibility.attach(this);
  this._detachPosition = position.attach(this);
  this._detachDrag = drag.attach(this);
  this._detachClick = click.attach(this);
  this._detachExpansion = expansion.attach(this);
};

Scroller.prototype.isInDOM = function () {
  var currentNode = this.view.parentNode;
  while (currentNode && currentNode !== document.documentElement) {
    currentNode = currentNode.parentNode;
  }

  // If we still have a current node after the loop, we found the document
  // element, which means it's in DOM.
  return !!currentNode;
};

Scroller.prototype.destroy = function () {
  var scrollObject = this.isBody ? window : this.view;

  scrollObject.removeEventListener('scroll', this._onScroll, false);

  window.removeEventListener('resize', this._onResize, false);

  this.scrollBarThumb.removeEventListener('dragstart', this._onThumbDragStart, true);

  this.view.removeAttribute('data-scroll-area-initialized', '');
  this.view.removeChild(this.scrollBarTrack);

  this._detachVisibility();
  this._detachPosition();
  this._detachDrag();
  this._detachClick();
  this._detachExpansion();
};

var isAttached = false;
var controlMessageSubscription;

exports.update = function (node) {
  if (!isAttached) {
    return;
  }

  // Clean up scrollers that are not in DOM anymore.
  scrollers = scrollers.filter(function (scroller) {
    if (!scroller.isInDOM()) {
      scroller.destroy();
      return false;
    }
    return true;
  });

  // Update all active scrollers
  for (var i = 0, l = scrollers.length; i < l; i++) {
    scrollers[i].update();
  }

  var selector = '[data-scroll-area]';
  var scrollViews = (node || document).querySelectorAll(selector);

  for (var i = 0, l = scrollViews.length; i < l; i++) {
    if (!scrollViews[i].hasAttribute('data-scroll-area-initialized')) {
      var scrollView = scrollViews[i];
      var isBody = scrollView === document.body;

      if (isBody && glue.getVersion() !== 2) {
        continue;
      }

      scrollers.push(new Scroller(scrollView));
    }
  }
};

exports.attach = function () {
  if (isAttached) return;
  isAttached = true;

  var setScrollBarMode = function setScrollBarMode(mode) {
    scrollerStyle = mode;

    for (var i = 0, l = scrollers.length; i < l; i++) {
      scrollers[i].setScrollBarMode(mode);
    }
  };

  controlMessageSubscription = cosmos.resolver.subscribe({
    url: 'sp://messages/v1/container/control'
  }, function (error, response) {
    if (!error) {
      var data = response.getJSONBody();
      if (data) {
        var styleWasChanged = true;
        switch (data.type) {
          case 'set_scroller_style_always_visible':
            setScrollBarMode('always');
            break;
          case 'set_scroller_style_overlay':
            setScrollBarMode('overlay');
            break;
          default:
            styleWasChanged = false;
        }

        // Fix a rendering bug in Chromium. When scroller style changes in the
        // system (changing system preference, connecting/disconnecting a mouse
        // etc), Chromium will render a white area where the scroll bar is
        // supposed to be. By adding and removing a class name we're triggering
        // a re-render and it will look good.
        //
        // https://jira.spotify.net/browse/KM-8285
        // http://crbug.com/538579
        if (styleWasChanged) {
          var performFix = function performFix() {
            var nodes = scrollers.map(function (scroller) {
              return scroller.view;
            });

            // Always include body to fix the main scroll, even if it doesn't
            // have a custom scroll bar.
            if (nodes.indexOf(document.body) === -1) {
              nodes.push(document.body);
            }

            for (var i = 0, l = nodes.length; i < l; i++) {
              nodes[i].classList.add('jmeBDLRW3CRWW3kZZaZ');
              nodes[i].classList.remove('jmeBDLRW3CRWW3kZZaZ');
            }
          };

          // Perform the fix twice (once with a delay), since it sometimes might
          // be slow and won't apply the fix on the first try.
          performFix();
          setTimeout(performFix, 1000);
        }
      }
    } else {
      controlMessageSubscription.cancel();
    }
  });
};

exports.detach = function () {
  if (!isAttached) return;
  isAttached = false;

  for (var i = 0, l = scrollers.length; i < l; i++) {
    scrollers[i].destroy();
  }
  scrollers.length = 0;

  scrollerStyle = null;

  if (controlMessageSubscription) {
    controlMessageSubscription.cancel();
    controlMessageSubscription = null;
  }
};

},{"../../spotify-glue-cat":348,"../center":268,"./click":294,"./drag":296,"./expansion":297,"./position":299,"./visibility":300,"spotify-cosmos-api":694}],299:[function(require,module,exports){
'use strict';

/**
 * Module for handling updating the scroll bar thumb position when scroll
 * position changes.
 *
 * @private
 */

module.exports = {

  setThumbPosition: function setThumbPosition(scroller) {
    if (scroller.viewScrollHeight === scroller.viewHeight) {
      scroller.thumbTop = 0;
    } else {
      scroller.thumbTop = scroller.view.scrollTop / (scroller.viewScrollHeight - scroller.viewHeight) * (scroller.viewHeight - scroller.thumbHeight);
    }

    scroller.scrollBarThumb.style.transform = 'translate3d(0, ' + (scroller.thumbTop + 'px') + ', 0)';
  },

  onScroll: function onScroll(scroller) {
    this.setThumbPosition(scroller);
  },

  attach: function attach(scroller) {
    var onScroll = this.onScroll.bind(this, scroller);

    var scrollObject = scroller.isBody ? window : scroller.view;
    scrollObject.addEventListener('scroll', onScroll, false);

    this.setThumbPosition(scroller);

    return function () {
      scrollObject.removeEventListener('scroll', onScroll, false);
    };
  }

};

},{}],300:[function(require,module,exports){
'use strict';

/**
 * Module for handling the visibility of the scroll bar, based on mouse position
 * and scroll events.
 *
 * @private
 */

var config = require('./config');

module.exports = {

  // Called from outside
  setHandler: function setHandler(eventName, scroller, handler) {
    if (eventName === 'show') {
      scroller._showHandler = handler;
    } else if (eventName === 'hide') {
      scroller._hideHandler = handler;
    }
  },

  refresh: function refresh(scroller) {
    if (scroller.viewScrollHeight > scroller.viewHeight) {
      this.showScrollBar(scroller);
    } else {
      this.hideScrollBar(scroller);
    }
  },

  showScrollBar: function showScrollBar(scroller) {
    if (scroller.isVisible) {
      return;
    }

    if (scroller.viewScrollHeight > scroller.viewHeight) {
      scroller.scrollBarTrack.classList.add('visible');
      scroller.isVisible = true;

      if (scroller._showHandler) {
        scroller._showHandler();
      }
    }
  },

  hideScrollBar: function hideScrollBar(scroller) {
    if (!scroller.isVisible || scroller.isDragging) {
      return;
    }

    scroller.scrollBarTrack.classList.remove('visible');
    scroller.isVisible = false;

    if (scroller._hideHandler) {
      scroller._hideHandler();
    }
  },

  startHideTimer: function startHideTimer(scroller) {
    this.stopHideTimer(scroller);
    scroller.hideTimer = setTimeout(this.hideScrollBar.bind(this, scroller), config.hideAfterMs);
  },

  stopHideTimer: function stopHideTimer(scroller) {
    clearTimeout(scroller.hideTimer);
  },

  // Called from outside
  onDragEnd: function onDragEnd(scroller) {
    if (!scroller.alwaysVisible && !scroller.isMouseOver) {
      this.startHideTimer(scroller);
    }
  },

  // Called from outside
  onClickEnd: function onClickEnd(scroller) {
    if (!scroller.alwaysVisible && !scroller.isMouseOver) {
      this.startHideTimer(scroller);
    }
  },

  onScroll: function onScroll(scroller) {
    if (!scroller.isVisible) {
      this.showScrollBar(scroller);
    }

    if (!scroller.isDragging && !scroller.isClickScrolling && !scroller.isMouseOver) {
      this.startHideTimer(scroller);
    }
  },

  onTrackMouseEnter: function onTrackMouseEnter(scroller, event) {
    if (event.target === scroller.scrollBarTrack) {
      scroller.isMouseOver = true;

      this.stopHideTimer(scroller);

      if (!scroller.isVisible) {
        scroller.mouseOverShowTimer = setTimeout(this.showScrollBar.bind(this, scroller), config.showAfterMs);
      }
    }
  },

  onTrackMouseLeave: function onTrackMouseLeave(scroller, event) {
    if (event.target === scroller.scrollBarTrack) {
      scroller.isMouseOver = false;

      if (!scroller.isDragging && !scroller.isClickScrolling) {
        clearTimeout(scroller.mouseOverShowTimer);

        if (scroller.isVisible) {
          this.startHideTimer(scroller);
        }
      }
    }
  },

  attach: function attach(scroller) {
    if (scroller.alwaysVisible) {
      this.refresh(scroller);

      return function () {};
    } else {
      this.hideScrollBar(scroller);

      var onScroll = this.onScroll.bind(this, scroller);
      var onTrackMouseEnter = this.onTrackMouseEnter.bind(this, scroller);
      var onTrackMouseLeave = this.onTrackMouseLeave.bind(this, scroller);

      var scrollObject = scroller.isBody ? window : scroller.view;
      scrollObject.addEventListener('scroll', onScroll, false);

      scroller.scrollBarTrack.addEventListener('mouseenter', onTrackMouseEnter, false);
      scroller.scrollBarTrack.addEventListener('mouseleave', onTrackMouseLeave, false);

      return function () {
        scrollObject.removeEventListener('scroll', onScroll, false);

        scroller.scrollBarTrack.removeEventListener('mouseenter', onTrackMouseEnter, false);
        scroller.scrollBarTrack.removeEventListener('mouseleave', onTrackMouseLeave, false);
      };
    }
  },

  update: function update(scroller) {
    if (scroller.alwaysVisible) {
      this.refresh(scroller);
    }
  },

  highlight: function highlight(scroller) {
    if (!scroller.alwaysVisible && !scroller.isVisible) {
      this.showScrollBar(scroller);
      this.startHideTimer(scroller);
    }
  }

};

},{"./config":295}],301:[function(require,module,exports){
/**
 * @module spotify-events/select
 */
'use strict';

var $ = require('../spotify-elements');
var center = require('./center');

var live = require('../spotify-live');

var ATTR_SELECT = 'select';
var ATTR_PROPERTY = 'select-property';
var SELECTOR_SELECT = '[data-' + ATTR_SELECT + ']';

// Stored nodes, used to not add listeners multiple times
var storedNodes = [];

/**
 * Handle a change on a select node.
 *
 * @param {MouseEvent} event Event object.
 * @param {Elements} elem An elements DOM node for the select.
 */
function handleChange(event, elem) {
  var property = elem.data(ATTR_PROPERTY);
  var node = elem[0];
  // If a property is set, update the model. That will later trigger
  // an update of the view and a change event on center will be sent.
  if (property) {
    publish(node, property);
    // If no property is set, just emit a change event on center.
  } else {
      emitUpdate(node, selectedValue(node));
    }
}

/**
 * Return the value attribute of the selected option
 *
 * @param {Elements} elem An elements DOM node for the select
 */
function selectedValue(node) {
  var selected = node.options[node.selectedIndex];
  return selected.value;
}

/**
 * Handle when a select-option event happens on center.
 *
 * @param {Object} event An object with data.
 */
function onSelectSet(event) {
  if (!event.id) return;

  var elem = $('[data-' + ATTR_SELECT + '=' + event.id + ']');
  if (!elem) return;

  var node = elem[0];
  var value = event.selected;

  // updating the node will trigger a DOM event,
  // delegated to handleChange in this module.
  var property = elem.data(ATTR_PROPERTY);

  if (property) {
    publish(node, property, value);
  } else {
    setState(node, value);
  }
}

/**
 * Publish new data to the live model. If no data-uri is found from
 * the passed node, nothing happens.
 *
 * @param {HtmlElement} node A DOM node for the select
 * @param {string} property A property name on the live model
 * @param {string=} opt_value Optional value to set the property to.
 *     If not provided, the selected option's value is fetched from the DOM.
 */
function publish(node, property, opt_value) {
  var uri = getUriFromNode(node);
  if (!uri) return;

  var model = live(uri);

  // If the model doesn't have a current value, we can't safely
  // set a new value without maybe being wrong.
  var value = model.get(property);
  if (value === undefined) return;

  var newValue = opt_value === undefined ? selectedValue(node) : opt_value;

  var data = {};
  data[property] = newValue;

  // Publishing the new value to the model will trigger the update
  // handler added here in this module to send an center event,
  // and update the DOM if needed.
  model.publish(data);
}

/**
 * Update the state of one select node.
 *
 * @param {HTMLElement} node A DOM node for the select.
 */
function updateNode(node) {
  if (storedNodes.indexOf(node) > -1) return;
  storedNodes.push(node);

  var elem = $(node);
  var property = elem.data(ATTR_PROPERTY);
  if (!property) return;

  var uri = getUriFromNode(node);
  if (!uri) return;

  var model = live(uri);

  model.get(property, function (error, value) {
    if (error) throw error;

    setState(node, value);

    model.on('update', function (properties) {
      if (property in properties) {
        setState(node, properties[property]);
      }
    });
  });
}

/**
 * Update a select node based on a value.
 *
 * @param {HTMLElement} node A DOM node for a select.
 * @param {string} value The value attribute of the option to select
 */
function setState(node, value) {
  updateNodeWithValue(node, value);
  emitUpdate(node, value);
}

/**
 * Update a select based on an option's value attribute
 *
 * @param {HTMLElement} node A DOM node for a select.
 * @param {string} value The value attribute of the option to select
 */
function updateNodeWithValue(node, value) {
  var selectElement = $(node);
  var optionElement = selectElement.find('option[value="' + value + '"]');
  if (optionElement && !optionElement.attribute('selected')) {
    optionElement.select();
  }
}

/**
 * Emit a change event on center. It will have the following format:
 * {
 *   element: HTMLElement,
 *   id: 'id from data-select attribute' || null,
 *   selected: the new selected value
 * }
 *
 * @param {HTMLElement} node A DOM node for a select.
 * @param {string} value Attribute of the selected option
 */
function emitUpdate(node, selected) {
  var id = $(node).data(ATTR_SELECT) || null;
  center.emit('select-change', {
    element: node,
    id: id,
    selected: selected
  });
}

/**
 * Get a URI from a node.
 *
 * @param {HTMLElement} node A DOM node.
 *
 * @return {string?} A URI string or null if not found.
 */
function getUriFromNode(node) {
  var stateNode = node.closest('[data-uri]');
  if (!stateNode) return null;
  return stateNode.getAttribute('data-uri');
}

var isAttached = false;

exports.update = function (opt_node) {
  if (!isAttached) return;

  var nodes = $(opt_node || document).search(SELECTOR_SELECT);
  if (!nodes) return;

  nodes.forEach(updateNode);
};

exports.attach = function () {
  if (isAttached) return;
  isAttached = true;

  var doc = $(document);
  doc.delegate('change', SELECTOR_SELECT, handleChange);

  center.on('select-set', onSelectSet);
};

exports.detach = function () {
  if (!isAttached) return;
  isAttached = false;

  var doc = $(document);
  doc.undelegate('change', SELECTOR_SELECT, handleChange);

  center.off('select-set', onSelectSet);
};

},{"../spotify-elements":259,"../spotify-live":439,"./center":268}],302:[function(require,module,exports){
/**
 * @module spotify-events/selection/containers
 * @private
 */
'use strict';

var $ = require('../../spotify-elements');
var live = require('../../spotify-live');

/**
 * Container DOM nodes.
 *
 * @type {Array.<HTMLElement>}
 */
var containers = [];

/**
 * Forget the known containers.
 */
function reset() {
  containers.length = 0;
}

/**
 * Update container storage based on the current DOM.
 */
function update() {
  var nodes = $(document).search(':not(.sticky-clone) > [data-list]');
  if (!nodes) return;

  // Don't drop any containers. If they are removed from the DOM we just keep
  // the reference along with the selection state at the same index. Clearing
  // has to be done manually instead.

  // Append new containers to the end of the list.
  nodes.forEach(function (container) {
    if (containers.indexOf(container) === -1) {
      containers.push(container);
    }
  });
}

/**
 * Get the number of rows in the container at the specified index.
 *
 * @param {number} index The container index.
 *
 * @return {number} The number of rows.
 */
function getContainerLength(index) {
  var container = $(containers[index]);
  if (!container) return 0;

  var uri = container.data('uri');
  if (!uri) return 0;

  var list = live(uri).get('rows');
  if (!list) return 0;

  return list.length;
}

/**
 * Get the index of a container based on URI.
 *
 * @param {string} uri The URI of the container.
 *
 * @return {number} The index of the container. Returns -1 if not found.
 */
function getContainerIndex(uri) {
  for (var i = 0, l = containers.length; i < l; i++) {
    var containerUri = getUri(i);
    if (containerUri === uri) return i;
  }

  return -1;
}

/**
 * Get the URI for a container.
 *
 * @param {number} index The container index.
 *
 * @return {string?} The URI or null if not found.
 */
function getUri(index) {
  var element = containers[index];
  var uri = element && element.getAttribute('data-uri');
  return uri || null;
}

/**
 * Get the URIs for all containers.
 *
 * @return {Array.<string?>} Array of URIs.
 */
function getUris() {
  var uris = [];
  for (var i = 0, l = containers.length; i < l; i++) {
    uris.push(getUri(i));
  }
  return uris;
}

/**
 * Get the live list for a container.
 *
 * @param {number} index The container index.
 *
 * @return {LiveList?} A live list or null if not found.
 */
function getLiveList(index) {
  var uri = getUri(index);
  var list = live(uri).get('rows');
  return list || null;
}

exports.elements = containers;
exports.reset = reset;
exports.update = update;
exports.getContainerLength = getContainerLength;
exports.getContainerIndex = getContainerIndex;
exports.getUri = getUri;
exports.getUris = getUris;
exports.getLiveList = getLiveList;

},{"../../spotify-elements":259,"../../spotify-live":439}],303:[function(require,module,exports){
(function (global){
/**
 * spotify-events/selection/controller
 * @private
 */
'use strict';

var $ = require('../../spotify-elements');
var intersection = require('mout/array/intersection');
var live = require('../../spotify-live');
var liburi = require('spotify-liburi');

var center = require('../center');
var selection = require('./index');
var model = require('./model');
var rows = require('./rows');
var containers = require('./containers');
var positions = require('./positions');
var Position = require('../util/Position');
var cosmos = require('../util/cosmos');

var focusEventValid = false;

// Listeners per URI (key is URI)
var listListeners = {};
var listListenerUris = [];

var SELECTABLE = '[data-list-item]';
var CLIPBOARD_ENDPOINT = 'sp://desktop/v1/clipboard';

/**
 * Check whether the event occured on the documentElement.
 *
 * @param {Event} event A event object.
 *
 * @return {boolean}
 */
function isOnDocument(event) {
  return event.target === document.documentElement;
}

/**
 * Get the row node from a mouse event.
 *
 * @param {MouseEvent} event A mouse event object.
 *
 * @return {HTMLElement} A DOM node.
 */
function getNodeFromEvent(event) {
  return event.target.closest(SELECTABLE);
}

/**
 * Check if a target is inside a filter component.
 *
 * @param {HTMLElement} target A DOM node.
 *
 * @return {boolean} Whether the target was inside a filter component.
 */
function isFilterTarget(target) {
  return target !== document && !!target.closest('[data-filter]');
}

/**
 * Handle a mousedown event.
 *
 * @param {MouseEvent|TouchEvent} event A mouse or touch event.
 * @param {boolean=} opt_isMouseUp Pass true if this is a simulated mousedown
 *     triggered by a mouseup event.
 */
function handleMouseDown(event, opt_isMouseUp) {
  if (isOnDocument(event)) return;

  focusEventValid = false;
  var node = getNodeFromEvent(event);
  if (node) {
    handleRowMouseDown(event, node, opt_isMouseUp);
  } else {
    handleOutsideMouseDown(event);
  }
}

/**
 * Handle when the mouse is pressed down on a list row.
 *
 * @param {MouseEvent|TouchEvent} event A mouse or touch event.
 * @param {HTMLElemtn} rowNode The DOM node for the clicked row.
 * @param {boolean=} opt_isMouseUp Pass true if this is a simulated mousedown
 *     triggered by a mouseup event.
 */
function handleRowMouseDown(event, rowNode, opt_isMouseUp) {
  var button = getButtonFromEvent(event);
  var isPrimaryButton = button === 1;

  // If we can't find a valid position for the DOM node, we can't handle
  // selection correctly.
  var position = positions.getFromNode(rowNode);
  if (!position) return;

  var isSelected = model.isSelected(position);
  var singleMultiSelect = isMac() ? event.metaKey : event.ctrlKey;
  var multiselect = event.shiftKey || singleMultiSelect;
  var singleClick = !event.shiftKey;

  if (!isMultiSelectEnabled()) {
    singleMultiSelect = multiselect = false;
    singleClick = true;
  }

  // Remove selection if a selected item is clicked with cmd/ctrl
  if (multiselect && singleClick && isSelected && isPrimaryButton) {

    // For multiselect, make sure we do the deselection only on mouseup
    if (!opt_isMouseUp) return;
    handleDeselectOnSingleMultiSelect(position);

    // Select multiple items if clicked with shift key
  } else if (!singleClick) {

      // Optimize by doing this only on mousedown
      if (opt_isMouseUp) return;
      handleShiftMultiSelect(position);

      // Select a single item
    } else {

        // Handle the case when the primary button is pressed down on a selected item.
        // The method will be called once again in that case, on mouse up. This is
        // to allow the drag and drop to abort the selection change.

        // So we do the actual selection on mouseup, where we know it's not a drag n drop thing.
        if (isPrimaryButton && isSelected && !opt_isMouseUp) {
          return;
        }
        // For multiselect, make sure we do the selection only on mouseup
        if (multiselect && !opt_isMouseUp) {
          return;
        }

        handleSingleSelect(position, event, opt_isMouseUp);
      }
  rows.update();
}

/**
 * Handle when the mouse is pressed down outside a list row.
 *
 * @param {MouseEvent} event A mouse event.
 */
function handleOutsideMouseDown(event) {
  var isSort = !!event.target.closest('[data-sort]');
  var isFilter = isFilterTarget(event.target);
  var hasSelection = model.hasSelection();

  // Deselect if clicked outside the list.
  // Clicking sort headers should just sort, not clear selection.
  if (!(isSort || isFilter) && hasSelection) {
    model.clear();
    rows.update();
  }
}

/**
 * Handle a focus event.
 *
 * @param {MouseEvent} event A mouse event.
 */
function handleFocus(event) {
  if (!focusEventValid) return;
  var node = getNodeFromEvent(event);
  if (node) {
    handleRowFocus(event, node);
  } else {
    handleOutsideFocus(event);
  }
  focusEventValid = false;
}

/**
 * Handle when a row receives focus.
 *
 * @param {MouseEvent} event A mouse event.
 * @param {HTMLElement} rowNode The DOM node for the focused row.
 */
function handleRowFocus(event, rowNode) {
  var position = positions.getFromNode(rowNode);

  // Invalid positions and already selected rows don't need to be handled
  if (!position || model.isSelected(position)) {
    return;
  }

  model.clear();
  model.add(position);
  model.setFocus(position);
  model.setOrigin(position);
  rows.update();
}

/**
 * Handle when an element outside the table receives focus.
 *
 * @param {MouseEvent} event A mouse event.
 */
function handleOutsideFocus(event) {
  if (isFilterTarget(event.target)) return;
  model.clear();
  rows.update();
}

/**
 * Handle when the mouse button is released.
 *
 * @param {MouseEvent|TouchEvent} event A mouse or touch event.
 */
function handleMouseUp(event) {
  if (isOnDocument(event)) return;

  handleMouseDown(event, true);
}

/**
 * Handle deselecting a currently selected row in a multi-select situation
 * (cmd/ctrl). This might mean that we need to adjust origin and focus as well.
 *
 * @param {Position} position Position clicked on.
 */
function handleDeselectOnSingleMultiSelect(position) {
  var origin = model.getOrigin();
  var focus = model.getFocus();
  var dir = positions.getDirection(origin, focus);

  // When removing the node that is both origin and focus, there will be no
  // direction in which the origin/focus could be moved. Like here:

  // Click A, CMD click C, CMD click B, CMD click B again.

  // Native desktop will now still have origin on B. MacOS Finder does move
  // origin but it's hard to know how it decides.

  // For a predictable behaviour, default to look downwards, and always reverse
  // the direction when no selected node is found.

  if (!dir) dir = 1;

  var isOrigin = position.isSame(origin);
  var isFocus = position.isSame(focus);
  var above, below;

  if (isOrigin || isFocus) {
    above = getClosestSelected(position, 'up');
    below = getClosestSelected(position, 'down');
  }

  // If direction is down (1), the next after origin is found below
  if (isOrigin) {
    model.setOrigin(dir === 1 ? below || above : above || below);
  }

  // If direction is down (1), the next after focus is found above
  if (position.isSame(focus)) {
    model.setFocus(dir === 1 ? above || below : below || above);
  }

  model.remove(position);
}

/**
 * Handle multi-selecting a range from the current focus to the new position.
 * This also handles deselecting as needed.
 *
 * @param {Position} position Position clicked on.
 */
function handleShiftMultiSelect(position) {
  var origin = model.getOrigin();
  var focus = model.getFocus();

  // Remove selection from origin to old focus.
  // If it's part of the new selection it will be re-added.
  if (origin && focus && !origin.isSame(focus)) {
    model.remove(origin, focus);
  }

  // If there is no origin, we will set the origin to the first selectable row
  if (!origin) {
    origin = new Position(0, 0);
    model.setOrigin(origin);
  }

  // Add selection from the current origin to the clicked position
  model.add(origin, position);
  model.setFocus(position);
}

/**
 * Handle a normal mousedown without any multi-select keys.
 *
 * @param {Position} position Position clicked on.
 * @param {MouseEvent|TouchEvent} event A mouse or touch event.
 * @param {boolean=} opt_isMouseUp Pass true if this is a simulated mousedown
 *     triggered by a mouseup event.
 */
function handleSingleSelect(position, event, opt_isMouseUp) {
  var origin = model.getOrigin();

  var button = getButtonFromEvent(event);
  var isPrimaryButton = button === 1;
  var isSecondaryButton = button === 2;

  var isSelected = model.isSelected(position);
  var singleMultiSelect = isMac() ? event.metaKey : event.ctrlKey;
  var multiselect = event.shiftKey || singleMultiSelect;

  if (!isMultiSelectEnabled()) {
    singleMultiSelect = multiselect = false;
  }

  // Left click without cmd/ctrl/shift clears selection.
  // Also right click on something that wasn't selected clears.
  var isRegularPrimary = !multiselect && isPrimaryButton;
  var isSelectedSecondary = !isSelected && isSecondaryButton;
  if (isRegularPrimary || isSelectedSecondary) {
    model.clear();
  }

  // Add item to selection
  model.add(position);
  model.setFocus(position, { isTouch: isTouchEvent(event) });

  // When adding to an existing selection, leave origin alone.
  var isNextToSelection;
  if (origin && !origin.isSame(position)) {
    var next = positions.getClosest(position, 'down');

    isNextToSelection = next && model.isSelected(next);
    if (!isNextToSelection) {
      var prev = positions.getClosest(position, 'up');
      isNextToSelection = prev && model.isSelected(prev);
    }
  }
  if (!isNextToSelection) {
    model.setOrigin(position);
  }
}

/**
 * Handler for when a key is pressed down in the list. Depending on the key,
 * this will either move the selection (up and down arrows), shrink/grow the
 * selection (shift up and down arrows) or clear the selection (escape key).
 *
 * @param {KeyboardEvent} event The event object.
 */
function handleKeyDown(event) {
  if (isFilterTarget(event.target)) return;

  focusEventValid = true;
  var isUp = event.keyCode === 38;
  var isDown = event.keyCode === 40;

  if (!isKeyboardNavEnabled()) return;

  if (!isUp && !isDown) return;

  var origin = model.getOrigin();
  var focus = model.getFocus();
  var next = focus;

  do {
    next = next && positions.getClosest(next, isDown ? 'down' : 'up');
  } while (next && model.isPositionHidden(next));

  // Only move the selection if the up or down key was pressed.
  // And only do it if the cmd/ctrl key is not also pressed.
  // The cmd/ctrl key will change the volume in the client.
  if ((isUp || isDown) && !event.metaKey && !event.ctrlKey && next) {

    // Multi-select must have a previous selection position
    if (event.shiftKey && isMultiSelectEnabled() && origin && focus) {
      var keyDirection = isDown ? 1 : -1;
      var direction = positions.getDirection(origin, focus);
      var isSingleRange = direction === 0;
      if (isSingleRange || keyDirection === direction) {
        model.add(next);
        scrollIntoView(next);
      } else {
        model.remove(focus);
      }

      // If multi-select can't be performed, just move the current selection
    } else {
        model.clear();
        model.add(next);
        model.setOrigin(next);
        scrollIntoView(next);
        event.preventDefault(); // Prevent normal scrolling
      }

    // Always set the new focus to the row above or below
    model.setFocus(next);
  }

  rows.update();
}

/**
 * Handle when a section of a list is scrolled into view.
 * This needs to update selection state of the row nodes.
 *
 * @param {Object} event Event object.
 */
function handleScrollShowAfter(event) {
  var node = event.pageNode && event.pageNode[0];
  rows.update(node);
}

/**
 * Handle setting which indices are hidden.
 *
 * @param {Object} data Object with properties `hiddenIndices` (array of
 *     indices) and `uri` (URI of the list).
 */
function handleSetHidden(data) {
  model.setHiddenIndices(data.indices, data.uri);
}

/**
 * Add a row to the selection based on a list URI.
 * TODO: Remove logic to handle global lists.
 *
 * @param {string} listUri The list URI.
 * @param {number} index The index within the list.
 * @param {boolean=} opt_doNotScrollIntoView Optionally skip scrolling added index into view
 */
function handleAddByUri(listUri, index, opt_doNotScrollIntoView) {
  var uriNodes = $('[data-uri=' + listUri + ']');
  var matches = intersection(containers.elements, uriNodes);

  if (!matches || matches.length < 1) {
    return;
  }

  var container = $(matches[0]);
  var containerIndex = container && containers.elements.indexOf(container[0]);
  var listIsPlayContext = container && container.matches('[data-context]');

  if (listIsPlayContext) {
    // Selection is not based on the global container that is defined via data-context,
    // so the indices need to be resolved to match the selection containers.
    var localPosition = positions.getPositionFromGlobalIndex(index);
    containerIndex = localPosition.containerIndex;
    index = localPosition.index;
  } else if (containerIndex === -1) {
    console && console.warn && console.warn('No container matching this uri was found or selection doesn\'t know ' + 'about the container. Possibly you need to run events.update.');
    return;
  }

  if (!isMultiSelectEnabled()) model.clear();

  var position = new Position(containerIndex, index);
  if (!model.getOrigin()) model.setOrigin(position);
  model.setFocus(position);
  model.add(position);

  rows.update();

  if (opt_doNotScrollIntoView !== true) {
    scrollIntoView(position);
  }
}

/**
 * Handle a select_all event from Cosmos.
 */
function handleSelectAll() {
  if (!isMultiSelectEnabled()) {
    return false;
  }

  model.clear();

  var first = new Position(0, 0);
  model.setOrigin(first);

  var last = positions.getLastPositionForSelectAll();
  model.setFocus(last);

  model.add(first, last);
  rows.update();
}

/**
 * Handle a copy event from Cosmos.
 */
function handleCopy() {
  cosmos.put({ url: CLIPBOARD_ENDPOINT, body: getSelectedUrls().join('\n') });
}

/**
 * Handle a cut event from Cosmos.
 */
function handleCut() {
  handleCopy();

  cosmos.post({ url: 'sp://messages/v1/container/control', body: { type: 'delete' } });
}

/**
 * Gets list of uris for selected rows
 *
 * @return {Array.<string>} Array of URIs.
 */
function handleGetUris() {
  var selections = model.selections;
  var uris = [];

  for (var container = 0; container < selections.length; container++) {
    var containerSelection = selections[container];
    if (!containerSelection) continue;

    var entity;

    var list = containers.getLiveList(container);
    if (!list) continue;

    // * Order the keys
    // Since the user can select tracks in any order,
    // the selection is an unordered set until we actually retrieve the
    // uris of the selection. In this case we want to get the uris
    // in the same order as they are shown in the list.
    var orderedSelectedKeys = list.keys.filter(function (key) {
      return !!containerSelection[key];
    });

    for (var i = 0, l = orderedSelectedKeys.length; i < l; i++) {
      var item = list.valueOf(orderedSelectedKeys[i]);
      if (!item) continue;

      entity = item.get('track');
      if (!entity) entity = item.get('playlist');
      if (!entity) entity = item.get('album');
      if (!entity) entity = item.get('artist');
      if (!entity) entity = item.get('user');
      if (!entity) entity = item;

      uris.push(entity.get('uri'));
    }
  }

  return uris;
}

/**
 * Returns the HTTPS urls of the selected rows
 *
 * @return {Array.<string>} Array of URLs.
 */
function getSelectedUrls() {
  var uris = handleGetUris();
  var urls = [];
  for (var i = 0; i < uris.length; i++) {
    var uriObj = liburi.from(uris[i]);
    if (uriObj) {
      urls.push(uriObj.toOpenURL());
    }
  }
  return urls;
}

/**
 * Get the mouse button number identifier from an event object.
 *
 * @param {MouseEvent|TouchEvent} event A mouse event.
 *
 * @return {number} A number representing the pressed button:
 *     0: No button pressed
 *     1: Primary button (usually left)
 *     2: Secondary button (usually right)
 *     3: Middle (usually the wheel)
 */
function getButtonFromEvent(event) {

  // Touches don't have buttons, so treat all touches as a primary button
  if (isTouchEvent(event)) {
    return 1;
  }

  switch (event.button) {
    case 0:
      return 1;
    case 2:
      return 2;
    case 1:
      return 3;
    default:
      return 0;
  }
}

/**
 * Check if the user agent is on a Mac.
 *
 * @return {boolean} True if Mac, false otherwise.
 */
function isMac() {
  if (!global.window) return false;
  if (!global.window.navigator) return false;
  var userAgent = global.window.navigator.userAgent || '';
  return userAgent.indexOf('Mac') > -1;
}

/**
 * Check if multi-select is enabled.
 * We currently disable it for the Web Player, since not much can be done with
 * a multi-selection there.
 *
 * @return {boolean} True if enabled, false otherwise.
 */
function isMultiSelectEnabled() {
  if ($('body').data('multi-select-disabled') !== null) return false;
  if (!global.window) return false;
  return !!global.window._getSpotifyModule;
}

/**
 * Check if keyboard selection is enabled.
 * If it's not enabled it is not possible to move the selection with arrow
 * keys or extend it with shift + arrow keys.
 *
 * @return {boolean} True if enabled, false otherwise.
 */
function isKeyboardNavEnabled() {
  return $('body').data('keyboard-select-disabled') === null;
}

/**
 * Check if the event is a touch event.
 *
 * @param {Event} event Event object.
 *
 * @return {boolean} True if it is a touch event object.
 */
function isTouchEvent(event) {
  return !!event.changedTouches;
}

/**
 * Get the closest selected position in the specified direction.
 *
 * @param {Position} position A position.
 * @param {string} direction The direction to search in: 'up' or 'down'.
 *
 * @return {Position?} A position or null if not found.
 */
function getClosestSelected(position, direction) {
  while (position) {
    position = positions.getClosest(position, direction);
    if (position && model.isSelected(position)) return position;
  }
  return null;
}

/**
 * Scroll the position into view.
 *
 * @param {Position} position A position.
 */
function scrollIntoView(position) {
  var container = containers.elements[position.containerIndex];
  var scrollContainer = container && container.querySelector('[data-scroll-container]');
  if (scrollContainer) {
    center.emit('scroll-to-index', scrollContainer, position.index);
  } else {
    var node = positions.getNodeFromPosition(position);
    if (!node) return;

    var offset = node.getBoundingClientRect().top;
    if (offset < 0 || offset >= window.innerHeight) {
      node.scrollIntoView(offset < 0);
    }
  }
}

/**
 * Update the list listeners for the current containers.
 */
function updateListListeners() {
  var uris = containers.getUris();

  for (var i = 0, l = uris.length; i < l; i++) {
    var uri = uris[i];
    if (uri && listListenerUris.indexOf(uri) === -1) {
      var list = live(uri).get('rows');
      if (list) {
        var listener = createListListener(uri);
        list.on('update', listener);
        listListeners[uri] = listener;
        listListenerUris.push(uri);
      }
    }
  }
}

/**
 * Create an event listener for list updates.
 * When an update happens, the selection model will be updated for the right
 * container.
 *
 * @param {string} uri A URI for a list.
 *
 * @return {function} A listener function.
 */
function createListListener(uri) {
  return function (operations) {
    var uris = containers.getUris();
    var containerIndex = uris.indexOf(uri);
    if (containerIndex > -1) {

      // If something was removed from the list, we must update the selection
      // state, as something that was selected might have been removed.
      // Insert and move operations don't affect the current selection state,
      // as everything is based on row IDs, which don't change.
      for (var i = 0, l = operations.length; i < l; i++) {
        var operation = operations[i];
        if (operation.type === 'remove') {
          model.updateContainer(containerIndex);
          break;
        }
      }

      // Update the rows visually based on the model state
      rows.update();
    }
  };
}

/**
 * Remove all list listeners.
 */
function resetListListeners() {
  for (var i = 0, l = listListenerUris.length; i < l; i++) {
    var uri = listListenerUris[i];
    var listener = listListeners[uri];
    var list = live(uri).get('rows');
    if (list && listener) {
      list.off('update', listener);
      delete listListeners[uri];
      listListenerUris.splice(i, 1);
      i--;l--;
    }
  }
}

function handleListSwap(event) {
  var rowsListBefore = live(event.before).get('rows');
  if (!rowsListBefore) return;

  var selectionBefore = selection.getIndicesPerList().filter(function (indicesPerList) {
    return indicesPerList.uri === event.before;
  })[0];

  var selectedKeysBefore = [];
  if (selectionBefore) {
    selectedKeysBefore = selectionBefore.indices.map(function (index) {
      return rowsListBefore.keys[index];
    });
  }

  center.on('scroll-reset', function onScrollReset() {
    center.off('scroll-reset', onScrollReset);

    live(event.after).get('rows', function (error, rowsListAfter) {
      selectedKeysBefore.forEach(function (selectedKeyBefore) {
        var indexAfter = rowsListAfter.keys.indexOf(selectedKeyBefore);
        if (indexAfter !== -1) {
          handleAddByUri(event.after, indexAfter, true);
        }
      });
    }, live.ASAP);
  });
}

exports.handleMouseDown = handleMouseDown;
exports.handleMouseUp = handleMouseUp;
exports.handleKeyDown = handleKeyDown;
exports.handleFocus = handleFocus;
exports.handleScrollShowAfter = handleScrollShowAfter;
exports.handleSetHidden = handleSetHidden;
exports.handleAddByUri = handleAddByUri;
exports.handleSelectAll = handleSelectAll;
exports.handleCopy = handleCopy;
exports.handleCut = handleCut;
exports.handleGetUris = handleGetUris;
exports.updateListListeners = updateListListeners;
exports.resetListListeners = resetListListeners;
exports.handleListSwap = handleListSwap;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../spotify-elements":259,"../../spotify-live":439,"../center":268,"../util/Position":317,"../util/cosmos":319,"./containers":302,"./index":304,"./model":305,"./positions":306,"./rows":307,"mout/array/intersection":634,"spotify-liburi":707}],304:[function(require,module,exports){
/**
 * spotify-events/selection
 */
'use strict';

var $ = require('../../spotify-elements');
var live = require('../../spotify-live');
var getOriginUri = require('../../spotify-live-wrapped-uri').getOriginUri;

var center = require('../center');
var controller = require('./controller');
var containers = require('./containers');
var model = require('./model');
var rows = require('./rows');
var positions = require('./positions');
var Position = require('../util/Position');
var appUtil = require('../util/app');

var cosmos = require('../util/cosmos');

var controlMessageSubscription;

/**
 * Attach event listeners etc.
 */
exports.attach = function () {
  var doc = $(document);
  doc.on('mousedown', controller.handleMouseDown);
  doc.on('touchstart', controller.handleMouseDown);
  doc.on('mouseup', controller.handleMouseUp);
  doc.on('touchend', controller.handleMouseUp);
  doc.on('keydown', controller.handleKeyDown);
  doc.on('focus', controller.handleFocus, true);

  center.on('scroll-show-after', controller.handleScrollShowAfter);
  center.on('selection-set-hidden', controller.handleSetHidden);
  center.on('list-swap', controller.handleListSwap);

  // Creating an "intentional bug".. By switching to use row IDs internally
  // for the selection model, we no longer need to manually update indices
  // as long as the new list has the same IDs (which we require anyway for
  // other reasons). We stopped using this event a long time ago anyway,
  // because it never really worked without odd behaviors. I've done a
  // code search (indexed Nov 23 2014), and there is not a single place
  // where this event is used, except in old versions of spotify-events,
  // which is not a problem. Technically, not responding to this event
  // is a breaking change, but for simplicity's sake let's stop handling it.
  // Fixing code that never gets used just for the sake of it makes no sense.
  // If someone really needs this in the future, we can fix it then.
  // So, this line should be commented for now.
  //
  // center.on('update-indices', controller.handleUpdateIndices);

  controlMessageSubscription = cosmos.subscribe({ url: 'sp://messages/v1/container/control' }, function (error, response) {
    if (error) throw error;
    var data = response.body;
    if (data && appUtil.isActiveAndFocused()) {
      if (data.type === 'select_all') {
        controller.handleSelectAll();
      } else if (data.type === 'copy') {
        controller.handleCopy();
      } else if (data.type === 'cut') {
        controller.handleCut();
      }
    }
  });
};

/**
 * Detach event listeners etc.
 */
exports.detach = function () {
  var doc = $(document);
  doc.off('mousedown', controller.handleMouseDown);
  doc.off('touchstart', controller.handleMouseDown);
  doc.off('mouseup', controller.handleMouseUp);
  doc.off('touchend', controller.handleMouseUp);
  doc.off('keydown', controller.handleKeyDown);
  doc.off('focus', controller.handleFocus, true);

  center.off('scroll-show-after', controller.handleScrollShowAfter);
  center.off('selection-set-hidden', controller.handleSetHidden);
  center.off('list-swap', controller.handleListSwap);

  // See comment in `attach` for the long story why this is commented.
  // center.off('update-indices', controller.handleUpdateIndices);

  if (controlMessageSubscription) {
    controlMessageSubscription.cancel();
    controlMessageSubscription = null;
  }
};

/**
 * Update the module based on the current DOM state.
 */
exports.update = function () {
  containers.update();
  controller.updateListListeners();
};

/**
 * Add a row to the selection based on a list URI.
 *
 * @param {string} listUri The list URI.
 * @param {number} index The index within the list.
 */
exports.add = function (listUri, index) {
  controller.handleAddByUri(listUri, index);
};

/**
 * Check if the selection has any holes (contains many ranges).
 *
 * @return {boolean} True if it has holes, false otherwise.
 */
exports.hasHoles = function () {
  return model.hasHoles();
};

/**
 * Check if the row node is selected.
 *
 * @param {HTMLElement|Elements} node A DOM node for a row.
 *
 * @return {boolean} True if it is selected, false otherwise.
 */
exports.isNodeSelected = function (node) {
  node = 'innerHTML' in node ? node : node[0];
  if (!node) return false;

  var position = positions.getFromNode(node);
  if (!position) return false;

  return model.isSelected(position);
};

/**
 * Reset the selection state and its knowledge of any containers.
 */
exports.reset = function () {
  controller.resetListListeners();
  model.reset();
  rows.update();
  containers.reset();
};

/**
 * Clear the current selection.
 */
exports.clear = function () {
  model.clear();
  rows.update();
};

/**
 * Set the origin to a new position.
 *
 * @param {number} containerIndex The index of the container.
 * @param {number} index The index within the container.
 */
exports.setOrigin = function (containerIndex, index) {
  model.setOrigin(new Position(containerIndex, index));
};

/**
 * Set the focus to a new position.
 *
 * @param {number} containerIndex The index of the container.
 * @param {number} index The index within the container.
 */
exports.setFocus = function (containerIndex, index) {
  model.setFocus(new Position(containerIndex, index));
};

/**
 * Get the current origin position.
 *
 * @return {Object?} An object with numeric properties `containerIndex`
 *     and `index`, or null if no origin is set.
 */
exports.getOrigin = function () {
  var origin = model.getOrigin();
  if (!origin) return null;
  return {
    containerIndex: origin.containerIndex,
    index: origin.index
  };
};

/**
 * Get the current focus position.
 *
 * @return {Object?} An object with numeric properties `containerIndex`
 *     and `index`, or null if no origin is set.
 */
exports.getFocus = function () {
  var focus = model.getFocus();
  if (!focus) return null;
  return {
    containerIndex: focus.containerIndex,
    index: focus.index
  };
};

/**
 * Get all selected indices organized by list.
 *
 * @return {Array.<Object>} Array of objects of this structure:
 *     {
 *       containerIndex: 0,
 *
 *       // This is the list in the UI (could be sorted or unsorted)
 *       uri: 'spotify:internal:sortlist:asc:track(name):list',
 *       keys: ['c', 'd', 'e', 'j', 'o', 't'],
 *       indices: [3, 4, 5, 10, 15, 20], // Ordered indices in the list
 *
 *       // If all items between two selected items are hidden, they will be
 *       // included here to allow nice ranges to be created from this. It will
 *       // also include hidden items right after the last selected item.
 *       keysWithHidden: ['c', 'd', 'e', 'j', 'k', 'l', 'm', 'n', 'o', 't'],
 *       indicesWithHidden: [3, 4, 5, 10, 11, 12, 13, 14, 15, 20],
 *
 *       // Optional object for the unsorted list if the list is a sorted list
 *       origin: {
 *         uri: 'spotify:list',
 *         keys: ['c', 'd', 'e', 'j', 'o', 't'],
 *         indices: [7, 19, 8, 14, 0, 9] // Unordered indices in the original list
 *       }
 *     }
 */
exports.getIndicesPerList = function () {
  var selections = model.selections;
  var indicesPerList = [];

  for (var i = 0; i < selections.length; i++) {
    var containerSelection = selections[i];
    if (containerSelection && Object.keys(containerSelection).length) {

      var uri = containers.getUri(i);
      if (!uri) continue;

      var list = containers.getLiveList(i);
      if (!list) continue;

      var indices = model.getIndicesForContainer(i);
      if (!indices) continue;

      var keys = indices.map(function (selectedIndex) {
        return list.keys[selectedIndex];
      });

      var indicesWithHidden = model.getIndicesWithHiddenForContainer(i);
      var keysWithHidden = indicesWithHidden.map(function (selectedIndex) {
        return list.keys[selectedIndex];
      });

      var context = {
        containerIndex: i,
        uri: uri,
        indices: indices,
        keys: keys,
        indicesWithHidden: indicesWithHidden,
        keysWithHidden: keysWithHidden
      };

      var originUri = getOriginUri(uri);
      if (originUri) {
        var wrappedList = live(uri).get('rows');
        var originList = live(originUri).get('rows');

        var originIndices;
        var originKeys;
        if (wrappedList && originList) {
          var key;
          var originListKeyIndexMap = {};
          originIndices = new Array(indices.length);
          originKeys = new Array(indices.length);

          for (var i = 0, keys = originList.keys; i < keys.length; i++) {
            originListKeyIndexMap[keys[i]] = i;
          };

          for (var j = 0; j < indices.length; j++) {
            key = wrappedList.keys[indices[j]];
            originIndices[j] = originListKeyIndexMap[key];
            originKeys[j] = originList.keys[originIndices[j]];
          }
        }
        context.origin = {
          uri: originUri,
          indices: originIndices || [],
          keys: originKeys || []
        };
      }

      indicesPerList.push(context);
    }
  }

  return indicesPerList;
};

/**
 * Get all selected indices relative to the full page (across all containers).
 *
 * @return {Object?} The value null if no global context is found or if found,
 *     an object of this structure:
 *     {
 *       uri: 'spotify:context:uri',
 *       indices: [0, 3, 56, 120],
 *
 *       // These elements are Elements instances from the 'elements' npm
 *       // package. This should be fixed in a future major version, to be
 *       // normal HTML elements.
 *       containers: [
 *         containerElement1,
 *         containerElement1,
 *         containerElement4,
 *         containerElement5
 *       ]
 *     }
 */
exports.getIndicesGlobal = function () {
  var selections = model.selections;
  var elements = containers.elements;
  var indices = [];
  var selectionContainers = [];

  if (elements.length === 0) {
    return null;
  }
  var contextUriContainer = elements[0].closest('[data-context]');
  var contextUri = contextUriContainer && contextUriContainer.getAttribute('data-uri');

  if (!contextUri) return null;

  for (var container = 0; container < selections.length; container++) {
    var containerSelection = selections[container];
    var list = containers.getLiveList(container);
    if (list && containerSelection) {

      var orderedSelectedKeys = list.keys.filter(function (key) {
        return !!containerSelection[key];
      });

      for (var i = 0, l = orderedSelectedKeys.length; i < l; i++) {
        var j = list.keys.indexOf(orderedSelectedKeys[i]);
        indices.push(positions.getGlobalIndexFromPosition(new Position(container, j)));
        selectionContainers.push($(elements[container]));
      }
    }
  }

  return {
    uri: contextUri,
    indices: indices,
    containers: selectionContainers
  };
};

/**
 * Get the URI of all selected rows.
 *
 * @return {Array.<string>} Array of URIs.
 */
exports.getUris = function () {
  return controller.handleGetUris();
};

/**
 * Get the nodes for all selected rows that can be found.
 *
 * @return {Array.<HTMLElement>} Array of DOM nodes.
 */
exports.getNodes = function () {
  return rows.getSelectedRows();
};

},{"../../spotify-elements":259,"../../spotify-live":439,"../../spotify-live-wrapped-uri":438,"../center":268,"../util/Position":317,"../util/app":318,"../util/cosmos":319,"./containers":302,"./controller":303,"./model":305,"./positions":306,"./rows":307}],305:[function(require,module,exports){
/**
 * @module spotify-events/selection/model
 * @private
 */
'use strict';

var live = require('../../spotify-live');
var Range = require('../../spotify-range2');
var containers = require('./containers');
var positions = require('./positions');
var Position = require('../util/Position');

/**
 * Selections for all known containers.
 * Each container's selection space is represented as an object where keys are
 * row IDs. This allows for quick lookups.
 *
 * @type {Array.<Object.<string, boolean>>}
 */
var selections = [];

/**
 * Hidden items for all known containers.
 * Each container is represented as an object where keys are row IDs. This
 * allows for quick lookups.
 *
 * @type {Object.<number, Object.<string, boolean>>}
 */
var hiddenKeysPerContainer = {};

var originContainerIndex = null;
var originKey = null;
var focusContainerIndex = null;
var focusKey = null;
var focusIsTouch = false;

/**
 * Get the current origin.
 *
 * @return {Position?} The origin position or null if not set.
 */
function getOrigin() {
  if (originContainerIndex === null) return null;
  if (originKey === null) return null;

  var list = containers.getLiveList(originContainerIndex);
  if (list) {
    var index = list.keys.indexOf(originKey);
    if (index === -1) return null;
    var position = new Position(originContainerIndex, index);
    return position;
  }
  return null;
}

/**
 * Get the current focus. This is the position for the keyboard focus.
 *
 * @return {Position?} The focus position or null if not set.
 */
function getFocus() {
  if (focusContainerIndex === null) return null;
  if (focusKey === null) return null;

  var list = containers.getLiveList(focusContainerIndex);
  if (list) {
    var index = list.keys.indexOf(focusKey);
    var position = new Position(focusContainerIndex, index);
    return position;
  }
  return null;
}

/**
 * Set the current origin.
 *
 * @param {Position?} position A position or null if removing the origin.
 */
function setOrigin(position) {
  if (position) {
    var list = containers.getLiveList(position.containerIndex);
    if (list) {
      originContainerIndex = position.containerIndex;
      originKey = list.keys[position.index] || null;
      return;
    }
  }

  originContainerIndex = null;
  originKey = null;
}

/**
 * Set the current focus.
 *
 * @param {Position?} position A position or null if removing the focus.
 */
function setFocus(position, options) {
  focusIsTouch = !!(options && options.isTouch);

  if (position) {
    var list = containers.getLiveList(position.containerIndex);
    if (list) {
      focusContainerIndex = position.containerIndex;
      focusKey = list.keys[position.index];
      return;
    }
  }

  focusContainerIndex = null;
  focusKey = null;
}

/**
 * Check if the current focus was triggered by a touch.
 * This is done since we might want to have different styles for selection focus
 * when triggered by a touch event.
 *
 * @return {boolean} True if triggered by touch.
 */
function wasFocusTriggeredByTouch() {
  return focusIsTouch;
}

/**
 * Handle setting which indices are hidden.
 *
 * @param {Array.<number>} hiddenIndices Array of indices that are hidden.
 * @param {string} containerUri The URI of the container.
 */
function setHiddenIndices(hiddenIndices, containerUri) {
  var list = live(containerUri).get('rows');
  if (list) {
    var keys = list.keys;
    var hiddenKeys = {};
    for (var i = 0, l = hiddenIndices.length; i < l; i++) {
      var key = keys[hiddenIndices[i]];
      if (key) hiddenKeys[key] = true;
    }

    var containerIndex = containers.getContainerIndex(containerUri);

    hiddenKeysPerContainer[containerIndex] = hiddenKeys;

    updateContainer(containerIndex);
  }
}

/**
 * Check if given position is hidden.
 *
 * @param {Position} from The position to check.
 * @return {boolean} True if position is hidden.
 */
function isPositionHidden(pos) {
  var idsPerContainer = getIds(pos, pos);
  var id = idsPerContainer[0][0];
  var hiddenKeys = hiddenKeysPerContainer[pos.containerIndex];
  return hiddenKeys && hiddenKeys[id];
}

/**
 * Add rows to the selection.
 *
 * @param {Position} from The start position to add.
 * @param {Position=} opt_to The end position to add. If not provided, it will
 *     only add a single row to the selection.
 */
function add(from, opt_to) {
  var to = opt_to || from;

  // Flip the positions if the direction is up.
  if (positions.getDirection(from, to) === -1) {
    var temp = from;
    from = to;
    to = temp;
  }

  var idsPerContainer = getIds(from, to);

  for (var i = 0, l = idsPerContainer.length; i < l; i++) {
    var containerIndex = from.containerIndex + i;
    var selected = selections[containerIndex] || (selections[containerIndex] = Object.create(null));
    var ids = idsPerContainer[i];
    var hiddenKeys = hiddenKeysPerContainer[containerIndex];

    // Set all new items as selected, unless they're hidden
    for (var j = 0, id; id = ids[j]; j++) {
      if (!hiddenKeys || !hiddenKeys[id]) {
        selected[id] = true;
      }
    }
  }
}

/**
 * Remove rows from the selection.
 *
 * @param {Position} from The start position to remove.
 * @param {Position=} opt_to The end position to remove. If not provided, it will
 *     only remove a single row from the selection.
 */
function remove(from, opt_to) {
  var to = opt_to || from;

  // Flip the positions if the direction is up.
  if (positions.getDirection(from, to) === -1) {
    var temp = from;
    from = to;
    to = temp;
  }

  var idsPerContainer = getIds(from, to);

  for (var i = 0, l = idsPerContainer.length; i < l; i++) {
    var containerIndex = from.containerIndex + i;
    var selected = selections[containerIndex] || (selections[containerIndex] = Object.create(null));
    var ids = idsPerContainer[i];

    // Loop the row ids that are to be removed and remove them from the selection.
    // That's usually faster than looping the selection since there's no UI for
    // removing a big chunk of selection in one go.
    for (var j = 0, id; id = ids[j]; j++) {
      delete selected[id];
    }
  }
}

/**
 * Clear the current selection.
 */
function clear() {
  selections.length = 0;
  setOrigin(null);
  setFocus(null);
}

/**
 * Reset the current selection state.
 */
function reset() {
  clear();
  hiddenKeysPerContainer = {};
}

/**
 * Update the model state based on the current state of the list.
 * If items were removed from the list, removed items that were selected
 * will be removed from selection state.
 */
function updateContainer(containerIndex) {
  var keys = selections[containerIndex];
  if (!keys) return;

  var list = containers.getLiveList(containerIndex);
  if (!list) return;

  for (var key in keys) {
    var hasKey = list.hasKey(key);
    var shouldDelete = !hasKey;
    if (!shouldDelete) {
      var hiddenKeys = hiddenKeysPerContainer[containerIndex];
      var shouldDelete = hiddenKeys ? hiddenKeys[key] : false;
    }
    if (shouldDelete) {
      delete keys[key];
    }
  }
}

/**
 * Get ranges for the provided global range.
 *
 * @param {Position} from The start position.
 * @param {Position} to The end position. This position must be below the
 *     `from` position.
 *
 * @return {Array.<Range>} Array of ranges. There will be one range per
 *     matching container.
 */
function getRanges(from, to) {
  var ranges = [];

  var fromContainer = from.containerIndex;
  var toContainer = to.containerIndex;

  for (var i = fromContainer; i <= toContainer; i++) {
    var fromIndex = i === fromContainer ? from.index : 0;
    var toIndex;
    if (i === toContainer) {
      toIndex = to.index;
    } else {
      var containerLength = containers.getContainerLength(i);
      if (containerLength > 0) {
        toIndex = containerLength - 1;
      }
    }

    if (toIndex === undefined) {
      ranges.push(new Range(0, 0));
    } else {
      ranges.push(new Range(fromIndex, toIndex + 1));
    }
  }

  return ranges;
}

/**
 * Get IDs for the provided global range.
 *
 * @param {Position} from The start position.
 * @param {Position} to The end position. This position must be below the
 *     `from` position.
 *
 * @return {Array.<Array.<string>>} Array of IDs per container.
 */
function getIds(from, to, opt_keys) {
  var idsPerContainer = [];

  var fromContainer = from.containerIndex;
  var toContainer = to.containerIndex;

  for (var i = fromContainer; i <= toContainer; i++) {
    var fromIndex = i === fromContainer ? from.index : 0;
    var toIndex;
    if (i === toContainer) {
      toIndex = to.index;
    } else {
      var containerLength = containers.getContainerLength(i);
      if (containerLength > 0) {
        toIndex = containerLength - 1;
      }
    }

    if (toIndex === undefined) {
      idsPerContainer.push([]);
    } else {
      var ids = [];
      idsPerContainer.push(ids);

      var containerUri = containers.getUri(i);
      var list = live(containerUri).get('rows');
      if (list) {
        var keys = list.keys;

        for (var n = fromIndex; n < toIndex + 1; n++) {
          ids.push(keys[n]);
        }
      }
    }
  }

  return idsPerContainer;
}

/**
 * Check if the position is selected.
 *
 * @param {Position} position A position.
 *
 * @return {boolean} True if it is selected, false otherwise.
 */
function isSelected(position) {

  // Get the ranges of the according container
  var keys = selections[position.containerIndex];
  if (!keys) return false;

  // Check if the row is within the selected ranges for the container
  var list = containers.getLiveList(position.containerIndex);
  if (list) {
    var key = list.keys[position.index];
    return !!keys[key];
  }

  return false;
}

/**
 * Check if the selection has any holes (contains many ranges).
 *
 * @return {boolean} True if it has holes, false otherwise.
 */
function hasHoles() {
  var rangeCount = 0;

  for (var containerIndex = 0; containerIndex < selections.length; containerIndex++) {
    var containerSelection = selections[containerIndex];
    var list = containers.getLiveList(containerIndex);

    var keys = Object.keys(containerSelection);

    // A selection in more than one container means the selection has holes
    if (keys.length > 0) {
      rangeCount++;

      // Also more than one range in only one container means it has holes.
      if (list) {
        var indices = [];
        for (var j = 0, len = keys.length; j < len; j++) {
          indices.push(list.indexOf(keys[j]));
        }
        indices.sort(function (a, b) {
          return a - b;
        });
        var previousIndex;
        for (var i = 0, l = indices.length; i < l; i++) {
          var index = indices[i];
          if (i > 0 && index > previousIndex + 1) {
            rangeCount++;
            break;
          }
          previousIndex = index;
        }
      }
    }
    if (rangeCount > 1) return true;
  }

  return false;
}

/**
 * Check if there is any selection in any container.
 *
 * @return {boolean} True if there is a selection.
 */
function hasSelection() {
  for (var i = 0, l = selections.length; i < l; i++) {
    if (selections[i] && Object.keys(selections[i]).length > 0) {
      return true;
    }
  }

  return false;
}

/**
 * Get the selected indices for a container.
 *
 * @param {number} containerIndex The container index.
 *
 * @return {Array.<number>?} An array of indices or null if nothing is selected.
 */
function getIndicesForContainer(containerIndex) {
  var unorderedKeys = selections[containerIndex];
  if (!unorderedKeys) return null;
  var indices = [];

  var list = containers.getLiveList(containerIndex);

  var orderedKeys = list.keys.filter(function (key) {
    return !!unorderedKeys[key];
  });

  if (list && orderedKeys.length) {
    if (orderedKeys.length > 1) {
      // indexOfMany() is much more perfomant for big selections
      indices = list.indexOfMany(orderedKeys);
    } else {
      // for a single selected item, indexOf() is a little bit more perfomant
      indices = [list.indexOf(orderedKeys[0])];
    }
  }

  return indices.length ? indices : null;
}

/**
 * Get the selected indices for a container, including hidden items that join
 * two ranges. For example, in a list [A, B, C, D, E, F, G, H], everything is
 * selected except C, D, F and G. There are hidden items, C, D, F and G. This
 * method would then return the indices of all items except H,
 * [0, 1, 2, 3, 4, 5, 6]. It does include hidden items right after the last
 * selected one.
 *
 * @param {number} containerIndex The container index.
 *
 * @return {Array.<number>?} An array of indices or null if nothing is selected.
 */
function getIndicesWithHiddenForContainer(containerIndex) {
  var indices = getIndicesForContainer(containerIndex);
  if (!indices) return null;

  var hiddenKeys = hiddenKeysPerContainer[containerIndex];
  if (!hiddenKeys) return indices;

  var ranges = Range.fromIndices(indices);
  if (ranges.length === 1) return indices;

  var list = containers.getLiveList(containerIndex);
  if (!list) return indices;

  var hiddenIds = Object.keys(hiddenKeys);
  var hiddenIndices = [];

  if (hiddenIds.length) {
    if (hiddenIds.length > 1) {
      // indexOfMany() is much more perfomant for big selections
      hiddenIndices = list.indexOfMany(hiddenIds);
    } else {
      // for a single selected item, indexOf() is a little bit more perfomant
      hiddenIndices = [list.indexOf(hiddenIds[0])];
    }
  }

  hiddenIndices = hiddenIndices.filter(function (index) {
    return index > -1;
  });

  var hiddenRanges = Range.fromIndices(hiddenIndices);
  var hiddenStarts = hiddenRanges.map(function (range) {
    return range.start;
  });
  var hiddenEnds = hiddenRanges.map(function (range) {
    return range.end;
  });

  for (var i = 0, l = ranges.length; i < l; i++) {
    var range = ranges[i];
    var nextRange = ranges[i + 1];

    var indexOfRange = hiddenStarts.indexOf(range.end);
    if (indexOfRange > -1) {
      var hiddenEnd = hiddenEnds[indexOfRange];
      if (!nextRange || hiddenEnd === nextRange.start) {
        var hiddenIndicesInRange = hiddenRanges[indexOfRange].toIndices();
        if (hiddenIndicesInRange.length > 0) {
          indices = indices.concat(hiddenIndicesInRange);
        }
      }
    }
  }

  indices.sort(function (a, b) {
    return a - b;
  });

  return indices.length ? indices : null;
}

exports.selections = selections;
exports.getOrigin = getOrigin;
exports.getFocus = getFocus;
exports.setOrigin = setOrigin;
exports.setFocus = setFocus;
exports.wasFocusTriggeredByTouch = wasFocusTriggeredByTouch;
exports.setHiddenIndices = setHiddenIndices;
exports.isPositionHidden = isPositionHidden;
exports.add = add;
exports.remove = remove;
exports.clear = clear;
exports.reset = reset;
exports.updateContainer = updateContainer;
exports.isSelected = isSelected;
exports.hasHoles = hasHoles;
exports.hasSelection = hasSelection;
exports.getIndicesForContainer = getIndicesForContainer;
exports.getIndicesWithHiddenForContainer = getIndicesWithHiddenForContainer;

},{"../../spotify-live":439,"../../spotify-range2":489,"../util/Position":317,"./containers":302,"./positions":306}],306:[function(require,module,exports){
/**
 * @module spotify-events/selection/positions
 * @private
 */
'use strict';

var $ = require('../../spotify-elements');

var containers = require('./containers');
var Position = require('../util/Position');

/**
 * Get the closest position in the specified direction.
 *
 * @param {Position} position A position.
 * @param {string} direction The direction to search in: 'up' or 'down'.
 *
 * @return {Position?} A position or null if not found.
 */
function getClosest(position, direction) {
  var isDown = direction === 'down';
  var containerIndex = position.containerIndex;
  var index = position.index;

  // Find next position within the current container
  var containerLength = containers.getContainerLength(containerIndex);
  var nextIndex = isDown ? index + 1 : index - 1;
  if (nextIndex < containerLength && nextIndex >= 0) {
    return new Position(containerIndex, nextIndex);
  }

  // Out of bounds, traverse containers
  containerIndex = isDown ? containerIndex + 1 : containerIndex - 1;
  containerLength = containers.getContainerLength(containerIndex);
  if (containerLength) {
    nextIndex = isDown ? 0 : containerLength - 1;
    return new Position(containerIndex, nextIndex);
  }

  return null;
}

/**
 * Get a position from a row node.
 *
 * @param {HTMLElement} node A DOM node for a list row.
 *
 * @return {Position?} A position or null if not found.
 */
function getFromNode(node) {

  // We need a parent node, since we will be checking if the row is inside
  // one of the known selection containers.
  if (!node.parentNode) return null;

  // We also need a data-index attribute on the row to get the index for the
  // row within the current selection container.
  if (!node.hasAttribute('data-index')) return null;

  var elements = containers.elements;
  if (elements.length === 0) return null;

  for (var i = 0, l = elements.length; i < l; i++) {
    if (elements[i] && containsNode(elements[i], node)) {
      var row = +node.getAttribute('data-index');
      return new Position(i, row);
    }
  }

  return null;
}

/**
 * Check if an element contains another node.
 *
 * @param {HTMLElement} element The container element.
 * @param {HTMLElement} child The potential child node.
 *
 * @return {boolean} True if element contains the child, false otherwise.
 */
function containsNode(element, child) {
  while (child && child.parentNode !== element) {
    child = child.parentNode;
  }
  return !!child;
}

/**
 * Get the row node that the specified position represents.
 *
 * @param {Position} position A position.
 *
 * @return {HTMLElement?} A DOM node or null if not found.
 */
function getNodeFromPosition(position) {
  var container = containers.elements[position.containerIndex];
  if (!container) return null;
  var node = $(container).find('[data-index=' + position.index + ']');
  return node ? node[0] : null;
}

/**
 * Get the direction from one position to another.
 *
 * @param {Position} from First position.
 * @param {Position} to Second position.
 *
 * @return {number} A number representing the direction.
 *     -1 is up
 *      0 is same
 *      1 is down
 */
function getDirection(from, to) {
  if (!from || !to) return 0;

  // With different containers we can just compare the containers
  if (from.containerIndex !== to.containerIndex) return from.containerIndex < to.containerIndex ? 1 : -1;

  // Within the same container, compare the row indices
  if (from.index === to.index) return 0;
  return from.index < to.index ? 1 : -1;
}

/**
 * Get data about in which container and where inside that the provided
 * global index is.
 *
 * @param {number} globalIndex An index relative to the full page (all
 *     selection containers).
 *
 * @return {Position} A position.
 */
function getPositionFromGlobalIndex(globalIndex) {
  var resolvedIndex = globalIndex;
  var resolvedContainerIndex = 0;
  var containerLength;
  var countIndices = 0;

  // Subtract the amount of tracks in containers until passing globalIndex
  for (var i = 0, l = containers.elements.length; i < l; i++) {

    containerLength = containers.getContainerLength(i);
    countIndices += containerLength;

    if (countIndices > globalIndex) break;

    resolvedContainerIndex = i + 1;
    resolvedIndex -= containerLength;
  }

  return new Position(resolvedContainerIndex, resolvedIndex);
}

/**
 * Get the global index relative to the full page (across all selection
 * containers) from a position object.
 *
 * @param {Position} position A position.
 *
 * @return {number} A global index.
 */
function getGlobalIndexFromPosition(position) {
  var resolvedIndex = position.index;

  // Subtract length of previous lists
  for (var i = position.containerIndex - 1; i >= 0; i--) {
    resolvedIndex += containers.getContainerLength(i);
  }

  return resolvedIndex;
}

/**
 * Get last position on page.
 *
 * @return {Position} A position.
 */
function getLastPosition() {
  var lastContainerIndex = containers.elements.length - 1;
  var lastIndex = containers.getContainerLength(lastContainerIndex) - 1;

  return new Position(lastContainerIndex, lastIndex);
}

/**
 * Get last position for "select all" on page, disregarding containers with
 * [data-select-all="false"].
 *
 * @return {Position} A position.
 */
function getLastPositionForSelectAll() {
  var lastContainerIndex = containers.elements.filter(function (element) {
    return element.getAttribute('data-list-may-select-all') !== 'false';
  }).length - 1;
  var lastIndex = containers.getContainerLength(lastContainerIndex) - 1;

  return new Position(lastContainerIndex, lastIndex);
}

exports.getClosest = getClosest;
exports.getFromNode = getFromNode;
exports.getNodeFromPosition = getNodeFromPosition;
exports.getDirection = getDirection;
exports.getPositionFromGlobalIndex = getPositionFromGlobalIndex;
exports.getGlobalIndexFromPosition = getGlobalIndexFromPosition;
exports.getLastPosition = getLastPosition;
exports.getLastPositionForSelectAll = getLastPositionForSelectAll;

},{"../../spotify-elements":259,"../util/Position":317,"./containers":302}],307:[function(require,module,exports){
/**
 * @module spotify-events/selection/rows
 * @private
 */
'use strict';

var $ = require('../../spotify-elements');
var difference = require('mout/array/difference');

var model = require('./model');
var containers = require('./containers');
var positions = require('./positions');

var SELECTOR_ROW = '[data-list-item]';
var CLASSNAME_SELECTED = 'selected';
var CLASSNAME_FOCUSED = 'selection-focus';
var CLASSNAME_FOCUSED_TOUCH = 'selection-focus-touch';
var focusTimeout;

/**
 * Update the selection state of rows.
 *
 * @param {HTMLElement=} opt_node Optional DOM node. If provided, the update
 *     will only affect rows found inside this node.
 */
function update(opt_node) {
  var currentlySelectedRows = getSelectedRows(opt_node);
  var rowsToBeSelected = getRowsToSelect(opt_node);

  var rowsToDeselect = difference(currentlySelectedRows, rowsToBeSelected);
  var rowsToSelect = difference(rowsToBeSelected, currentlySelectedRows);

  currentlySelectedRows.forEach(function (row) {
    $(row).removeClass(CLASSNAME_FOCUSED);
    $(row).removeClass(CLASSNAME_FOCUSED_TOUCH);
  });

  // Remove styles for selected rows that should now be deselected
  rowsToDeselect.forEach(function (row) {
    $(row).removeClass(CLASSNAME_SELECTED);
  });

  // Add styles for unselected rows that should now be selected
  rowsToSelect.forEach(function (row) {
    $(row).addClass(CLASSNAME_SELECTED);
  });

  // Add styles for the row with the selection focus
  var focus = model.getFocus();
  if (focus) {
    var focusNode = positions.getNodeFromPosition(focus);
    if (focusNode) {
      // If the focusNode is not yet in the viewport and we `focus()` it, the
      // browser will bluntly scroll it into view, which looks bad. (KM-6508)
      clearTimeout(focusTimeout);
      focusTimeout = setTimeout(function () {
        var isInputFocused = document.activeElement && $(document.activeElement).matches('input, textarea');
        var isButtonFocused = document.activeElement && $(document.activeElement).matches('button');
        if (isElementInViewport(focusNode) && !isInputFocused && !isButtonFocused) {
          focusNode.focus();
        }
      }, 0);
      $(focusNode).addClass(CLASSNAME_FOCUSED);

      if (model.wasFocusTriggeredByTouch()) {
        $(focusNode).addClass(CLASSNAME_FOCUSED_TOUCH);
      }
    }
  }
}

/**
 * Get the rows that are currently selected, found inside the known containers.
 *
 * @param {HTMLElement=} opt_node Optional DOM node. If provided, it will only
 *     search inside this node.
 *
 * @return {Array.<HTMLElement>} Array of DOM nodes.
 */
function getSelectedRows(opt_node) {
  var elements = opt_node ? [opt_node] : containers.elements;
  var rows = [];

  elements.forEach(function (container) {
    var nodes = $(container).search(SELECTOR_ROW + '.' + CLASSNAME_SELECTED);
    if (nodes) Array.prototype.push.apply(rows, nodes);
  });

  return rows;
}

/**
 * Get the rows that should be selected, found inside the known containers.
 *
 * @param {HTMLElement=} opt_node Optional DOM node. If provided, it will only
 *     search inside this node.
 *
 * @return {Array.<HTMLElement>} Array of DOM nodes.
 */
function getRowsToSelect(opt_node) {
  var rows = [];
  var containerElements = containers.elements;

  model.selections.forEach(function (keys, index) {
    if (!keys) return;

    var list = containers.getLiveList(index);
    if (!list) return;

    var container = containerElements[index];
    // If a node was passed, only check the container if it contains the node
    if (opt_node && !containerElements[index].contains(opt_node)) {
      container = null;
    }
    if (!container) return;

    var listNodes = $(container).search(SELECTOR_ROW);
    if (!listNodes) return;

    var nodes = listNodes.filter(function (listNode) {
      var nodeIndex = +listNode.getAttribute('data-index');
      var nodeRowId = list.keys[nodeIndex];
      return !!keys[nodeRowId];
    });

    Array.prototype.push.apply(rows, nodes);
  });
  return rows;
}

function isElementInViewport(el) {
  var rect = el.getBoundingClientRect();
  return rect.top >= 0 && rect.bottom <= document.documentElement.clientHeight;
}

exports.update = update;
exports.getSelectedRows = getSelectedRows;

},{"../../spotify-elements":259,"./containers":302,"./model":305,"./positions":306,"mout/array/difference":626}],308:[function(require,module,exports){
'use strict';

var SHUFFLE_CLASS = 'shuffle-mode';
var shuffleMode = require('../spotify-shuffle-mode');
var rootNode = document.documentElement;
var rootClassList = rootNode.classList;

function setClass() {
  if (shuffleMode.isEnabled()) {
    rootClassList.add(SHUFFLE_CLASS);
  } else {
    rootClassList.remove(SHUFFLE_CLASS);
  }
}

var isAttached = false;

exports.attach = function attach() {
  if (isAttached) return;
  isAttached = true;

  setClass();
};

exports.detach = function detach() {
  if (!isAttached) return;
  isAttached = false;

  rootClassList.remove(SHUFFLE_CLASS);
};

exports.update = function update(node) {
  if (!isAttached) return;

  if (node === rootNode) {
    setClass();
  }
};

},{"../spotify-shuffle-mode":491}],309:[function(require,module,exports){
/**
 * @module spotify-events/slider
 */
'use strict';

var $ = require('../spotify-elements');
var center = require('./center');

var live = require('../spotify-live');

var ATTR_SLIDER = 'slider';
var ATTR_PROPERTY = 'slider-property';
var SELECTOR_SLIDER = '[data-' + ATTR_SLIDER + ']';
var CLASSNAME_ENABLED = 'enabled';
var CLASSNAME_DISABLED = 'disabled';
var ATTR_ALLOWED = 'slider-allowed-property';

var SPACE_KEY_CODE = 32;

// Stored nodes, used to not add listeners multiple times
var storedNodes = [];

/**
 * Handle a click on a slider node.
 *
 * @param {MouseEvent} event Event object.
 * @param {Elements} elem An elements DOM node for the slider.
 */
function handleClick(event, elem) {
  var property = elem.data(ATTR_PROPERTY);

  if (elem.data(ATTR_ALLOWED) && !live(elem.data('uri')).get(elem.data(ATTR_ALLOWED))) {
    return;
  }

  // If a property is set, update the model. That will later trigger
  // an update of the view and a change event on center will be sent.
  if (property) {
    toggleAndPublish(elem[0], property);

    // If no property is set, just flip the visual style and emit
    // a change event on center.
  } else {
      setState(elem[0], !elem.hasClass(CLASSNAME_ENABLED));
    }
}

/**
 * Handle a keyboard event on a slider node.
 *
 * @param {KeyboardEvent} event Event object.
 * @param {Elements} elem An elements DOM node for the slider.
 */
function handleKeyUp(event, elem) {
  if (event.keyCode !== SPACE_KEY_CODE) {
    return;
  }

  handleClick(event, elem);
};

/**
 * Handle when a slider-set event happens on center.
 *
 * @param {Object} event An object with data.
 */
function onSliderSet(event) {
  if (!event.id) return;

  var elem = $('[data-' + ATTR_SLIDER + '=' + event.id + ']');
  if (!elem) return;

  var node = elem[0];
  var enabled = !!event.enabled;

  var property = elem.data(ATTR_PROPERTY);

  if (property) {
    toggleAndPublish(node, property, enabled);
  } else {
    setState(node, enabled);
  }
}

/**
 * Update the live model with new data. If no data-uri is found from
 * the passed node, nothing happens.
 *
 * @param {HTMLElement} node A DOM node for the slider.
 * @param {string} property A property name on the model.
 * @param {boolean=} opt_enabled Optional boolean flag. If true, this
 *     sets it to true, if false this sets it to false. If not provided,
 *     this sets it to the opposite of the current value in the model.
 */
function toggleAndPublish(node, property, opt_enabled) {
  var uri = getUriFromNode(node);
  if (!uri) return;

  var model = live(uri);

  // If the model doesn't have a current value, we can't safely
  // set a new value without maybe being wrong.
  var value = model.get(property);
  if (value === undefined) return;

  var newValue = opt_enabled === undefined ? !value : opt_enabled;

  var data = {};
  data[property] = newValue;

  // Publishing the new value to the model will trigger the update
  // handler added here in this module to update the visual state
  // of the button.
  model.publish(data);
}

/**
 * Update the state of one slider node.
 *
 * @param {HTMLElement} node A DOM node for the slider.
 */
function updateNode(node) {

  // Don't handle the same URI and node twice.
  if (storedNodes.indexOf(node) > -1) return;
  storedNodes.push(node);

  var elem = $(node);
  var property = elem.data(ATTR_PROPERTY);
  var allowedProperty = elem.data(ATTR_ALLOWED);

  if (!property) return;

  var uri = getUriFromNode(node);
  if (!uri) return;

  var model = live(uri);

  model.get(property, function (error, value) {
    if (error) throw error;

    setState(node, !!value);

    model.on('update', function (properties) {
      if (property in properties) {
        setState(node, !!properties[property]);
      }

      if (allowedProperty && allowedProperty in properties) {
        disableNode(node, !properties[allowedProperty]);
      }
    });
  });
}

/**
 * Update a slider node based on a value.
 *
 * @param {HTMLElement} node A DOM node for a slider.
 * @param {boolean} enabled True if should be enabled, false otherwise.
 */
function setState(node, enabled) {
  updateNodeWithValue(node, enabled);
  emitUpdate(node, enabled);
}

/**
 * Update a slider node based on a value.
 *
 * @param {HTMLElement} node A DOM node for a slider.
 * @param {boolean} enabled True if should be enabled, false otherwise.
 */
function updateNodeWithValue(node, enabled) {
  var elem = $(node);
  if (enabled) {
    elem.addClass(CLASSNAME_ENABLED);
  } else {
    elem.removeClass(CLASSNAME_ENABLED);
  }
}

/**
 * Update a slider node based on whether is disabled
 *
 * @param {HTMLElement} node A DOM node for a slider.
 * @param {boolean} disabled True if should be disabled, false otherwise.
 */
function disableNode(node, disabled) {
  var elem = $(node);
  if (disabled) {
    elem.addClass(CLASSNAME_DISABLED);
  } else {
    elem.removeClass(CLASSNAME_DISABLED);
  }
}

/**
 * Emit a change event on center. It will have the following format:
 * {
 *   element: HTMLElement,
 *   id: 'id from data-slider attribute' || null,
 *   enabled: true // the new value
 * }
 *
 * @param {HTMLElement} node A DOM node for a slider.
 * @param {boolean} enabled True if enabled, false otherwise.
 */
function emitUpdate(node, enabled) {
  var id = $(node).data(ATTR_SLIDER) || null;
  center.emit('slider-change', {
    element: node,
    id: id,
    enabled: enabled
  });
}

/**
 * Get a URI from a node.
 *
 * @param {HTMLElement} node A DOM node.
 *
 * @return {string?} A URI string or null if not found.
 */
function getUriFromNode(node) {
  var stateNode = node.closest('[data-uri]');
  if (!stateNode) return null;
  return stateNode.getAttribute('data-uri');
}

var isAttached = false;

/**
 * Update the module based on the current DOM state.
 *
 * @param {HTMLElement=} opt_node Optional DOM node to make changes inside.
 */
exports.update = function (opt_node) {
  if (!isAttached) return;

  var nodes = $(opt_node || document).search(SELECTOR_SLIDER);
  if (!nodes) return;

  nodes.forEach(updateNode);
};

/**
 * Attach event listeners etc.
 */
exports.attach = function () {
  if (isAttached) return;
  isAttached = true;

  var doc = $(document);
  doc.delegate('click', SELECTOR_SLIDER, handleClick);
  doc.delegate('keyup', SELECTOR_SLIDER, handleKeyUp);

  center.on('slider-set', onSliderSet);
};

/**
 * Detach event listeners etc.
 */
exports.detach = function () {
  if (!isAttached) return;
  isAttached = false;

  var doc = $(document);
  doc.undelegate('click', SELECTOR_SLIDER, handleClick);
  doc.undelegate('keyup', SELECTOR_SLIDER, handleKeyUp);

  center.off('slider-set', onSliderSet);
};

},{"../spotify-elements":259,"../spotify-live":439,"./center":268}],310:[function(require,module,exports){
'use strict';

var $ = require('../spotify-elements');
require('../spotify-elements/attributes');
require('../spotify-elements/traversal');

var live = require('../spotify-live');
var center = require('./center');
var sortUriUtils = require('../spotify-live-sort-uri');

var UIInteraction4 = require('../spotify-logger/messages/UIInteraction4');

var ASC = 'tl-sort-asc';
var DESC = 'tl-sort-desc';

var handleSort = function handleSort(event, node) {
  var listNode = node.parent('[data-list]');
  if (!listNode) return;

  var uri = listNode.data('uri');
  if (!uri) return;

  var model = live(uri);

  var queryCurrent = sortUriUtils.getQuery(uri);
  var directionCurrent = sortUriUtils.getDirection(uri);

  var query = node.data('sort');

  var reverse = directionCurrent === 'asc' ? 'desc' : 'asc';
  var direction = queryCurrent === query ? reverse : 'asc';
  var reset = queryCurrent === query && directionCurrent === 'desc';

  var origin = sortUriUtils.getOriginUri(uri) || uri;

  var nextUri;
  if (reset) {
    nextUri = origin;
    query = null;
    direction = null;
  } else {
    nextUri = sortUriUtils.create(origin, direction, query);
  }

  // The first time a live model for the sorted URI is created, the sortlist
  // model will set up the sorting queries based on the URI.
  var nextList = live(nextUri);

  // We then need to trigger the sort to happen by asking for rows
  // The app itself will most likely request rows anyway, but by doing it
  // early might make it slightly faster.
  nextList.get('rows', function () {});

  var player = live('spotify:player');

  player.get('variant', function (error, context) {
    if (error) throw error;

    if (context && context.get('uri') === uri) {
      player.emit('update-context', {
        context: nextUri
      });
    }
  });

  setClassNames(listNode, query, direction);

  center.emit('sort-header-click', {
    uri: origin,
    requested: {
      query: query || null,
      direction: direction || null
    },
    current: {
      query: queryCurrent || null,
      direction: directionCurrent || null
    }
  });

  center.emit('list-swap', { before: uri, after: nextUri });

  UIInteraction4.log({
    feature_id: live('spotify:application').get('appURI') || 'unknown',
    section_id: 'sort-header',
    target_uri: nextUri,
    interaction_type: 'hit',
    user_intent: 'sort',
    timestamp: Math.round(Date.now() / 1000)
  });
};

var setClassNames = function setClassNames(list, opt_query, opt_direction) {

  var uri = list.data('uri');
  var query = opt_query !== undefined ? opt_query : sortUriUtils.getQuery(uri);
  var direction = opt_direction !== undefined ? opt_direction : sortUriUtils.getDirection(uri);
  var headers = list.search('[data-sort]');
  if (!headers) return;

  for (var i = 0, header; header = $(headers[i]); i++) {
    header.removeClass(ASC + ' ' + DESC);
    if (header.data('sort') === query) {
      header.addClass(direction === 'asc' ? ASC : DESC);
    }
  }
};

var handlePreviousProxyClick = function handlePreviousProxyClick(event, node) {
  handleSort(null, node.previousSibling());
};

var isAttached = false;

exports.update = function (node) {
  if (!isAttached) return;

  node = $(node) || $(document);

  var lists = node.matches('[data-list]') ? [node] : node.search('[data-list]');
  if (!lists) return;

  for (var i = 0, list; list = $(lists[i]); i++) {
    var headers = list.search('[data-sort]');
    if (!headers) continue;
    setClassNames(list);
  }
};

exports.attach = function attach() {
  if (isAttached) return;
  isAttached = true;

  $(document).delegate('click', '[data-sort]', handleSort);
  $(document).delegate('click', '[data-sort-previous]', handlePreviousProxyClick);
};

exports.detach = function detach() {
  if (!isAttached) return;
  isAttached = false;

  $(document).undelegate('click', '[data-sort]', handleSort);
  $(document).undelegate('click', '[data-sort-previous]', handlePreviousProxyClick);
};

},{"../spotify-elements":259,"../spotify-elements/attributes":255,"../spotify-elements/traversal":261,"../spotify-live":439,"../spotify-live-sort-uri":437,"../spotify-logger/messages/UIInteraction4":452,"./center":268}],311:[function(require,module,exports){
'use strict';

var throttle = require('./util/throttle');
var center = require('./center');
var sort = require('./sort');

var DEFAULT_STICKY_CLASS_NAME = 'sticky-top';
var TTL_STICKIES = 4000;
var TTL_POSITIONS = 0;

var isAttached = false;
var nodesGBCR = null;
var rootGBCR = null;
var timestamp;

var updateStickies = function updateStickies(nodes) {
  var rects = getRects(TTL_STICKIES);
  var scrollTop = window.scrollY;
  var width = rects.root.width;
  var top = rects.root.top;
  var height = 0;

  resetOldStickies();

  (nodes instanceof Array ? nodes : rects.nodes).forEach(function (nodeInfo, i) {
    var node = nodeInfo.node;
    var rect = nodeInfo.rect;
    var stickyClone = node.stickyClone;
    var stickyClassName = nodeInfo.stickyClassName;

    // Check if the node should be sticked or not (if true, it should be).
    if (rect.top - top < scrollTop) {
      if (!(stickyClone || node).classList.contains(stickyClassName)) {
        // <THEAD>s can't be made sticky, so we clone it and add it to the DOM.
        if (node.nodeName.toLowerCase() === 'thead' && !node.stickyClone) {
          node = createClone(node);
        }

        node.classList.add(stickyClassName);

        // Update styles accordingly.
        node.setAttribute('data-sticky-active', '');
        node.style.right = width - rect.right + 'px';
        node.style.left = rect.left + 'px';
        node.style.position = 'fixed';
        node.style.top = height + 'px';
      } else {
        (stickyClone || node).style.top = height + 'px';
      }

      // Increment the top reference and the height. Do it even if the element is already sticked.
      height += rect.height;
      top += rect.height;
    } else {
      if ((stickyClone || node).classList.contains(stickyClassName)) {
        resetSticky(node);
      }
    }
  });
};

var updatePositions = function updatePositions() {
  var rects = getRects(TTL_POSITIONS);
  var width = rects.root.width;

  // Update left and right.
  rects.nodes.forEach(function (nodeInfo, i) {
    var node = nodeInfo.node;
    var rect = nodeInfo.rect;

    if (node.stickyClone) {
      node = node.stickyClone;
    }

    if (node.classList.contains(nodeInfo.stickyClassName)) {
      node.style.right = width - rect.right + 'px';
      node.style.left = rect.left + 'px';
    }
  });
};

var resetSticky = function resetSticky(node) {
  // <THEAD>s can't be made sticky, so verify if we are using a clone and remove it from the DOM.
  if (node.nodeName.toLowerCase() === 'thead' && node.stickyClone) {
    removeClone(node);
  }

  node.classList.remove(getStickyClassName(node));

  // Update styles accordingly.
  node.removeAttribute('data-sticky-active', '');
  node.style.right = '';
  node.style.left = '';
  node.style.position = '';
  node.style.top = '';
};

var resetOldStickies = function resetOldStickies() {
  var selector = '[data-sticky-active]:not([data-sticky])';
  var nodes = document.querySelectorAll(selector);
  for (var i = 0, l = nodes.length; i < l; i++) {
    if (!nodes[i].isStickyClone) {
      resetSticky(nodes[i]);
    }
  }
};

var getRects = function getRects(ttl) {
  var reference = timestamp + ttl;
  var nodes = document.querySelectorAll('[data-sticky]');

  // Refresh timestamp (always).
  timestamp = Date.now();

  // If the reference time is still valid, and nodes are the same, then return data.
  if (reference > timestamp && nodesGBCR && nodes.length === nodesGBCR.length) {
    var equal = true;

    for (var i = 0; i < nodes.length; i++) {
      equal = equal && nodes[i] === nodesGBCR[i].node;
    }

    if (equal) {
      return {
        nodes: nodesGBCR,
        root: rootGBCR
      };
    }
  }

  // Otherwise, compute and cache.
  rootGBCR = document.documentElement.getBoundingClientRect();
  nodesGBCR = Array.prototype.map.call(document.querySelectorAll('[data-sticky]'), function (node) {
    var parentRect = node.parentNode.getBoundingClientRect();
    var nodeRect = node.getBoundingClientRect();

    // Return a structure per node. Only some fields are stored in the rect object (the ones used).
    return {
      stickyClassName: getStickyClassName(node),
      node: node,
      rect: {
        top: parentRect.top,
        height: nodeRect.height,
        left: parentRect.left,
        right: parentRect.right
      }
    };
  });

  return {
    nodes: nodesGBCR,
    root: rootGBCR
  };
};

var createClone = function createClone(node) {
  var div = document.createElement('div');
  var thead = node.cloneNode(true);
  var table = node.parentNode.cloneNode(false);
  var onListSwap;

  table.appendChild(thead).removeAttribute('data-sticky');
  div.appendChild(table);
  div.className = 'sticky-clone';
  div.isStickyClone = true;

  onListSwap = function onListSwap(data) {
    var table = thead.parentNode;
    var uri = table && table.getAttribute('data-uri');

    // Update the "data-uri" of the cloned table, and the sort state of the original one.
    if (uri) {
      table.setAttribute('data-uri', data.after);
      sort.update(node.parentNode);
    };
  };

  center.on('list-swap', onListSwap);

  node.parentNode.parentNode.appendChild(div);
  node.style.visibility = 'hidden';
  node.stickyListSwapListener = onListSwap;
  node.stickyClone = div;

  return div;
};

var removeClone = function removeClone(node) {
  var stickyClone = node.stickyClone;

  if (stickyClone.parentNode) {
    stickyClone.parentNode.removeChild(stickyClone);
  }

  if (node.stickyListSwapListener) {
    center.off('list-swap', node.stickyListSwapListener);
  }

  node.style.removeProperty('visibility');

  delete node.stickyClone;
  delete node.stickyListSwapListener;
};

var getStickyClassName = function getStickyClassName(stickyNode) {
  var root = document.documentElement;
  var classSticky;
  var node;

  for (node = stickyNode; node !== root; node = node.parentNode) {
    if (classSticky = node.getAttribute('data-class-sticky')) {
      return classSticky;
    }
  }

  return DEFAULT_STICKY_CLASS_NAME;
};

exports.DEFAULT_STICKY_CLASS_NAME = DEFAULT_STICKY_CLASS_NAME;

exports.attach = function attach() {
  if (!isAttached) {
    isAttached = true;

    window.addEventListener('scroll', updateStickies);
    window.addEventListener('resize', updatePositions);
  }
};

exports.detach = function detach() {
  if (isAttached) {
    isAttached = false;

    window.removeEventListener('scroll', updateStickies);
    window.removeEventListener('resize', updatePositions);

    nodesGBCR = null;
    rootGBCR = null;
  }
};

exports.update = function (optNode) {
  if (isAttached) {
    nodesGBCR = null;
    rootGBCR = null;

    updateStickies();
  }
};

exports._getStickyClassName = getStickyClassName;

},{"./center":268,"./sort":310,"./util/throttle":322}],312:[function(require,module,exports){
module.exports={
  "drag_tooltip_many_items": "items",
  "drag_tooltip_many_tracks": "tracks",
  "drag_tooltip_many_artists": "artists",
  "drag_tooltip_many_albums": "albums",
  "drag_tooltip_many_playlists": "playlists",
  "drag_tooltip_many_users": "users"
}
},{}],313:[function(require,module,exports){
'use strict';

var $ = require('../spotify-elements');
var live = require('../spotify-live');
var dom = require('./util/dom');

var SELECTOR_THUMBS_DOWN_BUTTON = '[data-button=thumbs-down]';
var SELECTOR_THUMBS_UP_BUTTON = '[data-button=thumbs-up]';

/**
 * Handle the click on a Thumbs button.
 *
 * @param {MouseEvent} event An event object for a click event.
 * @param {HTMLElement} button A button DOM node.
 *
 * @private
 */
function handleThumbsButtonClick(event, button) {
  var type = dom.getAttributeFromNodeOrParent(button[0], 'data-button');
  var trackUri = dom.getAttributeFromNodeOrParent(button[0], 'data-uri');
  var contextUri = dom.getContextFromNodeOrParent(button[0]);

  // Must use track uri
  if (!trackUri || !contextUri) return;

  // Emit thumb event on context
  if (type === 'thumbs-down') {
    live(contextUri).emit('thumb-down', trackUri);
  } else if (type === 'thumbs-up') {
    live(contextUri).emit('thumb-up', trackUri);
  }
};

var isAttached = false;

/**
 * Attach the event listeners for the module.
 * Part of the spotify-events interface.
 */
exports.attach = function () {
  if (isAttached) return;
  isAttached = true;

  var doc = $(document);
  doc.delegate('click', SELECTOR_THUMBS_DOWN_BUTTON, handleThumbsButtonClick);
  doc.delegate('click', SELECTOR_THUMBS_UP_BUTTON, handleThumbsButtonClick);
};

/**
 * Detach the event listeners for the module.
 * Part of the spotify-events interface.
 */
exports.detach = function () {
  if (!isAttached) return;
  isAttached = false;

  var doc = $(document);
  doc.undelegate('click', SELECTOR_THUMBS_DOWN_BUTTON, handleThumbsButtonClick);
  doc.undelegate('click', SELECTOR_THUMBS_UP_BUTTON, handleThumbsButtonClick);
};

exports.update = function (optNode) {};

},{"../spotify-elements":259,"../spotify-live":439,"./util/dom":320}],314:[function(require,module,exports){
'use strict';

var $ = require('../spotify-elements');
var zen = require('../spotify-elements/zen');

var tooltipMargin = 8; // We want some spacing around the tooltip

var tooltip = zen('div#tooltip');
var tooltipNode = tooltip[0];
var tooltipTextNode = zen('span')[0];
var tooltipArrowTop = zen('div.tooltip-arrow-top');
var tooltipArrowBottom = zen('div.tooltip-arrow-bottom');
tooltip.appendChild(tooltipArrowTop);
tooltip.appendChild(tooltipArrowBottom);
tooltip.appendChild(tooltipTextNode);

var attachedNode = null;
var tooltipNodeAttached = false;

// tooltipArrow will point to the current visible tooltipArrow
// that can be either tooltipArrowTop or tooltipArrowBottom
var tooltipArrow = null;

var addTooltipToDOM = function addTooltipToDOM() {
  document.body.appendChild(tooltipNode);
  tooltipNodeAttached = true;
};

var removeTooltipFromDOM = function removeTooltipFromDOM() {
  attachedNode = null;
  if (tooltipNode.parentNode) document.body.removeChild(tooltipNode);

  tooltipNodeAttached = false;
};

var showTooltip = function showTooltip(event, node) {
  var realNode = node[0];
  var top = 0;
  var left = 0;

  var tooltipText = node.data('tooltip') || node.getAttribute('title');
  if (!tooltipText) return;

  // Remember the node we set the text from so that text can be updated.
  attachedNode = node;

  if (!node.tooltipCheck) {
    node.removeAttribute('title');
    node.setAttribute('data-tooltip', tooltipText);
    node.tooltipCheck = true;
  }

  if (!tooltipNodeAttached) addTooltipToDOM();

  setText(tooltipText);

  var tooltipHeight = tooltipNode.clientHeight;
  var tooltipWidth = tooltipNode.offsetWidth;

  // Don't use window.scrollY because cross browser issues.
  // https://developer.mozilla.org/en-US/docs/Web/API/Window.scrollY
  var scrollY = window.pageYOffset;

  var bounds = realNode.getBoundingClientRect();
  var targetHeight = realNode.offsetHeight;
  var targetWidth = realNode.offsetWidth;
  var targetTop = parseInt(bounds.top) + scrollY;
  var targetLeft = parseInt(bounds.left);
  var targetCenter = targetLeft + targetWidth / 2;
  var targetBottom = targetTop + targetHeight;
  var viewportWidth = document.documentElement.clientWidth;
  var viewportHeight = document.documentElement.clientHeight;

  // Decide if the tooltip should be over or under the node
  if (targetBottom + tooltipHeight + tooltipMargin - scrollY > viewportHeight) {
    // On top
    top = targetTop - tooltipHeight - tooltipMargin;
    tooltipArrowTop.removeClass('visible');
    tooltipArrowBottom.addClass('visible');
    tooltipArrow = tooltipArrowBottom;
  } else {
    top = targetTop + targetHeight + tooltipMargin;
    if (top - scrollY > viewportHeight) {
      top = viewportHeight - tooltipHeight;
    }
    tooltipArrowTop.addClass('visible');
    tooltipArrowBottom.removeClass('visible');
    tooltipArrow = tooltipArrowTop;
  }

  var distanceToTheRight = viewportWidth - tooltipMargin - targetCenter;
  var distanceToTheLeft = targetCenter - tooltipMargin;
  var tooltipOffsetRight = Math.max(0, tooltipWidth / 2 - distanceToTheRight);
  var tooltipOffsetLeft = Math.max(0, tooltipWidth / 2 - distanceToTheLeft);

  left = targetCenter - tooltipWidth / 2 - (tooltipOffsetRight || -tooltipOffsetLeft);

  tooltipNode.style.top = top + 'px';
  tooltipNode.style.left = left + 'px';
  tooltipArrow[0].style.left = targetCenter - left + 'px';

  if (node.hasAttribute('data-tooltip-instant')) {
    tooltip.addClass('instant');
  } else {
    tooltip.removeClass('instant');
  }

  tooltip.addClass('visible');
};

var hideTooltip = function hideTooltip() {
  attachedNode = null;
  setText('');
  tooltip.removeClass('visible');
  tooltipNode.style.left = 0;
  tooltipNode.style.top = 0;
  if (tooltipArrow) {
    tooltipArrow[0].style.left = 0;
  }
};

var setText = function setText(text) {
  tooltipTextNode.innerHTML = text;
};

var isAttached = false;

exports.attach = function attach() {
  if (isAttached) return;
  isAttached = true;

  var doc = $(document);
  doc.delegate('mouseover', '[data-tooltip]', showTooltip);
  doc.delegate('mouseout', '[data-tooltip]', hideTooltip);
  doc.on('keydown', hideTooltip);
  doc.on('mousedown', hideTooltip);
};

exports.detach = function detach() {
  if (!isAttached) return;
  isAttached = false;

  removeTooltipFromDOM();
  var doc = $(document);
  doc.undelegate('mouseover', '[data-tooltip]', showTooltip);
  doc.undelegate('mouseout', '[data-tooltip]', hideTooltip);
  doc.off('keydown', hideTooltip);
  doc.off('mousedown', hideTooltip);
};

/** Forces an update of the tooltip text. */
exports.update = function update() {
  if (!isAttached) return;

  if (!attachedNode) return;

  if (attachedNode.data('tooltip')) {
    showTooltip(null, attachedNode);
  } else {
    // The tooltip no longer has text and should be hidden.
    hideTooltip();
  }
};

// Export for testing purposes
exports._setText = setText;

},{"../spotify-elements":259,"../spotify-elements/zen":262}],315:[function(require,module,exports){
'use strict';

var $ = require('../spotify-elements');

var doc = $(document);
var hoverActive = true;

/* Store events in an array */
var touchArray = [];
var addEvent = function addEvent(touchEvent) {
  touchArray.push(touchEvent);
};

function getMediaObjects() {
  return doc.search('.media-object');
}

function isMediaObject(element) {
  return !!element.closest('.media-object');
}

function handleEvent(e) {
  var target = e.target;
  if (isMediaObject(target)) {
    switch (e.type) {
      case 'touchstart':
        addEvent(e);
        if (hoverActive) {
          disableHover(e);
        }
        break;

      case 'touchmove':
        addEvent(e);
        break;

      case 'touchend':

        if (target && touchArray.length === 1 && touchArray[0].type === 'touchstart') {
          e.preventDefault();
          target.click();
        }
        touchArray = [];
        break;

      case 'contextmenu':
        addEvent(e);
        break;

      case 'mousemove':
        if (!hoverActive) {
          enableHover(e);
        }
        break;
    }
  }
}

function disableHover(e) {
  var mediaObjects = getMediaObjects();
  if (mediaObjects) {
    mediaObjects.forEach(function (object) {
      // Find available hover elements
      var overlay = $(object).find('.mo-overlay');
      // Hide hover elements
      if (overlay) {
        var add = $(object).find('.mo-add');
        var play = $(object).find('.mo-play');
        var more = $(object).find('.mo-more');
        var del = $(object).find('.mo-delete');

        hide(overlay);
        if (add) {
          hide(add);
        }
        if (play) {
          hide(play);
        }
        if (more) {
          hide(more);
        }
        if (del) {
          hide(del);
        }
      }
    });
    hoverActive = false;
  }

  function hide(element) {
    element.addClass('not-visible');
  }
}

function enableHover(e) {
  var mediaObjects = getMediaObjects();
  if (mediaObjects) {
    // Show hover elements
    mediaObjects.forEach(function (object) {
      var elements = $(object).search('.not-visible');
      if (elements) {
        show(elements);
        hoverActive = true;
      }
    });
  }

  function show(element) {
    element.removeClass('not-visible');
  }
}

var isAttached = false;

exports.attach = function () {
  if (isAttached) return;
  isAttached = true;

  doc.on('touchstart', handleEvent);
  doc.on('touchmove', handleEvent);
  doc.on('touchend', handleEvent);
  doc.on('mousemove', handleEvent);
  doc.on('contextmenu', handleEvent);
};

exports.detach = function () {
  if (!isAttached) return;
  isAttached = false;

  doc.off('touchstart', handleEvent);
  doc.off('touchmove', handleEvent);
  doc.off('touchend', handleEvent);
  doc.off('mousemove', handleEvent);
  doc.off('contextmenu', handleEvent);
};

exports.update = function () {};

exports._reset = function () {
  hoverActive = true;
  touchArray = [];
};

},{"../spotify-elements":259}],316:[function(require,module,exports){
'use strict';

var prime = require('prime');
var Emitter = require('prime/emitter');
var Range = require('../../spotify-range2');

var SYNC = Emitter.EMIT_SYNC;

module.exports = prime({
  mixin: Emitter,

  constructor: function constructor(container, params) {
    this.container = container;

    this.height = params.height || 0;
    this.length = params.length || 0;

    this.tag = params.tag || 'li';
    this.request = params.request;

    // Unique call identificator.
    this._id = 0;

    this.reset();
  },

  resetFrom: function resetFrom(fromIndex, length, hiddenIndices) {
    var range = this._range;

    // Redirect the call to reset.
    if (fromIndex < range.end) {
      this.reset(length, hiddenIndices);
      this.show(range);
    }
  },

  reset: function reset(length, hiddenIndices) {
    var tag = this.tag;
    var totalHeight;

    if (typeof length !== 'undefined') {
      this.length = length;
    }

    totalHeight = this.length * this.height;

    // Hidden indices are not supported anymore (legacy).
    if (hiddenIndices) {
      throw new TypeError('Hidden indices are not supported anymore!');
    }

    this.container.innerHTML = '<' + tag + ' style="height:' + totalHeight + 'px"></' + tag + '>' + '<' + tag + ' style="height:0px"></' + tag + '>';

    this._range = new Range(0, 0);
    this._waitingRange = new Range(0, 0);

    // An array of ranges representing the visible nodes.
    this.emit('index-change', [], SYNC);
  },

  show: function show(range) {
    var length = this.length;
    var actual = this._range;
    var waiting = this._waitingRange;

    // Limit range to the [0, length) interval.
    var bound = new Range(Math.max(0, range.start), Math.min(length, range.end));

    // If the range requested is the same, do nothing.
    if (bound.start === actual.start && bound.end === actual.end) {
      return;
    }

    // If the range requested is the same, do nothing.
    if (bound.start === waiting.start && bound.end === waiting.end) {
      return;
    }

    this._drawRange(bound);
  },

  _drawRange: function _drawRange(range) {
    var container = this.container;
    var oldRange = this._range;
    var height = this.height;
    var length = this.length;
    var tag = this.tag;
    var id = ++this._id;
    var self = this;

    this._waitingRange = range;

    // Request the whole range. We will manually intersect later with the current one.
    this.request(range, function (err, nodes) {
      var oldLength = oldRange.length;
      var newLength = range.length;
      var diff = 0;
      var first;
      var last;
      var i;

      // If a new range has been requested in the meantime, don't draw/modify anything.
      if (id !== self._id) {
        return;
      }

      // Cache the range requested.
      self._range = range;
      self._waitingRange = new Range(0, 0);

      // Get first and last nodes as references. We will use them for removing/adding nodes.
      first = container.firstChild;
      last = container.lastChild;

      // Change heights of the paddings.
      first.style.height = range.start * height + 'px';
      last.style.height = (length - range.end) * height + 'px';

      // Remove old nodes. Since nodes change their position when removing them one by one,
      // we have to keep the cumulative sum of nodes removed cached.
      oldRange.subtract(range).forEach(function (subrange) {
        var length = subrange.length;

        for (i = 0; i < length; i++) {
          // We add one to the children index because the first child is not a row but the top padding.
          container.removeChild(container.children[subrange.start - oldRange.start - diff + 1]);
        }

        diff += length;
      });

      // Add new nodes. If the new nodes are below the old range, insert them at the top;
      // otherwise, insert them at the bottom.
      range.subtract(oldRange).forEach(function (subrange) {
        var length = subrange.length;
        var start = subrange.start - range.start;
        var subnodes = nodes.slice(start, start + length);
        var ref;

        // Emit a change before.
        self.emit('before-show', subrange, subnodes, SYNC);

        // Get the reference node. If the range is below, then insert at the top.
        // Otherwise, insert at the bottom.
        if (subrange.below(oldRange)) {
          ref = first.nextSibling;
        } else {
          ref = last;
        }

        for (i = 0; i < length; i++) {
          container.insertBefore(subnodes[i], ref);
        }

        // Emit a change after.
        self.emit('after-show', subrange, subnodes, SYNC);
      });

      self.emit('index-change', [range], SYNC);
    });
  }
});

},{"../../spotify-range2":489,"prime":678,"prime/emitter":677}],317:[function(require,module,exports){
'use strict';

var Position = function Position(containerIndex, index) {
  this.containerIndex = containerIndex;
  this.index = index;
};

Position.prototype.isSame = function (position) {
  return this.containerIndex === position.containerIndex && this.index === position.index;
};

module.exports = Position;

},{}],318:[function(require,module,exports){
'use strict';

var live = require('../../spotify-live');

function checkIfActive() {
  return live('spotify:application').get('active') || false;
}

function checkIfFocused() {

  // If the active element of the top frame has a contentWindow that matches
  // this window, it means the iframe of this app is in focus.
  var topActiveElement = window.top.document.activeElement;
  var activeWindow = topActiveElement && topActiveElement.contentWindow;
  if (activeWindow) {
    return activeWindow === window;
  }

  // Top frame (zlink)
  if (window.top === window) {
    return true;
  }

  return false;
};

exports.isActive = function () {
  return checkIfActive();
};

exports.isActiveAndFocused = function () {
  return checkIfActive() && checkIfFocused();
};

},{"../../spotify-live":439}],319:[function(require,module,exports){
/**
 * @module spotify-events/util/cosmos
 * @private
 */

'use strict';

var live = require('../../spotify-live');
var cosmos = require('spotify-cosmos-api');
var liburi = require('spotify-liburi');

var ASAP = live.ASAP;

function DELETE(options, opt_callback) {
  options.method = exports.cosmos.Action.DELETE;
  return request(options, opt_callback);
}

function GET(options, opt_callback) {
  options.method = exports.cosmos.Action.GET;
  return request(options, opt_callback);
}

function SUB(options, opt_callback) {
  options.method = exports.cosmos.Action.SUB;
  return request(options, opt_callback);
}

function POST(options, opt_callback) {
  options.method = exports.cosmos.Action.POST;
  return request(options, opt_callback);
}

function PUT(options, opt_callback) {
  options.method = exports.cosmos.Action.PUT;
  return request(options, opt_callback);
}

function HEAD(options, opt_callback) {
  options.method = exports.cosmos.Action.HEAD;
  return request(options, opt_callback);
}

function request(options, opt_callback) {
  var method = options.method;
  delete options.method;

  var subscription, canceled;

  sanitizeURL(options.url, function (error, url) {
    if (error) return opt_callback && opt_callback(error);

    // if you cancel before the userName is replaced.
    if (canceled) return;

    var request = new exports.cosmos.Request(method || exports.cosmos.Action.GET, url, options.headers, options.body);
    subscription = exports.cosmos.resolver.resolve(request, function (error, response) {
      if (!opt_callback) return;
      if (error) return opt_callback(error);
      try {
        opt_callback(null, {
          body: JSON.parse(response.getBody() || '{}'),
          headers: response.getHeaders(),
          status: response.getStatusCode()
        });
      } catch (parseError) {
        parseError.response = response;
        opt_callback(parseError);
      }
    });
  });

  return {
    cancel: function cancel() {
      if (subscription && subscription.cancel) {
        // we already subscribed, cancel it.
        subscription.cancel();
        subscription = null;
      } else if (!canceled) {
        // not subscribed yet, don't even subscribe.
        canceled = true;
      }
      return null;
    }
  };
}

function sanitizeURL(url, callback) {
  if (url.indexOf('@') > -1) {
    live('spotify:client').query('currentUser(username)', function (error, data) {
      if (error) return callback(error);
      callback(null, url.replace('@', liburi.getCanonicalUsername(data.currentUser.username)));
    }, ASAP);
  } else {
    callback(null, url);
  }
}

exports.request = request;
exports.get = GET;
exports.post = POST;
exports.subscribe = SUB;
exports.delete = DELETE;
exports.put = PUT;
exports.head = HEAD;
exports.cosmos = cosmos;

exports.sanitizeURL = sanitizeURL;

},{"../../spotify-live":439,"spotify-cosmos-api":694,"spotify-liburi":707}],320:[function(require,module,exports){
'use strict';

/**
 * @public
 */

/**
 * Get the context URI from the specified node or its parents.
 *
 * @param {HTMLElement} node A DOM node.
 *
 * @return {string} The context URI or empty string if not found.
 */

function getContextFromNodeOrParent(node) {
  var contextNode = node.closest('[data-context]');
  return contextNode && contextNode.getAttribute('data-uri') || '';
};

/**
 * Get the value for the passed attribute name, either from the passed node
 * or from any parent node.
 *
 * @param {HTMLElement} node The node to start searching from.
 * @param {string} attributeName The name of the attribute.
 *
 * @return {string} The value, or empty string if not found.
 */
function getAttributeFromNodeOrParent(node, attributeName) {
  var selector = '[' + attributeName + ']';
  var attributeNode = node.closest(selector);
  return attributeNode && attributeNode.getAttribute(attributeName) || '';
};

exports.getContextFromNodeOrParent = getContextFromNodeOrParent;
exports.getAttributeFromNodeOrParent = getAttributeFromNodeOrParent;

},{}],321:[function(require,module,exports){
'use strict';

module.exports = function getLogContext(target) {
  var currentNode = target;
  var logContext = [];
  while (currentNode) {
    if (currentNode.matches && currentNode.matches('[data-log-context]')) {
      logContext.unshift(currentNode.getAttribute('data-log-context'));
    }
    currentNode = currentNode.parentNode;
  }
  return logContext.join('/') || null;
};

},{}],322:[function(require,module,exports){
'use strict';

var defer = require('prime/defer');

/**
 * Throttle the function calls to only trigger once per tick.
 * This will return a new function that you will use when you want
 * to call your function. Calling it multiple times in the same
 * run loop will only really call it once.
 *
 * @param {function} fn A function.
 * @param {Object=} opt_ctx The context to run the function in ('this').
 *
 * @return {function} A new function.
 */
function throttle(fn, opt_ctx) {
  var queued = false;
  var args;

  return function () {
    args = arguments;
    if (!queued) {
      queued = true;
      defer.frame(function () {
        queued = false;
        fn.apply(opt_ctx, args);
      });
    }
  };
}

module.exports = throttle;

},{"prime/defer":676}],323:[function(require,module,exports){
'use strict';

var $ = require('../spotify-elements');
var live = require('../spotify-live');

var update = function update(node) {

  var observables = ($(node) || $(document)).search('[data-watch]');

  if (observables) observables.forEach(function (node) {
    node = $(node);
    var key = node.data('watch');

    if (!key) return;

    var observed = node._observed || (node._observed = {});

    if (observed[key]) return;
    observed[key] = true;

    var parent;

    var uriNode = node[0].closest('[data-uri]');
    var uri = uriNode && uriNode.getAttribute('data-uri');

    if (!uri) return;

    var model = live(uri);

    var updateText = function updateText(event) {
      if (key in event) {
        var value = event[key];
        node.text(value == null ? '' : value);
      }
    };

    model.get(key, function (err, value) {
      if (err) throw err;
      var event = {};
      event[key] = value;
      updateText(event);
    });

    model.on('update', updateText);
  });
};

var isAttached = false;

exports.update = function (optNode) {
  if (!isAttached) return;

  update(optNode);
};
exports.attach = function () {
  if (isAttached) return;
  isAttached = true;
};
exports.detach = function () {
  if (!isAttached) return;
  isAttached = false;
};

},{"../spotify-elements":259,"../spotify-live":439}],324:[function(require,module,exports){
(function (global){
'use strict';

exports.init = function () {
  require('./expose-debug-global').expose(global, 'abba', require('../spotify-abba-mini'));
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-abba-mini":181,"./expose-debug-global":327}],325:[function(require,module,exports){
(function (global){
'use strict';

exports.init = function () {
  require('./expose-debug-global').expose(global, 'bridge', require('../spotify-bridge-request'));
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-bridge-request":253,"./expose-debug-global":327}],326:[function(require,module,exports){
(function (global){
'use strict';

exports.init = function () {
  require('./expose-debug-global').expose(global, 'cosmos', require('spotify-cosmos-api'));
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./expose-debug-global":327,"spotify-cosmos-api":694}],327:[function(require,module,exports){
'use strict';

exports.expose = function (global, name, object) {
  if (global.__spotify && global.__spotify.developer_mode) {
    Object.defineProperty(global, name, {
      get: function get() {
        try {
          throw new Error();
        } catch (error) {
          if (!/injectedscript/i.test(error.stack)) {
            throw new Error('window.' + name + ' should only be accessed from the console');
          }
        }
        return object;
      },
      enumerable: true,
      configurable: true
    });
  }
};

},{}],328:[function(require,module,exports){
(function (global){
'use strict';

exports.init = function () {
  require('./expose-debug-global').expose(global, 'live', require('../spotify-live'));
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-live":439,"./expose-debug-global":327}],329:[function(require,module,exports){
module.exports = {
  "Album": "Album",
  "AndMore": "und {0} weitere",
  "Artist": "Künstler",
  "By": "von",
  "Create Similar Playlist": "Ähnliche Playlist erstellen",
  "Filter": "Filter",
  "Follow": "Folgen",
  "Follower": "Follower",
  "FollowersLabel": "Followers",
  "Following": "Folge ich",
  "FollowingLabel": "Folge ich",
  "ListenersLabel": "Monatliche Hörer",
  "FollowsYou": "Folgt dir",
  "HoldToPreview": "Zum Reinhören gedrückt halten",
  "ListenCount": "{0} Mal abgespielt",
  "ListenReactionMulti": "{0} Hörer in Deinem Netzwerk",
  "ListenReactionSingle": "{0} hört sich das an",
  "LocalFile": "Lokale Datei",
  "More": "Mehr",
  "Pause": "Pause",
  "Play": "Play",
  "Playlist": "Playlist",
  "PressEnterToPlay": "Drück die Eingabetaste zum Abspielen",
  "Popularity": "Beliebtheit",
  "Remove": "Entfernen",
  "RemoveYourMusic": "Aus \"Deine Musik\" entfernen",
  "Save": "Speichern",
  "SaveYourMusic": "In \"Deine Musik\" speichern",
  "Saved": "Gespeichert",
  "ShufflePlay": "Shuffle",
  "Song": "Song",
  "StartRadio": "Radio starten",
  "Time": "Dauer",
  "Toplist": "Top-Songs",
  "Track": "Song",
  "Unfollow": "Nicht mehr folgen",
  "User": "Benutzer",
  "ViewAll": "Mehr Darstellung",
  "HoursShort": "{0} Std.",
  "MinutesShort": "{0} Min.",
  "SecondsShort": "{0} Sek.",
  "ErrorTitle": "Bei der Anzeige dieser Ansicht ist ein Fehler aufgetreten!",
  "ErrorMessage": "Diese Ansicht ist entweder nicht vorhanden oder es ist ein Fehler aufgetreten.",
  "OfflineTitle": "Diese Ansicht ist offline nicht verfügbar.",
  "OfflineMessage": "Geh zum Laden online."
};
},{}],330:[function(require,module,exports){
module.exports = {
  "Album": "Άλμπουμ",
  "AndMore": "και άλλοι {0}",
  "Artist": "Καλλιτέχνης",
  "By": "από",
  "Create Similar Playlist": "Δημιουργία παρόμοιας playlist",
  "Filter": "Φίλτρο",
  "Follow": "Ακολούθησε",
  "Follower": "Οπαδός",
  "FollowersLabel": "Οπαδοί",
  "Following": "Aκολουθείται",
  "FollowingLabel": "Aκολουθείται",
  "ListenersLabel": "Μηνιαίοι ακροατές",
  "FollowsYou": "Σε ακολουθεί",
  "HoldToPreview": "Πάτησε και κράτησε πατημένο για προεπισκόπηση",
  "ListenCount": "{0} αναπαραγωγές",
  "ListenReactionMulti": "{0} ακροατές στο δίκτυό σου",
  "ListenReactionSingle": "Ο χρήστης {0} ακούει αυτό",
  "LocalFile": "Τοπικό αρχείο",
  "More": "Περισσότερα",
  "Pause": "Παύση",
  "Play": "Αναπαραγωγή",
  "Playlist": "Λίστα",
  "PressEnterToPlay": "Πάτησε Enter για αναπαραγωγή",
  "Popularity": "Δημοφιλία",
  "Remove": "Αφαίρεση",
  "RemoveYourMusic": "Αφαίρεση από τη Mουσική σου",
  "Save": "Αποθήκευση",
  "SaveYourMusic": "Αποθήκευση στη Mουσική σου",
  "Saved": "Αποθηκεύτηκε",
  "ShufflePlay": "Τυχαία αναπαραγωγή",
  "Song": "Τραγούδι",
  "StartRadio": "Έναρξη ραδιοφώνου",
  "Time": "Διάρκεια",
  "Toplist": "Κορυφαία τραγούδια",
  "Track": "Τραγούδι",
  "Unfollow": "Άρση ακολούθησης",
  "User": "Χρήστης",
  "ViewAll": "Δες τα όλα",
  "HoursShort": "{0} ώρα",
  "MinutesShort": "{0} λεπ.",
  "SecondsShort": "{0} δευτ.",
  "ErrorTitle": "Προέκυψε σφάλμα κατά την προβολή αυτής της οθόνης!",
  "ErrorMessage": "Η συγκεκριμένη προβολή δεν υπάρχει ή προέκυψε κάποιο σφάλμα.",
  "OfflineTitle": "Αυτή η προβολή δεν είναι διαθέσιμη εκτός σύνδεσης!",
  "OfflineMessage": "Συνδέσου στο διαδίκτυο για να πραγματοποιηθεί φόρτωση."
};
},{}],331:[function(require,module,exports){
module.exports = {
  "Album": "Album",
  "AndMore": "and {0} more",
  "Artist": "Artist",
  "By": "by",
  "Create Similar Playlist": "Create Similar Playlist",
  "Filter": "Filter",
  "Follow": "Follow",
  "Follower": "Follower",
  "FollowersLabel": "Followers",
  "Following": "Following",
  "FollowingLabel": "Following",
  "ListenersLabel": "Monthly Listeners",
  "FollowsYou": "Follows You",
  "HoldToPreview": "Click and Hold to Preview",
  "ListenCount": "{0} plays",
  "ListenReactionMulti": "{0} listeners in your network",
  "ListenReactionSingle": "{0} listens to this",
  "LocalFile": "Local File",
  "More": "More",
  "Pause": "Pause",
  "Play": "Play",
  "Playlist": "Playlist",
  "PressEnterToPlay": "Press Enter to play",
  "Popularity": "Popularity",
  "Remove": "Remove",
  "RemoveYourMusic": "Remove from Your Music",
  "Save": "Save",
  "SaveYourMusic": "Save to Your Music",
  "Saved": "Saved",
  "ShufflePlay": "Shuffle Play",
  "Song": "Song",
  "StartRadio": "Start Radio",
  "Time": "Time",
  "Toplist": "Top songs",
  "Track": "Song",
  "Unfollow": "Unfollow",
  "User": "User",
  "ViewAll": "View All",
  "HoursShort": "{0} hr",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} sec",
  "ErrorTitle": "There was a problem displaying this view!",
  "ErrorMessage": "This view either does not exist or an error occurred.",
  "OfflineTitle": "This view is not available offline!",
  "OfflineMessage": "Please go online to load."
}
;
},{}],332:[function(require,module,exports){
module.exports = {
  "Album": "Álbum",
  "AndMore": "y {0} más",
  "Artist": "Artista",
  "By": "por",
  "Create Similar Playlist": "Crear playlist similar",
  "Filter": "Filtrar",
  "Follow": "Seguir",
  "Follower": "Seguidor",
  "FollowersLabel": "Seguidores",
  "Following": "Siguiendo",
  "FollowingLabel": "Siguiendo",
  "ListenersLabel": "Oyentes mensuales",
  "FollowsYou": "Te sigue",
  "HoldToPreview": "Haz clic y mantén pulsado para oír la muestra preliminar",
  "ListenCount": "{0} reproducciones",
  "ListenReactionMulti": "{0} oyentes en tu red",
  "ListenReactionSingle": "{0} escucha esto",
  "LocalFile": "Archivo local",
  "More": "Más",
  "Pause": "Pausa",
  "Play": "Reproducir",
  "Playlist": "Lista",
  "PressEnterToPlay": "Presiona Enter para reproducir",
  "Popularity": "Popularidad",
  "Remove": "Eliminar",
  "RemoveYourMusic": "Eliminar de Tu Música",
  "Save": "Guardar",
  "SaveYourMusic": "Guardar en Tu Música",
  "Saved": "Guardado",
  "ShufflePlay": "Aleatoria",
  "Song": "Canción",
  "StartRadio": "Comenzar Radio",
  "Time": "Tiempo",
  "Toplist": "Canciones más reproducidas",
  "Track": "Canción",
  "Unfollow": "Dejar de seguir",
  "User": "Usuario",
  "ViewAll": "Ver todos",
  "HoursShort": "{0} hr",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} seg",
  "ErrorTitle": "Hubo un problema al mostrar esta vista.",
  "ErrorMessage": "Puede ser que esta vista no exista, o bien, que haya ocurrido un error.",
  "OfflineTitle": "Esta vista no está disponible sin conexión. ",
  "OfflineMessage": "Conéctate a la red para cargar."
};
},{}],333:[function(require,module,exports){
module.exports = {
  "Album": "Álbum",
  "AndMore": "y {0} más",
  "Artist": "Artista",
  "By": "por",
  "Create Similar Playlist": "Crear playlist similar",
  "Filter": "Filtrar",
  "Follow": "Seguir",
  "Follower": "Seguidor",
  "FollowersLabel": "Seguidores",
  "Following": "Siguiendo",
  "FollowingLabel": "Siguiendo",
  "ListenersLabel": "Oyentes mensuales",
  "FollowsYou": "Te sigue",
  "HoldToPreview": "Pulsa y mantén pulsado para oír la muestra preliminar",
  "ListenCount": "{0} reproducciones",
  "ListenReactionMulti": "{0} oyentes en tu red",
  "ListenReactionSingle": "{0} escucha esto",
  "LocalFile": "Archivo local",
  "More": "Más",
  "Pause": "Pausar",
  "Play": "Reproducir",
  "Playlist": "Lista",
  "PressEnterToPlay": "Pulsa Intro para reproducir",
  "Popularity": "Popularidad",
  "Remove": "Retirar",
  "RemoveYourMusic": "Eliminar de Tu música",
  "Save": "Guardar",
  "SaveYourMusic": "Guardar en Tu música",
  "Saved": "Guardada",
  "ShufflePlay": "Aleatoria",
  "Song": "Canción",
  "StartRadio": "Comenzar radio",
  "Time": "Tiempo",
  "Toplist": "Canciones más escuchadas",
  "Track": "Canción",
  "Unfollow": "Dejar de seguir",
  "User": "Usuario",
  "ViewAll": "Ver todos",
  "HoursShort": "{0} hr",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} seg",
  "ErrorTitle": "Se ha producido un problema al mostrar esta vista.",
  "ErrorMessage": "Esta vista no existe o se ha producido un error.",
  "OfflineTitle": "Esta vista no está disponible sin conexión. ",
  "OfflineMessage": "Por favor, conéctate para cargar."
};
},{}],334:[function(require,module,exports){
module.exports = {
  "Album": "Albumi",
  "AndMore": "ja {0} muuta",
  "Artist": "Artisti",
  "By": "tekijältä",
  "Create Similar Playlist": "Luo samankaltainen soittolista",
  "Filter": "Suodatin",
  "Follow": "Seuraa",
  "Follower": "Seuraaja",
  "FollowersLabel": "Seuraajat",
  "Following": "Seurataan",
  "FollowingLabel": "Seurataan",
  "ListenersLabel": "Kuuntelijat kuukauden aikana",
  "FollowsYou": "Seuraa sinua",
  "HoldToPreview": "Kuuntele pätkä pitämällä tätä painettuna",
  "ListenCount": "{0} toistoa",
  "ListenReactionMulti": "{0} kuuntelijaa verkostossasi",
  "ListenReactionSingle": "{0} kuuntelee tätä",
  "LocalFile": "Paikallinen tiedosto",
  "More": "Lisää",
  "Pause": "Tauko",
  "Play": "Toista",
  "Playlist": "Soittolista",
  "PressEnterToPlay": "Toista painamalla Enter-näppäintä",
  "Popularity": "Suosio",
  "Remove": "Poista",
  "RemoveYourMusic": "Poista Omasta musiikista",
  "Save": "Tallenna",
  "SaveYourMusic": "Tallenna Omaan musiikkiin",
  "Saved": "Tallennettu",
  "ShufflePlay": "Satunnaistoisto",
  "Song": "Kappale",
  "StartRadio": "Käynnistä radio",
  "Time": "Kesto",
  "Toplist": "Suosituimmat kappaleet",
  "Track": "Kappale",
  "Unfollow": "Lopeta seuraaminen",
  "User": "Käyttäjä",
  "ViewAll": "Näytä kaikki",
  "HoursShort": "{0} h",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} s",
  "ErrorTitle": "Tämän näkymän näyttämisessä on ongelmia.",
  "ErrorMessage": "Tätä näkymää ei ole, tai tapahtui virhe.",
  "OfflineTitle": "Tätä näkymää ei voi käyttää offline-tilassa!",
  "OfflineMessage": "Siirry online-tilaan, jotta voit ladata."
};
},{}],335:[function(require,module,exports){
module.exports = {
  "Album": "Album",
  "AndMore": "et {0} autres",
  "Artist": "Artiste",
  "By": "par",
  "Create Similar Playlist": "Créer une liste de lecture semblable",
  "Filter": "Filtrer",
  "Follow": "Suivre",
  "Follower": "Abonné",
  "FollowersLabel": "Abonné",
  "Following": "Suivis",
  "FollowingLabel": "Suivis",
  "ListenersLabel": "Auditeurs mensuels",
  "FollowsYou": "Vous suit",
  "HoldToPreview": "Cliquez longuement pour avoir un aperçu",
  "ListenCount": "{0} écoutes",
  "ListenReactionMulti": "{0} auditeurs dans votre réseau",
  "ListenReactionSingle": "{0} écoute ceci",
  "LocalFile": "Fichier local",
  "More": "Plus",
  "Pause": "Pause",
  "Play": "Lecture",
  "Playlist": "Playlist",
  "PressEnterToPlay": "Appuyez sur Entrée pour faire la lecture",
  "Popularity": "Popularité",
  "Remove": "Supprimer",
  "RemoveYourMusic": "Supprimer de Votre musique",
  "Save": "Sauvegarder",
  "SaveYourMusic": "Enregistrer dans Votre musique",
  "Saved": "Sauvegardé",
  "ShufflePlay": "Lecture aléatoire",
  "Song": "Titre",
  "StartRadio": "Lancer la radio",
  "Time": "Durée",
  "Toplist": "Meilleures chansons",
  "Track": "Titre",
  "Unfollow": "Ne plus suivre",
  "User": "Utilisateur",
  "ViewAll": "Voir tout",
  "HoursShort": "{0} h",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} s",
  "ErrorTitle": "Un problème est survenu lors du chargement de cet affichage!",
  "ErrorMessage": "L'affichage n'existe pas ou une erreur s'est produite.",
  "OfflineTitle": "Cette vue n'est pas disponible hors ligne!",
  "OfflineMessage": "Veuillez accéder à Internet pour charger le contenu."
};
},{}],336:[function(require,module,exports){
module.exports = {
  "Album": "Album",
  "AndMore": "et {0} autres",
  "Artist": "Artiste",
  "By": "par",
  "Create Similar Playlist": "Créer une playlist similaire",
  "Filter": "Filtre",
  "Follow": "S'abonner",
  "Follower": "Abonné",
  "FollowersLabel": "Abonnés",
  "Following": "Abonné",
  "FollowingLabel": "Abonné",
  "ListenersLabel": "Nombres de personnes qui écoutent par mois",
  "FollowsYou": "Est abonné à vous",
  "HoldToPreview": "Cliquez longuement pour avoir un aperçu",
  "ListenCount": "{0} écoutes",
  "ListenReactionMulti": "{0} auditeurs dans votre réseau",
  "ListenReactionSingle": "{0} écoute ceci.",
  "LocalFile": "Fichier local",
  "More": "Plus",
  "Pause": "Pause",
  "Play": "Lire",
  "Playlist": "Playlist",
  "PressEnterToPlay": "Appuyez sur Entrée pour écouter",
  "Popularity": "Popularité",
  "Remove": "Supprimer",
  "RemoveYourMusic": "Supprimer de Ma musique",
  "Save": "Sauvegarder",
  "SaveYourMusic": "Sauvegarder dans Ma musique",
  "Saved": "Sauvegardé",
  "ShufflePlay": "Aléatoire",
  "Song": "Titre",
  "StartRadio": "Ecouter la radio",
  "Time": "Durée",
  "Toplist": "Top titres",
  "Track": "Titre",
  "Unfollow": "Se désabonner",
  "User": "Utilisateur",
  "ViewAll": "Présentation tout",
  "HoursShort": "{0} h",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} s",
  "ErrorTitle": "Problème d'affichage !",
  "ErrorMessage": "Cet affichage n'existe pas ou une erreur s'est produite.",
  "OfflineTitle": "Cet affichage n'est pas disponible hors connexion.",
  "OfflineMessage": "Connectez-vous pour procéder au chargement."
};
},{}],337:[function(require,module,exports){
module.exports = {
  "Album": "Album",
  "AndMore": "és még {0} felhasználó",
  "Artist": "Előadó",
  "By": "tőle:",
  "Create Similar Playlist": "Hasonló műsorlista létrehozása",
  "Filter": "Szűrő",
  "Follow": "Követés",
  "Follower": "Követő",
  "FollowersLabel": "Követők",
  "Following": "Követések",
  "FollowingLabel": "Követések",
  "ListenersLabel": "Hallgatók havonta",
  "FollowsYou": "Téged követ",
  "HoldToPreview": "Tartsd nyomva a belehallgatáshoz",
  "ListenCount": "{0} lejátszás",
  "ListenReactionMulti": "{0} ismerősöd hallgatta meg",
  "ListenReactionSingle": "{0} már meghallgatta",
  "LocalFile": "Helyi fájl",
  "More": "Több",
  "Pause": "Szünet",
  "Play": "Lejátszás",
  "Playlist": "Lejátszási lista",
  "PressEnterToPlay": "Lejátszás az Enterrel",
  "Popularity": "Népszerűség",
  "Remove": "Eltávolítás",
  "RemoveYourMusic": "Törlés a Zenéid közül",
  "Save": "Mentés",
  "SaveYourMusic": "Mentés a Zenéid közé",
  "Saved": "Mentett",
  "ShufflePlay": "Lejátszás keverve",
  "Song": "Dal",
  "StartRadio": "Rádió bekapcsolása",
  "Time": "Idő",
  "Toplist": "Toplista",
  "Track": "Dal",
  "Unfollow": "Nem követem",
  "User": "Felhasználó",
  "ViewAll": "Mindent mutat",
  "HoursShort": "{0} óra",
  "MinutesShort": "{0} perc",
  "SecondsShort": "{0} mp",
  "ErrorTitle": "Egy hiba miatt nem jeleníthető meg ez az oldal",
  "ErrorMessage": "A kért nézet nem létezik, vagy valamilyen műszaki hiba történt.",
  "OfflineTitle": "Ez a nézet internetkapcsolat nélkül nem érhető el.",
  "OfflineMessage": "Csatlakozz az internethez, majd indítsd el."
};
},{}],338:[function(require,module,exports){
module.exports = {
  "Album": "Album",
  "AndMore": "dan {0} lagi",
  "Artist": "Artis",
  "By": "menurut",
  "Create Similar Playlist": "Buat Playlist Serupa",
  "Filter": "Filter",
  "Follow": "Ikuti",
  "Follower": "Pengikut",
  "FollowersLabel": "Pengikut",
  "Following": "Mengikuti",
  "FollowingLabel": "Mengikuti",
  "ListenersLabel": "Pendengar Bulanan",
  "FollowsYou": "Mengikutimu",
  "HoldToPreview": "Klik dan Tahan untuk Pratinjau",
  "ListenCount": "{0} permainan",
  "ListenReactionMulti": "{0} pendengar di jaringanmu",
  "ListenReactionSingle": "{0} mendengarkan ini",
  "LocalFile": "File Lokal",
  "More": "Lainnya",
  "Pause": "Jeda",
  "Play": "Play",
  "Playlist": "Playlist",
  "PressEnterToPlay": "Tekan Enter untuk memainkan",
  "Popularity": "Popularitas",
  "Remove": "Hapus",
  "RemoveYourMusic": "Hapus dari Musik Kamu",
  "Save": "Simpan",
  "SaveYourMusic": "Simpan ke Musik Kamu",
  "Saved": "Tersimpan",
  "ShufflePlay": "Pemutaran Acak",
  "Song": "Lagu",
  "StartRadio": "Mulai Radio",
  "Time": "Waktu",
  "Toplist": "Lagu teratas",
  "Track": "Lagu",
  "Unfollow": "Berhenti mengikuti",
  "User": "Pengguna",
  "ViewAll": "Lihat Semua",
  "HoursShort": "{0} jam",
  "MinutesShort": "{0} mnt",
  "SecondsShort": "{0} dtk",
  "ErrorTitle": "Ada masalah saat menampilkan tampilan ini!",
  "ErrorMessage": "Tampilan ini tidak ada atau terjadi kesalahan.",
  "OfflineTitle": "Tampilan ini tidak tersedia offline.",
  "OfflineMessage": "Alihkan ke online untuk memuat."
};
},{}],339:[function(require,module,exports){
module.exports = {
  "Album": "Album",
  "AndMore": "e altri {0}",
  "Artist": "Artista",
  "By": "per",
  "Create Similar Playlist": "Crea playlist simile",
  "Filter": "Filtra",
  "Follow": "Segui",
  "Follower": "Follower",
  "FollowersLabel": "Follower",
  "Following": "Following",
  "FollowingLabel": "Following",
  "ListenersLabel": "Ascoltatori questo mese",
  "FollowsYou": "Ti segue",
  "HoldToPreview": "Tieni premuto per un'anteprima",
  "ListenCount": "{0} riproduzioni",
  "ListenReactionMulti": "{0} ascoltatori nella tua rete",
  "ListenReactionSingle": "{0} ascolta questo",
  "LocalFile": "File locale",
  "More": "Più",
  "Pause": "Pausa",
  "Play": "Play",
  "Playlist": "Playlist",
  "PressEnterToPlay": "Premi Invio per riprodurre",
  "Popularity": "Popolarità",
  "Remove": "Rimuovi",
  "RemoveYourMusic": "Elimina da La tua musica",
  "Save": "Salva",
  "SaveYourMusic": "Salva in La tua musica",
  "Saved": "Salvato",
  "ShufflePlay": "Riproduzione shuffle",
  "Song": "Brano",
  "StartRadio": "Crea una radio",
  "Time": "Durata",
  "Toplist": "Brani top",
  "Track": "Brano",
  "Unfollow": "Non seguire più",
  "User": "Utente",
  "ViewAll": "Visualizza tutto",
  "HoursShort": "{0} ore",
  "MinutesShort": "{0} min.",
  "SecondsShort": "{0} sec",
  "ErrorTitle": "Si è verificato un errore in questa vista.",
  "ErrorMessage": "La vista non esiste o si è verificato un errore.",
  "OfflineTitle": "Questa vista non è disponibile offline.",
  "OfflineMessage": "Passa online per caricare."
};
},{}],340:[function(require,module,exports){
module.exports = {
  "Album": "アルバム",
  "AndMore": "その他{0}人",
  "Artist": "アーティスト",
  "By": "/",
  "Create Similar Playlist": "同様のプレイリストを作成",
  "Filter": "フィルタ",
  "Follow": "フォロー",
  "Follower": "フォロワー",
  "FollowersLabel": "フォロワー",
  "Following": "フォロー中",
  "FollowingLabel": "フォロー中",
  "ListenersLabel": "今月のリスナー",
  "FollowsYou": "あなたをフォローしています",
  "HoldToPreview": "プレビューするには、クリックを押しします",
  "ListenCount": "{0}回再生",
  "ListenReactionMulti": "ネットワーク内で{0}人が聴いています",
  "ListenReactionSingle": "{0}さんはこれを聴いています",
  "LocalFile": "ローカルファイル",
  "More": "詳細",
  "Pause": "一時停止",
  "Play": "再生",
  "Playlist": "プレイリスト",
  "PressEnterToPlay": "再生するにはEnterキーを押します",
  "Popularity": "人気",
  "Remove": "削除",
  "RemoveYourMusic": "My Musicから削除",
  "Save": "保存",
  "SaveYourMusic": "My Musicに保存",
  "Saved": "保存済み",
  "ShufflePlay": "シャッフルプレイ",
  "Song": "ソング",
  "StartRadio": "Radioを開始",
  "Time": "時間",
  "Toplist": "トップ曲",
  "Track": "ソング",
  "Unfollow": "フォローをやめる",
  "User": "ユーザー",
  "ViewAll": "すべて表示",
  "HoursShort": "{0} 時間",
  "MinutesShort": "{0} 分",
  "SecondsShort": "{0} 秒",
  "ErrorTitle": "このビューを表示しようとしているときに問題が発生しました。",
  "ErrorMessage": "このビューが存在しないか、エラーが発生しました。",
  "OfflineTitle": "このビューはオフラインでは使用できません。",
  "OfflineMessage": "ロードするには、インターネットに接続してください。"
};
},{}],341:[function(require,module,exports){
module.exports = {
  "Album": "Album",
  "AndMore": "en {0} meer",
  "Artist": "Artiest",
  "By": "van",
  "Create Similar Playlist": "Vergelijkbare afspeellijst maken",
  "Filter": "Filter",
  "Follow": "Volgen",
  "Follower": "Volger",
  "FollowersLabel": "Volgers",
  "Following": "Volgend",
  "FollowingLabel": "Volgend",
  "ListenersLabel": "Luisteraars per maand",
  "FollowsYou": "Volgt jou",
  "HoldToPreview": "Klikken en vasthouden om een stukje te horen",
  "ListenCount": "{0} keer afgespeeld",
  "ListenReactionMulti": "{0} luisteraars in jouw netwerk",
  "ListenReactionSingle": "{0} luistert hiernaar",
  "LocalFile": "Lokaal bestand",
  "More": "Meer",
  "Pause": "Pauze",
  "Play": "Afspelen",
  "Playlist": "Afspeellijst",
  "PressEnterToPlay": "Druk op Enter om af te spelen",
  "Popularity": "Populariteit",
  "Remove": "Verwijderen",
  "RemoveYourMusic": "Verwijderen uit Jouw Muziek",
  "Save": "Opslaan",
  "SaveYourMusic": "Opslaan in Jouw Muziek",
  "Saved": "Opgeslagen",
  "ShufflePlay": "Shuffle",
  "Song": "Nummer",
  "StartRadio": "Radio starten",
  "Time": "Tijd",
  "Toplist": "Topnummers",
  "Track": "Nummer",
  "Unfollow": "Niet meer volgen",
  "User": "Gebruiker",
  "ViewAll": "Alles bekijken",
  "HoursShort": "{0} uur",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} sec",
  "ErrorTitle": "Er is een fout opgetreden bij het laden van deze weergave.",
  "ErrorMessage": "Deze weergave bestaat niet of er is een fout opgetreden.",
  "OfflineTitle": "Deze weergave is offline niet beschikbaar!",
  "OfflineMessage": "Ga online om te laden."
};
},{}],342:[function(require,module,exports){
module.exports = {
  "Album": "Album",
  "AndMore": "i {0} więcej",
  "Artist": "Wykonawca",
  "By": "według",
  "Create Similar Playlist": "Utwórz podobną playlistę",
  "Filter": "Filtruj",
  "Follow": "Obserwuj",
  "Follower": "Obserwujący",
  "FollowersLabel": "Obserwatorzy",
  "Following": "Obserwowana",
  "FollowingLabel": "Obserwowana",
  "ListenersLabel": "Słuchacze w tym miesiącu",
  "FollowsYou": "Obserwuje Cię",
  "HoldToPreview": "Aby odsłuchać, kliknij i przytrzymaj.",
  "ListenCount": "Liczba odtworzeń: {0}",
  "ListenReactionMulti": "Liczba słuchaczy w Twojej sieci: {0}",
  "ListenReactionSingle": "Użytkownik {0} słucha tego",
  "LocalFile": "Plik lokalny",
  "More": "Więcej",
  "Pause": "Pauza",
  "Play": "Odtwórz",
  "Playlist": "Playlista",
  "PressEnterToPlay": "Naciśnij Enter, aby odtworzyć",
  "Popularity": "Popularność",
  "Remove": "Usuń",
  "RemoveYourMusic": "Usuń z kolekcji Twoja muzyka",
  "Save": "Zapisz",
  "SaveYourMusic": "Zapisz w kolekcji Twoja muzyka",
  "Saved": "Zapisany",
  "ShufflePlay": "Odtwarzanie losowe",
  "Song": "Utwór",
  "StartRadio": "Włącz radio",
  "Time": "Czas",
  "Toplist": "Najpopularniejsze utwory",
  "Track": "Utwór",
  "Unfollow": "Przestań obserwować",
  "User": "Użytkownik",
  "ViewAll": "Wyświetl wszystko",
  "HoursShort": "{0} godz.",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} s",
  "ErrorTitle": "Podczas wyświetlania tego widoku wystąpił błąd!",
  "ErrorMessage": "Ten widok nie istnieje lub wystąpił błąd.",
  "OfflineTitle": "Ten widok jest niedostępny w trybie offline. ",
  "OfflineMessage": "Przejdź do trybu online, aby załadować."
};
},{}],343:[function(require,module,exports){
module.exports = {
  "Album": "Álbum",
  "AndMore": "e mais {0}",
  "Artist": "Artista",
  "By": "de",
  "Create Similar Playlist": "Criar playlist similar",
  "Filter": "Filtrar",
  "Follow": "Seguir",
  "Follower": "Seguidor",
  "FollowersLabel": "Seguidores",
  "Following": "Seguindo",
  "FollowingLabel": "Seguindo",
  "ListenersLabel": "Ouvintes mensais",
  "FollowsYou": "Segue você",
  "HoldToPreview": "Clique e segure para a prévia",
  "ListenCount": "{0} reproduções",
  "ListenReactionMulti": "{0} ouvintes na sua rede",
  "ListenReactionSingle": "{0} ouvem isso",
  "LocalFile": "Arquivo local",
  "More": "Mais",
  "Pause": "Pause",
  "Play": "Play",
  "Playlist": "Playlist",
  "PressEnterToPlay": "Pressione Enter para tocar",
  "Popularity": "Popularidade",
  "Remove": "Remover",
  "RemoveYourMusic": "Remover de Suas músicas",
  "Save": "Salvar",
  "SaveYourMusic": "Salvar em Suas músicas",
  "Saved": "Salvo",
  "ShufflePlay": "Ordem aleatória",
  "Song": "Música",
  "StartRadio": "Abrir rádio",
  "Time": "Tempo",
  "Toplist": "Músicas mais tocadas",
  "Track": "Música",
  "Unfollow": "Deixar de seguir",
  "User": "Usuário",
  "ViewAll": "Ver tudo",
  "HoursShort": "{0} h",
  "MinutesShort": "{0} m",
  "SecondsShort": "{0} s",
  "ErrorTitle": "Tivemos um problema ao mostrar esta exibição!",
  "ErrorMessage": "A exibição não existe ou ocorreu um erro.",
  "OfflineTitle": "Essa visualização não está disponível offline!",
  "OfflineMessage": "Fique online para carregar."
};
},{}],344:[function(require,module,exports){
module.exports = {
  "Album": "Album",
  "AndMore": "och {0} till",
  "Artist": "Artist",
  "By": "av",
  "Create Similar Playlist": "Skapa en liknande spellista",
  "Filter": "Filtrera",
  "Follow": "Följ",
  "Follower": "Följare",
  "FollowersLabel": "Följare",
  "Following": "Följer",
  "FollowingLabel": "Följer",
  "ListenersLabel": "Lyssnare per månad",
  "FollowsYou": "Följer dig",
  "HoldToPreview": "Klicka och håll kvar för att förhandslyssna",
  "ListenCount": "{0} uppspelningar",
  "ListenReactionMulti": "{0} lyssnare i ditt nätverk",
  "ListenReactionSingle": "{0} lyssnar på detta",
  "LocalFile": "Lokal fil",
  "More": "Mer",
  "Pause": "Pausa",
  "Play": "Spela upp",
  "Playlist": "Spellista",
  "PressEnterToPlay": "Tryck på Retur om du vill lyssna",
  "Popularity": "Popularitet",
  "Remove": "Ta bort",
  "RemoveYourMusic": "Ta bort från Din Musik",
  "Save": "Spara",
  "SaveYourMusic": "Spara i Din Musik",
  "Saved": "Sparade",
  "ShufflePlay": "Slumpmässig uppspelning",
  "Song": "Låt",
  "StartRadio": "Starta radio",
  "Time": "Tid",
  "Toplist": "Topplåtar",
  "Track": "Låt",
  "Unfollow": "Sluta följa",
  "User": "Användare",
  "ViewAll": "Visa alla",
  "HoursShort": "{0} tim",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} sek",
  "ErrorTitle": "Det uppstod ett fel när den här vyn skulle visas!",
  "ErrorMessage": "Den här vyn finns inte eller så uppstod ett fel.",
  "OfflineTitle": "Den här vyn är inte tillgänglig offline.",
  "OfflineMessage": "Anslut till internet om du vill läsa in appen."
};
},{}],345:[function(require,module,exports){
module.exports = {
  "Album": "Albüm",
  "AndMore": "ve {0} daha",
  "Artist": "Sanatçı",
  "By": "-",
  "Create Similar Playlist": "Benzer Çalma Listesi Oluştur",
  "Filter": "Filtrele",
  "Follow": "Takip Et",
  "Follower": "Takipçi",
  "FollowersLabel": "Takipçiler",
  "Following": "Takip Ediliyor",
  "FollowingLabel": "Takip Ediliyor",
  "ListenersLabel": "Aylık Dinleyici",
  "FollowsYou": "Seni Takip Ediyor",
  "HoldToPreview": "Basılı Tut ve Önizle",
  "ListenCount": "{0} dinleme",
  "ListenReactionMulti": "Ağında {0} dinleyici",
  "ListenReactionSingle": "{0} bunu dinliyor",
  "LocalFile": "Yerel Dosya",
  "More": "Daha fazla",
  "Pause": "Duraklat",
  "Play": "Çal",
  "Playlist": "Çalma listesi",
  "PressEnterToPlay": "Çalmak için Enter'a bas",
  "Popularity": "Popülerlik",
  "Remove": "Çıkar",
  "RemoveYourMusic": "Müziklerin'den çıkar",
  "Save": "Kaydet",
  "SaveYourMusic": "Müziklerin'e kaydet",
  "Saved": "Kaydedildi",
  "ShufflePlay": "Karışık Çal",
  "Song": "Şarkı",
  "StartRadio": "Radyoyu Başlat",
  "Time": "Saat",
  "Toplist": "En çok dinlenen şarkılar",
  "Track": "Şarkı",
  "Unfollow": "Takip Etmeyi Bırak",
  "User": "Kullanıcı",
  "ViewAll": "Tümünü Görüntüle",
  "HoursShort": "{0} sa",
  "MinutesShort": "{0} dk",
  "SecondsShort": "{0} sn",
  "ErrorTitle": "Bu öğe görüntülenirken bir sorun oluştu!",
  "ErrorMessage": "Bu görünüm yok veya bir hata oluştu.",
  "OfflineTitle": "Bu görünüm çevrimdışıyken kullanılamaz!",
  "OfflineMessage": "Yüklemek için lütfen çevrimiçi ol."
};
},{}],346:[function(require,module,exports){
module.exports = {
  "Album": "專輯",
  "AndMore": "還有 {0} 首",
  "Artist": "藝人",
  "By": "－",
  "Create Similar Playlist": "建立相似的播放清單",
  "Filter": "篩選",
  "Follow": "關注",
  "Follower": "粉絲",
  "FollowersLabel": "關注者",
  "Following": "正在關注",
  "FollowingLabel": "正在關注",
  "ListenersLabel": "每月聽眾",
  "FollowsYou": "關注你",
  "HoldToPreview": "按住即可預覽",
  "ListenCount": "播放了 {0} 次",
  "ListenReactionMulti": "在你的社群網路中有 {0} 名聽眾",
  "ListenReactionSingle": "{0} 收聽了這首歌曲",
  "LocalFile": "本機檔案",
  "More": "更多",
  "Pause": "暫停",
  "Play": "播放",
  "Playlist": "播放列表",
  "PressEnterToPlay": "請按 Enter 播放",
  "Popularity": "流行",
  "Remove": "移除",
  "RemoveYourMusic": "從你的音樂中移除",
  "Save": "儲存",
  "SaveYourMusic": "儲存至你的音樂",
  "Saved": "已儲存",
  "ShufflePlay": "隨機播放",
  "Song": "歌曲",
  "StartRadio": "啟用電臺",
  "Time": "時間",
  "Toplist": "當紅歌曲",
  "Track": "歌曲",
  "Unfollow": "取消關注",
  "User": "使用者",
  "ViewAll": "檢視全部",
  "HoursShort": "{0} 小時",
  "MinutesShort": "{0} 分鐘",
  "SecondsShort": "{0} 秒鐘",
  "ErrorTitle": "顯示這個畫面時出現問題。",
  "ErrorMessage": "這個畫面可能不存在或發生錯誤。",
  "OfflineTitle": "離線時無法使用這個檢視！",
  "OfflineMessage": "請上網以載入。"
};
},{}],347:[function(require,module,exports){
module.exports = {
  "Album": "Album",
  "AndMore": "dan {0} lagi",
  "Artist": "Artis",
  "By": "oleh",
  "Create Similar Playlist": "Cipta Senarai Main Serupa",
  "Filter": "Penapis",
  "Follow": "Ikut",
  "Follower": "Pengikut",
  "FollowersLabel": "Pengikut",
  "Following": "Mengikuti",
  "FollowingLabel": "Mengikuti",
  "ListenersLabel": "Pendengar Bulanan",
  "FollowsYou": "Megikuti Anda",
  "HoldToPreview": "Klik dan Tahan untuk Pratonton",
  "ListenCount": "{0} main",
  "ListenReactionMulti": "{0} pendengar dalam rangkaian anda",
  "ListenReactionSingle": "{0} mendengar ini",
  "LocalFile": "Fail Setempat",
  "More": "Lebih banyak",
  "Pause": "Jeda",
  "Play": "Main",
  "Playlist": "Senarai main",
  "PressEnterToPlay": "Tekan Enter untuk main",
  "Popularity": "Populariti",
  "Remove": "Keluarkan",
  "RemoveYourMusic": "Keluarkan daripada Muzik Anda",
  "Save": "Simpan",
  "SaveYourMusic": "Simpan ke Muzik Anda",
  "Saved": "Disimpan",
  "ShufflePlay": "Main Rombak",
  "Song": "Lagu",
  "StartRadio": "Mulakan Radio",
  "Time": "Masa",
  "Toplist": "Lagu popular",
  "Track": "Lagu",
  "Unfollow": "Nyahikut",
  "User": "Pengguna",
  "ViewAll": "Lihat Semua",
  "HoursShort": "{0} jam",
  "MinutesShort": "{0} min",
  "SecondsShort": "{0} saat",
  "ErrorTitle": "Terdapat masalah memaparkan paparan ini!",
  "ErrorMessage": "Paparan ini sama ada tidak wujud atau ralat berlaku.",
  "OfflineTitle": "Paparan ini tidak tersedia di luar talian!",
  "OfflineMessage": "Sila ke online untuk memuatkan."
};
},{}],348:[function(require,module,exports){
'use strict';

exports.getVersion = require('./src/version').getVersion;
exports.gridOverlay = require('./src/gridOverlay');

},{"./src/gridOverlay":349,"./src/version":350}],349:[function(require,module,exports){
(function (global){
'use strict';

var cosmos = require('spotify-cosmos-api');

var DEFAULT_GRID_COLOR = 'rgba(251, 74, 131, 0.22)';
var DEFAULT_GRID_COLOR_HIGHLIGHT = 'rgba(251, 74, 131, 0.8)';
var GRID_BASELINE = 8;

var overlayElement = null;
var baselineHighlightElement = null;
var gridColor = '';
var highlightGridColor = '';
var gridModes = ['off', 'column', 'baseline'];
var currentModeIndex = 0;

/**
 * Listen for control messages to toggle the grid when a menu item is clicked
 * or a keyboard shortcut is pressed. This only happens if the user is a global
 * app developer.
 */
function listen() {
  var spotify = global.__spotify;
  var productState = spotify && spotify.product_state;
  var appDeveloperFlag = productState && productState['app-developer'];

  if (appDeveloperFlag === '3' || appDeveloperFlag === '7') {
    cosmos.resolver.subscribe({
      url: 'sp://messages/v1/container/control'
    }, function (error, response) {
      if (error) return;
      var data = response.getJSONBody();
      if (data && data.type === 'toggle_grid') {
        toggle();
      }
    });
  }
}

/**
 * Toggle the grid overlay.
 */
function toggle() {
  var newIndex = currentModeIndex + 1;
  if (newIndex > gridModes.length - 1) {
    newIndex = 0;
  }

  var mode = gridModes[newIndex];

  if (mode === 'off') {
    disable();
  } else {
    enable(mode);
  }
}

/**
 * Enable the grid overlay.
 *
 * @param {string} mode The grid mode to enable, 'column' or 'baseline'.
 */
function enable(mode) {
  if (!mode) {
    return;
  }

  if (gridModes[currentModeIndex] === mode) {
    return;
  }

  currentModeIndex = gridModes.indexOf(mode);

  if (overlayElement && overlayElement.parentNode) {
    overlayElement.parentNode.removeChild(overlayElement);
  }

  if (mode === 'baseline') {
    document.addEventListener('mousemove', onMouseMove, false);
  }

  overlayElement = createOverlayElement();

  document.body.appendChild(overlayElement);
}

/**
 * Disable the grid overlay.
 */
function disable() {
  if (gridModes[currentModeIndex] === 'off') {
    return;
  }

  if (overlayElement && overlayElement.parentNode) {
    overlayElement.parentNode.removeChild(overlayElement);
  }

  currentModeIndex = gridModes.indexOf('off');
  overlayElement = null;
  baselineHighlightElement = null;

  document.removeEventListener('mousemove', onMouseMove, false);
}

/**
 * Set the color used for each grid column or baseline line.
 *
 * @param {string} color Any valid CSS color.
 * @param {string=} highlightColor Any valid CSS color. Can be omitted for
 *     column grid.
 */
function setColor(color, highlightColor) {
  gridColor = color;
  highlightGridColor = highlightColor;
}

/**
 * Reset all state in this module.
 */
function reset() {
  overlayElement = null;
  baselineHighlightElement = null;
  gridColor = '';
  highlightGridColor = '';
  currentModeIndex = 0;
}

/**
 * Mouse move handler that highlights the hovered baseline line.
 *
 * @param {Event} event A mousemove event object.
 *
 * @private
 */
function onMouseMove(event) {
  if (!baselineHighlightElement) {
    baselineHighlightElement = document.createElement('div');
    baselineHighlightElement.className = 'grid-overlay-baseline-highlight';
    baselineHighlightElement.style.backgroundColor = highlightGridColor || DEFAULT_GRID_COLOR_HIGHLIGHT;
    overlayElement.appendChild(baselineHighlightElement);
  }

  // Calculate the Y position for the baseline line closest to the pointer
  var pointerPos = event.clientY + window.scrollY;
  var yLineAbove = Math.floor(pointerPos / GRID_BASELINE) * GRID_BASELINE;
  var y = yLineAbove + (pointerPos % GRID_BASELINE > 4 ? GRID_BASELINE : 0);

  baselineHighlightElement.style.top = y - 1 + 'px';
}

/**
 * Create the DOM nodes needed for the overlay, with the correct class names
 * and styles.
 *
 * @return {HTMLElement} The container element for the overlay.
 *
 * @private
 */
function createOverlayElement() {
  var color = gridColor || DEFAULT_GRID_COLOR;

  var container = document.createElement('div');
  container.className = 'grid-overlay container';

  if (gridModes[currentModeIndex] === 'column') {
    var row = document.createElement('div');
    row.className = 'grid-overlay-row row';
    container.appendChild(row);

    var sizeLabel = createSizeLabel();
    container.appendChild(sizeLabel);

    var columnClassNames = 'col-xs-1 col-sm-1 col-md-1 col-lg-1';

    for (var i = 0; i < 12; i++) {
      var column = document.createElement('div');
      column.className = 'grid-overlay-col-' + (i + 1) + ' ' + columnClassNames;

      column.style.backgroundColor = color;

      row.appendChild(column);
    }
  } else if (gridModes[currentModeIndex] === 'baseline') {
    container.classList.add('grid-overlay-baseline');

    var baselinePercentage = (GRID_BASELINE - 1) / GRID_BASELINE * 100 + '%';

    var backgroundImage = ['linear-gradient(', 'to bottom, ', 'transparent, ', 'transparent ' + baselinePercentage + ', ', color + ' ' + baselinePercentage, ')'].join('');

    container.style.backgroundImage = backgroundImage;

    // Because JSDOM is using the package 'cssstyle', which is stupid and
    // doesn't support gradients as values...
    container.style._backgroundImage = backgroundImage;
  }

  return container;
}

/**
 * Create the DOM nodes needed for the grid size label.
 *
 * @return {HTMLElement} A DOM node.
 *
 * @private
 */
function createSizeLabel() {
  var sizes = [{ name: 'Extra Small', id: 'xs' }, { name: 'Small', id: 'sm' }, { name: 'Medium', id: 'md' }, { name: 'Large', id: 'lg' }];

  var labelContainer = document.createElement('div');
  labelContainer.className = 'grid-overlay-label';

  sizes.forEach(function (size) {
    var label = document.createElement('span');
    label.className = 'visible-' + size.id;
    label.textContent = size.name;
    labelContainer.appendChild(label);
  });

  return labelContainer;
}

exports.listen = listen;
exports.toggle = toggle;
exports.enable = enable;
exports.disable = disable;
exports.setColor = setColor;
exports.reset = reset;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"spotify-cosmos-api":694}],350:[function(require,module,exports){
'use strict';

// This should be removed later when nothing is calling this method

exports.getVersion = function () {
  return 1;
};

},{}],351:[function(require,module,exports){
'use strict';

module.exports = {
  'de': require('../i18n/de.lang'),
  'el': require('../i18n/el.lang'),
  'en': require('../i18n/en.lang'),
  'es': require('../i18n/es.lang'),
  'es-419': require('../i18n/es-419.lang'),
  'fi': require('../i18n/fi.lang'),
  'fr': require('../i18n/fr.lang'),
  'fr-CA': require('../i18n/fr-CA.lang'),
  'hu': require('../i18n/hu.lang'),
  'id': require('../i18n/id.lang'),
  'it': require('../i18n/it.lang'),
  'ja': require('../i18n/ja.lang'),
  'nl': require('../i18n/nl.lang'),
  'pl': require('../i18n/pl.lang'),
  'pt-BR': require('../i18n/pt-BR.lang'),
  'sv': require('../i18n/sv.lang'),
  'tr': require('../i18n/tr.lang'),
  'zh-Hant': require('../i18n/zh-Hant.lang'),
  'zsm': require('../i18n/zsm.lang')
};

},{"../i18n/de.lang":329,"../i18n/el.lang":330,"../i18n/en.lang":331,"../i18n/es-419.lang":332,"../i18n/es.lang":333,"../i18n/fi.lang":334,"../i18n/fr-CA.lang":335,"../i18n/fr.lang":336,"../i18n/hu.lang":337,"../i18n/id.lang":338,"../i18n/it.lang":339,"../i18n/ja.lang":340,"../i18n/nl.lang":341,"../i18n/pl.lang":342,"../i18n/pt-BR.lang":343,"../i18n/sv.lang":344,"../i18n/tr.lang":345,"../i18n/zh-Hant.lang":346,"../i18n/zsm.lang":347}],352:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};
  var buffer = "", stack1, helper, functionType="function", escapeExpression=this.escapeExpression, self=this;

function program1(depth0,data) {

  var buffer = "", stack1, helper;
  buffer += "\n  <a href=\"";
  if (helper = helpers.url) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.url); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-log-click=\"";
  if (helper = helpers.id) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.id); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\">";
  if (helper = helpers.name) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.name); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</a>\n  ";
  return buffer;
  }

function program3(depth0,data) {

  var buffer = "", stack1;
  buffer += " ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.id), {hash:{},inverse:self.program(6, program6, data),fn:self.program(4, program4, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += " ";
  return buffer;
  }
function program4(depth0,data) {

  var buffer = "", stack1, helper;
  buffer += "\n  <a data-log-click=\"";
  if (helper = helpers.id) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.id); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\">";
  if (helper = helpers.name) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.name); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</a>\n  ";
  return buffer;
  }

function program6(depth0,data) {

  var buffer = "", stack1, helper;
  buffer += "\n  <p class=\"navbar-text\">";
  if (helper = helpers.name) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.name); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "</p>\n  ";
  return buffer;
  }

  buffer += "<li class=\"";
  if (helper = helpers.className) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.className); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" data-navbar-item-id=\"";
  if (helper = helpers.id) { stack1 = helper.call(depth0, {hash:{},data:data}); }
  else { helper = (depth0 && depth0.id); stack1 = typeof helper === functionType ? helper.call(depth0, {hash:{},data:data}) : helper; }
  buffer += escapeExpression(stack1)
    + "\" role=\"menuitem\" data-menu-item>\n  ";
  stack1 = helpers['if'].call(depth0, (depth0 && depth0.url), {hash:{},inverse:self.program(3, program3, data),fn:self.program(1, program1, data),data:data});
  if(stack1 || stack1 === 0) { buffer += stack1; }
  buffer += "\n</li>";
  return buffer;
  });

},{"hbsfy/runtime":563}],353:[function(require,module,exports){
'use strict';

// Usage
// Data {{#compare 'myvalue' value}}has{{else}}doesn't have{{/compare}} myvalue.
// Data {{#compare '5' tracks.length true}}has{{else}}doesn't have{{/compare}} 5 tracks.
// Data {{#compare tracks.length 5 operator='>'}}has more than{{else}}has less than or equal to{{/compare}} 5 tracks.

var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var operators = {
  '==': function _(a, b) {
    /* eslint eqeqeq: 0 */return a == b;
  },
  '===': function _(a, b) {
    return a === b;
  },
  '!=': function _(a, b) {
    /* eslint eqeqeq: 0 */return a != b;
  },
  '<': function _(a, b) {
    return a < b;
  },
  '>': function _(a, b) {
    return a > b;
  },
  '<=': function _(a, b) {
    return a <= b;
  },
  '>=': function _(a, b) {
    return a >= b;
  },
  'typeof': function _typeof(a, b) {
    return (typeof a === 'undefined' ? 'undefined' : _typeof2(a)) == b;
  }
};

function compare(a, b, s) {
  var options = arguments[arguments.length - 1];
  var soft = s !== options ? s : false;
  var operator = soft ? '==' : options.hash.operator || '===';

  var match = operators[operator](a, b);

  return match ? options.fn(this) : options.inverse(this);
}

compare.displayName = 'compare';

module.exports = compare;

},{}],354:[function(require,module,exports){
'use strict';

var duration = function duration(ms) {
  if (isNaN(ms)) return ms;

  var s = Math.round(ms / 1000);
  var oneMinute = 60;
  var oneHour = 60 * oneMinute;

  var hours = Math.floor(s / oneHour);
  var minutes = Math.floor(s % oneHour / oneMinute);
  var seconds = Math.round(s % oneHour % oneMinute);

  // Include hours if needed
  if (hours) {
    hours += ':';

    // If hours are specified, minutes should always be with two digits
    if (minutes < 10) minutes = '0' + minutes;
  } else {
    hours = '';
  }

  // Since minutes should always be displayed, seconds should always be with two digits
  if (seconds < 10) seconds = '0' + seconds;

  return hours + minutes + ':' + seconds;
};

duration.displayName = 'duration';

module.exports = duration;

},{}],355:[function(require,module,exports){
'use strict';

var nameListTooltip = require('./name-list-tooltip');

var facepile = function facepile(list, totalCount, mT, opts) {
  var options = opts;
  var minThresh = mT;

  if (!list) {
    return '';
  }

  if (arguments.length < 4) {
    options = minThresh;
    minThresh = 3;
  }

  minThresh = minThresh || 3;

  var len = list.length;
  var thresh = Math.min(minThresh, len);
  var ret = '';

  // Display faces.
  for (var i = 0; i < thresh; i++) {
    var obj = list[i];
    obj.modifiers = 'media-object-link media-object-simple';
    ret += options.fn(obj);
  }

  // Display badge count for hidden listeners.
  if (totalCount > thresh) {
    ret += options.inverse({
      badgeCount: totalCount - thresh,
      badgeTooltip: nameListTooltip(list.slice(thresh), totalCount - thresh)
    });
  }
  return ret;
};

facepile.displayName = 'facepile';

module.exports = facepile;

},{"./name-list-tooltip":361}],356:[function(require,module,exports){
(function (global){
'use strict';

var getHTTPLink = require('../util/link');

var isDesktop = !!global._getSpotifyModule;

var href = function href(uri) {
  if (isDesktop) return uri;
  return getHTTPLink(uri, 'https://play.spotify.com');
};

href.displayName = 'href';

module.exports = href;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../util/link":368}],357:[function(require,module,exports){
'use strict';

var loc = require('./loc');

var humanizeDuration = function humanizeDuration(ms) {
  if (isNaN(ms)) return ms;

  var s = Math.round(ms / 1000);
  var oneMinute = 60;
  var oneHour = 60 * oneMinute;

  var hours = Math.floor(s / oneHour);
  var minutes = Math.floor(s % oneHour / oneMinute);
  var seconds = Math.round(s % oneHour % oneMinute);

  var formattedDuration = '';

  if (hours) {
    formattedDuration += loc('HoursShort', hours, {});
  }

  if (minutes) {
    formattedDuration += ' ';
    formattedDuration += loc('MinutesShort', minutes, {});
  }

  if (!hours && !minutes || hours === 0 && minutes < 10) {
    formattedDuration += ' ';
    formattedDuration += loc('SecondsShort', seconds, {});
  }

  return formattedDuration.trim();
};

humanizeDuration.displayName = 'humanizeDuration';

module.exports = humanizeDuration;

},{"./loc":360}],358:[function(require,module,exports){
'use strict';

exports.compare = require('./compare');
exports.duration = require('./duration');
exports.facepile = require('./facepile');
exports.href = require('./href');
exports.humanizeDuration = require('./humanize-duration');
exports.list = require('./list');
exports.loc = require('./loc');
exports.nameListTooltip = require('./name-list-tooltip');
exports.numeral = require('./numeral');
exports.share = require('./share');
exports.slice = require('./slice');
exports.type = require('./type');
exports.userReaction = require('./user-reaction');

},{"./compare":353,"./duration":354,"./facepile":355,"./href":356,"./humanize-duration":357,"./list":359,"./loc":360,"./name-list-tooltip":361,"./numeral":362,"./share":363,"./slice":364,"./type":365,"./user-reaction":366}],359:[function(require,module,exports){
'use strict';

var map = require('mout/array/map');

var Handlebars = require('handlebars/dist/cjs/handlebars.runtime').default;

var lists = {};

var list = function list(array) {
  if (!array) {
    return '';
  }

  var args = Array.prototype.slice.call(arguments);
  var options = args.pop();
  var listID = args[1];

  if (array === 'reset') {
    delete lists[listID];
    return '';
  }

  if (listID && lists[listID] === undefined) {
    lists[listID] = -1;
  }

  return map(array, function (item, i) {
    var data = Handlebars.createFrame(options.data || {});
    data.index = listID ? ++lists[listID] : i;
    data.number = data.index + 1;
    data.localIndex = i;
    data.localNumber = i + 1;
    return options.fn(item, { data: data });
  }).join(options.hash && options.hash.join || '');
};

list.displayName = 'list';

module.exports = list;

},{"handlebars/dist/cjs/handlebars.runtime":556,"mout/array/map":635}],360:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var mixIn = require('mout/object/mixIn');
var slice_ = Array.prototype.slice;

var storage = {};

var loc = function loc(key) {
  var value = storage[key];

  if (!value) return '';

  var args = slice_.call(arguments, 1);
  var options = {};

  if (_typeof(args[args.length - 1]) === 'object') {
    options = args.pop();
  }

  var hash = options.hash;

  return value.replace(/\{([\w-]+)\}/g, function (full, match) {
    var n = +match;
    var interpolated;

    if (isNaN(n)) {
      interpolated = hash[match];
    } else {
      interpolated = args[n];
    }

    return interpolated !== null ? interpolated : '';
  });
};

loc.displayName = 'loc';

loc.register = function (object) {
  mixIn(storage, object);
  return this;
};

module.exports = loc;

},{"mout/object/mixIn":667}],361:[function(require,module,exports){
'use strict';

var loc = require('./loc');

var nameListTooltip = function nameListTooltip(users, totalCount) {
  if (totalCount === 0) {
    return undefined;
  }

  var len = users.length;
  var textTokens = users.map(function (user) {
    return user.name;
  });

  if (totalCount - len > 0) {
    var andMoreText = loc('AndMore', totalCount - len);
    textTokens.push(andMoreText);
  }

  return textTokens.join('<br>\n').replace(/'/g, '&#39;');
};

nameListTooltip.displayName = 'nameListTooltip';

module.exports = nameListTooltip;

},{"./loc":360}],362:[function(require,module,exports){
'use strict';

var isNumber = require('mout/lang/isNumber');

/**
 * If the first argument is a number, pipe it through spotify-numeral with an
 * optional format propety in the options hash, otherwise return it untouched.
 *
 * Example usage – results when using fr locale:
 *
 * {{numeral 1000}} -> '1 000'
 * {{numeral 1000 format='0,0.000'}} -> '1 000,000'
 * {{numeral 1000 format='$0,0.00'}} -> '€1 000,00'
 *
 * @param {Number|String} number - The number to format (or string to leave
 *     untouched).
 * @param {Object} [options] - The handlebars options object.
 * @param {Object} [options.hash] - The handlebars options hash object.
 * @param {String} [options.hash.format] - The optional format to pass to
 *     numeraljs.
 * @return {String} The formatted (or untouched) string.
 */
var numeralHelper = function numeralHelper(number, options) {
  var format = options && options.hash && options.hash.format;
  var numeral = numeralHelper._numeral;
  return isNumber(number) ? numeral(number).format(format) : number;
};

numeralHelper.displayName = 'numeral';

module.exports = numeralHelper;

// This is tricky, but is a way to allow for the locale to be injected
// from the consuming app instead of from within spotify-numeral, removing
// the dependency on spotify-quickstart.
module.exports.setLocale = function (locale) {
  numeralHelper._numeral = require('../../spotify-numeral')(locale);
};

},{"../../spotify-numeral":466,"mout/lang/isNumber":650}],363:[function(require,module,exports){
'use strict';

var getHTTPLink = require('../util/link');

var share = function share(uri) {
  return getHTTPLink(uri, 'https://open.spotify.com');
};

share.displayName = 'share';

module.exports = share;

},{"../util/link":368}],364:[function(require,module,exports){
'use strict';

var kindOf = require('mout/lang/kindOf');
var map = require('mout/array/map');
var forEach = require('mout/array/forEach');

var Handlebars = require('handlebars/dist/cjs/handlebars.runtime').default;
var slice_ = Array.prototype.slice;

var slice = function slice(arr) {
  var array = arr;

  if (!array) {
    return '';
  }

  var sep;
  var begin;
  var end;
  var options;

  forEach(slice_.call(arguments, 1), function (arg) {
    switch (kindOf(arg)) {
      case 'String':
        sep = arg;
        break;

      case 'Number':
        if (begin === null) {
          begin = arg;
        } else if (end === null) {
          end = arg;
        }
        break;

      case 'Object':
        options = arg;
        break;

      default:
      // Do nothing.
    }
  });

  if (begin !== null) {
    array = array.slice(begin, end !== null ? end : array.length);
  }

  return map(array, function (item) {
    var data = Handlebars.createFrame(options.data || {});

    return options.fn(item, { data: data });
  }).join(sep || '');
};

slice.displayName = 'slice';

module.exports = slice;

},{"handlebars/dist/cjs/handlebars.runtime":556,"mout/array/forEach":632,"mout/array/map":635,"mout/lang/kindOf":655}],365:[function(require,module,exports){
'use strict';

var getType = require('../util/type');

// This needs at least the uri param to get the type:
// {{type uri}}
//
// If you pass more parameters you can use it like a matcher:
// {{#type uri "track" "album"}}YAY{{/type}}
// This will print 'YAY' for tracks or albums.

var type = function type(uri) {
  if (arguments.length <= 2) {
    // Simple get type.
    return getType(uri);
  }

  // Match type.
  var context = arguments[arguments.length - 1];
  var success = false;
  var uriType = getType(uri);

  for (var i = 1; i < arguments.length - 1; i++) {
    if (uriType === arguments[i]) {
      success = true;
      break;
    }
  }

  return success ? context.fn(this) : context.inverse(this);
};

type.displayName = 'type';

module.exports = type;

},{"../util/type":369}],366:[function(require,module,exports){
'use strict';

var loc = require('./loc');

var userReaction = function userReaction(users, totalCount, reactionType) {
  if (!totalCount) return '';
  var key = reactionType + 'Reaction' + (totalCount > 1 ? 'Multi' : 'Single');

  if (totalCount > 1) {
    return loc(key, totalCount);
  }

  if (!users.length) {
    return '';
  }

  var firstListener = users[0].name;
  return loc(key, firstListener);
};

userReaction.displayName = 'userReaction';

module.exports = userReaction;

},{"./loc":360}],367:[function(require,module,exports){
'use strict';

var kindOf = require('mout/lang/kindOf');

var Handlebars = require('handlebars/dist/cjs/handlebars.runtime').default;

// Expose the runtime to make partials easier to register.
exports.runtime = Handlebars;

exports.register = function (helpers) {
  var list = {};

  if (kindOf(helpers) === 'Function') {
    list[helpers.displayName] = helpers;
  } else {
    list = helpers;
  }

  for (var key in list) {
    if (list.hasOwnProperty(key)) {
      Handlebars.registerHelper(key, list[key]);
    }
  }

  return this;
};

},{"handlebars/dist/cjs/handlebars.runtime":556,"mout/lang/kindOf":655}],368:[function(require,module,exports){
'use strict';

module.exports = function (uri, base) {
  var matches = (uri || '').match(/^spotify:(.+)$/);

  if (!matches) {
    return uri || '';
  }

  var parts = matches.pop().replace(/:$/, '').split(/:/);
  var type = parts.shift();

  if (type === 'search') {
    parts = [parts.join(':')];
  }

  parts.unshift(base, type);

  return parts.join('/');
};

},{}],369:[function(require,module,exports){
'use strict';

module.exports = function (uri) {
  if (!uri || !uri.split) {
    return null;
  }
  var parts = uri.split(':');
  var result = null;
  switch (parts[1]) {
    case 'album':
      // spotify:album:<id>:<disc>
      if (parts.length === 4) {
        return 'disc';
      } else if (parts.length === 3) {
        return 'album';
      }
      break;

    case 'artist':
      if (parts.length === 3) {
        return 'artist';
      }
      break;

    case 'track':
      if (parts.length === 3) {
        return 'track';
      }
      break;

    case 'genre':
      if (parts.length === 3) {
        return 'genre';
      }
      break;

    case 'station':
      if (parts.length > 3) {
        return 'station';
      }
      break;

    case 'local':
      if (parts.length === 6) {
        return 'track';
      } else if (parts.length === 4) {
        return 'album';
      } else if (parts.length === 3) {
        return 'artist';
      }
      break;

    case 'user':
      // spotify:user:<username>:collection
      if (parts.length > 3 && parts[3] === 'collection') {
        return 'collection';
      }

      // spotify:user:<username>:folder:<id>
      if (parts.length === 5 && parts[3] === 'folder') {
        return 'playlist-folder';
      }

      // spotify:user:<username>:<playlist:<id>|starred|toplist>
      if (parts.length > 3 && parts.length <= 5 && parts[2] !== 'facebook') {
        return 'playlist';
      } else if (parts.length === 3) {
        return 'user';
      }
      break;

    case 'internal':
      // spotify:internal:local-files
      return parts[2];

    case 'app':
      // spotify:app:collection:albums, spotify:app:radio
      return parts.slice(1).join('-');

    default:
    // Do nothing.
  }

  return result;
};

},{}],370:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var Translations = require('../spotify-translations');
var glueLocales = require('../spotify-glue-cat/strings');

module.exports = function (localeToStrings) {
  if (!localeToStrings || (typeof localeToStrings === 'undefined' ? 'undefined' : _typeof(localeToStrings)) !== 'object') {
    throw new Error('' + 'Locale strings must be a plain object. ' + 'See spotify-i18n/README.md');
  }

  function getClientLocale() {
    return typeof window !== 'undefined' && window.__spotify && window.__spotify.locale || 'en';
  }

  var locales = localeToStrings;
  var i18n = new Translations();
  i18n.injectData(locales[getClientLocale()] || {});

  return {
    locale: getClientLocale,
    get: i18n.get.bind(i18n),

    glueStrings: function glueStrings() {
      return glueLocales[getClientLocale()];
    },

    appStrings: function appStrings() {
      return locales[getClientLocale()];
    }
  };
};

},{"../spotify-glue-cat/strings":351,"../spotify-translations":492}],371:[function(require,module,exports){
'use strict';

var base = 'spotify:internal:filterlist';
var regExp = /^spotify:internal:filterlist:([^:]*):(.*)$/;

/**
 * Create a URI representing a filtered variant of a list.
 *
 * @param {string} originUri The original list URI.
 * @param {string} query The query string (compatible with Core). Filter
 *     implementations might not look at all values.
 *
 * @return {string} URI of the filtered variant of the list. The URI will have
 *     the query string URL encoded.
 */
exports.create = function (originUri, query) {
  originUri = originUri.replace(/^spotify:/, '');

  query = encodeURIComponent(query);

  return [base, query, originUri].join(':');
};

/**
 * Get the query string from a filter URI.
 *
 * @param {string} filterUri The URI of the filtered list.
 *
 * @return {string} The query string, URL decoded. If URI is
 *     invalid, this returns an empty string.
 */
exports.getQuery = function (filterUri) {
  var matches = filterUri.match(regExp);
  if (!matches) return '';

  return decodeURIComponent(matches[1]);
};

/**
 * Get the URI of the original list.
 *
 * @param {string} filterUri The URI of the filtered list.
 *
 * @return {string} The URI of the original list. If the filter URI is invalid,
 *     this returns an empty string.
 */
exports.getOriginUri = function (filterUri) {
  var matches = filterUri.match(regExp);
  if (!matches) return '';

  return 'spotify:' + matches[2];
};

/**
 * Parse and return all parts of the filter URI.
 *
 * @param {string} filterUri The URI of the filtered list.
 *
 * @return {Object?} An object with properties `direction`, `query` and `originUri`,
 *     or null if the URI is not valid.
 */
exports.parse = function (filterUri) {
  var matches = filterUri.match(regExp);
  if (!matches) return null;

  return {
    query: decodeURIComponent(matches[1]),
    originUri: 'spotify:' + matches[2]
  };
};

/**
 * Test if the provided URI is a valid filter URI.
 *
 * @param {string} filterUri The URI of the filtered list.
 *
 * @return {boolean} True if it's valid, false otherwise.
 */
exports.isValid = function (filterUri) {
  return regExp.test(filterUri);
};

/**
 * The regular expression that matches filter URIs.
 */
exports.regExp = regExp;

},{}],372:[function(require,module,exports){
module.exports = {
  "playlist_name_for_tracks.default_name": "Neue Playlist"
};
},{}],373:[function(require,module,exports){
module.exports = {
  "playlist_name_for_tracks.default_name": "Νέα λίστα"
};
},{}],374:[function(require,module,exports){
module.exports = {
  "playlist_name_for_tracks.default_name": "New Playlist"
};
},{}],375:[function(require,module,exports){
module.exports = {
  "playlist_name_for_tracks.default_name": "Nueva playlist"
};
},{}],376:[function(require,module,exports){
module.exports = {
  "playlist_name_for_tracks.default_name": "Nueva Lista"
};
},{}],377:[function(require,module,exports){
module.exports = {
  "playlist_name_for_tracks.default_name": "Uusi soittolista"
};
},{}],378:[function(require,module,exports){
module.exports = {
  "playlist_name_for_tracks.default_name": "Nouvelle playlist"
};
},{}],379:[function(require,module,exports){
module.exports = {
  "playlist_name_for_tracks.default_name": "Créer une playlist"
};
},{}],380:[function(require,module,exports){
module.exports = {
  "playlist_name_for_tracks.default_name": "Új lejátszási lista"
};
},{}],381:[function(require,module,exports){
module.exports = {
  "playlist_name_for_tracks.default_name": "Playlist Baru"
};
},{}],382:[function(require,module,exports){
'use strict';

// This file will likely become a generated file in the future. Please
// avoid adding extra APIs or exports here.

var i18n = require('../../spotify-i18n')({
  'de': require('./de.lang'),
  'el': require('./el.lang'),
  'en': require('./en.lang'),
  'es': require('./es.lang'),
  'es-419': require('./es-419.lang'),
  'fi': require('./fi.lang'),
  'fr': require('./fr.lang'),
  'fr-CA': require('./fr-CA.lang'),
  'hu': require('./hu.lang'),
  'id': require('./id.lang'),
  'it': require('./it.lang'),
  'ja': require('./ja.lang'),
  'nl': require('./nl.lang'),
  'pl': require('./pl.lang'),
  'pt-BR': require('./pt-BR.lang'),
  'sv': require('./sv.lang'),
  'tr': require('./tr.lang'),
  'zh-Hant': require('./zh-Hant.lang'),
  'zsm': require('./zsm.lang')
});

module.exports = i18n;

},{"../../spotify-i18n":370,"./de.lang":372,"./el.lang":373,"./en.lang":374,"./es-419.lang":375,"./es.lang":376,"./fi.lang":377,"./fr-CA.lang":378,"./fr.lang":379,"./hu.lang":380,"./id.lang":381,"./it.lang":383,"./ja.lang":384,"./nl.lang":385,"./pl.lang":386,"./pt-BR.lang":387,"./sv.lang":388,"./tr.lang":389,"./zh-Hant.lang":390,"./zsm.lang":391}],383:[function(require,module,exports){
module.exports = {
  "playlist_name_for_tracks.default_name": "Nuova playlist"
};
},{}],384:[function(require,module,exports){
module.exports = {
  "playlist_name_for_tracks.default_name": "新規プレイリスト"
};
},{}],385:[function(require,module,exports){
module.exports = {
  "playlist_name_for_tracks.default_name": "Nieuwe afspeellijst"
};
},{}],386:[function(require,module,exports){
module.exports = {
  "playlist_name_for_tracks.default_name": "Nowa playlista"
};
},{}],387:[function(require,module,exports){
module.exports = {
  "playlist_name_for_tracks.default_name": "Nova playlist"
};
},{}],388:[function(require,module,exports){
module.exports = {
  "playlist_name_for_tracks.default_name": "Ny spellista"
};
},{}],389:[function(require,module,exports){
module.exports = {
  "playlist_name_for_tracks.default_name": "Yeni Çalma Listesi"
};
},{}],390:[function(require,module,exports){
module.exports = {
  "playlist_name_for_tracks.default_name": "新播放列表"
};
},{}],391:[function(require,module,exports){
module.exports = {
  "playlist_name_for_tracks.default_name": "Playlist Main Baru"
};
},{}],392:[function(require,module,exports){
'use strict';

var live = require('../spotify-live');
var liburi = require('spotify-liburi');

var getPlaylistNameFor = exports;

var MAX_ITEMS = 100;
var MAX_PLAYLISTS = 100;
var GET_PLAYLIST_NAME_TIMEOUT = 100;

function getUri(uri) {
  return uri.toURI ? uri.toURI() : uri;
}

function hasSameAlbum(albumUri, tracks) {
  return tracks.every(function (track) {
    return track.album.uri === albumUri;
  });
}

function hasSameArtist(artistUri, tracks) {
  return tracks.every(function (track) {
    return track.artists.some(function (artist) {
      return artist.uri === artistUri;
    });
  });
}

function findAvailableName(baseName, callback) {
  var rootlistModel = live('spotify:rootlist');
  if (!rootlistModel.get('implemented')) {
    return callback(null, baseName);
  }

  rootlistModel.get('rows', function (error, rowsList) {
    var end = Math.min(rowsList.length, MAX_PLAYLISTS);

    rootlistModel.query('rows[0:' + end + '](playlist(uri))', function (error, data) {
      if (error) return callback(null, baseName);

      Promise.all(data.rows.filter(function (row) {
        return liburi.from(row.playlist.uri).type === liburi.Type.PLAYLIST;
      }).map(function (row) {
        return new Promise(function (resolve, reject) {
          live(row.playlist.uri).query('name', function (error, data) {
            resolve(data && data.name || '');
          }, live.ASAP, GET_PLAYLIST_NAME_TIMEOUT);
        });
      })).then(function (existingNames) {
        var existingNamesMap = {};
        existingNames.forEach(function (name) {
          existingNamesMap[name] = true;
        });

        var name = baseName;
        var num = 2;

        while (name in existingNamesMap) {
          name = baseName + ' ' + num;
          num++;
        }
        callback(null, name);
      });
    }, live.ASAP);
  }, live.ASAP);
}

function getDefaultPlaylistName(callback) {
  var strings = require('./i18n');

  var defaultPlaylistName = strings.get('playlist_name_for_tracks.default_name');

  getPlaylistNameFor._findAvailable(defaultPlaylistName, callback);
}

function getPlaylistNameForAlbum(albumUri, callback) {
  live(getUri(albumUri)).query('name, artists[0](name)', function (error, album) {
    if (error) return callback(error);

    var artistName = album.artists[0].name;
    var name;
    if (artistName && album.name) {
      name = artistName + ' – ' + album.name;
    } else if (artistName) {
      name = artistName;
    } else if (album.name) {
      name = album.name;
    }

    if (name) {
      getPlaylistNameFor._findAvailable(name, callback);
    } else {
      getPlaylistNameFor.defaultPlaylist(callback);
    }
  }, live.ASAP);
}

function getPlaylistNameForArtist(artistUri, callback) {
  live(getUri(artistUri)).get('name', function (error, name) {
    if (error) return callback(error);
    if (name) {
      getPlaylistNameFor._findAvailable(name, callback);
    } else {
      getPlaylistNameFor.defaultPlaylist(callback);
    }
  }, live.ASAP);
}

function getPlaylistNameForPlaylist(playlistUri, callback) {
  live(getUri(playlistUri)).get('name', function (error, name) {
    if (error) return callback(error);
    if (name) {
      getPlaylistNameFor._findAvailable(name, callback);
    } else {
      getPlaylistNameFor.defaultPlaylist(callback);
    }
  }, live.ASAP);
}

function getPlaylistNameForTracks(trackUris, callback) {
  var uris = trackUris.slice(0, MAX_ITEMS).map(function (trackUri) {
    return live(getUri(trackUri));
  });

  if (uris.length === 1) {
    getPlaylistNameFor._track(uris[0], callback);
    return;
  }

  live(uris).query('album(uri), artists(uri)', function (error, tracks) {
    var albumUri = tracks[0].album.uri;
    var artistUri = tracks[0].artists[0].uri;

    if (hasSameAlbum(albumUri, tracks)) {
      getPlaylistNameFor.album(albumUri, callback);
    } else if (hasSameArtist(artistUri, tracks)) {
      getPlaylistNameFor._artist(artistUri, callback);
    } else {
      getPlaylistNameFor.defaultPlaylist(callback);
    }
  }, live.ASAP);
}

function getPlaylistNameForTrack(trackUri, callback) {
  live(trackUri).query('name, artists[0](name)', function (error, track) {
    var artistName = track.artists[0] && track.artists[0].name;
    var trackName = track.name;

    var name;
    if (artistName && trackName) {
      name = trackName + ' – ' + artistName;
    } else if (artistName) {
      name = artistName;
    } else if (trackName) {
      name = trackName;
    }
    if (name) {
      getPlaylistNameFor._findAvailable(name, callback);
    } else {
      getPlaylistNameFor.defaultPlaylist(callback);
    }
  }, live.ASAP);
}

function getPlaylistNameForItems(uris, callback) {
  var typesMap = {};
  uris.slice(0, MAX_ITEMS).forEach(function (item) {
    var uriObject = liburi.from(item);
    typesMap[uriObject && uriObject.type] = true;
  });

  var types = Object.keys(typesMap);
  if (types.length === 1) {
    switch (types[0]) {
      case liburi.Type.TRACK:
      case liburi.Type.LOCAL:
        getPlaylistNameFor.tracks(uris, callback);
        break;

      case liburi.Type.ALBUM:
      case liburi.Type.LOCAL_ALBUM:
        getPlaylistNameFor.album(uris[0], callback);
        break;

      case liburi.Type.ARTIST:
      case liburi.Type.LOCAL_ARTIST:
        getPlaylistNameFor._artist(uris[0], callback);
        break;

      case liburi.Type.PLAYLIST:
        getPlaylistNameFor.playlist(uris[0], callback);
        break;

      default:
        getPlaylistNameFor.defaultPlaylist(callback);
        break;
    }
  } else {
    getPlaylistNameFor.defaultPlaylist(callback);
  }
}

getPlaylistNameFor.items = getPlaylistNameForItems;
getPlaylistNameFor._track = getPlaylistNameForTrack;
getPlaylistNameFor.tracks = getPlaylistNameForTracks;
getPlaylistNameFor.album = getPlaylistNameForAlbum;
getPlaylistNameFor._artist = getPlaylistNameForArtist;
getPlaylistNameFor.playlist = getPlaylistNameForPlaylist;
getPlaylistNameFor.defaultPlaylist = getDefaultPlaylistName;
getPlaylistNameFor._findAvailable = findAvailableName;

},{"../spotify-live":439,"./i18n":382,"spotify-liburi":707}],393:[function(require,module,exports){
(function (global){
'use strict';

var live = require('../../spotify-live');
var cosmos = require('../util/cosmos');
var Collection = require('./collection');

var endpoints = {
  isInCollection: 'sp://core-collection/v1/contains',
  updateIsInCollection: 'sp://core-collection/v1/items',
  changes: 'hm://collection-web/v1/@/changes',
  broadcast: 'sp://messages/v1/collectionstate',
  pubsub: 'hm://collection/collection/@/json'
};

var onCollectionPublish = function onCollectionPublish(error, response) {
  if (error) {
    if (global.console) console.error(error);
    return;
  }

  // Currently, we only store tracks in collection2, and derive albums from
  // these. Because of this, we only get tracks in the pubsub events, but
  // adding/removing a track might have altered the calculated Collection state
  // of its album. To check this, we pass the change set down to
  // the changes endpoint and will receive a list of objects with
  // uri and isInCollection properties that we can forward to live.
  cosmos.sanitizeURL(endpoints.changes, function (error, url) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }

    // FIXME: Hack alert
    // Because of enum weirdness in Java, we need to
    // uppercase the value in the type field.
    // Remove this map once FESK-1921 is fixed.
    response.body.items = response.body.items.map(function (item) {
      item.type = item.type.toUpperCase();
      return item;
    });
    // End hack alert

    cosmos.post({ url: url, body: response.body }, function (error, response) {
      if (error) {
        if (global.console) console.error(error);
        return;
      }
      response.body.items.forEach(function (item) {
        if (item.hasOwnProperty('isInCollection') && !item.hasOwnProperty('added')) {
          // Patch items to contain added
          item.added = item.isInCollection;
        }
      });
      live(response.body.items);
    });
  });
};

var albumCollection;
var broadcastSubscription;
var collectionSubscription;

var regExp = exports.matches = /^spotify:album:[^:]+$/;
var registered = false;
exports.register = function () {
  if (registered) return;
  registered = true;

  albumCollection = new Collection(endpoints);

  live.subscribe(regExp, 'publish', albumCollection.onPublish);
  live.subscribe(regExp, 'wait', albumCollection.onWait);

  broadcastSubscription = cosmos.subscribe({ url: endpoints.broadcast }, Collection.onBroadcast);
  collectionSubscription = cosmos.subscribe({ url: endpoints.pubsub }, onCollectionPublish);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  live.unsubscribe(regExp, 'publish', albumCollection.onPublish);
  live.unsubscribe(regExp, 'wait', albumCollection.onWait);

  albumCollection = null;

  if (broadcastSubscription) {
    broadcastSubscription.cancel();
    broadcastSubscription = null;
  }

  if (collectionSubscription) {
    collectionSubscription.cancel();
    collectionSubscription = null;
  }
};

exports._endpoints = endpoints;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../spotify-live":439,"../util/cosmos":435,"./collection":395}],394:[function(require,module,exports){
'use strict';

var profile = require('./profile');

var regExp = exports.matches = /^spotify:artist:/;
var registered;
exports.register = function () {
  if (registered) return;
  registered = true;

  profile.register(regExp);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  profile.unregister(regExp);
};

},{"./profile":397}],395:[function(require,module,exports){
(function (global){
'use strict';

// This model will take a URI and create a live model for that URI.
//
//
// It will listen for publish events on the live model. The publish
// events are only triggered when someone actually wants to update
// something on the backend.
// When a publish event is detected, it will:
//
// * If the changed property was "added", it will contact
//   the backend to update the stored collection state. If this
//   fails, it will set it to the opposite of what was pusblished.
//
// * On success, broadcast the changes to the rest of the client via
//   cosmos, as "isInCollection" / "isFollowing" and as "added".
//
// This model will also listen for update events on the live model.
// The update event will be triggered when someone changes the data
// on the live model, without an intention to update the backend.
// When an update event is detected, it will:
//
// This model will also listen for broadcast events from the rest
// of the client. When a broadcast event is received, this happens:
//
// * If the URI for the broadcast message does not match this model,
//   do nothing.
//
// * It will then update the live model with the data it received
//   from the broadcast event. This will trigger the update listener
//   described above, but it won't run the code because all properties
//   are there.

var prime = require('prime');
var defer = require('prime/defer');

var live = require('../../spotify-live');
var contains = require('mout/array/contains');

var cosmos = require('../util/cosmos');

var INSUFFICIENT_STORAGE = 507;

// COLLECTION

var Collection = prime({

  constructor: function constructor(endpoints) {
    var self = this;
    this.endpoints = endpoints;
    this.onPublish = this.onPublish.bind(this);
    this.waitQueue = [];
    this.onWait = this.onWait.bind(this);
    this.fetch = this.fetch.bind(this);
  },

  onPublish: function onPublish(model, data) {
    // If the property is "added", update the backend with the new value
    // If the update fails, revert the state
    // If the update does not fail, broadcast the new state, as "isInCollection" and "added"
    if ('added' in data) {

      var endpoints = this.endpoints;
      var state = !!data.added;

      // optimistic
      model.update({ added: state });

      var method = state ? 'post' : 'delete';
      this._publish(method, [model], function (error, data) {
        if (error) {
          // that's what being optimistic gets you
          model.update({ added: !state });
          if (error.response && error.response.getStatusCode() === INSUFFICIENT_STORAGE) {
            cosmos.post({
              url: 'sp://messages/v1/container/user-message',
              body: { id: 'collection-limit-exceeded' }
            });
          }
        } else {
          cosmos.post({ url: endpoints.broadcast, body: { uri: model.uri, isInCollection: state, added: state } });
          if (data && data.items) {
            data.items.forEach(function (item) {
              // Patch items to contain added
              item.added = item.isInCollection;
              cosmos.post({ url: endpoints.broadcast, body: item });
            });
          }
        }
      });
    }
  },

  onWait: function onWait(model, properties) {
    if (contains(properties, 'added')) {
      this.fetch(model);
    }
  },

  fetch: function fetch(model) {
    var endpoints = this.endpoints;
    var queue = this.waitQueue;

    queue.push(model);

    // The first thing that gets added to the queue should defer a batch fetch
    // for the next tick. On the next tick, it will batch fetch status for all
    // models added to the queue.
    if (queue.length === 1) {
      defer(this._fetchBatch, this);
    }
  },

  _fetchBatch: function _fetchBatch() {
    var queue = this.waitQueue;
    if (queue.length === 0) return;

    // Create a new queue for requests coming after this
    this.waitQueue = [];

    this._contains(queue, function (error, result) {
      // Collection returns 404 for a user without a collection. This is sent as an error,
      // but we will just interpret that as `isInCollection` is false. All other errors
      // we just throw.
      if (error && (!error.response || error.response && error.response.getStatusCode() !== 404)) {
        if (global.console) console.error(error);
        return;
      }

      queue.forEach(function (model, i) {
        var added = false;
        if (!error) added = result[i];
        model.update({ added: added });
      });
    });
  },

  _contains: function _contains(models, callback) {
    var url = this.endpoints.isInCollection;
    var body = this._getRequestBody(models);

    cosmos.post({ url: url, body: body }, function (error, result) {
      callback(error, result && result.body && result.body.found);
    });
  },

  _publish: function _publish(method, models, callback) {
    var url = this.endpoints.updateIsInCollection;
    var body = this._getRequestBody(models);

    cosmos[method]({ url: url, body: body }, function (error, result) {
      callback(error, result && result.body);
    });
  },

  _getRequestBody: function _getRequestBody(models) {
    return {
      items: models.map(function (model) {
        return model.uri;
      }),
      source: global.__spotify && global.__spotify.app_uri || null
    };
  }

});

// ----------------------

Collection.onBroadcast = function (error, response) {
  if (error) {
    if (global.console) console.error(error);
    return;
  }

  var value;
  if ('added' in response.body) value = response.body.added;
  // Deal with older versions of this package that send isInCollection / isFollowing
  else if ('isInCollection' in response.body) value = response.body.isInCollection;

  live(response.body.uri).update({
    added: value
  });
};

module.exports = Collection;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../spotify-live":439,"../util/cosmos":435,"mout/array/contains":625,"prime":678,"prime/defer":676}],396:[function(require,module,exports){
(function (global){
'use strict';

// The 'playlist' function will be called when a new live object is
// created for the pattern in playlist.matches. We use this function
// to automatically add data to the live model when requested, and to
// push any needed updates to the backend.
//
//
// It will listen for publish events on the live model. The publish
// events are only triggered when someone actually wants to update
// something on the backend.
// When a publish event is detected, it will:
//
// * Broadcast the changes to the rest of the client via cosmos.
//
// * If the changed property was `added`, it will contact
//   the backend to update the stored collection state for the
//   currently logged in user. If this fails, it will revert the
//   state for the live model and broadcast the reverted state.
//
// This function will also listen for update events on the live model.
// The update event will be triggered when someone changes the data
// on the live model, without an intention to update the backend.
// When an update event is detected, it will:
//
// This function will also listen for broadcast events from the rest
// of the client. When a broadcast event is received, this happens:
//
// * If the URI for the broadcast message does not match this model,
//   do nothing.
//
// * It will then update the live model with the data it received
//   from the broadcast event. This will trigger the update listener
//   described above, but it won't run the code because all properties
//   are there.

var contains = require('mout/array/contains');

var live = require('../../spotify-live');
var liburi = require('spotify-liburi');

var cosmos = require('../util/cosmos');
var bridge = require('../util/bridge').request;

var endpoints = {
  broadcast: 'sp://messages/v1/followstate'
};

function onPublish(model, data) {
  // If the property is "added", update the backend with the new
  // value. If the update fails somewhere along the way, revert the state
  // and broadcast the reverted state to the rest of the client.
  if ('added' in data) {
    model.update({ added: data.added });

    if (model.get('followersCount') != null) {
      model.update({
        followersCount: model.get('followersCount') + (data.added ? 1 : -1)
      });
    }

    updateBackend(model, !!data.added, function (error) {
      if (error) {
        // Revert optimistic change
        model.update({ added: !data.added });

        if (model.get('followersCount') != null) {
          model.update({
            followersCount: model.get('followersCount') + (!data.added ? 1 : -1)
          });
        }
      } else {
        broadcast(model);
      }
    });
  }
}

function onBroadcast(error, response) {
  if (error) {
    if (global.console) console.error(error);
    return;
  }
  var value;
  if ('added' in response.body) {
    value = response.body.added;
  } else if ('isFollowing' in response.body) {
    value = response.body.isFollowing;
  }

  if (value !== undefined) {
    live(response.body.uri).update({
      added: value
    });
  }
}

function fetchAdded(model) {
  cosmos.get({
    url: 'sp://core-playlist/v1/playlist/' + encodeURIComponent(model.uri) + '/metadata',
    body: {
      policy: {
        followed: true
      }
    }
  }, function (error, response) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }
    model.update({
      added: response.body.metadata.followed
    });
  });
}

function fetchFollowersCount(model) {
  bridge('playlist_subscribers_snapshot', [{ type: 'list', uri: model.uri }, 0, 0], function (error, data) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }
    model.update({
      followersCount: data.length
    });
  });
}

function getRequestData(callback) {
  // Assumes that the client live object either already has the data about the current user,
  // or that there is code included for getting this data on request.
  live('spotify:client').query('currentUser(username)', function (error, data) {
    if (error) return callback(error);

    callback(null, {
      username: data.currentUser.username
    });
  });
}

function broadcast(model) {
  var value = model.get('added');
  cosmos.post({
    url: endpoints.broadcast,
    body: {
      uri: model.uri,
      isFollowing: value,
      added: value
    }
  });
}

function updateBackend(model, added, callback) {
  if (added) {
    cosmos.post({
      url: 'sp://core-playlist/v1/rootlist',
      body: {
        operation: 'add',
        uris: [model.uri],
        before: 'start'
      }
    }, function (error, response) {
      if (error) return callback(error);
      model.update({
        added: true
      });
      callback(null);
    });
  } else {
    // Removing using Core needs the `rowId`, which we don't necessarily have,
    // so stick with old bridge message for now. It's only adding that needs to
    // be done using Core to fix KM-8804.
    bridge('library_unsubscribe', [liburi.profileURI(__spotify.username).toURI(), model.uri], function (error, data) {
      if (error) return callback(error, data);
      callback(null, data);
    });
  };
}

var onWait = function onWait(model, properties) {
  var needsAdded = contains(properties, 'added');
  var needsFollowersCount = contains(properties, 'followersCount');
  if (needsAdded) {
    var subscribed = model.get('subscribed');
    if (subscribed !== undefined) {
      model.update({ added: subscribed });
    } else {
      fetchAdded(model);
    }
  }
  if (needsFollowersCount) {
    fetchFollowersCount(model);
  }
};

var regExp = exports.matches = /^spotify:user:[^:]+:playlist:[^:]+$/;

var broadcastSubscription;
var registered;
exports.register = function () {
  if (registered) return;
  registered = true;

  live.subscribe(regExp, 'publish', onPublish);
  live.subscribe(regExp, 'wait', onWait);
  broadcastSubscription = cosmos.subscribe({ url: endpoints.broadcast }, onBroadcast);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  live.unsubscribe(regExp, 'publish', onPublish);
  live.unsubscribe(regExp, 'wait', onWait);

  broadcastSubscription.cancel();
  broadcastSubscription = null;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../spotify-live":439,"../util/bridge":433,"../util/cosmos":435,"mout/array/contains":625,"spotify-liburi":707}],397:[function(require,module,exports){
(function (global){
'use strict';

// This model will, when registered to live, listen for publish
// events on the live model. The publish events are only triggered
// when someone actually wants to update something on the backend.
// When a publish event is detected, it will:
//
// * Broadcast the changes to the rest of the client via cosmos.
//
// * If the changed property was isFollowing, it will contact
//   the backend to update the stored following state for the
//   currently logged in user. If this fails, it will revert the
//   state for the live model and broadcast the reverted state.
//
// This function will also listen for update events on the live model.
// The update event will be triggered when someone changes the data
// on the live model, without an intention to update the backend.
// When an update event is detected, it will:
//
// * If the changed property was isFollowing, it will automatically
//   update followersCount on the live model.
//
// This function will also listen for broadcast events from the rest
// of the client. When a broadcast event is received, this happens:
//
// * If the URI for the broadcast message does not match this model,
//   do nothing.
//
// * It will then update the live model with the data it received
//   from the broadcast event. This will trigger the update listener
//   described above, but it won't run the code because all properties
//   are there.
//

var intersection = require('mout/array/intersection');
var live = require('../../spotify-live');
var cosmos = require('../util/cosmos');
var requestsInProgress = {};

var endpoints = {
  isFollowing: 'hm://socialgraph/v2/is_following?format=json',
  followCounts: 'hm://socialgraph/v2/counts?format=json',
  updateIsFollowing: 'hm://socialgraph/v2/following?format=json',
  broadcast: 'sp://messages/v1/followstate'
};

function onUpdate(model, data) {

  // Only update followers count if that data was not present in the changed data
  if ('added' in data && !('followersCount' in data)) {
    var followersCount = model.get('followersCount');
    if (followersCount !== undefined) {
      var newFollowersCount = followersCount + (data.added ? 1 : -1);
      model.update({ followersCount: newFollowersCount });
    }
  }
}

function onPublish(model, data) {
  // If the property is added, update the backend with the new value.
  // If the update fails, revert the model state.
  // If the update is successful, broadcast the state to the client.
  if ('added' in data) {
    // if there is a request in course, do not launch a new request
    // as this can mess up with the Backend
    if (requestsInProgress[model.uri]) {
      return;
    }
    requestsInProgress[model.uri] = true;

    // we're optimistic this will work
    model.update({ 'added': data.added });

    updateBackend(model, !!data.added, function (error) {
      // request finished, we can accept more requests now
      delete requestsInProgress[model.uri];
      if (error) {
        // such is life.
        model.update({ added: !data.added });
      } else {
        model.update({ added: data.added });
        broadcast(model);
      }
    });
  }
}

function onBroadcast(error, response) {
  if (error) {
    if (global.console) console.error(error);
    return;
  }

  var body = response.body;
  var data = {};

  if ('added' in body) data.added = body.added;
  // Also accept broadcast from older versions that only send "isFollowing"
  else if ('isFollowing' in body) data.added = body.isFollowing;

  if ('followersCount' in body) data.followersCount = body.followersCount;
  if ('followingCount' in body) data.followingCount = body.followingCount;

  live(body.uri).update(data);
}

function onWait(model, properties) {
  if (intersection(properties, followProperties).length) getRequestData(model, function (error, data) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }
    updateIsFollowing(model, data);
    updateCounts(model, data);
  });
}

function updateIsFollowing(model, requestData, opt_callback) {
  var options = {
    url: endpoints.isFollowing,
    body: requestData
  };
  cosmos.get(options, function (error, response) {
    if (error && opt_callback) return opt_callback(error);
    if (error) {
      if (global.console) console.error(error);
      return;
    }

    var value = response.body[0].is_following;
    model.update({ added: value });

    if (opt_callback) opt_callback();
  });
}

function updateCounts(model, requestData, opt_callback) {
  var options = {
    url: endpoints.followCounts,
    body: requestData
  };
  cosmos.get(options, function (error, response) {
    if (error && opt_callback) return opt_callback(error);
    if (error) {
      if (global.console) console.error(error);
      return;
    }

    var body = response.body[0];

    model.update({
      followersCount: body.followers_count,
      followingCount: body.following_count
    });

    if (opt_callback) opt_callback();
  });
}

function getRequestData(model, callback) {
  // Assumes that the client live object either already has the data about the current user,
  // or that there is code included for getting this data on request.
  live('spotify:client').query('currentUser(uri)', function (error, data) {
    if (error) return callback(error);

    callback(null, {
      // Social graph v2 expects decoded uris (i.e. spotify:user:someone!
      // rather than spotify:user:someone%21). `currentUser(uri)` returns a
      // uri-encoded user name.
      source_uri: decodeURIComponent(data.currentUser.uri),
      target_uris: [decodeURIComponent(model.uri)]
    });
  });
}

function updateBackend(model, isFollowing, callback) {

  getRequestData(model, function (error, data) {
    if (error) return callback(error);
    var requestMethod = isFollowing ? 'post' : 'delete';
    cosmos[requestMethod]({ url: endpoints.updateIsFollowing, body: data }, function (error) {
      if (error) return callback(error);
      callback(null);
    });
  });
}

function broadcast(model) {
  var added = model.get('added');
  cosmos.post({
    url: endpoints.broadcast,
    body: {
      uri: model.uri,
      isFollowing: added,
      added: added,
      followersCount: model.get('followersCount'),
      followingCount: model.get('followingCount')
    }
  });
}

var followProperties = ['added', 'followersCount', 'followingCount'];

var broadcastSubscription;

exports.register = function (regExp) {
  live.subscribe(regExp, 'wait', onWait);
  live.subscribe(regExp, 'update', onUpdate);
  live.subscribe(regExp, 'publish', onPublish);

  // reset the requestsInProgress variable
  requestsInProgress = {};

  if (!broadcastSubscription) {
    broadcastSubscription = cosmos.subscribe({ url: endpoints.broadcast }, onBroadcast);
  }
};

exports.unregister = function (regExp) {
  live.unsubscribe(regExp, 'wait', onWait);
  live.unsubscribe(regExp, 'update', onUpdate);
  live.unsubscribe(regExp, 'publish', onPublish);

  if (broadcastSubscription) {
    broadcastSubscription.cancel();
    broadcastSubscription = null;
  }
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../spotify-live":439,"../util/cosmos":435,"mout/array/intersection":634}],398:[function(require,module,exports){
(function (global){
'use strict';

var live = require('../../spotify-live');
var cosmos = require('../util/cosmos');
var Collection = require('./collection');

var endpoints = {
  isInCollection: 'sp://core-collection/v1/contains',
  updateIsInCollection: 'sp://core-collection/v1/items',
  broadcast: 'sp://messages/v1/collectionstate',
  pubsub: 'hm://collection/collection/@/json'
};

var onCollectionPublish = function onCollectionPublish(error, response) {
  if (error) {
    if (global.console) console.error(error);
    return;
  }

  var items = response.body.items;
  items.forEach(function (item) {
    // FIXME: Hack alert
    // Because of enum weirdness in Java, we need to
    // uppercase the value in the type field.
    // Remove this once FESK-1921 is fixed.
    if (item.type.toUpperCase() === 'TRACK') {
      var uri = 'spotify:track:' + item.identifier;
      live(uri).update({ added: !item.removed });
    }
  });
};

var trackCollection;
var broadcastSubscription;
var collectionSubscription;

var regExp = exports.matches = /^spotify:track:[^:]+$/;
var registered = false;
exports.register = function () {
  if (registered) return;
  registered = true;

  trackCollection = new Collection(endpoints);

  live.subscribe(regExp, 'publish', trackCollection.onPublish);
  live.subscribe(regExp, 'wait', trackCollection.onWait);

  broadcastSubscription = cosmos.subscribe({ url: endpoints.broadcast }, Collection.onBroadcast);
  collectionSubscription = cosmos.subscribe({ url: endpoints.pubsub }, onCollectionPublish);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  live.unsubscribe(regExp, 'publish', trackCollection.onPublish);
  live.unsubscribe(regExp, 'wait', trackCollection.onWait);

  trackCollection = null;

  if (broadcastSubscription) {
    broadcastSubscription.cancel();
    broadcastSubscription = null;
  }

  if (collectionSubscription) {
    collectionSubscription.cancel();
    collectionSubscription = null;
  }
};

exports._endpoints = endpoints;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../spotify-live":439,"../util/cosmos":435,"./collection":395}],399:[function(require,module,exports){
(function (global){
/**
 * @module spotify-live-models/album
 */
'use strict';

var live = require('../spotify-live');

var liburi = require('spotify-liburi');

var intersection = require('mout/array/intersection');
var contains = require('mout/array/contains');
var mixIn = require('mout/object/mixIn');

var bridge = require('./util/bridge').request;

function isLocalAlbum(uri) {
  return liburi.from(uri).type === liburi.Type.LOCAL_ALBUM;
}

function isLocalArtist(uri) {
  return liburi.from(uri).type === liburi.Type.LOCAL_ARTIST;
}

function updateMetadata(model) {
  if (isLocalAlbum(model.uri)) {
    var uriObject = liburi.from(model.uri);
    if (uriObject) {
      var data = {
        local: true,
        name: uriObject.album,
        artists: [{
          uri: 'spotify:local:',
          name: '',
          local: true
        }]
      };
      if (uriObject.artist) {
        data.artists[0].uri = liburi.localArtistURI(uriObject.artist).toURI();
        data.artists[0].name = uriObject.artist;
        data.artists[0].local = true;
      }
      model.update(data);
    }
  } else {
    bridge('album_metadata', [model.uri], function (error, payload) {
      if (error) {
        if (global.console) console.error(error);
        return;
      }
      model.update(payload);
    });
  }
}

function updateLocal(model) {
  model.update({
    local: isLocalAlbum(model.uri)
  });
}

var idCounter = 1000;

function getRowUri(trackUri) {
  return trackUri.replace('spotify:', 'spotify:row:' + (++idCounter).toString(36) + ':');
}

function updateRows(model) {
  var descriptor = { type: 'list', uri: model.uri };

  bridge('album_tracks_snapshot', [descriptor, 0, 0, false], function (error, payload) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }

    bridge('album_tracks_snapshot', [descriptor, 0, payload.length, false], function (error, payload) {
      if (error) {
        if (global.console) console.error(error);
        return;
      }

      var discs = [];
      var uriId = liburi.from(model.uri).id;

      var rows = payload.metadata && payload.metadata.map(function (trackdata, i) {
        var track = mixIn({ uri: payload.array[i] }, trackdata);
        var discNum = track.disc ? track.disc - 1 : 0;
        track.unavailable = !track.playable;
        setLocalProperty(track);
        if (!discs[discNum]) {
          discs[discNum] = {
            rows: [],
            uri: uriId ? liburi.albumURI(uriId, discNum + 1).toURI() : ''
          };
        }
        var uri = getRowUri(track.uri);
        var trackObject = {
          track: track,
          uri: uri
        };
        discs[discNum].rows.push(trackObject);
        return trackObject;
      });

      model.update({ rows: rows, discs: discs });
    });
  });
}

function setLocalProperty(track) {
  if (track.album && track.album.uri) {
    track.album.local = isLocalAlbum(track.album.uri);
  }
  if (track.artists) {
    for (var i = 0, l = track.artists.length; i < l; i++) {
      var artist = track.artists[i];
      if (artist.uri) {
        artist.local = isLocalArtist(artist.uri);
      }
    }
  }
}

function onWait(model, properties) {
  var hasLocal = contains(properties, 'local');
  var hasRows = contains(properties, 'rows');
  var hasDiscs = contains(properties, 'discs');

  var metaFields = ['artists', 'image', 'images', 'name', 'playable', 'type', 'availability', 'date', 'label', 'copyrights'];

  var hasMetadata = !!intersection(properties, metaFields).length;

  if (hasMetadata) updateMetadata(model);
  if (hasRows || hasDiscs) updateRows(model);
  if (hasLocal) updateLocal(model);
}

var regExp = exports.matches = /^spotify:album:[0-9a-zA-Z]+$|^spotify:local:[^:]*:[^:]*$/;
var registered;
exports.register = function () {
  if (registered) return;
  registered = true;

  live.subscribe(regExp, 'wait', onWait);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  live.unsubscribe(regExp, 'wait', onWait);
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-live":439,"./util/bridge":433,"mout/array/contains":625,"mout/array/intersection":634,"mout/object/mixIn":667,"spotify-liburi":707}],400:[function(require,module,exports){
(function (global){
/**
 * @module spotify-live-models/application
 */
'use strict';

var contains = require('mout/array/contains');
var live = require('../spotify-live');
var bridge = require('./util/bridge').request;
var AppState = require('../spotify-navigation/app-state');

var BACKOFF = 100;

function bridgeWait() {
  bridge('application_event_wait', [], function (error, event) {
    if (!registered) return;
    if (error) {
      setTimeout(function () {
        bridgeWait(model);
      }, BACKOFF);
      if (global.console) console.error(error);
      return;
    }

    var model = live('spotify:application');

    if (event.data && event.data.arguments) {
      model.update({
        arguments: event.data.arguments.join(':')
      });
    }

    // These don't won't happen on Zelda, there we handle it through postMessage. See onMessage.
    switch (event.type) {
      case 'activate':
        model.update({ 'active': true });
        break;

      case 'deactivate':
        model.update({ 'active': false });
        break;
    }

    bridgeWait(model);
  });
}

function onMessage(message) {
  var model = live('spotify:application');

  if (message.data && message.data.name) {
    if (message.data.name === 'set_active') {
      model.update({
        active: message.data.active
      });
    } else if (message.data.name === 'set_arguments') {
      // Arguments come as an array of un-encoded values, but we need to
      // concatenate them to a single colon-separated string for the
      // current design of the API. This is incorrect, as arguments should
      // be encoded if they are joined in a string. We should fix this, but
      // not without a breaking change.
      // https://jira.spotify.net/browse/KM-2353
      model.update({
        arguments: message.data.arguments.join(':')
      });
    } else if (message.data.name === 'set_state') {
      model.update({
        state: AppState.unserialize(message.data.state)
      });
    }
  }
}

function onRegister(model) {
  model.update({
    version: global.__spotify && global.__spotify.app_version || '0.0.0'
  });

  bridge('application_query', [], function (error, payload) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }

    var data = {};
    if (payload.uri) data.appURI = payload.uri;
    if (payload.arguments) data.arguments = payload.arguments.join(':');
    if ('active' in payload) data.active = payload.active;

    model.update(data);
  });
}

function applicationOpenUri(model, event) {
  bridge('application_open_uri', [event.uri]);
}

function applicationReplaceUri(model, event) {

  // This is intended to work like history.replace in the browser.

  // Desktop can also replace further back, so the current appURI needs
  // to be passed.
  // Link can't replace further back anyway, so anything thruthy as the
  // second argument will just replace the current.

  model.get('appURI', function (error, appUri) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }
    bridge('application_open_uri', [event.uri, appUri]);
  });
}

var regExp = exports.matches = /^spotify:application$/;
var registered;
exports.register = function () {
  if (registered) return;
  registered = true;

  live.subscribe(regExp, 'push-history-state', applicationOpenUri);
  live.subscribe(regExp, 'replace-history-state', applicationReplaceUri);
  global.addEventListener('message', onMessage);
  bridgeWait();
  onRegister(live('spotify:application'));
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  live.unsubscribe(regExp, 'push-history-state', applicationOpenUri);
  live.unsubscribe(regExp, 'replace-history-state', applicationReplaceUri);
  global.removeEventListener('message', onMessage);
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-live":439,"../spotify-navigation/app-state":462,"./util/bridge":433,"mout/array/contains":625}],401:[function(require,module,exports){
(function (global){
/**
 * @module spotify-live-models/artist
 */
'use strict';

var liburi = require('spotify-liburi');
var contains = require('mout/array/contains');
var live = require('../spotify-live');
var bridge = require('./util/bridge').request;

function isLocalArtist(uri) {
  return liburi.from(uri).type === liburi.Type.LOCAL_ARTIST;
}

function updateMetadata(model) {
  if (isLocalArtist(model.uri)) {
    var uriObject = liburi.from(model.uri);
    if (uriObject) {
      model.update({
        local: true,
        name: uriObject.artist
      });
    }
  } else {
    bridge('artist_metadata', [model.uri], function (error, payload) {
      if (error) {
        if (global.console) console.error(error);
        return;
      }
      if (!payload.image && !model.get('image')) payload.image = '';
      if (!payload.images && !model.get('images')) payload.images = [];
      model.update(payload);
    });
  }
}

function updateLocal(model) {
  model.update({
    local: isLocalArtist(model.uri)
  });
}

function onWait(model, properties) {
  var hasLocal = contains(properties, 'local');
  var hasMetadata = false;
  var metaFields = ['image', 'images', 'name', 'popularity'];
  for (var i = 0, l = properties.length; i < l; i++) {
    if (contains(metaFields, properties[i])) {
      hasMetadata = true;
      break;
    }
  }

  if (hasMetadata) updateMetadata(model);
  if (hasLocal) updateLocal(model);
}

var regExp = exports.matches = /^spotify:artist:|^spotify:local:[^:]*$/;
var registered;
exports.register = function () {
  if (registered) return;
  registered = true;

  live.subscribe(regExp, 'wait', onWait);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  live.unsubscribe(regExp, 'wait', onWait);
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-live":439,"./util/bridge":433,"mout/array/contains":625,"spotify-liburi":707}],402:[function(require,module,exports){
(function (global){
/**
 * @module spotify-live-models/client-storage
 */
'use strict';

var forOwn = require('mout/object/forOwn');
var combine = require('mout/array/combine');
var remove = require('mout/array/remove');
var contains = require('mout/array/contains');

var URI = 'spotify:client-storage';
var live = require('../spotify-live');
var cosmos = require('./util/cosmos');
var endpoints = {
  broadcast: 'sp://messages/v1/client-storage'
};

var waiting = [];

function onInit(model) {
  // Set a flag for showing that the model has been implemented and
  // registered. This is so that we can check this in player without
  // making a breaking change. Would be great with a future live API
  // to see if someone has implemented a specific model.
  model.update({ implemented: true });
}

function onWait(model, properties) {
  // Ask the top frame to broadcast the properties.
  // Values will be null when they weren't stored.
  waiting = combine(waiting, properties);
  global.top.postMessage({
    type: 'client_storage',
    name: 'broadcast_client_storage',
    data: properties
  }, '*');
}

function onPublish(model, properties) {
  // Tell the top frame to persist and broadcast
  global.top.postMessage({
    type: 'client_storage',
    name: 'set_client_storage',
    data: properties
  }, '*');

  // Optimistic update
  model.update(properties);
}

function onBroadcast(error, event) {
  var update = {};
  var model = live(URI);
  forOwn(event.body, function (value, key) {

    // Update model if this instance of storage knows that the model waits for it
    var isWaiting = contains(waiting, key);

    // Or if the model has a potentially outdated value in the live cache
    var hasKey = model.get(key) !== undefined;

    if (isWaiting || hasKey) update[key] = value;
    if (isWaiting) remove(waiting, key);
  });
  model.update(update);
}

var broadcastSubscription;
var regExp = exports.matches = new RegExp('^' + URI + '$');
var registered;

exports.register = function () {
  if (registered) return;
  registered = true;

  live.subscribe(regExp, 'init', onInit);
  live.subscribe(regExp, 'wait', onWait);
  live.subscribe(regExp, 'publish', onPublish);
  broadcastSubscription = cosmos.subscribe({ url: endpoints.broadcast }, onBroadcast);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  live.unsubscribe(regExp, 'init', onInit);
  live.unsubscribe(regExp, 'wait', onWait);
  live.unsubscribe(regExp, 'publish', onPublish);

  if (broadcastSubscription) {
    broadcastSubscription.cancel();
    broadcastSubscription = null;
  }
  waiting.length = 0;
};

exports._endpoints = endpoints;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-live":439,"./util/cosmos":435,"mout/array/combine":624,"mout/array/contains":625,"mout/array/remove":636,"mout/object/forOwn":663}],403:[function(require,module,exports){
(function (global){
/**
 * @module spotify-live-models/client
 */
'use strict';

var live = require('../spotify-live');
var bridge = require('./util/bridge').request;
var liburi = require('spotify-liburi');

var BACKOFF = 100;

function updateCurrentUser(model) {
  bridge('user_metadata', ['spotify:user:@'], function (error, payload) {
    if (error) {
      if (global.__spotify && global.__spotify.username) {
        var username = global.__spotify.username;
        model.update({
          currentUser: {
            uri: liburi.profileURI(username).toURI(),
            username: username
          }
        });
      }

      if (global.console) console.error(error);
      return;
    }

    model.update({
      currentUser: {
        uri: liburi.profileURI(payload.username).toURI(),
        name: payload.name,
        username: payload.username
      }
    });
  });
}

function getFeatures(callback) {
  bridge('client_features', [], function (error, payload) {
    if (error) return callback(error);
    callback(null, payload.features);
  });
}

function updateSessionData(model) {
  bridge('session_query', [], function (error, payload) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }

    // Not all the clients expose employee property so it needs to be set if it does not exist
    if (payload.employee === undefined) {
      if (global.__spotify && global.__spotify.product_state && global.__spotify.product_state.employee) {
        // For Zelda
        payload.employee = global.__spotify.product_state.employee === '1' ? true : false;
      } else {
        // Clients older than 0.9.16 do not expose employee flag.
        payload.employee = false;
      }
    }

    model.update({ session: payload });

    // Initiate session subscription since data has been requested once.
    bridgeWaitSession(model);
  });
}

function bridgeWaitSession(model) {
  bridge('session_event_wait', [], function (error, event) {
    if (!registered) return;
    if (error) {
      setTimeout(function () {
        bridgeWaitSession(model);
      }, BACKOFF);
      if (global.console) console.error(error);
      return;
    }

    if (event.type === 'change') {
      model.get('session').update(event.data);
    }

    bridgeWaitSession(model);
  });
}

function showContextMenu(model, data) {
  if (global === window && window.top && window.top.postMessage) {
    window.top.postMessage({
      type: 'client_show_context_ui',
      data: data
    }, '*');
  }
}

function onWait(model, properties) {
  if (properties.indexOf('currentUser') > -1) {
    updateCurrentUser(model);
  }

  if (properties.indexOf('session') > -1) {
    updateSessionData(model);
  }
}

var hasFeatures;

function onFeaturesWait(featuresModel, properties) {
  // If features have been loaded before, every requested feature that
  // generates a 'wait' event after that is not an enabled feature in
  // the client, so we return false for all other properties.
  if (hasFeatures) {
    var features = {};
    properties.forEach(function (prop) {
      features[prop] = false;
    });
    featuresModel.update(features);
  } else {
    hasFeatures = true;
    getFeatures(function (error, features) {
      if (error) {
        if (global.console) console.error(error);
        return;
      }
      featuresModel.update(features);

      // Get a list of features that the model is waiting for still,
      // even after the received features were added.
      var neededFeatures = [];
      properties.forEach(function (prop) {
        if (!(prop in features)) neededFeatures.push(prop);
      });

      // Trigger a new wait handler for the properties it's still waiting for
      onFeaturesWait(featuresModel, neededFeatures);
    });
  }
}

function onInit(model) {
  // Get container_features and put it into it's own place on the client model.
  var __spotify = global.__spotify || {};
  var containerFeatures = live(__spotify.container_features || {});
  containerFeatures.on('wait', function (properties) {
    var update = {};
    for (var i = 0, property; property = properties[i]; i++) {
      update[property] = false;
    }
    containerFeatures.update(update);
  });

  // Listen for wait events on the features model to fetch data
  // through bridge and set other features to false
  var features = live({});
  features.on('wait', function (properties) {
    onFeaturesWait(features, properties);
  });

  model.update({
    features: features,
    containerFeatures: containerFeatures
  });

  // Grab the username from __spotify where available
  if (global.__spotify && global.__spotify.username) {
    var username = global.__spotify.username;
    model.update({
      currentUser: {
        uri: liburi.profileURI(username).toURI(),
        username: username
      }
    });
  }

  // Async fetch from bridge to complete currentUser to a user model
  // while we don't have all the info available elsewhere.
  updateCurrentUser(model);
}

var regExp = exports.matches = /^spotify:client$/;
var registered;
exports.register = function () {
  if (registered) return;
  registered = true;

  live.subscribe(regExp, 'wait', onWait);
  live.subscribe(regExp, 'init', onInit);
  live.subscribe(regExp, 'show-context-menu', showContextMenu);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  live.unsubscribe(regExp, 'wait', onWait);
  live.unsubscribe(regExp, 'init', onInit);
  live.unsubscribe(regExp, 'show-context-menu', showContextMenu);
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-live":439,"./util/bridge":433,"spotify-liburi":707}],404:[function(require,module,exports){
/**
 * @module spotify-live-models/list-variant
 */
'use strict';

var contains = require('mout/array/contains');
var showUnplayableTracks = require('./util/unplayable-tracks-playlist-setting.js');
var legacySortUris = require('./sorting/legacy-sort-uris');

var live = require('../spotify-live');
var sortUriUtils = require('../spotify-live-sort-uri');
var filterUriUtils = require('../spotify-live-filter-uri');
var URI = require('spotify-liburi');

var SESSION_STORAGE = 'spotify:session-storage';
var CLIENT_STORAGE = 'spotify:client-storage';
var SORT_VARIANT_KEY = 'list-variant-';
var STRING_FILTER_KEY = 'list-filter-string-';

var sessionStorageListeners = {};

function onWait(model, properties) {
  if (!contains(properties, 'listVariant')) {
    return;
  }

  var uri = getOriginUri(model.uri);

  // listVariant objects are shared amongst all variants.
  var listVariant = live(uri).get('listVariant');
  if (!listVariant) {
    listVariant = live({
      origin: {
        uri: uri
      }
    });
    listVariant.on('wait', onVariantWait.bind(null, listVariant));
  }

  model.update({ listVariant: listVariant });

  // If the model is a variant, set that list variant on the origin too
  // so it can be accessed there for the next variant to ask.
  if (uri !== model.uri) {
    live(uri).update({ listVariant: listVariant });
  }
}

function onVariantWait(model, properties) {
  if (contains(properties, 'currentUri')) {
    addAndWatchCurrentUri(model);
    // This will fulfill and watch all other properties
    return;
  }

  if (contains(properties, 'filterString')) {
    addAndWatchFilterString(model);
  }
  if (contains(properties, 'sortQuery') || contains(properties, 'sortDirection') || contains(properties, 'sortUri')) {
    addAndWatchSortQuery(model);
  }
  if (contains(properties, 'showUnplayable')) {
    addAndWatchUnplayable(model);
  }
}

function addAndWatchCurrentUri(model) {

  model.on('update', update);
  update();

  function update() {
    var props = 'filterString, sortQuery, sortDirection, sortUri, showUnplayable, origin(uri)';
    model.query(props, function (error, data) {
      if (error) {
        console.error('Error when getting', props, ':', Error);
        return;
      }

      var result = data.origin.uri;
      var filters = [];

      if (data.filterString) {
        filters.push('text contains ' + encodeURIComponent(data.filterString));
      }

      if (!data.showUnplayable) {
        filters.push('playable eq true');
      }

      if (filters.length) {
        result = filterUriUtils.create(result, filters.join(','));
      }

      var sortUriParams = data.sortUri && sortUriUtils.parse(data.sortUri);

      if (sortUriParams) {
        result = sortUriUtils.create(result, sortUriParams.direction, sortUriParams.query);
      }

      model.update({
        currentUri: result
      });
    });
  }
}

var showUnplayablePref;
var updateUnavailablePrefOn = [];

function addAndWatchUnplayable(model) {
  var uri = model.get('origin').uri;
  var type = URI.fromString(uri).type;

  if (type !== URI.Type.PLAYLIST) {
    model.update({ showUnplayable: true });
    return;
  }

  updateUnavailablePrefOn.push(model);
  if (showUnplayablePref != null) {
    model.update({ showUnplayable: showUnplayablePref });
    return;
  }

  showUnplayableTracks.subscribe(function (error, showUnplayable) {
    // Cache this globally as we will never cancel this subscribe here.
    // The same setting is valid for all models.
    if (error) {
      console.error(error);
      showUnplayable = false; // Should default to hide unplayable.
    }

    showUnplayablePref = showUnplayable;
    for (var i = 0; i < updateUnavailablePrefOn.length; i++) {
      updateUnavailablePrefOn[i].update({ showUnplayable: showUnplayable });
    }
  });
}

function addAndWatchSortQuery(model) {
  var uri = model.get('origin').uri;

  var clientStorage = live(CLIENT_STORAGE);
  var key = SORT_VARIANT_KEY + uri;
  if (clientStorage.get('implemented')) {
    updateSortParams(model, uri, key);
    clientStorage.on('update', function (changed) {
      if (changed.hasOwnProperty(key)) {
        updateSortParams(model, uri, key);
      }
    });
  } else {
    // There is no clientStorage. Update the model with defaults.
    var update = getDefaultQueryParams(uri);
    model.update(update);
  }
}

function updateSortParams(model, uri, key) {
  var clientStorage = live(CLIENT_STORAGE);

  clientStorage.get(key, function (error, variant) {
    // Respond with the sort variant if it's a valid sort URI
    var sortParams = variant && sortUriUtils.parse(variant);
    if (!error && sortParams) {
      // Check for legacy sort URIs and convert them by publishing
      // the updated version on client-storage
      var convertedFromLegacy = legacySortUris.legacyQueries[sortParams.query];

      if (convertedFromLegacy != null && convertedFromLegacy !== sortParams.query) {
        // Fix the legacy query on storage
        var fixedUri = sortUriUtils.create(uri, sortParams.direction, convertedFromLegacy);
        var publish = {};
        publish[key] = fixedUri;
        clientStorage.publish(publish);
        // This will trigger another update which will then set the sort params.
        return;
      }

      model.update({
        sortQuery: sortParams.query,
        sortDirection: sortParams.direction, // this is 'asc' or 'desc'
        sortUri: variant
      });
    } else if (variant === uri) {
      // This was unsorted.
      model.update({
        sortQuery: null,
        sortDirection: null,
        sortUri: null
      });
    } else {
      // There was nothing valid in store. Update the model with defaults.
      var update = getDefaultQueryParams(uri);
      model.update(update);
    }
  });
}

function getDefaultQueryParams(uri) {
  var sortQuery = null;
  var sortDirection = null;
  var sortUri = null;

  var isLocalFiles = uri === 'spotify:internal:local-files';
  if (isLocalFiles) {
    // Local files should be sorted by trackname by default
    sortQuery = 'track(name)';
    sortDirection = 'asc';
    sortUri = sortUriUtils.create(uri, sortDirection, sortQuery);
  }

  return {
    sortQuery: sortQuery,
    sortDirection: sortDirection,
    sortUri: sortUri
  };
}

function addAndWatchFilterString(model) {
  var uri = model.get('origin').uri; // The variant object itself doesn't have a uri, this is the one for the list it's about
  var sessionStorage = live(SESSION_STORAGE);
  var key = STRING_FILTER_KEY + uri;

  if (sessionStorage.get('implemented')) {
    updateFilterString(model, uri, key);
    sessionStorage.on('update', function (changed) {
      if (changed.hasOwnProperty(key)) {
        updateFilterString(model, uri, key);
      }
    });
  } else {
    model.update({ 'filterString': '' });
  }
};

function updateFilterString(model, uri, key) {
  var sessionStorage = live(SESSION_STORAGE);

  sessionStorage.get(key, function (error, value) {
    model.update({ 'filterString': value || '' });
  }, live.ASAP);
}

function getOriginUri(uri) {
  var sorted = sortUriUtils.parse(uri);
  if (sorted) uri = sorted.originUri;

  var filtered = filterUriUtils.parse(uri);
  if (filtered) uri = filtered.originUri;

  return uri;
}

function updateRegisteredStatus(status) {
  registered = status;
  live('spotify:list-variant').update({ implemented: status });
}

var regExp = exports.matches = /^spotify:/;
var registered;
exports.register = function () {
  if (registered) return;

  live.subscribe(regExp, 'wait', onWait);
  updateRegisteredStatus(true);
};

exports.unregister = function () {
  if (!registered) return;

  updateUnavailablePrefOn = [];
  showUnplayablePref = null;

  live.unsubscribe(regExp, 'wait', onWait);
  updateRegisteredStatus(false);
};

},{"../spotify-live":439,"../spotify-live-filter-uri":371,"../spotify-live-sort-uri":437,"./sorting/legacy-sort-uris":417,"./util/unplayable-tracks-playlist-setting.js":436,"mout/array/contains":625,"spotify-liburi":707}],405:[function(require,module,exports){
(function (global){
/**
 * @module spotify-live-models/local-files
 */
'use strict';

var contains = require('mout/array/contains');

var live = require('../spotify-live');
var listOperations = require('spotify-live-list-operations');
var liburi = require('spotify-liburi');
var Range = require('../spotify-range2');
var cosmos = require('./util/cosmos');

var regExp = /^spotify:internal:local-files$/;

function onWait(model, properties) {
  if (contains(properties, 'allows')) getAllows(model);
  if (contains(properties, 'rows')) getRows(model);
}

function getAllows(model) {
  model.update({
    allows: {
      insertTracks: false,
      removeTracks: false
    }
  });
}

function createRows(data) {
  var rows = new Array(data.length);

  for (var i = 0, l = data.length; i < l; i++) {
    var track = data[i];

    setLocalProperty(track);

    // We want timestamp in milliseconds, but the client gives it in seconds.
    var dateAdded = track.dateAdded * 1000;

    var row = {
      uri: getRowUri(track.uri),
      track: track,
      dateAdded: dateAdded
    };

    rows[i] = row;

    delete track.dateAdded;
    delete track.addedBy;
  }

  return rows;
}

function setLocalProperty(track) {
  if (track.album && track.album.uri) {
    var albumType = liburi.from(track.album.uri).type;
    track.album.local = albumType === liburi.Type.LOCAL_ALBUM;
  }
  if (track.artists) {
    for (var i = 0, l = track.artists.length; i < l; i++) {
      var artist = track.artists[i];
      if (artist.uri) {
        var artistType = liburi.from(artist.uri).type;
        artist.local = artistType === liburi.Type.LOCAL_ARTIST;
      }
    }
  }
}

function getRows(model) {
  cosmos.get({ url: 'sp://local-files/v1/tracks' }, function (error, response) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }

    model.update({
      rows: createRows(response.body)
    });

    cosmos.subscribe({ url: 'sp://local-files/v1/changes' }, function (error, response) {
      if (error) {
        if (global.console) console.error(error);
        return;
      }

      onChange(model, response.body);
    });
  });
}

function onChange(model, event) {
  switch (event.type) {
    case 'removed':
      onTracksRemoved(model, event.data);break;
    case 'added':
      onTracksAdded(model, event.data);break;
    case 'moved':
      onTracksMoved(model, event.data);break;
    case 'changed':
      onMetadataChanged(model, event.data);break;
  }
}

function onMetadataChanged(model, data) {

  // The positions we get could in some cases be for multiple ranges.
  //
  // We need to remove each range individually, so that we can re-add
  // the same range with updated data right after removing the range.
  // The reason we can't just update rows with new data is that the
  // metadata might cause the row to get a new URI (since local files
  // contain the metadata in the URI).

  var ranges = Range.fromIndices(data.positions);

  var startOfRangeInChangeset = 0;

  for (var rangeIndex = 0, range; range = ranges[rangeIndex]; rangeIndex++) {
    var indices = range.toIndices();
    var rangeLength = range.length;
    var tracks = new Array(indices.length);

    for (var i = 0; i < rangeLength; i++) {
      tracks[i] = data.tracks[startOfRangeInChangeset + i];
    }

    // Remove range and re-add it with new data
    var removeOperations = listOperations.getRemoveOperations(indices);
    model.get('rows').update(removeOperations);
    addTracksToList(model, tracks, indices[0]);

    startOfRangeInChangeset += rangeLength;
  }
}

function onTracksMoved(model, data) {
  var moveOperations = listOperations.getMoveOperations(data.positions, data.position);
  model.get('rows').update(moveOperations);
}

function onTracksRemoved(model, data) {
  var removeOperations = listOperations.getRemoveOperations(data.positions);
  model.get('rows').update(removeOperations);
}

function onTracksAdded(model, data) {
  addTracksToList(model, data.tracks, data.position);
}

function addTracksToList(model, tracks, index) {
  var rows = createRows(tracks);

  var insertOperations = listOperations.getInsertOperations(rows, index);
  model.get('rows').update(insertOperations);
}

var idCounter = 1000;
function getRowUri(trackUri) {
  return trackUri.replace('spotify:', 'spotify:row:' + (++idCounter).toString(36) + ':');
}

var registered = false;

exports.register = function () {
  if (registered) return;
  registered = true;
  live.subscribe(regExp, 'wait', onWait);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;
  live.unsubscribe(regExp, 'wait', onWait);
};

exports.matches = regExp;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-live":439,"../spotify-range2":489,"./util/cosmos":435,"mout/array/contains":625,"spotify-liburi":707,"spotify-live-list-operations":708}],406:[function(require,module,exports){
'use strict';

var cosmos = require('../util/cosmos');

var ARTIST_CONTEXT_URL = 'hm://artistplaycontext/';

function getContext(contextUri, options, opt_callback) {

  var url = contextUri.split(':').join('/');
  var resolverUrl = ARTIST_CONTEXT_URL + url + '/km';
  var postObject = { url: resolverUrl };

  cosmos.get(postObject, opt_callback);
}

module.exports = {
  getContext: getContext
};

},{"../util/cosmos":435}],407:[function(require,module,exports){
(function (global){
/**
 * @module spotify-live-models/player/control
 * @private
 */
'use strict';

var shuffleMode = require('../../spotify-shuffle-mode');
var cosmosPlayer = require('./cosmos-player');
var playerApi = require('./player-api');
var playlistResolver = require('./playlist-resolver');
var artistResolver = require('./artist-resolver');

var dataUtils = require('./data');

var cosmos = require('../util/cosmos');

/**
 * Check AB test if it should use new artist context resolver.
 *
 * @param {Function=} callback Callback function.
 **/
function shouldUseArtistContextPlayerResolver(callback) {
  var ARTIST_CONTEXT_TEST = 'Rollout_short_artist_context_desktop';
  cosmos.post({
    url: 'sp://abba/v1/flags',
    body: { flags: [ARTIST_CONTEXT_TEST] }
  }, function (_, response) {
    var flags = response && response.body && response.body.flags || [];
    var featureFlagCell = flags[0] && flags[0].featureName === ARTIST_CONTEXT_TEST && flags[0].cell;

    callback(featureFlagCell === 'Rollout');
  });
}

/**
 * Request to play a list of track URIs.
 *
 * @param {Array.<string>} trackUris Array of track URIs.
 * @param {?Array.<string>} opt_ids Array of one id per track. Not needed when the context never needs to be updated.
 * @param {Object} playOptions An object with play options.
 * @param {Function=} opt_callback Callback function.
 */
function playTrackUris(trackUris, opt_ids, playOptions, opt_callback) {
  playerApi.play(trackUris, opt_ids, playOptions, opt_callback);
}

/**
 * Request to play a context through the cosmos track resolver.
 *
 * @param {string} contextUri Context URI.
 * @param {Object} playOptions An object with play options.
 * @param {Function=} opt_callback Optional callback function.
 */
function playFromResolver(contextUri, playOptions, opt_callback) {
  playerApi.playFromResolver(contextUri, playOptions, opt_callback);
}

/**
 * Play a context directly, only supported on context player
 *
 * @param {Object} context Context object that CP can deal with.
 * @param {Object} playOptions An object with play options.
 * @param {Function=} opt_callback Optional callback function.
 */
function playContext(context, playOptions, opt_callback) {
  playerApi.playContext(context, playOptions, opt_callback);
}

/**
 * Request to play a context through the playlist resolver.
 *
 * @param {string} contextUri Context URI.
 * @param {Object} playOptions An object with play options.
 * @param {Function=} opt_callback Optional callback function.
 */
function playFromPlaylistResolver(contextUri, playOptions, opt_callback) {
  // For playlist playback we don't need to support ranges, so we'll
  // always just pick the first.
  var skipToIndex = {};

  // Todo: This should be cleaned up, we don't need a list of uids because we
  // never need ranges now. We do that stuff using pages.
  if (playOptions.uids) {
    skipToIndex.track_uid = playOptions.uids[0];
  } else if (playOptions.uid) {
    skipToIndex.track_uid = playOptions.uid;
  }

  // Todo: This should be cleaned up, we don't need a list of uids because we
  // never need ranges now. We do that stuff using pages.
  if (playOptions.uris) {
    skipToIndex.track_uri = playOptions.uris[0];
  } else if (playOptions.trackUri) {
    skipToIndex.track_uri = playOptions.trackUri;
  }

  var preparePlayOptions = {};
  if (Object.keys(skipToIndex).length) {
    preparePlayOptions.skip_to_index = skipToIndex;
  }
  if (shuffleMode.isEnabled()) {
    preparePlayOptions.player_options_override = {
      shuffling_context: true
    };
  }

  var playOrigin = {
    view_uri: playOptions.context,

    // fills in source_start & source_end
    // example values: browse, playlist-owned-by-self-non-collaborative
    feature_identifier: playOptions.source,

    // fills in referer
    // example values: spotify:app:browse
    referrer_identifier: playOptions.contextPlayerReferrer,

    // fills in referrer version
    feature_version: playOptions.referrerVersion
  };

  var options = {
    prepare_play_options: preparePlayOptions,
    play_origin: playOrigin
  };

  playlistResolver.play(contextUri, options, opt_callback);
}

/**
 * Request to play a single track.
 *
 * @param {string} uri The track URI.
 * @param {Object} playOptions An object with play options.
 * @param {Function=} opt_callback Optional callback function.
 */
function playTrack(uri, playOptions, opt_callback) {
  playOptions.context = uri;
  playOptions.track = uri;
  playOptions.index = 0;
  playTrackUris([uri], null, playOptions, opt_callback);
}

/**
 * Request to play tracks found in the list of rows.
 *
 * @param {LiveList} rows A live list of rows with tracks.
 * @param {Object} playOptions An object with play options.
 * @param {Function=} opt_callback Optional callback function.
 */
function playRows(rows, playOptions, opt_callback) {
  var index = playOptions.index;
  var range = playOptions.range;

  if (index === null && range) {
    dataUtils.getFirstPlayableRow(rows, range, function (error, index) {
      if (error && opt_callback) return opt_callback(error);
      if (error) {
        if (global.console) console.error(error);
        return;
      }

      var trackUris = dataUtils.getTracksFromRows(rows);
      playOptions.index = index;

      playTrackUris(trackUris, rows.keys, playOptions, opt_callback);
    });
  } else {
    var trackUris = dataUtils.getTracksFromRows(rows);
    playTrackUris(trackUris, rows.keys, playOptions, opt_callback);
  }
}

/**
 * Request to play artist context.
 *
 * @param {string} contextUri Context URI.
 * @param {Function=} opt_callback Optional callback function.
 */
function playFromArtist(uri, playOptions, opt_callback) {
  shouldUseArtistContextPlayerResolver(function (playFromArtistResolver) {
    if (playFromArtistResolver) {
      artistResolver.getContext(uri, playOptions, function (error, data) {
        if (error && opt_callback) return opt_callback(error);
        if (error) {
          if (global.console) console.error(error);
          return;
        }

        var contextObject = data.body;
        playContext(contextObject, playOptions, opt_callback);
      });
    } else {
      // If artist resolver is not enabled yet use regular resolver
      playFromResolver(uri, playOptions, opt_callback);
    }
  });
}

/**
 * Request to update the player with tracks from the provided rows list.
 * This will update the player silently without interrupting playback.
 *
 * @param {LiveList} rows A live list of rows with tracks.
 * @param {Object} playOptions An object with play options.
 * @param {Function=} opt_callback Optional callback function.
 */
function updateWithRows(rows, playOptions, opt_callback) {

  var tracks = dataUtils.getTracksFromRows(rows);

  // Context Player matches on UIDs so let's not provide index
  delete playOptions.index;
  playerApi.update(tracks, rows.keys, playOptions, opt_callback);
}

/**
 * Request to update the player with tracks from the cosmos track resolver.
 * This will update the player silently without interrupting playback.
 *
 * @param {Object} playOptions An object with play options.
 * @param {Function=} opt_callback Optional callback function.
 */
function updateWithResolver(playOptions, opt_callback) {

  /*
    Todo:
    When currently playing from tracklist, keys need to be passed on to the new playlist and folder resolver
  */

  cosmosPlayer.update(playOptions, null, opt_callback);
}

/**
 * Request to pause the playback.
 *
 * @param {Function=} opt_callback Optional callback function.
 */
function pause(opt_callback) {
  playerApi.pause(opt_callback);
}

/**
 * Request to resume the playback.
 *
 * @param {Function=} opt_callback Optional callback function.
 */
function resume(opt_callback) {
  playerApi.resume(opt_callback);
}

/**
 * Request to skip to the previous track.
 *
 * @param {Function=} opt_callback Optional callback function.
 */
function skipPrev(opt_callback) {
  cosmosPlayer.skipPrev(opt_callback);
}

/**
 * Request to skip to the next track.
 *
 * @param {Function=} opt_callback Optional callback function.
 */
function skipNext(opt_callback) {
  cosmosPlayer.skipNext(opt_callback);
}

exports.playTrack = playTrack;
exports.playRows = playRows;
exports.playFromResolver = playFromResolver;
exports.playContext = playContext;
exports.playFromArtist = playFromArtist;
exports.updateWithRows = updateWithRows;
exports.updateWithResolver = updateWithResolver;
exports.pause = pause;
exports.resume = resume;
exports.skipPrev = skipPrev;
exports.skipNext = skipNext;
exports.playFromPlaylistResolver = playFromPlaylistResolver;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../spotify-shuffle-mode":491,"../util/cosmos":435,"./artist-resolver":406,"./cosmos-player":408,"./data":409,"./player-api":411,"./playlist-resolver":412}],408:[function(require,module,exports){
/**
 * @module spotify-live-models/player/cosmos-player
 * @private
 */
'use strict';

var cosmos = require('../util/cosmos');

var PLAYER_URI = 'sp://player/v2/main';
var TRACK_RESOLVER_URI = 'hm://track-resolver/v1?uri=';

var deepFillIn = require('mout/object/deepFillIn');
var isStationUri = require('../station').isStationUri;

var ACTIONS = {
  PLAY: 'play',
  PAUSE: 'pause',
  RESUME: 'resume',
  UPDATE: 'update',
  SKIP_PREV: 'skip_prev',
  SKIP_NEXT: 'skip_next'
};

/**
 * Request to play a list of URIs or a resolvable context URI.
 *
 * @param {Object} options Object with options and data of what to play.
 * @param {?Array} opt_trackUris List of track URIs to play.
 * @param {Function=} opt_callback Callback function.
 */
function play(options, opt_trackUris, opt_callback) {
  if (opt_trackUris) options.tracks = opt_trackUris;
  var state = createCosmosState(options.context, options);

  state.action = ACTIONS.PLAY;

  postPlayerState(state, opt_callback);
}

/**
 * Request to pause the playback.
 *
 * @param {Function=} opt_callback Optional callback function.
 */
function pause(opt_callback) {
  cosmos.post({ url: PLAYER_URI, body: { action: ACTIONS.PAUSE } }, opt_callback);
}

/**
 * Request to resume the playback.
 *
 * @param {Function=} opt_callback Optional callback function.
 */
function resume(opt_callback) {
  cosmos.post({ url: PLAYER_URI, body: { action: ACTIONS.RESUME } }, opt_callback);
}

/**
 * Request to skip playback back.
 *
 * @param {Function=} opt_callback Optional callback function.
 */
function skipPrev(opt_callback) {
  cosmos.post({ url: PLAYER_URI, body: { action: ACTIONS.SKIP_PREV } }, opt_callback);
}

/**
 * Request to skip playback forward.
 *
 * @param {Function=} opt_callback Optional callback function.
 */
function skipNext(opt_callback) {
  cosmos.post({ url: PLAYER_URI, body: { action: ACTIONS.SKIP_NEXT } }, opt_callback);
}

/**
 * Request to update the player with the new state. This will not interupt
 * playback if the context is the same.
 *
 * @param {Object} state State object for the cosmos player.
 * @param {?Array} opt_trackUris List of track URIs to play.
 * @param {Function=} opt_callback Optional callback function.
 */
function update(options, opt_trackUris, opt_callback) {
  if (opt_trackUris) options.tracks = opt_trackUris;
  var state = createCosmosState(options.context, options);

  state.action = ACTIONS.UPDATE;

  // Up the index by one, since the comsos player expects the next track when updating to a different context.
  state.index++;

  // If the new index is past the end of the list, make it the last index of
  // the list. This will make it work for the case where the list only contains
  // a single track. For lists containing more tracks, this will make the player
  // continue playing the current track as a lone track (without any context)
  // and then pick up the right context with the right highlight and all after
  // that track has played.
  if (state.tracks && state.tracks.length <= state.index) {
    state.index = state.tracks.length - 1;
  }

  postPlayerState(state, opt_callback);
}

/**
 * Post the state object to the cosmos player.
 *
 * @param {Object} state State object for the cosmos player.
 * @param {Function=} opt_callback Optional callback function.
 */
function postPlayerState(state, opt_callback) {
  if (state.context) {
    cosmos.sanitizeURL(state.context, function (error, uri) {
      if (error) return opt_callback(error);
      state.context = uri;

      if (!state.tracks) {
        if (/^spotify:user:[^:]+:(playlist:)/.test(uri)) state.next_page_url = uri;else state.next_page_url = TRACK_RESOLVER_URI + encodeURI(uri);

        // Set tracks to an empty array since cosmos player on core js expects it.
        // REMOVE ME! 2014-10-24, see KM-3914.
        state.tracks = [];
      }

      cosmos.post({ url: PLAYER_URI, body: state }, opt_callback);
    });
  } else {
    cosmos.post({ url: PLAYER_URI, body: state }, opt_callback);
  }
}

/**
 * Request to get the current state of the cosmos player.
 *
 * @param {Function} callback Callback function.
 */
function getState(callback) {
  cosmos.get({ url: PLAYER_URI }, function (error, response) {
    if (error) return callback(error);
    callback(null, response.body);
  });
}

/**
 * Request to get the current state of the cosmos player whenever the player
 * changes.
 *
 * @param {Function} callback Callback function.
 *
 * @return {Object} An object with a method to unsubscribe.
 */
function subscribe(callback) {
  var subscription = cosmos.subscribe({ url: PLAYER_URI }, function (error, response) {
    if (error) return callback(error);
    callback(null, response.body);
  });

  return {
    unsubscribe: function unsubscribe() {
      if (!subscription) return;
      subscription.cancel();
      subscription = null;
    }
  };
}

/**
 * Create a state object for the cosmos player.
 *
 * @param {string} contextUri  Context URI.
 * @param {Object} playOptions An object with play options.
 *
 * @return {Object} An object with state in a format that the cosmos player understands.
 */
function createCosmosState(contextUri, playOptions) {

  var isStationContext = isStationUri(contextUri);
  var defaultState = {
    context: null,
    index: null,
    track: null,
    options: {
      can_repeat: true,
      can_shuffle: !isStationContext,
      can_skip_prev: !isStationContext,
      can_skip_next: true,
      can_seek: true,
      use_dmca_rules: false,
      repeat: false,
      repeat_track: false,
      shuffle_context: false
    },
    play_origin: {
      source: 'unknown',
      reason: 'unknown',
      referrer: 'unknown',
      referrer_version: 'unknown',
      referrer_vendor: 'unknown'
    }
  };

  var state = {
    context: contextUri,
    play_origin: {
      source: playOptions.source,
      reason: playOptions.reason,
      referrer: playOptions.referrer,
      referrer_version: playOptions.referrerVersion
    }
  };

  if ('tracks' in playOptions) state.tracks = playOptions.tracks;
  if ('index' in playOptions) state.index = playOptions.index;
  if ('track' in playOptions) state.track = playOptions.track;

  deepFillIn(state, defaultState);

  return state;
}

exports.play = play;
exports.pause = pause;
exports.resume = resume;
exports.skipPrev = skipPrev;
exports.skipNext = skipNext;
exports.update = update;
exports.getState = getState;
exports.subscribe = subscribe;

},{"../station":424,"../util/cosmos":435,"mout/object/deepFillIn":657}],409:[function(require,module,exports){
/**
 * @module spotify-live-models/player/data
 * @private
 */
'use strict';

var live = require('../../spotify-live');
var Range = require('../../spotify-range2');

var playerApi = require('./player-api');

/**
 * Default values for play options.
 */
var PLAY_OPTIONS_DEFAULTS = {
  page: null,
  uid: null,
  trackUri: null,
  index: null,
  source: 'unknown',
  reason: 'unknown'
};

/**
 * Get the first playable row from range in a list of rows.
 *
 * @param {LiveList} rows A live list of rows.
 * @param {Range} range A range object.
 * @param {Function} callback A callback where the second argument is the
 *     index of the first playable row. If no playable track is found, the
 *     index will be the first index in the range.
 */
function getFirstPlayableRow(rows, range, callback) {
  var index = range.start;

  isRowPlayable(rows.get(index), function playableCallback(error, playable) {
    if (playable) return callback(null, index);
    if (index === range.end - 1) return callback(null, range.start);

    isRowPlayable(rows.get(++index), playableCallback);
  });
}

/**
 * Check if the row is playable.
 *
 * @param {LiveObject?} row A row live object. If this is falsy, the callback
 *     is returned with false immediately.
 * @param {Function} callback A callback where the second argument is the
 *     boolean flag for playable. The callback may run synchronously or
 *     asynchronously.
 */
function isRowPlayable(row, callback) {
  if (!row) return callback(null, false);

  row.query('track(playable)', function (error, data) {
    if (error) return callback(error);
    callback(null, data.track.playable);
  }, live.ASAP);
}

/**
 * Get options for play actions based on a data object and other state
 * like referrer set on the player or application object.
 *
 * @param {Object} data A data object.
 * @param {Function} callback A callback, where the second argument is a data
 *     object with the options.
 */
function getPlayOptions(data, callback) {
  getReferrer(function (error, viewUri, baseUri) {
    if (error) return callback(error);

    Object.keys(PLAY_OPTIONS_DEFAULTS).forEach(function (key) {
      if (data[key] === undefined) {
        data[key] = PLAY_OPTIONS_DEFAULTS[key];
      }
    });

    if (data.range) {
      data.range = new Range(data.range[0], data.range[1]);
    }

    data.referrer = viewUri;
    data.contextPlayerReferrer = baseUri;
    data.referrerVersion = getReferrerVersion();

    callback(null, data);
  });
}

/**
 * Get a list of track URIs from a live list of rows.
 *
 * @param {LiveList} rows A live list of rows.
 *
 * @return {Array.<string>} Array of track URIs. If a row is not set in the list,
 *     or if the row doesn't have a track object with a URI, an 'undefined' value
 *     will be put in that position in the output array.
 */
function getTracksFromRows(rows) {
  return rows.map(function (row) {
    var track = row && row.get('track');
    return track && track.uri;
  });
}

/**
 * Get the latest player state, in the format of the player live model.
 *
 * @param {Function} callback Callback function.
 */
function getPlayerState(callback) {
  playerApi.getState(callback);
}

/**
 * Subscribe to the cosmos player to get the latest player state,
 * in the format of the player live model.
 *
 * @param {Function} callback Callback function.
 * @return {Object} An object with a method to unsubscribe.
 */
function subscribeForPlayerState(callback) {
  return playerApi.subscribe(callback);
}

/**
 * Get the referrer for the player. This is usually the path back to the app in
 * the state where the playback started. It can be set by the user in the `referrer`
 * property of the player live object. If nothing is set there, it will generate
 * the referrer by combining the app URI with the app arguments.
 *
 * @param {Function} callback A callback where the second argument is the referrer.
 */
function getReferrer(callback) {
  // 'referrer' corresponds to fullURI below
  var referrer = live('spotify:player').get('referrer');
  var referrerBaseUri = live('spotify:player').get('referrerBaseUri');
  if (referrer) {
    if (!referrerBaseUri) {
      console.warn('referrer field is set on the player model (' + referrer + '), but referrerBaseUri isn\'t');
    }
    return callback(null, referrer, referrerBaseUri || '');
  }

  live('spotify:application').get('appURI', 'arguments', function (error, uri, args) {
    if (error) return callback(error);
    var fullUri = args ? uri + ':' + args : uri;
    callback(null, fullUri, uri);
  });
}

/**
 * Get the referrer version. This is usually the version of the app. It can be set
 * by the user in the `version` property of the application live object. If nothing
 * is set there, it will use the default version '0.0.0'.
 *
 * @return {string} The version string.
 */
function getReferrerVersion() {
  return live('spotify:application').get('version') || '0.0.0';
}

exports.getReferrer = getReferrer;
exports.getReferrerVersion = getReferrerVersion;
exports.getFirstPlayableRow = getFirstPlayableRow;
exports.isRowPlayable = isRowPlayable;
exports.getPlayOptions = getPlayOptions;
exports.getTracksFromRows = getTracksFromRows;
exports.getPlayerState = getPlayerState;
exports.subscribeForPlayerState = subscribeForPlayerState;

},{"../../spotify-live":439,"../../spotify-range2":489,"./player-api":411}],410:[function(require,module,exports){
(function (global){
/**
 * @module spotify-live-models/player
 */
'use strict';

var live = require('../../spotify-live');
var shuffleMode = require('../../spotify-shuffle-mode');
var URI = require('spotify-liburi');
var cosmos = require('spotify-cosmos-api');

var playerApi = require('./player-api');
var playbackControl = require('./control');
var dataUtils = require('./data');
var updatesUtils = require('./updates');
var sortUriUtils = require('../../spotify-live-sort-uri');
var filterUriUtils = require('../../spotify-live-filter-uri');
var createStationPlayContext = require('../station/create-play-context');
var createStationPlayOptions = require('../station/create-play-options');
var isStationUri = require('../station').isStationUri;

var TYPE_TRACK = 'track';
var TYPE_TRACK_RESOLVER = 'track-resolver';
var TYPE_ROWS = 'rows';
var TYPE_CP_RESOLVER_PLAYLIST = 'context-player-resolver-playlist';
var TYPE_CP_CONTEXT = 'context-player-context';
var TYPE_CONTEXT_OBJECT = 'context-object';
var TYPE_STATION_CONTEXT = 'context-station-context';
var TYPE_CP_ARTIST_CONTEXT = 'context-player-artist';
var TYPE_CONTEXT_EPISODE = 'context-episode';
var VARIANT_KEY = 'list-variant-';
var lastPlayRequestId = 0;

// This data store will keep context objects keyed by context URI. The values
// are context objects in the format of spotify-player Context:
// https://ghe.spotify.net/spotify-sdk/spotify-player/blob/master/lib/v2/types.js#L164
var contextDataStore = {};

/**
 * Handler for when properties are requested from the model.
 *
 * @param {LiveObject} model The player live object.
 */
function onWait(model) {
  updateState(model);
}

/**
 * Handler for when the model needs to be updated by polling the player.
 *
 * @param {LiveObject} model The player live object.
 */
function onSync(model) {
  updateState(model);
}

/**
 * Handler for when the real player is updated.
 *
 * @param {Error?} error An error object, or null.
 * @param {Object} data Data object in the format of this live model.
 */
function onPlayerStateUpdate(error, data) {
  if (error) {
    if (global.console) console.error(error);
    return;
  }
  var model = live('spotify:player');
  if (model.get('pending')) return;
  model.update(data);
}

/**
 * Handler for when the model receives the 'update' event.
 *
 * @param {LiveObject} model The player live object.
 */
function onUpdate(model) {
  var index = model.get('index') && model.get('index').get('track');
  if (index != null) {
    updatesUtils.setPlayingIndex(index);
  }

  updatesUtils.clean(model);
}

/**
 * Handler for when the model receives the 'play' event.
 *
 * @param {LiveObject} model The player live object.
 * @param {Object} event The event object with data about what to play.
 *     Can contain the following properties:
 *       `context` (string, context URI)
 *       `index` (number, index within context to play)
 *       `uid` (string, uid within context to play)
 *       `page` (number, index for the context player page)
 *       `range` (array of two values, start and end index)
 *       `uids` (array of uids representing an index or a range)
 *       `uris` (array of uris connected to the uids)
 *       `source` (string)
 *       `reason` (string)
 */
function onPlay(model, event) {
  var context = event.context;
  if (!context) return;

  // The `index` property might be `null`, which should mean that no specific
  // index should be played.
  if (typeof event.index !== 'number') {
    delete event.index;
  }

  // [SHUFFLE] If we are in shuffle mode and we get a request for a specific
  // track, refuse to play.
  if (shuffleMode.isEnabled()) {
    if (event.hasOwnProperty('index') || event.hasOwnProperty('uid')) {
      cosmos.resolver.post({
        url: 'sp://messages/v1/container/user-message',
        body: {
          description: 'Track cannot be played because "shuffle mode" is enabled',
          id: 'shuffle-unplayable-track'
        }
      });
      return;
    }
  }

  var playRequestId = ++lastPlayRequestId;

  // Update the model optimistically
  model.update(playerApi.addContext({
    isPlaying: true,
    isPaused: false,
    index: event.index === undefined ? null : { page: 0, track: event.index },
    track: event.trackUri === undefined ? null : { uri: event.trackUri },
    contextUpdatedCrossFrame: false
  }, context));

  // Get options for the play action based on event data and other state
  // Todo: getPlayOptions creates options that fit the cosmos/v1 implementation.
  // We could probably do this a bit later from cosmos-player.js
  dataUtils.getPlayOptions(event, function (error, options) {
    if (error || !options.context) return updateState(model); // Revert state

    // Canonical contexts can have sorted and/or filtered state that needs
    // to be respected client-wide. We therefore query for the correct variant
    // to be played.
    // For spotify:internal uris on the other hand, we don't look for variants.
    // This would also be the case for contexts that already represent variants.
    // Please see docs for details.
    if (/^spotify:internal:/.test(options.context)) {
      playWithOptions(model, playRequestId, options);
      return;
    }

    if (live('spotify:list-variant').get('implemented')) {
      live(options.context).query('listVariant(currentUri, sortUri)', function (error, data) {
        if (error) return updateState(model); // Revert state

        // Abort if a new play request has happened since this request started
        if (lastPlayRequestId !== playRequestId) {
          return;
        }

        options.context = data.listVariant.currentUri;

        playWithOptions(model, playRequestId, options);
      });
    } else {
      playWithOptions(model, playRequestId, options);
    }
  });
}

/**
 * Handler for when the model receives the 'pause' event.
 *
 * @param {LiveObject} model The player live object.
 */
function onPause(model) {
  if (model.get('isPlaying') === false || model.get('isPaused') === true) {
    return;
  }

  model.update({ isPaused: true });

  playbackControl.pause(function (error) {
    if (error) return model.update({ isPaused: false });
  });
}

/**
 * Handler for when the model receives the 'resume' event.
 *
 * @param {LiveObject} model The player live object.
 */
function onResume(model) {
  if (model.get('isPlaying') === true && model.get('isPaused') === false) {
    return;
  }

  model.update({ isPaused: false });

  playbackControl.resume(function (error) {
    if (error) return model.update({ isPaused: true });
  });
}

/**
 * Handler for when the model receives the 'skip-previous' event.
 *
 * @param {LiveObject} model The player live object.
 */
function onSkipPrev() {
  // Skip prev often starts playback, but not when you're on the first track.
  // Therefor no optimistic update of 'playing' here.
  playbackControl.skipPrev();
}

/**
 * Handler for when the model receives the 'skip-next' event.
 *
 * @param {LiveObject} model The player live object.
 */
function onSkipNext() {
  // Skip next often starts playback, but not when you're on the last track.
  // Therefor no optimistic update of 'playing' here.
  playbackControl.skipNext();
}

/**
 * Handler for when the model receives the 'update-context' event.
 *
 * @param {LiveObject} model The player live object.
 * @param {Object} event An event object with a `context` property (string).
 */
function onUpdateContext(model, event) {
  var contextUri = event.context;
  if (!contextUri) return;

  var context = live(contextUri);
  var playRequestId = ++lastPlayRequestId;

  var currentIndex = model.get('index') && model.get('index').get('track');
  var currentContext = model.get('variant');

  // Update player model optimistically with context and no index.
  // We can't know the index yet, so we must set it to nothing to
  // not get wrong highlights.
  model.update(playerApi.addContext({
    index: null,
    pending: true,
    contextUpdatedCrossFrame: false
  }, contextUri));

  // We need the rows list to be able to get the index and play the list.
  live(contextUri).get('rows', function (error, rowsList) {
    if (error) {
      model.update({ pending: false });
      if (global.console) console.error(error);
      return;
    }

    var options = { context: contextUri };
    dataUtils.getPlayOptions(options, function (error, options) {

      // Abort if a new play request has happened since this request started
      if (lastPlayRequestId !== playRequestId) {
        return;
      }

      // Store which row is currently playing, so that we can get the index
      // of the playing row in another list.
      updatesUtils.setPlayingIndex(currentIndex, currentContext.get('rows'));

      // Find the index of the currently playing track in new list, to do an
      // optimistic update. This is not optional, since the actual player only appends
      // the next context and will not send an update until the next skip.
      // (If it does, because of play/pause for example, it will still report the old
      // list that we're not showing in the UI)

      // At the same time, find the index that we will use to actually update the playback
      var updateIndices = updatesUtils.getPlayingAndUpdateIndicesInList(rowsList);
      options.index = updateIndices.update;
      if (updateIndices.playing != null) model.update({ index: { page: 0, track: updateIndices.playing } });

      if (model.get('playOrigin') && model.get('playOrigin').get('referrerIdentifier') !== options.referrer) {
        model.update({ contextUpdatedCrossFrame: true });
      }

      playbackControl.updateWithRows(rowsList, options, function (error) {
        model.update({ pending: false });
        if (error) return updateState(model); // Revert state
      });

      updatesUtils.listen(rowsList, options, function (options) {
        playbackControl.updateWithRows(rowsList, options, function (error) {
          if (error) return updateState(model); // Revert state
        });
      });
    });
  });
}

/**
 * Request to start playback based on passed options.
 * If the request fails, it will revert the player model to the latest
 * state.
 *
 * @param {LiveObject} model The player live object.
 * @param {string} playRequestId The ID for this request.
 * @param {Object} options Object with options and data of what to play.
 */
function playWithOptions(model, playRequestId, options) {
  var contextUri = options.context;
  var resolverType = getPlaybackResolverType(contextUri);

  if (resolverType === TYPE_TRACK) {
    playbackControl.playTrack(contextUri, options, function (error) {
      if (error) return updateState(model); // Revert state
    });
  } else if (resolverType === TYPE_TRACK_RESOLVER) {
      playbackControl.playFromResolver(contextUri, options, function (error) {
        if (error) return updateState(model); // Revert state
      });
    } else if (resolverType === TYPE_ROWS) {
        var isSortedList = sortUriUtils.isValid(contextUri);

        // If it's a sorted list that is played by rows, we want to request all the track
        // URIs of the sorted list and then play that list of tracks. We will wait for all
        // tracks to be fetched and sorted, to allow clicking play on a media object in
        // Browse for example and have it play the stored sorted variant of the playlist.
        if (isSortedList) {
          getSortedRows(contextUri, function (error, rowsList) {
            if (error) return updateState(model); // Revert state

            // Abort if a new play request has happened since this request started
            if (lastPlayRequestId !== playRequestId) {
              return;
            }

            playRows(model, rowsList, options);
          });

          // Play any other context from the rows list
        } else {
            live(contextUri).query('rows(track(uri))', function (err) {
              if (!err && lastPlayRequestId === playRequestId) {
                playRows(model, live(contextUri).get('rows'), options);
              }
            });
          }
      } else if (resolverType === TYPE_CP_RESOLVER_PLAYLIST) {
        playbackControl.playFromPlaylistResolver(contextUri, options, function (error) {
          if (error) return updateState(model); // Revert state
        });
      } else if (resolverType === TYPE_CONTEXT_OBJECT) {
          var context = contextDataStore[contextUri];
          playbackControl.playContext(context, options, function (error) {
            if (error) return updateState(model); // Revert state
          });
        } else if (resolverType === TYPE_CP_CONTEXT) {

            var context = {
              url: 'context://' + contextUri,
              entity_uri: contextUri
            };

            playbackControl.playContext(context, options, function (error) {
              if (error) return updateState(model); // Revert state
            });
          } else if (resolverType === TYPE_STATION_CONTEXT) {
              var station = live(contextUri);
              station.query('rows', function (err) {
                if (!err) {
                  playbackControl.playContext(createStationPlayContext(station), createStationPlayOptions(station, options), function (error) {
                    if (error) return updateState(model); // Revert state
                  });
                }
              });
            } else if (resolverType === TYPE_CP_ARTIST_CONTEXT) {
                playbackControl.playFromArtist(contextUri, options, function (error) {
                  if (error) return updateState(model); // Revert state
                });
              } else if (resolverType === TYPE_CONTEXT_EPISODE) {
                  var episodeQueryTimeout = 3000;
                  live(contextUri).query('episode(name, manifestId, show(name))', function (error, data) {
                    if (error) return updateState(model); // Revert state

                    var episode = data.episode;
                    var context = {
                      'uri': contextUri,
                      'pages': [{
                        'tracks': {
                          'uri': contextUri,
                          'metadata': {
                            'title': episode.name,
                            'album_title': episode.show.name,
                            'media.type': 'video',
                            'media.manifest_id': episode.manifestId
                          }
                        }
                      }],
                      'restrictions': {
                        'disallow_skipping_prev_reasons': ['disallow-video'],
                        'disallow_skipping_next_reasons': ['disallow-video'],
                        'disallow_toggling_repeat_context_reasons': ['disallow-video'],
                        'disallow_toggling_repeat_track_reasons': ['disallow-video'],
                        'disallow_toggling_shuffle_reasons': ['disallow-video']
                      }
                    };

                    if (!options.player_options_override) {
                      options.player_options_override = {};
                    }
                    // Avoid repeating context when playing episode
                    // This might be removed in future when we have proper shows support
                    options.player_options_override.repeating_context = false;
                    options.player_options_override.repeating_track = false;

                    playbackControl.playContext(context, options, function (error) {
                      if (error) return updateState(model); // Revert state
                    });
                  }, episodeQueryTimeout);
                }
}

/**
 * Request to start playback based on passed rows list and options.
 * If the request fails, it will revert the player model to the latest
 * state.
 *
 * @param {LiveObject} model The player live object.
 * @param {LiveList} rowsList The rows live list.
 * @param {Object} options Object with options and data of what to play.
 */
function playRows(model, rowsList, options) {
  playbackControl.playRows(rowsList, options, function (error) {
    if (error) return updateState(model); // Revert state

    updatesUtils.listen(rowsList, options, function (options) {
      playbackControl.updateWithRows(rowsList, options, function (error) {
        if (error) return updateState(model); // Revert state
      });
    });
  });
}

/**
 * Get the type of playback resolver to use for a certain context URI.
 *
 * @param {string} contextUri Context URI.
 *
 * @return {string} A resolver type. One of 'track-resolver', 'rows' or 'track'.
 */
function getPlaybackResolverType(contextUri) {
  var contextType = URI.from(contextUri).type;

  var isTrack = contextType === URI.Type.TRACK;
  var isPlaylist = contextType === URI.Type.PLAYLIST;
  var isPlaylistFolder = contextType === URI.Type.FOLDER;
  var isArtist = contextType === URI.Type.ARTIST;
  var isSortedList = sortUriUtils.isValid(contextUri);
  var isFilteredList = filterUriUtils.isValid(contextUri);
  var isStation = isStationUri(contextUri);
  var isEpisode = contextType === URI.Type.EPISODE;

  if (isTrack) return TYPE_TRACK;

  if (isPlaylist) {
    return TYPE_CP_RESOLVER_PLAYLIST;
  }

  if (isPlaylistFolder) {
    return TYPE_CP_CONTEXT;
  }

  if (isStation) return TYPE_STATION_CONTEXT;

  var originContextType, originUri;
  if (isSortedList) {
    originUri = sortUriUtils.parse(contextUri).originUri;

    // If the sorted URI is in fact a filtered URI, the origin URI that _that_ is based on
    // needs to be taken into account when judging the originContextType.
    if (filterUriUtils.isValid(originUri)) originUri = filterUriUtils.parse(originUri).originUri;

    originContextType = URI.from(originUri).type;

    if (originContextType === URI.Type.PLAYLIST) {
      return TYPE_CP_RESOLVER_PLAYLIST;
    }

    return TYPE_ROWS;
  }

  if (isFilteredList) {
    // If the sorted URI is in fact a filtered URI, the origin URI that _that_ is based on
    // needs to be taken into account when judging the originContextType.
    originUri = filterUriUtils.parse(contextUri).originUri;
    originContextType = URI.from(originUri).type;

    if (originContextType === URI.Type.PLAYLIST) {
      return TYPE_CP_RESOLVER_PLAYLIST;
    }

    return TYPE_ROWS;
  }

  var contextData = contextDataStore[contextUri];
  if (contextData) {
    return TYPE_CONTEXT_OBJECT;
  }

  // If it's a different URI, check if we have rows
  var rowsList = live(contextUri).get('rows');
  if (rowsList && rowsList.length) {
    return TYPE_ROWS;
  }

  // If it's an artist context but context object or rows were not defined
  if (isArtist) {
    return TYPE_CP_ARTIST_CONTEXT;
  }

  if (isEpisode) {
    return TYPE_CONTEXT_EPISODE;
  }

  // If no rows are available, final hope is on the track resolver
  return TYPE_TRACK_RESOLVER;
}

/**
 * Get the stored variant of the list. For example, if a user has sorted a
 * playlist, that is stored in the client, so playing the playlist from another
 * place should play the stored sorted variant.
 *
 * @param {string} listUri The normal list URI.
 * @param {Function} callback Callback function where second argument is the
 *     URI of the variant to play. This could be the original list URI.
 */
function getStoredSortUri(listUri, callback) {
  live('spotify:client').query('containerFeatures(clientStorage)', function (error, data) {
    if (error) return callback(null, listUri);

    var defaultUri = listUri;

    if (data.containerFeatures.clientStorage) {
      var key = VARIANT_KEY + listUri;
      var clientStorage = live('spotify:client-storage');

      // Check whether the client storage live model has been registered.
      // This is so that we can check this without making this a
      // breaking change. Would be great with a future live API to see
      // if someone has implemented a specific model.
      if (clientStorage.get('implemented')) {
        clientStorage.get(key, function (error, variant) {
          if (error) return callback(null, defaultUri);

          // Respond with the sort variant if it's a valid sort URI
          if (variant && sortUriUtils.isValid(variant) || variant === listUri) {
            return callback(null, variant);
          }

          // Fall back to the regular playlist URI if it's not valid
          callback(null, defaultUri);
        });
      } else {

        // Fall back to the regular playlist URI if client storage is not implemented
        callback(null, defaultUri);
      }
    } else {
      callback(null, defaultUri);
    }
  });
}

/**
 * Get the live list for the rows of the sorted URI.
 *
 * @param {string} sortUri The URI of the sorted list.
 * @param {Function} callback Callback function where second argument is the
 *     sorted live list.
 */
function getSortedRows(sortUri, callback) {
  var playlistUri = sortUriUtils.getOriginUri(sortUri);

  // Get the rows list for the regular playlist.
  // We could have queried for the track of every row, but by not querying we
  // avoid the conversions from live objects to plain objects.
  live(playlistUri).get('rows', function (error, rows) {
    if (error) return callback(error);

    // Get the live models for all rows.
    rows.get(0, rows.length, function (error) {
      if (error) return callback(error);

      // When we know we have the rows, we can safely sort the list
      live(sortUri).get('rows', function (error, rowsList) {
        if (error) return callback(error);

        // Finally return the sorted rows list
        callback(null, rowsList);
      });
    });
  });
}

/**
 * Update the player model with the current data of the cosmos player model.
 *
 * @param {LiveObject} model The player live object.
 */
function updateState(model) {
  dataUtils.getPlayerState(function (error, data) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }
    model.update(data);
  });
}

var regExp = exports.matches = /^spotify:player$/;
var registered;
var playerSubscription;

exports.register = function () {
  if (registered) return;
  registered = true;

  live.subscribe(regExp, 'play', onPlay);
  live.subscribe(regExp, 'pause', onPause);
  live.subscribe(regExp, 'resume', onResume);
  live.subscribe(regExp, 'skip-previous', onSkipPrev);
  live.subscribe(regExp, 'skip-next', onSkipNext);
  live.subscribe(regExp, 'update-context', onUpdateContext);
  live.subscribe(regExp, 'update', onUpdate);
  live.subscribe(regExp, 'wait', onWait);
  live.subscribe(regExp, 'sync-position', onSync);

  playerSubscription = dataUtils.subscribeForPlayerState(onPlayerStateUpdate);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  live.unsubscribe(regExp, 'play', onPlay);
  live.unsubscribe(regExp, 'pause', onPause);
  live.unsubscribe(regExp, 'resume', onResume);
  live.unsubscribe(regExp, 'skip-previous', onSkipPrev);
  live.unsubscribe(regExp, 'skip-next', onSkipNext);
  live.unsubscribe(regExp, 'update-context', onUpdateContext);
  live.unsubscribe(regExp, 'update', onUpdate);
  live.unsubscribe(regExp, 'wait', onWait);
  live.unsubscribe(regExp, 'sync-position', onSync);

  playerSubscription.unsubscribe();
  playerSubscription = null;
};

exports.setContextData = function (contextUri, contextData) {
  contextDataStore[contextUri] = contextData;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../spotify-live":439,"../../spotify-live-filter-uri":371,"../../spotify-live-sort-uri":437,"../../spotify-shuffle-mode":491,"../station":424,"../station/create-play-context":425,"../station/create-play-options":426,"./control":407,"./data":409,"./player-api":411,"./updates":413,"spotify-cosmos-api":694,"spotify-liburi":707}],411:[function(require,module,exports){
(function (global){
/**
 * @module spotify-live-models/player/player-api
 * @private
 */
'use strict';

var dataUtils = require('./data');
var cosmosUtil = require('../util/cosmos');

var live = require('../../spotify-live');
var sortUriUtils = require('../../spotify-live-sort-uri');
var filterUriUtils = require('../../spotify-live-filter-uri');

var PlayerApi = require('spotify-player/lib/v2');
var cosmos = require('spotify-cosmos-api');
var shuffleMode = require('../../spotify-shuffle-mode');

var TRACK_RESOLVER_URI = 'hm://track-resolver/v2?uri=';

var player;

function getPlayer(callback) {

  if (player) {
    callback(player);
    return;
  }

  // One of a fixed list of features, since this is used for logging. It should
  // be the readable name of the feature, for example "radio", "album", "playlist"
  // and it should be the same for a given feature across platforms.
  // The list is probably this:
  // https://ghe.spotify.net/datainfra/log-parser/blob/master/spotify/log_parser/messages_specs.py#L29
  var featureIdentifier;

  // The version of the feature itself
  var featureVersion;

  var appManifest = global.__spotify && global.__spotify.app_manifest;
  if (appManifest) {
    featureVersion = appManifest.BundleVersion || null;
    featureIdentifier = appManifest.BundleIdentifier || null;
  }

  // Hard coded overwrites for apps where we needed to choose a new
  // BundleIdentifier for compat reasons
  // Todo: This is incomplete and would better be fixed by letting features
  // provide values specifically for this. See KM-6973.
  var overwrites = {
    'playlist-desktop': 'playlist'
  };

  if (featureIdentifier && overwrites[featureIdentifier]) featureIdentifier = overwrites[featureIdentifier];

  // The uri of the view that's supposed to show the context where the track is
  // playing, including arguments. That's called referrer in terms of the
  // player live model.
  dataUtils.getReferrer(function (error, viewUri, baseUri) {
    if (error && console) {
      console.error('The player API could not be initialized due to a missing referrer!', error);
      return;
    }

    var options = baseUri ? { referrerIdentifier: baseUri } : null;

    player = new PlayerApi.Player(cosmos.resolver, viewUri, featureIdentifier, featureVersion, options);
    callback(player);

    // The viewUri on this player instance can't ever change, so since we cache
    // it we have to destroy it when arguments change.
    live('spotify:application').on('update', function (data) {
      if ('arguments' in data) {
        player = null;
      }
    });
  });
}

function play(trackUris, opt_rowIds, playOptions, opt_callback) {
  getPlayer(function (player) {
    var tracks = new Array(trackUris.length);
    for (var i = 0; i < trackUris.length; i++) {
      var trackUri = trackUris[i];

      var track = { uri: trackUri };

      // [SHUFFLE]
      // To make the Shuffle rules work correctly, we need to pass album URI
      // and artist URI along with each track.
      if (shuffleMode.isEnabled()) {
        var album = live(trackUri).get('album');
        var artists = live(trackUri).get('artists');
        var albumUri = album && album.uri;
        var artistUri = artists && artists.get(0) && artists.get(0).uri;

        if (albumUri) {
          track.album_uri = albumUri;
        }

        if (artistUri) {
          track.artist_uri = artistUri;
        }
      }

      if (opt_rowIds) {
        track.uid = '' + opt_rowIds[i];
      }

      tracks[i] = track;
    }

    var context = {
      pages: [{
        tracks: tracks
      }],
      metadata: {
        'zelda.context_uri': playOptions.context
      },
      entity_uri: getOriginUri(playOptions.context)
    };

    var options = {};
    if (typeof playOptions.index === 'number') {
      options.skip_to_index = {
        page: 0,
        track: playOptions.index
      };
    }

    if (shuffleMode.isEnabled()) {
      options.player_options_override = {
        'shuffling_context': true
      };
    }

    player.play(context, options, opt_callback);
  });
}

function playContext(context, playOptions, opt_callback) {
  if (shuffleMode.isEnabled()) {
    playOptions.player_options_override = {
      'shuffling_context': true
    };
  }

  if (playOptions.uid || playOptions.uri || playOptions.page) {
    playOptions.skip_to = {};
    if (playOptions.uid) {
      playOptions.skip_to.track_uid = playOptions.uid;
    } else if (playOptions.uri) {
      playOptions.skip_to.track_uri = playOptions.uri;
    }

    // Together with UID send page_index property, so Connect can
    // figure out where to look for a track that needs to
    // be played. (Connect doesn't support UIDs at the moment).
    if (playOptions.page) {
      playOptions.skip_to.page_index = playOptions.page;
    }
  }

  getPlayer(function (player) {
    player.play(context, playOptions || {}, opt_callback);
  });
}

function update(trackUris, opt_rowIds, playOptions, opt_callback) {
  getPlayer(function (player) {

    var length = trackUris.length;
    var tracks = new Array(length);

    // Todo: When currently playing from the new playlist and folder resolver,
    // uids provided by the core resolver need to be used.

    for (var i = 0; i < length; i++) {

      tracks[i] = {
        uri: trackUris[i]
      };
      if (opt_rowIds) tracks[i].uid = '' + opt_rowIds[i];
    }

    var context = {
      pages: [{
        tracks: tracks
      }],
      metadata: {
        'zelda.context_uri': playOptions.context
      },
      entity_uri: getOriginUri(playOptions.context)
    };

    player.update(context, opt_callback);
  });
}

function playFromResolver(contextUri, playOptions, opt_callback) {
  getPlayer(function (player) {
    cosmosUtil.sanitizeURL(contextUri, function (error, uri) {
      if (error) {
        if (opt_callback) opt_callback(error);
        return;
      }

      var context = {
        entity_uri: uri
      };

      var options = null;
      if (typeof playOptions.index === 'number') {
        options = {
          skip_to_index: {
            page: 0,
            track: playOptions.index
          }
        };
      } else if (playOptions.trackUri) {
        options = {
          skip_to_index: {
            track_uri: playOptions.trackUri
          }
        };
      }

      context.pages = [{ page_url: TRACK_RESOLVER_URI + encodeURI(uri) }];

      player.play(context, options, opt_callback);
    });
  });
}

var cancelSubscribe;

function subscribe(callback, options) {
  cancelSubscribe = false;
  options = options || {};

  var subscription;
  getPlayer(function (player) {
    if (cancelSubscribe) return;
    subscription = player.subscribe(function (error, response) {
      if (error) {
        return callback(error);
      }
      callback(null, addContext(response.getJSONBody()));
    }, options);
  });

  return {
    unsubscribe: function unsubscribe() {
      cancelSubscribe = true;
      if (!subscription) return;
      subscription.cancel();
      subscription = null;
    }
  };
}

function getState(callback) {
  getPlayer(function (player) {
    player.getState(function (error, response) {
      if (error) {
        callback(error, null);
      } else {
        callback(null, addContext(response.getJSONBody()));
      }
    });
  });
}

function pause(opt_callback) {
  getPlayer(function (player) {
    player.pause(opt_callback);
  });
}

function resume(opt_callback) {
  getPlayer(function (player) {
    player.resume(opt_callback);
  });
}

function clear() {
  player = null;
}

/**
 * Adds the context to a given player state.
 *
 * @param {Object} data Input data in the format of the cosmos player live model (v2).
 * @param {string?} opt_uri Optional URI to be used in first place.
 * @return {Object} Data object.
 */
function addContext(data, opt_uri) {
  var uri = opt_uri || // We provide the URI of the context.
  data.context_metadata['zelda.context_uri'] || // Best case scenario.
  data.context_uri || // No special context, use the standard one.
  data.track && data.track.uri || // If a track is present, use it.
  null; // Nothing found; there's nothing being played.

  var context = getOriginUri(uri);

  // Avoid writing it into the context. People should always use the context object.
  delete data.context_uri;

  if (uri) {
    data.variant = { uri: uri };
    data.context = { uri: context };
  } else {
    data.variant = null;
    data.context = null;
  }

  // Track and index are flagged as "optional", meaning that when the player is stopped
  // will not be returned. Because of the way "live" works (waiting for properties until
  // they're set), it could happen that we wait forever for "track" and "index". For
  // aoviding this, we set them both to "null".
  data.track = data.track || null;
  data.index = data.index || null;

  if (data.track) {
    data.uid = data.track.uid;
    delete data.track.uid;
  } else {
    data.uid = null;
  }

  return removeUnderscores(data);
}

/**
 * Returns the original URI from a given filtered & sorted URI. For example, given
 * this URL:
 *
 * spotify:internal:sortlist:desc:track(name):internal:filterlist:playable%20eq%20true:user:myuser:playlist:7h5o3lf1ithsxec0wgjznj
 *
 * This method would return:
 *
 * spotify:user:myuser:playlist:7h5o3lf1ithsxec0wgjznj
 *
 * @param {string} uri An internal URI format with sort and/or query parts.
 * @return {string} The original URI.
 */
function getOriginUri(uri) {
  if (!uri) {
    return uri;
  }

  var sorted = sortUriUtils.parse(uri);
  if (sorted) uri = sorted.originUri;

  var filtered = filterUriUtils.parse(uri);
  if (filtered) uri = filtered.originUri;

  return uri;
}

/**
 * Transforms C++ syntax for variable names and keys (underscore_names) to the JS format
 * (camelCase).
 */
function removeUnderscores(data) {
  var transformedKey;

  for (var key in data) {
    if (data.hasOwnProperty(key)) {
      transformedKey = key.replace(/_(.)/g, function (str, chr) {
        return chr.toUpperCase();
      });

      if (data[key] instanceof Object) {
        data[transformedKey] = removeUnderscores(data[key]);
      } else {
        data[transformedKey] = data[key];
      }

      if (transformedKey !== key) {
        delete data[key];
      }
    }
  }

  return data;
}

exports.play = play;
exports.playFromResolver = playFromResolver;
exports.playContext = playContext;
exports.pause = pause;
exports.resume = resume;
exports.update = update;
exports.subscribe = subscribe;
exports.getState = getState;
exports.clear = clear;
exports.addContext = addContext;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../../spotify-live":439,"../../spotify-live-filter-uri":371,"../../spotify-live-sort-uri":437,"../../spotify-shuffle-mode":491,"../util/cosmos":435,"./data":409,"spotify-cosmos-api":694,"spotify-player/lib/v2":714}],412:[function(require,module,exports){
'use strict';

var cosmos = require('../util/cosmos');

var sortUriUtils = require('../../spotify-live-sort-uri');
var filterUriUtils = require('../../spotify-live-filter-uri');
var coreSortParams = require('../../spotify-core-sort-params');

var PLAYLIST_RESOLVER = 'sp://core-playlist/v1/playlist/';

// Todo: This is playlist-desktop/src/core-datasource/parse-uri.js
// but it's much easier to make it common when we OneRepo™.
function parseURI(uri) {
  var parsedSortUri = sortUriUtils.parse(uri);
  if (parsedSortUri) uri = parsedSortUri.originUri;
  var parsedFilterUri = filterUriUtils.parse(uri);
  if (parsedFilterUri) uri = parsedFilterUri.originUri;
  return {
    uri: uri,
    sort: parsedSortUri,
    filter: parsedFilterUri
  };
}

function play(contextUri, options, opt_callback) {

  var parsed = parseURI(contextUri);

  var query = [];
  if (parsed.sort) {
    var direction = parsed.sort.direction === 'desc' ? 'DESC' : 'ASC';
    query.push('sort=' + encodeURIComponent(coreSortParams(parsed.sort.query, direction)));
  }

  var filters = [];
  if (parsed.filter) {
    var filtersFromQuery = parsed.filter.query.split(',').map(function (filter) {
      return encodeURIComponent(filter);
    });
    filters.push.apply(filters, filtersFromQuery);
  }
  if (filters.length) {
    query.push('filter=' + filters.join(','));
  }

  // Include a contextUri that is then reflected as the context in the player state
  query.push('uri=' + encodeURIComponent(contextUri));

  var queryString = '';
  if (query.length) {
    queryString = '?' + query.join('&');
  }

  var url = encodeURIComponent(parsed.uri);
  var resolverUrl = PLAYLIST_RESOLVER + url + '/play' + queryString;
  var postObject = { url: resolverUrl };
  if (options) postObject.body = options;

  cosmos.post(postObject, opt_callback);
}

module.exports = {
  play: play
};

},{"../../spotify-core-sort-params":254,"../../spotify-live-filter-uri":371,"../../spotify-live-sort-uri":437,"../util/cosmos":435}],413:[function(require,module,exports){
/**
 * @module spotify-live-models/player/updates
 * @private
 */
'use strict';

var lastRowsList;
var lastRowsListUri;
var lastRowsListHandler;
var lastRowsListReferrer;
var playerRowKey;
var playerKeys;

/**
 * Listen for updates on a rows list and update the player when
 * changes happen.
 *
 * @param {LiveList} rowsList A live list of rows.
 * @param {Object} options Object with options and data of what to play.
 * @param {Function} handler A handler function that gets called whenever
 *     the list is updated. Gets called with one argument: an options object.
 */
function listen(rowsList, options, handler) {
  if (lastRowsList) {
    removeRowsListener();
  }

  lastRowsList = rowsList;
  lastRowsListUri = options.context;
  lastRowsListReferrer = options.contextPlayerReferrer;

  lastRowsListHandler = function lastRowsListHandler() {
    // Todo: Only add this for TPM.
    options.index = getPlayingAndUpdateIndicesInList(rowsList).update;
    handler(options);
  };

  rowsList.on('update', lastRowsListHandler);
}

/**
 * Check if the last added rows listener is still valid for the current
 * player state, and clean up the update handler if it's not valid.
 *
 * @param {LiveObject} model The player live object.
 */
function clean(model) {
  if (!lastRowsListHandler) return;

  var context = model.get('variant');

  // Remove listener if the player context is no longer the same
  if ((context && context.uri) !== lastRowsListUri) {
    removeRowsListener();

    // Remove listener if the player referrer is no longer the same
  } else {
      var origin = model.get('playOrigin');
      var playerReferrer = origin && origin.get('referrerIdentifier');

      if (playerReferrer !== lastRowsListReferrer && !model.get('contextUpdatedCrossFrame')) {
        removeRowsListener();
      }
    }
}

/**
 * Save which item is currently playing.
 *
 * @param {number} index The index for the playing row.
 */
function setPlayingIndex(index, optRowsList) {
  if (!lastRowsList && !optRowsList) {
    return;
  }

  // If the index is out of bounds (e.g. is -1 because the track is not found),
  // then just keep the old playerRowKey.
  if (index < 0) {
    return;
  }

  var list = optRowsList || lastRowsList;

  playerRowKey = list.keys[index] || null;
  playerKeys = list.keys.slice();
}

/**
 * Remove the saved rows listener data.
 */
function removeRowsListener() {
  if (lastRowsList) {
    lastRowsList.off('update', lastRowsListHandler);
  }

  lastRowsList = null;
  lastRowsListUri = '';
  lastRowsListHandler = null;
  lastRowsListReferrer = '';
}

/**
 * Get the index of the playing row in the provided list.
 *
 * @param {LiveList} rowsList A live list of rows.
 *
 * @return {number} The index of the playing row, or -1 if not found.
 */
function getPlayingAndUpdateIndicesInList(rowsList) {
  if (!playerRowKey) return { update: -1, playing: -1 };

  // Find the currently playing row in the new list
  var playingIndexInNewList = rowsList.keys.indexOf(playerRowKey);
  var updateIndex = playingIndexInNewList;

  // If the playing row was not found in the new list, loop through the row
  // keys of the list that the player is currently playing from, and try to
  // find the next row key that exist both in the currently playing list and
  // the new list.
  if (playingIndexInNewList === -1) {
    var indexInPlayerList = playerKeys.indexOf(playerRowKey);
    for (var i = indexInPlayerList, l = playerKeys.length; i < l; i++) {
      updateIndex = rowsList.keys.indexOf(playerKeys[i]);
      if (updateIndex > -1) {

        // Index must be -1 since we've moved down several rows. The cosmos
        // player wants the index of the next row, so before passing it to
        // cosmos, the index will be incremented again.
        updateIndex--;

        break;
      }
    }
  }

  return {
    update: updateIndex,
    playing: playingIndexInNewList
  };
}

/**
 * Check if the player is currently playing from a rows list.
 *
 * @param {string} opt_uri Context URI. If passed, it checks for that specific URI.
 *
 * @return {boolean} True if it is playing from a rows list, false otherwise.
 */
function isPlayingFromRowsContext(opt_uri) {
  if (opt_uri) return lastRowsListUri === opt_uri;

  return !!lastRowsList;
}

exports.setPlayingIndex = setPlayingIndex;
exports.listen = listen;
exports.clean = clean;
exports.getPlayingAndUpdateIndicesInList = getPlayingAndUpdateIndicesInList;
exports.isPlayingFromRowsContext = isPlayingFromRowsContext;

},{}],414:[function(require,module,exports){
(function (global){
/**
 * @module spotify-live-models/playlist
 */
'use strict';

var contains = require('mout/array/contains');
var mixIn = require('mout/object/mixIn');
var intersection = require('mout/array/intersection');
var interpolate = require('interpolate');

var live = require('../spotify-live');
var liburi = require('spotify-liburi');

var cosmos = require('./util/cosmos');
var bridgeRequest = require('./util/bridge').request;
var debug = require('debug')('spotify-live-models:playlist');

var CLIENT = 'spotify:client';
var BACKOFF = 100;

var OFFLINE_STATUS = {
  NO: 'no',
  WAITING: 'waiting',
  DOWNLOADING: 'downloading',
  YES: 'yes'
};

var endpoints = {
  broadcast: 'sp://messages/v1/playliststate',
  'core-playlist': 'sp://core-playlist/v1/playlist'
};

function onBroadcast(error, response) {
  if (error) {
    if (global.console) console.error(error);
    return;
  }

  live(response.body.uri).update(response.body);
}

var offlineSubscriptions = {};

// This bridge call is only available in the C++ bridge and is used for
// updating subscribed/following state for the playlist.
function bridgeWaitAny(model) {
  bridgeRequest('playlist_event_wait_any', [model.uri], function (error, event) {
    // Bridge (tested in Zelda) has a bug [1] where the callbacks for
    // playlist_event_wait_any are mixed up, so that the response is
    // for a different playlist than the one that was requested.
    // By updating the live model for the URI in the event, and then
    // listen again for that model, we will update the correct models.
    // This should be removed when the bug is fixed. However, nothing
    // will break if it's still there.
    //
    // [1] https://jira.spotify.net/browse/KM-1241
    var eventModel = event && event.data.uri ? live(event.data.uri) : model;
    if (error) {
      setTimeout(function () {
        bridgeWaitAny(eventModel);
      }, BACKOFF);
      if (global.console) console.error(error);
      return;
    }

    if (event.type === 'change') {
      event.data.isFollowing = event.data.subscribed;
      event.data.added = event.data.subscribed;
      eventModel.update(event.data);
    }

    bridgeWaitAny(eventModel);
  });
}

function bridgeWait(model) {
  bridgeRequest('playlist_event_wait', [model.uri], function (error, event) {
    if (error) {
      // Hotfix 2014-10-20: We are matching temporary playlists with this model, and we're not sure
      // what the implications are if we wouldn't. For now we give up when we see a 'invalid-uri'
      // message
      if (error.name !== 'invalid-uri') {
        setTimeout(function () {
          bridgeWait(model);
        }, BACKOFF);
      }
      if (global.console) console.error(error);
      return;
    }

    // The only thing we need to care about here is 'change', other types like
    // 'insert', 'remove', 'move' aren't dealt with via bridge anymore.
    if (event.type === 'change') {
      model.update(event.data);
    }

    bridgeWait(model);
  });
}

function updateMetadata(model, needsImage) {
  bridgeRequest('playlist_metadata', [model.uri], function (error, payload) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }

    model.update(payload);

    // If the payload does not contain any images
    // we need to make a separate bridge request
    if (needsImage && !payload.images) {
      updateImage(model);
    }
  });
}

function updateImage(model) {
  bridgeRequest('playlist_profile', [model.uri], function (error, payload) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }
    if (!payload.image) payload.image = '';
    if (!payload.images) payload.images = [];
    model.update(payload);
  });
}

function updatePopularity(model) {
  bridgeRequest('playlist_popularity', [model.uri], function (error, payload) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }
    model.update(payload);
  });
}

function updateAnnotatedData(model) {
  var uriObject = liburi.from(model.uri);
  if (!uriObject || !uriObject.username || !uriObject.id) {
    debug('invalid uri for annotated data: %o', model.uri);
    model.update({ annotatedImage: null });
    return;
  }

  var encodedUsername = encodeURIComponent(uriObject.username);
  var playlistId = liburi.hexToId(uriObject.id);

  var url = interpolate('hm://playlist-annotate/v1/annotation/user/{username}/playlist/{id}', {
    username: encodedUsername,
    id: playlistId
  });

  cosmos.get({ url: url + '?format=json&bust=' + Date.now() }, function (error, response) {
    if (error) {
      model.update({
        annotatedImage: null
      });
      return;
    }

    var body = response.body;
    model.update({
      annotatedImage: body && body.picture || null
    });
  });
}

function onWait(model, properties) {
  var needsShouldBeOffline = contains(properties, 'shouldBeOffline');
  var needsOfflineStatus = contains(properties, 'offlineStatus');
  var needsOfflineProgress = contains(properties, 'offlineProgress');
  var needsPlayable = contains(properties, 'playable');
  var needsPopularity;
  var needsImage;
  var needsMetadata;
  var needsAnnotatedData;
  var needsFormatListType = contains(properties, 'formatListType');

  var metaFields = ['collaborative', 'subscribed', 'published', 'name', 'owner', 'description', 'allows'];

  properties.forEach(function (key) {
    if (key === 'popularity') needsPopularity = true;
    if (key === 'image' || key === 'images') {
      needsImage = true;
    }
    if (key === 'annotatedImage') {
      needsAnnotatedData = true;
    }
    if (!needsMetadata && contains(metaFields, key)) needsMetadata = true;
  });

  if (needsMetadata) updateMetadata(model, needsImage);else if (needsImage) updateImage(model);

  if (needsAnnotatedData) updateAnnotatedData(model);

  if (needsPopularity) updatePopularity(model);

  if (needsShouldBeOffline || needsOfflineProgress || needsOfflineStatus) updateOffline(model);

  if (needsPlayable) updateAndSubscribePlayable(model);

  if (needsFormatListType) updateFormatListType(model);
}

function onInit(model) {
  bridgeWait(model);
  if (global._getSpotifyModule) {
    bridgeWaitAny(model);
  }
}

function onPublish(model, properties) {
  // Only shouldBeOffline is handled here
  if (!properties.hasOwnProperty('shouldBeOffline')) {
    return;
  }

  live(CLIENT).query('session(capabilities(offlineSync))', function (error, data) {
    if (error && global.console) console.error(error);
    if (error || !data.session.capabilities.offlineSync) {
      sendCantOfflineMessage();
    } else {
      var shouldBeOfflineValue;

      if ('shouldBeOffline' in properties) shouldBeOfflineValue = !!properties.shouldBeOffline;

      if (shouldBeOfflineValue !== undefined) {
        // optimistic update, this gets reverted somewhere else
        updateModelWithOffline(model, { offline_availability: shouldBeOfflineValue ? 'yes' : 'no' });
        publishShouldBeOffline(model, shouldBeOfflineValue);
      }
    }
  }, live.ASAP);
}

function onUpdate(model, data) {
  if ('offlineStatus' in data) {
    var shouldBeOffline = model.get('shouldBeOffline');
    var isDownloading = data.offlineStatus === OFFLINE_STATUS.DOWNLOADING;
    var shouldSubscribe = shouldBeOffline && isDownloading;

    if (shouldSubscribe) {
      subscribeToOfflineProgress(model);
    } else {
      unsubscribeToOfflineProgress(model);
    }
  }
}

function updateOffline(model) {
  cosmos.subscribe({ url: 'sp://offline/v1/resources?uri=' + model.uri }, function (error, response) {

    if (!error) {
      var resource = response.body.resources;
      updateModelWithOffline(model, resource);
    } else {
      // Status -104 means 'No endpoint resolver that could handle the request was found'.
      // If that's the case, we try the old bridge offline messages, and if that's not supported,
      // we treat it like the client doesn't support offline.
      if (error.response && error.response.getStatusCode() === -104) {

        // Desktop detection using the C++ bridge function
        if (global._getSpotifyModule) {
          bridgeRequest('offline_query_state', [model.uri], function (error, data) {
            if (error) {
              if (global.console) console.error(error);
              return;
            }
            updateModelWithOffline(model, { offline_availability: data.enabled ? 'yes' : 'no' });
          });

          // Client doesn't support offline, so set the offline status to 'no'
        } else {
            updateModelWithOffline(model, { offline_availability: 'no' });
          }
      } else {
        if (global.console) console.error(error);
        return;
      }
    }
  });
}

function updateModelWithOffline(model, resource) {
  var shouldBeOffline = false;
  var progress;

  switch (resource.offline_availability) {
    case OFFLINE_STATUS.WAITING:
      shouldBeOffline = true;
      progress = 0;
      break;
    case OFFLINE_STATUS.DOWNLOADING:
      shouldBeOffline = true;
      break;
    case OFFLINE_STATUS.YES:
      shouldBeOffline = true;
      progress = 1;
      break;
    case OFFLINE_STATUS.NO:
      progress = 0;
      break;
  }

  // Updating this one will cause the 'update' event to start listening for
  // progress changes and update offlineProgress.
  model.update({
    shouldBeOffline: shouldBeOffline,
    offlineStatus: resource.offline_availability
  });

  if (progress !== undefined) {
    model.update({
      offlineProgress: progress
    });
  }
}

function updateAndSubscribePlayable(model) {
  // Todo: It would be nice to take the users cache state into account,
  // a ticket for that: KM-8283. 'playable' would then change meaning from
  // 'according to track metadata' to 'according to track metadata and cache
  // state when offline', but that can be seen as a progressive enhancement.
  var playableRows = endpoints['core-playlist'] + '/' + encodeURIComponent(model.uri) + '/metadata?&filter=playable%20eq%20true';
  cosmos.subscribe({
    url: playableRows,
    body: {
      policy: {
        length: true
      }
    }
  }, function (error, response) {
    if (!error) {
      model.update({ playable: !!response.body.metadata.length });
    } else {
      console.error(error);
    }
  });
}

function updateFormatListType(model) {
  var url = 'sp://core-playlist/v1/playlist/' + encodeURIComponent(model.uri) + '/metadata';

  cosmos.get({ url: url }, function (error, response) {
    var formatListType = 'playlist';
    if (!error && response.body && response.body.metadata && response.body.metadata.formatListType) {
      formatListType = response.body.metadata.formatListType;
    }
    model.update({
      formatListType: formatListType
    });
  });
}

function subscribeToOfflineProgress(model) {
  var subscription = offlineSubscriptions[model.uri];
  if (subscription) {
    return;
  }
  offlineSubscriptions[model.uri] = cosmos.subscribe({ url: 'sp://offline/v1/progress?uri=' + model.uri }, function (error, response) {

    if (!error) {
      var progress = response.body.progress;
      model.update({ offlineProgress: progress.percent_complete / 100 || 0 });

      // unsubscribe to offline progress messages when the download is complete
      // (sometimes after a complete download we receive a progress event of 0)
      if (progress.percent_complete === 100) {
        unsubscribeToOfflineProgress(model);
      }
    } else {
      // Status -104 means 'No endpoint resolver that could handle the request was found'.
      // If that's the case, we try the old bridge offline messages, and if that's not supported,
      // we treat it like the client doesn't support offline.
      if (error.response && error.response.getStatusCode() === -104) {

        // Desktop detection using the C++ bridge function
        if (global._getSpotifyModule) {
          bridgeRequest('offline_query_state', [model.uri], function (error, data) {
            if (error) {
              if (global.console) console.error(error);
              return;
            }
            model.update({ offlineProgress: data.enabled ? 1 : 0 });
          });

          // Client doesn't support offline, so set the offline status to 'no'
        } else {
            model.update({ offlineProgress: 0 });
          }
      } else {
        if (global.console) console.error(error);
        return;
      }
    }
  });
}

function unsubscribeToOfflineProgress(model) {
  var subscription = offlineSubscriptions[model.uri];
  if (!subscription) {
    return;
  }

  subscription.cancel();
  delete offlineSubscriptions[model.uri];
}

function publishShouldBeOffline(model, enabled) {
  var method = enabled ? 'post' : 'delete';
  cosmos[method]({ url: 'sp://offline/v1/resources?uri=' + model.uri }, function (error, response) {

    if (error) {
      // Status -104 means 'No endpoint resolver that could handle the request was found'.
      // If that's the case, we try the old bridge offline messages, and if that's not supported,
      // we treat it like the client doesn't support offline.
      if (error.response && error.response.getStatusCode() === -104) {

        // Desktop detection using the C++ bridge function
        if (global._getSpotifyModule) {
          var message = enabled ? 'offline_enable_sync' : 'offline_disable_sync';
          bridgeRequest(message, [model.uri], function (error, data) {

            // Revert the state if it failed
            if (error) {
              updateModelWithOffline(model, {
                offline_availability: enabled ? 'no' : 'yes'
              });
            }
          });

          // Client doesn't support offline, so set the offline status to 'no'
        } else {
            updateModelWithOffline(model, {
              offline_availability: enabled ? 'no' : 'yes'
            });
          }
      } else {
        updateModelWithOffline(model, {
          offline_availability: enabled ? 'no' : 'yes'
        });
      }
    }
  });
}

function sendCantOfflineMessage() {
  cosmos.post({
    url: 'sp://messages/v1/container/user-message',
    body: {
      id: 'cant-offline-playlists'
    }
  });
}

var regExp = exports.matches = /^spotify:user:(.*):playlist|^spotify:internal:temp_playlist:|^spotify:temp-playlist:/;
var broadcastSubscription;
var registered;
exports.register = function () {
  if (registered) return;
  registered = true;

  live.subscribe(regExp, 'wait', onWait);
  live.subscribe(regExp, 'init', onInit);
  live.subscribe(regExp, 'publish', onPublish);
  live.subscribe(regExp, 'update', onUpdate);

  broadcastSubscription = cosmos.subscribe({ url: endpoints.broadcast }, onBroadcast);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  live.unsubscribe(regExp, 'wait', onWait);
  live.unsubscribe(regExp, 'init', onInit);
  live.unsubscribe(regExp, 'publish', onPublish);
  live.unsubscribe(regExp, 'update', onUpdate);

  broadcastSubscription.cancel();
  broadcastSubscription = null;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-live":439,"./util/bridge":433,"./util/cosmos":435,"debug":526,"interpolate":565,"mout/array/contains":625,"mout/array/intersection":634,"mout/object/mixIn":667,"spotify-liburi":707}],415:[function(require,module,exports){
(function (global){
/**
 * @module spotify-live-models/session-storage
 */
'use strict';

var forOwn = require('mout/object/forOwn');
var combine = require('mout/array/combine');
var remove = require('mout/array/remove');
var contains = require('mout/array/contains');

var URI = 'spotify:session-storage';
var live = require('../spotify-live');
var cosmos = require('./util/cosmos');
var endpoints = {
  broadcast: 'sp://messages/v1/session-storage'
};

var waiting = [];

function onInit(model) {
  // Set a flag for showing that the model has been implemented and
  // registered. This is so that we can check this in player without
  // making a breaking change.
  model.update({ implemented: true });
}

function onWait(model, properties) {
  // Ask the top frame to broadcast the properties.
  // Values will be null when they weren't stored.
  waiting = combine(waiting, properties);
  global.top.postMessage({
    type: 'session_storage',
    name: 'broadcast_session_storage',
    data: properties
  }, '*');
}

function onPublish(model, properties) {
  // Tell the top frame to persist and broadcast
  global.top.postMessage({
    type: 'session_storage',
    name: 'set_session_storage',
    data: properties
  }, '*');

  // Optimistic update
  model.update(properties);
}

function onBroadcast(error, event) {
  var update = {};
  var model = live(URI);

  forOwn(event.body, function (value, key) {

    // Update model if this instance of storage knows that the model waits for it
    var isWaiting = contains(waiting, key);

    // Or if the model has a potentially outdated value in the live cache
    var hasKey = model.get(key) !== undefined;

    if (isWaiting || hasKey) update[key] = value;
    if (isWaiting) remove(waiting, key);
  });
  model.update(update);
}

var broadcastSubscription;
var regExp = exports.matches = new RegExp('^' + URI + '$');
var registered;

exports.register = function () {
  if (registered) return;
  registered = true;

  live.subscribe(regExp, 'init', onInit);
  live.subscribe(regExp, 'wait', onWait);
  live.subscribe(regExp, 'publish', onPublish);
  broadcastSubscription = cosmos.subscribe({ url: endpoints.broadcast }, onBroadcast);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  live.unsubscribe(regExp, 'init', onInit);
  live.unsubscribe(regExp, 'wait', onWait);
  live.unsubscribe(regExp, 'publish', onPublish);

  if (broadcastSubscription) {
    broadcastSubscription.cancel();
    broadcastSubscription = null;
  }
  waiting.length = 0;
};

exports._endpoints = endpoints;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-live":439,"./util/cosmos":435,"mout/array/combine":624,"mout/array/contains":625,"mout/array/remove":636,"mout/object/forOwn":663}],416:[function(require,module,exports){
"use strict";

/**
 * This module splits up a list into many chunks.
 *
 * @module spotify-live-models/sorting/chunker
 * @private
 */

/**
 * Splits up an array of data into smaller chunks.
 *
 * @param {Array} list The array to be split up.
 * @param {number=} opt_size Optional size of each chunk.
 *
 * @return {Array} Array of chunks, where each chunk is an array of data.
 */
module.exports = function (list, opt_size) {

  function split(array, segments) {
    segments = segments || 2;
    var results = [];
    if (array == null) {
      return results;
    }

    var minLength = Math.floor(array.length / segments);
    var remainder = array.length % segments;
    var i = 0;
    var len = array.length;
    var segmentIndex = 0;
    var segmentLength;

    while (i < len) {
      segmentLength = minLength;
      if (segmentIndex < remainder) {
        segmentLength++;
      }

      results.push(array.slice(i, i + segmentLength));

      segmentIndex++;
      i += segmentLength;
    }

    return results;
  }

  var size = opt_size || 50;
  var chunkCount = Math.ceil(list.length / size);
  var chunks = split(list, chunkCount);

  return chunks;
};

},{}],417:[function(require,module,exports){
/**
 * This file contains transformations from legacy sort queries to new sort
 * queries. We need this because when a user sorts by a certain column, we store
 * the full URI for that list and the sort query is part of the URI. Whenever
 * we change the sort query of a column, we will break sorting for users who
 * have a stored sort state with the old query. That's why we need to maintain
 * this conversion from old to new to make the right list load for all users.
 *
 * When to remove a conversion needs to be weighed case by case I guess. If a
 * user sorts by a certain column and doesn't launch the client for three months
 * and we change the query during that time, it's expected to still work for
 * that user when logging in the next time.
 *
 * History of this file is in the play-desktop app,
 * https://ghe.spotify.net/zelda/client-zelda-js/blob/master/apps/playlist-desktop/src/legacy-sort-uris.js
 */
'use strict';

exports.legacyQueries = {
  // Change date: 2015-03-16
  'track(album(name))': 'track(album(name),disc,number)',
  // Change date: 2015-03-16
  'track(artists(name))': 'track(artists[0:1](name),album(name),disc,number)',
  // Change date: 2015-03-17, value changed 2015-07-14 because we introduced the conversion below.
  'track(addedBy)': 'addedBy(name)',
  // Change date: 2015-07-14
  'track(addedBy(name))': 'addedBy(name)',
  // Change date: 2015-06-26
  'timeSinceAdded': 'timeSinceAdded,track(album(name),disc,number)'
};

},{}],418:[function(require,module,exports){
'use strict';

/**
 * This module helps posting chunked data to/from a worker.
 *
 * @module spotify-live-models/sorting/poster
 * @private
 */

/**
 * Posts data from/to a worker.
 *
 * @param {Object} worker A web worker.
 * @param {Array} chunks Array of split up data.
 * @param {number} index Index of the current chunk to post. Initiate the
 *     poster with 0, and it posts all data sequentially until all data
 *     is posted.
 * @param {string} id An ID for the full payload.
 */
module.exports = function poster(worker, chunks, index, id) {
  'use strict';

  var data = {
    items: chunks[index],
    id: id
  };

  if (index === chunks.length - 1) {
    data.last = true;
  }

  worker.postMessage(data);

  if (!data.last) {
    poster(worker, chunks, index + 1, id);
  }
};

},{}],419:[function(require,module,exports){
(function (global){
'use strict';

/**
 * This module sorts an array of data in the best possible way.
 * If Web Workers are supported, it will spawn new workers and
 * sort on different threads to speed it up.
 *
 * @module spotify-live-models/sorting/sort
 * @private
 */

var chunker = require('./chunker');
var poster = require('./poster');
var sorter = require('./sorter');
var sortWorker = require('./sortworker');
var defer = require('prime/defer');

var workerFile;
var workers = {};
var callbacks = {};
var waitingForReset = {};

// A generated ID will be stored here for each sorted list. Whenever a sorted
// list is asked to resort, a new ID will be generated and set here for that
// list. That allows us to cancel a previous sort if a newer one has started
// before the old one finished.
var idCounter = 0;
var lastIds = {};

/**
 * The local sorter that sorts on the main thread.
 *
 * @param {string} sortUri URI of the sorted list.
 * @param {Array.<Object>} items Array of items to sort. Each item is
 *     an object with the properties `data` and `key`. The `data`
 *     property is an array of values to sort on. The `key` property
 *     is a string for the row ID.
 * @param {Function} callback Async callback where the data is the array of
 *     sorted items.
*/
function localSorter(sortUri, items, callback) {
  items = sorter(items);

  // Saving the callback as the latest callback for this sorted list
  // will allow us to only respond with the latest sorted values (if
  // multiple sort calls were made at the same time).
  callbacks[sortUri] = callback;

  // Make the callback async
  defer(function () {

    // Only allow the latest callback to run
    if (callback === callbacks[sortUri]) {
      delete callbacks[sortUri];

      callback(null, items);
    }
  });
}

/**
 * The Web Worker sorter.
 *
 * @param {string} sortUri URI of the sorted list.
 * @param {Array.<Object>} items Array of items to sort. Each item is
 *     an object with the properties `data` and `key`. The `data`
 *     property is an array of values to sort on. The `key` property
 *     is a string for the row ID.
 * @param {Function} callback Async callback where the data is the array of
 *     sorted items.
 */
function workerSorter(sortUri, items, callback) {
  var worker = workers[sortUri];

  // If we already have a worker for this sorted list, reset that worker
  // and tell it to sort the new data. By saving the callback we make sure
  // that the original worker event handler will run the latest callback
  // when the sorting is done.
  if (worker) {
    callbacks[sortUri] = callback;
    waitingForReset[sortUri] = (waitingForReset[sortUri] || 0) + 1;
    var id = (++idCounter).toString(36);
    lastIds[sortUri] = id;
    worker.postMessage({ reset: true, newId: id });
    sendItemsToWorker(items, worker, id);
    return;
  }

  worker = new Worker(workerFile);
  workers[sortUri] = worker;
  callbacks[sortUri] = callback;

  var id = (++idCounter).toString(36);
  lastIds[sortUri] = id;
  sendItemsToWorker(items, worker, id);

  var result = { items: [] };

  worker.addEventListener('message', function (event) {
    onWorkerMessage(event, result, sortUri);
  }, false);
}

/**
 * Event handler for receiving a message from a worker.
 * This will handle collecting all chunks of data and post it to the latest
 * callback when all chunks have been received.
 *
 * @param {Event} event An event object from the worker 'message' event.
 * @param {Object} result An object with a property `items` for the sorted items.
 * @param {string} sortUri The sort URI for the current sort.
 */
function onWorkerMessage(event, result, sortUri) {

  // When the main thread tells the worker to reset, the worker will respond with
  // a message to reset the array of already sorted items.
  if (event.data.reset) {
    waitingForReset[sortUri]--;
    result.items.length = 0;
    return;
  }

  // Skip messages that don't belong to the latest sort
  if (event.data.id !== lastIds[sortUri]) {
    return;
  }

  // If we are still waiting for reset messages, don't continue to add more items
  // to the list of sorted items.
  if (waitingForReset[sortUri]) {
    return;
  }

  // If we are not waiting for any resets, just save the chunk of sorted items.
  result.items = result.items.concat(event.data.items);

  // When all data has been passed over from the worker, kill the worker and run
  // the latest registered callback for this sorted list.
  if (event.data.last) {
    workers[sortUri].terminate();

    var callback = callbacks[sortUri];
    delete callbacks[sortUri];
    delete workers[sortUri];

    callback(null, result.items);
  }
}

/**
 * Create the Web Worker file path.
 * Since the worker can't share objects with the main thead, we can't share
 * dependencies. To solve this, we convert the dependencies to strings and pass
 * them as arguments to the worker file.
 * To circumvent the need of a separate file for the worker, we make the worker
 * itself and the passed dependencies a single string and make a blob out of it.
 * From the blob we can get a URL that we can pass to the worker constructor.
 *
 * @return {string} Blob URL that can be passed to the worker.
 */
function createWorkerFile() {
  var workerStr = sortWorker.toString();
  var sortStr = sorter.toString();
  var chunkerStr = chunker.toString();
  var posterStr = poster.toString();
  var argsStr = [sortStr, chunkerStr, posterStr].join(', ');
  var stringWorker = '(' + workerStr + ')(' + argsStr + ')';

  var blob = new Blob([stringWorker], { type: 'text/javascript' });
  var url = URL.createObjectURL(blob);

  return url;
}

/**
 * Send the provided items to the provided worker. It will do this by splitting
 * the items into chunks and sending the chunks.
 *
 * @param {Array} items An array of items.
 * @param {Worker} worker A worker instance.
 * @param {string} id The ID for the payload.
 */
function sendItemsToWorker(data, worker, id) {
  var chunks = chunker(data);
  poster(worker, chunks, 0, id);
}

/**
 * Get the sort function to use.
 * If Web Workers are supported, it will use that, otherwise it will use the
 * default sorter on the main thread.
 * Having the code in a function allows for testing where worker support can
 * be removed and added while running the tests.
 *
 * @return {Function} The sorter function.
 */
function getSorter() {
  if (global.Worker && global.Blob && global.URL) {
    if (!workerFile) {
      workerFile = createWorkerFile();
    }
    return workerSorter;
  } else {
    return localSorter;
  }
}

/**
 * Sort the data using the best supported method.
 *
 * @param {string} sortUri URI of the sorted list.
 * @param {Array.<Object>} items Array of items to sort. Each item is
 *     an object with the properties `data` and `key`. The `data`
 *     property is an array of values to sort on. The `key` property
 *     is a string for the row ID.
 * @param {Function} callback Async callback where the data is the array of
 *     sorted items.
 */
module.exports = function (sortUri, items, callback) {
  var sort = getSorter();
  sort(sortUri, items, callback);
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./chunker":416,"./poster":418,"./sorter":420,"./sortworker":421,"prime/defer":676}],420:[function(require,module,exports){
'use strict';

/**
 * This module sorts an array of data.
 *
 * @module spotify-live-models/sorting/sorter
 * @private
 */

/**
 * Sorts an array of data. Supports multiple levels of values
 * (if two items are the same, it tests the values in the next level).
 *
 * @param {Array.<Object>} data Array of items to sort. Each item is
 *     an object with the properties `data` and `key`. The `data`
 *     property is an array of values to sort on. The `key` property
 *     is a string for the row ID.
 *
 * @return {Array.<Object>} A new array of the same objects that were
 *     passed in, but sorted.
 */
module.exports = function (data) {
  'use strict';

  data.sort(function (a, b) {

    var length = a.data.length;

    for (var i = 0; i < length; i++) {
      var aValue = a.data[i];
      var bValue = b.data[i];

      var aNumber = parseInt(aValue, 10);
      var bNumber = parseInt(bValue, 10);

      var aStartsWithNumber = !isNaN(aNumber);
      var bStartsWithNumber = !isNaN(bNumber);

      if (aStartsWithNumber && bStartsWithNumber) {
        if (aNumber < bNumber) return -1;
        if (aNumber > bNumber) return 1;
      } else if (aStartsWithNumber) {
        return -1;
      } else if (bStartsWithNumber) {
        return 1;
      }

      if (aValue.localeCompare) {
        var value = aValue.localeCompare(bValue);
        if (value !== 0) return value;
      } else {
        if (aValue < bValue) return -1;
        if (aValue > bValue) return 1;
      }
    }
  });

  return data;
};

},{}],421:[function(require,module,exports){
'use strict';

/**
 * This is the Web Worker file that sorts the data and passes it back again.
 * The file cannot be passed directly to new Worker(), as it needs some
 * dependencies. These dependencies are required before creating the worker,
 * and then serialized together with this file into a single blob, which is
 * used to create the worker.
 *
 * @module spotify-live-models/sorting/sortworker
 * @private
 */

/**
 * Sort worker.
 *
 * @param {Function} sort Function that sorts an array of data based on a
 *     property.
 * @param {Function} chunk Function that splits up data into chunks.
 * @param {Function} post Function that posts chunks of data back to main
 *     thread.
 * @param {Object} opt_worker Optional worker instance (mainly for testability).
 */
module.exports = function (sort, chunk, post, opt_worker) {
  'use strict';

  var worker = opt_worker || self;

  var itemsToSort = [];
  var id = null;

  worker.addEventListener('message', function (event) {

    // When the main thread tells the worker to reset, the worker will respond with
    // a message to reset the array of already sorted items.
    if (event.data.reset) {
      itemsToSort.length = 0;
      id = event.data.newId;
      worker.postMessage({ reset: true, newId: id });
      return;
    }

    // Only set the stored id for the first message
    if (id === null) {
      id = event.data.id;
    }

    // If the event id does not match the stored id, don't do anything.
    // This allows a sort to be aborted in the middle.
    if (id !== event.data.id) {
      return;
    }

    itemsToSort = itemsToSort.concat(event.data.items);

    if (event.data.last) {
      var sortedItems = sort(itemsToSort);
      var chunks = chunk(sortedItems);
      post(worker, chunks, 0, id);
    }
  }, false);
};

},{}],422:[function(require,module,exports){
'use strict';

/**
 * Get the row values used for sorting.
 *
 * @module spotify-live-models/sorting/values
 * @private
 */

/**
 * Get the values from the row based on the passed mask.
 * String values will be sanitized (lowercase, removing articles like 'the' etc).
 * The values can then be used for sorting.
 *
 * @param {Object} mask A mask object from the query parser.
 * @param {Object} row Row data object.
 *
 * @return {Array>} Array of values to sort on.
 *
 * @example
 * var parse = require('../../spotify-live/util/parser');
 * var mask = parse('track(name), track(artists(name))').mask;
 * var row = {track: {name: 'Track', artists: [{name: 'Artist'}]}};
 * var values = getValues(mask, row);
 * console.log(values);
 * // ['track', 'artist']
 */
function getValues(mask, row) {
  var result = [];
  mask.forEach(function (m) {
    var k = m.key;
    var value = row[k];

    // If the value is an array, we will concatenate all the
    // values with a comma in between, so that sorting takes
    // all values into account. An example is sorting tracks
    // based on 'artists(name)', where there can be many
    // artists for a track. We will in that case concatenate
    // all artists with comma in between and use a string with
    // all the artists when we compare in the sort function.
    if (Array.isArray(value)) {
      if (m.mask) {
        var values = [];
        for (var i = 0, l = value.length; i < l; i++) {
          values = values.concat(getValues(m.mask, value[i]));
        }
        result.push(values.join(', '));
      } else {
        result.push(value.join(', '));
      }
    } else {
      if (m.mask) result.push.apply(result, getValues(m.mask, value));else result.push(value);
    }
  });

  result = sanitizeStrings(result);

  return result;
}

/**
 * Sanitize string values. This includes trimming whitespace, converting
 * the string to lower case and removing common articles like 'the'.
 *
 * @param {Array} values Array of values.
 *
 * @return {Array} A new array of sanitized values.
 */
function sanitizeStrings(values) {
  var numberRe = /\b[0-9]+\b/g;
  var pad = '000000';

  return values.map(function (value) {
    if (typeof value !== 'string') return value;

    value = value.toLowerCase();

    // Remove the first article
    var articles = ['the ', '(the) '];
    for (var i = 0, article; article = articles[i]; i++) {
      if (value.indexOf(article) === 0) {
        value = value.replace(article, '');
        break;
      }
    }

    // Zero-pad numbers for natural numeric sorting (i.e. 2 before 10)
    value = value.replace(numberRe, function (match) {
      if (match.length >= pad.length) return match;
      return pad.substr(0, pad.length - match.length) + match;
    });

    return value.trim();
  });
}

module.exports = getValues;

},{}],423:[function(require,module,exports){
(function (global){
/**
 * @module spotify-live-models/sortlist
 */
'use strict';

var live = require('../spotify-live');
var mixIn = require('mout/object/mixIn');

var Range = require('../spotify-range2');
var diff = require('../spotify-live/util/diff');
var parse = require('../spotify-live/util/parser');
var sortUriUtils = require('../spotify-live-sort-uri');
var listOperations = require('spotify-live-list-operations');

var sort = require('./sorting/sort');
var getValues = require('./sorting/values');

// A generated ID will be stored here for each sorted list. Whenever a sorted
// list is asked to resort, a new ID will be generated and set here for that
// list. That allows us to cancel a previous sort if a newer one has started
// before the old one finished.
var idCounter = 0;
var lastIds = {};

/**
 * Event handler for the live 'init' event on sorted models. Keeps sorted model
 * and tracking model in sync (properties, not rows).
 *
 * This will set up an update listener for the tracking model, so that any
 * changes to the tracking model are also applied to the sort model.
 *
 * This also sets up a publish listener for the sorted model, so that anything
 * that is published on the sorted model gets published on the tracking model,
 * which can then update backend with the data and then update the tracking
 * model with the correct data, which will then trickle back down to the
 * sorted model.
 *
 * @param {LiveObject} sortModel The sorted live model.
 */
function onInit(sortModel) {
  var trackingModel = getTrackingModel(sortModel.uri);

  lastIds[sortModel.uri] = (++idCounter).toString(36);

  // Update the sorted model when any property on the tracking model changes (except rows)
  trackingModel.on('update', function (properties) {
    var updateObject = mixIn({}, properties);
    delete updateObject.rows;
    sortModel.update(updateObject);
  });

  // Update the tracking model when any property on the sort model changes (except rows)
  sortModel.on('publish', function (properties) {
    var updateObject = mixIn({}, properties);
    delete updateObject.rows;
    trackingModel.publish(updateObject);
  });
}

/**
 * Event handler for the live 'wait' event on sorted models.
 * This will fetch any requested property from the tracking model, or if
 * rows are requested, it will perform a sort of the rows from the tracking
 * model.
 *
 * It will also listen for changes. If a change is published on the sorted list,
 * it will be republished on the tracking list. When the tracking list is updated
 * with the new data (maybe after a save on the backend), the sorted list will be
 * updated and resorted if needed.
 *
 * @param {LiveObject} sortModel The sorted live model.
 * @param {Array} properties Array of properties that the model is waiting for.
 */
function onWait(sortModel, properties) {
  var trackingModel = getTrackingModel(sortModel.uri);

  properties.forEach(function (key) {

    // Requesting rows will create a live list of rows, perform sorting,
    // fill the list with the sorted items and also start to listen for changes.
    if (key === 'rows') {
      setRowsProperty(sortModel, trackingModel);

      // Requesting any other property than rows will just get that property from
      // the tracking model.
    } else {
        trackingModel.get(key, function (error, value) {
          if (error) {
            if (global.console) console.error(error);
            return;
          }
          var obj = {};
          obj[key] = value;
          sortModel.update(obj);
        });
      }
  });
}

/**
 * Set the `rows` property on the sort model. It will create a new live list
 * and perform sorting based on the rows of the tracking model. It will also
 * set up listeners for any changes to the lists to automatically keep
 * everything in sync.
 *
 * @param {LiveObject} sortModel The live object for the sorted list.
 * @param {LiveObject} trackingModel The live object for the list the sorted
 *     list is tracking.
 */
function setRowsProperty(sortModel, trackingModel) {
  var sortParams = sortUriUtils.parse(sortModel.uri);
  var direction = sortParams.direction;
  var query = sortParams.query;

  // Start the first sort
  performRowSorting(trackingModel, sortModel, query, direction);

  // Whenever a publish call happens on the sorted list, publish it to the
  // tracking list.
  sortModel.get('rows', function (error, sortList) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }
    sortList.on('publish', function (operations) {
      var trackingList = trackingModel.get('rows');
      if (!trackingList) return;
      syncRows(trackingList, operations, 'publish');
    });
  });

  // We need to get the rows list of the tracking model to be able to know the
  // length of the list, so that we can create the rows list for the sorted list.
  trackingModel.get('rows', function (error, trackingList) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }

    // Listen for updates on the tracking list and apply the changes (and
    // maybe resort if needed) on the sorted list.
    trackingList.on('update', function (operations) {
      var sortList = sortModel.get('rows');
      if (!sortList) return;
      var mustSort = syncRows(sortList, operations, 'update');
      if (mustSort) performRowSorting(trackingModel, sortModel, query, direction);
    });
  });
}

/**
 * Get the tracking model for a sort URI.
 * For an ascending sort URI, the tracking model would be the original list.
 * For a descending sort URI, the tracking model would be the ascending sort list.
 *
 * @param {string} sortUri The sort URI.
 *
 * @return {LiveObject} The live object for the tracking model.
 */
function getTrackingModel(sortUri) {
  var parsed = sortUriUtils.parse(sortUri);
  var direction = parsed.direction;
  var originUri = parsed.originUri;
  var query = parsed.query;

  // We can use the sorting from the ascending list when requesting the
  // descending list, by just depending on the ascending list. Asking for
  // data from the ascending list will make that list ask for the data
  // from the original list and then sort it, and then the descending list
  // will reverse that.
  if (direction === 'desc') {
    return live(sortUriUtils.create(originUri, 'asc', query));
  } else {
    return live(originUri);
  }
}

/**
 * Get data that is needed for performing a sort.
 *
 * @param {Array.<Object>} rows Array of objects of metadata about the rows.
 * @param {Object} mask A mask object from the query parser.
 * @param {LiveList} trackingList The live list for the list the sorted
 *     list is tracking.
 *
 * @return {Array.<Object>} A new array of items used for sorting. Each item is
 *     an object with the properties `data` and `key`. The `data`
 *     property is an array of values to sort on. The `key` property
 *     is a string for the row ID.
 *
 * @example
 * {
 *   data: ['Name of Song', 'Whatever', 100, 0],
 *   key: '0'
 * }
 */
function getSortData(rows, mask, trackingList) {
  return rows.map(function (row, i) {
    var array = getValues(mask, row);
    array.push(i);
    return { data: array, key: trackingList.keys[i] };
  });
}

/**
 * Perform sorting of all rows in a list.
 *
 * @param {LiveObject} trackingModel The model that the sort model is tracking.
 *     For ascending lists, this is the original model. For descending lists,
 *     this is the ascending sort model.
 * @param {LiveObject} sortModel The model to perform the sort on.
 * @param {string} sortQuery The sort query (live compatible query).
 * @param {string} sortDirection The sort direction ('asc' or 'desc').
 */
function performRowSorting(trackingModel, sortModel, sortQuery, sortDirection) {
  lastIds[sortModel.uri] = (++idCounter).toString(36);
  var sortId = lastIds[sortModel.uri];

  // Querying the rows of the tracking model might perform a sort. An example is when
  // getting the sort for a descending list, it will query the rows from the ascending
  // list, which will in turn query the rows from the original list and then perform a
  // sort. When the ascending sort is done, the query will be done and the descending
  // list can just use the ascending list and reverse it.
  trackingModel.get('rows', function (error, rows) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }

    // Create a list of loaded rows. This allows partial loading of a list,
    // and the sorted version will only contain the loaded rows.
    var rowsToSort = [];
    var keys = [];
    for (var i = 0, l = rows.length; i < l; i++) {
      if (rows.get(i)) {
        rowsToSort.push(rows.get(i));
        keys.push(rows.keys[i]);
      }
    }

    // Empty lists won't sort anyway, so quit here, but empty the sorted list
    // to make it up to date.
    if (rowsToSort.length === 0) {
      var sortList = sortModel.get('rows');
      if (sortList) {
        sortList.update([{
          type: 'remove',
          index: 0,
          length: sortList.length
        }]);
      } else {
        sortModel.update({ rows: [] });
      }
      return;
    }

    var partialTrackingList = live([]);

    partialTrackingList.update([{
      type: 'insert',
      index: 0,
      values: rowsToSort,
      keys: keys
    }]);

    // Now we have a list containing only the loaded rows
    partialTrackingList.query(sortQuery, function (error, rows) {
      if (error) {
        if (global.console) console.error(error);
        return;
      }

      // If direction is descending, the tracking model is ascending. Simply reverse that.
      if (sortDirection === 'desc') {
        updateListWithReversedData(sortModel, partialTrackingList);

        // For an ascending sort, perform a real sort.
      } else {

          var mask = parse(sortQuery).mask;
          var sortData = getSortData(rows, mask, partialTrackingList);

          sort(sortModel.uri, sortData, function (error, sortedData) {
            if (error) {
              if (global.console) console.error(error);
              return;
            }
            if (lastIds[sortModel.uri] !== sortId) return;
            updateListWithSortedData(sortModel, partialTrackingList, sortedData);
          });
        }
    });
  });
}

/**
 * Update the sorted live list with the right data after a sort.
 *
 * @param {LiveObject} sortModel The live object for the sorted list.
 * @param {LiveList} trackingList The live list for the list the sorted
 *     list is tracking.
 * @param {Array.<Object>} sortedItems Array of sorted items. Each item is
 *     an object with a property `key`, which is a string for the row ID.
 */
function updateListWithSortedData(sortModel, trackingList, sortedItems) {
  var sortList = sortModel.get('rows');

  // Copy the rows from the list that the sorted list is tracking,
  // if the sorted list has no tracks yet. Only for the first time.
  if (!sortList) {
    sortList = new live.List();
    sortModel.update({ rows: sortList });
  }

  var length = sortedItems.length;
  var keys = new Array(length);
  var values = new Array(length);

  for (var i = 0, l = sortedItems.length; i < l; i++) {
    keys[i] = sortedItems[i].key;
    values[i] = trackingList.valueOf(keys[i]);
  }

  sortList.update([{
    type: 'remove',
    index: 0,
    length: sortList.length
  }, {
    type: 'insert',
    index: 0,
    keys: keys,
    values: values
  }]);
}

/**
 * Update the sorted live list with the data of the list it is tracking,
 * but reversed.
 *
 * @param {LiveObject} sortModel The live object for the sorted list.
 * @param {LiveList} trackingList The live list for the list the sorted
 *     list is tracking.
 */
function updateListWithReversedData(sortModel, trackingList) {
  var sortList = sortModel.get('rows');

  if (!sortList) {
    sortList = new live.List();
    sortModel.update({ rows: sortList });
  }

  sortList.update([{
    type: 'remove',
    index: 0,
    length: sortList.length
  }, {
    type: 'insert',
    index: 0,
    length: trackingList.length,
    values: trackingList.values.slice().reverse(),
    keys: trackingList.keys.slice().reverse()
  }]);
}

/**
 * Converting the passed in operations to be relative to the list that was
 * passed in. Passing operations for a sorted list can convert the operations
 * to be used for the original list. This also updates (or publishes) the list
 * with the converted operations.
 *
 * @param {LiveList} rows The list to sync operations to.
 * @param {Array.<Object>} operations Array of operation objects.
 * @param {string} mode The mode for updates. 'update' or 'publish'.
 *
 * @return {boolean} True if a resort must happen after applying the operations.
 */
function syncRows(rows, operations, mode) {
  var mustSort = false;

  operations.forEach(function (operation) {
    var newOperations = [];

    switch (operation.type) {

      // If rows are removed from the tracking list, we can "simply" remove
      // the same rows from the sorted model.
      case 'remove':
        newOperations = convertRemoveOperationForList(rows, operation);
        break;

      // If rows are inserted in the tracking list, we must add the rows to
      // the sorted list and resort. Where we insert doesn't matter as we will
      // perform a new sort anyway.
      case 'insert':
        newOperations = [{
          type: 'insert', index: 0,
          values: operation.values, keys: operation.keys
        }];
        mustSort = true;
        break;

      // If rows are moved in the tracking list, we don't need to perform any
      // new moves directly, but we will need to perform a resort, as sorting
      // uses stable sort (falls back on index in original list if compared
      // values are the same).
      case 'move':
        mustSort = true;
        break;
    }

    if (mode === 'publish') {
      rows.publish(newOperations);
    } else if (mode === 'update') {
      rows.update(newOperations);
    }
  });

  return mustSort;
}

/**
 * Convert a remove operation from one list to an operation that can
 * be used in another list. An example is when we have an operation that
 * happened in the original list, we need to convert that to operations
 * that can be applied to the sorted list.
 *
 * @param {LiveList} list The live list to create the operations for.
 * @param {Object} operation The input 'remove' operation.
 *
 * @return {Array.<Object>} Array of remove operation objects.
 */
function convertRemoveOperationForList(list, operation) {
  var indices = [];
  var operationKeys = operation.keys;

  list.keys.forEach(function (key, i) {
    if (operationKeys.indexOf(key) > -1) indices.push(i);
  });

  return listOperations.getRemoveOperations(indices);
}

var regExp = exports.matches = /^spotify:internal:sortlist:(asc|desc):([^:]*):(.*)$/;

var registered = false;
exports.register = function () {
  if (registered) return;
  registered = true;

  live.subscribe(regExp, 'init', onInit);
  live.subscribe(regExp, 'wait', onWait);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  live.unsubscribe(regExp, 'init', onInit);
  live.unsubscribe(regExp, 'wait', onWait);
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-live":439,"../spotify-live-sort-uri":437,"../spotify-live/util/diff":440,"../spotify-live/util/parser":442,"../spotify-range2":489,"./sorting/sort":419,"./sorting/values":422,"mout/object/mixIn":667,"spotify-live-list-operations":708}],424:[function(require,module,exports){
'use strict';

/**
 * @module spotify-live-models/station
 */

var live = require('../spotify-live');

// Utilities
var trackToRow = require('./station/track-to-row');
var contains = require('mout/array/contains');
var spotifyURI = require('spotify-liburi');
var messageProxy = require('./station/station-message-proxy.js');
var thumbActions = require('./station/thumb-actions');

var appUri; // The app where this live model is being used.

var URI = exports.URI = 'spotify:station:';
var regExp = exports.matches = new RegExp('^' + URI + '(' + '((artist:|album:|track:)[a-zA-Z0-9]{22})' + '|' + '(user:[^:]+:' + '(playlist:[a-zA-Z0-9]{22}|top:tracks|toplist))' + '|' + '(user:[^:]+:cluster:[a-zA-Z0-9]{22})' + '|' + '(genre:[a-zA-Z0-9]*)' + ')');
exports.isStationUri = regExp.test.bind(regExp);

var DEFAULT_FETCH_COUNT = 15;

// Station Types
var PLAYLIST = 'playlist';
var TRACK = 'track';
var ALBUM = 'album';
var ARTIST = 'artist';
var GENRE = 'genre';
var CLUSTER = 'cluster';
var UNKNOWN = 'unknown';

var registered = false;
var queryReplySubscription;
var metadataUpdateSubscription;

var trackingRows = []; // A list of stations that need row updates.
var trackingMetadata = []; // A list of stations that need metadata updates.

/**
 * Get the station's base seed from the live model uri
 * @param {Object} model
 * @return {String}
 */
function getBaseSeedFromUri(model) {
  var seed = model.uri.replace(/^spotify:station:/, 'spotify:');
  return decodeURIComponent(seed);
}

/**
 * Get the station type
 * @param {String} seed
 * @return {String}
 */
function getType(seed) {
  var uri = spotifyURI.from(seed);
  if (!uri) {
    return UNKNOWN;
  }
  var contextType = uri.type;
  if (contextType === spotifyURI.Type.PLAYLIST) {
    return PLAYLIST;
  } else if (contextType === spotifyURI.Type.ARTIST) {
    return ARTIST;
  } else if (contextType === spotifyURI.Type.ALBUM) {
    return ALBUM;
  } else if (contextType === spotifyURI.Type.TRACK) {
    return TRACK;
  } else if (seed.indexOf('spotify:genre:') === 0) {
    return GENRE;
  } else if (seed.indexOf(':cluster:') > 0) {
    return CLUSTER;
  } else {
    return UNKNOWN;
  }
}

/**
 * Thumb up a track
 * @param {Object} model
 * @param {String} trackUID
 */
function onThumbUp(model, trackUri) {
  messageProxy.thumb({
    'stationUri': model.get('uri'),
    'trackUri': trackUri,
    'thumb': thumbActions.UP
  });
}

/**
 * Thumb down a track
 * @param {Object} model
 * @param {String} trackUID
 */
function onThumbDown(model, trackUri) {
  messageProxy.thumb({
    'stationUri': model.get('uri'),
    'trackUri': trackUri,
    'thumb': thumbActions.DOWN
  });
}

/**
 * Post a request for data from the container (station-manager in zlink).
 * @param {Object} model
 * @param {Array} properties
 * @param {Boolean} needsRows
 * @param {Integer} fetchCount
 */
function requestStationData(model, properties, needsRows, fetchCount) {
  var count = needsRows ? fetchCount || model.get('fetchCount') : false;
  messageProxy.request({
    'appUri': appUri,
    'stationUri': model.get('uri'),
    'metadata': properties,
    'trackCount': count
  });
}

/**
 * Get the appURI to compare against the referrerIdentifier from the player
 */
function getAppUri() {
  live('spotify:application').query('appURI', function (error, data) {
    if (!error) {
      appUri = data.appURI;
    }
  });
}

/**
 * Callback for rows wait event.
 * @param {Object} model
 * @param {Array} ranges
 */
function onRowsWait(model, ranges) {
  if (ranges && ranges.length > 0) {
    var fetchCount = 0;
    var largestTrack = 0;
    ranges.forEach(function (a) {
      if (a.end > largestTrack) {
        largestTrack = a.end;
      }
    });
    fetchCount = largestTrack - model.get('rows').length;
    requestStationData(model, [], true, fetchCount);
  }
}

/**
 * Subscriber for request reply messages
 * @param {Object} opts
 */
function onRequestReply(opts) {
  var sentAppUri = opts.appUri;
  var stationUri = opts.stationUri;
  var station = opts.station;
  if (sentAppUri === appUri) {
    if (station.hasOwnProperty('tracks')) {
      if (trackingRows.indexOf(stationUri) !== -1) {
        var timeStamp = new Date().getTime();
        station.rows = station.tracks.map(trackToRow.bind(null, timeStamp));
      }
      // Never keep a tracks object in the station (needs to be rows).
      delete station.tracks;
    }
    live(stationUri).update(station);
  }
}

/**
 * Subscriber for updateMetadata messages
 * @param {Object} opts
 */
function onUpdateMetadata(opts) {
  var stationUri = opts.stationUri;
  var metadata = opts.metadata;
  if (trackingMetadata.indexOf(stationUri) === -1) {
    return;
  }
  if (metadata.hasOwnProperty('tracks')) {
    if (trackingRows.indexOf(stationUri) !== -1) {
      var timeStamp = new Date().getTime();
      metadata.rows = metadata.tracks.map(trackToRow.bind(null, timeStamp));
    }
    // Never keep a tracks object in the station (needs to be rows).
    delete metadata.tracks;
  }
  live(stationUri).update(metadata);
}

/**
 * When the model intializes
 * @param {Object} model
 */
function onInit(model) {
  var baseSeed = getBaseSeedFromUri(model);
  if (!baseSeed) {
    return;
  }
  model.update({
    baseSeed: baseSeed,
    type: getType(baseSeed),
    added: false, // set this by default
    fetchCount: DEFAULT_FETCH_COUNT
  });
  model.on('update', function onModelUpdate(properties) {
    if (properties.hasOwnProperty('rows')) {
      model.get('rows').on('wait', onRowsWait.bind(null, model));
      model.off('update', onModelUpdate);
    }
  });
  trackingMetadata.push(model.get('uri'));
}

/**
 * Model publish listener
 * @param {Object} model station
 * @param {Object} properties
 */
function onPublish(model, properties) {
  if (properties.hasOwnProperty('added')) {
    var added = properties.added;
    if (typeof added === 'boolean') {
      model.update({ added: added });
      messageProxy.add({
        'stationUri': model.get('uri'),
        'add': added
      });
    } else {
      console.error('Added can only be a boolean');
    }
  }
}

/**
 * Unset props listener
 * @param {Object} model station
 * @param {Object} properties
 */
function onWait(model, properties) {
  var rowsIndex = -1;
  var needsMetadata;
  var metaFields = ['name', 'subtitle', 'relatedArtists', 'image', 'nextPageUrl'];

  properties.forEach(function (key, index) {
    if (key === 'rows') {
      rowsIndex = index;
    }
    if (!needsMetadata && contains(metaFields, key)) {
      needsMetadata = true;
    }
  });

  if (rowsIndex !== -1) {
    trackingRows.push(model.get('uri'));
    properties.splice(rowsIndex, 1);
    requestStationData(model, properties, true);
  } else if (needsMetadata) {
    requestStationData(model, properties);
  }
}

exports.register = function (stationMessageProxy) {
  if (registered) {
    return;
  }
  registered = true;

  // used only for testing
  if (stationMessageProxy) {
    messageProxy = stationMessageProxy;
  }

  live.subscribe(regExp, 'wait', onWait);
  live.subscribe(regExp, 'init', onInit);
  live.subscribe(regExp, 'thumb-up', onThumbUp);
  live.subscribe(regExp, 'thumb-down', onThumbDown);
  live.subscribe(regExp, 'publish', onPublish);
  queryReplySubscription = messageProxy.subscribeTo_requestReply(onRequestReply);
  metadataUpdateSubscription = messageProxy.subscribeTo_updateMetadata(onUpdateMetadata);
  getAppUri();
};

exports.unregister = function () {
  if (!registered) {
    return;
  }
  registered = false;

  live.unsubscribe(regExp, 'wait', onWait);
  live.unsubscribe(regExp, 'init', onInit);
  live.unsubscribe(regExp, 'thumb-up', onThumbUp);
  live.unsubscribe(regExp, 'thumb-down', onThumbDown);
  live.unsubscribe(regExp, 'publish', onPublish);
  queryReplySubscription.cancel();
  metadataUpdateSubscription.cancel();
  trackingRows = [];
  trackingMetadata = [];
};

},{"../spotify-live":439,"./station/station-message-proxy.js":428,"./station/thumb-actions":429,"./station/track-to-row":430,"mout/array/contains":625,"spotify-liburi":707}],425:[function(require,module,exports){
'use strict';

var rowToPlayerTrack = require('./row-to-player-track');

var PLAYER_RESTRICTIONS = {
  'disallow_toggling_repeat_context_reasons': ['disallow-radio'],
  'disallow_toggling_repeat_track_reasons': ['disallow-radio'],
  'disallow_toggling_shuffle_reasons': ['disallow-radio']
};

/**
 * Create an array of tracks formatted for the context player
 * @param {Object} model
 * @return {Array} tracks array
 */
function createPlayerTracks(model) {
  var rows = model.get('rows');
  if (!rows) {
    return [];
  }
  return rows.values.map(rowToPlayerTrack);
}

/**
 * Construct a context object for context-player
 * @param {Object} model station live model
 * @return {Object} context
 */
module.exports = function createPlayContext(model) {
  return {
    'entity_uri': model.get('uri'),
    'pages': [{
      'tracks': createPlayerTracks(model),
      'next_page_url': model.get('nextPageUrl')
    }],
    'metadata': {
      'context_description': model.get('name')
    },
    'restrictions': PLAYER_RESTRICTIONS
  };
};

},{"./row-to-player-track":427}],426:[function(require,module,exports){
'use strict';

var PLAYER_OPTIONS = {
  'shuffling_context': false,
  'repeating_context': false,
  'repeating_track': false
};

/**
 * This is neccesary because you dont get pages back from the context-player.
 * So if you want to resume a station with a set of rows (not pages)
 * you have to know the index of the last played row,
 * which you can get by comparing currentTrackUid with the row's Uid.
 * @param {Object} model station live model
 * @return {Int} index
 */
function getLastIndex(model) {
  var rows = model.get('rows');
  var currentTrackUid = model.get('currentTrackUid');

  if (!rows || !currentTrackUid) {
    return 0;
  }

  var currentIndex;

  var foundRow = rows.values.some(function (row, index) {
    if (row.get('uid') === currentTrackUid) {
      currentIndex = index;
      return true;
    }
  });

  return foundRow ? currentIndex : 0;
};

/**
 * Creates the context-player options for a station context
 * @param {Object} model station model
 * @param {Object} options optional
 * @return {Object} playOptions
 */
module.exports = function createPlayOptions(model, options) {
  if (options && (options.index || options.index === 0)) {
    var trackIndex = options.index;
  } else {
    var trackIndex = getLastIndex(model);
  }
  var playOptions = {
    'skip_to_index': {
      'page': 0,
      'track': trackIndex
    },
    'player_options_override': PLAYER_OPTIONS
  };
  if (options && options.uid) {
    playOptions.uid = options.uid;
  }
  return playOptions;
};

},{}],427:[function(require,module,exports){
'use strict';

/**
 * Converts a station row into a track for the context-player
 * @param {Object} row station row
 * @return {Object} track
 */

module.exports = function rowToPlayerTrack(row) {
  return {
    'uid': row.get('uid'),
    'uri': row.get('track').get('uri'),
    'album_uri': row.get('track').get('albumUri'),
    'artist_uri': row.get('track').get('artistUri'),
    'metadata': {
      'image_url': row.get('track').get('image'),
      'radio.thumb': row.get('thumb')
    }
  };
};

},{}],428:[function(require,module,exports){
'use strict';

/**
 * Station Message Proxy
 * This module is used to standarize the I/O of station messages
 * posted and subscribed by apps with stations. Mainly used to manage
 * the communication between apps and the station-manager in zlink.
 * For example: posting to the request message endpoint, certain object keys
 * are required, and when you add a subscriber
 * to that request endpoint, that function receives the same key/values.
 *
 * In the app:
 * stationMessageProxy.request({
 *  'appUri': 'spotfiy:app:stations',
 *  'stationUri': 'spotify:station:genre:rock',
 *  'metadata': true,
 *  'rowCount': 15
 * });
 *
 * In station-manager:
 * stationMessageProxy.subscribeTo_request(function(obj){
 *  obj.appUri // 'spotfiy:app:stations'
 *  obj.stationUri // 'spotify:station:genre:rock',
 *  obj.metadata // true
 *  obj.rowCount // 15
 * });
 */

var bridge = require('../../spotify-bridge-request');

// Message Uris
var baseUri = 'sp://messages/v1/station/';
var URIS = {
  ADD: baseUri + 'add',
  CREATE: baseUri + 'create',
  THUMB: baseUri + 'thumb',
  REQUEST: baseUri + 'request',
  REQUEST_REPLY: baseUri + 'request/reply',
  UPDATE_METADATA: baseUri + 'update/metadata',
  UPDATE_LAST_PLAYED: baseUri + 'update/lastPlayed',
  REQUEST_ALL: baseUri + 'request-all',
  REQUEST_ALL_REPLY: baseUri + 'request-all/reply',
  REQUEST_SAVED: baseUri + 'request-saved',
  REQUEST_SAVED_REPLY: baseUri + 'request-saved/reply'
};

// Module's Name
var NAME = 'station-message-proxy';

// Message Body Keys (the only valid keys that these proxy methods accept)
var KEY_APP_URI = 'appUri';
var KEY_STATION_URI = 'stationUri';
var KEY_METADATA = 'metadata';
var KEY_TRACK_COUNT = 'trackCount';
var KEY_STATION = 'station';
var KEY_ADD = 'add';
var KEY_THUMB = 'thumb';
var KEY_TRACK_URI = 'trackUri';
var KEY_SAVED_STATIONS = 'saved_stations';
var KEY_USER_STATIONS = 'user_stations';
var KEY_GENRE_STATIONS = 'genre_stations';
var KEY_RECOMMENDED_STATIONS = 'recommended_stations';
var KEY_CLUSTER_STATIONS = 'cluster_stations';
var KEY_CLUSTER_FORMAT_NAME = 'cluster_format_name';

/**
 * A hasmap of all the available methods you can call and 'subscribeTo'
 * and their required object keys.
 */
var API_METHODS = {
  'add': {
    'requiredKeys': [KEY_STATION_URI, KEY_ADD],
    'uri': URIS.ADD
  },
  'request': {
    'requiredKeys': [KEY_APP_URI, KEY_STATION_URI, KEY_METADATA, KEY_TRACK_COUNT],
    'uri': URIS.REQUEST
  },
  'requestReply': {
    'requiredKeys': [KEY_APP_URI, KEY_STATION_URI, KEY_STATION],
    'uri': URIS.REQUEST_REPLY
  },
  'updateMetadata': {
    'requiredKeys': [KEY_STATION_URI, KEY_METADATA],
    'uri': URIS.UPDATE_METADATA
  },
  'updateLastPlayed': {
    'requiredKeys': [KEY_STATION_URI],
    'uri': URIS.UPDATE_LAST_PLAYED
  },
  'thumb': {
    'requiredKeys': [KEY_STATION_URI, KEY_TRACK_URI, KEY_THUMB],
    'uri': URIS.THUMB
  },
  'requestAll': {
    'requiredKeys': [],
    'uri': URIS.REQUEST_ALL
  },
  'requestAllReply': {
    'requiredKeys': [KEY_CLUSTER_FORMAT_NAME, KEY_CLUSTER_STATIONS, KEY_USER_STATIONS, KEY_RECOMMENDED_STATIONS, KEY_GENRE_STATIONS],
    'uri': URIS.REQUEST_ALL_REPLY
  },
  'requestSaved': {
    'requiredKeys': [],
    'uri': URIS.REQUEST_SAVED
  },
  'requestSavedReply': {
    'requiredKeys': [KEY_SAVED_STATIONS],
    'uri': URIS.REQUEST_SAVED_REPLY
  }
};

function _cosmosError(fnName, error) {
  if (error) {
    console.error(NAME + ':' + fnName + ': ' + error);
  }
}

function _createSubscribeWrapper(fnName, subscriber) {
  return function wrapper(error, response) {
    if (error || !response || !response.body) {
      console.error(NAME + ':' + fnName + ' ', error);
      return;
    }
    var body;
    try {
      body = JSON.parse(response.body);
    } catch (e) {
      console.error(NAME + ':' + fnName + ': ' + e);
      return;
    }
    subscriber(body);
  };
}

function _subscribe(fnName, uri, subscriber) {
  if (typeof subscriber !== 'function') {
    throw new Error(NAME + ':' + fnName + ' needs a function.');
  }
  return bridge.cosmos({ method: 'SUB', uri: uri }, _createSubscribeWrapper('subscribeTo' + fnName, subscriber));
}

function _post(fnName, uri, requiredKeys, opts) {
  var body = {};
  requiredKeys.forEach(function (key) {
    if (!opts.hasOwnProperty(key)) {
      throw new Error(NAME + ':' + fnName + ':request missing keys: ' + requiredKeys);
    }
    body[key] = opts[key];
  });

  bridge.cosmos({ method: 'POST', uri: uri, body: JSON.stringify(body) }, _cosmosError.bind(null, 'request'));
}

var API = {};

Object.keys(API_METHODS).forEach(function (method) {
  API[method] = _post.bind(null, method, API_METHODS[method].uri, API_METHODS[method].requiredKeys);

  API['subscribeTo_' + method] = _subscribe.bind(null, method, API_METHODS[method].uri);
});

// Only for unit tests - do not use these directly
API.URIS = URIS;

module.exports = API;

},{"../../spotify-bridge-request":253}],429:[function(require,module,exports){
'use strict';

module.exports = {
  UP: 'ups',
  DOWN: 'downs'
};

},{}],430:[function(require,module,exports){
'use strict';

/**
 * Convert track objects coming from station-manager into a row.
 * @param {Object} track
 * @return {Object} row
 */

module.exports = function trackToRow(timeStamp, track, index) {
  var metadata = track.metadata || {};
  var artistUri = track.artist_uri || metadata.artist_uri;
  var albumUri = track.album_uri || metadata.album_uri;
  var uid = track.uid;

  if (!track.uid) {
    var id = track.uri.replace('spotify:track:', '');
    uid = timeStamp + id + index;
  }

  return {
    uid: uid,
    uri: uid,
    thumb: metadata['radio.thumb'] || '',
    track: {
      uri: track.uri,
      name: metadata.title,
      image: metadata.image_url,
      artistUri: artistUri,
      albumUri: albumUri,
      artists: [{ name: metadata.artist_name, uri: artistUri }],
      album: { name: metadata.album_title, uri: albumUri }
    }
  };
};

},{}],431:[function(require,module,exports){
(function (global){
/**
 * @module spotify-live-models/track
 */
'use strict';

var live = require('../spotify-live');
var liburi = require('spotify-liburi');
var intersection = require('mout/array/intersection');
var contains = require('mout/array/contains');
var bridge = require('./util/bridge').request;
var cosmos = require('./util/cosmos');
var util = require('./util/common');

var BACKOFF = 100;
var localFilesRequest = null;

var metaFields = ['album', 'artists', 'availability', 'disc', 'duration', 'explicit', 'image', 'local', 'name', 'number', 'placeholder', 'playable', 'popularity', 'linkedTrack'];

function onWait(model, properties) {
  // Set the 'unavailable' property based on the 'playable' property
  if (contains(properties, 'unavailable')) {
    model.get('playable', function (error, playable) {
      if (error) {
        if (global.console) console.error(error);
        return;
      }
      model.update({ unavailable: !playable });
    });
  }

  var hasMetadata = !!intersection(properties, metaFields).length;

  if (hasMetadata) updateMetadata(model);

  var needsShouldBeOffline = contains(properties, 'shouldBeOffline');
  var needsOfflineProgress = contains(properties, 'offlineProgress');
  if (needsShouldBeOffline || needsOfflineProgress) {
    updateOffline(model);
  }
}

function updateMetadata(model) {
  bridge('track_metadata', [model.uri], function (error, payload) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }
    util.setLocalProperties(payload);
    payload.image = largestImage(payload);

    // The linkedTrack is not available everywhere, so do fallback
    if (payload.linkedTrack) {
      payload.linkedTrack = { uri: payload.linkedTrack };
    } else {
      payload.linkedTrack = null;
    }

    model.update(payload);
  });
}

function largestImage(trackMetadata) {
  var imageURI = trackMetadata.image;
  var largestSize;

  if (trackMetadata.images) {
    for (var i = 0; i < trackMetadata.images.length; i++) {
      var currentImage = trackMetadata.images[i];
      if (!largestSize || currentImage[0] > largestSize) {
        largestSize = currentImage[0];
        imageURI = currentImage[1];
      }
    }
  }

  return imageURI;
}

function updateOffline(model) {

  // Local tracks are available offline if they are playable
  if (liburi.fromString(model.uri).type === liburi.Type.LOCAL) {
    model.get('playable', function (error, playable) {
      if (error) {
        if (global.console) console.error(error);
        return;
      }
      model.update({
        shouldBeOffline: playable,
        offlineProgress: playable ? 1 : 0
      });
    });
    return;
  }

  cosmos.subscribe({ url: 'sp://offline/v1/resources?uri=' + model.uri }, function (error, response) {

    if (!error) {
      var resource = response.body.resources;
      updateModelWithOfflineData(model, resource);
    } else {
      // Status -104 (or 404 in web player) means 'No endpoint resolver that could handle the request was found'.
      // If that's the case, we handle it like the client doesn't support offline.
      var statusCode = error.response && error.response.getStatusCode();
      if (statusCode === -104 || statusCode === 404) {
        updateModelWithOfflineData(model, { offline_availability: 'no' });
      } else {
        if (global.console) console.error(error);
        return;
      }
    }
  });
}

function updateModelWithOfflineData(model, resource) {
  var shouldBeOffline = false;
  var offlineProgress = 0;

  switch (resource.offline_availability) {
    case 'waiting':
      shouldBeOffline = true;offlineProgress = 0;break;
    case 'downloading':
      shouldBeOffline = true;offlineProgress = 0.5;break;
    case 'yes':
      shouldBeOffline = true;offlineProgress = 1;break;
  }

  model.update({
    shouldBeOffline: shouldBeOffline,
    offlineProgress: offlineProgress
  });
}

function waitForLocalFilesChange() {
  localFilesRequest = cosmos.subscribe({ url: 'sp://local-files/v1/changes' }, function (error, response) {
    if (!registered) return;

    if (error) {
      // Status -104 (or 404 in web player) means 'No endpoint resolver that could handle the request was found'.
      // If that's the case, we bail out and don't do anything.
      var statusCode = error.response && error.response.getStatusCode();
      if (statusCode === -104 || statusCode === 404) {
        return;
      }
      if (global.console) console.error(error);
      return;
    }

    var event = response.body;
    var data = event.data;
    var type = event.type;
    var isAdded = type === 'added';
    var isRemoved = type === 'removed';

    if (isAdded || isRemoved) {
      data.tracks.forEach(function (track) {
        live(track.uri).update({
          shouldBeOffline: isAdded,
          offlineProgress: isAdded ? 1 : 0,
          playable: isAdded
        });
      });
    }
  });
}

function waitForTrackChange() {
  bridge('track_event_wait_any', [], function (error, event) {
    if (!registered) return;

    if (error) {
      setTimeout(function () {
        waitForTrackChange();
      }, BACKOFF);
      if (global.console) console.error(error);
      return;
    }

    waitForTrackChange();

    if (event.type === 'change') {
      if (event.data.playable !== undefined) {
        event.data.unavailable = !event.data.playable;
      }
      live(event.data.uri).update(event.data);
    }
  });
}

var regExp = exports.matches = /^spotify:track:|^spotify:local:[^:]*:[^:]*:[^:]*:\d*$/;
var registered;
exports.register = function () {
  if (registered) return;
  registered = true;

  live.subscribe(regExp, 'wait', onWait);

  waitForLocalFilesChange();

  // Only desktop has support for track relinking
  if (!!global._getSpotifyModule) waitForTrackChange();
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  live.unsubscribe(regExp, 'wait', onWait);

  if (localFilesRequest) {
    localFilesRequest.cancel();
    localFilesRequest = null;
  }
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-live":439,"./util/bridge":433,"./util/common":434,"./util/cosmos":435,"mout/array/contains":625,"mout/array/intersection":634,"spotify-liburi":707}],432:[function(require,module,exports){
(function (global){
/**
 * @module spotify-live-models/user
 */
'use strict';

var live = require('../spotify-live');
var liburi = require('spotify-liburi');
var contains = require('mout/array/contains');
var intersection = require('mout/array/intersection');
var bridge = require('./util/bridge').request;

function updateMetadata(model) {
  bridge('user_metadata', [model.uri], function (error, payload) {
    if (error && global.console) console.error(error);

    if (!payload) payload = {};

    payload.username = payload.username || liburi.from(model.uri).username;
    payload.name = payload.name || payload.username;
    payload.image = payload.image || '';
    payload.images = payload.images || [];

    if (payload.subscribed == null) {
      payload.subscribed = false;
    }

    if (payload.currentUser == null) {
      live('spotify:client').query('currentUser(uri)', function (error, data) {
        if (error) {
          if (global.console) console.error(error);
          return;
        }
        model.update({ currentUser: model.uri === data.currentUser.uri });
      });
    }

    model.update(payload);
  });
}

function updateArtist(model) {
  bridge('user_associated_artist', [model.uri], function (error, payload) {
    if (error) {
      if (global.console) console.error(error);
      return;
    }
    var artist = payload.artist ? { uri: payload.artist } : null;
    model.update({ artist: artist });
  });
}

function onWait(model, properties) {
  var hasArtist = contains(properties, 'artist');
  var metaFields = ['currentUser', 'name', 'username', 'image', 'images', 'subscribed'];
  var hasMetadata = !!intersection(properties, metaFields).length;

  if (hasMetadata) updateMetadata(model);
  if (hasArtist) updateArtist(model);
}

var regExp = exports.matches = /^spotify:user:[^:]+$/;
var registered;
exports.register = function () {
  if (registered) return;
  registered = true;

  live.subscribe(regExp, 'wait', onWait);
};

exports.unregister = function () {
  if (!registered) return;
  registered = false;

  live.unsubscribe(regExp, 'wait', onWait);
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-live":439,"./util/bridge":433,"mout/array/contains":625,"mout/array/intersection":634,"spotify-liburi":707}],433:[function(require,module,exports){
/**
 * @module spotify-live-models/util/bridge
 * @private
 */

'use strict';

var bridge = require('../../spotify-bridge-request');

module.exports = {
  request: bridge.request
};

},{"../../spotify-bridge-request":253}],434:[function(require,module,exports){
'use strict';

var liburi = require('spotify-liburi');

function setLocalProperties(track) {
  if (track.album && track.album.uri) {
    var albumType = liburi.from(track.album.uri).type;
    track.album.local = albumType === liburi.Type.LOCAL_ALBUM;
  }
  if (track.artists) {
    for (var i = 0, l = track.artists.length; i < l; i++) {
      var artist = track.artists[i];
      if (artist.uri) {
        var artistType = liburi.from(artist.uri).type;
        artist.local = artistType === liburi.Type.LOCAL_ARTIST;
      }
    }
  }
}

/**
 * Export public interface
 */
module.exports = {
  setLocalProperties: setLocalProperties
};

},{"spotify-liburi":707}],435:[function(require,module,exports){
(function (global){
/**
 * @module spotify-live-models/util/cosmos
 * @private
 */

'use strict';

var cosmos = require('spotify-cosmos-api');

function DELETE(options, opt_callback) {
  options.method = exports.cosmos.Action.DELETE;
  return request(options, opt_callback);
}

function GET(options, opt_callback) {
  options.method = exports.cosmos.Action.GET;
  return request(options, opt_callback);
}

function SUB(options, opt_callback) {
  options.method = exports.cosmos.Action.SUB;
  return request(options, opt_callback);
}

function POST(options, opt_callback) {
  options.method = exports.cosmos.Action.POST;
  return request(options, opt_callback);
}

function PUT(options, opt_callback) {
  options.method = exports.cosmos.Action.PUT;
  return request(options, opt_callback);
}

function HEAD(options, opt_callback) {
  options.method = exports.cosmos.Action.HEAD;
  return request(options, opt_callback);
}

function request(options, opt_callback) {
  var method = options.method;
  delete options.method;

  var subscription, canceled;

  sanitizeURL(options.url, function (error, url) {
    if (error) return opt_callback && opt_callback(error);

    // if you cancel before the userName is replaced.
    if (canceled) return;

    var request = new exports.cosmos.Request(method || exports.cosmos.Action.GET, url, options.headers, options.body);
    subscription = exports.cosmos.resolver.resolve(request, function (error, response) {
      if (!opt_callback) return;
      if (error) return opt_callback(error);
      try {
        opt_callback(null, {
          body: JSON.parse(response.getBody() || '{}'),
          headers: response.getHeaders(),
          status: response.getStatusCode()
        });
      } catch (parseError) {
        parseError.response = response;
        opt_callback(parseError);
      }
    });
  });

  return {
    cancel: function cancel() {
      if (subscription && subscription.cancel) {
        // we already subscribed, cancel it.
        subscription.cancel();
        subscription = null;
      } else if (!canceled) {
        // not subscribed yet, don't even subscribe.
        canceled = true;
      }
      return null;
    }
  };
}

function sanitizeURL(url, callback) {
  if (url.indexOf('@') > -1) {
    callback(null, url.replace('@', encodeURIComponent(global.__spotify.username)));
  } else {
    callback(null, url);
  }
}

exports.request = request;
exports.get = GET;
exports.post = POST;
exports.subscribe = SUB;
exports.delete = DELETE;
exports.put = PUT;
exports.head = HEAD;
exports.cosmos = cosmos;

exports.sanitizeURL = sanitizeURL;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"spotify-cosmos-api":694}],436:[function(require,module,exports){
'use strict';

var Preferences = require('../../spotify-preferences');

var preferences = null;
var showUnplayableTracks = null;

var isInitialized = false;
var initCallbacks = [];

/**
 * Initialize the module and start listening for preference updates.
 */

function init(callback) {

  initCallbacks.push(callback);
  if (initCallbacks.length > 1) {
    // We already kicked of the subscription
    return;
  }

  subscribe(function (error, value) {
    if (!error) {
      showUnplayableTracks = !!value;
    }
    isInitialized = true;

    var cb;
    while (cb = initCallbacks.pop()) {
      cb(showUnplayableTracks);
    }
  });
}

/**
 * Subscribe for changes of the 'Show Unplayable Tracks' preference.
 *
 * @param {Function} callback Callback function that gets called for
 *                            each change.
 *
 * @return {Object} An object with a `cancel` method.
 */
function subscribe(callback) {
  var preferences = new Preferences('ui');

  return preferences.subscribe('show_unplayable_tracks', function (error, value) {
    if (error) return callback(error);
    callback(null, !!value);
  });
}

exports.subscribe = subscribe;

},{"../../spotify-preferences":486}],437:[function(require,module,exports){
'use strict';

var base = 'spotify:internal:sortlist';
var regExp = /^spotify:internal:sortlist:(asc|desc):([^:]*):(.*)$/;

/**
 * Create a URI representing a sorted variant of a list.
 *
 * @param {string} originUri The original list URI.
 * @param {string} direction The direction of the sorted list ('asc' or 'desc').
 * @param {string} query The query string (compatible with spotify-live). Sorting
 *     implementations might not look at all values. The list of produced values
 *     from the query will be tried in order from left to right. If two items have
 *     the same value, it will look at the next produced value from this query.
 *     Any spaces in the query will be removed.
 *
 * @return {string} URI of the sorted variant of the list. The URI will have
 *     the query string URL encoded.
 */
exports.create = function (originUri, direction, query) {
  originUri = originUri.replace(/^spotify:/, '');

  query = encodeURIComponent(query);
  query = query.replace(/%20/g, '');

  return [base, direction, query, originUri].join(':');
};

/**
 * Get the direction of the sorted list.
 *
 * @param {string} sortUri The URI of the sorted list.
 *
 * @return {string} The direction of the sort ('asc' or 'desc'). If URI is
 *     invalid, this returns an empty string.
 */
exports.getDirection = function (sortUri) {
  var matches = sortUri.match(regExp);
  if (!matches) return '';

  return matches[1];
};

/**
 * Get the query string from a sort URI.
 *
 * @param {string} sortUri The URI of the sorted list.
 *
 * @return {string} The query string, URL decoded. If URI is
 *     invalid, this returns an empty string.
 */
exports.getQuery = function (sortUri) {
  var matches = sortUri.match(regExp);
  if (!matches) return '';

  return decodeURIComponent(matches[2]);
};

/**
 * Get the URI of the original list.
 *
 * @param {string} sortUri The URI of the sorted list.
 *
 * @return {string} The URI of the original list. If the sort URI is invalid,
 *     this returns an empty string.
 */
exports.getOriginUri = function (sortUri) {
  var matches = sortUri.match(regExp);
  if (!matches) return '';

  return 'spotify:' + matches[3];
};

/**
 * Parse and return all parts of the sort URI.
 *
 * @param {string} sortUri The URI of the sorted list.
 *
 * @return {Object?} An object with properties `direction`, `query` and `originUri`,
 *     or null if the URI is not valid.
 */
exports.parse = function (sortUri) {
  var matches = sortUri.match(regExp);
  if (!matches) return null;

  return {
    direction: matches[1],
    query: decodeURIComponent(matches[2]),
    originUri: 'spotify:' + matches[3]
  };
};

/**
 * Test if the provided URI is a valid sort URI.
 *
 * @param {string} sortUri The URI of the sorted list.
 *
 * @return {boolean} True if it's valid, false otherwise.
 */
exports.isValid = function (sortUri) {
  return regExp.test(sortUri);
};

/**
 * The regular expression that matches sort URIs.
 */
exports.regExp = regExp;

},{}],438:[function(require,module,exports){
'use strict';

var sortUriUtils = require('../spotify-live-sort-uri');
var filterUriUtils = require('../spotify-live-filter-uri');

/**
 * Create a URI representing a wrapped variant of a list.
 *
 * @param {object} opts The options.
 * @param {string} opts.originUri The origin uri.
 * @param {object?} opts.filter The filter, if any
 * @param {object?} opts.sort The sorting, if any
 *
 * @return {string} URI of the wrapped variant of the list.
 */
exports.create = function (opts) {
  var uri = opts.originUri;
  if (opts.filter) {
    uri = filterUriUtils.create(uri, opts.filter.query);
  }
  if (opts.sort) {
    uri = sortUriUtils.create(uri, opts.sort.direction, opts.sort.query);
  }
  return uri;
};

/**
 * Get the URI of the original list.
 *
 * @param {string} sortUri The URI of the wrapped list.
 *
 * @return {string} The URI of the original list. If the wrapped URI is invalid,
 *     this returns an empty string.
 */
exports.getOriginUri = function (wrappedUri) {
  var parsed = exports.parse(wrappedUri);
  return parsed && parsed.originUri || '';
};

/**
 * Parse and return all parts of the wrapped URI.
 *
 * @param {string} wrappedUri The URI of the wrapped list.
 *
 * @return {object} An object with properties `originUri`, `sort` and `filter`.
 */
exports.parse = function (wrappedUri) {
  var sort = sortUriUtils.parse(wrappedUri);
  var filter = filterUriUtils.parse(sort && sort.originUri || wrappedUri);
  if (!(sort || filter)) return null;

  return {
    originUri: filter && filter.originUri || sort && sort.originUri,
    sort: sort,
    filter: filter
  };
};

/**
 * Test if the provided URI is a valid wrapped URI.
 *
 * @param {string} wrappedUri The URI of the wrapped list.
 *
 * @return {boolean} True if it's valid, false otherwise.
 */
exports.isValid = function (wrappedUri) {
  return !!exports.parse(wrappedUri);
};

},{"../spotify-live-filter-uri":371,"../spotify-live-sort-uri":437}],439:[function(require,module,exports){
(function (global){
/**
 * @module live
 */'use strict';

// prime

var prime = require('prime');
var defer = require('prime/defer');
var Emitter = require('prime/emitter');

// mout
var isPlainObject = require('mout/lang/isPlainObject');
var isArray = require('mout/lang/isArray');
var isRegExp = require('mout/lang/isRegExp');
var isNumber = function isNumber(n) {
  return typeof n === 'number';
};
var isString = function isString(s) {
  return typeof s === 'string';
};

var escapeRegExp = require('mout/string/escapeRegExp');

var _difference = require('mout/array/difference');
var filter = require('mout/array/filter');
var combine = require('mout/array/combine');
var map = require('mout/array/map');

var deepMixIn = require('mout/object/deepMixIn');
var pick = require('mout/object/pick');
var keys = require('mout/object/keys');

// finally
var flow = require('finally');

// util
var OrderedSet = require('./util/ordered-set');
var Range = require('../spotify-range2');
var parse = require('./util/parser');
var throttle = require('./util/throttle');

// methods

var isLiveList = function isLiveList(item) {
  return item instanceof LiveList;
};

var isLiveObject = function isLiveObject(item) {
  return item instanceof LiveObject;
};

// Simple, stupid and fast.
// Shallow, not checking hasOwnProperty.
var simpleClone = function simpleClone(object) {
  var clone = {};
  for (var key in object) {
    clone[key] = object[key];
  }
  return clone;
};

var difference = function difference(a, b) {
  return a.length === 0 ? [] : _difference.apply(this, arguments);
};

var values = function values(object, keys) {
  var values = [];
  var key;
  for (var i = 0, len = keys.length; i < len; i++) {
    key = keys[i];
    if (key in object) values.push(object[key]);else values.length++;
  }
  return values;
};

// subtract ranges2 from ranges1
var rdifference = function rdifference(ranges1, ranges2) {
  if (!ranges1.length) return [];

  var resultingRanges = [];

  for (var i = 0, len = ranges1.length; i < len; i++) {
    var range = ranges1[i];
    resultingRanges = resultingRanges.concat(range.subtract(ranges2));
  }

  // Make sure we don't have overlapping ranges
  resultingRanges = new Range(0, 0).merge(resultingRanges);

  // Remove any empty ranges
  resultingRanges = filter(resultingRanges, function (range) {
    return !!range.length;
  });

  return resultingRanges;
};

// merge ranges1 into ranges2
var rcombine = function rcombine(ranges1, ranges2) {
  for (var i = 0, len = ranges1.length; i < len; i++) {
    var range = ranges1[i];
    ranges2 = range.merge(ranges2);
  }
  return ranges2;
};

// util
var IDX = 0;

var slice_ = Array.prototype.slice;

var transform = function transform(item, method) {

  if (isPlainObject(item)) {
    // plain objects need to be liveified
    if ('operations' in item) return new LiveList().update(item.operations);
    return live(item.uri)._update(item, method);
  }

  if (isArray(item)) {
    // arrays need to be liveified
    return new LiveList()._update([{
      type: 'insert',
      index: 0,
      length: item.length,
      values: item
    }], method);
  }
  return item;
};

// Creates a callback with a timeout.
function createTimedCallback(callback, timeout) {
  var called;
  var timeoutId = setTimeout(function () {
    called = true;
    callback(new Error('Timeout Expired: ' + timeout + ' milliseconds'));
  }, timeout);
  return function () {
    if (!called) {
      clearTimeout(timeoutId);
      callback.apply(this, arguments);
    }
  };
};

var LiveList = prime( /** @lends LiveList.prototype */{

  mixin: Emitter,

  /**
   * A representation of an array which may be observed for changes
   * @constructs
   * @mixes Emitter
   * @param {Number} [length] - A number representing the length of the liveList.
   */
  constructor: function LiveList(length) {
    this._data = new OrderedSet(length);
    this._mergeThrottled = throttle(this._merge, this);
    this._waiting = [];

    var self = this;
    var lastWait = '';

    if (live.debug) setInterval(function () {
      var thisWait = self._waiting.toString();
      if (lastWait === thisWait) return;
      lastWait = thisWait;

      if (self._waiting.length) {
        console.warn(self, 'waiting for', self._waiting);
      } else {
        console.warn(self, 'all done');
      }
    }, 2000);
  },

  get index() {
    return this._data.index;
  },

  get length() {
    return this._data.length;
  },

  get keys() {
    return this._data.keys;
  },

  get values() {
    return this._data.values;
  },

  indexOf: function indexOf(key) {
    return this._data.indexOf(key);
  },

  indexOfMany: function indexOfMany(keys) {
    return this._data.indexOfMany(keys);
  },

  valueOf: function valueOf(key) {
    return this._data.valueOf(key);
  },

  hasKey: function hasKey(key) {
    return this._data.hasKey(key);
  },

  forEach: function forEach(fn, ctx) {
    this._data.forEach(fn, ctx);
    return this;
  },

  map: function map(fn, ctx) {
    return this._data.map(fn, ctx);
  },

  _merge: function _merge() {
    var data = this._data; // actual data
    var publish = this._publish; // new items on top of a copy of data || null
    var before = this._before; // an old copy of data || null

    if (publish) {
      delete this._publish;
      if (this._listeners && this._listeners.publish) {
        var publishDiff = data.diff(publish);
        if (publishDiff.length) this.emit('publish', publishDiff, EMIT_SYNC);
      }
    } else if (before) {
      delete this._before;
      if (this._listeners && this._listeners.update) {
        var updateDiff = before.diff(data);
        if (updateDiff.length) this.emit('update', updateDiff, EMIT_SYNC);
      }
    }
    return this;
  },

  _update: function _update(operations, method) {

    var branch;
    if (method === PUBLISH) {
      // it was receiving, cannot publish.
      if (this._before) return this;
      branch = this._publish || (this._publish = this._data.clone());
    } else if (method === UPDATE) {
      // it was publishing, delete it.
      if (this._publish) delete this._publish;
      if (!this._before) this._before = this._data.clone();
      branch = this._data;
    }

    var op;
    for (var opIndex = 0, opLen = operations.length; opIndex < opLen; opIndex++) {
      op = operations[opIndex];
      switch (op.type) {
        case 'length':
          branch.length = op.length;break;
        case 'sort':
          branch.sort(op.compareFunction);break;
        case 'move':
          branch.move(op.from, op.to, op.length);break;
        case 'remove':
          branch.remove(op.index, op.length);break;
        case 'insert':
          var values = [];
          var keys = op.keys || [];
          for (var i = 0, len = op.values.length; i < len; i++) {
            if (!op.keys || !op.keys[i]) keys[i] = (IDX++).toString(36);
            values[i] = transform(op.values[i], method);
          }
          branch.insert(op.index, keys, values);
          break;
      }
    }

    if (method === UPDATE) this._waiting = rdifference(this._waiting, this.index);

    this._mergeThrottled();
    return this;
  },

  publish: function publish(operations) {
    return this._update(operations, PUBLISH);
  },

  update: function update(operations) {
    return this._update(operations, UPDATE);
  },

  /**
   * Serialize the data in this list into a plain object.
   *
   * @param {number=} limit Optional limit parameter. Controls how many levels
   *     deep to serialize.
   *
   * @return {Array} The data array.
   */
  serialize: function serialize(limit) {
    if (limit === 0) return [];

    var array = [];
    var nextLimit = limit === undefined ? undefined : limit - 1;

    for (var i = 0; i < this.length; i++) {
      var value = this.values[i];
      var serializedValue = value;
      if (value && value.serialize) {
        serializedValue = value.serialize(nextLimit);
      }
      array.push(serializedValue);
    }

    return array;
  },

  _getDataFromMask: function _getDataFromMask(mask) {
    var items = [];

    if (mask.length > 0) {
      // The provided mask to a list is the mask for each list item, so we need
      // to loop through all the items and get the data from each item based on
      // the mask.
      for (var i = 0, l = this.length; i < l; i++) {
        var item = this.get(i);
        var parsedItem;
        var isObjectOrList = item && item._getDataFromMask;
        if (isObjectOrList) {
          parsedItem = item._getDataFromMask(mask);
        }
        items.push(parsedItem);
      }
    }

    return items;
  },

  _query: function _query(selector, callback, mode) {
    var self = this;

    var query = function query() {
      queryList(self, selector, function (error, data, wasSync) {
        if (error) return callback(error);

        if (!wasSync) {
          self._query(selector, callback, mode);
        } else {
          callback(null, data);
        }
      });
    };

    if (mode === ASYNC) defer(query);else query();
  },

  /**
   * Query properties in this list.
   * This can be called in two different ways: with a callback or without. When
   * calling it with a callback, it will wait for any missing data and always
   * return the data you queried for. When calling it without a callback, it
   * will return an array structure with only the data that was found in the
   * object at the moment. It will not kick off any events for waiting for
   * properties.
   *
   * @param {String} selector - The query selector. Only selectors without
   *     filters are supported when not providing a callback.
   * @param {Array} params - The query replace parameters.
   * @param {LiveList~queryCallback} callback - The callback that handles the response.
   * @param {Object} [mode] live.SYNC: Force sync, 2: live.ASAP: Don't force async
   * @param {Number} timeout - optional timeout in milliseconds
   *
   * @return {LiveList|Array} If no callback is passed it returns an array with
   *                             the data matching the query, that was found at
   *                             the moment in the list.
   *                             If a callback is passed it returns the instance.
   */
  query: function query(selector, params, callback, mode, timeout) {
    /**
     * @callback LiveList~queryCallback
     * @param {Error|Null} error - An error that you can throw, or null.
     * @param {Array} [data] - The response as an array.
     */
    if (typeof params === 'function') {
      // shift for empty params
      timeout = mode;
      mode = callback;
      callback = params;
      params = [];
    }

    if (!callback) {
      return this._getDataFromMask(parse(selector, params).mask);
    }

    if (!mode) {
      mode = ASYNC;
    } else if (isNumber(mode)) {
      // shift once again
      timeout = mode;
      mode = ASYNC;
    }

    if (timeout) {
      callback = createTimedCallback(callback, timeout);
    }

    this._query(parse(selector, params), callback, mode);
    return this;
  },

  _wait: function _wait(ranges) {
    if (!this._required) {
      // if _required is set, it was deferred already
      this._required = [];
      defer(function () {
        var missingFromIndex = this.missing(this._required);
        var missingFromWaiting = rdifference(missingFromIndex, this._waiting);
        this._waiting = rcombine(this._waiting, missingFromWaiting);
        delete this._required;
        if (missingFromWaiting.length) this.emit('wait', missingFromWaiting, EMIT_SYNC);
      }, this);
    }
    this._required = rcombine(this._required, ranges);
  },

  missing: function missing(ranges) {
    return rdifference(ranges, this.index);
  },

  // the raw, unbeautified get
  // this can callback sync or async
  _get: function _get(ranges, callback) {
    if (this.missing(ranges).length) {
      // has missing stuff (no matter what)
      this._wait(ranges);

      var check = function check() {
        var needed = this.missing(ranges);
        if (!needed.length) {
          this.off('update', check);
          callback.call(this);
        }
      };

      this.on('update', check);
    } else {
      // the callback is called with 'true' when syncronous.
      callback.call(this, null, true);
    }
  },

  /**
   * Checks if the range has been set with values in the list.
   *
   * @param {number} fromIndex The index to start from.
   * @param {number=} toIndex Optional index to stop at (non-inclusive). If no
   *     toIndex is specified, it will default to the index after fromIndex, to
   *     check for the single item at fromIndex.
   *
   * @return {Boolean} True if the range has been set.
   */
  has: function has(fromIndex, toIndex) {
    var hasToIndex = toIndex !== undefined;
    if (!hasToIndex) toIndex = fromIndex + 1;

    var range = new Range(fromIndex, toIndex);

    return range.contained(this.index);
  },

  /**
   * Gets items from the list between the specified indices.
   * @param {Number} what - The index to start from.
   * @param {Number} [toIndex=fromIndex + 1] - The index to stop at (non-inclusive).
   * @param {LiveList~getCallback} [callback] - Optional callback function. If no toIndex
   *     is specified, the callback can be placed as the second argument.
   * @param {Object} [mode] live.SYNC: Force sync, 2: live.ASAP: Don't force async
   * @param {Number} timeout - optional timeout in milliseconds
   * @return {LiveList|Array} If no callback is specified, returns the requested items in an array.
   *                          If a callback is specified, the method returns the instance.
   */
  get: function get(fromIndex, toIndex) {
    /**
     * @callback LiveList~getCallback
     * @param {Error|Null} error - An error that you can throw, or null.
     * @param {Array|*} [data] - The response as an array.
     *                           If toIndex is not specified a single item on the list is passed.
     */

    // fast, get one
    if (arguments.length === 1) {
      if (isNumber(fromIndex)) return this.values[fromIndex];
      if (isString(fromIndex)) return this.valueOf(fromIndex);
    }

    var self = this;

    var args = slice_.call(arguments);
    var callback, mode, requested;

    for (var i = 0, len = args.length; i < len; i++) {
      var arg = args[i];
      if (typeof arg === 'function') {
        var split = args.splice(i, 3);
        len = args.length;
        callback = split[0];
        if (split[1]) {
          if (split[1] === SYNC || split[1] === ASYNC || split[1] === ASAP) {
            mode = split[1];
          } else {
            // assume this arg is a timeout
            mode = ASYNC;
            callback = createTimedCallback(callback, split[1]);
            break;
          }
          // is there a timeout ?
          if (split[2] && mode !== SYNC) {
            callback = createTimedCallback(callback, split[2]);
          }
        } else {
          mode = ASYNC;
        }
        break;
      }
    }

    var asArray = false;
    var asSingleValue = false;

    if (fromIndex instanceof Range) {
      // one range
      requested = args;
      asArray = !callback && requested.length > 1;
    } else if (isArray(fromIndex)) {
      // array of ranges
      asArray = true;
      requested = fromIndex;
    } else {
      // numbers ?
      var hasToIndex = !isNaN(toIndex);
      if (!hasToIndex) toIndex = fromIndex + 1;
      asSingleValue = !hasToIndex;
      requested = [new Range(fromIndex, toIndex)];
    }

    var result = function result() {
      return map(requested, function (range) {
        return self.values.slice(range.start, range.end);
      });
    };

    var done = function done() {
      if (asArray) callback.call(self, null, result());else if (asSingleValue) callback.call(self, null, self.values[fromIndex]);else callback.apply(self, [null].concat(result()));
    };

    if (!callback) {
      if (asArray) return result();
      return result()[0];
    } else if (mode === SYNC) {
      done();
    } else {
      if (mode === ASYNC && !this.missing(requested).length) {
        // it has all the data but needs to be ASYNC
        defer(function () {
          this._get(requested, done);
        }, this);
      } else {
        this._get(requested, done);
      }
    }
    return this;
  }

});

var LiveObject = prime( /** @lends LiveObject.prototype */{

  mixin: Emitter,

  /**
   * A representation of an object which may be observed for changes
   * @constructs
   * @mixes Emitter
   */
  constructor: function LiveObject(_uri) {
    this.uri = _uri;
    this._data = { uri: _uri };
    this._mergeThrottled = throttle(this._merge, this);
    this.index = [];
    this._waiting = [];
    this.emit('init', EMIT_SYNC);

    var self = this;
    var lastWait = '';

    if (live.debug) setInterval(function () {
      var thisWait = self._waiting.toString();
      if (lastWait === thisWait) return;
      lastWait = thisWait;

      if (self._waiting.length) {
        console.warn(self, self._waiting);
      } else {
        console.warn(self, 'all done');
      }
    }, 2000);
  },

  emit: function emit() {
    var uri = this.uri;
    if (uri) {
      var keys = emitters.keys;
      var values = emitters.values;
      var key;
      var args;

      for (var i = 0, len = keys.length; i < len; i++) {
        key = keys[i];
        if (uri.match(key)) {
          if (!args) {
            args = new Array(arguments.length);
            for (var j = 0; j < arguments.length; ++j) {
              args[j] = arguments[j];
            }
            args.splice(1, 0, this);
          }
          var emitter = values[i];
          emitter.emit.apply(emitter, args);
        }
      }
    }

    Emitter.prototype.emit.apply(this, arguments);
  },

  _merge: function _merge() {
    var data = this._data; // the data
    var before = this._before; // an old copy of data
    var publish = this._publish; // published data
    var value;
    var key;

    // published changes
    if (publish) {
      delete this._publish;

      // emit change events if the object has a uri that can be subscribed too,
      // or the object in itself has listeners
      if (this.uri || this._listeners && this._listeners.publish) {
        var publishEvent = {};

        for (key in publish) {
          value = publish[key];
          if (data[key] !== value) publishEvent[key] = value;
        }

        if (Object.keys(publishEvent).length) {
          this.emit('publish', publishEvent, EMIT_SYNC);
        }
      }
    }

    // if there are changes
    if (before) {
      delete this._before;

      var updateEvent = {};

      // emit change events if the object has a uri that can be subscribed too,
      // or the object in itself has listeners
      if (this.uri || this._listeners && this._listeners.update) {
        // check changed and added keys
        for (key in data) {
          value = data[key];
          // there was no key, or value is different
          if (!(key in before) || before[key] !== value) updateEvent[key] = value;
        }

        // check deleted keys
        for (key in before) {
          value = before[key];
          // there is no key so it was deleted
          if (!(key in data)) updateEvent[key] = undefined;
        }

        if (Object.keys(updateEvent).length) {
          this.emit('update', updateEvent, EMIT_SYNC);
        }
      }
    }

    return this;
  },

  _update: function _update(object, method) {
    var branch;

    if (method === PUBLISH) {
      branch = this._publish || (this._publish = simpleClone(this._data));
    } else if (method === UPDATE) {
      if (!this._before) this._before = simpleClone(this._data);
      branch = this._data;
    }

    var value;
    for (var key in object) {
      value = object[key];
      var previous = !(key in branch) ? undefined : branch[key];

      if (isLiveList(previous)) {
        // updating lists with an array will keep the reference but replace every item.
        if (isArray(value)) {

          previous._update([{
            type: 'remove',
            index: 0,
            length: previous.length
          }, {
            type: 'insert',
            index: 0,
            values: value
          }], method);
          continue;
        } else if (isPlainObject(value) && 'operations' in value) {
          previous._update(value.operations, method);
          continue;
        }
      }

      if (method === UPDATE && value === undefined) delete branch[key];else branch[key] = transform(value, method);
    }

    if (method === UPDATE) {
      this.index = keys(branch);
      this._waiting = difference(this._waiting, this.index);
    }

    this._mergeThrottled();
    return this;
  },

  delete: function _delete(key) {
    var object = {};
    object[key] = undefined;
    return this.update(object);
  },

  update: function update(object) {
    return this._update(object, UPDATE);
  },

  publish: function publish(object) {
    return this._update(object, PUBLISH);
  },

  /**
   * Serialize the data in this object into a plain object.
   *
   * @param {number=} limit Optional limit parameter. Controls how many levels
   *     deep to serialize.
   *
   * @return {Object} The data object.
   */
  serialize: function serialize(limit) {
    if (limit === 0) return {};

    var object = {};
    var data = this._data;
    var nextLimit = limit === undefined ? undefined : limit - 1;

    for (var key in data) {
      var value = data[key];
      if (value === undefined) continue;
      var serializedValue = value;
      if (value && value.serialize) {
        serializedValue = value.serialize(nextLimit);
      }
      object[key] = serializedValue;
    }

    return object;
  },

  _getDataFromMask: function _getDataFromMask(mask) {
    var data = {};

    for (var i = 0, l = mask.length; i < l; i++) {
      var thisMask = mask[i];
      var nextMask = thisMask.mask;
      var key = thisMask.key;

      var realValue = this.get(key);
      var value = realValue;

      // Set the value to an empty object or array, and then it will be filled
      // in with the found data in the next step.
      if (isLiveObject(realValue)) value = {};
      if (isLiveList(realValue)) value = [];

      if (nextMask) {
        if (isLiveObject(realValue)) {
          var innerData = realValue._getDataFromMask(nextMask);
          deepMixIn(value, innerData);
        } else if (isLiveList(realValue)) {
          value = realValue._getDataFromMask(nextMask);
        }
      }

      data[key] = value;
    }

    return data;
  },

  _query: function _query(selector, callback, mode) {
    var self = this;

    var query = function query() {
      queryObject(self, selector, function (error, data, wasSync) {
        if (error) return callback.call(this, error);

        if (!wasSync) {
          self._query(selector, callback, mode);
        } else {
          callback.call(this, null, data);
        }
      });
    };

    if (mode === ASYNC) defer(query);else query();
  },

  /**
   * Query properties in this object.
   * This can be called in two different ways: with a callback or without. When
   * calling it with a callback, it will wait for any missing properties and
   * always return the data you queried for. When calling it without a callback,
   * it will return an object structure with only the data that was found in the
   * object at the moment. It will not kick off any events for waiting for
   * properties.
   *
   * @param {String} selector - The query selector. Only selectors without
   *     filters are supported when not providing a callback.
   * @param {Array} params - The query replace parameters. Optional.
   * @param {LiveObject~queryCallback} callback - The callback function.
   * @param {Object} [mode] live.SYNC: Force sync, 2: live.ASAP: Don't force async
   * @param {Number} timeout - optional timeout in milliseconds
   *
   * @return {LiveObject|Object} If no callback is passed it returns an object
   *                             with the data matching the query, that was found
   *                             at the moment in the object.
   *                             If a callback is passed it returns the instance.
   */
  query: function query(selector, params, callback, mode, timeout) {
    /**
     * @callback LiveObject~queryCallback
     * @param {Error|Null} error - An error that you can throw, or null.
     * @param {LiveObject} [data] - The response as a plain object.
     */
    if (typeof params === 'function') {
      // shift for empty params
      timeout = mode;
      mode = callback;
      callback = params;
      params = [];
    }

    if (!callback) {
      return this._getDataFromMask(parse(selector, params).mask);
    }

    if (!mode) {
      mode = ASYNC;
    } else if (isNumber(mode)) {
      // shift once again
      timeout = mode;
      mode = ASYNC;
    }

    if (timeout) {
      callback = createTimedCallback(callback, timeout);
    }

    this._query(parse(selector, params), callback, mode);
    return this;
  },

  _wait: function _wait(keys) {
    if (!this._required) {
      // if _required is set, it was deferred already
      this._required = [];
      defer(function () {
        var missingFromIndex = this.missing(this._required);
        var missingFromWaiting = difference(missingFromIndex, this._waiting);
        this._waiting = combine(this._waiting, missingFromWaiting);
        delete this._required;
        if (missingFromWaiting.length) this.emit('wait', missingFromWaiting, EMIT_SYNC);
      }, this);
    }
    this._required = combine(this._required, keys);
  },

  missing: function missing(keys) {
    return difference(keys, this.index);
  },

  /**
   * Checks if the key has been set in the object.
   *
   * @param {string} key The name of the key.
   *
   * @return {Boolean} True if the key has been set.
   */
  has: function has(key) {
    return this.index.indexOf(key) > -1;
  },

  // the raw, unbeautified get
  // this can callback sync or async
  _get: function _get(keys, callback) {
    if (this.missing(keys).length) {
      this._wait(keys);

      var check = function check() {
        var needed = this.missing(keys);
        if (!needed.length) {
          this.off('update', check);
          callback.call(this);
        }
      };
      this.on('update', check);
    } else {
      // the callback is called with 'true' when syncronous.
      callback.call(this, null, true);
    }
  },

  /**
   * Gets values from the object.
   * @param {...String|Array} keys - An array of strings as arguments.
   * @param {LiveObject~getCallback} [callback] - Optional callback function.
   * @param {Object} [mode] live.SYNC: Force sync, 2: live.ASAP: Don't force async
   * @param {Number} timeout - optional timeout in milliseconds
   * @return {LiveObject|Array|*} If no callback is passed and keys is either an array or multiple arguments
   *                             returns the values in an array.
   *                             If no callback is passed and keys is a single parameter it
   *                             returns the requested value (any type).
   *                             If a callback is passed it returns the instance.
   */
  get: function get(key) {
    /**
     * @callback LiveObject~getCallback
     * @param {Error|Null} error - An error that you can throw, or null.
     * @param {Array|...*} [data] - If keys are requested as arguments (any #)
     *                              it will return many results as arguments.
     *                              If keys are requested as an array (any #), it will return data as an array
     * @param {Number} [mode] 1: FORCE SYNC, 2: DON'T FORCE ASYNC
     */

    // fast, get one
    var data = this._data;
    if (arguments.length === 1 && isString(key)) return data[key];

    var self = this;

    var args = slice_.call(arguments);
    var callback, mode, keys;

    for (var i = 0, len = args.length; i < len; i++) {
      var arg = args[i];
      if (typeof arg === 'function') {
        var split = args.splice(i, 3);
        len = args.length;
        callback = split[0];
        if (split[1]) {
          if (split[1] === SYNC || split[1] === ASYNC || split[1] === ASAP) {
            mode = split[1];
          } else {
            // assume this arg is a timeout
            mode = ASYNC;
            callback = createTimedCallback(callback, split[1]);
            break;
          }
          // is there a timeout ?
          if (split[2] && mode !== SYNC) {
            callback = createTimedCallback(callback, split[2]);
          }
        } else {
          mode = ASYNC;
        }
        break;
      }
    }

    var asArray = false;

    if (isArray(key)) {
      keys = key;
      asArray = true;
    } else {
      keys = args;
    }

    var done = function done() {
      var vals = values(data, keys);
      if (asArray) {
        callback.call(self, null, vals);
      } else {
        vals.unshift(null); // unshift no error
        callback.apply(self, vals);
      }
    };

    if (!callback) {
      return values(data, keys);
    } else if (mode === SYNC) {
      done();
    } else {
      if (mode === ASYNC && !this.missing(keys).length) {
        // it has all the data but needs to be ASYNC
        defer(function () {
          self._get(keys, done);
        });
      } else {
        this._get(keys, done);
      }
    }

    return this;
  }

});

var queryAny = function queryAny(object, selector, callback) {
  if (isPlainObject(object) || isLiveObject(object)) return queryObject(object, selector, callback);else if (isArray(object) || isLiveList(object)) return queryList(object, selector, callback);else return callback(null, object, true);
};

var queryObject = function queryObject(object, selector, callback) {
  var data = {};
  var isSync = true;

  if (!selector) callback(null, data, isSync);

  var keys = map(selector.mask, 'key');

  var done = function done(values) {
    flow().parallel(values, function (objectValue, i) {
      var control = this;
      queryAny(objectValue, selector.mask[i], function (error, dataValue, wasSync) {
        if (error) return control.break(error);
        if (!wasSync) isSync = false;
        if (data[keys[i]]) deepMixIn(data[keys[i]], dataValue);else data[keys[i]] = dataValue;
        control.done();
      });
    }).finally(function (error) {
      callback(error, data, isSync);
    });
  };

  if (isLiveObject(object)) {
    object._get(keys, function (error, wasSync) {
      if (error) return callback(error);
      if (!wasSync) isSync = false;
      var values = map(keys, function (key) {
        return object._data[key];
      });
      done(values);
    });
  } else {
    var values = pick(object, keys);
    done(values);
  }
};

var satisfies = function satisfies(value, op, right) {
  if (!op) return !!value;
  if (isRegExp(right)) return right.test(value);

  if (op === '=') return value === right;
  if (op === '!=') return value !== right;

  if (isNumber(right)) {
    if (op === '>') return value > right;
    if (op === '>=') return value >= right;
    if (op === '<') return value < right;
    if (op === '<=') return value <= right;
  }

  if (isString(right)) {
    var escapedRight = escapeRegExp(right);
    // starts with
    if (op === '^=') return new RegExp('^' + escapedRight).test(value);
    // ends with
    if (op === '$=') return new RegExp(escapedRight + '$').test(value);
    // contains separated by space e.g. 'list of things to look for' ~= 'list'
    if (op === '~=') return new RegExp('(^|\\s)' + escapedRight + '(\\s|$)').test(value);
    // contains separated by - e.g. 'list-of-things-to-look-for' ~= 'things'
    if (op === '|=') return new RegExp('^' + escapedRight + '(-|$)').test(value);
    // contains e.g. 'listofthingstolookfor' ~= 'look'
    if (op === ' *=') return value.toString().indexOf(right) !== -1;
  }

  return false;
};

var filterArray = function filterArray(array, left, op, right, callback) {
  var isSync = true;

  var filtered = [];

  flow().parallel(array, function (item, i) {
    var ctrl = this;

    if (isLiveObject(item)) {
      item._get([left], function (error, wasSync) {
        if (error) return ctrl.break(error);
        if (!wasSync) isSync = false;
        var value = item._data[left];
        if (satisfies(value, op, right)) filtered[i] = item;
        ctrl.done();
      });
    } else if (isPlainObject(item)) {
      if (satisfies(item[left], op, right)) filtered[i] = item;
      ctrl.done();
    } else {
      // filter objects only
      ctrl.done();
    }
  }).finally(function (error) {
    if (error) return callback(error);
    var clean = [];
    for (var i = 0; i < filtered.length; i++) {
      if (i in filtered) clean.push(filtered[i]);
    }callback(null, clean, isSync);
  });
};

// default filter that filters the whole list.
var defaultFilters = [[{
  left: 0,
  op: ':'
}]];

var queryList = function queryList(list, selector, callback) {
  var isSync = true;
  // if there are no filters we need to query the full length
  if (!selector.filters) selector.filters = defaultFilters;

  // single filter.
  // must be sequential.
  flow().sequential(selector.filters, function (conditions) {
    var sequential = this;

    var ref = [];

    // list of conditions in a single filter.
    // can be parallel.
    flow().parallel(conditions, function (condition) {
      var parallel = this;

      var left = condition.left;
      var right = condition.right;
      var op = condition.op;

      if ('left' in condition && !('right' in condition) && isNumber(left)) {
        if (!op) right = left + 1;else if (op === ':') right = list.length;
        op = ':';
      }

      if ('right' in condition && !('left' in condition) && isNumber(right) && op === ':') {
        left = 0;
      }

      // filter by range.
      if (isNumber(left) && isNumber(right) && op === ':') {
        // if the list is an array it means it has already been filtered.
        if (isArray(list)) {
          var filtered = slice_.call(list, left, right);
          ref = ref.concat(filtered);
          parallel.done();
        } else {
          list._get([new Range(left, right)], function (error, wasSync) {
            if (error) return parallel.break(error);

            for (var i = left; i < right; i++) {
              ref.push(list.values[i]);
            }if (!wasSync) isSync = false;
            parallel.done();
          });
        }
      } else {

        var done = function done(array) {
          filterArray(array, left, op, right, function (error, filtered, wasSync) {
            if (error) return parallel.break(error);

            if (!wasSync) isSync = false;
            ref = ref.concat(filtered);
            parallel.done();
          });
        };

        if (isArray(list)) {
          done(list);
        } else {
          // the list is not an array, never been filtered.
          // assume full length.
          // call a function that filters an array once you arraify it.
          list._get([new Range(0, list.length)], function (error, wasSync) {
            if (error) return parallel.break(error);

            var array = [];
            for (var i = 0; i < list.length; i++) {
              array.push(list.values[i]);
            }if (!wasSync) isSync = false;
            done(array);
          });
        }
      }

      // parallel finished
    }).finally(function (error) {
      if (error) return sequential.break(error);
      list = ref;
      sequential.continue();
    });

    // sequential finished
  }).finally(function (error) {
    if (error) return callback(error);

    var data = [];

    // final parallel
    flow().parallel(list, function (item, i) {
      var control = this;
      queryAny(item, selector, function (err, res, wasSync) {
        if (!wasSync) isSync = false;
        if (data[i]) deepMixIn(data[i], res);else data[i] = res;
        control.done(err);
      });
    }).finally(function (err) {
      callback(err, data, isSync);
    });
  });
};

var cache = {};

/**
 * Create a new instance of a object, based on an unique identifier.
 * @function
 * @static
 * @param {String|LiveObject} item - An object with an uri property, or an uri as a string.
 * @return {LiveObject|LiveList} An instance of LiveObject or LiveList.
 */
var live = function live(item) {
  if (isArray(item)) {
    return new LiveList().update([{
      type: 'insert',
      index: 0,
      length: item.length,
      values: item
    }]);
  } else if (isNumber(item)) {
    return new LiveList(item);
  } else if (isString(item)) {
    return cache[item] || (cache[item] = new LiveObject(item));
  } else if (isPlainObject(item)) {
    return live(item.uri).update(item);
  } else if (isLiveList(item) || isLiveObject(item)) {
    return item;
  }

  return new LiveObject();
};

// Allow localStorage.debug to also control live.debug.
if (global.localStorage && global.localStorage.debug && (global.localStorage.debug.indexOf('spotify-live') > -1 || global.localStorage.debug.indexOf('*') > -1)) {
  live.debug = true;
}

var emitters = {
  keys: [],
  values: []
};

/**
 * Subscribe to the specific event of objects matching the pattern.
 * @function
 * @static
 * @param {RegExp} match - Regular expression for matching uris.
 * @param {String} name - The name of the event to listen for.
 * @param {Function} handle - The event handle.
 * @return {Function} The live function.
 */
live.subscribe = function (match, name, handle) {
  if (match.matches) match = match.matches;

  var string = match.toString();

  var keys = emitters.keys;
  var values = emitters.values;

  var emitter;
  for (var i = 0, len = keys.length; i < len; i++) {
    var key = keys[i];
    if (key.toString() === string) {
      emitter = values[i];
      if (emitter) break;
    }
  }

  if (!emitter) {
    keys.push(match);
    values.push(emitter = new Emitter());
  }

  emitter.on(name, handle);

  return this;
};

/**
 * Unsubscribe to the specific event of objects matching the pattern.
 * @function
 * @static
 * @param {RegExp} match - Regular expression for matching uris.
 * @param {String} name - The name of the event to unsubscribe from.
 * @param {Function} handle - The event handle.
 * @return {Function} The live function.
 */
live.unsubscribe = function (match, name, handle) {
  if (match.matches) match = match.matches;

  var string = match.toString();

  var keys = emitters.keys;
  var values = emitters.values;

  var emitter;
  for (var i = 0, len = keys.length; i < len; i++) {
    var key = keys[i];
    if (key.toString() === string) {
      emitter = values[i];
      if (emitter) break;
    }
  }

  if (emitter) emitter.off(name, handle);

  return this;
};

/**
 * Delete a model from the live cache.
 *
 * @param {string} uri A uri.
 *
 * @return {Function} The live function.
 */
live.delete = function (uri) {
  delete cache[uri];
  return this;
};

/**
 * Purge the entire cache.
 *
 * @return {Function} The live function.
 */
live.purge = function () {
  cache = {};
  return this;
};

/**
 * Check if live has an object for the URI in the cache.
 *
 * @param {string} uri A uri.
 *
 * @return {Boolean} True if the object is in the cache.
 */
live.has = function (uri) {
  return !!cache[uri];
};

var EMIT_SYNC = live.EMIT_SYNC = Emitter.EMIT_SYNC;

var ASYNC = live.ASYNC = 'ASYNC';
var SYNC = live.SYNC = 'SYNC';
var ASAP = live.ASAP = 'ASAP';

var PUBLISH = 3;
var UPDATE = 4;

/**
 * @static
 * @see LiveObject
 */
live.Object = LiveObject;

/**
 * @static
 * @see LiveList
 */
live.List = LiveList;

module.exports = live;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-range2":489,"./util/ordered-set":441,"./util/parser":442,"./util/throttle":443,"finally":533,"mout/array/combine":624,"mout/array/difference":626,"mout/array/filter":629,"mout/array/map":635,"mout/lang/isArray":648,"mout/lang/isPlainObject":652,"mout/lang/isRegExp":653,"mout/object/deepMixIn":659,"mout/object/keys":665,"mout/object/pick":668,"mout/string/escapeRegExp":670,"prime":678,"prime/defer":676,"prime/emitter":677}],440:[function(require,module,exports){
/**
 * @module spotify-live/diff
 */
'use strict';

// Original code from: https://github.com/codeparty/arraydiff
// License: MIT
// This has been forked to allow for optimizations and patching operations.

// Based on some rough benchmarking, this algorithm is about O(n^2) worst case,
// and it can compute diffs on random arrays of length 1024 in about 34ms,
// though just a few changes on an array of length 1024 takes about 0.5ms

var splice_ = Array.prototype.splice;
var slice_ = Array.prototype.slice;

var annotate = function annotate(before, after) {
  // Find all items in both the before and after array, and represent them
  // as moves. Many of these "moves" may end up being discarded in the last
  // pass if they are from an index to the same index, but we don't know this
  // up front, since we haven't yet offset the indices.
  //
  // Also keep a map of all the indicies accounted for in the before and after
  // arrays. These maps are used next to create insert and remove diffs.
  var beforeLength = before.length;
  var afterLength = after.length;
  var moves = [];
  var beforeMarked = {};
  var afterMarked = {};
  for (var beforeIndex = 0; beforeIndex < beforeLength; beforeIndex++) {
    var beforeItem = before[beforeIndex];
    for (var afterIndex = 0; afterIndex < afterLength; afterIndex++) {
      if (afterMarked[afterIndex]) continue;
      if (beforeItem !== after[afterIndex]) continue;
      var from = beforeIndex;
      var to = afterIndex;
      var length = 0;
      do {
        beforeMarked[beforeIndex++] = afterMarked[afterIndex++] = true;
        length++;
      } while (beforeIndex < beforeLength && afterIndex < afterLength && before[beforeIndex] === after[afterIndex] && !afterMarked[afterIndex]);
      var moveDiff = {
        type: 'move',
        from: from,
        to: to,
        length: length
      };
      moves.push(moveDiff);
      beforeIndex--;
      break;
    }
  }

  // Create a remove for all of the items in the before array that were
  // not marked as being matched in the after array as well
  var removes = [];
  for (beforeIndex = 0; beforeIndex < beforeLength;) {
    if (beforeMarked[beforeIndex]) {
      beforeIndex++;
      continue;
    }
    var index = beforeIndex;
    var length = 0;
    while (beforeIndex < beforeLength && !beforeMarked[beforeIndex++]) {
      length++;
    }
    var removeDiff = {
      type: 'remove',
      index: index,
      length: length,
      values: slice_.call(before, index, index + length)
    };
    removes.push(removeDiff);
  }

  // Create an insert for all of the items in the after array that were
  // not marked as being matched in the before array as well
  var inserts = [];
  for (afterIndex = 0; afterIndex < afterLength;) {
    if (afterMarked[afterIndex]) {
      afterIndex++;
      continue;
    }
    var index = afterIndex;
    var length = 0;
    while (afterIndex < afterLength && !afterMarked[afterIndex++]) {
      length++;
    }
    var values = slice_.call(after, index, index + length);
    inserts.push({ type: 'insert', index: index, length: length, values: values });
  }

  return [removes, moves, inserts];
};

var offset = function offset(removes, moves, inserts) {

  var insertsLength = inserts.length;
  var removesLength = removes.length;
  var movesLength = moves.length;
  var i, j;

  // Offset subsequent removes and moves by removes
  var count = 0;
  for (i = 0; i < removesLength; i++) {
    var remove = removes[i];
    remove.index -= count;
    count += remove.length;
    for (j = 0; j < movesLength; j++) {
      var move = moves[j];
      if (move.from >= remove.index) move.from -= remove.length;
    }
  }

  // Offset moves by inserts
  for (i = insertsLength; i--;) {
    var insert = inserts[i];
    var length = insert.length;
    for (j = movesLength; j--;) {
      var move = moves[j];
      if (move.to >= insert.index) move.to -= length;
    }
  }

  // Offset the to of moves by later moves
  for (i = movesLength; i-- > 1;) {
    var move = moves[i];
    if (move.to === move.from) continue;
    for (j = i; j--;) {
      var earlier = moves[j];
      if (earlier.to >= move.to) earlier.to -= move.length;
      if (earlier.to >= move.from) earlier.to += move.length;
    }
  }

  // Only output moves that end up having an effect after offsetting
  var outputMoves = [];

  // Offset the from of moves by earlier moves
  for (i = 0; i < movesLength; i++) {
    var move = moves[i];
    if (move.to === move.from) continue;
    outputMoves.push(move);
    for (j = i + 1; j < movesLength; j++) {
      var later = moves[j];
      if (later.from >= move.from) later.from -= move.length;
      if (later.from >= move.to) later.from += move.length;
    }
  }

  // try to reduce the number of move events
  reduceMoves(outputMoves);

  return removes.concat(outputMoves, inserts);
};

var reduceMoves = function reduceMoves(moves) {
  for (var i = 0; i < moves.length; i++) {

    // if we detect a move operation of a lots of items to a near position, we
    // can swap it by a move operation of less items to a farther position
    // (which is going to be much more performant).
    //
    // Example:
    // [1, 2, 3, 4, 5, 6, 7] => [2, 3, 4, 5, 6, 7, 1]
    // We could move [2, 3, 4, 5, 6, 7] one position ahead, but it's better to
    // move [1] six positions behind.
    if (moves[i].length > Math.abs(moves[i].to - moves[i].from)) {
      var from = moves[i].from;
      var to = moves[i].to;
      var length = moves[i].length;

      moves[i].length = Math.abs(moves[i].to - moves[i].from);
      moves[i].from = to;
      moves[i].to = to + length;
    }
  }
};

var insert = function insert(array, index, values) {
  for (var i = 0; i < values.length; i++) {
    if (i in values) {
      var idx = index + i;
      if (array.length < idx) array.length = idx;
      array.splice(idx, 0, values[i]);
    }
  }
  return values;
};

var remove = function remove(array, index, length) {
  return splice_.call(array, index, length);
};

var move = function move(array, from, to, length) {
  var moved = remove(array, from, length);
  insert(array, to, moved);
  return moved;
};

var patch = function patch(array, operations) {
  for (var i = 0; i < operations.length; i++) {
    var operation = operations[i];
    switch (operation.type) {
      case 'move':
        move(array, operation.from, operation.to, operation.length);break;
      case 'remove':
        remove(array, operation.index, operation.length);break;
      case 'insert':
        insert(array, operation.index, operation.values);break;
    }
  }
  return array;
};

var diff = function diff(before, after) {
  var operations = annotate(before, after);
  return offset.apply(this, operations);
};

diff.annotate = annotate;
diff.offset = offset;

diff.remove = remove;
diff.insert = insert;
diff.move = move;
diff.patch = patch;

module.exports = diff;

},{}],441:[function(require,module,exports){
/**
 * @module spotify-live/util/ordered-set
 * @private
 */
'use strict';

// prime

var prime = require('prime');

// mout
var forEach = require('mout/array/forEach');

var Range = require('../../spotify-range2');
var _diff = require('./diff');

var OrderedSet = prime({

  constructor: function constructor(length) {
    if (!length) length = 0;
    this.index = [];
    this.keys = new Array(length);
    this.values = new Array(length);
    this.objectStorage = {};
  },

  get length() {
    return this.keys.length;
  },

  set length(value) {
    this.keys.length = value;
    this.values.length = value;
  },

  forEach: function forEach(fn, ctx) {
    var index = this.index;
    main: for (var k = 0; k < index.length; k++) {
      var range = index[k];
      for (var i = range.start; i < range.end; i++) {
        if (fn.call(ctx, this.values[i], i, this.keys[i], this) === false) break main;
      }
    }
    return this;
  },

  map: function map(fn, ctx) {
    var values = new Array(this.length);
    this.forEach(function (value, index, key) {
      values[index] = fn.call(ctx, value, index, key, this);
    }, this);
    return values;
  },

  copy: function copy(set) {
    this.index = set.index.slice();
    this.keys = set.keys.slice();
    this.values = set.values.slice();
    var length = this.keys.length;
    this.objectStorage = {};
    for (var i = 0; i < length; i++) {
      this.objectStorage[this.keys[i]] = this.values[i];
    }
    return this;
  },

  clone: function clone() {
    return new OrderedSet().copy(this);
  },

  indexOf: function indexOf(key) {
    var index = -1;
    this.forEach(function (v, i, k) {
      if (key === k) {
        index = i;
        return false;
      }
    });
    return index;
  },

  indexOfMany: function indexOfMany(keys) {
    var indexedKeys = {};
    var found = 0;
    var output = [];

    // create a hash with the keys that are going to be searched, so we can
    // access them really fast later
    for (var i = 0; i < keys.length; i++) {
      indexedKeys[keys[i]] = -1;
    }

    this.forEach(function (v, i, k) {
      // If the element one that is being searched, add its position
      // to the output array
      if (k in indexedKeys) {
        indexedKeys[k] = i;
        found++;

        // when we have found all the search keys, we do not need to iterate
        // any more
        if (found >= keys.length) {
          return false;
        }
      }
    });

    for (i = 0; i < keys.length; i++) {
      output[i] = indexedKeys[keys[i]];
    }

    return output;
  },

  valueOf: function valueOf(key) {
    return this.objectStorage[key] || null;
  },

  hasKey: function hasKey(key) {
    return this.objectStorage.hasOwnProperty(key);
  },

  sort: function sort(fn) {
    var keys = this.keys;
    var values = this.values;
    var operations = _diff(values.slice(), values.sort(fn));

    forEach(operations, function (op) {
      // unless something is broken, a sort only produces moves.
      _diff.move(keys, op.from, op.to, op.length);
    });

    return this;
  },

  move: function move(from, to, length) {
    if (from > this.length) return [];
    if (from + length > this.length) length = from - this.length;
    if (to > this.length) to = this.length;
    if (from === to) return [];

    _diff.move(this.keys, from, to, length);
    _diff.move(this.values, from, to, length);

    return this;
  },

  insert: function insert(index, keys, values) {
    if (keys.length !== values.length) throw new Error('length mismatch');

    var range = new Range(index, index + keys.length);
    this.index = range.insert(this.index);

    _diff.insert(this.keys, index, keys);
    _diff.insert(this.values, index, values);

    for (var i = 0, length = keys.length; i < length; i++) {
      this.objectStorage[keys[i]] = values[i];
    }

    return this;
  },

  remove: function remove(index, length) {
    if (index >= this.length) return [];
    if (index + length > this.length) length = this.length;
    var range = new Range(index, index + length);
    this.index = range.extract(this.index);

    for (var i = 0; i < length; i++) {
      delete this.objectStorage[this.keys[i + index]];
    }
    _diff.remove(this.keys, index, length);
    _diff.remove(this.values, index, length);

    return this;
  },

  diff: function diff(target) {
    var operations = _diff.annotate(this.keys, target.keys);

    forEach(operations[0], function (op) {
      // remove
      op.keys = op.values;
      op.values = this.values.slice(op.index, op.index + op.length);
    }, this);

    forEach(operations[1], function (op) {
      // move
      op.keys = op.values;
      op.values = this.values.slice(op.from, op.from + op.length);
    }, this);

    forEach(operations[2], function (op) {
      // insert
      op.keys = op.values;
      op.values = target.values.slice(op.index, op.index + op.length);
    });

    return _diff.offset.apply(_diff, operations);
  },

  patch: function patch(operations) {
    forEach(operations, function (op) {
      switch (op.type) {
        case 'move':
          this.move(op.from, op.to, op.length);break;
        case 'remove':
          this.remove(op.index, op.length);break;
        case 'insert':
          this.insert(op.index, op.keys, op.values);break;
      }
    }, this);
    return this;
  }

});

module.exports = OrderedSet;

},{"../../spotify-range2":489,"./diff":440,"mout/array/forEach":632,"prime":678}],442:[function(require,module,exports){
/**
 * @module spotify-live/util/parser
 */
'use strict';

var normalize = function normalize(value) {
  if (value !== '' && !isNaN(value)) return +value;else if (value === 'true') return true;else if (value === 'false') return false;else if (value === 'null') return null;else if (value === 'undefined') return undefined;
  return value;
};

function escapeForRegExp(str) {
  return str.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
};

var COMMA = ',';
var BMASK = '(';
var EMASK = ')';
var BFILTER = '[';
var EFILTER = ']';
var EQUALS = '=';
var WHITESPACE = '\\s';

var operators = ['=', '!=', '>=', '<=', '>', '<', '^=', '$=', '~=', '|=', '*='];

var keyBlacklist = COMMA + BMASK + EMASK + escapeForRegExp(BFILTER) + escapeForRegExp(EFILTER) + EQUALS + WHITESPACE;
var keyBlacklistCharacterClass = '[^' + keyBlacklist + ']';

var KEY_CHARACTER_REG_EXP = new RegExp(keyBlacklistCharacterClass);
var EXACT_KEY_REG_EXP = new RegExp('^' + keyBlacklistCharacterClass + '+$');

var OPERATORS_REG_EXP = new RegExp(operators.map(escapeForRegExp).join('|'));
var REPLACE_REG_EXP = /\$([\d]+)/;
var RANGE_FILTER_REG_EXP = /^(\d*):(\d*)$/;

var parse = function parse(string, params) {
  if (!params) params = [];

  var selector = { mask: [] };
  var history = [selector];

  var key = '';
  var filter;

  var filterStr = '';
  var left = '';
  var right = '';
  var op = '';

  for (var i = 0; i < string.length + 1; i++) {
    var c = string.charAt(i);

    if (filter) {
      // parse the filter
      filterStr = filterStr.trim();
      if (c === COMMA || c === EFILTER) {
        var matches;
        if (matches = filterStr.match(RANGE_FILTER_REG_EXP)) {
          left = matches[1];
          op = ':';
          right = matches[2];
        } else if (matches = filterStr.match(OPERATORS_REG_EXP)) {
          left = filterStr.substring(0, matches.index);
          op = matches[0];
          right = filterStr.substring(matches.index + op.length);
        } else if (matches = filterStr.match(EXACT_KEY_REG_EXP)) {
          left = matches[0];
        } else {
          throw new SyntaxError('syntax error: `' + filterStr + '` contains characters not valid in a filter');
        }

        filterStr = '';

        var condition = {};

        if (left) {
          var leftMatch = left.match(REPLACE_REG_EXP);
          left = leftMatch ? params[+leftMatch[1]] : normalize(left);
          condition.left = left;
        }

        if (op) condition.op = op;

        if (right) {
          var rightMatch = right.match(REPLACE_REG_EXP);
          right = rightMatch ? params[+rightMatch[1]] : normalize(right);
          condition.right = right;
        }

        if ('left' in condition || 'right' in condition) filter.push(condition);

        right = '';
        left = '';
        op = '';

        if (c === EFILTER) {
          if (filter.length) {
            var filters = selector.filters || (selector.filters = []);
            filters.push(filter);
          }

          filter = null;
        }
        continue;
      }

      filterStr += c;
    } else {
      // parse the key

      if (c && KEY_CHARACTER_REG_EXP.test(c)) {
        // key
        key += c;
      } else if (key && (!c || c === COMMA || c === BMASK || c === BFILTER || c === EMASK)) {
        // end key
        // end word is "a!" or "b(a!)" or "a!,c" or "a!(" or "a!["
        var keyMatch = key.match(REPLACE_REG_EXP);
        // begin a new selector
        history[0].mask.push(selector = { key: keyMatch ? params[+keyMatch[1]] : normalize(key) });
        key = '';
      } else if (c && key) {
        throw new SyntaxError('syntax error: `' + c + '` is not a valid character in a key');
      }

      if (c === BMASK) {
        selector.mask = [];
        history.unshift(selector);
      } else if (c === EMASK) {
        history.shift();
      }

      if (c === BFILTER) {
        filter = [];
      }
    }
  }

  if (history.length !== 1) throw new SyntaxError('syntax error');

  return history[0];
};

/** exports */
module.exports = parse;

},{}],443:[function(require,module,exports){
/**
 * @module spotify-live/util/throttle
 * @private
 */
'use strict';

var defer = require('prime/defer');
var isInteger = function isInteger(n) {
  return typeof n === 'number' && n % 1 === 0;
};

var slice = Array.prototype.slice;

var _throttle = function _throttle(fn, method, context) {
  var queued, args, cancel;

  return function () {
    args = arguments;
    if (!queued) {
      queued = true;
      cancel = method(function (time) {
        queued = false;
        fn.apply(context, slice.call(args).concat(time));
      });
    }
    return cancel;
  };
};

var throttle = function throttle(callback, argument, context) {
  if (isInteger(argument)) return throttle.timeout(callback, argument, context);else return throttle.immediate(callback, argument);
};

throttle.timeout = function (callback, ms, context) {
  return _throttle(callback, function (run) {
    return defer.timeout(run, ms, context);
  }, context);
};

throttle.frame = function (callback, context) {
  return _throttle(callback, function (run) {
    return defer.frame(run, context);
  }, context);
};

throttle.immediate = function (callback, context) {
  return _throttle(callback, function (run) {
    return defer.immediate(run, context);
  }, context);
};

module.exports = throttle;

},{"prime/defer":676}],444:[function(require,module,exports){
(function (global){
'use strict';

var bridge = require('../spotify-bridge-request');
var namespace;
var async = require('async');
var libUri = require('spotify-liburi');

var SEPARATOR = ':';

function getNamespace(callback) {
  if (namespace) {
    callback(null, namespace);
    return;
  }

  async.parallel([function getAppId(callback) {
    bridge.request('application_query', [], function (error, payload) {
      if (error) {
        callback(error);
        return;
      }
      var app = libUri.fromString(payload.uri);
      if (!app || !app.id) {
        callback(new error('App URI could not be parsed'));
        return;
      }

      callback(null, app.id);
    });
  }, function getUsername(callback) {
    if (global.__spotify && global.__spotify.username) {
      callback(null, global.__spotify.username);
      return;
    }

    bridge.request('user_metadata', ['spotify:user:@'], function (error, payload) {
      callback(error, payload && payload.username);
    });
  }], function (error, results) {
    if (!error) {
      var appId = results[0];
      var userId = encodeURIComponent(results[1]);
      namespace = appId + SEPARATOR + userId + SEPARATOR;
    }
    callback(error, namespace);
  });
}

function set(key, value, callback) {
  getNamespace(function (error, namespace) {
    if (error) {
      if (callback) callback(error);
      return;
    }

    global.localStorage.setItem(namespace + key, value);
    if (callback) callback();
  });
}

function get(key, callback) {
  getNamespace(function (error, namespace) {
    if (error) {
      if (callback) callback(error);
      return;
    }

    callback(null, global.localStorage.getItem(namespace + key));
  });
}

function remove(key, callback) {
  getNamespace(function (error, namespace) {
    if (error) {
      if (callback) callback(error);
      return;
    }

    global.localStorage.removeItem(namespace + key);
    if (callback) callback(null);
  });
}

function clear(callback) {
  if (!namespace) {
    if (callback) callback(null);
    return;
  }

  var keys = Object.keys(global.localStorage);
  for (var i = 0, key; key = keys[i]; i++) {
    if (key.indexOf(namespace) === 0) {
      delete global.localStorage[key];
    }
  }

  if (callback) callback(null);
}

function _setNamespace(value) {
  namespace = value;
}

var storage = {
  set: set,
  get: get,
  remove: remove,
  clear: clear,
  _setNamespace: _setNamespace
};

module.exports = storage;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../spotify-bridge-request":253,"async":502,"spotify-liburi":707}],445:[function(require,module,exports){
'use strict';

var languages = require('./languages.json');

function lookup(language, to) {
  var lang = languages[language];
  if (lang[to]) {
    return lang[to];
  } else {
    return language;
  }
}

module.exports = lookup;
module.exports.all = function () {
  return Object.keys(languages);
};

},{"./languages.json":446}],446:[function(require,module,exports){
module.exports={
  "de": {
    "smartling": "de-DE"
  },
  "el": {
    "smartling": "el-GR"
  },
  "en": {
    "smartling": "en-GB"
  },
  "es": {
    "numeral": "es-ES",
    "smartling": "es-ES"
  },
  "es-419": {
    "moment": "es",
    "numeral": "es-ES",
    "smartling": "es-LA"
  },
  "fi": {
    "smartling": "fi-FI"
  },
  "fr": {
    "smartling": "fr-FR"
  },
  "fr-CA": {
    "smartling": "fr-CA",
    "moment": "fr-ca"
  },
  "hu": {
    "smartling": "hu-HU"
  },
  "id": {
    "smartling": "id-ID"
  },
  "it": {
    "smartling": "it-IT"
  },
  "ja": {
    "smartling": "ja-JP"
  },
  "nl": {
    "numeral": "nl-nl",
    "smartling": "nl-NL"
  },
  "pl": {
    "smartling": "pl-PL"
  },
  "pt-BR": {
    "moment": "pt-br",
    "numeral": "pt-br",
    "smartling": "pt-BR"
  },
  "sv": {
    "smartling": "sv-SE"
  },
  "tr": {
    "smartling": "tr-TR"
  },
  "zh-Hant": {
    "moment": "zh-tw",
    "smartling": "zh-TW"
  },
  "zsm": {
    "moment": "ms-my",
    "smartling": "ms-MY"
  }
}
},{}],447:[function(require,module,exports){
'use strict';

var schemer = require('./schemer');
var cosmos = require('spotify-cosmos-api');
var debug = require('debug');

var id = 0;

module.exports = function log(schema, data) {
  /*eslint-disable camelcase */
  var body = schemer(schema, Object.assign({}, {
    message_name: schema.name,
    message_version: schema.schema_version
  }, data));

  // Logging cosmos endpoint requires all values to be strings.
  body.fields = body.fields.map(function (f) {
    if (typeof f === 'string') return f;
    if (f == null) return '';
    return JSON.stringify(f);
  });

  var qualifiedName = schema.name + schema.schema_version;
  /*eslint-enable camelcase */

  var messageDebug = debug('spotify-logger:' + qualifiedName);
  var requestId = ++id;

  messageDebug('REQ %s#%s %s', qualifiedName, requestId, JSON.stringify(body));

  cosmos.resolver.post({
    url: 'sp://logging/v1/log',
    body: body
  }, function (error, response) {
    if (error) return console.error(error, body);
    messageDebug('RES %s#%s %d', qualifiedName, requestId, response.getStatusCode());
  });
};

},{"./schemer":449,"debug":526,"spotify-cosmos-api":694}],448:[function(require,module,exports){
'use strict';

var schemer = require('./schemer');
var cosmos = require('spotify-cosmos-api');
var debug = require('debug');

var id = 0;

function schemeBody(schema, data) {
  var body = schemer(schema, Object.assign({}, {
    message_name: schema.name,
    message_version: schema.schema_version
  }, data));

  // Logging cosmos endpoint requires all values to be strings.
  body.fields = body.fields.map(function (f) {
    if (typeof f === 'string') return f;
    if (f == null) return '';
    return JSON.stringify(f);
  });

  return body;
}

module.exports.add = function add(schema, data, callback) {
  var body = schemeBody(schema, data);

  var qualifiedName = schema.name + schema.schema_version;
  /*eslint-enable camelcase */
  cosmos.resolver.post({
    url: 'sp://logging/v1/add_pending_message',
    body: body
  }, function (error, response) {

    if (error) callback(error, null);

    var reply = response.getJSONBody();
    if (!reply.hasOwnProperty('message_id')) {
      callback(new Error('pendingLog: message_id not present', reply), null);
      return;
    }
    callback(null, reply.message_id);
  });
};

module.exports.update = function update(schema, messageId, data, callback) {
  var body = schemeBody(schema, data);
  body.message_id = messageId;
  var qualifiedName = schema.name + schema.schema_version;
  /*eslint-enable camelcase */

  cosmos.resolver.post({
    url: 'sp://logging/v1/update_pending_message',
    body: body
  }, function (error, response) {
    if (error) return callback(error);

    callback(null);
  });
};

module.exports.send = function send(schema, messageId) {

  var body = {
    message_id: messageId
  };
  // Logging cosmos endpoint requires all values to be strings.
  var qualifiedName = schema.name + schema.schema_version;
  cosmos.resolver.post({
    url: 'sp://logging/v1/send_pending_message',
    body: body
  }, function (error, response) {
    if (error) return console.error(error, body);
  });
};

},{"./schemer":449,"debug":526,"spotify-cosmos-api":694}],449:[function(require,module,exports){
'use strict';

var validation = require('../vendor/avro-trunk/lang/js/lib/validator');
var debug = require('debug')(require('../package.json').name + ':');

module.exports = function (schema, data) {

  debug(schema.name);

  var name = data.message_name;
  var version = data.message_version;
  var copy = Object.assign({}, data);

  if (version !== schema.schema_version) throw new Error('' + 'Invalid message version: received Message with message_version ' + version + ' but the Schema requires version ' + schema.schema_version);

  // Create positional array of field values as required by cosmos and
  // log-parser, and also create an avro Field for each value to allow
  // validation.
  var fields = schema.fields.map(function (f) {
    var type = f.type;
    var value = copy[f.name];

    // If field is a union, attempt to infer the type by grabbing the first
    // non-null type from the schema.
    if (Array.isArray(f.type)) {
      copy[f.name] = {};
      var firstNoneNullType = type.filter(function (t) {
        return t !== 'null';
      })[0];
      copy[f.name][firstNoneNullType] = value;
      debug('union `%s` (%s) : `%s`', f.name, firstNoneNullType, value);
    } else {
      copy[f.name] = value;
      debug('field `%s` : `%s`', f.name, value);
    }
    return value === undefined ? f.default : value;
  })
  // remove name, version
  .slice(2);

  validation.Validator.validate(schema, copy);

  return {
    message: name,
    version: version,
    fields: fields
  };
};

module.exports.Validator = validation.Validator;
module.exports.ProtocolValidator = validation.ProtocolValidator;

},{"../package.json":454,"../vendor/avro-trunk/lang/js/lib/validator":461,"debug":526}],450:[function(require,module,exports){
'use strict';

var schema = require('../schemas/AddToPlaylist3.json');
var log = require('../lib/log');

module.exports = {
  schema: schema,
  log: log.bind(null, schema)
};

},{"../lib/log":447,"../schemas/AddToPlaylist3.json":456}],451:[function(require,module,exports){
'use strict';

var schema = require('../schemas/ClientEvent3.json');
var log = require('../lib/log');

module.exports = {
  schema: schema,
  log: log.bind(null, schema)
};

},{"../lib/log":447,"../schemas/ClientEvent3.json":457}],452:[function(require,module,exports){
'use strict';

var schema = require('../schemas/UIInteraction4.json');
var log = require('../lib/log');

module.exports = {
  schema: schema,
  log: log.bind(null, schema)
};

},{"../lib/log":447,"../schemas/UIInteraction4.json":459}],453:[function(require,module,exports){
'use strict';

var schema = require('../schemas/UserDragAndDropInteraction1.json');
var log = require('../lib/log');

module.exports = {
  schema: schema,
  log: log.bind(null, schema)
};

},{"../lib/log":447,"../schemas/UserDragAndDropInteraction1.json":460}],454:[function(require,module,exports){
module.exports={
  "name": "spotify-logger",
  "version": "1.0.0",
  "description": "Generate / consume log-parser schemas in JS",
  "bin": {
    "spotify-logger-schemas-generator": "bin/schemas-generator",
    "spotify-logger-messages-generator": "bin/messages-generator"
  },
  "main": "lib/log.js",
  "dependencies": {},
  "devDependencies": {},
  "scripts": {
    "dev": "echo App scripts have been removed. Please see docs/app-development.md for more information. && exit 1",
    "prod": "echo App scripts have been removed. Please see docs/app-development.md for more information. && exit 1",
    "spa": "echo App scripts have been removed. Please see docs/app-development.md for more information. && exit 1",
    "enable": "echo App scripts have been removed. Please see docs/app-development.md for more information. && exit 1"
  },
  "author": "Drew Petersen <drewp@spotify.com>",
  "license": "UNLICENSED",
  "private": true
}
},{}],455:[function(require,module,exports){
'use strict';

var schema = require('../schemas/EndVideo7.json');
var pendingLog = require('../lib/pendingLog');

module.exports = {
  schema: schema,
  add: pendingLog.add.bind(null, schema),
  update: pendingLog.update.bind(null, schema),
  send: pendingLog.send.bind(null, schema)
};

},{"../lib/pendingLog":448,"../schemas/EndVideo7.json":458}],456:[function(require,module,exports){
module.exports={
  "namespace": "com.spotify.Message",
  "type": "record",
  "name": "AddToPlaylist",
  "fields": [
    {
      "type": "string",
      "name": "message_name"
    },
    {
      "type": "int",
      "name": "message_version"
    },
    {
      "default": null,
      "doc": "Create playlist, save to collection, save to existing playlist etc.",
      "type": [
        "null",
        "string"
      ],
      "name": "intent"
    },
    {
      "default": null,
      "doc": "URI of item that was added and only the first if multiple.",
      "type": [
        "null",
        "string"
      ],
      "name": "item_uri"
    },
    {
      "default": null,
      "doc": "Number of items added.",
      "type": [
        "null",
        "string"
      ],
      "name": "number_items"
    },
    {
      "default": null,
      "doc": "What section the item where added from.",
      "type": [
        "null",
        "string"
      ],
      "name": "section"
    },
    {
      "default": null,
      "doc": "The view uri which led to add to playlist.",
      "type": [
        "null",
        "string"
      ],
      "name": "source"
    },
    {
      "default": null,
      "doc": "The action which led to add to playlist.",
      "type": [
        "null",
        "string"
      ],
      "name": "source_action"
    },
    {
      "default": null,
      "doc": "The position of playlist added to or null.",
      "type": [
        "null",
        "int"
      ],
      "name": "playlist_index"
    },
    {
      "default": null,
      "doc": "The uri of playlist added to or null.",
      "type": [
        "null",
        "string"
      ],
      "name": "playlist_uri"
    },
    {
      "default": null,
      "doc": "The total number of items displayed.",
      "type": [
        "null",
        "int"
      ],
      "name": "total_number_playlists"
    },
    {
      "default": null,
      "doc": "Unix timestamp",
      "type": [
        "null",
        "long"
      ],
      "name": "time"
    }
  ],
  "doc": "User interacted with add to playlist.",
  "schema_version": 3
}
},{}],457:[function(require,module,exports){
module.exports={
  "type": "record",
  "name": "ClientEvent",
  "namespace": "com.spotify.Message",
  "doc": "A generic client event primarily used by Stitch Apps",
  "fields": [
    {
      "name": "message_name",
      "type": "string"
    },
    {
      "name": "message_version",
      "type": "int"
    },
    {
      "name": "source",
      "type": [
        "null",
        "string"
      ],
      "doc": "Source which generated the event, will mostly be set to the App-ID",
      "default": null
    },
    {
      "name": "context",
      "type": [
        "null",
        "string"
      ],
      "doc": "Optional context within the app",
      "default": null
    },
    {
      "name": "event",
      "type": [
        "null",
        "string"
      ],
      "doc": "Event name",
      "default": null
    },
    {
      "name": "event_version",
      "type": [
        "null",
        "string"
      ],
      "doc": "Optional event version, can be used as a version or sub-type",
      "default": null
    },
    {
      "name": "test_version",
      "type": [
        "null",
        "string"
      ],
      "doc": "Optional test case if A/B testing",
      "default": null
    },
    {
      "name": "source_version",
      "type": [
        "null",
        "string"
      ],
      "doc": "The version of the app",
      "default": null
    },
    {
      "name": "source_vendor",
      "type": [
        "null",
        "string"
      ],
      "doc": "The app vendor",
      "default": null
    },
    {
      "name": "json_data",
      "type": [
        "null",
        "string"
      ],
      "doc": "Additional JSON data specific to the event being sent",
      "default": null
    }
  ],
  "schema_version": 3
}
},{}],458:[function(require,module,exports){
module.exports={
  "type": "record",
  "name": "EndVideo",
  "namespace": "com.spotify.Message",
  "doc": "Information about a video played by the client",
  "fields": [
    {
      "name": "message_name",
      "type": "string"
    },
    {
      "name": "message_version",
      "type": "int"
    },
    {
      "name": "file_id",
      "type": [
        "null",
        "bytes"
      ],
      "doc": "ID of the video manifest",
      "default": null
    },
    {
      "name": "playback_id",
      "type": [
        "null",
        "bytes"
      ],
      "doc": "ID of the unique playback",
      "default": null
    },
    {
      "name": "feature_identifier",
      "type": [
        "null",
        "string"
      ],
      "doc": "The identifier of the feature that started playback",
      "default": null
    },
    {
      "name": "feature_version",
      "type": [
        "null",
        "string"
      ],
      "doc": "The version of the feature that started playback",
      "default": null
    },
    {
      "name": "view_uri",
      "type": [
        "null",
        "string"
      ],
      "doc": "The URI of the view that started playback",
      "default": null
    },
    {
      "name": "reason_start",
      "type": [
        "null",
        "string"
      ],
      "doc": "Why the video was started",
      "default": null
    },
    {
      "name": "reason_end",
      "type": [
        "null",
        "string"
      ],
      "doc": "Why the video ended (trackdone, trackerror, etc.)",
      "default": null
    },
    {
      "name": "ms_played",
      "type": [
        "null",
        "long"
      ],
      "doc": "Total milliseconds played, including overlapping time ranges",
      "default": null
    },
    {
      "name": "ms_total_est",
      "type": [
        "null",
        "long"
      ],
      "doc": "Duration of the video in milliseconds (constant if VOD, variable if live)",
      "default": null
    },
    {
      "name": "live",
      "type": [
        "null",
        "boolean"
      ],
      "doc": "Is the video being streamed live?",
      "default": null
    },
    {
      "name": "ms_manifest_latency",
      "type": [
        "null",
        "long"
      ],
      "doc": "The time it took to fetch the manifest in milliseconds (may be 0 if cached or prefetched)",
      "default": null
    },
    {
      "name": "n_seekback",
      "type": [
        "null",
        "long"
      ],
      "doc": "Number of times user seeked backwards",
      "default": null
    },
    {
      "name": "ms_seekback",
      "type": [
        "null",
        "long"
      ],
      "doc": "The total amount of milliseconds jumped when performing seekbacks throughout playback.",
      "default": null
    },
    {
      "name": "n_seekfwd",
      "type": [
        "null",
        "long"
      ],
      "doc": "Number of times user seeked forwards",
      "default": null
    },
    {
      "name": "ms_seekfwd",
      "type": [
        "null",
        "long"
      ],
      "doc": "The total amount of milliseconds jumped when performing seek forwards throughout playback.",
      "default": null
    },
    {
      "name": "ms_latency",
      "type": [
        "null",
        "long"
      ],
      "doc": "Time from initiating video playback to first frame ready to play in milliseconds",
      "default": null
    },
    {
      "name": "ui_latency",
      "type": [
        "null",
        "long"
      ],
      "doc": "Time from UI interaction to first frame ready to play in milliseconds (may be -1 if not user-initiated)",
      "default": null
    },
    {
      "name": "start_offset_ms",
      "type": [
        "null",
        "long"
      ],
      "doc": "The offset at which the video started playing in milliseconds",
      "default": null
    },
    {
      "name": "ms_initial_buffering",
      "type": [
        "null",
        "long"
      ],
      "doc": "Time between first segment load and first frame ready to play in milliseconds",
      "default": null
    },
    {
      "name": "ms_seek_rebuffering",
      "type": [
        "null",
        "long"
      ],
      "doc": "Total time spent re-buffering from a seek in milliseconds",
      "default": null
    },
    {
      "name": "ms_stalled",
      "type": [
        "null",
        "long"
      ],
      "doc": "Total time where playback stalled in milliseconds (excluding initial buffering and seek rebuffering)",
      "default": null
    },
    {
      "name": "max_ms_seek_rebuffering",
      "type": [
        "null",
        "long"
      ],
      "doc": "Maximum time spent re-buffering from a single seek",
      "default": null
    },
    {
      "name": "max_ms_stalled",
      "type": [
        "null",
        "long"
      ],
      "doc": "Maximum time stalled from a single stall",
      "default": null
    },
    {
      "name": "n_stalls",
      "type": [
        "null",
        "long"
      ],
      "doc": "Number of times playback was stopped because of empty buffer (excluding initial buffering and seek rebuffering)",
      "default": null
    },
    {
      "name": "shuffle",
      "type": [
        "null",
        "boolean"
      ],
      "doc": "If playback was initiated while in shuffle mode",
      "default": null
    },
    {
      "name": "max_continous",
      "type": [
        "null",
        "long"
      ],
      "doc": "Maximum continuous time range played in milliseconds",
      "default": null
    },
    {
      "name": "union_played",
      "type": [
        "null",
        "long"
      ],
      "doc": "Union of all played time ranges in milliseconds (cannot exceed duration)",
      "default": null
    },
    {
      "name": "play_context",
      "type": [
        "null",
        "string"
      ],
      "doc": "The context from which this track was played (spotify URI)",
      "default": null
    },
    {
      "name": "audiocodec",
      "type": [
        "null",
        "string"
      ],
      "doc": "The primarily played audio codec (in RFC6381 notation)",
      "default": null
    },
    {
      "name": "videocodec",
      "type": [
        "null",
        "string"
      ],
      "doc": "The primarily played video codec (in RFC6381 notation)",
      "default": null
    },
    {
      "name": "play_track",
      "type": [
        "null",
        "string"
      ],
      "doc": "Spotify URI for the track (ex. spotify:episode:abc)",
      "default": null
    },
    {
      "name": "incognito_mode",
      "type": [
        "null",
        "boolean"
      ],
      "doc": "Whether playback was initiated in incognito mode",
      "default": null
    },
    {
      "name": "provider",
      "type": [
        "null",
        "string"
      ],
      "doc": "The playback rule that provided the video, e.g., \"mft/inject_random_track\" or \"queue\"",
      "default": null
    },
    {
      "name": "referrer",
      "type": [
        "null",
        "string"
      ],
      "doc": "Either a remote site or a spotify app which initiated the request",
      "default": null
    },
    {
      "name": "referrer_version",
      "type": [
        "null",
        "string"
      ],
      "doc": "The version of the referrer, where applicable",
      "default": null
    },
    {
      "name": "referrer_vendor",
      "type": [
        "null",
        "string"
      ],
      "doc": "The vendor of the referrer, where applicable",
      "default": null
    },
    {
      "name": "streaming_rule",
      "type": [
        "null",
        "string"
      ],
      "doc": "The streaming rule in effect for this track",
      "default": null
    },
    {
      "name": "gaia_dev_id",
      "type": [
        "null",
        "string"
      ],
      "doc": "Remote control that started the playback. Same as \"dev-id\" in \"Gaia\" messages sent by that device. \"none\" if non-Gaia playback.",
      "default": null
    },
    {
      "name": "start_bitrate",
      "type": [
        "null",
        "long"
      ],
      "doc": "Bitrate at which playback started (bits/s)",
      "default": null
    },
    {
      "name": "full_screen",
      "type": [
        "null",
        "long"
      ],
      "doc": "Milliseconds played while video is in a modal or fullscreen state",
      "default": null
    },
    {
      "name": "time_weighted_bitrate",
      "type": [
        "null",
        "long"
      ],
      "doc": "Average bitrate weighted by the amount of time video played at each bitrate",
      "default": null
    },
    {
      "name": "prefetched_bytes",
      "type": [
        "null",
        "long"
      ],
      "doc": "Total number of bytes prefetched for the selected content",
      "default": null
    },
    {
      "name": "prefetched_bytes_loaded",
      "type": [
        "null",
        "long"
      ],
      "doc": "Total number of prefetched bytes played back",
      "default": null
    },
    {
      "name": "key_system",
      "type": [
        "null",
        "string"
      ],
      "doc": "The DRM key system",
      "default": null
    },
    {
      "name": "ms_key_latency",
      "type": [
        "null",
        "long"
      ],
      "doc": "The time it took to fetch and install the DRM key in milliseconds.",
      "default": null
    },
    {
      "name": "total_bytes",
      "type": [
        "null",
        "long"
      ],
      "doc": "The total segment bytes downloaded",
      "default": null
    },
    {
      "name": "local_time_ms",
      "type": [
        "null",
        "long"
      ],
      "doc": "The local time at which playback was initiated (Unix timestamp in milliseconds)",
      "default": null
    },
    {
      "name": "connection_type_start",
      "type": [
        "null",
        "string"
      ],
      "doc": "connection type (i.e. wifi, 3G) at the start of the stream",
      "default": null
    },
    {
      "name": "connection_type_end",
      "type": [
        "null",
        "string"
      ],
      "doc": "connection type (i.e. wifi, 3G) at the end of the stream",
      "default": null
    }
  ],
  "schema_version": 7
}
},{}],459:[function(require,module,exports){
module.exports={
  "type": "record",
  "name": "UIInteraction",
  "namespace": "com.spotify.Message",
  "doc": "A UI interaction log",
  "fields": [
    {
      "name": "message_name",
      "type": "string"
    },
    {
      "name": "message_version",
      "type": "int"
    },
    {
      "name": "request_id",
      "type": [
        "null",
        "string"
      ],
      "doc": "Request ID from Spaces Log",
      "default": null
    },
    {
      "name": "feature_id",
      "type": [
        "null",
        "string"
      ],
      "doc": "Uri of the feature page (e.g., Music, Start Page, etc.)",
      "default": null
    },
    {
      "name": "section_id",
      "type": [
        "null",
        "string"
      ],
      "doc": "Section or block of the page (e.g., Early Morning)",
      "default": null
    },
    {
      "name": "block_index",
      "type": [
        "null",
        "int"
      ],
      "doc": "Index of block on page",
      "default": null
    },
    {
      "name": "item_index",
      "type": [
        "null",
        "int"
      ],
      "doc": "Index of item in block",
      "default": null
    },
    {
      "name": "target_uri",
      "type": [
        "null",
        "string"
      ],
      "doc": "Destination of interaction",
      "default": null
    },
    {
      "name": "interaction_type",
      "type": [
        "null",
        "string"
      ],
      "doc": "Type of interaction (e.g., hit, swipe, hold, hover, etc.)",
      "default": null
    },
    {
      "name": "user_intent",
      "type": [
        "null",
        "string"
      ],
      "doc": "Grouping of interactions based on user intent (e.g., play, navigate-forward, navigate-back)",
      "default": null
    },
    {
      "name": "timestamp",
      "type": [
        "null",
        "double"
      ],
      "doc": "Unix timestamp of event",
      "default": null
    }
  ],
  "schema_version": 4
}
},{}],460:[function(require,module,exports){
module.exports={
  "type": "record",
  "name": "UserDragAndDropInteraction",
  "namespace": "com.spotify.Message",
  "doc": "Logged whenever a user drags and drops (currently desktop only) an item in the client. Only completed drag and drops are logged and not canceled/failed ones.",
  "fields": [
    {
      "name": "message_name",
      "type": "string"
    },
    {
      "name": "message_version",
      "type": "int"
    },
    {
      "name": "item_type",
      "type": [
        "null",
        "string"
      ],
      "doc": "Type of item, eg \"track\".",
      "default": null
    },
    {
      "name": "item_uri",
      "type": [
        "null",
        "string"
      ],
      "doc": "Uri of item that was dropped and only the first if multiple.",
      "default": null
    },
    {
      "name": "number_items",
      "type": [
        "null",
        "long"
      ],
      "doc": "Number of items dropped.",
      "default": null
    },
    {
      "name": "source_view_uri",
      "type": [
        "null",
        "string"
      ],
      "doc": "View uri from where the drag started, eg \"spotify:app:playlist-desktop\".",
      "default": null
    },
    {
      "name": "source_uri",
      "type": [
        "null",
        "string"
      ],
      "doc": "Uri of the context from where the drag started, eg: \"spotify:user:spotify:playlist:1m6DKwKNM1YLcm3OX6RzJg\".",
      "default": null
    },
    {
      "name": "source_index",
      "type": [
        "null",
        "long"
      ],
      "doc": "Index of the item from where the drag started.",
      "default": null
    },
    {
      "name": "source_component",
      "type": [
        "null",
        "string"
      ],
      "doc": "Id of the component from where the drag started, eg: \"header/title\" if the user dragged a playlist via the playlist title in the header.",
      "default": null
    },
    {
      "name": "target_view_uri",
      "type": [
        "null",
        "string"
      ],
      "doc": "View uri where the drop ended, eg \"spotify:app:zlink\".",
      "default": null
    },
    {
      "name": "target_uri",
      "type": [
        "null",
        "string"
      ],
      "doc": "Uri of the context where the drop ended, \"spotify:user:spotify:rootlist\".",
      "default": null
    },
    {
      "name": "target_index",
      "type": [
        "null",
        "long"
      ],
      "doc": "Index where dropped.",
      "default": null
    },
    {
      "name": "target_component",
      "type": [
        "null",
        "string"
      ],
      "doc": "Id of the component where the drop ended, eg: \"player/queue\" if dropped on the Queue button in the player component.",
      "default": null
    },
    {
      "name": "ms_duration",
      "type": [
        "null",
        "long"
      ],
      "doc": "The duration in milliseconds from the start of the drag until the end of the drop.",
      "default": null
    }
  ],
  "schema_version": 1
}
},{}],461:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

// Licensed to the Apache Software Foundation (ASF) under one or more
// contributor license agreements.  See the NOTICE file distributed with
// this work for additional information regarding copyright ownership.
// The ASF licenses this file to You under the Apache License, Version 2.0
// (the "License"); you may not use this file except in compliance with
// the License.  You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

if (typeof require !== 'undefined') {
  var _ = require("underscore");
}

var AvroSpec = {
  PrimitiveTypes: ['null', 'boolean', 'int', 'long', 'float', 'double', 'bytes', 'string'],
  ComplexTypes: ['record', 'enum', 'array', 'map', 'union', 'fixed']
};
AvroSpec.Types = AvroSpec.PrimitiveTypes.concat(AvroSpec.ComplexTypes);

var InvalidSchemaError = function InvalidSchemaError(msg) {
  return new Error('InvalidSchemaError: ' + msg);
};
var InvalidProtocolError = function InvalidProtocolError(msg) {
  return new Error('InvalidProtocolError: ' + msg);
};
var ValidationError = function ValidationError(msg) {
  return new Error('ValidationError: ' + msg);
};
var ProtocolValidationError = function ProtocolValidationError(msg) {
  return new Error('ProtocolValidationError: ' + msg);
};

function Record(name, namespace, fields) {
  function validateArgs(name, namespace, fields) {
    if (!_.isString(name)) {
      throw new InvalidSchemaError('Record name must be string');
    }

    if (!_.isNull(namespace) && !_.isUndefined(namespace) && !_.isString(namespace)) {
      throw new InvalidSchemaError('Record namespace must be string or null');
    }

    if (!_.isArray(fields)) {
      throw new InvalidSchemaError('Record name must be string');
    }
  }

  validateArgs(name, namespace, fields);

  this.name = name;
  this.namespace = namespace;
  this.fields = fields;
}

function makeFullyQualifiedTypeName(schema, namespace) {
  var typeName = null;
  if (_.isString(schema)) {
    typeName = schema;
  } else if (_.isObject(schema)) {
    if (_.isString(schema.namespace)) {
      namespace = schema.namespace;
    }
    if (_.isString(schema.name)) {
      typeName = schema.name;
    } else if (_.isString(schema.type)) {
      typeName = schema.type;
    }
    /** BEGIN CHANGE BY drewp **/
    else if (_.has(schema, 'valueSchema') && _.isString(schema.valueSchema.type)) {
        typeName = makeFullyQualifiedTypeName(schema.valueSchema, namespace);
      }
    /** END CHANGE BY drewp **/
  } else {
      throw new InvalidSchemaError('unable to determine fully qualified type name from schema ' + JSON.stringify(schema) + ' in namespace ' + namespace);
    }

  if (!_.isString(typeName)) {
    throw new InvalidSchemaError('unable to determine type name from schema ' + JSON.stringify(schema) + ' in namespace ' + namespace);
  }

  if (typeName.indexOf('.') !== -1) {
    return typeName;
  } else if (_.contains(AvroSpec.PrimitiveTypes, typeName)) {
    return typeName;
  } else if (_.isString(namespace)) {
    return namespace + '.' + typeName;
  } else {
    return typeName;
  }
}

function Union(typeSchemas, namespace) {
  this.branchNames = function () {
    return _.map(typeSchemas, function (typeSchema) {
      return makeFullyQualifiedTypeName(typeSchema, namespace);
    });
  };

  function validateArgs(typeSchemas) {
    if (!_.isArray(typeSchemas) || _.isEmpty(typeSchemas)) {
      throw new InvalidSchemaError('Union must have at least 1 branch');
    }
  }

  validateArgs(typeSchemas);

  this.typeSchemas = typeSchemas;
  this.namespace = namespace;
}

function Enum(symbols) {

  function validateArgs(symbols) {
    if (!_.isArray(symbols)) {
      throw new InvalidSchemaError('Enum must have array of symbols, got ' + JSON.stringify(symbols));
    }
    if (!_.all(symbols, function (symbol) {
      return _.isString(symbol);
    })) {
      throw new InvalidSchemaError('Enum symbols must be strings, got ' + JSON.stringify(symbols));
    }
  }

  validateArgs(symbols);

  this.symbols = symbols;
}

function AvroArray(itemSchema) {

  function validateArgs(itemSchema) {
    if (_.isNull(itemSchema) || _.isUndefined(itemSchema)) {
      throw new InvalidSchemaError('Array "items" schema should not be null or undefined');
    }
  }

  validateArgs(itemSchema);

  this.itemSchema = itemSchema;
}

function Map(valueSchema) {
  function validateArgs(valueSchema) {
    if (_.isNull(valueSchema) || _.isUndefined(valueSchema)) {
      throw new InvalidSchemaError('Map "values" schema should not be null or undefined');
    }
  }

  validateArgs(valueSchema);

  this.valueSchema = valueSchema;
}

function Field(name, schema) {
  function validateArgs(name, schema) {
    if (!_.isString(name)) {
      throw new InvalidSchemaError('Field name must be string');
    }
  }

  this.name = name;
  this.schema = schema;
}

function Primitive(type) {
  function validateArgs(type) {
    if (!_.isString(type)) {
      throw new InvalidSchemaError('Primitive type name must be a string');
    }

    if (!_.contains(AvroSpec.PrimitiveTypes, type)) {
      throw new InvalidSchemaError('Primitive type must be one of: ' + JSON.stringify(AvroSpec.PrimitiveTypes) + '; got ' + type);
    }
  }

  validateArgs(type);

  this.type = type;
}

function Validator(schema, namespace, namedTypes) {
  this.validate = function (obj) {
    return _validate(this.schema, obj);
  };

  var _validate = function _validate(schema, obj) {
    if (schema instanceof Record) {
      return _validateRecord(schema, obj);
    } else if (schema instanceof Union) {
      return _validateUnion(schema, obj);
    } else if (schema instanceof Enum) {
      return _validateEnum(schema, obj);
    } else if (schema instanceof AvroArray) {
      return _validateArray(schema, obj);
    } else if (schema instanceof Map) {
      return _validateMap(schema, obj);
    } else if (schema instanceof Primitive) {
      return _validatePrimitive(schema, obj);
    } else {
      throw new InvalidSchemaError('validation not yet implemented: ' + JSON.stringify(schema));
    }
  };

  var _validateRecord = function _validateRecord(schema, obj) {
    if (!_.isObject(obj) || _.isArray(obj)) {
      throw new ValidationError('Expected record Javascript type to be non-array object, got ' + JSON.stringify(obj));
    }

    var schemaFieldNames = _.pluck(schema.fields, 'name').sort();
    var objFieldNames = _.keys(obj).sort();
    if (!_.isEqual(schemaFieldNames, objFieldNames)) {
      throw new ValidationError('Expected record fields ' + JSON.stringify(schemaFieldNames) + '; got ' + JSON.stringify(objFieldNames));
    }

    return _.all(schema.fields, function (field) {
      return _validate(field.schema, obj[field.name]);
    });
  };

  var _validateUnion = function _validateUnion(schema, obj) {
    if (_.isObject(obj)) {
      if (_.isArray(obj)) {
        throw new ValidationError('Expected union Javascript type to be non-array object (or null), got ' + JSON.stringify(obj));
      } else if (_.size(obj) !== 1) {
        throw new ValidationError('Expected union Javascript object to be object with exactly 1 key (or null), got ' + JSON.stringify(obj));
      } else {
        var unionBranch = _.keys(obj)[0];
        if (unionBranch === "") {
          throw new ValidationError('Expected union Javascript object to contain non-empty string branch, got ' + JSON.stringify(obj));
        }
        if (_.contains(schema.branchNames(), unionBranch)) {
          return true;
        } else {
          throw new ValidationError('Expected union branch to be one of ' + JSON.stringify(schema.branchNames()) + '; got ' + JSON.stringify(unionBranch));
        }
      }
    } else if (_.isNull(obj)) {
      if (_.contains(schema.branchNames(), 'null')) {
        return true;
      } else {
        throw new ValidationError('Expected union branch to be one of ' + JSON.stringify(schema.branchNames()) + '; got ' + JSON.stringify(obj));
      }
    } else {
      throw new ValidationError('Expected union Javascript object to be non-array object of size 1 or null, got ' + JSON.stringify(obj));
    }
  };

  var _validateEnum = function _validateEnum(schema, obj) {
    if (_.isString(obj)) {
      if (_.contains(schema.symbols, obj)) {
        return true;
      } else {
        throw new ValidationError('Expected enum value to be one of ' + JSON.stringify(schema.symbols) + '; got ' + JSON.stringify(obj));
      }
    } else {
      throw new ValidationError('Expected enum Javascript object to be string, got ' + JSON.stringify(obj));
    }
  };

  var _validateArray = function _validateArray(schema, obj) {
    if (_.isArray(obj)) {
      return _.all(obj, function (member) {
        return _validate(schema.itemSchema, member);
      });
    } else {
      throw new ValidationError('Expected array Javascript object to be array, got ' + JSON.stringify(obj));
    }
  };

  var _validateMap = function _validateMap(schema, obj) {
    if (_.isObject(obj) && !_.isArray(obj)) {
      return _.all(obj, function (value) {
        return _validate(schema.valueSchema, value);
      });
    } else if (_.isArray(obj)) {
      throw new ValidationError('Expected map Javascript object to be non-array object, got array ' + JSON.stringify(obj));
    } else {
      throw new ValidationError('Expected map Javascript object to be non-array object, got ' + JSON.stringify(obj));
    }
  };

  var _validatePrimitive = function _validatePrimitive(schema, obj) {
    switch (schema.type) {
      case 'null':
        if (_.isNull(obj) || _.isUndefined(obj)) {
          return true;
        } else {
          throw new ValidationError('Expected Javascript null or undefined for Avro null, got ' + JSON.stringify(obj));
        }
        break;
      case 'boolean':
        if (_.isBoolean(obj)) {
          return true;
        } else {
          throw new ValidationError('Expected Javascript boolean for Avro boolean, got ' + JSON.stringify(obj));
        }
        break;
      case 'int':
        if (_.isNumber(obj) && Math.floor(obj) === obj && Math.abs(obj) <= Math.pow(2, 31)) {
          return true;
        } else {
          throw new ValidationError('Expected Javascript int32 number for Avro int, got ' + JSON.stringify(obj));
        }
        break;
      case 'long':
        if (_.isNumber(obj) && Math.floor(obj) === obj && Math.abs(obj) <= Math.pow(2, 63)) {
          return true;
        } else {
          throw new ValidationError('Expected Javascript int64 number for Avro long, got ' + JSON.stringify(obj));
        }
        break;
      case 'float':
        if (_.isNumber(obj)) {
          // TODO: handle NaN?
          return true;
        } else {
          throw new ValidationError('Expected Javascript float number for Avro float, got ' + JSON.stringify(obj));
        }
        break;
      case 'double':
        if (_.isNumber(obj)) {
          // TODO: handle NaN?
          return true;
        } else {
          throw new ValidationError('Expected Javascript double number for Avro double, got ' + JSON.stringify(obj));
        }
        break;
      case 'bytes':
        throw new InvalidSchemaError('not yet implemented: ' + schema.type);
      case 'string':
        if (_.isString(obj)) {
          // TODO: handle NaN?
          return true;
        } else {
          throw new ValidationError('Expected Javascript string for Avro string, got ' + JSON.stringify(obj));
        }
        break;
      default:
        throw new InvalidSchemaError('unrecognized primitive type: ' + schema.type);
    }
  };

  // TODO: namespace handling is rudimentary. multiple namespaces within a certain nested schema definition
  // are probably buggy.
  var _namedTypes = namedTypes || {};
  var _saveNamedType = function _saveNamedType(fullyQualifiedTypeName, schema) {
    if (_.has(_namedTypes, fullyQualifiedTypeName)) {
      if (!_.isEqual(_namedTypes[fullyQualifiedTypeName], schema)) {
        throw new InvalidSchemaError('conflicting definitions for type ' + fullyQualifiedTypeName + ': ' + JSON.stringify(_namedTypes[fullyQualifiedTypeName]) + ' and ' + JSON.stringify(schema));
      }
    } else {
      _namedTypes[fullyQualifiedTypeName] = schema;
    }
  };

  var _lookupTypeByFullyQualifiedName = function _lookupTypeByFullyQualifiedName(fullyQualifiedTypeName) {
    if (_.has(_namedTypes, fullyQualifiedTypeName)) {
      return _namedTypes[fullyQualifiedTypeName];
    } else {
      return null;
    }
  };

  var _parseNamedType = function _parseNamedType(schema, namespace) {
    if (_.contains(AvroSpec.PrimitiveTypes, schema)) {
      return new Primitive(schema);
    } else if (!_.isNull(_lookupTypeByFullyQualifiedName(makeFullyQualifiedTypeName(schema, namespace)))) {
      return _lookupTypeByFullyQualifiedName(makeFullyQualifiedTypeName(schema, namespace));
    } else {
      throw new InvalidSchemaError('unknown type name: ' + JSON.stringify(schema) + '; known type names are ' + JSON.stringify(_.keys(_namedTypes)));
    }
  };

  var _parseSchema = function _parseSchema(schema, parentSchema, namespace) {
    if (_.isNull(schema) || _.isUndefined(schema)) {
      throw new InvalidSchemaError('schema is null, in parentSchema: ' + JSON.stringify(parentSchema));
    } else if (_.isString(schema)) {
      return _parseNamedType(schema, namespace);
    } else if (_.isObject(schema) && !_.isArray(schema)) {
      if (schema.type === 'record') {
        var newRecord = new Record(schema.name, schema.namespace, _.map(schema.fields, function (field) {
          return new Field(field.name, _parseSchema(field.type, schema, schema.namespace || namespace));
        }));
        _saveNamedType(makeFullyQualifiedTypeName(schema, namespace), newRecord);
        return newRecord;
      } else if (schema.type === 'enum') {
        if (_.has(schema, 'symbols')) {
          var newEnum = new Enum(schema.symbols);
          _saveNamedType(makeFullyQualifiedTypeName(schema, namespace), newEnum);
          return newEnum;
        } else {
          throw new InvalidSchemaError('enum must specify symbols, got ' + JSON.stringify(schema));
        }
      } else if (schema.type === 'array') {
        if (_.has(schema, 'items')) {
          return new AvroArray(_parseSchema(schema.items, schema, namespace));
        } else {
          throw new InvalidSchemaError('array must specify "items" schema, got ' + JSON.stringify(schema));
        }
      } else if (schema.type === 'map') {
        if (_.has(schema, 'values')) {
          return new Map(_parseSchema(schema.values, schema, namespace));
        } else {
          throw new InvalidSchemaError('map must specify "values" schema, got ' + JSON.stringify(schema));
        }
      } else if (_.has(schema, 'type') && _.contains(AvroSpec.PrimitiveTypes, schema.type)) {
        return _parseNamedType(schema.type, namespace);
      } else {
        throw new InvalidSchemaError('not yet implemented: ' + schema.type);
      }
    } else if (_.isArray(schema)) {
      if (_.isEmpty(schema)) {
        throw new InvalidSchemaError('unions must have at least 1 branch');
      }
      var branchTypes = _.map(schema, function (branchType) {
        return _parseSchema(branchType, schema, namespace);
      });
      return new Union(branchTypes, namespace);
    } else {
      throw new InvalidSchemaError('unexpected Javascript type for schema: ' + (typeof schema === 'undefined' ? 'undefined' : _typeof(schema)));
    }
  };

  this.rawSchema = schema;
  this.schema = _parseSchema(schema, null, namespace);
}

Validator.validate = function (schema, obj) {
  return new Validator(schema).validate(obj);
};

function ProtocolValidator(protocol) {
  this.validate = function (typeName, obj) {
    var fullyQualifiedTypeName = makeFullyQualifiedTypeName(typeName, protocol.namespace);
    if (!_.has(_typeSchemaValidators, fullyQualifiedTypeName)) {
      throw new ProtocolValidationError('Protocol does not contain definition for type ' + JSON.stringify(fullyQualifiedTypeName) + ' (fully qualified from input "' + typeName + '"); known types are ' + JSON.stringify(_.keys(_typeSchemaValidators)));
    }
    return _typeSchemaValidators[fullyQualifiedTypeName].validate(obj);
  };

  var _typeSchemaValidators = {};
  var _initSchemaValidators = function _initSchemaValidators(protocol) {
    var namedTypes = {};
    if (!_.has(protocol, 'protocol') || !_.isString(protocol.protocol)) {
      throw new InvalidProtocolError('Protocol must contain a "protocol" attribute with a string value');
    }
    if (_.isArray(protocol.types)) {
      _.each(protocol.types, function (typeSchema) {
        var schemaValidator = new Validator(typeSchema, protocol.namespace, namedTypes);
        var fullyQualifiedTypeName = makeFullyQualifiedTypeName(typeSchema, protocol.namespace);
        _typeSchemaValidators[fullyQualifiedTypeName] = schemaValidator;
      });
    }
  };

  _initSchemaValidators(protocol);
}

ProtocolValidator.validate = function (protocol, typeName, obj) {
  return new ProtocolValidator(protocol).validate(typeName, obj);
};

if (typeof exports !== 'undefined') {
  exports['Validator'] = Validator;
  exports['ProtocolValidator'] = ProtocolValidator;
}

},{"underscore":734}],462:[function(require,module,exports){
'use strict';

/**
 * Object representing state of an app.
 *
 * @param {String} uri Spotify URI of app.
 * @constructor
 */

function AppState(uri) {
  /**
   * Spotify URI.
   *
   * @type {String}
   */
  this._uri = undefined;

  /**
   * String identifying what requested a state.
   *
   * @type {String}
   */
  this._referrer = undefined;

  if (uri !== undefined) {
    this.setURI(uri);
  }
}

/**
 * Create new instance of AppState based on JSON string.
 *
 * @param {String} json Serialized representation of AppState object.
 * @return {AppState} Instance of AppState.
 */
AppState.unserialize = function (json) {
  var s = JSON.parse(json);
  var a = new AppState();
  a.setURI(s.uri);
  a.setReferrer(s.referrer);
  return a;
};

/**
 * Test if another object is considered equal to this.
 *
 * @param {AppState} state AppState instance to compare.
 */
AppState.prototype.equals = function (state) {
  return typeof this._uri === 'string' && state instanceof AppState && this._uri === state._uri && this._referrer === state._referrer;
};

/**
 * Get App identifier.
 *
 * @return {String} Id of app contained in URI.
 */
AppState.prototype.getAppId = function () {
  var uri = this.getURI();
  var parts = uri.split(':');
  if (parts.length < 3) {
    return undefined;
  }
  if (parts[1] !== 'app') {
    return undefined;
  }
  if (parts[2] === '') {
    return undefined;
  }
  return parts[2];
};

/**
 * Get Referrer value.
 *
 * @return {String} Referrer value as string.
 */
AppState.prototype.getReferrer = function () {
  return this._referrer;
};

/**
 * Get URI value.
 *
 * @return {String} URI as string.
 */
AppState.prototype.getURI = function () {
  if (this._uri === undefined) {
    throw new Error('URI not set');
  }
  return this._uri;
};

/**
 * Create serialized representation of this instance.
 *
 * @return {String} Serialized representation of AppState object.
 */
AppState.prototype.serialize = function () {
  return JSON.stringify({
    uri: this.getURI(),
    referrer: this.getReferrer()
  });
};

/**
 * Set Referrer value.
 *
 * @param {String} referrer Referrer string.
 */
AppState.prototype.setReferrer = function (referrer) {
  this._referrer = referrer;
};

/**
 * Set URI value.
 *
 * @param {String} uri Spotify URI for app.
 */
AppState.prototype.setURI = function (uri) {
  if (typeof uri !== 'string') {
    throw new TypeError('URI must be string');
  }
  this._uri = uri;
};

module.exports = AppState;

},{}],463:[function(require,module,exports){
'use strict';

module.exports = {
  AppState: require('./app-state'),
  Navigator: require('./navigator')
};

},{"./app-state":462,"./navigator":464}],464:[function(require,module,exports){
(function (global){
'use strict';

var inherit = require('spotify-inheritance/inherit');
var EventEmitter = require('spotify-eventemitter');
var AppState = require('./app-state');
var _global = global.top || global;

/**
 * Class containing methods for navigating.
 *
 * @constructor
 */
function Navigator() {
  EventEmitter.call(this);

  /**
   * Locally bound handler function for message event on global.
   *
   * @type {Function}
   */
  this._messageHandler = this._messageHandler.bind(this);
}

inherit(Navigator, EventEmitter);

/**
 * Maps constants to string values of known events.
 */
Navigator.EVENTS = {
  OPEN_STATE: 'navigation_open_state'
};

/**
 * Identify posted message and trigger relevant callbacks
 * based on the message contents.
 *
 * @param {Object} message Message object caused by postMessage.
 */
Navigator.prototype._messageHandler = function (message) {
  if (!message.data.type) {
    return;
  }
  var name = message.data.type;
  if (name === Navigator.EVENTS.OPEN_STATE) {
    var appState = AppState.unserialize(message.data.state);
    this.emitSync(name, { state: appState });
  }
};

/**
 * Start listening to messages.
 */
Navigator.prototype.attachListener = function () {
  _global.addEventListener('message', this._messageHandler);
};

/**
 * Stop listening to messages.
 */
Navigator.prototype.detachListener = function () {
  _global.removeEventListener('message', this._messageHandler);
};

/**
 * Send an open request message.
 *
 * @param {AppState} state AppState instance to base open action on.
 */
Navigator.prototype.requestOpenState = function (state) {
  _global.postMessage({
    type: Navigator.EVENTS.OPEN_STATE,
    state: state.serialize()
  }, '*');
};

module.exports = Navigator;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./app-state":462,"spotify-eventemitter":700,"spotify-inheritance/inherit":706}],465:[function(require,module,exports){
'use strict';

module.exports = function (numeral) {
  return {
    delimiters: {
      thousands: ',',
      decimal: '.'
    },
    abbreviations: {
      thousand: 'k',
      million: 'm',
      billion: 'b',
      trillion: 't'
    },
    ordinal: function ordinal(number) {
      var b = number % 10;
      return ~ ~(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
    },
    currency: {
      symbol: '$'
    }
  };
};

},{}],466:[function(require,module,exports){
'use strict';

var numeral = require('./numeraljs/numeral');
var locales = require('../spotify-locales');

module.exports = function (currentLanguage) {

  // We need to explicitly require all languages listed in spotify-locales
  // so that Quickstart can access them at runtime
  // (dynamic paths can't be cached).
  var languages = {
    'de': require('./numeraljs/languages/de'),
    // Custom en.js file
    'en': require('./en')(numeral),
    // es-419 falls back to es-es in Numeral.js
    'es-ES': require('./numeraljs/languages/es-ES'),
    'fi': require('./numeraljs/languages/fi'),
    'fr': require('./numeraljs/languages/fr'),
    'fr-CA': require('./numeraljs/languages/fr-CA'),
    'hu': require('./numeraljs/languages/hu'),
    'id': require('./numeraljs/languages/id'),
    'it': require('./numeraljs/languages/it'),
    'ja': require('./numeraljs/languages/ja'),
    'nl-nl': require('./numeraljs/languages/nl-nl'),
    'pl': require('./numeraljs/languages/pl'),
    'pt-br': require('./numeraljs/languages/pt-br'),
    'sv': require('./numeraljs/languages/sv'),
    'tr': require('./numeraljs/languages/tr')
  };

  var numeralLocale = locales(currentLanguage, 'numeral');
  if (!languages[numeralLocale]) {
    numeralLocale = 'en';
  }
  numeral.language(numeralLocale, languages[numeralLocale]);
  numeral.language(numeralLocale);

  return numeral;
};

},{"../spotify-locales":445,"./en":465,"./numeraljs/languages/de":467,"./numeraljs/languages/es-ES":468,"./numeraljs/languages/fi":469,"./numeraljs/languages/fr":471,"./numeraljs/languages/fr-CA":470,"./numeraljs/languages/hu":472,"./numeraljs/languages/id":473,"./numeraljs/languages/it":474,"./numeraljs/languages/ja":475,"./numeraljs/languages/nl-nl":476,"./numeraljs/languages/pl":477,"./numeraljs/languages/pt-br":478,"./numeraljs/languages/sv":479,"./numeraljs/languages/tr":480,"./numeraljs/numeral":481}],467:[function(require,module,exports){
'use strict';

/*!
 * numeral.js language configuration
 * language : German (de) – generally useful in Germany, Austria, Luxembourg, Belgium
 * author : Marco Krage : https://github.com/sinky
 */
(function () {
    var language = {
        delimiters: {
            thousands: '.',
            decimal: ','
        },
        abbreviations: {
            thousand: 'k',
            million: 'm',
            billion: 'b',
            trillion: 't'
        },
        ordinal: function ordinal(number) {
            return '.';
        },
        currency: {
            symbol: '€'
        }
    };

    // Node
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = language;
    }
})();

},{}],468:[function(require,module,exports){
'use strict';

/*!
 * numeral.js language configuration
 * language : spanish Spain
 * author : Hernan Garcia : https://github.com/hgarcia
 */
(function () {
    var language = {
        delimiters: {
            thousands: '.',
            decimal: ','
        },
        abbreviations: {
            thousand: 'k',
            million: 'mm',
            billion: 'b',
            trillion: 't'
        },
        ordinal: function ordinal(number) {
            var b = number % 10;
            return b === 1 || b === 3 ? 'er' : b === 2 ? 'do' : b === 7 || b === 0 ? 'mo' : b === 8 ? 'vo' : b === 9 ? 'no' : 'to';
        },
        currency: {
            symbol: '€'
        }
    };

    // Node
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = language;
    }
})();

},{}],469:[function(require,module,exports){
'use strict';

/*!
 * numeral.js language configuration
 * language : Finnish
 * author : Sami Saada : https://github.com/samitheberber
 */
(function () {
    var language = {
        delimiters: {
            thousands: ' ',
            decimal: ','
        },
        abbreviations: {
            thousand: 'k',
            million: 'M',
            billion: 'G',
            trillion: 'T'
        },
        ordinal: function ordinal(number) {
            return '.';
        },
        currency: {
            symbol: '€'
        }
    };

    // Node
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = language;
    }
})();

},{}],470:[function(require,module,exports){
'use strict';

/*!
 * numeral.js language configuration
 * language : french (Canada) (fr-CA)
 * author : Léo Renaud-Allaire : https://github.com/renaudleo
 */
(function () {
    var language = {
        delimiters: {
            thousands: ' ',
            decimal: ','
        },
        abbreviations: {
            thousand: 'k',
            million: 'M',
            billion: 'G',
            trillion: 'T'
        },
        ordinal: function ordinal(number) {
            return number === 1 ? 'er' : 'e';
        },
        currency: {
            symbol: '$'
        }
    };

    // Node
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = language;
    }
})();

},{}],471:[function(require,module,exports){
'use strict';

/*!
 * numeral.js language configuration
 * language : french (fr)
 * author : Adam Draper : https://github.com/adamwdraper
 */
(function () {
    var language = {
        delimiters: {
            thousands: ' ',
            decimal: ','
        },
        abbreviations: {
            thousand: 'k',
            million: 'm',
            billion: 'b',
            trillion: 't'
        },
        ordinal: function ordinal(number) {
            return number === 1 ? 'er' : 'e';
        },
        currency: {
            symbol: '€'
        }
    };

    // Node
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = language;
    }
})();

},{}],472:[function(require,module,exports){
'use strict';

/*!
 * numeral.js language configuration
 * language : Hungarian (hu)
 * author : Peter Bakondy : https://github.com/pbakondy
 */
(function () {
    var language = {
        delimiters: {
            thousands: ' ',
            decimal: ','
        },
        abbreviations: {
            thousand: 'E', // ezer
            million: 'M', // millió
            billion: 'Mrd', // milliárd
            trillion: 'T' // trillió
        },
        ordinal: function ordinal(number) {
            return '.';
        },
        currency: {
            symbol: ' Ft'
        }
    };

    // Node
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = language;
    }
})();

},{}],473:[function(require,module,exports){
'use strict';

/*!
 * numeral.js language configuration
 * language : Indonesian (id)
 */
(function () {
    var language = {
        delimiters: {
            thousands: ',',
            decimal: '.'
        },
        abbreviations: {
            thousand: 'ribu',
            million: 'juta',
            billion: 'miliar',
            trillion: 'triliun'
        },
        ordinal: function ordinal(number) {
            // According to Spotify's internal Indonesian specialist,
            // there is no ordinal symbol in Indonesian (like st, nd, th, º, ª),
            // they just use the word (equivalent to writing: first, second,
            // third, instead of 1st, 2nd, 3rd). And as we don't have such
            // capability to translate all numbers to words, this function
            // returns an empty string and wherever there's a ordinal, it will
            // just show up as the cardinal number.
            return '';
        },
        currency: {
            symbol: 'Rp'
        }
    };

    // Node
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = language;
    }
})();

},{}],474:[function(require,module,exports){
'use strict';

/*!
 * numeral.js language configuration
 * language : italian Italy (it)
 * author : Giacomo Trombi : http://cinquepunti.it
 */
(function () {
    var language = {
        delimiters: {
            thousands: '.',
            decimal: ','
        },
        abbreviations: {
            thousand: 'mila',
            million: 'mil',
            billion: 'b',
            trillion: 't'
        },
        ordinal: function ordinal(number) {
            return 'º';
        },
        currency: {
            symbol: '€'
        }
    };

    // Node
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = language;
    }
})();

},{}],475:[function(require,module,exports){
'use strict';

/*!
 * numeral.js language configuration
 * language : japanese
 * author : teppeis : https://github.com/teppeis
 */
(function () {
    var language = {
        delimiters: {
            thousands: ',',
            decimal: '.'
        },
        abbreviations: {
            thousand: '千',
            million: '百万',
            billion: '十億',
            trillion: '兆'
        },
        ordinal: function ordinal(number) {
            return '.';
        },
        currency: {
            symbol: '¥'
        }
    };

    // Node
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = language;
    }
})();

},{}],476:[function(require,module,exports){
'use strict';

/*!
 * numeral.js language configuration
 * language : netherlands-dutch (nl-nl)
 * author : Dave Clayton : https://github.com/davedx
 */
(function () {
    var language = {
        delimiters: {
            thousands: '.',
            decimal: ','
        },
        abbreviations: {
            thousand: 'k',
            million: 'mln',
            billion: 'mrd',
            trillion: 'bln'
        },
        ordinal: function ordinal(number) {
            var remainder = number % 100;
            return number !== 0 && remainder <= 1 || remainder === 8 || remainder >= 20 ? 'ste' : 'de';
        },
        currency: {
            symbol: '€ '
        }
    };

    // Node
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = language;
    }
})();

},{}],477:[function(require,module,exports){
'use strict';

/*!
 * numeral.js language configuration
 * language : polish (pl)
 * author : Dominik Bulaj : https://github.com/dominikbulaj
 */
(function () {
    var language = {
        delimiters: {
            thousands: ' ',
            decimal: ','
        },
        abbreviations: {
            thousand: 'tys.',
            million: 'mln',
            billion: 'mld',
            trillion: 'bln'
        },
        ordinal: function ordinal(number) {
            return '.';
        },
        currency: {
            symbol: 'PLN'
        }
    };

    // Node
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = language;
    }
})();

},{}],478:[function(require,module,exports){
'use strict';

/*!
 * numeral.js language configuration
 * language : portuguese brazil (pt-br)
 * author : Ramiro Varandas Jr : https://github.com/ramirovjr
 */
(function () {
    var language = {
        delimiters: {
            thousands: '.',
            decimal: ','
        },
        abbreviations: {
            thousand: 'mil',
            million: 'milhões',
            billion: 'b',
            trillion: 't'
        },
        ordinal: function ordinal(number) {
            return 'º';
        },
        currency: {
            symbol: 'R$'
        }
    };

    // Node
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = language;
    }
})();

},{}],479:[function(require,module,exports){
'use strict';

/*!
 * numeral.js language configuration
 * language : swedish
 * author :
 */
(function () {
    var language = {
        delimiters: {
            thousands: ' ',
            decimal: ','
        },
        abbreviations: {
            thousand: 't',
            million: 'mn',
            billion: 'md',
            trillion: 'bn'
        },
        ordinal: function ordinal(number) {
            return '.';
        },
        currency: {
            symbol: 'SEK'
        }
    };

    // Node
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = language;
    }
})();

},{}],480:[function(require,module,exports){
'use strict';

/*!
 * numeral.js language configuration
 * language : turkish (tr)
 * author : Ecmel Ercan : https://github.com/ecmel, Erhan Gundogan : https://github.com/erhangundogan, Burak Yiğit Kaya: https://github.com/BYK
 */
(function () {
    var suffixes = {
        1: '\'inci',
        5: '\'inci',
        8: '\'inci',
        70: '\'inci',
        80: '\'inci',

        2: '\'nci',
        7: '\'nci',
        20: '\'nci',
        50: '\'nci',

        3: '\'üncü',
        4: '\'üncü',
        100: '\'üncü',

        6: '\'ncı',

        9: '\'uncu',
        10: '\'uncu',
        30: '\'uncu',

        60: '\'ıncı',
        90: '\'ıncı'
    },
        language = {
        delimiters: {
            thousands: '.',
            decimal: ','
        },
        abbreviations: {
            thousand: 'bin',
            million: 'milyon',
            billion: 'milyar',
            trillion: 'trilyon'
        },
        ordinal: function ordinal(number) {
            if (number === 0) {
                // special case for zero
                return '\'ıncı';
            }

            var a = number % 10,
                b = number % 100 - a,
                c = number >= 100 ? 100 : null;

            return suffixes[a] || suffixes[b] || suffixes[c];
        },
        currency: {
            symbol: '₺'
        }
    };

    // Node
    if (typeof module !== 'undefined' && module.exports) {
        module.exports = language;
    }
})();

},{}],481:[function(require,module,exports){
'use strict';

/*!
 * numeral.js
 * version : 1.5.3
 * author : Adam Draper
 * license : MIT
 * http://adamwdraper.github.com/Numeral-js/
 */

(function () {

    /************************************
        Constants
    ************************************/

    var _numeral,
        VERSION = '1.5.3',

    // internal storage for language config files
    languages = {},
        currentLanguage = 'en',
        zeroFormat = null,
        defaultFormat = '0,0',

    // check for nodeJS
    hasModule = typeof module !== 'undefined' && module.exports;

    /************************************
        Constructors
    ************************************/

    // Numeral prototype object
    function Numeral(number) {
        this._value = number;
    }

    /**
     * Implementation of toFixed() that treats floats more like decimals
     *
     * Fixes binary rounding issues (eg. (0.615).toFixed(2) === '0.61') that present
     * problems for accounting- and finance-related software.
     */
    function toFixed(value, precision, roundingFunction, optionals) {
        var power = Math.pow(10, precision),
            optionalsRegExp,
            output;

        //roundingFunction = (roundingFunction !== undefined ? roundingFunction : Math.round);
        // Multiply up by precision, round accurately, then divide and use native toFixed():
        output = (roundingFunction(value * power) / power).toFixed(precision);

        if (optionals) {
            optionalsRegExp = new RegExp('0{1,' + optionals + '}$');
            output = output.replace(optionalsRegExp, '');
        }

        return output;
    }

    /************************************
        Formatting
    ************************************/

    // determine what type of formatting we need to do
    function formatNumeral(n, format, roundingFunction) {
        var output;

        // figure out what kind of format we are dealing with
        if (format.indexOf('$') > -1) {
            // currency!!!!!
            output = formatCurrency(n, format, roundingFunction);
        } else if (format.indexOf('%') > -1) {
            // percentage
            output = formatPercentage(n, format, roundingFunction);
        } else if (format.indexOf(':') > -1) {
            // time
            output = formatTime(n, format);
        } else {
            // plain ol' numbers or bytes
            output = formatNumber(n._value, format, roundingFunction);
        }

        // return string
        return output;
    }

    // revert to number
    function unformatNumeral(n, string) {
        var stringOriginal = string,
            thousandRegExp,
            millionRegExp,
            billionRegExp,
            trillionRegExp,
            suffixes = ['KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'],
            bytesMultiplier = false,
            power;

        if (string.indexOf(':') > -1) {
            n._value = unformatTime(string);
        } else {
            if (string === zeroFormat) {
                n._value = 0;
            } else {
                if (languages[currentLanguage].delimiters.decimal !== '.') {
                    string = string.replace(/\./g, '').replace(languages[currentLanguage].delimiters.decimal, '.');
                }

                // see if abbreviations are there so that we can multiply to the correct number
                thousandRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.thousand + '(?:\\)|(\\' + languages[currentLanguage].currency.symbol + ')?(?:\\))?)?$');
                millionRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.million + '(?:\\)|(\\' + languages[currentLanguage].currency.symbol + ')?(?:\\))?)?$');
                billionRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.billion + '(?:\\)|(\\' + languages[currentLanguage].currency.symbol + ')?(?:\\))?)?$');
                trillionRegExp = new RegExp('[^a-zA-Z]' + languages[currentLanguage].abbreviations.trillion + '(?:\\)|(\\' + languages[currentLanguage].currency.symbol + ')?(?:\\))?)?$');

                // see if bytes are there so that we can multiply to the correct number
                for (power = 0; power <= suffixes.length; power++) {
                    bytesMultiplier = string.indexOf(suffixes[power]) > -1 ? Math.pow(1024, power + 1) : false;

                    if (bytesMultiplier) {
                        break;
                    }
                }

                // do some math to create our number
                n._value = (bytesMultiplier ? bytesMultiplier : 1) * (stringOriginal.match(thousandRegExp) ? Math.pow(10, 3) : 1) * (stringOriginal.match(millionRegExp) ? Math.pow(10, 6) : 1) * (stringOriginal.match(billionRegExp) ? Math.pow(10, 9) : 1) * (stringOriginal.match(trillionRegExp) ? Math.pow(10, 12) : 1) * (string.indexOf('%') > -1 ? 0.01 : 1) * ((string.split('-').length + Math.min(string.split('(').length - 1, string.split(')').length - 1)) % 2 ? 1 : -1) * Number(string.replace(/[^0-9\.]+/g, ''));

                // round if we are talking about bytes
                n._value = bytesMultiplier ? Math.ceil(n._value) : n._value;
            }
        }
        return n._value;
    }

    function formatCurrency(n, format, roundingFunction) {
        var symbolIndex = format.indexOf('$'),
            openParenIndex = format.indexOf('('),
            minusSignIndex = format.indexOf('-'),
            space = '',
            spliceIndex,
            output;

        // check for space before or after currency
        if (format.indexOf(' $') > -1) {
            space = ' ';
            format = format.replace(' $', '');
        } else if (format.indexOf('$ ') > -1) {
            space = ' ';
            format = format.replace('$ ', '');
        } else {
            format = format.replace('$', '');
        }

        // format the number
        output = formatNumber(n._value, format, roundingFunction);

        // position the symbol
        if (symbolIndex <= 1) {
            if (output.indexOf('(') > -1 || output.indexOf('-') > -1) {
                output = output.split('');
                spliceIndex = 1;
                if (symbolIndex < openParenIndex || symbolIndex < minusSignIndex) {
                    // the symbol appears before the "(" or "-"
                    spliceIndex = 0;
                }
                output.splice(spliceIndex, 0, languages[currentLanguage].currency.symbol + space);
                output = output.join('');
            } else {
                output = languages[currentLanguage].currency.symbol + space + output;
            }
        } else {
            if (output.indexOf(')') > -1) {
                output = output.split('');
                output.splice(-1, 0, space + languages[currentLanguage].currency.symbol);
                output = output.join('');
            } else {
                output = output + space + languages[currentLanguage].currency.symbol;
            }
        }

        return output;
    }

    function formatPercentage(n, format, roundingFunction) {
        var space = '',
            output,
            value = n._value * 100;

        // check for space before %
        if (format.indexOf(' %') > -1) {
            space = ' ';
            format = format.replace(' %', '');
        } else {
            format = format.replace('%', '');
        }

        output = formatNumber(value, format, roundingFunction);

        if (output.indexOf(')') > -1) {
            output = output.split('');
            output.splice(-1, 0, space + '%');
            output = output.join('');
        } else {
            output = output + space + '%';
        }

        return output;
    }

    function formatTime(n) {
        var hours = Math.floor(n._value / 60 / 60),
            minutes = Math.floor((n._value - hours * 60 * 60) / 60),
            seconds = Math.round(n._value - hours * 60 * 60 - minutes * 60);
        return hours + ':' + (minutes < 10 ? '0' + minutes : minutes) + ':' + (seconds < 10 ? '0' + seconds : seconds);
    }

    function unformatTime(string) {
        var timeArray = string.split(':'),
            seconds = 0;
        // turn hours and minutes into seconds and add them all up
        if (timeArray.length === 3) {
            // hours
            seconds = seconds + Number(timeArray[0]) * 60 * 60;
            // minutes
            seconds = seconds + Number(timeArray[1]) * 60;
            // seconds
            seconds = seconds + Number(timeArray[2]);
        } else if (timeArray.length === 2) {
            // minutes
            seconds = seconds + Number(timeArray[0]) * 60;
            // seconds
            seconds = seconds + Number(timeArray[1]);
        }
        return Number(seconds);
    }

    function formatNumber(value, format, roundingFunction) {
        var negP = false,
            signed = false,
            optDec = false,
            abbr = '',
            abbrK = false,
            // force abbreviation to thousands
        abbrM = false,
            // force abbreviation to millions
        abbrB = false,
            // force abbreviation to billions
        abbrT = false,
            // force abbreviation to trillions
        abbrForce = false,
            // force abbreviation
        bytes = '',
            ord = '',
            abs = Math.abs(value),
            suffixes = ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'],
            min,
            max,
            power,
            w,
            precision,
            thousands,
            d = '',
            neg = false;

        // check if number is zero and a custom zero format has been set
        if (value === 0 && zeroFormat !== null) {
            return zeroFormat;
        } else {
            // see if we should use parentheses for negative number or if we should prefix with a sign
            // if both are present we default to parentheses
            if (format.indexOf('(') > -1) {
                negP = true;
                format = format.slice(1, -1);
            } else if (format.indexOf('+') > -1) {
                signed = true;
                format = format.replace(/\+/g, '');
            }

            // see if abbreviation is wanted
            if (format.indexOf('a') > -1) {
                // check if abbreviation is specified
                abbrK = format.indexOf('aK') >= 0;
                abbrM = format.indexOf('aM') >= 0;
                abbrB = format.indexOf('aB') >= 0;
                abbrT = format.indexOf('aT') >= 0;
                abbrForce = abbrK || abbrM || abbrB || abbrT;

                // check for space before abbreviation
                if (format.indexOf(' a') > -1) {
                    abbr = ' ';
                    format = format.replace(' a', '');
                } else {
                    format = format.replace('a', '');
                }

                if (abs >= Math.pow(10, 12) && !abbrForce || abbrT) {
                    // trillion
                    abbr = abbr + languages[currentLanguage].abbreviations.trillion;
                    value = value / Math.pow(10, 12);
                } else if (abs < Math.pow(10, 12) && abs >= Math.pow(10, 9) && !abbrForce || abbrB) {
                    // billion
                    abbr = abbr + languages[currentLanguage].abbreviations.billion;
                    value = value / Math.pow(10, 9);
                } else if (abs < Math.pow(10, 9) && abs >= Math.pow(10, 6) && !abbrForce || abbrM) {
                    // million
                    abbr = abbr + languages[currentLanguage].abbreviations.million;
                    value = value / Math.pow(10, 6);
                } else if (abs < Math.pow(10, 6) && abs >= Math.pow(10, 3) && !abbrForce || abbrK) {
                    // thousand
                    abbr = abbr + languages[currentLanguage].abbreviations.thousand;
                    value = value / Math.pow(10, 3);
                }
            }

            // see if we are formatting bytes
            if (format.indexOf('b') > -1) {
                // check for space before
                if (format.indexOf(' b') > -1) {
                    bytes = ' ';
                    format = format.replace(' b', '');
                } else {
                    format = format.replace('b', '');
                }

                for (power = 0; power <= suffixes.length; power++) {
                    min = Math.pow(1024, power);
                    max = Math.pow(1024, power + 1);

                    if (value >= min && value < max) {
                        bytes = bytes + suffixes[power];
                        if (min > 0) {
                            value = value / min;
                        }
                        break;
                    }
                }
            }

            // see if ordinal is wanted
            if (format.indexOf('o') > -1) {
                // check for space before
                if (format.indexOf(' o') > -1) {
                    ord = ' ';
                    format = format.replace(' o', '');
                } else {
                    format = format.replace('o', '');
                }

                ord = ord + languages[currentLanguage].ordinal(value);
            }

            if (format.indexOf('[.]') > -1) {
                optDec = true;
                format = format.replace('[.]', '.');
            }

            w = value.toString().split('.')[0];
            precision = format.split('.')[1];
            thousands = format.indexOf(',');

            if (precision) {
                if (precision.indexOf('[') > -1) {
                    precision = precision.replace(']', '');
                    precision = precision.split('[');
                    d = toFixed(value, precision[0].length + precision[1].length, roundingFunction, precision[1].length);
                } else {
                    d = toFixed(value, precision.length, roundingFunction);
                }

                w = d.split('.')[0];

                if (d.split('.')[1].length) {
                    d = languages[currentLanguage].delimiters.decimal + d.split('.')[1];
                } else {
                    d = '';
                }

                if (optDec && Number(d.slice(1)) === 0) {
                    d = '';
                }
            } else {
                w = toFixed(value, null, roundingFunction);
            }

            // format number
            if (w.indexOf('-') > -1) {
                w = w.slice(1);
                neg = true;
            }

            if (thousands > -1) {
                w = w.toString().replace(/(\d)(?=(\d{3})+(?!\d))/g, '$1' + languages[currentLanguage].delimiters.thousands);
            }

            if (format.indexOf('.') === 0) {
                w = '';
            }

            return (negP && neg ? '(' : '') + (!negP && neg ? '-' : '') + (!neg && signed ? '+' : '') + w + d + (ord ? ord : '') + (abbr ? abbr : '') + (bytes ? bytes : '') + (negP && neg ? ')' : '');
        }
    }

    /************************************
        Top Level Functions
    ************************************/

    _numeral = function numeral(input) {
        if (_numeral.isNumeral(input)) {
            input = input.value();
        } else if (input === 0 || typeof input === 'undefined') {
            input = 0;
        } else if (!Number(input)) {
            input = _numeral.fn.unformat(input);
        }

        return new Numeral(Number(input));
    };

    // version number
    _numeral.version = VERSION;

    // compare numeral object
    _numeral.isNumeral = function (obj) {
        return obj instanceof Numeral;
    };

    // This function will load languages and then set the global language.  If
    // no arguments are passed in, it will simply return the current global
    // language key.
    _numeral.language = function (key, values) {
        if (!key) {
            return currentLanguage;
        }

        if (key && !values) {
            if (!languages[key]) {
                throw new Error('Unknown language : ' + key);
            }
            currentLanguage = key;
        }

        if (values || !languages[key]) {
            loadLanguage(key, values);
        }

        return _numeral;
    };

    // This function provides access to the loaded language data.  If
    // no arguments are passed in, it will simply return the current
    // global language object.
    _numeral.languageData = function (key) {
        if (!key) {
            return languages[currentLanguage];
        }

        if (!languages[key]) {
            throw new Error('Unknown language : ' + key);
        }

        return languages[key];
    };

    _numeral.language('en', {
        delimiters: {
            thousands: ',',
            decimal: '.'
        },
        abbreviations: {
            thousand: 'k',
            million: 'm',
            billion: 'b',
            trillion: 't'
        },
        ordinal: function ordinal(number) {
            var b = number % 10;
            return ~ ~(number % 100 / 10) === 1 ? 'th' : b === 1 ? 'st' : b === 2 ? 'nd' : b === 3 ? 'rd' : 'th';
        },
        currency: {
            symbol: '$'
        }
    });

    _numeral.zeroFormat = function (format) {
        zeroFormat = typeof format === 'string' ? format : null;
    };

    _numeral.defaultFormat = function (format) {
        defaultFormat = typeof format === 'string' ? format : '0.0';
    };

    /************************************
        Helpers
    ************************************/

    function loadLanguage(key, values) {
        languages[key] = values;
    }

    /************************************
        Floating-point helpers
    ************************************/

    // The floating-point helper functions and implementation
    // borrows heavily from sinful.js: http://guipn.github.io/sinful.js/

    /**
     * Array.prototype.reduce for browsers that don't support it
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce#Compatibility
     */
    if ('function' !== typeof Array.prototype.reduce) {
        Array.prototype.reduce = function (callback, opt_initialValue) {
            'use strict';

            if (null === this || 'undefined' === typeof this) {
                // At the moment all modern browsers, that support strict mode, have
                // native implementation of Array.prototype.reduce. For instance, IE8
                // does not support strict mode, so this check is actually useless.
                throw new TypeError('Array.prototype.reduce called on null or undefined');
            }

            if ('function' !== typeof callback) {
                throw new TypeError(callback + ' is not a function');
            }

            var index,
                value,
                length = this.length >>> 0,
                isValueSet = false;

            if (1 < arguments.length) {
                value = opt_initialValue;
                isValueSet = true;
            }

            for (index = 0; length > index; ++index) {
                if (this.hasOwnProperty(index)) {
                    if (isValueSet) {
                        value = callback(value, this[index], index, this);
                    } else {
                        value = this[index];
                        isValueSet = true;
                    }
                }
            }

            if (!isValueSet) {
                throw new TypeError('Reduce of empty array with no initial value');
            }

            return value;
        };
    }

    /**
     * Computes the multiplier necessary to make x >= 1,
     * effectively eliminating miscalculations caused by
     * finite precision.
     */
    function multiplier(x) {
        var parts = x.toString().split('.');
        if (parts.length < 2) {
            return 1;
        }
        return Math.pow(10, parts[1].length);
    }

    /**
     * Given a variable number of arguments, returns the maximum
     * multiplier that must be used to normalize an operation involving
     * all of them.
     */
    function correctionFactor() {
        var args = Array.prototype.slice.call(arguments);
        return args.reduce(function (prev, next) {
            var mp = multiplier(prev),
                mn = multiplier(next);
            return mp > mn ? mp : mn;
        }, -Infinity);
    }

    /************************************
        Numeral Prototype
    ************************************/

    _numeral.fn = Numeral.prototype = {

        clone: function clone() {
            return _numeral(this);
        },

        format: function format(inputString, roundingFunction) {
            return formatNumeral(this, inputString ? inputString : defaultFormat, roundingFunction !== undefined ? roundingFunction : Math.round);
        },

        unformat: function unformat(inputString) {
            if (Object.prototype.toString.call(inputString) === '[object Number]') {
                return inputString;
            }
            return unformatNumeral(this, inputString ? inputString : defaultFormat);
        },

        value: function value() {
            return this._value;
        },

        valueOf: function valueOf() {
            return this._value;
        },

        set: function set(value) {
            this._value = Number(value);
            return this;
        },

        add: function add(value) {
            var corrFactor = correctionFactor.call(null, this._value, value);
            function cback(accum, curr, currI, O) {
                return accum + corrFactor * curr;
            }
            this._value = [this._value, value].reduce(cback, 0) / corrFactor;
            return this;
        },

        subtract: function subtract(value) {
            var corrFactor = correctionFactor.call(null, this._value, value);
            function cback(accum, curr, currI, O) {
                return accum - corrFactor * curr;
            }
            this._value = [value].reduce(cback, this._value * corrFactor) / corrFactor;
            return this;
        },

        multiply: function multiply(value) {
            function cback(accum, curr, currI, O) {
                var corrFactor = correctionFactor(accum, curr);
                return accum * corrFactor * (curr * corrFactor) / (corrFactor * corrFactor);
            }
            this._value = [this._value, value].reduce(cback, 1);
            return this;
        },

        divide: function divide(value) {
            function cback(accum, curr, currI, O) {
                var corrFactor = correctionFactor(accum, curr);
                return accum * corrFactor / (curr * corrFactor);
            }
            this._value = [this._value, value].reduce(cback);
            return this;
        },

        difference: function difference(value) {
            return Math.abs(_numeral(this._value).subtract(value).value());
        }

    };

    /************************************
        Exposing Numeral
    ************************************/

    module.exports = _numeral;
}).call(undefined);

},{}],482:[function(require,module,exports){
'use strict';

var cosmos = require('spotify-cosmos-api');
var model = require('spotify-page-logger-model');

function logging(page, type, entityUri) {
  var req = {
    url: 'sp://logging/v1/log',
    body: {
      message: 'PageView',
      version: 1,
      fields: ['' + type, '' + Date.now(), '' + page, '' + entityUri]
    }
  };

  cosmos.resolver.post(req, function () {});
}

// The main goal of this module is to give the ability of logging page enters and page exits,
// limiting developers to log random strings. Only pages defined inside the model can be logged,
// and otherwise, "unknown" should be used.
module.exports = model(function (page) {
  return function (type, entityUri) {
    logging(page, type, entityUri);
  };
});

// Constants for types ('enter' when entering a view, and 'exit' when leaving).
module.exports.TYPE_ENTER = 'enter';
module.exports.TYPE_EXIT = 'exit';

},{"spotify-cosmos-api":694,"spotify-page-logger-model":709}],483:[function(require,module,exports){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var AddToPlaylist3 = require('../../libs/spotify-logger/messages/AddToPlaylist3');
var liburi = require('spotify-liburi');

var _addTracksToPlaylist = require('./playlist-actions').addTracksToPlaylist;

var PlaylistActions = exports.PlaylistActions = function () {
  function PlaylistActions(live, bridgeRequestFn, cosmos) {
    _classCallCheck(this, PlaylistActions);

    this._live = live;
    this._bridge = bridgeRequestFn;
    this._cosmos = cosmos;
  }

  _createClass(PlaylistActions, [{
    key: 'getCollaborativeStatus',
    value: function getCollaborativeStatus(uri, cb) {
      var query = 'collaborative, published';

      this._live(uri.toString()).query(query, cb, this._live.ASAP);
    }
  }, {
    key: 'setPlaylistPublished',
    value: function setPlaylistPublished(uri, publish, cb) {
      var _this = this;

      var uriStr = uri.toString();

      this._bridge(publish ? 'library_publish' : 'library_unpublish', ['spotify:user:@', uriStr], function (err, data) {
        if (!err) {
          _this._live(uriStr).update({
            published: publish
          });
        }
        return cb(err, data);
      });
    }
  }, {
    key: 'isPlaylistOffline',
    value: function isPlaylistOffline(uri, cb) {
      this._live(uri.toString()).query('shouldBeOffline', function (err, data) {
        if (err) {
          cb(err);
          return;
        }
        cb(null, !!data.shouldBeOffline);
      }, this._live.ASAP);
    }
  }, {
    key: 'createNewPlaylist',
    value: function createNewPlaylist(name, cb) {
      this._bridge('playlist_create', [name], function (err, data) {
        if (err) {
          cb(err);
          return;
        }
        cb(null, data.uri);
      });
    }
  }, {
    key: 'logAddToPlaylist',
    value: function logAddToPlaylist(data) {
      var intent;
      if (data.isNew) {
        intent = 'create-new-playlist';
      } else if (data.isInFolder) {
        intent = 'add-to-playlist-in-folder';
      } else {
        intent = 'add-to-playlist';
      }

      AddToPlaylist3.log({
        /* eslint-disable */
        intent: intent,
        item_uri: data.uris[0].toURI(),
        number_items: data.uris.length,
        section: 'all-playlists',
        source: data.appUri,
        source_action: 'add-to-playlist',
        playlist_index: data.playlistIndex,
        playlist_uri: data.playlistUri,
        total_number_playlists: data.numberOfVisibleItems,
        time: Math.round(Date.now() / 1000)
      });
    }
  }, {
    key: 'addTracksToPlaylist',
    /* eslint-enable */
    value: function addTracksToPlaylist(uri, tracks, cb) {
      var tracksStr = tracks.map(function (trackUri) {
        return trackUri.toString();
      });

      _addTracksToPlaylist(this._cosmos, uri, tracksStr, cb);
    }
  }, {
    key: 'addAlbumToPlaylist',
    value: function addAlbumToPlaylist(playlistUri, albumUri, cb) {
      var _this2 = this;

      var args = [albumUri.toString(), 0, -1];

      return this._bridge('album_tracks_snapshot', args, function (err, resp) {
        if (err) {
          cb(err);
          return;
        }
        _this2.addTracksToPlaylist(playlistUri, resp.array, cb);
      });
    }
  }, {
    key: 'addStuffToPlaylist',
    value: function addStuffToPlaylist(playlistUri, uris, cb) {
      if (uris[0].type === liburi.Type.ALBUM) {
        this.addAlbumToPlaylist(playlistUri, uris[0], cb);
        if (uris.length > 1) {
          console.warn('Passed more than a single album to addStuffToPlaylist(). Adding only one.');
        }
      } else {
        this.addTracksToPlaylist(playlistUri, uris, cb);
      }
    }
  }, {
    key: 'refreshedPlaylistName',
    value: function refreshedPlaylistName(oldName) {
      if (!oldName) {
        // TODO(jaco): Should be localised, but since the name is still very much up
        // in the air and this will only go out to employees, we don't want to send
        // it off for translation yet since it will likely change a couple of times
        // before we're happy with it.
        return 'Similar Playlist';
      }

      var nextInt = function nextInt(intStr) {
        return parseInt(intStr, 10) + 1;
      };

      // Parenthesized number suffix: "Playlist (2)"
      var matches = oldName.match(new RegExp('(.*)\\((\\d+)\\)$'));
      if (matches) {
        return matches[1].trim() + ' (' + nextInt(matches[2]) + ')';
      }

      return oldName + ' (2)';
    }
  }, {
    key: 'createRefreshedPlaylist',
    value: function createRefreshedPlaylist(playlistUri, cb) {
      var _this3 = this;

      var oldName = this._live(playlistUri.toString()).get('name');
      var name = this.refreshedPlaylistName(oldName);

      this._cosmos.resolver.post({
        url: 'hm://playlistfreshener/freshen',
        body: {
          playlistURI: playlistUri.toString(),
          type: 'W2V_freshener'
        }
      }, function (error, response) {
        if (error) {
          cb(error);
          return;
        }

        var body = response.getJSONBody();
        var trackUris = body.recommendedTracks.map(function (r) {
          return 'spotify:track:' + r.id;
        });

        _this3.createNewPlaylist(name, function (createNewPlaylistError, newPlaylistUri) {
          if (createNewPlaylistError) {
            cb(createNewPlaylistError);
            return;
          }

          _this3.addTracksToPlaylist(newPlaylistUri, trackUris, function (addTracksToPlaylistError) {
            cb(addTracksToPlaylistError, newPlaylistUri);
          });
        });
      });
    }
  }, {
    key: 'setPlaylistCollaborative',
    value: function setPlaylistCollaborative(uri, collaborative, cb) {
      var _this4 = this;

      this._bridge('playlist_set_collaborative', [uri.toString(), collaborative], function (err) {
        if (err) {
          cb(err);
          return;
        }
        if (collaborative) {
          // when we set a playlist as collaborative, check if
          // it's public and make it private
          _this4.getCollaborativeStatus(uri, function (error, data) {
            if (error || data.published === null) {
              console.error(error || new Error('`published` property unexpectedly missing'));
              return;
            }

            if (data.published) {
              _this4.setPlaylistPublished(uri, false);
            }
          });
        }
        cb();
      });
    }
  }]);

  return PlaylistActions;
}();

},{"../../libs/spotify-logger/messages/AddToPlaylist3":450,"./playlist-actions":484,"spotify-liburi":707}],484:[function(require,module,exports){
(function (global){
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.addTracksToPlaylist = addTracksToPlaylist;
var DUPLICATE_ACTIONS = exports.DUPLICATE_ACTIONS = {
  ADD_ALL: 'add_all',
  ADD_UNIQUE: 'add_unique',
  CANCEL: 'cancel'
};

function getDuplicates(cosmos, playlistURI, trackURIs, callback) {
  cosmos.resolver.post({
    url: 'sp://core-playlist/v1/playlist/' + encodeURIComponent(playlistURI) + '/contains',
    body: {
      items: trackURIs
    }
  }, function (error, response) {
    if (error) {
      callback([]);
      return;
    }

    var body = response.getJSONBody();
    var foundByIndex = body.found;

    var duplicates = [];
    var uniques = [];

    trackURIs.forEach(function (uri, index) {
      if (foundByIndex[index]) {
        duplicates.push(trackURIs[index]);
      } else {
        uniques.push(trackURIs[index]);
      }
    });

    callback(duplicates, uniques);
  });
}

function maybeFilterDuplicates(cosmos, playlistURI, trackURIs, callback) {
  getDuplicates(cosmos, playlistURI, trackURIs, function (duplicates, uniques) {
    if (!duplicates.length) {
      callback(trackURIs);
      return;
    }

    cosmos.resolver.post({
      url: 'sp://messages/v1/avoidduplicates',
      body: {
        action: 'confirm',
        source: global.__spotify.app_uri,
        playlistUri: playlistURI,
        numItems: trackURIs.length,
        numDuplicates: duplicates.length
      }
    }, function (postError) {
      if (postError) {
        callback(trackURIs);
        return;
      }

      // Subscribe for the dialog response
      var subscription = cosmos.resolver.subscribe({
        url: 'sp://messages/v1/avoidduplicates'
      }, function (error, response) {
        subscription.cancel();
        if (error) {
          callback(trackURIs);
          return;
        }
        switch (response.getJSONBody().action) {
          case DUPLICATE_ACTIONS.ADD_ALL:
            callback(trackURIs);
            break;

          case DUPLICATE_ACTIONS.ADD_UNIQUE:
            callback(uniques);
            break;

          case DUPLICATE_ACTIONS.CANCEL:
            callback([]);
            break;

          default:
            throw new Error('Invalid DUPLICATE_ACTION.');
        }
      });
    });
  });
}

function addTracksToPlaylist(cosmos, playlistURI, trackURIs, cb) {
  maybeFilterDuplicates(cosmos, playlistURI, trackURIs, function (filteredTrackURIs) {
    if (!filteredTrackURIs.length) {
      cb();
      return;
    }

    cosmos.resolver.post({
      url: 'sp://core-playlist/v1/playlist/' + encodeURIComponent(playlistURI),
      body: {
        operation: 'add',
        uris: filteredTrackURIs,
        after: 'end'
      }
    }, function (error, response) {
      // TODO(jaco): Move over to status code checking when CORE-1638 is done.
      var trackLimitExceeded = error && response && response.getJSONBody() && /exceed the maximum playlist size/i.test(response.getJSONBody().error);
      if (trackLimitExceeded) {
        cosmos.resolver.post({
          url: 'sp://messages/v1/container/user-message',
          body: { id: 'playlist-limit-exceeded' }
        });
      }

      if (error) {
        cb(error);
        return;
      }
      cb();
    });
  });
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],485:[function(require,module,exports){
(function (global){
'use strict';

exports.ALWAYS_FORM_AND_VISIBLE_HEADER_HINT = '0';
exports.ALWAYS_FORM_NO_VISIBLE_HEADER_HINT = '1';
exports.INLINE_CREATE_AND_VISIBLE_HEADER_HINT = '2';
exports.INLINE_CREATE_NO_VISIBLE_HEADER_HINT = '3';

exports.getTestCell = function () {
  var productState = global.__spotify && global.__spotify.product_state || {};

  var isTestEnabled = productState['enable-annotations'] === '2';
  return isTestEnabled && productState['ab-desktop-playlist-annotation-edit'] || null;
};

exports.isEnabled = function () {
  var flag = global.__spotify && global.__spotify.product_state && global.__spotify.product_state['enable-annotations'];
  return flag === '1' || flag === '2';
};

exports.isMarkupAllowed = function () {
  var flag = global.__spotify && global.__spotify.product_state && global.__spotify.product_state['playlist-annotations-markup'];
  return flag === '1';
};

exports.hasContextMenuEditAction = function () {
  return exports.isEnabled();
};

exports.hasContextMenuRenameAction = function () {
  return !exports.isEnabled();
};

exports.shouldShowAnnotateWhenCreating = function () {
  var testCell = exports.getTestCell();
  return testCell === null || testCell === exports.ALWAYS_FORM_AND_VISIBLE_HEADER_HINT || testCell === exports.ALWAYS_FORM_NO_VISIBLE_HEADER_HINT;
};

exports.hasVisibleHeaderHint = function () {
  var testCell = exports.getTestCell();
  return testCell === exports.ALWAYS_FORM_AND_VISIBLE_HEADER_HINT || testCell === exports.INLINE_CREATE_AND_VISIBLE_HEADER_HINT;
};

exports.hasSidebarRenameFieldHintButton = function () {
  var testCell = exports.getTestCell();
  return testCell === exports.INLINE_CREATE_AND_VISIBLE_HEADER_HINT || testCell === exports.INLINE_CREATE_NO_VISIBLE_HEADER_HINT;
};

exports.hasVisibleFormPermissionMessage = function () {
  return exports.getTestCell() !== null;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],486:[function(require,module,exports){

'use strict';

/**
 * Module dependencies
 */

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol ? "symbol" : typeof obj; };

var extend = require('extend'),
    bridge = require('../spotify-bridge-request'),
    batch = require('spotify-batch');

/**
 * Bridge methods
 */

var PREF_ALL = 'preferences_all';
var PREF_GET = 'preferences_get';
var PREF_SET = 'preferences_set';
var PREF_SUB = 'preferences_event_wait';

/**
 * Converts a string with dot notation into
 * a nested object where the last key is
 * set to value
 *
 *  eg: f('foo.bar', 123) = {foo: {bar: 123}}
 *
 * @api private
 * @param {String} string
 * @param {Mixed} value
 * @param {String} delimiter - optional
 */

function TransformStringIntoObjectAndSetValue(string, value, delimiter) {
  var object = {};
  string.split(delimiter || '.').reduce(function (o, c, i, a) {
    if (i < a.length - 1) {
      o[c] = {};
    } else {
      o[c] = value;
    }

    return o[c];
  }, object);

  return object;
}

/**
 * Converts an object with nest objects into a flat object
 *
 *  eg: f({foo: {bar: 123}}) = {'foo.bar': 123}
 *
 * @api private
 * @param {String} string
 * @param {String} delimiter - optional
 */

function TransformObjectIntoFlatObject(object, delimiter) {
  var flattened = {};
  delimiter = delimiter || '.';
  function traverse(o, key) {
    var tmp = null;
    for (var p in o) {
      if ('object' == _typeof(o[p])) {
        key = key ? [key, p].join(delimiter) : p;
        traverse(o[p], key);
      } else {
        tmp = key ? [key, p].join(delimiter) : p;
        flattened[tmp] = o[p];
      }
    }
  }

  traverse(object);
  return flattened;
}

/**
 * Normalizes data from bridge responses
 *
 * @api private
 * @param {String} key
 * @param {Object} data
 * @param {Boolean} preserve - optional (Default: false)
 */

function NormalizeData(key, data, preserve) {
  var out = {};
  var regex = '*' == key ? null : RegExp('^' + key);
  var targets = null;

  if ('object' != (typeof data === 'undefined' ? 'undefined' : _typeof(data))) {
    return data;
  }

  targets = Object.keys(data).map(function (key) {
    if (null == regex || regex.test(key)) {
      return [key, data[key]];
    }
  }).filter(Boolean).reduce(function (t, c) {
    t[c[0]] = c[1];
    return t;
  }, {});

  Object.keys(targets).forEach(function (key) {
    // extend output object with transformed properties
    extend(true, out, TransformStringIntoObjectAndSetValue(key, targets[key]));
  });

  if ('*' == key || true === preserve) {
    return out;
  } else {
    return key.split('.').reduce(function (o, k) {
      return o[k];
    }, out);
  }
}

/**
 * Subscribes to a key.
 *
 * @api private
 * @param {Function} rpc The RPC to use.
 * @param {String} key The key (including path).
 * @param {*} lastValue The last value of the key (used for comparing).
 * @param {Function} fn Subscribe handler.
 * @param {Object=} sub Subscription object, optional.
 */

function SubscribeToKey(rpc, key, lastValue, fn, sub) {
  sub = sub || {
    isCancelled: false,
    cancel: function cancel() {
      this.isCancelled = true;
    }
  };

  rpc(PREF_SUB, [], function (err, res) {
    if (sub.isCancelled) return;

    var didValueChange = false;

    if (res) {
      var value = NormalizeData(key, res);
      if (value !== lastValue) {
        lastValue = value;
        didValueChange = true;
      }
    }

    // Resubscribe since one subscription is only for one response
    SubscribeToKey(rpc, key, lastValue, fn, sub);

    if (didValueChange) {
      fn(null, lastValue);
    }
  });

  return sub;
}

/**
 * `Preferences' constructor
 *
 * @api public
 * @param {String} path - optional (Default: '*')
 * @param {Function} rpc - optional
 */

module.exports = Preferences;
function Preferences(path, rpc) {
  if (!(this instanceof Preferences)) {
    return new Preferences(path, rpc);
  }

  this.path = path || '*';
  this.rpc = rpc || bridge.request.bind(bridge);
}

/**
 * Retrieves all preferences at path.
 * If path is '*' then all preferences
 * are retrieved.
 *
 * @api public
 * @param {Function} fn
 */

Preferences.prototype.all = function (fn) {
  var self = this;
  var path = this.path;

  this.rpc(PREF_ALL, [], function (err, res) {
    if (err) {
      return fn(err);
    } else if ('*' == path) {
      fn(null, res);
    } else {
      fn(null, NormalizeData(path, res, true));
    }
  });

  return this;
};

/**
 * Sets a preference at key at path
 * with value
 *
 * @api public
 * @param {String} key
 * @param {Mixed} value
 * @param {Function} fn
 */

Preferences.prototype.set = function (key, value, fn) {
  var self = this;
  var path = this.path;
  var tmp = null;
  var map = null;
  var jobs = null;

  // handle batch jobs to extend bridge preferences
  if ('object' == (typeof key === 'undefined' ? 'undefined' : _typeof(key))) {
    fn = value;

    map = TransformObjectIntoFlatObject(key);
    jobs = batch().concurrency(1);
    Object.keys(map).forEach(function (k) {
      jobs.push(function (next) {
        self.set(k, map[k], next);
      });
    });

    jobs.run(fn);
  } else {
    key = '*' == path ? key : [path, key].join('.');
    this.rpc(PREF_SET, [key, value], fn);
  }
  return this;
};

/**
 * Sets a preference bitflag at path, based on the inputs.
 *
 * @api public
 * @param {String} key
 * @param {Array} flagBoolPairs
 * @param {Function} fn
 */

Preferences.prototype.setAtomicFlags = function (key, flagBoolPairs, fn) {
  var self = this;

  self.get(key, function (err, value) {
    if (err) return fn(err);

    flagBoolPairs.forEach(function (pair) {
      var flag = pair[0];
      var bool = pair[1];
      if (bool === undefined || bool === null) return;
      if (bool) value |= flag;else value &= ~flag;
    });

    self.set(key, value, fn);
  });
};

/**
 * Gets a preference at key at path
 *
 * @api public
 * @param {String} key
 * @param {Function} fn
 */

Preferences.prototype.get = function (key, fn) {
  var self = this;
  key = '*' == this.path ? key : [this.path, key].join('.');

  // try to get property first
  this.rpc(PREF_GET, [key], function (err, res) {
    var value = res ? NormalizeData(key, res) : null;
    if (null == value) {
      self.rpc(PREF_ALL, [], function (err, res) {
        if (err) {
          return fn(err);
        } else {
          fn(null, NormalizeData(key, res));
        }
      });
    } else {
      fn(null, NormalizeData(key, res));
    }
  });
  return this;
};

/**
 * Subscribes to a preference at key at path
 *
 * @api public
 * @param {String} key
 * @param {Function} fn
 */

Preferences.prototype.subscribe = function (key, fn) {
  var self = this;
  var sub = null;
  var cancelled = false;

  // Get initial value and then subscribe for changes
  this.get(key, function (err, res) {
    if (cancelled) return;
    var keyWithPath = '*' == self.path ? key : [self.path, key].join('.');
    sub = SubscribeToKey(self.rpc, keyWithPath, res, fn);

    // Respond to the GET (initial value for SUB)
    fn(err, res);
  });

  return {
    cancel: function cancel() {
      cancelled = true;
      if (sub) {
        sub.cancel();
      }
    }
  };
};

},{"../spotify-bridge-request":253,"extend":532,"spotify-batch":688}],487:[function(require,module,exports){
'use strict';

var EventEmitter = require('spotify-eventemitter');
var inheritance = require('spotify-inheritance');

var template = require('./template.hbs');

/**
 * Spotify progressbar. Time counter that emits events and updates an HTML
 * progress bar
 *
 * @param {DOMElement} container    DOM element where to render the progress bar
 * @param {int} maxValue            maximum value for the progress bar (ms)
 * @param {Object} options          Several customization options
 */
function ProgressBar(container, maxValue, options) {

  options = options || {};

  this._container = container;
  this._container.innerHTML = template();

  this._element = this._container.querySelector('.progress-bar-wrapper');
  this._innerElement = this._container.querySelector('.inner');

  this._disabled = options.disabled || false;
  this._currentValue = options.initialValue || 0;

  this._playbackSpeed = 1;

  this._updateIntervalTime = options.updateInterval || 0;

  this._maxUpdateIntervalTime = options.maxUpdateInterval || 1000;
  this._minUpdateIntervalTime = options.minUpdateInterval || 25;

  this._animationEnabled = true;

  this._useWebAnimations = typeof options.useWebAnimations === 'undefined' ? true : options.useWebAnimations;

  if (!('animate' in this._element) || !(this._element.animate instanceof Function)) {
    this._useWebAnimations = false;
  }

  this.setMaxValue(maxValue);

  this._onDragStart = this._onDragStart.bind(this);
  this._onDragEnd = this._onDragEnd.bind(this);
  this._onDragMove = this._onDragMove.bind(this);

  this._element.addEventListener('mousedown', this._onDragStart);

  this._element.addEventListener('touchstart', this._onDragStart);

  EventEmitter.call(this);
}
inheritance.inherit(ProgressBar, EventEmitter);

/**
 * Returns container element
 * Used to toggle progress bar color for video
 *
 * @return {DOMElement}
 */
ProgressBar.prototype.getContainer = function () {
  return this._container;
};

/**
 * Check whether the progressbar is playng
 *
 * @return {Boolean} true if it's playing
 */
ProgressBar.prototype.isPlaying = function () {
  if (this._animation) {
    return this._animation.playState === 'running';
  }

  return !!this._updateInterval;
};

/**
 * Get the maximum value
 *
 * @return {int} The value
 */
ProgressBar.prototype.getMaxValue = function () {
  return this._maxValue;
};

/**
 * Set the maximum value
 *
 * @param {int} value The value
 */
ProgressBar.prototype.setMaxValue = function (value) {
  if (this._maxValue === value) {
    return;
  }

  this._maxValue = value;

  var interval = this._calcUpdateInterval();

  if (interval === null) {
    this._createWebAnimation();
  } else {
    this._destroyWebAnimation();
  }

  this._emitProgress(true);
};

/**
 * Get the latest set value on the progressbar
 *
 * @return {int} The value
 */
ProgressBar.prototype.getValue = function () {
  if (this._animation) {
    return this._animation.currentTime;
  }
  return this._currentValue;
};

/**
 * Get the real current value on the progressbar
 *
 * @return {int} The value
 */
ProgressBar.prototype.getRealValue = function () {
  if (this._animation) {
    return this._animation.currentTime;
  }

  var value = this._currentValue || 0;

  // if the progressbar is playing, add the amount of time spent
  // since last update to the value
  if (this.isPlaying()) {
    var lastPlayTime = this._lastPlayTime || Date.now();
    value += (Date.now() - lastPlayTime) * this._playbackSpeed;
  }

  // return the calculated maxium value at this concrete moment
  return Math.min(this._maxValue, value);
};

/**
 * Sets a new value
 *
 * @param {int} value The value to set
 */
ProgressBar.prototype.setValue = function (value) {
  if (value > this.getMaxValue()) {
    value = this.getMaxValue();
  }

  if (value < 0) {
    value = 0;
  }

  return this._setValue(value, false);
};

/**
 * Sets playback speed
 *
 * @param {float} value The playback speed
 */
ProgressBar.prototype.setPlaybackSpeed = function (playbackSpeed) {
  if (playbackSpeed < 0) {
    playbackSpeed = 0;
  }
  this._playbackSpeed = playbackSpeed;
};

ProgressBar.prototype._calcStyleString = function (value) {
  var scale = (this.getMaxValue() - value) / this.getMaxValue() * 100;
  return scale + '%';
};

ProgressBar.prototype._createWebAnimation = function () {
  var isPlaying = this.isPlaying();
  var currentTime = this.getRealValue();

  // reset the standard position of the progress bar
  this._innerElement.style.right = this._calcStyleString(0);

  if (this._animation) {
    this._animation.cancel();
  }

  // reset the animation
  this._animation = this._innerElement.animate([{ right: this._calcStyleString(0) }, { right: this._calcStyleString(this.getMaxValue()) }], this.getMaxValue() + 1);

  if (!isPlaying) {
    this._animation.pause();
  }
  this._animation.currentTime = currentTime;
};

ProgressBar.prototype._destroyWebAnimation = function () {
  var isPlaying = this.isPlaying();
  var currentTime = this.getRealValue();

  if (this._animation) {
    this._animation.cancel();
    this._animation = null;
  }

  this._setValue(currentTime);

  if (isPlaying) {
    this.play();
  }
};

ProgressBar.prototype._setValue = function (value, isUpdate) {
  if (value > this.getMaxValue()) {
    value = 0;
    this.pause();
  }

  if (isUpdate) {
    this.emitSync('update', { value: value });
  }

  this._lastPlayTime = Date.now();

  if (value === this.getValue()) {
    return;
  }

  if (this._animation) {
    this._animation.currentTime = value;
  } else {
    this._currentValue = value;
    this._renderValue(value);
  }

  this._emitProgress();
};

ProgressBar.prototype._renderValue = function (value) {
  this._innerElement.style.right = this._calcStyleString(value);
};

ProgressBar.prototype.play = function () {
  this._createProgressEmitter();

  if (this._animation) {
    return this._animation.play();
  }

  var interval = this._calcUpdateInterval();

  if (interval) {
    if (this.isPlaying()) {
      this.pause();
    }

    this._setValue(this.getValue());

    this._updateInterval = setInterval(function () {
      if (this._animationEnabled) {
        this._renderValue(this.getRealValue());
      }
    }.bind(this), interval);
  }
};

ProgressBar.prototype.pause = function () {
  if (!this.isPlaying()) {
    return;
  }

  if (this._animation) {
    this._animation.pause();
  } else if (this._updateInterval) {
    this._setValue(this.getRealValue());
    clearInterval(this._updateInterval);
    this._updateInterval = null;
  }
};

ProgressBar.prototype.isDisabled = function () {
  return this._disabled;
};

ProgressBar.prototype.disable = function () {
  this._element.classList.remove('handle');
  this._disabled = true;
};

ProgressBar.prototype.enable = function () {
  this._element.classList.add('handle');
  this._disabled = false;
};

ProgressBar.prototype.disableAnimation = function () {
  this._animationEnabled = false;
};

ProgressBar.prototype.enableAnimation = function () {
  this._animationEnabled = true;
  this._renderValue(this.getRealValue());
  this._emitProgress();
};

ProgressBar.prototype._createProgressEmitter = function () {
  var self = this;

  var interval = 1000;

  if (!this._progressEmitter) {
    this._progressEmitter = setTimeout(function emitter() {
      if (!self.isPlaying()) {
        self._progressEmitter = null;
        return;
      }
      self._emitProgress();

      self._progressEmitter = setTimeout(emitter, interval);
    }, interval);
  }
};

ProgressBar.prototype._emitProgress = function (force) {
  if (!this._animationEnabled) {
    return;
  }

  var value = this.getRealValue();

  if (force || this._lastEmittedProgress !== Math.floor(value / 1000)) {
    this._lastEmittedProgress = Math.floor(value / 1000);
    this.emitSync('progress', { value: value });
  }
};

ProgressBar.prototype._calcUpdateInterval = function () {
  if (this._updateIntervalTime) {
    return this._updateIntervalTime;
  }

  var width = this._container.getBoundingClientRect().width;
  var length = this.getMaxValue();

  var updateInterval = Math.min(length / width, this._maxUpdateIntervalTime);

  if (updateInterval < this._minUpdateIntervalTime && this._useWebAnimations) {
    updateInterval = null;
  } else {
    updateInterval = Math.max(updateInterval, this._minUpdateIntervalTime);
  }

  if (isNaN(updateInterval)) {
    updateInterval = this._maxUpdateIntervalTime;
  }

  return updateInterval;
};

ProgressBar.prototype._calcPositionX = function (evt) {
  var x;
  var type = evt.type;
  if (type == 'touchstart' || type == 'touchmove' || type == 'touchend') {
    x = evt.changedTouches[0].pageX;
  } else {
    x = evt.pageX;
  }
  var rect = this._container.getBoundingClientRect();
  var scrollLeft = document.documentElement.scrollLeft;

  var posX = Math.max(x - rect.left - scrollLeft, 0);

  return Math.min(posX / rect.width * this.getMaxValue(), this.getMaxValue());
};

ProgressBar.prototype._isMouseLeftClick = function (evt) {
  var leftClick = false;

  if ('buttons' in evt) {
    leftClick = evt.buttons === 1;
  } else if ('which' in evt) {
    leftClick = evt.which === 1;
  } else if ('button' in evt) {
    leftClick = evt.button === 1;
  }

  return leftClick;
};

ProgressBar.prototype._onDragStart = function (evt) {
  if (this._disabled) {
    return;
  }

  if (!this._isMouseLeftClick(evt) && evt.type != 'touchstart') {
    return;
  }

  this._element.classList.add('active');

  this._playAfterDrag = this.isPlaying();
  this.pause();

  var value = this._calcPositionX(evt);
  this._setValue(value);

  window.addEventListener('mousemove', this._onDragMove);
  window.addEventListener('mouseup', this._onDragEnd);
  window.addEventListener('touchmove', this._onDragMove);
  window.addEventListener('touchend', this._onDragEnd);

  this.emit('drag-start', {
    container: this._container
  });
};

ProgressBar.prototype._onDragEnd = function (evt) {
  this._element.classList.remove('active');

  if (this._playAfterDrag) {
    this.play();
  }
  this._playAfterDrag = null;

  window.removeEventListener('mousemove', this._onDragMove);
  window.removeEventListener('mouseup', this._onDragEnd);
  window.removeEventListener('touchmove', this._onDragMove);
  window.removeEventListener('touchend', this._onDragEnd);

  this.emit('drag-end', {
    container: this._container
  });

  var value = this._calcPositionX(evt);
  this._setValue(value, true);
};

ProgressBar.prototype._onDragMove = function (evt) {
  var value = this._calcPositionX(evt);
  this.setValue(value);
};

/**
 * Export public interface
 */
module.exports = ProgressBar;

},{"./template.hbs":488,"spotify-eventemitter":700,"spotify-inheritance":705}],488:[function(require,module,exports){
// hbsfy compiled Handlebars template
var HandlebarsCompiler = require('hbsfy/runtime');
module.exports = HandlebarsCompiler.template(function (Handlebars,depth0,helpers,partials,data) {
  this.compilerInfo = [4,'>= 1.0.0'];
helpers = this.merge(helpers, Handlebars.helpers); data = data || {};



  return "<div class=\"progress-bar-wrapper handle\">\n  <div class=\"progress-bar\">\n    <div class=\"inner\">\n      <div class=\"handle\"></div>\n    </div>\n  </div>\n</div>\n";
  });

},{"hbsfy/runtime":563}],489:[function(require,module,exports){
/**
 * @module spotify-range2
 */
'use strict';

var prime = require('prime');

var map = require('mout/array/map');

var push_ = Array.prototype.push;
var slice_ = Array.prototype.slice;

var Range = prime( /** @lends Range.prototype */{

  /**
   * The representation of a range
   * @constructs
   * @param {Number} start The start of the range.
   * @param {Number} end The end of the range.
   */
  constructor: function Range(start, end) {
    this.update(start, end);
  },

  /** Update a range. */
  update: function update(start, end) {
    if (start !== null) this.start = start;
    if (end !== null) this.end = end;
    if (this.start === null || this.end === null) throw new Error('invalid range');
    if (this.start > this.end) throw new Error('invalid range');
    this.length = this.end - this.start;
    return this;
  },

  /** Copy a range. */
  copy: function copy() {
    return new Range(this.start, this.end);
  },

  /** Range is above range. */
  above: function above(range) {
    if (!range) return false;
    return this.start >= range.end;
  },

  /** Range is below range. */
  below: function below(range) {
    if (!range) return false;
    return this.end <= range.start;
  },

  adjacent: function adjacent(range) {
    if (!range) return false;
    return this.end === range.start || this.start === range.end;
  },

  /** Range intersects range. */
  intersects: function intersects(range) {
    if (!range) return false;
    return !this.above(range) && !this.below(range);
  },

  /** Range contains range. */
  contains: function contains(range) {
    if (!range) return false;
    return this.start <= range.start && this.end >= range.end;
  },

  /** Range is contained by ranges. */
  contained: function contained(range) {
    var ranges;
    if (range instanceof Range) ranges = arguments;else ranges = range;
    if (!ranges) return false;

    for (var i = 0; ranges[i] !== undefined; i++) {
      var r = ranges[i];
      if (r.start <= this.start && r.end >= this.end) {
        return true;
      }
    }
    return false;
  },

  /** Range fits two ranges. */
  fits: function fits(prev, next) {
    if (!prev && !next) return true;
    if (!prev) return this.end <= next.start;
    if (!next) return this.start >= prev.end;
    return this.start >= prev.end && this.end <= next.start;
  },

  // get the section of this range contained between two ranges
  // [0, 20] » [0, 8], [16, 20] » [8, 16]

  /** portion of a range between two ranges. */
  between: function between(prev, next) {
    if (!prev && !next) return this.copy();
    if (!prev) return this.start >= next.start ? null : new Range(this.start, Math.min(this.end, next.start));
    if (!next) return this.end <= prev.end ? null : new Range(Math.max(prev.end, this.start), this.end);

    return this.end > prev.end && this.start < next.start ? new Range(Math.max(prev.end, this.start), Math.min(next.start, this.end)) : null;
  },

  // [0, 8] » [0, 2], [4, 5] = [0, 2], [4, 5]
  // [3, 6] » [5, 7] = [5, 6]
  // [6, 9] » [5, 7] = [6, 7]

  /** intersection of a range with many ranges */
  intersection: function intersection(range) {
    var intersected = [];
    var ranges;
    if (range instanceof Range) ranges = arguments;else ranges = range;
    for (var k = 0; k < ranges.length; k++) {
      var r = ranges[k];
      if (this.below(r)) break;

      if (r.intersects(this)) intersected.push(new Range(Math.max(this.start, r.start), Math.min(this.end, r.end)));
    }
    return intersected;
  },

  // subtract ranges from this range
  // [0, 8] » [0, 2], [4, 5] = [2, 4], [5, 8]

  /** subtract many ranges from the range. */
  subtract: function subtract(range) {
    var subtracted = [];
    var ranges;
    if (range instanceof Range) ranges = arguments;else ranges = range;
    for (var k = -1; k < ranges.length; k++) {
      var prev = ranges[k];
      var next = ranges[k + 1];
      var between = this.between(prev, next);
      if (between) subtracted.push(between);
    }
    return subtracted;
  },

  // extract this range from ranges
  // [0, 8] » [0, 2], [5, 8] = []
  // [8, 20] » [0, 2], [5, 8] = [0, 2], [5, 8]
  // [0, 10] » [5, 10], [15, 20] = [5, 10]
  // [10, 20] » [5, 80], [90, 100] = [5, 70] [80, 90]
  // [10, 20] » [0, 10], [20, 30] = [0, 20]

  /** extract the range from many ranges. */
  extract: function extract(range) {
    var ranges = range instanceof Range ? slice_.call(arguments) : range.slice();

    for (var k = 0; k < ranges.length; k++) {
      var prev = ranges[k - 1];
      var next = ranges[k];

      var newRange = null;

      if (this.below(next)) {
        newRange = new Range(next.start - this.length, next.end - this.length);
      } else if (this.intersects(next)) {
        var subtracted = next.subtract(this);
        if (subtracted.length === 2) {
          // is contained
          newRange = new Range(subtracted[0].start, subtracted[1].end - this.length);
        } else if (subtracted.length === 1) {
          if (next.end > this.end) {
            // second segment kept
            newRange = new Range(subtracted[0].start - this.length, subtracted[0].end - this.length);
          } else if (this.start > next.start) {
            // first segment kept
            newRange = new Range(subtracted[0].start, subtracted[0].end);
          }
        } else {
          // gets eaten
          ranges.splice(k--, 1); // decrease k
        }
      } else {
          ranges.splice(k, 1, next.copy());
        }

      if (newRange) {
        if (prev && prev.end === newRange.start) {
          // touches previous
          ranges.splice(k-- - 1, 2, new Range(prev.start, newRange.end)); // decrease k due to splicing
        } else {
            ranges.splice(k, 1, newRange);
          }
      }
    }

    return ranges;
  },

  // [2,3] » [0,1], [2,3] = [0,1], [2,4]
  // [1,2] » [0,6] = [0,7]
  // [0,1] » [0,1], [5,6] = [0,2], [6,7]
  // [4,6] » [0,1], [5,6] = [0,1], [4,6], [7,8]

  // TODO: this can be slightly better. merging can be done in one loop.

  /** insert the range in many ranges. */
  insert: function insert(range) {
    var ranges = range instanceof Range ? slice_.call(arguments) : range.slice();

    for (var k = 0; k < ranges.length; k++) {
      var next = ranges[k];

      if (this.start >= next.end) {
        ranges.splice(k, 1, next.copy());
      } else if (this.start > next.start && this.start < next.end) {
        ranges.splice(k, 1, new Range(next.start, this.start), new Range(this.start, next.end));
      } else {
        ranges.splice(k, 1, new Range(next.start + this.length, next.end + this.length));
      }
    }

    return this.merge(ranges);
  },

  // merge this range in ranges
  // [0, 8] » [0, 2], [5, 8] = [0, 8]
  // [8, 20] » [0, 2], [5, 8] = [0, 2], [5, 20]
  // [0, 10] » [5, 10], [15, 20] = [0, 10], [15, 20]

  /** merge many ranges to the range. */
  merge: function merge(range) {
    var ranges;
    if (range instanceof Range) ranges = arguments;else ranges = range;

    ranges = map(ranges, function (r) {
      return r.copy();
    });

    if (!ranges.length) return [this.copy()];

    var k;
    var l;

    for (k = -1, l = ranges.length; k < l; k++) {
      var prev = ranges[k];
      var next = ranges[k + 1];
      var between = this.between(prev, next);

      if (between) {
        if (!prev && next) {
          if (between.end === next.start) {
            next.update(between.start, next.end);
          } else {
            k++; // increase k since we had a push
            ranges.unshift(between);
          }
        } else if (prev && next) {
          if (prev.end === between.start && between.end === next.start) {
            prev.update(prev.start, next.end);
            ranges.splice(k-- + 1, 1); // remove the next, decrease k since we had a splice
          } else if (prev.end === between.start) {
              prev.update(prev.start, between.end);
            } else if (between.end === next.start) {
              next.update(between.start, next.end);
            } else {
              ranges.splice(k + 1, 0, between);
            }
        } else if (prev && !next) {
          if (prev.end === between.start) {
            prev.update(prev.start, between.end);
          } else {
            k++; // increase k since we had a push
            ranges.push(between);
          }
        }
      }
    }

    return ranges;
  },

  /** Remove range from many ranges
      - The range(s) you pass is what you remove from */
  remove: function remove(range) {
    var ranges;
    if (range instanceof Range) ranges = arguments;else ranges = range;
    var result = [];
    for (var i = 0; i < ranges.length; i++) {
      var remaining = ranges[i].subtract(this);
      if (remaining.length) push_.apply(result, remaining);
    }
    return result;
  },

  /** Range to an array of indices */
  toIndices: function toIndices() {
    var indices = [];
    for (var i = this.start; i < this.end; i++) {
      indices.push(i);
    }return indices;
  },

  /** Range to a string */
  toString: function toString() {
    return [this.start, this.end] + '';
  }

});

/**
 * Range from a string
 * @memberof Range
 * @static
 * @param {String} string - The string.
 * @return {Range} The range.
 */
Range.fromString = function (string) {
  var parts = string.split(',');
  return new Range(+parts[0], +parts[1]);
};

/**
 * Ranges from an array of indices
 * @memberof Range
 * @static
 * @param {Array} indices - An array of indices.
 * @return {Array} An array of Ranges.
 */
Range.fromIndices = function (indices) {
  indices.sort(function (a, b) {
    return a > b ? 1 : -1;
  });

  var ranges = [];
  var rstart;
  var rend;

  for (var i = 0; i < indices.length; i++) {
    rstart = indices[i];
    rend = rstart;
    while (indices[i + 1] - indices[i] === 1) {
      rend = indices[i + 1]; // increment the index if the numbers sequential
      i++;
    }
    ranges.push(new Range(rstart, rend + 1));
  }

  return ranges;
};

/**
 * A function that returns a range.
 * @function
 * @see Range
 * @param {Number} start The start of the range.
 * @param {Number} end The end of the range.
 */
module.exports = Range;

},{"mout/array/map":635,"prime":678}],490:[function(require,module,exports){
'use strict';

/**
 * Creates a rate limiter where the permits are distributed at a fixed rate,
 * defined in terms of permits per second. Permits will be distributed
 * smoothly, with the delay between individual permits being adjusted to
 * ensure that the configured rate is maintained.
 *
 * @param {Number}
 */

function RateLimiter(permitsPerSecond) {
  this.setRate(permitsPerSecond);
  this._lastPermission = 0;
}

/**
 * Reconfigure the rate
 *
 * @param {Number}
 */
RateLimiter.prototype.setRate = function (permitsPerSecond) {
  if (isNaN(permitsPerSecond)) {
    throw Error('Invalid rate');
  }

  this._rate = permitsPerSecond;
  this._minWaitInMs = 1000 / permitsPerSecond;
};

/**
 * Return the rate (i.e. permits per second)
 *
 * @return {Number}
 */
RateLimiter.prototype.getRate = function () {
  return this._rate;
};

/**
 * Try to acquire a permit, it will return a boolean indicating
 * whether the permit is granted
 *
 * @return {boolean}
 */
RateLimiter.prototype.acquire = function () {
  var now = Date.now();
  var canAcquirePermit = now - this._lastPermission >= this._minWaitInMs;

  if (canAcquirePermit) {
    this._lastPermission = now;
  }

  return canAcquirePermit;
};

module.exports = RateLimiter;

},{}],491:[function(require,module,exports){
(function (global){
'use strict';

module.exports = {
  ENABLED: '1',
  DISABLED: '0',
  TEST_NAME: 'ab-desktop-shuffle',
  isEnabled: function isEnabled() {
    return global.__spotify && global.__spotify.product_state && global.__spotify.product_state[this.TEST_NAME] === this.ENABLED || false;
  }

};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],492:[function(require,module,exports){
'use strict';

function Translations() {
  this._data = {};

  // ensure that the context of the get method is always this object
  this.get = this.get.bind(this);
}

/**
 * Default implementation if the
 * locale is not loaded
 */
Translations.prototype.injectData = function (data) {
  this._data = data;
};

/**
 * Get a translation
 */
Translations.prototype.get = function (key, var_args) {
  var format = this._data.hasOwnProperty(key) ? this._data[key] : key;
  var args = arguments;

  return format.replace(/\{(\d+?)\}/g, function (str, num) {
    var value = args[+num + 1];

    // Do not change by a ||. A value of an empty string would make it fail.
    return typeof value !== 'undefined' ? value : str;
  });
};

/**
 * Gets the raw translations data
 * @return {Object} Locale object
 */
Translations.prototype.getData = function () {
  return this._data;
};

/**
 * Creates a translations instance with the specified data
 *
 * @param {Object} data Translations object
 * @return {Translations}
 */
Translations.createWithData = function (data) {
  var translations = new Translations();
  translations.injectData(data);
  return translations;
};

module.exports = Translations;

},{}],493:[function(require,module,exports){
'use strict';

module.exports = require('./src/SPVideoManager');

},{"./src/SPVideoManager":496}],494:[function(require,module,exports){
/**
 * Copyright 2014 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 *
 * @fileoverview Implements a manager for adaptive bitrate streaming.
 */
'use strict';

var shaka = require('./shaka');
/**
 * Creates a SPAbrManager, which selects video tracks using a basic set of
 * heuristics.
 *
 * @struct
 * @constructor
 * @implements {shaka.media.IAbrManager}
 * @export
 */
var SPAbrManager = function SPAbrManager(player) {
  /** @private {shaka.util.IBandwidthEstimator} */
  this.estimator_ = null;

  /** @private {shaka.player.IVideoSource} */
  this.videoSource_ = null;

  /** @private {!shaka.util.EventManager} */

  this.player_ = player;
  /**
   * The timestamp after which we are allowed to adapt, in milliseconds.
   * @private {number}
   */
  this.nextAdaptationTime_ = Number.POSITIVE_INFINITY;

  /** @private {boolean} */
  this.enabled_ = true;
};

/**
 * The minimum amount of time that must pass before the first switch, in
 * milliseconds.  This gives the bandwidth estimator time to get some real
 * data before changing anything.
 *
 * @private
 * @const {number}
 */
SPAbrManager.FIRST_SWITCH_INTERVAL_ = 4000;

/**
 * The minimum amount of time that must pass between switches, in milliseconds.
 * This keeps us from changing too often and annoying the user.
 *
 * @private
 * @const {number}
 */
SPAbrManager.MIN_SWITCH_INTERVAL_ = 30000;

/**
 * The minimum amount of time that must pass between bandwidth evaluations, in
 * milliseconds.  This keeps us from checking for adaptation opportunities too
 * often.
 *
 * @private
 * @const {number}
 */
SPAbrManager.MIN_EVAL_INTERVAL_ = 3000;

/**
 * The fraction of the estimated bandwidth which we should try to use when
 * upgrading.
 *
 * @private
 * @const {number}
 */
SPAbrManager.BANDWIDTH_UPGRADE_TARGET_ = 0.85;

/**
 * The fraction of the estimated bandwidth we should downgrade to avoid
 * exceeding.
 *
 * @private
 * @const {number}
 */
SPAbrManager.BANDWIDTH_DOWNGRADE_TARGET_ = 0.95;

/**
 * @override
 * @suppress {checkTypes} to set otherwise non-nullable types to null.
 */
SPAbrManager.prototype.destroy = function () {
  this.estimator_ = null;
  this.videoSource_ = null;
};

/** @override */
SPAbrManager.prototype.initialize = function (estimator, videoSource) {
  if (this.estimator_ || this.videoSource_) {
    return;
  }
  this.estimator_ = estimator;
  this.videoSource_ = videoSource;
};

/** @override */
SPAbrManager.prototype.start = function () {
  if (!this.estimator_ || !this.videoSource_ || this.started_) {
    return;
  }

  this.nextAdaptationTime_ = Date.now() + SPAbrManager.FIRST_SWITCH_INTERVAL_;
  this.player_.addEventListener('adaptation', this.onAdaptation_.bind(this));
  this.estimator_.addEventListener('bandwidth', this.onBandwidth_.bind(this));
  this.player_.addEventListener('trackschanged', this.chooseNewTrack_.bind(this));

  this.started_ = true;
};

/** @override */
SPAbrManager.prototype.enable = function (enabled) {
  this.enabled_ = enabled;
};

/** @override */
SPAbrManager.prototype.getInitialVideoTrackId = function () {
  if (!this.estimator_ || !this.videoSource_) {
    return null;
  }

  var chosen = this.chooseVideoTrack_();
  return chosen ? chosen.id : null;
};

/**
 * Select the specified video track.
 *
 * Does nothing if the AbrManager has not been started.
 *
 * @param {shaka.player.VideoTrack} track the track to the switch to
 * @param {boolean} clearBuffer If true, removes the previous stream's content
 *     before switching to the new stream.
 * @param {number=} opt_clearBufferOffset if |clearBuffer| and
 *     |opt_clearBufferOffset| are truthy, clear the stream buffer from the
 *     given offset (relative to the video's current time) to the end of the
 *     stream.
 *
 * @protected
 * @expose
 */
SPAbrManager.prototype.selectVideoTrack = function (track, clearBuffer, optClearBufferOffset) {
  if (!this.started_) {
    return;
  }
  this.videoSource_.selectVideoTrack(track.id, clearBuffer, optClearBufferOffset);
};

/**
 * Find the active track in the list.
 *
 * @param {!Array.<T>} trackList
 * @return {T}
 *
 * @template T
 * @private
 */
SPAbrManager.findActiveTrack_ = function (trackList) {
  for (var i = 0; i < trackList.length; ++i) {
    if (trackList[i].active) {
      return trackList[i];
    }
  }

  return null;
};

/**
 * Handles bandwidth update events.
 *
 * @param {!Event} event
 * @private
 */
SPAbrManager.prototype.onBandwidth_ = function (event) {
  if (Date.now() < this.nextAdaptationTime_) {
    return;
  }

  this.chooseNewTrack_(event);
};

/**
 * Makes adaptation decisions.
 *
 * @param {!Event} event
 * @private
 */
SPAbrManager.prototype.chooseNewTrack_ = function (event) {
  if (event.type !== 'bandwidth') {
    return;
  }
  if (!this.enabled_) {
    return;
  }

  // Alias.
  var SimpleAbrManager = SPAbrManager;

  var chosen = this.chooseVideoTrack_();

  if (chosen) {
    if (chosen.active) {
      // We are already using the correct video track.
      this.nextAdaptationTime_ = Date.now() + SimpleAbrManager.MIN_EVAL_INTERVAL_;
      return;
    }

    this.selectVideoTrack(chosen, true, 2.0);
  }

  // Can't adapt again until we get confirmation of this one.
  this.nextAdaptationTime_ = Number.POSITIVE_INFINITY;
};

/**
 * Handles adaptation events.
 *
 * @param {!Event} event
 * @private
 */
SPAbrManager.prototype.onAdaptation_ = function () {
  // This check allows us to ignore the initial adaptation events, which would
  // otherwise cause us not to honor FIRST_SWITCH_INTERVAL_.
  if (this.nextAdaptationTime_ === Number.POSITIVE_INFINITY) {
    // Adaptation is complete, so schedule the next adaptation.
    this.nextAdaptationTime_ = Date.now() + SPAbrManager.MIN_SWITCH_INTERVAL_;
  }
};

/**
 * Choose a video track based on current bandwidth conditions.
 *
 * @return {shaka.player.VideoTrack} The chosen video track or null if there
 *     are no video tracks to choose.
 * @private
 */
SPAbrManager.prototype.chooseVideoTrack_ = function () {
  // Alias.
  var SimpleAbrManager = SPAbrManager;

  var videoTracks = this.videoSource_.getVideoTracks();
  if (videoTracks.length === 0) {
    return null;
  }

  videoTracks.sort(shaka.player.VideoTrack.compare);

  var activeAudioTrack = SimpleAbrManager.findActiveTrack_(this.videoSource_.getAudioTracks());
  var audioBandwidth = activeAudioTrack ? activeAudioTrack.bandwidth : 0;

  var bandwidth = this.estimator_.getBandwidth();

  // Start by assuming that we will use the first track.
  var chosen = videoTracks[0];

  for (var i = 0; i < videoTracks.length; ++i) {
    var track = videoTracks[i];
    var nextTrack = i + 1 < videoTracks.length ? videoTracks[i + 1] : { bandwidth: Number.POSITIVE_INFINITY };

    // Ignore any track which is missing bandwidth info.
    if (!track.bandwidth) continue;

    var minBandwidth = (track.bandwidth + audioBandwidth) / SimpleAbrManager.BANDWIDTH_DOWNGRADE_TARGET_;
    var maxBandwidth = (nextTrack.bandwidth + audioBandwidth) / SimpleAbrManager.BANDWIDTH_UPGRADE_TARGET_;
    /*
     * console.log('Bandwidth ranges:',
     *             ((track.bandwidth + audioBandwidth) / 1e6).toFixed(3),
     *           (minBandwidth / 1e6).toFixed(3),
     *             (maxBandwidth / 1e6).toFixed(3));
     */

    if (bandwidth >= minBandwidth && bandwidth <= maxBandwidth) {
      chosen = track;
      if (chosen.active) break;
    }
  }

  return chosen;
};

module.exports = SPAbrManager;

},{"./shaka":500}],495:[function(require,module,exports){
/**
 * @license
 * Copyright 2015 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
'use strict';

var shaka = require('./shaka');
var EWMA = require('./ewma');
var util = require('util');

/**
 * Tracks bandwidth samples and estimates available bandwidth.
 * Based on the minimum of two exponentially-weighted moving averages with
 * different half-lives.
 *
 * @struct
 * @constructor
 * @extends {shaka.util.FakeEventTarget}
 * @implements {shaka.util.IBandwidthEstimator}
 * @export
 */
var SPBandwidthEstimator = function SPBandwidthEstimator() {
  shaka.util.FakeEventTarget.call(this, null);
  /**
   * A fast-moving average.
   * Half of the estimate is based on the last 3 seconds of sample history.
   * @private {!shaka.util.EWMA}
   */
  this.fast_ = new EWMA(3);

  /**
   * A slow-moving average.
   * Half of the estimate is based on the last 10 seconds of sample history.
   * @private {!shaka.util.EWMA}
   */
  this.slow_ = new EWMA(10);

  /**
   * Prevents ultra-fast internal connections from causing crazy results.
   * Modified by Betamax@Spotify Aparently this gets even crazier on Really
   * fast networks and the bandwidth calculation kicks in way to late
   * @private {number}
   * @const
   */
  this.minDelayMs_ = 80;

  /**
   * Initial estimate used when there is not enough data.
   * Modified by Betamax@Spotify to supply a start bitrate of 1Mbps
   * @private {number}
   * @const
   */
  this.defaultEstimate_ = 1e6; // 1Mbps

  /**
   * Minimum weight required to trust the estimate.
   * Modified by Betamax@Spotify let the calculation be used even earlier
   * @private {number}
   * @const
   */
  this.minWeight_ = 0.3;

  /**
   * Minimum number of bytes, under which samples are discarded.
   * Modified by Betamax@Spotify to let the minium packet size used
   * be less than our smallest
   * @private {number}
   * @const
   */

  this.minBytes_ = 50000;

  /**
   * The last time a sample was recorded, in milliseconds.
   * @private {number}
   */
  this.lastSampleTime_ = 0;
};

util.inherits(SPBandwidthEstimator, shaka.util.FakeEventTarget);

/** @override */
SPBandwidthEstimator.prototype.sample = function (delayMs, bytes) {
  if (bytes < this.minBytes_) {
    return;
  }

  delayMs = Math.max(delayMs, this.minDelayMs_);

  var bandwidth = 8000 * bytes / delayMs;
  var weight = delayMs / 1000;

  this.fast_.sample(weight, bandwidth);
  this.slow_.sample(weight, bandwidth);

  this.dispatchEvent(new Event('bandwidth'));

  this.lastSampleTime_ = Date.now();
};

/** @override */
SPBandwidthEstimator.prototype.getBandwidth = function () {
  if (this.fast_.getTotalWeight() < this.minWeight_) {
    return this.defaultEstimate_;
  }

  // Take the minimum of these two estimates.  This should have the effect of
  // adapting down quickly, but up more slowly.
  return Math.min(this.fast_.getEstimate(), this.slow_.getEstimate());
};

/** @override */
SPBandwidthEstimator.prototype.getDataAge = function () {
  return (Date.now() - this.lastSampleTime_) / 1000;
};

/** @override */
SPBandwidthEstimator.prototype.supportsCaching = function () {
  return false;
};

module.exports = SPBandwidthEstimator;

},{"./ewma":499,"./shaka":500,"util":736}],496:[function(require,module,exports){
'use strict';

var UUID = require('uuid-js');
var EventEmitter = require('events').EventEmitter;
var util = require('util');
var _ = require('./utils');
var SPVideoPlayer = require('./SPVideoPlayer');
var SPBandwidthEstimator = require('./SPBandwidthEstimator');
var SPVideoPlayerTracker = require('./SPVideoPlayerTracker');

var bandwidthEstimator;
var SPVideoManager, activeId;
var videos = {};

// CONSTANTS
var CHANGE_EVENT = 'change';

function getVideo(id) {
  var vid = null;
  if (typeof id === 'undefined') {
    vid = videos[activeId];
  } else {
    vid = videos[id];
  }

  console.assert(vid, 'Video unavailable ', vid);
  return vid;
}

function generateId() {
  var uuid = UUID.create();
  return uuid.toString();
}

var _state = {
  'isPlaying': false,
  'activeVideo': null,
  'activeVideoState': {},
  'volume': 1
};

var _onChange = function _onChange(err, p, c) {
  SPVideoManager.set({
    'activeVideoState': c
  });
};

/**
 * @module SPVideoManager
 */
SPVideoManager = {

  /**
   * @param {String} [key]
   * @return {*} - value at key or shallow clone of state
   */
  get: function get(key) {
    return arguments.length ? _state[key] : _.clone(_state);
  },

  /**
   * @param {String|Object} key - key or hash of key:value pairs to be updated
   * @param {*} [val]
   * @param {Boolean} [silent] - if true then no change event is fired
   * @return {SPVideoPlayer} this
   */
  set: function set(key, val, silent) {
    var oldState = this.get();

    if (arguments.length < 3 && util.isObject(key)) {
      silent = val;
      _.extend(_state, key);
    } else {
      _state[key] = val;
    }

    if (!silent) {
      this.emitter.emit(CHANGE_EVENT, null, oldState, this.get());
    }

    return this;
  },

  /**
   * @param {HTMLVideoElement} node
   * @param {Object} config
   * @return {String} videoId
   */
  createVideo: function createVideo(node, config) {
    var videoId = generateId();
    if (!bandwidthEstimator || bandwidthEstimator.getDataAge() >= 3600) {
      bandwidthEstimator = new SPBandwidthEstimator();
    }
    config.bandwidthEstimator = bandwidthEstimator;
    videos[videoId] = new SPVideoPlayer(node, config);
    return videoId;
  },

  getActiveVideo: function getActiveVideo() {
    return videos[activeId];
  },

  getVideo: function getVideo(videoId) {
    return videos[videoId];
  },

  /**
   * @param {Number} [videoId]
   * @return {SPVideoManager}
   */
  play: function play(videoId) {
    getVideo(videoId).play();
    return SPVideoManager;
  },

  /**
   * @param {Number} [videoId]
   * @return {SPVideoManager}
   */
  pause: function pause(videoId) {
    getVideo(videoId).pause();
    return SPVideoManager;
  },

  /**
   * @param {Number} [videoId]
   * @param {Number} [timeInSeconds]
   * @return {SPVideoManager}
   */
  seekTo: function seekTo(videoId, timeInSeconds) {
    getVideo(videoId).seekTo(timeInSeconds);
    return SPVideoManager;
  },

  /**
   * @param {Number} n
   * @return {SPVideoManager}
   */
  setPlayerVolume: function setPlayerVolume(videoId, volume) {
    if (videoId === activeId) {
      SPVideoManager.setVolume(volume);
    } else {
      getVideo(videoId).setVolume(volume);
    }
    return SPVideoManager;
  },

  /**
   * @param {Number} n
   * @return {SPVideoManager}
   */
  setVolume: function setVolume(n) {
    this.set('volume', n);

    // Apply to active video
    if (getVideo()) {
      getVideo().setVolume(n);
    }
    return SPVideoManager;
  },

  /**
   * @param {Number} [videoId]
   * @return {SPVideoManager}
   */
  destroy: function destroy(videoId, destroyNode, reason) {
    if (videoId) {
      var video = getVideo(videoId);
      if (video) {
        if (!!destroyNode) {
          video.getNode().remove();
        }
        video.unload(reason);
        delete videos[videoId];
      }
    }

    return SPVideoManager;
  },

  /**
   * @param {String} videoId
   * @return {SPVideoManager}
   */
  setActiveVideo: function setActiveVideo(videoId) {
    activeId = videoId;

    for (var v in videos) {
      if (!videos.hasOwnProperty(v)) continue;

      videos[v].set({
        'isActive': false,
        'endReason': getVideo(videoId).get('startReason')
      });
    }

    getVideo(videoId).setVolume(this.get('volume')).unmute().set({
      'isActive': true
    }).subscribe(_onChange);

    // Notify listeners that video is playing
    this.set({
      'isPlaying': true,
      'activeVideo': activeId,
      'activeVideoState': getVideo(videoId).get()
    });

    return SPVideoManager;
  },

  /**
   * @return {SPVideoManager}
   */
  clearActiveVideo: function clearActiveVideo() {
    getVideo().unsubscribe(_onChange).mute().set({
      'isActive': false
    });

    // Notify listeners that video is not playing
    this.set({
      'isPlaying': false,
      'activeVideo': null,
      'activeVideoState': {}
    });

    activeId = null;

    return SPVideoManager;
  },

  /**
   * @param {Number} [videoId]
   * @param {Function} cb
   * @return {SPVideoManager}
   */
  subscribe: function subscribe(videoId, cb) {
    if (videoId) {
      getVideo(videoId).addListener(CHANGE_EVENT, cb);
    } else {
      // Sub to the active video
      this.emitter.addListener('change', cb);
    }
    return SPVideoManager;
  },

  /**
   * @param {Number} [videoId]
   * @param {Function} [cb]
   * @return {SPVideoManager}
   */
  unsubscribe: function unsubscribe(videoId, cb) {
    if (videoId) {
      getVideo(videoId).removeListener(CHANGE_EVENT, cb);
    } else {
      // Unsub from active video
      this.emitter.removeListener('change', cb);
    }
    return SPVideoManager;
  },

  createEndVideoTracker: function createEndVideoTracker(player, options) {
    return new SPVideoPlayerTracker(player, options);
  },

  emitter: new EventEmitter()
};

module.exports = SPVideoManager;

},{"./SPBandwidthEstimator":495,"./SPVideoPlayer":497,"./SPVideoPlayerTracker":498,"./utils":501,"events":531,"util":736,"uuid-js":737}],497:[function(require,module,exports){
(function (global){
'use strict';
/**
 * @external EventEmitter
 * @see {@link https://nodejs.org/api/events.html|EventEmitter}
 */

var EventEmitter = require('events').EventEmitter;
var util = require('util');
var shaka = require('./shaka');
var _ = require('./utils');
var SPAbrManager = require('./SPAbrManager');

// CONSTANTS
var CHANGE_EVENT = 'change';
var BUFFERING_INTERVAL = 500;
var UPDATE_INTERVAL = 15000;
var PRODUCT_STATE_WIDEVINE_LICENSE_URL = 'widevine-license-url';

function isDashyURL(url) {
  return (/(\.mpd$)|(\/dash\/)/.test(url)
  );
}

function optionsFromConfig(config) {
  return !config ? {} : {
    'url': config.url || null,
    'type': config.type || null,
    'isDash': config.type === 'dash' || isDashyURL(config.url),
    'volume': config.volume || 1,
    'startPaused': config.startPaused || false,
    'isAd': config.isAd || false,
    'nativeControls': config.nativeControls || false,
    'preseekPosition': config.position || 0,
    'networkCallback': config.networkCallback,
    'bandwidthEstimator': config.bandwidthEstimator,
    'playbackID': config.playbackID,
    'fileId': config.fileId || 'unknown',
    'playOrigin': config.playOrigin || {},
    'track_uri': config.track_uri || '',
    'provider': config.provider || '',
    'startReason': config.startReason || 'unknown',
    'play_context': config.play_context || ''
  };
}

/**
 * @class SPVideoPlayer
 * @extends external:EventEmitter
 * @param {HTMLVideoElement} node
 * @param {Object} config
 */
var SPVideoPlayer = function SPVideoPlayer(node, config) {
  EventEmitter.call(this);
  this._options = optionsFromConfig(config);

  // set up video node
  _.bindAll(this);
  this._node = node;
  this._node.controls = this._options.nativeControls;
  this._node.setAttribute('preload', 'auto');
  this._player = new shaka.player.Player(node);

  // defaults
  this._firstTimeUpdate = false;
  this._playerBufferInterval = null;
  this._playerTimeUpdateInterval = null;
  this._state = this._getDefaultState();

  this._startListening();

  this.setVolume(this._options.volume);

  var playerSource = null;
  /* eslint-disable no-unused-vars */
  var protectionCallback = function protectionCallback(schemeUri, contentProtection) {
    return [{
      'keySystem': 'com.widevine.alpha',
      'licenseServerUrl': global.__spotify.product_state[PRODUCT_STATE_WIDEVINE_LICENSE_URL]
    }];
  };
  /* eslint-enable no-unused-vars */

  if (this._options.isDash) {
    // If config.estimator is null, the dash player will default to the
    // builtin estimator
    playerSource = new shaka.player.DashVideoSource(this._options.url, protectionCallback, this._options.bandwidthEstimator, new SPAbrManager(this._player));

    if (this._options.networkCallback) {
      playerSource.setNetworkCallback(this._options.networkCallback);
    }
  } else {
    playerSource = new shaka.player.HttpVideoSource(this._options.url);
  }

  this._playerLoadPromise = this._player.load(playerSource).then(function () {
    this.set({ 'isLoaded': true });
  }.bind(this));

  // add a tracker
  if (config.videoTrackerFactory) {
    config.videoTrackerFactory(this, this._options);
  }
  this.setPaused(this._options.startPaused);
};

util.inherits(SPVideoPlayer, EventEmitter);

SPVideoPlayer.prototype._getDefaultState = function () {
  return {
    'isAd': this._options.isAd,
    'isEnded': false,
    'isPlaying': false,
    'isPaused': this._options.startPaused,
    'isError': false,
    'isBuffering': false,
    'isLoaded': false,
    'canPlay': false,
    'isSeeking': false,
    'timeBuffering': 0,
    'readyTimeBuffering': 0,
    'isMuted': this._node.muted || this._node.volume === 0,
    'duration': this._node.duration || -1,
    'currentTime': this._node.currentTime || -1,
    'progress': this._node.currentTime / this._node.duration || 0,
    'volume': this._node.muted ? 0 : this._node.volume,
    'bitrate': 0,
    'stalls': 0,
    'stats': {},
    'endReason': 'unknown'
  };
};

SPVideoPlayer.prototype._handleEnded = function () {
  this._disablePlayTimers();

  this.set({
    isEnded: true,
    endReason: 'trackdone',
    stats: this._player.getStats()
  });
};

SPVideoPlayer.prototype._handleDurationchange = function (e) {
  this.set({
    duration: e.target.duration,
    progress: e.target.currentTime / e.target.duration,
    stats: this._player.getStats()
  });
};

SPVideoPlayer.prototype._handleTimeUpdate = function (e) {
  // if seeking, pretend we're at the last seek time
  var time = this._lastSeekTime || e.target.currentTime || 0;
  this.set({
    currentTime: time,
    progress: time / e.target.duration,
    stats: this._player.getStats()
  }, true);

  if (this._state.isSeeking) {
    this.set({ isSeeking: false });
    this._lastSeekTime = null;
  }
};

SPVideoPlayer.prototype._handlePlaying = function () {
  this.set({
    isPlaying: true,
    isEnded: false,
    stats: this._player.getStats()
  });
};

SPVideoPlayer.prototype._handlePause = function () {
  this.set({
    isPlaying: false,
    stats: this._player.getStats()
  });
};

SPVideoPlayer.prototype._handleVolumechange = function (e) {
  this.set({
    isMuted: e.target.muted || e.target.volume === 0,
    volume: e.target.muted ? 0 : e.target.volume
  });
};

SPVideoPlayer.prototype._handleLoadedmetadata = function () {
  if (this._options.preseekPosition > 0) {
    this.seekTo(this._options.preseekPosition);
    this._options.preseekPosition = 0;
  }
};

SPVideoPlayer.prototype._handleError = function (e) {
  var oldState = this.get();
  var stats = this._player.getStats();
  var errorData = {
    'type': '' + e.type,
    'detail_type': '' + e.detail.type,
    'detail_message': '' + e.detail.message,
    'play_time': '' + stats.playTime,
    'buffering_time': '' + stats.bufferingTime,
    'dropped_frames': '' + stats.droppedFrames,
    'playback_latency': '' + stats.playbackLatency
  };

  var xhr = e.detail.xhr;
  if (xhr) {
    errorData.httpStatus = xhr.status;
    errorData.responseText = xhr.responseText;
  }

  this.set({
    isEnded: true,
    isError: true,
    stats: stats,
    endReason: 'trackerror'
  }, true);

  this.emit(CHANGE_EVENT, errorData, oldState, this.get());
};

SPVideoPlayer.prototype._handleAdaptation = function (e) {
  if (e.contentType !== 'video') {
    return;
  }
  this.set({
    bitrate: e.bandwidth,
    currentTime: this._node.currentTime
  });
};

SPVideoPlayer.prototype._handleSeeked = function () {
  if (!this._state.isSeeking) {
    return;
  }
  this.set({
    isSeeking: false
  });
};

SPVideoPlayer.prototype._handleCanplay = function () {
  this.set({
    canPlay: true
  });
};

SPVideoPlayer.prototype._videoEvents = {
  'ended': '_handleEnded',
  'durationchange': '_handleDurationchange',
  'timeupdate': '_handleTimeUpdate',
  'volumechange': '_handleVolumechange',
  'playing': '_handlePlaying',
  'pause': '_handlePause',
  'seeked': '_handleSeeked',
  'canplay': '_handleCanplay',
  'loadedmetadata': '_handleLoadedmetadata'
};

SPVideoPlayer.prototype._startListening = function () {
  // video node events
  for (var x in this._videoEvents) {
    if (this._videoEvents.hasOwnProperty(x)) {
      this._node.addEventListener(x, this[this._videoEvents[x]]);
    }
  }

  // shaka player events
  this._player.addEventListener('error', this._handleError);
  this._player.addEventListener('adaptation', this._handleAdaptation);
};

SPVideoPlayer.prototype._stopListening = function () {
  // video node events
  for (var x in this._videoEvents) {
    if (this._videoEvents.hasOwnProperty(x)) {
      this._node.removeEventListener(x, this[this._videoEvents[x]]);
    }
  }

  // shaka player events
  this._player.removeEventListener('error', this._handleError);
  this._player.removeEventListener('adaptation', this._handleAdaptation);
};

SPVideoPlayer.prototype._enablePlayTimers = function () {
  if (this._playerBufferInterval) {
    return;
  }

  var lastProgress = 0;
  var lastCheckDate = new Date().getTime();
  var timerUpdate = function () {
    this.set({ timeUpdate: true });
    this.set({ timeUpdate: false }, true);
  }.bind(this);
  var bufferPoll = function () {
    var currentProgress = this.get('progress');
    var currentTime = new Date().getTime();
    var oldBuffering = this.get('isBuffering');

    if (this.get('isPlaying') === true) {
      if (!this._firstTimeUpdate) {
        timerUpdate();
        this._firstTimeUpdate = true;
      }
      if (currentProgress > lastProgress) {
        if (this.get('isBuffering') === true) {
          this.set({
            isBuffering: false,
            timeBuffering: 0
          });
        }
      } else {
        var stalls = this._state.stalls;
        if (!oldBuffering) {
          stalls++;
        }
        this.set({
          isBuffering: true,
          stalls: stalls,
          timeBuffering: this.get('timeBuffering') + currentTime - lastCheckDate
        }, oldBuffering); // only send update on first update
      }
    }

    lastProgress = currentProgress;
    lastCheckDate = currentTime;
  }.bind(this);
  this._playerTimeUpdateInterval = setInterval(timerUpdate, UPDATE_INTERVAL);
  this._playerBufferInterval = setInterval(bufferPoll, BUFFERING_INTERVAL);
};

SPVideoPlayer.prototype._disablePlayTimers = function () {
  clearInterval(this._playerBufferInterval);
  clearInterval(this._playerTimeUpdateInterval);
  this._playerBufferInterval = null;
  this._playerTimeUpdateInterval = null;
  this.set('isBuffering', false);
  this.set('timeBuffering', 0);
};

/**
 * @param {String} [key]
 * @return {*} - value at key or shallow clone of state
 */
SPVideoPlayer.prototype.get = function (key) {
  return arguments.length ? this._state[key] : _.clone(this._state);
};

/**
 * @param {String|Object} key - key or hash of key:value pairs to be updated
 * @param {*} [val]
 * @param {Boolean} [silent] - if true then no change event is fired
 * @return {SPVideoPlayer} this
 */
SPVideoPlayer.prototype.set = function (key, val, silent) {
  var oldState = this.get();

  if (arguments.length < 3 && util.isObject(key)) {
    silent = val;
    _.extend(this._state, key);
  } else {
    this._state[key] = val;
  }

  if (!silent) {
    this.emit(CHANGE_EVENT, undefined, oldState, this.get());
  }

  return this;
};

/**
 * @param {Number} n
 * @return {SPVideoPlayer} this
 */
SPVideoPlayer.prototype.setPaused = function (p) {
  p = !!p;
  if (p) {
    this._node.pause();
    this._node.playbackRate = 0;
    this._disablePlayTimers();
  } else {
    this._node.play();
    this._node.playbackRate = 1;
    this._enablePlayTimers();
  }
  this._node.autoplay = !p;
  this.set({ 'isPaused': p });
  return this;
};

/**
 * @return {SPVideoPlayer} this
 */
SPVideoPlayer.prototype.pause = function () {
  return this.setPaused(true);
};

/**
 * @return {SPVideoPlayer} this
 */
SPVideoPlayer.prototype.play = function () {
  return this.setPaused(false);
};

/**
 * @param {Number} n
 * @return {SPVideoPlayer} this
 */
SPVideoPlayer.prototype.setVolume = function (n) {
  this._node.volume = n;
  return this;
};

/**
 * @return {SPVideoPlayer} this
 */
SPVideoPlayer.prototype.seekTo = function (timeInSeconds) {
  if (timeInSeconds < 0) {
    timeInSeconds = 0;
  }
  var duration = this._node.duration || 0;
  if (timeInSeconds > duration) {
    timeInSeconds = duration;
  }
  // Some content doesn't actually start on 0, if we
  // seek to before the start time, shaka player just
  // freezes there.
  if (timeInSeconds < 0.1) {
    timeInSeconds = 0.1;
  }

  this._lastSeekTime = timeInSeconds;
  // Update the current time, and then emit the event, so the
  // states will hold the seek diff, and let the first update be silent
  this.set({ currentTime: this._node.currentTime }, true);
  this.set({ isSeeking: true, currentTime: timeInSeconds });
  this._node.currentTime = timeInSeconds;

  return this;
};

/**
 * @return {SPVideoPlayer} this
 */
SPVideoPlayer.prototype.mute = function () {
  this._node.muted = true;
  return this;
};

/**
 * @return {SPVideoPlayer} this
 */
SPVideoPlayer.prototype.unmute = function () {
  this._node.muted = false;
  return this;
};

/**
 * @return {SPVideoPlayer} this
 */
SPVideoPlayer.prototype.unload = function (reason) {
  this._disablePlayTimers();
  this.set({
    isEnded: true,
    endReason: reason,
    stats: this._player.getStats()
  });
  this._stopListening();
  this._playerLoadPromise.then(function () {
    this._player.unload();
  }.bind(this));
};

/**
 * @param {String} [prop]
 * @param {Function} fn
 * @return {SPVideoPlayer} this
 */
SPVideoPlayer.prototype.subscribe = function (prop, fn) {
  if (typeof prop === 'string') {
    this.addListener(CHANGE_EVENT + ':' + prop, fn);
  } else {
    this.addListener(CHANGE_EVENT, prop);
  }

  return this;
};

/**
 * @param {String} [prop]
 * @param {Function} fn
 * @return {SPVideoPlayer} this
 */
SPVideoPlayer.prototype.unsubscribe = function (prop, fn) {
  if (typeof prop === 'string') {
    this.removeListener(CHANGE_EVENT + ':' + prop, fn);
  } else {
    this.removeListener(CHANGE_EVENT, prop);
  }

  return this;
};

/**
 * @return {node} node
 */
SPVideoPlayer.prototype.getNode = function () {
  return this._node;
};

module.exports = SPVideoPlayer;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./SPAbrManager":494,"./shaka":500,"./utils":501,"events":531,"util":736}],498:[function(require,module,exports){
'use strict';

var _ = require('./utils');
var EndVideo7 = require('../../spotify-logger/pending-messages/EndVideo7');

var SPVideoPlayerTracker = function SPVideoPlayerTracker(player, options) {
  this._nSeekfwd = 0;
  this._msSeekfwd = 0;
  this._nSeekback = 0;
  this._msSeekback = 0;
  this._nStalls = 0;
  this._startBitrate = 0;
  this._oldBitrate = 0;
  this._initTime = new Date().getTime();
  this._latency = 0;
  this._bitrates = [];
  this._options = options;
  this._logged = false;
  this._endVideoSent = false;
  this._shouldSendEndVideo = false;
  this._endReason = 'unknown';
  this._duration = 0;
  _.bindAll(this);

  player.subscribe(this._onChange);
};

SPVideoPlayerTracker.prototype._onChange = function (errorData, oldState, newState) {

  if (this._latency === 0 && newState.currentTime >= 0) {
    this._latency = new Date().getTime() - this._initTime;
  }

  if (!oldState.isSeeking && newState.isSeeking) {
    this._seekTo(oldState, newState);
  }
  if (this._duration === 0 && newState.duration >= 0) {
    this._duration = newState.duration;
  }

  if (this._endReason !== newState.endReason) {
    this._endReason = newState.endReason;
  }
  if (newState.bitrate !== this._oldBitrate) {
    this._updatePlayedSegment(newState.currentTime, oldState.bitrate, newState.currentTime, false);
  }

  this._oldBitrate = newState.bitrate;
  if (this._startBitrate === 0) {
    this._startBitrate = newState.bitrate;
  }

  if (newState.timeUpdate) {
    this._updateEndVideo('unexpected-exit', newState.stats);
  }

  if (!oldState.isPaused && newState.isPaused) {
    this._updateEndVideo('unexpected-exit-while-paused', newState.stats);
  }

  if (newState.isEnded && !this._logged) {
    this._updatePlayedSegment(newState.currentTime, oldState.bitrate, newState.currentTime, true);
    this._logEndVideo(this._endReason, newState.stats);
    this._logged = true;
  }
};

SPVideoPlayerTracker.prototype._seekTo = function (oldState, newState) {
  this._updatePlayedSegment(oldState.currentTime, oldState.bitrate, newState.currentTime, true);

  var relativeSeek = newState.currentTime - oldState.currentTime;
  if (relativeSeek > 0) {
    this._nSeekfwd++;
    this._msSeekfwd += relativeSeek;
  } else {
    this._nSeekback++;
    this._msSeekback -= relativeSeek;
  }
};

SPVideoPlayerTracker.prototype._updatePlayedSegment = function (currentTime, bitrate, newTime, endSegment) {

  if (this._segmentStartTime !== undefined) {
    var diff = currentTime - this._segmentStartTime;
    if (diff > 0.01) {
      this._bitrates.push({
        timeDiff: diff,
        endSegment: endSegment,
        bitrate: bitrate
      });
    }
  }

  if (currentTime >= 0.0) {
    this._segmentStartTime = newTime;
  }
};

SPVideoPlayerTracker.prototype._calculatePlayTimesAndBitrates = function () {
  var played = 0;
  var maxContinuous = 0;
  var curContinuous = 0;
  var bitrateLength = {};
  var startContinous = true;
  for (var i in this._bitrates) {
    if (!this._bitrates.hasOwnProperty(i)) {
      continue;
    }
    var ent = this._bitrates[i];
    played += ent.timeDiff;
    if (startContinous) {
      curContinuous = ent.timeDiff;
    } else {
      curContinuous += ent.timeDiff;
    }
    maxContinuous = Math.max(maxContinuous, curContinuous);

    if (bitrateLength.hasOwnProperty(ent.bitrate)) {
      bitrateLength[ent.bitrate] += ent.timeDiff;
    } else {
      bitrateLength[ent.bitrate] = ent.timeDiff;
    }
    startContinous = ent.endSegment;
  }

  var timeWeightedBitrate = 0;
  for (var bitrate in bitrateLength) {
    if (bitrateLength.hasOwnProperty(bitrate)) {
      timeWeightedBitrate += bitrate * bitrateLength[bitrate] / played;
    }
  }
  return {
    msPlayed: Math.round(played * 1000),
    unionPlayed: -1,
    maxContinuous: Math.round(maxContinuous * 1000),
    timeWeightedBitrate: Math.round(timeWeightedBitrate)
  };
};

SPVideoPlayerTracker.prototype._createMessage = function (reason, stats) {

  var calc = this._calculatePlayTimesAndBitrates();

  return {
    'file_id': this._options.fileId,
    'playback_id': this._options.playbackID,
    'feature_identifier': this._options.playOrigin.feature_identifier,
    'feature_version': this._options.playOrigin.feature_version,
    'view_uri': this._options.playOrigin.view_uri,
    'reason_start': this._options.startReason,
    'reason_end': reason,
    'ms_played': calc.msPlayed,
    'ms_total_est': Math.round(this._duration * 1000),
    'live': false,
    'ms_manifest_latency': -1,
    'n_seekback': this._nSeekback,
    'ms_seekback': Math.round(this._msSeekback * 1000),
    'n_seekfwd': this._nSeekfwd,
    'ms_seekfwd': Math.round(this._msSeekfwd * 1000),
    'ms_latency': Math.round(this._latency),
    'ui_latency': -1,
    'start_offset_ms': Math.round(this._options.preseekPosition * 1000),
    'ms_initial_buffering': Math.round(stats.bufferingTime * 1000),
    'ms_seek_rebuffering': -1,
    'ms_stalled': -1,
    'max_ms_seek_rebuffering': -1,
    'max_ms_stalled': -1,
    'n_stalls': this._nStalls,
    'shuffle': false,
    'max_continous': calc.maxContinuous,
    'union_played': calc.unionPlayed,
    'play_context': this._options.play_context,
    'audiocodec': 'mp4a.40.5',
    'videocodec': 'vp9',
    'play_track': this._options.track_uri,
    'incognito_mode': false,
    'provider': this._options.provider,
    'referrer': this._options.playOrigin.external_referrer,
    'referrer_version': this._options.playOrigin.feature_version,
    'referrer_vendor': 'com.spotify',
    'streaming_rule': '',
    'gaia_dev_id': this._options.playOrigin.device_identifier,
    'start_bitrate': this._startBitrate,
    'full_screen': 0,
    'time_weighted_bitrate': calc.timeWeightedBitrate,
    'prefetched_bytes': 0,
    'prefetched_bytes_loaded': -1,
    'key_system': '',
    'ms_key_latency': -1,
    'total_bytes': Math.round(calc.timeWeightedBitrate * calc.msPlayed / 1000 / 8),
    'local_time_ms': Math.round(this._initTime * 1000),
    'connection_type_start': 'unknown',
    'connection_type_end': 'unknown'
  };
};

SPVideoPlayerTracker.prototype._updateEndVideo = function (reason, stats) {
  if (this._endVideoSent) {
    return;
  }

  var logMessage = this._createMessage(reason, stats);
  if (this._messageId === undefined) {
    this._messageId = -1;

    EndVideo7.add(logMessage, function (error, messageId) {
      if (error) {
        this._messageId = undefined;
        return;
      }
      this._messageId = messageId;
      if (this._shouldSendEndVideo) {
        EndVideo7.send(this._messageId);
      }
    }.bind(this));
    return;
  } else if (this._messageId === -1) {
    // if we are waiting for an 'add' just bail, this is a rare case
    // but just bail here since it's probably good enough
    return;
  }
  // Do a final update and sene the EndVideo
  EndVideo7.update(this._messageId, logMessage, function (error) {
    if (error) {
      console.error('logEndVideo, failed update:', error);
    }
    if (this._shouldSendEndVideo) {
      EndVideo7.send(this._messageId);
    }
  }.bind(this));
};

SPVideoPlayerTracker.prototype._logEndVideo = function (reason, stats) {
  if (this._endVideoSent) {
    return;
  }
  this._shouldSendEndVideo = true;
  this._updateEndVideo(reason, stats);
  this._endVideoSent = true;
};

module.exports = SPVideoPlayerTracker;

},{"../../spotify-logger/pending-messages/EndVideo7":455,"./utils":501}],499:[function(require,module,exports){
/**
 * @license
 * Copyright 2015 Google Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Computes an exponentionally-weighted moving average.
 *
 * @param {number} halfLife About half of the estimated value will be from the
 *     last |halfLife| samples by weight.
 * @struct
 * @constructor
 */
'use strict';

var EWMA = function EWMA(halfLife) {

  /**
   * Larger values of alpha expire historical data more slowly.
   * @private {number}
   */
  this.alpha_ = Math.exp(Math.log(0.5) / halfLife);

  /** @private {number} */
  this.estimate_ = 0;

  /** @private {number} */
  this.totalWeight_ = 0;
};

/**
 * Takes a sample.
 *
 * @param {number} weight
 * @param {number} value
 */
EWMA.prototype.sample = function (weight, value) {
  var adjAlpha = Math.pow(this.alpha_, weight);
  this.estimate_ = value * (1 - adjAlpha) + adjAlpha * this.estimate_;
  this.totalWeight_ += weight;
};

/**
 * @return {number}
 */
EWMA.prototype.getTotalWeight = function () {
  return this.totalWeight_;
};

/**
 * @return {number}
 */
EWMA.prototype.getEstimate = function () {
  var zeroFactor = 1 - Math.pow(this.alpha_, this.totalWeight_);
  return this.estimate_ / zeroFactor;
};

module.exports = EWMA;

},{}],500:[function(require,module,exports){
'use strict';

var shaka = require('shaka-player');

if (typeof document !== 'undefined' && typeof Document !== 'undefined') {
  shaka.polyfill.installAll();
}

module.exports = shaka;

},{"shaka-player":684}],501:[function(require,module,exports){
'use strict';

module.exports = {
  extend: function extend() {
    return Object.assign.apply(Object, arguments);
  },

  clone: function clone(obj) {
    return Object.assign({}, obj);
  },

  bindAll: function bindAll(obj, keys) {
    var key;

    if (arguments.length === 1) {
      for (key in obj) {
        if (typeof obj[key] === 'function') {
          obj[key] = obj[key].bind(obj);
        }
      }
    } else {
      for (key in keys) {
        if (typeof obj[keys[key]] === 'function') {
          obj[keys[key]] = obj[keys[key]].bind(obj);
        }
      }
    }

    return obj;
  }
};

},{}],502:[function(require,module,exports){
(function (process,global){
/*!
 * async
 * https://github.com/caolan/async
 *
 * Copyright 2010-2014 Caolan McMahon
 * Released under the MIT license
 */
(function () {

    var async = {};
    function noop() {}
    function identity(v) {
        return v;
    }
    function toBool(v) {
        return !!v;
    }
    function notId(v) {
        return !v;
    }

    // global on the server, window in the browser
    var previous_async;

    // Establish the root object, `window` (`self`) in the browser, `global`
    // on the server, or `this` in some virtual machines. We use `self`
    // instead of `window` for `WebWorker` support.
    var root = typeof self === 'object' && self.self === self && self ||
            typeof global === 'object' && global.global === global && global ||
            this;

    if (root != null) {
        previous_async = root.async;
    }

    async.noConflict = function () {
        root.async = previous_async;
        return async;
    };

    function only_once(fn) {
        return function() {
            if (fn === null) throw new Error("Callback was already called.");
            fn.apply(this, arguments);
            fn = null;
        };
    }

    function _once(fn) {
        return function() {
            if (fn === null) return;
            fn.apply(this, arguments);
            fn = null;
        };
    }

    //// cross-browser compatiblity functions ////

    var _toString = Object.prototype.toString;

    var _isArray = Array.isArray || function (obj) {
        return _toString.call(obj) === '[object Array]';
    };

    // Ported from underscore.js isObject
    var _isObject = function(obj) {
        var type = typeof obj;
        return type === 'function' || type === 'object' && !!obj;
    };

    function _isArrayLike(arr) {
        return _isArray(arr) || (
            // has a positive integer length property
            typeof arr.length === "number" &&
            arr.length >= 0 &&
            arr.length % 1 === 0
        );
    }

    function _arrayEach(arr, iterator) {
        var index = -1,
            length = arr.length;

        while (++index < length) {
            iterator(arr[index], index, arr);
        }
    }

    function _map(arr, iterator) {
        var index = -1,
            length = arr.length,
            result = Array(length);

        while (++index < length) {
            result[index] = iterator(arr[index], index, arr);
        }
        return result;
    }

    function _range(count) {
        return _map(Array(count), function (v, i) { return i; });
    }

    function _reduce(arr, iterator, memo) {
        _arrayEach(arr, function (x, i, a) {
            memo = iterator(memo, x, i, a);
        });
        return memo;
    }

    function _forEachOf(object, iterator) {
        _arrayEach(_keys(object), function (key) {
            iterator(object[key], key);
        });
    }

    function _indexOf(arr, item) {
        for (var i = 0; i < arr.length; i++) {
            if (arr[i] === item) return i;
        }
        return -1;
    }

    var _keys = Object.keys || function (obj) {
        var keys = [];
        for (var k in obj) {
            if (obj.hasOwnProperty(k)) {
                keys.push(k);
            }
        }
        return keys;
    };

    function _keyIterator(coll) {
        var i = -1;
        var len;
        var keys;
        if (_isArrayLike(coll)) {
            len = coll.length;
            return function next() {
                i++;
                return i < len ? i : null;
            };
        } else {
            keys = _keys(coll);
            len = keys.length;
            return function next() {
                i++;
                return i < len ? keys[i] : null;
            };
        }
    }

    // Similar to ES6's rest param (http://ariya.ofilabs.com/2013/03/es6-and-rest-parameter.html)
    // This accumulates the arguments passed into an array, after a given index.
    // From underscore.js (https://github.com/jashkenas/underscore/pull/2140).
    function _restParam(func, startIndex) {
        startIndex = startIndex == null ? func.length - 1 : +startIndex;
        return function() {
            var length = Math.max(arguments.length - startIndex, 0);
            var rest = Array(length);
            for (var index = 0; index < length; index++) {
                rest[index] = arguments[index + startIndex];
            }
            switch (startIndex) {
                case 0: return func.call(this, rest);
                case 1: return func.call(this, arguments[0], rest);
            }
            // Currently unused but handle cases outside of the switch statement:
            // var args = Array(startIndex + 1);
            // for (index = 0; index < startIndex; index++) {
            //     args[index] = arguments[index];
            // }
            // args[startIndex] = rest;
            // return func.apply(this, args);
        };
    }

    function _withoutIndex(iterator) {
        return function (value, index, callback) {
            return iterator(value, callback);
        };
    }

    //// exported async module functions ////

    //// nextTick implementation with browser-compatible fallback ////

    // capture the global reference to guard against fakeTimer mocks
    var _setImmediate = typeof setImmediate === 'function' && setImmediate;

    var _delay = _setImmediate ? function(fn) {
        // not a direct alias for IE10 compatibility
        _setImmediate(fn);
    } : function(fn) {
        setTimeout(fn, 0);
    };

    if (typeof process === 'object' && typeof process.nextTick === 'function') {
        async.nextTick = process.nextTick;
    } else {
        async.nextTick = _delay;
    }
    async.setImmediate = _setImmediate ? _delay : async.nextTick;


    async.forEach =
    async.each = function (arr, iterator, callback) {
        return async.eachOf(arr, _withoutIndex(iterator), callback);
    };

    async.forEachSeries =
    async.eachSeries = function (arr, iterator, callback) {
        return async.eachOfSeries(arr, _withoutIndex(iterator), callback);
    };


    async.forEachLimit =
    async.eachLimit = function (arr, limit, iterator, callback) {
        return _eachOfLimit(limit)(arr, _withoutIndex(iterator), callback);
    };

    async.forEachOf =
    async.eachOf = function (object, iterator, callback) {
        callback = _once(callback || noop);
        object = object || [];

        var iter = _keyIterator(object);
        var key, completed = 0;

        while ((key = iter()) != null) {
            completed += 1;
            iterator(object[key], key, only_once(done));
        }

        if (completed === 0) callback(null);

        function done(err) {
            completed--;
            if (err) {
                callback(err);
            }
            // Check key is null in case iterator isn't exhausted
            // and done resolved synchronously.
            else if (key === null && completed <= 0) {
                callback(null);
            }
        }
    };

    async.forEachOfSeries =
    async.eachOfSeries = function (obj, iterator, callback) {
        callback = _once(callback || noop);
        obj = obj || [];
        var nextKey = _keyIterator(obj);
        var key = nextKey();
        function iterate() {
            var sync = true;
            if (key === null) {
                return callback(null);
            }
            iterator(obj[key], key, only_once(function (err) {
                if (err) {
                    callback(err);
                }
                else {
                    key = nextKey();
                    if (key === null) {
                        return callback(null);
                    } else {
                        if (sync) {
                            async.setImmediate(iterate);
                        } else {
                            iterate();
                        }
                    }
                }
            }));
            sync = false;
        }
        iterate();
    };



    async.forEachOfLimit =
    async.eachOfLimit = function (obj, limit, iterator, callback) {
        _eachOfLimit(limit)(obj, iterator, callback);
    };

    function _eachOfLimit(limit) {

        return function (obj, iterator, callback) {
            callback = _once(callback || noop);
            obj = obj || [];
            var nextKey = _keyIterator(obj);
            if (limit <= 0) {
                return callback(null);
            }
            var done = false;
            var running = 0;
            var errored = false;

            (function replenish () {
                if (done && running <= 0) {
                    return callback(null);
                }

                while (running < limit && !errored) {
                    var key = nextKey();
                    if (key === null) {
                        done = true;
                        if (running <= 0) {
                            callback(null);
                        }
                        return;
                    }
                    running += 1;
                    iterator(obj[key], key, only_once(function (err) {
                        running -= 1;
                        if (err) {
                            callback(err);
                            errored = true;
                        }
                        else {
                            replenish();
                        }
                    }));
                }
            })();
        };
    }


    function doParallel(fn) {
        return function (obj, iterator, callback) {
            return fn(async.eachOf, obj, iterator, callback);
        };
    }
    function doParallelLimit(fn) {
        return function (obj, limit, iterator, callback) {
            return fn(_eachOfLimit(limit), obj, iterator, callback);
        };
    }
    function doSeries(fn) {
        return function (obj, iterator, callback) {
            return fn(async.eachOfSeries, obj, iterator, callback);
        };
    }

    function _asyncMap(eachfn, arr, iterator, callback) {
        callback = _once(callback || noop);
        arr = arr || [];
        var results = _isArrayLike(arr) ? [] : {};
        eachfn(arr, function (value, index, callback) {
            iterator(value, function (err, v) {
                results[index] = v;
                callback(err);
            });
        }, function (err) {
            callback(err, results);
        });
    }

    async.map = doParallel(_asyncMap);
    async.mapSeries = doSeries(_asyncMap);
    async.mapLimit = doParallelLimit(_asyncMap);

    // reduce only has a series version, as doing reduce in parallel won't
    // work in many situations.
    async.inject =
    async.foldl =
    async.reduce = function (arr, memo, iterator, callback) {
        async.eachOfSeries(arr, function (x, i, callback) {
            iterator(memo, x, function (err, v) {
                memo = v;
                callback(err);
            });
        }, function (err) {
            callback(err, memo);
        });
    };

    async.foldr =
    async.reduceRight = function (arr, memo, iterator, callback) {
        var reversed = _map(arr, identity).reverse();
        async.reduce(reversed, memo, iterator, callback);
    };

    async.transform = function (arr, memo, iterator, callback) {
        if (arguments.length === 3) {
            callback = iterator;
            iterator = memo;
            memo = _isArray(arr) ? [] : {};
        }

        async.eachOf(arr, function(v, k, cb) {
            iterator(memo, v, k, cb);
        }, function(err) {
            callback(err, memo);
        });
    };

    function _filter(eachfn, arr, iterator, callback) {
        var results = [];
        eachfn(arr, function (x, index, callback) {
            iterator(x, function (v) {
                if (v) {
                    results.push({index: index, value: x});
                }
                callback();
            });
        }, function () {
            callback(_map(results.sort(function (a, b) {
                return a.index - b.index;
            }), function (x) {
                return x.value;
            }));
        });
    }

    async.select =
    async.filter = doParallel(_filter);

    async.selectLimit =
    async.filterLimit = doParallelLimit(_filter);

    async.selectSeries =
    async.filterSeries = doSeries(_filter);

    function _reject(eachfn, arr, iterator, callback) {
        _filter(eachfn, arr, function(value, cb) {
            iterator(value, function(v) {
                cb(!v);
            });
        }, callback);
    }
    async.reject = doParallel(_reject);
    async.rejectLimit = doParallelLimit(_reject);
    async.rejectSeries = doSeries(_reject);

    function _createTester(eachfn, check, getResult) {
        return function(arr, limit, iterator, cb) {
            function done() {
                if (cb) cb(getResult(false, void 0));
            }
            function iteratee(x, _, callback) {
                if (!cb) return callback();
                iterator(x, function (v) {
                    if (cb && check(v)) {
                        cb(getResult(true, x));
                        cb = iterator = false;
                    }
                    callback();
                });
            }
            if (arguments.length > 3) {
                eachfn(arr, limit, iteratee, done);
            } else {
                cb = iterator;
                iterator = limit;
                eachfn(arr, iteratee, done);
            }
        };
    }

    async.any =
    async.some = _createTester(async.eachOf, toBool, identity);

    async.someLimit = _createTester(async.eachOfLimit, toBool, identity);

    async.all =
    async.every = _createTester(async.eachOf, notId, notId);

    async.everyLimit = _createTester(async.eachOfLimit, notId, notId);

    function _findGetResult(v, x) {
        return x;
    }
    async.detect = _createTester(async.eachOf, identity, _findGetResult);
    async.detectSeries = _createTester(async.eachOfSeries, identity, _findGetResult);
    async.detectLimit = _createTester(async.eachOfLimit, identity, _findGetResult);

    async.sortBy = function (arr, iterator, callback) {
        async.map(arr, function (x, callback) {
            iterator(x, function (err, criteria) {
                if (err) {
                    callback(err);
                }
                else {
                    callback(null, {value: x, criteria: criteria});
                }
            });
        }, function (err, results) {
            if (err) {
                return callback(err);
            }
            else {
                callback(null, _map(results.sort(comparator), function (x) {
                    return x.value;
                }));
            }

        });

        function comparator(left, right) {
            var a = left.criteria, b = right.criteria;
            return a < b ? -1 : a > b ? 1 : 0;
        }
    };

    async.auto = function (tasks, concurrency, callback) {
        if (typeof arguments[1] === 'function') {
            // concurrency is optional, shift the args.
            callback = concurrency;
            concurrency = null;
        }
        callback = _once(callback || noop);
        var keys = _keys(tasks);
        var remainingTasks = keys.length;
        if (!remainingTasks) {
            return callback(null);
        }
        if (!concurrency) {
            concurrency = remainingTasks;
        }

        var results = {};
        var runningTasks = 0;

        var hasError = false;

        var listeners = [];
        function addListener(fn) {
            listeners.unshift(fn);
        }
        function removeListener(fn) {
            var idx = _indexOf(listeners, fn);
            if (idx >= 0) listeners.splice(idx, 1);
        }
        function taskComplete() {
            remainingTasks--;
            _arrayEach(listeners.slice(0), function (fn) {
                fn();
            });
        }

        addListener(function () {
            if (!remainingTasks) {
                callback(null, results);
            }
        });

        _arrayEach(keys, function (k) {
            if (hasError) return;
            var task = _isArray(tasks[k]) ? tasks[k]: [tasks[k]];
            var taskCallback = _restParam(function(err, args) {
                runningTasks--;
                if (args.length <= 1) {
                    args = args[0];
                }
                if (err) {
                    var safeResults = {};
                    _forEachOf(results, function(val, rkey) {
                        safeResults[rkey] = val;
                    });
                    safeResults[k] = args;
                    hasError = true;

                    callback(err, safeResults);
                }
                else {
                    results[k] = args;
                    async.setImmediate(taskComplete);
                }
            });
            var requires = task.slice(0, task.length - 1);
            // prevent dead-locks
            var len = requires.length;
            var dep;
            while (len--) {
                if (!(dep = tasks[requires[len]])) {
                    throw new Error('Has nonexistent dependency in ' + requires.join(', '));
                }
                if (_isArray(dep) && _indexOf(dep, k) >= 0) {
                    throw new Error('Has cyclic dependencies');
                }
            }
            function ready() {
                return runningTasks < concurrency && _reduce(requires, function (a, x) {
                    return (a && results.hasOwnProperty(x));
                }, true) && !results.hasOwnProperty(k);
            }
            if (ready()) {
                runningTasks++;
                task[task.length - 1](taskCallback, results);
            }
            else {
                addListener(listener);
            }
            function listener() {
                if (ready()) {
                    runningTasks++;
                    removeListener(listener);
                    task[task.length - 1](taskCallback, results);
                }
            }
        });
    };



    async.retry = function(times, task, callback) {
        var DEFAULT_TIMES = 5;
        var DEFAULT_INTERVAL = 0;

        var attempts = [];

        var opts = {
            times: DEFAULT_TIMES,
            interval: DEFAULT_INTERVAL
        };

        function parseTimes(acc, t){
            if(typeof t === 'number'){
                acc.times = parseInt(t, 10) || DEFAULT_TIMES;
            } else if(typeof t === 'object'){
                acc.times = parseInt(t.times, 10) || DEFAULT_TIMES;
                acc.interval = parseInt(t.interval, 10) || DEFAULT_INTERVAL;
            } else {
                throw new Error('Unsupported argument type for \'times\': ' + typeof t);
            }
        }

        var length = arguments.length;
        if (length < 1 || length > 3) {
            throw new Error('Invalid arguments - must be either (task), (task, callback), (times, task) or (times, task, callback)');
        } else if (length <= 2 && typeof times === 'function') {
            callback = task;
            task = times;
        }
        if (typeof times !== 'function') {
            parseTimes(opts, times);
        }
        opts.callback = callback;
        opts.task = task;

        function wrappedTask(wrappedCallback, wrappedResults) {
            function retryAttempt(task, finalAttempt) {
                return function(seriesCallback) {
                    task(function(err, result){
                        seriesCallback(!err || finalAttempt, {err: err, result: result});
                    }, wrappedResults);
                };
            }

            function retryInterval(interval){
                return function(seriesCallback){
                    setTimeout(function(){
                        seriesCallback(null);
                    }, interval);
                };
            }

            while (opts.times) {

                var finalAttempt = !(opts.times-=1);
                attempts.push(retryAttempt(opts.task, finalAttempt));
                if(!finalAttempt && opts.interval > 0){
                    attempts.push(retryInterval(opts.interval));
                }
            }

            async.series(attempts, function(done, data){
                data = data[data.length - 1];
                (wrappedCallback || opts.callback)(data.err, data.result);
            });
        }

        // If a callback is passed, run this as a controll flow
        return opts.callback ? wrappedTask() : wrappedTask;
    };

    async.waterfall = function (tasks, callback) {
        callback = _once(callback || noop);
        if (!_isArray(tasks)) {
            var err = new Error('First argument to waterfall must be an array of functions');
            return callback(err);
        }
        if (!tasks.length) {
            return callback();
        }
        function wrapIterator(iterator) {
            return _restParam(function (err, args) {
                if (err) {
                    callback.apply(null, [err].concat(args));
                }
                else {
                    var next = iterator.next();
                    if (next) {
                        args.push(wrapIterator(next));
                    }
                    else {
                        args.push(callback);
                    }
                    ensureAsync(iterator).apply(null, args);
                }
            });
        }
        wrapIterator(async.iterator(tasks))();
    };

    function _parallel(eachfn, tasks, callback) {
        callback = callback || noop;
        var results = _isArrayLike(tasks) ? [] : {};

        eachfn(tasks, function (task, key, callback) {
            task(_restParam(function (err, args) {
                if (args.length <= 1) {
                    args = args[0];
                }
                results[key] = args;
                callback(err);
            }));
        }, function (err) {
            callback(err, results);
        });
    }

    async.parallel = function (tasks, callback) {
        _parallel(async.eachOf, tasks, callback);
    };

    async.parallelLimit = function(tasks, limit, callback) {
        _parallel(_eachOfLimit(limit), tasks, callback);
    };

    async.series = function(tasks, callback) {
        _parallel(async.eachOfSeries, tasks, callback);
    };

    async.iterator = function (tasks) {
        function makeCallback(index) {
            function fn() {
                if (tasks.length) {
                    tasks[index].apply(null, arguments);
                }
                return fn.next();
            }
            fn.next = function () {
                return (index < tasks.length - 1) ? makeCallback(index + 1): null;
            };
            return fn;
        }
        return makeCallback(0);
    };

    async.apply = _restParam(function (fn, args) {
        return _restParam(function (callArgs) {
            return fn.apply(
                null, args.concat(callArgs)
            );
        });
    });

    function _concat(eachfn, arr, fn, callback) {
        var result = [];
        eachfn(arr, function (x, index, cb) {
            fn(x, function (err, y) {
                result = result.concat(y || []);
                cb(err);
            });
        }, function (err) {
            callback(err, result);
        });
    }
    async.concat = doParallel(_concat);
    async.concatSeries = doSeries(_concat);

    async.whilst = function (test, iterator, callback) {
        callback = callback || noop;
        if (test()) {
            var next = _restParam(function(err, args) {
                if (err) {
                    callback(err);
                } else if (test.apply(this, args)) {
                    iterator(next);
                } else {
                    callback.apply(null, [null].concat(args));
                }
            });
            iterator(next);
        } else {
            callback(null);
        }
    };

    async.doWhilst = function (iterator, test, callback) {
        var calls = 0;
        return async.whilst(function() {
            return ++calls <= 1 || test.apply(this, arguments);
        }, iterator, callback);
    };

    async.until = function (test, iterator, callback) {
        return async.whilst(function() {
            return !test.apply(this, arguments);
        }, iterator, callback);
    };

    async.doUntil = function (iterator, test, callback) {
        return async.doWhilst(iterator, function() {
            return !test.apply(this, arguments);
        }, callback);
    };

    async.during = function (test, iterator, callback) {
        callback = callback || noop;

        var next = _restParam(function(err, args) {
            if (err) {
                callback(err);
            } else {
                args.push(check);
                test.apply(this, args);
            }
        });

        var check = function(err, truth) {
            if (err) {
                callback(err);
            } else if (truth) {
                iterator(next);
            } else {
                callback(null);
            }
        };

        test(check);
    };

    async.doDuring = function (iterator, test, callback) {
        var calls = 0;
        async.during(function(next) {
            if (calls++ < 1) {
                next(null, true);
            } else {
                test.apply(this, arguments);
            }
        }, iterator, callback);
    };

    function _queue(worker, concurrency, payload) {
        if (concurrency == null) {
            concurrency = 1;
        }
        else if(concurrency === 0) {
            throw new Error('Concurrency must not be zero');
        }
        function _insert(q, data, pos, callback) {
            if (callback != null && typeof callback !== "function") {
                throw new Error("task callback must be a function");
            }
            q.started = true;
            if (!_isArray(data)) {
                data = [data];
            }
            if(data.length === 0 && q.idle()) {
                // call drain immediately if there are no tasks
                return async.setImmediate(function() {
                    q.drain();
                });
            }
            _arrayEach(data, function(task) {
                var item = {
                    data: task,
                    callback: callback || noop
                };

                if (pos) {
                    q.tasks.unshift(item);
                } else {
                    q.tasks.push(item);
                }

                if (q.tasks.length === q.concurrency) {
                    q.saturated();
                }
            });
            async.setImmediate(q.process);
        }
        function _next(q, tasks) {
            return function(){
                workers -= 1;

                var removed = false;
                var args = arguments;
                _arrayEach(tasks, function (task) {
                    _arrayEach(workersList, function (worker, index) {
                        if (worker === task && !removed) {
                            workersList.splice(index, 1);
                            removed = true;
                        }
                    });

                    task.callback.apply(task, args);
                });
                if (q.tasks.length + workers === 0) {
                    q.drain();
                }
                q.process();
            };
        }

        var workers = 0;
        var workersList = [];
        var q = {
            tasks: [],
            concurrency: concurrency,
            payload: payload,
            saturated: noop,
            empty: noop,
            drain: noop,
            started: false,
            paused: false,
            push: function (data, callback) {
                _insert(q, data, false, callback);
            },
            kill: function () {
                q.drain = noop;
                q.tasks = [];
            },
            unshift: function (data, callback) {
                _insert(q, data, true, callback);
            },
            process: function () {
                while(!q.paused && workers < q.concurrency && q.tasks.length){

                    var tasks = q.payload ?
                        q.tasks.splice(0, q.payload) :
                        q.tasks.splice(0, q.tasks.length);

                    var data = _map(tasks, function (task) {
                        return task.data;
                    });

                    if (q.tasks.length === 0) {
                        q.empty();
                    }
                    workers += 1;
                    workersList.push(tasks[0]);
                    var cb = only_once(_next(q, tasks));
                    worker(data, cb);
                }
            },
            length: function () {
                return q.tasks.length;
            },
            running: function () {
                return workers;
            },
            workersList: function () {
                return workersList;
            },
            idle: function() {
                return q.tasks.length + workers === 0;
            },
            pause: function () {
                q.paused = true;
            },
            resume: function () {
                if (q.paused === false) { return; }
                q.paused = false;
                var resumeCount = Math.min(q.concurrency, q.tasks.length);
                // Need to call q.process once per concurrent
                // worker to preserve full concurrency after pause
                for (var w = 1; w <= resumeCount; w++) {
                    async.setImmediate(q.process);
                }
            }
        };
        return q;
    }

    async.queue = function (worker, concurrency) {
        var q = _queue(function (items, cb) {
            worker(items[0], cb);
        }, concurrency, 1);

        return q;
    };

    async.priorityQueue = function (worker, concurrency) {

        function _compareTasks(a, b){
            return a.priority - b.priority;
        }

        function _binarySearch(sequence, item, compare) {
            var beg = -1,
                end = sequence.length - 1;
            while (beg < end) {
                var mid = beg + ((end - beg + 1) >>> 1);
                if (compare(item, sequence[mid]) >= 0) {
                    beg = mid;
                } else {
                    end = mid - 1;
                }
            }
            return beg;
        }

        function _insert(q, data, priority, callback) {
            if (callback != null && typeof callback !== "function") {
                throw new Error("task callback must be a function");
            }
            q.started = true;
            if (!_isArray(data)) {
                data = [data];
            }
            if(data.length === 0) {
                // call drain immediately if there are no tasks
                return async.setImmediate(function() {
                    q.drain();
                });
            }
            _arrayEach(data, function(task) {
                var item = {
                    data: task,
                    priority: priority,
                    callback: typeof callback === 'function' ? callback : noop
                };

                q.tasks.splice(_binarySearch(q.tasks, item, _compareTasks) + 1, 0, item);

                if (q.tasks.length === q.concurrency) {
                    q.saturated();
                }
                async.setImmediate(q.process);
            });
        }

        // Start with a normal queue
        var q = async.queue(worker, concurrency);

        // Override push to accept second parameter representing priority
        q.push = function (data, priority, callback) {
            _insert(q, data, priority, callback);
        };

        // Remove unshift function
        delete q.unshift;

        return q;
    };

    async.cargo = function (worker, payload) {
        return _queue(worker, 1, payload);
    };

    function _console_fn(name) {
        return _restParam(function (fn, args) {
            fn.apply(null, args.concat([_restParam(function (err, args) {
                if (typeof console === 'object') {
                    if (err) {
                        if (console.error) {
                            console.error(err);
                        }
                    }
                    else if (console[name]) {
                        _arrayEach(args, function (x) {
                            console[name](x);
                        });
                    }
                }
            })]));
        });
    }
    async.log = _console_fn('log');
    async.dir = _console_fn('dir');
    /*async.info = _console_fn('info');
    async.warn = _console_fn('warn');
    async.error = _console_fn('error');*/

    async.memoize = function (fn, hasher) {
        var memo = {};
        var queues = {};
        var has = Object.prototype.hasOwnProperty;
        hasher = hasher || identity;
        var memoized = _restParam(function memoized(args) {
            var callback = args.pop();
            var key = hasher.apply(null, args);
            if (has.call(memo, key)) {
                async.setImmediate(function () {
                    callback.apply(null, memo[key]);
                });
            }
            else if (has.call(queues, key)) {
                queues[key].push(callback);
            }
            else {
                queues[key] = [callback];
                fn.apply(null, args.concat([_restParam(function (args) {
                    memo[key] = args;
                    var q = queues[key];
                    delete queues[key];
                    for (var i = 0, l = q.length; i < l; i++) {
                        q[i].apply(null, args);
                    }
                })]));
            }
        });
        memoized.memo = memo;
        memoized.unmemoized = fn;
        return memoized;
    };

    async.unmemoize = function (fn) {
        return function () {
            return (fn.unmemoized || fn).apply(null, arguments);
        };
    };

    function _times(mapper) {
        return function (count, iterator, callback) {
            mapper(_range(count), iterator, callback);
        };
    }

    async.times = _times(async.map);
    async.timesSeries = _times(async.mapSeries);
    async.timesLimit = function (count, limit, iterator, callback) {
        return async.mapLimit(_range(count), limit, iterator, callback);
    };

    async.seq = function (/* functions... */) {
        var fns = arguments;
        return _restParam(function (args) {
            var that = this;

            var callback = args[args.length - 1];
            if (typeof callback == 'function') {
                args.pop();
            } else {
                callback = noop;
            }

            async.reduce(fns, args, function (newargs, fn, cb) {
                fn.apply(that, newargs.concat([_restParam(function (err, nextargs) {
                    cb(err, nextargs);
                })]));
            },
            function (err, results) {
                callback.apply(that, [err].concat(results));
            });
        });
    };

    async.compose = function (/* functions... */) {
        return async.seq.apply(null, Array.prototype.reverse.call(arguments));
    };


    function _applyEach(eachfn) {
        return _restParam(function(fns, args) {
            var go = _restParam(function(args) {
                var that = this;
                var callback = args.pop();
                return eachfn(fns, function (fn, _, cb) {
                    fn.apply(that, args.concat([cb]));
                },
                callback);
            });
            if (args.length) {
                return go.apply(this, args);
            }
            else {
                return go;
            }
        });
    }

    async.applyEach = _applyEach(async.eachOf);
    async.applyEachSeries = _applyEach(async.eachOfSeries);


    async.forever = function (fn, callback) {
        var done = only_once(callback || noop);
        var task = ensureAsync(fn);
        function next(err) {
            if (err) {
                return done(err);
            }
            task(next);
        }
        next();
    };

    function ensureAsync(fn) {
        return _restParam(function (args) {
            var callback = args.pop();
            args.push(function () {
                var innerArgs = arguments;
                if (sync) {
                    async.setImmediate(function () {
                        callback.apply(null, innerArgs);
                    });
                } else {
                    callback.apply(null, innerArgs);
                }
            });
            var sync = true;
            fn.apply(this, args);
            sync = false;
        });
    }

    async.ensureAsync = ensureAsync;

    async.constant = _restParam(function(values) {
        var args = [null].concat(values);
        return function (callback) {
            return callback.apply(this, args);
        };
    });

    async.wrapSync =
    async.asyncify = function asyncify(func) {
        return _restParam(function (args) {
            var callback = args.pop();
            var result;
            try {
                result = func.apply(this, args);
            } catch (e) {
                return callback(e);
            }
            // if result is Promise object
            if (_isObject(result) && typeof result.then === "function") {
                result.then(function(value) {
                    callback(null, value);
                })["catch"](function(err) {
                    callback(err.message ? err : new Error(err));
                });
            } else {
                callback(null, result);
            }
        });
    };

    // Node.js
    if (typeof module === 'object' && module.exports) {
        module.exports = async;
    }
    // AMD / RequireJS
    else if (typeof define === 'function' && define.amd) {
        define([], function () {
            return async;
        });
    }
    // included directly via <script> tag
    else {
        root.async = async;
    }

}());

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"_process":680}],503:[function(require,module,exports){
/**
 * BezierEasing - use bezier curve for transition easing function
 * by Gaëtan Renaudeau 2014 - 2015 – MIT License
 *
 * Credits: is based on Firefox's nsSMILKeySpline.cpp
 * Usage:
 * var spline = BezierEasing([ 0.25, 0.1, 0.25, 1.0 ])
 * spline.get(x) => returns the easing value | x must be in [0, 1] range
 *
 */

// These values are established by empiricism with tests (tradeoff: performance VS precision)
var NEWTON_ITERATIONS = 4;
var NEWTON_MIN_SLOPE = 0.001;
var SUBDIVISION_PRECISION = 0.0000001;
var SUBDIVISION_MAX_ITERATIONS = 10;

var kSplineTableSize = 11;
var kSampleStepSize = 1.0 / (kSplineTableSize - 1.0);

var float32ArraySupported = typeof Float32Array === "function";

function A (aA1, aA2) { return 1.0 - 3.0 * aA2 + 3.0 * aA1; }
function B (aA1, aA2) { return 3.0 * aA2 - 6.0 * aA1; }
function C (aA1)      { return 3.0 * aA1; }

// Returns x(t) given t, x1, and x2, or y(t) given t, y1, and y2.
function calcBezier (aT, aA1, aA2) {
  return ((A(aA1, aA2)*aT + B(aA1, aA2))*aT + C(aA1))*aT;
}

// Returns dx/dt given t, x1, and x2, or dy/dt given t, y1, and y2.
function getSlope (aT, aA1, aA2) {
  return 3.0 * A(aA1, aA2)*aT*aT + 2.0 * B(aA1, aA2) * aT + C(aA1);
}

function binarySubdivide (aX, aA, aB, mX1, mX2) {
  var currentX, currentT, i = 0;
  do {
    currentT = aA + (aB - aA) / 2.0;
    currentX = calcBezier(currentT, mX1, mX2) - aX;
    if (currentX > 0.0) {
      aB = currentT;
    } else {
      aA = currentT;
    }
  } while (Math.abs(currentX) > SUBDIVISION_PRECISION && ++i < SUBDIVISION_MAX_ITERATIONS);
  return currentT;
}

function newtonRaphsonIterate (aX, aGuessT, mX1, mX2) {
  for (var i = 0; i < NEWTON_ITERATIONS; ++i) {
    var currentSlope = getSlope(aGuessT, mX1, mX2);
    if (currentSlope === 0.0) return aGuessT;
    var currentX = calcBezier(aGuessT, mX1, mX2) - aX;
    aGuessT -= currentX / currentSlope;
  }
  return aGuessT;
}

/**
 * points is an array of [ mX1, mY1, mX2, mY2 ]
 */
function BezierEasing (points, b, c, d) {
  if (arguments.length === 4) {
    return new BezierEasing([ points, b, c, d ]);
  }
  if (!(this instanceof BezierEasing)) return new BezierEasing(points);

  if (!points || points.length !== 4) {
    throw new Error("BezierEasing: points must contains 4 values");
  }
  for (var i=0; i<4; ++i) {
    if (typeof points[i] !== "number" || isNaN(points[i]) || !isFinite(points[i])) {
      throw new Error("BezierEasing: points should be integers.");
    }
  }
  if (points[0] < 0 || points[0] > 1 || points[2] < 0 || points[2] > 1) {
    throw new Error("BezierEasing x values must be in [0, 1] range.");
  }

  this._str = "BezierEasing("+points+")";
  this._css = "cubic-bezier("+points+")";
  this._p = points;
  this._mSampleValues = float32ArraySupported ? new Float32Array(kSplineTableSize) : new Array(kSplineTableSize);
  this._precomputed = false;

  this.get = this.get.bind(this);
}

BezierEasing.prototype = {

  get: function (x) {
    var mX1 = this._p[0],
      mY1 = this._p[1],
      mX2 = this._p[2],
      mY2 = this._p[3];
    if (!this._precomputed) this._precompute();
    if (mX1 === mY1 && mX2 === mY2) return x; // linear
    // Because JavaScript number are imprecise, we should guarantee the extremes are right.
    if (x === 0) return 0;
    if (x === 1) return 1;
    return calcBezier(this._getTForX(x), mY1, mY2);
  },

  getPoints: function() {
    return this._p;
  },

  toString: function () {
    return this._str;
  },

  toCSS: function () {
    return this._css;
  },

  // Private part

  _precompute: function () {
    var mX1 = this._p[0],
      mY1 = this._p[1],
      mX2 = this._p[2],
      mY2 = this._p[3];
    this._precomputed = true;
    if (mX1 !== mY1 || mX2 !== mY2)
      this._calcSampleValues();
  },

  _calcSampleValues: function () {
    var mX1 = this._p[0],
      mX2 = this._p[2];
    for (var i = 0; i < kSplineTableSize; ++i) {
      this._mSampleValues[i] = calcBezier(i * kSampleStepSize, mX1, mX2);
    }
  },

  /**
   * getTForX chose the fastest heuristic to determine the percentage value precisely from a given X projection.
   */
  _getTForX: function (aX) {
    var mX1 = this._p[0],
      mX2 = this._p[2],
      mSampleValues = this._mSampleValues;

    var intervalStart = 0.0;
    var currentSample = 1;
    var lastSample = kSplineTableSize - 1;

    for (; currentSample !== lastSample && mSampleValues[currentSample] <= aX; ++currentSample) {
      intervalStart += kSampleStepSize;
    }
    --currentSample;

    // Interpolate to provide an initial guess for t
    var dist = (aX - mSampleValues[currentSample]) / (mSampleValues[currentSample+1] - mSampleValues[currentSample]);
    var guessForT = intervalStart + dist * kSampleStepSize;

    var initialSlope = getSlope(guessForT, mX1, mX2);
    if (initialSlope >= NEWTON_MIN_SLOPE) {
      return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
    } else if (initialSlope === 0.0) {
      return guessForT;
    } else {
      return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
    }
  }
};

// CSS mapping
BezierEasing.css = {
  "ease":        BezierEasing.ease      = BezierEasing(0.25, 0.1, 0.25, 1.0),
  "linear":      BezierEasing.linear    = BezierEasing(0.00, 0.0, 1.00, 1.0),
  "ease-in":     BezierEasing.easeIn    = BezierEasing(0.42, 0.0, 1.00, 1.0),
  "ease-out":    BezierEasing.easeOut   = BezierEasing(0.00, 0.0, 0.58, 1.0),
  "ease-in-out": BezierEasing.easeInOut = BezierEasing(0.42, 0.0, 0.58, 1.0)
};

module.exports = BezierEasing;

},{}],504:[function(require,module,exports){
(function (global){
var check = require('./check.js');
var compare = require('./compare.js');

/**
 * Throws an Error if there are differences between the two given instances. The
 * error message will contain the difference summary. Compares arrays, booleans,
 * numbers, objects and strings as well as null and undefined by value and other
 * types by reference.
 */
var assert = function (one, two) {
  var summary;

  summary = compare(one, two, '');

  if (summary !== null) {
    throw new global.Error(summary);
  }
};

/**
 * Throws an Error if the given method does not throw when called with the given
 * args for the given instance.
 */
assert.throws = function (instance, method, args) {
  var unexpected;

  check.function(method);
  check.array(args);

  unexpected = new Error('Expected an error to be thrown!');

  try {
    method.apply(instance, args);

    throw unexpected;
  } catch (error) {
    if (error === unexpected) {
      throw unexpected;
    }
  }
};

module.exports = assert;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./check.js":505,"./compare.js":507}],505:[function(require,module,exports){
(function (global){
var is = require('./is.js');

/**
 * Throws a TypeError if the given instance is not an array.
 */
exports.array = function (instance) {
  if (!is.array(instance)) {
    throw new global.TypeError('Expected array!');
  }
};

/**
 * Throws a TypeError if the given instance is not a boolean.
 */
exports.boolean = function (instance) {
  if (!is.boolean(instance)) {
    throw new global.TypeError('Expected boolean!');
  }
};

/**
 * Throws a TypeError if the given instance is not a function.
 */
exports.function = function (instance) {
  if (!is.function(instance)) {
    throw new global.TypeError('Expected function!');
  }
};

/**
 * Throws a TypeError if the given instance is not null.
 */
exports.null = function (instance) {
  if (!is.null(instance)) {
    throw new global.TypeError('Expected null!');
  }
};

/**
 * Throws a TypeError if the given instance is not a number.
 */
exports.number = function (instance) {
  if (!is.number(instance)) {
    throw new global.TypeError('Expected number!');
  }
};

/**
 * Throws a TypeError if the given instance is not an object.
 */
exports.object = function (instance) {
  if (!is.object(instance)) {
    throw new global.TypeError('Expected object!');
  }
};

/**
 * Throws a TypeError if the given instance is not a string.
 */
exports.string = function (instance) {
  if (!is.string(instance)) {
    throw new global.TypeError('Expected string!');
  }
};

/**
 * Throws a TypeError if the given instance does not descend from the given
 * constructor.
 */
exports.type = function (instance, constructor) {
  if (!is.type(instance, constructor)) {
    throw new global.TypeError('Expected type!');
  }
};

/**
 * Throws a TypeError if the given instance is not undefined.
 */
exports.undefined = function (instance) {
  if (!is.undefined(instance)) {
    throw new global.TypeError('Expected undefined!');
  }
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./is.js":515}],506:[function(require,module,exports){
(function (global){
var is = require('./is.js');
var name = require('./name.js');

/**
 * Attemps to clone the given instance. Only arrays, booleans, numbers, objects
 * and strings as well as null and undefined are accepted. If any other type is
 * encountered, a TypeError is thrown.
 */
var clone = function (instance) {
  var array;
  var i;
  var k;
  var l;
  var object;

  if (is.array(instance)) {
    array = [];

    for (i = 0, l = instance.length; i < l; i++) {
      array[i] = clone(instance[i]);
    }

    return array;
  }

  if (is.boolean(instance)) {
    return instance;
  }

  if (is.null(instance)) {
    return instance;
  }

  if (is.number(instance)) {
    return instance;
  }

  if (is.object(instance)) {
    object = {};

    for (k in instance) {
      object[k] = clone(instance[k]);
    }

    return object;
  }

  if (is.string(instance)) {
    return instance;
  }

  if (is.undefined(instance)) {
    return instance;
  }

  throw new global.TypeError('Unexpected type "' + name(instance) + '"!');
};

module.exports = clone;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./is.js":515,"./name.js":517}],507:[function(require,module,exports){
var is = require('./is.js');
var name = require('./name.js');

/**
 * Creates a difference summary between the two given instances. Compares
 * arrays, booleans, numbers, objects and strings as well as null and undefined
 * by value and other types by reference. Returns null if the two given
 * instances are identical.
 */
var compare = function (one, two, prefix) {
  var i;
  var k;
  var l;
  var m;
  var result;
  var summary;

  result = '\n';

  if (!is.string(prefix)) {
    prefix = '';
  }

  if (is.array(one)) {
    if (!is.array(two)) {
      return 'expected type "' + name(one) + '" but found type "' + name(two) + '"\n';
    }

    for (i = 0, l = one.length, m = two.length; i < l && i < m; i++) {
      summary = compare(one[i], two[i], prefix + '    ');

      if (summary !== null) {
        result += prefix + '"' + i + '": ' + summary;
      }
    }

    for (; i < l; i++) {
      result += prefix + '"' + i + '": the item is missing\n';
    }

    for (; i < m; i++) {
      result += prefix + '"' + i + '": the item was not expected\n';
    }

    return result !== '\n' ? result : null;
  }

  if (is.boolean(one)) {
    if (!is.boolean(two)) {
      return 'expected type "' + name(one) + '" but found type "' + name(two) + '"\n';
    }

    if (one.valueOf() !== two.valueOf()) {
      return 'expected ' + one.valueOf() + ' but found ' + two.valueOf() + '\n';
    }

    return null;
  }

  if (is.null(one)) {
    if (!is.null(two)) {
      return 'expected type "' + name(one) + '" but found type "' + name(two) + '"\n';
    }

    return null;
  }

  if (is.number(one)) {
    if (!is.number(two)) {
      return 'expected type "' + name(one) + '" but found type "' + name(two) + '"\n';
    }

    if (one.valueOf() !== two.valueOf()) {
      return 'expected ' + one.valueOf() + ' but found ' + two.valueOf() + '\n';
    }

    return null;
  }

  if (is.object(one)) {
    if (!is.object(two)) {
      return 'expected type "' + name(one) + '" but found type "' + name(two) + '"\n';
    }

    for (k in one) {
      if (!(k in two)) {
        result += prefix + '"' + k + '": the item is missing\n';
      } else {
        summary = compare(one[k], two[k], prefix + '    ');

        if (summary !== null) {
          result += prefix + '"' + k + '": ' + summary;
        }
      }
    }

    for (k in two) {
      if (!(k in one)) {
        result += prefix + '"' + k + '": the item was not expected\n';
      }
    }

    return result !== '\n' ? result : null;
  }

  if (is.string(one)) {
    if (!is.string(two)) {
      return 'expected type "' + name(one) + '" but found type "' + name(two) + '"\n';
    }

    if (one.valueOf() !== two.valueOf()) {
      return 'expected "' + one.valueOf() + '" but found "' + two.valueOf() + '"\n';
    }

    return null;
  }

  if (is.undefined(one)) {
    if (!is.undefined(two)) {
      return 'expected type "' + name(one) + '" but found type "' + name(two) + '"\n';
    }

    return null;
  }

  if (two == null || two.constructor !== one.constructor) {
    return 'expected an instance of type "' + name(one) + '"\n';
  } else {
    if (one !== two) {
      return 'expected a different instance of type "' + name(one) + '"\n';
    }
  }

  return null;
};

module.exports = compare;

},{"./is.js":515,"./name.js":517}],508:[function(require,module,exports){
var is = require('./is.js');

/**
 * Checks whether the given actual json conforms to the given schema. This
 * asserts that all required fields are present and have the correct types. It
 * also asserts that all optional fields either are present and have the correct
 * types or are missing in the given actual json.
 */
var conforms = function (actual, schema, verbose, path) {
  var i;
  var l;
  var result;
  var k;
  var parts;

  if (!is.boolean(verbose)) {
    verbose = false;
  }

  if (!is.string(path)) {
    path = 'root';
  }

  if (is.array(schema)) {
    if (is.array(actual)) {
      if (schema.length === 0) {
        return true;
      }

      if (schema.length !== 1) {
        if (verbose) {
          console.warn(path + ': expected an array with exactly one element in the schema but found ' + schema.length + ' elements');
        }

        return false;
      }

      result = true;

      for (i = 0, l = actual.length; i < l; i++) {
        if (!conforms(actual[i], schema[0], verbose, path + '[' + i + ']')) {
          result = false;
        }
      }

      return result;
    } else {
      if (verbose) {
        console.warn(path + ': expected an array but found', actual);
      }

      return false;
    }
  }

  if (is.boolean(schema)) {
    if (is.boolean(actual)) {
      return true;
    } else {
      if (verbose) {
        console.warn(path + ': expected a boolean but found', actual);
      }

      return false;
    }
  }

  if (is.number(schema)) {
    if (is.number(actual)) {
      return true;
    } else {
      if (verbose) {
        console.warn(path + ': expected a number but found', actual);
      }

      return false;
    }
  }

  if (is.object(schema)) {
    if (is.object(actual)) {
      result = true;

      for (k in schema) {
        parts = /^([^?]+)\?$/.exec(k);

        if (parts === null) {
          if (!conforms(actual[k], schema[k], verbose, path + '.' + k)) {
            result = false;
          }
        } else {
          if (actual[parts[1]] != null) {
            if (!conforms(actual[parts[1]], schema[k], verbose, path + '.' + k)) {
              result = false;
            }
          }
        }
      }

      return result;
    } else {
      if (verbose) {
        console.warn(path + ': expected an object but found', actual);
      }

      return false;
    }
  }

  if (is.string(schema)) {
    if (is.string(actual)) {
      return true;
    } else {
      if (verbose) {
        console.warn(path + ': expected a string but found', actual);
      }

      return false;
    }
  }

  if (verbose) {
    console.warn(path + ': expected a supported type in the schema but found', schema);
  }

  return false;
};

module.exports = conforms;

},{"./is.js":515}],509:[function(require,module,exports){
(function (global){
var check = require('./check.js');

/**
 * Makes base a pure class.
 */
var define = function (base) {
  check.function(base);

  base.prototype = global.Object.create(null);
  base.prototype.constructor = base;
};

module.exports = define;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./check.js":505}],510:[function(require,module,exports){
var is = require('./is.js');
var name = require('./name.js');

/**
 * Determines if the two given instances are identical. Compares arrays,
 * booleans, numbers, objects and strings as well as null and undefined by value
 * and other types by reference.
 */
var equals = function (one, two) {
  var i;
  var k;
  var l;

  if (is.array(one)) {
    if (!is.array(two)) {
      return false;
    }

    if (one.length !== two.length) {
      return false;
    }

    for (i = 0, l = one.length; i < l; i++) {
      if (!equals(one[i], two[i])) {
        return false;
      }
    }

    return true;
  }

  if (is.boolean(one)) {
    if (!is.boolean(two)) {
      return false;
    }

    if (one.valueOf() !== two.valueOf()) {
      return false;
    }

    return true;
  }

  if (is.null(one)) {
    if (!is.null(two)) {
      return false;
    }

    return true;
  }

  if (is.number(one)) {
    if (!is.number(two)) {
      return false;
    }

    if (one.valueOf() !== two.valueOf()) {
      return false;
    }

    return true;
  }

  if (is.object(one)) {
    if (!is.object(two)) {
      return false;
    }

    for (k in one) {
      if (!(k in two)) {
        return false;
      }

      if (!equals(one[k], two[k])) {
        return false;
      }
    }

    for (k in two) {
      if (!(k in one)) {
        return false;
      }
    }

    return true;
  }

  if (is.string(one)) {
    if (!is.string(two)) {
      return false;
    }

    if (one.valueOf() !== two.valueOf()) {
      return false;
    }

    return true;
  }

  if (is.undefined(one)) {
    if (!is.undefined(two)) {
      return false;
    }

    return true;
  }

  return one === two;
};

module.exports = equals;

},{"./is.js":515,"./name.js":517}],511:[function(require,module,exports){
(function (global){
var check = require('./check.js');

/**
 * Makes derived extend base.
 */
var extend = function (derived, base) {
  check.function(derived);
  check.function(base);

  derived.prototype = global.Object.create(base.prototype);
  derived.prototype.constructor = derived;
};

module.exports = extend;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./check.js":505}],512:[function(require,module,exports){
var is = require('./is.js');

/**
 * Returns the given fallback if the given instance is not an array.
 */
exports.array = function (instance, fallback) {
  return is.array(instance) ? instance : fallback;
};

/**
 * Returns the given fallback if the given instance is not a boolean.
 */
exports.boolean = function (instance, fallback) {
  return is.boolean(instance) ? instance : fallback;
};

/**
 * Returns the given fallback if the given instance is not a function.
 */
exports.function = function (instance, fallback) {
  return is.function(instance) ? instance : fallback;
};

/**
 * Returns the given fallback if the given instance is not null.
 */
exports.null = function (instance, fallback) {
  return is.null(instance) ? instance : fallback;
};

/**
 * Returns the given fallback if the given instance is not a number.
 */
exports.number = function (instance, fallback) {
  return is.number(instance) ? instance : fallback;
};

/**
 * Returns the given fallback if the given instance is not an object.
 */
exports.object = function (instance, fallback) {
  return is.object(instance) ? instance : fallback;
};

/**
 * Returns the given fallback if the given instance is not a string.
 */
exports.string = function (instance, fallback) {
  return is.string(instance) ? instance : fallback;
};

/**
 * Returns the given fallback if the given instance does not descend from the
 * given constructor.
 */
exports.type = function (instance, constructor, fallback) {
  return is.type(instance, constructor) ? instance : fallback;
};

/**
 * Returns the given fallback if the given instance is not undefined.
 */
exports.undefined = function (instance, fallback) {
  return is.undefined(instance) ? instance : fallback;
};

},{"./is.js":515}],513:[function(require,module,exports){
/**
 * Creates a function wrapper that always returns the given value.
 */
var fixture = function (value) {
  return function () {
    return value;
  };
};

module.exports = fixture;

},{}],514:[function(require,module,exports){
exports.assert = require('./assert.js');
exports.check = require('./check.js');
exports.clone = require('./clone.js');
exports.compare = require('./compare.js');
exports.conforms = require('./conforms.js');
exports.define = require('./define.js');
exports.equals = require('./equals.js');
exports.extend = require('./extend.js');
exports.fallback = require('./fallback.js');
exports.fixture = require('./fixture.js');
exports.is = require('./is.js');
exports.mock = require('./mock.js');
exports.name = require('./name.js');
exports.spy = require('./spy.js');
exports.stub = require('./stub.js');

},{"./assert.js":504,"./check.js":505,"./clone.js":506,"./compare.js":507,"./conforms.js":508,"./define.js":509,"./equals.js":510,"./extend.js":511,"./fallback.js":512,"./fixture.js":513,"./is.js":515,"./mock.js":516,"./name.js":517,"./spy.js":518,"./stub.js":519}],515:[function(require,module,exports){
(function (global){
/**
 * Determines if the given instance is an array.
 */
exports.array = function (instance) {
  return instance != null && instance.constructor === global.Array;
};

/**
 * Determines if the given instance is a boolean.
 */
exports.boolean = function (instance) {
  return instance != null && instance.constructor === global.Boolean;
};

/**
 * Determines if the given instance is a function.
 */
exports.function = function (instance) {
  return instance != null && instance.constructor === global.Function;
};

/**
 * Determines if the given instance is null.
 */
exports.null = function (instance) {
  return instance === null;
};

/**
 * Determines if the given instance is a number.
 */
exports.number = function (instance) {
  return instance != null && instance.constructor === global.Number;
};

/**
 * Determines if the given instance is an object.
 */
exports.object = function (instance) {
  return instance != null && instance.constructor === global.Object;
};

/**
 * Determines if the given instance is a string.
 */
exports.string = function (instance) {
  return instance != null && instance.constructor === global.String;
};

/**
 * Determines if the given instance descends from the given constructor.
 */
exports.type = function (instance, constructor) {
  return instance != null && constructor != null && instance instanceof constructor;
};

/**
 * Determines if the given instance is undefined.
 */
exports.undefined = function (instance) {
  return instance === global.undefined;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],516:[function(require,module,exports){
(function (global){
var check = require('./check.js');
var extend = require('./extend.js');
var is = require('./is.js');

/**
 * Creates a mock for the given base class with the given implementation that
 * can be used for unit testing. The methods defined on implementation will be
 * used instead of the methods defined on the base class.
 */
var mock = function (base, implementation) {
  var derived;
  var keys;
  var i;
  var key;

  check.function(base);

  derived = function () {
    base.apply(this, arguments);
  };

  extend(derived, base);

  derived.create = function () {
    var that;

    that = global.Object.create(derived.prototype);

    derived.apply(that, arguments);

    return that;
  };

  if (implementation != null) {
    check.object(implementation);

    keys = global.Object.getOwnPropertyNames(implementation);

    for (i = 0; i < keys.length; i++) {
      key = keys[i];

      if (key !== 'constructor' && is.function(implementation[key])) {
        if (is.function(base.prototype[key])) {
          derived.prototype[key] = implementation[key];
        } else {
          throw new global.Error('Method "' + key + '" doesn\'t override any method defined on the base class!');
        }
      }
    }
  }

  return derived;
};

module.exports = mock;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./check.js":505,"./extend.js":511,"./is.js":515}],517:[function(require,module,exports){
var is = require('./is.js');

/**
 * Attempts to read the type name for the given instance.
 */
var name = function (instance) {
  if (is.null(instance)) {
    return 'Null';
  }

  if (is.undefined(instance)) {
    return 'Undefined';
  }

  if (is.function(instance.constructor) && is.string(instance.constructor.name)) {
    return instance.constructor.name;
  }

  return '';
};

module.exports = name;

},{"./is.js":515}],518:[function(require,module,exports){
(function (global){
var check = require('./check.js');

/**
 * Creates a spy function that records all function calls into the given calls
 * array.
 */
var spy = function (calls) {
  check.array(calls);

  return function () {
    calls.push({ 'caller' : this, 'arguments' : global.Array.prototype.slice.call(arguments) });
  };
};

module.exports = spy;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./check.js":505}],519:[function(require,module,exports){
(function (global){
var check = require('./check.js');
var extend = require('./extend.js');
var is = require('./is.js');

/**
 * Creates a stub for the given base class with the given implementation that
 * can be used for unit testing.
 */
var stub = function (base, implementation) {
  var derived;
  var prototype;
  var keys;
  var i;
  var key;

  check.function(base);
  check.object(implementation);

  derived = function () {
    var key;

    for (key in implementation) {
      this[key] = implementation[key];
    }
  };

  extend(derived, base);

  derived.create = function () {
    var that;

    that = global.Object.create(derived.prototype);

    derived.apply(that, arguments);

    return that;
  };

  prototype = base.prototype;

  while (prototype != null && prototype !== global.Object.prototype) {
    keys = global.Object.getOwnPropertyNames(prototype);

    for (i = 0; i < keys.length; i++) {
      key = keys[i];

      if (key !== 'constructor' && is.function(prototype[key])) {
        if (is.function(implementation[key])) {
          derived.prototype[key] = implementation[key];
        } else {
          derived.prototype[key] = (function (key) {
            return function () {
              throw new global.Error('Method stub "' + key + '" called!');
            };
          })(key);
        }
      }
    }

    prototype = global.Object.getPrototypeOf(prototype);
  }

  return derived;
};

module.exports = stub;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./check.js":505,"./extend.js":511,"./is.js":515}],520:[function(require,module,exports){
'use strict';

exports.message = require('./src/message');
exports.request = require('./src/request');
exports.response = require('./src/response');
exports.playerstate = require('./src/player_state');

},{"./src/message":521,"./src/player_state":522,"./src/request":523,"./src/response":524}],521:[function(require,module,exports){
/**
 * A set of Message headers.
 *
 * @name exports.Headers
 * @typedef {Object.<string, string>}
 */
exports.Headers;

/**
 * A body of a Request-Response.
 *
 * @name exports.Body
 * @typedef {*}
 */
exports.Body;

/**
 * A serialized Message object.
 *
 * @name Spotify.Cosmos.SerializedMessage
 * @typedef {{
 *   uri: Spotify.Cosmos.URI,
 *   headers: Spotify.Cosmos.Headers,
 *   body: Spotify.Cosmos.Body
 * }}
 */
exports.SerializedMessage;

/**
 * Encapsulates a message.
 *
 * A message is an entity that has a URI, headers and a body.
 *
 * @constructs Spotify.Cosmos.Message
 * @param {Spotify.Cosmos.URI} uri The URI of the message
 * @param {Spotify.Cosmos.Headers=} opt_headers The optional headers of the
 *     message.
 * @param {Spotify.Cosmos.Body=} opt_body The optional body of the message.
 */
function Message(uri, opt_headers, opt_body) {
  if (uri == null)
    throw new TypeError('Invalid `uri` argument for Message.');

  /**
   * The URI of the Message.
   *
   * @type {Spotify.Cosmos.URI}
   * @protected
   */
  this._uri = uri;

  /**
   * The headers of the Message.
   *
   * @type {Spotify.Cosmos.Headers}
   * @protected
   */
  this._headers = {};

  /**
   * The body of the Message.
   *
   * @type {Spotify.Cosmos.Body}
   * @protected
   */
  this._body = this._encodeBody(opt_body || '');

  if (opt_headers) this._setHeaders(opt_headers);
}
exports.Message = Message;

/**
 * Creates a new Message from a SerializedMessage object.
 *
 * @param {Spotify.Cosmos.SerializedMessage} object The serialized request.
 * @return {Spotify.Cosmos.Message|null} The new Message object or null.
 */
Message.fromObject = function(object) {
  return (object && object.uri) ?
    new Message(
        object.uri,
        object.headers,
        object.body
    ) : null;
};

/**
 * Encodes a message body to a string.
 *
 * @param {*} body The value for the body.
 * @return {string} The body encoded as a string.
 */
Message.prototype._encodeBody = function(body) {
  if (typeof body != 'string') {
    body = JSON.stringify(body);
  }
  return body;
};

/**
 * Returns the URI of the message.
 *
 * @return {Spotify.Cosmos.URI} The URI of the message.
 */
Message.prototype.getURI = function() {
  return this._uri;
};

/**
 * Returns the mimetype of the message.
 *
 * @return {Spotify.Cosmos.MimeType} The mimetype of the message.
 */
Message.prototype.getMimeType = function() {
  return this._headers['accept'];
};

/**
 * Returns the value of a message's headers.
 *
 * @param {string} name The name of the header.
 * @return {string|null} The header value or null if the header wasn't set.
 */
Message.prototype.getHeader = function(name) {
  return this._headers[name.toLowerCase()] || null;
};

/**
 * Returns the headers of the message.
 *
 * @return {Spotify.Cosmos.Headers} The headers of the message.
 */
Message.prototype.getHeaders = function() {
  var _headers = this._headers;
  var headers = {};
  for (var name in _headers) {
    if (!_headers.hasOwnProperty(name)) continue;
    headers[name] = _headers[name];
  }
  return headers;
};

/**
 * Sets a bunch of headers to the message's headers.
 *
 * @param {Spotify.Cosmos.Headers} headers The headers to set to the message.
 * @protected
 */
Message.prototype._setHeaders = function(headers) {
  var _headers = this._headers;
  for (var name in headers) {
    if (!headers.hasOwnProperty(name)) continue;
    _headers[name.toLowerCase()] = headers[name];
  }
  return this;
};

/**
 * Returns the body of the message.
 *
 * @return {Spotify.Cosmos.Body} The body of the message.
 */
Message.prototype.getBody = function() {
  return this._body;
};

/**
 * Returns the body as a JSON object.
 *
 * @return {Object|null} The body of the message parsed as a JSON value. Can
 *     be null if the body is not a proper JSON string.
 */
Message.prototype.getJSONBody = function() {
  try {
    return JSON.parse(this._body);
  } catch(e) {
    return null;
  }
};

/**
 * Creates a new Message instance with data copied from the current instance.
 *
 * @param {Spotify.Cosmos.Headers=} opt_headers The optional headers of the
 *     message.
 * @param {Spotify.Cosmos.Body=} opt_body The optional body of the message.
 */
Message.prototype.copy = function(opt_headers, opt_body) {
  return new Message(
      this._uri,
      this._copyHeaders(opt_headers),
      typeof opt_body != 'undefined' ? opt_body : this._body
  );
};

/**
 * Copies the headers of the message.
 *
 * @param {Spotify.Cosmos.Headers=} opt_headers The optional headers of the
 *     message.
 * @return {Spotify.Cosmos.Headers} The headers of the message.
 */
Message.prototype._copyHeaders = function(opt_headers) {
  var headers;
  if (opt_headers) {
    var _headers = this._headers;
    var name;
    headers = {};
    for (name in _headers) {
      if (!_headers.hasOwnProperty(name)) continue;
      headers[name] = _headers[name];
    }
    for (name in opt_headers) {
      if (!opt_headers.hasOwnProperty(name)) continue;
      headers[name.toLowerCase()] = opt_headers[name];
    }
  } else {
    headers = this._headers;
  }
  return headers;
};

/**
 * Serializes the message into a plain object.
 *
 * @return {Spotify.Cosmos.SerializedMessage} The serialized object.
 */
Message.prototype.serialize = function() {
  return this.toJSON();
};

/**
 * Returns a JSON-object representation of the message.
 *
 * @return {Object} The JSON representation of the message.
 */
Message.prototype.toJSON = function() {
  return {
    uri: this._uri,
    headers: this._headers,
    body: this._body
  };
};

},{}],522:[function(require,module,exports){
var inherit = require('spotify-inheritance').inherit;

/**
 * PlayerState is used for two distinct purposes: Pushing new state to the
 * player (this is done when you request to play a completely new context with
 * 'play' method) and retrieving player state updates.
 *
 * Changing properties on PlayerState objects will not change the state of
 * the player unless you pass it to the 'play' method.
 *
 * @param {Object} stateData the data for the playerState.
 */
function PlayerState(stateData) {
  Serializable.call(this, [
    'action',
    'context',
    'tracks',
    'index',
    'playing',
    'loading',
    'track',
    'position',
    'duration',
    'volume',
    'options',
    'play_origin',
    'next_page_url',
    'prev_page_url'
  ]);

  stateData = stateData || {};
  /**
   * What kind of the action player should perform.
   * It's set directly before sending the request.
   * @type {String}
   */
  this.action = stateData.action;

  /**
   * Spotify uri describing the context that
   * will be played e.g playlist, album or artist.
   * Example: spotify:artist:4XaUmUGjidSklcDHxv3XWf,
   * spotify:user:daftpunkofficial:playlist:5nrg0D90OlFyveVfrQD0zE,
   * spotify:album:2nXJkqkS1tIKIyhBcFMmwz
   *
   * @type {String}
   */
  this.context = stateData.context;

  /**
   * The list of tracks uris to play in the given context.
   * Example: [
   *    spotify:track:0bXpmJyHHYPk6QBFj25bYF,
   *    spotify:track:6DXFVsLcEvOTSrkG9G1Cb1,
   *    spotify:track:6rxEjkoar48SssZePbtb2x
   * ]
   *
   * @type {Array.<String>}
   */
  this.tracks = stateData.tracks;

  /**
   * Which element on the this.tracks list should
   * be played.
   *
   * @type {Number}
   */
  this.index = stateData.index;

  /**
   * Is the player currently playing
   */
  this.playing = stateData.playing;
  this.loading = stateData.loading;

  /**
   * Current track URI
   * @type {String}
   */
  this.track = stateData.track;


  this.position = stateData.position;

  this.volume = stateData.volume;

  /**
   * Current track duration in miliseconds?
   * @type {Number}
   */
  this.duration = stateData.duration;

  /**
   * See PlayOptions description
   * @type {cosmos-bindings-js/scripts/player_state~PlayOptions}
   */
  this.options = new PlayOptions(stateData.options);

  /**
   * See PlayOrigin description
   * @type {cosmos-bindings-js/scripts/player_state~PlayOrigin}
   */
  this.play_origin = new PlayOrigin(stateData.play_origin);

  /**
   * Before the list of tracks that are to be played ends, a request will be sent
   * to this URL, which is supposed to return a list of tracks. That list of
   * tracks will then be appended to the list of tracks in the context.
   *
   * The response payload of the next_page_url should look like this:
   *
   * {
   *   "tracks": [
   *     { "track": "spotify:track:$TRACK-ID1", "context": "spotify:album:$ALBUM-ID1" },
   *     { "track": "spotify:track:$TRACK-ID2", "context": "spotify:album:$ALBUM-ID1" },
   *     { "track": "spotify:track:$TRACK-ID3", "context": "spotify:album:$ALBUM-ID1" },
   *   ],
   *   "next_page_url": "...", // Optional
   *   "prev_page_url": "..." // Optional
   * }
   *
   * May be null, which is the same as a URL that would return an empty list
   * of tracks (but with null, no network request is made).
   */
  this.next_page_url = stateData.next_page_url;

  /**
   * Like `next_page_url`, but for going backwards in the context.
   */
  this.prev_page_url = stateData.prev_page_url;
}
inherit(PlayerState, Serializable);

/**
 * Ovverides prototype method.
 * Converts play options and origin to
 * serializable to make sure only correct data
 * is returned.
 * @return {Object} Data associated with player state.
 */
PlayerState.prototype.serialize = function() {
  if (this.options && !(this.options instanceof PlayOptions)) {
    this.options = new PlayOptions(this.options);
  }

  if (this.play_origin && !(this.play_origin instanceof PlayOrigin)) {
    this.play_origin = new PlayOrigin(this.play_origin);
  }

  return this.constructor.prototype.serialize.call(this);
};

/**
 * Possible player actions.
 */
PlayerState.ACTIONS = {
  UNKNOWN: 'unknown',
  PLAY: 'play',
  UPDATE: 'update',
  STOP: 'stop',
  RESUME: 'resume',
  PAUSE: 'pause',
  SKIP_PREV: 'skip_prev',
  SKIP_NEXT: 'skip_next'
};

function PlayOrigin(data) {
  Serializable.call(this, [
    'source',
    'source_context',
    'reason',
    'referrer',
    'referrer_version',
    'referrer_vendor'
  ]);

  data = data || {};

  /**
   * What kind of playlist did we play from?
   *
   * The default value of this property is "unknown". Must have a value.
   *
   * Valid values include 'album', 'artist', 'extlink', 'playlist', 'playqueue',
   * 'radio', 'search', 'unknown'.
   *
   * For an up to date list of valid values, see `PLAY_SOURCES` in
   * https://git.spotify.net/cgit.cgi/log-parser.git/tree/spotify/log_parser/messages_specs.py
   */
  this.source = data.source || 'unknown';

  /**
   * The uri of the view that initiated the playback.
   */
  this.source_context = data.source_context || 'unknown';

  /**
   * Why was the song started?
   *
   * The default value of this property is "unknown". Must have a value.
   *
   * A list of valid values that might be used by features:
   *
   * unknown    = Client doesn't know
   * clickrow   = A row in the song list was clicked/opened
   * playbtn    = The play button was pressed
   * urlopen    = A Url was opened
   *
   * For a complete and up to date list of valid values, see `PLAY_REASONS` in
   * https://git.spotify.net/cgit.cgi/log-parser.git/tree/spotify/log_parser/messages_specs.py
   */
  this.reason = data.reason || 'unknown';

  /**
   * Either a remote site or a spotify app which initiated the request.
   *
   * NOTE: This normally should be a readonly property and not be set
   * explicitly in the PlayerState as the Player will overwrite it when sending the request.
   */
  this.referrer = data.referrer || 'unknown';

  /**
   * The version of the referrer, where applicable. It usually makes sense to
   * set this value to the version of the JS app version, for instance "0.7.5".
   *
   * NOTE: This normally should be a readonly property and not be set
   * explicitly in the PlayerState as the Player will overwrite it when sending the request.
   */
  this.referrer_version = data.referrer_version || 'unknown';

  /**
   * The vendor of the referrer, where applicable.
   * For example com.soundrop, com.spotify.
   *
   * NOTE: This normally should be a readonly property and not be set
   * explicitly in the PlayerState as the Player will overwrite it when sending the request.
   */
  this.referrer_vendor = data.referrer_vendor || 'unknown';
}
inherit(PlayOrigin, Serializable);

/**
 * What kind of options user has
 * with the player. By default
 * all 'can_*' properties are set to true.
 * You might want to restrict some of them
 * in the special cases like ads (no skipping)
 * or radio no skipping prev.
 * @constructor
 * @param {Object} options The options data.
 */
function PlayOptions(options) {
  Serializable.call(this, [
    'repeat',
    'shuffle',
    'can_repeat',
    'can_shuffle',
    'can_skip_prev',
    'can_skip_next',
    'can_seek',
    'use_dmca_rules'
  ]);
  options = options || {};

  /**
   * True if repeat (repeat all, not single track repeat) is (or is to be) enabled.
   *
   * Default value is false
   */
  this.repeat = options.repeat !== undefined ? options.repeat : false;

  /**
   * True if shuffle is (or is to be) enabled.
   *
   * Default value is false
   */
  this.shuffle = options.shuffle !== undefined ? options.shuffle : false;

  /**
   * True if this context can be repeated. This would be false for instance in the
   * case of radio.
   *
   * Default value is true.
   */
  this.can_repeat = options.can_repeat !== undefined ? options.can_repeat : true;

  /**
   * True if this context can be shuffled. This would be false for instance in the
   * case of radio.
   *
   * Default value is true.
   */
  this.can_shuffle = options.can_shuffle !== undefined ? options.can_shuffle : true;

  /**
   * True if the user is (or should be) allowed to skip to the previous track.
   *
   * Default value is true.
   */
  this.can_skip_prev = options.can_skip_prev !== undefined ? options.can_skip_prev : true;

  /**
   * True if the user is (or should be) allowed to skip to the next track.
   *
   * Default value is true.
   */
  this.can_skip_next = options.can_skip_next !== undefined ? options.can_skip_next : true;

  /**
   * True if the user is (or should be) allowed to seek to a certain time in the
   * currently playing track.
   *
   * Default value is true.
   */
  this.can_seek = options.can_seek !== undefined ? options.can_seek : true;

  /**
   * True if the track player should automatically apply DMCA rules when playing.
   * DMCA rules should be enabled for users that have free radio in the US, and
   * controls how many tracks the user are allowed to skip etc.
   *
   * Default value is false.
   */
  this.use_dmca_rules = options.use_dmca_rules !== undefined ? options.use_dmca_rules : false;
}
inherit(PlayOptions, Serializable);

/**
 * The object accepting only defined properties.
 * To make sure only valid properties are passed
 * always use 'serialize()' when object value needed.
 * @constructor
 * @param {Array.<string>} allowedProps The list of the properties
 * that are supported for the object.
 */
function Serializable(allowedProps) {
  this._props = allowedProps || [];
}

/**
 * The JSON representation of the object.
 * @return {Object} Data associated with current player state.
 */
Serializable.prototype.serialize = function() {
  var data = {};
  var prop;

  for (var i = 0, l = this._props.length; i < l; i++) {
    prop = this._props[i];
    if (this[prop] !== undefined) {
      if (this[prop] instanceof Serializable) {
        data[prop] = this[prop].serialize();
      } else {
        data[prop] = this[prop];
      }
    }
  }

  return data;
};

exports.PlayerState = PlayerState;

},{"spotify-inheritance":705}],523:[function(require,module,exports){
var inherit = require('spotify-inheritance').inherit;

var Message = require('./message').Message;

/**
 * Request actions.
 *
 * @name exports.Action
 * @enum {string}
 */
exports.Action = {
  DELETE: 'DELETE',
  GET: 'GET',
  HEAD: 'HEAD',
  POST: 'POST',
  PUT: 'PUT',
  SUB: 'SUB',
  PATCH: 'PATCH'
};

/**
 * A serialized Request object.
 *
 * @name Spotify.Cosmos.SerializedRequest
 * @typedef {{
 *   uri: Spotify.Cosmos.URI,
 *   headers: Spotify.Cosmos.Headers,
 *   body: Spotify.Cosmos.Body
 * }}
 */
exports.SerializedRequest;

/**
 * Encapsulates a request to the handlers.
 *
 * Instances of this class are "immutable" and should not be changed.
 *
 * @constructs Spotify.Cosmos.Request
 * @extends Spotify.Cosmos.Message
 * @param {Spotify.Cosmos.Action} action The action of the request.
 * @param {Spotify.Cosmos.URI} uri The URI of the request
 * @param {Spotify.Cosmos.Headers=} opt_headers The optional headers of the
 *     request.
 * @param {Spotify.Cosmos.Body=} opt_body The optional body of the request.
 */
function Request(action, uri, opt_headers, opt_body) {
  if (!(this instanceof Request))
    return new Request(action, uri, opt_headers, opt_body);
  if (!action)
    throw new TypeError('Invalid `action` argument for Request.');
  Message.call(this, uri, opt_headers, opt_body);

  /**
   * The action of the request.
   *
   * @type {Spotify.Cosmos.Action}
   * @protected
   */
  this._action = action;
}
inherit(Request, Message);
exports.Request = Request;

/**
 * Creates a new Request from a SerializedRequest object.
 *
 * @param {Spotify.Cosmos.SerializedRequest} object The serialized request.
 * @return {Spotify.Cosmos.Request|null} The new Request object or null.
 */
Request.fromObject = function(object) {
  return (object && object.action && object.uri) ?
    new Request(
        object.action,
        object.uri,
        object.headers,
        object.body
    ) : null;
};

/**
 * Returns the action of the request.
 *
 * @return {Spotify.Cosmos.Action} The action of the request.
 */
Request.prototype.getAction = function() {
  return this._action;
};

/**
 * @inheritDoc
 */
Request.prototype.copy = function(opt_headers, opt_body) {
  return new Request(
      this._action,
      this._uri,
      this._copyHeaders(opt_headers),
      typeof opt_body != 'undefined' ? opt_body : this._body
  );
};

/**
 * @inheritDoc
 */
Request.prototype.toJSON = function() {
  return {
    action: this._action,
    uri: this._uri,
    headers: this._headers,
    body: this._body
  };
};



},{"./message":521,"spotify-inheritance":705}],524:[function(require,module,exports){
var inherit = require('spotify-inheritance').inherit;

var Message = require('./message').Message;

/**
 * Statuscode.
 * The statuses with negative numbers are reserved for
 * errors that originate within the cosmos library.
 *
 * @name exports.StatusCode
 * @enum {number}
 */
exports.StatusCode = {
  OK: 200,
  CREATED: 201,
  ACCEPTED: 202,
  BAD_REQUEST: 400,
  UNAUTHORIZED: 401,
  FORBIDDEN: 403,
  NOT_FOUND: 404,
  METHOD_NOT_ALLOWED: 405,
  TIMED_OUT: 408,
  CONFLICT: 409,
  GONE: 410,
  INTERNAL_SERVER_ERROR: 500,
  NOT_IMPLEMENTED: 501,
  BAD_GATEWAY: 502,
  SERVICE_UNAVAILABLE: 503,

  /** Something went wrong, but the exact reason is not known. */
  ERROR_UNKNOWN: -100,

  /** A resource allocation required to complete the request failed. */
  ERROR_ALLOCATION_FAILED: -101,

  /** The body could not be decoded because it does
   not conform to the encoding header field. */
  ERROR_INVALID_ENCODING: -102,

  /** The router detected an infinite loop while processing the request. */
  ERROR_INFINITE_LOOP: -103,

  /** No endpoint resolver that could handle the request was found. */
  ERROR_RESOLVER_NOT_FOUND: -104
};

/**
 * A serialized Response object.
 *
 * @name Spotify.Cosmos.SerializedResponse
 * @typedef {{
 *   uri: Spotify.Cosmos.URI,
 *   status: Spotify.Cosmos.StatusCode,
 *   headers: Spotify.Cosmos.Headers,
 *   body: Spotify.Cosmos.Body
 * }}
 */
exports.SerializedResponse;

/**
 * Encapsulates a response from the handlers.
 *
 * @constructs Spotify.Cosmos.Response
 * @extends Spotify.Cosmos.Message
 * @param {Spotify.Cosmos.URI} uri The URI of the response
 * @param {Spotify.Cosmos.StatusCode} status The status of the response.
 * @param {Spotify.Cosmos.Headers=} opt_headers The optional headers of the
 *     response.
 * @param {Spotify.Cosmos.Body=} opt_body The optional body of the response.
 */
function Response(uri, status, opt_headers, opt_body) {
  if (!(this instanceof Response))
    return new Response(uri, status, opt_headers, opt_body, opt_requestURI);
  if (typeof status == 'undefined' || status == null)
    throw new TypeError('Invalid `status` argument for Response.');

  Message.call(this, uri, opt_headers, opt_body);

  /**
   * The Status of the Response.
   *
   * @type {Spotify.Cosmos.StatusCode}
   * @protected
   */
  this._status = status;
}
inherit(Response, Message);
exports.Response = Response;

/**
 * Creates a new Response from a SerializedResponse object.
 *
 * @param {Spotify.Cosmos.SerializedResponse} object The serialized response.
 * @return {Spotify.Cosmos.Response|null} The new Response object or null.
 */
Response.fromObject = function(object) {
  return (object && object.uri && object.status) ?
    new Response(
        object.uri,
        object.status,
        object.headers,
        object.body
    ) : null;
};

/**
 * @inheritDoc
 */
Response.prototype.getMimeType = function() {
  return this._headers['content-type'];
};

/**
 * Returns the status code of the Response.
 *
 * @return {Spotify.Cosmos.StatusCode} The status code of the response.
 */
Response.prototype.getStatusCode = function() {
  return this._status;
};

/**
 * @inheritDoc
 */
Response.prototype.copy = function(opt_headers, opt_body) {
  return new Response(
      this._uri,
      this._status,
      this._copyHeaders(opt_headers),
      typeof opt_body != 'undefined' ? opt_body : this._body
  );
};

/**
 * @inheritDoc
 */
Response.prototype.toJSON = function() {
  return {
    uri: this._uri,
    status: this._status,
    headers: this._headers,
    body: this._body
  };
};


},{"./message":521,"spotify-inheritance":705}],525:[function(require,module,exports){
module.exports = function (css, customDocument) {
  var doc = customDocument || document;
  if (doc.createStyleSheet) {
    var sheet = doc.createStyleSheet()
    sheet.cssText = css;
    return sheet.ownerNode;
  } else {
    var head = doc.getElementsByTagName('head')[0],
        style = doc.createElement('style');

    style.type = 'text/css';

    if (style.styleSheet) {
      style.styleSheet.cssText = css;
    } else {
      style.appendChild(doc.createTextNode(css));
    }

    head.appendChild(style);
    return style;
  }
};

module.exports.byUrl = function(url) {
  if (document.createStyleSheet) {
    return document.createStyleSheet(url).ownerNode;
  } else {
    var head = document.getElementsByTagName('head')[0],
        link = document.createElement('link');

    link.rel = 'stylesheet';
    link.href = url;

    head.appendChild(link);
    return link;
  }
};

},{}],526:[function(require,module,exports){

/**
 * This is the web browser implementation of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = require('./debug');
exports.log = log;
exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = 'undefined' != typeof chrome
               && 'undefined' != typeof chrome.storage
                  ? chrome.storage.local
                  : localstorage();

/**
 * Colors.
 */

exports.colors = [
  'lightseagreen',
  'forestgreen',
  'goldenrod',
  'dodgerblue',
  'darkorchid',
  'crimson'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

function useColors() {
  // is webkit? http://stackoverflow.com/a/16459606/376773
  return ('WebkitAppearance' in document.documentElement.style) ||
    // is firebug? http://stackoverflow.com/a/398120/376773
    (window.console && (console.firebug || (console.exception && console.table))) ||
    // is firefox >= v31?
    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
    (navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31);
}

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

exports.formatters.j = function(v) {
  return JSON.stringify(v);
};


/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs() {
  var args = arguments;
  var useColors = this.useColors;

  args[0] = (useColors ? '%c' : '')
    + this.namespace
    + (useColors ? ' %c' : ' ')
    + args[0]
    + (useColors ? '%c ' : ' ')
    + '+' + exports.humanize(this.diff);

  if (!useColors) return args;

  var c = 'color: ' + this.color;
  args = [args[0], c, 'color: inherit'].concat(Array.prototype.slice.call(args, 1));

  // the final "%c" is somewhat tricky, because there could be other
  // arguments passed either before or after the %c, so we need to
  // figure out the correct index to insert the CSS into
  var index = 0;
  var lastC = 0;
  args[0].replace(/%[a-z%]/g, function(match) {
    if ('%%' === match) return;
    index++;
    if ('%c' === match) {
      // we only are interested in the *last* %c
      // (the user may have provided their own)
      lastC = index;
    }
  });

  args.splice(lastC, 0, c);
  return args;
}

/**
 * Invokes `console.log()` when available.
 * No-op when `console.log` is not a "function".
 *
 * @api public
 */

function log() {
  // this hackery is required for IE8/9, where
  // the `console.log` function doesn't have 'apply'
  return 'object' === typeof console
    && console.log
    && Function.prototype.apply.call(console.log, console, arguments);
}

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */

function save(namespaces) {
  try {
    if (null == namespaces) {
      exports.storage.removeItem('debug');
    } else {
      exports.storage.debug = namespaces;
    }
  } catch(e) {}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */

function load() {
  var r;
  try {
    r = exports.storage.debug;
  } catch(e) {}
  return r;
}

/**
 * Enable namespaces listed in `localStorage.debug` initially.
 */

exports.enable(load());

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage(){
  try {
    return window.localStorage;
  } catch (e) {}
}

},{"./debug":527}],527:[function(require,module,exports){

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 *
 * Expose `debug()` as the module.
 */

exports = module.exports = debug;
exports.coerce = coerce;
exports.disable = disable;
exports.enable = enable;
exports.enabled = enabled;
exports.humanize = require('ms');

/**
 * The currently active debug mode names, and names to skip.
 */

exports.names = [];
exports.skips = [];

/**
 * Map of special "%n" handling functions, for the debug "format" argument.
 *
 * Valid key names are a single, lowercased letter, i.e. "n".
 */

exports.formatters = {};

/**
 * Previously assigned color.
 */

var prevColor = 0;

/**
 * Previous log timestamp.
 */

var prevTime;

/**
 * Select a color.
 *
 * @return {Number}
 * @api private
 */

function selectColor() {
  return exports.colors[prevColor++ % exports.colors.length];
}

/**
 * Create a debugger with the given `namespace`.
 *
 * @param {String} namespace
 * @return {Function}
 * @api public
 */

function debug(namespace) {

  // define the `disabled` version
  function disabled() {
  }
  disabled.enabled = false;

  // define the `enabled` version
  function enabled() {

    var self = enabled;

    // set `diff` timestamp
    var curr = +new Date();
    var ms = curr - (prevTime || curr);
    self.diff = ms;
    self.prev = prevTime;
    self.curr = curr;
    prevTime = curr;

    // add the `color` if not set
    if (null == self.useColors) self.useColors = exports.useColors();
    if (null == self.color && self.useColors) self.color = selectColor();

    var args = Array.prototype.slice.call(arguments);

    args[0] = exports.coerce(args[0]);

    if ('string' !== typeof args[0]) {
      // anything else let's inspect with %o
      args = ['%o'].concat(args);
    }

    // apply any `formatters` transformations
    var index = 0;
    args[0] = args[0].replace(/%([a-z%])/g, function(match, format) {
      // if we encounter an escaped % then don't increase the array index
      if (match === '%%') return match;
      index++;
      var formatter = exports.formatters[format];
      if ('function' === typeof formatter) {
        var val = args[index];
        match = formatter.call(self, val);

        // now we need to remove `args[index]` since it's inlined in the `format`
        args.splice(index, 1);
        index--;
      }
      return match;
    });

    if ('function' === typeof exports.formatArgs) {
      args = exports.formatArgs.apply(self, args);
    }
    var logFn = enabled.log || exports.log || console.log.bind(console);
    logFn.apply(self, args);
  }
  enabled.enabled = true;

  var fn = exports.enabled(namespace) ? enabled : disabled;

  fn.namespace = namespace;

  return fn;
}

/**
 * Enables a debug mode by namespaces. This can include modes
 * separated by a colon and wildcards.
 *
 * @param {String} namespaces
 * @api public
 */

function enable(namespaces) {
  exports.save(namespaces);

  var split = (namespaces || '').split(/[\s,]+/);
  var len = split.length;

  for (var i = 0; i < len; i++) {
    if (!split[i]) continue; // ignore empty strings
    namespaces = split[i].replace(/\*/g, '.*?');
    if (namespaces[0] === '-') {
      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
    } else {
      exports.names.push(new RegExp('^' + namespaces + '$'));
    }
  }
}

/**
 * Disable debug output.
 *
 * @api public
 */

function disable() {
  exports.enable('');
}

/**
 * Returns true if the given mode name is enabled, false otherwise.
 *
 * @param {String} name
 * @return {Boolean}
 * @api public
 */

function enabled(name) {
  var i, len;
  for (i = 0, len = exports.skips.length; i < len; i++) {
    if (exports.skips[i].test(name)) {
      return false;
    }
  }
  for (i = 0, len = exports.names.length; i < len; i++) {
    if (exports.names[i].test(name)) {
      return true;
    }
  }
  return false;
}

/**
 * Coerce `val`.
 *
 * @param {Mixed} val
 * @return {Mixed}
 * @api private
 */

function coerce(val) {
  if (val instanceof Error) return val.stack || val.message;
  return val;
}

},{"ms":675}],528:[function(require,module,exports){
/*jshint browser:true, node:true*/

'use strict';

module.exports = Delegate;

/**
 * DOM event delegator
 *
 * The delegator will listen
 * for events that bubble up
 * to the root node.
 *
 * @constructor
 * @param {Node|string} [root] The root node or a selector string matching the root node
 */
function Delegate(root) {

  /**
   * Maintain a map of listener
   * lists, keyed by event name.
   *
   * @type Object
   */
  this.listenerMap = [{}, {}];
  if (root) {
    this.root(root);
  }

  /** @type function() */
  this.handle = Delegate.prototype.handle.bind(this);
}

/**
 * Start listening for events
 * on the provided DOM element
 *
 * @param  {Node|string} [root] The root node or a selector string matching the root node
 * @returns {Delegate} This method is chainable
 */
Delegate.prototype.root = function(root) {
  var listenerMap = this.listenerMap;
  var eventType;

  // Remove master event listeners
  if (this.rootElement) {
    for (eventType in listenerMap[1]) {
      if (listenerMap[1].hasOwnProperty(eventType)) {
        this.rootElement.removeEventListener(eventType, this.handle, true);
      }
    }
    for (eventType in listenerMap[0]) {
      if (listenerMap[0].hasOwnProperty(eventType)) {
        this.rootElement.removeEventListener(eventType, this.handle, false);
      }
    }
  }

  // If no root or root is not
  // a dom node, then remove internal
  // root reference and exit here
  if (!root || !root.addEventListener) {
    if (this.rootElement) {
      delete this.rootElement;
    }
    return this;
  }

  /**
   * The root node at which
   * listeners are attached.
   *
   * @type Node
   */
  this.rootElement = root;

  // Set up master event listeners
  for (eventType in listenerMap[1]) {
    if (listenerMap[1].hasOwnProperty(eventType)) {
      this.rootElement.addEventListener(eventType, this.handle, true);
    }
  }
  for (eventType in listenerMap[0]) {
    if (listenerMap[0].hasOwnProperty(eventType)) {
      this.rootElement.addEventListener(eventType, this.handle, false);
    }
  }

  return this;
};

/**
 * @param {string} eventType
 * @returns boolean
 */
Delegate.prototype.captureForType = function(eventType) {
  return ['blur', 'error', 'focus', 'load', 'resize', 'scroll'].indexOf(eventType) !== -1;
};

/**
 * Attach a handler to one
 * event for all elements
 * that match the selector,
 * now or in the future
 *
 * The handler function receives
 * three arguments: the DOM event
 * object, the node that matched
 * the selector while the event
 * was bubbling and a reference
 * to itself. Within the handler,
 * 'this' is equal to the second
 * argument.
 *
 * The node that actually received
 * the event can be accessed via
 * 'event.target'.
 *
 * @param {string} eventType Listen for these events
 * @param {string|undefined} selector Only handle events on elements matching this selector, if undefined match root element
 * @param {function()} handler Handler function - event data passed here will be in event.data
 * @param {Object} [eventData] Data to pass in event.data
 * @returns {Delegate} This method is chainable
 */
Delegate.prototype.on = function(eventType, selector, handler, useCapture) {
  var root, listenerMap, matcher, matcherParam;

  if (!eventType) {
    throw new TypeError('Invalid event type: ' + eventType);
  }

  // handler can be passed as
  // the second or third argument
  if (typeof selector === 'function') {
    useCapture = handler;
    handler = selector;
    selector = null;
  }

  // Fallback to sensible defaults
  // if useCapture not set
  if (useCapture === undefined) {
    useCapture = this.captureForType(eventType);
  }

  if (typeof handler !== 'function') {
    throw new TypeError('Handler must be a type of Function');
  }

  root = this.rootElement;
  listenerMap = this.listenerMap[useCapture ? 1 : 0];

  // Add master handler for type if not created yet
  if (!listenerMap[eventType]) {
    if (root) {
      root.addEventListener(eventType, this.handle, useCapture);
    }
    listenerMap[eventType] = [];
  }

  if (!selector) {
    matcherParam = null;

    // COMPLEX - matchesRoot needs to have access to
    // this.rootElement, so bind the function to this.
    matcher = matchesRoot.bind(this);

  // Compile a matcher for the given selector
  } else if (/^[a-z]+$/i.test(selector)) {
    matcherParam = selector;
    matcher = matchesTag;
  } else if (/^#[a-z0-9\-_]+$/i.test(selector)) {
    matcherParam = selector.slice(1);
    matcher = matchesId;
  } else {
    matcherParam = selector;
    matcher = matches;
  }

  // Add to the list of listeners
  listenerMap[eventType].push({
    selector: selector,
    handler: handler,
    matcher: matcher,
    matcherParam: matcherParam
  });

  return this;
};

/**
 * Remove an event handler
 * for elements that match
 * the selector, forever
 *
 * @param {string} [eventType] Remove handlers for events matching this type, considering the other parameters
 * @param {string} [selector] If this parameter is omitted, only handlers which match the other two will be removed
 * @param {function()} [handler] If this parameter is omitted, only handlers which match the previous two will be removed
 * @returns {Delegate} This method is chainable
 */
Delegate.prototype.off = function(eventType, selector, handler, useCapture) {
  var i, listener, listenerMap, listenerList, singleEventType;

  // Handler can be passed as
  // the second or third argument
  if (typeof selector === 'function') {
    useCapture = handler;
    handler = selector;
    selector = null;
  }

  // If useCapture not set, remove
  // all event listeners
  if (useCapture === undefined) {
    this.off(eventType, selector, handler, true);
    this.off(eventType, selector, handler, false);
    return this;
  }

  listenerMap = this.listenerMap[useCapture ? 1 : 0];
  if (!eventType) {
    for (singleEventType in listenerMap) {
      if (listenerMap.hasOwnProperty(singleEventType)) {
        this.off(singleEventType, selector, handler);
      }
    }

    return this;
  }

  listenerList = listenerMap[eventType];
  if (!listenerList || !listenerList.length) {
    return this;
  }

  // Remove only parameter matches
  // if specified
  for (i = listenerList.length - 1; i >= 0; i--) {
    listener = listenerList[i];

    if ((!selector || selector === listener.selector) && (!handler || handler === listener.handler)) {
      listenerList.splice(i, 1);
    }
  }

  // All listeners removed
  if (!listenerList.length) {
    delete listenerMap[eventType];

    // Remove the main handler
    if (this.rootElement) {
      this.rootElement.removeEventListener(eventType, this.handle, useCapture);
    }
  }

  return this;
};


/**
 * Handle an arbitrary event.
 *
 * @param {Event} event
 */
Delegate.prototype.handle = function(event) {
  var i, l, type = event.type, root, phase, listener, returned, listenerList = [], target, /** @const */ EVENTIGNORE = 'ftLabsDelegateIgnore';

  if (event[EVENTIGNORE] === true) {
    return;
  }

  target = event.target;

  // Hardcode value of Node.TEXT_NODE
  // as not defined in IE8
  if (target.nodeType === 3) {
    target = target.parentNode;
  }

  root = this.rootElement;

  phase = event.eventPhase || ( event.target !== event.currentTarget ? 3 : 2 );

  switch (phase) {
    case 1: //Event.CAPTURING_PHASE:
      listenerList = this.listenerMap[1][type];
    break;
    case 2: //Event.AT_TARGET:
      if (this.listenerMap[0] && this.listenerMap[0][type]) listenerList = listenerList.concat(this.listenerMap[0][type]);
      if (this.listenerMap[1] && this.listenerMap[1][type]) listenerList = listenerList.concat(this.listenerMap[1][type]);
    break;
    case 3: //Event.BUBBLING_PHASE:
      listenerList = this.listenerMap[0][type];
    break;
  }

  // Need to continuously check
  // that the specific list is
  // still populated in case one
  // of the callbacks actually
  // causes the list to be destroyed.
  l = listenerList.length;
  while (target && l) {
    for (i = 0; i < l; i++) {
      listener = listenerList[i];

      // Bail from this loop if
      // the length changed and
      // no more listeners are
      // defined between i and l.
      if (!listener) {
        break;
      }

      // Check for match and fire
      // the event if there's one
      //
      // TODO:MCG:20120117: Need a way
      // to check if event#stopImmediatePropagation
      // was called. If so, break both loops.
      if (listener.matcher.call(target, listener.matcherParam, target)) {
        returned = this.fire(event, target, listener);
      }

      // Stop propagation to subsequent
      // callbacks if the callback returned
      // false
      if (returned === false) {
        event[EVENTIGNORE] = true;
        event.preventDefault();
        return;
      }
    }

    // TODO:MCG:20120117: Need a way to
    // check if event#stopPropagation
    // was called. If so, break looping
    // through the DOM. Stop if the
    // delegation root has been reached
    if (target === root) {
      break;
    }

    l = listenerList.length;
    target = target.parentElement;
  }
};

/**
 * Fire a listener on a target.
 *
 * @param {Event} event
 * @param {Node} target
 * @param {Object} listener
 * @returns {boolean}
 */
Delegate.prototype.fire = function(event, target, listener) {
  return listener.handler.call(target, event, target);
};

/**
 * Check whether an element
 * matches a generic selector.
 *
 * @type function()
 * @param {string} selector A CSS selector
 */
var matches = (function(el) {
  if (!el) return;
  var p = el.prototype;
  return (p.matches || p.matchesSelector || p.webkitMatchesSelector || p.mozMatchesSelector || p.msMatchesSelector || p.oMatchesSelector);
}(Element));

/**
 * Check whether an element
 * matches a tag selector.
 *
 * Tags are NOT case-sensitive,
 * except in XML (and XML-based
 * languages such as XHTML).
 *
 * @param {string} tagName The tag name to test against
 * @param {Element} element The element to test with
 * @returns boolean
 */
function matchesTag(tagName, element) {
  return tagName.toLowerCase() === element.tagName.toLowerCase();
}

/**
 * Check whether an element
 * matches the root.
 *
 * @param {?String} selector In this case this is always passed through as null and not used
 * @param {Element} element The element to test with
 * @returns boolean
 */
function matchesRoot(selector, element) {
  /*jshint validthis:true*/
  if (this.rootElement === window) return element === document;
  return this.rootElement === element;
}

/**
 * Check whether the ID of
 * the element in 'this'
 * matches the given ID.
 *
 * IDs are case-sensitive.
 *
 * @param {string} id The ID to test against
 * @param {Element} element The element to test with
 * @returns boolean
 */
function matchesId(id, element) {
  return id === element.id;
}

/**
 * Short hand for off()
 * and root(), ie both
 * with no parameters
 *
 * @return void
 */
Delegate.prototype.destroy = function() {
  this.off();
  this.root();
};

},{}],529:[function(require,module,exports){
/*jshint browser:true, node:true*/

'use strict';

/**
 * @preserve Create and manage a DOM event delegator.
 *
 * @version 0.3.0
 * @codingstandard ftlabs-jsv2
 * @copyright The Financial Times Limited [All Rights Reserved]
 * @license MIT License (see LICENSE.txt)
 */
var Delegate = require('./delegate');

module.exports = function(root) {
  return new Delegate(root);
};

module.exports.Delegate = Delegate;

},{"./delegate":528}],530:[function(require,module,exports){
/*!
 * escape-html
 * Copyright(c) 2012-2013 TJ Holowaychuk
 * Copyright(c) 2015 Andreas Lubbe
 * Copyright(c) 2015 Tiancheng "Timothy" Gu
 * MIT Licensed
 */

'use strict';

/**
 * Module variables.
 * @private
 */

var matchHtmlRegExp = /["'&<>]/;

/**
 * Module exports.
 * @public
 */

module.exports = escapeHtml;

/**
 * Escape special characters in the given string of html.
 *
 * @param  {string} string The string to escape for inserting into HTML
 * @return {string}
 * @public
 */

function escapeHtml(string) {
  var str = '' + string;
  var match = matchHtmlRegExp.exec(str);

  if (!match) {
    return str;
  }

  var escape;
  var html = '';
  var index = 0;
  var lastIndex = 0;

  for (index = match.index; index < str.length; index++) {
    switch (str.charCodeAt(index)) {
      case 34: // "
        escape = '&quot;';
        break;
      case 38: // &
        escape = '&amp;';
        break;
      case 39: // '
        escape = '&#39;';
        break;
      case 60: // <
        escape = '&lt;';
        break;
      case 62: // >
        escape = '&gt;';
        break;
      default:
        continue;
    }

    if (lastIndex !== index) {
      html += str.substring(lastIndex, index);
    }

    lastIndex = index + 1;
    html += escape;
  }

  return lastIndex !== index
    ? html + str.substring(lastIndex, index)
    : html;
}

},{}],531:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      }
      throw TypeError('Uncaught, unspecified "error" event.');
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],532:[function(require,module,exports){
var hasOwn = Object.prototype.hasOwnProperty;
var toStr = Object.prototype.toString;
var undefined;

var isArray = function isArray(arr) {
	if (typeof Array.isArray === 'function') {
		return Array.isArray(arr);
	}

	return toStr.call(arr) === '[object Array]';
};

var isPlainObject = function isPlainObject(obj) {
	'use strict';
	if (!obj || toStr.call(obj) !== '[object Object]') {
		return false;
	}

	var has_own_constructor = hasOwn.call(obj, 'constructor');
	var has_is_property_of_method = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');
	// Not own constructor property must be Object
	if (obj.constructor && !has_own_constructor && !has_is_property_of_method) {
		return false;
	}

	// Own properties are enumerated firstly, so to speed up,
	// if last one is own, then all properties are own.
	var key;
	for (key in obj) {}

	return key === undefined || hasOwn.call(obj, key);
};

module.exports = function extend() {
	'use strict';
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[0],
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if (typeof target === 'boolean') {
		deep = target;
		target = arguments[1] || {};
		// skip the boolean and the target
		i = 2;
	} else if ((typeof target !== 'object' && typeof target !== 'function') || target == null) {
		target = {};
	}

	for (; i < length; ++i) {
		options = arguments[i];
		// Only deal with non-null/undefined values
		if (options != null) {
			// Extend the base object
			for (name in options) {
				src = target[name];
				copy = options[name];

				// Prevent never-ending loop
				if (target === copy) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray(copy)))) {
					if (copyIsArray) {
						copyIsArray = false;
						clone = src && isArray(src) ? src : [];
					} else {
						clone = src && isPlainObject(src) ? src : {};
					}

					// Never move original objects, clone them
					target[name] = extend(deep, clone, copy);

				// Don't bring in undefined values
				} else if (copy !== undefined) {
					target[name] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};


},{}],533:[function(require,module,exports){
/*
Finally
*/'use strict';

var prime = require('prime');

var kindOf = require('mout/lang/kindOf');
var map = require('mout/array/map');
var slice = require('mout/array/slice');
var forEach = require('mout/array/forEach');
var reduce = require('mout/array/reduce');

var each = require('mout/collection/forEach');
var cmap = require('mout/collection/map');

var push_ = Array.prototype.push;

/* create the flow */
var Flow = prime({

  /* options */
  constructor: function Flow() {
    this._seq = [];
  },

  /* add steps to the flow */
  then: function() {
    this._push(this._callbacks(arguments));
    return this;
  },

  _parallel: function(parallel, args) {
    var self = this;
    return function() {
      var control = new Controller(self, self._index++);
      self._controls.push(control);
      parallel.apply(control, args ? args.concat(slice(arguments)) : arguments);
    };
  },

  _push: function(parallels, args) {
    if (!parallels.length) return;
    this._seq.push(map(parallels, function(parallel) {
      return this._parallel(parallel, args);
    }, this));
  },

  _callbacks: function(callbacks) {
    return reduce(callbacks, function(a, b) {
      if (kindOf(b) === 'Array') push_.apply(a, b);
      else a.push(b);
      return a;
    }, []);
  },

  /* will make a sequential entry for each entry in the object */
  sequential: function(object) {
    var callbacks = this._callbacks(slice(arguments, 1));
    each(object, function(value, key) {
      this._push(callbacks, [value, key]);
    }, this);
    return this;
  },

  /* will make a single sequential entry with one parallel for each entry in the object */
  parallel: function(object, parallel) {
    var parallels = cmap(object, function(value, key) {
      return this._parallel(parallel, [value, key]);
    }, this);
    if (parallels.length) this._seq.push(parallels);
    return this;
  },

  /* assign last step and execute the flow */
  finally: function() {
    this.then.apply(this, arguments);
    this._continue.call(this);
    return this;
  },

  /* execute the flow with arguments to the first step */
  run: function() {
    this._continue.apply(this, arguments);
    return this;
  },

  // private

  _break: function() {
    this._seq.splice(0, this._seq.length - 1);
    this._continue.apply(this, arguments);
  },

  _spread: function(error, args) {
    var seq = this._next();
    if (!seq || !(seq = seq[0])) return;
    if (!args || !args.length) args = [undefined];
    this._length = args.length;
    forEach(args, function(arg) {
      seq(error, arg);
    });
  },

  _continue: function() {
    var seq = this._next();
    if (!seq) return;
    this._length = seq.length;
    var args = arguments;
    forEach(seq, function(parallel) {
      parallel.apply(null, args);
    });
  },

  _next: function() {
    var seq = this._seq.shift();
    if (!seq) return;

    if (this._controls) forEach(this._controls, function(control) { // kill old controls
      control._kill();
    });

    // reset variables

    this._arguments = [];
    this._errors = [];
    this._controls = [];
    this._index = 0;

    return seq;
  },

  _done: function(index, error, data) {
    this._arguments[index] = data;
    if (error) this._errors.push(error);
    if (!--this._length) {
      var errors = null;
      if (this._errors.length === 1) errors = this._errors[0];
      else if (this._errors.length) errors = new Error(map(this._errors, function(e) {
        return e.message;
      }).join('\n'));
      this._continue.apply(this, [errors].concat(this._arguments));
    }
    else this._controls[index]._kill();
  }

});

/* control the flow */
var Controller = function Controller(flow, index) {

  var dead;

  this._kill = function() {
    dead = true;
  };

  /* break the flow */
  this.break = function() {
    if (!dead) flow._break.apply(flow, arguments);
  };

  /* step in the next sequential */
  this.continue = function() {
    if (!dead) flow._continue.apply(flow, arguments);
  };

  /* spread results to the next sequential */
  this.spread = function(error, args) {
    if (!dead) flow._spread(error, args);
  };

  /* set the the current parallel in the sequential as complete */
  var done = this.done = function(error, data) {
    if (!dead) flow._done.call(flow, index, error, data);
  };

};

/* public interface */
module.exports = function() {
  var flow = new Flow();
  flow.then.apply(flow, arguments);
  return flow;
};

},{"mout/array/forEach":534,"mout/array/map":535,"mout/array/reduce":536,"mout/array/slice":537,"mout/collection/forEach":538,"mout/collection/map":540,"mout/lang/kindOf":548,"prime":555}],534:[function(require,module,exports){


    /**
     * Array forEach
     */
    function forEach(arr, callback, thisObj) {
        if (arr == null) {
            return;
        }
        var i = -1,
            len = arr.length;
        while (++i < len) {
            // we iterate over sparse items since there is no way to make it
            // work properly on IE 7-8. see #64
            if ( callback.call(thisObj, arr[i], i, arr) === false ) {
                break;
            }
        }
    }

    module.exports = forEach;



},{}],535:[function(require,module,exports){
var makeIterator = require('../function/makeIterator_');

    /**
     * Array map
     */
    function map(arr, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        var results = [];
        if (arr == null){
            return results;
        }

        var i = -1, len = arr.length;
        while (++i < len) {
            results[i] = callback(arr[i], i, arr);
        }

        return results;
    }

     module.exports = map;


},{"../function/makeIterator_":542}],536:[function(require,module,exports){


    /**
     * Array reduce
     */
    function reduce(arr, fn, initVal) {
        // check for args.length since initVal might be "undefined" see #gh-57
        var hasInit = arguments.length > 2,
            result = initVal;

        if (arr == null || !arr.length) {
            if (!hasInit) {
                throw new Error('reduce of empty array with no initial value');
            } else {
                return initVal;
            }
        }

        var i = -1, len = arr.length;
        while (++i < len) {
            if (!hasInit) {
                result = arr[i];
                hasInit = true;
            } else {
                result = fn(result, arr[i], i, arr);
            }
        }

        return result;
    }

    module.exports = reduce;


},{}],537:[function(require,module,exports){


    /**
     * Create slice of source array or array-like object
     */
    function slice(arr, start, end){
        var len = arr.length;

        if (start == null) {
            start = 0;
        } else if (start < 0) {
            start = Math.max(len + start, 0);
        } else {
            start = Math.min(start, len);
        }

        if (end == null) {
            end = len;
        } else if (end < 0) {
            end = Math.max(len + end, 0);
        } else {
            end = Math.min(end, len);
        }

        var result = [];
        while (start < end) {
            result.push(arr[start++]);
        }

        return result;
    }

    module.exports = slice;



},{}],538:[function(require,module,exports){
var make = require('./make_');
var arrForEach = require('../array/forEach');
var objForEach = require('../object/forOwn');

    /**
     */
    module.exports = make(arrForEach, objForEach);



},{"../array/forEach":534,"../object/forOwn":551,"./make_":539}],539:[function(require,module,exports){
var slice = require('../array/slice');

    /**
     * internal method used to create other collection modules.
     */
    function makeCollectionMethod(arrMethod, objMethod, defaultReturn) {
        return function(){
            var args = slice(arguments);
            if (args[0] == null) {
                return defaultReturn;
            }
            // array-like is treated as array
            return (typeof args[0].length === 'number')? arrMethod.apply(null, args) : objMethod.apply(null, args);
        };
    }

    module.exports = makeCollectionMethod;



},{"../array/slice":537}],540:[function(require,module,exports){
var isObject = require('../lang/isObject');
var values = require('../object/values');
var arrMap = require('../array/map');
var makeIterator = require('../function/makeIterator_');

    /**
     * Map collection values, returns Array.
     */
    function map(list, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        // list.length to check array-like object, if not array-like
        // we simply map all the object values
        if( isObject(list) && list.length == null ){
            list = values(list);
        }
        return arrMap(list, function (val, key, list) {
            return callback(val, key, list);
        });
    }

    module.exports = map;



},{"../array/map":535,"../function/makeIterator_":542,"../lang/isObject":547,"../object/values":554}],541:[function(require,module,exports){


    /**
     * Returns the first argument provided to it.
     */
    function identity(val){
        return val;
    }

    module.exports = identity;



},{}],542:[function(require,module,exports){
var identity = require('./identity');
var prop = require('./prop');
var deepMatches = require('../object/deepMatches');

    /**
     * Converts argument into a valid iterator.
     * Used internally on most array/object/collection methods that receives a
     * callback/iterator providing a shortcut syntax.
     */
    function makeIterator(src, thisObj){
        if (src == null) {
            return identity;
        }
        switch(typeof src) {
            case 'function':
                // function is the first to improve perf (most common case)
                // also avoid using `Function#call` if not needed, which boosts
                // perf a lot in some cases
                return (typeof thisObj !== 'undefined')? function(val, i, arr){
                    return src.call(thisObj, val, i, arr);
                } : src;
            case 'object':
                return function(val){
                    return deepMatches(val, src);
                };
            case 'string':
            case 'number':
                return prop(src);
        }
    }

    module.exports = makeIterator;



},{"../object/deepMatches":549,"./identity":541,"./prop":543}],543:[function(require,module,exports){


    /**
     * Returns a function that gets a property of the passed object
     */
    function prop(name){
        return function(obj){
            return obj[name];
        };
    }

    module.exports = prop;



},{}],544:[function(require,module,exports){
var mixIn = require('../object/mixIn');

    /**
     * Create Object using prototypal inheritance and setting custom properties.
     * - Mix between Douglas Crockford Prototypal Inheritance <http://javascript.crockford.com/prototypal.html> and the EcmaScript 5 `Object.create()` method.
     * @param {object} parent    Parent Object.
     * @param {object} [props] Object properties.
     * @return {object} Created object.
     */
    function createObject(parent, props){
        function F(){}
        F.prototype = parent;
        return mixIn(new F(), props);

    }
    module.exports = createObject;



},{"../object/mixIn":553}],545:[function(require,module,exports){
var isKind = require('./isKind');
    /**
     */
    var isArray = Array.isArray || function (val) {
        return isKind(val, 'Array');
    };
    module.exports = isArray;


},{"./isKind":546}],546:[function(require,module,exports){
var kindOf = require('./kindOf');
    /**
     * Check if value is from a specific "kind".
     */
    function isKind(val, kind){
        return kindOf(val) === kind;
    }
    module.exports = isKind;


},{"./kindOf":548}],547:[function(require,module,exports){
var isKind = require('./isKind');
    /**
     */
    function isObject(val) {
        return isKind(val, 'Object');
    }
    module.exports = isObject;


},{"./isKind":546}],548:[function(require,module,exports){


    var _rKind = /^\[object (.*)\]$/,
        _toString = Object.prototype.toString,
        UNDEF;

    /**
     * Gets the "kind" of value. (e.g. "String", "Number", etc)
     */
    function kindOf(val) {
        if (val === null) {
            return 'Null';
        } else if (val === UNDEF) {
            return 'Undefined';
        } else {
            return _rKind.exec( _toString.call(val) )[1];
        }
    }
    module.exports = kindOf;


},{}],549:[function(require,module,exports){
var forOwn = require('./forOwn');
var isArray = require('../lang/isArray');

    function containsMatch(array, pattern) {
        var i = -1, length = array.length;
        while (++i < length) {
            if (deepMatches(array[i], pattern)) {
                return true;
            }
        }

        return false;
    }

    function matchArray(target, pattern) {
        var i = -1, patternLength = pattern.length;
        while (++i < patternLength) {
            if (!containsMatch(target, pattern[i])) {
                return false;
            }
        }

        return true;
    }

    function matchObject(target, pattern) {
        var result = true;
        forOwn(pattern, function(val, key) {
            if (!deepMatches(target[key], val)) {
                // Return false to break out of forOwn early
                return (result = false);
            }
        });

        return result;
    }

    /**
     * Recursively check if the objects match.
     */
    function deepMatches(target, pattern){
        if (target && typeof target === 'object') {
            if (isArray(target) && isArray(pattern)) {
                return matchArray(target, pattern);
            } else {
                return matchObject(target, pattern);
            }
        } else {
            return target === pattern;
        }
    }

    module.exports = deepMatches;



},{"../lang/isArray":545,"./forOwn":551}],550:[function(require,module,exports){
var hasOwn = require('./hasOwn');

    var _hasDontEnumBug,
        _dontEnums;

    function checkDontEnum(){
        _dontEnums = [
                'toString',
                'toLocaleString',
                'valueOf',
                'hasOwnProperty',
                'isPrototypeOf',
                'propertyIsEnumerable',
                'constructor'
            ];

        _hasDontEnumBug = true;

        for (var key in {'toString': null}) {
            _hasDontEnumBug = false;
        }
    }

    /**
     * Similar to Array/forEach but works over object properties and fixes Don't
     * Enum bug on IE.
     * based on: http://whattheheadsaid.com/2010/10/a-safer-object-keys-compatibility-implementation
     */
    function forIn(obj, fn, thisObj){
        var key, i = 0;
        // no need to check if argument is a real object that way we can use
        // it for arrays, functions, date, etc.

        //post-pone check till needed
        if (_hasDontEnumBug == null) checkDontEnum();

        for (key in obj) {
            if (exec(fn, obj, key, thisObj) === false) {
                break;
            }
        }


        if (_hasDontEnumBug) {
            var ctor = obj.constructor,
                isProto = !!ctor && obj === ctor.prototype;

            while (key = _dontEnums[i++]) {
                // For constructor, if it is a prototype object the constructor
                // is always non-enumerable unless defined otherwise (and
                // enumerated above).  For non-prototype objects, it will have
                // to be defined on this object, since it cannot be defined on
                // any prototype objects.
                //
                // For other [[DontEnum]] properties, check if the value is
                // different than Object prototype value.
                if (
                    (key !== 'constructor' ||
                        (!isProto && hasOwn(obj, key))) &&
                    obj[key] !== Object.prototype[key]
                ) {
                    if (exec(fn, obj, key, thisObj) === false) {
                        break;
                    }
                }
            }
        }
    }

    function exec(fn, obj, key, thisObj){
        return fn.call(thisObj, obj[key], key, obj);
    }

    module.exports = forIn;



},{"./hasOwn":552}],551:[function(require,module,exports){
var hasOwn = require('./hasOwn');
var forIn = require('./forIn');

    /**
     * Similar to Array/forEach but works over object properties and fixes Don't
     * Enum bug on IE.
     * based on: http://whattheheadsaid.com/2010/10/a-safer-object-keys-compatibility-implementation
     */
    function forOwn(obj, fn, thisObj){
        forIn(obj, function(val, key){
            if (hasOwn(obj, key)) {
                return fn.call(thisObj, obj[key], key, obj);
            }
        });
    }

    module.exports = forOwn;



},{"./forIn":550,"./hasOwn":552}],552:[function(require,module,exports){


    /**
     * Safer Object.hasOwnProperty
     */
     function hasOwn(obj, prop){
         return Object.prototype.hasOwnProperty.call(obj, prop);
     }

     module.exports = hasOwn;



},{}],553:[function(require,module,exports){
var forOwn = require('./forOwn');

    /**
    * Combine properties from all the objects into first one.
    * - This method affects target object in place, if you want to create a new Object pass an empty object as first param.
    * @param {object} target    Target Object
    * @param {...object} objects    Objects to be combined (0...n objects).
    * @return {object} Target Object.
    */
    function mixIn(target, objects){
        var i = 0,
            n = arguments.length,
            obj;
        while(++i < n){
            obj = arguments[i];
            if (obj != null) {
                forOwn(obj, copyProp, target);
            }
        }
        return target;
    }

    function copyProp(val, key){
        this[key] = val;
    }

    module.exports = mixIn;


},{"./forOwn":551}],554:[function(require,module,exports){
var forOwn = require('./forOwn');

    /**
     * Get object values
     */
    function values(obj) {
        var vals = [];
        forOwn(obj, function(val, key){
            vals.push(val);
        });
        return vals;
    }

    module.exports = values;



},{"./forOwn":551}],555:[function(require,module,exports){
/*
prime
 - prototypal inheritance
*/"use strict"

var hasOwn = require("mout/object/hasOwn"),
    mixIn  = require("mout/object/mixIn"),
    create = require("mout/lang/createObject"),
    kindOf = require("mout/lang/kindOf")

var hasDescriptors = true

try {
    Object.defineProperty({}, "~", {})
    Object.getOwnPropertyDescriptor({}, "~")
} catch (e){
    hasDescriptors = false
}

// we only need to be able to implement "toString" and "valueOf" in IE < 9
var hasEnumBug = !({valueOf: 0}).propertyIsEnumerable("valueOf"),
    buggy      = ["toString", "valueOf"]

var verbs = /^constructor|inherits|mixin$/

var implement = function(proto){
    var prototype = this.prototype

    for (var key in proto){
        if (key.match(verbs)) continue
        if (hasDescriptors){
            var descriptor = Object.getOwnPropertyDescriptor(proto, key)
            if (descriptor){
                Object.defineProperty(prototype, key, descriptor)
                continue
            }
        }
        prototype[key] = proto[key]
    }

    if (hasEnumBug) for (var i = 0; (key = buggy[i]); i++){
        var value = proto[key]
        if (value !== Object.prototype[key]) prototype[key] = value
    }

    return this
}

var prime = function(proto){

    if (kindOf(proto) === "Function") proto = {constructor: proto}

    var superprime = proto.inherits

    // if our nice proto object has no own constructor property
    // then we proceed using a ghosting constructor that all it does is
    // call the parent's constructor if it has a superprime, else an empty constructor
    // proto.constructor becomes the effective constructor
    var constructor = (hasOwn(proto, "constructor")) ? proto.constructor : (superprime) ? function(){
        return superprime.apply(this, arguments)
    } : function(){}

    if (superprime){

        mixIn(constructor, superprime)

        var superproto = superprime.prototype
        // inherit from superprime
        var cproto = constructor.prototype = create(superproto)

        // setting constructor.parent to superprime.prototype
        // because it's the shortest possible absolute reference
        constructor.parent = superproto
        cproto.constructor = constructor
    }

    if (!constructor.implement) constructor.implement = implement

    var mixins = proto.mixin
    if (mixins){
        if (kindOf(mixins) !== "Array") mixins = [mixins]
        for (var i = 0; i < mixins.length; i++) constructor.implement(create(mixins[i].prototype))
    }

    // implement proto and return constructor
    return constructor.implement(proto)

}

module.exports = prime

},{"mout/lang/createObject":544,"mout/lang/kindOf":548,"mout/object/hasOwn":552,"mout/object/mixIn":553}],556:[function(require,module,exports){
"use strict";
/*globals Handlebars: true */
var base = require("./handlebars/base");

// Each of these augment the Handlebars object. No need to setup here.
// (This is done to easily share code between commonjs and browse envs)
var SafeString = require("./handlebars/safe-string")["default"];
var Exception = require("./handlebars/exception")["default"];
var Utils = require("./handlebars/utils");
var runtime = require("./handlebars/runtime");

// For compatibility and usage outside of module systems, make the Handlebars object a namespace
var create = function() {
  var hb = new base.HandlebarsEnvironment();

  Utils.extend(hb, base);
  hb.SafeString = SafeString;
  hb.Exception = Exception;
  hb.Utils = Utils;

  hb.VM = runtime;
  hb.template = function(spec) {
    return runtime.template(spec, hb);
  };

  return hb;
};

var Handlebars = create();
Handlebars.create = create;

exports["default"] = Handlebars;
},{"./handlebars/base":557,"./handlebars/exception":558,"./handlebars/runtime":559,"./handlebars/safe-string":560,"./handlebars/utils":561}],557:[function(require,module,exports){
"use strict";
var Utils = require("./utils");
var Exception = require("./exception")["default"];

var VERSION = "1.3.0";
exports.VERSION = VERSION;var COMPILER_REVISION = 4;
exports.COMPILER_REVISION = COMPILER_REVISION;
var REVISION_CHANGES = {
  1: '<= 1.0.rc.2', // 1.0.rc.2 is actually rev2 but doesn't report it
  2: '== 1.0.0-rc.3',
  3: '== 1.0.0-rc.4',
  4: '>= 1.0.0'
};
exports.REVISION_CHANGES = REVISION_CHANGES;
var isArray = Utils.isArray,
    isFunction = Utils.isFunction,
    toString = Utils.toString,
    objectType = '[object Object]';

function HandlebarsEnvironment(helpers, partials) {
  this.helpers = helpers || {};
  this.partials = partials || {};

  registerDefaultHelpers(this);
}

exports.HandlebarsEnvironment = HandlebarsEnvironment;HandlebarsEnvironment.prototype = {
  constructor: HandlebarsEnvironment,

  logger: logger,
  log: log,

  registerHelper: function(name, fn, inverse) {
    if (toString.call(name) === objectType) {
      if (inverse || fn) { throw new Exception('Arg not supported with multiple helpers'); }
      Utils.extend(this.helpers, name);
    } else {
      if (inverse) { fn.not = inverse; }
      this.helpers[name] = fn;
    }
  },

  registerPartial: function(name, str) {
    if (toString.call(name) === objectType) {
      Utils.extend(this.partials,  name);
    } else {
      this.partials[name] = str;
    }
  }
};

function registerDefaultHelpers(instance) {
  instance.registerHelper('helperMissing', function(arg) {
    if(arguments.length === 2) {
      return undefined;
    } else {
      throw new Exception("Missing helper: '" + arg + "'");
    }
  });

  instance.registerHelper('blockHelperMissing', function(context, options) {
    var inverse = options.inverse || function() {}, fn = options.fn;

    if (isFunction(context)) { context = context.call(this); }

    if(context === true) {
      return fn(this);
    } else if(context === false || context == null) {
      return inverse(this);
    } else if (isArray(context)) {
      if(context.length > 0) {
        return instance.helpers.each(context, options);
      } else {
        return inverse(this);
      }
    } else {
      return fn(context);
    }
  });

  instance.registerHelper('each', function(context, options) {
    var fn = options.fn, inverse = options.inverse;
    var i = 0, ret = "", data;

    if (isFunction(context)) { context = context.call(this); }

    if (options.data) {
      data = createFrame(options.data);
    }

    if(context && typeof context === 'object') {
      if (isArray(context)) {
        for(var j = context.length; i<j; i++) {
          if (data) {
            data.index = i;
            data.first = (i === 0);
            data.last  = (i === (context.length-1));
          }
          ret = ret + fn(context[i], { data: data });
        }
      } else {
        for(var key in context) {
          if(context.hasOwnProperty(key)) {
            if(data) {
              data.key = key;
              data.index = i;
              data.first = (i === 0);
            }
            ret = ret + fn(context[key], {data: data});
            i++;
          }
        }
      }
    }

    if(i === 0){
      ret = inverse(this);
    }

    return ret;
  });

  instance.registerHelper('if', function(conditional, options) {
    if (isFunction(conditional)) { conditional = conditional.call(this); }

    // Default behavior is to render the positive path if the value is truthy and not empty.
    // The `includeZero` option may be set to treat the condtional as purely not empty based on the
    // behavior of isEmpty. Effectively this determines if 0 is handled by the positive path or negative.
    if ((!options.hash.includeZero && !conditional) || Utils.isEmpty(conditional)) {
      return options.inverse(this);
    } else {
      return options.fn(this);
    }
  });

  instance.registerHelper('unless', function(conditional, options) {
    return instance.helpers['if'].call(this, conditional, {fn: options.inverse, inverse: options.fn, hash: options.hash});
  });

  instance.registerHelper('with', function(context, options) {
    if (isFunction(context)) { context = context.call(this); }

    if (!Utils.isEmpty(context)) return options.fn(context);
  });

  instance.registerHelper('log', function(context, options) {
    var level = options.data && options.data.level != null ? parseInt(options.data.level, 10) : 1;
    instance.log(level, context);
  });
}

var logger = {
  methodMap: { 0: 'debug', 1: 'info', 2: 'warn', 3: 'error' },

  // State enum
  DEBUG: 0,
  INFO: 1,
  WARN: 2,
  ERROR: 3,
  level: 3,

  // can be overridden in the host environment
  log: function(level, obj) {
    if (logger.level <= level) {
      var method = logger.methodMap[level];
      if (typeof console !== 'undefined' && console[method]) {
        console[method].call(console, obj);
      }
    }
  }
};
exports.logger = logger;
function log(level, obj) { logger.log(level, obj); }

exports.log = log;var createFrame = function(object) {
  var obj = {};
  Utils.extend(obj, object);
  return obj;
};
exports.createFrame = createFrame;
},{"./exception":558,"./utils":561}],558:[function(require,module,exports){
"use strict";

var errorProps = ['description', 'fileName', 'lineNumber', 'message', 'name', 'number', 'stack'];

function Exception(message, node) {
  var line;
  if (node && node.firstLine) {
    line = node.firstLine;

    message += ' - ' + line + ':' + node.firstColumn;
  }

  var tmp = Error.prototype.constructor.call(this, message);

  // Unfortunately errors are not enumerable in Chrome (at least), so `for prop in tmp` doesn't work.
  for (var idx = 0; idx < errorProps.length; idx++) {
    this[errorProps[idx]] = tmp[errorProps[idx]];
  }

  if (line) {
    this.lineNumber = line;
    this.column = node.firstColumn;
  }
}

Exception.prototype = new Error();

exports["default"] = Exception;
},{}],559:[function(require,module,exports){
"use strict";
var Utils = require("./utils");
var Exception = require("./exception")["default"];
var COMPILER_REVISION = require("./base").COMPILER_REVISION;
var REVISION_CHANGES = require("./base").REVISION_CHANGES;

function checkRevision(compilerInfo) {
  var compilerRevision = compilerInfo && compilerInfo[0] || 1,
      currentRevision = COMPILER_REVISION;

  if (compilerRevision !== currentRevision) {
    if (compilerRevision < currentRevision) {
      var runtimeVersions = REVISION_CHANGES[currentRevision],
          compilerVersions = REVISION_CHANGES[compilerRevision];
      throw new Exception("Template was precompiled with an older version of Handlebars than the current runtime. "+
            "Please update your precompiler to a newer version ("+runtimeVersions+") or downgrade your runtime to an older version ("+compilerVersions+").");
    } else {
      // Use the embedded version info since the runtime doesn't know about this revision yet
      throw new Exception("Template was precompiled with a newer version of Handlebars than the current runtime. "+
            "Please update your runtime to a newer version ("+compilerInfo[1]+").");
    }
  }
}

exports.checkRevision = checkRevision;// TODO: Remove this line and break up compilePartial

function template(templateSpec, env) {
  if (!env) {
    throw new Exception("No environment passed to template");
  }

  // Note: Using env.VM references rather than local var references throughout this section to allow
  // for external users to override these as psuedo-supported APIs.
  var invokePartialWrapper = function(partial, name, context, helpers, partials, data) {
    var result = env.VM.invokePartial.apply(this, arguments);
    if (result != null) { return result; }

    if (env.compile) {
      var options = { helpers: helpers, partials: partials, data: data };
      partials[name] = env.compile(partial, { data: data !== undefined }, env);
      return partials[name](context, options);
    } else {
      throw new Exception("The partial " + name + " could not be compiled when running in runtime-only mode");
    }
  };

  // Just add water
  var container = {
    escapeExpression: Utils.escapeExpression,
    invokePartial: invokePartialWrapper,
    programs: [],
    program: function(i, fn, data) {
      var programWrapper = this.programs[i];
      if(data) {
        programWrapper = program(i, fn, data);
      } else if (!programWrapper) {
        programWrapper = this.programs[i] = program(i, fn);
      }
      return programWrapper;
    },
    merge: function(param, common) {
      var ret = param || common;

      if (param && common && (param !== common)) {
        ret = {};
        Utils.extend(ret, common);
        Utils.extend(ret, param);
      }
      return ret;
    },
    programWithDepth: env.VM.programWithDepth,
    noop: env.VM.noop,
    compilerInfo: null
  };

  return function(context, options) {
    options = options || {};
    var namespace = options.partial ? options : env,
        helpers,
        partials;

    if (!options.partial) {
      helpers = options.helpers;
      partials = options.partials;
    }
    var result = templateSpec.call(
          container,
          namespace, context,
          helpers,
          partials,
          options.data);

    if (!options.partial) {
      env.VM.checkRevision(container.compilerInfo);
    }

    return result;
  };
}

exports.template = template;function programWithDepth(i, fn, data /*, $depth */) {
  var args = Array.prototype.slice.call(arguments, 3);

  var prog = function(context, options) {
    options = options || {};

    return fn.apply(this, [context, options.data || data].concat(args));
  };
  prog.program = i;
  prog.depth = args.length;
  return prog;
}

exports.programWithDepth = programWithDepth;function program(i, fn, data) {
  var prog = function(context, options) {
    options = options || {};

    return fn(context, options.data || data);
  };
  prog.program = i;
  prog.depth = 0;
  return prog;
}

exports.program = program;function invokePartial(partial, name, context, helpers, partials, data) {
  var options = { partial: true, helpers: helpers, partials: partials, data: data };

  if(partial === undefined) {
    throw new Exception("The partial " + name + " could not be found");
  } else if(partial instanceof Function) {
    return partial(context, options);
  }
}

exports.invokePartial = invokePartial;function noop() { return ""; }

exports.noop = noop;
},{"./base":557,"./exception":558,"./utils":561}],560:[function(require,module,exports){
"use strict";
// Build out our basic SafeString type
function SafeString(string) {
  this.string = string;
}

SafeString.prototype.toString = function() {
  return "" + this.string;
};

exports["default"] = SafeString;
},{}],561:[function(require,module,exports){
"use strict";
/*jshint -W004 */
var SafeString = require("./safe-string")["default"];

var escape = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#x27;",
  "`": "&#x60;"
};

var badChars = /[&<>"'`]/g;
var possible = /[&<>"'`]/;

function escapeChar(chr) {
  return escape[chr] || "&amp;";
}

function extend(obj, value) {
  for(var key in value) {
    if(Object.prototype.hasOwnProperty.call(value, key)) {
      obj[key] = value[key];
    }
  }
}

exports.extend = extend;var toString = Object.prototype.toString;
exports.toString = toString;
// Sourced from lodash
// https://github.com/bestiejs/lodash/blob/master/LICENSE.txt
var isFunction = function(value) {
  return typeof value === 'function';
};
// fallback for older versions of Chrome and Safari
if (isFunction(/x/)) {
  isFunction = function(value) {
    return typeof value === 'function' && toString.call(value) === '[object Function]';
  };
}
var isFunction;
exports.isFunction = isFunction;
var isArray = Array.isArray || function(value) {
  return (value && typeof value === 'object') ? toString.call(value) === '[object Array]' : false;
};
exports.isArray = isArray;

function escapeExpression(string) {
  // don't escape SafeStrings, since they're already safe
  if (string instanceof SafeString) {
    return string.toString();
  } else if (!string && string !== 0) {
    return "";
  }

  // Force a string conversion as this will be done by the append regardless and
  // the regex test will do this transparently behind the scenes, causing issues if
  // an object's to string has escaped characters in it.
  string = "" + string;

  if(!possible.test(string)) { return string; }
  return string.replace(badChars, escapeChar);
}

exports.escapeExpression = escapeExpression;function isEmpty(value) {
  if (!value && value !== 0) {
    return true;
  } else if (isArray(value) && value.length === 0) {
    return true;
  } else {
    return false;
  }
}

exports.isEmpty = isEmpty;
},{"./safe-string":560}],562:[function(require,module,exports){
// Create a simple path alias to allow browserify to resolve
// the runtime on a supported path.
module.exports = require('./dist/cjs/handlebars.runtime');

},{"./dist/cjs/handlebars.runtime":556}],563:[function(require,module,exports){
module.exports = require("handlebars/runtime")["default"];

},{"handlebars/runtime":562}],564:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],565:[function(require,module,exports){

/**
 port of http://www.bbc.co.uk/glow/docs/1.7/api/glow.lang.shtml #interpolate
  Modified to be stand-alone and offer support for delimters of random length
  @description Replaces placeholders in a string with data from an object

  @param {String} template The string containing {placeholders}
  @param {Object} data Object containing the data to be merged in to the template
    The object can contain nested data objects and arrays, with nested object properties and array elements are accessed using dot notation. eg foo.bar or foo.0.
    The data labels in the object cannot contain characters used in the template delimiters, so if the data must be allowed to contain the default { and } delimiters, the delimters must be changed using the option below.
  @param {Object} opts Options object
    @param {String} [opts.delimiter="{}"] Alternative label delimiter(s) for the template. Needs to be symmetric, i.e. '{{}}', '<%%>'

  @returns {String}
 */

function interpolate (template, data, opts) {
  var regex,
      lDel,
      rDel,
      delLen,
      lDelLen,
      delimiter,
      // For escaping strings to go in regex
      regexEscape = /([$\^\\\/()|?+*\[\]{}.\-])/g;

  opts = opts || {};

  delimiter = opts.delimiter || '{}';
  delLen = delimiter.length;
  lDelLen = Math.ceil(delLen / 2);
  // escape delimiters for regex
  lDel = delimiter.substr(0, lDelLen).replace(regexEscape, "\\$1");
  rDel = delimiter.substr(lDelLen, delLen).replace(regexEscape, "\\$1") || lDel;

  // construct the new regex
  regex = new RegExp(lDel + "[^" + lDel + rDel + "]+" + rDel, "g");

  return template.replace(regex, function (placeholder) {
    var key = placeholder.slice(lDelLen, -lDelLen),
        keyParts = key.split("."),
        val,
        i = 0,
        len = keyParts.length;

    if (key in data) {
      // need to be backwards compatible with "flattened" data.
      val = data[key];
    }
    else {
      // look up the chain
      val = data;
      for (; i < len; i++) {
        if (keyParts[i] in val) {
          val = val[ keyParts[i] ];
        } else {
          return placeholder;
        }
      }
    }
    return val;
  });
}

module.exports = interpolate;

},{}],566:[function(require,module,exports){
'use strict';
module.exports = function (buf) {
	if (!buf || buf.length < 3) {
		return false;
	}

	return buf[0] === 255 &&
		buf[1] === 216 &&
		buf[2] === 255;
};

},{}],567:[function(require,module,exports){
/*!
 * Knockout JavaScript library v3.2.0
 * (c) Steven Sanderson - http://knockoutjs.com/
 * License: MIT (http://www.opensource.org/licenses/mit-license.php)
 */

(function(){
var DEBUG=true;
(function(undefined){
    // (0, eval)('this') is a robust way of getting a reference to the global object
    // For details, see http://stackoverflow.com/questions/14119988/return-this-0-evalthis/14120023#14120023
    var window = this || (0, eval)('this'),
        document = window['document'],
        navigator = window['navigator'],
        jQueryInstance = window["jQuery"],
        JSON = window["JSON"];
(function(factory) {
    // Support three module loading scenarios
    if (typeof require === 'function' && typeof exports === 'object' && typeof module === 'object') {
        // [1] CommonJS/Node.js
        var target = module['exports'] || exports; // module.exports is for Node.js
        factory(target, require);
    } else if (typeof define === 'function' && define['amd']) {
        // [2] AMD anonymous module
        define(['exports', 'require'], factory);
    } else {
        // [3] No module loader (plain <script> tag) - put directly in global namespace
        factory(window['ko'] = {});
    }
}(function(koExports, require){
// Internally, all KO objects are attached to koExports (even the non-exported ones whose names will be minified by the closure compiler).
// In the future, the following "ko" variable may be made distinct from "koExports" so that private objects are not externally reachable.
var ko = typeof koExports !== 'undefined' ? koExports : {};
// Google Closure Compiler helpers (used only to make the minified file smaller)
ko.exportSymbol = function(koPath, object) {
    var tokens = koPath.split(".");

    // In the future, "ko" may become distinct from "koExports" (so that non-exported objects are not reachable)
    // At that point, "target" would be set to: (typeof koExports !== "undefined" ? koExports : ko)
    var target = ko;

    for (var i = 0; i < tokens.length - 1; i++)
        target = target[tokens[i]];
    target[tokens[tokens.length - 1]] = object;
};
ko.exportProperty = function(owner, publicName, object) {
    owner[publicName] = object;
};
ko.version = "3.2.0";

ko.exportSymbol('version', ko.version);
ko.utils = (function () {
    function objectForEach(obj, action) {
        for (var prop in obj) {
            if (obj.hasOwnProperty(prop)) {
                action(prop, obj[prop]);
            }
        }
    }

    function extend(target, source) {
        if (source) {
            for(var prop in source) {
                if(source.hasOwnProperty(prop)) {
                    target[prop] = source[prop];
                }
            }
        }
        return target;
    }

    function setPrototypeOf(obj, proto) {
        obj.__proto__ = proto;
        return obj;
    }

    var canSetPrototype = ({ __proto__: [] } instanceof Array);

    // Represent the known event types in a compact way, then at runtime transform it into a hash with event name as key (for fast lookup)
    var knownEvents = {}, knownEventTypesByEventName = {};
    var keyEventTypeName = (navigator && /Firefox\/2/i.test(navigator.userAgent)) ? 'KeyboardEvent' : 'UIEvents';
    knownEvents[keyEventTypeName] = ['keyup', 'keydown', 'keypress'];
    knownEvents['MouseEvents'] = ['click', 'dblclick', 'mousedown', 'mouseup', 'mousemove', 'mouseover', 'mouseout', 'mouseenter', 'mouseleave'];
    objectForEach(knownEvents, function(eventType, knownEventsForType) {
        if (knownEventsForType.length) {
            for (var i = 0, j = knownEventsForType.length; i < j; i++)
                knownEventTypesByEventName[knownEventsForType[i]] = eventType;
        }
    });
    var eventsThatMustBeRegisteredUsingAttachEvent = { 'propertychange': true }; // Workaround for an IE9 issue - https://github.com/SteveSanderson/knockout/issues/406

    // Detect IE versions for bug workarounds (uses IE conditionals, not UA string, for robustness)
    // Note that, since IE 10 does not support conditional comments, the following logic only detects IE < 10.
    // Currently this is by design, since IE 10+ behaves correctly when treated as a standard browser.
    // If there is a future need to detect specific versions of IE10+, we will amend this.
    var ieVersion = document && (function() {
        var version = 3, div = document.createElement('div'), iElems = div.getElementsByTagName('i');

        // Keep constructing conditional HTML blocks until we hit one that resolves to an empty fragment
        while (
            div.innerHTML = '<!--[if gt IE ' + (++version) + ']><i></i><![endif]-->',
            iElems[0]
        ) {}
        return version > 4 ? version : undefined;
    }());
    var isIe6 = ieVersion === 6,
        isIe7 = ieVersion === 7;

    function isClickOnCheckableElement(element, eventType) {
        if ((ko.utils.tagNameLower(element) !== "input") || !element.type) return false;
        if (eventType.toLowerCase() != "click") return false;
        var inputType = element.type;
        return (inputType == "checkbox") || (inputType == "radio");
    }

    return {
        fieldsIncludedWithJsonPost: ['authenticity_token', /^__RequestVerificationToken(_.*)?$/],

        arrayForEach: function (array, action) {
            for (var i = 0, j = array.length; i < j; i++)
                action(array[i], i);
        },

        arrayIndexOf: function (array, item) {
            if (typeof Array.prototype.indexOf == "function")
                return Array.prototype.indexOf.call(array, item);
            for (var i = 0, j = array.length; i < j; i++)
                if (array[i] === item)
                    return i;
            return -1;
        },

        arrayFirst: function (array, predicate, predicateOwner) {
            for (var i = 0, j = array.length; i < j; i++)
                if (predicate.call(predicateOwner, array[i], i))
                    return array[i];
            return null;
        },

        arrayRemoveItem: function (array, itemToRemove) {
            var index = ko.utils.arrayIndexOf(array, itemToRemove);
            if (index > 0) {
                array.splice(index, 1);
            }
            else if (index === 0) {
                array.shift();
            }
        },

        arrayGetDistinctValues: function (array) {
            array = array || [];
            var result = [];
            for (var i = 0, j = array.length; i < j; i++) {
                if (ko.utils.arrayIndexOf(result, array[i]) < 0)
                    result.push(array[i]);
            }
            return result;
        },

        arrayMap: function (array, mapping) {
            array = array || [];
            var result = [];
            for (var i = 0, j = array.length; i < j; i++)
                result.push(mapping(array[i], i));
            return result;
        },

        arrayFilter: function (array, predicate) {
            array = array || [];
            var result = [];
            for (var i = 0, j = array.length; i < j; i++)
                if (predicate(array[i], i))
                    result.push(array[i]);
            return result;
        },

        arrayPushAll: function (array, valuesToPush) {
            if (valuesToPush instanceof Array)
                array.push.apply(array, valuesToPush);
            else
                for (var i = 0, j = valuesToPush.length; i < j; i++)
                    array.push(valuesToPush[i]);
            return array;
        },

        addOrRemoveItem: function(array, value, included) {
            var existingEntryIndex = ko.utils.arrayIndexOf(ko.utils.peekObservable(array), value);
            if (existingEntryIndex < 0) {
                if (included)
                    array.push(value);
            } else {
                if (!included)
                    array.splice(existingEntryIndex, 1);
            }
        },

        canSetPrototype: canSetPrototype,

        extend: extend,

        setPrototypeOf: setPrototypeOf,

        setPrototypeOfOrExtend: canSetPrototype ? setPrototypeOf : extend,

        objectForEach: objectForEach,

        objectMap: function(source, mapping) {
            if (!source)
                return source;
            var target = {};
            for (var prop in source) {
                if (source.hasOwnProperty(prop)) {
                    target[prop] = mapping(source[prop], prop, source);
                }
            }
            return target;
        },

        emptyDomNode: function (domNode) {
            while (domNode.firstChild) {
                ko.removeNode(domNode.firstChild);
            }
        },

        moveCleanedNodesToContainerElement: function(nodes) {
            // Ensure it's a real array, as we're about to reparent the nodes and
            // we don't want the underlying collection to change while we're doing that.
            var nodesArray = ko.utils.makeArray(nodes);

            var container = document.createElement('div');
            for (var i = 0, j = nodesArray.length; i < j; i++) {
                container.appendChild(ko.cleanNode(nodesArray[i]));
            }
            return container;
        },

        cloneNodes: function (nodesArray, shouldCleanNodes) {
            for (var i = 0, j = nodesArray.length, newNodesArray = []; i < j; i++) {
                var clonedNode = nodesArray[i].cloneNode(true);
                newNodesArray.push(shouldCleanNodes ? ko.cleanNode(clonedNode) : clonedNode);
            }
            return newNodesArray;
        },

        setDomNodeChildren: function (domNode, childNodes) {
            ko.utils.emptyDomNode(domNode);
            if (childNodes) {
                for (var i = 0, j = childNodes.length; i < j; i++)
                    domNode.appendChild(childNodes[i]);
            }
        },

        replaceDomNodes: function (nodeToReplaceOrNodeArray, newNodesArray) {
            var nodesToReplaceArray = nodeToReplaceOrNodeArray.nodeType ? [nodeToReplaceOrNodeArray] : nodeToReplaceOrNodeArray;
            if (nodesToReplaceArray.length > 0) {
                var insertionPoint = nodesToReplaceArray[0];
                var parent = insertionPoint.parentNode;
                for (var i = 0, j = newNodesArray.length; i < j; i++)
                    parent.insertBefore(newNodesArray[i], insertionPoint);
                for (var i = 0, j = nodesToReplaceArray.length; i < j; i++) {
                    ko.removeNode(nodesToReplaceArray[i]);
                }
            }
        },

        fixUpContinuousNodeArray: function(continuousNodeArray, parentNode) {
            // Before acting on a set of nodes that were previously outputted by a template function, we have to reconcile
            // them against what is in the DOM right now. It may be that some of the nodes have already been removed, or that
            // new nodes might have been inserted in the middle, for example by a binding. Also, there may previously have been
            // leading comment nodes (created by rewritten string-based templates) that have since been removed during binding.
            // So, this function translates the old "map" output array into its best guess of the set of current DOM nodes.
            //
            // Rules:
            //   [A] Any leading nodes that have been removed should be ignored
            //       These most likely correspond to memoization nodes that were already removed during binding
            //       See https://github.com/SteveSanderson/knockout/pull/440
            //   [B] We want to output a continuous series of nodes. So, ignore any nodes that have already been removed,
            //       and include any nodes that have been inserted among the previous collection

            if (continuousNodeArray.length) {
                // The parent node can be a virtual element; so get the real parent node
                parentNode = (parentNode.nodeType === 8 && parentNode.parentNode) || parentNode;

                // Rule [A]
                while (continuousNodeArray.length && continuousNodeArray[0].parentNode !== parentNode)
                    continuousNodeArray.shift();

                // Rule [B]
                if (continuousNodeArray.length > 1) {
                    var current = continuousNodeArray[0], last = continuousNodeArray[continuousNodeArray.length - 1];
                    // Replace with the actual new continuous node set
                    continuousNodeArray.length = 0;
                    while (current !== last) {
                        continuousNodeArray.push(current);
                        current = current.nextSibling;
                        if (!current) // Won't happen, except if the developer has manually removed some DOM elements (then we're in an undefined scenario)
                            return;
                    }
                    continuousNodeArray.push(last);
                }
            }
            return continuousNodeArray;
        },

        setOptionNodeSelectionState: function (optionNode, isSelected) {
            // IE6 sometimes throws "unknown error" if you try to write to .selected directly, whereas Firefox struggles with setAttribute. Pick one based on browser.
            if (ieVersion < 7)
                optionNode.setAttribute("selected", isSelected);
            else
                optionNode.selected = isSelected;
        },

        stringTrim: function (string) {
            return string === null || string === undefined ? '' :
                string.trim ?
                    string.trim() :
                    string.toString().replace(/^[\s\xa0]+|[\s\xa0]+$/g, '');
        },

        stringStartsWith: function (string, startsWith) {
            string = string || "";
            if (startsWith.length > string.length)
                return false;
            return string.substring(0, startsWith.length) === startsWith;
        },

        domNodeIsContainedBy: function (node, containedByNode) {
            if (node === containedByNode)
                return true;
            if (node.nodeType === 11)
                return false; // Fixes issue #1162 - can't use node.contains for document fragments on IE8
            if (containedByNode.contains)
                return containedByNode.contains(node.nodeType === 3 ? node.parentNode : node);
            if (containedByNode.compareDocumentPosition)
                return (containedByNode.compareDocumentPosition(node) & 16) == 16;
            while (node && node != containedByNode) {
                node = node.parentNode;
            }
            return !!node;
        },

        domNodeIsAttachedToDocument: function (node) {
            return ko.utils.domNodeIsContainedBy(node, node.ownerDocument.documentElement);
        },

        anyDomNodeIsAttachedToDocument: function(nodes) {
            return !!ko.utils.arrayFirst(nodes, ko.utils.domNodeIsAttachedToDocument);
        },

        tagNameLower: function(element) {
            // For HTML elements, tagName will always be upper case; for XHTML elements, it'll be lower case.
            // Possible future optimization: If we know it's an element from an XHTML document (not HTML),
            // we don't need to do the .toLowerCase() as it will always be lower case anyway.
            return element && element.tagName && element.tagName.toLowerCase();
        },

        registerEventHandler: function (element, eventType, handler) {
            var mustUseAttachEvent = ieVersion && eventsThatMustBeRegisteredUsingAttachEvent[eventType];
            if (!mustUseAttachEvent && jQueryInstance) {
                jQueryInstance(element)['bind'](eventType, handler);
            } else if (!mustUseAttachEvent && typeof element.addEventListener == "function")
                element.addEventListener(eventType, handler, false);
            else if (typeof element.attachEvent != "undefined") {
                var attachEventHandler = function (event) { handler.call(element, event); },
                    attachEventName = "on" + eventType;
                element.attachEvent(attachEventName, attachEventHandler);

                // IE does not dispose attachEvent handlers automatically (unlike with addEventListener)
                // so to avoid leaks, we have to remove them manually. See bug #856
                ko.utils.domNodeDisposal.addDisposeCallback(element, function() {
                    element.detachEvent(attachEventName, attachEventHandler);
                });
            } else
                throw new Error("Browser doesn't support addEventListener or attachEvent");
        },

        triggerEvent: function (element, eventType) {
            if (!(element && element.nodeType))
                throw new Error("element must be a DOM node when calling triggerEvent");

            // For click events on checkboxes and radio buttons, jQuery toggles the element checked state *after* the
            // event handler runs instead of *before*. (This was fixed in 1.9 for checkboxes but not for radio buttons.)
            // IE doesn't change the checked state when you trigger the click event using "fireEvent".
            // In both cases, we'll use the click method instead.
            var useClickWorkaround = isClickOnCheckableElement(element, eventType);

            if (jQueryInstance && !useClickWorkaround) {
                jQueryInstance(element)['trigger'](eventType);
            } else if (typeof document.createEvent == "function") {
                if (typeof element.dispatchEvent == "function") {
                    var eventCategory = knownEventTypesByEventName[eventType] || "HTMLEvents";
                    var event = document.createEvent(eventCategory);
                    event.initEvent(eventType, true, true, window, 0, 0, 0, 0, 0, false, false, false, false, 0, element);
                    element.dispatchEvent(event);
                }
                else
                    throw new Error("The supplied element doesn't support dispatchEvent");
            } else if (useClickWorkaround && element.click) {
                element.click();
            } else if (typeof element.fireEvent != "undefined") {
                element.fireEvent("on" + eventType);
            } else {
                throw new Error("Browser doesn't support triggering events");
            }
        },

        unwrapObservable: function (value) {
            return ko.isObservable(value) ? value() : value;
        },

        peekObservable: function (value) {
            return ko.isObservable(value) ? value.peek() : value;
        },

        toggleDomNodeCssClass: function (node, classNames, shouldHaveClass) {
            if (classNames) {
                var cssClassNameRegex = /\S+/g,
                    currentClassNames = node.className.match(cssClassNameRegex) || [];
                ko.utils.arrayForEach(classNames.match(cssClassNameRegex), function(className) {
                    ko.utils.addOrRemoveItem(currentClassNames, className, shouldHaveClass);
                });
                node.className = currentClassNames.join(" ");
            }
        },

        setTextContent: function(element, textContent) {
            var value = ko.utils.unwrapObservable(textContent);
            if ((value === null) || (value === undefined))
                value = "";

            // We need there to be exactly one child: a text node.
            // If there are no children, more than one, or if it's not a text node,
            // we'll clear everything and create a single text node.
            var innerTextNode = ko.virtualElements.firstChild(element);
            if (!innerTextNode || innerTextNode.nodeType != 3 || ko.virtualElements.nextSibling(innerTextNode)) {
                ko.virtualElements.setDomNodeChildren(element, [element.ownerDocument.createTextNode(value)]);
            } else {
                innerTextNode.data = value;
            }

            ko.utils.forceRefresh(element);
        },

        setElementName: function(element, name) {
            element.name = name;

            // Workaround IE 6/7 issue
            // - https://github.com/SteveSanderson/knockout/issues/197
            // - http://www.matts411.com/post/setting_the_name_attribute_in_ie_dom/
            if (ieVersion <= 7) {
                try {
                    element.mergeAttributes(document.createElement("<input name='" + element.name + "'/>"), false);
                }
                catch(e) {} // For IE9 with doc mode "IE9 Standards" and browser mode "IE9 Compatibility View"
            }
        },

        forceRefresh: function(node) {
            // Workaround for an IE9 rendering bug - https://github.com/SteveSanderson/knockout/issues/209
            if (ieVersion >= 9) {
                // For text nodes and comment nodes (most likely virtual elements), we will have to refresh the container
                var elem = node.nodeType == 1 ? node : node.parentNode;
                if (elem.style)
                    elem.style.zoom = elem.style.zoom;
            }
        },

        ensureSelectElementIsRenderedCorrectly: function(selectElement) {
            // Workaround for IE9 rendering bug - it doesn't reliably display all the text in dynamically-added select boxes unless you force it to re-render by updating the width.
            // (See https://github.com/SteveSanderson/knockout/issues/312, http://stackoverflow.com/questions/5908494/select-only-shows-first-char-of-selected-option)
            // Also fixes IE7 and IE8 bug that causes selects to be zero width if enclosed by 'if' or 'with'. (See issue #839)
            if (ieVersion) {
                var originalWidth = selectElement.style.width;
                selectElement.style.width = 0;
                selectElement.style.width = originalWidth;
            }
        },

        range: function (min, max) {
            min = ko.utils.unwrapObservable(min);
            max = ko.utils.unwrapObservable(max);
            var result = [];
            for (var i = min; i <= max; i++)
                result.push(i);
            return result;
        },

        makeArray: function(arrayLikeObject) {
            var result = [];
            for (var i = 0, j = arrayLikeObject.length; i < j; i++) {
                result.push(arrayLikeObject[i]);
            };
            return result;
        },

        isIe6 : isIe6,
        isIe7 : isIe7,
        ieVersion : ieVersion,

        getFormFields: function(form, fieldName) {
            var fields = ko.utils.makeArray(form.getElementsByTagName("input")).concat(ko.utils.makeArray(form.getElementsByTagName("textarea")));
            var isMatchingField = (typeof fieldName == 'string')
                ? function(field) { return field.name === fieldName }
                : function(field) { return fieldName.test(field.name) }; // Treat fieldName as regex or object containing predicate
            var matches = [];
            for (var i = fields.length - 1; i >= 0; i--) {
                if (isMatchingField(fields[i]))
                    matches.push(fields[i]);
            };
            return matches;
        },

        parseJson: function (jsonString) {
            if (typeof jsonString == "string") {
                jsonString = ko.utils.stringTrim(jsonString);
                if (jsonString) {
                    if (JSON && JSON.parse) // Use native parsing where available
                        return JSON.parse(jsonString);
                    return (new Function("return " + jsonString))(); // Fallback on less safe parsing for older browsers
                }
            }
            return null;
        },

        stringifyJson: function (data, replacer, space) {   // replacer and space are optional
            if (!JSON || !JSON.stringify)
                throw new Error("Cannot find JSON.stringify(). Some browsers (e.g., IE < 8) don't support it natively, but you can overcome this by adding a script reference to json2.js, downloadable from http://www.json.org/json2.js");
            return JSON.stringify(ko.utils.unwrapObservable(data), replacer, space);
        },

        postJson: function (urlOrForm, data, options) {
            options = options || {};
            var params = options['params'] || {};
            var includeFields = options['includeFields'] || this.fieldsIncludedWithJsonPost;
            var url = urlOrForm;

            // If we were given a form, use its 'action' URL and pick out any requested field values
            if((typeof urlOrForm == 'object') && (ko.utils.tagNameLower(urlOrForm) === "form")) {
                var originalForm = urlOrForm;
                url = originalForm.action;
                for (var i = includeFields.length - 1; i >= 0; i--) {
                    var fields = ko.utils.getFormFields(originalForm, includeFields[i]);
                    for (var j = fields.length - 1; j >= 0; j--)
                        params[fields[j].name] = fields[j].value;
                }
            }

            data = ko.utils.unwrapObservable(data);
            var form = document.createElement("form");
            form.style.display = "none";
            form.action = url;
            form.method = "post";
            for (var key in data) {
                // Since 'data' this is a model object, we include all properties including those inherited from its prototype
                var input = document.createElement("input");
                input.type = "hidden";
                input.name = key;
                input.value = ko.utils.stringifyJson(ko.utils.unwrapObservable(data[key]));
                form.appendChild(input);
            }
            objectForEach(params, function(key, value) {
                var input = document.createElement("input");
                input.type = "hidden";
                input.name = key;
                input.value = value;
                form.appendChild(input);
            });
            document.body.appendChild(form);
            options['submitter'] ? options['submitter'](form) : form.submit();
            setTimeout(function () { form.parentNode.removeChild(form); }, 0);
        }
    }
}());

ko.exportSymbol('utils', ko.utils);
ko.exportSymbol('utils.arrayForEach', ko.utils.arrayForEach);
ko.exportSymbol('utils.arrayFirst', ko.utils.arrayFirst);
ko.exportSymbol('utils.arrayFilter', ko.utils.arrayFilter);
ko.exportSymbol('utils.arrayGetDistinctValues', ko.utils.arrayGetDistinctValues);
ko.exportSymbol('utils.arrayIndexOf', ko.utils.arrayIndexOf);
ko.exportSymbol('utils.arrayMap', ko.utils.arrayMap);
ko.exportSymbol('utils.arrayPushAll', ko.utils.arrayPushAll);
ko.exportSymbol('utils.arrayRemoveItem', ko.utils.arrayRemoveItem);
ko.exportSymbol('utils.extend', ko.utils.extend);
ko.exportSymbol('utils.fieldsIncludedWithJsonPost', ko.utils.fieldsIncludedWithJsonPost);
ko.exportSymbol('utils.getFormFields', ko.utils.getFormFields);
ko.exportSymbol('utils.peekObservable', ko.utils.peekObservable);
ko.exportSymbol('utils.postJson', ko.utils.postJson);
ko.exportSymbol('utils.parseJson', ko.utils.parseJson);
ko.exportSymbol('utils.registerEventHandler', ko.utils.registerEventHandler);
ko.exportSymbol('utils.stringifyJson', ko.utils.stringifyJson);
ko.exportSymbol('utils.range', ko.utils.range);
ko.exportSymbol('utils.toggleDomNodeCssClass', ko.utils.toggleDomNodeCssClass);
ko.exportSymbol('utils.triggerEvent', ko.utils.triggerEvent);
ko.exportSymbol('utils.unwrapObservable', ko.utils.unwrapObservable);
ko.exportSymbol('utils.objectForEach', ko.utils.objectForEach);
ko.exportSymbol('utils.addOrRemoveItem', ko.utils.addOrRemoveItem);
ko.exportSymbol('unwrap', ko.utils.unwrapObservable); // Convenient shorthand, because this is used so commonly

if (!Function.prototype['bind']) {
    // Function.prototype.bind is a standard part of ECMAScript 5th Edition (December 2009, http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-262.pdf)
    // In case the browser doesn't implement it natively, provide a JavaScript implementation. This implementation is based on the one in prototype.js
    Function.prototype['bind'] = function (object) {
        var originalFunction = this, args = Array.prototype.slice.call(arguments), object = args.shift();
        return function () {
            return originalFunction.apply(object, args.concat(Array.prototype.slice.call(arguments)));
        };
    };
}

ko.utils.domData = new (function () {
    var uniqueId = 0;
    var dataStoreKeyExpandoPropertyName = "__ko__" + (new Date).getTime();
    var dataStore = {};

    function getAll(node, createIfNotFound) {
        var dataStoreKey = node[dataStoreKeyExpandoPropertyName];
        var hasExistingDataStore = dataStoreKey && (dataStoreKey !== "null") && dataStore[dataStoreKey];
        if (!hasExistingDataStore) {
            if (!createIfNotFound)
                return undefined;
            dataStoreKey = node[dataStoreKeyExpandoPropertyName] = "ko" + uniqueId++;
            dataStore[dataStoreKey] = {};
        }
        return dataStore[dataStoreKey];
    }

    return {
        get: function (node, key) {
            var allDataForNode = getAll(node, false);
            return allDataForNode === undefined ? undefined : allDataForNode[key];
        },
        set: function (node, key, value) {
            if (value === undefined) {
                // Make sure we don't actually create a new domData key if we are actually deleting a value
                if (getAll(node, false) === undefined)
                    return;
            }
            var allDataForNode = getAll(node, true);
            allDataForNode[key] = value;
        },
        clear: function (node) {
            var dataStoreKey = node[dataStoreKeyExpandoPropertyName];
            if (dataStoreKey) {
                delete dataStore[dataStoreKey];
                node[dataStoreKeyExpandoPropertyName] = null;
                return true; // Exposing "did clean" flag purely so specs can infer whether things have been cleaned up as intended
            }
            return false;
        },

        nextKey: function () {
            return (uniqueId++) + dataStoreKeyExpandoPropertyName;
        }
    };
})();

ko.exportSymbol('utils.domData', ko.utils.domData);
ko.exportSymbol('utils.domData.clear', ko.utils.domData.clear); // Exporting only so specs can clear up after themselves fully

ko.utils.domNodeDisposal = new (function () {
    var domDataKey = ko.utils.domData.nextKey();
    var cleanableNodeTypes = { 1: true, 8: true, 9: true };       // Element, Comment, Document
    var cleanableNodeTypesWithDescendants = { 1: true, 9: true }; // Element, Document

    function getDisposeCallbacksCollection(node, createIfNotFound) {
        var allDisposeCallbacks = ko.utils.domData.get(node, domDataKey);
        if ((allDisposeCallbacks === undefined) && createIfNotFound) {
            allDisposeCallbacks = [];
            ko.utils.domData.set(node, domDataKey, allDisposeCallbacks);
        }
        return allDisposeCallbacks;
    }
    function destroyCallbacksCollection(node) {
        ko.utils.domData.set(node, domDataKey, undefined);
    }

    function cleanSingleNode(node) {
        // Run all the dispose callbacks
        var callbacks = getDisposeCallbacksCollection(node, false);
        if (callbacks) {
            callbacks = callbacks.slice(0); // Clone, as the array may be modified during iteration (typically, callbacks will remove themselves)
            for (var i = 0; i < callbacks.length; i++)
                callbacks[i](node);
        }

        // Erase the DOM data
        ko.utils.domData.clear(node);

        // Perform cleanup needed by external libraries (currently only jQuery, but can be extended)
        ko.utils.domNodeDisposal["cleanExternalData"](node);

        // Clear any immediate-child comment nodes, as these wouldn't have been found by
        // node.getElementsByTagName("*") in cleanNode() (comment nodes aren't elements)
        if (cleanableNodeTypesWithDescendants[node.nodeType])
            cleanImmediateCommentTypeChildren(node);
    }

    function cleanImmediateCommentTypeChildren(nodeWithChildren) {
        var child, nextChild = nodeWithChildren.firstChild;
        while (child = nextChild) {
            nextChild = child.nextSibling;
            if (child.nodeType === 8)
                cleanSingleNode(child);
        }
    }

    return {
        addDisposeCallback : function(node, callback) {
            if (typeof callback != "function")
                throw new Error("Callback must be a function");
            getDisposeCallbacksCollection(node, true).push(callback);
        },

        removeDisposeCallback : function(node, callback) {
            var callbacksCollection = getDisposeCallbacksCollection(node, false);
            if (callbacksCollection) {
                ko.utils.arrayRemoveItem(callbacksCollection, callback);
                if (callbacksCollection.length == 0)
                    destroyCallbacksCollection(node);
            }
        },

        cleanNode : function(node) {
            // First clean this node, where applicable
            if (cleanableNodeTypes[node.nodeType]) {
                cleanSingleNode(node);

                // ... then its descendants, where applicable
                if (cleanableNodeTypesWithDescendants[node.nodeType]) {
                    // Clone the descendants list in case it changes during iteration
                    var descendants = [];
                    ko.utils.arrayPushAll(descendants, node.getElementsByTagName("*"));
                    for (var i = 0, j = descendants.length; i < j; i++)
                        cleanSingleNode(descendants[i]);
                }
            }
            return node;
        },

        removeNode : function(node) {
            ko.cleanNode(node);
            if (node.parentNode)
                node.parentNode.removeChild(node);
        },

        "cleanExternalData" : function (node) {
            // Special support for jQuery here because it's so commonly used.
            // Many jQuery plugins (including jquery.tmpl) store data using jQuery's equivalent of domData
            // so notify it to tear down any resources associated with the node & descendants here.
            if (jQueryInstance && (typeof jQueryInstance['cleanData'] == "function"))
                jQueryInstance['cleanData']([node]);
        }
    }
})();
ko.cleanNode = ko.utils.domNodeDisposal.cleanNode; // Shorthand name for convenience
ko.removeNode = ko.utils.domNodeDisposal.removeNode; // Shorthand name for convenience
ko.exportSymbol('cleanNode', ko.cleanNode);
ko.exportSymbol('removeNode', ko.removeNode);
ko.exportSymbol('utils.domNodeDisposal', ko.utils.domNodeDisposal);
ko.exportSymbol('utils.domNodeDisposal.addDisposeCallback', ko.utils.domNodeDisposal.addDisposeCallback);
ko.exportSymbol('utils.domNodeDisposal.removeDisposeCallback', ko.utils.domNodeDisposal.removeDisposeCallback);
(function () {
    var leadingCommentRegex = /^(\s*)<!--(.*?)-->/;

    function simpleHtmlParse(html) {
        // Based on jQuery's "clean" function, but only accounting for table-related elements.
        // If you have referenced jQuery, this won't be used anyway - KO will use jQuery's "clean" function directly

        // Note that there's still an issue in IE < 9 whereby it will discard comment nodes that are the first child of
        // a descendant node. For example: "<div><!-- mycomment -->abc</div>" will get parsed as "<div>abc</div>"
        // This won't affect anyone who has referenced jQuery, and there's always the workaround of inserting a dummy node
        // (possibly a text node) in front of the comment. So, KO does not attempt to workaround this IE issue automatically at present.

        // Trim whitespace, otherwise indexOf won't work as expected
        var tags = ko.utils.stringTrim(html).toLowerCase(), div = document.createElement("div");

        // Finds the first match from the left column, and returns the corresponding "wrap" data from the right column
        var wrap = tags.match(/^<(thead|tbody|tfoot)/)              && [1, "<table>", "</table>"] ||
                   !tags.indexOf("<tr")                             && [2, "<table><tbody>", "</tbody></table>"] ||
                   (!tags.indexOf("<td") || !tags.indexOf("<th"))   && [3, "<table><tbody><tr>", "</tr></tbody></table>"] ||
                   /* anything else */                                 [0, "", ""];

        // Go to html and back, then peel off extra wrappers
        // Note that we always prefix with some dummy text, because otherwise, IE<9 will strip out leading comment nodes in descendants. Total madness.
        var markup = "ignored<div>" + wrap[1] + html + wrap[2] + "</div>";
        if (typeof window['innerShiv'] == "function") {
            div.appendChild(window['innerShiv'](markup));
        } else {
            div.innerHTML = markup;
        }

        // Move to the right depth
        while (wrap[0]--)
            div = div.lastChild;

        return ko.utils.makeArray(div.lastChild.childNodes);
    }

    function jQueryHtmlParse(html) {
        // jQuery's "parseHTML" function was introduced in jQuery 1.8.0 and is a documented public API.
        if (jQueryInstance['parseHTML']) {
            return jQueryInstance['parseHTML'](html) || []; // Ensure we always return an array and never null
        } else {
            // For jQuery < 1.8.0, we fall back on the undocumented internal "clean" function.
            var elems = jQueryInstance['clean']([html]);

            // As of jQuery 1.7.1, jQuery parses the HTML by appending it to some dummy parent nodes held in an in-memory document fragment.
            // Unfortunately, it never clears the dummy parent nodes from the document fragment, so it leaks memory over time.
            // Fix this by finding the top-most dummy parent element, and detaching it from its owner fragment.
            if (elems && elems[0]) {
                // Find the top-most parent element that's a direct child of a document fragment
                var elem = elems[0];
                while (elem.parentNode && elem.parentNode.nodeType !== 11 /* i.e., DocumentFragment */)
                    elem = elem.parentNode;
                // ... then detach it
                if (elem.parentNode)
                    elem.parentNode.removeChild(elem);
            }

            return elems;
        }
    }

    ko.utils.parseHtmlFragment = function(html) {
        return jQueryInstance ? jQueryHtmlParse(html)   // As below, benefit from jQuery's optimisations where possible
                              : simpleHtmlParse(html);  // ... otherwise, this simple logic will do in most common cases.
    };

    ko.utils.setHtml = function(node, html) {
        ko.utils.emptyDomNode(node);

        // There's no legitimate reason to display a stringified observable without unwrapping it, so we'll unwrap it
        html = ko.utils.unwrapObservable(html);

        if ((html !== null) && (html !== undefined)) {
            if (typeof html != 'string')
                html = html.toString();

            // jQuery contains a lot of sophisticated code to parse arbitrary HTML fragments,
            // for example <tr> elements which are not normally allowed to exist on their own.
            // If you've referenced jQuery we'll use that rather than duplicating its code.
            if (jQueryInstance) {
                jQueryInstance(node)['html'](html);
            } else {
                // ... otherwise, use KO's own parsing logic.
                var parsedNodes = ko.utils.parseHtmlFragment(html);
                for (var i = 0; i < parsedNodes.length; i++)
                    node.appendChild(parsedNodes[i]);
            }
        }
    };
})();

ko.exportSymbol('utils.parseHtmlFragment', ko.utils.parseHtmlFragment);
ko.exportSymbol('utils.setHtml', ko.utils.setHtml);

ko.memoization = (function () {
    var memos = {};

    function randomMax8HexChars() {
        return (((1 + Math.random()) * 0x100000000) | 0).toString(16).substring(1);
    }
    function generateRandomId() {
        return randomMax8HexChars() + randomMax8HexChars();
    }
    function findMemoNodes(rootNode, appendToArray) {
        if (!rootNode)
            return;
        if (rootNode.nodeType == 8) {
            var memoId = ko.memoization.parseMemoText(rootNode.nodeValue);
            if (memoId != null)
                appendToArray.push({ domNode: rootNode, memoId: memoId });
        } else if (rootNode.nodeType == 1) {
            for (var i = 0, childNodes = rootNode.childNodes, j = childNodes.length; i < j; i++)
                findMemoNodes(childNodes[i], appendToArray);
        }
    }

    return {
        memoize: function (callback) {
            if (typeof callback != "function")
                throw new Error("You can only pass a function to ko.memoization.memoize()");
            var memoId = generateRandomId();
            memos[memoId] = callback;
            return "<!--[ko_memo:" + memoId + "]-->";
        },

        unmemoize: function (memoId, callbackParams) {
            var callback = memos[memoId];
            if (callback === undefined)
                throw new Error("Couldn't find any memo with ID " + memoId + ". Perhaps it's already been unmemoized.");
            try {
                callback.apply(null, callbackParams || []);
                return true;
            }
            finally { delete memos[memoId]; }
        },

        unmemoizeDomNodeAndDescendants: function (domNode, extraCallbackParamsArray) {
            var memos = [];
            findMemoNodes(domNode, memos);
            for (var i = 0, j = memos.length; i < j; i++) {
                var node = memos[i].domNode;
                var combinedParams = [node];
                if (extraCallbackParamsArray)
                    ko.utils.arrayPushAll(combinedParams, extraCallbackParamsArray);
                ko.memoization.unmemoize(memos[i].memoId, combinedParams);
                node.nodeValue = ""; // Neuter this node so we don't try to unmemoize it again
                if (node.parentNode)
                    node.parentNode.removeChild(node); // If possible, erase it totally (not always possible - someone else might just hold a reference to it then call unmemoizeDomNodeAndDescendants again)
            }
        },

        parseMemoText: function (memoText) {
            var match = memoText.match(/^\[ko_memo\:(.*?)\]$/);
            return match ? match[1] : null;
        }
    };
})();

ko.exportSymbol('memoization', ko.memoization);
ko.exportSymbol('memoization.memoize', ko.memoization.memoize);
ko.exportSymbol('memoization.unmemoize', ko.memoization.unmemoize);
ko.exportSymbol('memoization.parseMemoText', ko.memoization.parseMemoText);
ko.exportSymbol('memoization.unmemoizeDomNodeAndDescendants', ko.memoization.unmemoizeDomNodeAndDescendants);
ko.extenders = {
    'throttle': function(target, timeout) {
        // Throttling means two things:

        // (1) For dependent observables, we throttle *evaluations* so that, no matter how fast its dependencies
        //     notify updates, the target doesn't re-evaluate (and hence doesn't notify) faster than a certain rate
        target['throttleEvaluation'] = timeout;

        // (2) For writable targets (observables, or writable dependent observables), we throttle *writes*
        //     so the target cannot change value synchronously or faster than a certain rate
        var writeTimeoutInstance = null;
        return ko.dependentObservable({
            'read': target,
            'write': function(value) {
                clearTimeout(writeTimeoutInstance);
                writeTimeoutInstance = setTimeout(function() {
                    target(value);
                }, timeout);
            }
        });
    },

    'rateLimit': function(target, options) {
        var timeout, method, limitFunction;

        if (typeof options == 'number') {
            timeout = options;
        } else {
            timeout = options['timeout'];
            method = options['method'];
        }

        limitFunction = method == 'notifyWhenChangesStop' ?  debounce : throttle;
        target.limit(function(callback) {
            return limitFunction(callback, timeout);
        });
    },

    'notify': function(target, notifyWhen) {
        target["equalityComparer"] = notifyWhen == "always" ?
            null :  // null equalityComparer means to always notify
            valuesArePrimitiveAndEqual;
    }
};

var primitiveTypes = { 'undefined':1, 'boolean':1, 'number':1, 'string':1 };
function valuesArePrimitiveAndEqual(a, b) {
    var oldValueIsPrimitive = (a === null) || (typeof(a) in primitiveTypes);
    return oldValueIsPrimitive ? (a === b) : false;
}

function throttle(callback, timeout) {
    var timeoutInstance;
    return function () {
        if (!timeoutInstance) {
            timeoutInstance = setTimeout(function() {
                timeoutInstance = undefined;
                callback();
            }, timeout);
        }
    };
}

function debounce(callback, timeout) {
    var timeoutInstance;
    return function () {
        clearTimeout(timeoutInstance);
        timeoutInstance = setTimeout(callback, timeout);
    };
}

function applyExtenders(requestedExtenders) {
    var target = this;
    if (requestedExtenders) {
        ko.utils.objectForEach(requestedExtenders, function(key, value) {
            var extenderHandler = ko.extenders[key];
            if (typeof extenderHandler == 'function') {
                target = extenderHandler(target, value) || target;
            }
        });
    }
    return target;
}

ko.exportSymbol('extenders', ko.extenders);

ko.subscription = function (target, callback, disposeCallback) {
    this.target = target;
    this.callback = callback;
    this.disposeCallback = disposeCallback;
    this.isDisposed = false;
    ko.exportProperty(this, 'dispose', this.dispose);
};
ko.subscription.prototype.dispose = function () {
    this.isDisposed = true;
    this.disposeCallback();
};

ko.subscribable = function () {
    ko.utils.setPrototypeOfOrExtend(this, ko.subscribable['fn']);
    this._subscriptions = {};
}

var defaultEvent = "change";

var ko_subscribable_fn = {
    subscribe: function (callback, callbackTarget, event) {
        var self = this;

        event = event || defaultEvent;
        var boundCallback = callbackTarget ? callback.bind(callbackTarget) : callback;

        var subscription = new ko.subscription(self, boundCallback, function () {
            ko.utils.arrayRemoveItem(self._subscriptions[event], subscription);
            if (self.afterSubscriptionRemove)
                self.afterSubscriptionRemove(event);
        });

        if (self.beforeSubscriptionAdd)
            self.beforeSubscriptionAdd(event);

        if (!self._subscriptions[event])
            self._subscriptions[event] = [];
        self._subscriptions[event].push(subscription);

        return subscription;
    },

    "notifySubscribers": function (valueToNotify, event) {
        event = event || defaultEvent;
        if (this.hasSubscriptionsForEvent(event)) {
            try {
                ko.dependencyDetection.begin(); // Begin suppressing dependency detection (by setting the top frame to undefined)
                for (var a = this._subscriptions[event].slice(0), i = 0, subscription; subscription = a[i]; ++i) {
                    // In case a subscription was disposed during the arrayForEach cycle, check
                    // for isDisposed on each subscription before invoking its callback
                    if (!subscription.isDisposed)
                        subscription.callback(valueToNotify);
                }
            } finally {
                ko.dependencyDetection.end(); // End suppressing dependency detection
            }
        }
    },

    limit: function(limitFunction) {
        var self = this, selfIsObservable = ko.isObservable(self),
            isPending, previousValue, pendingValue, beforeChange = 'beforeChange';

        if (!self._origNotifySubscribers) {
            self._origNotifySubscribers = self["notifySubscribers"];
            self["notifySubscribers"] = function(value, event) {
                if (!event || event === defaultEvent) {
                    self._rateLimitedChange(value);
                } else if (event === beforeChange) {
                    self._rateLimitedBeforeChange(value);
                } else {
                    self._origNotifySubscribers(value, event);
                }
            };
        }

        var finish = limitFunction(function() {
            // If an observable provided a reference to itself, access it to get the latest value.
            // This allows computed observables to delay calculating their value until needed.
            if (selfIsObservable && pendingValue === self) {
                pendingValue = self();
            }
            isPending = false;
            if (self.isDifferent(previousValue, pendingValue)) {
                self._origNotifySubscribers(previousValue = pendingValue);
            }
        });

        self._rateLimitedChange = function(value) {
            isPending = true;
            pendingValue = value;
            finish();
        };
        self._rateLimitedBeforeChange = function(value) {
            if (!isPending) {
                previousValue = value;
                self._origNotifySubscribers(value, beforeChange);
            }
        };
    },

    hasSubscriptionsForEvent: function(event) {
        return this._subscriptions[event] && this._subscriptions[event].length;
    },

    getSubscriptionsCount: function () {
        var total = 0;
        ko.utils.objectForEach(this._subscriptions, function(eventName, subscriptions) {
            total += subscriptions.length;
        });
        return total;
    },

    isDifferent: function(oldValue, newValue) {
        return !this['equalityComparer'] || !this['equalityComparer'](oldValue, newValue);
    },

    extend: applyExtenders
};

ko.exportProperty(ko_subscribable_fn, 'subscribe', ko_subscribable_fn.subscribe);
ko.exportProperty(ko_subscribable_fn, 'extend', ko_subscribable_fn.extend);
ko.exportProperty(ko_subscribable_fn, 'getSubscriptionsCount', ko_subscribable_fn.getSubscriptionsCount);

// For browsers that support proto assignment, we overwrite the prototype of each
// observable instance. Since observables are functions, we need Function.prototype
// to still be in the prototype chain.
if (ko.utils.canSetPrototype) {
    ko.utils.setPrototypeOf(ko_subscribable_fn, Function.prototype);
}

ko.subscribable['fn'] = ko_subscribable_fn;


ko.isSubscribable = function (instance) {
    return instance != null && typeof instance.subscribe == "function" && typeof instance["notifySubscribers"] == "function";
};

ko.exportSymbol('subscribable', ko.subscribable);
ko.exportSymbol('isSubscribable', ko.isSubscribable);

ko.computedContext = ko.dependencyDetection = (function () {
    var outerFrames = [],
        currentFrame,
        lastId = 0;

    // Return a unique ID that can be assigned to an observable for dependency tracking.
    // Theoretically, you could eventually overflow the number storage size, resulting
    // in duplicate IDs. But in JavaScript, the largest exact integral value is 2^53
    // or 9,007,199,254,740,992. If you created 1,000,000 IDs per second, it would
    // take over 285 years to reach that number.
    // Reference http://blog.vjeux.com/2010/javascript/javascript-max_int-number-limits.html
    function getId() {
        return ++lastId;
    }

    function begin(options) {
        outerFrames.push(currentFrame);
        currentFrame = options;
    }

    function end() {
        currentFrame = outerFrames.pop();
    }

    return {
        begin: begin,

        end: end,

        registerDependency: function (subscribable) {
            if (currentFrame) {
                if (!ko.isSubscribable(subscribable))
                    throw new Error("Only subscribable things can act as dependencies");
                currentFrame.callback(subscribable, subscribable._id || (subscribable._id = getId()));
            }
        },

        ignore: function (callback, callbackTarget, callbackArgs) {
            try {
                begin();
                return callback.apply(callbackTarget, callbackArgs || []);
            } finally {
                end();
            }
        },

        getDependenciesCount: function () {
            if (currentFrame)
                return currentFrame.computed.getDependenciesCount();
        },

        isInitial: function() {
            if (currentFrame)
                return currentFrame.isInitial;
        }
    };
})();

ko.exportSymbol('computedContext', ko.computedContext);
ko.exportSymbol('computedContext.getDependenciesCount', ko.computedContext.getDependenciesCount);
ko.exportSymbol('computedContext.isInitial', ko.computedContext.isInitial);
ko.exportSymbol('computedContext.isSleeping', ko.computedContext.isSleeping);
ko.observable = function (initialValue) {
    var _latestValue = initialValue;

    function observable() {
        if (arguments.length > 0) {
            // Write

            // Ignore writes if the value hasn't changed
            if (observable.isDifferent(_latestValue, arguments[0])) {
                observable.valueWillMutate();
                _latestValue = arguments[0];
                if (DEBUG) observable._latestValue = _latestValue;
                observable.valueHasMutated();
            }
            return this; // Permits chained assignments
        }
        else {
            // Read
            ko.dependencyDetection.registerDependency(observable); // The caller only needs to be notified of changes if they did a "read" operation
            return _latestValue;
        }
    }
    ko.subscribable.call(observable);
    ko.utils.setPrototypeOfOrExtend(observable, ko.observable['fn']);

    if (DEBUG) observable._latestValue = _latestValue;
    observable.peek = function() { return _latestValue };
    observable.valueHasMutated = function () { observable["notifySubscribers"](_latestValue); }
    observable.valueWillMutate = function () { observable["notifySubscribers"](_latestValue, "beforeChange"); }

    ko.exportProperty(observable, 'peek', observable.peek);
    ko.exportProperty(observable, "valueHasMutated", observable.valueHasMutated);
    ko.exportProperty(observable, "valueWillMutate", observable.valueWillMutate);

    return observable;
}

ko.observable['fn'] = {
    "equalityComparer": valuesArePrimitiveAndEqual
};

var protoProperty = ko.observable.protoProperty = "__ko_proto__";
ko.observable['fn'][protoProperty] = ko.observable;

// Note that for browsers that don't support proto assignment, the
// inheritance chain is created manually in the ko.observable constructor
if (ko.utils.canSetPrototype) {
    ko.utils.setPrototypeOf(ko.observable['fn'], ko.subscribable['fn']);
}

ko.hasPrototype = function(instance, prototype) {
    if ((instance === null) || (instance === undefined) || (instance[protoProperty] === undefined)) return false;
    if (instance[protoProperty] === prototype) return true;
    return ko.hasPrototype(instance[protoProperty], prototype); // Walk the prototype chain
};

ko.isObservable = function (instance) {
    return ko.hasPrototype(instance, ko.observable);
}
ko.isWriteableObservable = function (instance) {
    // Observable
    if ((typeof instance == "function") && instance[protoProperty] === ko.observable)
        return true;
    // Writeable dependent observable
    if ((typeof instance == "function") && (instance[protoProperty] === ko.dependentObservable) && (instance.hasWriteFunction))
        return true;
    // Anything else
    return false;
}


ko.exportSymbol('observable', ko.observable);
ko.exportSymbol('isObservable', ko.isObservable);
ko.exportSymbol('isWriteableObservable', ko.isWriteableObservable);
ko.exportSymbol('isWritableObservable', ko.isWriteableObservable);
ko.observableArray = function (initialValues) {
    initialValues = initialValues || [];

    if (typeof initialValues != 'object' || !('length' in initialValues))
        throw new Error("The argument passed when initializing an observable array must be an array, or null, or undefined.");

    var result = ko.observable(initialValues);
    ko.utils.setPrototypeOfOrExtend(result, ko.observableArray['fn']);
    return result.extend({'trackArrayChanges':true});
};

ko.observableArray['fn'] = {
    'remove': function (valueOrPredicate) {
        var underlyingArray = this.peek();
        var removedValues = [];
        var predicate = typeof valueOrPredicate == "function" && !ko.isObservable(valueOrPredicate) ? valueOrPredicate : function (value) { return value === valueOrPredicate; };
        for (var i = 0; i < underlyingArray.length; i++) {
            var value = underlyingArray[i];
            if (predicate(value)) {
                if (removedValues.length === 0) {
                    this.valueWillMutate();
                }
                removedValues.push(value);
                underlyingArray.splice(i, 1);
                i--;
            }
        }
        if (removedValues.length) {
            this.valueHasMutated();
        }
        return removedValues;
    },

    'removeAll': function (arrayOfValues) {
        // If you passed zero args, we remove everything
        if (arrayOfValues === undefined) {
            var underlyingArray = this.peek();
            var allValues = underlyingArray.slice(0);
            this.valueWillMutate();
            underlyingArray.splice(0, underlyingArray.length);
            this.valueHasMutated();
            return allValues;
        }
        // If you passed an arg, we interpret it as an array of entries to remove
        if (!arrayOfValues)
            return [];
        return this['remove'](function (value) {
            return ko.utils.arrayIndexOf(arrayOfValues, value) >= 0;
        });
    },

    'destroy': function (valueOrPredicate) {
        var underlyingArray = this.peek();
        var predicate = typeof valueOrPredicate == "function" && !ko.isObservable(valueOrPredicate) ? valueOrPredicate : function (value) { return value === valueOrPredicate; };
        this.valueWillMutate();
        for (var i = underlyingArray.length - 1; i >= 0; i--) {
            var value = underlyingArray[i];
            if (predicate(value))
                underlyingArray[i]["_destroy"] = true;
        }
        this.valueHasMutated();
    },

    'destroyAll': function (arrayOfValues) {
        // If you passed zero args, we destroy everything
        if (arrayOfValues === undefined)
            return this['destroy'](function() { return true });

        // If you passed an arg, we interpret it as an array of entries to destroy
        if (!arrayOfValues)
            return [];
        return this['destroy'](function (value) {
            return ko.utils.arrayIndexOf(arrayOfValues, value) >= 0;
        });
    },

    'indexOf': function (item) {
        var underlyingArray = this();
        return ko.utils.arrayIndexOf(underlyingArray, item);
    },

    'replace': function(oldItem, newItem) {
        var index = this['indexOf'](oldItem);
        if (index >= 0) {
            this.valueWillMutate();
            this.peek()[index] = newItem;
            this.valueHasMutated();
        }
    }
};

// Populate ko.observableArray.fn with read/write functions from native arrays
// Important: Do not add any additional functions here that may reasonably be used to *read* data from the array
// because we'll eval them without causing subscriptions, so ko.computed output could end up getting stale
ko.utils.arrayForEach(["pop", "push", "reverse", "shift", "sort", "splice", "unshift"], function (methodName) {
    ko.observableArray['fn'][methodName] = function () {
        // Use "peek" to avoid creating a subscription in any computed that we're executing in the context of
        // (for consistency with mutating regular observables)
        var underlyingArray = this.peek();
        this.valueWillMutate();
        this.cacheDiffForKnownOperation(underlyingArray, methodName, arguments);
        var methodCallResult = underlyingArray[methodName].apply(underlyingArray, arguments);
        this.valueHasMutated();
        return methodCallResult;
    };
});

// Populate ko.observableArray.fn with read-only functions from native arrays
ko.utils.arrayForEach(["slice"], function (methodName) {
    ko.observableArray['fn'][methodName] = function () {
        var underlyingArray = this();
        return underlyingArray[methodName].apply(underlyingArray, arguments);
    };
});

// Note that for browsers that don't support proto assignment, the
// inheritance chain is created manually in the ko.observableArray constructor
if (ko.utils.canSetPrototype) {
    ko.utils.setPrototypeOf(ko.observableArray['fn'], ko.observable['fn']);
}

ko.exportSymbol('observableArray', ko.observableArray);
var arrayChangeEventName = 'arrayChange';
ko.extenders['trackArrayChanges'] = function(target) {
    // Only modify the target observable once
    if (target.cacheDiffForKnownOperation) {
        return;
    }
    var trackingChanges = false,
        cachedDiff = null,
        pendingNotifications = 0,
        underlyingSubscribeFunction = target.subscribe;

    // Intercept "subscribe" calls, and for array change events, ensure change tracking is enabled
    target.subscribe = target['subscribe'] = function(callback, callbackTarget, event) {
        if (event === arrayChangeEventName) {
            trackChanges();
        }
        return underlyingSubscribeFunction.apply(this, arguments);
    };

    function trackChanges() {
        // Calling 'trackChanges' multiple times is the same as calling it once
        if (trackingChanges) {
            return;
        }

        trackingChanges = true;

        // Intercept "notifySubscribers" to track how many times it was called.
        var underlyingNotifySubscribersFunction = target['notifySubscribers'];
        target['notifySubscribers'] = function(valueToNotify, event) {
            if (!event || event === defaultEvent) {
                ++pendingNotifications;
            }
            return underlyingNotifySubscribersFunction.apply(this, arguments);
        };

        // Each time the array changes value, capture a clone so that on the next
        // change it's possible to produce a diff
        var previousContents = [].concat(target.peek() || []);
        cachedDiff = null;
        target.subscribe(function(currentContents) {
            // Make a copy of the current contents and ensure it's an array
            currentContents = [].concat(currentContents || []);

            // Compute the diff and issue notifications, but only if someone is listening
            if (target.hasSubscriptionsForEvent(arrayChangeEventName)) {
                var changes = getChanges(previousContents, currentContents);
                if (changes.length) {
                    target['notifySubscribers'](changes, arrayChangeEventName);
                }
            }

            // Eliminate references to the old, removed items, so they can be GCed
            previousContents = currentContents;
            cachedDiff = null;
            pendingNotifications = 0;
        });
    }

    function getChanges(previousContents, currentContents) {
        // We try to re-use cached diffs.
        // The scenarios where pendingNotifications > 1 are when using rate-limiting or the Deferred Updates
        // plugin, which without this check would not be compatible with arrayChange notifications. Normally,
        // notifications are issued immediately so we wouldn't be queueing up more than one.
        if (!cachedDiff || pendingNotifications > 1) {
            cachedDiff = ko.utils.compareArrays(previousContents, currentContents, { 'sparse': true });
        }

        return cachedDiff;
    }

    target.cacheDiffForKnownOperation = function(rawArray, operationName, args) {
        // Only run if we're currently tracking changes for this observable array
        // and there aren't any pending deferred notifications.
        if (!trackingChanges || pendingNotifications) {
            return;
        }
        var diff = [],
            arrayLength = rawArray.length,
            argsLength = args.length,
            offset = 0;

        function pushDiff(status, value, index) {
            return diff[diff.length] = { 'status': status, 'value': value, 'index': index };
        }
        switch (operationName) {
            case 'push':
                offset = arrayLength;
            case 'unshift':
                for (var index = 0; index < argsLength; index++) {
                    pushDiff('added', args[index], offset + index);
                }
                break;

            case 'pop':
                offset = arrayLength - 1;
            case 'shift':
                if (arrayLength) {
                    pushDiff('deleted', rawArray[offset], offset);
                }
                break;

            case 'splice':
                // Negative start index means 'from end of array'. After that we clamp to [0...arrayLength].
                // See https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice
                var startIndex = Math.min(Math.max(0, args[0] < 0 ? arrayLength + args[0] : args[0]), arrayLength),
                    endDeleteIndex = argsLength === 1 ? arrayLength : Math.min(startIndex + (args[1] || 0), arrayLength),
                    endAddIndex = startIndex + argsLength - 2,
                    endIndex = Math.max(endDeleteIndex, endAddIndex),
                    additions = [], deletions = [];
                for (var index = startIndex, argsIndex = 2; index < endIndex; ++index, ++argsIndex) {
                    if (index < endDeleteIndex)
                        deletions.push(pushDiff('deleted', rawArray[index], index));
                    if (index < endAddIndex)
                        additions.push(pushDiff('added', args[argsIndex], index));
                }
                ko.utils.findMovesInArrayComparison(deletions, additions);
                break;

            default:
                return;
        }
        cachedDiff = diff;
    };
};
ko.computed = ko.dependentObservable = function (evaluatorFunctionOrOptions, evaluatorFunctionTarget, options) {
    var _latestValue,
        _needsEvaluation = true,
        _isBeingEvaluated = false,
        _suppressDisposalUntilDisposeWhenReturnsFalse = false,
        _isDisposed = false,
        readFunction = evaluatorFunctionOrOptions,
        pure = false,
        isSleeping = false;

    if (readFunction && typeof readFunction == "object") {
        // Single-parameter syntax - everything is on this "options" param
        options = readFunction;
        readFunction = options["read"];
    } else {
        // Multi-parameter syntax - construct the options according to the params passed
        options = options || {};
        if (!readFunction)
            readFunction = options["read"];
    }
    if (typeof readFunction != "function")
        throw new Error("Pass a function that returns the value of the ko.computed");

    function addSubscriptionToDependency(subscribable, id) {
        if (!_subscriptionsToDependencies[id]) {
            _subscriptionsToDependencies[id] = subscribable.subscribe(evaluatePossiblyAsync);
            ++_dependenciesCount;
        }
    }

    function disposeAllSubscriptionsToDependencies() {
        ko.utils.objectForEach(_subscriptionsToDependencies, function (id, subscription) {
            subscription.dispose();
        });
        _subscriptionsToDependencies = {};
    }

    function disposeComputed() {
        disposeAllSubscriptionsToDependencies();
        _dependenciesCount = 0;
        _isDisposed = true;
        _needsEvaluation = false;
    }

    function evaluatePossiblyAsync() {
        var throttleEvaluationTimeout = dependentObservable['throttleEvaluation'];
        if (throttleEvaluationTimeout && throttleEvaluationTimeout >= 0) {
            clearTimeout(evaluationTimeoutInstance);
            evaluationTimeoutInstance = setTimeout(evaluateImmediate, throttleEvaluationTimeout);
        } else if (dependentObservable._evalRateLimited) {
            dependentObservable._evalRateLimited();
        } else {
            evaluateImmediate();
        }
    }

    function evaluateImmediate(suppressChangeNotification) {
        if (_isBeingEvaluated) {
            if (pure) {
                throw Error("A 'pure' computed must not be called recursively");
            }
            // If the evaluation of a ko.computed causes side effects, it's possible that it will trigger its own re-evaluation.
            // This is not desirable (it's hard for a developer to realise a chain of dependencies might cause this, and they almost
            // certainly didn't intend infinite re-evaluations). So, for predictability, we simply prevent ko.computeds from causing
            // their own re-evaluation. Further discussion at https://github.com/SteveSanderson/knockout/pull/387
            return;
        }

        // Do not evaluate (and possibly capture new dependencies) if disposed
        if (_isDisposed) {
            return;
        }

        if (disposeWhen && disposeWhen()) {
            // See comment below about _suppressDisposalUntilDisposeWhenReturnsFalse
            if (!_suppressDisposalUntilDisposeWhenReturnsFalse) {
                dispose();
                return;
            }
        } else {
            // It just did return false, so we can stop suppressing now
            _suppressDisposalUntilDisposeWhenReturnsFalse = false;
        }

        _isBeingEvaluated = true;

        // When sleeping, recalculate the value and return.
        if (isSleeping) {
            try {
                var dependencyTracking = {};
                ko.dependencyDetection.begin({
                    callback: function (subscribable, id) {
                        if (!dependencyTracking[id]) {
                            dependencyTracking[id] = 1;
                            ++_dependenciesCount;
                        }
                    },
                    computed: dependentObservable,
                    isInitial: undefined
                });
                _dependenciesCount = 0;
                _latestValue = readFunction.call(evaluatorFunctionTarget);
            } finally {
                ko.dependencyDetection.end();
                _isBeingEvaluated = false;
            }
        } else {
            try {
                // Initially, we assume that none of the subscriptions are still being used (i.e., all are candidates for disposal).
                // Then, during evaluation, we cross off any that are in fact still being used.
                var disposalCandidates = _subscriptionsToDependencies, disposalCount = _dependenciesCount;
                ko.dependencyDetection.begin({
                    callback: function(subscribable, id) {
                        if (!_isDisposed) {
                            if (disposalCount && disposalCandidates[id]) {
                                // Don't want to dispose this subscription, as it's still being used
                                _subscriptionsToDependencies[id] = disposalCandidates[id];
                                ++_dependenciesCount;
                                delete disposalCandidates[id];
                                --disposalCount;
                            } else {
                                // Brand new subscription - add it
                                addSubscriptionToDependency(subscribable, id);
                            }
                        }
                    },
                    computed: dependentObservable,
                    isInitial: pure ? undefined : !_dependenciesCount        // If we're evaluating when there are no previous dependencies, it must be the first time
                });

                _subscriptionsToDependencies = {};
                _dependenciesCount = 0;

                try {
                    var newValue = evaluatorFunctionTarget ? readFunction.call(evaluatorFunctionTarget) : readFunction();

                } finally {
                    ko.dependencyDetection.end();

                    // For each subscription no longer being used, remove it from the active subscriptions list and dispose it
                    if (disposalCount) {
                        ko.utils.objectForEach(disposalCandidates, function(id, toDispose) {
                            toDispose.dispose();
                        });
                    }

                    _needsEvaluation = false;
                }

                if (dependentObservable.isDifferent(_latestValue, newValue)) {
                    dependentObservable["notifySubscribers"](_latestValue, "beforeChange");

                    _latestValue = newValue;
                    if (DEBUG) dependentObservable._latestValue = _latestValue;

                    if (suppressChangeNotification !== true) {  // Check for strict true value since setTimeout in Firefox passes a numeric value to the function
                        dependentObservable["notifySubscribers"](_latestValue);
                    }
                }
            } finally {
                _isBeingEvaluated = false;
            }
        }

        if (!_dependenciesCount)
            dispose();
    }

    function dependentObservable() {
        if (arguments.length > 0) {
            if (typeof writeFunction === "function") {
                // Writing a value
                writeFunction.apply(evaluatorFunctionTarget, arguments);
            } else {
                throw new Error("Cannot write a value to a ko.computed unless you specify a 'write' option. If you wish to read the current value, don't pass any parameters.");
            }
            return this; // Permits chained assignments
        } else {
            // Reading the value
            ko.dependencyDetection.registerDependency(dependentObservable);
            if (_needsEvaluation)
                evaluateImmediate(true /* suppressChangeNotification */);
            return _latestValue;
        }
    }

    function peek() {
        // Peek won't re-evaluate, except to get the initial value when "deferEvaluation" is set, or while the computed is sleeping.
        // Those are the only times that both of these conditions will be satisfied.
        if (_needsEvaluation && !_dependenciesCount)
            evaluateImmediate(true /* suppressChangeNotification */);
        return _latestValue;
    }

    function isActive() {
        return _needsEvaluation || _dependenciesCount > 0;
    }

    // By here, "options" is always non-null
    var writeFunction = options["write"],
        disposeWhenNodeIsRemoved = options["disposeWhenNodeIsRemoved"] || options.disposeWhenNodeIsRemoved || null,
        disposeWhenOption = options["disposeWhen"] || options.disposeWhen,
        disposeWhen = disposeWhenOption,
        dispose = disposeComputed,
        _subscriptionsToDependencies = {},
        _dependenciesCount = 0,
        evaluationTimeoutInstance = null;

    if (!evaluatorFunctionTarget)
        evaluatorFunctionTarget = options["owner"];

    ko.subscribable.call(dependentObservable);
    ko.utils.setPrototypeOfOrExtend(dependentObservable, ko.dependentObservable['fn']);

    dependentObservable.peek = peek;
    dependentObservable.getDependenciesCount = function () { return _dependenciesCount; };
    dependentObservable.hasWriteFunction = typeof options["write"] === "function";
    dependentObservable.dispose = function () { dispose(); };
    dependentObservable.isActive = isActive;

    // Replace the limit function with one that delays evaluation as well.
    var originalLimit = dependentObservable.limit;
    dependentObservable.limit = function(limitFunction) {
        originalLimit.call(dependentObservable, limitFunction);
        dependentObservable._evalRateLimited = function() {
            dependentObservable._rateLimitedBeforeChange(_latestValue);

            _needsEvaluation = true;    // Mark as dirty

            // Pass the observable to the rate-limit code, which will access it when
            // it's time to do the notification.
            dependentObservable._rateLimitedChange(dependentObservable);
        }
    };

    if (options['pure']) {
        pure = true;
        isSleeping = true;     // Starts off sleeping; will awake on the first subscription
        dependentObservable.beforeSubscriptionAdd = function () {
            // If asleep, wake up the computed and evaluate to register any dependencies.
            if (isSleeping) {
                isSleeping = false;
                evaluateImmediate(true /* suppressChangeNotification */);
            }
        }
        dependentObservable.afterSubscriptionRemove = function () {
            if (!dependentObservable.getSubscriptionsCount()) {
                disposeAllSubscriptionsToDependencies();
                isSleeping = _needsEvaluation = true;
            }
        }
    } else if (options['deferEvaluation']) {
        // This will force a computed with deferEvaluation to evaluate when the first subscriptions is registered.
        dependentObservable.beforeSubscriptionAdd = function () {
            peek();
            delete dependentObservable.beforeSubscriptionAdd;
        }
    }

    ko.exportProperty(dependentObservable, 'peek', dependentObservable.peek);
    ko.exportProperty(dependentObservable, 'dispose', dependentObservable.dispose);
    ko.exportProperty(dependentObservable, 'isActive', dependentObservable.isActive);
    ko.exportProperty(dependentObservable, 'getDependenciesCount', dependentObservable.getDependenciesCount);

    // Add a "disposeWhen" callback that, on each evaluation, disposes if the node was removed without using ko.removeNode.
    if (disposeWhenNodeIsRemoved) {
        // Since this computed is associated with a DOM node, and we don't want to dispose the computed
        // until the DOM node is *removed* from the document (as opposed to never having been in the document),
        // we'll prevent disposal until "disposeWhen" first returns false.
        _suppressDisposalUntilDisposeWhenReturnsFalse = true;

        // Only watch for the node's disposal if the value really is a node. It might not be,
        // e.g., { disposeWhenNodeIsRemoved: true } can be used to opt into the "only dispose
        // after first false result" behaviour even if there's no specific node to watch. This
        // technique is intended for KO's internal use only and shouldn't be documented or used
        // by application code, as it's likely to change in a future version of KO.
        if (disposeWhenNodeIsRemoved.nodeType) {
            disposeWhen = function () {
                return !ko.utils.domNodeIsAttachedToDocument(disposeWhenNodeIsRemoved) || (disposeWhenOption && disposeWhenOption());
            };
        }
    }

    // Evaluate, unless sleeping or deferEvaluation is true
    if (!isSleeping && !options['deferEvaluation'])
        evaluateImmediate();

    // Attach a DOM node disposal callback so that the computed will be proactively disposed as soon as the node is
    // removed using ko.removeNode. But skip if isActive is false (there will never be any dependencies to dispose).
    if (disposeWhenNodeIsRemoved && isActive() && disposeWhenNodeIsRemoved.nodeType) {
        dispose = function() {
            ko.utils.domNodeDisposal.removeDisposeCallback(disposeWhenNodeIsRemoved, dispose);
            disposeComputed();
        };
        ko.utils.domNodeDisposal.addDisposeCallback(disposeWhenNodeIsRemoved, dispose);
    }

    return dependentObservable;
};

ko.isComputed = function(instance) {
    return ko.hasPrototype(instance, ko.dependentObservable);
};

var protoProp = ko.observable.protoProperty; // == "__ko_proto__"
ko.dependentObservable[protoProp] = ko.observable;

ko.dependentObservable['fn'] = {
    "equalityComparer": valuesArePrimitiveAndEqual
};
ko.dependentObservable['fn'][protoProp] = ko.dependentObservable;

// Note that for browsers that don't support proto assignment, the
// inheritance chain is created manually in the ko.dependentObservable constructor
if (ko.utils.canSetPrototype) {
    ko.utils.setPrototypeOf(ko.dependentObservable['fn'], ko.subscribable['fn']);
}

ko.exportSymbol('dependentObservable', ko.dependentObservable);
ko.exportSymbol('computed', ko.dependentObservable); // Make "ko.computed" an alias for "ko.dependentObservable"
ko.exportSymbol('isComputed', ko.isComputed);

ko.pureComputed = function (evaluatorFunctionOrOptions, evaluatorFunctionTarget) {
    if (typeof evaluatorFunctionOrOptions === 'function') {
        return ko.computed(evaluatorFunctionOrOptions, evaluatorFunctionTarget, {'pure':true});
    } else {
        evaluatorFunctionOrOptions = ko.utils.extend({}, evaluatorFunctionOrOptions);   // make a copy of the parameter object
        evaluatorFunctionOrOptions['pure'] = true;
        return ko.computed(evaluatorFunctionOrOptions, evaluatorFunctionTarget);
    }
}
ko.exportSymbol('pureComputed', ko.pureComputed);

(function() {
    var maxNestedObservableDepth = 10; // Escape the (unlikely) pathalogical case where an observable's current value is itself (or similar reference cycle)

    ko.toJS = function(rootObject) {
        if (arguments.length == 0)
            throw new Error("When calling ko.toJS, pass the object you want to convert.");

        // We just unwrap everything at every level in the object graph
        return mapJsObjectGraph(rootObject, function(valueToMap) {
            // Loop because an observable's value might in turn be another observable wrapper
            for (var i = 0; ko.isObservable(valueToMap) && (i < maxNestedObservableDepth); i++)
                valueToMap = valueToMap();
            return valueToMap;
        });
    };

    ko.toJSON = function(rootObject, replacer, space) {     // replacer and space are optional
        var plainJavaScriptObject = ko.toJS(rootObject);
        return ko.utils.stringifyJson(plainJavaScriptObject, replacer, space);
    };

    function mapJsObjectGraph(rootObject, mapInputCallback, visitedObjects) {
        visitedObjects = visitedObjects || new objectLookup();

        rootObject = mapInputCallback(rootObject);
        var canHaveProperties = (typeof rootObject == "object") && (rootObject !== null) && (rootObject !== undefined) && (!(rootObject instanceof Date)) && (!(rootObject instanceof String)) && (!(rootObject instanceof Number)) && (!(rootObject instanceof Boolean));
        if (!canHaveProperties)
            return rootObject;

        var outputProperties = rootObject instanceof Array ? [] : {};
        visitedObjects.save(rootObject, outputProperties);

        visitPropertiesOrArrayEntries(rootObject, function(indexer) {
            var propertyValue = mapInputCallback(rootObject[indexer]);

            switch (typeof propertyValue) {
                case "boolean":
                case "number":
                case "string":
                case "function":
                    outputProperties[indexer] = propertyValue;
                    break;
                case "object":
                case "undefined":
                    var previouslyMappedValue = visitedObjects.get(propertyValue);
                    outputProperties[indexer] = (previouslyMappedValue !== undefined)
                        ? previouslyMappedValue
                        : mapJsObjectGraph(propertyValue, mapInputCallback, visitedObjects);
                    break;
            }
        });

        return outputProperties;
    }

    function visitPropertiesOrArrayEntries(rootObject, visitorCallback) {
        if (rootObject instanceof Array) {
            for (var i = 0; i < rootObject.length; i++)
                visitorCallback(i);

            // For arrays, also respect toJSON property for custom mappings (fixes #278)
            if (typeof rootObject['toJSON'] == 'function')
                visitorCallback('toJSON');
        } else {
            for (var propertyName in rootObject) {
                visitorCallback(propertyName);
            }
        }
    };

    function objectLookup() {
        this.keys = [];
        this.values = [];
    };

    objectLookup.prototype = {
        constructor: objectLookup,
        save: function(key, value) {
            var existingIndex = ko.utils.arrayIndexOf(this.keys, key);
            if (existingIndex >= 0)
                this.values[existingIndex] = value;
            else {
                this.keys.push(key);
                this.values.push(value);
            }
        },
        get: function(key) {
            var existingIndex = ko.utils.arrayIndexOf(this.keys, key);
            return (existingIndex >= 0) ? this.values[existingIndex] : undefined;
        }
    };
})();

ko.exportSymbol('toJS', ko.toJS);
ko.exportSymbol('toJSON', ko.toJSON);
(function () {
    var hasDomDataExpandoProperty = '__ko__hasDomDataOptionValue__';

    // Normally, SELECT elements and their OPTIONs can only take value of type 'string' (because the values
    // are stored on DOM attributes). ko.selectExtensions provides a way for SELECTs/OPTIONs to have values
    // that are arbitrary objects. This is very convenient when implementing things like cascading dropdowns.
    ko.selectExtensions = {
        readValue : function(element) {
            switch (ko.utils.tagNameLower(element)) {
                case 'option':
                    if (element[hasDomDataExpandoProperty] === true)
                        return ko.utils.domData.get(element, ko.bindingHandlers.options.optionValueDomDataKey);
                    return ko.utils.ieVersion <= 7
                        ? (element.getAttributeNode('value') && element.getAttributeNode('value').specified ? element.value : element.text)
                        : element.value;
                case 'select':
                    return element.selectedIndex >= 0 ? ko.selectExtensions.readValue(element.options[element.selectedIndex]) : undefined;
                default:
                    return element.value;
            }
        },

        writeValue: function(element, value, allowUnset) {
            switch (ko.utils.tagNameLower(element)) {
                case 'option':
                    switch(typeof value) {
                        case "string":
                            ko.utils.domData.set(element, ko.bindingHandlers.options.optionValueDomDataKey, undefined);
                            if (hasDomDataExpandoProperty in element) { // IE <= 8 throws errors if you delete non-existent properties from a DOM node
                                delete element[hasDomDataExpandoProperty];
                            }
                            element.value = value;
                            break;
                        default:
                            // Store arbitrary object using DomData
                            ko.utils.domData.set(element, ko.bindingHandlers.options.optionValueDomDataKey, value);
                            element[hasDomDataExpandoProperty] = true;

                            // Special treatment of numbers is just for backward compatibility. KO 1.2.1 wrote numerical values to element.value.
                            element.value = typeof value === "number" ? value : "";
                            break;
                    }
                    break;
                case 'select':
                    if (value === "" || value === null)       // A blank string or null value will select the caption
                        value = undefined;
                    var selection = -1;
                    for (var i = 0, n = element.options.length, optionValue; i < n; ++i) {
                        optionValue = ko.selectExtensions.readValue(element.options[i]);
                        // Include special check to handle selecting a caption with a blank string value
                        if (optionValue == value || (optionValue == "" && value === undefined)) {
                            selection = i;
                            break;
                        }
                    }
                    if (allowUnset || selection >= 0 || (value === undefined && element.size > 1)) {
                        element.selectedIndex = selection;
                    }
                    break;
                default:
                    if ((value === null) || (value === undefined))
                        value = "";
                    element.value = value;
                    break;
            }
        }
    };
})();

ko.exportSymbol('selectExtensions', ko.selectExtensions);
ko.exportSymbol('selectExtensions.readValue', ko.selectExtensions.readValue);
ko.exportSymbol('selectExtensions.writeValue', ko.selectExtensions.writeValue);
ko.expressionRewriting = (function () {
    var javaScriptReservedWords = ["true", "false", "null", "undefined"];

    // Matches something that can be assigned to--either an isolated identifier or something ending with a property accessor
    // This is designed to be simple and avoid false negatives, but could produce false positives (e.g., a+b.c).
    // This also will not properly handle nested brackets (e.g., obj1[obj2['prop']]; see #911).
    var javaScriptAssignmentTarget = /^(?:[$_a-z][$\w]*|(.+)(\.\s*[$_a-z][$\w]*|\[.+\]))$/i;

    function getWriteableValue(expression) {
        if (ko.utils.arrayIndexOf(javaScriptReservedWords, expression) >= 0)
            return false;
        var match = expression.match(javaScriptAssignmentTarget);
        return match === null ? false : match[1] ? ('Object(' + match[1] + ')' + match[2]) : expression;
    }

    // The following regular expressions will be used to split an object-literal string into tokens

        // These two match strings, either with double quotes or single quotes
    var stringDouble = '"(?:[^"\\\\]|\\\\.)*"',
        stringSingle = "'(?:[^'\\\\]|\\\\.)*'",
        // Matches a regular expression (text enclosed by slashes), but will also match sets of divisions
        // as a regular expression (this is handled by the parsing loop below).
        stringRegexp = '/(?:[^/\\\\]|\\\\.)*/\w*',
        // These characters have special meaning to the parser and must not appear in the middle of a
        // token, except as part of a string.
        specials = ',"\'{}()/:[\\]',
        // Match text (at least two characters) that does not contain any of the above special characters,
        // although some of the special characters are allowed to start it (all but the colon and comma).
        // The text can contain spaces, but leading or trailing spaces are skipped.
        everyThingElse = '[^\\s:,/][^' + specials + ']*[^\\s' + specials + ']',
        // Match any non-space character not matched already. This will match colons and commas, since they're
        // not matched by "everyThingElse", but will also match any other single character that wasn't already
        // matched (for example: in "a: 1, b: 2", each of the non-space characters will be matched by oneNotSpace).
        oneNotSpace = '[^\\s]',

        // Create the actual regular expression by or-ing the above strings. The order is important.
        bindingToken = RegExp(stringDouble + '|' + stringSingle + '|' + stringRegexp + '|' + everyThingElse + '|' + oneNotSpace, 'g'),

        // Match end of previous token to determine whether a slash is a division or regex.
        divisionLookBehind = /[\])"'A-Za-z0-9_$]+$/,
        keywordRegexLookBehind = {'in':1,'return':1,'typeof':1};

    function parseObjectLiteral(objectLiteralString) {
        // Trim leading and trailing spaces from the string
        var str = ko.utils.stringTrim(objectLiteralString);

        // Trim braces '{' surrounding the whole object literal
        if (str.charCodeAt(0) === 123) str = str.slice(1, -1);

        // Split into tokens
        var result = [], toks = str.match(bindingToken), key, values, depth = 0;

        if (toks) {
            // Append a comma so that we don't need a separate code block to deal with the last item
            toks.push(',');

            for (var i = 0, tok; tok = toks[i]; ++i) {
                var c = tok.charCodeAt(0);
                // A comma signals the end of a key/value pair if depth is zero
                if (c === 44) { // ","
                    if (depth <= 0) {
                        if (key)
                            result.push(values ? {key: key, value: values.join('')} : {'unknown': key});
                        key = values = depth = 0;
                        continue;
                    }
                // Simply skip the colon that separates the name and value
                } else if (c === 58) { // ":"
                    if (!values)
                        continue;
                // A set of slashes is initially matched as a regular expression, but could be division
                } else if (c === 47 && i && tok.length > 1) {  // "/"
                    // Look at the end of the previous token to determine if the slash is actually division
                    var match = toks[i-1].match(divisionLookBehind);
                    if (match && !keywordRegexLookBehind[match[0]]) {
                        // The slash is actually a division punctuator; re-parse the remainder of the string (not including the slash)
                        str = str.substr(str.indexOf(tok) + 1);
                        toks = str.match(bindingToken);
                        toks.push(',');
                        i = -1;
                        // Continue with just the slash
                        tok = '/';
                    }
                // Increment depth for parentheses, braces, and brackets so that interior commas are ignored
                } else if (c === 40 || c === 123 || c === 91) { // '(', '{', '['
                    ++depth;
                } else if (c === 41 || c === 125 || c === 93) { // ')', '}', ']'
                    --depth;
                // The key must be a single token; if it's a string, trim the quotes
                } else if (!key && !values) {
                    key = (c === 34 || c === 39) /* '"', "'" */ ? tok.slice(1, -1) : tok;
                    continue;
                }
                if (values)
                    values.push(tok);
                else
                    values = [tok];
            }
        }
        return result;
    }

    // Two-way bindings include a write function that allow the handler to update the value even if it's not an observable.
    var twoWayBindings = {};

    function preProcessBindings(bindingsStringOrKeyValueArray, bindingOptions) {
        bindingOptions = bindingOptions || {};

        function processKeyValue(key, val) {
            var writableVal;
            function callPreprocessHook(obj) {
                return (obj && obj['preprocess']) ? (val = obj['preprocess'](val, key, processKeyValue)) : true;
            }
            if (!bindingParams) {
                if (!callPreprocessHook(ko['getBindingHandler'](key)))
                    return;

                if (twoWayBindings[key] && (writableVal = getWriteableValue(val))) {
                    // For two-way bindings, provide a write method in case the value
                    // isn't a writable observable.
                    propertyAccessorResultStrings.push("'" + key + "':function(_z){" + writableVal + "=_z}");
                }
            }
            // Values are wrapped in a function so that each value can be accessed independently
            if (makeValueAccessors) {
                val = 'function(){return ' + val + ' }';
            }
            resultStrings.push("'" + key + "':" + val);
        }

        var resultStrings = [],
            propertyAccessorResultStrings = [],
            makeValueAccessors = bindingOptions['valueAccessors'],
            bindingParams = bindingOptions['bindingParams'],
            keyValueArray = typeof bindingsStringOrKeyValueArray === "string" ?
                parseObjectLiteral(bindingsStringOrKeyValueArray) : bindingsStringOrKeyValueArray;

        ko.utils.arrayForEach(keyValueArray, function(keyValue) {
            processKeyValue(keyValue.key || keyValue['unknown'], keyValue.value);
        });

        if (propertyAccessorResultStrings.length)
            processKeyValue('_ko_property_writers', "{" + propertyAccessorResultStrings.join(",") + " }");

        return resultStrings.join(",");
    }

    return {
        bindingRewriteValidators: [],

        twoWayBindings: twoWayBindings,

        parseObjectLiteral: parseObjectLiteral,

        preProcessBindings: preProcessBindings,

        keyValueArrayContainsKey: function(keyValueArray, key) {
            for (var i = 0; i < keyValueArray.length; i++)
                if (keyValueArray[i]['key'] == key)
                    return true;
            return false;
        },

        // Internal, private KO utility for updating model properties from within bindings
        // property:            If the property being updated is (or might be) an observable, pass it here
        //                      If it turns out to be a writable observable, it will be written to directly
        // allBindings:         An object with a get method to retrieve bindings in the current execution context.
        //                      This will be searched for a '_ko_property_writers' property in case you're writing to a non-observable
        // key:                 The key identifying the property to be written. Example: for { hasFocus: myValue }, write to 'myValue' by specifying the key 'hasFocus'
        // value:               The value to be written
        // checkIfDifferent:    If true, and if the property being written is a writable observable, the value will only be written if
        //                      it is !== existing value on that writable observable
        writeValueToProperty: function(property, allBindings, key, value, checkIfDifferent) {
            if (!property || !ko.isObservable(property)) {
                var propWriters = allBindings.get('_ko_property_writers');
                if (propWriters && propWriters[key])
                    propWriters[key](value);
            } else if (ko.isWriteableObservable(property) && (!checkIfDifferent || property.peek() !== value)) {
                property(value);
            }
        }
    };
})();

ko.exportSymbol('expressionRewriting', ko.expressionRewriting);
ko.exportSymbol('expressionRewriting.bindingRewriteValidators', ko.expressionRewriting.bindingRewriteValidators);
ko.exportSymbol('expressionRewriting.parseObjectLiteral', ko.expressionRewriting.parseObjectLiteral);
ko.exportSymbol('expressionRewriting.preProcessBindings', ko.expressionRewriting.preProcessBindings);

// Making bindings explicitly declare themselves as "two way" isn't ideal in the long term (it would be better if
// all bindings could use an official 'property writer' API without needing to declare that they might). However,
// since this is not, and has never been, a public API (_ko_property_writers was never documented), it's acceptable
// as an internal implementation detail in the short term.
// For those developers who rely on _ko_property_writers in their custom bindings, we expose _twoWayBindings as an
// undocumented feature that makes it relatively easy to upgrade to KO 3.0. However, this is still not an official
// public API, and we reserve the right to remove it at any time if we create a real public property writers API.
ko.exportSymbol('expressionRewriting._twoWayBindings', ko.expressionRewriting.twoWayBindings);

// For backward compatibility, define the following aliases. (Previously, these function names were misleading because
// they referred to JSON specifically, even though they actually work with arbitrary JavaScript object literal expressions.)
ko.exportSymbol('jsonExpressionRewriting', ko.expressionRewriting);
ko.exportSymbol('jsonExpressionRewriting.insertPropertyAccessorsIntoJson', ko.expressionRewriting.preProcessBindings);
(function() {
    // "Virtual elements" is an abstraction on top of the usual DOM API which understands the notion that comment nodes
    // may be used to represent hierarchy (in addition to the DOM's natural hierarchy).
    // If you call the DOM-manipulating functions on ko.virtualElements, you will be able to read and write the state
    // of that virtual hierarchy
    //
    // The point of all this is to support containerless templates (e.g., <!-- ko foreach:someCollection -->blah<!-- /ko -->)
    // without having to scatter special cases all over the binding and templating code.

    // IE 9 cannot reliably read the "nodeValue" property of a comment node (see https://github.com/SteveSanderson/knockout/issues/186)
    // but it does give them a nonstandard alternative property called "text" that it can read reliably. Other browsers don't have that property.
    // So, use node.text where available, and node.nodeValue elsewhere
    var commentNodesHaveTextProperty = document && document.createComment("test").text === "<!--test-->";

    var startCommentRegex = commentNodesHaveTextProperty ? /^<!--\s*ko(?:\s+([\s\S]+))?\s*-->$/ : /^\s*ko(?:\s+([\s\S]+))?\s*$/;
    var endCommentRegex =   commentNodesHaveTextProperty ? /^<!--\s*\/ko\s*-->$/ : /^\s*\/ko\s*$/;
    var htmlTagsWithOptionallyClosingChildren = { 'ul': true, 'ol': true };

    function isStartComment(node) {
        return (node.nodeType == 8) && startCommentRegex.test(commentNodesHaveTextProperty ? node.text : node.nodeValue);
    }

    function isEndComment(node) {
        return (node.nodeType == 8) && endCommentRegex.test(commentNodesHaveTextProperty ? node.text : node.nodeValue);
    }

    function getVirtualChildren(startComment, allowUnbalanced) {
        var currentNode = startComment;
        var depth = 1;
        var children = [];
        while (currentNode = currentNode.nextSibling) {
            if (isEndComment(currentNode)) {
                depth--;
                if (depth === 0)
                    return children;
            }

            children.push(currentNode);

            if (isStartComment(currentNode))
                depth++;
        }
        if (!allowUnbalanced)
            throw new Error("Cannot find closing comment tag to match: " + startComment.nodeValue);
        return null;
    }

    function getMatchingEndComment(startComment, allowUnbalanced) {
        var allVirtualChildren = getVirtualChildren(startComment, allowUnbalanced);
        if (allVirtualChildren) {
            if (allVirtualChildren.length > 0)
                return allVirtualChildren[allVirtualChildren.length - 1].nextSibling;
            return startComment.nextSibling;
        } else
            return null; // Must have no matching end comment, and allowUnbalanced is true
    }

    function getUnbalancedChildTags(node) {
        // e.g., from <div>OK</div><!-- ko blah --><span>Another</span>, returns: <!-- ko blah --><span>Another</span>
        //       from <div>OK</div><!-- /ko --><!-- /ko -->,             returns: <!-- /ko --><!-- /ko -->
        var childNode = node.firstChild, captureRemaining = null;
        if (childNode) {
            do {
                if (captureRemaining)                   // We already hit an unbalanced node and are now just scooping up all subsequent nodes
                    captureRemaining.push(childNode);
                else if (isStartComment(childNode)) {
                    var matchingEndComment = getMatchingEndComment(childNode, /* allowUnbalanced: */ true);
                    if (matchingEndComment)             // It's a balanced tag, so skip immediately to the end of this virtual set
                        childNode = matchingEndComment;
                    else
                        captureRemaining = [childNode]; // It's unbalanced, so start capturing from this point
                } else if (isEndComment(childNode)) {
                    captureRemaining = [childNode];     // It's unbalanced (if it wasn't, we'd have skipped over it already), so start capturing
                }
            } while (childNode = childNode.nextSibling);
        }
        return captureRemaining;
    }

    ko.virtualElements = {
        allowedBindings: {},

        childNodes: function(node) {
            return isStartComment(node) ? getVirtualChildren(node) : node.childNodes;
        },

        emptyNode: function(node) {
            if (!isStartComment(node))
                ko.utils.emptyDomNode(node);
            else {
                var virtualChildren = ko.virtualElements.childNodes(node);
                for (var i = 0, j = virtualChildren.length; i < j; i++)
                    ko.removeNode(virtualChildren[i]);
            }
        },

        setDomNodeChildren: function(node, childNodes) {
            if (!isStartComment(node))
                ko.utils.setDomNodeChildren(node, childNodes);
            else {
                ko.virtualElements.emptyNode(node);
                var endCommentNode = node.nextSibling; // Must be the next sibling, as we just emptied the children
                for (var i = 0, j = childNodes.length; i < j; i++)
                    endCommentNode.parentNode.insertBefore(childNodes[i], endCommentNode);
            }
        },

        prepend: function(containerNode, nodeToPrepend) {
            if (!isStartComment(containerNode)) {
                if (containerNode.firstChild)
                    containerNode.insertBefore(nodeToPrepend, containerNode.firstChild);
                else
                    containerNode.appendChild(nodeToPrepend);
            } else {
                // Start comments must always have a parent and at least one following sibling (the end comment)
                containerNode.parentNode.insertBefore(nodeToPrepend, containerNode.nextSibling);
            }
        },

        insertAfter: function(containerNode, nodeToInsert, insertAfterNode) {
            if (!insertAfterNode) {
                ko.virtualElements.prepend(containerNode, nodeToInsert);
            } else if (!isStartComment(containerNode)) {
                // Insert after insertion point
                if (insertAfterNode.nextSibling)
                    containerNode.insertBefore(nodeToInsert, insertAfterNode.nextSibling);
                else
                    containerNode.appendChild(nodeToInsert);
            } else {
                // Children of start comments must always have a parent and at least one following sibling (the end comment)
                containerNode.parentNode.insertBefore(nodeToInsert, insertAfterNode.nextSibling);
            }
        },

        firstChild: function(node) {
            if (!isStartComment(node))
                return node.firstChild;
            if (!node.nextSibling || isEndComment(node.nextSibling))
                return null;
            return node.nextSibling;
        },

        nextSibling: function(node) {
            if (isStartComment(node))
                node = getMatchingEndComment(node);
            if (node.nextSibling && isEndComment(node.nextSibling))
                return null;
            return node.nextSibling;
        },

        hasBindingValue: isStartComment,

        virtualNodeBindingValue: function(node) {
            var regexMatch = (commentNodesHaveTextProperty ? node.text : node.nodeValue).match(startCommentRegex);
            return regexMatch ? regexMatch[1] : null;
        },

        normaliseVirtualElementDomStructure: function(elementVerified) {
            // Workaround for https://github.com/SteveSanderson/knockout/issues/155
            // (IE <= 8 or IE 9 quirks mode parses your HTML weirdly, treating closing </li> tags as if they don't exist, thereby moving comment nodes
            // that are direct descendants of <ul> into the preceding <li>)
            if (!htmlTagsWithOptionallyClosingChildren[ko.utils.tagNameLower(elementVerified)])
                return;

            // Scan immediate children to see if they contain unbalanced comment tags. If they do, those comment tags
            // must be intended to appear *after* that child, so move them there.
            var childNode = elementVerified.firstChild;
            if (childNode) {
                do {
                    if (childNode.nodeType === 1) {
                        var unbalancedTags = getUnbalancedChildTags(childNode);
                        if (unbalancedTags) {
                            // Fix up the DOM by moving the unbalanced tags to where they most likely were intended to be placed - *after* the child
                            var nodeToInsertBefore = childNode.nextSibling;
                            for (var i = 0; i < unbalancedTags.length; i++) {
                                if (nodeToInsertBefore)
                                    elementVerified.insertBefore(unbalancedTags[i], nodeToInsertBefore);
                                else
                                    elementVerified.appendChild(unbalancedTags[i]);
                            }
                        }
                    }
                } while (childNode = childNode.nextSibling);
            }
        }
    };
})();
ko.exportSymbol('virtualElements', ko.virtualElements);
ko.exportSymbol('virtualElements.allowedBindings', ko.virtualElements.allowedBindings);
ko.exportSymbol('virtualElements.emptyNode', ko.virtualElements.emptyNode);
//ko.exportSymbol('virtualElements.firstChild', ko.virtualElements.firstChild);     // firstChild is not minified
ko.exportSymbol('virtualElements.insertAfter', ko.virtualElements.insertAfter);
//ko.exportSymbol('virtualElements.nextSibling', ko.virtualElements.nextSibling);   // nextSibling is not minified
ko.exportSymbol('virtualElements.prepend', ko.virtualElements.prepend);
ko.exportSymbol('virtualElements.setDomNodeChildren', ko.virtualElements.setDomNodeChildren);
(function() {
    var defaultBindingAttributeName = "data-bind";

    ko.bindingProvider = function() {
        this.bindingCache = {};
    };

    ko.utils.extend(ko.bindingProvider.prototype, {
        'nodeHasBindings': function(node) {
            switch (node.nodeType) {
                case 1: // Element
                    return node.getAttribute(defaultBindingAttributeName) != null
                        || ko.components['getComponentNameForNode'](node);
                case 8: // Comment node
                    return ko.virtualElements.hasBindingValue(node);
                default: return false;
            }
        },

        'getBindings': function(node, bindingContext) {
            var bindingsString = this['getBindingsString'](node, bindingContext),
                parsedBindings = bindingsString ? this['parseBindingsString'](bindingsString, bindingContext, node) : null;
            return ko.components.addBindingsForCustomElement(parsedBindings, node, bindingContext, /* valueAccessors */ false);
        },

        'getBindingAccessors': function(node, bindingContext) {
            var bindingsString = this['getBindingsString'](node, bindingContext),
                parsedBindings = bindingsString ? this['parseBindingsString'](bindingsString, bindingContext, node, { 'valueAccessors': true }) : null;
            return ko.components.addBindingsForCustomElement(parsedBindings, node, bindingContext, /* valueAccessors */ true);
        },

        // The following function is only used internally by this default provider.
        // It's not part of the interface definition for a general binding provider.
        'getBindingsString': function(node, bindingContext) {
            switch (node.nodeType) {
                case 1: return node.getAttribute(defaultBindingAttributeName);   // Element
                case 8: return ko.virtualElements.virtualNodeBindingValue(node); // Comment node
                default: return null;
            }
        },

        // The following function is only used internally by this default provider.
        // It's not part of the interface definition for a general binding provider.
        'parseBindingsString': function(bindingsString, bindingContext, node, options) {
            try {
                var bindingFunction = createBindingsStringEvaluatorViaCache(bindingsString, this.bindingCache, options);
                return bindingFunction(bindingContext, node);
            } catch (ex) {
                ex.message = "Unable to parse bindings.\nBindings value: " + bindingsString + "\nMessage: " + ex.message;
                throw ex;
            }
        }
    });

    ko.bindingProvider['instance'] = new ko.bindingProvider();

    function createBindingsStringEvaluatorViaCache(bindingsString, cache, options) {
        var cacheKey = bindingsString + (options && options['valueAccessors'] || '');
        return cache[cacheKey]
            || (cache[cacheKey] = createBindingsStringEvaluator(bindingsString, options));
    }

    function createBindingsStringEvaluator(bindingsString, options) {
        // Build the source for a function that evaluates "expression"
        // For each scope variable, add an extra level of "with" nesting
        // Example result: with(sc1) { with(sc0) { return (expression) } }
        var rewrittenBindings = ko.expressionRewriting.preProcessBindings(bindingsString, options),
            functionBody = "with($context){with($data||{}){return{" + rewrittenBindings + "}}}";
        return new Function("$context", "$element", functionBody);
    }
})();

ko.exportSymbol('bindingProvider', ko.bindingProvider);
(function () {
    ko.bindingHandlers = {};

    // The following element types will not be recursed into during binding. In the future, we
    // may consider adding <template> to this list, because such elements' contents are always
    // intended to be bound in a different context from where they appear in the document.
    var bindingDoesNotRecurseIntoElementTypes = {
        // Don't want bindings that operate on text nodes to mutate <script> contents,
        // because it's unexpected and a potential XSS issue
        'script': true
    };

    // Use an overridable method for retrieving binding handlers so that a plugins may support dynamically created handlers
    ko['getBindingHandler'] = function(bindingKey) {
        return ko.bindingHandlers[bindingKey];
    };

    // The ko.bindingContext constructor is only called directly to create the root context. For child
    // contexts, use bindingContext.createChildContext or bindingContext.extend.
    ko.bindingContext = function(dataItemOrAccessor, parentContext, dataItemAlias, extendCallback) {

        // The binding context object includes static properties for the current, parent, and root view models.
        // If a view model is actually stored in an observable, the corresponding binding context object, and
        // any child contexts, must be updated when the view model is changed.
        function updateContext() {
            // Most of the time, the context will directly get a view model object, but if a function is given,
            // we call the function to retrieve the view model. If the function accesses any obsevables or returns
            // an observable, the dependency is tracked, and those observables can later cause the binding
            // context to be updated.
            var dataItemOrObservable = isFunc ? dataItemOrAccessor() : dataItemOrAccessor,
                dataItem = ko.utils.unwrapObservable(dataItemOrObservable);

            if (parentContext) {
                // When a "parent" context is given, register a dependency on the parent context. Thus whenever the
                // parent context is updated, this context will also be updated.
                if (parentContext._subscribable)
                    parentContext._subscribable();

                // Copy $root and any custom properties from the parent context
                ko.utils.extend(self, parentContext);

                // Because the above copy overwrites our own properties, we need to reset them.
                // During the first execution, "subscribable" isn't set, so don't bother doing the update then.
                if (subscribable) {
                    self._subscribable = subscribable;
                }
            } else {
                self['$parents'] = [];
                self['$root'] = dataItem;

                // Export 'ko' in the binding context so it will be available in bindings and templates
                // even if 'ko' isn't exported as a global, such as when using an AMD loader.
                // See https://github.com/SteveSanderson/knockout/issues/490
                self['ko'] = ko;
            }
            self['$rawData'] = dataItemOrObservable;
            self['$data'] = dataItem;
            if (dataItemAlias)
                self[dataItemAlias] = dataItem;

            // The extendCallback function is provided when creating a child context or extending a context.
            // It handles the specific actions needed to finish setting up the binding context. Actions in this
            // function could also add dependencies to this binding context.
            if (extendCallback)
                extendCallback(self, parentContext, dataItem);

            return self['$data'];
        }
        function disposeWhen() {
            return nodes && !ko.utils.anyDomNodeIsAttachedToDocument(nodes);
        }

        var self = this,
            isFunc = typeof(dataItemOrAccessor) == "function" && !ko.isObservable(dataItemOrAccessor),
            nodes,
            subscribable = ko.dependentObservable(updateContext, null, { disposeWhen: disposeWhen, disposeWhenNodeIsRemoved: true });

        // At this point, the binding context has been initialized, and the "subscribable" computed observable is
        // subscribed to any observables that were accessed in the process. If there is nothing to track, the
        // computed will be inactive, and we can safely throw it away. If it's active, the computed is stored in
        // the context object.
        if (subscribable.isActive()) {
            self._subscribable = subscribable;

            // Always notify because even if the model ($data) hasn't changed, other context properties might have changed
            subscribable['equalityComparer'] = null;

            // We need to be able to dispose of this computed observable when it's no longer needed. This would be
            // easy if we had a single node to watch, but binding contexts can be used by many different nodes, and
            // we cannot assume that those nodes have any relation to each other. So instead we track any node that
            // the context is attached to, and dispose the computed when all of those nodes have been cleaned.

            // Add properties to *subscribable* instead of *self* because any properties added to *self* may be overwritten on updates
            nodes = [];
            subscribable._addNode = function(node) {
                nodes.push(node);
                ko.utils.domNodeDisposal.addDisposeCallback(node, function(node) {
                    ko.utils.arrayRemoveItem(nodes, node);
                    if (!nodes.length) {
                        subscribable.dispose();
                        self._subscribable = subscribable = undefined;
                    }
                });
            };
        }
    }

    // Extend the binding context hierarchy with a new view model object. If the parent context is watching
    // any obsevables, the new child context will automatically get a dependency on the parent context.
    // But this does not mean that the $data value of the child context will also get updated. If the child
    // view model also depends on the parent view model, you must provide a function that returns the correct
    // view model on each update.
    ko.bindingContext.prototype['createChildContext'] = function (dataItemOrAccessor, dataItemAlias, extendCallback) {
        return new ko.bindingContext(dataItemOrAccessor, this, dataItemAlias, function(self, parentContext) {
            // Extend the context hierarchy by setting the appropriate pointers
            self['$parentContext'] = parentContext;
            self['$parent'] = parentContext['$data'];
            self['$parents'] = (parentContext['$parents'] || []).slice(0);
            self['$parents'].unshift(self['$parent']);
            if (extendCallback)
                extendCallback(self);
        });
    };

    // Extend the binding context with new custom properties. This doesn't change the context hierarchy.
    // Similarly to "child" contexts, provide a function here to make sure that the correct values are set
    // when an observable view model is updated.
    ko.bindingContext.prototype['extend'] = function(properties) {
        // If the parent context references an observable view model, "_subscribable" will always be the
        // latest view model object. If not, "_subscribable" isn't set, and we can use the static "$data" value.
        return new ko.bindingContext(this._subscribable || this['$data'], this, null, function(self, parentContext) {
            // This "child" context doesn't directly track a parent observable view model,
            // so we need to manually set the $rawData value to match the parent.
            self['$rawData'] = parentContext['$rawData'];
            ko.utils.extend(self, typeof(properties) == "function" ? properties() : properties);
        });
    };

    // Returns the valueAccesor function for a binding value
    function makeValueAccessor(value) {
        return function() {
            return value;
        };
    }

    // Returns the value of a valueAccessor function
    function evaluateValueAccessor(valueAccessor) {
        return valueAccessor();
    }

    // Given a function that returns bindings, create and return a new object that contains
    // binding value-accessors functions. Each accessor function calls the original function
    // so that it always gets the latest value and all dependencies are captured. This is used
    // by ko.applyBindingsToNode and getBindingsAndMakeAccessors.
    function makeAccessorsFromFunction(callback) {
        return ko.utils.objectMap(ko.dependencyDetection.ignore(callback), function(value, key) {
            return function() {
                return callback()[key];
            };
        });
    }

    // Given a bindings function or object, create and return a new object that contains
    // binding value-accessors functions. This is used by ko.applyBindingsToNode.
    function makeBindingAccessors(bindings, context, node) {
        if (typeof bindings === 'function') {
            return makeAccessorsFromFunction(bindings.bind(null, context, node));
        } else {
            return ko.utils.objectMap(bindings, makeValueAccessor);
        }
    }

    // This function is used if the binding provider doesn't include a getBindingAccessors function.
    // It must be called with 'this' set to the provider instance.
    function getBindingsAndMakeAccessors(node, context) {
        return makeAccessorsFromFunction(this['getBindings'].bind(this, node, context));
    }

    function validateThatBindingIsAllowedForVirtualElements(bindingName) {
        var validator = ko.virtualElements.allowedBindings[bindingName];
        if (!validator)
            throw new Error("The binding '" + bindingName + "' cannot be used with virtual elements")
    }

    function applyBindingsToDescendantsInternal (bindingContext, elementOrVirtualElement, bindingContextsMayDifferFromDomParentElement) {
        var currentChild,
            nextInQueue = ko.virtualElements.firstChild(elementOrVirtualElement),
            provider = ko.bindingProvider['instance'],
            preprocessNode = provider['preprocessNode'];

        // Preprocessing allows a binding provider to mutate a node before bindings are applied to it. For example it's
        // possible to insert new siblings after it, and/or replace the node with a different one. This can be used to
        // implement custom binding syntaxes, such as {{ value }} for string interpolation, or custom element types that
        // trigger insertion of <template> contents at that point in the document.
        if (preprocessNode) {
            while (currentChild = nextInQueue) {
                nextInQueue = ko.virtualElements.nextSibling(currentChild);
                preprocessNode.call(provider, currentChild);
            }
            // Reset nextInQueue for the next loop
            nextInQueue = ko.virtualElements.firstChild(elementOrVirtualElement);
        }

        while (currentChild = nextInQueue) {
            // Keep a record of the next child *before* applying bindings, in case the binding removes the current child from its position
            nextInQueue = ko.virtualElements.nextSibling(currentChild);
            applyBindingsToNodeAndDescendantsInternal(bindingContext, currentChild, bindingContextsMayDifferFromDomParentElement);
        }
    }

    function applyBindingsToNodeAndDescendantsInternal (bindingContext, nodeVerified, bindingContextMayDifferFromDomParentElement) {
        var shouldBindDescendants = true;

        // Perf optimisation: Apply bindings only if...
        // (1) We need to store the binding context on this node (because it may differ from the DOM parent node's binding context)
        //     Note that we can't store binding contexts on non-elements (e.g., text nodes), as IE doesn't allow expando properties for those
        // (2) It might have bindings (e.g., it has a data-bind attribute, or it's a marker for a containerless template)
        var isElement = (nodeVerified.nodeType === 1);
        if (isElement) // Workaround IE <= 8 HTML parsing weirdness
            ko.virtualElements.normaliseVirtualElementDomStructure(nodeVerified);

        var shouldApplyBindings = (isElement && bindingContextMayDifferFromDomParentElement)             // Case (1)
                               || ko.bindingProvider['instance']['nodeHasBindings'](nodeVerified);       // Case (2)
        if (shouldApplyBindings)
            shouldBindDescendants = applyBindingsToNodeInternal(nodeVerified, null, bindingContext, bindingContextMayDifferFromDomParentElement)['shouldBindDescendants'];

        if (shouldBindDescendants && !bindingDoesNotRecurseIntoElementTypes[ko.utils.tagNameLower(nodeVerified)]) {
            // We're recursing automatically into (real or virtual) child nodes without changing binding contexts. So,
            //  * For children of a *real* element, the binding context is certainly the same as on their DOM .parentNode,
            //    hence bindingContextsMayDifferFromDomParentElement is false
            //  * For children of a *virtual* element, we can't be sure. Evaluating .parentNode on those children may
            //    skip over any number of intermediate virtual elements, any of which might define a custom binding context,
            //    hence bindingContextsMayDifferFromDomParentElement is true
            applyBindingsToDescendantsInternal(bindingContext, nodeVerified, /* bindingContextsMayDifferFromDomParentElement: */ !isElement);
        }
    }

    var boundElementDomDataKey = ko.utils.domData.nextKey();


    function topologicalSortBindings(bindings) {
        // Depth-first sort
        var result = [],                // The list of key/handler pairs that we will return
            bindingsConsidered = {},    // A temporary record of which bindings are already in 'result'
            cyclicDependencyStack = []; // Keeps track of a depth-search so that, if there's a cycle, we know which bindings caused it
        ko.utils.objectForEach(bindings, function pushBinding(bindingKey) {
            if (!bindingsConsidered[bindingKey]) {
                var binding = ko['getBindingHandler'](bindingKey);
                if (binding) {
                    // First add dependencies (if any) of the current binding
                    if (binding['after']) {
                        cyclicDependencyStack.push(bindingKey);
                        ko.utils.arrayForEach(binding['after'], function(bindingDependencyKey) {
                            if (bindings[bindingDependencyKey]) {
                                if (ko.utils.arrayIndexOf(cyclicDependencyStack, bindingDependencyKey) !== -1) {
                                    throw Error("Cannot combine the following bindings, because they have a cyclic dependency: " + cyclicDependencyStack.join(", "));
                                } else {
                                    pushBinding(bindingDependencyKey);
                                }
                            }
                        });
                        cyclicDependencyStack.length--;
                    }
                    // Next add the current binding
                    result.push({ key: bindingKey, handler: binding });
                }
                bindingsConsidered[bindingKey] = true;
            }
        });

        return result;
    }

    function applyBindingsToNodeInternal(node, sourceBindings, bindingContext, bindingContextMayDifferFromDomParentElement) {
        // Prevent multiple applyBindings calls for the same node, except when a binding value is specified
        var alreadyBound = ko.utils.domData.get(node, boundElementDomDataKey);
        if (!sourceBindings) {
            if (alreadyBound) {
                throw Error("You cannot apply bindings multiple times to the same element.");
            }
            ko.utils.domData.set(node, boundElementDomDataKey, true);
        }

        // Optimization: Don't store the binding context on this node if it's definitely the same as on node.parentNode, because
        // we can easily recover it just by scanning up the node's ancestors in the DOM
        // (note: here, parent node means "real DOM parent" not "virtual parent", as there's no O(1) way to find the virtual parent)
        if (!alreadyBound && bindingContextMayDifferFromDomParentElement)
            ko.storedBindingContextForNode(node, bindingContext);

        // Use bindings if given, otherwise fall back on asking the bindings provider to give us some bindings
        var bindings;
        if (sourceBindings && typeof sourceBindings !== 'function') {
            bindings = sourceBindings;
        } else {
            var provider = ko.bindingProvider['instance'],
                getBindings = provider['getBindingAccessors'] || getBindingsAndMakeAccessors;

            // Get the binding from the provider within a computed observable so that we can update the bindings whenever
            // the binding context is updated or if the binding provider accesses observables.
            var bindingsUpdater = ko.dependentObservable(
                function() {
                    bindings = sourceBindings ? sourceBindings(bindingContext, node) : getBindings.call(provider, node, bindingContext);
                    // Register a dependency on the binding context to support obsevable view models.
                    if (bindings && bindingContext._subscribable)
                        bindingContext._subscribable();
                    return bindings;
                },
                null, { disposeWhenNodeIsRemoved: node }
            );

            if (!bindings || !bindingsUpdater.isActive())
                bindingsUpdater = null;
        }

        var bindingHandlerThatControlsDescendantBindings;
        if (bindings) {
            // Return the value accessor for a given binding. When bindings are static (won't be updated because of a binding
            // context update), just return the value accessor from the binding. Otherwise, return a function that always gets
            // the latest binding value and registers a dependency on the binding updater.
            var getValueAccessor = bindingsUpdater
                ? function(bindingKey) {
                    return function() {
                        return evaluateValueAccessor(bindingsUpdater()[bindingKey]);
                    };
                } : function(bindingKey) {
                    return bindings[bindingKey];
                };

            // Use of allBindings as a function is maintained for backwards compatibility, but its use is deprecated
            function allBindings() {
                return ko.utils.objectMap(bindingsUpdater ? bindingsUpdater() : bindings, evaluateValueAccessor);
            }
            // The following is the 3.x allBindings API
            allBindings['get'] = function(key) {
                return bindings[key] && evaluateValueAccessor(getValueAccessor(key));
            };
            allBindings['has'] = function(key) {
                return key in bindings;
            };

            // First put the bindings into the right order
            var orderedBindings = topologicalSortBindings(bindings);

            // Go through the sorted bindings, calling init and update for each
            ko.utils.arrayForEach(orderedBindings, function(bindingKeyAndHandler) {
                // Note that topologicalSortBindings has already filtered out any nonexistent binding handlers,
                // so bindingKeyAndHandler.handler will always be nonnull.
                var handlerInitFn = bindingKeyAndHandler.handler["init"],
                    handlerUpdateFn = bindingKeyAndHandler.handler["update"],
                    bindingKey = bindingKeyAndHandler.key;

                if (node.nodeType === 8) {
                    validateThatBindingIsAllowedForVirtualElements(bindingKey);
                }

                try {
                    // Run init, ignoring any dependencies
                    if (typeof handlerInitFn == "function") {
                        ko.dependencyDetection.ignore(function() {
                            var initResult = handlerInitFn(node, getValueAccessor(bindingKey), allBindings, bindingContext['$data'], bindingContext);

                            // If this binding handler claims to control descendant bindings, make a note of this
                            if (initResult && initResult['controlsDescendantBindings']) {
                                if (bindingHandlerThatControlsDescendantBindings !== undefined)
                                    throw new Error("Multiple bindings (" + bindingHandlerThatControlsDescendantBindings + " and " + bindingKey + ") are trying to control descendant bindings of the same element. You cannot use these bindings together on the same element.");
                                bindingHandlerThatControlsDescendantBindings = bindingKey;
                            }
                        });
                    }

                    // Run update in its own computed wrapper
                    if (typeof handlerUpdateFn == "function") {
                        ko.dependentObservable(
                            function() {
                                handlerUpdateFn(node, getValueAccessor(bindingKey), allBindings, bindingContext['$data'], bindingContext);
                            },
                            null,
                            { disposeWhenNodeIsRemoved: node }
                        );
                    }
                } catch (ex) {
                    ex.message = "Unable to process binding \"" + bindingKey + ": " + bindings[bindingKey] + "\"\nMessage: " + ex.message;
                    throw ex;
                }
            });
        }

        return {
            'shouldBindDescendants': bindingHandlerThatControlsDescendantBindings === undefined
        };
    };

    var storedBindingContextDomDataKey = ko.utils.domData.nextKey();
    ko.storedBindingContextForNode = function (node, bindingContext) {
        if (arguments.length == 2) {
            ko.utils.domData.set(node, storedBindingContextDomDataKey, bindingContext);
            if (bindingContext._subscribable)
                bindingContext._subscribable._addNode(node);
        } else {
            return ko.utils.domData.get(node, storedBindingContextDomDataKey);
        }
    }

    function getBindingContext(viewModelOrBindingContext) {
        return viewModelOrBindingContext && (viewModelOrBindingContext instanceof ko.bindingContext)
            ? viewModelOrBindingContext
            : new ko.bindingContext(viewModelOrBindingContext);
    }

    ko.applyBindingAccessorsToNode = function (node, bindings, viewModelOrBindingContext) {
        if (node.nodeType === 1) // If it's an element, workaround IE <= 8 HTML parsing weirdness
            ko.virtualElements.normaliseVirtualElementDomStructure(node);
        return applyBindingsToNodeInternal(node, bindings, getBindingContext(viewModelOrBindingContext), true);
    };

    ko.applyBindingsToNode = function (node, bindings, viewModelOrBindingContext) {
        var context = getBindingContext(viewModelOrBindingContext);
        return ko.applyBindingAccessorsToNode(node, makeBindingAccessors(bindings, context, node), context);
    };

    ko.applyBindingsToDescendants = function(viewModelOrBindingContext, rootNode) {
        if (rootNode.nodeType === 1 || rootNode.nodeType === 8)
            applyBindingsToDescendantsInternal(getBindingContext(viewModelOrBindingContext), rootNode, true);
    };

    ko.applyBindings = function (viewModelOrBindingContext, rootNode) {
        // If jQuery is loaded after Knockout, we won't initially have access to it. So save it here.
        if (!jQueryInstance && window['jQuery']) {
            jQueryInstance = window['jQuery'];
        }

        if (rootNode && (rootNode.nodeType !== 1) && (rootNode.nodeType !== 8))
            throw new Error("ko.applyBindings: first parameter should be your view model; second parameter should be a DOM node");
        rootNode = rootNode || window.document.body; // Make "rootNode" parameter optional

        applyBindingsToNodeAndDescendantsInternal(getBindingContext(viewModelOrBindingContext), rootNode, true);
    };

    // Retrieving binding context from arbitrary nodes
    ko.contextFor = function(node) {
        // We can only do something meaningful for elements and comment nodes (in particular, not text nodes, as IE can't store domdata for them)
        switch (node.nodeType) {
            case 1:
            case 8:
                var context = ko.storedBindingContextForNode(node);
                if (context) return context;
                if (node.parentNode) return ko.contextFor(node.parentNode);
                break;
        }
        return undefined;
    };
    ko.dataFor = function(node) {
        var context = ko.contextFor(node);
        return context ? context['$data'] : undefined;
    };

    ko.exportSymbol('bindingHandlers', ko.bindingHandlers);
    ko.exportSymbol('applyBindings', ko.applyBindings);
    ko.exportSymbol('applyBindingsToDescendants', ko.applyBindingsToDescendants);
    ko.exportSymbol('applyBindingAccessorsToNode', ko.applyBindingAccessorsToNode);
    ko.exportSymbol('applyBindingsToNode', ko.applyBindingsToNode);
    ko.exportSymbol('contextFor', ko.contextFor);
    ko.exportSymbol('dataFor', ko.dataFor);
})();
(function(undefined) {
    var loadingSubscribablesCache = {}, // Tracks component loads that are currently in flight
        loadedDefinitionsCache = {};    // Tracks component loads that have already completed

    ko.components = {
        get: function(componentName, callback) {
            var cachedDefinition = getObjectOwnProperty(loadedDefinitionsCache, componentName);
            if (cachedDefinition) {
                // It's already loaded and cached. Reuse the same definition object.
                // Note that for API consistency, even cache hits complete asynchronously.
                setTimeout(function() { callback(cachedDefinition) }, 0);
            } else {
                // Join the loading process that is already underway, or start a new one.
                loadComponentAndNotify(componentName, callback);
            }
        },

        clearCachedDefinition: function(componentName) {
            delete loadedDefinitionsCache[componentName];
        },

        _getFirstResultFromLoaders: getFirstResultFromLoaders
    };

    function getObjectOwnProperty(obj, propName) {
        return obj.hasOwnProperty(propName) ? obj[propName] : undefined;
    }

    function loadComponentAndNotify(componentName, callback) {
        var subscribable = getObjectOwnProperty(loadingSubscribablesCache, componentName),
            completedAsync;
        if (!subscribable) {
            // It's not started loading yet. Start loading, and when it's done, move it to loadedDefinitionsCache.
            subscribable = loadingSubscribablesCache[componentName] = new ko.subscribable();
            beginLoadingComponent(componentName, function(definition) {
                loadedDefinitionsCache[componentName] = definition;
                delete loadingSubscribablesCache[componentName];

                // For API consistency, all loads complete asynchronously. However we want to avoid
                // adding an extra setTimeout if it's unnecessary (i.e., the completion is already
                // async) since setTimeout(..., 0) still takes about 16ms or more on most browsers.
                if (completedAsync) {
                    subscribable['notifySubscribers'](definition);
                } else {
                    setTimeout(function() {
                        subscribable['notifySubscribers'](definition);
                    }, 0);
                }
            });
            completedAsync = true;
        }
        subscribable.subscribe(callback);
    }

    function beginLoadingComponent(componentName, callback) {
        getFirstResultFromLoaders('getConfig', [componentName], function(config) {
            if (config) {
                // We have a config, so now load its definition
                getFirstResultFromLoaders('loadComponent', [componentName, config], function(definition) {
                    callback(definition);
                });
            } else {
                // The component has no config - it's unknown to all the loaders.
                // Note that this is not an error (e.g., a module loading error) - that would abort the
                // process and this callback would not run. For this callback to run, all loaders must
                // have confirmed they don't know about this component.
                callback(null);
            }
        });
    }

    function getFirstResultFromLoaders(methodName, argsExceptCallback, callback, candidateLoaders) {
        // On the first call in the stack, start with the full set of loaders
        if (!candidateLoaders) {
            candidateLoaders = ko.components['loaders'].slice(0); // Use a copy, because we'll be mutating this array
        }

        // Try the next candidate
        var currentCandidateLoader = candidateLoaders.shift();
        if (currentCandidateLoader) {
            var methodInstance = currentCandidateLoader[methodName];
            if (methodInstance) {
                var wasAborted = false,
                    synchronousReturnValue = methodInstance.apply(currentCandidateLoader, argsExceptCallback.concat(function(result) {
                        if (wasAborted) {
                            callback(null);
                        } else if (result !== null) {
                            // This candidate returned a value. Use it.
                            callback(result);
                        } else {
                            // Try the next candidate
                            getFirstResultFromLoaders(methodName, argsExceptCallback, callback, candidateLoaders);
                        }
                    }));

                // Currently, loaders may not return anything synchronously. This leaves open the possibility
                // that we'll extend the API to support synchronous return values in the future. It won't be
                // a breaking change, because currently no loader is allowed to return anything except undefined.
                if (synchronousReturnValue !== undefined) {
                    wasAborted = true;

                    // Method to suppress exceptions will remain undocumented. This is only to keep
                    // KO's specs running tidily, since we can observe the loading got aborted without
                    // having exceptions cluttering up the console too.
                    if (!currentCandidateLoader['suppressLoaderExceptions']) {
                        throw new Error('Component loaders must supply values by invoking the callback, not by returning values synchronously.');
                    }
                }
            } else {
                // This candidate doesn't have the relevant handler. Synchronously move on to the next one.
                getFirstResultFromLoaders(methodName, argsExceptCallback, callback, candidateLoaders);
            }
        } else {
            // No candidates returned a value
            callback(null);
        }
    }

    // Reference the loaders via string name so it's possible for developers
    // to replace the whole array by assigning to ko.components.loaders
    ko.components['loaders'] = [];

    ko.exportSymbol('components', ko.components);
    ko.exportSymbol('components.get', ko.components.get);
    ko.exportSymbol('components.clearCachedDefinition', ko.components.clearCachedDefinition);
})();
(function(undefined) {

    // The default loader is responsible for two things:
    // 1. Maintaining the default in-memory registry of component configuration objects
    //    (i.e., the thing you're writing to when you call ko.components.register(someName, ...))
    // 2. Answering requests for components by fetching configuration objects
    //    from that default in-memory registry and resolving them into standard
    //    component definition objects (of the form { createViewModel: ..., template: ... })
    // Custom loaders may override either of these facilities, i.e.,
    // 1. To supply configuration objects from some other source (e.g., conventions)
    // 2. Or, to resolve configuration objects by loading viewmodels/templates via arbitrary logic.

    var defaultConfigRegistry = {};

    ko.components.register = function(componentName, config) {
        if (!config) {
            throw new Error('Invalid configuration for ' + componentName);
        }

        if (ko.components.isRegistered(componentName)) {
            throw new Error('Component ' + componentName + ' is already registered');
        }

        defaultConfigRegistry[componentName] = config;
    }

    ko.components.isRegistered = function(componentName) {
        return componentName in defaultConfigRegistry;
    }

    ko.components.unregister = function(componentName) {
        delete defaultConfigRegistry[componentName];
        ko.components.clearCachedDefinition(componentName);
    }

    ko.components.defaultLoader = {
        'getConfig': function(componentName, callback) {
            var result = defaultConfigRegistry.hasOwnProperty(componentName)
                ? defaultConfigRegistry[componentName]
                : null;
            callback(result);
        },

        'loadComponent': function(componentName, config, callback) {
            var errorCallback = makeErrorCallback(componentName);
            possiblyGetConfigFromAmd(errorCallback, config, function(loadedConfig) {
                resolveConfig(componentName, errorCallback, loadedConfig, callback);
            });
        },

        'loadTemplate': function(componentName, templateConfig, callback) {
            resolveTemplate(makeErrorCallback(componentName), templateConfig, callback);
        },

        'loadViewModel': function(componentName, viewModelConfig, callback) {
            resolveViewModel(makeErrorCallback(componentName), viewModelConfig, callback);
        }
    };

    var createViewModelKey = 'createViewModel';

    // Takes a config object of the form { template: ..., viewModel: ... }, and asynchronously convert it
    // into the standard component definition format:
    //    { template: <ArrayOfDomNodes>, createViewModel: function(params, componentInfo) { ... } }.
    // Since both template and viewModel may need to be resolved asynchronously, both tasks are performed
    // in parallel, and the results joined when both are ready. We don't depend on any promises infrastructure,
    // so this is implemented manually below.
    function resolveConfig(componentName, errorCallback, config, callback) {
        var result = {},
            makeCallBackWhenZero = 2,
            tryIssueCallback = function() {
                if (--makeCallBackWhenZero === 0) {
                    callback(result);
                }
            },
            templateConfig = config['template'],
            viewModelConfig = config['viewModel'];

        if (templateConfig) {
            possiblyGetConfigFromAmd(errorCallback, templateConfig, function(loadedConfig) {
                ko.components._getFirstResultFromLoaders('loadTemplate', [componentName, loadedConfig], function(resolvedTemplate) {
                    result['template'] = resolvedTemplate;
                    tryIssueCallback();
                });
            });
        } else {
            tryIssueCallback();
        }

        if (viewModelConfig) {
            possiblyGetConfigFromAmd(errorCallback, viewModelConfig, function(loadedConfig) {
                ko.components._getFirstResultFromLoaders('loadViewModel', [componentName, loadedConfig], function(resolvedViewModel) {
                    result[createViewModelKey] = resolvedViewModel;
                    tryIssueCallback();
                });
            });
        } else {
            tryIssueCallback();
        }
    }

    function resolveTemplate(errorCallback, templateConfig, callback) {
        if (typeof templateConfig === 'string') {
            // Markup - parse it
            callback(ko.utils.parseHtmlFragment(templateConfig));
        } else if (templateConfig instanceof Array) {
            // Assume already an array of DOM nodes - pass through unchanged
            callback(templateConfig);
        } else if (isDocumentFragment(templateConfig)) {
            // Document fragment - use its child nodes
            callback(ko.utils.makeArray(templateConfig.childNodes));
        } else if (templateConfig['element']) {
            var element = templateConfig['element'];
            if (isDomElement(element)) {
                // Element instance - copy its child nodes
                callback(cloneNodesFromTemplateSourceElement(element));
            } else if (typeof element === 'string') {
                // Element ID - find it, then copy its child nodes
                var elemInstance = document.getElementById(element);
                if (elemInstance) {
                    callback(cloneNodesFromTemplateSourceElement(elemInstance));
                } else {
                    errorCallback('Cannot find element with ID ' + element);
                }
            } else {
                errorCallback('Unknown element type: ' + element);
            }
        } else {
            errorCallback('Unknown template value: ' + templateConfig);
        }
    }

    function resolveViewModel(errorCallback, viewModelConfig, callback) {
        if (typeof viewModelConfig === 'function') {
            // Constructor - convert to standard factory function format
            // By design, this does *not* supply componentInfo to the constructor, as the intent is that
            // componentInfo contains non-viewmodel data (e.g., the component's element) that should only
            // be used in factory functions, not viewmodel constructors.
            callback(function (params /*, componentInfo */) {
                return new viewModelConfig(params);
            });
        } else if (typeof viewModelConfig[createViewModelKey] === 'function') {
            // Already a factory function - use it as-is
            callback(viewModelConfig[createViewModelKey]);
        } else if ('instance' in viewModelConfig) {
            // Fixed object instance - promote to createViewModel format for API consistency
            var fixedInstance = viewModelConfig['instance'];
            callback(function (params, componentInfo) {
                return fixedInstance;
            });
        } else if ('viewModel' in viewModelConfig) {
            // Resolved AMD module whose value is of the form { viewModel: ... }
            resolveViewModel(errorCallback, viewModelConfig['viewModel'], callback);
        } else {
            errorCallback('Unknown viewModel value: ' + viewModelConfig);
        }
    }

    function cloneNodesFromTemplateSourceElement(elemInstance) {
        switch (ko.utils.tagNameLower(elemInstance)) {
            case 'script':
                return ko.utils.parseHtmlFragment(elemInstance.text);
            case 'textarea':
                return ko.utils.parseHtmlFragment(elemInstance.value);
            case 'template':
                // For browsers with proper <template> element support (i.e., where the .content property
                // gives a document fragment), use that document fragment.
                if (isDocumentFragment(elemInstance.content)) {
                    return ko.utils.cloneNodes(elemInstance.content.childNodes);
                }
        }

        // Regular elements such as <div>, and <template> elements on old browsers that don't really
        // understand <template> and just treat it as a regular container
        return ko.utils.cloneNodes(elemInstance.childNodes);
    }

    function isDomElement(obj) {
        if (window['HTMLElement']) {
            return obj instanceof HTMLElement;
        } else {
            return obj && obj.tagName && obj.nodeType === 1;
        }
    }

    function isDocumentFragment(obj) {
        if (window['DocumentFragment']) {
            return obj instanceof DocumentFragment;
        } else {
            return obj && obj.nodeType === 11;
        }
    }

    function possiblyGetConfigFromAmd(errorCallback, config, callback) {
        if (typeof config['require'] === 'string') {
            // The config is the value of an AMD module
            if (require || window['require']) {
                (require || window['require'])([config['require']], callback);
            } else {
                errorCallback('Uses require, but no AMD loader is present');
            }
        } else {
            callback(config);
        }
    }

    function makeErrorCallback(componentName) {
        return function (message) {
            throw new Error('Component \'' + componentName + '\': ' + message);
        };
    }

    ko.exportSymbol('components.register', ko.components.register);
    ko.exportSymbol('components.isRegistered', ko.components.isRegistered);
    ko.exportSymbol('components.unregister', ko.components.unregister);

    // Expose the default loader so that developers can directly ask it for configuration
    // or to resolve configuration
    ko.exportSymbol('components.defaultLoader', ko.components.defaultLoader);

    // By default, the default loader is the only registered component loader
    ko.components['loaders'].push(ko.components.defaultLoader);

    // Privately expose the underlying config registry for use in old-IE shim
    ko.components._allRegisteredComponents = defaultConfigRegistry;
})();
(function (undefined) {
    // Overridable API for determining which component name applies to a given node. By overriding this,
    // you can for example map specific tagNames to components that are not preregistered.
    ko.components['getComponentNameForNode'] = function(node) {
        var tagNameLower = ko.utils.tagNameLower(node);
        return ko.components.isRegistered(tagNameLower) && tagNameLower;
    };

    ko.components.addBindingsForCustomElement = function(allBindings, node, bindingContext, valueAccessors) {
        // Determine if it's really a custom element matching a component
        if (node.nodeType === 1) {
            var componentName = ko.components['getComponentNameForNode'](node);
            if (componentName) {
                // It does represent a component, so add a component binding for it
                allBindings = allBindings || {};

                if (allBindings['component']) {
                    // Avoid silently overwriting some other 'component' binding that may already be on the element
                    throw new Error('Cannot use the "component" binding on a custom element matching a component');
                }

                var componentBindingValue = { 'name': componentName, 'params': getComponentParamsFromCustomElement(node, bindingContext) };

                allBindings['component'] = valueAccessors
                    ? function() { return componentBindingValue; }
                    : componentBindingValue;
            }
        }

        return allBindings;
    }

    var nativeBindingProviderInstance = new ko.bindingProvider();

    function getComponentParamsFromCustomElement(elem, bindingContext) {
        var paramsAttribute = elem.getAttribute('params');

        if (paramsAttribute) {
            var params = nativeBindingProviderInstance['parseBindingsString'](paramsAttribute, bindingContext, elem, { 'valueAccessors': true, 'bindingParams': true }),
                rawParamComputedValues = ko.utils.objectMap(params, function(paramValue, paramName) {
                    return ko.computed(paramValue, null, { disposeWhenNodeIsRemoved: elem });
                }),
                result = ko.utils.objectMap(rawParamComputedValues, function(paramValueComputed, paramName) {
                    // Does the evaluation of the parameter value unwrap any observables?
                    if (!paramValueComputed.isActive()) {
                        // No it doesn't, so there's no need for any computed wrapper. Just pass through the supplied value directly.
                        // Example: "someVal: firstName, age: 123" (whether or not firstName is an observable/computed)
                        return paramValueComputed.peek();
                    } else {
                        // Yes it does. Supply a computed property that unwraps both the outer (binding expression)
                        // level of observability, and any inner (resulting model value) level of observability.
                        // This means the component doesn't have to worry about multiple unwrapping.
                        return ko.computed(function() {
                            return ko.utils.unwrapObservable(paramValueComputed());
                        }, null, { disposeWhenNodeIsRemoved: elem });
                    }
                });

            // Give access to the raw computeds, as long as that wouldn't overwrite any custom param also called '$raw'
            // This is in case the developer wants to react to outer (binding) observability separately from inner
            // (model value) observability, or in case the model value observable has subobservables.
            if (!result.hasOwnProperty('$raw')) {
                result['$raw'] = rawParamComputedValues;
            }

            return result;
        } else {
            // For consistency, absence of a "params" attribute is treated the same as the presence of
            // any empty one. Otherwise component viewmodels need special code to check whether or not
            // 'params' or 'params.$raw' is null/undefined before reading subproperties, which is annoying.
            return { '$raw': {} };
        }
    }

    // --------------------------------------------------------------------------------
    // Compatibility code for older (pre-HTML5) IE browsers

    if (ko.utils.ieVersion < 9) {
        // Whenever you preregister a component, enable it as a custom element in the current document
        ko.components['register'] = (function(originalFunction) {
            return function(componentName) {
                document.createElement(componentName); // Allows IE<9 to parse markup containing the custom element
                return originalFunction.apply(this, arguments);
            }
        })(ko.components['register']);

        // Whenever you create a document fragment, enable all preregistered component names as custom elements
        // This is needed to make innerShiv/jQuery HTML parsing correctly handle the custom elements
        document.createDocumentFragment = (function(originalFunction) {
            return function() {
                var newDocFrag = originalFunction(),
                    allComponents = ko.components._allRegisteredComponents;
                for (var componentName in allComponents) {
                    if (allComponents.hasOwnProperty(componentName)) {
                        newDocFrag.createElement(componentName);
                    }
                }
                return newDocFrag;
            };
        })(document.createDocumentFragment);
    }
})();(function(undefined) {

    var componentLoadingOperationUniqueId = 0;

    ko.bindingHandlers['component'] = {
        'init': function(element, valueAccessor, ignored1, ignored2, bindingContext) {
            var currentViewModel,
                currentLoadingOperationId,
                disposeAssociatedComponentViewModel = function () {
                    var currentViewModelDispose = currentViewModel && currentViewModel['dispose'];
                    if (typeof currentViewModelDispose === 'function') {
                        currentViewModelDispose.call(currentViewModel);
                    }

                    // Any in-flight loading operation is no longer relevant, so make sure we ignore its completion
                    currentLoadingOperationId = null;
                };

            ko.utils.domNodeDisposal.addDisposeCallback(element, disposeAssociatedComponentViewModel);

            ko.computed(function () {
                var value = ko.utils.unwrapObservable(valueAccessor()),
                    componentName, componentParams;

                if (typeof value === 'string') {
                    componentName = value;
                } else {
                    componentName = ko.utils.unwrapObservable(value['name']);
                    componentParams = ko.utils.unwrapObservable(value['params']);
                }

                if (!componentName) {
                    throw new Error('No component name specified');
                }

                var loadingOperationId = currentLoadingOperationId = ++componentLoadingOperationUniqueId;
                ko.components.get(componentName, function(componentDefinition) {
                    // If this is not the current load operation for this element, ignore it.
                    if (currentLoadingOperationId !== loadingOperationId) {
                        return;
                    }

                    // Clean up previous state
                    disposeAssociatedComponentViewModel();

                    // Instantiate and bind new component. Implicitly this cleans any old DOM nodes.
                    if (!componentDefinition) {
                        throw new Error('Unknown component \'' + componentName + '\'');
                    }
                    cloneTemplateIntoElement(componentName, componentDefinition, element);
                    var componentViewModel = createViewModel(componentDefinition, element, componentParams),
                        childBindingContext = bindingContext['createChildContext'](componentViewModel);
                    currentViewModel = componentViewModel;
                    ko.applyBindingsToDescendants(childBindingContext, element);
                });
            }, null, { disposeWhenNodeIsRemoved: element });

            return { 'controlsDescendantBindings': true };
        }
    };

    ko.virtualElements.allowedBindings['component'] = true;

    function cloneTemplateIntoElement(componentName, componentDefinition, element) {
        var template = componentDefinition['template'];
        if (!template) {
            throw new Error('Component \'' + componentName + '\' has no template');
        }

        var clonedNodesArray = ko.utils.cloneNodes(template);
        ko.virtualElements.setDomNodeChildren(element, clonedNodesArray);
    }

    function createViewModel(componentDefinition, element, componentParams) {
        var componentViewModelFactory = componentDefinition['createViewModel'];
        return componentViewModelFactory
            ? componentViewModelFactory.call(componentDefinition, componentParams, { element: element })
            : componentParams; // Template-only component
    }

})();
var attrHtmlToJavascriptMap = { 'class': 'className', 'for': 'htmlFor' };
ko.bindingHandlers['attr'] = {
    'update': function(element, valueAccessor, allBindings) {
        var value = ko.utils.unwrapObservable(valueAccessor()) || {};
        ko.utils.objectForEach(value, function(attrName, attrValue) {
            attrValue = ko.utils.unwrapObservable(attrValue);

            // To cover cases like "attr: { checked:someProp }", we want to remove the attribute entirely
            // when someProp is a "no value"-like value (strictly null, false, or undefined)
            // (because the absence of the "checked" attr is how to mark an element as not checked, etc.)
            var toRemove = (attrValue === false) || (attrValue === null) || (attrValue === undefined);
            if (toRemove)
                element.removeAttribute(attrName);

            // In IE <= 7 and IE8 Quirks Mode, you have to use the Javascript property name instead of the
            // HTML attribute name for certain attributes. IE8 Standards Mode supports the correct behavior,
            // but instead of figuring out the mode, we'll just set the attribute through the Javascript
            // property for IE <= 8.
            if (ko.utils.ieVersion <= 8 && attrName in attrHtmlToJavascriptMap) {
                attrName = attrHtmlToJavascriptMap[attrName];
                if (toRemove)
                    element.removeAttribute(attrName);
                else
                    element[attrName] = attrValue;
            } else if (!toRemove) {
                element.setAttribute(attrName, attrValue.toString());
            }

            // Treat "name" specially - although you can think of it as an attribute, it also needs
            // special handling on older versions of IE (https://github.com/SteveSanderson/knockout/pull/333)
            // Deliberately being case-sensitive here because XHTML would regard "Name" as a different thing
            // entirely, and there's no strong reason to allow for such casing in HTML.
            if (attrName === "name") {
                ko.utils.setElementName(element, toRemove ? "" : attrValue.toString());
            }
        });
    }
};
(function() {

ko.bindingHandlers['checked'] = {
    'after': ['value', 'attr'],
    'init': function (element, valueAccessor, allBindings) {
        var checkedValue = ko.pureComputed(function() {
            // Treat "value" like "checkedValue" when it is included with "checked" binding
            if (allBindings['has']('checkedValue')) {
                return ko.utils.unwrapObservable(allBindings.get('checkedValue'));
            } else if (allBindings['has']('value')) {
                return ko.utils.unwrapObservable(allBindings.get('value'));
            }

            return element.value;
        });

        function updateModel() {
            // This updates the model value from the view value.
            // It runs in response to DOM events (click) and changes in checkedValue.
            var isChecked = element.checked,
                elemValue = useCheckedValue ? checkedValue() : isChecked;

            // When we're first setting up this computed, don't change any model state.
            if (ko.computedContext.isInitial()) {
                return;
            }

            // We can ignore unchecked radio buttons, because some other radio
            // button will be getting checked, and that one can take care of updating state.
            if (isRadio && !isChecked) {
                return;
            }

            var modelValue = ko.dependencyDetection.ignore(valueAccessor);
            if (isValueArray) {
                if (oldElemValue !== elemValue) {
                    // When we're responding to the checkedValue changing, and the element is
                    // currently checked, replace the old elem value with the new elem value
                    // in the model array.
                    if (isChecked) {
                        ko.utils.addOrRemoveItem(modelValue, elemValue, true);
                        ko.utils.addOrRemoveItem(modelValue, oldElemValue, false);
                    }

                    oldElemValue = elemValue;
                } else {
                    // When we're responding to the user having checked/unchecked a checkbox,
                    // add/remove the element value to the model array.
                    ko.utils.addOrRemoveItem(modelValue, elemValue, isChecked);
                }
            } else {
                ko.expressionRewriting.writeValueToProperty(modelValue, allBindings, 'checked', elemValue, true);
            }
        };

        function updateView() {
            // This updates the view value from the model value.
            // It runs in response to changes in the bound (checked) value.
            var modelValue = ko.utils.unwrapObservable(valueAccessor());

            if (isValueArray) {
                // When a checkbox is bound to an array, being checked represents its value being present in that array
                element.checked = ko.utils.arrayIndexOf(modelValue, checkedValue()) >= 0;
            } else if (isCheckbox) {
                // When a checkbox is bound to any other value (not an array), being checked represents the value being trueish
                element.checked = modelValue;
            } else {
                // For radio buttons, being checked means that the radio button's value corresponds to the model value
                element.checked = (checkedValue() === modelValue);
            }
        };

        var isCheckbox = element.type == "checkbox",
            isRadio = element.type == "radio";

        // Only bind to check boxes and radio buttons
        if (!isCheckbox && !isRadio) {
            return;
        }

        var isValueArray = isCheckbox && (ko.utils.unwrapObservable(valueAccessor()) instanceof Array),
            oldElemValue = isValueArray ? checkedValue() : undefined,
            useCheckedValue = isRadio || isValueArray;

        // IE 6 won't allow radio buttons to be selected unless they have a name
        if (isRadio && !element.name)
            ko.bindingHandlers['uniqueName']['init'](element, function() { return true });

        // Set up two computeds to update the binding:

        // The first responds to changes in the checkedValue value and to element clicks
        ko.computed(updateModel, null, { disposeWhenNodeIsRemoved: element });
        ko.utils.registerEventHandler(element, "click", updateModel);

        // The second responds to changes in the model value (the one associated with the checked binding)
        ko.computed(updateView, null, { disposeWhenNodeIsRemoved: element });
    }
};
ko.expressionRewriting.twoWayBindings['checked'] = true;

ko.bindingHandlers['checkedValue'] = {
    'update': function (element, valueAccessor) {
        element.value = ko.utils.unwrapObservable(valueAccessor());
    }
};

})();var classesWrittenByBindingKey = '__ko__cssValue';
ko.bindingHandlers['css'] = {
    'update': function (element, valueAccessor) {
        var value = ko.utils.unwrapObservable(valueAccessor());
        if (typeof value == "object") {
            ko.utils.objectForEach(value, function(className, shouldHaveClass) {
                shouldHaveClass = ko.utils.unwrapObservable(shouldHaveClass);
                ko.utils.toggleDomNodeCssClass(element, className, shouldHaveClass);
            });
        } else {
            value = String(value || ''); // Make sure we don't try to store or set a non-string value
            ko.utils.toggleDomNodeCssClass(element, element[classesWrittenByBindingKey], false);
            element[classesWrittenByBindingKey] = value;
            ko.utils.toggleDomNodeCssClass(element, value, true);
        }
    }
};
ko.bindingHandlers['enable'] = {
    'update': function (element, valueAccessor) {
        var value = ko.utils.unwrapObservable(valueAccessor());
        if (value && element.disabled)
            element.removeAttribute("disabled");
        else if ((!value) && (!element.disabled))
            element.disabled = true;
    }
};

ko.bindingHandlers['disable'] = {
    'update': function (element, valueAccessor) {
        ko.bindingHandlers['enable']['update'](element, function() { return !ko.utils.unwrapObservable(valueAccessor()) });
    }
};
// For certain common events (currently just 'click'), allow a simplified data-binding syntax
// e.g. click:handler instead of the usual full-length event:{click:handler}
function makeEventHandlerShortcut(eventName) {
    ko.bindingHandlers[eventName] = {
        'init': function(element, valueAccessor, allBindings, viewModel, bindingContext) {
            var newValueAccessor = function () {
                var result = {};
                result[eventName] = valueAccessor();
                return result;
            };
            return ko.bindingHandlers['event']['init'].call(this, element, newValueAccessor, allBindings, viewModel, bindingContext);
        }
    }
}

ko.bindingHandlers['event'] = {
    'init' : function (element, valueAccessor, allBindings, viewModel, bindingContext) {
        var eventsToHandle = valueAccessor() || {};
        ko.utils.objectForEach(eventsToHandle, function(eventName) {
            if (typeof eventName == "string") {
                ko.utils.registerEventHandler(element, eventName, function (event) {
                    var handlerReturnValue;
                    var handlerFunction = valueAccessor()[eventName];
                    if (!handlerFunction)
                        return;

                    try {
                        // Take all the event args, and prefix with the viewmodel
                        var argsForHandler = ko.utils.makeArray(arguments);
                        viewModel = bindingContext['$data'];
                        argsForHandler.unshift(viewModel);
                        handlerReturnValue = handlerFunction.apply(viewModel, argsForHandler);
                    } finally {
                        if (handlerReturnValue !== true) { // Normally we want to prevent default action. Developer can override this be explicitly returning true.
                            if (event.preventDefault)
                                event.preventDefault();
                            else
                                event.returnValue = false;
                        }
                    }

                    var bubble = allBindings.get(eventName + 'Bubble') !== false;
                    if (!bubble) {
                        event.cancelBubble = true;
                        if (event.stopPropagation)
                            event.stopPropagation();
                    }
                });
            }
        });
    }
};
// "foreach: someExpression" is equivalent to "template: { foreach: someExpression }"
// "foreach: { data: someExpression, afterAdd: myfn }" is equivalent to "template: { foreach: someExpression, afterAdd: myfn }"
ko.bindingHandlers['foreach'] = {
    makeTemplateValueAccessor: function(valueAccessor) {
        return function() {
            var modelValue = valueAccessor(),
                unwrappedValue = ko.utils.peekObservable(modelValue);    // Unwrap without setting a dependency here

            // If unwrappedValue is the array, pass in the wrapped value on its own
            // The value will be unwrapped and tracked within the template binding
            // (See https://github.com/SteveSanderson/knockout/issues/523)
            if ((!unwrappedValue) || typeof unwrappedValue.length == "number")
                return { 'foreach': modelValue, 'templateEngine': ko.nativeTemplateEngine.instance };

            // If unwrappedValue.data is the array, preserve all relevant options and unwrap again value so we get updates
            ko.utils.unwrapObservable(modelValue);
            return {
                'foreach': unwrappedValue['data'],
                'as': unwrappedValue['as'],
                'includeDestroyed': unwrappedValue['includeDestroyed'],
                'afterAdd': unwrappedValue['afterAdd'],
                'beforeRemove': unwrappedValue['beforeRemove'],
                'afterRender': unwrappedValue['afterRender'],
                'beforeMove': unwrappedValue['beforeMove'],
                'afterMove': unwrappedValue['afterMove'],
                'templateEngine': ko.nativeTemplateEngine.instance
            };
        };
    },
    'init': function(element, valueAccessor, allBindings, viewModel, bindingContext) {
        return ko.bindingHandlers['template']['init'](element, ko.bindingHandlers['foreach'].makeTemplateValueAccessor(valueAccessor));
    },
    'update': function(element, valueAccessor, allBindings, viewModel, bindingContext) {
        return ko.bindingHandlers['template']['update'](element, ko.bindingHandlers['foreach'].makeTemplateValueAccessor(valueAccessor), allBindings, viewModel, bindingContext);
    }
};
ko.expressionRewriting.bindingRewriteValidators['foreach'] = false; // Can't rewrite control flow bindings
ko.virtualElements.allowedBindings['foreach'] = true;
var hasfocusUpdatingProperty = '__ko_hasfocusUpdating';
var hasfocusLastValue = '__ko_hasfocusLastValue';
ko.bindingHandlers['hasfocus'] = {
    'init': function(element, valueAccessor, allBindings) {
        var handleElementFocusChange = function(isFocused) {
            // Where possible, ignore which event was raised and determine focus state using activeElement,
            // as this avoids phantom focus/blur events raised when changing tabs in modern browsers.
            // However, not all KO-targeted browsers (Firefox 2) support activeElement. For those browsers,
            // prevent a loss of focus when changing tabs/windows by setting a flag that prevents hasfocus
            // from calling 'blur()' on the element when it loses focus.
            // Discussion at https://github.com/SteveSanderson/knockout/pull/352
            element[hasfocusUpdatingProperty] = true;
            var ownerDoc = element.ownerDocument;
            if ("activeElement" in ownerDoc) {
                var active;
                try {
                    active = ownerDoc.activeElement;
                } catch(e) {
                    // IE9 throws if you access activeElement during page load (see issue #703)
                    active = ownerDoc.body;
                }
                isFocused = (active === element);
            }
            var modelValue = valueAccessor();
            ko.expressionRewriting.writeValueToProperty(modelValue, allBindings, 'hasfocus', isFocused, true);

            //cache the latest value, so we can avoid unnecessarily calling focus/blur in the update function
            element[hasfocusLastValue] = isFocused;
            element[hasfocusUpdatingProperty] = false;
        };
        var handleElementFocusIn = handleElementFocusChange.bind(null, true);
        var handleElementFocusOut = handleElementFocusChange.bind(null, false);

        ko.utils.registerEventHandler(element, "focus", handleElementFocusIn);
        ko.utils.registerEventHandler(element, "focusin", handleElementFocusIn); // For IE
        ko.utils.registerEventHandler(element, "blur",  handleElementFocusOut);
        ko.utils.registerEventHandler(element, "focusout",  handleElementFocusOut); // For IE
    },
    'update': function(element, valueAccessor) {
        var value = !!ko.utils.unwrapObservable(valueAccessor()); //force boolean to compare with last value
        if (!element[hasfocusUpdatingProperty] && element[hasfocusLastValue] !== value) {
            value ? element.focus() : element.blur();
            ko.dependencyDetection.ignore(ko.utils.triggerEvent, null, [element, value ? "focusin" : "focusout"]); // For IE, which doesn't reliably fire "focus" or "blur" events synchronously
        }
    }
};
ko.expressionRewriting.twoWayBindings['hasfocus'] = true;

ko.bindingHandlers['hasFocus'] = ko.bindingHandlers['hasfocus']; // Make "hasFocus" an alias
ko.expressionRewriting.twoWayBindings['hasFocus'] = true;
ko.bindingHandlers['html'] = {
    'init': function() {
        // Prevent binding on the dynamically-injected HTML (as developers are unlikely to expect that, and it has security implications)
        return { 'controlsDescendantBindings': true };
    },
    'update': function (element, valueAccessor) {
        // setHtml will unwrap the value if needed
        ko.utils.setHtml(element, valueAccessor());
    }
};
// Makes a binding like with or if
function makeWithIfBinding(bindingKey, isWith, isNot, makeContextCallback) {
    ko.bindingHandlers[bindingKey] = {
        'init': function(element, valueAccessor, allBindings, viewModel, bindingContext) {
            var didDisplayOnLastUpdate,
                savedNodes;
            ko.computed(function() {
                var dataValue = ko.utils.unwrapObservable(valueAccessor()),
                    shouldDisplay = !isNot !== !dataValue, // equivalent to isNot ? !dataValue : !!dataValue
                    isFirstRender = !savedNodes,
                    needsRefresh = isFirstRender || isWith || (shouldDisplay !== didDisplayOnLastUpdate);

                if (needsRefresh) {
                    // Save a copy of the inner nodes on the initial update, but only if we have dependencies.
                    if (isFirstRender && ko.computedContext.getDependenciesCount()) {
                        savedNodes = ko.utils.cloneNodes(ko.virtualElements.childNodes(element), true /* shouldCleanNodes */);
                    }

                    if (shouldDisplay) {
                        if (!isFirstRender) {
                            ko.virtualElements.setDomNodeChildren(element, ko.utils.cloneNodes(savedNodes));
                        }
                        ko.applyBindingsToDescendants(makeContextCallback ? makeContextCallback(bindingContext, dataValue) : bindingContext, element);
                    } else {
                        ko.virtualElements.emptyNode(element);
                    }

                    didDisplayOnLastUpdate = shouldDisplay;
                }
            }, null, { disposeWhenNodeIsRemoved: element });
            return { 'controlsDescendantBindings': true };
        }
    };
    ko.expressionRewriting.bindingRewriteValidators[bindingKey] = false; // Can't rewrite control flow bindings
    ko.virtualElements.allowedBindings[bindingKey] = true;
}

// Construct the actual binding handlers
makeWithIfBinding('if');
makeWithIfBinding('ifnot', false /* isWith */, true /* isNot */);
makeWithIfBinding('with', true /* isWith */, false /* isNot */,
    function(bindingContext, dataValue) {
        return bindingContext['createChildContext'](dataValue);
    }
);
var captionPlaceholder = {};
ko.bindingHandlers['options'] = {
    'init': function(element) {
        if (ko.utils.tagNameLower(element) !== "select")
            throw new Error("options binding applies only to SELECT elements");

        // Remove all existing <option>s.
        while (element.length > 0) {
            element.remove(0);
        }

        // Ensures that the binding processor doesn't try to bind the options
        return { 'controlsDescendantBindings': true };
    },
    'update': function (element, valueAccessor, allBindings) {
        function selectedOptions() {
            return ko.utils.arrayFilter(element.options, function (node) { return node.selected; });
        }

        var selectWasPreviouslyEmpty = element.length == 0;
        var previousScrollTop = (!selectWasPreviouslyEmpty && element.multiple) ? element.scrollTop : null;
        var unwrappedArray = ko.utils.unwrapObservable(valueAccessor());
        var includeDestroyed = allBindings.get('optionsIncludeDestroyed');
        var arrayToDomNodeChildrenOptions = {};
        var captionValue;
        var filteredArray;
        var previousSelectedValues;

        if (element.multiple) {
            previousSelectedValues = ko.utils.arrayMap(selectedOptions(), ko.selectExtensions.readValue);
        } else {
            previousSelectedValues = element.selectedIndex >= 0 ? [ ko.selectExtensions.readValue(element.options[element.selectedIndex]) ] : [];
        }

        if (unwrappedArray) {
            if (typeof unwrappedArray.length == "undefined") // Coerce single value into array
                unwrappedArray = [unwrappedArray];

            // Filter out any entries marked as destroyed
            filteredArray = ko.utils.arrayFilter(unwrappedArray, function(item) {
                return includeDestroyed || item === undefined || item === null || !ko.utils.unwrapObservable(item['_destroy']);
            });

            // If caption is included, add it to the array
            if (allBindings['has']('optionsCaption')) {
                captionValue = ko.utils.unwrapObservable(allBindings.get('optionsCaption'));
                // If caption value is null or undefined, don't show a caption
                if (captionValue !== null && captionValue !== undefined) {
                    filteredArray.unshift(captionPlaceholder);
                }
            }
        } else {
            // If a falsy value is provided (e.g. null), we'll simply empty the select element
        }

        function applyToObject(object, predicate, defaultValue) {
            var predicateType = typeof predicate;
            if (predicateType == "function")    // Given a function; run it against the data value
                return predicate(object);
            else if (predicateType == "string") // Given a string; treat it as a property name on the data value
                return object[predicate];
            else                                // Given no optionsText arg; use the data value itself
                return defaultValue;
        }

        // The following functions can run at two different times:
        // The first is when the whole array is being updated directly from this binding handler.
        // The second is when an observable value for a specific array entry is updated.
        // oldOptions will be empty in the first case, but will be filled with the previously generated option in the second.
        var itemUpdate = false;
        function optionForArrayItem(arrayEntry, index, oldOptions) {
            if (oldOptions.length) {
                previousSelectedValues = oldOptions[0].selected ? [ ko.selectExtensions.readValue(oldOptions[0]) ] : [];
                itemUpdate = true;
            }
            var option = element.ownerDocument.createElement("option");
            if (arrayEntry === captionPlaceholder) {
                ko.utils.setTextContent(option, allBindings.get('optionsCaption'));
                ko.selectExtensions.writeValue(option, undefined);
            } else {
                // Apply a value to the option element
                var optionValue = applyToObject(arrayEntry, allBindings.get('optionsValue'), arrayEntry);
                ko.selectExtensions.writeValue(option, ko.utils.unwrapObservable(optionValue));

                // Apply some text to the option element
                var optionText = applyToObject(arrayEntry, allBindings.get('optionsText'), optionValue);
                ko.utils.setTextContent(option, optionText);
            }
            return [option];
        }

        // By using a beforeRemove callback, we delay the removal until after new items are added. This fixes a selection
        // problem in IE<=8 and Firefox. See https://github.com/knockout/knockout/issues/1208
        arrayToDomNodeChildrenOptions['beforeRemove'] =
            function (option) {
                element.removeChild(option);
            };

        function setSelectionCallback(arrayEntry, newOptions) {
            // IE6 doesn't like us to assign selection to OPTION nodes before they're added to the document.
            // That's why we first added them without selection. Now it's time to set the selection.
            if (previousSelectedValues.length) {
                var isSelected = ko.utils.arrayIndexOf(previousSelectedValues, ko.selectExtensions.readValue(newOptions[0])) >= 0;
                ko.utils.setOptionNodeSelectionState(newOptions[0], isSelected);

                // If this option was changed from being selected during a single-item update, notify the change
                if (itemUpdate && !isSelected)
                    ko.dependencyDetection.ignore(ko.utils.triggerEvent, null, [element, "change"]);
            }
        }

        var callback = setSelectionCallback;
        if (allBindings['has']('optionsAfterRender')) {
            callback = function(arrayEntry, newOptions) {
                setSelectionCallback(arrayEntry, newOptions);
                ko.dependencyDetection.ignore(allBindings.get('optionsAfterRender'), null, [newOptions[0], arrayEntry !== captionPlaceholder ? arrayEntry : undefined]);
            }
        }

        ko.utils.setDomNodeChildrenFromArrayMapping(element, filteredArray, optionForArrayItem, arrayToDomNodeChildrenOptions, callback);

        ko.dependencyDetection.ignore(function () {
            if (allBindings.get('valueAllowUnset') && allBindings['has']('value')) {
                // The model value is authoritative, so make sure its value is the one selected
                ko.selectExtensions.writeValue(element, ko.utils.unwrapObservable(allBindings.get('value')), true /* allowUnset */);
            } else {
                // Determine if the selection has changed as a result of updating the options list
                var selectionChanged;
                if (element.multiple) {
                    // For a multiple-select box, compare the new selection count to the previous one
                    // But if nothing was selected before, the selection can't have changed
                    selectionChanged = previousSelectedValues.length && selectedOptions().length < previousSelectedValues.length;
                } else {
                    // For a single-select box, compare the current value to the previous value
                    // But if nothing was selected before or nothing is selected now, just look for a change in selection
                    selectionChanged = (previousSelectedValues.length && element.selectedIndex >= 0)
                        ? (ko.selectExtensions.readValue(element.options[element.selectedIndex]) !== previousSelectedValues[0])
                        : (previousSelectedValues.length || element.selectedIndex >= 0);
                }

                // Ensure consistency between model value and selected option.
                // If the dropdown was changed so that selection is no longer the same,
                // notify the value or selectedOptions binding.
                if (selectionChanged) {
                    ko.utils.triggerEvent(element, "change");
                }
            }
        });

        // Workaround for IE bug
        ko.utils.ensureSelectElementIsRenderedCorrectly(element);

        if (previousScrollTop && Math.abs(previousScrollTop - element.scrollTop) > 20)
            element.scrollTop = previousScrollTop;
    }
};
ko.bindingHandlers['options'].optionValueDomDataKey = ko.utils.domData.nextKey();
ko.bindingHandlers['selectedOptions'] = {
    'after': ['options', 'foreach'],
    'init': function (element, valueAccessor, allBindings) {
        ko.utils.registerEventHandler(element, "change", function () {
            var value = valueAccessor(), valueToWrite = [];
            ko.utils.arrayForEach(element.getElementsByTagName("option"), function(node) {
                if (node.selected)
                    valueToWrite.push(ko.selectExtensions.readValue(node));
            });
            ko.expressionRewriting.writeValueToProperty(value, allBindings, 'selectedOptions', valueToWrite);
        });
    },
    'update': function (element, valueAccessor) {
        if (ko.utils.tagNameLower(element) != "select")
            throw new Error("values binding applies only to SELECT elements");

        var newValue = ko.utils.unwrapObservable(valueAccessor());
        if (newValue && typeof newValue.length == "number") {
            ko.utils.arrayForEach(element.getElementsByTagName("option"), function(node) {
                var isSelected = ko.utils.arrayIndexOf(newValue, ko.selectExtensions.readValue(node)) >= 0;
                ko.utils.setOptionNodeSelectionState(node, isSelected);
            });
        }
    }
};
ko.expressionRewriting.twoWayBindings['selectedOptions'] = true;
ko.bindingHandlers['style'] = {
    'update': function (element, valueAccessor) {
        var value = ko.utils.unwrapObservable(valueAccessor() || {});
        ko.utils.objectForEach(value, function(styleName, styleValue) {
            styleValue = ko.utils.unwrapObservable(styleValue);

            if (styleValue === null || styleValue === undefined || styleValue === false) {
                // Empty string removes the value, whereas null/undefined have no effect
                styleValue = "";
            }

            element.style[styleName] = styleValue;
        });
    }
};
ko.bindingHandlers['submit'] = {
    'init': function (element, valueAccessor, allBindings, viewModel, bindingContext) {
        if (typeof valueAccessor() != "function")
            throw new Error("The value for a submit binding must be a function");
        ko.utils.registerEventHandler(element, "submit", function (event) {
            var handlerReturnValue;
            var value = valueAccessor();
            try { handlerReturnValue = value.call(bindingContext['$data'], element); }
            finally {
                if (handlerReturnValue !== true) { // Normally we want to prevent default action. Developer can override this be explicitly returning true.
                    if (event.preventDefault)
                        event.preventDefault();
                    else
                        event.returnValue = false;
                }
            }
        });
    }
};
ko.bindingHandlers['text'] = {
    'init': function() {
        // Prevent binding on the dynamically-injected text node (as developers are unlikely to expect that, and it has security implications).
        // It should also make things faster, as we no longer have to consider whether the text node might be bindable.
        return { 'controlsDescendantBindings': true };
    },
    'update': function (element, valueAccessor) {
        ko.utils.setTextContent(element, valueAccessor());
    }
};
ko.virtualElements.allowedBindings['text'] = true;
(function () {

if (window && window.navigator) {
    var parseVersion = function (matches) {
        if (matches) {
            return parseFloat(matches[1]);
        }
    };

    // Detect various browser versions because some old versions don't fully support the 'input' event
    var operaVersion = window.opera && window.opera.version && parseInt(window.opera.version()),
        userAgent = window.navigator.userAgent,
        safariVersion = parseVersion(userAgent.match(/^(?:(?!chrome).)*version\/([^ ]*) safari/i)),
        firefoxVersion = parseVersion(userAgent.match(/Firefox\/([^ ]*)/));
}

// IE 8 and 9 have bugs that prevent the normal events from firing when the value changes.
// But it does fire the 'selectionchange' event on many of those, presumably because the
// cursor is moving and that counts as the selection changing. The 'selectionchange' event is
// fired at the document level only and doesn't directly indicate which element changed. We
// set up just one event handler for the document and use 'activeElement' to determine which
// element was changed.
if (ko.utils.ieVersion < 10) {
    var selectionChangeRegisteredName = ko.utils.domData.nextKey(),
        selectionChangeHandlerName = ko.utils.domData.nextKey();
    var selectionChangeHandler = function(event) {
        var target = this.activeElement,
            handler = target && ko.utils.domData.get(target, selectionChangeHandlerName);
        if (handler) {
            handler(event);
        }
    };
    var registerForSelectionChangeEvent = function (element, handler) {
        var ownerDoc = element.ownerDocument;
        if (!ko.utils.domData.get(ownerDoc, selectionChangeRegisteredName)) {
            ko.utils.domData.set(ownerDoc, selectionChangeRegisteredName, true);
            ko.utils.registerEventHandler(ownerDoc, 'selectionchange', selectionChangeHandler);
        }
        ko.utils.domData.set(element, selectionChangeHandlerName, handler);
    };
}

ko.bindingHandlers['textInput'] = {
    'init': function (element, valueAccessor, allBindings) {

        var previousElementValue = element.value,
            timeoutHandle,
            elementValueBeforeEvent;

        var updateModel = function (event) {
            clearTimeout(timeoutHandle);
            elementValueBeforeEvent = timeoutHandle = undefined;

            var elementValue = element.value;
            if (previousElementValue !== elementValue) {
                // Provide a way for tests to know exactly which event was processed
                if (DEBUG && event) element['_ko_textInputProcessedEvent'] = event.type;
                previousElementValue = elementValue;
                ko.expressionRewriting.writeValueToProperty(valueAccessor(), allBindings, 'textInput', elementValue);
            }
        };

        var deferUpdateModel = function (event) {
            if (!timeoutHandle) {
                // The elementValueBeforeEvent variable is set *only* during the brief gap between an
                // event firing and the updateModel function running. This allows us to ignore model
                // updates that are from the previous state of the element, usually due to techniques
                // such as rateLimit. Such updates, if not ignored, can cause keystrokes to be lost.
                elementValueBeforeEvent = element.value;
                var handler = DEBUG ? updateModel.bind(element, {type: event.type}) : updateModel;
                timeoutHandle = setTimeout(handler, 4);
            }
        };

        var updateView = function () {
            var modelValue = ko.utils.unwrapObservable(valueAccessor());

            if (modelValue === null || modelValue === undefined) {
                modelValue = '';
            }

            if (elementValueBeforeEvent !== undefined && modelValue === elementValueBeforeEvent) {
                setTimeout(updateView, 4);
                return;
            }

            // Update the element only if the element and model are different. On some browsers, updating the value
            // will move the cursor to the end of the input, which would be bad while the user is typing.
            if (element.value !== modelValue) {
                previousElementValue = modelValue;  // Make sure we ignore events (propertychange) that result from updating the value
                element.value = modelValue;
            }
        };

        var onEvent = function (event, handler) {
            ko.utils.registerEventHandler(element, event, handler);
        };

        if (DEBUG && ko.bindingHandlers['textInput']['_forceUpdateOn']) {
            // Provide a way for tests to specify exactly which events are bound
            ko.utils.arrayForEach(ko.bindingHandlers['textInput']['_forceUpdateOn'], function(eventName) {
                if (eventName.slice(0,5) == 'after') {
                    onEvent(eventName.slice(5), deferUpdateModel);
                } else {
                    onEvent(eventName, updateModel);
                }
            });
        } else {
            if (ko.utils.ieVersion < 10) {
                // Internet Explorer <= 8 doesn't support the 'input' event, but does include 'propertychange' that fires whenever
                // any property of an element changes. Unlike 'input', it also fires if a property is changed from JavaScript code,
                // but that's an acceptable compromise for this binding. IE 9 does support 'input', but since it doesn't fire it
                // when using autocomplete, we'll use 'propertychange' for it also.
                onEvent('propertychange', function(event) {
                    if (event.propertyName === 'value') {
                        updateModel(event);
                    }
                });

                if (ko.utils.ieVersion == 8) {
                    // IE 8 has a bug where it fails to fire 'propertychange' on the first update following a value change from
                    // JavaScript code. It also doesn't fire if you clear the entire value. To fix this, we bind to the following
                    // events too.
                    onEvent('keyup', updateModel);      // A single keystoke
                    onEvent('keydown', updateModel);    // The first character when a key is held down
                }
                if (ko.utils.ieVersion >= 8) {
                    // Internet Explorer 9 doesn't fire the 'input' event when deleting text, including using
                    // the backspace, delete, or ctrl-x keys, clicking the 'x' to clear the input, dragging text
                    // out of the field, and cutting or deleting text using the context menu. 'selectionchange'
                    // can detect all of those except dragging text out of the field, for which we use 'dragend'.
                    // These are also needed in IE8 because of the bug described above.
                    registerForSelectionChangeEvent(element, updateModel);  // 'selectionchange' covers cut, paste, drop, delete, etc.
                    onEvent('dragend', deferUpdateModel);
                }
            } else {
                // All other supported browsers support the 'input' event, which fires whenever the content of the element is changed
                // through the user interface.
                onEvent('input', updateModel);

                if (safariVersion < 5 && ko.utils.tagNameLower(element) === "textarea") {
                    // Safari <5 doesn't fire the 'input' event for <textarea> elements (it does fire 'textInput'
                    // but only when typing). So we'll just catch as much as we can with keydown, cut, and paste.
                    onEvent('keydown', deferUpdateModel);
                    onEvent('paste', deferUpdateModel);
                    onEvent('cut', deferUpdateModel);
                } else if (operaVersion < 11) {
                    // Opera 10 doesn't always fire the 'input' event for cut, paste, undo & drop operations.
                    // We can try to catch some of those using 'keydown'.
                    onEvent('keydown', deferUpdateModel);
                } else if (firefoxVersion < 4.0) {
                    // Firefox <= 3.6 doesn't fire the 'input' event when text is filled in through autocomplete
                    onEvent('DOMAutoComplete', updateModel);

                    // Firefox <=3.5 doesn't fire the 'input' event when text is dropped into the input.
                    onEvent('dragdrop', updateModel);       // <3.5
                    onEvent('drop', updateModel);           // 3.5
                }
            }
        }

        // Bind to the change event so that we can catch programmatic updates of the value that fire this event.
        onEvent('change', updateModel);

        ko.computed(updateView, null, { disposeWhenNodeIsRemoved: element });
    }
};
ko.expressionRewriting.twoWayBindings['textInput'] = true;

// textinput is an alias for textInput
ko.bindingHandlers['textinput'] = {
    // preprocess is the only way to set up a full alias
    'preprocess': function (value, name, addBinding) {
        addBinding('textInput', value);
    }
};

})();ko.bindingHandlers['uniqueName'] = {
    'init': function (element, valueAccessor) {
        if (valueAccessor()) {
            var name = "ko_unique_" + (++ko.bindingHandlers['uniqueName'].currentIndex);
            ko.utils.setElementName(element, name);
        }
    }
};
ko.bindingHandlers['uniqueName'].currentIndex = 0;
ko.bindingHandlers['value'] = {
    'after': ['options', 'foreach'],
    'init': function (element, valueAccessor, allBindings) {
        // If the value binding is placed on a radio/checkbox, then just pass through to checkedValue and quit
        if (element.tagName.toLowerCase() == "input" && (element.type == "checkbox" || element.type == "radio")) {
            ko.applyBindingAccessorsToNode(element, { 'checkedValue': valueAccessor });
            return;
        }

        // Always catch "change" event; possibly other events too if asked
        var eventsToCatch = ["change"];
        var requestedEventsToCatch = allBindings.get("valueUpdate");
        var propertyChangedFired = false;
        var elementValueBeforeEvent = null;

        if (requestedEventsToCatch) {
            if (typeof requestedEventsToCatch == "string") // Allow both individual event names, and arrays of event names
                requestedEventsToCatch = [requestedEventsToCatch];
            ko.utils.arrayPushAll(eventsToCatch, requestedEventsToCatch);
            eventsToCatch = ko.utils.arrayGetDistinctValues(eventsToCatch);
        }

        var valueUpdateHandler = function() {
            elementValueBeforeEvent = null;
            propertyChangedFired = false;
            var modelValue = valueAccessor();
            var elementValue = ko.selectExtensions.readValue(element);
            ko.expressionRewriting.writeValueToProperty(modelValue, allBindings, 'value', elementValue);
        }

        // Workaround for https://github.com/SteveSanderson/knockout/issues/122
        // IE doesn't fire "change" events on textboxes if the user selects a value from its autocomplete list
        var ieAutoCompleteHackNeeded = ko.utils.ieVersion && element.tagName.toLowerCase() == "input" && element.type == "text"
                                       && element.autocomplete != "off" && (!element.form || element.form.autocomplete != "off");
        if (ieAutoCompleteHackNeeded && ko.utils.arrayIndexOf(eventsToCatch, "propertychange") == -1) {
            ko.utils.registerEventHandler(element, "propertychange", function () { propertyChangedFired = true });
            ko.utils.registerEventHandler(element, "focus", function () { propertyChangedFired = false });
            ko.utils.registerEventHandler(element, "blur", function() {
                if (propertyChangedFired) {
                    valueUpdateHandler();
                }
            });
        }

        ko.utils.arrayForEach(eventsToCatch, function(eventName) {
            // The syntax "after<eventname>" means "run the handler asynchronously after the event"
            // This is useful, for example, to catch "keydown" events after the browser has updated the control
            // (otherwise, ko.selectExtensions.readValue(this) will receive the control's value *before* the key event)
            var handler = valueUpdateHandler;
            if (ko.utils.stringStartsWith(eventName, "after")) {
                handler = function() {
                    // The elementValueBeforeEvent variable is non-null *only* during the brief gap between
                    // a keyX event firing and the valueUpdateHandler running, which is scheduled to happen
                    // at the earliest asynchronous opportunity. We store this temporary information so that
                    // if, between keyX and valueUpdateHandler, the underlying model value changes separately,
                    // we can overwrite that model value change with the value the user just typed. Otherwise,
                    // techniques like rateLimit can trigger model changes at critical moments that will
                    // override the user's inputs, causing keystrokes to be lost.
                    elementValueBeforeEvent = ko.selectExtensions.readValue(element);
                    setTimeout(valueUpdateHandler, 0);
                };
                eventName = eventName.substring("after".length);
            }
            ko.utils.registerEventHandler(element, eventName, handler);
        });

        var updateFromModel = function () {
            var newValue = ko.utils.unwrapObservable(valueAccessor());
            var elementValue = ko.selectExtensions.readValue(element);

            if (elementValueBeforeEvent !== null && newValue === elementValueBeforeEvent) {
                setTimeout(updateFromModel, 0);
                return;
            }

            var valueHasChanged = (newValue !== elementValue);

            if (valueHasChanged) {
                if (ko.utils.tagNameLower(element) === "select") {
                    var allowUnset = allBindings.get('valueAllowUnset');
                    var applyValueAction = function () {
                        ko.selectExtensions.writeValue(element, newValue, allowUnset);
                    };
                    applyValueAction();

                    if (!allowUnset && newValue !== ko.selectExtensions.readValue(element)) {
                        // If you try to set a model value that can't be represented in an already-populated dropdown, reject that change,
                        // because you're not allowed to have a model value that disagrees with a visible UI selection.
                        ko.dependencyDetection.ignore(ko.utils.triggerEvent, null, [element, "change"]);
                    } else {
                        // Workaround for IE6 bug: It won't reliably apply values to SELECT nodes during the same execution thread
                        // right after you've changed the set of OPTION nodes on it. So for that node type, we'll schedule a second thread
                        // to apply the value as well.
                        setTimeout(applyValueAction, 0);
                    }
                } else {
                    ko.selectExtensions.writeValue(element, newValue);
                }
            }
        };

        ko.computed(updateFromModel, null, { disposeWhenNodeIsRemoved: element });
    },
    'update': function() {} // Keep for backwards compatibility with code that may have wrapped value binding
};
ko.expressionRewriting.twoWayBindings['value'] = true;
ko.bindingHandlers['visible'] = {
    'update': function (element, valueAccessor) {
        var value = ko.utils.unwrapObservable(valueAccessor());
        var isCurrentlyVisible = !(element.style.display == "none");
        if (value && !isCurrentlyVisible)
            element.style.display = "";
        else if ((!value) && isCurrentlyVisible)
            element.style.display = "none";
    }
};
// 'click' is just a shorthand for the usual full-length event:{click:handler}
makeEventHandlerShortcut('click');
// If you want to make a custom template engine,
//
// [1] Inherit from this class (like ko.nativeTemplateEngine does)
// [2] Override 'renderTemplateSource', supplying a function with this signature:
//
//        function (templateSource, bindingContext, options) {
//            // - templateSource.text() is the text of the template you should render
//            // - bindingContext.$data is the data you should pass into the template
//            //   - you might also want to make bindingContext.$parent, bindingContext.$parents,
//            //     and bindingContext.$root available in the template too
//            // - options gives you access to any other properties set on "data-bind: { template: options }"
//            //
//            // Return value: an array of DOM nodes
//        }
//
// [3] Override 'createJavaScriptEvaluatorBlock', supplying a function with this signature:
//
//        function (script) {
//            // Return value: Whatever syntax means "Evaluate the JavaScript statement 'script' and output the result"
//            //               For example, the jquery.tmpl template engine converts 'someScript' to '${ someScript }'
//        }
//
//     This is only necessary if you want to allow data-bind attributes to reference arbitrary template variables.
//     If you don't want to allow that, you can set the property 'allowTemplateRewriting' to false (like ko.nativeTemplateEngine does)
//     and then you don't need to override 'createJavaScriptEvaluatorBlock'.

ko.templateEngine = function () { };

ko.templateEngine.prototype['renderTemplateSource'] = function (templateSource, bindingContext, options) {
    throw new Error("Override renderTemplateSource");
};

ko.templateEngine.prototype['createJavaScriptEvaluatorBlock'] = function (script) {
    throw new Error("Override createJavaScriptEvaluatorBlock");
};

ko.templateEngine.prototype['makeTemplateSource'] = function(template, templateDocument) {
    // Named template
    if (typeof template == "string") {
        templateDocument = templateDocument || document;
        var elem = templateDocument.getElementById(template);
        if (!elem)
            throw new Error("Cannot find template with ID " + template);
        return new ko.templateSources.domElement(elem);
    } else if ((template.nodeType == 1) || (template.nodeType == 8)) {
        // Anonymous template
        return new ko.templateSources.anonymousTemplate(template);
    } else
        throw new Error("Unknown template type: " + template);
};

ko.templateEngine.prototype['renderTemplate'] = function (template, bindingContext, options, templateDocument) {
    var templateSource = this['makeTemplateSource'](template, templateDocument);
    return this['renderTemplateSource'](templateSource, bindingContext, options);
};

ko.templateEngine.prototype['isTemplateRewritten'] = function (template, templateDocument) {
    // Skip rewriting if requested
    if (this['allowTemplateRewriting'] === false)
        return true;
    return this['makeTemplateSource'](template, templateDocument)['data']("isRewritten");
};

ko.templateEngine.prototype['rewriteTemplate'] = function (template, rewriterCallback, templateDocument) {
    var templateSource = this['makeTemplateSource'](template, templateDocument);
    var rewritten = rewriterCallback(templateSource['text']());
    templateSource['text'](rewritten);
    templateSource['data']("isRewritten", true);
};

ko.exportSymbol('templateEngine', ko.templateEngine);

ko.templateRewriting = (function () {
    var memoizeDataBindingAttributeSyntaxRegex = /(<([a-z]+\d*)(?:\s+(?!data-bind\s*=\s*)[a-z0-9\-]+(?:=(?:\"[^\"]*\"|\'[^\']*\'))?)*\s+)data-bind\s*=\s*(["'])([\s\S]*?)\3/gi;
    var memoizeVirtualContainerBindingSyntaxRegex = /<!--\s*ko\b\s*([\s\S]*?)\s*-->/g;

    function validateDataBindValuesForRewriting(keyValueArray) {
        var allValidators = ko.expressionRewriting.bindingRewriteValidators;
        for (var i = 0; i < keyValueArray.length; i++) {
            var key = keyValueArray[i]['key'];
            if (allValidators.hasOwnProperty(key)) {
                var validator = allValidators[key];

                if (typeof validator === "function") {
                    var possibleErrorMessage = validator(keyValueArray[i]['value']);
                    if (possibleErrorMessage)
                        throw new Error(possibleErrorMessage);
                } else if (!validator) {
                    throw new Error("This template engine does not support the '" + key + "' binding within its templates");
                }
            }
        }
    }

    function constructMemoizedTagReplacement(dataBindAttributeValue, tagToRetain, nodeName, templateEngine) {
        var dataBindKeyValueArray = ko.expressionRewriting.parseObjectLiteral(dataBindAttributeValue);
        validateDataBindValuesForRewriting(dataBindKeyValueArray);
        var rewrittenDataBindAttributeValue = ko.expressionRewriting.preProcessBindings(dataBindKeyValueArray, {'valueAccessors':true});

        // For no obvious reason, Opera fails to evaluate rewrittenDataBindAttributeValue unless it's wrapped in an additional
        // anonymous function, even though Opera's built-in debugger can evaluate it anyway. No other browser requires this
        // extra indirection.
        var applyBindingsToNextSiblingScript =
            "ko.__tr_ambtns(function($context,$element){return(function(){return{ " + rewrittenDataBindAttributeValue + " } })()},'" + nodeName.toLowerCase() + "')";
        return templateEngine['createJavaScriptEvaluatorBlock'](applyBindingsToNextSiblingScript) + tagToRetain;
    }

    return {
        ensureTemplateIsRewritten: function (template, templateEngine, templateDocument) {
            if (!templateEngine['isTemplateRewritten'](template, templateDocument))
                templateEngine['rewriteTemplate'](template, function (htmlString) {
                    return ko.templateRewriting.memoizeBindingAttributeSyntax(htmlString, templateEngine);
                }, templateDocument);
        },

        memoizeBindingAttributeSyntax: function (htmlString, templateEngine) {
            return htmlString.replace(memoizeDataBindingAttributeSyntaxRegex, function () {
                return constructMemoizedTagReplacement(/* dataBindAttributeValue: */ arguments[4], /* tagToRetain: */ arguments[1], /* nodeName: */ arguments[2], templateEngine);
            }).replace(memoizeVirtualContainerBindingSyntaxRegex, function() {
                return constructMemoizedTagReplacement(/* dataBindAttributeValue: */ arguments[1], /* tagToRetain: */ "<!-- ko -->", /* nodeName: */ "#comment", templateEngine);
            });
        },

        applyMemoizedBindingsToNextSibling: function (bindings, nodeName) {
            return ko.memoization.memoize(function (domNode, bindingContext) {
                var nodeToBind = domNode.nextSibling;
                if (nodeToBind && nodeToBind.nodeName.toLowerCase() === nodeName) {
                    ko.applyBindingAccessorsToNode(nodeToBind, bindings, bindingContext);
                }
            });
        }
    }
})();


// Exported only because it has to be referenced by string lookup from within rewritten template
ko.exportSymbol('__tr_ambtns', ko.templateRewriting.applyMemoizedBindingsToNextSibling);
(function() {
    // A template source represents a read/write way of accessing a template. This is to eliminate the need for template loading/saving
    // logic to be duplicated in every template engine (and means they can all work with anonymous templates, etc.)
    //
    // Two are provided by default:
    //  1. ko.templateSources.domElement       - reads/writes the text content of an arbitrary DOM element
    //  2. ko.templateSources.anonymousElement - uses ko.utils.domData to read/write text *associated* with the DOM element, but
    //                                           without reading/writing the actual element text content, since it will be overwritten
    //                                           with the rendered template output.
    // You can implement your own template source if you want to fetch/store templates somewhere other than in DOM elements.
    // Template sources need to have the following functions:
    //   text() 			- returns the template text from your storage location
    //   text(value)		- writes the supplied template text to your storage location
    //   data(key)			- reads values stored using data(key, value) - see below
    //   data(key, value)	- associates "value" with this template and the key "key". Is used to store information like "isRewritten".
    //
    // Optionally, template sources can also have the following functions:
    //   nodes()            - returns a DOM element containing the nodes of this template, where available
    //   nodes(value)       - writes the given DOM element to your storage location
    // If a DOM element is available for a given template source, template engines are encouraged to use it in preference over text()
    // for improved speed. However, all templateSources must supply text() even if they don't supply nodes().
    //
    // Once you've implemented a templateSource, make your template engine use it by subclassing whatever template engine you were
    // using and overriding "makeTemplateSource" to return an instance of your custom template source.

    ko.templateSources = {};

    // ---- ko.templateSources.domElement -----

    ko.templateSources.domElement = function(element) {
        this.domElement = element;
    }

    ko.templateSources.domElement.prototype['text'] = function(/* valueToWrite */) {
        var tagNameLower = ko.utils.tagNameLower(this.domElement),
            elemContentsProperty = tagNameLower === "script" ? "text"
                                 : tagNameLower === "textarea" ? "value"
                                 : "innerHTML";

        if (arguments.length == 0) {
            return this.domElement[elemContentsProperty];
        } else {
            var valueToWrite = arguments[0];
            if (elemContentsProperty === "innerHTML")
                ko.utils.setHtml(this.domElement, valueToWrite);
            else
                this.domElement[elemContentsProperty] = valueToWrite;
        }
    };

    var dataDomDataPrefix = ko.utils.domData.nextKey() + "_";
    ko.templateSources.domElement.prototype['data'] = function(key /*, valueToWrite */) {
        if (arguments.length === 1) {
            return ko.utils.domData.get(this.domElement, dataDomDataPrefix + key);
        } else {
            ko.utils.domData.set(this.domElement, dataDomDataPrefix + key, arguments[1]);
        }
    };

    // ---- ko.templateSources.anonymousTemplate -----
    // Anonymous templates are normally saved/retrieved as DOM nodes through "nodes".
    // For compatibility, you can also read "text"; it will be serialized from the nodes on demand.
    // Writing to "text" is still supported, but then the template data will not be available as DOM nodes.

    var anonymousTemplatesDomDataKey = ko.utils.domData.nextKey();
    ko.templateSources.anonymousTemplate = function(element) {
        this.domElement = element;
    }
    ko.templateSources.anonymousTemplate.prototype = new ko.templateSources.domElement();
    ko.templateSources.anonymousTemplate.prototype.constructor = ko.templateSources.anonymousTemplate;
    ko.templateSources.anonymousTemplate.prototype['text'] = function(/* valueToWrite */) {
        if (arguments.length == 0) {
            var templateData = ko.utils.domData.get(this.domElement, anonymousTemplatesDomDataKey) || {};
            if (templateData.textData === undefined && templateData.containerData)
                templateData.textData = templateData.containerData.innerHTML;
            return templateData.textData;
        } else {
            var valueToWrite = arguments[0];
            ko.utils.domData.set(this.domElement, anonymousTemplatesDomDataKey, {textData: valueToWrite});
        }
    };
    ko.templateSources.domElement.prototype['nodes'] = function(/* valueToWrite */) {
        if (arguments.length == 0) {
            var templateData = ko.utils.domData.get(this.domElement, anonymousTemplatesDomDataKey) || {};
            return templateData.containerData;
        } else {
            var valueToWrite = arguments[0];
            ko.utils.domData.set(this.domElement, anonymousTemplatesDomDataKey, {containerData: valueToWrite});
        }
    };

    ko.exportSymbol('templateSources', ko.templateSources);
    ko.exportSymbol('templateSources.domElement', ko.templateSources.domElement);
    ko.exportSymbol('templateSources.anonymousTemplate', ko.templateSources.anonymousTemplate);
})();
(function () {
    var _templateEngine;
    ko.setTemplateEngine = function (templateEngine) {
        if ((templateEngine != undefined) && !(templateEngine instanceof ko.templateEngine))
            throw new Error("templateEngine must inherit from ko.templateEngine");
        _templateEngine = templateEngine;
    }

    function invokeForEachNodeInContinuousRange(firstNode, lastNode, action) {
        var node, nextInQueue = firstNode, firstOutOfRangeNode = ko.virtualElements.nextSibling(lastNode);
        while (nextInQueue && ((node = nextInQueue) !== firstOutOfRangeNode)) {
            nextInQueue = ko.virtualElements.nextSibling(node);
            action(node, nextInQueue);
        }
    }

    function activateBindingsOnContinuousNodeArray(continuousNodeArray, bindingContext) {
        // To be used on any nodes that have been rendered by a template and have been inserted into some parent element
        // Walks through continuousNodeArray (which *must* be continuous, i.e., an uninterrupted sequence of sibling nodes, because
        // the algorithm for walking them relies on this), and for each top-level item in the virtual-element sense,
        // (1) Does a regular "applyBindings" to associate bindingContext with this node and to activate any non-memoized bindings
        // (2) Unmemoizes any memos in the DOM subtree (e.g., to activate bindings that had been memoized during template rewriting)

        if (continuousNodeArray.length) {
            var firstNode = continuousNodeArray[0],
                lastNode = continuousNodeArray[continuousNodeArray.length - 1],
                parentNode = firstNode.parentNode,
                provider = ko.bindingProvider['instance'],
                preprocessNode = provider['preprocessNode'];

            if (preprocessNode) {
                invokeForEachNodeInContinuousRange(firstNode, lastNode, function(node, nextNodeInRange) {
                    var nodePreviousSibling = node.previousSibling;
                    var newNodes = preprocessNode.call(provider, node);
                    if (newNodes) {
                        if (node === firstNode)
                            firstNode = newNodes[0] || nextNodeInRange;
                        if (node === lastNode)
                            lastNode = newNodes[newNodes.length - 1] || nodePreviousSibling;
                    }
                });

                // Because preprocessNode can change the nodes, including the first and last nodes, update continuousNodeArray to match.
                // We need the full set, including inner nodes, because the unmemoize step might remove the first node (and so the real
                // first node needs to be in the array).
                continuousNodeArray.length = 0;
                if (!firstNode) { // preprocessNode might have removed all the nodes, in which case there's nothing left to do
                    return;
                }
                if (firstNode === lastNode) {
                    continuousNodeArray.push(firstNode);
                } else {
                    continuousNodeArray.push(firstNode, lastNode);
                    ko.utils.fixUpContinuousNodeArray(continuousNodeArray, parentNode);
                }
            }

            // Need to applyBindings *before* unmemoziation, because unmemoization might introduce extra nodes (that we don't want to re-bind)
            // whereas a regular applyBindings won't introduce new memoized nodes
            invokeForEachNodeInContinuousRange(firstNode, lastNode, function(node) {
                if (node.nodeType === 1 || node.nodeType === 8)
                    ko.applyBindings(bindingContext, node);
            });
            invokeForEachNodeInContinuousRange(firstNode, lastNode, function(node) {
                if (node.nodeType === 1 || node.nodeType === 8)
                    ko.memoization.unmemoizeDomNodeAndDescendants(node, [bindingContext]);
            });

            // Make sure any changes done by applyBindings or unmemoize are reflected in the array
            ko.utils.fixUpContinuousNodeArray(continuousNodeArray, parentNode);
        }
    }

    function getFirstNodeFromPossibleArray(nodeOrNodeArray) {
        return nodeOrNodeArray.nodeType ? nodeOrNodeArray
                                        : nodeOrNodeArray.length > 0 ? nodeOrNodeArray[0]
                                        : null;
    }

    function executeTemplate(targetNodeOrNodeArray, renderMode, template, bindingContext, options) {
        options = options || {};
        var firstTargetNode = targetNodeOrNodeArray && getFirstNodeFromPossibleArray(targetNodeOrNodeArray);
        var templateDocument = firstTargetNode && firstTargetNode.ownerDocument;
        var templateEngineToUse = (options['templateEngine'] || _templateEngine);
        ko.templateRewriting.ensureTemplateIsRewritten(template, templateEngineToUse, templateDocument);
        var renderedNodesArray = templateEngineToUse['renderTemplate'](template, bindingContext, options, templateDocument);

        // Loosely check result is an array of DOM nodes
        if ((typeof renderedNodesArray.length != "number") || (renderedNodesArray.length > 0 && typeof renderedNodesArray[0].nodeType != "number"))
            throw new Error("Template engine must return an array of DOM nodes");

        var haveAddedNodesToParent = false;
        switch (renderMode) {
            case "replaceChildren":
                ko.virtualElements.setDomNodeChildren(targetNodeOrNodeArray, renderedNodesArray);
                haveAddedNodesToParent = true;
                break;
            case "replaceNode":
                ko.utils.replaceDomNodes(targetNodeOrNodeArray, renderedNodesArray);
                haveAddedNodesToParent = true;
                break;
            case "ignoreTargetNode": break;
            default:
                throw new Error("Unknown renderMode: " + renderMode);
        }

        if (haveAddedNodesToParent) {
            activateBindingsOnContinuousNodeArray(renderedNodesArray, bindingContext);
            if (options['afterRender'])
                ko.dependencyDetection.ignore(options['afterRender'], null, [renderedNodesArray, bindingContext['$data']]);
        }

        return renderedNodesArray;
    }

    function resolveTemplateName(template, data, context) {
        // The template can be specified as:
        if (ko.isObservable(template)) {
            // 1. An observable, with string value
            return template();
        } else if (typeof template === 'function') {
            // 2. A function of (data, context) returning a string
            return template(data, context);
        } else {
            // 3. A string
            return template;
        }
    }

    ko.renderTemplate = function (template, dataOrBindingContext, options, targetNodeOrNodeArray, renderMode) {
        options = options || {};
        if ((options['templateEngine'] || _templateEngine) == undefined)
            throw new Error("Set a template engine before calling renderTemplate");
        renderMode = renderMode || "replaceChildren";

        if (targetNodeOrNodeArray) {
            var firstTargetNode = getFirstNodeFromPossibleArray(targetNodeOrNodeArray);

            var whenToDispose = function () { return (!firstTargetNode) || !ko.utils.domNodeIsAttachedToDocument(firstTargetNode); }; // Passive disposal (on next evaluation)
            var activelyDisposeWhenNodeIsRemoved = (firstTargetNode && renderMode == "replaceNode") ? firstTargetNode.parentNode : firstTargetNode;

            return ko.dependentObservable( // So the DOM is automatically updated when any dependency changes
                function () {
                    // Ensure we've got a proper binding context to work with
                    var bindingContext = (dataOrBindingContext && (dataOrBindingContext instanceof ko.bindingContext))
                        ? dataOrBindingContext
                        : new ko.bindingContext(ko.utils.unwrapObservable(dataOrBindingContext));

                    var templateName = resolveTemplateName(template, bindingContext['$data'], bindingContext),
                        renderedNodesArray = executeTemplate(targetNodeOrNodeArray, renderMode, templateName, bindingContext, options);

                    if (renderMode == "replaceNode") {
                        targetNodeOrNodeArray = renderedNodesArray;
                        firstTargetNode = getFirstNodeFromPossibleArray(targetNodeOrNodeArray);
                    }
                },
                null,
                { disposeWhen: whenToDispose, disposeWhenNodeIsRemoved: activelyDisposeWhenNodeIsRemoved }
            );
        } else {
            // We don't yet have a DOM node to evaluate, so use a memo and render the template later when there is a DOM node
            return ko.memoization.memoize(function (domNode) {
                ko.renderTemplate(template, dataOrBindingContext, options, domNode, "replaceNode");
            });
        }
    };

    ko.renderTemplateForEach = function (template, arrayOrObservableArray, options, targetNode, parentBindingContext) {
        // Since setDomNodeChildrenFromArrayMapping always calls executeTemplateForArrayItem and then
        // activateBindingsCallback for added items, we can store the binding context in the former to use in the latter.
        var arrayItemContext;

        // This will be called by setDomNodeChildrenFromArrayMapping to get the nodes to add to targetNode
        var executeTemplateForArrayItem = function (arrayValue, index) {
            // Support selecting template as a function of the data being rendered
            arrayItemContext = parentBindingContext['createChildContext'](arrayValue, options['as'], function(context) {
                context['$index'] = index;
            });

            var templateName = resolveTemplateName(template, arrayValue, arrayItemContext);
            return executeTemplate(null, "ignoreTargetNode", templateName, arrayItemContext, options);
        }

        // This will be called whenever setDomNodeChildrenFromArrayMapping has added nodes to targetNode
        var activateBindingsCallback = function(arrayValue, addedNodesArray, index) {
            activateBindingsOnContinuousNodeArray(addedNodesArray, arrayItemContext);
            if (options['afterRender'])
                options['afterRender'](addedNodesArray, arrayValue);
        };

        return ko.dependentObservable(function () {
            var unwrappedArray = ko.utils.unwrapObservable(arrayOrObservableArray) || [];
            if (typeof unwrappedArray.length == "undefined") // Coerce single value into array
                unwrappedArray = [unwrappedArray];

            // Filter out any entries marked as destroyed
            var filteredArray = ko.utils.arrayFilter(unwrappedArray, function(item) {
                return options['includeDestroyed'] || item === undefined || item === null || !ko.utils.unwrapObservable(item['_destroy']);
            });

            // Call setDomNodeChildrenFromArrayMapping, ignoring any observables unwrapped within (most likely from a callback function).
            // If the array items are observables, though, they will be unwrapped in executeTemplateForArrayItem and managed within setDomNodeChildrenFromArrayMapping.
            ko.dependencyDetection.ignore(ko.utils.setDomNodeChildrenFromArrayMapping, null, [targetNode, filteredArray, executeTemplateForArrayItem, options, activateBindingsCallback]);

        }, null, { disposeWhenNodeIsRemoved: targetNode });
    };

    var templateComputedDomDataKey = ko.utils.domData.nextKey();
    function disposeOldComputedAndStoreNewOne(element, newComputed) {
        var oldComputed = ko.utils.domData.get(element, templateComputedDomDataKey);
        if (oldComputed && (typeof(oldComputed.dispose) == 'function'))
            oldComputed.dispose();
        ko.utils.domData.set(element, templateComputedDomDataKey, (newComputed && newComputed.isActive()) ? newComputed : undefined);
    }

    ko.bindingHandlers['template'] = {
        'init': function(element, valueAccessor) {
            // Support anonymous templates
            var bindingValue = ko.utils.unwrapObservable(valueAccessor());
            if (typeof bindingValue == "string" || bindingValue['name']) {
                // It's a named template - clear the element
                ko.virtualElements.emptyNode(element);
            } else {
                // It's an anonymous template - store the element contents, then clear the element
                var templateNodes = ko.virtualElements.childNodes(element),
                    container = ko.utils.moveCleanedNodesToContainerElement(templateNodes); // This also removes the nodes from their current parent
                new ko.templateSources.anonymousTemplate(element)['nodes'](container);
            }
            return { 'controlsDescendantBindings': true };
        },
        'update': function (element, valueAccessor, allBindings, viewModel, bindingContext) {
            var value = valueAccessor(),
                dataValue,
                options = ko.utils.unwrapObservable(value),
                shouldDisplay = true,
                templateComputed = null,
                templateName;

            if (typeof options == "string") {
                templateName = value;
                options = {};
            } else {
                templateName = options['name'];

                // Support "if"/"ifnot" conditions
                if ('if' in options)
                    shouldDisplay = ko.utils.unwrapObservable(options['if']);
                if (shouldDisplay && 'ifnot' in options)
                    shouldDisplay = !ko.utils.unwrapObservable(options['ifnot']);

                dataValue = ko.utils.unwrapObservable(options['data']);
            }

            if ('foreach' in options) {
                // Render once for each data point (treating data set as empty if shouldDisplay==false)
                var dataArray = (shouldDisplay && options['foreach']) || [];
                templateComputed = ko.renderTemplateForEach(templateName || element, dataArray, options, element, bindingContext);
            } else if (!shouldDisplay) {
                ko.virtualElements.emptyNode(element);
            } else {
                // Render once for this single data point (or use the viewModel if no data was provided)
                var innerBindingContext = ('data' in options) ?
                    bindingContext['createChildContext'](dataValue, options['as']) :  // Given an explitit 'data' value, we create a child binding context for it
                    bindingContext;                                                        // Given no explicit 'data' value, we retain the same binding context
                templateComputed = ko.renderTemplate(templateName || element, innerBindingContext, options, element);
            }

            // It only makes sense to have a single template computed per element (otherwise which one should have its output displayed?)
            disposeOldComputedAndStoreNewOne(element, templateComputed);
        }
    };

    // Anonymous templates can't be rewritten. Give a nice error message if you try to do it.
    ko.expressionRewriting.bindingRewriteValidators['template'] = function(bindingValue) {
        var parsedBindingValue = ko.expressionRewriting.parseObjectLiteral(bindingValue);

        if ((parsedBindingValue.length == 1) && parsedBindingValue[0]['unknown'])
            return null; // It looks like a string literal, not an object literal, so treat it as a named template (which is allowed for rewriting)

        if (ko.expressionRewriting.keyValueArrayContainsKey(parsedBindingValue, "name"))
            return null; // Named templates can be rewritten, so return "no error"
        return "This template engine does not support anonymous templates nested within its templates";
    };

    ko.virtualElements.allowedBindings['template'] = true;
})();

ko.exportSymbol('setTemplateEngine', ko.setTemplateEngine);
ko.exportSymbol('renderTemplate', ko.renderTemplate);
// Go through the items that have been added and deleted and try to find matches between them.
ko.utils.findMovesInArrayComparison = function (left, right, limitFailedCompares) {
    if (left.length && right.length) {
        var failedCompares, l, r, leftItem, rightItem;
        for (failedCompares = l = 0; (!limitFailedCompares || failedCompares < limitFailedCompares) && (leftItem = left[l]); ++l) {
            for (r = 0; rightItem = right[r]; ++r) {
                if (leftItem['value'] === rightItem['value']) {
                    leftItem['moved'] = rightItem['index'];
                    rightItem['moved'] = leftItem['index'];
                    right.splice(r, 1);         // This item is marked as moved; so remove it from right list
                    failedCompares = r = 0;     // Reset failed compares count because we're checking for consecutive failures
                    break;
                }
            }
            failedCompares += r;
        }
    }
};

ko.utils.compareArrays = (function () {
    var statusNotInOld = 'added', statusNotInNew = 'deleted';

    // Simple calculation based on Levenshtein distance.
    function compareArrays(oldArray, newArray, options) {
        // For backward compatibility, if the third arg is actually a bool, interpret
        // it as the old parameter 'dontLimitMoves'. Newer code should use { dontLimitMoves: true }.
        options = (typeof options === 'boolean') ? { 'dontLimitMoves': options } : (options || {});
        oldArray = oldArray || [];
        newArray = newArray || [];

        if (oldArray.length <= newArray.length)
            return compareSmallArrayToBigArray(oldArray, newArray, statusNotInOld, statusNotInNew, options);
        else
            return compareSmallArrayToBigArray(newArray, oldArray, statusNotInNew, statusNotInOld, options);
    }

    function compareSmallArrayToBigArray(smlArray, bigArray, statusNotInSml, statusNotInBig, options) {
        var myMin = Math.min,
            myMax = Math.max,
            editDistanceMatrix = [],
            smlIndex, smlIndexMax = smlArray.length,
            bigIndex, bigIndexMax = bigArray.length,
            compareRange = (bigIndexMax - smlIndexMax) || 1,
            maxDistance = smlIndexMax + bigIndexMax + 1,
            thisRow, lastRow,
            bigIndexMaxForRow, bigIndexMinForRow;

        for (smlIndex = 0; smlIndex <= smlIndexMax; smlIndex++) {
            lastRow = thisRow;
            editDistanceMatrix.push(thisRow = []);
            bigIndexMaxForRow = myMin(bigIndexMax, smlIndex + compareRange);
            bigIndexMinForRow = myMax(0, smlIndex - 1);
            for (bigIndex = bigIndexMinForRow; bigIndex <= bigIndexMaxForRow; bigIndex++) {
                if (!bigIndex)
                    thisRow[bigIndex] = smlIndex + 1;
                else if (!smlIndex)  // Top row - transform empty array into new array via additions
                    thisRow[bigIndex] = bigIndex + 1;
                else if (smlArray[smlIndex - 1] === bigArray[bigIndex - 1])
                    thisRow[bigIndex] = lastRow[bigIndex - 1];                  // copy value (no edit)
                else {
                    var northDistance = lastRow[bigIndex] || maxDistance;       // not in big (deletion)
                    var westDistance = thisRow[bigIndex - 1] || maxDistance;    // not in small (addition)
                    thisRow[bigIndex] = myMin(northDistance, westDistance) + 1;
                }
            }
        }

        var editScript = [], meMinusOne, notInSml = [], notInBig = [];
        for (smlIndex = smlIndexMax, bigIndex = bigIndexMax; smlIndex || bigIndex;) {
            meMinusOne = editDistanceMatrix[smlIndex][bigIndex] - 1;
            if (bigIndex && meMinusOne === editDistanceMatrix[smlIndex][bigIndex-1]) {
                notInSml.push(editScript[editScript.length] = {     // added
                    'status': statusNotInSml,
                    'value': bigArray[--bigIndex],
                    'index': bigIndex });
            } else if (smlIndex && meMinusOne === editDistanceMatrix[smlIndex - 1][bigIndex]) {
                notInBig.push(editScript[editScript.length] = {     // deleted
                    'status': statusNotInBig,
                    'value': smlArray[--smlIndex],
                    'index': smlIndex });
            } else {
                --bigIndex;
                --smlIndex;
                if (!options['sparse']) {
                    editScript.push({
                        'status': "retained",
                        'value': bigArray[bigIndex] });
                }
            }
        }

        // Set a limit on the number of consecutive non-matching comparisons; having it a multiple of
        // smlIndexMax keeps the time complexity of this algorithm linear.
        ko.utils.findMovesInArrayComparison(notInSml, notInBig, smlIndexMax * 10);

        return editScript.reverse();
    }

    return compareArrays;
})();

ko.exportSymbol('utils.compareArrays', ko.utils.compareArrays);
(function () {
    // Objective:
    // * Given an input array, a container DOM node, and a function from array elements to arrays of DOM nodes,
    //   map the array elements to arrays of DOM nodes, concatenate together all these arrays, and use them to populate the container DOM node
    // * Next time we're given the same combination of things (with the array possibly having mutated), update the container DOM node
    //   so that its children is again the concatenation of the mappings of the array elements, but don't re-map any array elements that we
    //   previously mapped - retain those nodes, and just insert/delete other ones

    // "callbackAfterAddingNodes" will be invoked after any "mapping"-generated nodes are inserted into the container node
    // You can use this, for example, to activate bindings on those nodes.

    function mapNodeAndRefreshWhenChanged(containerNode, mapping, valueToMap, callbackAfterAddingNodes, index) {
        // Map this array value inside a dependentObservable so we re-map when any dependency changes
        var mappedNodes = [];
        var dependentObservable = ko.dependentObservable(function() {
            var newMappedNodes = mapping(valueToMap, index, ko.utils.fixUpContinuousNodeArray(mappedNodes, containerNode)) || [];

            // On subsequent evaluations, just replace the previously-inserted DOM nodes
            if (mappedNodes.length > 0) {
                ko.utils.replaceDomNodes(mappedNodes, newMappedNodes);
                if (callbackAfterAddingNodes)
                    ko.dependencyDetection.ignore(callbackAfterAddingNodes, null, [valueToMap, newMappedNodes, index]);
            }

            // Replace the contents of the mappedNodes array, thereby updating the record
            // of which nodes would be deleted if valueToMap was itself later removed
            mappedNodes.length = 0;
            ko.utils.arrayPushAll(mappedNodes, newMappedNodes);
        }, null, { disposeWhenNodeIsRemoved: containerNode, disposeWhen: function() { return !ko.utils.anyDomNodeIsAttachedToDocument(mappedNodes); } });
        return { mappedNodes : mappedNodes, dependentObservable : (dependentObservable.isActive() ? dependentObservable : undefined) };
    }

    var lastMappingResultDomDataKey = ko.utils.domData.nextKey();

    ko.utils.setDomNodeChildrenFromArrayMapping = function (domNode, array, mapping, options, callbackAfterAddingNodes) {
        // Compare the provided array against the previous one
        array = array || [];
        options = options || {};
        var isFirstExecution = ko.utils.domData.get(domNode, lastMappingResultDomDataKey) === undefined;
        var lastMappingResult = ko.utils.domData.get(domNode, lastMappingResultDomDataKey) || [];
        var lastArray = ko.utils.arrayMap(lastMappingResult, function (x) { return x.arrayEntry; });
        var editScript = ko.utils.compareArrays(lastArray, array, options['dontLimitMoves']);

        // Build the new mapping result
        var newMappingResult = [];
        var lastMappingResultIndex = 0;
        var newMappingResultIndex = 0;

        var nodesToDelete = [];
        var itemsToProcess = [];
        var itemsForBeforeRemoveCallbacks = [];
        var itemsForMoveCallbacks = [];
        var itemsForAfterAddCallbacks = [];
        var mapData;

        function itemMovedOrRetained(editScriptIndex, oldPosition) {
            mapData = lastMappingResult[oldPosition];
            if (newMappingResultIndex !== oldPosition)
                itemsForMoveCallbacks[editScriptIndex] = mapData;
            // Since updating the index might change the nodes, do so before calling fixUpContinuousNodeArray
            mapData.indexObservable(newMappingResultIndex++);
            ko.utils.fixUpContinuousNodeArray(mapData.mappedNodes, domNode);
            newMappingResult.push(mapData);
            itemsToProcess.push(mapData);
        }

        function callCallback(callback, items) {
            if (callback) {
                for (var i = 0, n = items.length; i < n; i++) {
                    if (items[i]) {
                        ko.utils.arrayForEach(items[i].mappedNodes, function(node) {
                            callback(node, i, items[i].arrayEntry);
                        });
                    }
                }
            }
        }

        for (var i = 0, editScriptItem, movedIndex; editScriptItem = editScript[i]; i++) {
            movedIndex = editScriptItem['moved'];
            switch (editScriptItem['status']) {
                case "deleted":
                    if (movedIndex === undefined) {
                        mapData = lastMappingResult[lastMappingResultIndex];

                        // Stop tracking changes to the mapping for these nodes
                        if (mapData.dependentObservable)
                            mapData.dependentObservable.dispose();

                        // Queue these nodes for later removal
                        nodesToDelete.push.apply(nodesToDelete, ko.utils.fixUpContinuousNodeArray(mapData.mappedNodes, domNode));
                        if (options['beforeRemove']) {
                            itemsForBeforeRemoveCallbacks[i] = mapData;
                            itemsToProcess.push(mapData);
                        }
                    }
                    lastMappingResultIndex++;
                    break;

                case "retained":
                    itemMovedOrRetained(i, lastMappingResultIndex++);
                    break;

                case "added":
                    if (movedIndex !== undefined) {
                        itemMovedOrRetained(i, movedIndex);
                    } else {
                        mapData = { arrayEntry: editScriptItem['value'], indexObservable: ko.observable(newMappingResultIndex++) };
                        newMappingResult.push(mapData);
                        itemsToProcess.push(mapData);
                        if (!isFirstExecution)
                            itemsForAfterAddCallbacks[i] = mapData;
                    }
                    break;
            }
        }

        // Call beforeMove first before any changes have been made to the DOM
        callCallback(options['beforeMove'], itemsForMoveCallbacks);

        // Next remove nodes for deleted items (or just clean if there's a beforeRemove callback)
        ko.utils.arrayForEach(nodesToDelete, options['beforeRemove'] ? ko.cleanNode : ko.removeNode);

        // Next add/reorder the remaining items (will include deleted items if there's a beforeRemove callback)
        for (var i = 0, nextNode = ko.virtualElements.firstChild(domNode), lastNode, node; mapData = itemsToProcess[i]; i++) {
            // Get nodes for newly added items
            if (!mapData.mappedNodes)
                ko.utils.extend(mapData, mapNodeAndRefreshWhenChanged(domNode, mapping, mapData.arrayEntry, callbackAfterAddingNodes, mapData.indexObservable));

            // Put nodes in the right place if they aren't there already
            for (var j = 0; node = mapData.mappedNodes[j]; nextNode = node.nextSibling, lastNode = node, j++) {
                if (node !== nextNode)
                    ko.virtualElements.insertAfter(domNode, node, lastNode);
            }

            // Run the callbacks for newly added nodes (for example, to apply bindings, etc.)
            if (!mapData.initialized && callbackAfterAddingNodes) {
                callbackAfterAddingNodes(mapData.arrayEntry, mapData.mappedNodes, mapData.indexObservable);
                mapData.initialized = true;
            }
        }

        // If there's a beforeRemove callback, call it after reordering.
        // Note that we assume that the beforeRemove callback will usually be used to remove the nodes using
        // some sort of animation, which is why we first reorder the nodes that will be removed. If the
        // callback instead removes the nodes right away, it would be more efficient to skip reordering them.
        // Perhaps we'll make that change in the future if this scenario becomes more common.
        callCallback(options['beforeRemove'], itemsForBeforeRemoveCallbacks);

        // Finally call afterMove and afterAdd callbacks
        callCallback(options['afterMove'], itemsForMoveCallbacks);
        callCallback(options['afterAdd'], itemsForAfterAddCallbacks);

        // Store a copy of the array items we just considered so we can difference it next time
        ko.utils.domData.set(domNode, lastMappingResultDomDataKey, newMappingResult);
    }
})();

ko.exportSymbol('utils.setDomNodeChildrenFromArrayMapping', ko.utils.setDomNodeChildrenFromArrayMapping);
ko.nativeTemplateEngine = function () {
    this['allowTemplateRewriting'] = false;
}

ko.nativeTemplateEngine.prototype = new ko.templateEngine();
ko.nativeTemplateEngine.prototype.constructor = ko.nativeTemplateEngine;
ko.nativeTemplateEngine.prototype['renderTemplateSource'] = function (templateSource, bindingContext, options) {
    var useNodesIfAvailable = !(ko.utils.ieVersion < 9), // IE<9 cloneNode doesn't work properly
        templateNodesFunc = useNodesIfAvailable ? templateSource['nodes'] : null,
        templateNodes = templateNodesFunc ? templateSource['nodes']() : null;

    if (templateNodes) {
        return ko.utils.makeArray(templateNodes.cloneNode(true).childNodes);
    } else {
        var templateText = templateSource['text']();
        return ko.utils.parseHtmlFragment(templateText);
    }
};

ko.nativeTemplateEngine.instance = new ko.nativeTemplateEngine();
ko.setTemplateEngine(ko.nativeTemplateEngine.instance);

ko.exportSymbol('nativeTemplateEngine', ko.nativeTemplateEngine);
(function() {
    ko.jqueryTmplTemplateEngine = function () {
        // Detect which version of jquery-tmpl you're using. Unfortunately jquery-tmpl
        // doesn't expose a version number, so we have to infer it.
        // Note that as of Knockout 1.3, we only support jQuery.tmpl 1.0.0pre and later,
        // which KO internally refers to as version "2", so older versions are no longer detected.
        var jQueryTmplVersion = this.jQueryTmplVersion = (function() {
            if (!jQueryInstance || !(jQueryInstance['tmpl']))
                return 0;
            // Since it exposes no official version number, we use our own numbering system. To be updated as jquery-tmpl evolves.
            try {
                if (jQueryInstance['tmpl']['tag']['tmpl']['open'].toString().indexOf('__') >= 0) {
                    // Since 1.0.0pre, custom tags should append markup to an array called "__"
                    return 2; // Final version of jquery.tmpl
                }
            } catch(ex) { /* Apparently not the version we were looking for */ }

            return 1; // Any older version that we don't support
        })();

        function ensureHasReferencedJQueryTemplates() {
            if (jQueryTmplVersion < 2)
                throw new Error("Your version of jQuery.tmpl is too old. Please upgrade to jQuery.tmpl 1.0.0pre or later.");
        }

        function executeTemplate(compiledTemplate, data, jQueryTemplateOptions) {
            return jQueryInstance['tmpl'](compiledTemplate, data, jQueryTemplateOptions);
        }

        this['renderTemplateSource'] = function(templateSource, bindingContext, options) {
            options = options || {};
            ensureHasReferencedJQueryTemplates();

            // Ensure we have stored a precompiled version of this template (don't want to reparse on every render)
            var precompiled = templateSource['data']('precompiled');
            if (!precompiled) {
                var templateText = templateSource['text']() || "";
                // Wrap in "with($whatever.koBindingContext) { ... }"
                templateText = "{{ko_with $item.koBindingContext}}" + templateText + "{{/ko_with}}";

                precompiled = jQueryInstance['template'](null, templateText);
                templateSource['data']('precompiled', precompiled);
            }

            var data = [bindingContext['$data']]; // Prewrap the data in an array to stop jquery.tmpl from trying to unwrap any arrays
            var jQueryTemplateOptions = jQueryInstance['extend']({ 'koBindingContext': bindingContext }, options['templateOptions']);

            var resultNodes = executeTemplate(precompiled, data, jQueryTemplateOptions);
            resultNodes['appendTo'](document.createElement("div")); // Using "appendTo" forces jQuery/jQuery.tmpl to perform necessary cleanup work

            jQueryInstance['fragments'] = {}; // Clear jQuery's fragment cache to avoid a memory leak after a large number of template renders
            return resultNodes;
        };

        this['createJavaScriptEvaluatorBlock'] = function(script) {
            return "{{ko_code ((function() { return " + script + " })()) }}";
        };

        this['addTemplate'] = function(templateName, templateMarkup) {
            document.write("<script type='text/html' id='" + templateName + "'>" + templateMarkup + "<" + "/script>");
        };

        if (jQueryTmplVersion > 0) {
            jQueryInstance['tmpl']['tag']['ko_code'] = {
                open: "__.push($1 || '');"
            };
            jQueryInstance['tmpl']['tag']['ko_with'] = {
                open: "with($1) {",
                close: "} "
            };
        }
    };

    ko.jqueryTmplTemplateEngine.prototype = new ko.templateEngine();
    ko.jqueryTmplTemplateEngine.prototype.constructor = ko.jqueryTmplTemplateEngine;

    // Use this one by default *only if jquery.tmpl is referenced*
    var jqueryTmplTemplateEngineInstance = new ko.jqueryTmplTemplateEngine();
    if (jqueryTmplTemplateEngineInstance.jQueryTmplVersion > 0)
        ko.setTemplateEngine(jqueryTmplTemplateEngineInstance);

    ko.exportSymbol('jqueryTmplTemplateEngine', ko.jqueryTmplTemplateEngine);
})();
}));
}());
})();

},{}],568:[function(require,module,exports){
var baseCreate = require('./_baseCreate'),
    baseLodash = require('./_baseLodash');

/** Used as references for the maximum length and index of an array. */
var MAX_ARRAY_LENGTH = 4294967295;

/**
 * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
 *
 * @private
 * @constructor
 * @param {*} value The value to wrap.
 */
function LazyWrapper(value) {
  this.__wrapped__ = value;
  this.__actions__ = [];
  this.__dir__ = 1;
  this.__filtered__ = false;
  this.__iteratees__ = [];
  this.__takeCount__ = MAX_ARRAY_LENGTH;
  this.__views__ = [];
}

// Ensure `LazyWrapper` is an instance of `baseLodash`.
LazyWrapper.prototype = baseCreate(baseLodash.prototype);
LazyWrapper.prototype.constructor = LazyWrapper;

module.exports = LazyWrapper;

},{"./_baseCreate":572,"./_baseLodash":574}],569:[function(require,module,exports){
var baseCreate = require('./_baseCreate'),
    baseLodash = require('./_baseLodash');

/**
 * The base constructor for creating `lodash` wrapper objects.
 *
 * @private
 * @param {*} value The value to wrap.
 * @param {boolean} [chainAll] Enable explicit method chain sequences.
 */
function LodashWrapper(value, chainAll) {
  this.__wrapped__ = value;
  this.__actions__ = [];
  this.__chain__ = !!chainAll;
  this.__index__ = 0;
  this.__values__ = undefined;
}

LodashWrapper.prototype = baseCreate(baseLodash.prototype);
LodashWrapper.prototype.constructor = LodashWrapper;

module.exports = LodashWrapper;

},{"./_baseCreate":572,"./_baseLodash":574}],570:[function(require,module,exports){
var getNative = require('./_getNative'),
    root = require('./_root');

/* Built-in method references that are verified to be native. */
var WeakMap = getNative(root, 'WeakMap');

module.exports = WeakMap;

},{"./_getNative":592,"./_root":603}],571:[function(require,module,exports){
/**
 * A faster alternative to `Function#apply`, this function invokes `func`
 * with the `this` binding of `thisArg` and the arguments of `args`.
 *
 * @private
 * @param {Function} func The function to invoke.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} args The arguments to invoke `func` with.
 * @returns {*} Returns the result of `func`.
 */
function apply(func, thisArg, args) {
  var length = args.length;
  switch (length) {
    case 0: return func.call(thisArg);
    case 1: return func.call(thisArg, args[0]);
    case 2: return func.call(thisArg, args[0], args[1]);
    case 3: return func.call(thisArg, args[0], args[1], args[2]);
  }
  return func.apply(thisArg, args);
}

module.exports = apply;

},{}],572:[function(require,module,exports){
var isObject = require('./isObject');

/** Built-in value references. */
var objectCreate = Object.create;

/**
 * The base implementation of `_.create` without support for assigning
 * properties to the created object.
 *
 * @private
 * @param {Object} prototype The object to inherit from.
 * @returns {Object} Returns the new object.
 */
function baseCreate(proto) {
  return isObject(proto) ? objectCreate(proto) : {};
}

module.exports = baseCreate;

},{"./isObject":613}],573:[function(require,module,exports){
var isFunction = require('./isFunction'),
    isHostObject = require('./_isHostObject'),
    isMasked = require('./_isMasked'),
    isObject = require('./isObject'),
    toSource = require('./_toSource');

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/6.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = Function.prototype.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = (isFunction(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

module.exports = baseIsNative;

},{"./_isHostObject":594,"./_isMasked":597,"./_toSource":605,"./isFunction":612,"./isObject":613}],574:[function(require,module,exports){
/**
 * The function whose prototype chain sequence wrappers inherit from.
 *
 * @private
 */
function baseLodash() {
  // No operation performed.
}

module.exports = baseLodash;

},{}],575:[function(require,module,exports){
var identity = require('./identity'),
    metaMap = require('./_metaMap');

/**
 * The base implementation of `setData` without support for hot loop detection.
 *
 * @private
 * @param {Function} func The function to associate metadata with.
 * @param {*} data The metadata.
 * @returns {Function} Returns `func`.
 */
var baseSetData = !metaMap ? identity : function(func, data) {
  metaMap.set(func, data);
  return func;
};

module.exports = baseSetData;

},{"./_metaMap":599,"./identity":610}],576:[function(require,module,exports){
/**
 * Checks if `value` is a global object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {null|Object} Returns `value` if it's a global object, else `null`.
 */
function checkGlobal(value) {
  return (value && value.Object === Object) ? value : null;
}

module.exports = checkGlobal;

},{}],577:[function(require,module,exports){
/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * Creates an array that is the composition of partially applied arguments,
 * placeholders, and provided arguments into a single array of arguments.
 *
 * @private
 * @param {Array} args The provided arguments.
 * @param {Array} partials The arguments to prepend to those provided.
 * @param {Array} holders The `partials` placeholder indexes.
 * @params {boolean} [isCurried] Specify composing for a curried function.
 * @returns {Array} Returns the new array of composed arguments.
 */
function composeArgs(args, partials, holders, isCurried) {
  var argsIndex = -1,
      argsLength = args.length,
      holdersLength = holders.length,
      leftIndex = -1,
      leftLength = partials.length,
      rangeLength = nativeMax(argsLength - holdersLength, 0),
      result = Array(leftLength + rangeLength),
      isUncurried = !isCurried;

  while (++leftIndex < leftLength) {
    result[leftIndex] = partials[leftIndex];
  }
  while (++argsIndex < holdersLength) {
    if (isUncurried || argsIndex < argsLength) {
      result[holders[argsIndex]] = args[argsIndex];
    }
  }
  while (rangeLength--) {
    result[leftIndex++] = args[argsIndex++];
  }
  return result;
}

module.exports = composeArgs;

},{}],578:[function(require,module,exports){
/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * This function is like `composeArgs` except that the arguments composition
 * is tailored for `_.partialRight`.
 *
 * @private
 * @param {Array} args The provided arguments.
 * @param {Array} partials The arguments to append to those provided.
 * @param {Array} holders The `partials` placeholder indexes.
 * @params {boolean} [isCurried] Specify composing for a curried function.
 * @returns {Array} Returns the new array of composed arguments.
 */
function composeArgsRight(args, partials, holders, isCurried) {
  var argsIndex = -1,
      argsLength = args.length,
      holdersIndex = -1,
      holdersLength = holders.length,
      rightIndex = -1,
      rightLength = partials.length,
      rangeLength = nativeMax(argsLength - holdersLength, 0),
      result = Array(rangeLength + rightLength),
      isUncurried = !isCurried;

  while (++argsIndex < rangeLength) {
    result[argsIndex] = args[argsIndex];
  }
  var offset = argsIndex;
  while (++rightIndex < rightLength) {
    result[offset + rightIndex] = partials[rightIndex];
  }
  while (++holdersIndex < holdersLength) {
    if (isUncurried || argsIndex < argsLength) {
      result[offset + holders[holdersIndex]] = args[argsIndex++];
    }
  }
  return result;
}

module.exports = composeArgsRight;

},{}],579:[function(require,module,exports){
/**
 * Copies the values of `source` to `array`.
 *
 * @private
 * @param {Array} source The array to copy values from.
 * @param {Array} [array=[]] The array to copy values to.
 * @returns {Array} Returns `array`.
 */
function copyArray(source, array) {
  var index = -1,
      length = source.length;

  array || (array = Array(length));
  while (++index < length) {
    array[index] = source[index];
  }
  return array;
}

module.exports = copyArray;

},{}],580:[function(require,module,exports){
var root = require('./_root');

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

module.exports = coreJsData;

},{"./_root":603}],581:[function(require,module,exports){
/**
 * Gets the number of `placeholder` occurrences in `array`.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} placeholder The placeholder to search for.
 * @returns {number} Returns the placeholder count.
 */
function countHolders(array, placeholder) {
  var length = array.length,
      result = 0;

  while (length--) {
    if (array[length] === placeholder) {
      result++;
    }
  }
  return result;
}

module.exports = countHolders;

},{}],582:[function(require,module,exports){
var createCtorWrapper = require('./_createCtorWrapper'),
    root = require('./_root');

/** Used to compose bitmasks for wrapper metadata. */
var BIND_FLAG = 1;

/**
 * Creates a function that wraps `func` to invoke it with the optional `this`
 * binding of `thisArg`.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {number} bitmask The bitmask of wrapper flags. See `createWrapper`
 *  for more details.
 * @param {*} [thisArg] The `this` binding of `func`.
 * @returns {Function} Returns the new wrapped function.
 */
function createBaseWrapper(func, bitmask, thisArg) {
  var isBind = bitmask & BIND_FLAG,
      Ctor = createCtorWrapper(func);

  function wrapper() {
    var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
    return fn.apply(isBind ? thisArg : this, arguments);
  }
  return wrapper;
}

module.exports = createBaseWrapper;

},{"./_createCtorWrapper":583,"./_root":603}],583:[function(require,module,exports){
var baseCreate = require('./_baseCreate'),
    isObject = require('./isObject');

/**
 * Creates a function that produces an instance of `Ctor` regardless of
 * whether it was invoked as part of a `new` expression or by `call` or `apply`.
 *
 * @private
 * @param {Function} Ctor The constructor to wrap.
 * @returns {Function} Returns the new wrapped function.
 */
function createCtorWrapper(Ctor) {
  return function() {
    // Use a `switch` statement to work with class constructors. See
    // http://ecma-international.org/ecma-262/6.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
    // for more details.
    var args = arguments;
    switch (args.length) {
      case 0: return new Ctor;
      case 1: return new Ctor(args[0]);
      case 2: return new Ctor(args[0], args[1]);
      case 3: return new Ctor(args[0], args[1], args[2]);
      case 4: return new Ctor(args[0], args[1], args[2], args[3]);
      case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
      case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
      case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
    }
    var thisBinding = baseCreate(Ctor.prototype),
        result = Ctor.apply(thisBinding, args);

    // Mimic the constructor's `return` behavior.
    // See https://es5.github.io/#x13.2.2 for more details.
    return isObject(result) ? result : thisBinding;
  };
}

module.exports = createCtorWrapper;

},{"./_baseCreate":572,"./isObject":613}],584:[function(require,module,exports){
var apply = require('./_apply'),
    createCtorWrapper = require('./_createCtorWrapper'),
    createHybridWrapper = require('./_createHybridWrapper'),
    createRecurryWrapper = require('./_createRecurryWrapper'),
    getHolder = require('./_getHolder'),
    replaceHolders = require('./_replaceHolders'),
    root = require('./_root');

/**
 * Creates a function that wraps `func` to enable currying.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {number} bitmask The bitmask of wrapper flags. See `createWrapper`
 *  for more details.
 * @param {number} arity The arity of `func`.
 * @returns {Function} Returns the new wrapped function.
 */
function createCurryWrapper(func, bitmask, arity) {
  var Ctor = createCtorWrapper(func);

  function wrapper() {
    var length = arguments.length,
        args = Array(length),
        index = length,
        placeholder = getHolder(wrapper);

    while (index--) {
      args[index] = arguments[index];
    }
    var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)
      ? []
      : replaceHolders(args, placeholder);

    length -= holders.length;
    if (length < arity) {
      return createRecurryWrapper(
        func, bitmask, createHybridWrapper, wrapper.placeholder, undefined,
        args, holders, undefined, undefined, arity - length);
    }
    var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
    return apply(fn, this, args);
  }
  return wrapper;
}

module.exports = createCurryWrapper;

},{"./_apply":571,"./_createCtorWrapper":583,"./_createHybridWrapper":585,"./_createRecurryWrapper":587,"./_getHolder":591,"./_replaceHolders":602,"./_root":603}],585:[function(require,module,exports){
var composeArgs = require('./_composeArgs'),
    composeArgsRight = require('./_composeArgsRight'),
    countHolders = require('./_countHolders'),
    createCtorWrapper = require('./_createCtorWrapper'),
    createRecurryWrapper = require('./_createRecurryWrapper'),
    getHolder = require('./_getHolder'),
    reorder = require('./_reorder'),
    replaceHolders = require('./_replaceHolders'),
    root = require('./_root');

/** Used to compose bitmasks for wrapper metadata. */
var BIND_FLAG = 1,
    BIND_KEY_FLAG = 2,
    CURRY_FLAG = 8,
    CURRY_RIGHT_FLAG = 16,
    ARY_FLAG = 128,
    FLIP_FLAG = 512;

/**
 * Creates a function that wraps `func` to invoke it with optional `this`
 * binding of `thisArg`, partial application, and currying.
 *
 * @private
 * @param {Function|string} func The function or method name to wrap.
 * @param {number} bitmask The bitmask of wrapper flags. See `createWrapper`
 *  for more details.
 * @param {*} [thisArg] The `this` binding of `func`.
 * @param {Array} [partials] The arguments to prepend to those provided to
 *  the new function.
 * @param {Array} [holders] The `partials` placeholder indexes.
 * @param {Array} [partialsRight] The arguments to append to those provided
 *  to the new function.
 * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
 * @param {Array} [argPos] The argument positions of the new function.
 * @param {number} [ary] The arity cap of `func`.
 * @param {number} [arity] The arity of `func`.
 * @returns {Function} Returns the new wrapped function.
 */
function createHybridWrapper(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
  var isAry = bitmask & ARY_FLAG,
      isBind = bitmask & BIND_FLAG,
      isBindKey = bitmask & BIND_KEY_FLAG,
      isCurried = bitmask & (CURRY_FLAG | CURRY_RIGHT_FLAG),
      isFlip = bitmask & FLIP_FLAG,
      Ctor = isBindKey ? undefined : createCtorWrapper(func);

  function wrapper() {
    var length = arguments.length,
        args = Array(length),
        index = length;

    while (index--) {
      args[index] = arguments[index];
    }
    if (isCurried) {
      var placeholder = getHolder(wrapper),
          holdersCount = countHolders(args, placeholder);
    }
    if (partials) {
      args = composeArgs(args, partials, holders, isCurried);
    }
    if (partialsRight) {
      args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
    }
    length -= holdersCount;
    if (isCurried && length < arity) {
      var newHolders = replaceHolders(args, placeholder);
      return createRecurryWrapper(
        func, bitmask, createHybridWrapper, wrapper.placeholder, thisArg,
        args, newHolders, argPos, ary, arity - length
      );
    }
    var thisBinding = isBind ? thisArg : this,
        fn = isBindKey ? thisBinding[func] : func;

    length = args.length;
    if (argPos) {
      args = reorder(args, argPos);
    } else if (isFlip && length > 1) {
      args.reverse();
    }
    if (isAry && ary < length) {
      args.length = ary;
    }
    if (this && this !== root && this instanceof wrapper) {
      fn = Ctor || createCtorWrapper(fn);
    }
    return fn.apply(thisBinding, args);
  }
  return wrapper;
}

module.exports = createHybridWrapper;

},{"./_composeArgs":577,"./_composeArgsRight":578,"./_countHolders":581,"./_createCtorWrapper":583,"./_createRecurryWrapper":587,"./_getHolder":591,"./_reorder":601,"./_replaceHolders":602,"./_root":603}],586:[function(require,module,exports){
var apply = require('./_apply'),
    createCtorWrapper = require('./_createCtorWrapper'),
    root = require('./_root');

/** Used to compose bitmasks for wrapper metadata. */
var BIND_FLAG = 1;

/**
 * Creates a function that wraps `func` to invoke it with the `this` binding
 * of `thisArg` and `partials` prepended to the arguments it receives.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {number} bitmask The bitmask of wrapper flags. See `createWrapper`
 *  for more details.
 * @param {*} thisArg The `this` binding of `func`.
 * @param {Array} partials The arguments to prepend to those provided to
 *  the new function.
 * @returns {Function} Returns the new wrapped function.
 */
function createPartialWrapper(func, bitmask, thisArg, partials) {
  var isBind = bitmask & BIND_FLAG,
      Ctor = createCtorWrapper(func);

  function wrapper() {
    var argsIndex = -1,
        argsLength = arguments.length,
        leftIndex = -1,
        leftLength = partials.length,
        args = Array(leftLength + argsLength),
        fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;

    while (++leftIndex < leftLength) {
      args[leftIndex] = partials[leftIndex];
    }
    while (argsLength--) {
      args[leftIndex++] = arguments[++argsIndex];
    }
    return apply(fn, isBind ? thisArg : this, args);
  }
  return wrapper;
}

module.exports = createPartialWrapper;

},{"./_apply":571,"./_createCtorWrapper":583,"./_root":603}],587:[function(require,module,exports){
var isLaziable = require('./_isLaziable'),
    setData = require('./_setData');

/** Used to compose bitmasks for wrapper metadata. */
var BIND_FLAG = 1,
    BIND_KEY_FLAG = 2,
    CURRY_BOUND_FLAG = 4,
    CURRY_FLAG = 8,
    PARTIAL_FLAG = 32,
    PARTIAL_RIGHT_FLAG = 64;

/**
 * Creates a function that wraps `func` to continue currying.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {number} bitmask The bitmask of wrapper flags. See `createWrapper`
 *  for more details.
 * @param {Function} wrapFunc The function to create the `func` wrapper.
 * @param {*} placeholder The placeholder value.
 * @param {*} [thisArg] The `this` binding of `func`.
 * @param {Array} [partials] The arguments to prepend to those provided to
 *  the new function.
 * @param {Array} [holders] The `partials` placeholder indexes.
 * @param {Array} [argPos] The argument positions of the new function.
 * @param {number} [ary] The arity cap of `func`.
 * @param {number} [arity] The arity of `func`.
 * @returns {Function} Returns the new wrapped function.
 */
function createRecurryWrapper(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
  var isCurry = bitmask & CURRY_FLAG,
      newHolders = isCurry ? holders : undefined,
      newHoldersRight = isCurry ? undefined : holders,
      newPartials = isCurry ? partials : undefined,
      newPartialsRight = isCurry ? undefined : partials;

  bitmask |= (isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG);
  bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG);

  if (!(bitmask & CURRY_BOUND_FLAG)) {
    bitmask &= ~(BIND_FLAG | BIND_KEY_FLAG);
  }
  var newData = [
    func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,
    newHoldersRight, argPos, ary, arity
  ];

  var result = wrapFunc.apply(undefined, newData);
  if (isLaziable(func)) {
    setData(result, newData);
  }
  result.placeholder = placeholder;
  return result;
}

module.exports = createRecurryWrapper;

},{"./_isLaziable":596,"./_setData":604}],588:[function(require,module,exports){
var baseSetData = require('./_baseSetData'),
    createBaseWrapper = require('./_createBaseWrapper'),
    createCurryWrapper = require('./_createCurryWrapper'),
    createHybridWrapper = require('./_createHybridWrapper'),
    createPartialWrapper = require('./_createPartialWrapper'),
    getData = require('./_getData'),
    mergeData = require('./_mergeData'),
    setData = require('./_setData'),
    toInteger = require('./toInteger');

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/** Used to compose bitmasks for wrapper metadata. */
var BIND_FLAG = 1,
    BIND_KEY_FLAG = 2,
    CURRY_FLAG = 8,
    CURRY_RIGHT_FLAG = 16,
    PARTIAL_FLAG = 32,
    PARTIAL_RIGHT_FLAG = 64;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max;

/**
 * Creates a function that either curries or invokes `func` with optional
 * `this` binding and partially applied arguments.
 *
 * @private
 * @param {Function|string} func The function or method name to wrap.
 * @param {number} bitmask The bitmask of wrapper flags.
 *  The bitmask may be composed of the following flags:
 *     1 - `_.bind`
 *     2 - `_.bindKey`
 *     4 - `_.curry` or `_.curryRight` of a bound function
 *     8 - `_.curry`
 *    16 - `_.curryRight`
 *    32 - `_.partial`
 *    64 - `_.partialRight`
 *   128 - `_.rearg`
 *   256 - `_.ary`
 *   512 - `_.flip`
 * @param {*} [thisArg] The `this` binding of `func`.
 * @param {Array} [partials] The arguments to be partially applied.
 * @param {Array} [holders] The `partials` placeholder indexes.
 * @param {Array} [argPos] The argument positions of the new function.
 * @param {number} [ary] The arity cap of `func`.
 * @param {number} [arity] The arity of `func`.
 * @returns {Function} Returns the new wrapped function.
 */
function createWrapper(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
  var isBindKey = bitmask & BIND_KEY_FLAG;
  if (!isBindKey && typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  var length = partials ? partials.length : 0;
  if (!length) {
    bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG);
    partials = holders = undefined;
  }
  ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);
  arity = arity === undefined ? arity : toInteger(arity);
  length -= holders ? holders.length : 0;

  if (bitmask & PARTIAL_RIGHT_FLAG) {
    var partialsRight = partials,
        holdersRight = holders;

    partials = holders = undefined;
  }
  var data = isBindKey ? undefined : getData(func);

  var newData = [
    func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,
    argPos, ary, arity
  ];

  if (data) {
    mergeData(newData, data);
  }
  func = newData[0];
  bitmask = newData[1];
  thisArg = newData[2];
  partials = newData[3];
  holders = newData[4];
  arity = newData[9] = newData[9] == null
    ? (isBindKey ? 0 : func.length)
    : nativeMax(newData[9] - length, 0);

  if (!arity && bitmask & (CURRY_FLAG | CURRY_RIGHT_FLAG)) {
    bitmask &= ~(CURRY_FLAG | CURRY_RIGHT_FLAG);
  }
  if (!bitmask || bitmask == BIND_FLAG) {
    var result = createBaseWrapper(func, bitmask, thisArg);
  } else if (bitmask == CURRY_FLAG || bitmask == CURRY_RIGHT_FLAG) {
    result = createCurryWrapper(func, bitmask, arity);
  } else if ((bitmask == PARTIAL_FLAG || bitmask == (BIND_FLAG | PARTIAL_FLAG)) && !holders.length) {
    result = createPartialWrapper(func, bitmask, thisArg, partials);
  } else {
    result = createHybridWrapper.apply(undefined, newData);
  }
  var setter = data ? baseSetData : setData;
  return setter(result, newData);
}

module.exports = createWrapper;

},{"./_baseSetData":575,"./_createBaseWrapper":582,"./_createCurryWrapper":584,"./_createHybridWrapper":585,"./_createPartialWrapper":586,"./_getData":589,"./_mergeData":598,"./_setData":604,"./toInteger":621}],589:[function(require,module,exports){
var metaMap = require('./_metaMap'),
    noop = require('./noop');

/**
 * Gets metadata for `func`.
 *
 * @private
 * @param {Function} func The function to query.
 * @returns {*} Returns the metadata for `func`.
 */
var getData = !metaMap ? noop : function(func) {
  return metaMap.get(func);
};

module.exports = getData;

},{"./_metaMap":599,"./noop":616}],590:[function(require,module,exports){
var realNames = require('./_realNames');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Gets the name of `func`.
 *
 * @private
 * @param {Function} func The function to query.
 * @returns {string} Returns the function name.
 */
function getFuncName(func) {
  var result = (func.name + ''),
      array = realNames[result],
      length = hasOwnProperty.call(realNames, result) ? array.length : 0;

  while (length--) {
    var data = array[length],
        otherFunc = data.func;
    if (otherFunc == null || otherFunc == func) {
      return data.name;
    }
  }
  return result;
}

module.exports = getFuncName;

},{"./_realNames":600}],591:[function(require,module,exports){
/**
 * Gets the argument placeholder value for `func`.
 *
 * @private
 * @param {Function} func The function to inspect.
 * @returns {*} Returns the placeholder value.
 */
function getHolder(func) {
  var object = func;
  return object.placeholder;
}

module.exports = getHolder;

},{}],592:[function(require,module,exports){
var baseIsNative = require('./_baseIsNative'),
    getValue = require('./_getValue');

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

module.exports = getNative;

},{"./_baseIsNative":573,"./_getValue":593}],593:[function(require,module,exports){
/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

module.exports = getValue;

},{}],594:[function(require,module,exports){
/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */
function isHostObject(value) {
  // Many host objects are `Object` objects that can coerce to strings
  // despite having improperly defined `toString` methods.
  var result = false;
  if (value != null && typeof value.toString != 'function') {
    try {
      result = !!(value + '');
    } catch (e) {}
  }
  return result;
}

module.exports = isHostObject;

},{}],595:[function(require,module,exports){
/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  length = length == null ? MAX_SAFE_INTEGER : length;
  return !!length &&
    (typeof value == 'number' || reIsUint.test(value)) &&
    (value > -1 && value % 1 == 0 && value < length);
}

module.exports = isIndex;

},{}],596:[function(require,module,exports){
var LazyWrapper = require('./_LazyWrapper'),
    getData = require('./_getData'),
    getFuncName = require('./_getFuncName'),
    lodash = require('./wrapperLodash');

/**
 * Checks if `func` has a lazy counterpart.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
 *  else `false`.
 */
function isLaziable(func) {
  var funcName = getFuncName(func),
      other = lodash[funcName];

  if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {
    return false;
  }
  if (func === other) {
    return true;
  }
  var data = getData(other);
  return !!data && func === data[0];
}

module.exports = isLaziable;

},{"./_LazyWrapper":568,"./_getData":589,"./_getFuncName":590,"./wrapperLodash":623}],597:[function(require,module,exports){
var coreJsData = require('./_coreJsData');

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

module.exports = isMasked;

},{"./_coreJsData":580}],598:[function(require,module,exports){
var composeArgs = require('./_composeArgs'),
    composeArgsRight = require('./_composeArgsRight'),
    replaceHolders = require('./_replaceHolders');

/** Used as the internal argument placeholder. */
var PLACEHOLDER = '__lodash_placeholder__';

/** Used to compose bitmasks for wrapper metadata. */
var BIND_FLAG = 1,
    BIND_KEY_FLAG = 2,
    CURRY_BOUND_FLAG = 4,
    CURRY_FLAG = 8,
    ARY_FLAG = 128,
    REARG_FLAG = 256;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMin = Math.min;

/**
 * Merges the function metadata of `source` into `data`.
 *
 * Merging metadata reduces the number of wrappers used to invoke a function.
 * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
 * may be applied regardless of execution order. Methods like `_.ary` and
 * `_.rearg` modify function arguments, making the order in which they are
 * executed important, preventing the merging of metadata. However, we make
 * an exception for a safe combined case where curried functions have `_.ary`
 * and or `_.rearg` applied.
 *
 * @private
 * @param {Array} data The destination metadata.
 * @param {Array} source The source metadata.
 * @returns {Array} Returns `data`.
 */
function mergeData(data, source) {
  var bitmask = data[1],
      srcBitmask = source[1],
      newBitmask = bitmask | srcBitmask,
      isCommon = newBitmask < (BIND_FLAG | BIND_KEY_FLAG | ARY_FLAG);

  var isCombo =
    ((srcBitmask == ARY_FLAG) && (bitmask == CURRY_FLAG)) ||
    ((srcBitmask == ARY_FLAG) && (bitmask == REARG_FLAG) && (data[7].length <= source[8])) ||
    ((srcBitmask == (ARY_FLAG | REARG_FLAG)) && (source[7].length <= source[8]) && (bitmask == CURRY_FLAG));

  // Exit early if metadata can't be merged.
  if (!(isCommon || isCombo)) {
    return data;
  }
  // Use source `thisArg` if available.
  if (srcBitmask & BIND_FLAG) {
    data[2] = source[2];
    // Set when currying a bound function.
    newBitmask |= bitmask & BIND_FLAG ? 0 : CURRY_BOUND_FLAG;
  }
  // Compose partial arguments.
  var value = source[3];
  if (value) {
    var partials = data[3];
    data[3] = partials ? composeArgs(partials, value, source[4]) : value;
    data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
  }
  // Compose partial right arguments.
  value = source[5];
  if (value) {
    partials = data[5];
    data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
    data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
  }
  // Use source `argPos` if available.
  value = source[7];
  if (value) {
    data[7] = value;
  }
  // Use source `ary` if it's smaller.
  if (srcBitmask & ARY_FLAG) {
    data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
  }
  // Use source `arity` if one is not provided.
  if (data[9] == null) {
    data[9] = source[9];
  }
  // Use source `func` and merge bitmasks.
  data[0] = source[0];
  data[1] = newBitmask;

  return data;
}

module.exports = mergeData;

},{"./_composeArgs":577,"./_composeArgsRight":578,"./_replaceHolders":602}],599:[function(require,module,exports){
var WeakMap = require('./_WeakMap');

/** Used to store function metadata. */
var metaMap = WeakMap && new WeakMap;

module.exports = metaMap;

},{"./_WeakMap":570}],600:[function(require,module,exports){
/** Used to lookup unminified function names. */
var realNames = {};

module.exports = realNames;

},{}],601:[function(require,module,exports){
var copyArray = require('./_copyArray'),
    isIndex = require('./_isIndex');

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMin = Math.min;

/**
 * Reorder `array` according to the specified indexes where the element at
 * the first index is assigned as the first element, the element at
 * the second index is assigned as the second element, and so on.
 *
 * @private
 * @param {Array} array The array to reorder.
 * @param {Array} indexes The arranged array indexes.
 * @returns {Array} Returns `array`.
 */
function reorder(array, indexes) {
  var arrLength = array.length,
      length = nativeMin(indexes.length, arrLength),
      oldArray = copyArray(array);

  while (length--) {
    var index = indexes[length];
    array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
  }
  return array;
}

module.exports = reorder;

},{"./_copyArray":579,"./_isIndex":595}],602:[function(require,module,exports){
/** Used as the internal argument placeholder. */
var PLACEHOLDER = '__lodash_placeholder__';

/**
 * Replaces all `placeholder` elements in `array` with an internal placeholder
 * and returns an array of their indexes.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {*} placeholder The placeholder to replace.
 * @returns {Array} Returns the new array of placeholder indexes.
 */
function replaceHolders(array, placeholder) {
  var index = -1,
      length = array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (value === placeholder || value === PLACEHOLDER) {
      array[index] = PLACEHOLDER;
      result[resIndex++] = index;
    }
  }
  return result;
}

module.exports = replaceHolders;

},{}],603:[function(require,module,exports){
(function (global){
var checkGlobal = require('./_checkGlobal');

/** Detect free variable `global` from Node.js. */
var freeGlobal = checkGlobal(typeof global == 'object' && global);

/** Detect free variable `self`. */
var freeSelf = checkGlobal(typeof self == 'object' && self);

/** Detect `this` as the global object. */
var thisGlobal = checkGlobal(typeof this == 'object' && this);

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || thisGlobal || Function('return this')();

module.exports = root;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./_checkGlobal":576}],604:[function(require,module,exports){
var baseSetData = require('./_baseSetData'),
    now = require('./now');

/** Used to detect hot functions by number of calls within a span of milliseconds. */
var HOT_COUNT = 150,
    HOT_SPAN = 16;

/**
 * Sets metadata for `func`.
 *
 * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
 * period of time, it will trip its breaker and transition to an identity
 * function to avoid garbage collection pauses in V8. See
 * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
 * for more details.
 *
 * @private
 * @param {Function} func The function to associate metadata with.
 * @param {*} data The metadata.
 * @returns {Function} Returns `func`.
 */
var setData = (function() {
  var count = 0,
      lastCalled = 0;

  return function(key, value) {
    var stamp = now(),
        remaining = HOT_SPAN - (stamp - lastCalled);

    lastCalled = stamp;
    if (remaining > 0) {
      if (++count >= HOT_COUNT) {
        return key;
      }
    } else {
      count = 0;
    }
    return baseSetData(key, value);
  };
}());

module.exports = setData;

},{"./_baseSetData":575,"./now":617}],605:[function(require,module,exports){
/** Used to resolve the decompiled source of functions. */
var funcToString = Function.prototype.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to process.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

module.exports = toSource;

},{}],606:[function(require,module,exports){
var LazyWrapper = require('./_LazyWrapper'),
    LodashWrapper = require('./_LodashWrapper'),
    copyArray = require('./_copyArray');

/**
 * Creates a clone of `wrapper`.
 *
 * @private
 * @param {Object} wrapper The wrapper to clone.
 * @returns {Object} Returns the cloned wrapper.
 */
function wrapperClone(wrapper) {
  if (wrapper instanceof LazyWrapper) {
    return wrapper.clone();
  }
  var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
  result.__actions__ = copyArray(wrapper.__actions__);
  result.__index__  = wrapper.__index__;
  result.__values__ = wrapper.__values__;
  return result;
}

module.exports = wrapperClone;

},{"./_LazyWrapper":568,"./_LodashWrapper":569,"./_copyArray":579}],607:[function(require,module,exports){
var toInteger = require('./toInteger');

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a function that invokes `func`, with the `this` binding and arguments
 * of the created function, while it's called less than `n` times. Subsequent
 * calls to the created function return the result of the last `func` invocation.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Function
 * @param {number} n The number of calls at which `func` is no longer invoked.
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new restricted function.
 * @example
 *
 * jQuery(element).on('click', _.before(5, addContactToList));
 * // => allows adding up to 4 contacts to the list
 */
function before(n, func) {
  var result;
  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  n = toInteger(n);
  return function() {
    if (--n > 0) {
      result = func.apply(this, arguments);
    }
    if (n <= 1) {
      func = undefined;
    }
    return result;
  };
}

module.exports = before;

},{"./toInteger":621}],608:[function(require,module,exports){
var createWrapper = require('./_createWrapper');

/** Used to compose bitmasks for wrapper metadata. */
var CURRY_FLAG = 8;

/**
 * Creates a function that accepts arguments of `func` and either invokes
 * `func` returning its result, if at least `arity` number of arguments have
 * been provided, or returns a function that accepts the remaining `func`
 * arguments, and so on. The arity of `func` may be specified if `func.length`
 * is not sufficient.
 *
 * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
 * may be used as a placeholder for provided arguments.
 *
 * **Note:** This method doesn't set the "length" property of curried functions.
 *
 * @static
 * @memberOf _
 * @since 2.0.0
 * @category Function
 * @param {Function} func The function to curry.
 * @param {number} [arity=func.length] The arity of `func`.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
 * @returns {Function} Returns the new curried function.
 * @example
 *
 * var abc = function(a, b, c) {
 *   return [a, b, c];
 * };
 *
 * var curried = _.curry(abc);
 *
 * curried(1)(2)(3);
 * // => [1, 2, 3]
 *
 * curried(1, 2)(3);
 * // => [1, 2, 3]
 *
 * curried(1, 2, 3);
 * // => [1, 2, 3]
 *
 * // Curried with placeholders.
 * curried(1)(_, 3)(2);
 * // => [1, 2, 3]
 */
function curry(func, arity, guard) {
  arity = guard ? undefined : arity;
  var result = createWrapper(func, CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
  result.placeholder = curry.placeholder;
  return result;
}

// Assign default placeholders.
curry.placeholder = {};

module.exports = curry;

},{"./_createWrapper":588}],609:[function(require,module,exports){
var isObject = require('./isObject'),
    now = require('./now'),
    toNumber = require('./toNumber');

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeMax = Math.max,
    nativeMin = Math.min;

/**
 * Creates a debounced function that delays invoking `func` until after `wait`
 * milliseconds have elapsed since the last time the debounced function was
 * invoked. The debounced function comes with a `cancel` method to cancel
 * delayed `func` invocations and a `flush` method to immediately invoke them.
 * Provide an options object to indicate whether `func` should be invoked on
 * the leading and/or trailing edge of the `wait` timeout. The `func` is invoked
 * with the last arguments provided to the debounced function. Subsequent calls
 * to the debounced function return the result of the last `func` invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is invoked
 * on the trailing edge of the timeout only if the debounced function is
 * invoked more than once during the `wait` timeout.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.debounce` and `_.throttle`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to debounce.
 * @param {number} [wait=0] The number of milliseconds to delay.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=false]
 *  Specify invoking on the leading edge of the timeout.
 * @param {number} [options.maxWait]
 *  The maximum time `func` is allowed to be delayed before it's invoked.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new debounced function.
 * @example
 *
 * // Avoid costly calculations while the window size is in flux.
 * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
 *
 * // Invoke `sendMail` when clicked, debouncing subsequent calls.
 * jQuery(element).on('click', _.debounce(sendMail, 300, {
 *   'leading': true,
 *   'trailing': false
 * }));
 *
 * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
 * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
 * var source = new EventSource('/stream');
 * jQuery(source).on('message', debounced);
 *
 * // Cancel the trailing debounced invocation.
 * jQuery(window).on('popstate', debounced.cancel);
 */
function debounce(func, wait, options) {
  var lastArgs,
      lastThis,
      maxWait,
      result,
      timerId,
      lastCallTime,
      lastInvokeTime = 0,
      leading = false,
      maxing = false,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  wait = toNumber(wait) || 0;
  if (isObject(options)) {
    leading = !!options.leading;
    maxing = 'maxWait' in options;
    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }

  function invokeFunc(time) {
    var args = lastArgs,
        thisArg = lastThis;

    lastArgs = lastThis = undefined;
    lastInvokeTime = time;
    result = func.apply(thisArg, args);
    return result;
  }

  function leadingEdge(time) {
    // Reset any `maxWait` timer.
    lastInvokeTime = time;
    // Start the timer for the trailing edge.
    timerId = setTimeout(timerExpired, wait);
    // Invoke the leading edge.
    return leading ? invokeFunc(time) : result;
  }

  function remainingWait(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime,
        result = wait - timeSinceLastCall;

    return maxing ? nativeMin(result, maxWait - timeSinceLastInvoke) : result;
  }

  function shouldInvoke(time) {
    var timeSinceLastCall = time - lastCallTime,
        timeSinceLastInvoke = time - lastInvokeTime;

    // Either this is the first call, activity has stopped and we're at the
    // trailing edge, the system time has gone backwards and we're treating
    // it as the trailing edge, or we've hit the `maxWait` limit.
    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
  }

  function timerExpired() {
    var time = now();
    if (shouldInvoke(time)) {
      return trailingEdge(time);
    }
    // Restart the timer.
    timerId = setTimeout(timerExpired, remainingWait(time));
  }

  function trailingEdge(time) {
    timerId = undefined;

    // Only invoke if we have `lastArgs` which means `func` has been
    // debounced at least once.
    if (trailing && lastArgs) {
      return invokeFunc(time);
    }
    lastArgs = lastThis = undefined;
    return result;
  }

  function cancel() {
    lastInvokeTime = 0;
    lastArgs = lastCallTime = lastThis = timerId = undefined;
  }

  function flush() {
    return timerId === undefined ? result : trailingEdge(now());
  }

  function debounced() {
    var time = now(),
        isInvoking = shouldInvoke(time);

    lastArgs = arguments;
    lastThis = this;
    lastCallTime = time;

    if (isInvoking) {
      if (timerId === undefined) {
        return leadingEdge(lastCallTime);
      }
      if (maxing) {
        // Handle invocations in a tight loop.
        timerId = setTimeout(timerExpired, wait);
        return invokeFunc(lastCallTime);
      }
    }
    if (timerId === undefined) {
      timerId = setTimeout(timerExpired, wait);
    }
    return result;
  }
  debounced.cancel = cancel;
  debounced.flush = flush;
  return debounced;
}

module.exports = debounce;

},{"./isObject":613,"./now":617,"./toNumber":622}],610:[function(require,module,exports){
/**
 * This method returns the first argument given to it.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Util
 * @param {*} value Any value.
 * @returns {*} Returns `value`.
 * @example
 *
 * var object = { 'user': 'fred' };
 *
 * console.log(_.identity(object) === object);
 * // => true
 */
function identity(value) {
  return value;
}

module.exports = identity;

},{}],611:[function(require,module,exports){
/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @type {Function}
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified,
 *  else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

module.exports = isArray;

},{}],612:[function(require,module,exports){
var isObject = require('./isObject');

/** `Object#toString` result references. */
var funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified,
 *  else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 8 which returns 'object' for typed array and weak map constructors,
  // and PhantomJS 1.9 which returns 'function' for `NodeList` instances.
  var tag = isObject(value) ? objectToString.call(value) : '';
  return tag == funcTag || tag == genTag;
}

module.exports = isFunction;

},{"./isObject":613}],613:[function(require,module,exports){
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/6.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return !!value && (type == 'object' || type == 'function');
}

module.exports = isObject;

},{}],614:[function(require,module,exports){
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return !!value && typeof value == 'object';
}

module.exports = isObjectLike;

},{}],615:[function(require,module,exports){
var isObjectLike = require('./isObjectLike');

/** `Object#toString` result references. */
var symbolTag = '[object Symbol]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */
var objectToString = objectProto.toString;

/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified,
 *  else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */
function isSymbol(value) {
  return typeof value == 'symbol' ||
    (isObjectLike(value) && objectToString.call(value) == symbolTag);
}

module.exports = isSymbol;

},{"./isObjectLike":614}],616:[function(require,module,exports){
/**
 * A method that returns `undefined`.
 *
 * @static
 * @memberOf _
 * @since 2.3.0
 * @category Util
 * @example
 *
 * _.times(2, _.noop);
 * // => [undefined, undefined]
 */
function noop() {
  // No operation performed.
}

module.exports = noop;

},{}],617:[function(require,module,exports){
/**
 * Gets the timestamp of the number of milliseconds that have elapsed since
 * the Unix epoch (1 January 1970 00:00:00 UTC).
 *
 * @static
 * @memberOf _
 * @since 2.4.0
 * @category Date
 * @returns {number} Returns the timestamp.
 * @example
 *
 * _.defer(function(stamp) {
 *   console.log(_.now() - stamp);
 * }, _.now());
 * // => Logs the number of milliseconds it took for the deferred invocation.
 */
function now() {
  return Date.now();
}

module.exports = now;

},{}],618:[function(require,module,exports){
var before = require('./before');

/**
 * Creates a function that is restricted to invoking `func` once. Repeat calls
 * to the function return the value of the first invocation. The `func` is
 * invoked with the `this` binding and arguments of the created function.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new restricted function.
 * @example
 *
 * var initialize = _.once(createApplication);
 * initialize();
 * initialize();
 * // `initialize` invokes `createApplication` once
 */
function once(func) {
  return before(2, func);
}

module.exports = once;

},{"./before":607}],619:[function(require,module,exports){
var debounce = require('./debounce'),
    isObject = require('./isObject');

/** Used as the `TypeError` message for "Functions" methods. */
var FUNC_ERROR_TEXT = 'Expected a function';

/**
 * Creates a throttled function that only invokes `func` at most once per
 * every `wait` milliseconds. The throttled function comes with a `cancel`
 * method to cancel delayed `func` invocations and a `flush` method to
 * immediately invoke them. Provide an options object to indicate whether
 * `func` should be invoked on the leading and/or trailing edge of the `wait`
 * timeout. The `func` is invoked with the last arguments provided to the
 * throttled function. Subsequent calls to the throttled function return the
 * result of the last `func` invocation.
 *
 * **Note:** If `leading` and `trailing` options are `true`, `func` is
 * invoked on the trailing edge of the timeout only if the throttled function
 * is invoked more than once during the `wait` timeout.
 *
 * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
 * for details over the differences between `_.throttle` and `_.debounce`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to throttle.
 * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
 * @param {Object} [options={}] The options object.
 * @param {boolean} [options.leading=true]
 *  Specify invoking on the leading edge of the timeout.
 * @param {boolean} [options.trailing=true]
 *  Specify invoking on the trailing edge of the timeout.
 * @returns {Function} Returns the new throttled function.
 * @example
 *
 * // Avoid excessively updating the position while scrolling.
 * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
 *
 * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
 * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
 * jQuery(element).on('click', throttled);
 *
 * // Cancel the trailing throttled invocation.
 * jQuery(window).on('popstate', throttled.cancel);
 */
function throttle(func, wait, options) {
  var leading = true,
      trailing = true;

  if (typeof func != 'function') {
    throw new TypeError(FUNC_ERROR_TEXT);
  }
  if (isObject(options)) {
    leading = 'leading' in options ? !!options.leading : leading;
    trailing = 'trailing' in options ? !!options.trailing : trailing;
  }
  return debounce(func, wait, {
    'leading': leading,
    'maxWait': wait,
    'trailing': trailing
  });
}

module.exports = throttle;

},{"./debounce":609,"./isObject":613}],620:[function(require,module,exports){
var toNumber = require('./toNumber');

/** Used as references for various `Number` constants. */
var INFINITY = 1 / 0,
    MAX_INTEGER = 1.7976931348623157e+308;

/**
 * Converts `value` to a finite number.
 *
 * @static
 * @memberOf _
 * @since 4.12.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted number.
 * @example
 *
 * _.toFinite(3.2);
 * // => 3.2
 *
 * _.toFinite(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toFinite(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toFinite('3.2');
 * // => 3.2
 */
function toFinite(value) {
  if (!value) {
    return value === 0 ? value : 0;
  }
  value = toNumber(value);
  if (value === INFINITY || value === -INFINITY) {
    var sign = (value < 0 ? -1 : 1);
    return sign * MAX_INTEGER;
  }
  return value === value ? value : 0;
}

module.exports = toFinite;

},{"./toNumber":622}],621:[function(require,module,exports){
var toFinite = require('./toFinite');

/**
 * Converts `value` to an integer.
 *
 * **Note:** This method is loosely based on
 * [`ToInteger`](http://www.ecma-international.org/ecma-262/6.0/#sec-tointeger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * _.toInteger(3.2);
 * // => 3
 *
 * _.toInteger(Number.MIN_VALUE);
 * // => 0
 *
 * _.toInteger(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toInteger('3.2');
 * // => 3
 */
function toInteger(value) {
  var result = toFinite(value),
      remainder = result % 1;

  return result === result ? (remainder ? result - remainder : result) : 0;
}

module.exports = toInteger;

},{"./toFinite":620}],622:[function(require,module,exports){
var isFunction = require('./isFunction'),
    isObject = require('./isObject'),
    isSymbol = require('./isSymbol');

/** Used as references for various `Number` constants. */
var NAN = 0 / 0;

/** Used to match leading and trailing whitespace. */
var reTrim = /^\s+|\s+$/g;

/** Used to detect bad signed hexadecimal string values. */
var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

/** Used to detect binary string values. */
var reIsBinary = /^0b[01]+$/i;

/** Used to detect octal string values. */
var reIsOctal = /^0o[0-7]+$/i;

/** Built-in method references without a dependency on `root`. */
var freeParseInt = parseInt;

/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */
function toNumber(value) {
  if (typeof value == 'number') {
    return value;
  }
  if (isSymbol(value)) {
    return NAN;
  }
  if (isObject(value)) {
    var other = isFunction(value.valueOf) ? value.valueOf() : value;
    value = isObject(other) ? (other + '') : other;
  }
  if (typeof value != 'string') {
    return value === 0 ? value : +value;
  }
  value = value.replace(reTrim, '');
  var isBinary = reIsBinary.test(value);
  return (isBinary || reIsOctal.test(value))
    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
    : (reIsBadHex.test(value) ? NAN : +value);
}

module.exports = toNumber;

},{"./isFunction":612,"./isObject":613,"./isSymbol":615}],623:[function(require,module,exports){
var LazyWrapper = require('./_LazyWrapper'),
    LodashWrapper = require('./_LodashWrapper'),
    baseLodash = require('./_baseLodash'),
    isArray = require('./isArray'),
    isObjectLike = require('./isObjectLike'),
    wrapperClone = require('./_wrapperClone');

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates a `lodash` object which wraps `value` to enable implicit method
 * chain sequences. Methods that operate on and return arrays, collections,
 * and functions can be chained together. Methods that retrieve a single value
 * or may return a primitive value will automatically end the chain sequence
 * and return the unwrapped value. Otherwise, the value must be unwrapped
 * with `_#value`.
 *
 * Explicit chain sequences, which must be unwrapped with `_#value`, may be
 * enabled using `_.chain`.
 *
 * The execution of chained methods is lazy, that is, it's deferred until
 * `_#value` is implicitly or explicitly called.
 *
 * Lazy evaluation allows several methods to support shortcut fusion.
 * Shortcut fusion is an optimization to merge iteratee calls; this avoids
 * the creation of intermediate arrays and can greatly reduce the number of
 * iteratee executions. Sections of a chain sequence qualify for shortcut
 * fusion if the section is applied to an array of at least `200` elements
 * and any iteratees accept only one argument. The heuristic for whether a
 * section qualifies for shortcut fusion is subject to change.
 *
 * Chaining is supported in custom builds as long as the `_#value` method is
 * directly or indirectly included in the build.
 *
 * In addition to lodash methods, wrappers have `Array` and `String` methods.
 *
 * The wrapper `Array` methods are:
 * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
 *
 * The wrapper `String` methods are:
 * `replace` and `split`
 *
 * The wrapper methods that support shortcut fusion are:
 * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
 * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
 * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
 *
 * The chainable wrapper methods are:
 * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
 * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
 * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
 * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
 * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
 * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
 * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
 * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
 * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
 * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
 * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
 * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
 * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
 * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
 * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
 * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
 * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
 * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
 * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
 * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
 * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
 * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
 * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
 * `zipObject`, `zipObjectDeep`, and `zipWith`
 *
 * The wrapper methods that are **not** chainable by default are:
 * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
 * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `deburr`, `divide`, `each`,
 * `eachRight`, `endsWith`, `eq`, `escape`, `escapeRegExp`, `every`, `find`,
 * `findIndex`, `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `first`,
 * `floor`, `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`,
 * `forOwnRight`, `get`, `gt`, `gte`, `has`, `hasIn`, `head`, `identity`,
 * `includes`, `indexOf`, `inRange`, `invoke`, `isArguments`, `isArray`,
 * `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`, `isBoolean`,
 * `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`, `isEqualWith`,
 * `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`, `isMap`,
 * `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
 * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
 * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
 * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
 * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
 * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
 * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
 * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
 * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
 * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
 * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
 * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
 * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
 * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
 * `upperFirst`, `value`, and `words`
 *
 * @name _
 * @constructor
 * @category Seq
 * @param {*} value The value to wrap in a `lodash` instance.
 * @returns {Object} Returns the new `lodash` wrapper instance.
 * @example
 *
 * function square(n) {
 *   return n * n;
 * }
 *
 * var wrapped = _([1, 2, 3]);
 *
 * // Returns an unwrapped value.
 * wrapped.reduce(_.add);
 * // => 6
 *
 * // Returns a wrapped value.
 * var squares = wrapped.map(square);
 *
 * _.isArray(squares);
 * // => false
 *
 * _.isArray(squares.value());
 * // => true
 */
function lodash(value) {
  if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
    if (value instanceof LodashWrapper) {
      return value;
    }
    if (hasOwnProperty.call(value, '__wrapped__')) {
      return wrapperClone(value);
    }
  }
  return new LodashWrapper(value);
}

// Ensure wrappers are instances of `baseLodash`.
lodash.prototype = baseLodash.prototype;
lodash.prototype.constructor = lodash;

module.exports = lodash;

},{"./_LazyWrapper":568,"./_LodashWrapper":569,"./_baseLodash":574,"./_wrapperClone":606,"./isArray":611,"./isObjectLike":614}],624:[function(require,module,exports){
var indexOf = require('./indexOf');

    /**
     * Combines an array with all the items of another.
     * Does not allow duplicates and is case and type sensitive.
     */
    function combine(arr1, arr2) {
        if (arr2 == null) {
            return arr1;
        }

        var i = -1, len = arr2.length;
        while (++i < len) {
            if (indexOf(arr1, arr2[i]) === -1) {
                arr1.push(arr2[i]);
            }
        }

        return arr1;
    }
    module.exports = combine;


},{"./indexOf":633}],625:[function(require,module,exports){
var indexOf = require('./indexOf');

    /**
     * If array contains values.
     */
    function contains(arr, val) {
        return indexOf(arr, val) !== -1;
    }
    module.exports = contains;


},{"./indexOf":633}],626:[function(require,module,exports){
var unique = require('./unique');
var filter = require('./filter');
var some = require('./some');
var contains = require('./contains');
var slice = require('./slice');


    /**
     * Return a new Array with elements that aren't present in the other Arrays.
     */
    function difference(arr) {
        var arrs = slice(arguments, 1),
            result = filter(unique(arr), function(needle){
                return !some(arrs, function(haystack){
                    return contains(haystack, needle);
                });
            });
        return result;
    }

    module.exports = difference;



},{"./contains":625,"./filter":629,"./slice":637,"./some":638,"./unique":639}],627:[function(require,module,exports){
var is = require('../lang/is');
var isArray = require('../lang/isArray');
var every = require('./every');

    /**
     * Compares if both arrays have the same elements
     */
    function equals(a, b, callback){
        callback = callback || is;

        if (!isArray(a) || !isArray(b)) {
            return callback(a, b);
        }

        if (a.length !== b.length) {
            return false;
        }

        return every(a, makeCompare(callback), b);
    }

    function makeCompare(callback) {
        return function(value, i) {
            return i in this && callback(value, this[i]);
        };
    }

    module.exports = equals;



},{"../lang/is":647,"../lang/isArray":648,"./every":628}],628:[function(require,module,exports){
var makeIterator = require('../function/makeIterator_');

    /**
     * Array every
     */
    function every(arr, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        var result = true;
        if (arr == null) {
            return result;
        }

        var i = -1, len = arr.length;
        while (++i < len) {
            // we iterate over sparse items since there is no way to make it
            // work properly on IE 7-8. see #64
            if (!callback(arr[i], i, arr) ) {
                result = false;
                break;
            }
        }

        return result;
    }

    module.exports = every;


},{"../function/makeIterator_":641}],629:[function(require,module,exports){
var makeIterator = require('../function/makeIterator_');

    /**
     * Array filter
     */
    function filter(arr, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        var results = [];
        if (arr == null) {
            return results;
        }

        var i = -1, len = arr.length, value;
        while (++i < len) {
            value = arr[i];
            if (callback(value, i, arr)) {
                results.push(value);
            }
        }

        return results;
    }

    module.exports = filter;



},{"../function/makeIterator_":641}],630:[function(require,module,exports){
var findIndex = require('./findIndex');

    /**
     * Returns first item that matches criteria
     */
    function find(arr, iterator, thisObj){
        var idx = findIndex(arr, iterator, thisObj);
        return idx >= 0? arr[idx] : void(0);
    }

    module.exports = find;



},{"./findIndex":631}],631:[function(require,module,exports){
var makeIterator = require('../function/makeIterator_');

    /**
     * Returns the index of the first item that matches criteria
     */
    function findIndex(arr, iterator, thisObj){
        iterator = makeIterator(iterator, thisObj);
        if (arr == null) {
            return -1;
        }

        var i = -1, len = arr.length;
        while (++i < len) {
            if (iterator(arr[i], i, arr)) {
                return i;
            }
        }

        return -1;
    }

    module.exports = findIndex;


},{"../function/makeIterator_":641}],632:[function(require,module,exports){
arguments[4][534][0].apply(exports,arguments)
},{"dup":534}],633:[function(require,module,exports){


    /**
     * Array.indexOf
     */
    function indexOf(arr, item, fromIndex) {
        fromIndex = fromIndex || 0;
        if (arr == null) {
            return -1;
        }

        var len = arr.length,
            i = fromIndex < 0 ? len + fromIndex : fromIndex;
        while (i < len) {
            // we iterate over sparse items since there is no way to make it
            // work properly on IE 7-8. see #64
            if (arr[i] === item) {
                return i;
            }

            i++;
        }

        return -1;
    }

    module.exports = indexOf;


},{}],634:[function(require,module,exports){
var unique = require('./unique');
var filter = require('./filter');
var every = require('./every');
var contains = require('./contains');
var slice = require('./slice');


    /**
     * Return a new Array with elements common to all Arrays.
     * - based on underscore.js implementation
     */
    function intersection(arr) {
        var arrs = slice(arguments, 1),
            result = filter(unique(arr), function(needle){
                return every(arrs, function(haystack){
                    return contains(haystack, needle);
                });
            });
        return result;
    }

    module.exports = intersection;



},{"./contains":625,"./every":628,"./filter":629,"./slice":637,"./unique":639}],635:[function(require,module,exports){
arguments[4][535][0].apply(exports,arguments)
},{"../function/makeIterator_":641,"dup":535}],636:[function(require,module,exports){
var indexOf = require('./indexOf');

    /**
     * Remove a single item from the array.
     * (it won't remove duplicates, just a single item)
     */
    function remove(arr, item){
        var idx = indexOf(arr, item);
        if (idx !== -1) arr.splice(idx, 1);
    }

    module.exports = remove;


},{"./indexOf":633}],637:[function(require,module,exports){
arguments[4][537][0].apply(exports,arguments)
},{"dup":537}],638:[function(require,module,exports){
var makeIterator = require('../function/makeIterator_');

    /**
     * Array some
     */
    function some(arr, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        var result = false;
        if (arr == null) {
            return result;
        }

        var i = -1, len = arr.length;
        while (++i < len) {
            // we iterate over sparse items since there is no way to make it
            // work properly on IE 7-8. see #64
            if ( callback(arr[i], i, arr) ) {
                result = true;
                break;
            }
        }

        return result;
    }

    module.exports = some;


},{"../function/makeIterator_":641}],639:[function(require,module,exports){
var filter = require('./filter');

    /**
     * @return {array} Array of unique items
     */
    function unique(arr, compare){
        compare = compare || isEqual;
        return filter(arr, function(item, i, arr){
            var n = arr.length;
            while (++i < n) {
                if ( compare(item, arr[i]) ) {
                    return false;
                }
            }
            return true;
        });
    }

    function isEqual(a, b){
        return a === b;
    }

    module.exports = unique;



},{"./filter":629}],640:[function(require,module,exports){
arguments[4][541][0].apply(exports,arguments)
},{"dup":541}],641:[function(require,module,exports){
arguments[4][542][0].apply(exports,arguments)
},{"../object/deepMatches":658,"./identity":640,"./prop":642,"dup":542}],642:[function(require,module,exports){
arguments[4][543][0].apply(exports,arguments)
},{"dup":543}],643:[function(require,module,exports){
var kindOf = require('./kindOf');
var isPlainObject = require('./isPlainObject');
var mixIn = require('../object/mixIn');

    /**
     * Clone native types.
     */
    function clone(val){
        switch (kindOf(val)) {
            case 'Object':
                return cloneObject(val);
            case 'Array':
                return cloneArray(val);
            case 'RegExp':
                return cloneRegExp(val);
            case 'Date':
                return cloneDate(val);
            default:
                return val;
        }
    }

    function cloneObject(source) {
        if (isPlainObject(source)) {
            return mixIn({}, source);
        } else {
            return source;
        }
    }

    function cloneRegExp(r) {
        var flags = '';
        flags += r.multiline ? 'm' : '';
        flags += r.global ? 'g' : '';
        flags += r.ignoreCase ? 'i' : '';
        return new RegExp(r.source, flags);
    }

    function cloneDate(date) {
        return new Date(+date);
    }

    function cloneArray(arr) {
        return arr.slice();
    }

    module.exports = clone;



},{"../object/mixIn":667,"./isPlainObject":652,"./kindOf":655}],644:[function(require,module,exports){
arguments[4][544][0].apply(exports,arguments)
},{"../object/mixIn":667,"dup":544}],645:[function(require,module,exports){
var clone = require('./clone');
var forOwn = require('../object/forOwn');
var kindOf = require('./kindOf');
var isPlainObject = require('./isPlainObject');

    /**
     * Recursively clone native types.
     */
    function deepClone(val, instanceClone) {
        switch ( kindOf(val) ) {
            case 'Object':
                return cloneObject(val, instanceClone);
            case 'Array':
                return cloneArray(val, instanceClone);
            default:
                return clone(val);
        }
    }

    function cloneObject(source, instanceClone) {
        if (isPlainObject(source)) {
            var out = {};
            forOwn(source, function(val, key) {
                this[key] = deepClone(val, instanceClone);
            }, out);
            return out;
        } else if (instanceClone) {
            return instanceClone(source);
        } else {
            return source;
        }
    }

    function cloneArray(arr, instanceClone) {
        var out = [],
            i = -1,
            n = arr.length,
            val;
        while (++i < n) {
            out[i] = deepClone(arr[i], instanceClone);
        }
        return out;
    }

    module.exports = deepClone;




},{"../object/forOwn":663,"./clone":643,"./isPlainObject":652,"./kindOf":655}],646:[function(require,module,exports){
var is = require('./is');
var isObject = require('./isObject');
var isArray = require('./isArray');
var objEquals = require('../object/equals');
var arrEquals = require('../array/equals');

    /**
     * Recursively checks for same properties and values.
     */
    function deepEquals(a, b, callback){
        callback = callback || is;

        var bothObjects = isObject(a) && isObject(b);
        var bothArrays = !bothObjects && isArray(a) && isArray(b);

        if (!bothObjects && !bothArrays) {
            return callback(a, b);
        }

        function compare(a, b){
            return deepEquals(a, b, callback);
        }

        var method = bothObjects ? objEquals : arrEquals;
        return method(a, b, compare);
    }

    module.exports = deepEquals;



},{"../array/equals":627,"../object/equals":660,"./is":647,"./isArray":648,"./isObject":651}],647:[function(require,module,exports){


    /**
     * Check if both arguments are egal.
     */
    function is(x, y){
        // implementation borrowed from harmony:egal spec
        if (x === y) {
          // 0 === -0, but they are not identical
          return x !== 0 || 1 / x === 1 / y;
        }

        // NaN !== NaN, but they are identical.
        // NaNs are the only non-reflexive value, i.e., if x !== x,
        // then x is a NaN.
        // isNaN is broken: it converts its argument to number, so
        // isNaN("foo") => true
        return x !== x && y !== y;
    }

    module.exports = is;



},{}],648:[function(require,module,exports){
arguments[4][545][0].apply(exports,arguments)
},{"./isKind":649,"dup":545}],649:[function(require,module,exports){
arguments[4][546][0].apply(exports,arguments)
},{"./kindOf":655,"dup":546}],650:[function(require,module,exports){
var isKind = require('./isKind');
    /**
     */
    function isNumber(val) {
        return isKind(val, 'Number');
    }
    module.exports = isNumber;


},{"./isKind":649}],651:[function(require,module,exports){
arguments[4][547][0].apply(exports,arguments)
},{"./isKind":649,"dup":547}],652:[function(require,module,exports){


    /**
     * Checks if the value is created by the `Object` constructor.
     */
    function isPlainObject(value) {
        return (!!value && typeof value === 'object' &&
            value.constructor === Object);
    }

    module.exports = isPlainObject;



},{}],653:[function(require,module,exports){
var isKind = require('./isKind');
    /**
     */
    function isRegExp(val) {
        return isKind(val, 'RegExp');
    }
    module.exports = isRegExp;


},{"./isKind":649}],654:[function(require,module,exports){
var isKind = require('./isKind');
    /**
     */
    function isString(val) {
        return isKind(val, 'String');
    }
    module.exports = isString;


},{"./isKind":649}],655:[function(require,module,exports){
arguments[4][548][0].apply(exports,arguments)
},{"dup":548}],656:[function(require,module,exports){


    /**
     * Typecast a value to a String, using an empty string value for null or
     * undefined.
     */
    function toString(val){
        return val == null ? '' : val.toString();
    }

    module.exports = toString;



},{}],657:[function(require,module,exports){
var forOwn = require('./forOwn');
var isPlainObject = require('../lang/isPlainObject');

    /**
     * Deeply copy missing properties in the target from the defaults.
     */
    function deepFillIn(target, defaults){
        var i = 0,
            n = arguments.length,
            obj;

        while(++i < n) {
            obj = arguments[i];
            if (obj) {
                // jshint loopfunc: true
                forOwn(obj, function(newValue, key) {
                    var curValue = target[key];
                    if (curValue == null) {
                        target[key] = newValue;
                    } else if (isPlainObject(curValue) &&
                               isPlainObject(newValue)) {
                        deepFillIn(curValue, newValue);
                    }
                });
            }
        }

        return target;
    }

    module.exports = deepFillIn;



},{"../lang/isPlainObject":652,"./forOwn":663}],658:[function(require,module,exports){
arguments[4][549][0].apply(exports,arguments)
},{"../lang/isArray":648,"./forOwn":663,"dup":549}],659:[function(require,module,exports){
var forOwn = require('./forOwn');
var isPlainObject = require('../lang/isPlainObject');

    /**
     * Mixes objects into the target object, recursively mixing existing child
     * objects.
     */
    function deepMixIn(target, objects) {
        var i = 0,
            n = arguments.length,
            obj;

        while(++i < n){
            obj = arguments[i];
            if (obj) {
                forOwn(obj, copyProp, target);
            }
        }

        return target;
    }

    function copyProp(val, key) {
        var existing = this[key];
        if (isPlainObject(val) && isPlainObject(existing)) {
            deepMixIn(existing, val);
        } else {
            this[key] = val;
        }
    }

    module.exports = deepMixIn;



},{"../lang/isPlainObject":652,"./forOwn":663}],660:[function(require,module,exports){
var hasOwn = require('./hasOwn');
var every = require('./every');
var isObject = require('../lang/isObject');
var is = require('../lang/is');

    // Makes a function to compare the object values from the specified compare
    // operation callback.
    function makeCompare(callback) {
        return function(value, key) {
            return hasOwn(this, key) && callback(value, this[key]);
        };
    }

    function checkProperties(value, key) {
        return hasOwn(this, key);
    }

    /**
     * Checks if two objects have the same keys and values.
     */
    function equals(a, b, callback) {
        callback = callback || is;

        if (!isObject(a) || !isObject(b)) {
            return callback(a, b);
        }

        return (every(a, makeCompare(callback), b) &&
                every(b, checkProperties, a));
    }

    module.exports = equals;


},{"../lang/is":647,"../lang/isObject":651,"./every":661,"./hasOwn":664}],661:[function(require,module,exports){
var forOwn = require('./forOwn');
var makeIterator = require('../function/makeIterator_');

    /**
     * Object every
     */
    function every(obj, callback, thisObj) {
        callback = makeIterator(callback, thisObj);
        var result = true;
        forOwn(obj, function(val, key) {
            // we consider any falsy values as "false" on purpose so shorthand
            // syntax can be used to check property existence
            if (!callback(val, key, obj)) {
                result = false;
                return false; // break
            }
        });
        return result;
    }

    module.exports = every;



},{"../function/makeIterator_":641,"./forOwn":663}],662:[function(require,module,exports){
arguments[4][550][0].apply(exports,arguments)
},{"./hasOwn":664,"dup":550}],663:[function(require,module,exports){
arguments[4][551][0].apply(exports,arguments)
},{"./forIn":662,"./hasOwn":664,"dup":551}],664:[function(require,module,exports){
arguments[4][552][0].apply(exports,arguments)
},{"dup":552}],665:[function(require,module,exports){
var forOwn = require('./forOwn');

    /**
     * Get object keys
     */
     var keys = Object.keys || function (obj) {
            var keys = [];
            forOwn(obj, function(val, key){
                keys.push(key);
            });
            return keys;
        };

    module.exports = keys;



},{"./forOwn":663}],666:[function(require,module,exports){
var hasOwn = require('./hasOwn');
var deepClone = require('../lang/deepClone');
var isObject = require('../lang/isObject');

    /**
     * Deep merge objects.
     */
    function merge() {
        var i = 1,
            key, val, obj, target;

        // make sure we don't modify source element and it's properties
        // objects are passed by reference
        target = deepClone( arguments[0] );

        while (obj = arguments[i++]) {
            for (key in obj) {
                if ( ! hasOwn(obj, key) ) {
                    continue;
                }

                val = obj[key];

                if ( isObject(val) && isObject(target[key]) ){
                    // inception, deep merge objects
                    target[key] = merge(target[key], val);
                } else {
                    // make sure arrays, regexp, date, objects are cloned
                    target[key] = deepClone(val);
                }

            }
        }

        return target;
    }

    module.exports = merge;



},{"../lang/deepClone":645,"../lang/isObject":651,"./hasOwn":664}],667:[function(require,module,exports){
arguments[4][553][0].apply(exports,arguments)
},{"./forOwn":663,"dup":553}],668:[function(require,module,exports){
var slice = require('../array/slice');

    /**
     * Return a copy of the object, filtered to only have values for the whitelisted keys.
     */
    function pick(obj, var_keys){
        var keys = typeof arguments[1] !== 'string'? arguments[1] : slice(arguments, 1),
            out = {},
            i = 0, key;
        while (key = keys[i++]) {
            out[key] = obj[key];
        }
        return out;
    }

    module.exports = pick;



},{"../array/slice":637}],669:[function(require,module,exports){

    /**
     * Contains all Unicode white-spaces. Taken from
     * http://en.wikipedia.org/wiki/Whitespace_character.
     */
    module.exports = [
        ' ', '\n', '\r', '\t', '\f', '\v', '\u00A0', '\u1680', '\u180E',
        '\u2000', '\u2001', '\u2002', '\u2003', '\u2004', '\u2005', '\u2006',
        '\u2007', '\u2008', '\u2009', '\u200A', '\u2028', '\u2029', '\u202F',
        '\u205F', '\u3000'
    ];


},{}],670:[function(require,module,exports){
var toString = require('../lang/toString');

    /**
     * Escape RegExp string chars.
     */
    function escapeRegExp(str) {
        return toString(str).replace(/\W/g,'\\$&');
    }

    module.exports = escapeRegExp;



},{"../lang/toString":656}],671:[function(require,module,exports){
var toString = require('../lang/toString');
var WHITE_SPACES = require('./WHITE_SPACES');
    /**
     * Remove chars from beginning of string.
     */
    function ltrim(str, chars) {
        str = toString(str);
        chars = chars || WHITE_SPACES;

        var start = 0,
            len = str.length,
            charLen = chars.length,
            found = true,
            i, c;

        while (found && start < len) {
            found = false;
            i = -1;
            c = str.charAt(start);

            while (++i < charLen) {
                if (c === chars[i]) {
                    found = true;
                    start++;
                    break;
                }
            }
        }

        return (start >= len) ? '' : str.substr(start, len);
    }

    module.exports = ltrim;


},{"../lang/toString":656,"./WHITE_SPACES":669}],672:[function(require,module,exports){
var toString = require('../lang/toString');
var WHITE_SPACES = require('./WHITE_SPACES');
    /**
     * Remove chars from end of string.
     */
    function rtrim(str, chars) {
        str = toString(str);
        chars = chars || WHITE_SPACES;

        var end = str.length - 1,
            charLen = chars.length,
            found = true,
            i, c;

        while (found && end >= 0) {
            found = false;
            i = -1;
            c = str.charAt(end);

            while (++i < charLen) {
                if (c === chars[i]) {
                    found = true;
                    end--;
                    break;
                }
            }
        }

        return (end >= 0) ? str.substring(0, end + 1) : '';
    }

    module.exports = rtrim;


},{"../lang/toString":656,"./WHITE_SPACES":669}],673:[function(require,module,exports){
var toString = require('../lang/toString');
var WHITE_SPACES = require('./WHITE_SPACES');
var ltrim = require('./ltrim');
var rtrim = require('./rtrim');
    /**
     * Remove white-spaces from beginning and end of string.
     */
    function trim(str, chars) {
        str = toString(str);
        chars = chars || WHITE_SPACES;
        return ltrim(rtrim(str, chars), chars);
    }

    module.exports = trim;


},{"../lang/toString":656,"./WHITE_SPACES":669,"./ltrim":671,"./rtrim":672}],674:[function(require,module,exports){


    /**
     * Get current time in miliseconds
     */
    function now(){
        // yes, we defer the work to another function to allow mocking it
        // during the tests
        return now.get();
    }

    now.get = (typeof Date.now === 'function')? Date.now : function(){
        return +(new Date());
    };

    module.exports = now;



},{}],675:[function(require,module,exports){
/**
 * Helpers.
 */

var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} options
 * @return {String|Number}
 * @api public
 */

module.exports = function(val, options){
  options = options || {};
  if ('string' == typeof val) return parse(val);
  return options.long
    ? long(val)
    : short(val);
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = '' + str;
  if (str.length > 10000) return;
  var match = /^((?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(str);
  if (!match) return;
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function short(ms) {
  if (ms >= d) return Math.round(ms / d) + 'd';
  if (ms >= h) return Math.round(ms / h) + 'h';
  if (ms >= m) return Math.round(ms / m) + 'm';
  if (ms >= s) return Math.round(ms / s) + 's';
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function long(ms) {
  return plural(ms, d, 'day')
    || plural(ms, h, 'hour')
    || plural(ms, m, 'minute')
    || plural(ms, s, 'second')
    || ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, n, name) {
  if (ms < n) return;
  if (ms < n * 1.5) return Math.floor(ms / n) + ' ' + name;
  return Math.ceil(ms / n) + ' ' + name + 's';
}

},{}],676:[function(require,module,exports){
(function (process,global){
/*
defer
*/"use strict"

var kindOf  = require("mout/lang/kindOf"),
    now     = require("mout/time/now"),
    forEach = require("mout/array/forEach"),
    indexOf = require("mout/array/indexOf")

var callbacks = {
    timeout: {},
    frame: [],
    immediate: []
}

var push = function(collection, callback, context, defer){

    var iterator = function(){
        iterate(collection)
    }

    if (!collection.length) defer(iterator)

    var entry = {
        callback: callback,
        context: context
    }

    collection.push(entry)

    return function(){
        var io = indexOf(collection, entry)
        if (io > -1) collection.splice(io, 1)
    }
}

var iterate = function(collection){
    var time = now()

    forEach(collection.splice(0), function(entry) {
        entry.callback.call(entry.context, time)
    })
}

var defer = function(callback, argument, context){
    return (kindOf(argument) === "Number") ? defer.timeout(callback, argument, context) : defer.immediate(callback, argument)
}

if (global.process && process.nextTick){

    defer.immediate = function(callback, context){
        return push(callbacks.immediate, callback, context, process.nextTick)
    }

} else if (global.setImmediate){

    defer.immediate = function(callback, context){
        return push(callbacks.immediate, callback, context, setImmediate)
    }

} else if (global.postMessage && global.addEventListener){

    addEventListener("message", function(event){
        if (event.source === global && event.data === "@deferred"){
            event.stopPropagation()
            iterate(callbacks.immediate)
        }
    }, true)

    defer.immediate = function(callback, context){
        return push(callbacks.immediate, callback, context, function(){
            postMessage("@deferred", "*")
        })
    }

} else {

    defer.immediate = function(callback, context){
        return push(callbacks.immediate, callback, context, function(iterator){
            setTimeout(iterator, 0)
        })
    }

}

var requestAnimationFrame = global.requestAnimationFrame ||
    global.webkitRequestAnimationFrame ||
    global.mozRequestAnimationFrame ||
    global.oRequestAnimationFrame ||
    global.msRequestAnimationFrame ||
    function(callback) {
        setTimeout(callback, 1e3 / 60)
    }

defer.frame = function(callback, context){
    return push(callbacks.frame, callback, context, requestAnimationFrame)
}

var clear

defer.timeout = function(callback, ms, context){
    var ct = callbacks.timeout

    if (!clear) clear = defer.immediate(function(){
        clear = null
        callbacks.timeout = {}
    })

    return push(ct[ms] || (ct[ms] = []), callback, context, function(iterator){
        setTimeout(iterator, ms)
    })
}

module.exports = defer

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"_process":680,"mout/array/forEach":632,"mout/array/indexOf":633,"mout/lang/kindOf":655,"mout/time/now":674}],677:[function(require,module,exports){
/*
Emitter
*/"use strict"

var indexOf = require("mout/array/indexOf"),
    forEach = require("mout/array/forEach")

var prime = require("./index"),
    defer = require("./defer")

var slice = Array.prototype.slice;

var Emitter = prime({

    constructor: function(stoppable){
        this._stoppable = stoppable
    },

    on: function(event, fn){
        var listeners = this._listeners || (this._listeners = {}),
            events = listeners[event] || (listeners[event] = [])

        if (indexOf(events, fn) === -1) events.push(fn)

        return this
    },

    off: function(event, fn){
        var listeners = this._listeners, events
        if (listeners && (events = listeners[event])){

            var io = indexOf(events, fn)
            if (io > -1) events.splice(io, 1)
            if (!events.length) delete listeners[event];
            for (var l in listeners) return this
            delete this._listeners
        }
        return this
    },

    emit: function(event){
        var self = this,
            args = slice.call(arguments, 1)

        var emit = function(){
            var listeners = self._listeners, events
            if (listeners && (events = listeners[event])){
                forEach(events.slice(0), function(event){
                    var result = event.apply(self, args)
                    if (self._stoppable) return result
                })
            }
        }

        if (args[args.length - 1] === Emitter.EMIT_SYNC){
            args.pop()
            emit()
        } else {
            defer(emit)
        }

        return this
    }

})

Emitter.EMIT_SYNC = {}

module.exports = Emitter

},{"./defer":676,"./index":678,"mout/array/forEach":632,"mout/array/indexOf":633}],678:[function(require,module,exports){
arguments[4][555][0].apply(exports,arguments)
},{"dup":555,"mout/lang/createObject":644,"mout/lang/kindOf":655,"mout/object/hasOwn":664,"mout/object/mixIn":667}],679:[function(require,module,exports){
/*
Map
*/"use strict"

var indexOf = require("mout/array/indexOf")

var prime = require("./index")

var Map = prime({

    constructor: function Map(){
        this.length = 0
        this._values = []
        this._keys = []
    },

    set: function(key, value){
        var index = indexOf(this._keys, key)

        if (index === -1){
            this._keys.push(key)
            this._values.push(value)
            this.length++
        } else {
            this._values[index] = value
        }

        return this
    },

    get: function(key){
        var index = indexOf(this._keys, key)
        return (index === -1) ? null : this._values[index]
    },

    count: function(){
        return this.length
    },

    forEach: function(method, context){
        for (var i = 0, l = this.length; i < l; i++){
            if (method.call(context, this._values[i], this._keys[i], this) === false) break
        }
        return this
    },

    map: function(method, context){
        var results = new Map
        this.forEach(function(value, key){
            results.set(key, method.call(context, value, key, this))
        }, this)
        return results
    },

    filter: function(method, context){
        var results = new Map
        this.forEach(function(value, key){
            if (method.call(context, value, key, this)) results.set(key, value)
        }, this)
        return results
    },

    every: function(method, context){
        var every = true
        this.forEach(function(value, key){
            if (!method.call(context, value, key, this)) return (every = false)
        }, this)
        return every
    },

    some: function(method, context){
        var some = false
        this.forEach(function(value, key){
            if (method.call(context, value, key, this)) return !(some = true)
        }, this)
        return some
    },

    indexOf: function(value){
        var index = indexOf(this._values, value)
        return (index > -1) ? this._keys[index] : null
    },

    remove: function(value){
        var index = indexOf(this._values, value)

        if (index !== -1){
            this._values.splice(index, 1)
            this.length--
            return this._keys.splice(index, 1)[0]
        }

        return null
    },

    unset: function(key){
        var index = indexOf(this._keys, key)

        if (index !== -1){
            this._keys.splice(index, 1)
            this.length--
            return this._values.splice(index, 1)[0]
        }

        return null
    },

    keys: function(){
        return this._keys.slice()
    },

    values: function(){
        return this._values.slice()
    }

})

var map = function(){
    return new Map
}

map.prototype = Map.prototype

module.exports = map

},{"./index":678,"mout/array/indexOf":633}],680:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],681:[function(require,module,exports){
(function (global){
/*! Quill Editor v0.19.10
 *  https://quilljs.com/
 *  Copyright (c) 2014, Jason Chen
 *  Copyright (c) 2013, salesforce.com
 */
(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.Quill = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw (f.code="MODULE_NOT_FOUND", f)}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(_dereq_,module,exports){
(function (global){
/**
 * @license
 * lodash 3.5.0 (Custom Build) <https://lodash.com/>
 * Build: `lodash modern include="difference,intersection,last,all,each,invoke,map,reduce,bind,defer,partial,clone,extend,defaults,omit,values,isElement,isEqual,isFunction,isNumber,isObject,isString,uniqueId" --development --output .build/lodash.js`
 * Copyright 2012-2015 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.2 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */
;(function() {

  /** Used as a safe reference for `undefined` in pre-ES5 environments. */
  var undefined;

  /** Used as the semantic version number. */
  var VERSION = '3.5.0';

  /** Used to compose bitmasks for wrapper metadata. */
  var BIND_FLAG = 1,
      BIND_KEY_FLAG = 2,
      CURRY_BOUND_FLAG = 4,
      CURRY_FLAG = 8,
      CURRY_RIGHT_FLAG = 16,
      PARTIAL_FLAG = 32,
      PARTIAL_RIGHT_FLAG = 64,
      REARG_FLAG = 128,
      ARY_FLAG = 256;

  /** Used to detect when a function becomes hot. */
  var HOT_COUNT = 150,
      HOT_SPAN = 16;

  /** Used as the `TypeError` message for "Functions" methods. */
  var FUNC_ERROR_TEXT = 'Expected a function';

  /** Used as the internal argument placeholder. */
  var PLACEHOLDER = '__lodash_placeholder__';

  /** `Object#toString` result references. */
  var argsTag = '[object Arguments]',
      arrayTag = '[object Array]',
      boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      errorTag = '[object Error]',
      funcTag = '[object Function]',
      mapTag = '[object Map]',
      numberTag = '[object Number]',
      objectTag = '[object Object]',
      regexpTag = '[object RegExp]',
      setTag = '[object Set]',
      stringTag = '[object String]',
      weakMapTag = '[object WeakMap]';

  var arrayBufferTag = '[object ArrayBuffer]',
      float32Tag = '[object Float32Array]',
      float64Tag = '[object Float64Array]',
      int8Tag = '[object Int8Array]',
      int16Tag = '[object Int16Array]',
      int32Tag = '[object Int32Array]',
      uint8Tag = '[object Uint8Array]',
      uint8ClampedTag = '[object Uint8ClampedArray]',
      uint16Tag = '[object Uint16Array]',
      uint32Tag = '[object Uint32Array]';

  /** Used to match `RegExp` flags from their coerced string values. */
  var reFlags = /\w*$/;

  /** Used to detect named functions. */
  var reFuncName = /^\s*function[ \n\r\t]+\w/;

  /** Used to detect host constructors (Safari > 5). */
  var reHostCtor = /^\[object .+?Constructor\]$/;

  /**
   * Used to match `RegExp` special characters.
   * See this [article on `RegExp` characters](http://www.regular-expressions.info/characters.html#special)
   * for more details.
   */
  var reRegExpChars = /[.*+?^${}()|[\]\/\\]/g,
      reHasRegExpChars = RegExp(reRegExpChars.source);

  /** Used to detect functions containing a `this` reference. */
  var reThis = /\bthis\b/;

  /** Used to identify `toStringTag` values of typed arrays. */
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
  typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
  typedArrayTags[dateTag] = typedArrayTags[errorTag] =
  typedArrayTags[funcTag] = typedArrayTags[mapTag] =
  typedArrayTags[numberTag] = typedArrayTags[objectTag] =
  typedArrayTags[regexpTag] = typedArrayTags[setTag] =
  typedArrayTags[stringTag] = typedArrayTags[weakMapTag] = false;

  /** Used to identify `toStringTag` values supported by `_.clone`. */
  var cloneableTags = {};
  cloneableTags[argsTag] = cloneableTags[arrayTag] =
  cloneableTags[arrayBufferTag] = cloneableTags[boolTag] =
  cloneableTags[dateTag] = cloneableTags[float32Tag] =
  cloneableTags[float64Tag] = cloneableTags[int8Tag] =
  cloneableTags[int16Tag] = cloneableTags[int32Tag] =
  cloneableTags[numberTag] = cloneableTags[objectTag] =
  cloneableTags[regexpTag] = cloneableTags[stringTag] =
  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
  cloneableTags[errorTag] = cloneableTags[funcTag] =
  cloneableTags[mapTag] = cloneableTags[setTag] =
  cloneableTags[weakMapTag] = false;

  /** Used to determine if values are of the language type `Object`. */
  var objectTypes = {
    'function': true,
    'object': true
  };

  /** Detect free variable `exports`. */
  var freeExports = objectTypes[typeof exports] && exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule = objectTypes[typeof module] && module && !module.nodeType && module;

  /** Detect free variable `global` from Node.js. */
  var freeGlobal = freeExports && freeModule && typeof global == 'object' && global;

  /** Detect free variable `window`. */
  var freeWindow = objectTypes[typeof window] && window;

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;

  /**
   * Used as a reference to the global object.
   *
   * The `this` value is used if it is the global object to avoid Greasemonkey's
   * restricted `window` object, otherwise the `window` object is used.
   */
  var root = freeGlobal || ((freeWindow !== (this && this.window)) && freeWindow) || this;

  /*--------------------------------------------------------------------------*/

  /**
   * The base implementation of `_.indexOf` without support for binary searches.
   *
   * @private
   * @param {Array} array The array to search.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseIndexOf(array, value, fromIndex) {
    if (value !== value) {
      return indexOfNaN(array, fromIndex);
    }
    var index = fromIndex - 1,
        length = array.length;

    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }

  /**
   * The base implementation of `_.isFunction` without support for environments
   * with incorrect `typeof` results.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
   */
  function baseIsFunction(value) {
    // Avoid a Chakra JIT bug in compatibility modes of IE 11.
    // See https://github.com/jashkenas/underscore/issues/1621 for more details.
    return typeof value == 'function' || false;
  }

  /**
   * Converts `value` to a string if it is not one. An empty string is returned
   * for `null` or `undefined` values.
   *
   * @private
   * @param {*} value The value to process.
   * @returns {string} Returns the string.
   */
  function baseToString(value) {
    if (typeof value == 'string') {
      return value;
    }
    return value == null ? '' : (value + '');
  }

  /**
   * Gets the index at which the first occurrence of `NaN` is found in `array`.
   * If `fromRight` is provided elements of `array` are iterated from right to left.
   *
   * @private
   * @param {Array} array The array to search.
   * @param {number} fromIndex The index to search from.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {number} Returns the index of the matched `NaN`, else `-1`.
   */
  function indexOfNaN(array, fromIndex, fromRight) {
    var length = array.length,
        index = fromIndex + (fromRight ? 0 : -1);

    while ((fromRight ? index-- : ++index < length)) {
      var other = array[index];
      if (other !== other) {
        return index;
      }
    }
    return -1;
  }

  /**
   * Checks if `value` is object-like.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   */
  function isObjectLike(value) {
    return (value && typeof value == 'object') || false;
  }

  /**
   * Replaces all `placeholder` elements in `array` with an internal placeholder
   * and returns an array of their indexes.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {*} placeholder The placeholder to replace.
   * @returns {Array} Returns the new array of placeholder indexes.
   */
  function replaceHolders(array, placeholder) {
    var index = -1,
        length = array.length,
        resIndex = -1,
        result = [];

    while (++index < length) {
      if (array[index] === placeholder) {
        array[index] = PLACEHOLDER;
        result[++resIndex] = index;
      }
    }
    return result;
  }

  /*--------------------------------------------------------------------------*/

  /** Used for native method references. */
  var objectProto = Object.prototype;

  /** Used to detect DOM support. */
  var document = (document = root.window) && document.document;

  /** Used to resolve the decompiled source of functions. */
  var fnToString = Function.prototype.toString;

  /** Used to check objects for own properties. */
  var hasOwnProperty = objectProto.hasOwnProperty;

  /** Used to generate unique IDs. */
  var idCounter = 0;

  /**
   * Used to resolve the `toStringTag` of values.
   * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.prototype.tostring)
   * for more details.
   */
  var objToString = objectProto.toString;

  /** Used to detect if a method is native. */
  var reNative = RegExp('^' +
    escapeRegExp(objToString)
    .replace(/toString|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
  );

  /** Native method references. */
  var ArrayBuffer = isNative(ArrayBuffer = root.ArrayBuffer) && ArrayBuffer,
      bufferSlice = isNative(bufferSlice = ArrayBuffer && new ArrayBuffer(0).slice) && bufferSlice,
      floor = Math.floor,
      getPrototypeOf = isNative(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf,
      propertyIsEnumerable = objectProto.propertyIsEnumerable,
      Set = isNative(Set = root.Set) && Set,
      Uint8Array = isNative(Uint8Array = root.Uint8Array) && Uint8Array,
      WeakMap = isNative(WeakMap = root.WeakMap) && WeakMap;

  /** Used to clone array buffers. */
  var Float64Array = (function() {
    // Safari 5 errors when using an array buffer to initialize a typed array
    // where the array buffer's `byteLength` is not a multiple of the typed
    // array's `BYTES_PER_ELEMENT`.
    try {
      var func = isNative(func = root.Float64Array) && func,
          result = new func(new ArrayBuffer(10), 0, 1) && func;
    } catch(e) {}
    return result;
  }());

  /* Native method references for those with the same name as other `lodash` methods. */
  var nativeIsArray = isNative(nativeIsArray = Array.isArray) && nativeIsArray,
      nativeCreate = isNative(nativeCreate = Object.create) && nativeCreate,
      nativeKeys = isNative(nativeKeys = Object.keys) && nativeKeys,
      nativeMax = Math.max,
      nativeMin = Math.min,
      nativeNow = isNative(nativeNow = Date.now) && nativeNow;

  /** Used as references for the maximum length and index of an array. */
  var MAX_ARRAY_LENGTH = Math.pow(2, 32) - 1,
      MAX_ARRAY_INDEX =  MAX_ARRAY_LENGTH - 1,
      HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;

  /** Used as the size, in bytes, of each `Float64Array` element. */
  var FLOAT64_BYTES_PER_ELEMENT = Float64Array ? Float64Array.BYTES_PER_ELEMENT : 0;

  /**
   * Used as the maximum length of an array-like value.
   * See the [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-number.max_safe_integer)
   * for more details.
   */
  var MAX_SAFE_INTEGER = Math.pow(2, 53) - 1;

  /** Used to store function metadata. */
  var metaMap = WeakMap && new WeakMap;

  /*------------------------------------------------------------------------*/

  /**
   * Creates a `lodash` object which wraps `value` to enable implicit chaining.
   * Methods that operate on and return arrays, collections, and functions can
   * be chained together. Methods that return a boolean or single value will
   * automatically end the chain returning the unwrapped value. Explicit chaining
   * may be enabled using `_.chain`. The execution of chained methods is lazy,
   * that is, execution is deferred until `_#value` is implicitly or explicitly
   * called.
   *
   * Lazy evaluation allows several methods to support shortcut fusion. Shortcut
   * fusion is an optimization that merges iteratees to avoid creating intermediate
   * arrays and reduce the number of iteratee executions.
   *
   * Chaining is supported in custom builds as long as the `_#value` method is
   * directly or indirectly included in the build.
   *
   * In addition to lodash methods, wrappers have `Array` and `String` methods.
   *
   * The wrapper `Array` methods are:
   * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`,
   * `splice`, and `unshift`
   *
   * The wrapper `String` methods are:
   * `replace` and `split`
   *
   * The wrapper methods that support shortcut fusion are:
   * `compact`, `drop`, `dropRight`, `dropRightWhile`, `dropWhile`, `filter`,
   * `first`, `initial`, `last`, `map`, `pluck`, `reject`, `rest`, `reverse`,
   * `slice`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, `toArray`,
   * and `where`
   *
   * The chainable wrapper methods are:
   * `after`, `ary`, `assign`, `at`, `before`, `bind`, `bindAll`, `bindKey`,
   * `callback`, `chain`, `chunk`, `commit`, `compact`, `concat`, `constant`,
   * `countBy`, `create`, `curry`, `debounce`, `defaults`, `defer`, `delay`,
   * `difference`, `drop`, `dropRight`, `dropRightWhile`, `dropWhile`, `fill`,
   * `filter`, `flatten`, `flattenDeep`, `flow`, `flowRight`, `forEach`,
   * `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `functions`,
   * `groupBy`, `indexBy`, `initial`, `intersection`, `invert`, `invoke`, `keys`,
   * `keysIn`, `map`, `mapValues`, `matches`, `matchesProperty`, `memoize`, `merge`,
   * `mixin`, `negate`, `noop`, `omit`, `once`, `pairs`, `partial`, `partialRight`,
   * `partition`, `pick`, `plant`, `pluck`, `property`, `propertyOf`, `pull`,
   * `pullAt`, `push`, `range`, `rearg`, `reject`, `remove`, `rest`, `reverse`,
   * `shuffle`, `slice`, `sort`, `sortBy`, `sortByAll`, `sortByOrder`, `splice`,
   * `spread`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, `tap`,
   * `throttle`, `thru`, `times`, `toArray`, `toPlainObject`, `transform`,
   * `union`, `uniq`, `unshift`, `unzip`, `values`, `valuesIn`, `where`,
   * `without`, `wrap`, `xor`, `zip`, and `zipObject`
   *
   * The wrapper methods that are **not** chainable by default are:
   * `add`, `attempt`, `camelCase`, `capitalize`, `clone`, `cloneDeep`, `deburr`,
   * `endsWith`, `escape`, `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`,
   * `findLast`, `findLastIndex`, `findLastKey`, `findWhere`, `first`, `has`,
   * `identity`, `includes`, `indexOf`, `inRange`, `isArguments`, `isArray`,
   * `isBoolean`, `isDate`, `isElement`, `isEmpty`, `isEqual`, `isError`,
   * `isFinite`,`isFunction`, `isMatch`, `isNative`, `isNaN`, `isNull`, `isNumber`,
   * `isObject`, `isPlainObject`, `isRegExp`, `isString`, `isUndefined`,
   * `isTypedArray`, `join`, `kebabCase`, `last`, `lastIndexOf`, `max`, `min`,
   * `noConflict`, `now`, `pad`, `padLeft`, `padRight`, `parseInt`, `pop`,
   * `random`, `reduce`, `reduceRight`, `repeat`, `result`, `runInContext`,
   * `shift`, `size`, `snakeCase`, `some`, `sortedIndex`, `sortedLastIndex`,
   * `startCase`, `startsWith`, `sum`, `template`, `trim`, `trimLeft`,
   * `trimRight`, `trunc`, `unescape`, `uniqueId`, `value`, and `words`
   *
   * The wrapper method `sample` will return a wrapped value when `n` is provided,
   * otherwise an unwrapped value is returned.
   *
   * @name _
   * @constructor
   * @category Chain
   * @param {*} value The value to wrap in a `lodash` instance.
   * @returns {Object} Returns the new `lodash` wrapper instance.
   * @example
   *
   * var wrapped = _([1, 2, 3]);
   *
   * // returns an unwrapped value
   * wrapped.reduce(function(sum, n) {
   *   return sum + n;
   * });
   * // => 6
   *
   * // returns a wrapped value
   * var squares = wrapped.map(function(n) {
   *   return n * n;
   * });
   *
   * _.isArray(squares);
   * // => false
   *
   * _.isArray(squares.value());
   * // => true
   */
  function lodash() {
    // No operation performed.
  }

  /**
   * An object environment feature flags.
   *
   * @static
   * @memberOf _
   * @type Object
   */
  var support = lodash.support = {};

  (function(x) {

    /**
     * Detect if functions can be decompiled by `Function#toString`
     * (all but Firefox OS certified apps, older Opera mobile browsers, and
     * the PlayStation 3; forced `false` for Windows 8 apps).
     *
     * @memberOf _.support
     * @type boolean
     */
    support.funcDecomp = !isNative(root.WinRTError) && reThis.test(function() { return this; });

    /**
     * Detect if `Function#name` is supported (all but IE).
     *
     * @memberOf _.support
     * @type boolean
     */
    support.funcNames = typeof Function.name == 'string';

    /**
     * Detect if the DOM is supported.
     *
     * @memberOf _.support
     * @type boolean
     */
    try {
      support.dom = document.createDocumentFragment().nodeType === 11;
    } catch(e) {
      support.dom = false;
    }

    /**
     * Detect if `arguments` object indexes are non-enumerable.
     *
     * In Firefox < 4, IE < 9, PhantomJS, and Safari < 5.1 `arguments` object
     * indexes are non-enumerable. Chrome < 25 and Node.js < 0.11.0 treat
     * `arguments` object indexes as non-enumerable and fail `hasOwnProperty`
     * checks for indexes that exceed their function's formal parameters with
     * associated values of `0`.
     *
     * @memberOf _.support
     * @type boolean
     */
    try {
      support.nonEnumArgs = !propertyIsEnumerable.call(arguments, 1);
    } catch(e) {
      support.nonEnumArgs = true;
    }
  }(0, 0));

  /*------------------------------------------------------------------------*/

  /**
   *
   * Creates a cache object to store unique values.
   *
   * @private
   * @param {Array} [values] The values to cache.
   */
  function SetCache(values) {
    var length = values ? values.length : 0;

    this.data = { 'hash': nativeCreate(null), 'set': new Set };
    while (length--) {
      this.push(values[length]);
    }
  }

  /**
   * Checks if `value` is in `cache` mimicking the return signature of
   * `_.indexOf` by returning `0` if the value is found, else `-1`.
   *
   * @private
   * @param {Object} cache The cache to search.
   * @param {*} value The value to search for.
   * @returns {number} Returns `0` if `value` is found, else `-1`.
   */
  function cacheIndexOf(cache, value) {
    var data = cache.data,
        result = (typeof value == 'string' || isObject(value)) ? data.set.has(value) : data.hash[value];

    return result ? 0 : -1;
  }

  /**
   * Adds `value` to the cache.
   *
   * @private
   * @name push
   * @memberOf SetCache
   * @param {*} value The value to cache.
   */
  function cachePush(value) {
    var data = this.data;
    if (typeof value == 'string' || isObject(value)) {
      data.set.add(value);
    } else {
      data.hash[value] = true;
    }
  }

  /*------------------------------------------------------------------------*/

  /**
   * Copies the values of `source` to `array`.
   *
   * @private
   * @param {Array} source The array to copy values from.
   * @param {Array} [array=[]] The array to copy values to.
   * @returns {Array} Returns `array`.
   */
  function arrayCopy(source, array) {
    var index = -1,
        length = source.length;

    array || (array = Array(length));
    while (++index < length) {
      array[index] = source[index];
    }
    return array;
  }

  /**
   * A specialized version of `_.forEach` for arrays without support for callback
   * shorthands or `this` binding.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */
  function arrayEach(array, iteratee) {
    var index = -1,
        length = array.length;

    while (++index < length) {
      if (iteratee(array[index], index, array) === false) {
        break;
      }
    }
    return array;
  }

  /**
   * A specialized version of `_.every` for arrays without support for callback
   * shorthands or `this` binding.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if all elements pass the predicate check,
   *  else `false`.
   */
  function arrayEvery(array, predicate) {
    var index = -1,
        length = array.length;

    while (++index < length) {
      if (!predicate(array[index], index, array)) {
        return false;
      }
    }
    return true;
  }

  /**
   * A specialized version of `_.map` for arrays without support for callback
   * shorthands or `this` binding.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   */
  function arrayMap(array, iteratee) {
    var index = -1,
        length = array.length,
        result = Array(length);

    while (++index < length) {
      result[index] = iteratee(array[index], index, array);
    }
    return result;
  }

  /**
   * A specialized version of `_.reduce` for arrays without support for callback
   * shorthands or `this` binding.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initFromArray] Specify using the first element of `array`
   *  as the initial value.
   * @returns {*} Returns the accumulated value.
   */
  function arrayReduce(array, iteratee, accumulator, initFromArray) {
    var index = -1,
        length = array.length;

    if (initFromArray && length) {
      accumulator = array[++index];
    }
    while (++index < length) {
      accumulator = iteratee(accumulator, array[index], index, array);
    }
    return accumulator;
  }

  /**
   * Used by `_.defaults` to customize its `_.assign` use.
   *
   * @private
   * @param {*} objectValue The destination object property value.
   * @param {*} sourceValue The source object property value.
   * @returns {*} Returns the value to assign to the destination object.
   */
  function assignDefaults(objectValue, sourceValue) {
    return typeof objectValue == 'undefined' ? sourceValue : objectValue;
  }

  /**
   * The base implementation of `_.assign` without support for argument juggling,
   * multiple sources, and `this` binding `customizer` functions.
   *
   * @private
   * @param {Object} object The destination object.
   * @param {Object} source The source object.
   * @param {Function} [customizer] The function to customize assigning values.
   * @returns {Object} Returns the destination object.
   */
  function baseAssign(object, source, customizer) {
    var props = keys(source);
    if (!customizer) {
      return baseCopy(source, object, props);
    }
    var index = -1,
        length = props.length;

    while (++index < length) {
      var key = props[index],
          value = object[key],
          result = customizer(value, source[key], key, object, source);

      if ((result === result ? (result !== value) : (value === value)) ||
          (typeof value == 'undefined' && !(key in object))) {
        object[key] = result;
      }
    }
    return object;
  }

  /**
   * Copies the properties of `source` to `object`.
   *
   * @private
   * @param {Object} source The object to copy properties from.
   * @param {Object} [object={}] The object to copy properties to.
   * @param {Array} props The property names to copy.
   * @returns {Object} Returns `object`.
   */
  function baseCopy(source, object, props) {
    if (!props) {
      props = object;
      object = {};
    }
    var index = -1,
        length = props.length;

    while (++index < length) {
      var key = props[index];
      object[key] = source[key];
    }
    return object;
  }

  /**
   * The base implementation of `_.callback` which supports specifying the
   * number of arguments to provide to `func`.
   *
   * @private
   * @param {*} [func=_.identity] The value to convert to a callback.
   * @param {*} [thisArg] The `this` binding of `func`.
   * @param {number} [argCount] The number of arguments to provide to `func`.
   * @returns {Function} Returns the callback.
   */
  function baseCallback(func, thisArg, argCount) {
    var type = typeof func;
    if (type == 'function') {
      return (typeof thisArg != 'undefined' && isBindable(func))
        ? bindCallback(func, thisArg, argCount)
        : func;
    }
    if (func == null) {
      return identity;
    }
    if (type == 'object') {
      return baseMatches(func);
    }
    return typeof thisArg == 'undefined'
      ? baseProperty(func + '')
      : baseMatchesProperty(func + '', thisArg);
  }

  /**
   * The base implementation of `_.clone` without support for argument juggling
   * and `this` binding `customizer` functions.
   *
   * @private
   * @param {*} value The value to clone.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @param {Function} [customizer] The function to customize cloning values.
   * @param {string} [key] The key of `value`.
   * @param {Object} [object] The object `value` belongs to.
   * @param {Array} [stackA=[]] Tracks traversed source objects.
   * @param {Array} [stackB=[]] Associates clones with source counterparts.
   * @returns {*} Returns the cloned value.
   */
  function baseClone(value, isDeep, customizer, key, object, stackA, stackB) {
    var result;
    if (customizer) {
      result = object ? customizer(value, key, object) : customizer(value);
    }
    if (typeof result != 'undefined') {
      return result;
    }
    if (!isObject(value)) {
      return value;
    }
    var isArr = isArray(value);
    if (isArr) {
      result = initCloneArray(value);
      if (!isDeep) {
        return arrayCopy(value, result);
      }
    } else {
      var tag = objToString.call(value),
          isFunc = tag == funcTag;

      if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
        result = initCloneObject(isFunc ? {} : value);
        if (!isDeep) {
          return baseCopy(value, result, keys(value));
        }
      } else {
        return cloneableTags[tag]
          ? initCloneByTag(value, tag, isDeep)
          : (object ? value : {});
      }
    }
    // Check for circular references and return corresponding clone.
    stackA || (stackA = []);
    stackB || (stackB = []);

    var length = stackA.length;
    while (length--) {
      if (stackA[length] == value) {
        return stackB[length];
      }
    }
    // Add the source value to the stack of traversed objects and associate it with its clone.
    stackA.push(value);
    stackB.push(result);

    // Recursively populate clone (susceptible to call stack limits).
    (isArr ? arrayEach : baseForOwn)(value, function(subValue, key) {
      result[key] = baseClone(subValue, isDeep, customizer, key, value, stackA, stackB);
    });
    return result;
  }

  /**
   * The base implementation of `_.create` without support for assigning
   * properties to the created object.
   *
   * @private
   * @param {Object} prototype The object to inherit from.
   * @returns {Object} Returns the new object.
   */
  var baseCreate = (function() {
    function Object() {}
    return function(prototype) {
      if (isObject(prototype)) {
        Object.prototype = prototype;
        var result = new Object;
        Object.prototype = null;
      }
      return result || root.Object();
    };
  }());

  /**
   * The base implementation of `_.delay` and `_.defer` which accepts an index
   * of where to slice the arguments to provide to `func`.
   *
   * @private
   * @param {Function} func The function to delay.
   * @param {number} wait The number of milliseconds to delay invocation.
   * @param {Object} args The `arguments` object to slice and provide to `func`.
   * @returns {number} Returns the timer id.
   */
  function baseDelay(func, wait, args, fromIndex) {
    if (typeof func != 'function') {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    return setTimeout(function() { func.apply(undefined, baseSlice(args, fromIndex)); }, wait);
  }

  /**
   * The base implementation of `_.difference` which accepts a single array
   * of values to exclude.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Array} values The values to exclude.
   * @returns {Array} Returns the new array of filtered values.
   */
  function baseDifference(array, values) {
    var length = array ? array.length : 0,
        result = [];

    if (!length) {
      return result;
    }
    var index = -1,
        indexOf = getIndexOf(),
        isCommon = indexOf == baseIndexOf,
        cache = (isCommon && values.length >= 200) ? createCache(values) : null,
        valuesLength = values.length;

    if (cache) {
      indexOf = cacheIndexOf;
      isCommon = false;
      values = cache;
    }
    outer:
    while (++index < length) {
      var value = array[index];

      if (isCommon && value === value) {
        var valuesIndex = valuesLength;
        while (valuesIndex--) {
          if (values[valuesIndex] === value) {
            continue outer;
          }
        }
        result.push(value);
      }
      else if (indexOf(values, value, 0) < 0) {
        result.push(value);
      }
    }
    return result;
  }

  /**
   * The base implementation of `_.forEach` without support for callback
   * shorthands and `this` binding.
   *
   * @private
   * @param {Array|Object|string} collection The collection to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array|Object|string} Returns `collection`.
   */
  function baseEach(collection, iteratee) {
    var length = collection ? collection.length : 0;
    if (!isLength(length)) {
      return baseForOwn(collection, iteratee);
    }
    var index = -1,
        iterable = toObject(collection);

    while (++index < length) {
      if (iteratee(iterable[index], index, iterable) === false) {
        break;
      }
    }
    return collection;
  }

  /**
   * The base implementation of `_.every` without support for callback
   * shorthands or `this` binding.
   *
   * @private
   * @param {Array|Object|string} collection The collection to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if all elements pass the predicate check,
   *  else `false`
   */
  function baseEvery(collection, predicate) {
    var result = true;
    baseEach(collection, function(value, index, collection) {
      result = !!predicate(value, index, collection);
      return result;
    });
    return result;
  }

  /**
   * The base implementation of `_.flatten` with added support for restricting
   * flattening and specifying the start index.
   *
   * @private
   * @param {Array} array The array to flatten.
   * @param {boolean} isDeep Specify a deep flatten.
   * @param {boolean} isStrict Restrict flattening to arrays and `arguments` objects.
   * @param {number} fromIndex The index to start from.
   * @returns {Array} Returns the new flattened array.
   */
  function baseFlatten(array, isDeep, isStrict, fromIndex) {
    var index = fromIndex - 1,
        length = array.length,
        resIndex = -1,
        result = [];

    while (++index < length) {
      var value = array[index];

      if (isObjectLike(value) && isLength(value.length) && (isArray(value) || isArguments(value))) {
        if (isDeep) {
          // Recursively flatten arrays (susceptible to call stack limits).
          value = baseFlatten(value, isDeep, isStrict, 0);
        }
        var valIndex = -1,
            valLength = value.length;

        result.length += valLength;
        while (++valIndex < valLength) {
          result[++resIndex] = value[valIndex];
        }
      } else if (!isStrict) {
        result[++resIndex] = value;
      }
    }
    return result;
  }

  /**
   * The base implementation of `baseForIn` and `baseForOwn` which iterates
   * over `object` properties returned by `keysFunc` invoking `iteratee` for
   * each property. Iterator functions may exit iteration early by explicitly
   * returning `false`.
   *
   * @private
   * @param {Object} object The object to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {Function} keysFunc The function to get the keys of `object`.
   * @returns {Object} Returns `object`.
   */
  function baseFor(object, iteratee, keysFunc) {
    var index = -1,
        iterable = toObject(object),
        props = keysFunc(object),
        length = props.length;

    while (++index < length) {
      var key = props[index];
      if (iteratee(iterable[key], key, iterable) === false) {
        break;
      }
    }
    return object;
  }

  /**
   * The base implementation of `_.forIn` without support for callback
   * shorthands and `this` binding.
   *
   * @private
   * @param {Object} object The object to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Object} Returns `object`.
   */
  function baseForIn(object, iteratee) {
    return baseFor(object, iteratee, keysIn);
  }

  /**
   * The base implementation of `_.forOwn` without support for callback
   * shorthands and `this` binding.
   *
   * @private
   * @param {Object} object The object to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Object} Returns `object`.
   */
  function baseForOwn(object, iteratee) {
    return baseFor(object, iteratee, keys);
  }

  /**
   * The base implementation of `_.invoke` which requires additional arguments
   * to be provided as an array of arguments rather than individually.
   *
   * @private
   * @param {Array|Object|string} collection The collection to iterate over.
   * @param {Function|string} methodName The name of the method to invoke or
   *  the function invoked per iteration.
   * @param {Array} [args] The arguments to invoke the method with.
   * @returns {Array} Returns the array of results.
   */
  function baseInvoke(collection, methodName, args) {
    var index = -1,
        isFunc = typeof methodName == 'function',
        length = collection ? collection.length : 0,
        result = isLength(length) ? Array(length) : [];

    baseEach(collection, function(value) {
      var func = isFunc ? methodName : (value != null && value[methodName]);
      result[++index] = func ? func.apply(value, args) : undefined;
    });
    return result;
  }

  /**
   * The base implementation of `_.isEqual` without support for `this` binding
   * `customizer` functions.
   *
   * @private
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @param {Function} [customizer] The function to customize comparing values.
   * @param {boolean} [isWhere] Specify performing partial comparisons.
   * @param {Array} [stackA] Tracks traversed `value` objects.
   * @param {Array} [stackB] Tracks traversed `other` objects.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   */
  function baseIsEqual(value, other, customizer, isWhere, stackA, stackB) {
    // Exit early for identical values.
    if (value === other) {
      // Treat `+0` vs. `-0` as not equal.
      return value !== 0 || (1 / value == 1 / other);
    }
    var valType = typeof value,
        othType = typeof other;

    // Exit early for unlike primitive values.
    if ((valType != 'function' && valType != 'object' && othType != 'function' && othType != 'object') ||
        value == null || other == null) {
      // Return `false` unless both values are `NaN`.
      return value !== value && other !== other;
    }
    return baseIsEqualDeep(value, other, baseIsEqual, customizer, isWhere, stackA, stackB);
  }

  /**
   * A specialized version of `baseIsEqual` for arrays and objects which performs
   * deep comparisons and tracks traversed objects enabling objects with circular
   * references to be compared.
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Function} [customizer] The function to customize comparing objects.
   * @param {boolean} [isWhere] Specify performing partial comparisons.
   * @param {Array} [stackA=[]] Tracks traversed `value` objects.
   * @param {Array} [stackB=[]] Tracks traversed `other` objects.
   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
   */
  function baseIsEqualDeep(object, other, equalFunc, customizer, isWhere, stackA, stackB) {
    var objIsArr = isArray(object),
        othIsArr = isArray(other),
        objTag = arrayTag,
        othTag = arrayTag;

    if (!objIsArr) {
      objTag = objToString.call(object);
      if (objTag == argsTag) {
        objTag = objectTag;
      } else if (objTag != objectTag) {
        objIsArr = isTypedArray(object);
      }
    }
    if (!othIsArr) {
      othTag = objToString.call(other);
      if (othTag == argsTag) {
        othTag = objectTag;
      } else if (othTag != objectTag) {
        othIsArr = isTypedArray(other);
      }
    }
    var objIsObj = objTag == objectTag,
        othIsObj = othTag == objectTag,
        isSameTag = objTag == othTag;

    if (isSameTag && !(objIsArr || objIsObj)) {
      return equalByTag(object, other, objTag);
    }
    var valWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
        othWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

    if (valWrapped || othWrapped) {
      return equalFunc(valWrapped ? object.value() : object, othWrapped ? other.value() : other, customizer, isWhere, stackA, stackB);
    }
    if (!isSameTag) {
      return false;
    }
    // Assume cyclic values are equal.
    // For more information on detecting circular references see https://es5.github.io/#JO.
    stackA || (stackA = []);
    stackB || (stackB = []);

    var length = stackA.length;
    while (length--) {
      if (stackA[length] == object) {
        return stackB[length] == other;
      }
    }
    // Add `object` and `other` to the stack of traversed objects.
    stackA.push(object);
    stackB.push(other);

    var result = (objIsArr ? equalArrays : equalObjects)(object, other, equalFunc, customizer, isWhere, stackA, stackB);

    stackA.pop();
    stackB.pop();

    return result;
  }

  /**
   * The base implementation of `_.isMatch` without support for callback
   * shorthands or `this` binding.
   *
   * @private
   * @param {Object} object The object to inspect.
   * @param {Array} props The source property names to match.
   * @param {Array} values The source values to match.
   * @param {Array} strictCompareFlags Strict comparison flags for source values.
   * @param {Function} [customizer] The function to customize comparing objects.
   * @returns {boolean} Returns `true` if `object` is a match, else `false`.
   */
  function baseIsMatch(object, props, values, strictCompareFlags, customizer) {
    var length = props.length;
    if (object == null) {
      return !length;
    }
    var index = -1,
        noCustomizer = !customizer;

    while (++index < length) {
      if ((noCustomizer && strictCompareFlags[index])
            ? values[index] !== object[props[index]]
            : !hasOwnProperty.call(object, props[index])
          ) {
        return false;
      }
    }
    index = -1;
    while (++index < length) {
      var key = props[index];
      if (noCustomizer && strictCompareFlags[index]) {
        var result = hasOwnProperty.call(object, key);
      } else {
        var objValue = object[key],
            srcValue = values[index];

        result = customizer ? customizer(objValue, srcValue, key) : undefined;
        if (typeof result == 'undefined') {
          result = baseIsEqual(srcValue, objValue, customizer, true);
        }
      }
      if (!result) {
        return false;
      }
    }
    return true;
  }

  /**
   * The base implementation of `_.map` without support for callback shorthands
   * or `this` binding.
   *
   * @private
   * @param {Array|Object|string} collection The collection to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   */
  function baseMap(collection, iteratee) {
    var result = [];
    baseEach(collection, function(value, key, collection) {
      result.push(iteratee(value, key, collection));
    });
    return result;
  }

  /**
   * The base implementation of `_.matches` which does not clone `source`.
   *
   * @private
   * @param {Object} source The object of property values to match.
   * @returns {Function} Returns the new function.
   */
  function baseMatches(source) {
    var props = keys(source),
        length = props.length;

    if (length == 1) {
      var key = props[0],
          value = source[key];

      if (isStrictComparable(value)) {
        return function(object) {
          return object != null && object[key] === value && hasOwnProperty.call(object, key);
        };
      }
    }
    var values = Array(length),
        strictCompareFlags = Array(length);

    while (length--) {
      value = source[props[length]];
      values[length] = value;
      strictCompareFlags[length] = isStrictComparable(value);
    }
    return function(object) {
      return baseIsMatch(object, props, values, strictCompareFlags);
    };
  }

  /**
   * The base implementation of `_.matchesProperty` which does not coerce `key`
   * to a string.
   *
   * @private
   * @param {string} key The key of the property to get.
   * @param {*} value The value to compare.
   * @returns {Function} Returns the new function.
   */
  function baseMatchesProperty(key, value) {
    if (isStrictComparable(value)) {
      return function(object) {
        return object != null && object[key] === value;
      };
    }
    return function(object) {
      return object != null && baseIsEqual(value, object[key], null, true);
    };
  }

  /**
   * The base implementation of `_.property` which does not coerce `key` to a string.
   *
   * @private
   * @param {string} key The key of the property to get.
   * @returns {Function} Returns the new function.
   */
  function baseProperty(key) {
    return function(object) {
      return object == null ? undefined : object[key];
    };
  }

  /**
   * The base implementation of `_.reduce` and `_.reduceRight` without support
   * for callback shorthands or `this` binding, which iterates over `collection`
   * using the provided `eachFunc`.
   *
   * @private
   * @param {Array|Object|string} collection The collection to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} accumulator The initial value.
   * @param {boolean} initFromCollection Specify using the first or last element
   *  of `collection` as the initial value.
   * @param {Function} eachFunc The function to iterate over `collection`.
   * @returns {*} Returns the accumulated value.
   */
  function baseReduce(collection, iteratee, accumulator, initFromCollection, eachFunc) {
    eachFunc(collection, function(value, index, collection) {
      accumulator = initFromCollection
        ? (initFromCollection = false, value)
        : iteratee(accumulator, value, index, collection);
    });
    return accumulator;
  }

  /**
   * The base implementation of `setData` without support for hot loop detection.
   *
   * @private
   * @param {Function} func The function to associate metadata with.
   * @param {*} data The metadata.
   * @returns {Function} Returns `func`.
   */
  var baseSetData = !metaMap ? identity : function(func, data) {
    metaMap.set(func, data);
    return func;
  };

  /**
   * The base implementation of `_.slice` without an iteratee call guard.
   *
   * @private
   * @param {Array} array The array to slice.
   * @param {number} [start=0] The start position.
   * @param {number} [end=array.length] The end position.
   * @returns {Array} Returns the slice of `array`.
   */
  function baseSlice(array, start, end) {
    var index = -1,
        length = array.length;

    start = start == null ? 0 : (+start || 0);
    if (start < 0) {
      start = -start > length ? 0 : (length + start);
    }
    end = (typeof end == 'undefined' || end > length) ? length : (+end || 0);
    if (end < 0) {
      end += length;
    }
    length = start > end ? 0 : ((end - start) >>> 0);
    start >>>= 0;

    var result = Array(length);
    while (++index < length) {
      result[index] = array[index + start];
    }
    return result;
  }

  /**
   * The base implementation of `_.values` and `_.valuesIn` which creates an
   * array of `object` property values corresponding to the property names
   * returned by `keysFunc`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the array of property values.
   */
  function baseValues(object, props) {
    var index = -1,
        length = props.length,
        result = Array(length);

    while (++index < length) {
      result[index] = object[props[index]];
    }
    return result;
  }

  /**
   * Performs a binary search of `array` to determine the index at which `value`
   * should be inserted into `array` in order to maintain its sort order.
   *
   * @private
   * @param {Array} array The sorted array to inspect.
   * @param {*} value The value to evaluate.
   * @param {boolean} [retHighest] Specify returning the highest, instead
   *  of the lowest, index at which a value should be inserted into `array`.
   * @returns {number} Returns the index at which `value` should be inserted
   *  into `array`.
   */
  function binaryIndex(array, value, retHighest) {
    var low = 0,
        high = array ? array.length : low;

    if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
      while (low < high) {
        var mid = (low + high) >>> 1,
            computed = array[mid];

        if (retHighest ? (computed <= value) : (computed < value)) {
          low = mid + 1;
        } else {
          high = mid;
        }
      }
      return high;
    }
    return binaryIndexBy(array, value, identity, retHighest);
  }

  /**
   * This function is like `binaryIndex` except that it invokes `iteratee` for
   * `value` and each element of `array` to compute their sort ranking. The
   * iteratee is invoked with one argument; (value).
   *
   * @private
   * @param {Array} array The sorted array to inspect.
   * @param {*} value The value to evaluate.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {boolean} [retHighest] Specify returning the highest, instead
   *  of the lowest, index at which a value should be inserted into `array`.
   * @returns {number} Returns the index at which `value` should be inserted
   *  into `array`.
   */
  function binaryIndexBy(array, value, iteratee, retHighest) {
    value = iteratee(value);

    var low = 0,
        high = array ? array.length : 0,
        valIsNaN = value !== value,
        valIsUndef = typeof value == 'undefined';

    while (low < high) {
      var mid = floor((low + high) / 2),
          computed = iteratee(array[mid]),
          isReflexive = computed === computed;

      if (valIsNaN) {
        var setLow = isReflexive || retHighest;
      } else if (valIsUndef) {
        setLow = isReflexive && (retHighest || typeof computed != 'undefined');
      } else {
        setLow = retHighest ? (computed <= value) : (computed < value);
      }
      if (setLow) {
        low = mid + 1;
      } else {
        high = mid;
      }
    }
    return nativeMin(high, MAX_ARRAY_INDEX);
  }

  /**
   * A specialized version of `baseCallback` which only supports `this` binding
   * and specifying the number of arguments to provide to `func`.
   *
   * @private
   * @param {Function} func The function to bind.
   * @param {*} thisArg The `this` binding of `func`.
   * @param {number} [argCount] The number of arguments to provide to `func`.
   * @returns {Function} Returns the callback.
   */
  function bindCallback(func, thisArg, argCount) {
    if (typeof func != 'function') {
      return identity;
    }
    if (typeof thisArg == 'undefined') {
      return func;
    }
    switch (argCount) {
      case 1: return function(value) {
        return func.call(thisArg, value);
      };
      case 3: return function(value, index, collection) {
        return func.call(thisArg, value, index, collection);
      };
      case 4: return function(accumulator, value, index, collection) {
        return func.call(thisArg, accumulator, value, index, collection);
      };
      case 5: return function(value, other, key, object, source) {
        return func.call(thisArg, value, other, key, object, source);
      };
    }
    return function() {
      return func.apply(thisArg, arguments);
    };
  }

  /**
   * Creates a clone of the given array buffer.
   *
   * @private
   * @param {ArrayBuffer} buffer The array buffer to clone.
   * @returns {ArrayBuffer} Returns the cloned array buffer.
   */
  function bufferClone(buffer) {
    return bufferSlice.call(buffer, 0);
  }
  if (!bufferSlice) {
    // PhantomJS has `ArrayBuffer` and `Uint8Array` but not `Float64Array`.
    bufferClone = !(ArrayBuffer && Uint8Array) ? constant(null) : function(buffer) {
      var byteLength = buffer.byteLength,
          floatLength = Float64Array ? floor(byteLength / FLOAT64_BYTES_PER_ELEMENT) : 0,
          offset = floatLength * FLOAT64_BYTES_PER_ELEMENT,
          result = new ArrayBuffer(byteLength);

      if (floatLength) {
        var view = new Float64Array(result, 0, floatLength);
        view.set(new Float64Array(buffer, 0, floatLength));
      }
      if (byteLength != offset) {
        view = new Uint8Array(result, offset);
        view.set(new Uint8Array(buffer, offset));
      }
      return result;
    };
  }

  /**
   * Creates an array that is the composition of partially applied arguments,
   * placeholders, and provided arguments into a single array of arguments.
   *
   * @private
   * @param {Array|Object} args The provided arguments.
   * @param {Array} partials The arguments to prepend to those provided.
   * @param {Array} holders The `partials` placeholder indexes.
   * @returns {Array} Returns the new array of composed arguments.
   */
  function composeArgs(args, partials, holders) {
    var holdersLength = holders.length,
        argsIndex = -1,
        argsLength = nativeMax(args.length - holdersLength, 0),
        leftIndex = -1,
        leftLength = partials.length,
        result = Array(argsLength + leftLength);

    while (++leftIndex < leftLength) {
      result[leftIndex] = partials[leftIndex];
    }
    while (++argsIndex < holdersLength) {
      result[holders[argsIndex]] = args[argsIndex];
    }
    while (argsLength--) {
      result[leftIndex++] = args[argsIndex++];
    }
    return result;
  }

  /**
   * This function is like `composeArgs` except that the arguments composition
   * is tailored for `_.partialRight`.
   *
   * @private
   * @param {Array|Object} args The provided arguments.
   * @param {Array} partials The arguments to append to those provided.
   * @param {Array} holders The `partials` placeholder indexes.
   * @returns {Array} Returns the new array of composed arguments.
   */
  function composeArgsRight(args, partials, holders) {
    var holdersIndex = -1,
        holdersLength = holders.length,
        argsIndex = -1,
        argsLength = nativeMax(args.length - holdersLength, 0),
        rightIndex = -1,
        rightLength = partials.length,
        result = Array(argsLength + rightLength);

    while (++argsIndex < argsLength) {
      result[argsIndex] = args[argsIndex];
    }
    var pad = argsIndex;
    while (++rightIndex < rightLength) {
      result[pad + rightIndex] = partials[rightIndex];
    }
    while (++holdersIndex < holdersLength) {
      result[pad + holders[holdersIndex]] = args[argsIndex++];
    }
    return result;
  }

  /**
   * Creates a function that assigns properties of source object(s) to a given
   * destination object.
   *
   * @private
   * @param {Function} assigner The function to assign values.
   * @returns {Function} Returns the new assigner function.
   */
  function createAssigner(assigner) {
    return function() {
      var args = arguments,
          length = args.length,
          object = args[0];

      if (length < 2 || object == null) {
        return object;
      }
      var customizer = args[length - 2],
          thisArg = args[length - 1],
          guard = args[3];

      if (length > 3 && typeof customizer == 'function') {
        customizer = bindCallback(customizer, thisArg, 5);
        length -= 2;
      } else {
        customizer = (length > 2 && typeof thisArg == 'function') ? thisArg : null;
        length -= (customizer ? 1 : 0);
      }
      if (guard && isIterateeCall(args[1], args[2], guard)) {
        customizer = length == 3 ? null : customizer;
        length = 2;
      }
      var index = 0;
      while (++index < length) {
        var source = args[index];
        if (source) {
          assigner(object, source, customizer);
        }
      }
      return object;
    };
  }

  /**
   * Creates a function that wraps `func` and invokes it with the `this`
   * binding of `thisArg`.
   *
   * @private
   * @param {Function} func The function to bind.
   * @param {*} [thisArg] The `this` binding of `func`.
   * @returns {Function} Returns the new bound function.
   */
  function createBindWrapper(func, thisArg) {
    var Ctor = createCtorWrapper(func);

    function wrapper() {
      var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
      return fn.apply(thisArg, arguments);
    }
    return wrapper;
  }

  /**
   * Creates a `Set` cache object to optimize linear searches of large arrays.
   *
   * @private
   * @param {Array} [values] The values to cache.
   * @returns {null|Object} Returns the new cache object if `Set` is supported, else `null`.
   */
  var createCache = !(nativeCreate && Set) ? constant(null) : function(values) {
    return new SetCache(values);
  };

  /**
   * Creates a function that produces an instance of `Ctor` regardless of
   * whether it was invoked as part of a `new` expression or by `call` or `apply`.
   *
   * @private
   * @param {Function} Ctor The constructor to wrap.
   * @returns {Function} Returns the new wrapped function.
   */
  function createCtorWrapper(Ctor) {
    return function() {
      var thisBinding = baseCreate(Ctor.prototype),
          result = Ctor.apply(thisBinding, arguments);

      // Mimic the constructor's `return` behavior.
      // See https://es5.github.io/#x13.2.2 for more details.
      return isObject(result) ? result : thisBinding;
    };
  }

  /**
   * Creates a function that wraps `func` and invokes it with optional `this`
   * binding of, partial application, and currying.
   *
   * @private
   * @param {Function|string} func The function or method name to reference.
   * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.
   * @param {*} [thisArg] The `this` binding of `func`.
   * @param {Array} [partials] The arguments to prepend to those provided to the new function.
   * @param {Array} [holders] The `partials` placeholder indexes.
   * @param {Array} [partialsRight] The arguments to append to those provided to the new function.
   * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
   * @param {Array} [argPos] The argument positions of the new function.
   * @param {number} [ary] The arity cap of `func`.
   * @param {number} [arity] The arity of `func`.
   * @returns {Function} Returns the new wrapped function.
   */
  function createHybridWrapper(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
    var isAry = bitmask & ARY_FLAG,
        isBind = bitmask & BIND_FLAG,
        isBindKey = bitmask & BIND_KEY_FLAG,
        isCurry = bitmask & CURRY_FLAG,
        isCurryBound = bitmask & CURRY_BOUND_FLAG,
        isCurryRight = bitmask & CURRY_RIGHT_FLAG;

    var Ctor = !isBindKey && createCtorWrapper(func),
        key = func;

    function wrapper() {
      // Avoid `arguments` object use disqualifying optimizations by
      // converting it to an array before providing it to other functions.
      var length = arguments.length,
          index = length,
          args = Array(length);

      while (index--) {
        args[index] = arguments[index];
      }
      if (partials) {
        args = composeArgs(args, partials, holders);
      }
      if (partialsRight) {
        args = composeArgsRight(args, partialsRight, holdersRight);
      }
      if (isCurry || isCurryRight) {
        var placeholder = wrapper.placeholder,
            argsHolders = replaceHolders(args, placeholder);

        length -= argsHolders.length;
        if (length < arity) {
          var newArgPos = argPos ? arrayCopy(argPos) : null,
              newArity = nativeMax(arity - length, 0),
              newsHolders = isCurry ? argsHolders : null,
              newHoldersRight = isCurry ? null : argsHolders,
              newPartials = isCurry ? args : null,
              newPartialsRight = isCurry ? null : args;

          bitmask |= (isCurry ? PARTIAL_FLAG : PARTIAL_RIGHT_FLAG);
          bitmask &= ~(isCurry ? PARTIAL_RIGHT_FLAG : PARTIAL_FLAG);

          if (!isCurryBound) {
            bitmask &= ~(BIND_FLAG | BIND_KEY_FLAG);
          }
          var result = createHybridWrapper(func, bitmask, thisArg, newPartials, newsHolders, newPartialsRight, newHoldersRight, newArgPos, ary, newArity);
          result.placeholder = placeholder;
          return result;
        }
      }
      var thisBinding = isBind ? thisArg : this;
      if (isBindKey) {
        func = thisBinding[key];
      }
      if (argPos) {
        args = reorder(args, argPos);
      }
      if (isAry && ary < args.length) {
        args.length = ary;
      }
      var fn = (this && this !== root && this instanceof wrapper) ? (Ctor || createCtorWrapper(func)) : func;
      return fn.apply(thisBinding, args);
    }
    return wrapper;
  }

  /**
   * Creates a function that wraps `func` and invokes it with the optional `this`
   * binding of `thisArg` and the `partials` prepended to those provided to
   * the wrapper.
   *
   * @private
   * @param {Function} func The function to partially apply arguments to.
   * @param {number} bitmask The bitmask of flags. See `createWrapper` for more details.
   * @param {*} thisArg The `this` binding of `func`.
   * @param {Array} partials The arguments to prepend to those provided to the new function.
   * @returns {Function} Returns the new bound function.
   */
  function createPartialWrapper(func, bitmask, thisArg, partials) {
    var isBind = bitmask & BIND_FLAG,
        Ctor = createCtorWrapper(func);

    function wrapper() {
      // Avoid `arguments` object use disqualifying optimizations by
      // converting it to an array before providing it `func`.
      var argsIndex = -1,
          argsLength = arguments.length,
          leftIndex = -1,
          leftLength = partials.length,
          args = Array(argsLength + leftLength);

      while (++leftIndex < leftLength) {
        args[leftIndex] = partials[leftIndex];
      }
      while (argsLength--) {
        args[leftIndex++] = arguments[++argsIndex];
      }
      var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
      return fn.apply(isBind ? thisArg : this, args);
    }
    return wrapper;
  }

  /**
   * Creates a function that either curries or invokes `func` with optional
   * `this` binding and partially applied arguments.
   *
   * @private
   * @param {Function|string} func The function or method name to reference.
   * @param {number} bitmask The bitmask of flags.
   *  The bitmask may be composed of the following flags:
   *     1 - `_.bind`
   *     2 - `_.bindKey`
   *     4 - `_.curry` or `_.curryRight` of a bound function
   *     8 - `_.curry`
   *    16 - `_.curryRight`
   *    32 - `_.partial`
   *    64 - `_.partialRight`
   *   128 - `_.rearg`
   *   256 - `_.ary`
   * @param {*} [thisArg] The `this` binding of `func`.
   * @param {Array} [partials] The arguments to be partially applied.
   * @param {Array} [holders] The `partials` placeholder indexes.
   * @param {Array} [argPos] The argument positions of the new function.
   * @param {number} [ary] The arity cap of `func`.
   * @param {number} [arity] The arity of `func`.
   * @returns {Function} Returns the new wrapped function.
   */
  function createWrapper(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
    var isBindKey = bitmask & BIND_KEY_FLAG;
    if (!isBindKey && typeof func != 'function') {
      throw new TypeError(FUNC_ERROR_TEXT);
    }
    var length = partials ? partials.length : 0;
    if (!length) {
      bitmask &= ~(PARTIAL_FLAG | PARTIAL_RIGHT_FLAG);
      partials = holders = null;
    }
    length -= (holders ? holders.length : 0);
    if (bitmask & PARTIAL_RIGHT_FLAG) {
      var partialsRight = partials,
          holdersRight = holders;

      partials = holders = null;
    }
    var data = !isBindKey && getData(func),
        newData = [func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity];

    if (data && data !== true) {
      mergeData(newData, data);
      bitmask = newData[1];
      arity = newData[9];
    }
    newData[9] = arity == null
      ? (isBindKey ? 0 : func.length)
      : (nativeMax(arity - length, 0) || 0);

    if (bitmask == BIND_FLAG) {
      var result = createBindWrapper(newData[0], newData[2]);
    } else if ((bitmask == PARTIAL_FLAG || bitmask == (BIND_FLAG | PARTIAL_FLAG)) && !newData[4].length) {
      result = createPartialWrapper.apply(undefined, newData);
    } else {
      result = createHybridWrapper.apply(undefined, newData);
    }
    var setter = data ? baseSetData : setData;
    return setter(result, newData);
  }

  /**
   * A specialized version of `baseIsEqualDeep` for arrays with support for
   * partial deep comparisons.
   *
   * @private
   * @param {Array} array The array to compare.
   * @param {Array} other The other array to compare.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Function} [customizer] The function to customize comparing arrays.
   * @param {boolean} [isWhere] Specify performing partial comparisons.
   * @param {Array} [stackA] Tracks traversed `value` objects.
   * @param {Array} [stackB] Tracks traversed `other` objects.
   * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
   */
  function equalArrays(array, other, equalFunc, customizer, isWhere, stackA, stackB) {
    var index = -1,
        arrLength = array.length,
        othLength = other.length,
        result = true;

    if (arrLength != othLength && !(isWhere && othLength > arrLength)) {
      return false;
    }
    // Deep compare the contents, ignoring non-numeric properties.
    while (result && ++index < arrLength) {
      var arrValue = array[index],
          othValue = other[index];

      result = undefined;
      if (customizer) {
        result = isWhere
          ? customizer(othValue, arrValue, index)
          : customizer(arrValue, othValue, index);
      }
      if (typeof result == 'undefined') {
        // Recursively compare arrays (susceptible to call stack limits).
        if (isWhere) {
          var othIndex = othLength;
          while (othIndex--) {
            othValue = other[othIndex];
            result = (arrValue && arrValue === othValue) || equalFunc(arrValue, othValue, customizer, isWhere, stackA, stackB);
            if (result) {
              break;
            }
          }
        } else {
          result = (arrValue && arrValue === othValue) || equalFunc(arrValue, othValue, customizer, isWhere, stackA, stackB);
        }
      }
    }
    return !!result;
  }

  /**
   * A specialized version of `baseIsEqualDeep` for comparing objects of
   * the same `toStringTag`.
   *
   * **Note:** This function only supports comparing values with tags of
   * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
   *
   * @private
   * @param {Object} value The object to compare.
   * @param {Object} other The other object to compare.
   * @param {string} tag The `toStringTag` of the objects to compare.
   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
   */
  function equalByTag(object, other, tag) {
    switch (tag) {
      case boolTag:
      case dateTag:
        // Coerce dates and booleans to numbers, dates to milliseconds and booleans
        // to `1` or `0` treating invalid dates coerced to `NaN` as not equal.
        return +object == +other;

      case errorTag:
        return object.name == other.name && object.message == other.message;

      case numberTag:
        // Treat `NaN` vs. `NaN` as equal.
        return (object != +object)
          ? other != +other
          // But, treat `-0` vs. `+0` as not equal.
          : (object == 0 ? ((1 / object) == (1 / other)) : object == +other);

      case regexpTag:
      case stringTag:
        // Coerce regexes to strings and treat strings primitives and string
        // objects as equal. See https://es5.github.io/#x15.10.6.4 for more details.
        return object == (other + '');
    }
    return false;
  }

  /**
   * A specialized version of `baseIsEqualDeep` for objects with support for
   * partial deep comparisons.
   *
   * @private
   * @param {Object} object The object to compare.
   * @param {Object} other The other object to compare.
   * @param {Function} equalFunc The function to determine equivalents of values.
   * @param {Function} [customizer] The function to customize comparing values.
   * @param {boolean} [isWhere] Specify performing partial comparisons.
   * @param {Array} [stackA] Tracks traversed `value` objects.
   * @param {Array} [stackB] Tracks traversed `other` objects.
   * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
   */
  function equalObjects(object, other, equalFunc, customizer, isWhere, stackA, stackB) {
    var objProps = keys(object),
        objLength = objProps.length,
        othProps = keys(other),
        othLength = othProps.length;

    if (objLength != othLength && !isWhere) {
      return false;
    }
    var hasCtor,
        index = -1;

    while (++index < objLength) {
      var key = objProps[index],
          result = hasOwnProperty.call(other, key);

      if (result) {
        var objValue = object[key],
            othValue = other[key];

        result = undefined;
        if (customizer) {
          result = isWhere
            ? customizer(othValue, objValue, key)
            : customizer(objValue, othValue, key);
        }
        if (typeof result == 'undefined') {
          // Recursively compare objects (susceptible to call stack limits).
          result = (objValue && objValue === othValue) || equalFunc(objValue, othValue, customizer, isWhere, stackA, stackB);
        }
      }
      if (!result) {
        return false;
      }
      hasCtor || (hasCtor = key == 'constructor');
    }
    if (!hasCtor) {
      var objCtor = object.constructor,
          othCtor = other.constructor;

      // Non `Object` object instances with different constructors are not equal.
      if (objCtor != othCtor &&
          ('constructor' in object && 'constructor' in other) &&
          !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
            typeof othCtor == 'function' && othCtor instanceof othCtor)) {
        return false;
      }
    }
    return true;
  }

  /**
   * Gets the appropriate "callback" function. If the `_.callback` method is
   * customized this function returns the custom method, otherwise it returns
   * the `baseCallback` function. If arguments are provided the chosen function
   * is invoked with them and its result is returned.
   *
   * @private
   * @returns {Function} Returns the chosen function or its result.
   */
  function getCallback(func, thisArg, argCount) {
    var result = lodash.callback || callback;
    result = result === callback ? baseCallback : result;
    return argCount ? result(func, thisArg, argCount) : result;
  }

  /**
   * Gets metadata for `func`.
   *
   * @private
   * @param {Function} func The function to query.
   * @returns {*} Returns the metadata for `func`.
   */
  var getData = !metaMap ? noop : function(func) {
    return metaMap.get(func);
  };

  /**
   * Gets the appropriate "indexOf" function. If the `_.indexOf` method is
   * customized this function returns the custom method, otherwise it returns
   * the `baseIndexOf` function. If arguments are provided the chosen function
   * is invoked with them and its result is returned.
   *
   * @private
   * @returns {Function|number} Returns the chosen function or its result.
   */
  function getIndexOf(collection, target, fromIndex) {
    var result = lodash.indexOf || indexOf;
    result = result === indexOf ? baseIndexOf : result;
    return collection ? result(collection, target, fromIndex) : result;
  }

  /**
   * Initializes an array clone.
   *
   * @private
   * @param {Array} array The array to clone.
   * @returns {Array} Returns the initialized clone.
   */
  function initCloneArray(array) {
    var length = array.length,
        result = new array.constructor(length);

    // Add array properties assigned by `RegExp#exec`.
    if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
      result.index = array.index;
      result.input = array.input;
    }
    return result;
  }

  /**
   * Initializes an object clone.
   *
   * @private
   * @param {Object} object The object to clone.
   * @returns {Object} Returns the initialized clone.
   */
  function initCloneObject(object) {
    var Ctor = object.constructor;
    if (!(typeof Ctor == 'function' && Ctor instanceof Ctor)) {
      Ctor = Object;
    }
    return new Ctor;
  }

  /**
   * Initializes an object clone based on its `toStringTag`.
   *
   * **Note:** This function only supports cloning values with tags of
   * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
   *
   *
   * @private
   * @param {Object} object The object to clone.
   * @param {string} tag The `toStringTag` of the object to clone.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @returns {Object} Returns the initialized clone.
   */
  function initCloneByTag(object, tag, isDeep) {
    var Ctor = object.constructor;
    switch (tag) {
      case arrayBufferTag:
        return bufferClone(object);

      case boolTag:
      case dateTag:
        return new Ctor(+object);

      case float32Tag: case float64Tag:
      case int8Tag: case int16Tag: case int32Tag:
      case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
        var buffer = object.buffer;
        return new Ctor(isDeep ? bufferClone(buffer) : buffer, object.byteOffset, object.length);

      case numberTag:
      case stringTag:
        return new Ctor(object);

      case regexpTag:
        var result = new Ctor(object.source, reFlags.exec(object));
        result.lastIndex = object.lastIndex;
    }
    return result;
  }

  /**
   * Checks if `func` is eligible for `this` binding.
   *
   * @private
   * @param {Function} func The function to check.
   * @returns {boolean} Returns `true` if `func` is eligible, else `false`.
   */
  function isBindable(func) {
    var support = lodash.support,
        result = !(support.funcNames ? func.name : support.funcDecomp);

    if (!result) {
      var source = fnToString.call(func);
      if (!support.funcNames) {
        result = !reFuncName.test(source);
      }
      if (!result) {
        // Check if `func` references the `this` keyword and store the result.
        result = reThis.test(source) || isNative(func);
        baseSetData(func, result);
      }
    }
    return result;
  }

  /**
   * Checks if `value` is a valid array-like index.
   *
   * @private
   * @param {*} value The value to check.
   * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
   * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
   */
  function isIndex(value, length) {
    value = +value;
    length = length == null ? MAX_SAFE_INTEGER : length;
    return value > -1 && value % 1 == 0 && value < length;
  }

  /**
   * Checks if the provided arguments are from an iteratee call.
   *
   * @private
   * @param {*} value The potential iteratee value argument.
   * @param {*} index The potential iteratee index or key argument.
   * @param {*} object The potential iteratee object argument.
   * @returns {boolean} Returns `true` if the arguments are from an iteratee call, else `false`.
   */
  function isIterateeCall(value, index, object) {
    if (!isObject(object)) {
      return false;
    }
    var type = typeof index;
    if (type == 'number') {
      var length = object.length,
          prereq = isLength(length) && isIndex(index, length);
    } else {
      prereq = type == 'string' && index in object;
    }
    if (prereq) {
      var other = object[index];
      return value === value ? (value === other) : (other !== other);
    }
    return false;
  }

  /**
   * Checks if `value` is a valid array-like length.
   *
   * **Note:** This function is based on ES `ToLength`. See the
   * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength)
   * for more details.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
   */
  function isLength(value) {
    return typeof value == 'number' && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }

  /**
   * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` if suitable for strict
   *  equality comparisons, else `false`.
   */
  function isStrictComparable(value) {
    return value === value && (value === 0 ? ((1 / value) > 0) : !isObject(value));
  }

  /**
   * Merges the function metadata of `source` into `data`.
   *
   * Merging metadata reduces the number of wrappers required to invoke a function.
   * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
   * may be applied regardless of execution order. Methods like `_.ary` and `_.rearg`
   * augment function arguments, making the order in which they are executed important,
   * preventing the merging of metadata. However, we make an exception for a safe
   * common case where curried functions have `_.ary` and or `_.rearg` applied.
   *
   * @private
   * @param {Array} data The destination metadata.
   * @param {Array} source The source metadata.
   * @returns {Array} Returns `data`.
   */
  function mergeData(data, source) {
    var bitmask = data[1],
        srcBitmask = source[1],
        newBitmask = bitmask | srcBitmask;

    var arityFlags = ARY_FLAG | REARG_FLAG,
        bindFlags = BIND_FLAG | BIND_KEY_FLAG,
        comboFlags = arityFlags | bindFlags | CURRY_BOUND_FLAG | CURRY_RIGHT_FLAG;

    var isAry = bitmask & ARY_FLAG && !(srcBitmask & ARY_FLAG),
        isRearg = bitmask & REARG_FLAG && !(srcBitmask & REARG_FLAG),
        argPos = (isRearg ? data : source)[7],
        ary = (isAry ? data : source)[8];

    var isCommon = !(bitmask >= REARG_FLAG && srcBitmask > bindFlags) &&
      !(bitmask > bindFlags && srcBitmask >= REARG_FLAG);

    var isCombo = (newBitmask >= arityFlags && newBitmask <= comboFlags) &&
      (bitmask < REARG_FLAG || ((isRearg || isAry) && argPos.length <= ary));

    // Exit early if metadata can't be merged.
    if (!(isCommon || isCombo)) {
      return data;
    }
    // Use source `thisArg` if available.
    if (srcBitmask & BIND_FLAG) {
      data[2] = source[2];
      // Set when currying a bound function.
      newBitmask |= (bitmask & BIND_FLAG) ? 0 : CURRY_BOUND_FLAG;
    }
    // Compose partial arguments.
    var value = source[3];
    if (value) {
      var partials = data[3];
      data[3] = partials ? composeArgs(partials, value, source[4]) : arrayCopy(value);
      data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : arrayCopy(source[4]);
    }
    // Compose partial right arguments.
    value = source[5];
    if (value) {
      partials = data[5];
      data[5] = partials ? composeArgsRight(partials, value, source[6]) : arrayCopy(value);
      data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : arrayCopy(source[6]);
    }
    // Use source `argPos` if available.
    value = source[7];
    if (value) {
      data[7] = arrayCopy(value);
    }
    // Use source `ary` if it's smaller.
    if (srcBitmask & ARY_FLAG) {
      data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
    }
    // Use source `arity` if one is not provided.
    if (data[9] == null) {
      data[9] = source[9];
    }
    // Use source `func` and merge bitmasks.
    data[0] = source[0];
    data[1] = newBitmask;

    return data;
  }

  /**
   * A specialized version of `_.pick` that picks `object` properties specified
   * by the `props` array.
   *
   * @private
   * @param {Object} object The source object.
   * @param {string[]} props The property names to pick.
   * @returns {Object} Returns the new object.
   */
  function pickByArray(object, props) {
    object = toObject(object);

    var index = -1,
        length = props.length,
        result = {};

    while (++index < length) {
      var key = props[index];
      if (key in object) {
        result[key] = object[key];
      }
    }
    return result;
  }

  /**
   * A specialized version of `_.pick` that picks `object` properties `predicate`
   * returns truthy for.
   *
   * @private
   * @param {Object} object The source object.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {Object} Returns the new object.
   */
  function pickByCallback(object, predicate) {
    var result = {};
    baseForIn(object, function(value, key, object) {
      if (predicate(value, key, object)) {
        result[key] = value;
      }
    });
    return result;
  }

  /**
   * Reorder `array` according to the specified indexes where the element at
   * the first index is assigned as the first element, the element at
   * the second index is assigned as the second element, and so on.
   *
   * @private
   * @param {Array} array The array to reorder.
   * @param {Array} indexes The arranged array indexes.
   * @returns {Array} Returns `array`.
   */
  function reorder(array, indexes) {
    var arrLength = array.length,
        length = nativeMin(indexes.length, arrLength),
        oldArray = arrayCopy(array);

    while (length--) {
      var index = indexes[length];
      array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
    }
    return array;
  }

  /**
   * Sets metadata for `func`.
   *
   * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
   * period of time, it will trip its breaker and transition to an identity function
   * to avoid garbage collection pauses in V8. See [V8 issue 2070](https://code.google.com/p/v8/issues/detail?id=2070)
   * for more details.
   *
   * @private
   * @param {Function} func The function to associate metadata with.
   * @param {*} data The metadata.
   * @returns {Function} Returns `func`.
   */
  var setData = (function() {
    var count = 0,
        lastCalled = 0;

    return function(key, value) {
      var stamp = now(),
          remaining = HOT_SPAN - (stamp - lastCalled);

      lastCalled = stamp;
      if (remaining > 0) {
        if (++count >= HOT_COUNT) {
          return key;
        }
      } else {
        count = 0;
      }
      return baseSetData(key, value);
    };
  }());

  /**
   * A fallback implementation of `_.isPlainObject` which checks if `value`
   * is an object created by the `Object` constructor or has a `[[Prototype]]`
   * of `null`.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
   */
  function shimIsPlainObject(value) {
    var Ctor,
        support = lodash.support;

    // Exit early for non `Object` objects.
    if (!(isObjectLike(value) && objToString.call(value) == objectTag) ||
        (!hasOwnProperty.call(value, 'constructor') &&
          (Ctor = value.constructor, typeof Ctor == 'function' && !(Ctor instanceof Ctor)))) {
      return false;
    }
    // IE < 9 iterates inherited properties before own properties. If the first
    // iterated property is an object's own property then there are no inherited
    // enumerable properties.
    var result;
    // In most environments an object's own properties are iterated before
    // its inherited properties. If the last iterated property is an object's
    // own property then there are no inherited enumerable properties.
    baseForIn(value, function(subValue, key) {
      result = key;
    });
    return typeof result == 'undefined' || hasOwnProperty.call(value, result);
  }

  /**
   * A fallback implementation of `Object.keys` which creates an array of the
   * own enumerable property names of `object`.
   *
   * @private
   * @param {Object} object The object to inspect.
   * @returns {Array} Returns the array of property names.
   */
  function shimKeys(object) {
    var props = keysIn(object),
        propsLength = props.length,
        length = propsLength && object.length,
        support = lodash.support;

    var allowIndexes = length && isLength(length) &&
      (isArray(object) || (support.nonEnumArgs && isArguments(object)));

    var index = -1,
        result = [];

    while (++index < propsLength) {
      var key = props[index];
      if ((allowIndexes && isIndex(key, length)) || hasOwnProperty.call(object, key)) {
        result.push(key);
      }
    }
    return result;
  }

  /**
   * Converts `value` to an object if it is not one.
   *
   * @private
   * @param {*} value The value to process.
   * @returns {Object} Returns the object.
   */
  function toObject(value) {
    return isObject(value) ? value : Object(value);
  }

  /*------------------------------------------------------------------------*/

  /**
   * Creates an array excluding all values of the provided arrays using
   * `SameValueZero` for equality comparisons.
   *
   * **Note:** `SameValueZero` comparisons are like strict equality comparisons,
   * e.g. `===`, except that `NaN` matches `NaN`. See the
   * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
   * for more details.
   *
   * @static
   * @memberOf _
   * @category Array
   * @param {Array} array The array to inspect.
   * @param {...Array} [values] The arrays of values to exclude.
   * @returns {Array} Returns the new array of filtered values.
   * @example
   *
   * _.difference([1, 2, 3], [4, 2]);
   * // => [1, 3]
   */
  function difference() {
    var args = arguments,
        index = -1,
        length = args.length;

    while (++index < length) {
      var value = args[index];
      if (isArray(value) || isArguments(value)) {
        break;
      }
    }
    return baseDifference(value, baseFlatten(args, false, true, ++index));
  }

  /**
   * Gets the index at which the first occurrence of `value` is found in `array`
   * using `SameValueZero` for equality comparisons. If `fromIndex` is negative,
   * it is used as the offset from the end of `array`. If `array` is sorted
   * providing `true` for `fromIndex` performs a faster binary search.
   *
   * **Note:** `SameValueZero` comparisons are like strict equality comparisons,
   * e.g. `===`, except that `NaN` matches `NaN`. See the
   * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
   * for more details.
   *
   * @static
   * @memberOf _
   * @category Array
   * @param {Array} array The array to search.
   * @param {*} value The value to search for.
   * @param {boolean|number} [fromIndex=0] The index to search from or `true`
   *  to perform a binary search on a sorted array.
   * @returns {number} Returns the index of the matched value, else `-1`.
   * @example
   *
   * _.indexOf([1, 2, 1, 2], 2);
   * // => 1
   *
   * // using `fromIndex`
   * _.indexOf([1, 2, 1, 2], 2, 2);
   * // => 3
   *
   * // performing a binary search
   * _.indexOf([1, 1, 2, 2], 2, true);
   * // => 2
   */
  function indexOf(array, value, fromIndex) {
    var length = array ? array.length : 0;
    if (!length) {
      return -1;
    }
    if (typeof fromIndex == 'number') {
      fromIndex = fromIndex < 0 ? nativeMax(length + fromIndex, 0) : fromIndex;
    } else if (fromIndex) {
      var index = binaryIndex(array, value),
          other = array[index];

      if (value === value ? (value === other) : (other !== other)) {
        return index;
      }
      return -1;
    }
    return baseIndexOf(array, value, fromIndex || 0);
  }

  /**
   * Creates an array of unique values in all provided arrays using `SameValueZero`
   * for equality comparisons.
   *
   * **Note:** `SameValueZero` comparisons are like strict equality comparisons,
   * e.g. `===`, except that `NaN` matches `NaN`. See the
   * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-samevaluezero)
   * for more details.
   *
   * @static
   * @memberOf _
   * @category Array
   * @param {...Array} [arrays] The arrays to inspect.
   * @returns {Array} Returns the new array of shared values.
   * @example
   * _.intersection([1, 2], [4, 2], [2, 1]);
   * // => [2]
   */
  function intersection() {
    var args = [],
        argsIndex = -1,
        argsLength = arguments.length,
        caches = [],
        indexOf = getIndexOf(),
        isCommon = indexOf == baseIndexOf;

    while (++argsIndex < argsLength) {
      var value = arguments[argsIndex];
      if (isArray(value) || isArguments(value)) {
        args.push(value);
        caches.push((isCommon && value.length >= 120) ? createCache(argsIndex && value) : null);
      }
    }
    argsLength = args.length;
    var array = args[0],
        index = -1,
        length = array ? array.length : 0,
        result = [],
        seen = caches[0];

    outer:
    while (++index < length) {
      value = array[index];
      if ((seen ? cacheIndexOf(seen, value) : indexOf(result, value, 0)) < 0) {
        argsIndex = argsLength;
        while (--argsIndex) {
          var cache = caches[argsIndex];
          if ((cache ? cacheIndexOf(cache, value) : indexOf(args[argsIndex], value, 0)) < 0) {
            continue outer;
          }
        }
        if (seen) {
          seen.push(value);
        }
        result.push(value);
      }
    }
    return result;
  }

  /**
   * Gets the last element of `array`.
   *
   * @static
   * @memberOf _
   * @category Array
   * @param {Array} array The array to query.
   * @returns {*} Returns the last element of `array`.
   * @example
   *
   * _.last([1, 2, 3]);
   * // => 3
   */
  function last(array) {
    var length = array ? array.length : 0;
    return length ? array[length - 1] : undefined;
  }

  /*------------------------------------------------------------------------*/

  /**
   * Checks if `predicate` returns truthy for **all** elements of `collection`.
   * The predicate is bound to `thisArg` and invoked with three arguments;
   * (value, index|key, collection).
   *
   * If a property name is provided for `predicate` the created `_.property`
   * style callback returns the property value of the given element.
   *
   * If a value is also provided for `thisArg` the created `_.matchesProperty`
   * style callback returns `true` for elements that have a matching property
   * value, else `false`.
   *
   * If an object is provided for `predicate` the created `_.matches` style
   * callback returns `true` for elements that have the properties of the given
   * object, else `false`.
   *
   * @static
   * @memberOf _
   * @alias all
   * @category Collection
   * @param {Array|Object|string} collection The collection to iterate over.
   * @param {Function|Object|string} [predicate=_.identity] The function invoked
   *  per iteration.
   * @param {*} [thisArg] The `this` binding of `predicate`.
   * @returns {boolean} Returns `true` if all elements pass the predicate check,
   *  else `false`.
   * @example
   *
   * _.every([true, 1, null, 'yes'], Boolean);
   * // => false
   *
   * var users = [
   *   { 'user': 'barney', 'active': false },
   *   { 'user': 'fred',   'active': false }
   * ];
   *
   * // using the `_.matches` callback shorthand
   * _.every(users, { 'user': 'barney', 'active': false });
   * // => false
   *
   * // using the `_.matchesProperty` callback shorthand
   * _.every(users, 'active', false);
   * // => true
   *
   * // using the `_.property` callback shorthand
   * _.every(users, 'active');
   * // => false
   */
  function every(collection, predicate, thisArg) {
    var func = isArray(collection) ? arrayEvery : baseEvery;
    if (typeof predicate != 'function' || typeof thisArg != 'undefined') {
      predicate = getCallback(predicate, thisArg, 3);
    }
    return func(collection, predicate);
  }

  /**
   * Iterates over elements of `collection` invoking `iteratee` for each element.
   * The `iteratee` is bound to `thisArg` and invoked with three arguments;
   * (value, index|key, collection). Iterator functions may exit iteration early
   * by explicitly returning `false`.
   *
   * **Note:** As with other "Collections" methods, objects with a `length` property
   * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`
   * may be used for object iteration.
   *
   * @static
   * @memberOf _
   * @alias each
   * @category Collection
   * @param {Array|Object|string} collection The collection to iterate over.
   * @param {Function} [iteratee=_.identity] The function invoked per iteration.
   * @param {*} [thisArg] The `this` binding of `iteratee`.
   * @returns {Array|Object|string} Returns `collection`.
   * @example
   *
   * _([1, 2]).forEach(function(n) {
   *   console.log(n);
   * }).value();
   * // => logs each value from left to right and returns the array
   *
   * _.forEach({ 'a': 1, 'b': 2 }, function(n, key) {
   *   console.log(n, key);
   * });
   * // => logs each value-key pair and returns the object (iteration order is not guaranteed)
   */
  function forEach(collection, iteratee, thisArg) {
    return (typeof iteratee == 'function' && typeof thisArg == 'undefined' && isArray(collection))
      ? arrayEach(collection, iteratee)
      : baseEach(collection, bindCallback(iteratee, thisArg, 3));
  }

  /**
   * Invokes the method named by `methodName` on each element in `collection`,
   * returning an array of the results of each invoked method. Any additional
   * arguments are provided to each invoked method. If `methodName` is a function
   * it is invoked for, and `this` bound to, each element in `collection`.
   *
   * @static
   * @memberOf _
   * @category Collection
   * @param {Array|Object|string} collection The collection to iterate over.
   * @param {Function|string} methodName The name of the method to invoke or
   *  the function invoked per iteration.
   * @param {...*} [args] The arguments to invoke the method with.
   * @returns {Array} Returns the array of results.
   * @example
   *
   * _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');
   * // => [[1, 5, 7], [1, 2, 3]]
   *
   * _.invoke([123, 456], String.prototype.split, '');
   * // => [['1', '2', '3'], ['4', '5', '6']]
   */
  function invoke(collection, methodName) {
    return baseInvoke(collection, methodName, baseSlice(arguments, 2));
  }

  /**
   * Creates an array of values by running each element in `collection` through
   * `iteratee`. The `iteratee` is bound to `thisArg` and invoked with three
   * arguments; (value, index|key, collection).
   *
   * If a property name is provided for `predicate` the created `_.property`
   * style callback returns the property value of the given element.
   *
   * If a value is also provided for `thisArg` the created `_.matchesProperty`
   * style callback returns `true` for elements that have a matching property
   * value, else `false`.
   *
   * If an object is provided for `predicate` the created `_.matches` style
   * callback returns `true` for elements that have the properties of the given
   * object, else `false`.
   *
   * Many lodash methods are guarded to work as interatees for methods like
   * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
   *
   * The guarded methods are:
   * `ary`, `callback`, `chunk`, `clone`, `create`, `curry`, `curryRight`, `drop`,
   * `dropRight`, `fill`, `flatten`, `invert`, `max`, `min`, `parseInt`, `slice`,
   * `sortBy`, `take`, `takeRight`, `template`, `trim`, `trimLeft`, `trimRight`,
   * `trunc`, `random`, `range`, `sample`, `uniq`, and `words`
   *
   * @static
   * @memberOf _
   * @alias collect
   * @category Collection
   * @param {Array|Object|string} collection The collection to iterate over.
   * @param {Function|Object|string} [iteratee=_.identity] The function invoked
   *  per iteration.
   *  create a `_.property` or `_.matches` style callback respectively.
   * @param {*} [thisArg] The `this` binding of `iteratee`.
   * @returns {Array} Returns the new mapped array.
   * @example
   *
   * function timesThree(n) {
   *   return n * 3;
   * }
   *
   * _.map([1, 2], timesThree);
   * // => [3, 6]
   *
   * _.map({ 'a': 1, 'b': 2 }, timesThree);
   * // => [3, 6] (iteration order is not guaranteed)
   *
   * var users = [
   *   { 'user': 'barney' },
   *   { 'user': 'fred' }
   * ];
   *
   * // using the `_.property` callback shorthand
   * _.map(users, 'user');
   * // => ['barney', 'fred']
   */
  function map(collection, iteratee, thisArg) {
    var func = isArray(collection) ? arrayMap : baseMap;
    iteratee = getCallback(iteratee, thisArg, 3);
    return func(collection, iteratee);
  }

  /**
   * Reduces `collection` to a value which is the accumulated result of running
   * each element in `collection` through `iteratee`, where each successive
   * invocation is supplied the return value of the previous. If `accumulator`
   * is not provided the first element of `collection` is used as the initial
   * value. The `iteratee` is bound to `thisArg`and invoked with four arguments;
   * (accumulator, value, index|key, collection).
   *
   * Many lodash methods are guarded to work as interatees for methods like
   * `_.reduce`, `_.reduceRight`, and `_.transform`.
   *
   * The guarded methods are:
   * `assign`, `defaults`, `merge`, and `sortAllBy`
   *
   * @static
   * @memberOf _
   * @alias foldl, inject
   * @category Collection
   * @param {Array|Object|string} collection The collection to iterate over.
   * @param {Function} [iteratee=_.identity] The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {*} [thisArg] The `this` binding of `iteratee`.
   * @returns {*} Returns the accumulated value.
   * @example
   *
   * _.reduce([1, 2], function(sum, n) {
   *   return sum + n;
   * });
   * // => 3
   *
   * _.reduce({ 'a': 1, 'b': 2 }, function(result, n, key) {
   *   result[key] = n * 3;
   *   return result;
   * }, {});
   * // => { 'a': 3, 'b': 6 } (iteration order is not guaranteed)
   */
  function reduce(collection, iteratee, accumulator, thisArg) {
    var func = isArray(collection) ? arrayReduce : baseReduce;
    return func(collection, getCallback(iteratee, thisArg, 4), accumulator, arguments.length < 3, baseEach);
  }

  /*------------------------------------------------------------------------*/

  /**
   * Gets the number of milliseconds that have elapsed since the Unix epoch
   * (1 January 1970 00:00:00 UTC).
   *
   * @static
   * @memberOf _
   * @category Date
   * @example
   *
   * _.defer(function(stamp) {
   *   console.log(_.now() - stamp);
   * }, _.now());
   * // => logs the number of milliseconds it took for the deferred function to be invoked
   */
  var now = nativeNow || function() {
    return new Date().getTime();
  };

  /*------------------------------------------------------------------------*/

  /**
   * Creates a function that invokes `func` with the `this` binding of `thisArg`
   * and prepends any additional `_.bind` arguments to those provided to the
   * bound function.
   *
   * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
   * may be used as a placeholder for partially applied arguments.
   *
   * **Note:** Unlike native `Function#bind` this method does not set the `length`
   * property of bound functions.
   *
   * @static
   * @memberOf _
   * @category Function
   * @param {Function} func The function to bind.
   * @param {*} thisArg The `this` binding of `func`.
   * @param {...*} [args] The arguments to be partially applied.
   * @returns {Function} Returns the new bound function.
   * @example
   *
   * var greet = function(greeting, punctuation) {
   *   return greeting + ' ' + this.user + punctuation;
   * };
   *
   * var object = { 'user': 'fred' };
   *
   * var bound = _.bind(greet, object, 'hi');
   * bound('!');
   * // => 'hi fred!'
   *
   * // using placeholders
   * var bound = _.bind(greet, object, _, '!');
   * bound('hi');
   * // => 'hi fred!'
   */
  function bind(func, thisArg) {
    var bitmask = BIND_FLAG;
    if (arguments.length > 2) {
      var partials = baseSlice(arguments, 2),
          holders = replaceHolders(partials, bind.placeholder);

      bitmask |= PARTIAL_FLAG;
    }
    return createWrapper(func, bitmask, thisArg, partials, holders);
  }

  /**
   * Defers invoking the `func` until the current call stack has cleared. Any
   * additional arguments are provided to `func` when it is invoked.
   *
   * @static
   * @memberOf _
   * @category Function
   * @param {Function} func The function to defer.
   * @param {...*} [args] The arguments to invoke the function with.
   * @returns {number} Returns the timer id.
   * @example
   *
   * _.defer(function(text) {
   *   console.log(text);
   * }, 'deferred');
   * // logs 'deferred' after one or more milliseconds
   */
  function defer(func) {
    return baseDelay(func, 1, arguments, 1);
  }

  /**
   * Creates a function that invokes `func` with `partial` arguments prepended
   * to those provided to the new function. This method is like `_.bind` except
   * it does **not** alter the `this` binding.
   *
   * The `_.partial.placeholder` value, which defaults to `_` in monolithic
   * builds, may be used as a placeholder for partially applied arguments.
   *
   * **Note:** This method does not set the `length` property of partially
   * applied functions.
   *
   * @static
   * @memberOf _
   * @category Function
   * @param {Function} func The function to partially apply arguments to.
   * @param {...*} [args] The arguments to be partially applied.
   * @returns {Function} Returns the new partially applied function.
   * @example
   *
   * var greet = function(greeting, name) {
   *   return greeting + ' ' + name;
   * };
   *
   * var sayHelloTo = _.partial(greet, 'hello');
   * sayHelloTo('fred');
   * // => 'hello fred'
   *
   * // using placeholders
   * var greetFred = _.partial(greet, _, 'fred');
   * greetFred('hi');
   * // => 'hi fred'
   */
  function partial(func) {
    var partials = baseSlice(arguments, 1),
        holders = replaceHolders(partials, partial.placeholder);

    return createWrapper(func, PARTIAL_FLAG, null, partials, holders);
  }

  /*------------------------------------------------------------------------*/

  /**
   * Creates a clone of `value`. If `isDeep` is `true` nested objects are cloned,
   * otherwise they are assigned by reference. If `customizer` is provided it is
   * invoked to produce the cloned values. If `customizer` returns `undefined`
   * cloning is handled by the method instead. The `customizer` is bound to
   * `thisArg` and invoked with two argument; (value [, index|key, object]).
   *
   * **Note:** This method is loosely based on the structured clone algorithm.
   * The enumerable properties of `arguments` objects and objects created by
   * constructors other than `Object` are cloned to plain `Object` objects. An
   * empty object is returned for uncloneable values such as functions, DOM nodes,
   * Maps, Sets, and WeakMaps. See the [HTML5 specification](http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm)
   * for more details.
   *
   * @static
   * @memberOf _
   * @category Lang
   * @param {*} value The value to clone.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @param {Function} [customizer] The function to customize cloning values.
   * @param {*} [thisArg] The `this` binding of `customizer`.
   * @returns {*} Returns the cloned value.
   * @example
   *
   * var users = [
   *   { 'user': 'barney' },
   *   { 'user': 'fred' }
   * ];
   *
   * var shallow = _.clone(users);
   * shallow[0] === users[0];
   * // => true
   *
   * var deep = _.clone(users, true);
   * deep[0] === users[0];
   * // => false
   *
   * // using a customizer callback
   * var el = _.clone(document.body, function(value) {
   *   if (_.isElement(value)) {
   *     return value.cloneNode(false);
   *   }
   * });
   *
   * el === document.body
   * // => false
   * el.nodeName
   * // => BODY
   * el.childNodes.length;
   * // => 0
   */
  function clone(value, isDeep, customizer, thisArg) {
    if (isDeep && typeof isDeep != 'boolean' && isIterateeCall(value, isDeep, customizer)) {
      isDeep = false;
    }
    else if (typeof isDeep == 'function') {
      thisArg = customizer;
      customizer = isDeep;
      isDeep = false;
    }
    customizer = typeof customizer == 'function' && bindCallback(customizer, thisArg, 1);
    return baseClone(value, isDeep, customizer);
  }

  /**
   * Checks if `value` is classified as an `arguments` object.
   *
   * @static
   * @memberOf _
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
   * @example
   *
   * _.isArguments(function() { return arguments; }());
   * // => true
   *
   * _.isArguments([1, 2, 3]);
   * // => false
   */
  function isArguments(value) {
    var length = isObjectLike(value) ? value.length : undefined;
    return (isLength(length) && objToString.call(value) == argsTag) || false;
  }

  /**
   * Checks if `value` is classified as an `Array` object.
   *
   * @static
   * @memberOf _
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
   * @example
   *
   * _.isArray([1, 2, 3]);
   * // => true
   *
   * _.isArray(function() { return arguments; }());
   * // => false
   */
  var isArray = nativeIsArray || function(value) {
    return (isObjectLike(value) && isLength(value.length) && objToString.call(value) == arrayTag) || false;
  };

  /**
   * Checks if `value` is a DOM element.
   *
   * @static
   * @memberOf _
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
   * @example
   *
   * _.isElement(document.body);
   * // => true
   *
   * _.isElement('<body>');
   * // => false
   */
  function isElement(value) {
    return (value && value.nodeType === 1 && isObjectLike(value) &&
      (objToString.call(value).indexOf('Element') > -1)) || false;
  }
  // Fallback for environments without DOM support.
  if (!support.dom) {
    isElement = function(value) {
      return (value && value.nodeType === 1 && isObjectLike(value) && !isPlainObject(value)) || false;
    };
  }

  /**
   * Performs a deep comparison between two values to determine if they are
   * equivalent. If `customizer` is provided it is invoked to compare values.
   * If `customizer` returns `undefined` comparisons are handled by the method
   * instead. The `customizer` is bound to `thisArg` and invoked with three
   * arguments; (value, other [, index|key]).
   *
   * **Note:** This method supports comparing arrays, booleans, `Date` objects,
   * numbers, `Object` objects, regexes, and strings. Objects are compared by
   * their own, not inherited, enumerable properties. Functions and DOM nodes
   * are **not** supported. Provide a customizer function to extend support
   * for comparing other values.
   *
   * @static
   * @memberOf _
   * @category Lang
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @param {Function} [customizer] The function to customize comparing values.
   * @param {*} [thisArg] The `this` binding of `customizer`.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   * @example
   *
   * var object = { 'user': 'fred' };
   * var other = { 'user': 'fred' };
   *
   * object == other;
   * // => false
   *
   * _.isEqual(object, other);
   * // => true
   *
   * // using a customizer callback
   * var array = ['hello', 'goodbye'];
   * var other = ['hi', 'goodbye'];
   *
   * _.isEqual(array, other, function(value, other) {
   *   if (_.every([value, other], RegExp.prototype.test, /^h(?:i|ello)$/)) {
   *     return true;
   *   }
   * });
   * // => true
   */
  function isEqual(value, other, customizer, thisArg) {
    customizer = typeof customizer == 'function' && bindCallback(customizer, thisArg, 3);
    if (!customizer && isStrictComparable(value) && isStrictComparable(other)) {
      return value === other;
    }
    var result = customizer ? customizer(value, other) : undefined;
    return typeof result == 'undefined' ? baseIsEqual(value, other, customizer) : !!result;
  }

  /**
   * Checks if `value` is classified as a `Function` object.
   *
   * @static
   * @memberOf _
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
   * @example
   *
   * _.isFunction(_);
   * // => true
   *
   * _.isFunction(/abc/);
   * // => false
   */
  var isFunction = !(baseIsFunction(/x/) || (Uint8Array && !baseIsFunction(Uint8Array))) ? baseIsFunction : function(value) {
    // The use of `Object#toString` avoids issues with the `typeof` operator
    // in older versions of Chrome and Safari which return 'function' for regexes
    // and Safari 8 equivalents which return 'object' for typed array constructors.
    return objToString.call(value) == funcTag;
  };

  /**
   * Checks if `value` is the language type of `Object`.
   * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
   *
   * **Note:** See the [ES5 spec](https://es5.github.io/#x8) for more details.
   *
   * @static
   * @memberOf _
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an object, else `false`.
   * @example
   *
   * _.isObject({});
   * // => true
   *
   * _.isObject([1, 2, 3]);
   * // => true
   *
   * _.isObject(1);
   * // => false
   */
  function isObject(value) {
    // Avoid a V8 JIT bug in Chrome 19-20.
    // See https://code.google.com/p/v8/issues/detail?id=2291 for more details.
    var type = typeof value;
    return type == 'function' || (value && type == 'object') || false;
  }

  /**
   * Checks if `value` is a native function.
   *
   * @static
   * @memberOf _
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a native function, else `false`.
   * @example
   *
   * _.isNative(Array.prototype.push);
   * // => true
   *
   * _.isNative(_);
   * // => false
   */
  function isNative(value) {
    if (value == null) {
      return false;
    }
    if (objToString.call(value) == funcTag) {
      return reNative.test(fnToString.call(value));
    }
    return (isObjectLike(value) && reHostCtor.test(value)) || false;
  }

  /**
   * Checks if `value` is classified as a `Number` primitive or object.
   *
   * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are classified
   * as numbers, use the `_.isFinite` method.
   *
   * @static
   * @memberOf _
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
   * @example
   *
   * _.isNumber(8.4);
   * // => true
   *
   * _.isNumber(NaN);
   * // => true
   *
   * _.isNumber('8.4');
   * // => false
   */
  function isNumber(value) {
    return typeof value == 'number' || (isObjectLike(value) && objToString.call(value) == numberTag) || false;
  }

  /**
   * Checks if `value` is a plain object, that is, an object created by the
   * `Object` constructor or one with a `[[Prototype]]` of `null`.
   *
   * **Note:** This method assumes objects created by the `Object` constructor
   * have no inherited enumerable properties.
   *
   * @static
   * @memberOf _
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   * }
   *
   * _.isPlainObject(new Foo);
   * // => false
   *
   * _.isPlainObject([1, 2, 3]);
   * // => false
   *
   * _.isPlainObject({ 'x': 0, 'y': 0 });
   * // => true
   *
   * _.isPlainObject(Object.create(null));
   * // => true
   */
  var isPlainObject = !getPrototypeOf ? shimIsPlainObject : function(value) {
    if (!(value && objToString.call(value) == objectTag)) {
      return false;
    }
    var valueOf = value.valueOf,
        objProto = isNative(valueOf) && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);

    return objProto
      ? (value == objProto || getPrototypeOf(value) == objProto)
      : shimIsPlainObject(value);
  };

  /**
   * Checks if `value` is classified as a `String` primitive or object.
   *
   * @static
   * @memberOf _
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
   * @example
   *
   * _.isString('abc');
   * // => true
   *
   * _.isString(1);
   * // => false
   */
  function isString(value) {
    return typeof value == 'string' || (isObjectLike(value) && objToString.call(value) == stringTag) || false;
  }

  /**
   * Checks if `value` is classified as a typed array.
   *
   * @static
   * @memberOf _
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
   * @example
   *
   * _.isTypedArray(new Uint8Array);
   * // => true
   *
   * _.isTypedArray([]);
   * // => false
   */
  function isTypedArray(value) {
    return (isObjectLike(value) && isLength(value.length) && typedArrayTags[objToString.call(value)]) || false;
  }

  /*------------------------------------------------------------------------*/

  /**
   * Assigns own enumerable properties of source object(s) to the destination
   * object. Subsequent sources overwrite property assignments of previous sources.
   * If `customizer` is provided it is invoked to produce the assigned values.
   * The `customizer` is bound to `thisArg` and invoked with five arguments;
   * (objectValue, sourceValue, key, object, source).
   *
   * @static
   * @memberOf _
   * @alias extend
   * @category Object
   * @param {Object} object The destination object.
   * @param {...Object} [sources] The source objects.
   * @param {Function} [customizer] The function to customize assigning values.
   * @param {*} [thisArg] The `this` binding of `customizer`.
   * @returns {Object} Returns `object`.
   * @example
   *
   * _.assign({ 'user': 'barney' }, { 'age': 40 }, { 'user': 'fred' });
   * // => { 'user': 'fred', 'age': 40 }
   *
   * // using a customizer callback
   * var defaults = _.partialRight(_.assign, function(value, other) {
   *   return typeof value == 'undefined' ? other : value;
   * });
   *
   * defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
   * // => { 'user': 'barney', 'age': 36 }
   */
  var assign = createAssigner(baseAssign);

  /**
   * Assigns own enumerable properties of source object(s) to the destination
   * object for all destination properties that resolve to `undefined`. Once a
   * property is set, additional values of the same property are ignored.
   *
   * @static
   * @memberOf _
   * @category Object
   * @param {Object} object The destination object.
   * @param {...Object} [sources] The source objects.
   * @returns {Object} Returns `object`.
   * @example
   *
   * _.defaults({ 'user': 'barney' }, { 'age': 36 }, { 'user': 'fred' });
   * // => { 'user': 'barney', 'age': 36 }
   */
  function defaults(object) {
    if (object == null) {
      return object;
    }
    var args = arrayCopy(arguments);
    args.push(assignDefaults);
    return assign.apply(undefined, args);
  }

  /**
   * Creates an array of the own enumerable property names of `object`.
   *
   * **Note:** Non-object values are coerced to objects. See the
   * [ES spec](https://people.mozilla.org/~jorendorff/es6-draft.html#sec-object.keys)
   * for more details.
   *
   * @static
   * @memberOf _
   * @category Object
   * @param {Object} object The object to inspect.
   * @returns {Array} Returns the array of property names.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.keys(new Foo);
   * // => ['a', 'b'] (iteration order is not guaranteed)
   *
   * _.keys('hi');
   * // => ['0', '1']
   */
  var keys = !nativeKeys ? shimKeys : function(object) {
    if (object) {
      var Ctor = object.constructor,
          length = object.length;
    }
    if ((typeof Ctor == 'function' && Ctor.prototype === object) ||
        (typeof object != 'function' && (length && isLength(length)))) {
      return shimKeys(object);
    }
    return isObject(object) ? nativeKeys(object) : [];
  };

  /**
   * Creates an array of the own and inherited enumerable property names of `object`.
   *
   * **Note:** Non-object values are coerced to objects.
   *
   * @static
   * @memberOf _
   * @category Object
   * @param {Object} object The object to inspect.
   * @returns {Array} Returns the array of property names.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.keysIn(new Foo);
   * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
   */
  function keysIn(object) {
    if (object == null) {
      return [];
    }
    if (!isObject(object)) {
      object = Object(object);
    }
    var length = object.length;
    length = (length && isLength(length) &&
      (isArray(object) || (support.nonEnumArgs && isArguments(object))) && length) || 0;

    var Ctor = object.constructor,
        index = -1,
        isProto = typeof Ctor == 'function' && Ctor.prototype === object,
        result = Array(length),
        skipIndexes = length > 0;

    while (++index < length) {
      result[index] = (index + '');
    }
    for (var key in object) {
      if (!(skipIndexes && isIndex(key, length)) &&
          !(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
        result.push(key);
      }
    }
    return result;
  }

  /**
   * The opposite of `_.pick`; this method creates an object composed of the
   * own and inherited enumerable properties of `object` that are not omitted.
   * Property names may be specified as individual arguments or as arrays of
   * property names. If `predicate` is provided it is invoked for each property
   * of `object` omitting the properties `predicate` returns truthy for. The
   * predicate is bound to `thisArg` and invoked with three arguments;
   * (value, key, object).
   *
   * @static
   * @memberOf _
   * @category Object
   * @param {Object} object The source object.
   * @param {Function|...(string|string[])} [predicate] The function invoked per
   *  iteration or property names to omit, specified as individual property
   *  names or arrays of property names.
   * @param {*} [thisArg] The `this` binding of `predicate`.
   * @returns {Object} Returns the new object.
   * @example
   *
   * var object = { 'user': 'fred', 'age': 40 };
   *
   * _.omit(object, 'age');
   * // => { 'user': 'fred' }
   *
   * _.omit(object, _.isNumber);
   * // => { 'user': 'fred' }
   */
  function omit(object, predicate, thisArg) {
    if (object == null) {
      return {};
    }
    if (typeof predicate != 'function') {
      var props = arrayMap(baseFlatten(arguments, false, false, 1), String);
      return pickByArray(object, baseDifference(keysIn(object), props));
    }
    predicate = bindCallback(predicate, thisArg, 3);
    return pickByCallback(object, function(value, key, object) {
      return !predicate(value, key, object);
    });
  }

  /**
   * Creates an array of the own enumerable property values of `object`.
   *
   * **Note:** Non-object values are coerced to objects.
   *
   * @static
   * @memberOf _
   * @category Object
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property values.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.values(new Foo);
   * // => [1, 2] (iteration order is not guaranteed)
   *
   * _.values('hi');
   * // => ['h', 'i']
   */
  function values(object) {
    return baseValues(object, keys(object));
  }

  /*------------------------------------------------------------------------*/

  /**
   * Escapes the `RegExp` special characters "\", "^", "$", ".", "|", "?", "*",
   * "+", "(", ")", "[", "]", "{" and "}" in `string`.
   *
   * @static
   * @memberOf _
   * @category String
   * @param {string} [string=''] The string to escape.
   * @returns {string} Returns the escaped string.
   * @example
   *
   * _.escapeRegExp('[lodash](https://lodash.com/)');
   * // => '\[lodash\]\(https://lodash\.com/\)'
   */
  function escapeRegExp(string) {
    string = baseToString(string);
    return (string && reHasRegExpChars.test(string))
      ? string.replace(reRegExpChars, '\\$&')
      : string;
  }

  /*------------------------------------------------------------------------*/

  /**
   * Creates a function that invokes `func` with the `this` binding of `thisArg`
   * and arguments of the created function. If `func` is a property name the
   * created callback returns the property value for a given element. If `func`
   * is an object the created callback returns `true` for elements that contain
   * the equivalent object properties, otherwise it returns `false`.
   *
   * @static
   * @memberOf _
   * @alias iteratee
   * @category Utility
   * @param {*} [func=_.identity] The value to convert to a callback.
   * @param {*} [thisArg] The `this` binding of `func`.
   * @param- {Object} [guard] Enables use as a callback for functions like `_.map`.
   * @returns {Function} Returns the callback.
   * @example
   *
   * var users = [
   *   { 'user': 'barney', 'age': 36 },
   *   { 'user': 'fred',   'age': 40 }
   * ];
   *
   * // wrap to create custom callback shorthands
   * _.callback = _.wrap(_.callback, function(callback, func, thisArg) {
   *   var match = /^(.+?)__([gl]t)(.+)$/.exec(func);
   *   if (!match) {
   *     return callback(func, thisArg);
   *   }
   *   return function(object) {
   *     return match[2] == 'gt'
   *       ? object[match[1]] > match[3]
   *       : object[match[1]] < match[3];
   *   };
   * });
   *
   * _.filter(users, 'age__gt36');
   * // => [{ 'user': 'fred', 'age': 40 }]
   */
  function callback(func, thisArg, guard) {
    if (guard && isIterateeCall(func, thisArg, guard)) {
      thisArg = null;
    }
    return isObjectLike(func)
      ? matches(func)
      : baseCallback(func, thisArg);
  }

  /**
   * Creates a function that returns `value`.
   *
   * @static
   * @memberOf _
   * @category Utility
   * @param {*} value The value to return from the new function.
   * @returns {Function} Returns the new function.
   * @example
   *
   * var object = { 'user': 'fred' };
   * var getter = _.constant(object);
   *
   * getter() === object;
   * // => true
   */
  function constant(value) {
    return function() {
      return value;
    };
  }

  /**
   * This method returns the first argument provided to it.
   *
   * @static
   * @memberOf _
   * @category Utility
   * @param {*} value Any value.
   * @returns {*} Returns `value`.
   * @example
   *
   * var object = { 'user': 'fred' };
   *
   * _.identity(object) === object;
   * // => true
   */
  function identity(value) {
    return value;
  }

  /**
   * Creates a function which performs a deep comparison between a given object
   * and `source`, returning `true` if the given object has equivalent property
   * values, else `false`.
   *
   * **Note:** This method supports comparing arrays, booleans, `Date` objects,
   * numbers, `Object` objects, regexes, and strings. Objects are compared by
   * their own, not inherited, enumerable properties. For comparing a single
   * own or inherited property value see `_.matchesProperty`.
   *
   * @static
   * @memberOf _
   * @category Utility
   * @param {Object} source The object of property values to match.
   * @returns {Function} Returns the new function.
   * @example
   *
   * var users = [
   *   { 'user': 'barney', 'age': 36, 'active': true },
   *   { 'user': 'fred',   'age': 40, 'active': false }
   * ];
   *
   * _.filter(users, _.matches({ 'age': 40, 'active': false }));
   * // => [{ 'user': 'fred', 'age': 40, 'active': false }]
   */
  function matches(source) {
    return baseMatches(baseClone(source, true));
  }

  /**
   * A no-operation function which returns `undefined` regardless of the
   * arguments it receives.
   *
   * @static
   * @memberOf _
   * @category Utility
   * @example
   *
   * var object = { 'user': 'fred' };
   *
   * _.noop(object) === undefined;
   * // => true
   */
  function noop() {
    // No operation performed.
  }

  /**
   * Generates a unique ID. If `prefix` is provided the ID is appended to it.
   *
   * @static
   * @memberOf _
   * @category Utility
   * @param {string} [prefix] The value to prefix the ID with.
   * @returns {string} Returns the unique ID.
   * @example
   *
   * _.uniqueId('contact_');
   * // => 'contact_104'
   *
   * _.uniqueId();
   * // => '105'
   */
  function uniqueId(prefix) {
    var id = ++idCounter;
    return baseToString(prefix) + id;
  }

  /*------------------------------------------------------------------------*/

  // Add functions to the `Set` cache.
  SetCache.prototype.push = cachePush;

  // Add functions that return wrapped values when chaining.
  lodash.assign = assign;
  lodash.bind = bind;
  lodash.callback = callback;
  lodash.constant = constant;
  lodash.defaults = defaults;
  lodash.defer = defer;
  lodash.difference = difference;
  lodash.forEach = forEach;
  lodash.intersection = intersection;
  lodash.invoke = invoke;
  lodash.keys = keys;
  lodash.keysIn = keysIn;
  lodash.map = map;
  lodash.matches = matches;
  lodash.omit = omit;
  lodash.partial = partial;
  lodash.values = values;

  // Add aliases.
  lodash.collect = map;
  lodash.each = forEach;
  lodash.extend = assign;
  lodash.iteratee = callback;

  /*------------------------------------------------------------------------*/

  // Add functions that return unwrapped values when chaining.
  lodash.clone = clone;
  lodash.escapeRegExp = escapeRegExp;
  lodash.every = every;
  lodash.identity = identity;
  lodash.indexOf = indexOf;
  lodash.isArguments = isArguments;
  lodash.isArray = isArray;
  lodash.isElement = isElement;
  lodash.isEqual = isEqual;
  lodash.isFunction = isFunction;
  lodash.isNative = isNative;
  lodash.isNumber = isNumber;
  lodash.isObject = isObject;
  lodash.isPlainObject = isPlainObject;
  lodash.isString = isString;
  lodash.isTypedArray = isTypedArray;
  lodash.last = last;
  lodash.noop = noop;
  lodash.now = now;
  lodash.reduce = reduce;
  lodash.uniqueId = uniqueId;

  // Add aliases.
  lodash.all = every;
  lodash.foldl = reduce;
  lodash.inject = reduce;

  /*------------------------------------------------------------------------*/

  /**
   * The semantic version number.
   *
   * @static
   * @memberOf _
   * @type string
   */
  lodash.VERSION = VERSION;

  // Assign default placeholders.
  arrayEach(['bind', 'partial'], function(methodName) {
    lodash[methodName].placeholder = lodash;
  });

  /*--------------------------------------------------------------------------*/

  // Some AMD build optimizers like r.js check for condition patterns like the following:
  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
    // Expose lodash to the global object when an AMD loader is present to avoid
    // errors in cases where lodash is loaded by a script tag and not intended
    // as an AMD module. See http://requirejs.org/docs/errors.html#mismatch for
    // more details.
    root._ = lodash;

    // Define as an anonymous module so, through path mapping, it can be
    // referenced as the "underscore" module.
    define(function() {
      return lodash;
    });
  }
  // Check for `exports` after `define` in case a build optimizer adds an `exports` object.
  else if (freeExports && freeModule) {
    // Export for Node.js or RingoJS.
    if (moduleExports) {
      (freeModule.exports = lodash)._ = lodash;
    }
    // Export for Narwhal or Rhino -require.
    else {
      freeExports._ = lodash;
    }
  }
  else {
    // Export for a browser or Rhino.
    root._ = lodash;
  }
}.call(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],2:[function(_dereq_,module,exports){
/*!
 * EventEmitter2
 * https://github.com/hij1nx/EventEmitter2
 *
 * Copyright (c) 2013 hij1nx
 * Licensed under the MIT license.
 */
;!function(undefined) {

  var isArray = Array.isArray ? Array.isArray : function _isArray(obj) {
    return Object.prototype.toString.call(obj) === "[object Array]";
  };
  var defaultMaxListeners = 10;

  function init() {
    this._events = {};
    if (this._conf) {
      configure.call(this, this._conf);
    }
  }

  function configure(conf) {
    if (conf) {

      this._conf = conf;

      conf.delimiter && (this.delimiter = conf.delimiter);
      conf.maxListeners && (this._events.maxListeners = conf.maxListeners);
      conf.wildcard && (this.wildcard = conf.wildcard);
      conf.newListener && (this.newListener = conf.newListener);

      if (this.wildcard) {
        this.listenerTree = {};
      }
    }
  }

  function EventEmitter(conf) {
    this._events = {};
    this.newListener = false;
    configure.call(this, conf);
  }

  //
  // Attention, function return type now is array, always !
  // It has zero elements if no any matches found and one or more
  // elements (leafs) if there are matches
  //
  function searchListenerTree(handlers, type, tree, i) {
    if (!tree) {
      return [];
    }
    var listeners=[], leaf, len, branch, xTree, xxTree, isolatedBranch, endReached,
        typeLength = type.length, currentType = type[i], nextType = type[i+1];
    if (i === typeLength && tree._listeners) {
      //
      // If at the end of the event(s) list and the tree has listeners
      // invoke those listeners.
      //
      if (typeof tree._listeners === 'function') {
        handlers && handlers.push(tree._listeners);
        return [tree];
      } else {
        for (leaf = 0, len = tree._listeners.length; leaf < len; leaf++) {
          handlers && handlers.push(tree._listeners[leaf]);
        }
        return [tree];
      }
    }

    if ((currentType === '*' || currentType === '**') || tree[currentType]) {
      //
      // If the event emitted is '*' at this part
      // or there is a concrete match at this patch
      //
      if (currentType === '*') {
        for (branch in tree) {
          if (branch !== '_listeners' && tree.hasOwnProperty(branch)) {
            listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i+1));
          }
        }
        return listeners;
      } else if(currentType === '**') {
        endReached = (i+1 === typeLength || (i+2 === typeLength && nextType === '*'));
        if(endReached && tree._listeners) {
          // The next element has a _listeners, add it to the handlers.
          listeners = listeners.concat(searchListenerTree(handlers, type, tree, typeLength));
        }

        for (branch in tree) {
          if (branch !== '_listeners' && tree.hasOwnProperty(branch)) {
            if(branch === '*' || branch === '**') {
              if(tree[branch]._listeners && !endReached) {
                listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], typeLength));
              }
              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i));
            } else if(branch === nextType) {
              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i+2));
            } else {
              // No match on this one, shift into the tree but not in the type array.
              listeners = listeners.concat(searchListenerTree(handlers, type, tree[branch], i));
            }
          }
        }
        return listeners;
      }

      listeners = listeners.concat(searchListenerTree(handlers, type, tree[currentType], i+1));
    }

    xTree = tree['*'];
    if (xTree) {
      //
      // If the listener tree will allow any match for this part,
      // then recursively explore all branches of the tree
      //
      searchListenerTree(handlers, type, xTree, i+1);
    }

    xxTree = tree['**'];
    if(xxTree) {
      if(i < typeLength) {
        if(xxTree._listeners) {
          // If we have a listener on a '**', it will catch all, so add its handler.
          searchListenerTree(handlers, type, xxTree, typeLength);
        }

        // Build arrays of matching next branches and others.
        for(branch in xxTree) {
          if(branch !== '_listeners' && xxTree.hasOwnProperty(branch)) {
            if(branch === nextType) {
              // We know the next element will match, so jump twice.
              searchListenerTree(handlers, type, xxTree[branch], i+2);
            } else if(branch === currentType) {
              // Current node matches, move into the tree.
              searchListenerTree(handlers, type, xxTree[branch], i+1);
            } else {
              isolatedBranch = {};
              isolatedBranch[branch] = xxTree[branch];
              searchListenerTree(handlers, type, { '**': isolatedBranch }, i+1);
            }
          }
        }
      } else if(xxTree._listeners) {
        // We have reached the end and still on a '**'
        searchListenerTree(handlers, type, xxTree, typeLength);
      } else if(xxTree['*'] && xxTree['*']._listeners) {
        searchListenerTree(handlers, type, xxTree['*'], typeLength);
      }
    }

    return listeners;
  }

  function growListenerTree(type, listener) {

    type = typeof type === 'string' ? type.split(this.delimiter) : type.slice();

    //
    // Looks for two consecutive '**', if so, don't add the event at all.
    //
    for(var i = 0, len = type.length; i+1 < len; i++) {
      if(type[i] === '**' && type[i+1] === '**') {
        return;
      }
    }

    var tree = this.listenerTree;
    var name = type.shift();

    while (name) {

      if (!tree[name]) {
        tree[name] = {};
      }

      tree = tree[name];

      if (type.length === 0) {

        if (!tree._listeners) {
          tree._listeners = listener;
        }
        else if(typeof tree._listeners === 'function') {
          tree._listeners = [tree._listeners, listener];
        }
        else if (isArray(tree._listeners)) {

          tree._listeners.push(listener);

          if (!tree._listeners.warned) {

            var m = defaultMaxListeners;

            if (typeof this._events.maxListeners !== 'undefined') {
              m = this._events.maxListeners;
            }

            if (m > 0 && tree._listeners.length > m) {

              tree._listeners.warned = true;
              console.error('(node) warning: possible EventEmitter memory ' +
                            'leak detected. %d listeners added. ' +
                            'Use emitter.setMaxListeners() to increase limit.',
                            tree._listeners.length);
              console.trace();
            }
          }
        }
        return true;
      }
      name = type.shift();
    }
    return true;
  }

  // By default EventEmitters will print a warning if more than
  // 10 listeners are added to it. This is a useful default which
  // helps finding memory leaks.
  //
  // Obviously not all Emitters should be limited to 10. This function allows
  // that to be increased. Set to zero for unlimited.

  EventEmitter.prototype.delimiter = '.';

  EventEmitter.prototype.setMaxListeners = function(n) {
    this._events || init.call(this);
    this._events.maxListeners = n;
    if (!this._conf) this._conf = {};
    this._conf.maxListeners = n;
  };

  EventEmitter.prototype.event = '';

  EventEmitter.prototype.once = function(event, fn) {
    this.many(event, 1, fn);
    return this;
  };

  EventEmitter.prototype.many = function(event, ttl, fn) {
    var self = this;

    if (typeof fn !== 'function') {
      throw new Error('many only accepts instances of Function');
    }

    function listener() {
      if (--ttl === 0) {
        self.off(event, listener);
      }
      fn.apply(this, arguments);
    }

    listener._origin = fn;

    this.on(event, listener);

    return self;
  };

  EventEmitter.prototype.emit = function() {

    this._events || init.call(this);

    var type = arguments[0];

    if (type === 'newListener' && !this.newListener) {
      if (!this._events.newListener) { return false; }
    }

    // Loop through the *_all* functions and invoke them.
    if (this._all) {
      var l = arguments.length;
      var args = new Array(l - 1);
      for (var i = 1; i < l; i++) args[i - 1] = arguments[i];
      for (i = 0, l = this._all.length; i < l; i++) {
        this.event = type;
        this._all[i].apply(this, args);
      }
    }

    // If there is no 'error' event listener then throw.
    if (type === 'error') {

      if (!this._all &&
        !this._events.error &&
        !(this.wildcard && this.listenerTree.error)) {

        if (arguments[1] instanceof Error) {
          throw arguments[1]; // Unhandled 'error' event
        } else {
          throw new Error("Uncaught, unspecified 'error' event.");
        }
        return false;
      }
    }

    var handler;

    if(this.wildcard) {
      handler = [];
      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();
      searchListenerTree.call(this, handler, ns, this.listenerTree, 0);
    }
    else {
      handler = this._events[type];
    }

    if (typeof handler === 'function') {
      this.event = type;
      if (arguments.length === 1) {
        handler.call(this);
      }
      else if (arguments.length > 1)
        switch (arguments.length) {
          case 2:
            handler.call(this, arguments[1]);
            break;
          case 3:
            handler.call(this, arguments[1], arguments[2]);
            break;
          // slower
          default:
            var l = arguments.length;
            var args = new Array(l - 1);
            for (var i = 1; i < l; i++) args[i - 1] = arguments[i];
            handler.apply(this, args);
        }
      return true;
    }
    else if (handler) {
      var l = arguments.length;
      var args = new Array(l - 1);
      for (var i = 1; i < l; i++) args[i - 1] = arguments[i];

      var listeners = handler.slice();
      for (var i = 0, l = listeners.length; i < l; i++) {
        this.event = type;
        listeners[i].apply(this, args);
      }
      return (listeners.length > 0) || !!this._all;
    }
    else {
      return !!this._all;
    }

  };

  EventEmitter.prototype.on = function(type, listener) {

    if (typeof type === 'function') {
      this.onAny(type);
      return this;
    }

    if (typeof listener !== 'function') {
      throw new Error('on only accepts instances of Function');
    }
    this._events || init.call(this);

    // To avoid recursion in the case that type == "newListeners"! Before
    // adding it to the listeners, first emit "newListeners".
    this.emit('newListener', type, listener);

    if(this.wildcard) {
      growListenerTree.call(this, type, listener);
      return this;
    }

    if (!this._events[type]) {
      // Optimize the case of one listener. Don't need the extra array object.
      this._events[type] = listener;
    }
    else if(typeof this._events[type] === 'function') {
      // Adding the second element, need to change to array.
      this._events[type] = [this._events[type], listener];
    }
    else if (isArray(this._events[type])) {
      // If we've already got an array, just append.
      this._events[type].push(listener);

      // Check for listener leak
      if (!this._events[type].warned) {

        var m = defaultMaxListeners;

        if (typeof this._events.maxListeners !== 'undefined') {
          m = this._events.maxListeners;
        }

        if (m > 0 && this._events[type].length > m) {

          this._events[type].warned = true;
          console.error('(node) warning: possible EventEmitter memory ' +
                        'leak detected. %d listeners added. ' +
                        'Use emitter.setMaxListeners() to increase limit.',
                        this._events[type].length);
          console.trace();
        }
      }
    }
    return this;
  };

  EventEmitter.prototype.onAny = function(fn) {

    if (typeof fn !== 'function') {
      throw new Error('onAny only accepts instances of Function');
    }

    if(!this._all) {
      this._all = [];
    }

    // Add the function to the event listener collection.
    this._all.push(fn);
    return this;
  };

  EventEmitter.prototype.addListener = EventEmitter.prototype.on;

  EventEmitter.prototype.off = function(type, listener) {
    if (typeof listener !== 'function') {
      throw new Error('removeListener only takes instances of Function');
    }

    var handlers,leafs=[];

    if(this.wildcard) {
      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();
      leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);
    }
    else {
      // does not use listeners(), so no side effect of creating _events[type]
      if (!this._events[type]) return this;
      handlers = this._events[type];
      leafs.push({_listeners:handlers});
    }

    for (var iLeaf=0; iLeaf<leafs.length; iLeaf++) {
      var leaf = leafs[iLeaf];
      handlers = leaf._listeners;
      if (isArray(handlers)) {

        var position = -1;

        for (var i = 0, length = handlers.length; i < length; i++) {
          if (handlers[i] === listener ||
            (handlers[i].listener && handlers[i].listener === listener) ||
            (handlers[i]._origin && handlers[i]._origin === listener)) {
            position = i;
            break;
          }
        }

        if (position < 0) {
          continue;
        }

        if(this.wildcard) {
          leaf._listeners.splice(position, 1);
        }
        else {
          this._events[type].splice(position, 1);
        }

        if (handlers.length === 0) {
          if(this.wildcard) {
            delete leaf._listeners;
          }
          else {
            delete this._events[type];
          }
        }
        return this;
      }
      else if (handlers === listener ||
        (handlers.listener && handlers.listener === listener) ||
        (handlers._origin && handlers._origin === listener)) {
        if(this.wildcard) {
          delete leaf._listeners;
        }
        else {
          delete this._events[type];
        }
      }
    }

    return this;
  };

  EventEmitter.prototype.offAny = function(fn) {
    var i = 0, l = 0, fns;
    if (fn && this._all && this._all.length > 0) {
      fns = this._all;
      for(i = 0, l = fns.length; i < l; i++) {
        if(fn === fns[i]) {
          fns.splice(i, 1);
          return this;
        }
      }
    } else {
      this._all = [];
    }
    return this;
  };

  EventEmitter.prototype.removeListener = EventEmitter.prototype.off;

  EventEmitter.prototype.removeAllListeners = function(type) {
    if (arguments.length === 0) {
      !this._events || init.call(this);
      return this;
    }

    if(this.wildcard) {
      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();
      var leafs = searchListenerTree.call(this, null, ns, this.listenerTree, 0);

      for (var iLeaf=0; iLeaf<leafs.length; iLeaf++) {
        var leaf = leafs[iLeaf];
        leaf._listeners = null;
      }
    }
    else {
      if (!this._events[type]) return this;
      this._events[type] = null;
    }
    return this;
  };

  EventEmitter.prototype.listeners = function(type) {
    if(this.wildcard) {
      var handlers = [];
      var ns = typeof type === 'string' ? type.split(this.delimiter) : type.slice();
      searchListenerTree.call(this, handlers, ns, this.listenerTree, 0);
      return handlers;
    }

    this._events || init.call(this);

    if (!this._events[type]) this._events[type] = [];
    if (!isArray(this._events[type])) {
      this._events[type] = [this._events[type]];
    }
    return this._events[type];
  };

  EventEmitter.prototype.listenersAny = function() {

    if(this._all) {
      return this._all;
    }
    else {
      return [];
    }

  };

  if (typeof define === 'function' && define.amd) {
     // AMD. Register as an anonymous module.
    define(function() {
      return EventEmitter;
    });
  } else if (typeof exports === 'object') {
    // CommonJS
    exports.EventEmitter2 = EventEmitter;
  }
  else {
    // Browser global.
    window.EventEmitter2 = EventEmitter;
  }
}();

},{}],3:[function(_dereq_,module,exports){
var diff = _dereq_('fast-diff');
var is = _dereq_('./is');
var op = _dereq_('./op');


var NULL_CHARACTER = String.fromCharCode(0);  // Placeholder char for embed in diff()


var Delta = function (ops) {
  // Assume we are given a well formed ops
  if (is.array(ops)) {
    this.ops = ops;
  } else if (is.object(ops) && is.array(ops.ops)) {
    this.ops = ops.ops;
  } else {
    this.ops = [];
  }
};


Delta.prototype.insert = function (text, attributes) {
  var newOp = {};
  if (is.string(text)) {
    if (text.length === 0) return this;
    newOp.insert = text;
  } else if (is.number(text)) {
    newOp.insert = text;
  }
  if (is.object(attributes) && Object.keys(attributes).length > 0) newOp.attributes = attributes;
  return this.push(newOp);
};

Delta.prototype['delete'] = function (length) {
  if (length <= 0) return this;
  return this.push({ 'delete': length });
};

Delta.prototype.retain = function (length, attributes) {
  if (length <= 0) return this;
  var newOp = { retain: length };
  if (is.object(attributes) && Object.keys(attributes).length > 0) newOp.attributes = attributes;
  return this.push(newOp);
};

Delta.prototype.push = function (newOp) {
  var index = this.ops.length;
  var lastOp = this.ops[index - 1];
  newOp = op.clone(newOp);
  if (is.object(lastOp)) {
    if (is.number(newOp['delete']) && is.number(lastOp['delete'])) {
      this.ops[index - 1] = { 'delete': lastOp['delete'] + newOp['delete'] };
      return this;
    }
    // Since it does not matter if we insert before or after deleting at the same index,
    // always prefer to insert first
    if (is.number(lastOp['delete']) && (is.string(newOp.insert) || is.number(newOp.insert))) {
      index -= 1;
      lastOp = this.ops[index - 1];
      if (!is.object(lastOp)) {
        this.ops.unshift(newOp);
        return this;
      }
    }
    if (is.equal(newOp.attributes, lastOp.attributes)) {
      if (is.string(newOp.insert) && is.string(lastOp.insert)) {
        this.ops[index - 1] = { insert: lastOp.insert + newOp.insert };
        if (is.object(newOp.attributes)) this.ops[index - 1].attributes = newOp.attributes
        return this;
      } else if (is.number(newOp.retain) && is.number(lastOp.retain)) {
        this.ops[index - 1] = { retain: lastOp.retain + newOp.retain };
        if (is.object(newOp.attributes)) this.ops[index - 1].attributes = newOp.attributes
        return this;
      }
    }
  }
  this.ops.splice(index, 0, newOp);
  return this;
};

Delta.prototype.chop = function () {
  var lastOp = this.ops[this.ops.length - 1];
  if (lastOp && lastOp.retain && !lastOp.attributes) {
    this.ops.pop();
  }
  return this;
};

Delta.prototype.length = function () {
  return this.ops.reduce(function (length, elem) {
    return length + op.length(elem);
  }, 0);
};

Delta.prototype.slice = function (start, end) {
  start = start || 0;
  if (!is.number(end)) end = Infinity;
  var delta = new Delta();
  var iter = op.iterator(this.ops);
  var index = 0;
  while (index < end && iter.hasNext()) {
    var nextOp;
    if (index < start) {
      nextOp = iter.next(start - index);
    } else {
      nextOp = iter.next(end - index);
      delta.push(nextOp);
    }
    index += op.length(nextOp);
  }
  return delta;
};


Delta.prototype.compose = function (other) {
  var thisIter = op.iterator(this.ops);
  var otherIter = op.iterator(other.ops);
  this.ops = [];
  while (thisIter.hasNext() || otherIter.hasNext()) {
    if (otherIter.peekType() === 'insert') {
      this.push(otherIter.next());
    } else if (thisIter.peekType() === 'delete') {
      this.push(thisIter.next());
    } else {
      var length = Math.min(thisIter.peekLength(), otherIter.peekLength());
      var thisOp = thisIter.next(length);
      var otherOp = otherIter.next(length);
      if (is.number(otherOp.retain)) {
        var newOp = {};
        if (is.number(thisOp.retain)) {
          newOp.retain = length;
        } else {
          newOp.insert = thisOp.insert;
        }
        // Preserve null when composing with a retain, otherwise remove it for inserts
        var attributes = op.attributes.compose(thisOp.attributes, otherOp.attributes, is.number(thisOp.retain));
        if (attributes) newOp.attributes = attributes;
        this.push(newOp);
      // Other op should be delete, we could be an insert or retain
      // Insert + delete cancels out
      } else if (is.number(otherOp['delete']) && is.number(thisOp.retain)) {
        this.push(otherOp);
      }
    }
  }
  return this.chop();
};

Delta.prototype.diff = function (other) {
  var strings = [this.ops, other.ops].map(function (ops) {
    return ops.map(function (op) {
      if (is.string(op.insert)) return op.insert;
      if (is.number(op.insert)) return NULL_CHARACTER;
      var prep = ops === other.ops ? 'on' : 'with';
      throw new Error('diff() called ' + prep + ' non-document');
    }).join('');
  });
  var diffResult = diff(strings[0], strings[1]);
  var thisIter = op.iterator(this.ops);
  var otherIter = op.iterator(other.ops);
  var delta = new Delta();
  diffResult.forEach(function (component) {
    var length = component[1].length;
    while (length > 0) {
      var opLength = 0;
      switch (component[0]) {
        case diff.INSERT:
          opLength = Math.min(otherIter.peekLength(), length);
          delta.push(otherIter.next(opLength));
          break;
        case diff.DELETE:
          opLength = Math.min(length, thisIter.peekLength());
          thisIter.next(opLength);
          delta['delete'](opLength);
          break;
        case diff.EQUAL:
          opLength = Math.min(thisIter.peekLength(), otherIter.peekLength(), length);
          var thisOp = thisIter.next(opLength);
          var otherOp = otherIter.next(opLength);
          if (thisOp.insert === otherOp.insert) {
            delta.retain(opLength, op.attributes.diff(thisOp.attributes, otherOp.attributes));
          } else {
            delta.push(otherOp)['delete'](opLength);
          }
          break;
      }
      length -= opLength;
    }
  });
  return delta.chop();
};

Delta.prototype.transform = function (other, priority) {
  priority = !!priority;
  if (is.number(other)) {
    return this.transformPosition(other, priority);
  }
  var thisIter = op.iterator(this.ops);
  var otherIter = op.iterator(other.ops);
  var delta = new Delta();
  while (thisIter.hasNext() || otherIter.hasNext()) {
    if (thisIter.peekType() === 'insert' && (priority || otherIter.peekType() !== 'insert')) {
      delta.retain(op.length(thisIter.next()));
    } else if (otherIter.peekType() === 'insert') {
      delta.push(otherIter.next());
    } else {
      var length = Math.min(thisIter.peekLength(), otherIter.peekLength());
      var thisOp = thisIter.next(length);
      var otherOp = otherIter.next(length);
      if (thisOp['delete']) {
        // Our delete either makes their delete redundant or removes their retain
        continue;
      } else if (otherOp['delete']) {
        delta.push(otherOp);
      } else {
        // We retain either their retain or insert
        delta.retain(length, op.attributes.transform(thisOp.attributes, otherOp.attributes, priority));
      }
    }
  }
  return delta.chop();
};

Delta.prototype.transformPosition = function (index, priority) {
  priority = !!priority;
  var thisIter = op.iterator(this.ops);
  var offset = 0;
  while (thisIter.hasNext() && offset <= index) {
    var length = thisIter.peekLength();
    var nextType = thisIter.peekType();
    thisIter.next();
    if (nextType === 'delete') {
      index -= Math.min(length, index - offset);
      continue;
    } else if (nextType === 'insert' && (offset < index || !priority)) {
      index += length;
    }
    offset += length;
  }
  return index;
};


module.exports = Delta;

},{"./is":4,"./op":5,"fast-diff":6}],4:[function(_dereq_,module,exports){
module.exports = {
  equal: function (a, b) {
    if (a === b) return true;
    if (a == null && b == null) return true;
    if (a == null || b == null) return false;
    if (Object.keys(a).length != Object.keys(b).length) return false;
    for(var key in a) {
      // Only compare one level deep
      if (a[key] !== b[key]) return false;
    }
    return true;
  },

  array: function (value) {
    return Array.isArray(value);
  },

  number: function (value) {
    if (typeof value === 'number') return true;
    if (typeof value === 'object' && Object.prototype.toString.call(value) === '[object Number]') return true;
    return false;
  },

  object: function (value) {
    if (!value) return false;
    return (typeof value === 'function' || typeof value === 'object');
  },

  string: function (value) {
    if (typeof value === 'string') return true;
    if (typeof value === 'object' && Object.prototype.toString.call(value) === '[object String]') return true;
    return false;
  }
};

},{}],5:[function(_dereq_,module,exports){
var is = _dereq_('./is');


var lib = {
  attributes: {
    clone: function (attributes, keepNull) {
      if (!is.object(attributes)) return {};
      return Object.keys(attributes).reduce(function (memo, key) {
        if (attributes[key] !== undefined && (attributes[key] !== null || keepNull)) {
          memo[key] = attributes[key];
        }
        return memo;
      }, {});
    },

    compose: function (a, b, keepNull) {
      if (!is.object(a)) a = {};
      if (!is.object(b)) b = {};
      var attributes = this.clone(b, keepNull);
      for (var key in a) {
        if (a[key] !== undefined && b[key] === undefined) {
          attributes[key] = a[key];
        }
      }
      return Object.keys(attributes).length > 0 ? attributes : undefined;
    },

    diff: function(a, b) {
      if (!is.object(a)) a = {};
      if (!is.object(b)) b = {};
      var attributes = Object.keys(a).concat(Object.keys(b)).reduce(function (attributes, key) {
        if (a[key] !== b[key]) {
          attributes[key] = b[key] === undefined ? null : b[key];
        }
        return attributes;
      }, {});
      return Object.keys(attributes).length > 0 ? attributes : undefined;
    },

    transform: function (a, b, priority) {
      if (!is.object(a)) return b;
      if (!is.object(b)) return undefined;
      if (!priority) return b;  // b simply overwrites us without priority
      var attributes = Object.keys(b).reduce(function (attributes, key) {
        if (a[key] === undefined) attributes[key] = b[key];  // null is a valid value
        return attributes;
      }, {});
      return Object.keys(attributes).length > 0 ? attributes : undefined;
    }
  },

  clone: function (op) {
    var newOp = this.attributes.clone(op);
    if (is.object(newOp.attributes)) {
      newOp.attributes = this.attributes.clone(newOp.attributes, true);
    }
    return newOp;
  },

  iterator: function (ops) {
    return new Iterator(ops);
  },

  length: function (op) {
    if (is.number(op['delete'])) {
      return op['delete'];
    } else if (is.number(op.retain)) {
      return op.retain;
    } else {
      return is.string(op.insert) ? op.insert.length : 1;
    }
  }
};


function Iterator(ops) {
  this.ops = ops;
  this.index = 0;
  this.offset = 0;
};

Iterator.prototype.hasNext = function () {
  return this.peekLength() < Infinity;
};

Iterator.prototype.next = function (length) {
  if (!length) length = Infinity;
  var nextOp = this.ops[this.index];
  if (nextOp) {
    var offset = this.offset;
    var opLength = lib.length(nextOp)
    if (length >= opLength - offset) {
      length = opLength - offset;
      this.index += 1;
      this.offset = 0;
    } else {
      this.offset += length;
    }
    if (is.number(nextOp['delete'])) {
      return { 'delete': length };
    } else {
      var retOp = {};
      if (nextOp.attributes) {
        retOp.attributes = nextOp.attributes;
      }
      if (is.number(nextOp.retain)) {
        retOp.retain = length;
      } else if (is.string(nextOp.insert)) {
        retOp.insert = nextOp.insert.substr(offset, length);
      } else {
        // offset should === 0, length should === 1
        retOp.insert = nextOp.insert;
      }
      return retOp;
    }
  } else {
    return { retain: Infinity };
  }
};

Iterator.prototype.peekLength = function () {
  if (this.ops[this.index]) {
    // Should never return 0 if our index is being managed correctly
    return lib.length(this.ops[this.index]) - this.offset;
  } else {
    return Infinity;
  }
};

Iterator.prototype.peekType = function () {
  if (this.ops[this.index]) {
    if (is.number(this.ops[this.index]['delete'])) {
      return 'delete';
    } else if (is.number(this.ops[this.index].retain)) {
      return 'retain';
    } else {
      return 'insert';
    }
  }
  return 'retain';
};


module.exports = lib;

},{"./is":4}],6:[function(_dereq_,module,exports){
/**
 * This library modifies the diff-patch-match library by Neil Fraser
 * by removing the patch and match functionality and certain advanced
 * options in the diff function. The original license is as follows:
 *
 * ===
 *
 * Diff Match and Patch
 *
 * Copyright 2006 Google Inc.
 * http://code.google.com/p/google-diff-match-patch/
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


/**
 * The data structure representing a diff is an array of tuples:
 * [[DIFF_DELETE, 'Hello'], [DIFF_INSERT, 'Goodbye'], [DIFF_EQUAL, ' world.']]
 * which means: delete 'Hello', add 'Goodbye' and keep ' world.'
 */
var DIFF_DELETE = -1;
var DIFF_INSERT = 1;
var DIFF_EQUAL = 0;


/**
 * Find the differences between two texts.  Simplifies the problem by stripping
 * any common prefix or suffix off the texts before diffing.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @return {Array} Array of diff tuples.
 */
function diff_main(text1, text2) {
  // Check for equality (speedup).
  if (text1 == text2) {
    if (text1) {
      return [[DIFF_EQUAL, text1]];
    }
    return [];
  }

  // Trim off common prefix (speedup).
  var commonlength = diff_commonPrefix(text1, text2);
  var commonprefix = text1.substring(0, commonlength);
  text1 = text1.substring(commonlength);
  text2 = text2.substring(commonlength);

  // Trim off common suffix (speedup).
  commonlength = diff_commonSuffix(text1, text2);
  var commonsuffix = text1.substring(text1.length - commonlength);
  text1 = text1.substring(0, text1.length - commonlength);
  text2 = text2.substring(0, text2.length - commonlength);

  // Compute the diff on the middle block.
  var diffs = diff_compute_(text1, text2);

  // Restore the prefix and suffix.
  if (commonprefix) {
    diffs.unshift([DIFF_EQUAL, commonprefix]);
  }
  if (commonsuffix) {
    diffs.push([DIFF_EQUAL, commonsuffix]);
  }
  diff_cleanupMerge(diffs);
  return diffs;
};


/**
 * Find the differences between two texts.  Assumes that the texts do not
 * have any common prefix or suffix.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @return {Array} Array of diff tuples.
 */
function diff_compute_(text1, text2) {
  var diffs;

  if (!text1) {
    // Just add some text (speedup).
    return [[DIFF_INSERT, text2]];
  }

  if (!text2) {
    // Just delete some text (speedup).
    return [[DIFF_DELETE, text1]];
  }

  var longtext = text1.length > text2.length ? text1 : text2;
  var shorttext = text1.length > text2.length ? text2 : text1;
  var i = longtext.indexOf(shorttext);
  if (i != -1) {
    // Shorter text is inside the longer text (speedup).
    diffs = [[DIFF_INSERT, longtext.substring(0, i)],
             [DIFF_EQUAL, shorttext],
             [DIFF_INSERT, longtext.substring(i + shorttext.length)]];
    // Swap insertions for deletions if diff is reversed.
    if (text1.length > text2.length) {
      diffs[0][0] = diffs[2][0] = DIFF_DELETE;
    }
    return diffs;
  }

  if (shorttext.length == 1) {
    // Single character string.
    // After the previous speedup, the character can't be an equality.
    return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
  }

  // Check to see if the problem can be split in two.
  var hm = diff_halfMatch_(text1, text2);
  if (hm) {
    // A half-match was found, sort out the return data.
    var text1_a = hm[0];
    var text1_b = hm[1];
    var text2_a = hm[2];
    var text2_b = hm[3];
    var mid_common = hm[4];
    // Send both pairs off for separate processing.
    var diffs_a = diff_main(text1_a, text2_a);
    var diffs_b = diff_main(text1_b, text2_b);
    // Merge the results.
    return diffs_a.concat([[DIFF_EQUAL, mid_common]], diffs_b);
  }

  return diff_bisect_(text1, text2);
};


/**
 * Find the 'middle snake' of a diff, split the problem in two
 * and return the recursively constructed diff.
 * See Myers 1986 paper: An O(ND) Difference Algorithm and Its Variations.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @return {Array} Array of diff tuples.
 * @private
 */
function diff_bisect_(text1, text2) {
  // Cache the text lengths to prevent multiple calls.
  var text1_length = text1.length;
  var text2_length = text2.length;
  var max_d = Math.ceil((text1_length + text2_length) / 2);
  var v_offset = max_d;
  var v_length = 2 * max_d;
  var v1 = new Array(v_length);
  var v2 = new Array(v_length);
  // Setting all elements to -1 is faster in Chrome & Firefox than mixing
  // integers and undefined.
  for (var x = 0; x < v_length; x++) {
    v1[x] = -1;
    v2[x] = -1;
  }
  v1[v_offset + 1] = 0;
  v2[v_offset + 1] = 0;
  var delta = text1_length - text2_length;
  // If the total number of characters is odd, then the front path will collide
  // with the reverse path.
  var front = (delta % 2 != 0);
  // Offsets for start and end of k loop.
  // Prevents mapping of space beyond the grid.
  var k1start = 0;
  var k1end = 0;
  var k2start = 0;
  var k2end = 0;
  for (var d = 0; d < max_d; d++) {
    // Walk the front path one step.
    for (var k1 = -d + k1start; k1 <= d - k1end; k1 += 2) {
      var k1_offset = v_offset + k1;
      var x1;
      if (k1 == -d || (k1 != d && v1[k1_offset - 1] < v1[k1_offset + 1])) {
        x1 = v1[k1_offset + 1];
      } else {
        x1 = v1[k1_offset - 1] + 1;
      }
      var y1 = x1 - k1;
      while (x1 < text1_length && y1 < text2_length &&
             text1.charAt(x1) == text2.charAt(y1)) {
        x1++;
        y1++;
      }
      v1[k1_offset] = x1;
      if (x1 > text1_length) {
        // Ran off the right of the graph.
        k1end += 2;
      } else if (y1 > text2_length) {
        // Ran off the bottom of the graph.
        k1start += 2;
      } else if (front) {
        var k2_offset = v_offset + delta - k1;
        if (k2_offset >= 0 && k2_offset < v_length && v2[k2_offset] != -1) {
          // Mirror x2 onto top-left coordinate system.
          var x2 = text1_length - v2[k2_offset];
          if (x1 >= x2) {
            // Overlap detected.
            return diff_bisectSplit_(text1, text2, x1, y1);
          }
        }
      }
    }

    // Walk the reverse path one step.
    for (var k2 = -d + k2start; k2 <= d - k2end; k2 += 2) {
      var k2_offset = v_offset + k2;
      var x2;
      if (k2 == -d || (k2 != d && v2[k2_offset - 1] < v2[k2_offset + 1])) {
        x2 = v2[k2_offset + 1];
      } else {
        x2 = v2[k2_offset - 1] + 1;
      }
      var y2 = x2 - k2;
      while (x2 < text1_length && y2 < text2_length &&
             text1.charAt(text1_length - x2 - 1) ==
             text2.charAt(text2_length - y2 - 1)) {
        x2++;
        y2++;
      }
      v2[k2_offset] = x2;
      if (x2 > text1_length) {
        // Ran off the left of the graph.
        k2end += 2;
      } else if (y2 > text2_length) {
        // Ran off the top of the graph.
        k2start += 2;
      } else if (!front) {
        var k1_offset = v_offset + delta - k2;
        if (k1_offset >= 0 && k1_offset < v_length && v1[k1_offset] != -1) {
          var x1 = v1[k1_offset];
          var y1 = v_offset + x1 - k1_offset;
          // Mirror x2 onto top-left coordinate system.
          x2 = text1_length - x2;
          if (x1 >= x2) {
            // Overlap detected.
            return diff_bisectSplit_(text1, text2, x1, y1);
          }
        }
      }
    }
  }
  // Diff took too long and hit the deadline or
  // number of diffs equals number of characters, no commonality at all.
  return [[DIFF_DELETE, text1], [DIFF_INSERT, text2]];
};


/**
 * Given the location of the 'middle snake', split the diff in two parts
 * and recurse.
 * @param {string} text1 Old string to be diffed.
 * @param {string} text2 New string to be diffed.
 * @param {number} x Index of split point in text1.
 * @param {number} y Index of split point in text2.
 * @return {Array} Array of diff tuples.
 */
function diff_bisectSplit_(text1, text2, x, y) {
  var text1a = text1.substring(0, x);
  var text2a = text2.substring(0, y);
  var text1b = text1.substring(x);
  var text2b = text2.substring(y);

  // Compute both diffs serially.
  var diffs = diff_main(text1a, text2a);
  var diffsb = diff_main(text1b, text2b);

  return diffs.concat(diffsb);
};


/**
 * Determine the common prefix of two strings.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {number} The number of characters common to the start of each
 *     string.
 */
function diff_commonPrefix(text1, text2) {
  // Quick check for common null cases.
  if (!text1 || !text2 || text1.charAt(0) != text2.charAt(0)) {
    return 0;
  }
  // Binary search.
  // Performance analysis: http://neil.fraser.name/news/2007/10/09/
  var pointermin = 0;
  var pointermax = Math.min(text1.length, text2.length);
  var pointermid = pointermax;
  var pointerstart = 0;
  while (pointermin < pointermid) {
    if (text1.substring(pointerstart, pointermid) ==
        text2.substring(pointerstart, pointermid)) {
      pointermin = pointermid;
      pointerstart = pointermin;
    } else {
      pointermax = pointermid;
    }
    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
  }
  return pointermid;
};


/**
 * Determine the common suffix of two strings.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {number} The number of characters common to the end of each string.
 */
function diff_commonSuffix(text1, text2) {
  // Quick check for common null cases.
  if (!text1 || !text2 ||
      text1.charAt(text1.length - 1) != text2.charAt(text2.length - 1)) {
    return 0;
  }
  // Binary search.
  // Performance analysis: http://neil.fraser.name/news/2007/10/09/
  var pointermin = 0;
  var pointermax = Math.min(text1.length, text2.length);
  var pointermid = pointermax;
  var pointerend = 0;
  while (pointermin < pointermid) {
    if (text1.substring(text1.length - pointermid, text1.length - pointerend) ==
        text2.substring(text2.length - pointermid, text2.length - pointerend)) {
      pointermin = pointermid;
      pointerend = pointermin;
    } else {
      pointermax = pointermid;
    }
    pointermid = Math.floor((pointermax - pointermin) / 2 + pointermin);
  }
  return pointermid;
};


/**
 * Do the two texts share a substring which is at least half the length of the
 * longer text?
 * This speedup can produce non-minimal diffs.
 * @param {string} text1 First string.
 * @param {string} text2 Second string.
 * @return {Array.<string>} Five element Array, containing the prefix of
 *     text1, the suffix of text1, the prefix of text2, the suffix of
 *     text2 and the common middle.  Or null if there was no match.
 */
function diff_halfMatch_(text1, text2) {
  var longtext = text1.length > text2.length ? text1 : text2;
  var shorttext = text1.length > text2.length ? text2 : text1;
  if (longtext.length < 4 || shorttext.length * 2 < longtext.length) {
    return null;  // Pointless.
  }

  /**
   * Does a substring of shorttext exist within longtext such that the substring
   * is at least half the length of longtext?
   * Closure, but does not reference any external variables.
   * @param {string} longtext Longer string.
   * @param {string} shorttext Shorter string.
   * @param {number} i Start index of quarter length substring within longtext.
   * @return {Array.<string>} Five element Array, containing the prefix of
   *     longtext, the suffix of longtext, the prefix of shorttext, the suffix
   *     of shorttext and the common middle.  Or null if there was no match.
   * @private
   */
  function diff_halfMatchI_(longtext, shorttext, i) {
    // Start with a 1/4 length substring at position i as a seed.
    var seed = longtext.substring(i, i + Math.floor(longtext.length / 4));
    var j = -1;
    var best_common = '';
    var best_longtext_a, best_longtext_b, best_shorttext_a, best_shorttext_b;
    while ((j = shorttext.indexOf(seed, j + 1)) != -1) {
      var prefixLength = diff_commonPrefix(longtext.substring(i),
                                           shorttext.substring(j));
      var suffixLength = diff_commonSuffix(longtext.substring(0, i),
                                           shorttext.substring(0, j));
      if (best_common.length < suffixLength + prefixLength) {
        best_common = shorttext.substring(j - suffixLength, j) +
            shorttext.substring(j, j + prefixLength);
        best_longtext_a = longtext.substring(0, i - suffixLength);
        best_longtext_b = longtext.substring(i + prefixLength);
        best_shorttext_a = shorttext.substring(0, j - suffixLength);
        best_shorttext_b = shorttext.substring(j + prefixLength);
      }
    }
    if (best_common.length * 2 >= longtext.length) {
      return [best_longtext_a, best_longtext_b,
              best_shorttext_a, best_shorttext_b, best_common];
    } else {
      return null;
    }
  }

  // First check if the second quarter is the seed for a half-match.
  var hm1 = diff_halfMatchI_(longtext, shorttext,
                             Math.ceil(longtext.length / 4));
  // Check again based on the third quarter.
  var hm2 = diff_halfMatchI_(longtext, shorttext,
                             Math.ceil(longtext.length / 2));
  var hm;
  if (!hm1 && !hm2) {
    return null;
  } else if (!hm2) {
    hm = hm1;
  } else if (!hm1) {
    hm = hm2;
  } else {
    // Both matched.  Select the longest.
    hm = hm1[4].length > hm2[4].length ? hm1 : hm2;
  }

  // A half-match was found, sort out the return data.
  var text1_a, text1_b, text2_a, text2_b;
  if (text1.length > text2.length) {
    text1_a = hm[0];
    text1_b = hm[1];
    text2_a = hm[2];
    text2_b = hm[3];
  } else {
    text2_a = hm[0];
    text2_b = hm[1];
    text1_a = hm[2];
    text1_b = hm[3];
  }
  var mid_common = hm[4];
  return [text1_a, text1_b, text2_a, text2_b, mid_common];
};


/**
 * Reorder and merge like edit sections.  Merge equalities.
 * Any edit section can move as long as it doesn't cross an equality.
 * @param {Array} diffs Array of diff tuples.
 */
function diff_cleanupMerge(diffs) {
  diffs.push([DIFF_EQUAL, '']);  // Add a dummy entry at the end.
  var pointer = 0;
  var count_delete = 0;
  var count_insert = 0;
  var text_delete = '';
  var text_insert = '';
  var commonlength;
  while (pointer < diffs.length) {
    switch (diffs[pointer][0]) {
      case DIFF_INSERT:
        count_insert++;
        text_insert += diffs[pointer][1];
        pointer++;
        break;
      case DIFF_DELETE:
        count_delete++;
        text_delete += diffs[pointer][1];
        pointer++;
        break;
      case DIFF_EQUAL:
        // Upon reaching an equality, check for prior redundancies.
        if (count_delete + count_insert > 1) {
          if (count_delete !== 0 && count_insert !== 0) {
            // Factor out any common prefixies.
            commonlength = diff_commonPrefix(text_insert, text_delete);
            if (commonlength !== 0) {
              if ((pointer - count_delete - count_insert) > 0 &&
                  diffs[pointer - count_delete - count_insert - 1][0] ==
                  DIFF_EQUAL) {
                diffs[pointer - count_delete - count_insert - 1][1] +=
                    text_insert.substring(0, commonlength);
              } else {
                diffs.splice(0, 0, [DIFF_EQUAL,
                                    text_insert.substring(0, commonlength)]);
                pointer++;
              }
              text_insert = text_insert.substring(commonlength);
              text_delete = text_delete.substring(commonlength);
            }
            // Factor out any common suffixies.
            commonlength = diff_commonSuffix(text_insert, text_delete);
            if (commonlength !== 0) {
              diffs[pointer][1] = text_insert.substring(text_insert.length -
                  commonlength) + diffs[pointer][1];
              text_insert = text_insert.substring(0, text_insert.length -
                  commonlength);
              text_delete = text_delete.substring(0, text_delete.length -
                  commonlength);
            }
          }
          // Delete the offending records and add the merged ones.
          if (count_delete === 0) {
            diffs.splice(pointer - count_insert,
                count_delete + count_insert, [DIFF_INSERT, text_insert]);
          } else if (count_insert === 0) {
            diffs.splice(pointer - count_delete,
                count_delete + count_insert, [DIFF_DELETE, text_delete]);
          } else {
            diffs.splice(pointer - count_delete - count_insert,
                count_delete + count_insert, [DIFF_DELETE, text_delete],
                [DIFF_INSERT, text_insert]);
          }
          pointer = pointer - count_delete - count_insert +
                    (count_delete ? 1 : 0) + (count_insert ? 1 : 0) + 1;
        } else if (pointer !== 0 && diffs[pointer - 1][0] == DIFF_EQUAL) {
          // Merge this equality with the previous one.
          diffs[pointer - 1][1] += diffs[pointer][1];
          diffs.splice(pointer, 1);
        } else {
          pointer++;
        }
        count_insert = 0;
        count_delete = 0;
        text_delete = '';
        text_insert = '';
        break;
    }
  }
  if (diffs[diffs.length - 1][1] === '') {
    diffs.pop();  // Remove the dummy entry at the end.
  }

  // Second pass: look for single edits surrounded on both sides by equalities
  // which can be shifted sideways to eliminate an equality.
  // e.g: A<ins>BA</ins>C -> <ins>AB</ins>AC
  var changes = false;
  pointer = 1;
  // Intentionally ignore the first and last element (don't need checking).
  while (pointer < diffs.length - 1) {
    if (diffs[pointer - 1][0] == DIFF_EQUAL &&
        diffs[pointer + 1][0] == DIFF_EQUAL) {
      // This is a single edit surrounded by equalities.
      if (diffs[pointer][1].substring(diffs[pointer][1].length -
          diffs[pointer - 1][1].length) == diffs[pointer - 1][1]) {
        // Shift the edit over the previous equality.
        diffs[pointer][1] = diffs[pointer - 1][1] +
            diffs[pointer][1].substring(0, diffs[pointer][1].length -
                                        diffs[pointer - 1][1].length);
        diffs[pointer + 1][1] = diffs[pointer - 1][1] + diffs[pointer + 1][1];
        diffs.splice(pointer - 1, 1);
        changes = true;
      } else if (diffs[pointer][1].substring(0, diffs[pointer + 1][1].length) ==
          diffs[pointer + 1][1]) {
        // Shift the edit over the next equality.
        diffs[pointer - 1][1] += diffs[pointer + 1][1];
        diffs[pointer][1] =
            diffs[pointer][1].substring(diffs[pointer + 1][1].length) +
            diffs[pointer + 1][1];
        diffs.splice(pointer + 1, 1);
        changes = true;
      }
    }
    pointer++;
  }
  // If shifts were made, the diff needs reordering and another shift sweep.
  if (changes) {
    diff_cleanupMerge(diffs);
  }
};


var diff = diff_main;
diff.INSERT = DIFF_INSERT;
diff.DELETE = DIFF_DELETE;
diff.EQUAL = DIFF_EQUAL;


module.exports = diff;

},{}],7:[function(_dereq_,module,exports){
module.exports={"version":"0.19.10"}
},{}],8:[function(_dereq_,module,exports){
var Delta, Document, Format, Line, LinkedList, Normalizer, _, dom;

_ = _dereq_('lodash');

Delta = _dereq_('rich-text/lib/delta');

dom = _dereq_('../lib/dom');

Format = _dereq_('./format');

Line = _dereq_('./line');

LinkedList = _dereq_('../lib/linked-list');

Normalizer = _dereq_('./normalizer');

Document = (function() {
  function Document(root, options) {
    this.root = root;
    if (options == null) {
      options = {};
    }
    this.normalizer = new Normalizer();
    this.formats = {};
    _.each(options.formats, _.bind(this.addFormat, this));
    this.setHTML(this.root.innerHTML);
  }

  Document.prototype.addFormat = function(name, config) {
    if (!_.isObject(config)) {
      config = Format.FORMATS[name];
    }
    if (this.formats[name] != null) {
      console.warn('Overwriting format', name, this.formats[name]);
    }
    this.formats[name] = new Format(config);
    return this.normalizer.addFormat(config);
  };

  Document.prototype.appendLine = function(lineNode) {
    return this.insertLineBefore(lineNode, null);
  };

  Document.prototype.findLeafAt = function(index, inclusive) {
    var line, offset, ref;
    ref = this.findLineAt(index), line = ref[0], offset = ref[1];
    if (line != null) {
      return line.findLeafAt(offset, inclusive);
    } else {
      return [null, offset];
    }
  };

  Document.prototype.findLine = function(node) {
    var line;
    while ((node != null) && (dom.BLOCK_TAGS[node.tagName] == null)) {
      node = node.parentNode;
    }
    line = node != null ? this.lineMap[node.id] : null;
    if ((line != null ? line.node : void 0) === node) {
      return line;
    } else {
      return null;
    }
  };

  Document.prototype.findLineAt = function(index) {
    var curLine, length;
    if (!(this.lines.length > 0)) {
      return [null, index];
    }
    length = this.toDelta().length();
    if (index === length) {
      return [this.lines.last, this.lines.last.length];
    }
    if (index > length) {
      return [null, index - length];
    }
    curLine = this.lines.first;
    while (curLine != null) {
      if (index < curLine.length) {
        return [curLine, index];
      }
      index -= curLine.length;
      curLine = curLine.next;
    }
    return [null, index];
  };

  Document.prototype.getHTML = function() {
    var container, html;
    html = this.root.innerHTML;
    html = html.replace(/\>\s+\</g, '>&nbsp;<');
    container = document.createElement('div');
    container.innerHTML = html;
    _.each(container.querySelectorAll("." + Line.CLASS_NAME), function(node) {
      dom(node).removeClass(Line.CLASS_NAME);
      return node.removeAttribute('id');
    });
    return container.innerHTML;
  };

  Document.prototype.insertLineBefore = function(newLineNode, refLine) {
    var line;
    line = new Line(this, newLineNode);
    if (refLine != null) {
      if (!dom(newLineNode.parentNode).isElement()) {
        this.root.insertBefore(newLineNode, refLine.node);
      }
      this.lines.insertAfter(refLine.prev, line);
    } else {
      if (!dom(newLineNode.parentNode).isElement()) {
        this.root.appendChild(newLineNode);
      }
      this.lines.append(line);
    }
    this.lineMap[line.id] = line;
    return line;
  };

  Document.prototype.mergeLines = function(line, lineToMerge) {
    if (lineToMerge.length > 1) {
      if (line.length === 1) {
        dom(line.leaves.last.node).remove();
      }
      _.each(dom(lineToMerge.node).childNodes(), function(child) {
        if (child.tagName !== dom.DEFAULT_BREAK_TAG) {
          return line.node.appendChild(child);
        }
      });
    }
    this.removeLine(lineToMerge);
    return line.rebuild();
  };

  Document.prototype.optimizeLines = function() {
    return _.each(this.lines.toArray(), function(line, i) {
      line.optimize();
      return true;
    });
  };

  Document.prototype.rebuild = function() {
    var lineNode, lines, results;
    lines = this.lines.toArray();
    lineNode = this.root.firstChild;
    if ((lineNode != null) && (dom.LIST_TAGS[lineNode.tagName] != null)) {
      lineNode = lineNode.firstChild;
    }
    _.each(lines, (function(_this) {
      return function(line, index) {
        var newLine, ref;
        while (line.node !== lineNode) {
          if (line.node.parentNode === _this.root || ((ref = line.node.parentNode) != null ? ref.parentNode : void 0) === _this.root) {
            lineNode = _this.normalizer.normalizeLine(lineNode);
            newLine = _this.insertLineBefore(lineNode, line);
            lineNode = dom(lineNode).nextLineNode(_this.root);
          } else {
            return _this.removeLine(line);
          }
        }
        if (line.outerHTML !== lineNode.outerHTML) {
          line.node = _this.normalizer.normalizeLine(line.node);
          line.rebuild();
        }
        return lineNode = dom(lineNode).nextLineNode(_this.root);
      };
    })(this));
    results = [];
    while (lineNode != null) {
      lineNode = this.normalizer.normalizeLine(lineNode);
      this.appendLine(lineNode);
      results.push(lineNode = dom(lineNode).nextLineNode(this.root));
    }
    return results;
  };

  Document.prototype.removeLine = function(line) {
    if (line.node.parentNode != null) {
      if (dom.LIST_TAGS[line.node.parentNode.tagName] && line.node.parentNode.childNodes.length === 1) {
        dom(line.node.parentNode).remove();
      } else {
        dom(line.node).remove();
      }
    }
    delete this.lineMap[line.id];
    return this.lines.remove(line);
  };

  Document.prototype.setHTML = function(html) {
    html = Normalizer.stripComments(html);
    html = Normalizer.stripWhitespace(html);
    this.root.innerHTML = html;
    this.lines = new LinkedList();
    this.lineMap = {};
    return this.rebuild();
  };

  Document.prototype.splitLine = function(line, offset) {
    var lineNode1, lineNode2, newLine, ref;
    offset = Math.min(offset, line.length - 1);
    ref = dom(line.node).split(offset, true), lineNode1 = ref[0], lineNode2 = ref[1];
    line.node = lineNode1;
    line.rebuild();
    newLine = this.insertLineBefore(lineNode2, line.next);
    newLine.formats = _.clone(line.formats);
    newLine.resetContent();
    return newLine;
  };

  Document.prototype.toDelta = function() {
    var delta, lines;
    lines = this.lines.toArray();
    delta = new Delta();
    _.each(lines, function(line) {
      return _.each(line.delta.ops, function(op) {
        return delta.push(op);
      });
    });
    return delta;
  };

  return Document;

})();

module.exports = Document;



},{"../lib/dom":17,"../lib/linked-list":18,"./format":10,"./line":12,"./normalizer":13,"lodash":1,"rich-text/lib/delta":3}],9:[function(_dereq_,module,exports){
var Document, Editor, Line, Selection, _, dom;

_ = _dereq_('lodash');

dom = _dereq_('../lib/dom');

Document = _dereq_('./document');

Line = _dereq_('./line');

Selection = _dereq_('./selection');

Editor = (function() {
  Editor.sources = {
    API: 'api',
    SILENT: 'silent',
    USER: 'user'
  };

  function Editor(root, quill, options) {
    this.root = root;
    this.quill = quill;
    this.options = options != null ? options : {};
    this.root.setAttribute('id', this.options.id);
    this.doc = new Document(this.root, this.options);
    this.delta = this.doc.toDelta();
    this.length = this.delta.length();
    this.selection = new Selection(this.doc, this.quill);
    this.timer = setInterval(_.bind(this.checkUpdate, this), this.options.pollInterval);
    if (!this.options.readOnly) {
      this.enable();
    }
  }

  Editor.prototype.destroy = function() {
    return clearInterval(this.timer);
  };

  Editor.prototype.disable = function() {
    return this.enable(false);
  };

  Editor.prototype.enable = function(enabled) {
    if (enabled == null) {
      enabled = true;
    }
    return this.root.setAttribute('contenteditable', enabled);
  };

  Editor.prototype.applyDelta = function(delta, source) {
    var localDelta;
    localDelta = this._update();
    if (localDelta) {
      delta = localDelta.transform(delta, true);
      localDelta = delta.transform(localDelta, false);
    }
    if (delta.ops.length > 0) {
      delta = this._trackDelta((function(_this) {
        return function() {
          var index;
          index = 0;
          _.each(delta.ops, function(op) {
            if (_.isString(op.insert)) {
              _this._insertAt(index, op.insert, op.attributes);
              return index += op.insert.length;
            } else if (_.isNumber(op.insert)) {
              _this._insertAt(index, dom.EMBED_TEXT, op.attributes);
              return index += 1;
            } else if (_.isNumber(op["delete"])) {
              return _this._deleteAt(index, op["delete"]);
            } else if (_.isNumber(op.retain)) {
              _.each(op.attributes, function(value, name) {
                return _this._formatAt(index, op.retain, name, value);
              });
              return index += op.retain;
            }
          });
          return _this.selection.shiftAfter(0, 0, _.bind(_this.doc.optimizeLines, _this.doc));
        };
      })(this));
      this.delta = this.doc.toDelta();
      this.length = this.delta.length();
      this.innerHTML = this.root.innerHTML;
      if (delta && source !== Editor.sources.SILENT) {
        this.quill.emit(this.quill.constructor.events.TEXT_CHANGE, delta, source);
      }
    }
    if (localDelta && localDelta.ops.length > 0 && source !== Editor.sources.SILENT) {
      return this.quill.emit(this.quill.constructor.events.TEXT_CHANGE, localDelta, Editor.sources.USER);
    }
  };

  Editor.prototype.checkUpdate = function(source) {
    var delta;
    if (source == null) {
      source = 'user';
    }
    if (this.root.parentNode == null) {
      return clearInterval(this.timer);
    }
    delta = this._update();
    if (delta) {
      this.delta.compose(delta);
      this.length = this.delta.length();
      this.quill.emit(this.quill.constructor.events.TEXT_CHANGE, delta, source);
    }
    if (delta) {
      source = Editor.sources.SILENT;
    }
    return this.selection.update(source);
  };

  Editor.prototype.focus = function() {
    if (this.selection.range != null) {
      return this.selection.setRange(this.selection.range);
    } else {
      return this.root.focus();
    }
  };

  Editor.prototype.getBounds = function(index) {
    var bounds, containerBounds, leaf, offset, range, ref, side;
    this.checkUpdate();
    ref = this.doc.findLeafAt(index, true), leaf = ref[0], offset = ref[1];
    if (leaf == null) {
      throw new Error('Invalid index');
    }
    containerBounds = this.root.parentNode.getBoundingClientRect();
    side = 'left';
    if (leaf.length === 0) {
      bounds = leaf.node.parentNode.getBoundingClientRect();
    } else if (dom.VOID_TAGS[leaf.node.tagName]) {
      bounds = leaf.node.getBoundingClientRect();
      if (offset === 1) {
        side = 'right';
      }
    } else {
      range = document.createRange();
      if (offset < leaf.length) {
        range.setStart(leaf.node, offset);
        range.setEnd(leaf.node, offset + 1);
      } else {
        range.setStart(leaf.node, offset - 1);
        range.setEnd(leaf.node, offset);
        side = 'right';
      }
      bounds = range.getBoundingClientRect();
    }
    return {
      height: bounds.height,
      left: bounds[side] - containerBounds.left,
      top: bounds.top - containerBounds.top
    };
  };

  Editor.prototype._deleteAt = function(index, length) {
    if (length <= 0) {
      return;
    }
    return this.selection.shiftAfter(index, -1 * length, (function(_this) {
      return function() {
        var curLine, deleteLength, firstLine, mergeFirstLine, nextLine, offset, ref;
        ref = _this.doc.findLineAt(index), firstLine = ref[0], offset = ref[1];
        curLine = firstLine;
        mergeFirstLine = firstLine.length - offset <= length && offset > 0;
        while ((curLine != null) && length > 0) {
          nextLine = curLine.next;
          deleteLength = Math.min(curLine.length - offset, length);
          if (offset === 0 && length >= curLine.length) {
            _this.doc.removeLine(curLine);
          } else {
            curLine.deleteText(offset, deleteLength);
          }
          length -= deleteLength;
          curLine = nextLine;
          offset = 0;
        }
        if (mergeFirstLine && firstLine.next) {
          return _this.doc.mergeLines(firstLine, firstLine.next);
        }
      };
    })(this));
  };

  Editor.prototype._formatAt = function(index, length, name, value) {
    return this.selection.shiftAfter(index, 0, (function(_this) {
      return function() {
        var formatLength, line, offset, ref, results;
        ref = _this.doc.findLineAt(index), line = ref[0], offset = ref[1];
        results = [];
        while ((line != null) && length > 0) {
          formatLength = Math.min(length, line.length - offset - 1);
          line.formatText(offset, formatLength, name, value);
          length -= formatLength;
          if (length > 0) {
            line.format(name, value);
          }
          length -= 1;
          offset = 0;
          results.push(line = line.next);
        }
        return results;
      };
    })(this));
  };

  Editor.prototype._insertAt = function(index, text, formatting) {
    if (formatting == null) {
      formatting = {};
    }
    return this.selection.shiftAfter(index, text.length, (function(_this) {
      return function() {
        var line, lineTexts, offset, ref;
        text = text.replace(/\r\n?/g, '\n');
        lineTexts = text.split('\n');
        ref = _this.doc.findLineAt(index), line = ref[0], offset = ref[1];
        return _.each(lineTexts, function(lineText, i) {
          var nextLine;
          if ((line == null) || line.length <= offset) {
            if (i < lineTexts.length - 1 || lineText.length > 0) {
              line = _this.doc.appendLine(document.createElement(dom.DEFAULT_BLOCK_TAG));
              offset = 0;
              line.insertText(offset, lineText, formatting);
              line.format(formatting);
              nextLine = null;
            }
          } else {
            line.insertText(offset, lineText, formatting);
            if (i < lineTexts.length - 1) {
              nextLine = _this.doc.splitLine(line, offset + lineText.length);
              _.each(_.defaults({}, formatting, line.formats), function(value, format) {
                return line.format(format, formatting[format]);
              });
              offset = 0;
            }
          }
          return line = nextLine;
        });
      };
    })(this));
  };

  Editor.prototype._trackDelta = function(fn) {
    var delta, newDelta;
    fn();
    newDelta = this.doc.toDelta();
    delta = this.delta.diff(newDelta);
    return delta;
  };

  Editor.prototype._update = function() {
    var delta;
    if (this.innerHTML === this.root.innerHTML) {
      return false;
    }
    delta = this._trackDelta((function(_this) {
      return function() {
        _this.selection.preserve(_.bind(_this.doc.rebuild, _this.doc));
        return _this.selection.shiftAfter(0, 0, _.bind(_this.doc.optimizeLines, _this.doc));
      };
    })(this));
    this.innerHTML = this.root.innerHTML;
    if (delta.ops.length > 0) {
      return delta;
    } else {
      return false;
    }
  };

  return Editor;

})();

module.exports = Editor;



},{"../lib/dom":17,"./document":8,"./line":12,"./selection":14,"lodash":1}],10:[function(_dereq_,module,exports){
var Format, _, dom;

_ = _dereq_('lodash');

dom = _dereq_('../lib/dom');

Format = (function() {
  Format.types = {
    LINE: 'line'
  };

  Format.FORMATS = {
    bold: {
      tag: 'B',
      prepare: 'bold'
    },
    italic: {
      tag: 'I',
      prepare: 'italic'
    },
    underline: {
      tag: 'U',
      prepare: 'underline'
    },
    strike: {
      tag: 'S',
      prepare: 'strikeThrough'
    },
    color: {
      style: 'color',
      "default": 'rgb(0, 0, 0)',
      prepare: 'foreColor'
    },
    background: {
      style: 'backgroundColor',
      "default": 'rgb(255, 255, 255)',
      prepare: 'backColor'
    },
    font: {
      style: 'fontFamily',
      "default": "'Helvetica', 'Arial', sans-serif",
      prepare: 'fontName'
    },
    size: {
      style: 'fontSize',
      "default": '13px',
      prepare: function(value) {
        return document.execCommand('fontSize', false, dom.convertFontSize(value));
      }
    },
    link: {
      tag: 'A',
      attribute: 'href'
    },
    image: {
      tag: 'IMG',
      attribute: 'src'
    },
    align: {
      type: Format.types.LINE,
      style: 'textAlign',
      "default": 'left'
    },
    bullet: {
      type: Format.types.LINE,
      exclude: 'list',
      parentTag: 'UL',
      tag: 'LI'
    },
    list: {
      type: Format.types.LINE,
      exclude: 'bullet',
      parentTag: 'OL',
      tag: 'LI'
    }
  };

  function Format(config) {
    this.config = config;
  }

  Format.prototype.add = function(node, value) {
    var formatNode, inline, parentNode, ref, ref1;
    if (!value) {
      return this.remove(node);
    }
    if (this.value(node) === value) {
      return node;
    }
    if (_.isString(this.config.parentTag)) {
      parentNode = document.createElement(this.config.parentTag);
      dom(node).wrap(parentNode);
      if (node.parentNode.tagName === ((ref = node.parentNode.previousSibling) != null ? ref.tagName : void 0)) {
        dom(node.parentNode.previousSibling).merge(node.parentNode);
      }
      if (node.parentNode.tagName === ((ref1 = node.parentNode.nextSibling) != null ? ref1.tagName : void 0)) {
        dom(node.parentNode).merge(node.parentNode.nextSibling);
      }
    }
    if (_.isString(this.config.tag)) {
      formatNode = document.createElement(this.config.tag);
      if (dom.VOID_TAGS[formatNode.tagName] != null) {
        if (node.parentNode != null) {
          dom(node).replace(formatNode);
        }
        node = formatNode;
      } else if (this.isType(Format.types.LINE)) {
        node = dom(node).switchTag(this.config.tag);
      } else {
        dom(node).wrap(formatNode);
        node = formatNode;
      }
    }
    if (_.isString(this.config.style) || _.isString(this.config.attribute) || _.isString(this.config["class"])) {
      if (_.isString(this.config["class"])) {
        node = this.remove(node);
      }
      if (dom(node).isTextNode()) {
        inline = document.createElement(dom.DEFAULT_INLINE_TAG);
        dom(node).wrap(inline);
        node = inline;
      }
      if (_.isString(this.config.style)) {
        if (value !== this.config["default"]) {
          node.style[this.config.style] = value;
        }
      }
      if (_.isString(this.config.attribute)) {
        node.setAttribute(this.config.attribute, value);
      }
      if (_.isString(this.config["class"])) {
        dom(node).addClass(this.config["class"] + value);
      }
    }
    return node;
  };

  Format.prototype.isType = function(type) {
    return type === this.config.type;
  };

  Format.prototype.match = function(node) {
    var c, i, len, ref, ref1;
    if (!dom(node).isElement()) {
      return false;
    }
    if (_.isString(this.config.parentTag) && ((ref = node.parentNode) != null ? ref.tagName : void 0) !== this.config.parentTag) {
      return false;
    }
    if (_.isString(this.config.tag) && node.tagName !== this.config.tag) {
      return false;
    }
    if (_.isString(this.config.style) && (!node.style[this.config.style] || node.style[this.config.style] === this.config["default"])) {
      return false;
    }
    if (_.isString(this.config.attribute) && !node.hasAttribute(this.config.attribute)) {
      return false;
    }
    if (_.isString(this.config["class"])) {
      ref1 = dom(node).classes();
      for (i = 0, len = ref1.length; i < len; i++) {
        c = ref1[i];
        if (c.indexOf(this.config["class"]) === 0) {
          return true;
        }
      }
      return false;
    }
    return true;
  };

  Format.prototype.prepare = function(value) {
    if (_.isString(this.config.prepare)) {
      return document.execCommand(this.config.prepare, false, value);
    } else if (_.isFunction(this.config.prepare)) {
      return this.config.prepare(value);
    }
  };

  Format.prototype.remove = function(node) {
    var c, i, len, ref;
    if (!this.match(node)) {
      return node;
    }
    if (_.isString(this.config.style)) {
      node.style[this.config.style] = '';
      if (!node.getAttribute('style')) {
        node.removeAttribute('style');
      }
    }
    if (_.isString(this.config.attribute)) {
      node.removeAttribute(this.config.attribute);
    }
    if (_.isString(this.config["class"])) {
      ref = dom(node).classes();
      for (i = 0, len = ref.length; i < len; i++) {
        c = ref[i];
        if (c.indexOf(this.config["class"]) === 0) {
          dom(node).removeClass(c);
        }
      }
    }
    if (_.isString(this.config.tag)) {
      if (this.isType(Format.types.LINE)) {
        if (_.isString(this.config.parentTag)) {
          if (node.previousSibling != null) {
            dom(node).splitBefore(node.parentNode.parentNode);
          }
          if (node.nextSibling != null) {
            dom(node.nextSibling).splitBefore(node.parentNode.parentNode);
          }
        }
        node = dom(node).switchTag(dom.DEFAULT_BLOCK_TAG);
      } else {
        node = dom(node).switchTag(dom.DEFAULT_INLINE_TAG);
        if (dom.EMBED_TAGS[this.config.tag] != null) {
          dom(node).text(dom.EMBED_TEXT);
        }
      }
    }
    if (_.isString(this.config.parentTag)) {
      dom(node.parentNode).unwrap();
    }
    if (node.tagName === dom.DEFAULT_INLINE_TAG && !node.hasAttributes()) {
      node = dom(node).unwrap();
    }
    return node;
  };

  Format.prototype.value = function(node) {
    var c, i, len, ref;
    if (!this.match(node)) {
      return void 0;
    }
    if (_.isString(this.config.attribute)) {
      return node.getAttribute(this.config.attribute) || void 0;
    } else if (_.isString(this.config.style)) {
      return node.style[this.config.style] || void 0;
    } else if (_.isString(this.config["class"])) {
      ref = dom(node).classes();
      for (i = 0, len = ref.length; i < len; i++) {
        c = ref[i];
        if (c.indexOf(this.config["class"]) === 0) {
          return c.slice(this.config["class"].length);
        }
      }
    } else if (_.isString(this.config.tag)) {
      return true;
    }
    return void 0;
  };

  return Format;

})();

module.exports = Format;



},{"../lib/dom":17,"lodash":1}],11:[function(_dereq_,module,exports){
var Format, Leaf, LinkedList, _, dom,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

_ = _dereq_('lodash');

dom = _dereq_('../lib/dom');

Format = _dereq_('./format');

LinkedList = _dereq_('../lib/linked-list');

Leaf = (function(superClass) {
  extend(Leaf, superClass);

  Leaf.ID_PREFIX = 'ql-leaf-';

  Leaf.isLeafNode = function(node) {
    return dom(node).isTextNode() || (node.firstChild == null);
  };

  function Leaf(node1, formats) {
    this.node = node1;
    this.formats = _.clone(formats);
    this.id = _.uniqueId(Leaf.ID_PREFIX);
    this.text = dom(this.node).text();
    this.length = this.text.length;
  }

  Leaf.prototype.deleteText = function(offset, length) {
    var textNode;
    if (!(length > 0)) {
      return;
    }
    this.text = this.text.slice(0, offset) + this.text.slice(offset + length);
    this.length = this.text.length;
    if (dom.EMBED_TAGS[this.node.tagName] != null) {
      textNode = document.createTextNode(this.text);
      return this.node = dom(this.node).replace(textNode);
    } else {
      return dom(this.node).text(this.text);
    }
  };

  Leaf.prototype.insertText = function(offset, text) {
    var textNode;
    this.text = this.text.slice(0, offset) + text + this.text.slice(offset);
    if (dom(this.node).isTextNode()) {
      dom(this.node).text(this.text);
    } else {
      textNode = document.createTextNode(text);
      if (this.node.tagName === dom.DEFAULT_BREAK_TAG) {
        this.node = dom(this.node).replace(textNode);
      } else {
        this.node.appendChild(textNode);
        this.node = textNode;
      }
    }
    return this.length = this.text.length;
  };

  return Leaf;

})(LinkedList.Node);

module.exports = Leaf;



},{"../lib/dom":17,"../lib/linked-list":18,"./format":10,"lodash":1}],12:[function(_dereq_,module,exports){
var Delta, Format, Leaf, Line, LinkedList, Normalizer, _, dom,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

_ = _dereq_('lodash');

Delta = _dereq_('rich-text/lib/delta');

dom = _dereq_('../lib/dom');

Format = _dereq_('./format');

Leaf = _dereq_('./leaf');

Line = _dereq_('./line');

LinkedList = _dereq_('../lib/linked-list');

Normalizer = _dereq_('./normalizer');

Line = (function(superClass) {
  extend(Line, superClass);

  Line.CLASS_NAME = 'ql-line';

  Line.ID_PREFIX = 'ql-line-';

  function Line(doc, node1) {
    this.doc = doc;
    this.node = node1;
    this.id = _.uniqueId(Line.ID_PREFIX);
    this.formats = {};
    dom(this.node).addClass(Line.CLASS_NAME);
    this.rebuild();
    Line.__super__.constructor.call(this, this.node);
  }

  Line.prototype.buildLeaves = function(node, formats) {
    return _.each(dom(node).childNodes(), (function(_this) {
      return function(node) {
        var nodeFormats;
        node = _this.doc.normalizer.normalizeNode(node);
        nodeFormats = _.clone(formats);
        _.each(_this.doc.formats, function(format, name) {
          if (!format.isType(Format.types.LINE) && format.match(node)) {
            return nodeFormats[name] = format.value(node);
          }
        });
        if (Leaf.isLeafNode(node)) {
          return _this.leaves.append(new Leaf(node, nodeFormats));
        } else {
          return _this.buildLeaves(node, nodeFormats);
        }
      };
    })(this));
  };

  Line.prototype.deleteText = function(offset, length) {
    var deleteLength, leaf, ref;
    if (!(length > 0)) {
      return;
    }
    ref = this.findLeafAt(offset), leaf = ref[0], offset = ref[1];
    while ((leaf != null) && length > 0) {
      deleteLength = Math.min(length, leaf.length - offset);
      leaf.deleteText(offset, deleteLength);
      length -= deleteLength;
      leaf = leaf.next;
      offset = 0;
    }
    return this.rebuild();
  };

  Line.prototype.findLeaf = function(leafNode) {
    var curLeaf;
    curLeaf = this.leaves.first;
    while (curLeaf != null) {
      if (curLeaf.node === leafNode) {
        return curLeaf;
      }
      curLeaf = curLeaf.next;
    }
    return null;
  };

  Line.prototype.findLeafAt = function(offset, inclusive) {
    var leaf;
    if (inclusive == null) {
      inclusive = false;
    }
    if (offset >= this.length - 1) {
      return [this.leaves.last, this.leaves.last.length];
    }
    leaf = this.leaves.first;
    while (leaf != null) {
      if (offset < leaf.length || (offset === leaf.length && inclusive)) {
        return [leaf, offset];
      }
      offset -= leaf.length;
      leaf = leaf.next;
    }
    return [this.leaves.last, offset - this.leaves.last.length];
  };

  Line.prototype.format = function(name, value) {
    var formats;
    if (_.isObject(name)) {
      formats = name;
    } else {
      formats = {};
      formats[name] = value;
    }
    _.each(formats, (function(_this) {
      return function(value, name) {
        var excludeFormat, format;
        format = _this.doc.formats[name];
        if (format == null) {
          return;
        }
        if (format.isType(Format.types.LINE)) {
          if (format.config.exclude && _this.formats[format.config.exclude]) {
            excludeFormat = _this.doc.formats[format.config.exclude];
            if (excludeFormat != null) {
              _this.node = excludeFormat.remove(_this.node);
              delete _this.formats[format.config.exclude];
            }
          }
          _this.node = format.add(_this.node, value);
        }
        if (value) {
          return _this.formats[name] = value;
        } else {
          return delete _this.formats[name];
        }
      };
    })(this));
    return this.resetContent();
  };

  Line.prototype.formatText = function(offset, length, name, value) {
    var format, leaf, leafOffset, leftNode, nextLeaf, ref, ref1, ref2, rightNode, targetNode;
    ref = this.findLeafAt(offset), leaf = ref[0], leafOffset = ref[1];
    format = this.doc.formats[name];
    if (!((format != null) && format.config.type !== Format.types.LINE)) {
      return;
    }
    while ((leaf != null) && length > 0) {
      nextLeaf = leaf.next;
      if ((value && leaf.formats[name] !== value) || (!value && (leaf.formats[name] != null))) {
        targetNode = leaf.node;
        if (leaf.formats[name] != null) {
          dom(targetNode).splitBefore(this.node);
          while (!format.match(targetNode)) {
            targetNode = targetNode.parentNode;
          }
          dom(targetNode).split(leaf.length);
        }
        if (leafOffset > 0) {
          ref1 = dom(targetNode).split(leafOffset), leftNode = ref1[0], targetNode = ref1[1];
        }
        if (leaf.length > leafOffset + length) {
          ref2 = dom(targetNode).split(length), targetNode = ref2[0], rightNode = ref2[1];
        }
        format.add(targetNode, value);
      }
      length -= leaf.length - leafOffset;
      leafOffset = 0;
      leaf = nextLeaf;
    }
    return this.rebuild();
  };

  Line.prototype.insertText = function(offset, text, formats) {
    var leaf, leafOffset, nextNode, node, prevNode, ref, ref1;
    if (formats == null) {
      formats = {};
    }
    if (!(text.length > 0)) {
      return;
    }
    ref = this.findLeafAt(offset), leaf = ref[0], leafOffset = ref[1];
    if (_.isEqual(leaf.formats, formats)) {
      leaf.insertText(leafOffset, text);
      return this.resetContent();
    } else {
      node = _.reduce(formats, (function(_this) {
        return function(node, value, name) {
          var format;
          format = _this.doc.formats[name];
          if (format != null) {
            node = format.add(node, value);
          }
          return node;
        };
      })(this), document.createTextNode(text));
      ref1 = dom(leaf.node).split(leafOffset), prevNode = ref1[0], nextNode = ref1[1];
      if (nextNode) {
        nextNode = dom(nextNode).splitBefore(this.node).get();
      }
      this.node.insertBefore(node, nextNode);
      return this.rebuild();
    }
  };

  Line.prototype.optimize = function() {
    Normalizer.optimizeLine(this.node);
    return this.rebuild();
  };

  Line.prototype.rebuild = function(force) {
    if (force == null) {
      force = false;
    }
    if (!force && (this.outerHTML != null) && this.outerHTML === this.node.outerHTML) {
      if (_.all(this.leaves.toArray(), (function(_this) {
        return function(leaf) {
          return dom(leaf.node).isAncestor(_this.node);
        };
      })(this))) {
        return false;
      }
    }
    this.node = this.doc.normalizer.normalizeNode(this.node);
    if (dom(this.node).length() === 0 && !this.node.querySelector(dom.DEFAULT_BREAK_TAG)) {
      this.node.appendChild(document.createElement(dom.DEFAULT_BREAK_TAG));
    }
    this.leaves = new LinkedList();
    this.formats = _.reduce(this.doc.formats, (function(_this) {
      return function(formats, format, name) {
        if (format.isType(Format.types.LINE)) {
          if (format.match(_this.node)) {
            formats[name] = format.value(_this.node);
          } else {
            delete formats[name];
          }
        }
        return formats;
      };
    })(this), this.formats);
    this.buildLeaves(this.node, {});
    this.resetContent();
    return true;
  };

  Line.prototype.resetContent = function() {
    if (this.node.id !== this.id) {
      this.node.id = this.id;
    }
    this.outerHTML = this.node.outerHTML;
    this.length = 1;
    this.delta = new Delta();
    _.each(this.leaves.toArray(), (function(_this) {
      return function(leaf) {
        _this.length += leaf.length;
        if (dom.EMBED_TAGS[leaf.node.tagName] != null) {
          return _this.delta.insert(1, leaf.formats);
        } else {
          return _this.delta.insert(leaf.text, leaf.formats);
        }
      };
    })(this));
    return this.delta.insert('\n', this.formats);
  };

  return Line;

})(LinkedList.Node);

module.exports = Line;



},{"../lib/dom":17,"../lib/linked-list":18,"./format":10,"./leaf":11,"./line":12,"./normalizer":13,"lodash":1,"rich-text/lib/delta":3}],13:[function(_dereq_,module,exports){
var Normalizer, _, camelize, dom;

_ = _dereq_('lodash');

dom = _dereq_('../lib/dom');

camelize = function(str) {
  str = str.replace(/(?:^|[-_])(\w)/g, function(i, c) {
    if (c) {
      return c.toUpperCase();
    } else {
      return '';
    }
  });
  return str.charAt(0).toLowerCase() + str.slice(1);
};

Normalizer = (function() {
  Normalizer.ALIASES = {
    'STRONG': 'B',
    'EM': 'I',
    'DEL': 'S',
    'STRIKE': 'S'
  };

  Normalizer.ATTRIBUTES = {
    'color': 'color',
    'face': 'fontFamily',
    'size': 'fontSize'
  };

  function Normalizer() {
    this.whitelist = {
      styles: {},
      tags: {}
    };
    this.whitelist.tags[dom.DEFAULT_BREAK_TAG] = true;
    this.whitelist.tags[dom.DEFAULT_BLOCK_TAG] = true;
    this.whitelist.tags[dom.DEFAULT_INLINE_TAG] = true;
  }

  Normalizer.prototype.addFormat = function(config) {
    if (config.tag != null) {
      this.whitelist.tags[config.tag] = true;
    }
    if (config.parentTag != null) {
      this.whitelist.tags[config.parentTag] = true;
    }
    if (config.style != null) {
      return this.whitelist.styles[config.style] = true;
    }
  };

  Normalizer.prototype.normalizeLine = function(lineNode) {
    lineNode = Normalizer.wrapInline(lineNode);
    lineNode = Normalizer.handleBreaks(lineNode);
    lineNode = Normalizer.pullBlocks(lineNode);
    lineNode = this.normalizeNode(lineNode);
    Normalizer.unwrapText(lineNode);
    if ((lineNode != null) && (dom.LIST_TAGS[lineNode.tagName] != null)) {
      lineNode = lineNode.firstChild;
    }
    return lineNode;
  };

  Normalizer.prototype.normalizeNode = function(node) {
    if (dom(node).isTextNode()) {
      return node;
    }
    _.each(Normalizer.ATTRIBUTES, function(style, attribute) {
      var value;
      if (node.hasAttribute(attribute)) {
        value = node.getAttribute(attribute);
        if (attribute === 'size') {
          value = dom.convertFontSize(value);
        }
        node.style[style] = value;
        return node.removeAttribute(attribute);
      }
    });
    this.whitelistStyles(node);
    return this.whitelistTags(node);
  };

  Normalizer.prototype.whitelistStyles = function(node) {
    var original, styles;
    original = dom(node).styles();
    styles = _.omit(original, (function(_this) {
      return function(value, key) {
        return _this.whitelist.styles[camelize(key)] == null;
      };
    })(this));
    if (Object.keys(styles).length < Object.keys(original).length) {
      if (Object.keys(styles).length > 0) {
        return dom(node).styles(styles, true);
      } else {
        return node.removeAttribute('style');
      }
    }
  };

  Normalizer.prototype.whitelistTags = function(node) {
    if (!dom(node).isElement()) {
      return node;
    }
    if (Normalizer.ALIASES[node.tagName] != null) {
      node = dom(node).switchTag(Normalizer.ALIASES[node.tagName]);
    } else if (this.whitelist.tags[node.tagName] == null) {
      if (dom.BLOCK_TAGS[node.tagName] != null) {
        node = dom(node).switchTag(dom.DEFAULT_BLOCK_TAG);
      } else if (!node.hasAttributes() && (node.firstChild != null)) {
        node = dom(node).unwrap();
      } else {
        node = dom(node).switchTag(dom.DEFAULT_INLINE_TAG);
      }
    }
    return node;
  };

  Normalizer.handleBreaks = function(lineNode) {
    var breaks;
    breaks = _.map(lineNode.querySelectorAll(dom.DEFAULT_BREAK_TAG));
    _.each(breaks, (function(_this) {
      return function(br) {
        if ((br.nextSibling != null) && (!dom.isIE(10) || (br.previousSibling != null))) {
          return dom(br.nextSibling).splitBefore(lineNode.parentNode);
        }
      };
    })(this));
    return lineNode;
  };

  Normalizer.optimizeLine = function(lineNode) {
    var lineNodeLength, node, nodes, results;
    lineNode.normalize();
    lineNodeLength = dom(lineNode).length();
    nodes = dom(lineNode).descendants();
    results = [];
    while (nodes.length > 0) {
      node = nodes.pop();
      if ((node != null ? node.parentNode : void 0) == null) {
        continue;
      }
      if (dom.EMBED_TAGS[node.tagName] != null) {
        continue;
      }
      if (node.tagName === dom.DEFAULT_BREAK_TAG) {
        if (lineNodeLength !== 0) {
          results.push(dom(node).remove());
        } else {
          results.push(void 0);
        }
      } else if (dom(node).length() === 0) {
        nodes.push(node.nextSibling);
        results.push(dom(node).unwrap());
      } else if ((node.previousSibling != null) && node.tagName === node.previousSibling.tagName) {
        if (_.isEqual(dom(node).attributes(), dom(node.previousSibling).attributes())) {
          nodes.push(node.firstChild);
          results.push(dom(node.previousSibling).merge(node));
        } else {
          results.push(void 0);
        }
      } else {
        results.push(void 0);
      }
    }
    return results;
  };

  Normalizer.pullBlocks = function(lineNode) {
    var curNode;
    curNode = lineNode.firstChild;
    while (curNode != null) {
      if ((dom.BLOCK_TAGS[curNode.tagName] != null) && curNode.tagName !== 'LI') {
        dom(curNode).isolate(lineNode.parentNode);
        if ((dom.LIST_TAGS[curNode.tagName] == null) || !curNode.firstChild) {
          dom(curNode).unwrap();
          Normalizer.pullBlocks(lineNode);
        } else {
          dom(curNode.parentNode).unwrap();
          if (lineNode.parentNode == null) {
            lineNode = curNode;
          }
        }
        break;
      }
      curNode = curNode.nextSibling;
    }
    return lineNode;
  };

  Normalizer.stripComments = function(html) {
    return html.replace(/<!--[\s\S]*?-->/g, '');
  };

  Normalizer.stripWhitespace = function(html) {
    html = html.trim();
    html = html.replace(/(\r?\n|\r)+/g, ' ');
    html = html.replace(/\>\s+\</g, '><');
    return html;
  };

  Normalizer.wrapInline = function(lineNode) {
    var blockNode, nextNode;
    if (dom.BLOCK_TAGS[lineNode.tagName] != null) {
      return lineNode;
    }
    blockNode = document.createElement(dom.DEFAULT_BLOCK_TAG);
    lineNode.parentNode.insertBefore(blockNode, lineNode);
    while ((lineNode != null) && (dom.BLOCK_TAGS[lineNode.tagName] == null)) {
      nextNode = lineNode.nextSibling;
      blockNode.appendChild(lineNode);
      lineNode = nextNode;
    }
    return blockNode;
  };

  Normalizer.unwrapText = function(lineNode) {
    var spans;
    spans = _.map(lineNode.querySelectorAll(dom.DEFAULT_INLINE_TAG));
    return _.each(spans, function(span) {
      if (!span.hasAttributes()) {
        return dom(span).unwrap();
      }
    });
  };

  return Normalizer;

})();

module.exports = Normalizer;



},{"../lib/dom":17,"lodash":1}],14:[function(_dereq_,module,exports){
var Leaf, Normalizer, Range, Selection, _, dom;

_ = _dereq_('lodash');

dom = _dereq_('../lib/dom');

Leaf = _dereq_('./leaf');

Normalizer = _dereq_('./normalizer');

Range = _dereq_('../lib/range');

Selection = (function() {
  function Selection(doc, emitter) {
    this.doc = doc;
    this.emitter = emitter;
    this.focus = false;
    this.range = new Range(0, 0);
    this.nullDelay = false;
    this.update('silent');
  }

  Selection.prototype.checkFocus = function() {
    return document.activeElement === this.doc.root;
  };

  Selection.prototype.getRange = function(ignoreFocus) {
    var end, nativeRange, start;
    if (ignoreFocus == null) {
      ignoreFocus = false;
    }
    if (this.checkFocus()) {
      nativeRange = this._getNativeRange();
      if (nativeRange == null) {
        return null;
      }
      start = this._positionToIndex(nativeRange.startContainer, nativeRange.startOffset);
      if (nativeRange.startContainer === nativeRange.endContainer && nativeRange.startOffset === nativeRange.endOffset) {
        end = start;
      } else {
        end = this._positionToIndex(nativeRange.endContainer, nativeRange.endOffset);
      }
      return new Range(Math.min(start, end), Math.max(start, end));
    } else if (ignoreFocus) {
      return this.range;
    } else {
      return null;
    }
  };

  Selection.prototype.preserve = function(fn) {
    var endNode, endOffset, nativeRange, ref, ref1, ref2, ref3, startNode, startOffset;
    nativeRange = this._getNativeRange();
    if ((nativeRange != null) && this.checkFocus()) {
      ref = this._encodePosition(nativeRange.startContainer, nativeRange.startOffset), startNode = ref[0], startOffset = ref[1];
      ref1 = this._encodePosition(nativeRange.endContainer, nativeRange.endOffset), endNode = ref1[0], endOffset = ref1[1];
      fn();
      ref2 = this._decodePosition(startNode, startOffset), startNode = ref2[0], startOffset = ref2[1];
      ref3 = this._decodePosition(endNode, endOffset), endNode = ref3[0], endOffset = ref3[1];
      return this._setNativeRange(startNode, startOffset, endNode, endOffset);
    } else {
      return fn();
    }
  };

  Selection.prototype.setRange = function(range, source) {
    var endNode, endOffset, ref, ref1, ref2, startNode, startOffset;
    if (range != null) {
      ref = this._indexToPosition(range.start), startNode = ref[0], startOffset = ref[1];
      if (range.isCollapsed()) {
        ref1 = [startNode, startOffset], endNode = ref1[0], endOffset = ref1[1];
      } else {
        ref2 = this._indexToPosition(range.end), endNode = ref2[0], endOffset = ref2[1];
      }
      this._setNativeRange(startNode, startOffset, endNode, endOffset);
    } else {
      this._setNativeRange(null);
    }
    return this.update(source);
  };

  Selection.prototype.shiftAfter = function(index, length, fn) {
    var range;
    range = this.getRange();
    fn();
    if (range != null) {
      range.shift(index, length);
      return this.setRange(range, 'silent');
    }
  };

  Selection.prototype.update = function(source) {
    var emit, focus, range, toEmit;
    focus = this.checkFocus();
    range = this.getRange(true);
    emit = source !== 'silent' && (!Range.compare(range, this.range) || focus !== this.focus);
    toEmit = focus ? range : null;
    if (toEmit === null && source === 'user' && !this.nullDelay) {
      return this.nullDelay = true;
    } else {
      this.nullDelay = false;
      this.range = range;
      this.focus = focus;
      if (emit) {
        return this.emitter.emit(this.emitter.constructor.events.SELECTION_CHANGE, toEmit, source);
      }
    }
  };

  Selection.prototype._decodePosition = function(node, offset) {
    var childIndex;
    if (dom(node).isElement()) {
      childIndex = dom(node.parentNode).childNodes().indexOf(node);
      offset += childIndex;
      node = node.parentNode;
    }
    return [node, offset];
  };

  Selection.prototype._encodePosition = function(node, offset) {
    var text;
    while (true) {
      if (dom(node).isTextNode() || node.tagName === dom.DEFAULT_BREAK_TAG || (dom.EMBED_TAGS[node.tagName] != null)) {
        return [node, offset];
      } else if (offset < node.childNodes.length) {
        node = node.childNodes[offset];
        offset = 0;
      } else if (node.childNodes.length === 0) {
        if (this.doc.normalizer.whitelist.tags[node.tagName] == null) {
          text = document.createTextNode('');
          node.appendChild(text);
          node = text;
        }
        return [node, 0];
      } else {
        node = node.lastChild;
        if (dom(node).isElement()) {
          if (node.tagName === dom.DEFAULT_BREAK_TAG || (dom.EMBED_TAGS[node.tagName] != null)) {
            return [node, 1];
          } else {
            offset = node.childNodes.length;
          }
        } else {
          return [node, dom(node).length()];
        }
      }
    }
  };

  Selection.prototype._getNativeRange = function() {
    var range, selection;
    selection = document.getSelection();
    if ((selection != null ? selection.rangeCount : void 0) > 0) {
      range = selection.getRangeAt(0);
      if (dom(range.startContainer).isAncestor(this.doc.root, true)) {
        if (range.startContainer === range.endContainer || dom(range.endContainer).isAncestor(this.doc.root, true)) {
          return range;
        }
      }
    }
    return null;
  };

  Selection.prototype._indexToPosition = function(index) {
    var leaf, offset, ref;
    if (this.doc.lines.length === 0) {
      return [this.doc.root, 0];
    }
    ref = this.doc.findLeafAt(index, true), leaf = ref[0], offset = ref[1];
    return this._decodePosition(leaf.node, offset);
  };

  Selection.prototype._positionToIndex = function(node, offset) {
    var leaf, leafNode, leafOffset, line, lineOffset, ref;
    if (dom.isIE(10) && node.tagName === 'BR' && offset === 1) {
      offset = 0;
    }
    ref = this._encodePosition(node, offset), leafNode = ref[0], offset = ref[1];
    line = this.doc.findLine(leafNode);
    if (line == null) {
      return 0;
    }
    leaf = line.findLeaf(leafNode);
    lineOffset = 0;
    while (line.prev != null) {
      line = line.prev;
      lineOffset += line.length;
    }
    if (leaf == null) {
      return lineOffset;
    }
    leafOffset = 0;
    while (leaf.prev != null) {
      leaf = leaf.prev;
      leafOffset += leaf.length;
    }
    return lineOffset + leafOffset + offset;
  };

  Selection.prototype._setNativeRange = function(startNode, startOffset, endNode, endOffset) {
    var nativeRange, selection;
    selection = document.getSelection();
    if (!selection) {
      return;
    }
    if (startNode != null) {
      if (!this.checkFocus()) {
        this.doc.root.focus();
      }
      nativeRange = this._getNativeRange();
      if ((nativeRange == null) || startNode !== nativeRange.startContainer || startOffset !== nativeRange.startOffset || endNode !== nativeRange.endContainer || endOffset !== nativeRange.endOffset) {
        selection.removeAllRanges();
        nativeRange = document.createRange();
        nativeRange.setStart(startNode, startOffset);
        nativeRange.setEnd(endNode, endOffset);
        return selection.addRange(nativeRange);
      }
    } else {
      selection.removeAllRanges();
      this.doc.root.blur();
      if (dom.isIE(11) && !dom.isIE(9)) {
        return document.body.focus();
      }
    }
  };

  return Selection;

})();

module.exports = Selection;



},{"../lib/dom":17,"../lib/range":20,"./leaf":11,"./normalizer":13,"lodash":1}],15:[function(_dereq_,module,exports){
_dereq_('./modules/authorship');

_dereq_('./modules/image-tooltip');

_dereq_('./modules/keyboard');

_dereq_('./modules/link-tooltip');

_dereq_('./modules/multi-cursor');

_dereq_('./modules/paste-manager');

_dereq_('./modules/toolbar');

_dereq_('./modules/tooltip');

_dereq_('./modules/undo-manager');

module.exports = _dereq_('./quill');



},{"./modules/authorship":21,"./modules/image-tooltip":22,"./modules/keyboard":23,"./modules/link-tooltip":24,"./modules/multi-cursor":25,"./modules/paste-manager":26,"./modules/toolbar":27,"./modules/tooltip":28,"./modules/undo-manager":29,"./quill":30}],16:[function(_dereq_,module,exports){
var ColorPicker, Picker, dom,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

dom = _dereq_('./dom');

Picker = _dereq_('./picker');

ColorPicker = (function(superClass) {
  extend(ColorPicker, superClass);

  function ColorPicker() {
    ColorPicker.__super__.constructor.apply(this, arguments);
    dom(this.container).addClass('ql-color-picker');
  }

  ColorPicker.prototype.buildItem = function(picker, option, index) {
    var item;
    item = ColorPicker.__super__.buildItem.call(this, picker, option, index);
    item.style.backgroundColor = option.value;
    return item;
  };

  return ColorPicker;

})(Picker);

module.exports = ColorPicker;



},{"./dom":17,"./picker":19}],17:[function(_dereq_,module,exports){
var SelectWrapper, Wrapper, _, dom, lastKeyEvent,
  bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

_ = _dereq_('lodash');

lastKeyEvent = null;

Wrapper = (function() {
  function Wrapper(node1) {
    this.node = node1;
    this.trigger = bind(this.trigger, this);
  }

  Wrapper.prototype.addClass = function(cssClass) {
    if (this.hasClass(cssClass)) {
      return;
    }
    if (this.node.classList != null) {
      this.node.classList.add(cssClass);
    } else if (this.node.className != null) {
      this.node.className = (this.node.className + ' ' + cssClass).trim();
    }
    return this;
  };

  Wrapper.prototype.attributes = function(attributes) {
    var attr, i, j, len, ref, value;
    if (attributes) {
      _.each(attributes, (function(_this) {
        return function(value, name) {
          return _this.node.setAttribute(name, value);
        };
      })(this));
      return this;
    } else {
      if (this.node.attributes == null) {
        return {};
      }
      attributes = {};
      ref = this.node.attributes;
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        value = ref[i];
        attr = this.node.attributes[i];
        attributes[attr.name] = attr.value;
      }
      return attributes;
    }
  };

  Wrapper.prototype.child = function(offset) {
    var child, length;
    child = this.node.firstChild;
    length = dom(child).length();
    while (child != null) {
      if (offset < length) {
        break;
      }
      offset -= length;
      child = child.nextSibling;
      length = dom(child).length();
    }
    if (child == null) {
      child = this.node.lastChild;
      offset = dom(child).length();
    }
    return [child, offset];
  };

  Wrapper.prototype.childNodes = function() {
    return _.map(this.node.childNodes);
  };

  Wrapper.prototype.classes = function() {
    return this.node.className.split(/\s+/);
  };

  Wrapper.prototype.descendants = function() {
    return _.map(this.node.getElementsByTagName('*'));
  };

  Wrapper.prototype.get = function() {
    return this.node;
  };

  Wrapper.prototype.hasClass = function(cssClass) {
    if (this.node.classList != null) {
      return this.node.classList.contains(cssClass);
    } else if (this.node.className != null) {
      return this.classes().indexOf(cssClass) > -1;
    }
    return false;
  };

  Wrapper.prototype.isAncestor = function(ancestor, inclusive) {
    var node;
    if (inclusive == null) {
      inclusive = false;
    }
    if (ancestor === this.node) {
      return inclusive;
    }
    node = this.node;
    while (node) {
      if (node === ancestor) {
        return true;
      }
      node = node.parentNode;
    }
    return false;
  };

  Wrapper.prototype.isElement = function() {
    var ref;
    return ((ref = this.node) != null ? ref.nodeType : void 0) === dom.ELEMENT_NODE;
  };

  Wrapper.prototype.isTextNode = function() {
    var ref;
    return ((ref = this.node) != null ? ref.nodeType : void 0) === dom.TEXT_NODE;
  };

  Wrapper.prototype.isolate = function(root) {
    if (this.node.nextSibling != null) {
      dom(this.node.nextSibling).splitBefore(root);
    }
    this.splitBefore(root);
    return this;
  };

  Wrapper.prototype.length = function() {
    var length;
    if (this.node == null) {
      return 0;
    }
    length = this.text().length;
    if (this.isElement()) {
      length += this.node.querySelectorAll(Object.keys(dom.EMBED_TAGS).join(',')).length;
    }
    return length;
  };

  Wrapper.prototype.merge = function(node) {
    var $node;
    $node = dom(node);
    if (this.isElement()) {
      $node.moveChildren(this.node);
      this.normalize();
    } else {
      this.text(this.text() + $node.text());
    }
    $node.remove();
    return this;
  };

  Wrapper.prototype.moveChildren = function(newParent) {
    _.each(this.childNodes(), function(child) {
      return newParent.appendChild(child);
    });
    return this;
  };

  Wrapper.prototype.nextLineNode = function(root) {
    var nextNode;
    nextNode = this.node.nextSibling;
    if ((nextNode == null) && this.node.parentNode !== root) {
      nextNode = this.node.parentNode.nextSibling;
    }
    if ((nextNode != null) && (dom.LIST_TAGS[nextNode.tagName] != null)) {
      nextNode = nextNode.firstChild;
    }
    return nextNode;
  };

  Wrapper.prototype.normalize = function() {
    var $node, curNode, followingNode, nextNode;
    curNode = this.node.firstChild;
    while (curNode != null) {
      nextNode = curNode.nextSibling;
      $node = dom(curNode);
      if ((nextNode != null) && dom(nextNode).isTextNode()) {
        if ($node.text().length === 0) {
          $node.remove();
        } else if ($node.isTextNode()) {
          followingNode = nextNode.nextSibling;
          $node.merge(nextNode);
          nextNode = followingNode;
        }
      }
      curNode = nextNode;
    }
    return this;
  };

  Wrapper.prototype.on = function(eventName, listener) {
    this.node.addEventListener(eventName, (function(_this) {
      return function(event) {
        var arg, propagate;
        arg = lastKeyEvent && (eventName === 'keydown' || eventName === 'keyup') ? lastKeyEvent : event;
        propagate = listener.call(_this.node, arg);
        if (!propagate) {
          event.preventDefault();
          event.stopPropagation();
        }
        return propagate;
      };
    })(this));
    return this;
  };

  Wrapper.prototype.remove = function() {
    var ref;
    if ((ref = this.node.parentNode) != null) {
      ref.removeChild(this.node);
    }
    this.node = null;
    return null;
  };

  Wrapper.prototype.removeClass = function(cssClass) {
    var classArray;
    if (!this.hasClass(cssClass)) {
      return;
    }
    if (this.node.classList != null) {
      this.node.classList.remove(cssClass);
    } else if (this.node.className != null) {
      classArray = this.classes();
      classArray.splice(classArray.indexOf(cssClass), 1);
      this.node.className = classArray.join(' ');
    }
    if (!this.node.getAttribute('class')) {
      this.node.removeAttribute('class');
    }
    return this;
  };

  Wrapper.prototype.replace = function(newNode) {
    this.node.parentNode.replaceChild(newNode, this.node);
    this.node = newNode;
    return newNode;
  };

  Wrapper.prototype.splitBefore = function(root, force) {
    var nextNode, parentClone, parentNode, refNode;
    if (force == null) {
      force = false;
    }
    if (this.node === root || this.node.parentNode === root) {
      return this;
    }
    if ((this.node.previousSibling != null) || force) {
      parentNode = this.node.parentNode;
      parentClone = parentNode.cloneNode(false);
      parentNode.parentNode.insertBefore(parentClone, parentNode.nextSibling);
      refNode = this.node;
      while (refNode != null) {
        nextNode = refNode.nextSibling;
        parentClone.appendChild(refNode);
        refNode = nextNode;
      }
      return dom(parentClone).splitBefore(root);
    } else {
      return dom(this.node.parentNode).splitBefore(root);
    }
  };

  Wrapper.prototype.split = function(offset, force) {
    var after, child, childLeft, childRight, left, nextRight, nodeLength, ref, ref1, right;
    if (force == null) {
      force = false;
    }
    nodeLength = this.length();
    offset = Math.max(0, offset);
    offset = Math.min(offset, nodeLength);
    if (!(force || offset !== 0)) {
      return [this.node.previousSibling, this.node, false];
    }
    if (!(force || offset !== nodeLength)) {
      return [this.node, this.node.nextSibling, false];
    }
    if (this.node.nodeType === dom.TEXT_NODE) {
      after = this.node.splitText(offset);
      return [this.node, after, true];
    } else {
      left = this.node;
      right = this.node.cloneNode(false);
      this.node.parentNode.insertBefore(right, left.nextSibling);
      ref = this.child(offset), child = ref[0], offset = ref[1];
      ref1 = dom(child).split(offset), childLeft = ref1[0], childRight = ref1[1];
      while (childRight !== null) {
        nextRight = childRight.nextSibling;
        right.appendChild(childRight);
        childRight = nextRight;
      }
      return [left, right, true];
    }
  };

  Wrapper.prototype.styles = function(styles, overwrite) {
    var obj, styleString;
    if (overwrite == null) {
      overwrite = false;
    }
    if (styles) {
      if (!overwrite) {
        styles = _.defaults(styles, this.styles());
      }
      styleString = _.map(styles, function(style, name) {
        return name + ": " + style;
      }).join('; ') + ';';
      this.node.setAttribute('style', styleString);
      return this;
    } else {
      styleString = this.node.getAttribute('style') || '';
      obj = _.reduce(styleString.split(';'), function(styles, str) {
        var name, ref, value;
        ref = str.split(':'), name = ref[0], value = ref[1];
        if (name && value) {
          name = name.trim();
          value = value.trim();
          styles[name.toLowerCase()] = value;
        }
        return styles;
      }, {});
      return obj;
    }
  };

  Wrapper.prototype.switchTag = function(newTag) {
    var attributes, newNode;
    newTag = newTag.toUpperCase();
    if (this.node.tagName === newTag) {
      return this;
    }
    newNode = document.createElement(newTag);
    attributes = this.attributes();
    if (dom.VOID_TAGS[newTag] == null) {
      this.moveChildren(newNode);
    }
    this.replace(newNode);
    return this.attributes(attributes).get();
  };

  Wrapper.prototype.text = function(text) {
    if (text != null) {
      switch (this.node.nodeType) {
        case dom.ELEMENT_NODE:
          this.node.textContent = text;
          break;
        case dom.TEXT_NODE:
          this.node.data = text;
      }
      return this;
    } else {
      switch (this.node.nodeType) {
        case dom.ELEMENT_NODE:
          if (this.node.tagName === dom.DEFAULT_BREAK_TAG) {
            return "";
          }
          if (dom.EMBED_TAGS[this.node.tagName] != null) {
            return dom.EMBED_TEXT;
          }
          if (this.node.textContent != null) {
            return this.node.textContent;
          }
          return "";
        case dom.TEXT_NODE:
          return this.node.data || "";
        default:
          return "";
      }
    }
  };

  Wrapper.prototype.textNodes = function() {
    var textNode, textNodes, walker;
    walker = document.createTreeWalker(this.node, NodeFilter.SHOW_TEXT, null, false);
    textNodes = [];
    while (textNode = walker.nextNode()) {
      textNodes.push(textNode);
    }
    return textNodes;
  };

  Wrapper.prototype.toggleClass = function(className, state) {
    if (state == null) {
      state = !this.hasClass(className);
    }
    if (state) {
      this.addClass(className);
    } else {
      this.removeClass(className);
    }
    return this;
  };

  Wrapper.prototype.trigger = function(eventName, options) {
    var event, initFn, modifiers;
    if (options == null) {
      options = {};
    }
    if (['keypress', 'keydown', 'keyup'].indexOf(eventName) < 0) {
      event = document.createEvent('Event');
      event.initEvent(eventName, options.bubbles, options.cancelable);
    } else {
      event = document.createEvent('KeyboardEvent');
      lastKeyEvent = _.clone(options);
      if (_.isNumber(options.key)) {
        lastKeyEvent.which = options.key;
      } else if (_.isString(options.key)) {
        lastKeyEvent.which = options.key.toUpperCase().charCodeAt(0);
      } else {
        lastKeyEvent.which = 0;
      }
      if (dom.isIE(10)) {
        modifiers = [];
        if (options.altKey) {
          modifiers.push('Alt');
        }
        if (options.ctrlKey) {
          modifiers.push('Control');
        }
        if (options.metaKey) {
          modifiers.push('Meta');
        }
        if (options.shiftKey) {
          modifiers.push('Shift');
        }
        event.initKeyboardEvent(eventName, options.bubbles, options.cancelable, window, 0, 0, modifiers.join(' '), null, null);
      } else {
        initFn = _.isFunction(event.initKeyboardEvent) ? 'initKeyboardEvent' : 'initKeyEvent';
        event[initFn](eventName, options.bubbles, options.cancelable, window, options.ctrlKey, options.altKey, options.shiftKey, options.metaKey, 0, 0);
      }
    }
    this.node.dispatchEvent(event);
    lastKeyEvent = null;
    return this;
  };

  Wrapper.prototype.unwrap = function() {
    var next, ret;
    ret = this.node.firstChild;
    next = this.node.nextSibling;
    _.each(this.childNodes(), (function(_this) {
      return function(child) {
        return _this.node.parentNode.insertBefore(child, next);
      };
    })(this));
    this.remove();
    return ret;
  };

  Wrapper.prototype.wrap = function(wrapper) {
    var parent;
    if (this.node.parentNode != null) {
      this.node.parentNode.insertBefore(wrapper, this.node);
    }
    parent = wrapper;
    while (parent.firstChild != null) {
      parent = wrapper.firstChild;
    }
    parent.appendChild(this.node);
    return this;
  };

  return Wrapper;

})();

SelectWrapper = (function(superClass) {
  extend(SelectWrapper, superClass);

  function SelectWrapper() {
    return SelectWrapper.__super__.constructor.apply(this, arguments);
  }

  SelectWrapper.prototype["default"] = function() {
    return this.node.querySelector('option[selected]');
  };

  SelectWrapper.prototype.option = function(option, trigger) {
    var child, i, j, len, ref, value;
    if (trigger == null) {
      trigger = true;
    }
    value = _.isElement(option) ? option.value : option;
    if (value) {
      value = value.replace(/[^\w]+/g, '');
      ref = this.node.children;
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        child = ref[i];
        if (child.value.replace(/[^\w]+/g, '') === value) {
          this.node.selectedIndex = i;
          break;
        }
      }
    } else {
      this.node.selectedIndex = -1;
    }
    if (trigger) {
      this.trigger('change');
    }
    return this;
  };

  SelectWrapper.prototype.reset = function(trigger) {
    var option;
    if (trigger == null) {
      trigger = true;
    }
    option = this["default"]();
    if (option != null) {
      option.selected = true;
    } else {
      this.node.selectedIndex = 0;
    }
    if (trigger) {
      this.trigger('change');
    }
    return this;
  };

  SelectWrapper.prototype.value = function() {
    if (this.node.selectedIndex > -1) {
      return this.node.options[this.node.selectedIndex].value;
    } else {
      return '';
    }
  };

  return SelectWrapper;

})(Wrapper);

dom = function(node) {
  if ((node != null ? node.tagName : void 0) === 'SELECT') {
    return new SelectWrapper(node);
  } else {
    return new Wrapper(node);
  }
};

dom = _.extend(dom, {
  ELEMENT_NODE: 1,
  NOBREAK_SPACE: "&nbsp;",
  TEXT_NODE: 3,
  ZERO_WIDTH_NOBREAK_SPACE: "\uFEFF",
  DEFAULT_BLOCK_TAG: 'DIV',
  DEFAULT_BREAK_TAG: 'BR',
  DEFAULT_INLINE_TAG: 'SPAN',
  EMBED_TEXT: '!',
  FONT_SIZES: {
    '10px': 1,
    '13px': 2,
    '16px': 3,
    '18px': 4,
    '24px': 5,
    '32px': 6,
    '48px': 7
  },
  KEYS: {
    BACKSPACE: 8,
    TAB: 9,
    ENTER: 13,
    ESCAPE: 27,
    LEFT: 37,
    UP: 38,
    RIGHT: 39,
    DOWN: 40,
    DELETE: 46
  },
  BLOCK_TAGS: {
    'ADDRESS': 'ADDRESS',
    'ARTICLE': 'ARTICLE',
    'ASIDE': 'ASIDE',
    'AUDIO': 'AUDIO',
    'BLOCKQUOTE': 'BLOCKQUOTE',
    'CANVAS': 'CANVAS',
    'DD': 'DD',
    'DIV': 'DIV',
    'DL': 'DL',
    'FIGCAPTION': 'FIGCAPTION',
    'FIGURE': 'FIGURE',
    'FOOTER': 'FOOTER',
    'FORM': 'FORM',
    'H1': 'H1',
    'H2': 'H2',
    'H3': 'H3',
    'H4': 'H4',
    'H5': 'H5',
    'H6': 'H6',
    'HEADER': 'HEADER',
    'HGROUP': 'HGROUP',
    'LI': 'LI',
    'OL': 'OL',
    'OUTPUT': 'OUTPUT',
    'P': 'P',
    'PRE': 'PRE',
    'SECTION': 'SECTION',
    'TABLE': 'TABLE',
    'TBODY': 'TBODY',
    'TD': 'TD',
    'TFOOT': 'TFOOT',
    'TH': 'TH',
    'THEAD': 'THEAD',
    'TR': 'TR',
    'UL': 'UL',
    'VIDEO': 'VIDEO'
  },
  EMBED_TAGS: {
    'IMG': 'IMG'
  },
  LINE_TAGS: {
    'DIV': 'DIV',
    'LI': 'LI'
  },
  LIST_TAGS: {
    'OL': 'OL',
    'UL': 'UL'
  },
  VOID_TAGS: {
    'AREA': 'AREA',
    'BASE': 'BASE',
    'BR': 'BR',
    'COL': 'COL',
    'COMMAND': 'COMMAND',
    'EMBED': 'EMBED',
    'HR': 'HR',
    'IMG': 'IMG',
    'INPUT': 'INPUT',
    'KEYGEN': 'KEYGEN',
    'LINK': 'LINK',
    'META': 'META',
    'PARAM': 'PARAM',
    'SOURCE': 'SOURCE',
    'TRACK': 'TRACK',
    'WBR': 'WBR'
  },
  convertFontSize: function(size) {
    var i, s, sources, targets;
    if (_.isString(size) && size.indexOf('px') > -1) {
      sources = Object.keys(dom.FONT_SIZES);
      targets = _.values(dom.FONT_SIZES);
    } else {
      targets = Object.keys(dom.FONT_SIZES);
      sources = _.values(dom.FONT_SIZES);
    }
    for (i in sources) {
      s = sources[i];
      if (parseInt(size) <= parseInt(s)) {
        return targets[i];
      }
    }
    return _.last(targets);
  },
  isIE: function(maxVersion) {
    var version;
    version = document.documentMode;
    return version && maxVersion >= version;
  },
  isIOS: function() {
    return /iPhone|iPad/i.test(navigator.userAgent);
  },
  isMac: function() {
    return /Mac/i.test(navigator.platform);
  }
});

module.exports = dom;



},{"lodash":1}],18:[function(_dereq_,module,exports){
var LinkedList, Node;

Node = (function() {
  function Node(data) {
    this.data = data;
    this.prev = this.next = null;
  }

  return Node;

})();

LinkedList = (function() {
  LinkedList.Node = Node;

  function LinkedList() {
    this.length = 0;
    this.first = this.last = null;
  }

  LinkedList.prototype.append = function(node) {
    if (this.first != null) {
      node.next = null;
      this.last.next = node;
    } else {
      this.first = node;
    }
    node.prev = this.last;
    this.last = node;
    return this.length += 1;
  };

  LinkedList.prototype.insertAfter = function(refNode, newNode) {
    newNode.prev = refNode;
    if (refNode != null) {
      newNode.next = refNode.next;
      if (refNode.next != null) {
        refNode.next.prev = newNode;
      }
      refNode.next = newNode;
      if (refNode === this.last) {
        this.last = newNode;
      }
    } else {
      newNode.next = this.first;
      this.first.prev = newNode;
      this.first = newNode;
    }
    return this.length += 1;
  };

  LinkedList.prototype.remove = function(node) {
    if (this.length > 1) {
      if (node.prev != null) {
        node.prev.next = node.next;
      }
      if (node.next != null) {
        node.next.prev = node.prev;
      }
      if (node === this.first) {
        this.first = node.next;
      }
      if (node === this.last) {
        this.last = node.prev;
      }
    } else {
      this.first = this.last = null;
    }
    node.prev = node.next = null;
    return this.length -= 1;
  };

  LinkedList.prototype.toArray = function() {
    var arr, cur;
    arr = [];
    cur = this.first;
    while (cur != null) {
      arr.push(cur);
      cur = cur.next;
    }
    return arr;
  };

  return LinkedList;

})();

module.exports = LinkedList;



},{}],19:[function(_dereq_,module,exports){
var Normalizer, Picker, _, dom;

_ = _dereq_('lodash');

dom = _dereq_('./dom');

Normalizer = _dereq_('../core/normalizer');

Picker = (function() {
  Picker.TEMPLATE = '<span class="ql-picker-label"></span><span class="ql-picker-options"></span>';

  function Picker(select) {
    this.select = select;
    this.container = document.createElement('span');
    this.buildPicker();
    dom(this.container).addClass('ql-picker');
    this.select.style.display = 'none';
    this.select.parentNode.insertBefore(this.container, this.select);
    dom(document).on('click', (function(_this) {
      return function() {
        _this.close();
        return true;
      };
    })(this));
    dom(this.label).on('click', (function(_this) {
      return function() {
        _.defer(function() {
          return dom(_this.container).toggleClass('ql-expanded');
        });
        return false;
      };
    })(this));
    dom(this.select).on('change', (function(_this) {
      return function() {
        var item, option;
        if (_this.select.selectedIndex > -1) {
          item = _this.container.querySelectorAll('.ql-picker-item')[_this.select.selectedIndex];
          option = _this.select.options[_this.select.selectedIndex];
        }
        _this.selectItem(item, false);
        return dom(_this.label).toggleClass('ql-active', option !== dom(_this.select)["default"]());
      };
    })(this));
  }

  Picker.prototype.buildItem = function(picker, option, index) {
    var item;
    item = document.createElement('span');
    item.setAttribute('data-value', option.getAttribute('value'));
    dom(item).addClass('ql-picker-item').text(dom(option).text()).on('click', (function(_this) {
      return function() {
        _this.selectItem(item, true);
        return _this.close();
      };
    })(this));
    if (this.select.selectedIndex === index) {
      this.selectItem(item, false);
    }
    return item;
  };

  Picker.prototype.buildPicker = function() {
    var picker;
    _.each(dom(this.select).attributes(), (function(_this) {
      return function(value, name) {
        return _this.container.setAttribute(name, value);
      };
    })(this));
    this.container.innerHTML = Normalizer.stripWhitespace(Picker.TEMPLATE);
    this.label = this.container.querySelector('.ql-picker-label');
    picker = this.container.querySelector('.ql-picker-options');
    return _.each(this.select.options, (function(_this) {
      return function(option, i) {
        var item;
        item = _this.buildItem(picker, option, i);
        return picker.appendChild(item);
      };
    })(this));
  };

  Picker.prototype.close = function() {
    return dom(this.container).removeClass('ql-expanded');
  };

  Picker.prototype.selectItem = function(item, trigger) {
    var selected, value;
    selected = this.container.querySelector('.ql-selected');
    if (selected != null) {
      dom(selected).removeClass('ql-selected');
    }
    if (item != null) {
      value = item.getAttribute('data-value');
      dom(item).addClass('ql-selected');
      dom(this.label).text(dom(item).text());
      dom(this.select).option(value, trigger);
      return this.label.setAttribute('data-value', value);
    } else {
      this.label.innerHTML = '&nbsp;';
      return this.label.removeAttribute('data-value');
    }
  };

  return Picker;

})();

module.exports = Picker;



},{"../core/normalizer":13,"./dom":17,"lodash":1}],20:[function(_dereq_,module,exports){
var Range, _;

_ = _dereq_('lodash');

Range = (function() {
  Range.compare = function(r1, r2) {
    if (r1 === r2) {
      return true;
    }
    if (!((r1 != null) && (r2 != null))) {
      return false;
    }
    return r1.equals(r2);
  };

  function Range(start, end) {
    this.start = start;
    this.end = end;
  }

  Range.prototype.equals = function(range) {
    if (range == null) {
      return false;
    }
    return this.start === range.start && this.end === range.end;
  };

  Range.prototype.shift = function(index, length) {
    var ref;
    return (ref = _.map([this.start, this.end], function(pos) {
      if (index > pos) {
        return pos;
      }
      if (length >= 0) {
        return pos + length;
      } else {
        return Math.max(index, pos + length);
      }
    }), this.start = ref[0], this.end = ref[1], ref);
  };

  Range.prototype.isCollapsed = function() {
    return this.start === this.end;
  };

  return Range;

})();

module.exports = Range;



},{"lodash":1}],21:[function(_dereq_,module,exports){
var Authorship, Delta, Quill, _, dom;

Quill = _dereq_('../quill');

_ = Quill.require('lodash');

dom = Quill.require('dom');

Delta = Quill.require('delta');

Authorship = (function() {
  Authorship.DEFAULTS = {
    authorId: null,
    color: 'transparent',
    enabled: false
  };

  function Authorship(quill, options) {
    this.quill = quill;
    this.options = options;
    if (this.options.button != null) {
      this.attachButton(this.options.button);
    }
    if (this.options.enabled) {
      this.enable();
    }
    this.quill.addFormat('author', {
      "class": 'author-'
    });
    if (this.options.authorId == null) {
      return;
    }
    this.quill.on(this.quill.constructor.events.PRE_EVENT, (function(_this) {
      return function(eventName, delta, origin) {
        var authorDelta, authorFormat;
        if (eventName === _this.quill.constructor.events.TEXT_CHANGE && origin === 'user') {
          authorDelta = new Delta();
          authorFormat = {
            author: _this.options.authorId
          };
          _.each(delta.ops, function(op) {
            if (op["delete"] != null) {
              return;
            }
            if ((op.insert != null) || ((op.retain != null) && (op.attributes != null))) {
              op.attributes || (op.attributes = {});
              op.attributes.author = _this.options.authorId;
              return authorDelta.retain(op.retain || op.insert.length || 1, authorFormat);
            } else {
              return authorDelta.retain(op.retain);
            }
          });
          return _this.quill.updateContents(authorDelta, Quill.sources.SILENT);
        }
      };
    })(this));
    this.addAuthor(this.options.authorId, this.options.color);
  }

  Authorship.prototype.addAuthor = function(id, color) {
    var styles;
    styles = {};
    styles[".authorship .author-" + id] = {
      "background-color": "" + color
    };
    return this.quill.theme.addStyles(styles);
  };

  Authorship.prototype.attachButton = function(button) {
    var $button;
    $button = dom(button);
    return $button.on('click', (function(_this) {
      return function() {
        $button.toggleClass('ql-on');
        return _this.enable($dom.hasClass('ql-on'));
      };
    })(this));
  };

  Authorship.prototype.enable = function(enabled) {
    if (enabled == null) {
      enabled = true;
    }
    return dom(this.quill.root).toggleClass('authorship', enabled);
  };

  Authorship.prototype.disable = function() {
    return this.enable(false);
  };

  return Authorship;

})();

Quill.registerModule('authorship', Authorship);

module.exports = Authorship;



},{"../quill":30}],22:[function(_dereq_,module,exports){
var Delta, ImageTooltip, Quill, Range, Tooltip, _, dom,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Quill = _dereq_('../quill');

Tooltip = _dereq_('./tooltip');

_ = Quill.require('lodash');

dom = Quill.require('dom');

Delta = Quill.require('delta');

Range = Quill.require('range');

ImageTooltip = (function(superClass) {
  extend(ImageTooltip, superClass);

  ImageTooltip.DEFAULTS = {
    template: '<input class="input" type="textbox"> <div class="preview"> <span>Preview</span> </div> <a href="javascript:;" class="cancel">Cancel</a> <a href="javascript:;" class="insert">Insert</a>'
  };

  function ImageTooltip(quill, options) {
    this.quill = quill;
    this.options = options;
    this.options = _.defaults(this.options, Tooltip.DEFAULTS);
    ImageTooltip.__super__.constructor.call(this, this.quill, this.options);
    this.preview = this.container.querySelector('.preview');
    this.textbox = this.container.querySelector('.input');
    dom(this.container).addClass('ql-image-tooltip');
    this.initListeners();
  }

  ImageTooltip.prototype.initListeners = function() {
    dom(this.container.querySelector('.insert')).on('click', _.bind(this.insertImage, this));
    dom(this.container.querySelector('.cancel')).on('click', _.bind(this.hide, this));
    dom(this.textbox).on('input', _.bind(this._preview, this));
    this.initTextbox(this.textbox, this.insertImage, this.hide);
    return this.quill.onModuleLoad('toolbar', (function(_this) {
      return function(toolbar) {
        return toolbar.initFormat('image', _.bind(_this._onToolbar, _this));
      };
    })(this));
  };

  ImageTooltip.prototype.insertImage = function() {
    var index, url;
    url = this._normalizeURL(this.textbox.value);
    if (this.range == null) {
      this.range = new Range(0, 0);
    }
    if (this.range) {
      this.preview.innerHTML = '<span>Preview</span>';
      this.textbox.value = '';
      index = this.range.end;
      this.quill.insertEmbed(index, 'image', url, 'user');
      this.quill.setSelection(index + 1, index + 1);
    }
    return this.hide();
  };

  ImageTooltip.prototype._onToolbar = function(range, value) {
    if (value) {
      if (!this.textbox.value) {
        this.textbox.value = 'http://';
      }
      this.show();
      this.textbox.focus();
      return _.defer((function(_this) {
        return function() {
          return _this.textbox.setSelectionRange(_this.textbox.value.length, _this.textbox.value.length);
        };
      })(this));
    } else {
      return this.quill.deleteText(range, 'user');
    }
  };

  ImageTooltip.prototype._preview = function() {
    var img;
    if (!this._matchImageURL(this.textbox.value)) {
      return;
    }
    if (this.preview.firstChild.tagName === 'IMG') {
      return this.preview.firstChild.setAttribute('src', this.textbox.value);
    } else {
      img = document.createElement('img');
      img.setAttribute('src', this.textbox.value);
      return this.preview.replaceChild(img, this.preview.firstChild);
    }
  };

  ImageTooltip.prototype._matchImageURL = function(url) {
    return /^https?:\/\/.+\.(jpe?g|gif|png)$/.test(url);
  };

  ImageTooltip.prototype._normalizeURL = function(url) {
    if (!/^https?:\/\//.test(url)) {
      url = 'http://' + url;
    }
    return url;
  };

  return ImageTooltip;

})(Tooltip);

Quill.registerModule('image-tooltip', ImageTooltip);

module.exports = ImageTooltip;



},{"../quill":30,"./tooltip":28}],23:[function(_dereq_,module,exports){
var Delta, Keyboard, Quill, _, dom;

Quill = _dereq_('../quill');

_ = Quill.require('lodash');

dom = Quill.require('dom');

Delta = Quill.require('delta');

Keyboard = (function() {
  Keyboard.hotkeys = {
    BOLD: {
      key: 'B',
      metaKey: true
    },
    INDENT: {
      key: dom.KEYS.TAB
    },
    ITALIC: {
      key: 'I',
      metaKey: true
    },
    OUTDENT: {
      key: dom.KEYS.TAB,
      shiftKey: true
    },
    UNDERLINE: {
      key: 'U',
      metaKey: true
    }
  };

  function Keyboard(quill, options) {
    this.quill = quill;
    this.hotkeys = {};
    this._initListeners();
    this._initHotkeys();
    this._initDeletes();
  }

  Keyboard.prototype.addHotkey = function(hotkeys, callback) {
    if (!Array.isArray(hotkeys)) {
      hotkeys = [hotkeys];
    }
    return _.each(hotkeys, (function(_this) {
      return function(hotkey) {
        var base, which;
        hotkey = _.isObject(hotkey) ? _.clone(hotkey) : {
          key: hotkey
        };
        hotkey.callback = callback;
        which = _.isNumber(hotkey.key) ? hotkey.key : hotkey.key.toUpperCase().charCodeAt(0);
        if ((base = _this.hotkeys)[which] == null) {
          base[which] = [];
        }
        return _this.hotkeys[which].push(hotkey);
      };
    })(this));
  };

  Keyboard.prototype.toggleFormat = function(range, format) {
    var delta, toolbar, value;
    if (range.isCollapsed()) {
      delta = this.quill.getContents(Math.max(0, range.start - 1), range.end);
    } else {
      delta = this.quill.getContents(range);
    }
    value = delta.ops.length === 0 || !_.all(delta.ops, function(op) {
      var ref;
      return (ref = op.attributes) != null ? ref[format] : void 0;
    });
    if (range.isCollapsed()) {
      this.quill.prepareFormat(format, value, Quill.sources.USER);
    } else {
      this.quill.formatText(range, format, value, Quill.sources.USER);
    }
    toolbar = this.quill.getModule('toolbar');
    if (toolbar != null) {
      return toolbar.setActive(format, value);
    }
  };

  Keyboard.prototype._initDeletes = function() {
    return this.addHotkey([dom.KEYS.DELETE, dom.KEYS.BACKSPACE], (function(_this) {
      return function(range, hotkey) {
        var format, line, offset, ref;
        if ((range != null) && _this.quill.getLength() > 0) {
          if (range.start !== range.end) {
            _this.quill.deleteText(range.start, range.end, Quill.sources.USER);
          } else {
            if (hotkey.key === dom.KEYS.BACKSPACE) {
              ref = _this.quill.editor.doc.findLineAt(range.start), line = ref[0], offset = ref[1];
              if (offset === 0 && (line.formats.bullet || line.formats.list)) {
                format = line.format.bullet ? 'bullet' : 'list';
                _this.quill.formatLine(range.start, range.start, format, false);
              } else if (range.start > 0) {
                _this.quill.deleteText(range.start - 1, range.start, Quill.sources.USER);
              }
            } else if (range.start < _this.quill.getLength()) {
              _this.quill.deleteText(range.start, range.start + 1, Quill.sources.USER);
            }
          }
        }
        return false;
      };
    })(this));
  };

  Keyboard.prototype._initHotkeys = function() {
    this.addHotkey(Keyboard.hotkeys.INDENT, (function(_this) {
      return function(range) {
        _this._onTab(range, false);
        return false;
      };
    })(this));
    this.addHotkey(Keyboard.hotkeys.OUTDENT, (function(_this) {
      return function(range) {
        return false;
      };
    })(this));
    return _.each(['bold', 'italic', 'underline'], (function(_this) {
      return function(format) {
        return _this.addHotkey(Keyboard.hotkeys[format.toUpperCase()], function(range) {
          _this.toggleFormat(range, format);
          return false;
        });
      };
    })(this));
  };

  Keyboard.prototype._initListeners = function() {
    return dom(this.quill.root).on('keydown', (function(_this) {
      return function(event) {
        var prevent;
        prevent = false;
        _.each(_this.hotkeys[event.which], function(hotkey) {
          var metaKey;
          metaKey = dom.isMac() ? event.metaKey : event.metaKey || event.ctrlKey;
          if (!!hotkey.metaKey !== !!metaKey) {
            return;
          }
          if (!!hotkey.shiftKey !== !!event.shiftKey) {
            return;
          }
          if (!!hotkey.altKey !== !!event.altKey) {
            return;
          }
          prevent = hotkey.callback(_this.quill.getSelection(), hotkey, event) === false || prevent;
          return true;
        });
        return !prevent;
      };
    })(this));
  };

  Keyboard.prototype._onTab = function(range, shift) {
    var delta;
    if (shift == null) {
      shift = false;
    }
    delta = new Delta().retain(range.start).insert("\t")["delete"](range.end - range.start).retain(this.quill.getLength() - range.end);
    this.quill.updateContents(delta, Quill.sources.USER);
    return this.quill.setSelection(range.start + 1, range.start + 1);
  };

  return Keyboard;

})();

Quill.registerModule('keyboard', Keyboard);

module.exports = Keyboard;



},{"../quill":30}],24:[function(_dereq_,module,exports){
var LinkTooltip, Quill, Tooltip, _, dom,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Quill = _dereq_('../quill');

Tooltip = _dereq_('./tooltip');

_ = Quill.require('lodash');

dom = Quill.require('dom');

LinkTooltip = (function(superClass) {
  extend(LinkTooltip, superClass);

  LinkTooltip.DEFAULTS = {
    maxLength: 50,
    template: '<span class="title">Visit URL:&nbsp;</span> <a href="#" class="url" target="_blank" href="about:blank"></a> <input class="input" type="text"> <span>&nbsp;&#45;&nbsp;</span> <a href="javascript:;" class="change">Change</a> <a href="javascript:;" class="remove">Remove</a> <a href="javascript:;" class="done">Done</a>'
  };

  LinkTooltip.hotkeys = {
    LINK: {
      key: 'K',
      metaKey: true
    }
  };

  function LinkTooltip(quill, options) {
    this.quill = quill;
    this.options = options;
    this.options = _.defaults(this.options, Tooltip.DEFAULTS);
    LinkTooltip.__super__.constructor.call(this, this.quill, this.options);
    dom(this.container).addClass('ql-link-tooltip');
    this.textbox = this.container.querySelector('.input');
    this.link = this.container.querySelector('.url');
    this.initListeners();
  }

  LinkTooltip.prototype.initListeners = function() {
    this.quill.on(this.quill.constructor.events.SELECTION_CHANGE, (function(_this) {
      return function(range) {
        var anchor;
        if (!((range != null) && range.isCollapsed())) {
          return;
        }
        anchor = _this._findAnchor(range);
        if (anchor) {
          _this.setMode(anchor.href, false);
          return _this.show(anchor);
        } else {
          _this.range = null;
          return _this.hide();
        }
      };
    })(this));
    dom(this.container.querySelector('.done')).on('click', _.bind(this.saveLink, this));
    dom(this.container.querySelector('.remove')).on('click', (function(_this) {
      return function() {
        return _this.removeLink(_this.range);
      };
    })(this));
    dom(this.container.querySelector('.change')).on('click', (function(_this) {
      return function() {
        return _this.setMode(_this.link.href, true);
      };
    })(this));
    this.initTextbox(this.textbox, this.saveLink, this.hide);
    this.quill.onModuleLoad('toolbar', (function(_this) {
      return function(toolbar) {
        _this.toolbar = toolbar;
        return toolbar.initFormat('link', _.bind(_this._onToolbar, _this));
      };
    })(this));
    return this.quill.onModuleLoad('keyboard', (function(_this) {
      return function(keyboard) {
        return keyboard.addHotkey(LinkTooltip.hotkeys.LINK, _.bind(_this._onKeyboard, _this));
      };
    })(this));
  };

  LinkTooltip.prototype.saveLink = function() {
    var anchor, url;
    url = this._normalizeURL(this.textbox.value);
    if (this.range != null) {
      if (this.range.isCollapsed()) {
        anchor = this._findAnchor(this.range);
        if (anchor != null) {
          anchor.href = url;
        }
      } else {
        this.quill.formatText(this.range, 'link', url, 'user');
      }
    }
    return this.setMode(url, false);
  };

  LinkTooltip.prototype.removeLink = function(range) {
    if (range.isCollapsed()) {
      range = this._expandRange(range);
    }
    this.quill.formatText(range, 'link', false, 'user');
    if (this.toolbar != null) {
      return this.toolbar.setActive('link', false);
    }
  };

  LinkTooltip.prototype.setMode = function(url, edit) {
    var text;
    if (edit == null) {
      edit = false;
    }
    if (edit) {
      this.textbox.value = url;
      _.defer((function(_this) {
        return function() {
          _this.textbox.focus();
          return _this.textbox.setSelectionRange(url.length, url.length);
        };
      })(this));
    } else {
      this.link.href = url;
      text = url.length > this.options.maxLength ? url.slice(0, this.options.maxLength) + '...' : url;
      dom(this.link).text(text);
    }
    return dom(this.container).toggleClass('editing', edit);
  };

  LinkTooltip.prototype._findAnchor = function(range) {
    var leaf, node, offset, ref;
    ref = this.quill.editor.doc.findLeafAt(range.start, true), leaf = ref[0], offset = ref[1];
    if (leaf != null) {
      node = leaf.node;
    }
    while (node != null) {
      if (node.tagName === 'A') {
        return node;
      }
      node = node.parentNode;
    }
    return null;
  };

  LinkTooltip.prototype._expandRange = function(range) {
    var end, leaf, offset, ref, start;
    ref = this.quill.editor.doc.findLeafAt(range.start, true), leaf = ref[0], offset = ref[1];
    start = range.start - offset;
    end = start + leaf.length;
    return {
      start: start,
      end: end
    };
  };

  LinkTooltip.prototype._onToolbar = function(range, value) {
    return this._toggle(range, value);
  };

  LinkTooltip.prototype._onKeyboard = function() {
    var range;
    range = this.quill.getSelection();
    return this._toggle(range, true);
  };

  LinkTooltip.prototype._toggle = function(range, value) {
    var nativeRange;
    if (!range) {
      return;
    }
    if (value && !range.isCollapsed()) {
      this.setMode(this._suggestURL(range), true);
      nativeRange = this.quill.editor.selection._getNativeRange();
      return this.show(nativeRange);
    } else {
      return this.removeLink(range);
    }
  };

  LinkTooltip.prototype._normalizeURL = function(url) {
    if (!/^(https?:\/\/|mailto:)/.test(url)) {
      url = 'http://' + url;
    }
    return url;
  };

  LinkTooltip.prototype._suggestURL = function(range) {
    var text;
    text = this.quill.getText(range);
    return this._normalizeURL(text);
  };

  return LinkTooltip;

})(Tooltip);

Quill.registerModule('link-tooltip', LinkTooltip);

module.exports = LinkTooltip;



},{"../quill":30,"./tooltip":28}],25:[function(_dereq_,module,exports){
var EventEmitter2, MultiCursor, Quill, _, dom,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

Quill = _dereq_('../quill');

EventEmitter2 = _dereq_('eventemitter2').EventEmitter2;

_ = Quill.require('lodash');

dom = Quill.require('dom');

MultiCursor = (function(superClass) {
  extend(MultiCursor, superClass);

  MultiCursor.DEFAULTS = {
    template: '<span class="cursor-flag"> <span class="cursor-name"></span> </span> <span class="cursor-caret"></span>',
    timeout: 2500
  };

  MultiCursor.events = {
    CURSOR_ADDED: 'cursor-addded',
    CURSOR_MOVED: 'cursor-moved',
    CURSOR_REMOVED: 'cursor-removed'
  };

  function MultiCursor(quill, options) {
    this.quill = quill;
    this.options = options;
    this.cursors = {};
    this.container = this.quill.addContainer('ql-multi-cursor', true);
    this.quill.on(this.quill.constructor.events.TEXT_CHANGE, _.bind(this._applyDelta, this));
  }

  MultiCursor.prototype.clearCursors = function() {
    _.each(Object.keys(this.cursors), _.bind(this.removeCursor, this));
    return this.cursors = {};
  };

  MultiCursor.prototype.moveCursor = function(userId, index) {
    var cursor;
    cursor = this.cursors[userId];
    cursor.index = index;
    dom(cursor.elem).removeClass('hidden');
    clearTimeout(cursor.timer);
    cursor.timer = setTimeout((function(_this) {
      return function() {
        dom(cursor.elem).addClass('hidden');
        return cursor.timer = null;
      };
    })(this), this.options.timeout);
    this._updateCursor(cursor);
    return cursor;
  };

  MultiCursor.prototype.removeCursor = function(userId) {
    var cursor;
    cursor = this.cursors[userId];
    this.emit(MultiCursor.events.CURSOR_REMOVED, cursor);
    if (cursor != null) {
      cursor.elem.parentNode.removeChild(cursor.elem);
    }
    return delete this.cursors[userId];
  };

  MultiCursor.prototype.setCursor = function(userId, index, name, color) {
    var cursor;
    if (this.cursors[userId] == null) {
      this.cursors[userId] = cursor = {
        userId: userId,
        index: index,
        color: color,
        elem: this._buildCursor(name, color)
      };
      this.emit(MultiCursor.events.CURSOR_ADDED, cursor);
    }
    _.defer((function(_this) {
      return function() {
        return _this.moveCursor(userId, index);
      };
    })(this));
    return this.cursors[userId];
  };

  MultiCursor.prototype.shiftCursors = function(index, length, authorId) {
    if (authorId == null) {
      authorId = null;
    }
    return _.each(this.cursors, (function(_this) {
      return function(cursor, id) {
        if (!(cursor && (cursor.index > index || cursor.userId === authorId))) {
          return;
        }
        return cursor.index += Math.max(length, index - cursor.index);
      };
    })(this));
  };

  MultiCursor.prototype.update = function() {
    return _.each(this.cursors, (function(_this) {
      return function(cursor, id) {
        if (cursor == null) {
          return;
        }
        _this._updateCursor(cursor);
        return true;
      };
    })(this));
  };

  MultiCursor.prototype._applyDelta = function(delta) {
    var index;
    index = 0;
    _.each(delta.ops, (function(_this) {
      return function(op) {
        var length, ref;
        length = 0;
        if (op.insert != null) {
          length = op.insert.length || 1;
          _this.shiftCursors(index, length, (ref = op.attributes) != null ? ref['author'] : void 0);
        } else if (op["delete"] != null) {
          _this.shiftCursors(index, -1 * op["delete"], null);
        } else if (op.retain != null) {
          _this.shiftCursors(index, 0, null);
          length = op.retain;
        }
        return index += length;
      };
    })(this));
    return this.update();
  };

  MultiCursor.prototype._buildCursor = function(name, color) {
    var cursor, cursorCaret, cursorFlag, cursorName;
    cursor = document.createElement('span');
    dom(cursor).addClass('cursor');
    cursor.innerHTML = this.options.template;
    cursorFlag = cursor.querySelector('.cursor-flag');
    cursorName = cursor.querySelector('.cursor-name');
    dom(cursorName).text(name);
    cursorCaret = cursor.querySelector('.cursor-caret');
    cursorCaret.style.backgroundColor = cursorName.style.backgroundColor = color;
    this.container.appendChild(cursor);
    return cursor;
  };

  MultiCursor.prototype._updateCursor = function(cursor) {
    var bounds, flag;
    bounds = this.quill.getBounds(cursor.index);
    cursor.elem.style.top = (bounds.top - this.quill.container.scrollTop) + 'px';
    cursor.elem.style.left = bounds.left + 'px';
    cursor.elem.style.height = bounds.height + 'px';
    flag = cursor.elem.querySelector('.cursor-flag');
    dom(cursor.elem).toggleClass('top', parseInt(cursor.elem.style.top) <= flag.offsetHeight).toggleClass('left', parseInt(cursor.elem.style.left) <= flag.offsetWidth).toggleClass('right', this.quill.root.offsetWidth - parseInt(cursor.elem.style.left) <= flag.offsetWidth);
    return this.emit(MultiCursor.events.CURSOR_MOVED, cursor);
  };

  return MultiCursor;

})(EventEmitter2);

Quill.registerModule('multi-cursor', MultiCursor);

module.exports = MultiCursor;



},{"../quill":30,"eventemitter2":2}],26:[function(_dereq_,module,exports){
var Delta, Document, PasteManager, Quill, _, dom;

Quill = _dereq_('../quill');

Document = _dereq_('../core/document');

_ = Quill.require('lodash');

dom = Quill.require('dom');

Delta = Quill.require('delta');

PasteManager = (function() {
  function PasteManager(quill, options) {
    this.quill = quill;
    this.options = options;
    this.container = this.quill.addContainer('ql-paste-manager');
    this.container.setAttribute('contenteditable', true);
    dom(this.quill.root).on('paste', _.bind(this._paste, this));
  }

  PasteManager.prototype._paste = function() {
    var oldDocLength, range;
    oldDocLength = this.quill.getLength();
    range = this.quill.getSelection();
    if (range == null) {
      return;
    }
    this.container.focus();
    return _.defer((function(_this) {
      return function() {
        var delta, doc, lengthAdded, line, lineBottom, offset, ref, windowBottom;
        doc = new Document(_this.container, _this.quill.options);
        delta = doc.toDelta();
        lengthAdded = delta.length() - 1;
        delta.compose(new Delta().retain(lengthAdded)["delete"](1));
        if (range.start > 0) {
          delta.ops.unshift({
            retain: range.start
          });
        }
        delta["delete"](range.end - range.start);
        _this.quill.updateContents(delta, 'user');
        _this.quill.setSelection(range.start + lengthAdded, range.start + lengthAdded);
        ref = _this.quill.editor.doc.findLineAt(range.start + lengthAdded), line = ref[0], offset = ref[1];
        lineBottom = line.node.getBoundingClientRect().bottom;
        windowBottom = document.documentElement.clientHeight;
        if (lineBottom > windowBottom) {
          line.node.scrollIntoView(false);
        }
        return _this.container.innerHTML = "";
      };
    })(this));
  };

  return PasteManager;

})();

Quill.registerModule('paste-manager', PasteManager);

module.exports = PasteManager;



},{"../core/document":8,"../quill":30}],27:[function(_dereq_,module,exports){
var Quill, Toolbar, _, dom;

Quill = _dereq_('../quill');

_ = Quill.require('lodash');

dom = Quill.require('dom');

Toolbar = (function() {
  Toolbar.DEFAULTS = {
    container: null
  };

  Toolbar.formats = {
    LINE: {
      'align': 'align',
      'bullet': 'bullet',
      'list': 'list'
    },
    SELECT: {
      'align': 'align',
      'background': 'background',
      'color': 'color',
      'font': 'font',
      'size': 'size'
    },
    TOGGLE: {
      'bold': 'bold',
      'bullet': 'bullet',
      'image': 'image',
      'italic': 'italic',
      'link': 'link',
      'list': 'list',
      'strike': 'strike',
      'underline': 'underline'
    },
    TOOLTIP: {
      'image': 'image',
      'link': 'link'
    }
  };

  function Toolbar(quill, options) {
    this.quill = quill;
    this.options = options;
    if (_.isString(this.options) || _.isElement(this.options)) {
      this.options = {
        container: this.options
      };
    }
    if (this.options.container == null) {
      throw new Error('container required for toolbar', this.options);
    }
    this.container = _.isString(this.options.container) ? document.querySelector(this.options.container) : this.options.container;
    this.inputs = {};
    this.preventUpdate = false;
    this.triggering = false;
    _.each(this.quill.options.formats, (function(_this) {
      return function(format) {
        if (Toolbar.formats.TOOLTIP[format] != null) {
          return;
        }
        return _this.initFormat(format, function(range, value) {
          if (_this.triggering) {
            return;
          }
          if (range.isCollapsed()) {
            _this.quill.prepareFormat(format, value, 'user');
          } else if (Toolbar.formats.LINE[format] != null) {
            _this.quill.formatLine(range, format, value, 'user');
          } else {
            _this.quill.formatText(range, format, value, 'user');
          }
          return _.defer(function() {
            _this.updateActive(range, ['bullet', 'list']);
            return _this.setActive(format, value);
          });
        });
      };
    })(this));
    this.quill.on(this.quill.constructor.events.SELECTION_CHANGE, (function(_this) {
      return function(range) {
        if (range != null) {
          return _this.updateActive(range);
        }
      };
    })(this));
    this.quill.onModuleLoad('keyboard', (function(_this) {
      return function(keyboard) {
        return keyboard.addHotkey([dom.KEYS.BACKSPACE, dom.KEYS.DELETE, dom.KEYS.ENTER], function() {
          return _.defer(_.bind(_this.updateActive, _this));
        });
      };
    })(this));
    dom(this.container).addClass('ql-toolbar');
    if (dom.isIOS()) {
      dom(this.container).addClass('ios');
    }
    if (dom.isIE(11)) {
      dom(this.container).on('mousedown', (function(_this) {
        return function() {
          return false;
        };
      })(this));
    }
  }

  Toolbar.prototype.initFormat = function(format, callback) {
    var eventName, input, selector;
    selector = ".ql-" + format;
    if (Toolbar.formats.SELECT[format] != null) {
      selector = "select" + selector;
      eventName = 'change';
    } else {
      eventName = 'click';
    }
    input = this.container.querySelector(selector);
    if (input == null) {
      return;
    }
    this.inputs[format] = input;
    return dom(input).on(eventName, (function(_this) {
      return function() {
        var range, value;
        value = eventName === 'change' ? dom(input).value() : !dom(input).hasClass('ql-active');
        _this.preventUpdate = true;
        _this.quill.focus();
        range = _this.quill.getSelection();
        if (range != null) {
          callback(range, value);
        }
        _this.preventUpdate = false;
        return true;
      };
    })(this));
  };

  Toolbar.prototype.setActive = function(format, value) {
    var $input, input, ref, selectValue;
    input = this.inputs[format];
    if (input == null) {
      return;
    }
    $input = dom(input);
    if (input.tagName === 'SELECT') {
      this.triggering = true;
      selectValue = $input.value(input);
      if (value == null) {
        value = (ref = $input["default"]()) != null ? ref.value : void 0;
      }
      if (Array.isArray(value)) {
        value = '';
      }
      if (value !== selectValue) {
        if (value != null) {
          $input.option(value);
        } else {
          $input.reset();
        }
      }
      return this.triggering = false;
    } else {
      return $input.toggleClass('ql-active', value || false);
    }
  };

  Toolbar.prototype.updateActive = function(range, formats) {
    var activeFormats;
    if (formats == null) {
      formats = null;
    }
    range || (range = this.quill.getSelection());
    if (!((range != null) && !this.preventUpdate)) {
      return;
    }
    activeFormats = this._getActive(range);
    return _.each(this.inputs, (function(_this) {
      return function(input, format) {
        if (!Array.isArray(formats) || formats.indexOf(format) > -1) {
          _this.setActive(format, activeFormats[format]);
        }
        return true;
      };
    })(this));
  };

  Toolbar.prototype._getActive = function(range) {
    var leafFormats, lineFormats;
    leafFormats = this._getLeafActive(range);
    lineFormats = this._getLineActive(range);
    return _.defaults({}, leafFormats, lineFormats);
  };

  Toolbar.prototype._getLeafActive = function(range) {
    var contents, formatsArr, line, offset, ref;
    if (range.isCollapsed()) {
      ref = this.quill.editor.doc.findLineAt(range.start), line = ref[0], offset = ref[1];
      if (offset === 0) {
        contents = this.quill.getContents(range.start, range.end + 1);
      } else {
        contents = this.quill.getContents(range.start - 1, range.end);
      }
    } else {
      contents = this.quill.getContents(range);
    }
    formatsArr = _.map(contents.ops, 'attributes');
    return this._intersectFormats(formatsArr);
  };

  Toolbar.prototype._getLineActive = function(range) {
    var firstLine, formatsArr, lastLine, offset, ref, ref1;
    formatsArr = [];
    ref = this.quill.editor.doc.findLineAt(range.start), firstLine = ref[0], offset = ref[1];
    ref1 = this.quill.editor.doc.findLineAt(range.end), lastLine = ref1[0], offset = ref1[1];
    if ((lastLine != null) && lastLine === firstLine) {
      lastLine = lastLine.next;
    }
    while ((firstLine != null) && firstLine !== lastLine) {
      formatsArr.push(_.clone(firstLine.formats));
      firstLine = firstLine.next;
    }
    return this._intersectFormats(formatsArr);
  };

  Toolbar.prototype._intersectFormats = function(formatsArr) {
    return _.reduce(formatsArr.slice(1), function(activeFormats, formats) {
      var activeKeys, added, formatKeys, intersection, missing;
      if (formats == null) {
        formats = {};
      }
      activeKeys = Object.keys(activeFormats);
      formatKeys = formats != null ? Object.keys(formats) : {};
      intersection = _.intersection(activeKeys, formatKeys);
      missing = _.difference(activeKeys, formatKeys);
      added = _.difference(formatKeys, activeKeys);
      _.each(intersection, function(name) {
        if (Toolbar.formats.SELECT[name] != null) {
          if (Array.isArray(activeFormats[name])) {
            if (activeFormats[name].indexOf(formats[name]) < 0) {
              return activeFormats[name].push(formats[name]);
            }
          } else if (activeFormats[name] !== formats[name]) {
            return activeFormats[name] = [activeFormats[name], formats[name]];
          }
        }
      });
      _.each(missing, function(name) {
        if (Toolbar.formats.TOGGLE[name] != null) {
          return delete activeFormats[name];
        } else if ((Toolbar.formats.SELECT[name] != null) && !Array.isArray(activeFormats[name])) {
          return activeFormats[name] = [activeFormats[name]];
        }
      });
      _.each(added, function(name) {
        if (Toolbar.formats.SELECT[name] != null) {
          return activeFormats[name] = [formats[name]];
        }
      });
      return activeFormats;
    }, formatsArr[0] || {});
  };

  return Toolbar;

})();

Quill.registerModule('toolbar', Toolbar);

module.exports = Toolbar;



},{"../quill":30}],28:[function(_dereq_,module,exports){
var Normalizer, Quill, Tooltip, _, dom;

Quill = _dereq_('../quill');

_ = Quill.require('lodash');

dom = Quill.require('dom');

Normalizer = Quill.require('normalizer');

Tooltip = (function() {
  Tooltip.DEFAULTS = {
    offset: 10,
    template: ''
  };

  Tooltip.HIDE_MARGIN = '-10000px';

  function Tooltip(quill, options) {
    this.quill = quill;
    this.options = options;
    this.container = this.quill.addContainer('ql-tooltip');
    this.container.innerHTML = Normalizer.stripWhitespace(this.options.template);
    dom(this.quill.root).on('focus', _.bind(this.hide, this));
    this.hide();
    this.quill.on(this.quill.constructor.events.TEXT_CHANGE, (function(_this) {
      return function(delta, source) {
        if (source === 'user' && _this.container.style.left !== Tooltip.HIDE_MARGIN) {
          _this.range = null;
          return _this.hide();
        }
      };
    })(this));
  }

  Tooltip.prototype.initTextbox = function(textbox, enterCallback, escapeCallback) {
    return dom(textbox).on('keyup', (function(_this) {
      return function(event) {
        switch (event.which) {
          case dom.KEYS.ENTER:
            return enterCallback.call(_this);
          case dom.KEYS.ESCAPE:
            return escapeCallback.call(_this);
          default:
            return true;
        }
      };
    })(this));
  };

  Tooltip.prototype.hide = function() {
    this.container.style.left = Tooltip.HIDE_MARGIN;
    if (this.range) {
      this.quill.setSelection(this.range);
    }
    return this.range = null;
  };

  Tooltip.prototype.position = function(reference) {
    var left, offsetBottom, offsetLeft, offsetTop, parentBounds, referenceBounds, top;
    if (reference != null) {
      referenceBounds = reference.getBoundingClientRect();
      parentBounds = this.quill.container.getBoundingClientRect();
      offsetLeft = referenceBounds.left - parentBounds.left;
      offsetTop = referenceBounds.top - parentBounds.top;
      offsetBottom = referenceBounds.bottom - parentBounds.bottom;
      left = offsetLeft + referenceBounds.width / 2 - this.container.offsetWidth / 2;
      top = offsetTop + referenceBounds.height + this.options.offset;
      if (top + this.container.offsetHeight > this.quill.container.offsetHeight) {
        top = offsetTop - this.container.offsetHeight - this.options.offset;
      }
      left = Math.max(0, Math.min(left, this.quill.container.offsetWidth - this.container.offsetWidth));
      top = Math.max(0, Math.min(top, this.quill.container.offsetHeight - this.container.offsetHeight));
    } else {
      left = this.quill.container.offsetWidth / 2 - this.container.offsetWidth / 2;
      top = this.quill.container.offsetHeight / 2 - this.container.offsetHeight / 2;
    }
    top += this.quill.container.scrollTop;
    return [left, top];
  };

  Tooltip.prototype.show = function(reference) {
    var left, ref, top;
    this.range = this.quill.getSelection();
    ref = this.position(reference), left = ref[0], top = ref[1];
    this.container.style.left = left + "px";
    this.container.style.top = top + "px";
    return this.container.focus();
  };

  return Tooltip;

})();

Quill.registerModule('tooltip', Tooltip);

module.exports = Tooltip;



},{"../quill":30}],29:[function(_dereq_,module,exports){
var Delta, Quill, UndoManager, _;

Quill = _dereq_('../quill');

_ = Quill.require('lodash');

Delta = Quill.require('delta');

UndoManager = (function() {
  UndoManager.DEFAULTS = {
    delay: 1000,
    maxStack: 100
  };

  UndoManager.hotkeys = {
    UNDO: {
      key: 'Z',
      metaKey: true
    },
    REDO: {
      key: 'Z',
      metaKey: true,
      shiftKey: true
    }
  };

  function UndoManager(quill, options) {
    this.quill = quill;
    this.options = options != null ? options : {};
    this.lastRecorded = 0;
    this.ignoreChange = false;
    this.clear();
    this.initListeners();
  }

  UndoManager.prototype.initListeners = function() {
    this.quill.onModuleLoad('keyboard', (function(_this) {
      return function(keyboard) {
        keyboard.addHotkey(UndoManager.hotkeys.UNDO, function() {
          _this.quill.editor.checkUpdate();
          _this.undo();
          return false;
        });
        return keyboard.addHotkey(UndoManager.hotkeys.REDO, function() {
          _this.quill.editor.checkUpdate();
          _this.redo();
          return false;
        });
      };
    })(this));
    return this.quill.on(this.quill.constructor.events.TEXT_CHANGE, (function(_this) {
      return function(delta, origin) {
        if (_this.ignoreChange) {
          return;
        }
        _this.record(delta, _this.oldDelta);
        return _this.oldDelta = _this.quill.getContents();
      };
    })(this));
  };

  UndoManager.prototype.clear = function() {
    this.stack = {
      undo: [],
      redo: []
    };
    return this.oldDelta = this.quill.getContents();
  };

  UndoManager.prototype.record = function(changeDelta, oldDelta) {
    var change, ignored, timestamp, undoDelta;
    if (!(changeDelta.ops.length > 0)) {
      return;
    }
    this.stack.redo = [];
    try {
      undoDelta = this.quill.getContents().diff(this.oldDelta);
      timestamp = new Date().getTime();
      if (this.lastRecorded + this.options.delay > timestamp && this.stack.undo.length > 0) {
        change = this.stack.undo.pop();
        undoDelta = undoDelta.compose(change.undo);
        changeDelta = change.redo.compose(changeDelta);
      } else {
        this.lastRecorded = timestamp;
      }
      this.stack.undo.push({
        redo: changeDelta,
        undo: undoDelta
      });
      if (this.stack.undo.length > this.options.maxStack) {
        return this.stack.undo.unshift();
      }
    } catch (_error) {
      ignored = _error;
      console.warn('Could not record change... clearing undo stack.');
      return this.clear();
    }
  };

  UndoManager.prototype.redo = function() {
    return this._change('redo', 'undo');
  };

  UndoManager.prototype.undo = function() {
    return this._change('undo', 'redo');
  };

  UndoManager.prototype._getLastChangeIndex = function(delta) {
    var index, lastIndex;
    lastIndex = 0;
    index = 0;
    _.each(delta.ops, function(op) {
      if (op.insert != null) {
        return lastIndex = Math.max(index + (op.insert.length || 1), lastIndex);
      } else if (op["delete"] != null) {
        return lastIndex = Math.max(index, lastIndex);
      } else if (op.retain != null) {
        if (op.attributes != null) {
          lastIndex = Math.max(index + op.retain, lastIndex);
        }
        return index += op.retain;
      }
    });
    return lastIndex;
  };

  UndoManager.prototype._change = function(source, dest) {
    var change, index;
    if (this.stack[source].length > 0) {
      change = this.stack[source].pop();
      this.lastRecorded = 0;
      this.ignoreChange = true;
      this.quill.updateContents(change[source], 'user');
      this.ignoreChange = false;
      index = this._getLastChangeIndex(change[source]);
      this.quill.setSelection(index, index);
      this.oldDelta = this.quill.getContents();
      return this.stack[dest].push(change);
    }
  };

  return UndoManager;

})();

Quill.registerModule('undo-manager', UndoManager);

module.exports = UndoManager;



},{"../quill":30}],30:[function(_dereq_,module,exports){
var Delta, Editor, EventEmitter2, Format, Normalizer, Quill, Range, _, dom, pkg,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty,
  slice = [].slice;

_ = _dereq_('lodash');

pkg = _dereq_('../package.json');

Delta = _dereq_('rich-text/lib/delta');

EventEmitter2 = _dereq_('eventemitter2').EventEmitter2;

dom = _dereq_('./lib/dom');

Editor = _dereq_('./core/editor');

Format = _dereq_('./core/format');

Normalizer = _dereq_('./core/normalizer');

Range = _dereq_('./lib/range');

Quill = (function(superClass) {
  extend(Quill, superClass);

  Quill.version = pkg.version;

  Quill.editors = [];

  Quill.modules = [];

  Quill.themes = [];

  Quill.DEFAULTS = {
    formats: ['align', 'bold', 'italic', 'strike', 'underline', 'color', 'background', 'font', 'size', 'link', 'image', 'bullet', 'list'],
    modules: {
      'keyboard': true,
      'paste-manager': true,
      'undo-manager': true
    },
    pollInterval: 100,
    readOnly: false,
    styles: {},
    theme: 'base'
  };

  Quill.events = {
    MODULE_INIT: 'module-init',
    POST_EVENT: 'post-event',
    PRE_EVENT: 'pre-event',
    SELECTION_CHANGE: 'selection-change',
    TEXT_CHANGE: 'text-change'
  };

  Quill.sources = Editor.sources;

  Quill.registerModule = function(name, module) {
    if (Quill.modules[name] != null) {
      console.warn("Overwriting " + name + " module");
    }
    return Quill.modules[name] = module;
  };

  Quill.registerTheme = function(name, theme) {
    if (Quill.themes[name] != null) {
      console.warn("Overwriting " + name + " theme");
    }
    return Quill.themes[name] = theme;
  };

  Quill.require = function(name) {
    switch (name) {
      case 'lodash':
        return _;
      case 'delta':
        return Delta;
      case 'normalizer':
        return Normalizer;
      case 'dom':
        return dom;
      case 'range':
        return Range;
      default:
        return null;
    }
  };

  function Quill(container1, options) {
    var html, moduleOptions, themeClass;
    this.container = container1;
    if (options == null) {
      options = {};
    }
    if (_.isString(this.container)) {
      this.container = document.querySelector(this.container);
    }
    if (this.container == null) {
      throw new Error('Invalid Quill container');
    }
    moduleOptions = _.defaults(options.modules || {}, Quill.DEFAULTS.modules);
    html = this.container.innerHTML;
    this.container.innerHTML = '';
    this.options = _.defaults(options, Quill.DEFAULTS);
    this.options.modules = moduleOptions;
    this.options.id = this.id = "ql-editor-" + (Quill.editors.length + 1);
    this.modules = {};
    this.root = this.addContainer('ql-editor');
    this.editor = new Editor(this.root, this, this.options);
    Quill.editors.push(this);
    this.setHTML(html, Quill.sources.SILENT);
    themeClass = Quill.themes[this.options.theme];
    if (themeClass == null) {
      throw new Error("Cannot load " + this.options.theme + " theme. Are you sure you registered it?");
    }
    this.theme = new themeClass(this, this.options);
    _.each(this.options.modules, (function(_this) {
      return function(option, name) {
        return _this.addModule(name, option);
      };
    })(this));
  }

  Quill.prototype.destroy = function() {
    var html;
    html = this.getHTML();
    _.each(this.modules, function(module, name) {
      if (_.isFunction(module.destroy)) {
        return module.destroy();
      }
    });
    this.editor.destroy();
    this.removeAllListeners();
    Quill.editors.splice(_.indexOf(Quill.editors, this), 1);
    return this.container.innerHTML = html;
  };

  Quill.prototype.addContainer = function(className, before) {
    var container, refNode;
    if (before == null) {
      before = false;
    }
    refNode = before ? this.root : null;
    container = document.createElement('div');
    dom(container).addClass(className);
    this.container.insertBefore(container, refNode);
    return container;
  };

  Quill.prototype.addFormat = function(name, format) {
    return this.editor.doc.addFormat(name, format);
  };

  Quill.prototype.addModule = function(name, options) {
    var moduleClass;
    moduleClass = Quill.modules[name];
    if (moduleClass == null) {
      throw new Error("Cannot load " + name + " module. Are you sure you registered it?");
    }
    if (options === true) {
      options = {};
    }
    options = _.defaults(options, this.theme.constructor.OPTIONS[name] || {}, moduleClass.DEFAULTS || {});
    this.modules[name] = new moduleClass(this, options);
    this.emit(Quill.events.MODULE_INIT, name, this.modules[name]);
    return this.modules[name];
  };

  Quill.prototype.deleteText = function(start, end, source) {
    var delta, formats, ref;
    if (source == null) {
      source = Quill.sources.API;
    }
    ref = this._buildParams(start, end, {}, source), start = ref[0], end = ref[1], formats = ref[2], source = ref[3];
    if (!(end > start)) {
      return;
    }
    delta = new Delta().retain(start)["delete"](end - start);
    return this.editor.applyDelta(delta, source);
  };

  Quill.prototype.emit = function() {
    var args, eventName;
    eventName = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    Quill.__super__.emit.apply(this, [Quill.events.PRE_EVENT, eventName].concat(slice.call(args)));
    Quill.__super__.emit.apply(this, [eventName].concat(slice.call(args)));
    return Quill.__super__.emit.apply(this, [Quill.events.POST_EVENT, eventName].concat(slice.call(args)));
  };

  Quill.prototype.focus = function() {
    return this.editor.focus();
  };

  Quill.prototype.formatLine = function(start, end, name, value, source) {
    var formats, line, offset, ref, ref1;
    ref = this._buildParams(start, end, name, value, source), start = ref[0], end = ref[1], formats = ref[2], source = ref[3];
    ref1 = this.editor.doc.findLineAt(end), line = ref1[0], offset = ref1[1];
    if (line != null) {
      end += line.length - offset;
    }
    return this.formatText(start, end, formats, source);
  };

  Quill.prototype.formatText = function(start, end, name, value, source) {
    var delta, formats, ref;
    ref = this._buildParams(start, end, name, value, source), start = ref[0], end = ref[1], formats = ref[2], source = ref[3];
    formats = _.reduce(formats, (function(_this) {
      return function(formats, value, name) {
        var format;
        format = _this.editor.doc.formats[name];
        if (!(value && value !== format.config["default"])) {
          formats[name] = null;
        }
        return formats;
      };
    })(this), formats);
    delta = new Delta().retain(start).retain(end - start, formats);
    return this.editor.applyDelta(delta, source);
  };

  Quill.prototype.getBounds = function(index) {
    return this.editor.getBounds(index);
  };

  Quill.prototype.getContents = function(start, end) {
    if (start == null) {
      start = 0;
    }
    if (end == null) {
      end = null;
    }
    if (_.isObject(start)) {
      end = start.end;
      start = start.start;
    }
    return this.editor.delta.slice(start, end);
  };

  Quill.prototype.getHTML = function() {
    return this.editor.doc.getHTML();
  };

  Quill.prototype.getLength = function() {
    return this.editor.length;
  };

  Quill.prototype.getModule = function(name) {
    return this.modules[name];
  };

  Quill.prototype.getSelection = function() {
    this.editor.checkUpdate();
    return this.editor.selection.getRange();
  };

  Quill.prototype.getText = function(start, end) {
    if (start == null) {
      start = 0;
    }
    if (end == null) {
      end = null;
    }
    return _.map(this.getContents(start, end).ops, function(op) {
      if (_.isString(op.insert)) {
        return op.insert;
      } else {
        return '';
      }
    }).join('');
  };

  Quill.prototype.insertEmbed = function(index, type, url, source) {
    return this.insertText(index, dom.EMBED_TEXT, type, url, source);
  };

  Quill.prototype.insertText = function(index, text, name, value, source) {
    var delta, end, formats, ref;
    ref = this._buildParams(index, 0, name, value, source), index = ref[0], end = ref[1], formats = ref[2], source = ref[3];
    if (!(text.length > 0)) {
      return;
    }
    delta = new Delta().retain(index).insert(text, formats);
    return this.editor.applyDelta(delta, source);
  };

  Quill.prototype.onModuleLoad = function(name, callback) {
    if (this.modules[name]) {
      return callback(this.modules[name]);
    }
    return this.on(Quill.events.MODULE_INIT, function(moduleName, module) {
      if (moduleName === name) {
        return callback(module);
      }
    });
  };

  Quill.prototype.prepareFormat = function(name, value, source) {
    var format, range;
    if (source == null) {
      source = Quill.sources.API;
    }
    format = this.editor.doc.formats[name];
    if (format == null) {
      return;
    }
    range = this.getSelection();
    if (!(range != null ? range.isCollapsed() : void 0)) {
      return;
    }
    if (format.isType(Format.types.LINE)) {
      return this.formatLine(range, name, value, source);
    } else {
      return format.prepare(value);
    }
  };

  Quill.prototype.setContents = function(delta, source) {
    if (source == null) {
      source = Quill.sources.API;
    }
    if (Array.isArray(delta)) {
      delta = {
        ops: delta.slice()
      };
    } else {
      delta = {
        ops: delta.ops.slice()
      };
    }
    delta.ops.push({
      "delete": this.getLength()
    });
    return this.updateContents(delta, source);
  };

  Quill.prototype.setHTML = function(html, source) {
    if (source == null) {
      source = Quill.sources.API;
    }
    if (!html.trim()) {
      html = "<" + dom.DEFAULT_BLOCK_TAG + "><" + dom.DEFAULT_BREAK_TAG + "></" + dom.DEFAULT_BLOCK_TAG + ">";
    }
    this.editor.doc.setHTML(html);
    return this.editor.checkUpdate(source);
  };

  Quill.prototype.setSelection = function(start, end, source) {
    var range;
    if (source == null) {
      source = Quill.sources.API;
    }
    if (_.isNumber(start) && _.isNumber(end)) {
      range = new Range(start, end);
    } else {
      range = start;
      source = end || source;
    }
    return this.editor.selection.setRange(range, source);
  };

  Quill.prototype.setText = function(text, source) {
    var delta;
    if (source == null) {
      source = Quill.sources.API;
    }
    delta = new Delta().insert(text);
    return this.setContents(delta, source);
  };

  Quill.prototype.updateContents = function(delta, source) {
    if (source == null) {
      source = Quill.sources.API;
    }
    if (Array.isArray(delta)) {
      delta = {
        ops: delta
      };
    }
    return this.editor.applyDelta(delta, source);
  };

  Quill.prototype._buildParams = function() {
    var formats, params;
    params = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    if (_.isObject(params[0])) {
      params.splice(0, 1, params[0].start, params[0].end);
    }
    if (_.isString(params[2])) {
      formats = {};
      formats[params[2]] = params[3];
      params.splice(2, 2, formats);
    }
    if (params[3] == null) {
      params[3] = Quill.sources.API;
    }
    return params;
  };

  return Quill;

})(EventEmitter2);

Quill.registerTheme('base', _dereq_('./themes/base'));

Quill.registerTheme('snow', _dereq_('./themes/snow'));

module.exports = Quill;



},{"../package.json":7,"./core/editor":9,"./core/format":10,"./core/normalizer":13,"./lib/dom":17,"./lib/range":20,"./themes/base":32,"./themes/snow":33,"eventemitter2":2,"lodash":1,"rich-text/lib/delta":3}],31:[function(_dereq_,module,exports){
module.exports = ".ql-image-tooltip{padding:10px;width:300px}.ql-image-tooltip:after{clear:both;content:\"\";display:table}.ql-image-tooltip a{border:1px solid #000;box-sizing:border-box;display:inline-block;float:left;padding:5px;text-align:center;width:50%}.ql-image-tooltip img{bottom:0;left:0;margin:auto;max-height:100%;max-width:100%;position:absolute;right:0;top:0}.ql-image-tooltip .input{box-sizing:border-box;width:100%}.ql-image-tooltip .preview{margin:10px 0;position:relative;border:1px dashed #000;height:200px}.ql-image-tooltip .preview span{display:inline-block;position:absolute;text-align:center;top:40%;width:100%}.ql-link-tooltip{padding:5px 10px}.ql-link-tooltip input.input{width:170px}.ql-link-tooltip a.done,.ql-link-tooltip input.input{display:none}.ql-link-tooltip a.change{margin-right:4px}.ql-link-tooltip.editing a.done,.ql-link-tooltip.editing input.input{display:inline-block}.ql-link-tooltip.editing a.change,.ql-link-tooltip.editing a.remove,.ql-link-tooltip.editing a.url{display:none}.ql-multi-cursor{position:absolute;left:0;top:0;z-index:1000}.ql-multi-cursor .cursor{margin-left:-1px;position:absolute}.ql-multi-cursor .cursor-flag{bottom:100%;position:absolute;white-space:nowrap}.ql-multi-cursor .cursor-name{display:inline-block;color:#fff;padding:2px 8px}.ql-multi-cursor .cursor-caret{height:100%;position:absolute;width:2px}.ql-multi-cursor .cursor.hidden .cursor-flag{display:none}.ql-multi-cursor .cursor.top .cursor-flag{bottom:auto;top:100%}.ql-multi-cursor .cursor.right .cursor-flag{right:-2px}.ql-paste-manager{left:-100000px;position:absolute;top:50%}.ql-toolbar{box-sizing:border-box}.ql-tooltip{background-color:#fff;border:1px solid #000;box-sizing:border-box;position:absolute;top:0;white-space:nowrap;z-index:2000}.ql-tooltip a{cursor:pointer;text-decoration:none}.ql-container{box-sizing:border-box;cursor:text;font-family:Helvetica,Arial,sans-serif;font-size:13px;height:100%;line-height:1.42;margin:0;overflow-x:hidden;overflow-y:auto;padding:12px 15px;position:relative}.ql-editor{box-sizing:border-box;min-height:100%;outline:0;tab-size:4;white-space:pre-wrap}.ql-editor div{margin:0;padding:0}.ql-editor a{text-decoration:underline}.ql-editor b{font-weight:700}.ql-editor i{font-style:italic}.ql-editor s{text-decoration:line-through}.ql-editor u{text-decoration:underline}.ql-editor img{max-width:100%}.ql-editor blockquote,.ql-editor ol,.ql-editor ul{margin:0 0 0 2em;padding:0}.ql-editor ol{list-style-type:decimal}.ql-editor ul{list-style-type:disc}.ql-editor.ql-ie-10 br,.ql-editor.ql-ie-9 br{display:none}";
},{}],32:[function(_dereq_,module,exports){
var BaseTheme, _, baseStyles, dom;

_ = _dereq_('lodash');

dom = _dereq_('../../lib/dom');

baseStyles = _dereq_('./base.styl');

BaseTheme = (function() {
  BaseTheme.OPTIONS = {};

  BaseTheme.objToCss = function(obj) {
    return _.map(obj, function(value, key) {
      var innerStr;
      innerStr = _.map(value, function(innerValue, innerKey) {
        return innerKey + ": " + innerValue + ";";
      }).join(' ');
      return key + " { " + innerStr + " }";
    }).join("\n");
  };

  function BaseTheme(quill, options) {
    var version;
    this.quill = quill;
    this.options = options;
    dom(this.quill.container).addClass('ql-container');
    if (this.options.styles) {
      this.addStyles(baseStyles + BaseTheme.objToCss(this.options.styles));
    }
    if (dom.isIE(10)) {
      version = dom.isIE(9) ? '9' : '10';
      dom(this.quill.root).addClass('ql-ie-' + version);
    }
  }

  BaseTheme.prototype.addStyles = function(css) {
    var style;
    if (_.isObject(css)) {
      css = BaseTheme.objToCss(css);
    }
    style = document.createElement('style');
    style.type = 'text/css';
    style.appendChild(document.createTextNode(css));
    return document.head.appendChild(style);
  };

  return BaseTheme;

})();

module.exports = BaseTheme;



},{"../../lib/dom":17,"./base.styl":31,"lodash":1}],33:[function(_dereq_,module,exports){
var BaseTheme, ColorPicker, Picker, SnowTheme, _, dom,
  extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
  hasProp = {}.hasOwnProperty;

_ = _dereq_('lodash');

ColorPicker = _dereq_('../../lib/color-picker');

BaseTheme = _dereq_('../base');

dom = _dereq_('../../lib/dom');

Picker = _dereq_('../../lib/picker');

SnowTheme = (function(superClass) {
  extend(SnowTheme, superClass);

  SnowTheme.COLORS = ["#000000", "#e60000", "#ff9900", "#ffff00", "#008A00", "#0066cc", "#9933ff", "#ffffff", "#facccc", "#ffebcc", "#ffffcc", "#cce8cc", "#cce0f5", "#ebd6ff", "#bbbbbb", "#f06666", "#ffc266", "#ffff66", "#66b966", "#66a3e0", "#c285ff", "#888888", "#a10000", "#b26b00", "#b2b200", "#006100", "#0047b2", "#6b24b2", "#444444", "#5c0000", "#663d00", "#666600", "#003700", "#002966", "#3d1466"];

  SnowTheme.OPTIONS = {
    'multi-cursor': {
      template: '<span class="cursor-flag"> <span class="cursor-triangle top"></span> <span class="cursor-name"></span> <span class="cursor-triangle bottom"></span> </span> <span class="cursor-caret"></span>'
    }
  };

  function SnowTheme(quill, options) {
    this.quill = quill;
    this.options = options;
    SnowTheme.__super__.constructor.apply(this, arguments);
    dom(this.quill.container).addClass('ql-snow');
    this.pickers = [];
    this.quill.on(this.quill.constructor.events.SELECTION_CHANGE, (function(_this) {
      return function(range) {
        if (range != null) {
          return _.invoke(_this.pickers, 'close');
        }
      };
    })(this));
    this.quill.onModuleLoad('multi-cursor', _.bind(this.extendMultiCursor, this));
    this.quill.onModuleLoad('toolbar', _.bind(this.extendToolbar, this));
  }

  SnowTheme.prototype.extendMultiCursor = function(module) {
    return module.on(module.constructor.events.CURSOR_ADDED, function(cursor) {
      var bottomTriangle, topTriangle;
      bottomTriangle = cursor.elem.querySelector('.cursor-triangle.bottom');
      topTriangle = cursor.elem.querySelector('.cursor-triangle.top');
      return bottomTriangle.style.borderTopColor = topTriangle.style.borderBottomColor = cursor.color;
    });
  };

  SnowTheme.prototype.extendToolbar = function(module) {
    dom(module.container).addClass('ql-snow');
    _.each(['color', 'background', 'font', 'size', 'align'], (function(_this) {
      return function(format) {
        var picker, select;
        select = module.container.querySelector(".ql-" + format);
        if (select == null) {
          return;
        }
        switch (format) {
          case 'font':
          case 'size':
          case 'align':
            picker = new Picker(select);
            break;
          case 'color':
          case 'background':
            picker = new ColorPicker(select);
            _.each(picker.container.querySelectorAll('.ql-picker-item'), function(item, i) {
              if (i < 7) {
                return dom(item).addClass('ql-primary-color');
              }
            });
        }
        if (picker != null) {
          return _this.pickers.push(picker);
        }
      };
    })(this));
    return _.each(dom(module.container).textNodes(), function(node) {
      if (dom(node).text().trim().length === 0) {
        return dom(node).remove();
      }
    });
  };

  return SnowTheme;

})(BaseTheme);

module.exports = SnowTheme;



},{"../../lib/color-picker":16,"../../lib/dom":17,"../../lib/picker":19,"../base":32,"lodash":1}]},{},[15])(15)
});
}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],682:[function(require,module,exports){
module.exports = require('./dist/quill');

},{"./dist/quill":681}],683:[function(require,module,exports){
//  Ramda v0.17.1
//  https://github.com/ramda/ramda
//  (c) 2013-2015 Scott Sauyet, Michael Hurley, and David Chambers
//  Ramda may be freely distributed under the MIT license.

;(function() {

  'use strict';

  /**
     * A special placeholder value used to specify "gaps" within curried functions,
     * allowing partial application of any combination of arguments,
     * regardless of their positions.
     *
     * If `g` is a curried ternary function and `_` is `R.__`, the following are equivalent:
     *
     *   - `g(1, 2, 3)`
     *   - `g(_, 2, 3)(1)`
     *   - `g(_, _, 3)(1)(2)`
     *   - `g(_, _, 3)(1, 2)`
     *   - `g(_, 2, _)(1, 3)`
     *   - `g(_, 2)(1)(3)`
     *   - `g(_, 2)(1, 3)`
     *   - `g(_, 2)(_, 3)(1)`
     *
     * @constant
     * @memberOf R
     * @category Function
     * @example
     *
     *      var greet = R.replace('{name}', R.__, 'Hello, {name}!');
     *      greet('Alice'); //=> 'Hello, Alice!'
     */
    var __ = { '@@functional/placeholder': true };

    // jshint unused:vars
    var _arity = function _arity(n, fn) {
        // jshint unused:vars
        switch (n) {
        case 0:
            return function () {
                return fn.apply(this, arguments);
            };
        case 1:
            return function (a0) {
                return fn.apply(this, arguments);
            };
        case 2:
            return function (a0, a1) {
                return fn.apply(this, arguments);
            };
        case 3:
            return function (a0, a1, a2) {
                return fn.apply(this, arguments);
            };
        case 4:
            return function (a0, a1, a2, a3) {
                return fn.apply(this, arguments);
            };
        case 5:
            return function (a0, a1, a2, a3, a4) {
                return fn.apply(this, arguments);
            };
        case 6:
            return function (a0, a1, a2, a3, a4, a5) {
                return fn.apply(this, arguments);
            };
        case 7:
            return function (a0, a1, a2, a3, a4, a5, a6) {
                return fn.apply(this, arguments);
            };
        case 8:
            return function (a0, a1, a2, a3, a4, a5, a6, a7) {
                return fn.apply(this, arguments);
            };
        case 9:
            return function (a0, a1, a2, a3, a4, a5, a6, a7, a8) {
                return fn.apply(this, arguments);
            };
        case 10:
            return function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
                return fn.apply(this, arguments);
            };
        default:
            throw new Error('First argument to _arity must be a non-negative integer no greater than ten');
        }
    };

    var _cloneRegExp = function _cloneRegExp(pattern) {
        return new RegExp(pattern.source, (pattern.global ? 'g' : '') + (pattern.ignoreCase ? 'i' : '') + (pattern.multiline ? 'm' : '') + (pattern.sticky ? 'y' : '') + (pattern.unicode ? 'u' : ''));
    };

    var _complement = function _complement(f) {
        return function () {
            return !f.apply(this, arguments);
        };
    };

    /**
     * Private `concat` function to merge two array-like objects.
     *
     * @private
     * @param {Array|Arguments} [set1=[]] An array-like object.
     * @param {Array|Arguments} [set2=[]] An array-like object.
     * @return {Array} A new, merged array.
     * @example
     *
     *      _concat([4, 5, 6], [1, 2, 3]); //=> [4, 5, 6, 1, 2, 3]
     */
    var _concat = function _concat(set1, set2) {
        set1 = set1 || [];
        set2 = set2 || [];
        var idx;
        var len1 = set1.length;
        var len2 = set2.length;
        var result = [];
        idx = 0;
        while (idx < len1) {
            result[result.length] = set1[idx];
            idx += 1;
        }
        idx = 0;
        while (idx < len2) {
            result[result.length] = set2[idx];
            idx += 1;
        }
        return result;
    };

    var _containsWith = function _containsWith(pred, x, list) {
        var idx = 0, len = list.length;
        while (idx < len) {
            if (pred(x, list[idx])) {
                return true;
            }
            idx += 1;
        }
        return false;
    };

    /**
     * Optimized internal two-arity curry function.
     *
     * @private
     * @category Function
     * @param {Function} fn The function to curry.
     * @return {Function} The curried function.
     */
    var _curry1 = function _curry1(fn) {
        return function f1(a) {
            if (arguments.length === 0) {
                return f1;
            } else if (a != null && a['@@functional/placeholder'] === true) {
                return f1;
            } else {
                return fn.apply(this, arguments);
            }
        };
    };

    /**
     * Optimized internal two-arity curry function.
     *
     * @private
     * @category Function
     * @param {Function} fn The function to curry.
     * @return {Function} The curried function.
     */
    var _curry2 = function _curry2(fn) {
        return function f2(a, b) {
            var n = arguments.length;
            if (n === 0) {
                return f2;
            } else if (n === 1 && a != null && a['@@functional/placeholder'] === true) {
                return f2;
            } else if (n === 1) {
                return _curry1(function (b) {
                    return fn(a, b);
                });
            } else if (n === 2 && a != null && a['@@functional/placeholder'] === true && b != null && b['@@functional/placeholder'] === true) {
                return f2;
            } else if (n === 2 && a != null && a['@@functional/placeholder'] === true) {
                return _curry1(function (a) {
                    return fn(a, b);
                });
            } else if (n === 2 && b != null && b['@@functional/placeholder'] === true) {
                return _curry1(function (b) {
                    return fn(a, b);
                });
            } else {
                return fn(a, b);
            }
        };
    };

    /**
     * Optimized internal three-arity curry function.
     *
     * @private
     * @category Function
     * @param {Function} fn The function to curry.
     * @return {Function} The curried function.
     */
    var _curry3 = function _curry3(fn) {
        return function f3(a, b, c) {
            var n = arguments.length;
            if (n === 0) {
                return f3;
            } else if (n === 1 && a != null && a['@@functional/placeholder'] === true) {
                return f3;
            } else if (n === 1) {
                return _curry2(function (b, c) {
                    return fn(a, b, c);
                });
            } else if (n === 2 && a != null && a['@@functional/placeholder'] === true && b != null && b['@@functional/placeholder'] === true) {
                return f3;
            } else if (n === 2 && a != null && a['@@functional/placeholder'] === true) {
                return _curry2(function (a, c) {
                    return fn(a, b, c);
                });
            } else if (n === 2 && b != null && b['@@functional/placeholder'] === true) {
                return _curry2(function (b, c) {
                    return fn(a, b, c);
                });
            } else if (n === 2) {
                return _curry1(function (c) {
                    return fn(a, b, c);
                });
            } else if (n === 3 && a != null && a['@@functional/placeholder'] === true && b != null && b['@@functional/placeholder'] === true && c != null && c['@@functional/placeholder'] === true) {
                return f3;
            } else if (n === 3 && a != null && a['@@functional/placeholder'] === true && b != null && b['@@functional/placeholder'] === true) {
                return _curry2(function (a, b) {
                    return fn(a, b, c);
                });
            } else if (n === 3 && a != null && a['@@functional/placeholder'] === true && c != null && c['@@functional/placeholder'] === true) {
                return _curry2(function (a, c) {
                    return fn(a, b, c);
                });
            } else if (n === 3 && b != null && b['@@functional/placeholder'] === true && c != null && c['@@functional/placeholder'] === true) {
                return _curry2(function (b, c) {
                    return fn(a, b, c);
                });
            } else if (n === 3 && a != null && a['@@functional/placeholder'] === true) {
                return _curry1(function (a) {
                    return fn(a, b, c);
                });
            } else if (n === 3 && b != null && b['@@functional/placeholder'] === true) {
                return _curry1(function (b) {
                    return fn(a, b, c);
                });
            } else if (n === 3 && c != null && c['@@functional/placeholder'] === true) {
                return _curry1(function (c) {
                    return fn(a, b, c);
                });
            } else {
                return fn(a, b, c);
            }
        };
    };

    /**
     * Internal curryN function.
     *
     * @private
     * @category Function
     * @param {Number} length The arity of the curried function.
     * @return {array} An array of arguments received thus far.
     * @param {Function} fn The function to curry.
     */
    var _curryN = function _curryN(length, received, fn) {
        return function () {
            var combined = [];
            var argsIdx = 0;
            var left = length;
            var combinedIdx = 0;
            while (combinedIdx < received.length || argsIdx < arguments.length) {
                var result;
                if (combinedIdx < received.length && (received[combinedIdx] == null || received[combinedIdx]['@@functional/placeholder'] !== true || argsIdx >= arguments.length)) {
                    result = received[combinedIdx];
                } else {
                    result = arguments[argsIdx];
                    argsIdx += 1;
                }
                combined[combinedIdx] = result;
                if (result == null || result['@@functional/placeholder'] !== true) {
                    left -= 1;
                }
                combinedIdx += 1;
            }
            return left <= 0 ? fn.apply(this, combined) : _arity(left, _curryN(length, combined, fn));
        };
    };

    var _filter = function _filter(fn, list) {
        var idx = 0, len = list.length, result = [];
        while (idx < len) {
            if (fn(list[idx])) {
                result[result.length] = list[idx];
            }
            idx += 1;
        }
        return result;
    };

    var _forceReduced = function _forceReduced(x) {
        return {
            '@@transducer/value': x,
            '@@transducer/reduced': true
        };
    };

    /**
     * @private
     * @param {Function} fn The strategy for extracting function names from an object
     * @return {Function} A function that takes an object and returns an array of function names.
     */
    var _functionsWith = function _functionsWith(fn) {
        return function (obj) {
            return _filter(function (key) {
                return typeof obj[key] === 'function';
            }, fn(obj));
        };
    };

    var _has = function _has(prop, obj) {
        return Object.prototype.hasOwnProperty.call(obj, prop);
    };

    var _identity = function _identity(x) {
        return x;
    };

    /**
     * Tests whether or not an object is an array.
     *
     * @private
     * @param {*} val The object to test.
     * @return {Boolean} `true` if `val` is an array, `false` otherwise.
     * @example
     *
     *      _isArray([]); //=> true
     *      _isArray(null); //=> false
     *      _isArray({}); //=> false
     */
    var _isArray = Array.isArray || function _isArray(val) {
        return val != null && val.length >= 0 && Object.prototype.toString.call(val) === '[object Array]';
    };

    /**
     * Determine if the passed argument is an integer.
     *
     * @private
     * @param {*} n
     * @category Type
     * @return {Boolean}
     */
    var _isInteger = Number.isInteger || function _isInteger(n) {
        return n << 0 === n;
    };

    var _isNumber = function _isNumber(x) {
        return Object.prototype.toString.call(x) === '[object Number]';
    };

    var _isString = function _isString(x) {
        return Object.prototype.toString.call(x) === '[object String]';
    };

    var _isTransformer = function _isTransformer(obj) {
        return typeof obj['@@transducer/step'] === 'function';
    };

    var _map = function _map(fn, list) {
        var idx = 0, len = list.length, result = Array(len);
        while (idx < len) {
            result[idx] = fn(list[idx]);
            idx += 1;
        }
        return result;
    };

    var _pipe = function _pipe(f, g) {
        return function () {
            return g.call(this, f.apply(this, arguments));
        };
    };

    var _pipeP = function _pipeP(f, g) {
        return function () {
            var ctx = this;
            return f.apply(ctx, arguments).then(function (x) {
                return g.call(ctx, x);
            });
        };
    };

    var _quote = function _quote(s) {
        return '"' + s.replace(/"/g, '\\"') + '"';
    };

    var _reduced = function _reduced(x) {
        return x && x['@@transducer/reduced'] ? x : {
            '@@transducer/value': x,
            '@@transducer/reduced': true
        };
    };

    /**
     * An optimized, private array `slice` implementation.
     *
     * @private
     * @param {Arguments|Array} args The array or arguments object to consider.
     * @param {Number} [from=0] The array index to slice from, inclusive.
     * @param {Number} [to=args.length] The array index to slice to, exclusive.
     * @return {Array} A new, sliced array.
     * @example
     *
     *      _slice([1, 2, 3, 4, 5], 1, 3); //=> [2, 3]
     *
     *      var firstThreeArgs = function(a, b, c, d) {
     *        return _slice(arguments, 0, 3);
     *      };
     *      firstThreeArgs(1, 2, 3, 4); //=> [1, 2, 3]
     */
    var _slice = function _slice(args, from, to) {
        switch (arguments.length) {
        case 1:
            return _slice(args, 0, args.length);
        case 2:
            return _slice(args, from, args.length);
        default:
            var list = [];
            var idx = 0;
            var len = Math.max(0, Math.min(args.length, to) - from);
            while (idx < len) {
                list[idx] = args[from + idx];
                idx += 1;
            }
            return list;
        }
    };

    /**
     * Polyfill from <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString>.
     */
    var _toISOString = function () {
        var pad = function pad(n) {
            return (n < 10 ? '0' : '') + n;
        };
        return typeof Date.prototype.toISOString === 'function' ? function _toISOString(d) {
            return d.toISOString();
        } : function _toISOString(d) {
            return d.getUTCFullYear() + '-' + pad(d.getUTCMonth() + 1) + '-' + pad(d.getUTCDate()) + 'T' + pad(d.getUTCHours()) + ':' + pad(d.getUTCMinutes()) + ':' + pad(d.getUTCSeconds()) + '.' + (d.getUTCMilliseconds() / 1000).toFixed(3).slice(2, 5) + 'Z';
        };
    }();

    var _xdropRepeatsWith = function () {
        function XDropRepeatsWith(pred, xf) {
            this.xf = xf;
            this.pred = pred;
            this.lastValue = undefined;
            this.seenFirstValue = false;
        }
        XDropRepeatsWith.prototype['@@transducer/init'] = function () {
            return this.xf['@@transducer/init']();
        };
        XDropRepeatsWith.prototype['@@transducer/result'] = function (result) {
            return this.xf['@@transducer/result'](result);
        };
        XDropRepeatsWith.prototype['@@transducer/step'] = function (result, input) {
            var sameAsLast = false;
            if (!this.seenFirstValue) {
                this.seenFirstValue = true;
            } else if (this.pred(this.lastValue, input)) {
                sameAsLast = true;
            }
            this.lastValue = input;
            return sameAsLast ? result : this.xf['@@transducer/step'](result, input);
        };
        return _curry2(function _xdropRepeatsWith(pred, xf) {
            return new XDropRepeatsWith(pred, xf);
        });
    }();

    var _xfBase = {
        init: function () {
            return this.xf['@@transducer/init']();
        },
        result: function (result) {
            return this.xf['@@transducer/result'](result);
        }
    };

    var _xfilter = function () {
        function XFilter(f, xf) {
            this.xf = xf;
            this.f = f;
        }
        XFilter.prototype['@@transducer/init'] = _xfBase.init;
        XFilter.prototype['@@transducer/result'] = _xfBase.result;
        XFilter.prototype['@@transducer/step'] = function (result, input) {
            return this.f(input) ? this.xf['@@transducer/step'](result, input) : result;
        };
        return _curry2(function _xfilter(f, xf) {
            return new XFilter(f, xf);
        });
    }();

    var _xfind = function () {
        function XFind(f, xf) {
            this.xf = xf;
            this.f = f;
            this.found = false;
        }
        XFind.prototype['@@transducer/init'] = _xfBase.init;
        XFind.prototype['@@transducer/result'] = function (result) {
            if (!this.found) {
                result = this.xf['@@transducer/step'](result, void 0);
            }
            return this.xf['@@transducer/result'](result);
        };
        XFind.prototype['@@transducer/step'] = function (result, input) {
            if (this.f(input)) {
                this.found = true;
                result = _reduced(this.xf['@@transducer/step'](result, input));
            }
            return result;
        };
        return _curry2(function _xfind(f, xf) {
            return new XFind(f, xf);
        });
    }();

    var _xfindIndex = function () {
        function XFindIndex(f, xf) {
            this.xf = xf;
            this.f = f;
            this.idx = -1;
            this.found = false;
        }
        XFindIndex.prototype['@@transducer/init'] = _xfBase.init;
        XFindIndex.prototype['@@transducer/result'] = function (result) {
            if (!this.found) {
                result = this.xf['@@transducer/step'](result, -1);
            }
            return this.xf['@@transducer/result'](result);
        };
        XFindIndex.prototype['@@transducer/step'] = function (result, input) {
            this.idx += 1;
            if (this.f(input)) {
                this.found = true;
                result = _reduced(this.xf['@@transducer/step'](result, this.idx));
            }
            return result;
        };
        return _curry2(function _xfindIndex(f, xf) {
            return new XFindIndex(f, xf);
        });
    }();

    var _xfindLast = function () {
        function XFindLast(f, xf) {
            this.xf = xf;
            this.f = f;
        }
        XFindLast.prototype['@@transducer/init'] = _xfBase.init;
        XFindLast.prototype['@@transducer/result'] = function (result) {
            return this.xf['@@transducer/result'](this.xf['@@transducer/step'](result, this.last));
        };
        XFindLast.prototype['@@transducer/step'] = function (result, input) {
            if (this.f(input)) {
                this.last = input;
            }
            return result;
        };
        return _curry2(function _xfindLast(f, xf) {
            return new XFindLast(f, xf);
        });
    }();

    var _xfindLastIndex = function () {
        function XFindLastIndex(f, xf) {
            this.xf = xf;
            this.f = f;
            this.idx = -1;
            this.lastIdx = -1;
        }
        XFindLastIndex.prototype['@@transducer/init'] = _xfBase.init;
        XFindLastIndex.prototype['@@transducer/result'] = function (result) {
            return this.xf['@@transducer/result'](this.xf['@@transducer/step'](result, this.lastIdx));
        };
        XFindLastIndex.prototype['@@transducer/step'] = function (result, input) {
            this.idx += 1;
            if (this.f(input)) {
                this.lastIdx = this.idx;
            }
            return result;
        };
        return _curry2(function _xfindLastIndex(f, xf) {
            return new XFindLastIndex(f, xf);
        });
    }();

    var _xmap = function () {
        function XMap(f, xf) {
            this.xf = xf;
            this.f = f;
        }
        XMap.prototype['@@transducer/init'] = _xfBase.init;
        XMap.prototype['@@transducer/result'] = _xfBase.result;
        XMap.prototype['@@transducer/step'] = function (result, input) {
            return this.xf['@@transducer/step'](result, this.f(input));
        };
        return _curry2(function _xmap(f, xf) {
            return new XMap(f, xf);
        });
    }();

    var _xtake = function () {
        function XTake(n, xf) {
            this.xf = xf;
            this.n = n;
        }
        XTake.prototype['@@transducer/init'] = _xfBase.init;
        XTake.prototype['@@transducer/result'] = _xfBase.result;
        XTake.prototype['@@transducer/step'] = function (result, input) {
            if (this.n === 0) {
                return _reduced(result);
            } else {
                this.n -= 1;
                return this.xf['@@transducer/step'](result, input);
            }
        };
        return _curry2(function _xtake(n, xf) {
            return new XTake(n, xf);
        });
    }();

    var _xtakeWhile = function () {
        function XTakeWhile(f, xf) {
            this.xf = xf;
            this.f = f;
        }
        XTakeWhile.prototype['@@transducer/init'] = _xfBase.init;
        XTakeWhile.prototype['@@transducer/result'] = _xfBase.result;
        XTakeWhile.prototype['@@transducer/step'] = function (result, input) {
            return this.f(input) ? this.xf['@@transducer/step'](result, input) : _reduced(result);
        };
        return _curry2(function _xtakeWhile(f, xf) {
            return new XTakeWhile(f, xf);
        });
    }();

    var _xwrap = function () {
        function XWrap(fn) {
            this.f = fn;
        }
        XWrap.prototype['@@transducer/init'] = function () {
            throw new Error('init not implemented on XWrap');
        };
        XWrap.prototype['@@transducer/result'] = function (acc) {
            return acc;
        };
        XWrap.prototype['@@transducer/step'] = function (acc, x) {
            return this.f(acc, x);
        };
        return function _xwrap(fn) {
            return new XWrap(fn);
        };
    }();

    /**
     * Adds two numbers. Equivalent to `a + b` but curried.
     *
     * @func
     * @memberOf R
     * @category Math
     * @sig Number -> Number -> Number
     * @param {Number} a
     * @param {Number} b
     * @return {Number}
     * @see R.subtract
     * @example
     *
     *      R.add(2, 3);       //=>  5
     *      R.add(7)(10);      //=> 17
     */
    var add = _curry2(function add(a, b) {
        return a + b;
    });

    /**
     * Applies a function to the value at the given index of an array,
     * returning a new copy of the array with the element at the given
     * index replaced with the result of the function application.
     * @see R.update
     *
     * @func
     * @memberOf R
     * @category List
     * @sig (a -> a) -> Number -> [a] -> [a]
     * @param {Function} fn The function to apply.
     * @param {Number} idx The index.
     * @param {Array|Arguments} list An array-like object whose value
     *        at the supplied index will be replaced.
     * @return {Array} A copy of the supplied array-like object with
     *         the element at index `idx` replaced with the value
     *         returned by applying `fn` to the existing element.
     * @example
     *
     *      R.adjust(R.add(10), 1, [0, 1, 2]);     //=> [0, 11, 2]
     *      R.adjust(R.add(10))(1)([0, 1, 2]);     //=> [0, 11, 2]
     */
    var adjust = _curry3(function adjust(fn, idx, list) {
        if (idx >= list.length || idx < -list.length) {
            return list;
        }
        var start = idx < 0 ? list.length : 0;
        var _idx = start + idx;
        var _list = _concat(list);
        _list[_idx] = fn(list[_idx]);
        return _list;
    });

    /**
     * Returns a function that always returns the given value. Note that for
     * non-primitives the value returned is a reference to the original value.
     *
     * This function is known as `const`, `constant`, or `K` (for K combinator)
     * in other languages and libraries.
     *
     * @func
     * @memberOf R
     * @category Function
     * @sig a -> (* -> a)
     * @param {*} val The value to wrap in a function
     * @return {Function} A Function :: * -> val.
     * @example
     *
     *      var t = R.always('Tee');
     *      t(); //=> 'Tee'
     */
    var always = _curry1(function always(val) {
        return function () {
            return val;
        };
    });

    /**
     * Returns a new list, composed of n-tuples of consecutive elements
     * If `n` is greater than the length of the list, an empty list is returned.
     *
     * @func
     * @memberOf R
     * @category List
     * @sig Number -> [a] -> [[a]]
     * @param {Number} n The size of the tuples to create
     * @param {Array} list The list to split into `n`-tuples
     * @return {Array} The new list.
     * @example
     *
     *      R.aperture(2, [1, 2, 3, 4, 5]); //=> [[1, 2], [2, 3], [3, 4], [4, 5]]
     *      R.aperture(3, [1, 2, 3, 4, 5]); //=> [[1, 2, 3], [2, 3, 4], [3, 4, 5]]
     *      R.aperture(7, [1, 2, 3, 4, 5]); //=> []
     */
    var aperture = _curry2(function aperture(n, list) {
        var idx = 0;
        var limit = list.length - (n - 1);
        var acc = new Array(limit >= 0 ? limit : 0);
        while (idx < limit) {
            acc[idx] = _slice(list, idx, idx + n);
            idx += 1;
        }
        return acc;
    });

    /**
     * Returns a new list containing the contents of the given list, followed by the given
     * element.
     *
     * @func
     * @memberOf R
     * @category List
     * @sig a -> [a] -> [a]
     * @param {*} el The element to add to the end of the new list.
     * @param {Array} list The list whose contents will be added to the beginning of the output
     *        list.
     * @return {Array} A new list containing the contents of the old list followed by `el`.
     * @see R.prepend
     * @example
     *
     *      R.append('tests', ['write', 'more']); //=> ['write', 'more', 'tests']
     *      R.append('tests', []); //=> ['tests']
     *      R.append(['tests'], ['write', 'more']); //=> ['write', 'more', ['tests']]
     */
    var append = _curry2(function append(el, list) {
        return _concat(list, [el]);
    });

    /**
     * Applies function `fn` to the argument list `args`. This is useful for
     * creating a fixed-arity function from a variadic function. `fn` should
     * be a bound function if context is significant.
     *
     * @func
     * @memberOf R
     * @category Function
     * @sig (*... -> a) -> [*] -> a
     * @param {Function} fn
     * @param {Array} args
     * @return {*}
     * @see R.call, R.unapply
     * @example
     *
     *      var nums = [1, 2, 3, -99, 42, 6, 7];
     *      R.apply(Math.max, nums); //=> 42
     */
    var apply = _curry2(function apply(fn, args) {
        return fn.apply(this, args);
    });

    /**
     * Makes a shallow clone of an object, setting or overriding the specified
     * property with the given value.  Note that this copies and flattens
     * prototype properties onto the new object as well.  All non-primitive
     * properties are copied by reference.
     *
     * @func
     * @memberOf R
     * @category Object
     * @sig String -> a -> {k: v} -> {k: v}
     * @param {String} prop the property name to set
     * @param {*} val the new value
     * @param {Object} obj the object to clone
     * @return {Object} a new object similar to the original except for the specified property.
     * @see R.dissoc
     * @example
     *
     *      R.assoc('c', 3, {a: 1, b: 2}); //=> {a: 1, b: 2, c: 3}
     */
    var assoc = _curry3(function assoc(prop, val, obj) {
        var result = {};
        for (var p in obj) {
            result[p] = obj[p];
        }
        result[prop] = val;
        return result;
    });

    /**
     * Makes a shallow clone of an object, setting or overriding the nodes
     * required to create the given path, and placing the specific value at the
     * tail end of that path.  Note that this copies and flattens prototype
     * properties onto the new object as well.  All non-primitive properties
     * are copied by reference.
     *
     * @func
     * @memberOf R
     * @category Object
     * @sig [String] -> a -> {k: v} -> {k: v}
     * @param {Array} path the path to set
     * @param {*} val the new value
     * @param {Object} obj the object to clone
     * @return {Object} a new object similar to the original except along the specified path.
     * @see R.dissocPath
     * @example
     *
     *      R.assocPath(['a', 'b', 'c'], 42, {a: {b: {c: 0}}}); //=> {a: {b: {c: 42}}}
     */
    var assocPath = _curry3(function assocPath(path, val, obj) {
        switch (path.length) {
        case 0:
            return obj;
        case 1:
            return assoc(path[0], val, obj);
        default:
            return assoc(path[0], assocPath(_slice(path, 1), val, Object(obj[path[0]])), obj);
        }
    });

    /**
     * Creates a function that is bound to a context.
     * Note: `R.bind` does not provide the additional argument-binding capabilities of
     * [Function.prototype.bind](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).
     *
     * @func
     * @memberOf R
     * @category Function
     * @category Object
     * @see R.partial
     * @sig (* -> *) -> {*} -> (* -> *)
     * @param {Function} fn The function to bind to context
     * @param {Object} thisObj The context to bind `fn` to
     * @return {Function} A function that will execute in the context of `thisObj`.
     */
    var bind = _curry2(function bind(fn, thisObj) {
        return _arity(fn.length, function () {
            return fn.apply(thisObj, arguments);
        });
    });

    /**
     * A function wrapping calls to the two functions in an `&&` operation, returning the result of the first
     * function if it is false-y and the result of the second function otherwise.  Note that this is
     * short-circuited, meaning that the second function will not be invoked if the first returns a false-y
     * value.
     *
     * @func
     * @memberOf R
     * @category Logic
     * @sig (*... -> Boolean) -> (*... -> Boolean) -> (*... -> Boolean)
     * @param {Function} f a predicate
     * @param {Function} g another predicate
     * @return {Function} a function that applies its arguments to `f` and `g` and `&&`s their outputs together.
     * @see R.and
     * @example
     *
     *      var gt10 = function(x) { return x > 10; };
     *      var even = function(x) { return x % 2 === 0 };
     *      var f = R.both(gt10, even);
     *      f(100); //=> true
     *      f(101); //=> false
     */
    var both = _curry2(function both(f, g) {
        return function _both() {
            return f.apply(this, arguments) && g.apply(this, arguments);
        };
    });

    /**
     * Makes a comparator function out of a function that reports whether the first element is less than the second.
     *
     * @func
     * @memberOf R
     * @category Function
     * @sig (a, b -> Boolean) -> (a, b -> Number)
     * @param {Function} pred A predicate function of arity two.
     * @return {Function} A Function :: a -> b -> Int that returns `-1` if a < b, `1` if b < a, otherwise `0`.
     * @example
     *
     *      var cmp = R.comparator(function(a, b) {
     *        return a.age < b.age;
     *      });
     *      var people = [
     *        // ...
     *      ];
     *      R.sort(cmp, people);
     */
    var comparator = _curry1(function comparator(pred) {
        return function (a, b) {
            return pred(a, b) ? -1 : pred(b, a) ? 1 : 0;
        };
    });

    /**
     * Takes a function `f` and returns a function `g` such that:
     *
     *   - applying `g` to zero or more arguments will give __true__ if applying
     *     the same arguments to `f` gives a logical __false__ value; and
     *
     *   - applying `g` to zero or more arguments will give __false__ if applying
     *     the same arguments to `f` gives a logical __true__ value.
     *
     * @func
     * @memberOf R
     * @category Logic
     * @sig (*... -> *) -> (*... -> Boolean)
     * @param {Function} f
     * @return {Function}
     * @see R.not
     * @example
     *
     *      var isEven = function(n) { return n % 2 === 0; };
     *      var isOdd = R.complement(isEven);
     *      isOdd(21); //=> true
     *      isOdd(42); //=> false
     */
    var complement = _curry1(_complement);

    /**
     * Returns a function, `fn`, which encapsulates if/else-if/else logic.
     * `R.cond` takes a list of [predicate, transform] pairs. All of the
     * arguments to `fn` are applied to each of the predicates in turn
     * until one returns a "truthy" value, at which point `fn` returns the
     * result of applying its arguments to the corresponding transformer.
     * If none of the predicates matches, `fn` returns undefined.
     *
     * @func
     * @memberOf R
     * @category Logic
     * @sig [[(*... -> Boolean),(*... -> *)]] -> (*... -> *)
     * @param {Array} pairs
     * @return {Function}
     * @example
     *
     *      var fn = R.cond([
     *        [R.equals(0),   R.always('water freezes at 0°C')],
     *        [R.equals(100), R.always('water boils at 100°C')],
     *        [R.T,           function(temp) { return 'nothing special happens at ' + temp + '°C'; }]
     *      ]);
     *      fn(0); //=> 'water freezes at 0°C'
     *      fn(50); //=> 'nothing special happens at 50°C'
     *      fn(100); //=> 'water boils at 100°C'
     */
    var cond = _curry1(function cond(pairs) {
        return function () {
            var idx = 0;
            while (idx < pairs.length) {
                if (pairs[idx][0].apply(this, arguments)) {
                    return pairs[idx][1].apply(this, arguments);
                }
                idx += 1;
            }
        };
    });

    /**
     * Returns `true` if the `x` is found in the `list`, using `pred` as an
     * equality predicate for `x`.
     *
     * @func
     * @memberOf R
     * @category List
     * @sig (a, a -> Boolean) -> a -> [a] -> Boolean
     * @param {Function} pred A predicate used to test whether two items are equal.
     * @param {*} x The item to find
     * @param {Array} list The list to iterate over
     * @return {Boolean} `true` if `x` is in `list`, else `false`.
     * @example
     *
     *      var xs = [{x: 12}, {x: 11}, {x: 10}];
     *      R.containsWith(function(a, b) { return a.x === b.x; }, {x: 10}, xs); //=> true
     *      R.containsWith(function(a, b) { return a.x === b.x; }, {x: 1}, xs); //=> false
     */
    var containsWith = _curry3(_containsWith);

    /**
     * Counts the elements of a list according to how many match each value
     * of a key generated by the supplied function. Returns an object
     * mapping the keys produced by `fn` to the number of occurrences in
     * the list. Note that all keys are coerced to strings because of how
     * JavaScript objects work.
     *
     * @func
     * @memberOf R
     * @category Relation
     * @sig (a -> String) -> [a] -> {*}
     * @param {Function} fn The function used to map values to keys.
     * @param {Array} list The list to count elements from.
     * @return {Object} An object mapping keys to number of occurrences in the list.
     * @example
     *
     *      var numbers = [1.0, 1.1, 1.2, 2.0, 3.0, 2.2];
     *      var letters = R.split('', 'abcABCaaaBBc');
     *      R.countBy(Math.floor)(numbers);    //=> {'1': 3, '2': 2, '3': 1}
     *      R.countBy(R.toLower)(letters);   //=> {'a': 5, 'b': 4, 'c': 3}
     */
    var countBy = _curry2(function countBy(fn, list) {
        var counts = {};
        var len = list.length;
        var idx = 0;
        while (idx < len) {
            var key = fn(list[idx]);
            counts[key] = (_has(key, counts) ? counts[key] : 0) + 1;
            idx += 1;
        }
        return counts;
    });

    /**
     * Creates an object containing a single key:value pair.
     *
     * @func
     * @memberOf R
     * @category Object
     * @sig String -> a -> {String:a}
     * @param {String} key
     * @param {*} val
     * @return {Object}
     * @example
     *
     *      var matchPhrases = R.compose(
     *        R.createMapEntry('must'),
     *        R.map(R.createMapEntry('match_phrase'))
     *      );
     *      matchPhrases(['foo', 'bar', 'baz']); //=> {must: [{match_phrase: 'foo'}, {match_phrase: 'bar'}, {match_phrase: 'baz'}]}
     */
    var createMapEntry = _curry2(function createMapEntry(key, val) {
        var obj = {};
        obj[key] = val;
        return obj;
    });

    /**
     * Returns a curried equivalent of the provided function, with the
     * specified arity. The curried function has two unusual capabilities.
     * First, its arguments needn't be provided one at a time. If `g` is
     * `R.curryN(3, f)`, the following are equivalent:
     *
     *   - `g(1)(2)(3)`
     *   - `g(1)(2, 3)`
     *   - `g(1, 2)(3)`
     *   - `g(1, 2, 3)`
     *
     * Secondly, the special placeholder value `R.__` may be used to specify
     * "gaps", allowing partial application of any combination of arguments,
     * regardless of their positions. If `g` is as above and `_` is `R.__`,
     * the following are equivalent:
     *
     *   - `g(1, 2, 3)`
     *   - `g(_, 2, 3)(1)`
     *   - `g(_, _, 3)(1)(2)`
     *   - `g(_, _, 3)(1, 2)`
     *   - `g(_, 2)(1)(3)`
     *   - `g(_, 2)(1, 3)`
     *   - `g(_, 2)(_, 3)(1)`
     *
     * @func
     * @memberOf R
     * @category Function
     * @sig Number -> (* -> a) -> (* -> a)
     * @param {Number} length The arity for the returned function.
     * @param {Function} fn The function to curry.
     * @return {Function} A new, curried function.
     * @see R.curry
     * @example
     *
     *      var addFourNumbers = function() {
     *        return R.sum([].slice.call(arguments, 0, 4));
     *      };
     *
     *      var curriedAddFourNumbers = R.curryN(4, addFourNumbers);
     *      var f = curriedAddFourNumbers(1, 2);
     *      var g = f(3);
     *      g(4); //=> 10
     */
    var curryN = _curry2(function curryN(length, fn) {
        if (length === 1) {
            return _curry1(fn);
        }
        return _arity(length, _curryN(length, [], fn));
    });

    /**
     * Decrements its argument.
     *
     * @func
     * @memberOf R
     * @category Math
     * @sig Number -> Number
     * @param {Number} n
     * @return {Number}
     * @see R.inc
     * @example
     *
     *      R.dec(42); //=> 41
     */
    var dec = add(-1);

    /**
     * Returns the second argument if it is not null or undefined. If it is null
     * or undefined, the first (default) argument is returned.
     *
     * @func
     * @memberOf R
     * @category Logic
     * @sig a -> b -> a | b
     * @param {a} val The default value.
     * @param {b} val The value to return if it is not null or undefined
     * @return {*} The the second value or the default value
     * @example
     *
     *      var defaultTo42 = defaultTo(42);
     *
     *      defaultTo42(null);  //=> 42
     *      defaultTo42(undefined);  //=> 42
     *      defaultTo42('Ramda');  //=> 'Ramda'
     */
    var defaultTo = _curry2(function defaultTo(d, v) {
        return v == null ? d : v;
    });

    /**
     * Finds the set (i.e. no duplicates) of all elements in the first list not contained in the second list.
     * Duplication is determined according to the value returned by applying the supplied predicate to two list
     * elements.
     *
     * @func
     * @memberOf R
     * @category Relation
     * @sig (a,a -> Boolean) -> [a] -> [a] -> [a]
     * @param {Function} pred A predicate used to test whether two items are equal.
     * @param {Array} list1 The first list.
     * @param {Array} list2 The second list.
     * @see R.difference
     * @return {Array} The elements in `list1` that are not in `list2`.
     * @example
     *
     *      function cmp(x, y) { return x.a === y.a; }
     *      var l1 = [{a: 1}, {a: 2}, {a: 3}];
     *      var l2 = [{a: 3}, {a: 4}];
     *      R.differenceWith(cmp, l1, l2); //=> [{a: 1}, {a: 2}]
     */
    var differenceWith = _curry3(function differenceWith(pred, first, second) {
        var out = [];
        var idx = 0;
        var firstLen = first.length;
        var containsPred = containsWith(pred);
        while (idx < firstLen) {
            if (!containsPred(first[idx], second) && !containsPred(first[idx], out)) {
                out[out.length] = first[idx];
            }
            idx += 1;
        }
        return out;
    });

    /**
     * Returns a new object that does not contain a `prop` property.
     *
     * @func
     * @memberOf R
     * @category Object
     * @sig String -> {k: v} -> {k: v}
     * @param {String} prop the name of the property to dissociate
     * @param {Object} obj the object to clone
     * @return {Object} a new object similar to the original but without the specified property
     * @see R.assoc
     * @example
     *
     *      R.dissoc('b', {a: 1, b: 2, c: 3}); //=> {a: 1, c: 3}
     */
    var dissoc = _curry2(function dissoc(prop, obj) {
        var result = {};
        for (var p in obj) {
            if (p !== prop) {
                result[p] = obj[p];
            }
        }
        return result;
    });

    /**
     * Makes a shallow clone of an object, omitting the property at the
     * given path. Note that this copies and flattens prototype properties
     * onto the new object as well.  All non-primitive properties are copied
     * by reference.
     *
     * @func
     * @memberOf R
     * @category Object
     * @sig [String] -> {k: v} -> {k: v}
     * @param {Array} path the path to set
     * @param {Object} obj the object to clone
     * @return {Object} a new object without the property at path
     * @see R.assocPath
     * @example
     *
     *      R.dissocPath(['a', 'b', 'c'], {a: {b: {c: 42}}}); //=> {a: {b: {}}}
     */
    var dissocPath = _curry2(function dissocPath(path, obj) {
        switch (path.length) {
        case 0:
            return obj;
        case 1:
            return dissoc(path[0], obj);
        default:
            var head = path[0];
            var tail = _slice(path, 1);
            return obj[head] == null ? obj : assoc(head, dissocPath(tail, obj[head]), obj);
        }
    });

    /**
     * Divides two numbers. Equivalent to `a / b`.
     *
     * @func
     * @memberOf R
     * @category Math
     * @sig Number -> Number -> Number
     * @param {Number} a The first value.
     * @param {Number} b The second value.
     * @return {Number} The result of `a / b`.
     * @see R.multiply
     * @example
     *
     *      R.divide(71, 100); //=> 0.71
     *
     *      var half = R.divide(R.__, 2);
     *      half(42); //=> 21
     *
     *      var reciprocal = R.divide(1);
     *      reciprocal(4);   //=> 0.25
     */
    var divide = _curry2(function divide(a, b) {
        return a / b;
    });

    /**
     * Returns a new list containing all but last the`n` elements of a given list,
     * passing each value from the right to the supplied predicate function, skipping
     * elements while the predicate function returns `true`. The predicate function
     * is passed one argument: (value)*.
     *
     * @func
     * @memberOf R
     * @category List
     * @sig (a -> Boolean) -> [a] -> [a]
     * @param {Function} fn The function called per iteration.
     * @param {Array} list The collection to iterate over.
     * @return {Array} A new array.
     * @see R.takeLastWhile
     * @example
     *
     *      var lteThree = function(x) {
     *        return x <= 3;
     *      };
     *
     *      R.dropLastWhile(lteThree, [1, 2, 3, 4, 3, 2, 1]); //=> [1, 2]
     */
    var dropLastWhile = _curry2(function dropLastWhile(pred, list) {
        var idx = list.length - 1;
        while (idx >= 0 && pred(list[idx])) {
            idx -= 1;
        }
        return _slice(list, 0, idx + 1);
    });

    /**
     * A function wrapping calls to the two functions in an `||` operation, returning the result of the first
     * function if it is truth-y and the result of the second function otherwise.  Note that this is
     * short-circuited, meaning that the second function will not be invoked if the first returns a truth-y
     * value.
     *
     * @func
     * @memberOf R
     * @category Logic
     * @sig (*... -> Boolean) -> (*... -> Boolean) -> (*... -> Boolean)
     * @param {Function} f a predicate
     * @param {Function} g another predicate
     * @return {Function} a function that applies its arguments to `f` and `g` and `||`s their outputs together.
     * @see R.or
     * @example
     *
     *      var gt10 = function(x) { return x > 10; };
     *      var even = function(x) { return x % 2 === 0 };
     *      var f = R.either(gt10, even);
     *      f(101); //=> true
     *      f(8); //=> true
     */
    var either = _curry2(function either(f, g) {
        return function _either() {
            return f.apply(this, arguments) || g.apply(this, arguments);
        };
    });

    /**
     * Returns the empty value of its argument's type. Ramda defines the empty
     * value of Array (`[]`), Object (`{}`), and String (`''`). Other types are
     * supported if they define `<Type>.empty` and/or `<Type>.prototype.empty`.
     *
     * @func
     * @memberOf R
     * @category Function
     * @sig a -> a
     * @param {*} x
     * @return {*}
     * @example
     *
     *      R.empty(Just(42));      //=> Nothing()
     *      R.empty([1, 2, 3]);     //=> []
     *      R.empty('unicorns');    //=> ''
     *      R.empty({x: 1, y: 2});  //=> {}
     */
    var empty = _curry1(function empty(x) {
        if (x != null && typeof x.empty === 'function') {
            return x.empty();
        } else if (x != null && typeof x.constructor != null && typeof x.constructor.empty === 'function') {
            return x.constructor.empty();
        } else {
            switch (Object.prototype.toString.call(x)) {
            case '[object Array]':
                return [];
            case '[object Object]':
                return {};
            case '[object String]':
                return '';
            }
        }
    });

    /**
     * Creates a new object by recursively evolving a shallow copy of `object`, according to the
     * `transformation` functions. All non-primitive properties are copied by reference.
     *
     * A `tranformation` function will not be invoked if its corresponding key does not exist in
     * the evolved object.
     *
     * @func
     * @memberOf R
     * @category Object
     * @sig {k: (v -> v)} -> {k: v} -> {k: v}
     * @param {Object} transformations The object specifying transformation functions to apply
     *        to the object.
     * @param {Object} object The object to be transformed.
     * @return {Object} The transformed object.
     * @example
     *
     *      var tomato  = {firstName: '  Tomato ', data: {elapsed: 100, remaining: 1400}, id:123};
     *      var transformations = {
     *        firstName: R.trim,
     *        lastName: R.trim, // Will not get invoked.
     *        data: {elapsed: R.add(1), remaining: R.add(-1)}
     *      };
     *      R.evolve(transformations, tomato); //=> {firstName: 'Tomato', data: {elapsed: 101, remaining: 1399}, id:123}
     */
    var evolve = _curry2(function evolve(transformations, object) {
        var transformation, key, type, result = {};
        for (key in object) {
            transformation = transformations[key];
            type = typeof transformation;
            result[key] = type === 'function' ? transformation(object[key]) : type === 'object' ? evolve(transformations[key], object[key]) : object[key];
        }
        return result;
    });

    /**
     * Creates a new object out of a list key-value pairs.
     *
     * @func
     * @memberOf R
     * @category List
     * @sig [[k,v]] -> {k: v}
     * @param {Array} pairs An array of two-element arrays that will be the keys and values of the output object.
     * @return {Object} The object made by pairing up `keys` and `values`.
     * @see R.toPairs
     * @example
     *
     *      R.fromPairs([['a', 1], ['b', 2],  ['c', 3]]); //=> {a: 1, b: 2, c: 3}
     */
    var fromPairs = _curry1(function fromPairs(pairs) {
        var idx = 0, len = pairs.length, out = {};
        while (idx < len) {
            if (_isArray(pairs[idx]) && pairs[idx].length) {
                out[pairs[idx][0]] = pairs[idx][1];
            }
            idx += 1;
        }
        return out;
    });

    /**
     * Returns `true` if the first argument is greater than the second;
     * `false` otherwise.
     *
     * @func
     * @memberOf R
     * @category Relation
     * @sig Ord a => a -> a -> Boolean
     * @param {*} a
     * @param {*} b
     * @return {Boolean}
     * @see R.lt
     * @example
     *
     *      R.gt(2, 1); //=> true
     *      R.gt(2, 2); //=> false
     *      R.gt(2, 3); //=> false
     *      R.gt('a', 'z'); //=> false
     *      R.gt('z', 'a'); //=> true
     */
    var gt = _curry2(function gt(a, b) {
        return a > b;
    });

    /**
     * Returns `true` if the first argument is greater than or equal to the second;
     * `false` otherwise.
     *
     * @func
     * @memberOf R
     * @category Relation
     * @sig Ord a => a -> a -> Boolean
     * @param {Number} a
     * @param {Number} b
     * @return {Boolean}
     * @see R.lte
     * @example
     *
     *      R.gte(2, 1); //=> true
     *      R.gte(2, 2); //=> true
     *      R.gte(2, 3); //=> false
     *      R.gte('a', 'z'); //=> false
     *      R.gte('z', 'a'); //=> true
     */
    var gte = _curry2(function gte(a, b) {
        return a >= b;
    });

    /**
     * Returns whether or not an object has an own property with
     * the specified name
     *
     * @func
     * @memberOf R
     * @category Object
     * @sig s -> {s: x} -> Boolean
     * @param {String} prop The name of the property to check for.
     * @param {Object} obj The object to query.
     * @return {Boolean} Whether the property exists.
     * @example
     *
     *      var hasName = R.has('name');
     *      hasName({name: 'alice'});   //=> true
     *      hasName({name: 'bob'});     //=> true
     *      hasName({});                //=> false
     *
     *      var point = {x: 0, y: 0};
     *      var pointHas = R.has(R.__, point);
     *      pointHas('x');  //=> true
     *      pointHas('y');  //=> true
     *      pointHas('z');  //=> false
     */
    var has = _curry2(_has);

    /**
     * Returns whether or not an object or its prototype chain has
     * a property with the specified name
     *
     * @func
     * @memberOf R
     * @category Object
     * @sig s -> {s: x} -> Boolean
     * @param {String} prop The name of the property to check for.
     * @param {Object} obj The object to query.
     * @return {Boolean} Whether the property exists.
     * @example
     *
     *      function Rectangle(width, height) {
     *        this.width = width;
     *        this.height = height;
     *      }
     *      Rectangle.prototype.area = function() {
     *        return this.width * this.height;
     *      };
     *
     *      var square = new Rectangle(2, 2);
     *      R.hasIn('width', square);  //=> true
     *      R.hasIn('area', square);  //=> true
     */
    var hasIn = _curry2(function hasIn(prop, obj) {
        return prop in obj;
    });

    /**
     * Returns true if its arguments are identical, false otherwise. Values are
     * identical if they reference the same memory. `NaN` is identical to `NaN`;
     * `0` and `-0` are not identical.
     *
     * @func
     * @memberOf R
     * @category Relation
     * @sig a -> a -> Boolean
     * @param {*} a
     * @param {*} b
     * @return {Boolean}
     * @example
     *
     *      var o = {};
     *      R.identical(o, o); //=> true
     *      R.identical(1, 1); //=> true
     *      R.identical(1, '1'); //=> false
     *      R.identical([], []); //=> false
     *      R.identical(0, -0); //=> false
     *      R.identical(NaN, NaN); //=> true
     */
    // SameValue algorithm
    // Steps 1-5, 7-10
    // Steps 6.b-6.e: +0 != -0
    // Step 6.a: NaN == NaN
    var identical = _curry2(function identical(a, b) {
        // SameValue algorithm
        if (a === b) {
            // Steps 1-5, 7-10
            // Steps 6.b-6.e: +0 != -0
            return a !== 0 || 1 / a === 1 / b;
        } else {
            // Step 6.a: NaN == NaN
            return a !== a && b !== b;
        }
    });

    /**
     * A function that does nothing but return the parameter supplied to it. Good as a default
     * or placeholder function.
     *
     * @func
     * @memberOf R
     * @category Function
     * @sig a -> a
     * @param {*} x The value to return.
     * @return {*} The input value, `x`.
     * @example
     *
     *      R.identity(1); //=> 1
     *
     *      var obj = {};
     *      R.identity(obj) === obj; //=> true
     */
    var identity = _curry1(_identity);

    /**
     * Creates a function that will process either the `onTrue` or the `onFalse` function depending
     * upon the result of the `condition` predicate.
     *
     * @func
     * @memberOf R
     * @category Logic
     * @sig (*... -> Boolean) -> (*... -> *) -> (*... -> *) -> (*... -> *)
     * @param {Function} condition A predicate function
     * @param {Function} onTrue A function to invoke when the `condition` evaluates to a truthy value.
     * @param {Function} onFalse A function to invoke when the `condition` evaluates to a falsy value.
     * @return {Function} A new unary function that will process either the `onTrue` or the `onFalse`
     *                    function depending upon the result of the `condition` predicate.
     * @example
     *
     *      // Flatten all arrays in the list but leave other values alone.
     *      var flattenArrays = R.map(R.ifElse(Array.isArray, R.flatten, R.identity));
     *
     *      flattenArrays([[0], [[10], [8]], 1234, {}]); //=> [[0], [10, 8], 1234, {}]
     *      flattenArrays([[[10], 123], [8, [10]], "hello"]); //=> [[10, 123], [8, 10], "hello"]
     */
    var ifElse = _curry3(function ifElse(condition, onTrue, onFalse) {
        return curryN(Math.max(condition.length, onTrue.length, onFalse.length), function _ifElse() {
            return condition.apply(this, arguments) ? onTrue.apply(this, arguments) : onFalse.apply(this, arguments);
        });
    });

    /**
     * Increments its argument.
     *
     * @func
     * @memberOf R
     * @category Math
     * @sig Number -> Number
     * @param {Number} n
     * @return {Number}
     * @see R.dec
     * @example
     *
     *      R.inc(42); //=> 43
     */
    var inc = add(1);

    /**
     * Inserts the supplied element into the list, at index `index`.  _Note
     * that this is not destructive_: it returns a copy of the list with the changes.
     * <small>No lists have been harmed in the application of this function.</small>
     *
     * @func
     * @memberOf R
     * @category List
     * @sig Number -> a -> [a] -> [a]
     * @param {Number} index The position to insert the element
     * @param {*} elt The element to insert into the Array
     * @param {Array} list The list to insert into
     * @return {Array} A new Array with `elt` inserted at `index`.
     * @example
     *
     *      R.insert(2, 'x', [1,2,3,4]); //=> [1,2,'x',3,4]
     */
    var insert = _curry3(function insert(idx, elt, list) {
        idx = idx < list.length && idx >= 0 ? idx : list.length;
        var result = _slice(list);
        result.splice(idx, 0, elt);
        return result;
    });

    /**
     * Inserts the sub-list into the list, at index `index`.  _Note  that this
     * is not destructive_: it returns a copy of the list with the changes.
     * <small>No lists have been harmed in the application of this function.</small>
     *
     * @func
     * @memberOf R
     * @category List
     * @sig Number -> [a] -> [a] -> [a]
     * @param {Number} index The position to insert the sub-list
     * @param {Array} elts The sub-list to insert into the Array
     * @param {Array} list The list to insert the sub-list into
     * @return {Array} A new Array with `elts` inserted starting at `index`.
     * @example
     *
     *      R.insertAll(2, ['x','y','z'], [1,2,3,4]); //=> [1,2,'x','y','z',3,4]
     */
    var insertAll = _curry3(function insertAll(idx, elts, list) {
        idx = idx < list.length && idx >= 0 ? idx : list.length;
        return _concat(_concat(_slice(list, 0, idx), elts), _slice(list, idx));
    });

    /**
     * See if an object (`val`) is an instance of the supplied constructor.
     * This function will check up the inheritance chain, if any.
     *
     * @func
     * @memberOf R
     * @category Type
     * @sig (* -> {*}) -> a -> Boolean
     * @param {Object} ctor A constructor
     * @param {*} val The value to test
     * @return {Boolean}
     * @example
     *
     *      R.is(Object, {}); //=> true
     *      R.is(Number, 1); //=> true
     *      R.is(Object, 1); //=> false
     *      R.is(String, 's'); //=> true
     *      R.is(String, new String('')); //=> true
     *      R.is(Object, new String('')); //=> true
     *      R.is(Object, 's'); //=> false
     *      R.is(Number, {}); //=> false
     */
    var is = _curry2(function is(Ctor, val) {
        return val != null && val.constructor === Ctor || val instanceof Ctor;
    });

    /**
     * Tests whether or not an object is similar to an array.
     *
     * @func
     * @memberOf R
     * @category Type
     * @category List
     * @sig * -> Boolean
     * @param {*} x The object to test.
     * @return {Boolean} `true` if `x` has a numeric length property and extreme indices defined; `false` otherwise.
     * @example
     *
     *      R.isArrayLike([]); //=> true
     *      R.isArrayLike(true); //=> false
     *      R.isArrayLike({}); //=> false
     *      R.isArrayLike({length: 10}); //=> false
     *      R.isArrayLike({0: 'zero', 9: 'nine', length: 10}); //=> true
     */
    var isArrayLike = _curry1(function isArrayLike(x) {
        if (_isArray(x)) {
            return true;
        }
        if (!x) {
            return false;
        }
        if (typeof x !== 'object') {
            return false;
        }
        if (x instanceof String) {
            return false;
        }
        if (x.nodeType === 1) {
            return !!x.length;
        }
        if (x.length === 0) {
            return true;
        }
        if (x.length > 0) {
            return x.hasOwnProperty(0) && x.hasOwnProperty(x.length - 1);
        }
        return false;
    });

    /**
     * Reports whether the list has zero elements.
     *
     * @func
     * @memberOf R
     * @category Logic
     * @sig [a] -> Boolean
     * @param {Array} list
     * @return {Boolean}
     * @example
     *
     *      R.isEmpty([1, 2, 3]);   //=> false
     *      R.isEmpty([]);          //=> true
     *      R.isEmpty('');          //=> true
     *      R.isEmpty(null);        //=> false
     *      R.isEmpty(R.keys({}));  //=> true
     *      R.isEmpty({});          //=> false ({} does not have a length property)
     *      R.isEmpty({length: 0}); //=> true
     */
    var isEmpty = _curry1(function isEmpty(list) {
        return Object(list).length === 0;
    });

    /**
     * Checks if the input value is `null` or `undefined`.
     *
     * @func
     * @memberOf R
     * @category Type
     * @sig * -> Boolean
     * @param {*} x The value to test.
     * @return {Boolean} `true` if `x` is `undefined` or `null`, otherwise `false`.
     * @example
     *
     *      R.isNil(null); //=> true
     *      R.isNil(undefined); //=> true
     *      R.isNil(0); //=> false
     *      R.isNil([]); //=> false
     */
    var isNil = _curry1(function isNil(x) {
        return x == null;
    });

    /**
     * Returns a list containing the names of all the enumerable own
     * properties of the supplied object.
     * Note that the order of the output array is not guaranteed to be
     * consistent across different JS platforms.
     *
     * @func
     * @memberOf R
     * @category Object
     * @sig {k: v} -> [k]
     * @param {Object} obj The object to extract properties from
     * @return {Array} An array of the object's own properties.
     * @example
     *
     *      R.keys({a: 1, b: 2, c: 3}); //=> ['a', 'b', 'c']
     */
    // cover IE < 9 keys issues
    var keys = function () {
        // cover IE < 9 keys issues
        var hasEnumBug = !{ toString: null }.propertyIsEnumerable('toString');
        var nonEnumerableProps = [
            'constructor',
            'valueOf',
            'isPrototypeOf',
            'toString',
            'propertyIsEnumerable',
            'hasOwnProperty',
            'toLocaleString'
        ];
        var contains = function contains(list, item) {
            var idx = 0;
            while (idx < list.length) {
                if (list[idx] === item) {
                    return true;
                }
                idx += 1;
            }
            return false;
        };
        return typeof Object.keys === 'function' ? _curry1(function keys(obj) {
            return Object(obj) !== obj ? [] : Object.keys(obj);
        }) : _curry1(function keys(obj) {
            if (Object(obj) !== obj) {
                return [];
            }
            var prop, ks = [], nIdx;
            for (prop in obj) {
                if (_has(prop, obj)) {
                    ks[ks.length] = prop;
                }
            }
            if (hasEnumBug) {
                nIdx = nonEnumerableProps.length - 1;
                while (nIdx >= 0) {
                    prop = nonEnumerableProps[nIdx];
                    if (_has(prop, obj) && !contains(ks, prop)) {
                        ks[ks.length] = prop;
                    }
                    nIdx -= 1;
                }
            }
            return ks;
        });
    }();

    /**
     * Returns a list containing the names of all the
     * properties of the supplied object, including prototype properties.
     * Note that the order of the output array is not guaranteed to be
     * consistent across different JS platforms.
     *
     * @func
     * @memberOf R
     * @category Object
     * @sig {k: v} -> [k]
     * @param {Object} obj The object to extract properties from
     * @return {Array} An array of the object's own and prototype properties.
     * @example
     *
     *      var F = function() { this.x = 'X'; };
     *      F.prototype.y = 'Y';
     *      var f = new F();
     *      R.keysIn(f); //=> ['x', 'y']
     */
    var keysIn = _curry1(function keysIn(obj) {
        var prop, ks = [];
        for (prop in obj) {
            ks[ks.length] = prop;
        }
        return ks;
    });

    /**
     * Returns the number of elements in the array by returning `list.length`.
     *
     * @func
     * @memberOf R
     * @category List
     * @sig [a] -> Number
     * @param {Array} list The array to inspect.
     * @return {Number} The length of the array.
     * @example
     *
     *      R.length([]); //=> 0
     *      R.length([1, 2, 3]); //=> 3
     */
    var length = _curry1(function length(list) {
        return list != null && is(Number, list.length) ? list.length : NaN;
    });

    /**
     * Returns `true` if the first argument is less than the second;
     * `false` otherwise.
     *
     * @func
     * @memberOf R
     * @category Relation
     * @sig Ord a => a -> a -> Boolean
     * @param {*} a
     * @param {*} b
     * @return {Boolean}
     * @see R.gt
     * @example
     *
     *      R.lt(2, 1); //=> false
     *      R.lt(2, 2); //=> false
     *      R.lt(2, 3); //=> true
     *      R.lt('a', 'z'); //=> true
     *      R.lt('z', 'a'); //=> false
     */
    var lt = _curry2(function lt(a, b) {
        return a < b;
    });

    /**
     * Returns `true` if the first argument is less than or equal to the second;
     * `false` otherwise.
     *
     * @func
     * @memberOf R
     * @category Relation
     * @sig Ord a => a -> a -> Boolean
     * @param {Number} a
     * @param {Number} b
     * @return {Boolean}
     * @see R.gte
     * @example
     *
     *      R.lte(2, 1); //=> false
     *      R.lte(2, 2); //=> true
     *      R.lte(2, 3); //=> true
     *      R.lte('a', 'z'); //=> true
     *      R.lte('z', 'a'); //=> false
     */
    var lte = _curry2(function lte(a, b) {
        return a <= b;
    });

    /**
     * The mapAccum function behaves like a combination of map and reduce; it applies a
     * function to each element of a list, passing an accumulating parameter from left to
     * right, and returning a final value of this accumulator together with the new list.
     *
     * The iterator function receives two arguments, *acc* and *value*, and should return
     * a tuple *[acc, value]*.
     *
     * @func
     * @memberOf R
     * @category List
     * @sig (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
     * @param {Function} fn The function to be called on every element of the input `list`.
     * @param {*} acc The accumulator value.
     * @param {Array} list The list to iterate over.
     * @return {*} The final, accumulated value.
     * @example
     *
     *      var digits = ['1', '2', '3', '4'];
     *      var append = function(a, b) {
     *        return [a + b, a + b];
     *      }
     *
     *      R.mapAccum(append, 0, digits); //=> ['01234', ['01', '012', '0123', '01234']]
     */
    var mapAccum = _curry3(function mapAccum(fn, acc, list) {
        var idx = 0, len = list.length, result = [], tuple = [acc];
        while (idx < len) {
            tuple = fn(tuple[0], list[idx]);
            result[idx] = tuple[1];
            idx += 1;
        }
        return [
            tuple[0],
            result
        ];
    });

    /**
     * The mapAccumRight function behaves like a combination of map and reduce; it applies a
     * function to each element of a list, passing an accumulating parameter from right
     * to left, and returning a final value of this accumulator together with the new list.
     *
     * Similar to `mapAccum`, except moves through the input list from the right to the
     * left.
     *
     * The iterator function receives two arguments, *acc* and *value*, and should return
     * a tuple *[acc, value]*.
     *
     * @func
     * @memberOf R
     * @category List
     * @sig (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])
     * @param {Function} fn The function to be called on every element of the input `list`.
     * @param {*} acc The accumulator value.
     * @param {Array} list The list to iterate over.
     * @return {*} The final, accumulated value.
     * @example
     *
     *      var digits = ['1', '2', '3', '4'];
     *      var append = function(a, b) {
     *        return [a + b, a + b];
     *      }
     *
     *      R.mapAccumRight(append, 0, digits); //=> ['04321', ['04321', '0432', '043', '04']]
     */
    var mapAccumRight = _curry3(function mapAccumRight(fn, acc, list) {
        var idx = list.length - 1, result = [], tuple = [acc];
        while (idx >= 0) {
            tuple = fn(tuple[0], list[idx]);
            result[idx] = tuple[1];
            idx -= 1;
        }
        return [
            tuple[0],
            result
        ];
    });

    /**
     * Tests a regular expression against a String. Note that this function
     * will return an empty array when there are no matches. This differs
     * from [`String.prototype.match`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/match)
     * which returns `null` when there are no matches.
     *
     * @func
     * @memberOf R
     * @see R.test
     * @category String
     * @sig RegExp -> String -> [String | Undefined]
     * @param {RegExp} rx A regular expression.
     * @param {String} str The string to match against
     * @return {Array} The list of matches or empty array.
     * @example
     *
     *      R.match(/([a-z]a)/g, 'bananas'); //=> ['ba', 'na', 'na']
     *      R.match(/a/, 'b'); //=> []
     *      R.match(/a/, null); //=> TypeError: null does not have a method named "match"
     */
    var match = _curry2(function match(rx, str) {
        return str.match(rx) || [];
    });

    /**
     * mathMod behaves like the modulo operator should mathematically, unlike the `%`
     * operator (and by extension, R.modulo). So while "-17 % 5" is -2,
     * mathMod(-17, 5) is 3. mathMod requires Integer arguments, and returns NaN
     * when the modulus is zero or negative.
     *
     * @func
     * @memberOf R
     * @category Math
     * @sig Number -> Number -> Number
     * @param {Number} m The dividend.
     * @param {Number} p the modulus.
     * @return {Number} The result of `b mod a`.
     * @example
     *
     *      R.mathMod(-17, 5);  //=> 3
     *      R.mathMod(17, 5);   //=> 2
     *      R.mathMod(17, -5);  //=> NaN
     *      R.mathMod(17, 0);   //=> NaN
     *      R.mathMod(17.2, 5); //=> NaN
     *      R.mathMod(17, 5.3); //=> NaN
     *
     *      var clock = R.mathMod(R.__, 12);
     *      clock(15); //=> 3
     *      clock(24); //=> 0
     *
     *      var seventeenMod = R.mathMod(17);
     *      seventeenMod(3);  //=> 2
     *      seventeenMod(4);  //=> 1
     *      seventeenMod(10); //=> 7
     */
    var mathMod = _curry2(function mathMod(m, p) {
        if (!_isInteger(m)) {
            return NaN;
        }
        if (!_isInteger(p) || p < 1) {
            return NaN;
        }
        return (m % p + p) % p;
    });

    /**
     * Returns the larger of its two arguments.
     *
     * @func
     * @memberOf R
     * @category Relation
     * @sig Ord a => a -> a -> a
     * @param {*} a
     * @param {*} b
     * @return {*}
     * @see R.maxBy, R.min
     * @example
     *
     *      R.max(789, 123); //=> 789
     *      R.max('a', 'b'); //=> 'b'
     */
    var max = _curry2(function max(a, b) {
        return b > a ? b : a;
    });

    /**
     * Takes a function and two values, and returns whichever value produces
     * the larger result when passed to the provided function.
     *
     * @func
     * @memberOf R
     * @category Relation
     * @sig Ord b => (a -> b) -> a -> a -> a
     * @param {Function} f
     * @param {*} a
     * @param {*} b
     * @return {*}
     * @see R.max, R.minBy
     * @example
     *
     *      R.maxBy(function(n) { return n * n; }, -3, 2); //=> -3
     */
    var maxBy = _curry3(function maxBy(f, a, b) {
        return f(b) > f(a) ? b : a;
    });

    /**
     * Create a new object with the own properties of `a`
     * merged with the own properties of object `b`.
     *
     * @func
     * @memberOf R
     * @category Object
     * @sig {k: v} -> {k: v} -> {k: v}
     * @param {Object} a
     * @param {Object} b
     * @return {Object}
     * @example
     *
     *      R.merge({ 'name': 'fred', 'age': 10 }, { 'age': 40 });
     *      //=> { 'name': 'fred', 'age': 40 }
     *
     *      var resetToDefault = R.merge(R.__, {x: 0});
     *      resetToDefault({x: 5, y: 2}); //=> {x: 0, y: 2}
     */
    var merge = _curry2(function merge(a, b) {
        var result = {};
        var ks = keys(a);
        var idx = 0;
        while (idx < ks.length) {
            result[ks[idx]] = a[ks[idx]];
            idx += 1;
        }
        ks = keys(b);
        idx = 0;
        while (idx < ks.length) {
            result[ks[idx]] = b[ks[idx]];
            idx += 1;
        }
        return result;
    });

    /**
     * Returns the smaller of its two arguments.
     *
     * @func
     * @memberOf R
     * @category Relation
     * @sig Ord a => a -> a -> a
     * @param {*} a
     * @param {*} b
     * @return {*}
     * @see R.minBy, R.max
     * @example
     *
     *      R.min(789, 123); //=> 123
     *      R.min('a', 'b'); //=> 'a'
     */
    var min = _curry2(function min(a, b) {
        return b < a ? b : a;
    });

    /**
     * Takes a function and two values, and returns whichever value produces
     * the smaller result when passed to the provided function.
     *
     * @func
     * @memberOf R
     * @category Relation
     * @sig Ord b => (a -> b) -> a -> a -> a
     * @param {Function} f
     * @param {*} a
     * @param {*} b
     * @return {*}
     * @see R.min, R.maxBy
     * @example
     *
     *      R.minBy(function(n) { return n * n; }, -3, 2); //=> 2
     */
    var minBy = _curry3(function minBy(f, a, b) {
        return f(b) < f(a) ? b : a;
    });

    /**
     * Divides the second parameter by the first and returns the remainder.
     * Note that this functions preserves the JavaScript-style behavior for
     * modulo. For mathematical modulo see `mathMod`
     *
     * @func
     * @memberOf R
     * @category Math
     * @sig Number -> Number -> Number
     * @param {Number} a The value to the divide.
     * @param {Number} b The pseudo-modulus
     * @return {Number} The result of `b % a`.
     * @see R.mathMod
     * @example
     *
     *      R.modulo(17, 3); //=> 2
     *      // JS behavior:
     *      R.modulo(-17, 3); //=> -2
     *      R.modulo(17, -3); //=> 2
     *
     *      var isOdd = R.modulo(R.__, 2);
     *      isOdd(42); //=> 0
     *      isOdd(21); //=> 1
     */
    var modulo = _curry2(function modulo(a, b) {
        return a % b;
    });

    /**
     * Multiplies two numbers. Equivalent to `a * b` but curried.
     *
     * @func
     * @memberOf R
     * @category Math
     * @sig Number -> Number -> Number
     * @param {Number} a The first value.
     * @param {Number} b The second value.
     * @return {Number} The result of `a * b`.
     * @see R.divide
     * @example
     *
     *      var double = R.multiply(2);
     *      var triple = R.multiply(3);
     *      double(3);       //=>  6
     *      triple(4);       //=> 12
     *      R.multiply(2, 5);  //=> 10
     */
    var multiply = _curry2(function multiply(a, b) {
        return a * b;
    });

    /**
     * Wraps a function of any arity (including nullary) in a function that accepts exactly `n`
     * parameters. Any extraneous parameters will not be passed to the supplied function.
     *
     * @func
     * @memberOf R
     * @category Function
     * @sig Number -> (* -> a) -> (* -> a)
     * @param {Number} n The desired arity of the new function.
     * @param {Function} fn The function to wrap.
     * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of
     *         arity `n`.
     * @example
     *
     *      var takesTwoArgs = function(a, b) {
     *        return [a, b];
     *      };
     *      takesTwoArgs.length; //=> 2
     *      takesTwoArgs(1, 2); //=> [1, 2]
     *
     *      var takesOneArg = R.nAry(1, takesTwoArgs);
     *      takesOneArg.length; //=> 1
     *      // Only `n` arguments are passed to the wrapped function
     *      takesOneArg(1, 2); //=> [1, undefined]
     */
    var nAry = _curry2(function nAry(n, fn) {
        switch (n) {
        case 0:
            return function () {
                return fn.call(this);
            };
        case 1:
            return function (a0) {
                return fn.call(this, a0);
            };
        case 2:
            return function (a0, a1) {
                return fn.call(this, a0, a1);
            };
        case 3:
            return function (a0, a1, a2) {
                return fn.call(this, a0, a1, a2);
            };
        case 4:
            return function (a0, a1, a2, a3) {
                return fn.call(this, a0, a1, a2, a3);
            };
        case 5:
            return function (a0, a1, a2, a3, a4) {
                return fn.call(this, a0, a1, a2, a3, a4);
            };
        case 6:
            return function (a0, a1, a2, a3, a4, a5) {
                return fn.call(this, a0, a1, a2, a3, a4, a5);
            };
        case 7:
            return function (a0, a1, a2, a3, a4, a5, a6) {
                return fn.call(this, a0, a1, a2, a3, a4, a5, a6);
            };
        case 8:
            return function (a0, a1, a2, a3, a4, a5, a6, a7) {
                return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7);
            };
        case 9:
            return function (a0, a1, a2, a3, a4, a5, a6, a7, a8) {
                return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7, a8);
            };
        case 10:
            return function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
                return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
            };
        default:
            throw new Error('First argument to nAry must be a non-negative integer no greater than ten');
        }
    });

    /**
     * Negates its argument.
     *
     * @func
     * @memberOf R
     * @category Math
     * @sig Number -> Number
     * @param {Number} n
     * @return {Number}
     * @example
     *
     *      R.negate(42); //=> -42
     */
    var negate = _curry1(function negate(n) {
        return -n;
    });

    /**
     * A function that returns the `!` of its argument. It will return `true` when
     * passed false-y value, and `false` when passed a truth-y one.
     *
     * @func
     * @memberOf R
     * @category Logic
     * @sig * -> Boolean
     * @param {*} a any value
     * @return {Boolean} the logical inverse of passed argument.
     * @see R.complement
     * @example
     *
     *      R.not(true); //=> false
     *      R.not(false); //=> true
     *      R.not(0); => true
     *      R.not(1); => false
     */
    var not = _curry1(function not(a) {
        return !a;
    });

    /**
     * Returns the nth element of the given list or string.
     * If n is negative the element at index length + n is returned.
     *
     * @func
     * @memberOf R
     * @category List
     * @sig Number -> [a] -> a | Undefined
     * @sig Number -> String -> String
     * @param {Number} offset
     * @param {*} list
     * @return {*}
     * @example
     *
     *      var list = ['foo', 'bar', 'baz', 'quux'];
     *      R.nth(1, list); //=> 'bar'
     *      R.nth(-1, list); //=> 'quux'
     *      R.nth(-99, list); //=> undefined
     *
     *      R.nth('abc', 2); //=> 'c'
     *      R.nth('abc', 3); //=> ''
     */
    var nth = _curry2(function nth(offset, list) {
        var idx = offset < 0 ? list.length + offset : offset;
        return _isString(list) ? list.charAt(idx) : list[idx];
    });

    /**
     * Returns a function which returns its nth argument.
     *
     * @func
     * @memberOf R
     * @category Function
     * @sig Number -> *... -> *
     * @param {Number} n
     * @return {Function}
     * @example
     *
     *      R.nthArg(1)('a', 'b', 'c'); //=> 'b'
     *      R.nthArg(-1)('a', 'b', 'c'); //=> 'c'
     */
    var nthArg = _curry1(function nthArg(n) {
        return function () {
            return nth(n, arguments);
        };
    });

    /**
     * Returns the nth character of the given string.
     *
     * @func
     * @memberOf R
     * @category String
     * @sig Number -> String -> String
     * @param {Number} n
     * @param {String} str
     * @return {String}
     * @deprecated since v0.16.0
     * @example
     *
     *      R.nthChar(2, 'Ramda'); //=> 'm'
     *      R.nthChar(-2, 'Ramda'); //=> 'd'
     */
    var nthChar = _curry2(function nthChar(n, str) {
        return str.charAt(n < 0 ? str.length + n : n);
    });

    /**
     * Returns the character code of the nth character of the given string.
     *
     * @func
     * @memberOf R
     * @category String
     * @sig Number -> String -> Number
     * @param {Number} n
     * @param {String} str
     * @return {Number}
     * @deprecated since v0.16.0
     * @example
     *
     *      R.nthCharCode(2, 'Ramda'); //=> 'm'.charCodeAt(0)
     *      R.nthCharCode(-2, 'Ramda'); //=> 'd'.charCodeAt(0)
     */
    var nthCharCode = _curry2(function nthCharCode(n, str) {
        return str.charCodeAt(n < 0 ? str.length + n : n);
    });

    /**
     * Returns a singleton array containing the value provided.
     *
     * Note this `of` is different from the ES6 `of`; See
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/of
     *
     * @func
     * @memberOf R
     * @category Function
     * @sig a -> [a]
     * @param {*} x any value
     * @return {Array} An array wrapping `x`.
     * @example
     *
     *      R.of(null); //=> [null]
     *      R.of([42]); //=> [[42]]
     */
    var of = _curry1(function of(x) {
        return [x];
    });

    /**
     * Accepts a function `fn` and returns a function that guards invocation of `fn` such that
     * `fn` can only ever be called once, no matter how many times the returned function is
     * invoked.
     *
     * @func
     * @memberOf R
     * @category Function
     * @sig (a... -> b) -> (a... -> b)
     * @param {Function} fn The function to wrap in a call-only-once wrapper.
     * @return {Function} The wrapped function.
     * @example
     *
     *      var addOneOnce = R.once(function(x){ return x + 1; });
     *      addOneOnce(10); //=> 11
     *      addOneOnce(addOneOnce(50)); //=> 11
     */
    var once = _curry1(function once(fn) {
        var called = false, result;
        return function () {
            if (called) {
                return result;
            }
            called = true;
            result = fn.apply(this, arguments);
            return result;
        };
    });

    /**
     * Returns the result of "setting" the portion of the given data structure
     * focused by the given lens to the given value.
     *
     * @func
     * @memberOf R
     * @category Object
     * @typedef Lens s a = Functor f => (a -> f a) -> s -> f s
     * @sig Lens s a -> (a -> a) -> s -> s
     * @param {Lens} lens
     * @param {*} v
     * @param {*} x
     * @return {*}
     * @see R.prop, R.lensIndex, R.lensProp
     * @example
     *
     *      var headLens = R.lensIndex(0);
     *
     *      R.over(headLens, R.toUpper, ['foo', 'bar', 'baz']); //=> ['FOO', 'bar', 'baz']
     */
    var over = function () {
        var Identity = function (x) {
            return {
                value: x,
                map: function (f) {
                    return Identity(f(x));
                }
            };
        };
        return _curry3(function over(lens, f, x) {
            return lens(function (y) {
                return Identity(f(y));
            })(x).value;
        });
    }();

    /**
     * Retrieve the value at a given path.
     *
     * @func
     * @memberOf R
     * @category Object
     * @sig [String] -> {k: v} -> v | Undefined
     * @param {Array} path The path to use.
     * @return {*} The data at `path`.
     * @example
     *
     *      R.path(['a', 'b'], {a: {b: 2}}); //=> 2
     *      R.path(['a', 'b'], {c: {b: 2}}); //=> undefined
     */
    var path = _curry2(function path(paths, obj) {
        if (obj == null) {
            return;
        } else {
            var val = obj;
            for (var idx = 0, len = paths.length; idx < len && val != null; idx += 1) {
                val = val[paths[idx]];
            }
            return val;
        }
    });

    /**
     * Returns a partial copy of an object containing only the keys specified.  If the key does not exist, the
     * property is ignored.
     *
     * @func
     * @memberOf R
     * @category Object
     * @sig [k] -> {k: v} -> {k: v}
     * @param {Array} names an array of String property names to copy onto a new object
     * @param {Object} obj The object to copy from
     * @return {Object} A new object with only properties from `names` on it.
     * @see R.omit
     * @example
     *
     *      R.pick(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, d: 4}
     *      R.pick(['a', 'e', 'f'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1}
     */
    var pick = _curry2(function pick(names, obj) {
        var result = {};
        var idx = 0;
        while (idx < names.length) {
            if (names[idx] in obj) {
                result[names[idx]] = obj[names[idx]];
            }
            idx += 1;
        }
        return result;
    });

    /**
     * Similar to `pick` except that this one includes a `key: undefined` pair for properties that don't exist.
     *
     * @func
     * @memberOf R
     * @category Object
     * @sig [k] -> {k: v} -> {k: v}
     * @param {Array} names an array of String property names to copy onto a new object
     * @param {Object} obj The object to copy from
     * @return {Object} A new object with only properties from `names` on it.
     * @see R.pick
     * @example
     *
     *      R.pickAll(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, d: 4}
     *      R.pickAll(['a', 'e', 'f'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, e: undefined, f: undefined}
     */
    var pickAll = _curry2(function pickAll(names, obj) {
        var result = {};
        var idx = 0;
        var len = names.length;
        while (idx < len) {
            var name = names[idx];
            result[name] = obj[name];
            idx += 1;
        }
        return result;
    });

    /**
     * Returns a partial copy of an object containing only the keys that
     * satisfy the supplied predicate.
     *
     * @func
     * @memberOf R
     * @category Object
     * @sig (v, k -> Boolean) -> {k: v} -> {k: v}
     * @param {Function} pred A predicate to determine whether or not a key
     *        should be included on the output object.
     * @param {Object} obj The object to copy from
     * @return {Object} A new object with only properties that satisfy `pred`
     *         on it.
     * @see R.pick
     * @example
     *
     *      var isUpperCase = function(val, key) { return key.toUpperCase() === key; }
     *      R.pickBy(isUpperCase, {a: 1, b: 2, A: 3, B: 4}); //=> {A: 3, B: 4}
     */
    var pickBy = _curry2(function pickBy(test, obj) {
        var result = {};
        for (var prop in obj) {
            if (test(obj[prop], prop, obj)) {
                result[prop] = obj[prop];
            }
        }
        return result;
    });

    /**
     * Returns a new list with the given element at the front, followed by the contents of the
     * list.
     *
     * @func
     * @memberOf R
     * @category List
     * @sig a -> [a] -> [a]
     * @param {*} el The item to add to the head of the output list.
     * @param {Array} list The array to add to the tail of the output list.
     * @return {Array} A new array.
     * @see R.append
     * @example
     *
     *      R.prepend('fee', ['fi', 'fo', 'fum']); //=> ['fee', 'fi', 'fo', 'fum']
     */
    var prepend = _curry2(function prepend(el, list) {
        return _concat([el], list);
    });

    /**
     * Returns a function that when supplied an object returns the indicated property of that object, if it exists.
     *
     * @func
     * @memberOf R
     * @category Object
     * @sig s -> {s: a} -> a | Undefined
     * @param {String} p The property name
     * @param {Object} obj The object to query
     * @return {*} The value at `obj.p`.
     * @example
     *
     *      R.prop('x', {x: 100}); //=> 100
     *      R.prop('x', {}); //=> undefined
     */
    var prop = _curry2(function prop(p, obj) {
        return obj[p];
    });

    /**
     * If the given, non-null object has an own property with the specified name,
     * returns the value of that property.
     * Otherwise returns the provided default value.
     *
     * @func
     * @memberOf R
     * @category Object
     * @sig a -> String -> Object -> a
     * @param {*} val The default value.
     * @param {String} p The name of the property to return.
     * @param {Object} obj The object to query.
     * @return {*} The value of given property of the supplied object or the default value.
     * @example
     *
     *      var alice = {
     *        name: 'ALICE',
     *        age: 101
     *      };
     *      var favorite = R.prop('favoriteLibrary');
     *      var favoriteWithDefault = R.propOr('Ramda', 'favoriteLibrary');
     *
     *      favorite(alice);  //=> undefined
     *      favoriteWithDefault(alice);  //=> 'Ramda'
     */
    var propOr = _curry3(function propOr(val, p, obj) {
        return obj != null && _has(p, obj) ? obj[p] : val;
    });

    /**
     * Returns `true` if the specified object property satisfies the given
     * predicate; `false` otherwise.
     *
     * @func
     * @memberOf R
     * @category Logic
     * @sig (a -> Boolean) -> String -> {String: a} -> Boolean
     * @param {Function} pred
     * @param {String} name
     * @param {*} obj
     * @return {Boolean}
     * @see R.propEq
     * @see R.propIs
     * @example
     *
     *      R.propSatisfies(x => x > 0, 'x', {x: 1, y: 2}); //=> true
     */
    var propSatisfies = _curry3(function propSatisfies(pred, name, obj) {
        return pred(obj[name]);
    });

    /**
     * Acts as multiple `prop`: array of keys in, array of values out. Preserves order.
     *
     * @func
     * @memberOf R
     * @category Object
     * @sig [k] -> {k: v} -> [v]
     * @param {Array} ps The property names to fetch
     * @param {Object} obj The object to query
     * @return {Array} The corresponding values or partially applied function.
     * @example
     *
     *      R.props(['x', 'y'], {x: 1, y: 2}); //=> [1, 2]
     *      R.props(['c', 'a', 'b'], {b: 2, a: 1}); //=> [undefined, 1, 2]
     *
     *      var fullName = R.compose(R.join(' '), R.props(['first', 'last']));
     *      fullName({last: 'Bullet-Tooth', age: 33, first: 'Tony'}); //=> 'Tony Bullet-Tooth'
     */
    var props = _curry2(function props(ps, obj) {
        var len = ps.length;
        var out = [];
        var idx = 0;
        while (idx < len) {
            out[idx] = obj[ps[idx]];
            idx += 1;
        }
        return out;
    });

    /**
     * Returns a list of numbers from `from` (inclusive) to `to`
     * (exclusive).
     *
     * @func
     * @memberOf R
     * @category List
     * @sig Number -> Number -> [Number]
     * @param {Number} from The first number in the list.
     * @param {Number} to One more than the last number in the list.
     * @return {Array} The list of numbers in tthe set `[a, b)`.
     * @example
     *
     *      R.range(1, 5);    //=> [1, 2, 3, 4]
     *      R.range(50, 53);  //=> [50, 51, 52]
     */
    var range = _curry2(function range(from, to) {
        if (!(_isNumber(from) && _isNumber(to))) {
            throw new TypeError('Both arguments to range must be numbers');
        }
        var result = [];
        var n = from;
        while (n < to) {
            result.push(n);
            n += 1;
        }
        return result;
    });

    /**
     * Returns a single item by iterating through the list, successively calling the iterator
     * function and passing it an accumulator value and the current value from the array, and
     * then passing the result to the next call.
     *
     * Similar to `reduce`, except moves through the input list from the right to the left.
     *
     * The iterator function receives two values: *(acc, value)*
     *
     * Note: `R.reduceRight` does not skip deleted or unassigned indices (sparse arrays), unlike
     * the native `Array.prototype.reduce` method. For more details on this behavior, see:
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight#Description
     *
     * @func
     * @memberOf R
     * @category List
     * @sig (a,b -> a) -> a -> [b] -> a
     * @param {Function} fn The iterator function. Receives two values, the accumulator and the
     *        current element from the array.
     * @param {*} acc The accumulator value.
     * @param {Array} list The list to iterate over.
     * @return {*} The final, accumulated value.
     * @example
     *
     *      var pairs = [ ['a', 1], ['b', 2], ['c', 3] ];
     *      var flattenPairs = function(acc, pair) {
     *        return acc.concat(pair);
     *      };
     *
     *      R.reduceRight(flattenPairs, [], pairs); //=> [ 'c', 3, 'b', 2, 'a', 1 ]
     */
    var reduceRight = _curry3(function reduceRight(fn, acc, list) {
        var idx = list.length - 1;
        while (idx >= 0) {
            acc = fn(acc, list[idx]);
            idx -= 1;
        }
        return acc;
    });

    /**
     * Returns a value wrapped to indicate that it is the final value of the
     * reduce and transduce functions.  The returned value
     * should be considered a black box: the internal structure is not
     * guaranteed to be stable.
     *
     * Note: this optimization is unavailable to functions not explicitly listed
     * above.  For instance, it is not currently supported by reduceIndexed,
     * reduceRight, or reduceRightIndexed.
     *
     * @func
     * @memberOf R
     * @category List
     * @see R.reduce, R.transduce
     * @sig a -> *
     * @param {*} x The final value of the reduce.
     * @return {*} The wrapped value.
     * @example
     *
     *      R.reduce(
     *        R.pipe(R.add, R.ifElse(R.lte(10), R.reduced, R.identity)),
     *        0,
     *        [1, 2, 3, 4, 5]) // 10
     */
    var reduced = _curry1(_reduced);

    /**
     * Removes the sub-list of `list` starting at index `start` and containing
     * `count` elements.  _Note that this is not destructive_: it returns a
     * copy of the list with the changes.
     * <small>No lists have been harmed in the application of this function.</small>
     *
     * @func
     * @memberOf R
     * @category List
     * @sig Number -> Number -> [a] -> [a]
     * @param {Number} start The position to start removing elements
     * @param {Number} count The number of elements to remove
     * @param {Array} list The list to remove from
     * @return {Array} A new Array with `count` elements from `start` removed.
     * @example
     *
     *      R.remove(2, 3, [1,2,3,4,5,6,7,8]); //=> [1,2,6,7,8]
     */
    var remove = _curry3(function remove(start, count, list) {
        return _concat(_slice(list, 0, Math.min(start, list.length)), _slice(list, Math.min(list.length, start + count)));
    });

    /**
     * Replace a substring or regex match in a string with a replacement.
     *
     * @func
     * @memberOf R
     * @category String
     * @sig RegExp|String -> String -> String -> String
     * @param {RegExp|String} pattern A regular expression or a substring to match.
     * @param {String} replacement The string to replace the matches with.
     * @param {String} str The String to do the search and replacement in.
     * @return {String} The result.
     * @example
     *
     *      R.replace('foo', 'bar', 'foo foo foo'); //=> 'bar foo foo'
     *      R.replace(/foo/, 'bar', 'foo foo foo'); //=> 'bar foo foo'
     *
     *      // Use the "g" (global) flag to replace all occurrences:
     *      R.replace(/foo/g, 'bar', 'foo foo foo'); //=> 'bar bar bar'
     */
    var replace = _curry3(function replace(regex, replacement, str) {
        return str.replace(regex, replacement);
    });

    /**
     * Returns a new list with the same elements as the original list, just
     * in the reverse order.
     *
     * @func
     * @memberOf R
     * @category List
     * @sig [a] -> [a]
     * @param {Array} list The list to reverse.
     * @return {Array} A copy of the list in reverse order.
     * @example
     *
     *      R.reverse([1, 2, 3]);  //=> [3, 2, 1]
     *      R.reverse([1, 2]);     //=> [2, 1]
     *      R.reverse([1]);        //=> [1]
     *      R.reverse([]);         //=> []
     */
    var reverse = _curry1(function reverse(list) {
        return _slice(list).reverse();
    });

    /**
     * Scan is similar to reduce, but returns a list of successively reduced values from the left
     *
     * @func
     * @memberOf R
     * @category List
     * @sig (a,b -> a) -> a -> [b] -> [a]
     * @param {Function} fn The iterator function. Receives two values, the accumulator and the
     *        current element from the array
     * @param {*} acc The accumulator value.
     * @param {Array} list The list to iterate over.
     * @return {Array} A list of all intermediately reduced values.
     * @example
     *
     *      var numbers = [1, 2, 3, 4];
     *      var factorials = R.scan(R.multiply, 1, numbers); //=> [1, 1, 2, 6, 24]
     */
    var scan = _curry3(function scan(fn, acc, list) {
        var idx = 0, len = list.length, result = [acc];
        while (idx < len) {
            acc = fn(acc, list[idx]);
            result[idx + 1] = acc;
            idx += 1;
        }
        return result;
    });

    /**
     * Returns the result of "setting" the portion of the given data structure
     * focused by the given lens to the given value.
     *
     * @func
     * @memberOf R
     * @category Object
     * @typedef Lens s a = Functor f => (a -> f a) -> s -> f s
     * @sig Lens s a -> a -> s -> s
     * @param {Lens} lens
     * @param {*} v
     * @param {*} x
     * @return {*}
     * @see R.prop, R.lensIndex, R.lensProp
     * @example
     *
     *      var xLens = R.lensProp('x');
     *
     *      R.set(xLens, 4, {x: 1, y: 2});  //=> {x: 4, y: 2}
     *      R.set(xLens, 8, {x: 1, y: 2});  //=> {x: 8, y: 2}
     */
    var set = _curry3(function set(lens, v, x) {
        return over(lens, always(v), x);
    });

    /**
     * Returns a copy of the list, sorted according to the comparator function, which should accept two values at a
     * time and return a negative number if the first value is smaller, a positive number if it's larger, and zero
     * if they are equal.  Please note that this is a **copy** of the list.  It does not modify the original.
     *
     * @func
     * @memberOf R
     * @category List
     * @sig (a,a -> Number) -> [a] -> [a]
     * @param {Function} comparator A sorting function :: a -> b -> Int
     * @param {Array} list The list to sort
     * @return {Array} a new array with its elements sorted by the comparator function.
     * @example
     *
     *      var diff = function(a, b) { return a - b; };
     *      R.sort(diff, [4,2,7,5]); //=> [2, 4, 5, 7]
     */
    var sort = _curry2(function sort(comparator, list) {
        return _slice(list).sort(comparator);
    });

    /**
     * Sorts the list according to the supplied function.
     *
     * @func
     * @memberOf R
     * @category Relation
     * @sig Ord b => (a -> b) -> [a] -> [a]
     * @param {Function} fn
     * @param {Array} list The list to sort.
     * @return {Array} A new list sorted by the keys generated by `fn`.
     * @example
     *
     *      var sortByFirstItem = R.sortBy(prop(0));
     *      var sortByNameCaseInsensitive = R.sortBy(R.compose(R.toLower, R.prop('name')));
     *      var pairs = [[-1, 1], [-2, 2], [-3, 3]];
     *      sortByFirstItem(pairs); //=> [[-3, 3], [-2, 2], [-1, 1]]
     *      var alice = {
     *        name: 'ALICE',
     *        age: 101
     *      };
     *      var bob = {
     *        name: 'Bob',
     *        age: -10
     *      };
     *      var clara = {
     *        name: 'clara',
     *        age: 314.159
     *      };
     *      var people = [clara, bob, alice];
     *      sortByNameCaseInsensitive(people); //=> [alice, bob, clara]
     */
    var sortBy = _curry2(function sortBy(fn, list) {
        return _slice(list).sort(function (a, b) {
            var aa = fn(a);
            var bb = fn(b);
            return aa < bb ? -1 : aa > bb ? 1 : 0;
        });
    });

    /**
     * Subtracts two numbers. Equivalent to `a - b` but curried.
     *
     * @func
     * @memberOf R
     * @category Math
     * @sig Number -> Number -> Number
     * @param {Number} a The first value.
     * @param {Number} b The second value.
     * @return {Number} The result of `a - b`.
     * @see R.add
     * @example
     *
     *      R.subtract(10, 8); //=> 2
     *
     *      var minus5 = R.subtract(R.__, 5);
     *      minus5(17); //=> 12
     *
     *      var complementaryAngle = R.subtract(90);
     *      complementaryAngle(30); //=> 60
     *      complementaryAngle(72); //=> 18
     */
    var subtract = _curry2(function subtract(a, b) {
        return a - b;
    });

    /**
     * Returns a new list containing the last `n` elements of a given list, passing each value
     * to the supplied predicate function, and terminating when the predicate function returns
     * `false`. Excludes the element that caused the predicate function to fail. The predicate
     * function is passed one argument: *(value)*.
     *
     * @func
     * @memberOf R
     * @category List
     * @sig (a -> Boolean) -> [a] -> [a]
     * @param {Function} fn The function called per iteration.
     * @param {Array} list The collection to iterate over.
     * @return {Array} A new array.
     * @see R.dropLastWhile
     * @example
     *
     *      var isNotOne = function(x) {
     *        return !(x === 1);
     *      };
     *
     *      R.takeLastWhile(isNotOne, [1, 2, 3, 4]); //=> [2, 3, 4]
     */
    var takeLastWhile = _curry2(function takeLastWhile(fn, list) {
        var idx = list.length - 1;
        while (idx >= 0 && fn(list[idx])) {
            idx -= 1;
        }
        return _slice(list, idx + 1, Infinity);
    });

    /**
     * Runs the given function with the supplied object, then returns the object.
     *
     * @func
     * @memberOf R
     * @category Function
     * @sig (a -> *) -> a -> a
     * @param {Function} fn The function to call with `x`. The return value of `fn` will be thrown away.
     * @param {*} x
     * @return {*} `x`.
     * @example
     *
     *      var sayX = function(x) { console.log('x is ' + x); };
     *      R.tap(sayX, 100); //=> 100
     *      //-> 'x is 100'
     */
    var tap = _curry2(function tap(fn, x) {
        fn(x);
        return x;
    });

    /**
     * Determines whether a given string matches a given regular expression.
     *
     * @func
     * @memberOf R
     * @see R.match
     * @category String
     * @sig RegExp -> String -> Boolean
     * @param {RegExp} pattern
     * @param {String} str
     * @return {Boolean}
     * @example
     *
     *      R.test(/^x/, 'xyz'); //=> true
     *      R.test(/^y/, 'xyz'); //=> false
     */
    var test = _curry2(function test(pattern, str) {
        return _cloneRegExp(pattern).test(str);
    });

    /**
     * Calls an input function `n` times, returning an array containing the results of those
     * function calls.
     *
     * `fn` is passed one argument: The current value of `n`, which begins at `0` and is
     * gradually incremented to `n - 1`.
     *
     * @func
     * @memberOf R
     * @category List
     * @sig (i -> a) -> i -> [a]
     * @param {Function} fn The function to invoke. Passed one argument, the current value of `n`.
     * @param {Number} n A value between `0` and `n - 1`. Increments after each function call.
     * @return {Array} An array containing the return values of all calls to `fn`.
     * @example
     *
     *      R.times(R.identity, 5); //=> [0, 1, 2, 3, 4]
     */
    var times = _curry2(function times(fn, n) {
        var len = Number(n);
        var list = new Array(len);
        var idx = 0;
        while (idx < len) {
            list[idx] = fn(idx);
            idx += 1;
        }
        return list;
    });

    /**
     * Converts an object into an array of key, value arrays.
     * Only the object's own properties are used.
     * Note that the order of the output array is not guaranteed to be
     * consistent across different JS platforms.
     *
     * @func
     * @memberOf R
     * @category Object
     * @sig {String: *} -> [[String,*]]
     * @param {Object} obj The object to extract from
     * @return {Array} An array of key, value arrays from the object's own properties.
     * @see R.fromPairs
     * @example
     *
     *      R.toPairs({a: 1, b: 2, c: 3}); //=> [['a', 1], ['b', 2], ['c', 3]]
     */
    var toPairs = _curry1(function toPairs(obj) {
        var pairs = [];
        for (var prop in obj) {
            if (_has(prop, obj)) {
                pairs[pairs.length] = [
                    prop,
                    obj[prop]
                ];
            }
        }
        return pairs;
    });

    /**
     * Converts an object into an array of key, value arrays.
     * The object's own properties and prototype properties are used.
     * Note that the order of the output array is not guaranteed to be
     * consistent across different JS platforms.
     *
     * @func
     * @memberOf R
     * @category Object
     * @sig {String: *} -> [[String,*]]
     * @param {Object} obj The object to extract from
     * @return {Array} An array of key, value arrays from the object's own
     *         and prototype properties.
     * @example
     *
     *      var F = function() { this.x = 'X'; };
     *      F.prototype.y = 'Y';
     *      var f = new F();
     *      R.toPairsIn(f); //=> [['x','X'], ['y','Y']]
     */
    var toPairsIn = _curry1(function toPairsIn(obj) {
        var pairs = [];
        for (var prop in obj) {
            pairs[pairs.length] = [
                prop,
                obj[prop]
            ];
        }
        return pairs;
    });

    /**
     * Removes (strips) whitespace from both ends of the string.
     *
     * @func
     * @memberOf R
     * @category String
     * @sig String -> String
     * @param {String} str The string to trim.
     * @return {String} Trimmed version of `str`.
     * @example
     *
     *      R.trim('   xyz  '); //=> 'xyz'
     *      R.map(R.trim, R.split(',', 'x, y, z')); //=> ['x', 'y', 'z']
     */
    var trim = function () {
        var ws = '\t\n\x0B\f\r \xA0\u1680\u180E\u2000\u2001\u2002\u2003' + '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028' + '\u2029\uFEFF';
        var zeroWidth = '\u200B';
        var hasProtoTrim = typeof String.prototype.trim === 'function';
        if (!hasProtoTrim || (ws.trim() || !zeroWidth.trim())) {
            return _curry1(function trim(str) {
                var beginRx = new RegExp('^[' + ws + '][' + ws + ']*');
                var endRx = new RegExp('[' + ws + '][' + ws + ']*$');
                return str.replace(beginRx, '').replace(endRx, '');
            });
        } else {
            return _curry1(function trim(str) {
                return str.trim();
            });
        }
    }();

    /**
     * Gives a single-word string description of the (native) type of a value, returning such
     * answers as 'Object', 'Number', 'Array', or 'Null'.  Does not attempt to distinguish user
     * Object types any further, reporting them all as 'Object'.
     *
     * @func
     * @memberOf R
     * @category Type
     * @sig (* -> {*}) -> String
     * @param {*} val The value to test
     * @return {String}
     * @example
     *
     *      R.type({}); //=> "Object"
     *      R.type(1); //=> "Number"
     *      R.type(false); //=> "Boolean"
     *      R.type('s'); //=> "String"
     *      R.type(null); //=> "Null"
     *      R.type([]); //=> "Array"
     *      R.type(/[A-z]/); //=> "RegExp"
     */
    var type = _curry1(function type(val) {
        return val === null ? 'Null' : val === undefined ? 'Undefined' : Object.prototype.toString.call(val).slice(8, -1);
    });

    /**
     * Takes a function `fn`, which takes a single array argument, and returns
     * a function which:
     *
     *   - takes any number of positional arguments;
     *   - passes these arguments to `fn` as an array; and
     *   - returns the result.
     *
     * In other words, R.unapply derives a variadic function from a function
     * which takes an array. R.unapply is the inverse of R.apply.
     *
     * @func
     * @memberOf R
     * @category Function
     * @sig ([*...] -> a) -> (*... -> a)
     * @param {Function} fn
     * @return {Function}
     * @see R.apply
     * @example
     *
     *      R.unapply(JSON.stringify)(1, 2, 3); //=> '[1,2,3]'
     */
    var unapply = _curry1(function unapply(fn) {
        return function () {
            return fn(_slice(arguments));
        };
    });

    /**
     * Wraps a function of any arity (including nullary) in a function that accepts exactly 1
     * parameter. Any extraneous parameters will not be passed to the supplied function.
     *
     * @func
     * @memberOf R
     * @category Function
     * @sig (* -> b) -> (a -> b)
     * @param {Function} fn The function to wrap.
     * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of
     *         arity 1.
     * @example
     *
     *      var takesTwoArgs = function(a, b) {
     *        return [a, b];
     *      };
     *      takesTwoArgs.length; //=> 2
     *      takesTwoArgs(1, 2); //=> [1, 2]
     *
     *      var takesOneArg = R.unary(takesTwoArgs);
     *      takesOneArg.length; //=> 1
     *      // Only 1 argument is passed to the wrapped function
     *      takesOneArg(1, 2); //=> [1, undefined]
     */
    var unary = _curry1(function unary(fn) {
        return nAry(1, fn);
    });

    /**
     * Returns a function of arity `n` from a (manually) curried function.
     *
     * @func
     * @memberOf R
     * @category Function
     * @sig Number -> (a -> b) -> (a -> c)
     * @param {Number} length The arity for the returned function.
     * @param {Function} fn The function to uncurry.
     * @return {Function} A new function.
     * @see R.curry
     * @example
     *
     *      var addFour = function(a) {
     *        return function(b) {
     *          return function(c) {
     *            return function(d) {
     *              return a + b + c + d;
     *            };
     *          };
     *        };
     *      };
     *
     *      var uncurriedAddFour = R.uncurryN(4, addFour);
     *      curriedAddFour(1, 2, 3, 4); //=> 10
     */
    var uncurryN = _curry2(function uncurryN(depth, fn) {
        return curryN(depth, function () {
            var currentDepth = 1;
            var value = fn;
            var idx = 0;
            var endIdx;
            while (currentDepth <= depth && typeof value === 'function') {
                endIdx = currentDepth === depth ? arguments.length : idx + value.length;
                value = value.apply(this, _slice(arguments, idx, endIdx));
                currentDepth += 1;
                idx = endIdx;
            }
            return value;
        });
    });

    /**
     * Builds a list from a seed value. Accepts an iterator function, which returns either false
     * to stop iteration or an array of length 2 containing the value to add to the resulting
     * list and the seed to be used in the next call to the iterator function.
     *
     * The iterator function receives one argument: *(seed)*.
     *
     * @func
     * @memberOf R
     * @category List
     * @sig (a -> [b]) -> * -> [b]
     * @param {Function} fn The iterator function. receives one argument, `seed`, and returns
     *        either false to quit iteration or an array of length two to proceed. The element
     *        at index 0 of this array will be added to the resulting array, and the element
     *        at index 1 will be passed to the next call to `fn`.
     * @param {*} seed The seed value.
     * @return {Array} The final list.
     * @example
     *
     *      var f = function(n) { return n > 50 ? false : [-n, n + 10] };
     *      R.unfold(f, 10); //=> [-10, -20, -30, -40, -50]
     */
    var unfold = _curry2(function unfold(fn, seed) {
        var pair = fn(seed);
        var result = [];
        while (pair && pair.length) {
            result[result.length] = pair[0];
            pair = fn(pair[1]);
        }
        return result;
    });

    /**
     * Returns a new list containing only one copy of each element in the original list, based
     * upon the value returned by applying the supplied predicate to two list elements. Prefers
     * the first item if two items compare equal based on the predicate.
     *
     * @func
     * @memberOf R
     * @category List
     * @sig (a, a -> Boolean) -> [a] -> [a]
     * @param {Function} pred A predicate used to test whether two items are equal.
     * @param {Array} list The array to consider.
     * @return {Array} The list of unique items.
     * @example
     *
     *      var strEq = function(a, b) { return String(a) === String(b); };
     *      R.uniqWith(strEq)([1, '1', 2, 1]); //=> [1, 2]
     *      R.uniqWith(strEq)([{}, {}]);       //=> [{}]
     *      R.uniqWith(strEq)([1, '1', 1]);    //=> [1]
     *      R.uniqWith(strEq)(['1', 1, 1]);    //=> ['1']
     */
    var uniqWith = _curry2(function uniqWith(pred, list) {
        var idx = 0, len = list.length;
        var result = [], item;
        while (idx < len) {
            item = list[idx];
            if (!_containsWith(pred, item, result)) {
                result[result.length] = item;
            }
            idx += 1;
        }
        return result;
    });

    /**
     * Returns a new copy of the array with the element at the
     * provided index replaced with the given value.
     * @see R.adjust
     *
     * @func
     * @memberOf R
     * @category List
     * @sig Number -> a -> [a] -> [a]
     * @param {Number} idx The index to update.
     * @param {*} x The value to exist at the given index of the returned array.
     * @param {Array|Arguments} list The source array-like object to be updated.
     * @return {Array} A copy of `list` with the value at index `idx` replaced with `x`.
     * @example
     *
     *      R.update(1, 11, [0, 1, 2]);     //=> [0, 11, 2]
     *      R.update(1)(11)([0, 1, 2]);     //=> [0, 11, 2]
     */
    var update = _curry3(function update(idx, x, list) {
        return adjust(always(x), idx, list);
    });

    /**
     * Returns a list of all the enumerable own properties of the supplied object.
     * Note that the order of the output array is not guaranteed across
     * different JS platforms.
     *
     * @func
     * @memberOf R
     * @category Object
     * @sig {k: v} -> [v]
     * @param {Object} obj The object to extract values from
     * @return {Array} An array of the values of the object's own properties.
     * @example
     *
     *      R.values({a: 1, b: 2, c: 3}); //=> [1, 2, 3]
     */
    var values = _curry1(function values(obj) {
        var props = keys(obj);
        var len = props.length;
        var vals = [];
        var idx = 0;
        while (idx < len) {
            vals[idx] = obj[props[idx]];
            idx += 1;
        }
        return vals;
    });

    /**
     * Returns a list of all the properties, including prototype properties,
     * of the supplied object.
     * Note that the order of the output array is not guaranteed to be
     * consistent across different JS platforms.
     *
     * @func
     * @memberOf R
     * @category Object
     * @sig {k: v} -> [v]
     * @param {Object} obj The object to extract values from
     * @return {Array} An array of the values of the object's own and prototype properties.
     * @example
     *
     *      var F = function() { this.x = 'X'; };
     *      F.prototype.y = 'Y';
     *      var f = new F();
     *      R.valuesIn(f); //=> ['X', 'Y']
     */
    var valuesIn = _curry1(function valuesIn(obj) {
        var prop, vs = [];
        for (prop in obj) {
            vs[vs.length] = obj[prop];
        }
        return vs;
    });

    /**
     * Returns a "view" of the given data structure, determined by the given lens.
     * The lens's focus determines which portion of the data structure is visible.
     *
     * @func
     * @memberOf R
     * @category Object
     * @typedef Lens s a = Functor f => (a -> f a) -> s -> f s
     * @sig Lens s a -> s -> a
     * @param {Lens} lens
     * @param {*} x
     * @return {*}
     * @see R.prop, R.lensIndex, R.lensProp
     * @example
     *
     *      var xLens = R.lensProp('x');
     *
     *      R.view(xLens, {x: 1, y: 2});  //=> 1
     *      R.view(xLens, {x: 4, y: 2});  //=> 4
     */
    var view = function () {
        var Const = function (x) {
            return {
                value: x,
                map: function () {
                    return this;
                }
            };
        };
        return _curry2(function view(lens, x) {
            return lens(Const)(x).value;
        });
    }();

    /**
     * Takes a spec object and a test object; returns true if the test satisfies
     * the spec. Each of the spec's own properties must be a predicate function.
     * Each predicate is applied to the value of the corresponding property of
     * the test object. `where` returns true if all the predicates return true,
     * false otherwise.
     *
     * `where` is well suited to declaratively expressing constraints for other
     * functions such as `filter` and `find`.
     *
     * @func
     * @memberOf R
     * @category Object
     * @sig {String: (* -> Boolean)} -> {String: *} -> Boolean
     * @param {Object} spec
     * @param {Object} testObj
     * @return {Boolean}
     * @example
     *
     *      // pred :: Object -> Boolean
     *      var pred = R.where({
     *        a: R.equals('foo'),
     *        b: R.complement(R.equals('bar')),
     *        x: R.gt(_, 10),
     *        y: R.lt(_, 20)
     *      });
     *
     *      pred({a: 'foo', b: 'xxx', x: 11, y: 19}); //=> true
     *      pred({a: 'xxx', b: 'xxx', x: 11, y: 19}); //=> false
     *      pred({a: 'foo', b: 'bar', x: 11, y: 19}); //=> false
     *      pred({a: 'foo', b: 'xxx', x: 10, y: 19}); //=> false
     *      pred({a: 'foo', b: 'xxx', x: 11, y: 20}); //=> false
     */
    var where = _curry2(function where(spec, testObj) {
        for (var prop in spec) {
            if (_has(prop, spec) && !spec[prop](testObj[prop])) {
                return false;
            }
        }
        return true;
    });

    /**
     * Wrap a function inside another to allow you to make adjustments to the parameters, or do
     * other processing either before the internal function is called or with its results.
     *
     * @func
     * @memberOf R
     * @category Function
     * @sig (a... -> b) -> ((a... -> b) -> a... -> c) -> (a... -> c)
     * @param {Function} fn The function to wrap.
     * @param {Function} wrapper The wrapper function.
     * @return {Function} The wrapped function.
     * @example
     *
     *      var greet = function(name) {return 'Hello ' + name;};
     *
     *      var shoutedGreet = R.wrap(greet, function(gr, name) {
     *        return gr(name).toUpperCase();
     *      });
     *      shoutedGreet("Kathy"); //=> "HELLO KATHY"
     *
     *      var shortenedGreet = R.wrap(greet, function(gr, name) {
     *        return gr(name.substring(0, 3));
     *      });
     *      shortenedGreet("Robert"); //=> "Hello Rob"
     */
    var wrap = _curry2(function wrap(fn, wrapper) {
        return curryN(fn.length, function () {
            return wrapper.apply(this, _concat([fn], arguments));
        });
    });

    /**
     * Creates a new list out of the two supplied by creating each possible
     * pair from the lists.
     *
     * @func
     * @memberOf R
     * @category List
     * @sig [a] -> [b] -> [[a,b]]
     * @param {Array} as The first list.
     * @param {Array} bs The second list.
     * @return {Array} The list made by combining each possible pair from
     *         `as` and `bs` into pairs (`[a, b]`).
     * @example
     *
     *      R.xprod([1, 2], ['a', 'b']); //=> [[1, 'a'], [1, 'b'], [2, 'a'], [2, 'b']]
     */
    // = xprodWith(prepend); (takes about 3 times as long...)
    var xprod = _curry2(function xprod(a, b) {
        // = xprodWith(prepend); (takes about 3 times as long...)
        var idx = 0;
        var ilen = a.length;
        var j;
        var jlen = b.length;
        var result = [];
        while (idx < ilen) {
            j = 0;
            while (j < jlen) {
                result[result.length] = [
                    a[idx],
                    b[j]
                ];
                j += 1;
            }
            idx += 1;
        }
        return result;
    });

    /**
     * Creates a new list out of the two supplied by pairing up
     * equally-positioned items from both lists.  The returned list is
     * truncated to the length of the shorter of the two input lists.
     * Note: `zip` is equivalent to `zipWith(function(a, b) { return [a, b] })`.
     *
     * @func
     * @memberOf R
     * @category List
     * @sig [a] -> [b] -> [[a,b]]
     * @param {Array} list1 The first array to consider.
     * @param {Array} list2 The second array to consider.
     * @return {Array} The list made by pairing up same-indexed elements of `list1` and `list2`.
     * @example
     *
     *      R.zip([1, 2, 3], ['a', 'b', 'c']); //=> [[1, 'a'], [2, 'b'], [3, 'c']]
     */
    var zip = _curry2(function zip(a, b) {
        var rv = [];
        var idx = 0;
        var len = Math.min(a.length, b.length);
        while (idx < len) {
            rv[idx] = [
                a[idx],
                b[idx]
            ];
            idx += 1;
        }
        return rv;
    });

    /**
     * Creates a new object out of a list of keys and a list of values.
     *
     * @func
     * @memberOf R
     * @category List
     * @sig [String] -> [*] -> {String: *}
     * @param {Array} keys The array that will be properties on the output object.
     * @param {Array} values The list of values on the output object.
     * @return {Object} The object made by pairing up same-indexed elements of `keys` and `values`.
     * @example
     *
     *      R.zipObj(['a', 'b', 'c'], [1, 2, 3]); //=> {a: 1, b: 2, c: 3}
     */
    var zipObj = _curry2(function zipObj(keys, values) {
        var idx = 0, len = keys.length, out = {};
        while (idx < len) {
            out[keys[idx]] = values[idx];
            idx += 1;
        }
        return out;
    });

    /**
     * Creates a new list out of the two supplied by applying the function to
     * each equally-positioned pair in the lists. The returned list is
     * truncated to the length of the shorter of the two input lists.
     *
     * @function
     * @memberOf R
     * @category List
     * @sig (a,b -> c) -> [a] -> [b] -> [c]
     * @param {Function} fn The function used to combine the two elements into one value.
     * @param {Array} list1 The first array to consider.
     * @param {Array} list2 The second array to consider.
     * @return {Array} The list made by combining same-indexed elements of `list1` and `list2`
     *         using `fn`.
     * @example
     *
     *      var f = function(x, y) {
     *        // ...
     *      };
     *      R.zipWith(f, [1, 2, 3], ['a', 'b', 'c']);
     *      //=> [f(1, 'a'), f(2, 'b'), f(3, 'c')]
     */
    var zipWith = _curry3(function zipWith(fn, a, b) {
        var rv = [], idx = 0, len = Math.min(a.length, b.length);
        while (idx < len) {
            rv[idx] = fn(a[idx], b[idx]);
            idx += 1;
        }
        return rv;
    });

    /**
     * A function that always returns `false`. Any passed in parameters are ignored.
     *
     * @func
     * @memberOf R
     * @category Function
     * @sig * -> false
     * @return {Boolean} false
     * @see R.always, R.T
     * @example
     *
     *      R.F(); //=> false
     */
    var F = always(false);

    /**
     * A function that always returns `true`. Any passed in parameters are ignored.
     *
     * @func
     * @memberOf R
     * @category Function
     * @sig * -> true
     * @return {Boolean} `true`.
     * @see R.always, R.F
     * @example
     *
     *      R.T(); //=> true
     */
    var T = always(true);

    /**
     * Similar to hasMethod, this checks whether a function has a [methodname]
     * function. If it isn't an array it will execute that function otherwise it will
     * default to the ramda implementation.
     *
     * @private
     * @param {Function} fn ramda implemtation
     * @param {String} methodname property to check for a custom implementation
     * @return {Object} Whatever the return value of the method is.
     */
    var _checkForMethod = function _checkForMethod(methodname, fn) {
        return function () {
            var length = arguments.length;
            if (length === 0) {
                return fn();
            }
            var obj = arguments[length - 1];
            return _isArray(obj) || typeof obj[methodname] !== 'function' ? fn.apply(this, arguments) : obj[methodname].apply(obj, _slice(arguments, 0, length - 1));
        };
    };

    /**
     * Copies an object.
     *
     * @private
     * @param {*} value The value to be copied
     * @param {Array} refFrom Array containing the source references
     * @param {Array} refTo Array containing the copied source references
     * @return {*} The copied value.
     */
    var _clone = function _clone(value, refFrom, refTo) {
        var copy = function copy(copiedValue) {
            var len = refFrom.length;
            var idx = 0;
            while (idx < len) {
                if (value === refFrom[idx]) {
                    return refTo[idx];
                }
                idx += 1;
            }
            refFrom[idx + 1] = value;
            refTo[idx + 1] = copiedValue;
            for (var key in value) {
                copiedValue[key] = _clone(value[key], refFrom, refTo);
            }
            return copiedValue;
        };
        switch (type(value)) {
        case 'Object':
            return copy({});
        case 'Array':
            return copy([]);
        case 'Date':
            return new Date(value);
        case 'RegExp':
            return _cloneRegExp(value);
        default:
            return value;
        }
    };

    var _createPartialApplicator = function _createPartialApplicator(concat) {
        return function (fn) {
            var args = _slice(arguments, 1);
            return _arity(Math.max(0, fn.length - args.length), function () {
                return fn.apply(this, concat(args, arguments));
            });
        };
    };

    /**
     * Returns a function that dispatches with different strategies based on the
     * object in list position (last argument). If it is an array, executes [fn].
     * Otherwise, if it has a  function with [methodname], it will execute that
     * function (functor case). Otherwise, if it is a transformer, uses transducer
     * [xf] to return a new transformer (transducer case). Otherwise, it will
     * default to executing [fn].
     *
     * @private
     * @param {String} methodname property to check for a custom implementation
     * @param {Function} xf transducer to initialize if object is transformer
     * @param {Function} fn default ramda implementation
     * @return {Function} A function that dispatches on object in list position
     */
    var _dispatchable = function _dispatchable(methodname, xf, fn) {
        return function () {
            var length = arguments.length;
            if (length === 0) {
                return fn();
            }
            var obj = arguments[length - 1];
            if (!_isArray(obj)) {
                var args = _slice(arguments, 0, length - 1);
                if (typeof obj[methodname] === 'function') {
                    return obj[methodname].apply(obj, args);
                }
                if (_isTransformer(obj)) {
                    var transducer = xf.apply(null, args);
                    return transducer(obj);
                }
            }
            return fn.apply(this, arguments);
        };
    };

    // The algorithm used to handle cyclic structures is
    // inspired by underscore's isEqual
    // RegExp equality algorithm: http://stackoverflow.com/a/10776635
    var _equals = function _equals(a, b, stackA, stackB) {
        var typeA = type(a);
        if (typeA !== type(b)) {
            return false;
        }
        if (typeA === 'Boolean' || typeA === 'Number' || typeA === 'String') {
            return typeof a === 'object' ? typeof b === 'object' && identical(a.valueOf(), b.valueOf()) : identical(a, b);
        }
        if (identical(a, b)) {
            return true;
        }
        if (typeA === 'RegExp') {
            // RegExp equality algorithm: http://stackoverflow.com/a/10776635
            return a.source === b.source && a.global === b.global && a.ignoreCase === b.ignoreCase && a.multiline === b.multiline && a.sticky === b.sticky && a.unicode === b.unicode;
        }
        if (Object(a) === a) {
            if (typeA === 'Date' && a.getTime() !== b.getTime()) {
                return false;
            }
            var keysA = keys(a);
            if (keysA.length !== keys(b).length) {
                return false;
            }
            var idx = stackA.length - 1;
            while (idx >= 0) {
                if (stackA[idx] === a) {
                    return stackB[idx] === b;
                }
                idx -= 1;
            }
            stackA[stackA.length] = a;
            stackB[stackB.length] = b;
            idx = keysA.length - 1;
            while (idx >= 0) {
                var key = keysA[idx];
                if (!_has(key, b) || !_equals(b[key], a[key], stackA, stackB)) {
                    return false;
                }
                idx -= 1;
            }
            stackA.pop();
            stackB.pop();
            return true;
        }
        return false;
    };

    /**
     * Private function that determines whether or not a provided object has a given method.
     * Does not ignore methods stored on the object's prototype chain. Used for dynamically
     * dispatching Ramda methods to non-Array objects.
     *
     * @private
     * @param {String} methodName The name of the method to check for.
     * @param {Object} obj The object to test.
     * @return {Boolean} `true` has a given method, `false` otherwise.
     * @example
     *
     *      var person = { name: 'John' };
     *      person.shout = function() { alert(this.name); };
     *
     *      _hasMethod('shout', person); //=> true
     *      _hasMethod('foo', person); //=> false
     */
    var _hasMethod = function _hasMethod(methodName, obj) {
        return obj != null && !_isArray(obj) && typeof obj[methodName] === 'function';
    };

    /**
     * `_makeFlat` is a helper function that returns a one-level or fully recursive function
     * based on the flag passed in.
     *
     * @private
     */
    var _makeFlat = function _makeFlat(recursive) {
        return function flatt(list) {
            var value, result = [], idx = 0, j, ilen = list.length, jlen;
            while (idx < ilen) {
                if (isArrayLike(list[idx])) {
                    value = recursive ? flatt(list[idx]) : list[idx];
                    j = 0;
                    jlen = value.length;
                    while (j < jlen) {
                        result[result.length] = value[j];
                        j += 1;
                    }
                } else {
                    result[result.length] = list[idx];
                }
                idx += 1;
            }
            return result;
        };
    };

    var _reduce = function () {
        function _arrayReduce(xf, acc, list) {
            var idx = 0, len = list.length;
            while (idx < len) {
                acc = xf['@@transducer/step'](acc, list[idx]);
                if (acc && acc['@@transducer/reduced']) {
                    acc = acc['@@transducer/value'];
                    break;
                }
                idx += 1;
            }
            return xf['@@transducer/result'](acc);
        }
        function _iterableReduce(xf, acc, iter) {
            var step = iter.next();
            while (!step.done) {
                acc = xf['@@transducer/step'](acc, step.value);
                if (acc && acc['@@transducer/reduced']) {
                    acc = acc['@@transducer/value'];
                    break;
                }
                step = iter.next();
            }
            return xf['@@transducer/result'](acc);
        }
        function _methodReduce(xf, acc, obj) {
            return xf['@@transducer/result'](obj.reduce(bind(xf['@@transducer/step'], xf), acc));
        }
        var symIterator = typeof Symbol !== 'undefined' ? Symbol.iterator : '@@iterator';
        return function _reduce(fn, acc, list) {
            if (typeof fn === 'function') {
                fn = _xwrap(fn);
            }
            if (isArrayLike(list)) {
                return _arrayReduce(fn, acc, list);
            }
            if (typeof list.reduce === 'function') {
                return _methodReduce(fn, acc, list);
            }
            if (list[symIterator] != null) {
                return _iterableReduce(fn, acc, list[symIterator]());
            }
            if (typeof list.next === 'function') {
                return _iterableReduce(fn, acc, list);
            }
            throw new TypeError('reduce: list must be array or iterable');
        };
    }();

    var _stepCat = function () {
        var _stepCatArray = {
            '@@transducer/init': Array,
            '@@transducer/step': function (xs, x) {
                return _concat(xs, [x]);
            },
            '@@transducer/result': _identity
        };
        var _stepCatString = {
            '@@transducer/init': String,
            '@@transducer/step': function (a, b) {
                return a + b;
            },
            '@@transducer/result': _identity
        };
        var _stepCatObject = {
            '@@transducer/init': Object,
            '@@transducer/step': function (result, input) {
                return merge(result, isArrayLike(input) ? createMapEntry(input[0], input[1]) : input);
            },
            '@@transducer/result': _identity
        };
        return function _stepCat(obj) {
            if (_isTransformer(obj)) {
                return obj;
            }
            if (isArrayLike(obj)) {
                return _stepCatArray;
            }
            if (typeof obj === 'string') {
                return _stepCatString;
            }
            if (typeof obj === 'object') {
                return _stepCatObject;
            }
            throw new Error('Cannot create transformer for ' + obj);
        };
    }();

    var _xall = function () {
        function XAll(f, xf) {
            this.xf = xf;
            this.f = f;
            this.all = true;
        }
        XAll.prototype['@@transducer/init'] = _xfBase.init;
        XAll.prototype['@@transducer/result'] = function (result) {
            if (this.all) {
                result = this.xf['@@transducer/step'](result, true);
            }
            return this.xf['@@transducer/result'](result);
        };
        XAll.prototype['@@transducer/step'] = function (result, input) {
            if (!this.f(input)) {
                this.all = false;
                result = _reduced(this.xf['@@transducer/step'](result, false));
            }
            return result;
        };
        return _curry2(function _xall(f, xf) {
            return new XAll(f, xf);
        });
    }();

    var _xany = function () {
        function XAny(f, xf) {
            this.xf = xf;
            this.f = f;
            this.any = false;
        }
        XAny.prototype['@@transducer/init'] = _xfBase.init;
        XAny.prototype['@@transducer/result'] = function (result) {
            if (!this.any) {
                result = this.xf['@@transducer/step'](result, false);
            }
            return this.xf['@@transducer/result'](result);
        };
        XAny.prototype['@@transducer/step'] = function (result, input) {
            if (this.f(input)) {
                this.any = true;
                result = _reduced(this.xf['@@transducer/step'](result, true));
            }
            return result;
        };
        return _curry2(function _xany(f, xf) {
            return new XAny(f, xf);
        });
    }();

    var _xdrop = function () {
        function XDrop(n, xf) {
            this.xf = xf;
            this.n = n;
        }
        XDrop.prototype['@@transducer/init'] = _xfBase.init;
        XDrop.prototype['@@transducer/result'] = _xfBase.result;
        XDrop.prototype['@@transducer/step'] = function (result, input) {
            if (this.n > 0) {
                this.n -= 1;
                return result;
            }
            return this.xf['@@transducer/step'](result, input);
        };
        return _curry2(function _xdrop(n, xf) {
            return new XDrop(n, xf);
        });
    }();

    var _xdropWhile = function () {
        function XDropWhile(f, xf) {
            this.xf = xf;
            this.f = f;
        }
        XDropWhile.prototype['@@transducer/init'] = _xfBase.init;
        XDropWhile.prototype['@@transducer/result'] = _xfBase.result;
        XDropWhile.prototype['@@transducer/step'] = function (result, input) {
            if (this.f) {
                if (this.f(input)) {
                    return result;
                }
                this.f = null;
            }
            return this.xf['@@transducer/step'](result, input);
        };
        return _curry2(function _xdropWhile(f, xf) {
            return new XDropWhile(f, xf);
        });
    }();

    var _xgroupBy = function () {
        function XGroupBy(f, xf) {
            this.xf = xf;
            this.f = f;
            this.inputs = {};
        }
        XGroupBy.prototype['@@transducer/init'] = _xfBase.init;
        XGroupBy.prototype['@@transducer/result'] = function (result) {
            var key;
            for (key in this.inputs) {
                if (_has(key, this.inputs)) {
                    result = this.xf['@@transducer/step'](result, this.inputs[key]);
                    if (result['@@transducer/reduced']) {
                        result = result['@@transducer/value'];
                        break;
                    }
                }
            }
            return this.xf['@@transducer/result'](result);
        };
        XGroupBy.prototype['@@transducer/step'] = function (result, input) {
            var key = this.f(input);
            this.inputs[key] = this.inputs[key] || [
                key,
                []
            ];
            this.inputs[key][1] = append(input, this.inputs[key][1]);
            return result;
        };
        return _curry2(function _xgroupBy(f, xf) {
            return new XGroupBy(f, xf);
        });
    }();

    /**
     * Creates a new list iteration function from an existing one by adding two new parameters
     * to its callback function: the current index, and the entire list.
     *
     * This would turn, for instance, Ramda's simple `map` function into one that more closely
     * resembles `Array.prototype.map`.  Note that this will only work for functions in which
     * the iteration callback function is the first parameter, and where the list is the last
     * parameter.  (This latter might be unimportant if the list parameter is not used.)
     *
     * @func
     * @memberOf R
     * @category Function
     * @category List
     * @sig ((a ... -> b) ... -> [a] -> *) -> (a ..., Int, [a] -> b) ... -> [a] -> *)
     * @param {Function} fn A list iteration function that does not pass index or list to its callback
     * @return {Function} An altered list iteration function that passes (item, index, list) to its callback
     * @example
     *
     *      var mapIndexed = R.addIndex(R.map);
     *      mapIndexed(function(val, idx) {return idx + '-' + val;}, ['f', 'o', 'o', 'b', 'a', 'r']);
     *      //=> ['0-f', '1-o', '2-o', '3-b', '4-a', '5-r']
     */
    var addIndex = _curry1(function addIndex(fn) {
        return curryN(fn.length, function () {
            var idx = 0;
            var origFn = arguments[0];
            var list = arguments[arguments.length - 1];
            var args = _slice(arguments);
            args[0] = function () {
                var result = origFn.apply(this, _concat(arguments, [
                    idx,
                    list
                ]));
                idx += 1;
                return result;
            };
            return fn.apply(this, args);
        });
    });

    /**
     * Returns `true` if all elements of the list match the predicate, `false` if there are any
     * that don't.
     *
     * Acts as a transducer if a transformer is given in list position.
     * @see R.transduce
     *
     * @func
     * @memberOf R
     * @category List
     * @sig (a -> Boolean) -> [a] -> Boolean
     * @param {Function} fn The predicate function.
     * @param {Array} list The array to consider.
     * @return {Boolean} `true` if the predicate is satisfied by every element, `false`
     *         otherwise.
     * @see R.any, R.none
     * @example
     *
     *      var lessThan2 = R.flip(R.lt)(2);
     *      var lessThan3 = R.flip(R.lt)(3);
     *      R.all(lessThan2)([1, 2]); //=> false
     *      R.all(lessThan3)([1, 2]); //=> true
     */
    var all = _curry2(_dispatchable('all', _xall, function all(fn, list) {
        var idx = 0;
        while (idx < list.length) {
            if (!fn(list[idx])) {
                return false;
            }
            idx += 1;
        }
        return true;
    }));

    /**
     * A function that returns the first argument if it's falsy otherwise the second
     * argument. Note that this is NOT short-circuited, meaning that if expressions
     * are passed they are both evaluated.
     *
     * Dispatches to the `and` method of the first argument if applicable.
     *
     * @func
     * @memberOf R
     * @category Logic
     * @sig * -> * -> *
     * @param {*} a any value
     * @param {*} b any other value
     * @return {*} the first argument if falsy otherwise the second argument.
     * @see R.both
     * @example
     *
     *      R.and(false, true); //=> false
     *      R.and(0, []); //=> 0
     *      R.and(null, ''); => null
     */
    var and = _curry2(function and(a, b) {
        return _hasMethod('and', a) ? a.and(b) : a && b;
    });

    /**
     * Returns `true` if at least one of elements of the list match the predicate, `false`
     * otherwise.
     *
     * Acts as a transducer if a transformer is given in list position.
     * @see R.transduce
     *
     * @func
     * @memberOf R
     * @category List
     * @sig (a -> Boolean) -> [a] -> Boolean
     * @param {Function} fn The predicate function.
     * @param {Array} list The array to consider.
     * @return {Boolean} `true` if the predicate is satisfied by at least one element, `false`
     *         otherwise.
     * @see R.all, R.none
     * @example
     *
     *      var lessThan0 = R.flip(R.lt)(0);
     *      var lessThan2 = R.flip(R.lt)(2);
     *      R.any(lessThan0)([1, 2]); //=> false
     *      R.any(lessThan2)([1, 2]); //=> true
     */
    var any = _curry2(_dispatchable('any', _xany, function any(fn, list) {
        var idx = 0;
        while (idx < list.length) {
            if (fn(list[idx])) {
                return true;
            }
            idx += 1;
        }
        return false;
    }));

    /**
     * Wraps a function of any arity (including nullary) in a function that accepts exactly 2
     * parameters. Any extraneous parameters will not be passed to the supplied function.
     *
     * @func
     * @memberOf R
     * @category Function
     * @sig (* -> c) -> (a, b -> c)
     * @param {Function} fn The function to wrap.
     * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of
     *         arity 2.
     * @example
     *
     *      var takesThreeArgs = function(a, b, c) {
     *        return [a, b, c];
     *      };
     *      takesThreeArgs.length; //=> 3
     *      takesThreeArgs(1, 2, 3); //=> [1, 2, 3]
     *
     *      var takesTwoArgs = R.binary(takesThreeArgs);
     *      takesTwoArgs.length; //=> 2
     *      // Only 2 arguments are passed to the wrapped function
     *      takesTwoArgs(1, 2, 3); //=> [1, 2, undefined]
     */
    var binary = _curry1(function binary(fn) {
        return nAry(2, fn);
    });

    /**
     * Creates a deep copy of the value which may contain (nested) `Array`s and
     * `Object`s, `Number`s, `String`s, `Boolean`s and `Date`s. `Function`s are
     * not copied, but assigned by their reference.
     *
     * @func
     * @memberOf R
     * @category Object
     * @sig {*} -> {*}
     * @param {*} value The object or array to clone
     * @return {*} A new object or array.
     * @example
     *
     *      var objects = [{}, {}, {}];
     *      var objectsClone = R.clone(objects);
     *      objects[0] === objectsClone[0]; //=> false
     */
    var clone = _curry1(function clone(value) {
        return _clone(value, [], []);
    });

    /**
     * Returns a new list consisting of the elements of the first list followed by the elements
     * of the second.
     *
     * @func
     * @memberOf R
     * @category List
     * @sig [a] -> [a] -> [a]
     * @param {Array} list1 The first list to merge.
     * @param {Array} list2 The second set to merge.
     * @return {Array} A new array consisting of the contents of `list1` followed by the
     *         contents of `list2`. If, instead of an Array for `list1`, you pass an
     *         object with a `concat` method on it, `concat` will call `list1.concat`
     *         and pass it the value of `list2`.
     *
     * @example
     *
     *      R.concat([], []); //=> []
     *      R.concat([4, 5, 6], [1, 2, 3]); //=> [4, 5, 6, 1, 2, 3]
     *      R.concat('ABC', 'DEF'); // 'ABCDEF'
     */
    var concat = _curry2(function concat(set1, set2) {
        if (_isArray(set2)) {
            return _concat(set1, set2);
        } else if (_hasMethod('concat', set1)) {
            return set1.concat(set2);
        } else {
            throw new TypeError('can\'t concat ' + typeof set1);
        }
    });

    /**
     * Returns a curried equivalent of the provided function. The curried
     * function has two unusual capabilities. First, its arguments needn't
     * be provided one at a time. If `f` is a ternary function and `g` is
     * `R.curry(f)`, the following are equivalent:
     *
     *   - `g(1)(2)(3)`
     *   - `g(1)(2, 3)`
     *   - `g(1, 2)(3)`
     *   - `g(1, 2, 3)`
     *
     * Secondly, the special placeholder value `R.__` may be used to specify
     * "gaps", allowing partial application of any combination of arguments,
     * regardless of their positions. If `g` is as above and `_` is `R.__`,
     * the following are equivalent:
     *
     *   - `g(1, 2, 3)`
     *   - `g(_, 2, 3)(1)`
     *   - `g(_, _, 3)(1)(2)`
     *   - `g(_, _, 3)(1, 2)`
     *   - `g(_, 2)(1)(3)`
     *   - `g(_, 2)(1, 3)`
     *   - `g(_, 2)(_, 3)(1)`
     *
     * @func
     * @memberOf R
     * @category Function
     * @sig (* -> a) -> (* -> a)
     * @param {Function} fn The function to curry.
     * @return {Function} A new, curried function.
     * @see R.curryN
     * @example
     *
     *      var addFourNumbers = function(a, b, c, d) {
     *        return a + b + c + d;
     *      };
     *
     *      var curriedAddFourNumbers = R.curry(addFourNumbers);
     *      var f = curriedAddFourNumbers(1, 2);
     *      var g = f(3);
     *      g(4); //=> 10
     */
    var curry = _curry1(function curry(fn) {
        return curryN(fn.length, fn);
    });

    /**
     * Returns a new list containing the last `n` elements of a given list, passing each value
     * to the supplied predicate function, skipping elements while the predicate function returns
     * `true`. The predicate function is passed one argument: *(value)*.
     *
     * Acts as a transducer if a transformer is given in list position.
     * @see R.transduce
     *
     * @func
     * @memberOf R
     * @category List
     * @sig (a -> Boolean) -> [a] -> [a]
     * @param {Function} fn The function called per iteration.
     * @param {Array} list The collection to iterate over.
     * @return {Array} A new array.
     * @see R.takeWhile
     * @example
     *
     *      var lteTwo = function(x) {
     *        return x <= 2;
     *      };
     *
     *      R.dropWhile(lteTwo, [1, 2, 3, 4, 3, 2, 1]); //=> [3, 4, 3, 2, 1]
     */
    var dropWhile = _curry2(_dispatchable('dropWhile', _xdropWhile, function dropWhile(pred, list) {
        var idx = 0, len = list.length;
        while (idx < len && pred(list[idx])) {
            idx += 1;
        }
        return _slice(list, idx);
    }));

    /**
     * Returns `true` if its arguments are equivalent, `false` otherwise.
     * Dispatches to an `equals` method if present. Handles cyclical data
     * structures.
     *
     * @func
     * @memberOf R
     * @category Relation
     * @sig a -> b -> Boolean
     * @param {*} a
     * @param {*} b
     * @return {Boolean}
     * @example
     *
     *      R.equals(1, 1); //=> true
     *      R.equals(1, '1'); //=> false
     *      R.equals([1, 2, 3], [1, 2, 3]); //=> true
     *
     *      var a = {}; a.v = a;
     *      var b = {}; b.v = b;
     *      R.equals(a, b); //=> true
     */
    var equals = _curry2(function equals(a, b) {
        return _hasMethod('equals', a) ? a.equals(b) : _hasMethod('equals', b) ? b.equals(a) : _equals(a, b, [], []);
    });

    /**
     * Returns a new list containing only those items that match a given predicate function.
     * The predicate function is passed one argument: *(value)*.
     *
     * Note that `R.filter` does not skip deleted or unassigned indices, unlike the native
     * `Array.prototype.filter` method. For more details on this behavior, see:
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/filter#Description
     *
     * Acts as a transducer if a transformer is given in list position.
     * @see R.transduce
     *
     * @func
     * @memberOf R
     * @category List
     * @sig (a -> Boolean) -> [a] -> [a]
     * @param {Function} fn The function called per iteration.
     * @param {Array} list The collection to iterate over.
     * @return {Array} The new filtered array.
     * @see R.reject
     * @example
     *
     *      var isEven = function(n) {
     *        return n % 2 === 0;
     *      };
     *      R.filter(isEven, [1, 2, 3, 4]); //=> [2, 4]
     */
    var filter = _curry2(_dispatchable('filter', _xfilter, _filter));

    /**
     * Returns the first element of the list which matches the predicate, or `undefined` if no
     * element matches.
     *
     * Acts as a transducer if a transformer is given in list position.
     * @see R.transduce
     *
     * @func
     * @memberOf R
     * @category List
     * @sig (a -> Boolean) -> [a] -> a | undefined
     * @param {Function} fn The predicate function used to determine if the element is the
     *        desired one.
     * @param {Array} list The array to consider.
     * @return {Object} The element found, or `undefined`.
     * @example
     *
     *      var xs = [{a: 1}, {a: 2}, {a: 3}];
     *      R.find(R.propEq('a', 2))(xs); //=> {a: 2}
     *      R.find(R.propEq('a', 4))(xs); //=> undefined
     */
    var find = _curry2(_dispatchable('find', _xfind, function find(fn, list) {
        var idx = 0;
        var len = list.length;
        while (idx < len) {
            if (fn(list[idx])) {
                return list[idx];
            }
            idx += 1;
        }
    }));

    /**
     * Returns the index of the first element of the list which matches the predicate, or `-1`
     * if no element matches.
     *
     * Acts as a transducer if a transformer is given in list position.
     * @see R.transduce
     *
     * @func
     * @memberOf R
     * @category List
     * @sig (a -> Boolean) -> [a] -> Number
     * @param {Function} fn The predicate function used to determine if the element is the
     * desired one.
     * @param {Array} list The array to consider.
     * @return {Number} The index of the element found, or `-1`.
     * @example
     *
     *      var xs = [{a: 1}, {a: 2}, {a: 3}];
     *      R.findIndex(R.propEq('a', 2))(xs); //=> 1
     *      R.findIndex(R.propEq('a', 4))(xs); //=> -1
     */
    var findIndex = _curry2(_dispatchable('findIndex', _xfindIndex, function findIndex(fn, list) {
        var idx = 0;
        var len = list.length;
        while (idx < len) {
            if (fn(list[idx])) {
                return idx;
            }
            idx += 1;
        }
        return -1;
    }));

    /**
     * Returns the last element of the list which matches the predicate, or `undefined` if no
     * element matches.
     *
     * Acts as a transducer if a transformer is given in list position.
     * @see R.transduce
     *
     * @func
     * @memberOf R
     * @category List
     * @sig (a -> Boolean) -> [a] -> a | undefined
     * @param {Function} fn The predicate function used to determine if the element is the
     * desired one.
     * @param {Array} list The array to consider.
     * @return {Object} The element found, or `undefined`.
     * @example
     *
     *      var xs = [{a: 1, b: 0}, {a:1, b: 1}];
     *      R.findLast(R.propEq('a', 1))(xs); //=> {a: 1, b: 1}
     *      R.findLast(R.propEq('a', 4))(xs); //=> undefined
     */
    var findLast = _curry2(_dispatchable('findLast', _xfindLast, function findLast(fn, list) {
        var idx = list.length - 1;
        while (idx >= 0) {
            if (fn(list[idx])) {
                return list[idx];
            }
            idx -= 1;
        }
    }));

    /**
     * Returns the index of the last element of the list which matches the predicate, or
     * `-1` if no element matches.
     *
     * Acts as a transducer if a transformer is given in list position.
     * @see R.transduce
     *
     * @func
     * @memberOf R
     * @category List
     * @sig (a -> Boolean) -> [a] -> Number
     * @param {Function} fn The predicate function used to determine if the element is the
     * desired one.
     * @param {Array} list The array to consider.
     * @return {Number} The index of the element found, or `-1`.
     * @example
     *
     *      var xs = [{a: 1, b: 0}, {a:1, b: 1}];
     *      R.findLastIndex(R.propEq('a', 1))(xs); //=> 1
     *      R.findLastIndex(R.propEq('a', 4))(xs); //=> -1
     */
    var findLastIndex = _curry2(_dispatchable('findLastIndex', _xfindLastIndex, function findLastIndex(fn, list) {
        var idx = list.length - 1;
        while (idx >= 0) {
            if (fn(list[idx])) {
                return idx;
            }
            idx -= 1;
        }
        return -1;
    }));

    /**
     * Returns a new list by pulling every item out of it (and all its sub-arrays) and putting
     * them in a new array, depth-first.
     *
     * @func
     * @memberOf R
     * @category List
     * @sig [a] -> [b]
     * @param {Array} list The array to consider.
     * @return {Array} The flattened list.
     * @see R.unnest
     * @example
     *
     *      R.flatten([1, 2, [3, 4], 5, [6, [7, 8, [9, [10, 11], 12]]]]);
     *      //=> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
     */
    var flatten = _curry1(_makeFlat(true));

    /**
     * Returns a new function much like the supplied one, except that the first two arguments'
     * order is reversed.
     *
     * @func
     * @memberOf R
     * @category Function
     * @sig (a -> b -> c -> ... -> z) -> (b -> a -> c -> ... -> z)
     * @param {Function} fn The function to invoke with its first two parameters reversed.
     * @return {*} The result of invoking `fn` with its first two parameters' order reversed.
     * @example
     *
     *      var mergeThree = function(a, b, c) {
     *        return ([]).concat(a, b, c);
     *      };
     *
     *      mergeThree(1, 2, 3); //=> [1, 2, 3]
     *
     *      R.flip(mergeThree)(1, 2, 3); //=> [2, 1, 3]
     */
    var flip = _curry1(function flip(fn) {
        return curry(function (a, b) {
            var args = _slice(arguments);
            args[0] = b;
            args[1] = a;
            return fn.apply(this, args);
        });
    });

    /**
     * Iterate over an input `list`, calling a provided function `fn` for each element in the
     * list.
     *
     * `fn` receives one argument: *(value)*.
     *
     * Note: `R.forEach` does not skip deleted or unassigned indices (sparse arrays), unlike
     * the native `Array.prototype.forEach` method. For more details on this behavior, see:
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach#Description
     *
     * Also note that, unlike `Array.prototype.forEach`, Ramda's `forEach` returns the original
     * array. In some libraries this function is named `each`.
     *
     * @func
     * @memberOf R
     * @category List
     * @sig (a -> *) -> [a] -> [a]
     * @param {Function} fn The function to invoke. Receives one argument, `value`.
     * @param {Array} list The list to iterate over.
     * @return {Array} The original list.
     * @example
     *
     *      var printXPlusFive = function(x) { console.log(x + 5); };
     *      R.forEach(printXPlusFive, [1, 2, 3]); //=> [1, 2, 3]
     *      //-> 6
     *      //-> 7
     *      //-> 8
     */
    var forEach = _curry2(_checkForMethod('forEach', function forEach(fn, list) {
        var len = list.length;
        var idx = 0;
        while (idx < len) {
            fn(list[idx]);
            idx += 1;
        }
        return list;
    }));

    /**
     * Returns a list of function names of object's own functions
     *
     * @func
     * @memberOf R
     * @category Object
     * @sig {*} -> [String]
     * @param {Object} obj The objects with functions in it
     * @return {Array} A list of the object's own properties that map to functions.
     * @example
     *
     *      R.functions(R); // returns list of ramda's own function names
     *
     *      var F = function() { this.x = function(){}; this.y = 1; }
     *      F.prototype.z = function() {};
     *      F.prototype.a = 100;
     *      R.functions(new F()); //=> ["x"]
     */
    var functions = _curry1(_functionsWith(keys));

    /**
     * Returns a list of function names of object's own and prototype functions
     *
     * @func
     * @memberOf R
     * @category Object
     * @sig {*} -> [String]
     * @param {Object} obj The objects with functions in it
     * @return {Array} A list of the object's own properties and prototype
     *         properties that map to functions.
     * @example
     *
     *      R.functionsIn(R); // returns list of ramda's own and prototype function names
     *
     *      var F = function() { this.x = function(){}; this.y = 1; }
     *      F.prototype.z = function() {};
     *      F.prototype.a = 100;
     *      R.functionsIn(new F()); //=> ["x", "z"]
     */
    var functionsIn = _curry1(_functionsWith(keysIn));

    /**
     * Splits a list into sub-lists stored in an object, based on the result of calling a String-returning function
     * on each element, and grouping the results according to values returned.
     *
     * Acts as a transducer if a transformer is given in list position.
     * @see R.transduce
     *
     * @func
     * @memberOf R
     * @category List
     * @sig (a -> String) -> [a] -> {String: [a]}
     * @param {Function} fn Function :: a -> String
     * @param {Array} list The array to group
     * @return {Object} An object with the output of `fn` for keys, mapped to arrays of elements
     *         that produced that key when passed to `fn`.
     * @example
     *
     *      var byGrade = R.groupBy(function(student) {
     *        var score = student.score;
     *        return score < 65 ? 'F' :
     *               score < 70 ? 'D' :
     *               score < 80 ? 'C' :
     *               score < 90 ? 'B' : 'A';
     *      });
     *      var students = [{name: 'Abby', score: 84},
     *                      {name: 'Eddy', score: 58},
     *                      // ...
     *                      {name: 'Jack', score: 69}];
     *      byGrade(students);
     *      // {
     *      //   'A': [{name: 'Dianne', score: 99}],
     *      //   'B': [{name: 'Abby', score: 84}]
     *      //   // ...,
     *      //   'F': [{name: 'Eddy', score: 58}]
     *      // }
     */
    var groupBy = _curry2(_dispatchable('groupBy', _xgroupBy, function groupBy(fn, list) {
        return _reduce(function (acc, elt) {
            var key = fn(elt);
            acc[key] = append(elt, acc[key] || (acc[key] = []));
            return acc;
        }, {}, list);
    }));

    /**
     * Returns the first element of the given list or string. In some libraries
     * this function is named `first`.
     *
     * @func
     * @memberOf R
     * @category List
     * @see R.tail, R.init, R.last
     * @sig [a] -> a | Undefined
     * @sig String -> String
     * @param {*} list
     * @return {*}
     * @example
     *
     *      R.head(['fi', 'fo', 'fum']); //=> 'fi'
     *      R.head([]); //=> undefined
     *
     *      R.head('abc'); //=> 'a'
     *      R.head(''); //=> ''
     */
    var head = nth(0);

    /**
     * Combines two lists into a set (i.e. no duplicates) composed of those
     * elements common to both lists.  Duplication is determined according
     * to the value returned by applying the supplied predicate to two list
     * elements.
     *
     * @func
     * @memberOf R
     * @category Relation
     * @sig (a,a -> Boolean) -> [a] -> [a] -> [a]
     * @param {Function} pred A predicate function that determines whether
     *        the two supplied elements are equal.
     * @param {Array} list1 One list of items to compare
     * @param {Array} list2 A second list of items to compare
     * @see R.intersection
     * @return {Array} A new list containing those elements common to both lists.
     * @example
     *
     *      var buffaloSpringfield = [
     *        {id: 824, name: 'Richie Furay'},
     *        {id: 956, name: 'Dewey Martin'},
     *        {id: 313, name: 'Bruce Palmer'},
     *        {id: 456, name: 'Stephen Stills'},
     *        {id: 177, name: 'Neil Young'}
     *      ];
     *      var csny = [
     *        {id: 204, name: 'David Crosby'},
     *        {id: 456, name: 'Stephen Stills'},
     *        {id: 539, name: 'Graham Nash'},
     *        {id: 177, name: 'Neil Young'}
     *      ];
     *
     *      var sameId = function(o1, o2) {return o1.id === o2.id;};
     *
     *      R.intersectionWith(sameId, buffaloSpringfield, csny);
     *      //=> [{id: 456, name: 'Stephen Stills'}, {id: 177, name: 'Neil Young'}]
     */
    var intersectionWith = _curry3(function intersectionWith(pred, list1, list2) {
        var results = [], idx = 0;
        while (idx < list1.length) {
            if (_containsWith(pred, list1[idx], list2)) {
                results[results.length] = list1[idx];
            }
            idx += 1;
        }
        return uniqWith(pred, results);
    });

    /**
     * Creates a new list with the separator interposed between elements.
     *
     * @func
     * @memberOf R
     * @category List
     * @sig a -> [a] -> [a]
     * @param {*} separator The element to add to the list.
     * @param {Array} list The list to be interposed.
     * @return {Array} The new list.
     * @example
     *
     *      R.intersperse('n', ['ba', 'a', 'a']); //=> ['ba', 'n', 'a', 'n', 'a']
     */
    var intersperse = _curry2(_checkForMethod('intersperse', function intersperse(separator, list) {
        var out = [];
        var idx = 0;
        var length = list.length;
        while (idx < length) {
            if (idx === length - 1) {
                out.push(list[idx]);
            } else {
                out.push(list[idx], separator);
            }
            idx += 1;
        }
        return out;
    }));

    /**
     * Transforms the items of the list with the transducer and appends the transformed items to
     * the accumulator using an appropriate iterator function based on the accumulator type.
     *
     * The accumulator can be an array, string, object or a transformer. Iterated items will
     * be appended to arrays and concatenated to strings. Objects will be merged directly or 2-item
     * arrays will be merged as key, value pairs.
     *
     * The accumulator can also be a transformer object that provides a 2-arity reducing iterator
     * function, step, 0-arity initial value function, init, and 1-arity result extraction function
     * result. The step function is used as the iterator function in reduce. The result function is
     * used to convert the final accumulator into the return type and in most cases is R.identity.
     * The init function is used to provide the initial accumulator.
     *
     * The iteration is performed with R.reduce after initializing the transducer.
     *
     * @func
     * @memberOf R
     * @category List
     * @sig a -> (b -> b) -> [c] -> a
     * @param {*} acc The initial accumulator value.
     * @param {Function} xf The transducer function. Receives a transformer and returns a transformer.
     * @param {Array} list The list to iterate over.
     * @return {*} The final, accumulated value.
     * @example
     *
     *      var numbers = [1, 2, 3, 4];
     *      var transducer = R.compose(R.map(R.add(1)), R.take(2));
     *
     *      R.into([], transducer, numbers); //=> [2, 3]
     *
     *      var intoArray = R.into([]);
     *      intoArray(transducer, numbers); //=> [2, 3]
     */
    var into = _curry3(function into(acc, xf, list) {
        return _isTransformer(acc) ? _reduce(xf(acc), acc['@@transducer/init'](), list) : _reduce(xf(_stepCat(acc)), acc, list);
    });

    /**
     * Same as R.invertObj, however this accounts for objects
     * with duplicate values by putting the values into an
     * array.
     *
     * @func
     * @memberOf R
     * @category Object
     * @sig {s: x} -> {x: [ s, ... ]}
     * @param {Object} obj The object or array to invert
     * @return {Object} out A new object with keys
     * in an array.
     * @example
     *
     *      var raceResultsByFirstName = {
     *        first: 'alice',
     *        second: 'jake',
     *        third: 'alice',
     *      };
     *      R.invert(raceResultsByFirstName);
     *      //=> { 'alice': ['first', 'third'], 'jake':['second'] }
     */
    var invert = _curry1(function invert(obj) {
        var props = keys(obj);
        var len = props.length;
        var idx = 0;
        var out = {};
        while (idx < len) {
            var key = props[idx];
            var val = obj[key];
            var list = _has(val, out) ? out[val] : out[val] = [];
            list[list.length] = key;
            idx += 1;
        }
        return out;
    });

    /**
     * Returns a new object with the keys of the given object
     * as values, and the values of the given object as keys.
     *
     * @func
     * @memberOf R
     * @category Object
     * @sig {s: x} -> {x: s}
     * @param {Object} obj The object or array to invert
     * @return {Object} out A new object
     * @example
     *
     *      var raceResults = {
     *        first: 'alice',
     *        second: 'jake'
     *      };
     *      R.invertObj(raceResults);
     *      //=> { 'alice': 'first', 'jake':'second' }
     *
     *      // Alternatively:
     *      var raceResults = ['alice', 'jake'];
     *      R.invertObj(raceResults);
     *      //=> { 'alice': '0', 'jake':'1' }
     */
    var invertObj = _curry1(function invertObj(obj) {
        var props = keys(obj);
        var len = props.length;
        var idx = 0;
        var out = {};
        while (idx < len) {
            var key = props[idx];
            out[obj[key]] = key;
            idx += 1;
        }
        return out;
    });

    /**
     * Returns the last element of the given list or string.
     *
     * @func
     * @memberOf R
     * @category List
     * @see R.init, R.head, R.tail
     * @sig [a] -> a | Undefined
     * @sig String -> String
     * @param {*} list
     * @return {*}
     * @example
     *
     *      R.last(['fi', 'fo', 'fum']); //=> 'fum'
     *      R.last([]); //=> undefined
     *
     *      R.last('abc'); //=> 'c'
     *      R.last(''); //=> ''
     */
    var last = nth(-1);

    /**
     * Returns the position of the last occurrence of an item in
     * an array, or -1 if the item is not included in the array.
     * `R.equals` is used to determine equality.
     *
     * @func
     * @memberOf R
     * @category List
     * @sig a -> [a] -> Number
     * @param {*} target The item to find.
     * @param {Array} xs The array to search in.
     * @return {Number} the index of the target, or -1 if the target is not found.
     * @see R.indexOf
     * @example
     *
     *      R.lastIndexOf(3, [-1,3,3,0,1,2,3,4]); //=> 6
     *      R.lastIndexOf(10, [1,2,3,4]); //=> -1
     */
    var lastIndexOf = _curry2(function lastIndexOf(target, xs) {
        if (_hasMethod('lastIndexOf', xs)) {
            return xs.lastIndexOf(target);
        } else {
            var idx = xs.length - 1;
            while (idx >= 0) {
                if (equals(xs[idx], target)) {
                    return idx;
                }
                idx -= 1;
            }
            return -1;
        }
    });

    /**
     * Returns a new list, constructed by applying the supplied function to every element of the
     * supplied list.
     *
     * Note: `R.map` does not skip deleted or unassigned indices (sparse arrays), unlike the
     * native `Array.prototype.map` method. For more details on this behavior, see:
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map#Description
     *
     * Acts as a transducer if a transformer is given in list position.
     * @see R.transduce
     *
     * @func
     * @memberOf R
     * @category List
     * @sig (a -> b) -> [a] -> [b]
     * @param {Function} fn The function to be called on every element of the input `list`.
     * @param {Array} list The list to be iterated over.
     * @return {Array} The new list.
     * @example
     *
     *      var double = function(x) {
     *        return x * 2;
     *      };
     *
     *      R.map(double, [1, 2, 3]); //=> [2, 4, 6]
     */
    var map = _curry2(_dispatchable('map', _xmap, _map));

    /**
     * Map, but for objects. Creates an object with the same keys as `obj` and values
     * generated by running each property of `obj` through `fn`. `fn` is passed one argument:
     * *(value)*.
     *
     * @func
     * @memberOf R
     * @category Object
     * @sig (v -> v) -> {k: v} -> {k: v}
     * @param {Function} fn A function called for each property in `obj`. Its return value will
     * become a new property on the return object.
     * @param {Object} obj The object to iterate over.
     * @return {Object} A new object with the same keys as `obj` and values that are the result
     *         of running each property through `fn`.
     * @example
     *
     *      var values = { x: 1, y: 2, z: 3 };
     *      var double = function(num) {
     *        return num * 2;
     *      };
     *
     *      R.mapObj(double, values); //=> { x: 2, y: 4, z: 6 }
     */
    var mapObj = _curry2(function mapObj(fn, obj) {
        return _reduce(function (acc, key) {
            acc[key] = fn(obj[key]);
            return acc;
        }, {}, keys(obj));
    });

    /**
     * Like `mapObj`, but but passes additional arguments to the predicate function. The
     * predicate function is passed three arguments: *(value, key, obj)*.
     *
     * @func
     * @memberOf R
     * @category Object
     * @sig (v, k, {k: v} -> v) -> {k: v} -> {k: v}
     * @param {Function} fn A function called for each property in `obj`. Its return value will
     *        become a new property on the return object.
     * @param {Object} obj The object to iterate over.
     * @return {Object} A new object with the same keys as `obj` and values that are the result
     *         of running each property through `fn`.
     * @example
     *
     *      var values = { x: 1, y: 2, z: 3 };
     *      var prependKeyAndDouble = function(num, key, obj) {
     *        return key + (num * 2);
     *      };
     *
     *      R.mapObjIndexed(prependKeyAndDouble, values); //=> { x: 'x2', y: 'y4', z: 'z6' }
     */
    var mapObjIndexed = _curry2(function mapObjIndexed(fn, obj) {
        return _reduce(function (acc, key) {
            acc[key] = fn(obj[key], key, obj);
            return acc;
        }, {}, keys(obj));
    });

    /**
     * Returns `true` if no elements of the list match the predicate,
     * `false` otherwise.
     *
     * @func
     * @memberOf R
     * @category List
     * @sig (a -> Boolean) -> [a] -> Boolean
     * @param {Function} fn The predicate function.
     * @param {Array} list The array to consider.
     * @return {Boolean} `true` if the predicate is not satisfied by every element, `false` otherwise.
     * @see R.all, R.any
     * @example
     *
     *      R.none(R.isNaN, [1, 2, 3]); //=> true
     *      R.none(R.isNaN, [1, 2, 3, NaN]); //=> false
     */
    var none = _curry2(_complement(_dispatchable('any', _xany, any)));

    /**
     * A function that returns the first truthy of two arguments otherwise the
     * last argument. Note that this is NOT short-circuited, meaning that if
     * expressions are passed they are both evaluated.
     *
     * Dispatches to the `or` method of the first argument if applicable.
     *
     * @func
     * @memberOf R
     * @category Logic
     * @sig * -> * -> *
     * @param {*} a any value
     * @param {*} b any other value
     * @return {*} the first truthy argument, otherwise the last argument.
     * @see R.either
     * @example
     *
     *      R.or(false, true); //=> true
     *      R.or(0, []); //=> []
     *      R.or(null, ''); => ''
     */
    var or = _curry2(function or(a, b) {
        return _hasMethod('or', a) ? a.or(b) : a || b;
    });

    /**
     * Accepts as its arguments a function and any number of values and returns a function that,
     * when invoked, calls the original function with all of the values prepended to the
     * original function's arguments list. In some libraries this function is named `applyLeft`.
     *
     * @func
     * @memberOf R
     * @category Function
     * @sig (a -> b -> ... -> i -> j -> ... -> m -> n) -> a -> b-> ... -> i -> (j -> ... -> m -> n)
     * @param {Function} fn The function to invoke.
     * @param {...*} [args] Arguments to prepend to `fn` when the returned function is invoked.
     * @return {Function} A new function wrapping `fn`. When invoked, it will call `fn`
     *         with `args` prepended to `fn`'s arguments list.
     * @example
     *
     *      var multiply = function(a, b) { return a * b; };
     *      var double = R.partial(multiply, 2);
     *      double(2); //=> 4
     *
     *      var greet = function(salutation, title, firstName, lastName) {
     *        return salutation + ', ' + title + ' ' + firstName + ' ' + lastName + '!';
     *      };
     *      var sayHello = R.partial(greet, 'Hello');
     *      var sayHelloToMs = R.partial(sayHello, 'Ms.');
     *      sayHelloToMs('Jane', 'Jones'); //=> 'Hello, Ms. Jane Jones!'
     */
    var partial = curry(_createPartialApplicator(_concat));

    /**
     * Accepts as its arguments a function and any number of values and returns a function that,
     * when invoked, calls the original function with all of the values appended to the original
     * function's arguments list.
     *
     * Note that `partialRight` is the opposite of `partial`: `partialRight` fills `fn`'s arguments
     * from the right to the left.  In some libraries this function is named `applyRight`.
     *
     * @func
     * @memberOf R
     * @category Function
     * @sig (a -> b-> ... -> i -> j -> ... -> m -> n) -> j -> ... -> m -> n -> (a -> b-> ... -> i)
     * @param {Function} fn The function to invoke.
     * @param {...*} [args] Arguments to append to `fn` when the returned function is invoked.
     * @return {Function} A new function wrapping `fn`. When invoked, it will call `fn` with
     *         `args` appended to `fn`'s arguments list.
     * @example
     *
     *      var greet = function(salutation, title, firstName, lastName) {
     *        return salutation + ', ' + title + ' ' + firstName + ' ' + lastName + '!';
     *      };
     *      var greetMsJaneJones = R.partialRight(greet, 'Ms.', 'Jane', 'Jones');
     *
     *      greetMsJaneJones('Hello'); //=> 'Hello, Ms. Jane Jones!'
     */
    var partialRight = curry(_createPartialApplicator(flip(_concat)));

    /**
     * Takes a predicate and a list and returns the pair of lists of
     * elements which do and do not satisfy the predicate, respectively.
     *
     * @func
     * @memberOf R
     * @category List
     * @sig (a -> Boolean) -> [a] -> [[a],[a]]
     * @param {Function} pred A predicate to determine which array the element belongs to.
     * @param {Array} list The array to partition.
     * @return {Array} A nested array, containing first an array of elements that satisfied the predicate,
     *         and second an array of elements that did not satisfy.
     * @example
     *
     *      R.partition(R.contains('s'), ['sss', 'ttt', 'foo', 'bars']);
     *      //=> [ [ 'sss', 'bars' ],  [ 'ttt', 'foo' ] ]
     */
    var partition = _curry2(function partition(pred, list) {
        return _reduce(function (acc, elt) {
            var xs = acc[pred(elt) ? 0 : 1];
            xs[xs.length] = elt;
            return acc;
        }, [
            [],
            []
        ], list);
    });

    /**
     * Determines whether a nested path on an object has a specific value,
     * in `R.equals` terms. Most likely used to filter a list.
     *
     * @func
     * @memberOf R
     * @category Relation
     * @sig [String] -> * -> {String: *} -> Boolean
     * @param {Array} path The path of the nested property to use
     * @param {*} val The value to compare the nested property with
     * @param {Object} obj The object to check the nested property in
     * @return {Boolean} `true` if the value equals the nested object property,
     *         `false` otherwise.
     * @example
     *
     *      var user1 = { address: { zipCode: 90210 } };
     *      var user2 = { address: { zipCode: 55555 } };
     *      var user3 = { name: 'Bob' };
     *      var users = [ user1, user2, user3 ];
     *      var isFamous = R.pathEq(['address', 'zipCode'], 90210);
     *      R.filter(isFamous, users); //=> [ user1 ]
     */
    var pathEq = _curry3(function pathEq(_path, val, obj) {
        return equals(path(_path, obj), val);
    });

    /**
     * Returns a new list by plucking the same named property off all objects in the list supplied.
     *
     * @func
     * @memberOf R
     * @category List
     * @sig k -> [{k: v}] -> [v]
     * @param {Number|String} key The key name to pluck off of each object.
     * @param {Array} list The array to consider.
     * @return {Array} The list of values for the given key.
     * @example
     *
     *      R.pluck('a')([{a: 1}, {a: 2}]); //=> [1, 2]
     *      R.pluck(0)([[1, 2], [3, 4]]);   //=> [1, 3]
     */
    var pluck = _curry2(function pluck(p, list) {
        return map(prop(p), list);
    });

    /**
     * Returns `true` if the specified object property is equal, in `R.equals`
     * terms, to the given value; `false` otherwise.
     *
     * @func
     * @memberOf R
     * @category Relation
     * @sig String -> a -> Object -> Boolean
     * @param {String} name
     * @param {*} val
     * @param {*} obj
     * @return {Boolean}
     * @see R.equals, R.propSatisfies
     * @example
     *
     *      var abby = {name: 'Abby', age: 7, hair: 'blond'};
     *      var fred = {name: 'Fred', age: 12, hair: 'brown'};
     *      var rusty = {name: 'Rusty', age: 10, hair: 'brown'};
     *      var alois = {name: 'Alois', age: 15, disposition: 'surly'};
     *      var kids = [abby, fred, rusty, alois];
     *      var hasBrownHair = R.propEq('hair', 'brown');
     *      R.filter(hasBrownHair, kids); //=> [fred, rusty]
     */
    var propEq = _curry3(function propEq(name, val, obj) {
        return propSatisfies(equals(val), name, obj);
    });

    /**
     * Returns `true` if the specified object property is of the given type;
     * `false` otherwise.
     *
     * @func
     * @memberOf R
     * @category Type
     * @sig Type -> String -> Object -> Boolean
     * @param {Function} type
     * @param {String} name
     * @param {*} obj
     * @return {Boolean}
     * @see R.is
     * @see R.propSatisfies
     * @example
     *
     *      R.propIs(Number, 'x', {x: 1, y: 2});  //=> true
     *      R.propIs(Number, 'x', {x: 'foo'});    //=> false
     *      R.propIs(Number, 'x', {});            //=> false
     */
    var propIs = _curry3(function propIs(type, name, obj) {
        return propSatisfies(is(type), name, obj);
    });

    /**
     * Returns a single item by iterating through the list, successively calling the iterator
     * function and passing it an accumulator value and the current value from the array, and
     * then passing the result to the next call.
     *
     * The iterator function receives two values: *(acc, value)*.  It may use `R.reduced` to
     * shortcut the iteration.
     *
     * Note: `R.reduce` does not skip deleted or unassigned indices (sparse arrays), unlike
     * the native `Array.prototype.reduce` method. For more details on this behavior, see:
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce#Description
     * @see R.reduced
     *
     * @func
     * @memberOf R
     * @category List
     * @sig (a,b -> a) -> a -> [b] -> a
     * @param {Function} fn The iterator function. Receives two values, the accumulator and the
     *        current element from the array.
     * @param {*} acc The accumulator value.
     * @param {Array} list The list to iterate over.
     * @return {*} The final, accumulated value.
     * @example
     *
     *      var numbers = [1, 2, 3];
     *      var add = function(a, b) {
     *        return a + b;
     *      };
     *
     *      R.reduce(add, 10, numbers); //=> 16
     */
    var reduce = _curry3(_reduce);

    /**
     * Similar to `filter`, except that it keeps only values for which the given predicate
     * function returns falsy. The predicate function is passed one argument: *(value)*.
     *
     * Acts as a transducer if a transformer is given in list position.
     * @see R.transduce
     *
     * @func
     * @memberOf R
     * @category List
     * @sig (a -> Boolean) -> [a] -> [a]
     * @param {Function} fn The function called per iteration.
     * @param {Array} list The collection to iterate over.
     * @return {Array} The new filtered array.
     * @see R.filter
     * @example
     *
     *      var isOdd = function(n) {
     *        return n % 2 === 1;
     *      };
     *      R.reject(isOdd, [1, 2, 3, 4]); //=> [2, 4]
     */
    var reject = _curry2(function reject(fn, list) {
        return filter(_complement(fn), list);
    });

    /**
     * Returns a fixed list of size `n` containing a specified identical value.
     *
     * @func
     * @memberOf R
     * @category List
     * @sig a -> n -> [a]
     * @param {*} value The value to repeat.
     * @param {Number} n The desired size of the output list.
     * @return {Array} A new array containing `n` `value`s.
     * @example
     *
     *      R.repeat('hi', 5); //=> ['hi', 'hi', 'hi', 'hi', 'hi']
     *
     *      var obj = {};
     *      var repeatedObjs = R.repeat(obj, 5); //=> [{}, {}, {}, {}, {}]
     *      repeatedObjs[0] === repeatedObjs[1]; //=> true
     */
    var repeat = _curry2(function repeat(value, n) {
        return times(always(value), n);
    });

    /**
     * Returns the elements of the given list or string (or object with a `slice`
     * method) from `fromIndex` (inclusive) to `toIndex` (exclusive).
     *
     * @func
     * @memberOf R
     * @category List
     * @sig Number -> Number -> [a] -> [a]
     * @sig Number -> Number -> String -> String
     * @param {Number} fromIndex The start index (inclusive).
     * @param {Number} toIndex The end index (exclusive).
     * @param {*} list
     * @return {*}
     * @example
     *
     *      R.slice(1, 3, ['a', 'b', 'c', 'd']);        //=> ['b', 'c']
     *      R.slice(1, Infinity, ['a', 'b', 'c', 'd']); //=> ['b', 'c', 'd']
     *      R.slice(0, -1, ['a', 'b', 'c', 'd']);       //=> ['a', 'b', 'c']
     *      R.slice(-3, -1, ['a', 'b', 'c', 'd']);      //=> ['b', 'c']
     *      R.slice(0, 3, 'ramda');                     //=> 'ram'
     */
    var slice = _curry3(_checkForMethod('slice', function slice(fromIndex, toIndex, list) {
        return Array.prototype.slice.call(list, fromIndex, toIndex);
    }));

    /**
     * Splits a collection into slices of the specified length.
     *
     * @func
     * @memberOf R
     * @category List
     * @sig Number -> [a] -> [[a]]
     * @sig Number -> String -> [String]
     * @param {Number} n
     * @param {Array} list
     * @return {Array}
     * @example
     *
     *      R.splitEvery(3, [1, 2, 3, 4, 5, 6, 7]); //=> [[1, 2, 3], [4, 5, 6], [7]]
     *      R.splitEvery(3, 'foobarbaz'); //=> ['foo', 'bar', 'baz']
     */
    var splitEvery = _curry2(function splitEvery(n, list) {
        if (n <= 0) {
            throw new Error('First argument to splitEvery must be a positive integer');
        }
        var result = [];
        var idx = 0;
        while (idx < list.length) {
            result.push(slice(idx, idx += n, list));
        }
        return result;
    });

    /**
     * Adds together all the elements of a list.
     *
     * @func
     * @memberOf R
     * @category Math
     * @sig [Number] -> Number
     * @param {Array} list An array of numbers
     * @return {Number} The sum of all the numbers in the list.
     * @see R.reduce
     * @example
     *
     *      R.sum([2,4,6,8,100,1]); //=> 121
     */
    var sum = reduce(add, 0);

    /**
     * Returns all but the first element of the given list or string (or object
     * with a `tail` method).
     *
     * @func
     * @memberOf R
     * @category List
     * @see R.head, R.init, R.last
     * @sig [a] -> [a]
     * @sig String -> String
     * @param {*} list
     * @return {*}
     * @example
     *
     *      R.tail([1, 2, 3]);  //=> [2, 3]
     *      R.tail([1, 2]);     //=> [2]
     *      R.tail([1]);        //=> []
     *      R.tail([]);         //=> []
     *
     *      R.tail('abc');  //=> 'bc'
     *      R.tail('ab');   //=> 'b'
     *      R.tail('a');    //=> ''
     *      R.tail('');     //=> ''
     */
    var tail = _checkForMethod('tail', slice(1, Infinity));

    /**
     * Returns the first `n` elements of the given list, string, or
     * transducer/transformer (or object with a `take` method).
     *
     * @func
     * @memberOf R
     * @category List
     * @sig Number -> [a] -> [a]
     * @sig Number -> String -> String
     * @param {Number} n
     * @param {*} list
     * @return {*}
     * @see R.drop
     * @example
     *
     *      R.take(1, ['foo', 'bar', 'baz']); //=> ['foo']
     *      R.take(2, ['foo', 'bar', 'baz']); //=> ['foo', 'bar']
     *      R.take(3, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
     *      R.take(4, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
     *      R.take(3, 'ramda');               //=> 'ram'
     *
     *      var personnel = [
     *        'Dave Brubeck',
     *        'Paul Desmond',
     *        'Eugene Wright',
     *        'Joe Morello',
     *        'Gerry Mulligan',
     *        'Bob Bates',
     *        'Joe Dodge',
     *        'Ron Crotty'
     *      ];
     *
     *      var takeFive = R.take(5);
     *      takeFive(personnel);
     *      //=> ['Dave Brubeck', 'Paul Desmond', 'Eugene Wright', 'Joe Morello', 'Gerry Mulligan']
     */
    var take = _curry2(_dispatchable('take', _xtake, function take(n, xs) {
        return slice(0, n < 0 ? Infinity : n, xs);
    }));

    /**
     * Returns a new list containing the first `n` elements of a given list, passing each value
     * to the supplied predicate function, and terminating when the predicate function returns
     * `false`. Excludes the element that caused the predicate function to fail. The predicate
     * function is passed one argument: *(value)*.
     *
     * Acts as a transducer if a transformer is given in list position.
     * @see R.transduce
     *
     * @func
     * @memberOf R
     * @category List
     * @sig (a -> Boolean) -> [a] -> [a]
     * @param {Function} fn The function called per iteration.
     * @param {Array} list The collection to iterate over.
     * @return {Array} A new array.
     * @see R.dropWhile
     * @example
     *
     *      var isNotFour = function(x) {
     *        return !(x === 4);
     *      };
     *
     *      R.takeWhile(isNotFour, [1, 2, 3, 4]); //=> [1, 2, 3]
     */
    var takeWhile = _curry2(_dispatchable('takeWhile', _xtakeWhile, function takeWhile(fn, list) {
        var idx = 0, len = list.length;
        while (idx < len && fn(list[idx])) {
            idx += 1;
        }
        return _slice(list, 0, idx);
    }));

    /**
     * Initializes a transducer using supplied iterator function. Returns a single item by
     * iterating through the list, successively calling the transformed iterator function and
     * passing it an accumulator value and the current value from the array, and then passing
     * the result to the next call.
     *
     * The iterator function receives two values: *(acc, value)*. It will be wrapped as a
     * transformer to initialize the transducer. A transformer can be passed directly in place
     * of an iterator function.  In both cases, iteration may be stopped early with the
     * `R.reduced` function.
     *
     * A transducer is a function that accepts a transformer and returns a transformer and can
     * be composed directly.
     *
     * A transformer is an an object that provides a 2-arity reducing iterator function, step,
     * 0-arity initial value function, init, and 1-arity result extraction function, result.
     * The step function is used as the iterator function in reduce. The result function is used
     * to convert the final accumulator into the return type and in most cases is R.identity.
     * The init function can be used to provide an initial accumulator, but is ignored by transduce.
     *
     * The iteration is performed with R.reduce after initializing the transducer.
     *
     * @func
     * @memberOf R
     * @category List
     * @see R.reduce, R.reduced, R.into
     * @sig (c -> c) -> (a,b -> a) -> a -> [b] -> a
     * @param {Function} xf The transducer function. Receives a transformer and returns a transformer.
     * @param {Function} fn The iterator function. Receives two values, the accumulator and the
     *        current element from the array. Wrapped as transformer, if necessary, and used to
     *        initialize the transducer
     * @param {*} acc The initial accumulator value.
     * @param {Array} list The list to iterate over.
     * @return {*} The final, accumulated value.
     * @example
     *
     *      var numbers = [1, 2, 3, 4];
     *      var transducer = R.compose(R.map(R.add(1)), R.take(2));
     *
     *      R.transduce(transducer, R.flip(R.append), [], numbers); //=> [2, 3]
     */
    var transduce = curryN(4, function transduce(xf, fn, acc, list) {
        return _reduce(xf(typeof fn === 'function' ? _xwrap(fn) : fn), acc, list);
    });

    /**
     * Combines two lists into a set (i.e. no duplicates) composed of the elements of each list.  Duplication is
     * determined according to the value returned by applying the supplied predicate to two list elements.
     *
     * @func
     * @memberOf R
     * @category Relation
     * @sig (a,a -> Boolean) -> [a] -> [a] -> [a]
     * @param {Function} pred A predicate used to test whether two items are equal.
     * @param {Array} list1 The first list.
     * @param {Array} list2 The second list.
     * @return {Array} The first and second lists concatenated, with
     *         duplicates removed.
     * @see R.union
     * @example
     *
     *      function cmp(x, y) { return x.a === y.a; }
     *      var l1 = [{a: 1}, {a: 2}];
     *      var l2 = [{a: 1}, {a: 4}];
     *      R.unionWith(cmp, l1, l2); //=> [{a: 1}, {a: 2}, {a: 4}]
     */
    var unionWith = _curry3(function unionWith(pred, list1, list2) {
        return uniqWith(pred, _concat(list1, list2));
    });

    /**
     * Returns a new list containing only one copy of each element in the original list.
     * `R.equals` is used to determine equality.
     *
     * @func
     * @memberOf R
     * @category List
     * @sig [a] -> [a]
     * @param {Array} list The array to consider.
     * @return {Array} The list of unique items.
     * @example
     *
     *      R.uniq([1, 1, 2, 1]); //=> [1, 2]
     *      R.uniq([1, '1']);     //=> [1, '1']
     *      R.uniq([[42], [42]]); //=> [[42]]
     */
    var uniq = uniqWith(equals);

    /**
     * Returns a new list by pulling every item at the first level of nesting out, and putting
     * them in a new array.
     *
     * @func
     * @memberOf R
     * @category List
     * @sig [a] -> [b]
     * @param {Array} list The array to consider.
     * @return {Array} The flattened list.
     * @see R.flatten
     * @example
     *
     *      R.unnest([1, [2], [[3]]]); //=> [1, 2, [3]]
     *      R.unnest([[1, 2], [3, 4], [5, 6]]); //=> [1, 2, 3, 4, 5, 6]
     */
    var unnest = _curry1(_makeFlat(false));

    /**
     * Accepts a function `fn` and any number of transformer functions and returns a new
     * function. When the new function is invoked, it calls the function `fn` with parameters
     * consisting of the result of calling each supplied handler on successive arguments to the
     * new function.
     *
     * If more arguments are passed to the returned function than transformer functions, those
     * arguments are passed directly to `fn` as additional parameters. If you expect additional
     * arguments that don't need to be transformed, although you can ignore them, it's best to
     * pass an identity function so that the new function reports the correct arity.
     *
     * @func
     * @memberOf R
     * @category Function
     * @sig (x1 -> x2 -> ... -> z) -> ((a -> x1), (b -> x2), ...) -> (a -> b -> ... -> z)
     * @param {Function} fn The function to wrap.
     * @param {...Function} transformers A variable number of transformer functions
     * @return {Function} The wrapped function.
     * @example
     *
     *      var double = function(y) { return y * 2; };
     *      var square = function(x) { return x * x; };
     *      var add = function(a, b) { return a + b; };
     *      // Adds any number of arguments together
     *      var addAll = function() {
     *        return R.reduce(add, 0, arguments);
     *      };
     *
     *      // Basic example
     *      var addDoubleAndSquare = R.useWith(addAll, double, square);
     *
     *      //≅ addAll(double(10), square(5));
     *      addDoubleAndSquare(10, 5); //=> 45
     *
     *      // Example of passing more arguments than transformers
     *      //≅ addAll(double(10), square(5), 100);
     *      addDoubleAndSquare(10, 5, 100); //=> 145
     *
     *      // If there are extra _expected_ arguments that don't need to be transformed, although
     *      // you can ignore them, it might be best to pass in the identity function so that the new
     *      // function correctly reports arity.
     *      var addDoubleAndSquareWithExtraParams = R.useWith(addAll, double, square, R.identity);
     *      // addDoubleAndSquareWithExtraParams.length //=> 3
     *      //≅ addAll(double(10), square(5), R.identity(100));
     *      addDoubleAndSquare(10, 5, 100); //=> 145
     */
    /*, transformers */
    var useWith = curry(function useWith(fn) {
        var transformers = _slice(arguments, 1);
        var tlen = transformers.length;
        return curry(_arity(tlen, function () {
            var args = [], idx = 0;
            while (idx < tlen) {
                args[idx] = transformers[idx](arguments[idx]);
                idx += 1;
            }
            return fn.apply(this, args.concat(_slice(arguments, tlen)));
        }));
    });

    /**
     * Takes a spec object and a test object; returns true if the test satisfies
     * the spec, false otherwise. An object satisfies the spec if, for each of the
     * spec's own properties, accessing that property of the object gives the same
     * value (in `R.equals` terms) as accessing that property of the spec.
     *
     * `whereEq` is a specialization of [`where`](#where).
     *
     * @func
     * @memberOf R
     * @category Object
     * @sig {String: *} -> {String: *} -> Boolean
     * @param {Object} spec
     * @param {Object} testObj
     * @return {Boolean}
     * @see R.where
     * @example
     *
     *      // pred :: Object -> Boolean
     *      var pred = R.whereEq({a: 1, b: 2});
     *
     *      pred({a: 1});              //=> false
     *      pred({a: 1, b: 2});        //=> true
     *      pred({a: 1, b: 2, c: 3});  //=> true
     *      pred({a: 1, b: 1});        //=> false
     */
    var whereEq = _curry2(function whereEq(spec, testObj) {
        return where(mapObj(equals, spec), testObj);
    });

    var _flatCat = function () {
        var preservingReduced = function (xf) {
            return {
                '@@transducer/init': _xfBase.init,
                '@@transducer/result': function (result) {
                    return xf['@@transducer/result'](result);
                },
                '@@transducer/step': function (result, input) {
                    var ret = xf['@@transducer/step'](result, input);
                    return ret['@@transducer/reduced'] ? _forceReduced(ret) : ret;
                }
            };
        };
        return function _xcat(xf) {
            var rxf = preservingReduced(xf);
            return {
                '@@transducer/init': _xfBase.init,
                '@@transducer/result': function (result) {
                    return rxf['@@transducer/result'](result);
                },
                '@@transducer/step': function (result, input) {
                    return !isArrayLike(input) ? _reduce(rxf, result, [input]) : _reduce(rxf, result, input);
                }
            };
        };
    }();

    var _indexOf = function _indexOf(list, item, from) {
        var idx = from;
        while (idx < list.length) {
            if (equals(list[idx], item)) {
                return idx;
            }
            idx += 1;
        }
        return -1;
    };

    /**
     * Create a predicate wrapper which will call a pick function (all/any) for each predicate
     *
     * @private
     * @see R.all
     * @see R.any
     */
    // Call function immediately if given arguments
    // Return a function which will call the predicates with the provided arguments
    var _predicateWrap = function _predicateWrap(predPicker) {
        return function (preds) {
            var predIterator = function () {
                var args = arguments;
                return predPicker(function (predicate) {
                    return predicate.apply(null, args);
                }, preds);
            };
            return arguments.length > 1 ? // Call function immediately if given arguments
            predIterator.apply(null, _slice(arguments, 1)) : // Return a function which will call the predicates with the provided arguments
            _arity(Math.max.apply(Math, pluck('length', preds)), predIterator);
        };
    };

    var _xchain = _curry2(function _xchain(f, xf) {
        return map(f, _flatCat(xf));
    });

    /**
     * Given a list of predicates, returns a new predicate that will be true exactly when all of them are.
     *
     * @func
     * @memberOf R
     * @category Logic
     * @sig [(*... -> Boolean)] -> (*... -> Boolean)
     * @param {Array} list An array of predicate functions
     * @param {*} optional Any arguments to pass into the predicates
     * @return {Function} a function that applies its arguments to each of
     *         the predicates, returning `true` if all are satisfied.
     * @see R.anyPass
     * @example
     *
     *      var gt10 = function(x) { return x > 10; };
     *      var even = function(x) { return x % 2 === 0};
     *      var f = R.allPass([gt10, even]);
     *      f(11); //=> false
     *      f(12); //=> true
     */
    var allPass = _curry1(_predicateWrap(all));

    /**
     * Given a list of predicates returns a new predicate that will be true exactly when any one of them is.
     *
     * @func
     * @memberOf R
     * @category Logic
     * @sig [(*... -> Boolean)] -> (*... -> Boolean)
     * @param {Array} list An array of predicate functions
     * @param {*} optional Any arguments to pass into the predicates
     * @return {Function} A function that applies its arguments to each of the predicates, returning
     *         `true` if all are satisfied.
     * @see R.allPass
     * @example
     *
     *      var gt10 = function(x) { return x > 10; };
     *      var even = function(x) { return x % 2 === 0};
     *      var f = R.anyPass([gt10, even]);
     *      f(11); //=> true
     *      f(8); //=> true
     *      f(9); //=> false
     */
    var anyPass = _curry1(_predicateWrap(any));

    /**
     * ap applies a list of functions to a list of values.
     *
     * @func
     * @memberOf R
     * @category Function
     * @sig [f] -> [a] -> [f a]
     * @param {Array} fns An array of functions
     * @param {Array} vs An array of values
     * @return {Array} An array of results of applying each of `fns` to all of `vs` in turn.
     * @example
     *
     *      R.ap([R.multiply(2), R.add(3)], [1,2,3]); //=> [2, 4, 6, 4, 5, 6]
     */
    var ap = _curry2(function ap(fns, vs) {
        return _hasMethod('ap', fns) ? fns.ap(vs) : _reduce(function (acc, fn) {
            return _concat(acc, map(fn, vs));
        }, [], fns);
    });

    /**
     * Returns the result of calling its first argument with the remaining
     * arguments. This is occasionally useful as a converging function for
     * `R.converge`: the left branch can produce a function while the right
     * branch produces a value to be passed to that function as an argument.
     *
     * @func
     * @memberOf R
     * @category Function
     * @sig (*... -> a),*... -> a
     * @param {Function} fn The function to apply to the remaining arguments.
     * @param {...*} args Any number of positional arguments.
     * @return {*}
     * @see R.apply
     * @example
     *
     *      var indentN = R.pipe(R.times(R.always(' ')),
     *                           R.join(''),
     *                           R.replace(/^(?!$)/gm));
     *
     *      var format = R.converge(R.call,
     *                              R.pipe(R.prop('indent'), indentN),
     *                              R.prop('value'));
     *
     *      format({indent: 2, value: 'foo\nbar\nbaz\n'}); //=> '  foo\n  bar\n  baz\n'
     */
    var call = curry(function call(fn) {
        return fn.apply(this, _slice(arguments, 1));
    });

    /**
     * `chain` maps a function over a list and concatenates the results.
     * This implementation is compatible with the
     * Fantasy-land Chain spec, and will work with types that implement that spec.
     * `chain` is also known as `flatMap` in some libraries
     *
     * @func
     * @memberOf R
     * @category List
     * @sig (a -> [b]) -> [a] -> [b]
     * @param {Function} fn
     * @param {Array} list
     * @return {Array}
     * @example
     *
     *      var duplicate = function(n) {
     *        return [n, n];
     *      };
     *      R.chain(duplicate, [1, 2, 3]); //=> [1, 1, 2, 2, 3, 3]
     */
    var chain = _curry2(_dispatchable('chain', _xchain, function chain(fn, list) {
        return unnest(map(fn, list));
    }));

    /**
     * Turns a list of Functors into a Functor of a list, applying
     * a mapping function to the elements of the list along the way.
     *
     * @func
     * @memberOf R
     * @category List
     * @see R.commute
     * @sig Functor f => (f a -> f b) -> (x -> f x) -> [f a] -> f [b]
     * @param {Function} fn The transformation function
     * @param {Function} of A function that returns the data type to return
     * @param {Array} list An array of functors of the same type
     * @return {*}
     * @example
     *
     *      R.commuteMap(R.map(R.add(10)), R.of, [[1], [2, 3]]);   //=> [[11, 12], [11, 13]]
     *      R.commuteMap(R.map(R.add(10)), R.of, [[1, 2], [3]]);   //=> [[11, 13], [12, 13]]
     *      R.commuteMap(R.map(R.add(10)), R.of, [[1], [2], [3]]); //=> [[11, 12, 13]]
     *      R.commuteMap(R.map(R.add(10)), Maybe.of, [Just(1), Just(2), Just(3)]);   //=> Just([11, 12, 13])
     *      R.commuteMap(R.map(R.add(10)), Maybe.of, [Just(1), Just(2), Nothing()]); //=> Nothing()
     */
    var commuteMap = _curry3(function commuteMap(fn, of, list) {
        function consF(acc, ftor) {
            return ap(map(append, fn(ftor)), acc);
        }
        return _reduce(consF, of([]), list);
    });

    /**
     * Wraps a constructor function inside a curried function that can be called with the same
     * arguments and returns the same type. The arity of the function returned is specified
     * to allow using variadic constructor functions.
     *
     * @func
     * @memberOf R
     * @category Function
     * @sig Number -> (* -> {*}) -> (* -> {*})
     * @param {Number} n The arity of the constructor function.
     * @param {Function} Fn The constructor function to wrap.
     * @return {Function} A wrapped, curried constructor function.
     * @example
     *
     *      // Variadic constructor function
     *      var Widget = function() {
     *        this.children = Array.prototype.slice.call(arguments);
     *        // ...
     *      };
     *      Widget.prototype = {
     *        // ...
     *      };
     *      var allConfigs = [
     *        // ...
     *      ];
     *      R.map(R.constructN(1, Widget), allConfigs); // a list of Widgets
     */
    var constructN = _curry2(function constructN(n, Fn) {
        if (n > 10) {
            throw new Error('Constructor with greater than ten arguments');
        }
        if (n === 0) {
            return function () {
                return new Fn();
            };
        }
        return curry(nAry(n, function ($0, $1, $2, $3, $4, $5, $6, $7, $8, $9) {
            switch (arguments.length) {
            case 1:
                return new Fn($0);
            case 2:
                return new Fn($0, $1);
            case 3:
                return new Fn($0, $1, $2);
            case 4:
                return new Fn($0, $1, $2, $3);
            case 5:
                return new Fn($0, $1, $2, $3, $4);
            case 6:
                return new Fn($0, $1, $2, $3, $4, $5);
            case 7:
                return new Fn($0, $1, $2, $3, $4, $5, $6);
            case 8:
                return new Fn($0, $1, $2, $3, $4, $5, $6, $7);
            case 9:
                return new Fn($0, $1, $2, $3, $4, $5, $6, $7, $8);
            case 10:
                return new Fn($0, $1, $2, $3, $4, $5, $6, $7, $8, $9);
            }
        }));
    });

    /**
     * Accepts at least three functions and returns a new function. When invoked, this new
     * function will invoke the first function, `after`, passing as its arguments the
     * results of invoking the subsequent functions with whatever arguments are passed to
     * the new function.
     *
     * @func
     * @memberOf R
     * @category Function
     * @sig (x1 -> x2 -> ... -> z) -> ((a -> b -> ... -> x1), (a -> b -> ... -> x2), ...) -> (a -> b -> ... -> z)
     * @param {Function} after A function. `after` will be invoked with the return values of
     *        `fn1` and `fn2` as its arguments.
     * @param {...Function} functions A variable number of functions.
     * @return {Function} A new function.
     * @example
     *
     *      var add = function(a, b) { return a + b; };
     *      var multiply = function(a, b) { return a * b; };
     *      var subtract = function(a, b) { return a - b; };
     *
     *      //≅ multiply( add(1, 2), subtract(1, 2) );
     *      R.converge(multiply, add, subtract)(1, 2); //=> -3
     *
     *      var add3 = function(a, b, c) { return a + b + c; };
     *      R.converge(add3, multiply, add, subtract)(1, 2); //=> 4
     */
    var converge = curryN(3, function converge(after) {
        var fns = _slice(arguments, 1);
        return curryN(Math.max.apply(Math, pluck('length', fns)), function () {
            var args = arguments;
            var context = this;
            return after.apply(context, _map(function (fn) {
                return fn.apply(context, args);
            }, fns));
        });
    });

    /**
     * Returns all but the first `n` elements of the given list, string, or
     * transducer/transformer (or object with a `drop` method).
     *
     * @func
     * @memberOf R
     * @category List
     * @see R.transduce
     * @sig Number -> [a] -> [a]
     * @sig Number -> String -> String
     * @param {Number} n
     * @param {*} list
     * @return {*}
     * @see R.take
     * @example
     *
     *      R.drop(1, ['foo', 'bar', 'baz']); //=> ['bar', 'baz']
     *      R.drop(2, ['foo', 'bar', 'baz']); //=> ['baz']
     *      R.drop(3, ['foo', 'bar', 'baz']); //=> []
     *      R.drop(4, ['foo', 'bar', 'baz']); //=> []
     *      R.drop(3, 'ramda');               //=> 'da'
     */
    var drop = _curry2(_dispatchable('drop', _xdrop, function drop(n, xs) {
        return slice(Math.max(0, n), Infinity, xs);
    }));

    /**
     * Returns a list containing all but the last `n` elements of the given `list`.
     *
     * @func
     * @memberOf R
     * @category List
     * @sig Number -> [a] -> [a]
     * @sig Number -> String -> String
     * @param {Number} n The number of elements of `xs` to skip.
     * @param {Array} xs The collection to consider.
     * @return {Array}
     * @see R.takeLast
     * @example
     *
     *      R.dropLast(1, ['foo', 'bar', 'baz']); //=> ['foo', 'bar']
     *      R.dropLast(2, ['foo', 'bar', 'baz']); //=> ['foo']
     *      R.dropLast(3, ['foo', 'bar', 'baz']); //=> []
     *      R.dropLast(4, ['foo', 'bar', 'baz']); //=> []
     *      R.dropLast(3, 'ramda');               //=> 'ra'
     */
    var dropLast = _curry2(function dropLast(n, xs) {
        return take(n < xs.length ? xs.length - n : 0, xs);
    });

    /**
     * Returns a new list without any consecutively repeating elements. Equality is
     * determined by applying the supplied predicate two consecutive elements.
     * The first element in a series of equal element is the one being preserved.
     *
     * Acts as a transducer if a transformer is given in list position.
     * @see R.transduce
     *
     * @func
     * @memberOf R
     * @category List
     * @sig (a, a -> Boolean) -> [a] -> [a]
     * @param {Function} pred A predicate used to test whether two items are equal.
     * @param {Array} list The array to consider.
     * @return {Array} `list` without repeating elements.
     * @example
     *
     *      function lengthEq(x, y) { return Math.abs(x) === Math.abs(y); };
     *      var l = [1, -1, 1, 3, 4, -4, -4, -5, 5, 3, 3];
     *      R.dropRepeatsWith(lengthEq, l); //=> [1, 3, 4, -5, 3]
     */
    var dropRepeatsWith = _curry2(_dispatchable('dropRepeatsWith', _xdropRepeatsWith, function dropRepeatsWith(pred, list) {
        var result = [];
        var idx = 1;
        var len = list.length;
        if (len !== 0) {
            result[0] = list[0];
            while (idx < len) {
                if (!pred(last(result), list[idx])) {
                    result[result.length] = list[idx];
                }
                idx += 1;
            }
        }
        return result;
    }));

    /**
     * Reports whether two objects have the same value, in `R.equals` terms,
     * for the specified property. Useful as a curried predicate.
     *
     * @func
     * @memberOf R
     * @category Object
     * @sig k -> {k: v} -> {k: v} -> Boolean
     * @param {String} prop The name of the property to compare
     * @param {Object} obj1
     * @param {Object} obj2
     * @return {Boolean}
     *
     * @example
     *
     *      var o1 = { a: 1, b: 2, c: 3, d: 4 };
     *      var o2 = { a: 10, b: 20, c: 3, d: 40 };
     *      R.eqProps('a', o1, o2); //=> false
     *      R.eqProps('c', o1, o2); //=> true
     */
    var eqProps = _curry3(function eqProps(prop, obj1, obj2) {
        return equals(obj1[prop], obj2[prop]);
    });

    /**
     * Returns the position of the first occurrence of an item in an array,
     * or -1 if the item is not included in the array. `R.equals` is used to
     * determine equality.
     *
     * @func
     * @memberOf R
     * @category List
     * @sig a -> [a] -> Number
     * @param {*} target The item to find.
     * @param {Array} xs The array to search in.
     * @return {Number} the index of the target, or -1 if the target is not found.
     * @see R.lastIndexOf
     * @example
     *
     *      R.indexOf(3, [1,2,3,4]); //=> 2
     *      R.indexOf(10, [1,2,3,4]); //=> -1
     */
    var indexOf = _curry2(function indexOf(target, xs) {
        return _hasMethod('indexOf', xs) ? xs.indexOf(target) : _indexOf(xs, target, 0);
    });

    /**
     * Returns all but the last element of the given list or string.
     *
     * @func
     * @memberOf R
     * @category List
     * @see R.last, R.head, R.tail
     * @sig [a] -> [a]
     * @sig String -> String
     * @param {*} list
     * @return {*}
     * @example
     *
     *      R.init([1, 2, 3]);  //=> [1, 2]
     *      R.init([1, 2]);     //=> [1]
     *      R.init([1]);        //=> []
     *      R.init([]);         //=> []
     *
     *      R.init('abc');  //=> 'ab'
     *      R.init('ab');   //=> 'a'
     *      R.init('a');    //=> ''
     *      R.init('');     //=> ''
     */
    var init = slice(0, -1);

    /**
     * Returns `true` if all elements are unique, in `R.equals` terms,
     * otherwise `false`.
     *
     * @func
     * @memberOf R
     * @category List
     * @sig [a] -> Boolean
     * @param {Array} list The array to consider.
     * @return {Boolean} `true` if all elements are unique, else `false`.
     * @example
     *
     *      R.isSet(['1', 1]); //=> true
     *      R.isSet([1, 1]);   //=> false
     *      R.isSet([[42], [42]]); //=> false
     */
    var isSet = _curry1(function isSet(list) {
        var len = list.length;
        var idx = 0;
        while (idx < len) {
            if (_indexOf(list, list[idx], idx + 1) >= 0) {
                return false;
            }
            idx += 1;
        }
        return true;
    });

    /**
     * Returns a lens for the given getter and setter functions. The getter "gets"
     * the value of the focus; the setter "sets" the value of the focus. The setter
     * should not mutate the data structure.
     *
     * @func
     * @memberOf R
     * @category Object
     * @typedef Lens s a = Functor f => (a -> f a) -> s -> f s
     * @sig (s -> a) -> ((a, s) -> s) -> Lens s a
     * @param {Function} getter
     * @param {Function} setter
     * @return {Lens}
     * @see R.view, R.set, R.over, R.lensIndex, R.lensProp
     * @example
     *
     *      var xLens = R.lens(R.prop('x'), R.assoc('x'));
     *
     *      R.view(xLens, {x: 1, y: 2});            //=> 1
     *      R.set(xLens, 4, {x: 1, y: 2});          //=> {x: 4, y: 2}
     *      R.over(xLens, R.negate, {x: 1, y: 2});  //=> {x: -1, y: 2}
     */
    var lens = _curry2(function lens(getter, setter) {
        return function (f) {
            return function (s) {
                return map(function (v) {
                    return setter(v, s);
                }, f(getter(s)));
            };
        };
    });

    /**
     * Returns a lens whose focus is the specified index.
     *
     * @func
     * @memberOf R
     * @category Object
     * @typedef Lens s a = Functor f => (a -> f a) -> s -> f s
     * @sig Number -> Lens s a
     * @param {Number} n
     * @return {Lens}
     * @see R.view, R.set, R.over
     * @example
     *
     *      var headLens = R.lensIndex(0);
     *
     *      R.view(headLens, ['a', 'b', 'c']);            //=> 'a'
     *      R.set(headLens, 'x', ['a', 'b', 'c']);        //=> ['x', 'b', 'c']
     *      R.over(headLens, R.toUpper, ['a', 'b', 'c']); //=> ['A', 'b', 'c']
     */
    var lensIndex = _curry1(function lensIndex(n) {
        return lens(nth(n), update(n));
    });

    /**
     * Returns a lens whose focus is the specified property.
     *
     * @func
     * @memberOf R
     * @category Object
     * @typedef Lens s a = Functor f => (a -> f a) -> s -> f s
     * @sig String -> Lens s a
     * @param {String} k
     * @return {Lens}
     * @see R.view, R.set, R.over
     * @example
     *
     *      var xLens = R.lensProp('x');
     *
     *      R.view(xLens, {x: 1, y: 2});            //=> 1
     *      R.set(xLens, 4, {x: 1, y: 2});          //=> {x: 4, y: 2}
     *      R.over(xLens, R.negate, {x: 1, y: 2});  //=> {x: -1, y: 2}
     */
    var lensProp = _curry1(function lensProp(k) {
        return lens(prop(k), assoc(k));
    });

    /**
     * "lifts" a function to be the specified arity, so that it may "map over" that many
     * lists (or other Functors).
     *
     * @func
     * @memberOf R
     * @see R.lift
     * @category Function
     * @sig Number -> (*... -> *) -> ([*]... -> [*])
     * @param {Function} fn The function to lift into higher context
     * @return {Function} The function `fn` applicable to mappable objects.
     * @example
     *
     *      var madd3 = R.liftN(3, R.curryN(3, function() {
     *        return R.reduce(R.add, 0, arguments);
     *      }));
     *      madd3([1,2,3], [1,2,3], [1]); //=> [3, 4, 5, 4, 5, 6, 5, 6, 7]
     */
    var liftN = _curry2(function liftN(arity, fn) {
        var lifted = curryN(arity, fn);
        return curryN(arity, function () {
            return _reduce(ap, map(lifted, arguments[0]), _slice(arguments, 1));
        });
    });

    /**
     * Returns the mean of the given list of numbers.
     *
     * @func
     * @memberOf R
     * @category Math
     * @sig [Number] -> Number
     * @param {Array} list
     * @return {Number}
     * @example
     *
     *      R.mean([2, 7, 9]); //=> 6
     *      R.mean([]); //=> NaN
     */
    var mean = _curry1(function mean(list) {
        return sum(list) / list.length;
    });

    /**
     * Returns the median of the given list of numbers.
     *
     * @func
     * @memberOf R
     * @category Math
     * @sig [Number] -> Number
     * @param {Array} list
     * @return {Number}
     * @example
     *
     *      R.median([2, 9, 7]); //=> 7
     *      R.median([7, 2, 10, 9]); //=> 8
     *      R.median([]); //=> NaN
     */
    var median = _curry1(function median(list) {
        var len = list.length;
        if (len === 0) {
            return NaN;
        }
        var width = 2 - len % 2;
        var idx = (len - width) / 2;
        return mean(_slice(list).sort(function (a, b) {
            return a < b ? -1 : a > b ? 1 : 0;
        }).slice(idx, idx + width));
    });

    /**
     * Merges a list of objects together into one object.
     *
     * @func
     * @memberOf R
     * @category List
     * @sig [{k: v}] -> {k: v}
     * @param {Array} list An array of objects
     * @return {Object} A merged object.
     * @see R.reduce
     * @example
     *
     *      R.mergeAll([{foo:1},{bar:2},{baz:3}]); //=> {foo:1,bar:2,baz:3}
     *      R.mergeAll([{foo:1},{foo:2},{bar:2}]); //=> {foo:2,bar:2}
     */
    var mergeAll = _curry1(function mergeAll(list) {
        return reduce(merge, {}, list);
    });

    /**
     * Performs left-to-right function composition. The leftmost function may have
     * any arity; the remaining functions must be unary.
     *
     * In some libraries this function is named `sequence`.
     *
     * @func
     * @memberOf R
     * @category Function
     * @sig (((a, b, ..., n) -> o), (o -> p), ..., (x -> y), (y -> z)) -> (a -> b -> ... -> n -> z)
     * @param {...Function} functions
     * @return {Function}
     * @see R.compose
     * @example
     *
     *      var f = R.pipe(Math.pow, R.negate, R.inc);
     *
     *      f(3, 4); // -(3^4) + 1
     */
    var pipe = function pipe() {
        if (arguments.length === 0) {
            throw new Error('pipe requires at least one argument');
        }
        return curryN(arguments[0].length, reduce(_pipe, arguments[0], tail(arguments)));
    };

    /**
     * Performs left-to-right composition of one or more Promise-returning
     * functions. The leftmost function may have any arity; the remaining
     * functions must be unary.
     *
     * @func
     * @memberOf R
     * @category Function
     * @sig ((a -> Promise b), (b -> Promise c), ..., (y -> Promise z)) -> (a -> Promise z)
     * @param {...Function} functions
     * @return {Function}
     * @see R.composeP
     * @example
     *
     *      //  followersForUser :: String -> Promise [User]
     *      var followersForUser = R.pipeP(db.getUserById, db.getFollowers);
     */
    var pipeP = function pipeP() {
        if (arguments.length === 0) {
            throw new Error('pipeP requires at least one argument');
        }
        return curryN(arguments[0].length, reduce(_pipeP, arguments[0], tail(arguments)));
    };

    /**
     * Multiplies together all the elements of a list.
     *
     * @func
     * @memberOf R
     * @category Math
     * @sig [Number] -> Number
     * @param {Array} list An array of numbers
     * @return {Number} The product of all the numbers in the list.
     * @see R.reduce
     * @example
     *
     *      R.product([2,4,6,8,100,1]); //=> 38400
     */
    var product = reduce(multiply, 1);

    /**
     * Reasonable analog to SQL `select` statement.
     *
     * @func
     * @memberOf R
     * @category Object
     * @category Relation
     * @sig [k] -> [{k: v}] -> [{k: v}]
     * @param {Array} props The property names to project
     * @param {Array} objs The objects to query
     * @return {Array} An array of objects with just the `props` properties.
     * @example
     *
     *      var abby = {name: 'Abby', age: 7, hair: 'blond', grade: 2};
     *      var fred = {name: 'Fred', age: 12, hair: 'brown', grade: 7};
     *      var kids = [abby, fred];
     *      R.project(['name', 'grade'], kids); //=> [{name: 'Abby', grade: 2}, {name: 'Fred', grade: 7}]
     */
    // passing `identity` gives correct arity
    var project = useWith(_map, pickAll, identity);

    /**
     * Returns a new list containing the last `n` elements of the given list.
     * If `n > list.length`, returns a list of `list.length` elements.
     *
     * @func
     * @memberOf R
     * @category List
     * @sig Number -> [a] -> [a]
     * @sig Number -> String -> String
     * @param {Number} n The number of elements to return.
     * @param {Array} xs The collection to consider.
     * @return {Array}
     * @see R.dropLast
     * @example
     *
     *      R.takeLast(1, ['foo', 'bar', 'baz']); //=> ['baz']
     *      R.takeLast(2, ['foo', 'bar', 'baz']); //=> ['for', 'baz']
     *      R.takeLast(3, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
     *      R.takeLast(4, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
     *      R.takeLast(3, 'ramda');               //=> 'mda'
     */
    var takeLast = _curry2(function takeLast(n, xs) {
        return drop(n >= 0 ? xs.length - n : 0, xs);
    });

    var _contains = function _contains(a, list) {
        return _indexOf(list, a, 0) >= 0;
    };

    //  mapPairs :: (Object, [String]) -> [String]
    // Function, RegExp, user-defined types
    var _toString = function _toString(x, seen) {
        var recur = function recur(y) {
            var xs = seen.concat([x]);
            return _contains(y, xs) ? '<Circular>' : _toString(y, xs);
        };
        //  mapPairs :: (Object, [String]) -> [String]
        var mapPairs = function (obj, keys) {
            return _map(function (k) {
                return _quote(k) + ': ' + recur(obj[k]);
            }, keys.slice().sort());
        };
        switch (Object.prototype.toString.call(x)) {
        case '[object Arguments]':
            return '(function() { return arguments; }(' + _map(recur, x).join(', ') + '))';
        case '[object Array]':
            return '[' + _map(recur, x).concat(mapPairs(x, reject(test(/^\d+$/), keys(x)))).join(', ') + ']';
        case '[object Boolean]':
            return typeof x === 'object' ? 'new Boolean(' + recur(x.valueOf()) + ')' : x.toString();
        case '[object Date]':
            return 'new Date(' + _quote(_toISOString(x)) + ')';
        case '[object Null]':
            return 'null';
        case '[object Number]':
            return typeof x === 'object' ? 'new Number(' + recur(x.valueOf()) + ')' : 1 / x === -Infinity ? '-0' : x.toString(10);
        case '[object String]':
            return typeof x === 'object' ? 'new String(' + recur(x.valueOf()) + ')' : _quote(x);
        case '[object Undefined]':
            return 'undefined';
        default:
            return typeof x.constructor === 'function' && x.constructor.name !== 'Object' && typeof x.toString === 'function' && x.toString() !== '[object Object]' ? x.toString() : // Function, RegExp, user-defined types
            '{' + mapPairs(x, keys(x)).join(', ') + '}';
        }
    };

    /**
     * Turns a list of Functors into a Functor of a list.
     *
     * @func
     * @memberOf R
     * @category List
     * @see R.commuteMap
     * @sig Functor f => (x -> f x) -> [f a] -> f [a]
     * @param {Function} of A function that returns the data type to return
     * @param {Array} list An array of functors of the same type
     * @return {*}
     * @example
     *
     *      R.commute(R.of, [[1], [2, 3]]);   //=> [[1, 2], [1, 3]]
     *      R.commute(R.of, [[1, 2], [3]]);   //=> [[1, 3], [2, 3]]
     *      R.commute(R.of, [[1], [2], [3]]); //=> [[1, 2, 3]]
     *      R.commute(Maybe.of, [Just(1), Just(2), Just(3)]);   //=> Just([1, 2, 3])
     *      R.commute(Maybe.of, [Just(1), Just(2), Nothing()]); //=> Nothing()
     */
    var commute = commuteMap(identity);

    /**
     * Performs right-to-left function composition. The rightmost function may have
     * any arity; the remaining functions must be unary.
     *
     * @func
     * @memberOf R
     * @category Function
     * @sig ((y -> z), (x -> y), ..., (o -> p), ((a, b, ..., n) -> o)) -> (a -> b -> ... -> n -> z)
     * @param {...Function} functions
     * @return {Function}
     * @see R.pipe
     * @example
     *
     *      var f = R.compose(R.inc, R.negate, Math.pow);
     *
     *      f(3, 4); // -(3^4) + 1
     */
    var compose = function compose() {
        if (arguments.length === 0) {
            throw new Error('compose requires at least one argument');
        }
        return pipe.apply(this, reverse(arguments));
    };

    /**
     * Returns the right-to-left Kleisli composition of the provided functions,
     * each of which must return a value of a type supported by [`chain`](#chain).
     *
     * `R.composeK(h, g, f)` is equivalent to `R.compose(R.chain(h), R.chain(g), R.chain(f))`.
     *
     * @func
     * @memberOf R
     * @category Function
     * @see R.pipeK
     * @sig Chain m => ((y -> m z), (x -> m y), ..., (a -> m b)) -> (m a -> m z)
     * @param {...Function}
     * @return {Function}
     * @example
     *
     *      //  parseJson :: String -> Maybe *
     *      //  get :: String -> Object -> Maybe *
     *
     *      //  getStateCode :: Maybe String -> Maybe String
     *      var getStateCode = R.composeK(
     *        R.compose(Maybe.of, R.toUpper),
     *        get('state'),
     *        get('address'),
     *        get('user'),
     *        parseJson
     *      );
     *
     *      getStateCode(Maybe.of('{"user":{"address":{"state":"ny"}}}'));
     *      //=> Just('NY')
     *      getStateCode(Maybe.of('[Invalid JSON]'));
     *      //=> Nothing()
     */
    var composeK = function composeK() {
        return arguments.length === 0 ? identity : compose.apply(this, map(chain, arguments));
    };

    /**
     * Performs right-to-left composition of one or more Promise-returning
     * functions. The rightmost function may have any arity; the remaining
     * functions must be unary.
     *
     * @func
     * @memberOf R
     * @category Function
     * @sig ((y -> Promise z), (x -> Promise y), ..., (a -> Promise b)) -> (a -> Promise z)
     * @param {...Function} functions
     * @return {Function}
     * @see R.pipeP
     * @example
     *
     *      //  followersForUser :: String -> Promise [User]
     *      var followersForUser = R.composeP(db.getFollowers, db.getUserById);
     */
    var composeP = function composeP() {
        if (arguments.length === 0) {
            throw new Error('composeP requires at least one argument');
        }
        return pipeP.apply(this, reverse(arguments));
    };

    /**
     * Wraps a constructor function inside a curried function that can be called with the same
     * arguments and returns the same type.
     *
     * @func
     * @memberOf R
     * @category Function
     * @sig (* -> {*}) -> (* -> {*})
     * @param {Function} Fn The constructor function to wrap.
     * @return {Function} A wrapped, curried constructor function.
     * @example
     *
     *      // Constructor function
     *      var Widget = function(config) {
     *        // ...
     *      };
     *      Widget.prototype = {
     *        // ...
     *      };
     *      var allConfigs = [
     *        // ...
     *      ];
     *      R.map(R.construct(Widget), allConfigs); // a list of Widgets
     */
    var construct = _curry1(function construct(Fn) {
        return constructN(Fn.length, Fn);
    });

    /**
     * Returns `true` if the specified value is equal, in `R.equals` terms,
     * to at least one element of the given list; `false` otherwise.
     *
     * @func
     * @memberOf R
     * @category List
     * @sig a -> [a] -> Boolean
     * @param {Object} a The item to compare against.
     * @param {Array} list The array to consider.
     * @return {Boolean} `true` if the item is in the list, `false` otherwise.
     *
     * @example
     *
     *      R.contains(3, [1, 2, 3]); //=> true
     *      R.contains(4, [1, 2, 3]); //=> false
     *      R.contains([42], [[42]]); //=> true
     */
    var contains = _curry2(_contains);

    /**
     * Finds the set (i.e. no duplicates) of all elements in the first list not contained in the second list.
     *
     * @func
     * @memberOf R
     * @category Relation
     * @sig [a] -> [a] -> [a]
     * @param {Array} list1 The first list.
     * @param {Array} list2 The second list.
     * @return {Array} The elements in `list1` that are not in `list2`.
     * @see R.differenceWith
     * @example
     *
     *      R.difference([1,2,3,4], [7,6,5,4,3]); //=> [1,2]
     *      R.difference([7,6,5,4,3], [1,2,3,4]); //=> [7,6,5]
     */
    var difference = _curry2(function difference(first, second) {
        var out = [];
        var idx = 0;
        var firstLen = first.length;
        while (idx < firstLen) {
            if (!_contains(first[idx], second) && !_contains(first[idx], out)) {
                out[out.length] = first[idx];
            }
            idx += 1;
        }
        return out;
    });

    /**
     * Returns a new list without any consecutively repeating elements.
     * `R.equals` is used to determine equality.
     *
     * Acts as a transducer if a transformer is given in list position.
     * @see R.transduce
     *
     * @func
     * @memberOf R
     * @category List
     * @sig [a] -> [a]
     * @param {Array} list The array to consider.
     * @return {Array} `list` without repeating elements.
     * @example
     *
     *     R.dropRepeats([1, 1, 1, 2, 3, 4, 4, 2, 2]); //=> [1, 2, 3, 4, 2]
     */
    var dropRepeats = _curry1(_dispatchable('dropRepeats', _xdropRepeatsWith(equals), dropRepeatsWith(equals)));

    /**
     * Combines two lists into a set (i.e. no duplicates) composed of those elements common to both lists.
     *
     * @func
     * @memberOf R
     * @category Relation
     * @sig [a] -> [a] -> [a]
     * @param {Array} list1 The first list.
     * @param {Array} list2 The second list.
     * @see R.intersectionWith
     * @return {Array} The list of elements found in both `list1` and `list2`.
     * @example
     *
     *      R.intersection([1,2,3,4], [7,6,5,4,3]); //=> [4, 3]
     */
    var intersection = _curry2(function intersection(list1, list2) {
        return uniq(_filter(flip(_contains)(list1), list2));
    });

    /**
     * "lifts" a function of arity > 1 so that it may "map over" an Array or
     * other Functor.
     *
     * @func
     * @memberOf R
     * @see R.liftN
     * @category Function
     * @sig (*... -> *) -> ([*]... -> [*])
     * @param {Function} fn The function to lift into higher context
     * @return {Function} The function `fn` applicable to mappable objects.
     * @example
     *
     *      var madd3 = R.lift(R.curry(function(a, b, c) {
     *        return a + b + c;
     *      }));
     *      madd3([1,2,3], [1,2,3], [1]); //=> [3, 4, 5, 4, 5, 6, 5, 6, 7]
     *
     *      var madd5 = R.lift(R.curry(function(a, b, c, d, e) {
     *        return a + b + c + d + e;
     *      }));
     *      madd5([1,2], [3], [4, 5], [6], [7, 8]); //=> [21, 22, 22, 23, 22, 23, 23, 24]
     */
    var lift = _curry1(function lift(fn) {
        return liftN(fn.length, fn);
    });

    /**
     * Returns a partial copy of an object omitting the keys specified.
     *
     * @func
     * @memberOf R
     * @category Object
     * @sig [String] -> {String: *} -> {String: *}
     * @param {Array} names an array of String property names to omit from the new object
     * @param {Object} obj The object to copy from
     * @return {Object} A new object with properties from `names` not on it.
     * @see R.pick
     * @example
     *
     *      R.omit(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, c: 3}
     */
    var omit = _curry2(function omit(names, obj) {
        var result = {};
        for (var prop in obj) {
            if (!_contains(prop, names)) {
                result[prop] = obj[prop];
            }
        }
        return result;
    });

    /**
     * Returns the left-to-right Kleisli composition of the provided functions,
     * each of which must return a value of a type supported by [`chain`](#chain).
     *
     * `R.pipeK(f, g, h)` is equivalent to `R.pipe(R.chain(f), R.chain(g), R.chain(h))`.
     *
     * @func
     * @memberOf R
     * @category Function
     * @see R.composeK
     * @sig Chain m => ((a -> m b), (b -> m c), ..., (y -> m z)) -> (m a -> m z)
     * @param {...Function}
     * @return {Function}
     * @example
     *
     *      //  parseJson :: String -> Maybe *
     *      //  get :: String -> Object -> Maybe *
     *
     *      //  getStateCode :: Maybe String -> Maybe String
     *      var getStateCode = R.pipeK(
     *        parseJson,
     *        get('user'),
     *        get('address'),
     *        get('state'),
     *        R.compose(Maybe.of, R.toUpper)
     *      );
     *
     *      getStateCode(Maybe.of('{"user":{"address":{"state":"ny"}}}'));
     *      //=> Just('NY')
     *      getStateCode(Maybe.of('[Invalid JSON]'));
     *      //=> Nothing()
     */
    var pipeK = function pipeK() {
        return composeK.apply(this, reverse(arguments));
    };

    /**
     * Returns the string representation of the given value. `eval`'ing the output
     * should result in a value equivalent to the input value. Many of the built-in
     * `toString` methods do not satisfy this requirement.
     *
     * If the given value is an `[object Object]` with a `toString` method other
     * than `Object.prototype.toString`, this method is invoked with no arguments
     * to produce the return value. This means user-defined constructor functions
     * can provide a suitable `toString` method. For example:
     *
     *     function Point(x, y) {
     *       this.x = x;
     *       this.y = y;
     *     }
     *
     *     Point.prototype.toString = function() {
     *       return 'new Point(' + this.x + ', ' + this.y + ')';
     *     };
     *
     *     R.toString(new Point(1, 2)); //=> 'new Point(1, 2)'
     *
     * @func
     * @memberOf R
     * @category String
     * @sig * -> String
     * @param {*} val
     * @return {String}
     * @example
     *
     *      R.toString(42); //=> '42'
     *      R.toString('abc'); //=> '"abc"'
     *      R.toString([1, 2, 3]); //=> '[1, 2, 3]'
     *      R.toString({foo: 1, bar: 2, baz: 3}); //=> '{"bar": 2, "baz": 3, "foo": 1}'
     *      R.toString(new Date('2001-02-03T04:05:06Z')); //=> 'new Date("2001-02-03T04:05:06.000Z")'
     */
    var toString = _curry1(function toString(val) {
        return _toString(val, []);
    });

    /**
     * Combines two lists into a set (i.e. no duplicates) composed of the
     * elements of each list.
     *
     * @func
     * @memberOf R
     * @category Relation
     * @sig [a] -> [a] -> [a]
     * @param {Array} as The first list.
     * @param {Array} bs The second list.
     * @return {Array} The first and second lists concatenated, with
     *         duplicates removed.
     * @example
     *
     *      R.union([1, 2, 3], [2, 3, 4]); //=> [1, 2, 3, 4]
     */
    var union = _curry2(compose(uniq, _concat));

    /**
     * Returns a new list containing only one copy of each element in the
     * original list, based upon the value returned by applying the supplied
     * function to each list element. Prefers the first item if the supplied
     * function produces the same value on two items. `R.equals` is used for
     * comparison.
     *
     * @func
     * @memberOf R
     * @category List
     * @sig (a -> b) -> [a] -> [a]
     * @param {Function} fn A function used to produce a value to use during comparisons.
     * @param {Array} list The array to consider.
     * @return {Array} The list of unique items.
     * @example
     *
     *      R.uniqBy(Math.abs, [-1, -5, 2, 10, 1, 2]); //=> [-1, -5, 2, 10]
     */
    var uniqBy = _curry2(function uniqBy(fn, list) {
        var idx = 0, applied = [], result = [], appliedItem, item;
        while (idx < list.length) {
            item = list[idx];
            appliedItem = fn(item);
            if (!_contains(appliedItem, applied)) {
                result.push(item);
                applied.push(appliedItem);
            }
            idx += 1;
        }
        return result;
    });

    /**
     * Turns a named method with a specified arity into a function
     * that can be called directly supplied with arguments and a target object.
     *
     * The returned function is curried and accepts `arity + 1` parameters where
     * the final parameter is the target object.
     *
     * @func
     * @memberOf R
     * @category Function
     * @sig Number -> String -> (a -> b -> ... -> n -> Object -> *)
     * @param {Number} arity Number of arguments the returned function should take
     *        before the target object.
     * @param {Function} method Name of the method to call.
     * @return {Function} A new curried function.
     * @example
     *
     *      var sliceFrom = R.invoker(1, 'slice');
     *      sliceFrom(6, 'abcdefghijklm'); //=> 'ghijklm'
     *      var sliceFrom6 = R.invoker(2, 'slice')(6);
     *      sliceFrom6(8, 'abcdefghijklm'); //=> 'gh'
     */
    var invoker = _curry2(function invoker(arity, method) {
        return curryN(arity + 1, function () {
            var target = arguments[arity];
            if (target != null && is(Function, target[method])) {
                return target[method].apply(target, _slice(arguments, 0, arity));
            }
            throw new TypeError(toString(target) + ' does not have a method named "' + method + '"');
        });
    });

    /**
     * Returns a string made by inserting the `separator` between each
     * element and concatenating all the elements into a single string.
     *
     * @func
     * @memberOf R
     * @category List
     * @sig String -> [a] -> String
     * @param {Number|String} separator The string used to separate the elements.
     * @param {Array} xs The elements to join into a string.
     * @return {String} str The string made by concatenating `xs` with `separator`.
     * @see R.split
     * @example
     *
     *      var spacer = R.join(' ');
     *      spacer(['a', 2, 3.4]);   //=> 'a 2 3.4'
     *      R.join('|', [1, 2, 3]);    //=> '1|2|3'
     */
    var join = invoker(1, 'join');

    /**
     * Creates a new function that, when invoked, caches the result of calling `fn` for a given
     * argument set and returns the result. Subsequent calls to the memoized `fn` with the same
     * argument set will not result in an additional call to `fn`; instead, the cached result
     * for that set of arguments will be returned.
     *
     * @func
     * @memberOf R
     * @category Function
     * @sig (*... -> a) -> (*... -> a)
     * @param {Function} fn The function to memoize.
     * @return {Function} Memoized version of `fn`.
     * @example
     *
     *      var count = 0;
     *      var factorial = R.memoize(function(n) {
     *        count += 1;
     *        return R.product(R.range(1, n + 1));
     *      });
     *      factorial(5); //=> 120
     *      factorial(5); //=> 120
     *      factorial(5); //=> 120
     *      count; //=> 1
     */
    var memoize = _curry1(function memoize(fn) {
        var cache = {};
        return function () {
            var key = toString(arguments);
            if (!_has(key, cache)) {
                cache[key] = fn.apply(this, arguments);
            }
            return cache[key];
        };
    });

    /**
     * Splits a string into an array of strings based on the given
     * separator.
     *
     * @func
     * @memberOf R
     * @category String
     * @sig String -> String -> [String]
     * @param {String} sep The separator string.
     * @param {String} str The string to separate into an array.
     * @return {Array} The array of strings from `str` separated by `str`.
     * @see R.join
     * @example
     *
     *      var pathComponents = R.split('/');
     *      R.tail(pathComponents('/usr/local/bin/node')); //=> ['usr', 'local', 'bin', 'node']
     *
     *      R.split('.', 'a.b.c.xyz.d'); //=> ['a', 'b', 'c', 'xyz', 'd']
     */
    var split = invoker(1, 'split');

    /**
     * The lower case version of a string.
     *
     * @func
     * @memberOf R
     * @category String
     * @sig String -> String
     * @param {String} str The string to lower case.
     * @return {String} The lower case version of `str`.
     * @see R.toUpper
     * @example
     *
     *      R.toLower('XYZ'); //=> 'xyz'
     */
    var toLower = invoker(0, 'toLowerCase');

    /**
     * The upper case version of a string.
     *
     * @func
     * @memberOf R
     * @category String
     * @sig String -> String
     * @param {String} str The string to upper case.
     * @return {String} The upper case version of `str`.
     * @see R.toLower
     * @example
     *
     *      R.toUpper('abc'); //=> 'ABC'
     */
    var toUpper = invoker(0, 'toUpperCase');

    var R = {
        F: F,
        T: T,
        __: __,
        add: add,
        addIndex: addIndex,
        adjust: adjust,
        all: all,
        allPass: allPass,
        always: always,
        and: and,
        any: any,
        anyPass: anyPass,
        ap: ap,
        aperture: aperture,
        append: append,
        apply: apply,
        assoc: assoc,
        assocPath: assocPath,
        binary: binary,
        bind: bind,
        both: both,
        call: call,
        chain: chain,
        clone: clone,
        commute: commute,
        commuteMap: commuteMap,
        comparator: comparator,
        complement: complement,
        compose: compose,
        composeK: composeK,
        composeP: composeP,
        concat: concat,
        cond: cond,
        construct: construct,
        constructN: constructN,
        contains: contains,
        containsWith: containsWith,
        converge: converge,
        countBy: countBy,
        createMapEntry: createMapEntry,
        curry: curry,
        curryN: curryN,
        dec: dec,
        defaultTo: defaultTo,
        difference: difference,
        differenceWith: differenceWith,
        dissoc: dissoc,
        dissocPath: dissocPath,
        divide: divide,
        drop: drop,
        dropLast: dropLast,
        dropLastWhile: dropLastWhile,
        dropRepeats: dropRepeats,
        dropRepeatsWith: dropRepeatsWith,
        dropWhile: dropWhile,
        either: either,
        empty: empty,
        eqProps: eqProps,
        equals: equals,
        evolve: evolve,
        filter: filter,
        find: find,
        findIndex: findIndex,
        findLast: findLast,
        findLastIndex: findLastIndex,
        flatten: flatten,
        flip: flip,
        forEach: forEach,
        fromPairs: fromPairs,
        functions: functions,
        functionsIn: functionsIn,
        groupBy: groupBy,
        gt: gt,
        gte: gte,
        has: has,
        hasIn: hasIn,
        head: head,
        identical: identical,
        identity: identity,
        ifElse: ifElse,
        inc: inc,
        indexOf: indexOf,
        init: init,
        insert: insert,
        insertAll: insertAll,
        intersection: intersection,
        intersectionWith: intersectionWith,
        intersperse: intersperse,
        into: into,
        invert: invert,
        invertObj: invertObj,
        invoker: invoker,
        is: is,
        isArrayLike: isArrayLike,
        isEmpty: isEmpty,
        isNil: isNil,
        isSet: isSet,
        join: join,
        keys: keys,
        keysIn: keysIn,
        last: last,
        lastIndexOf: lastIndexOf,
        length: length,
        lens: lens,
        lensIndex: lensIndex,
        lensProp: lensProp,
        lift: lift,
        liftN: liftN,
        lt: lt,
        lte: lte,
        map: map,
        mapAccum: mapAccum,
        mapAccumRight: mapAccumRight,
        mapObj: mapObj,
        mapObjIndexed: mapObjIndexed,
        match: match,
        mathMod: mathMod,
        max: max,
        maxBy: maxBy,
        mean: mean,
        median: median,
        memoize: memoize,
        merge: merge,
        mergeAll: mergeAll,
        min: min,
        minBy: minBy,
        modulo: modulo,
        multiply: multiply,
        nAry: nAry,
        negate: negate,
        none: none,
        not: not,
        nth: nth,
        nthArg: nthArg,
        nthChar: nthChar,
        nthCharCode: nthCharCode,
        of: of,
        omit: omit,
        once: once,
        or: or,
        over: over,
        partial: partial,
        partialRight: partialRight,
        partition: partition,
        path: path,
        pathEq: pathEq,
        pick: pick,
        pickAll: pickAll,
        pickBy: pickBy,
        pipe: pipe,
        pipeK: pipeK,
        pipeP: pipeP,
        pluck: pluck,
        prepend: prepend,
        product: product,
        project: project,
        prop: prop,
        propEq: propEq,
        propIs: propIs,
        propOr: propOr,
        propSatisfies: propSatisfies,
        props: props,
        range: range,
        reduce: reduce,
        reduceRight: reduceRight,
        reduced: reduced,
        reject: reject,
        remove: remove,
        repeat: repeat,
        replace: replace,
        reverse: reverse,
        scan: scan,
        set: set,
        slice: slice,
        sort: sort,
        sortBy: sortBy,
        split: split,
        splitEvery: splitEvery,
        subtract: subtract,
        sum: sum,
        tail: tail,
        take: take,
        takeLast: takeLast,
        takeLastWhile: takeLastWhile,
        takeWhile: takeWhile,
        tap: tap,
        test: test,
        times: times,
        toLower: toLower,
        toPairs: toPairs,
        toPairsIn: toPairsIn,
        toString: toString,
        toUpper: toUpper,
        transduce: transduce,
        trim: trim,
        type: type,
        unapply: unapply,
        unary: unary,
        uncurryN: uncurryN,
        unfold: unfold,
        union: union,
        unionWith: unionWith,
        uniq: uniq,
        uniqBy: uniqBy,
        uniqWith: uniqWith,
        unnest: unnest,
        update: update,
        useWith: useWith,
        values: values,
        valuesIn: valuesIn,
        view: view,
        where: where,
        whereEq: whereEq,
        wrap: wrap,
        xprod: xprod,
        zip: zip,
        zipObj: zipObj,
        zipWith: zipWith
    };

  /* TEST_ENTRY_POINT */

  if (typeof exports === 'object') {
    module.exports = R;
  } else if (typeof define === 'function' && define.amd) {
    define(function() { return R; });
  } else {
    this.R = R;
  }

}.call(this));

},{}],684:[function(require,module,exports){
(function(){var g={};
(function(window){var k,aa=this;function p(a,b){var c=a.split("."),d=aa;c[0]in d||!d.execScript||d.execScript("var "+c[0]);for(var e;c.length&&(e=c.shift());)c.length||void 0===b?d[e]?d=d[e]:d=d[e]={}:d[e]=b}function q(a,b){function c(){}c.prototype=b.prototype;a.Yb=b.prototype;a.prototype=new c;a.prototype.constructor=a;a.Xb=function(a,c,f){return b.prototype[c].apply(a,Array.prototype.slice.call(arguments,2))}};/*

 Copyright 2015 Google Inc.

 Licensed under the Apache License, Version 2.0 (the "License");
 you may not use this file except in compliance with the License.
 You may obtain a copy of the License at

     http://www.apache.org/licenses/LICENSE-2.0

 Unless required by applicable law or agreed to in writing, software
 distributed under the License is distributed on an "AS IS" BASIS,
 WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 See the License for the specific language governing permissions and
 limitations under the License.
*/
function ba(){};function ca(a){var b=console[a];b?b.bind||(console[a]=function(){b.apply(console,arguments)}):console[a]=function(){}}ca("error");ca("warn");ca("info");ca("log");ca("debug");function da(a){ea[a]={na:fa(),end:NaN}}function ga(a){if(a=ea[a])a.end=fa()}function ha(a){return(a=ea[a])&&a.end?a.end-a.na:NaN}var fa=window.performance&&window.performance.now?window.performance.now.bind(window.performance):Date.now,ea={};function ia(a,b,c){this.id=a;this.bandwidth=b||0;this.lang=c||"unknown";this.active=!1}p("shaka.player.AudioTrack.compare",function(a,b){return a.lang<b.lang?-1:a.lang>b.lang?1:a.bandwidth<b.bandwidth?-1:a.bandwidth>b.bandwidth?1:0});function ja(){this.minBandwidth=this.maxBandwidth=this.maxWidth=this.minHeight=this.maxHeight=null}ja.prototype.clone=function(){var a=new ja;a.maxHeight=this.maxHeight;a.minHeight=this.minHeight;a.maxWidth=this.maxWidth;a.maxBandwidth=this.maxBandwidth;a.minBandwidth=this.minBandwidth;return a};function r(){this.fontSize="100%";this.fontColor=ka;this.fontOpacity=la;this.backgroundColor=ma;this.backgroundOpacity=la;this.fontEdge=na}p("shaka.player.TextStyle",r);r.prototype.a=function(){var a=window.localStorage.getItem("ShakaPlayerTextStyle");if(a){var b;try{b=JSON.parse(a)}catch(c){return}if(b&&"object"==typeof b){var a=b,d;for(d in a)d in this&&(this[d]=a[d])}}};r.prototype.load=r.prototype.a;r.prototype.b=function(){window.localStorage.setItem("ShakaPlayerTextStyle",JSON.stringify(this))};
r.prototype.store=r.prototype.b;function oa(a){var b=[];b.push("font-size: "+a.fontSize);b.push("color: "+pa(a.fontColor,a.fontOpacity));b.push("background-color: "+pa(a.backgroundColor,a.backgroundOpacity));for(var c=[],d=0;d<a.fontEdge.length;++d){var e=a.fontEdge[d].slice(3,6);c.push(pa(a.fontEdge[d].slice(0,3),a.fontOpacity)+" "+e.join("px ")+"px")}b.push("text-shadow: "+c.join(","));return b.join("; ")}function pa(a,b){return"rgba("+a.concat(b).join(",")+")"}var ka=[255,255,255],ma=[0,0,0];
r.StandardColors={WHITE:ka,BLACK:ma,RED:[255,0,0],GREEN:[0,255,0],BLUE:[0,0,255],YELLOW:[255,255,0],MAGENTA:[255,0,255],CYAN:[0,255,255]};var la=1;r.StandardOpacities={OPAQUE:la,SEMI_HIGH:.75,SEMI_LOW:.25,TRANSPARENT:0};var na=[];
r.EdgeStyles={NONE:na,RAISED:[[34,34,34,1,1,0],[34,34,34,2,2,0],[34,34,34,3,3,0]],DEPRESSED:[[204,204,204,1,1,0],[204,204,204,0,1,0],[34,34,34,-1,-1,0],[34,34,34,0,-1,0]],UNIFORM:[[34,34,34,0,0,4],[34,34,34,0,0,4],[34,34,34,0,0,4],[34,34,34,0,0,4]],DROP:[[34,34,34,2,2,3],[34,34,34,2,2,4],[34,34,34,2,2,5]]};function qa(a,b){this.id=a;this.lang=b||"unknown";this.enabled=this.active=!1}p("shaka.player.TextTrack.compare",function(a,b){return a.lang<b.lang?-1:a.lang>b.lang?1:0});function ra(a,b,c,d){this.id=a;this.bandwidth=b||0;this.width=c||0;this.height=d||0;this.active=!1}function sa(a,b){var c=a.width*a.height,d=b.width*b.height;return c<d?-1:c>d?1:a.bandwidth<b.bandwidth?-1:a.bandwidth>b.bandwidth?1:0}p("shaka.player.VideoTrack.compare",sa);function ta(){var a="CustomEvent"in window;if(a)try{new CustomEvent("")}catch(b){a=!1}a||(window.CustomEvent=ua)}p("shaka.polyfill.CustomEvent.install",ta);function ua(a,b){var c=document.createEvent("CustomEvent"),d=b||{bubbles:!1,cancelable:!1,detail:null};c.initCustomEvent(a,!!d.bubbles,!!d.cancelable,d.detail);return c};function va(){var a=Element.prototype;a.requestFullscreen=a.requestFullscreen||a.mozRequestFullScreen||a.msRequestFullscreen||a.webkitRequestFullscreen;a=Document.prototype;a.exitFullscreen=a.exitFullscreen||a.mozCancelFullScreen||a.msExitFullscreen||a.webkitExitFullscreen;"fullscreenElement"in document||Object.defineProperty(document,"fullscreenElement",{get:function(){return document.mozFullScreenElement||document.msFullscreenElement||document.webkitFullscreenElement}});document.addEventListener("webkitfullscreenchange",
xa);document.addEventListener("webkitfullscreenerror",xa);document.addEventListener("mozfullscreenchange",xa);document.addEventListener("mozfullscreenerror",xa);document.addEventListener("MSFullscreenChange",xa);document.addEventListener("MSFullscreenError",xa)}p("shaka.polyfill.Fullscreen.install",va);function xa(a){var b=a.type.replace(/^(webkit|moz|MS)/,"").toLowerCase(),b=new Event(b,a);a.target.dispatchEvent(b)};function ya(){return Promise.reject(Error("The key system specified is not supported."))}function za(a){return null==a?Promise.resolve():Promise.reject(Error("MediaKeys not supported."))}function Aa(){throw new TypeError("Illegal constructor.");}Aa.prototype.createSession=function(){};Aa.prototype.setServerCertificate=function(){};function Ba(){throw new TypeError("Illegal constructor.");}Ba.prototype.getConfiguration=function(){};Ba.prototype.createMediaKeys=function(){};function u(a){this.c=[];this.b=[];this.ba=Ca;if(a)try{a(this.W.bind(this),this.a.bind(this))}catch(b){this.a(b)}}var Ca=0;function Da(){window.Promise||(window.Promise=u,window.Promise.resolve=Ea,window.Promise.reject=Fa,window.Promise.all=Ga,window.Promise.race=Ha,window.setImmediate?(Ja=function(a){return window.setImmediate(a)},Ka=function(a){return window.clearImmediate(a)}):(Ja=function(a){return window.setTimeout(a,0)},Ka=function(a){return window.clearTimeout(a)}))}
p("shaka.polyfill.Promise.install",Da);function Ea(a){var b=new u;b.W(a);return b}function Fa(a){var b=new u;b.a(a);return b}function Ga(a){function b(a,b,c){a.ba==Ca&&(e[b]=c,d++,d==e.length&&a.W(e))}var c=new u;if(!a.length)return (c.W([]), c);for(var d=0,e=Array(a.length),f=c.a.bind(c),g=0;g<a.length;++g)a[g]&&a[g].then?a[g].then(b.bind(null,c,g),f):b(c,g,a[g]);return c}function Ha(a){for(var b=new u,c=b.W.bind(b),d=b.a.bind(b),e=0;e<a.length;++e)a[e]&&a[e].then?a[e].then(c,d):c(a[e]);return b}
u.prototype.then=function(a,b){var c=new u;switch(this.ba){case 1:La(this,c,a);break;case 2:La(this,c,b);break;case Ca:this.c.push({Ia:c,Ba:a}),this.b.push({Ia:c,Ba:b})}return c};u.prototype.then=u.prototype.then;u.prototype.catch=function(a){return this.then(void 0,a)};u.prototype["catch"]=u.prototype.catch;u.prototype.W=function(a){if(this.ba==Ca){this.wa=a;this.ba=1;for(a=0;a<this.c.length;++a)La(this,this.c[a].Ia,this.c[a].Ba);this.c=[];this.b=[]}};
u.prototype.a=function(a){if(this.ba==Ca){this.wa=a;this.ba=2;for(a=0;a<this.b.length;++a)La(this,this.b[a].Ia,this.b[a].Ba);this.c=[];this.b=[]}};function La(a,b,c){Ma.push(function(){if(c&&"function"==typeof c){try{var a=c(this.wa)}catch(e){b.a(e);return}a instanceof u?a==b?b.a(new TypeError("Chaining cycle detected")):a.then(b.W.bind(b),b.a.bind(b)):b.W(a)}else 1==this.ba?b.W(this.wa):b.a(this.wa)}.bind(a));null==Na&&(Na=Ja(Oa))}
function Oa(){for(;Ma.length;){null!=Na&&(Ka(Na),Na=null);var a=Ma;Ma=[];for(var b=0;b<a.length;++b)a[b]()}}function Ja(){return 0}function Ka(){}var Na=null,Ma=[];function Pa(){var a=HTMLVideoElement.prototype;!a.getVideoPlaybackQuality&&"webkitDroppedFrameCount"in a&&(a.getVideoPlaybackQuality=Qa)}p("shaka.polyfill.VideoPlaybackQuality.install",Pa);function Qa(){return{droppedVideoFrames:this.webkitDroppedFrameCount,totalVideoFrames:this.webkitDecodedFrameCount,corruptedVideoFrames:0,creationTime:NaN,totalFrameDelay:0}};function Ra(a,b){for(var c=[],d=0;d<a.length;++d){for(var e=!1,f=0;f<c.length&&!(e=b?b(a[d],c[f]):a[d]===c[f]);++f);e||c.push(a[d])}return c};function v(){return Date.now()+Sa}var Sa=0;function Ta(a){this.b=a;this.c=0==Ua;this.a=0}var Ua=1;function Va(a){return a.a<a.b.byteLength}function Wa(a){var b=a.b.getUint8(a.a);a.a+=1;return b}function w(a){var b=a.b.getUint32(a.a,a.c);a.a+=4;return b}function Xa(a){var b,c;a.c?(b=a.b.getUint32(a.a,!0),c=a.b.getUint32(a.a+4,!0)):(c=a.b.getUint32(a.a,!1),b=a.b.getUint32(a.a+4,!1));if(2097151<c)throw new RangeError("DataViewReader: Overflow reading 64-bit value.");a.a+=8;return c*Math.pow(2,32)+b}
function Ya(a){if(a.a+16>a.b.byteLength)throw new RangeError("DataViewReader: Read past end of DataView.");var b=new Uint8Array(a.b.buffer,a.a,16);a.a+=16;return b}function Za(a,b){if(a.a+b>a.b.byteLength)throw new RangeError("DataViewReader: Skip past end of DataView.");a.a+=b};function $a(a){this.b=a;this.a=new Ta(a);ab||(ab=[new Uint8Array([255]),new Uint8Array([127,255]),new Uint8Array([63,255,255]),new Uint8Array([31,255,255,255]),new Uint8Array([15,255,255,255,255]),new Uint8Array([7,255,255,255,255,255]),new Uint8Array([3,255,255,255,255,255,255]),new Uint8Array([1,255,255,255,255,255,255,255])])}var ab;
function bb(a){var b;b=cb(a);if(7<b.length)throw new RangeError("EbmlParser: EBML ID must be at most 7 bytes.");for(var c=0,d=0;d<b.length;d++)c=256*c+b[d];b=c;c=cb(a);a:{for(d=0;d<ab.length;d++)if(db(c,ab[d])){d=!0;break a}d=!1}if(d)c=a.b.byteLength-a.a.a;else{if(8==c.length&&c[1]&224)throw new RangeError("EbmlParser: Variable sized integer value must be at most 53 bits.");for(var d=c[0]&(1<<8-c.length)-1,e=1;e<c.length;e++)d=256*d+c[e];c=d}c=a.a.a+c<=a.b.byteLength?c:a.b.byteLength-a.a.a;d=new DataView(a.b.buffer,
a.b.byteOffset+a.a.a,c);Za(a.a,c);return new eb(b,d)}function cb(a){var b=Wa(a.a),c;for(c=1;8>=c&&!(b&1<<8-c);c++);if(8<c)throw new RangeError("EbmlParser: Variable sized integer must fit within 8 bytes.");var d=new Uint8Array(c);d[0]=b;for(b=1;b<c;b++)d[b]=Wa(a.a);return d}function eb(a,b){this.id=a;this.a=b}
function fb(a){if(8<a.a.byteLength)throw new RangeError("EbmlElement: Unsigned integer has too many bytes.");if(8==a.a.byteLength&&a.a.getUint8(0)&224)throw new RangeError("EbmlParser: Unsigned integer must be at most 53 bits.");for(var b=0,c=0;c<a.a.byteLength;c++)var d=a.a.getUint8(c),b=256*b+d;return b};var gb={"output-restricted":"The required output protection is not available.","output-not-allowed":"The required output protection is not available.",expired:"The decryption key has expired.","internal-error":"The key system has encountered an unspecified error."};function hb(a){this.c=Math.exp(Math.log(.5)/a);this.a=this.b=0}hb.prototype.sample=function(a,b){var c=Math.pow(this.c,a);this.b=b*(1-c)+c*this.b;this.a+=a};function ib(a){return a.b/(1-Math.pow(a.c,a.a))};function x(a){var b=new CustomEvent(a.type,{detail:a.detail,bubbles:!!a.bubbles}),c;for(c in a)c in b||(b[c]=a[c]);return b}function y(a){return new CustomEvent("error",{detail:a,bubbles:!0})};function jb(a,b,c){kb(b);kb(c);return c==b||a>=lb&&c==b.split("-")[0]||a>=mb&&c.split("-")[0]==b.split("-")[0]?!0:!1}var lb=1,mb=2;function kb(a){a=a.toLowerCase().split("-");var b=nb[a[0]];b&&(a[0]=b);return a.join("-")}
var nb={aar:"aa",abk:"ab",afr:"af",aka:"ak",alb:"sq",amh:"am",ara:"ar",arg:"an",arm:"hy",asm:"as",ava:"av",ave:"ae",aym:"ay",aze:"az",bak:"ba",bam:"bm",baq:"eu",bel:"be",ben:"bn",bih:"bh",bis:"bi",bod:"bo",bos:"bs",bre:"br",bul:"bg",bur:"my",cat:"ca",ces:"cs",cha:"ch",che:"ce",chi:"zh",chu:"cu",chv:"cv",cor:"kw",cos:"co",cre:"cr",cym:"cy",cze:"cs",dan:"da",deu:"de",div:"dv",dut:"nl",dzo:"dz",ell:"el",eng:"en",epo:"eo",est:"et",eus:"eu",ewe:"ee",fao:"fo",fas:"fa",fij:"fj",fin:"fi",fra:"fr",fre:"fr",
fry:"fy",ful:"ff",geo:"ka",ger:"de",gla:"gd",gle:"ga",glg:"gl",glv:"gv",gre:"el",grn:"gn",guj:"gu",hat:"ht",hau:"ha",heb:"he",her:"hz",hin:"hi",hmo:"ho",hrv:"hr",hun:"hu",hye:"hy",ibo:"ig",ice:"is",ido:"io",iii:"ii",iku:"iu",ile:"ie",ina:"ia",ind:"id",ipk:"ik",isl:"is",ita:"it",jav:"jv",jpn:"ja",kal:"kl",kan:"kn",kas:"ks",kat:"ka",kau:"kr",kaz:"kk",khm:"km",kik:"ki",kin:"rw",kir:"ky",kom:"kv",kon:"kg",kor:"ko",kua:"kj",kur:"ku",lao:"lo",lat:"la",lav:"lv",lim:"li",lin:"ln",lit:"lt",ltz:"lb",lub:"lu",
lug:"lg",mac:"mk",mah:"mh",mal:"ml",mao:"mi",mar:"mr",may:"ms",mkd:"mk",mlg:"mg",mlt:"mt",mon:"mn",mri:"mi",msa:"ms",mya:"my",nau:"na",nav:"nv",nbl:"nr",nde:"nd",ndo:"ng",nep:"ne",nld:"nl",nno:"nn",nob:"nb",nor:"no",nya:"ny",oci:"oc",oji:"oj",ori:"or",orm:"om",oss:"os",pan:"pa",per:"fa",pli:"pi",pol:"pl",por:"pt",pus:"ps",que:"qu",roh:"rm",ron:"ro",rum:"ro",run:"rn",rus:"ru",sag:"sg",san:"sa",sin:"si",slk:"sk",slo:"sk",slv:"sl",sme:"se",smo:"sm",sna:"sn",snd:"sd",som:"so",sot:"st",spa:"es",sqi:"sq",
srd:"sc",srp:"sr",ssw:"ss",sun:"su",swa:"sw",swe:"sv",tah:"ty",tam:"ta",tat:"tt",tel:"te",tgk:"tg",tgl:"tl",tha:"th",tib:"bo",tir:"ti",ton:"to",tsn:"tn",tso:"ts",tuk:"tk",tur:"tr",twi:"tw",uig:"ug",ukr:"uk",urd:"ur",uzb:"uz",ven:"ve",vie:"vi",vol:"vo",wel:"cy",wln:"wa",wol:"wo",xho:"xh",yid:"yi",yor:"yo",zha:"za",zho:"zh",zul:"zu"};function ob(a){return Object.keys(a).map(function(b){return a[b]})}function pb(a,b){return qb(a,b,"boolean")}function rb(a,b){var c=qb(a,b,"number");if(null==c)return null;if(isNaN(c)||c==Number.NEGATIVE_INFINITY||c==Number.POSITIVE_INFINITY)throw new RangeError("'"+b+"' must be finite.");if(0>c)throw new RangeError("'"+b+"' must be >= 0");return c}function sb(a,b){return qb(a,b,"string")}
function qb(a,b,c){a=a[b];if(null==a)return null;if(typeof a!=c)throw new TypeError("'"+b+"' must be a "+c+".");return a}function tb(a,b,c){a=a[b];if(null==a)return null;if(!(a instanceof c))throw new TypeError("'"+b+"' must be an instance of "+c.name+".");return a};function z(){this.a={}}z.prototype.push=function(a,b){this.a.hasOwnProperty(a)?this.a[a].push(b):this.a[a]=[b]};z.prototype.set=function(a,b){this.a[a]=b};z.prototype.get=function(a){return(a=this.a[a])?a.slice():null};function ub(a){var b=[],c;for(c in a.a)b.push.apply(b,a.a[c]);return b}function vb(a,b,c){if(a=a.a[b])for(b=0;b<a.length;++b)a[b]==c&&(a.splice(b,1),--b)}function wb(a){var b=[],c;for(c in a.a)b.push(c);return b};function B(){this.a=new z}B.prototype.destroy=function(){xb(this);this.a=null};function C(a,b,c,d){b=new yb(b,c,d);a.a.push(c,b)}B.prototype.sa=function(a,b){for(var c=this.a.get(b)||[],d=0;d<c.length;++d){var e=c[d];e.target==a&&(e.sa(),vb(this.a,b,e))}};function xb(a){for(var b=ub(a.a),c=0;c<b.length;++c)b[c].sa();a.a.a={}}function yb(a,b,c){this.target=a;this.type=b;this.a=c;this.target.addEventListener(b,c,!1)}
yb.prototype.sa=function(){this.target&&(this.target.removeEventListener(this.type,this.a,!1),this.a=this.target=null)};function D(a){this.ya=new z;this.v=a}p("shaka.util.FakeEventTarget",D);D.prototype.addEventListener=function(a,b,c){c||this.ya.push(a,b)};D.prototype.removeEventListener=function(a,b,c){c||vb(this.ya,a,b)};
D.prototype.dispatchEvent=function(a){a.hasOwnProperty("srcElement")||(delete a.srcElement,Object.defineProperty(a,"srcElement",{get:function(){return null}}));if(a.hasOwnProperty("target"))a.target=this;else{delete a.target;var b=this;Object.defineProperty(a,"target",{get:function(){return b},set:function(a){b=a}})}if(a.hasOwnProperty("currentTarget"))a.currentTarget=null;else{delete a.currentTarget;var c=null;Object.defineProperty(a,"currentTarget",{get:function(){return c},set:function(a){c=a}})}return zb(this,
a)};function zb(a,b){b.currentTarget=a;for(var c=a.ya.get(b.type)||[],d=0;d<c.length;++d){var e=c[d];try{e.handleEvent?e.handleEvent(b):e.call(a,b)}catch(f){}}a.v&&b.bubbles&&zb(a.v,b);return b.defaultPrevented};function Ab(){D.call(this,null);this.a=new hb(3);this.c=new hb(10);this.b=0}q(Ab,D);p("shaka.util.EWMABandwidthEstimator",Ab);Ab.prototype.sample=function(a,b){if(!(65536>b)){a=Math.max(a,50);var c=8E3*b/a,d=a/1E3;this.a.sample(d,c);this.c.sample(d,c);this.dispatchEvent(x({type:"bandwidth"}));this.b=Date.now()}};Ab.prototype.getBandwidth=function(){return.5>this.a.a?5E5:Math.min(ib(this.a),ib(this.c))};Ab.prototype.getDataAge=function(){return(Date.now()-this.b)/1E3};
Ab.prototype.supportsCaching=function(){return!1};function E(){var a,b,c=new Promise(function(c,e){a=c;b=e});c.resolve=a;c.reject=b;c.destroy=E.prototype.destroy;return c}E.prototype.destroy=function(){this.catch(function(){});var a=Error("Destroyed!");a.type="destroy";this.reject(a)};function Bb(a){return a.split("").reduce(function(a,c,d){return a+(d&&0==d%4?" "+c:c)})};function Cb(){this.g=new E;this.f=!1;this.a=null;this.b=[];this.c=null}function Db(a,b){if(a.f)throw Error("Cannot append to a running task!");a.b.push(b)}Cb.prototype.start=function(){if(this.f)throw Error("Task already started!");this.f=!0;this.b.unshift(function(){});Eb(this,void 0)};Cb.prototype.end=function(){this.b.splice(1)};
function Eb(a,b){var c=a.b[0](b),d;c?(d=c[0],a.c=c[1]):(d=Promise.resolve(),a.c=null);d.then(F(a,function(a){this.a?(this.b=[],this.c=null,Fb(this)):(this.b.shift(),this.b.length?Eb(this,a):(this.g.resolve(a),this.c=null))})).catch(F(a,function(a){this.b=[];this.c=null;this.a?Fb(this):this.g.reject(a)}))}function Fb(a){var b=Error("Task aborted.");b.type="aborted";a.g.reject(b);window.setTimeout(function(){this.a.resolve();this.a=null}.bind(a),5)};function F(a,b){return b.bind(a)};function Gb(a,b){D.call(this,b);this.a=null;this.h=a}q(Gb,D);
function Hb(a){if(!window.indexedDB)return (a=Error("Persistant storage requires IndexedDB support."), a.type="storage", Promise.reject(a));if(a.a)return (a=Error("A database connection is already open."), a.type="storage", Promise.reject(a));var b=new E,c=window.indexedDB.open("content_database",1);c.onupgradeneeded=F(a,function(a){this.a=a.target.result;Ib(this,"group_store",{keyPath:"group_id"});Ib(this,"stream_index_store",{keyPath:"stream_id"});a=Ib(this,"content_store",{autoIncrement:"true"});a.createIndex("segment",
["stream_id","segment_id"],{unique:!0});a.createIndex("stream","stream_id",{unique:!1})});c.onsuccess=F(a,function(a){this.a=a.target.result;b.resolve()});c.onerror=function(){b.reject(c.error)};return b}function Jb(a){a.a&&(a.a.close(),a.a=null)}function Ib(a,b,c){a.a.objectStoreNames.contains(b)&&a.a.deleteObjectStore(b);return a.a.createObjectStore(b,c)}function Kb(a){return Lb(a,"content_store")}function Mb(a){return Lb(a,"stream_index_store")}function Ob(a){return Lb(a,"group_store")}
function Lb(a,b){return a.a.transaction([b],a.h).objectStore(b)}function Pb(a,b){var c=new E,d=a.get(b);d.onerror=function(){c.reject(d.error)};d.onsuccess=function(){if(d.result)c.resolve(d.result);else{var a=Error("Item not found.");a.type="storage";c.reject(a)}};return c};function Qb(){Gb.call(this,"readonly",null)}q(Qb,Gb);function Rb(a){var b=new E,c=[],d=Ob(a).openCursor();d.onerror=function(){b.reject(d.error)};d.onsuccess=function(a){(a=a.target.result)?(c.push(a.key),a.continue()):b.resolve(c)};return b}
function Sb(a,b){return Pb(Ob(a),b).then(F(a,function(a){a.session_ids=Ra(a.session_ids);return a.hasOwnProperty("duration")||a.hasOwnProperty("key_system")?Promise.resolve(a):Tb(this,a.stream_ids[0]).then(function(b){a.duration=b.duration;a.key_system=b.key_system;a.license_server=b.license_server;a.with_credentials=b.with_credentials;a.distinctive_identifier=b.distinctive_identifier;a.audio_robustness=b.audio_robustness;a.video_robustness=b.video_robustness;return Promise.resolve(a)})}))}
function Tb(a,b){return Pb(Mb(a),b)}function Ub(a,b,c){return Pb(Kb(a).index("segment"),[b,c]).then(function(a){return Promise.resolve(a.content)})};function Vb(a,b,c){MediaSource.isTypeSupported(b);b=a.addSourceBuffer(b);this.i=a;this.c=b;this.l=c;this.j=new B;this.g=null;this.b=[];this.w=0;this.f=this.a=null;this.s=0;C(this.j,this.c,"updateend",this.B.bind(this))}var Wb=1/60;Vb.prototype.destroy=function(){Xb(this).catch(function(){});this.f&&this.f.destroy();this.a=this.f=null;this.g&&(Jb(this.g),this.g=null);this.b=null;this.j.destroy();this.i=this.c=this.j=null};
function Yb(a,b){for(var c=a.c.buffered,d=0;d<c.length;++d){var e=c.start(d)-Wb,f=c.end(d)+Wb;if(b>=e&&b<=f)return c.end(d)-b}return 0}
function Zb(a,b,c,d){if(a.a)return (a=Error("Cannot fetch ("+a.v+"): previous operation not complete."), a.type="stream", Promise.reject(a));a.a=new Cb;c!=a.c.timestampOffset&&(a.c.timestampOffset=c);"idb"!=b.url.b[0].P||a.g||(a.g=new Qb,Db(a.a,function(){return[Hb(this.g)]}.bind(a)));d&&Db(a.a,function(){return[$b(this,d),this.h.bind(this)]}.bind(a));Db(a.a,function(){var a=b.a?b.a-b.b:1,c=new ac;c.a=3;c.h=1E3*a;c.c=1E3*this.s;c.i=this.g;return[bc(b.url,c,this.l),G.prototype.g.bind(b.url)]}.bind(a));
Db(a.a,F(a,function(a){this.l.getBandwidth();return[$b(this,a),this.h.bind(this)]}));var e=0==a.c.buffered.length&&0==a.b.length,f=null;Db(a.a,function(){if(0==this.c.buffered.length){var a=Error("Failed to buffer segment ("+this.v+").");a.type="stream";return[Promise.reject(a)]}e&&(a=b.b,f=this.c.buffered.start(0)-a);a=cc(this.b,b.b);0<=a?this.b.splice(a+1,0,b):this.b.push(b)}.bind(a));return dc(a).then(function(){return Promise.resolve(f)}.bind(a))}
function ec(a){if(a.a)return (a=Error("Cannot clear ("+a.v+"): previous operation not complete."), a.type="stream", Promise.reject(a));a.a=new Cb;Db(a.a,function(){var a;a:if(0==this.c.buffered.length)a=Promise.resolve();else{try{this.c.remove(0,this.i.duration)}catch(c){a=Promise.reject(c);break a}this.b=[];a=this.f=new E}return[a,this.h.bind(this)]}.bind(a));return dc(a)}
function fc(a,b){if(a.a){var c=Error("Cannot clearAfter ("+a.v+"): previous operation not complete.");c.type="stream";return Promise.reject(c)}a.a=new Cb;Db(a.a,function(){return[gc(this,b),this.h.bind(this)]}.bind(a));return dc(a)}function Xb(a){a.a?(a=a.a,a.a?a=a.a:a.f?(a.c&&a.c(),a.a=new E,a=a.a):(a.f=!0,a=Promise.resolve())):a=Promise.resolve();return a}function dc(a){a.a.start();return a.a.g.then(F(a,function(){this.a=null})).catch(F(a,function(a){this.a=null;return Promise.reject(a)}))}
function $b(a,b){try{a.c.appendBuffer(b)}catch(c){return Promise.reject(c)}a.f=new E;return a.f}function gc(a,b){if(0==a.c.buffered.length)return Promise.resolve();var c=cc(a.b,b);if(-1==c||c==a.b.length-1)return Promise.resolve();try{a.c.remove(a.b[c+1].b,a.i.duration)}catch(d){return Promise.reject(d)}a.b=a.b.slice(0,c+1);a.f=new E;return a.f}Vb.prototype.h=function(){this.f&&"open"==this.i.readyState&&this.c.abort()};Vb.prototype.B=function(){this.f&&(this.f.resolve(),this.f=null)};function hc(a){return String.fromCharCode.apply(null,a)}p("shaka.util.Uint8ArrayUtils.toString",hc);function ic(a){for(var b=new Uint8Array(a.length),c=0;c<a.length;++c)b[c]=a.charCodeAt(c);return b}p("shaka.util.Uint8ArrayUtils.fromString",ic);p("shaka.util.Uint8ArrayUtils.toBase64",function(a,b){var c=void 0==b?!0:b,d=window.btoa(hc(a)).replace(/\+/g,"-").replace(/\//g,"_");return c?d:d.replace(/=*$/,"")});function jc(a){return ic(window.atob(a.replace(/-/g,"+").replace(/_/g,"/")))}
p("shaka.util.Uint8ArrayUtils.fromBase64",jc);p("shaka.util.Uint8ArrayUtils.fromHex",function(a){for(var b=new Uint8Array(a.length/2),c=0;c<a.length;c+=2)b[c/2]=window.parseInt(a.substr(c,2),16);return b});function kc(a){for(var b="",c=0;c<a.length;++c){var d=a[c].toString(16);1==d.length&&(d="0"+d);b+=d}return b}p("shaka.util.Uint8ArrayUtils.toHex",kc);function db(a,b){if(!a&&!b)return!0;if(!a||!b||a.length!=b.length)return!1;for(var c=0;c<a.length;++c)if(a[c]!=b[c])return!1;return!0};function lc(){this.h=this.a="";this.i=!1;this.s=this.l=null;this.v=this.g=!1;this.j=this.f="";this.c=null;this.b=[]}
function mc(a){var b=new lc;if(!a)return b;var c=sb(a,"keySystem");if(null!=c)b.a=c;else throw Error("'keySystem' cannot be null.");var d=sb(a,"licenseServerUrl");if(null!=d)b.h=d;else if(c)throw Error("For encrypted streaming content, 'licenseServerUrl' cannot be null or empty.");c=pb(a,"withCredentials");null!=c&&(b.i=c);c=tb(a,"licensePostProcessor",Function);null!=c&&(b.l=c);c=tb(a,"licensePreProcessor",Function);null!=c&&(b.s=c);c=pb(a,"distinctiveIdentifierRequired");null!=c&&(b.g=c);c=pb(a,
"persistentStateRequired");null!=c&&(b.v=c);c=sb(a,"audioRobustness");null!=c&&(b.f=c);c=sb(a,"videoRobustness");null!=c&&(b.j=c);c=tb(a,"serverCertificate",Uint8Array);null!=c&&(b.c=c);if(c=tb(a,"initData",Object)){a=tb(c,"initData",Uint8Array);if(null==a)throw Error("'initData.initData' cannot be null.");c=sb(c,"initDataType");if(null==c)throw Error("'initData.initDataType' cannot be null.");b.b.push({initData:new Uint8Array(a.buffer),initDataType:c})}return b}
function nc(a,b){var c=new lc;c.a=a.a;c.h=a.h;c.i=a.i;c.l=a.l;c.s=a.s;c.g=a.g;c.v=a.v;c.f=a.f;c.j=a.j;c.c=a.c?new Uint8Array(a.c.buffer):null;oc(c,a.b);oc(c,b.b);return c}function oc(a,b){var c=a.b.concat(b.map(function(a){return{initData:new Uint8Array(a.initData.buffer),initDataType:a.initDataType}}));a.b=Ra(c,pc)}function pc(a,b){return a.initDataType==b.initDataType&&db(a.initData,b.initData)};function qc(a,b){try{var c=new rc(a,b);return Promise.resolve(c)}catch(d){return Promise.reject(d)}}function sc(a){var b=this.mediaKeys;b&&b!=a&&tc(b,null);delete this.mediaKeys;(this.mediaKeys=a)&&tc(a,this);return Promise.resolve()}
function rc(a,b){this.a=this.keySystem=a;var c=!0;"org.w3.clearkey"==a&&(this.a="webkit-org.w3.clearkey",c=!1);var d=!1,e;e=document.getElementsByTagName("video");e=e.length?e[0]:document.createElement("video");for(var f=0;f<b.length;++f){var g=b[f],h={audioCapabilities:[],videoCapabilities:[],persistentState:"optional",distinctiveIdentifier:"optional",initDataTypes:g.initDataTypes,sessionTypes:["temporary"]},l=!1;if(g.audioCapabilities)for(var m=0;m<g.audioCapabilities.length;++m){var n=g.audioCapabilities[m];
n.contentType&&(l=!0,e.canPlayType(n.contentType.split(";")[0],this.a)&&(h.audioCapabilities.push(n),d=!0))}if(g.videoCapabilities)for(m=0;m<g.videoCapabilities.length;++m)n=g.videoCapabilities[m],n.contentType&&(l=!0,e.canPlayType(n.contentType,this.a)&&(h.videoCapabilities.push(n),d=!0));l||(d=e.canPlayType("video/mp4",this.a)||e.canPlayType("video/webm",this.a));"required"==g.persistentState&&(c?(h.persistentState="required",h.sessionTypes=["persistent-license"]):d=!1);if(d){this.b=h;return}}c=
"Unsupported keySystem";if("org.w3.clearkey"==a||"com.widevine.alpha"==a)c="None of the requested configurations were supported.";c=Error(c);c.name="NotSupportedError";c.code=DOMException.NOT_SUPPORTED_ERR;throw c;}rc.prototype.createMediaKeys=function(){var a=new uc(this.a);return Promise.resolve(a)};rc.prototype.getConfiguration=function(){return this.b};function uc(a){this.g=a;this.b=null;this.a=new B;this.c=[];this.f={}}
function tc(a,b){a.b=b;xb(a.a);b&&(C(a.a,b,"webkitneedkey",a.Ob.bind(a)),C(a.a,b,"webkitkeymessage",a.Nb.bind(a)),C(a.a,b,"webkitkeyadded",a.Lb.bind(a)),C(a.a,b,"webkitkeyerror",a.Mb.bind(a)))}k=uc.prototype;k.createSession=function(a){var b=a||"temporary";if("temporary"!=b&&"persistent-license"!=b)throw new TypeError("Session type "+a+" is unsupported on this platform.");a=this.b||document.createElement("video");a.src||(a.src="about:blank");b=new vc(a,this.g,b);this.c.push(b);return b};
k.setServerCertificate=function(){return Promise.reject(Error("setServerCertificate not supported on this platform."))};k.Ob=function(a){a=x({type:"encrypted",initDataType:"webm",initData:a.initData});this.b.dispatchEvent(a)};k.Nb=function(a){var b=wc(this,a.sessionId);b&&(a=x({type:"message",messageType:void 0==b.keyStatuses.Fa()?"licenserequest":"licenserenewal",message:a.message}),b.b&&(b.b.resolve(),b.b=null),b.dispatchEvent(a))};
k.Lb=function(a){if(a=wc(this,a.sessionId))xc(a,"usable"),a.a&&a.a.resolve(),a.a=null};
k.Mb=function(a){var b=wc(this,a.sessionId);if(b){var c=Error("EME v0.1b key error");c.errorCode=a.errorCode;c.errorCode.systemCode=a.systemCode;!a.sessionId&&b.b?(c.method="generateRequest",45==a.systemCode&&(c.message="Unsupported session type."),b.b.reject(c),b.b=null):a.sessionId&&b.a?(c.method="update",b.a.reject(c),b.a=null):(c=a.systemCode,a.errorCode.code==MediaKeyError.MEDIA_KEYERR_OUTPUT?xc(b,"output-restricted"):1==c?xc(b,"expired"):xc(b,"internal-error"))}};
function wc(a,b){var c=a.f[b];return c?c:(c=a.c.shift())?(c.sessionId=b,a.f[b]=c):null}function vc(a,b,c){D.call(this,null);this.f=a;this.h=!1;this.a=this.b=null;this.c=b;this.g=c;this.sessionId="";this.expiration=NaN;this.closed=new E;this.keyStatuses=new yc}q(vc,D);
function zc(a,b,c){if(a.h)return Promise.reject(Error("The session is already initialized."));a.h=!0;var d;try{if("persistent-license"==a.g)if(c)d=ic("LOAD_SESSION|"+c);else{var e=new Uint8Array(b);d=ic("PERSISTENT|"+hc(e))}else d=new Uint8Array(b)}catch(f){return Promise.reject(f)}a.b=new E;try{a.f.webkitGenerateKeyRequest(a.c,d)}catch(g){if("InvalidStateError"!=g.name)return (a.b=null, Promise.reject(g));setTimeout(function(){try{this.f.webkitGenerateKeyRequest(this.c,d)}catch(a){this.b.reject(a),
this.b=null}}.bind(a),10)}return a.b}k=vc.prototype;k.Qa=function(a,b){if(this.a)this.a.then(this.Qa.bind(this,a,b)).catch(this.Qa.bind(this,a,b));else{this.a=a;var c,d;"webkit-org.w3.clearkey"==this.c?(c=hc(new Uint8Array(b)),d=JSON.parse(c),"oct"!=d.keys[0].kty&&(this.a.reject(Error("Response is not a valid JSON Web Key Set.")),this.a=null),c=jc(d.keys[0].k),d=jc(d.keys[0].kid)):(c=new Uint8Array(b),d=null);try{this.f.webkitAddKey(this.c,c,d,this.sessionId)}catch(e){this.a.reject(e),this.a=null}}};
function xc(a,b){a.keyStatuses.Ma(b);var c=x({type:"keystatuseschange"});a.dispatchEvent(c)}k.generateRequest=function(a,b){return zc(this,b,null)};k.load=function(a){return"persistent-license"==this.g?zc(this,null,a):Promise.reject(Error("Not a persistent session."))};k.update=function(a){var b=new E;this.Qa(b,a);return b};
k.close=function(){if("persistent-license"!=this.g){if(!this.sessionId)return (this.closed.reject(Error("The session is not callable.")), this.closed);this.f.webkitCancelKeyRequest(this.c,this.sessionId)}this.closed.resolve();return this.closed};k.remove=function(){return"persistent-license"!=this.g?Promise.reject(Error("Not a persistent session.")):this.close()};function yc(){this.size=0;this.a=void 0}var Ac;k=yc.prototype;k.Ma=function(a){this.size=void 0==a?0:1;this.a=a};k.Fa=function(){return this.a};
k.forEach=function(a){this.a&&a(Ac,this.a)};k.get=function(a){if(this.has(a))return this.a};k.has=function(a){var b=Ac;return this.a&&db(new Uint8Array(a),new Uint8Array(b))?!0:!1};function Bc(a){this.systemIds=[];this.cencKeyIds=[];this.a=[];a=new Ta(new DataView(a.buffer));try{for(;Va(a);){var b=a.a,c=w(a),d=w(a);1==c?c=Xa(a):0==c&&(c=a.b.byteLength-b);if(1886614376!=d)Za(a,c-(a.a-b));else{var e=Wa(a);if(1<e)Za(a,c-(a.a-b));else{Za(a,3);var f=kc(Ya(a)),g=[];if(0<e)for(var h=w(a),l=0;l<h;++l){var m=kc(Ya(a));g.push(m)}var n=w(a);Za(a,n);this.cencKeyIds.push.apply(this.cencKeyIds,g);this.systemIds.push(f);this.a.push({start:b,end:a.a-1});a.a!=b+c&&Za(a,c-(a.a-b))}}}}catch(t){}}
;function Cc(a,b){try{var c=new Dc(a,b);return Promise.resolve(c)}catch(d){return Promise.reject(d)}}
function Dc(a,b){this.keySystem=a;for(var c=!1,d=0;d<b.length;++d){var e=b[d],f={audioCapabilities:[],videoCapabilities:[],persistentState:"optional",distinctiveIdentifier:"optional",initDataTypes:e.initDataTypes,sessionTypes:["temporary"]},g=!1;if(e.audioCapabilities)for(var h=0;h<e.audioCapabilities.length;++h){var l=e.audioCapabilities[h];if(l.contentType){var g=!0,m=l.contentType.split(";")[0];MSMediaKeys.isTypeSupported(this.keySystem,m)&&(f.audioCapabilities.push(l),c=!0)}}if(e.videoCapabilities)for(h=
0;h<e.videoCapabilities.length;++h)l=e.videoCapabilities[h],l.contentType&&(g=!0,m=l.contentType.split(";")[0],MSMediaKeys.isTypeSupported(this.keySystem,m)&&(f.videoCapabilities.push(l),c=!0));g||(c=MSMediaKeys.isTypeSupported(this.keySystem,"video/mp4"));"required"==e.persistentState&&(f.persistentState="required",f.sessionTypes=["persistent-license"]);if(c){this.a=f;return}}c=Error("Unsupported keySystem");c.name="NotSupportedError";c.code=DOMException.NOT_SUPPORTED_ERR;throw c;}
Dc.prototype.createMediaKeys=function(){var a=new Ec(this.keySystem);return Promise.resolve(a)};Dc.prototype.getConfiguration=function(){return this.a};function Fc(a){var b=this.mediaKeys;b&&b!=a&&Gc(b,null);delete this.mediaKeys;return(this.mediaKeys=a)?Gc(a,this):Promise.resolve()}function Ec(a){this.a=new MSMediaKeys(a);this.b=new B}Ec.prototype.createSession=function(a){if("temporary"!=(a||"temporary"))throw new TypeError("Session type "+a+" is unsupported on this platform.");return new Hc(this.a)};
Ec.prototype.setServerCertificate=function(){return Promise.reject(Error("setServerCertificate not supported on this platform."))};function Gc(a,b){function c(){b.msSetMediaKeys(d.a);b.removeEventListener("loadedmetadata",c)}xb(a.b);if(!b)return Promise.resolve();C(a.b,b,"msneedkey",Ic);var d=a;try{return (1<=b.readyState?b.msSetMediaKeys(a.a):b.addEventListener("loadedmetadata",c), Promise.resolve())}catch(e){return Promise.reject(e)}}
function Hc(a){D.call(this,null);this.c=null;this.g=a;this.b=this.a=null;this.f=new B;this.sessionId="";this.expiration=NaN;this.closed=new E;this.keyStatuses=new Jc}q(Hc,D);k=Hc.prototype;k.generateRequest=function(a,b){this.a=new E;try{this.c=this.g.createSession("video/mp4",new Uint8Array(b),null),C(this.f,this.c,"mskeymessage",this.Bb.bind(this)),C(this.f,this.c,"mskeyadded",this.zb.bind(this)),C(this.f,this.c,"mskeyerror",this.Ab.bind(this)),Kc(this,"status-pending")}catch(c){this.a.reject(c)}return this.a};
k.load=function(){return Promise.reject(Error("MediaKeySession.load not yet supported"))};k.update=function(a){this.b=new E;try{this.c.update(new Uint8Array(a))}catch(b){this.b.reject(b)}return this.b};k.close=function(){try{this.c.close(),this.closed.resolve(),xb(this.f)}catch(a){this.closed.reject(a)}return this.closed};k.remove=function(){return Promise.reject(Error("MediaKeySession.remove is only applicable for persistent licenses, which are not supported on this platform"))};
function Ic(a){var b=a.initData;if(b){var c=new Bc(b);if(1>=c.a.length)a=b;else{var d=[];for(a=0;a<c.a.length;a++)d.push(b.subarray(c.a[a].start,c.a[a].end+1));b=Ra(d,Lc);for(a=c=0;a<b.length;a++)c+=b[a].length;c=new Uint8Array(c);for(a=d=0;a<b.length;a++)c.set(b[a],d),d+=b[a].length;a=c}}else a=b;a=x({type:"encrypted",initDataType:"cenc",initData:a});this.dispatchEvent(a)}function Lc(a,b){return db(a,b)}
k.Bb=function(a){this.a&&(this.a.resolve(),this.a=null);a=x({type:"message",messageType:void 0==this.keyStatuses.Fa()?"licenserequest":"licenserenewal",message:a.message.buffer});this.dispatchEvent(a)};k.zb=function(){this.a?(this.a.resolve(),this.a=null):this.b&&(Kc(this,"usable"),this.b.resolve(),this.b=null)};
k.Ab=function(){var a=Error("EME v20140218 key error");a.errorCode=this.c.error;if(null!=this.a)this.a.reject(a),this.a=null;else if(null!=this.b)this.b.reject(a),this.b=null;else switch(this.c.error.code){case MSMediaKeyError.MS_MEDIA_KEYERR_OUTPUT:case MSMediaKeyError.MS_MEDIA_KEYERR_HARDWARECHANGE:Kc(this,"output-not-allowed");default:Kc(this,"internal-error")}};function Kc(a,b){a.keyStatuses.Ma(b);var c=x({type:"keystatuseschange"});a.dispatchEvent(c)}function Jc(){this.size=0;this.a=void 0}var Mc;
k=Jc.prototype;k.Ma=function(a){this.size=void 0==a?0:1;this.a=a};k.Fa=function(){return this.a};k.forEach=function(a){this.a&&a(Mc,this.a)};k.get=function(a){if(this.has(a))return this.a};k.has=function(a){var b=Mc;return this.a&&db(new Uint8Array(a),new Uint8Array(b))?!0:!1};function Nc(){Navigator.prototype.requestMediaKeySystemAccess&&MediaKeySystemAccess.prototype.getConfiguration||(HTMLMediaElement.prototype.webkitGenerateKeyRequest?(Ac=(new Uint8Array([0])).buffer,Navigator.prototype.requestMediaKeySystemAccess=qc,delete HTMLMediaElement.prototype.mediaKeys,HTMLMediaElement.prototype.mediaKeys=null,HTMLMediaElement.prototype.setMediaKeys=sc,window.MediaKeys=uc,window.MediaKeySystemAccess=rc):window.MSMediaKeys?(Mc=(new Uint8Array([0])).buffer,delete HTMLMediaElement.prototype.mediaKeys,
HTMLMediaElement.prototype.mediaKeys=null,HTMLMediaElement.prototype.setMediaKeys=Fc,window.MediaKeys=Ec,window.MediaKeySystemAccess=Dc,Navigator.prototype.requestMediaKeySystemAccess=Cc):(Navigator.prototype.requestMediaKeySystemAccess=ya,delete HTMLMediaElement.prototype.mediaKeys,HTMLMediaElement.prototype.mediaKeys=null,HTMLMediaElement.prototype.setMediaKeys=za,window.MediaKeys=Aa,window.MediaKeySystemAccess=Ba))}p("shaka.polyfill.MediaKeys.install",Nc);p("shaka.polyfill.installAll",function(){ta();va();Pa();Da();Nc()});var Oc=/^(?:([^:/?#.]+):)?(?:\/\/(?:([^/?#]*)@)?([^/#?]*?)(?::([0-9]+))?(?=[/#?]|$))?([^?#]+)?(?:\?([^#]*))?(?:#(.*))?$/;function H(a){var b;a instanceof H?(Pc(this,a.P),this.ca=a.ca,this.S=a.S,Qc(this,a.ia),this.O=a.O,Rc(this,a.a.clone()),this.aa=a.aa):a&&(b=String(a).match(Oc))?(Pc(this,b[1]||"",!0),this.ca=Sc(b[2]||""),this.S=Sc(b[3]||"",!0),Qc(this,b[4]),this.O=Sc(b[5]||"",!0),Rc(this,b[6]||"",!0),this.aa=Sc(b[7]||"")):this.a=new Tc(null)}k=H.prototype;k.P="";k.ca="";k.S="";k.ia=null;k.O="";k.aa="";
k.toString=function(){var a=[],b=this.P;b&&a.push(Vc(b,Wc,!0),":");if(b=this.S){a.push("//");var c=this.ca;c&&a.push(Vc(c,Wc,!0),"@");a.push(encodeURIComponent(b).replace(/%25([0-9a-fA-F]{2})/g,"%$1"));b=this.ia;null!=b&&a.push(":",String(b))}if(b=this.O)this.S&&"/"!=b.charAt(0)&&a.push("/"),a.push(Vc(b,"/"==b.charAt(0)?Xc:Yc,!0));(b=this.a.toString())&&a.push("?",b);(b=this.aa)&&a.push("#",Vc(b,Zc));return a.join("")};
k.resolve=function(a){var b=this.clone();"data"===b.P&&(b=new H);var c=!!a.P;c?Pc(b,a.P):c=!!a.ca;c?b.ca=a.ca:c=!!a.S;c?b.S=a.S:c=null!=a.ia;var d=a.O;if(c)Qc(b,a.ia);else if(c=!!a.O){if("/"!=d.charAt(0))if(this.S&&!this.O)d="/"+d;else{var e=b.O.lastIndexOf("/");-1!=e&&(d=b.O.substr(0,e+1)+d)}if(".."==d||"."==d)d="";else if(-1!=d.indexOf("./")||-1!=d.indexOf("/.")){for(var e=0==d.lastIndexOf("/",0),d=d.split("/"),f=[],g=0;g<d.length;){var h=d[g++];"."==h?e&&g==d.length&&f.push(""):".."==h?((1<f.length||
1==f.length&&""!=f[0])&&f.pop(),e&&g==d.length&&f.push("")):(f.push(h),e=!0)}d=f.join("/")}}c?b.O=d:c=""!==a.a.toString();c?Rc(b,a.a.clone()):c=!!a.aa;c&&(b.aa=a.aa);return b};k.clone=function(){return new H(this)};function Pc(a,b,c){a.P=c?Sc(b,!0):b;a.P&&(a.P=a.P.replace(/:$/,""))}function Qc(a,b){if(b){b=Number(b);if(isNaN(b)||0>b)throw Error("Bad port number "+b);a.ia=b}else a.ia=null}function Rc(a,b,c){b instanceof Tc?a.a=b:(c||(b=Vc(b,$c)),a.a=new Tc(b))}
function Sc(a,b){return a?b?decodeURI(a):decodeURIComponent(a):""}function Vc(a,b,c){return"string"==typeof a?(a=encodeURI(a).replace(b,ad),c&&(a=a.replace(/%25([0-9a-fA-F]{2})/g,"%$1")),a):null}function ad(a){a=a.charCodeAt(0);return"%"+(a>>4&15).toString(16)+(a&15).toString(16)}var Wc=/[#\/\?@]/g,Yc=/[\#\?:]/g,Xc=/[\#\?]/g,$c=/[\#\?@]/g,Zc=/#/g;function Tc(a){this.b=a||null}Tc.prototype.a=null;Tc.prototype.c=null;
function bd(a,b,c){if(!a.a&&(a.a={},a.c=0,a.b))for(var d=a.b.split("&"),e=0;e<d.length;e++){var f=d[e].indexOf("="),g=null,h=null;0<=f?(g=d[e].substring(0,f),h=d[e].substring(f+1)):g=d[e];g=decodeURIComponent(g.replace(/\+/g," "));h=h||"";bd(a,g,decodeURIComponent(h.replace(/\+/g," ")))}a.b=null;(d=a.a.hasOwnProperty(b)&&a.a[b])||(a.a[b]=d=[]);d.push(c);a.c++}
Tc.prototype.toString=function(){if(this.b)return this.b;if(!this.a)return"";var a=[],b;for(b in this.a)for(var c=encodeURIComponent(b),d=this.a[b],e=0;e<d.length;e++){var f=c;""!==d[e]&&(f+="="+encodeURIComponent(d[e]));a.push(f)}return this.b=a.join("&")};Tc.prototype.clone=function(){var a=new Tc;a.b=this.b;if(this.a){var b={},c;for(c in this.a)b[c]=this.a[c].concat();a.a=b;a.c=this.c}return a};function cd(){this.id=this.url=null;this.type="static";this.b=this.j=this.u=this.hb=null;this.h=5;this.f=this.c=this.g=null;this.i=1;this.a=[]}function dd(){this.g=this.f=this.c=this.u=this.a=this.start=this.id=null;this.b=[]}function ed(){this.i=this.b=this.height=this.width=this.contentType=this.lang=this.group=this.id=null;this.c=!1;this.h=this.g=this.f=this.u=null;this.j=[];this.a=[]}function fd(){this.value=null}function gd(){this.contentType=this.lang=this.id=null}
function hd(){this.a=this.b=this.g=this.u=this.h=this.f=this.height=this.width=this.bandwidth=this.lang=this.id=null;this.c=[]}function id(){this.b=this.a=this.c=this.f=null}function jd(){this.parsedPssh=this.psshBox=null}function kd(){this.url=null}function ld(){this.url=null}function md(){this.u=null;this.g=1;this.c=this.b=this.a=this.f=null}md.prototype.clone=function(){var a=new md;a.u=nd(this.u);a.g=this.g;a.f=this.f;a.a=J(this.a);a.b=J(this.b);a.c=J(this.c);return a};
function od(){this.a=this.url=null}od.prototype.clone=function(){var a=new od;a.url=nd(this.url);a.a=J(this.a);return a};function pd(){this.a=this.url=null}pd.prototype.clone=function(){var a=new pd;a.url=nd(this.url);a.a=J(this.a);return a};function qd(){this.u=null;this.f=1;this.b=this.g=null;this.i=1;this.h=null;this.a=[];this.c=null}qd.prototype.clone=function(){var a=new qd;a.u=nd(this.u);a.f=this.f;a.g=this.g;a.b=this.b;a.i=this.i;a.h=J(this.h);a.a=nd(this.a)||[];a.c=J(this.c);return a};
function rd(){this.a=this.b=null}rd.prototype.clone=function(){var a=new rd;a.b=nd(this.b);a.a=J(this.a);return a};function sd(){this.a=1;this.b=this.i=null;this.j=1;this.c=this.g=this.f=this.h=null}sd.prototype.clone=function(){var a=new sd;a.a=this.a;a.i=this.i;a.b=this.b;a.j=this.j;a.h=this.h;a.f=this.f;a.g=this.g;a.c=J(this.c);return a};function td(){this.a=[]}td.prototype.clone=function(){var a=new td;a.a=nd(this.a)||[];return a};function ud(){this.c=this.a=this.b=null}
ud.prototype.clone=function(){var a=new ud;a.b=this.b;a.a=this.a;a.c=this.c;return a};function vd(a,b){this.na=a;this.end=b}vd.prototype.clone=function(){return new vd(this.na,this.end)};cd.TAG_NAME="MPD";dd.TAG_NAME="Period";ed.TAG_NAME="AdaptationSet";fd.TAG_NAME="Role";gd.TAG_NAME="ContentComponent";hd.TAG_NAME="Representation";id.TAG_NAME="ContentProtection";jd.TAG_NAME="cenc:pssh";kd.TAG_NAME="BaseURL";ld.TAG_NAME="Location";md.TAG_NAME="SegmentBase";od.TAG_NAME="RepresentationIndex";
pd.TAG_NAME="Initialization";qd.TAG_NAME="SegmentList";rd.TAG_NAME="SegmentURL";sd.TAG_NAME="SegmentTemplate";td.TAG_NAME="SegmentTimeline";ud.TAG_NAME="S";
cd.prototype.parse=function(a,b){this.url=a.hb;this.id=K(b,"id",L);this.type=K(b,"type",L)||"static";this.b=K(b,"mediaPresentationDuration",wd);this.h=K(b,"minBufferTime",wd,this.h);this.g=K(b,"minimumUpdatePeriod",wd,this.g);this.c=K(b,"availabilityStartTime",xd,this.c);this.f=K(b,"timeShiftBufferDepth",wd,this.f);this.i=K(b,"suggestedPresentationDelay",wd,this.i);var c=a.u,d=M(this,b,kd);this.u=yd(c,d);if(d=O(this,b,ld))this.j=zd(c,d.url);this.a=M(this,b,dd)};
dd.prototype.parse=function(a,b){this.id=K(b,"id",L);this.start=K(b,"start",wd);this.a=K(b,"duration",wd);var c=M(this,b,kd);this.u=yd(a.u,c);this.c=O(this,b,md);this.f=O(this,b,qd);this.g=O(this,b,sd);this.b=M(this,b,ed);Ad(this)};function Ad(a){for(var b=[],c=0;c<a.b.length;++c){var d=a.b[c];null!=d.group&&(b[d.group]=!0)}for(c=0;c<a.b.length;++c)if(d=a.b[c],null==d.group){for(var e=1;1==b[e];)++e;b[e]=!0;d.group=e}}
ed.prototype.parse=function(a,b){var c=O(this,b,gd)||{},d=O(this,b,fd);this.id=K(b,"id",L);this.group=K(b,"group",P);this.lang=K(b,"lang",L,c.lang);this.contentType=K(b,"contentType",L,c.contentType);this.width=K(b,"width",Q);this.height=K(b,"height",Q);this.b=K(b,"mimeType",L);this.i=K(b,"codecs",L);this.c=d&&"main"==d.value;this.lang&&(this.lang=kb(this.lang));c=M(this,b,kd);this.u=yd(a.u,c);this.j=M(this,b,id);!this.contentType&&this.b&&(this.contentType=this.b.split("/")[0]);this.f=a.c?Bd(this,
b,a.c):O(this,b,md);this.g=a.f?Bd(this,b,a.f):O(this,b,qd);this.h=a.g?Bd(this,b,a.g):O(this,b,sd);this.a=M(this,b,hd);!this.b&&this.a.length&&(this.b=this.a[0].f,!this.contentType&&this.b&&(this.contentType=this.b.split("/")[0]))};fd.prototype.parse=function(a,b){this.value=K(b,"value",L)};gd.prototype.parse=function(a,b){this.id=K(b,"id",L);this.lang=K(b,"lang",L);this.contentType=K(b,"contentType",L);this.lang&&(this.lang=kb(this.lang))};
hd.prototype.parse=function(a,b){this.id=K(b,"id",L);this.bandwidth=K(b,"bandwidth",Q);this.width=K(b,"width",Q,a.width);this.height=K(b,"height",Q,a.height);this.f=K(b,"mimeType",L,a.b);this.h=K(b,"codecs",L,a.i);this.lang=a.lang;var c=M(this,b,kd);this.u=yd(a.u,c);this.c=M(this,b,id);this.g=a.f?Bd(this,b,a.f):O(this,b,md);this.b=a.g?Bd(this,b,a.g):O(this,b,qd);this.a=a.h?Bd(this,b,a.h):O(this,b,sd);this.c=this.c.concat(a.j)};
id.prototype.parse=function(a,b){this.f=b;this.c=K(b,"schemeIdUri",L);var c=K(b,"cenc:default_KID",L);c&&(this.b=c.replace(/[-]/g,""));this.a=O(this,b,jd)};jd.prototype.parse=function(a,b){var c=Cd(b);if(c){this.psshBox=jc(c);try{this.parsedPssh=new Bc(this.psshBox)}catch(d){if(!(d instanceof RangeError))throw d;}}};kd.prototype.parse=function(a,b){this.url=Cd(b)};ld.prototype.parse=function(a,b){this.url=Cd(b)};
md.prototype.parse=function(a,b){this.u=a.u||this.u;this.g=K(b,"timescale",Q,this.g);this.f=K(b,"presentationTimeOffset",P,this.f);this.a=K(b,"indexRange",Dd,this.a);this.b=O(this,b,od)||this.b;this.c=O(this,b,pd)||this.c};od.prototype.parse=function(a,b){var c=K(b,"sourceURL",L);this.url=zd(a.u,c);this.a=K(b,"range",Dd,J(a.a))};pd.prototype.parse=function(a,b){var c=K(b,"sourceURL",L);this.url=zd(a.u,c);this.a=K(b,"range",Dd)};
qd.prototype.parse=function(a,b){this.u=a.u||this.u;this.f=K(b,"timescale",Q,this.f);this.g=K(b,"presentationTimeOffset",P,this.g);this.b=K(b,"duration",Q,this.b);var c=K(b,"startNumber",Q);null!=c&&(this.i=c);this.h=O(this,b,pd)||this.h;this.a=(c=M(this,b,rd))&&0<c.length?c:this.a;this.c=O(this,b,td)||this.c};rd.prototype.parse=function(a,b){var c=K(b,"media",L);this.b=zd(a.u,c);this.a=K(b,"mediaRange",Dd)};
sd.prototype.parse=function(a,b){this.a=K(b,"timescale",Q,this.a);this.i=K(b,"presentationTimeOffset",P,this.i);this.b=K(b,"duration",Q,this.b);var c=K(b,"startNumber",P);null!=c&&(this.j=c);this.h=K(b,"media",L,this.h);this.f=K(b,"index",L,this.f);this.g=K(b,"initialization",L,this.g);this.c=O(this,b,td)||this.c};td.prototype.parse=function(a,b){this.a=M(this,b,ud)};ud.prototype.parse=function(a,b){this.b=K(b,"t",P);this.a=K(b,"d",P);this.c=K(b,"r",Ed)};
function yd(a,b){if(!b||0===b.length)return a;for(var c=[],d=0;d<b.length;d++){var e=b[d].url;null==a||0===a.length?c.push(new H(e)):(e=zd(a.slice(0,1),e),c.push(e[0]))}return c}function zd(a,b){if(!b)return a;var c=new H(b);return a?a.map(function(a){return a.resolve(c)}):[c]}function Bd(a,b,c){var d=J(c);(b=Fd(b,c.constructor.TAG_NAME))&&d.parse(a,b);return d}function O(a,b,c){var d=null;if(b=Fd(b,c.TAG_NAME))d=new c,d.parse(a,b);return d}
function Fd(a,b){for(var c=null,d=0;d<a.childNodes.length;d++)if(a.childNodes[d].tagName==b){if(c)return null;c=a.childNodes[d]}return c}function M(a,b,c){for(var d=[],e=0;e<b.childNodes.length;e++)if(b.childNodes[e].tagName==c.TAG_NAME){var f=new c;f.parse.call(f,a,b.childNodes[e]);d.push(f)}return d}function Cd(a){a=a.firstChild;return a.nodeType!=Node.TEXT_NODE?null:a.nodeValue}function nd(a){return a?a.map(function(a){return a.clone()}):null}function J(a){return a?a.clone():null}
function K(a,b,c,d){a=c(a.getAttribute(b));return null!=a?a:void 0!==d?d:null}function xd(a){if(!a)return null;a=Date.parse(a);return isNaN(a)?null:Math.floor(a/1E3)}
function wd(a){if(!a)return null;var b=/^P(?:([0-9]*)Y)?(?:([0-9]*)M)?(?:([0-9]*)D)?(?:T(?:([0-9]*)H)?(?:([0-9]*)M)?(?:([0-9.]*)S)?)?$/.exec(a);if(!b)return null;a=0;var c=P(b[1]);c&&(a+=31536E3*c);(c=P(b[2]))&&(a+=2592E3*c);(c=P(b[3]))&&(a+=86400*c);(c=P(b[4]))&&(a+=3600*c);(c=P(b[5]))&&(a+=60*c);b=window.parseFloat(b[6]);(b=isNaN(b)?null:b)&&(a+=b);return a}
function Dd(a){var b=/([0-9]+)-([0-9]+)/.exec(a);if(!b)return null;a=P(b[1]);if(null==a)return null;b=P(b[2]);return null==b?null:new vd(a,b)}function Ed(a){a=window.parseInt(a,10);return isNaN(a)?null:a}function Q(a){a=window.parseInt(a,10);return 0<a?a:null}function P(a){a=window.parseInt(a,10);return 0<=a?a:null}function L(a){return a};function Gd(a,b){this.url=a;this.b=b||new ac;this.g=this.i=this.h=0;this.a=null;this.c=new E;this.f=null}function ac(){this.body=null;this.a=1;this.h=1E3;this.c=0;this.method="GET";this.f="arraybuffer";this.b={};this.g=this.j=!1;this.i=null}var Hd=!0;function Id(a){Jd(a);a.b.body=null;a.c.destroy();a.c=null;a.f=null}function Jd(a){a.a&&(a.a.onload=null,a.a.onreadystatechange=null,a.a.onerror=null,a.a.ontimeout=null);a.a=null}k=Gd.prototype;
k.rb=function(){if(this.a)return this.c;if(0==this.url.lastIndexOf("data:",0)){var a=this.url.split(":")[1].split(";").pop().split(","),b=a.pop(),b="base64"==a.pop()?window.atob(b.replace(/-/g,"+").replace(/_/g,"/")):window.decodeURIComponent(b);"arraybuffer"==this.b.f&&(b=ic(b).buffer);a=JSON.parse(JSON.stringify(new XMLHttpRequest));a.response=b;a.responseText=b.toString();b=this.c;b.resolve(a);Id(this);return b}if(0==this.url.lastIndexOf("idb:",0))return Kd(this);this.h++;this.i=Date.now();this.g||
(this.g=this.b.h);this.a=new XMLHttpRequest;a=this.url;Hd&&(this.f&&!this.f.supportsCaching()||this.b.g)&&(a=new H(a),bd(a.a,"_",Date.now()),a=a.toString());this.a.open(this.b.method,a,!0);this.a.responseType=this.b.f;this.a.timeout=this.b.c;this.a.withCredentials=this.b.j;this.a.onload=this.xb.bind(this);this.b.g&&(this.a.onreadystatechange=this.Eb.bind(this));this.a.onerror=this.Tb.bind(this);this.a.ontimeout=this.Ib.bind(this);for(b in this.b.b)this.a.setRequestHeader(b,this.b.b[b]);this.a.send(this.b.body);
return this.c};function Kd(a){var b=a.url.split("/");return Ub(a.b.i,parseInt(b[2],10),parseInt(b[3],10)).then(F(a,function(a){var b=JSON.parse(JSON.stringify(new XMLHttpRequest));b.response=a;a=this.c;a.resolve(b);Id(this);return a})).catch(F(a,function(a){Id(this);return Promise.reject(a)}))}function Ld(a,b,c){b=Error(b);b.type=c;b.status=a.a.status;b.url=a.url;b.method=a.b.method;b.body=a.b.body;b.xhr=a.a;return b}
k.xb=function(a){this.f&&this.f.sample(Date.now()-this.i,a.loaded);200<=this.a.status&&299>=this.a.status?(this.c.resolve(this.a),Id(this)):this.h<this.b.a?Md(this):(a=Ld(this,"HTTP error.","net"),this.c.reject(a),Id(this))};k.Eb=function(){if(this.a.readyState==XMLHttpRequest.HEADERS_RECEIVED){var a=Date.parse(this.a.getResponseHeader("Date"));a&&(Sa=a-Date.now())}};k.Tb=function(){var a=Ld(this,"Network failure.","net");this.c.reject(a);Id(this)};
k.Ib=function(){if(this.h<this.b.a)Md(this);else{var a=Ld(this,"Request timed out.","net");this.c.reject(a);Id(this)}};function Md(a){Jd(a);window.setTimeout(a.rb.bind(a),a.g*(1+.5*(2*Math.random()-1)));a.g*=2};function G(a,b,c,d){this.b=b;this.f=c||0;this.i=null!=d?d:null;this.c=this.a=null;this.j=a;this.h=null}function Nd(a,b){return a&&0!==a.length?a.map(function(a){return a.resolve(b)}):[b]}function bc(a,b,c){if(a.a)return a.a;b=b||new ac;if(a.f||a.i)b.b.Range="bytes="+(a.f+"-"+(null!=a.i?a.i:""));a.a=Od(a,0,b,c);return a.a}
G.prototype.g=function(){if(this.c){this.a=null;var a=this.c;if(a.a&&a.a.readyState!=XMLHttpRequest.DONE){a.a.abort();var b=Ld(a,"Request aborted.","aborted");a.c.reject(b);Id(a)}this.h=this.c=null}};
function Od(a,b,c,d){var e=a.b[b].toString();a.j&&(e=a.j(e,c.b)||e);a.c=new Gd(e,c);d&&(a.c.f=d);e=a.c.rb().then(F(a,function(a){this.h=this.c=this.a=null;this.h=a.a?new H(a.a):this.b[b];return Promise.resolve(a.response)}));return e=e.catch(F(a,function(a){if(this.a&&b+1<this.b.length)return this.a=Od(this,b+1,c,d);this.a=this.c=null;return Promise.reject(a)}))}G.prototype.clone=function(){return new G(this.j,this.b.map(function(a){return a.clone()}),this.f,this.i)};G.prototype.toString=function(){return this.b[0].toString()};function Pd(a,b){this.a=new ac;this.a.f="text";this.a.a=3;this.a.c=1E3*(null!=b?b:0);this.a.g=!0;this.b=a}function Qd(a){var b=a.b;return bc(b,a.a).then(function(a){var d;d=b.b;var e=[b.h];d=(a=(new DOMParser).parseFromString(a,"text/xml"))?O({hb:d,u:e},a,cd):null;if(d)return Promise.resolve(d);d=Error("MPD parse failure.");d.type="dash";return Promise.reject(d)})};function Rd(a,b,c,d){for(var e=b.a,f=[],g=0;g<d;++g){var h=g+c,l=(h-1)*e.b,m=l/e.a,n=(l+e.b)/e.a,h=Sd(a,b,e.j+h-1,l);if(!h)return null;f.push(new Td(m,n,h))}return f}function Sd(a,b,c,d){if(!b.a)return null;var e=b.a.h;if(!e)return b.u?new G(a,b.u,0,null):null;c=Ud(e,b.id,c,b.bandwidth,d);if(!c)return null;b=Nd(b.u,c);return new G(a,b,0,null)}
function Ud(a,b,c,d,e){var f={RepresentationID:b,Number:c,Bandwidth:d,Time:e};a=a.replace(/\$(RepresentationID|Number|Bandwidth|Time)?(?:%0([0-9]+)d)?\$/g,function(a,b,c){if("$$"==a)return"$";var d=f[b];if(null==d)return a;"RepresentationID"==b&&c&&(c=void 0);a=d.toString();c=window.parseInt(c,10)||1;c=Math.max(0,c-a.length);return Array(c+1).join("0")+a});try{return new H(a)}catch(g){if(g instanceof URIError)return null;throw g;}}
function Vd(a,b,c){var d=0;b*=c;a=a.a;c=[];for(var e=0;e<a.length&&a[e].a;++e){var f=a[e].b,f=null!=f?f:d,g=a[e].c||0;0>g&&(g=a[e].a,g=e+1===a.length?Math.ceil((a[0].b+b-f)/g)-1:Math.ceil((a[e+1].b-f)/g)-1);0<c.length&&f!=d&&(c[c.length-1].end=f);for(var h=0;h<=g;++h)d=f+a[e].a,c.push({start:f,end:d}),f=d}return c};function Wd(a,b){this.a=a;this.b=b||null}Wd.prototype.destroy=function(){this.a&&(this.a.g(),this.a=null);this.b=null};Wd.prototype.create=function(){return this.a?bc(this.a):Promise.resolve(this.b)};function Td(a,b,c){this.b=a;this.a=b;this.url=c}function Xd(a,b,c){return new Td(b,c,a.url)}function cc(a,b){for(var c=a.length-1;0<=c;--c){var d=a[c];if(b>=d.b&&(null==d.a||b<d.a))return c}return-1}function Yd(a,b){return a.map(function(a){return Xd(a,a.b+b,null!=a.a?a.a+b:null)})};function Zd(){}
Zd.prototype.parse=function(a,b,c,d){var e=null;try{a:{var f=[],g=new Ta(a),h=w(g);if(1936286840!=w(g))e=null;else{1==h&&(h=Xa(g));var l=Wa(g);Za(g,3);Za(g,4);var m=w(g);if(0==m)e=null;else{var n,t;0==l?(n=w(g),t=w(g)):(n=Xa(g),t=Xa(g));Za(g,2);var A=g.b.getUint16(g.a,g.c);g.a+=2;a=n;b=b+h+t;for(h=0;h<A;h++){var N=w(g);t=(N&2147483648)>>>31;var l=N&2147483647,I=w(g);w(g);if(1==t){e=null;break a}var wa=new G(d,c,b,b+l-1);f.push(new Td(a/m,(a+I)/m,wa));a+=I;b+=l}e=f}}}}catch(Nb){if(!(Nb instanceof RangeError))throw Nb;
}return e};function R(a){this.o=a;this.i=0}R.prototype.destroy=function(){this.o=null};k=R.prototype;k.length=function(){return this.o.length};function S(a){if(0==a.o.length)throw new RangeError("SegmentIndex: There is no first SegmentReference.");return a.o[0]}k.A=function(){if(0==this.o.length)throw new RangeError("SegmentIndex: There is no last SegmentReference.");return this.o[this.o.length-1]};
k.get=function(a){if(0>a||a>=this.o.length)throw new RangeError("SegmentIndex: The specified index is out of range.");return this.o[a]};k.la=function(a){a=cc(this.o,a);return 0<=a?this.o[a]:null};k.Ha=function(a){$d(this,a);return!0};
function $d(a,b){a.i!=b.i&&(b=new R(Yd(b.o,a.i-b.i)));if(0==a.length())a.o=b.o.slice(0);else if(0!=b.length()&&null!=a.A().a&&!(null!=b.A().a&&b.A().a<a.A().a)){if(a.A().a<=S(b).b)var c=Xd(a.A(),a.A().b,S(b).b),c=a.o.slice(0,-1).concat([c]);else{var d;for(d=0;d<a.o.length&&!(a.o[d].a>=S(b).b);++d);a.o[d].b<S(b).b?(c=Xd(a.o[d],a.o[d].b,S(b).b),c=a.o.slice(0,d).concat([c])):(S(a).b>S(b).b||S(b),c=a.o.slice(0,d))}a.o=c.concat(b.o)}}
k.ka=function(a){var b=a-this.i;if(0==b)return 0;this.o=Yd(this.o,b);this.i=a;return b};k.Ea=function(){return 0<this.length()?{start:S(this).b,end:this.A().a}:{start:0,end:0}};function T(a,b,c,d){R.call(this,a);this.g=b;this.w=c;this.f=d;this.h=this.g.b||this.g.a.reduce(function(a,b){return null==b.a?NaN:a+b.a},0)||0;this.a=this.l=this.c=null;ae(this)}q(T,R);T.prototype.destroy=function(){this.w=this.g=null;R.prototype.destroy.call(this)};T.prototype.la=function(a){be(this,v()/1E3);return R.prototype.la.call(this,a)};T.prototype.Ha=function(a){if(!(a instanceof T))return!1;$d(this,a);this.h=Math.max(this.h,a.h);null==this.c?(this.f=a.f,ae(this)):ce(this);return!0};
function ae(a){ce(a);if(0!=a.length()){a.length();var b=null!=a.A().a?a.A().a:a.A().b;if(a.g.c>a.f)a.c=b;else{var c=a.f-(a.g.c+a.w.start);0>c?a.c=b:c<Math.max(a.A().b,a.A().a||0)?(a.A(),a.c=b):a.c=c}a.l=a.A().b;a.a=S(a).b}}T.prototype.ka=function(a){a=R.prototype.ka.call(this,a);Math.min.apply(null,this.o.filter(function(a){return null!=a.a}).map(function(a){return a.a-a.b}));null!=this.c&&(this.l+=a,this.a+=a,this.c+=a);return a};T.prototype.Ea=function(){return de(this,v()/1E3)};
function de(a,b){be(a,b);if(null==a.c||null==a.l||null==a.a)return{start:0,end:0};var c=Number.POSITIVE_INFINITY;a.h&&(c=a.h);var d=b-a.f,e=a.c+d;null!=a.g.f&&(e=e-a.a-a.g.f,0<e&&(a.a+=e));a.a=Math.min(a.a,c);d=a.l+d;if(d<a.a)return{start:a.a,end:a.a};d=0<a.length()?null!=a.A().a?Math.min(d,a.A().a):d:a.a;d=Math.max(d,a.a);d=Math.min(d,c);return{start:a.a,end:d}}
function be(a,b){ce(a);if(null!=a.g.f)if(null==a.c)a.length();else{for(var c=a.c+(b-a.f),d=0,e=0;e<a.o.length;++e){var f=null;e<a.o.length-1?f=a.o[e+1].a:(f=a.o[e],f=null!=f.a?f.a+(f.a-f.b):null);if(null!=f&&f<c-a.g.f)++d;else break}0<d&&a.o.splice(0,d)}}function ce(a){if(a.h){for(var b=0,c=a.o.length-1;0<=c;--c)if(a.o[c].b>a.h)++b;else break;0<b&&a.o.splice(-b)}};function oe(a,b,c,d,e){var f=1,g=0,h;if(a.c>d)h=null;else{var l=a.i||0,m=a.f||0;h=c.a;h=h.b/h.a;var n=d-(a.c+b.start);0>n?h=null:(m=n-2*h-m,0>m&&(m=0),m=Math.ceil(m/h)*h,n-=h,0>n?h=null:(l=Math.floor(n/h)*h-l,0>l&&(l=0),l=Math.floor(l/h)*h,h={Ya:m/h+1,current:(l>=m?l:m)/h+1}))}h&&(f=h.Ya,g=h.current-h.Ya+1);f=Rd(e,c,f,g);if(null==f)throw (a=Error("Failed to generate SegmentReferences."), a.type="stream", a);T.call(this,f,a,b,d);this.s=c;this.v=this.b=0<this.length()?a.c+b.start+this.A().a:null;this.j=
h?h.current+1:null;this.B=e}q(oe,T);oe.prototype.destroy=function(){this.B=this.s=null;T.prototype.destroy.call(this)};oe.prototype.la=function(a){var b=v()/1E3;pe(this,b);be(this,b);return R.prototype.la.call(this,a)};oe.prototype.Ha=function(a){if(null!=this.b||!(a instanceof oe)||null==a.b)return!1;this.b=a.b;this.v=a.v;this.j=a.j;this.f=a.f;this.h=a.h;$d(this,a);pe(this,v()/1E3);ae(this);return!0};oe.prototype.ka=function(a){a=T.prototype.ka.call(this,a);null!=this.b&&(this.b+=a,this.v+=a);return a};
oe.prototype.Ea=function(){var a=v()/1E3;pe(this,a);return de(this,a)};function pe(a,b){if(null!=a.b&&null!=a.v&&null!=a.j){var c=a.s.a,c=c.b/c.a,d=Math.floor((a.v+(b-a.f)-a.b)/c);if(0!=d){var e=Rd(a.B,a.s,a.j,d);Array.prototype.push.apply(a.o,Yd(e,a.i));a.b+=d*c;a.j+=d}}};function qe(a,b,c,d,e){this.f=a;this.b=b;this.c=c;this.h=d;this.a=null;this.g=e}qe.prototype.destroy=function(){this.g=this.c=this.b=this.f=null;this.a&&(this.a.destroy(),this.a=null)};
qe.prototype.create=function(){if(this.a)return Promise.resolve(this.a);if("dynamic"==this.f.type)try{this.a=new oe(this.f,this.b,this.c,this.h,this.g)}catch(a){return Promise.reject(a)}else{var b;b=this.c.a;if(b=Rd(this.g,this.c,1,Math.ceil(this.b.a/(b.b/b.a)))){if(0<b.length){var c=b[b.length-1];b[b.length-1]=Xd(c,c.b,this.b.a)}b=new R(b)}else b=null;this.a=b;if(!this.a)return (b=Error("Failed to generate SegmentReferences"), b.type="stream", Promise.reject(b))}return Promise.resolve(this.a)};function re(a,b,c,d,e){this.c=a;this.b=b;this.g=c;this.a=null;this.h=d;this.f=e}re.prototype.destroy=function(){this.f=this.g=this.b=this.c=null;this.a&&(this.a.destroy(),this.a=null)};
re.prototype.create=function(){if(this.a)return Promise.resolve(this.a);var a=this.g.b,b=[];a.c&&(b=Vd(a.c,a.f||1,this.b.a||0));var c=0;a.b&&a.i?c=(a.i-1)*a.b:0<b.length&&(c=b[0].start-(a.g||0));var d=a.a.length;0<b.length&&b.length!=a.a.length&&(d=Math.min(b.length,a.a.length));for(var e=[],f=0;f<d;++f){var g=a.a[f],h=c/a.f,l=null,m=null;a.b?(l=c+a.b,m=l/a.f):0<b.length?(l=b[f].end-(a.g||0),m=l/a.f):(m=h+this.b.a,l=m*a.f);var c=l,l=0,n=null;g.a&&(l=g.a.na,n=g.a.end);e.push(new Td(h,m,new G(this.f,
g.b,l,n)))}"dynamic"==this.c.type?this.a=new T(e,this.c,this.b,this.h):this.a=new R(e);return Promise.resolve(this.a)};function se(a,b,c,d,e){this.b=a;this.c=b;this.f=c;this.h=d;this.a=null;this.g=e}se.prototype.destroy=function(){this.g=this.f=this.c=this.b=null;this.a&&(this.a.destroy(),this.a=null)};
se.prototype.create=function(){if(this.a)return Promise.resolve(this.a);for(var a=this.f.a,b=Vd(a.c,a.a||1,this.c.a||0),c=[],d=0;d<b.length;++d){var e=b[d].start,f=e/a.a,g=b[d].end/a.a,e=Sd(this.g,this.f,d+a.j,e);if(!e)return (a=Error("Failed to generate media URL."), a.type="dash", Promise.reject(a));var h=(a.i||0)/a.a;c.push(new Td(f-h,g-h,e))}"dynamic"==this.b.type?this.a=new T(c,this.b,this.c,this.h):this.a=new R(c);return Promise.resolve(this.a)};function te(a){this.b=a;this.a=null}te.prototype.destroy=function(){this.b=null;this.a&&(this.a.destroy(),this.a=null)};te.prototype.create=function(){if(this.a)return Promise.resolve(this.a);for(var a=[],b=0;b<this.b.length;++b){var c=this.b[b];a.push(new Td(c.start_time,c.end_time,new G(null,[new H(c.url)],c.start_byte,null)))}this.b=null;this.a=new R(a);return Promise.resolve(this.a)};function ue(){this.C=ve++;this.id=this.H=this.I=null;this.c=0;this.height=this.width=this.bandwidth=null;this.b=this.a="";this.f=[];this.N=!1;this.J=!0}var ve=0;ue.prototype.destroy=function(){this.I&&(this.I.destroy(),this.I=null);this.H&&(this.H.destroy(),this.H=null)};function we(a){var b=a.a||"";a.b&&(b+='; codecs="'+a.b+'"');return b}function xe(){this.C=ye++;this.id=null;this.contentType=this.lang="";this.b=!1;this.m=[];this.a=[]}var ye=0;
xe.prototype.destroy=function(){for(var a=0;a<this.m.length;++a)this.m[a].destroy();this.a=this.m=null};function ze(a){for(var b=[],c=0;c<a.a.length;++c){var d=new Ae;d.id=a.C;d.a=a.a[c];d.contentType=a.contentType;d.b=a.m.length?we(a.m[0]):"";b.push(d)}return b}function Be(){this.id=null;this.start=0;this.b=null;this.a=[]}Be.prototype.destroy=function(){for(var a=0;a<this.a.length;++a)this.a[a].destroy();this.a=null};function Ce(){this.b=!1;this.h=this.g=this.f=null;this.c=0;this.a=[]}
Ce.prototype.destroy=function(){for(var a=0;a<this.a.length;++a)this.a[a].destroy();this.a=null};function Ae(){this.id=0;this.a=null;this.b=this.contentType=""};function De(a,b,c,d,e){D.call(this,a);this.c=b;this.a=new Vb(c,d,e);this.w=this.G=this.b=null;this.K=!1;this.g=null;this.l=!1;this.i=null;this.s=!1;this.h=new E;this.j=this.f=!1;this.B=0;this.L=15;this.D=!1}q(De,D);De.prototype.F=function(a){null!=a.initialStreamBufferSize&&(this.B=Number(a.initialStreamBufferSize));null!=a.streamBufferSize&&(this.L=Number(a.streamBufferSize));null!=a.segmentRequestTimeout&&(this.a.s=Number(a.segmentRequestTimeout))};
De.prototype.destroy=function(){Ee(this);this.h.destroy();this.b=this.h=null;this.a.destroy();this.v=this.c=this.a=null};k=De.prototype;k.oa=function(){return this.b};k.bb=function(){return this.G};k.sb=function(a){this.f||a.then(function(){this.f=!0;this.g||Fe(this,0)}.bind(this)).catch(function(){});return this.h};k.Ga=function(){return this.j};
k.ra=function(a,b,c){if(a!=this.b){var d=[a.I.create(),a.H.create()];Promise.all(d).then(F(this,function(d){if(this.c){var f=this.b;this.b=a;this.G=d[0];this.w=d[1];this.K=!0;this.l||(f?b&&Ge(this,!0,c):Fe(this,0))}})).catch(F(this,function(a){"aborted"!=a.type&&(this.f?(a=y(a),this.dispatchEvent(a)):this.h.reject(a))}))}};k.jb=function(){return Ge(this,!1)};
function Ge(a,b,c){a.b&&!a.l&&(a.l=!0,Ee(a),Xb(a.a).then(F(a,function(){var a=this.c.currentTime;if(!b&&0<Yb(this.a,a)&&0<=cc(this.a.b,a))return Promise.resolve();if(c)return fc(this.a,this.c.currentTime+c);this.D=!0;return ec(this.a)})).then(F(a,function(){this.l=!1;Fe(this,0)})).catch(F(a,function(a){this.l=!1;this.f?(a=y(a),this.dispatchEvent(a)):this.h.reject(a)})))}k.kb=function(a){return 0<Yb(this.a,a)&&0<=cc(this.a.b,a)};k.va=function(){};k.Da=function(){return!0};
k.Kb=function(){if(this.s&&!this.f)this.g=null;else{var a;if(a=this.f&&!this.j)a=1<this.a.c.buffered.length?!0:!1;if(a)Ge(this,!0);else{this.g=null;a=this.b;var b=this.G,c=this.c.currentTime;Yb(this.a,this.s?c:c+(this.i||0))>=(this.s?Math.max(this.B,this.L):this.B)?(He(this),Fe(this,1E3/(Math.abs(this.c.playbackRate)||1))):(b=Ie(this,c,b))?(b=Zb(this.a,b,a.c,this.w),this.w=null,this.K&&(this.K=!1,Je(this,a)),this.j=!1,b.then(F(this,function(a){null==this.i&&(this.i=a);this.D&&0<Yb(this.a,c)&&(this.D=
!1,this.c.currentTime+=.001);Fe(this,0)})).catch(F(this,function(a){if("aborted"!=a.type){var b=[0,404,410];"net"==a.type&&-1!=b.indexOf(a.xhr.status)&&this.b&&Fe(this,5E3);a=y(a);this.dispatchEvent(a)}}))):(He(this),this.f&&!this.j&&(this.j=!0,Ke(this)),Fe(this,1E3))}}};function Ie(a,b,c){a=a.a;var d=a.b.length;a=0<d?a.b[d-1]:null;return null!=a?null!=a.a?c.la(a.a):null:c.la(b)||(c.length()?c.A():null)}
function He(a){if(!a.s&&null!=a.i){a.s=!0;var b=a.a,c=a.i,d=c-b.w;0!=d&&(b.b=Yd(b.b,d),b.w=c);a.h.resolve(a.i)}}function Je(a,b){var c;c=b.a.split("/")[0];c=x({type:"adaptation",bubbles:!0,contentType:c,size:"video"!=c?null:{width:b.width,height:b.height},bandwidth:b.bandwidth});a.dispatchEvent(c)}function Ke(a){var b=x({type:"ended"});a.dispatchEvent(b)}function Fe(a,b){a.g=window.setTimeout(a.Kb.bind(a),b)}function Ee(a){null!=a.g&&(window.clearTimeout(a.g),a.g=null)};function Le(a){this.b=a;this.a=null}Le.prototype.destroy=function(){this.a&&(this.a.destroy(),this.a=null)};Le.prototype.create=function(){if(this.a)return Promise.resolve(this.a);var a=new Td(0,null,this.b);this.a=new R([a]);return Promise.resolve(this.a)};function Me(a,b){D.call(this,a);this.b=b;this.g=!0;this.h=this.f=null;this.c=new E;this.a=null}q(Me,D);Me.prototype.F=function(){};Me.prototype.destroy=function(){this.a&&this.b.removeChild(this.a);this.c.destroy();this.v=this.b=this.f=this.h=this.a=this.c=null};k=Me.prototype;k.oa=function(){return this.f};k.bb=function(){return this.h};k.sb=function(){return this.c};k.Ga=function(){return!0};
k.ra=function(a){a.I.create().then(F(this,function(b){if(this.b){if(0==b.length())return Promise.reject(Error("No subtitles URL available."));var c=this.f;this.f=a;this.h=b;b=S(b).url.b[0].toString();var d=this.Da();this.a&&(this.va(!1),this.b.removeChild(this.a));this.a=document.createElement("track");this.b.appendChild(this.a);this.a.src=b;this.va(d);b=x({type:"adaptation",bubbles:!0,contentType:"text",size:null,bandwidth:a.bandwidth});this.dispatchEvent(b);c||this.c.resolve(0)}}))};k.jb=function(){};
k.kb=function(){return!0};k.va=function(a){this.g=a;this.a&&(this.a.track.mode=a?"showing":"disabled")};k.Da=function(){this.a&&(this.g="showing"==this.a.track.mode);return this.g};function Ne(){}
Ne.prototype.parse=function(a,b,c,d){var e=null;try{var f;var g=new $a(b);if(440786851!=bb(g).id)f=null;else{var h=bb(g);if(408125543!=h.id)f=null;else{var l=h.a.byteOffset,m;var n=new $a(h.a);for(b=null;Va(n.a);){var t=bb(n);if(357149030==t.id){b=t;break}}if(b){for(var A=new $a(b.a),n=1E6;Va(A.a);){var N=bb(A);if(2807729==N.id){n=fb(N);break}}m=n/1E9}else m=null;f=m?{Qb:l,Ub:m}:null}}if(f){var I=bb(new $a(a));if(475249515!=I.id)e=null;else{var wa=f.Qb,Nb=f.Ub;a=[];var ee=new $a(I.a);for(f=I=-1;Va(ee.a);){var fe=
bb(ee);if(187==fe.id){var Ia;var ge=new $a(fe.a),he=bb(ge);if(179!=he.id)Ia=null;else{var Cf=fb(he),ie=bb(ge);if(183!=ie.id)Ia=null;else{for(var je=new $a(ie.a),l=0;Va(je.a);){var ke=bb(je);if(241==ke.id){l=fb(ke);break}}Ia={Wb:Cf,Pb:l}}}if(Ia){var le=Nb*Ia.Wb,me=wa+Ia.Pb;if(0<=I){var Uc=new G(d,c,f,me-1);a.push(new Td(I,le,Uc))}I=le;f=me}}}0<=I&&(Uc=new G(d,c,f,null),a.push(new Td(I,null,Uc)));e=a}}else e=null}catch(ne){if(!(ne instanceof RangeError))throw ne;}return e};function Oe(a,b,c,d,e,f,g){this.g=a;this.i=b;this.f=c;this.a=d;this.c=e;this.j=f;this.b=null;this.h=g}Oe.prototype.destroy=function(){this.h=this.i=this.g=null;this.a.g();this.a=null;this.c&&(this.c.g(),this.c=null);this.b=null};
Oe.prototype.create=function(){if(this.b)return this.b;var a=[bc(this.a)];"webm"==this.f&&a.push(bc(this.c));return this.b=Promise.all(a).then(F(this,function(a){var c=a[0];a=a[1]||null;var d=null;"mp4"==this.f?(d=new Zd,d=d.parse(new DataView(c),this.a.f,this.a.b,this.h)):"webm"==this.f&&(d=new Ne,d=d.parse(new DataView(c),new DataView(a),this.a.b,this.h));if(!d)return (c=Error("Failed to parse SegmentReferences from "+this.a.toString()+" (or one of its fallbacks)."), c.type="stream", Promise.reject(c));
var e;"dynamic"==this.g.type?e=new T(d,this.g,this.i,this.j):e=new R(d);return Promise.resolve(e)}))};function Pe(a){this.a=a}
function Qe(a,b,c){for(var d=v()/1E3,e=0;e<b.a.length;++e)for(var f=b.a[e],g=0;g<f.b.length;++g){var h=f.b[g];if("text"!=h.contentType)for(var l=0;l<h.a.length;++l){var m=h.a[l],n=0,n=n+(m.g?1:0),n=n+(m.b?1:0),n=n+(m.a?1:0);0==n?(h.a.splice(l,1),--l):1!=n&&(m.g?(m.b=null,m.a=null):m.b&&(m.a=null))}}Re(b);for(e=0;e<b.a.length;++e)for(f=b.a[e],g=0;g<f.b.length;++g){l=h=f.b[g];m=null;for(n=0;n<l.a.length;++n){var t=l.a[n].f||"";m?t!=m&&(l.a.splice(n,1),--n):m=t}0==h.a.length&&(f.b.splice(g,1),--g)}"dynamic"==
b.type&&null==b.c&&(b.c=d);e=new Ce;"dynamic"==b.type&&(e.b=!0,e.f=b.g,e.g=new G(c,b.j||b.url),e.h=b.c);e.c=b.h||5;for(f=0;f<b.a.length;++f){g=b.a[f];if(null==g.start)break;g=Se(a,b,g,d,c);e.a.push(g)}return e}
function Re(a){if(a.a.length){null==a.a[0].start&&(a.a[0].start=0);var b=function(a){return 0==a||!!a};"dynamic"==a.type&&(a.b=null);b(a.b)&&1==a.a.length&&!b(a.a[0].a)&&(a.a[0].a=a.b);for(var c=0,d=!0,e=0;e<a.a.length;++e){var f=a.a[e-1],g=a.a[e],h=a.a[e+1]||{start:a.b};!b(g.start)&&f&&b(f.start)&&b(f.a)&&(g.start=f.start+f.a);!b(g.a)&&b(h.start)&&(g.a=h.start-g.start);null!=g.start&&null!=g.a?c+=g.a:d=!1}b(a.b)||(e=a.a[a.a.length-1],d?a.b=c:b(e.start)&&b(e.a)?a.b=e.start+e.a:"dynamic"!=a.type&&
(a.b=c))}}function Se(a,b,c,d,e){var f=new Be;f.id=c.id;f.start=c.start;f.b=c.a;var g=new z;c.b.forEach(function(a){g.push(a.contentType||"",a)});for(var h=wb(g),l=0;l<h.length;++l){var m=new z;g.get(h[l]).forEach(function(a){m.push(a.group,a)});for(var n=wb(m),t=0;t<n.length;++t){var A=new z;m.get(n[t]).forEach(function(a){A.push(a.lang,a)});for(var N=wb(A),I=0;I<N.length;++I){var wa=A.get(N[I]),wa=Te(a,b,c,wa,d,e);f.a.push(wa)}}}return f}
function Te(a,b,c,d,e,f){ba(d.every(function(a){return a.group==d[0].group&&(a.lang||"")==(d[0].lang||"")&&(a.contentType||"")==(d[0].contentType||"")}));var g=new xe,h=d.filter(function(a){return null!=a.id});h.length==d.length&&(g.id=h.map(function(a){return a.id}).sort().reduce(function(a,b){return a+","+b}));g.lang=d[0].lang||"";g.contentType=d[0].contentType||"";g.b=d.some(function(a){return a.c});for(var h={},l=0;l<d.length;++l)for(var m=d[l],n=0;n<m.a.length;++n){var t=m.a[n],A=Ue(a,t),N=g.a.slice(0);
Ve(A,N);0==N.length&&0<g.a.length||!(t=We(b,c,t,e,f))||(g.m.push(t),g.a=N,h[t.C]=m)}if(g.a.some(function(a){return""==a.a}))return (g.m.forEach(function(a){a.N=!0}), g);a=Xe(d);for(l=0;l<g.m.length;++l)t=g.m[l],m=h[t.C],m==a&&(t.N=!0);return g}function Xe(a){for(var b=null,c=null,d=0;d<a.length;++d)for(var e=a[d],f=0;f<e.a.length;++f){var g=e.a[f],g=(g.width||1)*(g.height||1)*(g.bandwidth||1);if(null==b||g<b)b=g,c=e}return c}
function Ve(a,b){if(0==b.length)Array.prototype.push.apply(b,a);else for(var c=0;c<b.length;++c){for(var d=!1,e=0;e<a.length;++e){var f=b[c],g=a[e];if(f.a==g.a&&f.h==g.h&&f.i==g.i&&f.g==g.g&&f.v==g.v&&f.f==g.f&&f.j==g.j&&db(f.c,g.c)){d=!0;oc(b[c],a[e].b);break}}d||(b.splice(c,1),--c)}}function Ue(a,b){var c=[];if(0==b.c.length)c.push(new lc);else if(a.a)for(var d=0;d<b.c.length;++d)c.push.apply(c,Ye(a,b.c[d]));return c}
function Ye(a,b){var c=[];if(2!=a.a.length)return[];var d=a.a(b.c||"",b.f);if(!(d&&d instanceof Array))return[];for(var e=0;e<d.length;++e){var f=mc(d[e]);0==f.b.length&&b.a&&b.a.psshBox&&oc(f,[{initData:b.a.psshBox,initDataType:"cenc"}]);c.push(f)}return c}
function We(a,b,c,d,e){if(!c.u||0===c.u.length)return null;var f=null,g=1,h=0;if(c.g)f=c.f.split("/")[1],"mp4"!=f&&"webm"!=f?f=null:(g=c.g,"webm"!=f||g.c?g.a||g.b&&g.b.a?(h=g.b,h||(h=new od,h.url=c.u,h.a=g.a?g.a.clone():null),h=Ze(h,e),g=g.c?Ze(g.c,e):null,a=new Oe(a,b,f,h,g,d,e),b=new Wd(g),d=new ue,d.I=a,d.H=b,f=d):f=null:f=null),g=c.g.g,h=c.g.f;else if(c.b)f=c.b,!f.b&&!f.c&&1<f.a.length?f=null:f.b||b.a||f.c||1!=f.a.length?f.c&&0===f.c.a.length?f=null:(f=f.h?Ze(f.h,e):null,a=new re(a,b,c,d,e),b=
new Wd(f),d=new ue,d.I=a,d.H=b,f=d):f=null,g=c.b.f,h=c.b.g;else if(c.a){a:if(f=c.a,g=0+(f.f?1:0),g+=f.c?1:0,g+=f.b?1:0,0==g?g=!1:(1!=g&&(f.f?(f.c=null,f.b=null):f.c&&(f.b=null)),g=!0),g){g=null;if(f.g&&(g=(f=c.a.g)?$e(c,f,pd):null,!g)){f=null;break a}f=g?Ze(g,e):null;g=c.a;g.f?(g=c.f.split("/")[1],"mp4"!=g&&"webm"!=g?a=null:"webm"!=g||f?Sd(e,c,1,0)?(h=(h=c.a.f)?$e(c,h,od):null)?(h=Ze(h,e),a=new Oe(a,b,g,h,f,d,e)):a=null:a=null:a=null):a=g.h?g.c?new se(a,b,c,d,e):g.b?"dynamic"!=a.type&&null==b.a?null:
new qe(a,b,c,d,e):null:null;a?(b=new Wd(f),d=new ue,d.I=a,d.H=b,f=d):f=null}else f=null;g=c.a.a;h=c.a.i}else"text"==c.f.split("/")[0]&&(f=new ue,f.I=new Le(new G(e,c.u)));if(!f)return null;f.id=c.id;h&&(f.c=-1*h/g);f.bandwidth=c.bandwidth;f.width=c.width;f.height=c.height;f.a=c.f||"";f.b=c.h||"";for(a=0;a<c.c.length;++a)b=c.c[a],b.b&&f.f.push(b.b);return f}function $e(a,b,c){b=Ud(b,a.id,null,a.bandwidth,null);if(!b)return null;c=new c;c.url=Nd(a.u,b);return c}
function Ze(a,b){var c=a.url,d=0,e=null;a.a&&(d=a.a.na,e=a.a.end);return new G(b,c,d,e)};function af(){this.streamStats=null;this.droppedFrames=this.decodedFrames=NaN;this.bufferingTime=this.playTime=this.estimatedBandwidth=0;this.playbackLatency=NaN;this.bufferingHistory=[];this.bandwidthHistory=[];this.streamHistory=[]}function bf(a,b){var c=new cf(b);a.streamHistory.push(new df(c));if(c.videoHeight||!a.streamStats)a.streamStats=c}function cf(a){this.videoWidth=a.width;this.videoHeight=a.height;this.videoMimeType=a.a;this.videoBandwidth=a.bandwidth}
function df(a){this.timestamp=v()/1E3;this.value=a};function ef(a,b){Gb.call(this,"readwrite",b);this.j=a;this.b=0}q(ef,Gb);
function ff(a,b,c,d,e){for(var f=[],g=[],h=0,l=0,m=[],n=b.map(function(a){return a.I.create()}),n=Promise.all(n),t=b.map(function(a){return a.H.create()}),t=Promise.all(t),n=Promise.all([n,t]).then(function(a){f=a[0];g=a[1];h=f.reduce(function(a,b){return a+b.length()},0)}),t=0;t<b.length;++t)n=n.then(function(a){return gf(this,b[a],f[a],g[a],h,l)}.bind(a,t)),n=n.then(function(a,b){l+=f[a].length();m.push(b)}.bind(a,t));return n.then(F(a,function(){return hf(Ob(this))})).then(F(a,function(a){var b=
new E;c=Ra(c);var f={group_id:a,stream_ids:m,session_ids:c,duration:d,key_system:e.a,license_server:e.h,with_credentials:e.i,distinctive_identifier:e.g,audio_robustness:e.f,video_robustness:e.j},g=Ob(this).put(f);g.onsuccess=function(){b.resolve(a)};g.onerror=function(){b.reject(g.error)};return b}))}function jf(a,b){return Pb(Ob(a),b).then(F(a,function(a){var d=[],e;for(e in a.stream_ids)d.push(kf(this,a.stream_ids[e]));a=Ob(this);d.push(a.delete(b));return Promise.all(d)}))}
function gf(a,b,c,d,e,f){var g=[hf(Mb(a)),hf(Kb(a).index("stream"))],g=Promise.all(g).then(F(a,function(a){return{qa:Math.max(a[0],a[1]),ja:new ArrayBuffer(0),Ja:0,o:[],Ca:null,Vb:e,ib:f}})),g=g.then(a.f.bind(a,c));return g=g.then(a.g.bind(a,b,d))}function hf(a){var b=new E,c=a.openCursor(null,"prev");c.onsuccess=function(a){a.target.result?b.resolve(a.target.result.key+1):b.resolve(0)};c.onerror=function(){b.reject(c.error)};return b}
ef.prototype.g=function(a,b,c){var d=new E;a={stream_id:c.qa,mime_type:a.a,codecs:a.b,init_segment:b,references:c.o};var e=Mb(this).put(a);e.onsuccess=function(){d.resolve(c.qa)};e.onerror=function(){d.reject(e.error)};return d};ef.prototype.f=function(a,b){for(var c=Promise.resolve(),d=0;d<a.length();++d)var e=a.get(d),f=d==a.length()-1,f=this.c.bind(this,e,b,f),c=c.then(this.i.bind(this,e)),c=c.then(f);return c.then(function(){return Promise.resolve(b)}).catch(F(this,function(a){kf(this,b.qa);return Promise.reject(a)}))};
ef.prototype.c=function(a,b,c,d){var e=new E;0==b.ja.byteLength&&(b.Ca=a);b.ja=lf(b.ja,d);b.ib++;var f=x({type:"progress",detail:b.ib/b.Vb*100,bubbles:!0});if(1048576<=b.ja.byteLength||c){c={stream_id:b.qa,segment_id:b.Ja,content:b.ja};var g=Kb(this).put(c);b.o.push({start_time:b.Ca.b,start_byte:b.Ca.url.f,end_time:a.a,url:"idb://"+b.qa+"/"+b.Ja});b.Ja++;b.ja=new ArrayBuffer(0);g.onerror=function(){e.reject(g.error)};g.onsuccess=F(this,function(){this.dispatchEvent(f);e.resolve()})}else this.dispatchEvent(f),
e.resolve();return e};function lf(a,b){var c=new Uint8Array(a.byteLength+b.byteLength);c.set(new Uint8Array(a),0);c.set(new Uint8Array(b),a.byteLength);return c.buffer}ef.prototype.i=function(a){var b=new ac;b.c=1E3*this.b;return bc(a.url,b,this.j)};
function kf(a,b){var c=new E,d=Mb(a).delete(b);d.onerror=function(){c.reject(d.error)};var e=Kb(a);e.index("stream").openKeyCursor(IDBKeyRange.only(b)).onsuccess=function(a){if(a=a.target.result)e.delete(a.primaryKey),a.continue()};e.transaction.oncomplete=function(){c.resolve()};return c};function mf(a,b,c,d,e,f){this.b=new G(null,[new H(a)]);this.a=new ac;this.a.body=b;this.a.method=c;this.a.a=3;this.a.j=d;this.a.c=1E3*(null!=f?f:0);a=e||{};for(var g in a)this.a.b[g]=a[g]}function nf(a){return bc(a.b,a.a).then(function(a){return Promise.resolve(new Uint8Array(a))})};function U(a,b,c){D.call(this,a);this.h=b;this.b=c;this.a=this.i=null;this.l=new B;this.c=[];this.f=[];this.s=0;this.g=new E;this.j=null;this.w=0}q(U,D);U.prototype.destroy=function(){this.v=null;for(var a=0;a<this.f.length;++a)this.f[a].close().catch(function(){});this.f=[];this.c=this.a=this.i=null;this.g.destroy();this.g=null;this.l.destroy();this.l=null;this.j&&(window.clearTimeout(this.j),this.j=null);this.h=this.b=null};
U.prototype.initialize=function(){for(var a=new z,b=this.b.ab(),c=0;c<b.length;++c){var d=b[c];d.a.a||d.b&&!of(d.b)||a.push(d.contentType,d)}for(var c={},d=!1,e=0;e<b.length;++e){var f=b[e];if(f.a.a&&!a.a.hasOwnProperty(f.contentType)){var g=f.a.a,h=c[g];h||(h=f.a,h={audioCapabilities:void 0,videoCapabilities:void 0,initDataTypes:void 0,distinctiveIdentifier:h.g?"required":"optional",persistentState:h.v||this.b.ha()?"required":"optional",sessionTypes:[this.b.ha()?"persistent-license":"temporary"]},
c[g]=h);if(f.b&&(g=f.contentType+"Capabilities",g in h)){d=!0;h[g]||(h[g]=[]);var l;"audio"==f.contentType?l=f.a.f:"video"==f.contentType&&(l=f.a.j);h[g].push({contentType:f.b,robustness:l})}}}if(!d)if(b.length)this.a=b[0].a;else throw (a=Error("No DrmInfo exists!"), a.type="drm", a);if(0==Object.keys(c).length)return (this.b.Ka(a), this.g.resolve(), Promise.resolve());l=new E;c=pf(this,c,l);c=c.then(this.D.bind(this,b,a));l.reject(null);return c};
function qf(a,b){null==a.j&&(a.j=window.setTimeout(function(){var a=Error("Timeout waiting for sessions.");a.type="storage";this.g.reject(a)}.bind(a),b));return a.g}function rf(a){return Promise.all(a.f.map(function(a){return a.remove()}))}
function pf(a,b,c){for(var d in b)c=c.catch(function(a,b){return navigator.requestMediaKeySystemAccess(a,[b])}.bind(null,d,b[d]));a.b.ha()&&(c=c.catch(function(){throw Error("Either none of the requested key systems are supported or none of the requested key systems support persistent state.");}));return c}
U.prototype.D=function(a,b,c){if(!this.h)return sf();for(var d=c.keySystem,e=c.getConfiguration(),f=["audio","video"],g=0;g<f.length;++g){var h=f[g];if(!b.a.hasOwnProperty(h)){var l=e[h+"Capabilities"];if(l){for(var l=l[0],m=[],n={},t=0;t<a.length;++t){var A=a[t],N=l?A.b==l.contentType:A.contentType==h;A.a.a!=d||!N||A.id in n||(m.push(A),n[A.id]=!0,this.a=this.a?nc(this.a,A.a):A.a)}b.set(h,m)}}}this.b.Ka(b);return c.createMediaKeys().then(function(a){this.i=a}.bind(this))};
function tf(a){return a.h?a.i?a.h.setMediaKeys(a.i).then(F(a,function(){return this.h?this.a.c?this.i.setServerCertificate(this.a.c):Promise.resolve():sf()})).then(F(a,function(){if(!this.h)return sf();if(0<this.b.ua().length)uf(this);else{for(var a=0;a<this.a.b.length;++a){var c=this.a.b[a];this.B({type:"encrypted",initDataType:c.initDataType,initData:c.initData})}0==this.a.b.length&&C(this.l,this.h,"encrypted",this.B.bind(this))}})):Promise.resolve():sf()}
function sf(){var a=Error("EmeManager destroyed");a.type="destroy";return Promise.reject(a)}
U.prototype.B=function(a){for(var b=new Uint8Array(a.initData),c=0;c<this.c.length;++c)if(db(b,this.c[c].data))return;try{var d=vf(this)}catch(e){b=y(e);this.dispatchEvent(b);this.g.reject(e);return}a=d.generateRequest(a.initDataType,a.initData);this.c.push({data:b,La:d});a.catch(F(this,function(a){if(this.h){for(var b=0;b<this.c.length;++b)if(this.c[b].La==d){this.c.splice(b,1);break}b=y(a);this.dispatchEvent(b);this.g.reject(a)}}));this.f.push(d)};
function uf(a){for(var b=a.b.ua(),c=0;c<b.length;++c){var d=vf(a),e=d.load(b[c]);a.f.push(d);e.then(F(a,function(){this.s++;this.s>=this.f.length&&this.g.resolve()})).catch(F(a,function(a){a=y(a);this.dispatchEvent(a)}))}}
function vf(a){var b=null;if(a.b.ha())try{b=a.i.createSession("persistent-license")}catch(c){throw Error("Persistent licenses are not supported by this key system or platform.");}else b=a.i.createSession();C(a.l,b,"message",a.G.bind(a));C(a.l,b,"keystatuseschange",a.F.bind(a));return b}U.prototype.G=function(a){wf(this,a.target,this.a,a.message)};
U.prototype.F=function(a){a=a.target;var b={};a.keyStatuses.forEach(function(a,c){if("string"==typeof a){var f=a;a=c;c=f}if("com.microsoft.playready"==this.a.a&&16==a.byteLength){var f=new DataView(a),g=f.getUint32(0,!0),h=f.getUint16(4,!0),l=f.getUint16(6,!0);f.setUint32(0,g,!1);f.setUint16(4,h,!1);f.setUint16(6,l,!1)}f=kc(new Uint8Array(a));b[f]=c}.bind(this));if(a.expiration<Date.now()){for(var c=0;c<this.c.length;++c)if(this.c[c].La==a){this.c.splice(c,1);break}a.close();this.f.splice(this.f.indexOf(a),
1)}this.b.cb(b)};function wf(a,b,c,d){d=xf(c,d);nf(new mf(d.url,d.body,d.method,c.i,d.headers,a.w)).then(F(a,function(a){c.l&&(a=c.l(a));return b.update(a)})).then(F(a,function(){var a=x({type:"sessionReady",detail:b});this.dispatchEvent(a);this.s++;this.s>=this.f.length&&this.g.resolve()})).catch(F(a,function(a){a.La=b;a=y(a);this.dispatchEvent(a)}))}
function xf(a,b){var c={url:a.h,body:b.slice(0),method:"POST",headers:{}};if("com.microsoft.playready"===a.a){for(var d=String.fromCharCode.apply(null,new Uint16Array(c.body)),d=(new DOMParser).parseFromString(d,"application/xml"),e=d.getElementsByTagName("name"),f=d.getElementsByTagName("value"),g=0;g<e.length;g++)c.headers[e[g].childNodes[0].nodeValue]=f[g].childNodes[0].nodeValue;c.body=window.atob(d.getElementsByTagName("Challenge")[0].childNodes[0].nodeValue)}if(!a.s)return c;a.s(c);c.url=sb(c,
"url");if(null==c.url)throw Error("'url' cannot be null.");if(!(c.body instanceof ArrayBuffer||"string"==typeof c.body||null==c.body))throw new TypeError("'body' must be an ArrayBuffer, a string, or null.");c.method=sb(c,"method");if("GET"!=c.method&&"POST"!=c.method)throw Error("'method' must be either 'GET' or 'POST'.");c.headers=tb(c,"headers",Object);if(null==c.headers)throw Error("'headers' cannot be null.");return c};function V(a){D.call(this,null);this.a=a;this.b=null;this.f=new B;this.j=this.i=null;this.D=0;this.w=null;this.h=!1;this.g=new af;this.c={enableAdaptation:!0,streamBufferSize:15,liveStreamEndTimeout:15,licenseRequestTimeout:0,mpdRequestTimeout:0,segmentRequestTimeout:0,preferredLanguage:"en",restrictions:new ja};this.l=1;this.F=null}q(V,D);p("shaka.player.Player",V);V.version="v1.6.5";
V.isBrowserSupported=function(){return!!window.MediaSource&&!!window.MediaKeys&&!!window.navigator&&!!window.navigator.requestMediaKeySystemAccess&&!!window.MediaKeySystemAccess&&!!window.MediaKeySystemAccess.prototype.getConfiguration&&!!window.Promise&&!!Element.prototype.requestFullscreen&&!!document.exitFullscreen&&"fullscreenElement"in document&&!!window.Uint8Array};function of(a){return"text/vtt"==a?!!window.VTTCue:MediaSource.isTypeSupported(a)}V.isTypeSupported=of;
V.setTextStyle=function(a){var b=document.getElementById("ShakaPlayerTextStyle");b||(b=document.createElement("style"),b.id="ShakaPlayerTextStyle",document.head.appendChild(b));for(b=b.sheet;b.cssRules.length;)b.deleteRule(0);b.insertRule("::cue { "+oa(a)+" }",0)};V.prototype.destroy=function(){return this.s().then(F(this,function(){this.f.destroy();this.a=this.f=null})).catch(function(){})};V.prototype.destroy=V.prototype.destroy;
V.prototype.s=function(){if(!this.b)return Promise.resolve();this.h&&yf(this);this.a.pause();xb(this.f);zf(this);Af(this);this.i&&(this.i.destroy(),this.i=null);this.a.src="";var a=this.a.setMediaKeys(null);this.b&&(this.b.destroy(),this.b=null);this.h=!1;this.g=new af;return a};V.prototype.unload=V.prototype.s;
V.prototype.ea=function(a){var b=this.s();this.a.autoplay&&(da("load"),C(this.f,this.a,"timeupdate",this.wb.bind(this)));a.T(this.c);a.pb(this.F);this.F=null;b=b.then(F(this,function(){return a.X()}));b.catch(F(this,function(b){a.destroy();return Promise.reject(b)}));return b.then(F(this,function(){if(!this.a)return Bf();this.b=a;C(this.f,this.b,"seekrangechanged",this.Fb.bind(this));this.i=new U(this,this.a,this.b);return this.i.initialize()})).then(F(this,function(){if(!this.a)return Bf();C(this.f,
this.a,"error",this.Rb.bind(this));C(this.f,this.a,"playing",this.Db.bind(this));C(this.f,this.a,"pause",this.Cb.bind(this));return this.b.lb(this,this.a)})).then(F(this,function(){return this.a?tf(this.i):Bf()})).then(F(this,function(){if(!this.a)return Bf();Df(this)})).catch(F(this,function(a){if(!this.a)return Bf();if("destroy"!=a.type){var b=y(a);this.dispatchEvent(b)}return this.s().then(function(){return Promise.reject(a)})}))};V.prototype.load=V.prototype.ea;
function Bf(){var a=Error("Player destroyed");a.type="destroy";return Promise.reject(a)}k=V.prototype;k.wb=function(){ga("load");this.g.playbackLatency=ha("load")/1E3;this.f.sa(this.a,"timeupdate")};k.Rb=function(){if(this.a.error){var a=this.a.error.code;a!=MediaError.MEDIA_ERR_ABORTED&&(a=Error(Ef[a]||"Unknown playback error."),a.type="playback",a=y(a),this.dispatchEvent(a))}};
k.Db=function(){da("playing");!this.j&&0>this.l&&(this.a.playbackRate=0,this.B(this.a.currentTime,Date.now(),this.l));this.h&&yf(this)};k.Cb=function(){ga("playing");var a=ha("playing");if(!isNaN(a)){var b=this.g;b.playTime+=a/1E3}Af(this)};k.Fb=function(a){this.D=a.start};
k.qb=function(){if(!this.a.paused){ga("playing");var a=ha("playing");if(!isNaN(a)){var b=this.g;b.playTime+=a/1E3;da("playing")}}a=this.g;b=this.a;b.getVideoPlaybackQuality&&(b=b.getVideoPlaybackQuality(),a.decodedFrames=b.totalVideoFrames,a.droppedFrames=b.droppedVideoFrames);return this.g};V.prototype.getStats=V.prototype.qb;V.prototype.da=function(){return this.b?this.b.ma():[]};V.prototype.getVideoTracks=V.prototype.da;V.prototype.Y=function(){return this.b?this.b.pa():[]};
V.prototype.getAudioTracks=V.prototype.Y;V.prototype.$=function(){return this.b?this.b.Oa():[]};V.prototype.getTextTracks=V.prototype.$;V.prototype.selectVideoTrack=function(a,b){return this.b?this.b.selectVideoTrack(a,void 0==b?!0:b):!1};V.prototype.selectVideoTrack=V.prototype.selectVideoTrack;V.prototype.M=function(a,b,c){return this.b?this.b.nb(a,void 0==b?!0:b,c):!1};V.prototype.selectAudioTrack=V.prototype.M;V.prototype.fa=function(a){return this.b?this.b.ob(a,!1):!1};
V.prototype.selectTextTrack=V.prototype.fa;V.prototype.V=function(a){this.b&&this.b.Na(a)};V.prototype.enableTextTrack=V.prototype.V;V.prototype.T=function(a){Af(this);0<=a?this.a.playbackRate=a:this.a.paused||(this.a.playbackRate=0,this.B(this.a.currentTime,Date.now(),a));this.l=a};V.prototype.setPlaybackRate=V.prototype.T;V.prototype.K=function(){return this.l};V.prototype.getPlaybackRate=V.prototype.K;V.prototype.R=function(a){this.F=a};V.prototype.setPlaybackStartTime=V.prototype.R;
V.prototype.G=function(){return this.b?this.b.mb():!1};V.prototype.isLive=V.prototype.G;
V.prototype.U=function(a){if(a){var b=pb(a,"enableAdaptation");null!=b&&(this.c.enableAdaptation=b);b=rb(a,"streamBufferSize");null!=b&&(this.c.streamBufferSize=b);b=rb(a,"liveStreamEndTimeout");null!=b&&(this.c.liveStreamEndTimeout=b);b=rb(a,"licenseRequestTimeout");null!=b&&(this.c.licenseRequestTimeout=b);b=rb(a,"mpdRequestTimeout");null!=b&&(this.c.mpdRequestTimeout=b);b=rb(a,"segmentRequestTimeout");null!=b&&(this.c.segmentRequestTimeout=b);b=sb(a,"preferredLanguage");null!=b&&(this.c.preferredLanguage=
b);b=tb(a,"restrictions",ja);null!=b&&(this.c.restrictions=b.clone());a=pb(a,"disableCacheBustingEvenThoughItMayAffectBandwidthEstimation");null!=a&&(Hd=!a);this.b&&this.b.T(this.c)}};V.prototype.configure=V.prototype.U;V.prototype.Z=function(){return this.c};V.prototype.getConfiguration=V.prototype.Z;function Af(a){a.j&&(window.clearTimeout(a.j),a.j=null)}function Df(a){zf(a);a.w=window.setTimeout(a.L.bind(a),100)}function zf(a){a.w&&(window.clearTimeout(a.w),a.w=null)}
V.prototype.B=function(a,b,c){this.j=null;var d=(Date.now()-b)/1E3*c;this.a.currentTime<this.D+(this.G()?1:.05)?this.a.pause():(d=Math.max(this.D,a+d),this.a.currentTime=d,this.j=window.setTimeout(this.B.bind(this,a,b,c),250))};function yf(a){ga("buffering");var b=a.g;b.bufferingTime+=ha("buffering")/1E3;a.h=!1;a.dispatchEvent(x({type:"bufferingEnd"}))}
V.prototype.L=function(){Df(this);if(!this.a.ended&&!this.a.seeking){var a=this.a.buffered,b=a.length?a.end(a.length-1):0,a=Math.max(b-this.a.currentTime,0),c=this.a.duration,c=isNaN(c)?0:Math.max(c-.05,0),b=b>=c||this.a.currentTime>=c;if(this.h){if(c=this.b.$a(),b||a>c)yf(this),this.a.play()}else!this.a.paused&&!b&&.5>a&&(this.h=!0,this.a.pause(),this.g.bufferingHistory.push(v()/1E3),da("buffering"),this.dispatchEvent(x({type:"bufferingStart"})))}};
var Ef={2:"A network failure occured while loading media content.",3:"The browser failed to decode the media content.",4:"The browser does not support the media content."};function Ff(a){for(var b=0;b<a.length;++b)for(var c=a[b],d=0;d<c.a.length;++d){for(var e=c.a[d],f=e,g=0;g<f.m.length;++g)of(we(f.m[g]))||(f.m.splice(g,1),--g);0==e.m.length&&(c.a.splice(d,1),--d)}}function Gf(a){for(var b=0;b<a.length;++b)for(var c=a[b],d=0;d<c.a.length;++d)c.a[d].m.sort(Hf)}function Hf(a,b){var c=a.bandwidth||Number.MAX_VALUE,d=b.bandwidth||Number.MAX_VALUE;return c<d?-1:c>d?1:0};function If(a){this.a=a}If.prototype.destroy=function(){this.a.destroy();this.a=null};If.prototype.update=function(a){var b=Jf(a),c=Jf(this.a);return Promise.all([b,c]).then(F(this,function(b){var c=b[0];b=b[1];var f=this.a.a;Ff(f);Gf(f);a.f=this.a.f;a.g=this.a.g?this.a.g.clone():null;a.c=this.a.c;f=[];Kf(a,this.a,c,b,f);c=a.a;Ff(c);Gf(c);return Promise.resolve(f)}))};
function Jf(a){function b(a,b){return a.concat(b)}var c=a.a.map(function(a){return a.a}).reduce(b,[]).map(function(a){return a.m}).reduce(b,[]);a=c.map(function(a){return a.I.create()});return Promise.all(a).then(function(a){for(var b={},f=0;f<c.length;++f)b[c[f].C]=a[f];return Promise.resolve(b)})}
function Kf(a,b,c,d,e){var f=new z;a.a.forEach(function(a,b){f.push(a.id||""+b,a)});var g=new z;b.a.forEach(function(a,b){g.push(a.id||""+b,a)});a=wb(f);for(b=0;b<a.length;++b){var h=a[b],l=f.get(h);1<l.length||(h=g.get(h))&&0!=h.length&&1==h.length&&(Lf(l[0],h[0],c,d,e),l[0].b=h[0].b)}}
function Lf(a,b,c,d,e){var f=new z;a.a.forEach(function(a,b){f.push(a.id||""+b,a)});var g=new z;b.a.forEach(function(a,b){g.push(a.id||""+b,a)});a=wb(f);for(b=0;b<a.length;++b){var h=a[b],l=f.get(h);1<l.length||(h=g.get(h))&&0!=h.length&&1==h.length&&Mf(l[0],h[0],c,d,e)}}
function Mf(a,b,c,d,e){var f=new z;a.m.forEach(function(a,b){f.push(a.id||""+b,a)});var g=new z;b.m.forEach(function(a,b){g.push(a.id||""+b,a)});b={};for(var h=wb(f),l=0;l<h.length;++l){var m=h[l];b[m]=m;var n=f.get(m);1<n.length||((m=g.get(m))&&0!=m.length?1==m.length&&(Nf(n[0],m[0],c,d),n[0].H=m[0].H,m[0].H=null,n[0].c=m[0].c):(e.push(n[0]),a.m.splice(a.m.indexOf(n[0]),1)))}h=wb(g);for(l=0;l<h.length;++l)m=h[l],b[m]||(b[m]=m,m=g.get(m),a.m.push(m[0]))}
function Nf(a,b,c,d){a=c[a.C];b=d[b.C];a.length();a.Ha(b)&&a.length()};function W(){this.a=this.b=null;this.f=new B;this.c=Number.POSITIVE_INFINITY;this.i=!0;this.g=!1}p("shaka.media.SimpleAbrManager",W);W.prototype.destroy=function(){this.f.destroy();this.a=this.b=this.f=null};W.prototype.initialize=function(a,b){this.b||this.a||(this.b=a,this.a=b)};
W.prototype.start=function(){this.b&&this.a&&!this.g&&(this.c=Date.now()+4E3,C(this.f,this.b,"bandwidth",this.v.bind(this)),C(this.f,this.a,"adaptation",this.j.bind(this)),C(this.f,this.a,"trackschanged",this.h.bind(this)),this.g=!0)};W.prototype.enable=function(a){this.i=a};W.prototype.getInitialVideoTrackId=function(){if(!this.b||!this.a)return null;var a=Of(this);return a?a.id:null};W.prototype.selectVideoTrack=function(a,b,c){this.g&&this.a.selectVideoTrack(a.id,b,c)};
W.prototype.v=function(){Date.now()<this.c||this.h()};W.prototype.h=function(){if(this.i){var a=Of(this);if(a){if(a.active){this.c=Date.now()+3E3;return}this.selectVideoTrack(a,!1)}this.c=Number.POSITIVE_INFINITY}};W.prototype.j=function(){this.c==Number.POSITIVE_INFINITY&&(this.c=Date.now()+3E4)};
function Of(a){var b=a.a.ma();if(0==b.length)return null;b.sort(sa);var c;a:{c=a.a.pa();for(var d=0;d<c.length;++d)if(c[d].active){c=c[d];break a}c=null}c=c?c.bandwidth:0;a=a.b.getBandwidth();for(var d=b[0],e=0;e<b.length;++e){var f=b[e],g=e+1<b.length?b[e+1]:{bandwidth:Number.POSITIVE_INFINITY};if(f.bandwidth&&(g=(g.bandwidth+c)/.85,a>=(f.bandwidth+c)/.95&&a<=g&&(d=f,d.active)))break}return d};function Pf(a,b,c){D.call(this,null);this.f=a;this.c=b;this.b=mc(c);this.a=null}q(Pf,D);p("shaka.player.HttpVideoSource",Pf);Pf.prototype.T=function(){};Pf.prototype.destroy=function(){this.a&&(this.a.parentElement.removeChild(this.a),this.a=null);this.v=this.b=null};k=Pf.prototype;k.lb=function(a,b){this.v=a;var c=b.mediaKeys;b.src=this.f;c=b.setMediaKeys(c);this.c&&(this.a=document.createElement("track"),this.a.src=this.c,b.appendChild(this.a),this.a.track.mode="showing");return c};k.X=function(){return Promise.resolve()};
k.ma=function(){return[]};k.pa=function(){return[]};k.Oa=function(){return[]};k.$a=function(){return 5};k.ab=function(){var a=new Ae;a.a=this.b;return[a]};k.Ka=function(){};Pf.prototype.selectVideoTrack=function(){return!1};k=Pf.prototype;k.nb=function(){return!1};k.ob=function(){return!1};k.Na=function(a){this.a&&(this.a.track.mode=a?"showing":"disabled")};k.pb=function(){};k.ua=function(){return[]};k.ha=function(){return!1};k.mb=function(){return!1};
k.cb=function(a){for(var b in a){var c=a[b],d=gb[c]||null;if(d){var e=Bb(b),d=Error("Key "+e+" is not usable. "+d);d.type="drm";d.code=c;c=y(d);this.dispatchEvent(c)}}};function X(a,b,c){D.call(this,null);this.a=a;this.Z=b;this.i=new B;this.g=new MediaSource;this.f=null;this.da=0;this.b=new z;this.G=c;this.G.initialize(b,this);this.L=!1;this.K="en";this.fa=!1;this.U=null;this.B=new E;this.h=new ja;this.D=null;this.Va=1;this.c={};this.ea=new E;this.Ta=0;this.Ua=15;this.w=null;this.Ra=this.Sa=!1;this.s={};this.$=this.Y=this.V=null;this.F={}}q(X,D);p("shaka.player.StreamVideoSource",X);
X.prototype.T=function(a){null!=a.streamBufferSize&&(this.F.streamBufferSize=a.streamBufferSize);null!=a.segmentRequestTimeout&&(this.F.segmentRequestTimeout=a.segmentRequestTimeout);Qf(this);null!=a.enableAdaptation&&this.G.enable(Boolean(a.enableAdaptation));null!=a.mpdRequestTimeout&&(this.da=Number(a.mpdRequestTimeout));null!=a.liveStreamEndTimeout&&(this.Ua=Number(a.liveStreamEndTimeout));null!=a.preferredLanguage&&(this.K=kb(String(a.preferredLanguage)));null!=a.restrictions&&(this.h=a.restrictions,
this.L&&Rf(this))};X.prototype.destroy=function(){this.B.destroy();this.ea.destroy();this.ea=this.B=null;this.Y&&(window.clearTimeout(this.Y),this.Y=null);this.V&&(window.clearTimeout(this.V),this.V=null);this.s=null;this.i.destroy();this.i=null;ob(this.c).forEach(function(a){a.destroy()});this.b=this.c=null;this.a&&(this.a.destroy(),this.a=null);this.G.destroy();this.v=this.h=this.U=this.f=this.g=this.Z=this.G=null};k=X.prototype;
k.lb=function(a,b){if(!this.L){var c=Error("Cannot call attach() right now.");c.type="app";return Promise.reject(c)}this.v=a;this.f=b;this.U=a.qb();C(this.i,this.g,"sourceopen",this.yb.bind(this));C(this.i,this.Z,"bandwidth",this.Sb.bind(this));this.a.b&&(C(this.i,a,"bufferingStart",this.vb.bind(this)),C(this.i,a,"bufferingEnd",this.ub.bind(this)));c=this.f.mediaKeys;this.f.src=window.URL.createObjectURL(this.g);c=this.f.setMediaKeys(c);return Promise.all([this.B,c])};
k.X=function(){if(this.L){var a=Error("Cannot call load() right now.");a.type="app";return Promise.reject(a)}if(!this.a||0==this.a.a.length)return (a=Error("The manifest does not specify any content."), a.type="stream", Promise.reject(a));a=this.a.a;Ff(a);Gf(a);if(0==this.a.a.length||0==this.a.a[0].a.length)return (a=Error("The manifest specifies content that cannot be displayed on this browser/platform."), a.type="stream", Promise.reject(a));this.L=!0;this.F.initialStreamBufferSize=this.a.c;Qf(this);Rf(this);
return Promise.resolve()};k.gb=function(a){var b=Date.now(),c=this.V=null,d=this.a.g;(a?this.eb():this.fb(d)).then(F(this,function(a){c=new If(a);return c.update(this.a)})).then(F(this,function(a){c.destroy();c=null;for(var d=0;d<a.length;++d)Sf(this,a[d]);this.F.initialStreamBufferSize=this.a.c;Qf(this);Rf(this);0==Object.keys(this.c).length?Tf(this):Uf(this,(Date.now()-b)/1E3)})).catch(F(this,function(a){c&&(c.destroy(),c=null);"aborted"!=a.type&&(a=y(a),this.dispatchEvent(a),this.a&&Uf(this,0))}))};
k.fb=function(){return Promise.reject("Cannot update manifest with this VideoSource implementation.")};k.eb=function(){return Promise.reject("Cannot update manifest with this VideoSource implementation.")};function Uf(a,b){if(null!=a.a.f){var c=Math.max(a.a.f,3),c=Math.max(c-b,0);a.V=window.setTimeout(a.gb.bind(a,!1),1E3*c)}}
function Sf(a,b){var c=b.a.split("/")[0],d=a.c[c];if(d&&d.oa()==b){var e=a.b.get(b.a.split("/")[0]).map(function(a){return a.m}).reduce(function(a,b){return a.concat(b)},[]).filter(function(a){return a.N&&a.J});if(0==e.length){c=Error("All usable streams have been removed from the manifest.");c.type="app";c=y(c);a.dispatchEvent(c);return}a.s[c].Pa==b&&delete a.s[c];d.ra(e[0],!0);b.destroy()}b.destroy()}
k.ma=function(){if(!this.b.a.hasOwnProperty("video"))return[];for(var a=this.c.video,a=(a=a?a.oa():null)?a.C:0,b=[],c=this.b.get("video"),d=0;d<c.length;++d)for(var e=c[d],f=0;f<e.m.length;++f){var g=e.m[f];if(g.N&&g.J){var h=g.C,g=new ra(h,g.bandwidth,g.width,g.height);h==a&&(g.active=!0);b.push(g)}}return b};X.prototype.getVideoTracks=X.prototype.ma;
X.prototype.pa=function(){if(!this.b.a.hasOwnProperty("audio"))return[];for(var a=this.c.audio,a=(a=a?a.oa():null)?a.C:0,b=[],c=this.b.get("audio"),d=0;d<c.length;++d)for(var e=c[d],f=e.lang,g=0;g<e.m.length;++g){var h=e.m[g];if(h.N&&h.J){var l=h.C,h=new ia(l,h.bandwidth,f);l==a&&(h.active=!0);b.push(h)}}return b};X.prototype.getAudioTracks=X.prototype.pa;
X.prototype.Oa=function(){if(!this.b.a.hasOwnProperty("text"))return[];for(var a=this.c.text,b=a?a.oa():null,b=b?b.C:0,c=[],d=this.b.get("text"),e=0;e<d.length;++e)for(var f=d[e],g=f.lang,h=0;h<f.m.length;++h){var l=f.m[h].C,m=new qa(l,g);l==b&&(m.active=!0,m.enabled=a.Da());c.push(m)}return c};X.prototype.getTextTracks=X.prototype.Oa;X.prototype.$a=function(){return Number(this.F.initialStreamBufferSize)};
X.prototype.ab=function(){var a;if(this.L){a=this.a.a[0];for(var b=[],c=0;c<a.a.length;++c)b.push.apply(b,ze(a.a[c]));a=b}else a=[];return a};
X.prototype.Ka=function(a){if(this.L){for(var b={},c=this.a.a[0],d=0;d<c.a.length;++d){var e=c.a[d];b[e.C]=e}this.b.a={};c=wb(a);for(d=0;d<c.length;++d){var e=c[d],f=a.get(e);if("video"==e){var g=f[0].id;this.b.push(e,b[g])}else if("audio"==e)for(var g=f[0].b.split(";")[0],h=0;h<f.length;++h){var l=f[h];l.b.split(";")[0]==g&&this.b.push(e,b[l.id])}else for(h=0;h<f.length;++h)g=f[h].id,this.b.push(e,b[g])}this.fa=!0;if(a=this.b.get("audio"))Vf(this,a),this.b.set("audio",a),a=a[0].lang||this.K,jb(2,
this.K,a)&&(this.fa=!1);if(a=this.b.get("text"))Vf(this,a),this.b.set("text",a),a=a[0].lang||this.K,jb(2,this.K,a)||(this.fa=!1)}};X.prototype.selectVideoTrack=function(a,b,c){return Wf(this,"video",a,b,c)};k=X.prototype;k.nb=function(a,b,c){return Wf(this,"audio",a,b,c)};k.ob=function(a,b){return Wf(this,"text",a,b)};k.Na=function(a){var b=this.c.text;b&&b.va(a)};k.pb=function(a){this.$=a};
function Rf(a){if(a.h){for(var b=!1,c=0;c<a.a.a.length;++c)for(var d=a.a.a[c],e=0;e<d.a.length;++e){var f=d.a[e];if("video"==f.contentType)for(var g=0;g<f.m.length;++g){var h=f.m[g],l=h.J;h.J=!0;a.h.maxWidth&&h.width>a.h.maxWidth&&(h.J=!1);a.h.maxHeight&&h.height>a.h.maxHeight&&(h.J=!1);a.h.minHeight&&h.height<a.h.minHeight&&(h.J=!1);a.h.maxBandwidth&&h.bandwidth>a.h.maxBandwidth&&(h.J=!1);a.h.minBandwidth&&h.bandwidth<a.h.minBandwidth&&(h.J=!1);l!=h.J&&(b=!0)}}0!=ub(a.b).length&&b&&(Xf(a),0<a.ma().length||
(b=Error("The application has restricted all video tracks!"),b.type="app",b=y(b),a.dispatchEvent(b)))}}k.ua=function(){return[]};k.ha=function(){return!1};k.mb=function(){return this.a?this.a.b:!1};
k.cb=function(a){for(var b,c=!1,d=new z,e=ub(this.b),f=0;f<e.length;++f)for(var g=e[f],h=0;h<g.m.length;++h){var l=g.m[h];l.f.forEach(function(a){d.push(a,l)})}for(b in a)if(e=gb[a[b]]||null,g=d.get(b))for(f=0;f<g.length;++f)l=g[f],h=l.N,l.N=!e,h!=l.N&&(c=!0);else Bb(b);c&&(Xf(this),b=this.pa(),a=this.ma(),b=this.b.a.hasOwnProperty("audio")&&0==b.length,a=this.b.a.hasOwnProperty("video")&&0==a.length,b||a)&&(a=Error("The key system has restricted all "+(b&&a?"audio and video tracks.":b?"audio tracks.":
"video tracks.")),a.type="drm",a=y(a),this.dispatchEvent(a))};function Xf(a){var b=x({type:"trackschanged",bubbles:!0});a.dispatchEvent(b)}function Wf(a,b,c,d,e){if(!a.b.a.hasOwnProperty(b)||!a.c[b])return!1;for(var f=a.b.get(b),g=0;g<f.length;++g)for(var h=f[g],l=0;l<h.m.length;++l){var m=h.m[l];if(m.C==c){if(!m.N||!m.J)return!1;if("text"!=b&&!a.Ra)return (c=a.s[b], a.s[b]={Pa:m,Wa:null!=c&&c.Wa||d,Xa:null!=c&&c.Xa||e}, !0);bf(a.U,m);a.c[b].ra(m,d,e);return!0}}return!1}
function Vf(a,b){for(var c=0;2>=c;++c)for(var d=0;d<b.length;++d){var e=b[d];if(jb(c,a.K,e.lang)){b.splice(d,1);b.splice(0,0,e);return}}for(d=0;d<b.length;++d)if(e=b[d],e.b){b.splice(d,1);b.splice(0,0,e);break}}k.yb=function(){this.i.sa(this.g,"sourceopen");Tf(this).then(F(this,function(){this.B&&this.B.resolve()})).catch(F(this,function(a){this.B&&this.B.reject(a)}))};
function Tf(a){for(var b=[],c=["audio","video","text"],d=0;d<c.length;++d){var e=c[d];a.b.a.hasOwnProperty(e)&&b.push(a.b.get(e)[0])}for(var f=Yf(a,b),d=0;d<c.length;++d)if(e=c[d],a.b.a.hasOwnProperty(e)&&!f[e])return (a=Error("Unable to select an initial "+e+" stream: all "+e+" streams have been restricted (by the application or by the key system)."), a.type="stream", Promise.reject(a));b=ob(f).map(function(a){return a.I.create()});return Promise.all(b).then(F(a,function(a){if(!a.every(function(a){return a.length()}))return (a=
Error("Some streams are not available."), a.type="stream", Promise.reject(a));a=Zf(this,a);if(!a)return (a=Error("Some streams are not available."), a.type="stream", Promise.reject(a));if(!$f(this,f))return (a=Error("Failed to create Stream objects."), a.type="stream", Promise.reject(a));this.G.start();ag(this,f,a);return Promise.resolve()})).catch(F(a,function(a){if("aborted"!=a.type)return (Object.keys(this.c), this.a.b?(v()<this.a.h?(a=Math.max(this.a.h-Date.now()/1E3,3),this.V=window.setTimeout(this.gb.bind(this,
!0),1E3*a)):Uf(this,0),Promise.resolve()):Promise.reject(a))}))}function Yf(a,b){for(var c={},d=0;d<b.length;++d){var e=b[d],f=null;if("video"==e.contentType){var g=a.G.getInitialVideoTrackId();if(null==g)continue;f=e.m.filter(function(a){return a.C==g});if(0==f.length)continue;f=f[0]}else if("audio"==e.contentType){f=e.m.filter(function(a){return a.N&&a.J});if(0==f.length)continue;f=e.m[Math.floor(f.length/2)]}else 0<e.m.length&&(f=e.m[0]);c[e.contentType]=f}return c}
function $f(a,b){var c={},d;for(d in b){var e=b[d],e="text"==d?new Me(a,a.f):bg(a,e);if(!e)return (ob(c).forEach(function(a){a.destroy()}), !1);c[d]=e}a.c=c;return!0}function bg(a,b){var c=new De(a,a.f,a.g,we(b),a.Z);c.F(a.F);return c}
function ag(a,b,c){a.Va=a.f.playbackRate;a.f.playbackRate=0;cg(a,c);var d;a.$&&a.$<=c.end&&a.$>=c.start?d=a.$:a.a.b?(d=c.end,a.Sa=!0):d=c.start;C(a.i,a.f,"seeking",a.Gb.bind(a));a.f.currentTime!=d&&(a.f.currentTime=d,a.D=d);dg(a,c.start,c.end);c=[];for(var e in a.c){d=a.c[e];c.push(d.sb(a.ea));C(a.i,d,"ended",a.Hb.bind(a));var f=b[e];bf(a.U,f);d.ra(f,!1)}Promise.all(c).then(a.tb.bind(a)).catch(F(a,function(a){"destroy"!=a.type&&(a=y(a),this.dispatchEvent(a))}));a.Na(a.fa)}
k.tb=function(a){ba(a&&a.length==Object.keys(this.c).length);for(var b=Number.POSITIVE_INFINITY,c=Number.NEGATIVE_INFINITY,d=0;d<a.length;++d)var e=a[d],b=Math.min(b,e),c=Math.max(c,e);a=eg(this);for(d=0;d<a.length;++d)a[d].ka(c);fg(this,a,c);d=ub(this.b).map(function(a){return a.m}).reduce(function(a,b){return a.concat(b)},[]).map(function(a){var b=[a.I.create()];a.H&&b.push(a.H.create());return Promise.all(b)});Promise.all(d).then(F(this,function(a){for(var b=0;b<a.length;++b)a[b][0].ka(c);this.Ra=
!0;for(var d in this.s)a=this.s[d],b=this.c[d],bf(this.U,a.Pa),b.ra(a.Pa,a.Wa,a.Xa);this.s={}})).catch(F(this,function(a){"aborted"!=a.type&&(a=y(a),this.dispatchEvent(a))}))};function fg(a,b,c){if(b=Zf(a,b))cg(a,b),dg(a,b.start,b.end);0!=c&&(c=a.f.currentTime+c,a.f.currentTime=c,a.D=c);a.Sa&&b&&(a.f.currentTime=b.end);a.f.playbackRate=a.Va;a.a.b&&null!=a.a.f&&Uf(a,0);gg(a);a.ea.resolve()}
function cg(a,b){if(a.a.b)isNaN(a.g.duration)&&(a.g.duration=b.end+2592E3);else if(isNaN(a.g.duration)||b.end>a.g.duration){a.g.duration=b.end;for(var c=0;c<a.g.sourceBuffers.length;++c)a.g.sourceBuffers[c].appendWindowEnd=b.end}}k.Jb=function(){this.Y=null;gg(this);var a=Zf(this,eg(this));a&&(this.a.b&&this.Ta!=a.A&&(this.Ta=a.A,null!=this.w&&(window.clearTimeout(this.w),this.w=null)),dg(this,a.start,a.end),this.f.paused||hg(this,this.f.currentTime,a.start,a.end))};
function dg(a,b,c){b=x({type:"seekrangechanged",bubbles:!0,start:b,end:c});a.dispatchEvent(b)}k.Gb=function(){var a=this.f.currentTime;if(null!=this.D){if(a>=this.D-.01&&a<=this.D+.01){this.D=null;return}this.D=null}var b=Zf(this,eg(this));if(b){var c=b.end;(b=hg(this,a,b.start,c))||(a<=c+.01?b=!1:(this.f.currentTime=c,b=!0));if(!b)for(var d in this.c)this.c[d].jb()}};
function hg(a,b,c,d){if(b>=c-.01)return!1;b=0;if(a.a.b){b=.5;for(var e in a.c)if(!a.c[e].kb(c+b)){b=a.a.c;break}}a.f.currentTime=Math.min(c+b,d);return!0}k.Hb=function(){if(!this.a.b){for(var a in this.c)if(!this.c[a].Ga())return;this.Za()}};k.vb=function(){ob(this.c).every(function(a){return a.Ga()})&&(this.w=window.setTimeout(this.Za.bind(this),1E3*this.Ua))};k.ub=function(){null!=this.w&&(window.clearTimeout(this.w),this.w=null)};
k.Sb=function(){var a=this.U,b=this.Z.getBandwidth();a.estimatedBandwidth=b;a.bandwidthHistory.push(new df(b))};k.Za=function(){this.w=null;this.g.endOfStream()};function eg(a){return ob(a.c).map(function(a){return a.bb()}).filter(function(a){return null!=a})}
function Zf(a,b){for(var c=0,d=Number.POSITIVE_INFINITY,e=Number.POSITIVE_INFINITY,f=0;f<b.length;++f){var g=b[f].Ea(),c=Math.max(c,g.start);null!=g.end&&(d=Math.min(d,g.end));b[f].length()&&(e=Math.min(e,b[f].A().a))}if(d==Number.POSITIVE_INFINITY)if(d=a.a.a[0],d.b)d=(d.start||0)+d.b;else return null;a.a.b&&(d=Math.max(d-a.a.c,c));return c>d?null:{start:c,end:d,A:e}}function gg(a){a.a.b&&(a.Y=window.setTimeout(a.Jb.bind(a),1E3))}function Qf(a){for(var b in a.c)a.c[b].F(a.F)};function Y(a,b,c,d){c||(c=new Ab);d||(d=new W);X.call(this,null,c,d);this.za=a;this.l=null;this.M=b;this.R=[];this.ga=[];this.ta=[];this.j=null}q(Y,X);p("shaka.player.DashVideoSource",Y);Y.prototype.Aa=function(a,b,c){this.R.push(a);this.ga.push(b||"");this.ta.push(c||"")};Y.prototype.addExternalCaptions=Y.prototype.Aa;Y.prototype.xa=function(a){this.j=a};Y.prototype.setNetworkCallback=Y.prototype.xa;Y.prototype.destroy=function(){this.l=this.j=this.M=null;X.prototype.destroy.call(this)};
Y.prototype.X=function(){var a=new G(this.j,[new H(this.za)]);return Qd(new Pd(a,this.da)).then(F(this,function(a){this.l=a;for(var c=0;c<this.R.length;c++){var d=a,e=this.R[c],f=this.ga[c],g=this.ta[c];if(0!==d.a.length){var h=new ed;h.contentType="text";h.lang=f||"en";h.c=!0;f=new hd;f.bandwidth=0;f.f=g||"text/vtt";f.u=[new H(e)];h.a.push(f);d.a[0].b.push(h);Ad(d.a[0])}}this.a=Qe(new Pe(this.M),a,this.j);return X.prototype.X.call(this)}))};
Y.prototype.fb=function(a){return Qd(new Pd(a,this.da)).then(F(this,function(a){this.l=a;a=Qe(new Pe(this.M),a,this.j);return Promise.resolve(a)}))};Y.prototype.eb=function(){var a=Qe(new Pe(this.M),this.l,this.j);return Promise.resolve(a)};function Z(a,b,c){b||(b=new Ab);c||(c=new W);X.call(this,null,b,c);this.R=a;this.M=[];this.timeoutMs=3E4;this.l={};this.j=this.ga=null}q(Z,X);p("shaka.player.OfflineVideoSource",Z);Z.prototype.T=function(a){null!=a.licenseRequestTimeout&&(this.l.licenseRequestTimeout=a.licenseRequestTimeout);null!=a.segmentRequestTimeout&&(this.l.segmentRequestTimeout=a.segmentRequestTimeout);X.prototype.T.call(this,a)};
p("shaka.player.OfflineVideoSource.retrieveGroupIds",function(){var a=new Qb,b=Hb(a).then(function(){return Rb(a)});b.then(function(){Jb(a)}).catch(function(){Jb(a)});return b});
Z.prototype.xa=function(a,b,c,d){var e,f=null,g={},h=[];a=new G(this.ga,[new H(a)]);return Qd(new Pd(a,this.da)).then(F(this,function(a){this.a=Qe(new Pe(c),a,this.ga);if(this.a.b)return (a=Error("Unable to store live streams offline."), a.type="app", Promise.reject(a));this.T({preferredLanguage:b});return X.prototype.X.call(this)})).then(F(this,function(){var a=document.createElement("video");a.src=window.URL.createObjectURL(this.g);e=new U(null,a,this);null!=this.l.licenseRequestTimeout&&(e.w=Number(this.l.licenseRequestTimeout));
C(this.i,e,"sessionReady",this.ta.bind(this));C(this.i,e,"error",function(a){f=a});return e.initialize()})).then(F(this,function(){for(var a=ub(this.b),b=0;b<a.length;++b)for(var c=a[b],e=0;e<c.m.length;++e){var f=c.m[e];g[f.C]=f}return d()})).then(F(this,function(a){for(var b=0;b<a.length;++b){var c=a[b],d=g[c];if(d)h.push(d);else return Promise.reject(Error("Invalid stream ID chosen: "+c))}var e=["audio","video"];h=h.filter(function(a){return 0>e.indexOf(a.a.split("/")[0])?!1:!0});a=h.map(function(a){return a.H.create()});
return Promise.all(a)})).then(F(this,function(a){for(var b=h,c=[],d=0;d<b.length;++d)try{c[d]=this.g.addSourceBuffer(we(b[d]))}catch(e){}if(b.length!=c.length)a=Error("Error initializing streams."),a.type="storage",a=Promise.reject(a);else{for(d=0;d<a.length;++d)(b=a[d])&&c[d].appendBuffer(b);a=Promise.resolve()}return a})).then(F(this,function(){return qf(e,this.timeoutMs)})).then(F(this,function(){return f?Promise.reject(f):ig(this,h,e.a,this.a.a[0].b)})).then(F(this,function(a){this.R=a;return f?
(jg(this),Promise.reject(f)):Promise.resolve(a)}))};p("shaka.player.OfflineVideoSource.prototype.store",Z.prototype.xa);Z.prototype.Aa=function(a){this.ga=a};Z.prototype.setNetworkCallback=Z.prototype.Aa;Z.prototype.ta=function(a){this.M.push(a.detail.sessionId)};
function ig(a,b,c,d){var e=new ef(a.Z,a);null!=a.l.segmentRequestTimeout&&(e.b=Number(a.l.segmentRequestTimeout));return Hb(e).then(F(a,function(){return ff(e,b,this.M,d,c)})).then(function(a){Jb(e);return Promise.resolve(a)}).catch(function(a){Jb(e);return Promise.reject(a)})}
Z.prototype.X=function(){var a=new Qb,b,c;return Hb(a).then(F(this,function(){return Sb(a,this.R)})).then(F(this,function(d){var e=[];this.M=d.session_ids;b=d.duration;c={keySystem:d.key_system,distinctiveIdentifierRequired:d.distinctive_identifier,persistentStorageRequired:!0,audioRobustness:d.audio_robustness,videoRobustness:d.video_robustness,withCredentials:d.with_credentials,licenseServerUrl:d.license_server};for(var f=0;f<d.stream_ids.length;++f)e.push(Tb(a,d.stream_ids[f]));return Promise.all(e)})).then(F(this,
function(a){var e=b,f=c,g=new Ce;g.c=5;for(var h=new Be,l=0;l<a.length;++l){var m=a[l],n=new ue,t=new te(m.references),A=new Wd(null,m.init_segment);n.I=t;n.H=A;n.a=m.mime_type;n.b=m.codecs;n.N=!0;this.j&&(null!=this.j.licenseServerUrl&&(f.licenseServerUrl=this.j.licenseServerUrl),null!=this.j.withCredentials&&(f.withCredentials=this.j.withCredentials),f.licensePostProcessor=this.j.licensePostProcessor,f.licensePreProcessor=this.j.licensePreProcessor,f.serverCertificate=this.j.serverCertificate);
m=mc(f);t=new xe;t.m.push(n);t.a.push(m);t.contentType=n.a.split("/")[0];h.a.push(t);h.b=e}g.a.push(h);this.a=g;return X.prototype.X.call(this)})).then(function(){Jb(a);return Promise.resolve()}).catch(function(b){Jb(a);return Promise.reject(b)})};
Z.prototype.za=function(a,b){a&&(this.j={licenseServerUrl:a.licenseServerUrl,withCredentials:a.withCredentials,serverCertificate:a.serverCertificate,licensePreProcessor:a.licensePreProcessor,licensePostProcessor:a.licensePostProcessor});var c=null;return kg(this).catch(function(a){return b?(c=a,Promise.resolve()):Promise.reject(a)}).then(F(this,function(){return jg(this)})).then(function(){return Promise.resolve(c)})};Z.prototype.deleteGroup=Z.prototype.za;Z.prototype.ua=function(){return this.M};
Z.prototype.ha=function(){return!0};function jg(a){var b=new ef(null,null);return Hb(b).then(F(a,function(){return jf(b,this.R)})).then(function(){Jb(b);return Promise.resolve()}).catch(function(a){Jb(b);return Promise.reject(a)})}
function kg(a){var b=document.createElement("video");b.src=window.URL.createObjectURL(a.g);var c=new U(null,b,a);null!=a.l.licenseRequestTimeout&&(c.w=Number(a.l.licenseRequestTimeout));return a.X().then(function(){return c.initialize()}).then(F(a,function(){return qf(c,this.timeoutMs)})).then(function(){return rf(c)}).then(F(a,function(){c.destroy();this.destroy();return Promise.resolve()})).catch(F(a,function(a){c.destroy();this.destroy();return Promise.reject(a)}))};}.bind(g,this))();
if (typeof(module)!="undefined"&&module.exports)module.exports=g.shaka;
else if (typeof(define)!="undefined" && define.amd)define(function(){return g.shaka});
else this.shaka=g.shaka;
})();


},{}],685:[function(require,module,exports){
/*
Slick Finder
*/"use strict"

// Notable changes from Slick.Finder 1.0.x

// faster bottom -> up expression matching
// prefers mental sanity over *obsessive compulsive* milliseconds savings
// uses prototypes instead of objects
// tries to use matchesSelector smartly, whenever available
// can populate objects as well as arrays
// lots of stuff is broken or not implemented

var parse = require("./parser")

// utilities

var index = 0,
    counter = document.__counter = (parseInt(document.__counter || -1, 36) + 1).toString(36),
    key = "uid:" + counter

var uniqueID = function(n, xml){
    if (n === window) return "window"
    if (n === document) return "document"
    if (n === document.documentElement) return "html"

    if (xml) {
        var uid = n.getAttribute(key)
        if (!uid) {
            uid = (index++).toString(36)
            n.setAttribute(key, uid)
        }
        return uid
    } else {
        return n[key] || (n[key] = (index++).toString(36))
    }
}

var uniqueIDXML = function(n) {
    return uniqueID(n, true)
}

var isArray = Array.isArray || function(object){
    return Object.prototype.toString.call(object) === "[object Array]"
}

// tests

var uniqueIndex = 0;

var HAS = {

    GET_ELEMENT_BY_ID: function(test, id){
        id = "slick_" + (uniqueIndex++);
        // checks if the document has getElementById, and it works
        test.innerHTML = '<a id="' + id + '"></a>'
        return !!this.getElementById(id)
    },

    QUERY_SELECTOR: function(test){
        // this supposedly fixes a webkit bug with matchesSelector / querySelector & nth-child
        test.innerHTML = '_<style>:nth-child(2){}</style>'

        // checks if the document has querySelectorAll, and it works
        test.innerHTML = '<a class="MiX"></a>'

        return test.querySelectorAll('.MiX').length === 1
    },

    EXPANDOS: function(test, id){
        id = "slick_" + (uniqueIndex++);
        // checks if the document has elements that support expandos
        test._custom_property_ = id
        return test._custom_property_ === id
    },

    // TODO: use this ?

    // CHECKED_QUERY_SELECTOR: function(test){
    //
    //     // checks if the document supports the checked query selector
    //     test.innerHTML = '<select><option selected="selected">a</option></select>'
    //     return test.querySelectorAll(':checked').length === 1
    // },

    // TODO: use this ?

    // EMPTY_ATTRIBUTE_QUERY_SELECTOR: function(test){
    //
    //     // checks if the document supports the empty attribute query selector
    //     test.innerHTML = '<a class=""></a>'
    //     return test.querySelectorAll('[class*=""]').length === 1
    // },

    MATCHES_SELECTOR: function(test){

        test.className = "MiX"

        // checks if the document has matchesSelector, and we can use it.

        var matches = test.matchesSelector || test.mozMatchesSelector || test.webkitMatchesSelector

        // if matchesSelector trows errors on incorrect syntax we can use it
        if (matches) try {
            matches.call(test, ':slick')
        } catch(e){
            // just as a safety precaution, also test if it works on mixedcase (like querySelectorAll)
            return matches.call(test, ".MiX") ? matches : false
        }

        return false
    },

    GET_ELEMENTS_BY_CLASS_NAME: function(test){
        test.innerHTML = '<a class="f"></a><a class="b"></a>'
        if (test.getElementsByClassName('b').length !== 1) return false

        test.firstChild.className = 'b'
        if (test.getElementsByClassName('b').length !== 2) return false

        // Opera 9.6 getElementsByClassName doesnt detects the class if its not the first one
        test.innerHTML = '<a class="a"></a><a class="f b a"></a>'
        if (test.getElementsByClassName('a').length !== 2) return false

        // tests passed
        return true
    },

    // no need to know

    // GET_ELEMENT_BY_ID_NOT_NAME: function(test, id){
    //     test.innerHTML = '<a name="'+ id +'"></a><b id="'+ id +'"></b>'
    //     return this.getElementById(id) !== test.firstChild
    // },

    // this is always checked for and fixed

    // STAR_GET_ELEMENTS_BY_TAG_NAME: function(test){
    //
    //     // IE returns comment nodes for getElementsByTagName('*') for some documents
    //     test.appendChild(this.createComment(''))
    //     if (test.getElementsByTagName('*').length > 0) return false
    //
    //     // IE returns closed nodes (EG:"</foo>") for getElementsByTagName('*') for some documents
    //     test.innerHTML = 'foo</foo>'
    //     if (test.getElementsByTagName('*').length) return false
    //
    //     // tests passed
    //     return true
    // },

    // this is always checked for and fixed

    // STAR_QUERY_SELECTOR: function(test){
    //
    //     // returns closed nodes (EG:"</foo>") for querySelector('*') for some documents
    //     test.innerHTML = 'foo</foo>'
    //     return !!(test.querySelectorAll('*').length)
    // },

    GET_ATTRIBUTE: function(test){
        // tests for working getAttribute implementation
        var shout = "fus ro dah"
        test.innerHTML = '<a class="' + shout + '"></a>'
        return test.firstChild.getAttribute('class') === shout
    }

}

// Finder

var Finder = function Finder(document){

    this.document        = document
    var root = this.root = document.documentElement
    this.tested          = {}

    // uniqueID

    this.uniqueID = this.has("EXPANDOS") ? uniqueID : uniqueIDXML

    // getAttribute

    this.getAttribute = (this.has("GET_ATTRIBUTE")) ? function(node, name){

        return node.getAttribute(name)

    } : function(node, name){

        node = node.getAttributeNode(name)
        return (node && node.specified) ? node.value : null

    }

    // hasAttribute

    this.hasAttribute = (root.hasAttribute) ? function(node, attribute){

        return node.hasAttribute(attribute)

    } : function(node, attribute) {

        node = node.getAttributeNode(attribute)
        return !!(node && node.specified)

    }

    // contains

    this.contains = (document.contains && root.contains) ? function(context, node){

        return context.contains(node)

    } : (root.compareDocumentPosition) ? function(context, node){

        return context === node || !!(context.compareDocumentPosition(node) & 16)

    } : function(context, node){

        do {
            if (node === context) return true
        } while ((node = node.parentNode))

        return false
    }

    // sort
    // credits to Sizzle (http://sizzlejs.com/)

    this.sorter = (root.compareDocumentPosition) ? function(a, b){

        if (!a.compareDocumentPosition || !b.compareDocumentPosition) return 0
        return a.compareDocumentPosition(b) & 4 ? -1 : a === b ? 0 : 1

    } : ('sourceIndex' in root) ? function(a, b){

        if (!a.sourceIndex || !b.sourceIndex) return 0
        return a.sourceIndex - b.sourceIndex

    } : (document.createRange) ? function(a, b){

        if (!a.ownerDocument || !b.ownerDocument) return 0
        var aRange = a.ownerDocument.createRange(),
            bRange = b.ownerDocument.createRange()

        aRange.setStart(a, 0)
        aRange.setEnd(a, 0)
        bRange.setStart(b, 0)
        bRange.setEnd(b, 0)
        return aRange.compareBoundaryPoints(Range.START_TO_END, bRange)

    } : null

    this.failed = {}

    var nativeMatches = this.has("MATCHES_SELECTOR")

    if (nativeMatches) this.matchesSelector = function(node, expression){

        if (this.failed[expression]) return null

        try {
            return nativeMatches.call(node, expression)
        } catch(e){
            if (slick.debug) console.warn("matchesSelector failed on " + expression)
            this.failed[expression] = true
            return null
        }

    }

    if (this.has("QUERY_SELECTOR")){

        this.querySelectorAll = function(node, expression){

            if (this.failed[expression]) return true

            var result, _id, _expression, _combinator, _node


            // non-document rooted QSA
            // credits to Andrew Dupont

            if (node !== this.document){

                _combinator = expression[0].combinator

                _id         = node.getAttribute("id")
                _expression = expression

                if (!_id){
                    _node = node
                    _id = "__slick__"
                    _node.setAttribute("id", _id)
                }

                expression = "#" + _id + " " + _expression


                // these combinators need a parentNode due to how querySelectorAll works, which is:
                // finding all the elements that match the given selector
                // then filtering by the ones that have the specified element as an ancestor
                if (_combinator.indexOf("~") > -1 || _combinator.indexOf("+") > -1){

                    node = node.parentNode
                    if (!node) result = true
                    // if node has no parentNode, we return "true" as if it failed, without polluting the failed cache

                }

            }

            if (!result) try {
                result = node.querySelectorAll(expression.toString())
            } catch(e){
                if (slick.debug) console.warn("querySelectorAll failed on " + (_expression || expression))
                result = this.failed[_expression || expression] = true
            }

            if (_node) _node.removeAttribute("id")

            return result

        }

    }

}

Finder.prototype.has = function(FEATURE){

    var tested        = this.tested,
        testedFEATURE = tested[FEATURE]

    if (testedFEATURE != null) return testedFEATURE

    var root     = this.root,
        document = this.document,
        testNode = document.createElement("div")

    testNode.setAttribute("style", "display: none;")

    root.appendChild(testNode)

    var TEST = HAS[FEATURE], result = false

    if (TEST) try {
        result = TEST.call(document, testNode)
    } catch(e){}

    if (slick.debug && !result) console.warn("document has no " + FEATURE)

    root.removeChild(testNode)

    return tested[FEATURE] = result

}

var combinators = {

    " ": function(node, part, push){

        var item, items

        var noId = !part.id, noTag = !part.tag, noClass = !part.classes

        if (part.id && node.getElementById && this.has("GET_ELEMENT_BY_ID")){
            item = node.getElementById(part.id)

            // return only if id is found, else keep checking
            // might be a tad slower on non-existing ids, but less insane

            if (item && item.getAttribute('id') === part.id){
                items = [item]
                noId = true
                // if tag is star, no need to check it in match()
                if (part.tag === "*") noTag = true
            }
        }

        if (!items){

            if (part.classes && node.getElementsByClassName && this.has("GET_ELEMENTS_BY_CLASS_NAME")){
                items = node.getElementsByClassName(part.classList)
                noClass = true
                // if tag is star, no need to check it in match()
                if (part.tag === "*") noTag = true
            } else {
                items = node.getElementsByTagName(part.tag)
                // if tag is star, need to check it in match because it could select junk, boho
                if (part.tag !== "*") noTag = true
            }

            if (!items || !items.length) return false

        }

        for (var i = 0; item = items[i++];)
            if ((noTag && noId && noClass && !part.attributes && !part.pseudos) || this.match(item, part, noTag, noId, noClass))
                push(item)

        return true

    },

    ">": function(node, part, push){ // direct children
        if ((node = node.firstChild)) do {
            if (node.nodeType == 1 && this.match(node, part)) push(node)
        } while ((node = node.nextSibling))
    },

    "+": function(node, part, push){ // next sibling
        while ((node = node.nextSibling)) if (node.nodeType == 1){
            if (this.match(node, part)) push(node)
            break
        }
    },

    "^": function(node, part, push){ // first child
        node = node.firstChild
        if (node){
            if (node.nodeType === 1){
                if (this.match(node, part)) push(node)
            } else {
                combinators['+'].call(this, node, part, push)
            }
        }
    },

    "~": function(node, part, push){ // next siblings
        while ((node = node.nextSibling)){
            if (node.nodeType === 1 && this.match(node, part)) push(node)
        }
    },

    "++": function(node, part, push){ // next sibling and previous sibling
        combinators['+'].call(this, node, part, push)
        combinators['!+'].call(this, node, part, push)
    },

    "~~": function(node, part, push){ // next siblings and previous siblings
        combinators['~'].call(this, node, part, push)
        combinators['!~'].call(this, node, part, push)
    },

    "!": function(node, part, push){ // all parent nodes up to document
        while ((node = node.parentNode)) if (node !== this.document && this.match(node, part)) push(node)
    },

    "!>": function(node, part, push){ // direct parent (one level)
        node = node.parentNode
        if (node !== this.document && this.match(node, part)) push(node)
    },

    "!+": function(node, part, push){ // previous sibling
        while ((node = node.previousSibling)) if (node.nodeType == 1){
            if (this.match(node, part)) push(node)
            break
        }
    },

    "!^": function(node, part, push){ // last child
        node = node.lastChild
        if (node){
            if (node.nodeType == 1){
                if (this.match(node, part)) push(node)
            } else {
                combinators['!+'].call(this, node, part, push)
            }
        }
    },

    "!~": function(node, part, push){ // previous siblings
        while ((node = node.previousSibling)){
            if (node.nodeType === 1 && this.match(node, part)) push(node)
        }
    }

}

Finder.prototype.search = function(context, expression, found){

    if (!context) context = this.document
    else if (!context.nodeType && context.document) context = context.document

    var expressions = parse(expression)

    // no expressions were parsed. todo: is this really necessary?
    if (!expressions || !expressions.length) throw new Error("invalid expression")

    if (!found) found = []

    var uniques, push = isArray(found) ? function(node){
        found[found.length] = node
    } : function(node){
        found[found.length++] = node
    }

    // if there is more than one expression we need to check for duplicates when we push to found
    // this simply saves the old push and wraps it around an uid dupe check.
    if (expressions.length > 1){
        uniques = {}
        var plush = push
        push = function(node){
            var uid = uniqueID(node)
            if (!uniques[uid]){
                uniques[uid] = true
                plush(node)
            }
        }
    }

    // walker

    var node, nodes, part

    main: for (var i = 0; expression = expressions[i++];){

        // querySelector

        // TODO: more functional tests

        // if there is querySelectorAll (and the expression does not fail) use it.
        if (!slick.noQSA && this.querySelectorAll){

            nodes = this.querySelectorAll(context, expression)
            if (nodes !== true){
                if (nodes && nodes.length) for (var j = 0; node = nodes[j++];) if (node.nodeName > '@'){
                    push(node)
                }
                continue main
            }
        }

        // if there is only one part in the expression we don't need to check each part for duplicates.
        // todo: this might be too naive. while solid, there can be expression sequences that do not
        // produce duplicates. "body div" for instance, can never give you each div more than once.
        // "body div a" on the other hand might.
        if (expression.length === 1){

            part = expression[0]
            combinators[part.combinator].call(this, context, part, push)

        } else {

            var cs = [context], c, f, u, p = function(node){
                var uid = uniqueID(node)
                if (!u[uid]){
                    u[uid] = true
                    f[f.length] = node
                }
            }

            // loop the expression parts
            for (var j = 0; part = expression[j++];){
                f = []; u = {}
                // loop the contexts
                for (var k = 0; c = cs[k++];) combinators[part.combinator].call(this, c, part, p)
                // nothing was found, the expression failed, continue to the next expression.
                if (!f.length) continue main
                cs = f // set the contexts for future parts (if any)
            }

            if (i === 0) found = f // first expression. directly set found.
            else for (var l = 0; l < f.length; l++) push(f[l]) // any other expression needs to push to found.
        }

    }

    if (uniques && found && found.length > 1) this.sort(found)

    return found

}

Finder.prototype.sort = function(nodes){
    return this.sorter ? Array.prototype.sort.call(nodes, this.sorter) : nodes
}

// TODO: most of these pseudo selectors include <html> and qsa doesnt. fixme.

var pseudos = {


    // TODO: returns different results than qsa empty.

    'empty': function(){
        return !(this && this.nodeType === 1) && !(this.innerText || this.textContent || '').length
    },

    'not': function(expression){
        return !slick.matches(this, expression)
    },

    'contains': function(text){
        return (this.innerText || this.textContent || '').indexOf(text) > -1
    },

    'first-child': function(){
        var node = this
        while ((node = node.previousSibling)) if (node.nodeType == 1) return false
        return true
    },

    'last-child': function(){
        var node = this
        while ((node = node.nextSibling)) if (node.nodeType == 1) return false
        return true
    },

    'only-child': function(){
        var prev = this
        while ((prev = prev.previousSibling)) if (prev.nodeType == 1) return false

        var next = this
        while ((next = next.nextSibling)) if (next.nodeType == 1) return false

        return true
    },

    'first-of-type': function(){
        var node = this, nodeName = node.nodeName
        while ((node = node.previousSibling)) if (node.nodeName == nodeName) return false
        return true
    },

    'last-of-type': function(){
        var node = this, nodeName = node.nodeName
        while ((node = node.nextSibling)) if (node.nodeName == nodeName) return false
        return true
    },

    'only-of-type': function(){
        var prev = this, nodeName = this.nodeName
        while ((prev = prev.previousSibling)) if (prev.nodeName == nodeName) return false
        var next = this
        while ((next = next.nextSibling)) if (next.nodeName == nodeName) return false
        return true
    },

    'enabled': function(){
        return !this.disabled
    },

    'disabled': function(){
        return this.disabled
    },

    'checked': function(){
        return this.checked || this.selected
    },

    'selected': function(){
        return this.selected
    },

    'focus': function(){
        var doc = this.ownerDocument
        return doc.activeElement === this && (this.href || this.type || slick.hasAttribute(this, 'tabindex'))
    },

    'root': function(){
        return (this === this.ownerDocument.documentElement)
    }

}

Finder.prototype.match = function(node, bit, noTag, noId, noClass){

    // TODO: more functional tests ?

    if (!slick.noQSA && this.matchesSelector){
        var matches = this.matchesSelector(node, bit)
        if (matches !== null) return matches
    }

    // normal matching

    if (!noTag && bit.tag){

        var nodeName = node.nodeName.toLowerCase()
        if (bit.tag === "*"){
            if (nodeName < "@") return false
        } else if (nodeName != bit.tag){
            return false
        }

    }

    if (!noId && bit.id && node.getAttribute('id') !== bit.id) return false

    var i, part

    if (!noClass && bit.classes){

        var className = this.getAttribute(node, "class")
        if (!className) return false

        for (part in bit.classes) if (!RegExp('(^|\\s)' + bit.classes[part] + '(\\s|$)').test(className)) return false
    }

    var name, value

    if (bit.attributes) for (i = 0; part = bit.attributes[i++];){

        var operator  = part.operator,
            escaped   = part.escapedValue

        name  = part.name
        value = part.value

        if (!operator){

            if (!this.hasAttribute(node, name)) return false

        } else {

            var actual = this.getAttribute(node, name)
            if (actual == null) return false

            switch (operator){
                case '^=' : if (!RegExp(      '^' + escaped            ).test(actual)) return false; break
                case '$=' : if (!RegExp(            escaped + '$'      ).test(actual)) return false; break
                case '~=' : if (!RegExp('(^|\\s)' + escaped + '(\\s|$)').test(actual)) return false; break
                case '|=' : if (!RegExp(      '^' + escaped + '(-|$)'  ).test(actual)) return false; break

                case '='  : if (actual !== value) return false; break
                case '*=' : if (actual.indexOf(value) === -1) return false; break
                default   : return false
            }

        }
    }

    if (bit.pseudos) for (i = 0; part = bit.pseudos[i++];){

        name  = part.name
        value = part.value

        if (pseudos[name]) return pseudos[name].call(node, value)

        if (value != null){
            if (this.getAttribute(node, name) !== value) return false
        } else {
            if (!this.hasAttribute(node, name)) return false
        }

    }

    return true

}

Finder.prototype.matches = function(node, expression){

    var expressions = parse(expression)

    if (expressions.length === 1 && expressions[0].length === 1){ // simplest match
        return this.match(node, expressions[0][0])
    }

    // TODO: more functional tests ?

    if (!slick.noQSA && this.matchesSelector){
        var matches = this.matchesSelector(node, expressions)
        if (matches !== null) return matches
    }

    var nodes = this.search(this.document, expression, {length: 0})

    for (var i = 0, res; res = nodes[i++];) if (node === res) return true
    return false

}

var finders = {}

var finder = function(context){
    var doc = context || document
    if (doc.ownerDocument) doc = doc.ownerDocument
    else if (doc.document) doc = doc.document

    if (doc.nodeType !== 9) throw new TypeError("invalid document")

    var uid = uniqueID(doc)
    return finders[uid] || (finders[uid] = new Finder(doc))
}

// ... API ...

var slick = function(expression, context){
    return slick.search(expression, context)
}

slick.search = function(expression, context, found){
    return finder(context).search(context, expression, found)
}

slick.find = function(expression, context){
    return finder(context).search(context, expression)[0] || null
}

slick.getAttribute = function(node, name){
    return finder(node).getAttribute(node, name)
}

slick.hasAttribute = function(node, name){
    return finder(node).hasAttribute(node, name)
}

slick.contains = function(context, node){
    return finder(context).contains(context, node)
}

slick.matches = function(node, expression){
    return finder(node).matches(node, expression)
}

slick.sort = function(nodes){
    if (nodes && nodes.length > 1) finder(nodes[0]).sort(nodes)
    return nodes
}

slick.parse = parse;

// slick.debug = true
// slick.noQSA  = true

module.exports = slick

},{"./parser":687}],686:[function(require,module,exports){
(function (global){
/*
slick
*/"use strict"

module.exports = "document" in global ? require("./finder") : { parse: require("./parser") }

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./finder":685,"./parser":687}],687:[function(require,module,exports){
/*
Slick Parser
 - originally created by the almighty Thomas Aylott <@subtlegradient> (http://subtlegradient.com)
*/"use strict"

// Notable changes from Slick.Parser 1.0.x

// The parser now uses 2 classes: Expressions and Expression
// `new Expressions` produces an array-like object containing a list of Expression objects
// - Expressions::toString() produces a cleaned up expressions string
// `new Expression` produces an array-like object
// - Expression::toString() produces a cleaned up expression string
// The only exposed method is parse, which produces a (cached) `new Expressions` instance
// parsed.raw is no longer present, use .toString()
// parsed.expression is now useless, just use the indices
// parsed.reverse() has been removed for now, due to its apparent uselessness
// Other changes in the Expressions object:
// - classNames are now unique, and save both escaped and unescaped values
// - attributes now save both escaped and unescaped values
// - pseudos now save both escaped and unescaped values

var escapeRe   = /([-.*+?^${}()|[\]\/\\])/g,
    unescapeRe = /\\/g

var escape = function(string){
    // XRegExp v2.0.0-beta-3
    // « https://github.com/slevithan/XRegExp/blob/master/src/xregexp.js
    return (string + "").replace(escapeRe, '\\$1')
}

var unescape = function(string){
    return (string + "").replace(unescapeRe, '')
}

var slickRe = RegExp(
/*
#!/usr/bin/env ruby
puts "\t\t" + DATA.read.gsub(/\(\?x\)|\s+#.*$|\s+|\\$|\\n/,'')
__END__
    "(?x)^(?:\
      \\s* ( , ) \\s*               # Separator          \n\
    | \\s* ( <combinator>+ ) \\s*   # Combinator         \n\
    |      ( \\s+ )                 # CombinatorChildren \n\
    |      ( <unicode>+ | \\* )     # Tag                \n\
    | \\#  ( <unicode>+       )     # ID                 \n\
    | \\.  ( <unicode>+       )     # ClassName          \n\
    |                               # Attribute          \n\
    \\[  \
        \\s* (<unicode1>+)  (?:  \
            \\s* ([*^$!~|]?=)  (?:  \
                \\s* (?:\
                    ([\"']?)(.*?)\\9 \
                )\
            )  \
        )?  \\s*  \
    \\](?!\\]) \n\
    |   :+ ( <unicode>+ )(?:\
    \\( (?:\
        (?:([\"'])([^\\12]*)\\12)|((?:\\([^)]+\\)|[^()]*)+)\
    ) \\)\
    )?\
    )"
*/
"^(?:\\s*(,)\\s*|\\s*(<combinator>+)\\s*|(\\s+)|(<unicode>+|\\*)|\\#(<unicode>+)|\\.(<unicode>+)|\\[\\s*(<unicode1>+)(?:\\s*([*^$!~|]?=)(?:\\s*(?:([\"']?)(.*?)\\9)))?\\s*\\](?!\\])|(:+)(<unicode>+)(?:\\((?:(?:([\"'])([^\\13]*)\\13)|((?:\\([^)]+\\)|[^()]*)+))\\))?)"
    .replace(/<combinator>/, '[' + escape(">+~`!@$%^&={}\\;</") + ']')
    .replace(/<unicode>/g, '(?:[\\w\\u00a1-\\uFFFF-]|\\\\[^\\s0-9a-f])')
    .replace(/<unicode1>/g, '(?:[:\\w\\u00a1-\\uFFFF-]|\\\\[^\\s0-9a-f])')
)

// Part

var Part = function Part(combinator){
    this.combinator = combinator || " "
    this.tag = "*"
}

Part.prototype.toString = function(){

    if (!this.raw){

        var xpr = "", k, part

        xpr += this.tag || "*"
        if (this.id) xpr += "#" + this.id
        if (this.classes) xpr += "." + this.classList.join(".")
        if (this.attributes) for (k = 0; part = this.attributes[k++];){
            xpr += "[" + part.name + (part.operator ? part.operator + '"' + part.value + '"' : '') + "]"
        }
        if (this.pseudos) for (k = 0; part = this.pseudos[k++];){
            xpr += ":" + part.name
            if (part.value) xpr += "(" + part.value + ")"
        }

        this.raw = xpr

    }

    return this.raw
}

// Expression

var Expression = function Expression(){
    this.length = 0
}

Expression.prototype.toString = function(){

    if (!this.raw){

        var xpr = ""

        for (var j = 0, bit; bit = this[j++];){
            if (j !== 1) xpr += " "
            if (bit.combinator !== " ") xpr += bit.combinator + " "
            xpr += bit
        }

        this.raw = xpr

    }

    return this.raw
}

var replacer = function(
    rawMatch,

    separator,
    combinator,
    combinatorChildren,

    tagName,
    id,
    className,

    attributeKey,
    attributeOperator,
    attributeQuote,
    attributeValue,

    pseudoMarker,
    pseudoClass,
    pseudoQuote,
    pseudoClassQuotedValue,
    pseudoClassValue
){

    var expression, current

    if (separator || !this.length){
        expression = this[this.length++] = new Expression
        if (separator) return ''
    }

    if (!expression) expression = this[this.length - 1]

    if (combinator || combinatorChildren || !expression.length){
        current = expression[expression.length++] = new Part(combinator)
    }

    if (!current) current = expression[expression.length - 1]

    if (tagName){

        current.tag = unescape(tagName)

    } else if (id){

        current.id = unescape(id)

    } else if (className){

        var unescaped = unescape(className)

        var classes = current.classes || (current.classes = {})
        if (!classes[unescaped]){
            classes[unescaped] = escape(className)
            var classList = current.classList || (current.classList = [])
            classList.push(unescaped)
            classList.sort()
        }

    } else if (pseudoClass){

        pseudoClassValue = pseudoClassValue || pseudoClassQuotedValue

        ;(current.pseudos || (current.pseudos = [])).push({
            type         : pseudoMarker.length == 1 ? 'class' : 'element',
            name         : unescape(pseudoClass),
            escapedName  : escape(pseudoClass),
            value        : pseudoClassValue ? unescape(pseudoClassValue) : null,
            escapedValue : pseudoClassValue ? escape(pseudoClassValue) : null
        })

    } else if (attributeKey){

        attributeValue = attributeValue ? escape(attributeValue) : null

        ;(current.attributes || (current.attributes = [])).push({
            operator     : attributeOperator,
            name         : unescape(attributeKey),
            escapedName  : escape(attributeKey),
            value        : attributeValue ? unescape(attributeValue) : null,
            escapedValue : attributeValue ? escape(attributeValue) : null
        })

    }

    return ''

}

// Expressions

var Expressions = function Expressions(expression){
    this.length = 0

    var self = this

    var original = expression, replaced

    while (expression){
        replaced = expression.replace(slickRe, function(){
            return replacer.apply(self, arguments)
        })
        if (replaced === expression) throw new Error(original + ' is an invalid expression')
        expression = replaced
    }
}

Expressions.prototype.toString = function(){
    if (!this.raw){
        var expressions = []
        for (var i = 0, expression; expression = this[i++];) expressions.push(expression)
        this.raw = expressions.join(", ")
    }

    return this.raw
}

var cache = {}

var parse = function(expression){
    if (expression == null) return null
    expression = ('' + expression).replace(/^\s+|\s+$/g, '')
    return cache[expression] || (cache[expression] = new Expressions(expression))
}

module.exports = parse

},{}],688:[function(require,module,exports){

/**
 * `Batch' constructor
 *
 * @api public
 * @param {Number} max - optional (Default: Infinity)
 */

module.exports = Batch;
function Batch (max) {
  if (!(this instanceof Batch)) {
    return new Batch(max);
  }

  var self = this;

  this.m = 0; // max
  this.c = 0; // concurrency
  this.jobs = [];

  this.concurrency(Infinity);
  this.max(max);

  Object.defineProperty(this, 'length', {
    get: function () {
      return self.jobs.length;
    }
  });
}

/**
 * Set batch concurrency
 *
 * @api public
 * @param {Number} n
 */

Batch.prototype.concurrency = function (n) {
  if (n > 0) {
    this.c = n;
  }
  return this;
};

/**
 * Set max job limit
 *
 * @api publc
 * @param {Number} n
 */

Batch.prototype.max = function (n) {
  this.m = 'number' == typeof n && n > 0 ? n : Infinity;
  return this;
};

/**
 * Push job onto queue
 *
 * @api publc
 * @param {Function} fn
 */

Batch.prototype.push = function (fn) {
  if ('function' != typeof fn) {
    throw new TypeError("expecting a function");
  } else if (this.length < this.m) {
    this.jobs.push(fn);
  }
  return this;
};

/**
 * Shift job off of queue
 *
 * @api public
 */

Batch.prototype.shift = function () {
  return this.jobs.shift();
};

/**
 * Dequeues all queued jobs
 *
 * @api public
 * @param {Function} done - optional
 */

Batch.prototype.run = function (done) {
  done = 'function' == typeof done ? done : Function();
  var self = this;
  var c = this.c;
  var i = 0;

  // empty queue
  if (0 == this.length) {
    return done(null);
  }

  function dequeue  () {
    var job = null;
    if (0 == self.length) {
      return false;
    }

    job = self.shift();

    if ('function' != typeof job) {
      return;
    }

    try { job(next); }
    catch (err) {
      done(err)
      return false;
    }

    function next (err) {
      if (err) {
        done(err);
      } else if (self.length) {
        dequeue();
      } else {
        done();
      }
    }
  }

  while (i++ < c) {
    if (false === dequeue()) {
      break;
    }
  }

  return this;
};

},{}],689:[function(require,module,exports){
/*jslint node: true */

'use strict';

var ClientRequest = require('./request').ClientRequest;

/**
 * An autoincremented id that is used to distinguish Resolver instances.
 *
 * @type {number}
 * @private
 */
var resolverUID = 0;

/**
 * A resolver takes a request for a resources and sends it through the
 * transport.
 *
 * @constructs Resolver
 */
function Resolver() {
  if (!(this instanceof Resolver))
    return new Resolver();

  /**
   * The resolver's id.
   *
   * @type {number}
   * @protected
   */
  this._id = resolverUID++;

  /**
   * An incrementing ID used for tracking requests.
   *
   * @type {number}
   * @protected
   */
  this._requestID = 0;

  /**
   * Storage for the sent request handlers waiting for a response.
   *
   * @type {Object.<string, function>}
   * @protected
   */
  this._handlers = {};
}
exports.Resolver = Resolver;

/**
 * Adds a handler to the internal storage.
 *
 * @param {number} requestID The identifier for the request.
 * @param {ClientRequest} handler The handler for the request.
 * @protected
 */
Resolver.prototype._addHandler = function(requestID, handler) {
  this._handlers[requestID] = handler;
  return this;
};

/**
 * Removes a handler from the internal storage.
 *
 * @param {number} requestID The identifier for the request.
 * @protected
 */
Resolver.prototype._removeHandler = function(requestID) {
  this._handlers[requestID] = null;
  return this;
};

/**
 * Sends a request through the transport.
 *
 * Subclasses of this class need to implement this method.
 *
 * @param {number} requestID The id of the request.
 * @param {Object} data The payload data for the request.
 * @protected
 */
Resolver.prototype._sendRequest = function(requestID, data) {
  throw new Error('Resolver _sendRequest not implemented.');
};

/**
 * Handles a response from the transport.
 *
 * @param {Object} response The response from the transport.
 * @protected
 */
Resolver.prototype._handleResponse = function(response) {
  throw new Error('Resolver _handleResponse not implemented.');
};

/**
 * Dispatches a request handler with some data.
 *
 * @param {number} requestID The request handler to dispatch.
 * @param {Object} data The response data to send back.
 * @protected
 */
Resolver.prototype._dispatchResponse = function(requestID, requestType, data) {
  var handler = this._handlers[requestID];
  if (!handler) return;
  handler._handleResponse(requestType, data);
};

/**
 * Resolves a request (represented by the data) through the transport.
 *
 * @param {Object} data The data representing the request.
 * @param {function} onsuccess The success handler for the request.
 * @param {function} onerror The error handler for the request.
 */
Resolver.prototype._resolve = function(data, onsuccess, onerror) {
  if (!data || !onsuccess || !onerror ||
      typeof onsuccess != 'function' || typeof onerror != 'function')
    throw new TypeError('Invalid argument length for `resolve`.');

  var requestID = ++this._requestID;
  var request = new ClientRequest(this, requestID, data, onsuccess, onerror);

  this._addHandler(requestID, request);

  request.onClose = this._removeHandler.bind(this);
  request.open();

  return request;
};

/**
 * Resolves a single request (represented by the data) through the transport.
 *
 * @param {Object} data The data representing the request.
 * @param {function} onsuccess The success handler for the request.
 * @param {function} onerror The error handler for the request.
 */
Resolver.prototype.resolve = function(data, onsuccess, onerror) {
  throw new Error('Resolver resolve not implemented.');
};

/**
 * Resolves a subscription request (represented by the data) through the transport.
 *
 * @param {Object} data The data representing the request.
 * @param {function} onsuccess The success handler for the request.
 * @param {function} onerror The error handler for the request.
 */
Resolver.prototype.subscribe = function(data, onsuccess, onerror) {
  throw new Error('Resolver subscribe not implemented.');
};

},{"./request":693}],690:[function(require,module,exports){
(function (global){
/*jslint node: true */

'use strict';

var defer = require('spotify-deferred');
var Resolver = require('./bootstrap').Resolver;

/**
 * A mock resolver for a nodejs environment.
 *
 * This resolver uses regular callbacks as a transport.
 *
 * @constructs Cosmos.MockResolver
 * @extends Cosmos.Resolver
 */
function MockResolver() {
  if (!(this instanceof MockResolver))
    return new MockResolver();
  Resolver.call(this);

  // rebind the _handleResponse method so that we can reuse it for both
  // addEventListener and removeEventListener
  this._handleResponse = this._handleResponse.bind(this);

  /**
   * The identifier for request messages.
   *
   * @type {string}
   * @protected
   */
  this._requestMessageType = 'cosmos-request';

  /**
   * The identifier for response messages.
   *
   * @type {string}
   * @protected
   */
  this._responseMessageType = 'cosmos-response';

  /**
   * Prefix for the requests ids to prevent clashes
   * with bridge requests in webplayer
   *
   * @type {string}
   * @private
   */
  this._requestIdPrefix = 'cosmos_';

  this._handlersMap = {};

  // attach the handler
  this.attach();
}
MockResolver.prototype = new Resolver();
MockResolver.prototype.constructor = MockResolver;
exports.MockResolver = MockResolver;

/**
 * @inheritDoc
 */
MockResolver.prototype._sendRequest = function(requestName, requestID, data) {
  var self = this;

  var message = {
    type: this._requestMessageType,
    resolver: this._id,
    id: this._requestIdPrefix + requestID,
    name: requestName,
    payload: data.serialize ? data.serialize() : data
  };

  if (!this._handlersMap[data._action]) {
    return;
  }

  if (!this._handlersMap[data._action][data._uri]) {
    return;
  }

  this._handlersMap[data._action][data._uri](data, function (status, resp) {
    message.payload = {
      body: typeof resp !== 'undefined' ? resp : status,
      uri: data._uri,
      status: typeof resp !== 'undefined' ? status : 200
    };
    message.type = self._responseMessageType;

    var response = {
      data: message
    };
    self._handleResponse(response);
  });
};

/**
 * @inheritDoc
 */
MockResolver.prototype._handleResponse = function(response) {
  var data = response.data;
  if (typeof data == 'string') {
    try {
      data = JSON.parse(response.data);
    } catch (e) {
      return;
    }
  }
  if (data.type != this._responseMessageType ||
      data.resolver != this._id ||
      !data.payload) return;
  var id = data.id || '';
  var requestID = parseInt(id.replace(this._requestIdPrefix, ''), 10);
  var requestName = data.name || '';
  if (!requestID || !requestName) return;
  this._dispatchResponse(requestID, requestName, data.payload);
};

/**
 * Attaches the resolver so that it could process calls from the window object.
 */
MockResolver.prototype.attach = function() {
  var win = global.window;
  if (win) {
    win._cosmosRequest = this.resolve.bind(this);
  }
};

/**
 * Detaches the resolver so that it doesn't process calls from the window object.
 */
MockResolver.prototype.detach = function() {
  var win = global.window;
  if (win) {
    delete win._cosmosRequest;
  }
};

/**
 * Specific method for the mock resolver to add request handlers
 *
 * @param {string}   method       Type of method (GET, POST, PUT, SUB)
 * @param {string}   uri          Request to handle
 * @param {Function} fn           Function that handles the request
 */
MockResolver.prototype.addHandler = function(method, uri, fn) {
  if (!this._handlersMap[method]) {
    this._handlersMap[method] = {};
  }

  this._handlersMap[method][uri] = fn;
};

/**
 * Specific method for the mock resolver to remove a specific request handler
 *
 * @param {string}   method       Type of method (GET, POST, PUT, SUB)
 * @param {string}   uri          Request to handle
 */
MockResolver.prototype.removeHandler = function(method, uri) {
  if (!this._handlersMap[method]) {
    return;
  }

  if (this._handlersMap[method][uri]) {
    delete this._handlersMap[method][uri];
  }
};

/**
 * Specific method for the mock resolver to remove all handlers
 */
MockResolver.prototype.clearHandlers = function() {
  this._handlersMap = {};
};

/**
 * Resolves a single request (represented by the data) through the transport.
 * Single requests need to be closed immediately after the response is
 * received.
 *
 * @param {Object} data The data representing the request.
 * @param {function} onsuccess The success handler for the request.
 * @param {function} onerror The error handler for the request.
 */
MockResolver.prototype.resolve = function(data, onsuccess, onerror) {
  function onResult(callback, response) {
    defer(callback.bind(this, response));
    request.close();
  }

  var request = this._resolve(data, onResult.bind(this, onsuccess), onResult.bind(this, onerror));
  return request;
};

/**
 * Resolves a  subscription request (represented by the data) through the transport.
 * Subscriptions stay open until they're explicitly closed.
 * Every time the request returns some data pull for next
 * batch is sent.
 *
 * @param {Object} data The data representing the request.
 * @param {function} onsuccess The success handler for the request.
 * @param {function} onerror The error handler for the request.
 */
MockResolver.prototype.subscribe = function(data, onsuccess, onerror) {
  return this._resolve(data, onsuccess, onerror);
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./bootstrap":689,"spotify-deferred":696}],691:[function(require,module,exports){
(function (global){
/*jslint node: true */

'use strict';

var SpotifyApi = global.SpotifyApi;
var useApiRequest = !!(SpotifyApi && SpotifyApi.api &&
    typeof SpotifyApi.api.request === 'function');

var Resolver = require('./bootstrap').Resolver;
var defer = require('spotify-deferred');

/**
 * A resolver for a native environment.
 *
 * This resolver uses the Stitch bridge as a transport
 *
 * @constructs Cosmos.NativeResolver
 * @extends Cosmos.Resolver
 * @param {Object} spBridge Spotify CPP/JS bridge
 */
function NativeResolver(spBridge) {
  if (!(this instanceof NativeResolver))
    return new NativeResolver();
  if (!spBridge) {
    throw new TypeError('Missing `spBridge` parameter');
  }
  Resolver.call(this);

  this._bridge = spBridge;

  this._deferredFlush = false;
}
NativeResolver.prototype = new Resolver();
NativeResolver.prototype.constructor = NativeResolver;
exports.NativeResolver = NativeResolver;

/**
 * Prepare bridge flush.
 * TODO: Move to the separate module
 */
NativeResolver.prototype._prepareCoreFlush = function() {
  if (!this._deferredFlush) {
    this._deferredFlush = true;
    this._defer(this, this._flushRequests);
  }
};

/**
 * Flush bridge requests.
 * TODO: Move to the separate module
 */
NativeResolver.prototype._flushRequests = function() {
  this._deferredFlush = false;
  var flushMsg = JSON.stringify({ name: 'core_flush', args: []});
  this._sendBridgeRequest(flushMsg, {
    onSuccess: function() {},
    onFailure: function() {}
  });
};

/**
 * Defer the function call.
 * TODO: Move to the separate module
 */
NativeResolver.prototype._defer = function(context, callback) {
  defer(callback.bind(context));
};

/**
 * If SpotifyApi is loaded, use api requests to send messages to bridge
 * TODO: Use proxy that will handle Cosmos/Stitch calls for the resolver.
 */
NativeResolver.prototype._sendRequest = function(requestName, requestId, data) {
  var self = this;
  data = (data.serialize ? data.serialize() : data);

  var args = [requestId, data];
  var caller = { self: this, id: requestId, type: requestName };

  if (useApiRequest) {
    this._sendApiRequest(requestName, args, caller, this._handleResponse, this._handleError);
  } else {
    this._sendCosmosRequest(requestName, args, caller, this._handleResponse, this._handleError);
  }
};


/**
 * Talk to bridge directly from Cosmos
 * TODO: Move to the separate module
 */
NativeResolver.prototype._sendCosmosRequest = function(requestName, args, caller, onSuccess, onError) {
  var message = JSON.stringify({
    name: requestName,
    args: args
  });

  this._sendBridgeRequest(message, {
    onSuccess: function(data) {
      onSuccess.call(caller, JSON.parse(data));
    },
    onFailure: function(data) {
      data = JSON.parse(data);
      onError.call(caller, data);
    }
  });

  this._prepareCoreFlush();
};

/**
 * Send message to the bridge
 * @param {string} message The message to send to the bridge.
 * @param {Object.<string, function>} callbackMap The `onSuccess`
 * and `onFailure` functions to be executed after request is completed.
 * TODO: Use proxy that will handle Cosmos/Stitch calls for the resolver.
 */
NativeResolver.prototype._sendBridgeRequest = function(message, callbackMap) {
  this._bridge.executeRequest(message, callbackMap || {});
};

/**
 * Use old API to send messages to the bridge.
 * TODO: Move to the separate module
 */
NativeResolver.prototype._sendApiRequest = function(requestName, args, caller, onSuccess, onError) {
  SpotifyApi.api.request(
      requestName,
      args,
      caller,
      onSuccess,
      onError
  );
};

/**
 * Handles successful responses from the bridge
 * @param {Object} data The response data.
 */
NativeResolver.prototype._handleResponse = function(data) {
  this.self._dispatchResponse(this.id, this.type, data.responses && data.responses[0] || data);
};

/**
 * Handles failed responses from the bridge
 * @param {Object} error The error data.
 */
NativeResolver.prototype._handleError = function(error) {
  this.self._dispatchResponse(this.id, this.type, error);
};

/**
 * Resolves a single request (represented by the data) through the transport.
 * Single requests need to be closed immediately after the response is
 * received.
 *
 * @param {Object} data The data representing the request.
 * @param {function} onsuccess The success handler for the request.
 * @param {function} onerror The error handler for the request.
 */
NativeResolver.prototype.resolve = function(data, onsuccess, onerror) {
  function onResult(callback, response) {
    this._defer(this, callback.bind(this, response));
    request.close();
  }

  var request = this._resolve(data, onResult.bind(this, onsuccess), onResult.bind(this, onerror));
  return request;
};

/**
 * Resolves a  subscription request (represented by the data) through the transport.
 * Subscriptions stay open until they're explicitly closed.
 * Every time the request returns some data pull for next
 * batch is sent.
 *
 * @param {Object} data The data representing the request.
 * @param {function} onsuccess The success handler for the request.
 * @param {function} onerror The error handler for the request.
 */
NativeResolver.prototype.subscribe = function(data, onsuccess, onerror) {
  function onResult(callback, response) {
    callback.call(this, response);
    request.pull();
  }

  var request = this._resolve(data, onResult.bind(this, onsuccess), onResult.bind(this, onerror));
  return request;
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./bootstrap":689,"spotify-deferred":696}],692:[function(require,module,exports){
(function (global){
/*jslint node: true */

'use strict';

var defer = require('spotify-deferred');
var Resolver = require('./bootstrap').Resolver;

/**
 * A resolver for a web-based environment.
 *
 * This resolver uses postMessage as a transport.
 *
 * @constructs Cosmos.WebResolver
 * @extends Cosmos.Resolver
 * @type {string=} opt_target The optional target for the postMessage calls.
 */
function WebResolver(opt_target) {
  if (!(this instanceof WebResolver))
    return new WebResolver(opt_target);
  Resolver.call(this);

  /**
   * The target for postMessage calls.
   *
   * @type {string}
   * @protected
   */
  this._target = opt_target || '*';

  // rebind the _handleResponse method so that we can reuse it for both
  // addEventListener and removeEventListener
  this._handleResponse = this._handleResponse.bind(this);

  /**
   * The identifier for request messages.
   *
   * @type {string}
   * @protected
   */
  this._requestMessageType = 'cosmos-request';

  /**
   * The identifier for response messages.
   *
   * @type {string}
   * @protected
   */
  this._responseMessageType = 'cosmos-response';

  /**
   * Prefix for the requests ids to prevent clashes
   * with bridge requests in webplayer
   *
   * @type {string}
   * @private
   */
  this._requestIdPrefix = 'cosmos_';

  // attach the handler
  this.attach();
}
WebResolver.prototype = new Resolver();
WebResolver.prototype.constructor = WebResolver;
exports.WebResolver = WebResolver;

/**
 * @inheritDoc
 */
WebResolver.prototype._sendRequest = function(requestName, requestID, data) {
  var top = global.window.top;

  var message = {
    type: this._requestMessageType,
    resolver: this._id,
    id: this._requestIdPrefix + requestID,
    name: requestName,
    payload: data.serialize ? data.serialize() : data
  };
  top.postMessage(JSON.stringify(message), this._target);
};

/**
 * @inheritDoc
 */
WebResolver.prototype._handleResponse = function(response) {
  var data = response.data;
  if (typeof data == 'string') {
    try {
      data = JSON.parse(response.data);
    } catch (e) {
      return;
    }
  }
  if (data.type != this._responseMessageType ||
      data.resolver != this._id ||
      !data.payload) return;
  var id = data.id || '';
  var requestID = parseInt(id.replace(this._requestIdPrefix, ''), 10);
  var requestName = data.name || '';
  if (!requestID || !requestName) return;
  this._dispatchResponse(requestID, requestName, data.payload);
};

/**
 * Attaches the resolver so that it could process postMessage calls.
 */
WebResolver.prototype.attach = function() {
  var win = global.window;
  if (win.addEvent && !win.addEventListener) {
    win.addEvent('onmessage', this._handleResponse);
  } else {
    win.addEventListener('message', this._handleResponse, false);
  }
};

/**
 * Detaches the resolver so that it doesn't process postMessage calls.
 */
WebResolver.prototype.detach = function() {
  var win = global.window;
  if (win.removeEvent && !win.removeEventListener) {
    win.removeEvent('onmessage', this._handleResponse);
  } else {
    win.removeEventListener('message', this._handleResponse, false);
  }
};

/**
 * Resolves a single request (represented by the data) through the transport.
 * Single requests need to be closed immediately after the response is
 * received.
 *
 * @param {Object} data The data representing the request.
 * @param {function} onsuccess The success handler for the request.
 * @param {function} onerror The error handler for the request.
 */
WebResolver.prototype.resolve = function(data, onsuccess, onerror) {
  function onResult(callback, response) {
    defer(callback.bind(this, response));
    request.close();
  }

  var request = this._resolve(data, onResult.bind(this, onsuccess), onResult.bind(this, onerror));
  return request;
};

/**
 * Resolves a  subscription request (represented by the data) through the transport.
 * Subscriptions stay open until they're explicitly closed.
 * Every time the request returns some data pull for next
 * batch is sent.
 *
 * @param {Object} data The data representing the request.
 * @param {function} onsuccess The success handler for the request.
 * @param {function} onerror The error handler for the request.
 */
WebResolver.prototype.subscribe = function(data, onsuccess, onerror) {
  return this._resolve(data, onsuccess, onerror);
};

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./bootstrap":689,"spotify-deferred":696}],693:[function(require,module,exports){
/*jslint node: true */

'use strict';

var defer = require('spotify-deferred');

/**
 * The representation of the connection to the client.
 * With introduction of Cosmos subscription the model of making
 * client requests changed.
 * Each Cosmos requests now needs to be explicitly cancelled to
 * close the connection.
 * Simple requests that only send or retrieve data (e.g POST and GET)
 * need to send 'cosmos_request_cancel' message immediately after the response
 * is received.
 * Subscription requests need to send a 'cosmos_request_pull' message every time
 * they receive data. The consumer of the subscription needs to cancel the subscription
 * when no more data should be sent from the provider.
 */
function ClientRequest(resolver, requestId, data, onsuccess, onerror) {

  /**
   * Request identifier.
   * @type {number}
   */
  this._requestId = requestId;

  /**
   * Either web or native request resolver.
   * @type {Cosmos.Resolver}
   */
  this._resolver = resolver;

  /**
   * Data that should be passed with every request.
   * @type {*}
   */
  this._requestData = data;

  /**
   * Triggered on success
   * @type {function}
   */
  this._successCallback = onsuccess;

  /**
   * Triggered on error
   * @type {function}
   */
  this._errorCallback = onerror;

  /**
   * Current state of the request.
   * @type {ClientRequest.status}
   */
  this._status = ClientRequest.status.INITIALIZED;
}
exports.ClientRequest = ClientRequest;

/**
 * Possible state of the ClientRequest instance.
 */
ClientRequest.status = {
  INITIALIZED: 'INITIALIZED',
  CLOSED: 'CLOSED',
  OPEN: 'OPEN'
};

/**
 * Possible desktop bridge messages.
 */
ClientRequest.messages = {
  OPEN: 'cosmos_request_create',
  PULL: 'cosmos_request_pull',
  CLOSE: 'cosmos_request_cancel'
};

/**
 * Opens the connection with the client.
 */
ClientRequest.prototype.open = function() {
  if (this._status === ClientRequest.status.INITIALIZED) {
    this._status = ClientRequest.status.OPEN;
    this._sendRequest(ClientRequest.messages.OPEN, this._requestData);
  }
};

/**
 * Send pull request for the open connection.
 * For subscriptions pull should resolve to a
 * piece of data.
 */
ClientRequest.prototype.pull = function() {
  if (this._status === ClientRequest.status.OPEN) {
    this._sendRequest(ClientRequest.messages.PULL, this._requestData);
  }
  return this._status;
};

/**
 * Closes the connection with the client.
 */
ClientRequest.prototype.close = function() {
  if (this._status === ClientRequest.status.OPEN) {
    this._status = ClientRequest.status.CLOSE;
    this._sendRequest(ClientRequest.messages.CLOSE);
  }
};

ClientRequest.prototype.onClose = function() {};

/**
 * Sends the request to the platform specific resolver
 * @param {string} requestName The message type. One of the {ClientRequest.messages}.
 * @param {object?} data The data to send with the request.
 */
ClientRequest.prototype._sendRequest = function(requestName, data) {
  this._resolver._sendRequest(requestName, this._requestId, data || {});
};

/**
 * Handles the response for the given request
 * @param {String} requestName The message type. One of the {ClientRequest.messages}.
 * @param {Object} data The response data.
 */
ClientRequest.prototype._handleResponse = function(requestName, data) {
  var self = this;
  var status = data && data.status;
  var callback;

  if (requestName === ClientRequest.messages.CLOSE) {
    this._successCallback = null;
    this._errorCallback = null;
    this._requestData = null;
    this.onClose(this._requestId);
    return;
  }

  callback = this._successCallback;
  callback = typeof callback === 'function' ? callback : function() {};
  defer(callback.bind(this, data));
};

},{"spotify-deferred":696}],694:[function(require,module,exports){
(function (global){
'use strict';

var window = global.window || {};
var process = global.process;

var common = require('cosmos-common-js');
var Resolver = require('./scripts/resolver').Resolver;

var SPResolver = null;
var spResolver = null;

var hasNativeBridge = window._getSpotifyModule &&
    typeof window._getSpotifyModule === 'function' &&
    window._getSpotifyModule('bridge');

var nodeRegex = /(node)|(grunt)|(iojs)(\.exe)*$/;
var isNodeJs = process && process.title && nodeRegex.test(process.argv[0]);

if (!isNodeJs) {
  if (hasNativeBridge) {
    SPResolver = require('./env/bootstrap.native.js').NativeResolver;
    spResolver = new SPResolver(hasNativeBridge);
  } else {
    SPResolver = require('./env/bootstrap.web.js').WebResolver;
    spResolver = new SPResolver();
  }
} else {
  SPResolver = require('./env/bootstrap.mock.js').MockResolver;
  spResolver = new SPResolver();

  exports.mockResolver = {
    addHandler: spResolver.addHandler.bind(spResolver),
    removeHandler: spResolver.removeHandler.bind(spResolver),
    clearHandlers: spResolver.clearHandlers.bind(spResolver)
  };
}

exports.Resolver = Resolver;
exports.Action = common.request.Action;
exports.Request = common.request.Request;
exports.Response = common.response.Response;
exports.resolver = spResolver ? new Resolver(spResolver) : null;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./env/bootstrap.mock.js":690,"./env/bootstrap.native.js":691,"./env/bootstrap.web.js":692,"./scripts/resolver":697,"cosmos-common-js":520}],695:[function(require,module,exports){
/**
 * @file
 * Unified window messaging facility.
 *
 * This module exports two functions to the Spotify
 * namespace which allows other subsystems to handle
 * particular types of messages sent through the native
 * window.postMessage method.
 *
 * @see Spotify.addMessageHandler
 * @see Spotify.removeMessageHandler
 */
'use strict';

var POST_ROUTER_ID = 'post-router-msg-' + new Date().getTime();

var hasStructuredClone = false;

var setImmediate = setImmediate ? setImmediate : setTimeout;

var CURRENT_WINDOW_ORIGIN = undefined;

if (typeof window !== 'undefined') {
  CURRENT_WINDOW_ORIGIN = (window.location.origin ||
      window.location.protocol + '//' + window.location.hostname);

  // Hacky solution to make it work for the webplayer.
  if (!window.__forceNoStructuredClone) {
    // Check if the platform has support for structured cloning.
    //
    // In platforms where this is supported, sending a postMessage with an
    // object that contains a function will throw an error, as it is not
    // cloneable.
    try {
      window.postMessage({
        toString: function() {
          return "clone-test";
        }
      }, CURRENT_WINDOW_ORIGIN);
      hasStructuredClone = false;
    } catch(e) {
      hasStructuredClone = true;
    }
  }
}

/**
 * Storage for message handlers.
 *
 * @type {Object.<string, Spotify.Shell.MessageHandler>}
 * @private
 */
var handlers = {};


/**
 * Variable to check if the window is already listening to postMessage events
 *
 * @type {bool}
 * @private
 */
var isListening = false;


function handleImmediateMessage(data) {
  var handler = handlers[data.type];
  if (!handler) return;
  handler.fn.call(this, data);
}


/**
 * Main event handler for the window message event.
 *
 * @param {Event} event The message event object.
 * @private
 */
function handlePostMessage(event) {
  var data = event.data;
  if (!hasStructuredClone) {
    if (typeof data == 'string') {
      try {
        data = JSON.parse(data);
      } catch (e) {
        return;
      }
    } else {
      // We only expect strings.
      return;
    }
  }
  if (event.origin == CURRENT_WINDOW_ORIGIN) {
    data = data[POST_ROUTER_ID];
    if (!data) {
      // Not our data, return immediately.
      return;
    }
  }
  var handler = handlers[data.type];
  if (!handler || handler.origin != '*' && event.origin !== handler.origin) {
    return;
  }
  handler.fn.call(this, data, event);
}

/**
 * Attaches the handlePostMessage function to PostMessage events
 *
 * @private
 */
var startListening = function() {
  if (window.attachEvent && !window.addEventListener) {
    // IE8 and Below
    window.attachEvent('onmessage', handlePostMessage);
  } else if (window.attachEvent && window.addEventListener) {
    // IE9
    window.addEventListener('message', handlePostMessage, false);
  } else if (window.addEventListener) {
    // Everyone else
    window.addEventListener('message', handlePostMessage, false);
  }
};


/**
 * Adds a message handler for a particular message type.
 *
 * The message handler function will be invoked when the window receives
 * a message marked as a particular type, receiving an argument. The
 * argument will be the data payload of the event decoded from JSON.
 *
 * @param {string} type The type of the message to handle.
 * @param {function} fn The handler function.
 * @param {string} origin needed
 * @throws {Error} Thrown if the message type being handled already has
 *     a handler function.
 */
var addMessageHandler = function(type, fn, origin) {
  if (typeof window !== 'undefined' && !isListening) {
    startListening();
    isListening = true;
  }

  if (!origin) {
    origin = CURRENT_WINDOW_ORIGIN;
  }

  if (handlers[type]) {
    throw new Error('Rehandling of message "' + type + '" not allowed.');
  }
  handlers[type] = {
    fn: fn,
    origin: origin
  };
  return;
};


/**
 * Removes a message handler for a particular message type.
 *
 * @param {string} type The type of the message to remove.
 * @param {Spotify.Shell.MessageHandler} fn The handler function.
 * @return {boolean} True if the handler function was succesfully removed.
 */
var removeMessageHandler = function(type, fn) {
  if (handlers[type] && (!fn || handlers[type].fn === fn)) {
    handlers[type] = null;
    return true;
  }
  return false;
};


/**
 * Sends a message to the event handler
 *
 * @param {string} type The type of the message to remove.
 * @param {Object} data JSON object to pass to the handler
 */
var sendMessage = function(type, data, destWindow, origin) {
  data = data || {};
  data.type = type;

  if (typeof window === 'undefined') {
    return setImmediate(handleImmediateMessage.bind(null, data));
  }

  destWindow = destWindow || window;

  if (!origin) {
    origin = CURRENT_WINDOW_ORIGIN;
  }

  destWindow.postMessage(JSON.stringify(data), origin);
};

var sendLocalMessage = function(type, data) {
  data = data || {};
  data.type = type;

  if (typeof window === 'undefined') {
    return setImmediate(handleImmediateMessage.bind(null, data));
  }

  // Wrap the data in a custom object to quickly identify the message.
  var wrapper = {};
  wrapper[POST_ROUTER_ID] = data;

  window.postMessage(hasStructuredClone ?
                     wrapper :
                     JSON.stringify(wrapper), CURRENT_WINDOW_ORIGIN);
};


/**
 * Export public interface
 */
module.exports = {
  addMessageHandler: addMessageHandler,
  removeMessageHandler: removeMessageHandler,
  sendMessage: sendMessage,
  sendLocalMessage: sendLocalMessage,
  WINDOW_ORIGIN: CURRENT_WINDOW_ORIGIN
};

},{}],696:[function(require,module,exports){
/**
 * @file
 * Introduces a function called "defer" that allows functions to be
 * executed in the next available tick.
 *
 * Unlike "setTimeout", "defer" executes the function at the nearest
 * possible time without clamping.
 *
 * @see Spotify.defer
 */
'use strict';

var PostRouter = require('spotify-postrouter');


/**
 * Storage for deferred functions to be executed.
 *
 * @type {Array.<function()>}
 * @private
 */
var deferred = [];


/**
 * A bound version of the postMessage routine used to trigger deferred
 * execution.
 *
 * @type {function()}
 * @private
 */
var send = function () {
  PostRouter.sendLocalMessage('execute_deferreds');
};


/**
 * Executes the deferred functions when the window
 * receives an 'execute_deferreds' message.
 *
 * @private
 */
function executeDeferreds() {
  var fns = deferred.splice(0);
  if (!fns.length) return;
  for (var i = 0, l = fns.length; i < l; i++) {
    try {
      fns[i]();
    } finally {
      // Do nothing.
      null;
    }
  }
}

PostRouter.addMessageHandler('execute_deferreds', executeDeferreds);


/**
 * Executes the function applied at the nearest possible time without
 * clamping.
 *
 * @param {function()} fn The function to execute.
 */
var defer = function(fn) {
  var trigger = !deferred.length;
  deferred.push(fn);
  if (trigger) send();
};


/**
 * Export public interface
 */
module.exports = defer;

},{"spotify-postrouter":695}],697:[function(require,module,exports){
var common = require('cosmos-common-js');

var Request = common.request.Request;
var Action = common.request.Action;
var Response = common.response.Response;

/**
 * Checks whether a status is successful.
 *
 * We define a successful status to be something within the 200 to 299 range.
 *
 * @param {number} status The status to check.
 */
function _isSuccessStatus(status) {
  // This constitutes a successfull status.
  return (status >= 200 && status <= 299);
};


function Resolver(spResolver) {
  if (!spResolver || typeof spResolver.resolve !== 'function') {
    throw TypeError('Incorrect resolver argument');
  }

  this._resolver = spResolver;
}

/**
 * The basic, generic method of sending the requests.
 *
 * For params description:
 * @borrows Resolver#_resolve as Resolver#resolve
 */
Resolver.prototype.resolve = function(request, callback) {
  return this._resolve(request, callback);
};

/**
 * Convenience method for doing GET requests.
 * resolver.get('sp://player') is an equivalent of
 * resolver.resolve(new Request('GET', 'sp://player')).
 *
 * @param {string|Object.<string, object>} options If is a string
 * will be parsed as url. If more data is needed, object notation
 * should be used.
 *  param options.url {string} The url of the request.
 *  param options.body {object=} The request body.
 *  param options.headers {object=} The request headers.
 * @param {function(error=, object?)} callback The function
 * executed after the request has been completed.
 *
 * @return {RequestHandler} The cancellable request handler.
 */
Resolver.prototype.get = function(options, callback) {
  return this._resolveFromParams(Action.GET, options, callback);
};

/**
 * Convenience method for doing POST requests.
 * resolver.post('sp://player') is an equivalent of
 * resolver.resolve(new Request('POST', 'sp://player'))
 *
 * @see Resolver#get for params description and returned value.
 */
Resolver.prototype.post = function(options, callback) {
  return this._resolveFromParams(Action.POST, options, callback);
};

/**
 * Convenience method for doing SUB requests.
 * resolver.subscribe('sp://player') is an equivalent of
 * resolver.resolve(new Request('SUB', 'sp://player'))
 *
 * @see Resolver#get for params description and returned value.
 */
Resolver.prototype.subscribe = function(options, callback) {
  return this._resolveFromParams(Action.SUB, options, callback);
};

/**
 * Convenience method for doing PUT requests.
 * resolver.put('sp://ads/v1/settings/session') is an equivalent of
 * resolver.resolve(new Request('PUT', 'sp://ads/v1/settings/session'))
 *
 * @see Resolver#get for params description and returned value.
 */
Resolver.prototype.put = function(options, callback) {
  return this._resolveFromParams(Action.PUT, options, callback);
};

/**
 * Convenience method for doing PATCH requests.
 * resolver.patch('sp://ads/v1/settings/session') is an equivalent of
 * resolver.resolve(new Request('PATCH', 'sp://ads/v1/settings/session'))
 *
 * @see Resolver#get for params description and returned value.
 */
Resolver.prototype.patch = function(options, callback) {
  return this._resolveFromParams(Action.PATCH, options, callback);
};

/**
 * Convenience method for doing DELETE requests.
 * resolver.delete('sp://player') is an equivalent of
 * resolver.resolve(new Request('DELETE', 'sp://player'))
 *
 * @see Resolver#get for params description and returned value.
 */
Resolver.prototype.delete = function(options, callback) {
  return this._resolveFromParams(Action.DELETE, options, callback);
};

/**
 * @private
 * Sends the request to the platform specific request resolver.
 * If the request action is 'SUB' it will send subscribe request
 * In any other case it will send simple resolve request.
 *
 * @param {Cosmos.Request} request A request object.
 * @param {function(error=, object?)} callback The function
 * executed after the request has been completed.
 *
 * @return {RequestHandler} The cancellable request handler.
 */
Resolver.prototype._resolve = function(request, callback) {
  if (!callback || typeof callback !== 'function') {
    callback = function() {};
  }

  var requestHandler;

  function onSuccess(serverResponse) {
    if (!requestHandler._request) {
      return;
    }

    var response = Response.fromObject(serverResponse);
    if (!response) {
      var error = new Error(
        'Failed to parse response: ' + JSON.stringify(serverResponse));
      return callback(error);
    }

    if (_isSuccessStatus(response.getStatusCode())) {
      return callback(null, response);
    } else {
      // Extract just the initial part of the request uri. It's good to have something
      // but it is also good to avoid having everything, since that can hurt dashboards
      // that group error messages.
      var requestEndpoint = request.toJSON().uri.match(/[^\:]*(\:\/\/)?[^\/]*/)[0];
      var errorMessage = (
        response.getHeader("error") ||
        "Request to " + requestEndpoint + " failed with status code " + response.getStatusCode());
      var error = new Error(errorMessage);
      error.response = response;
      return callback(error, response);
    }
  }

  function onError(serverResponse) {
    return callback(serverResponse instanceof Error ?
      serverResponse :
      new Error('Request failed: ' + JSON.stringify(serverResponse)));
  }

  var resolveFn = request.getAction() === Action.SUB ?
      this._resolver.subscribe : this._resolver.resolve;

  var clientRequest = resolveFn.call(this._resolver, request, onSuccess, onError);

  requestHandler = new RequestHandler(clientRequest);
  return requestHandler;
};

/**
 * @private
 * Creates Request object from supplied params.
 * @param {string} method Request method. One of the Request.Action.
 * @param {string|Object.<string, object>} options If is a string
 * will be parsed as url. If more data is needed, object notation
 * should be used.
 *  param options.url {string} The url of the request.
 *  param options.body {object=} The request body.
 *  param options.headers {object=} The request headers.
 * @param {function(error=, object?)} callback The function
 * executed after the request has been completed.
 *
 * @return {RequestHandler} The cancellable request handler.
 */
Resolver.prototype._resolveFromParams = function(method, options, callback) {
  options = options || {};

  var url = typeof options === 'string' ? options : options.url;
  var headers = options.headers;
  var body = options.body;

  var request = new Request(method, url, headers, body);

  return this._resolve(request, callback);
};

/**
 * The object that wraps the clientRequest
 * in a very simple interface.
 * Separates the implementation of the ClientRequest
 * from the request handler returned by Cosmos API.
 *
 * @param {Cosmos.ClientRequest} request The object
 * representing the newly opened request to the client.
 * Usually a request will be a subscription that
 * needs a close handler.
 */
function RequestHandler(request) {
  if (!request || typeof request.close !== 'function')
    throw new TypeError('Invalid `request` argument.');

  this._request = request;
}

/**
 * Closes the request and removes the object.
 */
RequestHandler.prototype.cancel = function() {
  if (this._request) {
    this._request.close();
    this._request = null;
  }
};

exports.Resolver = Resolver;

},{"cosmos-common-js":520}],698:[function(require,module,exports){
'use strict';

/**
 * The Base62 Converter
 *
 * @class Base62
 * @constructor
 *
 */

var digits = '0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ';
var invHexDigits = {};
var invDigits = {};

for (var i = 0; i < digits.length; ++i) { invDigits[digits[i]] = i; }
for (var i = 0; i < 16; ++i) { invHexDigits['0123456789abcdef'[i]] = i; }
for (var i = 0; i < 16; ++i) { invHexDigits['0123456789ABCDEF'[i]] = i; }

/**
 * lhs *= rhs
 * @private
 */
function mul(lhs, rhs, base) {
  var rest = 0;
  for (var i = 0; i < lhs.length; ++i) {
    var tmp = lhs[i] * rhs + rest;
    lhs[i] = tmp % base;
    rest = ~~(tmp / base);
  }
  while (rest) {
    lhs.push(rest % base);
    rest = ~~(rest / base);
  }
}

/**
 * acc += lhs * rhs
 * @private
 */
function madd(acc, lhs, rhs, base) {
  var rest = 0;
  for (var i = 0; i < lhs.length; ++i) {
    var tmp = ~~acc[i] + lhs[i] * rhs + rest;
    acc[i] = tmp % base;
    rest = ~~(tmp / base);
  }
  while (rest) {
    var tmp = ~~acc[i] + rest;
    acc[i] = tmp % base;
    rest = ~~(tmp / base);
    ++i;
  }
}

/**
 * Change base
 * @private
 */
function convert(data, fromBase, toBase) {
  var r = [0];
  var b = [1];
  for (var i = 0; i < data.length; ++i) {
    madd(r, b, data[i], toBase);
    mul(b, fromBase, toBase);
  }
  return r;
}

/**
 * Decode to
 * @private
 */
function mapr(data, mapping) {
  for (var i = 0, r = []; i < data.length; ++i) { r.push(mapping[data[i]]); }
  return r.reverse();
}

/**
 * Pad with 0s
 * @private
 */
function pad(data, length) {
  while (data.length < length) { data.push(0); }
  return data;
}

module.exports = {

  /**
   * Converts from array of bytes to base62 encoded string.
   *
   * @public
   * @name Spotify.Utils.Base62#fromBytes
   * @function
   * @param {Array.<number>} data Array of byte numbers.
   * @param {?number} length Do zeropadding until at least this length.
   * @return {string} Base62 encoded string.
  **/
  fromBytes: function(data, length) {
    var r = convert(data.slice(0).reverse(), 256, 62);
    return mapr(pad(r, length), digits).join('');
  },

  /**
   * Converts from base62 encoded string to array of bytes
   *
   * @public
   * @name Spotify.Utils.Base62#toBytes
   * @function
   * @param {string} str Base62 encoded string.
   * @param {?number} length Do zeropadding until at least this length.
   * @return {Array.<number>} Array of byte numbers.
  **/
  toBytes: function(str, length) {
    var r = convert(mapr(str, invDigits), 62, 256);
    return pad(r, length).reverse();
  },

  /**
   * Converts from base62 encoded string to hex encoded string
   *
   * @public
   * @name Spotify.Utils.Base62#toHex
   * @function
   * @param {string} str Base62 encoded string.
   * @param {?number} length Do zeropadding until at least this length.
   * @return {string} Hex encoded string.
  **/
  toHex: function(str, length) {
    var r = convert(mapr(str, invDigits), 62, 16);
    return mapr(pad(r, length), digits).join('');
  },

  /**
   * Converts from hex encoded strign to base62 encoded string
   *
   * @public
   * @name Spotify.Utils.Base62#fromHex
   * @function
   * @param {string} str Hex encoded string.
   * @param {?number} length Do zeropadding until at least this length.
   * @return {string} Base62 encoded string.
  **/
  fromHex: function(str, length) {
    var r = convert(mapr(str, invHexDigits), 16, 62);
    return mapr(pad(r, length), digits).join('');
  }

};

},{}],699:[function(require,module,exports){
(function() {
  /**
   * @file
   * Introduces a function called "defer" that allows functions to be
   * executed in the next available tick.
   *
   * Unlike "setTimeout", "defer" executes the function at the nearest
   * possible time without clamping.
   *
   * @see Spotify.defer
   */
  'use strict';

  var hasWindow = typeof window != 'undefined';
  var hasDefineProperty = typeof Object.defineProperty == 'function';

  if (hasWindow && window.__modDefFn) {
    // If deferred has been attached to the global scope
    module.exports = window.__modDefFn;
    return;
  }

  /**
   * Storage for deferred functions to be executed.
   *
   * @type {Array.<function()>}
   * @private
   */
  var deferred = [];


  /**
   * A bound version of the postMessage routine used to trigger deferred
   * execution.
   *
   * @type {function()}
   * @private
   */
  var send;
  var origin;

  if (hasWindow && window.postMessage) {
    origin = (window.location.origin ||
          window.location.protocol + '//' + window.location.hostname);
    send = window.postMessage.bind(window, '@execute_deferreds', origin);
    if (!window.__hasDeferredHandler) {
      if (hasDefineProperty) {
        Object.defineProperty(window, '__hasDeferredHandler', {value: 1});
      } else {
        window.__hasDeferredHandler = 1;
      }
      var handler = function(e) {
        if (e.origin != origin && e.data != '@execute_deferreds') {
          return;
        }
        executeDeferreds();
      };
      if (window.addEventListener) {
        window.addEventListener('message', handler);
      } else {
        window.attachEvent('onmessage', handler);
      }
    }
  } else if (typeof setImmediate != 'undefined') {
    send = setImmediate.bind(null, executeDeferreds);
  } else {
    send = setTimeout.bind(null, executeDeferreds, 10);
  }


  /**
   * Executes the deferred functions when the window
   * receives an 'execute_deferreds' message.
   *
   * @private
   */
  function executeDeferreds() {
    var fns = deferred.splice(0);
    if (!fns.length) return;
    for (var i = 0, l = fns.length; i < l; i++) {
      try {
        fns[i]();
      } finally {
        // Do nothing.
        null;
      }
    }
  }


  /**
   * Executes the function applied at the nearest possible time without
   * clamping.
   *
   * @param {function()} fn The function to execute.
   */
  var defer = function(fn) {
    var trigger = !deferred.length;
    deferred.push(fn);
    if (trigger) send();
  };

  if (hasWindow && !window.__modDefFn) {
    if (hasDefineProperty) {
      Object.defineProperty(window, '__modDefFn', {value: defer});
    } else {
      window.__modDefFn = defer;
    }
  }

  /**
   * Export public interface
   */
  module.exports = defer;

})();

},{}],700:[function(require,module,exports){
/**
 * @module spotify-eventemitter
 */
'use strict';

/**
 * @private
 */
var _defer = require('spotify-deferred');

/**
 * The event handlers.
 *
 * @typedef {Array.<function>}
 * @private
 */
var EventHandlers;

/**
 * Represents an Event.
 *
 * **NOTE**: The Event class is an internal class: you cannot instantiate it
 * directly. Instead, you should use the provided
 * {@link module:spotify-eventemitter.createEvent} function.
 *
 * @constructor
 * @param {string} type The type name of the event object.
 * @param {Object} props An object that will be added as properties of the
 *     event object.
 * @see {@link module:spotify-eventemitter.createEvent}
 */
function Event(type, props) {
  /**
   * The type of the event.
   *
   * @type {string}
   */
  this.type = type;

  /**
   * A flag for whether preventDefault was called.
   *
   * @type {boolean}
   * @private
   */
  this._prevented = false;

  /**
   * A flag for whether stopPropagation was called
   *
   * @type {boolean}
   * @private
   */
  this._stopped = false;

  /**
   * A flag for whether stopImmediatePropagation was called.
   *
   * @type {boolean}
   * @private
   */
  this._immediateStopped = false;

  if (props) {
    for (var key in props) {
      if (key == 'type') {
        continue;
      }
      this[key] = props[key];
    }
  }
}

/**
 * Prevents the default operation for the event.
 */
Event.prototype.preventDefault = function() {
  this._prevented = true;
};

/**
 * Returns whether preventDefault was called on the event.
 *
 * @return {boolean} True if preventDefault was called, false otherwise.
 */
Event.prototype.isDefaultPrevented = function() {
  return this._prevented;
};

/**
 * Stops the propagation of the event.
 */
Event.prototype.stopPropagation = function() {
  this._stopped = true;
};

/**
 * Returns whether stopPropagation was called on the event.
 *
 * @return {boolean} True if stopPropagation was called, false otherwise.
 */
Event.prototype.isPropagationStopped = function() {
  return this._stopped;
};

/**
 * Stops the immediate propagation of the event.
 *
 * Handlers added after any event handler calling this method will not receive
 * the event.
 */
Event.prototype.stopImmediatePropagation = function() {
  this._immediateStopped = true;
};

/**
 * Returns whether stopImmediatePropagation was called on the event.
 *
 * @return {boolean} True if stopImmediatePropagation was called, false
 *     otherwise.
 */
Event.prototype.isImmediatePropagationStopped = function() {
  return this._immediateStopped;
};

/**
 * An EventEmitter is an object that can be listened to for events.
 *
 * Instances of this class are not usually used directly; instead, a class that
 * needs EventEmitter functionality would inherit from the EventEmitter class
 * so that it's instances can use events.
 *
 * @constructor
 * @alias module:spotify-eventemitter
 *
 * @example <caption>Direct usage</caption>
 * var EventEmitter = require('spotify-eventemitter');
 * var emitter = new EventEmitter();
 * emitter.addListener('someEvent', function() {
 *     console.log('someEvent fired!');
 * });
 * emitter.emit('someEvent');
 * @example <caption>Inheritance</caption>
 * var EventEmitter = require('spotify-eventemitter');
 * var inherit = require('spotify-inherit/inherit');
 *
 * function MyClass() {
 *   EventEmitter.call(this);
 * }
 * inherit(MyClass, EventEmitter);
 *
 * var instance = new MyClass();
 * instance.addListener('someEvent', function() {
 *     console.log('someEvent fired!');
 * });
 * instance.emit('someEvent');
 */
function EventEmitter() {
  /**
   * A map of event names to event handlers.
   *
   * @type {Object.<string, module:spotify-eventemitter~EventHandlers>}
   * @private
   */
  this._listenerMap;
}

/**
 * Creates a new Event object.
 *
 * @param {string} type The type name of the event.
 * @param {Object=} opt_params An object containing properties for the new event
 *     object.
 * @return {module:spotify-eventemitter~Event} The new event object.
 */
EventEmitter.createEvent = function(type, opt_params) {
  return new Event(type, opt_params);
};

/**
 * Adds an event listener to the emitter.
 *
 * This method is idempotent: calling it multiple times using the same type
 * and listener arguments will only set the listener once. This behaviour is
 * done to prevent accidental additions of the same event listener.
 *
 * @param {string} type The type of event to listen to.
 * @param {function} listener A function to be called when the emitter fires
 *     the event specified in the type.
 * @return {module:spotify-eventemitter} The event emitter.
 */
EventEmitter.prototype.addListener = function(type, listener) {
  var _listenerMap = this._listenerMap || (this._listenerMap = {});
  var listeners = _listenerMap[type] || (_listenerMap[type] = []);
  if (listeners.indexOf(listener) != -1) {
    // Handler already added, return quickly.
    return this;
  }
  listeners.push(listener);
  return this;
};

/**
 * Adds multiple event listeners to the emitter.
 *
 * @param {Object.<string, function>} eventListeners An object, the keys of
 *     which correspond to the name of events to listen to, and the value of
 *     each of these keys should be a function that would be added as the
 *     listener for that event.
 * @return {module:spotify-eventemitter} The event emitter.
 */
EventEmitter.prototype.addListeners = function(eventListeners) {
  for (var type in eventListeners) {
    this.addListener(type, eventListeners[type]);
  }
  return this;
};

/**
 * Adds a "once" event listener to the emitter, which will be removed right
 * after it has been fired.
 *
 * In order to achieve the "once" behaviour, the listener argument passed to
 * this method is wrapped in a function, which is then returned by the method.
 *
 * Because of this wrapping, this method is not idempotent: calling it multiple
 * times with the same type and listener arguments will result to multiple
 * event listeners attached.
 *
 * @param {string} type The type of event to listen to.
 * @param {function} listener A function to be called when the emitter fires
 *     the event specified in the type and then automatically removed.
 * @return {function} The function used to wrap the listener function argument.
 *     This function can be used as an argument to removeEvent.
 */
EventEmitter.prototype.addOnceListener = function(type, listener) {
  var wrapper = function() {
    this.removeListener(type, wrapper);
    return listener.apply(this, arguments);
  };
  this.addListener(type, wrapper);
  return wrapper;
};

/**
 * Removes an event listener from the emitter.
 *
 * @param {string} type The type of event to remove.
 * @param {function} listener The listener function to remove. This must be a
 *     function that was added previously using addEvent.
 * @return {module:spotify-eventemitter} The event emitter.
 */
EventEmitter.prototype.removeListener = function(type, listener) {
  var _listenerMap = this._listenerMap;
  var listeners = _listenerMap && _listenerMap[type];
  if (!listeners) {
    return this;
  }
  var index = listeners.indexOf(listener);
  if (index == -1) {
    return this;
  }
  listeners.splice(index, 1);
  if (!listeners.length) {
    _listenerMap[type] = null;
  }
  return this;
};

/**
 * Removes all event listeners from the emitter for a particular type.
 *
 * @param {string} type The event type to remove.
 * @return {module:spotify-eventemitter} The event emitter.
 */
EventEmitter.prototype.removeAllListeners = function(type) {
  var _listenerMap = this._listenerMap;
  if (!_listenerMap) {
    return this;
  }
  _listenerMap[type] = null;
  return this;
};

/**
 * Removes multiple event listeners from the emitter.
 *
 * @param {Object.<string, function>} eventListeners An object, the keys of
 *     which correspond to the name of events to listen to, and the value of
 *     each of these keys should be a function that would be added as the
 *     listener for that event.
 * @return {module:spotify-eventemitter} The event emitter.
 */
EventEmitter.prototype.removeListeners = function(eventListeners) {
  for (var type in eventListeners) {
    this.removeListener(type, eventListeners[type]);
  }
  return this;
};

/**
 * Creates and emits an event on the emitter.
 *
 * This method invokes all the added event listeners of the `type` provided in
 * the order they were added, passing in a new Event object created using the
 * provided `type` and `opt_params` arguments.
 *
 * This method emits events asynchronously: the listeners are not called until
 * the next run loop.
 *
 * @param {string} type The type name of the event to emit.
 * @param {Object=} opt_params An object containing parameters for the Event
 *     object.
 * @return {module:spotify-eventemitter~Event} The Event object that was
 *     created.
 */
EventEmitter.prototype.emit = function(type, opt_params) {
  var event = new Event(type, opt_params);
  _defer(function() {
    this.emitEventSync(event);
  }.bind(this));
  return event;
};

/**
 * Emits an event on the emitter.
 *
 * This method invokes all the added event listeners of the `type` of the
 * `event` provided in the order they were added, passing in the `event` as an
 * argument.
 *
 * This method emits events asynchronously: the listeners are not called until
 * the next run loop.
 *
 * @param {module:spotify-eventemitter~Event} event The Event object.
 * @return {module:spotify-eventemitter~Event} The Event object that was passed.
 */
EventEmitter.prototype.emitEvent = function(event) {
  _defer(function() {
    this.emitEventSync(event);
  }.bind(this));
  return event;
};

/**
 * Creates and synchronously emits an event on the emitter.
 *
 * This method invokes all the added event listeners of the `type` provided in
 * the order they were added, passing in a new Event object created using the
 * provided `type` and `opt_params` arguments.
 *
 * @param {string} type The type name of event to emit.
 * @param {Object=} opt_params An object containing parameters for the event
 *     object.
 * @return {module:spotify-eventemitter~Event} The Event object that was
 *     created.
 */
EventEmitter.prototype.emitSync = function(type, opt_params) {
  var event = new Event(type, opt_params);
  this.emitEventSync(event);
  return event;
};

/**
 * Synchronously emits an event on the emitter.
 *
 * This method invokes all the added event listeners of the `type` of the
 * `event` provided in the order they were added, passing in the `event` as an
 * argument.
 *
 * @param {module:spotify-eventemitter~Event} event The Event object.
 * @return {module:spotify-eventemitter~Event} The Event object that was passed.
 */
EventEmitter.prototype.emitEventSync = function(event) {
  var type = event.type;
  var _listenerMap = this._listenerMap;
  var listeners = _listenerMap && _listenerMap[type];
  if (!listeners || !listeners.length) {
    return event;
  }
  listeners = listeners.slice(0);
  for (var i = 0, l = listeners.length; i < l; i++) {
    listeners[i].call(this, event);
    if (event.isImmediatePropagationStopped()) {
      break;
    }
  }
  return event;
};

// DEPRECATED METHODS:

/**
 * Adds an event listener to the emitter.
 *
 * **NOTE**: This method has been deprecated in favor of
 * {@link module:spotify-eventemitter#addListener}.
 *
 * This method is idempotent: calling it multiple times using the same type
 * and listener arguments will only set the listener once. This behaviour is
 * done to prevent accidental additions of the same event listener.
 *
 * @deprecated since v2.0.0.
 * @param {string} type The type of event to listen to.
 * @param {function} listener A function to be called when the emitter fires
 *     the event specified in the type.
 * @return {module:spotify-eventemitter} The event emitter.
 * @see {@link module:spotify-eventemitter#addListener}
 */
EventEmitter.prototype.addEvent = function(type, listener) {
  return this.addListener(type, listener);
};

/**
 * Adds multiple event listeners to the emitter.
 *
 * **NOTE**: This method has been deprecated in favor of
 * {@link module:spotify-eventemitter#addListeners}.
 *
 * @deprecated since v2.0.0.
 * @param {Object.<string, function>} eventListeners An object, the keys of
 *     which correspond to the name of events to listen to, and the value of
 *     each of these keys should be a function that would be added as the
 *     listener for that event.
 * @return {module:spotify-eventemitter} The event emitter.
 * @see {@link module:spotify-eventemitter#addListeners}
 */
EventEmitter.prototype.addEvents = function(eventListeners) {
  return this.addListeners(eventListeners);
};

/**
 * Adds a "once" event listener to the emitter, which will be removed right
 * after it has been fired.
 *
 * **NOTE**: This method has been deprecated in favor of
 * {@link module:spotify-eventemitter#addOnceListener}.
 *
 * In order to achieve the "once" behaviour, the listener argument passed to
 * this method is wrapped in a function, which is then returned by the method.
 *
 * Because of this wrapping, this method is not idempotent: calling it multiple
 * times with the same type and listener arguments will result to multiple
 * event listeners attached.
 *
 * @deprecated since v2.0.0.
 * @param {string} type The type of event to listen to.
 * @param {function} listener A function to be called when the emitter fires
 *     the event specified in the type and then automatically removed.
 * @return {function} The function used to wrap the listener function argument.
 *     This function can be used as an argument to removeEvent.
 * @see {@link module:spotify-eventemitter#addOnceListener}
 */
EventEmitter.prototype.addOnceEvent = function(type, listener) {
  return this.addOnceListener(type, listener);
};

/**
 * Removes an event listener from the emitter.
 *
 * **NOTE**: This method has been deprecated in favor of
 * {@link module:spotify-eventemitter#removeListener}.
 *
 * @deprecated since v2.0.0.
 * @param {string} type The type of event to remove.
 * @param {function} listener The listener function to remove. This must be a
 *     function that was added previously using addEvent.
 * @return {module:spotify-eventemitter} The event emitter.
 * @see {@link module:spotify-eventemitter#removeListener}
 */
EventEmitter.prototype.removeEvent = function(type, listener) {
  return this.removeListener(type, listener);
};

/**
 * Removes multiple event listeners from the emitter.
 *
 * **NOTE**: This method has been deprecated in favor of
 * {@link module:spotify-eventemitter#removeListeners}.
 *
 * @deprecated since v2.0.0.
 * @param {Object.<string, function>} events An object, the keys of which
 *     correspond to the name of events to remove, and the value of each of
 *     these keys should be a function that would be removed as a listener.
 * @return {module:spotify-eventemitter} The event emitter.
 * @see {@link module:spotify-eventemitter#removeListeners}
 */
EventEmitter.prototype.removeEvents = function(eventListeners) {
  return this.removeListeners(eventListeners);
};

/**
 * Fires an event on the emitter, optionally passing arguments to the listeners.
 *
 * **NOTE**: This method has been deprecated in favor of
 * {@link module:spotify-eventemitter#emit}.
 *
 * This method fire events asynchronously: the listeners are not called until
 * the next run loop. A third boolean parameter can be passed to change this
 * behaviour.
 *
 * @deprecated since v2.0.0.
 * @param {string} type The type of event to fire.
 * @param {Array.<*>=} opt_args A set of objects that would be passed to the
 *     event listeners as arguments.
 * @param {boolean=} opt_priority Passing true will fire the event synchronously.
 * @return {module:spotify-eventemitter} The event emitter.
 * @see {@link module:spotify-eventemitter#emit}
 */
EventEmitter.prototype.fireEvent = function(type, opt_args, opt_priority) {
  if (opt_priority) {
    this.fireEventSync(type, opt_args);
  } else {
    var self = this;
    _defer(function() { self.fireEventSync(type, opt_args); });
  }
  return this;
};

/**
 * Fires an event on the emitter synchronously, optionally passing arguments to
 * the listeners.
 *
 * **NOTE**: This method has been deprecated in favor of
 * {@link module:spotify-eventemitter#emitSync}.
 *
 * @deprecated since v2.0.0.
 * @param {string} type The type of event to fire.
 * @param {Array.<*>=} opt_args A set of objects that would be passed to the
 *     event listeners as arguments.
 * @return {module:spotify-eventemitter} The event emitter.
 * @see {@link module:spotify-eventemitter#emitSync}
 */
EventEmitter.prototype.fireEventSync = function(type, opt_args) {
  var self = this;
  var events = this._listenerMap && this._listenerMap[type];
  if (!events || !events.length) return this;
  events = events.slice(0);
  var i, l;
  if (!opt_args) {
    for (i = 0, l = events.length; i < l; i++) {
      events[i].call(self);
    }
  } else {
    if (!Array.isArray(opt_args)) {
      opt_args = [opt_args];
    }
    for (i = 0, l = events.length; i < l; i++) {
      events[i].apply(self, opt_args);
    }
  }
  return this;
};

/**
 * Adds an event listener to the emitter.
 *
 * **NOTE**: This method has been deprecated in favor of
 * {@link module:spotify-eventemitter#addListener}.
 *
 * This method is idempotent: calling it multiple times using the same type
 * and listener arguments will only set the listener once. This behaviour is
 * done to prevent accidental additions of the same event listener.
 *
 * @deprecated since v2.0.0.
 * @param {string} type The type of event to listen to.
 * @param {function} listener A function to be called when the emitter fires
 *     the event specified in the type.
 * @return {module:spotify-eventemitter} The event emitter.
 * @see {@link module:spotify-eventemitter#addListener}
 */
EventEmitter.prototype.on = function(type, listener) {
  return this.addEvent(type, listener);
};

/**
 * Adds a "once" event listener to the emitter, which will be removed right
 * after it has been fired.
 *
 * **NOTE**: This method has been deprecated in favor of
 * {@link module:spotify-eventemitter#addOnceListener}.
 *
 * In order to achieve the "once" behaviour, the listener argument passed to
 * this method is wrapped in a function, which is then returned by the method.
 *
 * Because of this wrapping, this method is not idempotent: calling it multiple
 * times with the same type and listener arguments will result to multiple
 * event listeners attached.
 *
 * @deprecated since v2.0.0.
 * @param {string} type The type of event to listen to.
 * @param {function} listener A function to be called when the emitter fires
 *     the event specified in the type and then automatically removed.
 * @return {function} The function used to wrap the listener function argument.
 *     This function can be used as an argument to removeEvent.
 * @see {@link module:spotify-eventemitter#addOnceListener}
 */
EventEmitter.prototype.once = function(type, listener) {
  return this.addOnceEvent(type, listener);
};

/**
 * Removes an event listener or all event listeners from the emitter.
 *
 * **NOTE**: This method has been deprecated in favor of
 * {@link module:spotify-eventemitter#removeListener}.
 *
 * @deprecated since v2.0.0.
 * @param {string} type The type of event to remove.
 * @param {function=} opt_listener The listener function to remove. This must be
 *     a function that was added previously using addEvent. If this parameter is
 *     not given, all event listeners of the corresponding `type` argument will
 *     be removed.
 * @return {module:spotify-eventemitter} The event emitter.
 * @see {@link module:spotify-eventemitter#removeListener}
 * @see {@link module:spotify-eventemitter#removeListeners}
 */
EventEmitter.prototype.off = function(type, opt_listener) {
  if (typeof opt_listener === 'function') {
    return this.removeEvent(type, opt_listener);
  }
  // if no listener set, remove all the listeners from the event
  this._listenerMap[type] = null;
  return this;
};

/**
 * Exporting
 */
module.exports = EventEmitter;

},{"spotify-deferred":699}],701:[function(require,module,exports){
var v1 = require('./v1');

exports.v1 = v1;

/**
 * Export the current version of the player API
 */
for (var key in v1) {
  exports[key] = v1[key];
}

},{"./v1":703}],702:[function(require,module,exports){
var cosmos = require('spotify-cosmos-api');

/**
 * Gaia is the main entry point to control connect with cosmos.
 *
 * @param {Cosmos.resolver} resolver The resolver to send requests to.
 * @param {String} endpoint Can either be 'spirc' or 'gaia' depending on if we should use
 *                          the old ('spirc') or the new ('gaia') resolver endpoint in core.
 *                          Defaults to 'gaia'.
 */
function Gaia(resolver, endpoint) {
  if (!resolver) {
    throw new TypeError('Missing parameters for Gaia');
  }

  if (!(this instanceof Gaia)) {
    return new Gaia(resolver);
  }

  this.resolver = resolver;
  if (!endpoint) {
    endpoint = 'gaia';
  }
  this.gaia_url = 'sp://' + endpoint + '/v1/';
}
/**
 * Transfer playback to a device.
 *
 * @param device_id The device ID.
 * @param {function(Error, Cosmos.Response=)} callback The function
 *    that will be called when the request completes.
 * @return {Cosmos.Request=} The Request handle.
 */
Gaia.prototype.transferPlayback = function(device_id, callback) {
  var request = new cosmos.Request(cosmos.Action.POST, this.getEndpointUri() + "transfer", null, device_id);
  return this.resolver.resolve(request, callback);
};
/**
 * Pull playback to the local device.
 *
 * @param {function(Error, Cosmos.Response=)} callback The function
 *    that will be called when the request completes.
 * @return {Cosmos.Request=} The Request handle.
 */
Gaia.prototype.pullPlayback = function(callback) {
  var request = new cosmos.Request(cosmos.Action.POST, this.getEndpointUri() + "pull", null);
  return this.resolver.resolve(request, callback);
};
/**
 * Set a device as `attached`.
 *
 * @param device_id The device ID.
 * @param {function(Error, Cosmos.Response=)} callback The function
 *    that will be called when the request completes.
 * @return {Cosmos.Request=} The Request handle.
 */
Gaia.prototype.attach = function(device_id, callback) {
  var request = new cosmos.Request(cosmos.Action.POST, this.getEndpointUri() + "attach", null, device_id);
  return this.resolver.resolve(request, callback);
};
/**
 * Set a device as `detached`.
 *
 * @param device_id The device ID.
 * @param {function(Error, Cosmos.Response=)} callback The function
 *    that will be called when the request completes.
 * @return {Cosmos.Request=} The Request handle.
 */
Gaia.prototype.detach = function(device_id, callback) {
  var request = new cosmos.Request(cosmos.Action.POST, this.getEndpointUri() + "detach", null, device_id);
  return this.resolver.resolve(request, callback);
};
/**
 * Send a volume up command to a device.
 *
 * @param device_id The device ID.
 * @param {function(Error, Cosmos.Response=)} callback The function
 *    that will be called when the request completes.
 * @return {Cosmos.Request=} The Request handle.
 */
Gaia.prototype.volumeUp = function(device_id, callback) {
  return this.resolver.resolve(
    new cosmos.Request(cosmos.Action.POST, this.getEndpointUri() + "volume/up", null, device_id),
    callback);
};
/**
 * Send a volume down command to a device.
 *
 * @param device_id The device ID.
 * @param {function(Error, Cosmos.Response=)} callback The function
 *    that will be called when the request completes.
 * @return {Cosmos.Request=} The Request handle.
 */
Gaia.prototype.volumeDown = function(device_id, callback) {
  return this.resolver.resolve(
    new cosmos.Request(cosmos.Action.POST, this.getEndpointUri() + "volume/down", null, device_id),
    callback);
};
/**
 * Send a logout command to a device.
 *
 * @param device_id The device ID.
 * @param {function(Error, Cosmos.Response=)} callback The function
 *    that will be called when the request completes.
 * @return {Cosmos.Request=} The Request handle.
 */
Gaia.prototype.logout = function(device_id, callback) {
  return this.resolver.resolve(
    new cosmos.Request(cosmos.Action.POST, this.getEndpointUri() + "logout", null, device_id),
    callback);
};
/**
 * Set the system volume.
 *
 * TODO(santeri): This should probably be moved to a system resolver or some such.
 *
 * @param volume The new volume, in the range of 0-65535.
 * @param {function(Error, Cosmos.Response=)} callback The function
 *    that will be called when the request completes.
 * @return {Cosmos.Request=} The Request handle.
 */
Gaia.prototype.setSystemVolume = function(volume, callback) {
  return this.resolver.resolve(
    new cosmos.Request(cosmos.Action.POST, this.getEndpointUri() + "volume", null, volume),
    callback);
};
/**
 * Trigger discovery.
 *
 * @param type can be one of "mdns", "dial", "hermes", "local", "all" or "nomdns"
 * @param {function(Error, Cosmos.Response=)} callback The function
 *    that will be called when the request completes.
 * @return {Cosmos.Request=} The Request handle.
 */
Gaia.prototype.discover = function(discovery_type, callback) {
  var request = new cosmos.Request(cosmos.Action.POST, this.getEndpointUri() + "discover", null, discovery_type);
  return this.resolver.resolve(request, callback);
};
/**
 * Inject gaia protobuf message into gaia core
 *
 * @param protobuf a protobuf buffer encoded as a hex string
 * @param {function(Error, Cosmos.Response=)} callback The function
 *    that will be called every time the event occurs.
 * @return {RequestHandle} The subscription handle.
 */
Gaia.prototype.mockSpirc = function(protobuf, callback) {
  var request = new cosmos.Request(cosmos.Action.POST, this.getEndpointUri() + "mock/spirc", null, protobuf);
  return this.resolver.resolve(request, callback);
};
/**
 * Subscribe to gaia events
 *
 * These will be triggered when the Gaia manager running state changes,
 * when the device map changes and when playback transfers happen.
 *
 * When subscribe is called the full state returned directly, without
 * waiting for an event to trigger.
 *
 * @param {function(Error, Cosmos.Response=)} callback The function
 *    that will be called every time the event occurs.
 * @return {RequestHandle} The subscription handle.
 *
 *    This object can be used to cancel the subscription
 *    by calling 'cancel()' on it:
 *
 *    var sub = gaia.subscribe(function(err, response) { });
 *    sub.cancel();
 */
Gaia.prototype.subscribe = function(callback) {
  return this.resolver.resolve(
      new cosmos.Request(cosmos.Action.SUB, this.getEndpointUri()),
      callback);
};
Gaia.prototype.getEndpointUri = function() {
  return this.gaia_url;
};

exports.Gaia = Gaia;

},{"spotify-cosmos-api":694}],703:[function(require,module,exports){
var gaia = require("./gaia");

exports.Gaia = gaia.Gaia;

},{"./gaia":702}],704:[function(require,module,exports){
'use strict';

/**
 * Function to add properties to an object
 * @param {Object} obj The input object
 * @param {Object} args The objects which are going to be injected
 * @return {Object} The extended object
 */
var extend = function(obj, args) {
  var source;

  for (var i = 1; i < arguments.length; i++) {
    source = arguments[i];
    if (source) {
      for (var prop in source) {
        if (source.hasOwnProperty(prop)) {
          obj[prop] = source[prop];
        }
      }
    }
  }
  return obj;
};


/**
 * Export public interface
 */
module.exports = extend;

},{}],705:[function(require,module,exports){
'use strict';

module.exports = {
  inherit: require('./inherit'),
  extend: require('./extend')
};

},{"./extend":704,"./inherit":706}],706:[function(require,module,exports){
'use strict';

/**
 * Makes a class inherit from a superclass' prototype indirectly.
 *
 * @param {Spotify.ClassLike} Sub The class that will inherit.
 * @param {Spotify.ClassLike} Super The class to inherit from.
 */
var inherit = function(Sub, Super) {
  var superProto = Super.prototype;
  function Superclass() {}
  Superclass.prototype = Sub._super = superProto;
  Superclass.prototype.constructor = Super;
  Sub.prototype = new Superclass();
};


/**
 * Export public interface
 */
module.exports = inherit;

},{}],707:[function(require,module,exports){
'use strict';

/**
 * @private
 */
var Base62 = require('spotify-crypto/src/base62');

/**
 * The URI prefix for URIs.
 *
 * @const
 * @private
 */
var URI_PREFIX = 'spotify:';

/**
 * The URL prefix for Play.
 *
 * @const
 * @private
 */
var PLAY_HTTP_PREFIX = 'http://play.spotify.com/';

/**
 * The HTTPS URL prefix for Play.
 *
 * @const
 * @private
 */
var PLAY_HTTPS_PREFIX = 'https://play.spotify.com/';

/**
 * The URL prefix for Open.
 *
 * @const
 * @private
 */
var OPEN_HTTP_PREFIX = 'http://open.spotify.com/';

/**
 * The HTTPS URL prefix for Open.
 *
 * @const
 * @private
 */
var OPEN_HTTPS_PREFIX = 'https://open.spotify.com/';

var ERROR_INVALID = new TypeError('Invalid Spotify URI!');
var ERROR_NOT_IMPLEMENTED = new TypeError('Not implemented!');


/**
 * The format for the URI to parse.
 *
 * @enum {number}
 * @private
 */
var Format = {
  URI: 0,
  URL: 1
};

/**
 * Represents the result of a URI splitting operation.
 *
 * @typedef {{
 *    format: Format,
 *    components: Array.<string>
 * }}
 * @see _splitIntoComponents
 * @private
 */
var SplittedURI;

/**
 * Split an string URI or HTTP/HTTPS URL into components, skipping the prefix.
 *
 * @param {string} str A string URI to split.
 * @return {SplittedURI} The parsed URI.
 * @private
 */
var _splitIntoComponents = function(str) {
  var components;
  var format;
  var anchor;

  var hashSplit = str.split('#');

  if (hashSplit.length > 1) {
    // first token
    str = hashSplit.shift();
    // last token
    anchor = hashSplit.pop();
  }

  if (str.indexOf(URI_PREFIX) === 0) {
    components = str.slice(URI_PREFIX.length).split(':');
    format = Format.URI;
  } else {
    // For HTTP URLs, ignore any query string argument
    str = str.split('?')[0];

    if (str.indexOf(PLAY_HTTP_PREFIX) === 0) {
      components = str.slice(PLAY_HTTP_PREFIX.length).split('/');
    } else if (str.indexOf(PLAY_HTTPS_PREFIX) === 0) {
      components = str.slice(PLAY_HTTPS_PREFIX.length).split('/');
    } else if (str.indexOf(OPEN_HTTP_PREFIX) === 0) {
      components = str.slice(OPEN_HTTP_PREFIX.length).split('/');
    } else if (str.indexOf(OPEN_HTTPS_PREFIX) === 0) {
      components = str.slice(OPEN_HTTPS_PREFIX.length).split('/');
    } else {
      throw ERROR_INVALID;
    }
    format = Format.URL;
  }

  if (anchor) {
    components.push(anchor);
  }

  return {
    format: format,
    components: components
  };
};

/**
 * Encodes a component according to a format.
 *
 * @param {string} component A component string.
 * @param {Format} format A format.
 * @return {string} An encoded component string.
 * @private
 */
var _encodeComponent = function(component, format) {
  component = encodeURIComponent(component);
  if (format === Format.URI) {
    component = component.replace(/%20/g, '+');
  }

  // encode characters that are not encoded by default by encodeURIComponent
  // but that the Spotify URI spec encodes: !'*()
  component = component.replace(/[!'()]/g, escape);
  component = component.replace(/\*/g, '%2A');

  return component;
};

/**
 * Decodes a component according to a format.
 *
 * @param {string} component An encoded component string.
 * @param {Format} format A format.
 * @return {string} An decoded component string.
 * @private
 */
var _decodeComponent = function(component, format) {
  var part = format == Format.URI ? component.replace(/\+/g, '%20') : component;
  return decodeURIComponent(part);
};

/**
 * Returns the components of a URI as an array.
 *
 * @param {URI} uri A uri.
 * @param {Format} format The output format.
 * @return {Array.<string>} An array of uri components.
 * @private
 */
var _getComponents = function(uri, format) {
  var base62;
  if (uri.id) {
    base62 = uri._base62Id;
  }

  var components;
  var i;
  var len;
  switch (uri.type) {
    case URI.Type.ALBUM:
      components = [URI.Type.ALBUM, base62];
      if (uri.disc) {
        components.push(uri.disc);
      }
      return components;
    case URI.Type.AD:
      return [URI.Type.AD, uri._base62Id];
    case URI.Type.ARTIST:
      return [URI.Type.ARTIST, base62];
    case URI.Type.ARTIST_TOPLIST:
      return [URI.Type.ARTIST, base62, URI.Type.TOP, uri.toplist];
    case URI.Type.SEARCH:
      return [URI.Type.SEARCH, _encodeComponent(uri.query, format)];
    case URI.Type.TRACK:
      if (uri.anchor) {
        base62 += '#' + uri.anchor;
      }
      return [URI.Type.TRACK, base62];
    case URI.Type.TRACKSET:
      var trackIds = [];
      for (i = 0, len = uri.tracks.length; i < len; i++) {
        trackIds.push(uri.tracks[i]._base62Id);
      }
      trackIds = [trackIds.join(',')];
      // Index can be 0 sometimes (required for trackset)
      if (uri.index !== null) {
        trackIds.push('#', uri.index);
      }
      return [URI.Type.TRACKSET, _encodeComponent(uri.name)].concat(trackIds);
    case URI.Type.FACEBOOK:
      return [URI.Type.USER, URI.Type.FACEBOOK, uri.uid];
    case URI.Type.AUDIO_FILE:
      return [URI.Type.AUDIO_FILE, uri.extension, uri._base62Id];
    case URI.Type.FOLDER:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.FOLDER, uri._base62Id];
    case URI.Type.FOLLOWERS:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.FOLLOWERS];
    case URI.Type.FOLLOWING:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.FOLLOWING];
    case URI.Type.PLAYLIST:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.PLAYLIST, base62];
    case URI.Type.STARRED:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.STARRED];
    case URI.Type.TEMP_PLAYLIST:
      return [URI.Type.TEMP_PLAYLIST, uri.origin, uri.data];
    case URI.Type.CONTEXT_GROUP:
      return [URI.Type.CONTEXT_GROUP, uri.origin, uri.name];
    case URI.Type.USER_TOPLIST:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.TOP, uri.toplist];
    // Legacy Toplist
    case URI.Type.USER_TOP_TRACKS:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.TOPLIST];
    case URI.Type.TOPLIST:
      return [URI.Type.TOP, uri.toplist].concat(uri.global ? [URI.Type.GLOBAL] : ['country', uri.country]);
    case URI.Type.INBOX:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.INBOX];
    case URI.Type.ROOTLIST:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.ROOTLIST];
    case URI.Type.PUBLISHED_ROOTLIST:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.PUBLISHED_ROOTLIST];
    case URI.Type.COLLECTION_TRACK_LIST:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.COLLECTION_TRACK_LIST, base62];
    case URI.Type.PROFILE:
      if (uri.args && uri.args.length > 0)
        return [URI.Type.USER, _encodeComponent(uri.username, format)].concat(uri.args);
      return [URI.Type.USER, _encodeComponent(uri.username, format)];
    case URI.Type.LOCAL_ARTIST:
      return [URI.Type.LOCAL, _encodeComponent(uri.artist, format)];
    case URI.Type.LOCAL_ALBUM:
      return [URI.Type.LOCAL, _encodeComponent(uri.artist, format), _encodeComponent(uri.album, format)];
    case URI.Type.LOCAL:
      return [URI.Type.LOCAL,
        _encodeComponent(uri.artist, format),
        _encodeComponent(uri.album, format),
        _encodeComponent(uri.track, format),
        uri.duration];
    case URI.Type.LIBRARY:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.LIBRARY].concat(uri.category ? [uri.category] : []);
    case URI.Type.IMAGE:
      return [URI.Type.IMAGE, uri._base62Id];
    case URI.Type.MOSAIC:
      components = uri.ids.slice(0);
      components.unshift(URI.Type.MOSAIC);
      return components;
    case URI.Type.RADIO:
      return [URI.Type.RADIO, uri.args];
    case URI.Type.SPECIAL:
      components = [URI.Type.SPECIAL];
      var args = uri.args || [];
      for (i = 0, len = args.length; i < len; ++i)
        components.push(_encodeComponent(args[i], format));
      return components;
    case URI.Type.STATION:
      components = [URI.Type.STATION];
      var args = uri.args || [];
      for (i = 0, len = args.length; i < len; i++) {
        components.push(_encodeComponent(args[i], format));
      }
      return components;
    case URI.Type.APPLICATION:
      components = [URI.Type.APP, uri._base62Id];
      var args = uri.args || [];
      for (i = 0, len = args.length; i < len; ++i)
        components.push(_encodeComponent(args[i], format));
      return components;
    case URI.Type.COLLECTION_ALBUM:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.COLLECTION, URI.Type.ALBUM, base62];
    case URI.Type.COLLECTION_MISSING_ALBUM:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.COLLECTION, URI.Type.ALBUM, base62, 'missing'];
    case URI.Type.COLLECTION_ARTIST:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.COLLECTION, URI.Type.ARTIST, base62];
    case URI.Type.COLLECTION:
      return [URI.Type.USER, _encodeComponent(uri.username, format), URI.Type.COLLECTION].concat(uri.category ? [uri.category] : []);
    case URI.Type.EPISODE:
      return [URI.Type.EPISODE, base62];
    default:
      throw ERROR_INVALID;
  }
};

/**
 * Parses the components of a URI into a real URI object.
 *
 * @param {Array.<string>} components The components of the URI as a string
 *     array.
 * @param {Format} format The format of the source string.
 * @return {URI} The URI object.
 * @private
 */
var _parseFromComponents = function(components, format) {
  var _current = 0;

  var _getNextComponent = function() {
    return components[_current++];
  };

  var _getIdComponent = function() {
    var component = _getNextComponent();

    if (component.length > 22) {
      throw new Error('Invalid ID');
    }
    return component;
  };

  var _getRemainingComponents = function() {
    return components.slice(_current);
  };

  var _getRemainingString = function() {
    var separator = (format == Format.URI) ? ':' : '/';
    return components.slice(_current).join(separator);
  };

  var part = _getNextComponent();
  var id;
  var i;
  var len;

  switch (part) {
    case URI.Type.ALBUM:
      return URI.albumURI(_getIdComponent(), parseInt(_getNextComponent(), 10));
    case URI.Type.AD:
      return URI.adURI(_getNextComponent());
    case URI.Type.ARTIST:
      id = _getIdComponent();
      if (_getNextComponent() == URI.Type.TOP) {
        return URI.artistToplistURI(id, _getNextComponent());
      } else {
        return URI.artistURI(id);
      }
    case URI.Type.AUDIO_FILE:
      return URI.audioFileURI(_getNextComponent(), _getNextComponent());
    case URI.Type.TEMP_PLAYLIST:
      return URI.temporaryPlaylistURI(_getNextComponent(), _getRemainingString());
    case URI.Type.SEARCH:
      return URI.searchURI(_decodeComponent(_getRemainingString(), format));
    case URI.Type.TRACK:
      return URI.trackURI(_getIdComponent(), _getNextComponent());
    case URI.Type.TRACKSET:
      var name = _decodeComponent(_getNextComponent());
      var tracksArray = _getNextComponent();
      var hashSign = _getNextComponent();
      var index = parseInt(_getNextComponent(), 10);
      // Sanity check: %23 is URL code for "#"
      if (hashSign !== '%23' || isNaN(index)) {
        index = null;
      }
      var tracksetTracks = [];
      if (tracksArray) {
        tracksArray = _decodeComponent(tracksArray).split(',');
        for (i = 0, len = tracksArray.length; i < len; i++) {
          var trackId = tracksArray[i];
          tracksetTracks.push(URI.trackURI(trackId));
        }
      }
      return URI.tracksetURI(tracksetTracks, name, index);
    case URI.Type.CONTEXT_GROUP:
      return URI.contextGroupURI(_getNextComponent(), _getNextComponent());
    case URI.Type.TOP:
      var type = _getNextComponent();
      if (_getNextComponent() == URI.Type.GLOBAL) {
        return URI.toplistURI(type, null, true);
      } else {
        return URI.toplistURI(type, _getNextComponent(), false);
      }
    case URI.Type.USER:
      var username = _decodeComponent(_getNextComponent(), format);
      var text = _getNextComponent();
      if (username == URI.Type.FACEBOOK && text != null) {
        return URI.facebookURI(parseInt(text, 10));
      } else if (text != null) {
        switch (text) {
          case URI.Type.PLAYLIST:
            return URI.playlistURI(username, _getIdComponent());
          case URI.Type.FOLDER:
            return URI.folderURI(username, _getIdComponent());
          case URI.Type.COLLECTION_TRACK_LIST:
            return URI.collectionTrackList(username, _getIdComponent());
          case URI.Type.COLLECTION:
            var collectionItemType = _getNextComponent();
            switch (collectionItemType) {
              case URI.Type.ALBUM:
                id = _getIdComponent();
                if (_getNextComponent() === 'missing') {
                  return URI.collectionMissingAlbumURI(username, id);
                } else {
                  return URI.collectionAlbumURI(username, id);
                }
              case URI.Type.ARTIST:
                return URI.collectionArtistURI(username, _getIdComponent());
              default:
                return URI.collectionURI(username, collectionItemType);
            }
          case URI.Type.STARRED:
            return URI.starredURI(username);
          case URI.Type.FOLLOWERS:
            return URI.followersURI(username);
          case URI.Type.FOLLOWING:
            return URI.followingURI(username);
          case URI.Type.TOP:
            return URI.userToplistURI(username, _getNextComponent());
          case URI.Type.INBOX:
            return URI.inboxURI(username);
          case URI.Type.ROOTLIST:
            return URI.rootlistURI(username);
          case URI.Type.PUBLISHED_ROOTLIST:
            return URI.publishedRootlistURI(username);
          case URI.Type.TOPLIST:
            // legacy toplist
            return URI.userTopTracksURI(username);
          case URI.Type.LIBRARY:
            return URI.libraryURI(username, _getNextComponent());
        }
      }
      var rem = _getRemainingComponents();
      if (text != null && rem.length > 0) {
        return URI.profileURI(username, [text].concat(rem));
      } else if (text != null) {
        return URI.profileURI(username, [text]);
      } else {
        return URI.profileURI(username);
      }
    case URI.Type.LOCAL:
      var artistNameComponent = _getNextComponent();
      var artistName = artistNameComponent && _decodeComponent(artistNameComponent, format);
      var albumNameComponent = _getNextComponent();
      var albumName = albumNameComponent && _decodeComponent(albumNameComponent, format);
      var trackNameComponent = _getNextComponent();
      var trackName = trackNameComponent && _decodeComponent(trackNameComponent, format);
      var durationComponent = _getNextComponent();
      var duration = parseInt(durationComponent, 10);
      if (trackNameComponent !== undefined) {
        return URI.localURI(artistName, albumName, trackName, duration);
      } else if (albumNameComponent !== undefined) {
        return URI.localAlbumURI(artistName, albumName);
      } else {
        return URI.localArtistURI(artistName);
      }
    case URI.Type.IMAGE:
      return URI.imageURI(_getIdComponent());
    case URI.Type.MOSAIC:
      return URI.mosaicURI(components.slice(_current));
    case URI.Type.RADIO:
      return URI.radioURI(_getRemainingString());
    case URI.Type.SPECIAL:
      var args = _getRemainingComponents();
      for (i = 0, len = args.length; i < len; ++i)
        args[i] = _decodeComponent(args[i], format);
      return URI.specialURI(args);
    case URI.Type.STATION:
      return URI.stationURI(_getRemainingComponents());
    case URI.Type.EPISODE:
      return URI.episodeURI(_getIdComponent());
    default:
      if (part === URI.Type.APP) {
        id = _getNextComponent();
      } else {
        id = part;
      }
      var args = _getRemainingComponents();
      for (i = 0, len = args.length; i < len; ++i)
        args[i] = _decodeComponent(args[i], format);
      return URI.applicationURI(id, args);
  }

  throw ERROR_INVALID;
};

/**
 * A class holding information about a uri.
 *
 * @constructor
 * @param {URI.Type} type The uri type.
 * @param {Object} props The uri properties.
 */
function URI(type, props) {
  /**
   * The uri type.
   *
   * @type {string}
   */
  this.type = type;

  // Merge properties into URI object.
  for (var prop in props) {
    if (typeof props[prop] == 'function') {
      continue;
    }
    this[prop] = props[prop];
  }
}

// Lazy convert the id to hexadecimal only when requested
Object.defineProperty(URI.prototype, 'id', {
  get: function() {
    if (!this._hexId) {
      this._hexId = this._base62Id ? URI.idToHex(this._base62Id) : undefined;
    }
    return this._hexId;
  },
  set: function(id) {
    this._base62Id = id ? URI.hexToId(id) : undefined;
    this._hexId = undefined;
  },
  enumerable: true,
  configurable: true
});

/**
 * Creates an application URI object from the current URI object.
 *
 * If the current URI object is already an application type, a copy is made.
 *
 * @return {URI} The current URI as an application URI.
 */
URI.prototype.toAppType = function() {
  if (this.type == URI.Type.APPLICATION) {
    return URI.applicationURI(this.id, this.args);
  } else {
    var components = _getComponents(this, Format.URL);
    var id = components.shift();
    var len = components.length;
    if (len) {
      while (len--) {
        components[len] = _decodeComponent(components[len], Format.URL);
      }
    }
    if (this.type == URI.Type.RADIO) {
      components = components.shift().split(':');
    }
    var result = URI.applicationURI(id, components);
    return result;
  }
};

/**
 * Creates a URI object from an application URI object.
 *
 * If the current URI object is not an application type, a copy is made.
 *
 * @return {URI} The current URI as a real typed URI.
 */
URI.prototype.toRealType = function() {
  if (this.type == URI.Type.APPLICATION) {
    return _parseFromComponents([this.id].concat(this.args), Format.URI);
  } else {
    return new URI(null, this);
  }
};

/**
 * Returns the URI representation of this URI.
 *
 * @return {String} The URI representation of this uri.
 */
URI.prototype.toURI = function() {
  return URI_PREFIX + _getComponents(this, Format.URI).join(':');
};

/**
 * Returns the String representation of this URI.
 *
 * @return {String} The URI representation of this uri.
 * @see {URI#toURI}
 */
URI.prototype.toString = function() {
  return this.toURI();
};

/**
 * Get the URL path of this uri.
 *
 * @param {boolean} opt_leadingSlash True if a leading slash should be prepended.
 * @return {String} The path of this uri.
 */
URI.prototype.toURLPath = function(opt_leadingSlash) {
  var components = _getComponents(this, Format.URL);
  if (components[0] === URI.Type.APP) {
    components.shift();
  }

  // Some URIs are allowed to have empty components. It should be investigated
  // whether we need to strip empty components at all from any URIs. For now,
  // we check specifically for tracksets and local tracks and strip empty
  // components for all other URIs.
  //
  // For tracksets, it's permissible to have a path that looks like
  // 'trackset//trackURI' because the identifier parameter for a trackset can
  // be blank. For local tracks, some metadata can be missing, like missing
  // album name would be 'spotify:local:artist::track:duration'.
  var isTrackset = components[0] === URI.Type.TRACKSET;
  var isLocalTrack = components[0] === URI.Type.LOCAL;
  var shouldStripEmptyComponents = !isTrackset && !isLocalTrack;

  if (shouldStripEmptyComponents) {
    var _temp = [];
    for (var i = 0, l = components.length; i < l; i++) {
      var component = components[i];
      if (!!component) {
        _temp.push(component);
      }
    }
    components = _temp;
  }
  var path = components.join('/');
  return opt_leadingSlash ? '/' + path : path;
};

/**
 * Returns the Play URL string for the uri.
 *
 * @return {string} The Play URL string for the uri.
 */
URI.prototype.toPlayURL = function() {
    return PLAY_HTTPS_PREFIX + this.toURLPath();
};

/**
 * Returns the URL string for the uri.
 *
 * @return {string} The URL string for the uri.
 * @see {URL#toPlayURL}
 */
URI.prototype.toURL = function() {
  return this.toPlayURL();
};

/**
 * Returns the Open URL string for the uri.
 *
 * @return {string} The Open URL string for the uri.
 */
URI.prototype.toOpenURL = function() {
  return OPEN_HTTPS_PREFIX + this.toURLPath();
};

/**
 * Returns the Play HTTPS URL string for the uri.
 *
 * @return {string} The Play HTTPS URL string for the uri.
 */
URI.prototype.toSecurePlayURL = function() {
    return this.toPlayURL();
};

/**
 * Returns the HTTPS URL string for the uri.
 *
 * @return {string} The HTTPS URL string for the uri.
 * @see {URL#toSecurePlayURL}
 */
URI.prototype.toSecureURL = function() {
  return this.toPlayURL();
};

/**
 * Returns the Open HTTPS URL string for the uri.
 *
 * @return {string} The Open HTTPS URL string for the uri.
 */
URI.prototype.toSecureOpenURL = function() {
  return this.toOpenURL();
};

/**
 * Returns the id of the uri as a bytestring.
 *
 * @return {Array} The id of the uri as a bytestring.
 */
URI.prototype.idToByteString = function() {
  var data = Base62.toBytes(this._base62Id);
  data = data.map(function(i) {
    return String.fromCharCode(i);
  }).join('');
  while (data.length < 16) {
    data = String.fromCharCode(0) + data;
  }
  return data;
};

/**
 * The various URI Types.
 *
 * Note that some of the types in this enum are not real URI types, but are
 * actually URI particles. They are marked so.
 *
 * @enum {string}
 */
URI.Type = {
  EMPTY: 'empty',
  ALBUM: 'album',
  AD: 'ad',
  /** URI particle; not an actual URI. */
  APP: 'app',
  APPLICATION: 'application',
  ARTIST: 'artist',
  ARTIST_TOPLIST: 'artist-toplist',
  AUDIO_FILE: 'audiofile',
  COLLECTION: 'collection',
  COLLECTION_ALBUM: 'collection-album',
  COLLECTION_MISSING_ALBUM: 'collection-missing-album',
  COLLECTION_ARTIST: 'collection-artist',
  CONTEXT_GROUP: 'context-group',
  EPISODE: 'episode',
  /** URI particle; not an actual URI. */
  FACEBOOK: 'facebook',
  FOLDER: 'folder',
  FOLLOWERS: 'followers',
  FOLLOWING: 'following',
  /** URI particle; not an actual URI. */
  GLOBAL: 'global',
  IMAGE: 'image',
  INBOX: 'inbox',
  LOCAL_ARTIST: 'local-artist',
  LOCAL_ALBUM: 'local-album',
  LOCAL: 'local',
  LIBRARY: 'library',
  MOSAIC: 'mosaic',
  PLAYLIST: 'playlist',
  PROFILE: 'profile',
  PUBLISHED_ROOTLIST: 'published-rootlist',
  RADIO: 'radio',
  ROOTLIST: 'rootlist',
  COLLECTION_TRACK_LIST: 'collectiontracklist',
  SEARCH: 'search',
  SPECIAL: 'special',
  STARRED: 'starred',
  STATION: 'station',
  TEMP_PLAYLIST: 'temp-playlist',
  /** URI particle; not an actual URI. */
  TOP: 'top',
  TOPLIST: 'toplist',
  TRACK: 'track',
  TRACKSET: 'trackset',
  /** URI particle; not an actual URI. */
  USER: 'user',
  USER_TOPLIST: 'user-toplist',
  USER_TOP_TRACKS: 'user-top-tracks',
  /** Deprecated contant. Please use USER_TOP_TRACKS. */
  USET_TOP_TRACKS: 'user-top-tracks'
};

/**
 * Creates a new URI object from a parsed string argument.
 *
 * @param {string} str The string that will be parsed into a URI object.
 * @throws TypeError If the string argument is not a valid URI, a TypeError will
 *     be thrown.
 * @return {URI} The parsed URI object.
 */
URI.fromString = function(str) {
  var splitted = _splitIntoComponents(str);
  return _parseFromComponents(splitted.components, splitted.format);
};

/**
 * Parses a given object into a URI instance.
 *
 * Unlike URI.fromString, this function could receive any kind of value. If
 * the value is already a URI instance, it is simply returned.
 * Otherwise the value will be stringified before parsing.
 *
 * This function also does not throw an error like URI.fromString, but
 * instead simply returns null if it can't parse the value.
 *
 * @param {*} value The value to parse.
 * @return {URI?} The corresponding URI instance, or null if the
 *     passed value is not a valid value.
 */
URI.from = function(value) {
  try {
    if (value instanceof URI) {
      return value;
    }
    if (typeof value == 'object' && value.type) {
      return new URI(null, value);
    }
    return URI.fromString(value.toString());
  } catch(e) {
    return null;
  }
};

/**
 * Creates a new URI from a bytestring.
 *
 * @param {URI.Type} type The type of the URI.
 * @param {ByteString} idByteString The ID of the URI as a bytestring.
 * @param {Object} opt_args Optional arguments to the URI constructor.
 * @return {URI} The URI object created.
 */
URI.fromByteString = function(type, idByteString, opt_args) {
  var bytes = [];
  for (var i = 0; i < idByteString.length; i++) {
    bytes.push(idByteString.charCodeAt(i));
  }
  var id = Base62.fromBytes(bytes, 22);
  var args = opt_args || {};
  args.id = id;
  return new URI(type, args);
};

/**
 * Clones a given SpotifyURI instance.
 *
 * @param {URI} uri The uri to clone.
 * @return {URI?} An instance of URI.
 */
URI.clone = function(uri) {
  if (!(uri instanceof URI)) {
    return null;
  }
  return new URI(null, uri);
};

/**
 * @deprecated
 */
URI.getCanonical = function(username) {
  return this.getCanonical(username);
};

/**
 * Returns the canonical representation of a username.
 *
 * @param {string} username The username to encode.
 * @return {string} The encoded canonical representation of the username.
 */
URI.getCanonicalUsername = function(username) {
  return _encodeComponent(username, Format.URI);
};

/**
 * Returns the non-canonical representation of a username.
 *
 * @param {string} username The username to encode.
 * @return {string} The unencoded canonical representation of the username.
 */
URI.getDisplayUsername = function(username) {
  return _decodeComponent(username, Format.URI);
};

/**
 * Returns the hex representation of a Base62 encoded id.
 *
 * @param {string} id The base62 encoded id.
 * @return {string} The hex representation of the base62 id.
 */
URI.idToHex = function(id) {
  if (id.length == 22) {
    return Base62.toHex(id, 32);
  }
  return id;
};

/**
 * Returns the base62 representation of a hex encoded id.
 *
 * @param {string} hex The hex encoded id.
 * @return {string} The base62 representation of the id.
 */
URI.hexToId = function(hex) {
  if (hex.length == 32) {
    return Base62.fromHex(hex, 22);
  }
  return hex;
};

/**
 * Creates a new empty URI.
 *
 * @return {URI} The empty URI.
 */
URI.emptyURI = function() {
  return new URI(URI.Type.EMPTY, {});
};

/**
 * Creates a new 'album' type URI.
 *
 * @param {string} id The id of the album.
 * @param {number} disc The disc number of the album.
 * @return {URI} The album URI.
 */
URI.albumURI = function(id, disc) {
  return new URI(URI.Type.ALBUM, {id: id, disc: disc});
};

/**
 * Creates a new 'ad' type URI.
 *
 * @param {string} id The id of the ad.
 * @return {URI} The ad URI.
 */
URI.adURI = function(id) {
  return new URI(URI.Type.AD, {id: id});
};

/**
 * Creates a new 'audiofile' type URI.
 *
 * @param {string} extension The extension of the audiofile.
 * @param {string} id The id of the extension.
 * @return {URI} The audiofile URI.
 */
URI.audioFileURI = function(extension, id) {
  return new URI(URI.Type.AUDIO_FILE, {id: id, extension: extension});
};

/**
 * Creates a new 'artist' type URI.
 *
 * @param {string} id The id of the artist.
 * @return {URI} The artist URI.
 */
URI.artistURI = function(id) {
  return new URI(URI.Type.ARTIST, {id: id});
};

/**
 * Creates a new 'artist-toplist' type URI.
 *
 * @param {string} id The id of the artist.
 * @param {string} toplist The toplist type.
 * @return {URI} The artist-toplist URI.
 */
URI.artistToplistURI = function(id, toplist) {
  return new URI(URI.Type.ARTIST_TOPLIST, {id: id, toplist: toplist});
};

/**
 * Creates a new 'search' type URI.
 *
 * @param {string} query The unencoded search query.
 * @return {URI} The search URI
 */
URI.searchURI = function(query) {
  return new URI(URI.Type.SEARCH, {query: query});
};

/**
 * Creates a new 'track' type URI.
 *
 * @param {string} id The id of the track.
 * @param {string} anchor The point in the track formatted as mm:ss
 * @return {URI} The track URI.
 */
URI.trackURI = function(id, anchor) {
  return new URI(URI.Type.TRACK, {id: id, anchor: anchor});
};

/**
 * Creates a new 'trackset' type URI.
 *
 * @param {Array.<URI>} tracks An array of 'track' type URIs.
 * @param {string} name The name of the trackset.
 * @param {number} index The index in the trackset.
 * @return {URI} The trackset URI.
 */
URI.tracksetURI = function(tracks, name, index) {
  return new URI(URI.Type.TRACKSET, {
    tracks: tracks,
    name: name || '',
    index: isNaN(index) ? null : index
  });
};

/**
 * Creates a new 'facebook' type URI.
 *
 * @param {string} uid The user id.
 * @return {URI} The facebook URI.
 */
URI.facebookURI = function(uid) {
  return new URI(URI.Type.FACEBOOK, {uid: uid});
};

/**
 * Creates a new 'followers' type URI.
 *
 * @param {string} username The non-canonical username.
 * @return {URI} The followers URI.
 */
URI.followersURI = function(username) {
  return new URI(URI.Type.FOLLOWERS, {username: username});
};

/**
 * Creates a new 'following' type URI.
 *
 * @param {string} username The non-canonical username.
 * @return {URI} The following URI.
 */
URI.followingURI = function(username) {
  return new URI(URI.Type.FOLLOWING, {username: username});
};

/**
 * Creates a new 'playlist' type URI.
 *
 * @param {string} username The non-canonical username of the playlist owner.
 * @param {string} id The id of the playlist.
 * @return {URI} The playlist URI.
 */
URI.playlistURI = function(username, id) {
  return new URI(URI.Type.PLAYLIST, {username: username, id: id});
};

/**
 * Creates a new 'folder' type URI.
 *
 * @param {string} username The non-canonical username of the folder owner.
 * @param {string} id The id of the folder.
 * @return {URI} The folder URI.
 */
URI.folderURI = function(username, id) {
  return new URI(URI.Type.FOLDER, {username: username, id: id});
};

/**
 * Creates a new 'collectiontracklist' type URI.
 *
 * @param {string} username The non-canonical username of the collection owner.
 * @param {string} id The id of the tracklist.
 * @return {URI} The collectiontracklist URI.
 */
URI.collectionTrackList = function(username, id) {
  return new URI(URI.Type.COLLECTION_TRACK_LIST, {username: username, id: id});
};

/**
 * Creates a new 'starred' type URI.
 *
 * @param {string} username The non-canonical username of the starred list owner.
 * @return {URI} The starred URI.
 */
URI.starredURI = function(username) {
  return new URI(URI.Type.STARRED, {username: username});
};

/**
 * Creates a new 'user-toplist' type URI.
 *
 * @param {string} username The non-canonical username of the toplist owner.
 * @param {string} toplist The toplist type.
 * @return {URI} The user-toplist URI.
 */
URI.userToplistURI = function(username, toplist) {
  return new URI(URI.Type.USER_TOPLIST, {username: username, toplist: toplist});
};

/**
 * Creates a new 'user-top-tracks' type URI.
 *
 * @deprecated
 * @param {string} username The non-canonical username of the toplist owner.
 * @return {URI} The user-top-tracks URI.
 */
URI.userTopTracksURI = function(username) {
  return new URI(URI.Type.USER_TOP_TRACKS, {username: username});
};

/**
 * Creates a new 'toplist' type URI.
 *
 * @param {string} toplist The toplist type.
 * @param {string} country The country code for the toplist.
 * @param {boolean} global True if this is a global rather than a country list.
 * @return {URI} The toplist URI.
 */
URI.toplistURI = function(toplist, country, global) {
  return new URI(URI.Type.TOPLIST, {toplist: toplist, country: country, global: !!global});
};

/**
 * Creates a new 'inbox' type URI.
 *
 * @param {string} username The non-canonical username of the inbox owner.
 * @return {URI} The inbox URI.
 */
URI.inboxURI = function(username) {
  return new URI(URI.Type.INBOX, {username: username});
};

/**
 * Creates a new 'rootlist' type URI.
 *
 * @param {string} username The non-canonical username of the rootlist owner.
 * @return {URI} The rootlist URI.
 */
URI.rootlistURI = function(username) {
  return new URI(URI.Type.ROOTLIST, {username: username});
};

/**
 * Creates a new 'published-rootlist' type URI.
 *
 * @param {string} username The non-canonical username of the published-rootlist owner.
 * @return {URI} The published-rootlist URI.
 */
URI.publishedRootlistURI = function(username) {
  return new URI(URI.Type.PUBLISHED_ROOTLIST, {username: username});
};

/**
 * Creates a new 'local-artist' type URI.
 *
 * @param {string} artist The artist name.
 * @return {URI} The local-artist URI.
 */
URI.localArtistURI = function(artist) {
  return new URI(URI.Type.LOCAL_ARTIST, {artist: artist});
};

/**
 * Creates a new 'local-album' type URI.
 *
 * @param {string} artist The artist name.
 * @param {string} album The album name.
 * @return {URI} The local-album URI.
 */
URI.localAlbumURI = function(artist, album) {
  return new URI(URI.Type.LOCAL_ALBUM, {artist: artist, album: album});
};

/**
 * Creates a new 'local' type URI.
 *
 * @param {string} artist The artist name.
 * @param {string} album The album name.
 * @param {string} track The track name.
 * @param {number} duration The track duration in ms.
 * @return {URI} The local URI.
 */
URI.localURI = function(artist, album, track, duration) {
  return new URI(URI.Type.LOCAL, {
    artist: artist,
    album: album,
    track: track,
    duration: duration
  });
};

/**
 * Creates a new 'library' type URI.
 *
 * @param {string} username The non-canonical username of the rootlist owner.
 * @param {string} category The category of the library.
 * @return {URI} The library URI.
 */
URI.libraryURI = function(username, category) {
  return new URI(URI.Type.LIBRARY, {username: username, category: category});
};

/**
 * Creates a new 'collection' type URI.
 *
 * @param {string} username The non-canonical username of the rootlist owner.
 * @param {string} category The category of the collection.
 * @return {URI} The collection URI.
 */
URI.collectionURI = function(username, category) {
  return new URI(URI.Type.COLLECTION, {username: username, category: category});
};

/**
 * Creates a new 'temp-playlist' type URI.
 *
 * @param {string} origin The origin of the temporary playlist.
 * @param {string} data Additional data for the playlist.
 * @return {URI} The temp-playlist URI.
 */
URI.temporaryPlaylistURI = function(origin, data) {
  return new URI(URI.Type.TEMP_PLAYLIST, {origin: origin, data: data});
};

/**
 * Creates a new 'context-group' type URI.
 *
 * @deprecated
 * @param {string} origin The origin of the temporary playlist.
 * @param {string} name The name of the context group.
 * @return {URI} The context-group URI.
 */
URI.contextGroupURI = function(origin, name) {
  return new URI(URI.Type.CONTEXT_GROUP, {origin: origin, name: name});
};

/**
 * Creates a new 'profile' type URI.
 *
 * @param {string} username The non-canonical username of the rootlist owner.
 * @param {Array.<string>} args A list of arguments.
 * @return {URI} The profile URI.
 */
URI.profileURI = function(username, args) {
  return new URI(URI.Type.PROFILE, {username: username, args: args});
};

/**
 * Creates a new 'image' type URI.
 *
 * @param {string} id The id of the image.
 * @return {URI} The image URI.
 */
URI.imageURI = function(id) {
  return new URI(URI.Type.IMAGE, {id: id});
};

/**
 * Creates a new 'mosaic' type URI.
 *
 * @param {Array.<string>} ids The ids of the mosaic immages.
 * @return {URI} The mosaic URI.
 */
URI.mosaicURI = function(ids) {
  return new URI(URI.Type.MOSAIC, {ids: ids});
};

/**
 * Creates a new 'radio' type URI.
 *
 * @param {string} args The radio seed arguments.
 * @return {URI} The radio URI.
 */
URI.radioURI = function(args) {
  args = typeof args === 'undefined' ? '' : args;
  return new URI(URI.Type.RADIO, {args: args});
};

/**
 * Creates a new 'special' type URI.
 *
 * @param {Array.<string>} args An array containing the other arguments.
 * @return {URI} The special URI.
 */
URI.specialURI = function(args) {
  args = typeof args === 'undefined' ? [] : args;
  return new URI(URI.Type.SPECIAL, {args: args});
};

/**
 * Creates a new 'station' type URI.
 *
 * @param {Array.<string>} args An array of arguments for the station.
 * @return {URI} The station URI.
 */
URI.stationURI = function(args) {
  args = typeof args === 'undefined' ? [] : args;
  return new URI(URI.Type.STATION, {args: args});
};

/**
 * Creates a new 'application' type URI.
 *
 * @param {string} id The id of the application.
 * @param {Array.<string>} args An array containing the arguments to the app.
 * @return {URI} The application URI.
 */
URI.applicationURI = function(id, args) {
  args = typeof args === 'undefined' ? [] : args;
  return new URI(URI.Type.APPLICATION, {id: id, args: args});
};

/**
 * Creates a new 'collection-album' type URI.
 *
 * @param {string} username The non-canonical username of the rootlist owner.
 * @param {string} id The id of the album.
 * @return {URI} The collection-album URI.
 */
URI.collectionAlbumURI = function(username, id) {
  return new URI(URI.Type.COLLECTION_ALBUM, {username: username, id: id});
};

/**
 * Creates a new 'collection-album-missing' type URI.
 *
 * @param {string} username The non-canonical username of the rootlist owner.
 * @param {string} id The id of the album.
 * @return {URI} The collection-album-missing URI.
 */
URI.collectionMissingAlbumURI = function(username, id) {
  return new URI(URI.Type.COLLECTION_MISSING_ALBUM, {username: username, id: id});
};

/**
 * Creates a new 'collection-artist' type URI.
 *
 * @param {string} username The non-canonical username of the rootlist owner.
 * @param {string} id The id of the artist.
 * @return {URI} The collection-artist URI.
 */
URI.collectionArtistURI = function(username, id) {
  return new URI(URI.Type.COLLECTION_ARTIST, {username: username, id: id});
};

/**
 * Creates a new 'episode' type URI.
 *
 * @param {string} id The id of the episode.
 * @return {URI} The episode URI.
 */
URI.episodeURI = function(id) {
  return new URI(URI.Type.EPISODE, {id: id});
};

/**
 * Export public interface
 */
module.exports = URI;

},{"spotify-crypto/src/base62":698}],708:[function(require,module,exports){
'use strict';

var Range = require('spotify-range2');

/**
 * Get the needed operations for inserting items at a specific index.
 *
 * @param {Array} items Array of items to insert.
 * @param {number} index Index to insert the items at, relative to the list
 *     before the operations.
 *
 * @return {Array.<Object>} Array of operation objects.
 */
function getInsertOperations(items, index) {
  return [{type: 'insert', index: index, values: items}];
}

/**
 * Get the needed operations for removing items from the specified indices.
 *
 * @param {Array.<number>} indices Array of indices relative to the list before
 *     the operations.
 *
 * @return {Array.<Object>} Array of operation objects.
 */
function getRemoveOperations(indices) {
  var ranges = Range.fromIndices(indices);

  var removed = 0;
  var operations = [];

  for (var r = 0, range; (range = ranges[r]); r++) {
    operations.push({type: 'remove', index: range.start - removed, length: range.length});
    removed += range.length;
  }

  return operations;
}

/**
 * Get the needed operations for moving items from a set of indices to a
 * target index.
 *
 * @param {Array.<number>} fromIndices Array of indices relative to the list
 *     before the operations.
 * @param {number} toIndex Index to move the items to, relative to the list
 *     before the operations.
 *
 * @return {Array.<Object>} Array of operation objects.
 */
function getMoveOperations(fromIndices, toIndex) {

  // We're going through one range at a time, and when a range is moved down,
  // we need to decrease the start of the next range to account for the
  // range we moved down (since each operation is based on the result of
  // the previous operation).
  var movedAbove = 0;

  // The maximum index starts at the index we want to move to.
  // When operations are created to move ranges, this maximum index
  // is increased to always point to the bottom index of the moved
  // items. If five items are moved from far down up to the 'to' index,
  // the new maxIndex will be toIndex + 5.
  var maxIndex = toIndex;

  var ranges = Range.fromIndices(fromIndices);
  var r, range;
  var toRange;

  // Find any range that intersects with the 'to' index. Referred below as
  // the 'to' range. This range can't be split, so we need to move items to
  // positions above or below this range if it exists.
  for (r = 0; (range = ranges[r]); r++) {
    if (range.start <= toIndex && range.end >= toIndex) {
      toRange = range;
      break;
    }
  }

  var operations = [];

  for (r = 0; (range = ranges[r]); r++) {
    var length = range.length;
    var to;
    var from = range.start - movedAbove;

    // If the 'to' index is inside a range
    if (toRange) {

      // Range is above the 'to' range, so move it to right above that range.
      if (range.end < toRange.start) {
        from = range.start - movedAbove;
        to = toRange.start - length;
        movedAbove += length;

      // Range is the 'to' range, which means it will not move anywhere.
      } else if (range === toRange) {
        maxIndex = Math.max(maxIndex, range.end);
        continue;

      // Range is below the 'to' range, so move it to the maximum index
      // we've reached so far.
      } else {
        from = range.start;
        to = maxIndex;
        maxIndex = Math.max(maxIndex, to + length);
      }

    // If the 'to' index is not inside a range
    } else {

      // Range is above the 'to' index, so move it to right above the maximum index.
      if (range.end < toIndex) {
        from = range.start - movedAbove;
        to = maxIndex - length;
        movedAbove += length;

      // Range is below the 'to' index, so move it to the maximum index we've
      // reached so far.
      } else {
        from = range.start;
        to = maxIndex;
        maxIndex = Math.max(maxIndex, to + length);
      }
    }

    operations.push({type: 'move', from: from, length: length, to: to});
  }

  return operations;
}

exports.getInsertOperations = getInsertOperations;
exports.getRemoveOperations = getRemoveOperations;
exports.getMoveOperations = getMoveOperations;

},{"spotify-range2":718}],709:[function(require,module,exports){
'use strict';

module.exports = function(log) {
  return {
    // feature album
    album: log('album'),

    // feature artist
    artist: log('artist'),
    artistAlbums: log('artist/albums'),
    artistBio: log('artist/bio'),
    artistGallery: log('artist/gallery'),
    artistPlaylists: log('artist/playlists'),
    artistRelated: log('artist/related'),

    // feature browse
    browse: log('browse'),

    // feature charts
    charts: log('charts'),
    chartsChart: log('charts/chart'),
    chartsRegional: log('charts/regional'),
    chartsSocial: log('charts/social'),
    chartsViral: log('charts/viral'),

    // feature collection
    collection: log('collection'),
    collectionAlbums: log('collection/albums'),
    collectionAlbumsAlbum: log('collection/albums/album'),
    collectionArtists: log('collection/artists'),
    collectionArtistsArtist: log('collection/artists/artist'),
    collectionPlaylists: log('collection/playlists'),
    collectionRadio: log('collection/radio'),
    collectionShows: log('collection/shows'),
    collectionSongs: log('collection/songs'),

    // feature concerts
    concerts: log('concerts'),
    concertsCitysearch: log('concerts/citysearch'),
    concertsConcert: log('concerts/concert'),

    // feature inbox
    inbox: log('inbox'),

    // feature moments
    moments: log('moments'),
    momentsCategory: log('moments/category'),

    // feature music
    music: log('music'),
    musicCategory: log('music/category'),

    // feature now
    now: log('now'),

    // feature nowplaying
    nowplaying: log('nowplaying'),
    nowplayingDevicepicker: log('nowplaying/devicepicker'),
    nowplayingQueue: log('nowplaying/queue'),

    // feature party
    party: log('party'),
    partyAddFriends: log('party/add-friends'),
    partyEnableBluetooth: log('party/enable-bluetooth'),
    partyEnableNearby: log('party/enable-nearby'),
    partyPreset: log('party/preset'),
    partyQueue: log('party/queue'),

    // feature playlist
    playlist: log('playlist'),

    // feature profile
    profile: log('profile'),
    profileActivity: log('profile/activity'),
    profileArtists: log('profile/artists'),
    profileFollowers: log('profile/followers'),
    profileFollowing: log('profile/following'),
    profilePlaylists: log('profile/playlists'),

    // feature radio
    radio: log('radio'),
    radioStation: log('radio/station'),

    // feature running
    running: log('running'),
    runningCategory: log('running/category'),
    runningSetup: log('running/setup'),

    // feature search
    search: log('search'),
    searchAlbums: log('search/albums'),
    searchArtists: log('search/artists'),
    searchGenres: log('search/genres'),
    searchPlaylists: log('search/playlists'),
    searchProfiles: log('search/profiles'),
    searchRadio: log('search/radio'),
    searchShows: log('search/shows'),
    searchSongs: log('search/songs'),
    searchVideos: log('search/videos'),

    // feature shows
    shows: log('shows'),
    showsAudio: log('shows/audio'),
    showsCategory: log('shows/category'),
    showsNetwork: log('shows/network'),
    showsVideo: log('shows/video'),

    // to be reported if the page is unknown to the container
    unknown: log('unknown')
  };
};

},{}],710:[function(require,module,exports){
var v1 = require('./v1');
var v2 = require('./v2');

exports.v1 = v1;
exports.v2 = v2;

/**
 * Export the current version of the player API
 */
for (var key in v2) {
  exports[key] = v2[key];
}

},{"./v1":711,"./v2":714}],711:[function(require,module,exports){
exports.Player = require('./player').Player;
exports.PlayerState = require('./state').PlayerState;

},{"./player":712,"./state":713}],712:[function(require,module,exports){
var cosmos = require('spotify-cosmos-api');
var PlayerState = require('./state').PlayerState;
var Request = cosmos.Request;
var Response = cosmos.Response;
var Action = cosmos.Action;

var PLAYER_URI_PREFIX = 'sp://player/v1/';
var DEFAULT_PLAYER_ID = 'main';
var TRACK_RESOLVER_URI = 'hm://track-resolver/v1?uri=';

/**
 * Player is the main entry point to control music playback with cosmos.
 *
 * There can be more than one Player object at the same time, and they
 * will sync up as one would expect.
 *
 * In practice there will be usually one Player object per app that
 * wants to control playback.
 *
 * Example:
 * var cosmos = require('cosmos');
 * var player = new cosmos.Player(cosmos.resolver, 'spotify:app:discover', '0.7.1', 'com.spotify', 'main');
 *
 * var playerState = new cosmos.PlayerState();
 * playerState.action = 'play';
 * playerState.tracks = [spotify:track:0bXpmJyHHYPk6QBFj25bYF];
 * playerState.reason = 'playbtn';
 * player.play(playerState);
 */
function Player(resolver, referrer, referrer_version, referrer_vendor, opt_options) {
  if (!resolver || !referrer || !referrer_version || !referrer_vendor) {
    throw new TypeError('Missing parameters for Player');
  }

  /**
   * The resolver used to send requests.
   * @type {Cosmos.Resolver{}
   */
  this._resolver = resolver;

  /**
   * Player id. Can be 'main' or 'context'.
   * @type {string}
   */
  this._id = opt_options && opt_options.playerId || DEFAULT_PLAYER_ID;

  /**
   * The referrer/owner of the player requests.
   * This is used to provide reference to the app
   * that owns the playback and needs to be a full
   * uri of the app or the url of the external resource.
   *
   * Examples:
   * 'spotify:app:artist:4wo1267SJuUfHgasdlfNfc'
   * 'spotify:app:user'
   * 'spotify:app:collection:songs'
   *
   * @type {string}
   */
  this._referrer = referrer;

  /**
   * The version referrer/owner of the player requests.
   * As it is used for logging purposes it should be
   * the version of the app e.g. '0.7.5'
   * @type {string}
   */
  this._referrer_version = referrer_version;

  /**
   * The referrer/owner of the player requests.
   * It is used for logging purposes and in most
   * cases it will be 'com.spotify'
   * @type {string}
   */
  this._referrer_vendor = referrer_vendor;

  this._addReferrerInfo = this._addReferrerInfo.bind(this);
}

/**
 * Convenience method that takes any spotify URI, like track playlist,
 * artist or album and creates a PlayerState object that, when played,
 * will start playing that entity.
 *
 * The caller of this method is free to tweak the player state (for instance
 * set whether the user should be able to skip) and then pass it to
 * player's `play` method. The `reason` and the `source` properties on state's
 * `play_origin` property must be set prior to invoking `play`.
 *
 * @param {string} uri Spotify uri to play, for instance spotify:track:4JJ5zGKnb1IpERyBrfmb1y.
 *
 * @return {Cosmos.PlayerState} player state.
 */
Player.stateFromUri = function(uri) {
  var playerState = new PlayerState();
  playerState.tracks = [];
  playerState.context = uri;

  if (/^spotify:user:[^:]+:(playlist:|starred)/.test(uri)) {
    playerState.next_page_url = uri;
  } else {
    playerState.next_page_url = TRACK_RESOLVER_URI + encodeURI(uri);
  }

  return playerState;
};

/**
 * Play the context described by PlayerState object.
 * @see Cosmos#PlayerState for details.
 *
 * @param {Cosmos.PlayerState} playerState Describes context to play.
 * @param {function(Error, Response)=} opt_callback
 * The function to execute after command was resolved.
 */
Player.prototype.play = function(playerState, opt_callback) {

  if (!(playerState instanceof PlayerState)) {
    throw new TypeError('Invalid `playerState` argument');
  }

  playerState.action = PlayerState.ACTIONS.PLAY;
  return this._sendRequest(playerState, opt_callback);
};

/**
 * Update the context to the one described by PlayerState object.
 * @see Cosmos#PlayerState for details.
 * The method is almost the same as the `play` one but it will
 * not interrupt the playback. The currently playing track will finish
 * and after that the ones from new context will play.
 *
 * @param {Cosmos.PlayerState} playerState Describes context to play.
 * @param {function(Error, Response)=} opt_callback
 * The function to execute after command was resolved.
 */
Player.prototype.update = function(playerState, opt_callback) {

  if (!(playerState instanceof PlayerState)) {
    throw new TypeError('Invalid `playerState` argument');
  }

  playerState.action = PlayerState.ACTIONS.UPDATE;
  return this._sendRequest(playerState, opt_callback);
};

/**
 * Stop the current context.
 * @param {function(Error, Response)=} opt_callback
 * The function to execute after command was resolved.
 */
Player.prototype.stop = function(opt_callback) {
  var playerState = new PlayerState();
  playerState.action = PlayerState.ACTIONS.STOP;
  return this._sendRequest(playerState, opt_callback);
};

/**
 * Resume current context.
 * @param {function(Error, Response)=} opt_callback
 * The function to execute after command was resolved.
 */
Player.prototype.resume = function(opt_callback) {
  var playerState = new PlayerState();
  playerState.action = PlayerState.ACTIONS.RESUME;
  return this._sendRequest(playerState, opt_callback);
};

/**
 * Pause current context.
 * @param {function(Error, Response)=} opt_callback
 * The function to execute after command was resolved.
 */
Player.prototype.pause = function(opt_callback) {
  var playerState = new PlayerState();
  playerState.action = PlayerState.ACTIONS.PAUSE;
  return this._sendRequest(playerState, opt_callback);
};

/**
 * Skip to the next song in the current context.
 * @param {function(Error, Response)=} opt_callback
 * The function to execute after command was resolved.
 */
Player.prototype.skipPrev = function(opt_callback) {
  var playerState = new PlayerState();
  playerState.action = PlayerState.ACTIONS.SKIP_PREV;
  return this._sendRequest(playerState, opt_callback);
};

/**
 * Skip to the pevious song in the current context.
 * @param {function(Error, Response)=} opt_callback
 * The function to execute after command was resolved.
 */
Player.prototype.skipNext = function(opt_callback) {
  var playerState = new PlayerState();
  playerState.action = PlayerState.ACTIONS.SKIP_NEXT;
  return this._sendRequest(playerState, opt_callback);
};

/**
 * @private
 * Send the request to the resolver.
 * @param {PlayerState} playerState The object describing
 * the context to act on.
 * @param {function(Error, Response)=} opt_callback
 * The function to execute after command was resolved.
 */
Player.prototype._sendRequest = function(playerState, opt_callback) {
  this._addReferrerInfo(playerState);
  var request = new Request(Action.POST, PLAYER_URI_PREFIX + this._id, null, playerState.serialize());
  return this._resolver.resolve(request, opt_callback);
};

/**
 * @private
 * Add referrer information.
 * Player should always send this info as its used
 * for logging. The properties are set in a constructor
 * and added automatically to every request sent from the player.
 * @param {PlayerState} playerState The object describing
 * current playerState.
 */
Player.prototype._addReferrerInfo = function(playerState) {
  playerState.play_origin.referrer = this._referrer;
  playerState.play_origin.referrer_version = this._referrer_version;
  playerState.play_origin.referrer_vendor = this._referrer_vendor;

  return playerState;
};

/**
 * @private
 * Parse the server response to the valid PlayerState.
 * Called after state is loaded from the service.
 * Tries to parse the response, convert it to a valid
 * PlayerState and later returns it. If converting
 * is not possible it just returns the original response.
 */
Player.prototype._parseState = function(body) {
  try {
    var state = JSON.parse(body);
    state = new PlayerState(state);
    return JSON.stringify(state.serialize());
  } catch (e) {
    return body;
  }
};

/**
 * Get the current player state from the service.
 * @param {function(Error|Response, Response=)} callback The function executed
 * after state is loaded.
 */
Player.prototype.getState = function(callback) {
  var self = this;
  var request = new Request(Action.GET, PLAYER_URI_PREFIX + this._id);
  return this._resolver.resolve(request, function(err, response) {

    var body = response && response.getBody();

    if (body) {
      var playerState  = self._parseState(body);
      response = new Response(
        response.getURI(),
        response.getStatusCode(),
        response.getHeaders(),
        playerState);
    }

    if (typeof callback === 'function') {
      callback(err, response);
    }
  });
};

/**
 * Updates referrer for the Player.
 * @param {string} referrer The referrer of the player requests.
 */
Player.prototype.setReferrer = function(referrer) {
  if (referrer) {
    this._referrer = referrer;
  }
};

/**
 * Subscribe to the player events
 * @param {Function} callback The function that will
 * be called every time the event occurs.
 * @return {RequestHandle} The subscription handle.
 * This object can be used to cancel the subscription.
 * by calling 'cancel()' on it.
 * Example:
 * var sub = player.subscribe(function(err, response) { });
 * sub.cancel();
 */
Player.prototype.subscribe = function(callback) {
  var request = new Request(Action.SUB, PLAYER_URI_PREFIX + this._id);
  return this._resolver.resolve(request, callback);
};

exports.Player = Player;

},{"./state":713,"spotify-cosmos-api":694}],713:[function(require,module,exports){
var inherit = require('spotify-inheritance/inherit');

/**
 * PlayerState is used for two distinct purposes: Pushing new state to the
 * player (this is done when you request to play a completely new context with
 * 'play' method) and retrieving player state updates.
 *
 * Changing properties on PlayerState objects will not change the state of
 * the player unless you pass it to the 'play' method.
 *
 * @param {Object} stateData the data for the playerState.
 */
function PlayerState(stateData) {
  Serializable.call(this, [
    'action',
    'context',
    'tracks',
    'index',
    'playing',
    'loading',
    'track',
    'position',
    'duration',
    'volume',
    'options',
    'play_origin',
    'next_page_url',
    'prev_page_url'
  ]);

  stateData = stateData || {};
  /**
   * What kind of the action player should perform.
   * It's set directly before sending the request.
   * @type {String}
   */
  this.action = stateData.action;

  /**
   * Spotify uri describing the context that
   * will be played e.g playlist, album or artist.
   * Example: spotify:artist:4XaUmUGjidSklcDHxv3XWf,
   * spotify:user:daftpunkofficial:playlist:5nrg0D90OlFyveVfrQD0zE,
   * spotify:album:2nXJkqkS1tIKIyhBcFMmwz
   *
   * @type {String}
   */
  this.context = stateData.context;

  /**
   * The list of tracks uris to play in the given context.
   * Example: [
   *    spotify:track:0bXpmJyHHYPk6QBFj25bYF,
   *    spotify:track:6DXFVsLcEvOTSrkG9G1Cb1,
   *    spotify:track:6rxEjkoar48SssZePbtb2x
   * ]
   *
   * @type {Array.<String>}
   */
  this.tracks = stateData.tracks;

  /**
   * Which element on the this.tracks list should
   * be played.
   *
   * @type {Number}
   */
  this.index = stateData.index;

  /**
   * Is the player currently playing
   */
  this.playing = stateData.playing;
  this.loading = stateData.loading;

  /**
   * Current track URI
   * @type {String}
   */
  this.track = stateData.track;


  this.position = stateData.position;

  this.volume = stateData.volume;

  /**
   * Current track duration in miliseconds?
   * @type {Number}
   */
  this.duration = stateData.duration;

  /**
   * See PlayOptions description
   * @type {cosmos-bindings-js/scripts/player_state~PlayOptions}
   */
  this.options = new PlayOptions(stateData.options);

  /**
   * See PlayOrigin description
   * @type {cosmos-bindings-js/scripts/player_state~PlayOrigin}
   */
  this.play_origin = new PlayOrigin(stateData.play_origin);

  /**
   * Before the list of tracks that are to be played ends, a request will be sent
   * to this URL, which is supposed to return a list of tracks. That list of
   * tracks will then be appended to the list of tracks in the context.
   *
   * The response payload of the next_page_url should look like this:
   *
   * {
   *   "tracks": [
   *     { "track": "spotify:track:$TRACK-ID1", "context": "spotify:album:$ALBUM-ID1" },
   *     { "track": "spotify:track:$TRACK-ID2", "context": "spotify:album:$ALBUM-ID1" },
   *     { "track": "spotify:track:$TRACK-ID3", "context": "spotify:album:$ALBUM-ID1" },
   *   ],
   *   "next_page_url": "...", // Optional
   *   "prev_page_url": "..." // Optional
   * }
   *
   * May be null, which is the same as a URL that would return an empty list
   * of tracks (but with null, no network request is made).
   */
  this.next_page_url = stateData.next_page_url;

  /**
   * Like `next_page_url`, but for going backwards in the context.
   */
  this.prev_page_url = stateData.prev_page_url;
}
inherit(PlayerState, Serializable);

/**
 * Ovverides prototype method.
 * Converts play options and origin to
 * serializable to make sure only correct data
 * is returned.
 * @return {Object} Data associated with player state.
 */
PlayerState.prototype.serialize = function() {
  if (this.options && !(this.options instanceof PlayOptions)) {
    this.options = new PlayOptions(this.options);
  }

  if (this.play_origin && !(this.play_origin instanceof PlayOrigin)) {
    this.play_origin = new PlayOrigin(this.play_origin);
  }

  return Serializable.prototype.serialize.call(this);
};

/**
 * Possible player actions.
 */
PlayerState.ACTIONS = {
  UNKNOWN: 'unknown',
  PLAY: 'play',
  UPDATE: 'update',
  STOP: 'stop',
  RESUME: 'resume',
  PAUSE: 'pause',
  SKIP_PREV: 'skip_prev',
  SKIP_NEXT: 'skip_next'
};

function PlayOrigin(data) {
  Serializable.call(this, [
    'source',
    'reason',
    'referrer',
    'referrer_version',
    'referrer_vendor'
  ]);

  data = data || {};

  /**
   * What kind of playlist did we play from?
   *
   * The default value of this property is "unknown". Must have a value.
   *
   * Valid values include 'album', 'artist', 'extlink', 'playlist', 'playqueue',
   * 'radio', 'search', 'unknown'.
   *
   * For an up to date list of valid values, see `PLAY_SOURCES` in
   * https://git.spotify.net/cgit.cgi/log-parser.git/tree/spotify/log_parser/messages_specs.py
   */
  this.source = data.source || 'unknown';

  /**
   * Why was the song started?
   *
   * The default value of this property is "unknown". Must have a value.
   *
   * A list of valid values that might be used by features:
   *
   * unknown    = Client doesn't know
   * clickrow   = A row in the song list was clicked/opened
   * playbtn    = The play button was pressed
   * urlopen    = A Url was opened
   *
   * For a complete and up to date list of valid values, see `PLAY_REASONS` in
   * https://git.spotify.net/cgit.cgi/log-parser.git/tree/spotify/log_parser/messages_specs.py
   */
  this.reason = data.reason || 'unknown';

  /**
   * Either a remote site or a spotify app which initiated the request.
   *
   * NOTE: This normally should be a readonly property and not be set
   * explicitly in the PlayerState as the Player will overwrite it when sending the request.
   */
  this.referrer = data.referrer || 'unknown';

  /**
   * The version of the referrer, where applicable. It usually makes sense to
   * set this value to the version of the JS app version, for instance "0.7.5".
   *
   * NOTE: This normally should be a readonly property and not be set
   * explicitly in the PlayerState as the Player will overwrite it when sending the request.
   */
  this.referrer_version = data.referrer_version || 'unknown';

  /**
   * The vendor of the referrer, where applicable.
   * For example com.soundrop, com.spotify.
   *
   * NOTE: This normally should be a readonly property and not be set
   * explicitly in the PlayerState as the Player will overwrite it when sending the request.
   */
  this.referrer_vendor = data.referrer_vendor || 'unknown';
}
inherit(PlayOrigin, Serializable);

/**
 * What kind of options user has
 * with the player. By default
 * all 'can_*' properties are set to true.
 * You might want to restrict some of them
 * in the special cases like ads (no skipping)
 * or radio no skipping prev.
 * @constructor
 * @param {Object} options The options data.
 */
function PlayOptions(options) {
  Serializable.call(this, [
    'repeat',
    'shuffle',
    'can_repeat',
    'can_shuffle',
    'can_skip_prev',
    'can_skip_next',
    'can_seek',
    'use_dmca_rules'
  ]);
  options = options || {};

  /**
   * True if repeat (repeat all, not single track repeat) is (or is to be) enabled.
   *
   * Default value is false
   */
  this.repeat = options.repeat !== undefined ? options.repeat : false;

  /**
   * True if shuffle is (or is to be) enabled.
   *
   * Default value is false
   */
  this.shuffle = options.shuffle !== undefined ? options.shuffle : false;

  /**
   * True if this context can be repeated. This would be false for instance in the
   * case of radio.
   *
   * Default value is true.
   */
  this.can_repeat = options.can_repeat !== undefined ? options.can_repeat : true;

  /**
   * True if this context can be shuffled. This would be false for instance in the
   * case of radio.
   *
   * Default value is true.
   */
  this.can_shuffle = options.can_shuffle !== undefined ? options.can_shuffle : true;

  /**
   * True if the user is (or should be) allowed to skip to the previous track.
   *
   * Default value is true.
   */
  this.can_skip_prev = options.can_skip_prev !== undefined ? options.can_skip_prev : true;

  /**
   * True if the user is (or should be) allowed to skip to the next track.
   *
   * Default value is true.
   */
  this.can_skip_next = options.can_skip_next !== undefined ? options.can_skip_next : true;

  /**
   * True if the user is (or should be) allowed to seek to a certain time in the
   * currently playing track.
   *
   * Default value is true.
   */
  this.can_seek = options.can_seek !== undefined ? options.can_seek : true;

  /**
   * True if the track player should automatically apply DMCA rules when playing.
   * DMCA rules should be enabled for users that have free radio in the US, and
   * controls how many tracks the user are allowed to skip etc.
   *
   * Default value is false.
   */
  this.use_dmca_rules = options.use_dmca_rules !== undefined ? options.use_dmca_rules : false;
}
inherit(PlayOptions, Serializable);

/**
 * The object accepting only defined properties.
 * To make sure only valid properties are passed
 * always use 'serialize()' when object value needed.
 * @constructor
 * @param {Array.<string>} allowedProps The list of the properties
 * that are supported for the object.
 */
function Serializable(allowedProps) {
  this._props = allowedProps || [];
}

/**
 * The JSON representation of the object.
 * @return {Object} Data associated with current player state.
 */
Serializable.prototype.serialize = function() {
  var data = {};
  var prop;

  for (var i = 0, l = this._props.length; i < l; i++) {
    prop = this._props[i];
    if (this[prop] !== undefined) {
      if (this[prop] instanceof Serializable) {
        data[prop] = this[prop].serialize();
      } else {
        data[prop] = this[prop];
      }
    }
  }

  return data;
};

exports.PlayerState = PlayerState;

},{"spotify-inheritance/inherit":706}],714:[function(require,module,exports){
var player = require("./player");
var types = require("./types");
var play = require("./play");

exports.Play = play.Play;
exports.Player = player.Player;
exports.PlayerContext = types.Context;
exports.PlayOptions = types.PlayOptions;
exports.PlayerRestrictions = types.Restrictions;
exports.PlayerSuppressions = types.Suppressions;
exports.PlayerTrack = types.Track;
exports.PlayerContextPage = types.ContextPage;
exports.IndexPath = types.IndexPath;

},{"./play":715,"./player":716,"./types":717}],715:[function(require,module,exports){
var cosmos = require('spotify-cosmos-api');
var nodefn = require('when/node');

/**
 * Play is exposed as Player.Play. It represents a prepared playback action.
 * Play objects are obtained from the preparePlay method on the Player; the
 * constructor is not a public API.
 *
 * Instantiating a Play object does not make a Cosmos request, the caller is
 * expected to make that call and pass in a promise of the result in the
 * createSessionPromise parameter.
 *
 * @param {Cosmos.resolver} resolver The resolver to send requests to.
 * @param {Promise} createSessionPromise A promise of a Cosmos.Response for
 *     the call to sp://player/v2/xyz/session.
 * @param {Player} player The player that initiated the call.
 * @param {function()=Number} getTime Clock. Should usually return
 *     new Date().getTime()
 * @param {module:spotify-player/types.Context} The context that was passed
 *     to the preparePlay call.
 * @param {Cosmos.PlayOptions=} opt_options The options that were passed to
 *     the preparePlay call.
 */
function Play(resolver, createSessionPromise, player, getTime, context, opt_options) {
  if (!(this instanceof Play)) {
    return new Play(resolver, createSessionPromise, player, getTime, context, opt_options);
  }

  if (!resolver || !createSessionPromise || !player || !getTime || !context) {
    throw new TypeError('Missing parameters for Play');
  }

  /**
   * @type {Cosmos.resolver}
   */
  this._resolver = resolver;

  /**
   * @type {Promise}
   */
  this._createSessionPromise = createSessionPromise;

  /**
   * @type {Player}
   */
  this._player = player;

  /**
   * @type {function()=Number}
   */
  this._getTime = getTime;

  /**
   * @type {module:spotify-player/types.Context}
   */
  this._context = context;

  /**
   * @type {Cosmos.PlayOptions=}
   */
  this._opt_options = opt_options;
}

/**
 * @return Promise of the session URL
 */
Play.prototype._sessionUrl = function() {
  return this._createSessionPromise.then(function(response) {
    return response.getJSONBody().session;
  });
};

Play.prototype._createPlayRequest = function(sessionUrl) {
  var body = {
    logging_params: {
      command_initiated_time: this._getTime()
    }
  };
  return new cosmos.Request(cosmos.Action.POST, sessionUrl + '/play', null, body);
};

Play.prototype._createUpdateRequest = function(sessionUrl, body) {
  body.logging_params = {
    command_initiated_time: this._getTime()
  };
  return new cosmos.Request(cosmos.Action.POST, sessionUrl + '/update', null, body);
};

/**
 * Perform the playback action that this handle represents.
 *
 * It is legal to call play more than once, but the playback action is only
 * prefetched the first time. If subsequent preparation is required, a new
 * Play object should be obtained.
 */
Play.prototype.play = function(opt_callback) {
  opt_callback = opt_callback || function() {};

  var self = this;
  if (this._createSessionPromise) {
    this._sessionUrl()
      .then(function(sessionUrl) {
        return nodefn.call(
          self._resolver.resolve.bind(self._resolver), self._createPlayRequest(sessionUrl));
      })
      .done(function() {
          opt_callback(null);
        }, function(error) {
          if (error.response && error.response.getStatusCode() === 404) {
            // The session has been invalidated. Try again without prefetching.
            self._createSessionPromise = null;
            self.play(opt_callback);
          } else {
            var wrappedError = new Error('Failed to prepare playback session: ' + error.message);
            wrappedError.cause = function() { return error; };
            opt_callback(wrappedError);
          }
        });
  } else {
    this._player.play(this._context, this._opt_options, opt_callback);
  }
};

Play.prototype._update = function(body, opt_callback) {
  opt_callback = opt_callback || function() {};

  var self = this;
  if (!this._createSessionPromise) {
    return opt_callback(new Error('Cannot update invalidated Play'));
  }

  this._sessionUrl()
    .then(function(sessionUrl) {
      return nodefn.call(
        self._resolver.resolve.bind(self._resolver), self._createUpdateRequest(sessionUrl, body));
    })
    .done(function() {
        opt_callback(null);
      }, function(error) {
        var wrappedError = new Error('Failed to update playback session: ' + error.message);
        wrappedError.cause = function() { return error; };
        opt_callback(wrappedError);
      });
};

Play.prototype.updateContext = function(context, opt_callback) {
  this._update({ context: context }, opt_callback);
};

Play.prototype.updatePage = function(page, opt_callback) {
  this._update({ page: page }, opt_callback);
};

Play.prototype.updateTrack = function(track, opt_callback) {
  this._update({ track: track }, opt_callback);
};

Play.prototype.updateViewUri = function(view_uri, opt_callback) {
  this._update({ view_uri: view_uri }, opt_callback);
};

/**
 * Invalidate the handle. This will cause any ongoing prefetching work to be
 * cancelled. It is good if any holder of a handle calls this method as soon
 * as it knows that it is not interested in its play action anymore.
 *
 * It is illegal to call play after this has been called. Invalidating an
 * invalidated Play is a no-op.
 */
Play.prototype.invalidate = function(opt_callback) {
  if (!this._createSessionPromise) {
    // Already invalidated
    return;
  }

  opt_callback = opt_callback || function() {};

  var self = this;
  this._sessionUrl().done(function(sessionUrl) {
    var request = new cosmos.Request(
      cosmos.Action.DELETE, sessionUrl, null, null);
    self._resolver.resolve(request, function() {
      opt_callback(null);
    });
  }, function() {
    // Ignore errors
    opt_callback(null);
  });

  this._createSessionPromise = null;
};

exports.Play = Play;

},{"spotify-cosmos-api":694,"when/node":756}],716:[function(require,module,exports){
var cosmos = require('spotify-cosmos-api');
var nodefn = require('when/node');
var play = require('./play');

var PLAYER_URI = 'sp://player/v2/';
var DEFAULT_PLAYER_ID = 'main';

/**
 * The object decribing the context for the playback
 * Can be used to pass viewUri or externalReferrer specific
 * for the play action.
 *
 * @typedef {Object} ContextConfig
 * @property {Cosmos.PlayerContext} context The context to play
 * @property {string=} opt_viewId Optional. Set to override the default viewUri
 * @property {string=} opt_externalReferrer Optional. Set to indicate that
 *      the playback is owne by external website/app.
 */

/**
 * Player is the main entry point to control music playback with cosmos.
 *
 * Player in itself isn't what deals with playback; it is merely an object
 * that controls playback and provides ability to observe the player state.
 * There can be more than one Player object at the same time, and they
 * will sync up as one would expect.
 *
 * In practice there will be at least one Player object per feature that
 * wants to control playback. The feature can choose to create one per view
 * or have only one object, it doesn't really matter.
 *
 * @param {Cosmos.resolver} resolver The resolver to send requests to.
 * @param {String} viewUri The uri of the view that owns the playback.
 * @param {String} featureIdentifier The identifier of the feature that started
 *     playback. This is arguably the most important field of this class. It is
 *     used for logging messages, in particular EndSong and EndVideo. (In EndSong,
 *     it ends up in source_start / source_end.) It should be a short human
 *     readable name of the feature, for example "radio", "album", "playlist".
 *     Ideally, it should be the same for a given feature across platforms.
 *
 *     Each feature should have only one string constant that it passes in here.
 *     You must not pass lots of distinct values here; for instance do not send
 *     something that contains the username or artist identifier.
 * @param {String} featureVersion The version of the feature. It often makes sense to set
 *     this value to the version of the spm package, for instance "0.7.5".
 * @param {{playerId: string}} opt_options The additional parameters for the player.
 *  param {string} options.playerId Can be used to override the id of the player
 *      which will result in a different endpoint for the player requests.
 */
function Player(resolver, viewUri, featureIdentifier, featureVersion, opt_options) {
  if (!(this instanceof Player)) {
    return new Player(resolver, viewUri, featureIdentifier, featureVersion);
  }

  if (!resolver || !viewUri || !featureIdentifier || !featureVersion) {
    throw new TypeError('Missing parameters for Player');
  }

  this._getTime = opt_options && opt_options.getTime || function() {
    return new Date().getTime();
  };

  /**
   * @type {string}
   */
  this._id = opt_options && opt_options.playerId || DEFAULT_PLAYER_ID;

  /**
   * @type {string}
   */
  this._referrerIdentifier = opt_options && opt_options.referrerIdentifier;

  /**
   * @type {Cosmos.resolver}
   */
  this._resolver = resolver;

  /**
   * @type {string}
   */
  this._viewUri = viewUri;

  /**
   * @type {string}
   */
  this._featureId = featureIdentifier;

  /**
   * @type {string}
   */
  this._featureVersion = featureVersion;
}

/**
 * The actions that can be understood by the PlayerResolver
 * in Cosmos Router.
 */
Player.Actions = {
  PLAY: 'play',
  SESSION: 'session',
  STOP: 'stop',
  UPDATE: 'update',
  PAUSE: 'pause',
  RESUME: 'resume',
  SKIP_NEXT: 'skip_next',
  SKIP_PREV: 'skip_prev',
  SHUFFLE: 'set_shuffling_context',
  REPEAT_CONTEXT: 'set_repeating_context',
  REPEAT_TRACK: 'set_repeating_track',
  SEEK_TO: 'seek_to'
};

/**
 * Private helper method for play and preparePlay
 */
Player.prototype._playOrPrepare = function(action, context, opt_options, opt_callback) {
  if (!context)
    throw new TypeError('Invalid `context` object');

  // Allow to not send the opt_options
  if (opt_options instanceof Function && !opt_callback) {
    opt_callback = opt_options;
    opt_options = null;
  }

  var params = {};
  params.context = context;
  params.play_origin = this._makePlayOrigin();
  params.options = opt_options;

  return this._sendRequestWithParams(action, params, opt_callback);
};

/**
 * Plays the given context.
 * Since both options and callback are optional this method can
 * take from 1 to 3 arguments. if callback is specified, it has to be
 * the last argument:
 *
 *    player.play(myContext);
 *    player.play(myContext, myPlayOptions);
 *    player.play(myContext, function myCallback() {});
 *    player.play(myContext, myPlayOptions, function myCallback() {});
 *
 * @param {module:spotify-player/types.Context} context The context to play.
 * @param {Cosmos.PlayOptions=} opt_options Optional play options.
 * @param {function(Error, Cosmos.Response?)=} opt_callback Optional
 *    callback that will be executed after player request is resolved.
 *
 *    NOTE: The reponse in the callback only has information about the
 *    request itself (i.e. if it was resolved correctly). If you want to have
 *    information about currently playing context you should subscribe to
 *    player events or fetch the current state using. getContext.
 *
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.play = function(context, opt_options, opt_callback) {
  return this._playOrPrepare(Player.Actions.PLAY, context, opt_options, opt_callback);
};

/**
 * This method is like play, but it doesn't actually initiate playback, it
 * merely expresses intent that the user is rather likely going to do a play
 * action like this soon.
 *
 * @return {Player.Play} A handle that is used for actually performing the
 *     playback action. When the object will no longer be used, the user is
 *     responsible for calling invalidate on it, otherwise it will keep
 *     holding resources. As long as this object is not invalidated, the
 *     playback system will take that as a hint that it should try to prepare
 *     playback like this.
 */
Player.prototype.preparePlay = function(context, opt_options) {
  var sessionPromise = nodefn.call(
    this._playOrPrepare.bind(this), Player.Actions.SESSION, context, opt_options);

  return new play.Play(this._resolver, sessionPromise, this, this._getTime, context, opt_options);
};

/**
 * Stop the playback and clear the context.
 *
 * @param {function=} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.stop = function(opt_callback) {
  return this._sendRequestWithAction(Player.Actions.STOP, opt_callback);
};

/**
 * Update the current context.
 *
 * @see https://short.spotify.net/0I for more detailed information on the
 *    implementation.
 *
 * @param {module:spotify-player/types.Context} context The context to update to.
 * @param {function=} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.update = function(context, opt_callback) {
  if (!context)
    throw new TypeError('Invalid `context` object');

  var params = { context: context };
  return this._sendRequestWithParams(Player.Actions.UPDATE, params, opt_callback);
};

/**
 * Resume the playback.
 *
 * @param {function=} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.resume = function(opt_callback) {
  return this._sendRequestWithAction(Player.Actions.RESUME, opt_callback);
};

/**
 * Pause the playback.
 *
 * @param {function=} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.pause = function(opt_callback) {
  return this._sendRequestWithAction(Player.Actions.PAUSE, opt_callback);
};

/**
 * Skip to the previous song.
 *
 * @param {Object=} opt_skip_options The object with the skip options
 *    like allow_seeking
 * @param {function=} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.skipToPrevTrack = function(opt_skip_options, opt_callback) {
  if (arguments.length === 1) {
    // In order to keep backwards compatibility we still need to support
    // passing just the callback as the first parameter
    if (typeof opt_skip_options === 'function') {
      opt_callback = opt_skip_options;
      opt_skip_options = null;
    }
  }
  var params = {};
  if (opt_skip_options) {
    params.options = opt_skip_options;
  }
  return this._sendRequestWithParams(Player.Actions.SKIP_PREV, params, opt_callback);
};

/**
 * Skip to the next song.
 *
 * @param {function=} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.skipToNextTrack = function(opt_callback) {
  return this._sendRequestWithAction(Player.Actions.SKIP_NEXT, opt_callback);
};

/**
 * Skip backwards until it gets to the specified track. This method never skips
 * to the beginning of the current track. For that, use seekTo.
 *
 * @discussion If the reverse runs out of tracks or skipping becomes disallowed
 *    for some other reason, this method will give up when it can no longer
 *    continue. This means that calling this for MFT users will almost
 *    certainly be a bad idea.
 *
 *    The intended purpose of this method is to make it possible to implement
 *    a view of the current future/reverse and allow the user to skip in it.
 *
 *    This method will look at the track URI and the track's UID (if present)
 *    to determine when it has reached its goal.
 *
 * @param {Object} track The track object, as it was provided from the
 *    player state reverse.
 * @param {function=} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.skipToSpecificPrevTrack = function(track, opt_callback) {
  return this._sendRequestWithParams(Player.Actions.SKIP_PREV, { track: track }, opt_callback);
};

/**
 * Skip forwards until it gets to the specified track.
 *
 * @discussion See discussion for -skipToPreviousTrack:
 *
 * @param {Object} track The track object, as it was provided from the
 *    player state reverse.
 * @param {function=} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.skipToSpecificNextTrack = function(track, opt_callback) {
  return this._sendRequestWithParams(Player.Actions.SKIP_NEXT, { track: track }, opt_callback);
};

/**
 * Deprecated alias for skipToPrevTrack
 */
Player.prototype.skipToPrev = Player.prototype.skipToPrevTrack;

/**
 * Deprecated alias for skipToNextTrack
 */
Player.prototype.skipToNext = Player.prototype.skipToNextTrack;

/**
 * Set the shuffle flag
 *
 * @param {boolean} isShuffling The value of the flag to set.
 * @param {function=} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.setShufflingContext = function(isShuffling, opt_callback) {
  return this._sendRequestWithParam(Player.Actions.SHUFFLE, isShuffling, opt_callback);
};

/**
 * Repeat the whole context
 *
 * @param {boolean} isRepeating The value of the flag to set.
 * @param {function=} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.setRepeatingContext = function(isRepeating, opt_callback) {
  return this._sendRequestWithParam(Player.Actions.REPEAT_CONTEXT, isRepeating, opt_callback);
};

/**
 * Repeat the single track
 *
 * @param {boolean} isRepeating The value of the flag to set.
 * @param {function=} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.setRepeatingTrack = function(isRepeating, opt_callback) {
  return this._sendRequestWithParam(Player.Actions.REPEAT_TRACK, isRepeating, opt_callback);
};

/**
 * Set the seek position. It should be set in seconds.
 *
 * @param {boolean} positionInMs Position to seek to in miliseconds.
 * @param {function=} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.seekTo = function(positionInMs, opt_callback) {
  return this._sendRequestWithParam(Player.Actions.SEEK_TO, positionInMs, opt_callback);
};

/**
 * Gets the current player state as an opaque string that can later be used to restore the
 * current state.
 *
 * @param {function(Error, Cosmos.Response=)} callback The function
 *    that will be called when the snapshot is available.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.save = function(callback) {
  var requestUri = this.getPlayerEndpointUri() + '/snapshot';
  var request = new cosmos.Request(cosmos.Action.GET, requestUri);
  return this._resolver.resolve(request, callback);
};

/**
 * Restores a state string that was previously saved by save().
 *
 * @param {string} state The state to restore.
 * @param {function(Error, Cosmos.Response=)} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.restore = function(state, opt_callback) {
  var requestUri = this.getPlayerEndpointUri() + '/snapshot';
  var request = new cosmos.Request(cosmos.Action.PUT, requestUri, null, state);
  return this._resolver.resolve(request, opt_callback);
};

/**
 * Gets the current player queue as an string that can later be modified to replace
 * the current queue.
 *
 * @param {function(Error, Cosmos.Response=)} callback The function
 *    that will be called when the queue is available.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */

Player.prototype.getQueue = function(callback) {
  var requestUri = this.getPlayerEndpointUri() + '/queue';
  var request = new cosmos.Request(cosmos.Action.GET, requestUri);
  return this._resolver.resolve(request, callback);
};

/**
 * Replace the player queue. The state will not replace the current one of the player if
 * the revision does not match the current revision of the player. This happens when
 * the player queue was changed elsewhere by the time it was received until it was set.
 * A response-status of 409 will inform about this situation.
 *
 * @param {string} state The queue-state to replace with.
 * @param {function(Error, Cosmos.Response=)} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.setQueue = function(state, opt_callback) {
  var requestUri = this.getPlayerEndpointUri() + '/queue';
  var request = new cosmos.Request(cosmos.Action.PUT, requestUri, null, state);
  return this._resolver.resolve(request, opt_callback);
};

/**
 * Subscribe to queue changes. There will be an initial callback when subscribing.
 */
Player.prototype.subscribeToQueue = function(callback) {
  var request = new cosmos.Request(cosmos.Action.SUB, this.getPlayerEndpointUri() + '/queue');
  return this._resolver.resolve(request, callback);
};

/**
 * Get the current player state.
 *
 * @param {function(Error, Cosmos.Response=)} callback The function
 *    that will be called when the state is available.
 * @param {Object=} opt_params The additional parameters for the request.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype.getState = function(callback, opt_params) {
  var request = new cosmos.Request(
    cosmos.Action.GET, this.getPlayerEndpointUriWithParams(opt_params));
  return this._resolver.resolve(request, callback);
};

/**
 * Subscribe to the player events
 *
 * @param {function(Error, Cosmos.Response=)} callback The function
 *    that will be called every time the event occurs.
 * @param {Object=} opt_params The additional parameters for the request.
 * @return {RequestHandle} The subscription handle.
 *
 *    This object can be used to cancel the subscription
 *    by calling 'cancel()' on it:
 *
 *    var sub = player.subscribe(function(err, response) { });
 *    sub.cancel();
 */
Player.prototype.subscribe = function(callback, opt_params) {
  var request = new cosmos.Request(
    cosmos.Action.SUB, this.getPlayerEndpointUriWithParams(opt_params));
  return this._resolver.resolve(request, callback);
};

/**
 * Subscribe to player error events
 */
Player.prototype.onError = function(callback) {
  var request = new cosmos.Request(cosmos.Action.SUB, this.getPlayerEndpointUri() + '/error');
  return this._resolver.resolve(request, callback);
};

Player.prototype._makePlayOrigin = function() {
  return {
    view_uri: this._viewUri,
    feature_identifier: this._featureId,
    feature_version: this._featureVersion,
    referrer_identifier: this._referrerIdentifier
  };
};

Player.prototype.getPlayerEndpointUri = function() {
  return PLAYER_URI + this._id;
};

Player.prototype.getPlayerEndpointUriWithParams = function(params) {
  params = params || {};

  var paramsArray = Object.keys(params).reduce(function(arr, key) {
    arr.push(key + '=' + encodeURIComponent(params[key]));
    return arr;
  }, []);

  if (paramsArray.length > 0) {
    return this.getPlayerEndpointUri() + '?' + paramsArray.join('&');
  } else {
    return this.getPlayerEndpointUri();
  }
};

/**
 * @private
 * Sends context-less request.
 *
 * @param {string} action The action to perform on the player.
 * @param {function=} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype._sendRequestWithAction = function(action, opt_callback) {
  return this._sendRequestWithParams(action, null, opt_callback);
};

/**
 * @private
 * Sends the request that only expects the single value in the body.
 *
 * @param {string} action The action to perform on the player.
 * @param {*} paramValue The value to send to the player.
 * @param {function=} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype._sendRequestWithParam = function(action, paramValue, opt_callback) {
  var params = {
    value: paramValue
  };
  return this._sendRequestWithParams(action, params, opt_callback);
};

/**
 * @private
 * Sends request with context and optional options.
 *
 * @param {string} action The action to perform on the player.
 * @param {Object?} params The context to play.
 * @param {function=} opt_callback If specified will be executed
 *    after request is resolved.
 * @return {Cosmos.RequestHandler} The object representing current request.
 */
Player.prototype._sendRequestWithParams = function(action, params, opt_callback) {
  var requestUri = this.getPlayerEndpointUri() + '/' + action;
  var body = params || {};
  body.logging_params = {
    command_initiated_time: this._getTime()
  };
  var request = new cosmos.Request(
    cosmos.Action.POST, requestUri, null, body);
  return this._resolver.resolve(request, opt_callback);
};

exports.Player = Player;

},{"./play":715,"spotify-cosmos-api":694,"when/node":756}],717:[function(require,module,exports){
/**
 * A PlayerTrack represents a single track in a context.
 *
 * @typedef {Object}
 * @property {String} uri
 *    The URI of the track. This will be one of the Spotify URIs, such as
 *    spotify:track:GID or spotify:local:DATA.
 * @property {String} album_uri
 *    The URI of the album that the track appears on. This property must always
 *    be set if the track URI is set. This is a requirement so that functions
 *    like MFT rules and biased shuffle can operate without having to fetch
 *    additional metadata for each track.
 * @property {String} artist_uri
 *    The URI of the main artist of the track. This property must always be set
 *    if the track URI is set. This is a requirement so that functions like MFT
 *    rules and biased shuffle can operate without having to fetch additional
 *    metadata for each track.
 * @property {Object} metadata
 *    A map with custom metadata for the track. This map can hold anything that
 *    the feature decides to put in it. Features should be prepared that the
 *    metadata can disappear and be able to work around that situation.
 *    The metadata is passed around and persisted, so it will usually stick
 *    around, but there are certain situations where the data is lost because of
 *    transferring the track over legacy protocols, to Connect enabled speakers
 *    and back.
 */
exports.Track;

/**
 * PlayerRestrictions is used to encapsulate limitations of a player or a
 * context. The caller can specify that restrictions should apply when playing a
 * given context (see PlayerContext.restrictions), and a player can notify that
 * restrictions (see PlayState.restrictions).
 *
 * @typedef {Object}
 * @property {Array.<String>} disallow_skipping_prev_reasons
 *    The reasons why skipping to the previous track should be / is disallowed.
 * @property {Array.<String>} disallow_skipping_next_reasons
 *    The reasons why skipping to the next track should be / is disallowed.
 * @property {Array.<String>} disallow_peeking_prev_reasons
 *    The reasons why peeking at the previous track should be / is disallowed.
 * @property {Array.<String>} disallow_peeking_next_reasons
 *    The reasons why peeking at the next track should be / is disallowed.
 * @property {Array.<String>} disallow_skipping_to_reasons
 *    The reasons why skipping to a specific track should be / is disallowed.
 * @property {Array.<String>} disallow_pausing_reasons
 *    The reasons why pausing playback should be / is disallowed.
 * @property {Array.<String>} disallow_resuming_reasons
 *    The reasons why resuming playback should be / is disallowed.
 * @property {Array.<String>} disallow_toggling_repeat_context_reasons
 *    The reasons why toggling repeat context should be / is disallowed.
 * @property {Array.<String>} disallow_toggling_repeat_track_reasons
 *    The reasons why toggling repeat track should be / is disallowed.
 * @property {Array.<String>} disallow_toggling_shuffle_reasons
 *    The reasons why toggling shuffle should be / is disallowed.
 * @property {Array.<String>} disallow_seeking_reasons
 *    The reasons why seeking within a track should be / is disallowed.
 * @property {Array.<String>} disallow_muting_reasons
 *    The reasons why muting audio should be / is disallowed.
 */
exports.Restrictions;

/**
 * PlayerSuppressions are used to disable certain player rules while playing a
 * context. The caller can specify that suppressions should apply when playing a
 * context (see PlayerOptions.suppressions), and a player can notify those
 * suppressions (see PlayState.suppressions).
 *
 * @typedef {Object}
 * @property {Array.<String>} providers
 *    The provider identifiers of the rules that should be disabled.
 */
exports.Suppressions;

/**
 * An object representing the index of the track to play within a context.
 * In the simplest case there is only one page thus its index should be 0.
 *
 * @typedef {Object}
 * @property {Number} page The index of the page to find the track in.
 * @property {Number} track The index of the track in the page.
 */
exports.IndexPath;

/**
 * This structure holds options that should be applied to the player: they are
 * either specified at a global or per-context level. When they are specified
 * globally, finishing the current context or starting to play a new context
 * does not change the player options: specifying them at a context-level means
 * that the previous global setting will be restored when the player is asked to
 * play another context.
 *
 * @typedef {Object}
 * @property {Boolean} shuffling_context
 *    Specifies if the player should shuffle the context or not.
 * @property {Boolean} repeating_context
 *    Specifies if the player should repeat the context or not.
 * @property {Boolean} repeating_track
 *    Specifies if the player should repeat the current track or not.
 */
exports.PlayerOptions;

/**
 * Options for a specific playback request. This object can specify for instance
 * which track to play within the given context, where to seek within the track
 * etc.
 *
 * @typedef {Object}
 * @property {module:spotify-player/types.IndexPath} skip_to_index
 *    The index in the context to start playing from. It is possible to specify
 *    a page that is not yet loaded, in which case the page will be downloaded
 *    before playback starts. The context player state will indicate that the
 *    playback is delayed because of loading the page.
 * @property {Number} seek_to
 *    The number of milliseconds to seek into the track when starting to
 *    play it.
 * @property {Boolean} initially_paused
 *    When this property is set, the context player will load the context but
 *    will not start playing audio for the first track. The is_paused property
 *    is set in the context player state to indicate that playback is paused. To
 *    start playing the track, call the `resume` method on the context player.
 * @property {module:spotify-player/types.PlayerOptions} player_options_override
 *    Use this to temporarily override the player options for this play request
 *    only. This can for instance be used to implement shuffle play buttons that
 *    enable shuffling but only for this particular context.
 */
exports.PlayOptions;

/**
 * Allows the list of tracks that will be played to be split up into chunks.
 * Pages may loaded or unloaded: an unloaded page will be loaded by the player
 * when it needs more tracks to play.
 *
 * @typedef {Object}
 * @property {String} page_url
 *     The URL of this page. If this property is set to a valid URL, it will be
 *     used to fetch the tracks of the page. The URL must be something that is
 *     supported by the context page loader in use, e.g., Hermes endpoints or
 *     Spotify playlist URIs. In the latter case, the context page loader will
 *     trigger the loaded signal each time the underlying playlist changes. If
 *     the tracks for the (static) context page are already provided in the
 *     tracks property, the page is considered loaded and the URL can be left
 *     empty.
 * @property {String} next_page_url
 *     The URL of the next context page. When the context page is stored in a
 *     context, the next page URL will be used to automatically append new pages
 *     at the end of the pages (or the fallback page) array. The new page
 *     will have its page URL set according to the next page URL of the last
 *     page in the context. The context page loaded will be used at some point
 *     to fetch the tracks for the new page. When the new page is fetched from
 *     the backend, it can also have the next page URL set, and yet another page
 *     is added to the context.
 * @property {Array<module:spotify-player/types.Track>} tracks
 *     An optional array with the tracks of this context page. When the context
 *     page is not loaded, the property is not initialized, and a context page
 *     loader will be used to fetch a loaded version of the page. In a loaded
 *     page this property will be set to an array of tracks. Note that the array
 *     can be empty, which means that the page does not have any tracks. This is
 *     not the same as a page that is not loaded, which may or may not have
 *     tracks.
 */
exports.ContextPage;

/**
 * Describes a set of tracks to be played.
 *
 * @typedef {Object}
 * @property {String} entity_uri
 *    An optional Spotify URI that represents what this entire context contains.
 *    For established entities like playlist, album, artist, this should be their
 *    respective URIs. This can be used for inter-feature playback status
 *    indication.
 *
 *    For instance, when the search page starts to play an artist, it should
 *    provide the artist URI in this field. The playback status indication for
 *    that artist in the search result list should be set if the current context
 *    entity URI matches the artist URI. On the artist page, the artist play
 *    button should also look at the entity URI for playback indication.
 * @property {Object} metadata
 *    A map with custom metadata for the track. This map can hold anything that
 *    the feature decides to put in it. Features should be prepared that the
 *    metadata can disappear and be able to work around that situation.
 *    The metadata is passed around and persisted, so it will usually stick
 *    around, but there are certain situations where the data is lost because of
 *    transferring the track over legacy protocols, to Connect enabled speakers
 *    and back.
 * @property {Array<module:spotify-player/types.ContextPage>} pages
 *    An array of context pages that contain the tracks that should be played
 *    for this context. The context pages may or may not be loaded when passing
 *    the context to the player for playback. Note that if the last context page
 *    has a next page URL, at some point a new context page will be added to the
 *    end of the array, for that page URL. This will happen when playback is
 *    nearing the end of the available context pages.
 * @property {Array<module:spotify-player/types.ContextPage>} fallback_pages
 *    A vector of context pages that contain the tracks that should be used as a
 *    fallback if some rule does not allow the tracks in the future to be
 *    played.  An example of this is the MFT rules, which has a number of
 *    restrictions of how many times a track and album can be played during a
 *    given time period.  Another example is the DMCA rules that is used for the
 *    radio feature. When a fallback track is picked from the fallback pages, it
 *    must be removed from the page, so that it is not used again later. The
 *    fallback track can be provided by the feature that starts playback or
 *    they will be populated by the player if they are needed and none are
 *    provided.
 * @property {module:spotify-player/types.Restricitions} restrictions
 *    The restrictons that should be applied to the player when playing tracks
 *    from the context, e.g., whether the user is allowed to skip backward and
 *    forward in the context or enable shuffling and repeating. Note that the
 *    actual restrictions of the player at any given moment is decided not only
 *    by the context restrictions but also by the rules that are applied, e.g.,
 *    the MFT rules will always disable skipping backward, and will disable
 *    skipping forward as well when the user has reached the maximum number of
 *    skips allowed per time period.
 */
exports.Context;

},{}],718:[function(require,module,exports){
/**
 * @module spotify-range2
 */'use strict';

var prime = require('prime');

var map = require('mout/array/map');

var push_ = Array.prototype.push;
var slice_ = Array.prototype.slice;

var Range = prime(/** @lends Range.prototype */{

  /**
   * The representation of a range
   * @constructs
   * @param {Number} start The start of the range.
   * @param {Number} end The end of the range.
   */
  constructor: function Range(start, end) {
    this.update(start, end);
  },

  /** Update a range. */
  update: function(start, end) {
    if (start != null) this.start = start;
    if (end != null) this.end = end;
    if (this.start == null || this.end == null) throw new Error('invalid range');
    if (this.start > this.end) throw new Error('invalid range');
    this.length = this.end - this.start;
    return this;
  },

  /** Copy a range. */
  copy: function() {
    return new Range(this.start, this.end);
  },

  /** Range is above range. */
  above: function(range) {
    if (!range) return false;
    return this.start >= range.end;
  },

  /** Range is below range. */
  below: function(range) {
    if (!range) return false;
    return this.end <= range.start;
  },

  adjacent: function(range) {
    if (!range) return false;
    return this.end === range.start || this.start === range.end;
  },

  /** Range intersects range. */
  intersects: function(range) {
    if (!range) return false;
    return !this.above(range) && !this.below(range);
  },

  /** Range contains range. */
  contains: function(range) {
    if (!range) return false;
    return (this.start <= range.start && this.end >= range.end);
  },

  /** Range is contained by ranges. */
  contained: function(range) {
    var ranges;
    if (range instanceof Range) ranges = arguments;
    else ranges = range;
    if (!ranges) return false;

    for (var i = 0; (range = ranges[i]); i++) {
      if (range.start <= this.start && range.end >= this.end)
        return true;
    }
    return false;
  },

  /** Range fits two ranges. */
  fits: function(prev, next) {
    if (!prev && !next) return true;
    if (!prev) return this.end <= next.start;
    if (!next) return this.start >= prev.end;
    return this.start >= prev.end && this.end <= next.start;
  },

  // get the section of this range contained between two ranges
  // [0, 20] » [0, 8], [16, 20] » [8, 16]

  /** portion of a range between two ranges. */
  between: function(prev, next) {
    if (!prev && !next) return this.copy();
    if (!prev) return this.start >= next.start ? null : new Range(this.start, Math.min(this.end, next.start));
    if (!next) return this.end <= prev.end ? null : new Range(Math.max(prev.end, this.start), this.end);

    return this.end > prev.end && this.start < next.start ?
        new Range(Math.max(prev.end, this.start), Math.min(next.start, this.end)) :
        null;
  },

  // [0, 8] » [0, 2], [4, 5] = [0, 2], [4, 5]
  // [3, 6] » [5, 7] = [5, 6]
  // [6, 9] » [5, 7] = [6, 7]

  /** intersection of a range with many ranges */
  intersection: function(range) {
    var intersected = [], ranges;
    if (range instanceof Range) ranges = arguments;
    else ranges = range;
    for (var k = 0; k < ranges.length; k++) {
      var r = ranges[k];
      if (this.below(r)) break;

      if (r.intersects(this)) intersected.push(new Range(Math.max(this.start, r.start), Math.min(this.end, r.end)));
    }
    return intersected;
  },

  // subtract ranges from this range
  // [0, 8] » [0, 2], [4, 5] = [2, 4], [5, 8]

  /** subtract many ranges from the range. */
  subtract: function(range) {
    var subtracted = [], ranges;
    if (range instanceof Range) ranges = arguments;
    else ranges = range;
    for (var k = -1; k < ranges.length; k++) {
      var prev = ranges[k];
      var next = ranges[k + 1];
      var between = this.between(prev, next);
      if (between) subtracted.push(between);
    }
    return subtracted;
  },

  // extract this range from ranges
  // [0, 8] » [0, 2], [5, 8] = []
  // [8, 20] » [0, 2], [5, 8] = [0, 2], [5, 8]
  // [0, 10] » [5, 10], [15, 20] = [5, 10]
  // [10, 20] » [5, 80], [90, 100] = [5, 70] [80, 90]
  // [10, 20] » [0, 10], [20, 30] = [0, 20]

  /** extract the range from many ranges. */
  extract: function(range) {
    var ranges = (range instanceof Range) ? slice_.call(arguments) : range.slice();

    for (var k = 0; k < ranges.length; k++) {
      var prev = ranges[k - 1];
      var next = ranges[k];

      var newRange = null;

      if (this.below(next)) {
        newRange = new Range(next.start - this.length, next.end - this.length);
      } else if (this.intersects(next)) {
        var subtracted = next.subtract(this);
        if (subtracted.length === 2) { // is contained
          newRange = new Range(subtracted[0].start, subtracted[1].end - this.length);
        } else if (subtracted.length === 1) {
          if (next.end > this.end) { // second segment kept
            newRange = new Range(subtracted[0].start - this.length, subtracted[0].end - this.length);
          } else if (this.start > next.start) { // first segment kept
            newRange = new Range(subtracted[0].start, subtracted[0].end);
          }
        } else { // gets eaten
          ranges.splice(k--, 1); // decrease k
        }
      } else {
        ranges.splice(k, 1, next.copy());
      }

      if (newRange) {
        if (prev && prev.end === newRange.start) { // touches previous
          ranges.splice(k-- - 1, 2, new Range(prev.start, newRange.end)); // decrease k due to splicing
        } else {
          ranges.splice(k, 1, newRange);
        }
      }

    }

    return ranges;
  },

  // [2,3] » [0,1], [2,3] = [0,1], [2,4]
  // [1,2] » [0,6] = [0,7]
  // [0,1] » [0,1], [5,6] = [0,2], [6,7]
  // [4,6] » [0,1], [5,6] = [0,1], [4,6], [7,8]

  // TODO: this can be slightly better. merging can be done in one loop.

  /** insert the range in many ranges. */
  insert: function(range) {
    var ranges = (range instanceof Range) ? slice_.call(arguments) : range.slice();

    for (var k = 0; k < ranges.length; k++) {
      var next = ranges[k];

      if (this.start >= next.end) {

        ranges.splice(k, 1, next.copy());

      } else if (this.start > next.start && this.start < next.end) {

        ranges.splice(k, 1, new Range(next.start, this.start), new Range(this.start, next.end));

      } else {

        ranges.splice(k, 1, new Range(next.start + this.length, next.end + this.length));

      }

    }

    return this.merge(ranges);

  },

  // merge this range in ranges
  // [0, 8] » [0, 2], [5, 8] = [0, 8]
  // [8, 20] » [0, 2], [5, 8] = [0, 2], [5, 20]
  // [0, 10] » [5, 10], [15, 20] = [0, 10], [15, 20]

  /** merge many ranges to the range. */
  merge: function(range) {
    var ranges;
    if (range instanceof Range) ranges = arguments;
    else ranges = range;

    ranges = map(ranges, function(r) {
      return r.copy();
    });

    if (!ranges.length) return [this.copy()];

    for (var k = -1, l = ranges.length; k < l; k++) {

      var prev = ranges[k];
      var next = ranges[k + 1];
      var between = this.between(prev, next);

      if (between) {

        if (!prev && next) {

          if (between.end === next.start) {
            next.update(between.start, next.end);
          } else {
            k++; // increase k since we had a push
            ranges.unshift(between);
          }

        } else if (prev && next) {

          if (prev.end === between.start && between.end === next.start) {
            prev.update(prev.start, next.end);
            ranges.splice(k-- + 1, 1); // remove the next, decrease k since we had a splice
          } else if (prev.end === between.start) {
            prev.update(prev.start, between.end);
          } else if (between.end === next.start) {
            next.update(between.start, next.end);
          } else {
            ranges.splice(k + 1, 0, between);
          }

        } else if (prev && !next) {

          if (prev.end === between.start) {
            prev.update(prev.start, between.end);
          } else {
            k++; // increase k since we had a push
            ranges.push(between);
          }
        }

      }

    }

    return ranges;
  },

  /** Remove range from many ranges
      - The range(s) you pass is what you remove from */
  remove: function(range) {
    var ranges;
    if (range instanceof Range) ranges = arguments;
    else ranges = range;
    var result = [];
    for (var i = 0; i < ranges.length; i++) {
      var remaining = ranges[i].subtract(this);
      if (remaining.length) push_.apply(result, remaining);
    }
    return result;
  },

  /** Range to an array of indices */
  toIndices: function() {
    var indices = [];
    for (var i = this.start; i < this.end; i++) indices.push(i);
    return indices;
  },

  /** Range to a string */
  toString: function() {
    return [this.start, this.end] + '';
  }

});

/**
 * Range from a string
 * @memberof Range
 * @static
 * @param {String} string - The string.
 * @return {Range} The range.
 */
Range.fromString = function(string) {
  var parts = string.split(',');
  return new Range(+parts[0], +parts[1]);
};

/**
 * Ranges from an array of indices
 * @memberof Range
 * @static
 * @param {Array} indices - An array of indices.
 * @return {Array} An array of Ranges.
 */
Range.fromIndices = function(indices) {
  indices.sort(function(a, b) {
    return a > b ? 1 : -1;
  });

  var ranges = [], rstart, rend;

  for (var i = 0; i < indices.length; i++) {
    rstart = indices[i];
    rend = rstart;
    while (indices[i + 1] - indices[i] === 1) {
      rend = indices[i + 1]; // increment the index if the numbers sequential
      i++;
    }
    ranges.push(new Range(rstart, rend + 1));
  }

  return ranges;
};

/**
 * A function that returns a range.
 * @function
 * @see Range
 * @param {Number} start The start of the range.
 * @param {Number} end The end of the range.
 */
module.exports = Range;

},{"mout/array/map":719,"prime":732}],719:[function(require,module,exports){
arguments[4][535][0].apply(exports,arguments)
},{"../function/makeIterator_":721,"dup":535}],720:[function(require,module,exports){
arguments[4][541][0].apply(exports,arguments)
},{"dup":541}],721:[function(require,module,exports){
arguments[4][542][0].apply(exports,arguments)
},{"../object/deepMatches":727,"./identity":720,"./prop":722,"dup":542}],722:[function(require,module,exports){
arguments[4][543][0].apply(exports,arguments)
},{"dup":543}],723:[function(require,module,exports){
arguments[4][544][0].apply(exports,arguments)
},{"../object/mixIn":731,"dup":544}],724:[function(require,module,exports){
arguments[4][545][0].apply(exports,arguments)
},{"./isKind":725,"dup":545}],725:[function(require,module,exports){
arguments[4][546][0].apply(exports,arguments)
},{"./kindOf":726,"dup":546}],726:[function(require,module,exports){
arguments[4][548][0].apply(exports,arguments)
},{"dup":548}],727:[function(require,module,exports){
arguments[4][549][0].apply(exports,arguments)
},{"../lang/isArray":724,"./forOwn":729,"dup":549}],728:[function(require,module,exports){
arguments[4][550][0].apply(exports,arguments)
},{"./hasOwn":730,"dup":550}],729:[function(require,module,exports){
arguments[4][551][0].apply(exports,arguments)
},{"./forIn":728,"./hasOwn":730,"dup":551}],730:[function(require,module,exports){
arguments[4][552][0].apply(exports,arguments)
},{"dup":552}],731:[function(require,module,exports){
arguments[4][553][0].apply(exports,arguments)
},{"./forOwn":729,"dup":553}],732:[function(require,module,exports){
arguments[4][555][0].apply(exports,arguments)
},{"dup":555,"mout/lang/createObject":723,"mout/lang/kindOf":726,"mout/object/hasOwn":730,"mout/object/mixIn":731}],733:[function(require,module,exports){
'use strict';

/**
 * Tree object implementation
 *
 * @param {Object}  data the data of the object
 * @param {Object}  parent the parent folder of the object
 * @param {Boolean} isFolder whether or not is a folder
 * @param {Function}  itemIdFn the function to get the object identifier
 */
function Tree (data, parent, isFolder, itemIdFn) {
  if (typeof data === 'string') {
    this.text = data;
    this.toString = function () { return this.text; };
  } else {
    for (var i in data) {
      this[i] = data[i];
    }
  }

  this.items = [];
  this.parent = parent;

  this._indexedItems = {};
  this.parents = [];
  var root = parent || this;
  while (true) {
    if (root.parent) {
      this.parents.unshift(root);
      root = root.parent;
    } else {
      break;
    }
  }

  if (data) {
    root = root ? root : this;
    if (!root._indexedItems[itemIdFn(data)]) {
      root._indexedItems[itemIdFn(data)] = this;
    }
  }

  this.isFolder = !!isFolder;
  this._itemIdFn = itemIdFn;

  Object.defineProperty(this, 'size', {
    get: function () { return this.items.length; }
  });
}

/**
 * Adds a new item to the Tree
 * @param {Object}  data the object data
 * @param {Boolean} isFolder whether or not the new added item is a folder
 */
Tree.prototype.addItem = function (data, isFolder) {
  var newItem = new this.constructor(data, this, isFolder, this._itemIdFn);

  this.items.push(newItem);
  return newItem;
};

/**
 * gets an item from a Tree
 * @param  {Mixed} id the id of the item
 * @param  {Boolean} recursive whether or not check recursively in the children
 * @return {Tree} the item object
 */
Tree.prototype.getItem = function (id, recursive) {
  for (var i = 0; i < this.items.length; i++) {
    if (this._itemIdFn(this.items[i]) === id) {
      return this.items[i];
    }

    if (recursive) {
      var item = this.items[i].getItem(id, recursive);
      if (item) {
        return item;
      }
    }
  }

  return null;
};

/**
 * returns whether or not an item exists in the Tree
 * @param  {Mixed} id the id of the item
 * @param  {Boolean} recursive whether or not check recursively in the children
 * @return {Boolean}
 */
Tree.prototype.hasItem = function (id, recursive) {
  if (recursive) {
    return !!this.getIndexedItem(id);
  } else {
    return !!this.getItem(id, false);
  }
};

/**
 * equivalent to getItem(id, true) but much faster
 * @param  {Mixed} id the id of the item
 * @return {Boolean}
 */
Tree.prototype.getIndexedItem = function (id) {
  var root = this.parents[0] ? this.parents[0] : this;
  return root._indexedItems[id];
};

/**
 * Creates a Tree object based on a flat array
 * @param  {Array}  input The input array
 * @param  {Function} isFolderFn function to check if an item is a folder
 * @param  {Function}  itemIdFn function to get the object identifier
 * @return {Tree}
 */
Tree.fromArray = function (input, isFolderFn, itemIdFn) {
  itemIdFn = itemIdFn || function (item) { return item.toString(); };

  var root = new this(null, null, true, itemIdFn);
  var currentItem = root;
  var treeStack = [];

  input.forEach(function (item, position) {
    item.position = position;

    if (isFolderFn(item)) {
      var id = itemIdFn(item);
      var currentId = treeStack.pop();
      if (id === currentId) {
        // close folder
        currentItem = currentItem.parent;
      } else {
        // open folder
        var newItem = currentItem.addItem(item, true);
        currentItem = newItem;
        treeStack.push(currentId);
        treeStack.push(id);
      }
    } else {
      // add regular tree
      currentItem.addItem(item);
    }
  });

  return root;
};

module.exports = Tree;

},{}],734:[function(require,module,exports){
//     Underscore.js 1.8.3
//     http://underscorejs.org
//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `exports` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var
    push             = ArrayProto.push,
    slice            = ArrayProto.slice,
    toString         = ObjProto.toString,
    hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind,
    nativeCreate       = Object.create;

  // Naked function reference for surrogate-prototype-swapping.
  var Ctor = function(){};

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.8.3';

  // Internal function that returns an efficient (for current engines) version
  // of the passed-in callback, to be repeatedly applied in other Underscore
  // functions.
  var optimizeCb = function(func, context, argCount) {
    if (context === void 0) return func;
    switch (argCount == null ? 3 : argCount) {
      case 1: return function(value) {
        return func.call(context, value);
      };
      case 2: return function(value, other) {
        return func.call(context, value, other);
      };
      case 3: return function(value, index, collection) {
        return func.call(context, value, index, collection);
      };
      case 4: return function(accumulator, value, index, collection) {
        return func.call(context, accumulator, value, index, collection);
      };
    }
    return function() {
      return func.apply(context, arguments);
    };
  };

  // A mostly-internal function to generate callbacks that can be applied
  // to each element in a collection, returning the desired result — either
  // identity, an arbitrary callback, a property matcher, or a property accessor.
  var cb = function(value, context, argCount) {
    if (value == null) return _.identity;
    if (_.isFunction(value)) return optimizeCb(value, context, argCount);
    if (_.isObject(value)) return _.matcher(value);
    return _.property(value);
  };
  _.iteratee = function(value, context) {
    return cb(value, context, Infinity);
  };

  // An internal function for creating assigner functions.
  var createAssigner = function(keysFunc, undefinedOnly) {
    return function(obj) {
      var length = arguments.length;
      if (length < 2 || obj == null) return obj;
      for (var index = 1; index < length; index++) {
        var source = arguments[index],
            keys = keysFunc(source),
            l = keys.length;
        for (var i = 0; i < l; i++) {
          var key = keys[i];
          if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];
        }
      }
      return obj;
    };
  };

  // An internal function for creating a new object that inherits from another.
  var baseCreate = function(prototype) {
    if (!_.isObject(prototype)) return {};
    if (nativeCreate) return nativeCreate(prototype);
    Ctor.prototype = prototype;
    var result = new Ctor;
    Ctor.prototype = null;
    return result;
  };

  var property = function(key) {
    return function(obj) {
      return obj == null ? void 0 : obj[key];
    };
  };

  // Helper for collection methods to determine whether a collection
  // should be iterated as an array or as an object
  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
  var getLength = property('length');
  var isArrayLike = function(collection) {
    var length = getLength(collection);
    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
  };

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles raw objects in addition to array-likes. Treats all
  // sparse array-likes as if they were dense.
  _.each = _.forEach = function(obj, iteratee, context) {
    iteratee = optimizeCb(iteratee, context);
    var i, length;
    if (isArrayLike(obj)) {
      for (i = 0, length = obj.length; i < length; i++) {
        iteratee(obj[i], i, obj);
      }
    } else {
      var keys = _.keys(obj);
      for (i = 0, length = keys.length; i < length; i++) {
        iteratee(obj[keys[i]], keys[i], obj);
      }
    }
    return obj;
  };

  // Return the results of applying the iteratee to each element.
  _.map = _.collect = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length,
        results = Array(length);
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      results[index] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
  };

  // Create a reducing function iterating left or right.
  function createReduce(dir) {
    // Optimized iterator function as using arguments.length
    // in the main function will deoptimize the, see #1991.
    function iterator(obj, iteratee, memo, keys, index, length) {
      for (; index >= 0 && index < length; index += dir) {
        var currentKey = keys ? keys[index] : index;
        memo = iteratee(memo, obj[currentKey], currentKey, obj);
      }
      return memo;
    }

    return function(obj, iteratee, memo, context) {
      iteratee = optimizeCb(iteratee, context, 4);
      var keys = !isArrayLike(obj) && _.keys(obj),
          length = (keys || obj).length,
          index = dir > 0 ? 0 : length - 1;
      // Determine the initial value if none is provided.
      if (arguments.length < 3) {
        memo = obj[keys ? keys[index] : index];
        index += dir;
      }
      return iterator(obj, iteratee, memo, keys, index, length);
    };
  }

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`.
  _.reduce = _.foldl = _.inject = createReduce(1);

  // The right-associative version of reduce, also known as `foldr`.
  _.reduceRight = _.foldr = createReduce(-1);

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, predicate, context) {
    var key;
    if (isArrayLike(obj)) {
      key = _.findIndex(obj, predicate, context);
    } else {
      key = _.findKey(obj, predicate, context);
    }
    if (key !== void 0 && key !== -1) return obj[key];
  };

  // Return all the elements that pass a truth test.
  // Aliased as `select`.
  _.filter = _.select = function(obj, predicate, context) {
    var results = [];
    predicate = cb(predicate, context);
    _.each(obj, function(value, index, list) {
      if (predicate(value, index, list)) results.push(value);
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, predicate, context) {
    return _.filter(obj, _.negate(cb(predicate)), context);
  };

  // Determine whether all of the elements match a truth test.
  // Aliased as `all`.
  _.every = _.all = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (!predicate(obj[currentKey], currentKey, obj)) return false;
    }
    return true;
  };

  // Determine if at least one element in the object matches a truth test.
  // Aliased as `any`.
  _.some = _.any = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (predicate(obj[currentKey], currentKey, obj)) return true;
    }
    return false;
  };

  // Determine if the array or object contains a given item (using `===`).
  // Aliased as `includes` and `include`.
  _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {
    if (!isArrayLike(obj)) obj = _.values(obj);
    if (typeof fromIndex != 'number' || guard) fromIndex = 0;
    return _.indexOf(obj, item, fromIndex) >= 0;
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function(value) {
      var func = isFunc ? method : value[method];
      return func == null ? func : func.apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, _.property(key));
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs) {
    return _.filter(obj, _.matcher(attrs));
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.find(obj, _.matcher(attrs));
  };

  // Return the maximum element (or element-based computation).
  _.max = function(obj, iteratee, context) {
    var result = -Infinity, lastComputed = -Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value > result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iteratee, context) {
    var result = Infinity, lastComputed = Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value < result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed < lastComputed || computed === Infinity && result === Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Shuffle a collection, using the modern version of the
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
  _.shuffle = function(obj) {
    var set = isArrayLike(obj) ? obj : _.values(obj);
    var length = set.length;
    var shuffled = Array(length);
    for (var index = 0, rand; index < length; index++) {
      rand = _.random(0, index);
      if (rand !== index) shuffled[index] = shuffled[rand];
      shuffled[rand] = set[index];
    }
    return shuffled;
  };

  // Sample **n** random values from a collection.
  // If **n** is not specified, returns a single random element.
  // The internal `guard` argument allows it to work with `map`.
  _.sample = function(obj, n, guard) {
    if (n == null || guard) {
      if (!isArrayLike(obj)) obj = _.values(obj);
      return obj[_.random(obj.length - 1)];
    }
    return _.shuffle(obj).slice(0, Math.max(0, n));
  };

  // Sort the object's values by a criterion produced by an iteratee.
  _.sortBy = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value: value,
        index: index,
        criteria: iteratee(value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index - right.index;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(behavior) {
    return function(obj, iteratee, context) {
      var result = {};
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index) {
        var key = iteratee(value, index, obj);
        behavior(result, value, key);
      });
      return result;
    };
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key].push(value); else result[key] = [value];
  });

  // Indexes the object's values by a criterion, similar to `groupBy`, but for
  // when you know that your index values will be unique.
  _.indexBy = group(function(result, value, key) {
    result[key] = value;
  });

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key]++; else result[key] = 1;
  });

  // Safely create a real, live array from anything iterable.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (isArrayLike(obj)) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return isArrayLike(obj) ? obj.length : _.keys(obj).length;
  };

  // Split a collection into two arrays: one whose elements all satisfy the given
  // predicate, and one whose elements all do not satisfy the predicate.
  _.partition = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var pass = [], fail = [];
    _.each(obj, function(value, key, obj) {
      (predicate(value, key, obj) ? pass : fail).push(value);
    });
    return [pass, fail];
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[0];
    return _.initial(array, array.length - n);
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array.
  _.last = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[array.length - 1];
    return _.rest(array, Math.max(0, array.length - n));
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, n == null || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, _.identity);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, strict, startIndex) {
    var output = [], idx = 0;
    for (var i = startIndex || 0, length = getLength(input); i < length; i++) {
      var value = input[i];
      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
        //flatten current level of array or arguments object
        if (!shallow) value = flatten(value, shallow, strict);
        var j = 0, len = value.length;
        output.length += len;
        while (j < len) {
          output[idx++] = value[j++];
        }
      } else if (!strict) {
        output[idx++] = value;
      }
    }
    return output;
  };

  // Flatten out an array, either recursively (by default), or just one level.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, false);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iteratee, context) {
    if (!_.isBoolean(isSorted)) {
      context = iteratee;
      iteratee = isSorted;
      isSorted = false;
    }
    if (iteratee != null) iteratee = cb(iteratee, context);
    var result = [];
    var seen = [];
    for (var i = 0, length = getLength(array); i < length; i++) {
      var value = array[i],
          computed = iteratee ? iteratee(value, i, array) : value;
      if (isSorted) {
        if (!i || seen !== computed) result.push(value);
        seen = computed;
      } else if (iteratee) {
        if (!_.contains(seen, computed)) {
          seen.push(computed);
          result.push(value);
        }
      } else if (!_.contains(result, value)) {
        result.push(value);
      }
    }
    return result;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(flatten(arguments, true, true));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    var result = [];
    var argsLength = arguments.length;
    for (var i = 0, length = getLength(array); i < length; i++) {
      var item = array[i];
      if (_.contains(result, item)) continue;
      for (var j = 1; j < argsLength; j++) {
        if (!_.contains(arguments[j], item)) break;
      }
      if (j === argsLength) result.push(item);
    }
    return result;
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = flatten(arguments, true, true, 1);
    return _.filter(array, function(value){
      return !_.contains(rest, value);
    });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    return _.unzip(arguments);
  };

  // Complement of _.zip. Unzip accepts an array of arrays and groups
  // each array's elements on shared indices
  _.unzip = function(array) {
    var length = array && _.max(array, getLength).length || 0;
    var result = Array(length);

    for (var index = 0; index < length; index++) {
      result[index] = _.pluck(array, index);
    }
    return result;
  };

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values.
  _.object = function(list, values) {
    var result = {};
    for (var i = 0, length = getLength(list); i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // Generator function to create the findIndex and findLastIndex functions
  function createPredicateIndexFinder(dir) {
    return function(array, predicate, context) {
      predicate = cb(predicate, context);
      var length = getLength(array);
      var index = dir > 0 ? 0 : length - 1;
      for (; index >= 0 && index < length; index += dir) {
        if (predicate(array[index], index, array)) return index;
      }
      return -1;
    };
  }

  // Returns the first index on an array-like that passes a predicate test
  _.findIndex = createPredicateIndexFinder(1);
  _.findLastIndex = createPredicateIndexFinder(-1);

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iteratee, context) {
    iteratee = cb(iteratee, context, 1);
    var value = iteratee(obj);
    var low = 0, high = getLength(array);
    while (low < high) {
      var mid = Math.floor((low + high) / 2);
      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
    }
    return low;
  };

  // Generator function to create the indexOf and lastIndexOf functions
  function createIndexFinder(dir, predicateFind, sortedIndex) {
    return function(array, item, idx) {
      var i = 0, length = getLength(array);
      if (typeof idx == 'number') {
        if (dir > 0) {
            i = idx >= 0 ? idx : Math.max(idx + length, i);
        } else {
            length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
        }
      } else if (sortedIndex && idx && length) {
        idx = sortedIndex(array, item);
        return array[idx] === item ? idx : -1;
      }
      if (item !== item) {
        idx = predicateFind(slice.call(array, i, length), _.isNaN);
        return idx >= 0 ? idx + i : -1;
      }
      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
        if (array[idx] === item) return idx;
      }
      return -1;
    };
  }

  // Return the position of the first occurrence of an item in an array,
  // or -1 if the item is not included in the array.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (stop == null) {
      stop = start || 0;
      start = 0;
    }
    step = step || 1;

    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var range = Array(length);

    for (var idx = 0; idx < length; idx++, start += step) {
      range[idx] = start;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Determines whether to execute a function as a constructor
  // or a normal function with the provided arguments
  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
    var self = baseCreate(sourceFunc.prototype);
    var result = sourceFunc.apply(self, args);
    if (_.isObject(result)) return result;
    return self;
  };

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = function(func, context) {
    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
    var args = slice.call(arguments, 2);
    var bound = function() {
      return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));
    };
    return bound;
  };

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context. _ acts
  // as a placeholder, allowing any combination of arguments to be pre-filled.
  _.partial = function(func) {
    var boundArgs = slice.call(arguments, 1);
    var bound = function() {
      var position = 0, length = boundArgs.length;
      var args = Array(length);
      for (var i = 0; i < length; i++) {
        args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];
      }
      while (position < arguments.length) args.push(arguments[position++]);
      return executeBound(func, bound, this, this, args);
    };
    return bound;
  };

  // Bind a number of an object's methods to that object. Remaining arguments
  // are the method names to be bound. Useful for ensuring that all callbacks
  // defined on an object belong to it.
  _.bindAll = function(obj) {
    var i, length = arguments.length, key;
    if (length <= 1) throw new Error('bindAll must be passed function names');
    for (i = 1; i < length; i++) {
      key = arguments[i];
      obj[key] = _.bind(obj[key], obj);
    }
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memoize = function(key) {
      var cache = memoize.cache;
      var address = '' + (hasher ? hasher.apply(this, arguments) : key);
      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);
      return cache[address];
    };
    memoize.cache = {};
    return memoize;
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){
      return func.apply(null, args);
    }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = _.partial(_.delay, _, 1);

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  _.throttle = function(func, wait, options) {
    var context, args, result;
    var timeout = null;
    var previous = 0;
    if (!options) options = {};
    var later = function() {
      previous = options.leading === false ? 0 : _.now();
      timeout = null;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    };
    return function() {
      var now = _.now();
      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0 || remaining > wait) {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }
        previous = now;
        result = func.apply(context, args);
        if (!timeout) context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, args, context, timestamp, result;

    var later = function() {
      var last = _.now() - timestamp;

      if (last < wait && last >= 0) {
        timeout = setTimeout(later, wait - last);
      } else {
        timeout = null;
        if (!immediate) {
          result = func.apply(context, args);
          if (!timeout) context = args = null;
        }
      }
    };

    return function() {
      context = this;
      args = arguments;
      timestamp = _.now();
      var callNow = immediate && !timeout;
      if (!timeout) timeout = setTimeout(later, wait);
      if (callNow) {
        result = func.apply(context, args);
        context = args = null;
      }

      return result;
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return _.partial(wrapper, func);
  };

  // Returns a negated version of the passed-in predicate.
  _.negate = function(predicate) {
    return function() {
      return !predicate.apply(this, arguments);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var args = arguments;
    var start = args.length - 1;
    return function() {
      var i = start;
      var result = args[start].apply(this, arguments);
      while (i--) result = args[i].call(this, result);
      return result;
    };
  };

  // Returns a function that will only be executed on and after the Nth call.
  _.after = function(times, func) {
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Returns a function that will only be executed up to (but not including) the Nth call.
  _.before = function(times, func) {
    var memo;
    return function() {
      if (--times > 0) {
        memo = func.apply(this, arguments);
      }
      if (times <= 1) func = null;
      return memo;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = _.partial(_.before, 2);

  // Object Functions
  // ----------------

  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
                      'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

  function collectNonEnumProps(obj, keys) {
    var nonEnumIdx = nonEnumerableProps.length;
    var constructor = obj.constructor;
    var proto = (_.isFunction(constructor) && constructor.prototype) || ObjProto;

    // Constructor is a special case.
    var prop = 'constructor';
    if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);

    while (nonEnumIdx--) {
      prop = nonEnumerableProps[nonEnumIdx];
      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
        keys.push(prop);
      }
    }
  }

  // Retrieve the names of an object's own properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = function(obj) {
    if (!_.isObject(obj)) return [];
    if (nativeKeys) return nativeKeys(obj);
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve all the property names of an object.
  _.allKeys = function(obj) {
    if (!_.isObject(obj)) return [];
    var keys = [];
    for (var key in obj) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };

  // Returns the results of applying the iteratee to each element of the object
  // In contrast to _.map it returns an object
  _.mapObject = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys =  _.keys(obj),
          length = keys.length,
          results = {},
          currentKey;
      for (var index = 0; index < length; index++) {
        currentKey = keys[index];
        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
      }
      return results;
  };

  // Convert an object into a list of `[key, value]` pairs.
  _.pairs = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [keys[i], obj[keys[i]]];
    }
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = createAssigner(_.allKeys);

  // Assigns a given object with all the own properties in the passed-in object(s)
  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
  _.extendOwn = _.assign = createAssigner(_.keys);

  // Returns the first key on an object that passes a predicate test
  _.findKey = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = _.keys(obj), key;
    for (var i = 0, length = keys.length; i < length; i++) {
      key = keys[i];
      if (predicate(obj[key], key, obj)) return key;
    }
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(object, oiteratee, context) {
    var result = {}, obj = object, iteratee, keys;
    if (obj == null) return result;
    if (_.isFunction(oiteratee)) {
      keys = _.allKeys(obj);
      iteratee = optimizeCb(oiteratee, context);
    } else {
      keys = flatten(arguments, false, false, 1);
      iteratee = function(value, key, obj) { return key in obj; };
      obj = Object(obj);
    }
    for (var i = 0, length = keys.length; i < length; i++) {
      var key = keys[i];
      var value = obj[key];
      if (iteratee(value, key, obj)) result[key] = value;
    }
    return result;
  };

   // Return a copy of the object without the blacklisted properties.
  _.omit = function(obj, iteratee, context) {
    if (_.isFunction(iteratee)) {
      iteratee = _.negate(iteratee);
    } else {
      var keys = _.map(flatten(arguments, false, false, 1), String);
      iteratee = function(value, key) {
        return !_.contains(keys, key);
      };
    }
    return _.pick(obj, iteratee, context);
  };

  // Fill in a given object with default properties.
  _.defaults = createAssigner(_.allKeys, true);

  // Creates an object that inherits from the given prototype object.
  // If additional properties are provided then they will be added to the
  // created object.
  _.create = function(prototype, props) {
    var result = baseCreate(prototype);
    if (props) _.extendOwn(result, props);
    return result;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Returns whether an object has a given set of `key:value` pairs.
  _.isMatch = function(object, attrs) {
    var keys = _.keys(attrs), length = keys.length;
    if (object == null) return !length;
    var obj = Object(object);
    for (var i = 0; i < length; i++) {
      var key = keys[i];
      if (attrs[key] !== obj[key] || !(key in obj)) return false;
    }
    return true;
  };


  // Internal recursive comparison function for `isEqual`.
  var eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a === 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className !== toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
      case '[object RegExp]':
      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return '' + a === '' + b;
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive.
        // Object(NaN) is equivalent to NaN
        if (+a !== +a) return +b !== +b;
        // An `egal` comparison is performed for other numeric values.
        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a === +b;
    }

    var areArrays = className === '[object Array]';
    if (!areArrays) {
      if (typeof a != 'object' || typeof b != 'object') return false;

      // Objects with different constructors are not equivalent, but `Object`s or `Array`s
      // from different frames are.
      var aCtor = a.constructor, bCtor = b.constructor;
      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
                               _.isFunction(bCtor) && bCtor instanceof bCtor)
                          && ('constructor' in a && 'constructor' in b)) {
        return false;
      }
    }
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

    // Initializing stack of traversed objects.
    // It's done here since we only need them for objects and arrays comparison.
    aStack = aStack || [];
    bStack = bStack || [];
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] === a) return bStack[length] === b;
    }

    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);

    // Recursively compare objects and arrays.
    if (areArrays) {
      // Compare array lengths to determine if a deep comparison is necessary.
      length = a.length;
      if (length !== b.length) return false;
      // Deep compare the contents, ignoring non-numeric properties.
      while (length--) {
        if (!eq(a[length], b[length], aStack, bStack)) return false;
      }
    } else {
      // Deep compare objects.
      var keys = _.keys(a), key;
      length = keys.length;
      // Ensure that both objects contain the same number of properties before comparing deep equality.
      if (_.keys(b).length !== length) return false;
      while (length--) {
        // Deep compare each member
        key = keys[length];
        if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return true;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
    return _.keys(obj).length === 0;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) === '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    var type = typeof obj;
    return type === 'function' || type === 'object' && !!obj;
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.
  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) === '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE < 9), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return _.has(obj, 'callee');
    };
  }

  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
  // IE 11 (#1621), and in Safari 8 (#1929).
  if (typeof /./ != 'function' && typeof Int8Array != 'object') {
    _.isFunction = function(obj) {
      return typeof obj == 'function' || false;
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
  _.isNaN = function(obj) {
    return _.isNumber(obj) && obj !== +obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, key) {
    return obj != null && hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iteratees.
  _.identity = function(value) {
    return value;
  };

  // Predicate-generating functions. Often useful outside of Underscore.
  _.constant = function(value) {
    return function() {
      return value;
    };
  };

  _.noop = function(){};

  _.property = property;

  // Generates a function for a given object that returns a given property.
  _.propertyOf = function(obj) {
    return obj == null ? function(){} : function(key) {
      return obj[key];
    };
  };

  // Returns a predicate for checking whether an object has a given set of
  // `key:value` pairs.
  _.matcher = _.matches = function(attrs) {
    attrs = _.extendOwn({}, attrs);
    return function(obj) {
      return _.isMatch(obj, attrs);
    };
  };

  // Run a function **n** times.
  _.times = function(n, iteratee, context) {
    var accum = Array(Math.max(0, n));
    iteratee = optimizeCb(iteratee, context, 1);
    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // A (possibly faster) way to get the current timestamp as an integer.
  _.now = Date.now || function() {
    return new Date().getTime();
  };

   // List of HTML entities for escaping.
  var escapeMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#x27;',
    '`': '&#x60;'
  };
  var unescapeMap = _.invert(escapeMap);

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  var createEscaper = function(map) {
    var escaper = function(match) {
      return map[match];
    };
    // Regexes for identifying a key that needs to be escaped
    var source = '(?:' + _.keys(map).join('|') + ')';
    var testRegexp = RegExp(source);
    var replaceRegexp = RegExp(source, 'g');
    return function(string) {
      string = string == null ? '' : '' + string;
      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
    };
  };
  _.escape = createEscaper(escapeMap);
  _.unescape = createEscaper(unescapeMap);

  // If the value of the named `property` is a function then invoke it with the
  // `object` as context; otherwise, return it.
  _.result = function(object, property, fallback) {
    var value = object == null ? void 0 : object[property];
    if (value === void 0) {
      value = fallback;
    }
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'":      "'",
    '\\':     '\\',
    '\r':     'r',
    '\n':     'n',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escaper = /\\|'|\r|\n|\u2028|\u2029/g;

  var escapeChar = function(match) {
    return '\\' + escapes[match];
  };

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  // NB: `oldSettings` only exists for backwards compatibility.
  _.template = function(text, settings, oldSettings) {
    if (!settings && oldSettings) settings = oldSettings;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset).replace(escaper, escapeChar);
      index = offset + match.length;

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      } else if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      } else if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }

      // Adobe VMs need the match returned to produce the correct offest.
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + 'return __p;\n';

    try {
      var render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled source as a convenience for precompilation.
    var argument = settings.variable || 'obj';
    template.source = 'function(' + argument + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function. Start chaining a wrapped Underscore object.
  _.chain = function(obj) {
    var instance = _(obj);
    instance._chain = true;
    return instance;
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var result = function(instance, obj) {
    return instance._chain ? _(obj).chain() : obj;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    _.each(_.functions(obj), function(name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result(this, func.apply(_, args));
      };
    });
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
      return result(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  _.each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return result(this, method.apply(this._wrapped, arguments));
    };
  });

  // Extracts the result from a wrapped and chained object.
  _.prototype.value = function() {
    return this._wrapped;
  };

  // Provide unwrapping proxy for some methods used in engine operations
  // such as arithmetic and JSON stringification.
  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;

  _.prototype.toString = function() {
    return '' + this._wrapped;
  };

  // AMD registration happens at the end for compatibility with AMD loaders
  // that may not enforce next-turn semantics on modules. Even though general
  // practice for AMD registration is to be anonymous, underscore registers
  // as a named module because, like jQuery, it is a base library that is
  // popular enough to be bundled in a third party lib, but not be part of
  // an AMD load request. Those cases could generate an error when an
  // anonymous define() is called outside of a loader request.
  if (typeof define === 'function' && define.amd) {
    define('underscore', [], function() {
      return _;
    });
  }
}.call(this));

},{}],735:[function(require,module,exports){
module.exports = function isBuffer(arg) {
  return arg && typeof arg === 'object'
    && typeof arg.copy === 'function'
    && typeof arg.fill === 'function'
    && typeof arg.readUInt8 === 'function';
}
},{}],736:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

var formatRegExp = /%[sdj%]/g;
exports.format = function(f) {
  if (!isString(f)) {
    var objects = [];
    for (var i = 0; i < arguments.length; i++) {
      objects.push(inspect(arguments[i]));
    }
    return objects.join(' ');
  }

  var i = 1;
  var args = arguments;
  var len = args.length;
  var str = String(f).replace(formatRegExp, function(x) {
    if (x === '%%') return '%';
    if (i >= len) return x;
    switch (x) {
      case '%s': return String(args[i++]);
      case '%d': return Number(args[i++]);
      case '%j':
        try {
          return JSON.stringify(args[i++]);
        } catch (_) {
          return '[Circular]';
        }
      default:
        return x;
    }
  });
  for (var x = args[i]; i < len; x = args[++i]) {
    if (isNull(x) || !isObject(x)) {
      str += ' ' + x;
    } else {
      str += ' ' + inspect(x);
    }
  }
  return str;
};


// Mark that a method should not be used.
// Returns a modified function which warns once by default.
// If --no-deprecation is set, then it is a no-op.
exports.deprecate = function(fn, msg) {
  // Allow for deprecating things in the process of starting up.
  if (isUndefined(global.process)) {
    return function() {
      return exports.deprecate(fn, msg).apply(this, arguments);
    };
  }

  if (process.noDeprecation === true) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (process.throwDeprecation) {
        throw new Error(msg);
      } else if (process.traceDeprecation) {
        console.trace(msg);
      } else {
        console.error(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
};


var debugs = {};
var debugEnviron;
exports.debuglog = function(set) {
  if (isUndefined(debugEnviron))
    debugEnviron = process.env.NODE_DEBUG || '';
  set = set.toUpperCase();
  if (!debugs[set]) {
    if (new RegExp('\\b' + set + '\\b', 'i').test(debugEnviron)) {
      var pid = process.pid;
      debugs[set] = function() {
        var msg = exports.format.apply(exports, arguments);
        console.error('%s %d: %s', set, pid, msg);
      };
    } else {
      debugs[set] = function() {};
    }
  }
  return debugs[set];
};


/**
 * Echos the value of a value. Trys to print the value out
 * in the best way possible given the different types.
 *
 * @param {Object} obj The object to print out.
 * @param {Object} opts Optional options object that alters the output.
 */
/* legacy: obj, showHidden, depth, colors*/
function inspect(obj, opts) {
  // default options
  var ctx = {
    seen: [],
    stylize: stylizeNoColor
  };
  // legacy...
  if (arguments.length >= 3) ctx.depth = arguments[2];
  if (arguments.length >= 4) ctx.colors = arguments[3];
  if (isBoolean(opts)) {
    // legacy...
    ctx.showHidden = opts;
  } else if (opts) {
    // got an "options" object
    exports._extend(ctx, opts);
  }
  // set default options
  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;
  if (isUndefined(ctx.depth)) ctx.depth = 2;
  if (isUndefined(ctx.colors)) ctx.colors = false;
  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;
  if (ctx.colors) ctx.stylize = stylizeWithColor;
  return formatValue(ctx, obj, ctx.depth);
}
exports.inspect = inspect;


// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics
inspect.colors = {
  'bold' : [1, 22],
  'italic' : [3, 23],
  'underline' : [4, 24],
  'inverse' : [7, 27],
  'white' : [37, 39],
  'grey' : [90, 39],
  'black' : [30, 39],
  'blue' : [34, 39],
  'cyan' : [36, 39],
  'green' : [32, 39],
  'magenta' : [35, 39],
  'red' : [31, 39],
  'yellow' : [33, 39]
};

// Don't use 'blue' not visible on cmd.exe
inspect.styles = {
  'special': 'cyan',
  'number': 'yellow',
  'boolean': 'yellow',
  'undefined': 'grey',
  'null': 'bold',
  'string': 'green',
  'date': 'magenta',
  // "name": intentionally not styling
  'regexp': 'red'
};


function stylizeWithColor(str, styleType) {
  var style = inspect.styles[styleType];

  if (style) {
    return '\u001b[' + inspect.colors[style][0] + 'm' + str +
           '\u001b[' + inspect.colors[style][1] + 'm';
  } else {
    return str;
  }
}


function stylizeNoColor(str, styleType) {
  return str;
}


function arrayToHash(array) {
  var hash = {};

  array.forEach(function(val, idx) {
    hash[val] = true;
  });

  return hash;
}


function formatValue(ctx, value, recurseTimes) {
  // Provide a hook for user-specified inspect functions.
  // Check that value is an object with an inspect function on it
  if (ctx.customInspect &&
      value &&
      isFunction(value.inspect) &&
      // Filter out the util module, it's inspect function is special
      value.inspect !== exports.inspect &&
      // Also filter out any prototype objects using the circular check.
      !(value.constructor && value.constructor.prototype === value)) {
    var ret = value.inspect(recurseTimes, ctx);
    if (!isString(ret)) {
      ret = formatValue(ctx, ret, recurseTimes);
    }
    return ret;
  }

  // Primitive types cannot have properties
  var primitive = formatPrimitive(ctx, value);
  if (primitive) {
    return primitive;
  }

  // Look up the keys of the object.
  var keys = Object.keys(value);
  var visibleKeys = arrayToHash(keys);

  if (ctx.showHidden) {
    keys = Object.getOwnPropertyNames(value);
  }

  // IE doesn't make error fields non-enumerable
  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx
  if (isError(value)
      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {
    return formatError(value);
  }

  // Some type of object without properties can be shortcutted.
  if (keys.length === 0) {
    if (isFunction(value)) {
      var name = value.name ? ': ' + value.name : '';
      return ctx.stylize('[Function' + name + ']', 'special');
    }
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    }
    if (isDate(value)) {
      return ctx.stylize(Date.prototype.toString.call(value), 'date');
    }
    if (isError(value)) {
      return formatError(value);
    }
  }

  var base = '', array = false, braces = ['{', '}'];

  // Make Array say that they are Array
  if (isArray(value)) {
    array = true;
    braces = ['[', ']'];
  }

  // Make functions say that they are functions
  if (isFunction(value)) {
    var n = value.name ? ': ' + value.name : '';
    base = ' [Function' + n + ']';
  }

  // Make RegExps say that they are RegExps
  if (isRegExp(value)) {
    base = ' ' + RegExp.prototype.toString.call(value);
  }

  // Make dates with properties first say the date
  if (isDate(value)) {
    base = ' ' + Date.prototype.toUTCString.call(value);
  }

  // Make error with message first say the error
  if (isError(value)) {
    base = ' ' + formatError(value);
  }

  if (keys.length === 0 && (!array || value.length == 0)) {
    return braces[0] + base + braces[1];
  }

  if (recurseTimes < 0) {
    if (isRegExp(value)) {
      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');
    } else {
      return ctx.stylize('[Object]', 'special');
    }
  }

  ctx.seen.push(value);

  var output;
  if (array) {
    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);
  } else {
    output = keys.map(function(key) {
      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);
    });
  }

  ctx.seen.pop();

  return reduceToSingleString(output, base, braces);
}


function formatPrimitive(ctx, value) {
  if (isUndefined(value))
    return ctx.stylize('undefined', 'undefined');
  if (isString(value)) {
    var simple = '\'' + JSON.stringify(value).replace(/^"|"$/g, '')
                                             .replace(/'/g, "\\'")
                                             .replace(/\\"/g, '"') + '\'';
    return ctx.stylize(simple, 'string');
  }
  if (isNumber(value))
    return ctx.stylize('' + value, 'number');
  if (isBoolean(value))
    return ctx.stylize('' + value, 'boolean');
  // For some reason typeof null is "object", so special case here.
  if (isNull(value))
    return ctx.stylize('null', 'null');
}


function formatError(value) {
  return '[' + Error.prototype.toString.call(value) + ']';
}


function formatArray(ctx, value, recurseTimes, visibleKeys, keys) {
  var output = [];
  for (var i = 0, l = value.length; i < l; ++i) {
    if (hasOwnProperty(value, String(i))) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          String(i), true));
    } else {
      output.push('');
    }
  }
  keys.forEach(function(key) {
    if (!key.match(/^\d+$/)) {
      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,
          key, true));
    }
  });
  return output;
}


function formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {
  var name, str, desc;
  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };
  if (desc.get) {
    if (desc.set) {
      str = ctx.stylize('[Getter/Setter]', 'special');
    } else {
      str = ctx.stylize('[Getter]', 'special');
    }
  } else {
    if (desc.set) {
      str = ctx.stylize('[Setter]', 'special');
    }
  }
  if (!hasOwnProperty(visibleKeys, key)) {
    name = '[' + key + ']';
  }
  if (!str) {
    if (ctx.seen.indexOf(desc.value) < 0) {
      if (isNull(recurseTimes)) {
        str = formatValue(ctx, desc.value, null);
      } else {
        str = formatValue(ctx, desc.value, recurseTimes - 1);
      }
      if (str.indexOf('\n') > -1) {
        if (array) {
          str = str.split('\n').map(function(line) {
            return '  ' + line;
          }).join('\n').substr(2);
        } else {
          str = '\n' + str.split('\n').map(function(line) {
            return '   ' + line;
          }).join('\n');
        }
      }
    } else {
      str = ctx.stylize('[Circular]', 'special');
    }
  }
  if (isUndefined(name)) {
    if (array && key.match(/^\d+$/)) {
      return str;
    }
    name = JSON.stringify('' + key);
    if (name.match(/^"([a-zA-Z_][a-zA-Z_0-9]*)"$/)) {
      name = name.substr(1, name.length - 2);
      name = ctx.stylize(name, 'name');
    } else {
      name = name.replace(/'/g, "\\'")
                 .replace(/\\"/g, '"')
                 .replace(/(^"|"$)/g, "'");
      name = ctx.stylize(name, 'string');
    }
  }

  return name + ': ' + str;
}


function reduceToSingleString(output, base, braces) {
  var numLinesEst = 0;
  var length = output.reduce(function(prev, cur) {
    numLinesEst++;
    if (cur.indexOf('\n') >= 0) numLinesEst++;
    return prev + cur.replace(/\u001b\[\d\d?m/g, '').length + 1;
  }, 0);

  if (length > 60) {
    return braces[0] +
           (base === '' ? '' : base + '\n ') +
           ' ' +
           output.join(',\n  ') +
           ' ' +
           braces[1];
  }

  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];
}


// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.
function isArray(ar) {
  return Array.isArray(ar);
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return isObject(re) && objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return isObject(d) && objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return isObject(e) &&
      (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = require('./support/isBuffer');

function objectToString(o) {
  return Object.prototype.toString.call(o);
}


function pad(n) {
  return n < 10 ? '0' + n.toString(10) : n.toString(10);
}


var months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',
              'Oct', 'Nov', 'Dec'];

// 26 Feb 16:19:34
function timestamp() {
  var d = new Date();
  var time = [pad(d.getHours()),
              pad(d.getMinutes()),
              pad(d.getSeconds())].join(':');
  return [d.getDate(), months[d.getMonth()], time].join(' ');
}


// log is just a thin wrapper to console.log that prepends a timestamp
exports.log = function() {
  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));
};


/**
 * Inherit the prototype methods from one constructor into another.
 *
 * The Function.prototype.inherits from lang.js rewritten as a standalone
 * function (not on Function.prototype). NOTE: If this file is to be loaded
 * during bootstrapping this function needs to be rewritten using some native
 * functions as prototype setup using normal JavaScript does not work as
 * expected during bootstrapping (see mirror.js in r114903).
 *
 * @param {function} ctor Constructor function which needs to inherit the
 *     prototype.
 * @param {function} superCtor Constructor function to inherit prototype from.
 */
exports.inherits = require('inherits');

exports._extend = function(origin, add) {
  // Don't do anything if add isn't an object
  if (!add || !isObject(add)) return origin;

  var keys = Object.keys(add);
  var i = keys.length;
  while (i--) {
    origin[keys[i]] = add[keys[i]];
  }
  return origin;
};

function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"./support/isBuffer":735,"_process":680,"inherits":564}],737:[function(require,module,exports){
/*
 * UUID-js: A js library to generate and parse UUIDs, TimeUUIDs and generate
 * TimeUUID based on dates for range selections.
 * @see http://www.ietf.org/rfc/rfc4122.txt
 **/

function UUIDjs() {
};

UUIDjs.maxFromBits = function(bits) {
  return Math.pow(2, bits);
};

UUIDjs.limitUI04 = UUIDjs.maxFromBits(4);
UUIDjs.limitUI06 = UUIDjs.maxFromBits(6);
UUIDjs.limitUI08 = UUIDjs.maxFromBits(8);
UUIDjs.limitUI12 = UUIDjs.maxFromBits(12);
UUIDjs.limitUI14 = UUIDjs.maxFromBits(14);
UUIDjs.limitUI16 = UUIDjs.maxFromBits(16);
UUIDjs.limitUI32 = UUIDjs.maxFromBits(32);
UUIDjs.limitUI40 = UUIDjs.maxFromBits(40);
UUIDjs.limitUI48 = UUIDjs.maxFromBits(48);

// Returns a random integer between min and max
// Using Math.round() will give you a non-uniform distribution!
// @see https://developer.mozilla.org/en-US/docs/JavaScript/Reference/Global_Objects/Math/random
function getRandomInt(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}

UUIDjs.randomUI04 = function() {
  return getRandomInt(0, UUIDjs.limitUI04-1);
};
UUIDjs.randomUI06 = function() {
  return getRandomInt(0, UUIDjs.limitUI06-1);
};
UUIDjs.randomUI08 = function() {
  return getRandomInt(0, UUIDjs.limitUI08-1);
};
UUIDjs.randomUI12 = function() {
  return getRandomInt(0, UUIDjs.limitUI12-1);
};
UUIDjs.randomUI14 = function() {
  return getRandomInt(0, UUIDjs.limitUI14-1);
};
UUIDjs.randomUI16 = function() {
  return getRandomInt(0, UUIDjs.limitUI16-1);
};
UUIDjs.randomUI32 = function() {
  return getRandomInt(0, UUIDjs.limitUI32-1);
};
UUIDjs.randomUI40 = function() {
  return (0 | Math.random() * (1 << 30)) + (0 | Math.random() * (1 << 40 - 30)) * (1 << 30);
};
UUIDjs.randomUI48 = function() {
  return (0 | Math.random() * (1 << 30)) + (0 | Math.random() * (1 << 48 - 30)) * (1 << 30);
};

UUIDjs.paddedString = function(string, length, z) {
  string = String(string);
  z = (!z) ? '0' : z;
  var i = length - string.length;
  for (; i > 0; i >>>= 1, z += z) {
    if (i & 1) {
      string = z + string;
    }
  }
  return string;
};

UUIDjs.prototype.fromParts = function(timeLow, timeMid, timeHiAndVersion, clockSeqHiAndReserved, clockSeqLow, node) {
  this.version = (timeHiAndVersion >> 12) & 0xF;
  this.hex = UUIDjs.paddedString(timeLow.toString(16), 8)
             + '-'
             + UUIDjs.paddedString(timeMid.toString(16), 4)
             + '-'
             + UUIDjs.paddedString(timeHiAndVersion.toString(16), 4)
             + '-'
             + UUIDjs.paddedString(clockSeqHiAndReserved.toString(16), 2)
             + UUIDjs.paddedString(clockSeqLow.toString(16), 2)
             + '-'
             + UUIDjs.paddedString(node.toString(16), 12);
  return this;
};

UUIDjs.prototype.toString = function() {
  return this.hex;
};
UUIDjs.prototype.toURN = function() {
  return 'urn:uuid:' + this.hex;
};

UUIDjs.prototype.toBytes = function() {
  var parts = this.hex.split('-');
  var ints = [];
  var intPos = 0;
  for (var i = 0; i < parts.length; i++) {
    for (var j = 0; j < parts[i].length; j+=2) {
      ints[intPos++] = parseInt(parts[i].substr(j, 2), 16);
    }
  }
  return ints;
};

UUIDjs.prototype.equals = function(uuid) {
  if (!(uuid instanceof UUID)) {
    return false;
  }
  if (this.hex !== uuid.hex) {
    return false;
  }
  return true;
};

UUIDjs.getTimeFieldValues = function(time) {
  var ts = time - Date.UTC(1582, 9, 15);
  var hm = ((ts / 0x100000000) * 10000) & 0xFFFFFFF;
  return { low: ((ts & 0xFFFFFFF) * 10000) % 0x100000000,
            mid: hm & 0xFFFF, hi: hm >>> 16, timestamp: ts };
};

UUIDjs._create4 = function() {
  return new UUIDjs().fromParts(
    UUIDjs.randomUI32(),
    UUIDjs.randomUI16(),
    0x4000 | UUIDjs.randomUI12(),
    0x80   | UUIDjs.randomUI06(),
    UUIDjs.randomUI08(),
    UUIDjs.randomUI48()
  );
};

UUIDjs._create1 = function() {
  var now = new Date().getTime();
  var sequence = UUIDjs.randomUI14();
  var node = (UUIDjs.randomUI08() | 1) * 0x10000000000 + UUIDjs.randomUI40();
  var tick = UUIDjs.randomUI04();
  var timestamp = 0;
  var timestampRatio = 1/4;

  if (now != timestamp) {
    if (now < timestamp) {
      sequence++;
    }
    timestamp = now;
    tick = UUIDjs.randomUI04();
  } else if (Math.random() < timestampRatio && tick < 9984) {
    tick += 1 + UUIDjs.randomUI04();
  } else {
    sequence++;
  }

  var tf = UUIDjs.getTimeFieldValues(timestamp);
  var tl = tf.low + tick;
  var thav = (tf.hi & 0xFFF) | 0x1000;

  sequence &= 0x3FFF;
  var cshar = (sequence >>> 8) | 0x80;
  var csl = sequence & 0xFF;

  return new UUIDjs().fromParts(tl, tf.mid, thav, cshar, csl, node);
};

UUIDjs.create = function(version) {
  version = version || 4;
  return this['_create' + version]();
};

UUIDjs.fromTime = function(time, last) {
  last = (!last) ? false : last;
  var tf = UUIDjs.getTimeFieldValues(time);
  var tl = tf.low;
  var thav = (tf.hi & 0xFFF) | 0x1000;  // set version '0001'
  if (last === false) {
    return new UUIDjs().fromParts(tl, tf.mid, thav, 0, 0, 0);
  } else {
    return new UUIDjs().fromParts(tl, tf.mid, thav, 0x80 | UUIDjs.limitUI06, UUIDjs.limitUI08 - 1, UUIDjs.limitUI48 - 1);
  }
};

UUIDjs.firstFromTime = function(time) {
  return UUIDjs.fromTime(time, false);
};
UUIDjs.lastFromTime = function(time) {
  return UUIDjs.fromTime(time, true);
};

UUIDjs.fromURN = function(strId) {
  var r, p = /^(?:urn:uuid:|\{)?([0-9a-f]{8})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{2})([0-9a-f]{2})-([0-9a-f]{12})(?:\})?$/i;
  if ((r = p.exec(strId))) {
    return new UUIDjs().fromParts(parseInt(r[1], 16), parseInt(r[2], 16),
                            parseInt(r[3], 16), parseInt(r[4], 16),
                            parseInt(r[5], 16), parseInt(r[6], 16));
  }
  return null;
};

UUIDjs.fromBytes = function(ints) {
  if (ints.length < 5) {
    return null;
  }
  var str = '';
  var pos = 0;
  var parts = [4, 2, 2, 2, 6];
  for (var i = 0; i < parts.length; i++) {
    for (var j = 0; j < parts[i]; j++) {
      var octet = ints[pos++].toString(16);
      if (octet.length == 1) {
        octet = '0' + octet;
      }
      str += octet;
    }
    if (parts[i] !== 6) {
      str += '-';
    }
  }
  return UUIDjs.fromURN(str);
};

UUIDjs.fromBinary = function(binary) {
  var ints = [];
  for (var i = 0; i < binary.length; i++) {
    ints[i] = binary.charCodeAt(i);
    if (ints[i] > 255 || ints[i] < 0) {
      throw new Error('Unexpected byte in binary data.');
    }
  }
  return UUIDjs.fromBytes(ints);
};

// Aliases to support legacy code. Do not use these when writing new code as
// they may be removed in future versions!
UUIDjs.new = function() {
  return this.create(4);
};
UUIDjs.newTS = function() {
  return this.create(1);
};

module.exports = UUIDjs;

},{}],738:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function (require) {

	var makePromise = require('./makePromise');
	var Scheduler = require('./Scheduler');
	var async = require('./env').asap;

	return makePromise({
		scheduler: new Scheduler(async)
	});

});
})(typeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); });

},{"./Scheduler":739,"./env":751,"./makePromise":754}],739:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	// Credit to Twisol (https://github.com/Twisol) for suggesting
	// this type of extensible queue + trampoline approach for next-tick conflation.

	/**
	 * Async task scheduler
	 * @param {function} async function to schedule a single async function
	 * @constructor
	 */
	function Scheduler(async) {
		this._async = async;
		this._running = false;

		this._queue = this;
		this._queueLen = 0;
		this._afterQueue = {};
		this._afterQueueLen = 0;

		var self = this;
		this.drain = function() {
			self._drain();
		};
	}

	/**
	 * Enqueue a task
	 * @param {{ run:function }} task
	 */
	Scheduler.prototype.enqueue = function(task) {
		this._queue[this._queueLen++] = task;
		this.run();
	};

	/**
	 * Enqueue a task to run after the main task queue
	 * @param {{ run:function }} task
	 */
	Scheduler.prototype.afterQueue = function(task) {
		this._afterQueue[this._afterQueueLen++] = task;
		this.run();
	};

	Scheduler.prototype.run = function() {
		if (!this._running) {
			this._running = true;
			this._async(this.drain);
		}
	};

	/**
	 * Drain the handler queue entirely, and then the after queue
	 */
	Scheduler.prototype._drain = function() {
		var i = 0;
		for (; i < this._queueLen; ++i) {
			this._queue[i].run();
			this._queue[i] = void 0;
		}

		this._queueLen = 0;
		this._running = false;

		for (i = 0; i < this._afterQueueLen; ++i) {
			this._afterQueue[i].run();
			this._afterQueue[i] = void 0;
		}

		this._afterQueueLen = 0;
	};

	return Scheduler;

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));

},{}],740:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	/**
	 * Custom error type for promises rejected by promise.timeout
	 * @param {string} message
	 * @constructor
	 */
	function TimeoutError (message) {
		Error.call(this);
		this.message = message;
		this.name = TimeoutError.name;
		if (typeof Error.captureStackTrace === 'function') {
			Error.captureStackTrace(this, TimeoutError);
		}
	}

	TimeoutError.prototype = Object.create(Error.prototype);
	TimeoutError.prototype.constructor = TimeoutError;

	return TimeoutError;
});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));
},{}],741:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	makeApply.tryCatchResolve = tryCatchResolve;

	return makeApply;

	function makeApply(Promise, call) {
		if(arguments.length < 2) {
			call = tryCatchResolve;
		}

		return apply;

		function apply(f, thisArg, args) {
			var p = Promise._defer();
			var l = args.length;
			var params = new Array(l);
			callAndResolve({ f:f, thisArg:thisArg, args:args, params:params, i:l-1, call:call }, p._handler);

			return p;
		}

		function callAndResolve(c, h) {
			if(c.i < 0) {
				return call(c.f, c.thisArg, c.params, h);
			}

			var handler = Promise._handler(c.args[c.i]);
			handler.fold(callAndResolveNext, c, void 0, h);
		}

		function callAndResolveNext(c, x, h) {
			c.params[c.i] = x;
			c.i -= 1;
			callAndResolve(c, h);
		}
	}

	function tryCatchResolve(f, thisArg, args, resolver) {
		try {
			resolver.resolve(f.apply(thisArg, args));
		} catch(e) {
			resolver.reject(e);
		}
	}

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));



},{}],742:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function(require) {

	var state = require('../state');
	var applier = require('../apply');

	return function array(Promise) {

		var applyFold = applier(Promise);
		var toPromise = Promise.resolve;
		var all = Promise.all;

		var ar = Array.prototype.reduce;
		var arr = Array.prototype.reduceRight;
		var slice = Array.prototype.slice;

		// Additional array combinators

		Promise.any = any;
		Promise.some = some;
		Promise.settle = settle;

		Promise.map = map;
		Promise.filter = filter;
		Promise.reduce = reduce;
		Promise.reduceRight = reduceRight;

		/**
		 * When this promise fulfills with an array, do
		 * onFulfilled.apply(void 0, array)
		 * @param {function} onFulfilled function to apply
		 * @returns {Promise} promise for the result of applying onFulfilled
		 */
		Promise.prototype.spread = function(onFulfilled) {
			return this.then(all).then(function(array) {
				return onFulfilled.apply(this, array);
			});
		};

		return Promise;

		/**
		 * One-winner competitive race.
		 * Return a promise that will fulfill when one of the promises
		 * in the input array fulfills, or will reject when all promises
		 * have rejected.
		 * @param {array} promises
		 * @returns {Promise} promise for the first fulfilled value
		 */
		function any(promises) {
			var p = Promise._defer();
			var resolver = p._handler;
			var l = promises.length>>>0;

			var pending = l;
			var errors = [];

			for (var h, x, i = 0; i < l; ++i) {
				x = promises[i];
				if(x === void 0 && !(i in promises)) {
					--pending;
					continue;
				}

				h = Promise._handler(x);
				if(h.state() > 0) {
					resolver.become(h);
					Promise._visitRemaining(promises, i, h);
					break;
				} else {
					h.visit(resolver, handleFulfill, handleReject);
				}
			}

			if(pending === 0) {
				resolver.reject(new RangeError('any(): array must not be empty'));
			}

			return p;

			function handleFulfill(x) {
				/*jshint validthis:true*/
				errors = null;
				this.resolve(x); // this === resolver
			}

			function handleReject(e) {
				/*jshint validthis:true*/
				if(this.resolved) { // this === resolver
					return;
				}

				errors.push(e);
				if(--pending === 0) {
					this.reject(errors);
				}
			}
		}

		/**
		 * N-winner competitive race
		 * Return a promise that will fulfill when n input promises have
		 * fulfilled, or will reject when it becomes impossible for n
		 * input promises to fulfill (ie when promises.length - n + 1
		 * have rejected)
		 * @param {array} promises
		 * @param {number} n
		 * @returns {Promise} promise for the earliest n fulfillment values
		 *
		 * @deprecated
		 */
		function some(promises, n) {
			/*jshint maxcomplexity:7*/
			var p = Promise._defer();
			var resolver = p._handler;

			var results = [];
			var errors = [];

			var l = promises.length>>>0;
			var nFulfill = 0;
			var nReject;
			var x, i; // reused in both for() loops

			// First pass: count actual array items
			for(i=0; i<l; ++i) {
				x = promises[i];
				if(x === void 0 && !(i in promises)) {
					continue;
				}
				++nFulfill;
			}

			// Compute actual goals
			n = Math.max(n, 0);
			nReject = (nFulfill - n + 1);
			nFulfill = Math.min(n, nFulfill);

			if(n > nFulfill) {
				resolver.reject(new RangeError('some(): array must contain at least '
				+ n + ' item(s), but had ' + nFulfill));
			} else if(nFulfill === 0) {
				resolver.resolve(results);
			}

			// Second pass: observe each array item, make progress toward goals
			for(i=0; i<l; ++i) {
				x = promises[i];
				if(x === void 0 && !(i in promises)) {
					continue;
				}

				Promise._handler(x).visit(resolver, fulfill, reject, resolver.notify);
			}

			return p;

			function fulfill(x) {
				/*jshint validthis:true*/
				if(this.resolved) { // this === resolver
					return;
				}

				results.push(x);
				if(--nFulfill === 0) {
					errors = null;
					this.resolve(results);
				}
			}

			function reject(e) {
				/*jshint validthis:true*/
				if(this.resolved) { // this === resolver
					return;
				}

				errors.push(e);
				if(--nReject === 0) {
					results = null;
					this.reject(errors);
				}
			}
		}

		/**
		 * Apply f to the value of each promise in a list of promises
		 * and return a new list containing the results.
		 * @param {array} promises
		 * @param {function(x:*, index:Number):*} f mapping function
		 * @returns {Promise}
		 */
		function map(promises, f) {
			return Promise._traverse(f, promises);
		}

		/**
		 * Filter the provided array of promises using the provided predicate.  Input may
		 * contain promises and values
		 * @param {Array} promises array of promises and values
		 * @param {function(x:*, index:Number):boolean} predicate filtering predicate.
		 *  Must return truthy (or promise for truthy) for items to retain.
		 * @returns {Promise} promise that will fulfill with an array containing all items
		 *  for which predicate returned truthy.
		 */
		function filter(promises, predicate) {
			var a = slice.call(promises);
			return Promise._traverse(predicate, a).then(function(keep) {
				return filterSync(a, keep);
			});
		}

		function filterSync(promises, keep) {
			// Safe because we know all promises have fulfilled if we've made it this far
			var l = keep.length;
			var filtered = new Array(l);
			for(var i=0, j=0; i<l; ++i) {
				if(keep[i]) {
					filtered[j++] = Promise._handler(promises[i]).value;
				}
			}
			filtered.length = j;
			return filtered;

		}

		/**
		 * Return a promise that will always fulfill with an array containing
		 * the outcome states of all input promises.  The returned promise
		 * will never reject.
		 * @param {Array} promises
		 * @returns {Promise} promise for array of settled state descriptors
		 */
		function settle(promises) {
			return all(promises.map(settleOne));
		}

		function settleOne(p) {
			var h = Promise._handler(p);
			if(h.state() === 0) {
				return toPromise(p).then(state.fulfilled, state.rejected);
			}

			h._unreport();
			return state.inspect(h);
		}

		/**
		 * Traditional reduce function, similar to `Array.prototype.reduce()`, but
		 * input may contain promises and/or values, and reduceFunc
		 * may return either a value or a promise, *and* initialValue may
		 * be a promise for the starting value.
		 * @param {Array|Promise} promises array or promise for an array of anything,
		 *      may contain a mix of promises and values.
		 * @param {function(accumulated:*, x:*, index:Number):*} f reduce function
		 * @returns {Promise} that will resolve to the final reduced value
		 */
		function reduce(promises, f /*, initialValue */) {
			return arguments.length > 2 ? ar.call(promises, liftCombine(f), arguments[2])
					: ar.call(promises, liftCombine(f));
		}

		/**
		 * Traditional reduce function, similar to `Array.prototype.reduceRight()`, but
		 * input may contain promises and/or values, and reduceFunc
		 * may return either a value or a promise, *and* initialValue may
		 * be a promise for the starting value.
		 * @param {Array|Promise} promises array or promise for an array of anything,
		 *      may contain a mix of promises and values.
		 * @param {function(accumulated:*, x:*, index:Number):*} f reduce function
		 * @returns {Promise} that will resolve to the final reduced value
		 */
		function reduceRight(promises, f /*, initialValue */) {
			return arguments.length > 2 ? arr.call(promises, liftCombine(f), arguments[2])
					: arr.call(promises, liftCombine(f));
		}

		function liftCombine(f) {
			return function(z, x, i) {
				return applyFold(f, void 0, [z,x,i]);
			};
		}
	};

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));

},{"../apply":741,"../state":755}],743:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	return function flow(Promise) {

		var resolve = Promise.resolve;
		var reject = Promise.reject;
		var origCatch = Promise.prototype['catch'];

		/**
		 * Handle the ultimate fulfillment value or rejection reason, and assume
		 * responsibility for all errors.  If an error propagates out of result
		 * or handleFatalError, it will be rethrown to the host, resulting in a
		 * loud stack track on most platforms and a crash on some.
		 * @param {function?} onResult
		 * @param {function?} onError
		 * @returns {undefined}
		 */
		Promise.prototype.done = function(onResult, onError) {
			this._handler.visit(this._handler.receiver, onResult, onError);
		};

		/**
		 * Add Error-type and predicate matching to catch.  Examples:
		 * promise.catch(TypeError, handleTypeError)
		 *   .catch(predicate, handleMatchedErrors)
		 *   .catch(handleRemainingErrors)
		 * @param onRejected
		 * @returns {*}
		 */
		Promise.prototype['catch'] = Promise.prototype.otherwise = function(onRejected) {
			if (arguments.length < 2) {
				return origCatch.call(this, onRejected);
			}

			if(typeof onRejected !== 'function') {
				return this.ensure(rejectInvalidPredicate);
			}

			return origCatch.call(this, createCatchFilter(arguments[1], onRejected));
		};

		/**
		 * Wraps the provided catch handler, so that it will only be called
		 * if the predicate evaluates truthy
		 * @param {?function} handler
		 * @param {function} predicate
		 * @returns {function} conditional catch handler
		 */
		function createCatchFilter(handler, predicate) {
			return function(e) {
				return evaluatePredicate(e, predicate)
					? handler.call(this, e)
					: reject(e);
			};
		}

		/**
		 * Ensures that onFulfilledOrRejected will be called regardless of whether
		 * this promise is fulfilled or rejected.  onFulfilledOrRejected WILL NOT
		 * receive the promises' value or reason.  Any returned value will be disregarded.
		 * onFulfilledOrRejected may throw or return a rejected promise to signal
		 * an additional error.
		 * @param {function} handler handler to be called regardless of
		 *  fulfillment or rejection
		 * @returns {Promise}
		 */
		Promise.prototype['finally'] = Promise.prototype.ensure = function(handler) {
			if(typeof handler !== 'function') {
				return this;
			}

			return this.then(function(x) {
				return runSideEffect(handler, this, identity, x);
			}, function(e) {
				return runSideEffect(handler, this, reject, e);
			});
		};

		function runSideEffect (handler, thisArg, propagate, value) {
			var result = handler.call(thisArg);
			return maybeThenable(result)
				? propagateValue(result, propagate, value)
				: propagate(value);
		}

		function propagateValue (result, propagate, x) {
			return resolve(result).then(function () {
				return propagate(x);
			});
		}

		/**
		 * Recover from a failure by returning a defaultValue.  If defaultValue
		 * is a promise, it's fulfillment value will be used.  If defaultValue is
		 * a promise that rejects, the returned promise will reject with the
		 * same reason.
		 * @param {*} defaultValue
		 * @returns {Promise} new promise
		 */
		Promise.prototype['else'] = Promise.prototype.orElse = function(defaultValue) {
			return this.then(void 0, function() {
				return defaultValue;
			});
		};

		/**
		 * Shortcut for .then(function() { return value; })
		 * @param  {*} value
		 * @return {Promise} a promise that:
		 *  - is fulfilled if value is not a promise, or
		 *  - if value is a promise, will fulfill with its value, or reject
		 *    with its reason.
		 */
		Promise.prototype['yield'] = function(value) {
			return this.then(function() {
				return value;
			});
		};

		/**
		 * Runs a side effect when this promise fulfills, without changing the
		 * fulfillment value.
		 * @param {function} onFulfilledSideEffect
		 * @returns {Promise}
		 */
		Promise.prototype.tap = function(onFulfilledSideEffect) {
			return this.then(onFulfilledSideEffect)['yield'](this);
		};

		return Promise;
	};

	function rejectInvalidPredicate() {
		throw new TypeError('catch predicate must be a function');
	}

	function evaluatePredicate(e, predicate) {
		return isError(predicate) ? e instanceof predicate : predicate(e);
	}

	function isError(predicate) {
		return predicate === Error
			|| (predicate != null && predicate.prototype instanceof Error);
	}

	function maybeThenable(x) {
		return (typeof x === 'object' || typeof x === 'function') && x !== null;
	}

	function identity(x) {
		return x;
	}

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));

},{}],744:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */
/** @author Jeff Escalante */

(function(define) { 'use strict';
define(function() {

	return function fold(Promise) {

		Promise.prototype.fold = function(f, z) {
			var promise = this._beget();

			this._handler.fold(function(z, x, to) {
				Promise._handler(z).fold(function(x, z, to) {
					to.resolve(f.call(this, z, x));
				}, x, this, to);
			}, z, promise._handler.receiver, promise._handler);

			return promise;
		};

		return Promise;
	};

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));

},{}],745:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function(require) {

	var inspect = require('../state').inspect;

	return function inspection(Promise) {

		Promise.prototype.inspect = function() {
			return inspect(Promise._handler(this));
		};

		return Promise;
	};

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));

},{"../state":755}],746:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	return function generate(Promise) {

		var resolve = Promise.resolve;

		Promise.iterate = iterate;
		Promise.unfold = unfold;

		return Promise;

		/**
		 * @deprecated Use github.com/cujojs/most streams and most.iterate
		 * Generate a (potentially infinite) stream of promised values:
		 * x, f(x), f(f(x)), etc. until condition(x) returns true
		 * @param {function} f function to generate a new x from the previous x
		 * @param {function} condition function that, given the current x, returns
		 *  truthy when the iterate should stop
		 * @param {function} handler function to handle the value produced by f
		 * @param {*|Promise} x starting value, may be a promise
		 * @return {Promise} the result of the last call to f before
		 *  condition returns true
		 */
		function iterate(f, condition, handler, x) {
			return unfold(function(x) {
				return [x, f(x)];
			}, condition, handler, x);
		}

		/**
		 * @deprecated Use github.com/cujojs/most streams and most.unfold
		 * Generate a (potentially infinite) stream of promised values
		 * by applying handler(generator(seed)) iteratively until
		 * condition(seed) returns true.
		 * @param {function} unspool function that generates a [value, newSeed]
		 *  given a seed.
		 * @param {function} condition function that, given the current seed, returns
		 *  truthy when the unfold should stop
		 * @param {function} handler function to handle the value produced by unspool
		 * @param x {*|Promise} starting value, may be a promise
		 * @return {Promise} the result of the last value produced by unspool before
		 *  condition returns true
		 */
		function unfold(unspool, condition, handler, x) {
			return resolve(x).then(function(seed) {
				return resolve(condition(seed)).then(function(done) {
					return done ? seed : resolve(unspool(seed)).spread(next);
				});
			});

			function next(item, newSeed) {
				return resolve(handler(item)).then(function() {
					return unfold(unspool, condition, handler, newSeed);
				});
			}
		}
	};

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));

},{}],747:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	return function progress(Promise) {

		/**
		 * @deprecated
		 * Register a progress handler for this promise
		 * @param {function} onProgress
		 * @returns {Promise}
		 */
		Promise.prototype.progress = function(onProgress) {
			return this.then(void 0, void 0, onProgress);
		};

		return Promise;
	};

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));

},{}],748:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function(require) {

	var env = require('../env');
	var TimeoutError = require('../TimeoutError');

	function setTimeout(f, ms, x, y) {
		return env.setTimer(function() {
			f(x, y, ms);
		}, ms);
	}

	return function timed(Promise) {
		/**
		 * Return a new promise whose fulfillment value is revealed only
		 * after ms milliseconds
		 * @param {number} ms milliseconds
		 * @returns {Promise}
		 */
		Promise.prototype.delay = function(ms) {
			var p = this._beget();
			this._handler.fold(handleDelay, ms, void 0, p._handler);
			return p;
		};

		function handleDelay(ms, x, h) {
			setTimeout(resolveDelay, ms, x, h);
		}

		function resolveDelay(x, h) {
			h.resolve(x);
		}

		/**
		 * Return a new promise that rejects after ms milliseconds unless
		 * this promise fulfills earlier, in which case the returned promise
		 * fulfills with the same value.
		 * @param {number} ms milliseconds
		 * @param {Error|*=} reason optional rejection reason to use, defaults
		 *   to a TimeoutError if not provided
		 * @returns {Promise}
		 */
		Promise.prototype.timeout = function(ms, reason) {
			var p = this._beget();
			var h = p._handler;

			var t = setTimeout(onTimeout, ms, reason, p._handler);

			this._handler.visit(h,
				function onFulfill(x) {
					env.clearTimer(t);
					this.resolve(x); // this = h
				},
				function onReject(x) {
					env.clearTimer(t);
					this.reject(x); // this = h
				},
				h.notify);

			return p;
		};

		function onTimeout(reason, h, ms) {
			var e = typeof reason === 'undefined'
				? new TimeoutError('timed out after ' + ms + 'ms')
				: reason;
			h.reject(e);
		}

		return Promise;
	};

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));

},{"../TimeoutError":740,"../env":751}],749:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function(require) {

	var setTimer = require('../env').setTimer;
	var format = require('../format');

	return function unhandledRejection(Promise) {

		var logError = noop;
		var logInfo = noop;
		var localConsole;

		if(typeof console !== 'undefined') {
			// Alias console to prevent things like uglify's drop_console option from
			// removing console.log/error. Unhandled rejections fall into the same
			// category as uncaught exceptions, and build tools shouldn't silence them.
			localConsole = console;
			logError = typeof localConsole.error !== 'undefined'
				? function (e) { localConsole.error(e); }
				: function (e) { localConsole.log(e); };

			logInfo = typeof localConsole.info !== 'undefined'
				? function (e) { localConsole.info(e); }
				: function (e) { localConsole.log(e); };
		}

		Promise.onPotentiallyUnhandledRejection = function(rejection) {
			enqueue(report, rejection);
		};

		Promise.onPotentiallyUnhandledRejectionHandled = function(rejection) {
			enqueue(unreport, rejection);
		};

		Promise.onFatalRejection = function(rejection) {
			enqueue(throwit, rejection.value);
		};

		var tasks = [];
		var reported = [];
		var running = null;

		function report(r) {
			if(!r.handled) {
				reported.push(r);
				logError('Potentially unhandled rejection [' + r.id + '] ' + format.formatError(r.value));
			}
		}

		function unreport(r) {
			var i = reported.indexOf(r);
			if(i >= 0) {
				reported.splice(i, 1);
				logInfo('Handled previous rejection [' + r.id + '] ' + format.formatObject(r.value));
			}
		}

		function enqueue(f, x) {
			tasks.push(f, x);
			if(running === null) {
				running = setTimer(flush, 0);
			}
		}

		function flush() {
			running = null;
			while(tasks.length > 0) {
				tasks.shift()(tasks.shift());
			}
		}

		return Promise;
	};

	function throwit(e) {
		throw e;
	}

	function noop() {}

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));

},{"../env":751,"../format":752}],750:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	return function addWith(Promise) {
		/**
		 * Returns a promise whose handlers will be called with `this` set to
		 * the supplied receiver.  Subsequent promises derived from the
		 * returned promise will also have their handlers called with receiver
		 * as `this`. Calling `with` with undefined or no arguments will return
		 * a promise whose handlers will again be called in the usual Promises/A+
		 * way (no `this`) thus safely undoing any previous `with` in the
		 * promise chain.
		 *
		 * WARNING: Promises returned from `with`/`withThis` are NOT Promises/A+
		 * compliant, specifically violating 2.2.5 (http://promisesaplus.com/#point-41)
		 *
		 * @param {object} receiver `this` value for all handlers attached to
		 *  the returned promise.
		 * @returns {Promise}
		 */
		Promise.prototype['with'] = Promise.prototype.withThis = function(receiver) {
			var p = this._beget();
			var child = p._handler;
			child.receiver = receiver;
			this._handler.chain(child, receiver);
			return p;
		};

		return Promise;
	};

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));


},{}],751:[function(require,module,exports){
(function (process){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

/*global process,document,setTimeout,clearTimeout,MutationObserver,WebKitMutationObserver*/
(function(define) { 'use strict';
define(function(require) {
	/*jshint maxcomplexity:6*/

	// Sniff "best" async scheduling option
	// Prefer process.nextTick or MutationObserver, then check for
	// setTimeout, and finally vertx, since its the only env that doesn't
	// have setTimeout

	var MutationObs;
	var capturedSetTimeout = typeof setTimeout !== 'undefined' && setTimeout;

	// Default env
	var setTimer = function(f, ms) { return setTimeout(f, ms); };
	var clearTimer = function(t) { return clearTimeout(t); };
	var asap = function (f) { return capturedSetTimeout(f, 0); };

	// Detect specific env
	if (isNode()) { // Node
		asap = function (f) { return process.nextTick(f); };

	} else if (MutationObs = hasMutationObserver()) { // Modern browser
		asap = initMutationObserver(MutationObs);

	} else if (!capturedSetTimeout) { // vert.x
		var vertxRequire = require;
		var vertx = vertxRequire('vertx');
		setTimer = function (f, ms) { return vertx.setTimer(ms, f); };
		clearTimer = vertx.cancelTimer;
		asap = vertx.runOnLoop || vertx.runOnContext;
	}

	return {
		setTimer: setTimer,
		clearTimer: clearTimer,
		asap: asap
	};

	function isNode () {
		return typeof process !== 'undefined' &&
			Object.prototype.toString.call(process) === '[object process]';
	}

	function hasMutationObserver () {
		return (typeof MutationObserver === 'function' && MutationObserver) ||
			(typeof WebKitMutationObserver === 'function' && WebKitMutationObserver);
	}

	function initMutationObserver(MutationObserver) {
		var scheduled;
		var node = document.createTextNode('');
		var o = new MutationObserver(run);
		o.observe(node, { characterData: true });

		function run() {
			var f = scheduled;
			scheduled = void 0;
			f();
		}

		var i = 0;
		return function (f) {
			scheduled = f;
			node.data = (i ^= 1);
		};
	}
});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(require); }));

}).call(this,require('_process'))
},{"_process":680}],752:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	return {
		formatError: formatError,
		formatObject: formatObject,
		tryStringify: tryStringify
	};

	/**
	 * Format an error into a string.  If e is an Error and has a stack property,
	 * it's returned.  Otherwise, e is formatted using formatObject, with a
	 * warning added about e not being a proper Error.
	 * @param {*} e
	 * @returns {String} formatted string, suitable for output to developers
	 */
	function formatError(e) {
		var s = typeof e === 'object' && e !== null && (e.stack || e.message) ? e.stack || e.message : formatObject(e);
		return e instanceof Error ? s : s + ' (WARNING: non-Error used)';
	}

	/**
	 * Format an object, detecting "plain" objects and running them through
	 * JSON.stringify if possible.
	 * @param {Object} o
	 * @returns {string}
	 */
	function formatObject(o) {
		var s = String(o);
		if(s === '[object Object]' && typeof JSON !== 'undefined') {
			s = tryStringify(o, s);
		}
		return s;
	}

	/**
	 * Try to return the result of JSON.stringify(x).  If that fails, return
	 * defaultValue
	 * @param {*} x
	 * @param {*} defaultValue
	 * @returns {String|*} JSON.stringify(x) or defaultValue
	 */
	function tryStringify(x, defaultValue) {
		try {
			return JSON.stringify(x);
		} catch(e) {
			return defaultValue;
		}
	}

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));

},{}],753:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	return function liftAll(liftOne, combine, dst, src) {
		if(typeof combine === 'undefined') {
			combine = defaultCombine;
		}

		return Object.keys(src).reduce(function(dst, key) {
			var f = src[key];
			return typeof f === 'function' ? combine(dst, liftOne(f), key) : dst;
		}, typeof dst === 'undefined' ? defaultDst(src) : dst);
	};

	function defaultCombine(o, f, k) {
		o[k] = f;
		return o;
	}

	function defaultDst(src) {
		return typeof src === 'function' ? src.bind() : Object.create(src);
	}
});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));

},{}],754:[function(require,module,exports){
(function (process){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	return function makePromise(environment) {

		var tasks = environment.scheduler;
		var emitRejection = initEmitRejection();

		var objectCreate = Object.create ||
			function(proto) {
				function Child() {}
				Child.prototype = proto;
				return new Child();
			};

		/**
		 * Create a promise whose fate is determined by resolver
		 * @constructor
		 * @returns {Promise} promise
		 * @name Promise
		 */
		function Promise(resolver, handler) {
			this._handler = resolver === Handler ? handler : init(resolver);
		}

		/**
		 * Run the supplied resolver
		 * @param resolver
		 * @returns {Pending}
		 */
		function init(resolver) {
			var handler = new Pending();

			try {
				resolver(promiseResolve, promiseReject, promiseNotify);
			} catch (e) {
				promiseReject(e);
			}

			return handler;

			/**
			 * Transition from pre-resolution state to post-resolution state, notifying
			 * all listeners of the ultimate fulfillment or rejection
			 * @param {*} x resolution value
			 */
			function promiseResolve (x) {
				handler.resolve(x);
			}
			/**
			 * Reject this promise with reason, which will be used verbatim
			 * @param {Error|*} reason rejection reason, strongly suggested
			 *   to be an Error type
			 */
			function promiseReject (reason) {
				handler.reject(reason);
			}

			/**
			 * @deprecated
			 * Issue a progress event, notifying all progress listeners
			 * @param {*} x progress event payload to pass to all listeners
			 */
			function promiseNotify (x) {
				handler.notify(x);
			}
		}

		// Creation

		Promise.resolve = resolve;
		Promise.reject = reject;
		Promise.never = never;

		Promise._defer = defer;
		Promise._handler = getHandler;

		/**
		 * Returns a trusted promise. If x is already a trusted promise, it is
		 * returned, otherwise returns a new trusted Promise which follows x.
		 * @param  {*} x
		 * @return {Promise} promise
		 */
		function resolve(x) {
			return isPromise(x) ? x
				: new Promise(Handler, new Async(getHandler(x)));
		}

		/**
		 * Return a reject promise with x as its reason (x is used verbatim)
		 * @param {*} x
		 * @returns {Promise} rejected promise
		 */
		function reject(x) {
			return new Promise(Handler, new Async(new Rejected(x)));
		}

		/**
		 * Return a promise that remains pending forever
		 * @returns {Promise} forever-pending promise.
		 */
		function never() {
			return foreverPendingPromise; // Should be frozen
		}

		/**
		 * Creates an internal {promise, resolver} pair
		 * @private
		 * @returns {Promise}
		 */
		function defer() {
			return new Promise(Handler, new Pending());
		}

		// Transformation and flow control

		/**
		 * Transform this promise's fulfillment value, returning a new Promise
		 * for the transformed result.  If the promise cannot be fulfilled, onRejected
		 * is called with the reason.  onProgress *may* be called with updates toward
		 * this promise's fulfillment.
		 * @param {function=} onFulfilled fulfillment handler
		 * @param {function=} onRejected rejection handler
		 * @param {function=} onProgress @deprecated progress handler
		 * @return {Promise} new promise
		 */
		Promise.prototype.then = function(onFulfilled, onRejected, onProgress) {
			var parent = this._handler;
			var state = parent.join().state();

			if ((typeof onFulfilled !== 'function' && state > 0) ||
				(typeof onRejected !== 'function' && state < 0)) {
				// Short circuit: value will not change, simply share handler
				return new this.constructor(Handler, parent);
			}

			var p = this._beget();
			var child = p._handler;

			parent.chain(child, parent.receiver, onFulfilled, onRejected, onProgress);

			return p;
		};

		/**
		 * If this promise cannot be fulfilled due to an error, call onRejected to
		 * handle the error. Shortcut for .then(undefined, onRejected)
		 * @param {function?} onRejected
		 * @return {Promise}
		 */
		Promise.prototype['catch'] = function(onRejected) {
			return this.then(void 0, onRejected);
		};

		/**
		 * Creates a new, pending promise of the same type as this promise
		 * @private
		 * @returns {Promise}
		 */
		Promise.prototype._beget = function() {
			return begetFrom(this._handler, this.constructor);
		};

		function begetFrom(parent, Promise) {
			var child = new Pending(parent.receiver, parent.join().context);
			return new Promise(Handler, child);
		}

		// Array combinators

		Promise.all = all;
		Promise.race = race;
		Promise._traverse = traverse;

		/**
		 * Return a promise that will fulfill when all promises in the
		 * input array have fulfilled, or will reject when one of the
		 * promises rejects.
		 * @param {array} promises array of promises
		 * @returns {Promise} promise for array of fulfillment values
		 */
		function all(promises) {
			return traverseWith(snd, null, promises);
		}

		/**
		 * Array<Promise<X>> -> Promise<Array<f(X)>>
		 * @private
		 * @param {function} f function to apply to each promise's value
		 * @param {Array} promises array of promises
		 * @returns {Promise} promise for transformed values
		 */
		function traverse(f, promises) {
			return traverseWith(tryCatch2, f, promises);
		}

		function traverseWith(tryMap, f, promises) {
			var handler = typeof f === 'function' ? mapAt : settleAt;

			var resolver = new Pending();
			var pending = promises.length >>> 0;
			var results = new Array(pending);

			for (var i = 0, x; i < promises.length && !resolver.resolved; ++i) {
				x = promises[i];

				if (x === void 0 && !(i in promises)) {
					--pending;
					continue;
				}

				traverseAt(promises, handler, i, x, resolver);
			}

			if(pending === 0) {
				resolver.become(new Fulfilled(results));
			}

			return new Promise(Handler, resolver);

			function mapAt(i, x, resolver) {
				if(!resolver.resolved) {
					traverseAt(promises, settleAt, i, tryMap(f, x, i), resolver);
				}
			}

			function settleAt(i, x, resolver) {
				results[i] = x;
				if(--pending === 0) {
					resolver.become(new Fulfilled(results));
				}
			}
		}

		function traverseAt(promises, handler, i, x, resolver) {
			if (maybeThenable(x)) {
				var h = getHandlerMaybeThenable(x);
				var s = h.state();

				if (s === 0) {
					h.fold(handler, i, void 0, resolver);
				} else if (s > 0) {
					handler(i, h.value, resolver);
				} else {
					resolver.become(h);
					visitRemaining(promises, i+1, h);
				}
			} else {
				handler(i, x, resolver);
			}
		}

		Promise._visitRemaining = visitRemaining;
		function visitRemaining(promises, start, handler) {
			for(var i=start; i<promises.length; ++i) {
				markAsHandled(getHandler(promises[i]), handler);
			}
		}

		function markAsHandled(h, handler) {
			if(h === handler) {
				return;
			}

			var s = h.state();
			if(s === 0) {
				h.visit(h, void 0, h._unreport);
			} else if(s < 0) {
				h._unreport();
			}
		}

		/**
		 * Fulfill-reject competitive race. Return a promise that will settle
		 * to the same state as the earliest input promise to settle.
		 *
		 * WARNING: The ES6 Promise spec requires that race()ing an empty array
		 * must return a promise that is pending forever.  This implementation
		 * returns a singleton forever-pending promise, the same singleton that is
		 * returned by Promise.never(), thus can be checked with ===
		 *
		 * @param {array} promises array of promises to race
		 * @returns {Promise} if input is non-empty, a promise that will settle
		 * to the same outcome as the earliest input promise to settle. if empty
		 * is empty, returns a promise that will never settle.
		 */
		function race(promises) {
			if(typeof promises !== 'object' || promises === null) {
				return reject(new TypeError('non-iterable passed to race()'));
			}

			// Sigh, race([]) is untestable unless we return *something*
			// that is recognizable without calling .then() on it.
			return promises.length === 0 ? never()
				 : promises.length === 1 ? resolve(promises[0])
				 : runRace(promises);
		}

		function runRace(promises) {
			var resolver = new Pending();
			var i, x, h;
			for(i=0; i<promises.length; ++i) {
				x = promises[i];
				if (x === void 0 && !(i in promises)) {
					continue;
				}

				h = getHandler(x);
				if(h.state() !== 0) {
					resolver.become(h);
					visitRemaining(promises, i+1, h);
					break;
				} else {
					h.visit(resolver, resolver.resolve, resolver.reject);
				}
			}
			return new Promise(Handler, resolver);
		}

		// Promise internals
		// Below this, everything is @private

		/**
		 * Get an appropriate handler for x, without checking for cycles
		 * @param {*} x
		 * @returns {object} handler
		 */
		function getHandler(x) {
			if(isPromise(x)) {
				return x._handler.join();
			}
			return maybeThenable(x) ? getHandlerUntrusted(x) : new Fulfilled(x);
		}

		/**
		 * Get a handler for thenable x.
		 * NOTE: You must only call this if maybeThenable(x) == true
		 * @param {object|function|Promise} x
		 * @returns {object} handler
		 */
		function getHandlerMaybeThenable(x) {
			return isPromise(x) ? x._handler.join() : getHandlerUntrusted(x);
		}

		/**
		 * Get a handler for potentially untrusted thenable x
		 * @param {*} x
		 * @returns {object} handler
		 */
		function getHandlerUntrusted(x) {
			try {
				var untrustedThen = x.then;
				return typeof untrustedThen === 'function'
					? new Thenable(untrustedThen, x)
					: new Fulfilled(x);
			} catch(e) {
				return new Rejected(e);
			}
		}

		/**
		 * Handler for a promise that is pending forever
		 * @constructor
		 */
		function Handler() {}

		Handler.prototype.when
			= Handler.prototype.become
			= Handler.prototype.notify // deprecated
			= Handler.prototype.fail
			= Handler.prototype._unreport
			= Handler.prototype._report
			= noop;

		Handler.prototype._state = 0;

		Handler.prototype.state = function() {
			return this._state;
		};

		/**
		 * Recursively collapse handler chain to find the handler
		 * nearest to the fully resolved value.
		 * @returns {object} handler nearest the fully resolved value
		 */
		Handler.prototype.join = function() {
			var h = this;
			while(h.handler !== void 0) {
				h = h.handler;
			}
			return h;
		};

		Handler.prototype.chain = function(to, receiver, fulfilled, rejected, progress) {
			this.when({
				resolver: to,
				receiver: receiver,
				fulfilled: fulfilled,
				rejected: rejected,
				progress: progress
			});
		};

		Handler.prototype.visit = function(receiver, fulfilled, rejected, progress) {
			this.chain(failIfRejected, receiver, fulfilled, rejected, progress);
		};

		Handler.prototype.fold = function(f, z, c, to) {
			this.when(new Fold(f, z, c, to));
		};

		/**
		 * Handler that invokes fail() on any handler it becomes
		 * @constructor
		 */
		function FailIfRejected() {}

		inherit(Handler, FailIfRejected);

		FailIfRejected.prototype.become = function(h) {
			h.fail();
		};

		var failIfRejected = new FailIfRejected();

		/**
		 * Handler that manages a queue of consumers waiting on a pending promise
		 * @constructor
		 */
		function Pending(receiver, inheritedContext) {
			Promise.createContext(this, inheritedContext);

			this.consumers = void 0;
			this.receiver = receiver;
			this.handler = void 0;
			this.resolved = false;
		}

		inherit(Handler, Pending);

		Pending.prototype._state = 0;

		Pending.prototype.resolve = function(x) {
			this.become(getHandler(x));
		};

		Pending.prototype.reject = function(x) {
			if(this.resolved) {
				return;
			}

			this.become(new Rejected(x));
		};

		Pending.prototype.join = function() {
			if (!this.resolved) {
				return this;
			}

			var h = this;

			while (h.handler !== void 0) {
				h = h.handler;
				if (h === this) {
					return this.handler = cycle();
				}
			}

			return h;
		};

		Pending.prototype.run = function() {
			var q = this.consumers;
			var handler = this.handler;
			this.handler = this.handler.join();
			this.consumers = void 0;

			for (var i = 0; i < q.length; ++i) {
				handler.when(q[i]);
			}
		};

		Pending.prototype.become = function(handler) {
			if(this.resolved) {
				return;
			}

			this.resolved = true;
			this.handler = handler;
			if(this.consumers !== void 0) {
				tasks.enqueue(this);
			}

			if(this.context !== void 0) {
				handler._report(this.context);
			}
		};

		Pending.prototype.when = function(continuation) {
			if(this.resolved) {
				tasks.enqueue(new ContinuationTask(continuation, this.handler));
			} else {
				if(this.consumers === void 0) {
					this.consumers = [continuation];
				} else {
					this.consumers.push(continuation);
				}
			}
		};

		/**
		 * @deprecated
		 */
		Pending.prototype.notify = function(x) {
			if(!this.resolved) {
				tasks.enqueue(new ProgressTask(x, this));
			}
		};

		Pending.prototype.fail = function(context) {
			var c = typeof context === 'undefined' ? this.context : context;
			this.resolved && this.handler.join().fail(c);
		};

		Pending.prototype._report = function(context) {
			this.resolved && this.handler.join()._report(context);
		};

		Pending.prototype._unreport = function() {
			this.resolved && this.handler.join()._unreport();
		};

		/**
		 * Wrap another handler and force it into a future stack
		 * @param {object} handler
		 * @constructor
		 */
		function Async(handler) {
			this.handler = handler;
		}

		inherit(Handler, Async);

		Async.prototype.when = function(continuation) {
			tasks.enqueue(new ContinuationTask(continuation, this));
		};

		Async.prototype._report = function(context) {
			this.join()._report(context);
		};

		Async.prototype._unreport = function() {
			this.join()._unreport();
		};

		/**
		 * Handler that wraps an untrusted thenable and assimilates it in a future stack
		 * @param {function} then
		 * @param {{then: function}} thenable
		 * @constructor
		 */
		function Thenable(then, thenable) {
			Pending.call(this);
			tasks.enqueue(new AssimilateTask(then, thenable, this));
		}

		inherit(Pending, Thenable);

		/**
		 * Handler for a fulfilled promise
		 * @param {*} x fulfillment value
		 * @constructor
		 */
		function Fulfilled(x) {
			Promise.createContext(this);
			this.value = x;
		}

		inherit(Handler, Fulfilled);

		Fulfilled.prototype._state = 1;

		Fulfilled.prototype.fold = function(f, z, c, to) {
			runContinuation3(f, z, this, c, to);
		};

		Fulfilled.prototype.when = function(cont) {
			runContinuation1(cont.fulfilled, this, cont.receiver, cont.resolver);
		};

		var errorId = 0;

		/**
		 * Handler for a rejected promise
		 * @param {*} x rejection reason
		 * @constructor
		 */
		function Rejected(x) {
			Promise.createContext(this);

			this.id = ++errorId;
			this.value = x;
			this.handled = false;
			this.reported = false;

			this._report();
		}

		inherit(Handler, Rejected);

		Rejected.prototype._state = -1;

		Rejected.prototype.fold = function(f, z, c, to) {
			to.become(this);
		};

		Rejected.prototype.when = function(cont) {
			if(typeof cont.rejected === 'function') {
				this._unreport();
			}
			runContinuation1(cont.rejected, this, cont.receiver, cont.resolver);
		};

		Rejected.prototype._report = function(context) {
			tasks.afterQueue(new ReportTask(this, context));
		};

		Rejected.prototype._unreport = function() {
			if(this.handled) {
				return;
			}
			this.handled = true;
			tasks.afterQueue(new UnreportTask(this));
		};

		Rejected.prototype.fail = function(context) {
			this.reported = true;
			emitRejection('unhandledRejection', this);
			Promise.onFatalRejection(this, context === void 0 ? this.context : context);
		};

		function ReportTask(rejection, context) {
			this.rejection = rejection;
			this.context = context;
		}

		ReportTask.prototype.run = function() {
			if(!this.rejection.handled && !this.rejection.reported) {
				this.rejection.reported = true;
				emitRejection('unhandledRejection', this.rejection) ||
					Promise.onPotentiallyUnhandledRejection(this.rejection, this.context);
			}
		};

		function UnreportTask(rejection) {
			this.rejection = rejection;
		}

		UnreportTask.prototype.run = function() {
			if(this.rejection.reported) {
				emitRejection('rejectionHandled', this.rejection) ||
					Promise.onPotentiallyUnhandledRejectionHandled(this.rejection);
			}
		};

		// Unhandled rejection hooks
		// By default, everything is a noop

		Promise.createContext
			= Promise.enterContext
			= Promise.exitContext
			= Promise.onPotentiallyUnhandledRejection
			= Promise.onPotentiallyUnhandledRejectionHandled
			= Promise.onFatalRejection
			= noop;

		// Errors and singletons

		var foreverPendingHandler = new Handler();
		var foreverPendingPromise = new Promise(Handler, foreverPendingHandler);

		function cycle() {
			return new Rejected(new TypeError('Promise cycle'));
		}

		// Task runners

		/**
		 * Run a single consumer
		 * @constructor
		 */
		function ContinuationTask(continuation, handler) {
			this.continuation = continuation;
			this.handler = handler;
		}

		ContinuationTask.prototype.run = function() {
			this.handler.join().when(this.continuation);
		};

		/**
		 * Run a queue of progress handlers
		 * @constructor
		 */
		function ProgressTask(value, handler) {
			this.handler = handler;
			this.value = value;
		}

		ProgressTask.prototype.run = function() {
			var q = this.handler.consumers;
			if(q === void 0) {
				return;
			}

			for (var c, i = 0; i < q.length; ++i) {
				c = q[i];
				runNotify(c.progress, this.value, this.handler, c.receiver, c.resolver);
			}
		};

		/**
		 * Assimilate a thenable, sending it's value to resolver
		 * @param {function} then
		 * @param {object|function} thenable
		 * @param {object} resolver
		 * @constructor
		 */
		function AssimilateTask(then, thenable, resolver) {
			this._then = then;
			this.thenable = thenable;
			this.resolver = resolver;
		}

		AssimilateTask.prototype.run = function() {
			var h = this.resolver;
			tryAssimilate(this._then, this.thenable, _resolve, _reject, _notify);

			function _resolve(x) { h.resolve(x); }
			function _reject(x)  { h.reject(x); }
			function _notify(x)  { h.notify(x); }
		};

		function tryAssimilate(then, thenable, resolve, reject, notify) {
			try {
				then.call(thenable, resolve, reject, notify);
			} catch (e) {
				reject(e);
			}
		}

		/**
		 * Fold a handler value with z
		 * @constructor
		 */
		function Fold(f, z, c, to) {
			this.f = f; this.z = z; this.c = c; this.to = to;
			this.resolver = failIfRejected;
			this.receiver = this;
		}

		Fold.prototype.fulfilled = function(x) {
			this.f.call(this.c, this.z, x, this.to);
		};

		Fold.prototype.rejected = function(x) {
			this.to.reject(x);
		};

		Fold.prototype.progress = function(x) {
			this.to.notify(x);
		};

		// Other helpers

		/**
		 * @param {*} x
		 * @returns {boolean} true iff x is a trusted Promise
		 */
		function isPromise(x) {
			return x instanceof Promise;
		}

		/**
		 * Test just enough to rule out primitives, in order to take faster
		 * paths in some code
		 * @param {*} x
		 * @returns {boolean} false iff x is guaranteed *not* to be a thenable
		 */
		function maybeThenable(x) {
			return (typeof x === 'object' || typeof x === 'function') && x !== null;
		}

		function runContinuation1(f, h, receiver, next) {
			if(typeof f !== 'function') {
				return next.become(h);
			}

			Promise.enterContext(h);
			tryCatchReject(f, h.value, receiver, next);
			Promise.exitContext();
		}

		function runContinuation3(f, x, h, receiver, next) {
			if(typeof f !== 'function') {
				return next.become(h);
			}

			Promise.enterContext(h);
			tryCatchReject3(f, x, h.value, receiver, next);
			Promise.exitContext();
		}

		/**
		 * @deprecated
		 */
		function runNotify(f, x, h, receiver, next) {
			if(typeof f !== 'function') {
				return next.notify(x);
			}

			Promise.enterContext(h);
			tryCatchReturn(f, x, receiver, next);
			Promise.exitContext();
		}

		function tryCatch2(f, a, b) {
			try {
				return f(a, b);
			} catch(e) {
				return reject(e);
			}
		}

		/**
		 * Return f.call(thisArg, x), or if it throws return a rejected promise for
		 * the thrown exception
		 */
		function tryCatchReject(f, x, thisArg, next) {
			try {
				next.become(getHandler(f.call(thisArg, x)));
			} catch(e) {
				next.become(new Rejected(e));
			}
		}

		/**
		 * Same as above, but includes the extra argument parameter.
		 */
		function tryCatchReject3(f, x, y, thisArg, next) {
			try {
				f.call(thisArg, x, y, next);
			} catch(e) {
				next.become(new Rejected(e));
			}
		}

		/**
		 * @deprecated
		 * Return f.call(thisArg, x), or if it throws, *return* the exception
		 */
		function tryCatchReturn(f, x, thisArg, next) {
			try {
				next.notify(f.call(thisArg, x));
			} catch(e) {
				next.notify(e);
			}
		}

		function inherit(Parent, Child) {
			Child.prototype = objectCreate(Parent.prototype);
			Child.prototype.constructor = Child;
		}

		function snd(x, y) {
			return y;
		}

		function noop() {}

		function initEmitRejection() {
			/*global process, self, CustomEvent*/
			if(typeof process !== 'undefined' && process !== null
				&& typeof process.emit === 'function') {
				// Returning falsy here means to call the default
				// onPotentiallyUnhandledRejection API.  This is safe even in
				// browserify since process.emit always returns falsy in browserify:
				// https://github.com/defunctzombie/node-process/blob/master/browser.js#L40-L46
				return function(type, rejection) {
					return type === 'unhandledRejection'
						? process.emit(type, rejection.value, rejection)
						: process.emit(type, rejection);
				};
			} else if(typeof self !== 'undefined' && typeof CustomEvent === 'function') {
				return (function(noop, self, CustomEvent) {
					var hasCustomEvent = false;
					try {
						var ev = new CustomEvent('unhandledRejection');
						hasCustomEvent = ev instanceof CustomEvent;
					} catch (e) {}

					return !hasCustomEvent ? noop : function(type, rejection) {
						var ev = new CustomEvent(type, {
							detail: {
								reason: rejection.value,
								key: rejection
							},
							bubbles: false,
							cancelable: true
						});

						return !self.dispatchEvent(ev);
					};
				}(noop, self, CustomEvent));
			}

			return noop;
		}

		return Promise;
	};
});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));

}).call(this,require('_process'))
},{"_process":680}],755:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */
/** @author Brian Cavalier */
/** @author John Hann */

(function(define) { 'use strict';
define(function() {

	return {
		pending: toPendingState,
		fulfilled: toFulfilledState,
		rejected: toRejectedState,
		inspect: inspect
	};

	function toPendingState() {
		return { state: 'pending' };
	}

	function toRejectedState(e) {
		return { state: 'rejected', reason: e };
	}

	function toFulfilledState(x) {
		return { state: 'fulfilled', value: x };
	}

	function inspect(handler) {
		var state = handler.state();
		return state === 0 ? toPendingState()
			 : state > 0   ? toFulfilledState(handler.value)
			               : toRejectedState(handler.value);
	}

});
}(typeof define === 'function' && define.amd ? define : function(factory) { module.exports = factory(); }));

},{}],756:[function(require,module,exports){
/** @license MIT License (c) copyright 2013 original author or authors */

/**
 * Collection of helpers for interfacing with node-style asynchronous functions
 * using promises.
 *
 * @author Brian Cavalier
 * @contributor Renato Zannon
 */

(function(define) {
define(function(require) {

	var when = require('./when');
	var _liftAll = require('./lib/liftAll');
	var setTimer = require('./lib/env').setTimer;
	var slice = Array.prototype.slice;

	var _apply = require('./lib/apply')(when.Promise, dispatch);

	return {
		lift: lift,
		liftAll: liftAll,
		apply: apply,
		call: call,
		createCallback: createCallback,
		bindCallback: bindCallback,
		liftCallback: liftCallback
	};

	/**
	 * Takes a node-style async function and calls it immediately (with an optional
	 * array of arguments or promises for arguments). It returns a promise whose
	 * resolution depends on whether the async functions calls its callback with the
	 * conventional error argument or not.
	 *
	 * With this it becomes possible to leverage existing APIs while still reaping
	 * the benefits of promises.
	 *
	 * @example
	 *    function onlySmallNumbers(n, callback) {
	 *		if(n < 10) {
	 *			callback(null, n + 10);
	 *		} else {
	 *			callback(new Error("Calculation failed"));
	 *		}
	 *	}
	 *
	 *    var nodefn = require("when/node/function");
	 *
	 *    // Logs '15'
	 *    nodefn.apply(onlySmallNumbers, [5]).then(console.log, console.error);
	 *
	 *    // Logs 'Calculation failed'
	 *    nodefn.apply(onlySmallNumbers, [15]).then(console.log, console.error);
	 *
	 * @param {function} f node-style function that will be called
	 * @param {Array} [args] array of arguments to func
	 * @returns {Promise} promise for the value func passes to its callback
	 */
	function apply(f, args) {
		return _apply(f, this, args || []);
	}

	function dispatch(f, thisArg, args, h) {
		var cb = createCallback(h);
		try {
			switch(args.length) {
				case 2: f.call(thisArg, args[0], args[1], cb); break;
				case 1: f.call(thisArg, args[0], cb); break;
				case 0: f.call(thisArg, cb); break;
				default:
					args.push(cb);
					f.apply(thisArg, args);
			}
		} catch(e) {
			h.reject(e);
		}
	}

	/**
	 * Has the same behavior that {@link apply} has, with the difference that the
	 * arguments to the function are provided individually, while {@link apply} accepts
	 * a single array.
	 *
	 * @example
	 *    function sumSmallNumbers(x, y, callback) {
	 *		var result = x + y;
	 *		if(result < 10) {
	 *			callback(null, result);
	 *		} else {
	 *			callback(new Error("Calculation failed"));
	 *		}
	 *	}
	 *
	 *    // Logs '5'
	 *    nodefn.call(sumSmallNumbers, 2, 3).then(console.log, console.error);
	 *
	 *    // Logs 'Calculation failed'
	 *    nodefn.call(sumSmallNumbers, 5, 10).then(console.log, console.error);
	 *
	 * @param {function} f node-style function that will be called
	 * @param {...*} [args] arguments that will be forwarded to the function
	 * @returns {Promise} promise for the value func passes to its callback
	 */
	function call(f /*, args... */) {
		return _apply(f, this, slice.call(arguments, 1));
	}

	/**
	 * Takes a node-style function and returns new function that wraps the
	 * original and, instead of taking a callback, returns a promise. Also, it
	 * knows how to handle promises given as arguments, waiting for their
	 * resolution before executing.
	 *
	 * Upon execution, the orginal function is executed as well. If it passes
	 * a truthy value as the first argument to the callback, it will be
	 * interpreted as an error condition, and the promise will be rejected
	 * with it. Otherwise, the call is considered a resolution, and the promise
	 * is resolved with the callback's second argument.
	 *
	 * @example
	 *    var fs = require("fs"), nodefn = require("when/node/function");
	 *
	 *    var promiseRead = nodefn.lift(fs.readFile);
	 *
	 *    // The promise is resolved with the contents of the file if everything
	 *    // goes ok
	 *    promiseRead('exists.txt').then(console.log, console.error);
	 *
	 *    // And will be rejected if something doesn't work out
	 *    // (e.g. the files does not exist)
	 *    promiseRead('doesnt_exist.txt').then(console.log, console.error);
	 *
	 *
	 * @param {Function} f node-style function to be lifted
	 * @param {...*} [args] arguments to be prepended for the new function @deprecated
	 * @returns {Function} a promise-returning function
	 */
	function lift(f /*, args... */) {
		var args1 = arguments.length > 1 ? slice.call(arguments, 1) : [];
		return function() {
			// TODO: Simplify once partialing has been removed
			var l = args1.length;
			var al = arguments.length;
			var args = new Array(al + l);
			var i;
			for(i=0; i<l; ++i) {
				args[i] = args1[i];
			}
			for(i=0; i<al; ++i) {
				args[i+l] = arguments[i];
			}
			return _apply(f, this, args);
		};
	}

	/**
	 * Lift all the functions/methods on src
	 * @param {object|function} src source whose functions will be lifted
	 * @param {function?} combine optional function for customizing the lifting
	 *  process. It is passed dst, the lifted function, and the property name of
	 *  the original function on src.
	 * @param {(object|function)?} dst option destination host onto which to place lifted
	 *  functions. If not provided, liftAll returns a new object.
	 * @returns {*} If dst is provided, returns dst with lifted functions as
	 *  properties.  If dst not provided, returns a new object with lifted functions.
	 */
	function liftAll(src, combine, dst) {
		return _liftAll(lift, combine, dst, src);
	}

	/**
	 * Takes an object that responds to the resolver interface, and returns
	 * a function that will resolve or reject it depending on how it is called.
	 *
	 * @example
	 *	function callbackTakingFunction(callback) {
	 *		if(somethingWrongHappened) {
	 *			callback(error);
	 *		} else {
	 *			callback(null, interestingValue);
	 *		}
	 *	}
	 *
	 *	var when = require('when'), nodefn = require('when/node/function');
	 *
	 *	var deferred = when.defer();
	 *	callbackTakingFunction(nodefn.createCallback(deferred.resolver));
	 *
	 *	deferred.promise.then(function(interestingValue) {
	 *		// Use interestingValue
	 *	});
	 *
	 * @param {Resolver} resolver that will be 'attached' to the callback
	 * @returns {Function} a node-style callback function
	 */
	function createCallback(resolver) {
		return function(err, value) {
			if(err) {
				resolver.reject(err);
			} else if(arguments.length > 2) {
				resolver.resolve(slice.call(arguments, 1));
			} else {
				resolver.resolve(value);
			}
		};
	}

	/**
	 * Attaches a node-style callback to a promise, ensuring the callback is
	 * called for either fulfillment or rejection. Returns a promise with the same
	 * state as the passed-in promise.
	 *
	 * @example
	 *	var deferred = when.defer();
	 *
	 *	function callback(err, value) {
	 *		// Handle err or use value
	 *	}
	 *
	 *	bindCallback(deferred.promise, callback);
	 *
	 *	deferred.resolve('interesting value');
	 *
	 * @param {Promise} promise The promise to be attached to.
	 * @param {Function} callback The node-style callback to attach.
	 * @returns {Promise} A promise with the same state as the passed-in promise.
	 */
	function bindCallback(promise, callback) {
		promise = when(promise);

		if (callback) {
			promise.then(success, wrapped);
		}

		return promise;

		function success(value) {
			wrapped(null, value);
		}

		function wrapped(err, value) {
			setTimer(function () {
				callback(err, value);
			}, 0);
		}
	}

	/**
	 * Takes a node-style callback and returns new function that accepts a
	 * promise, calling the original callback when the promise is either
	 * fulfilled or rejected with the appropriate arguments.
	 *
	 * @example
	 *	var deferred = when.defer();
	 *
	 *	function callback(err, value) {
	 *		// Handle err or use value
	 *	}
	 *
	 *	var wrapped = liftCallback(callback);
	 *
	 *	// `wrapped` can now be passed around at will
	 *	wrapped(deferred.promise);
	 *
	 *	deferred.resolve('interesting value');
	 *
	 * @param {Function} callback The node-style callback to wrap.
	 * @returns {Function} The lifted, promise-accepting function.
	 */
	function liftCallback(callback) {
		return function(promise) {
			return bindCallback(promise, callback);
		};
	}
});

})(typeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); });




},{"./lib/apply":741,"./lib/env":751,"./lib/liftAll":753,"./when":757}],757:[function(require,module,exports){
/** @license MIT License (c) copyright 2010-2014 original author or authors */

/**
 * Promises/A+ and when() implementation
 * when is part of the cujoJS family of libraries (http://cujojs.com/)
 * @author Brian Cavalier
 * @author John Hann
 */
(function(define) { 'use strict';
define(function (require) {

	var timed = require('./lib/decorators/timed');
	var array = require('./lib/decorators/array');
	var flow = require('./lib/decorators/flow');
	var fold = require('./lib/decorators/fold');
	var inspect = require('./lib/decorators/inspect');
	var generate = require('./lib/decorators/iterate');
	var progress = require('./lib/decorators/progress');
	var withThis = require('./lib/decorators/with');
	var unhandledRejection = require('./lib/decorators/unhandledRejection');
	var TimeoutError = require('./lib/TimeoutError');

	var Promise = [array, flow, fold, generate, progress,
		inspect, withThis, timed, unhandledRejection]
		.reduce(function(Promise, feature) {
			return feature(Promise);
		}, require('./lib/Promise'));

	var apply = require('./lib/apply')(Promise);

	// Public API

	when.promise     = promise;              // Create a pending promise
	when.resolve     = Promise.resolve;      // Create a resolved promise
	when.reject      = Promise.reject;       // Create a rejected promise

	when.lift        = lift;                 // lift a function to return promises
	when['try']      = attempt;              // call a function and return a promise
	when.attempt     = attempt;              // alias for when.try

	when.iterate     = Promise.iterate;      // DEPRECATED (use cujojs/most streams) Generate a stream of promises
	when.unfold      = Promise.unfold;       // DEPRECATED (use cujojs/most streams) Generate a stream of promises

	when.join        = join;                 // Join 2 or more promises

	when.all         = all;                  // Resolve a list of promises
	when.settle      = settle;               // Settle a list of promises

	when.any         = lift(Promise.any);    // One-winner race
	when.some        = lift(Promise.some);   // Multi-winner race
	when.race        = lift(Promise.race);   // First-to-settle race

	when.map         = map;                  // Array.map() for promises
	when.filter      = filter;               // Array.filter() for promises
	when.reduce      = lift(Promise.reduce);       // Array.reduce() for promises
	when.reduceRight = lift(Promise.reduceRight);  // Array.reduceRight() for promises

	when.isPromiseLike = isPromiseLike;      // Is something promise-like, aka thenable

	when.Promise     = Promise;              // Promise constructor
	when.defer       = defer;                // Create a {promise, resolve, reject} tuple

	// Error types

	when.TimeoutError = TimeoutError;

	/**
	 * Get a trusted promise for x, or by transforming x with onFulfilled
	 *
	 * @param {*} x
	 * @param {function?} onFulfilled callback to be called when x is
	 *   successfully fulfilled.  If promiseOrValue is an immediate value, callback
	 *   will be invoked immediately.
	 * @param {function?} onRejected callback to be called when x is
	 *   rejected.
	 * @param {function?} onProgress callback to be called when progress updates
	 *   are issued for x. @deprecated
	 * @returns {Promise} a new promise that will fulfill with the return
	 *   value of callback or errback or the completion value of promiseOrValue if
	 *   callback and/or errback is not supplied.
	 */
	function when(x, onFulfilled, onRejected, onProgress) {
		var p = Promise.resolve(x);
		if (arguments.length < 2) {
			return p;
		}

		return p.then(onFulfilled, onRejected, onProgress);
	}

	/**
	 * Creates a new promise whose fate is determined by resolver.
	 * @param {function} resolver function(resolve, reject, notify)
	 * @returns {Promise} promise whose fate is determine by resolver
	 */
	function promise(resolver) {
		return new Promise(resolver);
	}

	/**
	 * Lift the supplied function, creating a version of f that returns
	 * promises, and accepts promises as arguments.
	 * @param {function} f
	 * @returns {Function} version of f that returns promises
	 */
	function lift(f) {
		return function() {
			for(var i=0, l=arguments.length, a=new Array(l); i<l; ++i) {
				a[i] = arguments[i];
			}
			return apply(f, this, a);
		};
	}

	/**
	 * Call f in a future turn, with the supplied args, and return a promise
	 * for the result.
	 * @param {function} f
	 * @returns {Promise}
	 */
	function attempt(f /*, args... */) {
		/*jshint validthis:true */
		for(var i=0, l=arguments.length-1, a=new Array(l); i<l; ++i) {
			a[i] = arguments[i+1];
		}
		return apply(f, this, a);
	}

	/**
	 * Creates a {promise, resolver} pair, either or both of which
	 * may be given out safely to consumers.
	 * @return {{promise: Promise, resolve: function, reject: function, notify: function}}
	 */
	function defer() {
		return new Deferred();
	}

	function Deferred() {
		var p = Promise._defer();

		function resolve(x) { p._handler.resolve(x); }
		function reject(x) { p._handler.reject(x); }
		function notify(x) { p._handler.notify(x); }

		this.promise = p;
		this.resolve = resolve;
		this.reject = reject;
		this.notify = notify;
		this.resolver = { resolve: resolve, reject: reject, notify: notify };
	}

	/**
	 * Determines if x is promise-like, i.e. a thenable object
	 * NOTE: Will return true for *any thenable object*, and isn't truly
	 * safe, since it may attempt to access the `then` property of x (i.e.
	 *  clever/malicious getters may do weird things)
	 * @param {*} x anything
	 * @returns {boolean} true if x is promise-like
	 */
	function isPromiseLike(x) {
		return x && typeof x.then === 'function';
	}

	/**
	 * Return a promise that will resolve only once all the supplied arguments
	 * have resolved. The resolution value of the returned promise will be an array
	 * containing the resolution values of each of the arguments.
	 * @param {...*} arguments may be a mix of promises and values
	 * @returns {Promise}
	 */
	function join(/* ...promises */) {
		return Promise.all(arguments);
	}

	/**
	 * Return a promise that will fulfill once all input promises have
	 * fulfilled, or reject when any one input promise rejects.
	 * @param {array|Promise} promises array (or promise for an array) of promises
	 * @returns {Promise}
	 */
	function all(promises) {
		return when(promises, Promise.all);
	}

	/**
	 * Return a promise that will always fulfill with an array containing
	 * the outcome states of all input promises.  The returned promise
	 * will only reject if `promises` itself is a rejected promise.
	 * @param {array|Promise} promises array (or promise for an array) of promises
	 * @returns {Promise} promise for array of settled state descriptors
	 */
	function settle(promises) {
		return when(promises, Promise.settle);
	}

	/**
	 * Promise-aware array map function, similar to `Array.prototype.map()`,
	 * but input array may contain promises or values.
	 * @param {Array|Promise} promises array of anything, may contain promises and values
	 * @param {function(x:*, index:Number):*} mapFunc map function which may
	 *  return a promise or value
	 * @returns {Promise} promise that will fulfill with an array of mapped values
	 *  or reject if any input promise rejects.
	 */
	function map(promises, mapFunc) {
		return when(promises, function(promises) {
			return Promise.map(promises, mapFunc);
		});
	}

	/**
	 * Filter the provided array of promises using the provided predicate.  Input may
	 * contain promises and values
	 * @param {Array|Promise} promises array of promises and values
	 * @param {function(x:*, index:Number):boolean} predicate filtering predicate.
	 *  Must return truthy (or promise for truthy) for items to retain.
	 * @returns {Promise} promise that will fulfill with an array containing all items
	 *  for which predicate returned truthy.
	 */
	function filter(promises, predicate) {
		return when(promises, function(promises) {
			return Promise.filter(promises, predicate);
		});
	}

	return when;
});
})(typeof define === 'function' && define.amd ? define : function (factory) { module.exports = factory(require); });

},{"./lib/Promise":738,"./lib/TimeoutError":740,"./lib/apply":741,"./lib/decorators/array":742,"./lib/decorators/flow":743,"./lib/decorators/fold":744,"./lib/decorators/inspect":745,"./lib/decorators/iterate":746,"./lib/decorators/progress":747,"./lib/decorators/timed":748,"./lib/decorators/unhandledRejection":749,"./lib/decorators/with":750}],758:[function(require,module,exports){
/* eslint-disable no-unused-vars */
'use strict';

var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

module.exports = Object.assign || function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (Object.getOwnPropertySymbols) {
			symbols = Object.getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};

},{}]},{},[82]);
